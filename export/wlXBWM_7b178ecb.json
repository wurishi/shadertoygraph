{"ver":"0.1","info":{"id":"wlXBWM","date":"1596913459","viewed":936,"name":"Line Segment Depth-of-Field","username":"fizzer","description":"Modelling the usual volume of jittered rays for sampled depth-of-field as a cone, the sampling integral can be approximated by intersection tests of line segments against this cone. Maybe other DoF-like effects can be done this way too?","likes":66,"published":1,"flags":0,"usePreview":0,"tags":["wireframe","landscape","depthoffield","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265358979323;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Originally from https://www.shadertoy.com/view/llcfRf\n// Modified to remove the caps and return the whole intersection interval.\nvec2 iCappedCone2( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m3 = dot(rd,ba);\n\n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec2(-1.0);\n\n    return ((vec2(-1, +1) * sqrt(h)) - k1) / k2;\n}\n\n// Originally from https://www.shadertoy.com/view/4lcSRn\n// Modified to remove the caps and return the whole intersection interval.\nvec2 iCylinder2( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in float ra ) // point a, point b, radius\n{\n    // center the cylinder, normalize axis\n    vec3 cc = 0.5*(pa+pb);\n    float ch = length(pb-pa);\n    vec3 ca = (pb-pa)/ch;\n    ch *= 0.5;\n\n    vec3  oc = ro - cc;\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0);\n    \n    return ((vec2(-1, +1) * sqrt(h)) - b) / a;\n}\n\nfloat dofLine(vec3 c0, vec3 c1, float ra, vec3 p0, vec3 p1)\n{\n    float dlen = length(p1 - p0);\n    vec3 dir = (p1 - p0) / dlen;\n    \n    // Test for intersection of the line segment with the cone of defocused rays.\n    \n    vec2 res = iCappedCone2(p0, dir, c0, c1, ra, 0.);\n    \n    if(res.y < 0. || res.x > dlen)\n    {\n        // To avoid rendering subpixel-sized lines which would end up being heavily under-sampled,\n        // the center of the defocus cone is modelled as a thick cylinder.\n        \n        vec2 res2 = iCylinder2(p0, dir, c0, c1, 2e-3);\n\n        if(res2.y > res2.x && res2.y > 0. && res2.x < dlen)\n        {\n            res.x = min(res.x, res2.x);\n            res.y = max(res.y, res2.y);\n        }\n        \n        if(res.y < 0. || res.x > dlen)\n            return 0.;\n    }\n    \n    vec3 q0 = p0 + dir * res.x;\n    vec3 q1 = p0 + dir * res.y;\n\n    // Contribution is modelled somewhat on the usual monte carlo raytracing.\n    // This amounts to integrating coverage of a varying disc by a small point.\n    // Function to integrate is: 1 / (pi * ((a * x + b) ^ 2))\n    // Integral is: -1 / (pi * a * a * x + pi * a * b)\n    \n    vec3 cd = c1 - c0;\n    float cl2 = ra / dot(cd, cd);\n\n    float z0 = dot(q0 - c1, cd);\n    float z1 = dot(q1 - c1, cd);\n\n    float a = cl2 * (z1 - z0);\n    float b = cl2 * z0;\n\n    float i0 = pi * a * b;\n    float i1 = pi * a * (a + b);\n    \n    i0 = 1e-4 / max(1e-10, abs(i0)) * sign(i0);\n\ti1 = 1e-4 / max(1e-10, abs(i1)) * sign(i1);\n    \n    return min(1., abs(i1 - i0));\n}\n\n\nfloat heightmap(vec2 uv)\n{\n    return (texture(iChannel0, uv.yx / 256.).r - .1) * 2.;\n}\n    \nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0., -sin(a), cos(a), 0., 0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(-0.2, 1., 0.);\n    vec3 focus = ro + vec3(uv.xy, -3.5);\n\n    float ra = .08;\n    float t = iTime / 2.;\n    \n    mat3 m = rotX(.23);\n\n    vec3 col = vec3(0.0);\n\n    // Landscape.\n    \n    for(int y = -14; y < -1; ++y)\n    {\n        vec3 ps[4];\n\t\tfor(int x = -6; x < 6; ++x)\n        {            \n            ps[1] = ps[0];\n            ps[3] = ps[2];\n            ps[0] = vec3(float(x + 0), 0, float(y + 0)) / 2.;\n            ps[2] = vec3(float(x + 0), 0, float(y + 1)) / 2.;\n            \n            ps[0].y = heightmap(ps[0].xz + vec2(0., -floor(t))) + cos(iTime / 3.) * .1;\n            ps[0].z += fract(t);\n            ps[0] = m * ps[0];\n\n            ps[2].y = heightmap(ps[2].xz + vec2(0., -floor(t))) + cos(iTime / 3.) * .1;\n            ps[2].z += fract(t);\n            ps[2] = m * ps[2];\n\n            if(x > -6)\n            {\n                if(abs(x) > -y / 2)\n                \tcontinue;\n  \n                float f = 1. - smoothstep(2.8, 3.2,\n                          abs(max(abs(ps[0].z + 3.), max(abs(ps[1].z + 3.),\n                          max(abs(ps[2].z + 3.), abs(ps[3].z + 3.))))));\n                \n                if(f > 0.01)\n                {\n                    col += dofLine(ro, focus, ra, ps[0], ps[1]) * f * .5;\n                    col += dofLine(ro, focus, ra, ps[1], ps[3]) * f * .5;\n                }\n            }\n        }\n    }\n    \n    // Dust particles.\n    \n    for(int i = 0; i < 32; ++i)\n    {\n        vec3 dotp = cos(vec3(19, 129, 99) * (float(i))) * vec3(2., 0.4, 5.) + vec3(0, 0.4, 0.);\n        dotp.z += t;\n        dotp.z = mod(dotp.z, 5.) - 6.;\n        dotp = m * dotp;\n        float f = 1. - smoothstep(1.5, 2., abs(dotp.z + 3.));\n        if(f > 0.01)\n        \tcol += dofLine(ro, focus, ra, dotp, dotp + 1e-4) * f * vec3(1,.8,.2);\n    }\n    \n\n    col = pow(col + (1. - smoothstep(0., 3.8, length(uv))) * .1, vec3(1.8, 1.4, 1));\n\n    fragColor.rgb = col * 2.;\n\n    // Gamma correction\n\n    fragColor.rgb = pow(min(fragColor.rgb, 1.), vec3(1. / 2.2)) +\n        \ttexelFetch(iChannel1, ivec2(fragCoord) & 1023, 0).r / 100.;\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}]}