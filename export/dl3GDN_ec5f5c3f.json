{"ver":"0.1","info":{"id":"dl3GDN","date":"1682432953","viewed":169,"name":"blizzard on a aurora night","username":"foretoo","description":"gusty snowfall, aurora, wind stripes","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["aurora","snow","wind","blizzard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AMOUNT 40\n\nconst vec2 rnd = vec2(31.31738093, 1117.81051701);\nconst vec2 speed = vec2(4, 2);\n\n\n\n// -------- FLAKE\n\nfloat flake(vec2 uv, vec2 pos, float size) {\n  vec2 d = uv - pos;\n  return 1.0 - smoothstep(0.0, size*size, dot(d,d));\n}\n\n// -------- WIND\n\nvec2 windifyTime(vec2 p, float t) {\n    vec2 time = vec2(\n        sin(t * 0.137 + p.y * 0.52) * 0.533 + 0.533,\n        cos(t * 0.291 + p.x * 1.41) * 0.021 + 0.021\n    );\n    time *= vec2(\n        cos(t * 0.617) * 0.611 + 0.611,\n        sin(t * 0.579) * 0.471 + 0.471\n    );\n    return time *= 2.0;\n}\n\n// -------- AURORA\n\nvec3 aurora(vec2 uv, float scale, float speed, vec3 color) {\n  float t = iTime * speed;\n  vec2 s = vec2(scale, 2);\n  vec2 m = vec2(-2, -2);\n\n  vec2 p = uv * s + t * m;\n  float n = 0.5 + 0.5 * noise(p + t);\n\n  float aurora = n * (1.0 - uv.y);\n  \n  return color * aurora;\n}\n\n\n\n// -------- MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // prepare uv\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\n\n\n    // SNOWFLAKES and WIND\n    \n    // make uv borders extended off screen by 0.05 of its length\n    // to make snow seemlessly infinite\n    vec2 suv = (uv * 0.9 + vec2(0.05));\n    suv.x *= aspect;\n    \n    float flakes = 0.0;\n    float wind = 0.0;\n\n    for (int i = 0; i < AMOUNT; i++) {\n        float j = float(i);\n\n        // initial random position\n        vec2 p;\n        p.x = fract(sin(j) * rnd.y) * aspect;\n        p.y = fract(cos(j + p.x) * rnd.x);\n\n        // initial random velocity\n        float dv = 0.15;\n        vec2 v = vec2(\n            dv + fract(p.x * rnd.y) * dv,\n           -dv - fract(p.y * rnd.x) * dv\n        );\n\n        // radius, the slower v the smaller r\n        float lv = 0.6 - length(v);\n        float r = lv * lv * 0.2;\n\n        // apply gustiness to linerar time\n        vec2 t = windifyTime(p, iTime);\n        vec2 dt = windifyTime(p, iTime + 0.01) - t; // -0.008-0.008\n\n        // result position\n        p += v * (iTime + t) * speed;;\n        p = mod(p, vec2(aspect, 1.0));\n\n        // draw flakes, fake depth via different uv scales\n        flakes += 0.3 * flake(suv, p, r);\n        flakes += 0.9 * flake(suv * 0.7 + vec2(0.3), p, r * 0.9);\n        flakes += 0.9 * flake(suv * 0.6 + vec2(0, 0.4), p, r * 0.8);\n        flakes += 0.9 * flake(suv * 0.5 + vec2(0.5, 0), p, r * 0.7);\n\n        // wind\n\n        // wind derivative: dec-equal-inc -> 0-0.5-1\n        float dw = smootherstep((dt.x + 0.008) * 62.5);\n        // length of stripe, smaller value longer stripe\n        float wl = 0.04 * (2.0 - dw);\n        // distort uv\n        vec2 wuv = suv * vec2(wl, sin(suv.x * 0.5 + 0.5));\n        // get position\n        vec2 wp = v * (iTime * 2.0 + 123.4 + t) * speed * 0.06;\n        wp = mod(wp, vec2(aspect * 0.08, 1));\n        // draw wind stripes\n        wind += flake(wuv, wp, r) * dw;\n        wind += flake(wuv * 0.4, wp, r) * dw;\n    }\n\n    wind *= uv.x * (1.0 - uv.y);\n    wind *= noise(uv * vec2(1, 4) + iTime * 0.2) + 0.1;\n    wind *= 2.0;\n\n\n\n    // BACKGROUND\n    \n    // initial bg\n    vec3 bg = vec3(0, 0.1, 0.2);\n\n    // get aurora\n    vec3 aurorabg = vec3(0);\n    aurorabg += aurora(uv, 5.0, 0.2, vec3(0.0, 0.9, 0.0));\n    aurorabg += aurora(uv, 9.0, 0.3, vec3(0.3, 0.0, 0.9));\n    aurorabg += aurora(uv, 3.0, 0.1, vec3(0.9, 0.0, 0.9)) * 0.75;\n\n    // add contrasted aurora\n    bg += vec3(\n        smootherstep(smootherstep(aurorabg.r)),\n        smootherstep(smootherstep(aurorabg.g)),\n        aurorabg.b\n    );\n\n\n    fragColor = vec4(bg + wind + flakes, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float smootherstep(float x) {\n  return x*x*x*(3.0*x*(2.0*x-5.0)+10.0);\n}\n\nvec2 hash(vec2 p)\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0, 0) ), f - vec2(0, 0) ), \n                     dot( hash( i + vec2(1, 0) ), f - vec2(1, 0) ), u.x),\n                mix( dot( hash( i + vec2(0, 1) ), f - vec2(0, 1) ), \n                     dot( hash( i + vec2(1, 1) ), f - vec2(1, 1) ), u.x), u.y);\n}","name":"Common","description":"","type":"common"}]}