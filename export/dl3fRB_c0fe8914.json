{"ver":"0.1","info":{"id":"dl3fRB","date":"1701351471","viewed":18,"name":"pcunnell Helper functions","username":"pcunnell","description":"Repo to store reusable functions for future use / reminders / study and basic explanations","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["helpers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* DESCRIPTION\n    - Small helper functions to be reused and copied\n    - Found in various tutorials and from the forever incomplete 'book of shaders'\n*/\n\n#define PI 3.14159265359\n\n/* ********** COLORS ********** */\n/* \n    Palette:\n    - Using values found from \n        `http://dev.thi.ng/gradients/` \n        to build different time based color\n    - This is a modification of the starting time based color equation thats used for each new shader\n\n    Favorite Examples / starting points with 'palette':\n\n        col = palette(length(sharpenBands) + .001 + iTime * 0.2); // colors\n        y = sin(y * 6.0 + iTime) / 6.0;\n        y = abs(y);     \n        y = pow(0.01 / y, 1.2);\n        finalColor += col * y * mix(.2, 10., sin(time) * .5 + .5);\n*/\nvec3 palette( in float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(-1.268, 0.546, 0.546);\n    vec3 c = vec3(-1.663, -1.338, -1.703);\n    vec3 d = vec3(-0.063, 1.412, 1.745);\n    return a + b * cos( 6.28318 * (c * t + d));\n}\n\n\n/* ********** SHAPES ********** */\n/* HORIZONTAL LINE */\nfloat Line(vec2 uv, float xAxis, float yAxis, float blur) {\n    //return sin(uv.x);\n    return smoothstep(blur, 0.0, abs(uv.y - (uv.x/uv.x) + xAxis));\n}\n\n\n/* CIRCLE */\nfloat Circle(in vec2 uv, in float radius) {\n    vec2 position = vec2(0.); // accounts for the coords if user doesnt move 0 to middle \n    vec2 dist = uv - position;\n    float circleSizeModifier = 4.0;\n    float circleEquation = dot(dist,dist) * circleSizeModifier;\n    // change inner/outer to not be so close if you want a fuzzy boarder\n    float circleInner = radius - (radius * 0.01);\n    float circleOuter = radius + (radius * 0.01); //.01 for crisp edge\n\treturn 1. - smoothstep(circleInner, circleOuter, circleEquation);\n}\n\n\n/* BOX */\nfloat Box(in vec2 st, in vec2 size){\n    float blur = 0.001;\n    float crossScaleSecondary = .5;\n    float crossScalePrimary = 0.;\n    float scale = .1;\n\n    size = vec2(crossScalePrimary) - size * crossScaleSecondary;\n    vec2 uv = smoothstep(size, size + vec2(blur), st);    \n    uv *= smoothstep(size, size + vec2(blur), vec2(scale) - st);\n    return uv.x * uv.y;\n}\n\n/* CROSS */\nfloat Cross(in vec2 uv, float size){\n    float barThickness = 4.;\n    vec2 verticleBar = vec2(size, size/barThickness);\n    vec2 horizBar = vec2(size/barThickness ,size);\n    return Box(uv, verticleBar) + Box(uv, horizBar);\n}\n\n\n/* Ripples equation: sin((x * a - y * b) * c) * d + f = y */\nfloat Ripples (float x, float y) {\n    float heightOfRipples = .5; // the actual thickness or heigh of the ripples on a graph\n    float yAxisPosition = .5; // moves ripples up or down on the y axis\n    float xAxisFrequency = 60.; // spacing on xaxis; makes the ripples tilt\n    float xAxisFreqMult = 30.; // another multiplier on the frequency\n    float freqOther = 3.; // changes frequency but in a slightly different way than xAxisFrequency\n    return sin((x * xAxisFrequency - y * xAxisFreqMult) * freqOther) * heightOfRipples + yAxisPosition;\n}\n\n\n/* \n    Waves\n    - Same as ripples, but with a slight variation\n    equation: sin((x * a - y * b + t * c)) = y\n*/\nfloat Waves(float x, float y) {\n    float freq = 2.;\n    float twist = 6.; // moves bottom of sin along x axis twisting the whole thing\n    float timeFactor = .2; // moves graph along xaxis at some speed\n    return sin((x * freq - y * twist + iTime * timeFactor));\n}\n\n\n/* ********** TRICKS ********** */\n/* Mirror raw ex: uv.x = abs(uv.x); */\nfloat Mirror (float coord) {\n    return abs(coord);\n}\n\n\n/* translate coords in a circle */\nvec2 Translate (bool isClockWise) {\n    float sinRot = isClockWise ? -sin(iTime) : sin(iTime);\n    return vec2(cos(iTime), sinRot);\n}\n\n\n/* \n    MATRIX OPS \n    Multiply by the matrix first and then multiply the vectors\n*/\n/* rotation around vec2 0.0 */\nmat2 rotate2d(float angle) {\n    vec2 vect1 = vec2(cos(angle), -sin(angle));\n    vec2 vect2 = vec2(sin(angle), cos(angle));\n\n    return mat2(vect1, vect2);\n}\n\n/* scaling */\nmat2 scale(vec2 scale){\n    vec2 xAxisScale = vec2(scale.x, 0.0);\n    vec2 yAxisScale = vec2(0.0, scale.y);\n    return mat2(xAxisScale, yAxisScale);\n}\n\n/* ******************* MAIN ********************* */ \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // move 0 to the middle\n    uv -= .5;\n    // scale coordinates so it looks square\n    uv.x *= iResolution.x / iResolution.y;\n        \n    uv += .5;\n    uv = fract(uv) - .5;\n\n    // example moving coordinates for animation\n    uv += Translate(true) * 0.15;\n    \n    // must multiply to rotate to maintain the 2x2 matrix\n    uv *= rotate2d(sin(iTime)*PI);\n    \n    // mirror uses\n    //uv.x = Mirror(uv.x);\n    //uv.x = Mirror(pow(uv.x, uv.y));\n    //uv.y = Mirror(uv.y);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n    \n    // waves\n    //col += Waves(uv.x, uv.y);\n    \n    // ripples\n    //col += Ripples(uv.x, uv.y);\n    \n    // circle\n    col *= Circle(uv, .5) * palette(length(uv) + .001 - iTime * 0.2) * pow(.01/abs(sin(uv.y * 6.0 + iTime) / 6.0), .7);\n\n    // horizontal line with palette use\n    //col += Line(uv, 1., 0.2, .01) * palette(length(uv) + .001 + iTime * 0.2) * pow(.01/abs(sin(uv.x * 6.0 + iTime) / 6.0), .7);\n\n    // scaling cross example\n    uv = scale(vec2(sin(iTime) * 1. + 2.)) * uv;\n    \n    // cross (needs more work)\n    vec2 cross = vec2(Cross(uv -= Translate(true)*.2, .25));\n    \n    // must multiply to rotate to maintain the 2x2 matrix\n    uv = rotate2d(iTime) * uv;\n    \n\n    col += vec3(Cross(uv, .25)) * palette(length(uv - .025/.5) + .001 + iTime * 0.02);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}