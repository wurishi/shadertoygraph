{"ver":"0.1","info":{"id":"4lt3R2","date":"1470322037","viewed":156,"name":"Voro Nope","username":"XMunkki","description":"The shader code for the \"Voro Nope\" 4k-intro first released at the Assembly 2016.\n\nSee it with the music (done separately using 4klang):\nhttps://www.youtube.com/watch?v=06AsiIwcock\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voronoi","4kintro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Voro Nope\" 4k intro, released at Assembly 2016\n// Created by Jere \"XMunkki\" Sanisalo\n//\n// Parts from the internet, Inigo Quilez and others..\n//\n\nvec2 p;\nfloat time;\n////////////////\n\n\n\n\nint fx;\nfloat fx_part;\n\n//#define pi 3.14159265\n//#define pi2 (pi * 2.0)\n\nfloat smoothlerp(float v1, float v2, float t)\n{\n\treturn mix(v1, v2, t*t*(3.0-2.0*t));\n}\n\nfloat Randf_from_2(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 Rand3(vec3 p)\n{\n\treturn vec3(\n\t\tRandf_from_2(p.yz),\n\t\tRandf_from_2(p.xz),\n\t\tRandf_from_2(p.xy));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nint imod(int ai, int bi)\n{\n    return int(mod(float(ai), float(bi))+0.001);\n}\n\nbool Is_Inside(vec3 p)\n{\n    // Pick the effect\n    int f = imod(fx, 4);\n    \n    if (fx < (16 * 2)) f = 4; // Start ball\n    \n    // 0\n    if (f-- == 0)\n    { // Cross and ball\n\t\tp = abs(p);\n        return ((length(p) < 4.0) ||\n            (max(p.x, p.y) < 1.0) ||\n            (max(p.x, p.z) < 1.0) ||\n            (max(p.z, p.y) < 1.0));\n    }\n\n    // 1\n    if (f-- == 0)\n    { // Torus\n\t\tvec2 q = vec2(length(p.xz)-5.0,p.y);\n\t\treturn (length(q) < 2.0);\n    }\n    \n    // 2\n    if (f-- == 0)\n    { // Box\n        return sdBox(p, vec3(5,5,5)) < 0.0;\n    }\n    \n    // 3\n    if (f-- == 0)\n    { // Corner boxes\n        float d = sdBox(p, vec3(6,6,6));\n        float sz = 2.0;\n        p = abs(p);\n        d = max(d, -(p.x - sz));\n        d = max(d, -(p.y - sz));\n        d = max(d, -(p.z - sz));\n        \n        return d < 0.0;\n    }\n    \n    // 4\n    if (f-- == 0)\n    { // Ball\n        return length(p) < 4.0;\n    }\n    \n    return false;\n}\n\nvec3 CalcOffset(ivec3 ipos)\n{\n    vec3 pos = vec3(ipos);\n    vec3 p = abs(Rand3(pos));\n    vec3 ang = vec3(time * 1.23, time * 0.84, time * 1.11) + p.zxy * 234.456;\n    return clamp(p + cos(ang), vec3(0.2,0.2,0.2), vec3(0.8,0.8,0.8));\n}\n\nfloat DF(vec3 wpos, vec3 frac_pos_tweak)\n{ // Voronoi based distance function\n\tivec3 pos = ivec3(floor(wpos));\n\tvec3 posf = fract(wpos) + frac_pos_tweak;\n\n    \n    \n//\tbool is_inside = Is_Inside(pos);\nbool is_inside = false;\n\t\n\tfloat dist_inside = 10.0;\n\tfloat dist_outside = 10.0;\n\tfor (int z = -1; z <= 1; ++z)\n\t{\n\t\tfor (int y = -1; y <= 1; ++y)\n\t\t{\n\t\t\tfor (int x = -1; x <= 1; ++x)\n\t\t\t{\n\t\t\t\tivec3 iofs = ivec3(x, y, z);\n\t\t\t\tivec3 ipos = pos + iofs;\n\t\t\t\t\n\t\t\t\t// Same material?\n\t\t\t\t//if (is_inside == Is_Inside(ipos))\n\t\t\t\t//\tcontinue;\n\t\t\t\t\t\n\t\t\t\t// Apply distance\n\t\t\t\t//vec3 local_ofs = abs(Rand3(vec3(ipos)));\n\t\t\t\t//vec3 local_ofs2 = abs(Rand3(vec3(ipos+ivec3(4,4,4))));\n\t\t\t\t//vec3 local_ofs = vec3(0.5, 0.5, 0.5);\n\t\t\t\t\n// Lerp between fixed and tweaked\n//local_ofs = mix(local_ofs, vec3(0.5, 0.5, 0.5), 1.0 - abs(cos(time * 2.0)));\n//local_ofs = mix(local_ofs, local_ofs2, (1.0 + cos(time * 3.0))*0.5);\n\t\t\t\t\n                vec3 local_ofs = CalcOffset(ipos);\n                \n\t\t\t\tvec3 fofs = vec3(iofs) - posf + local_ofs;\n\t\t\t\tfloat d = dot(fofs, fofs);\n\t\t\t\t\n\t\t\t\t//res = min(res, d);\n\t\t\t\tif (Is_Inside(vec3(ipos)))\n\t\t\t\t\tdist_inside = min(dist_inside, d);\n\t\t\t\telse\n\t\t\t\t\tdist_outside = min(dist_outside, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tdist_inside = sqrt(dist_inside);\n\tdist_outside = sqrt(dist_outside);\n\t\n\tfloat d = dist_inside - dist_outside;\n\treturn d;\n}\n\nvec3 DFNormal(vec3 p)\n{\n\tfloat d = DF(p, vec3(0,0,0));\n\tfloat eps = 0.001;\n\treturn normalize(vec3(\n\t\tDF(p, vec3(eps, 0, 0)) - d,\n\t\tDF(p, vec3(0, eps, 0)) - d,\n\t\tDF(p, vec3(0, 0, eps)) - d\n\t\t));\n}\n\nvec2 Raytrace(vec3 ray_pos, vec3 ray_dir)\n{\n\tvec2 dist_glow = vec2(0, 0);\n\n    for (int i = 0; i < 40; ++i)\n\t{\n\t\tfloat d = DF(ray_pos + ray_dir * dist_glow.x, vec3(0,0,0));\n\t\tif (abs(d) < 0.001)\n\t\t\tbreak;\n        \n        // Glow\n        if (d > 0.0)\n            dist_glow.y += max(1.0 - d * 1.0, 0.0) * 0.2;\n            \n        // Moving\n\t\tdist_glow.x += d * 0.4;\n\t}\n\n\treturn dist_glow;\n}\n\nfloat AO(vec3 pos, vec3 normal)\n{\n    float t = 0.0;\n    float ret = 0.0;\n    for (int i = 0; i < 10; ++i)\n    {\n        t += 0.1;\n        float d = DF(pos + normal * t, vec3(0,0,0));\n        ret += clamp((t - d) * 0.2, 0.0, 1.0);\n    }\n    //ret *= 0.0;\n    return 1.0 - ret;\n}\n\nvec3 MakeColor(int idx, float adj)\n{\n    float i = adj + float(idx)*1523.0;\n    vec3 c = abs(cos(vec3(i,i*0.374,i*0.584)));\n    if (length(c) < 0.7)\n        return vec3(1,1,1)-c;\n    return c;\n}\n\nfloat Specular(vec3 ray_dir, vec3 normal, vec3 light_dir)\n{\n    vec3 hv = normalize(normalize(light_dir) - ray_dir);\n    return pow(abs(dot(normal, hv)), 15.0) * 2.0;\n}\n\nvec4 intro()\n{\n    // Pick the effect\n    fx_part = time / 0.477;\n    fx = int(fx_part);\n    fx_part = fract(fx_part);\n\n    // Base drum pause\n    if (fx >= 61 && fx < 64)\n    {\n        fx = 60;\n        fx_part = 1.0;\n    }\n    \n    // Calculate the camera\n\tfloat cam_ang = time * 0.25;\n\tvec3 cam_pos;\n\tvec3 cam_target = vec3(0, 0, 0);\n\tfloat cam_dist = 10.0;\n    \n    cam_dist += fract(float(fx)*1234.56789) * 5.0; // Random direction\n    \n    if (fx < 32)\n    {\n        cam_dist = 18.0 + time * 4.5 - float(fx) * 2.5;\n    }\n    else\n    {\n        cam_ang += float(fx) * 11.0;\n    }\n    if (fx >= (16 * 8))\n    {\n        float amt = fx_part * 3.0;\n        cam_dist += (imod(fx, 2) == 0) ? amt : -amt;\n    }\n    \n\tcam_pos = normalize(vec3(sin(cam_ang), sin(1.0 + cam_ang * 1.0) * 1.0, cos(cam_ang))) * cam_dist;\n\n    if (fx >= (16*2))\n    {\n        if (imod(fx,2)==0)\n            cam_pos.x *= -1.0;\n        if (imod(fx,3)==0)\n            cam_pos.y *= -1.0;\n        if (imod(fx,5)==0)\n            cam_pos.z *= -1.0;\n    }\n    \n    // Create the camera vectors\n\tvec3 cam_z = normalize(cam_target - cam_pos);\n\tvec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n\tvec3 cam_y = normalize(cross(cam_x, cam_z));\n\tvec3 ray_dir = normalize(\n\t\tcam_x * p.x/* * (16.0/9.0)*/ + \n\t\tcam_y * p.y +\n\t\tcam_z); // * 1.0    <-- fov\n\n\t// Calculate the pixel color\n\tvec3 color;\n\tvec2 dist_glow = Raytrace(cam_pos, ray_dir);\n\n\tif (dist_glow.x < 20.0)\n\t{\n\t\tvec3 hit_pos = cam_pos + ray_dir * dist_glow.x;\n\t\tvec3 normal = DFNormal(hit_pos);\n\t\t\n\t\tfloat light = abs(dot(normal, normalize(vec3(1,1,1))));\n\t\t\n        // Specular lighting\n        light += Specular(ray_dir, normal, vec3(-1,1,1));\n        light += Specular(ray_dir, normal, vec3(1,-1,1));\n        light += Specular(ray_dir, normal, vec3(1,1,-1));\n        \n        int col_idx = (fx < 32) ? -1 : fx;\n                \n        //color = Rand3(floor(hit_pos*0.21)) * 2.0;\n        color = MakeColor(col_idx+2,length(hit_pos)*0.1);\n        \n        color *= light;\n        \n        // Pulse\n        //c *= 2.0 - pow(0.2+abs(fx_part * 10.0 - length(hit_pos)), 1.0);\n        \n        color *= AO(hit_pos, normal);\n        \n        // Disable glow for hits\n        dist_glow.y = 0.0;\n        \n        // Blackness at the end\n        if (fx >= (16*6) && fx < (16*7))\n            color *= 0.0;\n\t}\n\telse\n\t{\n\t\t//color = vec4(0,0,0.5,1);\n        \n        // Bg rotation\n        float a = time * 0.5;\n        vec2 asc = vec2(sin(a), cos(a));\n        bool is_rot = (fx < (16 * 9));\n        vec2 pr = vec2(dot(p,asc.yx), dot(p,asc * vec2(1.0,is_rot?-1.0:1.0)));\n        \n        // Circles\n        float c = length(pr) * 20.0;\n        \n        int bg = imod(fx, 4);\n        // L-shapes\n        if (--bg == 0)\n\t        c = min(abs(pr.x), abs(pr.y)) * -30.0;\n        \n        // X-shapes\n        if (--bg == 0)\n\t        c = min(abs(dot(pr, vec2(1,1))), abs(dot(pr, vec2(-1,1)))) * 20.0;\n        \n        // Boxes\n        if (--bg == 0)\n            c = max(abs(pr.x), abs(pr.y)) * 30.0;\n\n        // THRESHOLD: black / area\n        c = max(0.00001, cos(c - time*5.0));\n        c = pow(c,0.1);\n\n        \n        //color = vec4(c*0.86,c*0.92,c*0.82,1);\n        color = c*MakeColor(fx,length(pr));\n\n        // Start: Bg pulse\n        if (fx < (16 * 6))\n        {\n\t        c = pow(length(pr)/1000.0,0.1)*0.4;\n            color=vec3(c, c, c);\n        }\n    }\n   \n    // Glow\n    if ((fx >= (16*6) && fx < (16 * 7)) ||\n        (fx >= (16*10)))\n    {\n\t    //color += vec3(0.98, 0.89, 0.92) * dist_glow.y;\n\t    color += MakeColor(fx+2,0.0) * dist_glow.y;\n    }\n    \n    // Color grading\n    float gr = 0.485;\n    //color = pow(color, vec4(gr,gr,gr,1));\n    \n    // Vignette\n    color *= 1.0 - pow(length(p) * 0.4, 0.7);\n\n    // Flashing\n    if (fx < (16 * 10))\n    {\n\t    //color *= pow(min(fx_part * 0.5, 1.0), 0.5);\n    \t//color *= min(fx_part * 1.0, 1.0);\n   \t \tcolor *= smoothstep(0.0, 0.7, fx_part);\n    }\n    \n    // End fade\n    color *= 1.0 - smoothstep(85.0, 97.0, time);\n    \n\treturn vec4(color, 1.0);\n}\n\n\n\n\n\n/////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0-1.0;\n    \n    p = uv;\n    time = iTime;\n    fragColor = intro();\n}\n","name":"Image","description":"","type":"image"}]}