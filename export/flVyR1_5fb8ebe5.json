{"ver":"0.1","info":{"id":"flVyR1","date":"1661008297","viewed":211,"name":"colonoscopy","username":"belfry","description":"or something. Just an experiment trying to get some cheap anti aliasing.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 eps = vec2(1.5, 0.);\n    vec4 col = texture(iChannel0, uv) + \n        textureLod(iChannel0, uv + eps.xy / iResolution.xy, 1.) * .5 + \n        textureLod(iChannel0, uv - eps.xy / iResolution.xy, 1.) * .5 + \n        textureLod(iChannel0, uv + eps.yx / iResolution.xy, 1.) * .5 + \n        textureLod(iChannel0, uv - eps.yx / iResolution.xy, 1.) * .5;\n\n    fragColor = col / 3.;\n    \n    vec2 a = (2. * fragCoord - iResolution.xy) / iResolution.xy;\n    fragColor *= 1.2 - length(a) * .65;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 fbm(vec3 uv)\n{\n    float b = 1. / 32.;\n    float t = 0.;\n    vec4 n = vec4(0.);\n    for (float i = 1.; i >= b; i *= .5)\n    {\n        t += i;\n        n += texture(iChannel2, uv / i * b) * i;\n    }\n    return n / t;\n}\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvec2 smoothmin(vec2 a, vec2 b, float t)\n{\n    float s = smoothstep(-t, t, a.x - b.x);\n    return mix(a, b, s) - s * (1. - s) * t;\n}\n\nfloat capsule(vec3 p, float h, float r)\n{\n    p.y -= clamp(p.y, -h, h);\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 e)\n{\n    vec3 a = abs(p) - e;\n    float i = max(a.x, max(a.y, a.z));\n    float o = length(max(a, vec3(0.)));\n    return i < 0. ? i : o;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nvec2 sdf(vec3 p)\n{\n    vec3 q = p;\n    vec4 f = fbm(p + iTime * .125) * 2.;\n    //f = fbm(f.xzy + p - iTime * .125) * 2.;\n    f = fbm(f.xzy + p) * (1. + sin(iTime + p.z * 2.) * .25);\n    \n    q = p;\n    q.xy *= rot(q.z * 2.);\n    float b1 = box(q, vec3(.5, .5, 15.)) + \n        sin(q.z*4. + iTime * 2.) * .125 - f.x;// * 2. + .5;\n    \n    q = p;\n    q.xy *= rot(-p.z);\n    q.x += cos(p.z) * .75;\n    q.y += .85;\n    q.z = mod(q.z, 1.) - .5;\n    float qs = sphere(q, sin(p.z + iTime)*.2 + .3);\n    \n    q = p;\n    q.x += sin(sin(p.z * 5.) + p.z) * .15;\n    q.y += sin(iTime*2.+p.z+p.y)*.2 + .75;\n    q = q.xzy;\n    float c = capsule(q, 10., .3 + sin(p.z) * .175) - f.y * .1;\n    \n    return smoothmin(vec2(c, 2.), smoothmin(vec2(qs, 1.), vec2(-b1, 0.), .75), .65);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    float occ = 0.;\n    for (float i = 0.; i < 5.; i++)\n    {\n        float d = i * .1 + .1;\n        occ += (d - sdf(p + n * d).x) * d;\n    }\n    return 1. - occ;\n}\n\nfloat lighting(vec3 p, vec3 d, vec3 n, vec3 l)\n{\n    float diff = max(0., dot(d, n));\n    float spec = pow(max(0., dot(normalize(d + l), n)), 16.);\n    float rim = pow(1. - abs(dot(d, n)), 5.);\n    float ao = ambientOcclusion(p, n);\n    float amb = .15 * ao;\n    return clamp(diff * .7 + spec * .7 + amb + rim * .5, 0., 1.);\n}\n\nvec3 gradient(vec3 p)\n{\n    vec2 eps = vec2(0., 0.01);\n    float x = sdf(p + eps.yxx).x - sdf(p - eps.yxx).x;\n    float y = sdf(p + eps.xyx).x - sdf(p - eps.xyx).x;\n    float z = sdf(p + eps.xxy).x - sdf(p - eps.xxy).x;\n    return normalize(vec3(x, y, z));\n}\n\nbool trace(vec3 pos, vec3 dir, inout float t, out float i, out vec3 p, out float id)\n{\n    for (i = 0.; i < 1000.; i++)\n    {\n        p = t * dir + pos;\n        vec2 o = sdf(p);\n        float d = o.x;\n        id = o.y;\n        if (abs(d) < .01 * t)\n            return true;\n        t += d * .1;\n        if (t > 400.)\n            break;\n    }\n    return false;\n}\n\nvec3 color(float id, vec3 p, vec3 n, vec3 d)\n{\n    vec3 cb = vec3(1., .47, .46) * (p.y + 1.5)*.5;\n    vec3 cs = vec3(1., .2 + (-p.z + 18.) * .02, .5);\n    vec3 cc = vec3(1., .35, .31);\n    \n    d = reflect(d, n);\n    float o = clamp(sdf(p + d * .5).y, 0., 1.);\n    vec3 r = mix(mix(cb, cc, o), mix(cs, cc, o - 1.), o*.5);\n    float t = .7 + dot(n, d) * .3;\n    return mix(r, mix(mix(cb, cc, id), mix(cs, cc, id - 1.), id*.5), t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 noise = texelFetch(\n        iChannel0, \n        ivec2(mod(fragCoord + vec2(123.123, 1) * iTime, iChannelResolution[0].xy)), \n        0\n    );\n    vec2 uv = (2. * (fragCoord + noise.xy) - iResolution.xy) / iResolution.y;\n    vec3 dir = normalize(vec3(uv, 1./tan(radians(30.))));\n    vec3 pos = vec3(0., 0.1, -5. + sin(iTime * .2) * 2.);\n    \n    float t = 0.;\n    float i;\n    vec3 p;\n    float id;\n    trace(pos, dir, t, i, p, id);\n    vec3 n = gradient(p);\n    float lit = lighting(p, -dir, n, normalize(vec3(1.)));\n    fragColor = vec4(color(id, p, n, dir) * lit, 1.) + .1 - .1*exp(t * .05);\n    fragColor += texture(iChannel1, fragCoord / iResolution.xy);\n    fragColor /= 2.;\n}","name":"Buffer A","description":"","type":"buffer"}]}