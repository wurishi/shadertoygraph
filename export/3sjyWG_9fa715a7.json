{"ver":"0.1","info":{"id":"3sjyWG","date":"1587264506","viewed":313,"name":"Conformal Droste effect","username":"RadoKirov","description":"math behind this conformal mapping - http://www.ams.org/notices/200304/fea-escher.pdf","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["droste","escher","conformalmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define M_PI 3.1415926535897932384626433832795\n\n// Parameters\nfloat winding = 3.0;\nfloat numSpirals = 1.0;\n\nfloat u_f = 2.0; // scaling\nfloat majorGrid = 2.0;\nfloat minorGrid = 2.0 /* majorGrid */ * 3.0;\n\nfloat speed = 3.0;\n\n// convert from cartisian to polar.\n// returns [r, theta] in x+iy = r e^i * theta\nvec2 polarz(in vec2 c) {\n  return vec2(length(c), atan(c.y, c.x));\n}\n\n// convert from polar to cartisian.\nvec2 cart(in vec2 c) {\n  return vec2(c.x * cos(c.y), c.x * sin(c.y));\n}\n\nvec2 powz(in vec2 c1, in vec2 c2) {\n  vec2 polarC = polarz(c1);\n\n  // (r * e ^ i theta) ^ (x + i y) = r ^ x * r ^ i y * e ^ i x theta * e ^ - y theta\n  // r ^ x * e ^ - y theta * e ^ i (x theta + log (r) y)\n  // |--------- r -------| * e ^ i |------- theta -----|\n\n  float r = pow(polarC.x, c2.x) * exp(-polarC.y * c2.y);\n  float theta = c2.x * polarC.y + log(polarC.x) * c2.y;\n\n  return cart(vec2(r, theta));\n}\n\nvec4 grid(in vec2 uv) {\n  float x = fract(uv.x * majorGrid + 0.07/2.0);\n  float y = fract(uv.y * majorGrid + 0.07/2.0);\n  if (abs(x) < 0.07 || abs(y) < 0.07) {\n    float c = smoothstep(0.9 * 0.07, 0.07, min(abs(x), abs(y)));\n    return vec4(c, c, c, 1.0);\n  }\n  x = fract(uv.x * minorGrid + 0.05/2.0);\n  y = fract(uv.y * minorGrid + 0.05/2.0);\n  if (abs(x) < 0.05 || abs(y) < 0.05){\n    float c = smoothstep(0.0045, 0.05, min(abs(x), abs(y)));\n    return vec4(c, c, c, 1.0);\n  }\n  return vec4(1.0, 1.0, 1.0, 1.0);\n}\n\nvec2 conformal(in vec2 uv) {\n  float P = log(u_f) / M_PI / 2.0;\n  vec2 alpha = vec2(winding / 4.0, numSpirals * P);\n  return powz(uv, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 c = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 e = conformal(c);\n    \n    float t = iTime / speed;\n    e /= exp(log(u_f) * fract(t / log(u_f)));\n    while (abs(e.x) > 1.0 || abs(e.y) > 1.0) {\n      e /= u_f;\n    }\n    while (abs(e.x) < 1.0 / u_f && abs(e.y) < 1.0 / u_f) {\n      e *= u_f;\n    }\n    \n    fragColor = grid(e + 1.0 / 2.0);\n}","name":"Image","description":"","type":"image"}]}