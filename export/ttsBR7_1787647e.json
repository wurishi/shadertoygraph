{"ver":"0.1","info":{"id":"ttsBR7","date":"1596480796","viewed":282,"name":"Homogeneous Shadow Volumes","username":"skye_adaire","description":"Click and drag to move the light.\nThe projection plane is shown in red, along with the projection of each vertex in blue.\nThe grey line passing through the light is the half plane boundary. \nVertices should not pass behind the light.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["volume","shadow","implicit","homogeneous","projective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by Skye Adaire\nApache License 2.0\n\nThis algorithm produces shadow volumes by treating the projection\nof a set of triangles as a homogenized implicit surface.\n\nAn implicit function takes a \"position\" and outputs a scalar.\n\tf(x, y, ...) = level\n\twhen level < 0 the position is inside the surface\n\twhen level = 0 the position is on the surface\n\twhen level > 0 the position is outside the surface\n\nA function can be homogenized by:\n\tf(x, y) -> w^(degree(f)) * f(x / w, y / w) = h(x, y, w)\n\nThis easily generalizes to 3D.\nIn 2D our \"face\" is a line segment, and our simplex is a triangle.\nIn 3D our face is a triangle, and our simplex is a tetrahedron.\n\nThe algorithm:\n1. Project an object's triangles onto a light's projection plane\n\t(shown in red). I refer to the projected object as the \"umbra mesh.\"\n2. For each face of the object, determine whether that face is\n\ttowards the light.\n3. For faces towards the light (even if occluded) form a \"light simplex\"\n\t(faces included are shown in green)\n4. For faces away from the light form a \"shadow volume\"\n\t(faces included are shown in pink)\n5. For a point in the world, translate and rotate relative to the light\n\t(or use a generalized projective plane)\n6. Evaluate the point against each light simplex and shadow volume.\n7. If a point is included in more shadow volumes than light simplex,\n\tit is shadowed.\n\nNotes:\nFor points not shadowed, the minimum level curve across all shadow\nvolumes could be used as a distance estimate to the nearest shadow.\nThis could be used to make a penumbra region for soft shadows.\n\nFor homogenization, multiplying by w is not required, but doing so\nmakes the shadow level curves appear more regularly spaced.\n\nFor a scene with multiple objects and lights, an umbra mesh\ncould be computed and stored for each pair of object and light.\n*/\n\n#define SHOW_LEVEL_CURVES false\n\nvec2 rotateCW(vec2 n)\n{\n    return vec2(n.y, -n.x);\n}\n\nmat3 makeLightTransform(vec2 origin, vec2 normal)\n{\n    return mat3(rotateCW(normal), 0, normal, 0, origin, 1);\n}\n\nmat3 makeProjection(vec3 v, vec3 p)\n{\n \treturn mat3(v * p[0], v * p[1], v * p[2]) - mat3(dot(v, p));\n}\n\nvec2 hmul1(in mat3 m, in vec2 v)\n{\n \tvec3 hv = m * vec3(v, 1);\n    return hv.xy / hv.z;\n}\n\n//this is to make the generalization more apparent\n#define vec1 float\n\nvec1 projectWorldPositionToLight(in mat3 projectToPlane, in mat3 worldToLight, vec2 p)\n{\n    vec2 pRelLight = hmul1(worldToLight, p);\n    vec2 pProjected = hmul1(projectToPlane, pRelLight);\n    return pProjected.x;\n}\n\nfloat A_intersection(float a, float b)\n{\n \treturn max(a, b);\n}\n\nfloat A_union(float a, float b)\n{\n \treturn min(a, b);\n}\n\n//implicit half plane given two points on it's surface\nfloat A_halfPlane(vec2 a, vec2 b, vec2 p)\n{\n    b = a + normalize(b - a);//make it euclidean\n    return (b.y - a.y) * p.x - (b.x - a.x) * p.y + b.x * a.y - b.y * a.x;\n}\n\n//implicit triangle with non-euclidean level curves, winding order is important\nfloat A_triangle(vec2 v0, vec2 v1, vec2 v2, vec2 p)\n{\n    return\n        A_intersection(A_halfPlane(v0, v1, p),\n   \t\tA_intersection(A_halfPlane(v1, v2, p),\n   \t\tA_halfPlane(v2, v0, p)));\n}\n\n//implicit 1D disk / interval / segment\nfloat A_disk(vec1 a, vec1 b, vec1 p)\n{\n    //return (p - a) * (p - b);//algebraic, but not euclidean\n\treturn max(a - p, p - b);//euclidean\n}\n\nfloat umbraHomogeneous(vec1 v0, vec1 v1, vec2 p)\n{\n \treturn /*p.y * */ A_disk(v0, v1, p.x / p.y);\n}\n\nbool isCounterClockwise(vec2 a, vec2 b, vec2 c)\n{\n    return cross(vec3(b - a, 0), vec3(c - a, 0)).z < 0.0;\n}\n\nvoid orderTriangleCW(inout vec2 v0, inout vec2 v1, inout vec2 v2)\n{\n    if(isCounterClockwise(v0, v1, v2))\n    {\n        vec2 t = v1;\n        v1 = v2;\n        v2 = t;\n    }\n}\n\nvoid orderVolumes(inout vec1 v0, inout vec1 v1)\n{\n \tif(v1 < v0)\n    {\n     \tfloat t = v0;\n        v0 = v1;\n        v1 = t;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n\n    float modelScale = 11.0;\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseUnit = mouseUV - 0.5;\n    vec2 mouseRatio = mouseUnit * vec2(iResolution.x / float(iResolution.y), 1.0);\n    vec2 mouseWorld = modelScale * mouseRatio;\n\n    //the light is the point at infinity\n    float timeScale = iTime * 0.2;\n    vec2 defaultLightPosition = vec2(cos(timeScale), sin(timeScale)) * 5.0;\n    vec2 lightPosition = iMouse.z <= 0.0 ? defaultLightPosition : mouseWorld;\n    vec2 lightNormal = -normalize(lightPosition);\n    mat3 lightToWorld = makeLightTransform(lightPosition, lightNormal);\n    mat3 worldToLight = inverse(lightToWorld);\n\n    //these are fixed relative to the light, which is why we transform rel light\n    vec3 projectionPosition = vec3(0, 0, 1);\n    vec3 projectionPlane = vec3(0, 1, -1.0);\n    mat3 projectToPlane = makeProjection(projectionPosition, projectionPlane);\n\n    vec2 uvPosition = fragCoord/iResolution.xy;\n    vec2 unitPosition = uvPosition - 0.5;\n    vec2 ratioPosition = unitPosition * vec2(iResolution.x / float(iResolution.y), 1.0);\n    vec2 modelPosition = modelScale * ratioPosition;\n    vec2 positionRelLight = hmul1(worldToLight, modelPosition);\n\n    #define vertexCount 9\n    vec2 objectPositions[vertexCount];\n    objectPositions[0] = vec2(-1.0, -1.3);\n    objectPositions[1] = vec2(3.5, 1.3);\n    objectPositions[2] = vec2(0.2, 0.2);\n    objectPositions[3] = vec2(-0.1, 3.0);\n    objectPositions[4] = vec2(-1.5, 1.0);\n    objectPositions[5] = vec2(-4.0, 0.5);\n    objectPositions[6] = vec2(3.0, -1.0);\n    objectPositions[7] = vec2(2.5, -1.5);\n    objectPositions[8] = vec2(3.5, -1.5);\n\n    #define triangleCount 4\n    ivec3 triangles[triangleCount];\n    triangles[0] = ivec3(0, 1, 2);\n    triangles[1] = ivec3(2, 3, 0);\n    triangles[2] = ivec3(0, 4, 5);\n    triangles[3] = ivec3(6, 7, 8);\n\n    vec1 umbraMesh[vertexCount];//the projected object\n\n    for(int i = 0; i < vertexCount; i++)\n    {\n     \tumbraMesh[i] = projectWorldPositionToLight(projectToPlane, worldToLight, objectPositions[i]);\n    }\n\n    //identify the faces pointing towards and away from the light\n    int lightSimplexCount = 0;\n    ivec2 lightSimplexes[10];\n    int shadowVolumeCount = 0;\n    ivec2 shadowVolumes[10];\n\n    for(int i = 0; i < triangleCount; i++)\n    {\n        int v0 = triangles[i].x;\n        int v1 = triangles[i].y;\n        int v2 = triangles[i].z;\n\n        vec2 i0 = lightPosition - objectPositions[v0];\n        vec2 i1 = lightPosition - objectPositions[v1];\n        vec2 i2 = lightPosition - objectPositions[v2];\n\n        vec2 n0 = rotateCW(objectPositions[v1] - objectPositions[v0]);\n        vec2 n1 = rotateCW(objectPositions[v2] - objectPositions[v1]);\n        vec2 n2 = rotateCW(objectPositions[v0] - objectPositions[v2]);\n\n       \tif(dot(n0, i0) >= 0.0)\n        {\n            lightSimplexes[lightSimplexCount] = ivec2(v0, v1);\n            lightSimplexCount++;\n        }\n        else\n        {\n            shadowVolumes[shadowVolumeCount] = ivec2(v0, v1);\n            shadowVolumeCount++;\n        }\n\n        if(dot(n1, i1) >= 0.0)\n        {\n            lightSimplexes[lightSimplexCount] = ivec2(v1, v2);\n            lightSimplexCount++;\n        }\n        else\n        {\n            shadowVolumes[shadowVolumeCount] = ivec2(v1, v2);\n            shadowVolumeCount++;\n        }\n\n        if(dot(n2, i2) >= 0.0)\n        {\n            lightSimplexes[lightSimplexCount] = ivec2(v2, v0);\n            lightSimplexCount++;\n        }\n        else\n        {\n            shadowVolumes[shadowVolumeCount] = ivec2(v2, v0);\n            shadowVolumeCount++;\n        }\n    }\n\n    int simplexShadowParity = 0;\n\n    //form a simplex with each face and the point at infinity\n    for(int i = 0; i < lightSimplexCount; i++)\n    {\n\t\tvec2 p0 = objectPositions[lightSimplexes[i].x];\n        vec2 p1 = objectPositions[lightSimplexes[i].y];\n        vec2 p2 = lightPosition;\n       \torderTriangleCW(p0, p1, p2);\n        \n        float level = A_triangle(p0, p1, p2, modelPosition);\n\n        if(level < 0.0)\n        {\n            simplexShadowParity += 1;\n        }\n    }\n\n    float shadowLevel = 1e10;\n\n    if(positionRelLight.y > 0.0)//exclude the volume behind the light\n    {\n        for(int i = 0; i < shadowVolumeCount; i++)\n        {\n\t\t\tvec1 v0 = umbraMesh[shadowVolumes[i].y];\n            vec1 v1 = umbraMesh[shadowVolumes[i].x];\n            orderVolumes(v0, v1);\n\n            float level = umbraHomogeneous(v0, v1, positionRelLight);\n\n            shadowLevel = A_union(level, shadowLevel);\n\n            if(level < 0.0)\n            {\n                simplexShadowParity -= 1;\n            }\n        }\n    }\n\n    if(simplexShadowParity < 0)//the position is in shadow\n    {\n     \tcolor += vec3(0.2);\n\n        if(SHOW_LEVEL_CURVES)\n        {\n            color -= pow(cos(5.0 * shadowLevel * 3.14159), 40.0) * 0.1;\n        }\n    }\n    else //the position is in light\n    {\n     \tcolor += vec3(0.6);\n\n        if(SHOW_LEVEL_CURVES)\n        {\n            color += pow(cos(5.0 * shadowLevel * 3.14159), 40.0) * 0.1;\n        }\n    }\n\n    //shade the border of the positive half plane through the light\n    if(abs(positionRelLight.y) < 0.05)\n    {\n     \tcolor = vec3(0.5);\n    }\n\n    vec3 lightEdgeColor = vec3(0.5, 0.9, 0.5);\n    vec3 shadowEdgeColor = vec3(0.86, 0.39, 0.73);\n    float edgeWidth = 0.1;\n\n    //draw triangles\n    for(int i = 0; i < triangleCount; i++)\n    {\n        int v0 = triangles[i].x;\n        int v1 = triangles[i].y;\n        int v2 = triangles[i].z;\n\n        if(A_triangle(objectPositions[v0], objectPositions[v1], objectPositions[v2], modelPosition) < 0.0)\n        {\n            color = vec3(1);\n\n            //shade edges based on parity\n\n            for(int j = 0; j < lightSimplexCount; j++)\n            {\n             \tivec2 s = lightSimplexes[j];\n\n                if(abs(A_halfPlane(objectPositions[v0], objectPositions[v1], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v0, v1) || s == ivec2(v1, v0))\n                    {\n                        color = lightEdgeColor;\n                    }\n                }\n                else if(abs(A_halfPlane(objectPositions[v1], objectPositions[v2], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v1, v2) || s == ivec2(v2, v1))\n                    {\n                        color = lightEdgeColor;\n                    }\n                }\n                else if(abs(A_halfPlane(objectPositions[v2], objectPositions[v0], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v2, v0) || s == ivec2(v0, v2))\n                    {\n                        color = lightEdgeColor;\n                    }\n                }\n            }\n\n            for(int j = 0; j < shadowVolumeCount; j++)\n            {\n             \tivec2 s = shadowVolumes[j];\n\n                if(abs(A_halfPlane(objectPositions[v0], objectPositions[v1], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v0, v1) || s == ivec2(v1, v0))\n                    {\n                        color = shadowEdgeColor;\n                    }\n                }\n                else if(abs(A_halfPlane(objectPositions[v1], objectPositions[v2], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v1, v2) || s == ivec2(v2, v1))\n                    {\n                        color = shadowEdgeColor;\n                    }\n                }\n                else if(abs(A_halfPlane(objectPositions[v2], objectPositions[v0], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v2, v0) || s == ivec2(v0, v2))\n                    {\n                        color = shadowEdgeColor;\n                    }\n                }\n            }\n        }\n    }\n\n    //draw real line\n    if(abs(positionRelLight.y - 1.0) < 0.05)\n    {\n     \tcolor = vec3(1.0, 0.2, 0.1);\n    }\n\n    vec3 vertexColor = vec3(0.2, 1, 1);\n\n    //draw vertices\n    for(int i = 0; i < vertexCount; i++)\n    {\n        //R2\n        if(length(modelPosition - objectPositions[i]) < 0.1)\n        {\n            color = vertexColor;\n        }\n\n        //projection in R1\n        if(abs(positionRelLight.y - 1.0) < 0.05 && abs(positionRelLight.x - umbraMesh[i]) < 0.1)\n        {\n            color = vertexColor;\n        }\n    }\n\n    //draw dot for light\n    if(length(positionRelLight) < 0.2)\n    {\n        color = vec3(1);\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}