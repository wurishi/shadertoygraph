{"ver":"0.1","info":{"id":"l3sSzN","date":"1709225689","viewed":97,"name":"Am am with textures","username":"kraba4","description":"for hw3","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["procedural","3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 eye = vec3(0.0, 0.0, 2.3);\nconst int max_steps = 160;\nvec3 light = vec3(1.0, 2.0, 4.0);\n \nmat3 rotate_matrix = mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n \nfloat dBox ( vec3 p, vec3 b)\n{\n\treturn length ( max ( abs ( p ) - b, 0.0 ) );\n}\n\nfloat dSphere( vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nmat3 rotate_Y(vec2 point) {\n    float theta = point.x;\n    float c = cos(theta);\n    float s = sin(theta);\n    return  mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n \nmat3 rotate_X(vec2 point) {\n    float theta = point.y;\n    float c = cos(theta);\n    float s = sin(theta);\n    return  mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\nfloat dTooth(vec3 point, vec3 center) {\n    return max(dBox(point - center, vec3(0.05, 0.05, 0.05)),\n           -dSphere(point - center + vec3(0.0, -0.1, 0.0), 0.1));\n}\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nint type = 0;\nvec3 skull_offset;\nfloat sdf(vec3 point) {\n    float back = max(dBox(point + vec3(0.0, 0.0, 0.2), vec3(0.4, 1.0, 0.4)), dSphere(point, 0.5));\n    float face = min(max(dBox(point + vec3(0.0, -0.05, -0.4), vec3(0.4, 0.4, 0.2)),\n      -dSphere(point + vec3(-0.2, -0.1, -0.6), 0.1)),\n      dBox(point + vec3(0.0, 0.5, -0.1), vec3(0.4, 0.3, 0.1)));\n    float tooth = dTooth(point, vec3(0.0, -0.4, 0.5));\n    skull_offset = vec3(sin(iTime * 2.0) / 30.0, -abs(sin(iTime * 2.0)) / 13.5, 0.0);\n    float skull = dBox(point + skull_offset + vec3(0.0, 0.8, -0.4), vec3(0.4, 0.1, 0.2));\n    \n    for (int i = 0; i < 5; ++i) {\n        face = min(face, dTooth(point, vec3(-0.325, -0.4,0.5) + vec3(1.0/6.0 * float(i), 0,0)));\n    }\n    face = max(face, -dSphere(point + vec3(0.6, 0.2, -0.6), 0.25));\n    face = max(face, -dSphere(point + vec3(-0.6, 0.2, -0.6), 0.25));\n    vec3 flipped_point = point;\n    flipped_point.y = -flipped_point.y;\n    skull_offset.y = -skull_offset.y;\n    for (int i = 0; i < 5; ++i) {\n        skull = smin(skull, \n                 dTooth(flipped_point  + skull_offset, vec3(-0.325, 0.65,0.5) + vec3(1.0/6.0 * float(i), 0,0)),\n                 60.0);\n    }\n    float head = smin(back, face, 7.0);\n    head = max(head, -sdTriPrism(point + vec3(0.0, 0.2, -0.6), vec2(0.1)));\n    \n    type = 0;\n    float glas =  dSphere(point + vec3(0.2, -0.1, -0.6), 0.1);\n    if (glas < head) {\n        type = 2;\n    }\n    head = min(head, glas);\n    if (skull < head) {\n        type = 1;\n    }\n    return smin(head, skull, 40.0);\n}\n\n\nvec3 trace(in vec3 from, in vec3 dir, out bool hit) {\n    vec3 hit_point = from;\n    hit_point += 0.05 * dir;\n    float dist;\n    hit = false;\n    for (int i = 0; i < max_steps; i++) {\n        dist = sdf(hit_point);\n        if (dist < 0.005) {\n            hit = true;\n            break;\n        }\n        float step_power = 0.4;\n        hit_point += step_power * abs(dist) * dir;\n        if (dist > 100.0) {\n            break;\n        }\n    }\n    return hit_point;\n}\n\n\nvec3 calculate_normal(vec3 point) {\n    const float eps = 0.0005;\n    float dx = sdf(point + vec3(eps, 0.0, 0.0)) - sdf(point - vec3(eps, 0.0, 0.0));\n    float dy = sdf(point + vec3(0.0, eps, 0.0)) - sdf(point - vec3(0.0, eps, 0.0));\n    float dz = sdf(point + vec3(0.0, 0.0, eps)) - sdf(point - vec3(0.0, 0.0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 getTriplanarWeights ( in vec3 n )\n{\n    vec3 w = abs ( n );\n \n    w *= w;\n \n    return w / ( w.x + w.y + w.z );\n}\n\n\nconst float PI = 3.14159265;\nconst float hole_ratio = 0.5;\nconst float circle_ratio = 0.6;\nconst float hole_dist_ratio = 0.4;\nconst float dist_ratio = 0.8;\nconst vec3 sun_color = vec3(1, 207.0 / 255.0, 72.0 / 255.0);\nconst vec3 mid_color = vec3(244.0 / 255.0, 169.0 / 255.0,0);\nconst vec3 bg_color = vec3(0.5, 0.5, 0.5);\nvec3 sun3(vec2 point, vec2 center, float radius) {\n    if (length(point - center) < circle_ratio * radius) {\n        return mid_color;\n    }\n    return bg_color;\n \n}\n \nvec3 sun2(vec2 point, vec2 center, float radius) {\n    //vec2 mouse = (((iMouse.xy / iResolution.xy) - 0.5) * 2.0) * 3.14;\n    if (length(point - center) < hole_ratio * radius) {\n        float r = cos(sin( 3.1415 / 2.0)) * hole_ratio * 0.8 * radius;\n        return mid_color * (1.0 - smoothstep(r, r * 1.05, length(point - center)));\n    }\n    if (length(point - center) < circle_ratio * radius) {\n        float r = circle_ratio * radius;\n        return sun_color * (1.0 - smoothstep(r, r * 1.05, length(point - center)));\n    }\n    float offset = dist_ratio * radius;\n    float speed = 50.0;\n    float animation = iTime;// mouse.y; // iTime;\n    for (float a_degree = animation * speed; a_degree < animation * speed + 360.0; a_degree += 45.0) {\n        float a = (a_degree / 360.0) * 2.0 * PI;\n        vec2 mini_center = center + (offset) * vec2(cos(a), sin(a));\n        float dist = length(point - mini_center);\n        float mini_radius =  radius - offset;\n        if (dist < mini_radius) {\n            return sun3(point, mini_center, mini_radius);\n        }\n    }\n    return bg_color;\n \n}\n \n \nvec3 sun(vec2 point, vec2 center, float radius) {\n    //vec2 mouse = (((iMouse.xy / iResolution.xy) - 0.5) * 2.0) * 3.14;\n    if (length(point - center) < hole_ratio * radius) {\n        float r = cos(sin(0.0)) * hole_ratio * 0.8 * radius;\n        return mid_color * (1.0 - smoothstep(r, r * 1.05, length(point - center)));\n        //return vec3(0);\n    }\n \n    if (length(point - center) < circle_ratio * radius * 1.02) {\n        float r =  circle_ratio * radius;\n        return sun_color * (1.0 - smoothstep(r*1.0, r * 1.06, length(point - center)));\n    }\n    float offset = dist_ratio * radius;\n    float speed = 30.0;\n    float animation = iTime; // iTime;\n    for (float a_degree = animation * speed; a_degree < animation * speed + 360.0; a_degree += 45.0) {\n        float a = (a_degree / 360.0) * 2.0 * PI;\n        vec2 mini_center = center + (offset) * vec2(cos(a), sin(a));\n        float dist = length(point - mini_center);\n        float mini_radius =  radius - offset;\n        if (dist < mini_radius) {\n            return sun2(point, mini_center, mini_radius);\n        }\n    }\n    return bg_color;\n \n}\n\nvec4 procedural_texture(vec2 pos) {\n \n    return vec4(sun(pos, vec2(-0.2, 0.1), 0.1), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse;\n    if (iMouse.xy == vec2(0,0)) {\n        mouse = vec2(0,0);\n    } else {\n        mouse = (((iMouse.xy / iResolution.xy) - 0.5) * 2.0) * 3.14;\n    }\n    vec2 uv01 = (fragCoord/iResolution.xy);\n    rotate_matrix = rotate_Y(mouse) * rotate_X(mouse);\n    eye = rotate_matrix * eye;\n    light = rotate_matrix * light;\n    vec2 uv = (uv01 - 0.5) * 2.0;\n    const int alias_steps = 2;\n    vec2 half_step = (vec2(1, 1) / iResolution.xy) * 2.0 / float(alias_steps);\n    float displayRatio = iResolution.x / iResolution.y;\n    vec3 viewRay[alias_steps * alias_steps];\n    for (int i = 0; i < alias_steps; i++) {\n        for (int j = 0; j < alias_steps; j++) {\n            viewRay[i*alias_steps + j] = normalize(rotate_matrix * vec3((uv.x + (half_step.x * float(i)))  * displayRatio,\n                            uv.y + half_step.y * float(j), 1.0) - eye);\n        }\n    }\n    vec3 color = vec3(0,0,0);\n    for (int i = 0; i < alias_steps; i++) {\n        for (int j = 0; j < alias_steps; j++) {\n            vec3 part_color;\n            bool hit;\n            vec3 hit_point = trace(eye, viewRay[i*alias_steps + j], hit); //very dangerous\n            vec3 rhit_point = hit_point;\n            vec3 texcord = rhit_point;\n            vec3 texture_colorZY;\n            vec3 texture_colorXZ;\n            vec3 texture_colorXY;\n            if (type == 1) {\n                texcord.x += skull_offset.x;\n                texcord.y -= skull_offset.y;\n                texture_colorZY = texture(iChannel0, texcord.yz).xyz;\n                texture_colorXZ = texture(iChannel0, texcord.zx).xyz;\n                texture_colorXY = texture(iChannel0, texcord.xy).xyz;\n            } else if (type == 2) {\n                texture_colorZY = procedural_texture(vec2(rhit_point.z, rhit_point.y)).xyz;\n                texture_colorXZ = procedural_texture(vec2(rhit_point.x, rhit_point.z)).xyz;\n                texture_colorXY = procedural_texture(rhit_point.xy).xyz;\n            } else {\n                texture_colorZY = texture(iChannel0, texcord.yz).xyz;\n                texture_colorXZ = texture(iChannel0, texcord.zx).xyz;\n                texture_colorXY = texture(iChannel0, texcord.xy).xyz;\n            }\n           \n            vec3 light_ray = normalize(light -  hit_point);\n            vec3 normal = calculate_normal(hit_point);\n            bool shadow_hit = false;\n            trace(hit_point, light_ray, shadow_hit);\n            vec3 w = getTriplanarWeights(normal);\n            vec3 texture_color = w.x * texture_colorZY + w.y * texture_colorXZ + w.z * texture_colorXY;\n            if (hit) {\n                part_color = texture_color * max(dot(normal, light_ray), 0.0);\n                float s =  max(dot(normal, normalize(light_ray - viewRay[i*alias_steps + j])), 0.0);\n                vec3 specular = vec3(1.0, 1.0, 1.0) * pow(s, 100.0);\n                part_color += 2.0 * specular;\n            } else {\n                part_color = vec3(0.4, 0.4, 1.0);\n            }\n           if (shadow_hit) {\n                part_color *= 0.5;\n           }\n            color += part_color / float(alias_steps * alias_steps);\n        }\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}