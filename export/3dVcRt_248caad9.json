{"ver":"0.1","info":{"id":"3dVcRt","date":"1641571862","viewed":56,"name":"Visualizer - StevenAnnunziato","username":"StevenAnnunziato","description":"An audio visualizer in a raytraced scene.\nNote: if the audio doesn't play, go to Buffer A, iChannel0 and click the play button. Feel free to try different music tracks here too.\n\nDrag the mouse on the screen to make interesting things happen.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // find normalized UV coordinates\n    vec2 invRes = 1.0 / iResolution.xy;    \n    vec2 uv = fragCoord * invRes;\n\n    // Output to screen\n    //fragColor = texture(iChannel0, uv); // music\n    //fragColor = texture(iChannel1, uv); // procedural texture\n    //fragColor = texture(iChannel2, uv); // ray tracing\n    fragColor = texture(iChannel3, uv); // after effects\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// BUFFER A: Music buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // find normalized UV coordinates\n    vec2 invRes = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    \n    // sample music\n    fragColor = texture(iChannel0, vec2(uv.x, 0.0)).xxxx;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// color scheme\n\nconst float colorCycleSpeed = 0.1;\nconst float brightnessCycleSpeed = 0.8;\n\n// after effect intensity\n// try (0.99, 0.1) and see what happens\n#define PSYCHEDELIC_FACTOR 0.2\n#define BLUR_AMOUNT 0.9\n\n// hueshift function adapted from user mAlk:\n// https://www.shadertoy.com/view/MsjXRt\nvec4 hueShift(in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735) * dot(vec3(0.55735), Color);\n    vec3 U = Color - P;\n    vec3 V = cross(vec3(0.55735), U);\n    \n    Color = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;\n    return vec4(Color, 1.0);\n}\n\n// Primary color of the color scheme\nvec4 colorA(in float t)\n{\n    return hueShift(vec3(1.0, 0.0, 0.0), t * colorCycleSpeed);\n}\n\n// Complementary to colorA\nvec4 colorB(in float t)\n{\n    return hueShift(vec3(1.0, 0.0, 0.0), t * colorCycleSpeed + 0.5);\n}\n\n// White-grey color\nvec4 neutralColor(in float t)\n{\n    // ensure value is [0, 1]\n    return vec4((sin(t * brightnessCycleSpeed) + 1.0) * 0.5);\n}\n\n// -------------------------------------------------------------------\n// Data structures for Raytracing\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec4 diffuseColor;\n};\n    \nstruct HitRecord {\n\tvec3 point;\n    float t;\n    vec3 normal;\n    bool frontFace;\n    vec4 diffuseColor;\n};\n    \nstruct Ray {\n\tvec4 origin;\n    vec4 direction;\n};\n    \n// structure for a point light\nstruct sPointLight\n{\n    vec4 center;\n    vec4 color;\n    float intensity;\n};\n\n\n// --------------------------------------------\n// Utility Functions    \n    \n// asPoint: promote a 3D vector into a 4D vector representing a point (w=1)\n//    point: input 3D vector\nvec4 asPoint(in vec3 point)\n{\n    return vec4(point, 1.0);\n}\n\n// asOffset: promote a 3D vector into a 4D vector representing an offset (w=0)\n//    offset: input 3D vector\nvec4 asOffset(in vec3 offset)\n{\n    return vec4(offset, 0.0);\n}\n\n// returns a random int [0, 1)\n// taken from this site: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat randomFloat(vec2 seed) {\n    return fract(sin(dot(seed.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat lengthSquared(vec2 x) {\n    return dot(x, x);\n}\n\n// optimized power increase functions\nfloat square(float n)\n{\n    return n * n;\n}\nfloat pow64(float n)\n{\n    n *= n; // power = 2\n    n *= n; // power = 4\n    n *= n; // power = 8\n    n *= n; // power = 16\n    n *= n; // power = 32\n    n *= n; // power = 64\n    return n;\n}\nfloat pow256(float n)\n{\n    n *= n; // power = 2\n    n *= n; // power = 4\n    n *= n; // power = 8\n    n *= n; // power = 16\n    n *= n; // power = 32\n    n *= n; // power = 64\n    n *= n; // power = 128\n    n *= n; // power = 256\n    return n;\n}\n\n// polar to cartesian function\nvec2 polarToCartesian(in float radius, in float theta)\n{\n    return vec2(radius * cos(theta), radius * sin(theta));\n}\n\n// initialize point light\nvoid initPointLight(out sPointLight light, in vec3 center, in vec4 color, in float intensity)\n{\n    light.center = asPoint(center);\n    light.color = color;\n    light.intensity = intensity;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// BUFFER B: Texture pattern\n\nconst float numStripes = 8.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // calculate inverse resolution and uv values\n    vec2 invRes = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    \n    // apply a repeating wave offset\n    float musicOffset = texture(iChannel0, vec2(0.4, 0.25)).x * 0.15;\n    // ensure the input lies between 0 and 2*pi\n    float t = fragCoord.y * invRes.y * 6.28;\n    uv.x += sin(t + iTime) * musicOffset;\n    \n    // draw stripes\n    float stripeIntensity = mod(floor(numStripes * (uv.x)), 2.0);\n    if (stripeIntensity == 0.0)\n        fragColor = colorA(iTime);\n    else\n        fragColor = colorB(iTime);\n    \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n\nBUFFER C: Raytracing\n\nOriginal code provided by Dan Buckstien\nModified by Steven Annunziato\nModifications are adapted from Peter Shirley's Ray Tracing in One Weekend\nhttps://raytracing.github.io/books/RayTracingInOneWeekend.html#rays,asimplecamera,andbackground\n\n*/\n\n// get point on ray\nvec3 at(Ray ray, float t)\n{\n\treturn ray.origin.xyz + ray.direction.xyz * t;\n}    \n \n// determine the correct way to set the face normal\nvoid setFaceNormal(Ray ray, in vec3 outwardNormal, out HitRecord record) {\n    if (dot(ray.direction.xyz, outwardNormal) > 0.0) {\n        // ray is inside the sphere\n        record.normal = -outwardNormal;\n        record.frontFace = false;\n    }\n    else {\n        // ray is outside the sphere\n        record.normal = outwardNormal;\n        record.frontFace = true;\n    }\n}\n\n// -----------------------------------------------------------\n// INTERSECTION\n\n// detect if a ray has intersected a sphere with clamped t value\nbool hitSphere(in vec3 center, in float radius, in Ray ray, in float tMin, in float tMax, out HitRecord record)\n{\n\t// calculate if the ray hits a sphere\n    vec3 oc = ray.origin.xyz - center;\n    float a = dot(ray.direction, ray.direction);\n    float half_b = dot(oc, ray.direction.xyz);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = half_b * half_b - a * c;\n    \n    if (discriminant > 0.0) {\n        float root = sqrt(discriminant);\n        \n        float temp = (-half_b - root) / a;\n        if (temp > tMin && temp < tMax) {\n            // calculate hit record information\n            record.t = temp;\n            record.point = at(ray, temp);\n            vec3 outwardNormal = (record.point - center) / radius;\n            setFaceNormal(ray, outwardNormal, record);\n            return true;\n        }\n        \n        temp = (-half_b + root) / a;\n        if (temp > tMin && temp < tMax) {\n            // calculate hit record information\n            record.t = temp;\n            record.point = at(ray, temp);\n            vec3 outwardNormal = (record.point - center) / radius;\n            setFaceNormal(ray, outwardNormal, record);\n            return true;\n        }\n    }\n    \n    return false;\n    \n}\n\n// consumes an array of spheres and a ray, and determines if any of the spheres have been hit\nbool hitSphereArray(in Sphere spheres[10], in Ray ray, in float tMin, in float tMax, out HitRecord record)\n{\n    HitRecord tempRecord;\n    bool hitAnything = false;\n    float closestSoFar = tMax;\n    \n    // loop through each sphere to determine if there is a hit\n    for (int i = spheres.length() - 1; i >= 0; --i)\n    {\n        if (hitSphere(spheres[i].center, spheres[i].radius, ray, tMin, closestSoFar, tempRecord))\n        {\n            hitAnything = true;\n            closestSoFar = tempRecord.t;\n            record = tempRecord;\n            record.diffuseColor = spheres[i].diffuseColor;\n        }\n    }\n    \n    // nothing is hit\n    return hitAnything;\n}\n\n// Adapted from Inigo Quilez\n// https://iquilezles.org/articles/intersectors\n// note: normal must be normalized\nfloat planeIntersect(in Ray ray, in vec4 normal, out HitRecord record)\n{\n    float t = -(dot(ray.origin.xyz, normal.xyz) + normal.w) / dot(ray.direction.xyz, normal.xyz);\n    record.normal = normal.xyz;\n    record.point = (ray.origin + t * ray.direction).xyz;\n    return t;\n}\n\n// ---------------------------------------------------------------------\n// LIGHTING\n\n// calculations for diffuse light scattering\nfloat calcDiffuse(in sPointLight light, in vec3 position, in vec3 normal, out vec3 lightVector)\n{\n    // lambertian reflectance\n    //lightVector = light.center.xyz - position;\n    float lightDist = sqrt(dot(lightVector, lightVector));\n    float invDist = 1.0 / lightDist;\n    lightVector *= invDist; // light vector is now normalized\n    float diffuseCoefficient = max(0.0, dot(normal, lightVector));\n    // attenuation (light falloff)\n    float invIntensity = 1.0 / light.intensity;\n    float attenuatedIntensity = 1.0 / (1.0 + (lightDist * invIntensity) + square(lightDist * invIntensity));\n    return diffuseCoefficient * attenuatedIntensity;\n}\n\n// calculations for specular highlights\nfloat phongSpecular(in vec3 lightVector, in vec3 viewVector, in vec3 normal)\n{\n    // phong reflectance\n    vec3 reflectedLight = reflect(-lightVector, normal);\n    float specularCoefficient = max(0.0, dot(viewVector, reflectedLight));\n    return pow64(specularCoefficient);\n}\n\nfloat blinnPhongSpecular(in vec3 lightVector, in vec3 viewVector, in vec3 normal)\n{\n    // blinn-phong reflectance\n    vec3 temp = lightVector + viewVector;\n    float invLength = 1.0 / sqrt(dot(temp, temp));\n    vec3 halfwayVector = temp * invLength;\n    float specularCoefficient = max(0.0, dot(normal, halfwayVector));\n    return pow256(specularCoefficient);   \n}\n\nvec4 calcLighting(Ray ray, HitRecord record, vec3 eyePos, sPointLight[4] lights, in vec4 diffuseColor)\n{\n    \n    // SHADING\n    // light and color properties\n    float ambientIntensity = 0.07;\n    vec4 ambientColor = vec4(0.8, 0.8, 0.9, 1.0);\n    vec4 specularHighlightColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    // final calculation\n    vec4 finalAmbient = ambientIntensity * ambientColor;\n    vec4 summedColor = vec4(0.0);\n    // loop through each light\n    for (int i = lights.length() - 1; i >= 0; --i) {\n\n        vec3 lightVector = lights[i].center.xyz - record.point;\n        vec3 viewVector = eyePos - record.point; // not normalized\n        float invLength = 1.0 / sqrt(dot(viewVector, viewVector));\n        viewVector *= invLength; // normalized\n\n        // first calculate diffuse intensity\n        float diffuseIntensity = calcDiffuse(lights[i], record.point, record.normal, lightVector);\n\n        // next calculate specular intensity\n        float specularIntensity = blinnPhongSpecular(lightVector, viewVector, record.normal);\n        specularIntensity *= neutralColor(iTime).x;\n\n        // final calculation\n        summedColor += (diffuseIntensity * diffuseColor + specularIntensity * specularHighlightColor) * lights[i].color;\n    }\n    return finalAmbient + summedColor;   \n}\n\n// ---------------------------------------------------------------------\n// RENDERING\n\n// calcViewport: calculate the viewing plane (viewport) coordinate\n//    viewport:       output viewing plane coordinate\n//    ndc:            output normalized device coordinate\n//    uv:             output screen-space coordinate\n//    aspect:         output aspect ratio of screen\n//    resolutionInv:  output reciprocal of resolution\n//    viewportHeight: input height of viewing plane\n//    fragCoord:      input coordinate of current fragment (in pixels)\n//    resolution:     input resolution of screen (in pixels)\nvoid calcViewport(out vec2 viewport, out vec2 ndc, out vec2 uv,\n                  out float aspect, out vec2 resolutionInv,\n                  in float viewportHeight, in vec2 fragCoord, in vec2 resolution)\n{\n    // inverse (reciprocal) resolution = 1 / resolution\n    resolutionInv = 1.0 / resolution;\n    \n    // aspect ratio = screen width / screen height\n    aspect = resolution.x * resolutionInv.y;\n\n    // uv = screen-space coordinate = [0, 1) = coord / resolution\n    uv = fragCoord * resolutionInv;\n    //uv = (fragCoord + vec2(randomFloat(fragCoord))) * resolutionInv;\n\n    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1\n    ndc = uv * 2.0 - 1.0;\n\n    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)\n    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));\n}\n\n// calcRay: calculate the ray direction and origin for the current pixel\n//    ray:\t\t\toutput direction and origin of ray\n//\t  eyePos:\t\tposition of camera or eye\n//    viewport:     input viewing plane coordinate (use above function to calculate)\n//    focalLength:  input distance to viewing plane\nvoid calcRay(out Ray ray, in vec3 eyePos,\n             in vec2 viewport, in float focalLength)\n{\n    // ray origin relative to viewer is the origin\n    // w = 1 because it represents a point; can ignore when using\n    ray.origin = vec4(eyePos.xyz, 1.0);\n\n    // ray direction relative to origin is based on viewing plane coordinate\n    // w = 0 because it represents a direction; can ignore when using\n    ray.direction = vec4(viewport.x, viewport.y, -focalLength, 0.0);\n}\n\n// calcColor: calculate the color of a pixel given a ray\n//    rayDirection: input ray direction\n//    rayOrigin:    input ray origin\nvec4 calcColor(in Ray ray, in Sphere spheres[10], in vec3 eyePos)\n{\n\n\t// lighting properties and animation values\n    float intensity = 20.0;\n    float orbitRadius = 4.0;\n    float offset = 3.14;\n    float depth = 3.5;\n    float height = 2.0;\n    vec3 lightPos1 = vec3(sin(iTime) * orbitRadius,          height, cos(iTime) * orbitRadius - depth);\n    vec3 lightPos2 = vec3(sin(iTime + offset) * orbitRadius, height, cos(iTime + offset) * orbitRadius - depth);\n    \n    // light definitions\n    vec4 lightColor = vec4(neutralColor(iTime).x) * 0.7 + 0.3;\n    sPointLight light1;\n    initPointLight(light1, lightPos1, lightColor, intensity);\n    sPointLight light2;\n    initPointLight(light2, lightPos2, lightColor, intensity);\n    \n    // array of lights\n    sPointLight lights[4];\n    lights[0] = light1;\n    lights[1] = light2;\n    \n    // create hit records for all objects in the world (aka the array of spheres)\n    HitRecord record;\n    if (hitSphereArray(spheres, ray, 0.0, 10000.0, record))\n    {\n        return calcLighting(ray, record, eyePos, lights, record.diffuseColor);\n    }\n    \n    // draw plane\n    float wobbleIntensity = 0.2;\n    float wobbleSpeed = 0.6;\n    vec3 planeNormal = vec3(sin(iTime * wobbleSpeed) * wobbleIntensity, 1.0, cos(iTime * wobbleSpeed) * wobbleIntensity);\n    float invNLength = 1.0 / sqrt(dot(planeNormal, planeNormal));\n    planeNormal *= invNLength; // normalized\n\tif (planeIntersect(ray, asOffset(planeNormal), record) > 0.0)\n    {\n        vec4 lightIntensity = calcLighting(ray, record, eyePos, lights, vec4(1.0));\n        \n        // sample from buffer B: generated texture\n        vec2 texCoord = vec2(record.point.x, record.point.z);\n        vec4 texColor = texture(iChannel1, texCoord);\n        \n        return texColor * lightIntensity;\n    }\n    \n    // calculate unit vector for the current ray direction\n    float invLength = 1.0 / sqrt(dot(ray.direction.xyz, ray.direction.xyz));\n    vec4 unitDirection = vec4(ray.direction.xyz * invLength, ray.direction.w);\n    \n    // output a gradient in the background\n    float t = 0.8 * (unitDirection.y + 0.3);\n    return (1.0 - t) * colorA(iTime) + t * neutralColor(iTime);\n}\n\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // viewing plane (viewport) info\n    vec2 viewport, ndc, uv, resolutionInv;\n    float aspect;\n    const float viewportHeight = 2.0, focalLength = 1.0;\n    vec3 eyePos = vec3(0.0, 0.5, 0.0);\n\n    // ray\n    Ray ray;\n\n    // setup\n    calcViewport(viewport, ndc, uv, aspect, resolutionInv,\n                 viewportHeight, fragCoord, iResolution.xy);\n    calcRay(ray, eyePos,\n            viewport, focalLength);\n\n    // sample music\n    float scaleModifier = 1.6;\n    float subBass = texture(iChannel0, vec2(0.0, 0.0)).x * scaleModifier;\n    float bass = texture(iChannel0, vec2(0.13, 0.0)).x * scaleModifier;\n    float lowMid = texture(iChannel0, vec2(0.4, 0.0)).x * scaleModifier;\n    float highMid = texture(iChannel0, vec2(0.6, 0.0)).x * scaleModifier;\n    float high = texture(iChannel0, vec2(0.8, 0.0)).x * scaleModifier;\n    float brilliance = texture(iChannel0, vec2(0.95, 0.0)).x * scaleModifier;\n    \n    // sample mouse position\n    vec2 mouseValue = iMouse.xy;\n    // correct sensitivity\n    mouseValue *= vec2(0.005, 0.005);\n    // reset rotation when not clicking\n    mouseValue *= float(iMouse.z > 0.0);\n    \n    // create spheres\n    // position for the main sphere\n    vec3 mainPos = vec3(0.0, 0.0, -4.0);\n    \n    // values for animation\n    float angle = 1.0471;\n    float orbitRadius = 2.5 + sin(iTime * 0.8) * 0.9 + mouseValue.x * 0.2;\n    float radialSpeed = (1.0 + mouseValue.x * 0.015) * iTime;\n    float extraHeight = 1.0 + mouseValue.y;\n    float scale1 = (0.4 + subBass * 0.4);\n    // positions for orbiting spheres\n    vec3 circlePos1 = vec3(sin(radialSpeed) * orbitRadius,               lowMid * extraHeight - 0.5,     cos(radialSpeed) * orbitRadius);\n    vec3 circlePos2 = vec3(sin(radialSpeed + angle) * orbitRadius,       brilliance * extraHeight - 0.5, cos(radialSpeed + angle) * orbitRadius);\n    vec3 circlePos3 = vec3(sin(radialSpeed + angle * 2.0) * orbitRadius, lowMid * extraHeight - 0.5,     cos(radialSpeed + angle * 2.0) * orbitRadius);\n    vec3 circlePos4 = vec3(sin(radialSpeed + angle * 3.0) * orbitRadius, brilliance * extraHeight - 0.5, cos(radialSpeed + angle * 3.0) * orbitRadius);\n    vec3 circlePos5 = vec3(sin(radialSpeed + angle * 4.0) * orbitRadius, lowMid * extraHeight - 0.5,     cos(radialSpeed + angle * 4.0) * orbitRadius);\n    vec3 circlePos6 = vec3(sin(radialSpeed + angle * 5.0) * orbitRadius, brilliance * extraHeight - 0.5, cos(radialSpeed + angle * 5.0) * orbitRadius);\n    circlePos1 += mainPos;\n    circlePos2 += mainPos;\n    circlePos3 += mainPos;\n    circlePos4 += mainPos;\n    circlePos5 += mainPos;\n    circlePos6 += mainPos;\n    \n    // declare spheres\n    float shift = 0.0;\n    Sphere sphere1 = Sphere(mainPos, scale1, neutralColor(iTime)); // main\n    Sphere sphere2 = Sphere(circlePos1, 0.45, colorA(iTime + shift));\n    Sphere sphere3 = Sphere(circlePos2, 0.4, colorB(iTime + shift));\n    Sphere sphere4 = Sphere(circlePos3, 0.45, colorA(iTime + shift));\n    Sphere sphere5 = Sphere(circlePos4, 0.4, colorB(iTime + shift));\n    Sphere sphere6 = Sphere(circlePos5, 0.45, colorA(iTime + shift));\n    Sphere sphere7 = Sphere(circlePos6, 0.4, colorB(iTime + shift));\n    \n    // add spheres to world\n    Sphere world[10];\n    world[0] = sphere1;\n    world[1] = sphere2;\n    world[2] = sphere3;\n    world[3] = sphere4;\n    world[4] = sphere5;\n    world[5] = sphere6;\n    world[6] = sphere7;\n    \n    // final color\n    fragColor = calcColor(ray, world, eyePos);\n    \n}\n\n/*\n\n#version 300 es\n\n// inputs (later)\n// uniforms (see shader inputs above)\n\n// output\nlayout (location = 0) out vec4 rtFragColor;\n\n// specific to shadertoy\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord);\n\nvoid main()\n{\n\t// shadertoy specific\n\tmainImage(rtFragColor, gl_FragCoord.xy); // gl_FragCoord.xy is from the hardware\n}\n\n*/","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// BUFFER D: After Effects\n\n// wave vec2\nvec2 wave(in vec2 originalLocation, in float t)\n{\n    vec2 deformedLocation = originalLocation;\n    \n    // shift coordinate by a sine function of the location\n    deformedLocation.y += sin(originalLocation.x * 6.0 + t * 2.0) * 0.012;\n    deformedLocation.x += sin(originalLocation.y * 6.0 + t * 2.0) * 0.012;\n    \n    // return deformed coordinate\n    return deformedLocation;\n}\n\n// Time accumulation method adapted from user qwzy:\n//https://www.shadertoy.com/view/Xlt3DX\nvec4 fadeColor(in vec2 uv, in float blur)\n{\n    \n    vec3 cur = texture(iChannel1, uv).xyz;\n    vec3 acc = texture(iChannel0, uv).xyz;\n    acc = hueShift(acc, 0.02).rgb;\n    acc *= 1.001;\n    \n    return vec4(cur * blur + acc * (1.0 - blur), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // calculate inverse resolution and uv values\n    vec2 invRes = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    \n    uv = mix(uv, wave(uv, iTime), PSYCHEDELIC_FACTOR);\n    \n    fragColor = fadeColor(uv, BLUR_AMOUNT);\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}