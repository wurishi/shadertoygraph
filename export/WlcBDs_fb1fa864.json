{"ver":"0.1","info":{"id":"WlcBDs","date":"1614297175","viewed":58,"name":"6 - Reflections with Cube Maps","username":"francislarge","description":" ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"3ttBWf","parentname":"5 - Reflection"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Light\n{\n    int   Type;\n    vec3  Position;   //for point light\n    vec3  Direction; //for directional light\n    float Intensity;\n};\n\n//Current light types. \n#define POINT_LIGHT       0\n#define DIRECTIONAL_LIGHT 1\n\n#define TOTAL_LIGHTS 4\nvec3 ComputeLightingAndReturnFinalColor(Light SceneLights[TOTAL_LIGHTS], int LightCount, vec3 SurfacePosition, vec3 SurfaceNormal, vec3 ToEyeRay, FMaterial SurfaceMaterial);\n\n#define TOTAL_SCENE_OBJECTS 3\nFHitResult RayCast(ASphere SceneSpheres[TOTAL_SCENE_OBJECTS], int ObjectsCount, ARay Ray);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float angle = iTime * 0.2;\n   vec3 XBasis = vec3(cos(angle), 0.0, sin(angle));\n   vec3 ZBasis = vec3(-XBasis.z, 0, XBasis.x);\n   vec3 CameraPosition = vec3(+0, 0, -6) + (ZBasis * 15.0);\n\n    \n    //Camera Definition\n    Camera MainCamera;\n    MainCamera.FOV         = 40.f;\n    MainCamera.Basis       = mat3(XBasis, vec3(0,1,0),ZBasis);\n    MainCamera.Position    = CameraPosition; \n    MainCamera.AspectRatio = iResolution.x/iResolution.y;\n\tMainCamera.ImagePlane.Z          = 1.f;\n\tMainCamera.ImagePlane.HalfHeight = tan(radians(MainCamera.FOV/2.f)) * MainCamera.ImagePlane.Z;\n\tMainCamera.ImagePlane.HalfWidth  = MainCamera.ImagePlane.HalfHeight * MainCamera.AspectRatio; \n   \n    //Ray Definition\n    vec2 FragCoord_NegOne_to_One = RemapVector_To_NegOne_to_One(fragCoord.xy, iResolution.xy);\n    FragCoord_NegOne_to_One.x *= MainCamera.ImagePlane.HalfWidth;\n\tFragCoord_NegOne_to_One.y *= MainCamera.ImagePlane.HalfHeight;\n    \n    ARay CameraRay;\n    CameraRay.Position  = MainCamera.Position;\n    CameraRay.Direction = vec3(FragCoord_NegOne_to_One, -MainCamera.ImagePlane.Z);\n    CameraRay.Direction = normalize( MainCamera.Basis * CameraRay.Direction );\n    \n    \n    //Scene Objects definition and material assignment. Material struct is defined in common\n       //(BaseColor, AmbienceFactor, Diffuseness, Specularity, Shineness)\n    FMaterial DefaultMaterial = FMaterial(vec3(1), 0.1, 1.0, 1.0, 400.0);\n    \n    ASphere Sphere1 = ASphere(vec3(-3, 1, -5), 1.5f, DefaultMaterial);\n    ASphere Sphere2 = ASphere(vec3(+0, 0, -6), 1.f, DefaultMaterial);\n    ASphere Sphere3 = ASphere(vec3(+3, 0, -6), 1.5f, DefaultMaterial);\n    \n    Sphere1.Material.BaseColor = vec3(1, 1, 0);\n    Sphere2.Material.BaseColor = vec3(1,0,0);\n    Sphere3.Material.BaseColor = vec3(1, 0, 1);\n    \n    Sphere2.Material.Specularity = 1.0;\n\n    //Lighting\n    Light PointLight1, DirectionalLight1; \n    PointLight1.Type      = POINT_LIGHT;\n    PointLight1.Intensity = 0.1;\n    PointLight1.Position  = vec3(0, 0, 100);\n\n    DirectionalLight1.Type      = DIRECTIONAL_LIGHT;\n    DirectionalLight1.Intensity = 0.1;\n    DirectionalLight1.Direction = vec3(0, -1, 0);\n        \n    //Ray cast on scene objects\n    ASphere SceneObjects[TOTAL_SCENE_OBJECTS] = ASphere[](Sphere1, Sphere2, Sphere3);\n    FHitResult HitResult = RayCast(SceneObjects, 3, CameraRay);\n    \n    //Determine final color and it's intensity\n    vec3 FinalColor;\n    \n    float CubeMapIntensity = 1.0;\n    if(HitResult.bWasAHit)\n    {\n        Light Lights[TOTAL_LIGHTS];\n        Lights[0] = DirectionalLight1;\n        Lights[1] = PointLight1;\n                \n        vec3 RootSurfaceHit_LitColor = ComputeLightingAndReturnFinalColor(\n            Lights,\n            2,\n            HitResult.HitLocation, \n            HitResult.HitNormal, \n            -CameraRay.Direction, \n            HitResult.ObjectHit.Material\n         );\n        \n        if(HitResult.ObjectHit.Material.Specularity > 0.0) \n        {\n            int RayBounces = 0, MaxRayBounces = 5;\n            \n            FHitResult OldHitResult = HitResult;\n            ARay OldRay = CameraRay;\n            while(RayBounces++ < MaxRayBounces)\n            {\n                if(OldHitResult.ObjectHit.Material.Specularity > 0.0) \n                {\n                    ARay NewRay = ARay(OldHitResult.HitLocation, reflect(OldRay.Direction, OldHitResult.HitNormal));\n                    \n                    FHitResult NewHitResult = RayCast(SceneObjects, 3, NewRay);\n                    if(NewHitResult.bWasAHit)\n                    {\n                        \n                        vec3 SurfaceHit_LitColor = ComputeLightingAndReturnFinalColor(\n                                Lights,\n                                2,\n                                NewHitResult.HitLocation, \n                                NewHitResult.HitNormal, \n                                -NewRay.Direction, \n                                NewHitResult.ObjectHit.Material\n                         );\n                         \n                         \n                         RootSurfaceHit_LitColor = mix(RootSurfaceHit_LitColor, \n                                SurfaceHit_LitColor, \n                                OldHitResult.ObjectHit.Material.Specularity\n                          );\n                        \n                        OldHitResult = NewHitResult;\n                        OldRay = NewRay;\n                    }\n                    else \n                    {\n                        \n                        RootSurfaceHit_LitColor = mix(RootSurfaceHit_LitColor, \n                                texture(iChannel0, NewRay.Direction).rgb,\n                                OldHitResult.ObjectHit.Material.Specularity\n                          ) * CubeMapIntensity;//length(texture(iChannel0, NewRay.Direction).rgb) ;\n                        break;\n                    }\n                }\n                \n            }\n            \n        }\n        \n        FinalColor = RootSurfaceHit_LitColor;\n    }\n    else\n    {\n        FinalColor = texture(iChannel0, CameraRay.Direction).rgb * CubeMapIntensity;\n    }\n\n\tfragColor = vec4(FinalColor, 1);\n}\n\nvec3 ComputeLightingAndReturnFinalColor(Light SceneLights[TOTAL_LIGHTS], int LightCount, vec3 SurfacePosition, vec3 SurfaceNormal, vec3 ToEyeRay, FMaterial SurfaceMaterial)\n{\n    vec3 FinalColor = SurfaceMaterial.BaseColor * SurfaceMaterial.AmbienceFactor; \n        \n    for(int i = 0; i < LightCount; i++)\n    {\n        Light CurrentLight = SceneLights[i];\n        vec3 ToLightSource;\n            \n        if( CurrentLight.Type == POINT_LIGHT)\n        {\n            ToLightSource = normalize( CurrentLight.Position - SurfacePosition );\n        }\n        else if(CurrentLight.Type == DIRECTIONAL_LIGHT)\n        {\n            ToLightSource = normalize(-CurrentLight.Direction);\n        }\n        \n       \n        //Diffuse lighting\n        float N_Dot_D                    = dot(SurfaceNormal, ToLightSource);\n        float LightDistributionOnSurface = max(N_Dot_D, 0.0) * CurrentLight.Intensity; \n        \n        FinalColor += SurfaceMaterial.BaseColor * (SurfaceMaterial.Diffuseness * LightDistributionOnSurface);\n        \n        //Specular lighting\n        vec3  ReflectedLightRay = reflect(-ToLightSource, SurfaceNormal);\n        float Reflected_Dot_Eye = dot(ToEyeRay, ReflectedLightRay);\n            \n        float SpecularDistributionOnSurface = pow( max(Reflected_Dot_Eye, 0.0), SurfaceMaterial.Shineness) * CurrentLight.Intensity;\n            \n        FinalColor += SurfaceMaterial.BaseColor * (SurfaceMaterial.Specularity * SpecularDistributionOnSurface);\n     \n    }\n    \n    \n       \n    \n    \n    return FinalColor; \n}\n\nFHitResult RayCast(ASphere SceneSpheres[TOTAL_SCENE_OBJECTS], int ObjectsCount, ARay Ray)\n{\n    FHitResult FinalHitResult;\n    \n    float ClosestT = -1.f;\n    bool  bFirstTimeCheck = true;\n    \n    for(int CurrentSphere = 0; CurrentSphere < ObjectsCount; CurrentSphere++)\n    {\n        FHitResult CurrentHitResult = SphereRayIntersection(SceneSpheres[CurrentSphere], Ray);\n        if(CurrentHitResult.bWasAHit)\n        {\n            if(bFirstTimeCheck)\n            {\n                ClosestT = CurrentHitResult.t;\n                \n                FinalHitResult = CurrentHitResult;\n                bFirstTimeCheck = false;\n            }\n            \n            if(CurrentHitResult.t < ClosestT)\n            {\n                ClosestT = CurrentHitResult.t;\n                FinalHitResult = CurrentHitResult;\n            }\n        }\n    }\n    \n    if(ClosestT != -1.f)\n    {\n        return FinalHitResult;\n    }\n\n\n\n    FinalHitResult.bWasAHit = false;\n    return FinalHitResult;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Containers\nstruct FImagePlane\n{\n    float HalfHeight;\n    float HalfWidth;\n    float Z;\n};\nstruct Camera\n{   \n    mat3  Basis;\n    vec3  Position;\n    float FOV;\n    float AspectRatio;\n    FImagePlane ImagePlane;\n};\n\nstruct ARay\n{\n    vec3 Position;\n    vec3 Direction;\n};\n\nstruct FMaterial\n{\n    vec3  BaseColor;\n    float AmbienceFactor;\n    float Diffuseness;\n    float Specularity;\n    float Shineness;\n};\n\n//TODO: Maybe change 'ASphere' to 'Object' and \n//assign a type to each one so they can all be put in one array\nconst int ObjectType_SPHERE = 0;\nconst int ObjectType_PLANE  = 1;\nstruct ASphere   \n{\n    vec3  Location; \n    float Radius;\n    FMaterial Material;\n};\n\nstruct FHitResult { bool bWasAHit; ASphere ObjectHit; vec3 HitLocation; vec3 HitNormal; float t; float x; };\n\n//Functions Declarations\nFHitResult SphereRayIntersection(ASphere SceneSphere, ARay Ray);\nvec3  RemapUnitVectorBtw_0_to_1(vec3 Normal);\nfloat Remap_X_Btw_0_And_1_Based_On_Radius(float x, float radius);\nvec2  RemapVector_To_NegOne_to_One(vec2 Vector2D, vec2 Boundary2D);\n\n\n//Function definitions \nFHitResult SphereRayIntersection(ASphere SceneSphere, ARay Ray)\n{\n    vec3 RayPosition  = Ray.Position;\n    vec3 RayDirection = Ray.Direction;\n    \n\tfloat DistanceToSphere = dot(SceneSphere.Location - RayPosition, RayDirection);\n\n\tFHitResult HitResult;\n\tif(DistanceToSphere > 1.f) //basically: distnce should be at least (> 1) in front of the image plane\n\t{\n\t\tfloat y = length( (RayPosition + RayDirection * DistanceToSphere) - SceneSphere.Location );\n\n\t\tif(y <= SceneSphere.Radius)\n\t\t{\n\t\t\tfloat x = sqrt(SceneSphere.Radius * SceneSphere.Radius - y * y);\n\n            float t1 = DistanceToSphere - x; //first point of ray intersection with the sphere\n            float t2 = DistanceToSphere + x; //second point of intersection/ray exit point\n\n\t\t\tHitResult.bWasAHit = true;\n\t\t\tHitResult.HitLocation = RayPosition + RayDirection * t1;\n\t\t\tHitResult.HitNormal = normalize( HitResult.HitLocation - SceneSphere.Location );\n\t\t\tHitResult.t = t1;\n\t\t\tHitResult.x = x;\n            \n            HitResult.ObjectHit = SceneSphere;\n\n\t\t\treturn HitResult;\n\t\t}\n        \n        HitResult.bWasAHit = false;\n\t\treturn HitResult;\n\t}\n\n\tHitResult.bWasAHit = false;\n\treturn HitResult;\n}\n\nvec3 RemapUnitVectorBtw_0_to_1(vec3 Normal)\n{\n\treturn (Normal + vec3(1.f)) / vec3(2.f);\n}\n\nfloat Remap_X_Btw_0_And_1_Based_On_Radius(float x, float radius)\n{\n\t// //for every x we calculate, what's it's distance from the radius in a 0 to 1 range\n\treturn x / radius;\n}\n\nvec2 RemapVector_To_NegOne_to_One(vec2 Vector2D, vec2 Boundary2D)\n{\n\treturn (Vector2D * 2.f)/Boundary2D - vec2(1.f);\n}","name":"Common","description":"","type":"common"}]}