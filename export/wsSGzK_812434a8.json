{"ver":"0.1","info":{"id":"wsSGzK","date":"1549331225","viewed":143,"name":"GLSL Workshop","username":"lesleylai","description":"GLSL workshop for the CU Computer Graphics Group","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TUTORIAL 12\n\n/**\n  * Lists\n  * 1. Hello world\n  * 2. The coordinate system\n  * 3. Step function\n  * 4. Line drawing\n  * 5. Smooth step function\n  * 6. Shapes: Rectangle\n  * 7. Color subtraction\n  * 8. Shapes: Circle\n  * 10: Transformation: Rotation\n  * 11: Rotation against arbitrary point\n  * 12: Some fun\n  */\n\n// Hello world\n#if TUTORIAL == 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Time varying pixel color\n    vec3 col = vec3(0., 0., 1.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// The coordinate system\n#if TUTORIAL == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0., 0., 1.);\n    if (uv.x < .2) {\n        col += vec3(0., 1., 0.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Step function\n#if TUTORIAL == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0., 0., 1.);\n    col += (1. - step(0.2, uv.x)) * vec3(0., 1., 0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Line drawing\n#if TUTORIAL == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.);\n    col += (\n        step(fragCoord.x, fragCoord.y * 1.8) - (step(fragCoord.x, fragCoord.y * 1.8 - 5.))\n    )  * vec3(1.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Smooth-step function\n#if TUTORIAL == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.);\n    col += (\n        smoothstep(fragCoord.x - 2., fragCoord.x + 2., fragCoord.y * 1.8)\n     - (smoothstep(fragCoord.x - 2., fragCoord.x + 2., fragCoord.y * 1.8 - 5.))\n    )  * vec3(1.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Shapes: Rectangle\nfloat rectangle(vec2 start, vec2 end, vec2 coord) {\n    return smoothstep(start.x - 1., start.x + 1., coord.x)\n           * smoothstep(start.y - 1., start.y + 1., coord.y)\n           * (1. - smoothstep(end.x - 1., end.x + 1., coord.x))\n           * (1. - smoothstep(end.y - 1., end.y + 1., coord.y))\n        ;\n}\n\n#if TUTORIAL == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(1, 0.3, 0.3);\n    col += rectangle(vec2(100., 200.), vec2(200., 340.), fragCoord) * vec3(.0, .0, 1.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n\n#if TUTORIAL == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(1, 0.3, 0.3);\n    float rect = rectangle(vec2(100., 200.), vec2(200., 340.), fragCoord);\n    col *= (1. - rect) * vec3(1.);\n    col += rect * vec3(.0, .0, 1.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Shapes: Circle\nfloat circle(float radius, vec2 center, vec2 coord) {\n    float distance2 = dot(center - coord, center - coord);\n    float radius2 = radius * radius;\n    return smoothstep(distance2, distance2*1.01, radius2);\n}\n\n#if TUTORIAL == 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.3, 0.3, 1);\n    \n    vec2 circle1_center = iResolution.xy / 2. + vec2(100.);\n    float circle1 = circle(50., circle1_center, fragCoord);\n    col *= (1. - circle1) * vec3(1.);\n    col += circle1 * vec3(1., .3, 0.);\n    \n    float rect = rectangle(vec2(0.), vec2(iResolution.x, 130.), fragCoord);\n    col *= (1. - rect) * vec3(1.);\n    col += rect * vec3(.6, 1., .3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Transformation: Rotation\nmat2 rotate(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n#if TUTORIAL == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.3, 0.3, 1);\n    \n    vec2 circle1_center = iResolution.xy / 2. + vec2(100.);\n    circle1_center = rotate(iTime) * circle1_center;\n    float circle1 = circle(50., circle1_center, fragCoord);\n    col *= (1. - circle1) * vec3(1.);\n    col += circle1 * vec3(1., .3, 0.);\n    \n    float rect = rectangle(vec2(0.), vec2(iResolution.x, 130.), fragCoord);\n    col *= (1. - rect) * vec3(1.);\n    col += rect * vec3(.6, 1., .3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Rotation against arbitrary point\nvec2 rotate_against(vec2 center, vec2 pt, float angle){\n    pt -= center;\n    pt = rotate(angle) * pt;\n    pt += center;\n    return pt;\n}\n\n#if TUTORIAL == 11\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.3, 0.3, 1);\n    \n    vec2 circle1_center = iResolution.xy / 2. + vec2(0., 150.);\n    circle1_center = rotate_against(vec2(iResolution.x / 2., 130.), circle1_center, iTime);\n    float circle1 = circle(50., circle1_center, fragCoord);\n    col *= (1. - circle1) * vec3(1.);\n    col += circle1 * vec3(1., .3, 0.);\n    \n    float rect = rectangle(vec2(0.), vec2(iResolution.x, 130.), fragCoord);\n    col *= (1. - rect) * vec3(1.);\n    col += rect * vec3(.6, 1., .3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\nfloat sun(float radius, vec2 center, vec2 coord) {\n    float distance2 = dot(center - coord, center - coord);\n    float radius2 = radius * radius;\n    return smoothstep(distance2, distance2*2., radius2);\n}\n\n#if TUTORIAL == 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec3 skycolor = vec3(0.3, 0.3, 1)  * max(cos(iTime), 0.);\n    vec3 dawncolor = vec3(0.8, 0.3, 0.3) * abs(pow(sin(iTime), 3.));\n    vec3 nightcol = texture(iChannel0, uv).rgb * max(0., pow(1. - cos(iTime), 2.)) / 10.;\n    vec3 col = skycolor + dawncolor + nightcol;\n    \n    \n    vec2 circle1_center = iResolution.xy / 2. + vec2(0., 150.);\n    circle1_center = rotate_against(vec2(iResolution.x / 2., 130.), circle1_center, iTime);\n    float circle1 = sun(30., circle1_center, fragCoord);\n    circle1 *= abs(pow(sin(iTime), 3.));\n    col *= (1. - circle1) * vec3(1.);\n    col += circle1 * vec3(1., .3, 0.);\n    float circle2 = sun(32., circle1_center, fragCoord);\n    col += circle2 * vec3(1., 1., 1.);\n    \n    float rect = rectangle(vec2(0.), vec2(iResolution.x, 130.), fragCoord);\n    col *= (1. - rect) * vec3(1.);\n    col += rect * vec3(.6, 1., .3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n#if TUTORIAL == 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n","name":"Image","description":"","type":"image"}]}