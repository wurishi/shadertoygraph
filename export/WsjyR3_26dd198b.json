{"ver":"0.1","info":{"id":"WsjyR3","date":"1587093353","viewed":149,"name":"Ray Marching - Cornell Box","username":"lukedan","description":"Cornell box with AO, soft shadows, DOF, and GI. Ceiling removed due to artifacts in soft shadows. The depth of field algorithm is more expensive but also more accurate. Use the mouse to control focal distance (y) and lens radius (x).","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float cocRadius(float depth, float focalPlane, float lensRadius) {\n\treturn abs((depth / focalPlane - 1.0f) * lensRadius);\n}\n\nconst int dofSamples = 80;\nconst float\n    dofAngle = 1.0f, dofSampleRadius = 10.0f,\n    dofRadiusThreshold = 0.5f, dofDepthThreshold = 2.0f, dofDepthCOCThreshold = 5.0f;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec4 rgbd = texture(iChannel0, uv);\n\n\tfloat focalPlane = 15.0f * iMouse.y / iResolution.y + 25.0f;\n\tfloat lensRadius = 80.0f * iMouse.x / iResolution.x;\n\n    float coc = cocRadius(rgbd.w, focalPlane, lensRadius);\n    \n\tvec2 rot = vec2(cos(dofAngle), sin(dofAngle)), cur = vec2(1.0f, 0.0f);\n\tfloat lenDiff = dofSampleRadius / float(dofSamples - 1), len = 0.0f;\n\n\tvec3 sumColor = vec3(0.0f, 0.0f, 0.0f);\n\tfloat sumWeight = 0.0f;\n\n\tfor (int i = 0; i < dofSamples; ++i) {\n\t\tvec2 offset = cur * len / iResolution.xy;\n\t\tvec4 rgbdSample = texture(iChannel0, uv + offset);\n        rgbdSample.xyz += texture(iChannel1, uv + offset).xyz;\n        \n\t\tfloat cocSample = cocRadius(rgbdSample.w, focalPlane, lensRadius);\n\t\tfloat valid = step(0.0f, cocSample - len + dofRadiusThreshold);\n        float depthLimit = step(dofDepthThreshold, rgbdSample.w - rgbd.w);\n        depthLimit *= 1.0f - smoothstep(0.0f, dofDepthCOCThreshold, coc);\n        valid *= 1.0f - depthLimit;\n\n\t\tsumColor += valid * rgbdSample.xyz;\n\t\tsumWeight += valid;\n\n\t\t// update\n\t\tlen += lenDiff;\n\t\tcur = vec2(cur.x * rot.x - cur.y * rot.y, cur.x * rot.y + cur.y * rot.x);\n\t}\n\n\tfragColor = vec4(sumColor / sumWeight, 1.0f);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float sdfSphere(vec3 pt, vec3 c, float r) {\n\treturn length(pt - c) - r;\n}\nfloat sdfPlane(vec3 pt, vec3 plane, vec3 n) {\n\treturn dot(pt - plane, n);\n}\nfloat sdfBox(vec3 pt, vec3 center, vec3 extents, mat3 rot) {\n\tpt = abs(rot * (pt - center));\n\tif (pt.x < extents.x && pt.y < extents.y && pt.z < extents.z) {\n\t\tvec3 innerDist3 = pt - extents;\n\t\treturn max(max(innerDist3.x, innerDist3.y), innerDist3.z);\n\t} else {\n\t\tvec3 outerDist3 = pt - min(pt, extents);\n\t\treturn length(outerDist3);\n\t}\n}\n\n\nstruct Ray {\n\tvec3 pos, dir;\n};\n\nstruct Camera {\n\tvec3\n\t\tposition,\n\t\t// normal vectors\n\t\tup, right,\n\t\t// used to compute rays, -1 for left/top border and 1 for right/bottom\n\t\thorizontal, vertical,\n\t\t// everything below are needed by initializeCamera(), including fovY and stuff\n\t\tfront, refUp;\n\tfloat fovY, aspectXOverY;\n};\n\nvoid initializeCamera(inout Camera cam) {\n\tcam.front = normalize(cam.front);\n\n\tcam.right = normalize(cross(cam.front, cam.refUp));\n\tcam.up = cross(cam.right, cam.front);\n\n\tfloat vertLen = tan(0.5f * cam.fovY);\n\tcam.vertical = cam.up * vertLen;\n\tcam.horizontal = cam.right * vertLen * cam.aspectXOverY;\n}\n\n// screenPos in [0, 1]^2\nRay getCameraRay(Camera cam, vec2 screenPos) {\n\tscreenPos = screenPos * 2.0f - 1.0f;\n\tRay result;\n\tresult.pos = cam.position;\n\tresult.dir = cam.front + cam.horizontal * screenPos.x + cam.vertical * screenPos.y;\n\treturn result;\n}\n\n\nstruct Intersection {\n\tint object;\n\tfloat t;\n};\n\nbool updateIntersection(inout Intersection isect, float t, int obj) {\n\tif (t < isect.t) {\n\t\tisect.t = t;\n\t\tisect.object = obj;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\n#define SUBSURFACE 0\n\nconst int\n\tcornellBoxFloor = 0,\n\tcornellBoxRedWall = 1,\n\tcornellBoxGreenWall = 2,\n\tcornellBoxBackWall = 3,\n\tcornellBoxCeilingWall = 4,\n\tcornellBoxLongCube = 5,\n\tcornellBoxShortCube = 6;\nconst mat3\n\tcornellBoxLongCubeRot = mat3(\n\t\t0.89f, 0.0f, 0.46f,\n\t\t0.0f, 1.0f, 0.0f,\n\t\t-0.46f, 0.0f, 0.89f\n\t),\n\tcornellBoxShortCubeRot = mat3(\n\t\t0.95f, 0.0f, -0.30f,\n\t\t0.0f, 1.0f, 0.0f,\n\t\t0.30f, 0.0f, 0.95f\n\t);\n\nIntersection cornellBoxScene(vec3 pt) {\n\tIntersection result;\n\n\t// objects near the light cause strips to appear for soft shadows\n\tresult.t = sdfPlane(pt, vec3(0.0f, -2.5f, 0.0f), vec3(0.0f, 1.0f, 0.0f));\n\tresult.object = cornellBoxFloor;\n\tupdateIntersection(result, sdfPlane(pt, vec3(5.0f, 2.5f, 0.0f), vec3(-1.0f, 0.0f, 0.0f)), cornellBoxRedWall);\n\tupdateIntersection(result, sdfPlane(pt, vec3(-5.0f, 2.5f, 0.0f), vec3(1.0f, 0.0f, 0.0f)), cornellBoxGreenWall);\n#if SUBSURFACE\n\tupdateIntersection(result, sdfPlane(pt, vec3(0.0f, 7.5f, 0.0f), vec3(0.0f, -1.0f, 0.0f)), cornellBoxCeilingWall);\n#else\n\tupdateIntersection(result, sdfPlane(pt, vec3(0.0f, 2.5f, 5.0f), vec3(0.0f, 0.0f, -1.0f)), cornellBoxBackWall);\n#endif\n\tupdateIntersection(\n\t\tresult, sdfBox(pt, vec3(2.0f, 0.0f, 3.0f), vec3(1.5f, 3.0f, 1.5f), cornellBoxLongCubeRot),\n\t\tcornellBoxLongCube\n\t);\n\tupdateIntersection(\n\t\tresult, sdfBox(pt, vec3(-2.0f, -1.0f, 0.75f), vec3(1.5f, 1.5f, 1.5f), cornellBoxShortCubeRot),\n\t\tcornellBoxShortCube\n\t);\n\n\treturn result;\n}\n\n\nconst int maxRayMarchingSteps = 100;\nconst float rayMarchingEps = 0.01f;\n\nIntersection rayMarch(Ray ray) {\n\tfloat totalT = 0.0f;\n\tfor (int i = 0; i < maxRayMarchingSteps; ++i) {\n\t\tIntersection isect = cornellBoxScene(ray.pos);\n\t\tif (isect.t < rayMarchingEps) {\n\t\t\tisect.t += totalT;\n\t\t\treturn isect;\n\t\t}\n\t\ttotalT += isect.t;\n\t\tray.pos += ray.dir * isect.t;\n\t}\n\tIntersection result;\n\tresult.object = -1;\n\treturn result;\n}\n\nconst float normalDelta = 0.01f;\n\nvec3 normal(vec3 pt) {\n\treturn normalize(vec3(\n\t\tcornellBoxScene(vec3(pt.x + normalDelta, pt.y, pt.z)).t -\n\t\tcornellBoxScene(vec3(pt.x - normalDelta, pt.y, pt.z)).t,\n\t\tcornellBoxScene(vec3(pt.x, pt.y + normalDelta, pt.z)).t -\n\t\tcornellBoxScene(vec3(pt.x, pt.y - normalDelta, pt.z)).t,\n\t\tcornellBoxScene(vec3(pt.x, pt.y, pt.z + normalDelta)).t -\n\t\tcornellBoxScene(vec3(pt.x, pt.y, pt.z - normalDelta)).t\n\t));\n}\n\n\nconst int numAOSamples = 5;\nconst float deltaAO = 0.4f;\n\nfloat ambientOcculusion(vec3 pt, vec3 n) {\n\tn *= deltaAO;\n\tfloat mul = 1.0f, tot = 0.0f;\n\tfor (int i = 0; i < numAOSamples; ++i) {\n\t\tpt += n;\n\t\ttot += mul * (float(i) * deltaAO - cornellBoxScene(pt).t);\n\t\tmul *= 0.5f;\n\t}\n\treturn tot;\n}\n\n\nfloat subsurface(\n\tvec3 light, vec3 normal, vec3 view, float thin,\n\tfloat distortion, float glow, float scale\n) {\n\tvec3 scatterDir = light + normal * distortion;\n\tfloat lightReachingEye = pow(clamp(dot(view, -scatterDir), 0.0f, 1.0f), glow) * scale;\n\tfloat attenuation = 1.0f;\n\t/*attenuation = max(0.0f, dot(normal, light) + dot(view, -light));*/\n\treturn lightReachingEye;\n\treturn attenuation * lightReachingEye * thin;\n}\n\nvec3 materialColor(int object) {\n\tswitch (object) {\n\tcase cornellBoxFloor:\n\tcase cornellBoxCeilingWall:\n\tcase cornellBoxBackWall:\n\tcase cornellBoxLongCube:\n\tcase cornellBoxShortCube:\n\t\treturn vec3(0.85f, 0.81f, 0.78f);\n\tcase cornellBoxRedWall:\n\t\treturn vec3(0.63f, 0.065f, 0.05f);\n\tcase cornellBoxGreenWall:\n\t\treturn vec3(0.14f, 0.45f, 0.091f);\n\t\tbreak;\n\t}\n\treturn vec3(0.0f);\n}\nvec3 material(vec3 pt, vec3 norm, vec3 cam, vec3 light, vec3 lightColor, int object, out float subsurfaceScatter) {\n\tsubsurfaceScatter = 0.0f;\n\tvec3 diff = light - pt;\n\tvec3 color = materialColor(object);\n\tswitch (object) {\n\tcase cornellBoxLongCube:\n\tcase cornellBoxShortCube:\n\t\t{\n#if SUBSURFACE\n\t\t\tfloat thickness = ambientOcculusion(pt, -norm);\n\t\t\tsubsurfaceScatter = subsurface(\n\t\t\t\tnormalize(light - pt), norm, normalize(cam - pt), thickness, 0.2f, 10.0f, 0.1f\n\t\t\t);\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color * lightColor * (dot(normalize(diff), norm) / dot(diff, diff));\n}\n\n#if SUBSURFACE\nconst vec3 lightPos = vec3(2.0f, 1.0f, 11.0f);\n#else\nconst vec3 lightPos = vec3(0.0f, 7.45f, 0.0f);\n#endif\nconst vec3 lightColor = vec3(17.0f, 12.0f, 4.0f) * 4.0f;\n\n\nconst int maximumShadowSteps = 100;\nconst float\n\tsoftShadowThreshold = 0.0001f,\n\tsoftShadowMinValue = 0.1f,\n\tsoftShadowMaxValue = 0.99f;\n\nfloat softShadow(vec3 p, vec3 light, float k) {\n\tvec3 diff = light - p;\n\tfloat dist = length(diff);\n\tdiff /= dist;\n\tfloat maxVal = softShadowMaxValue * dist, res = 1.0f, t = softShadowMinValue;\n\tfor (int i = 0; i < maximumShadowSteps && t < maxVal; ++i) {\n\t\tfloat sdf = cornellBoxScene(p + diff * t).t;\n\t\tif (sdf < softShadowThreshold) {\n\t\t\treturn 0.0f;\n\t\t}\n\t\tres = min(res, sdf * k / t);\n\t\tt += sdf;\n\t}\n\treturn res;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tCamera camera;\n\tcamera.position = vec3(0.0f, 5.5f, -30.0f);\n\tcamera.front = vec3(0.0f, 2.5f, 0.0f) - camera.position;\n\tcamera.refUp = vec3(0.0f, 1.0f, 0.0f);\n\tcamera.fovY = 19.5f * (3.14159f / 180.0f);\n\tcamera.aspectXOverY = iResolution.x / iResolution.y;\n\tinitializeCamera(camera);\n\n\tRay ray = getCameraRay(camera, fragCoord / iResolution.xy);\n\tIntersection isect = rayMarch(ray);\n\n\tvec3 point = ray.pos + isect.t * ray.dir;\n\tvec3 norm = normal(point);\n\tfloat subsurfaceScatter;\n\tvec3 color = material(\n\t\tpoint, norm, camera.position, lightPos, lightColor, isect.object, subsurfaceScatter\n\t);\n\tcolor *= 1.0f - ambientOcculusion(point, norm);\n\tcolor *= softShadow(point, lightPos, 7.0f);\n\tcolor += subsurfaceScatter * lightColor;\n\tfragColor = vec4(color, isect.t);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 sampleHemisphereCosine(vec3 normal, vec2 unitRandom) {\n\tvec3 x = normalize(cross(normal, vec3(1.0f, 2.0f, 3.0f)));\n\tvec3 y = cross(normal, x);\n\tfloat xv = cos(unitRandom.x * 3.1416f), yv = sin(unitRandom.x * 3.1416f), r = unitRandom.y;\n\treturn r * (x * xv + y * yv) + normal * sqrt(1.0f - r * r);\n}\n\nvec2 rand32(vec3 from, vec3 seed1, vec3 seed2, float seed3) {\n\treturn fract(sin(vec2(dot(from, seed1), dot(from, seed2))) * seed3);\n}\n\nconst int numSamples = 3;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tCamera camera;\n\tcamera.position = vec3(0.0f, 5.5f, -30.0f);\n\tcamera.front = vec3(0.0f, 2.5f, 0.0f) - camera.position;\n\tcamera.refUp = vec3(0.0f, 1.0f, 0.0f);\n\tcamera.fovY = 19.5f * (3.14159f / 180.0f);\n\tcamera.aspectXOverY = iResolution.x / iResolution.y;\n\tinitializeCamera(camera);\n\n\tRay ray = getCameraRay(camera, fragCoord / iResolution.xy);\n\tIntersection isect = rayMarch(ray);\n\n\tvec3 point = ray.pos + isect.t * ray.dir;\n\tvec3 norm = normal(point);\n\n\tray.pos = point + norm * 0.1f;\n\tvec3 total = vec3(0.0f);\n\tvec3 color = materialColor(isect.object);\n\tfor (int i = 0; i < numSamples; ++i) {\n\t\tray.dir = sampleHemisphereCosine(\n\t\t\tnorm,\n\t\t\trand32(\n\t\t\t\tvec3(fragCoord, i + 1),\n\t\t\t\tvec3(72.039f, 84.023f, 43.570f),\n\t\t\t\tvec3(52.345f, 36.458f, 98.527f),\n\t\t\t\t38974.827f\n\t\t\t)\n\t\t);\n\t\tIntersection indirect = rayMarch(ray);\n\t\tvec3 indirectPoint = ray.pos + indirect.t * ray.dir;\n\t\tvec3 indirectNorm = normal(indirectPoint);\n\n\t\tRay testRay;\n\t\ttestRay.pos = indirectPoint + indirectNorm * 0.1f;\n\t\ttestRay.dir = lightPos - testRay.pos;\n\t\tfloat len = length(testRay.dir);\n\t\ttestRay.dir /= len;\n\t\tIntersection testIsect = rayMarch(testRay);\n\n\t\tfloat sub;\n\t\tvec3 color = material(indirectPoint, indirectNorm, point, lightPos, lightColor, indirect.object, sub);\n\t\ttotal += step(len, testIsect.t) * color;\n\t}\n\tfragColor = vec4(total * color / float(numSamples), numSamples);\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tivec2 pixel = ivec2(fragCoord);\n\tfragColor = vec4(0.0f);\n\tfragColor += 0.038735 * texelFetch(iChannel0, ivec2(pixel.x - 3, pixel.y), 0);\n\tfragColor += 0.113085 * texelFetch(iChannel0, ivec2(pixel.x - 2, pixel.y), 0);\n\tfragColor += 0.215007 * texelFetch(iChannel0, ivec2(pixel.x - 1, pixel.y), 0);\n\tfragColor += 0.266346 * texelFetch(iChannel0, ivec2(pixel.x, pixel.y), 0);\n\tfragColor += 0.215007 * texelFetch(iChannel0, ivec2(pixel.x + 1, pixel.y), 0);\n\tfragColor += 0.113085 * texelFetch(iChannel0, ivec2(pixel.x + 2, pixel.y), 0);\n\tfragColor += 0.038735 * texelFetch(iChannel0, ivec2(pixel.x + 3, pixel.y), 0);\n}\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tivec2 pixel = ivec2(fragCoord);\n\tfragColor = vec4(0.0f);\n\tfragColor += 0.038735 * texelFetch(iChannel0, ivec2(pixel.x, pixel.y - 3), 0);\n\tfragColor += 0.113085 * texelFetch(iChannel0, ivec2(pixel.x, pixel.y - 2), 0);\n\tfragColor += 0.215007 * texelFetch(iChannel0, ivec2(pixel.x, pixel.y - 1), 0);\n\tfragColor += 0.266346 * texelFetch(iChannel0, ivec2(pixel.x, pixel.y), 0);\n\tfragColor += 0.215007 * texelFetch(iChannel0, ivec2(pixel.x, pixel.y + 1), 0);\n\tfragColor += 0.113085 * texelFetch(iChannel0, ivec2(pixel.x, pixel.y + 2), 0);\n\tfragColor += 0.038735 * texelFetch(iChannel0, ivec2(pixel.x, pixel.y + 3), 0);\n}\n","name":"Buf D","description":"","type":"buffer"}]}