{"ver":"0.1","info":{"id":"MsdSWM","date":"1459774273","viewed":473,"name":"Whitepoint","username":"koalefant","description":"Playing with distance fields and ambient occlusion.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","ao","ambientocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sd_sphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nvec3 op_rep(vec3 p, vec3 c){\n\treturn vec3(mod(p.x, c.x),\n\t\t\t\tmod(p.y, c.y),\n\t\t\t\tmod(p.z, c.z)) - 0.5 * c;\n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k ) {\n\tfloat res = exp( -k*a ) + exp( -k*b );\n\treturn -log( res )/k;\n}\n\nfloat displacement(vec3 p, float radius) {\n\tvec3 v = sin(p / 3.1415926 / radius);\n\treturn v.x*v.y*v.z;\n}\n\nfloat sd_floor(vec3 p) {\n\tfloat floor_r = 0.25;\n\tfloat pi = 3.1415926;\n\tfloat xoffset = cos(pi / 6.0) * floor_r*2.0;\n\tfloat floor_a = sd_sphere(op_rep(p, vec3(xoffset*2.0,0.0,xoffset)), floor_r*2.0);\n\tfloat floor_b = sd_sphere(op_rep(p+vec3(xoffset,0.0,xoffset/2.0), vec3(xoffset*2.0,0.0,xoffset)), floor_r*2.0);\n\treturn min(floor_a, floor_b);\n}\n\nfloat sd_box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sd_capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sd_torus_xz( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sd_torus_yz( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\nfloat level_distance(vec3 p) {\n\tfloat t = iTime;\n\tfloat floor_dist = sd_floor(op_rep(p + vec3(0,-1,0), vec3(0,4.6,0)));\n\tfloor_dist += cos(t*0.5)*0.2*cos(p.x)*cos(p.z);\n\n\tvec3 p_rep = op_rep(p+vec3(3,-1,3), vec3(5,0,5.95));\n\tfloat dome_osc = cos(t*2.0)*0.01;\n\tfloat dome = -sd_sphere(p_rep, 3.0) + dome_osc;\n\tdome = min(dome,\n\t\tsd_torus_yz(op_rep(p+vec3(0.5,-1,0), vec3(5,0,0)),\n\t\t\t\t\tvec2(1.6+dome_osc*3.0, 0.1)));\n\n\tfloat r = min(floor_dist, dome);\n\tr = min(r, sd_box(p, vec3(0.5,1,0.5)));\n\tr = min(r, sd_box(p+vec3(0,-0.5,0), vec3(0.25,1,0.25)));\n\n\tr = min(r, sd_capsule(p, vec3(-0.5,0,0.25), vec3(-0.5,1,-0.25), 0.2));\n\n\tr = min(r, sd_torus_xz(p+vec3(0,cos(t)*0.4-0.2,0), vec2(0.8, 0.1)));\n\tr = min(r, sd_torus_xz(p+vec3(0,sin(t*0.1)*0.2-0.2,0), vec2(1.0, 0.1)));\n\treturn r;\n}\n\nfloat total_distance(vec3 p) {\n\treturn level_distance(p);\n}\n\n// Based on \"GPU Ray Marching of Distance Fields\"\n// 2012 Lukasz Jaroslaw Tomczak\n// \n// modified to redistributed more samples closer to the surface\nfloat ambient_occlusion(vec3 p, vec3 n, int reflection) {\n\tconst int steps = 5;\n\tfloat sample_distance = 0.7;\n\tfloat occlusion = 0.0;\n\tfor (int i = 1; i <= steps; i++) {\n\t\tfloat k = float(i) / float(steps);\n\t\tk *= k;\n\t\tfloat current_radius = sample_distance * k;\n\t\tfloat distance_in_radius = total_distance(p + current_radius * n);\n\t\tocclusion += pow(0.5, k * float(steps)) * (current_radius - distance_in_radius);\n\t}\n\tfloat scale = 0.4;\n\treturn 1.0 - clamp(scale * occlusion, 0.0, 1.0 );\n}\n\nvec3 normal(vec3 p) {\n\tfloat e = 0.0001;\n\tfloat f0 = total_distance(p);\n\tfloat fx = total_distance(vec3(p.x + e,p.y,p.z));\n\tfloat fy = total_distance(vec3(p.x,p.y + e,p.z));\n\tfloat fz = total_distance(vec3(p.x,p.y,p.z + e));\n\treturn normalize(vec3(fx-f0,fy-f0,fz-f0));\n}\n\nvec4 raymarch(vec3 origin, vec3 dir) {\n\tfloat t = 0.0;\n\tconst int max_steps = 256;\n\tfloat epsilon = 0.00075;\n\tvec3 fog_color = vec3(1.0);\n\tvec4 color = vec4(fog_color,1);\n\tint num_reflections = 1;\n\tint reflections_left = num_reflections;\n\tfor(int i = 0; i < max_steps; ++i) {\n\t\tvec3 p = origin + dir * t;\n\t\tfloat d = total_distance(p);\n\t\tif(d < epsilon) {\n\t\t\tvec3 n = normal(p);\n\t\t\tvec3 sample_color = vec3(0.8);\n\t\t\t// distance fade\n\t\t\tsample_color = mix(sample_color, fog_color, vec3(clamp(1.0-exp(-length(p)/8.0), 0.0, fog_color.x))); // Sphere color\n\t\t\t// front light\n\t\t\t//color.xyz += 0.1 * vec3(1) * clamp(dot(-dir, n),0,1);\n\t\t\t// ambient occlusion\n\t\t\tsample_color *= ambient_occlusion(p, n, num_reflections - reflections_left);\n\n\t\t\tif (false) {\n\t\t\t\tfloat step_intensity = 1.0-(float(i))/float(max_steps);\n\t\t\t\tcolor.yz *= vec2(step_intensity);\n\t\t\t}\n            float f = 1.0;\n            if (num_reflections != reflections_left)\n            \tf = 0.075;\n\t\t\tcolor.xyz = mix(color.xyz, sample_color, f);\n            break;/*\n\t\t\tif (reflections_left == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// restart loop starting from new reflection point\n\t\t\t\treflections_left -= 1;\n\t\t\t\tepsilon *= 10.0;\n\t\t\t\torigin = p + n * epsilon * 2.0;\n\t\t\t\tdir = normalize(dir-2.0*n*dot(dir,n));\n\t\t\t\ti = 0;\n\t\t\t\tt = 0.0;\n\t\t\t\tmax_steps /= 4;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t}\n\t\tt += d * 1.0;\n\t}\n\treturn vec4(pow(color.xyz, vec3(2.2)), color.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n\tvec2 uv = coord.xy / iResolution.xy;\n    const float pi = 3.1415926;\n    \n    vec3 origin = vec3(cos(iTime * 0.1+pi*0.5)* 5.0-2.5, 2, cos(iTime*0.05)*0.2);\n    vec2 mouse = -2.0*(vec2(iMouse) / vec2(iResolution) - vec2(0.5));\n    if (iMouse.x == 0.0 && iMouse.y == 0.0)\n        mouse = vec2(0);\n    float ax = (uv.x-0.5+mouse.x)*pi*0.25 * 1.6;\n    float ay = (uv.y-0.5+mouse.y)*pi*0.25;\n    float cx = cos(ax);\n    float cy = cos(ay);\n    float sx = sin(ax);\n    float sy = sin(ay);\n    vec3 dir = normalize(vec3(cx, sy, sx*cy));\n    fragColor = raymarch(origin, dir);\n}","name":"Image","description":"","type":"image"}]}