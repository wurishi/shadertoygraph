{"ver":"0.1","info":{"id":"ftKSDW","date":"1640706404","viewed":135,"name":"Simple Snake Game","username":"jolle","description":"Simple snake game made during live coding stream\n\nControls WASD","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["game","interactive","snake","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nint[] numbers = int[](\n    0, 1, 0,\n    1, 0, 1,\n    1, 0, 1,\n    1, 0, 1,\n    0, 1, 0,\n\n    0, 1, 0,\n    0, 1, 0,\n    0, 1, 0,\n    0, 1, 0,\n    0, 1, 0,\n\n    0, 1, 0,\n    1, 0, 1,\n    0, 0, 1,\n    0, 1, 0,\n    1, 1, 1,\n\n    1, 1, 0,\n    0, 0, 1,\n    0, 1, 0,\n    0, 0, 1,\n    1, 1, 0,\n\n    1, 0, 1,\n    1, 0, 1,\n    1, 1, 1,\n    0, 0, 1,\n    0, 0, 1,\n\n    1, 1, 1,\n    1, 0, 0,\n    1, 1, 0,\n    0, 0, 1,\n    1, 1, 0,\n\n    0, 1, 1,\n    1, 0, 0,\n    1, 1, 0,\n    1, 0, 1,\n    0, 1, 0,\n\n    1, 1, 1,\n    0, 0, 1,\n    0, 1, 0,\n    0, 1, 0,\n    0, 1, 0,\n\n    0, 1, 0,\n    1, 0, 1,\n    0, 1, 0,\n    1, 0, 1,\n    0, 1, 0,\n\n    0, 1, 0,\n    1, 0, 1,\n    0, 1, 1,\n    0, 0, 1,\n    1, 1, 0);\n\nbool outputNum(int val, vec2 pos)\n{\n    if (pos.x < 0.0 || pos.y < 0.0 || pos.x >= 1.0 || pos.y >= 1.0)\n        return false;\n    int base = val * 3 * 5;\n    int x = 2 - int(pos.x * 3.0);\n    int y = int(pos.y * 5.0);\n    int addr = base + x + y * 3;\n    return numbers[addr] > 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = \n       texture(iChannel2, fragCoord.xy / iResolution.xy) +\n       texture(iChannel3, fragCoord.xy / iResolution.xy);\n   int score = int(read(SCORE).x);\n   vec2 area = iResolution.xy * 0.1 * vec2(iResolution.y / iResolution.x, 1.0);\n   if (outputNum(score % 10, (iResolution.xy - fragCoord.xy) / area) || \n       outputNum(score / 10, (iResolution.xy - fragCoord.xy - vec2(area.x * 1.33, 0)) / area))\n       fragColor = vec4(1.0, vec3(0.0));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const ivec2 POSITION = ivec2(0, 0);\nconst ivec2 DIRECTION = ivec2(1, 0);\nconst ivec2 TARGET = ivec2(2, 0);\nconst ivec2 SCORE = ivec2(3, 0);\nconst ivec2 TIMER = ivec2(4, 0);\nconst ivec2 TICK = ivec2(5, 0);\nconst ivec2 RESET = ivec2(6, 0);\nconst ivec2 SHAKE = ivec2(7, 0);\n\nconst ivec2 Resolution = ivec2(30, 20);\n\n#define read(varpos) texelFetch(iChannel0, varpos, 0)\n\n#define write(varpos, value) \\\n    if (varpos == ivec2(fragCoord)) \\\n        fragColor = value\n\nfloat snekLength(float score)\n{\n    return 12.0 + score * 4.0;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Variables buffers / most of logic\n\nuint hash(uint x)\n{\n    x = ((x >> 16u) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x) * 0x45d9f3bu;\n    x = (x >> 16u) ^ x;\n    return x;\n}\n\nfloat floatFromHash(uint h)\n{\n    return uintBitsToFloat(h & 0x007FFFFFu | 0x3F800000u) - 1.0;\n}\n\nvec4 randomPosition(uint seed)\n{\n    return vec4(\n        floor(floatFromHash(hash(floatBitsToUint(iTime)) ^ hash(seed)) * float(Resolution.x)),\n        floor(floatFromHash(hash(floatBitsToUint(iTime + 89013.8972)) ^ hash(seed)) * float(Resolution.y)),\n        0, 0);\n}\n\nvec4 randomTarget()\n{\n    for (uint i = 0u; i < 8u; ++i)\n    {\n        vec4 pos = randomPosition(i);\n        if (texelFetch(iChannel1, ivec2(pos), 0).x == 0.0)\n            return pos;\n    }\n    return randomPosition(9u);\n}\n\nvec4 tickDelay(vec4 score)\n{\n    return vec4(0.2 - 0.02 * (10.0 + score) / 10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Default values\n    vec4 position = vec4(Resolution.x / 2, Resolution.y / 2, vec2(0.0));\n    vec4 direction = vec4(1, vec3(0.0));\n    vec4 target = randomTarget();\n    vec4 score = vec4(0);\n    vec4 timer = tickDelay(score);\n    vec4 reset = read(RESET);\n    vec4 shake = vec4(0);\n\n    // Read stored variables\n    if (iFrame != 0 && reset.x == 0.0)\n    {\n        position = read(POSITION);\n        direction = read(DIRECTION);\n        target = read(TARGET);\n        score = read(SCORE);\n        timer = read(TIMER);\n        shake = read(SHAKE);\n    }\n    else\n    {\n        reset = vec4(0.0);\n    }\n\n    // Steering\n    // TODO: Queue\n    if (direction.x != 1.0 && texelFetch(iChannel2, ivec2(65, 0), 0).x > 0.0) // a\n        direction = vec4(-1.0, 0.0, 0.0, 0.0);\n    if (direction.x != -1.0 && texelFetch(iChannel2, ivec2(68, 0), 0).x > 0.0) // d\n        direction = vec4(1.0, 0.0, 0.0, 0.0);\n    if (direction.y != 1.0 && texelFetch(iChannel2, ivec2(83, 0), 0).x > 0.0) // s\n        direction = vec4(0.0, -1.0, 0.0, 0.0);\n    if (direction.y != -1.0 && texelFetch(iChannel2, ivec2(87, 0), 0).x > 0.0) // w\n        direction = vec4(0.0, 1.0, 0.0, 0.0);\n\n    // Do logic\n    bool tick = false;\n    shake.x = max(0.0, shake.x - iTimeDelta);\n    timer -= iTimeDelta;\n    if (timer.x <= 0.0)\n    {\n        tick = true;\n        position += direction;\n\n        // Self collision\n        if (texelFetch(iChannel1, ivec2(position), 0).x > 0.0 ||\n            position.x < 0.0 || position.y < 0.0 ||\n            position.x >= float(Resolution.x) || position.y >= float(Resolution.y))\n            reset = vec4(1.0);\n\n        // Thing collision\n        if (position.xy == target.xy)\n        {\n            score += 1.0;\n            target = randomTarget();\n            shake = vec4(1.0);\n        }\n\n        timer = tickDelay(score);\n    }\n\n    // Write back variables\n    fragColor = vec4(0.0);\n    write(POSITION, position);\n    write(DIRECTION, direction);\n    write(TARGET, target);\n    write(SCORE, score);\n    write(TIMER, timer);\n    write(TICK, tick ? vec4(1.0) : vec4(0.0));\n    write(RESET, reset);\n    write(SHAKE, shake);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// SNEK BUFFER\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\n    vec4 reset = read(RESET);\n    if (iFrame == 0 || reset.x > 0.0) return;\n\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    vec4 tick = read(TICK);\n    if (tick.x <= 0.0) return;\n\n    vec4 position = read(POSITION);\n    vec4 score = read(SCORE);\n\n    if (position.xy == floor(fragCoord.xy))\n        fragColor = vec4(1.0);\n    else\n    {\n        vec4 val = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        if (val.x > snekLength(score.x)) \n            fragColor = vec4(0.0);\n        else if (val.x != 0.0)\n        {\n            val.x += 1.0;\n            fragColor = vec4(val.x);\n        }\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 target = read(TARGET);\n\n    // Output to screen\n    float shake = 0.0001 * pow(read(SHAKE).x, 4.0);\n    // TODO: This doesn't really manage all aspects etc well\n    float aspect1 = iResolution.x / iResolution.y;\n    float aspect2 = float(Resolution.x) / float(Resolution.y);\n    vec2 scale = vec2(Resolution) / iResolution.xy * vec2(aspect1 / aspect2, 1.0);\n    vec2 fpos = fragCoord / iResolution.xy;\n    if (target.xy == floor(fragCoord * scale))    \n        fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n    else if (float(Resolution.x) < fragCoord.x * scale.x ||\n             float(Resolution.y) < fragCoord.y * scale.y)\n        fragColor = vec4(0.25);\n    else\n        fragColor = min(vec4(1.0), texture(iChannel1, fragCoord / iResolution.xy * scale +\n            shake * vec2(cos(iTime * 1920838.0), cos(iTime * 41231234.0))));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    for (int y = 0; y < 5; ++y)\n        for (int x = 0; x < 5; ++x)\n        {\n            fragColor += texelFetch(iChannel0, 2 * ivec2(x, y) + ivec2(fragCoord), 0);\n            fragColor += texelFetch(iChannel0, 2 * ivec2(-x, y) + ivec2(fragCoord), 0);\n            fragColor += texelFetch(iChannel0, 2 * ivec2(x, -y) + ivec2(fragCoord), 0);\n            fragColor += texelFetch(iChannel0, 2 * ivec2(-x, -y) + ivec2(fragCoord), 0);\n        }\n    fragColor /= 5.0 * 5.0 * 4.0;\n}","name":"Buffer D","description":"","type":"buffer"}]}