{"ver":"0.1","info":{"id":"ssGcWh","date":"1654751131","viewed":64,"name":"Raytracing Different Spheres","username":"saalty","description":"A little sideproject. Use your mouse to drag over the viewport to view the scene from different angles (and you can stop dragging to let it render). The code was made pretty quick and lazy so any improvements to it would be awesome.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 unit = vec2(1.0) / iResolution.xy;\n    // Applying some quick and fast blur\n    fragColor = (\n                texture(iChannel0, uv) + \n                texture(iChannel0, uv + unit * vec2(-1, 0)) + \n                texture(iChannel0, uv + unit * vec2(0, 1)) +\n                texture(iChannel0, uv + unit * vec2(1, 0)) +\n                texture(iChannel0, uv + unit * vec2(0, -1))\n                ) / 5.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPSILON 0.001\n#define AMBIENT 0.4\n#define IOR 2.0\n#define SAMPLECOUNT 16\n\nfloat rand(float co) { return fract(cos(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat random(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nmat4 rotationMatrix(vec3 axis, float angle) // Source: https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 tweakRay(vec3 v, float r, vec3 normal)\n{\n    vec3 updated = normalize(v + \n    \n    vec3(\n        (rand((v.x) * iTime) - 0.5) * r, \n        (rand((v.y) * iTime) - 0.5) * r, \n        (rand((v.z) * iTime) - 0.5) * r\n        )\n    );\n    return updated;\n}\nstruct Sphere\n{\n    vec3 pos;\n    float rad;\n    float scatter;\n    bool isLight;\n    bool isRefract;\n    vec3 col;\n};\nSphere spheres[] = Sphere[](\n    Sphere(\n        vec3(0.0, 40.0, 0.0),\n        16.0,\n        0.5,\n        true,\n        false,\n        vec3(80.0, 80.0, 80.0)\n    ),\n    Sphere(\n        vec3(0.0, 0.0, 0.0),\n        1.0,\n        0.5,\n        false,\n        true,\n        vec3(0.5, 0.0, 0.5)\n    ),\n    Sphere(\n        vec3(0.0, 0.0, 4.0),\n        1.0,\n        0.5,\n        false,\n        true,\n        vec3(0.0, 0.5, 0.0)\n    ),\n    Sphere(\n        vec3(0.0, 0.0, 8.0),\n        1.0,\n        0.5,\n        false,\n        false,\n        vec3(0.0, 0.0, 0.0)\n    ),\n    Sphere(\n        vec3(4.0, 0.0, 0.0),\n        1.0,\n        2.0,\n        false,\n        false,\n        vec3(0.0, 0.5, 0.5)\n    ),\n    Sphere(\n        vec3(8.0, 0.0, 0.0),\n        1.0,\n        0.5,\n        false,\n        false,\n        vec3(0.0, 0.5, 0.0)\n    ),\n    Sphere(\n        vec3(4.0, 0.0, 4.0),\n        1.0,\n        0.5,\n        false,\n        true,\n        vec3(50.0, 0.0, 0.0)\n    ),\n    Sphere(\n        vec3(8.0, 0.0, 8.0),\n        1.0,\n        0.5,\n        false,\n        true,\n        vec3(0.5, 0.5, 0.5)\n    ),\n    Sphere(\n        vec3(8.0, 0.0, 0.0),\n        1.0,\n        0.5,\n        false,\n        false,\n        vec3(0.0, 0.5, 0.0)\n    ),\n    Sphere(\n        vec3(8.0, 0.0, 0.0),\n        1.0,\n        0.5,\n        false,\n        false,\n        vec3(0.0, 0.5, 0.0)\n    ),\n    Sphere(\n        vec3(8.0, 0.0, 4.0),\n        1.0,\n        0.5,\n        false,\n        true,\n        vec3(0.5, 0.5, 0.2)\n    ),\n    Sphere(\n        vec3(4.0, 0.0, 8.0),\n        1.0,\n        0.5,\n        false,\n        false,\n        vec3(0.5, 1.0, 0.2)\n    )\n);\nfloat sphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) \n{\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\nfloat planeIntersect(vec3 r0, vec3 rd, vec3 p0, vec3 p1, vec3 p2)\n{\n    vec3 N = cross(p1-p0, p2-p0);\n    float X = dot(p0 - r0, N) / dot(rd, N);\n    return X;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 final = vec3(0.0);\n    mat4 camrotY = rotationMatrix(vec3(0, 1, 0), iMouse.x / iResolution.x * 6.282);\n    mat4 camrotX = rotationMatrix(vec3(1, 0, 0), iMouse.y / iResolution.y * 3.141);\n    for (int ri = 0;ri < SAMPLECOUNT;ri++)\n    {\n        vec3 ro = (camrotY * (camrotX * vec4(0.0, 0.0, 12.0, 0.0))).xyz + vec3(4.0, 0.0, 4.0);\n        vec3 rd = (camrotY * (-camrotX * vec4(normalize(vec3(uv / vec2(0.5, 1.0) - vec2(0.5 / 0.5, 0.5), 1.0)),0.0))).xyz;\n        vec3 rc = vec3(AMBIENT);\n        int steps = 0;\n        float eta = IOR;\n        bool keepgoing = true;\n        while (steps < 10 && keepgoing)\n        {\n            float mindist = 10000.0;\n            int mini = -1;\n            for (int i = 0;i < spheres.length();i++)\n            {\n                float dist = sphereIntersect(ro, rd, spheres[i].pos, spheres[i].rad);\n                if (dist < mindist && dist > 0.0)\n                {\n                    mindist = dist;\n                    mini = i;\n                    \n                }\n            }\n            vec3 oldRO = ro;\n            vec3 oldRD = rd;\n            if (mindist != 10000.0)\n            {\n                ro += rd * mindist;\n                \n                eta = 1.0 / eta;\n                rd = tweakRay(\n                    spheres[mini].isRefract ? refract(rd, normalize(ro - spheres[mini].pos), eta) \n                    : reflect(rd, normalize(ro - spheres[mini].pos)), spheres[mini].scatter, normalize(ro - spheres[mini].pos));\n                ro += rd * 0.001;\n                rc *= spheres[mini].col;\n                if (spheres[mini].isLight)\n                {\n                    break;\n                }\n            }\n            float dist = planeIntersect(ro, rd, vec3(0, -1, 0), vec3(0, -1, 1000), vec3(-10, -1, 0));\n            if (dist > 0.0)\n            {\n                ro = oldRO + rd * dist;\n                rd = tweakRay(reflect(oldRD, vec3(0, 1, 0)), 4.0, vec3(0, 1, 0));\n                ro += rd * 0.001;\n                continue;\n            }\n            steps++;\n        }\n        if (keepgoing) rc *= texture(iChannel1, rd).xyz;\n        final = final * 0.95 + rc * 0.05;\n    }\n    fragColor = vec4(iMouse.z > 0.0 ? clamp(final, 0.0, 1.0) : clamp(final * 0.002 + texture(iChannel0, uv).xyz * 0.998, 0.0, 1.0), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}