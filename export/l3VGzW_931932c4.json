{"ver":"0.1","info":{"id":"l3VGzW","date":"1717410164","viewed":249,"name":"power of pathtracer","username":"FoRenard","description":"pathtracer test hehe","likes":7,"published":1,"flags":32,"usePreview":1,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://kinakomoti321.hatenablog.com/entry/2023/11/05/201719\n// https://github.com/KhronosGroup/ToneMapping/blob/main/PBR_Neutral/pbrNeutral.glsl\nvec3 PBRNeutralToneMapping( vec3 color ) {\n  const float startCompression = 0.8 - 0.04;\n  const float desaturation = 0.15;\n\n  float x = min(color.r, min(color.g, color.b));\n  float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n  color -= offset;\n\n  float peak = max(color.r, max(color.g, color.b));\n  if (peak < startCompression) return color;\n\n  const float d = 1. - startCompression;\n  float newPeak = 1. - d * d / (peak + d - startCompression);\n  color *= newPeak / peak;\n\n  float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n  return mix(color, newPeak * vec3(1, 1, 1), g);\n}\n#define remap(x,a,b,c,d) ((((x)-(a))/((b)-(a)))*((d)-(c))+(c))\nbool inuv(vec2 uv)\n{\n    return all(greaterThanEqual(uv, vec2(0)))&&all(lessThan(uv, vec2(1)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fc=gl_FragCoord.xy,res = iResolution.xy,asp = res / min(res.x,res.y);\n    vec2 uv = fc / res,suv = (uv * 2. - 1.) * asp;\n    float hud=.0,crs=.0;\n    {\n        float d=128.,th=.1,pw=.2;\n        float x=uv.x*d,ix=floor(x),fx=fract(x),qx=(ix+.5)/d;\n        hud+=step(pcg3(vec3(ix,3,2)).x,mix(th,.0,pow(qx,pw)))*step(fx,dFdx(x));\n        float y=uv.y*d,iy=floor(y),fy=fract(y),qy=(iy+.5)/d;\n        hud+=step(pcg3(vec3(iy,5,4)).x,mix(th,.0,pow(qy,pw)))*step(fy,dFdy(y));\n        float dd=dot(suv,vec2(32));\n        hud+=step(pcg3(vec3(ix,.1,.9)).x,.01)*step(fract(dd),fwidth(dd));\n        crs+=step(.97,uv.y);\n        suv-=vec2(.58,-.13);\n        vec2 auv=abs(suv);\n        crs+=step(min(auv.x,auv.y),.004)*step(max(auv.x,auv.y),.05);\n        vec2 cuv=vec2(length(suv),atan(suv.y,suv.x)/TAU+.5)*vec2(32,4);\n        cuv.y+=floor(cuv.x)*1.2;\n        vec2 icuv=floor(cuv),fcuv=fract(cuv),qcuv=(icuv+.5)/vec2(32,4);\n        hud+=step(pcg3(vec3(icuv,1.523)).x,mix(.2,.05,sat(qcuv.x)))*smoothstep(fwidth(cuv.x)*2.,.0,abs(fcuv.x-.5));\n        vec2 muv=uv*asp*vec2(48.),imuv=floor(muv),fmuv=fract(muv);\n        fmuv=(fmuv-.5)/1.5+.5;\n        hud+=.5*float(imuv.y==6.||imuv.x==15.)*smoothstep(.50,.45,texture(iChannel1,vec2(int(pcg3(imuv.xyx).x*10.),12)/16.+fmuv/16.).a);\n        //hud+=float(imuv.y==3.||imuv.x==7.)*texture(iChannel1,vec2(int(pcg3(imuv.xyx).x*10.),12)/16.+fmuv/16.).r;\n    }\n    vec4 c=texelFetch(iChannel0,ivec2(fc),0);\n    c.rgb/=c.a;\n    c.rgb=PBRNeutralToneMapping(c.rgb*1.2);\n    float v=smoothstep(.9,.3,length(uv-.5));\n    c.rg=smoothstep(.0,1.,c.rg)*v;\n    c.rgb=mix(c.rgb,vec3(.9),sat(hud));\n    c.rgb=mix(c.rgb,vec3(0,0,1),crs);\n    fragColor=vec4(c.rgb,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DEPTH 10\n#define eps 1e-3\nuint seed = 0u;\nvec3 rnd3()\n{\n    seed = seed * 747796405u + 2891336453u;\n    return pcg3(vec3(gl_FragCoord.xy,seed));\n}\nvec2 rnd2()\n{\n    return rnd3().xy;\n}\nfloat rnd1()\n{\n    return rnd3().x;\n}\n\nvoid tangentSpaceBasis(vec3 normal,inout vec3 tangent,inout vec3 binormal)\n{\n    vec3 d = vec3(0,1,0);\n    if(abs(normal.y) > 0.99)\n        d = vec3(0,0,1);\n    tangent = normalize(cross(normal,d));\n    binormal = normalize(cross(tangent,normal));\n}\n\nvec3 worldToLocal(vec3 tangent,vec3 normal,vec3 binormal,vec3 world)\n{\n    return vec3(dot(world,tangent),dot(world,normal),dot(world,binormal));\n}\n\nvec3 localToWorld(vec3 tangent,vec3 normal,vec3 binormal,vec3 local)\n{\n    return tangent * local.x + binormal * local.z + normal * local.y;\n}\n\nvec3 hemisphereSampling(vec2 uv)\n{\n    float theta = acos(uv.x);\n    float phi = 2.0 * PI * uv.y;\n    return vec3(sin(theta) * cos(phi),cos(theta),sin(theta) * sin(phi));\n}\nstruct SurfaceInfo\n{\n    vec3 color;\n    vec3 emission;\n    float roughness;\n    float metallic;\n    vec3 normal;\n    vec3 position;\n};\nvec2 trip(vec3 P, vec3 N)\n{\n    N = N / dot(vec3(1), N);\n    return N.x * P.zy + N.y * P.xz + N.z * P.xy;\n}\nfloat sdf(vec3 p)\n{\n    return sin(p.x)+cos(p.z);\n}\n#define MAX_STEP 300\nbool raymarching(vec3 ro,vec3 rd,out SurfaceInfo info)\n{\n    info.color=vec3(0);\n    float d=1.;\n    vec3 sig=sign(rd);\n    vec3 stp=sig/rd;\n    vec3 vox=floor(ro/d)*d;\n    vec3 dep=((vox-ro+.5)*sig+.5)*stp;\n    vec3 axi;\n    rep(i,MAX_STEP)\n    {\n        vec3 h=pcg3(vox.zyz);\n        if(sdf(vox)<.0)\n        {\n            info.position = ro + rd*dot(dep-stp, axi);\n            info.normal = norm(-sig * axi);\n            vec2 uv=trip(info.position,info.normal);\n            info.color = vec3(1);\n            info.emission = h.x<.3?vec3(step(h.x,.5)*1.)*1.:vec3(0);\n            info.emission*=h.x<.2?vec3(step(fract((uv.x+uv.y)*4.),.3)):vec3(1)*vec3(0,0,1);\n            info.roughness = step(h.y,.5)*.8+.1;\n            info.metallic = step(h.z,.5)*.8+.1;\n            return true;\n        }\n        axi = dep.x<dep.z? \n            (dep.x<dep.y? vec3(1,0,0) : vec3(0,1,0) ):\n            (dep.z<dep.y? vec3(0,0,1) : vec3(0,1,0) );\n        vox += sig * axi*d;\n        dep += stp * axi*d;\n    }\n    info.position = ro+rd*d*float(MAX_STEP);\n    info.color = vec3(0);\n    info.normal = vec3(0);\n    return false;\n}\n\nvec3 cosineSampling(vec2 uv,inout float pdf)\n{\n    float theta = acos(1.0 - 2.0 * uv.x) * 0.5;\n    float phi = 2.0 * PI * uv.y;\n    pdf = cos(theta) / PI;\n    return vec3(sin(theta) * cos(phi),cos(theta),sin(theta) * sin(phi));\n}\nvec3 IBL(vec3 dir)\n{\n    return vec3(2.0);\n}\nvec3 shlickFresnel(vec3 F0,float cosTheta)\n{\n    float delta = 1.0 - cosTheta;\n    return F0 + (1.0 - F0) * delta * delta * delta * delta * delta;\n}\nfloat GGX_Lambda(vec3 v,float alpha)\n{\n    float delta = 1.0 + (alpha * alpha * v.x * v.x + alpha * alpha * v.z * v.z) / (v.y * v.y);\n    return (-1.0 + sqrt(delta)) / 2.0;\n}\nfloat GGX_D(vec3 wm,float alpha)\n{\n    float term1 = wm.x * wm.x / (alpha * alpha) + wm.z * wm.z / (alpha * alpha) + wm.y * wm.y;\n    float term2 = PI * alpha * alpha * term1 * term1;\n    return 1.0 / term2;\n}\nfloat GGX_G1(vec3 w,float alpha)\n{\n    return 1.0 / (1.0 + GGX_Lambda(w,alpha));\n}\nfloat GGX_G2_HeightCorrelated(vec3 wi,vec3 wo,float alpha)\n{\n    return 1.0 / (1.0 + GGX_Lambda(wi,alpha) + GGX_Lambda(wo,alpha));\n}\nvec3 ggx_halfsampling(vec2 uv,float alpha)\n{\n    float theta = atan(alpha * sqrt(uv.x) / sqrt(max(1.0 - uv.x,0.0)));\n    float phi = 2.0 * PI * uv.y;\n    return vec3(sin(theta) * cos(phi),cos(theta),sin(theta) * sin(phi));\n}\nvec3 sampleVisibleNormal(vec2 uv,vec3 wo,float alpha)\n{\n    vec3 strech_wo = normalize(vec3(wo.x * alpha,wo.y,wo.z * alpha));\n    float phi = 2.0 * PI * uv.x;\n    float z = fma((1.0 - uv.y),(1.0 + strech_wo.y),-strech_wo.y);\n    float sinTheta = sqrt(clamp(1.0 - z * z,0.0,1.0));\n    float x = sinTheta * cos(phi);\n    float y = sinTheta * sin(phi);\n    vec3 c = vec3(x,z,y);\n    vec3 h = c + strech_wo;\n\n    vec3 wm = normalize(vec3(h.x * alpha,h.y,h.z * alpha));\n    return wm;\n}\nfloat pdfLambert(vec3 wi)\n{\n    return wi.y / PI;\n}\nfloat pdfGGX(vec3 wo,vec3 wm,float alpha)\n{\n    return 0.25 * GGX_D(wm,alpha) * dot(wo,wm) / (dot(wm,wo) * abs(wo.y) * (1.0 + GGX_Lambda(wo,alpha)));\n}\nvec3 BSDF(vec3 wo,inout vec3 wi,SurfaceInfo info)\n{\n\n    float alpha = clamp(info.roughness * info.roughness,0.001,1.0);\n    vec3 F0 = mix(vec3(0.04),info.color,info.metallic);\n\n    float dif_weight = (1.0 - info.metallic);\n    float spec_weight = 1.0;\n    float sum_weight = dif_weight + spec_weight;\n\n    float cd = dif_weight / sum_weight;\n    float cs = spec_weight / sum_weight;\n\n    vec3 wm;\n    float pdf_diffuse;\n    float pdf_specular;\n    if(rnd1() < cd)\n    {\n        wi = cosineSampling(rnd2(),pdf_diffuse);\n        wm = normalize(wi + wo);\n        pdf_specular = pdfGGX(wo,wm,alpha);\n    }\n    else\n    {\n        wm = sampleVisibleNormal(rnd2(),wo,alpha);\n        wi = reflect(-wo,wm);\n        pdf_specular = pdfGGX(wo,wm,alpha);\n        pdf_diffuse = pdfLambert(wi);\n    }\n\n    if(wi.y < 0.0)\n    {\n        return vec3(0.0);\n    }\n\n    float pdf = cd * pdf_diffuse + cs * pdf_specular;\n\n    vec3 F = shlickFresnel(F0,dot(wi,wm));\n    float D = GGX_D(wm,alpha);\n    float G = GGX_G2_HeightCorrelated(wi,wo,alpha);\n\n    vec3 lambert = info.color / PI;\n\n    vec3 bsdf = lambert * (vec3(1.0) - F) * (1.0 - info.metallic) + F * D * G / (4.0 * wo.y * wi.y);\n\n    float cosine = wi.y;\n\n    return bsdf * cosine / pdf;\n}\nvec3 render(vec3 ro,vec3 rd)\n{\n    vec3 oro=ro,ord=rd;\n    vec3 col = vec3(0);\n    vec3 tp = vec3(1);//反射率 throughput\n    vec3 nor=vec3(0);\n    SurfaceInfo hit;\n    rep(i,MAX_DEPTH)\n    {\n        // russian roulette\n        float dice = sat(max(max(tp.x,tp.y),tp.z));\n        if(dice < rnd1())\n            break;\n        tp /= dice;\n\n        // raymarching\n        if(!raymarching(ro,rd,hit))\n        {\n            // no hit\n            col += tp * IBL(rd);\n            break;\n        }\n        if(length(hit.emission) > 0.0)\n        {\n            // hit light\n            col += tp * hit.emission;\n            break;\n        }\n        vec3 normal = hit.normal;\n        if(i==0)nor=normal;\n        vec3 tangent,binormal;\n        tangentSpaceBasis(normal,tangent,binormal);\n        vec3 local_wo = worldToLocal(tangent,normal,binormal,-rd);\n        vec3 local_wi;\n        tp *= BSDF(local_wo,local_wi,hit);\n        vec3 wi = localToWorld(tangent,normal,binormal,local_wi);\n        // next\n        //rd = norm(mix(wi,vec3(0,1,0),.1));// nne-like\n        rd=wi;\n        ro = hit.position + rd * eps * 10.;// avoid self-intersection\n    }\n    col=mix(vec3(0.718,0.922,0.961),col,exp(-.1*length(hit.position-oro)));\n    if(any(isnan(col)))col=vec3(0);\n    return col;\n}\nmat3 getBNT(vec3 T,float cr)\n{\n    T = normalize(T);\n    vec3 N = vec3(sin(cr), cos(cr), 0.0);\n    vec3 B = normalize(cross(N, T));\n    N = normalize(cross(T, B));\n    return mat3(B, N, T);\n}\nvoid getcam(vec2 fc,float t,out vec3 ro,out vec3 rd)\n{\n    fc += rnd2() - .5;\n    vec2 res = iResolution.xy,asp = res / min(res.x,res.y);\n    vec2 uv = fc / res,suv = (uv * 2. - 1.) * asp;\n    ro = vec3(2,5,-5);\n    vec3 dir = -ro;\n    float fov = 100.;\n    float z = 1./tan(fov*PI/360.) - length(suv)*.5;\n    rd = getBNT(dir,1.)*norm(vec3(suv,z));\n    // dof\n    vec3 tar=ro+rd*2.5;\n    ro+=(rnd3()-.5)*.08;\n    rd=norm(tar-ro);\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    seed = uint(iFrame);\n    vec4 col = vec4(0);\n    rep(i,8)\n    {\n        vec3 ro,rd;\n        getcam(gl_FragCoord.xy,iTime,ro,rd);\n        col += vec4(render(ro,rd),1);\n    }\n    fragColor = texelFetch(iChannel0,ivec2(gl_FragCoord.xy),0) + vec4(col.rgb / col.a,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define fma(a,b,c) ((a)*(b)+(c))\n#define sat(x) clamp(x,.0,1.)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define norm(x) normalize(x)\nconst float PI = acos(-1.);\nconst float TAU=PI*2.;\nvec3 pcg3(vec3 v)\n{\n    uvec3 x = floatBitsToUint(v);\n    const uint k = 1103515245u;\n    x = ((x >> 8U) ^ x.yzx) * k;\n    x = ((x >> 8U) ^ x.yzx) * k;\n    x = ((x >> 8U) ^ x.yzx) * k;\n    return vec3(x) / float(-1u);\n}","name":"Common","description":"","type":"common"}]}