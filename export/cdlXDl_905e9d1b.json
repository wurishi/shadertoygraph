{"ver":"0.1","info":{"id":"cdlXDl","date":"1669767263","viewed":115,"name":"Bezier curve axis-aligned box","username":"azherebtsov","description":"Axis aligned bounding boxes for Bezier curves to improve SDF performance by reducing search space. ","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["bezier","box","mask"],"hasliked":0,"parentid":"Ddj3WG","parentname":"Fork Fork Fork  stefsietz 927"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float mask(vec2 uv) {\n    uv.x /= iResolution.x/iResolution.y;\n    return texture(iChannel1, uv).r;\n}\n\n\nvec3 getBackgroundColor(vec2 uv) {\n    return texture(iChannel0, uv).rgb;\n    uv += 0.5; // remap uv from <-0.5,0.5> to <0,1>\n    vec3 gradientStartColor = vec3(0., 0., 0.);\n    vec3 gradientEndColor = vec3(0., 0., 0.);\n    \n    // animate color based on time\n    return mix(gradientStartColor, gradientEndColor, cos(iTime));\n}\n\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv * .55);\n\n  float smoothMask = mask(uv);\n  \n  \n  col = mix(col, vec3(1.), smoothMask * .3);\n \n  return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; // <0,1>\n    //uv -= 0.5; // center coordinates\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    \n    \n    vec3 col = drawScene(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi = 3.14159;\n\nconst vec2 vFontSize = vec2(0.0008, 0.00015);\nconst float brushSmooth = .005;\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nvec2 a1, a2, a3;\n\n//------------------------------------------------------------------------------\nvec2 quadratic(float t)     // return point on quadratic from parameter\n{\n    return a1+(a2*t)+(a3*t*t);\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n\nfloat mask(vec2 p, vec2 p1, vec2 p2, vec2 p3, float brush) {\n  float d = sdBezier(p, p1, p2, p3);\n  return 1. - smoothstep(0., brushSmooth, d - brush);\n}\n\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3 drawScene(vec2 uv) {\n  vec2 p1 = vec2(1.2, .3);\n  vec2 p2 = vec2(.8, 1.1);\n  vec2 p3 = vec2(.4, .2);\n  float brush = .1;\n  \n// -- control points\n  float d = 1.;//min( udSegment(uv,p1,p2),\n              //   udSegment(uv,p2,p3) );\n  //d = min( d, length(uv-p1)-0.01 );\n  //d = min( d, length(uv-p2)-0.02 );\n  //d = min( d, length(uv-p3)-0.03 );\n//  smoothMask = mix( smoothMask, 255., 1.0-smoothstep(0.0,0.007,d) );\n\n// -- bounding box\n  \n  // compute BEZIER coefficients\n  a1.x=                       (    p1.x);\n  a2.x=            (2.0*p2.x)-(2.0*p1.x);\n  a3.x= (    p3.x)-(2.0*p2.x)+(    p1.x);\n  \n  a1.y=                       (    p1.y);\n  a2.y=            (2.0*p2.y)-(2.0*p1.y);\n  a3.y= (    p3.y)-(2.0*p2.y)+(    p1.y);\n  \n\n  vec2 a,b, xr, yr;\n  vec2 roots = a2 / (a2 - a3);\n  \n  p1 = quadratic(0.);\n  p3 = quadratic(1.);\n\n  a=p1;                     b=p1;\n  if (a.x > p3.x) a.x=p3.x; if (b.x < p3.x) b.x=p3.x;\n  if (a.y > p3.y) a.y=p3.y; if (b.y < p3.y) b.y=p3.y;\n\n  if (roots.x > 0. && roots.x < 1.) {\n    float px = quadratic(roots.x).x;\n    if (a.x > px) a.x=px; if (b.x < px) b.x=px;\n  }\n\n  if (roots.y > 0. && roots.y < 1.) {\n    float py = quadratic(roots.y).y;\n    if (a.y > py) a.y=py; if (b.y < py) b.y=py;\n  }\n\n  // enlarge by d\n  a.x-=brush + brushSmooth; a.y-=brush + brushSmooth;\n  b.x+=brush + brushSmooth; b.y+=brush + brushSmooth;\n\n  // after this point `a` and `b` defines corners of the enclosing box \n\n  d = min( d, length(uv-a)-0.01 );\n  d = min( d, length(uv-b)-0.01 );\n  \n  // box borders\n  d = min( d, udSegment(uv,a,vec2(b.x,a.y)));\n  d = min( d, udSegment(uv,a,vec2(a.x,b.y)));\n  d = min( d, udSegment(uv,b,vec2(a.x,b.y)));\n  d = min( d, udSegment(uv,b,vec2(b.x,a.y)));\n  \n  //smoothMask = mix( smoothMask, 255., 1.0-smoothstep(0.0,0.002,d) );\n  \n  // -- mask\n  if (uv.x >= a.x && uv.y >= a.y && uv.x <= b.x && uv.y <= b.y) {\n    return vec3(mask(uv, p1, p2, p3, brush));\n  }\n\n  return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/vec2(iResolution.x, iResolution.y); // <0,1>\n    //uv -= 0.5; // center coordinates\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    \n    \n    vec3 col = drawScene(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}