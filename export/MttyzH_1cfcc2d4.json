{"ver":"0.1","info":{"id":"MttyzH","date":"1531639952","viewed":202,"name":"Brieskorn Varieties","username":"Ebanflo","description":"Mousable. A cross section of a certain class of affine algebraic varieties.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["math","raymarch","12d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define epsilon vec2(0, 0.01)\n#define far 30.0\n#define close 0.02\n#define steps 60\n\n#define m iMouse.xy==vec2(0)?sin(vec2(0.1*iTime,0.1*iTime+1.57)):(2.0*iMouse.xy-iResolution.xy)/iResolution.y\n\n//all must be integers greater than 1\nconst int exponents[] = int[](3, 5, 7);\n\nconst float radius = 3.0;\n\n//sdf of the complex variety, just divide the polynomial by its (complex) gradient\nfloat sdVariety(vec2 z[3]){\n    vec2[6] monomials;\n    for(int i = 0; i < 3; i++) monomials[i] = cpow(z[i], float(exponents[i]));\n    vec2[6] monomials1;\n    for(int i = 0; i < 3; i++) monomials1[i] = cpow(z[i] + epsilon, float(exponents[i]));\n    vec2 potential = vec2(0);\n    for(int i = 0; i < 3; i++) potential += monomials[i];\n    for(int i = 0; i < 3; i++){monomials1[i] -= monomials[i]; monomials1[i] /= epsilon.y;}\n    float magGrad = 0.0;\n    for(int i = 0; i < 3; i++) magGrad += dot(monomials1[i], monomials1[i]);\n    magGrad = sqrt(magGrad);\n    return length(potential)/magGrad;\n}\n\n//components of the normal which lie in the same 3-plane as the camera\nvec3 calcNormal(vec4 z){\n    return normalize(vec3(cpow(z.xy, float(exponents[0])),\n                          cpow(z.zw, float(exponents[1])).x));\n}\n\nfloat sdSphere(vec2 z[3]){\n    float d = 0.0;\n    for(int i = 0; i < 3; i++) d += dot(z[i], z[i]);\n    d = sqrt(d);\n    return d - radius;\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    vec2[3] p = vec2[](ro.xy, vec2(ro.z, 0.5*sin(0.5*iTime)), .25*m);\n    vec2[3] dir = vec2[](rd.xy, vec2(rd.z, 0), vec2(0));\n    float t = 0.0;\n    bool hit = false;\n    for(int i = 0; i < steps; i++){\n        float d = max(sdSphere(p), sdVariety(p));\n        if(d < close){hit = true; break;}\n        p = add(p, mul(d, dir));\n        t += d;\n        if(t > far) break;\n    }\n    //no fancy lighting or coloration or anything\n    if(hit) return (2.5 + 2.5*calcNormal(vec4(p[0], p[1])))/(t*t);\n    else return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 xy = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(xy, 2));\n    ro = r(ro, vec2(0.1*iTime));\n    rd = r(rd, vec2(0.1*iTime));\n    fragColor = vec4(render(ro, rd), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2[3] add(vec2[3] a, vec2[3] b){\n    for(int i = 0; i < 3; i++) a[i] += b[i];\n    return a;\n}\n\nvec2[3] mul(float s, vec2[3] v){\n    for(int i = 0; i < 3; i++) v[i] *= s;\n    return v;\n}\n\n//rodolphito's code----------------------------------\n\nvec3 r(vec3 v, vec2 r){\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\n//Complex+Quaternion+Octonion+Sedenion code\n//use with attribution (c) Rodol 2018\n//https://www.shadertoy.com/view/ldGyR3\n\nvec4 pi = vec4(0,2,4,8)*atan(1.0);\n\n// (1,i)\nvec2 creal(float a){return vec2(a,0);}\nfloat csl (vec2 z){return dot(z,z);}\nfloat cl  (vec2 z){return sqrt(csl(z));}\nfloat csil(vec2 z){return z.y*z.y;}\nfloat cil (vec2 z){return z.y;}\nfloat carg(vec2 z){return atan(cil(z),z.x);}\nvec2 cconj(vec2 z){z.x=-z.x;return-z;}\nvec2 cmul (vec2 z,float b){return z*b;}\nvec2 cmul (vec2 a,vec2 b){return mat2(a,-a.y,a.x)*b;}\nvec2 csqr (vec2 z){return vec2(z.x*z.x-z.y*z.y,2.0*z.y*z.x);}\nvec2 ccube(vec2 z){return vec2(z.x*z.x-3.0*z.y*z.y,3.0*z.x*z.x-z.y*z.y)*z;}\nvec2 cinv (vec2 z){return cconj(z)/csl(z);}\nvec2 cdiv (vec2 a,vec2 b){return cmul(a,cinv(b));}\nvec2 cexp (vec2 z){float l=cil(z);return sin(l+pi.yx)*exp(z.x);}\nvec2 clog (float x){return vec2(log(abs(x)),pi.z*step(0.0,x));}\nvec2 cpow (float a,vec2 z){float l=cil(z);return sin(l+pi.yx)*pow(a,z.x);}\nvec2 cpow (vec2 z,float n){return pow(csl(z),n*0.5)*sin(carg(z)*n+pi.yx);}\nvec2 cpow (vec2 a,vec2 b){return cmul(cpow(csl(a),0.5*b),cexp(carg(a)*b));}\n\n// (1,i,j,k)\nvec4 qreal(float a){return vec4(a,vec3(0));}\nfloat qsl (vec4 q){return dot(q,q);}\nfloat ql  (vec4 q){return sqrt(qsl(q));}\nfloat qsil(vec4 q){return dot(q.yzw,q.yzw);}\nfloat qil (vec4 q){return sqrt(qsil(q));}\nfloat qarg(vec4 q){return atan(qil(q),q.x);}\nvec4 qconj(vec4 q){q.x=-q.x;return-q;}\nvec3 qmul (vec4 q,vec3 v){return v+2.0*cross(cross(v,q.yzw)+q.x*v,q.yzw);}\nvec4 qmul (vec4 a,vec4 b){return vec4(a.x*b.x-dot(a.yzw,b.yzw),b.yzw*a.x+a.yzw*b.x+cross(a.yzw,b.yzw));}\nvec4 qsqr (vec4 q){return vec4(q.x*q.x-qsil(q),2.0*q.x*q.yzw);}\nvec4 qcube(vec4 q){float l=qsil(q);return q*vec2(3.0*q.x*q.x-l,q.x*q.x-3.0*l).yxxx;}\nvec4 qinv (vec4 q){return qconj(q)/qsl(q);}\nvec4 qdiv (vec4 a,vec4 b){return qmul(a,qinv(b));}\nvec4 qexp (vec4 q){float l=qil(q);vec2 z=sin(l+pi.xy)*exp(q.x);q*=z.x/l;q.x=z.y;return q;}\nvec4 qlog (float x){return vec4(log(abs(x)),step(0.0,x),vec2(0));}\nvec4 qpow (float a,vec4 q){float l=qil(q);vec2 z=sin(l+pi.xy)*pow(a,q.x);q*=z.x/l;q.x=z.y;return q;}\nvec4 qpow (vec4 q,float n){return pow(qsl(q),n*0.5)*sin(qarg(q)*n+pi.xy).yxxx;}\nvec4 qpow (vec4 a,vec4 b){return qmul(qpow(qsl(a),0.5*b),qexp(qarg(a)*b));}\n\n// (1,i,j,k,l,m,n,o)\nmat2x4 oreal(float a){return mat2x4(a,vec3(0),vec4(0));}\nfloat osl (mat2x4 o){return qsl(o[0])+qsl(o[1]);}\nfloat ol  (mat2x4 o){return sqrt(osl(o));}\nfloat osil(mat2x4 o){return qsil(o[0])+qsl(o[1]);}\nfloat oil (mat2x4 o){return sqrt(osil(o));}\nfloat oarg(mat2x4 o){return atan(oil(o),o[0].x);}\nmat2x4 oconj(mat2x4 o){o[0].x=-o[0].x;return-o;}\nmat2x4 omul (mat2x4 a,mat2x4 b){return mat2x4(qmul(a[0],b[0])-qmul(qconj(b[1]),a[1]),qmul(b[1],a[1])+qmul(a[1],qconj(b[0])));}\nmat2x4 osqr (mat2x4 o){return mat2x4(qsqr(o[0])-vec4(qsil(o[1]),vec3(0)),qsqr(o[1])+qmul(o[0],qconj(o[1])));}\n//mat2x4 ocube(mat2x4 o)\nmat2x4 oinv (mat2x4 o){return oconj(o)/osl(o);}\nmat2x4 odiv (mat2x4 a,mat2x4 b){return omul(a,oinv(b));}\nmat2x4 oexp (mat2x4 o){float l=oil(o);vec2 z=sin(l+pi.xy)*exp(o[0].x);o*=z.x/l;o[0].x=z.y;return o;}\nmat2x4 olog (float x){return mat2x4(log(abs(x)),step(0.0,x),vec2(0),vec4(0));}\nmat2x4 opow (float a,mat2x4 o){float l=oil(o);vec2 z=sin(l+pi.xy)*pow(a,o[0].x);o*=z.x/l;o[0].x=z.y;return o;}\nmat2x4 opow (mat2x4 o,float n){vec2 z=pow(osl(o),n*0.5)*sin(oarg(o)*n+pi.xy);return mat2x4(z.yxxx,z.xxxx);}\nmat2x4 opow (mat2x4 a,mat2x4 b){return omul(opow(osl(a),0.5*b),oexp(oarg(a)*b));}\n\n// (1,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)\nmat4x4 sreal(float a){return mat4x4(a,vec3(0),vec4(0),vec4(0),vec4(0));}\nfloat ssl (mat4x4 s){return qsl(s[0])+qsl(s[1])+qsl(s[2])+qsl(s[3]);}\nfloat sl  (mat4x4 s){return sqrt(ssl(s));}\nfloat ssil(mat4x4 s){return qsil(s[0])+qsl(s[1])+qsl(s[2])+qsl(s[3]);}\nfloat sil (mat4x4 s){return sqrt(ssil(s));}\nfloat sarg(mat4x4 s){return atan(sil(s),s[0].x);}\nmat4x4 sconj(mat4x4 s){s[0].x=-s[0].x;return-s;}\nmat4x4 smul (mat4x4 a,mat4x4 b){mat2x4 c=omul(mat2x4(a[0],a[1]),mat2x4(b[0],b[1]))-omul(oconj(mat2x4(b[2],b[3])),mat2x4(a[2],a[3]));mat2x4 d=omul(mat2x4(b[2],b[3]),mat2x4(a[2],a[3]))+omul(mat2x4(a[2],a[3]),oconj(mat2x4(b[0],b[1])));return mat4x4(c[0],d[1],c[0],d[1]);}\nmat4x4 ssqr (mat4x4 s){mat2x4 a=osqr(mat2x4(s[0],s[1]))-mat2x4(osil(mat2x4(s[2],s[3])),vec3(0),vec4(0));mat2x4 b=osqr(mat2x4(s[2],s[3]))+omul(mat2x4(s[0],s[1]),oconj(mat2x4(s[2],s[3])));return mat4x4(a[0],a[1],b[0],b[1]);}\n//mat4x4 scube(mat4x4 s)\nmat4x4 sinv (mat4x4 s){return sconj(s)/ssl(s);}\nmat4x4 sdiv (mat4x4 a,mat4x4 b){return smul(a,sinv(b));}\nmat4x4 sexp (mat4x4 s){float l=sil(s);vec2 z=sin(l+pi.xy)*exp(s[0].x);s*=z.x/l;s[0].x=z.y;return s;}\nmat4x4 slog (float x){return mat4x4(log(abs(x)),step(0.0,x),vec2(0),vec4(0),vec4(0),vec4(0));}\nmat4x4 spow (float a,mat4x4 s){float l=sil(s);vec2 z=sin(l+pi.xy)*pow(a,s[0].x);s*=z.x/l;s[0].x=z.y;return s;}\nmat4x4 spow (mat4x4 s,float n){vec2 z=pow(ssl(s),n*0.5)*sin(sarg(s)*n+pi.xy);return mat4x4(z.yxxx,z.xxxx,z.xxxx,z.xxxx);}\nmat4x4 spow (mat4x4 a,mat4x4 b){return smul(spow(ssl(a),0.5*b),sexp(sarg(a)*b));}\n\nvec3 hsv2rgb(vec3 c){return (2.0-c.y-sin(c.x-pi.xzw/3.0)*c.y)*c.z*0.5;}","name":"Common","description":"","type":"common"}]}