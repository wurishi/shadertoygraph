{"ver":"0.1","info":{"id":"sstBWj","date":"1657240947","viewed":83,"name":"Circle-Circle Intersection __","username":"Envy24","description":"Circle-Circle Intersection\nhttps://www.desmos.com/calculator/aizuhpqfet\n\nBufferA - circles rasterization\nBufferB - intersection rasterization\n\nOther realization:\nhttps://www.shadertoy.com/view/ltG3zK","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["intersection","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )\n#define TEXF1(SC)                 ( texelFetch(iChannel1, ivec2(SC), 0) )\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec4 circles_color = TEXF0(SC);\n    vec4 intersection_color = TEXF1(SC);\n\n    O = mix(circles_color, vec4(0,0,intersection_color.b,1), intersection_color.b);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/*\n    Return value:\n        0 - two complex roots;\n        1 - one real root, but root[0] == root[1];\n        2 - two real roots;\n*/\nint solveQuadratic(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n\n    if (discriminant < 0.0)\n    {\n        float INVa = 1.0 / (2. * coefs[0]);\n        float SQRT = sqrt(-discriminant);\n\n        roots[0].x = -coefs[1] * INVa;\n        roots[0].y = SQRT * INVa;\n        roots[1].x = -coefs[1] * INVa;\n        roots[1].y = -SQRT * INVa;\n\n        return 0;\n    }\n\n    if (abs(discriminant) < 1e-14)\n    {\n        float Re = -coefs[1] / (2. * coefs[0]);\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = Re;\n        roots[1].y = 0.0;\n\n        return 1;\n    }\n\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;\n    roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa;\n    roots[1].y = 0.0;\n\n    return 2;\n}\n\nint solve(\n    inout vec2[2] roots,\n    in float[3] coef)\n{\n    float EPSILON = 1e-2;\n\n    // Linear equation?\n    if (abs(coef[0]) < EPSILON)\n    {\n        // Constant?\n        if (abs(coef[1]) < EPSILON) { return 0; }\n\n        // Solve linear.\n        roots[0].x = -coef[2]/coef[1];\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n        \n    return solveQuadratic(roots, coef);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n\nfloat circleSDF_L2(\n    vec2 NDC,\n    vec2 C,\n    float R)\n{\n    NDC -= C;\n    float a = NDC.x*NDC.x+NDC.y*NDC.y-1.0;\n    float lambda = (1.0 - sqrt(1.0+a)) / a;\n    float invDenom = 1.0 / (1.0 + lambda);\n    vec2 AtoC = R*(NDC * invDenom - NDC) - NDC;\n\n    return length(AtoC);\n}\n\nvec3 colorize(float dist, vec3 color)\n{\n    return mix(vec3(1), color, smoothstep(6./R.y, 0.0, abs(dist)));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * 3.0;\n\n    /* Two intersection points. */\n    float R0 = sinOSC(1., 2.5, iTime);\n    float R1 = sinOSC(1., 3., iTime*0.5);\n    vec2 C0 = vec2(sinOSC(-2., 2., iTime),        sinOSC(-1., 1., iTime*0.7));\n    vec2 C1 = vec2(sinOSC( 2.5, -2.5, iTime*0.5), sinOSC(1.5, -1.5, iTime*0.3));\n    /* One intersection point. *\n    float R0 = 1.0;\n    float R1 = 1.0;\n    vec2 C0 = vec2(-1.0, 0.0);\n    vec2 C1 = vec2( 1.0, 0.0);\n    /**/\n\n    float md0 = circleSDF_L2(NDC, C0, R0),\n          md1 = circleSDF_L2(NDC, C1, R1);\n          \n    vec3 color =\n        md0 < md1 ?\n           colorize(md0, vec3(1,0,0)) :\n           colorize(md1, vec3(0,1,0));\n\n    O = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}\n\nfloat diskSDF_L2(\n    vec2 NDC,\n    vec2 C,\n    float R)\n{\n    return length(C - NDC)-R;\n}\n\n/* Solution from: https://www.desmos.com/calculator/aizuhpqfet *\nint circleCircleIntersection(\n    inout vec2 intersections[2],\n    vec2 C0,\n    vec2 C1,\n    float R0,\n    float R1)\n{\n    float z=2.*(C0.y-C1.y);\n    float m=C1.x*C1.x-C0.x*C0.x-C0.y*C0.y+C1.y*C1.y+R0*R0-R1*R1;\n    float n=2.*(C1.x-C0.x);\n    \n    float coef[3] = float[3](\n        z*z+n*n,\n        2.*(z*m-C1.x*z*n-C1.y*n*n),\n        m*m-2.*C1.x*m*n+C1.x*C1.x*n*n+C1.y*C1.y*n*n-R1*R1*n*n\n    );\n    \n    int num = solve(intersections, coef);\n      \n    intersections[0].y = intersections[0].x;\n    intersections[1].y = intersections[1].x;\n\n    intersections[0].x = (intersections[0].y*z + m)/n;\n    intersections[1].x = (intersections[1].y*z + m)/n;\n    \n    return num;\n}\n/**/\nint circleCircleIntersection(\n    inout vec2 intersections[2],\n    vec2 C0,\n    vec2 C1,\n    float R0,\n    float R1)\n{\n    float d0 = dot(C0, C0),\n          d1 = dot(C1, C1);\n    \n    float z=2.*(C0.y-C1.y),\n          m=d1-d0+R0*R0-R1*R1,\n          n=2.*(C1.x-C0.x),\n          nn = n*n;\n    \n    float coef[3] = float[3](\n        z*z+nn,\n        2.*(z*(m-C1.x*n)-C1.y*nn),\n        m*(m-2.*C1.x*n)+nn*(d1-R1*R1)\n    );\n    \n    // Solve quadratic equation for ys.\n    int num = solve(intersections, coef);\n      \n    // Convert (y,x) to (x,y)\n    intersections[0].y = intersections[0].x;\n    intersections[1].y = intersections[1].x;\n\n    // Calculate xs.\n    intersections[0].x = (intersections[0].y*z + m)/n;\n    intersections[1].x = (intersections[1].y*z + m)/n;\n    \n    return num;\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * 3.0;\n    \n    /* Two intersection points. */\n    float R0 = sinOSC(1., 2.5, iTime);\n    float R1 = sinOSC(1., 3., iTime*0.5);\n    vec2 C0 = vec2(sinOSC(-2., 2., iTime),        sinOSC(-1., 1., iTime*0.7));\n    vec2 C1 = vec2(sinOSC( 2.5, -2.5, iTime*0.5), sinOSC(1.5, -1.5, iTime*0.3));\n    /* One intersection point. *\n    float R0 = 1.0;\n    float R1 = 1.0;\n    vec2 C0 = vec2(-1.0, 0.0);\n    vec2 C1 = vec2( 1.0, 0.0);\n    /**/\n    \n    vec2 intersections[2];\n    int num = circleCircleIntersection(intersections, C0, C1, R0, R1);\n\n    vec3 color;\n\n    float md = 0.0;\n        \n    switch(num)\n    {\n    /* case 1 is rare, so you can throw away this case */\n    case 1: md = 1.0 - smoothstep(0.0, 6./R.y,     diskSDF_L2(NDC, intersections[0], 0.05));                 break;\n    case 2: md = 1.0 - smoothstep(0.0, 6./R.y, abs(segmentSDF_L2(NDC, intersections[0], intersections[1]))); break;\n    //default:md = 0.0; break;\n    }       \n\n    O = vec4(md);\n}","name":"Buffer B","description":"","type":"buffer"}]}