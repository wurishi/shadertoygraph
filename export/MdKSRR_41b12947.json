{"ver":"0.1","info":{"id":"MdKSRR","date":"1462553321","viewed":420,"name":"Hexels!","username":"allegrocm","description":"Just a hexagon sampler.  And for you smartasses, I realize it's not optimized or practical.","likes":2,"published":1,"flags":34,"usePreview":0,"tags":["hexels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float checkers()\n{\n    float scale = 16.0;\n \treturn mod(floor(gl_FragCoord.x / scale) + floor(gl_FragCoord.y / scale), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 upper = texture(iChannel2, uv);\n    float check = checkers();\n    check = 0.4 + 0.3 * check;\n    vec4 chx = vec4(check, check, check, 1.0);\n\tfragColor = mix(chx, upper, upper.a);;\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nint iclamp(int v, int low, int hi)\n{\n\tif(v < low) return low;\n    if(v > hi) return hi;\n    return v;\n}\n\nint hexelIndex(vec2 pos)\n{\n\tvec2 mouse = pos;\n\tmouse.x *= 0.866 * 1.6;\n\tfloat subColf = mod(mouse.x * 2.0, 2.0);\n        \n\tint subCol = int(subColf);\t\t//half hexes\n\tsubColf = mod(subColf, 1.0);\n\tfloat subRowf = mod(mouse.y, 2.0) * 3.0; \n\n\t//subrow 0 is the lower section of middle of the first row.\n\t//1 is the bottom of the first row/top of the second row, 2 is top top mid of 2nd row, etc\n\tint subRow = int(subRowf);\n\tsubRowf = mod(subRowf, 1.0);\n\tsubRow = iclamp(subRow, 0, 6);\n\t\n\t//true if we're on a horizontal line where the vertical faces meet (ie the middle section of each hex)\n\tbool midSection = true;\n\tif(subRow == 1 || subRow == 4) midSection = false;\n//\telse if(subRow > 2.\n\t//printf(\"subRow = %i (%.2f), subCol = %i (%.2f)\\n\", subRow,subRowf, subCol, subColf);\n\tint row = int(mouse.y);\t\n\t\n\tif(subRow == 2 || subRow == 5) row++;\n\n\t//shift over if we're in the midsection of the shifted hex rows\n\tif(subRow == 1 || subRow == 0 || subRow == 5) mouse.x += 0.5;\n\tint col = int(mouse.x);\n\t\n\tif(!midSection)\t\t//this is where it gets tricky\n\t{\n\t\tif(subRow == 4)\t\t//subrow 4 slopes downward on subCol 0, upward on subCol1\n\t\t{\n\t\t\tif(subCol == 1 && subColf > 1.0 - subRowf)\n\t\t\t{\n\t\t\t\trow++;\n\t\t\t\tcol++;\n\t\t\t}\n\t\t\telse if(subCol == 0 && subColf < subRowf)\n\t\t\t{\n\t\t\t\trow++;\n//\t\t\t\tcol--;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if(subRow == 1)\t\t//subrow 1 slopes upward on subCol 0, downward on subCol1\n\t\t{\n\t\t\tif(subCol == 0 && subColf > 1.0 - subRowf)\n\t\t\t{\n\t\t\t\trow++;\n//\t\t\t\tcol++;\n\t\t\t}\n\t\t\telse if(subCol == 1 && subColf < subRowf)\n\t\t\t{\n//\t\t\t\tprintf(\"swap\\n\");\n\t\t\t\trow++;\n\t\t\t\tcol--;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn row * 64 + col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    int hex = hexelIndex(uv * 8.0);\n    int hexY = hex/64;\n    int hexX = hex-hexY*64;\n    vec2 hexCoords = vec2(float(hexX), float(hexY)) / 64.0;;\n    vec4 color = texture(iChannel0, hexCoords);\n    vec4 bw = texture(iChannel1, hexCoords * 2.0);\n   \n    //a gamma curve of sorts\n    bw.r = 1.0-(cos(bw.r * 3.14159) * 0.5 + 0.5);\n    bw.r = 1.0-(cos(bw.r * 3.14159) * 0.5 + 0.5);\n\tfragColor = vec4(color.rgb,bw.r);\n\n}","name":"Buf A","description":"","type":"buffer"}]}