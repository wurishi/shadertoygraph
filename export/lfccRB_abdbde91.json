{"ver":"0.1","info":{"id":"lfccRB","date":"1732918937","viewed":61,"name":"Checkerboard 4","username":"jonaskje","description":"A checkerboard","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["checkerboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float CylinderRadiusM = 3.25;\nconst vec3 CameraPosition = vec3(0.0, 3.25, -3.0);\nconst float ViewPlaneDistanceM = 1.0;\nconst float ViewPlaneHeightM = 1.0;\nconst vec3 LightDirection = normalize(vec3(-0.646997, 0.554829, -0.407833));\n\n#define PRECISION_STEP 0.00001\n#define NO_HIT 1000.0\n\nvec3 pixelCoordToRay(vec2 fragCoord) {\n    // Compute inverse resolutions as variables\n    float InvResolutionX = 1.0 / iResolution.x;\n    float InvResolutionY = 1.0 / iResolution.y;\n\n    // Adjust the view plane width based on the aspect ratio\n    float ViewPlaneWidthM = ViewPlaneHeightM * (iResolution.x * InvResolutionY);\n\n    // Compute normalized device coordinates (NDC)\n    float x = ViewPlaneWidthM * (0.5 - (fragCoord.x + 0.5) * InvResolutionX);\n    float y = ((fragCoord.y + 0.5) * InvResolutionY) - 0.5;\n\n    return normalize(vec3(x, y, ViewPlaneDistanceM));\n}\n\nvec3 rotateByYawRoll(vec3 v, float yaw, float roll) {\n    // Compute trigonometric functions\n    float sy = sin(yaw), cy = cos(yaw);\n    float sr = sin(roll), cr = cos(roll);\n\n    // Apply combined yaw and roll rotation\n    return vec3(\n        cr * cy * v.x - sr * v.y + cr * sy * v.z,\n        sr * cy * v.x + cr * v.y + sr * sy * v.z,\n        -sy * v.x + cy * v.z\n    );\n}\n\nfloat rayCylinderIntersection(vec3 P, vec3 D) {\n    // Coefficients for the quadratic equation\n    float a = D.y * D.y + D.z * D.z;\n    float b = 2.0 * (P.y * D.y + P.z * D.z);\n    float c = P.y * P.y + P.z * P.z - CylinderRadiusM * CylinderRadiusM;\n\n    // Discriminant of the quadratic equation\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) return NO_HIT; // No intersection\n\n    float sqrtDiscriminant = sqrt(discriminant);\n    float inv2a = 0.5 / a;\n\n    // Compute the two possible intersection distances\n    float t0 = (-b - sqrtDiscriminant) * inv2a;\n    float t1 = (-b + sqrtDiscriminant) * inv2a;\n\n    // Choose the smallest positive t as the intersection point\n    float t = t0 > 0.0 ? t0 : (t1 > 0.0 ? t1 : NO_HIT);\n\n    return t;\n}\n\nfloat squarePattern(vec2 coord) {\n    // Compute grid indices\n    float xVal = floor(coord.x * 6.0);\n    float yVal = floor(coord.y * 6.0);\n\n    // Determine pattern based on parity\n    return mod(xVal + yVal, 2.0);\n}\n\nvec3 hsv2rgb(vec3 hsv) {\n    // Efficient HSV to RGB conversion\n    vec3 rgb = clamp(abs(mod(hsv.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return hsv.z * mix(vec3(1.0), rgb, hsv.y);\n}\n\n\nfloat raySphere(vec3 CameraPosition, vec3 rayDir, vec3 c, float r) {\n    vec3 oc = CameraPosition - c;\n    float h = dot(rayDir, oc);\n    float D = h * h - dot(oc, oc) + r * r;\n    if (D < 0.0) {\n        return NO_HIT;\n    }\n    float sqrtD = sqrt(D);\n    float t0 = -h - sqrtD;\n    float t1 = -h + sqrtD;\n\n    if (t0 > 0.0) {\n        return t0; // First intersection point\n    } else if (t1 > 0.0) {\n        return t1; // Ray starts inside sphere, second intersection point\n    } else {\n        return NO_HIT; // Intersection behind the ray origin\n    }\n}\n\n#define doSphere(bounceOffset, posOffset, x, hue) \\\n    {float speed = 0.6; \\\n    float h = 3.28 + abs(sin(iTime*5.0 + bounceOffset)*0.2); \\\n    vec3 sphereCenter = vec3(x, sin(1.3 + mod(speed*iTime + posOffset, 1.4))*h,cos( 1.3 + mod(speed*iTime + posOffset, 1.4))*h); \\\n    float t = raySphere(CameraPosition, rayDir, sphereCenter, 0.05); \\\n    if (t < res.w) \\\n    { \\\n        res.w = t; \\\n        res.xyz = hsv2rgb(vec3(hue, 0.7, 0.9)); \\\n        normal = normalize((CameraPosition + t * rayDir) - sphereCenter); \\\n    }} \n\nvec4 traceSpheres(vec3 CameraPosition, vec3 rayDir, inout vec3 normal)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, NO_HIT);\n    normal = vec3(0.0, 1.0, 0.0);\n\n    doSphere(1.40951194424625, 0.645580433656266, -1.58279751035515, 0.00604802277220787);\n    doSphere(2.63433196476397, 1.57572056487003, -0.933698912585945, 0.408157107144667);\n    doSphere(0.112099948791834, 0.031071691881433, -0.0475591318903301, 0.236691714374671);\n    doSphere(2.64073005555232, 0.939259036276144, 1.38102227979387, 0.518822133317041);\n    doSphere(2.97505993938775, 1.45565560788645, -0.817899956748774, 0.362861728464655);\n    doSphere(0.0566549594032834, 1.07587217794539, 1.75809785339893, 0.93986247756512);\n    doSphere(0.164739213131712, 0.234439307746682, 1.25018946791542, 0.864464572567709);\n    doSphere(3.1133108173559, 1.83798234641458, 1.22737718710088, 0.595241071467866);\n    doSphere(0.83222827168751, 1.13597709598764, 0.301282094000504, 0.661992491996844);\n    doSphere(1.01368467237506, 0.768029862720533, 0.791835238594485, 0.00456013670403517);\n    doSphere(1.7844825046996, 0.811555722174959, 1.60172530058852, 0.934735066227026);\n    doSphere(0.565863463350508, 1.4202006276791, 1.03070737376376, 0.842130211574086);\n    doSphere(2.51512038600404, 0.288984842453611, -0.947902427496343, 0.728244875431175);\n    doSphere(0.604865328224779, 1.44948381881671, 1.69170714155385, 0.638197052589709);\n    doSphere(2.39723901933862, 2.01244703881091, 0.789395424904952, 0.547469130040831);\n    doSphere(0.14813215085684, 1.56889867245634, 0.0474201766994877, 0.22202910306958);\n    doSphere(0.0651068276097564, 0.662098657787824, 0.659689191104699, 0.319707162827117);\n    doSphere(1.90066734020629, 2.02815258364573, -1.02826363361825, 0.200635948311834);\n    doSphere(1.96675990137586, 0.326210186502994, -1.02331079497156, 0.511123279813269);\n    doSphere(2.77230017770655, 0.968171158744102, -0.54843933253942, 0.478918327241632);\n    doSphere(0.792132119812133, 0.543444180089722, -0.375569378200718, 0.637385728134488);\n    doSphere(1.07476228271367, 1.89733716710347, 0.741580748344576, 0.476621169818854);\n    doSphere(1.45378256161408, 0.24669717687494, -1.57999782617204, 0.511762130312511);\n    doSphere(2.50035853776166, 0.578622166476502, -1.93420388360238, 0.310045845485314);\n    doSphere(0.852603030741496, 0.497253206231284, 1.72220935287057, 0.657057593416915);\n    doSphere(0.917363492146769, 0.0643015059010598, 1.81853031731142, 0.286339274740936);\n    doSphere(1.32002084752546, 0.0965911268706392, 1.90010382975456, 0.419978084238236);\n    doSphere(1.58165276471602, 0.217286042690876, -0.0828805985315146, 0.435579416079251);\n    doSphere(1.39793673263767, 0.287062385625701, -0.787663842918195, 0.382561927839444);\n    doSphere(0.791631169389762, 0.670941971322029, -1.34952162548412, 0.468500379691133);\n    doSphere(0.84721112789922, 2.04629326497498, -1.49932379065981, 0.795297234223828);\n\n    return res;\n}\n\nvec4 trace(vec3 CameraPosition, vec3 rayDir)\n{\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    vec4 res = traceSpheres(CameraPosition, rayDir, normal);\n    \n    // Find intersection with the cylinder\n    float t = rayCylinderIntersection(CameraPosition, rayDir);\n    if (t < res.w) \n    {\n        normal = vec3(0.0, 1.0, 0.0);\n        res.w = t;\n\n        vec3 intersect = CameraPosition + t * rayDir;\n        float intersectAngle = acos(intersect.y / CylinderRadiusM) - 0.4 * iTime;\n\n        // Calculate color based on the pattern and angle\n        float colorAngle = intersectAngle + 3.14159265 * squarePattern(vec2(intersect.x, intersectAngle * CylinderRadiusM));\n        float hue = mod(colorAngle / 6.28318530, 1.0);\n\n        // Set the fragment color\n        res.xyz = hsv2rgb(vec3(hue, 0.5, 0.8));\n\n\n        vec3 ignoreNormal;\n        vec4 shadowTrace = traceSpheres(intersect, LightDirection, ignoreNormal);\n        res.xyz *= shadowTrace.w < NO_HIT ? 0.6 : 1.0;\n    }\n    \n\n    vec3 reflection = reflect(rayDir, normal);\n    \n    float ambient = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n    float diffuse = clamp( dot( normal, LightDirection ), 0.2, 1.0 );\n    float specular = pow(clamp( dot( reflection, LightDirection ), 0.0, 1.0 ),16.0);\n    vec3 lit = vec3(diffuse);\n    lit += 0.20*ambient*vec3(0.50,0.50,0.60);\n    res.xyz *= lit;\n    res.xyz += specular*diffuse;    \n    return vec4(res.xyz, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Precompute sine of time for efficiency\n    float sTime = sin(iTime);\n    float yaw = sTime * 0.2;\n    float roll = sTime * 0.2;\n\n    // Compute the ray direction\n    vec3 rayDir = rotateByYawRoll(pixelCoordToRay(fragCoord), yaw, roll);\n\n\n    fragColor = trace(CameraPosition, rayDir);\n}\n","name":"Image","description":"","type":"image"}]}