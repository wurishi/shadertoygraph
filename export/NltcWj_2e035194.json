{"ver":"0.1","info":{"id":"NltcWj","date":"1660567495","viewed":213,"name":"Extended Hexagonal Tiling SDF","username":"TheTurk","description":"Distance function for a hexagonal tiling with parameters for size, spacing and corner radius.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","grid","sdf","circle","hexagon","distance","honeycomb","hex","hexagonaltiling","packing","heatshield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hexagon(vec2 position, float radius, float halfSpacing, float cornerRadius) {\n    vec2 s = vec2(-2.0, sqrt(3.0) * 2.0) * (radius + halfSpacing);\n    position = (fract(position / s) - 0.5) * s;   \n    position = abs(position);\n    position -= 2.0 * min(dot(position - vec2(radius, 1.0 / sqrt(3.0) * radius) - vec2(0.5, sqrt(3.0) * 0.5) * halfSpacing, vec2(-0.5, -sqrt(3.0) * 0.5)), 0.0) * vec2(-0.5, -sqrt(3.0) * 0.5);\n    position = abs(position);\n    position -= min(position.x - sqrt(3.0) * position.y, 0.0) * vec2(0.5, -sqrt(3.0) * 0.5);\n    radius -= cornerRadius;\n    position -= vec2(radius, clamp(position.y, 1.0 / sqrt(3.0) * -radius, 1.0 / sqrt(3.0) * radius));\n    return length(position) * sign(position.x) - cornerRadius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float minRadius = 0.5;\n    float maxRadius = minRadius / (sqrt(3.0) * 0.5);\n    float radius = minRadius * (1.0 - (cos(iTime) + 1.0) * 0.5) + maxRadius * ((cos(iTime) + 1.0) * 0.5);\n    float halfSpacing = maxRadius - radius;\n    float cornerRadius = (cos(iTime) + 1.0) * 0.5 * radius;\n    float d = hexagon(position, radius, halfSpacing, cornerRadius);\n\n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n    color *= 1.0 - exp(-4.0 * abs(d)); \n\tcolor *= 0.8 + 0.2 * cos(120.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.002) * iResolution.y));\n    if (iMouse.z > 0.0) {\n        vec2 mousePosition = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        float d = hexagon(mousePosition, radius, halfSpacing, cornerRadius);\n        color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 3.0, abs(length(position - mousePosition) - abs(d)) * iResolution.y - 1.0));\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}