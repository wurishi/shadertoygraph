{"ver":"0.1","info":{"id":"XXlyzf","date":"1726504394","viewed":29,"name":"Plus 2","username":"AndreWiking","description":"1","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 5 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n#define PI 3.1415926538\n\n\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec3  clr  = vec3 ( 0, 0, 0 );\n\nconst vec3  outline2_clr  = vec3(2, 2, 0.4);\nconst vec3 outline1_clr  = vec3(0.1, 2.1, 0.1);\nconst vec3 capsule_clr  = vec3(2.1, 0.1, 0.1);\nconst vec3 ground_clr  = vec3(2.1, 0.3, 0.1);\n\nfloat smoothUnion ( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 getTexture(vec3 p, vec3 normal) {\n    return ((texture(iChannel0, p.xy).rgb * normal.z) + (texture(iChannel0, p.xz).rgb * normal.y) + (texture(iChannel0, p.yz).rgb * normal.x));\n}\n\nvec3 capsuleColor(vec3 p) {\n    return texture(iChannel0, normalize(p.xy)).rgb;\n    //return getTexture(p, vec3(0.7,0.7,0.7));\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nconst float plane_dist = 8.0;\n\n\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat plusSdf(in vec3 p, in mat3 m) {\n   \n   vec3 q = m * p;\n   float capsule_h = 1.0, capsule_r = 0.3;\n   \n   float capsule1 = sdVerticalCapsule(q * rotateZ(PI * 0.0), capsule_h, capsule_r);\n   float capsule2 = sdVerticalCapsule(q * rotateZ(PI * 0.5), capsule_h, capsule_r);\n   float capsule3 = sdVerticalCapsule(q * rotateZ(PI * 1.0), capsule_h, capsule_r);\n   float capsule4 = sdVerticalCapsule(q * rotateZ(PI * 1.5), capsule_h, capsule_r);\n   \n   return min(capsule1, min(capsule2, min(capsule3, capsule4)));\n}\n\nfloat groundSdf(in vec3 p, in mat3 m) {\n   \n   vec3 q = m * p;\n\n   return sdRoundedCylinder(q - vec3(0, 2.5, 0), 0.8, 0.2, 0.05);\n}\n\nvec3 generateNormal2( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = plusSdf(z + vec3(e, 0, 0), m);\n    float dx2 = plusSdf(z - vec3(e, 0, 0), m);\n    float dy1 = plusSdf(z + vec3(0, e, 0), m);\n    float dy2 = plusSdf(z - vec3(0, e, 0), m);\n    float dz1 = plusSdf(z + vec3(0, 0, e), m);\n    float dz2 = plusSdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvec3 generateNormal3( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = groundSdf(z + vec3(e, 0, 0), m);\n    float dx2 = groundSdf(z - vec3(e, 0, 0), m);\n    float dy1 = groundSdf(z + vec3(0, e, 0), m);\n    float dy2 = groundSdf(z - vec3(0, e, 0), m);\n    float dz1 = groundSdf(z + vec3(0, 0, e), m);\n    float dz2 = groundSdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvec4 plusTexture(in vec3 p, in mat3 m) {\n   vec3 q = m * p;\n   return boxmap(iChannel0, q, generateNormal2(q, eps, m), 1.0); \n}\n\nvec4 groundTexture(in vec3 p, in mat3 m) {\n   vec3 q = m * p;\n   return boxmap(iChannel2, q, generateNormal3(q, eps, m), 1.0); \n}\n\n\nfloat sdf ( in vec3 p, in mat3 m)\n{\n   vec3 q = m * p;\n   \n   float res_min = plusSdf(p, m);\n   \n   float outline1_rot_speed = 2.6, outline2_rot_speed = -2.0;\n   float outline_le = 0.2, outline_r1 = 1.6, outline_r2 = 0.1;\n   \n   vec3 q_off = q + vec3(0, 0, outline_r2 / 2.0);\n   vec3 q1 = rotateY(iTime * outline1_rot_speed) * q_off;\n   vec3 q2 = rotateX(iTime * outline2_rot_speed) * q_off;\n   \n   float outline1 = sdLink(q1, outline_le, outline_r1, outline_r2);\n\n   float outline2 = sdLink(q2, outline_le, outline_r1 * 1.3, outline_r2);\n      \n   float ground = groundSdf(p, m);\n   \n   clr = plusTexture(p, m).rgb;\n   \n   if (outline1 < res_min) {\n       res_min = outline1;\n       clr = outline1_clr;\n   }\n   if (outline2 < res_min) {\n       res_min = outline2;\n       clr = outline2_clr;\n   }\n   if (ground < res_min) {\n       res_min = ground;\n       clr = groundTexture(p, m).rgb;\n   }\n     \n   return smoothUnion(ground, res_min, 0.3);\n}\n\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 100.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nconst float roughness = 0.2;\nconst vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );\nconst float gamma = 2.2;\nconst float pi    = 3.1415926;\nconst float FDiel = 0.04;\t\t// Fresnel for dielectrics\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\t\t// saturate\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NdH2 = NdH * NdH;\n\tfloat d  = (m2 - 1.0) * NdH2 + 1.0;\n\t\n\treturn m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n\t\n    return 0.25 / (V * L);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\n\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v )\n{\n    vec3  h    = normalize ( l + v );\n\tfloat nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n    float metallness = 1.0;\n    vec3  base  = pow ( clr, vec3 ( gamma ) );\n    vec3  F0    = mix ( vec3(FDiel), clr, metallness );\n\t\n\t\t\t// compute Beckman\n   \tfloat d = D_beckmann ( roughness, nh );\n\n            // compute Fresnel\n    vec3 f = fresnel ( F0, nv );\n\t\n            // default G\n    float g = G_default ( nl, nh, nv, vh );\n\t\n\t\t\t// resulting color\n\tvec3  ct   = f*(0.25 * d * g / nv);\n\tvec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;\n\tfloat ks   = 0.5;\n\n\treturn vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0.0, 0.0, 0.0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n        color = cookTorrance ( p, n, l, v );\n\t}\n    else {\n        color = texture(iChannel1, dir);\n    }\n\n        // Output to screen\n    fragColor = color * 4.0;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.1 + 0.7*rayDir * cos(iTime * 0.8);\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}\n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926535\n#define PI2 (2.0 * PI)\n#define PIh (PI / 2.0)\n#define PI2t (PI2 / 3.0)\n\n// how many pillars are there \n#define PILLARS .0\n\n// light example, set to 0 for dark example\n#if 1\n#define SKY_C vec3(99.0 / 255.0, 161.0 / 255.0, 196.0 / 255.0)\n#define SKY_ALT_C vec3(160.0 / 255.0, 187.0 / 255.0, 245.0 / 255.0)\n#define HORIZON_C vec3(161.0 / 255.0, 164.0 / 255.0, 132.0 / 255.0)\n#define HORIZON_ALT_C vec3(130.0 / 255.0, 184.0 / 255.0, 194.0 / 255.0)\n#define GROUND_C vec3(160.0 / 255.0, 126.0 / 255.0, 104.0 / 255.0)\n#define GROUND_ALT_C vec3(162.0 / 255.0, 95.0 / 255.0, 53.0 / 255.0)\n\n#else\n\n// how many pillars are there \n#define PILLARS 3.0\n#define SKY_C vec3(25.0 / 255.0, 25.0 / 255.0, 25.0 / 255.0)\n#define SKY_ALT_C vec3(35.0 / 255.0, 35.0 / 255.0, 35.0 / 255.0)\n#define HORIZON_C vec3(10.0 / 255.0, 10.0 / 255.0, 12.0 / 255.0)\n#define HORIZON_ALT_C vec3(66.0 / 255.0, 60.0 / 255.0, 66.0 / 255.0)\n#define GROUND_C vec3(0.0 / 255.0, 0.0 / 255.0, 0.0 / 255.0)\n#define GROUND_ALT_C vec3(10.0 / 255.0, 9.0 / 255.0, 11.0 / 255.0)\n#endif\n\n\n// this is trivial euler rotation transformation\nmat3 Rotation(vec3 euler){\n    // Deg to Rad\n    euler *= PI / 180.0;\n\n    // Rotation around X - pitch\n    float c = cos(euler.x);\n    float s = sin(euler.x);\n    mat3 Rx = mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n\n    // Rotation around Y - yaw\n    c = cos(euler.y);\n    s = sin(euler.y);\n    mat3 Ry = mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n\n    // Rotation around Z - roll\n    c = cos(euler.z);\n    s = sin(euler.z);\n    mat3 Rz = mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n    \n    return Rz*Ry*Rx;\n}\n\n\n// polar coordinates from\n// lat: 0...PI2\n// lon: 0...PI\nvec2 polarCoords(in vec3 xyz) {\n    // it may be necessary in your projection to either:\n    // a) rotate the projection by 90deg OR\n    // b) swap xyz until the projection makes sense:\n    xyz = xyz.xzy;\n    float theta = atan(xyz.y, xyz.x);\n    float rho = sqrt(pow(xyz.x, 2.0) + pow(xyz.y, 2.0) + pow(xyz.z, 2.0));\n    return vec2((theta + PIh) * 2.0, acos(xyz.z / rho));\n}\n\n// Gradient noise from Jorge Jimenez's presentation:\n// http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat gradientNoise(in vec2 uv)\n{\n    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(uv, magic.xy)));\n}\n\n\n\n// goes from 0...1:\n// - is 1 when forward along x axes\n// - is 0 when forward along y axes\n// (with multiples by the amount of color changing pillars)\nfloat latitude(float polar) {\n    return (sin(polar * PILLARS / 2.0) + 1.0) / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    \n    // Camera\n    vec3 cameraPos = vec3(0,1,-1);\n    vec3 dir = normalize(vec3(cameraPos.x+uv.x, cameraPos.y+uv.y, 0) - cameraPos);\n    // Rotate camera\n    vec3 rotAngles = vec3(10.*sin(iTime), iTime*10., 0);\n    mat3 R = Rotation(vec3((iMouse.yx + vec2(-iResolution.x / 12.0, 0.5)) * vec2(-0.5, 1.0), 0.0) + rotAngles);\n    // you can remove the rotation and direction from your code\n    // if you're passing the camera direction (or have a global bound)\n    dir = R * dir;\n    \n    // polar coordinates in lat/lon\n    vec2 polar = polarCoords(dir.xyz);\n     \n\n    // goes from 0...1 from bottom to up\n    // if the sphere is upside down:\n    // - do 1.0 - polar.y / PI\n    float upAmount = 1.0 - polar.y / PI;\n    \n    // interpolation values to move from one phase to another\n    // steeper transitions with higher powers\n    float ground = pow(smoothstep(0.1, 0.3, upAmount), 2.0);\n    float horizon = pow(smoothstep(0.3, 0.5, upAmount), 12.0);\n    float sky = pow(smoothstep(0.45, 0.6, upAmount), 2.0);\n    float highSky = pow(smoothstep(0.6, 0.85, upAmount), 3.0);\n    \n    // mixing the alternative colors to go through their alt version\n    // set the PI2t multication to vary the color phases\n    vec3 skyColor = mix(SKY_C, SKY_ALT_C, latitude(polar.x + 0.0 * PI2t));\n    vec3 groundColor = mix(GROUND_C, GROUND_ALT_C, latitude(polar.x + 1.0 * PI2t));\n    vec3 horizonColor = mix(HORIZON_C, HORIZON_ALT_C, latitude(polar.x + 2.0 * PI2t));\n    \n    vec3 lowGroundToGround = mix(GROUND_C, groundColor, ground);\n    vec3 groundToHorizon =  mix(lowGroundToGround, horizonColor, horizon);\n    vec3 horizonToSky = mix(groundToHorizon, skyColor, sky);\n    vec3 skyToHighSky = mix(horizonToSky, SKY_C, highSky);\n    \n    // add a minute amount of noise to hide color banding\n    vec3 color =  skyToHighSky + (1.0/255.0) * gradientNoise(fragCoord) - (0.5/255.0);\n        \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}