{"ver":"0.1","info":{"id":"sdfyWX","date":"1642782978","viewed":238,"name":"Noisy Fibonacci golf ball","username":"stegu","description":"A golf ball, showcasing our new \"3-D simplex flow noise\" psrdnoise() and some other fun stuff.\nYou need to load a custom texture with a distance field to see the text on the ball.\nDetails are in the first post, and at the top of the shader code.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["noise","distancefield","displacement","text","antialiasing","raytrace","bump","surface","fibonacci","edt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// NOTE: For best results, iChannel0 wants a specially encoded\n// signed Euclidean distance map!\n// Cut and paste this JS code into your browser console:\n/*\n    gShaderToy.SetTexture(0, {\n    mSrc:'https://dl.dropboxusercontent.com/s/npjwh07c50daxjl/fiblogoaaedt16bit.png?dl=0',\n    mType:'texture', mID:1, mSampler:{\n        filter: 'linear', wrap: 'repeat', vflip:'false', srgb:'false', internal:'byte' }})\n*/\n// Thanks to AntoineC for that little gem! (https://www.shadertoy.com/view/lsGGDd)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // In any normal shader environment, these would have been uniform parameters\n    float FibN = 300.0;    // This can be any integer from 1 to 2^21.\n    float noisydirt = 1.0; // Set to 0.0 to render smudged single-color dirt instead\n\n    float time = iTime;\n\n    // Aspect-correct view coordinates, unit square for st plus some margin\n    float spheresize = min(iResolution.x, iResolution.y);\n    vec2 sphereoffset = 0.5*(vec2(iResolution.xy)-spheresize);\n    vec2 st = (fragCoord - sphereoffset)/spheresize;\n    \n    // In any normal shader environment, these view parameters would have been set\n    // persistently by well-defined and intuitive UI interactions instead of being\n    // half random. I think Shadertoy would benefit from a proper navigation widget.\n    \n    // Adjust scale by mouse drags (down-drag zooms out, up-drag zooms in)\n    float zoom = pow(0.98,iMouse.y-abs(iMouse.w));\n    // No controlled panning. Horizontal drags just nudges time back and forth.\n\ttime = time + 0.02*(iMouse.x-abs(iMouse.z));\n\tvec2 pan = vec2(0.0);\n    float rotateY = 0.4*sqrt(zoom)*sin(time);\n    float rotateX = 0.4*sqrt(zoom)*sin(time*0.5*(sqrt(5.0)-1.0));\n\n    // Create a fake sphere. In WebGL proper, this could have been actual\n    // geometry, either a polygon mesh or a potentially large set of\n    // billboarded sphere proxies.\n    // This shader is not extremely heavy on computations, and it would\n    // perform well as a surface shader in a real world application.\n    // It runs just fine on weak laptops and smartphones.\n    vec3 uvw;\n    uvw.xy = zoom*(2.0*st-1.0)-pan; // Zoom and (don't) pan to change view\n\tfloat r2 = dot(uvw.xy, uvw.xy);\n\tuvw.z = sqrt(1.0 - min(1.0, r2)); // Fake coords for the face of a sphere\n\t\n\t// Rotate the sphere around some. Interactivity is frustrating in Shadertoy.\n\tvec3 p = uvw;\n    mat3 rotX = mat3(1.0, 0.0, 0.0,\n        0.0, cos(rotateX), sin(rotateX),\n        0.0, -sin(rotateX), cos(rotateX));\n    mat3 rotY = mat3(cos(rotateY), 0.0, -sin(rotateY),\n        0.0, 1.0, 0.0,\n        sin(rotateY), 0.0, cos(rotateY));\n    // We only need one matrix to go from view to object space,\n    // and I could have just named it M and be done with it, but\n    // this is equivalent to the inverse of MV in \"proper\" WebGL.\n    mat3 MV3inv = rotX*rotY;\n    p = normalize(MV3inv * p);\n\t\n\t// Make the sphere outline antialiased, because we can\n\tfloat silhouette = 1.0 - aastep(1.0, r2);\n\n\tconst float bigR = 1.0; // length(p), the sphere radius, is always 1.0 here\n\t// For large N, the closest pits touch when r = 5/3/sqrt(N) and d = 1.0\n\t// Note: changing either \"r\" or \"pitdepth\" will change the pit radius, \"rc\".\n\tfloat r = 4.0/sqrt(FibN); // Radius of the indenting spheres\n    float pitdepth = 0.1; // Pit depth relative to r, max is 1.0 (hemispheres)\n\tfloat d = bigR + r*(1.0-pitdepth);\n\t// rc is the radius of the circle of intersection between the two spheres.\n\t// Thanks to Wolfram Mathworld for saving me the trouble of working this out.\n\t// To be perfectly honest, I *did* work it out, but I got it slightly wrong.\n\t// Which means I didn't *actually* work it out. (Why am I writing this?)\n\tfloat rc = 0.5/d * sqrt((-d+r-bigR)*(-d-r+bigR)*(-d+r+bigR)*(d+r+bigR));\n\n\t// Various variables. I like to declare them in advance. I also know FORTRAN.\n\tfloat k, t, sh, pit;\n\tvec3 p0, c, pc, q, qc;\n\tvec3 V, L, N;\n\n\tV = normalize(MV3inv * vec3(0.0,0.0,1.0)); // V in obj coords\n\tL = normalize(MV3inv * vec3(1.0,1.0,1.0)); // L in obj coords\n\n\tp0 = inverseSF(p, FibN, k); // Fun!\n\n\tpit = aasmoothstep(rc-0.05*r, rc, length(p-p0)); // AA on minification\n\tif(pit < 1.0) {\n\t\tc = p0 * d;\n\t\tpc = p - c;\n\t\tt = tracepit(pc, V, r); // Trace the pit from the hit on the large sphere\n\t\t// Ugly hack: \"no hit\" returns a traced t of 0.0, which means q remains at p\n\t\tq = mix(p + t*V, p, pit);\n\t\tN = mix(normalize(c-q), p, pit);\n\t\tqc = q - c;\n\t\tt = tracepit(qc, -L, r); // Shadow feeler from inside the convex pit\n\t\t// \"sh\" is 0.0 where a pit is shadowed by its own rim.\n\t\t// This (\"hit point has norm > bigR\" implies \"ray escapes above the rim\")\n\t\tsh = aastep(bigR, length(q - t*L)); // AA for the shadow edge\n\t}\n\telse {\n\t\tN = p; // Unit sphere, N=p\n\t\tq = p; // No displacement outside of the pits\n\t\tsh = 1.0; // The large sphere is convex -- no local self-shadowing\n\t}\n\n\t// dP is an inverse measure of the fragment size in relation to\n\t// the view-projected tangent plane (our object's surface).\n\t// A surface feature smaller than dP in object space will alias badly.\n\t// We use this for frequency clamping. (The shader uses q for texturing\n\t// rather than p, so let's play extra nice, but p would work fine here.)\n\tvec3 dPdx = dFdx(q);\n\tvec3 dPdy = dFdy(q);\n\tfloat dP = min(length(dPdx), length(dPdy)); // min() for less anisotropy\n\t\n\tvec3 basecolor = vec3(1.0); // White base\n\tvec3 diffusecolor = basecolor; // Will be used to mix the final result\n\t\n\t// Compute 2-D texture coordinates for the distance field for the text.\n\t// The signed distance texture has aspect ratio 2:1 (w:h).\n\tfloat texu = clamp(atan(q.x,q.z)*2.0/PI+0.5, 0.0, 1.0);\n\tfloat texv = clamp(0.6-q.y*1.0, 0.0, 1.0);\n\tvec2 texuv = vec2(texu, texv);\n\tfloat dist = -distfieldlookup16(iChannel0, texuv);  // Custom 16-bit data\n\tfloat logomask = aastep(0.0, dist); // Antialiased inside/outside threshold\n\tfloat logocolormask = texture(iChannel0, texuv).b; // B channel has a mask\n\n\tvec3 g, gsum; // To store and accumulate gradients from psrdnoise()\n\n\tfloat printnoise = psrdnoise(q*8.0, vec3(0.0), 0.0, gsum);\n\tif(dP < 1.0/75.0) { // AA: Avoid adding noise at sub-pixel scales\n\t\tprintnoise += 0.5*psrdnoise(q*50.0+gsum*0.5, vec3(0.0), 0.0, g);\n\t\tgsum += g*0.5;\n\t\tif(dP < 1.0/150.0) {\n\t\t\tprintnoise += 0.5*psrdnoise(q*100.0+gsum*0.5, vec3(0.0), 0.0, g);\n\t\t}\n\t}\n\n    // Make the scratches less common and less prominent in the pits\n\tfloat printcoverage = aastep(-0.5, printnoise*(0.5+0.5*pit));\n\n\t// If the custom texture was loaded, add the text\n    vec3 logocolor = vec3(0.0); // Black\n    vec3 mottocolor = vec3(0.0, 0.0, 0.7); // Blue\n    // An undefined texture has size 1x1, for some reason\n    if(textureSize(iChannel0, 0).x > 1) {\n        diffusecolor = mix(diffusecolor, logocolor,\n            logomask*(1.0-logocolormask)*printcoverage);\n        diffusecolor = mix(diffusecolor, mottocolor,\n            logomask*logocolormask*printcoverage);\n    }\n\n\t// Add the spiral logo (This aliases on minification - I should fix that.)\n\tvec3 spiralcenter = normalize(vec3(0.0,0.6,1.0));         // Constant expression\n\tvec3 spiraluvec = cross(vec3(0.0,0.0,1.0), spiralcenter); // Constant expression\n\tvec3 spiralvvec = cross(spiraluvec, spiralcenter);        // Constant expression\n\tfloat spiralu = dot(p-spiralcenter, spiraluvec);\n\tfloat spiralv = dot(p-spiralcenter, spiralvvec);\n\tfloat spiralr = 4.0/(0.2+spiralu*spiralu+spiralv*spiralv)*5.0; // Scale to [0,8]\n\tfloat spiraltheta = atan(spiralv,spiralu)/PI; // Scale to [-1,1]\n\tfloat spiralmask = aastep(0.25, abs(fract(spiralr+0.5*spiraltheta)-0.5));\n    // End in a circle around the rim (one inner edge, one outer edge)\n    spiralmask = max(spiralmask, aastep(0.185, length(p-spiralcenter)));\n\tspiralmask = min(spiralmask, 1.0-aastep(0.2, length(p-spiralcenter)));\n\n    vec3 spiralcolor = vec3(0.8,0.0,0.0);\n\tdiffusecolor = mix(diffusecolor, spiralcolor, spiralmask*printcoverage);\n\n    // If noisydirt==0, or in distant views, we leave \"dirtnoise\" at 0.0\n\tfloat dirtnoise = 0.0;\n\tfloat dirtmasknoise = 0.5 + psrdnoise(-q*2.0, vec3(0.0), -1.0, gsum);\n\tdirtmasknoise += 0.5 * psrdnoise(q*4.0+gsum*0.5, vec3(0.0), 0.0, g);\n\tgsum += g*0.5;\n\tdirtmasknoise += 0.25 * psrdnoise(q*8.0+gsum*0.5, vec3(0.0), 0.0, g);\n\tvec3 dirtcolor = vec3(0.4,0.2,0.0); // Reddish brown\n\n\tfloat blend1, blend2, blend3; // Frequency clamp blends for the fine-grained noise\n\tif(noisydirt != 0.0) {\n\t\tif(1.0/dP > 40.0) { // AA: exclude noise with features smaller than a fragment\n\t\t\tblend1 = smoothstep(40.0, 150.0, 1.0/dP);\n\t\t\tdirtnoise += blend1*0.5*psrdnoise(q*60.0, vec3(0.0), 0.0, gsum);\n\t\t\tif(1.0/dP > 150.0) {\n\t\t\t\tblend2 = smoothstep(150.0, 400.0, 1.0/dP);\n\t\t\t\tdirtnoise += blend2*0.25*psrdnoise(q*150.0+gsum*0.1,\n                    vec3(0.0), 0.0, g);\n\t\t\t\tgsum = gsum + g*0.5;\n\t\t\t\tif(1.0/dP > 200.0) {\n\t\t\t\t\tblend3 = smoothstep(300.0, 800.0, 1.0/dP);\n\t\t\t\t\tdirtnoise += blend3*0.125*psrdnoise(q*300.0+gsum*0.1,\n                        vec3(0.0), 0.0, g);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdirtcolor *= (1.2-dirtnoise); // Noise up the plain color\n\t\t}\n\t}\n    // Less dirt in the pits (contrary to real dirt, but this looks nice)\n\tfloat dirtmask = aastep(0.6, (dirtmasknoise+dirtnoise)*(0.5+0.5*pit));\n    float dirtalpha = 0.7+0.3*noisydirt; // Noisy dirt looks best opaque\n    diffusecolor = mix(diffusecolor, dirtcolor, dirtmask*dirtalpha);\n\n\t// Add some bump to the otherwise very bland and perfect surface normal.\n    // Note that we don't do any displacement, so we don't need the noise\n    // value, only the gradient. I don't like C-style implicit discarding\n    // of a return value, so let's be nice and assign it to a dummy variable.\n    // (It improves readbility, and the compiler will optimize it away.)\n\tfloat dummy = psrdnoise(q*60.0, vec3(0.0), 0.0, g);\n\tvec3 g_ = g - dot(g,N)*N;\n\tdummy = psrdnoise(q*120.0+g*0.1, vec3(0.0), 0.0, g);\n\tg_ += g - dot(g,N)*N; // Yes, this is proper bump mapping in object space.\n\tN -= 0.01*g_;         // Everything is wonderfully simple when you have a 3-D\n\tnormalize(N);         // bump/displacement function where the gradient is known.\n\n\t// A simple Phong lighting model with one directional light\n\tvec3 Id = vec3(1.0,1.0,0.9) * max(0.0,dot(N,L)) * sh; // \"sh\" is pit self-shadow\n\t// \"Ambient\" has a weak directional component to keep the pits visible\n\tvec3 Ia = vec3(0.8,0.8,1.0) * (0.7 + 0.3*max(0.0, dot(N,-L)));\n\tvec3 R = reflect(-L,N);\n\tfloat dotRV = max(0.0,dot(R,V)) * sh; // Specular due to L, hence \"sh\" applies\n\tvec3 specularcolor = vec3(1.0);\n\tvec3 Is = 0.7*vec3(1.0,1.0,0.8) * pow(dotRV, 20.0) * (1.0-dirtmask);\n\tvec3 mixcolor = diffusecolor*(0.7*Id + 0.3*Ia) + specularcolor*Is;\n\n\tvec3 bgcolor = vec3(0.0,0.0,0.2); // Dark blue to match \"ambient\" tint\n\tfragColor = vec4(mix(bgcolor, mixcolor, silhouette), 1.0); // Antialias the outline\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\n\nvec4 permute(vec4 i) {\n     vec4 im = mod(i, 289.0);\n     return mod(((im*34.0)+10.0)*im, 289.0);\n}\n\nfloat psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)\n{\n  const mat3 M = mat3(0.0, 1.0, 1.0, 1.0, 0.0, 1.0,  1.0, 1.0, 0.0);\n  const mat3 Mi = mat3(-0.5, 0.5, 0.5, 0.5,-0.5, 0.5, 0.5, 0.5,-0.5);\n  vec3 uvw = M * x;\n  vec3 i0 = floor(uvw), f0 = fract(uvw);\n  vec3 g_ = step(f0.xyx, f0.yzz), l_ = 1.0 - g_;\n  vec3 g = vec3(l_.z, g_.xy), l = vec3(l_.xy, g_.z);\n  vec3 o1 = min( g, l ), o2 = max( g, l );\n  vec3 i1 = i0 + o1, i2 = i0 + o2, i3 = i0 + vec3(1.0);\n  vec3 v0 = Mi * i0, v1 = Mi * i1, v2 = Mi * i2, v3 = Mi * i3;\n  vec3 x0 = x - v0, x1 = x - v1, x2 = x - v2, x3 = x - v3;\n  if(any(greaterThan(period, vec3(0.0)))) {\n    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);\n    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);\n    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);\n\tif(period.x > 0.0) vx = mod(vx, period.x);\n\tif(period.y > 0.0) vy = mod(vy, period.y);\n\tif(period.z > 0.0) vz = mod(vz, period.z);\n\ti0 = floor(M * vec3(vx.x, vy.x, vz.x) + 0.5);\n\ti1 = floor(M * vec3(vx.y, vy.y, vz.y) + 0.5);\n\ti2 = floor(M * vec3(vx.z, vy.z, vz.z) + 0.5);\n\ti3 = floor(M * vec3(vx.w, vy.w, vz.w) + 0.5);\n  }\n  vec4 hash = permute( permute( permute( \n              vec4(i0.z, i1.z, i2.z, i3.z ))\n            + vec4(i0.y, i1.y, i2.y, i3.y ))\n            + vec4(i0.x, i1.x, i2.x, i3.x ));\n  vec4 theta = hash * 3.883222077;\n  vec4 sz = hash * -0.006920415 + 0.996539792;\n  vec4 psi = hash * 0.108705628;\n  vec4 Ct = cos(theta), St = sin(theta);\n  vec4 sz_prime = sqrt( 1.0 - sz*sz );\n  vec4 gx, gy, gz;\n  if(alpha != 0.0) {\n    vec4 px = Ct * sz_prime, py = St * sz_prime, pz = sz;\n    vec4 Sp = sin(psi), Cp = cos(psi), Ctp = St*Sp - Ct*Cp;\n    vec4 qx = mix( Ctp*St, Sp, sz), qy = mix(-Ctp*Ct, Cp, sz);\n    vec4 qz = -(py*Cp + px*Sp);\n    vec4 Sa = vec4(sin(alpha)), Ca = vec4(cos(alpha));\n    gx = Ca*px + Sa*qx; gy = Ca*py + Sa*qy; gz = Ca*pz + Sa*qz;\n  }\n  else {\n    gx = Ct * sz_prime; gy = St * sz_prime; gz = sz;  \n  }\n  vec3 g0 = vec3(gx.x, gy.x, gz.x), g1 = vec3(gx.y, gy.y, gz.y);\n  vec3 g2 = vec3(gx.z, gy.z, gz.z), g3 = vec3(gx.w, gy.w, gz.w);\n  vec4 w = 0.5-vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  w = max(w, 0.0); vec4 w2 = w * w, w3 = w2 * w;\n  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));\n  float n = dot(w3, gdotx);\n  vec4 dw = -6.0 * w2 * gdotx;\n  vec3 dn0 = w3.x * g0 + dw.x * x0;\n  vec3 dn1 = w3.y * g1 + dw.y * x1;\n  vec3 dn2 = w3.z * g2 + dw.z * x2;\n  vec3 dn3 = w3.w * g3 + dw.w * x3;\n  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);\n  return 39.5 * n;\n}\n\n#define m1 0.618033988749895\n\nfloat fracmodphi(float k) {\n\t// (Pray that this maps to an FMA instruction)\n\treturn k * m1 - floor(k * m1);\n}\n\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n\n// Find nearest neighbor on an N-point Fibonacci sphere.\n// Algorithm from the article \"Spherical Fibonacci Mapping\"\n// by Keinert et al, ACM Trans. on Graphics 34 (2015), 6, 193.\n// Ported from HLSL to GLSL by Stefan Gustavson 2021.\n//\nvec3 inverseSF(vec3 p, float N, out float j) {\n\tvec3 r;\n\tfloat phi = min(atan(p.y, p.x), PI); // min() to dodge NaN\n\tfloat cosTheta = p.z;\n\tfloat k = max(2.0, floor(\n\t\tlog(N * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))\n\t\t/ log(PHI*PHI)));\n\t// F0, F1 are actually faster to compute with pow()\n\t// than by using an array of precomputed values.\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 =  floor(Fk * PHI + 0.5);\n\tmat2 B = mat2(\n\t\t2.0*PI*fracmodphi(F0+1.0) - 2.0*PI*(PHI-1.0), -2.0*F0/N, \n\t\t2.0*PI*fracmodphi(F1+1.0) - 2.0*PI*(PHI-1.0), -2.0*F1/N);\n\tmat2 invB = inverse(B);\n\tvec2 c = floor(invB * vec2(phi, cosTheta - (1.0-1.0/N)));\n\tfloat dsqmin = 10.0; // No actual distance is larger than 4.0\n\tfor (float s = 0.0; s < 4.0; s++) {\n\t\tfloat cosTheta = dot(vec2(B[0][1],B[1][1]),\n\t\t\tvec2(mod(s, 2.0), floor(s*0.5)) + c) + (1.0-1.0/N);\n\t\tcosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n\t\tfloat i = floor(N*0.5 - cosTheta*N*0.5);\n\t\tfloat phi = 2.0*PI*fracmodphi(i);\n\t\tcosTheta = 1.0 - (2.0*i + 1.0)*(1.0/N);\n\t\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\tvec3 q = vec3(cos(phi)*sinTheta, sin(phi)*sinTheta,\tcosTheta);\n\t\tfloat dsq = dot(p-q, p-q); // Most numerically sound measure\n\t\tif (dsq < dsqmin) {\n\t\t\tdsqmin = dsq;\n\t\t\tj = i;\n\t\t\tr = q;\n\t\t}\n\t}\n\t// The return value is the closest point in the set.\n\t// The point index j is returned in an \"out\" parameter.\n\t// Another useful \"out\" parameter would be \"dsqmin\".\n\treturn r;\n}\n\n// A conveniently anti-aliased step(), in the style of\n// filterstep() in RSL and its namesake aastep() in OSL.\nfloat aastep(float threshold, float value) {\n\tfloat afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n\treturn smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// A smoothstep() that blends to an aastep() under minification\nfloat aasmoothstep(float t1, float t2, float v) {\n\tfloat aw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n\tfloat sw = max(0.5*(t2-t1), aw);\n\tfloat st = 0.5*(t1+t2);\n\treturn smoothstep(st-sw, st+sw, v);\n}\n\n// Ray trace for a hit with the *inside* of a sphere around the origin.\n// pc is the starting point for the ray (relative to the sphere centre),\n// V is the view vector pointing in the opposite direction of the ray,\n// and r is the radius of the sphere. The hit point q is computed from\n// the return value t as q = pc + t*V\nfloat tracepit(vec3 pc, vec3 V, float r) {\n\tfloat p_2 = dot(pc, V);\n\tfloat q = dot(pc, pc) - r*r;\n\tfloat arg = p_2*p_2 - q;\n\tif(arg >= 0.0) return -p_2 - sqrt(arg); // Pick farthest root (smallest t)\n\treturn 0.0; // We would want NaN or Inf here, but GLSL is bad with those...\n}\n\n// Retrieve 16-bit encoded distance from RG channels, with the added bonus\n// of circumventing the native reduced-precision texture interpolation.\nfloat distfieldlookup16(sampler2D tex, vec2 st) {\n\tvec2 dims = vec2(textureSize(tex, 0)); // Cast to floats for next line\n\tvec2 uv = st * dims;\n\tuv = clamp(uv, vec2(0.0), dims-2.0); // Fake \"clamp to edge\"\n\tvec2 uv00 = floor(uv + vec2(0.5)); // Lower left corner of lower left texel\n\tvec2 uvlerp = uv - uv00 + vec2(0.5); // Texel-local lerp blends [0,1]\n\tvec2 tx00, tx01, tx10, tx11;\n\tivec2 ij = ivec2(uv00);\n\ttx00 = texelFetch(tex, ij, 0).rg;\n\ttx01 = texelFetchOffset(tex, ij, 0, ivec2(0.0, 1.0)).rg;\n\ttx10 = texelFetchOffset(tex, ij, 0, ivec2(1.0, 0.0)).rg;\n\ttx11 = texelFetchOffset(tex, ij, 0, ivec2(1.0, 1.0)).rg;\n\t// This \"zero level\" at 18.0 is unique for the demo image,\n\t// where the largest features happened to be 36 pixels across.\n\tvec4 d = vec4(tx00.g, tx01.g, tx10.g, tx11.g)*255.0 - 18.0\n\t\t+ vec4(tx00.r, tx01.r, tx10.r, tx11.r)*(255.0/256.0);\n\tvec2 dd = mix(vec2(d.x,d.z), vec2(d.y,d.w), uvlerp.y); \n\treturn mix(dd.x, dd.y, uvlerp.x);\n}\n","name":"Common","description":"","type":"common"}]}