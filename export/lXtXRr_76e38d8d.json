{"ver":"0.1","info":{"id":"lXtXRr","date":"1719599799","viewed":46,"name":"hash benchmark","username":"nilrem","description":"Benchmarking hash and noise functions\nFor use with https://github.com/patuwwy/ShaderToy-Chrome-Plugin\nNOTE: chromium/chrome is much faster than firefox, especially on linux\nNOTE: ensure fixed GPU clock speeds","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hash","prng","benchmark"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// NOTE: This is all about \"just good enough\" hash functions optimized for speed,\n//       intended for fractal-noise/fbm and screen space-type stuff, NOT for general use!\n//\n//       Passing any serious https://en.wikipedia.org/wiki/Randomness_test is out-of-scope ;-)\n//\n// Challenges invited! :)\n// I'm offering PayPal bounties of 100€, 50€ and 25€ for the first 3 shadertoy entries in that order, iff they are\n//  - running at least 6% faster on any RTX 2xxx+ in direct comparison, as described here (2d val noise opt)\n//  - look like noise when drawn as a 1920x1080+ quad, without \"visually disturbing artifacts\"\n//  - are linked here in a comment\n//\n// NOTE: Fused instructions available on certain ISAs (ADD3, SHIFT+XOR, etc.), ILP, dependencies, latencies, throughput, register pressure (occupancy),\n//       and surrounding code (e.g. noise funcs) change the bottom line significantly.\n//       GPUs have taken on some characteristics of superscalar out-of-order CPUs,\n//         even though they're in-order SIMD (dual-issue ALUs, SFUs, \"free\" SMT).\n//       Compiler heuristics on top => profiling & disassembly required for sanity.\n//\n// Useful reference for NV ops: https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions\n//\n// Useful reference for LCGs: https://www.researchgate.net/publication/2683298_A_Collection_of_Selected_Pseudorandom_Number_Generators_With_Linear_Structures\n//\n\n//-------------------------------------------------------\n// benchmark settings\n//-------------------------------------------------------\n// Select type\n#define benchmark benchmark_hash_noise_2d\n//#define benchmark benchmark_hash_bare\n\n// Select hash function\n//#define hash1 hash1_opt_ih_1\n#define hash1 hash1_opt_ih_2\n//#define hash1 hash1_fabrice_ih3\n//#define hash1 hash1_fabrice_ih3_rewrite2\n//#define hash1 hash1_opt_hybrid_1\n//#define hash1 hash1_iq_ih3\n//#define hash1 hash_iq_elias\n\n// Select noise function\n#define noise1 noise1_value_iq_opt\n//#define noise1 noise1_value_iq\n//#define noise1 noise1_texturelod\n\n// Select total hash function calls per pixel\nconst int HASH_ITERS = 5000;\n\n//-------------------------------------------------------\n// visualization (disable for benchmarking)\n//-------------------------------------------------------\n// For totally scientific eyeballing\n//#define VISUALIZE_SCREENSPACE_FRAGCOORD\n//#define VISUALIZE_SCREENSPACE_INTEGER\n#define VISUALIZE_SCREENSPACE_UV\n\n//--------------------------------------\n// benchmark results\n//--------------------------------------\n// Benchmarked on debian 12.5, chromium 126, underclocked 3080 @1425Mhz, 5900x@3700Mhz@1CCX (6of12 cores)\n//\n// Fixed, stable, verified clocks on GPU & CPU (disable all boosts, NV control panel -> \"prefer max performance\", single AMD CCX)\n//\n// Resolution 1337x752, HASH_ITERS = 5000, inner_iters = 4, INTERPOLANT = 0 (cubic)\n//\n//                            |              ms/frame @1337x752          |\n// hash function              |  bare  | 2d val noise | 2d val noise opt |\n//                            |        |              |         | \"opt\"  |\n//----------------------------|--------|--------------|---------|--------|\n// hash1_hoskin               |  14.3  |    15.0      |         | 12.4   |\n// hash1_iq_ih3               |   7.2  |     7.6      |         |  7.7   |\n// hash1_fabrice_ih3          |   6.3  |     6.9      |   6.8   |  6.8   |\n// hash_iq_elias              |   6.8  |     7.3 !    |         |  7.4   |\n// hash_iq_elias_opt          |   5.9  |     7.5      |         |  7.5   |\n//                            |        |              |         |        |\n// hash1_fabrice_ih3_rewrite2 |        |     6.7      |         |  6.8   |\n//                            |        |              |         |        |\n// hash1_opt_float_1          |  10.0  |    10.0      |   8.8   |  8.7   |\n// hash1_opt_hybrid_1         |   5.0  |     6.4      |   6.1   |  5.7   |\n// hash1_opt_ih_1             |        |              |         |  4.8   |\n// hash1_opt_ih_2             |        |              |         |  4.65  | <- added 2024.06.30 11:34 (by me)\n//                            |        |              |         |        |\n// textureLod 8bit uint       |        |     3.2      |   N/A   |  N/A   |\n//\n//\n// ! : long compile time  (loop unrolling)\n\n\n//-------------------------------------------------------\n// 3rd party hash functions\n//-------------------------------------------------------\n\n// dave hoskin's classic\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nfloat hash1_hoskin(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19); // originally 33.33\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// iq's integer hash III\n// https://www.shadertoy.com/view/4tXyWN\nfloat hash1_iq_ih3( vec2 xf )\n{\n    // cast - original has uvec2 input\n    uvec2 x = uvec2(xf);                                                 // 2 cast\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );                     // 2 int mul, 2 shift, 2 xor\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );                     // 1 int mul, 1 shift, 1 xor\n    return float(n) * (1.0/float(0xffffffffU));                          // 1 cast, 1 float mul\n}\n\n// FabriceNeyret's fork of iq's integer hash III\n// https://www.shadertoy.com/view/fsKBzw\nfloat hash1_fabrice_ih3( vec2 f )\n{   uvec2 x = floatBitsToUint(f),                                          // 2 reinterpret cast (free)\n          q =     1103515245U * (x>>1U ^ x.yx   );                         // 2 int mul, 2 shift, 2 xor\n    return float( 1103515245U * (q.x   ^ q.y>>3U) ) / float(0xffffffffU);  // 1 int mul, 1 shift, 1 xor, 1 cast, 1 float mul  (div by const -> mul by const)\n}\n// Rewritten for clarity\nfloat hash1_fabrice_ih3_rewrite( vec2 f )\n{   uvec2 x = floatBitsToUint(f);\n    uvec2 q = 1103515245U * (x>>1U ^ x.yx   );\n    uint  n = 1103515245U * (q.x   ^ q.y>>3U);\n    return float(n) / float(0xffffffffU);\n}\n// Rewritten again\nfloat hash1_fabrice_ih3_rewrite2( vec2 f )\n{   uvec2 x = floatBitsToUint(f);\n    uvec2 y = uvec2(x.x>>1U ^ x.y, x.y>>1U ^ x.x);   // somewhat faster than the equivalent  x>>1U ^ x.yx\n    uvec2 p = 1103515245U * y;\n    uint  q = (p.x ^ p.y>>3U);\n    uint  n = 1103515245U * q;\n    return float(n) / float(0xffffffffU);\n}\n\n// iq's adaptation of Huge Elias' int hash\n// https://www.shadertoy.com/view/lsf3WH\n// NOTE: constants need tuning, lots of artifacts here\nfloat hash_iq_elias( in vec2 pf )\n{\n    ivec2 p = ivec2(pf);\n    // 2D -> 1D\n    int n = p.x*3 + p.y*113;\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & 0x0fffffff)/float(0x0fffffff);\n}\n\n// same as hash_iq_elias, converted some int muls to float muls\nfloat hash_iq_elias_opt( in vec2 p )\n{\n    int n = int( p.x*3. + p.y*113. );\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & 0x0fffffff)/float(0x0fffffff);\n}\n\n// don't remember from where, somewhere on shadertoy, high quality but slow\nfloat hash_lowbias32(in vec2 f)\n{\n    uvec2 xf = floatBitsToUint(f);\n    uint x = xf.x ^ xf.y>>3U;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return float(x) / float(0xffffffffU);\n    //return float( x & 0x0fffffffu)/float(0x0fffffffu);\n}\n\n//-------------------------------------------------------\n// optimized versions\n//-------------------------------------------------------\n\n// Optimized float version 1\nfloat hash1_opt_float_1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );                                      // 2 fract, 4 float mul\n    return fract( p.x*p.y*(p.x+p.y) );                                   // 1 fract, 2 float mul, 1 add   (no mad)\n}\n\n// Optimized hybrid version 1\n// NOTE: avoid int32 muls on AMD (1/4 rate), full-rate on NV RTX 2xxx+/V100+\n// TODO: optimize constants\nfloat hash1_opt_hybrid_1( vec2 p )\n{\n    p = p * vec2( 70.3183091, 71.5817437 );                              // 2 float mul\n    uvec2 q = floatBitsToUint( p );                                      // 2 reinterpret cast (free)\n    return fract( float(q.x ^ q.y) * (1.0/747.491) + 15361.3 );          // 1 xor, 1 cast, 1 fmad, 1 fract\n}\n\n//\n// NOTE: Constants for LCG-type integer hashes taken from: https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use\n//\n// Optimized int version 1\n//\n// Caveat: This is NOT a high quality hash function for general use!\n//         Works nicely for fractal noise (FBM) and screen-space noise though\n//\nfloat hash1_opt_ih_1( vec2 f )\n{\n    uvec2 x = floatBitsToUint(f);                                        // 2 reinterpret cast (free)\n    uvec2 p = 1103515245U * x;                                           // 2 int mul\n    uint  q = (p.x ^ p.y>>3U);                                           // 1 shift, 1 xor\n    uint  n = 1103515245U * q;                                           // 1 int mul\n    return float(n) * (1.0/float(0xffffffffU));                          // 1 cast, 1 float mul\n}\n// Optimized int version 2\n//\n// 1 less shift op than version 1\n//\n// Seems to work well for both large and small inputs\n//\nfloat hash1_opt_ih_2( vec2 f )\n{\n    uvec2 x = floatBitsToUint(f);                        \n    uvec2 p = uvec2(1103515245U*x.x, 134775813U*x.y);    // using different multipliers for x and y\n    uint  q = p.x ^ p.y;                                 // allows dropping the shift here\n    uint  n = 1103515245U * q;                           \n    return float(n) * (1.0/float(0xffffffffU));          \n}\n\n//-------------------------------------------------------\n// noise functions\n//-------------------------------------------------------\n// 2 -> 1\nfloat noise1_value_slower( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\n\n// 0: cubic\n// 1: quintic\n#define INTERPOLANT 0\nfloat noise1_value_iq( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    #if INTERPOLANT==1\n    // quintic interpolant\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    #else\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n    #endif\n\n    return mix( mix( hash1( i + vec2(0,0) ), \n                     hash1( i + vec2(1,0) ), u.x),\n                mix( hash1( i + vec2(0,1) ), \n                     hash1( i + vec2(1,1) ), u.x), u.y);\n}\n\n// optimized version\nfloat noise1_value_iq_opt( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    #if INTERPOLANT==1\n    // quintic interpolant\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    #else\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n    #endif\n\n    float ix1 = i.x+1.;\n    float iy1 = i.y+1.;\n\n    // NV compiler doesn't seem to\n    //  - optimize away float adds with 0. as an operand\n    //  - do sufficient CSE (common subexpression elimination), thus recalculates some results\n    // => ~6% faster end2end, depending on the hash function used\n    return mix( mix( hash1( vec2(i.x, i.y ) ), \n                     hash1( vec2(ix1, i.y ) ), u.x),\n                mix( hash1( vec2(i.x, iy1 ) ), \n                     hash1( vec2(ix1, iy1 ) ), u.x), u.y);\n}\n\nfloat noise1_texturelod( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p + f*f*(3.0-2.0*f);\n\treturn textureLod( iChannel0, (uv+118.4)/256.0, 1.0 ).x;\n}\n\n//-------------------------------------------------------\n// benchmark functions\n//-------------------------------------------------------\n// To prevent compilers from optimizing away our stuff:\n// For each call:\n//   - use unique argument values, unknown at compile time\n//   - use the results somehow\n\nfloat benchmark_hash_bare(vec2 fragCoord)\n{\n    const int   inner_iters = 4;\n    const float outer_iters = float(HASH_ITERS/inner_iters)+0.5;\n    \n    float r = 0.0;\n    \n    //for( float f = 0.0001; f<outer_iters; f+=1.00001 )\n    \n    // int loop variable based on uniform ~2% faster\n    int i_outer_iters = HASH_ITERS/inner_iters;\n    for( int f = int(iResolution.x)/1000000; f<i_outer_iters; f++ )\n    {\n        for( int i = 0; i < inner_iters; i++ )\n        {\n            r += hash1( fragCoord + float(f)*37. + float(i) );\n        }\n    }\n    return r / outer_iters;\n}\n\nfloat benchmark_hash_noise_2d(vec2 fragCoord)\n{\n    const int   inner_iters = 4;   // 4 hash calls per 2d cartesian grid (non-simplex) value noise call\n    const float outer_iters = float(HASH_ITERS/inner_iters)+0.5;\n    \n    float r = 0.0;\n    \n    int i_outer_iters = HASH_ITERS/inner_iters;\n    for( int i = ZERO; i<i_outer_iters; i++ )\n    {\n        r += noise1(fragCoord + float(i) * 37.);\n    }\n    \n    //for( float f = 0.0001; f<outer_iters; f+=1.00001 )\n    //{\n    //    r += noise1(fragCoord + f*37.);\n    //    //r += noise1(fragCoord + f + 1.1);\n    //    //r += noise1(fragCoord + f + 1.1);\n    //    //r += noise1(fragCoord + f + 2.1);\n    //    //r += noise1(fragCoord + f + 3.1);\n    //    \n    //    // noise1_texturelod:\n    //    // 1x:  3.25ms\n    //    // 2x:  6.5ms\n    //    // 3x:  9.7ms\n    //    // 4x: 12.7ms\n    //}\n    \n    return r / outer_iters;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sum = benchmark(fragCoord - iResolution.xy/2.);  // appears to trigger some compiler optimization on NV\n    \n    // Use the results somehow\n    \n    #ifdef VISUALIZE_SCREENSPACE_FRAGCOORD\n    // Display the hash function for eyeballing (large input values)\n    vec2 seed = fragCoord + float(iTime)*7.1;\n    vec3 col  = vec3( hash1(seed) );\n    \n    #elif defined(VISUALIZE_SCREENSPACE_INTEGER)\n    // Display the hash function for eyeballing (large \"integer\" input values)\n    vec2 seed = floor(fragCoord + float(iTime)*11137.1);\n    vec3 col  = vec3( hash1(seed) );\n    \n    #elif defined(VISUALIZE_SCREENSPACE_UV)\n    // Display the hash function for eyeballing (small input values)\n    vec2 uv   = fragCoord / iResolution.xy;\n    vec2 seed = uv - 0.5 + fract( float(iTime) );\n    vec3 col  = vec3( hash1(seed) );\n    \n    #else\n    // Benchmark without eyeballing, display sum\n    vec3 col  = vec3(sum);\n    #endif\n\n    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// zero unknown at compile time\n// prevents compilers from inlining loops when used to init loop variable\n// trick by klems\n#define ZERO (min(iFrame,0))\n","name":"Common","description":"","type":"common"}]}