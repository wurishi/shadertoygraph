{"ver":"0.1","info":{"id":"7s3SWf","date":"1634054537","viewed":78,"name":"The Sierpinski Triangle","username":"Andrew3086","description":"Using shaders to create such fractals is stupid and inefficient. \nIn this case, it's just an experiment. I was wondering if I could create a Sierpinski triangle using shader logic. \nAnd, in fact, i have done it.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sierpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float m = 350.0;\n    vec2 uv = fragCoord / iResolution.xy * m;\n    float col = 0.0;\n    \n    \n    vec2 A = vec2(m * 0.23, 1.0 * m * 0.1);\n    vec2 B = vec2(m * 0.77, 1.0 * m * 0.1);\n    vec2 C = vec2(m / 2.0, m * 0.9);\n    vec2 tmpPoint = (A + B) / 2.0;\n    \n    float p = 0.0;\n    float count = 0.0;\n    vec4 tmp;\n    \n    for (count = 0.0; count < 15000.0; count++) {\n        count++;\n        tmp = texture(iChannel0, vec2(mod(count, 256.0) / 256.0, round(count / 256.0) / 256.0));\n        p = mod(tmp.x * 256.0, 3.0);\n        if (p < 1.0) tmpPoint = (tmpPoint + A) / 2.0;\n        else if (p < 2.0) tmpPoint = (tmpPoint + B) / 2.0;\n        else if (p < 3.0) tmpPoint = (tmpPoint + C) / 2.0;\n        \n        if (mod(uv.x, m) < tmpPoint.x && mod(uv.x, m) > (tmpPoint.x - 1.0) &&\n            mod(uv.y, m) < tmpPoint.y && mod(uv.y, m) > (tmpPoint.y - 1.0)) col = 1.0;\n    }\n    \n    fragColor = vec4(col, col, col, 1.0);\n}","name":"Image","description":"","type":"image"}]}