{"ver":"0.1","info":{"id":"wdc3WX","date":"1569364358","viewed":121,"name":"Minus zero 'glitch' in compiler","username":"dezgeg","description":"Minus zero + compiler optimizations = not good","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["drivercompileroptimization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Here's a \"fun\" but extremely minor case I found where the result depends\n// on whether the shader compiler (I tried Intel/Mesa on Linux) optimizes\n// some expression to a compile time constant or not. \n\n// If the #define below is uncommented, you should get four colors on screen.\n// If the #define is commented, you just get a black screen.\n\n// In the latter case, the compiler presumably replaces 'uv * 0.0' with zero\n// constant at compile time, even though negative zero can happen as well.\n\n#define FORCE_COMPUTE_AT_RUNTIME\n\nfloat weird(float x) {\n    return float(floatBitsToUint(x) >> 24) / 255.;   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n#ifdef FORCE_COMPUTE_AT_RUNTIME\n    vec2 p = uv * min(0.0, iResolution.x);\n#else\n    vec2 p = uv * 0.0;\n#endif\n\n    fragColor = vec4(weird(p.x), weird(p.y), 0., 0.);\n}","name":"Image","description":"","type":"image"}]}