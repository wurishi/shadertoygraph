{"ver":"0.1","info":{"id":"MdlyDB","date":"1489774135","viewed":143,"name":"Multi Material","username":"aym0","description":"multi material study\ninspired by https://github.com/petershirley/raytracinginoneweekend","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265358979323;\nvec2 vTexCoord;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat srand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat rand(float seed){\n    vec2 co = vec2(seed, seed + 100.0);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat srand(float seed){\n    vec2 co = vec2(seed, seed + 100.0);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\nvec3 getRandomVector(vec2 co){\n    \n    vec3 dir = vec3(srand(co + vec2(0.3, -0.3)), srand(co + vec2(-0.2, -0.1)), srand(co + vec2(-0.1, -0.4)));\n    float r = rand(co);\n\n    return r * normalize(dir);\n    \n}\n\nvec2 getRandomVector2(vec2 co) {\n    vec2 dir = vec2(srand(co + vec2(0.3, -0.3)), srand(co + vec2(-0.2, -0.1)));\n    float r = rand(co);\n    \n    return r * normalize(dir);\n}\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction looking at\n};\n\nstruct Sphere {\n    // geometry\n    float r; // radius\n    vec3 c;  // center\n    \n    // material\n    int mat; // 0: lambert, 1: metal\n    vec3 albedo; // for attenuation\n    float fuzz;  // for metal reflection\n    float ref_idx; // for dielectric refraction ratio\n};\n\nstruct Intersection {\n    bool hit;\n    vec3 p;\n    vec3 n;\n    vec3 color;\n    float t;\n    Sphere rec;\n};\n\nvoid scatterLambert(inout Ray R, in Intersection I){\n    R.o = I.p;\n    R.d = I.n + getRandomVector(vTexCoord + R.d.yx * 10.0);\n}\n\nvoid scatterMetal(inout Ray R, in Intersection I) {\n    R.o = I.p;\n    R.d = reflect(R.d, I.n) + I.rec.fuzz * getRandomVector(vTexCoord + R.d.yx * 10.0);;\n}\n\nfloat schlick(float cosine, float ref_idx) {\n    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\nvoid scatterDielectric(inout Ray R, in Intersection I) {\n    vec3 outward;\n    vec3 reflected = reflect(R.d, I.n);\n    float ni;\n    float cosine;\n    float reflect_prob;\n    \n    if (dot(R.d, I.n) > 0.0) {\n        outward = - I.n;\n        ni = I.rec.ref_idx;\n        cosine = dot(R.d, I.n) / length(R.d);\n        cosine = sqrt(1.0 - I.rec.ref_idx * I.rec.ref_idx * (1.0 - cosine * cosine));\n    } else {\n        outward = I.n;\n        ni = 1.0 / I.rec.ref_idx;\n        cosine = - dot(R.d, I.n) / length(R.d);\n    }\n    \n    vec3 refracted = refract(R.d, outward, ni);\n    \n    if (length(refracted) > 0.0) {\n        reflect_prob = schlick(cosine, I.rec.ref_idx);\n    } else {\n        reflect_prob = 1.0;\n    }\n    \n    R.o = I.p;\n    if (rand(vTexCoord + R.d.yx * 10.0) < reflect_prob) {\n        R.d = reflected;\n    } else {\n        R.d = refracted;\n    }\n}\n\nvoid initSphere(inout Sphere s, in float r, in vec3 c) {\n    s.r = r;\n    s.c = c;\n}\n\nvoid setMaterial(inout Sphere s, in int m, in vec3 col, in float f, in float ref) {\n    s.mat = m;\n    s.albedo = col;\n    s.fuzz = f;\n    s.ref_idx = ref;\n}\n\nvoid calcColor(inout Ray R, inout Intersection I) {\n    \n    I.color *= I.rec.albedo;\n    \n    if (I.rec.mat == 0) {\n        scatterLambert(R, I);\n    } else if (I.rec.mat == 1) {\n        scatterMetal(R, I);\n    } else if (I.rec.mat == 2) {\n        scatterDielectric(R, I);\n    }\n    \n}\n\nvoid intersectSphere(inout Ray R, in Sphere S, inout Intersection I){\n    \n    vec3 L = R.o - S.c;\n    \n    float a = dot(R.d, R.d);\n    float b = dot(L, R.d);\n    float c = dot(L, L) - S.r * S.r;\n    \n    float discriminant = b * b - a * c;\n    \n    if (discriminant > 0.0) {\n        float t = (- b - sqrt(discriminant))/a;\n        if (t > 0.001 && t < I.t) {\n            \n            I.p = R.o + t * R.d;\n            I.n = normalize(I.p - S.c);\n            \n            I.t = t;\n            I.hit = true;\n            I.rec = S;\n            \n            return;\n        }\n        t = (- b + sqrt(discriminant))/a;\n        if (t > 0.001 && t < I.t) {\n            \n            I.p = R.o + t * R.d;\n            I.n = normalize(I.p - S.c);\n            \n            I.t = t;\n            I.hit = true;\n            I.rec = S;\n            \n            return;\n        }\n    }\n}\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookAt;\n    vec3 vUp;\n    float fov;\n    float aspect;\n    float aparture;\n    float focus_dist;\n    \n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lens_radius;\n};\n\nvoid initCamera(inout Camera C){\n    C.lens_radius = C.aparture * 0.5;\n    float theta = C.fov * PI / 180.0;\n    float half_height = tan(theta * 0.5);\n    float half_width = C.aspect * half_height;\n    \n    C.w = normalize(C.pos - C.lookAt);\n    C.u = normalize(cross(C.vUp, C.w));\n    C.v = cross(C.w, C.u);\n    \n    C.lower_left_corner = C.pos - half_width * C.focus_dist * C.u - half_height * C.focus_dist * C.v - C.focus_dist * C.w;\n    C.horizontal = 2.0 * half_width * C.focus_dist * C.u;\n    C.vertical = 2.0 * half_height * C.focus_dist * C.v;\n    \n}\n\nvoid createRay(inout Ray R, in Camera C, in float s, in float t) {\n    vec2 rd = C.lens_radius * getRandomVector2(vTexCoord * vec2(s, t));\n    vec3 offset = C.u * rd.x + C.v * rd.y;\n    \n    R.o = C.pos + offset;\n    R.d = C.lower_left_corner + s * C.horizontal + t * C.vertical - R.o;\n    \n}\n\nSphere earth;\nSphere slist[8];\n\nbool hitCheck(inout Ray R, inout Intersection I) {\n    I.hit = false;\n    I.p = vec3(0.0);\n    I.n = vec3(0.0);\n    I.t = 1.0e+30;\n    \n    intersectSphere(R, earth, I);\n    \n    for (int i = 0; i < 8; i++) {\n        intersectSphere(R, slist[i], I);\n    }\n    \n    return I.hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvTexCoord = fragCoord.xy;\n    \n    initSphere(earth, 100.0, vec3(0.0, - 102.0, 0.0));\n    setMaterial(earth, 1, vec3(0.6, 0.6, 0.6), 0.1, 0.0);\n    \n    float st = 2.0 * PI / 8.0;\n    float t = iTime;\n    \n    for (int i = 0; i < 8; i++) {\n        \n        \n        if (mod(float(i), 4.0) == 1.0) {\n            \n            initSphere(slist[i],\n                       0.4,\n                       vec3(cos(t) * sin(3.0 * t + st * float(i)),\n                            sin(t) * cos(4.0 * t + st * float(i)),\n                            cos(t + st *float(i))) * 2.0\n                       );\n            \n            setMaterial(slist[i], 0, vec3(0.2, 0.9, 1.0), 0.0, 0.0);\n            \n        } else if (mod(float(i), 4.0) == 3.0) {\n            \n            initSphere(slist[i],\n                       0.4,\n                       vec3(cos(t) * sin(3.0 * t + st * float(i)),\n                            sin(t) * cos(4.0 * t + st * float(i)),\n                            cos(t + st * float(i))) * 2.0\n                       );\n            \n            setMaterial(slist[i], 0, vec3(1.0, 0.3, 0.3), 0.0, 0.0);\n            \n        } else {\n            \n            initSphere(slist[i],\n                       0.2 * (sin(t) + 1.0) + 0.3,\n                       vec3(cos(t) * sin(4.0 * t + st * float(i)),\n                            sin(t) * cos(4.0 * t + st *float(i)),\n                            cos(t + st * float(i))) * 2.0\n                       );\n            \n            setMaterial(slist[i], 2, vec3(1.0), 0.0, 1.5);\n            \n            \n        }\n        \n        \n    }\n    \n    float size = 2.0 / min(iResolution.x, iResolution.y);\n    \n    float r = 4.0 + 3.5 * sin(t * 0.8);\n    \n    Camera cam;\n    cam.pos = vec3(r * sin(t), 0.5 * cos(t * 0.5) + 0.5, r * cos(t));\n    cam.lookAt = vec3(0.0, 0.0, 0.0);\n    cam.vUp = vec3(0.0, 1.0, 0.0);\n    cam.fov = 60.0;\n    cam.aspect = 4.0/3.0;\n    cam.focus_dist = 4.0;\n    cam.aparture = 0.05;\n    \n    initCamera(cam);\n    \n    Ray ray;\n    Intersection inter;\n    \n    vec3 destColor = vec3(0.0);\n    \n    float rs = 1.1;\n    \n    for (int i = 0; i < 5; i++) {\n        inter.color = vec3(1.0);\n        \n        createRay(ray, cam, p.x + size * srand(rs*t + 0.5), p.y + size * srand(rs*t));\n        \n        rs *= 1.2;\n        \n        if (hitCheck(ray, inter)) {\n            \n            int counter = 0;\n            \n            for (int i = 0; i < 10; i++) {\n                if (hitCheck(ray, inter)) {\n                    calcColor(ray, inter);\n                } else {\n                \tbreak;\n                }\n            }\n            \n        }\n    \n        destColor += inter.color;\n        \n    }\n    \n    destColor /= 5.0;\n    \n    fragColor = vec4(sqrt(destColor.r), sqrt(destColor.g), sqrt(destColor.b), 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}