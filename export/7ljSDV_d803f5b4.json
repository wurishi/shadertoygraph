{"ver":"0.1","info":{"id":"7ljSDV","date":"1628702688","viewed":147,"name":"Pokeball Raymarcher","username":"Geotale","description":"Mouse for rotation after 2 seconds.\nI may modify this to add lighting based on the background for kinda GI.\nI've tried this before, though I got many things wrong when handling the light.\nThanks to @milesWaugh for teaching me some stuff about reflections.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarcher","pokemon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A simple filler for if I do want to add a global illumination effect\n//This would require sampling the background, therefor I would need to\n//be able to accumulate the samples correctly, which requires this buffer\n//and this simple code below in the actual image file (if I don't use\n//gamma correction).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = vec4(texture(iChannel1, uv).rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MINDIST 0.00001\n#define MAXDIST 100.0\n#define MAXSTEPS 100\n\n\n//Materials\n//IR is unused at the moment so I've set it to 0 in each object here.\n//It would be used for reflections and refractions.\nstruct Mat {\n    vec3 col;\n    float ir;\n};\n\n//Objects are just made up of materials and distances.\nstruct Obj {\n    Mat mat;\n    float dist;\n};\n\nconst vec3 lightPos = vec3(3.0, 1.5, -2.2);\n\n\nfloat sdSphere(vec3 pos, float rad){\n    return length(pos) - rad;\n}\n\n//Thanks Inigo for where I got these SDFs\nfloat sdBox(vec3 pos, vec3 lens){\n    vec3 dists = abs(pos) - lens;\n    return length(max(dists, 0.0)) + min(max(dists.x, max(dists.y, dists.z)), 0.0);\n}\n\n//Modified to point forwards instead of upwards.\nfloat sdCylinder(vec3 pos, float height, float rad){\n    vec2 dists = abs(vec2(length(pos.xy), pos.z)) - vec2(rad, height);\n    return min(max(dists.x, dists.y), 0.0) + length(max(dists, 0.0));\n}\n\n\nfloat subtract(float obj1, float obj2){\n    return max(obj1, -obj2);\n}\n\n//I could have used \"inout Obj obj1\" for each of these but I personally\n//think this is much more readable\nObj minObj(Obj obj1, Obj obj2){\n    if(obj1.dist < obj2.dist)\n        return obj1;\n    return obj2;\n}\n\n//Compute the distance to the entire scene\nObj scene(vec3 pos, float maxDist){\n    //The default \"No Hit\" object\n    Obj res = Obj(Mat(vec3(0.0), 0.0), maxDist);\n    \n    //The top (red) cap\n    res = minObj(res, Obj(\n        Mat(\n            vec3(1.0, 0.0, 0.0),\n            0.0\n        ),\n        subtract(\n            subtract(\n                sdSphere(pos - vec3(0.0, 0.0, 0.0), 1.0),\n                sdBox(pos - vec3(0.0, -1.45, 0.0), vec3(1.5, 1.5, 1.5))\n            ),\n            sdSphere(pos - vec3(0.0, 0.0, -0.9), 0.31)\n        )\n    ));\n\n    //The bottom (white) cap\n    res = minObj(res, Obj(\n        Mat(\n            vec3(1.0, 1.0, 1.0),\n            0.0\n        ),\n        subtract(\n            subtract(\n                sdSphere(pos - vec3(0.0, 0.0, 0.0), 1.0),\n                sdBox(pos - vec3(0.0, 1.45, 0.0), vec3(1.5, 1.5, 1.5))\n            ),\n            sdSphere(pos - vec3(0.0, 0.0, -0.9), 0.31)\n        )\n    ));\n\n    //The cover for the button\n    res = minObj(res, Obj(\n        Mat(\n            vec3(1.0, 1.0, 1.0),\n            0.0\n        ),\n        sdCylinder(pos - vec3(0.0, 0.0, -0.95), 0.008, 0.21)\n    ));\n\n    //The button\n    res = minObj(res, Obj(\n        Mat(\n            vec3(1.0, 1.0, 1.0),\n            0.0\n        ),\n        sdCylinder(pos - vec3(0.0, 0.0, -0.95), 0.04, 0.15)\n    ));\n\n    //The black inside sphere\n    res = minObj(res, Obj(\n        Mat(\n            vec3(0.0, 0.0, 0.0),\n            0.0\n        ),\n        sdSphere(pos - vec3(0.0, 0.0, 0.0), 0.95)\n        \n        //What would have been a beautifly tiny detail -- If I wasn't mistaken\n        //about how these were designed to open up.\n        //Replace the above sdSphere with the below code and it will add a tiny\n        //indent that showed that the black part was in two parts that open\n        //seperately.\n\n/*\n        subtract(\n            sdSphere(pos - vec3(0.0, 0.0, 0.0), 0.95),\n            subtract(\n                sdBox(pos - vec3(0.0, 0.0, -0.6), vec3(2.0, 0.01, 2.0)),\n                sdSphere(pos - vec3(0.0, 0.0, 0.0), 0.94)\n            )\n        )\n*/\n));\n\n    return res;\n}\n\nObj raymarch(vec3 pos, vec3 dir, float maxDist){\n    //The current length of the ray\n    float len = 0.0;\n\n    for(int i = 0; i < MAXSTEPS && len < maxDist; i++){\n        Obj obj = scene(pos + len * dir, maxDist);\n        len += obj.dist;\n        if(obj.dist < MINDIST){\n            obj.dist = len;\n            return obj;\n        }\n    }\n    return Obj(Mat(vec3(0.0), 0.0), maxDist);\n}\n\nvec3 normal(vec3 pos){\n    vec2 add = vec2(-MINDIST, MINDIST);\n\n    return normalize(\n        add.yxx * scene(pos + add.yxx, MAXDIST).dist +\n        add.xyx * scene(pos + add.xyx, MAXDIST).dist +\n        add.xxy * scene(pos + add.xxy, MAXDIST).dist +\n        add.yyy * scene(pos + add.yyy, MAXDIST).dist\n    );\n}\n\nvec3 rotate(vec3 pos, float rotX, float rotY, float rotZ){\n    pos = vec3(pos.x, pos.y * cos(rotX) - pos.z * sin(rotX), pos.y * sin(rotX) + pos.z * cos(rotX));\n    pos = vec3(pos.z * sin(rotY) + pos.x * cos(rotY), pos.y, pos.z * cos(rotY) - pos.x * sin(rotY));\n    pos = vec3(pos.x * cos(rotZ) - pos.y * sin(rotZ), pos.x * sin(rotZ) + pos.y * cos(rotZ), pos.z);\n    return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n\n    //The uv transformed to be in the range -1.0 to 1.0\n    vec2 px = 2.0 * uv - 1.0;\n    px.y *= iResolution.y / iResolution.x;\n\n    //Doing the same thing for the mouse\n    vec2 m;\n    if(iTime < 2.0)\n        m = vec2(-0.34, -0.25);\n    else\n        m = 7.0 * iMouse.xy / iResolution.xy - 3.5;\n    m.y *= iResolution.y / iResolution.x;\n\n    //Get the initial position and direction of the ray\n    vec3 pos = rotate(vec3(0.0, 0.0, -3.0), -m.y, m.x, 0.0);\n    vec3 dir = rotate(normalize(vec3(px, 1.0)), -m.y, m.x, 0.0);\n\n    //Get the initial object hit\n    Obj obj = raymarch(pos, dir, MAXDIST);\n    vec3 col = vec3(0.0);\n\n    if(obj.dist < MAXDIST){\n        //If an object was hit, reflect it and compute shadows for it\n        vec3 nor = normal(pos + dir * obj.dist);\n        \n        //I need a new position because otherwise the raymarching function\n        //will immediately think I've hit an object, even though it's the\n        //same one that we first intersected with at nearly/at the same point\n        vec3 newPos = pos + dir * (obj.dist - 2.0 * MINDIST);\n\n        vec3 refDir = reflect(dir, nor);\n        float r0 = 0.1;\n        float refAm = r0 + (1.0 - r0) * pow(1.0 - dot(dir, -nor), 5.0);\n        \n        Obj ref = raymarch(newPos, refDir, MAXDIST);\n        \n        if(ref.dist < MAXDIST)\n            col = (1.0 - refAm) * obj.mat.col + refAm * ref.mat.col;\n        else\n            col = (1.0 - refAm) * obj.mat.col + refAm * texture(iChannel0, vec3(-1.0, 1.0, -1.0) * refDir).rgb;\n\n        //Some nice shading\n        col *= .7 + .4 * dot(nor, normalize(lightPos - newPos));\n        \n        Obj shadow = raymarch(newPos, normalize(lightPos - newPos), length(lightPos - newPos));\n        if(shadow.dist < length(lightPos - newPos))\n            col *= 0.8;\n    } else\n        //Otherwise, set the background to the cubemap\n        //I rotate the cubemap so the light is \n        col = texture(iChannel0, vec3(-1.0, 1.0, -1.0) * dir).rgb;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}