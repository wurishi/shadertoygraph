{"ver":"0.1","info":{"id":"fssSDM","date":"1618704100","viewed":120,"name":"glass sphere CG2 Seregina_311","username":"Ireee","description":"make it sphere","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["homework"],"hasliked":0,"parentid":"fdfXDM","parentname":"glass sphere"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1); // чтобы не засвечивало от источников (нет накоплению света!)\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int MAX_COUNT = 50;\nvec3 randDir;\n\nconst vec3 CAMERA_POS = vec3(1.5,2,-7);//(1.5,2,-7);\nconst float INF = 1e7 ;\n\nconst vec3 LIGHT1_POS = vec3 (-2.5,1.7,2.5);\nconst float LIGHT1_RADIUS = 0.6;\nconst vec3 LIGHT1_COLOR = vec3(1,0.4,0.2);\n\nvec3 LIGHT2_POS = vec3 (1.8,1,1);\nconst float LIGHT2_RADIUS = 0.2;\nconst vec3 LIGHT2_COLOR = vec3(1,1,0.9);\n\n\nconst vec3 LIGHT3_POS = vec3 (1.2,0,3.5);\nconst float LIGHT3_RADIUS = 0.16;\nconst vec3 LIGHT3_COLOR = vec3(0.9,0.9,0.68);//(0.8,0.5,0.2);\n\n\n\nfloat tracePlane (vec3 pos, vec3 dir, out vec3 normal){\n   \n    float t=(-1.25-pos.y)/dir.y;\n    if (t <= 0.0) return INF;\n\n    vec3 worldPos = t*dir+pos;\n    \n    // фигура горизонта\n    if (dot(worldPos.xz,worldPos.xz)< 121.0)\n    { \n        normal = vec3(0,1,0);\n        return t;\n    }\n    else {return INF;}\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    const float R = 0.6f;\n    float floorT = (-1.0 - pos.y) / dir.y;\n    if (floorT < 0.0)\n        return INF;\n    vec3 finalPos = pos + dir * floorT;\n    if (dot(finalPos.xz, finalPos.xz) < R * R) {\n        normal = vec3(0, 1, 0);\n        return floorT;\n    }\n    \n    float b = dot(pos.xz, dir.xz);\n    float a = dot(dir.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz);\n    float D = b * b - (c - R * R) * a;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        finalPos = t * dir + pos;\n        if (finalPos.y <= -1.0) {\n            normal = normalize(vec3(finalPos.x, 0, finalPos.z));\n            return t;\n        }\n    }\n\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    finalPos = t * dir + pos;\n    if (finalPos.y <= -1.0) {\n        normal = normalize(vec3(finalPos.x, 0, finalPos.z));\n        return t;\n    }\n    \n    return INF;\n}\n\nfloat traceSphere (vec3 pos, vec3 dir, float r, out vec3 normal){\n    \n    float b = dot(pos, dir);\n    float D = b * b - dot(pos,pos)+r*r; \n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t <= 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n\n}\n\nbool isOccluded(vec3 pos, vec3 target) { //тени\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphNorm; // пускаем луч через главную сферу\n    float sphT = traceSphere(pos, dir, 1.0, sphNorm);\n    if (sphT < dist)\n        return true;\n    vec3 cylNorm; // и через цилиндр\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float occl1 = isOccluded(pos, LIGHT1_POS+ randDir * LIGHT1_RADIUS ) ? 0. : 16.0f / distSq1; \n    \n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2); // мягкие тени\n    float occl2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0. : 7.0f / distSq2;\n    \n    vec3 toLight3 = LIGHT3_POS - pos;\n    float distSq3 = dot(toLight3, toLight3);\n    float occl3 = isOccluded(pos, LIGHT3_POS+ randDir * LIGHT3_RADIUS ) ? 0. : 3.5f / distSq3; \n    \n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * occl1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * occl2 * LIGHT2_COLOR\n        +max(0.0, dot(normal, normalize(toLight3))) * occl3 * LIGHT3_COLOR\n            + texture(iChannel1, normal).rgb * 0.45 ); //амбиентное освещение\n   // return color * max(0.0, dot(normal, normalize(toLight1)))*att1;\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1; \n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame){ // случайные числа\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n\n//const float MAX_HEIGHT = 1.0;\nconst float QF = 11.0;\nconst float QC = 1.0/QF;\nconst float HQC = QC*0.5 ;\nconst vec3 C_GRASS = vec3(0.3, 1, 0.5);\nconst vec3 C_DIRT = vec3(0.48, 0.32, 0.2);\n\nfloat sdBox(in vec3 p, vec3 size) {\n    return length(max(abs(p) - size, 0.)); \n} \n\n\nvec2 getTree(vec3 pOrig) {\n    \n    vec3 p = pOrig;\n    \n    \n    float leafs = sdBox(p - vec3(0., 0., 0. ), vec3(HQC) * vec3(6., 2., 6.));\n    leafs = min(leafs, sdBox(p - vec3(0., QC * 2., 0. ), vec3(HQC) * vec3(8., 2., 8.)));\n    leafs = min(leafs, sdBox(p - vec3(0., QC * 4., 0. ), vec3(HQC) * vec3(6., 2., 6.)));\n    leafs = min(leafs, sdBox(p - vec3(0., QC * 6., 0. ), vec3(HQC) * vec3(4., 2., 4.))); \n    \n    float dist ;\n    vec3 size = vec3(HQC * 2., HQC * 12., HQC * 2.); // ствол\n    dist = sdBox(p, size);\n    \n    if (leafs < dist) {\n        return vec2(leafs, 4.);\n    }\n    else if (dist < INF) return vec2(dist, 5.);\n    else return vec2 (INF, -1.0);\n}\n\nvec3 getNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 norm;\n    norm.x = getTree(pos+eps.xyy).x - getTree(pos-eps.xyy).x;\n    norm.y = getTree(pos+eps.yxy).x - getTree(pos-eps.yxy).x;\n    norm.z = getTree(pos+eps.yyx).x - getTree(pos-eps.yyx).x;\n    return normalize(norm);\n}\n\n///////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));// вектор 3 случ чисел\n    randDir = normalize(randVals - 0.5);\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy + 2.0*(randVals.xy - 0.5) )/iResolution.x; // ?антиляссинг? +1 балл\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3 (0,1,0);\n    vec3 right = normalize (cross(front, up));\n    up = normalize (cross (right, front)); // векторное произведение -> можно сменить верх на низ\n    vec3 viewVec = normalize (front + right*uv.x + up*uv.y);\n    \n    vec3 LIGHT3_POS = vec3(1.2,0,3.5) + 0.05*randVals;\n    \n    // поддержка материалов \n    const int EMISSION = 0;\n    const int DIFFUSE = 1; // при большом REFLECTION нужно умножать на какое-то знач\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    vec3 cur_pos = CAMERA_POS;\n    vec3 cur_dir = viewVec;\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float n1 = AIR_N; \n    float n_enter = AIR_N;\n\n    // границы\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);//REFLECTION+REFRACTION\n    \n    float total = 0.0;\n    vec3 tree_normal;\n    \n   // vec3 colorMult = vec3 (1,1,1);\n    \n    for (int i=0; i < MAX_COUNT; ++i){\n        \n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n       \n        \n        vec3 sphNorm;\n        float sphT = traceSphere(cur_pos, cur_dir, 1.0 ,sphNorm);\n        if (sphT < t){\n            t = sphT;\n            \n            normal = sphNorm;\n            if (randVals.x *0.08 < GLASS_R){\n                materialType = REFLECTION;\n            }\n            else { \n                materialType = REFRACTION;\n                if (dot(cur_dir,normal)>0.0){\n                    n_enter = AIR_N;\n                }\n                else {\n                    n_enter = GLASS_N;\n                } \n            } \n        }\n      \n       \n        vec2 treeT = getTree(cur_pos+viewVec*total);\n        tree_normal = getNormal(cur_pos +  viewVec * total); \n        if (treeT.x < t) {\n            total += treeT.x;\n            t = treeT.x;\n            \n           \n\n            if (randVals.y<0.45) {  // чтобы сделатьдерево более прозрачным, увеличь число 0.45\n                materialType = REFRACTION; \n                if (dot(cur_dir,normal)>0.0){\n                    n_enter = GLASS_N;\n                }\n                else {\n                    n_enter = AIR_N;\n                }\n                \n            } \n            else {\n                materialType = DIFFUSE;\n                normal = tree_normal;\n                if (int(treeT.y) == 4) {\n                    color = C_GRASS;\n                } \n                else if (int(treeT.y) == 5) {\n                    color = C_DIRT; \n                } \n            }\n     //       fragColor = vec4(color,1.0);\n\n        } \n        \n        ///////////////////////////////////////////////////////////////\n        vec3 cylNorm;\n        float cylT = traceCylinder(cur_pos, cur_dir, cylNorm);\n        if (cylT < t){\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t*cur_dir+cur_pos;\n            color = texture (iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n            \n        }\n        vec3 light1_Norm;\n        float light1T = traceSphere(cur_pos - LIGHT1_POS, cur_dir, LIGHT1_RADIUS,light1_Norm);\n        if (light1T<t){\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = light1_Norm;\n        }\n        vec3 light2_Norm;\n        float light2T = traceSphere(cur_pos - LIGHT2_POS, cur_dir, LIGHT2_RADIUS,light2_Norm);\n        if (light2T<t){\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = light2_Norm;\n        }\n        vec3 light3_Norm;\n        float light3T = traceSphere(cur_pos - LIGHT3_POS, cur_dir, LIGHT3_RADIUS,light3_Norm);\n        if (light3T<t){\n            t = light3T;\n            materialType = EMISSION;\n            color = LIGHT3_COLOR;\n            normal = light3_Norm;\n        }\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(cur_pos, cur_dir,planeNorm);\n        if (planeT<t){\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t*cur_dir+cur_pos;\n            color = texture (iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n            if (randVals.y<0.16) { // можно не использовать \n                materialType = REFLECTION; \n            } \n        }\n        \n        if (t!= INF){\n            vec3 worldPos = t*cur_dir+cur_pos;\n            fragColor = texture(iChannel0, worldPos.xz); \n            \n            if (materialType == EMISSION){ //эмиссивные материалы - источники света\n                fragColor.rgb = color;//*colorMult; \n            }\n           \n            else if (materialType == REFLECTION){\n                cur_dir = reflect (cur_dir, normal);\n                cur_pos = worldPos+cur_dir*1e-5;\n                \n            } \n            else if (materialType == REFRACTION){\n                cur_dir = refraction(cur_dir, normal, n1, n_enter);\n                cur_pos = worldPos+cur_dir*1e-5;\n                n1=n_enter;\n\n            }\n             else if (materialType == DIFFUSE){ // обычные твердые тела\n                fragColor.rgb = computeLight (worldPos,color,normal);\n            }\n        }\n        else {\n            fragColor.rgb = texture(iChannel1, cur_dir).rgb;//* colorMult;\n        }\n    \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv)+ texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}