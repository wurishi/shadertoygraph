{"ver":"0.1","info":{"id":"3tfXRM","date":"1562333589","viewed":1399,"name":"Simple night sky","username":"carolhmj","description":"Using noise functions to generate stars, clouds and a moon.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","clouds","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1416\n#define SKY_COLOR vec3(0.027, 0.151, 0.354)\n#define LIGHT_SKY vec3(0.45, 0.61, 0.98)\n#define STAR_COLOR vec3(0.92, 0.92, 0.14)\n#define MOON_COLOR vec3(0.81, 0.81, 0.81)\n\n//Noise functions from https://www.youtube.com/watch?v=zXsWftRdsvU\nfloat noise11(float p) {\n\treturn fract(sin(p*633.1847) * 9827.95);\n}\n    \nfloat noise21(vec2 p) {\n\treturn fract(sin(p.x*827.221 + p.y*3228.8275) * 878.121);\n}\n\nvec2 noise22(vec2 p) {\n\treturn fract(vec2(sin(p.x*9378.35), sin(p.y*75.589)) * 556.89);\n}\n\n//From https://codepen.io/Tobsta/post/procedural-generation-part-1-1d-perlin-noise\nfloat cosineInterpolation(float a, float b, float x) {\n    float ft = x * PI;\n    float f = (1. - cos(ft)) * .5;\n    return a * (1. - f) + b * f;\n}\n\nfloat smoothNoise11(float p, float dist) {\n    float prev = noise11(p-dist);\n    float next = noise11(p+dist);\n       \n    return cosineInterpolation(prev, next, .5);\n}\n\nfloat smoothNoise21(vec2 uv, float cells) {\n\tvec2 lv = fract(uv*cells);\n    vec2 id = floor(uv*cells);\n    \n    //smoothstep function: maybe change it later!\n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = noise21(id);\n    float br = noise21(id+vec2(1.,0.));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = noise21(id+vec2(0.,1.));\n    float tr = noise21(id+vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nvec2 smoothNoise22(vec2 uv, float cells) {\n\tvec2 lv = fract(uv*cells);\n    vec2 id = floor(uv*cells);\n    \n    //smoothstep function: maybe change it later!\n    lv = lv*lv*(3.-2.*lv);\n    \n    vec2 bl = noise22(id);\n    vec2 br = noise22(id+vec2(1.,0.));\n    vec2 b = mix(bl, br, lv.x);\n    \n    vec2 tl = noise22(id+vec2(0.,1.));\n    vec2 tr = noise22(id+vec2(1.,1.));\n    vec2 t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\n\nfloat valueNoise11(float p) {\n\tfloat c = smoothNoise11(p, 0.5);\n    c += smoothNoise11(p, 0.25)*.5;\n    c += smoothNoise11(p, 0.125)*.25;\n    c += smoothNoise11(p, 0.0625)*.125;\n    \n    return c /= .875;\n}\n\nfloat valueNoise21(vec2 uv) {\n\tfloat c = smoothNoise21(uv, 4.);\n    c += smoothNoise21(uv, 8.)*.5;\n    c += smoothNoise21(uv, 16.)*.25;\n    c += smoothNoise21(uv, 32.)*.125;\n    c += smoothNoise21(uv, 64.)*.0625;\n    \n    return c /= .9375;\n}\n\nvec2 valueNoise22(vec2 uv) {\n\tvec2 c = smoothNoise22(uv, 4.);\n    c += smoothNoise22(uv, 8.)*.5;\n    c += smoothNoise22(uv, 16.)*.25;\n    c += smoothNoise22(uv, 32.)*.125;\n    c += smoothNoise22(uv, 64.)*.0625;\n    \n    return c /= .9375;\n}\n\nvec3 point(vec2 p, vec2 uv, vec3 color, float size, float blur) {\n\tfloat dist = distance(p, uv);\n    \n    return color*smoothstep(size, size*(0.999-blur), dist);\n}\n\nfloat mapInterval(float x, float a, float b, float c, float d) {\n\treturn (x-a)/(b-a) * (d-c) + c;\n}\n\nfloat blink(float time, float timeInterval) {\n    float halfInterval = timeInterval / 2.0;\n    //Get relative position in the bucket\n    float p = mod(time, timeInterval);\n    \n    \n    if (p <= timeInterval / 2.) {\n    \treturn smoothstep(0., 1., p/halfInterval);\n    } else {\n        return smoothstep(1., 0., (p-halfInterval)/halfInterval);\n    }\n}\n\nvec3 sampleBumps(vec2 p, vec2 uv, float radius) {\n\tfloat dist = distance(p, uv);\n    \n    if (dist < radius) {\n    \treturn vec3((1.-valueNoise21(uv*10.))*.1);\n    }\n    return vec3(0.); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ouv = uv;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float time = iTime + mouse.x*10.;\n        \n    //vec3 col = vec3(0.0);\n    //float m = valueNoise21(uv);    \n\tvec3 col = mix(LIGHT_SKY, SKY_COLOR, ouv.y+.6);\n    \n    col *= .65 + (1.-ouv.y);\n    \n    //Add clouds\n    vec2 timeUv = uv;\n    timeUv.x += time*.1;\n    timeUv.y += valueNoise11(timeUv.x+.352)*.01;\n    float cloud = valueNoise21(timeUv);\n    col += cloud*.1;\n    \n    //Add stars in the top part of the scene\n    float timeInterval = 5.;\n    float timeBucket = floor(time / timeInterval);\n    \n    // Moon\n    vec2 moonPosition = vec2(-0.600, 0.25);\n    \n    col += point(moonPosition, uv, MOON_COLOR, 0.15, 0.3);\n    // Moon bumps\n    col += sampleBumps(moonPosition, uv, 0.12);\n    \n    for (float i = 0.; i < 25.; i++) {\n\t    vec2 starPosition = vec2(i/10., i/10.);\n        \n        starPosition.x = mapInterval(valueNoise11(timeBucket + i*827.913)-.4, 0., 1., -0.825, 0.825);\n        starPosition.y = mapInterval(valueNoise11(starPosition.x)-.3, 0., 1., -0.445, 0.445);\n\t    \n        float starIntensity = blink(time, timeInterval);\n        //Hide stars that are behind the moon\n        if (distance(starPosition, moonPosition) > 0.14) {\n        \tcol += point(starPosition, uv, STAR_COLOR, 0.001, 0.0)*clamp(starIntensity-.1, 0.0, 1.0)*10.0;\n        \tcol += point(starPosition, uv, STAR_COLOR, 0.009, 3.5)*starIntensity*3.0;\n        }\n    }\n  //col = vec3(blink(time, timeInterval));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}