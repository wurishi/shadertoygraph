{"ver":"0.1","info":{"id":"XlscWf","date":"1506778028","viewed":823,"name":"Islamic ornaments00","username":"knighty","description":"Islamic geometric art ornament. Obtained through foldings and ray mirroring.\nRef: G.S. Kaplan: \"Computer Graphics and Geometric Ornamental Design\", P.H.D. thesis, 2002.\n[url]http://www.cgl.uwaterloo.ca/csk/phd/kaplan_diss_full_print.pdf[/url]","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["2d","stars","pattern","tiling","art","islamic","ornament"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nIslamic geometric art ornament. Obtained through foldings and ray mirroring. There is still\nsome work to do:\n- More comments :P\n\nRef: G.S. Kaplan: \"Computer Graphics and Geometric Ornamental Design\", P.H.D. thesis, 2002.\n[url]www.cgl.uwaterloo.ca/csk/phd/kaplan_diss_full_print.pdf[/url]\n\nShader by knighty.\n\nLicence: public domain.\n\n*/\n\n//Gamma attempt\n#define GAMMA 2.2\n\n//uncomment me!\n//#define SIMPLE\n\n//Make it dance!\n#define WOBBLE 0.7\n\n//Comment me! Looks better and less complicated but without animation.\n//There is an \"error\" thought.\n#define VARIANT2\n\nfloat aaScale;\nfloat lineWidth = 0.;\nvec3 linesCol = vec3(0.6,0.75,.8);\nvec3 linesBorderCol = vec3(0.,0.,0.);\n\n//foldings constants\nconst vec2 rect = vec2(1.,1.3763819204711735382072095819109);// vec2(1, tan(3PI/10))\nconst vec3 f0 = vec3(0.80901699437494742410229341718282, -0.58778525229247312916870595463907, 0.);// vec3(cos(2PI/10, -sin(2PI/10),0)\nconst vec3 f1 = vec3(-0.58778525229247312916870595463907,-0.80901699437494742410229341718282, 0.85065080835203993218154049706301);// vec3(-sin(2PI/10), -cos(2PI/10),1/(2cos(3PI/10)))\nconst vec3 f2 = vec3(0.30901699437494742410229341718282,-0.95105651629515357211643933337938, 0.);// vec3(sin(PI/10), -cos(PI/10),0)\nconst vec3 f3 = vec3(0.,1., 0.);// for reference. We'll simply use abs(p.y)\nconst vec3 f4 = vec3(-0.58778525229247312916870595463907,-0.80901699437494742410229341718282, 0.52573111211913360602566908484788);// vec3(-sin(2PI/10), -cos(2PI/10),1/2*cos(2PI/10)*tg(PI/10))\nconst vec3 f5 = vec3(0.,1., 0.);// for reference. We'll simply use abs(p.y)\n#ifdef VARIANT2\nconst vec3 f6 = vec3(-0.95105651629515357211643933337938,-0.30901699437494742410229341718282, 0.85065080835203993218154049706301);// vec3(-cos(PI/10), -sin(PI/10),1/(2cos(3PI/10)))\n#endif\n\n//Ray\nstruct Ray{\n    vec2 O;\n    vec2 D;\n};\n//Starting ray\n#ifdef VARIANT2\nRay firstRay = Ray(vec2(0.80901699437494742410229341718282,0.26286555605956680301283454242394),//vec2(cos(PI/10),0)/(2cos(3PI/10))\n                   vec2(0.,1.));\n#else\nRay firstRay = Ray(vec2(1.,0.12410828034667904628607373958239),//vec2(1,2sin(PI/10)tgÂ²(PI/10))\n                   vec2(-0.95105651629515357211643933337938,-0.30901699437494742410229341718282));// -vec2(cos(PI/10),sin(PI/10));\n#endif\n\nvoid reflectRay(inout Ray ray, in vec3 mirror){\n    //we assume that ray direction and mirror normal are normalized.\n    float nd = dot(mirror.xy, ray.D);\n    float t = -(mirror.z + dot(mirror.xy, ray.O))/nd;\n    ray.O += t * ray.D;\n    ray.D -= 2. * nd * mirror.xy;\n}\n\nfloat sideRay(in Ray ray, vec2 p){\n    p -= ray.O;\n    return ray.D.y * p.x - ray.D.x * p.y;\n}\n\nfloat sideRay(in Ray ray, vec2 p, inout float r){\n    float t = (sideRay(ray, p) < 0.) ? 1. : 0.;\n    t += r; if(t > 1.) t=0.;//xor with r... I haven't integer support.\n    r = (r == 0.) ? 1. : 0.; \n    return t;\n}\n\n//Mirrors that reflect the ray\n// are f2 and f3 for default variant and f2,f3 and f4 for the variant 2\n\n// Folds the plane about the line L\nint lineFold(inout vec2 p, in vec3 L){\n\tfloat t = -(dot(p,L.xy) + L.z);\n\tp += 2. * max(0.,t) * L.xy;\n\treturn int(t > 0.);\n}\n\n// Folds the plane about some symmetry lines.\n// Returns the number of folds performed.\nint fold(in vec2 p, out vec2 z){\n\tint nbrFold = 0;\n\t//fold into the rectangle rect. first translation by 2*rect then mirror about faces of rect.\n\tz=mod(p, 2.*rect);\n\tz -= rect;\n\tnbrFold += int(z.x>0.); nbrFold += int(z.y>0.);\n\tz = -abs(z) + rect;\n    \n\t// Other folds\n\tnbrFold += lineFold(z, f0);\n\tnbrFold += lineFold(z, f1);\n    nbrFold += lineFold(z, f2);\n\tnbrFold += int(z.y < 0.); z.y = abs(z.y);//same as lineFold(z, f3);\n#ifdef VARIANT2\n    nbrFold += lineFold(z, f6);\n#endif\n    nbrFold += lineFold(z, f4);\n\tnbrFold += int(z.y < 0.); z.y = abs(z.y);//same as lineFold(z, f5);\n\t\t\n\treturn nbrFold;\n}\n\nfloat segDist(vec2 p, vec2 a, vec2 b){\n\tp -= a; b -=a;\n\tfloat t = clamp(dot(p,b) / dot(b,b), 0., 1.);\n\treturn length(p - t * b);\n}\n\nfloat segDistNoClamp(vec2 p, vec2 a, vec2 b){\n\tp -= a; b -=a;\n\tfloat t = dot(p,b) / dot(b,b);\n\treturn length(p - t * b);\n}\n\n//The profile of the lines for opacity and color\nfloat profile(float x, float width, float pixWidth){\n    float a = -.5/pixWidth;\n    float b = -a * (width + pixWidth);\n    return smoothstep(0., 1., a * x + b);\n}\n\nvec4 combine(vec4 up, vec4 dn){\n    if(up.w*dn.w == 1.)\n        return vec4(0.,0.,0.,1.);\n    return vec4(mix(up.rgb, dn.rgb * (1.-dn.w), up.w)/(1. - up.w * dn.w),\n                up.w * dn.w);\n}\n\nvec4 stepIt(vec4 pcol, vec2 z, Ray ray, float parity){\n    float d = segDistNoClamp(z, ray.O, ray.O + ray.D);\n    float po = 1. - profile(d, lineWidth+2.*aaScale, aaScale);\n    float pc = profile(d, lineWidth, aaScale);\n    //vec3 col = pc * linesCol;\n    vec3 col = mix(linesBorderCol, linesCol, pc);\n    \n    if(parity < .5)\n        return combine(vec4(col,po), pcol);\n    else\n        return combine(pcol, vec4(col,po));\n}\n\n#ifndef SIMPLE\nvec4 drawIt(vec2 z, float parity){\n    Ray ray = firstRay;\n    vec4 col = vec4(1., 1., 1., 1.);\n    float tc = 0., r = 0.;\n    \n    col = stepIt(col, z, ray, parity);\n    tc += sideRay(ray, z, r);\n#ifdef VARIANT2\n    reflectRay(ray, f4);\n    col = stepIt(col, z, ray, parity);\n    tc += sideRay(ray, z, r);\n#endif\n    reflectRay(ray, f3);\n    col = stepIt(col, z, ray, parity);\n    tc += sideRay(ray, z, r);\n    \n    reflectRay(ray, f2);\n    col = stepIt(col, z, ray, parity);\n    tc += sideRay(ray, z, r);\n    \n#ifdef VARIANT2\n    reflectRay(ray, f3);\n    col = stepIt(col, z, ray, parity);\n    tc += sideRay(ray, z, r);\n    \n    /*reflectRay(ray, f2);\n    col = stepIt(col, z, ray, parity);\n\ttc += sideRay(ray, z, r);\n    */\n#endif\n    vec4 col1 = vec4(pow(vec3(0.75+0.25*sin(tc*tc*3.2+iTime),\n               0.75+0.25*sin(tc*1.5+iTime*.7),\n               0.75+0.25*sin(tc*tc*4.2+iTime*.3)), vec3(GAMMA)),\n               0.);\n    return combine(col, col1);\n}\n\n#else\n\n//Simple drawing. Not used. useful to see the action of the folding.\n//in order to use it, uncomment the \"#define SIMPLE\" above ^^^ \nvec4 drawIt(vec2 z, float parity){\n    \n    Ray ray = firstRay;\n    \n    float d = segDist(z, ray.O, ray.O + ray.D);\n#ifdef VARIANT2\n    reflectRay(ray, f4);\n    d = min(d, segDist(z, ray.O, ray.O + ray.D));\n#endif\n    reflectRay(ray, f3);\n    d = min(d, segDist(z, ray.O, ray.O + ray.D));\n    reflectRay(ray, f2);\n    d = min(d, segDist(z, ray.O, ray.O + ray.D));\n    /*reflectRay(ray, f3);\n    d = min(d, segDist(z, ray.O, ray.O + ray.D));\n    reflectRay(ray, f2);\n    d = min(d, segDist(z, ray.O, ray.O + ray.D));\n    */\n    return vec4(vec3(0.7 + 0.6* (parity)) *clamp(d*100., 0., 1.), 1.);\n}\n\n#endif\n\n//\nvoid initRay(vec2 p){\n    linesCol = pow(linesCol,vec3(GAMMA));\n    linesBorderCol = pow(linesBorderCol,vec3(GAMMA));\n    lineWidth = sin(0.2 * iTime)*0.01+0.015;\n#ifdef VARIANT2 \n    float ang = 0.12 * sin(iTime + WOBBLE * p.x);\n    float d = firstRay.O.y * tan(ang);\n    firstRay.O.x -= d; firstRay.O.y =0.;\n    firstRay.D = vec2(sin(ang), cos(ang));\n#endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat scaleFactor= 5.;//0.05*iMouse.y;\n\tvec2 p = scaleFactor*(fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\taaScale=0.75*scaleFactor/iResolution.y;\n    \n    initRay(p);\n    \n    vec2 z = vec2(0.);\n\tint nbrFold = fold(p, z);\n    float parity = 1. - fract(float(nbrFold) * 0.5) * 2.;\n\n\tfragColor = drawIt(z, parity);\n    fragColor.xyz = pow(fragColor.xyz, vec3(1./GAMMA));\n}","name":"Image","description":"","type":"image"}]}