{"ver":"0.1","info":{"id":"wlX3WS","date":"1557445545","viewed":127,"name":"SDF-Merge","username":"bytearray","description":"merges stuff, now fixed","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define MAX_MARCHING_STEPS 100\n#define EPSILON 0.0001\n#define start 0.1\n#define end 100.0\n\nvec3 bug = vec3(0);\n\n\n\nfloat sphere(vec3 pos, float r)\n{\n    return length(pos) - r;\n}\n\nfloat box(vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat intersect(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\nfloat subtract(float distA, float distB)\n{\n    return max(distA, -distB);\n}\n\nfloat combine(float distA, float distB)\n{\n    return min(distA, distB);\n}\n\nfloat difference(float distA, float distB)\n{\n    return max(-distA, distB);\n}\n\nvec3 repeat(vec3 pos, vec3 rep)\n{\n    return mod(pos+0.5*rep, rep)-0.5*rep;\n}\n\nfloat spiked(vec3 pos)\n{\n    float lon = atan(pos.z, pos.x);\n    float lat = atan(pos.y, length(pos.xz));\n    \n    float s = sphere(pos, 2.);\n    return s + (sin(lat * 16.) * sin(lon * 8.)) * 0.2;\n}\n\nfloat lattice(in vec3 pos)\n{\n    float block = box(pos, vec3(2, 1.5, 1.5));\n    float holes = sphere(repeat(pos, vec3(0.4)), 0.25);\n    return subtract(block, holes);\n}\n\nfloat sdf(vec3 pos)\n{\n    float b = box(pos, vec3(2, 1.5, 1.5));\n    float t = torus(pos, vec2(2, 1));\n    float p = spiked(pos);\n    float s = sphere(pos, 2.);\n    float l = lattice(pos);\n    \n    float time = iTime / 2.;\n    \n    float inter = mod(time, 1.);\n    int n = int(mod(time, 5.));\n    float d;\n    \n    switch(n)\n    {\n        case 0: d = mix(b, t, inter); break;\n        case 1: d = mix(t, p, inter); break;\n        case 2: d = mix(p, s, inter); break;\n        case 3: d = mix(s, l, inter); break;\n        case 4: d = mix(l, b, inter); break;\n    }\n   \n    return d;\n}\n\nfloat ray(vec3 eye, vec3 dir)\n{\n    float depth = start;\n\tfor (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        \n        float dist = sdf(eye + depth * dir);\n        \n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y);\n    uv.x += (1. - iResolution.x / iResolution.y) / 2.;\n    vec2 st = uv - vec2(.5);\n    \n    vec3 eye = vec3(0., 10., 7.);\n    vec3 dir = vec3(st / 2., -1.);\n    \n    mat4 mat = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.));\n    dir = (mat * vec4(dir, 1.)).xyz;\n    \n    float depth = ray(eye, dir);\n    if(!(depth >= end - EPSILON))\n    {\n        vec3 hit = eye + dir * depth;\n    \tvec3 norm = estimateNormal(hit);\n        \n        fragColor = vec4(norm+vec3(.5), 1.);\n    }\n    else\n    {\n        fragColor = vec4(0);\n    }\n    fragColor.rgb += bug;\n}\n","name":"Image","description":"","type":"image"}]}