{"ver":"0.1","info":{"id":"lfGcRD","date":"1731547253","viewed":185,"name":"Five Sliders Test","username":"blackle","description":"testing my midi sliders on bonzomatic at qcc","likes":16,"published":3,"flags":0,"usePreview":0,"tags":["sliders","midi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fMidi1 = 0.0;\nfloat fMidi2 = 0.0;\nfloat fMidi3 = 0.0;\nfloat fMidi4 = 0.0;\nfloat fMidi5 = 0.0;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 tri(vec3 p) {\n  p = abs(p);\n  vec3 y = fract(p);\n  y = mix(y, 1.-y, vec3(ivec3(p)&1));\n  return y;\n}\n\n#define FK(x) floatBitsToInt(x*x/7.)\nfloat hash(vec2 p) {\n  int x = FK(p.x); int y = FK(p.y);\n  return float(x*x*y + y*y*x - x*y)/2.13e9;\n}\n\nfloat o = 0.;\nfloat scene(vec3 p) {\n  float scale = mix(1., 4., fMidi5);\n  vec3 pa = tri(p*scale)/scale;\n  vec3 pb = tri(p);\n  float cave = (length(pb) - length(p))/sqrt(2.) + mix(3.,5.,fMidi3);\n  float c1 = length(pa.xy)-.3;\n  c1 = min(length(pa.xz)-.3, c1);\n  c1 = min(length(pa.yz)-.3, c1);\n  float obj =  length(vec2(abs(length(p) - mix(.6,1.2,fMidi1)), abs(c1))/sqrt(2.))-.01*scale;\n  if (obj < cave) {\n    o = 1.;\n    return obj;\n  }\n  o = 0.;\n  return cave;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 grad(float x) {\n  return vec3(sin(x*3.14*2.), sin(x*3.14*2.+2.), sin(x*3.14*2.+4.))*.5+.5;\n}\n\nvec3 solar_invert(vec3 color, float x) {\n    float st = 1.-step(.5, x);\n    return abs((color-st)*(2.*x+4.*st-3.)+1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat t = iTime/20.;\nfMidi1 = sin(t)*.5+.5;\nfMidi2 = sin(t*2.)*.5+.5;\nfMidi3 = sin(t*3.)*.5+.5;\nfMidi4 = sin(t*5.)*.5+.5;\nfMidi5 = sin(t*7.)*.5+.5;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  uv += vec2(hash(uv),hash(uv.yx+1.))*length(uv)/30.;\n  \n  vec3 init = vec3(-4,0,0);\n  vec3 cam = normalize(vec3(3,uv+.2));\n  float zrot = iTime/7.;\n  float yrot = sin(iTime/5.333);\n\n  cam = erot(cam, vec3(0,1,0), yrot);\n  init = erot(init, vec3(0,1,0), yrot);\n\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);  \n\n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i < 50 && !hit; i++) {\n    float d = scene(p);\n    if (d*d < 1e-5) hit = true;\n    p += cam*d;\n    if (d > 1e4) break;\n  }\n  float lo = o;\n  vec3 n  = norm(p);\n  vec3 r = reflect(cam, n);\n  float m = length(sin(mix(n,r,lo)*3.5)*.5+.5)/sqrt(3.);\n  vec3 col = grad(fMidi2+sin(m*6.)*.1-lo*.5)*m + pow(m, 6.);\n\n  col = hit ? col : vec3(0.01);\n  col = solar_invert(col, fMidi4);\n\tfragColor = sqrt(vec4(smoothstep(-.1,1.1,col), 1)) + hash(uv)*.05;\n}","name":"Image","description":"","type":"image"}]}