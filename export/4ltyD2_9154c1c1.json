{"ver":"0.1","info":{"id":"4ltyD2","date":"1534162928","viewed":193,"name":"Simple raycasting","username":"vTurbine","description":"Wolf3D-like renderer implementation. No optimizations + some magic left.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * vTurbine, 2018\n */\n\nconst int MAP_SIZE = 6;\nconst int[] MAP = int[] (\n    1, 1, 1, 1, 1, 1,\n    1, 0, 0, 0, 0, 1,\n    1, 0, 0, 0, 0, 1,\n    1, 0, 0, 0, 1, 1,\n    1, 1, 0, 1, 0, 1,\n    1, 1, 1, 1, 1, 1\n);\n\nconst vec2  ORIGIN = vec2(3.3, 2.2);    // player's position\nconst float DIR    = 35.0; \t\t        // direction angle\n\nconst float FOV      = 66.0;\nconst float MAX_DIST = float(MAP_SIZE) / sin(radians(45.0));\n\nconst float HEIGHT_FAR  = 1.0 / 8.0;\nconst float HEIGHT_NEAR = 2.0 / 3.0;\n\nconst vec3 BG_COLOR_FLOOR   = vec3(0.35);\nconst vec3 BG_COLOR_CEILING = vec3(0.25);\n\nstruct rc_result {\n    float dist;\n    float tex_pos;\n    bool  is_vertical;\n};\n\nbool xor(bool a, bool b)\n{\n    return (a && !b) || (!a && b);\n} \n    \nrc_result ray_cast(float dir, float angle)\n{\n    if (angle <= -180.0) {\n        angle = 360.0 + angle;\n    }\n    else if (angle > 180.0) {\n        angle = angle - 360.0;\n    }\n\n    float x_tile_step;\n    float y_tile_step;\n    \n    float x_partial;\n    float y_partial;\n    \n    float x_ratio;\n    float y_ratio;\n    \n    if (angle >= 0.0 && angle < 90.0) { // I\n        x_tile_step =  1.0;\n        y_tile_step = -1.0;\n        \n        x_partial   = 1.0 - fract(ORIGIN.x);\n        y_partial   =       fract(ORIGIN.y);\n        \n        x_ratio     = 1.0 / tan(radians(angle));\n        y_ratio     =       tan(radians(angle));\n    }\n    else if (angle >= 90.0 && angle < 180.0) { // II\n        x_tile_step = -1.0;\n        y_tile_step = -1.0;\n        \n        x_partial   = fract(ORIGIN.x);\n        y_partial   = fract(ORIGIN.y);\n        \n        x_ratio     = 1.0 / tan(radians(180.0 - angle));\n        y_ratio     =       tan(radians(180.0 - angle));\n    }\n    else if (angle <= -90.0 && angle > -180.0) { // III\n        x_tile_step = -1.0;\n        y_tile_step =  1.0;\n        \n        x_partial   = fract(ORIGIN.x);\n        y_partial   = 1.0 - fract(ORIGIN.y);\n        \n        x_ratio     = 1.0 / tan(radians(180.0 + angle));\n        y_ratio     =       tan(radians(180.0 + angle));\n    }\n    else if (angle < 0.0 && angle > -90.0) { // IV\n        x_tile_step = 1.0;\n        y_tile_step = 1.0;\n        \n        x_partial   = 1.0 - fract(ORIGIN.x);\n        y_partial   = 1.0 - fract(ORIGIN.y);\n        \n        x_ratio     = -1.0 / tan(radians(angle));\n        y_ratio     =       -tan(radians(angle)); \n    }\n    \n    bool v_hit = false;\n    bool h_hit = false;\n    \n    vec2 v_hit_point;\n    vec2 h_hit_point;\n    \n    bool is_v_tile_valid = true;\n    bool is_h_tile_valid = true;\n    \n    for (int step = 0; step < MAP_SIZE; step++) {\n        /* Vert */\n        if (!v_hit && is_v_tile_valid) {\n            vec2 v_check = vec2(ORIGIN.x + x_tile_step * (y_partial + float(step)) * x_ratio,\n                                ORIGIN.y + y_tile_step * (y_partial + float(step)));\n            vec2 v_tile  = vec2(trunc(v_check.x),\n                                trunc(v_check.y + y_tile_step * 0.5));\n            \n            is_v_tile_valid = v_tile.x >= 0.0 && v_tile.x < float(MAP_SIZE)\n                           && v_tile.y >= 0.0 && v_tile.y < float(MAP_SIZE);\n            \n            if (is_v_tile_valid) {\n                int ofs = int(v_tile.x) + int(v_tile.y) * MAP_SIZE;\n                if (MAP[ofs] == 1) {\n                    v_hit = true;\n                    v_hit_point = v_check;\n                }\n            }\n        }\n        \n        /* Horiz */\n        if (!h_hit && is_h_tile_valid) {\n            vec2 h_check = vec2(ORIGIN.x + x_tile_step * (x_partial + float(step)),\n                                ORIGIN.y + y_tile_step * (x_partial + float(step)) * y_ratio);\n            vec2 h_tile  = vec2(trunc(h_check.x + x_tile_step * 0.5),\n                                trunc(h_check.y));\n            \n            is_h_tile_valid = h_tile.x >= 0.0 && h_tile.x < float(MAP_SIZE)\n                           && h_tile.y >= 0.0 && h_tile.y < float(MAP_SIZE);\n            \n            if (is_h_tile_valid) {\n                int ofs = int(h_tile.x) + int(h_tile.y) * MAP_SIZE;\n                if (MAP[ofs] == 1) {\n                    h_hit = true;\n                    h_hit_point = h_check;\n                }\n            }\n        }\n        \n        if ((v_hit && h_hit)\n            || (!is_v_tile_valid && !is_h_tile_valid)) {\n            break;\n        }\n    }\n    \n    float v_hit_dist = 0.0;\n    float h_hit_dist = 0.0;\n    \n    if (v_hit) {\n        v_hit_dist = abs(x_tile_step * (v_hit_point.x - ORIGIN.x) / cos(radians(angle)));\n    }\n    \n    if (h_hit) {\n        h_hit_dist = abs(y_tile_step * (h_hit_point.y - ORIGIN.y) / abs(sin(radians(angle))));\n    }\n    \n    float fisheye_corr = cos(radians(angle - dir));\n    \n    /* TODO: remove this magic with xor */\n\tif (!xor(v_hit_dist <= h_hit_dist, (v_hit_point.y * h_hit_point.x > 0.0))) {\n    \treturn rc_result(v_hit_dist * fisheye_corr, fract(v_hit_point.x), true);\n    }\n    else {\n        return rc_result(h_hit_dist * fisheye_corr, fract(h_hit_point.y), false);\n    }\n}\n\nfloat get_wall_height(float dist)\n{\n    return MAX_DIST * HEIGHT_FAR / dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float DELTA = FOV / iResolution.x;\n    float dir = 180.0 * (2.0 * iMouse.x / iResolution.x - 1.0) + iTime * 3.0;\n    \n    float angle = dir + (FOV / 2.0) - DELTA * fragCoord.x;\n    rc_result res = ray_cast(dir, angle);\n    \n    float height = get_wall_height(res.dist);\n    \n    vec4 color = vec4(BG_COLOR_FLOOR, 1.0);\n    \n    if (uv.y > 0.5) {\n\t\tcolor = vec4(BG_COLOR_CEILING, 1.0);\n    }\n    \n    float lower_bound =       (1.0 - height) / 2.0;\n    float upper_bound = 1.0 - (1.0 - height) / 2.0;\n    \n    if (uv.y > lower_bound && uv.y < upper_bound) { // draw wall column\n        vec4 tex_color = texture(iChannel0, vec2(res.tex_pos, (uv.y - lower_bound) / height));\n        color = mix(tex_color, vec4(0.2, 0.2, 0.2, 1.0), res.is_vertical ? 0.0 : 0.3);\n    }\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}