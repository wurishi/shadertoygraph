{"ver":"0.1","info":{"id":"WtGSzm","date":"1582393204","viewed":69,"name":"romance ability","username":"Besisi","description":"ability test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ngon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define N 8\n#define pi 3.14159265\n\nvec2 calcPoint(float angle, float radius)\n{       \n\treturn vec2(radius*cos(angle)*0.5625f + 0.5f, radius*sin(angle) + 0.5f);\n}\n\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat drawCircle(vec2 p, float d, vec2 uv)\n{\n    return (distance(p, uv) <= d) ? 1. : 0.;\n}\n\n\nfloat sdNGonTriVersion( in vec2 p, in float r )\n{\n    // these 2 lines can be precomputed\n    float an = 6.2831853/float(N);\n    float he = r*tan(0.5*an);\n\t\n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an*floor((atan(p.y,p.x)+0.5*an)/an);\n    vec2  cs = vec2(cos(bn),sin(bn));\n    p = mat2(cs.x,-cs.y,cs.y,cs.x)*p;\n\n    float NGonLength = length(p-vec2(r,clamp(p.y,-he,he)));\n   \tvec2 v1 = vec2(r, he);\n    vec2 v2 = vec2(r, -he);\n    vec2 v3 = vec2(0.0f, 0.0f);\n    return sdTriangle(v1, v2, v3, p);\n}\n\nfloat sdNGon( in vec2 p, in float r )\n{\n    // these 2 lines can be precomputed\n    float an = 6.2831853/float(N);\n    float he = r*tan(0.5*an);\n    \n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an*floor((atan(p.y,p.x)+0.5*an)/an);\n    vec2  cs = vec2(cos(bn),sin(bn));\n    p = mat2(cs.x,-cs.y,cs.y,cs.x)*p;\n\n    float NGonLength = length(p-vec2(r,clamp(p.y,-he,he)));\n    // side of polygon\n    return NGonLength*sign(p.x-r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 PixelPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    PixelPos *= 2.0;\n    \n\tfloat distance = sdNGon( PixelPos, 1.0 );\n\n    vec3 color;\n    if(distance > .0f)\n    {\n        color = vec3(0.1,0.4,0.7);\n    }\n    else\n    {\n        color = vec3(0.0,0.0,1.0);\n    }\n    //col *= 1.0 - exp(-2.0*abs(d));\n    if(distance< 0.0f)\n\t\tcolor *= 0.8 + 0.2*cos(60.0*distance);\n\t//col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\t\n    float SmallDistance = sdNGonTriVersion( PixelPos, 0.5f );\n    if(SmallDistance< 0.0f)\n    {\n        color = vec3(1.0,1.0,1.0);\n    }\n        //color -= vec3(1.0) - sign(SmallDistance)*vec3(1.0, 0.0, 0.0);\n    \n\tfragColor = vec4(color,1.0);\n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy; \t\n    float angdiff = 0.8f;\n    float vel1 = 0.1f;\n    float ang1 =0.35f;\n    float vel2 = 0.15f;    \n    \n    //in uv space\n    vec2 p1 = calcPoint(ang1,vel1);\n    vec2 p2 = calcPoint(ang1+angdiff,vel1);\n    vec2 p3 = calcPoint(ang1+angdiff*2.f,vel1);\n    vec2 p4 = calcPoint(ang1+angdiff*3.f,vel1);\n    vec2 p5 = calcPoint(ang1+angdiff*4.f,vel1 -0.05f);\n    vec2 p6 = calcPoint(ang1+angdiff*5.f,vel1 +0.04f);\n    vec2 p7 = calcPoint(ang1+angdiff*6.f,vel1 -0.02f);\n    vec2 p8 = calcPoint(ang1+angdiff*7.f,vel1);\n    \n    float lines = drawLine(p1, p2, uv, 1.)\n        + drawLine(p2, p3, uv, 1.)\n    \t+ drawLine(p2, p3, uv, 1.)\n    \t+ drawLine(p3, p4, uv, 1.)\n    \t+ drawLine(p4, p5, uv, 1.)\n    \t+ drawLine(p5, p6, uv, 1.)   \n    \t+ drawLine(p6, p7, uv, 1.)\n    \t+ drawLine(p7, p8, uv, 1.)  \n    \t+ drawLine(p8, p1, uv, 1.);   \n    \n    float d = 0.002;\n    float dots = drawCircle(p1, d, uv)\n        \t\t+drawCircle(p2, d, uv)\n        +drawCircle(p3, d, uv)\n        +drawCircle(p4, d, uv)\n        +drawCircle(p5, d, uv)\n        +drawCircle(p6, d, uv)\n        +drawCircle(p7, d, uv)\n        +drawCircle(p8, d, uv);       \n\n\tfragColor -= vec4(lines*.6-dots, dots, dots, 1.);    \n    \n}","name":"Image","description":"","type":"image"}]}