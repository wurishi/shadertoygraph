{"ver":"0.1","info":{"id":"4scGDj","date":"1452098297","viewed":346,"name":"Ray March Dream","username":"kaswan","description":"ray marching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","hill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATION 128\n#define EPSILON 0.002\n#define FAR_Z 20.0\n\nfloat sphere(vec3 p)\n{\n    float r = 1.5;\n\n \treturn length(p) - r;\n}\n\nfloat sphere2(vec3 p)\n{\n    float r = 0.3;\n    \n    vec3 c = vec3(0.0, 0.5 * sin(iTime * 2.0), 0.0);\n \n    return length(p - c) - r;\n}\n\nfloat plane(vec3 p)\n{\n    float h = -1.1;\n    \n    return p.y - h;\n}\n\nfloat hillFunc(vec3 p)\n{\n    float r2 = p.x*p.x + p.z*p.z;\n\n\treturn p.y - 2.0 / (r2 + 1.0);\n}\n\nvec3 grad(vec3 p)\n{\n \tvec3 h = vec3(0.01, 0.0, 0.0);\n    \n    return vec3(hillFunc(p + h.xyy) - hillFunc(p - h.xyy),\n                hillFunc(p + h.yxy) - hillFunc(p - h.yxy),\n                hillFunc(p + h.yyx) - hillFunc(p - h.yyx));\n}\n\nfloat hill(vec3 p)\n{\n    float r2 = p.x*p.x + p.z*p.z;\n    \n\tfloat h = p.y - 2.0 / (r2 + 1.0);\n    \n   \tvec3 g = grad(p);\n    g = normalize(g);\n    \n    vec3 hv = vec3(0.0, h, 0.0);\n    \n    return dot(g, hv);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat scene(vec3 p)\n{\n    float d;\n    \n   \tfloat dh = hill(p);\n\n    p.x = mod(p.x, 6.0) - 3.0;\n    //p.y = mod(p.y, 6.0) - 3.0;\n    p.z = mod(p.z, 6.0) - 3.0;\n    \n    p.y -= 1.1;\n    \n   \t//d = hill(p);\n    //d = sphere2(p);\n    d = max(-sphere(p), udRoundBox(p, vec3(1.0, 1.0, 1.0), 0.2));\n    //d = min(d, plane(p));\n    //d = min(sphere(p), sphere2(p));\n    d = min(d, dh);\n\td = min(d, sphere2(p));\n    \n\treturn d;\n}\n\nbool Shadow(vec3 p, vec3 vl)\n{\n \tfloat d;\n    \n    p += vl * 0.5;\n\n    for (int i = 0; i < 64; i++)\n    {\n     \td = scene(p);\n            \n        if (d < EPSILON){\n        \treturn true;        \n        }\n        \n        p += d * vl;\n    }\n    \n    return false;\n}\n\nfloat softShadow(vec3 p, vec3 vl, float k)\n{\n    float res = 1.0;\n    \n    p += vl * 0.1;\n\n    for (int i = 0; i < 64; i++)\n    {\n     \tfloat d = scene(p);\n            \n        if (d < EPSILON){\n        \treturn 0.0;        \n        }\n        \n        res = min(res, d * k / 1.0);\n        \n        p += d * vl;\n    }\n    \n    return res;\n}\n\nvec3 Fog(vec3  rgb, float depth )\n{\n    float b = 1.1;\n\n\tfloat fogAmount = 1.0 - exp( -depth*b );\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    \n    return mix( rgb, fogColor, fogAmount );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float ao = 0.0;\n    float sca = 15.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = (0.01 + 0.015*float(i*i));\n        float dd = scene( pos + hr*nor );\n        ao += (hr-dd)*sca;\n        sca *= 0.5;\n    }\n    return 1.0 - clamp( ao, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    vec3 light = vec3(5.0 * cos(iTime * 1.0), 3.0, 5.0 * sin(iTime * 1.0));\n    //vec3 light = vec3(2.0, 3.7, 2.0);\n    \n    vec3 cam = vec3(0.0, 4.5, 24.0);\n    vec3 p = cam;\n    \n    uv += vec2(0.0, -0.9);\n   \n    vec3 t = normalize(vec3(uv, -4.0));\n\tfor (int i = 0; i < MAX_ITERATION; i++)\n    {\n        float d = scene(p);\n        \n        \n        if (d < EPSILON){\n\n        \t//float depth = 1.0 - distance(p, vec3(0.0, 0.0, 2.5)) / FAR_Z;\n        \tfloat depth = distance(p, cam) / FAR_Z;\n\n\t\t\tvec3 eps = vec3(EPSILON, 0.0, 0.0);\n            vec3 normal;\n        \t    \n            normal.x = scene(p + eps.xyz) - scene(p - eps.xyz);\n            normal.y = scene(p + eps.yxz) - scene(p - eps.yxz);\n            normal.z = scene(p + eps.zyx) - scene(p - eps.zyx);\n            \n            normal = normalize(normal);\n\n            vec3 vl = normalize(light - p);\n            vec3 re = reflect(-vl, normal);\n            \n            float specular = pow(max(dot(re, -t), 0.0), 20.0); \n \t\t\t\n            float diffuse = max(dot(normal, vl), 0.0);\n            //float diffuse = 0.5;\n            \n            //if (dot(vl, normal) < EPSILON) break;\n\t\t\t\n            float shadow;\n            //if (Shadow(p, vl)) shadow = 0.1;\n            shadow = softShadow(p, vl, 15.0);\n            //shadow = 1.0;\n            \n            diffuse *= calcAO(p, normal);\n            \n            float b = min(diffuse, shadow);\n            b += specular;\n\n            vec4 color = vec4(b,b,b, 1.0);\n            if (scene(p) < EPSILON){\n                color = b * texture(iChannel0, p.xz * 0.25, 0.0);\n            }\n                \n            \n\t\t\tfragColor = vec4(Fog(vec3(color.rgb), depth), 1.0);\n            \n            return;\n\t\t}\n\t\t\n\t\tp += d * t;\n    }\n    \n    fragColor = vec4(0.5, 0.6, 0.7, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}