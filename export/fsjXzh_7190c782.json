{"ver":"0.1","info":{"id":"fsjXzh","date":"1619645244","viewed":119,"name":"Infinite Snowflakes","username":"PQuinn","description":"A shader that makes random snowflakes","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","snowflakes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592654\n#define flake_radius_range .05\n#define flake_radius_min .05\n# define flake_speed .15\n# define num_flakes 20\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 cart2polar(vec2 cart){\n    float r = length(cart);        \n    float theta = atan(cart.y/cart.x);   \n    if (cart.x < 0. && cart.y > 0.)\n        theta +=  PI;    \n    if (cart.x < 0. && cart.y < 0.)\n        theta -= PI;    \n    if (theta < 0.)\n        theta += 2.* PI;        \n    return vec2(r,theta);\n}\n\nfloat snowflake(vec2 center, float radius, vec2 point, int i){ // a binary in/out check\n\n    float r1 = .5 + 5. * rand(vec2(i,1)) ; \n    float r2 = 1. + 4. * rand(vec2(i,2)); \n    float r3 = .4 * rand(vec2(i,3)); // controls thiness (higher = thinner)\n    float r4 = 6.*(rand(vec2(i,4)-.5)); // speed of rotation\n        \n    vec2 polar = cart2polar(point - center);\n    float theta = polar.y;\n    float r = polar.x;\n    if (r>radius) {return 0.;} //outside, return 0    \n    theta *= 6.;\n    \n    if (i % 2 == 0){\n        theta += iTime;\n        }\n    else{\n        theta -=iTime;\n    }\n    \n    float a = sin(theta); // ensure 6 fold rotational symmetry and rotation    \n    float b = cos(r1 * r/radius * 2. * PI);      \n    float c = sin(r2 * r/radius * 2. * PI);\n    \n    return step(r3, (a + b + c)/3.);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float gradient = uv.y;    \n    //uv = uv * 2. - vec2(1,1);      \n    uv.y = -uv.y; // flip coords so +y is down\n    uv.y += 1. + flake_radius_min + flake_radius_range; // offset so (0,0) is above top left and we won't see flake pop in\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect; // correct aspect ratio\n   \n    vec3 bg = mix(vec3(0,0,1), vec3(.2,.2,.2), gradient);\n\n \n    // Output to screen\n    fragColor = vec4(bg,1.0);\n        \n    \n    for (int i = 0; i<num_flakes; i++){\n        vec2 c = vec2(0, 5. * rand(vec2(i,1)));\n        float y = c.y + flake_speed * iTime * (.5 + .5*rand(vec2(i,i))); // fall speed\n        c.y  = mod(y, 2.);\n        int pass = int(floor(y/2.)); \n        \n        int flake_number = i +  pass * num_flakes; // ensure new flake everytime around\n        c.x = aspect *  rand(vec2(flake_number, .1));\n        float radius = flake_radius_min  + flake_radius_range * rand(vec2(flake_number, .2));\n        vec3 col = vec3(1,1,1) * snowflake(c, radius, uv, flake_number);\n\n        fragColor += vec4(col, 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}