{"ver":"0.1","info":{"id":"3tK3Wz","date":"1578684288","viewed":77,"name":"learn16","username":"schlaffi","description":"Using the tutorial> https://www.youtube.com/watch?v=zfcCHPeDOhU\nbased on> https://www.shadertoy.com/view/lt33z7 ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["dwdwd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nint MAX_MARCHING_STEPS = 100;\nfloat MIN_DIST = 0.1;\nfloat MAX_DIST = 50.0;\nfloat EPSILON = 0.01;\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n \n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    vec3 sp2 = samplePoint;\n    sp2.x = fract(sp2.x*0.5+1.0)/0.5-1.0;\n    sp2.z = fract(sp2.z*0.5+.5*(iTime))/0.5-1.0;\n    return length(sp2) - 0.4;\n}\n\nfloat lightSdf(vec3 samplePoint ) {\n    float l = length(samplePoint);\n    if ( l < 0.3 ) {\n    \treturn l+0.3;\n    } else {\n    \treturn l-0.3;\n    }\n}\n\n\nfloat planeSDF(vec3 sp) {\n\treturn abs(sp.y+cnoise(sp*5.0+iTime*vec3(0,1.0,0.0))/20.) ;\n}\n    \n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nvec2 sceneSDF(vec3 samplePoint) {\n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    \n    float stuff[10];\n    stuff[0] = lightSdf(samplePoint-light1Pos);\n    stuff[1] = lightSdf(samplePoint-light2Pos);\n    stuff[2] = sphereSDF(samplePoint);\n    stuff[3] = planeSDF(samplePoint);\n\n    float m=99999.0;\n    float mat=0.;\n    for(int i = 0; i<=3; i++) {\n        if( stuff[i] < m ) {\n            mat = float(i);\n            m = stuff[i];\n        }\n    }\n    \n    return vec2(m, mat);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    vec2 depth = vec2(start,0.);\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = sceneSDF(eye + depth.x * marchingDirection);\n        if (dist[0] < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        depth.y=dist.y;\n        if (depth.x >= end) {\n            return vec2(end,0.);\n        }\n    }\n    return vec2(end,0.);\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// light source material\nvec3 lightSource(vec3 lightColor, vec3 lightPos, vec3 p, vec3 eye){\n\treturn lightColor/pow(length(p-lightPos),1.0);\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 light1Pos, vec3 light2Pos, vec3 light1Intensity, vec3 light2Intensity) {\n    vec3 color =  k_a;\n\n    \n    color = color + 10.*light1Intensity/pow(length(p-light1Pos),2.0);\n    color = color + 10.*light2Intensity/pow(length(p-light2Pos),2.0);\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 dir = rayDirection(50.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 1.5 , 9.0);\n    vec2 dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    vec3 initColor = vec3(uv, 1.0-uv.y);\n\n    vec3 color = initColor;\n\n    if (dist.x > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n    } else {\n\n        // The closest point on the surface to the eyepoint along the view ray\n        vec3 p = eye + dist.x * dir;\n\n        vec3 K_a = vec3(0.5, 0.1, 0.1);\n        vec3 K_d = vec3(0.7, 0.5, 0.4);\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 200.0;\n\t\t\n        vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    \tvec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    \tvec3 light1Intensity = vec3(1., 0.4, 0.1);\n    \tvec3 light2Intensity = vec3(0.0, 0.4, 0.4);\n        \n        //color = phongIllumination(K_a, K_d, K_s, shininess, p, eye,  light1Pos, light2Pos, light1Intensity, light2Intensity);\n        float f = fract(dist.x*1.1);\n        color=  mix(vec3(0.), mix( vec3(1., 0., 0.), mix(vec3(1., 1., 0.), vec3(1., 1., 1.),f*3.-2.), f*3.-1. ), f*3. );\n        /*\n        if (dist.y==2.){\n            color = phongIllumination(K_a, K_d, K_s, shininess, p, eye,  light1Pos, light2Pos, light1Intensity, light2Intensity);\n        } else if (dist.y==3.) {\n            color = phongIllumination(vec3(0.0, 0., 0.), vec3(0.1, 0.1, 0.5), vec3(.5, .5, 1.), 50., p, eye, light1Pos, light2Pos, light1Intensity, light2Intensity);\n        } else if (dist.y==0.) {\n            color = lightSource(light1Intensity, light1Pos, p, eye);\n        } else if (dist.y==1.) {\n            color = lightSource(light2Intensity, light2Pos, p, eye);\n        }*/\n\n        //color *= estimateNormal(p);\n    }\n\n\n    float foctor = fract(dist.x/MAX_DIST);\n    color = color*(1.0-foctor)+foctor*initColor;//vec3(1.,.9,.8)/;\n    \n    //color=vec3(fract(dist));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}