{"ver":"0.1","info":{"id":"XlyfDG","date":"1543757748","viewed":208,"name":"[TDF18]Kanye West & Lil Pump","username":"yasuo","description":"\"I love it\" Make america great again!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","tdf","kanye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPEED 0.5\n#define PI 3.14159265359\n#define degToRad (PI * 2.0) / 360.0\n#define fmod(x,y)  x-y*floor(x/y)\n\n\nstruct Params {\n\tmat3 krot;\n\tmat3 lrot;\n\tmat3 staturot;\n\tfloat headSc;\n\tvec3 bodySc;\n\tfloat armSc;\n\tfloat legSc;\n\tfloat shoesSc;\n\tfloat floorSc;\n\tfloat statueSc;\n\n\tvec3 head;\n\tfloat bodyZ;\n\tfloat wallX;\n\tvec3 arm;\n\tvec3 leg;\n\tfloat shoesX;\n\tfloat shoesZ;\n};\n\nfloat random(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat randomRange (in vec2 seed, in float min, in float max) {\n\treturn min + random(seed) * (max - min);\n}\t\n\t\nfloat noise(vec2 p){\n\tconst int res = 16;\n\t\n\tp *= float(res);\n\tvec2 n = floor(p);\n\tvec2 f = fract(p);\n\t\n\tf = f * f * (3.0 - 2.0 * f);\n\t\n\tfloat n0 = random(n);\n\tfloat n1 = random(n + vec2(1.0, 0.0));\n\tfloat n2 = random(n + vec2(0.0, 1.0));\n\tfloat n3 = random(n + vec2(1.0, 1.0));\n\t\n\tfloat m0 = mix(n0, n1, f.x);\n\tfloat m1 = mix(n2, n3, f.x);\n\t\n\treturn mix(m0, m1, f.y);\n}\n\nmat3 matRotateY(float rad)\n{\n    return mat3(cos(rad), 0, -sin(rad),\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\tsin(rad), 0, cos(rad));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n    float a = sin(t*.2 + 1.5), b = sin(t*.2);\n    return vec2(a*2., a*b);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat statue( vec3 p, vec2 h )\n{\n\tconst float a = 0.566025;\n\tp.y = abs(p.y);\n    vec3 q = abs( p );\n    float dx = max( q.x - h.y, max( q.z * a + p.y * 0.5, -p.y ) - h.x * 0.5 );\n    float dz = max( q.z - h.y, max( q.x * a + p.y * 0.5, -p.y ) - h.x * 0.5 );\n    return max( dx, dz );\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nfloat cubicInOut(float t) {\n\tfloat p = 2.0 * t * t;\n\treturn t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nvec3 bodyTex(vec3 cl,vec3 lcl,vec2 uv) {\n\tvec2 wave = vec2(uv.x,sin(uv.x*6.0*PI)/10.0-0.5 );\n\tfloat diff = distance(uv,wave)*noise(uv);\n\treturn max(cl,smoothstep(0.1,0.01,diff))*lcl;\n}\n\nvec4 lilpumpDist(vec3 p, Params param){\n\tvec3 op=p;\n    float d=100.0;\n    \n    p.x = abs(p.x);\n    p -= vec3(0.35, 0.0, 0.0);\n    p.y-=0.4;\n    \n    d=100.0;\n    d = min(d,sdBox(p-vec3(0.0+param.leg.x,-0.65,0.9+param.leg.z),vec3(0.3+param.legSc,0.5,0.2)));\n\tvec4 leg = vec4(0.4,0.3,0.3,d);\n    p=op;\n    \n    op=p;\n    p.x = abs(p.x);\n    p -= vec3(0.15, -1.15, 1.5);\n    \n    d=100.0;\n\t\n\tfloat shoes =sdBox(p+vec3(-0.2+param.shoesX,-0.4,0.6+param.shoesZ),vec3(0.32+param.shoesSc,0.08,0.3));\n\td=min(d,shoes);\n    vec4 shoesdist = vec4(0.75,0.75,0.75,d);\n    p=op;\n    \n    op=p;\n\tp.y-=1.1;\n    \n    d=100.0;\n    d=min(d,sdBox(p-vec3(0.0,-0.55+sin(iTime*5.1)*0.03,0.9+param.bodyZ),vec3(0.7+param.bodySc.x,0.6+param.bodySc.y,0.3+param.bodySc.z)));\n\t\n\tvec4 body = vec4(bodyTex(vec3(0.6,0.3,0.3),vec3(0.9,0.9,0.9),p.xy), d);\n    p=op;\n    \n\top=p;\n    p.x = abs(p.x);\n    p -= vec3(0.86, 0.0, 0.0);\n    p.y-=1.05;\n    \n    d=100.0;\n    d=min(d, sdBox(p-vec3(0.0+param.arm.x,(-0.55+param.arm.y)+sin(iTime*5.0)*0.05,0.9+param.arm.z),vec3(0.15,0.65,0.3)));\n\tvec4 arm = vec4(0.55,0.3,0.3,d-0.0001);\n    p=op;\n    \n\top=p;\n\tp.y-=1.65;\n    \n    d=100.0;\n    d=min(d,sdBox((p-vec3(0.0,(-0.39+param.head.y)+sin(iTime*5.0)*0.05,0.9+param.head.z)),vec3(0.15+param.headSc,0.15+param.headSc,0.15+param.headSc)));\n\tvec4 head = vec4(0.95,0.75,0.6,d-0.0001);\n    \n    vec4 res1 = combine(leg,shoesdist);\n    vec4 res2 = combine(body,arm);\n    vec4 res3 = combine(head,res1);\n    vec4 res4 = combine(res2,res3);\n\n    return res4;\n}\n\nvec4 kanyeDist(vec3 p, Params param){\n\tvec3 op=p;\n    float d=100.0;\n    \n    p.x = abs(p.x);\n    p -= vec3(0.37, 0.0, 0.0);\n    p.y-=0.4;\n    \n    d=100.0;\n    d = min(d,sdBox(p-vec3(0.0+param.leg.x,-0.65,0.9+param.leg.z),vec3(0.3+param.legSc,0.5,0.2)));\n\tvec4 leg = vec4(0.3,0.3,0.3,d);\n    p=op;\n    \n    op=p;\n    p.x = abs(p.x);\n    p -= vec3(0.15, -1.15, 1.9);\n    \n    d=100.0;\n\tfloat shoes =sdBox(p+vec3(-0.2+param.shoesX,-0.4,0.8+param.shoesZ),vec3(0.32+param.shoesSc,0.08,0.2));\n\td=min(d,shoes);\n    vec4 shoesdist = vec4(0.7,0.7,0.7,d);\n    p=op;\n    \n    op=p;\n\tp.y-=1.1;\n    \n    d=100.0;\n    d=min(d,sdBox(p-vec3(0.0,-0.55+sin(iTime*5.1)*0.03,0.9),vec3(0.7+param.bodySc.x,0.6+param.bodySc.y,0.3+param.bodySc.z)));\n\tvec4 body = vec4(bodyTex(vec3(0.2,0.07,0.05),vec3(0.5,0.37,0.0),p.xy), d);\n    p=op;\n    \n\top=p;\n    p.x = abs(p.x);\n    p -= vec3(0.86, 0.0, 0.0);\n    p.y-=1.05;\n    \n    d=100.0;\n    d=min(d, sdBox((p-vec3(0.0+param.arm.x,(-0.55+param.arm.y)+sin(iTime*5.0)*0.05,0.9+param.arm.z)),vec3(0.15,0.65,0.3)));\n\tvec4 arm = vec4(0.12,0.05,0.05,d-0.0001);\n    p=op;\n    \n\top=p;\n\tp.y-=1.65;\n    \n    d=100.0;\n    d=min(d,sdBox(p-vec3(0.0,(-0.39+param.head.y)+sin(iTime*5.0)*0.05,0.9+param.head.z),vec3(0.15+param.headSc,0.15+param.headSc,0.15+param.headSc)));\n\tvec4 head = vec4(0.45,0.15,0.1,d-0.0001);\n\n    vec4 res1 = combine(leg,shoesdist);\n    vec4 res2 = combine(body,arm);\n    vec4 res3 = combine(head,res1);\n    vec4 res4 = combine(res2,res3);\n\n    return res4;\n}\n\nvec3 noiseTex(vec3 p){\n\tvec3 color = vec3(0.0);\n\tcolor += noise(p.xz) * 0.125;\n\tcolor += noise(p.xz * 2.0) * 0.125;\n\tcolor += noise(p.xz * 4.0) * 0.125;\n\tcolor += noise(p.xz * 8.0) * 0.125;\n\tcolor += noise(p.xz * 16.0) * 0.125;\n\tcolor += noise(p.xz * 32.0) * 0.125;\n\treturn color;\n}\n\nvec4 map(vec3 p,Params param){    \n    float t = 100.0;\n    \n\tvec3 oldp = p;\n\tp.z = mod(p.z+(iTime*SPEED), 0.5)-0.25;\n\n    vec3 floorp = (p-vec3(0.0,0.5,0.0));\n    float w = sdBox(floorp,vec3(3.6+param.floorSc, 0.01, 0.3));\n\n\tvec3 floorColor = noiseTex(floorp)*vec3(1.23);\n\n    vec4 floorDist = vec4(floorColor, w);\n    \n    p = oldp;\n    p.z = mod(p.z+(iTime*SPEED), 0.7)-0.35;\n\tp.x = abs(p.x);\n    p -= vec3(6.0+param.wallX, 2.0, 0.0);\n    \n    \n\tfloat box = sdBox(p,vec3(0.3,3.5,0.5));\n    float box2 = sdBox(p,vec3(0.5,1.5,0.2));\n    float wall = opS(box2,box);\n    \n    t = min(t, wall);\n\n\tvec3 wallColor = noiseTex(p.zxy)*vec3(2.63,2.6,2.65);\n    vec4 wallDist = vec4(wallColor, t);\n    \t\n    t = 100.0;\n    float sta = statue((p+vec3(0.2, 0.0, 0.0))*param.staturot,vec2(0.4+param.statueSc,0.1));\n    t = min(t, sta);\n    vec4 statueDist = vec4(0.85,0.82,0.85, t);\n    \n    t = 100.0;\n    t = min(t, sdBox(p+vec3(0.3, 0.0, 0.35),vec3(0.02,3.5,0.02)));\n    vec4 wallLine = vec4(0.9,0.9,0.9, t);\n\t\n\tvec4 lilpump = lilpumpDist((oldp+vec3(-1.5, -1.35, -7.0))*param.lrot,param);\n\tvec4 kanye = kanyeDist((oldp+vec3(1.5, -1.35, -6.0))*param.krot,param);\n\n\tvec4 res1 = combine(floorDist,wallDist);\n    vec4 res2 = combine(statueDist,wallLine);\n\tvec4 res3 = combine(lilpump,kanye);\n\tvec4 res4 = combine(res1,res2);\n\tvec4 res5 = combine(res3,res4);\n\n\treturn res5;\n}\n\nvec3 normalMap(vec3 p,Params param){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0),param).w - map(p + vec3( -d, 0.0, 0.0),param).w,\n\t\tmap(p + vec3(0.0,   d, 0.0),param).w - map(p + vec3(0.0,  -d, 0.0),param).w,\n\t\tmap(p + vec3(0.0, 0.0,   d),param).w - map(p + vec3(0.0, 0.0,  -d),param).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd, Params param){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c,param).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid rainbow(vec2 p, float size, vec3 color, inout vec3 dst){\n    float l = smoothstep(0.0,1.1,length(p - vec2( 0.0,  0.0)));\n    if(l < size)dst = color;\n}\n\nfloat slopeSaw(vec2 position){\n\tfloat y = position.x;\n\tfloat animVal = sin(iTime);\n\tfloat animVal2 = sin(iTime*0.1);\n\tfloat animVal3 = sin(iTime*0.2);\n\tfloat animVal4 = sin(iTime*0.3);\n\tfloat animVal5 = sin(iTime*0.4);\n\tfloat animVal6 = sin(iTime*0.5);\n\tfloat animVal7 = sin(iTime*0.6);\n\tfloat animVal8 = sin(iTime*0.7);\n\tfloat animVal9 = sin(iTime*0.8);\n\tfloat slope = smoothstep( y-0.8+animVal, y-0.8+animVal, position.y);\n\tslope += smoothstep( y-0.6+animVal2, y-0.6+animVal2, position.y);\n\tslope += smoothstep( y-0.4+animVal4, y-0.4+animVal4, position.y);\n\tslope += smoothstep( y-0.2+animVal, y-0.2+animVal, position.y);\n\tslope += smoothstep( y+animVal5, y+animVal5, position.y);\n\tslope += smoothstep( y+0.2+animVal6, y+0.2+animVal6, position.y);\n\tslope += smoothstep( y+0.4+animVal7, y+0.4+animVal7, position.y);\n\tslope += smoothstep( y+0.6+animVal8, y+0.6+animVal8, position.y);\n\tslope += smoothstep( y+0.8+animVal9, y+0.8+animVal9, position.y);\n\treturn slope;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n\tfloat uvy = mod(iTime*0.5,2.5)-1.0;\n\tif (p.y+uvy > 0.2 && p.y+uvy < 0.7) {\n\t\tp.x += sin(p.y*5.0)*0.1;\n\t}\n\n\t// glitch effects\n\tfloat sceneLength = 10.0;\n\tfloat scene = fmod(iTime,sceneLength);\n\tif(scene>7.0 && scene<8.0){\n\t\tfloat threshold = 0.3;\n\n\t\tfloat etime = sin(iTime)*70.0; \n\t\tfloat f = fract(etime * 0.01* 10.0);\n\t\tetime += cubicInOut(2.0 - exp(-f*0.2));\n\t\tetime *= 0.2;\n\t\tfloat maxOffset = threshold/2.0;\n\t\t\n\t\tfor(float i = 0.0; i < 10.0 * 0.3; i += 2.0){\n\t\t\tfloat sliceY = random(vec2(etime , float(i)));\n\t\t\tfloat sliceH = random(vec2(etime , float(i))) * 0.55;\n\t\t\tfloat hOffset = randomRange(vec2(etime , float(i)), -maxOffset, maxOffset);\n\t\t\tvec2 uvOff = p;\n\t\t\tuvOff.x += hOffset*etime*0.05;\n\t\t\tif ((step(-sliceY, p.y) - step(fract(-sliceY+sliceH), p.y)) == 1.0 ){\n\t\t\t\tp = uvOff;\n\t\t\t}\n\t\t}\n\t\tp.x += sin(p.y*etime)*0.2*cos(p.y*etime)*0.1;\n\t}\t\n\t\n\tvec3 camPos = vec3(0.0, 2.0, 10.0);\n\tvec3 Fwd = vec3(0.0, 0.0, -1.0);\n\tvec3 Up  = vec3(0.0,  1., 0.0);\n\t\n\tvec3 left = cross(Fwd, Up);\n\tfloat depth = 0.7;\n\tvec3 ray = normalize(left * p.x + Up * p.y + Fwd * depth);\n\n\tfloat amplitude = 3.;\n\tfloat frequency = 2.;\n\tfloat noiseVal = 0.0;\n\tnoiseVal = sin(frequency);\n\tfloat nt = 0.01*(-iTime*130.0);\n\tnoiseVal += sin(p.x*frequency*2.1 + nt)*4.5;\n\tnoiseVal += sin(p.x*frequency*1.72 + nt*1.121)*4.0;\n\tnoiseVal += sin(p.x*frequency*2.221 + nt*0.437)*5.0;\n\tnoiseVal += sin(p.x*frequency*3.1122+ nt*4.269)*2.5;\n\tnoiseVal *= amplitude*0.06;\n\n\tp.xy -= path(noiseVal)*0.1;\n\n\t// animation\n\tmat3 camRotY = matRotateY(((sin(iTime*2.0)*noiseVal))*degToRad)*matRotateY(((sin(iTime*2.0)*3.0))*degToRad);\n\tmat3 rotY = matRotateY((22.0-(sin(iTime*2.0)*10.0))*degToRad);\n\tmat3 rotY2 = matRotateY((-20.0+(sin(iTime*2.2)*10.0))*degToRad);\n\t\n\tParams param;\n\tfloat animTime = fmod(iTime,16.0);\n\tfloat hsc = 0.0;\n\thsc += cubicInOut(animscene(animTime, 1.0, 0.6))*0.2;\n\thsc -= cubicInOut(animscene(animTime, 5.8, 0.6))*0.2;\n\n\thsc += cubicInOut(animscene(animTime, 9.2, 0.6))*0.2;\n\thsc -= cubicInOut(animscene(animTime, 12.9, 0.6))*0.2;\n\n\tfloat headY = 0.0;\n\theadY -= cubicInOut(animscene(animTime, 9.2, 0.6))*0.35;\n\theadY += cubicInOut(animscene(animTime, 12.9, 0.6))*0.35;\n\t\n\tfloat headZ = 0.0;\n\theadZ += cubicInOut(animscene(animTime, 9.2, 0.6))*0.5;\n\theadZ -= cubicInOut(animscene(animTime, 12.9, 0.6))*0.5;\n\n\tfloat bsc = 0.0;\n\tbsc -= cubicInOut(animscene(animTime, 1.4, 0.6))*0.35;\n\tbsc += cubicInOut(animscene(animTime, 5.4, 0.6))*0.35;\n\n\tbsc -= cubicInOut(animscene(animTime, 9.0, 0.6))*0.3;\n\tbsc += cubicInOut(animscene(animTime, 13.0, 0.6))*0.3;\n\t\n\tfloat bscY = 0.0;\n\tbscY -= cubicInOut(animscene(animTime, 9.1, 0.6))*0.2;\n\tbscY += cubicInOut(animscene(animTime, 13.1, 0.6))*0.2;\n\n\tfloat bscZ = 0.0;\n\tbscZ += cubicInOut(animscene(animTime, 9.2, 0.6))*0.35;\n\tbscZ -= cubicInOut(animscene(animTime, 13.2, 0.6))*0.35;\n\n\tfloat lsc = 0.0;\n\tlsc -= cubicInOut(animscene(animTime, 1.2, 0.6))*0.15;\n\tlsc += cubicInOut(animscene(animTime, 5.6, 0.6))*0.15;\n\n\tlsc -= cubicInOut(animscene(animTime, 8.9, 0.6))*0.15;\n\tlsc += cubicInOut(animscene(animTime, 12.9, 0.6))*0.15;\n\n\tfloat lx = 0.0;\n\tlx -= cubicInOut(animscene(animTime, 1.2, 0.6))*0.16;\n\tlx += cubicInOut(animscene(animTime, 5.6, 0.6))*0.16;\n\n\tlx -= cubicInOut(animscene(animTime, 8.9, 0.6))*0.16;\n\tlx += cubicInOut(animscene(animTime, 12.9, 0.6))*0.16;\n\n\tfloat lz = 0.0;\n\tlz -= cubicInOut(animscene(animTime, 8.9, 0.6))*0.4;\n\tlz += cubicInOut(animscene(animTime, 12.9, 0.6))*0.4;\n\n\tfloat shoessc = 0.0;\n\tshoessc -= cubicInOut(animscene(animTime, 1.3, 0.6))*0.16;\n\tshoessc += cubicInOut(animscene(animTime, 5.6, 0.6))*0.16;\n\t\n\tshoessc -= cubicInOut(animscene(animTime, 8.9, 0.6))*0.16;\n\tshoessc += cubicInOut(animscene(animTime, 12.9, 0.6))*0.16;\n\n\tfloat shoesx = 0.0;\n\tshoesx += cubicInOut(animscene(animTime, 1.3, 0.6))*0.16;\n\tshoesx -= cubicInOut(animscene(animTime, 5.6, 0.6))*0.16;\n\n\tshoesx += cubicInOut(animscene(animTime, 8.9, 0.6))*0.16;\n\tshoesx -= cubicInOut(animscene(animTime, 12.9, 0.6))*0.16;\n\n\tfloat shoesz = 0.0;\n\tshoesz += cubicInOut(animscene(animTime, 8.9, 0.6))*0.4;\n\tshoesz -= cubicInOut(animscene(animTime, 12.9, 0.6))*0.43;\n\n\tfloat armx = 0.0;\n\tarmx -= cubicInOut(animscene(animTime, 1.7, 0.6))*0.35;\n\tarmx += cubicInOut(animscene(animTime, 5.2, 0.6))*0.35;\n\n\tarmx -= cubicInOut(animscene(animTime, 8.8, 0.6))*0.6;\n\tarmx += cubicInOut(animscene(animTime, 12.8, 0.6))*0.6;\n\n\tfloat army = 0.0;\n\tarmy -= cubicInOut(animscene(animTime, 8.8, 0.6))*0.7;\n\tarmy += cubicInOut(animscene(animTime, 12.8, 0.6))*0.7;\n\n\tfloat armz = 0.0;\n\tarmz += cubicInOut(animscene(animTime, 8.8, 0.6))*0.3;\n\tarmz -= cubicInOut(animscene(animTime, 12.8, 0.6))*0.3;\n\n\tfloat fsc = 0.0;\n\tfsc -= cubicInOut(animscene(animTime, 2.0, 0.6))*0.6;\n\tfsc += cubicInOut(animscene(animTime, 6.2, 0.6))*0.6;\n\n\tfsc -= cubicInOut(animscene(animTime, 9.0, 0.6))*0.6;\n\tfsc += cubicInOut(animscene(animTime, 13.2, 0.6))*0.6;\n\n\tfloat wx = 0.0;\n\twx -= cubicInOut(animscene(animTime, 2.3, 0.6))*0.6;\n\twx += cubicInOut(animscene(animTime, 6.0, 0.6))*0.6;\n\n\twx -= cubicInOut(animscene(animTime, 9.3, 0.6))*0.6;\n\twx += cubicInOut(animscene(animTime, 13.0, 0.6))*0.6;\n\n\tfloat bgsc = 0.0;\n\tbgsc += cubicInOut(animscene(animTime, 1.9, 0.6))*0.3;\n\tbgsc -= cubicInOut(animscene(animTime, 5.8, 0.6))*0.3;\n\n\tbgsc += cubicInOut(animscene(animTime, 8.9, 0.6))*0.3;\n\tbgsc -= cubicInOut(animscene(animTime, 12.8, 0.6))*0.3;\n\n\tfloat staturot = 0.0;\n\tstaturot += cubicInOut(animscene(animTime, 2.3, 1.0))*180.0;\n\tstaturot += cubicInOut(animscene(animTime, 6.0, 1.0))*180.0;\n\t\n\tstaturot += cubicInOut(animscene(animTime, 9.3, 1.0))*180.0;\n\tstaturot += cubicInOut(animscene(animTime, 13.0, 1.0))*180.0;\n\n\tfloat statueSc = 0.4;\n\tstatueSc -= cubicInOut(animscene(animTime, 2.3, 1.0))*0.4;\n\tstatueSc += cubicInOut(animscene(animTime, 6.0, 1.0))*0.4;\n\n\tstatueSc -= cubicInOut(animscene(animTime, 9.3, 1.0))*0.4;\n\tstatueSc += cubicInOut(animscene(animTime, 13.0, 1.0))*0.4;\n\n\tparam.krot = rotY;\n\tparam.lrot = rotY2;\n\tparam.staturot = matRotateY(staturot*degToRad);\n\tparam.headSc = hsc;\n\tparam.head = vec3(0,headY,headZ);\n\tparam.bodySc = vec3(bsc,bscY,bscZ);\n\tparam.legSc = lsc;\n\tparam.leg = vec3(lx,0,lz);\n\tparam.shoesSc = shoessc;\n\tparam.shoesX = shoesx;\n\tparam.shoesZ = shoesz;\n\tparam.arm = vec3(armx,army,armz);\n\tparam.floorSc = fsc;\n\tparam.wallX = wx;\n\tparam.statueSc = statueSc;\n\n\tfloat t, dist;\n\tt = 0.0;\n\tvec3 distPos = camPos;\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 60; i++){\n\t\tdistCl = map(distPos,param);\n\t\tdist = distCl.w;\n\t\tif(dist < 0.001){break;}\n\t\tt += dist;\n\t\tdistPos = (camPos + t * ray)*camRotY;\n\t}\n\n\tvec2 rainbowp = p;\n\tvec3 color;\n\tfloat shadow = 1.0;\n\tif(dist < 0.001){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(0.0, 1.0, 0.0);\n\t\tvec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n\t\tvec3 normal = normalMap(distPos,param);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 0.1, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light,param);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n\t\t// rainbow bg\n\t\tif(scene>7.0 && scene<8.0){\n\t\t\trainbowp.y+=slopeSaw((fragCoord.xy) / min(iResolution.x, iResolution.y))-5.0;\n\t\t}\n\t\t\n\t\trainbowp.x*=(0.55+bgsc);\n\t\t\n\t\trainbowp.y += sin(rainbowp.x*30.0+iTime*2.0)*0.3*cos(rainbowp.x*10.0+iTime*2.0)*0.2;\n\t\trainbowp.y += 0.05+(bgsc*0.2);\n\t\t\n\n\t\tvec3 rainbowbg = vec3(0.8)+(.1-length(p.xy)/3.);\n\t\tvec3 rcolor = rainbowbg;\n\t\trainbow (rainbowp, 0.95, vec3(1.0,0.0,0.0), rcolor);\n\t\trainbow (rainbowp, 0.9, vec3(1.0,0.6,0.0), rcolor);\n\t\trainbow (rainbowp, 0.85, vec3(1.0,1.0,0.0), rcolor);\n\t\trainbow (rainbowp, 0.8, vec3(0.0,1.0,0.0), rcolor);\n\t\trainbow (rainbowp, 0.75, vec3(0.3,0.3,0.8), rcolor);\n\t\trainbow (rainbowp, 0.7, vec3(0.7,0.7,1.0), rcolor);\n\t\trainbow (rainbowp, 0.65, vec3(0.8,0.0,1.0), rcolor);\n\t\trainbow (rainbowp, 0.6, rainbowbg, rcolor);\n\n\t\tcolor = rcolor*(rainbowbg*noiseTex(vec3(rainbowp.xy,rainbowp.y))*vec3(2.0));\n\t}\n\n\t// rendering result\n\tfloat brightness = 3.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n\t// cross hatch\n\tvec3 hacthcolor = vec3(dst.x*0.9,0.2,0.2);\n\tfloat hatchsize = 5.0;\n\tif (color.g < 0.3) {\n        if (mod(fragCoord.x + fragCoord.y, hatchsize) == 0.0) {\n            fragColor = vec4(hacthcolor, 1.0);\n        }\n    }\n     \n    if (color.g < 0.1) {\n        if (mod(fragCoord.x - fragCoord.y, hatchsize) == 0.0) {\n            fragColor = vec4(hacthcolor, 1.0);\n        }\n    }\n\n}","name":"Image","description":"","type":"image"}]}