{"ver":"0.1","info":{"id":"wscfD2","date":"1606005323","viewed":135,"name":"bicolor multicolor metaballs","username":"Mischawake","description":"combining multicolored metaballs with light based bicoloring","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define hsv2rgb(h) clamp( abs(mod( h*6.+vec3(0,4,2), 6.)-3.)-1., 0., 1. )\n\nfloat calcInfluence( vec4 ball, vec2 uv)\n{ \n    float d = distance(ball.rg, uv);\n    float inf = pow( ball.b/d, 3.0);\n    return  inf;   \n}\n\nfloat calcHeight( vec4 ball, vec2 uv )\n{\n \n   float d = distance(ball.rg, uv)/ball.b;\n   float h = pow( 1. - pow( d, 2.), 1./3. );\n   return h;\n    \n}\n\nvec3 calcNormal( vec4 ball, vec2 uv )\n{\n   \n    float eps = 0.00001;\n    \n    vec3 xp = vec3( uv.x + eps, uv.y, calcHeight( ball, vec2(uv.x + eps, uv.y) ) \n                   - vec3( uv.x - eps, uv.y, calcHeight( ball, vec2(uv.x - eps, uv.y) )  ) );\n    vec3 yp = vec3( uv.x, uv.y + eps, calcHeight( ball, vec2( uv.x, uv.y + eps) ) \n                   - vec3( uv.x, uv.y - eps, calcHeight( ball, vec2(uv.x, uv.y - eps) ) ) );\n    \n    return cross( xp, yp );\n}\n\n\nvec3 calcOldNormal( vec4 ball, vec2 uv )\n{\n    return vec3( ball.rg - uv, 0.12);      \n}\n\nvec3[] colors = vec3[]\n(   \n\n    hsv2rgb(273.0/360.0),\n   \thsv2rgb(0.022),\n    hsv2rgb(0.475),\n    hsv2rgb(306.0/360.0)\n);\n\n//for gradient?\nvec3[] colors2 = vec3[]\n(   \n\n\thsv2rgb(187.0/360.0),\n   \thsv2rgb(54.0/360.0),\n    hsv2rgb(26.0/360.0),\n    hsv2rgb(71.0/360.0)\n    \n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= 0.333;\n    vec4 mouse = iMouse / iResolution.yyyy;\n    mouse.x -= 0.333;\n    \n    \n    //settings to play with!\n    float threshold = 1.0;\n    float specularIntensity = 0.35;\n    float specularPower = 3000.0;\n    float rimIntensity = 60.0; //2\n    float rimPower = 4.0;\n    float aoIntensity = 0.6;\n    float ambientBrightness =  0.25;\n    float lightBrightness = 0.5;\n    float splashBrightness = 0.25;\n    float radiosity = 1.0;\n \n    \n    vec3 ambientColor = vec3(1.0);//hsv2rgb( 0.5 + iTime / 200.0 );\n    \n    vec3 lightColor = vec3(1.0);//hsv2rgb( iTime / 100.0 );\n    \n    bool rainbowMode = false;\n    \n\n   \t//balls\n    float rad = 0.1;\n    float rf = 0.;//0.005;\n    float jiggle = 0.;//sin(iTime*(2.0)) * 0.0125;\n    \n    vec4[] balls = vec4[]\n    (\n        \n        vec4(0.0 + jiggle,0.2 + jiggle, rad + sin(iTime * 4.) * rf, 3.),\n        vec4(0.0 - jiggle,0.4,rad + sin(iTime * 4. + 1.) * rf, 3.),\n        vec4(0.0,0.6 + jiggle,rad + sin(iTime * 4. + 2.) * rf, 2.),\n        vec4(0.0 + jiggle,0.8 + jiggle,rad + sin(iTime * 4. + 1.) * rf, 2.),\n        \n        vec4(0.2 + jiggle,0.2 + jiggle, rad + sin(iTime * 4.) * rf, 0.),\n        vec4(0.2 - jiggle,0.4,rad + sin(iTime * 4. + 1.) * rf, 3.),\n        vec4(0.2,0.6 + jiggle,rad + sin(iTime * 4. + 2.) * rf, 3.),\n        vec4(0.2 + jiggle,0.8 + jiggle,rad + sin(iTime * 4. + 1.) * rf, 0.),\n\n        vec4(0.4 + jiggle,0.2 - jiggle,rad + sin(iTime * 4. + 3.) * rf, 0.),\n        vec4(0.4 + jiggle,0.4,rad + sin(iTime * 4. + 4.) * rf, 2.),\n        vec4(0.4,0.6 + jiggle,rad + sin(iTime * 4. + 5.) * rf, 0.),\n        vec4(0.4 - jiggle * 3.,0.8+jiggle,rad + sin(iTime * 4. + 6.) * rf, 0.),\n\n        vec4(0.6,0.2 - jiggle,rad + sin(iTime * 4. + 7.) * rf, 1.),\n        vec4(0.6,0.4 - jiggle,rad + sin(iTime * 4. + 8.) * rf, 2.),\n        vec4(0.6 - jiggle,0.6 - jiggle,rad + sin(iTime * 4. + 9.) * rf, 2.),\n        vec4(0.6,0.8 - jiggle,rad + sin(iTime * 4. + 10.) * rf, 1.),\n\n        vec4(0.8 + jiggle,0.2 + jiggle,rad + sin(iTime * 4. + 11.) * rf, 2.),\n        vec4(0.8 + jiggle,0.4 - jiggle,rad + sin(iTime * 4. + 12.) * rf, 2.),\n        vec4(0.8,0.6 + jiggle,rad + sin(iTime * 4. + 13.) * rf, 1.),    \n        vec4(0.8,0.8 - jiggle,rad + sin(iTime * 4. + 14.) * rf, 1.),\n        \n        vec4(1.0 + jiggle,0.2 + jiggle,rad + sin(iTime * 4. + 11.) * rf, 2.),\n        vec4(1.0 + jiggle,0.4 - jiggle,rad + sin(iTime * 4. + 12.) * rf, 2.),\n        vec4(1.0,0.6 + jiggle,rad + sin(iTime * 4. + 13.) * rf, 1.),    \n        vec4(1.0,0.8 - jiggle,rad + sin(iTime * 4. + 14.) * rf, 0.),\n\n        vec4( mouse.xy,rad, 2.),\n        vec4( 0.95 * abs(vec2(sin(iTime*0.2345), cos(iTime*0.1234))), rad, 1.)\n        \n     );\n    \n    int ballCount = 26;\n    \n    int accumulatorCount = 4;\n    float[] accumulators = float[]\n    (\n    \t0.0,\n        0.0,\n        0.0,\n        0.0\n    );\n    \n    vec3[] normals = vec3[]\n    (\n    \tvec3(0),\n        vec3(0),\n        vec3(0),\n        vec3(0)\n    );\n    \n    vec2[] pos = vec2[]\n    (\n    \tvec2(0),\n        vec2(0),\n        vec2(0),\n        vec2(0)\n    );\n    \n    \n    int i;\n    //determine color with greatest influence\n    for( i = 0; i < ballCount; i++ )\n    {\n        int idx = int( balls[i].a );\n        float inf = calcInfluence( balls[i], uv );\n        accumulators[idx] += inf;\n        normals[idx] += calcOldNormal( balls[i], uv) * min(10.0, inf );\n        pos[idx] += (balls[i].rg - uv) * inf;\n    }\n    \n    float maxInf = 0.0;\n    int maxIdx = 0;\n    vec3 avgColor = vec3(0,0,0);\n    float totalInf = 0.0;\n    \n    for( i = 0; i < accumulatorCount; i++ )\n    {\n        if( accumulators[i] > maxInf )\n        {\n            maxInf = accumulators[i];\n            maxIdx = i;\n        }\n        \n        totalInf += accumulators[i];\n        avgColor += accumulators[i] * colors[i];\n    }\n    \n    avgColor /= totalInf;\n    \n    float influence = accumulators[maxIdx];\n    vec3 baseColor = colors[maxIdx];\n    \n  \tvec3 highlightColor = colors2[maxIdx];\n    \n    vec3 normal = normalize( normals[maxIdx] );\n   \n    \n    vec3 lightDirection = normalize( vec3(0.0,-1.0,-1.0));\n    \n    vec3 splashDirection = normalize( vec3(-1.0,-1.0,-1.0) ); \n    \n\n    vec3 color = vec3(1.0);\n    \n    vec3 ambient = ambientBrightness * ambientColor;\n   \n    \n    float lightDot = max(0.,dot( -normal, lightDirection) );\n    float splashDot = max(0.,dot( -normal, splashDirection) );\n  \n    \n    //splash\n    float splash = pow( splashDot, 2.0 );\n   \n    \n    //diffust\n    \n    vec3 diffuse1 = lightDot * lightBrightness * lightColor;\n    vec3 diffuse2 = splashDot * splashBrightness * vec3(1.0);\n\n    \n    // specular blinn phong\n    vec3 dir = normalize(lightDirection + vec3(0,0,-1.0) );\n    float specAngle = max(dot(dir, -normal), 0.0);\n    float spec = pow(specAngle, specularPower);\n    vec3 specular = lightColor * spec * specularIntensity;\n    \n  \n    //rim light\n    float rim = 1.0 - (dot ( vec3(0.,0.,-1.), -normal));\n    vec3 rimLight = vec3(1.0) * rimIntensity * pow (rim, rimPower);\n    \n    vec3 combinedBase = baseColor * (1. - splash) + splash * highlightColor;\n    \n\t//radiosity\n    combinedBase = mix( combinedBase, avgColor, rim * radiosity);\n    \n    color = (ambient + diffuse1 + diffuse2 + specular + rimLight) * combinedBase;\n    \n    //ao\n    float prox = (maxInf/totalInf);\n    prox = pow( smoothstep( 1.0, 0.35, prox), 3.0 );\n    vec3 aoColor = vec3(0.0);\n    color = mix( color , aoColor, prox * aoIntensity);\n    \n\t//shape\n    float aa = min( fwidth( influence ) * 1.5, 1.);\n   \tfloat smo = smoothstep( 0., aa, influence - threshold);\n    color = mix( ambientColor * ambientBrightness * 0.1, color, smo);\n\n    \n   \tcolor = pow( color, vec3(2.2) );\n    \n    \n    fragColor = vec4( color, 1.0 );\n    \n    \n}","name":"Image","description":"","type":"image"}]}