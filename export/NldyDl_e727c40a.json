{"ver":"0.1","info":{"id":"NldyDl","date":"1660771914","viewed":358,"name":"Hard Yet Flowing Techno","username":"Geopin","description":"VJ TECHNO BASIC REACTIVE","likes":2,"published":3,"flags":36,"usePreview":0,"tags":["raymarch","postprocessing","techno","vj"],"hasliked":0,"parentid":"MdlcDM","parentname":"Seeing Worlds"},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Freshlov3 Online Browser Techno VJ \n\n// Cabbibo's HSV\nvec3 hsv(float h, float s, float v)\n\n\n//CHANGE THE H+VEC3 Values below to change the colours\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 1.0, 9.0, 2.0 ) / 0.9 ) * 1.8 ) - 1.0 ), 0.0, 0.9 ), s ) * v;\n}\n\nvoid mainImage(out vec4 f, in vec2 w)\n{\n    vec2 u = w/iResolution.xy;\n    vec4 col = vec4(0.);\n    float PSD = pow(abs(texture(iChannel1, vec2(.5)).r), 2.);\n    \n    for (int i = 0; i < 25; i++)\n    {\n        // adapted from by iq https://www.shadertoy.com/view/MsKGWR\n        vec2 offset = .05*cos( 0.1*float(i) + PSD + iTime + vec2(0,.1));\n        vec4 t = texture(iChannel0, u*.8 + offset + vec2(.01))*.3;\n        col += t*5.;\n    }\n    \n    col.rgb = hsv(col.x * .1 + iTime*.9 + PSD, 1., 1.);\n    f = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float eps = 0.01;\nconst float far = 100.;\n\nfloat map(vec3 p)\n{\n    p.z -= iTime;\n    return length(mod(p, 3.)-1.)-.8;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(eps,0.5);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(uv, 1.);\n    vec3 rd = normalize(vec3(uv, -1.));\n    float t = 0.;\n    for (int i = 0; i < 10; i++)\n    {\n        float m = map(ro + rd * t);\n        t += m;\n        if (m < eps || t > far) break;\n    }\n \n    vec3 p = ro + rd * t;\n    vec3 n = calcNormal(p);\n    vec3 lp = vec3(5., 4., 5.);\n    vec3 ld = lp - p;\n    float len = length(ld);\n    ld /= len;\n    float diff = max(dot(ld, n), 0.);\n    vec3 col = vec3(1.) * diff;\n\tfragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}