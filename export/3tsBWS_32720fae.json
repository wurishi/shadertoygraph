{"ver":"0.1","info":{"id":"3tsBWS","date":"1598444035","viewed":138,"name":"DG Celtic Torc and reflection","username":"DG622","description":"this is all ray marched and based on the tutorial 'treefoil knots' from the Art of Code aka BigWings. Raymarched water reflecting on a ray  marched torus. I could not get the water to reflect off the torus though!!\nYou have to watch it for a minute or so ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["toruswaterreflectionraymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//this is care of a torus tutorial 'trteefoil knots' from Art of Code Aug 2020\n//and i have attempted to get a reflection from a raymarched image rather\n//than a pre formed texture. I have managed this for the reflection of the Torc on the water but have not managed\n//to get it the other way round despite a number of attempts. Argh!!\n\n\nfloat N21 (vec2 p){\n \tp = fract(p* vec2( 273.53, 375.47));\n    p+=dot(p, p + 27.357);\n    return fract(p.x*p.y);\n}\n\nfloat smoothNoise (vec2 uv){// this is essentiually a mixing function /tiling\n  uv.xy -= iTime*.57;\n    vec2 lv = fract(uv);//these 2 go together fract giving the fraction and floor the integer of the cells\n    vec2 id = floor(uv);  \n    lv = lv * lv *(3.0 - 2.0 *lv);//interpolation for dummies video but this is essentially a smoothstep\n    float bl =fract( N21(id));//bottom left// fract here for the sky goes with the N21 fract if using N21a dont need it\n    float br = N21(id + vec2(1, 0));//bottom right\n    float b = mix( bl, br, lv.x);//so mix them to get the bottom line using the local uv.x              \n    \n    float tl = N21(id + vec2(0, 1));//top left etc\n    float tr = N21(id + vec2(1, 1));\n    float t = mix( tl, tr, lv.x);       \n    return mix(b, t, lv.y);    \n}\n\nfloat smoothNoise2 (vec2 uv, float flag ){//layering\n   float c;\n    if(flag < 1.0){ c = smoothNoise(uv*4.);  // So (uv * frequency ) * Amplitude\n                  }else{c+= smoothNoise(uv* 8. ) * .5;//add another layer/octave, each time double the frequency \n    \t\t\t\t\t\t\t\t//and halve the amplitude\n    c+= smoothNoise(uv* 16. ) * .25;\n    c+= smoothNoise(uv* 32. ) * .125;\n    c+= smoothNoise(uv* 65. ) * .0625;\n                  }\n   \n    return c/2.5;\t\t\t\t\t\t//need to divide by a factor to make sure c does not breach 1.0\n}\n\n\nmat2 Rot (float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n    \n}\n\nfloat Wave (vec3 p){//por the water\n    \tfloat v_time = iTime*0.5;   \t\t\t\n    \tfloat wave;         \n  \t\tp.xz*=0.07;\n    \tp.x -= v_time* 0.1751;\n    \tp.z -= v_time* 0.357;     \t\t\t\t\t\n    \twave = sin((p.x+p.z)*0.7751)*0.5351 ;//x direction separate out from z (freq)*amplitude\n \t\t//wave+=sin(p.x*0.937)*1.773;\n  \t\twave += smoothNoise2(vec2(sin(p.x), sin(p.z)), 3.0);//higher resolution   \t\t\n   \t\t wave+=smoothNoise2(vec2(sin(p.x+0.13), sin(p.z+0.57)), 0.0);  //low resolution \nreturn wave;\n}\n\n\tfloat sphere (vec4 dim, vec3 p){\n\t\t\tfloat retValue = length(p - dim.xyz)-dim.w;\n\t\t\treturn retValue;\n\t\t\t\t}\nvec2 twister(vec3 p){//the torc\n    p.y -= 4.0;\n    \tfloat r1 = 2.6;//larger diameter\n        float r2 = 0.01;//thinner strands this for the band though\n    \t      \n    \tvec2 cp = vec2(length(p.xz*0.9)-r1, p.y);    \t  \n        float a;\n       \ta = atan(p.x, p.z);  \n    if(a  > -2.9 && a < 2.9 ){ //a runs form - pie to pie\n        cp*=Rot(a*19.0);//more curls\n        cp.y = abs(cp.y*1.5)-0.07;//* tighter (as in metal)twined, minus is closer/tighter\n    \tr2 = 0.1;\n        \n    } else cp = vec2(length(p.xz*0.9)-0.0, p.y);//so need to set cp diameter to zero;\n                 \n    cp.y = abs(cp.y) - 0.1;//this gives the central strand\n    return vec2(length(cp)-r2, 10.0);  //the y is just a fl;ag to identify this as thetorc  \n    \n}       \n    \n     vec2 GetDist(vec3 p, float flag){\n\t\tvec2 retVal;\n        vec2 torc;\n        float wave;\n        float sea;\n         \t\t\t//dome was going to have a raymarched dome over it all with cloud, did not get the right effect\n       \t\t\t\t//  float dSphere = sphere(vec4(0.0,8.0,0.0,20.5),p);\n       \t\t\t\t//  if(dSphere < 0.0){retVal.y = 3.0;//so if inside create a flag which will be liberated in main\n       \t\t\t\t//  }else retVal.y = 0.0;\n       \t\t\t\t//  dSphere = abs(dSphere);//make it hollow\n       \t\t\t\t\t\t\t//  float dPlane = dot(vec3(p.x,p.y+0.0,p.z), normalize(vec3 (0.0,1.0,0.0)));//the vec 3 is the normal of the plane\n       \t\t\t\t// if(p.y < 8.0) retVal.y = 0.0;//re set the flag if we are below the dome bottom\n       \t\t\t\t//  float dome = max(dSphere, -p.y+8.0) - 0.01;//max gives intersection of a plane, the number: thickness\n\t\t \n        //the Torc\n         torc = twister(p);         \n        \n         float dSphereR = sphere(vec4(0.75,3.9,-2.6,0.4),p);\n         float dSphereL = sphere(vec4(-0.75,3.9,-2.6,0.4),p);\n         float dTPlane = dot(vec3(p.x,p.y+wave*5.0,p.z+2.9), normalize(vec3 (0.0,0.0,-1.0)));//the vec 3 is the normal of the plane\n         \t\t\t\t\t\t         \t\t       \n         float d = max(dSphereR, dTPlane) - 0.01;//max gives intersection of a plane, the number: thickness\n\t\t float d2 = max(dSphereL, dTPlane);        \n         d = min(d, d2); \n         torc.x = min(torc.x, d)/2.0;//divide to prevent artifact at cost to speed      \n                 \n\t\t//xxx water\n     \twave = Wave(p);\n    \tfloat dwPlane = dot(vec3(p.x,p.y-2.5-wave,p.z), normalize(vec3 (0.0,1.0,0.0))); \n    \tsea = min(dwPlane, p.y);        \n      \n        if(torc.x < sea )retVal.y = torc.y;\n        retVal.x = min(sea, torc.x);         \n                      \n        return retVal;\n        }\n\n\n     vec2 RayMarch(vec3 ro, vec3 rd, float flag){//0.0 low detail, 3.0 most\n            float dO = 0.0;\n            vec2 retVal;\n            for(int i = 0; i < 100; i++){\n                vec3 p = ro + dO * rd;\n                retVal = GetDist(p, flag);\n               \n           \t\tfloat dS = retVal.x;\n                dO += dS;\n                if( dS < 0.01 || dO > 100.0){\n                    break;\n                    }\n              }\n          \tretVal.x = dO;\n            return retVal;           \n       }\n\n\t\tvec3 GetNormal (vec3 p){\n            vec2 e = vec2(0.01, 0.0);\n            float d = GetDist(p, 0.0).x; //the y carries the flag for being inside the sphere not needed here         \t\n          \n            vec3 n = d - vec3(GetDist(p-e.xyy, 0.0).x,GetDist(p-e.yxy,0.0).x, GetDist(p-e.yyx,0.0).x);           \n            n = normalize(n);\n            return n;           \n       }\n        vec2 GetLight(vec3 p){\n         \tvec3 lightPos = vec3( -15.0, 10.0, -1.0);\n\n         \t\t\t\t\t// lightPos.xz += vec2(sin(iTime*2.0), cos(iTime*2.0));\n            vec3 light = normalize(lightPos - p);\n            vec3 n = GetNormal(p);           \n            vec2 dif = vec2(clamp(dot(n,light), 0.0, 1.0), 0.0);// so no negative numbers, last one just a value\n            //for the shadow\n            float retVal  = RayMarch(p + n * 0.01 * 3.0, light, 3.0).x;//this 3.0 is a work around second 3 is high detail\n            float d = retVal;\n            if (d < length (lightPos - p )) {dif.x *= 0.7;//faint shadow\n                                           \tdif.y = 10.0 ;//use as flag fopr reflectioon\n          }else dif.y = n.y;//ie normal elevation\n          \n           // dif.x*=0.8;//dimm it a little             \n            return dif;\n        }\n  \nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    \t\tvec2 uv = (fragCoord/iResolution.xy)*2.0-1.0;   \t\t\t                \n   \t\t\tvec2 m = iMouse.xy/iResolution.xy;   \n    \n    \t\tvec2 st = vec2( atan(uv.x, uv.y), length(uv));//the ploar coords\n    \n    \t\tvec3 RGB = vec3(0.0);\n    \t\tvec3 RGB1 = vec3(0.83, 0.69, 0.22);//gold\n    \t\tvec3 RGB2 = vec3(0.621, 0.273, 0.277);//reddish\n    \t\tvec3 RGBblue = vec3(0.05, 0.13, 0.29);\n    \t\tvec3 RGBgreen = vec3(0.05, 0.27, 0.35);\n    \t\tvec3 RGBwater = vec3(0.0);\n     \t\tfloat c;\n    \t\t\t\t\t// vec3 LightCol = vec3(0.15, 0.1, 0.1);\n    \t\tvec3 col = vec3(0.0);    \n    \t\t\n    \t\tvec3 ro = vec3(0.0+sin(iTime*0.2), 8.0, 2.0+cos(iTime*0.3));//    for the water was vec3 ro = vec3(15.0 , 15.0 ,-15.0  );\n    \t\t\t\t\t//\tro.yz *= Rot(-m.y*3.14+1.);\n    \t\t\t\t\t\t//ro.xz *= Rot(-sin(ro.x*iTime)*6.2831);    \n    \t\tvec3 rd = GetRayDir(uv, ro, vec3(0), 1.0);    \t\t\n            vec2 d = RayMarch(ro,rd, 0.0);\t//y is a flag 3.0 if inside the dome otherwise 0.0\t\t   \n            vec3 p= ro+rd*d.x;   \n            vec2 diff = GetLight(p);\n    \n    \t\tRGBwater = mix(RGBblue, RGBgreen, smoothstep(0.05, 0.6, diff.y));//mix green and blu via the normal    \n    \t\t\t\t\t\t\t\t//gives a dome but need to zoom out\n   \t\t\t\t\t\t\t\t\t//\tst = vec2(atan(p.x ,p.y), length(p.xy));//the polar coords for the dome        \n    \t\t\t\t\t\t\t\t//if (d.y>2.0 && d.y<4.0) \n        \t\t\t\t\t\t\t//\t{c = max(smoothstep(0.9,-.100,st.y),smoothNoise2(st, 3.0)); //inside the dome use polar coords for the cloud\n        \t\t\t\t\t\t\t//   \t col =vec3(c);//if in the dome show sky\n         \t\t\t\t\t\t\t//   } else {col += vec3(RGBwater+diff.x); //the water\n            col += vec3(RGBwater+diff.x); //the water\n    \t\n           \n    \t\t//reflection of torc on the water\n            vec3 n = GetNormal(p);\n       \t\tvec3 r = reflect (rd, n);\n            float ref = RayMarch(p+0.1, r, 0.0).x;// the 0.0 was a flag that i tried to use to get thje water reflected on the torc did not work\n            if (ref < length( p-r ))col=min(col, RGB1*ref);//blends better than just adding\n                  //xxx\n            //the torc                               \n    \t\tif(d.y > 9.0){col = vec3(RGB1+diff.x)*0.47; //ie d.y tells us this is the torc\n            float spec = max (0.0, r.y);\n    \t\tcol+=spec*spec*spec*0.5;\n                 }\n            \n    //try as i might could not get the water to reflect off the Torc        \n    \n    \t//col = pow(col, vec3(0.4545));   //gamma correction bit washed out for this                 \n            fragColor = vec4(col, 0.1);\n}","name":"Image","description":"","type":"image"}]}