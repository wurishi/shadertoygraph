{"ver":"0.1","info":{"id":"lcB3Dy","date":"1704569944","viewed":38,"name":"culegamer raymarcher v2","username":"CuleGamer","description":"i tried to make a better raymarcher","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rotate(vec3 vector,vec3 angle)\n{\n    vec3 cosA = cos(angle);\n    vec3 sinA = sin(angle);\n    return mat3(1.,0.,0.,0.,cosA.x,-sinA.x,0.,sinA.x,cosA.x) * mat3(cosA.y,0.,sinA.y,0.,1.,0.,-sinA.y,0.,cosA.y) * mat3(cosA.z,-sinA.z,0.,sinA.z,cosA.z,0.,0.,0.,1.) * vector;\n}\nfloat sdPlane(vec3 pos, float planeHeight)\n{\n    return pos.y - planeHeight + cos(pos.z);\n    \n}\nfloat sdSphere(vec3 pos, vec3 posSphere, float radius)\n{\n    return distance(pos, posSphere) - radius;\n}\nfloat signedDist(vec3 pos)\n{\n    return min(sdPlane(pos,0.0),sdSphere(pos,vec3(0.0,0.0,1.0),0.5));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uvMouse = 4.0 * (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec3 cameraRot = vec3(0.,uvMouse.x,0.);\n    vec3 sunVec = vec3(0.0,1.0,0.0);\n    const int iterations = 100;\n    const float distThreshold = 0.01;\n    vec3 cameraPos = rotate(vec3(0.,uvMouse.y,-1.0),cameraRot);\n    vec3 cameraVec = normalize(rotate(vec3(uv.x,uv.y+uvMouse.y,0.),cameraRot) - cameraPos);\n    vec3 rayPos = cameraPos;\n    vec3 col = vec3(dot(cameraVec * 0.25,sunVec));\n    for (int i = 0; i < iterations;i++)\n    {\n        rayPos += cameraVec * signedDist(rayPos);\n    }\n    vec3 terrainNormal = normalize(cross(vec3(0.0,-sin(rayPos.z),1.0), vec3(1.0,0.0,0.0)));\n    float diffuseLighting = dot(terrainNormal,sunVec);\n    float specularLighting = dot(0.5 * (-cameraVec - sunVec),terrainNormal);\n    if (signedDist(rayPos) < distThreshold)\n    {\n        col = vec3(diffuseLighting) * texture(iChannel0,rayPos.xz).xyz + (0.5 * (specularLighting+1.0));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}