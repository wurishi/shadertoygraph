{"ver":"0.1","info":{"id":"4cVSzt","date":"1732455902","viewed":273,"name":"Seismic charge sound","username":"Dave_Hoskins","description":"SOUND ON!\nTo me, it sounded like they used FM to create the sound, so I tried it on Shadertoy first.\nNo EQ or FX added. Only a wave shaper.\nIf anyone wants to add the plasma ball and/or the asteroids...?  Please fork it!\n\n","likes":24,"published":3,"flags":8,"usePreview":0,"tags":["raytracing","fmsynthesis","seismiccharge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 cameraPos, cameraTar;\n\nfloat ring(vec3 p, vec3 dir)\n{\n    float e = (iTime - T_RING)*2.5;\n    // Check for out of bounds...\n    if (dir.y > 0.0 || e < 0.0) return -1.0;\n    \n    // Project onto plane then do a 2D ring..\n    float n = (-p.y)/dir.y;\n    vec2 loc = p.xz + dir.xz * n;\n\n\n    float d = length(loc)-e;\n    \n    float r = smoothstep(1.0, .9, d) * squaredstep(-5., .0, d)*.25;\n    //\n    r += smoothstep(.9, 1., d) *smoothstep(1.1, 1., d);\n\n    return r;\n}\n\n\nvec3 getCamera(vec2 uv)\n{\n\n\tcameraPos = vec3(4, .5, -4);//cameraPath(gTime + 0.0);\n\tcameraTar = vec3(0,0,0);\n\tfloat roll = 0.4 - .3*cos(iTime*.3);\n\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cw = normalize(cameraTar-cameraPos);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return normalize(uv.x*cu + uv.y*cv + cw);\n}\n\nfloat lightGlow(vec3 light, vec3 ray)\n{\n    float n = dot(light, ray);\n    return pow(abs(n*.2),10.)*1.;\n\n}\nfloat flashAt(float v, float s, float e)\n{\n    return smoothstep(v-s, v, iTime) * smoothstep(v+e, v, iTime);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coords for aspect correction \n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 dir = getCamera(uv);\n\n    vec3 col = vec3(0);\n    \n    float bri = ring(cameraPos, dir);\n    bri = bri * smoothstep(RING_FADE+5.0, RING_FADE, iTime);\n    if (bri >= 0.) col += vec3(.0,bri*.5,bri);\n    \n    bri  = flashAt(T_ANTICIP-.1, .1, .03)*.8;\n    bri += flashAt(T_ANTICIP, .1, .04)*.8;\n    bri += flashAt(T_RING-.2, .1, .05)*.5;\n    bri += flashAt(T_RING, .2, .3)*.25;\n    float bri2 = smoothstep(T_ANTICIP+.2, T_ANTICIP+.6, iTime) * smoothstep(T_ANTICIP+1.8, T_ANTICIP+.6, iTime) *.2;\n    bri+=bri2;\n    col += lightGlow(-cameraPos, dir) * bri * vec3(.3, .7, 1.0); \n\n    \n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// By Dave Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define PHI atan(1.0)*8.0\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 noise21sou(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return  mix( hash21(p), hash21(p + 1.0), f)-.5;\n    \n}\n//----------------------------------------------------------------------------------------\n\nvec2 noise22sou(vec2 x)\n{\n    const vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash22(p),          hash22(p + add.xy),f.x),\n                   mix( hash22(p + add.yx), hash22(p + add.xx),f.x),f.y);\n    return res-.5;// -.5 Used for sound\n}\n\n//----------------------------------------------------------------------------------------\n// Fractal Brownian Motion...\nvec2 FBM22(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    \n    float a = .6;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += noise22sou(x * a) / a;\n        a += a;\n    }\n     \n    return r;\n}\n\n\n//---------------------------------------------------------------------------------------------------\n\n// The original sounded like frequency modulation, rather than a delay line to me...\n// FM plus two saws at G#ish\nfloat twang(float t)\n{\n    \n    float s = sin(t * 51.913* PHI);\n    float a = sin((t * 104.* PHI) + s * 22.);\n    float v = exp(-t*.75)*1.2;\n    float saw = (1.0-fract(51.9* t+.1))-.5;\n    float saw2 = (1.0-fract(103.2* t))-.5;\n    return a * v + saw*v *.5 * saw2 * v*.4;\n}\n\n//---------------------------------------------------------------------------------------------------\nvec2 explosion(float t)\n{\n    if (t == 0.0f) return vec2(0.0);\n    vec2 n1 = noise21sou(103. * t) + noise21sou(206. * t);\n    vec2 n2 = noise21sou(1700.*t) + noise21sou(901.*t);\n    vec2 n3 = noise21sou(4400.*t) + noise21sou(2050.*t);\n    float v2 = exp(-t*.4) + exp(-t*4.0);\n    float v3 = exp(-t*6.) * 5.0;\n    vec2 ret = n1 * v2;\n    ret += n2 * v2;\n    ret += n3 * v3;\n\n    return ret;\n}\n\n//---------------------------------------------------------------------------------------------------\nvec2 seismicCharge(float time)\n{\n    vec2 audio = vec2(.0);\n    float t_exp = max(time-T_RING, 0.0);\n    // Anticipate...\n    float v = linearstep(T_ANTICIP, T_RING, time) * linearstep(T_RING+1.0, T_RING, time);\n    float add = sin(51.913 * PHI * time) * v;\n    add *= 1.5 * smoothstep(0.0, 1.4, time);\n    audio += add;\n\n    // Twang and splodey...\n    audio += vec2(twang(t_exp), twang(max(t_exp-.004,0.0)));\n    audio += explosion(t_exp);\n\n    // Noise zoom down sound...\n    // Getting pitch sweeps is an interesting problem, but I just F'd around until it sounded OK. ðŸ˜ƒ\n    // The best part is the stereo chorus effect, created by off-setting the time very slightly in each channel....\n    // It makes a nice & shiny rocket sound.\n    \n    v = smoothstep(2.0, 3.0, t_exp) * smoothstep(6., 3., t_exp); // ...Volume envelope first\n    float p  = 14000.0 * linearstep(15.0, 0.0, t_exp)*.4;\n    audio +=( noise21sou(t_exp*p) + noise21sou((t_exp+0.004)*p))* v;\n\n    // Second zoomie..\n    p  = 4000.0 * linearstep(8.0, 0.0, t_exp*.4)*.6;\n    v = smoothstep(1.0, 3.0, t_exp)  * squaredstep(13.0, 3.0,t_exp)*.7; //... Volume envelope\n    audio +=( noise21sou(t_exp*p) + noise21sou((t_exp+0.003)*p))* v;\n    \n    return audio;\n \n}\n\n//---------------------------------------------------------------------------------------------------\nvec2 mainSound( in int samp,float time)\n{\n    vec2 audio = vec2(.0);\n    \n\n     audio += seismicCharge(time);\n\n     \n    // This is for loudness (also distortion), like Gamma correction for the ears! (not really)...\n    // Remember to clamp first...\n    audio = clamp(audio, -1.0, 1.0);\n    audio = 1.5*audio-.5*audio*audio*audio;\n     \n    return audio;\n    \n    \n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"//----------------------------------------------------------------------------------------\n//#define T_FLYING 3.0\n#define T_ANTICIP  .5\n#define T_RING   1.5\n#define RING_FADE 5.0\n\n//----------------------------------------------------------------------------------------\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise11(float x)\n{\n    float f = fract(x);\n    x = floor(x);\n    x = mix(hash11(x),hash11(x+1.0), f);\n    return x;\n}\n\nfloat noise12(vec2 x)\n{\n    const vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( hash12(p),          hash12(p + add.xy),f.x),\n                   mix( hash12(p + add.yx), hash12(p + add.xx),f.x),f.y);\n    return res;// -.5 Use for sound\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat linearstep(float edge0, float edge1, float x) \n{\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);;\n}\n\n//----------------------------------------------------------------------------------------\nfloat squaredstep(float edge0, float edge1, float x) \n{\n    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return x*x;\n}\n\n//----------------------------------------------------------------------------------------\nfloat sphere( in vec3 p, in float r)\n{\n    return  length(p)-r;\n}\n\nfloat torus( in vec2 p, in float ra, float rb )\n{\n    return  abs(length(p)-ra) - rb;\n}\n\nfloat FBM12(vec2 x)\n{\n    float r = 0.0;\n    \n    float a = .5;\n    \n    for (int i = 0; i < 5; i++)\n    {\n        r += noise12(x) * a;\n        a *= .53;\n        x *= mat2(1.4, .3, -.3, 1.4)*3.;\n    }\n     \n    return r;\n}\n\n\n\n\n","name":"Common","description":"","type":"common"}]}