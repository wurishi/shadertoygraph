{"ver":"0.1","info":{"id":"wlVXWc","date":"1583775089","viewed":237,"name":"Path Traced Spheres","username":"spalmer","description":"fork of [url]https://shadertoy.com/view/wtGGD3[/url] by alro","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytrace","pathtrace","occlusion","brdf","reflect","refract","spectral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BufferA iChannel0\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec4 c = texelFetch(BufferA, ivec2(p), 0);\n    // accumulated color divided by the number of iterations\n    // in alpha channel which is incremented each frame\n    //c.rgb /= c.a; // now normalized in BufferA\n    // tonemap all the way to sRGB gamut - see http://shadertoy.com/view/tlVXD3\n    c.rgb = 7./6.*(c.rgb / (c.rgb + 1./6.));\n    float bn = texelFetch(iChannel1, ivec2(p), 0).g; //random(p); //\n    c.rgb += .7/256. * vec3(bn * 2. - 1.); // screen space dither to help prevent buffer quantization banding\n\to = vec4(c.rgb, 1);    \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Path tracer into BufferA\n// fork of https://shadertoy.com/view/wtGGD3 by alro\n// seems related to https://shadertoy.com/view/MtycDD by reinder\n// ultimately due to Peter Shirley's \"Ray Tracing In One Weekend\"\n// http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\n// https://raytracing.github.io\n// Now much more interactive and antialiased.\n// I replaced the camera and the tone mapping.\n// Dielectrics now support albedo \"tint\" through its traced thickness, and spectral refraction.\n// Light and Fog (just tints for now) types too.\n// can use a dark \"light\" for general emissive colors\n// in 3d PBR, real lights should be very bright to appear to illuminate things properly,\n// like at least 5, maybe 10 or higher!\n\nconst int MAXIMUM_BOUNCE = 4; //6; //8; //4; //5; //3; //7; //\n\nconst vec3 L = normalize(vec3(0,.2,.9)); // main shadow trace direction\nconst vec3 sunColor = .2 * vec3(1,.9,.8);\nconst vec3 Lp = vec3(1, 1.8, -.7); // main point light source position for shadows\n\nconst int LIGHT = 0, LAMBERTIAN = 1, METAL = 2, DIELECTRIC = 3, FOG = 4; // enum surfacetype\n\nstruct Sphere \n{\n    vec3 center;\n    float radius;\n    int material; // surfacetype\n    vec3 albedo;\n    // Fuzz for metal, refraction index for dielectrics, density for fogs\n    float variable;\n};\n    \nconst int OBJECT_COUNT = 10; //6; //5; //\n\nSphere[OBJECT_COUNT] spheres;\n\nvoid InitScene()\n{    \n//\tspheres[0] = Sphere(vec3(0.0,-100.5,-1.0), 100., LAMBERTIAN, vec3(.8, .8, .0), .0);\n//    spheres[0] = Sphere(vec3(0.0,-100.5,-1.0), 100., LAMBERTIAN, vec3(.8, .8, .0), .0);\n    spheres[0] = Sphere(vec3(0.0, -1000., 0.0), 1000., LAMBERTIAN, vec3(.3), .0);\n #if 1\n    // Lambert scene\n    spheres[1] = Sphere(vec3(2,.5,-2), .5, LAMBERTIAN, vec3(.8, .3, 0.3), .0);\n    spheres[2] = Sphere(vec3(1,.5,0), .5, LAMBERTIAN, vec3(.8, .6, .2), .0);\n    spheres[3] = Sphere(vec3(-.9,.7,-.3), .7, LAMBERTIAN, vec3(.8, .8, .8), .7); // METAL? too many!\n    spheres[4] = Sphere(vec3(2.2, .25, -.5), .25, LAMBERTIAN, vec3(1,0,0), .0);\n #elif 0\n    // Metal scene\n    spheres[1] = Sphere(vec3(2,.5,-2), .5, LAMBERTIAN, vec3(.8, .3, 0.3), .0);\n    spheres[2] = Sphere(vec3(1,.5,0), .5, METAL, vec3(.8, .6, .2), 1.);\n    spheres[3] = Sphere(vec3(-.9,.7,-.3), .7, METAL, vec3(.8, .8, .8), .3);\n    spheres[4] = Sphere(vec3(2.2, .25, 1.5), .25, METAL, vec3(0,1,1), .0);\n #elif 0\n    // Dielectric scene\n    spheres[1] = Sphere(vec3(0,.5,0), .5, DIELECTRIC, vec3(.1, .2, .5), .0);\n\tspheres[2] = Sphere(vec3(1,.5,0), .5, METAL, vec3(.8, .6, .2), .3);\n\tspheres[3] = Sphere(vec3(-1.5,.48,.5), .48, DIELECTRIC, vec3(1,0,1), 1.5);\n\tspheres[4] = Sphere(vec3(-0.,.45,-1), .45, DIELECTRIC, vec3(1,1,0), 1.3);\n //\tspheres[4] = Sphere(vec3(-0.,.45,-1), -.45, DIELECTRIC, vec3(1,1,1), 1.5); // inside out!! weird.\n #elif 0\n    // variant scene - hollow, etc.\n    spheres[1] = Sphere(vec3(2, 1, 0), 1., DIELECTRIC, vec3(.7,1,.7), 1.5); // green glass\n    //spheres[1] = Sphere(vec3(2, 1, 0), 1., DIELECTRIC, vec3(.8,1,.9), 1.3); // water?\n    //spheres[2] = Sphere(vec3(2, 1, 0), -.95, DIELECTRIC, vec3(1), 1.5); // \"hollow\" inside\n    //spheres[2] = Sphere(vec3(-.5, .4, 2), -.37, DIELECTRIC, vec3(1), 2.4); // \"hollow\" inside\n    spheres[2] = Sphere(vec3(-2, 1, 0), 1., DIELECTRIC, vec3(.1, .2, .5), 1.07);\n    spheres[3] = Sphere(vec3(0, 1, 0), 1., METAL, vec3(.7, .6, .5), .5); // fuzzy metal\n    spheres[4] = Sphere(vec3(2.2, .25, 1.5), .25, DIELECTRIC, vec3(.9,.0,.0), 2.4);\n #else\n    // assortment\n    spheres[1] = Sphere(vec3(2, 1, 0), 1., DIELECTRIC, vec3(.8,1.,.9), 1.5); // glass\n    spheres[2] = Sphere(vec3(-2, 1, 0), 1., LAMBERTIAN, vec3(.1, .2, .5), .0);\n    spheres[3] = Sphere(vec3(0, 1, 0), 1., METAL, vec3(.7, .6, .5), .0);\n    spheres[4] = Sphere(vec3(2.2, .25, 1.5), .25, LAMBERTIAN, vec3(0,1,1), .0);\n #endif\n    //spheres[5] = Sphere(vec3(1, .35, -1.4), .35, LAMBERTIAN, vec3(.5,0,.5), .0);\n    //spheres[5] = Sphere(vec3(1, .35, -1.4), .35, LIGHT, 10.5*vec3(1,1,.1), .0);\n    //spheres[5] = Sphere(vec3(1, 1.0, -1.4), .35, LIGHT, 20.*vec3(1,1,1), .0);\n    //spheres[5] = Sphere(vec3(1, 3.0, -1.4), .35, LIGHT, 2.*vec3(1,1,1), .0);\n    spheres[5] = Sphere(vec3(1, 1.8, -.7), .35, LIGHT, 11.4*vec3(1,1,1), .0);\n #if 1\n    //spheres[6] = Sphere(vec3(1.5, .25, -1), .25, LAMBERTIAN, vec3(0,1,0), .0);\n    spheres[6] = Sphere(vec3(1.5, .25, -1), .25, FOG, vec3(0,1,0), 3.3);\n    spheres[7] = Sphere(vec3(-1.1, .4, 1), .4, METAL, vec3(.8,.6,.2), .2); // brassy\n    spheres[8] = Sphere(vec3(-1, .5, -1.5), .5, METAL, vec3(.9,1.,.3), .3); // golden\n    spheres[9] = Sphere(vec3(-.5, .4, 2), .4, DIELECTRIC, vec3(.5,.7,.9), 2.4); // gemstone\n #endif\n}\n\nstruct HitRecord \n{\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    int id; // just lookup material from object\n};\n    \nstruct Ray \n{\n    vec3 o  // origin point\n       , d; // direction vector\n};\n\n// Return the near intersection of a ray and sphere\nfloat sphereIntersect(Ray ray, Sphere sphere)\n{\n    return sphereIntersect(ray.o, ray.d, sphere.center, sphere.radius);\n}\n\nvec3 getRandomBall(vec3 seed)\n{\n\tvec3 s = vec3(seed.x, seed.y * 2. - 1., seed.z); //fract(3.*seed.x+sqrt(seed.y) + .25));\n//    s.z = 1.; // HACK prove that seed.z is FUBAR already\n    return vec3(sqrt(max(0., 1. - s.y*s.y)) * sin(vec2(.5*pi, 0) + s.x * tau), s.y)\n //    * pow(max(0., s.z), 1./3.)\n        ;\n}\n\n\n// Get a random direction on a unit sphere\n// http://corysimon.github.io/articles/uniformdistn-on-sphere\nvec3 getRandomDirection(vec3 seed) //vec2 seed) //float seed)\n{\n//    return getRandomBall(seed);\n    float rnd1 = seed.x; //seed;\n    float rnd2 = seed.y; //random(seed);\n    float rnd3 = seed.z; //fract(rnd1 + sqrt(5.)*rnd2);\n    float theta = tau * rnd1;\n    float phi = acos(1. - 2. * rnd2); // FIXME wtf man - no transcendentals please!\n\treturn sphericalToCartesian(theta, phi)\n  //    * pow(max(0.,rnd3), 1./3.) //* sqrt(rnd3) //\n        ;\n}\n\n// this is just a random vogel disc sample\n// Get a random point on a unit disc\n// https://mathworld.wolfram.com/DiskPointPicking\n// too bad it wants a 2d seed FIXME\nvec2 randomInUnitDisk(vec2 seed)\n{\n    vec2 rand = seed; //random2(seed);\n    float a = tau * rand.y;\n\treturn sqrt(rand.x) * vec2(sin(a), cos(a)); // sincos\n}\n\n// Get a random point on a unit hemisphere\n// http://rorydriscoll.com/2009/01/07/better-sampling\nvec3 cosineSampleHemisphere(vec2 seed)\n{\n    vec2 rand = seed; //random2(seed);\n    float a = tau * rand.y;\n    vec2 disk = sqrt(rand.x) * vec2(sin(a), cos(a));\n    return vec3(disk, sqrt(max(0., 1. - rand.x)));\n}\n// some sort of probabilistic test\nbool refraction(vec3 v, vec3 n, float niOverNt, out vec3 refracted, float rnd, inout vec3 tint)\n{\n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n   #if 1\n    // stochastic spectral prism split HACK - seems obvious that I need more wavelengths or better stochasm or something\n    float spread = 1. + .1 * fract(191.*iTime + rnd); //abs(rnd); //1.03; //1.07; //1.1; //.93; //\n    switch (uint(rnd*32.1)&3u) { //(v.x-v.y+dt)\n        case 1u:\n\t        niOverNt /= spread; // HACK just bend it\n            tint *= vec3(3,0,0);\n        \tbreak;\n        case 2u: // tried not bending green, but it seems to spread the colors out better if I do\n\t        niOverNt *= mix(spread, 1., -.7); // /= mix(spread, 1., .5); // HACK bend green less\n\t        tint *= vec3(0,3,0);\n    \t    break; // could do the other way, but then seems yellow is overrepresented\n        case 3u:\n\t        niOverNt *= mix(spread, 1., -2.); //spread; // HACK just bend it *more*\n        \ttint *= vec3(0,0,3);\n        \tbreak;\n    }\n   #endif\n    float discrim = 1. - niOverNt*niOverNt*(1. - dt*dt);\n    if (discrim > 0.) {\n        refracted = niOverNt*(uv - n*dt) - n*sqrt(discrim);\n        return true;\n    } \n    return false;\n}\n\n// Schlick's Fresnel approximation\n// almost straight from Shirley's book, renamed ref_idx to ior for index of refraction ratio\nfloat schlick(float cosine, float ior) \n{\n    float r0 = (1. - ior) / (1. + ior); // remaps 0..infinity to -1..1 but since ior ratio can be > 1, hard to describe\n    r0 *= r0; // squared\n    return r0 + (1. - r0) * pow(1. - cosine, 5.);\n}\n\n// I'm trying to figure out who wrote these BRDF's, until then maybe alro? bear with me.\n// they're definitely not what reinder is using, perhaps influenced by though.\n// I guess I've now started to actually modify them, so... we may never know now.\n// diffuse only, random scattering over hemisphere\nbool scatterLambertian(Sphere s, vec3 rnd\n      , inout Ray ray, inout HitRecord hit\n      , inout vec3 attenuation, inout Ray scattered)\n{\n\t// trace a random direction from the intersection\n\t// point at a distance of the surface normal.\n    // 1 + random unit away for hemisphere distribution.\n    // guess it's one way to do it.  idea is from Shirley.\n    vec3 sdir = hit.normal + getRandomDirection(rnd);\n    sdir = normalize(sdir);\n    float ncos = max(0., dot(sdir, hit.normal)); //1.; //\n    attenuation = s.albedo * ncos / 1. / pi; //; // / (ncos+.01); // * 2.  *  //\n    scattered = Ray(hit.pos, sdir);\n    ray.o += hit.normal * .002;\n    return true;\n}\n//    if (ncos < 0.) sdir = normalize(sdir - ncos * hit.normal); // FIXME shouldn't have done the max prior\n  #if 0\n// HACK attempt at shadows - tinting is wrong though\n    // this is making the rays bend to look toward the light source.\n    // for one thing, if a shiny object winds up blocking the light,\n    // will wind up projecting the shiny object into its own shadow,\n    // which is just wrong; for another, I don't have a proper correction\n    // factor for the distribution alteration, so results in severe\n    // discontinuities in the lighting around the edge where it kicks in.\n    // have not been able to correct for that, or fix the shadow tinting, here.\n    // I think it should somehow just turn black if there are any non-emissive objects in the way\n    // but then lensing and such may not work.\n    //float nl = 1.;\n    ray.o += .001*hit.normal;\n    vec3 sd2 = sdir;\n            //if (i == 0) \n            { \n                float nl = dot(hit.normal, L);\n                if (false && nl > 1e-2 && rnd.y > .7) {\n                    //float m = (1.-nl) * rnd.y * rnd.x;\n                    sd2 += L * 12.;\n                \t//sdir = normalize(mix(L, sdir, m));\n                }\n                vec3 tol = normalize(Lp - hit.pos);\n                nl = dot(hit.normal, tol);\n                if (nl > 1e-2 && rnd.x > .3) {\n                    //float m = (1.-nl) * rnd.y * rnd.x;\n                    sd2 += tol * 4.;\n                \t//sdir = normalize(mix(L, sdir, m));\n                }\n            }\n    if (dot(sd2, hit.normal) >= 1e-2)\n        sdir = sd2;\n    \t\t//col *= max(0., nl);\n    #endif\n    #if 0\n\t// TODO should mix rd toward sun L but then correct for the increased influence bias\n    sdir = normalize(sdir);\n    vec3 D = mix(sdir, -L, .5);\n    D = normalize(D);\n    float vl = dot(L, sdir), dl = dot(D, hit.normal);\n    if (dl < 0.) {\n        sdir = D;\n        nl = max(nl, 0.);\n\t\tattenuation *= -dl / nl; //nl / -dl; //\n    }\n    #endif\n\n// imperfectly specular\nbool scatterMetal(Sphere s, vec3 rnd\n      , inout Ray ray, inout HitRecord hit\n      , inout vec3 attenuation, inout Ray scattered)\n{\n    vec3 reflected = reflect(ray.d, hit.normal);\n    vec3 sdir = normalize(reflected + s.variable * getRandomDirection(rnd));\n    scattered = Ray(hit.pos, sdir);\n    attenuation = s.albedo; //1. / 4. / pi *  //\n    return true;\n    //return (dot(scattered.direction, rec.normal) > 0.0);\n}\n// shiny transparent\nbool scatterDielectric(Sphere s, vec3 rnd\n      , inout Ray ray, inout HitRecord hit\n      , inout vec3 attenuation, inout Ray scattered)\n{\n    vec3 outwardNormal\n    , n = hit.normal\n    , refracted\n    , reflected = reflect(ray.d, n);\n    float niOverNt, v = s.variable\n        , thick = distance(hit.pos, ray.o) * v; // * v (ior) is not correct, but ... maybe just some constant? need density!\n    attenuation = vec3(1);\n    attenuation = mix(s.albedo, attenuation, exp2(-thick));\n    // without attenuation, perfectly clear!\n    float cosine;\n    if (dot(ray.d, n) > 0.) {\n        outwardNormal = -n;\n        niOverNt = v;\n        cosine = v * dot(ray.d, n);\n    } else {\n        outwardNormal = n;\n        niOverNt = 1.0 / v;\n        cosine = -dot(ray.d, n);\n    }\n    vec3 rtint = vec3(1);\n    float reflectProb = refraction(ray.d\n            , outwardNormal, niOverNt, refracted, rnd.y, rtint)\n        ? schlick(cosine, v) : 1.;\n    attenuation *= rtint;\n\tvec3 scatdir = rnd.x < reflectProb\n    \t? reflected : refracted;\n    scattered = Ray(hit.pos, normalize(scatdir));\n    // or could trace both rays!  ;)  but obviously more costly.\n    return true;\n}\n\nbool scatterFog(Sphere s, vec3 rnd\n      , inout Ray ray, inout HitRecord hit\n      , inout vec3 attenuation, inout Ray scattered)\n{\n    float dens = s.variable // density\n        , thick = distance(hit.pos, ray.o) * dens;\n    attenuation = vec3(1);\n    attenuation = mix(s.albedo, attenuation, exp2(-thick));\n    // doesn't seem to have any inscatter, just pure extinction\n    scattered = Ray(hit.pos, ray.d);\n    return true;\n}\n// TODO I want to try one with small voronoi facets depending on gloss\n// maybe that should be part of the texture function instead\n\n// given two uniformly distributed random fractions in rnd,\n// depending on disc material type\n// if returns false, ray terminates with given attenuation\n// otherwise the other inout arguments are updated accordingly\n// for new scattered ray\nbool scatter(Sphere s, vec3 rnd\n      , inout Ray ray, inout HitRecord hit\n      , inout vec3 attenuation, inout Ray scattered)\n{\n    bool r = false;\n\tswitch (s.material) {\n       \tcase LIGHT:\n        \tattenuation = s.albedo; r = false;\n        \tbreak;\n        case LAMBERTIAN:\n        \tr = scatterLambertian(s, rnd\n                , ray, hit, attenuation, scattered);\n       \t\tbreak;\n        case METAL:\n            r = scatterMetal(s, rnd\n                , ray, hit, attenuation, scattered);\n            break;\n       \tcase DIELECTRIC:\n        \tr = scatterDielectric(s, rnd\n                , ray, hit, attenuation, scattered);\n            break;\n       \tcase FOG:\n        \tr = scatterFog(s, rnd\n                , ray, hit, attenuation, scattered);\n        \tbreak;\n    }\n    return r;\n}\n\nbool hitSphere(Sphere s, Ray ray, float t_min, float t_max, inout HitRecord hit)\n{\n    float t = sphereIntersect(ray, s);    \n    if (t >= 0. && t < t_max && t > t_min) {\n        hit.dist = t;\n        hit.pos = ray.o + ray.d * t;\n        hit.normal = normalize((hit.pos - s.center) / s.radius);\n        return true;\n    }    \n    return false;\n}\n\nbool traceObjects(Ray ray, inout HitRecord hit)\n{\n\tconst float MIN_DIST = 1e-4, MAX_DIST = 1e4;\n    HitRecord rec;\n    bool hitAnything = false;\n    float closestSoFar = MAX_DIST;\n    for (int i = 0; i < spheres.length(); ++i) {\n        if (hitSphere(spheres[i], ray, MIN_DIST, closestSoFar, rec)) {\n            hitAnything = true;\n            closestSoFar = rec.dist;\n            hit = rec;\n            hit.id = i;\n        }\n    }\n    return hitAnything;\n}\n\n// simple sky dome\nvec3 getBackgroundColor(vec3 rayDir)\n{\n    float weight = 1.; //.5 + .5 * rayDir.y;\n    vec3 c = mix(vec3(.7), vec3(.4, .7, 1.), weight); // * 2. / pi;\n    c += sunColor * pow(max(0., dot(rayDir, L)), 1024.);\n    return c;\n}\n\nvec3 renderScene(vec2 fragCoord, vec3 rnd, Ray ray) \n{\n\tHitRecord hit;\n    Ray scattered;\n    // Initialise to white and track the attenuation of light\n    vec3 col = vec3(1);\n    // GLSL does not allow recursion as in the original approach.\n    // For a maximum of MAXIMUM_BOUNCE iterations, adjust the colour variable with \n    // new information until it points into empty space or gets trapped in a shadow\n    for (int i = 0; i < MAXIMUM_BOUNCE; ++i) {\n    \tif (traceObjects(ray, hit)) { // Ray has hit an object?            \n            Sphere s = spheres[hit.id];\n            vec3 attenuation = vec3(1);\n            bool bounce = scatter(s, rnd, ray, hit, attenuation, scattered);\n            col *= attenuation;                  \n            if (bounce) {\n            \tray = scattered;\n            } else {\n                //if (s.material != DIELECTRIC) // == METAL) //\n                return col; //vec3(0); //\n            }\n    \t} else { // Multiply by sky color depending on the ray direction\n        \tcol *= getBackgroundColor(ray.d);\n        \treturn col;\n    \t}\n        //if (earlyExit) break;\n    }\n    return col;\n}\n// FIXME at least their camera supports adjustable ray focus!\nRay getRay(vec3 lookFrom, vec3 targetDir, vec3 upVector, float FOVdeg, float aspect\n           , float aperture, float focusDist, vec2 fragCoord, vec2 rnd)\n{\n    float halfHeight = tan(radians(.5 * FOVdeg))\n        , halfWidth = aspect * halfHeight;\n    vec2 uv = fragCoord / iResolution.xy\n        , rd = aperture * randomInUnitDisk(rnd);\n    vec3 origin = lookFrom\n        , w = -targetDir\n        , u = -normalize(cross(upVector, w))\n        , v = -cross(w, u)\n        , toll = - focusDist * (halfWidth  * u + halfHeight * v + w)\n        , ll = origin + toll\n    \t, du = 2. * focusDist * halfWidth  * u\n    \t, dv = 2. * focusDist * halfHeight * v\n        , offset = u * rd.x + v * rd.y\n        , o = origin + offset\n        , d = toll - offset //ll - o\n            + uv.x * du \n            + uv.y * dv\n            ;\n    return Ray(o, normalize(d));\n}\n\nconst float orbit_scale = 3.; // of radius of object\n\nconst vec3 object_pos = vec3(0., radius*.5, 0.);\n\nvoid mouseCamera(vec2 p, out vec3 pos, out vec3 dir, out int frames) // world position and forward direction of camera this frame\n{\n    vec2 R = iResolution.xy\n        , M = iMouse.xy\n        , m = StoQ(M.xy, R);\n    frames = 4; //256; // high quality when not moving\n    if (length(M.xy) <= 1.) {\n        m = vec2(.2 + .02*iTime,-.15); // unattended, mouse in bottom left corner?\n        frames = 16; //32; // mid quality\n    }\n    dir = OrbitCamera(m);\n    pos = object_pos - orbit_scale * radius * dir;\n  #if 1\n    // && PLANE\n    pos.y = max(pos.y, 5e-2); // do not go beneath ground\n    dir = normalize(object_pos - pos); // redo LookAt after clamp\n  #endif\n//    if (iMouse.z >= 0.) \n//        frames >>= 2; //frames >>= 1; //frames = min(frames, 8); //frames = 8; //16; // low quality to limit motion blurring\n    frames = max(frames, 1);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    InitScene();\n\n\t//float timeFract = fract(iTime); // for random scattering direction seed\n    bool resolutionChanged = false; // (texelFetch(iChannel0, ivec2(0.5, 2.5), 0).x == 1.0);\n\t//bool noaccum = resolutionChanged || iFrame == 0;\n     \n    vec3 camera_dir, camera_pos; // LookAt\n    int lagframes;\n    mouseCamera(p, camera_pos, camera_dir, lagframes);\n    float maxsamp = float(lagframes);\n    \n    vec2 R = iResolution.xy\n    , q = StoQ(p, R);\n    vec2 uv = p/R;\n    uv /= R.x/R.y;\n    //float bigprime = .5*pi; //35507.; // idk, some weird factor to bust up the integers\n    float timeseed = float(iFrame & 255) / 256.; //mod(iTime, .1) * 10.; //fract(77. * float(iFrame & 2047) * (1./2048.)); //fract(iTime); //*.7\n    float pseed = (p.x + (p.y-.5) * R.x) / (R.x*R.y); //(p.x + (p.y-.5) * 13.575532) * .5*pi;\n    //pseed = fract(pseed);\n    // each frame offset the ray by a small amount within the pixel\n    //vec2 seed = fract(timeseed + .1*pseed); //uv*3.3);\n    float seed = fract(timeseed + pseed); //pseed; // HACK ignore time for a bit while I debug the other stuff\n    \n    float focusDist = distance(camera_pos, object_pos);\n    //focusDist *= .2; //.5; //2.; //5.; // can adjust the focal plane for extra DoF blur\n    float aperture = .01; //.1; //.2; // initial out-of-focus-ness\n    vec3 col = vec3(0);\n    int AA = 32; //1; //128; //4; //16; //\n    if (iResolution.x >  999.) AA >>= 1;\n    if (iResolution.x > 1999.) AA >>= 2;\n    AA = max(1, AA);\n    int aa = AA;\n    while (aa-- > 0) {\n        float f = float(aa)/float(AA);\n        vec3 seeds = random3(seed + f);\n        vec2 seeds2 = fract(2. * seeds.yz); //1.-rnd3.xy; //\n        // getRay is already doing aperture randomization\n    \tvec3 up = vec3(0, 1, 0);\n    \tRay ray = getRay(camera_pos, camera_dir, up, 33. // hfovy in degrees\n                     , iResolution.x/iResolution.y, aperture, focusDist\n                     , p, seeds2);\n    \tcol += renderScene(p, seeds, ray);\n    }\n    col /= float(AA); // average of SSAA samples\n    \n    // add color to previous frame held in BufferA\n    // Alpha channel will hold total number of additions for later averaging.\n    vec4 prior = texelFetch(iChannel0, ivec2(p), 0);\n    // blend old samples down to fit\n    //if (prior.a >= maxsamp)\n    //    prior *= (maxsamp-1.)/maxsamp;\n    if (iMouse.z < 0.)\n    col = mix(col, prior.rgb, .95); // lame slow filter\n    c = vec4(col, 1);\n}\n// write color c to BufferA \n\n// needs importance sampling.\n// TODO screams for fog shadows and bloom\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = acos(-1.) //3.1415927\n, tau = 2.*pi\n, radius = 2.; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\n/* // build a 3x3 camera orientation matrix given forward direction vector, assuming up is +Y\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n} */ // unused atm\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\n// https://wikipedia.org/wiki/Spherical_coordinate_system\nvec3 sphericalToCartesian(float theta, float phi)\n{\n    return sph2cart(vec3(theta, phi, 1.));\n//    float sinPhi = sin(phi);\n//\treturn normalize(vec3(sinPhi * cos(theta), sinPhi * sin(theta), cos(phi)));\n}\n\n// orbit camera from https://shadertoy.com/view/WlVGD1\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * pi, 1.));\n} // returns forward vector camera aims along\n\n\nfloat Root(vec3 f) // first zero crossing of polynomial quadric function\n{ // f(t) = dot(f, vec3(1.,vec2(1.,t)*t)) == 0\n\tfloat d = sqrt(.25 * f.y * f.y - f.x * f.z);\n\tif (f.y * f.z < 0.) d = -d;\n\treturn (d - .5 * f.y) / f.z;\n} // see also The Quadratic Equation\n\nfloat traceBall(vec3 ro, vec3 rd)\n{\n\treturn Root(vec3(dot(ro, ro) - 1., 2. * dot(ro, rd), 1.));\n}\n\nfloat traceSphere(vec3 ro, vec3 rd, float r)\n{\n\treturn Root(vec3(dot(ro, ro) - r * r, 2. * dot(ro, rd), 1.));\n}\n\n// shim for near intersection of ray and sphere not at origin\n#if 1\n// mine\nfloat sphereIntersect(vec3 ro, vec3 rd, vec3 sc, float sr)\n{\n    ro -= sc; // sphere relative\n    float d = traceSphere(ro, rd, sr);\n    if (sr > 0. && !(d >= 0.) && length(ro) < sr) d = 0.; // handle inside differently\n    return d;\n}\n#else\n// alro's, mostly Shirley's; think it handles the inside and inside-out better perhaps\n// Return the near intersection of a ray and sphere\n// For normalised ray directions, a = 1 and is omitted\nfloat sphereIntersect(vec3 ro, vec3 rd, vec3 sc, float sr)\n{\n    vec3 oc = ro - sc;\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float d = b*b - 4.*c;\n    if (d < 0.) {\n        return -1.;\n    } else {\n        return (-b - sqrt(d)) * .5;\n    }\n}\n#endif\n\n// from http://shadertoy.com/view/3dySDw\nuint hashFn1(uint x)\n{\n    x ^= x << 9;\n    x ^= x >> 12;\n    return x * x;\n}\n// ok maybe this isn't so bad, now.  hashFn1 is all right, by my tests.\n// FIXME my hashes just absolutely suck, insufficent for the purpose of scattering rays.\nfloat random(float par)\n{\n    return float(hashFn1(floatBitsToUint(par)) >> 9) * exp2(-23.);\n//    return fract(sin(par * 34567.)); //fract(par * 37777.);\n//    return fract(sin(par * 60.27) * 43758.5453);\n}\n\nfloat random(vec2 par)\n{\n    return random(dot(par,vec2(12.9898,78.233)));\n//    return fract(sin(dot(par,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 random2(vec2 par)\n{\n\tfloat rand = random(par);\n\treturn vec2(rand, random(par+rand));\n}\n\nvec3 random3(float x)\n{\n    vec3 f = vec3(7,3,1) * x;\n    //f = sin(f);\n    return vec3(random(f.x), random(f.y), random(f.z));\n    //return fract(sin(x * vec3(7,11,9))*37777.); //fract(seed + f * vec3(7,11,9)); //vec3(seed, seed.x+seed.y) + f;\n    //return vec3(random(x), random(x*(x+.1) + .5), random(x*(x-1.) + .67));\n}\n        // FIXME my hash still stinks but I'm tired of screwing with it for now\n\n\n// using http://academo.org/demos/wavelength-to-colour-relationship/\n// I've mapped out sRGB to wavelength in nm nanometers for the RGB primaries,\n// too bad I could not find them listed anywhere directly.\n// for sRGB, everything from 645 to 697 maps to (255,0,0),  510 maps to (0,255,0),  440 maps to (0,0,255)\n// 580 is yellow; cyan is 490 nm, blue-ray laser at 405 is violet\n// 380 is magenta (not corresponding to a physical wavelength at all; outside visible spectrum),\n// Wikipedia says human eyes respond to light from 390 to 700 nm in wavelength\nconst vec3 wavelength_srgb = vec3(670., 510., 440.);  // in nm\n\n","name":"Common","description":"","type":"common"}]}