{"ver":"0.1","info":{"id":"3slXRf","date":"1551840194","viewed":127,"name":"shadow study 4","username":"mindtree","description":"shadow raymarching yet again","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shadowraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n#define WALL_AMP 1.0\n#define LIGHTA_AMP 3.0\n#define LIGHTB_AMP 3.0\n#define LIGHTC_AMP 3.0\n\nconst float PI = 3.1457;\n\nfloat bpm() { return 128.5; }\nfloat beats_per_bar() { return 4.; }\nfloat bar() { return iTime * bpm() / 60.0 / beats_per_bar(); }\nfloat bar_phase() { return mod(bar(), 1.0); }\nfloat bar2_phase() { return mod(bar(), 2.0) / 2.0; }\nfloat bar4_phase() { return mod(bar(), 4.0) / 4.0; }\nfloat bar8_phase() { return mod(bar(), 8.0) / 8.0; }\nfloat bar16_phase() { return mod(bar(), 16.0) / 16.0; }\nfloat beat() { return iTime * bpm() / 60.0; }\nfloat beat_phase() { return mod(beat(), 1.0); }\nfloat minim_phase() { return mod(beat()*0.5, 1.0); }\nfloat quaver_phase() { return mod(beat()*2.0, 1.0); }\nfloat semiquaver_phase() { return mod(beat()*4.0, 1.0); }\n\nfloat max_dist() {\n    //return bar8_phase() * MAX_DIST;\n    //return pow(sin(bar16_phase()*PI*2.0)*0.5+0.5, 1.) * MAX_DIST;\n    return MAX_DIST;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sqr(float phase) {\n    return float(int(phase * 2.0))*0.5;\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nvec3 blackbody(float Temp) {\n    vec3 col = vec3(255.);\n   col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n      col.y = 100.04 * log(Temp) - 623.6;\n      if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n      col.z = 194.18 * log(Temp) - 1448.6;\n      col = clamp(col, 0., 255.)/255.;\n   if (Temp < 1000.) col *= Temp/1000.;\n      return col;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat dSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat wall_dist(vec3 p) {\n    vec3 pos = vec3(0.0, 0.0, 10.0 + (sin(bar8_phase()*PI*2.0) * 0.5 + 0.5) * WALL_AMP);\n    vec3 dim = vec3(1000.0, 1000.0, 1.0);\n    return dBox(p-pos, dim);\n}\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    float sphere_d =  dSphere(p-vec3(0, 1, 8), 1.);\n    float wall_d = wall_dist(p);    \n    float d = wall_d;\n    d = min(d, sphere_d);\n    return d;\n}\n\nfloat shadow_march(vec3 ro, vec3 rd, float min_light, float light_dist, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    float maxt = min(max_dist(), light_dist);\n    for (float t=min_light; t < maxt;) {\n        vec3 p = ro + rd*t;\n        float h = GetDist(p);\n        if (h<SURF_DIST) {\n            return 0.0;\n        }\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>max_dist() || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat step_phase(float phase, int steps) {\n    return float(int(phase * float(steps))) / float(steps);\n}\n\nfloat lighta_phase() {\n\treturn bar4_phase();\n}\n\nfloat lightb_phase() {\n\treturn bar16_phase();\n}\n\nfloat lightc_phase() {\n\treturn bar8_phase();\n}\n\nfloat lighta_phase_stepped() {\n    return float(int(lighta_phase() * 4.0))/4.0;\n    //return bar4_phase();\n}\n\nvec3 lighta_pos() {\n    vec3 p = vec3(0, 0, 4.0 + 2.*sin(bar16_phase()*PI*2.));\n    float phase = lighta_phase();\n    p.xy += vec2(sin(phase*PI*2.), cos(phase*PI*2.))* 20.0;\n    p.xy += vec2(sin(phase*PI*2.), cos(phase*PI*2.))*2.;\n\treturn p;\n}\n\nvec3 lightb_pos() {\n    vec3 p = vec3(0, 0, 4. + 2.*sin(bar8_phase()*PI*2.));\n    float phase = lightb_phase();\n    p.xy += vec2(sin(phase*PI*2.), cos(phase*PI*2.))* 20.0;\n    p.xy += vec2(sin(phase*PI*2.), cos(phase*PI*2.))*2.;\n\treturn p;\n}\n\nvec3 lightc_pos() {\n    vec3 p = vec3(0, 0, 4. + 2.*sin(bar4_phase()*PI*2.));\n    float phase = lightc_phase();\n    p.xy += vec2(sin(phase*PI*2.), cos(phase*PI*2.))* 20.0;\n    p.xy += vec2(sin(phase*PI*2.), cos(phase*PI*2.))*2.;\n\treturn p;\n}\n\nfloat GetLight(vec3 p, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lp-p)) dif *= .1;\n    \n    \n    float min_light = 0.1;\n    float light_dist = 1.0;\n    float k = 0.25;\n    float s = shadow_march(p+n*SURF_DIST*2., l, min_light, light_dist, k);\n    \n    return dif * s;\n}\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, -10.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, (sin(bar4_phase()*PI*2.)*0.1+0.9)));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float la = GetLight(p, lighta_pos()) * LIGHTA_AMP;\n    float lb = GetLight(p, lightb_pos()) * LIGHTB_AMP;\n    float lc = GetLight(p, lightc_pos()) * LIGHTC_AMP;\n    \n    vec3 ca = vec3(la);\n    vec3 cb = vec3(lb);\n    vec3 cc = vec3(lc);\n    \n\tca = blackbody(la*2000.);\n    cb = blackbody(lb*2000.);\n    cc = blackbody(lc*2000.);\n    \n    col = ca + cb + cc;\n    col = mix(col, vec3(length(col)), (sin(bar16_phase()*2.0*PI)*0.5+0.5));\n    //col = vec3(length(col));\n    return col;\n}\n\nvec3 render_msaa(vec2 uv, int samples) {\n    int samples_per_side = samples / 2;\n    int half_samples_per_side = samples_per_side / 2;\n    int loop_end = samples_per_side - half_samples_per_side;\n    int loop_start = loop_end - samples_per_side;\n    float sample_step = 1.0 / iResolution.x;\n    vec3 acc = vec3(0.0);\n    for (int x = loop_start; x < loop_end; x++) {\n        for (int y = loop_start; y < loop_end; y++) {\n            vec2 coords = uv + vec2(float(x) * sample_step, float(y) * sample_step);\n            acc += render(coords);\n        }\n    }\n    return acc / float(samples_per_side * 2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //vec3 col = vec3(render_msaa(uv, 4));\n\tvec3 col = vec3(render(uv));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}