{"ver":"0.1","info":{"id":"XldfDM","date":"1539865948","viewed":113,"name":"__sphere2__","username":"monada","description":"  ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float circle( vec2 p, vec2 center, float r )\n{\n    p = p - center;\n    float len = abs( length( normalize( p ) * r )  - length( p )  );\n   \n    return pow( len, 0.2 );\n}\n\nfloat sphere( vec2 p, float r )\n{\n    return 0.8 * max( 0.0, r - length( p ) );\n}\n\nfloat pulse( vec2 p )\n{\n    return 1.2 + 0.2 * sin( length( p ) * 20. - iTime * 5.0 );\n}\n\nvec3 neon( float v )\n{\n    vec3 col = vec3( 1.9, 1.5, 1.7 );\n    \n    col = col * -v + col;\n    col = col * col;\n    col = col * col;\n    \n    return col;\n}\n\nvec2 rotate2( vec2 p, float r, float a )\n{\n    float c = cos( a );\n    float s = sin( a );\n    \n    return mat2(\n    c * r, s * r,\n            -s * r, c * r ) * p;\n}\n\nvec3 hash(vec3 p3) {\n    p3 = fract( p3 * vec3( .1031, .11369, .13787 ) );\n    p3 += dot( p3, p3.yxz + 19.19 );\n    return -1. + 2. * fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));\n}\n\nfloat noise_perlin( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n \n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat noise4( vec3 p )\n{\n float f;\n    f  = 0.5000 * noise_perlin( p ); \n f += 0.2500 * noise_perlin( p * 2. );\n f += 0.1250 * noise_perlin( p * 4. ); \n f += 0.0625 * noise_perlin( p * 8. );\n return f;\n}\n\nfloat noise_sum_abs(vec3 p) {\n    float f = 0.;\n    p = p * 3.;\n    f += 1.0000 * abs( noise_perlin( p ) );\n    f += 0.5000 * abs( noise_perlin( p * 2. ) );\n    f += 0.2500 * abs( noise_perlin( p * 3. ) );\n    f += 0.1250 * abs( noise_perlin( p * 4. ) );\n    f += 0.0625 * abs( noise_perlin( p * 5. ) );\n    \n    return f;\n}\n\n\nvec3 energy( vec2 p )\n{\n\n    float t = clamp( -p.x * p.x * 0.16 + 0.25, 0.0, 1.0 );\n\n    float s =  sphere( p, 0.8 ) * pulse( p ) * 2.2;\n    float s2 = 1.3 * sphere( p, 1.8 );\n    \n    float n = noise_sum_abs( vec3( p.xy, iTime * 0.04 ) * 2.0  );    \n\n    float v = pow( abs( n * -t + s2 ), 1.0 );\n   \n    vec3 baseCol = vec3( 2.8, 1.5, 1.2 ) * s;\n    \n    return neon( v ) * baseCol;\n}\n\nvec3 lightningImpl( vec2 p )\n{\n    float t = clamp( -p.x * p.x * 0.26 + 0.25, 0.0, 1.0  );\n    float n = noise4( vec3( p.xy, iTime ) * 8.0 );\n\n    float v = pow( abs( p.y + n * -t  ), 0.2 );\n    float sh = sphere( p, 0.8 );\n    \n    return neon( v ) * sh;\n}\n\nfloat cos_a = cos( 0.4 );\nfloat sin_a = sin( 0.5 );\n\n\nvec3 lightning( vec2 p )\n{\n    vec3 col;\n    float cont_val = cos_a * sin_a * 1.3;\n    \n    for( int i = 0; i < 3; ++i )\n    {\n        col += lightningImpl( p );\n        p = p * cont_val;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p =  2.0 * uv - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    fragColor.xyz = energy( p ) + lightning( p );\n}","name":"Image","description":"","type":"image"}]}