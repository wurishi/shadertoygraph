{"ver":"0.1","info":{"id":"4ld3Dl","date":"1472455164","viewed":707,"name":"Two Pass Separated Blur","username":"pmcneill","description":"A straightforward 2 pass \"high quality\" 7-tap blur.  Instead of performing 49 taps per pixel, it only performs 14.\nNote that you would never calculate UVs in the fragment shader like this, otherwise all your texture reads (taps) become dependent.","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["blur","optimized","mobile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Final Image\n//Reads iChannel0 just for a reference \n//Reads iChannel1 for the blurred texture generated by BufA->BufB\n\n\n//This is a chain of images.  Input Image -> BufA -> BufB -> Image \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    lowp vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    lowp vec4 blurrySample = texture(iChannel1, uv);\n    lowp vec4 regularSample = texture(iChannel0, uv);\n    \n    //Note: this awful chunk of code is simply for comparing the two inputs\n    //You want the contents of BufA and BufB\n    float x = iMouse.x;\n    if (abs(fragCoord.x - x) < 1.0)\n    {\n\t\tfragColor = vec4(0,1,0,1);\n    }\n    else\n    {\n\t\tif (fragCoord.x < x)\n        {\n            fragColor = regularSample;\n        }\n        else\n        {\n            fragColor = blurrySample;\n        }\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Horizontal pass\n//Reads iChannel0 \n//Writes BufA\n\n//varying lowp vec2 sampleUV0;\n//varying lowp vec2 sampleUV1;  //etc \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Optimization tip: Don't calculate UVS in a fragment shader\n    //Move these calculations to the vertex shader and pass through 7 uv coordinates using varying vec2s\n\n    lowp vec2 fragSize = vec2(1.0 / iResolution.x, 0.0);  //X axis blur\n    lowp vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    lowp vec2 sampleUV0 = uv - (fragSize * 3.0);\n    lowp vec2 sampleUV1 = uv - (fragSize * 2.0);\n    lowp vec2 sampleUV2 = uv - fragSize;\n    lowp vec2 sampleUV3 = uv;\n    lowp vec2 sampleUV4 = uv + fragSize;\n    lowp vec2 sampleUV5 = uv + (fragSize * 2.0);\n    lowp vec2 sampleUV6 = uv + (fragSize * 3.0);\n\n    \n    lowp vec4 sample = texture(iChannel0, sampleUV0) * 0.00598;\n    sample +=\t\t   texture(iChannel0, sampleUV1) * 0.060626;\n    sample +=\t\t   texture(iChannel0, sampleUV2) * 0.241843;\n    sample += \t\t   texture(iChannel0, sampleUV3) * 0.383103;\n    sample +=          texture(iChannel0, sampleUV4) * 0.241843;\n    sample +=          texture(iChannel0, sampleUV5) * 0.060626;\n    sample +=          texture(iChannel0, sampleUV6) * 0.00598;\n\n\n\tfragColor = sample;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Vertical pass\n//Reads iChannel0\n//Writes BufB\n\n//varying lowp vec2 sampleUV0;\n//varying lowp vec2 sampleUV1;  //etc \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Optimization tip: Don't calculate UVS in a fragment shader\n    //Move these calculations to the vertex shader and pass through 7 uv coordinates using varying vec2s\n\n    lowp vec2 fragSize = vec2(0.0, 1.0 / iResolution.y);  //Y axis blur\n    lowp vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    lowp vec2 sampleUV0 = uv - (fragSize * 3.0);\n    lowp vec2 sampleUV1 = uv - (fragSize * 2.0);\n    lowp vec2 sampleUV2 = uv - fragSize;\n    lowp vec2 sampleUV3 = uv;\n    lowp vec2 sampleUV4 = uv + fragSize;\n    lowp vec2 sampleUV5 = uv + (fragSize * 2.0);\n    lowp vec2 sampleUV6 = uv + (fragSize * 3.0);\n\n    \n    lowp vec4 sample = texture(iChannel0, sampleUV0) * 0.00598;\n    sample +=\t\t   texture(iChannel0, sampleUV1) * 0.060626;\n    sample +=\t\t   texture(iChannel0, sampleUV2) * 0.241843;\n    sample += \t\t   texture(iChannel0, sampleUV3) * 0.383103;\n    sample +=          texture(iChannel0, sampleUV4) * 0.241843;\n    sample +=          texture(iChannel0, sampleUV5) * 0.060626;\n    sample +=          texture(iChannel0, sampleUV6) * 0.00598;\n\n\n\tfragColor = sample;\n\n}","name":"Buf B","description":"","type":"buffer"}]}