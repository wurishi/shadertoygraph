{"ver":"0.1","info":{"id":"ttByD1","date":"1594302217","viewed":185,"name":"RayMarch template","username":"mithrandir","description":"Raymarching template with FXAA antia aliasing.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RES iResolution.xy\n\n//Pixelize effect\n#define PIXELIZE 1\n#define PIXEL_SIZE 128.0\n\n// 8-bit colors\n#define RETRO_COLORS 0\n\n//GameBoy palette\n#define DARKEST vec3(0.0588235, 0.21961, 0.0588235)\n#define DARK vec3(0.188235, 0.38431, 0.188235)\n#define LIGHT vec3(0.545098, 0.6745098, 0.0588235)\n#define LIGHTEST vec3(0.607843, 0.7372549, 0.0588235)\n#define LIGHT_STRENGHT 1.0\n//Cancels retro colors\n#define GAMEBOY_COLORS 1\n\nvec3 GetGameBoyColor(vec3 col)\n{\n    float luma = dot(col, vec3(0.2126, 0.7152, 0.0722));\n    float posterized = floor(luma * 4.0) / (4.0 - 1.0);\n    \n    float lumaTimesStrength = posterized * LIGHT_STRENGHT;\n\n    float darkest = clamp(lumaTimesStrength, 0.0, 1.0);\n    vec3 color = mix(DARKEST, DARK, darkest);\n\n    float light = clamp(lumaTimesStrength - 1.0, 0.0, 1.0);\n    color = mix(color, LIGHT, light);\n\n    float lightest = clamp(lumaTimesStrength - 2.0, 0.0, 1.0);\n    color = mix(color, LIGHTEST, lightest);\n\n    return color;\n}\n\n//Post process effect to get a retro look!\nvec3 Pixelize(vec2 uv)\n{\n    vec2 st = uv;\n    \n    #if PIXELIZE > 0\n    float size = floor(PIXEL_SIZE);\n    st = floor(uv * size);\n    st /= size;\n    #endif\n    vec3 color = texture(iChannel0, st).rgb;\n    \n    #if RETRO_COLORS > 0\n        //Simulate 8-bit colors\n        color = texture(iChannel0, st).rgb;\n        color = floor(color * 256.0);\n        color.r = floor(color.r/32.0) / 8.0;\n        color.g = floor(color.g/32.0) / 8.0;\n        color.b = floor(color.b/64.0) / 4.0;\n    #endif\n    \n    #if GAMEBOY_COLORS > 0\n    \tcolor = GetGameBoyColor(texture(iChannel0, st).rgb);\n    #endif\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 Col = Pixelize(fragCoord/RES);\n    \n    fragColor = vec4(Col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Set to 1 to toggle toon shading (still working on it)\n#define TOON_SHADING 0\n//Set to 1 if you want to see the LUT that is being generated in order to calculate toon lightning\n#define SHOW_TOON_LUT 0\n\n//Light Colors\n#define LIGHT_DIR normalize(vec3(0.8,1.0,0.5))\n#define LIGHT_COLOR vec3(7.0, 4.5, 3.0)\n#define SKY_COLOR vec3(0.6,0.7,0.9)\n#define BOUNCE_COLOR vec3(0.7,0.3,0.2)\n#define PLANE_TEXTURE_TILLING 0.2\n#define FRESNEL_POW 1.0\n//Camera \n#define CAMERA_HEIGHT 3.0\n#define CAMERA_DIST\t  7.0\n\n//Object colors\n#define TORUS_MAT vec3(0.1, 0.3, 0.4)\n#define BOX_MAT vec3(0.1, 0.3, 0.1)\n#define SPHERE_MAT vec3(0.3, 0.2, 0.1)\n//Here is were the objects on the scene are defined\n// vec4 = rgb = object color, a = Dist\nvec4 SceneDist(vec3 p) {\n    \n    //Assign different colors for each object.\n    vec3 mat = vec3(0.0);\n    \n    float box = sdRoundBox(p + vec3(3.0, 0.0, 0.0), vec3(1), 0.1);\n    float sphere = sdSphere(p + vec3(-2.0, 0.0, 0.0), 1.0);\n    \n    float bs = min(box, sphere);\n    \n    if (bs < sphere)\n        mat = BOX_MAT;\n    if (bs < box)\n        mat = SPHERE_MAT;\n    \n    float torus = sdTorus(p + vec3(sin(iTime) * 0.7, -1.0, 0.0), vec2(1.0, 0.3));\n    \n    float bst = smin(bs, torus, 1.0);\n    \n    if (torus < bs)\n        mat = TORUS_MAT;\n    \n    /*\n\tHave to figure out how to blend those colors, getting artifacts right now... \n    if (bst < bs)\n    {\n        mat = mix(mat, TORUS_MAT, bs);\n    }*/\n    \n    float plane = p.y + 1.0;\n    \n    float d = min(plane, bst);\n    \n    //You can project textures by using the position \n    //(easy to do with the plane since we only have to project it from top to bottom)\n    // if you want to project textures to a 3D object take a look to triplanar projection\n    if (d < bst)\n        mat = texture(iChannel0, p.xz * PLANE_TEXTURE_TILLING).rgb * 0.2;\n   \t\n    return vec4(mat, d);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) \n{\n\tfloat t = 0.0;\n    vec3 mat = vec3(0.0);\n    \n    for(int i = 0; i < 100; ++i)\n    {\n        vec3 pos = ro + rd*t;\n        vec4 h = SceneDist(pos);\n        mat = h.rgb;\n        if(h.a<0.001)break;\n        t+=h.a;\n        if(t>20.0) break;\n    }\n    if(t>20.0) t=-1.0;\n    \n    return vec4(mat, t);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = SceneDist(p).a;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        SceneDist(p-e.xyy).a,\n        SceneDist(p-e.yxy).a,\n        SceneDist(p-e.yyx).a);\n    \n    return normalize(n);\n}\n\nvec3 Sky(vec2 uv)\n{\n    vec3 Dark = vec3(.3,.3,.5);\n    vec3 Bright = vec3(0.7);\n    return mix(Dark, Bright, uv.y);\n}\n\nvec3 GetLight(vec3 p, vec3 n, vec3 rd)\n{\n    vec3 light = vec3(0.0);\n    vec3 LightDir = LIGHT_DIR;\n    \n    float dif = 0.0;\n    \n    #if TOON_SHADING > 0\n    \tdif = GetToonDiff(clamp(dot(n, LightDir), 0.0, 1.0));\n    #else\n    \tdif = clamp(dot(n, LightDir), 0.0, 1.0);\n    #endif\n    \n    float sun_shadow = step(RayMarch(p+n*0.001, LightDir).a, 0.0);\n    float sky_dif = clamp(0.5 + 0.5 * dot(n, vec3(0.0,1.0,0.0)), 0.0, 1.0);\n    float bounce_dif = clamp(0.5 + 0.5 * dot(n, vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n    vec3 reflection = normalize(2.0 * dif * n - LightDir);\n    float specular = pow(clamp(dot(reflection, -rd), 0.0, 1.0), 128.0) * dif;\n    \n    light += vec3(1.0);\n    light += vec3(specular)* LIGHT_COLOR * sun_shadow;\n    light += LIGHT_COLOR *dif*sun_shadow;\n    light += SKY_COLOR * sky_dif;\n    light += BOUNCE_COLOR * bounce_dif;\n    \n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    #if SHOW_TOON_LUT > 0\n    vec2 coords = fragCoord/iResolution.xy;\n    vec3 c = vec3(GetToonDiff(coords.x));\n    fragColor = vec4(c, 1.0);\n    #else\n    //Rotate with mouse position\n    vec3 ro = vec3(0, CAMERA_HEIGHT, -CAMERA_DIST);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    \n    vec3 col = SKY_COLOR - 0.5*rd.y;\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.a>0.0) {\n    \tvec3 p = ro + rd * d.a;\n    \tvec3 n = GetNormal(p);\n        vec3 mate = d.rgb;\n        \n        col = mate * GetLight(p, n, rd);\n    }\n        \n\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"mat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//SDFs from https://iquilezles.org/articles/distfunctions\n//Check out iq website if you haven't already!\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n//Feel free to change the values\nfloat GetToonDiff(float L)\n{\n    float col = 0.0;\n    \n    if (L < 0.3)\n    {\n    \tcol = 0.3 + 0.3 * smoothstep(0.25, 0.3, L);   \n    }\n    else if (L > 0.3 && L < 0.8)\n    {\n        col = 0.6 + 0.3 * smoothstep(0.75, 0.8, L);\n    }\n    else\n    {\n        col = 0.9;\n    }\n    \n   \treturn col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This is a template for raymarching shaders. In Common you'll find all the SDFs for primitve as well\n//as some utility functions. \n//Raymarching is happening inside Buffer A, you can toggle between Toon orregular lighting\n//and tweek camera and light settings. (Feel free to change lighting. \n//Go to GetLight() function inside Buffer A)\n//Here we are applying antialiasing, if desired, to the raymarched scene.\n\n//Use mouse input to rotate camera\n\n#define RES iResolution.xy\n\n// Change this variable to toggle Antialiasing\n#define ENABLE_FXAA 1\n\n//Using the following fxaa filter\n//https://www.shadertoy.com/view/4tf3D8\nvec3 fxaa(vec2 p)\n{\n\tfloat FXAA_SPAN_MAX   = 8.0;\n    float FXAA_REDUCE_MUL = 1.0 / 8.0;\n    float FXAA_REDUCE_MIN = 1.0 / 128.0;\n\n    // 1st stage - Find edge\n    vec3 rgbNW = texture(iChannel0, p + (vec2(-1.,-1.) / RES)).rgb;\n    vec3 rgbNE = texture(iChannel0, p + (vec2( 1.,-1.) / RES)).rgb;\n    vec3 rgbSW = texture(iChannel0, p + (vec2(-1., 1.) / RES)).rgb;\n    vec3 rgbSE = texture(iChannel0, p + (vec2( 1., 1.) / RES)).rgb;\n    vec3 rgbM  = texture(iChannel0, p).rgb;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    // 2nd stage - Blur\n    vec3 rgbA = .5 * (texture(iChannel0, p + dir * (1./3. - .5)).rgb +\n        \t\t\t  texture(iChannel0, p + dir * (2./3. - .5)).rgb);\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  texture(iChannel0, p + dir * (0./3. - .5)).rgb +\n        \t\t\t  texture(iChannel0, p + dir * (3./3. - .5)).rgb);\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 Col = vec3(0.0);\n    \n    #if ENABLE_FXAA > 0\n    \tCol = fxaa(fragCoord/RES);\n    #else\n    \tCol = texture(iChannel0, fragCoord/RES).rgb;\n    #endif\n    \n    fragColor = vec4(Col,1.0);\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}