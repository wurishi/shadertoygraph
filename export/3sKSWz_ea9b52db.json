{"ver":"0.1","info":{"id":"3sKSWz","date":"1573843752","viewed":470,"name":"volumetric box","username":"shiinamiyuki","description":"inefficient volumetric lighting. left click to reset samples.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb/col.a,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Intersection{\n\tint id;\n    vec3 normal;\n    float t;\n};\nfloat maxComp(vec3 o){\n    return max(max(o.x,o.y),o.z);\n}\nfloat minComp(vec3 o){\n\treturn min(min(o.x,o.y),o.z);\n}\nfloat intersectPlane(vec3 p, vec3 normal, vec3 o, vec3 d){\n\t// normal*(o+t*d - p )=0\n    // normal*(o - p) = -normal*d*t\n    float t = dot(normal, o - p )/-dot(normal, d);\n    return t >= 0.0f ? t: -1.0f;\n}\n\nbool fleq(float x, float y){\n\treturn abs(x - y) < 0.001;\n}\nfloat intersectBox(vec3 o, vec3 d, vec3 p1, vec3 p2, out vec3 n){\n\tvec3 t0 = (p1 - o)/d;\n    vec3 t1 = (p2 - o)/d;\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    float t = maxComp(tmin);\n    if(t < minComp(tmax)){\n    \tt = max(t, 0.0);\n        if(t > minComp(tmax)){\n        \treturn -1.0;\n        }\n        vec3 p = o + t *d;\n        if(fleq(p1.x,p.x)){\n        \tn = vec3(-1,0,0);\n        }else if(fleq(p2.x,p.x)){\n        \tn = vec3(1,0,0);\n        }else if(fleq(p1.y,p.y)){\n           n = vec3(0,-1,0);\n        }else if(fleq(p2.y,p.y)){\n        \tn = vec3(0,1,0);\n        }else if(fleq(p1.z,p.z)){\n           n = vec3(0,0,-1);\n        }else {\n        \tn = vec3(0,0,1);\n        }\n        return t;\n    }\n    return -1.0;\n}\n    \nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nIntersection intersect(vec3 o, vec3 d){\n    \n    Intersection isct;\n    isct.t = 1e16;\n    isct.id = 0;\n    float t = intersectPlane(vec3(0,-2,0), vec3(0,1,0),o,d);\n    if(t >=0.0 && t < isct.t){\n    \tisct.t = t;\n        isct.normal = vec3(0,1,0);\n        isct.id = 1;\n    }\n    {\n        mat4 T = rotationMatrix(normalize(vec3(0.2,0.7,-0.2)),0.9);\n        vec4 o1 = T * vec4(o,1.0);\n        vec4 d1 = T * vec4(d, 1.0);\n        \n    \tvec3 n;\n        vec3 p1 = vec3(-2,0,0.8);\n        vec3 p2 = p1 + vec3(1);\n        t = intersectBox(o1.xyz/o1.w,d1.xyz/d1.w,p1,p2,n);\n        vec4 p = o1 + t * d1;\n        vec4 p0 = inverse(T) * p;\n        //t = length(p0.xyz/p0.w - o);\n        n = mat3(transpose((T))) * n;\n        if(t >=0.0 && t < isct.t){\n            isct.t = t;\n            isct.normal = n;\n            isct.id = 2;\n        }\n        //return isct;\n        \n    }   \n    \n    return isct;\n}\n// Returns 2D random point in [0,1]²\nvec2 random2(vec2 st){\n  st = vec2( dot(st,vec2(127.1,311.7)),\n             dot(st,vec2(269.5,183.3)) );\n  return fract(sin(st)*43758.5453123);\n}\n// Inputs:\n//   st  3D seed\n// Returns 2D random point in [0,1]²\nvec2 random2(vec3 st){\n  vec2 S = vec2( dot(st,vec3(127.1,311.7,783.089)),\n             dot(st,vec3(269.5,183.3,173.542)) );\n  return fract(sin(S)*43758.5453123);\n}\nfloat intensity(vec3 l, vec3 wi){\n\treturn pow(max(dot(l,wi), 0.0), 12.0);\n}\nvec3 uniformSphere(vec3 seed){\n    vec2 v = random2(seed);\n    float z = 1.0 - 2.0f * v.x;\n    float r  =  sqrt(1.0 - z * z);\n    float phi = v.y * 3.1415926535 * 2.0;\n    return vec3(r*sin(phi),z,r*cos(phi));\n}\nvec3 trace(vec3 o , vec3 d){\n    float tmax = 10.0f;\n    Intersection isct = intersect(o, d);\n    if(isct.t>0.0)\n   \t\ttmax = min(tmax, isct.t);\n    vec3 col = vec3(0);\n    vec3 beta = vec3(1);\n    vec3 density = vec3(0.25);\n    vec3 light = vec3(0.37*20.0-10.0,2.5,1) + uniformSphere(vec3(d.xy,iTime)) * 0.25f;\n   \tvec3 lightDir = normalize(light - vec3(0,0,1));\n    float phase = 1.0/(4.0 * 3.1415926535);\n    float dt = 0.01;\n    vec3 ke = vec3(20) * vec3(237, 219, 154)/255.0;\n    for(float t0 = 0.0;t0<=tmax;t0+=dt){\n        vec3 p = o + t0 * d;\n        vec3 wi = normalize(light - p);\n        float dist = length(light - p);\n        Intersection isct = intersect(p, wi);\n        \n        if(isct.id == 0 || isct.t > dist){\n        \tvec3 Tr = exp(-density * t0) * phase * exp(-density * dist);\n            col += Tr * dt * ke * intensity(lightDir, wi);\n        }        \n        dt += 0.001 * t0 + 0.001 * rand(p.xy + vec2(iTime, 0));\n    }   \n    \n    if(isct.id != 0){\n        vec3 kd;\n        vec3 ka = vec3(0.04);\n        if(isct.id == 1){\n        \tkd = vec3(1);\n            ka = vec3(0);\n        }else{\n        \tkd = vec3(0.9,0,0);\n        }\n        vec3 p = o + isct.t * d;\n        vec3 wi = normalize(light - p);\n        vec3 wo = -d;\n        float invSqr = 1.0/dot(light - p, light - p);\n        Intersection sh = intersect(p+0.01 * wi, wi);\n        if(sh.id == 0)\n    \t\tcol += exp(-density * length(light-p)) \n            * kd * max(dot(wi, isct.normal), 0.0) \n            * invSqr * ke * intensity(lightDir, wi);\n        col += ka * kd;\n    }\n\t\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 prevcol = texture(iChannel0, uv);\n    if(iTime < 0.01f || iMouse.w > 0.0){\n    \tprevcol = vec4(0);\n    }\n\t\n\n    uv.x = 2.0f * uv.x -1.0f;\n    uv.y = 2.0f * (uv.y) - 1.0f;\n    uv.x *= iResolution.x / iResolution.y;\n#define MSAA 2\n    vec3 col;\n    vec2 offset = vec2(2) / iResolution.xy / float(MSAA);\n    for(int i =0;i< MSAA;i++){\n        for(int j =0 ;j<MSAA;j++){\n            vec3 o = vec3(0,0,-4);\n            vec3 d = vec3(uv + offset * (vec2(i,j) + random2(vec3(iTime, uv))), 0) - vec3(0,0, -2);\n            d = normalize(d);\n            col += trace(o, d);\n        }\n    }\n   \n\tcol /= float(MSAA) * float(MSAA);\n    col = pow(col, vec3(0.8));\n    // Output to screen\n    fragColor = vec4(col+prevcol.rgb,prevcol.w+1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}