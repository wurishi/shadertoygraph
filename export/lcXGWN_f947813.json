{"ver":"0.1","info":{"id":"lcXGWN","date":"1704572309","viewed":24,"name":"Gamepad Extension","username":"timestamp","description":"Use a gamepad or joystick with your shader.\n\nSimple, minimal concept demo.\n\nI'd like to know how well this works on other systems.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["hack","extension","gamepad","javascript"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ======================================================================================\n// Gamepad Extension minimal demo\n//\n// (c) 2023, timestamp @ shadertoy.com\n// ======================================================================================\n//\n// To use this shader:\n// - Plug in your gamepad/joystick\n// - Refresh this page\n// - Run the attached javascript in your browser developer console or in TamperMonkey\n// - Optional: Run JS GamepadExtension.readGamepad() in developer console to see available inputs \n// - Optional: Change the button/axis mappings encoded in uniform names\n//\n// Javascript API only attaches to gamepad when webpage has focus,\n// and you interact with the page, eg, using the keyboard or mouse!\n//\n// Grey background means Gamepad Extension is not activated or installed.\n// \n// JS API Docs: https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API\n//\n// Example usage: https://www.shadertoy.com/view/ctlcR7\n//\n// ======================================================================================\n//\n// Connect a button to signal once whenever pressed\n//     0  = Gamepad 0\n//     b  = button\n//     0  = button index 0\n//     m  = momentary, ie, signal for one frame when pressed\nuniform float iGamepad_0b0m;\n\n// Connect a button to signal while pressed\n//     0  = Gamepad 0\n//     b  = button\n//     0  = button index 0\nuniform float iGamepad_0b0;\n\n// Connect two gamepad axes (x,y)\n//     0  = Gamepad 0\n//     a  = axis\n//     0  = axis index 0 (and index 1 to fill vec2)\nuniform vec2 iGamepad_0a0;\n\nvoid mainImage( out vec4 O, in vec2 c)\n{    \n    c = (c + c - iResolution.xy) / iResolution.y; // AR, -1..1\n    \n#ifdef GamepadExtension // Defined by Gamepad Extension\n    vec4 bcol = vec4(0);   \n#else\n    vec4 bcol = vec4(0.2);\n#endif\n\n    // while button is pressed...\n    vec4 col = iGamepad_0b0 > 0.0 ? vec4(1,0,0,0) : vec4(0,1,0,0);\n    \n    // for one frame, whenever button is pressed...\n    float r = iGamepad_0b0m > 0.0 ? 0.18 : 0.04;\n    \n    vec2 p = iGamepad_0a0;\n    p.y = -p.y; // This gamepad needs y-axis flipped\n    O = length(p - c) < r ? col : bcol;    \n}\n\n/*\n// Tested on Win 10 + Chrome + TamperMonkey + 8bitDo gamepad + ShaderToy 2024-01-07.\n// Tested on Win 10 + Edge + Debug Console + 8bitDo gamepad + ShaderToy 2024-01-07.\n\n\n// =================================================================\n// Developer console version (no TamperMonkey):\n// =================================================================\n\nlet GamepadExtension =\n{\n    version: 20230810.0,\n    isAttached: false,\n    _effectPassPaint: undefined,\n    _effectPassNewShader: undefined,\n    _effectPaint: undefined,\n\n    // Returns { '':0, '6b3' : 1, '0a2' : -.352, ... }\n    readGamepad() {\n        let values = { };\n        let pads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);\n        if (pads == null) return values;\n        for (let i = 0; i < pads.length; i++) {\n            let pad = pads[i];\n            if (pad == null) continue;\n            for (let j = 0; j < pad.buttons.length; j++) {\n                let b = pad.buttons[j];\n                values[i + 'b' + j] = typeof (b) == \"object\" ? b.value : b === 1 ? 1 : 0;\n            }\n            for (let j = 0; j < pad.axes.length; j++) {\n                values[i + 'a' + j] = pad.axes[j];\n            }\n        }\n        return values;\n    },\n\n    applyValues(effect, pass) {\n        let gl = effect.mGLContext;\n        let program = pass.mProgram;\n        let renderer = effect.mRenderer;\n        let uu = pass.gamepadUniforms;\n        if(uu === undefined) {\n            uu = [];\n            const n = gl.getProgramParameter(program.mProgram, gl.ACTIVE_UNIFORMS);\n            for (let i = 0; i < n; i++) {\n                const u = gl.getActiveUniform(program.mProgram, i);\n                let m = u.name.match(/^iGamepad_(\\d+)([ab])(\\d+)(m?)$/); //  iGamepad_1b2m\n                if(!m) continue;\n                let r = {\n                    name : u.name,  // uniform name\n                    size : u.type == gl.FLOAT ? 1         // number of floats\n                         : u.type == gl.FLOAT_VEC2 ? 2\n                         : u.type == gl.FLOAT_VEC3 ? 3\n                         : u.type == gl.FLOAT_VEC4 ? 4\n                         : 0,\n                    padIdx : parseInt(m[1]), // gamepad index\n                    axis:m[2],  // a or b\n                    idx:parseInt(m[3]),  // button or axis index\n                    suffix:m[4]  // m or undefined\n                };\n                if(r.size == 0) continue;\n                uu.push(r);\n            }\n            pass.gamepadUniforms = uu;\n        }\n        if(uu.length == 0) return;\n\n        let vals = effect.gamepadValues = effect.gamepadValues ?? GamepadExtension.readGamepad();\n        let prev = effect.gamepadValuesPrev ?? {};\n\n        function get(u, idx){\n            let key = u.padIdx + u.axis + (u.idx + idx);\n            let nv = vals[key] ?? 0;\n            if(u.suffix != 'm') return nv;\n            let ov = prev[key] ?? 0;\n            return ov == 0 && nv != 0 ? nv : 0;\n        }\n\n        for(const u of uu) {\n            let pos = gl.getUniformLocation(program.mProgram, u.name);\n            if(u.size == 1) gl.uniform1f(pos, get(u,0) );\n            else if(u.size == 2) gl.uniform2f(pos, get(u,0), get(u, 1));\n            else if(u.size == 3) gl.uniform3f(pos, get(u,0), get(u, 1), get(u, 2));\n            else gl.uniform4f(pos, get(u,0), get(u, 1), get(u, 2), get(u,3));\n        }\n    },\n\n    effectPaint(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused) {\n        if (!isPaused) {\n            this.gamepadValuesPrev = this.gamepadValues;\n            this.gamepadValues = undefined; // reset for lazy create\n        }\n        return GamepadExtension._effectPaint.apply(this, arguments);\n    },\n\n    effectPassPaint(vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect) {\n        this.mRenderer.AttachShader(this.mProgram);\n        GamepadExtension.applyValues(effect, this);\n        return GamepadExtension._effectPassPaint.apply(this, arguments);\n    },\n\n    effectPassNewShader(commonSourceCodes, preventCache, onResolve) {\n        commonSourceCodes.push(\"#define GamepadExtension\");\n        this.gamepadUniforms = undefined; // reset for lazy create\n        return GamepadExtension._effectPassNewShader.apply(this, [commonSourceCodes, preventCache, onResolve]);\n    },\n\n    attach() {\n        if (this.isAttached) return;\n        this.isAttached = true;\n        this._effectPaint = Effect.prototype.Paint;\n        this._effectPassPaint = EffectPass.prototype.Paint;\n        this._effectPassNewShader = EffectPass.prototype.NewShader;\n        Effect.prototype.Paint = this.effectPaint;\n        EffectPass.prototype.Paint = this.effectPassPaint;\n        EffectPass.prototype.NewShader = this.effectPassNewShader;\n    },\n\n    detach() {\n        if (!this.isAttached) return;\n        this.isAttached = false;\n        Effect.prototype.Paint = this._effectPaint;\n        EffectPass.prototype.Paint = this._effectPassPaint;\n        EffectPass.prototype.NewShader = this._effectPassNewShader;\n    }\n};\n\nGamepadExtension.attach();\n\n\n\n// =================================================================\n// TamperMonkey version\n// =================================================================\n\n\n// ==UserScript==\n// @name         ShaderToy Gamepad Extension\n// @namespace    http://tampermonkey.net/\n// @version      1.0\n// @description  Access gamepads on ShaderToy\n// @author       (c) timestamp @ shadertoy.com\n// @match        https://www.shadertoy.com/view/*\n// @icon         https://www.google.com/s2/favicons?sz=64&domain=shadertoy.com\n// @grant        unsafeWindow\n// ==/UserScript==\n\n(function() {\n    'use strict';\n\nunsafeWindow.GamepadExtension =\n{\n    version: 20230810.0,\n    isAttached: false,\n    _effectPassPaint: undefined,\n    _effectPassNewShader: undefined,\n    _effectPaint: undefined,\n\n    // Returns { '':0, '6b3' : 1, '0a2' : -.352, ... }\n    readGamepad() {\n        let values = { };\n        let pads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);\n        if (pads == null) return values;\n        for (let i = 0; i < pads.length; i++) {\n            let pad = pads[i];\n            if (pad == null) continue;\n            for (let j = 0; j < pad.buttons.length; j++) {\n                let b = pad.buttons[j];\n                values[i + 'b' + j] = typeof (b) == \"object\" ? b.value : b === 1 ? 1 : 0;\n            }\n            for (let j = 0; j < pad.axes.length; j++) {\n                values[i + 'a' + j] = pad.axes[j];\n            }\n        }\n        return values;\n    },\n\n    applyValues(effect, pass) {\n        let gl = effect.mGLContext;\n        let program = pass.mProgram;\n        let renderer = effect.mRenderer;\n        let uu = pass.gamepadUniforms;\n        if(uu === undefined) {\n            uu = [];\n            const n = gl.getProgramParameter(program.mProgram, gl.ACTIVE_UNIFORMS);\n            for (let i = 0; i < n; i++) {\n                const u = gl.getActiveUniform(program.mProgram, i);\n                let m = u.name.match(/^iGamepad_(\\d+)([ab])(\\d+)(m?)$/); //  iGamepad_1b2m\n                if(!m) continue;\n                let r = {\n                    name : u.name,  // uniform name\n                    size : u.type == gl.FLOAT ? 1         // number of floats\n                         : u.type == gl.FLOAT_VEC2 ? 2\n                         : u.type == gl.FLOAT_VEC3 ? 3\n                         : u.type == gl.FLOAT_VEC4 ? 4\n                         : 0,\n                    padIdx : parseInt(m[1]), // gamepad index\n                    axis:m[2],  // a or b\n                    idx:parseInt(m[3]),  // button or axis index\n                    suffix:m[4]  // m or undefined\n                };\n                if(r.size == 0) continue;\n                uu.push(r);\n            }\n            pass.gamepadUniforms = uu;\n        }\n        if(uu.length == 0) return;\n\n        let vals = effect.gamepadValues = effect.gamepadValues ?? GamepadExtension.readGamepad();\n        let prev = effect.gamepadValuesPrev ?? {};\n\n        function get(u, idx){\n            let key = u.padIdx + u.axis + (u.idx + idx);\n            let nv = vals[key] ?? 0;\n            if(u.suffix != 'm') return nv;\n            let ov = prev[key] ?? 0;\n            return ov == 0 && nv != 0 ? nv : 0;\n        }\n\n        for(const u of uu) {\n            let pos = gl.getUniformLocation(program.mProgram, u.name);\n            if(u.size == 1) gl.uniform1f(pos, get(u,0) );\n            else if(u.size == 2) gl.uniform2f(pos, get(u,0), get(u, 1));\n            else if(u.size == 3) gl.uniform3f(pos, get(u,0), get(u, 1), get(u, 2));\n            else gl.uniform4f(pos, get(u,0), get(u, 1), get(u, 2), get(u,3));\n        }\n    },\n\n    effectPaint(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused) {\n        if (!isPaused) {\n            this.gamepadValuesPrev = this.gamepadValues;\n            this.gamepadValues = undefined; // reset for lazy create\n        }\n        return GamepadExtension._effectPaint.apply(this, arguments);\n    },\n\n    effectPassPaint(vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect) {\n        this.mRenderer.AttachShader(this.mProgram);\n        GamepadExtension.applyValues(effect, this);\n        return GamepadExtension._effectPassPaint.apply(this, arguments);\n    },\n\n    effectPassNewShader(commonSourceCodes, preventCache, onResolve) {\n        commonSourceCodes.push(\"#define GamepadExtension\");\n        this.gamepadUniforms = undefined; // reset for lazy create\n        return GamepadExtension._effectPassNewShader.apply(this, [commonSourceCodes, preventCache, onResolve]);\n    },\n\n    attach() {\n        if (this.isAttached) return;\n        this.isAttached = true;\n        this._effectPaint = Effect.prototype.Paint;\n        this._effectPassPaint = EffectPass.prototype.Paint;\n        this._effectPassNewShader = EffectPass.prototype.NewShader;\n        Effect.prototype.Paint = this.effectPaint;\n        EffectPass.prototype.Paint = this.effectPassPaint;\n        EffectPass.prototype.NewShader = this.effectPassNewShader;\n    },\n\n    detach() {\n        if (!this.isAttached) return;\n        this.isAttached = false;\n        Effect.prototype.Paint = this._effectPaint;\n        EffectPass.prototype.Paint = this._effectPassPaint;\n        EffectPass.prototype.NewShader = this._effectPassNewShader;\n    }\n};\n\n    unsafeWindow.GamepadExtension.attach();\n})();\n\n\n*/\n","name":"Image","description":"","type":"image"}]}