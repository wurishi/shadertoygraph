{"ver":"0.1","info":{"id":"fsGcW3","date":"1655673720","viewed":503,"name":"RayTracing Reflection+Refraction","username":"modern_shinobi","description":"Iterative implementation of pretty much complete ray tracing using various physics models. Usually it's supposed to be done using recursive methods and its much more intuitive that way but glsl doesn't support recursion :(","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["reflection","refraction","spheres","glsl","shadows","raytrace","multiple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hey!\n// This is my implementation of raytracing including\n// different reflections and refractions techniques \n// along with phong lighting model and shadows\n// There are still some bugs I think :o but \n// I'll come to them a bit later!\n// Enjoy :)\n\n\n#define PI 3.1415926535\n#define SHADOWS\n\nfloat FLOAT_MAX = 10e+10;\nfloat FLOAT_MIN = -10e+10;\n\n// Global Parameters\nvec4 ambientLight = vec4(1,1,1,1);\nfloat ambientStrength = 0.1;\nconst int R = 3;    // Num reflections\nconst float delta = 10e-5;\nfloat shadowFactor = 0.1;\nconst int N = 6;    // Num spheres\nbool transform = true;\nbool deg = false;\nfloat fov = 0.8;   // 0 < fov\nconst int totalRays = int(pow(2.0, float(R)));\n\n//--------------------------------------//\n\nstruct Material{\n    vec4 color;\n    float kd;   // Diffuse factor\n    float ks;   // Diffuse factor\n    float kr;   // Reflectivity\n    float kt;   // Transmitivity\n    float n;    // Refractive index\n};\n\nstruct Sphere{\n    float radius;\n    vec3 center;\n    Material mat;\n};\n\nstruct Plane{\n    vec3 center;\n    vec3 size;\n    vec3 normal;\n    Material mat;\n};\n\nstruct Light{\n    vec3 dir;\n    float mag;\n    vec4 color;\n    vec3 ray;\n};\n\nstruct Ray{\n    vec3 dir;\n    vec3 origin;\n    float factor;   // color multiplier for ray\n    float n;    // index of medium ray in currently in\n};\n\nstruct Hit{\n    float d;\n    vec3 point;\n    vec3 normal;\n};\n\nmat3 Rotation(vec3 euler, bool deg){\n\n    // Deg to Rad\n    if (deg)\n        euler *= PI / 180.0;\n\n    // Rotation around X - pitch\n    float c = cos(euler.x);\n    float s = sin(euler.x);\n    mat3 Rx = mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n\n    // Rotation around Y - yaw\n    c = cos(euler.y);\n    s = sin(euler.y);\n    mat3 Ry = mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n\n    // Rotation around Z - roll\n    c = cos(euler.z);\n    s = sin(euler.z);\n    mat3 Rz = mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n    \n    return Rz*Ry*Rx;\n}\n\n// Global variables\nRay[totalRays+1] reflectionRays;\nRay[totalRays+1] refractionRays;\nLight light;\nPlane ground;\nSphere[N] spheres;\n\n\n// Raycasting Functions definition\nHit RayCastPlane(vec3 rayOrigin, vec3 rayDir, in Plane plane, float delta){\n    Hit hit = Hit(-1.0, vec3(0), vec3(0));\n    // Move hitpoint by delta to avoid 'acne'\n    rayOrigin += delta * plane.normal;\n \n    if (rayDir.y != 0.0){\n        hit.d = (plane.center.y - rayOrigin.y)/rayDir.y;\n        hit.point = rayOrigin + hit.d * rayDir;\n        hit.normal = plane.normal;\n        \n        // Chceck if hitpoint within plane\n        vec3 relPoint = abs(hit.point - plane.center);\n        if (relPoint.x > plane.size.x || relPoint.z > plane.size.z){\n            hit.d = -1.0;\n        }\n    }\n    return hit;\n}\n\nHit RayCastSphere(vec3 rayOrigin, vec3 rayDir, in Sphere sphere){\n    Hit hit = Hit(-1.0, vec3(0), vec3(0));\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayDir, rayOrigin-sphere.center);\n    float c = dot(rayOrigin-sphere.center, rayOrigin-sphere.center) - \n                sphere.radius * sphere.radius;\n    \n    float det = b*b - 4.0*a*c;\n    if (det >= 0.0){\n        float d1 = (-b-sqrt(det))/2.0*a;\n        float d2 = (-b+sqrt(det))/2.0*a;\n        hit.d = min(d1,d2);\n        hit.point = rayOrigin + hit.d * rayDir;\n        hit.normal = normalize(hit.point - sphere.center);\n    }\n    return hit;\n}\n\nfloat RandFloat(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 GetLighting(in Material mat, in vec3 normal, in vec3 rayDir, in Light light){\n    // Diffuse\n    float diff = max(dot(normal, -light.dir), 0.0);\n    // Specular\n    vec3 reflectDir = -light.dir - 2.0 * normal * dot(-light.dir, normal);\n    float spec = pow(max(dot(rayDir, reflectDir), 0.0), mat.ks); \n    // Total\n    vec4 col = mat.color * light.color * (diff * mat.kd + spec * mat.kr);\n    return col;\n}\n\nfloat Fresnel(float n1, float n2, vec3 normal, vec3 incident, float reflectivity){\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return 1.0;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n    // adjust reflect multiplier for object reflectivity\n    ret = (reflectivity + (1.0-reflectivity) * ret);\n    return ret;\n}\n\n\nvec4 RayTraceCore(inout Ray ray, inout Material hitMat, inout Hit hit, in int iter){\n    \n    // Plane distance calculations\n    Hit hitGround = RayCastPlane(ray.origin, ray.dir, ground, 0.0);\n    // Sphere distance calculations\n    Hit[N] hitSphere;\n    for (int i=0; i<N; i++){\n        hitSphere[i] = RayCastSphere(ray.origin, ray.dir, spheres[i]);\n    }\n\n    // Finding closest object to camera\n    vec4 col = vec4(0,0,0,0);\n    // Minimum distance for ground plane\n    if (hitGround.d > 0.0){\n        hit = hitGround;\n        // sample ground texture\n        vec2 groundTexScale = vec2(0.5);\n        ground.mat.color = texture(iChannel1, hitGround.point.xz*groundTexScale);\n        hitMat = ground.mat;\n        col = GetLighting(ground.mat, hitGround.normal, ray.dir, light);\n    }\n    // Minimum distances for all spheres\n    for (int i=0; i<N; i++){\n        if (hitSphere[i].d < 0.0) hitSphere[i].d = FLOAT_MAX;\n        if (hitSphere[i].d < hit.d){\n            hit = hitSphere[i];\n            hitMat = spheres[i].mat;\n            col = GetLighting(spheres[i].mat, hitSphere[i].normal, ray.dir, light);\n        }\n    }\n\n    // If no object hit then exit\n    if (hit.d == FLOAT_MAX){\n        col = texture(iChannel0, reflect(ray.dir, hit.normal));\n        return col;\n    }\n\n    // Shadow of ground plane calculation\n#ifdef SHADOWS\n    if (iter == R-1){\n        Hit hitShadow;\n        float minShadowDist = FLOAT_MAX;\n        hitShadow = RayCastPlane(hit.point, -light.dir, ground, delta);\n        if (hitShadow.d >= 0.0 && hitShadow.d < minShadowDist){\n            col = vec4(0) * shadowFactor * exp(-1.0/hitShadow.d);\n            minShadowDist = hitShadow.d;\n        }\n        // Shadows of all spheres calculation\n        for (int i=0; i<N; i++){\n            hitShadow = RayCastSphere(hit.point + delta*hit.normal, -light.dir, spheres[i]);\n            if (hitShadow.d >= 0.0 && hitShadow.d < minShadowDist){\n                minShadowDist = hitShadow.d;\n                col = hitMat.color * shadowFactor * exp(-1.0/hitShadow.d);\n            }\n        }\n    }\n#endif\n\n    // Ambient light\n    if (iter == 0)\n        col += ambientStrength * ambientLight * hitMat.color;\n\n    return col;\n}\n\n\nvec4 CastRays(in int iter){\n    \n    int startIdx = 0;\n    if (iter != 0)\n        startIdx = 1;\n        for(int i=0;i<iter-1;i++)\n            startIdx *= 2;\n    int endIdx = 1;\n    for(int i=0;i<iter;i++)\n        endIdx *= 2;\n    \n    vec4 currLevelCol = vec4(0);\n\n    // ------- REFLECTION PART -------\n    // For each new reflection ray\n    int j = 0;  // new ray counter\n    for (int r=startIdx; r<endIdx; r++){\n        // Incident ray\n        Ray ray = reflectionRays[r];\n        if (ray.dir == vec3(0) || ray.factor==0.0){\n            // Rays that don't exist\n            j += 1;\n            continue;\n        }\n\n        Hit hit = Hit(FLOAT_MAX, vec3(0), vec3(0));\n        Material hitMat;\n        // Get color of ray\n        vec4 col = RayTraceCore(ray, hitMat, hit, iter);\n        currLevelCol += col * ray.factor;\n\n        float n1, n2;\n        if (ray.n != 1.0){\n            n1 = ray.n;\n            n2 = 1.0;\n            hit.normal *= -1.0;\n        } \n        else {\n            n1 = 1.0;\n            n2 = hitMat.n;\n        }\n        float Kr = Fresnel(n1, n2, hit.normal, ray.dir, hitMat.kr);\n        \n        // Add new reflection & refraction ray\n        if (hit.d < FLOAT_MAX && hit.d > 0.0){\n            // Add new reflection ray\n            reflectionRays[endIdx+j].origin = hit.point + delta * hit.normal;\n            reflectionRays[endIdx+j].dir = reflect(ray.dir, hit.normal);\n            reflectionRays[endIdx+j].factor = ray.factor * Kr;\n            reflectionRays[endIdx+j].n = n1;\n            // Add new refraction ray\n            if (hitMat.kt > 0.0){\n                refractionRays[endIdx+j].origin = hit.point - delta * hit.normal;\n                refractionRays[endIdx+j].factor = ray.factor * (1.0-Kr);\n                refractionRays[endIdx+j].n = n2;\n                refractionRays[endIdx+j].dir = refract(ray.dir, hit.normal, n1/n2);\n            }\n        }\n        j += 1;\n    }\n\n\n    // ------- REFRACTION PART -------\n    // For each new refraction ray\n    for (int r=startIdx; r<endIdx; r++){\n        Ray ray = refractionRays[r];\n        if (ray.dir == vec3(0) || ray.factor==0.0){\n            // Rays that don't exist\n            j += 1;\n            continue;\n        }\n\n        Hit hit = Hit(FLOAT_MAX, vec3(0), vec3(0));\n        Material hitMat;\n        // Get color of ray\n        vec4 col = RayTraceCore(ray, hitMat, hit, iter);\n        currLevelCol += col * ray.factor;\n\n        float n1, n2;\n        if (ray.n != 1.0){\n            n1 = ray.n;\n            n2 = 1.0;\n            hit.normal *= -1.0;\n        }\n        else {\n            n1 = 1.0;\n            n2 = hitMat.n;\n        }\n        float Kr = Fresnel(n1, n2, hit.normal, ray.dir, hitMat.kr);\n        \n        // Add new reflection & refraction ray\n        if (hit.d < FLOAT_MAX && hit.d > 0.0){\n            // Add new reflection ray\n            reflectionRays[endIdx+j].origin = hit.point + delta * hit.normal;\n            reflectionRays[endIdx+j].dir = reflect(ray.dir, hit.normal);\n            reflectionRays[endIdx+j].factor = ray.factor * Kr;\n            reflectionRays[endIdx+j].n = n1;\n            // Add new refraction ray\n            if (hitMat.kt > 0.0){\n                refractionRays[endIdx+j].origin = hit.point - delta * hit.normal;\n                refractionRays[endIdx+j].factor = ray.factor * (1.0-Kr);\n                refractionRays[endIdx+j].n = n2;\n                refractionRays[endIdx+j].dir = refract(ray.dir, hit.normal, n1/n2);\n            }\n        }\n        j += 1;\n    }\n\n    return currLevelCol;\n}\n\n\n//--------- Main Function ---------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    // Camera\n    vec3 cameraPos = vec3(0,0,-fov);\n    Ray ray;\n    ray.origin = cameraPos;\n    \n    // Camera motion\n    vec3 camOffset = vec3(0, 2, 5);\n    float camAngle = iTime * 0.6;\n    float camRadius = 6.0;\n    \n    // Light\n    light.dir = vec3(sin(iTime*0.7), -1, cos(iTime*0.7));\n    //light.dir = vec3(-0.4, -1.0, -1);\n    //light.dir = vec3(0.6, -0.5, 1);\n    light.mag = 1.0;\n    light.color = vec4(1,1,1,1);\n    \n    // Ground plane\n    ground.center = vec3(camOffset.x,0,camOffset.z);\n    ground.size = vec3(5,0,5);\n    ground.normal = vec3(0,1,0);\n    ground.mat = Material(vec4(0.3,0.8,0.2,1.0), 1.0, 16.0, 0.2, 0.0, 1.0);\n    \n    // Ground plane\n    spheres[0].radius = 0.8;\n    spheres[0].center = vec3(0.0,0.8,2);\n    spheres[0].mat = Material(vec4(0,0,0,0.0), 1.0, 32.0, 0.1, 1.0, 1.25);\n\n    spheres[1].radius = 1.1;\n    spheres[1].center = vec3(1.0,1.1,6);\n    spheres[1].mat = Material(vec4(0.3,0.3,1.0,1.0), 1.0, 16.0, 0.1, 0.0, 2.0);\n    \n    spheres[2].radius = 0.5;\n    spheres[2].center = vec3(-2.0,0.5,3.0);\n    spheres[2].mat = Material(vec4(0.8,0.8,0.1,1.0), 1.0, 32.0, 1.0, 0.0, 2.0);\n    \n    spheres[3].radius = 0.5;\n    spheres[3].center = vec3(1.5,0.8,3);\n    spheres[3].mat = Material(vec4(0.0,1.0,1.0,1.0), 1.0, 0.0001, 0.0, 0.0, 2.0);\n\n    spheres[4].radius = 1.0;\n    spheres[4].center = vec3(-0.8,1,4);\n    spheres[4].mat = Material(vec4(1.0,0.1,0.1,1.0), 1.0, 16.0, 0.5, 0.0, 2.0);\n    \n    spheres[5].radius = 1.0;\n    spheres[5].center = vec3(-2.0,1.0,7);\n    spheres[5].mat = Material(vec4(0,0,0,0.0), 1.0, 32.0, 0.1, 1.0, 1.5);\n    \n    //------------------------------------------------------------//\n    \n    // CALCULATIONS BEGIN\n    light.dir = normalize(light.dir);\n    light.ray = light.dir * light.mag;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // View ray\n    ray.dir = normalize(vec3(cameraPos.x+uv.x, cameraPos.y+uv.y, 0) - cameraPos);\n    ray.factor = 1.0;\n    ray.n = 1.0;    // Starts in air\n\n    // Translate & Rotate camera\n    camAngle = mod(camAngle, 2.0*PI);\n    vec3 rotate = vec3(-0.2, camAngle, 0);\n    vec3 translate = camOffset + vec3(camRadius*sin(camAngle), 0, -camRadius*cos(camAngle));\n    if (!transform){\n        rotate = vec3(0, 0, 0);\n        translate = vec3(0,1,-1);\n    }\n    mat3 Rxyz = Rotation(rotate, deg);\n    ray.dir = Rxyz * ray.dir;\n    ray.origin = translate;\n    \n    // Start recurive raytracing\n    for (int i=0; i<totalRays+1; i++){\n        reflectionRays[i] = Ray(vec3(0), vec3(0), 0.0, 0.0);\n        refractionRays[i] = Ray(vec3(0), vec3(0), 0.0, 0.0);\n    }\n    reflectionRays[0] = ray;\n    vec4 finalCol = vec4(0);\n    for(int iter=0; iter<R; iter++)\n        finalCol += CastRays(iter);\n    \n    // Output to screen\n    fragColor = finalCol;\n}","name":"Image","description":"","type":"image"}]}