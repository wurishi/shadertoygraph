{"ver":"0.1","info":{"id":"XlB3DV","date":"1432420624","viewed":933,"name":"Distance Ruler","username":"notlion","description":"Auto scaling distance measurement. Inspired by Johann Korndorfer's NVScene talk: https://www.youtube.com/watch?v=s8nFqwOho-s","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Based on Template 3D by iq: https://www.shadertoy.com/view/ldfSWs\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    float an = 0.217 * iTime + 10.0 * mouse.x;\n   \tcamTar = vec3(0.0, -2.0, 0.0);\n    float d = 2.0 + sin(an) * 1.525;\n    d *= d;\n    camPos = vec3(3. * sin(an), 2., 3. * cos(an)) * d;\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec3 doBackground(void) {\n    return vec3(0.0);\n}\n\nfloat doModel(vec3 p) {\n    float t = iTime * 0.5;\n    return min(sdBox(p, vec3(0.5)),\n               sdSphere(p + vec3(cos(t), sin(t * 0.831), sin(t * 1.379)), 0.5));\n}\n\nvec3 doMaterial(in vec3 pos, in vec3 nor) {\n    return vec3(.8);\n}\n\n\nfloat doRulerModel(vec3 p) {\n    return abs(p.y) - 0.01;\n}\n\nfloat rule(float d, float scale) {\n    return mix(1., .35, smoothstep(.6, 1., abs(fract(d * scale) * 2. - 1.)));\n}\n\nvec3 rulerColor(float t) {\n    t = clamp(log(t+1.0), 0.0, 1.0);\n    return mix(mix(vec3(0.,.1,1.), vec3(1.,.1,0.), t*5.), vec3(1.0), smoothstep(.2,.5,t));\n}\n\nvec3 doRulerMaterial(vec3 p, float d, float t) {\n    float lt = log(t) / log(10.0);\n    float s = pow(10.0, -floor(lt));\n    float m = smoothstep(0.0, 0.33, fract(lt));\n    float r = rule(d, s * 10.) * mix(rule(d, s * 100.0), rule(d, s), m);\n    return mix(rulerColor(s * d), rulerColor(s * d * 0.1), m) * 0.8 * r;\n}\n\nfloat doCombinedModels(vec3 p) {\n    return min(doModel(p), doRulerModel(p));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd);\n\nvec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal) {\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3 lig = normalize(vec3(1.5, 0.7, 0.9));\n    float dif = max(dot(nor, lig), 0.0);\n    float sha = 0.0;\n    if (dif > 0.01) sha = calcSoftshadow(pos + 0.01 * nor, lig);\n    lin += dif * vec3(2.) * sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.1);\n\n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal * lin;\n\n    // fog\n    //-----------------------------\n    col *= exp(-0.0005 * dis * dis);\n\n    return col;\n}\n\nvec3 calcIntersection(in vec3 ro, in vec3 rd) {\n    const float maxd = 100.0;    // max trace distance\n    const float precis = 0.00001; // precission of the intersection\n    vec3 p;\n    float h = precis * 2.0;\n    float d, r;\n    float t = 0.0;\n    float res = -1.0;\n    for (int i = 0; i < 90; i++) // max number of raymarching iterations is 90\n    {\n        if (h < precis || t > maxd) break;\n        p = ro + rd * t;\n        r = doRulerModel(p);\n        d = doModel(p);\n        h = min(d, r);\n        t += h;\n    }\n\n    if (t < maxd) res = t;\n    return vec3(res, r < d ? 1.0 : 0.0, d);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    const float eps = 0.002; // precision of the normal computation\n\n    const vec3 v1 = vec3(1.0, -1.0, -1.0);\n    const vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    const vec3 v4 = vec3(1.0, 1.0, 1.0);\n\n    return normalize(v1 * doCombinedModels(pos + v1 * eps) + \n                     v2 * doCombinedModels(pos + v2 * eps) +\n                     v3 * doCombinedModels(pos + v3 * eps) + \n                     v4 * doCombinedModels(pos + v4 * eps));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd) {\n    float res = 1.0;\n    float t = 0.0005; // selfintersection avoidance distance\n    float h = 1.0;\n    for (int i = 0; i < 40; i++) { // 40 is the max numnber of raymarching steps\n        h = doModel(ro + rd * t);\n        res = min(res, 64.0 * h / t); // 64 is the hardness of the shadows\n        t += clamp(h, 0.01, 2.0);     // limit the max and min stepping distances\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n    // camera movement\n    vec3 ro, ta;\n    doCamera(ro, ta, iTime, m);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix(ro, ta, 0.0); // 0.0 is the camera roll\n\n    // create view ray\n    vec3 rd = normalize(camMat * vec3(p.xy, 2.0)); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n    // render\n    //-----------------------------------------------------\n\n    vec3 col = doBackground();\n\n    // raymarch\n    vec3 t = calcIntersection(ro, rd);\n    if (t.x > -0.5) {\n        // geometry\n        vec3 pos = ro + t.x * rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal;\n        if (t.y > 0.)\n            mal = doRulerMaterial(pos, t.z, t.x);\n        else\n            mal = doMaterial(pos, nor);\n\n        col = doLighting(pos, nor, rd, t.x, mal);\n    }\n\n    //-----------------------------------------------------\n    // postprocessing\n    //-----------------------------------------------------\n\n    // gamma\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}