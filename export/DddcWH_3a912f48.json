{"ver":"0.1","info":{"id":"DddcWH","date":"1695009927","viewed":89,"name":"Liquid Fractal Visualizer","username":"DigitalShadow","description":"A more refined version of an earlier shader","likes":1,"published":1,"flags":36,"usePreview":0,"tags":["fractal","chaos","strangeattractor","microphone","escapemap"],"hasliked":0,"parentid":"ddccD8","parentname":"Dancing Attractor Visualization"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 1e-10;\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 HSLtoRGB(in vec3 hsl)\n{\n    // Hue-Saturation-Lightness [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsl.x);\n    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n\nvec3 RGBtoHSV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 RGBtoHSL(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Lightness [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float z = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);\n    return vec3(hcv.x, s, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float cycle = mod(iTime, 3.)/3.;\n    fragColor = texture(iChannel0, vec2(1.0-uv.x, 1.0-uv.y));  \n\n\n    //cycle hue\n    vec3 hsv=RGBtoHSV(fragColor.rgb);\n    hsv.r = mod(hsv.r + iTime / 10., 1.0);\n    hsv = HSVtoRGB(hsv);\n    fragColor.rgb = hsv;   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define itr 100\n#define maxL 1000.\n#define fade .33\n#define eqBands 12.\n#define freqPerBand 5.\n#define reactAmt 0.04\n#define sweepAmt 0.5\n\n//tension curve transfer function\nfloat curve(float x){\n    x = 1.0 - x;\n    x = x*x*x;\n    x = 1.0 - x;\n    return x;\n}\n\n//get max value at specified frequency spread\nfloat getBand(float x){\n    float band = floor(x*eqBands);\n    float coarseSpacing = 1.0 / eqBands;\n    float fineSpacing = coarseSpacing / freqPerBand;\n    float start = coarseSpacing * band;\n    float val = 0.0;\n    float c;\n    for(float i=0.0; i < freqPerBand; i++){\n        c=(start + fineSpacing * i);\n        c = c*c*c; //better frequency response curve\n        val = max(val,texture(iChannel0, vec2(c, 0.25)).r);\n    }\n    return val;\n}\n\n\nint iterate(vec2 p, out float minD, out float maxD){\n    \n    //coefficients\n    float a1 =  -0.5 + reactAmt * getBand(0.0 / 12.0);\n    float a2 =  -1.5 + reactAmt * getBand(1.0 / 12.0) + sweepAmt * sin(iTime/5.);\n    float a3 =  -0.5 + reactAmt * getBand(2.0 / 12.0) + sweepAmt * cos(iTime/6.);\n    float a4 =   0.1 + reactAmt * getBand(3.0 / 12.0) + sweepAmt * sin(iTime/7.);\n    float a5 =  -0.8 + reactAmt * getBand(4.0 / 12.0) + sweepAmt * cos(iTime/8.);\n    float a6 =   0.2 + reactAmt * getBand(5.0 / 12.0) + sweepAmt * sin(iTime/9.);\n    float a7 =  -0.9 + reactAmt * getBand(6.0 / 12.0) + sweepAmt * cos(iTime/10.);\n    float a8 =   0.9 + reactAmt * getBand(7.0 / 12.0) + sweepAmt * cos(iTime/11.);\n    float a9 =   0.1 + reactAmt * getBand(8.0 / 12.0) + sweepAmt * cos(iTime/12.);\n    float a10 = -0.3 + reactAmt * getBand(9.0 / 12.0) + sweepAmt * cos(iTime/13.);\n    float a11 = -1.5 + reactAmt * getBand(10.0 / 12.0)+ sweepAmt * cos(iTime/14.);\n    float a12 =  0.3 + reactAmt * getBand(11.0 / 12.0)+ sweepAmt * cos(iTime/15.);\n    \n    //optimize math\n    float x2, y2, xy;\n    \n    vec2 o = p;  //point origin\n    float d;     //distance from origin\n    minD=1.0;    //max distance\n    maxD=0.0;    //min distance\n    \n    int i=0;\n    while (i < itr){\n        x2 = p.x * p.x;\n        y2 = p.y * p.y;\n        xy = p.x * p.y;\n        \n        //x = a1  + a2 *P.x + a3 *x2 + a4 *xy + a5 *P.y + a6 *y2;\n        //y = a7  + a8 *P.x + a9 *x2 + a10*xy + a11*P.y + a12*y2;\n        p = vec2(a1  + a2 *p.x + a3 *x2 + a4 *xy + a5 *p.y + a6 *y2, a7  + a8 *p.x + a9 *x2 + a10*xy + a11*p.y + a12*y2);\n        \n        if (length(p) > maxL) break;\n        //omit square root from distance formula inside iteration loop to optimize\n        d = (o.x-p.x)*(o.x-p.x) + (o.y-p.y)*(o.y-p.y);\n        minD = min(d, minD);\n        maxD = max(d, maxD);\n        i++;\n    }\n    //apply the sqrt oustide iteration loop, end result is the same for much less cpu\n    minD = sqrt(minD);\n    maxD = sqrt(maxD);\n    return i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float zoom = 10. + 0.5* getBand(0.) + 5.*sin(iTime/10.);\n    float minD, maxD;\n    \n    //Measure how many iterations it takes to escape bounds\n    int i = iterate((uv*20.0 - 12.)/zoom, minD, maxD);\n    float t= float(i) / float(itr);\n  \n    //mix existing image and new to temporally smooth pixel values\n    vec3 ghost = texture(iChannel1, uv).rgb;\n    vec3 col = vec3(curve(t)*3. - sqrt(t), maxD/maxL, curve(1./maxD/minD));\n    col=fract(col);\n   \n    fragColor = vec4(col*fade + ghost*(1.0-fade),1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}