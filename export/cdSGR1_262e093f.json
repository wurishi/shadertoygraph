{"ver":"0.1","info":{"id":"cdSGR1","date":"1701551911","viewed":76,"name":"6-step commutation","username":"vlsh","description":"6-step commutation of electric motor demonstrated.\nTODO: \nSPEED CONTROL, EDEG, POLAR GRID, RPM\n","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["procedural","2d","math","diagram"],"hasliked":0,"parentid":"ftGfzh","parentname":"Simple Steering Kinematics"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Phase colors\nconst vec3 UVW_COLORS[3] = vec3[](\n    vec3(1.0, 0.4, 0.4),    // U\n    vec3(0.8, 1.0, 0.4),    // V\n    vec3(0.18, 0.76, 0.71)  // W\n);\n\n\nfloat keyPress(int key) {\n    return texelFetch( iChannel3, ivec2(key,0), 0 ).x;\n}\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 rotate(vec2 v, float angle)\n{\n    float cosA = cos(angle), sinA = sin(angle);\n    return v.x * vec2(cosA, sinA) + v.y * vec2(-sinA, cosA);\n}\n\nvec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\n// COMPONENT OF B ONTO A\nfloat comp(vec2 a, vec2 b)\n{\n    return dot(a, b)/(length(a));\n}\n\nfloat sdistLineSegment(vec2 a, vec2 b, vec2 pos)\n{\n    vec2 v = pos - a;\n    vec2 ab = b - a;\n    float s = comp(ab,v)/length(ab);\n    if (s<0.0) {\n        return length(pos - a);\n    } else if(s>1.0) {\n        return length(pos - b);\n    }\n    // 0.0 < s < 1.0\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nvec2 getChar(vec2 uv,  int c)\n{     \n    float x = (1.0 / 16.) *  fract ( float(c) / 16.)  * 16. + uv.x /16. ;   \n    float y = (1.0/16.) *  (16.- float(c/16) - 1.0 ) + uv.y/16. ;     \n    return vec2(x, y);\n}\n\nfloat stepDigitSdf(int step, vec2 uv)\n{\n    vec2 uv2 = getChar(uv,  48 + step);\n    if ((uv.x > 0.0 && uv.y > 0.0) && (uv.x < 1.0 && uv.y < 1.0)) return texture(iChannel1, uv2).w - 0.5;\n    else return 1e6;\n}\n\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 fragColor2 = vec3(0);\n    vec3 background = vec3(0.4,0.4 + 0.4*pos.y/5.0,0.4 + 0.4*pos.y/2.0);\n    vec3 axes = vec3(1.0);\n    vec3 lines = vec3(0.1);\n    vec3 sublines = vec3(0.05);\n    float subdiv = 8.0;\n\n    float thickness = 0.005;\n    float aa = length(fwidth(pos));\n\n    fragColor2 = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), background + sublines, fragColor2, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), background + lines, fragColor2, thickness, 0.01);\n\n    //stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n    fragColor = fragColor2*0.9;\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderCircle(vec2 center, float radius, vec2 pos, inout vec3 fragColor)\n{\n    float dist = length(pos - center) - radius;\n    stroke(dist, vec3(1, 1, 1), fragColor, 0.003, length(fwidth(pos)));\n}\n\nvoid renderCircleSolid(vec2 center, float radius, vec2 pos, vec3 col, inout vec3 fragColor)\n{\n    float dist = length(pos - center) - radius;\n    float aa = length(fwidth(pos));\n    fill(dist, col, fragColor, aa);\n}\n\nvoid renderCircleColored(vec2 center, float radius, vec2 pos, vec3 col, inout vec3 fragColor)\n{\n    float dist = length(pos - center) - radius;\n    stroke(dist, col, fragColor, 0.003, length(fwidth(pos)));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.375 - 6.0 * 0.0075;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = (fragCoord / iResolution.y) * 1.0 - vec2((1.0*aspect)/2.0, 1.0/2.0);\n    vec2 mou = (iMouse.xy / iResolution.y) * 1.0 - vec2((1.0*aspect)/2.0, 1.0/2.0);\n   \n\n    // Grid\n    fragColor.a = 1.0;\n\trenderGrid(pos*4.0, fragColor.rgb);\n    \n    // Get current commutation step from the buffer\n    int step = int((texelFetch( iChannel0,  COMMAND_STEP, 0 )).x);\n    \n    // Draw step number\n    float digitSdf = stepDigitSdf(step + 1, pos*10.0 + vec2(0.5,0.5));\n    fill(digitSdf, vec3(1.0), fragColor.rgb, length(fwidth(pos)));\n        \n    // Draw coils, these don't move, but change polarity depending on commutation step\n    for (int i = 0; i < COILS; i++) {\n        int color_index = i % 3; // get phase\n        renderCircleColored(getCoilPosition(i), 0.02, pos, UVW_COLORS[color_index], fragColor.rgb);\n        \n        // Lookup commutation pattern\n        vec3 coil_states = COIL_STATES[step];\n        \n        // Draw coil polarity\n        if (abs(getCoilPolarity(i,step)) > 0.01) {\n            vec3 polarity_color = vec3(0);\n            if (coil_states[color_index] > 0.0) {\n                polarity_color = vec3(1.0,0.0,0.0); \n            } else {\n                 polarity_color = vec3(0.0,0.0,1.0);\n            }\n            renderCircleSolid(getCoilPosition(i), 0.017, pos, polarity_color, fragColor.rgb);\n        }\n        \n    }\n    \n    // Draw rotor, need to know its angle stored in buffer\n    float angle = texelFetch( iChannel0,  ROTOR_ANGLE, 0 ).x;\n    for (int i = 0; i < MAGNETS; i++) {\n        vec3 polarity_color = vec3(0);\n        if (i % 2 == 0) {\n            polarity_color = vec3(1.0,0.0,0.0); \n        } else {\n            polarity_color = vec3(0.0,0.0,1.0);\n        }\n\n        renderCircleSolid(getMagnetPosition(i, angle), 0.017, pos, polarity_color, fragColor.rgb);\n    }\n    \n    // EDEG full rotatation\n    vec2 edeg_vec = 0.5*vec2(cos(EDEG_PER_REV), sin(EDEG_PER_REV));\n    float edge_vec_d = sdistLineSegment(vec2(0,0), edeg_vec, pos);\n    //stroke(edge_vec_d, vec3(1.0, 1.0, 1.0), fragColor.rgb, 0.003, length(fwidth(pos)));\n    \n    edeg_vec = 0.5*vec2(cos(MDEG_PER_STEP), sin(MDEG_PER_STEP));\n    edge_vec_d = sdistLineSegment(vec2(0,0), edeg_vec, pos);\n    //stroke(edge_vec_d, vec3(1.0, 1.0, 1.0), fragColor.rgb, 0.003, length(fwidth(pos)));\n    //void stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n    \n    renderCircleSolid(getMagnetPosition(0, angle)*0.9, 0.003, pos, vec3(1.0), fragColor.rgb);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat keyPress(int key) {\n    return texelFetch( iChannel3, ivec2(key,0), 0 ).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iTime < 1.0) discard;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 mousePos = (iMouse.xy / iResolution.y) * 1.0 - vec2((1.0*aspect)/2.0, 1.0/2.0);\n\n    fragColor = texelFetch( iChannel0,  ivec2(fragCoord), 0 );\n    if ((ivec2(fragCoord.xy) == COMMAND_STEP) && STEPS_PER_SECOND > 0.0) {\n        //float step = mod(iTime*STEPS_PER_SECOND, 6.0);\n        float angle = texelFetch( iChannel0,  ROTOR_ANGLE, 0 ).x;\n        float step = mod(floor(angle/MDEG_PER_STEP)+0.0, 6.0);\n        fragColor = vec4(step);\n    } else {\n        float step = (texelFetch( iChannel0,  COMMAND_STEP, 0 )).x;\n        \n        if (keyPress(KEY_STEP_1) > 0.0) {\n            step = 0.0;\n        }\n        \n        if (keyPress(KEY_STEP_2) > 0.0) {\n            step = 1.0;\n        }\n        \n        if (keyPress(KEY_STEP_3) > 0.0) {\n            step = 2.0;\n        }\n        \n        if (keyPress(KEY_STEP_4) > 0.0) {\n            step = 3.0;\n        }\n        \n        if (keyPress(KEY_STEP_5) > 0.0) {\n            step = 4.0;\n        }\n        \n        if (keyPress(KEY_STEP_6) > 0.0) {\n            step = 5.0;\n        }\n        \n        fragColor = vec4(step);\n    }\n    \n    if(ivec2(fragCoord.xy) == ROTOR_ANGULAR_TORQUE) {\n        float angle = texelFetch( iChannel0,  ROTOR_ANGLE, 0 ).x;\n        int step = int(texelFetch( iChannel0, COMMAND_STEP, 0 ).x);\n        float torque_total = 0.0;\n       \n        for (int i = 0; i < MAGNETS; i++) {\n            vec2 pm = getMagnetPosition(i, angle);\n            for (int j = 0; j < COILS; j++) {\n                vec2 pc = getCoilPosition(j);\n                vec2 v = pc - pm; // vector from magnet to coil\n                vec2 d = v/length(v); // direction from magnet to coil\n                vec2 F = FORCE*d*(-getCoilPolarity(j,step))*getMagnetPolarity(i);\n                F = F*(1.0/(length(v)*length(v))); // force inversely proportional to distance squared\n                vec2 r = pm;\n                float torque = -cross(vec3(F,0),vec3(r,0)).z;\n                torque_total += torque;\n            }\n        }\n\n        fragColor = vec4(torque_total);\n    }\n    \n    if(ivec2(fragCoord.xy) == ROTOR_ANGULAR_VELOCITY) {\n        float torque = texelFetch( iChannel0, ROTOR_ANGULAR_TORQUE, 0 ).x;\n        float acceleration = torque/(MAGNET_INERTIA*float(MAGNETS));\n        float old_velocity = texelFetch( iChannel0,  ivec2(fragCoord), 0 ).x;\n        acceleration = acceleration - old_velocity*DUMPING;\n        float new_velocity = old_velocity + iTimeDelta*acceleration;\n        fragColor = vec4(new_velocity);\n    }\n    \n    if(ivec2(fragCoord.xy) == ROTOR_ANGLE) {\n        float old_angle = texelFetch( iChannel0,  ivec2(fragCoord), 0 ).x;\n        float new_angle = old_angle + iTimeDelta*texelFetch( iChannel0, ROTOR_ANGULAR_VELOCITY, 0 ).x;\n        fragColor = vec4(new_angle);\n    }\n    \n    //fragColor = vec4(texelFetch( iChannel0, fragCoord, 0 ));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926538;\nconst int MAGNETS = 6;    // Multiples of 2 only\nconst int COILS = 9;      // Multiples of 3 only\nconst float COIL_R = 0.3;\nconst float ROTOR_R = COIL_R-0.05;\nconst float MAGNET_INERTIA = 1000.0;\nconst float DUMPING = 0.01;\nconst float STEPS_PER_SECOND = 1.0;\nconst float FORCE = 10.0;\nconst float EDEG_PER_REV = (2.0*PI)/(float(MAGNETS)*0.5);\nconst float MDEG_PER_STEP = EDEG_PER_REV/6.0;\n\nconst int KEY_STEP_1 = 49; // 1\nconst int KEY_STEP_2 = 50; // 2\nconst int KEY_STEP_3 = 51; // 3\nconst int KEY_STEP_4 = 52; // 4\nconst int KEY_STEP_5 = 53; // 5\nconst int KEY_STEP_6 = 54; // 6\n\nconst vec3 COIL_STATES[6] = vec3[](\n    vec3(0.0, -1.0, 1.0),  // 1\n    vec3(1.0, -1.0, 0.0),  // 2\n    vec3(1.0, 0.0, -1.0),  // 3\n    vec3(0.0, 1.0, -1.0),  // 4\n    vec3(-1.0, 1.0, 0.0),  // 5\n    vec3(-1.0, 0.0, 1.0)   // 6\n);\n\n\n// Buffer storage locations\nconst ivec2 COMMAND_STEP = ivec2(0,0);\nconst ivec2 ROTOR_ANGLE = ivec2(0,1);\nconst ivec2 ROTOR_ANGULAR_VELOCITY = ivec2(0,2);\nconst ivec2 ROTOR_ANGULAR_TORQUE = ivec2(0,3);\nconst ivec2 ROTOR_EDEG = ivec2(0,4);\n\n\nvec2 getCoilPosition(int N) {\n    float deg_per_coil = 2.0*PI/float(COILS);\n    return COIL_R*vec2(cos(deg_per_coil*float(N)),sin(deg_per_coil*float(N)));\n}\n\nvec2 getMagnetPosition(int N, float angle) {\n    float deg_per_magnet = 2.0*PI/float(MAGNETS);\n    return ROTOR_R*vec2(cos(deg_per_magnet*float(N) + angle),sin(deg_per_magnet*float(N) + angle));\n}\n\nfloat getMagnetPolarity(int N) {\n    if (N % 2 == 0) {\n        return 1.0;\n    }\n    else {\n        return -1.0;\n    }\n}\n\nfloat getCoilPolarity(int N, int step) {\n    int color_index = int(mod(float(N), 3.0)); // get phase\n    vec3 coil_states = COIL_STATES[step];\n    return coil_states[color_index];\n}\n\n\n\n// N = MAGNETS * COILS / GCD (MAGNETS, COILS)\n","name":"Common","description":"","type":"common"}]}