{"ver":"0.1","info":{"id":"lf23D1","date":"1704313008","viewed":47,"name":"Earth and Moon raymarching","username":"BhanosTD","description":"Simple sphere renderer","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RANGE 100.\n#define MAX_STEPS 100\n#define MARGIN 0.001\n#define SPHERE_AMOUNT 2\n\nconst vec3 sunDir = normalize(vec3(1., 1., -0.9));\n\nstruct Sphere{\n\tvec3 pos;\n\tfloat r;\n\tvec3 col;\n\tint type;\n};\n\nstruct HitData{\n\tbool hasCollided;\n\tSphere obj;\n\tvec3 pos;\n\tvec3 norm;\n    float dot;\n};\n\nSphere spheres[SPHERE_AMOUNT];\n\nvec3 random3(vec3 st){\n    st = vec3( dot(st,vec3(127.1,311.7,759.3)),\n              dot(st,vec3(269.5,183.3, 374.2)),\n              dot(st,vec3(281.5,952.3, 592.2)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Modified Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec3 st) {\n    vec3 i = floor(st);\n    vec3 f = fract(st);\n\n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix(mix( mix( dot( random3(i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n                     dot( random3(i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                mix( dot( random3(i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n                     dot( random3(i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n           mix( mix( dot( random3(i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n                     dot( random3(i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                mix( dot( random3(i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n                     dot( random3(i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z)\n                     ;\n}\n\n//My own voronoi implementation\n\nvec3 getCellOffset(ivec3 cell){\n\treturn random3(vec3(cell));\n\n}\n\nfloat voronoi(vec3 uv){\n\tivec3 cell = ivec3(uv);\n\n\tfloat minDist = 10.;\n\n\tfor(int x = -1; x <= 1; x++){\n\t\tfor(int y = -1; y <= 1; y++){\n\t\t\tfor(int z = -1; z <= 1; z++){\n\t\t\t\tminDist = min(minDist, length(uv - vec3(cell + ivec3(x, y, z)) - getCellOffset(cell + ivec3(x, y, z))));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn minDist;\n}\n\n\nHitData MarchRay(vec3 from, vec3 dir)\n{\n\tfloat distLeft = MAX_RANGE;\n\tint stepsLeft = MAX_STEPS;\n\n\tvec3 curPos = from;\n\tvec3 col = vec3(0);\n\n\tHitData hData;\n\thData.hasCollided = false;\n\n\twhile(stepsLeft > 0 && distLeft > 0.)\n\t{\n\t\tfloat minDist = MAX_RANGE;\n\n\t\tfor(int i = 0; i < SPHERE_AMOUNT; i++)\n\t\t{\n\t\t\tminDist = min(distance(curPos, spheres[i].pos) -spheres[i].r, minDist);\n\n\t\t\tif(minDist < MARGIN)\n\t\t\t{\n\t\t\t\thData.obj = spheres[i];\n\t\t\t\thData.hasCollided = true;\n\t\t\t\thData.pos = curPos + normalize(curPos - spheres[i].pos) * MARGIN * 1.1;\n\t\t\t\thData.norm = normalize(curPos - hData.obj.pos);\n                hData.dot = dot(hData.norm, dir);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcurPos += dir * minDist;\n\t\tdistLeft -= minDist;\n\t\tstepsLeft -= 1;\n\t}\n\n\treturn hData;\n}\n\nvec3 RotateY(vec3 vec, float rot){\n\treturn vec3(sin(rot)*vec.z + cos(rot) * vec.x, vec.y, -sin(rot) * vec.x + cos(rot) * vec.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = gl_FragCoord.xy / iResolution.x;\n\n\tspheres[0] = Sphere(vec3(0,0,0), 1., vec3(0.1, 0.2, 1.), 0);\n\tspheres[1] = Sphere(vec3(2. * sin(iTime),0.4*sin(iTime), 2. * cos(iTime)), 0.3, vec3(0.9, 0.9, 0.9), 1);\n\n\n\tHitData hData = MarchRay(vec3(0, 0.5 + 0.5*sin(iTime * 0.5), -5), normalize(vec3((uv - vec2(0.5, iResolution.y/iResolution.x*0.5)) * 2., 1.)));\n\n\tvec3 col = vec3(0.);\n\n\tif(hData.hasCollided)\n\t{\n\t\tif(hData.obj.type == 0)\n\t\t{\n\t\t\tcol = mix(vec3(0, 1, 0), vec3(0, 0, 1), float((noise(RotateY(hData.pos, iTime)+noise(RotateY(hData.pos*10., iTime))*0.2)*0.5+0.5)<0.6));\n\n\t\t\tfloat atm = 0.3*float(hData.dot > -0.3);\n            \n            col += vec3(0, atm, atm);\n\t\t}\n\t\telse if(hData.obj.type == 1)\n\t\t{\n\t\t\tcol = vec3(float(voronoi(RotateY(hData.pos - hData.obj.pos, -1.*iTime)*10.)>0.5)*0.1 + 0.5);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcol = hData.obj.col;\n\t\t}\n\n\t\tcol *= vec3(1.) - 0.5 * float(MarchRay(hData.pos, sunDir).hasCollided);\n\t}\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}