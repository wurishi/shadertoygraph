{"ver":"0.1","info":{"id":"lt33Rj","date":"1470224787","viewed":230,"name":"Mosquito Coil","username":"Sobaya","description":"Japanese Mosquito Coil.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3ddistancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float fov = 0.2;\nconst float eps = 0.001;\nconst float pi = 3.1415926535;\n\nfloat rand(vec3 p) {\n  return fract(sin(dot(p, vec3(12.9898, 78.233, 114514.1919810))) * 43758.5453);\n}\n\nfloat interpolate(float x, float y, float t) {\n  t = t * t * (3. - 2. * t);\n  return x * (1.-t) + y * t;\n}\n\nfloat irand(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  float rand1 = rand(i);\n  float rand2 = rand(i+vec3(1,0,0));\n  float rand3 = rand(i+vec3(0,0,1));\n  float rand4 = rand(i+vec3(1,0,1));\n  float rand5 = rand(i+vec3(0,1,0));\n  float rand6 = rand(i+vec3(1,1,0));\n  float rand7 = rand(i+vec3(0,1,1));\n  float rand8 = rand(i+vec3(1,1,1));\n  float t1 = interpolate(rand1, rand2, f.x);\n  float t2 = interpolate(rand3, rand4, f.x);\n  float t3 = interpolate(rand5, rand6, f.x);\n  float t4 = interpolate(rand7, rand8, f.x);\n  float s1 = interpolate(t1, t2, f.z);\n  float s2 = interpolate(t3, t4, f.z);\n  return interpolate(s1, s2, f.y);\n}\n\nfloat noise(vec3 p) {\n  float t = 0.;\n  for (int i = 0; i < 8; i++) {\n    float freq = pow(2., float(i));\n    float amp = pow(0.5, float(8-i));\n    t += irand(p / freq) * amp;\n  }\n  return t;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat length8(vec2 p) {\n  float x = 1., y = 1.;\n  for (int i = 0; i < 8; i++) {\n    x *= p.x;\n    y *= p.y;\n  }\n  return pow(x + y, 1.0 / 8.);\n}\n\nvec3 translate(vec3 p, vec3 t) {\n  return p - t;\n}\n\nvec3 rotate(vec3 p, vec3 n, float a) {\n  a *= pi / 180.;\n  float c = cos(a);\n  float s = -sin(a);\n   mat3 m = mat3(\n       n.x*n.x*(1.-c)+c, n.x*n.y*(1.-c)+n.z*s, n.x*n.z*(1.-c)-n.y*s,\n       n.y*n.x*(1.-c)-n.z*s, n.y*n.y*(1.-c)+c, n.y*n.z*(1.-c)+n.x*s,\n       n.z*n.x*(1.-c)+n.y*s, n.z*n.y*(1.-c)-n.x*s, n.z*n.z*(1.-c)+c\n       );\n   return m * p;\n}\n\nvec3 scale(vec3 p, vec3 s) {\n  return p / s;\n}\n\nvec3 fireEnd(float t) {\n  float n = floor((20. - t * 0.01) / (2. * pi));\n  float angle = 20. - t * 0.01 - n * 2. * pi;\n  float len = angle * 0.48 + 3. * n + 1.;\n  return vec3(sin(angle) * len, 0, cos(angle) * len);\n}\n\nfloat fire(vec3 p) {\n  p = translate(p, fireEnd(iTime) + vec3(0,5,0));\n  p = scale(p, vec3(2,8,2)*4.);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - 1.;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat body(vec3 p) {\n  p = translate(p, vec3(0.4,3,0));\n  float sub = p.y + 0.0;\n  float len = length(p.xz);\n  float angle = atan(p.x, p.z);\n  if (angle < 0.) angle += 2. * pi;\n  if (angle > 2. * pi) angle -= 2. * pi;\n  float n = floor((len - angle * 0.48+1.) / 3. - 0.2);\n  float t = angle + n * 2. * pi;\n  if (t > 20. - iTime * 0.01) return 1.;\n  vec2 q = vec2(mod(len - angle * 0.48, 3.)-1., p.y);\n  float result = length8(q) - 0.5;\n  result = max(result, sub);\n//  if (abs(result) < eps * 3)\n    result -= noise(p * 300.) * 0.1;\n  return result;\n}\n\nfloat distSaucer(vec3 p) {\n  p = translate(p,vec3(0,-3,0));\n  vec2 q = abs(vec2(length(p.zx), p.y / 20.)) - 0.3;\n  float bar = min(max(q.x,q.y),0.) + length(max(q,0.));\n  q = vec2(length(p.xz) - 10., p.y + 1.0);\n  float torus = length(q) - 0.2;\n  float bottom2 = max(max(-p.y-3.9, p.y + 3.5), length(p-vec3(0,-2,0)) - 10.);\n  p = translate(p, vec3(0,-1,0));\n  p = scale(p, vec3(1,30,1));\n  q = vec2(length(p.xz) - 10., p.y);\n  float result = length8(q) - 0.1;\n  result = min(result, bottom2);\n  result = min(result, torus);\n  result = min(result, bar);\n  return result;\n}\n\nfloat dist(vec3 p) {\n  return min(body(p), distSaucer(p));\n}\n\nint getNearestIndex(vec3 p) {\n  float minDist = body(p);\n  int idx = 0;\n  float d = distSaucer(p);\n  if (d < minDist) {\n    minDist = d;\n    idx = 1;\n  }\n  return idx;\n}\n\nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n        dist(p+vec3(eps,0,0)) - dist(p),\n        dist(p+vec3(0,eps,0)) - dist(p),\n        dist(p+vec3(0,0,eps)) - dist(p)\n      ));\n}\n\n\nvec3 rayMarch(vec3 eye, vec3 ray) {\n  vec3 current = eye;\n  for (int i = 0; i < 200; i++) {\n    float d = dist(current);\n    current += ray * d;\n    if (abs(d) < eps) {\n      break;\n    }\n  }\n  return current;\n}\n\nvec3 rayMarchFire(vec3 eye, vec3 ray) {\n  vec3 current = eye;\n  for (int i = 0; i < 100; i++) {\n    float d = fire(current);\n    current += ray * d;\n    if (abs(d) < eps) {\n      break;\n    }\n  }\n  return current;\n}\n\nvec2 cubeMap(vec3 current, vec3 vec) {\n  vec2 result;\n  vec3 tmp;\n  float minT = 1145141919.;\n  float size = 100.;\n  float t;\n\n  //===========x\n  t = (size - current.x) / vec.x;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n    minT = t;\n  }\n\n  t = (-size - current.x) / vec.x;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.y, tmp.z);\n    minT = t;\n  }\n\n  //===============y\n  t = (size - current.y) / vec.y;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n    minT = t;\n  }\n\n  t = (-size - current.y) / vec.y;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.z, tmp.x);\n    minT = t;\n  }\n\n  //==============z\n  t = (size - current.z) / vec.z;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n    minT = t;\n  }\n\n  t = (-size - current.z) / vec.z;\n  if (0. < t && t < minT) {\n    tmp = current + t * vec;\n    result = vec2(tmp.x, tmp.y);\n    minT = t;\n  }\n  return result  / (2. * size) + 1.;\n}\n\nvec3 getKatoriColor(vec3 p, vec3 vec) {\n  vec3 n = getNormal(p);\n  float diffuse = max(0.,dot(-vec, n));\n  vec3 difColor = vec3(0,0.5,0.3) * 0.8;\n  float len = length((p - fireEnd(iTime)).xz);\n  vec3 gray = vec3(0.7);\n  vec3 red = vec3(0.4,0,0);\n  vec3 black = vec3(0);\n  if (len < 0.7) {\n    difColor = gray;\n  } else if (len < 0.85) {\n    float t = (len - 0.7) / 0.15;\n    difColor = gray * (1.-t) + red * t;\n  } else if (len < 0.95) {\n    difColor = red;\n  } else if (len < 1.1) {\n    float t = (len - 0.95) / 0.15;\n    difColor = red * (1.-t) + black * t;\n  } else if (len < 1.2) {\n    difColor = black;\n  }\n  return difColor * diffuse;\n}\n\nvec3 getSaucerColor(vec3 p, vec3 vec) {\n  float diffuse = max(0.,dot(-vec, getNormal(p)));\n  vec = reflect(vec, getNormal(p));\n  p += vec;\n  int idx = 1;\n  for (int j = 0; j < 3; j++) {\n    p = rayMarch(p, vec);\n    if (abs(dist(p)) > eps) break;\n    if (getNearestIndex(p) == 0) {\n      idx = 0;\n      break;\n    }\n    vec = reflect(vec, getNormal(p));\n  }\n  vec3 reflectColor;\n  if (idx == 0) {\n    reflectColor = getKatoriColor(p, vec);\n  } else if (idx == 1) {\n    reflectColor = texture(iChannel0, cubeMap(p, reflect(vec, getNormal(p)))).rgb;\n  }\n  float refRate = 0.2;\n  return reflectColor * refRate + vec3(1) * (1.-refRate) * diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float a = -0.5;\n    float c = cos(a);\n    float s = sin(a);\n    vec3 n = normalize(vec3(1,0,0));\n    mat3 rot;\n\trot[0][0] = n[0]*n[0]*(1.-c)+c;\n\trot[0][1] = n[0]*n[1]*(1.-c)-n[2]*s;\n\trot[0][2] = n[2]*n[0]*(1.-c)+n[1]*s;\n\trot[1][0] = n[0]*n[1]*(1.-c)+n[2]*s;\n\trot[1][1] = n[1]*n[1]*(1.-c)+c;\n\trot[1][2] = n[1]*n[2]*(1.-c)-n[0]*s;\n\trot[2][0] = n[2]*n[0]*(1.-c)-n[1]*s;\n\trot[2][1] = n[1]*n[2]*(1.-c)+n[0]*s;\n\trot[2][2] = n[2]*n[2]*(1.-c)+c;\n\n  vec3 eye = vec3(0,5,-30);\n  eye = rot * eye;\n  vec3 ray = vec3(uv, sqrt(2.) * tan(fov));\n  const float angle = 1.5;\n  ray = vec3(sin(uv * angle), length(cos(uv * angle)));\n  ray = rot * ray;\n  ray = normalize(ray);\n  vec3 current = rayMarch(eye, ray);\n\n  vec3 lightPos = vec3(1,1,-1) * 10.;\n\n  if (abs(dist(current)) < eps) {\n      int idx = getNearestIndex(current);\n      if (idx == 0) {\n        fragColor.rgb = getKatoriColor(current, normalize(current - eye));\n      } else if (idx == 1) {\n        fragColor.rgb = getSaucerColor(current, normalize(current - eye));\n      }\n  } else {\n    fragColor.rgb = vec3(0);\n  }\n  fragColor.a = 1.;\n  current = rayMarchFire(eye, ray);\n  float t = 0.;\n  vec3 firePos = fireEnd(iTime+5.);\n  for (int i = 0; i < 20; i++) {\n    if (current.y < 2.5) continue;\n    float noiseValue = noise((current-firePos) * 300. - iTime * 100.);\n    noiseValue *= 1. - length((current-firePos).xz) * 3. ;\n    noiseValue = clamp(noiseValue, 0., 1.);\n    noiseValue = pow(noiseValue, 2.);\n    t += noiseValue * 0.2;\n    current += ray * 0.5;\n  }\n  fragColor.rgb += t * vec3(0.8) * 10.;\n}","name":"Image","description":"","type":"image"}]}