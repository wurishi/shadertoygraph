{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define inPentagon(p) (pentagon(p).y < 0.)\n#define shadow(d) (1. - 1. / (1. + d))\n#define sdDisk(c) length(u - c) - .02\n#define k cos(pi / 5. + vec2(0, 11))\n#define e vec2(-1, 1)\n#define pi acos(-1.)\n\nvec2 pentagon(vec2 p) {\n    p.x = abs(p.x);\n    p -= 2. * min(dot(k * e, p), .0) * k * e;\n    p -= 2. * min(dot(k, p), .0) * k;\n    \n    float r = .5 * k.y / k.x;\n    p -= vec2(clamp(p.x, - r, r), r);\n    \n    return p;\n}\n\nfloat sdPentagon(vec2 p) {\n    p = pentagon(p);\n    return length(p) * sign(p.y);\n}\n\n\n// a solução analítica provavelmente não deve ser difícil\n// mas a iterativa funciona perfeitamente.\nvec2 clipping(vec2 p) {\n    float d, mind, maxd = 10.;\n    \n    while(maxd - mind > .001) {\n        d = (mind + maxd) / 2.;\n        if(sdPentagon(d * p) > .0) \n            maxd = d;\n        else \n            mind = d;\n    }\n    \n    return mind * p;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), .0, 1.);\n    return length(pa - h * ba) - .005;\n}\n\nfloat sdRay(vec2 u, vec2 m) {\n    return min(\n               min(\n                   sdSegment(u, vec2(0), m), \n                   sdDisk(vec2(0))\n               ), \n               sdDisk(m)\n           );\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy, \n         m = (2. * iMouse.xy - r) / r.y;\n    u = (u + u - r) / r.y;\n    if(iMouse.z < .01) \n        m = vec2(1.2, .8) * cos(iTime * vec2(1.1, 1.3) + vec2(0, 2));\n        \n    \n    // pentagon\n    float d = sdPentagon(u);\n    \n    o = vec4(3, 4, 5, 0) / 10. \n        * (\n            d < .0\n                ? 1.4\n                : shadow(250. * d)\n          )\n        * (.05 * cos(120. * abs(d)) + 1.);\n        \n    // ray\n    d = sdRay(u, m);\n    o = max(o * shadow(260. * d), vec4(1, 1, 0, 0) * smoothstep(5. / r.y, .0, d));\n    \n    // intersection \n    if(!inPentagon(m))\n        d = sdDisk(clipping(m)),\n        o = mix(\n                o * shadow(500. * d), \n                vec4(1, 0, 0, 0),\n                smoothstep(4. / r.y, .0, d)\n            );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McVBzV","date":"1734239245","viewed":53,"name":"Clipping Pentagon","username":"Elsio","description":"Clips a point to the boundary of a pentagon while keeping it into the same ray through the origin. \nNOTE that this is DIFFERENT to computing the closest point on the box which you can see here: [url]https://www.shadertoy.com/view/cldSzf[/url]","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","ray","pentagon","clipping"],"hasliked":0,"parentid":"4fyfRV","parentname":"study clipping box (by @iq)"}}