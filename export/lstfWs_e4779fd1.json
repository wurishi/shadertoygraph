{"ver":"0.1","info":{"id":"lstfWs","date":"1527376872","viewed":147,"name":"Perspective sphere intersection","username":"Gar3th","description":"Perspective projection with basic sphere intersection and phong illumination","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["phong","illumination","lighting","pointlight","sphere","intersection","projection","specular","ambient","diffuse","perspective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 SpherePos()\n{\n    // this only needs to be calculated once per frame, not twice per fragment\n    return vec3(iResolution.x/2.0+cos(float(iFrame)/170.0)*200.0, iResolution.y/2.0+sin(float(iFrame)/170.0)*60.0, -50.0);\n}\nbool intersection(vec3 l, vec2 o, inout float dist)\n{\n    bool inter = false;\n    \n    float radius = 50.0;\n    vec3 center = SpherePos();\n    \n    vec3 orig = vec3(o.xy, 0);\n    \n    float toRoot = pow( dot(l,(orig-center)), 2.0 ) - pow( length(orig-center), 2.0 ) + radius*radius;\n    \n    if (toRoot > 0.0) \n    {\n        inter = true;\n        float rooted = sqrt(toRoot);\n        float base = -1.0*(dot(l, orig-center));\n        dist = min(rooted - base, rooted + base); // take the closer intersection (ignore edge cases)\n    }\n    \n    return inter;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pointLight = vec3(iResolution.x,0,50);\n   \n    vec3 backCol = vec3(66.0, 191.0, 244.0); backCol /= vec3(255.0,255.0,255.0);// sky color\n    vec3 sphereCol = vec3(1,0,0);   // red\n    \n    vec3 eye = vec3(iResolution.x/2.0, iResolution.y/2.0, 250.0); // eye is centered on view window and pulled back\n    vec3 ray = vec3(fragCoord,0) - eye;// perspective projection. Could use 0,0,-1 for orthographic projection\n    ray = ray / length(ray); // normalize\n    \n    \n    float dist = 20000.0; // magnatude of ray from view window to intersection\n    if (intersection(ray, fragCoord, dist)) \n    {\n        vec3 center = SpherePos();\n        vec3 interX = ray*dist + vec3(fragCoord,0);\n        vec3 lightRay = pointLight - interX; lightRay /= length(lightRay);\n        fragColor = vec4(sphereCol,1.0) * dot(vec3(ray.x,ray.y,ray.z*-1.0), lightRay); // diffuse lighting\n        \n        vec3 halfWay = (ray*-1.0) + lightRay; halfWay /= length(halfWay); // normalize\n        vec3 objNorm = interX - center;       objNorm /= length(objNorm);\n        float nh = dot(objNorm, halfWay);\n        if (nh > 0.0) fragColor += 0.6 * pow(nh, 125.0) * vec4(1,1,1,0); // specular lighting\n    }\n    else fragColor = vec4(backCol,1.0);\n}","name":"Image","description":"","type":"image"}]}