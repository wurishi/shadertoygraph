{"ver":"0.1","info":{"id":"lfdXWn","date":"1713815499","viewed":77,"name":"liminal trip","username":"RexSitael","description":"some wavy thing","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["animation","liminal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nconst float timeMultiplier = 10.;\nconst float iterations = 60.;\nconst float curvature = 6.;\nfloat theend = 0.;\n\nvec3 rgb(float r, float g, float b) {\n    return vec3(r,g,b)/255.0;\n}\n\nbool isDown(vec2 uv, float iteration, float frameThic) {\n    float powStep = curvature;\n    float maxIter = 1.0 / (frameThic * 2.);\n    float x = uv.x + ((sin(iTime) * ( pow(iteration, powStep))) / pow(maxIter,powStep - 0.5)) / iteration;\n    float y = uv.y + ((cos(iTime) * ( pow(iteration, powStep))) / pow(maxIter,powStep - 0.5)) / iteration;\n    bool down = y < frameThic * iteration;\n    return down;\n}\n\nbool isUp(vec2 uv, float iteration, float frameThic) {\n    float powStep = curvature;\n    float maxIter = 1.0 / (frameThic * 2.);\n    float x = uv.x + ((sin(iTime) * ( pow(iteration, powStep))) / pow(maxIter,powStep - 0.5)) / iteration;\n    float y = uv.y + ((cos(iTime) * ( pow(iteration, powStep))) / pow(maxIter,powStep - 0.5)) / iteration;\n    bool up = y > 1. - frameThic * iteration;\n    return up;\n}\n\n\nbool frame(vec2 uv, float iteration, float frameThic) {\n    float powStep = curvature;\n    float maxIter = 1.0 / (frameThic * 2.);\n    float x = uv.x + ((sin(iTime) * ( pow(iteration, powStep))) / pow(maxIter,powStep - 0.5)) / iteration;\n    float y = uv.y + ((cos(iTime) * ( pow(iteration, powStep))) / pow(maxIter,powStep - 0.5)) / iteration;\n    bool left = x < frameThic * iteration;\n    bool right = x > 1. - frameThic * iteration;\n    bool up = y > 1. - frameThic * iteration;\n    bool down = y < frameThic * iteration;\n    return left || right || up || down;\n}\n\nfloat cycleSin() {\n    float timer = 0.;\n    float mTime = iTime * timeMultiplier;\n    float cosT = abs(cos(mTime));\n    float sinT = abs(sin(mTime));\n    float modByPI = mod(mTime, M_PI);\n    if (modByPI >= 0. && modByPI < M_PI / 2. ) {\n        timer = cosT;\n    } else {\n        timer = sinT;\n    }\n    return -timer;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float iterColl = 1.1 - (iterations - theend)/iterations;\n    vec3 bgCol =  vec3(1., 1., 1.) -  (0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0, 2, 4))) * iterColl;\n    vec3 col = bgCol;\n    float frameThic = (1. / iterations) / 2.;\n    for(float i = iterations - theend; i > -2.; i--) {\n        float iter = i;\n        if (frame(uv,iter - cycleSin(), frameThic)) {\n            float iterCol = 1.1 - iter/iterations;\n            col = (0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0, 2, 4))) * iterCol ;\n            if(isUp(uv,iter - cycleSin(), frameThic)) {\n                col = vec3(1., 1., 1.) - col.xyz;\n            } else if(isDown(uv,iter-cycleSin(), frameThic)) {\n                col = col / 2.;\n            } \n        } \n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}