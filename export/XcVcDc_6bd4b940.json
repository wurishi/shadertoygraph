{"ver":"0.1","info":{"id":"XcVcDc","date":"1732910954","viewed":152,"name":"Into the Blob Zone","username":"ruudhelderman","description":"Experimenting with frequency modulation to model an infinite 3D alien environment.\nDrag with mouse to look around.","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["3d","sdf","fm","1k"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Into the Blob Zone\" by Ruud Helderman, November 2024 - MIT License\n// https://www.shadertoy.com/view/XcVcDc\n// Experimenting with frequency modulation to model an infinite 3D 'blob' environment.\n\n#define R       iResolution\n#define RR      (R.x + R.y)\n#define ROT(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float avg_dense = 4.0;    // density of blob mass, on average\nconst float var_dense = 1.5;    // density difference between 'rooms' and 'walls'\nconst float room_size = 4.0;    // when multiplied by 2*pi: time to traverse room\nconst float dark = 250.0;       // distance from camera to pitch black\n\nvec3 fm(in vec3 p)             // experimenting with frequency modulation in 3D\n{\n    return sin(p + 2.0 * sin(1.37 * p.yzx + 2.0 * sin(1.63 * p.zxy - 0.2 * iTime)));\n}\n\nfloat sdf(in vec3 p)            // 3D signed distance function (bound, not exact)\n{\n    float b = length(p / vec3(1, 1, 9));   // protective bubble around the camera\n    p.z += iTime;                          // camera moving forward\n    vec3 c = cos(p / room_size);\n    return 3.0 - dot(fm(p), vec3(1))\n        + smoothstep(0.0, 1.0, b) * (var_dense * dot(c*c, c) - avg_dense);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 ray = vec3((2.0 * fragCoord - R.xy) / RR, 1);   // looking forward (Z axis)\n    vec2 m = (iMouse.xy - abs(iMouse.zw)) / RR * 12.0;   // mouse drag, normalized\n    ray.yz *= ROT(m.y);               // first, tilt camera to look up/down\n    ray.xz *= ROT(m.x);               // next, spin camera to look around\n    ray /= dot(abs(ray), vec3(7));    // ray vector with length such that SDF change <= 1\n\n    float shade = 1.0;                // 2 = darkest, 0 = white\n    float depth = 0.0;                // raymarch depth\n    for (int i = 0; i < 500 && depth < dark; i++)        // raymarching loop\n    {\n        vec3 p = ray * depth;         // point on ray\n        float d = sdf(p);             // signed distance\n        depth += d;                   // march as far as possible without risking a negative SDF\n        if (d <= length(p) / RR)      // desired accuracy: roughly half a pixel\n        {\n            vec3 q = vec3(0.01, 0, 0);\n            shade += dot(normalize(ray), normalize(vec3(sdf(p+q), sdf(p+q.zxy), sdf(p+q.yzx)) - d));\n            break;\n        }\n    }\n    fragColor = vec4((1.0 - shade * vec3(0.4, 50, 50)) * max(1.0 - depth/dark, 0.0), 1);\n}\n","name":"Image","description":"","type":"image"}]}