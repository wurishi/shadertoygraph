{"ver":"0.1","info":{"id":"csy3Rm","date":"1678299068","viewed":60,"name":"Periodic line (saw)","username":"Envy24","description":"Source: https://www.youtube.com/watch?v=RKBhiE0HSOU","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["line","periodic","plotter","saw","graphs"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This method works for explicit ( y=f(x) ) and implicit ( d=f(x,y,...) ) functions. */\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 1.75 )\n#define UNIT                      ( 5.0*SCENE_SCALE / R.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx); // arclength change over argument change\n    return SMAA(abs(sdf) / dsdx);\n                           \n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\n// Explicit function definition.\n#define A ( sin(iTime*.5)*15. )\nfloat explicit(float x) { \n    x -= 1.;\n    return atan( (cos(A) - cos(A*x)) / (sin(A*x) - sin(A)) );\n}\nfloat explicit_dydx(float x)\n{\n    /*Numeric derivative.*\n    const float dx = 0.01;\n    return ( explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n    /* Analytic derivative. */\n    return A*.5;\n    /**/\n}\n//vec2 explicit_tangent(float x) { return vec2(1., explicit_dydx(x)); }\n//vec2 explicit_gradient(float x) { return vec2(1., explicit_dydx(x)); }\n//vec2 explicit_normal(float x) { vec2 T = explicit_tangent(x); return vec2(-T.y, T.x); }\n     \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    /* Explicit function y=f(x) */\n         color = mix(color, vec3(0,1,0), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}