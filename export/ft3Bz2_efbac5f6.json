{"ver":"0.1","info":{"id":"ft3Bz2","date":"1663402789","viewed":249,"name":"Normal mapped laminar flow 2tap","username":"Suslik","description":"A test with fields, simple lighting and laminar stretching 2-tap flows\n\nI mostly gathered here most of the stuff that I use frequently: gradient field operations, interpolation nodes, etc etc.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["flow","normalmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 GetFlowVelocity(vec2 pos)\n{\n    float y_size = iResolution.y / iResolution.x;\n    float y_dist = abs(pos.y - y_size * 0.5f) / (0.5f * y_size);\n    \n    return vec2(1.0f - y_dist * y_dist, 0.0f);\n}\n\nUvField GetVelocityField(vec2 pos)\n{\n    float eps = 1e-2f;\n    UvField uv_field;\n    uv_field[0].x = GetFlowVelocity(pos).x;\n    uv_field[0].yz = vec2(GetFlowVelocity(pos + vec2(eps, 0.0f)).x - uv_field[0].x, GetFlowVelocity(pos + vec2(0.0f, eps)).x - uv_field[0].x) / eps;\n\n    uv_field[1].x = GetFlowVelocity(pos).y;\n    uv_field[1].yz = vec2(GetFlowVelocity(pos + vec2(eps, 0.0f)).y - uv_field[1].x, GetFlowVelocity(pos + vec2(0.0f, eps)).y - uv_field[1].x) / eps;\n    return uv_field;\n}\n\nvec3 GetTotalLight(vec3 pos, vec3 surface_norm, vec3 albedo_color)\n{\n    float y_size = iResolution.y / iResolution.x;\n    vec3 res_light = vec3(0.0f);\n    {\n        vec3 delta = pos - vec3(vec2(0.75f, y_size * 0.5f), 0.3f);\n        res_light += GetPointLightFalloff(delta) * GetLight(normalize(delta), surface_norm, albedo_color) * vec3(1.0f, 0.5f, 0.01f);\n    }\n    {\n        vec3 delta = pos - vec3(vec2(0.25f, y_size * 0.5f), 0.3f);\n        res_light += GetPointLightFalloff(delta) * GetLight(normalize(delta), surface_norm, albedo_color) * vec3(0.01f, 0.5f, 1.0f);\n    }\n    return res_light;\n}\n\n#define INTERP_TYPE 2\n\nField GetFlowField(sampler2D tex, UvField uv_field, UvField flow_field, float phase, float phase_offset, float eps, uint type)\n{\n    //phase = 0.0f;\n    float period = 3.0f;\n    InterpNodes2 interp_nodes2 = GetInterpNodes2(phase / period);\n    float moment2 = 0.0f;\n    Field res_field;\n    for(uint node_index = 0u; node_index < 2u; node_index++)\n    {\n        vec3 node_hash = hash33(vec3(interp_nodes2.seeds[node_index], 0.0f, 0.0f));\n        UvField node_uv_field = uv_field - period * flow_field * (2.0f * interp_nodes2.phases[node_index] - 1.0f) - phase_offset * flow_field;\n        UvField hashed_uv_field = RotateMoveUvField(node_uv_field, node_hash.xy, node_hash.z * 2.0f * pi);\n        Field tex_field = SampleTexField(hashed_uv_field, tex, eps);\n        Field weight_field = Field(interp_nodes2.weights[node_index], 0.0f, 0.0f);\n        \n        if(type == 0u)\n        {\n            res_field += tex_field * weight_field.x;\n        }\n        if(type == 1u)\n        {\n            weight_field = FieldRampNorm(weight_field, FieldOneMinus(tex_field * 0.9f));\n            res_field += FieldMul(tex_field, weight_field);\n        }\n        if(type == 2u)\n        {\n            res_field += FieldRampNorm(tex_field, FieldOneMinus(weight_field * 0.5f));\n        }\n        //moment2 += interp_nodes2.weights[node_index] * interp_nodes2.weights[node_index];\n    }\n    return res_field;\n    //return PreserveVariance(res_field, vec3(textureLod(tex, vec2(0.5f, 0.5f), 10.0f).r, 0.0f, 0.0f), moment2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / max(iResolution.x, iResolution.y);\n\n    float stretch = iMouse.z > 0.5f ? (iMouse.y / iResolution.y * 10.0f) : 5.0f;\n    uint type = 0u;\n    if(uv.x > 1.0f / 3.0f) type = 1u;\n    if(uv.x > 2.0f / 3.0f) type = 2u;\n    if(abs(uv.x - 1.0f / 3.0f) < 1e-3f || abs(uv.x - 2.0f / 3.0f) < 1e-3f)\n    {\n        fragColor = vec4(1.0f);\n        return;\n    }\n    Field res_field = GetFlowField(iChannel0, IdentityUvField(uv * 2.0f), GetVelocityField(uv) * 0.1f, iTime, stretch, 1.0f / 512.0f, type);\n    \n    vec3 res_pos = vec3(uv, 0.0f);\n    vec3 res_norm = GradToNorm(res_field.yz * 0.1f);\n\n    //vec3 res_light = vec3(res_norm.xy, 0.0f);\n    vec3 res_light = GetTotalLight(res_pos, res_norm, vec3(0.1f));\n\n    vec3 srgb_color = pow(res_light, vec3(1.0f / 2.2f));\n    fragColor = vec4(srgb_color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define Field vec3\n#define UvField mat2x3\n\nField SampleTexFieldVec2(vec2 uv, sampler2D tex, float eps)\n{\n    Field res;\n    res.x = texture(tex, uv).r;\n    //in actual use this is supposed to be precalculted\n    float center = textureLod(tex, uv, 0.0f).r;\n    res.y = (textureLod(tex, uv + vec2(eps, 0.0f), 0.0f).r - center) / eps;\n    res.z = (textureLod(tex, uv + vec2(0.0f, eps), 0.0f).r - center) / eps;\n    return res;\n}\n\nField SampleTexField(UvField uv_field, sampler2D tex, float eps)\n{\n    Field local_field = SampleTexFieldVec2(vec2(uv_field[0].x, uv_field[1].x), tex, eps);\n    return Field(local_field.x, uv_field[0].yz * local_field.y + uv_field[1].yz * local_field.z);\n    /*vec2 uv = vec2(uv_field[0].x, uv_field[1].x);\n    float center_sample = texture(tex, uv).r;\n    float x_sample = texture(tex, uv + uv_field[0].yz * eps).r;\n    float y_sample = texture(tex, uv + uv_field[1].yz * eps).r;\n    \n    return Field(center_sample, (x_sample - center_sample) / eps, (y_sample - center_sample) / eps);*/\n}\n\nField FieldMul(Field field0, Field field1)\n{\n    return Field(field0.x * field1.x, field0.x * field1.yz + field1.x * field0.yz);\n}\nField FieldLinStep(Field value, Field center, Field steepness)\n{\n    return FieldMul(value, (steepness + Field(1.0f, 0.0f, 0.0f))) - FieldMul(center, steepness);\n}\nField FieldMax(Field field0, Field field1)\n{\n    return field0.x > field1.x ? field0 : field1;\n}\nField FieldMin(Field field0, Field field1)\n{\n    return field0.x < field1.x ? field0 : field1;\n}\t\nField FieldInverse(Field value)\n{\n    float inv = 1.0f / value.x;\n    return Field(inv, -inv * inv * value.yz);\n}\nField FieldInverseSafe(Field value)\n{\n    float inv = abs(value.x) > 1e-5f ? 1.0f / value.x : 1e5f;\n    return Field(inv, -inv * inv * value.yz);\n}\n\nField FieldOneMinus(Field value)\n{\n    return Field(1.0f - value.x, -value.yz);\n}\nField FieldSqr(Field value)\n{\n    return Field(value.x * value.x, 2.0f * value.x * value.yz);\n}\n\nField FieldRampNormHalf(Field value, Field center)\n{\n    //https://www.desmos.com/calculator/tpa2t76anf\n    return FieldMul(value, FieldInverseSafe(FieldMul(FieldSqr(2.0f * center), FieldOneMinus(value)) + value));\n}\n\nField FieldRampNorm(Field value, Field center)\n{\n    float eps = 1e-3f;\n    center.x = clamp(center.x, eps, 1.0f - eps);\n    bool mirror = center.x < 0.5f;\n    Field mirrored_value = mirror ? value : FieldOneMinus(value);\n    Field mirrored_center = mirror ? center : FieldOneMinus(center);\n    Field ramp = FieldRampNormHalf(mirrored_value, mirrored_center);\n    return mirror ? ramp : FieldOneMinus(ramp);\n}\n\nField FieldPowerConst(Field value, float p)\n{\n    float eps = 1e-3f;\n    if(value.x < eps) return value;\n\n    Field res;\n    res.x = pow(value.x, p);\n    res.yz = res.x * p / value.x * value.yz;\n    return res;\n}\n\nField FieldGainConst(Field value, float steepness)\n{\n    float eps = 1e-3f;\n    steepness = clamp(steepness, -1.0f + eps, 1.0f - eps);\n    float power = (1.0f + steepness) / (1.0f - steepness);\n    Field p = 0.5f * FieldPowerConst(2.0f * ((value.x < 0.5f) ? value : FieldOneMinus(value)), power);\n    return (value.x < 0.5f) ? p : FieldOneMinus(p);\n}\n\nField FieldDissolve(Field value, Field alpha)\n{\n    float eps = 1e-2f;\n    Field steepness = alpha.x > eps ? FieldInverse(alpha) : Field(1.0f / eps, 0.0f, 0.0f);\n\n    Field res = FieldMul(FieldMin(Field(0.0f, 0.0f, 0.0f), value - Field(1.0f, 0.0f, 0.0f)), steepness) + Field(1.0f, 0.0f, 0.0f);\n    res -= FieldMax(Field(0.0f, 0.0f, 0.0f), Field(eps, 0.0f, 0.0f) - alpha) / eps * 2.0f;\n    res = res.x < 0.0f ? Field(-1e-5f, 0.0f, 0.0f) : res;\n    return res;\n}\n\n\nUvField IdentityUvField(vec2 uv)\n{\n    UvField res_field;\n    res_field[0] = vec3(uv.x, 1.0f, 0.0f);\n    res_field[1] = vec3(uv.y, 0.0f, 1.0f);\n    return res_field;\n}\nUvField ApplyTransform(UvField src_uv_field, mat2x2 src_to_dst)\n{\n    //Eq0: this is how uv's are transformed for stuff like rotation\n    //dst.u(x,y) = src_to_dst * src.u(x,y)\n    //dst.v(x,y)                src.v(x,y)\n    \n    //Eq1: is done by multiplying left and right side of Eq0 by d/dx:\n    //d/dx*dst.u(x,y) = src_to_dst * d/dx * src.u(x,y)\n    //d/dx*dst.v(x,y)                d/dy * src.v(x,y)\n    \n    //Eq2: is done by multiplying left and right side of Eq0 by d/dy:\n    //d/dy*dst.u(x,y) = src_to_dst * d/dy * src.u(x,y)\n    //d/dy*dst.v(x,y)                d/dy * src.v(x,y)\n    \n    //Eq0, Eq1 and Eq2 can all be written as columns of a matrix with 2 rows and 3 columns:\n    //dst.u(x,y) d/dx*dst.u(x,y) d/dy*dst.u(x,y) = T(R) * src.u(x,y) d/dx*src.u(x,y) d/dy*src.u(x,y)\n    //dst.v(x,y) d/dx*dst.v(x,y) d/dy*dst.v(x,y)          src.v(x,y) d/dy*src.v(x,y) d/dy*src.v(x,y)\n    \n    //dst_uv_mat[2x3] = src_to_dst[2x2] * src_uv_mat[2x3]\n\n    //glsl's mat3x2 has actual size of [2x3] from math's perspective. praise opengl.\n    \n    //mat3x2 src_uv_mat = mat3x2(vec2(src_uv_field[0].x, src_uv_field[1].x), vec2(src_uv_field[0].y, src_uv_field[1].y), vec2(src_uv_field[0].z, src_uv_field[1].z));\n    \n    //each row of a uv_field is transformed as a vector. so we make it a column (transpose), transform and then transpose the result\n    mat3x2 src_uv_mat = transpose(src_uv_field);\n    \n    //each single column of src_uv_mat is transformed as a vec2 with src_to_dst matrix to obtain a single column of dst_uv_mat, that is a vec2 as well\n    mat3x2 dst_uv_mat = src_to_dst * src_uv_mat;\n    \n    UvField res_uv_field;\n    //res_uv_field[0] = Field(uv_mat[0].x, uv_mat[1].x, uv_mat[2].x);\n    //res_uv_field[1] = Field(uv_mat[0].y, uv_mat[1].y, uv_mat[2].y);\n    res_uv_field = transpose(dst_uv_mat);\n    \n    return res_uv_field;\n}\n\nUvField RotateMoveUvField(UvField src_uv_field, vec2 offset, float ang)\n{\n    mat2 dst_to_src = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    mat2 src_to_dst = transpose(dst_to_src);\n    UvField dst_uv_field = ApplyTransform(src_uv_field, src_to_dst);\n    dst_uv_field[0].x += offset.x;\n    dst_uv_field[1].x += offset.y;\n    return dst_uv_field;\n}\n\nvec3 GradToNorm(vec2 grad)\n{\n    return normalize(vec3(-grad, 1.0f));\n}\n\nvec2 NormToGrad(vec3 norm)\n{\n    return -norm.xy / norm.z;\n}\n\nfloat GetDiffuse(vec3 light_dir, vec3 surface_norm)\n{\n    return max(dot(-light_dir, surface_norm), 0.0f);\n}\n\nfloat GetPointLightFalloff(vec3 delta)\n{\n    return 1.0f / (dot(delta, delta) + 1e-5f);\n}\n\nvec3 GetLight(vec3 light_dir, vec3 surface_norm, vec3 albedo_color)\n{\n    return GetDiffuse(light_dir, surface_norm) * albedo_color;\n}\n\nfloat sqr(float val) {return val * val;}\n\nstruct InterpNodes2\n{\n    vec2 seeds;\n    vec2 phases;\n    vec2 weights;\n};\nInterpNodes2 GetInterpNodes2(float phase)\n{\n    vec2 global_phases = vec2(phase * 0.5) + vec2(0.5, 0.0);\n    vec2 phases = fract(global_phases);\n    vec2 seeds = floor(global_phases) * 2.0 + vec2(0.0, 1.0);\n    vec2 weights = min(phases, vec2(1.0f) - phases) * 2.0;\n    return InterpNodes2(seeds, phases, weights);\n}\n\n//from Qizhi Yu, et al [2011]. Lagrangian Texture Advection: Preserving Both Spectrum and Velocity Field. \n//IEEE Transactions on Visualization and Computer Graphics 17, 11 (2011), 1612–1623\nvec3 PreserveVariance(vec3 linearColor, vec3 meanColor, float moment2)\n{\n    return (linearColor - meanColor) / sqrt(moment2) + meanColor;\n}\n\n\nvec3 hash33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nconst float pi = 3.141592f;","name":"Common","description":"","type":"common"}]}