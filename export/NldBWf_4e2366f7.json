{"ver":"0.1","info":{"id":"NldBWf","date":"1663933979","viewed":107,"name":"Cube rot + poly + zBuf","username":"Hatokuro","description":"étape final\nAffichage d'un cube avec polygone colorée et zBuffer\nce petit projet m'aura permit de comprendre pas mal de chose et ainsi progresser.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["cuberotationzbuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define ANTIALIASING\n#define LINE\n\n#define DISTCAMERA 10.\n#define SIZE 1.\n\n\n//permet de fixer un point sur la surface d'un triangle (utile pour le zBuffer)\nvec3 zFix(vec3 point, vec3 A, vec3 B,vec3 C)\n{\n   vec3 AA = vec3(A.xy,0.);\n   vec3 BB = vec3(B.xy,0.);\n   vec3 CC = vec3(C.xy,0.);\n   \n   vec3 v0 = CC - AA;\n   vec3 v1 = BB - AA;\n   vec3 v2 = point - AA;\n   \n   float dot00 = dot(v0,v0);\n   float dot01 = dot(v0,v1);\n   float dot02 = dot(v0,v2);\n   float dot11 = dot(v1,v1);\n   float dot12 = dot(v1,v2);\n   \n   float inv = 1. / (dot00 * dot11 - dot01 * dot01);\n   float u = (dot11 * dot02 - dot01 * dot12)*inv;\n   float v = (dot00 * dot12 - dot01 * dot02)*inv;\n   \n   return A+u*(C-A)+v*(B-A);\n    \n}\n\nfloat dist(vec3 A, vec3 B) \n{\n    vec3 pos = A-B;\n    return sqrt(pos.x*pos.x+pos.y*pos.y+pos.z*pos.z);\n}\n\n//======================== POLYGONE ========================\nbool sameside(vec2 uv, vec3 A, vec3 B, vec3 C) //permet d'indiquer de quel coté d'une ligne on se trouve (0 ou 1)\n{\n    vec3 u = vec3(uv.x,uv.y,0.0);\n    vec3 valuexy = cross(B-A,C-A);\n    vec3 valuexz = cross(B-A,u-A);\n    \n    if(dot(valuexy,valuexz)>=0.){return true;}\n    else{return false;}   \n}\n\nbool inTriangle(vec2 uv,vec3 v[3]) // permet d'indiquer si on se trouve bien a l'intérieur d'un triangle (3 ligne)\n{\n    if(sameside(uv,v[0],v[1],v[2]) && sameside(uv,v[1],v[2],v[0]) && sameside(uv,v[2],v[0],v[1])){return true;}\n    else{return false;}\n   \n}\n//======================== LINE ========================\nfloat segment(vec2 u, vec2 a, vec2 b)  {         \n    b -= a, u -= a;\n    return length( u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nfloat line(vec2 uv, vec2 A,vec2 B, float width)\n{\n    float mysegment = segment(uv,A,B);\n    return mysegment = smoothstep(width,0.,mysegment);\n}\n\n//======================== MATRIX ========================\nmat3 rotateX(float angle){\n    float cosPhi = cos(angle);\n    float sinPhi = sin(angle);\n    return mat3(1.,0.,0.,\n    0.,cosPhi,-sinPhi,\n    0.,sinPhi,cosPhi);\n}\n\nmat3 rotateY(float angle){\n    float cosPhi = cos(angle);\n    float sinPhi = sin(angle);\n    return mat3(cosPhi,0.,sinPhi,\n    0.,1.,0.,\n    -sinPhi,0.,cosPhi);\n}\n\nmat3 rotateZ(float angle){\n    float cosPhi = cos(angle);\n    float sinPhi = sin(angle);\n    return mat3(cosPhi,-sinPhi,0.,\n    sinPhi,cosPhi,0.,\n    0.,0.,1.);\n}\n\nmat3 scaleXYZ(vec3 scale){\n    return mat3(scale.x,0.,0.,\n    0.,scale.y,0.,\n    0.,0.,scale.z);\n}\n//======================== COORD CUBE ========================\nconst vec3 vertices[8] = vec3[](\n    vec3(-1.,-1.,1.),\n    vec3(1.,-1.,1.),\n    vec3(-1.,1.,1.),\n    vec3(1.,1.,1.),\n    vec3(-1.,-1.,-1.),\n    vec3(1.,-1.,-1.),\n    vec3(-1.,1.,-1.),\n    vec3(1.,1.,-1.)\n);\n\nconst int orderA[12] = int[](0,2,0,3,4,6,4,7,0,1,2,3);\nconst int orderB[12] = int[](1,3,2,1,5,7,6,5,4,5,6,7);\n\nconst int triOrderA[12] = int[](0,1,4,5,0,1,2,3,0,2,1,3);\nconst int triOrderB[12] = int[](1,2,5,6,1,4,3,6,2,4,3,5);\nconst int triOrderC[12] = int[](2,3,6,7,4,5,6,7,4,6,5,7);\n\nconst vec3 triCol[12] = vec3[](\n    vec3(1.,0.,0.),\n    vec3(1.,0.,0.),\n    vec3(0.,1.,0.),\n    vec3(0.,1.,0.),\n    vec3(0.,0.,1.),\n    vec3(0.,0.,1.),\n    vec3(1.,1.,0.),\n    vec3(1.,1.,0.),\n    vec3(1.,0.,1.),\n    vec3(1.,0.,1.),\n    vec3(0.,1.,1.),\n    vec3(0.,1.,1.)\n);\n\nfloat zBuffer = 300000.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalisation des pixel (from 0 to 1)\n    vec2 uv = (2.* fragCoord - iResolution.xy)/iResolution.y;\n    float px_size = 2. / iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 verticesCube[8];\n    for(int i=0;i<8;i++)\n    {\n\n        verticesCube[i] =  vertices[i] * rotateX(iTime) * rotateY(iTime) *rotateZ(iTime);\n        verticesCube[i] = verticesCube[i] *  scaleXYZ(vec3(SIZE,SIZE,SIZE)); \n        verticesCube[i].z += DISTCAMERA;\n        \n        //perspective pour la profondeur\n        float ooz = 1. / verticesCube[i].z;\n\n        verticesCube[i].x = ooz* verticesCube[i].x*2.;\n        verticesCube[i].y =  ooz * verticesCube[i].y*2.;\n        \n    }\n    \n    \n    for(int i=0;i<12;i++)\n    {\n        vec3 coordTri[3];\n        coordTri[0]= vec3(verticesCube[triOrderA[i]].xy,0.);\n        coordTri[1]= vec3(verticesCube[triOrderB[i]].xy,0.);\n        coordTri[2]= vec3(verticesCube[triOrderC[i]].xy,0.);\n        \n        //ZBUFFER\n        vec3 moypos = zFix(vec3(uv,0.),verticesCube[triOrderA[i]],verticesCube[triOrderB[i]],verticesCube[triOrderC[i]]);\n        float dist = dist(vec3(0.,0.,0.),moypos);\n        if(inTriangle(uv,coordTri)){\n           if(dist <= zBuffer){\n               zBuffer = dist;\n               col = triCol[i];\n           }\n        }\n    }\n    for(int i=0;i<12;i++)\n    {\n        #ifdef LINE\n            col += line(uv,verticesCube[orderA[i]].xy,verticesCube[orderB[i]].xy,px_size);//trassage de lignes\n        #endif\n    }\n\n    // Output to screen\n    #ifdef ANTIALIASING\n        fragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n    #else\n        fragColor = vec4(col,1.0);\n    #endif\n    \n }","name":"Image","description":"","type":"image"}]}