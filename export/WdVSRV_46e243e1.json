{"ver":"0.1","info":{"id":"WdVSRV","date":"1574937753","viewed":185,"name":"another_hexagon_movement","username":"skaplun","description":"Linear vs accelerating interpolation. \nOriginal animation - https://i.pinimg.com/originals/ff/91/4f/ff914fbaf7a50a6c11b52cc6f902e2bf.gif","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["animation","hexagon","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ANGLES 6.\n#define HEX_SIZE .7\n#define AA (2./iResolution.y)\n#define EDGE_LENGTH .8\n#define DOT_RAD .015\n#define DOTS_COUNT 7.\n#define DOT_STEP (EDGE_LENGTH/DOTS_COUNT)\n#define HALF_DOT_STEP (DOT_STEP * .5)\n#define r(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define THICKNESS .0005\n\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\nconst float angDiff = PI/3.;\n\nconst vec3 CLR_BG = vec3(23., 19., 16.)/255.;\nconst vec3 CLR_TRAJ = vec3(36., 32., 29.)/255.;\n\nfloat hexDistance(in vec2 p){\n\tp = abs(p);\n    float h = dot(p, normalize(vec2(1., 1.73)));\n    return max(h, p.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  // Íñigo Quílez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvec4 pattern(vec2 uv, float variant){\n\tfloat hex = hexDistance(uv);\n    float traj = smoothstep(THICKNESS + AA, THICKNESS, abs(hex - HEX_SIZE));\n    for(float i=0.; i<6.; i++){\n    \tvec2 cntr = vec2(-EDGE_LENGTH, 0.) * r(i*angDiff + angDiff/2.);\t\n        float dst = distance(uv, cntr);\n        traj = max(traj, step(dst, EDGE_LENGTH + THICKNESS + AA)\n                       * step(hex, HEX_SIZE)\n                       * smoothstep(HALF_DOT_STEP - THICKNESS - AA, HALF_DOT_STEP - THICKNESS,\n                                    distance(HALF_DOT_STEP, mod(dst, DOT_STEP))));\n    }\n    vec4 bg = vec4(CLR_TRAJ, traj);\n\t\n    float animationPhase = iTime;\n    float sgmnt = mod(floor(animationPhase), 6.);\n    float curAng = sgmnt * PI/3. + angDiff/2.;\n    vec2 sp = vec2(-EDGE_LENGTH, 0.) * r(-curAng);\n    float rotPhase = pow(fract(animationPhase), variant);\n    vec2 dir = vec2(-1., 0.)\n             * r(-(sgmnt - 1.) * PI/3. + angDiff/2.)\n             * r(rotPhase * PI*2./3.);\n    float index = floor((distance(sp, uv) + HALF_DOT_STEP)/DOT_STEP) * DOT_STEP;\n    float point = step(distance(sp, uv), EDGE_LENGTH + DOT_RAD * 2.)\n        \t   * smoothstep(DOT_RAD + AA, DOT_RAD, distance(sp + dir * index, uv));\n    {\n        vec2 modDir = dir * r(curAng);\n    \tvec2 st = normalize(uv - sp) * r(curAng);\n        float pointAng = atan(modDir.y, modDir.x)/TAU+.5;\n        float posAng = atan(st.y, st.x)/TAU+.5;\n        float dst = step(posAng, pointAng)\n                  * smoothstep((pow(fract(animationPhase), 4.) + .1) * smoothstep(.45, 0., abs(fract(animationPhase) - .5)), 0., abs(pointAng - posAng));\n        bg = mix(bg, vec4(hsv2rgb(vec3(index + fract(animationPhase) * .5 + dst * .1 + 0.65, 1., 1.)), 1.), dst * step(hex, HEX_SIZE) * step(distance(sp, uv), EDGE_LENGTH + DOT_RAD * 2.) * smoothstep(DOT_RAD * dst * .5 + AA, DOT_RAD * dst * .5, distance(index, distance(sp, uv))));\n    }\n    \n    return mix(bg, vec4(1.), point);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n\tvec4 ptrn = pattern(uv - vec2(.9, 0.), 1.);\n    fragColor = vec4(mix(CLR_BG, ptrn.rgb, ptrn.a), 1.);\n    ptrn = pattern(uv + vec2(.9, 0.), 4.);\n    fragColor.rgb = mix(fragColor.rgb, ptrn.rgb, ptrn.a);\n}","name":"Image","description":"","type":"image"}]}