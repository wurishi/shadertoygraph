{"ver":"0.1","info":{"id":"4XSGWV","date":"1708875015","viewed":59,"name":"Triangular Interpolation","username":"rcmz","description":"Demonstration of triangular barycentric interpolation for texture sampling\n\nTop left : Triangular          Top right : Software bilinear (should be the same as hardware bilinear)\nBottom left : Nearest        Bottom right : Hardware bilinear","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["texture","barycentric","interpolation","triangular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void nearest(out vec4 color, vec2 uv) {\n    vec2 o;\n    ivec2 r = ivec2(uv * vec2(textureSize(iChannel0, 0))) % 2;\n    switch ((iFrame * 2 + (r.x + r.y * 2)) % 4) {\n        case 0: o = vec2(0, 0); break;\n        case 1: o = vec2(0, 1); break;\n        case 2: o = vec2(1, 1); break;\n        case 3: o = vec2(1, 0); break;\n    }\n    //uv += o * 0.5 / vec2(textureSize(iChannel0, 0));\n    color = texture(iChannel0, uv);\n}\n\nvoid hardwareBilinear(out vec4 color, vec2 uv) {\n    color = texture(iChannel1, uv);\n}\n\nvoid softwareBilinear(out vec4 color, vec2 uv) {\n    color = vec4(0);\n    for (int i = 0; i < 4; i++) {\n        vec2 s = uv * vec2(textureSize(iChannel0, 0));\n        ivec2 o = ivec2((i >> 0) & 1, (i >> 1) & 1);\n        ivec2 p = ivec2(s) + o;\n        vec2 d = max(1.0 - abs(s - vec2(p)), 0.0);\n        float c = d.x * d.y;\n        color += c * texelFetch(iChannel0, p, 0);\n    }\n}\n\nfloat area(vec2 v0, vec2 v1, vec2 v2) {\n    return abs((v0.x - v1.x) * (v2.y - v1.y) - (v0.y - v1.y) * (v2.x - v1.x));\n}\n\nvoid triangular(out vec4 color, vec2 uv) {\n    vec2 s = uv * vec2(textureSize(iChannel0, 0));\n    vec2 m = s - floor(s);\n    //bool b = bool((int(s.x) % 2) ^ (int(s.y) % 2));\n    //bool b = bool(iFrame % 2);\n    bool b = true;\n    \n    vec2 t[3];\n    if (b) {\n        t[0] = vec2(0, 0);\n        t[1] = vec2(1, 1);\n        t[2] = m.y < m.x ? vec2(1, 0) : vec2(0, 1);\n    } else {\n        t[0] = vec2(0, 1);\n        t[1] = vec2(1, 0);\n        t[2] = (1.0 - m.y) < m.x ? vec2(1, 1) : vec2(0, 0);\n    }\n\n    \n    color = vec4(0);\n    for (int i = 0; i < 3; i++) {\n        ivec2 p = ivec2(s) + ivec2(t[i]);\n        float c = area(m, t[(i + 1) % 3], t[(i + 2) % 3]);\n        color += c * texelFetch(iChannel0, p, 0);\n    }\n}\n\nvec2 transform(vec2 uv) {\n    //uv *= vec2(1, iResolution.y / iResolution.x);\n    return uv / 10.0 + vec2(0, 0.42);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (fragCoord + 0.5) / iResolution.xy;\n    if (uv.x < 0.5) {\n        if (uv.y < 0.5) {\n            nearest(fragColor, transform(uv * 2.0 - vec2(0, 0)));\n        } else {\n            triangular(fragColor, transform(uv * 2.0 - vec2(0, 1)));\n        }\n    } else {\n        if (uv.y < 0.5) {\n            hardwareBilinear(fragColor, transform(uv * 2.0 - vec2(1, 0)));\n        } else {\n            softwareBilinear(fragColor, transform(uv * 2.0 - vec2(1, 1)));\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}