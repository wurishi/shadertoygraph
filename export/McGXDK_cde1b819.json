{"ver":"0.1","info":{"id":"McGXDK","date":"1715772072","viewed":59,"name":"Cosmic Harmony: Audio and Visual","username":"Weichwolf","description":"ChatGPT: \"I created two shaders that offer a mesmerizing blend of audio and visual synthesis.\"","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["chatgpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWO_PI 6.28318530718\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * 0.1;\n    \n    // Background gradient\n    vec3 bgColor = mix(vec3(0.2, 0.0, 0.4), vec3(0.0, 0.0, 0.2), uv.y + 0.5);\n    \n    // Abstract shapes\n    float shape1 = sin(TWO_PI * (uv.x + time)) * cos(TWO_PI * (uv.y + time));\n    float shape2 = cos(TWO_PI * (uv.x * 0.5 + time)) * sin(TWO_PI * (uv.y * 0.5 + time));\n    \n    // Combining shapes\n    float shapes = shape1 + shape2;\n    \n    // Color modulation based on shapes and time\n    vec3 shapeColor = vec3(0.5 + 0.5 * sin(TWO_PI * shapes + time), 0.5 + 0.5 * cos(TWO_PI * shapes + time), 1.0 - shapes * 0.5);\n    \n    // Final color\n    fragColor = vec4(bgColor * shapeColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TWO_PI 6.28318530718\n\nfloat melody(float time) {\n    // A simple melody sequence\n    int notes[8] = int[8](440, 494, 523, 587, 659, 698, 784, 880); // A, B, C, D, E, F, G, A (in Hz)\n    float duration = 0.5; // Each note duration\n    int index = int(mod(time / duration, 8.0));\n    return float(notes[index]);\n}\n\nfloat padMelody(float time) {\n    // Background pad sequence\n    int padNotes[4] = int[4](220, 247, 262, 294); // Lower octaves\n    float duration = 1.5; // Longer note duration\n    int index = int(mod(time / duration, 4.0));\n    return float(padNotes[index]);\n}\n\nfloat lowPassFilter(float samplein, float cutoff, inout float state) {\n    float rc = 1.0 / (cutoff * TWO_PI);\n    float dt = 1.0 / 44100.0; // Assuming sample rate of 44100 Hz\n    float alpha = dt / (rc + dt);\n    state += (samplein - state) * alpha;\n    return state;\n}\n\nfloat fmSynth(float carrierFreq, float modulatorFreq, float modIndex, float time) {\n    return sin(TWO_PI * carrierFreq * time + modIndex * sin(TWO_PI * modulatorFreq * time));\n}\n\nvec2 mainSound(int samp, float time) {\n    float leadFreq = melody(time);\n    float padFreq = padMelody(time);\n    \n    // FM synthesis for the lead synth\n    float modFreq = 110.0; // Modulator frequency\n    float modIndex = 5.0;  // Modulation index\n    float lead = fmSynth(leadFreq, modFreq, modIndex, time) * 0.5;\n    \n    // Background pad (mellow spacey sound)\n    float pad = 0.3 * sin(TWO_PI * padFreq * time);\n    pad += 0.3 * sin(TWO_PI * (padFreq * 1.5) * time + sin(time) * 0.1);\n    \n    // Combine lead and pad\n    float combined = lead + pad;\n    \n    // Apply low-pass filter\n    float filterState = 0.0;\n    float filtered = lowPassFilter(combined, 440.0, filterState); // Cutoff frequency at 440 Hz\n    \n    return vec2(filtered);\n}\n","name":"Sound","description":"","type":"sound"}]}