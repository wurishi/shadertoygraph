{"ver":"0.1","info":{"id":"DsBBzw","date":"1689539654","viewed":141,"name":"Winding Number Diagram","username":"chronos","description":"Simple diagram showing the interpretation of winding numbers for line segments","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["number","field","diagram","winding","explainer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float percent = .01;\nconst float line_width = 1. * percent;\nconst float point_size = 2. * percent;\n\nfloat char(vec2 uv, vec2 position, float size, int ascii_code)\n{\n    uv = (uv-position) / (size*percent);\n    ivec2 ij = ivec2(uv * 64.) + ascii_to_offset(ascii_code);\n    float mask = step(0., min(min(uv.x, 1.-uv.x), min(uv.y, 1.-uv.y)));\n    return texelFetch(iChannel0, ij, 0).r * mask;\n}\n\nfloat char_shadow(vec2 uv, vec2 position, float size, int ascii_code, float shadow_offset, float shadow_blur)\n{\n    uv = (uv-(position+vec2(shadow_offset,-shadow_offset))) / (size*percent);\n    ivec2 ij = ivec2(uv * 64.) + ascii_to_offset(ascii_code);\n    float mask = step(0., min(min(uv.x, 1.-uv.x), min(uv.y, 1.-uv.y)));\n    float d = texelFetch(iChannel0, ij, 0).a;\n    float f = smoothstep(0.5+shadow_blur,0.5-shadow_blur, d); \n    return f * mask;\n}\n\nfloat disc(vec2 uv, vec2 center, float radius)\n{\n    float d = distance(uv,center);\n    return smoothstep(radius + fwidth(d), radius, d);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius)\n{\n    float d = abs(distance(uv,center)-radius);\n    float r =  line_width*.5;\n    return smoothstep(r+fwidth(d), r, d);\n}\n\nfloat circle_segment(vec2 uv, vec2 center, float radius, vec2 a, vec2 b)\n{\n    vec2 inside = inverse(mat2(a-center, b-center)) * (uv-center);\n    float inside1 = smoothstep(-fwidth(inside.x), 0., inside.x);\n    float inside2 = smoothstep(-fwidth(inside.y), 0., inside.y);\n    return inside1 * inside2 * circle(uv, center, radius);\n}\n\nfloat point(vec2 uv, vec2 center)\n{\n    return disc(uv, center, point_size);\n}\n\nvec2 project_onto_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    return clamp(dot(ap, ab) / dot(ab,ab), 0., 1.) * ab + a;\n}\n\nfloat segment(vec2 uv, vec2 a, vec2 b)\n{\n    vec2 projected_point = project_onto_segment(uv, a, b);\n    float d = distance(uv, projected_point);\n    float r = line_width * .5;\n    return smoothstep(r+fwidth(d), r, d);\n}\n\nfloat arrow(vec2 uv, vec2 a, vec2 b)\n{\n    float seg = segment(uv, a, b);\n    \n    vec2 BA = a-b;\n    float l = length(BA);\n    float c = (BA.x + BA.y) / l;\n    float s = (BA.x - BA.y) / l;\n    \n    mat2 rot = mat2(c,s,-s,c);\n    \n    vec2 p = .5 * (rot * (uv-b)) / (sqrt(2.) * point_size);\n    p+=0.5;\n    float d = min(min(p.x, p.y), 1.-p.x-p.y); // note: not the distance!\n    float tri = smoothstep(-fwidth(d), 0.,d);\n    return max(tri, seg);\n}\n\nfloat box(vec2 uv, vec2 vmin, vec2 vmax)\n{\n    uv = (uv-vmin)/(vmax-vmin);\n    float d = min(min(uv.x, 1.-uv.x), min(uv.y, 1.-uv.y));\n    float f = step(0., d);\n    return f;\n}\n\n/*\nfloat winding_number_dipole(vec2 O, vec2 X, vec2 N, float arclen)\n{\n    X -= O;\n    float R = length(X);\n    float outer_perimeter = 2. * PI * R;\n    return dot((X / R), normalize(N)) * arclen / outer_perimeter;\n}\n*/\n\nfloat winding_number_segment(vec2 O, vec2 A, vec2 B)\n{\n    vec2 a = normalize(A-O);\n    vec2 b = normalize(B-O);\n    float d = dot(a,b);\n    float angle = acos(d);\n    angle = min(angle, 2.*PI - angle);\n    return sign(determinant(mat2(a,b))) * angle / (2. * PI);\n}\n\nvec3 draw_diagram(vec2 uv)\n{\n    vec3 bg_color = vec3(0.2, 0.30, 0.5);\n\n    vec3 color = bg_color;\n    \n    vec2 A = vec2(1.5, 0.45);\n    vec2 B = vec2(1.1, .8);\n    \n    vec2 mid = (A+B)*.5;\n    \n    vec2 mouse = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    vec2 X = mid;\n    if(length(iMouse.xy) > 10.)\n        X = mouse;\n    \n    float t = iTime;\n    B = mat2(cos(t), -sin(t), sin(t), cos(t)) * (B-mid) + X;\n    A = mat2(cos(t), -sin(t), sin(t), cos(t)) * (A-mid) + X;\n    \n    vec2 AB = B - A;\n    vec2 N = (20. * percent) * normalize(AB).yx * vec2(1,-1);\n    \n    vec2 O = vec2(0);\n    \n    float radius = 75.*percent;\n    \n    float PointO = point(uv, O);\n    float PointA = point(uv, A);\n    float PointB = point(uv, B);\n    float PointX = point(uv, X);\n    \n    float PointA2 = point(uv, O+radius*normalize(A-O));\n    float PointB2 = point(uv, O+radius*normalize(B-O));\n    \n    float Circle = circle(uv, O, radius);\n    float SegmentAB = segment(uv, A, B);\n    float SegmentOA = segment(uv, O, A);\n    float SegmentOB = segment(uv, O, B);\n    float SegmentOmid = segment(uv, O, X);\n    \n    float ArrowN = arrow(uv, X, X+N);\n    \n    float charA = char(uv, A, 10., ascii_A);\n    float charB = char(uv, B, 10., ascii_B);\n    float charN = char(uv, X+N, 10., ascii_N);\n    float charX = char(uv, X, 10., ascii_X);\n    \n    const float shadow_alpha = 40.*percent;\n    float charA_shadow = shadow_alpha*char_shadow(uv, A, 10., ascii_A, .3*percent, 5.*percent);\n    float charB_shadow = shadow_alpha*char_shadow(uv, B, 10., ascii_B, .3*percent, 5.*percent);\n    float charN_shadow = shadow_alpha*char_shadow(uv, X+N, 10., ascii_N, .3*percent, 5.*percent);\n    float charX_shadow = shadow_alpha*char_shadow(uv, X, 10., ascii_X, .3*percent, 5.*percent);\n    \n    \n    float CircleSegmentAB = circle_segment(uv, O, radius, A, B);\n    \n    vec3 CircleSegmentColor = mix(vec3(1,0,0),vec3(0,1,0), step(0.,determinant(mat2(A-O,B-O))));\n    \n    // Draw bar showing magnitude of winding number\n    {\n        vec2 vmin = vec2(-1.3,-.8);\n        vec2 vmax = vec2(-1.,.8);\n        float Box = box(uv, vmin, vmax);\n        color = mix(color, vec3(1), Box);\n\n        float Winding = winding_number_segment(O, A, B);\n        vec3 CircleSegmentColorWinding = mix(vec3(1,0,0),vec3(0,1,0), step(0.,Winding));\n        vmin = vec2(-1.275,-.775);\n        vmax = vec2(-1.025,.775);\n        Box = box(uv, vmin, vmax);\n        color = mix(color, bg_color, Box);\n\n        \n        vec2 bar_vmax = vec2(vmax.x, mix(vmin.y, vmax.y, abs(Winding)));\n        float Bar = box(uv, vmin, bar_vmax);\n        color = mix(color, CircleSegmentColorWinding, Bar);\n        \n        float text_size = 15.;\n        vec2 char0pos = vec2(vmax.x, vmin.y-text_size/2. * percent );\n        float char0 = char(uv, char0pos, text_size, ascii_0);\n        float char0_shadow = shadow_alpha*char_shadow(uv, char0pos, text_size, ascii_0, .3*percent, 5.*percent);\n        color = mix(color, vec3(0), char0_shadow);\n        color = mix(color, vec3(1), char0);\n        \n        vec2 char1pos = vmax + vec2(0,-text_size/3. * percent);\n        float char1 = char(uv, char1pos, text_size, ascii_1);\n        float char1_shadow = shadow_alpha*char_shadow(uv, char1pos, text_size, ascii_1, .3*percent, 5.*percent);\n        color = mix(color, vec3(0), char1_shadow);\n        color = mix(color, vec3(1), char1);\n        \n    }\n    \n    \n    \n    color = mix(color, vec3(1), PointO);\n    color = mix(color, vec3(1), PointA);\n    color = mix(color, vec3(1), PointB);\n    color = mix(color, vec3(1), .75*PointA2);\n    color = mix(color, vec3(1), .75*PointB2);\n    \n    color = mix(color, vec3(1), PointX);\n    color = mix(color, vec3(1), .75*Circle);\n    \n    color = mix(color, vec3(1), .7*SegmentAB);\n    color = mix(color, vec3(1), .1*SegmentOA);\n    color = mix(color, vec3(1), .1*SegmentOB);\n    color = mix(color, vec3(1), .1*SegmentOmid);\n    \n    color = mix(color, vec3(1), .75*ArrowN);\n    \n    color = mix(color, vec3(0), charA_shadow);\n    color = mix(color, vec3(0), charB_shadow);\n    color = mix(color, vec3(0), charN_shadow);\n    color = mix(color, vec3(0), charX_shadow);\n    \n    \n    color = mix(color, vec3(1), charA);\n    color = mix(color, vec3(1), charB);\n    color = mix(color, vec3(1), charN);\n    color = mix(color, vec3(1), charX);\n    \n    \n    color = mix(color, CircleSegmentColor, CircleSegmentAB);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n\n    vec3 color = draw_diagram(uv);\n\n    fragColor = vec4(pow(color, vec3(1./GAMMA)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float GAMMA = 2.2;\n\nconst float PI = 3.14159265359;\n\nivec2 ascii_to_index(int ascii_code)\n{\n    const int row_len = 16;\n    const int glyph_size = 64;\n    int y = ascii_code / 16;\n    int x = ascii_code - y * 16;\n    return ivec2(x,y+1);\n}\n\nivec2 index_to_offset(ivec2 index)\n{\n    return ivec2(index.x * 64, 1024 - index.y * 64);\n}\n\nivec2 ascii_to_offset(int ascii_code)\n{\n    return index_to_offset(ascii_to_index(ascii_code));\n}\n\n/*\nfloat character(vec2 uv, vec2 position, float size, int ascii_code, int text_index)\n{\n    //float pixel_size = 1. / iResolution.y;\n    const float percent = .01;\n    uv = (uv-position) / (size*percent) - vec2(text_index, 0)*.5;//(size * pixel_size);\n    ivec2 ij = ivec2(uv * 64.) + ascii_to_offset(ascii_code);\n    float mask = step(0., uv.x) * step(0., 1.-uv.x) * step(0., uv.y) * step(0., 1.-uv.y);\n    return texelFetch(iChannel0, ij, 0).r * mask;\n}\n*/\n\n\n/*\n    \n    \"ASCII\" CODE TABLES FOR character() FUNCTION\n\n*/\n#define ascii_arrow_left 16\n#define ascii_arrow_up 17\n#define ascii_arrow_right 18\n#define ascii_arrow_down 19\n\n#define ascii_arrow_left_right 20\n#define ascii_arrow_up_down 21\n#define ascii_arrow_up_left 22\n#define ascii_arrow_up_right 23\n#define ascii_arrow_down_right 24\n#define ascii_arrow_down_left 25\n#define ascii_arrow_counter_clockwise 26\n#define ascii_arrow_clockwise 27\n#define ascii_arrow_STAR 28\n#define ascii_arrow_smiley 29\n\n#define ascii_space 32\t\n#define ascii_exclam 33\t\n#define ascii_quotation 34\t\n#define ascii_hash 35\t\n#define ascii_dollar 36\t\n#define ascii_percent 37\t\n#define ascii_ampersand 38\t\n#define ascii_apostrophe 39\t\n#define ascii_lparen 40\t\n#define ascii_rparen 41\t\n#define ascii_star 42\t\n#define ascii_plus 43\t\n#define ascii_comma 44\t\n#define ascii_minus 45\t\n#define ascii_period 46\t\n#define ascii_slash 47\t\n#define ascii_0 48\t\n#define ascii_1 49\t\n#define ascii_2 50\t\n#define ascii_3 51\t\n#define ascii_4 52\t\n#define ascii_5 53\t\n#define ascii_6 54\t\n#define ascii_7 55\t\n#define ascii_8 56\t\n#define ascii_9 57\t\n#define ascii_colon 58\t\n#define ascii_semicolon 59\t\n#define ascii_lt 60\t\n#define ascii_equals 61\t\n#define ascii_gt 62\t\n#define ascii_questionmark 63\t\n#define ascii_at 64\t\n#define ascii_A 65\t\n#define ascii_B 66\t\n#define ascii_C 67\t\n#define ascii_D 68\t\n#define ascii_E 69\t\n#define ascii_F 70\t\n#define ascii_G 71\t\n#define ascii_H 72\t\n#define ascii_I 73\t\n#define ascii_J 74\t\n#define ascii_K 75\t\n#define ascii_L 76\t\n#define ascii_M 77\t\n#define ascii_N 78\t\n#define ascii_O 79\t\n#define ascii_P 80\t\n#define ascii_Q 81\t\n#define ascii_R 82\t\n#define ascii_S 83\t\n#define ascii_T 84\t\n#define ascii_U 85\t\n#define ascii_V 86\t\n#define ascii_W 87\t\n#define ascii_X 88\t\n#define ascii_Y 89\t\n#define ascii_Z 90\t\n#define ascii_lbracket 91\t\n#define ascii_backslash 92\t\n#define ascii_rbracket 93\t\n#define ascii_hat 94\t\n#define ascii_underscore 95\t\n#define ascii_accent 96\t\n#define ascii_a 97\t\n#define ascii_b 98\t\n#define ascii_c 99\t\n#define ascii_d 100\t\n#define ascii_e 101\t\n#define ascii_f 102\t\n#define ascii_g 103\t\n#define ascii_h 104\t\n#define ascii_i 105\t\n#define ascii_j 106\t\n#define ascii_k 107\t\n#define ascii_l 108\t\n#define ascii_m 109\t\n#define ascii_n 110\t\n#define ascii_o 111\t\n#define ascii_p 112\t\n#define ascii_q 113\t\n#define ascii_r 114\t\n#define ascii_s 115\t\n#define ascii_t 116\t\n#define ascii_u 117\t\n#define ascii_v 118\t\n#define ascii_w 119\t\n#define ascii_x 120\t\n#define ascii_y 121\t\n#define ascii_z 122\t\n#define ascii_lbrace 123\t\n#define ascii_pipe 124\t\n#define ascii_rbrace 125\t\n#define ascii_tilde 126\t\n\t\n#define ascii_blank2 127\n\n#define ascii_alpha   128\n#define ascii_beta    129\n#define ascii_gamma   130\n#define ascii_delta   131\n#define ascii_epsilon 132\n#define ascii_zeta    ascii_z\n#define ascii_eta     ascii_n\n#define ascii_theta   133\n#define ascii_iota    ascii_i\n#define ascii_kappa   ascii_k\n#define ascii_lambda  134\n#define ascii_mu      135\n#define ascii_nu      ascii_v\n#define ascii_xi      136\n#define ascii_omicron ascii_o\n#define ascii_pi      137\n#define ascii_rho     138\n#define ascii_sigma   139\n#define ascii_tau     140\n#define ascii_upsilon ascii_u\n#define ascii_phi     141\n#define ascii_chi     ascii_x\n#define ascii_psi     142\n#define ascii_omega   143\n\n#define ascii_ALPHA   ascii_A\n#define ascii_BETA    ascii_B\n#define ascii_GAMMA   144\n#define ascii_DELTA   145\n#define ascii_EPSILON ascii_E\n#define ascii_ZETA    ascii_Z\n#define ascii_ETA     ascii_H\n#define ascii_THETA   146\n#define ascii_IOTA    ascii_I\n#define ascii_KAPPA   ascii_K\n#define ascii_LAMBDA  147\n#define ascii_MU      ascii_M\n#define ascii_NU      ascii_N\n#define ascii_XI      ascii_X\n#define ascii_OMICRON ascii_O\n#define ascii_PI      148\n#define ascii_RHO     ascii_P\n#define ascii_SIGMA   149\n#define ascii_TAU     ascii_T\n#define ascii_UPSILON ascii_Y\n#define ascii_PHI     150\n#define ascii_CHI     ascii_X\n#define ascii_PSI     151\n#define ascii_OMEGA   152\n","name":"Common","description":"","type":"common"}]}