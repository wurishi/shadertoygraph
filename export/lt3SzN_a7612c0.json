{"ver":"0.1","info":{"id":"lt3SzN","date":"1478422610","viewed":121,"name":"space gunk","username":"jcolicchio","description":"i made a weird blob in a space hallway","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (3.14159265)\n#define TAU (PI*2)\n#define FOV (75.0)\n#define THRESH (0.01)\n#define MAX_STEPS (120)\n\nstruct Collision {\n    int id;\n    vec3 posInUnitSpace;\n    float dist;\n    float percentMaxSteps;\n};\n\nfloat sdPlane(in vec3 p, in vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox(in vec3 p, in vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(in vec3 p, in float s )\n{\n  return length(p)-s;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// so our elements:\n// 0: backPlane\n// 1: sphere\n// 2: sphere\n// 3: box\n\n#define NONE (-1)\n#define PLANE0 (0)\n#define PLANE1 (1)\n#define SPHERE0 (2)\n#define SPHERE0_POS (vec3(cos(iTime)*100.0,-cos(iTime)*100.0,sin(iTime)*100.0+200.0))\n#define SPHERE0_R (100.0)\n#define SPHERE1 (3)\n#define BOX0 (4)\n#define BOX0_POS (vec3(0,cos(iTime)*100.0,200))\n\n#define DOOR (5)\n\n#define BOX1 (5)\n#define BOX1_POS (vec3(-200,0,200))\n#define BOX1_SIZE (vec3(40,80,160))\n\n\n// i figured it out!\n// so if you want to bend around the x axis as you move forward with z\n// then you use z to generate the matrix\n// and multiply yz by m, because x remains unbent if you're bending around x\nfloat opCheapBendBox1(in vec3 p, out vec3 bentP)\n{\n    float c = cos(0.002*p.z);\n    float s = sin(0.002*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    bentP = vec3(p.x,m*p.yz);\n    return sdBox(bentP, BOX1_SIZE);\n}\n\nvec3 opCheapBendCamera(in vec3 p)\n{\n\tfloat c = cos(0.0007*p.z);\n\tfloat s = sin(0.0007*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(p.x,m*p.yz);\n}\n\nvoid compare(inout int curID, inout vec3 curPos, inout float curDist,\n             in int newID, in vec3 newPos, in float newDist) {\n    if(curID == NONE || newDist < curDist) {\n        curID = newID;\n        curPos = newPos;\n        curDist = newDist;\n    }\n}\n\nfloat opRepBox( vec3 p, vec3 c, vec3 s)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdBox( q, s );\n}\n\nfloat opRepSphere(vec3 p, vec3 c, float r)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q, r );\n}\n\nvec3 cameraPos() {\n    return vec3(0,0,mod(iTime*80.0*3.0, 400.0));\n}\n\nfloat sphereSize() {\n    if(iTime < 300.0) {\n        return 60.0;\n    }\n    else if(iTime < 350.0) {\n\t    return 60.0 + (iTime-300.0)*1.0;\n    }\n    else if(iTime < 360.0) {\n\t    return 60.0 + 50.0 + (iTime-350.0)*10.0;\n    }\n    else {\n\t    return 60.0 + 50.0 + 100.0 + (iTime-360.0)*1.0;\n    }\n}\n\n\nCollision dist(in vec3 pos, in int disabledID) {\n    // for a position in the world p\n    // find the nearest collision\n    \n    int curID = NONE;\n    vec3 curPos = vec3(0);\n    float curDist = 0.0;\n    int newID = NONE;\n    vec3 newPos = vec3(0);\n    float newDist = 0.0;\n    \n    if(disabledID != PLANE0) {\n        newID = PLANE0;\n        newPos = pos - vec3(0,0,600) - cameraPos();\n        newDist = sdPlane(newPos, vec4(0,0,-1,0));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n    }\n    \n    if(disabledID != PLANE1) {\n        newID = SPHERE0;\n        newPos = pos - vec3(0,-150,100);\n        newDist = sdPlane(newPos, vec4(0,1,0,0));\n        //float minusSphere = sdSphere(pos - vec3(150,0,150),150.0);\n        //newDist = opS(minusSphere, newDist);\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        newID = SPHERE0;\n        newPos = pos - vec3(-250,0,100);\n        newDist = sdPlane(newPos, vec4(1,0,0,0));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        newID = SPHERE0;\n        newPos = pos - vec3(250,0,100);\n        newDist = sdPlane(newPos, vec4(-1,0,0,0));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        newID = SPHERE0;\n        newPos = pos - vec3(0,150,100);\n        newDist = sdPlane(newPos, vec4(0,-1,0,0));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        // now the other things\n        newID = SPHERE0;\n        newPos = pos - vec3(-250+30,-150+20,100);\n        newDist = opRepBox(newPos, vec3(0, 0, 20), vec3(30,20,30));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        newID = SPHERE0;\n        newPos = pos - vec3(250-30,-150+20,100);\n        newDist = opRepBox(newPos, vec3(0, 0, 20), vec3(30,20,30));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        newID = SPHERE0;\n        newPos = pos - vec3(250-30,150-20,100);\n        newDist = opRepBox(newPos, vec3(0, 0, 20), vec3(30,20,30));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        newID = SPHERE0;\n        newPos = pos - vec3(-250+30,150-20,100);\n        newDist = opRepBox(newPos, vec3(0, 0, 20), vec3(30,20,30));\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        /*newID = SPHERE0;\n        // base door openness on distance from camera\n        newPos = pos - vec3(float(-250/2)-mod(0.0*50.0,250.0), 0, 100);\n        newDist = opRepBox(newPos+vec3(0,0,400), vec3(0,0,800), vec3(250/2,150,10));\n        newDist = opS(sdSphere(vec3(0,0,200),200.0), newDist);\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        newID = SPHERE0;\n        newPos = pos - vec3(float(250/2)+mod(0.0*50.0,250.0), 0, 100);\n        newDist = opRepBox(newPos+vec3(0,0,400), vec3(0,0,800), vec3(250/2,150,10));\n        newDist = opS(sdSphere(vec3(0,0,0),200.0), newDist);\n        compare(curID, curPos, curDist, newID, newPos, newDist);*/\n        \n        newID = DOOR;\n        newPos = pos - vec3(100,-100,200);\n        newDist = opRepBox(newPos, vec3(60,60,400), vec3(30,30,2));\n        vec3 newPos2 = pos - vec3(0,0,-80) - cameraPos();\n        float c = cos(PI/4.0);\n        float s = sin(PI/4.0);\n        mat2 m = mat2(c,-s,s,c);\n        vec3 rotBox = vec3(newPos2.y,newPos2.xz*m).yxz;\n        newDist = opS(sdBox(rotBox, vec3(200,150,200)), newDist);\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        newPos = pos - vec3(100,-100,200);\n        newDist = opRepBox(newPos+vec3(0,0,200), vec3(60,60,400), vec3(30,30,2));\n        newPos2 = (pos - vec3(0,0,-80))*vec3(1,1.5,1) - cameraPos();\n        c = cos(PI/4.0);\n        s = sin(PI/4.0);\n        m = mat2(c,-s,s,c);\n        rotBox = vec3(newPos2.x,newPos2.yz*m);\n        newDist = opS(sdBox(rotBox, vec3(250,200,200)), newDist);\n        compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        newPos = (pos - vec3(0,0,100)) * vec3(1,1.0,1);\n        m = mat2(c,-s,s,c);\n        rotBox = vec3(newPos.z,newPos.xy*m).zxy;\n        newDist = sdBox(rotBox, vec3(20));\n        //compare(curID, curPos, curDist, newID, newPos, newDist);\n        \n        \n    }\n    \n    if(disabledID != SPHERE0) {\n        newID = SPHERE0;\n\t    newPos = pos - SPHERE0_POS - cameraPos();\n\t    newDist = sdSphere(newPos, SPHERE0_R);\n        //compare(curID, curPos, curDist, newID, newPos, newDist);\n    }\n    \n    if(disabledID != SPHERE1) {\n        newID = SPHERE1;\n        float a = (cos(iTime/20.0-PI)*0.5+0.5)*120.0;\n        newPos = pos - vec3(cos(iTime)*a,cos(PI/2.0+iTime*2.0)*a/2.0,50.0) - cameraPos();\n        newDist = sdSphere(newPos, sphereSize());\n\n        float fx = 0.2;\n        float fy = sqrt(iTime)/100.0;\n        float fz = cos(iTime/20.0)*0.05+0.15;\n        float amp = (cos(sin(140.0*2.2)+0.1)*3.0+5.0)*sin(140.0/30.0);\n        newDist += \n            sin(fx*newPos.x*cos(iTime*1.1)+0.5)*\n            sin(fy*newPos.y*sin(iTime*1.9))*\n            sin(fz*newPos.z*cos(sin(iTime*1.5)+1.5))*amp;\n        \n        compare(curID, curPos, curDist, newID, newPos, newDist);\n    }\n    \n    if(disabledID != BOX0) {\n        newID = BOX0;\n        newPos = pos - BOX0_POS;\n        newDist = sdBox(newPos, vec3(50));\n        //compare(curID, curPos, curDist, newID, newPos, newDist);\n    }\n    \n    if(disabledID != BOX1) {\n        newID = BOX1;\n        newPos = pos - BOX1_POS;\n        vec3 bentPos;\n        newDist = opCheapBendBox1(newPos, bentPos);\n        //compare(curID, curPos, curDist, newID, bentPos, newDist);\n    }\n    \n    return Collision(curID, curPos, curDist, 0.0);\n}\n\nbool rotating() {\n    return iTime > 25.0;\n}\nfloat rotationSpeed() {\n    return (iTime-25.0)/150.0;\n}\n\nbool nightmare() {\n    return iTime > 175.0 && iTime < 225.0;\n}\n\nbool twist() {\n    return iTime > 100.0;\n}\n\nfloat twistAmount() {\n    return (iTime-100.0)/5000.0;\n}\n\nbool dark() {\n    return mod(iTime, 100.0) > 50.0 || iTime > 400.0;\n}\n\nfloat nightmareAmount() {\n    return (iTime-175.0)/60.0;\n}\n\nCollision map(inout vec3 pos, in vec3 ray, in int disabledID) {\n    for(int i=0;i<MAX_STEPS;i++) {\n        vec3 bentPos = opCheapBendCamera(pos);\n        // rotate around z axis first?\n        vec3 rotPos = pos;\n        if(rotating()) {\n\t        float cc = cos(iTime*rotationSpeed());\n    \t    float s = sin(iTime*rotationSpeed());\n            if(twist()) {\n                cc = cos(-pos.z*twistAmount()+iTime*rotationSpeed());\n                s = sin(-pos.z*twistAmount()+iTime*rotationSpeed());\n            }\n        \tmat2 m = mat2(cc,-s,s,cc);\n\t        rotPos = vec3(pos.xy*m,pos.z);\n            if(nightmare()) {\n            \tpos = pos*(1.0-nightmareAmount()) + rotPos*nightmareAmount();\n            }\n        }\n        vec3 zoomPos = rotPos + cameraPos();\n        Collision c = dist(zoomPos, disabledID);\n        pos += ray*c.dist;\n        if(c.dist < THRESH) {\n            c.posInUnitSpace += vec3(0,0,-20);\n            c.percentMaxSteps = float(i)/float(MAX_STEPS);\n            return c;\n        }\n    }\n    return Collision(NONE,vec3(0),0.0, 1.0);\n}\n\nvec4 texture(in Collision col, in vec3 pos) {\n    if(col.id == NONE) {\n        return vec4(0,0,0,1);\n    }\n    else if(col.id == PLANE0) {\n        vec2 uv = col.posInUnitSpace.xy*0.008;\n        return vec4(texture(iChannel0,uv).rgb,1);\n    }\n    else if(col.id == PLANE1) {\n        vec2 uv = col.posInUnitSpace.xz*0.0016-vec2(iTime/20.0,0.3);\n        return vec4(texture(iChannel1,uv).rgb,1);\n    }\n    else if(col.id == SPHERE0) {\n        vec4 color = vec4(vec3(1.0-pos.z/400.0),1);\n        int s = int(col.posInUnitSpace.z/20.0*iTime)*10;\n        float sf = mod(float(s),200.0);\n        if(pos.z > sf && pos.z < sf+20.0) {\n            //color = vec4(vec3(0),1);\n            color.g = mod(col.posInUnitSpace.z/3.0,1.0);\n            //color.r = mod(col.posInUnitSpace.z/3.0,0.5);\n            //color.b = mod(col.posInUnitSpace.x/5.0,1.0);\n        }\n        \n        //color = vec4(vec3(1.0-pos.z/400.0),1);\n        if(pos.z > 10.0 && pos.z < 20.0) {\n        //    color = vec4(vec3(0),1);\n        }\n        \n        return color;\n    }\n    else if(col.id == DOOR) {\n        //return texture(iChannel1,pos.xy/100.0);\n        return vec4(vec3(1.0-pos.z/400.0),1);\n    }\n    else if(col.id == SPHERE1) {\n        float intensity = max((pos.z+50.0)/80.0+0.3,0.0)+0.2;\n        float r = cos(iTime)/2.0+0.5;\n        float g = sin(iTime)/2.0+0.5;\n        float b = cos(iTime*2.0)/2.0+0.5;\n    \treturn vec4(vec3(r,g,b)*(0.0+intensity),1);\n    }\n    else if(col.id == BOX0) {\n        return vec4(pos.z/300.0,pos.z/300.0,0,1);\n    }\n    else if(col.id == BOX1) {\n        // the pos will be bended, i think?\n        // but i believe because we save the pos relative to box\n        // prior to bending it, it'll still be box units?\n        \n        return vec4((col.posInUnitSpace*-1.0/BOX1_SIZE),1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    vec3 pixel = vec3(uv*iResolution.xy, 0);\n    vec3 viewer = vec3(0,0,-tan(FOV/2.0*PI/180.0)*length(iResolution.xy)/2.0);\n    \n    vec3 ray = normalize(pixel - viewer);\n    \n    vec3 pos = viewer;\n    Collision col = map(pos, ray, NONE);\n    \n    // let's bounce it if it struck the green ball?\n    /*if(col.id == SPHERE0) {\n        vec4 base = texture(col, pos);\n        // get the normal given the position\n        vec3 sphereNorm = normalize(pos - SPHERE0_POS);\n        // reflect ray\n        vec3 reflectedRay = normalize(reflect(ray, sphereNorm));\n        //col = map(pos, reflectedRay, DOOR);\n        vec4 refl = texture(col, pos);\n        fragColor = mix(base, refl, 0.8);\n    }\n    else {*/\n    \n    float t = mod(iTime, 200.0);\n    float interval = 0.863;\n    float onTime = interval/2.0;\n    float t2 = mod(iTime, interval);\n    if(!dark()) {\n        fragColor = texture(col, pos);\n    }\n    else {\n        vec3 color = vec3(1);\n        if(t2 > interval - onTime) {\n            color = vec3(cos(iTime*10.0)*0.25+0.5,\n                         sin(iTime*10.0)*0.25+0.5,\n                         cos(iTime*5.0)*0.25+0.7);\n        }\n        fragColor = vec4(color * col.percentMaxSteps*0.9+0.1,1);\n    }\n    //}\n    // if green, just set r and b to 0\n}","name":"Image","description":"","type":"image"}]}