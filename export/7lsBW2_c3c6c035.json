{"ver":"0.1","info":{"id":"7lsBW2","date":"1651604350","viewed":452,"name":"Cubic bezier distance","username":"gleboneloner","description":"Numerical-analytic approximation of the distance from point to a cubic bezier curve.\nIs uses oneshade's quartic solver after polynomial root deflation.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","cubic","numeric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float cubicBezier ( vec2 a, vec2 b, vec2 c, vec2 d, vec2 uv ) {\n\n    float s1 = -1.0;  vec2 S1 = 3.0*(b-c)-a+d;\n    float s2 = +1.0;  vec2 S2 = 3.0*(c+a-b-b);\n    float H1 = -1.0;  vec2 S3 = 3.0*(b-a);\n    float H2 = +1.0;  vec2 S4 = a-uv;\n\n    float U1 = 3.0*dot(S1,S1);\n    float U2 = 5.0*dot(S1,S2);\n    float U3 = 4.0*dot(S1,S3) + 2.0*dot(S2,S2);\n    float U4 = 3.0*dot(S1,S4) + 3.0*dot(S2,S3);\n    float U5 = 2.0*dot(S2,S4) + 1.0*dot(S3,S3);\n    float U6 = 1.0*dot(S3,S4);\n\n    for ( int i = 0; i < 12; i += 1 ) {\n\n        float s3 = (s1+s2)/2.0; float k = s3/(1.0-abs(s3));\n        \n        float H3 = k*(k*(k*(k*(U1*k+U2)+U3)+U4)+U5)+U6;\n\n        ( H1*H3 <= 0.0 ) ? ( s2 = s3, H2 = H3 ) : ( s1 = s3, H1 = H3 );\n\n    }\n\n    float n1 = (s1*H2-s2*H1)/(H2-H1); n1 /= 1.0-abs(n1);\n    \n    float B1 = U1, B2 = U2+n1*B1, B3 = U3+n1*B2, B4 = U4+n1*B3, B5 = U5+n1*B4;\n    \n    vec4 roots; solveQuartic( B1, B2, B3, B4, B5, roots );\n    \n    float n2 = roots.x, n3 = roots.y, n4 = roots.z, n5 = roots.w;\n\n    vec2 N1 = n1*(n1*(S1*n1+S2)+S3)+S4; float I1 = dot(N1,N1);\n    vec2 N2 = n2*(n2*(S1*n2+S2)+S3)+S4; float I2 = dot(N2,N2);\n    vec2 N3 = n3*(n3*(S1*n3+S2)+S3)+S4; float I3 = dot(N3,N3);\n    vec2 N4 = n4*(n4*(S1*n4+S2)+S3)+S4; float I4 = dot(N4,N4);\n    vec2 N5 = n5*(n5*(S1*n5+S2)+S3)+S4; float I5 = dot(N5,N5);\n\n    return sqrt(min(min(min(min(I1,I2),I3),I4),I5));\n\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 a = vec2( iResolution.x*0.35, iResolution.y*0.4 );\n    vec2 b = vec2( iResolution.x*0.35, iResolution.y*0.8 );\n    vec2 c = vec2( iResolution.x*0.65, iResolution.y*0.8 );\n    vec2 d = vec2( iResolution.x*0.65, iResolution.y*0.4 );\n    vec2 uv = fragCoord;\n    \n    if ( iMouse.z != 0.0 ) b = iMouse.xy;\n\n \tfloat n = cubicBezier( a, b, c, d, uv );\n    \n    vec4 color = mix( vec4(0.4,0.6,0.8,1), vec4(0.6,0.2,0.3,1), step( 0.0, cos(n/1.2) ) );\n\n    color = color * min(abs(cos(n/1.2)*1.2),1.0) * (1.4-1.2/exp(n/40.0));\n    \n    color = mix( vec4(1.0,1.0,1.0,1.0), color, smoothstep( 0.0, 1.8, n ) );\n    \n    color = mix( vec4(0.0,0.0,0.0,1.0), color, smoothstep( 6.0, 7.5, distance(uv,a) ) );\n    color = mix( vec4(0.2,0.8,0.7,1.0), color, smoothstep( 4.8, 6.0, distance(uv,a) ) );\n    \n    color = mix( vec4(0.0,0.0,0.0,1.0), color, smoothstep( 6.0, 7.5, distance(uv,d) ) );\n    color = mix( vec4(0.2,0.8,0.7,1.0), color, smoothstep( 4.8, 6.0, distance(uv,d) ) );\n    \n    color = mix( vec4(0.0,0.0,0.0,1.0), color, smoothstep( 6.0, 7.5, distance(uv,b) ) );\n    color = mix( vec4(1.0,0.7,0.2,1.0), color, smoothstep( 4.8, 6.0, distance(uv,b) ) );\n    \n    color = mix( vec4(0.0,0.0,0.0,1.0), color, smoothstep( 6.0, 7.5, distance(uv,c) ) );\n    color = mix( vec4(1.0,0.7,0.2,1.0), color, smoothstep( 4.8, 6.0, distance(uv,c) ) );\n    \n    fragColor = color;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// It uses this quartic solver https://www.shadertoy.com/view/fsB3Wt by oneshade\n\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}","name":"Common","description":"","type":"common"}]}