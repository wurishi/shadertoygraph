{"ver":"0.1","info":{"id":"WtcyzH","date":"1608570064","viewed":236,"name":"Animated Hiragana Demo","username":"mherreshoff","description":"Uses cubic curves to animate two Japanese hiragana, ma (ま) and sa (さ), continuously morphing into each other.  Still thinking of ways to speed it up to get it to work with more strokes.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["animated","cubic","calligraphy","japanese","hiragana"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n#define CS(a) vec2(cos(a), sin(a))\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec4(0,-2.*PI/3.,2.*PI/3.,0)))\n\nfloat sq(float x) { return x*x; }\n\n// We store cubics in vec4's, in little endian.\nfloat evalCubic (in vec4 p, in float v) {\n    return p.x + v*p.y + v*v*p.z + v*v*v*p.w;\n}\n\n// Similarly, we store the coefficients of a heptic.\nvec4[2] hepticD (in vec4[2] p) {\n    return vec4[2](vec4(p[0].yzw, p[1].x)*vec4(1,2,3,4),vec4(p[1].yzw, 0)*vec4(5,6,7,8));\n}\nfloat evalHeptic(in vec4[2] p, in float v) {\n    float s=v*v, q=s*s;\n    vec4 pows = vec4(1,v,s,v*s);\n    return dot(p[0],pows)+q*dot(p[1], pows);\n}\nvec4[2] mulCubic(in vec4 a, in vec4 b) {\n    return vec4[2](\n        vec4(a.x*b.x, dot(a.xy,b.yx), dot(a.xyz, b.zyx), dot(a.xyzw, b.wzyx)),\n        vec4(dot(a.yzw,b.wzy), dot(a.zw,b.wz), a.w*b.w, 0.));\n}\n#define sqCubic(a) mulCubic((a),(a))\n\n// Interpolates four values to make a cubic curve beween the middle two.\n// See: https://www.paulinternet.nl/?page=bicubic\nvec4 interpolate(in vec4 p) {\n    float f0 = p.y, f1 = p.z,\n          d0 = (p.z-p.x)/2., d1 = (p.w - p.y)/2.;\n    return vec4(f0, d0, -3.*f0+3.*f1-2.*d0-d1, 2.*f0-2.*f1+d0+d1);\n}\n\n#define C(v) vec4(v,0,0,0)\n#define F(v) evalHeptic(poly, v)\n#define FD(v) evalHeptic(polyD, v)\n#define FDD(v) evalHeptic(polyDD, v)\n\n\n// Bracketing version\nfloat distToStroke (in vec4 xPoly, in vec4 yPoly, in vec4 wPoly, vec2 pos) {\n    vec4[2] xTerm = sqCubic(xPoly - C(pos.x));\n    vec4[2] yTerm = sqCubic(yPoly - C(pos.y));\n    vec4[2] poly = vec4[2](xTerm[0]+yTerm[0]-wPoly, xTerm[1]+yTerm[1]);\n\n    float lo = 0., hi = 1.;\n    // Heuristic to find the minimum.  Repeatedly:\n    // Evaluate at the quartiles, and pick the half of the interval containing the best one.\n    for (float i = 0.; i < 7.; i++) {\n        float bestQ = 0., bestV = F(lo);\n        for (float q = 1.; q <= 4.; q++) {\n            float val = F(mix(lo, hi, q/4.));\n            if (val < bestV) {\n                bestQ = q; bestV = val;\n            }\n        }\n        float midQ = bestQ;\n        if (midQ < .5) midQ = 1.;\n        if (midQ > 3.5) midQ = 3.;\n        float newLo = mix(lo,hi,(midQ-1.)/4.), newHi = mix(lo,hi,(midQ+1.)/4.);\n        lo = newLo; hi = newHi;\n    }\n    return F((lo+hi)/2.);\n#undef f\n}\n\n\n// Heuristic: bisect.  Look at the dirivative in the middle to chose which half.\n// Somehow this was slower than bracketing.... why?\n/*\nfloat distToStroke (in vec4 xPoly, in vec4 yPoly, in vec4 wPoly, vec2 pos) {\n    vec4[2] xTerm = sqCubic(xPoly - C(pos.x));\n    vec4[2] yTerm = sqCubic(yPoly - C(pos.y));\n    vec4[2] poly = vec4[2](xTerm[0]+yTerm[0]-wPoly, xTerm[1]+yTerm[1]);\n    vec4[2] polyD = hepticD(poly);\n    // vec4[2] polyDD = hepticD(polyD);\n    float lo=0., hi=1.;\n    for (int i = 0; i < 7; i++) {\n        float mid = (lo+hi)/2.;\n        if (FD(mid) > 0.) hi = mid;\n        else lo = mid;\n    }\n    return F((hi+lo)/2.);\n}\n*/\n\nfloat distToPath(in vec3[16] vs, vec2 p) {\n    vec4 pathXs[vs.length()-1];\n    vec4 pathYs[vs.length()-1];\n    vec4 pathWs[vs.length()-1];\n    for (int i = 0; i < pathXs.length(); i++) {\n        pathXs[i] = interpolate(vec4(vs[i==0?0:i-1].x, vs[i].x, vs[i+1].x,vs[i+2==vs.length()?i+1:i+2].x));\n        pathYs[i] = interpolate(vec4(vs[i==0?0:i-1].y, vs[i].y, vs[i+1].y,vs[i+2==vs.length()?i+1:i+2].y));\n        pathWs[i] = interpolate(vec4(vs[i==0?0:i-1].z, vs[i].z, vs[i+1].z,vs[i+2==vs.length()?i+1:i+2].z));\n    }\n    float d = 100.;\n    for (int i = 0; i < pathXs.length(); i++) {\n        d = min(d, distToStroke(pathXs[i], pathYs[i], pathWs[i], p));\n    }\n    return d;\n}\n\n\nvoid mainImage(out vec4 O, in vec2 u)\n{\n    vec2 R=iResolution.xy, p = .5+(u-R/2.)/R.y;\n    \n    vec3 parchment1 = vec3(249, 233, 215)/255.;\n    vec3 parchment2 = vec3(176, 145, 72)/255.;\n    vec4 parchment = vec4(mix(parchment1, parchment2, pow(roughTexture(p*16.),4.)),1.);\n\n\n#define H(x,y) vec3(x,y,0) /* brush hits paper */\n#define T(x,y) vec3(x,y,.001) /* thin stroke */\n#define S(x,y) vec3(x,y,.003) /* regular stroke */\n#define L(x,y) vec3(x,y,-.003) /* brush lifted */\n    const vec3[] hiragana_ma = vec3[](\n        L(-.4, 1.), T(.3, .75), S(.75, .8), L(.75, .8), // top bar\n        L(-.4, .8), T(.3, .55), S(.75, .6), L(.75, .6), // mid bar\n        L(.5,1.0),S(.5,.8),S(.5,.2), // decender, and...\n        S(.3,.05), S(.1,.2), S(.4,.25), T(.8,.1), L(1.8,-.2) //loop.\n    );\n    \n    const vec3[] hiragana_sa = vec3[](\n        L(.3, .7), T(.35,.65), S(.25, .6), S(.75,.8), L(.75,.8), // cross bar\n        L(.2,.9), S(.25, .9), S(.75, .4), S(.74, .41), H(.5,.45), L(.37,.5), // decender, hook\n        H(.2,.4), T(.15,.3), S(.3, .12), S(.6,.1), L(.6,.1) // lower curve.\n    );\n    \n\n    vec3[16] vs;\n    float t = 2.*abs(fract(iTime/6.)-.5);\n    //for (int i = 0;i < 16; i++) vs[i] = mix(hiragana_ma[i], hiragana_sa[i], t);\n    // For whatever reason, manually unrolling this loop helped on my machine.\n    vs[0] = mix(hiragana_ma[0], hiragana_sa[0], t);\n    vs[1] = mix(hiragana_ma[1], hiragana_sa[1], t);\n    vs[2] = mix(hiragana_ma[2], hiragana_sa[2], t);\n    vs[3] = mix(hiragana_ma[3], hiragana_sa[3], t);\n    vs[4] = mix(hiragana_ma[4], hiragana_sa[4], t);\n    vs[5] = mix(hiragana_ma[5], hiragana_sa[5], t);\n    vs[6] = mix(hiragana_ma[6], hiragana_sa[6], t);\n    vs[7] = mix(hiragana_ma[7], hiragana_sa[7], t);\n    vs[8] = mix(hiragana_ma[8], hiragana_sa[8], t);\n    vs[9] = mix(hiragana_ma[9], hiragana_sa[9], t);\n    vs[10] = mix(hiragana_ma[10], hiragana_sa[10], t);\n    vs[11] = mix(hiragana_ma[11], hiragana_sa[11], t);\n    vs[12] = mix(hiragana_ma[12], hiragana_sa[12], t);\n    vs[13] = mix(hiragana_ma[13], hiragana_sa[13], t);\n    vs[14] = mix(hiragana_ma[14], hiragana_sa[14], t);\n    vs[15] = mix(hiragana_ma[15], hiragana_sa[15], t);\n\n    \n    float d = distToPath(vs, p);\n    O = mix(vec4(0),parchment, smoothstep(-0.002,0.,d));\n    /*\n    // Draw Interpolation points. \n    for (int i = 0; i < vs.length(); i++){\n      if (distance(vs[i].xy,p)<.01) O = hue(0.);\n    }\n    */\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// From: https://thebookofshaders.com/edit.php?log=161119153749\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat roughTexture(vec2 st) {\n    float n = 0.0;\n    for (float i = 1.0; i < 8.0; i ++) {\n        float m = pow(2.0, i);\n        n += snoise(st * m) * (1.0 / m);\n    }\n    return n * 0.5 + 0.5;\n}\n\n/// Other stuff:\n","name":"Common","description":"","type":"common"}]}