{"ver":"0.1","info":{"id":"tdtBD2","date":"1606078057","viewed":183,"name":"checkerboard animation 1.1","username":"DjinnKahn","description":"for https://isohedral.ca/swirled-series/\n\ntry changing N to a bigger power of 2","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["checkerboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 8.      // number of checkerboard squares\n#define PATTERN 0 // some integer in the range [0,N)\n#define PI 3.1415926\n\nconst bool shading = false;\n\nfloat easeInOutCubic( float x ) \n{\n\treturn x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat easeInOutQuad( float x ) \n{\n\treturn x < 0.5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nvec3 rotY( vec3 p, float angle )\n{\n    return vec3( p.x * cos(angle) + p.z * sin(angle), p.y, p.x * -sin(angle) + p.z * cos(angle) );\n}\nvec3 rotX( vec3 p, float angle )\n{\n    return vec3( p.x, p.y * cos(angle) + p.z * sin(angle), p.y * -sin(angle) + p.z * cos(angle) );\n}\n\nvec3 planeIntersectionUVT( vec3 rayPoint, vec3 rayDir, vec3 planePoint, vec3 planeU, vec3 planeV )\n{\n    vec3 p = rayPoint - planePoint;\n    vec3 planeN = cross( planeU, planeV );\n    float t = -dot( p, planeN ) / dot( rayDir, planeN ); // distance\n    float u = dot( p, planeU ) + dot( rayDir, planeU ) * t;\n    float v = dot( p, planeV ) + dot( rayDir, planeV ) * t;\n    return vec3( u, v, t );\n}\n\nvec3 permute( vec3 v, int n )\n{\n   if ( n == 1 ) return v.yzx;\n   if ( n == 2 ) return v.zxy; \n   return v.xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n        \n    float t = mod( iTime / 2., 1. );\n    t = easeInOutQuad( t );\n    \n    // set up camera\n    float angle = t * PI / 2.;\n    float vertAngle = sin( PI * t ) * .1;\n    vec3 pos = rotY( rotX( vec3( 0., 0., -5. ), angle), angle );\n    vec3 dir = rotY( rotX( vec3( 0., 0., 1. ), angle), angle );\n    vec3 dir_right = normalize( -cross( dir, vec3( 0., 1., 0. ) ) );\n    vec3 dir_up = cross( dir, dir_right );\n    \n    vec3 p = pos + dir_right * uv.x + dir_up * uv.y;\n        \n    \n    fragColor = vec4(vec3( .2 ), 1.0);\n    float closestDist = 999.; // z-buffering\n    \n    // There are N layers of planes for all 3 axes (X, Y, Z).\n    // We'll do a plane-ray intersection for each.\n    // Most of the intersections will be transparent -- the 'hit' variable decides if we actually hit a checker square or not\n    for ( int whichAxis = 0; whichAxis < 3; whichAxis++ )\n    {\n        for ( int checkerZ = 0; checkerZ < int(N); checkerZ++ )\n        {\n            vec3 planeUVT = planeIntersectionUVT( p, dir, permute( vec3( -.5,-.5, -.5 + float(checkerZ)/N ), whichAxis ), permute( vec3( 1.,0.,0. ), whichAxis ), permute( vec3( 0.,1.,0. ), whichAxis ) );\n            int checkerX = int(floor(planeUVT.x*N));\n            int checkerY = int(floor(planeUVT.y*N));\n            if ( checkerX < 0 || checkerX >= int(N) ) continue;\n            if ( checkerY < 0 || checkerY >= int(N) ) continue;\n            bool hit = (checkerX ^ checkerY ^ (int(N)-1) ^ PATTERN) == checkerZ;\n            if ( hit )\n            {\n                if ( planeUVT.z < closestDist )\n                {\n                    float light = shading ? dot( dir, permute( vec3( 0.,0.,1. ), whichAxis ) ) : 1.;\n                    //fragColor = vec4( planeUVT.xy, 0., 1. );                    \n                    fragColor = ((checkerX ^ checkerY) & 1) == 0 ? vec4( 0. ) : vec4( 1. ) * light;\n                    closestDist = planeUVT.z;\n                }\n            }\n        }\n    }    \n}","name":"Image","description":"","type":"image"}]}