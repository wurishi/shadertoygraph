{"ver":"0.1","info":{"id":"ss2SWy","date":"1620968994","viewed":133,"name":"Rotating Mandelbulb ","username":"sid003","description":"mandelbulb shader","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n#define MAX_STEPS 500\n#define MIN_DIST 0.001\n#define MAX_DIST 20.0\n#define R_MAX 2.0\n#define MAX_ITERS 100\n#define ZC 2.0\n#define PI 3.14159265358979323846264338327950288419716939937510\n#define SHADOW 0.9\n\n//stolen from: http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat mandelbulb(vec3 pos) {\n\tfloat power = 1.2 + (iTime * 0.1);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < MAX_ITERS ; i++) {\n\t\tr = length(z);\n\t\tif (r>R_MAX) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nvec3 rotateZ(vec3 pos, float theta) {\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\n\tmat3 rotationMatrix = mat3(\n\t\t\t\t\t\t   vec3(1, 0, 0), \n\t\t\t\t\t\t   vec3(0, c, -s),\n\t\t\t\t\t\t   vec3(0, s, c)\n\t\t\t\t\t\t   );\n\n\treturn rotationMatrix * pos;\n}\n\n\nvec3 rotateX(vec3 pos, float theta) {\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\n\n\tmat3 rotationMatrix = mat3(\n\t\t\t\t\t\t   vec3(c, -s, 0), \n\t\t\t\t\t\t   vec3(s, c, 0),\n\t\t\t\t\t\t   vec3(0, 0, 1)\n\t\t\t\t\t\t   );\n\n\treturn rotationMatrix * pos;\n}\n\n\nvec3 rotateY(vec3 pos, float theta) {\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\n\n\tmat3 rotationMatrix = mat3(\n\t\t\t\t\t\t   vec3(c, 0, s), \n\t\t\t\t\t\t   vec3(0, 1, 0),\n\t\t\t\t\t\t   vec3(-s, 0, c)\n\t\t\t\t\t\t   );\n\n\treturn rotationMatrix * pos;\n}\n\nfloat world_map(vec3 pos) {\n\treturn mandelbulb(rotateY(rotateX(pos, iTime * 0.5), iTime * 0.5));\n}\n\nfloat ray_march(vec3 origin, vec3 rayDir) {\n\tfloat td = MIN_DIST;\n\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 ray = origin + rayDir * td;\n\n\t\tfloat d = world_map(ray);\n\n\t\tif (d < MIN_DIST) {\n\t\t\treturn td;\n\t\t}\n\t\t\n\t\tif (d > MAX_DIST) {\n\t\t\treturn -1.0;\n\t\t}\n\n\t\ttd += d;\n\t}\n\n\treturn td;\n}\n\n//https://iquilezles.org/articles/rmshadows\nfloat soft_shadow(vec3 origin, vec3 rayDir, float k) {\n\tfloat td = MIN_DIST;\n\n\tfloat res = 1.0;\n\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 ray = origin + rayDir * td;\n\n\t\tfloat d = world_map(ray);\n\n\t\tif (d < MIN_DIST) {\n\t\t\treturn (1.0 - SHADOW);\n\t\t}\n\t\t\n\t\tif (d > MAX_DIST) {\n\t\t\tbreak;\n\t\t}\n\n\t\tres = min(res, k * d / td);\n\t\ttd += d;\n\t}\n\n\treturn res;\n}\n\nvec3 calc_normal(in vec3 pos) {\n\tconst float eps = 0.001;\n\n\tconst vec2 h = vec2(eps, 0);\n\n\treturn normalize(vec3(world_map(pos + h.xyy) - world_map(pos - h.xyy),\n\t\t\t\t\t\t  world_map(pos + h.yxy) - world_map(pos - h.yxy),\n\t\t\t\t\t\t  world_map(pos + h.yyx) - world_map(pos - h.yyx)\n\t));\n}\n\nvec3 get_color(in vec3 ro, vec3 dir) {\n\tfloat t = ray_march(ro, dir);\n\n\tif (t > 0.0) {\n\t\tvec3 pos = ro + t * dir;\n\n\t\tvec3 norm = calc_normal(pos);\n\n\t\tvec3 light = vec3(0.8, 0.8, -0.2);\n\n\t\tfloat k = soft_shadow(pos + norm * 0.001, light, 20.0);\n\t\t\n\n\t\tk *= clamp(dot(norm, light), 0.0, 1.0);\n\t\treturn vec3(1.0 - norm.x, norm.y, norm.x + norm.y) * k * 2.0;\n\t}\n\n\treturn vec3(1.0);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat ar = iResolution.x / iResolution.y;\n\n\tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y * ar;\n\tvec3 cam = vec3(0.0, 0, -1.5);\n\tvec3 rayDir = normalize(vec3(uv, 1.0));\n\tvec3 color = get_color(cam, rayDir);\n\n\tcolor = pow(color, vec3(0.4545));\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}