{"ver":"0.1","info":{"id":"XddcWf","date":"1520646858","viewed":178,"name":"Shogi piece","username":"mizar","description":"Shogi piece geometry test.\nI would like to implement reflection and refraction in the future.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["test","shogi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define mat4_rotx_sc(s, c) mat4(1., 0., 0., 0., 0., c, s, 0., 0., -(s), c, 0., 0., 0., 0., 1.)\n#define mat4_roty_sc(s, c) mat4(c, 0., -(s), 0., 0., 1., 0., 0., s, 0., c, 0., 0., 0., 0., 1.)\n#define mat4_rotz_sc(s, c) mat4(c, s, 0., 0., -(s), c, 0., 0., 0., 0., 1., 0., 0., 0., 0., 1.)\n#define mat4_mul_add(s, a) mat4(s.x, 0., 0., 0., 0., s.y, 0., 0., 0., 0., s.z, 0., a.x, a.y, a.z, 1.)\n\n// sholder angle\nconst float angle_a = radians(18.);\n// side angle\nconst float angle_b = radians(81.);\n// surface angle\nconst float angle_c = radians(85.);\n\nconst float sin_a = sin(angle_a);\nconst float cos_a = cos(angle_a);\nconst float sin_b = sin(angle_b);\nconst float cos_b = cos(angle_b);\nconst float cot_b = cos_b / sin_b;\nconst float sin_c = sin(angle_c);\nconst float cos_c = cos(angle_c);\nconst float cot_c = cos_c / sin_c;\n\nconst vec3 vec3_zero = vec3(0., 0., 0.);\nconst vec3 vec3_one = vec3(1., 1., 1.);\n\nfloat sdPiece_simple(vec3 p, vec3 g) {\n\t// Bottom\n\tfloat bo = -(p.y + g.y);\n\t// Shoulder\n\tfloat sh = abs(p.x) * sin_a + (p.y - g.y) * cos_a;\n\t// Side\n\tfloat si = (abs(p.x) - g.x) * sin_b + (p.y + g.y) * cos_b;\n\t// Surface\n\tfloat su = (abs(p.z) - g.z) * sin_c + (p.y + g.y) * cos_c;\n\n\treturn max(max(bo, sh), max(si, su));\n}\n\nvec4 sdPiece(vec3 p, vec3 g) {\n    // translate matrix\n\tconst mat4 mat4_bo  = mat4_mul_add(vec3(.5, .5, 1.), vec3(4./8., 1./8., 0.)) * mat4_rotx_sc(-1., +0.);\n\tconst mat4 mat4_shl = mat4_mul_add(vec3(.5, .5, 1.), vec3(4./8., 3./8., 0.)) * mat4_rotx_sc(+1., +0.) * mat4_rotz_sc(-sin_a, +cos_a);\n\tconst mat4 mat4_shr = mat4_mul_add(vec3(.5, .5, 1.), vec3(4./8., 3./8., 0.)) * mat4_rotx_sc(+1., +0.) * mat4_rotz_sc(+sin_a, +cos_a);\n\tconst mat4 mat4_sil = mat4_mul_add(vec3(.5, .5, 1.), vec3(1./8., 2./8., 0.)) * mat4_roty_sc(+1., +0.) * mat4_rotz_sc(+cos_b, +sin_b);\n\tconst mat4 mat4_sir = mat4_mul_add(vec3(.5, .5, 1.), vec3(7./8., 2./8., 0.)) * mat4_roty_sc(-1., +0.) * mat4_rotz_sc(-cos_b, +sin_b);\n\tconst mat4 mat4_su0 = mat4_mul_add(vec3(.5, .5, 1.), vec3(2./8., 6./8., 0.)) * mat4_roty_sc(+0., +1.) * mat4_rotx_sc(+cos_c, +sin_c);\n\tconst mat4 mat4_su1 = mat4_mul_add(vec3(.5, .5, 1.), vec3(6./8., 6./8., 0.)) * mat4_roty_sc(+0., -1.) * mat4_rotx_sc(-cos_c, +sin_c);\n    // texture border\n    const vec2 bo_lo  = vec2(1./4., 0./4.);\n    const vec2 bo_hi  = vec2(3./4., 1./4.);\n    const vec2 shl_lo = vec2(1./4., 1./4.);\n    const vec2 shl_hi = vec2(2./4., 2./4.);\n    const vec2 shr_lo = vec2(2./4., 1./4.);\n    const vec2 shr_hi = vec2(3./4., 2./4.);\n    const vec2 sil_lo = vec2(0./4., 0./4.);\n    const vec2 sil_hi = vec2(1./4., 2./4.);\n    const vec2 sir_lo = vec2(3./4., 0./4.);\n    const vec2 sir_hi = vec2(4./4., 2./4.);\n    const vec2 su0_lo = vec2(0./4., 2./4.);\n    const vec2 su0_hi = vec2(2./4., 4./4.);\n    const vec2 su1_lo = vec2(2./4., 2./4.);\n    const vec2 su1_hi = vec2(4./4., 4./4.);\n    // texture height multiplyer\n\tconst float heightMul = .02;\n    const float heightMul_ = max(heightMul, 0.);\n    // boundbox cut\n    const vec3 boundLimen = vec3_zero + heightMul_ + .125;   \n    vec3 bound = abs(p) - g;\n    if (any(greaterThan(bound, boundLimen))) return vec4(0., 0., 0., length(max(bound - heightMul_, 0.)));\n    \n    // pos coord negative/positive boolvector\n    bvec3 posp = greaterThanEqual(p, vec3_zero);\n    \n\t// Bottom\n\tvec4 bo = mat4_bo * vec4(p + vec3(0., g.y, 0.), 1.);\n    vec2 bo_xy = clamp(bo.xy, bo_lo, bo_hi);\n\tfloat bo_z = bo.z + texture(iChannel1, bo_xy).x * -heightMul;\n\t// Shoulder\n   \tvec4 sh = posp.x ? \n\t\tmat4_shr * vec4(p + vec3(0., -g.y, 0.), 1.):\n\t\tmat4_shl * vec4(p + vec3(0., -g.y, 0.), 1.); \n    vec2 sh_xy = posp.x ? clamp(sh.xy, shr_lo, shr_hi) : clamp(sh.xy, shl_lo, shl_hi);\n\tfloat sh_z = sh.z + texture(iChannel1, sh_xy).x * -heightMul;\n\t// Side\n\tvec4 si = posp.x ? \n\t\tmat4_sir * vec4(p + vec3(+g.y * cot_b - g.x, 0., 0.), 1.): \n\t\tmat4_sil * vec4(p + vec3(-g.y * cot_b + g.x, 0., 0.), 1.);\n    vec2 si_xy = posp.x ? clamp(si.xy, sir_lo, sir_hi) : clamp(si.xy, sil_lo, sil_hi);\n\tfloat si_z = si.z + texture(iChannel1, si_xy).x * -heightMul;\n\t// Surface\n\tvec4 su = posp.z ? \n\t\tmat4_su0 * vec4(p + vec3(0., 0., +g.y * cot_c - g.z), 1.):\n\t\tmat4_su1 * vec4(p + vec3(0., 0., -g.y * cot_c + g.z), 1.);\n    vec2 su_xy = posp.z ? clamp(su.xy, su0_lo, su0_hi) : clamp(su.xy, su1_lo, su1_hi);\n\tfloat su_z = su.z + texture(iChannel1, su_xy).x * -heightMul;\n\n    float max_z = max(max(bo_z, sh_z), max(si_z, su_z));\n    if (max_z == bo_z) return vec4(texture(iChannel0, bo_xy).xyz, max_z);\n    if (max_z == sh_z) return vec4(texture(iChannel0, sh_xy).xyz, max_z);\n    if (max_z == si_z) return vec4(texture(iChannel0, si_xy).xyz, max_z);\n    return vec4(texture(iChannel0, su_xy).xyz, max_z);\n    \n}\n\nvec4 distanceHub(vec3 p) {\n    // position\n    const vec3 p_k  = vec3(+1., -.5, 0.); // King\n    const vec3 p_rb = vec3( 0., -.5, 0.); // Rook, Bishop\n    const vec3 p_gs = vec3(-1., -.5, 0.); // Gold, Silver\n    const vec3 p_n  = vec3(+1., +.5, 0.); // kNight\n    const vec3 p_l  = vec3( 0., +.5, 0.); // Lance\n    const vec3 p_p  = vec3(-1., +.5, 0.); // Pawn\n    // half height/width/thick (square height = 1.)\n    const vec3 g_k  = vec3(.371, .413, .125); // King\n\tconst vec3 g_rb = vec3(.358, .400, .120); // Rook, Bishop\n\tconst vec3 g_gs = vec3(.345, .387, .114); // Gold, Silver\n\tconst vec3 g_n  = vec3(.329, .374, .107); // kNight\n\tconst vec3 g_l  = vec3(.303, .362, .103); // Lance\n\tconst vec3 g_p  = vec3(.291, .349, .100); // Pawn\n    // rotate\n\tfloat cos_x = cos(iTime * 0.4);\n\tfloat sin_x = sin(iTime * 0.4);\n\tfloat cos_z = cos(iTime * 1.0);\n\tfloat sin_z = sin(iTime * 1.0);\n    // rotate matrix\n\tmat3 m =\n\t\tmat3(cos_z, -sin_z, 0., sin_z, cos_z, 0., 0., 0., 1.) *\n\t\tmat3(1., 0., 0., 0., cos_x, sin_x, 0., -sin_x, cos_x);\n    // distance\n    vec4 d[6] = vec4[](\n        sdPiece(m * (p + p_k ), g_k ), // King\n\t\tsdPiece(m * (p + p_rb), g_rb), // Rook, Bishop\n\t\tsdPiece(m * (p + p_gs), g_gs), // Gold, Silver\n\t\tsdPiece(m * (p + p_n ), g_n ), // kNight\n        sdPiece(m * (p + p_l ), g_l ), // Lance\n\t\tsdPiece(m * (p + p_p ), g_p )  // Pawn\n    );\n    vec4 d_min = d[0];\n    \n    for(int i = 1; i < 6; i++) {\n        if(d_min.w > d[i].w) {\n        \td_min = d[i];\n        }\n    }\n    \n    return d_min;\n}\n\nvec3 genNormal(vec3 p) {\n\tconst float d = .001;\n    const vec3 xp = vec3(+d, 0., 0.);\n    const vec3 yp = vec3(0., +d, 0.);\n    const vec3 zp = vec3(0., 0., +d);\n    const vec3 xn = vec3(-d, 0., 0.);\n    const vec3 yn = vec3(0., -d, 0.);\n    const vec3 zn = vec3(0., 0., -d);\n\treturn normalize(vec3(\n\t\tdistanceHub(p + xp).w - distanceHub(p + xn).w,\n\t\tdistanceHub(p + yp).w - distanceHub(p + yn).w,\n\t\tdistanceHub(p + zp).w - distanceHub(p + zn).w\n\t));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tconst vec3 light = normalize(vec3(-.5, .5, 1.));\n\tvec2 p = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n\tvec3 cPos = vec3(0., 0.,  2.3);\n\tvec3 cDir = vec3(0., 0., -1.0);\n\tvec3 cUp  = vec3(0., 1.,  0.0);\n\tvec3 cSide = cross(cDir, cUp);\n\tfloat targetDepth = 1.;\n\tvec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n\tvec4 dist;\n\tfloat rLen = 0.;\n\tvec3 rPos = cPos;\n\tfor(int i = 0; i < 12; ++i){\n\t\tdist = distanceHub(rPos);\n\t\trLen += dist.w;\n\t\trPos = cPos + ray * rLen;\n\t}\n\tfor(int i = 0; i < 64; ++i){\n        vec4 prevDist = dist;\n\t\tdist = distanceHub(rPos);\n        float d = abs(dist.w);\n        if(d > 1. || d < .001) { break; }\n        if (prevDist.w * dist.w < 0.) {\n        \tfloat lb = rLen - prevDist.w;\n            float hb = rLen;\n            rLen = rLen - .5 * prevDist.w;\n            rPos = cPos + ray * rLen;\n            for (i = 0; i < 32; ++i) {\n                dist = distanceHub(rPos);\n                if (abs(dist.w) < .001) { break; }\n                if (prevDist.w * dist.w < 0.) {\n                    hb = rLen;\n                } else {\n                    lb = rLen;\n                }\n                rLen = .5 * (hb + lb);\n                rPos = cPos + ray * rLen;\n            }\n            break;\n        }\n        rLen += dist.w;\n\t\trPos = cPos + ray * rLen;\n\t}\n\tif(abs(dist.w) < .001) {\n\t\tvec3 normal = genNormal(rPos);\n\t\tfloat diff = max(dot(normal, light), .2);\n\t\tfragColor = vec4(dist.xyz * diff, 1.);\n\t} else {\n\t\tfragColor = vec4(.2, .6, .3, 1.);\n\t}\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// generate diffuse texture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    vec4 c_0 = texture(iChannel0, xy);\n    vec4 c_1 = texture(iChannel1, xy * .5 + 1./32.);\n    fragColor = c_1.x > .9 ? vec4(1., 1., 1., 1.) : c_0;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// generate height map\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    vec4 c0 = texture(iChannel0, xy)*.5;\n    vec4 c1 = texture(iChannel1, xy * .5 + 1./32.);\n    fragColor = max(c0, c1);\n}","name":"Buf B","description":"","type":"buffer"}]}