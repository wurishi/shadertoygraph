{"ver":"0.1","info":{"id":"ddyyRV","date":"1696316858","viewed":40,"name":"Gradient filter","username":"Masterchef365","description":"Gradient filter for toony effect","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gradient","demo","cubic","interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Cubic interpolation demo\" by Masterchef365. https://shadertoy.com/view/ddccD4\n// 2023-10-03 07:07:18\n\nvec4 cubic_interp(sampler2D img, vec2 uv) {\n    vec2 res = vec2(textureSize(img, 0).xy);\n    float coeffs[16] = float[16](\n        1./6., -1./2., 1./2., -1./6.,\n        2./3., 0., -1., 1./2.,\n        1./6., 1./2., 1./2., -1./2.,\n        0., 0., 0.0, 1./6.\n    );\n    vec2 fr = fract(uv*res);\n    ivec2 coord = ivec2(uv*res);\n    vec4 col = vec4(0);\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            vec2 t = vec2(1.);\n            vec2 B = vec2(0.);\n            for (int k = 0; k < 4; k++) {\n                B += t * vec2(coeffs[i*4+k], coeffs[j*4+k]);\n                t *= fr;\n            }\n            vec4 smp = texelFetch(iChannel0, coord + ivec2(i-1, j-1), 0);\n            col += smp * B.x * B.y;\n        }\n    }\n    return col;\n}\n\n\nvec2 gradient(sampler2D img, vec2 pt) {\n    float coeffs[16] = float[16](\n        1./6., -1./2., 1./2., -1./6.,\n        2./3., 0., -1., 1./2.,\n        1./6., 1./2., 1./2., -1./2.,\n        0., 0., 0.0, 1./6.\n    );\n    vec2 fr = fract(pt);\n    ivec2 coord = ivec2(pt);\n    vec2 grad = vec2(0.0);\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            vec2 t = vec2(1.);\n            vec2 B = vec2(0.);\n            vec2 dB = vec2(0.);\n            for (int k = 0; k < 4; k++) {\n                vec2 coeff = vec2(coeffs[i*4+k], coeffs[j*4+k]);\n                B += t * coeff;\n                dB += float(k) * pow(fr, vec2(float(k)-1.)) * coeff;\n                t *= fr;\n            }\n            float smp = texelFetch(img, coord + ivec2(i-1, j-1), 0).x;\n            grad += smp * (dB.xy * B.yx);\n        }\n    }\n    return grad;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv /= 1.;\n    uv += vec2(0.0, 0.0);\n    \n    vec2 res = vec2(textureSize(iChannel0, 0).xy);\n\n    // Time varying pixel color\n    vec3 col;\n    \n    col = cubic_interp(iChannel0, uv).rgb;\n\n    \n    vec2 v = gradient(iChannel0, uv*res);\n    col -= vec3(length(v)>abs(fract(-iTime/10.)-0.5)*2./5.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}