{"ver":"0.1","info":{"id":"cssfz4","date":"1688520838","viewed":179,"name":"Sobel Angle","username":"Sasquatch5","description":"Output the angle of the vector created by the sobel filter applied separately to each channel","likes":1,"published":1,"flags":2,"usePreview":0,"tags":["webcam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nfloat casin(float x) {\n\tfloat negate = float(x < 0.0);\n\tx = abs(x);\n\tfloat ret = -0.0187293;\n\tret *= x;\n\tret += 0.0742610;\n\tret *= x;\n\tret -= 0.2121144;\n\tret *= x;\n\tret += 1.5707288;\n\tret = 3.14159265358979*0.5 - sqrt(1.0 - x)*ret;\n\treturn ret - 2.0 * negate * ret;\n}\n\nfloat atan2(float y, float x) {\n \tfloat absx, absy, val;\n \n     if (x == 0.0 && y == 0.0) {\n \t\treturn 0.0;\n \t}\n \tabsy = y < 0.0 ? -y : y;\n \tabsx = x < 0.0 ? -x : x;\n \tif (absy - absx == absy) {\n \t\treturn y < 0.0 ? -3.1415*2.0 : 3.1415*2.0;\n \t}\n    \n    if (absx - absy == absx) {\n\t\tval = 0.0;\n    } else {\n        val = casin((y/x)/sqrt(1.0+((y/x)*(y/x))));\n    }\n \tif (x > 0.0) {\n \t\treturn val;\n \t}\n \tif (y < 0.0) {\n\t\treturn val - 3.1415;\n \t}\n \treturn val + 3.1415;\n}\nvec4 atan2(vec4 y, vec4 x){\n\n    return vec4(atan2(y.x, x.x), atan2(y.y, x.y), atan2(y.z, x.z), atan2(y.w, x.w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x = iResolution.x - fragCoord.x - 1.0;\n    \n    const int[] sobelKernelX = int[25] (\n\n        2, 2, 4, 2, 2,\n        1, 1, 2, 1, 1,\n        0, 0, 0, 0, 0,\n        -1, -1, -2, -1, -1,\n        -2, -2, -4, -2, -2\n    );\n\n    const int[] sobelKernelY = int[25] (\n\n        2, 1, 0, -1, -2,\n        2, 1, 0, -1, -2,\n        4, 2, 0, -2, -4,\n        2, 1, 0, -1, -2,\n        2, 1, 0, -1, -2\n    );\n\n    const vec2[] kernelPositions = vec2[25] (\n        vec2(-2, -2), vec2(-1, -2), vec2(0, -2), vec2(1, -2), vec2(2, -2),\n        vec2(-2, -1), vec2(-1, -1), vec2(0, -1), vec2(1, -1), vec2(2, -1),\n        vec2(-2, 0), vec2(-1, 0), vec2(0, 0), vec2(1, 0), vec2(2, 0),\n        vec2(-2, 1), vec2(-1, 1), vec2(0, 1), vec2(1, 1), vec2(2, 1),\n        vec2(-2, 2), vec2(-1, 2), vec2(0, 2), vec2(1, 2), vec2(2, 2)\n    );\n    vec4 xGradient;\n    vec4 yGradient;\n    for (int i = 0; i < 25; i++)\n    {\n        vec4 color = texture(iChannel0,(fragCoord + kernelPositions[i] * 2.0)/iResolution.xy);\n        xGradient += color * float(sobelKernelX[i]);\n        yGradient += color * float(sobelKernelY[i]);\n    }\n\n    vec4 gradientAngle = atan2(yGradient, xGradient);\n    gradientAngle = (gradientAngle + PI) / (2.0 * PI);\n    fragColor = gradientAngle;\n}","name":"Image","description":"","type":"image"}]}