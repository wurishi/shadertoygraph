{"ver":"0.1","info":{"id":"lsjyWV","date":"1493914740","viewed":141,"name":"Statue","username":"ocdy1001","description":"ok","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VIEW_DIST 200.0\n\nstruct Material{\n    vec3 albedo;\n    vec2 specular;\n    vec3 specularColour;\n    float reflection;\n};\n\nMaterial matWhite = Material(vec3(0.9, 0.9, 0.9), vec2(1.0, 0.0), vec3(1.0), 0.0);\nMaterial matGlossy = Material(vec3(0.2, 0.2, 0.7), vec2(16.0, 3.0), vec3(1.0), 0.1);\nMaterial matBrown = Material(vec3(0.2, 0.1, 0.05), vec2(16.0, 1.0), vec3(1.0), 0.0);\n\nMaterial matGold = Material(vec3(1.0, 1.0, 1.0), vec2(128.0, 8.0), vec3(0.6, 0.6, 0.1), 0.5);\nMaterial matMirror = Material(vec3(1.0), vec2(256.0, 1.0), vec3(1.0), 1.0);\n    \nfloat sdfSphere(vec3 point, vec3 pos, float radius){\n    return length(point - pos) - radius;\n}\n\nfloat sdfPlane(vec3 point, float down){\n\treturn point.y - down;\n}\n\nfloat sdfBox(vec3 point, vec3 pos, vec3 size)\n{\n  return length(max(abs(point-pos)-size*0.5,0.0));\n}\n\nfloat sdfEllipsoid(vec3 p, vec3 pos, vec3 r)\n{\n    p -= pos;\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdfUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat sdfSubtract( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdfIntersect( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdfBlend(float d1, float d2, float k)\n{\n    return smin( d1, d2, k);\n}\n\n\nfloat sHead(vec3 point, vec3 pos){\n    point -= pos;\n    float p0 = sdfSphere(point, vec3(0.0, 1.0, 0.0), 1.0);\n    float p1 = sdfBox(point, vec3(0.0, -0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    return sdfBlend(p0, p1, 1.0);\n}\n\nfloat sBody(vec3 point, vec3 pos){\n\tpoint -= pos;\n    point.z *= 1.3;\n    float p0 = sdfBox(point, vec3(0.0), vec3(1.5, 3.0, 1.0));\n    float p1 = sdfSphere(point, vec3(0.0), 1.0);\n    return sdfBlend(p0, p1, 1.5);\n}\n\nfloat sdfStatue(vec3 point, vec3 pos){\n    float res = 0.0;\n    point -= pos;\n    \n    float head = sHead(point/0.7, vec3(0.0, 2.8, 0.0)) * 0.7;\n    float body = sBody(point, vec3(0.0, 0.0, 0.0));\n    float arm0 = sdfEllipsoid(point, vec3(+1.5, +1.1, 0.0), vec3(2.2, 0.3, 0.3));\n    float arm1 = sdfEllipsoid(point, vec3(-1.5, +1.1, 0.0), vec3(2.2, 0.3, 0.3));\n    float leg1 = sdfEllipsoid(point, vec3(+0.6, -2.5, 0.0), vec3(0.5, 2.5, 0.5));\n    float leg2 = sdfEllipsoid(point, vec3(-0.6, -2.5, 0.0), vec3(0.5, 2.5, 0.5));\n    float legs = sdfUnion(leg1, leg2);\n    \n    res = sdfBlend(head, body, 0.5);\n    res = sdfBlend(res, arm0, 0.5);\n    res = sdfBlend(res, arm1, 0.5);\n    res = sdfBlend(res, legs, 0.5);\n    return res;\n}\n\n#define SHAPES 1\nvec2 getSDF(vec3 point){\n    vec2 shapes[SHAPES];\n    shapes[0] = vec2(sdfStatue(point, vec3(0.0, 1.0, 0.0)), 3.0);\n    float minf = VIEW_DIST * 10.0;\n    vec2 res = shapes[0];\n    for(int i = 1; i < SHAPES; i++){\n        if(shapes[i].x < res.x){\n        \tminf = shapes[i].x;\n            res = shapes[i];\n        }\n    }\n    return res;\n}\n\nvec2 intersect(vec3 ro, vec3 rd){\n    for(float t = 0.0; t < VIEW_DIST;){\n        vec2 closest = getSDF(ro + t*rd);\n        if(closest.x < 0.001) return vec2(t, closest.y);\n        t += closest.x;\n    }\n    return vec2(0.0);\n}\n\nvec3 calcNormal(vec3 pos){\n \tvec3 e = vec3(0.001, 0.0, 0.0);\n    vec3 n;\n    n.x = getSDF(pos + e.xyy).x - getSDF(pos - e.xyy).x;\n    n.y = getSDF(pos + e.yxy).x - getSDF(pos - e.yxy).x;\n    n.z = getSDF(pos + e.yyx).x - getSDF(pos - e.yyx).x;\n    return normalize(n);\n}\n\nfloat calcShadow(vec3 ro, vec3 rd, float ldits){\n\tfloat res = 1.0;\n    ro += rd * 0.1;\n    for(float t = 0.1; t < ldits;){\n    \tfloat h = getSDF(ro + t*rd).x;\n        if(h < 0.001) return 0.0;\n        res = min( res, 8.0*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat calcAmbientOcclusion(vec3 pos, vec3 nor)\n{\n\tfloat stepSize = 0.01f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tfloat d = getSDF(pos + nor * t).x;\n\t\toc += t - d;\n\t\tt += stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc, 0.0, 1.0);\n}\n\nvec3 calcShading(vec3 pos, vec3 nor, vec3 camdir, vec3 lightpos, Material mat){\n    vec3 lightDifference = lightpos - pos;\n    vec3 lightdir = normalize(lightDifference);\n    float ambientL = 0.01;\n    float diffuseL = dot(nor, lightdir);\n    float shadowL = calcShadow(pos, lightdir, length(lightDifference));\n\t\n    vec3 reflectdir = reflect(lightdir, nor);\n    float specangle = max(dot(reflectdir, camdir), 0.0);\n    float specularL = pow(specangle, mat.specular.x/4.0)*mat.specular.y;\n    \n    return vec3(ambientL + specularL + diffuseL*shadowL) * mat.albedo * mat.specularColour;\n}\n\nvec3 calcReflection(vec3 surfpos, vec3 surfnor, vec3 camdir, vec3 lightpos){\n    Material material;\n    vec2 inter = intersect(surfpos + (surfnor*0.01), surfnor);\n    if(inter.y > 0.5){\n        vec3 pos = surfpos + inter.x*surfnor;\n        vec3 nor = calcNormal(pos);\n        \n        if(inter.y == 1.0) material = matWhite;\n        else if(inter.y == 2.0) material = matGlossy;\n        else if(inter.y == 3.0) material = matGold;\n        else if(inter.y == 4.0) material = matBrown;\n        else if(inter.y == 5.0) material = matMirror;\n        \n        return calcShading(pos, nor, camdir, lightpos, material);\n    }\n    return texture( iChannel0, surfnor ).xyz;\n}\n\nvec3 calcMaterial(vec3 pos, vec3 nor, vec3 camdir, vec3 lightpos, Material mat){\n    vec3 lightDifference = lightpos - pos;\n    vec3 lightdir = normalize(lightDifference);\n    float ambientL = 0.01;\n    float diffuseL = dot(nor, lightdir);\n    float shadowL = calcShadow(pos, lightdir, length(lightDifference));\n\t\n    vec3 reflectdir = reflect(lightdir, nor);\n    float specangle = max(dot(reflectdir, camdir), 0.0);\n    float specularL = pow(specangle, mat.specular.x/4.0)*mat.specular.y;\n    \n    vec3 reflectL = calcReflection(pos, nor, camdir, lightpos);\n    \n    vec3 basec = mix(vec3(diffuseL), reflectL, mat.reflection);\n   \tvec3 colour = ((specularL + basec)*shadowL) + ambientL;\n    colour *= mat.albedo * mat.specularColour;\n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= -iResolution.x / iResolution.y;\n    \n    float time  = iTime * 0.5;\n    \n    vec3 campos = vec3(sin(time) * 9.0, 3.0, cos(time) * 9.0);\n    float camzoom = 1.0;\n    vec3 lookpos = vec3(0.0, 1.0, 0.0);\n    \n    vec3 lookdir = normalize(lookpos - campos);\n    vec3 right = normalize(cross( vec3(0.0, 1.0, 0.0), lookdir ));\n    vec3 up = normalize(cross(lookdir,right));\n    \n    vec3 imageplanepoint = campos + (lookdir*camzoom) + (right*uv.x) + (up*uv.y);\n    vec3 camdir = normalize(imageplanepoint - campos);\n    \n    vec3 lightpos = vec3(3.0, 4.0, 7.0) * 10.0;\n    \n    vec3 colour = texture( iChannel0, camdir ).xyz;\n    Material material;\n    \n    vec2 inter = intersect(campos, camdir);\n    if(inter.y > 0.5){\n        vec3 pos = campos + inter.x*camdir;\n        vec3 nor = calcNormal(pos);\n        \n        if(inter.y == 1.0) material = matWhite;\n        else if(inter.y == 2.0) material = matGlossy;\n        else if(inter.y == 3.0) material = matGold;\n        else if(inter.y == 4.0) material = matBrown;\n        else if(inter.y == 5.0) material = matMirror;\n        \n        colour = calcMaterial(pos, nor, camdir, lightpos, material);//*calcAmbientOcclusion(pos, nor);\n        colour = pow(colour, vec3(1.0/2.2));\n    }\n    \n\tfragColor = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}