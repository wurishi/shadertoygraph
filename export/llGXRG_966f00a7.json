{"ver":"0.1","info":{"id":"llGXRG","date":"1484770108","viewed":227,"name":"Lighting Blended Shapes","username":"twitchingace","description":"Messing around with displacement maps, blending, and normal calculation. Not entirely sure what's up with the waviness on the displacements (might be from floating points or my discrete steps). \n\nDefinitely not a faceless weezing. Don't even ask.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","phong","raymarch","displacement","lighting","blending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 eye = vec3(0,0,10);\nvec3 lightPos = vec3(10., -2., 2.);\n\nvec3 sphere1Pos = vec3(-0.6, 0., 0.);\nfloat sphere1Rad = .55;\n\nvec3 eye1Pos = vec3(-.8, -.15, .53);\nfloat eye1Rad = .1;\n\nvec3 eye2Pos = vec3(-0.35, -.13, .53);\nfloat eye2Rad = .1;\n\nvec3 sphere2Pos = vec3(0.05, 0.6, -.5);\nfloat sphere2Rad = .25;\n\nvec3 sphere3Pos = vec3(0.7, 0.1, 0.);\nfloat sphere3Rad = .4;\n\nvec3 eye3Pos = vec3(.67, 0., .4);\nfloat eye3Rad = .07;\n\nvec3 eye4Pos = vec3(1., .0, .31);\nfloat eye4Rad = .07;\n\nvec3 cylinder1Pos = vec3(-0.25, .4, -0.2);\nvec2 cylinder1Size = vec2(.075, .55);\nvec3 cylinder1Rotate = vec3(-.8, 0., -0.6);\n\nvec3 cylinder2Pos = vec3(0.3, .4, -0.2);\nvec2 cylinder2Size = vec2(.075, .35);\nvec3 cylinder2Rotate = vec3(-.7, 0., 0.7);\n\nvec3 eyebrow1Pos = vec3(-0.8, -.25, .55);\nvec2 eyebrow1Size = vec2(.045, .175);\nvec3 eyebrow1Rotate = vec3(-.05, 0., -1.3);\n\nvec3 eyebrow2Pos = vec3(-0.3, -.25, .55);\nvec2 eyebrow2Size = vec2(.045, .175);\nvec3 eyebrow2Rotate = vec3(.05, 0., 1.3);\n\nvec3 eyebrow3Pos = vec3(0.65, -.1, .45);\nvec2 eyebrow3Size = vec2(.035, .11);\nvec3 eyebrow3Rotate = vec3(-.2, 0., -1.2);\n\nvec3 eyebrow4Pos = vec3(1.05, -.1, 0.32);\nvec2 eyebrow4Size = vec2(.035, .11);\nvec3 eyebrow4Rotate = vec3(.2, 0., 1.2);\n\nconst float maxIterations = 32.;\n\nstruct mat{\n\tfloat spec;\n    float diff;\n    float amb;\n    float shiny;\n};\n\nstruct ray{\n \tvec3 position;\n    vec3 direction;\n};\n    \nmat test = mat(.3,1.1,.01,1.);\n\n/*\n * Begin utility distance functions\n */\nmat3 rotMat(vec3 rotAm) {\n    mat3 matx = mat3(vec3(1., 0., 0.),\n                      vec3(0., cos(rotAm.x), sin(rotAm.x)),\n                      vec3(0., -sin(rotAm.x), cos(rotAm.x)));\n    mat3 maty = mat3(vec3(cos(rotAm.y), 0., -sin(rotAm.y)),\n                      vec3(0., 1., 0.),\n                      vec3(sin(rotAm.y), 0., cos(rotAm.y)));\n    mat3 matz = mat3(vec3(cos(rotAm.z), sin(rotAm.z), 0.),\n                      vec3(-sin(rotAm.z), cos(rotAm.z), 0.),\n                      vec3(0., 0., 1.));\n    \n    mat3 matrix = matz * maty * matx;\n    // Transpose the matrix (we need its inverse)\n    float temp1 = matrix[1][0];\n    float temp2 = matrix[2][0];\n    float temp3 = matrix[2][1];\n    matrix[1][0] = matrix[0][1];\n    matrix[2][0] = matrix[0][2];\n    matrix[2][1] = matrix[1][2];\n    matrix[0][1] = temp1;\n    matrix[0][2] = temp2;\n    matrix[1][2] = temp3;\n    \n    return matrix;\n}\n\nfloat smin( float a, float b)\n{\n    float h = clamp( 0.5+0.5*(b-a)/0.1, 0.0, 1.0 );\n    return mix( b, a, h ) - 0.1*h*(1.0-h);\n}\n\nfloat subtract( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat distCylinder( vec3 p, vec2 h, vec3 rot)\n{\n\tp = rotMat(rot) * p;  \n\tfloat u = (.5 + atan(p.z, p.x)\n               / (2. * 3.14159)) / h.x;\n    float v = p.y / h.y + .5;\n    \n    float disp = texture(iChannel0, vec2(u * .1 + .1,v * .5 + .1)).r;\n    \n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0)) - (disp * .05);\n}\n\nfloat distFlatSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat distSphere( vec3 p, float s )\n{\n    // Standard UV wrapping for a sphere\n    float u = (.5 + atan(p.z, p.x)\n               / (2. * 3.14159)) / s / .5;\n    float v = (.5 - asin(p.y) / 3.14159) / s / .5;\n    float disp = texture( iChannel0,\n                           vec2(u,v)).r;\n    \n    // The exponential smooths out the displacement so we don't have crazy looking poles\n\treturn length(p)-s - (disp * 0.1 * (s / .5) * exp(1. - abs(p.y))/exp(1.));\n}\n\n// End utility distance functions\n\nfloat distFunc(vec3 p)\n{\n    // Basic shape\n    float d1 = distSphere(p - sphere1Pos, sphere1Rad);\n    float d2 = distSphere(p - sphere2Pos, sphere2Rad);\n    float d3 = distSphere(p - sphere3Pos, sphere3Rad);    \n    float d4 = distCylinder(p - cylinder1Pos, cylinder1Size, cylinder1Rotate);\n    float d5 = distCylinder(p - cylinder2Pos, cylinder2Size, cylinder2Rotate);\n    \n    // Eyebrows\n    float d6 = distCylinder(p - eyebrow1Pos, eyebrow1Size, eyebrow1Rotate);\n    float d7 = distCylinder(p - eyebrow2Pos, eyebrow2Size, eyebrow2Rotate);\n    float d8 = distCylinder(p - eyebrow3Pos, eyebrow3Size, eyebrow3Rotate);\n    float d9 = distCylinder(p - eyebrow4Pos, eyebrow4Size, eyebrow4Rotate);\n       \n    return smin(smin(smin(smin(smin(smin(min(min( d1, d2), d3), d4), d5), d6), d7), d8), d9);\n}\n\nfloat faceFunc(vec3 p){\n    float d1 = distFlatSphere(p - eye1Pos, eye1Rad);\n    float d2 = distFlatSphere(p - eye2Pos, eye2Rad);\n    float d3 = distFlatSphere(p - eye3Pos, eye3Rad);\n    float d4 = distFlatSphere(p - eye4Pos, eye4Rad);\n    \n    return min(min(min(d1, d2), d3), d4);\n}\n\n// Shamelessly ripped from IQ's https://www.shadertoy.com/view/Xds3zN\n// I'm honestly not quite sure how this works.\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*distFunc( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*distFunc( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*distFunc( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*distFunc( pos + e.xxx ) ) ;\n}\n\nvec3 getNormalFace( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*faceFunc( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*faceFunc( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*faceFunc( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*faceFunc( pos + e.xxx ) ) ;\n}\n\nray lookAt(in vec2 uv, in vec3 targetPoint){\n\tvec3 forward = normalize(targetPoint - eye);\n    vec3 up = vec3(0.,1.0,0.0);\n    vec3 right = cross(forward, up);\n    up = cross(forward, right);\n    vec3 ro = eye + forward * .1 + right * uv.x + up * uv.y;\n    vec3 rd = forward;\n    return ray(ro,rd);\n}\n\nvec3 rayMarch(ray marcher){\n    float epsilon = 0.001;\n    float t = 0., d, d2;\n    vec3 targetSphere = sphere1Pos;\n    float targetRad = sphere1Rad;\n    vec3 point;\n    \n    for (float i = 0.; i < maxIterations; i++){\n        point = marcher.position + marcher.direction * t;\n        \n        d = distFunc(point);\n        if (d < epsilon){\n            // Calc phong illumination\n            vec3 normal = getNormal(point);\n            vec3 light1Dir = normalize(lightPos - point);\n            vec3 viewDir = normalize(eye - point);\n            vec3 reflection1 = reflect(light1Dir, normal);\n            // Add the ambient component\n            float Ip = test.amb;\n            // Add the diffuse component\n            Ip += max(0., test.diff * dot(light1Dir, normal));\n            // Add the specular component\n            Ip += max(0., pow(test.spec * dot(reflection1, viewDir), test.shiny));\n            return Ip * vec3(.816, 0.26, .96); //getNormal(point);\n        }\n        \n        d2 = faceFunc(point);\n        if (d2 < epsilon){\n            // Calc phong illumination\n            vec3 normal = getNormalFace(point);\n            vec3 light1Dir = normalize(lightPos - point);\n            vec3 viewDir = normalize(eye - point);\n            vec3 reflection1 = reflect(light1Dir, normal);\n            // Add the ambient component\n            float Ip = test.amb;\n            // Add the diffuse component\n            Ip += max(0., test.diff * dot(light1Dir, normal));\n            // Add the specular component\n            Ip += max(0., pow(test.spec * dot(reflection1, viewDir), test.shiny));\n            return Ip * vec3(1.);\n        }\n        \n        t+=min(d, d2);\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    eye = vec3(4. * cos(iTime * .6), 4. * (sin(iTime * .25) / 2. - .5), 10. * sin(iTime * .6));\n    lightPos = vec3(6. * sin(iTime + 0.2), cos(iTime + .2) * 6., 2.);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    ray eyeRay = lookAt(uv, vec3(0)); \n\tfragColor = vec4(rayMarch(eyeRay),1.0);\n}","name":"Image","description":"","type":"image"}]}