{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec2 clip_coord()\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\treturn 2.0*aspect*gl_FragCoord.xy/iResolution.xy - aspect;\n}\n\nvec3 eye_ray(vec3 eye, vec3 look_at, vec3 eye_up, float fov){\n\t// Do as a matrix?\n\tvec3 forward = normalize(look_at - eye);\n\tvec3 right = cross(forward, normalize(eye_up));\n\tvec3 up = cross(right, forward);\n\t\n\tvec2 clip = clip_coord();\n\treturn normalize(forward + (clip.x*fov)*right + clip.y*up);\n}\n\nfloat d_sphere(vec3 v, vec3 p, float r){\n\treturn length(v - p) - r;\n}\n\nfloat d_cylinder(vec3 v, vec3 p, vec3 n, float r, float l){\n\tfloat dvn = dot(v - p, n);\n\treturn max(\n\t\tlength(v - n*dvn) - r,\n\t\tabs(dvn) - l*0.5\n\t);\n}\n\nfloat d_box(vec3 v, vec3 p, vec3 b){\n\tvec3 d = abs(v - p) - b*0.5;\n\treturn max(max(d.x, d.y), d.z);\n}\n\nfloat d_union(float d1, float d2){ return min(d1, d2); }\nfloat d_subtract(float d1, float d2){ return max(d1, -d2); }\nfloat d_intersect(float d1, float d2){ return max(d1, d2); }\n\nfloat dist(vec3 v){\n\tfloat s = 1.3;\n\tfloat r = mix(s, s*1.75, 0.5*sin(2.0*iTime) + 0.5);\n\t\n\tvec3 c = vec3(s*8.0);\n\tv = mod(v, c) - 0.5*c;\n\t\n\tfloat d = d_box(v, vec3(0), vec3(2.0*s));\n\td = d_subtract(d, d_sphere(v, vec3(0), r));\n\td = d_union(d, d_sphere(v, vec3(0), r*0.9));\n\treturn d;\n}\n\nconst float g_eps = 1e-3;\n\nvec3 grad(vec3 p){\n\treturn normalize(vec3(\n\t\tdist(p + vec3(g_eps,0,0)) - dist(p - vec3(g_eps,0,0)),\n\t\tdist(p + vec3(0,g_eps,0)) - dist(p - vec3(0,g_eps,0)),\n\t\tdist(p + vec3(0,0,g_eps)) - dist(p - vec3(0,0,g_eps))\n\t));\n}\n\nconst int iterations = 16;\nconst float threshold = 1e-3;\nconst float min_step = 1e-4;\nconst float step_fraction = 0.9;\n\nstruct Hit {\n\tvec3 p, n;\n\tfloat d;\n};\n\nHit raymarch(vec3 eye, vec3 ray){\n\tfloat dsum = 0.0;\n\tfor(int i=0; i<iterations; i++){\n\t\tvec3 p = eye + dsum*ray;\n\t\tfloat dmin = dist(p);\n\t\tif(dmin < threshold){\n\t\t\treturn Hit(p, grad(p), dsum);\n\t\t} else {\n\t\t\tdsum += max(min_step, dmin*step_fraction);\n\t\t}\n\t}\n\t\n\tvec3 p = eye + dsum*ray;\n\treturn Hit(p, grad(p), dsum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n\tvec3 eye = -3.0*normalize(vec3(-cos(t), cos(0.5*t), -sin(t)));\n\tvec3 look_at = vec3(0);\n\tvec3 up = vec3(0,sin(t),cos(t));\n\t\n\tvec3 ray = eye_ray(eye, look_at, up, 1.0);\n\tHit hit = raymarch(eye, ray);\n\tvec3 color = abs(hit.n);\n\t\n\tvec3 light_dir = normalize(vec3(1,1,1));\n\tfloat diff = dot(light_dir, hit.n);\n\t\n\t// Uh... not sure if this is correct, but looks neat\n\tfloat spec = pow(dot(reflect(ray, hit.n), light_dir), 40.0);\n\tfloat light = 0.8*diff + spec + 0.2;\n\tcolor *= light;\n\t\n\tvec3 fog_color = abs(ray);\n\tcolor = mix(color, fog_color, hit.d/100.0);\n\t\n\tfragColor = vec4(color, 0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldf3DS","date":"1378166521","viewed":335,"name":"Glorious Rainbows.","username":"slembcke","description":"More fun with raymarching, some shading and colored fog. I also decided I rather liked the look when the iteration count was turned down.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","trippy"],"hasliked":0,"parentid":"","parentname":""}}