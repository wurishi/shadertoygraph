{"ver":"0.1","info":{"id":"XXd3W8","date":"1716415930","viewed":77,"name":"Ocean Water (kinda)","username":"pedro_ocm","description":"rough simulation of ocean water.\n\nlooks blocky cus layered noise function is still too simplistic, might look better with Perlin noise.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["noise","lighting","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float N21(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat smooth_noise(vec2 uv, float time) {\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    \n    bl = sin(bl * time)*0.5 + .5;\n    br = sin(br * time)*0.5 + .5;\n    tl = sin(tl * time)*0.5 + .5;\n    tr = sin(tr * time)*0.5 + .5;\n    \n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    \n    return (mix(b, t, lv.y));\n}\n\nfloat layered_noise(vec2 uv, float time) {\n    float att = 0.5;\n    float c = smooth_noise(uv*1., time);\n    c += smooth_noise(uv*2., time)*.5*att;\n    c += smooth_noise(uv*4., time)*.25*att;\n    c += smooth_noise(uv*8., time)*.125*att;\n    c += smooth_noise(uv*17., time)*.0625*att;\n    c += smooth_noise(uv*33., time)*.0625*0.5*att;\n    c += smooth_noise(uv*64., time)*.0625*0.5*0.5*att;\n    c += smooth_noise(uv*129., time)*.0625*0.5*att;\n    \n    return smoothstep(0.,1.0,c/2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    float time = 2.*iTime + 7.;\n    float ds = 1./iResolution.y;\n    float factor = 8.;\n    \n    vec3 c = vec3(layered_noise((uv)*factor, time));\n    fragColor = vec4(c, 1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 calc_normal(vec2 uv, float ds, float time) {\n    float factor = 6.;\n    float col_c = texture(iChannel0, (uv)).x,\n          col_r = texture(iChannel0, (uv + vec2(ds,0.))).x,\n          col_l = texture(iChannel0, (uv - vec2(ds,0.))).x,\n          col_u = texture(iChannel0, (uv + vec2(0.,ds))).x,\n          col_d = texture(iChannel0, (uv - vec2(0.,ds))).x;\n          \n    vec3 hr_t = vec3(ds, 0.0, col_r - col_c),\n         hl_t = vec3(ds, 0.0, col_c - col_l),\n         vu_t = vec3(0.0, ds, col_u - col_c),\n         vd_t = vec3(0.0, ds, col_c - col_d);\n         \n    return normalize(cross((hr_t+hl_t)/2., (vu_t+vd_t)/2.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = 2.*iTime + 7.;\n    float ds = 1./iResolution.y;\n    \n    vec3 light_dir = normalize(vec3(0.0, 0.6, -1.0));\n    vec3 view_dir  = vec3(0.0, 0.0,  1.0);\n    vec3 normal = calc_normal(uv, ds, time);\n    vec3 reflection = reflect(light_dir, normal);\n    \n    float diff = max(dot(-light_dir, normal), 0.0);\n    float spec = max(dot(reflection, view_dir), 0.0);\n    \n    vec3 col = vec3(0.1, 0.1 + 0.2*diff, 0.4 + 0.1*diff);\n    col += vec3(0.25) * spec;\n    \n    //col = mix(col, texture(iChannel0, fragCoord / iResolution.xy).rgb, 0.5);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ds = 1. / iResolution.xy;\n    fragColor  = texture(iChannel0, uv) / 4.;\n    fragColor += texture(iChannel0, uv + vec2(-ds.x, -ds.y)) / 16.;\n    fragColor += texture(iChannel0, uv + vec2(-ds.x,  ds.y)) / 16.;\n    fragColor += texture(iChannel0, uv + vec2( ds.x, -ds.y)) / 16.;\n    fragColor += texture(iChannel0, uv + vec2( ds.x,  ds.y)) / 16.;\n    fragColor += texture(iChannel0, uv + vec2(-ds.x,   0.0)) / 8.;\n    fragColor += texture(iChannel0, uv + vec2( ds.x,   0.0)) / 8.;\n    fragColor += texture(iChannel0, uv + vec2(  0.0, -ds.y)) / 8.;\n    fragColor += texture(iChannel0, uv + vec2(  0.0,  ds.y)) / 8.;\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}