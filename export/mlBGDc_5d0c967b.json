{"ver":"0.1","info":{"id":"mlBGDc","date":"1674002939","viewed":99,"name":"Ray-march shadow test","username":"ianertson","description":"Just wanted to try doing shadows while ray-marching.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","light","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define STEPS 86\n#define NEAR 0.09\n#define FAR 200.0\n#define T (iTime*0.5)\n#define AA_SAMPLES 2\n\n\n\nvec2 rot2D(vec2 p, float angle) {\n  angle = radians(angle);\n  float s = sin(angle);\n  float c = cos(angle);\n  return p * mat2(c, s, -s, c);\n}\n\nmat4 rotationX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(1, 0, 0, 0), vec4(0, c, -s, 0), vec4(0, s, c, 0),\n              vec4(0, 0, 0, 1));\n}\n\nmat4 rotationY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(c, 0, s, 0), vec4(0, 1, 0, 0), vec4(-s, 0, c, 0),\n              vec4(0, 0, 0, 1));\n}\n\nmat4 rotationZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(c, -s, 0, 0), vec4(s, c, 0, 0), vec4(0, 0, 1, 0),\n              vec4(0, 0, 0, 1));\n}\n\nvec3 rotate3D(vec3 vertex, vec3 center, vec3 axis, float angle, bool inv, inout mat4 matrix) {\n  matrix = (rotationX(angle * axis.x) * rotationY(angle * axis.y) * rotationZ(angle * axis.z));\n  matrix = inv ? inverse(matrix) : matrix;\n  return (matrix * vec4(vertex - center, 1.0)).xyz + center;\n}\n\nvec3 noise(vec3 p) {\n    vec3 a = textureLod(iChannel0, p.zx+2.0, 0.0).xyz;\n    vec3 b = textureLod(iChannel3, p.xy/2.0, 0.0).xyz;\n    vec3 c = texture(iChannel2, 0.1*((a+b)*p)).xyz;\n    vec3 d = textureLod(iChannel3, 0.01*(a+b+c).xy, 0.0).xyz;\n    \n    d = mix(d, refract(d+b, a*p, dot(normalize(p), normalize(c))), smoothstep(0.0, 1.0, a.x));\n    \n    vec3 e = reflect(p-c, (c*a*b)) + (d * 4.0);\n    \n    \n    return (a+b+c+d+e) / 2.0;\n}\n\nmat4 getRotation(vec3 p) {\n    mat4 m;\n    rotate3D(p, p - vec3(0.5), vec3(0.0, 1.0, 0.0), iTime*0.5, false, m);\n    return m;\n}\n\nfloat getDistSphere(vec3 p) {\n    vec3 pos = vec3(0.0, -1.0, 6.0);\n    pos += vec3(cos(T), sin(T)*0.5, sin(T+3.214));\n    vec4 sphere = vec4(pos, 1.0);\n   \n    mat4 rot = getRotation(p);\n    p = (rot * vec4(p, 1.0)).xyz;\n    \n    vec3 n = noise(p*0.009);\n    sphere.xyz += n*0.2;\n    sphere.xyz = (rot * vec4(sphere.xyz, 1.0)).xyz;\n   \n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat getDistGround(vec3 p) {\n    return 10.+p.y;\n}\n\n#define ENTITY_SPHERE 0\n#define ENTITY_GROUND 1\n\nfloat getDist(vec3 p, inout int entity) {\n    float sphere = getDistSphere(p);\n    float ground = getDistGround(p);\n    \n    entity = sphere < ground ? ENTITY_SPHERE : ENTITY_GROUND;\n    return min(sphere, ground);\n}\n\nfloat getDist(vec3 p) {\n    int e = 0;\n    return getDist(p, e);\n}\n\n\n\nvec2 getUv(vec3 p, vec3 normal, float dist, int e) {\n    mat4 rot = getRotation(p);\n    \n    if (e == ENTITY_GROUND) {\n        vec3 k = p/FAR;\n        \n        return (k.xz+k.y)*16.0;\n    }\n  // \n    \n    p = normal;\n     p = (rot * vec4(p, 1.0)).xyz;\n   \n    float u = atan(p.x, -p.z) / (2. * M_PI) + .5;\n    float v = p.y * .5 + .5;\n    \n    return vec2(u, v);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.02, 0.0);\n    vec3 n = normalize(getDist(p) - vec3(\n        getDist(p+e.xyy),\n        getDist(p+e.yxy),\n        getDist(p+e.yyx)\n    ));\n\n\n    \n    return normalize(n);\n}\n\n\nfloat march(vec3 ro, vec3 rd, inout int e) {\n    float dist = 0.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec3 p = ro+(rd*dist);\n       \n \n\n        float nextDist = getDist(p, e);\n        \n        dist += nextDist;\n        \n        if (dist >= FAR || dist <= NEAR) break;\n    }\n    \n    return dist;\n}\n\nfloat getOcclusion(vec3 ro, vec3 rd, float odist, inout int e) {\n    return march(ro, rd, e);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    int e = 0;\n    float dist = march(ro, rd, e);\n    Light light = Light(vec3(4.0, 9.0, -1.0), 32.8, vec3(1.0));\n \n    float ambientStrength = 0.12;\n    \n    vec3 p = ro+(rd*dist);\n    if (dist < FAR) {\n       vec3 normal = getNormal(p);\n       vec2 uv = getUv(p, normal, dist, e);\n       vec3 bump = normal;\n       \n       if (e == ENTITY_GROUND) {\n         bump = extractBump(iChannel3, uv, normal);\n       } else {\n         bump = extractBump(iChannel0, uv, normal);\n       }\n       normal = bump;\n       \n       Ray ray;\n       ray.origin = ro;\n       ray.dir = rd;\n       ray.result.normal = normal;\n       ray.result.uv = uv;\n       ray.result.dist = dist;\n       ray.result.point = p;\n       vec3 L = normalize(p - light.pos);\n       vec3 offset = (normal*0.01)+(-L*0.01);\n       int occluder = e;\n       float occlusion = getOcclusion(light.pos, L, dist, occluder);\n       \n       if (e == ENTITY_GROUND) {\n           col = PBR(ray, light, iChannel2, normal, iChannel3);\n       } else {\n           col = PBR(ray, light, iChannel2, normal, iChannel0);\n       }\n       \n       float occ = occlusion;\n       float occDepth = occ / FAR;\n       \n       if (occ > NEAR && occ < FAR && occluder != e) {\n          vec3 ocPoint = light.pos+(L*occ);\n          float distPoint = distance(p, ocPoint);\n          float distPointLight = distance(ocPoint, light.pos);\n          col /= max(1.0, (distPointLight  * 1.0 / max(0.0001, distPoint*0.1)));\n       }\n       \n      // vec3 albedo = texture(iChannel0, uv).rgb;\n      // float NdotL = max(ambientStrength, dot(normal, L));\n      // col = albedo * NdotL;\n    } else {\n        col += getBackground(iChannel2, ro, rd) / M_PI;\n    }\n    \n    float depth = dist / FAR;\n    \n\n    \n    return col;\n\n}\n\n\n\n\nvec3 controller(vec3 dir, vec4 c, vec2 res) {\n    vec2 m = ((c.xy == vec2(0.) ? vec2(.5) : (c.xy / res.xy)) * 2. - 1.) * vec2(360.,90.);\n    dir.yz = rot2D(dir.yz, m.y);\n    dir.xz = rot2D(dir.xz, m.x);\n    return normalize(dir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n   // uv.y *= -1.0;\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0.0, 0.0, 0.2);\n    vec3 rd = vec3(normalize(vec3(uv.xy, 1.0)));\n    \n    if (iMouse.z > 0.01) {\n        rd = controller(rd, iMouse, R.xy);\n        \n    } else {\n        rd = controller(rd, vec4(0.0, 190.0, 0.0, 0.0), R.xy);\n    }\n    \n    vec3 walk = texture(iChannel1, vec2(0.0)).xyz;\n    ro += walk;\n    \n    #if AA_SAMPLES\n    vec3 offset = vec3(0.0);\n    float differ = 1.0;\n    vec3 prev = vec3(0.0);\n    for (int i = 0; i < AA_SAMPLES; i++) {\n        vec3 next = render(ro+(offset*0.9), rd-(offset*1.5));\n        differ = abs(distance(next, prev));\n        prev = next;\n        col += next;\n        float v = (float(i)/float(AA_SAMPLES)) *1.6;\n        offset = (((0.008*vec3(cos(col.x*1.6), sin(col.y*1.6), tan(col.z*1.6)))\n                + (0.008*vec3(cos(v*1.6), sin(v*1.6), tan(v*1.6)))) / 2.0)*(0.5+(differ*differ));\n        offset = clamp(offset, -0.0025, 0.0025);\n    }\n    col /= float(AA_SAMPLES);\n    #else\n    col = render(ro, rd);\n    #endif\n    \n    col += (col*luma(col));\n    col = mix(col, col*col, 0.34);\n    \n    col = colorCorrect(col, 2.2);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.5 / 256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame <= 16 || iMouse.z <= 0.001) pos = vec3(0.,0., 0.0);\n    \n    float mx = iMouse.z <= 0.001 ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n    float speed = MOVE_SPEED * iTimeDelta;\n    \n    speed *= 1. + 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n\n    speed *= 3.0;\n    \n    float forwardBackward =\n\ttexture(iChannel0, vec2(KEY_W, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_S, 0.)).r;\n\n\tfloat leftRight =\n\ttexture(iChannel0, vec2(KEY_A, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_D, 0.)).r;\n\n\tfloat s = sin(radians(mx));\n\tfloat c = cos(radians(mx));\n\n\tpos.x += speed * (forwardBackward * s - leftRight * c);\n\tpos.z += speed * (forwardBackward * c + leftRight * s);\n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float M_PI = 3.14159265359;\n\nstruct Light {\n    vec3 pos;\n    float strength;\n    vec3 color;\n};\n\nstruct RayResult {\n  vec3 normal;\n  vec3 point;\n  vec2 uv;\n  float dist;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 dir;\n  RayResult result;\n};\n\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat notzero(float v) {\n  return (abs(v) <= 0.0 ? 0.001 : v);\n}\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / notzero(max( denom, 0.000001 ));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat microfacetDistribution(float roughness, float NdotH)\n{\n    float roughnessSq = roughness * roughness;\n    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n    return roughnessSq / notzero((M_PI * f * f) + 0.00001);\n}\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / notzero(denom);\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\nfloat goldness(vec3 color) {\n    vec3 gold = vec3(1.0, 0.8, 0.4);\n    float distance = length(color - gold);\n    return 1.0 - distance;\n}\n\nfloat grayness(vec3 color) {\n  float luminance = dot(vec3(0.2126, 0.7152, 0.0722), color);\n  float gray = (luminance + color.r + color.g + color.b) / 3.0;\n  return abs(luminance - gray);\n}\n\nfloat copperness(vec3 color) {\n    vec3 copper = vec3(0.9, 0.6, 0.4);\n    float distance = length(color - copper);\n    return 1.0 - distance;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = lookAtPoint;\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 getBackground(samplerCube tex, vec3 origin, vec3 dir) {\n    return texture(tex, camera(origin, dir) * vec3(0.0, 0.0, -1.0)).rgb;\n}\n\n\nvec3 extractBump(sampler2D tex, vec2 uv, vec3 normal) {\n    vec3 color = texture(tex, uv).rgb;\n    vec2 texelSize = 1.0 / vec2(textureSize(tex, 0)).xy;\n    vec3 dx = texture(tex, uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = texture(tex, uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec3 n = normalize(vec3(dy.r - dx.r, dx.g - dy.g, 0.033*0.6));\n    return mix(normal, normalize(normal+n), 0.6);\n}\n\nfloat extractRough(vec3 color, vec2 uv, sampler2D tex) {\n    float avg = pow((color.r + color.g + color.b) / 3.0, 2.0);\n    float a = max(0.0001, 1.0 - avg);\n    vec2 tsize = vec2(textureSize(tex, 0).xy);\n    vec2 texel = 1.0 / tsize;\n    vec3 left = texture(tex, uv+(texel*vec2(-1.0, 0.0))).rgb;\n    vec3 right = texture(tex, uv+(texel*vec2(-1.0, 0.0))).rgb;\n    vec3 up = texture(tex, uv+(texel*vec2(0.0, 1.0))).rgb;\n    vec3 down = texture(tex, uv+(texel*vec2(0.0, -1.0))).rgb;\n    vec3 avgAround = (left+right+up+down) / 4.0;\n    float r = (a+(distance(color, avgAround)*3.0));\n    r *= max(0.001, 1.0 - pow(0.99*luma(color), 2.0));\n    return max(0.0004, smoothstep(0.0, 1.0, r));\n}\n\nfloat extractMetallic(vec3 color) {\n    float gold = goldness(color);\n    float copper = copperness(color);\n    float gray = grayness(color);\n    return pow((gold + copper + gray) / 3.0, 2.0);\n}\nvec3 extractSpec(vec3 color) {\n    float gold = goldness(color);\n    float copper = copperness(color);\n    float gray = grayness(color);\n    vec3 goldColor = vec3(1.0, 0.8, 0.4);\n    vec3 copperColor = vec3(0.9, 0.6, 0.4);\n    vec3 grayColor = vec3(0.2126, 0.7152, 0.0722);\n    vec3 spec = ((goldColor * gold) + (copperColor * copper) + (grayColor * gray)) / 3.0;\n    spec += (((vec3(1.0) - color) / M_PI) + luma(color)) / (M_PI*2.0);\n    return smoothstep(0.0, 1.0, pow(spec, vec3(2.1)));\n}\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\nvec3 reinhard2(vec3 x) {\n  const float L_white = 4.0;\n\n  return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\nvec3 gammaCorrect(vec3 color, float gamma) {\n  return pow(color, vec3(1.0 / gamma));\n}\n\nvec3 colorCorrect(vec3 color, float gamma) {\n  color =  max(color, vec3(0.0));\n\n  color  = mix(reinhard2(color), aces(color), 0.16);\n\n  // filmic\n  //color /= max(color, vec3(0.0001)) + vec3(1.0);\n\n  color = pow(color, vec3(1.0 / gamma));\n\n  return color;\n}\n\nvec3 PBR(\n    Ray ray,\n    Light light,\n    samplerCube envtex,\n    vec3 normal,\n    sampler2D tex\n) {\n  vec3 albedo = texture(tex, ray.result.uv).rgb;\n  vec3 diffuse = albedo / M_PI;\n  vec3 col = vec3(0.0);\n  float metallic = extractMetallic(albedo);\n  float roughness = extractRough(albedo, ray.result.uv, tex);\n  vec3 spec = extractSpec(albedo);\n  vec3 f0 = mix(vec3(0.04), diffuse, smoothstep(0.0, 1.0, metallic*2.0));\n  vec3 viewdir = normalize(ray.origin - ray.result.point);\n  vec3 reflection_dir = normalize(reflect(viewdir, normal) * -1.);\n  vec3 env = texture(envtex, reflection_dir).rgb;\n  float NdotV = abs(dot(normal, viewdir)) + 0.000001;\n  vec3 envBRDF = EnvBRDFApprox(spec/M_PI, pow(roughness, 2.0), NdotV);\n  vec3 F = fresnelSchlickRoughness(NdotV, f0, roughness);\n  vec3 indirectSpecular = env * (F * envBRDF.x + envBRDF.y);\n  col += indirectSpecular;\n  float glossy = max(0.0, 1.0 - (roughness*1.1));\n  \n  // light\n  vec3 L = normalize(ray.result.point - light.pos);\n  vec3 H = normalize(L + viewdir);\n  float HdotV = clamp(dot(H, viewdir),0.000001, 1.0);\n  float NdotH = clamp(dot(normal, H), 0.000001, 1.0);\n  float NdotL = max(0.0, dot(normal, L));\n  float dist = abs(distance(ray.result.point, light.pos));\n  float att = NdotL*max(0.000001, (pow(light.strength, 2.0) / max(0.0001, pow(dist, 2.0))));\n\n  vec3 light_reflect_dir = reflect(-L, normal);\n  float VdotR = max(dot(viewdir, light_reflect_dir), 0.0);\n  float specFres = (glossy * pow(VdotR, 64.0)) / M_PI;\n  vec3 fresnel = fresnelSchlick(HdotV, f0);\n  float D = microfacetDistribution(roughness, NdotH);\n  float S = DistributionGGX(normal, H, roughness);\n  float G = GeometrySmith(normal, viewdir, L, roughness);\n  float Fsd = (4.0 * NdotV * NdotL);\n  vec3 specularity = ((fresnel * S * G * D) / notzero(Fsd)) / M_PI;\n  vec3 kd = (vec3(1.0) - specularity) * (1.0 - metallic);\n  col += (kd * diffuse + specularity + specFres) * ((light.color * att));\n  return max(vec3(0.0), col);\n}","name":"Common","description":"","type":"common"}]}