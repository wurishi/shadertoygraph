{"ver":"0.1","info":{"id":"4dccz7","date":"1518142589","viewed":89,"name":"Paw Metaballs-CIS 566","username":"jamie2719","description":"CIS 566 project 3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.15926\n\nmat4 rotate(vec3 rot) {\n\tmat4 rx = mat4(vec4(1, 0, 0, 0),\n\t\t\t\t\tvec4(0, cos(rot.x * PI/180.0), sin(rot.x * PI/180.0), 0),\n\t\t\t\t\tvec4(0, -sin(rot.x * PI/180.0), cos(rot.x * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\tmat4 ry = mat4(vec4(cos(rot.y * PI/180.0), 0, -sin(rot.y * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 1, 0, 0),\n\t\t\t\t\tvec4(sin(rot.y * PI/180.0), 0, cos(rot.y * PI/180.0), 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\tmat4 rz = mat4(vec4(cos(rot.z * PI/180.0), sin(rot.z * PI/180.0), 0, 0),\n\t\t\t\t\tvec4(-sin(rot.z * PI/180.0), cos(rot.z * PI/180.0), 0, 0),\n\t\t\t\t\tvec4(0, 0, 1, 0),\n\t\t\t\t\tvec4(0, 0, 0, 1));\n\t\t\t\t\t\n\treturn rz * ry * rx;\n\t\n}\n\nmat4 translate(vec3 trans) {\n\treturn mat4(vec4(1, 0, 0, 0),\n\t\t\t\tvec4(0, 1, 0, 0),\n\t\t\t\tvec4(0, 0, 1, 0),\n\t\t\t\tvec4(trans.x, trans.y, trans.z, 1));\n}\n\n\n\nfloat sdSphere( vec3 p, float s, vec3 trans, vec3 rot) \n{\n    \n    p = vec3(rotate(rot) * vec4(p, 1));\n    \n    \n    p = vec3(translate(trans) * vec4(p, 1));\n    \n    \n    \n  \treturn length(p)-s;\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend(float A, float B)\n{\n    return smin( A, B, .9);\n}\n\n\nfloat sceneSDF(vec3 p) {\n    vec3 Ytrans = vec3(0, clamp(-8.5 * cos(iTime*1.2), -8.4, 8.4), 0);\n    vec3 Xtrans = vec3(clamp(8.5 * cos(iTime*1.2 - 1.2), -8.4, 8.4), 0, 0);\n    vec3 LtopTrans = vec3(clamp(7.0 * (cos(iTime*1.2 -.8)), -6.9, 6.9), clamp(-7.0 * (cos(iTime*1.2 -.8)), -6.9, 6.9), 0);\n    vec3 RtopTrans = vec3(clamp(-7.0 * cos(iTime*1.2 + 1.4), -6.9, 6.9), clamp(-7.0 * cos(iTime*1.2 + 1.4), -6.9, 6.9), 0);\n    \n    \n    \n    float centerBall = sdSphere(p, 3.5, vec3(cos(iTime*1.2), sin(iTime*1.2), 0), vec3(0, 0, 0));\n    float ballY = sdSphere(p, 1.5, Ytrans, vec3(0, 0, 0));\n    float ballX = sdSphere(p, 1.5, Xtrans, vec3(0, 0, 0));\n    float ballLtop = sdSphere(p, 1.5, LtopTrans, vec3(0, 0, 0));\n    float ballRtop = sdSphere(p, 1.5, RtopTrans, vec3(0, 0, 0));\n    \n    \n    float distY = distance(vec3(translate(vec3(0, 0, 0)) * vec4(p,1)), vec3(translate(Ytrans) * vec4(p,1)));\n    float distX = distance(vec3(translate(vec3(0, 0, 0)) * vec4(p,1)), vec3(translate(Xtrans) * vec4(p,1)));\n    float distLtop = distance(vec3(translate(vec3(0, 0, 0)) * vec4(p,1)), vec3(translate(LtopTrans) * vec4(p,1)));\n    float distRtop = distance(vec3(translate(vec3(0, 0, 0)) * vec4(p,1)), vec3(translate(RtopTrans) * vec4(p,1)));\n    \n    \n    if(distY <= 7.0) {\n    \tcenterBall = opBlend(centerBall, ballY);\n    }\n    else {\n    \tcenterBall = unionSDF(centerBall, ballY);\n    }\n    \n    \n    if(distX <= 7.0) {\n    \tcenterBall = opBlend(centerBall, ballX);\n    }\n    else {\n    \tcenterBall = unionSDF(centerBall, ballX);\n    }\n    \n    \n    if(distLtop <= 7.0) {\n    \tcenterBall = opBlend(centerBall, ballLtop);\n    }\n    else {\n    \tcenterBall = unionSDF(centerBall, ballLtop);\n    }\n    \n    \n    if(distRtop <= 7.0) {\n    \tcenterBall = opBlend(centerBall, ballRtop);\n    }\n    else {\n    \tcenterBall = unionSDF(centerBall, ballRtop);\n    }\n    \n    return centerBall;\n}\n\n\n\n\nvec3 toWorldSpace(vec3 p, vec3 eye, vec3 ref) {\n\tfloat fov = 75.0;\n\n\tfloat sx = (p.x);\n    float sy = (p.y);\n    float A = iResolution.x / iResolution.y;\n    float alpha = fov / 2.0 * (3.159 / 180.0);\n    vec3 forward = normalize(ref - eye);\n   \tvec3 right = normalize(cross(vec3(0, 1, 0), forward));\n   \tvec3 localUp = normalize(cross(forward, right));\n    \n\n    //convert screen point to world point\n    float len = .1;//length(forward);\n    vec3 V = (localUp * len * tan(alpha));\n    vec3 H = right * A * len *tan(alpha);\n\n    return vec3(eye + len * forward + sx * H + sy * V); //world point \n}\n\nbool raymarch(vec3 p, vec3 eye, vec3 ref) {\n    //get ray from world point\n    vec3 dir = normalize(p - eye);\n    vec3 origin = eye;\n    \n    \n    \n    float scene;\n    vec3 intersection;\n    bool intersected = false;\n    float t = 0.01;\n\tfor (int i = 0; i < 64; i++) {\n\t\tintersection = origin + dir * t;\n\t\t\n        \n        scene = sceneSDF(intersection);\n\t\t\n\t\tif(scene <= .01) {\n\t\t\tintersected = true;\n\t\t\tbreak;\n\t\t}\n\t\tt += scene;\n\t}\n   \treturn intersected;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrPt = uv * 2.0 - 1.0; // Transform to NDC\n    scrPt *= iResolution.x / iResolution.y;\n    \n    vec3 eye =  vec3(0, 0, -8);\n    vec3 ref = vec3(0.0, 0.0, 0.0);\n    \n    \n    vec3 p = toWorldSpace(vec3(scrPt, 1), eye, ref);\n    \n    \n    vec3 col;\n    if(raymarch(p, eye, ref)) {\n        col = vec3(0, 0, 0);\n    }\n    else {\n        col = vec3(1, 1, 1);\n    }\n    \n    fragColor = vec4(col,1);\n     \n\n\n    \n}","name":"Image","description":"","type":"image"}]}