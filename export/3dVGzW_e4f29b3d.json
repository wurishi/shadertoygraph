{"ver":"0.1","info":{"id":"3dVGzW","date":"1569828677","viewed":167,"name":"Brasil :)","username":"rmmcal","description":"Draw Brasil with (Fast Fourier transform)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","fft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Created by Rodrigo Cal (twitter: @rmmcal) - 2019/09\n// fork from http://glslsandbox.com/e#55074.0\n\n//---------------------------------------------------------\n// Brasil/Amazonas/Manaus\n// \n// Created by Rodrigo Cal (twitter: @rmmcal) - 2019/06\n//\n// Next pass: _NovaArte_\n//---------------------------------------------------------\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#define time iTime\n#define mouse iMouse.xy/iResolution.xy-.5\n#define resolution iResolution.xy\n\n\n#define LEN 41\n#define len 41\n#define size 1.5 \n\nconst float PI = 3.14159265359;\nconst float PI2 = 2. * PI;\n\nstruct DFTComplex{\n  float r;\n  float i;\n  float t;\n};\nDFTComplex ca[LEN] ;\n\nDFTComplex c(float r, float i, float t){\n\tDFTComplex v;\n\tv.r = r;\n\tv.i = i;\n\tv.t = t;\t\n\treturn v;\n}\n\nvoid init(){\t\n\tca[0] = c(-0.6329559483949811, -1.0488595842806698,-1.0);ca[1] = c(-0.49948255374621375, 0.9369158120414562,1.0);ca[2] = c(-0.6323067103672072, -0.5441907696989622,-2.0);ca[3] = c(-0.6362533554013272, -0.13220919747536838,-3.0);ca[4] = c(-0.5762937298416662, 0.12925156504758234,-4.0);ca[5] = c(-0.22979496913021455, 0.2816983241141681,2.0);ca[6] = c(-0.29915233459429197, 0.010247026335414241,-5.0);ca[7] = c(-0.27950937950938, 0.030880230880230914,0.0);ca[8] = c(0.19040775210706257, 0.004958074738002877,8.0);ca[9] = c(0.1383995491552632, 0.08077843246208972,3.0);ca[10] = c(0.005459857578185791, -0.1558297107379214,-11.0);ca[11] = c(-0.0037142916006230424, -0.15229446086168164,6.0);ca[12] = c(0.06053890920412106, -0.13617696697836576,-10.0);ca[13] = c(0.06690446814038714, -0.12335010103639696,-12.0);ca[14] = c(0.06762629837005599, 0.09194074305437319,12.0);ca[15] = c(-0.1081093053438392, -0.018645043358750026,-6.0);ca[16] = c(0.06007495149417518, 0.07446984299443206,-9.0);ca[17] = c(-0.08843785949574987, -0.003641930448804574,5.0);ca[18] = c(0.06402411394769637, -0.060085668929518214,-13.0);ca[19] = c(-0.0679382570400351, -0.05001149823097401,10.0);\n\tca[20] = c(0.052102240780126506, 0.06257573580624036,4.0);ca[21] = c(0.06855693091067758, -0.03300685895479882,7.0);ca[22] = c(0.06789295384239827, 0.02517736261899032,13.0);ca[23] = c(0.06600272841878548, 0.022133103735632233,-14.0);ca[24] = c(-0.009253575756347176, 0.06622228064704673,-8.0);ca[25] = c(0.029920568135883056, 0.055807528601362226,15.0);ca[26] = c(-0.0398714425216457, 0.04285506039166637,-15.0);ca[27] = c(-0.030246768592131372, -0.043502714882258715,16.0);ca[28] = c(-0.0516090832864804, 0.0026469915692289552,-16.0);ca[29] = c(0.043786592708372936, -0.02195124742078441,11.0);ca[30] = c(-0.010378573860283805, -0.04700029455423017,14.0);ca[31] = c(0.03723006178272242, 0.020018693715879297,-7.0);ca[32] = c(-0.029873838440484277, -0.02439964059537409,-17.0);ca[33] = c(0.025814977145075954, 0.023923464880595793,21.0);ca[34] = c(0.017301113182449236, 0.023401037902531268,24.0);ca[35] = c(-0.02695494150857804, -0.002830115861937604,20.0);ca[36] = c(-0.01913015726738268, 0.014843938552800223,-18.0);ca[37] = c(0.014360162878264663, -0.019365636335833818,22.0);ca[38] = c(-0.016992829657215693, -0.014325404223202009,19.0);ca[39] = c(-0.0018534201507345981, -0.021798021522242552,-20.0);\n\tca[40] = c(-0.01195347271649415, -0.01728691352587674,23.0);\n}\n\nstruct Complex{\n  float real;\n  float imag;\n  float abs1;\n  float arg1;  \n};\n\nComplex c(float real, float imag, float abs1, float arg1){\n\tComplex v;\n\tv.real = real;\n\tv.imag = imag;\n\tv.abs1 = abs1;\n\tv.arg1 = arg1;\t\n\treturn v;\n}\n\nComplex c(float real, float imag) {\n\treturn c(real, imag, distance(real, imag), atan(imag, real));\n}\n\nComplex c(float real){\n\treturn c(real, 0.);\n}\t\n\nComplex Polar(float abs, float arg){\n\treturn c(abs * cos(arg), abs * sin(arg));\n}\n\nComplex mul(Complex a, Complex b){\n\treturn c(a.real * b.real - a.imag * b.imag, a.imag * b.real + a.real * b.imag, a.abs1 * b.abs1, a.arg1 + b.arg1);\n}\n\nvoid get(float animation, out vec4 da[len]){\n\tfloat arg = animation / 360. * PI2;\n\tvec2 v = vec2(0.);\n\tfor (int i = 0; i < len; ++i) {\n\t\tDFTComplex key1 = ca[i];\n\t\tComplex c1 = mul(mul(Polar(1., arg * key1.t), c(key1.r, key1.i)), c(size / 10.));\n\t\tv = vec2(v.x + c1.real,v.y + c1.imag);\t\t\n\t\tda[i] = vec4(v.x, v.y, c1.arg1, c1.abs1);\n\t}\n}\n\n// https://iquilezles.org/articles/distfunctions2d  \nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat sdLine2( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )+(step(0.5,mod(floor(length(pa)*100.),2.)*1000.));\n}\n// udQuad => @link https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d ){\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n///////////////////////////////////////////////////////////////\n\nvoid sphere(vec2 p0, inout float c, float r, vec2 v0,  float v) {\n\tc = max (c, 1.-smoothstep(r,r+0.15, length(p0-v0) * 2.5*v));\n}\n\n#define np 150\nvoid mainBuff(  out vec4 fragColor, in vec2 fragCoord ) {\n\tinit();\n\tvec2 tr = vec2(-0.08,0.1);\n\tvec2 p0 = (2. * gl_FragCoord.xy - resolution) / resolution.y;\n\tvec2 p1 = p0 * .4;;\n\tvec2 p2 = p1 + vec2(cos(p0.y*10.+time*10.)*.01, cos(p0.x*10.+time*10.)*.01); \n\t \n\tvec4 da[len];\n\n\tvec2 v ;\n\tfloat r = 0.01;\n \tvec3 c ;\n \n\tfloat ts = time*17.-100.;\n\tfloat tc = 1.*abs(fract(time*.01)*2.-1.);\n\tfloat len1 = tc*float(np)+1.;\n\tfor (int j = 0 ; j < np; j++)\n\t{\n\t\tif (float(j) > len1)\n\t\t\tbreak;\n\t\t\n\t\tvec2 v0 = v;\n\t\t\t\n\t\tget(ts-float(j)*2., da);\n\t\tv = da[len-1].xy-tr;\n\t\t\n\t\tif (j>0)\n\t\t{\n\t\t\tfloat a = (float(len1*.5)/float(j));\n\t\t\ta =   a*a; a =   a*a;\n\t\t\ta = clamp(0.,1.,a);\n\t\t\tc.g = max (c.g, smoothstep(r,r+0.02, .04-sdLine( p1, v0, v ))*a);\n\t\t\tc.g = max (c.g, smoothstep(r,r+0.02, .02-sdLine( p1, v0, v ))*a*8.);\n\t\t\tif(mod(float(j),19.)==0. || j <= 1)\n\t\t\t{\n\t\t\t\tc.r = max (c.r, (1.-smoothstep(r,r+0.01, length(p2-v) * 2.0))*a);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvec2 v0,v1;\n\tget(ts-0., da);\n\tfor (int i = 0; i < 20; ++i) {\n\t\tv0 = da[i].xy-tr;\n\t\tv1 = da[i+1].xy-tr;\n\t\tsphere( p1, c.b, 0.001,  v0, .4/length(v0-v1)) ;\n\t\tc.b = max (c.b, smoothstep(r,r+0.02, .02-sdLine2( p1, v0, v1 ))*.2);\n\t}\n\tsphere( p1, c.b, 0.001,  -tr, 2.) ;\n\tc.b = max (c.b, smoothstep(r,r+0.02, .02-sdLine2( p1, -tr, da[0].xy-tr ))*.2);\n\t\n\tfloat f = 0.3;\n\tfragColor  = vec4(vec3(c.r*f, (c.r+c.g)*f, c.b*2.5),1.) ;\n\t\n\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmainBuff(fragColor, fragCoord);\n}","name":"Image","description":"","type":"image"}]}