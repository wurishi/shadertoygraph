{"ver":"0.1","info":{"id":"wtBGzK","date":"1560202316","viewed":916,"name":"[twitch] Broken Space","username":"NuSan","description":"Live streamed on twitch: https://www.twitch.tv/nusan_fx\nMade originally with Kodelife","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nLive streamed on twitch: https://www.twitch.tv/nusan_fx\nMade originally with Kodelife\n\n*/\n\nfloat time=0.0;\nfloat bpm=0.0;\n\nfloat knobtime(int x) {return iTime*4.0;}\nfloat key(float x) {return clamp((sin(x*3.0 - iTime)-0.97)*100.0,0.0,1.0);}\n\n//////////// GEOMETRY ////////////\n\nfloat pi=acos(-1.0);\n\nfloat sph(vec3 p, float s) {return length(p)-s;}\nfloat cyl(vec2 p, float s) {return length(p)-s;}\nfloat boxgrid(vec3 p, vec3 s, vec3 r) {p=abs(p)-s; p=abs(max(p,p.yzx))-r; return max(p.x,max(p.y,p.z));}\nfloat boxgrid(vec3 p, float s, float r) {return boxgrid(p, vec3(s), vec3(r));}\nfloat octa(vec3 p, float s) { p=abs(p); return dot(p,normalize(vec3(0.7)))-s;}\n\n\n//////////// MORPH ////////////\n\nfloat rnd(float t) { return fract(sin(t*758.655)*352.741); }\nfloat curve(float t, float d) { t/=d; return mix(rnd(floor(t)), rnd(floor(t)+1.0), pow(smoothstep(0.0,1.0,fract(t)), 10.0)); }\n\nmat2 rot(float a) {\n    float ca=cos(a);\n    float sa=sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nmat3 rotaxis(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat noise(vec3 p) {\n    vec3 ip=floor(p);\n    p=fract(p);\n    p=smoothstep(0.0,1.0,p);\n    vec3 st=vec3(7,137,233);\n    vec4 val=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n    vec4 v=mix(fract(sin(val)*9853.241), fract(sin(val+st.x)*9853.241), p.x);\n    vec2 v2=mix(v.xz,v.yw,p.y);\n    return mix(v2.x,v2.y,p.z);\n}\n\n#define repeat(VALUE,DISTANCE) (fract((VALUE)/DISTANCE+0.5)-0.5)*DISTANCE\n#define repid(VALUE,DISTANCE) (floor((VALUE)/DISTANCE+0.5)-0.5)\n\n//////////// PALETTES ////////////\n\nfloat pulse(float t, float s) {\n    float v=smoothstep(0.0,1.0,fract(t));\n    return mix(v,1.0-v,pow(v,s));\n}\nfloat pulse(float t) { return pulse(t,8.0); }\n\nfloat ipulse(float t, float s) {\n    return 1.0-pulse(t,s);\n}\n\nfloat ipulse(float t) { return ipulse(t,8.0); }\n\nvec3 tweakcolor(vec3 col) {\n    col *= rotaxis(vec3(1), time*0.2);\n    //col = mix(vec3(dot(col, vec3(0.7))), col, 1.0);\n    col *= 0.4;\n    col *= pow(col, vec3(1.3));\n\n    return col;\n}\n\n//////////// SHADING ////////////\nfloat map(vec3 p);\n\nvec3 getnorm(vec3 p) {\n    vec2 off=vec2(0.1,0);\n    return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nfloat getao(vec3 p, vec3 n, float d) {\n    return clamp(map(p+n*d)/d,0.0,1.0);\n}\n\nfloat getsss(vec3 p, vec3 r, float d) {\n    return clamp(map(p+r*d),0.0,1.0);\n}\n\n//////////// TUNNEL ////////////\n\nvec3 tunnel(vec3 p) {\n    float t=knobtime(0)*0.1;\n    vec3 off=vec3(0);\n    off.x += sin(p.z*0.01 + t + 12.3)*60.0;\n    off.y += sin(p.z*0.012 + t)*50.0;\n    return off;\n}\n\n//////////// MAP ////////////\n\nvec2 fractal(inout vec3 p) {\n\n    float s=10.0;\n    float mm=10000.0;\n    float id=0.0;\n    for(int i=0; i<4; ++i) {\n        float t=knobtime(3)*0.2 + float(i);//curve(time, 0.3+i*0.3);;\n        p.xy *= rot(t);\n        p.yz *= rot(t*0.7);    \n        id += dot(sign(p), vec3(1,1.7,2.3));\n        p=abs(p);\n        mm=min(mm, min(p.x,min(p.y,p.z)));\n        p-=s;\n        s*=0.5;\n    }\n\n    return vec2(mm, id);\n}\n\n// KODELIFE\n\nfloat oo = 0.0;\nvec3 trp=vec3(0);\nfloat tra=0.0;\nfloat map(vec3 p) {\n\n    float tt = knobtime(0);\n    \n    vec3 bp=p;\n    \n    p.xz*=rot(time*0.1);\n    p.xy*=rot(time*0.12);\n        \n    vec2 mm = fractal(p);\n    \n    float d = abs(mm.x)-0.3;\n    float dist = rnd(mm.y);\n\n    float t1 = max(d,sph(bp, 60.0));\n    float t2 = sph(bp, 40.0 + sin(tt*0.1+dist*32.0 + pow(fract(bpm),5.0))*20.0);\n    t2 = abs(t2)-0.3;\n    t2 = max(t2, -d+0.3);\n    \n    d=min(t1, t2);\n    \n    p=bp;\n    \n    p+=tunnel(p);\n    \n    vec3 bp2 = p;\n    \n    p.xy *= rot(sin(p.z*0.01 + tt*0.1));\n    p.yz *= rot(sin(p.z*0.01 + tt*0.1)*0.3);\n    p+=noise(p*0.02)*30.0;\n    p=repeat(p, 40.0);\n    float t3 = boxgrid(p, 7.0, 0.2);\n    t3 = min(t3, cyl(p.xy, 1.0));\n    t3 = min(t3, cyl(p.yz, 1.0));\n    t3 = min(t3, max(abs(cyl(bp.xy, 100.0 + sin(tt*0.3 + bp.z*0.05)*20.0))-3.0, abs(p.z)-0.4)*0.7);\n    t3=max(t3, -cyl(bp.xy, 80.0)); \n    \n    d=min(d, t3);\n    \n    float t5=abs(octa(bp2, 120.0))-1.0;\n    t5 = max(t5, mm.x-0.2);\n    oo+=0.2/(0.2+t5);\n    d=min(d, t5);\n    \n    \n    tra=(t1<=d)?1.0:0.0;\n        \n    return d;\n}\n\nvec3 sky(vec3 r) {\n    vec3 col=vec3(0);\n    vec3 rr = abs(repeat(r,0.1))*13.0;\n    col += max(rr.z,rr.y);\n    col *= pow(abs(r.x),10.0);\n    return col;\n}\n\nvec3 raymarch(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec3 s=vec3((curve(time, 0.7)-.5)*5.0,0,-150.0);\n    vec3 t=vec3(0,0,0);\n    \n    s -= tunnel(s);\n    t -= tunnel(t);\n    \n    vec3 cz=normalize(t-s);\n    vec3 cx=normalize(cross(cz, vec3(sin(time*0.1)*0.1,1,0)));\n    vec3 cy=normalize(cross(cz, cx));\n    \n    float fov = 0.3 + pulse(bpm*0.5,20.0)*0.2;\n    vec3 r=normalize(uv.x*cx + uv.y*cy + fov*cz);\n    \n    float maxdist=300.0;\n        \n    vec3 p=s;\n    float at=0.0;\n    float dd=0.0;\n    for(int i=0; i<200; ++i) {\n        float d=map(p);\n        if(d<0.001) {\n            if(tra>0.5) {\n                //vec3 n=getnorm(p);\n                float didi = 1.0-length(p)/60.0;\n                col += vec3(0.0002*float(i)*didi,0,0);\n                d=0.2;\n            } else {\n                break;\n            }\n        }\n        if(dd>maxdist) break;\n        p+=r*d;\n        dd+=d;\n        at += (1.0-tra)*1.0/(1.0+d);\n    }\n\n    float fog = 1.0-clamp(dd/maxdist,0.0,1.0);\n    \n    vec3 n=getnorm(p);\n    vec3 l=normalize(vec3(1,3,-2));\n    vec3 h=normalize(l-r);\n    float spec=max(0.0,dot(h,n));\n    float fres=pow(1.0-abs(dot(r,n)), 3.0);\n    \n    vec3 col1 = vec3(0.7,0.8,0.6);\n    vec3 col2 = vec3(0.8,0.8,0.5)*3.0;\n    float iter = pow(abs(r.z), 7.0);\n    vec3 atmocol = mix(col1, col2, iter);\n    \n    float ao=1.0;//getao(p,n,3.0) * getao(p,n,1.5) * 3.0;\n    float sss=getsss(p,r,2.0) + getsss(p,r,10.0);\n    \n    float fade = fog * ao;\n    col += (max(0.0,dot(n,l)) * .5+.5) * 0.7 * fade * atmocol * 0.2;\n    col += max(0.0,dot(n,l)) * (0.3 + 0.6*pow(spec,4.0) + 0.9*pow(spec,30.0)) * fade * atmocol*0.7;\n    col += pow(1.0-fog,5.0) * vec3(0.7,0.5,0.2);\n    col += pow(oo*0.15,0.7)*vec3(0.5,0.7,0.3);\n    \n    col += pow(at*0.035,0.4) * atmocol;\n\n    col += key(fract(length(p)*0.02)) * vec3(0.2,1.0,fract(trp.x*0.1)) * 10.0 * fog;\n    col *= 1.8,\n\n    col = tweakcolor(col);\n    \n    col *= 1.2-length(uv);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time=iTime;\n    bpm=time*90.0/60.0;\n    vec2 uv = -0.5 + 1. * fragCoord/iResolution.xy;\n    uv.y=-uv.y;\n    uv.x *= iResolution.x/float(iResolution.y);\n\n    vec2 buv=uv;\n    \n    vec3 col=vec3(0);\n    col += raymarch(uv);\n \n    col *= 1.2-length(buv);\n  \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}