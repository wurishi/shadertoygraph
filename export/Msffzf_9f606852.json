{"ver":"0.1","info":{"id":"Msffzf","date":"1497245948","viewed":670,"name":"Bankohan","username":"amagitakayosi","description":"Trying to simulate paopei \"Bankohan\" http://www.angelfire.com/anime3/karrafear/Paopei/Bankohan.html","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n#define GLSLIFY 1\nuniform float time;\nuniform vec2  mouse;\nuniform vec2  resolution;\nconst float PI = 3.1415926535897932384626433;\n\nvec2 squareFrame(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return getRay(camMat, screenPos, lensLength);\n}\n\nvec2 map(vec3 p);\n// Originally sourced from https://www.shadertoy.com/view/ldfSWs\n// Thank you Iñigo :)\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis, float reduction) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 30; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = map(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest * reduction;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 20.0, 0.001, 1.0);\n}\n\n// Originally sourced from https://www.shadertoy.com/view/ldfSWs\n// Thank you Iñigo :)\n\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ).x +\n                    v2 * map( pos + v2*eps ).x +\n                    v3 * map( pos + v3*eps ).x +\n                    v4 * map( pos + v4*eps ).x );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 0.002);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(in vec2 v, in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\n#define NUM 1.\n\nfloat t() {\n    return iTime * .3;\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec2 sdSpheres(in vec3 p) {\n    vec3 c1 = vec3(0);\n    float d1 = length(p - c1) - 2.4;\n\n    float d = 9999.;\n\n    for (int i = 0; i < 3; i++) {\n        float fi = float(i);\n        float ti = (1. - pow(1. - fract((t() + fi * .2)), 1.5)) * 8.;\n\n        vec3 u = vec3(rotate(vec2(1, 0), (fi + 1.) * .7 * PI), 0);\n        u.xy = rotate(u.xy, (fi + 1.) * .3);\n        u.xz = rotate(u.xz, (fi * 2. + 1.) * 1.9);\n        vec3 c2 = u * ti;\n        float d2 = length(p - c2) - .7;\n\n        float a1 = max(dot(normalize(p - c1), normalize(c2 - c1)), 0.);\n        float a2 = max(dot(normalize(p - c2), normalize(c1 - c2)), 0.);\n\n        d = smoothMin(\n            d,\n            smoothMin(\n                d1 * (1.1 - pow(a1, 20.)),\n                d2 * (1.1 - pow(a2, 20.)),\n                2.2\n            ),\n            2.5\n        );\n\n        for (int j = 0; j < 5; j++) {\n            float fj = float(j);\n            float tj = (1. - pow(1. - max(ti - 5. + fj * .8, 0.) / 3., 3.)) * 4.;\n\n            vec3 uj = vec3(rotate(vec2(1, 0), (fj + 1.) * .4 * PI + 1.5 * PI), 0);\n            uj.xy = rotate(uj.xy, (fi + 1.) * 1.3);\n            uj.xz = rotate(uj.xz, (fi * 3. + 1.) * .9);\n\n            vec3 cj = c2 + uj * tj;\n            float dj = length(p - cj) - .3;\n\n            float aj1 = max(dot(normalize(p - c2), normalize(cj - c2)), 0.);\n            float aj2 = max(dot(normalize(p - cj), normalize(c2 - cj)), 0.);\n\n            d = smoothMin(\n                d,\n                smoothMin(\n                    d2 * (1.1 - pow(aj1, 10.)),\n                    dj * (1.1 - pow(aj2, 10.)),\n                    4.3\n                ),\n                3.6\n            );\n        }\n    }\n\n    return vec2(d, 0);\n}\n\nvec2 map(vec3 p) {\n    return sdSpheres(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 rayOrigin = vec3(0, 5, 10);\n    rayOrigin.xy = rotate(rayOrigin.xy, t() * 2.7);\n    rayOrigin.z = sin(t() * 1.) * 3. + 10.;\n\n    vec3 rayTarget = vec3(0, 0, 0);\n    vec3 rayDirection = getRay(rayOrigin, rayTarget, squareFrame(iResolution.xy), 1.);\n\n    vec3 lightDir = normalize(vec3(0, 2, 1.));\n    vec3 light = vec3(.4, .2, .4) * 1.6;\n    vec3 ambient = vec3(-.3, 0, -.1);\n\n    vec2 collision = calcRayIntersection(rayOrigin, rayDirection, 20., 0.001, .8);\n    if (collision.x > .5) {\n        vec3 pos = rayOrigin + rayDirection * collision.x;\n        vec3 normal = calcNormal(pos);\n        float diff = clamp(dot(lightDir, normal), 0., 1.0);\n        vec3 c = diff * light + ambient;\n        fragColor = vec4(c, 1.0);\n    }\n    else {\n        float c = 1. - length(fragCoord.xy / iResolution.xy - 0.5);\n        fragColor = vec4(c * vec3(0.7, 0.8, 1.), 1);\n    }\n}\n","name":"Image","description":"","type":"image"}]}