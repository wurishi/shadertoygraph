{"ver":"0.1","info":{"id":"tl2yWW","date":"1594939320","viewed":352,"name":"Perlin Noise Flow","username":"tsmca","description":"2500 particles moving along a periodic 2d Perlin noise-based velocity field. \nBuffer A keeps track of particles. \nB is used to centre the Perlin noise.\nC reads the particle states from buffer A and draws them.\nD contains the tileable Perlin noise.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["2d","perlin","particles","flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Stores position and velocity of particles in texture\n\nfloat dt;\n\n\nvec2 get_acc(vec2 position){\n\treturn vec2(texture(iChannel1, position).xy);\n}\n\nbool in_radius(vec2 p, vec2 center, float radius){\n    if(sqrt(pow(center.x-p.x,2.)+pow(center.y-p.y,2.)) < radius) return true;\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 m = iMouse / iResolution.xyxx;\n    if (mod(iTime, 4.) < 0.1){\n    \tfragColor = vec4(uv.xy,0,0);\n    } else {\n        if (iFrame > 3){\n            dt = mix(dt, iTimeDelta, 1.);\n            vec4 particleState = texture(iChannel0, uv);\n            vec2 position = particleState.xy;\n            vec2 velocity = particleState.zw;\n\n            vec2 acceleration = get_acc(position);\n            velocity += acceleration*dt;\n            position += acceleration*dt;\n            position = mod(position, 1.0);\n\n\n\n            fragColor = vec4(position.xy, velocity.xy);\n            if( m.z>0.0 ){\n                if(in_radius(uv.xy, m.xy, 0.025)){ \n            \t\tfragColor = vec4(uv.xy, 0,0);\n                }\n            }\n        }\n        else {\n        \tfragColor = texture(iChannel0, uv);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// just used to center the noise from Buffer D \n//\n// 1. Buffer D generates tilable perlin noise on iFrame == 0; \n// 2. Buffer B calculates mean of noise on iFrame == 1\n// 3. Buffer D recenters noise on iFrame == 2\n\nbool reset;\nfloat lodFactor = 8.0;\n\nvec4 get_mean_vector(){\n    float rMean = 0.;\n    float gMean = 0.;\n    float bMean = 0.;\n    float aMean = 0.;\n    for(float i = 0.; i < iResolution.x/lodFactor; i+=1.){\n        for (float j = 0.; j < iResolution.y/lodFactor; j+=1.){\n            vec4 rgba = textureLod(iChannel0,vec2(i,j)/(iResolution.xy/lodFactor), 2. );\n            rMean += rgba.r;\n            gMean += rgba.g;\n            bMean += rgba.b;\n            aMean += rgba.a;\n        }\n    }\n    float sum = iResolution.x/lodFactor*iResolution.y/lodFactor;\n    rMean /= sum;\n    gMean /= sum;\n    bMean /= sum;\n    aMean /= sum;   \n    return(vec4(rMean, gMean, bMean, aMean));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    reset = iFrame ==1;\n    fragColor = texture(iChannel1, uv);\n    if (!reset) return;\n \n\tfragColor = get_mean_vector();\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define EPSILON 0.0012\n#define WIDTH 50\n#define HEIGHT 50\n#define DARKEN vec4(0.005,0.005,0.005,0);\n\nvec4 get_particle_state(int x, int y){\n\treturn(texture(iChannel0, vec2(float(x)/float(WIDTH), float(y)/float(HEIGHT))));\n}\n\nvec2 get_particle_acceleration(int x, int y){\n\treturn(texture(iChannel2, vec2(float(x)/float(WIDTH), float(y)/float(HEIGHT))).xy);\n}\n\nfloat sigmoid(float x) {\n\treturn 2./(1. + exp2(-x)) - 1.;\n}\n\nbool in_vicinity(vec2 pos, vec2 coord){\n    if(pow(coord.x-pos.x,2.) + pow(coord.y-pos.y,2.) < pow(EPSILON, 2.)){\n    \treturn(true);\n    }\n    return(false);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 3){\n    \tfragColor = vec4(0.,0.,0.,1.);\n    }\n    else{\n        \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel1, uv);\n    col -= DARKEN;\n    if (col.r < 0.) col.r = 0.;\n    if (col.g < 0.) col.g = 0.;\n    if (col.b < 0.) col.b = 0.;\n\n    for(int i = 0; i < WIDTH; i ++){\n        for (int j = 0; j < HEIGHT; j++){\n        \tvec4 state = get_particle_state(i, j);\n            vec2 position = state.xy;\n            vec2 velocity = state.zw;\n            float speed = sqrt(pow(velocity.x,2.0)+pow(velocity.y,2.0));\n            vec2 acceleration = get_particle_acceleration(i, j);\n            if(in_vicinity(position, uv)){\n                float r = abs(velocity.x)/sqrt(iTime);\n                float g = abs(velocity.y)/sqrt(iTime);\n                float b = abs(acceleration.x)/10./sqrt(iTime);\n                col += vec4(hsv2rgb(vec3(mod(speed*5.+iTime/3.141592654, 1.0), 1., 1.)), 0.);\n            \tif(col.r > 1.) col.r = 1.0;\n                if(col.g > 1.) col.g = 1.0;\n            \tif(col.b > 1.) col.b = 1.0;\n  \n\n                \n                //col += vec4(r,g,b,0.);\n            }\n        } \n    }\n    fragColor = col;\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nfloat uNoiseScale = 1.0;\n\nvec2 uSeed =  vec2(3141., 2718.);\n\n#define NOISE_SCALE 1\n#define OCTAVES 16\n#define PI 3.1415\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec4 P){\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 / 7.0;\n  vec4 gy00 = floor(gx00) / 7.0;\n  vec4 gz00 = floor(gy00) / 6.0;\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 / 7.0;\n  vec4 gy01 = floor(gx01) / 7.0;\n  vec4 gz01 = floor(gy01) / 6.0;\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 / 7.0;\n  vec4 gy10 = floor(gx10) / 7.0;\n  vec4 gz10 = floor(gy10) / 6.0;\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 / 7.0;\n  vec4 gy11 = floor(gx11) / 7.0;\n  vec4 gz11 = floor(gy11) / 6.0;\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat getNoise(vec2 uv, float scale, vec2 seed) {\n  float x1 = -(uNoiseScale * scale) + seed.x;\n  float y1 = -(uNoiseScale * scale) + seed.y;\n  float x2 = (uNoiseScale * scale) + seed.x;\n  float y2 = (uNoiseScale * scale) + seed.y;\n\n  float dx = (x2-x1);\n  float dy = (y2-y1);\n\n  float dxPi = dx/(2.0*PI);\n  float dyPi = dy/(2.0*PI);\n\n  float s = uv.x;\n  float t = uv.y;\n\n  float nx = x1 + cos(s*2.0*PI)*dxPi;\n  float ny = y1 + cos(t*2.0*PI)*dyPi;\n  float nz = x1 + sin(s*2.0*PI)*dxPi;\n  float nw = y1 + sin(t*2.0*PI)*dyPi;\n\n  float r = cnoise(vec4(nx, ny, nz, nw));\n  return r + .25;\n}\n\nfloat OctavePerlin(vec2 uv, int octaves, float persistence, vec2 seed) {\n    float total = 0.0;\n    float frequency = .5;\n    float amplitude = 1.0;\n    float maxValue = 0.;  // Used for normalizing result to 0.0 - 1.0\n    for(int i=0;i<octaves;++i) {\n        total += getNoise(uv, frequency, seed) * amplitude;\n\n        maxValue += amplitude;\n\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n\n    return total/maxValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    if(iFrame == 0){\n\n    vec2 seed = uSeed;\n    float persistence = .55;\n\n    vec2 rn = seed;\n    vec2 gn = seed + PI*2.;\n    vec2 bn = seed + PI*4.;\n    vec2 an = seed + PI*6.;\n\n    float r = OctavePerlin(uv, OCTAVES, persistence, rn);\n    float g = OctavePerlin(uv, OCTAVES, persistence, gn);\n    float b = OctavePerlin(uv, OCTAVES, persistence, bn);\n    float a = OctavePerlin(uv, OCTAVES, persistence, an);\n\n\n  fragColor = vec4(r,g,b,1.0);\n    }\n    else{\n\tif (iFrame == 2){\n    \tvec4 colors = texture(iChannel0, uv);\n        vec4 means = texture(iChannel1, vec2(0,0));\n        colors -= means;\n        fragColor = colors;\n    }\n    else{\n    \tfragColor = texture(iChannel0, uv);\n    }\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}