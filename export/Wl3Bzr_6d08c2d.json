{"ver":"0.1","info":{"id":"Wl3Bzr","date":"1613278066","viewed":127,"name":"Wintergatan Marble Machine","username":"rmccampbell7","description":"The Wintergatan marble machine song, played by marbles.\nThe array lookups are slow on my GPU, something about small caches I think. Any tips on how to speed it up let me know.\nAlso check out hubbe's much better one: https://www.shadertoy.com/view/lslfWn","likes":8,"published":1,"flags":8,"usePreview":0,"tags":["music","marble","wintergatan","marblemachine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 1\n// Change this if the marbles are out of sync with the music\n#define DELAY .0\n\n#define clamp01(x) clamp(x, 0., 1.)\n\nstruct DistId {\n    float dist;\n    int matId;\n};\n\nstruct Material {\n    vec3 diff_color;\n    vec3 spec_color;\n    float shininess;\n    float reflectivity;\n};\n\n\nfloat sdPlane(vec3 pos, vec3 norm, float d) {\n    return abs(dot(pos, norm) - d);\n}\n\nfloat sdSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat sdBox(vec3 pos, vec3 bounds) {\n    return length(max(abs(pos) - bounds, 0.));\n}\n\n\nfloat opUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat opIntersect(float a, float b) {\n    return max(a, b);\n}\n\nfloat opSubtract(float a, float b) {\n    return max(a, -b);\n}\n\nDistId opUnion(DistId a, DistId b) {\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\n\nMaterial getMaterial(int matId) {\n    switch (matId) {\n    case 0: // Floor\n        return Material(vec3(.1), vec3(.25), 10., .5);\n    case 1: // Marble\n        return Material(vec3(.6), vec3(1.), 20., 1.);\n    default:\n        return Material(vec3(0), vec3(0), 0., 0.);\n    }\n}\n\nDistId map(vec3 pos) {\n    // Draw floor\n    DistId res = DistId(sdPlane(pos, vec3(0,1,0), -.5), 0);\n    // Draw marbles\n    int n = int(iTime / dt);\n    for (int i = -3; i < 3; i++) {\n        if (n - i < 0) break;\n        int ni = (n - i) % NUM_NOTES;\n        float ti = iTime - float(n - i)*dt - DELAY;\n        for (int ch = 0; ch < NUM_CHANNELS; ch++) {\n            //int note = (4*(ch-1) + 79) * int(ni % 2==0);\n            int note = getNote(ch, ni);\n            if (note > 0) {\n                float x = float(note - 79);\n                float y = ti < 0. ? -10.*ti*(ti+3.) : -10.*ti*(ti-1.);\n                float z = ti < 0. ? 0. : 10.*ti;\n                res = opUnion(res, DistId(sdSphere(pos - vec3(x,y,z), .5), 1));\n            }\n        }\n    }\n    return res;\n}\n\n\nDistId castRay(vec3 origin, vec3 dir) {\n    float minDist = 1.;\n    float maxDist = 100.;\n\n    float t = minDist;\n    int matId = -1;\n    for (int i=0; i<128; i++) {\n        float eps = 1e-4*t;\n        DistId res = map(origin + dir*t);\n        matId = res.matId;\n        if (res.dist < eps || t > maxDist) break;\n        t += res.dist;\n    }\n    if (t > maxDist)\n        matId = -1;\n    return DistId(t, matId);\n}\n\n\nfloat softshadow(vec3 ro, vec3 rd) {\n    float res = 1.0;\n    for (float t=1.; t<10.;) {\n        float h = map(ro + rd*t).dist;\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, 8.*h/t);\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 1e-3;\n    return normalize(e.xyy * map(pos + e.xyy).dist +\n                     e.yxy * map(pos + e.yxy).dist +\n                     e.yyx * map(pos + e.yyx).dist +\n                     e.xxx * map(pos + e.xxx).dist);\n}\n\n\nvec3 shade2(vec3 origin, vec3 dir, float dist, int matId) {\n    vec3 pos = origin + dist*dir;\n    vec3 normal = calcNormal(pos);\n    Material mat = getMaterial(matId);\n    float ambient = .12*(1.0 + .6*normal.y);\n\n    vec3 light1 = normalize(vec3(1, 1, .75));\n    float diffuse = clamp01(dot(normal, light1));\n    float specular = pow(clamp01(dot(reflect(-light1, normal), -dir)), mat.shininess);\n\n    vec3 light2 = normalize(vec3(1, .5, -2));\n    diffuse += .8 * clamp01(dot(normal, light2));\n    specular += .8 * pow(clamp01(dot(reflect(-light2, normal), -dir)), mat.shininess);\n\n    vec3 col = clamp01(diffuse + ambient)*mat.diff_color;\n    col += clamp01(specular)*mat.spec_color;\n\n    return clamp01(col);\n}\n\nvec3 render2(vec3 origin, vec3 dir) {\n    //vec3 col = vec3(.5, .8, 1.)*(1.+1.5*dir.y);\n    vec3 col = texture(iChannel0, vec3(-dir.z,dir.yx)).rgb;\n    DistId res = castRay(origin, dir);\n    if (res.matId >= 0) {\n        col = shade2(origin, dir, res.dist, res.matId);\n    }\n    return col;\n}\n\n\nvec3 shade(vec3 origin, vec3 dir, float dist, int matId) {\n    vec3 pos = origin + dist*dir;\n    vec3 normal = calcNormal(pos);\n    Material mat = getMaterial(matId);\n    float ambient = .12*(1.0 + .6*normal.y);\n\n    vec3 light1 = normalize(vec3(1, 1, .75));\n    float shadow = softshadow(pos, light1);\n    float diffuse = clamp01(dot(normal, light1)) * shadow;\n    float specular = pow(clamp01(dot(reflect(-light1, normal), -dir)), mat.shininess) * shadow;\n\n    vec3 light2 = normalize(vec3(1, .5, -2));\n    diffuse += .8 * clamp01(dot(normal, light2));\n    specular += .8 * pow(clamp01(dot(reflect(-light2, normal), -dir)), mat.shininess);\n\n    vec3 col = clamp01(diffuse + ambient)*mat.diff_color;\n    col += clamp01(specular)*mat.spec_color;\n    \n    if (mat.reflectivity > 0.) {\n        col *= mix(vec3(1), render2(pos, reflect(dir, normal)), mat.reflectivity);\n    }\n\n    return clamp01(col);\n}\n\nvec3 render(vec3 origin, vec3 dir) {\n    //vec3 col = vec3(.5, .8, 1.)*(1.+1.5*dir.y);\n    vec3 col = texture(iChannel0, vec3(-dir.z,dir.yx)).rgb;\n    DistId res = castRay(origin, dir);\n    if (res.matId >= 0) {\n        col = shade(origin, dir, res.dist, res.matId);\n    }\n    return col;\n}\n\n\nmat3 lookAt(vec3 cameraPos, vec3 center, vec3 up) {\n    vec3 forward = normalize(center - cameraPos);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy == vec2(0) ?\n        vec2(0) : (2.*iMouse.xy - iResolution.xy) / iResolution.xy;\n\n    float r = 20.;\n    float theta = tau*(mouse.x*.5 + .25);\n    float phi = -mouse.y*tau/4.;\n    vec3 cameraPos = vec3(r*cos(theta)*cos(phi), r*sin(phi)+5., r*sin(theta)*cos(phi));\n    vec3 center = vec3(0, 5, 0);\n    mat3 cameraRot = lookAt(cameraPos, center, vec3(0, 1, 0));\n\n    float fov = 45.0;\n    float screenDist = 1. / tan(fov/2.*tau/360.);\n\n    vec3 col = vec3(0);\n    for (int i=0; i<AA; i++) {\n        for (int j=0; j<AA; j++) {\n            vec2 pix = fragCoord + vec2(i, j)/float(AA);\n            vec2 uv = (2.*pix - iResolution.xy) / iResolution.y;\n            vec3 rayDir = cameraRot * normalize(vec3(uv, screenDist));\n            col += render(cameraPos, rayDir);\n        }\n    }\n    col /= float(AA*AA);\n\n    // gamma\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float vol = .2;\n\n// from https://www.shadertoy.com/view/lslfWn\nfloat glock(float freq, float time) {\n   return sin(1.0 * tau*freq*time) * exp(-3.8 * time) / 2.0 +\n          sin(4.0 * tau*freq*time) * exp(-3.0 * time) / 4.0 +\n          sin(9.3 * tau*freq*time) * exp(-5.0 * time) / 10.0;\n}\n\nfloat beep(float f, float t) {\n    return sin(tau*f*t)*exp(-4.0*t);\n}\n\nfloat midi2freq(int note)\n{\n    return note > 0 ? 440.0 * pow(2.0, float(note - 69) / 12.0) : 0.;\n}\n\nvec2 mainSound(int samp, float time)\n{\n    int n = int(time / dt);\n    float t = mod(time, dt);\n\n    float snd = 0.0;\n\n    for (int i = 0; i < 2; i++) {\n        if (n-i < 0) break;\n        int ni = (n-i) % NUM_NOTES;\n        float ti = t + float(i)*dt;\n        for (int ch = 0; ch < NUM_CHANNELS; ch++) {\n            float freq = midi2freq(getNote(ch, ni));\n            snd += glock(freq, ti);\n        }\n    }\n\n    return vol*vec2(snd);\n}\n","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"const float bps = 5.0;\nconst float dt = 1.0/bps;\nconst int NUM_CHANNELS = 3;\n\nconst float tau = 6.2831855;\n\n// Extracted from midi file from https://www.youtube.com/watch?v=pNxP_0sEwF0\nint[] notes = int[](\n    0x000058, 0x000000, 0x4c4700, 0x000053, 0x000000, 0x000000, 0x4c4700, 0x000051,\n    0x00004f, 0x000051, 0x4c4700, 0x000053, 0x000000, 0x00004f, 0x4c4751, 0x000056,\n    0x000000, 0x000000, 0x4a4700, 0x000053, 0x000000, 0x000000, 0x4a4700, 0x000051,\n    0x00004f, 0x000051, 0x4a4700, 0x00004e, 0x000000, 0x00004f, 0x4a4751, 0x000056,\n    0x000000, 0x000000, 0x4e4a00, 0x000053, 0x000000, 0x000000, 0x4e4a00, 0x000056,\n    0x000054, 0x000053, 0x4e4a00, 0x000051, 0x000000, 0x00004f, 0x4e4a51, 0x00004c,\n    0x000000, 0x000048, 0x00004c, 0x000053, 0x000047, 0x000048, 0x00004a, 0x000056,\n    0x000054, 0x000053, 0x4e4a00, 0x000051, 0x000000, 0x00004f, 0x4e4a51, 0x000058,\n    0x000000, 0x000000, 0x4c4700, 0x000053, 0x000000, 0x000000, 0x4c4700, 0x000051,\n    0x00004f, 0x000051, 0x4c4700, 0x000053, 0x000000, 0x00004f, 0x4c4751, 0x000056,\n    0x000000, 0x000000, 0x4a4700, 0x000053, 0x000000, 0x000000, 0x4a4700, 0x000056,\n    0x000054, 0x000053, 0x4a4700, 0x000051, 0x000000, 0x00004f, 0x4a4751, 0x000056,\n    0x000000, 0x000000, 0x4e4a00, 0x000053, 0x000000, 0x000000, 0x4e4a51, 0x000058,\n    0x000000, 0x000053, 0x4a4700, 0x000051, 0x000000, 0x00004f, 0x4a474e, 0x00004c,\n    0x000000, 0x000047, 0x000048, 0x00004e, 0x000048, 0x00004c, 0x00004f, 0x00004a,\n    0x00004e, 0x000051, 0x000047, 0x000053, 0x00004a, 0x00004f, 0x000051, 0x000058,\n    0x000000, 0x000000, 0x4c4700, 0x000053, 0x000000, 0x000000, 0x4c4700, 0x000051,\n    0x00004f, 0x000051, 0x4c4700, 0x000053, 0x000000, 0x00004f, 0x4c4751, 0x000056,\n    0x000000, 0x000000, 0x4a4700, 0x000053, 0x000000, 0x000000, 0x4a4700, 0x000051,\n    0x00004f, 0x000051, 0x4a4700, 0x00004e, 0x000000, 0x00004f, 0x4a4751, 0x000056,\n    0x000000, 0x000000, 0x4e4a00, 0x000053, 0x000000, 0x000000, 0x4e4a00, 0x000056,\n    0x000054, 0x000053, 0x4e4a00, 0x000051, 0x000000, 0x00004f, 0x4e4a51, 0x00004c,\n    0x000000, 0x000048, 0x00004c, 0x000053, 0x000047, 0x000048, 0x00004a, 0x000056,\n    0x000054, 0x000053, 0x4e4a00, 0x000051, 0x000000, 0x00004f, 0x4e4a51, 0x000058,\n    0x000000, 0x000000, 0x4c4700, 0x000053, 0x000000, 0x000000, 0x4c4700, 0x000051,\n    0x00004f, 0x000051, 0x4c4700, 0x000053, 0x000000, 0x00004f, 0x4c4751, 0x000056,\n    0x000000, 0x000000, 0x4a4700, 0x000053, 0x000000, 0x000000, 0x4a4700, 0x000056,\n    0x000054, 0x000053, 0x4a4700, 0x000051, 0x000000, 0x00004f, 0x4a4751, 0x000056,\n    0x000000, 0x000000, 0x4e4a00, 0x000053, 0x000000, 0x000000, 0x4e4a51, 0x000058,\n    0x000000, 0x000053, 0x4a4700, 0x000051, 0x000000, 0x00004f, 0x4a474e, 0x00004c,\n    0x000000, 0x000047, 0x000048, 0x00004e, 0x000048, 0x00004c, 0x00004f, 0x00004a,\n    0x00004e, 0x000051, 0x000047, 0x000053, 0x00004a, 0x00004f, 0x000051, 0x000058,\n    0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,\n    0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000\n);\n\nconst int NUM_NOTES = notes.length();\n\nint getNote(int ch, int n) {\n    return (notes[n] >> (ch*8)) & 0xff;\n}\n\nfloat rand(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n","name":"Common","description":"","type":"common"}]}