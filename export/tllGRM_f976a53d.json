{"ver":"0.1","info":{"id":"tllGRM","date":"1555937014","viewed":123,"name":"concentric tori","username":"edapx","description":"Raymarching and torus","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265359\nconst int MAX_MARCHING_STEPS = 164;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 80.00;\n\nvec3 lightDirection = vec3(0.702, 0.1686, 0.6745);\n\n// https://iquilezles.org/articles/distfunctions\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat onion( in float d, in float h ){\n    return abs(d)-h;\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat bendTorus( vec3 p, vec2 dim ){\n    float wave = sin(iTime * 2.0) * 0.2;\n    float c = cos(wave*p.x);\n    float s = sin(wave*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3( p.xy*m, p.z);\n    return sdTorus(q, dim);\n}\n\nfloat bendBox( vec3 p, vec3 dim ){\n    float wave = sin(iTime * 2.0) * 0.2;\n    float c = cos(wave*p.x);\n    float s = sin(wave*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3( p.x, m*p.yz);\n    return sdBox(q, dim);\n}\n\nfloat map(vec3 pos){\n    float thick = 0.08;\n    float d = onion(bendTorus( pos.xzy, vec2(1.0,0.2) ), thick);\n    \n    d = max( d, pos.y+cos(iTime+1.2));\n    float d1 = onion(bendTorus( pos.xzy, vec2(1.1,0.5) ), thick-0.01);\n    d1 = max( d1, pos.x+sin(iTime-0.3));\n\n    float d2 = onion(bendTorus( pos.xzy, vec2(1.2,0.8) ), thick-0.02);\n    d2 = max( d2, pos.y+cos(iTime-0.9));\n    \n    float d3 = onion(bendTorus( pos.xzy, vec2(1.3,1.1) ), thick-0.03);\n    d3 = max( d3, pos.x+sin(iTime+0.5));\n\n    vec3 posBox = pos;\n    float boxZ = 0.1;\n    float box = bendBox(posBox, vec3(12.5, 3.1, boxZ));\n    \n    // cut it all in half so that the interior parts are visible\n    float tori = min(d3,min(d2,min(d1, d)));\n    return opSubtraction(box,tori);\n}    \n\nvec2 squareFrame(vec2 res, vec2 coord){\n    vec2 uv = 2.0 * coord.xy / res.xy - 1.0;\n    uv.x *= res.x / res.y;\n    return uv;\n}\n\nfloat raymarching(vec3 eye, vec3 marchingDirection){\n    float depth = NEAR_CLIP;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(eye + depth * marchingDirection);\n        if (dist < EPSILON){\n            return depth;\n        }\n\n        depth += dist;\n\n        if (depth >= FAR_CLIP) {\n            return FAR_CLIP;\n        }\n    }\n    return FAR_CLIP;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ ) {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat ao( in vec3 pos, in vec3 nor ){\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.06*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal){\n    float ambient = 0.3;\n    return clamp( dot(normal, lightDirection) * ambient + ambient, 0.0, 1.0 );\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 40.;\n    return clamp( pow(max(dot(h, normal), 0.), specularityCoef), 0.0, 1.0);\n}\n\nfloat fresnel(vec3 normal, vec3 dir){\n    return pow( clamp(1.0+dot(normal,dir),0.0,1.0), 2.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = squareFrame(iResolution.xy,fragCoord.xy);\n\n    float camSpeed = 1.0;\n    vec3 eye = vec3( \n               0.5+2.5*sin(camSpeed*iTime),\n                2.5,\n                2.3 - 3.0*cos(camSpeed*iTime)\n    );\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    mat3 camera = setCamera( eye, ta, 0.0 );\n    float fov = 1.5;\n    vec3 dir = camera * normalize(vec3(uv, fov));\n    \n    float shortestDistanceToScene = raymarching(eye, dir);\n\n    vec3 color;\n    vec3 bgColor = vec3(0.086, 0.290, 0.800);\n\n    if (shortestDistanceToScene < FAR_CLIP - EPSILON) {\n        vec3 collision = (eye += (shortestDistanceToScene*0.995) * dir );\n        float shadow  = softshadow(collision, lightDirection, 0.02, 2.5 );\n        vec3 normal = computeNormal(collision);\n        float diffLight = diffuse(normal);\n        float specLight = specular(normal, dir);\n        float fresnelLight = fresnel(normal, dir);\n        float ambientOcc = ao(collision, normal);\n        vec3 texCol = vec3(1.00, 0.352, 0.207);\n        color = (diffLight + specLight + fresnelLight) * texCol;\n        \n        shadow = mix(shadow, 1.0, 0.7);\n        color = color * ambientOcc * shadow;\n\n    } else {\n        color = bgColor;\n    }\n    \n\n    fragColor = vec4(clamp(color,0.0,1.0) , 1.0);\n}","name":"Image","description":"","type":"image"}]}