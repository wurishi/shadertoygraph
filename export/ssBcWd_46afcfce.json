{"ver":"0.1","info":{"id":"ssBcWd","date":"1727691376","viewed":18,"name":"Learning Raymarching - Isaac","username":"amajorcat","description":"https://inspirnathan.com/posts/52-shadertoy-tutorial-part-6/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface\n{\n    float sd; // signed distance\n    vec3 col;\n};\n\nSurface minWithColor( Surface obj1, Surface obj2 )\n{\n    if(obj1.sd < obj2.sd) return obj1;\n    else return obj2;\n}\n\nSurface sdSphere( vec3 p, float r, vec3 offset, vec3 col )\n{\n    return Surface(length(p + offset) - r, col);\n}\n\nSurface sdFloor( vec3 p, vec3 col )\n{\n    return Surface(p.y + 1., col);\n}\n\nSurface sdScene( vec3 p )\n{\n    Surface circle_1 = sdSphere(p, 1., vec3(0, 0., 0.), vec3(1., 1., 1.));\n    Surface circle_2 = sdSphere(p, 1., vec3(0, 0., 0.), vec3(1., 1., 1));\n    Surface res = minWithColor(circle_1, circle_2);\n    \n    \n    vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    return minWithColor(res, sdFloor(p, floorColor));\n}\n\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n  return normalize(\n    e.xyy * sdScene(p + e.xyy).sd +\n    e.yyx * sdScene(p + e.yyx).sd +\n    e.yxy * sdScene(p + e.yxy).sd +\n    e.xxx * sdScene(p + e.xxx).sd);\n}\n\nSurface rayMarch( vec3 ro, vec3 rd, float start, float end )\n{\n    float depth = start;\n    \n    Surface co; // closest object\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        float d = co.sd;\n        \n        depth += d;\n        \n        if(d < PRECISION || depth > end) break;        \n    }\n    \n    return Surface(depth, co.col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    vec3 lp = vec3(2., 2., 4.); // light position\n    vec3 ro = vec3(0., 0., 5.); // ray origin\n    vec3 col = vec3(0.);\n    \n    vec3 rd = normalize(vec3(uv, -1.)); // ray direction\n    \n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n    \n    vec3 backgroundColor = vec3(0.835, 1, 1);\n    \n    if(co.sd > MAX_DIST)\n    {\n        col = backgroundColor;\n    }\n    else\n    {\n        vec3 p = ro + rd * co.sd; // point on sphere we discovered from ray marching\n        vec3 normal = calcNormal(p);\n        vec3 lightPosition = vec3(10., 10., 10.);\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        // Calculate diffuse reflection by taking the dot product of \n        // the normal and the light direction.\n        float dif = clamp(dot(normal, lightDirection), 0.2, 1.);\n\n        col = dif * co.col + backgroundColor * .2;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}