{"ver":"0.1","info":{"id":"M3SBz3","date":"1730385850","viewed":161,"name":"Painting Trails","username":"gehtsiegarnixan","description":"I made a shader that paints on the buffer, while being frame-rate independent. \nThis shader has mouse controls to paint trails for yourself and a number of global constants in the Common section such as debug views.","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["height","interpolation","buffer","trail","path","heightblend","rendertarget","timedetla"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nI made a shader that paints on the buffer, while being frame-rate independent. \nThis shader has mouse controls to paint trails for yourself and a number of \nglobal constants in the Common section such as debug views.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Sample Buffer mask\n    vec3 buffer = texelFetch(iChannel2, ivec2(fragCoord), 0).xyz;\n    \n    // Get weight from buffer\n    float weight = clamp(buffer.z, 0.0, 1.0);\n    \n    // Square UVs\n    vec2 uv = fragCoord / iResolution.y;\n    uv *= 10.0; // Arbitrary scale\n\n    // Sample Color and height from two textures\n    vec3 colorA = phaseTexture(iChannel0, uv);\n    float heightA = getLightness(colorA); // arbitrary proxy for the height\n    \n    vec3 colorB = phaseTexture(iChannel1, uv);\n    float heightB = getLightness(colorB);\n\n    // Apply height contrast\n    weight = heightWeight(weight, vec2(heightA, heightB), 4.0);\n\n    #ifdef SHOW_WEIGHT\n        // Show weight as colormap\n        vec3 color = viridis(weight);\n    #else\n        // Interpolate between colors\n        vec3 color = mix(colorA, colorB, weight);\n    #endif\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// BUFFER STORING THE PAINTED TRAILS _________________________________________\n\n// Function to calculate the SDF for a line segment\nfloat sdfLineSegment(vec2 position, vec2 pointA, vec2 pointB) {\n    vec2 pa = position - pointA;\n    vec2 ba = pointB - pointA;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// Function to handle painting of the brush\nvoid applyBrush(vec2 uv, vec2 mousePos, inout vec4 color) {\n\n    // Get the previous mouse position\n    vec2 previousMousePos = color.xy;\n\n    // Calculate distance between current and previous mouse positions\n    float mouseDist = length(mousePos - previousMousePos);\n\n    // Maximum distance to switch to sphere distance\n    const float maxDistance = 0.2; \n\n    // Make brush mask and use lines to smooth the brush\n    float dist = 0.0;    \n    if (mouseDist > maxDistance) {\n    \n        // Use sphere distance if the difference is too large\n        dist = length(uv - mousePos);\n        \n    } else {\n        // Calculate SDF from the previous mouse pos to the current one\n        dist = sdfLineSegment(uv, mousePos, previousMousePos);\n    }\n\n    // Draw the sphere blob using the normal distribution\n    float brush = exp(-BRUSH_SPREAD * dist * dist);\n\n    // Apply the brush strength, adjusted by iTimeDelta\n    color.z += brush * BRUSH_OPACITY * iTimeDelta;\n\n    // Store the current mouse position\n    color.xy = mousePos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Sample itself\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Apply mask decay over time, adjusted by iTimeDelta\n    color.z *= exp(-DECAY_RATE * iTimeDelta);\n\n    // Ensure the value doesn't go below 0\n    color.z = max(color.z, 0.0);\n\n    // Compute UV coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    // If mouse was not moved yet, do a predefined walk\n    if (iMouse.x == 0.0) {\n    \n        #if 1\n            // Make custom time scale\n            float time = iTime * 2.0;\n            \n            // Smooth vector noise\n            vec2 noise = vectorValueNoise(time + 421.0);\n            \n            // Get the previous mouse position\n            vec2 previousMousePos = color.xy;\n            \n            // Vector pointing towards the center of the screen\n            vec2 edgeVector = -previousMousePos * 2.0 * vec2(iResolution.y / iResolution.x, 1);\n            \n            // Weights that get stronger near the edges of the screen\n            vec2 grid = 1.0 - abs(edgeVector);\n            float edgeWeight = 1.0 - grid.x * grid.y;\n            \n            // Nudge the noise back into the center\n            noise += edgeVector * edgeWeight;\n            \n            // Update the current position with the random noise\n            float stepSize = 2.0 * iTimeDelta; // Adjusted for the framerate\n            vec2 mousePos = previousMousePos + noise * stepSize;\n            \n        #else\n            // Make custom time scale\n            float time = iTime * 1.0;\n            \n            // Make circle mouse position\n            vec2 mousePos = vec2(sin(time), cos(time)) * 0.4;\n        #endif\n        \n        // Apply the brush to the color\n        applyBrush(uv, mousePos, color);\n    }\n\n    // If the mouse cursor is clicked\n    if (iMouse.z > 0.0) {\n    \n        // Mouse coords also square\n        vec2 mousePos = (iMouse.xy - iResolution.xy * 0.5) / iResolution.y;\n        \n        // Apply the brush to the color\n        applyBrush(uv, mousePos, color);\n    }\n\n    fragColor = vec4(color);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Show the weight as colormap\n//#define SHOW_WEIGHT\n\n// Parameters for the brush\n#define BRUSH_SIZE 0.1\n#define BRUSH_SPREAD (-log(0.05)/(BRUSH_SIZE * BRUSH_SIZE))\n#define BRUSH_OPACITY 16.0 // per second how much is added\n\n// Rate at which the color fades per second\n#define DECAY_RATE 0.5\n\n// GENERAL FUNCTIONS _____________________________________________________\n\n// Offsets weights based on height differences. Contrast value range is 0-inf, \n// See: https://www.shadertoy.com/view/cdGfWt or https://www.desmos.com/calculator/gxhnhzu1cs\nfloat heightWeight(float weight, vec2 heights, float contrast) {\n    \n    // Generate both weights\n    vec2 weights = vec2(1. - weight, weight);\n    \n    // Generate the height weight\n    vec2 heightWeights = weights * pow(heights +1.0, vec2(contrast));\n\n    // Normalize to sum 1 and return weight y since linear only needs one\n    return heightWeights.y / (heightWeights.x + heightWeights.y);\n}\n\n// Offset weight with height bias by contrast\n// See https://www.desmos.com/calculator/gxhnhzu1cs\nfloat straightHeightWeight (float weight, vec2 heights, float contrast) {\n\n    // apply contrast with offset\n    float heightWeight = weight + contrast * (weight * heights.y - (1.-weight) * heights.x);\n\n    // Ensure the final weight value is clamped to the range [0, 1]\n    return clamp(heightWeight, 0.0, 1.0);\n}\n\n// Simplified Smoothstep https://www.desmos.com/calculator/un0o21eokv\nfloat smoothValue(float x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// Function to calculate lightness (value in HSV) from RGB\nfloat getLightness(vec3 color) {\n    return max(max(color.r, color.g), color.b);\n}\n\n// RANDOM FUNCTIONS _________________________________________________\n\n// Sinus hill tiling mask, which is faster than a texture lookup\n#define TWO_PI 6.28318530718\nfloat sinHills(vec2 uv) {\n    vec2 d = sin(uv * TWO_PI); // pi-sized grid\n    return (d.x + d.y) * 0.25 + 0.5; // Add and rescale to 0-1\n}\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash21(uint p) {\n\tuvec2 q = p * VPRIME1;\n\tq = (q.x ^ q.y) * VPRIME2;\n    return vec2(q) * SMALLESTFLOAT;\n}\n\n// Very basic smooth vector noise\nvec2 vectorValueNoise(float position) {\n\n    // Calculate the cell coordinates and fractional part\n    uint id = uint(position); // Integer coordinates\n    float grid = position - float(id); // Fractional coordinates\n\n    // Compute hash values\n    vec2 a = hash21(id);\n    vec2 b = hash21(id + uint(1));\n\n    // Smoothing the weights a bit\n    float weight = smoothValue(grid);\n\n    // Linear interpolation between a and b\n    return mix(a, b, weight) * 2.0 - 1.0;\n}\n\n// TEXTURE VARIATION FUNCTION _____________________________________\n\n// Generates 2 indexs and a weight from a gradient\n// See https://www.desmos.com/calculator/uypn8kggi6\nvec3 getIndexWeight(float gradient, float count) {\n    \n    // generate partial values for the caculation\n    vec2 phases = vec2(gradient * (count-1.0) * 0.5) + vec2(0.5,0.0);\n    vec2 id = floor(phases);\n    float gridB = phases.y - id.y;\n    \n    // Fold repeating weights for the number of steps\n    float weight = min(gridB, 1.0 - gridB) * 2.0;\n    \n    // add some contrast to the grid for nicer transitions\n    weight = smoothValue(weight);\n    \n    // generate unique indexs for each weight phase\n    vec2 indexes = id * 2.0 + vec2(0.0,1.0);\n    \n    // Return the two indexes then the weight\n    return vec3(indexes, weight);\n}\n\n// Rotate and Offset the UV using the index\nvec2 phaseUV(vec2 uv, float id, float count) {\n    \n    // just the precentage of the id\n    vec2 precentage = vec2(id / count); \n    \n    // add slight scale variation to the textures (in %)\n    const float scaleVaritation = 0.3; // should probably be an input\n    uv *= (precentage.y - 0.5) * scaleVaritation + 1.0;\n    \n    // offset the coordinates\n    uv += precentage;\n    \n    // use the evenly spread out ID precentage as angle\n    const float rotationAmount = 0.5; // should probably be an input\n    float angle = TWO_PI * precentage.y * rotationAmount;\n    vec2 direction = vec2(sin(angle), cos(angle)); // use this to rotate normals\n\n    // Rotated coordinates (if you use normals they need to be rotated too)\n    uv = rotateUV(uv, direction); // rotation for coords, normals get rotated differently\n    \n    return uv;\n}\n\n// generates a random texturing using phases of a gradient noise\n// https://www.shadertoy.com/view/4flcR4\nvec3 phaseTexture(sampler2D tex, vec2 uv) {\n\n    // how many phases exist could be input parameter\n    const float count = 9.0;\n\n    // Sample noise gradient\n    float gradient = sinHills(uv / count * 2.0);\n\n    // generate the phase index and weights\n    vec3 indexWeight = getIndexWeight(gradient, count);    \n    float weight = indexWeight.z;\n    vec2 indices = indexWeight.xy;\n\n    // generate unique offsets and rotations for each phase\n    vec2 uvA = phaseUV( uv, indices.x, count);\n    vec2 uvB = phaseUV( uv, indices.y, count);\n            \n    // Sample color textures\n    vec3 colorA = texture(tex, uvA).xyz;\n    vec3 colorB = texture(tex, uvB).xyz;\n\n    // Height blend with the same texture makes a kinda histogram preservation  \n    // and it always looks nice no matter the texture and is really cheap\n    // See: https://www.shadertoy.com/view/DtXfD7\n    vec2 lightness = vec2(getLightness(colorA), getLightness(colorB));\n    weight = straightHeightWeight(weight, lightness, 1.);\n    \n    // Interpolate color\n    return mix(colorA, colorB, weight);\n}\n\n// DEBUG FUNCTIONS __________________________________________________________\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}","name":"Common","description":"","type":"common"}]}