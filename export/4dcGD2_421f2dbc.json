{"ver":"0.1","info":{"id":"4dcGD2","date":"1452136128","viewed":353,"name":"Simple Projectile System","username":"Hamneggs","description":"Bullet system test. Use WASD to aim, space to fire. This is more of a brutish attempt to do some state-reliant stuff.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["test","simple","bullet","system","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/**\n * A basic projectile system that stores its state in a framebuffer.\n * License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n */\n\n// Position of the bullet data.\nvec2 txBLTP = vec2(2,0);\n// Position of gun direction.\nvec2 txGUND = vec2(8,0);\n\n// Current buffer size for loading data.\nvec2 BUFF_RES = iChannelResolution[0].xy;\n\n#define DATA_BUFFER iChannel0\n\n// Reads a texel. We don't really need component-wise read functions.\nvec4 readTexel(in sampler2D buffer, in vec2 pos )\n{\n    return texture(buffer, (pos+.5)/BUFF_RES);\n}\n\n// Draws a dot on the screen.\nvec4 drawDot( in vec2 p, in vec2 uv, in float r)\n{\n    float d = smoothstep(r-.005, r, length(p-uv));\n    return mix(vec4(1.0),vec4(0.0),d);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get some UVs.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv*.1);\n    \n    // Load all the stuff from state.\n    vec4 bPos = readTexel(DATA_BUFFER,txBLTP);\n    vec4 gDir = readTexel(DATA_BUFFER,txGUND);\n    \n    // Draw a bullet, depending on if it exists. Remember, it's\n    // stored in bPos.a.\n    vec4 bullet = mix(vec4(0),drawDot(bPos.xy, uv, .01),bPos.a);\n    // Draw the gun and the barrel.\n    vec4 gunBase = drawDot(vec2(.5), uv, .0125);\n    vec4 gunBarrel = drawDot(vec2(.5)+gDir.xy*.0125, uv, .0125);\n    \n    // Alpha mask everything together.\n    fragColor = mix(vec4(0,0,0,1), gunBase, gunBase.a);\n    fragColor = mix(fragColor, gunBarrel, gunBarrel.a);\n    fragColor = mix(fragColor, bullet, bullet.a);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Position of the keyboard data.\nvec2 txKEYS = vec2(0,0);\n// Position of the bullet data.\nvec2 txBLTP = vec2(2,0);\n// Position of the bullet dir data.\nvec2 txBLTD = vec2(4,0);\n// Position of fire key data.\nvec2 txFIRE = vec2(6,0);\n// Position of gun direction.\nvec2 txGUND = vec2(8,0);\n\n// Other constants.\n#define DATA_BUFFER iChannel0\n#define KEYBOARD iChannel1\n#define KEY_DOWN_POS 0.0\n#define MOVE_SPEED .125\n\n// Key codes.\nconst float KEY_W = 87.0/256.0;\nconst float KEY_A = 65.0/256.0;\nconst float KEY_S = 83.0/256.0;\nconst float KEY_D = 68.0/256.0;\nconst float SPACE = 32.0/256.0;\n\n// Current buffer size for loading data.\nvec2 BUFF_RES = iChannelResolution[0].xy;\n\n// Reads a texel. We don't really need component-wise read functions.\nvec4 readTexel(in sampler2D buffer, in vec2 pos )\n{\n    return texture(buffer, (pos+.5)/BUFF_RES);\n}\n\n// Writes a single component of a pixel in a buffer.\nvoid write1( inout float buffer, in float val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n// Writes two components of a pixel in a buffer.\nvoid write2( inout vec2 buffer, in vec2 val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n// Writes three of the components.\nvoid write3( inout vec3 buffer, in vec3 val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n// Writes all components of a texel (at once).\nvoid write4( inout vec4 buffer, in vec4 val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\nvoid handleInput(inout vec4 buffer, in vec2 fragCoord )\n{\n    // Since we are straight up replacing the keys data\n    // every frame, we don't need to load the original value.\n    \n    // If a key is down, update the position accordingly.\n    vec4 keys; float spaceDown;\n    keys.r = texture(KEYBOARD,vec2(KEY_W, KEY_DOWN_POS)).r;\n    keys.g = texture(KEYBOARD,vec2(KEY_S, KEY_DOWN_POS)).r;\n    keys.b = texture(KEYBOARD,vec2(KEY_A, KEY_DOWN_POS)).r;\n    keys.a = texture(KEYBOARD,vec2(KEY_D, KEY_DOWN_POS)).r;\n    spaceDown = texture(KEYBOARD,vec2(SPACE, KEY_DOWN_POS)).r;\n    \n    // Store the keys value. That mix eases between full up and\n    // full down states, so that the velocity of the camera\n    // isn't as jarring.\n    write4(buffer,keys,txKEYS,fragCoord);\n    write1(buffer.r,spaceDown,txFIRE,fragCoord);\n}\n\nvoid handleBullets(inout vec4 buffer, in vec2 fragCoord)\n{\n    // Load prior frame's state.\n    vec4 bulletPos = readTexel(DATA_BUFFER, txBLTP);\n    vec4 bulletDir = readTexel(DATA_BUFFER, txBLTD);\n   \tvec4 dirInput = readTexel(DATA_BUFFER, txKEYS);\n    vec2 pGunDir = readTexel(DATA_BUFFER, txGUND).xy;\n    float fireInput = readTexel(DATA_BUFFER, txFIRE).r;\n    \n    // Alpha of bullet position is zero if it isn't on screen.\n    \n    // Set up the gun direction.\n    // If the prior gun direction was null, we set it to a default.\n    if(length(pGunDir) < .1) pGunDir = vec2(0.0,1.0);\n    // Next, we get the current direction from the input.\n    vec2 cGunDir = vec2(dirInput.a-dirInput.b,dirInput.r-dirInput.g);\n    \n    // If keys were pressed, this evals to cGunDir, otherwise we use\n    // the prior direction.\n    cGunDir = mix(pGunDir, cGunDir, length(cGunDir));\n    cGunDir = normalize(cGunDir); // Must be normalized.\n    \n    // If the bullet is non-existent and the fire button is down...\n    if(bulletPos.a < .1 && fireInput > .5)\n    {\n        // Make a bullet in the middle of the screen, and existant.\n        bulletPos.xyw = vec3(.5,.5, 1.0);\n        // store the bullet direction.\n        bulletDir.xyw = vec3(cGunDir,1.0);\n\t}\n    // If the bullet exists...\n    else if(bulletPos.a > .1)\n    {\n        // Update its position.\n        bulletPos.xy += bulletDir.xy*.05;\n        \n        // Set up a test position.\n        vec2 bPos = abs(bulletPos.xy-.5);\n        // Test if the bullet is off the screen.\n        if(max(bPos.x,bPos.y)>.5)\n        {\n            // If it is, set the alpha of the position to zero.\n            // so a new bullet could be created.\n            bulletPos.a = 0.0;\n            bulletPos.rgb = vec3(1,0,1);\n        }\n    }\n    \n    // Store the bullet and gun data.\n    write2(buffer.xy,cGunDir,txGUND, fragCoord);\n    write4(buffer,bulletPos,txBLTP,fragCoord);\n    write4(buffer,bulletDir,txBLTD,fragCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Load the buffer at this fragment's position.\n    vec4 buff = texture(DATA_BUFFER,fragCoord/BUFF_RES);\n    \n    // Call the input handler.\n    handleInput(buff,fragCoord);\n    // Call the bullet pos handler.\n    handleBullets(buff,fragCoord);\n    \n    // Write out this fragment position's result.\n    fragColor = buff;\n}","name":"Buf A","description":"","type":"buffer"}]}