{"ver":"0.1","info":{"id":"MssyDn","date":"1487790870","viewed":86,"name":"GRAPPROG MIDTERM LIM","username":"marcoolim","description":"I luv GRAPPROG <3\nby Miguel Enrico G. Lim","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simplicity","unity","diversity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define SWITCH 10\n//1-3 circles and squares with sin wave and rotations\n//4-6 polar shapes and rotation\n//7 & 8 color and shape combinations\n//9 & 10 modified shapes\n\n\n//Colors\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 yellow = vec3(1., 1., 0.0);\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n\tvec3 green = vec3(0.0, 1.0, 0.0);\n\tvec3 idk = vec3(0.0,1.0,1.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n\nmat2 rotate2d(float angle)\n{\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(vec2 value){\n\treturn mat2(value.x, 0,0, value.y);\n}\n//regular circle\nvec3 circle(vec2 uv, vec2 center, float r){\n    float color = distance(center, uv);\n    return vec3(smoothstep(color, r, 1.0));\n}\n\n//For polar shapes in a circle\nfloat circlePoly(vec2 circle, vec2 uv, float r) { \n    float diameter = distance(circle,uv)* 2.0;\n    uv -= circle;\n    float angle = atan(uv.y, uv.x);\n   \tangle += iTime * 2.;\n    r = sin(13.*angle);\n    float color = 1.0 - step(r,diameter);\n    return color;\n}\n//For polar circle\nvec3 SmoothCircle (vec2 uv,vec2 center, float r){\n    float diameter = distance(center, uv);\n    uv -= center;\n    vec3 color = vec3(1.0-smoothstep(r, r+0.05,diameter));\n    return color;\n}\n\n//Polygons with varying number of sides\nfloat GenPoly(vec2 uv, int sides, float modif){\n\tfloat a = atan(uv.x,uv.y)+PI;\n\tfloat r = TWO_PI/float(sides);\n\tfloat dist = cos(floor(modif+a/r)*r-a)*length(uv);\n    float value = 1. - smoothstep(0.4,0.41, dist * 3.);\n    return value;\n}\n//Squares with different sizes\nfloat GenRect(vec2 uv,vec2 pos, vec2 size, float borderThickness){\n    pos -= 0.5*size;\n    vec2 bl = step(pos,uv);\n    float pct = bl.x * bl.y;\n    vec2 tr = 1.0 - step(pos+size, uv);\n    pct *= tr.x * tr.y;\n    \n    return pct;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat ratio = iResolution.x / iResolution.y;     \n    \n    // PATTERNS\n    #if (SWITCH == 1)\n    uv *= 4.0;\n    vec2 tileldx = floor(uv); \n    uv = fract(uv);\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5*ratio, 0.5);\n    uv -= pos;\n    uv *= rotate2d(sin(iTime*-10.0));\n    uv *= scale2d(vec2(abs(sin(iTime*1.2)))); \n    uv += pos;\n    vec3 color = vec3(GenRect(uv,pos, vec2(0.5,0.5), 0.0))* red;\n    \n    if (tileldx.x == 0.0 && tileldx.y == 0.0 ||\n        tileldx.x == 1.0 && tileldx.y == 1.0 ||\n        tileldx.x == 2.0 && tileldx.y == 2.0 ||\n        tileldx.x == 3.0 && tileldx.y == 3.0 ||\n       \ttileldx.x == 0.0 && tileldx.y == 3.0 ||\n       \ttileldx.x == 1.0 && tileldx.y == 2.0 ||\n       \ttileldx.x == 2.0 && tileldx.y == 1.0 ||\n       \ttileldx.x == 3.0 && tileldx.y == 0.0){\n        uv -= pos;\n        color = vec3(circle(uv,vec2(0.0), 0.3)) * yellow;\n    }\n    #endif\n    \n    \n    \n    #if (SWITCH == 2)\n    uv *= 3.0;\n    vec2 tileldx = floor(uv);\n    uv = fract(uv);\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5*ratio, 0.5);\n    uv -= pos;   \n    uv *= rotate2d(iTime)*scale2d(vec2(.3));\n    uv = uv * rotate2d(iTime);\n    \n    vec3 color = GenPoly(uv, 4, 0.5) * red;\n    \n    if (tileldx.x == 0.0 && tileldx.y == 0.0 ||\n        tileldx.x == 2.0 && tileldx.y == 0.0 ||\n        tileldx.x == 2.0 && tileldx.y == 2.0 ||\n        tileldx.x == 0.0 && tileldx.y == 2.0){\n        color = vec3(circle(uv,vec2(0.0), 0.1)) * blue * abs(sin(iTime));\n    }\n    #endif\n    \n    \n    \n    #if (SWITCH == 3)\n    uv *= 5.0;\n    vec2 tileldx = floor(uv);\n    uv = fract(uv);\n    uv.x *= ratio;\n    vec2 pos = vec2(0.5 * ratio,0.5);\n    uv -= pos;\n   \tuv *= scale2d(vec2(abs(sin(iTime))));\n    \n    vec3 color = circle(uv,vec2(0.0), 0.22)* blue* abs(sin(iTime));\n    color += GenPoly(uv, 4, 0.5) * yellow;\n    \n    if (tileldx.x == 0.0 && tileldx.y == 0.0 ||\n        tileldx.x == 0.0 && tileldx.y == 1.0 ||\n        tileldx.x == 0.0 && tileldx.y == 2.0 ||\n        tileldx.x == 0.0 && tileldx.y == 3.0 ||\n        tileldx.x == 4.0 && tileldx.y == 4.0 ||\n        tileldx.x == 0.0 && tileldx.y == 4.0 ||\n        tileldx.x == 1.0 && tileldx.y == 4.0 ||\n        tileldx.x == 2.0 && tileldx.y == 4.0 ||\n        tileldx.x == 3.0 && tileldx.y == 4.0){\n        color = GenPoly(uv, 4, 0.5) * red * abs(sin(iTime));\n        color += circle(uv,vec2(0.0), 0.09)* yellow;\n    }\n    #endif\n    \n    \n        \n \t#if (SWITCH == 4)\n    uv *= 5.0;\n    vec2 tileldx = floor(uv);\n    uv = fract(uv);\n    uv.x *= ratio;\n    vec2 pos = vec2(0.225 * ratio,0.0);\n    uv -= pos;\n    \n    \n    vec3 color = circlePoly(vec2(0.5, 0.5), uv, 5.0)* red;\n    \n    if (tileldx.x == 0.0 && tileldx.y == 0.0 ||\n        tileldx.x == 1.0 && tileldx.y == 1.0 ||\n        tileldx.x == 2.0 && tileldx.y == 2.0 ||\n        tileldx.x == 3.0 && tileldx.y == 3.0 ||\n        tileldx.x == 4.0 && tileldx.y == 4.0 ||\n        tileldx.x == 0.0 && tileldx.y == 4.0 ||\n        tileldx.x == 1.0 && tileldx.y == 3.0 ||\n        tileldx.x == 2.0 && tileldx.y == 2.0 ||\n        tileldx.x == 3.0 && tileldx.y == 1.0 ||\n       \ttileldx.x == 4.0 && tileldx.y == 0.0){\n        color = circlePoly(vec2(0.5, 0.5), uv, 5.0) * white;\n    }\n    #endif\n    \n    \n    \n    #if (SWITCH == 5)\n    uv *= 3.0;\n    vec2 tileldx = floor(uv);\n    uv = fract(uv);\n    uv.x *= ratio;\n    vec2 pos = vec2(0.5 * ratio,0.5);\n    uv -= pos;\n    uv *= rotate2d(iTime)*scale2d(vec2(.3));\n    float angle = atan(uv.y,uv.x);\n    float radius = sin(angle*1.0)*sin(angle*20.0);\n    vec3 color = SmoothCircle(uv,vec2(0.5, 0.5),radius * 5.0) * red;\n    #endif\n    \n    \n    \n    #if (SWITCH == 6)\n    uv *= 5.0;\n    vec2 tileldx = floor(uv);\n    uv = fract(uv);\n    uv.x *= ratio;\n    vec2 pos = vec2(0.5 * ratio,0.5);\n    uv -= pos;\n    uv *= rotate2d(iTime)*scale2d(vec2(.3));\n    float angle = atan(uv.y,uv.x);\n    float radius = sin(angle*100.0)*sin(angle*20.0);\n    vec3 color = SmoothCircle(uv,vec2(0.5, 0.5), radius * 5.0) * red+yellow * abs(sin(iTime));\n    \n    if (tileldx.x == 0.0 && tileldx.y == 0.0 ||\n        tileldx.x == 1.0 && tileldx.y == 1.0 ||\n        tileldx.x == 2.0 && tileldx.y == 2.0 ||\n        tileldx.x == 3.0 && tileldx.y == 3.0 ||\n        tileldx.x == 4.0 && tileldx.y == 4.0 ||\n        tileldx.x == 0.0 && tileldx.y == 4.0 ||\n        tileldx.x == 1.0 && tileldx.y == 3.0 ||\n        tileldx.x == 2.0 && tileldx.y == 2.0 ||\n        tileldx.x == 3.0 && tileldx.y == 1.0 ||\n       \ttileldx.x == 4.0 && tileldx.y == 0.0){\n        color = circle(uv,vec2(0.0), 0.09) * white;\n        color *= circle(uv,vec2(0.0), 0.09) * red+yellow * abs(sin(iTime)) ;\n    }\n    #endif\n    \n    \n    \n    #if (SWITCH == 7)\n    uv *= 2.0;\n    vec2 tileldx = floor(uv);\n    uv = fract(uv);\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5*ratio, 0.5);\n    uv -= pos; \n    uv *= rotate2d(iTime)*scale2d(vec2(.3));\n    uv = uv * rotate2d(iTime);\n    vec3 color = GenPoly(uv, 4, 0.5) * green;\n    color *= GenPoly(uv, 6, 0.5) * yellow;\n    color *= GenPoly(uv, 3, 0.5) * yellow;\n    if (tileldx.x == 1.0 && tileldx.y == 1.0){\n         color += red;\n    }\n    if (tileldx.x == 0.0 && tileldx.y == 0.0){\n         color += blue;\n    }\n    if (tileldx.x == 0.0 && tileldx.y == 1.0){\n         color += circle(uv,vec2(0.0), 0.1) * red;\n    }\n     if (tileldx.x == 1.0 && tileldx.y == 0.0){\n         color += circle(uv,vec2(0.0), 0.1) * blue;\n    }\n    #endif\n    \n    \n    \n    #if (SWITCH == 8)\n    uv *= 1.0;\n    vec2 tileldx = floor(uv);\n    uv = fract(uv);\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5*ratio, 0.5);\n    uv -= pos;   \n    uv *= rotate2d(iTime)*scale2d(vec2(.5));\n    uv = uv * rotate2d(iTime);\n    vec3 color2 = GenPoly(uv, 8, 0.1) * red;\n    uv *= scale2d(vec2(abs(sin(iTime*1.2))));\n    color2 += circle(uv,vec2(0.0), 0.1) * white* sin(iTime);\n    vec3 color3 = GenPoly (uv,3,0.5) * blue;\n    vec3 color = color2 + color3;\n    #endif\n    \n    \n    \n    #if (SWITCH == 9)\n    uv *= 2.0;\n    vec2 tileldx = floor(uv);\n    uv = fract(uv);\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5*ratio, 0.5);\n    uv -= pos;   \n    uv *= rotate2d(iTime)*scale2d(vec2(.5));\n    uv = uv * rotate2d(iTime);\n    vec3 color = SmoothCircle(uv,vec2(0.1, 0.1),0.1)* red;\n    color += GenPoly(uv,4,0.3);\n     uv *= scale2d(vec2(abs(sin(iTime/2.0))));\n    color += circle(uv,vec2(0.0), 0.3)* red* abs(sin(iTime*2.0));\n    #endif\n    \n    \n    \n    #if (SWITCH == 10)\n    uv *= 10.0;\n    vec2 tileldx = floor(uv);\n    uv = fract(uv);\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5*ratio, 0.5);\n    uv -= pos;   \n    uv *= rotate2d(iTime)*scale2d(vec2(.5));\n    uv = uv * rotate2d(iTime);\n    uv *= scale2d(vec2(abs(sin(iTime/0.8))));\n    vec3 color = circle(uv,vec2(0.0), 0.3)* red;\n    color += GenPoly(uv,2,10.0) * white * abs(sin(iTime*2.0));\n    #endif\n    \n    fragColor = vec4(color,3.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}