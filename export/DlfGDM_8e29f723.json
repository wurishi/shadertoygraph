{"ver":"0.1","info":{"id":"DlfGDM","date":"1671908071","viewed":86,"name":"Fork Ray Marchi bocampagni 818","username":"bocampagni","description":"An intro to the very popular and powerful ray marching technique!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"fdVfDz","parentname":"Ray Marching for Beginners!"},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.1415925359\n#define diff .0015\n#define timeScale .7\n#define lightPathRadius .35\n#define lightPathCenter vec3(0, .15, .15)\n#define lightColor vec4(1.0, 1.0, 1.0, 1.0)\n#define lightStrength 1.0\n#define surfaceZDepth 0.0\n#define ambientColor vec4(0.01, 0.01, 0.01, 1.0)\n#define specularFactor 8.0\n#define specularRatio 5.0\n#define specularMapRatio 8.0\n#define useBaseImage\n\n\nfloat getHeightValue(sampler2D tex, vec2 coord)\n{\n\treturn texture(tex, coord).r;\n}\n\n\nvec2 getLocalDiff(sampler2D tex, vec2 coord)\n{\n\tfloat diffX = getHeightValue(tex, vec2(coord.x+diff, coord.y) )\n\t\t-getHeightValue(tex, vec2(coord.x-diff, coord.y) );\n\t\n\tfloat diffY = getHeightValue(tex, vec2(coord.x, coord.y+diff) )\n\t\t-getHeightValue(tex, vec2(coord.x, coord.y-diff) );\n\t\n\treturn vec2(diffX, diffY);\n}\n\n\nvec3 getSurfaceNormal(sampler2D tex, vec2 coord)\n{\n\tvec2 localDiff = getLocalDiff(tex, coord);\n\t\n\tlocalDiff *= -1.0;\n\t\n\tlocalDiff = (localDiff/2.0)+.5;\n\t\n\tfloat localDiffMag = length(localDiff);\n\tfloat z = sqrt(1.0-pow(localDiffMag, 2.0));\n\t\n\treturn vec3(localDiff, z);\n}\n\nfloat getSpecularity(sampler2D tex, vec2 coords)\n{\n\treturn texture(tex, coords).b*.5;\n}\n\nvec3 genLightCoords()\n{\n\tvec3 lightCoords = vec3(lightPathCenter.x + (sin(iTime*timeScale)*lightPathRadius), \n\t\t\t\tlightPathCenter.y,\n\t\t\t\tlightPathCenter.z);\n\treturn lightCoords;\n}\n\n\nvec3 getIncidence(vec3 lightPos, vec2 coord)\n{\n\treturn lightPos - vec3(coord, surfaceZDepth);\n}\n\nfloat getAngle(vec3 lightIncidence, vec3 normal)\n{\n\tnormal.xy -= .5;\n\tnormal.xy *= 2.0;\n\t\n\tnormal = normalize(normal);\n\tlightIncidence = normalize(lightIncidence);\n\t\n\treturn dot(lightIncidence, normal);\n}\n\nfloat getDist(vec3 light, vec2 coord)\n{\n\treturn distance(light, vec3(coord, 0.0));\n}\n\nvec4 getLighting(sampler2D heightTex, sampler2D specTex, vec2 coord)\n{\n\tvec3 lightPos = genLightCoords();\n\t\n\tvec3 lightIncidence = getIncidence(lightPos, coord);\n\t\n\tvec3 surfaceNormal = getSurfaceNormal(heightTex, coord);\n\t\n\tfloat cosine = getAngle(lightIncidence, surfaceNormal);\n\t\n\tfloat dist = getDist(lightPos, coord);\n\t\n\tvec4 ambient = ambientColor;\n\t\n\tvec4 diffuse = vec4(1.0);\n\tdiffuse *= lightStrength;\n\tdiffuse *=  (1.0-dist);\n\tdiffuse *= cosine;\n\tdiffuse *= lightColor;\n\t\n\tfloat spec = getSpecularity(specTex, coord);\n\t\n\tvec4 specular = vec4(1.0);\n\tspecular *= lightStrength;\n\tspecular *=  pow((1.0-dist), specularFactor);\n\tspecular *= pow(cosine, specularFactor*specularRatio);\n\tspecular *= lightColor;\n\tspecular *= spec*specularMapRatio;\n\t\n\treturn ambient+diffuse+specular;\n}\n\n\n\n\nmat2 Rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    \n    return length(vec2(x, p.y)) - r.y;\n}\n\n\nfloat dSphere(vec3 p, vec4 s) {\n    return length(p - s.xyz) - s.w;\n}\n\nfloat getDist(vec3 p) {\n    float planeDist = p.y;\n    \n    vec3 tp = p - vec3(0, 1, 6);\n\n    float sd  = dSphere(p, vec4(0, 1, 6 , 1));\n    float td  = dTorus (tp, vec2(1.5, 0.2));\n    \n    \n    float d = min(sd, planeDist);\n    d = min(d, td);\n    \n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = \n        vec3(\n        getDist(p + e.xyy),\n        getDist(p + e.yxy),\n        getDist(p + e.yyx)) - \n        vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 ro) {\n    vec3 lightPos = vec3(0, 5, 6);\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    vec3 r = reflect(-l,n);\n    \n    float amb = 0.1;\n    float ka = 1.0;\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float kd = 0.8;\n    \n    float shininess = 100.;\n    vec3 v = normalize(ro-p);\n    float spec = clamp(dot(r, v), 0.0, 1.0);\n    spec = pow(spec,shininess);\n    float ks = 1.0;\n    \n    float d = rayMarch(p + 2. * n * SURF_DIST , l);\n    \n    if (d < length(lightPos - p)) {\n        dif *= 0.1;\n        spec *= 0.5;\n    }\n    \n    return ka * amb + kd * dif + ks * spec;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0, 2, 0);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    rd.yz *= Rot(PI * 10. / 180.); \n    \n    float d = rayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float light_intensity = getLight(p, ro);\n    \n    vec3 background_color = texture(iChannel3, uv*vec2(1.,2.)).rgb;\n    \n    vec3 surface_color = vec3(250, 235, 215) / 255.;\n    \n    vec3 color;\n    \n    float alpha = 2.;\n\n\n\tvec4 lighting = getLighting(iChannel0, iChannel1, uv);\n    \n    if (d < MAX_DIST){\n    \n    if(p.y >= 1.19 || (p.y < .9 && p.y > .1) ){\n       surface_color = texture(iChannel0,p.xy).rgb;\n       fragColor = lighting * vec4(color,1.) * alpha;\n    }        \n    \n    if(p.y > .9 && p.y < 1.19)\n        surface_color = texture(iChannel1,p.xy).rgb;\n            \n        color = surface_color * vec3(light_intensity);\n    }else \n        color = background_color;\n        \n    fragColor = lighting * vec4(color,1.) * alpha;\n}","name":"Image","description":"","type":"image"}]}