{"ver":"0.1","info":{"id":"lXsXzB","date":"1709694386","viewed":179,"name":"fm bass-fork","username":"jorge2017a2","description":"fm bass-fork","likes":7,"published":1,"flags":8,"usePreview":0,"tags":["fmbassfork"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///por jorge2017a2\n//5-mar-2024\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(8.0*antialiasing(1.5),0.,d - (b) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat Hash21(vec2 p) {\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec2 uv1=uv;\n    vec2 uv2=uv;\n    \n    uv1-=vec2(0.0,0.0+0.5*sin(iTime*2.0));\n    uv2-=vec2(-0.5*sin(-iTime*2.0),0.5*cos(-iTime*2.0));\n    float esc=8.0;\n    uv1*=esc;\n    uv2*=esc;\n    \n    // Time varying pixel color\n    vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col=vec3(1.0);\n    float dfin=9999.9;\n    float pos1,pos2,d1,d2;\n    for( int i=0 ;i<5;i++)\n    {\n        pos1=Hash21(vec2(0.0,1.0+iTime));\n        pos2=Hash21(vec2(iTime,0.0));\n        \n        d1=sdCircle(uv1*vec2(1.0*pos1,0.5*pos2), pos1 );\n       d2=sdCircle(uv2*vec2(1.0*pos1,0.5*pos2), pos2 );\n       dfin=min(dfin, abs(d1)-0.1);\n       dfin=min(dfin, abs(d2)-0.1);\n       \n    }\n    col= DrawFigDelgado(vec3(1.0,0.0,0.0)+col2, col*pos1*col2, d1 );\n    col= DrawFigDelgado(vec3(0.0,1.0,0.0)*col2, col*pos2*col2, d2 );\n    col= DrawFigDelgado(vec3(0.0,0.0,1.0), col,dfin );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// fm bass\n///https://www.shadertoy.com/view/XtVcRK\n//Created by nabr in 2018-09-14\n//best fm synth on the planet ...continued\n\n///Modificado por JorgeFP...jorge2017a2\n///----5-mar-2024--\n\n#define g_ 2400.\n\n// oscillation\n// fm \n#define tau (8. * atan(1.))\n#define bo 16. \n#define Brot(p, a) p = (sin(bo * a) + cos(g_ * a)) * p + sin(g_ * a) * vec2(p.y, -p.x)\n#define Brotg(p, a, g) p = (sin(bo * a) + cos(g * a)) * p + sin(g * a) * vec2(p.y, -p.x)\n#define brass(p) vec2(pow(p.x + p.y, cos(p.z)), pow(p.z + p.y, sin(p.z)))\n#define mult(z, w) vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x)\n\n//#define WEDIDITFORTHEMEMORIES\n#ifdef WEDIDITFORTHEMEMORIES\n#undef bo\n#define bo 6.\n#endif\n\nvec2 calbrot(float  freq,float time, float vg)\n{\n    // frequencies\n    float n=freq;\n   \n    // bassline \n     vec3 bassln = vec3(tau * (tau * .25), tau, tau * .25);\n   \n    float nf = sqrt(time * n) / 2.;\n    float nf1 = sqrt(time * n);\n\n    // apply rotation, already now you get a nice synth sound\n   Brotg(bassln.xy, nf,vg);\n   Brotg(bassln.zy, nf1,vg); //sum to 45 degrees\n    \n  \n    #ifndef WEDIDITFORTHEMEMORIES\n    \n        return sign(bassln.zy)*.125; \n   #else\n    \n    \n    // lets be progresive and summarize the following lines \n    // under terms bandfilter, envelope, sustain \n    vec2 mixch = vec2(0.1, 1.0);\n\n    vec2 left = vec2(1.0, cos(time * tau * 2.));\n    vec2 right = vec2(0.7, -1.0); //-1 cut the sound\n    vec2 env = smoothstep(0.2, 0.4, mixch * mat2(left, right));\n    bassln.xy = env - mult(env, bassln.yz);\n   return brass(bassln) * -.25;\n    \n    #endif\n\n}\n\n\nvec2 mainSound( in int samp,float time )\n{\n    time=mod(time,100.0);\n    \n    float n1 = (time * float[](.16, .358, .12, .271)[int(time) % 4]);\n    float n2 = (time * float[](4.0, 5.8, 6.2, 1.2)[int(time) % 4]);\n    \n    vec2 re1,re2,sum;\n    \n    if(time<10.0)\n    {\n        re1=calbrot(n1,time,1850.);\n        re2=re1;\n    }\n    else if(time>10.0 && time <25.0)\n    {\n        re1=calbrot(n1,time,1600.);\n        re2=calbrot(n2,time,1600.);\n    \n    }\n    else if(time>25.0 && time <40.0)\n    {\n        re2=calbrot(n2,time*0.85,1200.);\n        re1=re2;    \n    }\n    else if(time>40.0 && time <75.0)\n    {\n        re1=calbrot(n1,time*1.5,2400.);\n        re2=calbrot(n2,time*1.5,2700.);\n    }\n    else\n    {\n        re1=calbrot(n1,time*2.5,800.);\n        re2=calbrot(n2,time,1700.);\n    }\n    \n    sum=(re1+re2)/2.0;\n    return sum;\n}","name":"Sound","description":"","type":"sound"}]}