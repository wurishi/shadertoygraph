{"ver":"0.1","info":{"id":"sd2yDd","date":"1644357408","viewed":152,"name":"Improving gradient dithering","username":"subpixel","description":"Display divided into three rows:\n- Top: alternate dithering method (see comments)\n- Centre: no dithering\n- Bottom: old dithering\n\nChange LEVELS to 16 to demonstrate banding more easily\n\nSet LEVELS","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gradient","didther"],"hasliked":0,"parentid":"lscGDr","parentname":"Just A High-Quality Gradient"},"renderpass":[{"inputs":[],"outputs":[],"code":"// Original: https://www.shadertoy.com/view/lscGDr\n\n//\n// Demonstrates high-quality and proper gamma-corrected color gradient.\n//\n// Does interpolation in linear color space, mixing colors using smoothstep function.\n// Also adds some gradient noise to reduce banding.\n//\n// References:\n// http://blog.johnnovak.net/2016/09/21/what-every-coder-should-know-about-gamma/\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch24.html\n// http://loopit.dk/banding_in_games.pdf\n//\n// This shader is dedicated to public domain.\n//\n// 2022-02-09 subpixel@subpixels.com (SPXL)\n// - Dither along the gradient transition (\"t\") (before converting to sRGB)\n//   instead of adding greyscale noise to the sRGB gradient\n// - Note that the comment re the shadder being dedicated to the public domain\n//   is from the source at https://www.shadertoy.com/view/lscGDr and I am\n//   unable to verify the legitimacy of that dedication.\n\n#define SRGB_TO_LINEAR(c) pow((c), vec3(2.2))\n#define LINEAR_TO_SRGB(c) pow((c), vec3(1.0 / 2.2))\n#define SRGB(r, g, b) SRGB_TO_LINEAR(vec3(float(r), float(g), float(b)) / 255.0)\n\nconst vec3 COLOR0 = SRGB(0, 0, 0);\nconst vec3 COLOR1 = SRGB(0, 255, 0);\n\nconst float Dither1 = 4.0;  // Original dither strength\nconst float Dither2 = 0.05; // SPXL dither strength\n\nconst float LEVELS = float(256); // 256 is full bit-depth color resolution\n\n// Gradient noise from Jorge Jimenez's presentation:\n// http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat gradientNoise(in vec2 uv)\n{\n    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(uv, magic.xy)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 a; // First gradient point.\n    vec2 b; // Second gradient point.\n    if (iMouse == vec4(0.0)) {\n        a = 0.1 * iResolution.xy;\n        b = iResolution.xy;\n    } else {\n        a = abs(iMouse.zw);\n        b = iMouse.xy;\n    }\n\n    // Calculate interpolation factor with vector projection.\n    vec2 ba = b - a;\n    float t = dot(fragCoord - a, ba) / dot(ba, ba);\n    \n    // Saturate and apply smoothstep to the factor.\n    float t1 = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));\n    \n    // SPXL alternative: apply noise before saturating; moving along the color gradient, not adding grey\n    float t2_Dithered = smoothstep(0.0, 1.0, clamp(t + Dither2*(gradientNoise(fragCoord) - 0.5), 0.0, 1.0));\n    \n    // Interpolate.\n    vec3 grad1 = mix(COLOR0, COLOR1, t1);\n    vec3 grad2_Dithered = mix(COLOR0, COLOR1, t2_Dithered);\n\n    // Convert color from linear to sRGB color space (=gamma encode).\n    vec3 grad1_sRGB = LINEAR_TO_SRGB(grad1);\n    vec3 grad2_Dithered_sRGB = LINEAR_TO_SRGB(grad2_Dithered);\n\n    // Add gradient noise (greyscale) to reduce banding (original noise option)\n    vec3 grad1_sRGB_Dithered = grad1_sRGB + (Dither1/255.0) * gradientNoise(fragCoord) - (Dither1 * 0.5/255.0);\n    \n    // From bottom of screen to top: original dither, no dither, SPXL dither\n    vec3 color = uv.y < 0.333 ? grad1_sRGB_Dithered :\n                 uv.y < 0.666 ? grad1_sRGB\n                              : grad2_Dithered_sRGB;\n    \n    // Option to cut down the number of available output RGB levels to make the banding more obvious\n    fragColor = vec4(round(color*LEVELS) / LEVELS, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}