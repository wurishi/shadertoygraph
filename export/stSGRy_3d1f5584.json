{"ver":"0.1","info":{"id":"stSGRy","date":"1624109650","viewed":1387,"name":"Yet Another Atmosphere","username":"LVutner","description":"Yet another atmosphere. Have fun.","likes":48,"published":1,"flags":32,"usePreview":0,"tags":["sky","atmosphericscattering","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Another atmospheric scattering implementation on Shadertoy\n    Single scattering model.\n\n    Author:\n        @LVutner\n\n    Credits:\n        @Jessie - For Cornette-Shank phase function!\n        @Zabidon - For equirectangular projection function!\n\n    References:\n        https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n        https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/\n        https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\n        https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n        https://www.desmos.com/calculator/j0wozszdwa\n*/\n\n//Samples transmittance LUT\nvec3 sample_transmittance_lut(float height, float angle, as_data atmosphere)\n{\n    //Basically we invert the operations from Buffer A\n    vec2 uv;\n    uv.x = angle * 0.5 + 0.5;\n    uv.y = max(0.0, min(height * (1.0 / (atmosphere.rAtmos - atmosphere.rPlanet)), 1.0));\n\n    //Scaling\n    uv *= AS_LIGHT_RESOLUTION;\n    uv /= iChannelResolution[0].xy;\n\n    return texture(iChannel0, uv).xyz;\n}\n\n//Atmospheric scattering function.\nvec3 atmospheric_scattering(vec3 ray_origin, vec3 ray_direction, vec3 light_direction, as_data atmosphere) \n{\n    //Intersection\n    vec2 atmosphereDists = ray_sphere_intersection(ray_origin, ray_direction, atmosphere.rAtmos);\n    vec2 planetDists = ray_sphere_intersection(ray_origin, ray_direction, atmosphere.rPlanet);\n\n    //Logic\n    bool planetIntersected = planetDists.y >= 0.0;\n    bool atmosphereIntersected = atmosphereDists.y >= 0.0;\n    vec2 sd = vec2((planetIntersected && planetDists.x < 0.0) ? planetDists.y : max(atmosphereDists.x, 0.0), (planetIntersected && planetDists.x > 0.0) ? planetDists.x : atmosphereDists.y);\n\n    //Calculate step size\n    float step_size = length(sd.y - sd.x) / float(AS_MAIN_SAMPLES);\n\n    //Ray increment\n    vec3 ray_increment = ray_direction * step_size;\n\n    //Initial ray position\n    vec3 ray_position = ray_direction * sd.x + (ray_increment * 0.5 + ray_origin);\n\n    //Initialize accumulators for scattering and transmittance.\n    vec3 total_scattering = vec3(0.0);\n    vec3 total_transmittance = vec3(1.0);\n\n    //Calculate the Rayleigh and Mie phases.\n    float VL = dot(ray_direction, light_direction);\n    vec2 phases = vec2(phase_rayleigh(VL), phase_cs_mie(VL, atmosphere.gMie));\n    \n    //Sample the primary (view) ray.\n    for (int i = 0; i < AS_MAIN_SAMPLES; i++) \n\t{\n        //Calculate the height of the sample.\n        float height = length(ray_position) - atmosphere.rPlanet;\n\n        //Get densities\n        vec3 step_density = get_densities(height, atmosphere);\n        \n        //Get air mass\n        vec3 step_air_mass = step_density * step_size;\n        \n        //Get optical depth\n        vec3 step_optical_depth = atmosphere.kExtinction * step_air_mass;\n        \n        //Get transmittance\n        vec3 step_transmittance = exp(-step_optical_depth);\n\n        //Sample total transmittance of light ray\n        vec3 light_transmittance = sample_transmittance_lut(height, dot(normalize(ray_position), light_direction), atmosphere);\n\n        //Calculate single scattering contribution\n        vec3 scattering = atmosphere.kScattering * (phases.xy * step_air_mass.xy) * light_transmittance;\n\n        //Calculate scattering integral (Frostbite)\n        vec3 scattering_integral = (scattering - scattering * step_transmittance) / max(vec3(1e-8), step_optical_depth);\n\n        //Accumulate samples\n        total_scattering += scattering_integral * total_transmittance;\n        total_transmittance *= step_transmittance;\n\n        //Increment the primary ray time.\n        ray_position += ray_increment;\n    }\n    \n    vec3 color = atmosphere.iSun * total_scattering;\n    \n    //Add sun\n    color += get_sun(VL, atmosphere) * total_transmittance * float(!planetIntersected);\n\n    return color;\n}\n\n//Outputs Earth-like atmosphere\nvec3 get_sky_color(vec3 ray_origin, vec3 ray_direction, vec3 light_direction)\n{\n    //Initialize data struct\n    as_data atmosphere;\n    \n    //Planet\n    atmosphere.rPlanet = 6371e3; //Planet radius\n    atmosphere.rAtmos = 6471e3; //Atmosphere radius\n\n    //Rayleigh\n    atmosphere.kRlh = vec3(5.8e-6, 13.3e-6, 33.31e-6); //Rayleigh coefficient\n    atmosphere.shRlh = 8e3; //Rayleigh height\n    \n    //Mie\n    atmosphere.kMie = vec3(2.1e-6); //Mie coefficient\n    atmosphere.aMie = 0.9; //Mie albedo\n    atmosphere.shMie = 1.2e3; //Mie height\n    atmosphere.gMie = 0.8; //Mie asymetry\n    \n    //Ozone\n    atmosphere.kOzo = vec3(7.7295962e-7, 6.67717648e-7, 7.04931588e-7); //Ozone absorption coefficient\n    \n    //Scattering matrix\n    atmosphere.kScattering = mat2x3(atmosphere.kRlh, atmosphere.kMie);\n    \n    //Extinction matrix\n    atmosphere.kExtinction[0] = atmosphere.kRlh; //Rayleigh\n    atmosphere.kExtinction[1] = atmosphere.kMie / atmosphere.aMie; //Mie\n    atmosphere.kExtinction[2] = atmosphere.kOzo; //Ozone\n        \n    //Sun intensity\n    atmosphere.iSun = 42.0; //Just sun intensity\n   \n    //Output\n\treturn atmospheric_scattering(ray_origin, ray_direction, light_direction, atmosphere);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Ray origin\n    vec3 ray_origin = vec3(0.0, 6371e3 + 1e2, 0.0); //Small offset, ffs. \n\n    //Ray direction\n    vec3 ray_direction = equirectangular(fragCoord, iResolution.xy);\n    \n    //A bit dynamic light direction\n    vec3 light_direction = normalize(vec3(0.0, sin(iTime) * 0.5 + 0.5, 1.0));\n\n    //Get atmosphere\n    vec3 color = get_sky_color(ray_origin, ray_direction, light_direction);\n\n    //Apply tonemapping\n    color = color * ACESInputMat;    \n    color = RRTAndODTFit(color);    \n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n\n    //Convert from linear to sRGB space\n    color = pow(color, vec3(1.0 / 2.2));\n\n    //Output\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Another atmospheric scattering implementation on Shadertoy\n    Single scattering model.\n\n    Author:\n        @LVutner\n\n    Credits:\n        @Jessie - For Cornette-Shank phase function!\n        @Zabidon - For equirectangular projection function!\n\n    References:\n        https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n        https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/\n        https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\n        https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n        https://www.desmos.com/calculator/j0wozszdwa\n*/\n\n#define PI 3.141592\n#define AS_MAIN_SAMPLES 32 //Scattering steps\n#define AS_LIGHT_SAMPLES 32 //Transmittance steps\n#define AS_LIGHT_RESOLUTION vec2(256.0, 64.0) //Resolution of transmittance texture\n\n//Struct with data used in atmosphere scattering function\nstruct as_data\n{\n\tfloat rPlanet; //Planet radius\n    float rAtmos; //Atmosphere radius\n\n\tvec3 kRlh; //Rayleigh coefficient\n    float shRlh; //Rayleigh scattering height\n    \n    vec3 kMie; //Mie coefficients\n    float aMie; //Mie albedo\n    float shMie; //Mie scattering height\n    float gMie; //Mie anisotropy\n    \n\tvec3 kOzo; //Ozone extinction coefficient\n\n    mat2x3 kScattering; //Scattering coeff matrix\n    mat3x3 kExtinction; //Extinction coeff matrix\n\n    float iSun; //Sun luminance\n};\n\n//Rayleigh phase\nfloat phase_rayleigh(float VL)\n{\n    return (3.0 / (16.0 * PI)) * (1.0 + pow(VL, 2.0));\n}\n\n//Cornette-Shank Mie phase\nfloat phase_cs_mie(float VL, float g_coeff) \n{\n\tfloat g_coeff_sqr = g_coeff * g_coeff;\n\tfloat p1 = 3.0 * (1.0 - g_coeff_sqr) * (1.0 / (PI * (2.0 + g_coeff_sqr)));\n\tfloat p2 = (1.0 + (VL * VL)) * (1.0/pow((1.0 + g_coeff_sqr - 2.0 * g_coeff * VL), 1.5));\n    \n\tfloat phase = (p1 * p2);\n\tphase *= 0.25 / PI;\n    \n\treturn max(phase, 0.0);\n}\n\n//Returns density of mie/rlh/ozo\nvec3 get_densities(float height, as_data atmosphere)\n{\n    //Rayleigh density\n    float densityRlh = exp(-height / atmosphere.shRlh);\n    \n    //Mie density\n    float densityMie = exp(-height / atmosphere.shMie);\n    \n    //Ozone density\n    float densityOzo = exp(-max(0.0, (35e3 - height) - atmosphere.rAtmos) / 5e3) * exp(-max(0.0, (height - 35e3) - atmosphere.rAtmos) / 15e3); \n    \n    //Output\n    return vec3(densityRlh, densityMie, densityOzo);\n}\n\n\n//Ray sphere intersection function\nvec2 ray_sphere_intersection(vec3 position, vec3 direction, float radius) \n{\n\tfloat b = dot(position, direction);\n\tfloat c = dot(position, position) - radius * radius;\n\t\n\tfloat d = b * b - c;\n    \n\tif (d < 0.0)\n\t\treturn vec2(-1.0);\n\n\td = sqrt(d);\n\t\n\treturn vec2(-b - d, -b + d);\n}\n\n//ACES approximation\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n    1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit( in vec3 v ) \n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\n//Limb darkening model\nvec3 get_sun(float VdotL, as_data atmosphere)\n{\n    //Sun settings\n    float radius = 0.01;\n\n    vec3 u = vec3(1.0, 1.0, 1.0); // some models have u!=1\n    vec3 a = vec3(0.397, 0.503, 0.652); // coefficient for RGB wavelength (680 ,550 ,440)\n\n    float centerToEdge = clamp(acos(VdotL) / radius, 0.0, 1.0);\n    float sinTheta = sqrt(1.0 - centerToEdge * centerToEdge);\n    \n    vec3 factor = 1.0 - u * (1.0 - pow(vec3(sinTheta), a));\n    return factor * atmosphere.iSun;\n}\n\n//Equirectangular projectiom\nvec3 equirectangular(vec2 fragcoord, vec2 resolution)\n{\n    vec2 o = (fragcoord / resolution - 0.5) * PI * 2.0;\n    o.y *= 0.5;\n    return vec3(cos(o.x), tan(o.y), sin(o.x)) * cos(o.y);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Calculates transmittance for light ray\nvec3 calculate_light_transmittance(vec3 position, vec3 light_direction, as_data atmosphere)\n{\n    //Calculate the step size of the secondary (light) ray.\n    float step_size = ray_sphere_intersection(position, light_direction, atmosphere.rAtmos).y / float(AS_LIGHT_SAMPLES);\n\n    //Ray increment\n    vec3 ray_increment = light_direction * step_size;\n\n    //Initial ray position (we start from the centre)\n    vec3 ray_position = position + ray_increment * 0.5;\n\n    //Initialize transmittance accumulators for the secondary (light) ray.\n    vec3 total_transmittance = vec3(1.0);\n    \n    //Sample the secondary ray.\n    for (int i = 0; i < AS_LIGHT_SAMPLES; i++) \n    {\n        //Calculate the height of the sample.\n        float height = length(ray_position) - atmosphere.rPlanet;\n\n        //Get densities.\n        vec3 step_density = get_densities(height, atmosphere);\n        \n        //Get air mass\n        vec3 step_air_mass = step_density * step_size;\n        \n        //Get optical depth\n        vec3 step_optical_depth = atmosphere.kExtinction * step_air_mass;\n        \n        //Get transmittance\n        vec3 step_transmittance = exp(-step_optical_depth);\n        \n        //Accumulate samples\n        total_transmittance *= step_transmittance;\n\n        //Increment the secondary ray time.\n        ray_position += ray_increment;\n    }\n    return total_transmittance;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Do not render anything outside of our LUT dimmensions\n    //We add a tiny padding\n    if (fragCoord.x >= AS_LIGHT_RESOLUTION.x + 1.0 || fragCoord.y >= AS_LIGHT_RESOLUTION.y + 1.0)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n//This code is duplicated in Image tab.\n    //Initialize data struct\n    as_data atmosphere;\n\n    //Planet\n    atmosphere.rPlanet = 6371e3; //Planet radius\n    atmosphere.rAtmos = 6471e3; //Atmosphere radius\n\n    //Rayleigh\n    atmosphere.kRlh = vec3(5.8e-6, 13.3e-6, 33.31e-6); //Rayleigh coefficient\n    atmosphere.shRlh = 8e3; //Rayleigh height\n    \n    //Mie\n    atmosphere.kMie = vec3(2.1e-6); //Mie coefficient\n    atmosphere.aMie = 0.9; //Mie albedo\n    atmosphere.shMie = 1.2e3; //Mie height\n    atmosphere.gMie = 0.8; //Mie asymetry\n    \n    //Ozone\n    atmosphere.kOzo = vec3(7.7295962e-7, 6.67717648e-7, 7.04931588e-8); //Ozone absorption coefficient\n    \n    //Scattering matrix\n    atmosphere.kScattering = mat2x3(atmosphere.kRlh, atmosphere.kMie);\n    \n    //Extinction matrix\n    atmosphere.kExtinction[0] = atmosphere.kRlh; //Rayleigh\n    atmosphere.kExtinction[1] = atmosphere.kMie / atmosphere.aMie; //Mie\n    atmosphere.kExtinction[2] = atmosphere.kOzo; //Ozone\n        \n    //Sun intensity\n    atmosphere.iSun = 42.0; //Just sun intensity\n//End of duplicated code\n\n    //Calculate UVs (0 - 1)\n    vec2 uv = clamp(fragCoord.xy, vec2(0.0), AS_LIGHT_RESOLUTION.xy - 1.0) / AS_LIGHT_RESOLUTION.xy;\n\n    //Calculate height and angle for ro&rd vecs\n    float angle = uv.x * 2.0 - 1.0;\n    float height = uv.y * (atmosphere.rAtmos - atmosphere.rPlanet);\n\n    //Calculate ro and rd\n    vec3 ray_origin = vec3(0.0, atmosphere.rPlanet + height, 0.0);\n    vec3 ray_direction = vec3(sqrt(1.0 - angle * angle), angle, 0.0); //You might need to change that\n\n    //Generate LUT and output\n\tfragColor.xyz = calculate_light_transmittance(ray_origin, ray_direction, atmosphere);     \n \n}","name":"Buffer A","description":"","type":"buffer"}]}