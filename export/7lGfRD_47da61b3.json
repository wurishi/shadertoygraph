{"ver":"0.1","info":{"id":"7lGfRD","date":"1664151608","viewed":198,"name":"primitives in voxels, reflected","username":"jt","description":"Proof of concept / quick hack:\nadded one reflection to [url=https://www.shadertoy.com/view/flyfRz]primitives in voxels[/url]\n(commented-out ambient occlusion so it renders at the same speed).\nTODO: cleanup the code.\n","likes":8,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","reflection","voxels","raycasting","voxel","primitives","reflections","dda","reflected","textured","subobjects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/7lGfRD primitives in voxels, reflected by jt\n// based on https://www.shadertoy.com/view/flyfRz primitives in voxels by jt\n// based on https://www.shadertoy.com/view/NstSR8 Cast Voxels March Sub-Objects\n// efficient voxel tracing based on https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy) which implements DDA based on http://lodev.org/cgtutor/raycasting.html\n// Basic functionality (intersection & raymarching primitives) based on iq's https://iquilezles.org/articles/distfunctions\n\n// Testing iq's primitives in voxel-grid acceleration structure with one reflection.\n\n// tags: 3d, raymarching, reflection, voxels, raycasting, voxel, primitives, reflections, dda, reflected, textured, subobjects\n\n// MIT license, as in https://www.shadertoy.com/terms\n\n/*\n\nCopyright (c) 2022 Jakob Thomsen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\nfloat hash13(vec3 p3) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat hash(uint x)\n{\n    return float(triple32(x)) / float(0xffffffffU);\n}\n\nuint uhash(uvec2 v)\n{\n    return triple32(v.x + triple32(v.y));\n}\n\n//float hash(uvec2 v)\n//{\n//    return float(uhash(v)) / float(0xffffffffU);\n//}\n\nuint uhash(uvec3 v)\n{\n    return triple32(v.x + triple32(v.y + triple32(v.z)));\n}\n\n#define MAX_DIST 1000.0\n\n// https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// primitives from https://www.shadertoy.com/view/Xds3zN Raymarching - Primitives by iq\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2\n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1\n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n\n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n\n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n\n    vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n    float m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n\n    // exact distance\n    #if 1\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n    #endif\n\n    // bound, not exact\n    #if 0\n    return m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdHorseshoe( in vec3 p, in vec2 c, in float r, in float le, vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p.xy);\n    p.xy = mat2(-c.x, c.y,\n              c.y, c.x)*p.xy;\n    p.xy = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n                (p.x>0.0)?p.y:l );\n    p.xy = vec2(p.x,abs(p.y-r))-vec2(le,0.0);\n\n    vec2 q = vec2(length(max(p.xy,0.0)) + min(0.0,max(p.x,p.y)),p.z);\n    vec2 d = abs(q) - w;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat box2d(vec2 p)\n{\n    vec2 q = abs(p) - vec2(1.0);\n    return min(max(q.x,q.y), float(0.0)) + length(max(q, float(0.0)));\n}\n\n// https://www.shadertoy.com/view/NddGWs 2d Infinite Stairs SDF (my stairs function, improved by iq)\nfloat infinite_stairs_even2d(vec2 p, float n)\n{\n    p *= n; // scale by number of stairs\n    p = vec2(p.x+p.y,p.x-p.y)/float(4.0);\n    p = fract(p.x) + vec2(p.y,-p.y);\n    p = float(2.0)*p-float(1.0);\n    return box2d(p) / n;\n}\n\nfloat infinite_stairs_even(vec3 p, float n)\n{\n    return infinite_stairs_even2d(vec2(p.y, p.z), n);\n}\n\nfloat finite_stairs_even(vec3 p, float n)\n{\n    return max(infinite_stairs_even(p + 0.5 / n, n * 2.0), sdBox(p, vec3(1.0) / 2.0));\n    //return max(infinite_stairs_even(p + 0.5 / n - iTime * 0.1, n * 2.0), sdBox(p, vec3(1.0) / 2.0));\n}\n\nvec2 Union(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 sdMixed(vec3 p, uint idx) // returns distance & material\n{\n    vec2 res = vec2(MAX_DIST, 0.0);\n    if(idx == 1u) res = Union(res, vec2(sdSphere(p, 0.2), 26.9));\n    if(idx == 2u) res = Union(res, vec2(sdRhombus(p.xzy, 0.15, 0.25, 0.04, 0.08), 17.0));\n    if(idx == 3u) res = Union(res, vec2(sdCappedTorus(p, vec2(0.866025,-0.5), 0.25, 0.05), 25.0));\n    if(idx == 4u) res = Union(res, vec2(sdBoxFrame(p, vec3(0.3,0.25,0.2), 0.025), 16.9));\n    if(idx == 5u) res = Union(res, vec2(sdCone(p, vec2(0.6,0.8), 0.45), 55.0));\n    if(idx == 6u) res = Union(res, vec2(sdCappedCone(p, 0.25, 0.25, 0.1), 13.67));\n    if(idx == 7u) res = Union(res, vec2(sdSolidAngle(p, vec2(3,4)/5.0, 0.4), 49.13));\n    if(idx == 8u) res = Union(res, vec2(sdTorus(p.xzy, vec2(0.25,0.05)), 7.1));\n    if(idx == 9u) res = Union(res, vec2(sdBox(p, vec3(0.3,0.25,0.1)), 3.0));\n    if(idx == 10u) res = Union(res, vec2(sdCapsule(p, vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1), 31.9));\n    if(idx == 11u) res = Union(res, vec2(sdCylinder(p, vec2(0.15,0.25)), 8.0));\n    if(idx == 12u) res = Union(res, vec2(sdHexPrism(p, vec2(0.2,0.05)), 18.4));\n\n    //if(idx == 13u) res = Union(res, vec2(sdPyramid(p*2.0, 1.0))/2.0, 13.56);\n    if(idx == 14u) res = Union(res, vec2(sdOctahedron(p, 0.35), 23.56));\n    if(idx == 15u) res = Union(res, vec2(sdTriPrism(p, vec2(0.3,0.05)), 43.5));\n    if(idx == 16u) res = Union(res, vec2(sdEllipsoid(p, vec3(0.2, 0.25, 0.05)), 43.17));\n    if(idx == 17u) res = Union(res, vec2(sdHorseshoe(p, vec2(cos(1.3), sin(1.3)), 0.2, 0.3, vec2(0.03,0.08)), 11.5));\n\n    if(idx == 18u) res = Union(res, vec2(sdOctogonPrism(p, 0.2, 0.05), 51.8));\n    if(idx == 19u) res = Union(res, vec2(sdCylinder(p, vec3(0.1,-0.1,0.0), vec3(-0.2,0.35,0.1), 0.08), 31.2));\n    if(idx == 20u) res = Union(res, vec2(sdCappedCone(p, vec3(0.1,0.0,0.0), vec3(-0.2,0.40,0.1), 0.15, 0.05), 46.1));\n    if(idx == 21u) res = Union(res, vec2(sdRoundCone(p, vec3(0.1,0.0,0.0), vec3(-0.1,0.35,0.1), 0.15, 0.05), 51.7));\n    if(idx == 22u) res = Union(res, vec2(sdRoundCone(p, 0.2, 0.1, 0.3), 37.0));\n\n    return res;\n}\n\n#define halfboundsize 3\n\n#define PI 3.1415926\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nfloat blob(vec3 p)\n{\n    return step(0.5, length(fract(p)-0.5));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n#define EPSILON 0.001\n\n// raymarch subobject\nvec2 march(vec3 ro, vec3 rd, float tmin, float tmax, uint idx)\n{\n    for(float t = tmin; t < tmax;)\n    {\n        vec2 res = sdMixed(ro + rd * t, idx);\n        if(res.x < EPSILON)\n            return vec2(t, res.y);\n        t += res.x;\n    }\n    return vec2(MAX_DIST, 0.0);\n}\n\n// based on https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p, uint idx)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdMixed(p + k.xyy * h, idx).x +\n                     k.yyx * sdMixed(p + k.yyx * h, idx).x +\n                     k.yxy * sdMixed(p + k.yxy * h, idx).x +\n                     k.xxx * sdMixed(p + k.xxx * h, idx).x);\n}\n\nuint getIdx(ivec3 cell)\n{\n    if(any(lessThan(cell, ivec3(-2))) || any(greaterThan(cell, ivec3(2)))) return 0u;\n    //return uint(4 * (cell.y & 3) + (cell.x & 3)); // count from 0 to 15\n    return 1u + (uhash(uvec3(cell)) % 22u);\n//    return 0u;\n}\n\n// voxel with environment (3x3x3) slow!\nfloat sdMixedWithEnv(ivec3 cell, vec3 offset)\n{\n    float d = MAX_DIST;\n    // naive method: 3x3x3 voxels\n    //for(int z = -1; z <= +1; z++)\n    //{\n    //    for(int y = -1; y <= +1; y++)\n    //    {\n    //        for(int x = -1; x <= +1; x++)\n    //        {\n\n    // kastorp's optimization: traverse only 2x2 tiles (instead of 3x3),\n    // chosen depending on where in the tile the current point is located.\n    ivec3 oo = -ivec3(step(vec3(0), offset));\n    for(int z = oo.y; z <= oo.z+1; z++)\n    {\n        for(int y = oo.y; y <= oo.y+1; y++)\n        {\n            for(int x = oo.x; x <= oo.x+1; x++)\n            {\n                uint idx = getIdx(cell + ivec3(x, y, z));\n                d = min(d, sdMixed(offset - vec3(x, y, z), idx).x);\n            }\n        }\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/Xds3zN Raymarching - Primitives by iq\n// https://iquilezles.org/articles/distfunctions\nfloat calcAO(vec3 pos, vec3 nor)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.12*float(i) / 4.0;\n        ivec3 cell = ivec3(floor(pos + h*nor));\n        //uint id = getVoxelIndex(cell);\n        //float d = SDF_Voxel(pos + h*nor - vec3(cell) - vec3(0.5), id);\n        float d = sdMixedWithEnv(cell, pos + h*nor - vec3(cell) - vec3(0.5));\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if(occ > 0.35) break;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);\n}\n\n#define MAX_RAY_STEPS 64\n\nstruct result\n{\n    float dist;\n    ivec3 cell;\n    float material;\n};\n\nresult voxelray(vec3 rayPos, vec3 rayDir)\n{\n    result res;\n\n    vec3 deltaDist = 1.0 / abs(rayDir);\n    ivec3 rayStep = ivec3(sign(rayDir));\n    res.dist = MAX_DIST;\n    res.cell = ivec3(floor(rayPos));\n\n    vec3 sideDist = (sign(rayDir) * (vec3(res.cell) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; // Setup of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n\n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n    //for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to avoid crash on some systems\n    {\n        //if (all(lessThanEqual(sign(rayDir) * vec3(res.cell), vec3(halfboundsize)))) // proceed until ray LEAVES level-box (but ENTER is OK, so level can be seen from outside)\n        if(all(lessThan(abs(res.cell), ivec3(halfboundsize)))) // odd\n        //if(all(greaterThanEqual(cell, -ivec3(halfboundsize))) && all(lessThan(cell, ivec3(halfboundsize)))) // even\n        {\n            uint idx = getIdx(res.cell);\n            if(idx > 0u) // skip empty voxels\n            {\n                // Near bounding-box side can be reconstructed from dda, howvever we need far bounding-box side, too.\n                // float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir);\n                // It appears to be easier to just do the box-intersection here (potential for optimization).\n                vec2 bounds = boxIntersection( rayPos - vec3(res.cell) - vec3(0.5), rayDir, vec3(0.5) ); // bounding box\n\n                uint id = getIdx(res.cell);\n                if(id != 0u)\n                {\n                    vec2 r = march(rayPos - vec3(res.cell) - vec3(0.5), rayDir, bounds.x, bounds.y, idx);\n\n                    if(r.x >= bounds.x && r.x <= bounds.y)\n                    {\n                        if(r.x >= 0.0) // required to catch corner-cases when ray starts in wall behind camera (duplicate close objects bug)\n                        {\n                            res.dist = r.x;\n                            res.material = r.y;\n\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // \"The raycasting code is somewhat based around a 2D raycasting toutorial found here:\n        //  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n        // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n        bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        sideDist += vec3(mask) * deltaDist;\n        res.cell += ivec3(vec3(mask)) * rayStep;\n    }\n\n    return res;\n}\n\nstruct state\n{\n    vec3 color;\n    bool running;\n    vec3 rayPos;\n    vec3 rayDir;\n};\n\nstate render(vec3 rayPos, vec3 rayDir)\n{\n    state s;\n    s.color = vec3(0);\n\n    // BEWARE: omitting initialization CRASHED my system when running this offline (works fine in shadertoy, though)\n    s.running = false;\n    s.rayPos = vec3(0);\n    s.rayDir = vec3(0);\n\n    result res = voxelray(rayPos, rayDir);\n\n    if(res.dist < MAX_DIST)\n    {\n        vec3 lightdir = normalize(vec3(1.0,-2.0, 3.0));\n\n        uint idx = getIdx(res.cell);\n        vec3 dst = rayPos + rayDir * res.dist;\n\n        vec3 n = normal(dst - vec3(res.cell) - vec3(0.5), idx);\n\n        s.color = 0.2 + 0.2 * sin(res.material * 2.0 + vec3(0.0, 1.0, 2.0)); // color scheme from iq's primitives\n\n        float diffuse = max(dot(lightdir, n), 0.0);\n        vec3 hal = normalize(lightdir - rayDir);\n        float specular = pow(clamp( dot(n, hal), 0.0, 1.0), 16.0);\n             specular *= diffuse;\n             specular *= 0.04+0.96*pow(clamp(1.0-dot(hal,lightdir),0.0,1.0),5.0);\n        s.color += 5.00 * specular * vec3(1.30,1.00,0.70);\n\n        //float ao = calcAO(rayPos + rayDir * res.dist, n); // AO is SLOW (it needs to check 2x2x2 cells)\n        float ao = 1.0;\n        result shadow = voxelray(dst, lightdir);\n        float brightness = 0.1 * ao + diffuse * step(MAX_DIST, shadow.dist);\n\n        s.color *= brightness;\n\n        s.running = true; // reflection\n        s.rayPos = dst;\n        s.rayDir = reflect(rayDir, n);\n    }\n\n    return s;\n}\n\n// Coordinate-systems:\n//  * camera-coordinates: x,y aligned with screen, z towards viewer\n//  * world-coordinates: map-on-table, i.e. x,y on the map with additional z-coordinate for height\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayPos = vec3(0.0, mix(2.0, 0.5, (0.5 - 0.5 * cos(iTime/10.0))) * float(halfboundsize), 0.0);\n    vec3 rayDir = vec3(screenPos.x, screenPos.y, 2.0);\n    rayDir.yz = mat2(vec2(0.0, 1.0), vec2(-1.0, 0.0)) * rayDir.yz;\n\n    mat2 R = rotate(1.0 * iTime / 5.0);\n    rayPos.xy = R * rayPos.xy;\n    rayDir.xy = R * rayDir.xy;\n\n    rayDir = normalize(rayDir);\n\n    state s0 = render(rayPos, rayDir);\n    if(s0.running)\n    {\n        state s1 = render(s0.rayPos, s0.rayDir); // could add more reflections but already slow enough\n        s0.color += s1.color;\n    }\n\n    fragColor.rgb = sqrt(s0.color);\n}\n","name":"Image","description":"","type":"image"}]}