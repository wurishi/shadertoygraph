{"ver":"0.1","info":{"id":"4tycW3","date":"1537929976","viewed":450,"name":"Anisotropic Kuwahara v2","username":"kam19_77","description":"Anisotropic Kuwahara v2 by Jan Eric Kyprianidis","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265358979323846;\nconst int N = 8;\n\nconst float radius = 4.0;\nconst float alpha = 1.0;\nconst float q = 8.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 uv = fragCoord/src_size;\n\n    vec4 t = texture(iChannel0, uv);\n    float a = radius * clamp((alpha + t.w) / alpha, 0.1, 2.0); \n    float b = radius * clamp(alpha / (alpha + t.w), 0.1, 2.0);\n\n    float cos_phi = cos(t.z);\n    float sin_phi = sin(t.z);\n\n    mat2 R = mat2(cos_phi, -sin_phi, sin_phi, cos_phi);\n    mat2 S = mat2(0.5/a, 0.0, 0.0, 0.5/b);\n    mat2 SR = S * R;\n\n    int max_x = int(sqrt(a*a * cos_phi*cos_phi +\n                          b*b * sin_phi*sin_phi));\n    int max_y = int(sqrt(a*a * sin_phi*sin_phi +\n                          b*b * cos_phi*cos_phi));\n\n    \n    vec4 m[8];\n    vec3 s[8];\n    {\n    \tvec3 c = texture(iChannel2, uv).rgb;\n        float w = texture(iChannel1, vec2(0.5, 0.5)).x;\n        for (int k = 0; k < N; ++k) {\n            m[k] =  vec4(c * w, w);\n            s[k] = c * c * w;\n        }\n    }\n\n    for (int j = 0; j <= max_y; ++j)  {\n        for (int i = -max_x; i <= max_x; ++i) {\n            if ((j !=0) || (i > 0)) {\n                vec2 v = SR * vec2(i,j);\n\n                if (dot(v,v) <= 0.25) {\n                    vec3 c0 = texture(iChannel2, uv + vec2(i,j)/src_size).rgb;\n                    vec3 c1 = texture(iChannel2, uv - vec2(i,j)/src_size).rgb;\n\n                    vec3 cc0 = c0 * c0;\n                    vec3 cc1 = c1 * c1;\n\n                    vec4 w0123 = texture(iChannel1, vec2(0.5, 0.5) + v);\n                    for (int k = 0; k < 4; ++k) {\n                        m[k] += vec4(c0 * w0123[k], w0123[k]);\n                        s[k] += cc0 * w0123[k];\n                    }\n                    for (int k = 4; k < 8; ++k) {\n                        m[k] += vec4(c1 * w0123[k-4], w0123[k-4]);\n                        s[k] += cc1 * w0123[k-4];\n                    }\n\n                    vec4 w4567 = texture(iChannel1, vec2(0.5, 0.5) - v);\n                    for (int k = 4; k < 8; ++k) {\n                        m[k] += vec4(c0 * w4567[k-4], w4567[k-4]);\n                        s[k] += cc0 * w4567[k-4];\n                    }\n                    for (int k = 0; k < 4; ++k) {\n                        m[k] += vec4(c1 * w4567[k], w4567[k]);\n                        s[k] += cc1 * w4567[k];\n                    }\n                }\n            }\n        }\n    }\n    \n    \n    vec4 o = vec4(0.0);\n    for (int k = 0; k < N; ++k) {\n        m[k].rgb /= m[k].w;\n        s[k] = abs(s[k] / m[k].w - m[k].rgb * m[k].rgb);\n\n        float sigma2 = s[k].r + s[k].g + s[k].b;\n        float w = 1.0 / (1.0 + pow(255.0 * sigma2, 0.5 * q));\n\n        o += vec4(m[k].rgb * w, w);\n    }\n\n    fragColor = vec4(o.rgb / o.w, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 uv = fragCoord/src_size;\n    vec2 d = 1.0 / src_size;\n\n    vec3 c = texture(iChannel0, uv).xyz;\n    vec3 u = (\n           -1.0 * texture(iChannel0, uv + vec2(-d.x, -d.y)).xyz +\n           -2.0 * texture(iChannel0, uv + vec2(-d.x,  0.0)).xyz + \n           -1.0 * texture(iChannel0, uv + vec2(-d.x,  d.y)).xyz +\n           +1.0 * texture(iChannel0, uv + vec2( d.x, -d.y)).xyz +\n           +2.0 * texture(iChannel0, uv + vec2( d.x,  0.0)).xyz + \n           +1.0 * texture(iChannel0, uv + vec2( d.x,  d.y)).xyz\n           ) / 4.0;\n\n    vec3 v = (\n           -1.0 * texture(iChannel0, uv + vec2(-d.x, -d.y)).xyz + \n           -2.0 * texture(iChannel0, uv + vec2( 0.0, -d.y)).xyz + \n           -1.0 * texture(iChannel0, uv + vec2( d.x, -d.y)).xyz +\n           +1.0 * texture(iChannel0, uv + vec2(-d.x,  d.y)).xyz +\n           +2.0 * texture(iChannel0, uv + vec2( 0.0,  d.y)).xyz + \n           +1.0 * texture(iChannel0, uv + vec2( d.x,  d.y)).xyz\n           ) / 4.0;\n    \n    vec3 col = vec3(dot(u, u), dot(v, v), dot(u, v));\n    //col = floor(col * 255.0) / 255.0;\t// denoise\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define DEBUG_VIEW_STRUCTURE_TENSOR\t\t0\n#define SMOOTHED_STRUCTURE_TENSOR\t\t1\n\nconst float sigma = 2.5;\n    \nvec3 gauss (vec2 uv, vec2 src_size, float sigma) {\n#if SMOOTHED_STRUCTURE_TENSOR\n    float twoSigma2 = 2.0 * sigma * sigma;\n    int halfWidth = int(ceil( 2.0 * sigma ));\n    \n    vec3 sum = vec3(0.0);\n    float norm = 0.0;\n    if (halfWidth > 0) {\n        for ( int i = -halfWidth; i <= halfWidth; ++i ) {\n            for ( int j = -halfWidth; j <= halfWidth; ++j ) {\n                float d = length(vec2(i,j));\n                float kernel = exp( -d *d / twoSigma2 );\n                vec3 c = texture(iChannel0, uv + vec2(i,j) / src_size ).rgb;\n                sum += kernel * c;\n                norm += kernel;\n            }\n        }\n    } else {\n        sum = texture(iChannel0, uv).rgb;\n        norm = 1.0;\n    }\n    return sum / norm;\n#else\n    return texture(iChannel0, uv).rgb;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 uv = fragCoord / src_size;\n\n#if DEBUG_VIEW_STRUCTURE_TENSOR\n    fragColor = vec4(gauss(uv, src_size, sigma), 1.0);\n#else\t// DEBUG_VIEW_STRUCTURE_TENSOR\n    vec3 g = gauss(uv, src_size, sigma).xyz;\n\n    float lambda1 = 0.5 * (g.y + g.x +\n        sqrt(g.y*g.y - 2.0*g.x*g.y + g.x*g.x + 4.0*g.z*g.z));\n    float lambda2 = 0.5 * (g.y + g.x -\n        sqrt(g.y*g.y - 2.0*g.x*g.y + g.x*g.x + 4.0*g.z*g.z));\n\n    vec2 v = vec2(lambda1 - g.x, -g.z);\n    vec2 t;\n    if (length(v) > 0.0) { \n        t = normalize(v);\n    } else {\n        t = vec2(0.0, 1.0);\n    }\n\n    float phi = atan(t.y, t.x);\n\n    float A = (lambda1 + lambda2 > 0.0)?\n        (lambda1 - lambda2) / (lambda1 + lambda2) : 0.0;\n\n    fragColor = vec4(t, phi, A);\n#endif\t// DEBUG_VIEW_STRUCTURE_TENSOR\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float PI = 3.14159265358979323846;\nconst int N = 8;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 uv = fragCoord/src_size;\n\n    float PIN = 2.0 * PI / float(N);\n    float halfPIN = 0.5f * PIN;\n    mat2 X = mat2(cos(-PIN), sin(-PIN), -sin(-PIN), cos(-PIN));\n    \n    vec2 l0 = vec2(1.0f, 0.0f);\n    vec2 l1 = uv - vec2(0.5f, 0.5f);\n    \n    vec4 col = vec4(0.0f);\n    if (dot(l1, l1) < 0.25f) {\n        if (acos(dot(l0, normalize(l1))) <= halfPIN) {\n            col.r = 1.0f;\n        }\n        \n        l0 *= X;\n        \n        if (acos(dot(l0, normalize(l1))) <= halfPIN) {\n            col.g = 1.0f;\n        }\n\n        l0 *= X;\n        \n        if (acos(dot(l0, normalize(l1))) <= halfPIN) {\n            col.b = 1.0f;\n        }\n        \n        l0 *= X;\n        \n        if (acos(dot(l0, normalize(l1))) <= halfPIN) {\n            col.a = 1.0f;\n        }\n\t}\n    \n    fragColor = col;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const float PI = 3.14159265358979323846;\n\nconst float Sigma = 5.0f;\nconst float Sigma2 = Sigma * Sigma;\nconst int Radius = int(ceil(Sigma * 2.0f));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 uv = fragCoord/src_size;\n    \n    vec4 accum = vec4(0.0);\n    for (int y = -Radius; y < Radius; ++y) {\n        for (int x = -Radius; x < Radius; ++x) {\n            vec4 c = texture(iChannel0, uv + vec2(x, y) / src_size);\n            float r = dot(vec2(x,y), vec2(x,y));\n            accum += exp(-r / (2.0f * Sigma2)) / (2.0f * PI * Sigma2) * c;\n        }\n    }\n    \n    fragColor = accum;\n}","name":"Buffer D","description":"","type":"buffer"}]}