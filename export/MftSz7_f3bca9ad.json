{"ver":"0.1","info":{"id":"MftSz7","date":"1714747127","viewed":69,"name":"Energy Cube","username":"Ruzzyr","description":"A simple shader of an energy cube. A play on standard raymarching.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","simple","cube","pattern","energy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Not mine.\nvec4 QuanternionMul(vec4 q1, vec4 q2) {\n    vec3 crossProduct = cross(q1.xyz, q2.xyz);\n    float dotProduct = dot(q1.xyz, q2.xyz);\n    return vec4(crossProduct + q1.w*q2.xyz + q2.w*q1.xyz, q1.w*q2.w - dotProduct);\n}\n\n// Not mine.\nvec4 QuanternionRot(vec3 axis, float angle) {\n    float halfAngle = angle * 0.5;\n    float s = sin(halfAngle);\n    return vec4(axis * s, cos(halfAngle));\n}\n\n// Not mine. A standard quaternion rotation.\nvec3 Rotate3D(vec3 p, vec3 axis, float angle) {\n        vec4 quat = QuanternionRot(normalize(axis), angle);\n        return QuanternionMul(QuanternionMul(quat, vec4(p, 0.0)), vec4(-quat.xyz, quat.w)).xyz;\n}\n\n// SDF of a cube. \nfloat CubeDistanceFunction(vec3 rayMarchPoint, vec3 boxOrigin, vec3 boxDimensions)\n{\n    // Rotation of the cube is a function of time. \n    vec3 boxPosOffset = Rotate3D(rayMarchPoint, vec3(1.,1.,1.), iTime) - boxOrigin;\n    return length(max(abs(boxPosOffset) - boxDimensions, 0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Gathering all the necessary information for raymarching.\n    vec2 uvCentral = uv*2. - 1.;\n    vec2 uvAspectRatio = vec2(uvCentral.x * iResolution.x/iResolution.y, uvCentral.y);\n    vec3 cameraOrigin = vec3( uvAspectRatio, 3.);\n    vec3 sphereOrigin = vec3(0., 0., 0.);\n    vec3 cameraVecDirection = normalize(vec3(uvAspectRatio, -2.));\n    \n    float t = 0.;\n    float attenuation = 0.;\n    \n    // Standard raymarching.\n    for (int i = 0; i < 16; i++)\n    {\n        vec3 p = t*cameraVecDirection + cameraOrigin;\n\n        float d = CubeDistanceFunction(p, sphereOrigin, vec3(0.5));\n        \n        // The main magic happens here. At every step we add \n        {\n            float radius = 0.1+float(i)*0.5;        \n            float lineThickness = 0.02 + (pow(float(i)/16., 5.)*128.*abs(sin(iTime*0.6)*2.))*0.05;\n\n            vec3 o = sin(p*10. + iTime)*0.5;\n            float dist = length(p + o);\n            float condition = smoothstep(dist, dist + 0.1, radius)\n                            - smoothstep(dist, dist + 0.1, radius - lineThickness);\n            attenuation += condition;\n        }\n        \n        t += d;\n    }\n    \n    // color is a function of time  and attenuation.\n    fragColor = vec4(attenuation*(0.05 + abs(vec3(sin(iTime+0.1),2.*cos(iTime+1.),4.*cos(iTime)))), 1.);\n}","name":"Image","description":"","type":"image"}]}