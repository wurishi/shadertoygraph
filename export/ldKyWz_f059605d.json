{"ver":"0.1","info":{"id":"ldKyWz","date":"1521660916","viewed":223,"name":"Lake.","username":"Pr0fed","description":"Getting more point into mixing colors of different noises. Still 2DVoronoi + 3DPerlin though.\nHow is my cool zooming effect?)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["proceduraltexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-- 2D Worley noise. -------------------------------------------------------\n\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\nfloat worley2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    \n    return 1.0 - dis;\n}\n\n//--------------------------------------------------------------------------\n\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// 3D Gradient noise by Iq.\nfloat noise3D( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f * f * (3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n#define NUM_OCTAVES 8\n\nfloat fbm ( in vec2 _st, float n) \n{\n    float v = 0.075;\n    float a = 0.5;\n    \n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.25), sin(1.25),\n                    -sin(1.25), cos(0.25));\n    \n    for (int i = 0; i < NUM_OCTAVES; ++i) \n    {\n        v += a * noise3D(vec3(_st, 0.5));\n        _st = rot * _st * 2.5;\n        \n        // Need to clamp, or it is very soft when camera is away and very sharp when near.\n        a *= clamp(n, 0.3, 0.65);\n    }\n    \n    return v;\n}\n\n// Colors.\nvec3 DirtyOrange = vec3(0.500, 0.375, 0.000);\nvec3 LightBlue = vec3(0.000, 0.478, 0.950);\nvec3 LightGreen = vec3(0.161, 0.739, 0.160);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Basic normalization.\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = -0.95 + 2.0 * q;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Centering the lake.\n    uv.y += 0.2;\n    \n    \n    float n = (-sin(iTime * 0.2) * 3.);\n\t\n    // Not sure why it is 'n'. I guess i should name it 'z' for zoom or smth. else.\n    uv *= 4. + n;\n    \n    float w = worley2D(vec2(fbm(0.33 * uv, -(n / 3.)))) * fbm(uv * 0.65, -(n / 3.));\n    \n    float grass = fbm(uv * 0.5, -(n / 3.));\n        \t  \n    vec3 col = vec3(w * 4.0);\n    \n    vec3 grassCol = LightGreen * vec3(grass);\n\t\n    // LightBlue color tweaking works like a charm.\n    // But i still didn't get full idea behind mixing more then 2 colors.\n    // I mean, if you change LightGreen it won't work as if you change LightBlue one channels.\n    // (obviously cause i'm doing \"1.0 - \" but i didn't figure out how to make it correct yet. \n    // I mean all the blending, with keeping the color channels input stable and correct.\n    col = mix((DirtyOrange * 0.9) * ((1.0 - (grassCol + grassCol)) * 1.35),\n              LightBlue * 1.1,\n              clamp((col * col), 0., 1.));   \n\n    // Output to screen.\n    fragColor = vec4((col * col) * 2., 1.0);\n}","name":"Image","description":"","type":"image"}]}