{"ver":"0.1","info":{"id":"Mf3cR8","date":"1730224246","viewed":87,"name":"Exact Heptadecagon Algebra","username":"rikr","description":"I never did an elementary construction of a heptadecagon before so I gave it a try and made it into shader code... Made By Rik Riesmeijer - No Rights Reserved. License: CC0, Released To The Public Domain.","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["cycle","circle","ring","tower","dots","sqrt","coloring","algebra","compass","17","ruler","cyclic","construct","heptadecagon","surd","extensions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Exact Heptadecagon Algebra.\n// Made By Rik Riesmeijer - No Rights Reserved.\n// License: CC0, Released To The Public Domain.\n\n// One color for each point of the heptadecagon.\nvec4 cl01 = vec4(1.0, 1.0, 1.0, 1);\nvec4 cl02 = vec4(0.6, 0.0, 0.8, 1);\nvec4 cl03 = vec4(0.5, 0.5, 1.0, 1);\nvec4 cl04 = vec4(0.3, 0.7, 0.5, 1);\nvec4 cl05 = vec4(0.6, 0.4, 0.8, 1);\nvec4 cl06 = vec4(0.9, 0.4, 0.9, 1);\nvec4 cl07 = vec4(1.0, 0.7, 1.0, 1);\nvec4 cl08 = vec4(0.4, 0.7, 0.9, 1);\nvec4 cl09 = vec4(0.5, 0.9, 0.6, 1);\nvec4 cl10 = vec4(0.5, 1.0, 0.7, 1);\nvec4 cl11 = vec4(0.9, 0.4, 0.4, 1);\nvec4 cl12 = vec4(0.8, 1.0, 0.2, 1);\nvec4 cl13 = vec4(0.9, 0.8, 0.0, 1);\nvec4 cl14 = vec4(0.8, 0.2, 1.0, 1);\nvec4 cl15 = vec4(1.0, 0.4, 0.0, 1);\nvec4 cl16 = vec4(0.0, 1.0, 0.1, 1);\nvec4 cl17 = vec4(1.0, 0.7, 0.7, 1);\n\n// Euclidean norm based distance function.\nfloat dist(vec2 x, vec2 y) {\n    return length(x - y);\n}\n\n// Shaping function for color blending.\nfloat smst(float x) {\n    return smoothstep(0.2, 0.1, x);\n}\n\n// Main shader function.\nvoid mainImage(out vec4 y, vec2 z) {\n    // Some repeatedly used constants.\n    const float Z = 0.0;\n    const float M = 0.5;\n    const float U = 1.0;\n    const float T = 2.3;\n\n    // Normalizing screen coordinate scale.\n    z = z - M * iResolution.xy;\n    z = T * z / iResolution.yy;\n    \n    // All of the numbers we will need in construction.\n    const float A = -float(1      );\n    const float S =  float(16     );\n    const float B =  float(17     );\n    const float C =  float(34     );\n    const float D =  float(68     );\n    const float E =  float(2448   );\n    const float F =  float(2720   );\n    const float G =  float(6284288);\n    \n    // First layer of extension tower.\n    float a = D + sqrt(E);\n    float b = D - sqrt(E);\n    float c = F + sqrt(G);\n    float d = F - sqrt(G);\n    float e = A + sqrt(B);\n    float f = A - sqrt(B);\n    float g = C + sqrt(D);\n    float h = C - sqrt(D);\n    \n    // Second layer of extension tower.\n    float i = a + sqrt(c);\n    float j = a - sqrt(c);\n    float k = b + sqrt(d);\n    float l = b - sqrt(d);\n    float m = e + sqrt(h);\n    float n = e - sqrt(h);\n    float o = f + sqrt(g);\n    float p = f - sqrt(g);\n    \n    // Third layer of extension tower.\n    float q = n - sqrt(i);\n    float r = m + sqrt(j);\n    float s = p - sqrt(l);\n    float t = n + sqrt(i);\n    float u = p + sqrt(l);\n    float v = o + sqrt(k);\n    float w = o - sqrt(k);\n    float x = m - sqrt(j);\n    \n    // Making values unitary.\n    float qn = q / S;\n    float rn = r / S;\n    float sn = s / S;\n    float tn = t / S;\n    float un = u / S;\n    float vn = v / S;\n    float wn = w / S;\n    float xn = x / S;\n    \n    // Difference of x squared and radius squared.\n    float qq = qn * -qn + U;\n    float rr = rn * -rn + U;\n    float ss = sn * -sn + U;\n    float tt = tn * -tn + U;\n    float uu = un * -un + U;\n    float vv = vn * -vn + U;\n    float ww = wn * -wn + U;\n    float xx = xn * -xn + U;\n    \n    // Unitary y coordinates for each x coordinate.\n    float qm = sqrt(qq);\n    float rm = sqrt(rr);\n    float sm = sqrt(ss);\n    float tm = sqrt(tt);\n    float um = sqrt(uu);\n    float vm = sqrt(vv);\n    float wm = sqrt(ww);\n    float xm = sqrt(xx);\n    \n    \n    // ------------------------------------------|\n    // START OF HEPTADECAGON EXACT COORDINATES.  |\n    // ------------------------------------------|\n    \n    vec2 qp = vec2(qn, qm); // X and Y in 2d.\n    vec2 rp = vec2(rn, rm);\n    vec2 sp = vec2(sn, sm);\n    vec2 tp = vec2(tn, tm);\n    vec2 up = vec2(un, um);\n    vec2 vp = vec2(vn, vm);\n    vec2 wp = vec2(wn, wm);\n    vec2 xp = vec2(xn, xm);\n    vec2 qc = vec2(qn, -qm); // Complements.\n    vec2 rc = vec2(rn, -rm);\n    vec2 sc = vec2(sn, -sm);\n    vec2 tc = vec2(tn, -tm);\n    vec2 uc = vec2(un, -um);\n    vec2 vc = vec2(vn, -vm);\n    vec2 wc = vec2(wn, -wm);\n    vec2 xc = vec2(xn, -xm);\n    vec2 ru = vec2(U, Z);    // Final Re unit.\n    \n    // ------------------------------------------|\n    // END OF ALGEBRAIC HEPTADECAGON COORDINATES.|\n    // ------------------------------------------|\n    \n    \n    // Calculate screen distance to each point.\n    float dqp = dist(z, qp);\n    float drp = dist(z, rp);\n    float dsp = dist(z, sp);\n    float dtp = dist(z, tp);\n    float dup = dist(z, up);\n    float dvp = dist(z, vp);\n    float dwp = dist(z, wp);\n    float dxp = dist(z, xp);\n    \n    // Calculate screen distance to each complementary point.\n    float dqc = dist(z, qc);\n    float drc = dist(z, rc);\n    float dsc = dist(z, sc);\n    float dtc = dist(z, tc);\n    float duc = dist(z, uc);\n    float dvc = dist(z, vc);\n    float dwc = dist(z, wc);\n    float dxc = dist(z, xc);\n    \n    // Calculate screen distance to real unit.\n    float dru = dist(z, ru);\n    \n    // Initialize output color.\n    y = vec4(Z);\n    \n    // Color the real unit shaped distance.\n    y = smst(dru) * cl01 + y;\n    \n    // Color the upper points by shaped distance.\n    y = smst(dqp) * cl02 + y;\n    y = smst(drp) * cl03 + y;\n    y = smst(dsp) * cl04 + y;\n    y = smst(dtp) * cl05 + y;\n    y = smst(dup) * cl06 + y;\n    y = smst(dvp) * cl07 + y;\n    y = smst(dwp) * cl08 + y;\n    y = smst(dxp) * cl09 + y;\n    \n    // Color the lower points by shaped distance.\n    y = smst(dqc) * cl10 + y;\n    y = smst(drc) * cl11 + y;\n    y = smst(dsc) * cl12 + y;\n    y = smst(dtc) * cl13 + y;\n    y = smst(duc) * cl14 + y;\n    y = smst(dvc) * cl15 + y;\n    y = smst(dwc) * cl16 + y;\n    y = smst(dxc) * cl17 + y;\n}\n","name":"Image","description":"","type":"image"}]}