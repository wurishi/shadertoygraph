{"ver":"0.1","info":{"id":"4lK3DK","date":"1476875012","viewed":2386,"name":"Equirectangular image viewer","username":"rosme","description":"Combines two other shadertoy shaders to mimic YouTube 360 video rendering\nFirst pass to generate equirectangular image from cubemaps. Copied from https://www.shadertoy.com/view/XsBSDR\nSecond pass used equirectangular input for 360 viewing experience. ","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["cubemap","youtube","equirectangular","360"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modification of\n//\n// No Geometry 360 Video\n// By KylBlz\n// https://www.shadertoy.com/view/Ml33z2\n\n#define PI 3.14159265\n#define DEG2RAD 0.01745329251994329576923690768489\n\nfloat hfovDegrees = 120.0;\nfloat vfovDegrees = 60.0;\n\n//tools\nvec3 rotateXY(vec3 p, vec2 angle) {\n    vec2 c = cos(angle), s = sin(angle);\n    p = vec3(p.x, c.x*p.y + s.x*p.z, -s.x*p.y + c.x*p.z);\n    return vec3(c.y*p.x + s.y*p.z, p.y, -s.y*p.x + c.y*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //place 0,0 in center from -1 to 1 ndc\n    vec2 uv = fragCoord.xy * 2./iResolution.xy - 1.;\n\t\n    //to spherical\n    vec3 camDir = normalize(vec3(uv.xy * vec2(tan(0.5 * hfovDegrees * DEG2RAD), tan(0.5 * vfovDegrees * DEG2RAD)), 1.0));\n    \n    //camRot is angle vec in rad\n    vec3 camRot = vec3( ((iMouse.xy / iResolution.xy) - 0.5) * vec2(2.0 * PI,  PI), 0.);\n    \n    //rotate\n    vec3 rd = normalize(rotateXY(camDir, camRot.yx));\n    \n    //radial azmuth polar\n    vec2 texCoord = vec2(atan(rd.z, rd.x) + PI, acos(-rd.y)) / vec2(2.0 * PI, PI);\n\n    fragColor = texture(iChannel0, texCoord);\n    \n    // Uncomment to visualize input\n    //fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Cube map to equirectangular map\n// By BeRo\n// https://www.shadertoy.com/view/XsBSDR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texCoord = fragCoord.xy / iResolution.xy; \n    vec2 thetaphi = ((texCoord * 2.0) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n\tfragColor = texture(iChannel0, rayDirection);\n    // for apply the equirectangular map like a cubemap:\n    // rayDirection = normalize(rayDirection);\n    // texture(uTexEnvMap, vec2((atan(rayDirection.z, rayDirection.x) / 6.283185307179586476925286766559) + 0.5, acos(rayDirection.y) / 3.1415926535897932384626433832795));    \n}","name":"Buf A","description":"","type":"buffer"}]}