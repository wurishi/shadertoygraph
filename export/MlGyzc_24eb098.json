{"ver":"0.1","info":{"id":"MlGyzc","date":"1537212088","viewed":368,"name":"Fractal emoji","username":"Aspect","description":"A Julia set that really makes you think. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","juliaset","thinking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A julia set combined with a \"thinking emoji\" procedural orbit trap. Dedicated to kisamegr\n//The code is a mess. I'm going to clean up the leftovers later. It was supposed to be a quick fun little thing\n//but it ended up being a pain to finish.\n\n#define PI 3.1415926535\nfloat fun2(in vec2 z)\n{\nreturn length(max(abs(z+texture(iChannel0,z).xy*0.1)-(+vec2(0.14*(1.0),0.14)),0.0))   ;\n}\n\nmat2 rot( in float a,in vec2 p ) \n{\n    float c = cos(a*p.y);\n    float s = sin(a*p.y);\n\treturn mat2(c,-s,s,c);\t\n}\n\nmat2 rotf( in float a) \n{\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,-s,s,c);\t\n}\n\nfloat sminc( float a, float b,float k )\n{\n   \n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h/(6.0*k*k);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return (length(p) - r);\n}\n\nfloat udSquare( vec2 p, float s )\n{\n  return length( max(abs(p)-s,vec2(0)) );\n}\n\nfloat sdcLine( in vec2 p, in vec2 a, in vec2 b )\n{\n  \tp=rot(-0.85,p)*p;\n    a=rot(-0.85,a)*a;\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n   float dist=(length( pa - (ba)*h ))-0.15;\n\treturn dist*0.25;\n}\n\nfloat sdccLine( in vec2 p, in vec2 a, in vec2 b )\n{\n  \tp=rot(-0.85,p)*p*1.6;\n    a=rot(-1.15,a)*a*1.;\n    b*=1.0;\n\tvec2 pa = p-a;\n    vec2  ba = b-a;\n    ba=rot(-0.425,ba)*ba*1.2;\n    pa=rot(-0.325,pa)*pa*1.5;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn (length( pa - (ba)*h )-1.0);\n}\n\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn 1.0*(abs(length( pa - (ba)*h )-0.1)-0.25);\n}\n\n\n\n\n\n\n\n\nfloat fun1(in vec2 p)\n{\n    const float k = sqrt(0.040);\n    \n     p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x -= clamp( p.x, -3.0, 0.0 );\n   return -length(p)*sign(p.y)*0.01;\n   \n}\n\nfloat fun3(in vec2 p)\n{\n  const float r=0.04;\n  const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n\n    return length(p-vec2(clamp(p.x,-r*k.z,r*k.z),r))*sign(p.y-r);   \n}\nfloat annularfun3(in vec2 p)\n{\n return abs(fun3(p))-0.01;\n}\n\nfloat annularCircle(in vec2 p,float r)\n{\n return abs(sdCircle(p,r)-0.02);\n}\n\nfloat opu(float d1,float d2)\n{\n    return (d1<d2) ? d1:d2;\n}\nfloat ops( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nfloat thinking(in vec2 p,in vec2 uv)\n{\n    //mouth\n    vec2 linea= vec2(0.0,0.0);\n    vec2 lineb= vec2(0.7,0.7);\n      \n    \n    //brows\n    vec2 linea1= vec2(0.0,0.0);\n    vec2 lineb1= vec2(0.6,0.6);\n    \n    vec2 linea2= vec2(0.0,0.0);\n    vec2 lineb2= vec2(0.6,0.6);\n    \n    //fingers\n    vec2 lineaz= vec2(0.0,0.0);\n    vec2 linebz= vec2(1.3,1.3);\n    \n    vec2 lineazz= vec2(0.0,0.0);\n    vec2 linebzz= vec2(1.6,1.6);\n    \n    \n  //head\n   float mini= opu(sdCircle(p+vec2(-0.025,-0.13),0.03),sdCircle(p+vec2(0.085,-0.05),0.03));\n   mini=opu(mini,annularCircle(p,0.262));\n   mini=opu(mini, sdcLine((p+vec2(-0.015,0.030))*8.1,lineb,linea)); //mouth\n   mini=opu(mini, sdcLine((rotf(0.24)*p+vec2(-0.015,-0.12))*10.1,lineb1,linea1)); //brows\n   mini=opu(mini, sdcLine((p+vec2(0.19,-0.065))*10.1,lineb2,linea2));\n\n    \n    //hand\n    p+=vec2(-0.06,0.08);\n    vec2 finoffs1=vec2(0.07,0.220);\n    vec2 finoffs2=vec2(0.06,0.28);\n    vec2 finoffs3=vec2(0.045,0.3);\n    \n    \n   p= rotf(0.45)*p;\n   mini=sminc(mini,sdCircle(p+vec2(0.1,0.215),0.10),0.1);\n   mini=sminc(mini,sdLine((rotf(-0.14)*p+vec2(0.085,0.140))*9.5,linebzz,lineazz),0.5);\n    mini=sminc(mini,sdccLine((rotf(-2.64)*p+vec2(-0.195,0.040))*10.,linebz,lineaz),1.1);\n   mini=sminc(mini,sdLine((rotf(-0.19)*p+finoffs1)*11.1,linebz,lineaz),0.5);\n   mini=sminc(mini,sdLine((rotf(-0.14)*p+finoffs2)*11.6,linebz,lineaz),0.5);\n    mini=sminc(mini,sdLine((rotf(-0.19)*p+finoffs3)*14.1,linebz,lineaz),0.2);\n   \n    \n    \n  return abs(mini)*15.5;   \n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; \n     screenPos.x *= iResolution.x / iResolution.y; \n\t\t\n    float tz = 22.5+0.5*cos(0.0024*(iTime)*(iTime));\n    vec2 c = vec2(0.8-0.07*tz,0.1500);\n    vec2 z = vec2((screenPos*0.7*cos(sqrt(0.1*iTime))+vec2(1.25-0.2,-0.2-0.03*cos(sqrt(iTime)))))+vec2(-1.21,0.10);\n\tvec2 zder = vec2(texture(iChannel0,z).xy*0.06);\t\n    float howclose=0.;\nfloat modsquared=dot(z,z);\n        float fracdist=0.;\n    float fracdistg=999.;\n    float fracdistb=0.;\n    float flagd=0.0;\n    \n    vec2 v0 = vec2(1.3,0.9)*cos(iTime*1.1 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*1.2 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*1.3 + vec2(2.0,1.0) );\n\n\tfor(int i=0;i<60;++i)\n    {\n\t    if(sqrt(modsquared)>2.0)\n        {\n\t\t\thowclose=float(i);\n\t\t\tbreak;\n            flagd+=1.;\n\n        }\n\t\t\n        zder=2.*vec2(z.x*zder.x-z.y*zder.y,+z.x*zder.y+z.y*zder.x)+vec2(1.0,0.0);\n        z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y) + c;\n        z = z;\n\t\t modsquared=dot(z,z);\n        \n        \n       \tfloat epsd=1.5; \n        //vec2 bpoint=0.095*tz*(z-vec2(0.01))+0.01*texture(iChannel0,z*tz).xy;\n      //  vec2 bpoint=((z+vec2(epsd,epsd))+(z+vec2(epsd,-epsd))+(z+vec2(-epsd,epsd))+(z+vec2(-epsd,-epsd)))/2.5;\n        fracdistg=min(fracdistg*0.85,1.15*thinking(z*2.26,screenPos));\n \n    }\n    fracdist=sqrt((modsquared)/(0.5*dot(zder,zder)))*log(modsquared);\n    //fracdistg= fracdist + tz* texture(iChannel0,screenPos).x;\n    fracdistb= fracdist + tz*texture(iChannel0,screenPos).y; \n    \n    howclose=3.5*exp(howclose/32.);\n    \n    fracdistg=sqrt(fracdistg);\n    \n    \n    if(flagd>0.)\n    {\n     fracdistg+=   tz*0.1*texture(iChannel0,screenPos).y;\n    }\n    \n    \n    fracdist= clamp( fracdist*(0.45*tz*pow(15.1,0.95)), 0.0, 1.0 );\n    fracdistg=clamp( fracdistg*((tz)*0.1*pow(0.65,0.15)), 0.0, 1.0 );\n    fracdistb=clamp( fracdistb*(tz*pow(10.,0.65)), 0.0, 1.0 );\n    float colr=fracdist*(howclose/66.);\n    float colg=fracdistg*(howclose/27.);\n    float colb=fracdistb;\n\t\n    \n    vec3 col =vec3(colr*4.1,(colg*1.15+colr)/2.,colg*4.11159);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}