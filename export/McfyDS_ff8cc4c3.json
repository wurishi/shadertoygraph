{"ver":"0.1","info":{"id":"McfyDS","date":"1721666683","viewed":150,"name":"Positive Affirmation","username":"igneus","description":"Experiments with ray tracing quadratic Bezier curves. \n\nNOTE: To use full screen, change kPathAccelDims to a constant value.","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["sdf","bezier","quadratic","newton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Vignetting is an effect caused by composite lenses whereby the image appears darker around the edges.\n// Despite being an artefact of lens design, it is often applied deliberately as an artistic effect to \n// frame the image and draw the eye inward toward the center. \nfloat Vignette(in vec2 fragCoord)\n{\n    #define kVignetteStrength         0.5             // The strength of the vignette effect\n    #define kVignetteScale            0.6            // The scale of the vignette effect\n    #define kVignetteExponent         3.0             // The rate of attenuation of the vignette effect\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x = (uv.x - 0.5) * (iResolution.x / iResolution.y) + 0.5;     \n    \n    float x = 2.0 * (uv.x - 0.5);\n    float y = 2.0 * (uv.y - 0.5);\n    \n    float dist = sqrt(x*x + y*y) / kRoot2;\n    \n    return mix(1.0, max(0.0, 1.0 - pow(dist * kVignetteScale, kVignetteExponent)), kVignetteStrength);\n}\n\nfloat Hatching(vec2 xy, float v, int i, float frequency, float modulation)\n{\n    float f = frequency * pow(float(modulation), float(i) / 3.);\n    float leftHash = 1. - saturate(5. * sin01(f * (xy.x + xy.y)) - (5.* saturate(2.0 * v)));\n    float rightHash = 1. - saturate(5. * sin01(f * (xy.x - xy.y)) - (5. * saturate(2.0 * v - 1.)));\n    \n    return leftHash * rightHash;\n}\n\nvec2 ScreenToView(vec2 xy)\n{\n    vec2 uv = ((xy / kPathAccelDims.xy) - vec2(0.5, 0.5));\n    return uv * vec2(1., kPathAccelDims.y / kPathAccelDims.x);\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xyScreen )\n{\n    SetGlobals(xyScreen, iResolution.xy);    \n    \n    //rgba = texelFetch(iChannel0, ivec2(xyScreen), 0);\n\n    //return;\n    \n    TimingCtx timingCtx = GetAnimationCtx(iTime, xyScreen, iResolution.xy);  \n    int phase = (timingCtx.intervalIdx + 0) % 2;\n\n    #define kPulseSpeed 1.5\n    #define kPulseAmp 2.\n    float pulse = mix(0.95, 1. / kPulseAmp, KickDrop(fract(iTime * kPulseSpeed), vec2(0., 0.), vec2(0.1, 1.), vec2(1., 0.)));\n    \n    vec3 rgb = kOne * Vignette(xyScreen) * 0.2 * mix(Hatching(xyScreen, Vignette(xyScreen), 0, 0.3, 1.), 1., 0.5);\n    \n    rgb = 1. - rgb;\n    \n    for(int i = 0; i < 3; ++i)\n    {\n         int c = (phase == 1) ? i : (2 - i);\n         vec2 uv = ((mix(1., pulse, float(i) / 3.) * (xyScreen - iResolution.xy * 0.5)) + iResolution.xy * 0.5) / iResolution.xy;\n         vec3 cel1 = texture(iChannel0, uv, 0.).xyz;               \n         uv = ((0.9 * mix(1., pulse, float(1) / 3.) * (xyScreen - iResolution.xy * 0.5)) + iResolution.xy * 0.5) / iResolution.xy;\n         vec3 cel2 = texture(iChannel0, uv, 0.).xyz;\n         \n         cel1.x = saturate(mix(-0.2, 0.95, cos(saturate(cel1.x) * kHalfPi)));\n      \n         float hatch = Hatching(vec2(xyScreen.y, -xyScreen.x), cel1.x, i, 0.4, 1.);\n         rgb[c] = mix(rgb[c], mix(0.7, 0.9, hatch), cel2.z);\n         \n         hatch = 1. - Hatching(xyScreen, cel1.x, i, 0.7, 1.);         \n         rgb[c] = mix(rgb[c], hatch, cel1.z);        \n         \n         hatch = Hatching(xyScreen, cel2.x, i, 0.7, 1.); \n         rgb[c] = mix(rgb[c], (phase == 1) ? hatch : (1. - hatch), cel2.y);\n\n    }    \n    \n    if(phase == 0)\n    {\n        rgb = 1. - rgb;\n    }\n    \n      // Grade\n    vec3 hsv = RGBToHSV(rgb);    \n    hsv.x += iTime;\n    hsv.y *= 1.;    \n    rgb = HSVToRGB(hsv);\n    \n    rgba = vec4(rgb, 1.0);\n  \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// *******************************************************************************************************\n//    Math functions\n// *******************************************************************************************************\n\n\n#define kPi                    3.14159265359\n#define kInvPi                 (1.0 / 3.14159265359)\n#define kTwoPi                 (2.0 * kPi)\n#define kFourPi                (4.0 * kPi)\n#define kHalfPi                (0.5 * kPi)\n#define kRoot2                 1.41421356237\n#define kLog10                 2.30258509299\n#define kFltMax                3.402823466e+38\n#define kOneThird              (1.0 / 3.0)\n#define kIntMax                0x7fffffff\n#define kOne                   vec3(1.)\n#define kZero                  vec3(0.)\n#define kRed                   vec3(1., 0., 0.)\n#define kGreen                 vec3(0., 1., 0.)\n#define kBlue                  vec3(0., 0., 1.)\n#define kPink                  vec3(1., 0., 0.2) \n\n#define Timecode vec3\n\nfloat cubrt(float a)           { return sign(a) * pow(abs(a), 1.0 / 3.0); }\nfloat toRad(float deg)         { return kTwoPi * deg / 360.0; }\nfloat toDeg(float rad)         { return 360.0 * rad / kTwoPi; }\nfloat sqr(float a)             { return a * a; }\nvec2 sqr(vec2 a)               { return a * a; }\nvec3 sqr(vec3 a)               { return a * a; }\nvec4 sqr(vec4 a)               { return a * a; }\nint sqr(int a)                 { return a * a; }\nint cub(int a)                 { return a * a * a; }\nfloat cub(float a)             { return a * a * a; }\nint mod2(int a, int b)         { return ((a % b) + b) % b; }\nfloat mod2(float a, float b)   { return mod(mod(a, b) + b, b); }\nvec3 mod2(vec3 a, vec3 b)      { return mod(mod(a, b) + b, b); }\nfloat length2(vec2 v)          { return dot(v, v); }\nfloat length2(vec3 v)          { return dot(v, v); }\nint sum(ivec2 a)               { return a.x + a.y; }\nfloat luminance(vec3 v)        { return v.x * 0.17691 + v.y * 0.8124 + v.z * 0.01063; }\nfloat mean(vec3 v)             { return v.x / 3.0 + v.y / 3.0 + v.z / 3.0; }\nvec4 mul4(vec3 a, mat4 m)      { return vec4(a, 1.0) * m; }\nvec3 mul3(vec3 a, mat4 m)      { return (vec4(a, 1.0) * m).xyz; }\nfloat sin01(float a)           { return 0.5 * sin(a) + 0.5; }\nfloat cos01(float a)           { return 0.5 * cos(a) + 0.5; }\nfloat saturate(float a)        { return clamp(a, 0.0, 1.0); }\nvec3 saturate(vec3 a)          { return clamp(a, 0.0, 1.0); }\nvec4 saturate(vec4 a)          { return clamp(a, 0.0, 1.0); }\nfloat saw01(float a)           { return abs(fract(a) * 2.0 - 1.0); }\nfloat cwiseMax(vec3 v)         { return (v.x > v.y) ? ((v.x > v.z) ? v.x : v.z) : ((v.y > v.z) ? v.y : v.z); }\nfloat cwiseMax(vec2 v)         { return (v.x > v.y) ? v.x : v.y; }\nint cwiseMax(ivec2 v)          { return (v.x > v.y) ? v.x : v.y; }\nfloat cwiseMin(vec3 v)         { return (v.x < v.y) ? ((v.x < v.z) ? v.x : v.z) : ((v.y < v.z) ? v.y : v.z); }\nint cwiseMin(ivec3 v)          { return (v.x < v.y) ? ((v.x < v.z) ? v.x : v.z) : ((v.y < v.z) ? v.y : v.z); }\nfloat cwiseMin(vec2 v)         { return (v.x < v.y) ? v.x : v.y; }\nfloat max3(float a, float b, float c) { return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c); }\nfloat min3(float a, float b, float c) { return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c); }\nvoid sort(inout float a, inout float b) { if(a > b) { float s = a; a = b; b = s; } }\nvoid swap(inout float a, inout float b) { float s = a; a = b; b = s; }\nvoid swap(inout int a, inout int b) { int s = a; a = b; b = s; }\n\nvec3 safeAtan(vec3 a, vec3 b)\n{\n    vec3 r;\n    #define kAtanEpsilon 1e-10\n    r.x = (abs(a.x) < kAtanEpsilon && abs(b.x) < kAtanEpsilon) ? 0.0 : atan(a.x, b.x); \n    r.y = (abs(a.y) < kAtanEpsilon && abs(b.y) < kAtanEpsilon) ? 0.0 : atan(a.y, b.y); \n    r.z = (abs(a.z) < kAtanEpsilon && abs(b.z) < kAtanEpsilon) ? 0.0 : atan(a.z, b.z); \n    return r;\n}\n\nvec3 GuardedNormalise(vec3 v, vec3 n)\n{\n    float len = length(v);\n    return (len > 1e-10) ? (v / len) : n;\n}\n\nvec3 SafeNormaliseTexel(vec4 t)\n{\n    return t.xyz / max(1e-15, t.w);\n}\n\nvec4 Sign(vec4 v)\n{\n    return step(vec4(0.0), v) * 2.0 - 1.0;\n}\n\nfloat Sign(float v)\n{\n    return step(0.0, v) * 2.0 - 1.0;\n}\n\nbool IsNan( float val )\n{\n    return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n}\n\nbvec3 IsNan( vec3 val )\n{\n    return bvec3( ( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) ? false : true, \n                  ( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) ? false : true, \n                  ( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 ) ? false : true);\n}\n\nbvec4 IsNan( vec4 val )\n{\n    return bvec4( ( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) ? false : true, \n                  ( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) ? false : true, \n                  ( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 ) ? false : true,\n                  ( val.w < 0.0 || 0.0 < val.w || val.w == 0.0 ) ? false : true);\n}\n\n\n#define SignedGamma(v, gamma) (sign(v) * pow(abs(v), gamma))\n\n// *******************************************************************************************************\n// Global variables\n\nvec2 gResolution;\nvec2 gFragCoord;\nuvec4 rngSeed;\nfloat gDxyDuv;\n\nvoid SetGlobals(vec2 fragCoord, vec2 resolution)\n{\n    gFragCoord = fragCoord;\n    gResolution = resolution;\n    \n     // First derivative of screen to world space (assuming square pixels)\n    gDxyDuv = 1.0 / min(gResolution.x, gResolution.y);\n}\n\nbool IsTexelInClipRegion(vec2 xy)\n{\n    return true;\n}\n\n// *******************************************************************************************************\n//    Math functions\n// *******************************************************************************************************\n\nfloat SmoothStep(float a, float b, float x) { return mix(a, b, x * x * (3.0 - 2.0 * x)); }\nvec4 SmoothStep(vec4 a, vec4 b, float x)    { return mix(a, b, x * x * (3.0 - 2.0 * x)); }\nfloat SmoothStep(float x)                   { return mix(0.0, 1.0, x * x * (3.0 - 2.0 * x)); }\n\nfloat PaddedSmoothStep(float x, float a, float b)\n{ \n    return SmoothStep(saturate(x * (a + b + 1.0) - a));\n}\n\nfloat PaddedSmoothStep(float x, float a)\n{\n    return PaddedSmoothStep(x, a, a);\n}\n\nfloat Impulse(float x, float axis, float stdDev)\n{\n    return exp(-sqr((x - axis) / stdDev));\n}\n\nfloat AnisotropicImpulse(float x, float axis, float stdDevA, float stdDevB)\n{\n    float impulse = (x < axis) ? exp(-sqr((x - axis) / stdDevA)) : exp(-sqr((x - axis) / stdDevB));\n    return saturate((impulse - 0.05) / (1.0 - 0.05));\n}\n\nfloat KickDrop(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    if(t < p1.x)\n    {\n        return mix(p0.y, p1.y, max(0.0, exp(-sqr((t - p1.x)*2.145966026289347/(p1.x-p0.x))) - 0.01) / 0.99);\n    }\n    else if(t < p2.x)\n    {\n        return mix(p1.y, p2.y, (t - p1.x) / (p2.x - p1.x));\n    }\n    else\n    {  \n        return mix(p3.y, p2.y, max(0.0, exp(-sqr((t - p2.x)*2.145966026289347/(p3.x-p2.x))) - 0.01) / 0.99);\n    }\n}\n\nfloat KickDrop(float t, vec2 p0, vec2 p1, vec2 p2)\n{\n    return KickDrop(t, p0, p1, p1, p2);\n}\n\nbool SolveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float b2ac4 = b * b - 4.0 * a * c;\n    if(b2ac4 < 0.0) { return false; } \n\n    float sqrtb2ac4 = sqrt(b2ac4);\n    t0 = (-b + sqrtb2ac4) / (2.0 * a);\n    t1 = (-b - sqrtb2ac4) / (2.0 * a);    \n    return true;\n}\n\n// Closed-form approxiation of the error function.\n// See 'Uniform Approximations for Transcendental Functions', Winitzki 2003, https://doi.org/10.1007/3-540-44839-X_82\nfloat ErfApprox(float x)\n{    \n     float a = 8.0 * (kPi - 3.0) / (3.0 * kPi * (4.0 - kPi));\n     return sign(x) * sqrt(1.0 - exp(-(x * x) * (4.0 / kPi + a * x * x) / (1.0 + a * x * x)));\n}\n\n// The antiderivative of the normalised Gaussian with standard deviation sigma\nfloat AntiderivGauss(float x, float sigma)\n{    \n    return 0.5 * (1.0 + ErfApprox(x / (sigma * kRoot2)));\n}\n\nconst mat4 kOrderedDither = mat4(vec4(0.0, 8.0, 2.0, 10.), vec4(12., 4., 14., 6.), vec4(3., 11., 1., 9.), vec4(15., 7., 13., 5.));\nfloat OrderedDither(ivec2 xyScreen)\n{    \n    return (kOrderedDither[xyScreen.x & 3][xyScreen.y & 3] + 1.0) / 17.0;\n}\n\n// *******************************************************************************************************\n//    2D SVG\n// *******************************************************************************************************\n\nfloat SDFLine(vec2 p, vec2 v0, vec2 v1, float thickness)\n{\n    v1 -= v0;\n    float t = saturate((dot(p, v1) - dot(v0, v1)) / dot(v1, v1));\n    vec2 perp = v0 + t * v1;\n    return saturate((thickness - length(p - perp)) / gDxyDuv);\n}\n\nfloat SDFQuad(vec2 p, vec2 v[4], float thickness)\n{\n    float c = 0.0;\n    for(int i = 0; i < 4; i++)\n    {\n        c = max(c, SDFLine(p, v[i], v[(i+1)%4], thickness)); \n    }\n \n    return c;\n}\n\nfloat SDFCircle(vec2 p, vec2 o, float r, float thickness, bool fill)\n{\n    float dist = fill ? ((r - length(o - p)) / thickness) : (1.0 - abs(r - length(o - p)) / thickness);\n    return saturate(dist);\n}\n\n// *******************************************************************************************************\n//    2D primitive tests\n// *******************************************************************************************************\n\nbool IsPointInQuad(vec2 uv, vec2 v[4])\n{\n    for(int i = 0; i < 4; i++)\n    {\n        if(dot(uv - v[i], v[i] - v[(i+1)%4]) > 0.0) { return false; }\n    }\n    return true;\n}\n\n// *******************************************************************************************************\n//    Transforms \n// *******************************************************************************************************\n\nmat3 WorldToViewMatrix(float rot, vec2 trans, float sca)\n{   \n    return mat3(vec3(cos(rot) / sca, sin(rot) / sca, trans.x), \n                vec3(-sin(rot) / sca, cos(rot) / sca, trans.y),\n                vec3(0.0, 0.0, 1.0));\n}\n\nmat3 WorldToViewMatrix(vec2 trans, float sca)\n{   \n    return mat3(vec3(1.0 / sca, 0.0, trans.x), \n                vec3(0.0, 1.0 / sca, trans.y),\n                vec3(0.0, 0.0, 1.0));\n}\n\nvec2 TransformScreenToWorld(vec2 p)\n{   \n    return (p - vec2(gResolution.xy) * 0.5) / float(gResolution.y); \n}\n\nvec2 TransformScreenToWorld(vec2 p, vec2 o)\n{   \n    return (p - o * 0.5) / float(gResolution.y); \n}\n\n\nvec3 Cartesian2DToBarycentric(vec2 p)\n{    \n    return vec3(p, 0.0) * mat3(vec3(0.0, 1.0 / 0.8660254037844387, 0.0),\n                          vec3(1.0, 0.5773502691896257, 0.0),\n                          vec3(-1.0, 0.5773502691896257, 0.0));    \n}\n\nvec2 BarycentricToCartesian2D(vec3 b)\n{    \n    return vec2(b.y * 0.5 - b.z * 0.5, b.x * 0.8660254037844387);    \n}\n\n// Maps an input uv position to periodic hexagonal tiling\n//     inout vec2 uv: The mapped uv coordinate\n//     out vec3 bary: The Barycentric coordinates at the point on the hexagon\n//     out ivec2 ij: The coordinate of the tile\nvec2 Cartesian2DToHexagonalTiling(in vec2 uv, out vec3 bary, out ivec2 ij)\n{    \n    #define kHexRatio vec2(1.5, 0.8660254037844387)\n    vec2 uvClip = mod(uv + kHexRatio, 2.0 * kHexRatio) - kHexRatio;\n    \n    ij = ivec2((uv + kHexRatio) / (2.0 * kHexRatio)) * 2;\n    if(uv.x + kHexRatio.x <= 0.0) ij.x -= 2;\n    if(uv.y + kHexRatio.y <= 0.0) ij.y -= 2;\n    \n    bary = Cartesian2DToBarycentric(uvClip);\n    if(bary.x > 0.0)\n    {\n        if(bary.z > 1.0) { bary += vec3(-1.0, 1.0, -2.0); ij += ivec2(-1, 1); }\n        else if(bary.y > 1.0) { bary += vec3(-1.0, -2.0, 1.0); ij += ivec2(1, 1); }\n    }\n    else\n    {\n        if(bary.y < -1.0) { bary += vec3(1.0, 2.0, -1.0); ij += ivec2(-1, -1); }\n        else if(bary.z < -1.0) { bary += vec3(1.0, -1.0, 2.0); ij += ivec2(1, -1); }\n    }\n\n    return vec2(bary.y * 0.5773502691896257 - bary.z * 0.5773502691896257, bary.x);\n}\n\nbool InverseSternograph(inout vec2 uv, float zoom)\n{\n    float theta = length(uv) * kPi * zoom;\n    if(theta >= kPi - 1e-1) { return false; }\n    \n    float phi = atan(-uv.y, -uv.x) + kPi;\n    \n    vec3 sph = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), -cos(theta));\n    \n    uv = vec2(sph.x / (1.0 - sph.z), sph.y / (1.0 - sph.z));\n    return true;\n}\n\n// *******************************************************************************************************\n//    Random number generation\n// *******************************************************************************************************\n\n// Permuted congruential generator from \"Hash Functions for GPU Rendering\" (Jarzynski and Olano)\n// http://jcgt.org/published/0009/03/02/paper.pdf\nuvec4 PCGAdvance()\n{\n    rngSeed = rngSeed * 1664525u + 1013904223u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    rngSeed ^= rngSeed >> 16u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    return rngSeed;\n}\n\n// Generates a tuple of canonical random number and uses them to sample an input texture\nvec4 Rand(sampler2D sampler)\n{\n    return texelFetch(sampler, (ivec2(gFragCoord) + ivec2(PCGAdvance() >> 16)) % 1024, 0);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nvec4 Rand()\n{\n    return vec4(PCGAdvance()) / float(0xffffffffu);\n}\n\n// Generates a tuple of canonical random numbers\n#define URand PCGAdvance()\nivec4 IRand() { return ivec4(PCGAdvance()); }\n\n// Seed the PCG hash function with the current frame multipled by a prime\nvoid PCGInitialise(uint frame)\n{    \n    rngSeed = uvec4(20219u, 7243u, 12547u, 28573u) * frame;\n}\n\n// Reverse the bits of 32-bit inteter\nuint RadicalInverse(uint i)\n{\n    i = ((i & 0xffffu) << 16u) | (i >> 16u);\n    i = ((i & 0x00ff00ffu) << 8u) | ((i & 0xff00ff00u) >> 8u);\n    i = ((i & 0x0f0f0f0fu) << 4u) | ((i & 0xf0f0f0f0u) >> 4u);\n    i = ((i & 0x33333333u) << 2u) | ((i & 0xccccccccu) >> 2u);    \n    i = ((i & 0x55555555u) << 1u) | ((i & 0xaaaaaaaau) >> 1u);        \n    return i;\n}\n\n// Samples the radix-2 Halton sequence from seed value, i\nfloat HaltonBase2(uint i)\n{    \n    return float(RadicalInverse(i)) / float(0xffffffffu);\n}\n\nfloat HaltonBase3(uint seed)\n{\n    uint accum = 0u;\n    accum += 1162261467u * (seed % 3u); seed /= 3u;\n    accum += 387420489u * (seed % 3u); seed /= 3u;\n    accum += 129140163u * (seed % 3u); seed /= 3u;\n    accum += 43046721u * (seed % 3u); seed /= 3u;\n    accum += 14348907u * (seed % 3u); seed /= 3u;\n    accum += 4782969u * (seed % 3u); seed /= 3u;\n    accum += 1594323u * (seed % 3u); seed /= 3u;\n    accum += 531441u * (seed % 3u); seed /= 3u;\n    accum += 177147u * (seed % 3u); seed /= 3u;\n    accum += 59049u * (seed % 3u); seed /= 3u;\n    accum += 19683u * (seed % 3u); seed /= 3u;\n    accum += 6561u * (seed % 3u); seed /= 3u;\n    accum += 2187u * (seed % 3u); seed /= 3u;\n    accum += 729u * (seed % 3u); seed /= 3u;\n    accum += 243u * (seed % 3u); seed /= 3u;\n    accum += 81u * (seed % 3u); seed /= 3u;\n    accum += 27u * (seed % 3u); seed /= 3u;\n    accum += 9u * (seed % 3u); seed /= 3u;\n    accum += 3u * (seed % 3u); seed /= 3u;\n    return float(accum + seed % 3u) / 3486784400.0f;\n} \n\nvec2 SampleUnitDisc(vec2 xi)\n{\n    float phi = xi.y * kTwoPi;   \n    return vec2(sin(phi), cos(phi)) * sqrt(xi.x);   \n}\n\n// *******************************************************************************************************\n//    Hash functions\n// *******************************************************************************************************\n\n// Constants for the Fowler-Noll-Vo hash function\n// https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function\n#define kFNVPrime              0x01000193u\n#define kFNVOffset             0x811c9dc5u\n#define kDimsPerBounce         4\n\n// Mix and combine two hashes\nuint HashCombine(uint a, uint b)\n{\n    return (((a << (31u - (b & 31u))) | (a >> (b & 31u)))) ^\n            ((b << (a & 31u)) | (b >> (31u - (a & 31u))));\n}\n\n// Compute a 32-bit Fowler-Noll-Vo hash for the given input\nuint HashOf(uint i)\n{\n    uint h = (kFNVOffset ^ (i & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 8u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 16u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 24u) & 0xffu)) * kFNVPrime;\n    return h;\n}\n\nuint HashOf(int a) { return HashOf(uint(a)); }\nuint HashOf(uint a, uint b) { return HashCombine(HashOf(a), HashOf(b)); }\nuint HashOf(uint a, uint b, uint c) { return HashCombine(HashCombine(HashOf(a), HashOf(b)), HashOf(c)); }\nuint HashOf(uint a, uint b, uint c, uint d) { return HashCombine(HashCombine(HashOf(a), HashOf(b)), HashCombine(HashOf(c), HashOf(d))); }\nuint HashOf(vec2 v) { return HashCombine(HashOf(uint(v.x)), HashOf(uint(v.y))); }\nuint HashOf(ivec2 v) { return HashCombine(HashOf(uint(v.x)), HashOf(uint(v.y))); }\n\n// Samples the radix-2 Halton sequence from seed value, i\nfloat HashToFloat(uint i)\n{    \n    return float(HashOf(i)) / float(0xffffffffu);\n}\n\n\nvec3 SampleUnitSphere(vec2 xi)\n{\n    xi.x = xi.x * 2.0 - 1.0;\n    xi.y *= kTwoPi;\n\n    float sinTheta = sqrt(1.0 - xi.x * xi.x);\n    return vec3(cos(xi.y) * sinTheta, xi.x, sin(xi.y) * sinTheta);\n}\n\n// *******************************************************************************************************\n//    Quadratic spline functions\n// *******************************************************************************************************\n\n#define kNumPaths 25\n#define kNumSplines 80\n#define kNumCoeffs 160\n#define kNumBVHLeaves 80\n#define kNumBVHFlags 2\n#define kBVHInnerSpan 64\n#define kBVHDepth 8\n#define kDocBBox vec4(-0.500000, -0.281250, 0.500000, 0.281250)\n\nconst vec3 points[kNumCoeffs] = vec3[kNumCoeffs](\n    vec3(-0.000100149,-0.00852335,-0.0250134),vec3(-0.00100111,0.0030494,0.0986139),vec3(-0.000309514,-0.00872364,-0.0336369),vec3(-0.00309547,0.00104718,0.100662),vec3(0.00264876,-0.0245143,-0.0426701),vec3(-0.00132437,-0.0451266,0.0986139),vec3(0.00148896,-0.0192168,-0.0645356),vec3(-0.00074447,-0.0477754,0.052163),\n    vec3(0.000303259,-0.0133468,-0.0822634),vec3(0.000476534,0.0452003,0.00364312),vec3(0.00250925,-0.0127403,-0.0953069),vec3(0.00394316,0.0461534,0.04932),vec3(0.0121522,-0.0850367,-0.105538),vec3(-0.0223347,0.00141231,0.0994165),vec3(0.0290155,-0.0607324,-0.178423),vec3(-0.00484143,-0.0432571,0.0784942),\n    vec3(0.00886273,-0.00147239,-0.210139),vec3(0.00865681,-0.0288549,0.0303956),vec3(0.00498158,0.0162531,-0.202749),vec3(0.00578939,-0.0115412,0.0101976),vec3(0.018001,-0.0133523,-0.181514),vec3(0.00318953,0.0422382,0.00444573),vec3(0.00881722,0.0226497,-0.176866),vec3(-0.0164633,0.0486172,0.0498734),\n    vec3(0.00382972,0.00590395,-0.145399),vec3(0.00357439,-0.0566351,0.0820274),vec3(0.00238503,0.0135634,-0.135665),vec3(0.00222608,-0.0494863,0.0289667),vec3(0.00481936,-0.0162425,-0.119717),vec3(-0.000370737,-0.0406283,-0.0182935),vec3(0.000370503,-0.00660374,-0.13114),vec3(-2.84789e-05,-0.0413698,-0.0592925),\n    vec3(0.000586493,0.0178072,-0.137373),vec3(-0.000351875,0.00215673,-0.100691),vec3(0.00542972,0.0189802,-0.118979),vec3(-0.00325785,0.00145299,-0.0988859),vec3(-0.000433681,0.00635514,-0.0945693),vec3(-0.000260213,0.0397148,-0.100691),vec3(0.00624715,0.00548778,-0.0886479),vec3(0.00374826,0.0391944,-0.0612362),\n    vec3(-0.000108671,0.0233607,-0.076913),vec3(-0.000542773,0.0606567,-0.0182935),vec3(0.00550417,0.0231434,-0.053661),vec3(-0.00277757,0.0595711,0.0418204),vec3(-0.00228861,-0.00513205,0.171616),vec3(0.00251745,-0.0675356,0.0865755),vec3(-0.00186411,-0.00970927,0.164195),vec3(0.00205065,-0.0625007,0.0215573),\n    vec3(-0.000545831,0.0129421,0.152622),vec3(-0.00163753,0.00471707,-0.0388927),vec3(-0.00150718,0.0118504,0.165018),vec3(-0.00452153,0.001442,-0.0358132),vec3(0.00218969,0.0120973,0.175361),vec3(-0.000291942,0.0634397,-0.0388928),vec3(0.00401426,0.0164767,0.189648),vec3(-0.000535263,0.0628558,0.024255),\n    vec3(-0.00112682,-0.0170962,0.210139),vec3(0.00316991,-0.00732208,0.0865755),vec3(-0.000950508,-0.0193499,0.191916),vec3(0.00513443,-0.000982261,0.0824233),vec3(-0.000486036,-0.0178861,0.112761),vec3(0.00155544,-0.00884298,0.0378863),vec3(-0.00156062,-0.0188582,0.0943889),vec3(0.00499389,-0.00573209,0.0305988),\n    vec3(-0.00239975,-0.00458783,0.0739701),vec3(0.00126509,-0.034407,0.0298606),vec3(-0.00261909,-0.00938734,0.0669825),vec3(0.00375584,-0.0318768,-0.00328137),vec3(0.00177235,-0.0152488,0.054976),vec3(-0.00715614,-0.00120386,-0.0314024),vec3(0.00484883,-0.0117041,0.0414996),vec3(-0.00608622,-0.0155161,-0.0397624),\n    vec3(-0.00773194,-0.0222202,0.0346443),vec3(0.0241116,-0.0418381,-0.0613647),vec3(0.0184121,-0.0376841,0.00469214),vec3(0.0142841,0.00638501,-0.0790913),vec3(0.000319101,-0.000118438,-0.0145799),vec3(0.000536584,0.00481398,-0.0584222),vec3(8.2179e-05,0.000519764,-0.0143792),vec3(0.000265952,0.00588715,-0.0530716),\n    vec3(0.00163852,0.038122,-0.0137773),vec3(0.0114366,0.00481537,-0.0469185),vec3(-0.0206995,0.0413991,0.0259832),vec3(0.010634,0.0276886,-0.0306665),vec3(-0.00889511,-1.06465e-08,0.0466828),vec3(-0.00715621,0.0280899,0.00765613),vec3(-0.00755751,-0.0177902,0.0377877),vec3(-0.00688874,0.0137775,0.0285898),\n    vec3(0.0232076,-0.0730337,0.0124399),vec3(-0.0340758,-2.19515e-08,0.0354785),vec3(0.0133093,-0.0266186,-0.0373862),vec3(0.00859428,-0.0681516,0.00140274),vec3(0.0101658,-1.30611e-08,-0.0506955),vec3(0.00461472,-0.0345104,-0.0581546),vec3(0.00909576,0.0203317,-0.0405297),vec3(0.0126405,-0.025281,-0.0880503),\n    vec3(-0.00538378,0.0329053,-0.0111022),vec3(0.00655435,1.60795e-08,-0.100691),vec3(-0.00284259,0.0221378,0.0164193),vec3(0.00387903,0.0131087,-0.0941364),vec3(0.00779151,0.00642058,0.0357144),vec3(0.00779156,-0.0260835,-0.0771487),vec3(0.00846048,0.0220036,0.0499265),vec3(0.00525018,-0.0105004,-0.0954406),\n    vec3(-0.0146803,0.0541734,0.0803906),vec3(0.0139447,1.07562e-08,-0.100691),vec3(-0.0124064,0.0248129,0.119884),vec3(0.00471498,0.0278895,-0.0867461),vec3(-0.0113088,-3.29272e-09,0.13229),vec3(-0.0157687,0.0659381,-0.0541416),vec3(0.0143973,-0.0226176,0.120981),vec3(0.00745785,0.0344007,-0.00397223),\n    vec3(0.00451455,0.00842697,-0.0116373),vec3(-0.000601905,0.0377207,-0.0340774),vec3(0.00250792,0.0174561,0.00130421),vec3(-0.0182585,0.0365169,0.00304135),vec3(-0.00434736,0.0120386,0.0212682),vec3(-0.00538392,-4.1159e-09,0.0212998),vec3(-0.00167192,0.00334384,0.0289594),vec3(0.00117044,-0.0107678,0.0159159),\n    vec3(-0.0120051,2.41466e-09,0.0306313),vec3(0.00127357,-0.028494,0.00631848),vec3(-0.00625336,-0.0240102,0.0186262),vec3(0.0127714,-0.0259469,-0.020902),vec3(-0.00219981,0.0105877,0.066747),vec3(0.00323267,0.0174251,-0.0324722),vec3(-0.000664881,0.00618813,0.0751349),vec3(-0.000942112,0.0238904,-0.0118145),\n    vec3(0.00568504,0.000802513,0.0806581),vec3(0.0117376,-0.0501605,0.0111338),vec3(-0.00608629,0.0121726,0.0871457),vec3(0.000902797,-0.0266852,-0.0272891),vec3(-0.00769132,-8.06717e-09,0.093232),vec3(0.00725646,-0.0308989,-0.0530715),vec3(0.000869533,-0.0153827,0.0855407),vec3(0.00819296,-0.0163859,-0.0767139),\n    vec3(0.00458133,-0.0212681,0.0710275),vec3(0.00545083,-2.35978e-08,-0.0849068),vec3(0.00605274,-0.0121055,0.0543407),vec3(0.00638702,0.0109016,-0.079456),vec3(-0.0176568,0.0436386,0.048288),vec3(0.0255218,-0.0175773,-0.0621674),vec3(-0.0158479,0.00832504,0.0742698),vec3(-0.0117158,0.0334664,-0.0542228),\n    vec3(0.00254145,-0.0176565,0.156902),vec3(-0.00615303,-1.64636e-10,-0.0581546),vec3(0.00628684,-0.0125736,0.141787),vec3(-0.00267522,-0.0123061,-0.0643076),vec3(0.00628677,3.18297e-08,0.1355),vec3(0.00254146,-0.0176565,-0.0792889),vec3(0.00254153,0.0125736,0.141787),vec3(0.0062868,-0.0125736,-0.094404),\n    vec3(-0.00267516,0.0176564,0.156902),vec3(0.0062868,0,-0.100691),vec3(-0.00615306,0.0123061,0.171883),vec3(0.00254144,0.0125736,-0.094404),vec3(-0.00615303,-2.12929e-08,0.178037),vec3(-0.00267523,0.0176565,-0.0792889),vec3(-0.0026752,-0.0123061,0.171883),vec3(-0.00615302,0.0123061,-0.0643077));\n\nconst int pathOffsets[25] = int[25](\n    0,2,4,6,10,12,14,16,18,22,24,26,28,30,32,34,36,40,50,56,62,64,70,72,80);\n\nconst float splineLengths[80] = float[80](\n    0.00888208,0.00941776,0.05136842,0.05166585,0.04750336,0.05116503,0.07716496,0.05968660,0.02248535,0.02235887,0.04677638,0.04614840,0.05400626,0.04990816,0.04264856,0.04186545,0.01848356,0.02453353,0.03989712,0.04461284,0.06445416,0.06370910,0.06545696,0.06156129,0.01280082,0.01113282,0.06475621,0.06564302,0.01878919,0.02090851,0.01978699\n    ,0.02063860,0.03390402,0.03065917,0.01636714,0.02297382,0.03756428,0.03117973,0.00535712,0.00618256,0.04334020,0.04554625,0.02360868,0.02674360,0.06477308,0.06136887,0.03221713,0.03319902,0.02863324,0.02585571,0.02399891,0.03115533,0.04317535,0.03570918,0.05212615,0.04359207,0.03939437,0.02851168,0.01017714,0.00977807,0.03048090\n    ,0.03399969,0.02237508,0.02360488,0.03922079,0.02669605,0.02547223,0.01712528,0.01796517,0.01887388,0.03200566,0.02542436,0.01676137,0.01671379,0.01682706,0.01682710,0.01671376,0.01676134,0.01664744,0.01664744);\n\nconst float cumulativeSplineLengths[80] = float[80](\n    0.48536381,1.00000000,0.49855661,1.00000000,0.48144454,1.00000000,0.42469320,0.75319064,0.87694341,1.00000000,0.50337899,1.00000000,0.51971865,1.00000000,0.50463301,1.00000000,0.42967948,1.00000000,0.18759824,0.39736998,0.70043659,1.00000000,0.51533508,1.00000000,0.53484631,1.00000000,0.49659967,1.00000000,0.47330675,1.00000000,0.48946682\n    ,1.00000000,0.52512926,1.00000000,0.41603306,1.00000000,0.46789429,0.85626364,0.92299110,1.00000000,0.11248844,0.23070265,0.29197842,0.36139080,0.52950776,0.68878925,0.77240801,0.85857522,0.93289208,1.00000000,0.10445344,0.24005465,0.42797211,0.58339369,0.81026882,1.00000000,0.25859189,0.44574779,0.51255244,0.57673752,0.77681977\n    ,1.00000000,0.48662674,1.00000000,0.26983055,0.45349362,0.62873709,0.74655527,0.87015176,1.00000000,0.55729842,1.00000000,0.12517893,0.25000250,0.37567198,0.50134176,0.62616515,0.75134385,0.87567192,1.00000000);\n\nconst float pathLengths[24] = float[24](\n    0.01829984,0.10303427,0.09866840,0.18169576,0.09292479,0.10391441,0.08451401,0.04301710,0.21267322,0.12701824,0.02393364,0.13039923,0.03969770,0.04042559,0.06456320,0.03934095,0.08028369,0.38528579,0.22975700,0.15234187,0.04597996,0.14535341,0.05743001,0.13389930);\n\n\n#define kPathAccelDims (iResolution.xy)\n//#define kPathAccelDims vec2(1200., 675.)\n//#define kPathAccelDims vec2(100., 75.)\n\n\nvec2 EvaluateQuadraticSpline(in vec3 abcX, in vec3 abcY, in float t)\n{\n    return vec2(abcX.x * t*t + abcX.y * t + abcX.z, abcY.x * t*t + abcY.y * t + abcY.z);\n}\n\nvec2 EvaluateDQuadraticSpline(in vec3 abcX, in vec3 abcY, in float t)\n{\n    return vec2(2. * abcX.x * t + abcX.y, 2.0 * abcY.x * t + abcY.y);\n}\n\nbool QuadradicSplinePerpendicularPointApprox(in vec3 abcX, in vec3 abcY, in float margin, in vec2 xy, out float tPerp, out vec2 xyPerp)\n{\n    float a0 = abcX.x, b0 = abcX.y, c0 = abcX.z;\n    float d0 = abcY.x, e0 = abcY.y, f0 = abcY.z;\n    float n0 = xy.x, m0 = xy.y;   \n    \n    vec4 P = vec4(-2.0*a0*a0 - 2.0*d0*d0, \n                  -3.0*a0*b0 - 3.0*d0*e0,\n                  -b0*b0 - 2.0*a0*c0 - e0*e0 - 2.0*d0*f0 + 2.0*d0*m0 + 2.0*a0*n0,\n                  -b0*c0 - e0*f0 + e0*m0 +  b0*n0);\n    \n    vec3 t, f;\n    float b2ac4 = sqr(2.*P.y) - 4.0*(3.*P.x)*P.z;\n    if(b2ac4 <= 1e-3 || abs(P.x) / max(1e-10, abs(P.y)) < 1.)\n    {\n        t.xz = vec2(-margin, 1. + margin);\n        t.y = mix(t.x, t.z, 0.5);\n    }\n    else\n    {\n        b2ac4 = sqrt(b2ac4);\n        float t0 = (-(2.*P.y) + b2ac4) / (2.0 * (3.*P.x));\n        float t1 = (-(2.*P.y) - b2ac4) / (2.0 * (3.*P.x)); \n        \n        t.x = t0-(t1-t0)*0.5;\n        t.y = (t0+t1)*0.5;\n        t.z = t1+(t1-t0)*0.5;    \n    }\n\n    #define Cubic(P, t) (P.w + (t) * (P.z + (t) * (P.y + (t) * P.x)))\n    #define DCubic(P, t) (P.z + (t) * (2. * P.y + (t) * 3. * P.x))\n    #define kNewtonIters 5\n    for(int i = 0; i < kNewtonIters; ++i)\n    {\n        f = Cubic(P, t);\n        t -= f / DCubic(P, t);       \n    }\n    f = Cubic(P, t);\n    \n    xyPerp = vec2(kFltMax);\n    float nearest = kFltMax;\n    for(int idx = 0; idx < 3; ++idx)\n    {\n        if(abs(f[idx]) < 1e-5)\n        {\n            float t = clamp(t[idx], -margin, 1.0 + margin);\n            vec2 perp = vec2(abcX.x * t*t + abcX.y * t + abcX.z,\n                            abcY.x * t*t + abcY.y * t + abcY.z);                        \n                        \n            float dist = length2(xy - perp);\n            if(dist < nearest)\n            {\n                nearest = dist;\n                xyPerp = perp;\n                tPerp = t;\n            }            \n       }\n    }\n     \n    return true;\n}\n\n\n// *******************************************************************************************************\n//    Colour functions\n// *******************************************************************************************************\n\nvec3 Hue(float phi)\n{\n    float phiColour = 6.0 * phi;\n    int i = int(phiColour);\n    vec3 c0 = vec3(((i + 4) / 3) & 1, ((i + 2) / 3) & 1, ((i + 0) / 3) & 1);\n    vec3 c1 = vec3(((i + 5) / 3) & 1, ((i + 3) / 3) & 1, ((i + 1) / 3) & 1);             \n    return mix(c0, c1, phiColour - float(i));\n}\n\n// A Gaussian function that we use to sample the XYZ standard observer \nfloat CIEXYZGauss(float lambda, float alpha, float mu, float sigma1, float sigma2)\n{\n   return alpha * exp(sqr(lambda - mu) / (-2.0 * sqr(lambda < mu ? sigma1 : sigma2)));\n}\n\nvec3 HSVToRGB(vec3 hsv)\n{\n    return mix(vec3(0.0), mix(vec3(1.0), Hue(hsv.x), hsv.y), hsv.z);\n}\n\nvec3 RGBToHSV( vec3 rgb)\n{\n    // Value\n    vec3 hsv;\n    hsv.z = cwiseMax(rgb);\n\n    // Saturation\n    float chroma = hsv.z - cwiseMin(rgb);\n    hsv.y = (hsv.z < 1e-10) ? 0.0 : (chroma / hsv.z);\n\n    // Hue\n    if (chroma < 1e-10)        { hsv.x = 0.0; }\n    else if (hsv.z == rgb.x)    { hsv.x = (1.0 / 6.0) * (rgb.y - rgb.z) / chroma; }\n    else if (hsv.z == rgb.y)    { hsv.x = (1.0 / 6.0) * (2.0 + (rgb.z - rgb.x) / chroma); }\n    else                        { hsv.x = (1.0 / 6.0) * (4.0 + (rgb.x - rgb.y) / chroma); }\n    hsv.x = fract(hsv.x + 1.0);\n\n    return hsv;\n}\n\nvec3 SampleSpectrum(float lambda)\n{\n\t// Here we use a set of fitted Gaussian curves to approximate the CIE XYZ standard observer.\n\t// See https://en.wikipedia.org/wiki/CIE_1931_color_space for detals on the formula\n\t// This allows us to map the sampled wavelength to usable RGB values. This code needs cleaning \n\t// up because we do an unnecessary normalisation steps as we map from lambda to XYZ to RGB.\n\n\t#define kRNorm (7000.0 - 3800.0) / 1143.07\n\t#define kGNorm (7000.0 - 3800.0) / 1068.7\n\t#define kBNorm (7000.0 - 3800.0) / 1068.25\n\n\t// Sample the Gaussian approximations\n\tvec3 xyz;\n\txyz.x = (CIEXYZGauss(lambda, 1.056, 5998.0, 379.0, 310.0) +\n             CIEXYZGauss(lambda, 0.362, 4420.0, 160.0, 267.0) +\n             CIEXYZGauss(lambda, 0.065, 5011.0, 204.0, 262.0)) * kRNorm;\n\txyz.y = (CIEXYZGauss(lambda, 0.821, 5688.0, 469.0, 405.0) +\n             CIEXYZGauss(lambda, 0.286, 5309.0, 163.0, 311.0)) * kGNorm;\n\txyz.z = (CIEXYZGauss(lambda, 1.217, 4370.0, 118.0, 360.0) +\n             CIEXYZGauss(lambda, 0.681, 4590.0, 260.0, 138.0)) * kBNorm;\n\n\t// XYZ to RGB linear transform\n\tvec3 rgb;\n\trgb.r = (2.04159 * xyz.x - 0.5650 * xyz.y - 0.34473 * xyz.z) / (2.0 * 0.565);\n\trgb.g = (-0.96924 * xyz.x + 1.87596 * xyz.y + 0.04155 * xyz.z) / (2.0 * 0.472);\n\trgb.b = (0.01344 * xyz.x - 0.11863 * xyz.y + 1.01517 * xyz.z) / (2.0 * 0.452);\n\n\treturn rgb;\n}\n\nfloat PackFloats(in float a, in float b)\n{\n    return uintBitsToFloat(packHalf2x16(vec2(a, b)));\n}\n\nfloat PackFloats(in vec2 v)\n{\n    return uintBitsToFloat(packHalf2x16(v));\n}\n\nvoid UnpackFloats(in float i, out float a, out float b)\n{\n    vec2 v = unpackHalf2x16(floatBitsToUint(i));\n    a = v.x; b = v.y;\n}\n\nvec2 UnpackFloats(in float i)\n{\n    return unpackHalf2x16(floatBitsToUint(i));\n}\n\nstruct TimingCtx\n{\n    int intervalIdx;\n    float time;\n    float phase;\n};\n\nTimingCtx GetAnimationCtx(float wallTime, vec2 xyScreen, vec2 iRes)\n{\n    TimingCtx ctx;\n    \n    #define kIntervalLength 6.\n    #define kTransitionLength 1.\n    #define kAnimSpeed 0.12\n    \n    ctx.intervalIdx = int(wallTime / kIntervalLength);\n    ctx.phase = fract(wallTime / kIntervalLength);\n    \n    float xi = HashToFloat(HashOf(ctx.intervalIdx));\n    float transNorm = kTransitionLength / kIntervalLength;\n    \n    if(ctx.phase > 1.0 - transNorm)\n    {\n        float transitionPhase = (ctx.phase - (1.0 - transNorm)) / transNorm;\n        \n        //if(ctx.intervalIdx % 2 == 0)\n        if(true)\n        {\n            #define kWipeEaseInOut 0.75\n            float alpha = tan(kHalfPi * kWipeEaseInOut);\n            transitionPhase = (tan(kHalfPi * kWipeEaseInOut * mix(-1., 1., transitionPhase)) + alpha) / (2. * alpha);\n            float theta = kTwoPi * xi + transitionPhase * kTwoPi * 1.5 * mix(-1., 1., round(xi));\n            vec2 d = vec2(cos(theta), sin(theta));\n            vec2 p = iRes * 0.5 + d * (iRes.x * 0.7) * mix(-1., 1., transitionPhase);\n\n            if(dot(d, xyScreen - p) < 0.) \n            { \n                ctx.intervalIdx++; \n            }\n        }\n        else\n        {        \n            #define kTransitionHexDensity 7.\n            \n            vec2 uvView = (xyScreen - iRes * 0.5) / float(iRes.y); \n            uvView /= mix(1., 0.5, exp(-sqr(length(uvView))));\n            vec3 bary;\n            ivec2 ij;\n            Cartesian2DToHexagonalTiling(uvView * kTransitionHexDensity, bary, ij);   \n\n            float ijLen = saturate(length(vec2(ij) * vec2(1., iRes.y / iRes.x)) / kTransitionHexDensity);\n            float baryLen = length(BarycentricToCartesian2D(bary));\n\n            if(transitionPhase > 1. - (ijLen + baryLen / kTransitionHexDensity))\n            {\n                ctx.intervalIdx++;\n            }\n        }    \n    }\n    \n    xi = HashToFloat(HashOf(ctx.intervalIdx) + 2u);\n    float offset = (ctx.intervalIdx == 0) ? 0. : xi;\n    ctx.time = kAnimSpeed * wallTime + 7.8715 * offset;// + 1.5762 * float(ctx.intervalIdx);\n    \n    return ctx;\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Ray tracing\n*/\n\n\n#define kNullRay                 -1.0\n\nstruct Transform\n{\n    vec3 trans;\n    mat3 rot;\n    float sca;\n};\n\nmat3 Identity()\n{\n    return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));\n}\n\nmat3 ScaleMat3(float scale)\n{\n    float invScale = 1.0f / scale;\n\treturn mat3(vec3(invScale, 0.0, 0.0),\n\t\t\tvec3(0.0, invScale, 0.0),\n\t\t\tvec3(0.0, 0.0, invScale));\n}\n\nmat3 RotXMat3(float theta)\n{\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n\treturn mat3(vec3(1.0, 0.0, 0.0),\n\t\t\tvec3(0.0, cosTheta, -sinTheta),\n\t\t\tvec3(0.0, sinTheta, cosTheta));\n}\n\nmat3 RotYMat3(const float theta)\n{\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n\treturn mat3(vec3(cosTheta, 0.0, sinTheta),\n\t\t\tvec3(0.0, 1.0, 0.0),\n\t\t\tvec3(-sinTheta, 0.0, cosTheta));\n}\n\nmat3 RotZMat3(const float theta)\n{\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n\treturn mat3(vec3(cosTheta, -sinTheta, 0.0),\n\t\t\tvec3(sinTheta, cosTheta, 0.0),\n\t\t\tvec3(0.0, 0.0, 1.0));\n}\n\nTransform CompoundTransform(vec3 trans, vec3 rot, float scale)\n{\n    Transform t; \n    t.rot = Identity();\n    t.sca = scale;\n    t.trans = trans;\n\n    if (rot.x != 0.0) { t.rot *= RotXMat3(rot.x); }\n    if (rot.y != 0.0) { t.rot *= RotYMat3(rot.y); }\n    if (rot.z != 0.0) { t.rot *= RotZMat3(rot.z); }\n\n    if (scale != 1.0f) { t.rot *= ScaleMat3(scale); }\n    \n    return t;\n}\n\nTransform IdentityTransform()\n{\n    Transform t;\n    t.rot = Identity();\n    t.sca = 1.0;\n    t.trans = kZero;\n    return t;\n}\n\n// Fast construction of orthonormal basis u sing quarternions to avoid expensive normalisation and branching \n// From Duf et al's technical report https://graphics.pixar.com/library/OrthonormalB/paper.pdf, inspired by\n// Frisvad's original paper: http://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\nmat3 CreateBasis(vec3 n)\n{\n    float s = Sign(n.z);\n    float a = -1.0 / (s + n.z);\n    float b = n.x * n.y * a;\n    \n    return mat3(vec3(1.0f + s * n.x * n.x * a, s * b, -s * n.x),\n                vec3(b, s + n.y * n.y * a, -n.y),\n                n);\n}\n\nmat3 CreateBasis(vec3 n, vec3 up)\n{\n    vec3 tangent = normalize(cross(n, up));\n\tvec3 cotangent = cross(tangent, n);\n\n\treturn transpose(mat3(tangent, cotangent, n));\n}\n\n// The minimum amount of data required to define an infinite ray in 3D space\nstruct RayBasic\n{\n    vec3   o;                   // Origin \n    vec3   d;                   // Direction  \n};\n\n// The \"full fat\" ray objects that most methods will refer to\nstruct Ray\n{\n    RayBasic od;   \n    \n    float    tNear;\n    vec3     weight;\n    float    pdf;\n    uint     flags;\n};\n\n#define kFlagsBackfacing      1u\n#define kFlagsSubsurface      2u\n#define kFlagsDirectRay       4u\n#define kFlagsScattered       8u\n#define kFlagsLightSample     16u\n#define kFlagsProbePath       32u\n#define kFlagsCausticPath     64u\n#define kFlagsVolumetricPath  128u\n\n//#define InheritFlags(ray) (ray.flags & kFlagsScattered)\n#define InheritFlags(ray) (ray.flags & (kFlagsProbePath | kFlagsCausticPath))\n\n#define IsBackfacing(ray) ((ray.flags & kFlagsBackfacing) != 0u)\n#define IsSubsurface(ray) ((ray.flags & kFlagsSubsurface) != 0u)\n#define IsScattered(ray) ((ray.flags & kFlagsScattered) != 0u)\n#define IsLightSample(ray) ((ray.flags & kFlagsLightSample) != 0u)\n#define IsProbePath(ray) ((ray.flags & kFlagsProbePath) != 0u)\n#define IsCausticPath(ray) ((ray.flags & kFlagsCausticPath) != 0u)\n#define IsVolumetricPath(ray) ((ray.flags & kFlagsVolumetricPath) != 0u)\n\nstruct HitCtx\n{\n    vec3     n;\n    vec2     uv;\n    float    kickoff;\n    int      matID;\n    float    chi;\n};\n\nvoid SetRayFlag(inout Ray ray, in uint flag, in bool set)\n{\n    ray.flags &= ~flag;\n    if(set) \n    {\n        ray.flags |= flag;\n    }  \n}\n\n#define PointAt(ray) (ray.od.o + ray.od.d * ray.tNear)\n\nRayBasic RayToObjectSpace(in RayBasic world, in Transform transform) \n{\n\tRayBasic object;\n\tobject.o = world.o - transform.trans;\n\tobject.d = world.d + object.o;\n\tobject.o = transform.rot * object.o;\n\tobject.d = (transform.rot * object.d) - object.o;\n\treturn object;\n}\n\n\nRay CreateOrthographicCameraRay(vec2 uv, vec2 sensorSize, vec3 cameraPos, vec3 cameraLookAt)\n{\n    vec3 w = normalize(cameraLookAt - cameraPos);\n    mat3 basis = CreateBasis(w, vec3(0.0, 1.0, 0.0));    \n    \n    Ray ray;\n    ray.od.o = cameraPos + vec3(uv * sensorSize, 0.0) * basis;\n    ray.od.d = w;\n    ray.weight = vec3(1.0);\n    return ray;\n}\n\nRay CreatePinholeCameraRay(vec2 uvScreen, vec3 cameraPos, vec3 cameraLookAt)\n{   \n    #define kCameraFoV          60.\n    Ray ray;\n    ray.od.o = cameraPos;\n    ray.od.d = CreateBasis(normalize(cameraPos - cameraLookAt), vec3(0., 1., 0.)) * normalize(vec3(uvScreen, -tan(toRad(kCameraFoV))));\n    ray.tNear = kFltMax;\n    ray.weight = vec3(1.0, 1.0, 1.0);\n    ray.pdf = kFltMax;   \n\n    return ray;  \n}\n\nvec3 RayPointAt(in Ray ray, float t)\n{\n    return ray.od.o + ray.od.d * t;\n}\n\nvoid CreateRay(inout Ray ray, vec3 o, vec3 d, vec3 kickoff, vec3 weight, float pdf, uint flags)\n{     \n    ray.od.o = o + kickoff;\n    ray.od.d = d;\n    ray.tNear = kFltMax;\n    ray.weight = weight;\n    ray.pdf = pdf;\n    ray.flags = flags;\n}\n\n// *******************************************************************************************************\n//    BxDFs \n// *******************************************************************************************************\n\n#define kInvalidHit      0\n#define kMatCornellBox   1\n#define kMatDielectric   2\n#define kMatLight        3\n#define kMatVolume       4\n#define kMatIncandescent 5\n\n#define kCameraPath      0\n#define kLightPath       1\n\n#define kSDFMode 1\n#define kSDFWireframe false\n\n// Returns line gradient defined by the perpendicular distance\nvec2 SDFLine(vec2 p, vec2 v, vec2 dv)\n{\n    //  Nearest point\n    return (v + saturate((dot(p, dv) - dot(v, dv)) / dot(dv, dv)) * dv);    \n}\n\nvec4 SDFSphere(vec3 p, float radius)\n{\n    return vec4(length(p), p);\n}\n\nvec4 SDFTube(vec3 p, float radius, float height)\n{\n    if(p.z >= 0.0) {  p.z -= min(height * 0.5, p.z);}\n    else {  p.z += min(height * 0.5, -p.z); }\n       \n    vec3 pPlane = vec3(p.xy, 0.0);\n    float pPlaneLen = length(pPlane);        \n    vec3 pRing = (pPlaneLen < 1e-10) ? vec3(0.0) : (p - (pPlane * radius / pPlaneLen));  \n    \n    return vec4(length(pRing), -pRing);\n}\n\nbool RayBoundingBox(inout RayBasic localRay, out vec2 tNearFar, in vec3 lowerBound, vec3 upperBound)\n{   \n    vec3 tNearPlane, tFarPlane;\n    for(int dim = 0; dim < 3; dim++)\n    {\n        if(abs(localRay.d[dim]) > 1e-10)\n        {\n            float t0 = (upperBound[dim] - localRay.o[dim]) / localRay.d[dim];\n            float t1 = (lowerBound[dim] - localRay.o[dim]) / localRay.d[dim];\n            if(t0 < t1) { tNearPlane[dim] = t0;  tFarPlane[dim] = t1; }\n            else { tNearPlane[dim] = t1;  tFarPlane[dim] = t0; }\n        }\n    }    \n   \n    float tNearMax = cwiseMax(tNearPlane);\n    float tFarMin = cwiseMin(tFarPlane);\n    if(tNearMax > tFarMin) { return false; }  // Ray didn't hit the box\n    \n    tNearFar = vec2(tNearMax, tFarMin);\n    return true;\n}\n\nvec4 SDFQuadraticPath(vec3 p, vec3 lowerBound, vec3 upperBound, sampler2D accelSampler)\n{   \n    if(p.z >= upperBound.z) {  p.z -= upperBound.z; }\n    else if(p.z <= lowerBound.z) {  p.z -= lowerBound.z; }\n    else { p.z = 0.0; }\n    \n    ivec2 texIdx = ivec2(kPathAccelDims * (p.xy - lowerBound.xy) / (upperBound.xy - lowerBound.xy));\n    texIdx = clamp(texIdx, ivec2(0), ivec2(kPathAccelDims.xy) - 1);\n    ivec4 nearestIdxs = ivec4(round(texelFetch(accelSampler, texIdx, 0)));\n    \n    float distNear2 = kFltMax;\n    vec2 xyPerpNear;\n    int iNear;\n    float tPerpNear;\n    for(int i = 0; i < 4 && nearestIdxs[i] >= 0; ++i)\n    {\n        int splineIdx = nearestIdxs[i];\n        float tPerp;\n        vec2 xyPerp;\n        if(QuadradicSplinePerpendicularPointApprox(points[splineIdx*2], points[splineIdx*2+1], 0.02, p.xy, tPerp, xyPerp))    \n        {\n            float dist2 = length2(xyPerp - p.xy);\n            if(dist2 < distNear2)\n            {\n                distNear2 = dist2;\n                xyPerpNear = xyPerp;\n                iNear = splineIdx;\n                tPerpNear = tPerp;\n            }\n        }        \n    }\n    \n    p -= vec3(xyPerpNear, 0.0); \n    return vec4(length(p), -p);    \n}\n\n// Generic ray-SDF intersector\nbool RaySDF(inout Ray ray, inout HitCtx hit, in Transform transform, Timecode time)\n{\n    RayBasic localRay = RayToObjectSpace(ray.od, transform);\n    float localMag = length(localRay.d);\n    localRay.d /= localMag;    \n    \n    #define kSDFMaxIters 50\n    #define kSDFCutoffThreshold 1e-3\n    #define kSDFFailThreshold   1e-2\n    #define kSDFEscapeThreshold 5.0\n    #define kSDFNewtonStep 0.95\n    #define kCameraClipPlane 0.05 \n\n    #define kSDFIsosurface 0.001\n\n    float oscilTime = 1. - cos01(time.z * 0.2);\n    #define bBoxLower vec3(kDocBBox.xy, -5.)\n    #define bBoxUpper vec3(kDocBBox.zw, 5.)\n    #define partLower vec3(kDocBBox.xy, -1. * mix(0.5, 0.05, oscilTime))\n    #define partUpper vec3(kDocBBox.zw, 1. * mix(0.5, 0.05, oscilTime))\n    #define sdfLower vec3(kDocBBox.xy, -1. * mix(0.1, 0.01, oscilTime))\n    #define sdfUpper vec3(kDocBBox.zw, 1. * mix(0.1, 0.01, oscilTime))\n\n    vec2 tNearFar;\n    if(!RayBoundingBox(localRay, tNearFar, bBoxLower, bBoxUpper)) { return false; }\n                \n    int iterIdx;\n    bool isSubsurface;      \n    bool isBounded = false;\n    float t = max(kCameraClipPlane, tNearFar.x); \n    vec3 p = localRay.o + t * localRay.d;    \n    \n    vec4 F;\n    for(iterIdx = 0; iterIdx < kSDFMaxIters; ++iterIdx)\n    {         \n        float partIdx = (p.z - 0.5 * (bBoxUpper.z - bBoxLower.z)) / (partUpper.z - partLower.z) + 0.5;\n        p.z = mix(partLower.z, partUpper.z, fract(partIdx));      \n        \n        F = SDFQuadraticPath(p, sdfLower, sdfUpper, iChannel3);\n        //F = SDFTube(p, 0.05, 0.1); \n                \n        F.x -= kSDFIsosurface;\n        \n        // On the first iteration, simply determine whether we're inside the isosurface or not\n        if(iterIdx == 0) { isSubsurface = F.x < 0.0; }\n        // Otherwise, check to see if we're at the surface\n        else if(F.x > 0.0 && F.x < kSDFCutoffThreshold) { break; }        \n        \n        if(!isBounded) { if(F.x < kSDFEscapeThreshold) { isBounded = true; } }\n        else if(F.x > kSDFEscapeThreshold) {  return false; }\n        \n        t += isSubsurface ? -F.x : F.x;\n        if(t > tNearFar.y) { return false; }\n        \n        p = localRay.o + t * localRay.d;\n    }  \n        \n    if(F.x > kSDFFailThreshold || t > ray.tNear) {  return false; }    \n    \n    t /= localMag;\n    \n    ray.tNear = t;\n    hit.n = normalize(transpose(transform.rot) * F.yzw);\n    hit.kickoff = 1e-3;\n    SetRayFlag(ray, kFlagsBackfacing, isSubsurface);\n    \n    return true;\n}\n\n\n///////////////// INTEGRATOR //////////////////////\n\nbool IntegratePath(inout Ray ray, inout vec3 aovs, in Timecode time, int sampleIdx, int mlpMode, ivec2 resolution, sampler2D mlpSampler)\n{\n    #define kTFarMax         1e3\n    #define kMaxDepth        1\n\n    HitCtx hit; \n    ray.tNear = kTFarMax;\n    float L = 0.;\n   \n    float theta = sin(kTwoPi * time.y - 1.) * 0.85;\n    theta = pow(abs(theta), 1.5) * sign(theta) * kHalfPi;\n    Transform transform = CompoundTransform(vec3(0., 0., 0.), vec3(0., theta, 0.0), 1.5);\n    bool isHit = RaySDF(ray, hit, transform, time);\n    if(isHit)\n    {\n        L = dot(hit.n, -ray.od.d); \n    }\n    else\n    {\n         hit.n = vec3(0.0, 0.0, 1.0);         \n    }              \n    \n    aovs.x = PackFloats(L, ray.tNear);\n    aovs.y = PackFloats(hit.n.xy);\n    aovs.z = hit.n.z;\n     \n    return isHit;}\n\nvoid mainImage( out vec4 rgba, in vec2 xyScreen )\n{ \n    rgba = vec4(0.);    \n    \n    SetGlobals(xyScreen, iResolution.xy); \n     \n    #define kContinuousRender true\n    #define kStopAfterFrames 1\n    #define kAntiAlias 1\n    #define kNumSamples (kAntiAlias*kAntiAlias)\n    \n    PCGInitialise(HashOf(uint(rgba.w), uint(xyScreen.x), uint(xyScreen.y)));    \n \n    vec2 xyAA = xyScreen + vec2(0.5);\n\n    vec2 uvView = TransformScreenToWorld(xyAA);             \n\n    TimingCtx timingCtx = GetAnimationCtx(iTime, xyScreen, iResolution.xy);  \n    \n    Timecode timecode;\n    timecode.x = 20.0 * timingCtx.time;\n    timecode.y = timingCtx.time * 0.3;\n    timecode.z = timingCtx.time * 7.;\n    \n    // Create a new camera ray and store the sampled wavelength (we reuse the same ray at each bounce)   \n    Ray ray = CreatePinholeCameraRay(uvView, vec3(0.0, 0., -1.), vec3(0.001, -0.01, 0.001));\n            \n    vec3 aovs;    \n    rgba.w = float(IntegratePath(ray, aovs, timecode, iFrame, 1, ivec2(iResolution.xy), iChannel2));   \n    rgba.xyz = aovs;\n \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    SDF acceleration structure\n*/\n\nvec2 ScreenToView(vec2 xy)\n{\n    vec2 uv = ((xy / kPathAccelDims.xy) - vec2(0.5, 0.));\n    return uv * vec2(1., kPathAccelDims.y / kPathAccelDims.x) + vec2(0.5, 0.);\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xyScreen )\n{  \n    if(xyScreen.x >= kPathAccelDims.x || xyScreen.y >= kPathAccelDims.y) { return; }\n    \n    if(iFrame == 4)\n    {\n        vec4 texel = texelFetch(iChannel0, ivec2(xyScreen), 0);\n        vec4 sorted = vec4(texel[0], -1.0, -1.0, -1.0); \n                \n        int i = 1;\n        for(int u = 1; u < 4; ++u)\n        {\n            int v = u - 1;\n            for(; v >= 0; --v)\n            {\n                if(texel[u] == texel[v]) { break; }\n            }\n            if(v == -1) { sorted[i++] = texel[u]; }\n        }\n        \n        rgba = sorted;        \n        return;\n    }    \n    else if(iFrame > 4)\n    {\n        rgba = texelFetch(iChannel0, ivec2(xyScreen), 0);\n        return;\n    }\n    \n    rgba = (iFrame == 0) ? vec4(0.0) : texelFetch(iChannel0, ivec2(xyScreen), 0);\n    \n    vec2 xyView = ScreenToView(xyScreen + vec2(float(iFrame % 2), float(iFrame / 2)) * 1.0 - .0);\n    xyView -= 0.5 * vec2(1., kPathAccelDims.y / kPathAccelDims.x);\n    \n    float distNear2 = kFltMax;\n    int idxNear;\n    for(int splineIdx = 0; splineIdx < kNumSplines; ++splineIdx)\n    {             \n        float tPerp;\n        vec2 xyPerp;\n        if(QuadradicSplinePerpendicularPointApprox(points[splineIdx*2], points[splineIdx*2+1], 0.02, xyView, tPerp, xyPerp))\n        {\n            float dist2 = length2(xyPerp - xyView);\n            if(dist2 < distNear2)\n            {\n                idxNear = splineIdx;\n                distNear2 = dist2;\n            }\n        }\n    } \n    \n    rgba[iFrame % 4] = float(idxNear);\n}\n\n\n\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    Cel shading\n*/\n\nvoid Tap(in ivec2 xyScreen, out vec3 lda, out vec3 n)\n{\n    vec4 texel = texelFetch(iChannel0, xyScreen, 0);\n        \n    n.xy = UnpackFloats(texel.y);\n    n.z = texel.z; \n    \n    UnpackFloats(texel.x, lda.x, lda.y);    \n    lda.z = texel.w;\n}\n\nvec3 Cel(in ivec2 xyScreen)\n{\n    vec3 n0, lda0;\n    Tap(xyScreen, lda0, n0);\n    \n    vec3 sumL = kZero;\n    float sumWeights = 0.0;\n    int x = int(xyScreen.x), y = int(xyScreen.y);\n    \n    #define kInnerRadius 1\n    vec3 innerFaceL = kZero;\n    vec3 innerEdgeL = kZero;\n    for(int v = -kInnerRadius; v <= kInnerRadius; ++v)\n    {\n        for(int u = -kInnerRadius; u <= kInnerRadius; ++u)\n        {\n            if(x + u < 0 || x + u >= int(iResolution.x) || y + v < 0 || y + v >= int(iResolution.y)) { continue; }           \n            \n            vec3 nk, ldak;\n            Tap(ivec2(x + u, y + v), ldak, nk);                       \n            \n            float kernelWeight = 1.0 - sqr(length(vec2(u, v)) / 3.0);\n            if(kernelWeight <= 0.0) { continue; }\n            \n            #define kNormGain (0.03 * float(kInnerRadius))\n            #define kNormBias 1.02\n            float deltaN = dot(normalize(nk), normalize(n0));\n            float normWeight = ((deltaN * kNormBias) - (1.0 - kNormGain)) / kNormGain;\n\n            #define kDepthBias (2. * float(kInnerRadius))\n            float deltaD = abs(log(1.0 + ldak.y) - log(1.0 + lda0.y));\n            float depthWeight = 1.0 - deltaD * float(kDepthBias);\n\n            float weight = saturate(depthWeight) * saturate(normWeight);   \n            \n            float tone = pow(ldak.x, 2.);\n            innerFaceL += kOne * tone * kernelWeight;\n            innerEdgeL += kOne * ErfApprox((weight - 0.5) * 4.) * kernelWeight;\n            sumWeights += kernelWeight;\n        }\n    }    \n    innerFaceL /= sumWeights;    \n    innerEdgeL /= sumWeights;\n\n    vec3 outerEdgeL = kZero;\n    sumWeights = 0.0;\n    #define kOuterRadius 1\n    for(int v = -kOuterRadius; v <= kOuterRadius; ++v)\n    {\n        for(int u = -kOuterRadius; u <= kOuterRadius; ++u)\n        {\n            if(x + u < 0 || x + u >= int(iResolution.x) || y + v < 0 || y + v >= int(iResolution.y)) { continue; }           \n            \n            vec3 nk, ldak;\n            Tap(ivec2(x + u, y + v), ldak, nk);   \n            \n            float kernelWeight = 1.0- sqr(length(vec2(u, v)) / float(sqr(kOuterRadius + 1)));\n            if(kernelWeight <= 0.0) { continue; }\n                     \n            #define kAlphaBias 10.\n            float deltaA = abs(ldak.z - lda0.z);\n            float alphaWeight = 1.0 - deltaA * kAlphaBias;\n            \n            float weight = saturate(alphaWeight);\n            \n            outerEdgeL += kOne * (1.0 - (3. * (1.0 - weight))) * kOne * kernelWeight;   \n            sumWeights += kernelWeight;\n        }\n    }     \n    outerEdgeL /= sumWeights;\n    \n    return vec3(innerFaceL.x, 1. - saturate(innerEdgeL.x) * saturate(outerEdgeL.x), lda0.z * exp(-sqr(0.3 * lda0.y)));\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n    SetGlobals(xy, iResolution.xy);      \n    \n    rgba.xyz = max(kZero, Cel(ivec2(xy)));    \n    rgba.w = 1.0;\n  \n}","name":"Buffer C","description":"","type":"buffer"}]}