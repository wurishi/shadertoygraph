{"ver":"0.1","info":{"id":"cslGWf","date":"1666898289","viewed":96,"name":"Vector field with path","username":"Envy24","description":"Use mouse to drag starting point.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sdf","distance","field","function","vector","arrow","l2"],"hasliked":0,"parentid":"ddX3WX","parentname":"Truncated vector field"},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define PIXELATE(SC, PS)          ( floor( (SC) / (PS) ) * (PS) )    // PS - pixel size\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define FIELD_SCALE                 5.0\n#define PI                          3.1415926535897932\n\n// Points after point E.\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R,\n    in float S) // Scale for working in screen coordinates.\n{\n    float len = length(B-E);\n    vec2 dir = len < 1e-7 ? vec2(1,0) : normalize(E-B),\n         up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,\n         C = E - dir * 0.05 * S, //      U--\n         U = C + up  * 0.05 * S, // B----C--E--E'\n         D = C - up  * 0.05 * S; //      D--\n         E += dir * 0.1375 * S;\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.1375 ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-R;\n}\n\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          curves_sdf = C + amp*smoothstep(4./R.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= curves_sdf;              // Add interleaved curves.\n    \n    return mix(color, vec3(1), smoothstep(6./R.y, 0., abs(dist)) );\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( vec2(0.) )//( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin)\n{\n    return ((2. * (SC - MOUSE_OFFSET) - R.xy) / R.y) * scale - origin;\n}\nvec2 unmap_from_centered_ndc(in vec2 NDC, in float scale, in vec2 origin)\n{\n    return ((((NDC + origin) / scale) * R.y) + R.xy) * 0.5 + MOUSE_OFFSET;       \n}\n\n// For control: https://www.geogebra.org/m/QPE4PaDZ\n\n// for NDC\nvec2 vector_field_ndc(vec2 P)\n{\n    //return vec2(1, 1);\n    //return vec2(P.y, -P.x);\n    return vec2(P.y*P.y, -P.x);\n    //return rotateAroundZ(vec2(P.y, -P.x), iTime);\n    //return rotateAroundZ(vec2(P.y*P.y, -P.x), iTime);\n}\n// for SC\nvec2 vector_field_sc(vec2 P)\n{\n    // Examples from: https://www.shadertoy.com/view/4s23DG\n    //return vec2(cos(P.x * 0.01 + P.y * 0.01) + cos(P.y * 0.005 + iTime), 2.0 * cos(P.y * 0.01  + iTime * 0.3)) * 0.5;;\n    return vec2(cos(P.x * 0.017 + cos(P.y * 0.004 + iTime * 0.1) * 6.28 * 4.0) * 3.0, cos(6.28 * cos(P.y * 0.01 + P.x * 0.007)));\n    //return 2.0 * texture(iChannel0, (P + vec2(iTime * 100.0, 0.0)) / iChannelResolution[0].xy).xy - 1.0;\n    \n}\n\n#define SCREEN_COORDINATES\n\n#ifdef SCREEN_COORDINATES\n// for range xy = [0; R.x][0; R.y]\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    const float SCALE = 25.;\n    \n    /* Process trace.*/\n    float minDist = 99., step_ = 10.;\n    vec2 B = LMB_IS_HOLD ? iMouse.xy : vec2(R.xy*0.5)+vec2(100,-100);\n    for (float i = 0.; i < 40.; i += 1.)\n    {\n        vec2 dir = vector_field_sc(B);\n        float mag = length(dir)*step_;\n        vec2 E = B + normalize(dir) * mag;\n\n        minDist = min( minDist,  arrowSDF(SC, B, E, 0., 3.*SCALE) );  \n        B = E;      \n    }\n    \n    /* Process grid of arrows */\n          B = PIXELATE(SC, SCALE) + vec2(SCALE/2.);\n    vec2 dir = vector_field_sc(B);\n    float mag = clamp(length(dir) * 10., 0., SCALE*0.35);\n         dir = normalize(dir);\n    vec2 E = B + dir * mag;\n         B -= dir * mag;\n\n    /* Colorize vector field. */\n    vec3 color = vec3(vector_field_sc(SC) * 0.5 + 0.5, 0.5);  // Smooth     \n    /* Draw grid */   \n         color = mix( color, vec3(1.), smoothstep(2., 0., arrowSDF(SC, B, E, 0., SCALE)));\n    /* Draw trace */\n         color = mix( color, vec3(0.), smoothstep(2.5, 0., minDist));  \n\n    O = vec4(color, 1.0);\n}\n#else\n// for range xy = [-5.*AR; 5.*AR][-5; 5.]\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float SCALE = 25.;\n    vec2 NDC = map_to_centered_ndc(SC, FIELD_SCALE, vec2(0));\n  \n    /* Process trace.*/\n    float minDist = 99., step_ = 0.25;\n    vec2 B = LMB_IS_HOLD ? map_to_centered_ndc(iMouse.xy, FIELD_SCALE, vec2(0)) : vec2(1.);\n    for (float i = 0.; i < 40.; i += 1.)\n    {\n        vec2 dir = vector_field_ndc(B);\n        float mag = length(dir)*step_;\n        vec2 E = B + normalize(dir) * mag;\n\n        minDist = min( minDist,  arrowSDF(NDC, B, E, 0., 2.0) );   \n        B = E;      \n    }\n    \n    /* Process grid of arrows */\n          B = map_to_centered_ndc(PIXELATE(SC, SCALE) + vec2(SCALE/2.), FIELD_SCALE, vec2(0));\n    vec2 dir = vector_field_ndc(B);\n    float mag = clamp(length(dir) * 0.01, 0., SCALE*0.005);\n    vec2 E = B + normalize(dir) * mag;\n         B -= normalize(dir) * mag*2.;\n        \n    /* Colorize vector field. */\n    vec3 color = vec3(normalize(vector_field_ndc(NDC).xy/mag), 0.5);\n    /* Draw grid */   \n         color = mix( color, vec3(1.), smoothstep(16./R.y, 0., arrowSDF(NDC, B, E, 0., 1.0)));\n    /* Draw trace */\n         color = mix( color, vec3(0.), smoothstep(16./R.y, 0., minDist));       \n\n    O = vec4(color, 1.0);\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}","name":"Common","description":"","type":"common"}]}