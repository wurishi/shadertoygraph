{"ver":"0.1","info":{"id":"4dfyWj","date":"1489798863","viewed":548,"name":"ResolveTestVR","username":"TimothyLottes","description":"Comparison of VR resolve methods","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","msaa","vrresolveshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// CHANGE THIS MODE DEFINE TO TRY DIFFERENT OPTIONS\n//  \n// Sorry, only looks right at 1920x1080 non-full-screen.\n//\n\n// Major under-sampling in the center.\n// Major over-sampling towards the ends.\n// Warp not intended to look like VR, but have similar properties.\n// All of these are linear filtering operations.\n\n// 0 Red ......... NoAA Resolve Then Nearest Warp\n// 1 Orange ...... NoAA Resolve Then Bilinear Warp\n// 2 Gold ........ 4xSGSSAA Box Resolve Then Bilinear Warp\n// 3 Yellow ...... 4xSGSSAA Gaussian Resolve With Warp + Noise\n\n#define MODE 3\n\n//================================================================================\n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\n// Kernel scale.\n// This is a horrible hack, but maybe good enough for now.\nF1 Kern(F2 p){\n // Convert to {-1 to 1} space.\n p=p/iResolution.xy;p=p*2.0-1.0;\n p=abs(p);\n p=p*p*0.5+p*0.5;\n return 0.5*p.x+0.5*p.y;}\n\n// Warp (given integer coordinates).\n// This is a proxy for a VR warp.\nF2 Warp(F2 p){\n // Convert to {-1 to 1} space.\n p=p/iResolution.xy;p=p*2.0-1.0;\n // Transform.\n p=p*abs(p)*0.5+p*0.5;\n // Convert back to integer.\n p=p*0.5+0.5;p*=iResolution.xy;return p;}\n\n// Unwarp.\nF2 Unwarp(F2 p){\n // Convert to {-1 to 1} space.\n p=p/iResolution.xy;p=p*2.0-1.0;\n // Invert transform.\n F2 pp=p;\n p=abs(p);\n p=0.5*(sqrt(8.0*p+1.0)-1.0);\n if(pp.x<0.0)p.x=-p.x;\n if(pp.y<0.0)p.y=-p.y;\n // Convert back to integer.\n p=p*0.5+0.5;p*=iResolution.xy;return p;}\n\n// Convert from linear to sRGB.\nF1 Srgb(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\n\n// Convert from sRGB to linear.\nF1 Linear(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}    \n\n//\n// Semi-Poor Quality Temporal Noise\n//\n\n// Base.\n// Ripped ad modified from: https://www.shadertoy.com/view/4djSRW\nF1 Noise(F2 p,F1 x){p+=x;\n F3 p3=fract(F3(p.xyx)*10.1031);\n p3+=dot(p3,p3.yzx+19.19);\n return fract((p3.x+p3.y)*p3.z)*2.0-1.0;}\n\n// Step 1 in generation of the dither source texture.\nF1 Noise1(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-12.0,t=1.0;   \n return (1.0/max(a*4.0+b*4.0,-c))*(\n  Noise(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Step 2 in generation of the dither source texture.\nF1 Noise2(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-2.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0))*(\n  Noise1(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise1(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise1(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise1(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise1(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise1(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise1(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise1(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise1(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n\n// Compute temporal dither from integer pixel position uv.\nF1 Noise3(F2 uv){return Noise2(uv,fract(iTime));}    \n\n// Energy preserving dither, for {int pixel pos,color,amount}.\nF1 Noise4(F2 uv,F1 c,F1 a){\n // Grain value {-1 to 1}.\n F1 g=Noise3(uv)*2.0;\n // Step size for black in non-linear space.\n F1 rcpStep=1.0/(256.0-1.0);\n // Estimate amount negative which still quantizes to zero.\n F1 black=0.5*Linear(rcpStep);\n // Estimate amount above 1.0 which still quantizes to 1.0.\n F1 white=2.0-Linear(1.0-rcpStep);\n // Add grain.\n return clamp(c+g*min(c+black,min(white-c,a)),0.0,1.0);}\n\n//\n// Pattern\n//\n\n// Dummy shader given pixel position.\nF1 Shade(F2 p){\n p.xy+=sin(iTime)*2.0;\n F2 pp=F2(p.x+p.y/16.0,p.y+p.x/16.0);\n pp*=pp;\n F1 x=sin(pp.x/800.0)>0.0?0.5:0.0;\n F1 y=sin(pp.y/1000.0)>0.0?0.5:0.0;\n return x+y;}\n\n// 4xMSAA pattern for quad given integer coordinates.\n//\n//  . x . . | < pixel\n//  . . . x |\n//  x . . .\n//  . . x .\n//\n//  01\n//  23\n//\nF2 Quad4(F2 pp){\n int q=(int(pp.x)&1)+((int(pp.y)&1)<<1);\n if(q==0)return pp+F2( 0.25,-0.25);\n if(q==1)return pp+F2( 0.25, 0.25);\n if(q==2)return pp+F2(-0.25,-0.25);\n         return pp+F2(-0.25, 0.25);}\n\n// Rotate {0.0,r} by a {-1.0 to 1.0}. \nF2 Rot(F1 r,F1 a){return F2(r*cos(a*3.14159),r*sin(a*3.14159));}\n\n// Rotate {pp} by a {0.0 to 1.0}. \nF2 Rot2(F2 pp,F1 a){\n a*=3.14159*2.0;\n F1 cosA=cos(a);\n F1 sinA=sin(a);\n return F2(dot(pp,F2(cosA,sinA)),dot(pp,F2(-sinA,cosA)));}\n\n//\n// RESOLVES\n//\n    \n// Single center sample, nearest warp.\nF1 ResolveNoAA(F2 pp){return Shade(floor(Warp(pp)));}\n\n// Single center sample, bilinear warp.\nF1 ResolveNoAABi(F2 pp){\n pp=Warp(pp);\n F2 ii=floor(pp);\n F1 a=Shade(ii);\n F1 b=Shade(ii+F2(1.0,0.0));\n F1 c=Shade(ii+F2(0.0,1.0));\n F1 d=Shade(ii+F2(1.0,1.0));\n F2 ff=pp-ii;\n a=mix(a,b,ff.x);\n c=mix(c,d,ff.x);\n a=mix(a,c,ff.y);\n return a;}\n\nF1 Shade4(F2 pp){return\n Shade(pp+F2( 0.125,-0.375))*0.25+\n Shade(pp+F2(-0.375,-0.125))*0.25+\n Shade(pp+F2( 0.375, 0.125))*0.25+\n Shade(pp+F2(-0.125, 0.375))*0.25;}\n\n// 4xSGSSAA box resolve, bilinear warp.\nF1 Resolve4xBi(F2 pp){\n pp=Warp(pp);\n F2 ii=floor(pp);\n F1 a=Shade4(ii);\n F1 b=Shade4(ii+F2(1.0,0.0));\n F1 c=Shade4(ii+F2(0.0,1.0));\n F1 d=Shade4(ii+F2(1.0,1.0));\n F2 ff=pp-ii;\n a=mix(a,b,ff.x);\n c=mix(c,d,ff.x);\n a=mix(a,c,ff.y);\n return a;}\n\n// Resolve With Warp\n\nvoid M44(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F1 kern=Kern(mm);\n kern*=3.0;\n F2 jj=Quad4(pp);\n F1 c=Shade(jj);\n jj=Unwarp(jj);\n F2 vv=mm-jj;\n F1 w=exp2(-(0.5+kern)*dot(vv,vv));    \n sumC+=c*w;sumW+=w;}\n\nvoid M4(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n M44(sumC,sumW,pp+F2( 0.125,-0.375),mm);\n M44(sumC,sumW,pp+F2(-0.375,-0.125),mm);\n M44(sumC,sumW,pp+F2( 0.375, 0.125),mm);\n M44(sumC,sumW,pp+F2(-0.125, 0.375),mm);}\n\n// 4xSGSSAA Gaussian Resolve With Warp\n// Over-kill on the number of filter taps taken for the resolve,\n// this is not required in practice,\n// just don't have time for an optimal implementation.\nF1 ResolveM4(F2 pp){\n F2 ww=floor(Warp(pp));\n F1 sumC=0.0;\n F1 sumW=0.0;\n // \n M4(sumC,sumW,ww+F2(-1.0,-2.0),pp);\n M4(sumC,sumW,ww+F2( 0.0,-2.0),pp);\n M4(sumC,sumW,ww+F2( 1.0,-2.0),pp);\n //\n M4(sumC,sumW,ww+F2(-2.0,-1.0),pp);\n M4(sumC,sumW,ww+F2(-1.0,-1.0),pp);\n M4(sumC,sumW,ww+F2( 0.0,-1.0),pp);\n M4(sumC,sumW,ww+F2( 1.0,-1.0),pp);\n M4(sumC,sumW,ww+F2( 2.0,-1.0),pp);\n //\n M4(sumC,sumW,ww+F2(-2.0, 0.0),pp);\n M4(sumC,sumW,ww+F2(-1.0, 0.0),pp);\n M4(sumC,sumW,ww+F2( 0.0, 0.0),pp);\n M4(sumC,sumW,ww+F2( 1.0, 0.0),pp);\n M4(sumC,sumW,ww+F2( 2.0, 0.0),pp);\n //   \n M4(sumC,sumW,ww+F2(-2.0, 1.0),pp);\n M4(sumC,sumW,ww+F2(-1.0, 1.0),pp);\n M4(sumC,sumW,ww+F2( 0.0, 1.0),pp);\n M4(sumC,sumW,ww+F2( 1.0, 1.0),pp);\n M4(sumC,sumW,ww+F2( 2.0, 1.0),pp);\n //\n M4(sumC,sumW,ww+F2(-1.0, 2.0),pp);\n M4(sumC,sumW,ww+F2( 0.0, 2.0),pp);\n M4(sumC,sumW,ww+F2( 1.0, 2.0),pp);\n // \n return sumC/sumW;}\n\n\n\n\n\n//\n// ENTRY\n//\n\nvoid mainImage(out F4 fragColor,in F2 fragCoord){\n F2 pp=fragCoord;\n F1 cc=0.0;\n int ss=MODE;\n // Red\n if(ss==0){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.0,0.0);return;}\n  cc=ResolveNoAA(pp);}\n // Orange\n else if(ss==1){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.5,0.0);return;}\n  cc=ResolveNoAABi(pp);}\n // Gold\n else if(ss==2){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.75,0.0);return;}\n  cc=Resolve4xBi(pp);}\n // Yellow\n else if(ss==3){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,1.0,0.0);return;}\n  cc=ResolveM4(pp);\n  cc=Noise4(pp,cc,1.0/16.0);}\n // Output   \n fragColor.x=Srgb(cc);\n fragColor.yxz=fragColor.xxx;}\n","name":"Image","description":"","type":"image"}]}