{"ver":"0.1","info":{"id":"cdVyDR","date":"1695984715","viewed":69,"name":"Ellipsoid rubber duck","username":"jaolejnik","description":"I wanted to practice some ray marching, so I decided to model my debugging rubber duck. Here it is, made entirely of ellipsoids!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","duck"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// materials id\n#define EYES_ID 0.0\n#define TONGUE_ID 1.0\n#define BEAK_ID 2.0\n#define BODY_ID 3.0\n\n// math constants\nconst float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;\n\n// ray marching constants\nconst float MIN_HIT_DISTANCE = 0.001;\nconst float MAX_TRACE_DISTANCE = 100.0;\nconst int STEP_COUNT = 500;\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox(in vec3 p, in vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// https://iquilezles.org/articles/smin/\nvec2 smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    float m = h*h * 0.5;\n    float s = m*k * (1.0 / 2.0);\n    return (a < b) ? vec2(a - s, m) : vec2(b - s, 1.0 - m);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec3 bend(in vec3 p, float strength)\n{\n    float c = cos(strength * p.x);\n    float s = sin(strength * p.x);\n    mat2 m = mat2(c, - s, s, c);\n    \n    return vec3(m * p.xy, p.z);\n}\n\nvec4 opUnion(in vec4 d1, in vec4 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec4 opSmoothUnion(in vec4 d1, in vec4 d2, float k)\n{\n    d1.xz = smin(d1.x, d2.x, k);\n    d1.w = d2.y;\n    \n    return d1;\n}\n\nvec3 rotate(in vec3 theta, in vec3 p)\n{\n    vec3 s = sin(PI / 180.0 * theta);\n    vec3 c = cos(PI / 180.0 * theta);\n    \n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, c.x, s.x ,\n        0.0, - s.x, c.x\n    );\n    \n    mat3 rotY = mat3(\n        c.y, 0.0, - s.y,\n        0.0, 1.0, 0.0,\n        s.y, 0.0, c.y\n    );\n    mat3 rotZ = mat3(\n        c.z, s.z, 0.0,\n        - s.z, c.z, 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    return rotZ * rotY * rotX * p;\n}\n\nvec4 sdDuck(in vec3 p)\n{\n    vec3 pSymmetricX = vec3(abs(p.x), p.yz);\n    \n    // calculate duck's body parts\n    float sdBodyBase = max(\n        sdEllipsoid(p, vec3(1.8, 1.3, 2.0) * clamp(iTime - 0.1, 0.001, 1.0)),\n        - sdBox(p - vec3(0.0, - 1.2, 0.0), vec3(5.0, 0.5, 5.0) * clamp(iTime - 1.0, 0.001, 1.0))\n    );\n    \n    float sdHead = sdEllipsoid(\n        rotate(vec3(45.0, 0.0, 0.0), p - vec3(0.0, 2.0, - 0.5)),\n        vec3(1.1, 1.0, 1.15) * clamp(iTime - 2.0, 0.001, 1.0)\n    );\n    \n    float sdWings = sdEllipsoid(\n        rotate(vec3(30.0, - 15.0, 90.0), pSymmetricX - vec3(1.65, 0.2, 0.2)),\n        vec3(0.6, 0.3, 0.75) * clamp(iTime - 3.0, 0.001, 1.0)\n    );\n    \n    float sdTail = sdEllipsoid(\n        rotate(vec3(35.0, 0.0, 0.0), p - vec3(0.0, 0.3, 1.3)),\n        vec3(0.8, 0.5, 1.1) * clamp(iTime - 4.0, 0.001, 1.0)\n    );\n    \n    float sdBody = smin(sdBodyBase, sdHead, 0.3).x;\n    sdBody = smin(sdBody, sdTail, 0.4).x;\n    sdBody = smin(sdBody, sdWings, 0.2).x;\n    \n    float sdBeakUpper = sdEllipsoid(\n        rotate(vec3(-10.0, 0.0, 0.0), bend(p - vec3(0.0, 2.1, - 1.5), - 0.8)),\n        vec3(0.6, 0.15, 0.6) * clamp(iTime - 5.2, 0.001, 1.0)\n    );\n    \n    float sdBeakLower = sdEllipsoid(\n        rotate(vec3(-15.0, 0.0, 0.0), bend(p - vec3(0.0, 1.6, - 1.5), 0.8)),\n        vec3(0.6, 0.15, 0.5) * clamp(iTime - 5.7, 0.001, 1.0)\n    );\n    \n    float sdBeak = min(sdBeakLower, sdBeakUpper);\n    \n    float sdTongue = sdEllipsoid(\n        p - vec3(0.0, 1.85, - 1.5),\n        vec3(0.4, 0.15, 0.45) * clamp(iTime - 6.0, 0.001, 1.0)\n    );\n    \n    float sdEyes = sdEllipsoid(\n        rotate(vec3(-30.0, 20.0, 0.0), pSymmetricX - vec3(0.55, 2.5, - 1.15)),\n        vec3(0.15, 0.2, 0.1) * clamp(iTime - 6.5, 0.001, 1.0)\n    );\n    \n    // assign material data to distance values\n    vec4 bodyData = vec4(sdBody, BODY_ID, 1.0, - 1.0);\n    vec4 beakData = vec4(sdBeak, BEAK_ID, 1.0, - 1.0);\n    vec4 tongueData = vec4(sdTongue, TONGUE_ID, 1.0, - 1.0);\n    vec4 eyesData = vec4(sdEyes, EYES_ID, 1.0, - 1.0);\n    \n    // put it all together\n    vec4 duckData = opUnion(bodyData, eyesData);\n    duckData = opSmoothUnion(duckData, beakData, 0.1);\n    duckData = opUnion(duckData, tongueData);\n    \n    return duckData;\n}\n\nvec4 mapWorld(in vec3 p)\n{\n    vec4 d = vec4(MAX_TRACE_DISTANCE, - 1.0, 1.0, - 1.0);\n    vec4 duckData = sdDuck(p - vec3(0.0, - 1.0, 0.0));\n    \n    d = opUnion(d, duckData);\n    \n    return d;\n}\n\nvec3 calculateNormal(in vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    vec3 normal = vec3(\n        mapWorld(p + e.xyy).x - mapWorld(p - e.xyy).x,\n        mapWorld(p + e.yxy).x - mapWorld(p - e.yxy).x,\n        mapWorld(p + e.yyx).x - mapWorld(p - e.yyx).x\n    );\n    \n    return normalize(normal);\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat shadow(in vec3 rayOrigin, in vec3 rayDirection, float mint, float maxt)\n{\n    float totalDistance = mint;\n    for(int i = 0; i < 256; i ++ )\n    {\n        float currentPosition = mapWorld(rayOrigin + rayDirection * totalDistance).x;\n        if (currentPosition < 0.001)\n        return 0.0;\n        totalDistance += currentPosition;\n        \n        if (totalDistance > maxt)\n        break;\n    }\n    return 1.0;\n}\n\nvec3 mapMaterial(float materialId)\n{\n    \n    vec3 material = vec3(0.0);\n    \n    if (materialId == TONGUE_ID)\n    {\n        material = vec3(1.0, 0.1, 0.1);\n    }\n    else if (materialId == BEAK_ID)\n    {\n        material = vec3(1.0, 0.25, 0.07);\n    }\n    else if (materialId == BODY_ID)\n    {\n        material = vec3(1.0, 0.85, 0.07);\n    }\n    \n    return material;\n}\n\nvec3 applyMaterial(in vec3 materialData)\n{\n    vec3 material = mapMaterial(materialData.x);\n    \n    if (materialData.z >= 0.0)\n    {\n        material = mix(material, mapMaterial(materialData.z), materialData.y);\n    }\n    \n    return material;\n}\n\nvec3 rayMarch(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    float totalDistance = 0.0;\n    \n    for(int i = 0; i < STEP_COUNT; ++ i)\n    {\n        vec3 currentPosition = rayOrigin + rayDirection * totalDistance;\n        \n        vec4 dm = mapWorld(currentPosition);\n        float distanceToClosest = dm.x;\n        vec3 materialData = dm.yzw;\n        \n        if (distanceToClosest < MIN_HIT_DISTANCE)\n        {\n            vec3 normal = calculateNormal(currentPosition);\n            vec3 lightDirection = normalize(vec3(-0.8, 0.4, - 0.2));\n            vec3 reflectionDirection = reflect(lightDirection, normal);\n            \n            float sunShadow = shadow(currentPosition, lightDirection, 0.03, 10.0);\n            float diffuseLight = clamp(dot(normal, lightDirection), 0.0, 1.0) * sunShadow;\n            float specularLight = 0.2 * pow(clamp(dot(reflectionDirection, rayDirection), 0.0, 1.0), 5.0);\n            float ambientLight = 0.15;\n            vec3 material = applyMaterial(materialData);\n            \n            return material * (diffuseLight + ambientLight) + specularLight;\n        }\n        \n        if (totalDistance > MAX_TRACE_DISTANCE)\n        {\n            break;\n        }\n        \n        totalDistance += distanceToClosest;\n    }\n    \n    return mix(vec3(0.7, 0.7, 0.7), vec3(0.0, 0.5, 0.75), (rayDirection.y + 1.0) / 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 origin = vec3(0.0);\n    \n    // camera setup\n    float animate = 0.85 * iTime;\n    vec3 cameraPosition = 6.0 * vec3(sin(animate), 0.3, - cos(animate));\n    vec3 cameraForward = normalize(vec3(origin - cameraPosition));\n    vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));\n    vec3 rayDirection = normalize(p.x * cameraRight + p.y * cameraUp + 1.5 * cameraForward);\n    \n    vec3 color = rayMarch(cameraPosition, rayDirection);\n    \n    // gamma correction\n    color = sqrt(color);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}