{"ver":"0.1","info":{"id":"clGyR3","date":"1700457839","viewed":78,"name":"Simple 2D Ray Tracer","username":"rodrigopaml","description":"First attemp to implement a simple 2d Ray Tracer.\nDirect light is calculated by one trace between pixel and light.\nIndirect light is calculated when there is no direct light. A single ray is casted in all directions. ","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["2d","raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_SQUARES 5\n#define PI 3.14159265359\n#define INF 999999999.0\n\n// Defines the indirect light quality \n// This number indicates the number of rays casted to determine the indirect light\n// (for max quality put 360)\n#define DIR 180\n\nstruct Square\n{\n  vec2 position;\n  vec2 size;\n  vec3 color;\n};\n\n// Squares of the scene\nSquare squares[MAX_SQUARES];\n\n// Init squares\nvoid InitializeSquares() \n{\n  squares[0].position = vec2(100.0, 100.0);\n  squares[0].size = vec2(100.0, 100.0);\n  squares[0].color = vec3(1.0, 0.0, 0.0);\n  \n  squares[1].position = vec2(500.0, 200.0);\n  squares[1].size = vec2(50.0, 50.0);\n  squares[1].color = vec3(0.0, 1.0, 0.0);\n\n  squares[2].position = vec2(300.0, 150.0);\n  squares[2].size = vec2(75.0, 255.0);\n  squares[2].color = vec3(0.0, 0.0, 1.0);\n  \n  squares[3].position = vec2(300.0, 440.0);\n  squares[3].size = vec2(75.0, 275.0);\n  squares[3].color = vec3(0.0, 1.0, 1.0);\n  \n  squares[4].position = vec2(600.0, 200.0);\n  squares[4].size = vec2(75.0, 275.0);\n  squares[4].color = vec3(1.0, 1.0, 0.0);\n}\n\n// Intersection between lines detection\nbool LineLineIntersect(vec2 l1p1, vec2 l1p2, vec2 l2p1, vec2 l2p2) \n{\n  float ua = ((l2p2.x - l2p1.x) * (l1p1.y - l2p1.y) - (l2p2.y - l2p1.y) * (l1p1.x - l2p1.x)) / ((l2p2.y - l2p1.y) * (l1p2.x - l1p1.x) - (l2p2.x - l2p1.x) * (l1p2.y - l1p1.y));\n  float ub = ((l1p2.x - l1p1.x) * (l1p1.y - l2p1.y) - (l1p2.y - l1p1.y) * (l1p1.x - l2p1.x)) / ((l2p2.y - l2p1.y) * (l1p2.x - l1p1.x) - (l2p2.x - l2p1.x) * (l1p2.y - l1p1.y));\n  \n  return (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0);\n}\n\n// Intersection between line and rect detection\nbool LineRectIntersect(vec2 lineStart, vec2 lineEnd, vec2 rectCenter, vec2 rectSize)\n{\n  vec2 rectHalfSize = rectSize * 0.5;\n  vec2 rectMin = rectCenter - rectHalfSize;\n  vec2 rectMax = rectCenter + rectHalfSize;\n  \n  return (LineLineIntersect(lineStart, lineEnd, rectMin, vec2(rectMin.x, rectMax.y)) || LineLineIntersect(lineStart, lineEnd, vec2(rectMin.x, rectMax.y), rectMax) || LineLineIntersect(lineStart, lineEnd, rectMax, vec2(rectMax.x, rectMin.y)) || LineLineIntersect(lineStart, lineEnd, vec2(rectMax.x, rectMin.y), rectMin));\n}\n\n// Find the point of intersection between a ray and rect\nvec2 RayRectangleIntersection(vec2 rayOrigin, vec2 rayDirection, vec2 rectCenter, vec2 rectSize)\n{\n  vec2 halfSize = rectSize * 0.5;\n  vec2 rectPosition = rectCenter - halfSize;\n\n  vec2 t1 = (rectPosition - rayOrigin) / rayDirection;\n  vec2 t2 = (rectPosition + rectSize - rayOrigin) / rayDirection;\n\n  vec2 tMin = min(t1, t2);\n  vec2 tMax = max(t1, t2);\n\n  float tEnter = max(tMin.x, tMin.y);\n  float tExit = min(tMax.x, tMax.y);\n\n  if (tEnter > tExit || tExit < 0.0) \n      return vec2(-1.0, -1.0);\n        \n  vec2 intersectionPoint = rayOrigin + tEnter * rayDirection;\n\n  return intersectionPoint;\n}\n\n// Get a normalized direction between two points\nvec2 GetNormalizedDirection(vec2 fromPoint, vec2 toPoint)\n{\n  return normalize(toPoint - fromPoint);\n}\n\nbool IsRect(vec2 pos, vec2 size, vec2 currFrag)\n{\n    return (currFrag.x >= pos.x - size.x / 2.0 && currFrag.x <= pos.x + size.x / 2.0 && currFrag.y >= pos.y - size.y / 2.0 && currFrag.y <= pos.y + size.y / 2.0);\n}\n\n// Get normalized vector to an angle\nvec2 GetDirection(int angle) \n{\n   float r = (2.0 * PI * float(angle)) / float(DIR);\n   return normalize(vec2(cos(r), sin(r)));\n}\n\n// Return if reached by light\nbool ReachLight(vec2 fragPos, vec2 lightPos, int reduce)\n{\n  for (int i = 0; i < MAX_SQUARES; ++i) \n  {\n    vec2 size = squares[i].size;\n    \n    if(reduce == i)\n    {\n        size.x = size.x - 1.0;\n        size.y = size.y - 1.0;\n    }\n    \n    bool intersect = LineRectIntersect(lightPos, fragPos, squares[i].position, size);\n\n    if (intersect) \n      return false;\n  }\n  \n  return true;\n}\n\n// Calculate light based on distance\nfloat GetLight(float baseValue, float distanceToLight)\n{\n    return baseValue / (1.0 + 0.003 * distanceToLight + 0.00001 * distanceToLight * distanceToLight);\n}\n\n// Calculate light for an point in shadow (used in indirect light calculation only)\nfloat CalculateLightPixelI(vec2 fragPos, vec2 lightPos, int ignore)\n{\n  if (!ReachLight(fragPos, lightPos, ignore)) \n    return 0.0;\n  \n  float distanceToLight = distance(fragPos, lightPos);\n  float attenuation = GetLight(1.0, distanceToLight);\n  \n  return attenuation;\n}\n\n// Calculate indirect light by casting rays around the pixel\n// If a ray hits a particular quad that have light in it, it will be take into account\n// Only take into account the nearest hit for each direction\nfloat CalculateIndirectLight(vec2 fragPos, vec2 lightPos) \n{\n  float result = 0.0;\n  float hits = 0.0;\n  \n  // Cast rays around the dark pixel\n  for (int j = 0; j < DIR; ++j) \n  {\n    vec2 dir = GetDirection(j);\n    \n    float nearestDistance = INF;\n    float dirResult = 0.0;\n    \n    // Test foreach quad\n    for (int i = 0; i < MAX_SQUARES; ++i)\n    {\n      // Where the ray hit the quad\n      vec2 interP = RayRectangleIntersection(fragPos, dir, squares[i].position, squares[i].size);\n      \n      if (interP == vec2(-1, -1)) \n          continue;\n          \n      float distIntersect = distance(squares[i].position, fragPos);\n      \n      // We only want the more closest hit\n      if(distIntersect > nearestDistance)\n          continue;\n             \n      // Calculate the light intensity in the point hitted\n      float lightInIntersection = CalculateLightPixelI(interP, lightPos, i);\n      \n      // Attenuate until it get in fragPos\n      float distanceToLight = distance(interP, fragPos);\n      float correctedLight = GetLight(lightInIntersection, distanceToLight);\n      \n      // Calculate vectors from the intersected point to (light and pixel)\n      vec2 dirToLight = GetNormalizedDirection(interP, lightPos);\n      vec2 dirToPoint = GetNormalizedDirection(interP, fragPos);   \n\n      // Get the angle\n      float dotProduct = dot(dirToLight, dirToPoint);\n      float angleCloseness = 0.5 * (dotProduct + 1.0);\n      \n      nearestDistance = distIntersect;\n      dirResult = correctedLight * max(0.5, angleCloseness);\n    }\n    \n    if(nearestDistance != INF)\n    {\n        result += dirResult;\n        hits = hits + 1.0;\n    }\n  }\n  \n  return result/hits;\n}\n\n// Main function that calculates light for each pixel\nfloat CalculateLightPixel(vec2 fragPos, vec2 lightPos) \n{ \n  // Here its for indirect light\n  if (!ReachLight(fragPos, lightPos, -1)) \n    return CalculateIndirectLight(fragPos, lightPos);\n  \n  // Direct light\n  float distanceToLight = distance(fragPos, lightPos);\n  float attenuation = GetLight(1.0f, distanceToLight);\n  \n  return attenuation;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n  InitializeSquares();\n  \n  vec3 color = vec3(1.0);\n  vec2 lightPosition = iMouse.xy;\n  \n  bool isQuad = false;\n  for (int i = 0; i < MAX_SQUARES; ++i) \n  {\n      bool q = IsRect(squares[i].position, squares[i].size, fragCoord.xy);\n      color += squares[i].color * float(q);\n      isQuad = isQuad || q;\n\n  }\n  \n   color = color * CalculateLightPixel(fragCoord.xy, lightPosition);\n  \n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}