{"ver":"0.1","info":{"id":"3sXyRn","date":"1583939254","viewed":101,"name":"Bug Walk","username":"spalmer","description":"making a bug animate, walk cycle, etc.  experimenting.  Might turn into an NPC enemy!\nFor this first test, I'll simply kinematically animate it, but next I might try a physically-modeled powered ragdoll skeleton.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this entire toy is based on https://shadertoy.com/view/tlGXDK\n\n#define BufferC   iChannel2\n\n\n// signed distance\n\nfloat dbox(float p)\n{\n    return abs(p) - 1.;\n}\n\n\n// iq's, mostly\nfloat dseg(vec3 q, vec3 a, vec3 b)\n{\n    q -= a; b -= a;\n    return length(q - b * clamp(dot(q, b) / dot(b, b), 0., 1.));\n}\n\n// https://iquilezles.org/articles/distfunctions\n// the blog page doesn't mention any license, so... I'm sort of confused, here, Inigo.\n#if 1\n// this is why I dislike the MIT license, it's this mandatory copy+paste \n// of this huge block of paranoid legalese text into my freaking code that\n// I'm trying to keep nice and clean and small and tidy:\n\n// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation \n// the rights to use, copy, modify, merge, publish, distribute, sublicense, \n// and/or sell copies of the Software, and to permit persons to whom the \n// Software is furnished to do so, subject to the following conditions: \n// The above copyright notice and this permission notice shall be included \n// in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, \n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES \n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR \n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I'm not a fan of lawyers' attempt to dominate intellectual discourse,\n// (look at the SHOUTING! are judges deaf?) but whatever.\n// And now, with no further ado, iq's very nice sdRoundCone implementation,\n// slightly modified to inline his dot2/sqr helper\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    vec3 pb = pa*l2 - ba*y;\n    float x2 = dot(pb,pb);\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n#endif\n\n// assumes the query coordinate has already been\n// transformed to the leg's rest pose along the x axis\nfloat dleg(vec3 q)\n{\n    float d1 = sdRoundCone(q, vec3(0), vec3(.4,0,0), .08, .03);\n    float d2 = sdRoundCone(q, vec3(.4,0,0), vec3(.9,-.18,0), .03, .02);\n    return min(d1, d2);\n}\n\nfloat Animation()\n{\n    return .2 * iTime + sin(2. * iTime) * .5;\n}\n\nfloat timeDisplacement()\n{\n    return 1. * iTime + sin(2. * iTime) * .2; ///.2;\n    //return Animation(); //fract();\n}\n\n\n// bug-local coordinates are relative to the base of the character,\n// the point beneath center of mass *at the ground* when walking.\n// It's much easier to get feet to match ground when animating.\n// So just indicate the point on the ground you'd like it to be at.\n// The bug itself will handle all the offsets.\n// For collision capsule, for bounding or hit detection, may want some offset.\n// TODO still needs a lot of work; WIP\nfloat dbug(vec3 q)\n{\n    float animation = Animation();\n    animation = fract(animation); // progress of walk cycle, fraction 0..1\n    // the legs all animate with a phase versus the main walk cycle\n    float d = length(q - vec3(0,.1,.4))-.15; // head sphere temp\n    d = min(d, dseg(q, vec3(0,.1,.3), vec3(0,.1,-.5)) - .1);\n    for (int i = 0; i < 8; ++i) {\n        if (i == 2 || i == 6) continue;\n        float x = float(i)/8.;\n        vec3 ql = q;\n        float sd = float((i&1) * 2 - 1);\n        vec2 r = sin(vec2(0, .5*pi) + tau * x\n               + .1*sin(tau*animation)\n            \t* sd);\n        ql.xz = mat2(r.y,-r.x, r) * ql.xz;\n        ql.x -= .1;\n        d = min(d, dleg(ql));\n    }\n    return d;\n}\n\t//q.x += sin(tau * animation);\n//float(((i ^ int((i-1)%6>=3))&1) * 2 - 1); //1.; //float(((i ^ (i/3))&1) * 2 - 1); //1.; // direction sign\n        //if (i == 4 || i == 0) sd = -sd;\n        //if (i == 0) sd = 0.;\n        \n// main model selector\nfloat shape(vec3 q)\n{\n    return dbug(q);\n}\n\n// show main model at origin, over a plane\nfloat sceneDistance(vec3 q)\n{\n    return min(shape(q - objectpos), q.y);\n}\n\n// hey, it's a way to do antialiasing on normal and such\n// here in Common tab without reliance on some external factor\n// such as camera distance.  But this is really a computation...\n// an exchange of info between threads, derivatives vs. fragCoord.  \n// So not free.\nfloat AntialiasPosition(vec3 q)\n{ // idk how best to say it without being repetitive at all; all these seem sub-optimal somehow but will all probably be about the same speed\n    return fwidth(q.x) + fwidth(q.y) + fwidth(q.z); //dot(vec3(1),fwidth(q)); //length(fwidth(q)); //\n} // length introduces an unnecessary sqrt that is probably not even wanted\n// at this point two functions use it; hopefully compiler will combine\n// the multiple calls with same argument when optimizing. FIXME\n\nconst float normal_precision = 0.002;\n// TODO may merge with sceneMaterial so it can adjust the normal per-material\n// TODO btw on blog page iq mentions using IZERO and a loop over an array to\n// prevent compiler inlining 4 loose calls, saving much compilation time.\n// iq's excellent tetrahedral (simplex) gradient, looped!\n// see https://iquilezles.org/articles/normalsSDF\n// I really did a number on the bitshifting though!\n// I rearranged it and reformatted, converted to loop.\n// FIXME epsilon got hardcoded in the process :( to match my other kludge\n// requires access to a uniform integer zero for proper looping\nvec3 sceneNormal(vec3 q, float blur, int uniformzero)\n{\n    float h = normal_precision\n        * sqrt(1./3.) // .5773\n        * (1. + 128.*blur) // antialiasing, band limit TODO tuning!! maybe need iResolution?\n        ;\n    vec3 n = vec3(0);\n    int i = 0;\n    i = uniformzero; //i = IZERO; //\n    for (; i < 4; ++i) {\n        vec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n        n += sceneDistance(q + e * h) * e;\n    }\n    return normalize(n);\n}\n\n//struct Material {}; // if material gets any more complicated, should just return the entire material; currently just albedo\n\nvec3 sceneMaterial(vec3 q, float blur)\n{\n    // simple grey plastic is fine for the object\n    vec3 albedo = diffuseColor;\n    // plane sinegrid\n\tif (q.y <= 1e-2)\n        albedo = vec3(.4,.5,.3)\n        \t+ .1 * sin(q.x) * sin(q.z + timeDisplacement())\n        \t\t* exp2(-1.2 * blur)\n        \t;\n   \treturn albedo;\n}\n\nvoid sceneSurface(int uniformzero\n      , vec3 phit, inout float t\n      , out vec3 albedo, out vec3 n, out float datmo)\n{\n    float blur = AntialiasPosition(phit);\n    bool is_hit = (t >= 0.);\n    float dsky = hatmo / depthscale;\n    datmo = t;\n    bool sky = !is_hit || t > dsky;\n    albedo = vec3(1);\n    if (sky) {\n        datmo = hatmo; //dsky; //\n        albedo = vec3(0);\n        n *= -0.; //*rd;\n        t = dsky; // decorrect for exaggeration\n        // TODO sky dome\n    } else { // hit sdf, so render it over bg, lit\n\t\tn = sceneNormal(phit, blur, uniformzero);\n      \talbedo = sceneMaterial(phit, blur); // HACK material is only albedo atm\n    \t// t sent for future reflection/shadow ray generation\n    \tdatmo *= depthscale;\n    }\n    //if (!isHit(t)) t = datmo; // HACK maybe sceneDraw should handle sky misses?\n}\n\n\nvec3 sceneAtmosphere(vec3 c, vec3 ro, vec3 rd, float t, float lv, float datmo)\n{\n    datmo = min(datmo, hatmo);\n//    datmo = max(0., datmo);\n    c *= exp2(-7e-5*vec3(1.,2.,3.)*datmo); // extinction\n    float afog = mix(pow(max(lv * .5 + .5, 0.), 2.), 1., .875);\n    vec3 cfog = 1. - exp2(-1e-4*csky*datmo);\n    vec3 ad = abs(rd);\n    c += afog\n        * cfog; // inscatter - crappy phase function tho FIXME kind of vaguely rayleigh-like\n    c += (1.-exp2(-4e-2*vec3(.22,.15,.08)*datmo)) * pow(max(lv, 0.), 8.) * .36; // fake mie\n    return c;\n}\n\nvec4 spaceBackground(vec3 d, float lv)\n{\n    return vec4(0,0,0,1);\n}\n\n//enviro(vec3 d, float focus)\n\n\n\n// for an explanation, see Pyramid Field https://shadertoy.com/view/3ld3Dl\n// TODO may make this toy the definitive one with the documentation.\n\nstruct Ray3 \n{\n    vec3 o, d; // origin and direction vectors\n};\n\nRay3 queryRay;\n\nvec3 queryAt(float t) \n{\n    return queryRay.o + queryRay.d * t;\n}\n\n// the parametric function of the ray;\n// given global queryRay and given index along it,\n// compute position along ray p and return sdf(p)\nfloat sdfQueryRay(float t)\n{\n    return sceneDistance(queryAt(t));\n}\n\n// a single iteration of a linear bracketed root finder algorithm aka regula falsi;\n// Linearly interpolate the position of a root between two known values on either side\n// returns mix factor to use between original two points\n// v0 = sdf(x0) and v1 = sdf(x1), then xRoot ~= mix(x0, x1, FalsePositionEstimate(v0, v1))\n// x0 and x1 *must* bracket the root, so v0 and v1 must have opposite signs or be zero.\n// takes two samples from field and returns interpolation factor between them where zero is likely to be found\nfloat FalsePositionEstimate(float v0, float v1)\n{\n\tfloat l = v0 - v1; \n\treturn abs(l) < 1e-24 ? .5 : v0 / l;\n}\n\nvec2 sdfqrFalsePositionStep(inout float x0, inout float x1, inout float v0, inout float v1)\n{\n    float u = FalsePositionEstimate(v0, v1);\n    float x = mix(x0, x1, u); // new guess\n    float d = sdfQueryRay(x); // NOTE function is hardcoded.  maybe I can make a small enough part of this into a macro.\n\tif (d < 0. == v0 < 0.)\n        v0 = d, x0 = x;\n\telse\n        v1 = d, x1 = x;\n    return vec2(x, d);\n}\n// result.x should then be between input x0 and x1, and closer than either.\n// result.y is the function's value at the new point result.x\n// on exit, either x0 or x1 will now contain the return value.x, and the extent should have shrunk.\n// post-result bracketing situation *should* be an improvement.\n// at some point you can stop calling it, and just use the midpoint of the remaining bracket.\n\n// now all that remains is to call it, perhaps repeatedly, until satisfied\n\n// usually even a few iterations does wonders.\nfloat sdfqrFalsePosition(inout float p0, inout float p1, inout float v0, inout float v1, int niter, float tol)\n{\n\tfloat x;\n    for (int i = niter; i-- > 0; ) {\n        vec2 r = sdfqrFalsePositionStep(p0, p1, v0, v1);\n        x = r.x;\n        if (abs(r.y) < tol) break;\n    }\n    return x;\n}\n\n// t is ray index into queryRay\n// d should be sdfQueryAt(t)\n// ot is t at prior step\n// od is d at prior step aka sdfQueryAt(ot)\n// r is a scale factor relating progress along t to the d value; usually somewhere around .9 works well for sdfs.\n// a is a minimum step size and determines the fine structure scale where details won't be skipped.\n// yes I realize these names are horrible, but I'm just getting this working.\nvoid sdfQueryRayStep(inout float t, inout float d, inout float ot, inout float od, float i, float r, float a)\n{\n    float t0 = t, d0 = d; //, ot0 = ot, od0 = od; // copy input values for later\n    float p = .5f * d / od;\n    float s = 1e-4 + d * r; /* * (.5\n\t\t+ .25f * p // \n\t\t+ .25f * i // overestimate more as we run out of iterations (i almost 1)\n\t\t);*/\n     t += max(s, a); // TODO a better function of the available data\n    d = sdfQueryRay(t);\n    ot = t0, od = d0;\n}\n\nfloat sdfqrRayMarch(vec3 ro, vec3 rd, float rate, int iter)\n{\n    queryRay.o = ro, queryRay.d = rd;\n    float rit = 1. / float(iter);\n    float ret = -1.; // \"missed\". see isMiss.\n    float t = .0, t1 = -1e-9, d = sdfQueryRay(t);\n    float d1 = d + 1e-9; // d1 is just a wild guess at the value of sdfQueryRay(t1); shouldn't matter a whole lot but does influence the size of the first step, probably.\n    do {\n        if (d <= .0) {\n        \tt = sdfqrFalsePosition(t, t1, d, d1, 4, 5e-4);\n            ret = t;\n            break;\n        }\n        sdfQueryRayStep(t, d, t1, d1, float(iter)*rit, rate, 9e-4); //1e-3); //5e-4); //\n    } while (iter-- > 0);\n    return ret;\n}\n\n\n// TODO need tmax arg, limit max trace distance; really, lo, hi range would be nice\nfloat raymarch(vec3 ro, vec3 rd, int nsteps)\n{\n    float t = sdfqrRayMarch(ro, rd, .975, nsteps);\n\treturn t;\n}\n\nfloat rayshadow(vec3 ro, vec3 rd, int nsteps)\n{\n    //return 1.; // HACK disable\n    if (rd.y <= 0. || ro.y <= 0.) return 1.;\n    float t = sdfqrRayMarch(ro, rd, 1.25, nsteps);\n\treturn t >= 0. ? 0. : 1.; // hard shadows atten\n}\n\n// p is fragment world pos, v is view dir (toward eye), n is surf normal, t is distance from p to camera plane\n// lv is dot(-L,v), albedo is diffuse/ambient color, datmo is (fake scaled) frag depth\n// returns premultiplied alpha color c of lit fragment\nvec3 sceneLight(vec3 p, vec3 v, vec3 n, float t, float lv, vec3 albedo, float datmo) //vec3 ro, vec3 rd, float t,\n{\n    float satten = 1.;\n    int nshadowsteps = IZERO + 32; //28; //24; //18; //\n    if (dot(n, lightDir) > 0.) {\n    \tp += 1e-4 * (n + lightDir * max(lv,0.)); // self-shadow bias HACK\n    \tsatten = rayshadow(p, lightDir, nshadowsteps);\n    }\n\treturn LightingBlinnPhong(n, v, albedo, t, satten).rgb;\n}\n\n// raymarch to find termination depth when ray hits solid object\nfloat sceneDepth(vec3 ro, vec3 rd)\n{\n    int nsteps = 128; //160; //192; //256; //32; // \n    nsteps += IZERO; // HACK prevent unwise compiler loop unrolling; can't do in Common because uniforms aren't directly accessible there\n    float d = raymarch(ro, rd, nsteps);\n    if (!(d >= 0.)) { \n        d = ro.y / -rd.y;\n        if (!(d >= 0.)) \n            d = -1.; //hatmo / depthscale; // TODO 'dome'\n    }\n    return d;\n}\n\nvec3 RenderScene(vec3 ro, vec3 rd, float time, out float d)\n{\n    float lv = dot(lightDir, rd); // factor of all fog and eye glare lighting\n    vec4 bg = spaceBackground(rd, lv);\n    vec3 c = bg.rgb;\n    d = sceneDepth(ro, rd);\n    float datmo;\n    vec3 albedo, normal;\n    vec3 hitp = ro + rd * d;\n    sceneSurface(IZERO, hitp, d, albedo, normal, datmo); //ro, rd\n    c = sceneLight(hitp, -rd, normal, d, lv, albedo, datmo);\n    c = sceneAtmosphere(c, ro, rd, d, lv, datmo);\n    return c;\n}\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\nvec3 camRayDir(vec2 p, vec2 r)\n{\n    vec2 q = StoQ(p, r);\n    const float hfovy = pi/6.;\n    return viewRayDir(q, hfovy);\n}\n\n// idk about this \"run the ray marcher and lighting in a loop\" style of\n// SSAA antialiasing but it's better than nothing.\nvec3 Render(vec2 p, vec2 r, int ss, vec3 camera_pos, vec3 camera_dir)\n{\n    mat3 iview = cameraMatrix(camera_dir);\n    float iss = 1. / float(ss);\n    vec3 o = vec3(0);\n    for (int i = ss; i-- > 0; ) {\n        float f = float(i) * iss;\n        vec2 fc = p; // fragcoord subpixel\n        // golden angle phi factor\n        const float phi = (sqrt(5.)+1.)/2.;\n        fc += .7 * sqrt(f) * cossin(pi*phi*2.*(f+.1*iTime)); // vogel disc jitter\n        // could add some extra angular defocus using iResolution\n\t    vec3 ro, rd, vd;\n    \tvd = camRayDir(fc, r);\n\t    ro = camera_pos, rd = normalize(iview * vd);\n\t    float d;\n\t    o.rgb += RenderScene(ro, rd, iTime, d);\n    }\n    o.rgb *= iss;\n    return o;\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec3 camera_pos = cameraPosition (BufferC)\n       , camera_dir = cameraDirection(BufferC);\n    vec3 c = Render(p, iResolution.xy, supersamples, camera_pos, camera_dir);\n    c = pow(c, vec3(1./2.2)); // to srgb gamma\n    c += vec3(.75/256. * rand(p)); // dither quantization bands\n    o = vec4(c, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.141592\n, tau = 2.*pi;\n// mandelbulb is too complex to handle with AA btw\nconst int supersamples = 1; //4; //6; //2; //8; // for SSAA antialiasing\nconst vec3 lightDir = normalize(vec3(0,.5,.866));\nconst float ambient = .3;\n// these aren't energy conserving and aren't PBR at all actually, just some HACK for now\nconst float specularity = 32.;\nconst vec3 specularColor = vec3(.3);\nconst vec3 diffuseColor = vec3(.7);\nconst float hatmo = 85000.; // air extinct distance\nconst float depthscale = 120.; //1200.; //12.; // fog exaggeration for horizon look mostly, affects sun also though\nconst vec3 csky = vec3(.2,.4,.6);\nconst vec3 objectpos = vec3(0,.2,0); //0,1.1,0); //0,2,0); //\n\n#define IZERO min(0, iFrame)\n\n// buffer mapping logic, could wrap to subsequent rows\nint slotid(ivec2 loc) { return loc.x; }\nivec2 slotloc(int id) { return ivec2(id, 0); }\n\nvec4 loadValue(sampler2D buf, int slot_id)\n{\n    return texelFetch(buf, slotloc(slot_id), 0);\n}\n\n\n// channel allocations can't be done in Common,\n// as the defines for the iChannel# samplers have not yet been set.\n// but we can allocate the slots within BufferC at least.\n\nconst int slotCameraPosition = 0;\nconst int slotCameraForward  = 1;\nconst int slotDesiredForward = 2;\nconst int slotMouseOld       = 3; // iMouse from prior frame\nconst int slotCount          = 4;\n\nvec2 cossin(float r)\n{\n    return sin(vec2(r + .5*pi, r));\n}\n\n// cheap rotation transform on p by s=(cos(a),sin(a))\nvoid rot(inout vec2 p, vec2 s) \n{\n\tp = p * s.x + vec2(p.y, -p.x) * s.y;\n} // then can rot(q.xz, cossin(a))\n// as matrix\n//mat2 mrot(vec2 s)\n//{\n//    return mat2(s.x, s.y, -s.y, s.x);\n//} // then can q.xz = mrot(cossin(a)) * q.xz;\n// idk yet which I will wind up using\n\n// build a 3x3 camera orientation matrix given forward direction vector, assuming up is +Y\nmat3 cameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n} // inverse view matrix\n// then just transform by pw = iview * pv;\n\n// implements inverse proj matrix transform (postclip to view dir)\n// with hfovy in radians\nvec3 viewRayDir(vec2 q, float hfovy)\n{\n\treturn normalize(vec3(q, 1./sin(hfovy)));\n//    return normalize(vec3(q, 2.)); // hard-coded to hfovy=60 degrees\n}\n/*\n// implements inverse view*proj matrix transform (postclip to world dir)\n// with hfovy in radians\nvec3 cameraRayDir(vec2 q\n                  //, mat3 view, vec3 cam_fwd\n                  , float hfovy)\n{\n//    mat3 M = cameraMatrix(cam_fwd);\n\treturn normalize(M * viewRayDir(q, hfovy));\n}\n\nvec3 lightRayDir(vec2 q, vec3 lgt_fwd)\n{\n    mat3 M = cameraMatrix(lgt_fwd);\n// FIXME perspective projection for light is wrong\n    return normalize(M * vec3(q, 20.));\n} // needs large near clip plane\n*/\n// refactored to Common; complicated by BufferC isn't available directly!\nvec3 cameraPosition(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraPosition).xyz;\n}\n\nvec3 cameraDirection(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraForward).xyz;\n}\n\n\n// see https://shadertoy.com/view/tdKSWW\nfloat rand(float x)\n{\n    // sine provides good decorrelation and as a bonus includes its own range reduction\n    // see https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n    x = sin(x*7.);\n    x *= 43708.8672;\n    x = fract(x);\n    return x;\n}\n\nfloat rand(vec2 x) { return rand(dot(x, vec2(11.07,10.71))); }\n\n\n\n\n\n\n// basic plasticky BRDF - temporary\nvec4 LightingBlinnPhong(vec3 n, vec3 v, vec3 albedo, float d, float satten)\n{\n    float amb = clamp(0.5 + 0.5 * n.y, 0., 1.); // less coming from down; makes hemispherical ambient\n    float lv = clamp(dot(lightDir, n) * satten, 0., 1.); // n dot l\n    vec3 h = normalize(v + lightDir);\n\n\tfloat dl = mix(lv, amb, ambient); //amb * ambient + dif * (1. - ambient); // how much diffuse+ambient lighting\n\tvec3 c = dl * albedo;\n    \n    float spec = pow(clamp(dot(h, n), 0., 1.), specularity);\n    spec *= lv * specularity * .038; // should mul by n*l and power, divide by 8*pi\n//    float reflectivity = 0.5;\n    // TODO reflections - should do another scene trace\n    //   vec3 ref = reflect(-rd, n);\n    //    vec3 crefl = texture(iChannel0, ref).rgb;\n\tc += spec * specularColor;\n    return vec4(c, 1);\n}\n\n\n\n\n\n// rest the lighting is in Image tab currently and needs cleaned up before moving to Common\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Debug Camera from https://shadertoy.com/view/WlVGDh\n\n// BufferC controls the state, mostly the camera location+direction\n// but wound up needing old mouse state and, for smoothing,\n// the desired facing direction.\n\n#define BufferC   iChannel2\n#define Keyboard  iChannel3\n\nconst float moverate = 1.5;\nconst float turnratemouse = .012;\nconst float turnratekbd = 2.6;\n\n\nvec3 desiredDirection() \n{\n    return loadValue(BufferC, slotDesiredForward).xyz;\n}\n\nvec4 oldMouse() \n{\n    return loadValue(BufferC, slotMouseOld);\n}\n\nbool asleep(vec2 mouse) // in shadertoy.com shader browser thumbnail? \n{\n    return dot(mouse, mouse) <= 2.;\n}\n\n// read keyboard key, return 1.0 if down\n// ultimately want to do differencing of negatives from positives\nfloat key(int vk) // key down state value as a float fraction\n{\n    float s = loadValue(Keyboard, vk).x; // read keyboard key state from texture\n    return step(.5, s); // test if down\n}\n\nconst int\n  KEY_SPACE = 32\n, KEY_CTRL  = 17 // DO NOT use control generally as when held, bad things can happen to our window or tab\n, KEY_SHIFT = 16\n, KEY_C     = 67\n// https://en.wikipedia.org/wiki/Arrow_keys#WASD_keys\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n// in DVORAK it's ,AOE, in AZERTY it's ZQSD\n, KEY_Z     = 90 // but Image tab is using it for showing depth FIXME\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_COMMA = 188 //188 JS, 44 ASCII\n, KEY_X     = 88 // used by Image tab; should keys move to Common tab?\n#if 0 // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0 // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE\n, KEY_DW    = KEY_C  // anything but control!\n, KEY_LEFT  = 37 // arrow keys for lookaround\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n;\n\nvec3 cameraMovement(bool shift)\n{\n    vec3 campos = cameraPosition(BufferC);\n    float\n      fw = key(KEY_FW)\n    , bw = key(KEY_BW)\n    , lf = key(KEY_LF)\n    , rt = key(KEY_RT)\n    , up = key(KEY_UW)\n    , dn = key(KEY_DW);\n    vec3 camfwd = cameraDirection(BufferC);\n    //if (asleep(iMouse.xy)) fw = .5; // automate forward\n    if (asleep(iMouse.xy)) campos = -4. * camfwd + objectpos; // orbit // * objectscale\n    mat3 camori = cameraMatrix(camfwd);\n    vec3 cammove = vec3(rt-lf, up-dn, fw-bw) * iTimeDelta * moverate;\n    if (shift) cammove *= 4.0; // shift key for speed boost\n    campos += camori * cammove;\n    //const float camradius = .04;\n    //vec3 normal = sceneNormal(campos, 1e-7, IZERO);\n    //float cdist = sceneDistance(campos);\n    //campos += normal * -min(cdist - camradius, .0); // collision with sdf\n    campos.y = max(campos.y, 0.1); // don't go below ground plane\n    return campos;\n}\n\nvec3 cameraSteering(bool shift)\n{\n    vec3 desiredRot = desiredDirection();\n    vec4 oMouse = oldMouse();\n    bool lmb = iMouse.z >= 0.;\n    bool olmb = oMouse.z >= 0.;\n    float shiftmod = shift ? .5 : 1.; // shift actually slows rotation down\n    vec2 orbit = vec2(0);\n    if (asleep(iMouse.xy)) {\n    \torbit = vec2(.15*iTimeDelta, 0);   // slow spin\n\t} else {\n    \tif (lmb && olmb) {\n\t        vec2 m = iMouse.xy - oMouse.xy;\n    \t    orbit += m * turnratemouse * shiftmod;\n    \t} \n    \t{\n    \t\tfloat aL = key(KEY_LEFT), aR = key(KEY_RIGHT), aU = key(KEY_UP), aD = key(KEY_DOWN);\n\t        vec2 m = vec2(aR - aL, aU - aD);\n    \t    orbit += m * iTimeDelta * turnratekbd * shiftmod;\n        }\n    }\n    if (dot(orbit,orbit) != 0.) {\n        // TODO cossin is too nifty not to use\n        rot(desiredRot.xz, vec2(cos(orbit.x),sin(orbit.x)));\n        vec2 vr = vec2(1.,desiredRot.y);\n        rot(vr, vec2(cos(orbit.y),-sin(orbit.y)));\n        desiredRot.xz *= max(1e-1f, vr.x); // do not flip signs here!\n        desiredRot.y = vr.y;\n  \t\tdesiredRot = normalize(desiredRot);\n    }\n    return desiredRot;\n}\n\n// smoothing filter\nvec3 cameraSmoothing()\n{\n    vec3 camfwd = cameraDirection(BufferC);\n    vec3 desiredFwd = desiredDirection();\n    camfwd = normalize(mix(desiredFwd, camfwd, exp2(-64.*iTimeDelta)));\n    return camfwd;\n}\n\n// a debugging fly camera using keyboard WASD + mouse + C/space\n// stores camera position,aim,etc. into c as a \n// color coded vector suitable for output to buffer\nvoid debugFlyCamera(out vec4 c, vec2 p)\n{    \n    if (p.y >= 1. || p.x >= float(slotCount)) discard; //return; // ignore most pixels - otherwise using an entire buffer is really bad\n    ivec2 ip = ivec2(p);\n    c = loadValue(BufferC, ip.x); // passthru by default\n    bool shift = key(KEY_SHIFT) > .5;\n    bool init = iFrame < 3; //iFrame == 0; // thumbnail issues\n    switch (slotid(ip)) {\n      case slotCameraPosition: {\n \t    c.xyz = init ? vec3(.9,.5,-2.) : cameraMovement(shift);            \n        break;\n      }\n      case slotCameraForward: {\n        c.xyz = init ? normalize(vec3(-.4,0.,.9)) : cameraSmoothing();\n        break;\n      }\n      case slotDesiredForward: {\n        c.xyz = init ? normalize(vec3(-.4,0.,.9)) : cameraSteering(shift);\n        break;\n      }\n      case slotMouseOld: {\n        c = iMouse;\n        break;\n      }\n      default:\n        break;\n    }\n}\n\n// output to Buffer C\nvoid mainImage(out vec4 c, vec2 p)\n{    \n    debugFlyCamera(c, p);\n}\n\n\n\n","name":"Buffer C","description":"","type":"buffer"}]}