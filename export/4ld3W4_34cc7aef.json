{"ver":"0.1","info":{"id":"4ld3W4","date":"1470228448","viewed":245,"name":"Minimal Raymarch","username":"Kastor","description":"This is a minimal version of iqs premitives","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 twist( vec3 p )\n{\n    float x = sin(cos(iTime * 0.5) * 0.2 + cos(iTime * 1.5) * 0.2);\n    float val = x * 3.2 *p.y+ cos(iTime + x) * 2.0;\n    float  c = cos(val);\n    float  s = sin(val);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nvec2 map( in vec3 pos )\n{\n\tvec2 res = \n         vec2( 0.5*box( twist(pos),vec3(0.5, 0.5, 10.7)), 46.7);\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n     \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.1, 0.1, 0.1);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        // material        \n\t\tcol = vec3(0.3, 1.0, 0.3);\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        //vec3 normal = calcNormal(pos);\n        float intensity = 0.0;\n        float ambient = 0.2;\n        float diffuse = clamp( dot( nor, -rd ), 0.0, 1.0 );\n        float spec = pow(clamp( dot( ref, -rd ), 0.0, 1.0 ),8.1);\n        intensity += ambient;\n        intensity += 0.7 * spec;\n        intensity += 0.7 * diffuse;\n        col *= intensity;\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n    }\n  \treturn vec3( clamp(col,0.0,1.0) );  \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 zaxis = normalize(ta-ro);\n\tvec3 up = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 xaxis = normalize( cross(zaxis, up) );\n\tvec3 yaxis = normalize( cross(xaxis, zaxis) );\n    return mat3( xaxis, yaxis, zaxis );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    vec2 mo = vec2(0,0);\n\t//mo = vec2(0.0, 0.2);\n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 origin = vec3( -4.5, 0.0, 6.0 );\n\tvec3 lookat = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( origin, lookat, 0.0 );\n    \n    // ray direction\n\tvec3 dir = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( origin, dir );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}