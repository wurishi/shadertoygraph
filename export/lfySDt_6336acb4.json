{"ver":"0.1","info":{"id":"lfySDt","date":"1715902229","viewed":56,"name":"bae #011 ~ Intersect & Inspect","username":"BretHudson","description":"Rings","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat PI = 3.14159;\nfloat EPSILON = 0.0001;\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n// below two thanks to https://stackoverflow.com/questions/52958171/glsl-optimization-check-if-variable-is-within-range\nfloat inRange(float a, float v, float b)\n{\n    return step(a, v) - step(b, v);\n}\n\nfloat compare(float v, float target)\n{\n    return inRange(target - EPSILON, v, target + EPSILON);\n}\n\n// below four functions thanks to https://www.ronja-tutorials.com/post/035-2d-sdf-combination/\nfloat intersect(float shape1, float shape2)\n{\n    return max(shape1, shape2);\n}\nvec3 intersect(vec3 shape1, vec3 shape2)\n{\n    return max(shape1, shape2);\n}\n\nfloat merge(float shape1, float shape2)\n{\n    return min(shape1, shape2);\n}\n\nvec3 merge(vec3 shape1, vec3 shape2)\n{\n    return min(shape1, shape2);\n}\n\nfloat subtract(float base, float subtraction)\n{\n    return intersect(base, -subtraction);\n}\nvec3 subtract(vec3 base, vec3 subtraction)\n{\n    return intersect(base, -subtraction);\n}\n\nfloat edge(float d, float d2)\n{\n    d2 += 0.06;\n    float thickness = 0.01;\n    float maxThick = 0.015;\n    return pow((maxThick - (maxThick - thickness) * sign(d2)) / abs(d), 1.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    float initialRot = 2.3;\n    \n    vec2 _uv = uv;\n    _uv *= rot(-(initialRot + iTime) + PI / 3.);\n    \n    float a = inRange(PI / 3., atan(_uv.y, _uv.x), PI);\n    float b = inRange(-PI, atan(_uv.y, _uv.x), -PI / 3.);\n    float c = inRange(-PI / 3., atan(_uv.y, _uv.x), PI / 3.);\n    \n    vec3 outerCircles = vec3(0);\n    \n    float innerD = sdCircle(uv, 0.5);\n    \n    vec3 col = vec3(0);\n    \n    float numCircles = 3.;\n    vec2 offset = vec2(1., 0.);\n    offset *= rot(initialRot + iTime);\n    offset *= (cos(1.9 + iTime) + 1.) / 5. + 0.4;\n    \n    float outerD = 1.;\n    \n    for (float i = 0.; i < numCircles; ++i)\n    {\n        offset *= rot(PI * 2. / numCircles);\n        float d = sdCircle(uv + offset, 0.3);\n        outerD = merge(d, outerD);\n    }\n    \n    float outer = subtract(outerD, innerD);\n    float overlap = intersect(outerD, innerD);\n    float inner = subtract(innerD, outerD);\n    \n    col += edge(outer, innerD) * vec3(\n        c + b,\n        a + b,\n        a + c\n    );\n    col += edge(overlap, innerD) * vec3(\n        a, c, b\n    );\n    \n    col += edge(inner, innerD + 0.06) * vec3(1.);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}