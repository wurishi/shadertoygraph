{"ver":"0.1","info":{"id":"ttXfWs","date":"1598039634","viewed":103,"name":"[TWITCH] Mirrors","username":"Flopine","description":"Made during a Twitch live session. You can watch all of them here: https://www.twitch.tv/flopine","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","animation","iridescence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define ITER 120.\n#define time iTime\n#define PI acos(-1.)\n\nstruct obj\n{\n    float d;\n    int mat;\n    vec3 col;\n};\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(a+u+abs(mod(u-a+st,2.*st)-st)));\n}\n\nobj minobj (obj a, obj b)\n{\n    if(a.d<b.d) return a;\n    else return b;\n}\n\nobj stminobj (obj a, obj b, float k ,float st)\n{\n    float dist = stmin(a.d,b.d,k,st);\n    if (a.d <= b.d) return obj(dist,a.mat,a.col);\n    else return obj(dist,b.mat,b.col);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-d;}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p, p.yzx);\n    return min(min(p.x,min(p.y,p.z))-d,od(p,0.5));\n}\n\nobj cage (vec3 p)\n{\n    p.xz *= rot(-PI/2.);\n    mo(p.yz, vec2(0.8));\n    p.xz *= rot(PI/4.);\n    mo(p.xy, vec2(1.));\n    p.xz *= rot(PI/2.);\n    float cd = box(p,vec3(0.5,0.7,0.05))-0.01;\n    return obj(cd, 1, vec3(0.6,0.1,0.5));\n}\n\nobj subcage (vec3 p)\n{\n    p.z += 0.5;\n    mo(p.xy, vec2(1.));\n    p.x -= 0.8;\n    p.yz *= rot(-PI/4.);\n    mo(p.xz, vec2(0.5));\n    p.xz *= rot(PI/4.);\n    float scd = box(p,vec3(0.8,0.2,0.1))-0.01;\n    return obj(scd, 2, vec3(0.1,0.8,0.));\n}\n\nobj structure (vec3 p)\n{\n    p.x = abs(p.x)-1.;\n    return stminobj(cage(p),subcage(p),0.15,5.);\n}\n\nobj gem (vec3 p)\n{\n    float octa = od(p,0.4);\n    mo(p.xz, vec2(3.));\n    p.xz *= rot(time*0.3);\n    mo(p.xy, vec2(1.5));\n    float gd = sc(p, 0.1)-0.05;\n    return obj(gd, 3, vec3(0.05));\n}\n\n\nobj SDF (vec3 p)\n{\n    obj scene = minobj(structure(p), gem(p));\n    return scene;\n}\n\n\nvec3 norm (vec3 p)\n{\n    vec2 eps = vec2(0.0005,0.);\n    return normalize(SDF(p).d - vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nvec3 palette (float t, vec3 c, vec3 d)\n{return vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+d));}\n\nvec3 iri(vec3 c, vec3 n, vec3 rd, vec3 pal)\n{\n    float fresnel = max(1.-dot(n,rd),0.);\n    c += palette(fresnel,vec3(2.),pal);\n    return c;\n}\n\nvec3 raymarch(inout vec3 p, vec3 rd, vec3 l)\n{\n    vec3 col = vec3(0.85,0.79,0.85);\n    vec3 newrd = rd;\n    bool hit = false;\n    int refi = 0;\n    obj O;\n    for (float i=0.; i<ITER; i++)\n    {\n        O = SDF(p);\n        if (O.d < 0.001)\n        {\n            hit = true;\n            if (O.mat == 3)\n            {\n                if (refi >= 1) break;\n                vec3 n = norm(p);\n                newrd = reflect(newrd,n);\n                p += 0.1*newrd;\n                col = O.col;\n                col += pow(max(dot(n,normalize(l-rd)),0.), 18.)*0.25;\n                refi ++;\n            }\n            else break;\n        }\n        p += O.d*newrd;\n    } \n\n    if (hit)\n    { \n        vec3 n = norm(p);\n        if (O.mat == 1) col = iri(O.col, n, rd, vec3(0.3,0.,0.8));\n        if (O.mat == 2) col = iri(O.col, n, rd, vec3(0.5,0.,0.2));\n    }\n    return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.,0.,-4.35),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        l = normalize(vec3(1.,2.,-1.));\n\n    vec3 color = raymarch(p,rd,l); \n\n    // vignetting (from iq)\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcolor *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.15);\n    \n    color *= 1./max(texture(iChannel0,uv*8.).r*1.9,0.01);\n    \n    fragColor = vec4(pow(color,vec3(0.4545)),1.);\n}","name":"Image","description":"","type":"image"}]}