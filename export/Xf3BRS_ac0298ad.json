{"ver":"0.1","info":{"id":"Xf3BRS","date":"1733262975","viewed":134,"name":"Oscillating String","username":"prasound","description":"A non-linear string oscillator. In the limit it approximates the KdV wave equation.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["oscillator"],"hasliked":0,"parentid":"4f3fDN","parentname":"Fermi–Pasta–Ulam problem"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 o, in vec2 p) {\n    o.rgb = texture(iChannel1, p/iResolution.xy).rgb;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\nconst float SQ3 = sqrt(3.);\nconst float INF = 1e10;\n\n// Simulation consts\nconst int N = 256;\nconst float DT = 0.5;\nconst float ALPHA = -1.3;\nconst float MASS = 0.5;\n\n// Rendering consts\nconst vec3 RGB_1 = vec3(0.22, 0.05, 1.50);\nconst vec3 RGB_2 = vec3(1.50, 0.05, 0.22);\nconst float GLOW = 1.5;\nconst float R0 = 0.02;\nconst float R1 = 0.5;\nconst float DMAX = 3.0;\nconst float DECAY = 1.2;\n\nvec4 texFetch(sampler2D ch0, int i) {\n    i = int(mod(float(i), float(N)));\n    return texelFetch(ch0, ivec2(i,0), 0);\n}\n\nvec2 c2mul(vec2 a, vec2 b) {\n    return mat2(a.x, a.y, -a.y, a.x) * b;\n}\n\nvec2 c2exp(float x) {\n    return vec2(cos(x), sin(x));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// CC0: Oscillating String\n//  Feel free to use in your experiments.\n//\n// Simulates the motion of masses in iChannel0.\n//  .xy = current\n//  .zw = previous\n\nvoid mainImage(out vec4 o, in vec2 p) {\n    ivec2 pp = ivec2(p - 0.5);\n\n    if (pp.x > N-1 || pp.y > 0)\n        return;\n     \n    // initial state\n    if (iFrame == 0) {\n        float x = 2.*PI*float(pp.x)/float(N);\n        o.xy = vec2(0.5*sin(x*2.),0.2*sin(x*3.));\n        o.zw = o.xy;\n        return;\n    }\n    \n    vec4 cc = texFetch(iChannel0, pp.x);\n    vec2 rr = texFetch(iChannel0, pp.x + 1).xy;\n    vec2 ll = texFetch(iChannel0, pp.x - 1).xy;\n    \n    vec2 T = rr + ll - 2.*cc.xy; // Hooke's law\n    T += ALPHA*T*(rr - ll); // the non-linear term\n    \n    o.xy = 2.*cc.xy - cc.zw;\n    o.xy += T.xy/MASS * (DT*DT);\n    o.zw = cc.xy; // prev <- curr\n    o = clamp(o,vec4(-DMAX),vec4(DMAX));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// CC0: Oscillating String\n//  Feel free to use in your experiments.\n//\n// Renders the mesh defined by iChannel0 coords.\n\nfloat lineSDF(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 pos2(sampler2D ch0, int i) {\n    vec2 c = c2exp(float(i)/float(N)*2.*PI + PI/2.);\n    vec4 w = texFetch(ch0, i);\n    return c*R1 + c2mul(c, w.xy);\n}\n\nfloat sdf(sampler2D ch0, vec2 q) {\n    float d = INF;\n    vec2 v1 = pos2(ch0, -1);\n    \n    for (int i = 0; i < N; i++) {\n        vec2 v2 = pos2(ch0, i);\n        d = min(d, lineSDF(q, v1, v2));\n        v1 = v2;\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 o, in vec2 p) {\n    vec2 q = p/iResolution.xy*2. - 1.;\n    q *= iResolution.xy/iResolution.yy;\n    \n    float d = sdf(iChannel0, q);\n    o.rgb = mix(RGB_1, RGB_2, pow(sin(iTime*3.), 2.));\n    o.rgb *= exp(-pow(7.5*d/R0, 2.0));\n    o.rgb = pow(o.rgb, vec3(0.4545));\n    o.a = 1.0;\n    \n    o.rgb += exp(-iTimeDelta*DECAY)*texture(iChannel1, p/iResolution.xy).rgb;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}