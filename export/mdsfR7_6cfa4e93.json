{"ver":"0.1","info":{"id":"mdsfR7","date":"1688597918","viewed":164,"name":"Perspective camera in 2D","username":"Envy24","description":"See Image tab.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","ray","line","sphere","intersection","camera","projection","perspective","one","point","central"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Use mouse to drag viewport.\n\n    3d version: https://www.shadertoy.com/view/NtsXz4#\n    This shader helps to understand how zFocalLength (from Blender perspective camera) affects zoom.\n    \n    Resulting image resolution is w=1., h = num_of_rays, where ray color represent pixel color.\n    Also notice that placing viewport after scene is not an error. You still get an image.\n    Placing viewport left of camera still get intersection, because \n*/\n\n#define SCENE_SCALE               ( 3. )\n#define ORIGIN                    ( vec2(2,0) )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat cellsSDF(vec2 NDC)\n{\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_line(NDC, 0.), horizontal_line(NDC, 0.)) +\n        max(vertical_line(NDC, 0.), horizontal_line(NDC, 0.));\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n    \n    vec3 color = vec3(1.);\n         color -= x_axis(NDC)*0.5; color -= y_axis(NDC)*0.5;\n         color -= cellsSDF(NDC)*0.2;\n         \n    /* Scene */\n    vec2 sphere = vec2(4, 0);\n    float radius = 1.0;\n    vec3 sphere_col = vec3(0,1,1);\n    color = mix(color, sphere_col, SMAA(diskSDF_L2(NDC, sphere, radius)));\n    /* */\n         \n    /* Perspective camera. */\n    vec2 look_at = sphere;\n    vec2 camera = vec2(-1.0, 0.0);\n    float zFocalLength = iMouse.xy == vec2(0) ? 2. : MP.x-camera.x;  \n\n    vec2 f = normalize(look_at - camera);\n    vec2 u = vec2(-f.y, f.x);\n      \n    float vpHeight = 2.; // abs(2.*MP.y);\n    /* */\n       \n    vec2 viewport_up =     camera + f * zFocalLength + u * vpHeight * 0.5,\n         viewport_bottom = camera + f * zFocalLength - u * vpHeight * 0.5;\n    \n    color = mix(color, vec3(0,0,1), 0.2*SMAA(arrowSDF_L2(NDC, camera, (camera+u), 0.001))); // up direction\n    color = mix(color, vec3(0,0,1), 0.2*SMAA(arrowSDF_L2(NDC, camera, (camera+f), 0.001))); // forward direction \n    color = mix(color, vec3(1,0,0), SMAA(segmentSDF_L2(NDC, viewport_bottom, viewport_up, 0.0))); // viewport\n    \n    const float num_of_rays = 10.; \n    float h = vpHeight / float(num_of_rays);\n    for (float i = 0.; i < num_of_rays; i += 1.)\n    {\n        vec2 ray = camera;\n        vec2 dir = normalize(f * zFocalLength + vec2(0, -vpHeight * 0.5 + h*0.5 + h*i));\n\n        float d = ray_sphere_intersection(ray, dir, sphere, radius);     \n        vec3 ray_color = d == -1. ? vec3(0, 0, 0) : sphere_col;        \n        color = mix(color, ray_color, 0.5*SMAA(segmentSDF_L2(NDC, ray, ray + 999. * dir, 0.0)));\n        \n        vec2 hit_point_on_image = camera + zFocalLength * dir / dir.x;\n        color = mix(color, ray_color, 0.5*SMAA(diskSDF_L2(NDC, hit_point_on_image, 0.04)));\n        \n        if (d != -1.)\n        {\n            vec2 hit_point = ray + dir * d;\n            color = mix(color, vec3(1,0,0), SMAA(diskSDF_L2(NDC, hit_point, 0.04)));\n        }\n    }\n    \n    color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, camera, 0.04))); // camera\n    \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n// Points exactly at point E.\nfloat arrowSDF_L2(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.275, //      U--\n         U = C + up  * 0.10,  // B----C----E\n         D = C - up  * 0.10;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.275 ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n\n// just change vec2 to vec3 for 3d\nfloat ray_sphere_intersection(\n    vec2 ray,\n    vec2 ray_dir,\n    vec2 sphere,\n    float r)\n{\n    sphere -= ray; // move sphere in ray coordinate system\n    \n    // Project sphere center on ray.\n    float dist = dot(sphere, ray_dir) /  dot(ray_dir, ray_dir);\n    vec2 sphere_to_ray_proj = dist * ray_dir;\n    float len = length(sphere_to_ray_proj - sphere);\n\n    // Check length between sphere center and projected point.\n    return \n        len > r || dist < 0. ? // ray-sphere intersection\n        //len > r ? // ray-line intersection\n            -1. : // no hit\n            dist-sqrt(r*r - len*len); // distance to hit point\n}","name":"Common","description":"","type":"common"}]}