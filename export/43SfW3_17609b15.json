{"ver":"0.1","info":{"id":"43SfW3","date":"1729968779","viewed":38,"name":"Julia set simple 3D","username":"kukovisuals","description":"Simple Julia set on 3D ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","julia3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D Julia Set Rendering KukoVisuals\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int MAX_MARCHING_STEPS = 100;\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 100.0;\nconst int MAX_ITERATIONS = 10;\nconst float BAILOUT = 4.0;\n\n// Distance estimator for the 3D Julia Set\nfloat DE_Julia(vec3 pos) {\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    vec3 c = vec3(-0.77, 0.112, 0.0); // Constant defining the Julia set shape\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        r = length(z);\n        if (r > BAILOUT) break;\n\n        // Convert to polar coordinates\n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        float r_power = pow(r, 8.0);\n\n        // Calculate new position\n        float sinTheta = sin(8.0 * theta);\n        float cosTheta = cos(8.0 * theta);\n        float sinPhi = sin(8.0 * phi);\n        float cosPhi = cos(8.0 * phi);\n        z = r_power * vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta) + c;\n\n        // Compute derivative\n        dr = pow(r, 7.0) * 8.0 * dr + 1.0;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n// Calculate normal for lighting\nvec3 getNormal(vec3 p) {\n    float eps = 0.0001;\n    vec2 e = vec2(1.0, -1.0) * eps;\n\n    float nx = DE_Julia(p + vec3(e.x, e.y, e.y)) - DE_Julia(p - vec3(e.x, e.y, e.y));\n    float ny = DE_Julia(p + vec3(e.y, e.x, e.y)) - DE_Julia(p - vec3(e.y, e.x, e.y));\n    float nz = DE_Julia(p + vec3(e.y, e.y, e.x)) - DE_Julia(p - vec3(e.y, e.y, e.x));\n\n    return normalize(vec3(nx, ny, nz));\n}\n\n// Main ray marching function\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 p) {\n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        p = ro + rd * totalDist;\n        float dist = DE_Julia(p);\n        if (dist < MIN_DIST || totalDist > MAX_DIST) break;\n        totalDist += dist;\n    }\n    return totalDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, -5.0); // Camera position\n    vec3 rd = normalize(vec3(uv, 9.0)); // Ray direction\n\n    // Rotate the scene\n    float angle = iTime * 0.1;\n    mat3 rotY = mat3(\n        cos(angle), 0.0, sin(angle),\n        0.0,        1.0,        0.0,\n        -sin(angle),0.0, cos(angle)\n    );\n    ro = rotY * ro;\n    rd = rotY * rd;\n\n    // Ray marching\n    vec3 p;\n    float totalDist = rayMarch(ro, rd, p);\n\n    // Shading\n    vec3 color = vec3(0.0);\n    if (totalDist < MAX_DIST) {\n        vec3 normal = getNormal(p);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n        float diff = max(dot(normal, lightDir), 0.0);\n\n        // Simple coloring based on normal\n        color = diff * vec3(0.2, 0.7, 0.9);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}