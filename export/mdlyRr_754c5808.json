{"ver":"0.1","info":{"id":"mdlyRr","date":"1686542549","viewed":90,"name":"Huygens Error","username":"Quazi","description":"Check the error in Huygens-Frensel Principle vs Kirchoff's Theorem.\nSee Principles of optics book \"Elements of the theory of diffraction\" section.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv_buff = fragCoord/iResolution.xy;\n    vec4 buffA = texture(iChannel0, uv_buff);\n    vec2 wave = buffA.xy/float(iFrame);\n    vec2 true_wave = buffA.zw/float(iFrame);\n    vec2 error = wave-true_wave;\n    vec2 out_wave = wave;\n    if(iFrame % 60 < 30){\n        out_wave = true_wave;\n    }\n    //fragColor = vec4(acos(clamp(dot(wave/length(wave), true_wave/length(true_wave)),-1.0,1.0))/PI, 0.0, length(error) ,1.0);\n    fragColor =vec4(abs(error)/length(true_wave) ,1.0*length(error)/length(true_wave),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KIRCHOFF\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n    vec2 uv = fragCoord;\n    //image plane is uvw\n    vec3 uvw = vec3(fragCoord+1.0*rand2seed(fragCoord, 0), 0.);\n    \n    float t = float(iFrame)*0.0;\n    \n    float U_0 = 100.0;  \n    vec3 src_pos = vec3(iResolution.xy*0.5, 0.0);\n    float wvlen = 0.05*iResolution.y;\n    float c = 1.0;\n    float f = c/wvlen;\n    float k = 2.0*PI/wvlen;\n    \n    float r_0 = length(iMouse.xy-src_pos.xy);\n    //float test_r = 3.0/f; // one wavelength\n    \n\n    vec2 true_wave = wavelet(uvw, src_pos, k, U_0);\n    \n    int N = 1000;\n    vec2 wave = vec2(0.,0.);\n    //float arc = 2.0*PI;\n    for (int i = 0; i < N; i++) {\n        //float a = arc*(float(i)+rand())/float(N);\n        //vec3 sample_dir = vec3(cos(a), sin(a), 0.);\n        // see principles of optics book \"Elements of the theory of diffraction\" section.\n        vec3 Q = src_pos + randSph() * r_0;\n        vec3 sample_dir = normalize(Q-src_pos);\n        vec2 U_r = wavelet(Q, src_pos, k, U_0);\n        vec3 QP = uvw-Q;\n\n        vec2 s_wavelet = wavelet(uvw, Q, k, 1.0);\n        #ifdef HUYGENS_FRESNEL\n            float KX = (1.+dot(sample_dir, QP/length(QP)))*0.5; //principles of optics pg.380 eq.20\n            //float KX = max(0., dot(sample_dir, QP/length(QP))); //Fresnel was wrong.\n            wave += complex_mult(vec2(0.,-1./wvlen), complex_mult(U_r, s_wavelet*KX));\n        #else //KIRCHOFF\n            vec3 srcQ = Q-src_pos;\n            float s = length(QP);\n            float r = length(srcQ);\n            vec2 z = vec2(-1./s, k)*dot(sample_dir, -QP/s);\n                 z-= vec2(-1./r, k)*dot(sample_dir, srcQ/r);\n            wave += (1./(4.*PI))*complex_mult(complex_mult(U_r, s_wavelet), z);\n        #endif\n    }\n    wave *= 4.0*PI*r_0*r_0/float(N);\n    vec2 uv_buff = fragCoord/iResolution.xy;\n    vec4 buffA = texture(iChannel0, uv_buff);\n    fragColor = buffA+vec4(wave, true_wave);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358979323846264338327950288;\nconst float S =50.0; //scale factor (what does 1 unit equal (e.g. 100 pixels = 1 unit -> S=100.0))\n\n//////////////////////////////////////////////////////////////////\n//https://www.shadertoy.com/view/wltcRS\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec2 rand2seed(vec2 p, int seed)\n{\n    uvec4 s = uvec4(p, uint(seed), uint(p.x) + uint(p.y));\n    pcg4d(s); return vec2(s.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec3 randSph()\n{\n    vec2 uv = rand2();\n    float theta = uv.x * 2.0 * PI;\n    float phi = acos(clamp(2.0*uv.y-1.0,-1.0,1.0));\n    return vec3(sin(phi)*cos(theta), sin(phi)*sin(theta), cos(phi));\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n////////////////////////////////////////////\n\nvec2 wavelet( vec3 uvw, vec3 src_pos, float k, float U_0)\n{\n    //https://en.wikipedia.org/wiki/Huygens%E2%80%93Fresnel_principle\n    float r = length(uvw-src_pos);\n    //U_0*exp(ikr) \n    return (U_0/r)*vec2(cos(k*r), sin(k*r));\n}\n\nvec2 complex_mult(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}","name":"Common","description":"","type":"common"}]}