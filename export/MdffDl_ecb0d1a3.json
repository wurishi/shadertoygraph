{"ver":"0.1","info":{"id":"MdffDl","date":"1499084008","viewed":189,"name":"FNV-1a vs LCG","username":"theGiallo","description":"Experimenting with shift operators to generate noise.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["noise","terrain","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n # Experimenting with 2D noise using bitwise operations\n FNV1-a[1] seems to work very well, compared with my use of a LCG[2], that calls the\n LCG a lot of times to get a good seed distribution.\n\n What I call 'octave noise' is ~Perlin noise.\n\n ## Controls\n Drag with LMB and zoom in/out with arrows UP/DOWN. '0' to reset zoom.\n\n [1]: http://www.isthe.com/chongo/tech/comp/fnv/#FNV-1a\n [2]: https://en.wikipedia.org/wiki/Linear_congruential_generator\n*/\n////////////////////////////////////////////////////////////////////////////////\n// NOTE(theGiallo): configurable parameters of octave noise\n    #define SIDE_M 0.5\n    #define OCT_STARTING_SCALE 0.15\n    #define OCT_COUNT 8.0\n// NOTE(theGiallo): end of conf\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n// NOTE(theGiallo): shared code\n\nconst vec2 MOUSE_OLD = vec2(0.0,0.0);\nconst vec2 POS_SCALE = vec2(1.0,0.0);\n\nvec4\nload_value( in vec2 uv_code )\n{\n    return texture( iChannel0, (uv_code+0.5)/iChannelResolution[0].xy, -100.0 );\n}\n// NOTE(theGiallo): end shared code\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n// NOTE(theGiallo): constants\n\n#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n////////////////////////////////////////////////////////////////////////////////\n// NOTE(theGiallo): base utilities\n\nfloat\nminv( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmaxv( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nminv( in vec2 v )\n{\n    return min( v.x, v.y );\n}\n\nfloat\nmaxv( in vec2 v )\n{\n    return max( v.x, v.y );\n}\n\nfloat smootherstep( float edge0, float edge1, float x )\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);\n    return x*x*x*(x*(x*6. - 15.) + 10.);\n}\nvec2 smootherstep( vec2 edge0, vec2 edge1, vec2 x )\n{\n    vec2 ret;\n    ret.x = smootherstep( edge0.x, edge1.x, x.x );\n    ret.y = smootherstep( edge0.y, edge1.y, x.y );\n    return ret;\n}\nvec2 smootherstep( float edge0, float edge1, vec2 x )\n{\n    vec2 ret;\n    ret.x = smootherstep( edge0, edge1, x.x );\n    ret.y = smootherstep( edge0, edge1, x.y );\n    return ret;\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat mirror( float v, float T )\n{\n    return mirror( v * 2.0 / T ) * T * 0.5;\n}\nfloat trw01( float v, float T )\n{\n    return mirror( v * 2.0 / T );\n}\nfloat trsin( float v, float T )\n{\n    return trw01(v,T) - 0.5;\n}\nfloat saw01( float v, float T2 )\n{\n    return mod( v * 2.0, T2 ) / T2;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// NOTE(theGiallo): noise generation\n\n#define uint_to_01(u) (float((u)>>1) / float(0x7FFFFFFF));\n/* The state word must be initialized to non-zero */\nuint xorshift32( uint state )\n{\n\tuint x = state;\n\tx ^= x << 13;\n\tx ^= x >> 17;\n\tx ^= x << 5;\n\tstate = x;\n\treturn x;\n}\nfloat xorshift3201( uint state )\n{\n    uint u = xorshift32( state );\n    return uint_to_01( u );\n}\n\nuint fnv1a( uint seed )\n{\n    uint offset_basis = 2166136261u;\n    uint FNV_prime = 16777619u;\n    uint hash = offset_basis;\n\tfor ( int i = 0; i != 4; ++i )\n    {\n        uint octet_of_data = ( seed >> ( i * 8 ) ) & 0xffu;\n        hash = hash ^ octet_of_data;\n        hash = hash * FNV_prime;\n    }\n\treturn hash;\n}\nfloat fnv1a_01( uint seed )\n{\n    uint u = fnv1a( seed );\n    #if 0\n    return float(u) / 32768.;\n    #else\n    return uint_to_01( u );\n    #endif\n}\n\nuint lcg( uint seed )\n{\n    seed = seed * 1103515245u + 12345u;\n\treturn uint(seed/65536u) % 32768u;\n}\nfloat lcg01( uint seed )\n{\n    uint u = lcg( seed );\n    return float(u) / 32768.;\n}\nfloat noise_a( uint seed )\n{\n    float ret;\n   \tseed = xorshift32(seed);\n   \tseed = xorshift32(seed);\n   \tseed = xorshift32(seed);\n   \tseed = xorshift32(seed);\n   \tseed = xorshift32(seed);\n    \n   \tseed = xorshift32(seed);\n   \tseed = xorshift32(seed);\n   \tseed = xorshift32(seed);\n   \tseed = xorshift32(seed);\n   \tseed = xorshift32(seed);\n    \n   \tret = xorshift3201(seed);\n    return ret;\n}\nfloat noise_b( uint seed )\n{\n    float ret;\n   \tseed = lcg(seed);\n   \tseed = lcg(seed);\n   \tseed = lcg(seed);\n   \tseed = lcg(seed);\n   \tseed = lcg(seed);\n   \tseed = lcg(seed);\n   \tret = lcg01(seed);\n    return ret;\n}\nfloat noise_fnv( uint seed )\n{\n    float ret;\n   \tret = fnv1a_01(seed);\n    return ret;\n}\n#define FLT_MAX 1e7\n#define FLT_MAXa 1e4\nvoid deneg( inout vec2 coord )\n{\n    coord.x += coord.x < 0. ? ceil(-coord.x / FLT_MAX) * FLT_MAX : 0.0;\n    coord.y += coord.y < 0. ? ceil(-coord.y / FLT_MAX) * FLT_MAX : 0.0;\n}\nvoid denega( inout vec2 coord )\n{\n    coord.x += coord.x < 0. ? ceil(-coord.x / FLT_MAXa) * FLT_MAXa : 0.0;\n    coord.y += coord.y < 0. ? ceil(-coord.y / FLT_MAXa) * FLT_MAXa : 0.0;\n}\n#define seed2( coord ) ( lcg( uint(coord.x) ) ^ uint(coord.y) )\nfloat noise_a( in vec2 coord, in vec2 resolution )\n{\n    float ret;\n    denega( coord );\n    #if 1\n    float M = 131.;\n    uint seed = 1u + uint(coord.y * resolution.x * M + coord.x * M);\n    #else\n    uint seed = seed2( coord );\n    #endif\n    ret = noise_a( seed );\n    return ret;\n}\nfloat noise_b( in vec2 coord )\n{\n    float ret;\n    deneg( coord );\n    #if 0\n    float M = 131.;\n    uint seed = 1u + uint(coord.y * resolution.x * M + coord.x * M);\n    #endif\n    uint seed = seed2( coord );\n    ret = noise_b( seed );\n    return ret;\n}\nfloat noise_fnv( in vec2 coord, in vec2 resolution )\n{\n    float ret;\n    deneg( coord );\n    #if 0\n    float M = 131.;\n    uint seed = 1u + uint(coord.y * resolution.x * M + coord.x * M);\n    #else\n    uint seed = seed2( coord );\n    #endif\n    ret = noise_fnv( seed );\n    return ret;\n}\n\nfloat octave_noise( vec2 coord, int octaves, float side, bool l )\n{\n    float v = 0.0;\n    float OCT_SCALE_M  = 1.0 - OCT_STARTING_SCALE;\n    float oct_scale = OCT_STARTING_SCALE;\n    #define NOISE l ? noise_fnv( c, res ) : noise_b( c )\n    int oct_count = octaves;\n    for ( int oct = oct_count; oct != 0; --oct )\n    {\n        float inv_oct = 1.0 / float(oct);\n        float inv_side = 1.0 / side;\n        vec2 res = iResolution.xy;\n        vec2 fc = coord * inv_side;\n        vec2 c;\n        \n        c.x = floor(fc.x);\n        c.y = floor(fc.y);\n        c += vec2(float(oct));\n    \tfloat n0 = NOISE;\n        \n        c.x = ceil(fc.x);\n        c.y = floor(fc.y);\n        c += vec2(float(oct));\n    \tfloat n1 = NOISE;\n        \n        c.x = floor(fc.x);\n        c.y = ceil(fc.y);\n        c += vec2(float(oct));\n    \tfloat n2 = NOISE;\n        \n        c.x = ceil(fc.x);\n        c.y = ceil(fc.y);\n        c += vec2(float(oct));\n    \tfloat n3 = NOISE;\n        \n        vec2 a = smootherstep( 0.0, 1.0, fract( fc ) );\n        float ov =\n        mix( mix( n0, n1, a.x ),\n             mix( n2, n3, a.x ),\n             a.y ) * oct_scale;\n        \n        v += ov;\n        \n        oct_scale *= OCT_SCALE_M;\n        side *= SIDE_M;\n    }\n    float final_1 = ( OCT_STARTING_SCALE * (pow(float(OCT_SCALE_M),float(oct_count)) - 1.0 ) ) / ( OCT_SCALE_M - 1.0 );\n    v /= final_1;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / max( iResolution.y, iResolution.x );\n\n    bool l = fragCoord.x < iResolution.x * 0.5;\n    vec4 pos_scale = load_value( POS_SCALE );\n    vec2 pos = pos_scale.xy;\n    float scale = pos_scale.z;\n    if ( !l )\n    {\n        fragCoord.x -= iResolution.x * 0.5;\n    }\n    vec2 cfc = fragCoord.xy - vec2(0.25,0.5) * iResolution.xy;\n    pos += scale * ( cfc );\n    float side = minv( iResolution.xy ) * 0.5;\n    int octaves = 1 + int( floor( OCT_COUNT * saw01(iTime, OCT_COUNT * 2.) ) );\n    octaves = int(OCT_COUNT);\n    float v = octave_noise( pos, octaves, side, l );\n    //float v0 = octave_noise( pos, octaves > 1 ? octaves -  1 : 1, side, l );\n    //v = ( v - v0 ) * 0.5 + 0.5;\n    fragColor.xyz = vec3( v );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n// NOTE(theGiallo): shared code\n\nconst vec2 MOUSE_OLD  = vec2(0.0,0.0);\nconst vec2 POS_SCALE  = vec2(1.0,0.0);\n\nvec4\nload_value( in vec2 uv_code )\n{\n    return texture( iChannel0, (uv_code+0.5)/iChannelResolution[0].xy, -100.0 );\n}\n// NOTE(theGiallo): end shared code\n////////////////////////////////////////////////////////////////////////////////\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_0     = 48;\nfloat\nkey( in int K )\n{\n    return texelFetch( iChannel1, ivec2(K,0), 0 ).x;\n}\n\nfloat\nisInside( vec2 p, vec2 c )\n{\n    vec2 d = abs( p - 0.5 - c ) - 0.5;\n    return - max( d.x, d.y );\n}\nbool\nis_value( in vec2 frag_coord, in vec2 tx_code )\n{\n    return isInside( frag_coord, tx_code ) > 0.0;\n//    return (uv_code+0.5)/iChannelResolution[0].xy == uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( iFrame == 0 )\n    {\n        fragColor = vec4(0.0);\n    \tif ( is_value( fragCoord, POS_SCALE ) )\n        {\n            fragColor = vec4(0.0,0.0,1.0,0.0);\n        }\n        return;\n    }\n    \n    fragColor = vec4(0.0);\n    if ( is_value( fragCoord, MOUSE_OLD ) )\n    {\n        fragColor = iMouse;\n    } else\n    if ( is_value( fragCoord, POS_SCALE ) )\n    {\n        vec4 mouse_old = load_value( MOUSE_OLD );\n        vec4 pos_old = load_value( POS_SCALE );\n        if ( mouse_old.z == iMouse.z )\n        {\n            pos_old.xy -= pos_old.z * ( iMouse.xy - mouse_old.xy );\n        }\n        float kup = key( KEY_UP );\n        float kdown = key( KEY_DOWN );\n        if ( kup - kdown != 0.0 )\n        {\n            if ( kdown != 0.0 )\n            {\n            \tpos_old.z *= 1.1;\n            }\n            if ( kup != 0.0 )\n            {\n            \tpos_old.z *= 1.0 / 1.1;\n            }\n        }\n        float k0 = key( KEY_0 );\n        if ( k0 != 0.0 )\n        {\n            pos_old.z = 1.0;\n        }\n        fragColor = pos_old;\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}