{"ver":"0.1","info":{"id":"3sj3RW","date":"1548349453","viewed":168,"name":"Circle Segment Distance","username":"nr4","description":"Accurate circle segment distance","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["circle","distance","segment","arc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Circle Segment Distance\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Update 1: Changed isoline drawing code to code from fabrice's comment\n// Update 2: Fixed sign of distance function\n\nconst vec3 c = vec3(1.,0., -1.);\nconst float pi = acos(-1.);\n\n// Distance to circle segment\nfloat circlesegment(vec2 x, float r, float p0, float p1)\n{\n    float p = atan(x.y, x.x);\n    vec2 philo = vec2(max(p0, p1), min(p0, p1));\n    if((p < philo.x && p > philo.y) || (p+2.*pi < philo.x && p+2.*pi > philo.y) || (p-2.*pi < philo.x && p-2.*pi > philo.y))\n    \treturn abs(length(x)-r);\n    return min(\n        length(x-r*vec2(cos(p0), sin(p0))),\n        length(x-r*vec2(cos(p1), sin(p1)))\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    \n    float d = circlesegment(uv-.4*c.xy,.1, pi/8., 15.*pi/8.);\n    d = min(d, circlesegment(uv+.4*c.xy,.1, -pi/2., pi/2.));\n    d = abs(d)- .02;\n    float e = 1.5/iResolution.y;\n    \n    vec3 col = cos(iTime+uv.xyx+vec3(0,2,4)) * smoothstep(.1+e, 0., abs( fract(20.*d) - .2 ) ) + vec3(1,0,0) * smoothstep(e, -e,d);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}