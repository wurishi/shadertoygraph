{"ver":"0.1","info":{"id":"flGXzd","date":"1641210733","viewed":153,"name":"Shader-Studies: Radar","username":"LeyMB","description":"A simple radar-shader I made as part of my studies to improve my shader knowledge. Inspired by ndel's beautiful \"Oblivion Radar\" shader that can be found here: https://www.shadertoy.com/view/4s2SRt","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["radar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based on ndel's beautiful \"Oblivion Radar\" shader that can be found here: https://www.shadertoy.com/view/4s2SRt\n\n// Many thanks to Patricio Gonzalez Vivo & Jen Lowe for their tutorials on thebookofshaders.com\n// Their website is an invaluable resource when starting out with learning shaders and has helped me greatly\n\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n\n// DrawCircle functions taken from https://www.shadertoy.com/view/4s2SRt\nfloat DrawCircle(vec2 uv, vec2 centerPoint, float radius, float width)\n{\n    float r = length(uv - centerPoint);\n    \n    return SMOOTH(r - width/2.0, radius) - SMOOTH(r + width/2.0, radius);\n}\n\n// movingLine functions taken from https://www.shadertoy.com/view/4s2SRt\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90.0 * iTime;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n\n    float pi = 3.14159265358979;\n\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0 * pi / 180.0),\n                            -sin(theta0* pi / 180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(180.0*atan(d.y,d.x) / pi + theta0, 360.0);\n        float gradient = clamp(1.0 - theta/90.0,0.0,1.0);\n        return SMOOTH(l,1.0)+0.5 * gradient;\n    }\n    else return 0.0;\n}\n\nmat2 rotate(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale(vec2 scale)\n{\n    return mat2(scale.x, 0.0, 0.0, scale.y);\n}\n\n\nvec2 MakeGrid(vec2 FragCoord, vec2 RowColumn, vec2 Resolution)\n{\n   vec2 st = FragCoord.xy/iResolution.xy;\n\n   st *= RowColumn;\n   st = fract(st);\n\n   return st;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n    vec2 currentPos = fragCoord.xy;\n    vec2 centerPos = iResolution.xy / 2.0;\n\n    // draw small scanlines\n    for (int i = 0; i < 100; i++)\n    {\n        color += sin(iTime) * DrawCircle(currentPos, centerPos, float(i) * 40.0, 0.15);\n    }\n\n    // draw big scanlines\n\n    vec3 scanlineColor;\n    scanlineColor += DrawCircle(currentPos, centerPos, 2.0, 0.5) \n                + DrawCircle(currentPos, centerPos, 10.0, 0.5)\n                + DrawCircle(currentPos, centerPos, 20.0, 0.5)\n                + DrawCircle(currentPos, centerPos, 40.0, 0.5)\n                + DrawCircle(currentPos, centerPos, 80.0, 0.5)\n                + DrawCircle(currentPos, centerPos, 160.0, 0.5)\n                + DrawCircle(currentPos, centerPos, 240.0, 0.5)\n                + DrawCircle(currentPos, centerPos, 320.0, 0.5);\n\n    // color scanlines\n    scanlineColor *= vec3(0.0, 1.0, 1.0);\n\n    color += scanlineColor;\n\n    color += movingLine(currentPos, centerPos, 320.0) * vec3(0.0, 0.0, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}