{"ver":"0.1","info":{"id":"mscyRS","date":"1695168998","viewed":50,"name":"Bright Bouncing Ball Thing","username":"Hamneggs","description":"Just a stateful screensaver with some questionable color math. I've really gotten rusty out here.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["screensaver","state"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define STARTING_NUM_CIRCLES 200\n#define CIRCLE_SIZEOF 2\n#define MMAP iChannel0\n\nconst vec2 TX_LEN_CIRCLES = vec2(2,2);  // For when it's time to add more.\nconst vec2 TX_CIRCLE_SIZEOF = vec2(2,3);\nconst vec2 TX_CIRCLES = vec2(3,2);\n\n/* \n    Reads a texel from a sampler2D at a given position.\n */\nvec4 readTexel( in sampler2D buff, in vec2 p )\n{\n    return texelFetch(buff, ivec2(p), 0);\n}\n\n/* \n    Do the whole gabbernazzle all at once.\n*/\nvoid write4( inout vec4 buff, in vec4 v, in vec2 p, in vec2 fc )\n{\n    vec2 off = abs(p-floor(fc));\n    buff = mix( v, buff, step(.01,max(off.x,off.y)) );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n/*\n\tReturns a psuedo-random value given a 2D vector.\n*/\nvec2 noise(vec2 co) {\n    return vec2(fract(sin(dot(co,vec2(12.9898,298.234))) * 43758.5453),\n                fract(cos(dot(co,vec2(14.2348,156.986))) * 56123.8641));\n}\n\n/*\n    Quick reference function from https://github.com/hughsk/glsl-hsv2rgb.\n*/\nvec3 hsv2rgb(vec3 c) { // https://github.com/hughsk/glsl-hsv2rgb\n  vec4 K = vec4(1.0, .66667, .33333, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/*\n    Creates a random hue and gives us back the corresponding RGB value.\n*/\nvec4 randomRGB(vec2 co) {\n    float f = fract(cos(dot(co,vec2(12.9898,298.234))) * 43758.5453);\n    vec3 rgb = hsv2rgb(vec3(f,1,1));\n    return vec4(rgb,1);\n}\n    \n/*\n    Initializes program state. (creates initial positions and velocities.)\n*/\nvoid initialize( inout vec4 buff, in vec2 fc ) {\n    // First let's write our starting array length and struct size.\n    write4(buff, vec4(STARTING_NUM_CIRCLES,0,0,0), TX_LEN_CIRCLES, fc);\n    write4(buff, vec4(CIRCLE_SIZEOF,0,0,0), TX_CIRCLE_SIZEOF, fc);\n    \n    // Now let's go initialize the array.\n    for ( int i = 0; i < STARTING_NUM_CIRCLES; ++i ) {\n        vec2 addr0 = TX_CIRCLES + vec2(i,0);\n        vec2 addr1 = TX_CIRCLES + vec2(i,1);\n        vec2 p = noise(addr0.xy);\n        vec2 v = noise(addr1.yx)*.005;\n        vec4 c = randomRGB(addr1);\n        write4(buff, vec4(p,v), addr0, fc);\n        write4(buff, c, addr1, fc);\n    }\n}\n\n/*\n    Updates a ball.\n*/\nvoid updateBall( inout vec2 p, inout vec2 v )\n{\n    // Take into account frame time.\n    vec2 pnext = p + (v * (iTimeDelta/.0166667));\n    \n    // This math brings us down to only two conditional checks hehe.\n    pnext *= 2.0;\n    pnext -= 1.0;\n    pnext = abs(pnext);\n    if ( pnext.x > 1.0 ) v.x *= -1.0;\n    if ( pnext.y > 1.0 ) v.y *= -1.0;\n    p += v * (iTimeDelta/.0166667);\n}\n\n/*\n    Per-frame state update.\n*/\nvoid update( inout vec4 buff, in vec2 fc ) {\n\n    // Go through all the circles and update them.\n    for ( int i = 0; i < STARTING_NUM_CIRCLES; ++i ) {\n        vec2 addr0 = TX_CIRCLES + vec2(i,0);\n        vec4 pv = readTexel( MMAP, addr0 );\n        vec2 p = pv.xy; vec2 v = pv.zw;\n        updateBall(p,v);\n        write4(buff, vec4(p,v), addr0, fc);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n    // sanitize.\n    if ( iFrame < 1 ) { \n        fragColor = vec4(0,0,0,1);\n        return; \n    }\n    // initialize.\n    if ( iFrame < 2 ) { \n        initialize(fragColor, fragCoord); \n        return; \n    }\n    \n    // run.\n    if ( fragCoord.y > 5.0 ) discard; // Quick optimization.\n    update(fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Draws a largely anti-aliased circle.\n*/\nvoid drawCircle( inout vec4 buff, in vec2 p, in vec2 uv, in vec4 c, in float r) {\n    float dr = length(p-uv);\n    float px = 1.0/iResolution.y;\n    dr = smoothstep(dr-px,dr+px, r); // \"if radius is greater than distance...\"\n    c = mix(vec4(0,0,0,1), c, dr);\n    buff = clamp(c+buff,vec4(0), vec4(1)); // Additive color!\n}\n\n/*\n    Draws all the circles for a given frame.\n*/\nvoid compositeCircles( inout vec4 buff, in vec2 uv, in vec2 fc ){\n\n    for ( int i = 0; i < STARTING_NUM_CIRCLES; ++i ) {\n        vec2 addr0 = TX_CIRCLES + vec2(i,0);\n        vec2 addr1 = TX_CIRCLES + vec2(i,1);\n        vec2 p = readTexel( MMAP, addr0 ).xy;\n        p.x *= iResolution.x/iResolution.y;\n        vec4 c = readTexel( MMAP, addr1 );\n        drawCircle(buff, p, uv, c, .05);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( iFrame < 2 ) { fragColor = vec4(0,0,0,0); return; }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Last frame contents.\n    vec4 pFrame = texture(iChannel1, uv);\n    \n    // Current frame contents.\n    vec4 cFrame = vec4(0,0,0,1);\n    \n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    vec4 bg = vec4(0,0,0,1);\n    \n    int x = 10;\n    \n    compositeCircles(cFrame, uv, fragCoord);\n    \n    fragColor = cFrame+pFrame*.4;//mix(cFrame, pFrame, .9);\n}","name":"Buffer B","description":"","type":"buffer"}]}