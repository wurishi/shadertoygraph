{"ver":"0.1","info":{"id":"WlVGDh","date":"1578836374","viewed":173,"name":"Debug Camera","username":"spalmer","description":"a simple debug camera controller lets you fly around with WASD+C+space+arrows+mouse lmb.\nX debug cam pos, Z debug depth.\nNow supports a few different key layout bindings.\nFeel free to use it!","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["mouse","camera","keyboard","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see Common tab for more info.\n// debug fly camera controlled by keyboard+mouse; see Buffer C.\n\n#define Font      iChannel1\n// stock font texture in iChannel1, linear filtered, using sdf in alpha\n#define BufferC   iChannel2\n#define Keyboard  iChannel3\n\n// read keyboard key state from texture, return true if down\nbool keydown(int vk)\n{\n    return .5 <= loadValue(Keyboard, vk).x;\n}\n// FIXME maybe wrap texelFetch?\nbool option(int vk)\n{\n    return .5 <= texelFetch(Keyboard, ivec2(vk,2), 0).x;\n}\n\n\n#if 1\n// numeric display based on https://shadertoy.com/view/llySRh\n// using font in iChannel1; otherwise I'd put it in Common\nfloat char(vec2 p, int c)\n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.)\n        return 0.;\n    vec2 q = p/16. + fract(vec2(c, 15-c/16) / 16.);\n    vec4 t = textureLod(Font, q, 0.);\n    // probably not perfect but seems ok\n    float scale = 64./(1.+dot(fwidth(q), vec2(1))); //(abs(dFdx(q.x))+abs(dFdy(q.y))); //length(fwidth(p)); //\n    scale = clamp(scale, 1./1024., 1024.);\n    float g = t.a; // a unorm-encoded signed distance\n    g = .5 - (g - .5) * scale; // antialiasing\n    g = clamp(g, 0., 1.);\n    return g;\n}\n    //float w = scale/16.;// /iResolution.y; //.05; //\n    //g = clamp(.5 - 1./w * (t.w-.5), 0., 1.); //\n    //g = smoothstep(.5+w,.5-w, t.w); // aa sdf - could probably do pixel perfect with a bit more effort\n    //g = clamp(.5 - (t.w - .5) * 8./scale; // yeah but we need scale info, maybe do the scaling here?\n\n// display unsigned int up to 4 digits base 10\nfloat pUint(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n); i > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    if (abs(n) < 1e-7)\n        v += char(p, 48);\n    return v;\n}\n\n// display unsigned int 4 digits base 10\nfloat pUint4(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n), d = 4; d-- > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    return v;\n}\n\nfloat pSign(vec2 p, inout float n)\n{\n    float v = 0.;\n    if (n < 0.) v += char(p + vec2(.5,0), 45), n = -n;\n    return v;\n}\n\n// display signed int4\nfloat pInt(vec2 p, float n)\n{\n    float v = 0.;\n    v += pSign(p, n); // p.x -= 2.;\n    v += pUint(p, n);\n    return v;\n}\n\n// display signed float4.4\nfloat pFloat(vec2 p, float n)\n{\n    float v = 0.;\n    v += pSign(p, n); p.x -= 2.;\n    v += pUint(p, floor(n)); p.x -= .5;\n    v += char(p, 46); p.x -= 2.;\n    v += pUint4(p, fract(n)*1e4);\n    return v;\n}\n// had to do some work to get it to display aligned properly and do signs correctly.\n// still not happy with missing zero digits in fraction.\n#endif\n\nfloat tracePlaneY(vec3 ro, vec3 rd)\n{\n    return ro.y <= 0. ? 0. : rd.y >= -5e-3 ? -1. : ro.y / -rd.y;\n}\n\n// FIXME need better example grid - see https://shadertoy.com/view/wl3Sz2\nfloat sillyGrid(vec2 p)\n{ // why would you make a grid this way?\n\tfloat g = sin(p.x) * sin(p.y); // grid texture\n    g *= g; g = 1. - g; g = pow(g, 8.);\n    g = mix(g, .2, min(1., .5*length(fwidth(p)))); // aa\n    return g;\n}\n\n/// macro is to future-proof check of bounding volume etc.\n#define ConsiderObject(dtemp, dmin, imin, dobj, iobj) \\\n\tdtemp = (dobj); \\\n\tif (0. <= dtemp && dtemp < dmin) \\\n\t    dmin = dtemp, imin = iobj;\n///\n\nvec3 RenderScene(vec3 ro, vec3 rd, float time, out float d)\n{\n    vec3 c = vec3(0.);\n    uint i = 0u; // sky is id 0\n    d = 1e4;\n    float dtemp; // prep trace scene\n    ConsiderObject(dtemp, d, i, tracePlaneY(ro, rd), 1u);\n    vec3 csky = rd*.5+.5; //const vec3(.5, .7, .9); //\n    switch (i) {\n        case 0u: { // sky\n            c.rgb = csky;\n            d = 1e4;\n        \tbreak;\n        }\n        case 1u: { // plane\n            vec2 hp = ro.xz + d * rd.xz; // hit pos\n    \t\tfloat stripe = sillyGrid(hp);\n            if (d == 0.) stripe = sin(time*12.); // beneath? flash\n            c.rgb = vec3(stripe * .5, 0., stripe * .5); //1., stripe, 0.);\n        \tbreak;\n        }\n    }\n    float dfade = exp2(-.02*d);\n    c.rgb = mix(csky, c.rgb, dfade);\n\treturn c;\n}\n\nvoid ViewRay(vec2 p, out vec3 ro, out vec3 rd, out vec3 vd)\n{\n    vec2 R = iResolution.xy\n    , q = StoQ(p, R);\n    vec3 camera_pos = cameraPosition(BufferC)\n    , camera_dir = cameraDirection(BufferC);\n    mat3 M = cameraMatrix(camera_dir, vec3(0,1,0));\n    const float hfovy = pi/6.;\n    vd = normalize(vec3(q, 1./sin(hfovy)));\n    ro = camera_pos, rd = normalize(M * vd);\n}\n\nvoid DebugStuff(inout vec3 c, vec2 p, vec3 ro, vec3 rd, vec3 vd, float d)\n{\n    // KEY_Z\n    if (keydown(90)) { // Z debugs depths\n        float z = d; // * vd.z; // radial or flat?  \n    \tfloat dfade = exp2(-.02*d);\n        float zaa = .5 * dfade * dfade / (1.+16.*fwidth(z)); // yes this is very complicated due to antialiasing\n        c.rgb = vec3(dfade) * mix(1., pow(sin(z), 4.), zaa);\n    }\t\n    // KEY_X\n    if (!option(88)) { // debug camera position at lower left of window\n        vec2 q = StoQ(p, iResolution.xy);\n    \tvec2 U = q * .5 + .5; // to unsigned aspect correct uv I guess, klunky\n        float text = 0.;\n        const float scl = 32.; //48.; //24.; //12.; //6.; //64.; //\n    \ttext += pFloat((U - vec2(-.2,.15)) * scl, ro.x);\n    \ttext += pFloat((U - vec2(-.2,.1 )) * scl, ro.y);\n   \t\ttext += pFloat((U - vec2(-.2,.05)) * scl, ro.z);\n        vec3 tc = vec3(1.,1.,.5);\n        c.rgb = mix(c.rgb, tc, clamp(text, 0., 1.));\n    }   \n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec3 ro, rd, vd;\n    ViewRay(p, ro, rd, vd);\n    float d;\n    c.rgb = RenderScene(ro, rd, iTime, d);\n    DebugStuff(c.rgb, p, ro, rd, vd, d);\n    c.rgb = pow(c.rgb, vec3(1./2.2));\n    c.a = 1.;\n}\n\n//    c.rgb += vec3(.9/256. * rand(p)); // dither\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// So many toys have poor camera control.  Use this!\n// Fabrice's example font code was used: https://shadertoy.com/view/llySRh \n// also some from https://shadertoy.com/view/ls3fDr\n// I guess it's not 100% original due to that.\n\n// Common #include shared definitions\n\n// buffer mapping logic, could wrap to subsequent rows\nint slotid(ivec2 loc) { return loc.x; }\nivec2 slotloc(int id) { return ivec2(id, 0); }\n\nvec4 loadValue(sampler2D buf, int slot_id)\n{\n    return texelFetch(buf, slotloc(slot_id), 0);\n}\n\n// channel allocations can't be done in Common,\n// as the defines for the iChannel# samplers have not yet been set.\n// but we can allocate the slots within BufferC at least.\n\nconst int\n  slotCameraPosition = 0\n, slotCameraForward  = 1\n, slotDesiredForward = 2\n, slotMouseOld       = 3 // iMouse from prior frame\n, slotCount          = 4\n;\n\nconst float pi = acos(-1.); //3.141592;\n\n// e^(i*rads) Euler's formula complex spinor\nvec2 cossin(float r)\n{\n    return sin(r + vec2(.5*pi, 0));\n}\n\n// There are so many ways to do this, though,\n// idk yet which I will wind up using\n// I tend to experiment to try to find shorter ways\n// or methods that fit different use-cases better.\n// The mat2 way is indeed very nice and versatile though.\n// I just wish it weren't so entangled with cossin.\n// including cossin, taking angle argument makes it\n// simpler in some cases but wasteful in others.\n// Fabrice complains every time I use the non-matrix version! hehehe\n// cheap rotation transform on p by s=(cos(a),sin(a))\n//void rot(inout vec2 p, vec2 s) \n//{\n//\tp = p * s.x + vec2(p.y, -p.x) * s.y;\n//} // then can rot(q.xz, cossin(a))\n// as matrix\nmat2 mrot(vec2 s)\n{\n    return mat2(s.x, -s.y, s.y, s.x);\n} // then can q.xz = mrot(cossin(a)) * q.xz;\n\n// build a 3x3 camera orientation matrix given forward and up direction vectors\n// not much like what I started with in https://shadertoy.com/view/ls3fDr, slightly reversed\nmat3 cameraMatrix(vec3 fwd, vec3 up)\n{\n    vec3 w = normalize(fwd)\n       , u = normalize(cross(up, w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n// then just transform by pw = MC * pv;\n// should transpose as view matrix instead!\n// then would be pw = pv * MV;\n\n// complicated by BufferC isn't available directly\nvec3 cameraPosition(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraPosition).xyz;\n}\n\nvec3 cameraDirection(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraForward).xyz;\n}\n\n// to signed aspect correct uv given screen pixel and resolution\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\nbool asleep(vec2 mouse) // in shadertoy.com shader browser thumbnail? \n{\n    return dot(mouse, mouse) <= 2.;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// BufferC controls the state, mostly the camera location+direction\n// but wound up needing old mouse state and, for smoothing,\n// the desired facing direction.\n\n#define BufferC   iChannel2\n// also the shader fragColor output\n#define Keyboard  iChannel3\n\nconst float moverate = .5; // actually very slow.\nconst float turnratemouse = .02; // since mouse can't go outside window, must be pretty fast\nconst float turnratekbd = 2.6;\n\n\nvec3 desiredDirection() \n{\n    return loadValue(BufferC, slotDesiredForward).xyz;\n}\n\nvec4 oldMouse() \n{\n    return loadValue(BufferC, slotMouseOld);\n}\n\n\n// read keyboard key, return 1.0 if down\n// ultimately want to do differencing of negatives from positives\nfloat key(int vk) // key down state value as a float fraction\n{\n    float s = loadValue(Keyboard, vk).x; // read keyboard key state from texture\n    return step(.5, s); // test if down\n}\n\nconst int\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n// https://wikipedia.org/wiki/Arrow_keys#WASD_keys\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n// in DVORAK it's ,AOE, in AZERTY it's ZQSD\n, KEY_Z     = 90 // but Image tab is using it for showing depth FIXME\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_COMMA = 188 //188 JS, 44 ASCII\n, KEY_X     = 88 // used by Image tab; should keys move to Common tab?\n, KEY_LEFT  = 37 // arrow keys for lookaround\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40 // I suppose you could bind them instead of WASD if you really prefer, but then must use mouse to look\n#if 0\n    // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0 \n    // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else \n    // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE\n, KEY_DW    = KEY_C  // anything but control!\n//, KEY_CTRL  = 17 // DO NOT use control generally as when held, bad things can happen to our window or tab\n;\n// see also http://keycode.info\n\nvec3 cameraMovement(bool shift)\n{\n    vec3 campos = cameraPosition(BufferC);\n    float\n      fw = key(KEY_FW)\n    , bw = key(KEY_BW)\n    , lf = key(KEY_LF)\n    , rt = key(KEY_RT)\n    , up = key(KEY_UW)\n    , dn = key(KEY_DW);\n    if (asleep(iMouse.xy)) fw = .5; // automate forward in thumbnails\n    vec3 camfwd = cameraDirection(BufferC);\n    mat3 camori = cameraMatrix(camfwd, vec3(0,1,0));\n    vec3 cammove = vec3(rt-lf, up-dn, fw-bw) * iTimeDelta * moverate;\n    if (shift) cammove *= 4.0; // shift key for speed boost\n    campos += camori * cammove;\n    const float camradius = .04;\n//    campos += sdfnormal(campos) * -min(sdf(campos) - camradius, .0); // collision with sdf\n    return campos;\n}\n\nvec3 cameraSteering(bool shift)\n{\n    vec3 desiredRot = desiredDirection();\n    vec4 oMouse = oldMouse();\n    bool lmb = iMouse.z >= 0.;\n    bool olmb = oMouse.z >= 0.;\n    float shiftmod = shift ? .5 : 1.; // shift actually slows rotation down\n    vec2 orbit = vec2(0);\n    if (asleep(iMouse.xy)) {\n    \torbit = vec2(.05*iTimeDelta, 0);   // attract mode slow spin\n\t} else {\n    \tif (lmb && olmb) {\n\t        vec2 m = iMouse.xy - oMouse.xy;\n    \t    orbit += m * turnratemouse * shiftmod;\n    \t} \n    \t{\n    \t\tfloat aL = key(KEY_LEFT), aR = key(KEY_RIGHT), aU = key(KEY_UP), aD = key(KEY_DOWN);\n\t        vec2 m = vec2(aR - aL, aU - aD);\n    \t    orbit += m * iTimeDelta * turnratekbd * shiftmod;\n        }\n    }\n    if (dot(orbit,orbit) != 0.) {\n        desiredRot.xz *= mrot(cossin(-orbit.x)); //desiredRot.xz = mrot(cossin(orbit.x)) * desiredRot.xz; //rot(desiredRot.xz, cossin(orbit.x)); //\n        vec2 vr = vec2(1., desiredRot.y);\n        vr *= mrot(cossin(orbit.y)); //vr = mrot(cossin(-orbit.y)) * vr; //rot(vr, cossin(-orbit.y));\n        desiredRot.xz *= max(1e-1, vr.x); // do not flip signs here!\n        desiredRot.y = vr.y;\n  \t\tdesiredRot = normalize(desiredRot);\n    }\n    return desiredRot;\n}\n\n// smoothing filter\nvec3 cameraSmoothing()\n{\n    vec3 camfwd = cameraDirection(BufferC);\n    vec3 desiredFwd = desiredDirection();\n    camfwd = normalize(mix(desiredFwd, camfwd, exp2(-64.*iTimeDelta)));\n    return camfwd;\n}\n\n// FIXME GL ES 1.0 does not support switch btw, so this limits the support to newer devices\n// implements a debugging fly camera using keyboard WASD + mouse + C/space\n// stores camera position,aim,etc. into c as a \n// color coded vector suitable for output to buffer\nvoid debugFlyCamera(out vec4 c, vec2 p)\n{    \n    ivec2 ip = ivec2(p);\n\t// ignore most pixels - otherwise using an entire buffer is really bad\n    if (!(ip.y == 0 && ip.x < slotCount)) discard;\n    c = loadValue(BufferC, ip.x); // passthru by default\n    bool shift = key(KEY_SHIFT) > .5;\n    bool init = iFrame < 3; //iFrame == 0; // thumbnail issues\n    switch (slotid(ip)) {\n      case slotCameraPosition: {\n \t    c.xyz = init ? vec3(.0,1.5,-3.5) : cameraMovement(shift);            \n        break;\n      }\n      case slotCameraForward: {\n        c.xyz = init ? vec3(0.,0.,1.) : cameraSmoothing();\n        break;\n      }\n      case slotDesiredForward: {\n        c.xyz = init ? vec3(0.,0.,1.) : cameraSteering(shift);\n        break;\n      }\n      case slotMouseOld: {\n        c = iMouse;\n        break;\n      }\n      default:\n        break;\n    }\n}\n    // 4 inefficient pixels shouldn't be a huge deal\n\n// in this case we output into Buffer C\nvoid mainImage(out vec4 c, vec2 p)\n{\n//    if (p.y >= 1. || int(p.x) >= slotCount) discard; // redundant\n    debugFlyCamera(c, p);\n}\n\n\n    //float elapsed = iTimeDelta; // seconds\n\n\n//KEY_CTRL // be careful with control key though; ctrl+W for example closes the window or something\n// iMouse.z is negative if lmb up\n \n\n\n// I hear Ben Quantock has a toy with fly cam!  \n// TODO I should check it out.  Maybe you should too!\n// https://shadertoy.com/view/ldyGzW\n// It's interesting but it's based on Euler angles completely.\n// Simpler in some ways.  The walking support and\n// camera flipping complicates it.  There's comments\n// there from Fabrice regarding how WASD sucks for \n// international keyboard users.  I suppose I've done about\n// all I can to help with that, but it could be more \n// automatic or easier to set up.  Maybe arrows should be movement?\n\n","name":"Buffer C","description":"","type":"buffer"}]}