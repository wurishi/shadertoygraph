{"ver":"0.1","info":{"id":"lflBRB","date":"1723991719","viewed":79,"name":"Reverse Multilevel 3D DDA","username":"Teluri","description":"Iterate on the lower level first and then iterate on the upper level and skip when necessary\n\nany idea on how to maker it faster?","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voxel","dda","3dda"],"hasliked":0,"parentid":"lfyGRW","parentname":"Multilevel 3D DDA"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_RAY_STEPS = 64*2;\n\nconst uint data1=4187984905u;\nconst uint data2=2418669983u;\n\n\nfloat sdSphere(vec3 p, float d) { \n    return length(p) - d; \n} \n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n  \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\t\nbool getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    \n\treturn d < 0.0;\n}\n\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n    \n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nuvec2 GetChunkOccupancy(ivec3 pos){\n    if(!getVoxel(pos)){\n        return uvec2(0u,0u);\n    }\n\treturn uvec2(data2,data1);\n}\n\nbool GetOccupancyBit(uvec2 chunk,vec3 pos){\n\tuvec3 upos= uvec3(pos);//&uvec3(3u)\n\tuint index= upos.x|(upos.y<<2u)|((upos.z&1u)<<4u);\n\t//uint data=bool(upos.z&2u)?chunk.y:chunk.x;\n    uint data = chunk[upos.z>>1u];\n\treturn bool(data & (1u<<index));\n}\n\nvec3 stepMask(vec3 sideDist) {\n    // <3\n    // Yoinked from https://www.shadertoy.com/view/l33XWf\n    bvec3 move;\n    bvec3 pon=lessThan(sideDist.xyz,sideDist.yzx);\n\n    move.x=pon.x && !pon.z;\n    move.y=pon.y && !pon.x;\n    move.z=!any(move.xy);\n\n    return vec3(move);\n}\n\n\nvec4 traceWorld(vec3 rayPos2, vec3 rayDir) {\n    vec3 raySign  = sign(rayDir);\n    vec3 raySign01= vec3(greaterThanEqual(rayDir,vec3(0.)));\n    \n    rayDir=abs(rayDir);\n    vec3 deltaDist= 1.0/rayDir;\n    \n    //upper level\n    //rayPos2*=0.25;\n    vec3 mapPos2  = floor(rayPos2);\n    vec3 sideDist2= (mapPos2-rayPos2 + raySign01) * deltaDist*raySign;\n    \n    \n    //lower level\n    vec3 rayPos   = (rayPos2-mapPos2)*4.;\n    vec3 mapPos   = floor(rayPos);\n    vec3 sideDist = (mapPos-rayPos + raySign01) * deltaDist*raySign;\n    vec3 mask     = stepMask(sideDist);\n    \n    \n    uvec2 chunk   = GetChunkOccupancy(ivec3(mapPos2));\n    \n    bool skipped  = false;\n    for (int i = 0; i < MAX_RAY_STEPS; i++) {\n        if(skipped||any(lessThan(mapPos,vec3(0)))||any(greaterThanEqual(mapPos,vec3(4.)))){\n            // if the lower level step crossed a chunk edge, do a upper level step\n            mask       = stepMask(sideDist2);\n            mapPos2   += mask * raySign;\n            sideDist2 += mask * deltaDist;\n            mapPos    -= mask * raySign * 4.;//adjust the lower level position to be back in 0..3\n            \n            chunk=GetChunkOccupancy(ivec3(mapPos2));\n            if(!all(bvec2(chunk))){\n                //if empty, skip doing the lower level steps and goes back to doing a upper level step\n                skipped=true;\n                continue;\n            }else if(skipped){ \n                //if not empty but the previous chunk was, recalculate the lower level position\n                skipped=false;\n                vec3 mini  = (mapPos2-rayPos2 + 1.-raySign01) * deltaDist*raySign;\n\t\t\t\tfloat d    = max (mini.x, max (mini.y, mini.z));\n\t\t\t\tvec3 inters= rayPos2 + rayDir*d*raySign;\n\t\t\t\t\n\t\t\t\tvec3 uv3d  = (inters - mapPos2)*4.;\n\t\t\t\tuv3d       = clamp(uv3d,vec3(0.00001),vec3(3.99999));\n\t\t\t\tmapPos     = floor(uv3d);\n\t\t\t\tsideDist   = (mapPos-uv3d +raySign01) * deltaDist*raySign;\n\t\t\t\t//mask       = mask2;\n            }\n        }\n        \n\t\tif(GetOccupancyBit(chunk,mapPos)){\n\t\t\treturn vec4(mapPos*0.25,1.);\n\t\t}\n        \n        mask      = stepMask(sideDist);\n        mapPos   += mask * raySign;\n        sideDist += mask * deltaDist;\n    }\n    \n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.0);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 2.7), -12.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, iTime);\n\trayDir.xz = rotate2d(rayDir.xz, iTime);\n    \n    if (any(equal(rayDir, vec3(0.0)))) // Avoid divide by zero when rayDir element is zero\n        rayDir += vec3(equal(rayDir, vec3(0.0))) * vec3(0.00001f);\n\t    \t\n\tfragColor = traceWorld(rayPos, rayDir);\n}","name":"Image","description":"","type":"image"}]}