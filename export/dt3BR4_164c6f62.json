{"ver":"0.1","info":{"id":"dt3BR4","date":"1701003676","viewed":99,"name":"brute force god-rays","username":"schneckers","description":"Siimple example of crepuscular/god rays + vogel disk for extra blur. Entirely screen-space based. ","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["godrays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2023 - Julian Heinken\n\n// NOTE: This is just for demonstration. In a real-world scenario, you should do the blurring process across multiple passes, with very few samples.\n// The amount of effective samples will accumulate, given much better performance compared to a single pass with brute force +200 samples.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // config variables:\n    int radialSmpCount = 48;\n    int softnessSmpCount = 6;\n    float range = -0.7;\n    float blurRadius = 0.08;\n    float attenuationSoftness = 0.8;\n \n \n    float rangePerSample = range / float(radialSmpCount);\n \n    \n    vec2 radialOrigin = vec2(0.3, 0.8); \n    radialOrigin += vec2(sin(iTime * 2.0), cos(iTime)) * vec2(0.1, 0.05) + vec2(0.1);\n    \n    // optional mouse control.\n    if(iMouse.z > 0.0){\n        radialOrigin = iMouse.xy / iResolution.xy ;\n    }\n    \n    vec4 buffer = vec4(0);\n    for(int softnessSmpIdx = 0; softnessSmpIdx < softnessSmpCount; softnessSmpIdx++)\n    {\n        vec2 softnessOffset = VogelDiskSample(softnessSmpIdx, softnessSmpCount, 0.0) * blurRadius;\n        vec2 uvOffset = softnessOffset + radialOrigin;\n        vec2 uvCentered = uv - uvOffset;\n        for(int radialIdx = 0; radialIdx < radialSmpCount; radialIdx++)\n        {\n            float stepSize = float(radialIdx) * rangePerSample;\n            vec2 uv = uvCentered * (1.0 + stepSize) + uvOffset ;\n            buffer += texture(iChannel0, uv); \n        }\n    }\n    \n  \n    vec4 radialBlurTarget = buffer / float(softnessSmpCount * radialSmpCount);\n    // compute attenuation\n    {\n        vec2 vecToOrigin = radialOrigin - uv;\n        \n        float invSqrFalloff = 1.0 / (dot(vecToOrigin, vecToOrigin) + attenuationSoftness);\n        radialBlurTarget *= invSqrFalloff;\n    }\n    radialBlurTarget *=  exp2(4.0);\n    \n    // composing.\n    vec4 background = texture(iChannel1, uv) * 0.8;\n    vec4 finalColor = radialBlurTarget + background;\n    \n    // frankenstein reinhard tonemapping\n    finalColor = (finalColor / (2.0 + finalColor)) * 2.0;\n    \n    \n    // Output to screen \n    fragColor = finalColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = max(vec4(0.0), texture(iChannel0, uv) - vec4(0.9));\n    //fragColor = pow(texture(iChannel0, uv), exp2(vec4(4.0)));\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 VogelDiskSample(int sampleIndex, int sampleCount, float phi)\n{\n    float sampleIndexf = float(sampleIndex);\n    float sampleCountf = float(sampleCount);\n    \n    float goldenAngle = 2.39996;\n\n    float r = sqrt((sampleIndexf + 0.5) / sampleCountf);\n    float theta = sampleIndexf * goldenAngle + phi;\n\n    return vec2(cos(theta), sin(theta)) * r;\n}","name":"Common","description":"","type":"common"}]}