{"ver":"0.1","info":{"id":"XfdcRn","date":"1730233475","viewed":41,"name":"Persistent State Velocity Test","username":"8InfinityTaco8","description":"Use the WASD keys to move the ball. ill add smearing and motion blur in different styles at to this at some point. ","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["physics","velocity","controls","persistentstate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 state = texture(iChannel0, vec2(0.5));\n    \n    // Calculate aspect ratio\n    float aspect = iResolution.x / iResolution.y;\n    \n    // Center UV and adjust for aspect ratio, then offset by circle position\n    vec2 centeredUV = (uv - state.xy) * vec2(aspect, 1.0);\n    \n    // Render circle using SDF\n    float d = sdCircle(centeredUV, CIRCLE_RADIUS);\n    vec3 col = vec3(smoothstep(0., 0.001, -d));\n    \n    //smoothstep(0.001, 0., -d) This gave black circle\n\n   //smoothstep(0., 0.001, -d) This gives white circle\n\n\n    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nbool isKeyPressed(int keyCode) {\n    return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x > 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 previousState = texture(iChannel0, uv);\n    \n    // Initialize state\n    if (iFrame == 0) {\n        fragColor = vec4(0.5, 0.5, 0.0, 0.0);  // INIT_POS expanded\n        return;\n    }\n    \n    vec2 position = previousState.xy;\n    vec2 velocity = previousState.zw;\n    \n    // Handle input\n    if (isKeyPressed(KEY_W)) velocity.y += ACCELERATION;\n    if (isKeyPressed(KEY_S)) velocity.y -= ACCELERATION;\n    if (isKeyPressed(KEY_A)) velocity.x -= ACCELERATION;\n    if (isKeyPressed(KEY_D)) velocity.x += ACCELERATION;\n    \n    // Update physics\n    velocity *= FRICTION;\n    position += velocity;\n    \n    // Boundary checking\n    position = clamp(position, BOUND_MIN, BOUND_MAX);\n    \n    fragColor = vec4(position, velocity);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define CIRCLE_RADIUS 0.05\n#define ACCELERATION 0.001\n#define FRICTION 0.98\n#define BOUND_MIN CIRCLE_RADIUS\n#define BOUND_MAX (1.0 - CIRCLE_RADIUS)\n\n#define KEY_W 87\n#define KEY_S 83\n#define KEY_A 65\n#define KEY_D 68\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}","name":"Common","description":"","type":"common"}]}