{"ver":"0.1","info":{"id":"fttfDB","date":"1663613463","viewed":81,"name":"dice_and_spheres","username":"boulygin233","description":"First + Second HW","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["homework","computergraphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 6.28;\nconst int spheres_amount = 6;\nconst float cube_size = 0.8;\nconst float pos = 0.5;\nconst float radius = 0.2;\nconst float rotate_radius = 2.0;\nconst float rotate_speed = 0.5;\n\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,c,-s),\n        vec3(0,s,c)\n    );\n}\n\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,0,-s),\n        vec3(0,1,0),\n        vec3(s,0,c)\n    );\n}\n\n\nfloat box ( in vec3 pos, in vec3 size )\n{\n    vec3 pt = abs ( pos ) - size;\n\n    return length ( max ( pt, 0.0 ) ) + min ( max ( pt.x, max ( pt.y, pt.z ) ), 0.0 );\n}\n\nfloat sphere ( vec3 p, in vec3 center, in float radius )\n{\n    return length ( p - center ) - radius;\n}\n\nfloat dE1 ( in vec3 p, in mat3 m)\n{\n    vec3  pt = m * p;\n    float d2 = box( pt, vec3 ( cube_size, cube_size, cube_size ) );\n    \n    float res = d2;\n    \n    //1\n    float ds = sphere ( pt, vec3 ( cube_size, 0.0, 0.0), radius );\n    res = max ( -ds, res );\n    \n    //6\n    ds = sphere ( pt, vec3 ( -cube_size, pos, pos), radius );\n    res = max ( -ds, res ); \n    ds = sphere ( pt, vec3 ( -cube_size, pos, -pos), radius );\n    res = max ( -ds, res ); \n    ds = sphere ( pt, vec3 ( -cube_size, -pos, pos), radius );\n    res = max ( -ds, res ); \n    ds = sphere ( pt, vec3 ( -cube_size, -pos, -pos), radius );\n    res = max ( -ds, res ); \n    ds = sphere ( pt, vec3 ( -cube_size, 0.0, pos), radius );\n    res = max ( -ds, res ); \n    ds = sphere ( pt, vec3 ( -cube_size, 0.0, -pos), radius );\n    res = max ( -ds, res ); \n    \n    //2\n    ds = sphere ( pt, vec3 ( pos, cube_size, -pos), radius );\n    res = max ( -ds, res ); \n    ds = sphere ( pt, vec3 ( -pos, cube_size, pos), radius );\n    res = max ( -ds, res );\n    \n    //5\n    ds = sphere ( pt, vec3 ( 0.0, -cube_size, 0.0), radius );\n    res = max ( -ds, res );\n    ds = sphere ( pt, vec3 ( pos, -cube_size, -pos), radius );\n    res = max ( -ds, res ); \n    ds = sphere ( pt, vec3 ( -pos, -cube_size, pos), radius );\n    res = max ( -ds, res );\n    ds = sphere ( pt, vec3 ( pos, -cube_size, pos), radius );\n    res = max ( -ds, res ); \n    ds = sphere ( pt, vec3 ( -pos, -cube_size, -pos), radius );\n    res = max ( -ds, res );\n    \n    //3\n    ds = sphere ( pt, vec3 ( 0.0, 0.0, cube_size), radius );\n    res = max ( -ds, res );\n    ds = sphere ( pt, vec3 ( pos, pos, cube_size), radius );\n    res = max ( -ds, res );\n    ds = sphere ( pt, vec3 ( -pos, -pos, cube_size), radius );\n    res = max ( -ds, res );\n    \n    //4\n    ds = sphere ( pt, vec3 ( pos, pos, -cube_size), radius );\n    res = max ( -ds, res ); \n    ds = sphere ( pt, vec3 ( pos, -pos, -cube_size), radius );\n    res = max ( -ds, res );\n    ds = sphere ( pt, vec3 ( -pos, pos, -cube_size), radius );\n    res = max ( -ds, res );\n    ds = sphere ( pt, vec3 ( -pos, -pos, -cube_size), radius );\n    res = max ( -ds, res );\n    \n    return res;\n}\n\nfloat dE2 ( in vec3 p, in mat3 m)\n{\n    vec3  pt = m * p;\n    \n    float res = 10.0;\n    \n    for (int i = 0; i < spheres_amount; ++i)\n    {\n        float ds = sphere ( pt, vec3 ( rotate_radius * cos(pi / float(spheres_amount) * (float(i) + iTime * rotate_speed)), rotate_radius * sin(pi/ float(spheres_amount) * (float(i) + iTime * rotate_speed)), 0.0 ), radius );\n        res = min ( ds, res );\n        ds = sphere ( pt, vec3 ( rotate_radius * cos(pi / float(spheres_amount) * (float(i) + iTime * rotate_speed)), 0.0 ,rotate_radius *  sin(pi/ float(spheres_amount) * (float(i) + iTime * rotate_speed)) ), radius );\n        res = min ( ds, res );\n        ds = sphere ( pt, vec3 ( 0.0 , rotate_radius * sin(pi/ float(spheres_amount) * (float(i) + iTime * rotate_speed)), rotate_radius * cos(pi / float(spheres_amount) * (float(i) + iTime * rotate_speed)) ), radius );\n        res = min ( ds, res );\n    }\n    \n    return res;\n}\n\nvec3 trace ( vec3 from, vec3 dir, out bool hit, in mat3 m, out int obj)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < 30; steps++ )\n\t{\n\t\tfloat\tdist1 = dE1 ( p, m);\n\t\tfloat\tdist2 = dE2 ( p, m);\n        \n\t\t\n\t\tif ( min(dist1, dist2) < 0.01 )\n\t\t{\n\t\t\thit = true;\n            if (dist1 < 0.01) \n            {\n                obj = 1;\n            }\n            else\n            {\n                obj = 2;\n            }\n\t\t\tbreak;\n\t\t}\n        \n\t\t\n\t\ttotalDist += min(dist1, dist2);\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += min(dist1, dist2) * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal(vec3 z, in mat3 m)\n{\n    float e = 0.001;\n    float dx1 = min(dE1(z + vec3(e,0,0), m), dE2(z + vec3(e,0,0), m));\n    float dx2 = min(dE1(z - vec3(e,0,0), m), dE2(z - vec3(e,0,0), m));\n    float dy1 = min(dE1(z + vec3(0,e,0), m), dE2(z + vec3(0,e,0), m));\n    float dy2 = min(dE1(z - vec3(0,e,0), m), dE2(z - vec3(0,e,0), m));\n    float dz1 = min(dE1(z + vec3(0,0,e), m), dE2(z + vec3(0,0,e), m));\n    float dz2 = min(dE1(z - vec3(0,0,e), m), dE2(z - vec3(0,0,e), m));\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nvec3 getTriplanarWeights ( in vec3 n ) \n{\n\tvec3 triW = abs(n);\n    \n\treturn triW / (triW.x + triW.y + triW.z);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0,0,9);\n    vec3 light = vec3(0.0, 3.0, 5.0);\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z - 0.5);\n    mat3 m = rotateX(6.0*mouse.y) * rotateY(6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy/max(iResolution.x, iResolution.y);\n    vec2 uv = scale * (fragCoord/iResolution.xy - vec2(0.5));\n    vec3 dir = normalize(vec3(uv, 0) - eye);\n    \n    bool hit;\n    int obj;\n    vec4 color = vec4 (0.5 + sin(iTime) / 5.0, 0.3 + cos(iTime) / 8.0, 1, 1);\n    \n    vec3 p = trace(eye, dir, hit, m, obj);\n    vec3 l = normalize(light - p);\n    vec3 v = normalize(eye - p);\n    vec3 n = generateNormal(p, m);\n    float nl = max(0.0, dot(n,l));\n    vec3 h = normalize(l + v);\n    float hn = max(0.0, dot(h, n));\n    float sp = pow(hn, 100.0);\n    \n    vec3 tx = getTriplanarWeights( n );\n    vec3 q  = m * p;\n    if (hit)\n    {\n        \n        if (obj == 1){\n            color = 0.7 * vec4(nl) + 0.5 * sp * vec4(1.0,0.0,0.0,1);\n            \n            vec4 cx = texture ( iChannel0, q.yz );\n            vec4 cy = texture ( iChannel0, q.zz );\n            vec4 cz = texture ( iChannel0, q.xy );\n            color *=  (tx.x * cx + tx.y * cy + tx.z * cz) * 1.5;\n        }\n        if (obj == 2){\n            color =  vec4(nl) + 0.5 * sp * vec4(1.0,0.3,0.1,1);\n            vec4 cx = texture ( iChannel1, q.yz );\n            vec4 cy = texture ( iChannel1, q.zz );\n            vec4 cz = texture ( iChannel1, q.xy );\n            color *=  (tx.x * cx + tx.y * cy + tx.z * cz) * (2.0 + sin(iTime)) / 2.0;\n        }\n        \n    }\n    else {\n        vec4 cx = texture ( iChannel2, q.yz );\n        vec4 cy = texture ( iChannel2, q.zz );\n        vec4 cz = texture ( iChannel2, q.xy );\n        color *=  tx.x * cx + tx.y * cy + tx.z * cz;\n    }\n    \n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}