{"ver":"0.1","info":{"id":"ldyGzG","date":"1455007176","viewed":271,"name":"Ray Automata","username":"alleycatsphinx","description":"Uses one channel per particle, per pixel.\n\nThe decisions for moving along angled paths without history are a set of 32 quasirandom values equidistributed across the coordinates. \n\nParticles spawn from the center and where you click with the mouse.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["automata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//ray automata\n#define DECISION_DISTRIBUTION\t\t25./32.\n#define MAX_FLOAT\t\t\t\t\tpow(2.,  8.)\n#define MIN_FLOAT\t\t\t\t\tpow(2., -8.)\n#define WRAP \t\t\t\t\t\ttrue\n#define ANGLE \t\t\t\t\t\t3 //channel that the particle is stored in\n\n#define MOUSE\t\t\t\t\t\tiMouse.xy/iResolution.xy\n\n\nvec2 neighbor_offset(float i); //8 offsets corrosponding to the ring of moore neighborhood positions ((0., -1.), (1., -1.), (1., 0.), (1., 1.)... etc)\nfloat add_particle(float prior_angle, float new_angle, vec2 position, vec2 add_position);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 cell\t\t\t\t\t= vec4(0.);\n\tvec2 position \t\t\t\t= fragCoord.xy;\n    \n    \n    //this is the set of equidistributed decision functions\n\tvec2 field\t\t\t\t\t= fract(position * DECISION_DISTRIBUTION) * .125;\n        \n    \n    //test 8 positions around the current pixel\n\tfor (float i = 0.; i < 8.; i++)\n    {\n        //generate the neighbor sample position\n\t\tvec2 neighbor_uv \t\t= position.xy - neighbor_offset(i);\n\t\tneighbor_uv\t\t\t\t= fract(neighbor_uv/iResolution.xy);\n\n        \n        //sample the neighbor for it's angle\n\t\tvec4 neighbor \t\t\t= texture(iChannel0, neighbor_uv);\n\t\tfloat incoming_angle\t= neighbor[ANGLE];\n\t\t\n\n        //select a decision sequence based on the primary axis of motion for this angle\n        float cutting_sequence\t= abs(fract(incoming_angle * 2.) - .5) < .25 ? field.x : field.y;\n        cutting_sequence\t\t= fract(incoming_angle + cutting_sequence);\n\n        bool alignment_decision = floor(cutting_sequence * 8.) == i; \n        \n        cell \t\t\t\t\t= alignment_decision ? neighbor : cell; \t\n\t}\n\t\t\n\n    //this spawns particles (prior angle is used to generate new angles without time)\n    vec4 prior_cell\t\t\t\t= texture(iChannel0, fragCoord.xy/iResolution.xy);\n    float prior_angle \t\t\t= prior_cell[ANGLE];\n        \n\n    vec2 center_position \t\t= floor(iResolution.xy * .5);\n   \tfloat center_spawn_angle\t= max(fract(prior_angle + (sqrt(5.)-1.) * .5), MIN_FLOAT);\n    \n    vec2 mouse_position\t   \t\t= floor(MOUSE * iResolution.xy);\n\tfloat mouse_spawn_angle\t\t= max(fract(prior_angle + MIN_FLOAT), MIN_FLOAT);\t\n\t\n    cell[ANGLE] \t\t\t\t= add_particle(cell[ANGLE],center_spawn_angle, position, center_position);\n    cell[ANGLE] \t\t\t\t= add_particle(cell[ANGLE], mouse_spawn_angle, position,  mouse_position);\n    \n    \n    //this adds color to living cells (try commenting it out and then back on again)\n    bool alive \t\t\t\t\t= cell[ANGLE] != 0.;\n    cell.xyz \t\t\t\t\t= alive ? vec3(1., 1., 1.) : vec3(0., 0., 0.); \n    \n    \n    //add trails (comment this in for trails)\t\t\t\t\n    //cell.y \t\t\t\t\t\t= (cell.y + prior_cell.y) * .9975;\n    \n    \n\tfragColor\t \t\t\t\t= cell;\n}//sphinx\n\n\n//returns the sequence of offsets for the moore neighborhood\nvec2 neighbor_offset(float i)\n{\n\tfloat c = abs(i-2.);\n\tfloat s = abs(i-4.);\n\treturn vec2(c > 1. ? c > 2. ? 1. : .0 : -1., s > 1. ? s > 2. ? -1. : .0 : 1.);\n}\n\n\n//creates new particles at the add position\nfloat add_particle(float prior_angle, float new_angle, vec2 position, vec2 add_position)\n{\n\treturn length(floor(position - add_position)) == 0. ? new_angle : prior_angle;\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}