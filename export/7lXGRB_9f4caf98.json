{"ver":"0.1","info":{"id":"7lXGRB","date":"1623337209","viewed":235,"name":"Glitter rain","username":"elefAntti","description":"A particle system meets cellular automaton. The image area is divided into a grid and each cell owns the particles within it. That way it is easy to find for each pixel the particles that might contribute to it\nMaybe I'll refine this further in the future","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["particles","multibuffer"],"hasliked":0,"parentid":"flX3RS","parentname":"AV008_Part"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 pixOffset(vec2 fragCoord)\n{\n    vec2 noise = rnd2(fragCoord, iTime *90.0);\n    noise.y = pow(noise.y, 1.0) * 4.0;\n    return fragCoord + fromPolar(noise);\n}\n\nfloat particleIntensity(float r, float z)\n{\n    float smoothness = 0.5;\n    float radius = 3.0 + z;\n    float intensity = (smoothstep(radius, radius * (1.0 - smoothness), r) ) * min(1.0, 5.0 / (z*z));\n    return intensity;\n}\n\n//so we have room for 10 particles and 40 floats each\nvec4 getParticleData(vec2 fragCoord, int particleIdx, int dataIdx)\n{\n    vec2 bCoord = bucketCoords(fragCoord);\n    return texelFetch(iChannel0, ivec2(bCoord \n        + vec2(float(particleIdx), float(dataIdx))), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 nf = iResolution.xy/iResolution.x;\n    vec2 fragBackup = fragCoord;\n#ifdef PIXEL_OFFSET\n    fragCoord=pixOffset(fragCoord);\n#endif\n    fragColor = vec4(0.0);\n    for(float dy = -5.0; dy < 6.0; dy += 1.0)\n    {\n        for(float dx = -5.0; dx < 6.0; dx +=1.0)\n        {\n            vec2 offset = vec2(dx,dy) * BUCKET_SIZE;\n            vec4 particleData = getParticleData(fragCoord + offset, 0, XY_IDX);\n            vec4 particleZW = getParticleData(fragCoord + offset, 0, ZW_IDX);\n            vec4 particleColor = getParticleData(fragCoord + offset, 0, INTENSITY_IDX);\n            fragColor += particleColor * particleIntensity(length(fragBackup - particleData.xy), particleZW.r*10.0 );\n        }\n    }\n\n   fragColor = sqrt(fragColor);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BUCKET_SIZE 10.00\n\n#define PARTICLE_DEAD_LIMIT 0.01\n#define GRAVITY 50.0\n#define PARTICLE_DECAY 0.99\n\n\n#define XY_IDX 0\n#define ZW_IDX 1\n#define INTENSITY_IDX 2\n\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 rnd2(vec2 coord, float time)\n{\n    return hash23(vec3(coord,time));\n}\n\n\n// All components are in the range [0â€¦1], including hue.\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Every pixel belongs to an x-by-x bucket. \n//These buckets are mapped to texture coords so that every second line is used\nvec2 bucketCoords( vec2 pixelCoords)\n{\n    vec2 gridCoords = floor(pixelCoords / BUCKET_SIZE);\n    return gridCoords * BUCKET_SIZE;\n}\n\n\n//kind of pseudo polar, where dir is between 0-1\nvec2 fromPolar(vec2 polar)\n{\n    polar.x *= 2.0 * 3.14159265;\n    vec2 cartesian = vec2(cos(polar.x), sin(polar.x)) * polar.y;\n    return cartesian;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec4 getParticleData(vec2 fragCoord, int particleIdx, int dataIdx)\n{\n    vec2 bCoord = bucketCoords(fragCoord);\n    return texelFetch(iChannel0, ivec2(bCoord \n        + vec2(float(particleIdx), float(dataIdx))), 0);\n}\n\n//Fetch another data channel from this same particle\nvec4 getSameParticleData(vec2 fragCoord, int dataIdx)\n{\n    vec2 bCoord = fragCoord;\n    bCoord.y = floor(bCoord.y / BUCKET_SIZE) * BUCKET_SIZE;\n    \n    return texelFetch(iChannel0, ivec2(bCoord + vec2(0.0, float(dataIdx))), 0);\n}\n\nbool particleInBucket(vec2 bucketCoord, vec2 particleCoord)\n{\n    vec2 diff = particleCoord - bucketCoord;\n    return min(diff.x, diff.y) >= 0.0 && max(diff.x, diff.y) < BUCKET_SIZE;\n}\n\nbool adopt(vec2 fragCoord, int dataChannel, out vec4 adoptedParticle)\n{\n    vec2 bCoords = bucketCoords(fragCoord);\n    for( int i = -1; i < 2; ++i)\n    {\n        for( int j = -1; j < 2; ++j)\n        {\n            if(i==0&&j==0)\n            {\n                continue;\n            }\n            for(int k = 0; k < 2; ++k)\n            {\n                vec2 offset = vec2(i, j)*BUCKET_SIZE;\n                vec4 pd = getParticleData(bCoords + offset, k, XY_IDX);\n                if(particleInBucket(bCoords, pd.xy))\n                {\n                    adoptedParticle = getParticleData(bCoords + offset, k, dataChannel);\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nbool particleDead(vec4 intensityData)\n{\n    return length(intensityData.rgb) < PARTICLE_DEAD_LIMIT;\n}\n\n\nvec4 makeNewParticle(int dataChannel, vec2 fragCoord, float time)\n{\n    if(int(dataChannel) == XY_IDX)\n    {        \n        vec2 pos = bucketCoords(fragCoord) + rnd2(fragCoord, time) * BUCKET_SIZE;\n        vec2 vel = fromPolar(rnd2(fragCoord, time)) * 50.0;\n        return vec4(pos.x, pos.y, vel.x, vel.y);\n    }\n    else if(int(dataChannel) == ZW_IDX)\n    {   \n        vec2 pos = rnd2(fragCoord * vec2(1002.0, 707.2), time + 0.1) * vec2(3.0) - vec2(1.5);\n        vec2 vel = rnd2(fragCoord * vec2(1021.7, 117.2), time + 0.3) * vec2(3.0) - vec2(1.5);\n        \n        return vec4(pos.x, pos.y, vel.x, vel.y);\n    }\n    else\n    {\n        vec2 hue_sat = rnd2(fragCoord, time);\n        hue_sat.y *= 0.5;\n        hue_sat.y += 0.5;\n        vec3 rgb = hsv2rgb(vec3(hue_sat, 1.0));\n        return vec4(rgb, 1.0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coordInCell = mod(fragCoord, BUCKET_SIZE);\n    \n    int dataChannel = int(round(coordInCell.y));\n    float particleIdx = round(coordInCell.x);\n    vec4 particleIntensities = getSameParticleData(fragCoord, INTENSITY_IDX);\n    vec4 particleCoords = getSameParticleData(fragCoord, XY_IDX);\n    vec4 adoptedParticle = vec4(0.0);\n    vec4 particleZW = getSameParticleData(fragCoord, ZW_IDX);\n   \n    \n    vec4 particleData = dataChannel==XY_IDX ? particleCoords:\n                        dataChannel==ZW_IDX ? particleZW:\n                        particleIntensities;\n    \n    \n    bool forceGenerate = distance(particleCoords.xy, fragCoord) > (5.0*BUCKET_SIZE);\n    if(particleDead(particleIntensities) || forceGenerate)\n    {\n        if(int(particleIdx) == 0)\n        {\n            particleData = makeNewParticle(int(dataChannel), fragCoord, iTime);\n        }\n        else\n        {\n            particleData = vec4(0.0);\n        }\n    }\n    \n    if(adopt(fragCoord, int(dataChannel), adoptedParticle))\n    {\n        if(int(particleIdx) == 0)\n        {\n            particleData = adoptedParticle;\n        }\n        else if(int(particleIdx) == 1)\n        {\n            particleData = getParticleData(fragCoord, 0, int(dataChannel));\n        }\n    }\n    \n    if(int(dataChannel) == XY_IDX)\n    {        \n            //Move particles\n            particleData.xy += particleData.zw * iTimeDelta / (particleZW.r+4.0);\n            particleData.w -= GRAVITY * iTimeDelta;\n            fragColor = particleData;\n    }\n    else if(int(dataChannel) == ZW_IDX)\n    {        \n            //Move particles\n            particleData.xy += particleData.zw * iTimeDelta;\n            fragColor = particleData;\n    }\n    else\n    {\n            fragColor=particleData*PARTICLE_DECAY;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}