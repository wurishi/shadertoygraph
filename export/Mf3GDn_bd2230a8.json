{"ver":"0.1","info":{"id":"Mf3GDn","date":"1711553900","viewed":67,"name":"Luminance-based edge detection","username":"mileslacey","description":"Extracting edges from the luminance-based sharpening shader.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["luminance","sharpening","luma","sparpen"],"hasliked":0,"parentid":"MXlXRX","parentname":"Luminance-based image sharpening"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License\n\n#define NEARBY_TEXEL_DISTANCE vec2(0.25)\n\n// final smoothstep interpolation edge,\n// lower values increase edge brightness\n#define LUMINANCE_CUTOFF 0.1\n\n// Linearize sRGB values before extracting luminance\n#define CONVERT_SRGB_LUMINANCE 0\n\n// Determine the Luminance method.\n//     0 uses average channel weights\n//     1 uses YCoCg-based luminance conversion\n//     2+ uses perceptive luminance\n#define LUMINANCE_CONVERSION_METHOD 2\n\n\n\n/*--------------------------------------\n RGB <-> YCoCg conversions\n--------------------------------------*/\nfloat rgb_to_luminance(vec4 rgb)\n{\n#if CONVERT_SRGB_LUMINANCE != 0\n    rgb = pow(rgb, vec4(2.2));\n#endif\n\n    // Different methods for getting luminance:\n    \n#if LUMINANCE_CONVERSION_METHOD == 0\n    const vec4 factor = vec4(vec3(1.0/3.0), 0.0);\n#elif LUMINANCE_CONVERSION_METHOD == 1\n    const vec4 factor = vec4(0.25, 0.5, 0.25, 0.0);\n#else\n    const vec4 factor = vec4(0.2126, 0.7152, 0.0722, 0.0);\n#endif\n    return dot(rgb, factor);\n}\n\n\n\nfloat rgb_to_luminance2(vec4 rgb)\n{\n    return rgb_to_luminance(rgb) * 2.0 - 1.0;\n}\n\n\n\n/*--------------------------------------\n Colors as Geometry\n--------------------------------------*/\nvec4 colors_to_normal(in float c0, in float c1, in float c2)\n{\n#if 0\n    vec3 p0 = vec3(c0,  0.0, 0.0);\n    vec3 p1 = vec3(0.0, c1,  0.0);\n    vec3 p2 = vec3(0.0, 0.0, c2);\n    vec3 p  = cross(p1-p0, p2-p0);\n#else\n    vec3 p  = vec3(c1, c0, c0) * vec3(c2, c2, c1);\n#endif\n    return vec4(normalize(p), 0.0);\n}\n\n\n\nfloat safe_sign(float x)\n{\n    return x >= 0.0 ? 1.0 : -1.0;\n}\n\n\n\nfloat imix(in float a, in float b, in float t)\n{\n    return (t-a)/(b-a);\n}\n\n\n\nvec4 imix4(in vec4 a, in vec4 b, in vec4 t)\n{\n    return (t-a)/(b-a);\n}\n\n\n\n/*--------------------------------------\n Upscaling\n--------------------------------------*/\nvec4 upscale_image(in vec2 fragCoord, in vec2 resolution, in sampler2D texImage)\n{\n    vec2  dims   = vec2(textureSize(texImage, 0).xy);\n    vec2  scale  = resolution / dims;\n    vec2  offset = scale * NEARBY_TEXEL_DISTANCE;\n    vec2  uv0    = fragCoord;\n    vec2  uvn    = uv0 + vec2( 0.0,      offset.y);\n    vec2  uvs    = uv0 + vec2( 0.0,     -offset.y);\n    vec2  uve    = uv0 + vec2( offset.x,  0.0);\n    vec2  uvw    = uv0 + vec2(-offset.x,  0.0);\n    \n    // nearby texture values\n    vec4 c0 = texture(texImage, uv0/resolution);\n    vec4 cn = texture(texImage, uvn/resolution);\n    vec4 cs = texture(texImage, uvs/resolution);\n    vec4 ce = texture(texImage, uve/resolution);\n    vec4 cw = texture(texImage, uvw/resolution);\n    \n    float l0 = rgb_to_luminance2(c0);\n    float ln = rgb_to_luminance2(cn);\n    float ls = rgb_to_luminance2(cs);\n    float le = rgb_to_luminance2(ce);\n    float lw = rgb_to_luminance2(cw);\n    \n    // make triangles of each color triplet\n    float dir = safe_sign(l0);\n    vec4 nw = vec4( lw, -ln, 1.0, 0.0);\n    vec4 ne = vec4(-le, -ln, 1.0, 0.0);\n    vec4 sw = vec4( lw,  ls, 1.0, 0.0);\n    vec4 se = vec4(-le,  ls, 1.0, 0.0);\n    \n    // extract luminance vectors\n    vec4 lookupDirs = mat4(nw, ne, sw, se) * vec4(1.0);\n    \n    // luminance intensity modulation\n    lookupDirs = smoothstep(vec4(-dir), vec4(dir), lookupDirs) * 2.0 - 1.0;\n    \n    // Extract edges\n    vec4  n = normalize(lookupDirs);\n    vec4  ld = vec4(0.0, 0.0, -dir, 0.0);\n    float d  = dot(ld, n) * 0.5 + 0.5;\n    float m  = imix(0.0, LUMINANCE_CUTOFF, d);\n    return m * vec4(0.0, 1.0, 0.0, 1.0);\n}\n\n\n\n/*--------------------------------------\n Main\n--------------------------------------*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n#if 0\n    fragCoord = (fragCoord/2.0) + (iResolution.xy / 4.0);\n#endif\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Show results, with comparison against the original texture.\n    vec4 srcImage = texture(iChannel0, uv);\n    vec4 dstImage = upscale_image(fragCoord, iResolution.xy, iChannel0);\n    \n    fragColor = show_diff(fragCoord, iMouse, iTime, iResolution, srcImage, dstImage);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/*--------------------------------------\n Helper function to diff images\n--------------------------------------*/\nvec4 show_diff(\n    in vec2 fragCoord,\n    in vec4 iMouse,\n    in float iTime,\n    in vec3 iResolution,\n    in vec4 color0,\n    in vec4 color1)\n{\n    vec4 result;\n    const float dilation = 10.0;\n    float modulation;\n    float cursor;\n    \n    if (sign(iMouse.z) > 0.0)\n    {\n        modulation = step(fragCoord.x, iMouse.x);\n        cursor = iMouse.x;\n    }\n    else\n    {\n        float timedMod = cos(fract(iTime / dilation) * 3.14159265 * 2.0);\n        float t = timedMod * 0.5 + 0.5;\n        modulation = step(fragCoord.x/iResolution.x, t);\n        cursor = iResolution.x * t;\n    }\n    \n    float line = fragCoord.x - cursor;\n    if (line > 0.0 && line <= 1.0)\n    {\n        result = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    else\n    {\n        result = mix(color1, color0, modulation);\n    }\n    \n    return result;\n}","name":"Common","description":"","type":"common"}]}