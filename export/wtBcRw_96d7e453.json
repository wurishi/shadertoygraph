{"ver":"0.1","info":{"id":"wtBcRw","date":"1593954370","viewed":299,"name":"screenyyy vidscreen 2","username":"Carandiru","description":"modified excerpts, fooling around, got shader!","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// - carandiru\n// http://bit.ly/supersinfulsilicon\n\n// original shader - https://www.shadertoy.com/view/3lByRm (modified)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Define the bluring radius/strength (direction independant)\n    vec2 radius = vec2(30);\n    // Calculate the value at the corners so that the matrix can be easily inverted\n    float maxi = radius.x*radius.y;\n    // Define the variable which will hold the blured values\n    vec3 blur = vec3(0.0);\n\n    // Define the variable which will be used to normalize the image\n    float sum = 0.0;\n    // The kernel is dynamically created based on the bluring radius\n        for(float v = -radius.y; v<=radius.y; v++){\n            // The pixel weight used by the kernel is defined as: the distance from the kernel origin (0,0)\n            // to the current kernel position, subtracted from the maximum possible distance. This leads\n            // to a gradient from 0% relative weight on the edges to 100% relative weight at the origin of the kernel\n            float weight = abs(maxi - radius.x*v);\n            // The weight is then exponentialized which seams to sleightly maintain more of the origianl detail\n            //weight = pow(weight, 2.0);\n            // The weight is then multiplied by the texture being sampled and added to the overall blurred values\n            vec2 new_uv = uv + vec2(radius.x, v)/iResolution.xy;\n            blur += weight * mix( texture( iChannel0, new_uv ).rgb, texture( iChannel1, new_uv ).rgb, 0.5f );\n              \n            \n            // The weight is then added for normalizing purposes\n            sum += weight;\n        }\n\n    // Finally the blurred image is normalized\n    blur /= sum;\n\n    // Output to screen\n    fragColor = vec4(blur + mix(blur, texture( iChannel1, uv ).rgb, pow(1.0f - blur.b * blur.r, 6.05f)), 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// original shader - https://www.shadertoy.com/view/ttsyDs (modified)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float uv_color =  myRandomColor(uv.yy + trunct(tT, 4.0), 4.0);\n    \n    float uv_offset = trunct(tT, 24.0 * uv_color) * 6.;\n    \n    float blockLine_random = 0.5 * myRandomColor(uv.yy + uv_offset, 6.0);\n    blockLine_random += 0.5 * myRandomColor(uv.yy + uv_offset, 10.0);\n    blockLine_random = blockLine_random * 2. - 1.0;\n    \n    blockLine_random = pow(blockLine_random, uv.y);\n    \n    float f = fwidth(blockLine_random);\n    \n    vec3 sharp;\n    sharp.r = smoothstep(0.5f - f, 0.5f + f, blockLine_random);\n    sharp.r = smoothstep(0.0125f - f, 0.75 - f, blockLine_random * sharp.r * 0.5f);\n    \n    sharp.b = 1.0f / pow(blockLine_random * 0.5f + 0.5f, 0.5f);\n    \n    sharp -= texture(iChannel0, uv).rgb * 0.25f;\n sharp.g = pow( smoothstep(uv.y - f, 1.0f, uv.y + fract(iTime)) * 0.7f, 5.0f);\n    \n    fragColor = vec4(matrix(sharp, uv, tT), 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// original shader - https://www.shadertoy.com/view/ttsyDs (modified)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float uv_color =  myRandomColor(uv.yy + trunct(tT, 4.0), 4.0);\n    \n    //try 1.0 and 2.0\n    // 1.0 only time Related\n    // 2.0 both time and uv coord Related\n    \n    //1.0\n    //float uv_offset = random1D(iTime * 0.01) * 0.1;\n    //2.0\n    float uv_offset = trunct(tHT + 0.5f, 2.0 * uv_color) * 4.;\n    \n    //生成随机非均匀宽度线条\n    float blockLine_random = 0.5 * myRandomColor(uv.yy + uv_offset, 6.0);\n    blockLine_random += 0.5 * myRandomColor(uv.yy + uv_offset, 10.0);\n    blockLine_random = blockLine_random * 2. - 1.0;\n    \n    fragColor = vec4(matrix(vec3(blockLine_random,0,blockLine_random * 2.0f), uv, tT), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define tT (iTime*0.5f)\n#define tHT (tT*0.5f)\n\nfloat trunct(float x, float num_levels)\n{\n    return floor(x * num_levels) / num_levels;\n}\n\nfloat randomNoise(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat myRandomColor(vec2 uv, float scale){\n\treturn fract(sin(dot(floor(uv * scale), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat random1D(float p){\n\treturn fract(sin(p) * 100000.0);\n}\n\nfloat random(in float x){\n    return random1D(x);\n}\n\nfloat random(in vec2 st){\n    return randomNoise(st);\n}\n\n// https://www.shadertoy.com/view/MlfXzN (modified)\nvec3 matrix(in vec3 color, in vec2 st, float t){\n    float rows = 28.0;\n    vec2 ipos = floor(st*rows)+vec2(1.,0.);\n\n    ipos += vec2(.0,floor(t*20.*random(ipos.x)));\n\n    vec2 fpos = fract(st*rows);\n    vec2 center = (.5-fpos);\n\n    float pct = random(ipos);\n    float glow = (1.-dot(center,center)*3.)*2.0;\n\n    return color * vec3(random(ipos) * pct * glow);\n}","name":"Common","description":"","type":"common"}]}