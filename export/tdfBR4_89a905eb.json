{"ver":"0.1","info":{"id":"tdfBR4","date":"1588958060","viewed":169,"name":"The Very Hungry Caterpillar","username":"sharond106","description":"The very hungry caterpillar in 3D!\nAll sdf functions are from iq's blog: https://iquilezles.org/articles/distfunctions/distfunctions.htm","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","noise","csg","bee","apple","caterpillar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float[] kernel = float[](0.010989, 0.011474,   0.011833,   0.012054,\t0.012129,   0.012054,\t0.011833,   0.011474,\t0.010989,\n                  0.011474, 0.01198,\t0.012355,   0.012586,\t0.012664,   0.012586,\t0.012355,   0.01198,\t0.011474,\n                  0.011833, 0.012355,\t0.012742,   0.01298,\t0.01306,    0.01298,\t0.012742,   0.012355,\t0.011833,\n                  0.01205,  0.012586,\t0.01298,    0.013222,\t0.013304,   0.013222,\t0.01298,    0.012586,\t0.012054,\n                  0.012129, 0.012664,\t0.01306,    0.013304,\t0.013386,   0.013304,\t0.01306,    0.012664,\t0.012129,\n                  0.012054, 0.012586,\t0.01298,    0.013222,\t0.013304,   0.013222,\t0.01298,    0.012586,\t0.012054,\n                  0.011833, 0.012355,\t0.012742,   0.01298,\t0.01306,    0.01298,\t0.012742,   0.012355,\t0.011833,\n                  0.011474, 0.01198,\t0.012355,   0.012586,\t0.012664,   0.012586,\t0.012355,   0.01198,\t0.011474,\n                  0.010989, 0.011474,\t0.011833,   0.012054,\t0.012129,   0.012054,\t0.011833,   0.011474,\t0.010989);\n        \n    float x = fragCoord.x - 4.;\n    float y = fragCoord.y - 4.;\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            vec2 pos = vec2(x, y);\n            vec2 uv = vec2(pos.x / iResolution.x, pos.y / iResolution.y);\n            vec4 textureColor = texture(iChannel0, uv);\n            vec4 weight = textureColor * kernel[i + j];\n            c += weight;\n            x++;\n        }\n        y++;\n        x = fragCoord.x - 4.;\n    }\n\n    vec4 blurColor = vec4(c.rgb, 1.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 unblurredColor = texture(iChannel0, uv);\n    \n    fragColor = vec4(mix(unblurredColor.rgb, blurColor.rgb, unblurredColor.a), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float FOVY = 0.25 * 3.141569;\nconst int RAY_STEPS = 256;\n\n#define FLOOR_SDF sdfBox(pos + vec3(0, 5.2, -20.0), vec3(100.0, 1.0, 100.0))\n#define FLOOR_ID 28\n\n// caterpillar head (body in sceneMap3D)\n#define HEAD_SDF sdfEllipsoid(pos - vec3(-4.6, -0.9, 15), vec3(1.5, 2.2, 1.5))\n#define HEAD_ID 0\n#define LEFT_EYE_SDF sdfEllipsoid(pos - vec3(-4.2, -0.3, 14), vec3(0.5, .8, .8))\n#define LEFT_EYE_ID 21\n#define RIGHT_EYE_SDF sdfEllipsoid(pos - vec3(-5, -0.3, 14), vec3(0.5, .8 ,.8))\n#define RIGHT_EYE_ID 22\n#define LEFT_EYEBALL_SDF sdfEllipsoid(pos - vec3(-4.2, -0.2, 13.8),vec3(0.3, .6, .8))\n#define LEFT_EYEBALL_ID 23\n#define RIGHT_EYEBALL_SDF sdfEllipsoid(pos - vec3(-5, -0.2, 13.8),vec3(0.3, .6, .8))\n#define RIGHT_EYEBALL_ID 24\n#define LEFT_EAR_SDF sdfRoundCone(pos, .1, .3, 2., LEFT_EAR_T)\n#define LEFT_EAR_ID 25\n#define LEFT_EAR_T inverseTransform(vec3(-4.3, 1, 15), vec3(0, 0, -15. * (cos(iTime)+ .5)), vec3(1))\n#define RIGHT_EAR_SDF sdfRoundCone(pos, .1, .3, 2., RIGHT_EAR_T)\n#define RIGHT_EAR_ID 26\n#define RIGHT_EAR_T inverseTransform(vec3(-4.7, 1, 15), vec3(-15. * (sin(iTime)+ .5), 0 , 20), vec3(1))\n#define MOUTH_SDF sdfEllipsoid(pos - vec3(-4.6, -1, 14), vec3(0.3, .3, 1))\n#define MOUTH_ID 27\n\n// apple shape and stem\n#define APPLE_SDF sdfRoundCone(pos, 2.8, 3.2, .6, APPLE_T)\n#define APPLE_T inverseTransform(vec3(-14, 0, 15), vec3(0), vec3(1.5, 1.8, 1.5))\n#define APPLE_SPHERE_SDF sdfSphere(pos, APPLE_SPHERE_T)\n#define APPLE_SPHERE_T inverseTransform(vec3(-14, -3, 15), vec3(0), vec3(8))\n#define APPLE_INTER_SDF sdfSmoothIntersection(APPLE_SDF, APPLE_SPHERE_SDF, 0.5)\n#define APPLE_TOP_SDF sdfEllipsoid(pos - vec3(-14, 5, 15), vec3(1))\n#define APPLE_FULL_SDF sdfSmoothSubtraction(APPLE_TOP_SDF, APPLE_INTER_SDF, 1.5)\n#define APPLE_STEM_SDF sdfRoundCone(pos, .15, .4, 2.5, APPLE_STEM_T)\n#define APPLE_STEM_ID 30\n#define APPLE_STEM_T inverseTransform(vec3(-15, 6.5, 17), vec3(0, 0, 15), vec3(1.3))\n\n// 2 smoothblend bites\n#define BITE1_SDF sdfVerticalCapsule(pos, 8., .7, BITE1_T)\n#define BITE1_T inverseTransform(vec3(-9, 2.5, 18), vec3(-80, 0, 0), vec3(1.5, 1,1))\n#define BITE2_SDF sdfVerticalCapsule(pos, 8., .7, BITE2_T)\n#define BITE2_T inverseTransform(vec3(-9.2, 1.3, 18), vec3(-80, 0, 0), vec3(2, 1, 1))\n#define BITES1_SDF sdfSmoothBlend(pos, BITE1_SDF, BITE2_SDF, 0.8)\n#define BITE3_SDF sdfVerticalCapsule(pos, 8., .7, BITE3_T)\n#define BITE3_T inverseTransform(vec3(-9.2, .3, 18), vec3(-90, 0, 0), vec3(1.5, 1, 1))\n#define BITE4_SDF sdfVerticalCapsule(pos, 8., .7, BITE4_T)\n#define BITE4_T inverseTransform(vec3(-9.2, .9, 18), vec3(-85, 0, 0), vec3(2, 1, 1))\n#define BITES2_SDF sdfSmoothBlend(pos, BITE3_SDF, BITE4_SDF, 0.3)\n\n// subtract bites to form final apple shape\n#define APPLE_BITE0_SDF sdfSmoothSubtraction(BITES1_SDF, APPLE_FULL_SDF, .05)\n#define APPLE_BITE_SDF sdfSmoothSubtraction(BITES2_SDF, APPLE_BITE0_SDF, .05)\n#define APPLE_FINAL_SDF sdfApple(pos)\n#define APPLE_BITE_ID 29\n\n//caterpillar feet\n#define FEET_ID 31\n\n#define FOOT1_SDF sdfRoundCone(pos, .2, .3, .5, FOOT1_T)\n#define FOOT1_T inverseTransform(vec3(-3.3, -3.8, 15), vec3(0, 0, 90), vec3(1))\n#define LEG1_SDF sdfEllipsoid(pos - vec3(-3.3, -3.4, 15), vec3(.2, .8, .2))\n#define FEET1_SDF sdfSmoothBlend(pos, FOOT1_SDF, LEG1_SDF, .3)\n\n#define FOOT2_SDF sdfRoundCone(pos, .2, .3, .5, FOOT2_T)\n#define FOOT2_T inverseTransform(vec3(-2, -3.8, 15), vec3(0, 0, 90), vec3(1))\n#define LEG2_SDF sdfEllipsoid(pos - vec3(-2, -3.4, 15), vec3(.2, .8, .2))\n#define FEET2_SDF sdfSmoothBlend(pos, FOOT2_SDF, LEG2_SDF, .3)\n\n#define FOOT3_SDF sdfRoundCone(pos, .2, .3, .5, FOOT3_T)\n#define FOOT3_T inverseTransform(vec3(-.8, -3.4, 15), vec3(0, 0, 110), vec3(1))\n#define LEG3_SDF sdfEllipsoid(pos - vec3(-.9, -2.8, 15), vec3(.2, .8, .2), inverseRotateZ(20.))\n#define FEET3_SDF sdfSmoothBlend(pos, FOOT3_SDF, LEG3_SDF, .3)\n\n#define FOOT4_SDF sdfRoundCone(pos, .2, .3, .5, FOOT4_T)\n#define FOOT4_T inverseTransform(vec3(.4, -2.8, 15), vec3(0, 0, 130), vec3(1))\n#define LEG4_SDF sdfEllipsoid(pos - vec3(0, -2.1, 15), vec3(.2, .8, .2), inverseRotateZ(40.))\n#define FEET4_SDF sdfSmoothBlend(pos, FOOT4_SDF, LEG4_SDF, .3)\n\n#define FOOT5_SDF sdfRoundCone(pos, .2, .3, .5, FOOT5_T)\n#define FOOT5_T inverseTransform(vec3(8.6, -3.5, 15), vec3(0, 0, 70), vec3(1))\n#define LEG5_SDF sdfEllipsoid(pos - vec3(8.7, -3, 15), vec3(.2, .8, .2), inverseRotateZ(-10.))\n#define FEET5_SDF sdfSmoothBlend(pos, FOOT5_SDF, LEG5_SDF, .3)\n\n#define FOOT6_SDF sdfRoundCone(pos, .2, .3, .5, FOOT6_T)\n#define FOOT6_T inverseTransform(vec3(10, -3.7, 15), vec3(0, 0, 90), vec3(1))\n#define LEG6_SDF sdfEllipsoid(pos - vec3(10, -3.4, 15), vec3(.2, .8, .2))\n#define FEET6_SDF sdfSmoothBlend(pos, FOOT6_SDF, LEG6_SDF, .3)\n\n// bee\n#define BEE_SDF sdfEllipsoid(pos - vec3(bee_pos, 9. + 2. * cos(.2 * bee_pos) * sin(.1*iTime), 24), vec3(1.1, 1, 1))\n#define BEE_ID 32\n#define bee_pos mix(-15., 20., tan(.3*iTime))\n#define BEE_T inverseTransform(vec3(bee_pos, 9. + 2. * cos(.2 * bee_pos) * sin(.1*iTime), 24), vec3(0), vec3(1.1, 1, 1))\n#define BEE_EYE_SDF sdfEllipsoid(pos -vec3(.6 + bee_pos, 9.2 + 2. * cos(.2 * bee_pos) * sin(.1*iTime), 23.3),vec3(.2))\n#define BEE_EYE_ID 33\n#define BEE_UNION_SDF sdfUnion(BEE_SDF, BEE_EYE_SDF, BEE_ID, BEE_EYE_ID, objectHit)\n#define BEE_WING1_SDF sdfCylinder(pos, vec2(.5, .01), BEE_WING1_T)\n#define BEE_WING_ID 35\n#define wing mix(25., 80., (cos(7. * iTime) + 1.)/2.)\n#define BEE_WING1_T inverseTransform(vec3(-.2 + bee_pos, 10.2 + 2. * cos(.2 * bee_pos) * sin(.1*iTime), 23.5), vec3(wing, 0, 0), vec3(1, 1, 1.5))\n#define BEE_WING2_SDF sdfCylinder(pos, vec2(.5, .01), BEE_WING2_T)\n#define wing2 mix(160., 90., (cos(7. * iTime) + 1.)/2.)\n#define BEE_WING2_T inverseTransform(vec3(-.2 + bee_pos, 10.2 + 2. * cos(.2 * bee_pos) * sin(.1*iTime), 24.5), vec3(wing2, 0, 0), vec3(1, 1, 1.5))\n#define BEE_STINGER_SDF sdfCappedCone(pos-vec3(-1.3 + bee_pos, 9.1 + 2. * cos(.2 * bee_pos) * sin(.1*iTime), 24.5), .01, .2, .5, inverseRotateZ(-90.))\n#define BEE_STINGER_ID 36\n\n//bounding box for apple\n#define TEST_APPLE_SDF sdfBox(pos + vec3(15, -3, -17), vec3(5.5))\n\n// bounding boxes for catepillar body\n#define TEST_BACK_SDF sdfBox(pos + vec3(-7, -.8, -14.5), vec3(4.5, 4.2, 1))\n#define TEST_FRONT_SDF sdfBox(pos + vec3(0, -.8, -14.5), vec3(3.6, 4.5, 1.))\n#define TEST_HEAD_SDF sdfBox(pos + vec3(4.5, -1, -14.5), vec3(1.2, 3, 1.5))\n\n//bounding box for bee\n#define TEST_BEE_SDF sdfBox(pos - vec3(bee_pos - .25, 9.4 + 2. * cos(.2 * bee_pos) * sin(.1*iTime), 24), vec3(1.5))\n\n//bounding box for grass\n//+y up +z back -x right\n#define TEST_GRASS_SDF sdfBox(pos - vec3(-5, 1.5, 85), vec3(70,5.5,60))\n\n// grass\n#define GRASS_ID 34\n#define GRASS_BOX_SDF sdfBox(sdfRep(pos - vec3(0, 2, 60), vec3(6), vec3(5, 0, 5)), vec3(1, 6, .2))\n#define GRASS_ELLIPSE1_SDF sdfEllipsoid(sdfRep(pos - vec3(1.5, -1.7, 60), vec3(6), vec3(5, 0, 5)), vec3(2.5,9,4))\n#define GRASS1_SDF sdfIntersection(GRASS_BOX_SDF, GRASS_ELLIPSE1_SDF)\n#define GRASS_ELLIPSE2_SDF sdfEllipsoid(sdfRep(pos - vec3(2, 1, 60), vec3(6), vec3(5, 0, 5)),  vec3(2,9,4))\n#define GRASS2_SDF sdfSubtraction(GRASS_ELLIPSE2_SDF, GRASS1_SDF)\n\n#define GRASS_BOX2_SDF sdfBox(sdfRep(pos - vec3(4.3, 1.6, 70), vec3(8), vec3(5, 0, 5)), vec3(1, 6, .2))\n#define GRASS_ELLIPSE3_SDF sdfEllipsoid(sdfRep(pos - vec3(5.7, -1.4, 70), vec3(8), vec3(5, 0, 5)), vec3(2.5,9,4))\n#define GRASS3_SDF sdfIntersection(GRASS_BOX2_SDF, GRASS_ELLIPSE3_SDF)\n#define GRASS_ELLIPSE4_SDF sdfEllipsoid(sdfRep(pos - vec3(6.2, 0.7, 70), vec3(8), vec3(5, 0, 5)),  vec3(2,9,4))\n#define GRASS4_SDF sdfSubtraction(GRASS_ELLIPSE4_SDF, GRASS3_SDF)\n\n#define GRASS_BOX3_SDF sdfBox(sdfRep(pos - vec3(2, 2, 85), vec3(10), vec3(7, 0, 5)), vec3(1, 6, .2))\n#define GRASS_ELLIPSE5_SDF sdfEllipsoid(sdfRep(pos - vec3(.5, -1.7, 85), vec3(10), vec3(7, 0, 5)), vec3(2.5,9,4))\n#define GRASS5_SDF sdfIntersection(GRASS_BOX3_SDF, GRASS_ELLIPSE5_SDF)\n#define GRASS_ELLIPSE6_SDF sdfEllipsoid(sdfRep(pos - vec3(0, 1, 85), vec3(10), vec3(7, 0, 5)),  vec3(2,9,4))\n#define GRASS6_SDF sdfSubtraction(GRASS_ELLIPSE6_SDF, GRASS5_SDF)\n\n#define GRASS_BOX4_SDF sdfBox(sdfRep(pos - vec3(2, 2, 90), vec3(12), vec3(7, 0, 5)), vec3(1, 6, .2))\n#define GRASS_ELLIPSE7_SDF sdfEllipsoid(sdfRep(pos - vec3(.5, -1.7, 90), vec3(12), vec3(7, 0, 5)), vec3(2.5,9,4))\n#define GRASS7_SDF sdfIntersection(GRASS_BOX4_SDF, GRASS_ELLIPSE7_SDF)\n#define GRASS_ELLIPSE8_SDF sdfEllipsoid(sdfRep(pos - vec3(0, 1, 90), vec3(12), vec3(7, 0, 5)),  vec3(2,9,4))\n#define GRASS8_SDF sdfSubtraction(GRASS_ELLIPSE8_SDF, GRASS7_SDF)\n\n#define GRASS_BOX5_SDF sdfBox(sdfRep(pos - vec3(5, 2, 70), vec3(7), vec3(5, 0, 5)), vec3(1, 6, .2))\n#define GRASS_ELLIPSE9_SDF sdfEllipsoid(sdfRep(pos - vec3(3.5, -1.7, 70), vec3(7), vec3(5, 0, 5)), vec3(2.5,9,4))\n#define GRASS9_SDF sdfIntersection(GRASS_BOX5_SDF, GRASS_ELLIPSE9_SDF)\n#define GRASS_ELLIPSE10_SDF sdfEllipsoid(sdfRep(pos - vec3(3, 1, 70), vec3(7), vec3(5, 0, 5)),  vec3(2,9,4))\n#define GRASS10_SDF sdfSubtraction(GRASS_ELLIPSE10_SDF, GRASS9_SDF)\n\n#define GRASS_BOX6_SDF sdfBox(sdfRep(pos - vec3(3.5, 2, 85), vec3(8), vec3(7, 0, 5)), vec3(1, 6, .2))\n#define GRASS_ELLIPSE11_SDF sdfEllipsoid(sdfRep(pos - vec3(2, -1.7, 85), vec3(8), vec3(7, 0, 5)), vec3(2.5,9,4))\n#define GRASS11_SDF sdfIntersection(GRASS_BOX6_SDF, GRASS_ELLIPSE11_SDF)\n#define GRASS_ELLIPSE12_SDF sdfEllipsoid(sdfRep(pos - vec3(1.5, 1, 85), vec3(8), vec3(7, 0, 5)),  vec3(2,9,4))\n#define GRASS12_SDF sdfSubtraction(GRASS_ELLIPSE12_SDF, GRASS11_SDF)\n\n#define GRASS_BOX7_SDF sdfBox(sdfRep(pos - vec3(2.5, 2, 52), vec3(5), vec3(5, 0, 5)), vec3(1, 6, .2))\n#define GRASS_ELLIPSE13_SDF sdfEllipsoid(sdfRep(pos - vec3(1, -1.7, 52), vec3(5), vec3(5, 0, 5)), vec3(2.5,9,4))\n#define GRASS13_SDF sdfIntersection(GRASS_BOX7_SDF, GRASS_ELLIPSE13_SDF)\n#define GRASS_ELLIPSE14_SDF sdfEllipsoid(sdfRep(pos - vec3(.5, 1, 52), vec3(5), vec3(5, 0, 5)),  vec3(2,9,4))\n#define GRASS14_SDF sdfSubtraction(GRASS_ELLIPSE14_SDF, GRASS13_SDF)\n\n// can change\n#define RENDER_CATERPILLAR_FRONT 1\n#define RENDER_CATERPILLAR_BACK 1\n#define RENDER_APPLE 1\n#define RENDER_BEE 1\n#define RENDER_GRASS 1\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 inverseTransform(vec3 translate, vec3 rotate, vec3 scale) {\n    mat4 s;\n    // matrices indexed to columns!\n    s[0] = vec4(1./scale.x, 0., 0., 0.);\n    s[1] = vec4(0., 1./scale.y, 0., 0.);\n    s[2] = vec4(0., 0., 1./scale.z, 0.);\n\ts[3] = vec4(0., 0., 0., 1.);                                     \n                                    \n    rotate.x = radians(rotate.x);\n    rotate.y = radians(rotate.y);\n    rotate.z = radians(rotate.z);\n      \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), -sin(rotate.x), 0.);\n    r_x[2] = vec4(0., sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                                                   \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(-sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), -sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n    \n    mat4 t;\n    t[0] = vec4(1., 0., 0., 0.);\n    t[1] = vec4(0., 1., 0., 0.);\n    t[2] = vec4(0., 0., 1., 0.);\n    t[3] = vec4(-translate.x, -translate.y, -translate.z, 1.); \n    \n    return s * r_z * r_y * r_x * t;\n}\n\nmat4 inverseRotateZ(float z) {\n    z = radians(z);\n    mat4 r_z;\n    r_z[0] = vec4(cos(z), -sin(z), 0., 0.);\n    r_z[1] = vec4(sin(z), cos(z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n    return r_z;\n}\n\nfloat sdfEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdfEllipsoid( vec3 p, vec3 r, mat4 t )\n{\n  p = vec3(t * vec4(p, 1));\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdfBox(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nvec3 sdfRep(vec3 p, vec3 grid, vec3 l)\n{\n    vec3 c = grid;\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat sdfSphere(vec3 p, mat4 t) {\n    p = vec3(t * vec4(p, 1));\n    return length(p) - 1.;\n}\n\nfloat sdfEye(vec3 p, mat4 t) {\n    p = vec3(t * vec4(p, 1));\n    if (p.y < (2. - 2.*(sin(4.*iTime) + 1.))){\n    \treturn length(p) - 1.;\n    }\n    else \n        return 34134.2;\n}\n\nfloat sdfRoundCone( vec3 p, float r1, float r2, float h, mat4 t){\n  p = vec3(t * vec4(p, 1));\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdfCylinder( vec3 p, vec2 h, mat4 t )\n{\n  p = vec3(t * vec4(p, 1));\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdfCappedCone( vec3 p, float r1, float r2, float h,  mat4 t )\n{\n  p = vec3(t * vec4(p, 1));\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdfVerticalCapsule( vec3 p, float h, float r, mat4 t )\n{\n  p = vec3(t * vec4(p, 1));\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdfSmoothBlend(vec3 p, float sdf1, float sdf2, float k) {\n    float h = max(k - abs(sdf1 - sdf2), 0.f) / k;\n    float sdf = min(sdf1, sdf2) - h * h * k * (.25f);\n    return sdf;\n}\n\nfloat sdfSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdfIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdfSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdfSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdfUnion(float d1, float d2, int d1_id, int d2_id ,out int objectHit) {\n    if (d1 < d2) {\n        objectHit = d1_id;\n        return d1;\n    }\n    objectHit = d2_id;\n    return d2;\n}\n\nmat4 appleTransform = mat4(1.0);\nconst mat4 appleScale = mat4(.7, 0, 0, 0,\n                             0, .7, 0, 0,\n                             0, 0, .7, 0,\n                             0, 0, 0, 1);\nfloat sdfApple(vec3 pos)\n{\n    appleTransform[3] = vec4(-3., -1., 2., 1.); \n\n    pos = vec3(appleScale * vec4(pos, 1.));\n    pos = vec3(appleTransform * vec4(pos, 1.));\n    return APPLE_BITE_SDF;\n}\n\n// positions and rotations for 20 body pieces\nconst vec3[] offset = vec3[](vec3(0, -0.2, 0), vec3(0, -.2, 0), vec3(0, 0.4, 0), vec3(-0.4, 0.6, 0), vec3(-1, 0.8, 0),\n                       vec3(-1.6, 1, 0), vec3(-2, 1, 0), vec3(-2, .8, 0), vec3(-2, .6, 0), vec3(-2, 0.2, 0),\n                       vec3(-2, 0, 0), vec3(-2, -.7, 0), vec3(-2.5, -1.5, 0), vec3(-3, -2.3, 0), vec3(-3.5, -2.9, 0),\n                       vec3(-4, -3, 0), vec3(-4, -2.8, 0), vec3(-4, -2.5, 0), vec3(-4.2, -1.5, 0), vec3(-4.5, -.2, 0));\nconst vec3[] rotate = vec3[](vec3(0, 0, 0), vec3(0, 0, 10), vec3(0, 0, 40), vec3(0, 0, 60), vec3(0, 0, 70),\n                       vec3(0, 0, 60), vec3(0, 0, 45), vec3(0, 0, 20), vec3(0, 0, 10), vec3(0, 0, 0),\n                       vec3(0, 0, -20), vec3(0, 0, -40), vec3(0, 0, -60), vec3(0, 0, -70), vec3(0, 0, -60),\n                       vec3(0, 0, -40), vec3(0, 0, -20), vec3(0, 0, 0), vec3(0, 0, 10), vec3(40, 0, 25));\n\nvoid sceneMap3D(vec3 pos, out float t, out int objectHit) {\n    vec3 center = vec3(-4, 0, 15);\n    center.y = max(4.*sin(.2*center.x), -.6);\n\n    t = FLOOR_SDF;\n    objectHit = FLOOR_ID;\n    float t2;\n    \n    #if RENDER_GRASS\n    if ((t2 = TEST_GRASS_SDF)< t){\n        if ((t2 = GRASS2_SDF) < t) {\n            t = t2;\n            objectHit = GRASS_ID;\n        }\n        if ((t2 = GRASS4_SDF) < t) {\n            t = t2;\n            objectHit = GRASS_ID;\n        }\n        if ((t2 = GRASS6_SDF) < t) {\n            t = t2;\n            objectHit = GRASS_ID;\n        }    \n        if ((t2 = GRASS8_SDF) < t) {\n            t = t2;\n            objectHit = GRASS_ID;\n        }\n        if ((t2 = GRASS10_SDF) < t) {\n            t = t2;\n            objectHit = GRASS_ID;\n        }\n        if ((t2 = GRASS12_SDF) < t) {\n            t = t2;\n            objectHit = GRASS_ID;\n        }\n        if ((t2 = GRASS14_SDF) < t) {\n            t = t2;\n            objectHit = GRASS_ID;\n        }\n    }\n    #endif\n    \n    #if RENDER_APPLE\n    if ((t2 = TEST_APPLE_SDF) < t) {\n        if ((t2 = APPLE_FINAL_SDF) < t) {\n            t = t2;\n            objectHit = APPLE_BITE_ID;\n        }\n    }\n    if ((t2 = APPLE_STEM_SDF) < t) {\n        t = t2;\n        objectHit = APPLE_STEM_ID;\n    }\n    #endif\n    \n    #if RENDER_BEE\n    if ((t2 = TEST_BEE_SDF) < t) {\n        if ((t2 = BEE_SDF) < t) {\n            t = t2;\n            objectHit = BEE_ID;\n        }\n        if ((t2 = BEE_EYE_SDF) < t) {\n            t = t2;\n            objectHit = BEE_EYE_ID;\n        }\n        if ((t2 = BEE_WING1_SDF) < t) {\n            t = t2;\n            objectHit = BEE_WING_ID;\n        }\n        if ((t2 = BEE_WING2_SDF) < t) {\n            t = t2;\n            objectHit = BEE_WING_ID;\n        }\n        if ((t2 = BEE_STINGER_SDF) < t) {\n            t = t2;\n            objectHit = BEE_STINGER_ID;\n        }\n    }\n    #endif\n    \n    #if RENDER_CATERPILLAR_BACK\n    if ((t2 = TEST_BACK_SDF) < t) {\n        center.x += 8.;\n        for (int i = 8; i < 20; i++) {\n            center.x += 1.;\n            center.y = max(4.*sin(.2*center.x), -.6);\n            vec3 scale = vec3(1, 2, 1);\n            if (i == 16) \n                scale = vec3(1, 1.8, 1);\n            else if (i == 17) \n                scale = vec3(.8, 1.5, 1);\n            else if (i == 18)\n                scale = vec3(.7, 1, 1);\n            else if (i == 19)\n                scale = vec3(.6, .8, .8);\n            if ((t2 = sdfEllipsoid(pos - (center + offset[i]), scale, inverseRotateZ(float(rotate[i].z)))) < t) {\n                t = t2; \n                objectHit = i + 1;\n            }\n    \t}\n        if ((t2 = FEET5_SDF) < t) {\n            t = t2;\n            objectHit = FEET_ID;\n        } \n        if ((t2 = FEET6_SDF) < t) {\n            t = t2;\n            objectHit = FEET_ID;\n        }\n    }\n    #endif\n    \n    #if RENDER_CATERPILLAR_FRONT\n    if ((t2 = TEST_FRONT_SDF) < t) {\n        center = vec3(-4, 0, 15);\n        for (int i = 0; i < 9; i++) {\n            center.x += 1.;\n            center.y = max(4.*sin(.2*center.x), -.6);\n            vec3 scale = vec3(1, 2, 1);\n            if (i == 16) \n                scale = vec3(1, 1.8, 1);\n            else if (i == 17) \n                scale = vec3(.8, 1.5, 1);\n            else if (i == 18)\n                scale = vec3(.7, 1, 1);\n            else if (i == 19)\n                scale = vec3(.6, .8, .8);\n            if ((t2 = sdfEllipsoid(pos - (center + offset[i]), scale, inverseRotateZ(float(rotate[i].z)))) < t) {\n                t = t2; \n                objectHit = i + 1;\n            }\n    \t}\n        if ((t2 = FEET1_SDF) < t) {\n            t = t2;\n            objectHit = FEET_ID;\n        } \n        if ((t2 = FEET2_SDF) < t) {\n            t = t2;\n            objectHit = FEET_ID;\n        } \n        if ((t2 = FEET3_SDF) < t) {\n            t = t2;\n            objectHit = FEET_ID;\n        } \n        if ((t2 = FEET4_SDF) < t) {\n            t = t2;\n            objectHit = FEET_ID;\n        }\n    }\n    if ((t2 = TEST_HEAD_SDF) < t) {\n        if ((t2 = HEAD_SDF) < t) {\n            t = t2;\n            objectHit = HEAD_ID;\n        }\n        if ((t2 = LEFT_EYEBALL_SDF) < t) {\n            t = t2;\n            objectHit = LEFT_EYEBALL_ID;\n        }\n        if ((t2 = RIGHT_EYEBALL_SDF) < t) {\n            t = t2;\n            objectHit = RIGHT_EYEBALL_ID;\n        }\n        if ((t2 = LEFT_EYE_SDF) < t) {\n            t = t2;\n            objectHit = LEFT_EYE_ID;\n        }\n        if ((t2 = RIGHT_EYE_SDF) < t) {\n            t = t2;\n            objectHit = RIGHT_EYE_ID;\n        }       \n        if ((t2 = LEFT_EAR_SDF) < t) {\n            t = t2;\n            objectHit = LEFT_EAR_ID;\n        }\n        if ((t2 = RIGHT_EAR_SDF) < t) {\n            t = t2;\n            objectHit = RIGHT_EAR_ID;\n        }\n        if ((t2 = MOUTH_SDF) < t) {\n            t = t2;\n            objectHit = MOUTH_ID;\n        } \n    }\n    #endif\n}\n\n// called by computeNormal\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objectHit) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; i++) {\n        vec3 pos = origin + t * dir;\n        float min;\n        sceneMap3D(pos, min, objectHit);\n        if (min < 0.001) {\n            return;\n        }\n        t += min;\n    }\n    t = -1.;\n    objectHit = -1;\n}\n\n// https://iquilezles.org/articles/normalsSDF\n// prevents compiler from inlining the 4 calls to sceneMap3D by making the loop rely on a variable\nvec3 computeNormal(vec3 p) {\n    vec3 n = vec3(0.0);\n    float eps = .001;\n    for( int i=(min(iFrame,0)); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneMap3D(p+eps*e);\n    }\n    return normalize(n);\n}\n\nconst float[] randomFloats = float[](22.71, 33.99, 41.2, 12., 143.,\n    \t\t\t\t\t\t\t\t52.3, 21., 31., 43., 13.423,\n    \t\t\t\t\t\t\t\t23., 33.123, 22.54, 11.1, 21.41,\n    \t\t\t\t\t\t\t\t6.856, 45.2, 4.12, 23.56, 22.3);\nfloat noise2D( vec2 p , int i) {\n    float random = randomFloats[i];\n    if (i == APPLE_BITE_ID)\n        random = .5 * 3.9;\n    return fract(sin(dot(p, vec2(127.1, 311.7))) *\n                  45964.03 / (4372. * (cos(random) + 3.) / 2.));\n}\nfloat interpNoise2D(float x, float y, int i) {\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY), i);\n    float v2 = noise2D(vec2(intX + 1, intY), i);\n    float v3 = noise2D(vec2(intX, intY + 1), i);\n    float v4 = noise2D(vec2(intX + 1, intY + 1), i);\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\nfloat fbm(float x, float y, int index) {\n    float total = 0.;\n    float persistence = 0.5f;\n    float octaves = 4.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(x * freq,\n                               y * freq, index) * amp;\n    }\n    return total;\n}\n\nvec2 random2 (vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                          dot(p, vec2(269.5, 183.3))))\n                 * 43758.5433);\n}\nfloat WorleyNoise(vec2 uv) {\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n\n    if ( length(random2(uvInt) - uvFract) < .05)\n        return 1.;\n        \n    return 0.;\n}\n\nvec3 computeMaterial(int objectHit, vec3 p, vec3 n, vec3 lightDir, vec3 view) {\n    lightDir = normalize(lightDir - p);\n    \n    float lambert = dot(n, lightDir);\n    \n    vec3 H = (view + lightDir) / .2;\n    float blinn = pow(max(dot(normalize(H), n), 0.f), 6.f);\n    blinn = max(pow(dot(normalize(H), n), 30.), 0.);\n    \n    vec3 color = vec3(lambert) * 1.25;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n    // start of body position\n    vec3 center = vec3(-4, 0, 15);\n    center.y = max(4.*sin(.2*center.x), -.6);\n\n    \n    if (objectHit == LEFT_EYE_ID || objectHit == RIGHT_EYE_ID) {\n        if (p.y > (2. - 2.*(sin(4.*iTime) + 1.))){\n            color = vec3(1, .2, .2);\n        } else {\n        \tcolor *= vec3(1, 1, .2);\n        }\n    }\n    else if (objectHit == LEFT_EYEBALL_ID || objectHit == RIGHT_EYEBALL_ID) {\n        if (p.y > (2. - 2.*(sin(4.*iTime) + 1.))){\n            color = vec3(1, .2, .2);\n        } else {\n            color = vec3(.2, .5, .2);\t// no shading on eyeballs\n            color += blinn;\n        }\n    }\n    else if (objectHit == HEAD_ID)               \n        color *= vec3(1, .2, .2);\n    else if (objectHit == BEE_EYE_ID) {\n        color = vec3(0);\t\n        color += blinn;\n    }\n    else if (objectHit == MOUTH_ID) \n        color = vec3(.2, .5, .2);\t// no shading on mouth\n   \telse if (objectHit == LEFT_EAR_ID || objectHit == RIGHT_EAR_ID) \n        color *= vec3(.5, .2, .7);\n    else if (objectHit == APPLE_STEM_ID) \n        color *= vec3(.3, .1, .1);\n    else if (objectHit == FEET_ID) \n        color *= vec3(.3, .1, .3);\n    else if (objectHit == BEE_STINGER_ID) \n        color *= vec3(0);    \n    else if (objectHit == BEE_WING_ID) {\n        color /= lambert;\n        color *= vec3(.7, .9, 1);\n    }\n    else if (objectHit == FLOOR_ID) {\n        float u = dot(vec3(1, 0, 0), p);\n        float v = dot(vec3(0, 0, 1), p);\n        float f = fbm(u * .1, v * .1, objectHit);\n        color *= vec3(.3, .2, .2) * f;\n    }\n    else if (objectHit == GRASS_ID) {\n        float f = fbm(p.x *p.z * .1, p.y * .1, objectHit);\n        color *= vec3(.1, .4, .1) * f;\n    }\n    else if (objectHit == BEE_ID) {\n        p = vec3(BEE_T * vec4(p, 1.));\n        if (p.x > .1 || (p.x > -.3 && p.x < -.1) || (p.x > -.7 && p.x < -.5) || p.x < -.9) {\n            color *= vec3(1,.9,0);\n        }\n        else{\n            color = vec3(0);\n        }\n    }\n    else if (objectHit == APPLE_BITE_ID) {\n        vec3 pos = p;\n        \n        appleTransform[3] = vec4(-3., -1., 2., 1.); \n\n    \tpos = vec3(appleScale * vec4(pos, 1.));\n    \tpos = vec3(appleTransform * vec4(pos, 1.));\n        \n        if (BITES1_SDF < .01 || BITES2_SDF < .01) {\n            color *= vec3(.8, .8, .5);\n        }\n        else {\n            color *= vec3(.8, 0, 0);\n            vec3 n = p;\n            float phi = atan(n.z, n.x);\n            if (phi < 0.) {\n                phi += (2.*3.1415926535897932384626433832795);\n            }\n            float theta = acos(n.y);\n            float u = 1. - phi/(2.*3.1415926535897932384626433832795);\n            float v = 1. - theta/3.1415926535897932384626433832795;\n\n            a = vec3(1.068, -3.522, -1.000);\n            b = vec3(0.608, .9, 0);\n            c = vec3(0.588, .7, 0);\n            d = vec3(3.138, -3.142, -3.142);\n\n            float f = fbm(p.x * .13, p.y * .05, objectHit);\n            color *= a + b * cos(2. * 3.1415926535897932384626433832795 * (f * c  + d));\n            color += (vec3(.5, .3,  0) * WorleyNoise(p.xy) * lambert);\n            color += blinn;\n        }\n    }\n    else if (objectHit >= 1 && objectHit <= 20) {\n        // use formula from sceneMap3D\n        center.x += float(objectHit);\n\n        center.y = max(4.*sin(.2*center.x), -.6);\n        p = vec3(inverseTransform(center + offset[objectHit - 1], rotate[objectHit - 1], vec3(1, 2, 1)) * vec4(p, 1.)); \n\n        vec3 n = p;\n        float phi = atan(n.z, n.x);\n        if (phi < 0.) {\n            phi += (2.*3.1415926535897932384626433832795);\n        }\n        float theta = acos(n.y);\n        float u = 1. - phi/(2.*3.1415926535897932384626433832795);\n        float v = 1. - theta/3.1415926535897932384626433832795;\n               \n        float f = fbm(u * 8., v * 8., objectHit - 1);\n\n        if (objectHit == 2 || objectHit == 5 || objectHit == 2 || objectHit == 9 || objectHit == 14 ||objectHit == 15 ||objectHit == 19) {\n            a = vec3(0.508, 0.368, 0);\n            b = vec3(-0.650, 0.500, 0);\n            c = vec3(0.333, 0.278 , 0);\n            d = vec3(0.660, 0.000, 0);\n        }\n        else if (objectHit == 1||objectHit == 3 ||objectHit == 7 ||objectHit == 8 ||objectHit == 11 ||objectHit == 13 ||objectHit == 17) {\n            a = vec3(-0.052, 0.348, -0.028);\n            b = vec3(-0.772, 0.500, 1.408);\n            c = vec3(0.478, 0.268, 0.028);\n            d = vec3(0.660, 0.000, -1.212);\n        }\n        else {\n            a = vec3(0, 0.308, -0.582);\n            b = vec3(0, 0.500, 1.408);\n            c = vec3(0, 0.388, -0.132);\n            d = vec3(0, 0.000, -2.212);\n        }\n\n        color *= a + b * cos(2. * 3.1415926535897932384626433832795 *\n                            (f * c  + d));\n    }\n    else {\n        color *= vec3(1);\n    }\n    return clamp(color, 0.f, 1.f);\n}\n\nfloat shadow(vec3 dir, vec3 origin, float k, int max_steps) {\n    float res = 1.0;\n    float t = 0.1;\n    for(int i = 0; i < max_steps; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        //res = min(1.0, (k * m / t));\n        t += m;\n    }\n    return res;\n}\n\nIntersection sdf3D(vec3 eye, vec3 dir) {\n    float t;\n    int objectHit;\n    march(eye, dir, t, objectHit);\n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect);\n    \n    vec3 lightPos = vec3(0, 20, -8);\n    \n    vec3 color = vec3(.7, .9, 1);\n    \n    if (objectHit != -1) {\n    \tcolor = computeMaterial(objectHit, isect, nor, lightPos, normalize(eye - isect));\n        \n       \t// don't cast shadow for grass, eyes and mouth on face because they look weird\n        if ((objectHit < 21 || objectHit > 24) && objectHit != MOUTH_ID && objectHit != HEAD_ID && objectHit != GRASS_ID) { \n            color *= shadow(normalize(lightPos - isect), isect, 14.0, int(abs(lightPos - isect)) + 40);\n        }\n    } \n    \n    return Intersection(t, color, isect, objectHit);\n}\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / float(iResolution.y);\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1, 1);\n    \n    vec3 eye = vec3(-2, 11, -9);\n    vec3 ref = vec3(-3, 7, 5);\n    vec3 rayDir = rayCast(eye, ref, uv); \n    \n    Intersection isect = sdf3D(eye, rayDir);\n\n     // Calculate blur value\n    float distFromCam = dot(normalize(ref - eye), isect.p - eye);   \n    float focalLength = 25.;\n    float blur = min(1.0, abs(distFromCam - focalLength) / 15.0);\n\n    fragColor = vec4(isect.color, blur);\n}","name":"Buffer A","description":"","type":"buffer"}]}