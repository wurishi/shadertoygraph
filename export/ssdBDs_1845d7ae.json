{"ver":"0.1","info":{"id":"ssdBDs","date":"1657557717","viewed":81,"name":"Dragon Scales Demo","username":"Wildric","description":"Change parameters to generate shapes that fit you need.\nIf lighting is on, move the mouse on shader window to move the light source","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pattern","scales"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Â© 2022 Wildric Auric\n\n\n//Change macros value to generate the best scales output\n\n//Scales shape parameters\nfloat SHAPE_HORIZONTAL_RADIUS  =0.3;\nfloat SHAPE_VERTICAL_RADIUS = 1.8;\nfloat PATTERN_FREQUENCY = 6.0;\n\n\n//Color Parameters\n#define SCALE_COLOR vec3(1.0,1.0,1.0)\n#define NOISE false\n#define BLACK_BORDER true\n#define COLOR_INTENSITY 1.0\n\n#define RANDOMIZE_COLOR false\n#define colIntensity vec3(1.0,1.0,1.0)\n\n\n\n//Light Parameters\n#define LIGHT false\n#define LIGHT_COLOR vec3(1.0, 1.0, 1.0)\n#define LIGHT_INTENSITY 1.0\n\n\n//Animation parameters\n\n#define ANIMATION true\n#define ANIMATION_SPEED 0.5\n\n\n//OTHER\n\n#define LIGHT_Z_POS 0.05\n\n\n\n\n\n//-----------------------------------------------------------\n\nvec2 originalUV = vec2(0.0);\nbool passed = false;\nvec3 lightPosition = vec3(0.5,0.5,LIGHT_Z_POS);\n\n\n\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv, float freq) {\n    uv *= freq;\n    vec2 fractional = fract(uv);\n    vec2 integer = floor(uv);\n    fractional = fractional*fractional*(3.0-2.0*fractional);\n    vec2 down = vec2( rand(integer), rand(integer + vec2(1.0, 0.0)) );\n    vec2 up = vec2( rand(integer + vec2(0.0,1.0)), rand(integer + vec2(1.0, 1.0)) );\n    float x = mix(down.x, down.y, fractional.x);\n    float y = mix(up.x, up.y, fractional.x);\n    return mix(x,y, fractional.y);\n}\n\n\nvec3 perlin(vec2 uv, float amplitudeMul, float freqMul,float amplitude, float freq)  {\n    vec3 col = vec3(noise(uv, 10.0)*10.0);\n    float total = amplitude;\n    for (int i = 0; i<10; i++) {\n        freq *= freqMul;\n        amplitude *= amplitudeMul;\n        col += vec3(noise(uv, freq)*amplitude);\n        total += amplitude;\n    }\n    col/= total;\n    return col;\n}\n\n\nvec3 CalculateNormal(vec2 coord,float len) {\n    return normalize(\n           vec3(\n                coord.x*0.4,\n                coord.y*0.4,\n                1.0\n                )\n            );\n}\n\n\nvec3 MagicalColorRandomizer(vec2 uv) {\n    vec3 r = perlin(uv, 0.5, 2.0, 100.0, 3.0)*colIntensity.r; //arbitrary values in perlin function to generate \"galatical\" colors\n    vec3 g = perlin(uv+0.1, 0.5, 2.0, 100.0, 3.0)*colIntensity.g;\n    vec3 b = perlin(uv + 0.5, 0.5, 4.0, 100.0, 1.0)*colIntensity.b;\n    float fade = pow(length(perlin(uv-0.1, 0.6, 2.0, 10.,10.0)), 30.0)*4.0;\n    return vec3(length(r),length(g), length(b))/sqrt(3.0);\n\n}\n\n\n\n\nvec3 Lit(vec2 position, vec3 normal) {\n    vec3 dir = normalize(vec3(position.x,position.y, 0.0) - lightPosition);\n    return -LIGHT_INTENSITY*dot(dir, normal) * LIGHT_COLOR;\n    \n}\n\n\n\n\nvec3 ShapePattern(vec2 uv,vec2 center) {\n    uv -= center;\n    vec2 localCoord = (uv + vec2(SHAPE_HORIZONTAL_RADIUS*0.5, 0.0))\n                       /vec2(SHAPE_HORIZONTAL_RADIUS, SHAPE_VERTICAL_RADIUS);\n                   \n    localCoord.y = -localCoord.y;     \n   \n    float f = SHAPE_HORIZONTAL_RADIUS ;//* (2.0 - smoothstep(0.0, .,localCoord.y));\n    float len = pow(uv.x/(f), 2.0) +  pow(uv.y/SHAPE_VERTICAL_RADIUS, 2.0);\n    float offsetu = 0.0;\n    \n    if (  len<= 1.3 + offsetu && uv.y < 0.0) {\n        //Point is inside the shape\n        passed = true;\n\n        vec3 result =  SCALE_COLOR * vec3(smoothstep(0.0,0.15,localCoord.y/2.0));\n        if (RANDOMIZE_COLOR) {\n            result *= MagicalColorRandomizer(originalUV);\n        };\n        if ( NOISE ) result *= 2.0* noise(localCoord, 1.0);\n        if (BLACK_BORDER) {\n                result *= vec3(smoothstep(1.0, 0.0,len/3.0));\n        }\n        if (LIGHT) \n            result *= Lit(originalUV, CalculateNormal(localCoord,len));\n        return result ; \n         \n        \n    }\n    return vec3(0.0,0.0,.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n    PATTERN_FREQUENCY = 6.0 + 0.5*(sin((cos(iTime*ANIMATION_SPEED) - uv.x * uv.y)*2.0)+1.0);\n   \n\n    //PATTERN_FREQUENCY = 6.0 + sin(iTime);\n    originalUV = uv;\n    uv *= float(PATTERN_FREQUENCY);\n\n\tuv.x += 0.05*sin(uv.y*10.0+iTime)/10.0;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    lightPosition.xy = mouse.xy;\n    \n    vec3 col = vec3(0.0);\n   \n   \n    float offset = 0.0;\n    for (int y = 0; y < int(float(PATTERN_FREQUENCY)/(SHAPE_VERTICAL_RADIUS)*2.0)+4; y++) {\n        for (int x = 0; x < int(float(PATTERN_FREQUENCY)/2.0/SHAPE_HORIZONTAL_RADIUS)+3; x++) {\n               if (passed) break;\n               vec2 center = vec2( (2.0*float(x) + offset) * float(SHAPE_HORIZONTAL_RADIUS),\n                                    float(PATTERN_FREQUENCY)+1.0- float(y)*SHAPE_VERTICAL_RADIUS*0.5);\n               col += ShapePattern(uv, center);\n       }\n       offset = 1.0 - offset;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col + 0.15,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"","name":"Common","description":"","type":"common"}]}