{"ver":"0.1","info":{"id":"7tlcRf","date":"1648477285","viewed":217,"name":"Gyroid Crystal","username":"Hyeve","description":"Why'd nobody tell me that these shapes were a thing before?! They're so neat!","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","glass","reflections","gyroid","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DTR 0.01745329\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define fft(f) (1-pow(max(1-texture(texFFTSmoothed,pow(64,f)/425).x*0.1,0),sqrt(f)*20))\n\nvec2 uv;\nvec3 cp,cn,cr,ro,rd,ss,oc,cc,gl,vb;\nvec4 fc;\nfloat tt,cd,sd,io,oa,td,tc;\nint es=0,ec;\n\nfloat gy(vec3 p, vec3 s){return (abs(dot(sin(p*s.x),cos((p*s.y).zxy)))-s.z)/(max(s.x,s.y)*1.8);}\nfloat smin(float a, float b, float k){float h=clamp(0.5+0.5*(b-a)/k,0.,1.);return mix(b,a,h)-k*h*(1.-h);}\n\n\nfloat mp(vec3 p)\n{\n\t\tvec3 pp=p;\n\t\tp.xz*=rot(tt*0.1);\n\t\tp.xy*=rot(tt*0.1);\n\t\t\n\t\tvec3 v=vec3(sin(tt*0.5)*0.2,cos(tt*0.6)*0.2,0);\n\t\tsd = gy(p,vec3(3,3,1.)+v);\t\n\t\tfloat gy2=gy(p,vec3(1.5,1.5,1.3));\n\t\tfloat an=pow(1.-pow(sin(tt*0.7)*0.5+0.5,3.),6.);\n\t\tsd=smin(-sd, abs(length(p) - 2.)-(an+0.1), -0.01);\n\t\tfloat c=length(p)-0.2;sd=min(sd,c);\n\t\tgl+=exp(-sd*0.1)*vec3(0.08);\n\t\tgl+=exp(-c*2.)*vec3(0.1,1.5,0.1)*0.8;\n\t\tsd=abs(sd)-0.001;\n\t\n\n\t\tif(sd<0.001)\n\t\t{\t\n\t\t\tio=gy2<-0.1?1.1:-1.;\n\t\t\toc=io<0.?vec3(0.05,0.05,0.2):vec3(0.1,0.5,0.9);\n\t\t\toa=io<0.?0.6:0.3;\n\t\t\tss=vec3(0);\n\t\t  vb=vec3(0.);\n\t\t\tec=2;\t\n\t\t}\n\t\treturn sd;\n}\n\nvoid tr(){vb.x=0.;cd=0.;for(tc=1.;tc<512.;tc++){mp(ro+rd*cd);cd+=sd;td+=sd;if(sd<0.0001||cd>128.)break;}}\nvoid nm(){mat3 k=mat3(cp,cp,cp)-mat3(.001);cn=normalize(mp(cp)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));}\n\nvec3 nm(vec3 p){mat3 k=mat3(p,p,p)-mat3(.001);return normalize(mp(p)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));}\n\nfloat occlusion(vec3 ro, vec3 rd, float d)\n{\n    float td,ta,md=d; \n    while(td<d){\n    float m=mp(ro+rd*td);td+=m;\n    if(m<md){md=m;ta=td;}\n    if(m<0.0001) break;}\n    vec3 ep=ro+rd*td;\n    float ls=max(mix(dot(nm(ep),-rd),1.-td/d,0.95),0.);\n    float ms=0.005;\n    return ls+(md<ms&&ls<0.1?1.-max(pow(md/ms,2.5),1.-max(1.-ta/d,0.)):0.)*oa; \n}\n\nvoid px()\n{\n  cc=vec3(0.3,0.3,0.6)+length(pow(abs(rd+vec3(0,0.,0)),vec3(3)))*0.3+gl/tc;\n  vec3 l=vec3(0.5,0.3,0.8);\n  if(cd>128.){oa=1.;return;}\n  float df=clamp(length(cn*l),0.,1.);\n  vec3 fr=pow(1.-df,3.)*mix(cc,vec3(0.4),0.5);\n  float sp=(1.-length(cross(cr,cn*l)))*0.2;\n  float ao=min(mp(cp+cn*0.3)-0.3,0.3)*0.4;\n  \n  //NEW OCCLUSION/SHADOWS TESTING\n  vec3 ld = -normalize(cp - vec3(0,2,-5));\n  float occ = occlusion(cp+cn*0.05,ld, 10.);\n  \n \n  cc=mix((oc*(df+fr+ss)+fr+sp+ao+gl/tc),oc,vb.x);\n  \n  cc-=occ*0.4;\n}\n\nvoid render(vec2 frag, vec2 res, float time, out vec4 col)\n{\n\t\n  uv=vec2(frag.x/res.x,frag.y/res.y);\n  uv-=0.5;uv/=vec2(res.y/res.x,1);\n  ro=vec3(0,0,-5);rd=normalize(vec3(uv,1));\n\ttt=mod(time, 260.);\n  \n\tfor(int i=0;i<25;i++)\n  {\n\t\ttr();cp=ro+rd*cd;nm();ro=cp-cn*(io<0.?-0.01:0.01);\n\t\tcr=refract(rd,cn,i%2==0?1./io:io);i=io<0.?i+1:i;\n    if((length(cr)==0.&&es<=0)||io<0.){cr=reflect(rd,cn);es=(io<0.?es:ec);}\n    if(max(es,0)%3==0&&cd<128.)rd=cr;es--;\n\t\tif(vb.x>0.&&i%2==1)oa=pow(clamp(cd/vb.y,0.,1.),vb.z);\n\t\tpx();fc=fc+vec4(cc*oa,oa)*(1.-fc.a);if((fc.a>=1.||cd>128.))break;\n  }\n  col = fc/fc.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    render(fragCoord.xy,iResolution.xy,iTime,fragColor);\n}","name":"Image","description":"","type":"image"}]}