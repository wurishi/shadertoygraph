{"ver":"0.1","info":{"id":"XddBRl","date":"1526366341","viewed":278,"name":"GPU_gems_simple_diffraction","username":"PGrad","description":"Credit for the diffraction and anisotropic material models goes to:\nhttp://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch08.html","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["diffraction","gpugems"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Distance between slits\n#define D 2.\n//Used for anisotropic illumination\n#define ROUGHNESS 3.\nvec3 getCircle(vec2 center, vec2 uv, vec3 n, inout vec3 t);\nvec3 aniso(vec3 h, vec3 n, float u);\nvec3 blend3(vec3 x);\nvec3 blinn_phong(vec3 h, vec3 n);\nvec3 env_map(vec3 n, vec3 v);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 n = vec3(0, 0, 1.);\n    vec3 light = vec3(3., 3., 5. + 3. * sin(iTime * .5));\n    vec2 center = vec2(.9,.5);\n    \n    vec3 pos = vec3(uv - center, 0);\n    vec3 l = normalize(light - pos);\n    vec3 v = normalize(vec3(vec2(0), 2.) - pos);\n    vec3 h = l + v; //Half vector\n   \tvec3 t; //Tangent vector\n    \n    vec3 col = getCircle(center, uv, n, t);\n\n    float u = abs(dot(h, t) * D); //D * |sin theta1 - sin theta2|\n    float C = 4.;\n    vec3 cdiff = vec3(0);\n   \tfor (int m = 1; m < 8; m++) //Sum contributions of wave\n   \t{\n     \tfloat y = 2. * u / float(m) - 1.; //Bound from .5 to 1 micron\n     \tcdiff.xyz += blend3(vec3(C * (y - 0.75), C * (y - 0.5),\n                     C * (y - 0.25)));\n   \t}\n    col *= aniso(h, n, u) + cdiff + blinn_phong(h,n) + env_map(n, v);\n\tcol = col == vec3(0.) ? texture(iChannel0, -v).rgb : col;    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvec3 getCircle(vec2 center, vec2 uv, vec3 n, inout vec3 t)\n{\n    float r = length(uv - center);\n    t = normalize(cross(vec3(uv - center, 0), n));\n    return r > .3 || r < .05 ? vec3(0.) : vec3(1.);\n}\n\nvec3 aniso(vec3 h, vec3 n, float u)\n{\n    float w = dot(h, n);\n    float e = ROUGHNESS * u / w;\n    return vec3(244, 188, 66) / 256. * exp(-e * e); //exp(-(r * tan(theta))^2)\n}\n\nvec3 blinn_phong(vec3 h, vec3 n)\n{\n    return vec3(pow(clamp(dot(normalize(h),n), 0., 1.), 10.));\n}\n\nvec3 env_map(vec3 n, vec3 v)\n{\n    vec3 r = -reflect(v, n);\n    return texture(iChannel0, r).rgb;\n}\n\nvec3 blend3(vec3 x)\n{\n    vec3 y = 1. - x * x; //Bump function\n    y = max(y, vec3(0));\n    return y;\n}","name":"Image","description":"","type":"image"}]}