{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// @gofreak_ie, say hi on twitter\r\n\r\n// an implementation of Ken Perlin's hypertexture fur\r\n\r\n// uses a mish-mash of things. I borrowed some code from Simon Green's\r\n// furball demo - at this point it's mostly just the shading & rotation\r\n// code\r\n\r\n// noise from iq, bias/gain from antonanalog\r\n\r\n// mixes in some dual real sdfs - some functions from iq - \r\n// which helps in projection for the fur on non-spherical shapes\r\n\r\n// if i neglected to credit anyone else please let me know!\r\n\r\n// bug/tweak feedback welcome!\r\n\r\n\r\n// increase/decrease furLayers for quality/speed\r\n// I originally set this to 128, which works on my machine (Mac/Chrome), but apparently\r\n// little more than 30 works on Windows\r\n// Try increasing if on Mac! :)\r\nconst int furLayers = 30; \r\n\r\nconst float shapeOuterRadius = 0.9;\r\nconst float shapeInnerRadius = 0.775;\r\n\r\nconst float furDepth = shapeOuterRadius - shapeInnerRadius;\r\nconst float rayStep = furDepth*4.0 / float(furLayers);\r\n\r\n// can twiddle these things for different types of fur\r\nfloat furFrequency = 50.0;\r\nfloat furBias = 0.7;\r\nfloat furGain = 0.1;\r\n\r\nfloat curliness = 0.02;\r\n// i'm not really sure how well curling works, but uncomment if you like\r\n//#define CURL\r\n\r\n\r\n\r\n//iq noise\r\nfloat hash( float n )\r\n{\r\n\treturn fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n\tvec3 p = floor(x);\r\n\tvec3 f = fract(x);\r\n\t\r\n\tf = f*f*(3.0-2.0*f);\r\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\r\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n\t\t\t\t   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n\r\nvec3 noise3( in vec3 x)\r\n{\r\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\r\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\r\n\t\t\t\tnoise(x) );\r\n}\r\n\r\n\r\n//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz\r\nfloat bias(float x, float b) {\r\n\treturn  x/((1./b-2.)*(1.-x)+1.);\r\n}\r\n\r\nfloat gain(float x, float g) {\r\n\tfloat t = (1./g-2.)*(1.-(2.*x));\t\r\n\treturn x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);\r\n}\r\n\r\nfloat turbulence(vec3 pos)\r\n{\r\n\tvec3 p = vec3(pos.x+123.456, pos.y, pos.z);\r\n\tfloat t = 0.0;\r\n\t\r\n\tfloat freq = 2.5;\r\n\tfor(int i =0; i<10; i++)\r\n\t{\r\n\t\t\r\n\t\tt += abs(noise3(p).x)/ freq;\r\n\t\t\r\n\t\tp *= 2.0;\r\n\t\tfreq *= 2.0;\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\treturn t-0.3;\r\n}\r\n\r\n//==================================================================================\r\n// some dual real numbers functions, for f : R3 -> R1\r\n\r\nstruct dualR3\r\n{\r\n    float x, y, z;\r\n\tfloat dx, dy, dz;\r\n};\r\n\r\nvec4 dSet( float a ) { return vec4( a, 0.0, 0.0, 0.0 ); }\r\nvec4 getX( dualR3 n ) {\treturn vec4(n.x, n.dx, 0.0, 0.0 ); }\r\nvec4 getY( dualR3 n ) {\treturn vec4(n.y, 0.0, n.dy, 0.0 ); }\r\nvec4 getZ( dualR3 n ) {\treturn vec4(n.z, 0.0, 0.0, n.dz ); }\r\n\r\nvec4 dSqrX( dualR3 a ) { return vec4( a.x*a.x, 2.0*a.x*a.dx, 0.0, 0.0 ); }\r\nvec4 dSqrY( dualR3 a ) { return vec4( a.y*a.y, 0.0, 2.0*a.y*a.dy, 0.0 ); }\r\nvec4 dSqrZ( dualR3 a ) { return vec4( a.z*a.z, 0.0, 0.0, 2.0*a.z*a.dz ); }\r\n\r\nvec4 dMul( vec4 a, vec4 b ) { return vec4( a.x*b.x, a.y*b.x + a.x*b.y, a.z*b.x + a.x*b.z, a.w*b.x + a.x*b.w );\r\n\t\t\t\t\r\n}\r\n\r\nvec4 dSqrt( vec4 a)\r\n{\r\n\tfloat sqrta;\r\n\tfloat inv_2sqrta;\r\n\t\r\n\tsqrta      = sqrt(a.x);\r\n\tinv_2sqrta = 1.0/(2.0*sqrta);\r\n\t\r\n\treturn vec4 (sqrta, inv_2sqrta * a.y, inv_2sqrta * a.z,inv_2sqrta * a.w);\r\n}\r\n\r\nvec4 dSin( vec4 a )\r\n{\r\n\tfloat sina = sin(a.x);\r\n\tfloat cosa = cos(a.x);\r\n\treturn vec4(sina, cosa * a.y, cosa * a.z, 0.0);\r\n}\r\n\r\nvec4 dMin(vec4 x, vec4 y)\r\n{\r\n\tif (x.x > y.x)\r\n\t{\r\n\t\treturn y;\r\n\t}\r\n\telse \r\n\t{\r\n\t\treturn x;\r\n\t}\r\n}\r\n\t\t\r\nvec4 dMax(vec4 x, vec4 y)\r\n{\r\n\tif (x.x < y.x)\r\n\t{\r\n\t\treturn y;\r\n\t}\r\n\telse \r\n\t{\r\n\t\treturn x;\r\n\t}\r\n}\r\n\r\nvec4 deformX(dualR3 p, float scale)\r\n{\r\n\t\r\n\treturn dSin(dMul( dSet(20.0*(1.0/scale)), getX(p) ));\r\n}\r\n\r\nvec4 dualSphere(dualR3 p, float scale)\r\n{\r\n\treturn (dSqrt(dSqrX(p) + dSqrY(p) + dSqrZ(p)) - dSet(scale));\r\n}\r\n\r\nvec4 dualSphereDynamicWarp(dualR3 p, float scale)\r\n{\r\n\treturn (dSqrt(dSqrX(p) + dSqrY(p) + dSqrZ(p)) - dSet(scale)) + dMul(dMul(dSet(abs(cos(iTime))), dSet(0.1) ), deformX(p, scale) );\r\n}\r\n\r\nvec4 dualSphereStaticWarp(dualR3 p, float scale)\r\n{\r\n\treturn (dSqrt(dSqrX(p) + dSqrY(p) + dSqrZ(p)) - dSet(scale)) + dMul(dSet(scale), dMul(dSet(0.02), deformX(p, scale)));\r\n}\r\n\r\n\r\nvec3 project(vec3 pos, float density, vec3 norm)\r\n{\r\n\t\r\n\tfloat f = furDepth*(1.0-density);\r\n\r\n\treturn pos + f*norm;\r\n\t\r\n}\r\n\r\n// thanks FabriceNeyret2 for the more compact code :)\r\nvec4 sphere(vec3 pos)\r\n{\tdualR3 p =  dualR3(pos.x,pos.y,pos.z,1.,1.,1.);\r\n\tvec4 f = dualSphereStaticWarp(p, shapeOuterRadius);\r\n\tfloat distOuter = f.x / length(f.yzw);\r\n\t\r\n\t\r\n\tfloat a = (distOuter>0.)            ? 0. \r\n \t\t\t  : ( (distOuter<-furDepth) ? 1. \r\n\t\t\t  : \t\t     \t\tabs(distOuter)/furDepth \r\n  \t\t\t\t);\r\n\treturn vec4(a, -f.yzw);\t\r\n}\r\n\r\n\r\n\r\n\r\n// furball specific functions\r\nbool intersectSphere(vec3 ro, vec3 rd, float r, out float t)\r\n{\r\n\tfloat b = dot(-ro, rd);\r\n\tfloat det = b*b - dot(ro, ro) + r*r;\r\n\tif (det < 0.0) return false;\r\n\tdet = sqrt(det);\r\n\tt = b - det;\r\n\treturn t > 0.0;\r\n}\r\n\r\nvec3 rotateX(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\r\n}\r\n\r\n\r\n\r\n\r\n// furry ball\r\n\r\n\r\n\r\nfloat furryball_density(vec3 pos)\r\n{\r\n\tfloat f = furFrequency;\r\n\t\r\n\t\r\n\tvec4 res = sphere(pos);\r\n\t\r\n\tfloat d = res.x;\r\n\t\r\n\tvec3 n = normalize(res.yzw);\r\n\t\r\n\t\r\n\t\r\n\t#ifdef CURL\r\n\t\r\n\t\tvec3 offset = vec3(18.0, 40.5, 20.0);\r\n\t\tvec3 x1 = pos + gain(1.-d, 0.3)*curliness * noise3(pos-offset).xyz;\r\n\t\t\r\n\t\r\n\t\tfloat s = noise3(f * project(x1, d, n)).x;\r\n\t\t//float s = svec.x;\r\n\t\r\n\t#else\r\n\t\r\n\t\tfloat s = 1.0*noise(f*project(pos, d, n));\r\n\t\r\n\t#endif\r\n\t\r\n\treturn gain(bias(s, furBias), furGain)*d;\r\n\t\r\n}\r\n\r\nfloat density_function(vec3 pos)\r\n{\r\n\tfloat density =  furryball_density(pos);\r\n\treturn density;\t\r\n}\r\n\r\nvec4 compute_shading(vec4 col, vec3 pos, vec3 normal)\r\n{\r\n\t// lighting\r\n\tvec3 ro = vec3(0.0);\r\n\tconst vec3 L = vec3(1, 1, 1);\r\n\tvec3 V = normalize(ro - pos);\r\n\tvec3 H = normalize(V + L);\r\n\r\n\tvec3 N = -normal;\r\n\t//float diff = max(0.0, dot(N, L));\r\n\tfloat diff = max(0.0, dot(N, L)*0.5+0.5);\r\n\t//float spec = pow(max(0.0, dot(N, H)), shininess);\r\n\t\r\n\t// base color\r\n\t//vec3 color = texture(iChannel1, uv*colorUvScale).xyz;\r\n\tvec4 color = col;\r\n\t// darken with depth\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\tt = clamp(t, 0.0, 1.0);\r\n\tfloat i = t*0.5+0.5;\r\n\t\t\r\n\treturn color*diff*i;\r\n}\t\t\r\n\r\n\r\nvec4 compute_color(vec3 pos, float density)\r\n{\r\n\t//return vec4(0.5, 0.5+density, 0.5, density);\r\n\tvec4 c = texture(iChannel1,pos.xy);\r\n\tc.a = density;\r\n\treturn c;\r\n}\r\n\r\nvec3 compute_normal(vec3 pos, float density)\r\n{\r\n\t\r\n    float eps = rayStep*2.0;\r\n    vec3 n;\r\n\t\r\n    n.x = density_function( vec3(pos.x+eps, pos.y, pos.z) ) - density;\r\n    n.y = density_function( vec3(pos.x, pos.y+eps, pos.z) ) - density;\r\n    n.z = density_function( vec3(pos.x, pos.y, pos.z+eps) ) - density;\r\n    return normalize(n);\r\n}\r\n\r\n\r\nvec4 func( vec3 ws )\r\n{\r\n\tdualR3 p =  dualR3(ws.x,ws.y,ws.z,1.0,1.0,1.0);\r\n\t\r\n\treturn dualSphereStaticWarp(p, shapeOuterRadius);\r\n}\r\n\r\n\r\nfloat dist( vec3 ws )\t\t\r\n{\r\n\t\r\n\t\r\n\tvec4 f = func( ws ) ;\t\r\n\t\r\n\tfloat dist = f.x / length(f.yzw);\r\n\t\r\n\treturn dist; \r\n\t\r\n}\t\r\n\r\n\r\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\r\n{\r\n\tfloat precis = 0.001;\r\n\tfloat h=0.002;\r\n\tfloat t = 0.0;\r\n\tfloat m = -1.0;\r\n\t\r\n\t//float count = 1.0;\r\n\tfor(int i=0; i<16; i++ )\r\n\t{\r\n\t\tif( abs(h)<precis||t>maxd )\r\n\t\t{\r\n\t\t\t//return float2( t, -1.0 );\r\n\t\t\t//int dummy = 0; // do nothing\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tt += h;\r\n\t\t\tfloat res = dist( ro+rd*t );\r\n\t\t\th = res;\r\n\t\t\t//m = res.y;\r\n\t\t\t//count = count+1.0;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t#ifdef VISUALISE_RAYSTEPS\r\n\t// return number of steps\r\n\t// return float2(count/64.0, m);\r\n\t#else\r\n\t\r\n\tm = 72.0;\r\n\tif( t>maxd ) m=-1.0;\r\n\treturn vec2( t, m );\r\n\t#endif\r\n}\r\n\r\n\r\nvec4 scene(vec3 ro,vec3 rd)\r\n{\r\n\t\r\n\tvec3 p = vec3(0.0);\r\n\t\r\n\tvec2 res = castRay(ro,rd, 4.0);\r\n\t\r\n\tfloat t = res.x;\r\n\tfloat m = res.y;\t\r\n\t\r\n\t\r\n\tvec4 color = vec4(0.0);\r\n\tif (m>-1.0) {\r\n\t\tvec3 pos = ro + rd*t;\r\n\t\tfloat previous_density;\r\n\t\t// ray-march into volume\r\n\t\tfor(int i=0; i<furLayers; i++) {\r\n\t\t\t\r\n\t\t\tfloat density = density_function(pos);\r\n\t\t\tvec4 c = compute_color(pos, density);\r\n\t\t\t\r\n\t\t\tif(density != previous_density)\r\n\t\t\t{\r\n\t\t\t\tvec3 normal = compute_normal(pos, density);\r\n\t\t\t\tc = compute_shading(c, pos, normal);\r\n\t\t\t\tprevious_density = density;\r\n\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\tc.a = 1.0 - pow(abs(1.0 - c.a), 100.0*rayStep);\r\n\t\t\t\r\n\t\t\tif(c.a > 0.0)\r\n\t\t\t{\r\n\t\t\t\tfloat t = c.a *(1.0 - color.a);\r\n\t\t\t\tcolor += vec4(t*c.r, t*c.g, t*c.b, t);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// march further along the ray\r\n\t\t\tif( c.a>0.99 ) break;\r\n\t\t\tpos += rd*rayStep;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn color;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv = uv*2.0-1.0;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\r\n\tvec3 rd = normalize(vec3(uv, -2.0));\r\n\t\r\n\tvec2 mouse = iMouse.xy / iResolution.xy;\r\n\tfloat roty = 0.0;\r\n\tfloat rotx = 0.0;\r\n\tif (iMouse.z > 0.0) {\r\n\t\trotx = (mouse.y-0.5)*3.0;\r\n\t\troty = -(mouse.x-0.5)*6.0;\r\n\t} else {\r\n\t\trotx = sin(iTime*1.5);\r\n\t}\r\n\t\r\n    ro = rotateX(ro, rotx);\t\r\n    ro = rotateY(ro, roty);\t\r\n    rd = rotateX(rd, rotx);\r\n    rd = rotateY(rd, roty);\r\n\t\r\n\tfragColor = scene(ro, rd)*2.0;\r\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xd23WV","date":"1394714022","viewed":5267,"name":"hypertexture fur","username":"gofreak","description":"An implementation of Ken Perlin's hypertexture fur. Mixes in some dual real sdfs - which helps in projection for the fur on non-spherical shapes, in this case a deformed sphere. Bug/tweak feedback welcome! Tested on Mac OSX/Chrome.","likes":46,"published":1,"flags":0,"usePreview":0,"tags":["fur","hypertexture","dualrealfunctions"],"hasliked":0,"parentid":"","parentname":""}}