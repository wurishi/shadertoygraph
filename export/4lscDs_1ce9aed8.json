{"ver":"0.1","info":{"id":"4lscDs","date":"1507026214","viewed":247,"name":"Stripe Composition","username":"aaaidan","description":"Study in generating and compositing stripes and shadows.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","25d","stripes","util"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592654\n#define TWO_PI 6.28318530718\n\n#define STRIPE_COLOR1 (vec4(194, 216, 68, 255)/255.)\n#define STRIPE_COLOR2 (vec4(194, 216, 68, 0)/255.)\n#define STRIPE_WIDTH 50.0\n#define STRIPE_ANGLE 0.0\n#define BACKGROUND_COLOR (vec4(235, 232, 222, 255)/255.)\n#define CIRCLE_RADIUS 150.0\n#define SHADOW_COLOR (vec4(30, 50, 0, 70)/255.)\n#define SPEED 5.0\n\n#define scale (1.0/STRIPE_WIDTH)\n\nvec4 blend(in vec4 under, in vec4 over) {\n    float outA = over.a + under.a * (1.0 - over.a);\n    vec3 outCol = vec3(0.0);\n    if (outA > 0.0) {\n    \toutCol = ( over.rgb*over.a + under.rgb*under.a*(1.0-over.a) ) / outA;\n    }\n    return vec4(outCol,outA);\n}\n\nvec4 stripes( in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy / 2.0;\n            \n    float angle = (STRIPE_ANGLE + iTime*SPEED) / 360.0 * TWO_PI;\n    \n    float sx = sin(angle) * (fragCoord.x - iMouse.x);\n    float sy = cos(angle) * (fragCoord.y - iMouse.y);\n    \n    float amt = sin((sx + sy) * TWO_PI * scale);\n    \n    vec4 color = amt > 0.0 ? vec4(STRIPE_COLOR1) : vec4(STRIPE_COLOR2);\n    \n    bool inCircle = \n        pow(fragCoord.x - center.x, 2.) + \n        pow(fragCoord.y - center.y, 2.) <\n        CIRCLE_RADIUS * CIRCLE_RADIUS;\n    \n    return vec4(color.rgb, inCircle ? color.a : 0.0);\n}\n\n#define BLUR_SIZE 19.0\n#define HALF_BLUR_SIZE (BLUR_SIZE/2.0)\n\nvec4 grid(in vec2 fragCoord) {\n    float angle = (STRIPE_ANGLE + iTime*3.6 + 90.0) / 360.0 * TWO_PI;\n    \n    float sx = sin(angle) * (fragCoord.x - iMouse.x);\n    float sy = cos(angle) * (fragCoord.y - iMouse.y);\n    \n    float amt = mod((sx + sy) * TWO_PI * scale, 15.0);\n    \n    return amt < 1.0 ? vec4(0.0,0.0,0.0,0.08) : vec4(0.0,0.0,0.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor  = stripes(fragCoord + vec2(-.25,-.25));\n    fragColor += stripes(fragCoord + vec2(-.25, .25));\n    fragColor += stripes(fragCoord + vec2( .25,-.25));\n    fragColor += stripes(fragCoord + vec2( .25, .25));\n    fragColor /= 4.0;\n    \n    // shadow\n    float totalSamples = 0.0;\n    float shadowAmt = 0.0;\n    for (float x=0.;x < BLUR_SIZE; x+=1.) {\n        for (float y=0.;y < BLUR_SIZE; y+=1.) {\n            \n            // this is my attempt at a circular (lens) blur \n            float sampleAmt = length(vec2(x,y) - HALF_BLUR_SIZE);\n            sampleAmt = 1.0 - step(HALF_BLUR_SIZE, sampleAmt);\n            \n            //sampleAmt = 1.0; // a.k.a box blur\n            \n            shadowAmt += stripes(\n                fragCoord + vec2(\n                    float(x)-HALF_BLUR_SIZE,\n                    float(y)-HALF_BLUR_SIZE+10.0\n                )\n            ).a * sampleAmt;\n            totalSamples += sampleAmt;\n        }\n    }\n    shadowAmt /= totalSamples;\n    \n    vec4 shadowColor = vec4(SHADOW_COLOR.rgb, SHADOW_COLOR.a * shadowAmt);\n    fragColor = blend(shadowColor, fragColor);\n    \n    // grid\n    vec4 gridColor = grid(fragCoord);\n    fragColor = blend(gridColor, fragColor);\n    \n    \n    fragColor = blend(BACKGROUND_COLOR, fragColor);\n}","name":"Image","description":"","type":"image"}]}