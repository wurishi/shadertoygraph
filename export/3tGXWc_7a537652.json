{"ver":"0.1","info":{"id":"3tGXWc","date":"1584810619","viewed":199,"name":"polar coords - raindrops","username":"iradicator","description":"Raindrops effect using polar coordinate system.\n\nCheck my blog post for more information: \nhttps://iradicator.com/screen-space-effects-using-polar-coordinates-linear-transformations/","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["2d","effect","linear","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define SQRT2 1.41421356237\n\n#define MAX_FLT 3.402823e+38\n#define EPSILON 1.192093e-07\n\n#define sqrLength(x) dot((x),(x))\n\nfloat clamp01(in float v) { return clamp(v, 0.0, 1.0); }\nvec2 clamp01(in vec2 v) { return vec2(clamp01(v.x), clamp01(v.y)); }\n\n//////////////\n// Controls //\n//////////////\n\n// True iff using polar coordinates (otherwise cartesian) \n#define IS_USING_POLAR_COORD 1\n\n// Raindrops strength (negative radius translation) effect (between 0 and 1)\n#define RAINDROPS_AMPLITUDE 0.02\n\n// raindrops power (between 0 and 1)\n#define RAINDROPS_POWER 0.1\n\n//////////////////////\n// Texture Sampling //\n//////////////////////\n\nvec4 sample_clamp(in sampler2D tex, in vec2 uv) \n{\n    return textureGrad(tex, clamp01(uv), dFdx(uv), dFdy(uv));\n}\n\nvec4 sample_repeat(in sampler2D tex, in vec2 uv) \n{\n    return textureGrad(tex, fract(uv), dFdx(uv), dFdy(uv));\n}\n\nvec4 sample_border(in sampler2D tex, in vec2 uv) \n{\n    bool isInBorder = ((0.0 <= uv.x) && (uv.x <= 1.0) && (0.0 <= uv.y) && (uv.y <= 1.0));\n    if (isInBorder)\n        return textureGrad(tex, fract(uv), dFdx(uv), dFdy(uv));\n    return vec4(1.0, 0.0, 1.0, 1.0); // bg color - magenta    \n}\n\n////////////////////////\n// Coordinate Systems //\n////////////////////////\n\nvec2 tex_to_cartesian(in vec2 uv, in vec2 origin)\n{\n    uv = 2.0 * uv - 1.0;\n    uv -= origin;\n    return uv;\n}\n\nvec2 cartesian_to_tex(in vec2 uv, in vec2 origin)\n{\n    uv += origin;\n    uv = 0.5 * uv + 0.5;\n    return uv;\n}\n\nvec2 tex_to_polar(in vec2 uv, in vec2 origin)\n{\n    uv = tex_to_cartesian(uv, origin);\n    float r = length(uv); \n    float theta = atan(uv.y, uv.x);\n    return vec2(r, theta);\n}\n\nvec2 polar_to_tex(in vec2 rt, in vec2 origin)\n{\n    float x = rt.x * cos(rt.y);\n    float y = rt.x * sin(rt.y);  \n    return cartesian_to_tex(vec2(x,y), origin);\n}\n\n////////////////\n// Transforms //\n////////////////\n\n\nvec2 get_origin(in vec2 uv, in float t)\n{\n    // Drawn from unifrom distribution and removing obvious collisions\n    vec2 origins[15];    \n\torigins[0 ] = vec2(-0.5427058957383726, -0.4167352024480706);\n\torigins[1 ] = vec2(-0.41573429020202046, 0.8479817999379784);\n\torigins[2 ] = vec2(0.8022551724885247, 0.33616427229720003);\n\torigins[3 ] = vec2(0.6362738732833295, -0.7584309062340302);\n\torigins[4 ] = vec2(-0.035740957557768294, 0.9024994999445803);\n\torigins[5 ] = vec2(-0.900713662013721, 0.6781372097919369);\n\torigins[6 ] = vec2(0.7189383123011639, -0.41510521723027716);\n\torigins[7 ] = vec2(0.2644921082469419, 0.0666671797015291);\n\torigins[8 ] = vec2(-0.9967104850093311, -0.2659144097783137);\n\torigins[9 ] = vec2(-0.6091092055119978, -0.04559961238010257);   \n\torigins[10] = vec2(0.2431943984105419, -0.8776904739586513);\n\torigins[11] = vec2(-0.15565228939643938, 0.13269877310834732);\n\torigins[12] = vec2(0.3466376116022718, -0.5250444116308786);\n\torigins[13] = vec2(0.15427185412111788, 0.5314478713192285);\n\torigins[14] = vec2(-0.810613292735594, 0.3066399656558083);\n    \n    int minOriginIndex = 0;\n    float mind2 = sqrLength(uv - origins[0]);\n    for (int i = 1; i < origins.length(); ++i)\n    {\n        float currd2 =  sqrLength(uv - origins[i]);\n        if (currd2 < mind2)\n        {\n            mind2 = currd2;\n            minOriginIndex = i;\n        }\n    }\n    return origins[minOriginIndex];\n}\n\nvec2 transform(in vec2 uv, in float t)\n{\n    float tr = RAINDROPS_AMPLITUDE * (1.0 + sin(2.0 * PI * t));\n    return uv - vec2(tr, 0.0);\n}\n\n////////////////////\n// Driver Program //\n////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{                    \n    vec2 uv_tex = fragCoord / iResolution.xy;\n\n    vec2 closest_origin = get_origin(2.0 * uv_tex - 1.0, iTime);\n    \n    // uv_s: tex coord -> cartesian / polar coord       \n#if IS_USING_POLAR_COORD\n    vec2 uv_s = tex_to_polar(uv_tex, closest_origin);\n#else\n    vec2 uv_s = tex_to_cartesian(uv_tex, closest_origin);\n#endif\n      \n    // uv_t: transformation   \n    vec2 uv_t = transform(uv_s, 2.3 * iTime + 33.0 * closest_origin.x - 9.0 *  closest_origin.y);\n    \n    // uv_e: transformed cartesian / polar coord -> transformed tex coord\n#if IS_USING_POLAR_COORD\n\tvec2 uv_e = polar_to_tex(uv_t, closest_origin);\n#else\n    vec2 uv_e = cartesian_to_tex(uv_t, closest_origin);\n#endif    \n\n    // uv: mixing between uv_tex and uv_e (lerping with alpha)        \n    float alpha = smoothstep(0.0, 1.0, 4.0 * distance(uv_tex, 0.5 * closest_origin + 0.5));\n    alpha = 1.0 - pow(alpha, RAINDROPS_POWER);\n    vec2 uv = mix(uv_tex, uv_e, alpha);\n            \n    \n    // final composition: texture using uv\n    vec3 col = sample_repeat(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}