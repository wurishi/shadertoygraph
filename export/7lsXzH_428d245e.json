{"ver":"0.1","info":{"id":"7lsXzH","date":"1625182542","viewed":135,"name":"Kaleidoscope sample","username":"lumic","description":"Using rotations + x-mirror to create a kaleidoscope","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","reflection","kaleidoscope","mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n#define ZOOM 2.0\n\nfloat rectSdf(vec2 p, vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rotate2d(float angle){\n   return mat2(\n       cos(angle),-sin(angle),\n       sin(angle),cos(angle)\n   );\n}\n\n// https://iquilezles.org/articles/distfunctions\n// c = half of repeat interval\n// l = how many times to repeat per axis\nfloat rectRepeat(vec2 p, vec2 size, vec2 c, vec2 l)\n{\n    vec2 q = p-c*clamp(round(p/c),-l,l);\n    return rectSdf(q, size);\n}\n\n\nfloat time1(float scale) {\n   // sinusoidal, with a short pause at start/end\n   float overshoot = 1.5;\n   float t = iTime * scale; // scale time here\n   float a = clamp((mod(t, 2.0) - 1.0) * overshoot, -1.0, 1.0);\n   return sin(a * PI);\n}\n\nfloat time2(float scale) {\n   // cosine, with a short pause at start/end\n   float overshoot = 1.5;\n   float t = iTime * scale; // scale time here\n   float a = clamp((mod(t, 2.0) - 1.0) * overshoot, -1.0, 1.0);\n   return cos(a * PI);\n}\n\n\n// Single axis mirror (x-axis)\nvec2 mirror(vec2 p, float offset) { \n    return vec2(abs(mod(p.x, 1.0) - 0.5) + offset, p.y);\n}\n\nvec2 kaleidoscope(vec2 p) {\n    float offsetX = time1(0.25) * 0.1;\n    float offsetY = time2(0.25) * 0.1;\n\n    mat2 rotate90 = rotate2d(PI * 0.5);\n    mat2 rotate45 = rotate2d(PI / 4.0);\n    \n    // Mirror horizontally\n    p =  mirror(p, offsetX);\n\n    // Mirror vertically\n    p = rotate90 * p;\n    p = mirror(p, offsetY);\n    \n    // angle fold\n    p = rotate45 * p;\n    p = mirror(p, 0.);\n\n    return p;\n}\n\nvec3 colorMap(vec2 p) {\n    //float d = rectSdf(uv, vec2(0.2, 0.2));\n    float d = rectRepeat(p, vec2(0.08), vec2(0.4), vec2(3., 1.));\n    \n    // coloring\n    vec3 col = (d<0.0) ? vec3(0.1,0.1,0.2) : vec3(0.2,0.6,0.8);\n    col *= 1.0 - exp(-9.0*abs(d));\n    col *= 1.0 + smoothstep(0.1, 0.2, 0.2*cos(300.0*abs(d)));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d )) );\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n\n    // Rescale\n    uv = uv * ZOOM;\n    vec2 kuv = kaleidoscope(uv);\n\n    //vec4 channel0 = texture(iChannel0, kaleidoscope(uv.xy) + 0.5);\n    //vec3 col = channel0.xyz;\n\n    mat2 domainRotation = rotate2d(time1(0.5) * 0.25);\n    vec3 col = colorMap(domainRotation * kuv);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}