{"ver":"0.1","info":{"id":"wdcXzH","date":"1571420089","viewed":107,"name":"Inside Out Dancing Julia Set","username":"Cotterzz","description":"Forked from https://www.shadertoy.com/view/wsKGDc and https://shadertoy.com/view/3dcXRn","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fractal","julia","fft","audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    vec4 col =  texture(iChannel0, uv);\n    //col = vec4(1.0,1.0,0.0,1.0);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fork of \"Dancing Julia\" by Cotterzz. https://shadertoy.com/view/3dcXRn\n// 2019-10-18 14:24:46\n\n// from \"Smooth Julia set with rain\" by martytram https://www.shadertoy.com/view/wsKGDc\n\n\n#define MAX_ITER 1000.\n#define R 100.\n#define S(a,b,c) smoothstep(a,b,c)\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//conversion helper\nfloat f(float n, vec3 hsl){\n    float k = mod(n+hsl.x*12., 12.);\n    float a = hsl.y*min(hsl.z, 1.-hsl.z);\n    return hsl.z-a*max(min(k-3., min(9.-k, 1.)),-1.);\n}\n// hsl in range <0, 1>^3\nvec3 hsl2rgb(vec3 hsl){\n    return vec3(f(0.,hsl), f(8.,hsl), f(4.,hsl));\n}\n\nvec3 hue2rgb(float hue){\n    \n    float fftc = texture(iChannel0, vec2(hue,0.0)).r;\n    //if(hue<1.0){return hsl2rgb(vec3(0., 1., 0.));} else {return hsl2rgb(vec3(hue, 1., .5));};\n    //return (hsl2rgb(vec3(fftc, 1., .5))+hsl2rgb(vec3(hue, 1., .5)))/2.;\n    return hsl2rgb(vec3(hue, 1., .5));\n}\n\nvec2 Rain(vec2 uv, float t){\n    t*= 40.;\n    vec2 aspect = vec2(3.,1.);\n    vec2 st = uv*aspect;\n    \n    vec2 id = floor(st);\n    st.y+=t*.22;\n    float n = fract(sin(id.x*256.45)*85.);\n    st.y += n;\n    uv.y += n;\n    id = floor(st);\n    st = fract(st)-.5;\n    \n    t+= fract(sin(id.x*56.45+id.y*485.)*155.)*6.28;\n    \n    float y = -sin(t+sin(t+.5*sin(t)))*0.43;\n    float x = (fract(sin(id.x*384.45)*id.y*288.)-.5)*.6;\n    vec2 p1 = vec2(x, y);\n    vec2 o1 = (st-p1)/aspect;\n    float d = length(o1);\n    \n    float m1 = S(.07, .0, d);\n    \n    vec2 o2 = (fract(uv*aspect.x*vec2(1.,2.)-vec2(p1.x,0.))-.5)/vec2(1.,2.);\n    d = length(o2);\n    \n    float m2 = S(0.2*(.5-st.y), .0, d) * S(-.1, .1, st.y-p1.y);\n    \n    //if(st.x>.46 || st.y>.49) m1 = 1.;\n    \n    return vec2(m1*o1*30.+m2*o2*10.);\n}\n\n\nvec3 juliaB(float zx, float zy, float cx, float cy){\n    float iter = 0.;\n    for(int i = 0; i<int(MAX_ITER); i++){\n        if(zx * zx + zy * zy < R*R && iter<MAX_ITER){\n\t\t\tfloat xtemp = zx*zx - zy*zy;\n        \tzy = 2. * zx * zy + cy;\n        \tzx = xtemp + cx;\n        \titer+=1.;\n        } else {\n            break;\n        }\n    }\n\n\n    /*if(iter>=MAX_ITER)\n        return vec3(1,1,0);*/\n    float dist = length(vec2(zx,zy));\n    float fracIter = log2(log(dist) / log(R)) - 1.;\n    iter -= fracIter;\n    return hue2rgb(sqrt(iter/10.));\n}\n\n\nvec3 julia(float zx, float zy, float cx, float cy){\n    float iter = 0.;\n    float nextzx = zx;\n    float nextzy = zy;\n    float nextcx = cx;\n    float nextcy = cy;\n    for(int i = 0; i<int(MAX_ITER); i++){\n        if(zx * zx + zy * zy < R*R && iter<MAX_ITER){\n\t\t\tfloat xtemp = zx*zx - zy*zy;\n        \tzy = 2. * zx * zy + cy;\n        \tzx = xtemp + cx;\n        \titer+=1.;\n        } else {\n            break;\n        }\n    }\n\n    /*if(iter>=MAX_ITER)\n        return vec3(1,1,0);*/\n    float dist = length(vec2(zx,zy));\n    float fracIter = log2(log(dist) / log(R)) - 1.;\n    iter -= fracIter;\n    float firstcol = sqrt(iter/10.);\n    if(firstcol<1.0){\n        firstcol*=firstcol;\n        vec3 nextcol = juliaB(nextzx*firstcol, nextzy*firstcol, nextcx, nextcy);\n        if(nextcol==vec3(0.0,0.0,0.0)){\n            return juliaB(nextzy*firstcol, nextzx*firstcol, nextcx, nextcy);\n        } else {\n            return nextcol;\n        }\n        \n        //if(firstco>0.3){\n            //return vec3(0.,0.,1.);\n       // } else {\n            //return vec3(1.,0.,0.);\n       // }\n        \n    }else {\n        return hue2rgb(firstcol);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvo = fragCoord/iResolution.xy;\n    vec2 toCenter = vec2(0.5)-(fragCoord/iResolution.xy);\n    float angle = (atan(toCenter.y,toCenter.x)+PI)/TWO_PI;\n    float radius = length(toCenter)*2.0;\n    float fftJ = texture(iChannel0, vec2(angle,0.0)).r;\n    float wav = texture(iChannel0, vec2(angle,1.0)).r;\n    float fftJr = texture(iChannel0, vec2(0.2,0.0)).r;\n    float wavr = texture(iChannel0, vec2(uvo.x,1.0)).r;\n    float fftJs = texture(iChannel0, vec2(0.5,0.0)).r;\n    float wavs = texture(iChannel0, vec2(0.5,1.0)).r;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m-=.5;\n    m*=2.;\n    uv*=2.;\n    float t = iTime;\n    t*=.7;\n    \n\n    // uncomment for rain\n    // vec2 rain = Rain(uv*2., t*5.13);rain += Rain(uv*3., t*.15) * .25;uv -= rain * 0.35;\n    \n    // swap these for mouse control instead of music\n\t// vec3 col = julia(uv.x, uv.y, m.x, m.y);\n    vec3 col = julia(uv.x/(fftJs+0.3), uv.y/(fftJs+0.3), -0.75,2.*(fftJr-0.5));\n    \n    // swap these for the post blurring\n    fragColor = (vec4(col, 1.0)/1.9 + texture(iChannel1, (uvo*0.98)+0.01)/1.9);\n    // fragColor = vec4(col, 1.0);\n}\n\n","name":"Buf A","description":"","type":"buffer"}]}