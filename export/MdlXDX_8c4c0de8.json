{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Hauva Kukka 2014.\n\n#define DISTANCE_EPSILON 0.01\n#define NORMAL_DELTA 0.0001\n#define OCCLUSION_DELTA 0.1\n#define SCENE_RADIUS 500.0\n#define STEP_SCALE 1.0\n\n#define MAX_HIT_COUNT 5\n#define ITERATION_COUNT 100\n\n#define TYPE_NONE        0\n#define TYPE_OPAQUE      1\n#define TYPE_TRANSPARENT 2\n\n#define MODE_OUTSIDE 0\n#define MODE_INSIDE  1\n\n#define N1 1.0\n#define N2 2.0\n \n#define R0(x, y) (((x - y) / (x + y)) * ((x - y) / (x + y)))\n#define PI 3.1415\n\n#define SHADOW\n\nstruct Material {\n\tvec3 color;\n    float shininess;\n    float opacity;\n};\n\nstruct HitInfo {\n\tMaterial material;\n    int type;\n};\n        \nvec3 viewer;\nvec3 target;\n\nHitInfo hitInfo;\n\nfloat clock;\n\nvec3 mirrorRay(vec3 ray, vec3 normal) {\n\tfloat dot = dot(ray, normal);\n    return 2.0 * dot * normal - ray;\n}\n\nfloat getPatternWeight(vec3 position) {\n    if (mod(position.z, 1.788854) > 0.894427) position.x += 0.5;\n\n    vec2 local = vec2(mod(position.x, 1.000000), mod(position.z, 0.894427));\n    vec2 center = vec2(0.5, 0.447214);    \n\n    vec2 delta = center - local;                  \n\tif (dot(delta, delta) > 0.18) return 0.0;\n    else                          return 1.0;    \n}\n\nfloat getDistanceBox(vec3 position, vec3 boxRadius, float r) {\n\tvec3 delta = abs(position) - boxRadius;\n\treturn min(max(delta.x, max(delta.y, delta.z)), 0.0) + length(max(delta, 0.0)) - r;\n}\n\nfloat getDistancePlaneXZ(vec3 position, float height) {\n\treturn position.y - height;\n}\n\nmat2 getRotation(float r) {\n \treturn mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat getDistanceSceneOpaque(vec3 position, bool saveHit) {\n    float field = getDistancePlaneXZ(position, -0.5);  \n    \n    if (field < DISTANCE_EPSILON && saveHit) {\n\t\thitInfo.type = TYPE_OPAQUE;\n        hitInfo.material.color = mix(\n            vec3(0.9, 0.8, 0.8),\n            vec3(0.9, 0.2, 0.2),\n    \t\tgetPatternWeight(position)\n        );\n        \n        hitInfo.material.shininess = 0.1;\n        hitInfo.material.opacity = 1.0;\n   \t}\t\n\n\treturn field;\n}\n\nfloat getDistanceSceneTransparent(vec3 position, bool saveHit) {   \n    mat2 twirl = mat2(cos(-clock), sin(-clock), -sin(-clock), cos(-clock));\n    vec3 local = position;\n    \n    local.xyz = position.xyz - vec3(target.x, sin(mod(clock, 0.5 * PI) + 0.25 * PI), 0.0);\n    local.xy = getRotation(-clock) * local.xy;\n    float field = getDistanceBox(local, vec3(1.0), 0.2);\t\n\n    local = position;\n    local.x -= 1.0 * target.x + 2.5;\n    local.y -= 0.5 *  sin(mod(2.0 * clock, 0.5 * PI) + 0.25 * PI);\n    local.xy = twirl * twirl * local.xy;\n    local.z -= 2.2;\n\n    field = min(field, getDistanceBox(local, vec3(0.5), 0.1));\n    \n    local = position;\n    local.x -= 1.0 * target.x + 0.5;\n    local.y -= 0.5 *  sin(mod(2.0 * clock, 0.5 * PI) + 0.25 * PI);\n    local.xy = twirl * twirl * local.xy;\n    local.z -= 2.2;\n    \n    field = min(field, getDistanceBox(local, vec3(0.5), 0.1));\n\n    if (field < DISTANCE_EPSILON && saveHit) {\n        hitInfo.type = TYPE_TRANSPARENT;\n        hitInfo.material.color = vec3(1.0, 0.9, 0.8);\n        hitInfo.material.shininess = 7.0;\n        hitInfo.material.opacity = 0.025;\n    }\n\n    return field;\n}\n\nfloat getDistanceScene(vec3 position, bool saveHit) {\n\treturn min(\n        getDistanceSceneOpaque(position, saveHit),\n        getDistanceSceneTransparent(position, saveHit)\n    );    \n}\n   \nvec3 getNormalTransparent(vec3 position) {\n    vec3 nDelta = vec3(\n        getDistanceSceneTransparent(position - vec3(NORMAL_DELTA, 0.0, 0.0), false),\n        getDistanceSceneTransparent(position - vec3(0.0, NORMAL_DELTA, 0.0), false),\n        getDistanceSceneTransparent(position - vec3(0.0, 0.0, NORMAL_DELTA), false)\n   \t);\n    \n    vec3 pDelta = vec3(\n        getDistanceSceneTransparent(position + vec3(NORMAL_DELTA, 0.0, 0.0), false),\n        getDistanceSceneTransparent(position + vec3(0.0, NORMAL_DELTA, 0.0), false),\n        getDistanceSceneTransparent(position + vec3(0.0, 0.0, NORMAL_DELTA), false)\n   \t);\n     \n    return normalize(pDelta - nDelta);\n}\n\nvec3 getNormalOpaque(vec3 position) {\n    vec3 nDelta = vec3(\n        getDistanceSceneOpaque(position - vec3(NORMAL_DELTA, 0.0, 0.0), false),\n        getDistanceSceneOpaque(position - vec3(0.0, NORMAL_DELTA, 0.0), false),\n        getDistanceSceneOpaque(position - vec3(0.0, 0.0, NORMAL_DELTA), false)\n   \t);\n    \n    vec3 pDelta = vec3(\n        getDistanceSceneOpaque(position + vec3(NORMAL_DELTA, 0.0, 0.0), false),\n        getDistanceSceneOpaque(position + vec3(0.0, NORMAL_DELTA, 0.0), false),\n        getDistanceSceneOpaque(position + vec3(0.0, 0.0, NORMAL_DELTA), false)\n   \t);\n     \n    return normalize(pDelta - nDelta);\n}\n\nfloat getSoftShadow(vec3 position, vec3 normal) {\n    position += DISTANCE_EPSILON * normal;\n    \n    float delta = 1.0;\n    float minimum = 1.0;\n    for (int i = 0; i < ITERATION_COUNT; i++) {\n        float field = max(0.0, getDistanceSceneTransparent(position, false));\n        if (field < DISTANCE_EPSILON) return 0.3;\n\n        minimum = min(minimum, 8.0 * field / delta);\n\n        vec3 rPos = position - target;\n        if (dot(rPos, rPos) > SCENE_RADIUS) {\n            return clamp(minimum, 0.3, 1.0);\n        }        \n        \n        delta += 0.1* field;\n        position += field * 0.25 * normal;\n    }\n    \n    return clamp(minimum, 0.3, 1.0);\n}\n\nfloat getAmbientOcclusion(vec3 position, vec3 normal) {\n    float brightness = 0.0;\n    \n    brightness += getDistanceScene(position + 0.5 * OCCLUSION_DELTA * normal, false);\n    brightness += getDistanceScene(position + 2.0 * OCCLUSION_DELTA * normal, false);\n    brightness += getDistanceScene(position + 4.0 * OCCLUSION_DELTA * normal, false);\n    \n    brightness = pow(brightness + 0.01, 0.5);    \n    return clamp(1.0 * brightness, 0.5, 1.0);\n}\n\nvec3 getLightDiffuse(vec3 surfaceNormal, vec3 lightNormal, vec3 lightColor) {\n    float power = max(0.0, dot(surfaceNormal, lightNormal));\n    return power * lightColor;\n}\n\nvec3 getLightSpecular(vec3 reflectionNormal, vec3 viewNormal, vec3 lightColor, float power) {\n    return pow(max(0.0, dot(reflectionNormal, viewNormal)), power) * lightColor;\n}\n\nfloat getFresnelSchlick(vec3 surfaceNormal, vec3 halfWayNormal, float r0) {\n    return r0 + (1.0 - r0) * pow(1.0 - dot(surfaceNormal, halfWayNormal), 5.0);\n}\n\nvec3 computeLight(vec3 position, vec3 surfaceNormal, Material material) {\n    vec3 lightPosition = target + vec3(-2.0, 4.0, 2.0);\n    vec3 lightAmbient  = 1.0 * vec3(0.2, 0.2, 0.5);\n    vec3 lightColor    = 100.0 * vec3(1.1, 0.9, 0.5);\n    \n    vec3 lightVector = lightPosition - position;\n    float attenuation = 1.0 / dot(lightVector, lightVector);\n    if (dot(surfaceNormal, lightVector) <= 0.0) return lightAmbient * material.color;\n        \n    vec3 lightNormal = normalize(lightVector);\n    \n#ifdef SHADOW\n    if (hitInfo.type == TYPE_OPAQUE) {\n        lightColor *= getSoftShadow(position, lightNormal);\n    }\n#endif\n    \n    vec3 viewNormal       = normalize(viewer - position);\n    vec3 halfWayNormal    = normalize(viewNormal + lightNormal);\n\tvec3 reflectionNormal = mirrorRay(lightNormal, surfaceNormal);\n        \n    float fresnelTerm  = getFresnelSchlick(surfaceNormal, halfWayNormal, material.shininess);\n    vec3 lightDiffuse  = getLightDiffuse(surfaceNormal, lightNormal, lightColor);    \n    vec3 lightSpecular = getLightSpecular(reflectionNormal, viewNormal, lightColor, 16.0);\n    \n    float brightness = getAmbientOcclusion(position, surfaceNormal);\n    \n    return brightness * (\n        lightAmbient + attenuation * (\n            material.opacity * lightDiffuse + fresnelTerm * lightSpecular\n        )\n    ) * material.color;\n}\n\nvec3 traceRay(vec3 position, vec3 normal) {\n   \tvec3 colorOutput = vec3(0.0);\n   \tvec3 rayColor = vec3(1.0);\n    \n    float fogAccum = 0.0;\n    \n  \tint mode = MODE_OUTSIDE;\n   \tfor(int hitCount = 0; hitCount < MAX_HIT_COUNT; hitCount++) {\n        hitInfo.type = TYPE_NONE;\n        \n        for (int it = 0; it < ITERATION_COUNT; it++) {            \n            float field;\n            \n            if (mode == MODE_OUTSIDE) {\n\t            field = getDistanceScene(position, true);            \n                fogAccum += abs(field);\n                if (field < DISTANCE_EPSILON) break;\n            }\n            else {\n\t\t\t\tfield = getDistanceSceneTransparent(position, true);\n                if (field > DISTANCE_EPSILON) break;\n            }\n\n            vec3 rPos = position - target;\n            if (dot(rPos, rPos) > SCENE_RADIUS) {\n                hitInfo.type = TYPE_NONE;\n                break;\n            }\n\n            float march = max(DISTANCE_EPSILON, abs(field));\n            position = position + STEP_SCALE * march * normal;\n        }\n\n     \tif (hitInfo.type == TYPE_OPAQUE) {\n    \t\tcolorOutput += rayColor * computeLight(\n                position, \n                getNormalOpaque(position),\n                hitInfo.material\n            );\n            \n            break;\n        } \n        else if (hitInfo.type == TYPE_TRANSPARENT) {\n            vec3 surfaceNormal = getNormalTransparent(position);\n            if (mode == MODE_INSIDE) surfaceNormal = -surfaceNormal;\n            \n            colorOutput += 0.02 * rayColor * computeLight(\n                position, \n                surfaceNormal,\n                hitInfo.material\n            );\n\t\t    \n            rayColor *= hitInfo.material.color;\n            normal = refract(normal, surfaceNormal, N1 / N2);\n            \n            if (mode == MODE_INSIDE) {\n            \tif (dot(normal, surfaceNormal) < 0.0) mode = MODE_OUTSIDE;\n                else                                  mode = MODE_INSIDE;\n            }\n            else mode = MODE_INSIDE;\n        }\n        else {\n            break;\n        }\n \t}\n\t        \n    vec3 dist = position - target;\n    return vec3(1.0 / (dot(dist, dist) * 0.001 + 1.0)) * colorOutput;\n}\n\nvec3 createRayNormal(vec3 origo, vec3 target, vec3 up, vec2 plane, float fov, vec3 displacement) {\n    vec3 axisZ = normalize(target - origo);\n\tvec3 axisX = normalize(cross(axisZ, up));\n    vec3 axisY = cross(axisX, axisZ);\n\n    origo += mat3(axisX, axisY, axisZ) * -displacement;\n    \n\tvec3 point = target + fov * length(target - origo) * (plane.x * axisX + plane.y * axisY);\n    return normalize(point - origo);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float cosCamera = cos(2.4 + 2.0 * cos(0.4 * iTime) + 0.0 * (fragCoord.y / iResolution.y));\n    float sinCamera = sin(2.4 + 2.0 * cos(0.4 * iTime) + 0.0 * (fragCoord.y / iResolution.y));\n    \n    clock = mod(1.0 * iTime, 20.0 * PI);\n    \n    vec3 m = vec3(1.6 * -clock, 0.0, 1.0);\n    \n    float rot = 3.0 + 0.1 * cos(iTime);\n    \n    viewer = m + vec3(rot * cosCamera, 2.0 * sin(0.4 * iTime) + 2.5, rot * sinCamera);\n    target = m + vec3(0.0, 0.5, 0.0);\n    \n    \n    vec3 displacement = vec3(0.0);\n    \n    // Stereo.\n    // if (mod(fragCoord.y, 2.0) > 1.0) displacement.x += 0.02; \n\t// else                                displacement.x -= 0.02;\n    \n    vec3 normal = createRayNormal(\n        viewer,\n        target,\n        vec3(0.0, 1.0, 0.0),\n        (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y,\n        1.6,\n        displacement\n    );\n    \n    hitInfo.type = TYPE_NONE;\n        \n    //mat2 r = getRotation(0.25 * length(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y);\n    vec3 color = traceRay(viewer, normal);\n    //color.rb = r * color.rg;\n   \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdlXDX","date":"1407480277","viewed":409,"name":"Marching glass cubes","username":"CrassulaOvata","description":"Unfinished. Doesn't seem to run properly on some (older?) cards. Not sure if it's a bug or if the shader is simply too complex. It's not very well optimized either. Thanks to Inigo Quilez for comprehensive tutorials and resources :) ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","refraction"],"hasliked":0,"parentid":"","parentname":""}}