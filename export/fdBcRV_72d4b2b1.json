{"ver":"0.1","info":{"id":"fdBcRV","date":"1643934681","viewed":140,"name":"athibaul Music ep1, Precise Time","username":"ttg","description":"athibaul's tutorial, enhanced with fixed-precision sample time - this is the simplest way to avoid the sound degradation that increases with time in most shadertoy Sound shaders that use the \"float t\" parameter.","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["tutorial","music","gpusound"],"hasliked":0,"parentid":"ssjyDD","parentname":"Making Music in Shadertoy - ep1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Making Music in Shadertoy - Episode 1 : Basics, Waveforms, and a Simple Tune\n//\n// See the youtube video for the commentary :\n// https://www.youtube.com/watch?v=3mteFftC7fE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TWOPI 6.2831855\n\nint samples(float t) {return int(round(t*iSampleRate));}\nfloat seconds(int t) {return float(t)/iSampleRate;}\n\n// like mod but for signed integers, uses fiddly integer arithmetic\n// int modsi(int a,int b){ int m=(a<0?~a:a)%b; return a<0?b-1-m:m; }\n\n// suggestion: #define S(t) samples(t)\n\nfloat oscfract(float f, int samp)\n{\n    return fract(f*seconds(samp));\n    // advanced: refine with an \"intfract\" formula\n    // (important for long-lasting (> ~10s) sounds)\n}\n\nfloat oscsin(float f, int samp)\n{\n    return sin(TWOPI*oscfract(f,samp));\n}\n\nfloat sinPluck(float f, int samp)\n{\n    float t = seconds(samp);\n    return oscsin(f,samp)*exp(-3.*t) * 0.1;\n}\n\nfloat squarePluck(float f, int samp)\n{\n    float t = seconds(samp);\n    return sign(oscsin(f,samp))*exp(-3.*t) * 0.1;\n}\n\nfloat sawPluck(float f, int samp)\n{\n    float t = seconds(samp);\n    return (oscfract(f,samp)*2. -1.)*exp(-3.*t) * 0.1;\n}\n\nfloat FM(float fc, float fm, float iom, int samp)\n{\n    return sin(TWOPI*oscfract(fc,samp) + iom*oscsin(fm,samp));\n}\n\nvec2 fmPluck(float f, int samp)\n{\n    float fc = f; // carrier freq\n    float fm = f; // modulation freq\n    float iom = 1.; // index of modulation\n    \n    float t = seconds(samp);\n    float env = exp(-3.*t) * 0.1;\n    vec2 sig = vec2(0);\n    \n    sig.x += FM(f+1., f+1., 1., samp) * env;\n    sig.y += FM(f-1., f-1., 1., samp) * env;\n    sig += FM(f, f, 15., samp) * exp(-20.*t) * 0.03;\n    \n    return sig;\n}\n\nvec2 pan(float pos)\n{\n    vec2 e = vec2(1.-pos, 1.+pos);\n    return normalize(e);\n}\n\nfloat interval(float semitones)\n{\n    return pow(2., semitones/12.);\n}\n\nconst float notes[] = float[6](-12., -5., 2., -5., 3., 5.);\n\nvec2 jingle(int samp)\n{\n    vec2 sig = vec2(0);\n    for(int i=0; i<6; i++)\n    {\n        float nn = notes[i];\n        float fi = 440.*interval(nn);\n        int s0i = samples(0.25)*i;\n        int period = samples(2.);\n        // int si = modsi(samp-s0i,samples(2.)); // \n        int si = (samp-s0i+period)%period;\n        float pos = float((i+1)%3) - 1.;\n        \n        sig += fmPluck(fi, si) * pan(pos);\n    }\n    return sig;\n}\n\nvec2 mainSound( int samp, float t )\n{\n    vec2 sig = vec2(0);\n    \n    /*\n    sig += fmPluck(440., (samp)%samples(1.)) * pan(-0.5);\n    sig += fmPluck(660., (samp - samples(0.25))%samples(1.))  * pan(0.5);\n    */\n    \n    sig += jingle(samp);\n    \n    \n    return sig;\n}\n","name":"Sound","description":"","type":"sound"}]}