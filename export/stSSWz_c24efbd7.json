{"ver":"0.1","info":{"id":"stSSWz","date":"1627504390","viewed":334,"name":"Colorful flipping hexagons","username":"TambakoJaguar","description":"Just had a flash with this crazy idea and the same evening I programmed it. The rotation of the hexagons was quite difficult to program. If you have tips to improve the code, please comment! Thanks!","likes":16,"published":1,"flags":16,"usePreview":0,"tags":["3d","waves","colorful","hexagon","rainbow","trippy","hallucination","pattern","geometric","flying","regular","flipping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Colorful flipping hexagons\" by Emmanuel Keller aka Tambako - July 2021\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n// Switches, you can play with them!\n#define specular\n#define border\n#define specrot\n//#define captmode\n//#define antialias\n\n\n#define pi 3.14159265359\n\n#ifdef captmode\nconst float KEY_1\t\t= 97.5/256.0;\nconst float KEY_2\t\t= 98.5/256.0;\nconst float KEY_3\t\t= 99.5/256.0;\nconst float KEY_4\t\t= 100.5/256.0;\nconst float KEY_5\t\t= 101.5/256.0;\nconst float KEY_6\t\t= 102.5/256.0;\nconst float KEY_7\t\t= 103.5/256.0;\nconst float KEY_8\t\t= 104.5/256.0;\nconst float KEY_9\t\t= 105.5/256.0;\n#endif\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.9;\nconst int aasamples = 2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.8, 0.9, 1.);\nconst float ambientint = 0.07;\n\n// Specular options\nconst float specint = 0.74;\nconst float specshin = 45.;\n\n// Tracing options\nconst float normdelta = 0.01;\nconst float maxdist = 2500.;\n\n// Geometry options\nconst float bg_height = 0.04;\nconst float hex_height = 0.12;\nconst float bg_width0 = 0.08;\nconst float gap_width = 0.055;\nconst float borderpos = 0.22;\nconst float borderwidth = 0.07;\nconst float borderheight = 0.2;\n\nconst float gen_scale = 0.15;\n\n// Color options\nconst float gamma = 1.4;\nconst vec3 sky_color = vec3(0.);\nconst vec3 background_color = vec3(0.3, 0.35, 0.5);\n\n// Campera options\nvec3 campos = vec3(0., 0., 10.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 2.;\n\nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n\nvec3 colors[3];\n   \n// Every object of the scene has its ID\n#define SKY_OBJ         0\n#define BACKGROUND_OBJ  1\n#define HEXAGONS_OBJ    2\n    \nDirLamp lamps[3];\n\nint aai;\nint aaj;\n\nfloat bg_width;\n\nfloat curtime;\n\n#ifdef captmode\nint num_key;\nint isKeyPressed(float key)\n{\n\treturn texture(iChannel0, vec2(key, 0.25) ).x > .0?1:0;\n}\n#endif\n\nvoid init()\n{    \n    lamps[0] = DirLamp(vec3(-2.5, 1., -4.), vec3(1., .95, .55), 1.4);\n    lamps[1] = DirLamp(vec3(2., 3., -4.), vec3(1., 1., 1.), 1.3);\n    lamps[2] = DirLamp(vec3(2., -1., 4.), vec3(0.65, 0.72, 1.), 1.2);\n    \n    #ifdef captmode\n    num_key = isKeyPressed(KEY_1) + 2*isKeyPressed(KEY_2) + 3*isKeyPressed(KEY_3);\n    num_key+= 4*isKeyPressed(KEY_4) + 5*isKeyPressed(KEY_5) + 6*isKeyPressed(KEY_6);\n    num_key+= 7*isKeyPressed(KEY_7) + 8*isKeyPressed(KEY_8) + 9*isKeyPressed(KEY_9);\n    \n    curtime = 14.; \n    #else\n    curtime = iTime;\n    #endif\n    \n       \n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// (2d cell id, distance to border, distance to center)\nvec4 hexagon(vec2 p) \n{\n\tvec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n\t\n\tvec2 ppi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(ppi.x + ppi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4(ppi + ca - cb*ma, e, f);\n}\n\nfloat getAngle(vec4 h)\n{\n    int colnr = int(mod(h.x, 3.));\n    float angle;\n    if (colnr==0)\n        angle = curtime*0.8*(1. + 0.12*sin(curtime*0.4 + h.x*0.04)) + sin(h.x*0.052 + h.y*0.012 + 4.*cos(h.x*0.008 + h.y*0.011)) - cos(h.x*0.015 + h.y*0.032);\n    if (colnr==1)\n        angle = curtime*0.9*(1. + 0.09*sin(curtime*0.3 + h.y*0.05)) + sin(h.x*0.047 + h.y*0.009) + 3.*cos(h.x*0.006 - h.y*0.007) - cos(h.x*0.013 + h.y*0.043);\n    if (colnr==2)\n        angle = curtime*1.05*(1. + 0.15*sin(curtime*0.5 + h.y*0.02)) + sin(h.x*0.056 + h.y*0.016) + 5.*cos(h.x*0.007 + h.y*0.009) - cos(h.x*0.018 + h.y*0.019);\n    return angle*smoothstep(2., 9., curtime);\n    //return 0.4;\n}\n\nfloat map_background(vec3 pos)\n{\n   vec4 h = hexagon(pos.xz);\n   \n   return max(h.z - bg_width/2., abs(pos.y) - bg_height/2.);\n}\n\nfloat map_hexagons(vec3 pos)\n{\n   vec4 h0 = hexagon(pos.xz);\n   \n   #ifdef specrot\n   float colnr = mod(h0.x, 3.);\n   pos.xz = rotateVec(pos.xz, colnr*pi/3.);\n   vec4 h = hexagon(pos.xz);\n   #else\n   vec4 h = h0;\n   #endif\n   \n   float lpx = pos.x - h.x*0.866025;\n   float lpz = pos.z - h.y*1.5;\n   vec3 pos2 = vec3(lpx, pos.y, lpz);\n   \n   float angle = getAngle(h0);\n   //float angle = getAngle(h);\n   pos2.xy = rotateVec(pos2.xy, angle);\n   vec4 h2 = hexagon(vec2(pos2.x, pos.z - h.x*1.5));\n   \n   #ifdef border\n   float borderhf = (1. - borderheight*smoothstep(borderpos, borderpos + borderwidth, h2.z))*(1. - 1.2*smoothstep(0.14, 0.115, h2.z)); \n   #else\n   float borderhf = 1.;\n   #endif\n   \n   float hex = max(-h2.z + bg_width/2. + gap_width, abs(pos2.y) - hex_height/2.*borderhf);\n   return h2.x==0.?hex:1000.;\n}\n\nvec2 map(vec3 pos)\n{\n    bg_width = bg_width0*(1. + 15.*smoothstep(0.5, 1.0, sin(0.008*pos.x*gen_scale + 1.1)*sin(0.008*pos.z*gen_scale - 3.45)));\n\n    float background = map_background(gen_scale*pos);\n    vec2 res = vec2(background, BACKGROUND_OBJ);\n    \n    float hexagons = map_hexagons(gen_scale*pos);\n    res = opU(res, vec2(hexagons, HEXAGONS_OBJ)); \n    \n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = campos.y - 5.;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 180; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.005 || cam.y<2.)\n            break;\n        t+= dist*1.3;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2).x;\n    }\n    return normalize(n);\n}\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    return sky_color;\n}\n\nvec3 getHexagonColor(vec4 h, vec3 pos)\n{\n    colors[0] = vec3(1., 0., 0.);\n    colors[1] = vec3(0., 1., 0.);\n    colors[2] = vec3(0., 0., 1.);\n    \n    int colnr = int(mod(h.x, 3.));\n    vec4 h0 = h;\n    \n    #ifdef specrot\n    pos.xz = rotateVec(pos.xz, float(colnr)*pi/3.);\n    h = hexagon(pos.xz);\n    #endif\n    \n    float lpx = pos.x - h.x*0.866025;\n    float lpz = pos.z - h.x*1.5;\n    vec2 pos2 = vec2(lpx, pos.y);\n   \n    float angle = getAngle(h0);\n    pos2 = rotateVec(pos2, angle);\n    \n    //return colors[colnr];\n    return pos2.y>0.?colors[colnr]:1.-colors[colnr];\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   if (objnr==BACKGROUND_OBJ)\n   {\n      vec3 col = background_color;\n      \n      col.r+= 0.4*smoothstep(0.92, 1.0, sin(0.008*pos.x*gen_scale + 1.1)*sin(0.008*pos.z*gen_scale - 3.45));\n      col.g+= 0.5*smoothstep(0.85, 1.0, sin(0.008*pos.x*gen_scale + 1.1)*sin(0.008*pos.z*gen_scale - 3.45));\n      col.b+= 0.6*smoothstep(0.75, 1.0, sin(0.008*pos.x*gen_scale + 1.1)*sin(0.008*pos.z*gen_scale - 3.45));\n    \n      return col;\n   }\n   else if (objnr==HEXAGONS_OBJ)\n   {\n      vec4 hex = hexagon(gen_scale*pos.xz);\n      return getHexagonColor(hex, gen_scale*pos);\n   }\n   else\n      return getSkyColor(ray);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl = normalize(lamp.direction);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*clamp(dot(norm, pl), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.direction) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   \n   #ifdef captmode\n   iMouse2 = vec2(0.5, 0.05);\n   #else\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 0.05);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   #endif\n  \n   float cc = pow(1. - sin(0.12*curtime), 1.35);\n   campos = vec3(0., 2.5 + 85.*pow(1. - cos(0.12*curtime), 2.2),  -43.*curtime - 270.*cc - 20.*pow(curtime*0.2, 1.3))/gen_scale;\n   //campos = vec3(0., 2.5,  0.)/gen_scale;\n   //campos = vec3(0., 15., -2.*curtime);\n\n   camdir = vec3(3.6*iMouse2.x - 1.75, -3.5*iMouse2.y - 0.6, -1.);   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = getSkyColor(ray);\n    }\n    col*= pow(smoothstep(maxdist, maxdist*0.3, tx), 0.5);\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n    float fov2 = fov;\n    \n    #ifdef captmode\n    if (num_key>0)\n    {\n        fov2*= 3.;\n        uv.x+= 2.*(iResolution.x / iResolution.y)*(mod(float(num_key - 1), 3.) - 1.);\n        uv.y+= 2.*(float((num_key - 1)/3) - 1.);\n    }\n    #endif\n    \n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov2);\n  \tRenderData traceinf = trace0(campos, ray, maxdist/gen_scale);\n  \tvec3 col = traceinf.col;\n    \n  \treturn vec4(pow(col, vec3(gamma)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}","name":"Image","description":"","type":"image"}]}