{"ver":"0.1","info":{"id":"7tffW7","date":"1651221903","viewed":185,"name":"Ray Marching Learning Project","username":"zxy_aaron","description":"Just learning. \nWork done: Draw shapes, smooth merge, build shadows.\nCurrent work: Draw volume clouds.\nPossible future work: lighting model, setting up scene, multi-object coloring, water rendering, physics simulation, anti-aliasing, Ray Traceing.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERESIZE 1.5\n#define SPHEREPOS vec3(0., sin(iTime * 3.) * 1.5, 0.)\n#define PLANESIZE 50.\n#define PLANEPOS vec3(0., 0., 0.)\n#define MAXSTEPS 255\n#define STEP 1.\n#define THRESHOLD 0.001\n#define CAMRANGE 25.\n#define SOFTSHADOWFALLOFF 20.\n#define SMOOTHINTENSITY 1.\n#define BOXPOS vec3(5., 2., 5.)\n#define BOXSIZE vec3(1., 2., 1.)\n#define CLOUDPOS vec3(0., 8., 0.)\n#define CLOUDRANGE vec3(5., 5., 5.) * 1.\n#define CLOUDROT 0.\n#define VOXELSIZE .1\n\nfloat cloudArea;\nvec3 worldPos;\n\nmat3 ident(){\n    return mat3(vec3(1., 0., 0.),\n                vec3(0., 1., 0.),\n                vec3(0., 0., 1.));\n}\n\nmat3 rotatorXAxis(in float dRotation){\n    return mat3(vec3(1., 0., 0),\n                vec3(0., cos(radians(dRotation)), sin(radians(dRotation))),\n                vec3(0., -sin(radians(dRotation)), cos(radians(dRotation))));\n}\n\nmat3 rotatorYAxis(in float dRotation){\n    return mat3(vec3(cos(radians(dRotation)), 0., -sin(radians(dRotation))),\n                vec3(0., 1., 0.),\n                vec3(sin(radians(dRotation)), 0., cos(radians(dRotation))));\n}\n\nfloat sdfSphere(in vec3 pos, in vec3 objectPos, in float size){\n    return distance(pos, objectPos) - (size - (sin(pos.x + iTime * 3.) * .5 + .5) * .5 - (sin(pos.z + iTime * 3.) * .5 + .5) * .5);\n}\n\nfloat sdfPlane(in vec3 pos, in vec3 objectPos, in float size){\n    return pos.y;\n}\n\nfloat sdfBox(in vec3 pos, in vec3 objectPos, in vec3 size){\n    /*vec3 q = abs(pos - objectPos) - size;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);*/\n    vec3 p = abs(pos - objectPos) - size;\n    return max(max(max(p.x, p.z), p.y), 0.);\n\n}\n\nfloat cloudBox(in vec3 pos, in vec3 objectPos, in vec3 size, in mat3 trans){\n    vec3 p = abs(pos - objectPos) - size;\n    //p *= trans;\n    return max(max(max(p.x, p.z), p.y), 0.);\n}\n\nvec2 smoothMerge(in vec2 a, in vec2 b, in float k){\n    vec2 area = pow(max( k - abs(a - b), 0.) / k, vec2(2.)) / 4. * k;\n    return min(a, b) - area;\n}\n\nvec2 sdfScene(in vec3 pos){\n    float wave = sin(distance(pos, SPHEREPOS) / 1.5 - iTime * 3.) * .5 + .5;\n    vec2 sdf = smoothMerge(vec2(sdfBox(pos, BOXPOS, BOXSIZE), 3.), vec2(sdfSphere(pos, SPHEREPOS, SPHERESIZE), SMOOTHINTENSITY), 2.);\n    sdf = smoothMerge(sdf, vec2(sdfBox(pos, BOXPOS - vec3(10., 0., 0.), BOXSIZE), 3.), SMOOTHINTENSITY);\n    sdf = smoothMerge(sdf, vec2(sdfBox(pos, BOXPOS - vec3(5., 0., 12.), BOXSIZE), 3.), SMOOTHINTENSITY);\n    sdf = smoothMerge(sdf, vec2(sdfPlane(pos, PLANEPOS, PLANESIZE), SMOOTHINTENSITY) - wave, 1.);\n    return sdf;\n}\n\nvec4 rayMarching( in vec2 rayRange,in mat3 camTrans, in float camRange, in vec3 camOffset){\n    vec3 rayDirRange = normalize(vec3((rayRange - .5 * iResolution.xy) / min(iResolution.x, iResolution.y), -1.));\n    rayDirRange *= camTrans;\n    float dist;\n    vec3 curPos = vec3(0., 0., camRange) * camTrans + camOffset;\n    vec4 area = vec4(0., 0., 0., 0.);\n    for(int i = 0; i < MAXSTEPS; i++){\n        dist = sdfScene(curPos).x; //min(sdfScene(curPos).x, sdfBox(curPos, CLOUDPOS, CLOUDRANGE));\n        if(dist < THRESHOLD){\n            area.w = 1.;\n            break;\n        }\n        curPos += dist * rayDirRange * STEP;\n    } \n    area.xyz = curPos;\n    worldPos = curPos;\n    if(sdfScene(curPos).x > sdfBox(curPos, CLOUDPOS, CLOUDRANGE)){\n        cloudArea = 2.;\n    }else{\n        cloudArea = 1.;\n    }\n    //area.w = sdfScene(curPos).y;\n    return area;\n}\n\nvec3 getNormal(in vec3 surfacePos){\n    return  normalize(vec3(sdfScene(surfacePos + vec3(.001, 0., 0.)).x - sdfScene(surfacePos - vec3(.001, 0., 0.)).x,\n                           sdfScene(surfacePos + vec3(0., .001, 0.)).x - sdfScene(surfacePos - vec3(0., .001, 0.)).x,\n                           sdfScene(surfacePos + vec3(0., 0., .001)).x - sdfScene(surfacePos - vec3(0., 0., .001)).x));\n}\n\nvec3 lambert(in vec3 lightPos, in vec3 surfaceNormal, in vec3 lightColor, in mat3 lightTrans){\n    vec3 lightDir = normalize(lightPos * lightTrans);\n    return (dot(lightDir, surfaceNormal) * .5 + .5) * lightColor;\n}\n\nfloat shadow(in vec3 worldPos, in vec3 lightPos, in vec3 worldNormal){\n    vec3 rayDir = normalize(lightPos);\n    vec3 curPos = worldPos + 0.001 * worldNormal;\n    float shadow = 1.;//clamp(dot(worldNormal, rayDir) * 2., 0., 1.);\n    float curDis, goneDis;\n    for(int  i = 0; i < MAXSTEPS; i++){\n        curDis = min(sdfScene(curPos).x, sdfBox(curPos, CLOUDPOS, CLOUDRANGE));\n        if(curDis < 0.001){\n            shadow = 0.;\n            break;\n        }\n        shadow = min(shadow,  SOFTSHADOWFALLOFF * curDis / goneDis);\n        curPos += curDis * rayDir;\n        goneDis = clamp(curDis + goneDis, 0., 20.);\n    }\n    return shadow; // * dot(worldNormal, rayDir) * .5 + .5;\n}\n\nfloat cloudScatter(in vec3 pos){\n    float texScale = 0.05;\n    float density = texture(iChannel0, pos * texScale).x;\n    return density;\n}\n\nvec4 cloud(in vec2 rayRange, in mat3 camTrans, in float camRange, in vec3 camOffset, in float voxelSize, in float coverageScale){\n    float sum = 0.;\n    vec3 color = vec3(1.);\n    vec3 camPos = vec3(0., 0., camRange) * camTrans + camOffset;\n    vec3 rayDirRange = normalize(vec3((rayRange - .5 * iResolution.xy) / min(iResolution.x, iResolution.y), -1.));\n    rayDirRange *= camTrans;\n    vec3 curPos = cloudBox(camPos, CLOUDPOS,CLOUDRANGE, rotatorXAxis(CLOUDROT)) * rayDirRange + camPos;\n    for(int i = 0; i < MAXSTEPS; i++){\n        if(cloudBox(curPos, CLOUDPOS,CLOUDRANGE, rotatorXAxis(CLOUDROT)) < THRESHOLD){\n            if(cloudBox(curPos, CLOUDPOS,CLOUDRANGE, rotatorXAxis(CLOUDROT)) > THRESHOLD || distance(worldPos, camPos) < distance(curPos, camPos)){\n                break;\n            }\n            sum += coverageScale * cloudScatter(curPos);\n            color *= vec3(exp(-cloudScatter(curPos) * voxelSize));\n            curPos += voxelSize * rayDirRange;\n        }else{\n            curPos += cloudBox(curPos, CLOUDPOS,CLOUDRANGE, rotatorXAxis(CLOUDROT)) * rayDirRange;\n        }\n        \n    }\n    return vec4(sum * color, sum);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    mat3 camTrans = rotatorXAxis(20.) * rotatorYAxis(0. + iTime * 50.);\n    float camRange = CAMRANGE;\n    vec3 camOffset = vec3(0., 4., 0.);\n    vec3 camPos = vec3(0., 0., camRange) * camTrans + camOffset;\n    float sceneSDF = rayMarching(fragCoord, camTrans, camRange, camOffset).w;\n    vec3 worldNormal = getNormal(worldPos);\n    mat3 lightTrans = ident();\n    vec3 lightPos = vec3(5., 5., 5.) * lightTrans;\n    vec3 light = lambert(lightPos, worldNormal, vec3(1.), ident());\n    float amb = (dot(worldNormal, vec3(0., 1., 0.)) * 0.5 + 0.5);// * min(sceneSDF.w, 1.);\n    float shadow = shadow(worldPos, lightPos, worldNormal);\n    vec3 col = clamp(light * shadow * amb, 0., 1.);\n    col = mix( col, vec3(0.8, 0.9, 1.), min(pow(distance(worldPos, camPos) / 100., .3), 1.));\n    vec4 cloud = cloud(fragCoord, camTrans, camRange, camOffset, VOXELSIZE, 0.02);\n    col = mix(pow(col, vec3(2.2)), cloud.xyz, cloud.w);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}