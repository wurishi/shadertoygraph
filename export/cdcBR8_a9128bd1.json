{"ver":"0.1","info":{"id":"cdcBR8","date":"1696821084","viewed":124,"name":"Simple 2D Black Hole","username":"DominicKarma","description":"Just a simple black hole in a 2D environment. Far from realistic of course, but still interesting.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["blackhole","gravitationallensing","accretiondisk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define constants.\nconst float distortionStrength = 1.0;\nconst float maxLensingAngle = 28.3;\nconst float blackRadius = 0.15;\nconst float edgeBrightnessFactor = 2.04;\n\n// Define colors.\nconst vec3 brightColor1 = vec3(0.95, 0.87, 0.75);\nconst vec3 brightColor2 = vec3(0.966, 0.91, 0.84);\nconst vec3 accretionDiskFadeColor = vec3(1.0, 0.67, 0.2);\n\n// Define dynamic globals.\nvec2 sourcePosition;\nvec2 aspectRatioCorrectionFactor;\n\n// Utility from HLSL. Clamps an input to a 0-1 range.\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\n// Inverse of the lerp/mix function. Useful for getting back the 0-1 interpolant from a given input range.\n// The resulting interpolant cannot extend beyond the 0-1 range, even if the inputs are outside of their expected provided bounds.\nfloat inverseLerp(float from, float to, float x)\n{\n    return saturate((x - from) / (to - from));\n}\n\nvec2 vectorNoise(vec2 coords)\n{\n    // Sample from the noise texture and interpret the results as an angle.\n    float angle = texture(iChannel0, coords).x * 16.03;\n    \n    // Convert the aforementioned angle into a 0-1 range vector.\n    return vec2(cos(angle), sin(angle)) * 0.5 + 0.5;\n}\n\n// Rotates a vector by a given angle.\n// This is based on the Z rotation matrix, but simplified.\nvec2 rotatedBy(vec2 v, float theta)\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nfloat calculateGravitationalLensingAngle(vec2 uv)\n{\n    // Calculate how far the given pixel is from the source of the distortion. This autocorrects for the aspect ratio resulting in\n    // non-square calculations.\n    float distanceToSource = max(distance((uv - 0.5) * aspectRatioCorrectionFactor + 0.5, sourcePosition), 0.0);\n    \n    // Calculate the lensing angle based on the aforementioned distance. This uses distance-based exponential decay to ensure that the effect\n    // does not extend far past the source itself.\n    return distortionStrength * maxLensingAngle * exp(-distanceToSource / blackRadius * 2.0);\n}\n\nvec4 applyColorEffects(vec4 color, float gravitationalLensingAngle, vec2 uv, vec2 distortedUV)\n{\n    // Calculate offset values based on noise.\n    vec2 uvOffset1 = vectorNoise(distortedUV + vec2(0, iTime * 0.8));\n    vec2 uvOffset2 = vectorNoise(distortedUV * 0.4 + vec2(0, iTime * 0.7));\n    \n    // Calculate color interpolants. These are used below.\n    // The black hole uses a little bit of the UV offset noise for calculating the edge boundaries. This helps make the effect feel a bit less\n    // mathematically perfect and more aesthetically interesting.\n    float offsetDistanceToSource = max(distance((uv - 0.5) * aspectRatioCorrectionFactor + 0.5, sourcePosition + uvOffset1 * 0.004), 0.0);\n    float blackInterpolant = inverseLerp(blackRadius, blackRadius * 0.85, offsetDistanceToSource);\n    float brightInterpolant = pow(inverseLerp(blackRadius * (1.01 + uvOffset2.x * 0.1), blackRadius * 0.97, offsetDistanceToSource), 1.6) * 0.6 + gravitationalLensingAngle * 7.777 / maxLensingAngle;\n    float accretionDiskInterpolant = inverseLerp(blackRadius * 1.93, blackRadius * 1.3, offsetDistanceToSource) * (1.0 - brightInterpolant);\n    \n    // Calculate the inner bright color. This is the color used right at the edge of the black hole itself, where everything is burning due to extraordinary amounts of particle friction.\n    vec4 brightColor = vec4(mix(brightColor1, brightColor2, uvOffset1.y), 1) * edgeBrightnessFactor;\n    \n    // Interpolate towards the bright color first.\n    color = mix(color, brightColor, saturate(brightInterpolant) * distortionStrength);\n    \n    // Interpolate towards the accretion disk's color next. This is what is drawn a bit beyond the burning bright edge. It is still heated, but not as much, and as such is closer to an orange\n    // glow than a blazing yellowish white.\n    color = mix(color, vec4(accretionDiskFadeColor, 1), accretionDiskInterpolant * distortionStrength);\n    \n    // Lastly, place the black hole in the center above everything.\n    color = mix(color, vec4(0, 0, 0, 1), blackInterpolant * distortionStrength);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Calculate dynamic global values.\n    aspectRatioCorrectionFactor = vec2(iResolution.x / iResolution.y, 1.0);\n    sourcePosition = vec2(0.5, cos(iTime * 4.3) * 0.2 + 0.5);\n    \n    // Calculate the gravitational lensing angle and the coordinates that result from following its rotation.\n    // This roughly follows the mathematics of relativistic gravitational lensing in the real world, albeit with a substitution for the impact parameter:\n    // https://en.wikipedia.org/wiki/Gravitational_lensing_formalism\n    float gravitationalLensingAngle = calculateGravitationalLensingAngle(uv);\n    vec2 distortedUV = rotatedBy(uv - 0.5, gravitationalLensingAngle) + 0.5;\n    \n    // Calculate the colors based on the above information, and supply them to the output color.\n    fragColor = applyColorEffects(texture(iChannel1, distortedUV), gravitationalLensingAngle, uv, distortedUV);\n}","name":"Image","description":"","type":"image"}]}