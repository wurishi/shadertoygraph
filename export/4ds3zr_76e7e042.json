{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// voxels!\n// @simesgreen\n\n// CSG operations\nfloat _union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat diff(float a, float b)\n{\n    return max(a, -b);\n}\n\n// primitive functions\n// these all return the distance to the surface from a given point\n\nfloat plane(vec3 p, vec3 planeN, vec3 planePos)\n{\n    return dot(p - planePos, planeN);\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xz);\n    return dot(c, vec2(q, p.y));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\n// distance to scene\nfloat scene(vec3 p)\n{\t\n    float d;\n    //d = box(p, vec3(1.0));\n    //p.z += sin(time)*1.5;\n    //d = diff( d, sphere(p, sin(time*0.5)*1.5) );\n\t\n    //d = sphere(p, 1.0);\t\n    d = sphere(p, sin(iTime)*0.5+0.5);\n\n    vec3 pr = p - vec3(1.5, 0.0, 0.0);\n    pr = rotateX(pr, iTime);\n    pr = rotateY(pr, iTime*0.3);\t\n    d= _union(d, diff(box(pr , vec3(0.6)), sphere(pr, 0.7)) );\n\n    //d = _union(d, sdCone(p + vec3(1.5, -0.5, 0.0), vec2(1.0, 0.5)));\n    pr = p + vec3(1.5, 0.0, 0.0);\n    pr = rotateX(pr, iTime);\n    d = _union(d, sdTorus(pr, vec2(0.5, 0.25)));\n\t\n    d = _union(d, plane(p, vec3(0.0, 1.0, 0.0), vec3(0.0, -1.0, 0.0)) );\n    return d;\n}\n\n// calculate scene normal\nvec3 sceneNormal(vec3 pos )\n{\n    float eps = 0.0001;\n    vec3 n;\n#if 0\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - scene( vec3(pos.x-eps, pos.y, pos.z) );\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - scene( vec3(pos.x, pos.y-eps, pos.z) );\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - scene( vec3(pos.x, pos.y, pos.z-eps) );\n#else\n    float d = scene(pos);\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - d;\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - d;\n#endif\n    return normalize(n);\n}\n\n// ambient occlusion approximation\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 3;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - scene(p + n*d));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos)\n{\n    const vec3 lightPos = vec3(4.0, 3.0, 5.0);\n    const vec3 color = vec3(1.0, 1.0, 0.0);\n    const float shininess = 40.0;\n\n    vec3 l = normalize(lightPos - pos);\n    vec3 v = normalize(eyePos - pos);\n    vec3 h = normalize(v + l);\n    float diff = dot(n, l);\n    float spec = max(0.0, pow(dot(n, h), shininess)) * float(diff > 0.0);\n    diff = max(0.0, diff);\n    //diff = 0.5+0.5*diff;\n\n    float fresnel = pow(1.0 - dot(n, v), 5.0);\n    float ao = ambientOcclusion(pos, n);\n\n//\treturn vec3(diff);\n//    return vec3(diff*ao)*color + vec3(spec + fresnel*0.5);\n    return vec3(diff*ao)*color;\t\n//    return vec3(diff*ao)*color + vec3(spec);\n//    return vec3(ao);\n//    return vec3(fresnel);\n}\n\n// trace ray using sphere tracing\nvec3 trace(vec3 ro, vec3 rd, out bool hit)\n{\n    const int maxSteps = 128;\n    const float hitThreshold = 0.001;\n    hit = false;\n    vec3 pos = ro;\n    vec3 hitPos = ro;\n\n    for(int i=0; i<maxSteps; i++)\n    {\n        float d = scene(pos);\n\t//d = max(d, 0.000001);\n        if (d < hitThreshold) {\n            hit = true;\n            hitPos = pos;\n            //return pos;\n        }\n        pos += d*rd;\n    }\n    return hitPos;\n}\n\n// Amanatides & Woo style voxel traversal\nconst vec3 voxelSize = vec3(0.1); // in world space\n//const vec3 voxelSize = vec3(0.2);\n\nvec3 worldToVoxel(vec3 i)\n{\n    return floor(i/voxelSize);\n}\n\nvec3 voxelToWorld(vec3 i)\n{\n    return i*voxelSize;\t\n}\n\nvec3 voxelTrace(vec3 ro, vec3 rd, out bool hit, out vec3 hitNormal)\n{\n    const int maxSteps = 64;\n    const float isoValue = 0.0;\n\n    vec3 voxel = worldToVoxel(ro);\n    vec3 step = sign(rd);\n\n    vec3 nearestVoxel = voxel + vec3(rd.x > 0.0, rd.y > 0.0, rd.z > 0.0);\n    vec3 tMax = (voxelToWorld(nearestVoxel) - ro) / rd;\n    vec3 tDelta = voxelSize / abs(rd);\n\n    vec3 hitVoxel = voxel;\n\t\n    hit = false;\n    float hitT = 0.0;\n    for(int i=0; i<maxSteps; i++) {\n        float d = scene(voxelToWorld(voxel));        \n        if (d <= isoValue && !hit) {\n            hit = true;\n\t    \thitVoxel = voxel;\n            //break;\n        }\n\n        if (tMax.x < tMax.y && tMax.x < tMax.z) { \n            voxel.x += step.x;\n            tMax.x += tDelta.x;\n\t\t\tif (!hit) {\n\t\t\t\thitNormal = vec3(-step.x, 0.0, 0.0);\n\t\t\t\thitT = tMax.x;\n\t\t\t}\n        } else if (tMax.y < tMax.z) {\n            voxel.y += step.y;\n            tMax.y += tDelta.y;\n\t\t\tif (!hit) {\n\t\t\t\thitNormal = vec3(0.0, -step.y, 0.0);\t\t\n\t\t\t\thitT = tMax.y;\n\t\t\t}\n        } else {\n            voxel.z += step.z;\n            tMax.z += tDelta.z;\n\t\t\tif (!hit) {\n\t\t\t\thitNormal = vec3(0.0, 0.0, -step.z);\t\t\n\t\t\t\thitT = tMax.z;\n\t\t\t}\n        }\n     \n#if 0\n        if ((voxel.x < 0) || (voxel.x >= size.width) ||\n            (voxel.y < 0) || (voxel.y >= size.height) ||\n            (voxel.z < 0) || (voxel.z >= size.depth)) {\n            break;            \n        }\n#endif\t    \n    }\n\n    //return voxelToWorld(hitVoxel);\n\treturn ro + hitT*rd;\n}\n\n\nvec3 background(vec3 rd)\n{\n     //return mix(vec3(1.0), vec3(0.0), rd.y);\n     return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.5, 1.0), abs(rd.y));\n     //return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    ro += rd*2.0;\n\t\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\tvec2 a = vec2(0.0, 0.0);\n\tif (iMouse.x > 0.0) {\n\t\ta.x = -(1.0 - mouse.y)*1.5;\n\t    a.y = 4.5 -(mouse.x-0.5)*3.0;\n\t}\n\t\n    rd = rotateX(rd, a.x);\n    ro = rotateX(ro, a.x);\n\t\t\n    rd = rotateY(rd, a.y);\n    ro = rotateY(ro, a.y);\n\n    // trace ray\n    bool hit;\n    //vec3 pos = trace(ro, rd, hit);\n    vec3 n;\n    vec3 pos = voxelTrace(ro, rd, hit, n);\n\n    vec3 rgb;\n    if(hit)\n    {\n        // calc normal\n        //vec3 n = sceneNormal(pos);\n\t    \n        // shade\n        rgb = shade(pos, n, ro);\n\n#if 0\n        // reflection\n        vec3 v = normalize(ro - pos);\n        float fresnel = 0.1 + 0.9*pow(1.0 - dot(n, v), 5.0);\n\n        ro = pos + n*0.2; // offset to avoid self-intersection\n        rd = reflect(-v, n);\n        //pos = trace(ro, rd, hit);\n\t\tpos = voxelTrace(ro, rd, hit, n);\n\t    \n        if (hit) {\n            //vec3 n = sceneNormal(pos);\n            rgb += shade(pos, n, ro) * vec3(fresnel);\n        } else {\n            rgb += background(rd) * vec3(fresnel);\n        }\n#endif \n\n     } else {\n        rgb = background(rd);\n     }\n\n    // vignetting\n    //rgb *= 0.5+0.5*smoothstep(2.0, 0.5, dot(pixel, pixel));\n\n    fragColor=vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ds3zr","date":"1361793646","viewed":6667,"name":"voxels","username":"simesgreen","description":"ray casting some simple voxel shapes","likes":84,"published":1,"flags":0,"usePreview":0,"tags":["voxels","raycasting"],"hasliked":0,"parentid":"","parentname":""}}