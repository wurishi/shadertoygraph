{"ver":"0.1","info":{"id":"7lBczR","date":"1649074468","viewed":55,"name":"RayTracing Spheres PGA","username":"UpgradeYourPisi","description":"Delivery 1 - Marc Ariza Alborni","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["delivery1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//MADE BY MARC ARIZA ALBORNI\n\n\nstruct Sphere {\n    vec3  center;   // position\n    float radius;   // radius\n    vec3  color; // color\n    float R0;  // base reflectance\n    float R1;\n    float R2;\n    int id; //identifier for ball\n};\n\nstruct Light{\n\n    vec3 direction;\n    vec3 color;\n};\n\nstruct Hit { // If castRay hits a surface, this contains the hit info\n    float hitDistance; // distance from ray origin to first intersection\n    vec3 position;  // hit surface position\n    vec3  normal;  // hit surface normal\n    vec3 color;// hit surface color\n    float R0;// hit surface base reflectance\n    float R1; //Refraction\n    float R2; //Specular\n};\n\n\nLight light=Light(vec3(0.5),vec3(0.3));\n\n Sphere spheres[3] = Sphere[3](\n    Sphere(vec3(-0.7, 0.5, 0.5), 0.5, vec3(0.9, 0.2, 0.1), 0.01,0.2,160.0,1), //left\n    Sphere(vec3(0.7, 0.0, 0.2),   0.5, vec3(0.0, 0.8, 0.2), 0.04,0.2,160.0,2), //right\n    Sphere(vec3(0.0, 0.7, -0.7),  0.5, vec3(0.2, 0.0, 0.7), 0.24,0.2,160.0,3) //center\n    \n    \n    );\n    \n#define NUM_OCTAVES 5\n\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvec4 BrownieMotionNoise(vec2 fragCoord){\n\nfloat noiseVal=(fbm(1999.+fragCoord*0.01));\n  return vec4(noiseVal,noiseVal,noiseVal,1.0);\n\n}\n\nvec3 DoSpecular(vec3 ray,Hit hit){\n\n    vec3 reflectRay = reflect(normalize(-light.direction),hit.normal);\n    \n    float specular=dot(-normalize(reflectRay),ray);\n\n\n    specular=clamp(specular,0.0,1.0);\n    specular=pow(specular,hit.R2);\n\n    return vec3(1.0)*specular;\n\n}\n\nvec3 CalculateRay(vec2 fragCoord,vec3 originPos){\n\n\n  vec3 zAxis=normalize(vec3(0.0)-originPos);\n  vec3 xAxis=cross(zAxis,normalize(vec3(0.0,1.0,0.0)));\n  vec3 yAxis=cross(xAxis,zAxis);\n\n  float cameraDistance=3.;\n  vec3 viewportCenter=cameraDistance*zAxis+originPos;\n  \n  \n\n\n  vec2 uv= fragCoord/iResolution.xy;\n  float ar=iResolution.x/iResolution.y;\n \n  uv=uv*2.0-1.0;\n  \n  uv.x*=ar;\n  \n  viewportCenter+= uv.x*xAxis;\n  viewportCenter+= uv.y*yAxis;\n  \n  \n \n  \n  vec3 final=vec3(viewportCenter);\n  \n  vec3 ray=normalize(final-originPos);\n  \n  return ray;\n\n}\n\n\nvec3 SkyGradient(vec3 ray){\n\n\n  vec3 topColor=vec3(0.2,0.4,1.0);\n  vec3 midColor=vec3(0.85,0.9,1.0);\n  \n \n  \n  float clampVal=clamp(ray.y,0.0,1.0);\n  \n  vec3 mergeColor =mix(midColor,topColor,clampVal);\n  \n  return mergeColor;\n \n}\n\nvec3 CheckerBoard(vec2 fragCoord)\n{\n\n    float size = 0.5f;\n    vec2 position = floor(fragCoord / size);\n    float checkers = mod(position.x + position.y, 2.0);\n\n    return  checkers * vec3(1.0, 1.0, 1.0);\n\n}\n\nbool IntesectWithPlane( in vec3 originPos, in vec3 ray,out Hit hit){\n\n    float plane=-0.5;\n    float t= (plane-originPos.y)/ray.y;\n    hit.hitDistance=t;\n    hit.position= originPos+ray* hit.hitDistance;\n    hit.color= CheckerBoard(hit.position.xz);\n    hit.normal=vec3(0.0,1.0,0.0);\n   \n   //PLANE REFLECTION\n    hit.R0=0.2;\n    hit.R1=0.1;\n    hit.R2=160.0;\n    \n   if(t<=0.0){\n   \n     return false;\n   }\n  \n     return true;\n   \n}\n\nbool IntersectWithSky( in vec3 originPos, in vec3 ray,out Hit hit){\n\n    float plane=100.0;\n    float t= (plane-originPos.y)/ray.y;\n    hit.hitDistance=t;\n    hit.position= originPos+ray* hit.hitDistance;\n    hit.color= mix(SkyGradient(ray),\n    vec3(1.0),\n    vec3(BrownieMotionNoise(hit.position.xz)));\n    hit.normal=vec3(0.0,1.0,0.0);\n   \n    hit.R0=0.2;\n    hit.R1=0.1;\n    hit.R2=160.0;\n    \n   if(t<=0.0){\n   \n     return false;\n   }\n  \n     return true;\n   \n}\n\nbool IntersectWithSpheres(in vec3 originPos, in vec3 ray,out Hit hit,in Sphere sphere){\n\n\n   \n\n\n  sphere.center.y= pow(abs(cos(2.0 * iTime +  sphere.center.y)),0.7);\n\n\n   vec3 oc=sphere.center-originPos;\n   float distanceOC=dot(oc,ray);\n   \n   vec3 k= originPos+(distanceOC*ray);\n   \n   vec3  ck=sphere.center-k;\n   float distanceCK=length(ck);\n   float distancePoint=sqrt((sphere.radius*sphere.radius) - (distanceCK*distanceCK));\n   \n   float t= distanceOC-distancePoint;\n   \n   vec3 intersectPoint=originPos+(t*ray);\n  \n   hit.position=intersectPoint;\n  \n   hit.hitDistance=t;\n \n   hit.color= sphere.color;\n    \n   hit.normal=normalize(hit.position-sphere.center);\n   \n   hit.R0=sphere.R0;\n   hit.R1=sphere.R1;\n   hit.R2=sphere.R2;\n   \n   \n   if(t>0.0){\n   \n     return true;\n   }\n   \n   return false;\n  \n}\n\nbool CheckNearestSphere(in vec3 originPos, in vec3 ray,out Hit hit){\n\n    bool check=false;\n\n    Hit nearestHit;\n    nearestHit.hitDistance=-1.0;\n\n    for(int i=0;i<3;++i){\n    \n          if(IntersectWithSpheres(originPos,ray,hit,spheres[i])){\n          \n              check=true;\n              \n              \n              if((nearestHit.hitDistance<0.0) || (nearestHit.hitDistance>distance(hit.position,originPos))){\n              \n                  nearestHit=hit;\n              \n              }\n          }\n    \n    \n    \n    }\n\n    if(check==true){\n    \n        hit=nearestHit;\n        return true;\n\n    }\n    \n    return false;\n\n}\n\nbool CalculateRayShadow(in vec3 originPos, in vec3 ray,out Hit hit){\n\n\n\n     if(CheckNearestSphere(originPos,ray,hit)){\n \n \n         hit.color=vec3(0.0);//,vec3(1.0),0.3);\n         \n         return true;\n \n     }\n     \n     return false;\n  \n}\n\n\n\n\nbool IntersectWithEverything(in vec3 originPos, in vec3 ray,out Hit hit){\n\n    Hit planeHit;\n    Hit sphereHit;\n    Hit shadowHit;\n    Hit skyHit;\n\n   bool hasHitPlane=false;\n   bool hasHitSphere=false;\n   bool hasHit=false;\n   \n   vec3 whiteCol=vec3(1.0);\n\n    if(IntesectWithPlane(originPos+vec3(0.001)*ray,ray,planeHit)){\n        \n        hasHitPlane=true;\n        hasHit=true;\n        \n        planeHit.color+=light.color*dot(planeHit.normal,light.direction);\n          planeHit.color=mix(planeHit.color,whiteCol,0.1);\n    }\n    if(CheckNearestSphere(originPos+vec3(0.001)*ray,ray,sphereHit)){\n    \n        \n         hasHitSphere=true;\n         hasHit=true;\n         sphereHit.color+=mix(light.color,vec3(0.0),0.3)*dot(sphereHit.normal,light.direction);\n         \n         //sphereHit.color=mix(sphereHit.color,whiteCol,0.1);\n         \n         \n         \n         sphereHit.color+=DoSpecular(ray,sphereHit);\n         \n         \n    }\n    \n    \n    \n    \n    if(hasHitSphere==true && hasHitPlane==false ){\n     \n      hit=sphereHit;\n      \n      \n     \n      if(CalculateRayShadow(hit.position+vec3(-0.001),normalize(light.direction),shadowHit)){\n      \n      \n         //hit.color=mix(shadowHit.color,hit.color,0.5);\n         \n         \n        \n      }\n     \n    }\n    else if(hasHitSphere==false && hasHitPlane==true ){\n     \n     \n       hit=planeHit;\n       \n         if(CalculateRayShadow(hit.position+vec3(-0.001),normalize(light.direction),shadowHit)){\n      \n      \n                   hit.color=mix(shadowHit.color,hit.color,0.5);\n                   \n                   \n                     \n              }\n    }\n     \n    else if(hasHitSphere == true && hasHitPlane == true){\n    \n       \n        \n        if(planeHit.hitDistance>sphereHit.hitDistance){\n        \n            hit=sphereHit;\n            \n             if(CalculateRayShadow(hit.position+vec3(-0.001),normalize(light.direction),shadowHit)){\n      \n      \n                   //hit.color=mix(shadowHit.color,hit.color,0.5);\n                   \n                   \n                     \n              }\n         \n            \n        }\n        else{\n        \n             hit=planeHit;\n             \n               if(CalculateRayShadow(hit.position+vec3(-0.001),normalize(light.direction),shadowHit)){\n      \n      \n                  hit.color=mix(shadowHit.color,hit.color,0.5);\n                   \n                   \n                     \n              }\n        }\n    }\n\n   \n    else{\n    \n     hasHit=false;\n    \n   \n     IntersectWithSky(originPos,ray,skyHit);\n    \n    hit=skyHit;\n    \n    }\n\n  return hasHit;\n}\nvec3 DoFresnel(vec3 ray,Hit hit, float index){\n\n    float r;          \n    r = index + (1.0-index)*pow(1.0-dot(hit.normal,-ray),5.0); \n    return vec3(r);\n\n}\nvec3 AddReflection(in vec3 ray,in Hit hit){\n\n\n    vec3 reflectRay=reflect(ray,hit.normal);\n   \n    vec3 color;\n \n  \n     if(IntersectWithEverything(hit.position,reflectRay,hit)){\n\n       color=hit.color;\n   \n     }\n     else{\n     \n     color = SkyGradient(ray);\n     }\n       \n  \n   return color;\n \n\n}\n\n\nvec3 AddRefraction(in vec3 ray,in Hit hit){\n\n\n    vec3 refractRay=refract(ray,hit.normal,hit.R1);\n   \n    vec3 color;\n \n  \n     if(IntersectWithEverything(hit.position,refractRay,hit)){\n\n       color=hit.color;\n   \n     }\n     else{\n     \n       color = SkyGradient(ray);\n     }\n       \n  \n   return color;\n \n\n}\n\n\nvec3 BackgroundDraw(vec2 fragCoord){\n\n  vec3 ColorRet;\n  vec3 originPos=vec3(0.0,0.0,2.0);\n  \n  float alpha;         \n  alpha += iTime * 0.5;         \n  float betha;         \n  betha = 45.0 * 0.0174533;        \n  float pi = 3.14159265359;         \n  originPos = vec3((cos(alpha)*2.*pi)*(cos(betha)*pi/2.),sin(betha),(sin(alpha)*2.*pi)*(cos(betha)*pi/2.));\n  \n  \n  vec3 ray=CalculateRay(fragCoord,originPos);\n  \n  vec3 colorReflect;\n  vec3 colorRefract;\n  vec3 colorFresnelReflect;\n  vec3 colorFresnelRefract;\n  vec3 colorAmbient=vec3(0.0);\n  \n  \n  \n    Hit hit;\n  if(IntersectWithEverything(originPos,ray,hit)){\n  \n    colorReflect=AddReflection(ray,hit);\n    colorRefract=AddRefraction(ray,hit);\n    \n    \n    colorFresnelReflect=DoFresnel(ray,hit,hit.R0);\n    colorFresnelRefract=DoFresnel(ray,hit,hit.R1);\n    \n    colorReflect=mix(hit.color,colorReflect,colorFresnelReflect);\n    colorRefract=mix(hit.color,colorRefract,colorFresnelRefract);\n    \n   \n    ColorRet=mix(colorReflect,colorRefract,0.2);\n    \n    \n  }\n  else{\n  \n    ColorRet = SkyGradient(ray);\n  }\n  \n  ColorRet+=colorAmbient*0.12;\n  \n  return ColorRet;\n}\n\nvec3 DoAA(vec2 fragCoord){\n\n    vec3 aa=\n    BackgroundDraw(vec2(fragCoord.x+0.5,fragCoord.y))\n    +BackgroundDraw(vec2(fragCoord.x-0.5,fragCoord.y))\n    +BackgroundDraw(vec2(fragCoord.x,fragCoord.y+0.5))\n    +BackgroundDraw(vec2(fragCoord.x,fragCoord.y-0.5));\n\n    aa*=0.25;\n    \n    \n    return aa;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(DoAA(fragCoord),1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}