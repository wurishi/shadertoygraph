{"ver":"0.1","info":{"id":"wtKSDm","date":"1583008910","viewed":55,"name":"Ray March 6","username":"baksej","description":"Ray March 6","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void pR(inout vec2 p, float a) {\n    p = cos(a) * p + sin(a) * vec2(p.y, - p.x);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat map(float v, float a, float b, float x, float y) {\n    float n = (v - a) / (b - a);\n    return x + n * (y - x);\n}\n\nfloat ground(vec3 pos) {\n    return pos.y;\n    \n}\nfloat samplesTaken = 0.0;\n\nfloat scene(vec3 pos) {\n    samplesTaken += 1.0 ;\n    vec3 i = floor(pos / 0.2);\n    \n    vec3 pos1 = pos;\n    \n    float s1 = sphere(pos1, 0.2);\n    \n    vec3 pos2 = pos;\n    pos2.y += 30.0 + 0.1;\n    pos2.z -= 1.0;\n    float s2 = sphere(pos2, 30.0);\n    \n    return smin(s1, s2, 0.15);\n}\n\nvec3 estimateNormal(vec3 pos) {\n    \n    return normalize(\n        vec3(\n            scene(pos - vec3(0.001, 0.0, 0.0)) - scene(pos + vec3(0.001, 0.0, 0.0)),\n            scene(pos - vec3(0.0, 0.001, 0.0)) - scene(pos + vec3(0.0, 0.001, 0.0)),\n            scene(pos - vec3(0.0, 0.0, 0.001)) - scene(pos + vec3(0.0, 0.0, 0.001))\n            \n        ));\n    }\n    \n    float softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float w)\n    {\n        float s = 1.0;\n        for(float t = mint; t < maxt; )\n        {\n            float h = scene(ro + rd * t);\n            s = min(s, 0.5 + 0.5 * h / (w * t));\n            if (s < 0.0)break;\n            t += clamp(h, 0.01, 1.0);\n        }\n        s = max(s, 0.0);\n        return s * s*(3.0 - 2.0 * s); // smoothstep\n    }\n    \n    // https://iquilezles.org/articles/rmshadows\n    // float improvedSoftShadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k)\n    // {\n        //     float res = 1.0;\n        //     float ph = 1e20;\n        //     for(float t = mint; t < maxt; )\n        //     {\n            //         float h = scene(ro + rd * t);\n            //         if (h < 0.001)return 0.0;\n            //         float y = h*h / (2.0 * ph);\n            //         float d = sqrt(h * h-y * y);\n            //         res = min(res, k * d / max(0.0, t - y));\n            //         ph = h;\n            //         t += clamp(h, 0.01, 1.0);\n        //     }\n        //     return res;\n    // }\n    vec3 lightOrigin = vec3(-0.3, 0.6, - 0.3);\n    \n    vec3 shade(vec3 pos) {\n        float falloff = 0.4;\n        vec3 albedo = vec3(1.0);\n        vec3 diffuseColor = vec3(1.0, 0.8, 0.6);\n        vec3 ambientColor = vec3(0.1, 0.1, 0.2);\n        \n        vec3 lightDir = normalize(pos - lightOrigin);\n        float lightIntensity = 1.0 - pow(length(pos - lightOrigin) * falloff, 2.0);\n        vec3 normal = estimateNormal(pos);\n        float diffuse = clamp(dot(lightDir, normal), 0.0, 1.0);\n        \n        float s = softshadow(pos, lightOrigin, 0.01, 3.0, 0.3);\n        \n        return albedo * (diffuseColor * diffuse * lightIntensity * s + ambientColor);\n    }\n    \n    vec3 trace(vec3 rayOrigin, vec3 rayDir, out float t) {\n        const int maxSteps = 256;\n        const float mint = 0.1;\n        const float maxt = 10.0;\n        \n        for(t = mint; t < maxt; ) {\n            vec3 pos = rayOrigin + rayDir * t;\n            float h = scene(pos);\n            if (h < 0.001) {\n                return shade(pos);\n                //return vec3(0.0);\n            }\n            t += clamp(h, 0.001, 1.0);\n            \n        }\n        return vec3(0.0);\n        \n    }\n    \n    void mainImage(out vec4 fragColor, in vec2 fragCoord)\n    {\n        // set up uv coords\n        vec2 uv = fragCoord / iResolution.xy;\n        uv = uv * 2.0 - 1.0;\n        uv.y /= iResolution.x / iResolution.y;\n        \n        // position lights\n        lightOrigin = vec3(sin(iTime), 0.6, - 0.3);\n        \n        // position camera\n        vec3 camOrigin = vec3(0.0, 0.5, - 3.0);\n        vec3 rayOrigin = vec3(camOrigin.xy + uv, camOrigin.z + 3.0);\n        vec3 dir = normalize(rayOrigin - camOrigin);\n        pR(dir.yz, - 0.1); // pitch camera down\n        \n        float dist;\n        \n        vec3 color = trace(camOrigin, dir, dist);\n        \n        vec3 computeColor = vec3(samplesTaken / 256.0);\n        vec3 distColor = vec3(dist * 0.1);\n        \n        color = mix(color, computeColor, step(0.0, uv.x));\n        \n        //float fog = clamp(map(dist, 10., 15., 1., 0.), 0.0, 1.0);\n        //color = mix(vec3(0.0), color, fog);\n        // Output to screen\n        fragColor = vec4(color, 1.0);\n    }","name":"Image","description":"","type":"image"}]}