{"ver":"0.1","info":{"id":"WlKSW1","date":"1582628159","viewed":162,"name":"moving in the infinite boxes","username":"suraimu752","description":"My first decent piece.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float focus = 4.;\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    float blur = (col.w - focus) * .00001;\n    \n    vec4 col1 = texture(iChannel0, uv + blur);\n    vec4 col2 = texture(iChannel0, uv - blur);\n    \n    col = (col + col1 + col2) / 3.;\n    \n    fragColor = vec4(col.xyz, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rotateX(vec3 p, float th){\n    return p * mat3(\n        1, 0, 0,\n        0, cos(th), -sin(th),\n        0, sin(th), cos(th)\n    );\n}\nvec3 rotateY(vec3 p, float th){\n    return p * mat3(\n        cos(th), 0, sin(th),\n        0, 1, 0,\n        -sin(th), 0, cos(th)\n    );\n}\nvec3 rotateZ(vec3 p, float th){\n    return p * mat3(\n        cos(th), -sin(th), 0,\n        sin(th), cos(th), 0,\n        0, 0, 1\n    );\n}\n\nfloat sdBox(vec3 p, vec3 size){\n    return length(max(abs(p) - size, 0.)) - .01;\n}\n\nvec3 spacer(vec3 p, float s){\n    return max(vec3(0), (abs(p) - vec3(s, s, 0))) * mix(vec3(1), vec3(-1), step(0., p));\n}\n\nvec3 trans(vec3 p){\n    float m = 1.;\n    p = spacer(p, .5);\n    vec3 q = mod(p, m) - m * .5;\n    q.x += (rand(floor(p.xy) + .3 + floor(p.zx) + .65) * 2. - 1.) * .08;\n    q.y += (rand(floor(p.zy) + .1 + floor(p.xy) + .52) * 2. - 1.) * .08;\n    q.z += (rand(floor(p.zz) + .2 + floor(p.yx) + .30) * 2. - 1.) * .075;\n    return q;\n}\n\nfloat dist(vec3 p){\n    return sdBox(trans(p), vec3(0.36, 0.36, 0.36));\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        dist(p + vec3(d, 0., 0.)) - dist(p + vec3(-d, 0., 0.)),\n        dist(p + vec3(0., d, 0.)) - dist(p + vec3(0., -d, 0.)),\n        dist(p + vec3(0., 0., d)) - dist(p + vec3(0., 0., -d))\n    ));\n}\n\nvec3 hsv(vec3 hsv){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(hsv.x) + t.xyz) * 6.0 - vec3(t.w));\n    return hsv.z * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), hsv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    vec3 lightDir0 = normalize(vec3(.3, .5, -1));\n    vec3 lightDir = normalize(vec3(0, 0, 1));\n\n    vec3 lightColor = hsv(vec3((sin(iTime * .4) + cos(iTime * .6)) * .03 + .54, .22, 1.));\n    \n    vec3 col = vec3(0.);\n\n    vec3 screen = vec3(uv, 0.), cpos = vec3(0, 0, -1.), o = vec3(0);\n    vec3 v = normalize(screen - cpos);\n    \n    v = rotateY(rotateX(v, sin(iTime * .33) * .5), sin(iTime * .52) * .3);\n    v = rotateZ(v, sin(iTime * .3) * 3.1415926535 * .2);\n    o += vec3(0., (sin(iTime * .4) + cos(iTime * .6)) * .46, iTime * 3.);\n\n    if(v.x > 0. && v.y > 0.){\n        o -= vec3(1, 1, 0) * .0001;\n    }\n\n    vec3 rpos = o;\n\n    float d = 0., len = 0.;\n\n    for(int i = 0; i < 1000; i++){\n        d = dist(rpos);\n        if(d < 0.001) {\n            vec3 normal = getNormal(rpos);\n            col = vec3(.5, .5, .5) * (max(0., dot(normal, lightDir0)) + max(0., dot(normal, lightDir)));\n            col /= pow(distance(rpos, o) * .3, 1.5);\n            break;\n        }\n        else{\n            col = lightColor * pow(length(rpos.xy) * .1, -2.);\n        }\n        \n        rpos += vec3(.5, .5, 0);\n        len += min(\n            min(\n                min(\n                    (step(0., v.x) - fract(rpos.x)) / v.x,\n                    (step(0., v.y) - fract(rpos.y)) / v.y\n                ),\n                (step(0., v.z) - fract(rpos.z)) / v.z\n            ) + .001,\n            d\n        );\n        rpos = o + v * len;\n    }\n    vec3 bloom = lightColor * min(pow(length(v.xy) * 16., -.5), 1.);\n    col += bloom;\n\n    fragColor = vec4(col, len);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}