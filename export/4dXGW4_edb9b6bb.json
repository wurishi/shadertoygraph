{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n\nfloat hash( float n )\n{\n\treturn fract( sin(n)*54671.57391);\n}\n\nfloat noise( vec2 p )\n{\n\treturn hash( p.x + p.y * 57.1235 );\n}\n\nstruct Line{\n\tvec3 loc;\n\tvec3 dir;\n\tvec3 color;\n\tfloat t;\n\tint id_obj;\n};\n\t\nstruct Material{\n\tvec3 ambient;\n\tvec3 difuse;\n\tvec3 specular;\n\tfloat brightness;\n\tfloat reflectance;\n};\n\t\nstruct Sphere{\n\tvec3 loc;\n\tMaterial mat;\n\tfloat r;\n};\n\nstruct Light{\n\tvec3 loc;\n\tvec3 color;\n};\n\t\nMaterial gold = Material(vec3(0.24725,0.1995,0.0745),vec3(0.75164,0.60648,0.22648),vec3 (0.628281,0.555802,0.366065),51.2, 0.6);\t\t\nMaterial red   = Material(vec3(0.1,0.0,0.0),vec3(0.6,0.0,0.0),vec3(0.8,0.0,0.0),50.0,0.7);\nMaterial blue  = Material(vec3(0.1,0.1,0.3),vec3(0.0,0.0,0.6),vec3(0.0,0.0,0.8),30.0,0.4);\nMaterial green = Material(vec3(0.1,0.3,0.1),vec3(0.0,0.6,0.0),vec3(0.0,0.8,0.0),70.0,0.0);\nMaterial white = Material(vec3(1),vec3(1),vec3(1),70.0,1.0);\nvec3 background_color = vec3(0.8,0.8,0.9);\nSphere sph[4];\nLight light = Light(vec3(-5.0,10.0,5.0),vec3(1.0,1.0,1.0));\nLight light2 = Light(vec3(-15.0,16.0,-30.0),vec3(1.0,1.0,1.0));\nLight lights[2];\n\nvoid background (inout Line line){\n\tline.color = background_color;\n}\n\nbool sphere_hits(in Line line, out float t, Sphere sphere){\n\tvec3 p0 = line.loc - sphere.loc;\n\tvec3 v = line.dir;\n\tfloat b = 2.0*dot(p0,v);\n\tfloat c = dot(p0,p0) - sphere.r*sphere.r;\n\tfloat D = b*b -4.0*c;\n\tif (D < 0.0) return false;\n\tif (D == 0.0){\n\t\tt = (-b)/2.0;\n\t\treturn true;\n\t}\n\tif (D > 0.0){\n\t\tfloat t0,t1;\n\t\tt0 = (-b + sqrt(D))/2.0;\n\t\tt1 = (-b - sqrt(D))/2.0;\n\t\tif ( t0 < t1 && t0 > 0.0) t = t0;\n\t\telse if (t1 < t0 && t1 > 0.0) t = t1;\n\t\telse return false;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec3 sphere_norm(Sphere sphere, vec3 hit_loc){\n\treturn normalize(hit_loc - sphere.loc);\n}\n\nvec3 plane_norm(vec3 hit_loc){\n\treturn normalize(vec3(0.0,1.0,0.0));\n}\n\nbool plane_hits(in Line line, out float t){\n\tvec3 n = vec3(0.0,1.0,0.0);\n\t//t = (0.0 - dot(line.loc,n)/dot(line.dir,n));\n\tt = - line.loc.y/line.dir.y;\n\tif (t <= 0.0) return false;\n\treturn true;\n}\n\nbool intersect(inout Line line){\n\tfloat t_hit = 0.0;\n\tfloat best_hit = 0.0;\n\tint best_obj = -1;\n\t\n\t//for each sphere\n\tfor(int i = 0; i < 4; i++){\n\t\t//if ray hit with sphere i\n\t\tif (sphere_hits(line,t_hit,sph[i])){\n\t\t\tif (t_hit < best_hit || best_obj < 0){\n\t\t\t\tbest_hit = t_hit;\n\t\t\t\tbest_obj = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//if ray doesn't hit with any sphere then check if hit with plane\n\tif (best_obj < 0){\n\t\tif (plane_hits(line,t_hit))\n\t\t\tif (t_hit < best_hit || best_obj < 0){\n\t\t\t\tbest_hit = t_hit;\n\t\t\t\tbest_obj = 100;\n\t\t\t}\n\t}\n\t\n\t//check if hit is infront camera\n\tif (best_obj >= 0){\n\t\tline.id_obj = best_obj;\n\t\tline.t = best_hit;\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nbool shadowIntersect(inout Line line){\n\tfloat t_hit = 0.0;\n\t\n\t//for each sphere\n\tfor(int i = 0; i < 4; i++){\n\t\t//if ray hit with sphere i\n\t\tif (sphere_hits(line,t_hit,sph[i]))\n\t\t\treturn true;\n\t}\n\tif (plane_hits(line,t_hit)) return true;\n\t\n\treturn false;\n}\n\nvec3 randomRay(vec3 N, vec2 fragCoord){\n\twhile (true) {\n\t\tfloat x = noise(fragCoord.xy);\n\t\tfloat y = noise(fragCoord.xy);\n\t\tfloat z = noise(fragCoord.xy);\n\t\tif (x * x + y * y + z * z > 1.0) continue;\n\t\tif (dot(vec3(x, y, z), N) < 0.0) continue; // ignore \"down\" dirs\n\t\treturn normalize(vec3(x, y, z)); // success!\n\t}\n}\n\nfloat ambientOcclusion(vec3 Pi, vec3 N, float m, vec2 fragCoord){\n\tfloat occlusedRays = 0.0;\n\tvec3 r;\n\tLine l;\n\tfor (float i = 0.0; i < m; i+=1.0){\n\t\tr = randomRay(N,fragCoord);\n\t\tl = Line(Pi+r*0.01,r,vec3(0.0),0.0,-1);\n\t\tif(intersect(l))\n\t\t\tif (l.t < 3.0)\n\t\t\t\tocclusedRays+=1.0-l.t/3.0;\n\t}\n\treturn (m-occlusedRays)/m;\n}\n\nvoid calculateColor(inout Line line_in, out Line lineR,bool occlusion, vec2 fragCoord){\n\tvec3 Pi = line_in.loc + line_in.dir*line_in.t;\n\tvec3 N;\n\tvec3 Kd,Ks,Ka;\n\tfloat gloss;\n\tif (line_in.id_obj != 100){\n\t\tN = sphere_norm(sph[line_in.id_obj],Pi);\n\t\tKd = sph[line_in.id_obj].mat.difuse;\n\t\tKs = sph[line_in.id_obj].mat.specular;\n\t\tKa = sph[line_in.id_obj].mat.ambient;\n\t\tgloss = sph[line_in.id_obj].mat.brightness;\n\t\t//sph[line.id_obj].mat.reflectance;\n\t}else{\n\t\tN = plane_norm(Pi);\n\t\tKd = vec3(0.7,0.7,0.0);\n\t\tKs = vec3(0.8,0.8,0.0);\n\t\tKa = vec3(0.075,0.075,0.0);\n\t\tgloss = 10.0;\n\t}\n\t//line_in.color = vec3(1.0);//*ambientOcclusion(Pi,N,64.0);\n\n\tvec3 E = -line_in.dir;\n\tvec3 Er = reflect(line_in.dir,N);\n\tlineR = Line(Pi+Er*0.01,Er,vec3(0.0,0.0,0.0),0.0,-1);\n\t\t\n\t//foreach light\n\tfor(int i = 0; i < 1; i++){\n\t\tvec3 L = lights[i].loc - Pi;\n\t\tfloat d = length(L);\n\t\tL = normalize(L);\n\t\tLine l = Line(Pi+L*0.01,L,vec3(1.0),0.0,-1);\n\t\t\n\t\tif (shadowIntersect(l) && !occlusion )\n\t\t\tline_in.color += Ka;\n\t\t//\tline_in.color += vec3(0.05);\n\t\telse{\n\t\n\t\n\t\tfloat NdotL  = clamp( dot(N,L), 0.0, 1.0 );\n\t\tvec3 diffuse = NdotL*Kd;\n//\t\tline.color += diffuse;\n\t\tfloat LdotEr = clamp( dot(L,Er), 0.0, 1.0);\n\t\t//celshading\n//\t\t\tif (LdotEr < 0.3) LdotEr = 0.3;\n//\t\t\telse if (LdotEr < 0.65) LdotEr = 0.65;\n//\t\t\telse if (LdotEr < 1.0) LdotEr = .99;\n\t\tvec3 specular = pow(LdotEr,gloss)*Ks;\n\t\tline_in.color += (diffuse + specular);\n\t\t}\n\t}\n\t//OCCLUSION\n\tif (occlusion)\n\t\tline_in.color *= vec3(ambientOcclusion(Pi,N,32.0,fragCoord));\n\n\n}\n\nvoid trace(inout Line line_trace, vec2 fragCoord){\n\tLine lineR,aux;\n\tif (intersect(line_trace)){\n\t\tcalculateColor(line_trace,lineR,false,fragCoord);\n\t\t/*int i = 0;\n\t\twhile (i < 2){\n\t\t\tif (intersect(lineR)){\n\t\t\t\tcalculateColor(lineR,aux);\n\t\t\t\t//line_trace.color += vec3(1.0,0.0,0.0);\n\t\t\t\tline_trace.color += lineR.color;\n\t\t\t\tlineR = aux;\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tbackground(lineR);\n\t\t\t\tline_trace.color += lineR.color*0.1;\n\t\t\t\ti=2;\n\t\t\t}\n\t\t}*/\n\t}else \n\t\tbackground(line_trace);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tsph[0] = Sphere(vec3(-1.0,3.0,1.5),red,3.0);\n\tsph[1] = Sphere(vec3(1.5,1.0,-1.0),blue,1.0);\n\tsph[2] = Sphere(vec3(-3.0,1.0,6.0),gold,1.0);\n\tsph[3] = Sphere(vec3(4.0,3.0,3.0), white,1.0);\n\tlights[0] = light;\n\tlights[1] = light2;\n\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tp = -1.0 + 2.0*p;\n\tp.x *= iResolution.x/iResolution.y;\n\n//\tfloat x = 0.6;//cos(iTime);\t\n//\tfloat y = 1.4;//sin(iTime);\n\tfloat x = sin(iTime);\t\n\tfloat y = cos(iTime);\n\n\tvec3 lookAt = vec3(0.0, 0.0, 0.0);\n\tvec3 ro = vec3(x*9.0,6.0,y*9.0); //camera position\n\tvec3 front = normalize(lookAt - ro);\n\tvec3 left = normalize(cross(vec3(0,1,0), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 rd = normalize(front*1.5 + left*p.x + up*p.y); // rect vector\n\t\n\tLine ray = Line(ro,rd,vec3(0.0),0.0,-1);\t\t// create ray with (loc,dir,color,distance to hit(0.0 initial), object hitted(no object hitted)) \n\t\n\ttrace(ray,fragCoord);\n\t\n\tfragColor = vec4(ray.color,1.0);\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dXGW4","date":"1369507599","viewed":223,"name":"RT","username":"madowen","description":"Ray tracing","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""}}