{"ver":"0.1","info":{"id":"DlXGWs","date":"1672688143","viewed":251,"name":"Psychedelic Snowflake","username":"myth0genesis","description":"My first reflection/refraction shader. It's only recursive one level down, but basically splits and recasts every ray that hits something and fades between them based on their angle of incidence (with the exception of TIR hits).","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","ray","raymarch","refraction","psychedelic","transparent","recursive","snowflake","march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2023 myth0genesis\n\nconst int maxstps = 100;\nconst float maxdst = 100.0;\nconst float mindst = 0.001;\nconst float fudge = mindst * 3.0;\nconst float pi = 3.1415927410125732421875;\nconst float tau = 6.283185482025146484375;\nconst float IOR = 1.45;\nconst float invIOR = 1.0 / IOR;\nconst float den = 0.2;\nconst float i3 = 1.0 / 3.0;\nconst float pii3 = pi * i3;\nconst float tFac = 1.0 * tau / 6.0;\nconst float sFac = 0.0003;\nconst float bgprd = 4.0;\nconst float sq32 = sqrt(3.0) * 0.5;\nconst float negs15 = -sqrt(2.0) * 0.25 * (sqrt(3.0) - 1.0);\nconst float negc15 = sqrt(2.0) * 0.25 * (sqrt(3.0) + 1.0);\nconst mat2 negi3Rot = mat2(  0.5, sq32,\n                           -sq32, 0.5  );\nconst mat2 negi3Rot2 = mat2( 0.5, -sq32,\n                            sq32,  0.5  );\nconst mat2 halfnegi3Rot = mat2(sq32, 0.5,\n                               -0.5, sq32);\nconst mat2 neg15Rot = mat2(negc15, -negs15,\n                           negs15,  negc15 );\nmat2 tRot;\n\nmat2 rot2D(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\n// Huge thanks to iq for this smoothing function! https://iquilezles.org/articles/functions/\nvec2 smoothabs(vec2 x, float k) {\n    return sqrt(x * x + k);\n}\n\n// And also thanks to iq for the geo functions and ops\nfloat sdHexagram(vec2 p, float r) {\n    const vec4 k = vec4(-0.5, 0.8660254038, 0.5773502692, 1.7320508076);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n    p -= 2.0 * min(dot(k.yx, p), 0.0) * k.yx;\n    p -= vec2(clamp(p.x, r * k.z, r * k.w), r);\n    return length(p) * sign(p.y);\n}\n\nfloat opExtrusion(vec3 p, float d, float h) {\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// Fold a hexagram prism one plane at a time.\nfloat snowflake(vec3 p) {\n    p = p.zyx;\n    p.yz = smoothabs(p.yz, sFac);\n    p.yz *= negi3Rot2;\n    p.yz = smoothabs(p.yz, sFac);\n    p.yz *= negi3Rot;\n    p.y -= 1.0;\n    p.xy = smoothabs(p.xy, sFac);\n    p.y -= 0.5;\n    p.xy = smoothabs(p.xy, sFac);\n    p.xy *= negi3Rot * tRot;\n    p.xy -= 0.25;\n    p.xy = smoothabs(p.xy, sFac);\n    p.xy *= negi3Rot2 * tRot;\n    p.xy = smoothabs(p.xy, sFac);\n    p.xy *= halfnegi3Rot;\n    p.yz = smoothabs(p.yz, sFac);\n    p.yz *= halfnegi3Rot * tRot;\n    p.yz = smoothabs(p.yz, sFac);\n    p.yz *= neg15Rot;\n    float d = opExtrusion(p.xzy, sdHexagram(p.xz, 0.5), 3.0);\n    return d - 0.025;\n}\n\nvec3 bg(vec3 rn) {\n    float at = atan(rn.x, rn.z);\n    return vec3(cos(at * bgprd), cos((at + i3 * tau) * bgprd), cos((at + 2.0 * i3 * tau) * bgprd)) * 0.5 + 0.5;\n}\n\nfloat map(vec3 pos) {\n    float d0 = snowflake(pos);\n    return d0;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO = 0.0;\n    \n    for(int i = 0; i < maxstps; i++) {\n    \tvec3 p = ro + rd * dO;\n        float dS = map(p) * side;\n        dO += dS;\n        if(dO > maxdst || abs(dS) < mindst) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.001, 0.0);\n    vec3 n = map(p) - \n        vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));\n    \n    return normalize(n);\n}\n\n// I know this isn't the best way to do it,\n// but it was easier for me to keep track\n// of what was going on here.\nvec3 rflrm(vec3 ro, vec3 rd0) {\n    \n    vec3 col = bg(rd0);\n\n    float d0 = rayMarch(ro, rd0, 1.0);\n\n    if(d0 < maxdst) {\n        vec3 h0 = ro + rd0 * d0;\n        vec3 n0 = getNormal(h0);\n        float frsn0 = pow(1.0 + dot(rd0, n0), 5.0);\n        vec3 rd1 = reflect(rd0, n0);\n        vec3 reflbg = bg(rd1);\n        vec3 rd2 = refract(rd0, n0, invIOR);\n        \n        vec3 h0offs = h0 - n0 * fudge;\n        float d1 = rayMarch(h0offs, rd2, -1.0);\n        \n        vec3 h1 = h0offs + rd2 * d1;\n        vec3 n1 = -getNormal(h1);\n        \n        vec3 refrbg = bg(rd1);\n        \n        \n        vec3 rd3 = refract(rd2, n1, IOR);\n        rd3 = (dot(rd3, rd3) == 0.0) ? reflect(rd2, n1) : rd3;\n        refrbg = bg(rd3);\n        \n        float optDst = exp(-d1 * den);\n        refrbg = refrbg * optDst;\n        \n        col = mix(refrbg, reflbg, frsn0);\n    }\n    \n    return col;\n}\n\n// 95% of this is based on Martijn Steinrucken's tutorials\n// on reflection and refraction: https://youtu.be/NCpaaLkmXI8\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    tRot = rot2D(iTime * tFac);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = vec2(0.5);\n    mat2 rmxz = mat2(0.0);\n    mat2 rmyz = mat2(0.0);\n    \n    if (iMouse.z > 0.0) {\n        m = -iMouse.xy / iResolution.xy;\n        rmxz = rot2D(m.x * tau);\n        rmyz = rot2D(m.y * tau + pi);\n    } else {\n        rmxz = rot2D(m.x * tau + sin(iTime * tFac) * 0.5);\n        rmyz = rot2D(m.y * tau + 2.7);\n    }\n\n    vec3 ro = vec3(0.0, 3.3, -7.7);\n    ro.yz *= rmyz;\n    ro.xz *= rmxz;\n    vec3 rd0 = normalize(vec3(uv.x, uv.y, 1.0));\n    rd0.yz *= rot2D(0.42);\n    rd0.yz *= rmyz;\n    rd0.xz *= rmxz;\n    \n    vec3 col = bg(rd0);\n\n    float d0 = rayMarch(ro, rd0, 1.0);\n\n    if(d0 < maxdst) {\n        vec3 h0 = ro + rd0 * d0;\n        vec3 n0 = getNormal(h0);\n        float frsn0 = pow(1.0 + dot(rd0, n0), 5.0);\n        vec3 rd1 = reflect(rd0, n0);\n        vec3 reflbg = rflrm(h0, rd1);\n        vec3 rd2 = refract(rd0, n0, invIOR);\n        \n        vec3 h0offs = h0 - n0 * fudge;\n        float d1 = rayMarch(h0offs, rd2, -1.0);\n        \n        vec3 h1 = h0offs + rd2 * d1;\n        vec3 n1 = -getNormal(h1);\n        \n        vec3 h1offs = h1 - n1 * fudge;\n        \n        vec3 refrbg = bg(rd1);\n        \n        vec3 rd3 = refract(rd2, n1, IOR);\n        \n        float d2 = 0.0;\n        if (dot(rd3, rd3) == 0.0) {\n            rd3 = reflect(rd2, n1);\n            d2 = rayMarch(h1, rd3, -1.0);\n            vec3 h2 = h1 + rd3 * d2;\n            \n            // Should this be flipped?\n            vec3 n2 = -getNormal(h2);\n            \n            vec3 rd4 = refract(h2, n2, IOR);\n            rd4 = (dot(rd4, rd4) == 0.0) ? reflect(rd3, n2) : rd4;\n            refrbg = bg(rd4);\n        } else {\n            refrbg = rflrm(h1offs, rd3);\n        }\n        \n        float optDst = exp(-d1 * den);\n        refrbg = refrbg * optDst;\n        \n        col = mix(refrbg, reflbg, frsn0);\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}