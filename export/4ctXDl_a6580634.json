{"ver":"0.1","info":{"id":"4ctXDl","date":"1714688225","viewed":45,"name":"!Raytrace test;","username":"Qwasdfet","description":"my first raytracing implementation. I didnt do much research so it probably has a bunch of things \"wrong\".\n\nedit: this probably isnt actually raytracing. renaming to put \"!\" in front","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define shit\n\n#define worldViewport iResolution.xy * 1.0 / iResolution.x\n#define focalLength 1.0\n#define pi (3.141592653589)\n\n//camera is +z forward +y up +x right\n\nvec3 toneMappedCol(vec3 col) {\n    float highVal = col.x;\n    if(col.y > col.x) highVal = col.y;\n    if(col.z > col.y) highVal = col.z;\n    float highValAnti = 1.0 / highVal;\n    \n    float lum = (col.x + col.y + col.z) / 3.0;\n    \n    float mappedLum = lum / (lum + 1.0);\n    \n    //return col * mappedLum / lum;\n    return col / (col + vec3(1.0,1.0,1.0));\n    \n}\n\nfloat quadraticZero1(float a, float b, float c){\n    return (-b - sqrt((b * b) - (4.0 * a * c))) / (2.0 * a);\n}\n\nvec3 spherePointOnLine(vec3 m, float r, vec3 cent){\n    float a = ((m.y * m.y) + (m.z * m.z) + (m.x * m.x));\n    float b = -2.0 * (m.x * cent.x + m.y * cent.y + m.z * cent.z);\n    float c = cent.x * cent.x + cent.y * cent.y + cent.z * cent.z - r * r;\n    float t = quadraticZero1(a,b,c);\n    return t * m;\n}\n\nvec3 sphereNormal(vec3 cent, vec3 surface, float radius) {\n    //if(surface == vec3(0.0,0.0,0.0)) return surface;\n    return (surface - cent) / (radius);\n}\n\nfloat squareDropoff(float dist){\n    return 1.0/pow(dist,2.0);//(dist + 1.0,2.0);\n}\n\nfloat sphericalDropoff(float dist){\n    return 1.0 / (2.0 * pi * pow(dist, 3.0));\n}\n\nvec3 rotateVec(vec3 inVec, vec4 quaternion, vec3 identity){   \n    return vec3(1.0,1.0,1.0);\n}\n\n//First iteration\n//cen = sphere center\n//r = sphere radius\n//col = sphere color\n//lp = point light position\n//lc = point light color\n//cs = camera ray slope\n//cp = camera viewport pos\nvec3 sphereColor(vec3 cen, float r, vec3 col, vec3 lp, vec3 lc, vec3 cs, vec3 cp){\n    vec3 surf = spherePointOnLine(cs,r,cen);\n    vec3 spheNorm = sphereNormal(cen, surf, r);\n    float distSurfLight = distance(surf,lp);\n    float distSurfCam = distance(surf, cp);\n    float surfLightAlignment = dot(lp - surf,spheNorm) / (distSurfLight * length(spheNorm));\n    //surfLightAlignment = min(0.0,surfLightAlignment);\n    vec3 surfaceCol = lc * col * surfLightAlignment * 1.0 / distSurfLight;//squareDropoff(distSurfLight);\n    vec3 camCol = surfaceCol * 1.0 / distSurfCam;// * squareDropoff(distSurfCam);\n    return camCol * 100.0;\n}\n\n//Second iteration\nvec3 sphereColor2(vec3 cen, float r, vec3 col, vec3 lp, vec3 lc, vec3 cs, vec3 cp){\n    vec3 surf = spherePointOnLine(cs,r,cen);\n    vec3 spheNorm = sphereNormal(cen, surf, r);\n    float distSurfLight = distance(surf,lp);\n    float distSurfCam = distance(surf, cp);\n    float surfLightAlignment = dot(lp - surf,spheNorm) / (distSurfLight * length(spheNorm));\n    //surfLightAlignment = min(0.0,surfLightAlignment);\n    vec3 surfaceCol = lc * col * surfLightAlignment;\n    vec3 camCol = surfaceCol;\n    return camCol * sphericalDropoff(distSurfLight + distSurfCam);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nint i = 2;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 rayDir_xy = (uv - vec2(0.5,0.5)) * worldViewport;\n    vec3 camSurf = vec3(rayDir_xy.xy,focalLength);\n    \n    //vec3 lightPos = vec3(0.0,10.0,8.0);\n    //vec3 lightPos = vec3(cos(iTime),-cos(iTime),sin(iTime)) * ;\n\n    //vec3 lightCol = vec3(1.0,1.0,1.0);// * (sin(iTime) + 1.0) / 2.0;\n    vec3 lightCol = vec3(sin(iTime * 0.9) + 1.0, sin(iTime) + 1.0, sin(iTime + 1.1) + 1.0) / 2.0;\n    lightCol *= 10.0;\n    vec3 spherePos = vec3(0.0,0.0,12.0);\n    //vec3 spherePos = vec3(iMouse.x / iResolution.x - 0.5,iMouse.y / iResolution.y - 0.5,2.0) * 6.0;\n    float sphereRad = 2.0;\n    vec3 sphereCol = vec3(1.0,1.0,1.0);//vec3(0.5,0.5,0.6) * 1.0;\n    \n    //vec3 lightPos = vec3(cos(iTime * 2.0),-cos(iTime * 1.1),sin(iTime * 2.0)) * 12.0 + spherePos;\n    vec3 lightPos = vec3(cos(iTime * 2.0),1.0,sin(iTime * 2.0)) * 12.0 + spherePos;\n\n    \n    // Time varying pixel color\n    vec3 col = sphereColor2(spherePos,sphereRad,sphereCol, lightPos, lightCol * 100000.0, camSurf, camSurf);\n    \n    //col = abs(spherePointOnLine(camSurf, sphereRad, spherePos));// * iMouse.x * 1000.0;\n    //col = vec3(1.0,1.0,1.0) * abs(quadraticZero1(1.0,0.0,-1.0));//quadraticZero1(uv.x, uv.y * 10.0,5.0));\n    \n    col = max(col,0.0);\n    col = toneMappedCol(col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \nif(i == 0) fragColor = vec4(1.0,1.0,1.0,1.0) * iMouse.x / iResolution.x;\n}","name":"Image","description":"","type":"image"}]}