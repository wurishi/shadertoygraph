{"ver":"0.1","info":{"id":"WddXDf","date":"1573059493","viewed":474,"name":"Trypophobia [contest]","username":"warlock","description":"Made with help of the awesome tutorial videos from BigWIngs\n\nhttps://www.youtube.com/watch?v=l-07BXzNdPw - Voronoi\n\nSpecial for competition of webgl enthusiast's community https://discord.gg/W9kTZAx","likes":15,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","voronoi","trypophobia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lts3DX","filepath":"https://soundcloud.com/myuu/the-unknown-horror-ambience","previewfilepath":"https://soundcloud.com/myuu/the-unknown-horror-ambience","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 50\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n//#define SHADOWS // optional shadows\n\n#define PI 3.1415926\n#define minDistance 100.\n#define SEED 345.\n#define iTime (iTime+SEED)\n\n\n\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec2 voronoi(vec2 p){\n\tvec2 gv = fract(p) - 0.5;\n    vec2 id = floor(p);\n    float minDist = minDistance;\n    float d = 0.;\n    vec2 cid = vec2(0);\n    for (float y = -1.; y <= 1.; y++){\n        for (float x = -1.; x <= 1.; x++){\n        \tvec2 offs = vec2(x, y);\n            \n            vec2 n = N22(id + offs);\n            vec2 p = offs + sin(n * SEED) * .25;\n            p += cos(n * iTime) * 0.0666;\n            d = length(gv - p);\n            if (d < minDist) {\n            \tminDist = d;\n                cid = n;\n            }\n        }\n    }\n    \n    vec2 mult = cid * iTime * PI * 0.5;\n    \n    return vec2(minDist, minDist * 8. + (sin(mult) * cos(mult * .25)));\n}\n\nvec2 sdFloor(vec3 p){\n    float d = p.y;\n    \n    vec2 vor = voronoi(p.xz);\n    float v = vor.x;\n    v = sin(v * PI * 1.5) * (0.25 + sin(vor.y) * 0.25) + 0.25;\n   \n    d -= pow(v, 4.);\n    \n    float r = texture(iChannel0, p.xz).r;\n\tr = pow(r, 2.) * 0.05;\n    d += r;\n\t\n    float g = texture(iChannel1, p.xz * 0.5).g;\n    d += pow(g, 4.) * 0.05;         \n    \n    return vec2(d * 0.5, vor.y);\n}\n\n\nvec2 GetDist( vec3 p ){\n\n    return sdFloor(p);\n}\n\nvec2 RayMarch( vec3 ro, vec3 rd ){\n    \n\tvec2 dO = vec2(0.);\n    \n    for (int i = 0; i < MAX_STEPS; i++){\n    \tvec3 p = ro + rd * dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x;\n        dO.y = dS.y;\n        if (dO.x > MAX_DIST || dO.x < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal( vec3 p ){\n    \n    vec2 e = vec2(.0001, 0);\n    \n    vec3 n = vec3(\n        GetDist(p + e.xyy).x - GetDist(p - e.xyy).x,\n        GetDist(p + e.yxy).x - GetDist(p - e.yxy).x,\n        GetDist(p + e.yyx).x - GetDist(p - e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat GetLight( vec3 p ){\n    \n\tvec3 lightPos = vec3(0, 5, 0);\n    lightPos.xz += vec2(cos(iTime * 0.328), sin(iTime)) * 2.;\n    vec3 l = normalize(lightPos - p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float plDist = length(lightPos - p);\n    #ifdef SHADOWS\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l).x;\n        if (d < plDist) dif *= 0.25;\n    \n    #endif\n    dif *= smoothstep(10., 0., plDist);\n    \n    return dif;\n}\n\nvec3 setFromSphericalCoords( float radius, float phi, float theta ) { // stolen from three.js :-P\n    \t\n    \tvec3 v = vec3(0);\n    \n    \tfloat sinPhiRadius = sin( phi ) * radius;\n\t\t\n\t\tv.x = sinPhiRadius * sin( theta );\n\t\tv.y = cos( phi ) * radius;\n\t\tv.z = sinPhiRadius * cos( theta );\n\n\t\treturn v;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    \n    // camera settings ---------------------------------------\n    \n        \n    // angles\n    \n    float distToOrigin = 7.5;\n    float phiStart = PI / 4.;\n    float thetaStart = PI / 3.;\n    \n    vec2 mouse = iMouse.z > 0. ? (iMouse.xy * 2. - iResolution.xy)  / iResolution.xy: vec2(0);\n    \n    vec3 lookAt = vec3(0, 0, 0);\n    \n    float phi = phiStart - mouse.y * (PI / 6.1);\n    float theta = thetaStart + mouse.x * PI;\n    \n    vec3 ro = setFromSphericalCoords(distToOrigin, phi, theta);\n\n    \n    float zoom = 1.;\n    vec3 f = normalize(lookAt - ro),\n        r = normalize(cross(vec3(0, 1, 0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i - ro);\n    \n    // -------------------------------------------------------\n    \n    vec2 d = RayMarch( ro, rd );  // returns distance(x) and data for gradient (y);\n    \n    vec3 p = ro + rd * d.x;\n\n    float dif = GetLight(p) * 1.5;\n    \n    //vec3 col = vec3(0.125, 0.3, 0.25);\n    //vec3 col = vec3(1,0.5,0.5);\n    vec3 col = vec3(0.5, 0.25, 0.5);\n    \n    col = mix(col, texture(iChannel0, p.xz).rgb, 0.25);\n    \n    col = mix(col, vec3(0.9, 0.05, 0.05) * 1.5, smoothstep(1., 0., d.y));\n    col = mix(col, vec3(0, 0, 0), smoothstep(0.5, 1., d.y) - smoothstep(1.25, 1.5, d.y));\n    //col = mix(col, vec3(0.5, 0, 0.75), smoothstep(0.14, 0.15, p.y) - smoothstep(0.15, 0.16, p.y));\n    \n    col *= dif;\n    \n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}