{"ver":"0.1","info":{"id":"wsdXWH","date":"1571927695","viewed":138,"name":"TestingWaves","username":"CoolerZ","description":"Each pixel is a weight of a fixed mass that only moves up and down. It is attached to it's 4 neighbors using springs of a fixed spring constant.\nThe springs exert a force on the weights based on hook's law proportional to the difference in heights.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["wavesphysics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sigmoid(float x)\n{\n    return 1. / (1. + exp(-x));\n}\n\nvec3 floatToRgb(float v, float scale) {\n    float r = v;\n    float g = mod(v*scale,1.0);\n    r-= g/scale;\n    float b = mod(v*scale*scale,1.0);\n    g-=b/scale;\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get current x and y.\n    fragCoord -= 0.5; // pixel coordinates are given as mid intergers, subtract 0.5 to make it interger.\n    ivec2 center = ivec2(fragCoord);\n    ivec2 res    = ivec2(iResolution) - 1;\n\n    float pos = texelFetch(iChannel0, center, 0).y;\n    //pos = sigmoid(pos);\n    //float e = sigmoid(sin(iTime));\n\n    //vec3 red   = vec3(1., e, e);\n    //vec3 green = vec3(e, 1., e);\n    //vec3 blue  = vec3(e,  e, 1.);\n    //vec3 black = vec3(0.);\n\n    //vec3 col = mix(black, green, sin(iTime) * 0.1);\n\t//if(pos > 0.6)col = mix(col, red, pos * 0.5);\n    //else if(pos < 0.4)col = mix(col, blue, 1. - pos * 2.); \n\n    //vec3 col = floatToRgb(pos, 256.);\n    vec3 col = vec3(sigmoid(pos), sin(pos), cos(pos));\n    //vec3 col = vec3(sigmoid(pos));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sigmoid(float x)\n{\n    return 1. / (1. + exp(-x));\n}\n\nfloat screen_center_dist(ivec2 pos)\n{\n    ivec2 screen_center = ivec2(iResolution) / 2;\n    float d = length(vec2(pos) - vec2(screen_center));\n    return sigmoid(d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // UPDATE VELOCITIES\n    // Channel 0 is previous velocities (x coordinate) and previous positions (y coordinate).\n\n    // get current x and y.\n    fragCoord -= 0.5; // pixel coordinates are given as mid intergers, subtract 0.5 to make it interger.\n    ivec2 center = ivec2(fragCoord);\n    ivec2 res    = ivec2(iResolution) - 1;\n\n    // if it is a boundary cell velocity is 0.\n    if(center.x == 0 || center.y == 0 || center.x == res.x || center.y == res.y)\n    {\n        fragColor = vec4(vec3(0.), 1.0);\n        return;\n    }\n\n    ivec2 left   = center + ivec2(-1,  0);\n    ivec2 top    = center + ivec2( 0,  1);\n    ivec2 right  = center + ivec2( 1,  0);\n    ivec2 bottom = center + ivec2( 0, -1);\n\n    // get previous z coordinate of current cell and neighbour cells.\n\tfloat pos_c = texelFetch(iChannel0, center, 0).y;\n\n\tfloat pos_l = texelFetch(iChannel0, left  , 0).y;\n\tfloat pos_t = texelFetch(iChannel0, top   , 0).y;\n\tfloat pos_r = texelFetch(iChannel0, right , 0).y;\n\tfloat pos_b = texelFetch(iChannel0, bottom, 0).y;\n\n    // get previous velocity of current cell.\n\tfloat vel   = texelFetch(iChannel0, center, 0).x;\n\n    // get 3d positions.\n    vec3 pos_cv = vec3(vec2(center), pos_c);\n\n    vec3 pos_lv = vec3(vec2(left  ), pos_l);\n\tvec3 pos_tv = vec3(vec2(top   ), pos_t);\n\tvec3 pos_rv = vec3(vec2(right ), pos_r);\n\tvec3 pos_bv = vec3(vec2(bottom), pos_b);\n\n    // calculate total force using Hooke's law.\n    vec3 force_l = (pos_lv - pos_cv);\n    vec3 force_t = (pos_tv - pos_cv);\n    vec3 force_r = (pos_rv - pos_cv);\n    vec3 force_b = (pos_bv - pos_cv);\n\n    force_l = normalize(force_l) * (length(force_l) - 1.) * SPRING_CONSTANT;\n    force_t = normalize(force_t) * (length(force_t) - 1.) * SPRING_CONSTANT;\n    force_r = normalize(force_r) * (length(force_r) - 1.) * SPRING_CONSTANT;\n    force_b = normalize(force_b) * (length(force_b) - 1.) * SPRING_CONSTANT;\n\n    // gravity\n    vec3 force_g = vec3(0., 0., -0.001 * MASS); // VERY LOW GRAVITY\n    // vec3 force_g = vec3(0., 0., -1.62 * MASS); // MOON\n    // vec3 force_g = vec3(0., 0., -9.807 * MASS); // EARTH\n\n    vec3 total_force = force_l + force_t + force_r + force_b + force_g;\n\n    // calculate acceleration and velocity.\n    float acc = total_force.z / MASS;\n    vel = (1. - FRICTION_COEFF) * vel + acc * iTimeDelta * PROP_SPEED;\n    //vel = (1. - FRICTION_COEFF * screen_center_dist(center)) * vel + acc * iTimeDelta * PROP_SPEED;\n\n    // clamp velocity.\n    vel = clamp(vel, -MAX_VELOCITY_MAGNITUDE, MAX_VELOCITY_MAGNITUDE);\n\n    // output current velocity and previous position.\n    fragColor = vec4(vel, pos_c, 0., 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float peak(ivec2 center, ivec2 pos, float size)\n{\n    float d = length(vec2(center) - vec2(pos));\n    float e = exp(-size * d);\n    return e;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // UPDATE POSITIONS\n    // Channel 0 is previous velocities (x coordinate) and previous positions (y coordinate).\n\n    // get current x and y.\n    fragCoord -= 0.5; // pixel coordinates are given as mid intergers, subtract 0.5 to make it interger.\n    ivec2 center = ivec2(fragCoord);\n    ivec2 res    = ivec2(iResolution) - 1;\n\n    // if it is a boundary cell position is 0.\n    if(center.x == 0 || center.y == 0 || center.x == res.x || center.y == res.y)\n    {\n        fragColor = vec4(vec3(0.), 1.0);\n        return;\n    }\n\n    // initial conditon is a peak at (128, 128).\n    if(iFrame < 30)\n    {\n\t    //fragColor = vec4(vec3(0.), 1.0);\n        float pos = texelFetch(iChannel1, center, 0).r;\n\t    fragColor = 10. * vec4(0., pos, 0., 1.0);\n\n        //float pos = 10. * peak(center, ivec2(128, 128), PEAK_SIZE);\n\t    //fragColor = vec4(0., pos, 0., 1.0);\n        return;\n    }\n\n    // get current velocity and previous position.\n\tfloat vel = texelFetch(iChannel0, center, 0).x;\n\tfloat pos = texelFetch(iChannel0, center, 0).y;\n\n    // calculate new position.\n    pos = pos + vel * iTimeDelta * PROP_SPEED;\n\n    // if LMB is down insert a peak at the click position.\n    ivec2 click = ivec2(iMouse.xy);\n    if(iMouse.z > 0.)pos += 10. * peak(center, click, PEAK_SIZE);\n\n    // clamp the position.\n    pos = clamp(pos, -MAX_DISPLACEMENT, MAX_DISPLACEMENT);\n\n    // output current velocity and current position.\n    fragColor = vec4(vel, pos, 0., 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SPRING_CONSTANT 4.\n#define PROP_SPEED 100.\n#define MASS 1.\n#define FRICTION_COEFF 0.005\n#define PEAK_SIZE .05\n#define MAX_VELOCITY_MAGNITUDE 100.\n#define MAX_DISPLACEMENT 640.","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // GAUSSIAN BLUR ON POSITIONS\n    // get current x and y.\n    fragCoord -= 0.5; // pixel coordinates are given as mid intergers, subtract 0.5 to make it interger.\n    ivec2 center = ivec2(fragCoord);\n    ivec2 res    = ivec2(iResolution) - 1;\n\n    // if it is a boundary cell velocity is 0.\n    if(center.x == 0 || center.y == 0 || center.x == res.x || center.y == res.y)\n    {\n        fragColor = vec4(vec3(0.), 1.0);\n        return;\n    }\n\n    ivec2 left   = center + ivec2(-1,  0);\n    ivec2 top    = center + ivec2( 0,  1);\n    ivec2 right  = center + ivec2( 1,  0);\n    ivec2 bottom = center + ivec2( 0, -1);\n\n    ivec2 top_left     = center + ivec2(-1,  1);\n    ivec2 top_right    = center + ivec2( 1,  1);\n    ivec2 bottom_right = center + ivec2( 1, -1);\n    ivec2 bottom_left  = center + ivec2(-1, -1);\n\n    // get current z coordinate of current cell and neighbour cells.\n\tfloat pos_c = texelFetch(iChannel0, center, 0).y;\n\n\tfloat pos_l = texelFetch(iChannel0, left  , 0).y;\n\tfloat pos_t = texelFetch(iChannel0, top   , 0).y;\n\tfloat pos_r = texelFetch(iChannel0, right , 0).y;\n\tfloat pos_b = texelFetch(iChannel0, bottom, 0).y;\n\n\tfloat pos_tl = texelFetch(iChannel0, top_left    , 0).y;\n\tfloat pos_tr = texelFetch(iChannel0, top_right   , 0).y;\n\tfloat pos_br = texelFetch(iChannel0, bottom_right, 0).y;\n\tfloat pos_bl = texelFetch(iChannel0, bottom_left , 0).y;\n\n    // get current z velocity of current cell and neighbour cells.\n\n\tfloat vel_c = texelFetch(iChannel0, center, 0).x;\n\n\tfloat vel_l = texelFetch(iChannel0, left  , 0).x;\n\tfloat vel_t = texelFetch(iChannel0, top   , 0).x;\n\tfloat vel_r = texelFetch(iChannel0, right , 0).x;\n\tfloat vel_b = texelFetch(iChannel0, bottom, 0).x;\n\n\tfloat vel_tl = texelFetch(iChannel0, top_left    , 0).x;\n\tfloat vel_tr = texelFetch(iChannel0, top_right   , 0).x;\n\tfloat vel_br = texelFetch(iChannel0, bottom_right, 0).x;\n\tfloat vel_bl = texelFetch(iChannel0, bottom_left , 0).x;\n\n    // gaussian 3 x 3 kernel\n    float vel = 0.0625 * (4. * vel_c + 2. * (vel_l + vel_t + vel_r + vel_b) + (vel_tl + vel_tr + vel_br + vel_bl));\n    float pos = 0.0625 * (4. * pos_c + 2. * (pos_l + pos_t + pos_r + pos_b) + (pos_tl + pos_tr + pos_br + pos_bl));\n\n    fragColor = vec4(vel, pos, 1., 1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}