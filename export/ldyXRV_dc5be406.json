{"ver":"0.1","info":{"id":"ldyXRV","date":"1465359780","viewed":339,"name":"Texture to Cube","username":"VoidChicken","description":"A technique to convert 2D textures to a 3D cube. Drag on the x-axis to change threshold.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","textures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International\n// license. All violations without an explicit exception from me [VoidChicken].\n/*\n\tExceptions:\n\t\n\n\n\n*/\n//#define _HIGH_DETAIL_OR_NONMAC\n#ifdef _HIGH_DETAIL_OR_NONMAC\nvec4 antialias(vec2 uv, vec2 pixel) {\n    vec4 v;\n    vec4 c = v+=texture(iChannel0, uv);\n    v+=c;\n    v+=texture(iChannel2, uv+vec2(pixel.x,0));\n    v+=texture(iChannel2, uv+vec2(0,pixel.y));\n    v+=texture(iChannel2, uv+pixel);\n    v+=texture(iChannel2, uv+vec2(-pixel.x,0));\n    v+=texture(iChannel2, uv+vec2(0,-pixel.y));\n    v+=texture(iChannel2, uv+vec2(-pixel.x,pixel.y));\n    v+=texture(iChannel2, uv+vec2(pixel.x,-pixel.y));\n    v+=texture(iChannel2, uv-pixel);\n    return vec4((v/9.).xyz,c.w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixel = 1./iResolution.xy;\n    vec4 v;\n    vec2 offs = (.5-uv)*length(.5-uv);\n    v=antialias(uv+offs*.00, pixel);\n\tfragColor = ((v)*((1.-length(.5-uv)*.5)));\n}\n#endif\n#ifndef _HIGH_DETAIL_OR_NONMAC\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    angle/=10.;\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat THRESH = 0.;\nfloat avg(vec3 c) {\n    return (c.x+c.y+c.z)/3.;\n}\nvec3 color(vec3 r) {\n    vec3 a = texture(iChannel0, r.xy).rgb;\n    vec3 b = texture(iChannel0, r.yz).rgb;\n    vec3 c = texture(iChannel0, r.xz).rgb;\n    return vec3(avg(vec3(a.x,b.x,c.x)),avg(vec3(a.y,b.y,c.y)),avg(vec3(a.z,b.z,c.z)));\n}\nbool collision(vec3 r) {\n    if (r!=mod(r,1.)) return false;\n    vec3 a = texture(iChannel0, r.xy).rgb;\n    vec3 b = texture(iChannel0, r.yz).rgb;\n    vec3 c = texture(iChannel0, r.xz).rgb;\n    return avg(vec3(avg(a),avg(b),avg(c)))>THRESH;\n}\nvec3 light = vec3(0, 0, 1);\nvec4 march (vec3 ro, vec3 rd) {\n    mat4 rot = rotationMatrix(vec3(0,1,0),iDate.w);\n    vec3 sky = texture(iChannel1, (vec4(rd,1)*rot).rgb).rgb;\n    for (float i = .0; i < 3.; i+=.005) {\n        vec4 r = vec4(ro+(rd*float(i)),1.);\n        vec4 r2 = r*rot;\n        vec3 rc=r2.xyz+.5;\n       \n        if (collision(rc)) {\n            vec3 n = normalize(r.xyz);\n            return vec4((color(rc)+ texture(iChannel1, reflect(rd,n)).rgb*.1),1);//vec4(dot(n,normalize(r2.xyz-light));\n        }\n    }\n    return vec4(sky,0.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light.y=sin(iDate.w)*5.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    THRESH = iMouse.x/iResolution.x;\n\tfragColor = (march(vec3(0,2.*(iMouse.y/iResolution.y-.5), -2), vec3(uv-.5,1)));\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    angle/=10.;\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat THRESH = 0.;\nfloat avg(vec3 c) {\n    return (c.x+c.y+c.z)/3.;\n}\nvec3 color(vec3 r) {\n    vec3 a = texture(iChannel0, r.xy).rgb;\n    vec3 b = texture(iChannel0, r.yz).rgb;\n    vec3 c = texture(iChannel0, r.xz).rgb;\n    return vec3(avg(vec3(a.x,b.x,c.x)),avg(vec3(a.y,b.y,c.y)),avg(vec3(a.z,b.z,c.z)));\n}\nbool collision(vec3 r) {\n    if (r!=mod(r,1.)) return false;\n    vec3 a = texture(iChannel0, r.xy).rgb;\n    vec3 b = texture(iChannel0, r.yz).rgb;\n    vec3 c = texture(iChannel0, r.xz).rgb;\n    return avg(vec3(avg(a),avg(b),avg(c)))>THRESH;\n}\nvec3 light = vec3(0, 0, 1);\nvec4 march (vec3 ro, vec3 rd) {\n    mat4 rot = rotationMatrix(vec3(0,1,0),iDate.w);\n    vec3 sky = texture(iChannel1, (vec4(rd,1)*rot).rgb).rgb;\n    for (float i = .0; i < 3.; i+=.005) {\n        vec4 r = vec4(ro+(rd*float(i)),1.);\n        vec4 r2 = r*rot;\n        vec3 rc=r2.xyz+.5;\n       \n        if (collision(rc)) {\n            vec3 n = normalize(r.xyz);\n            return vec4((color(rc)+ texture(iChannel1, reflect(rd,n)).rgb*.1),1);//vec4(dot(n,normalize(r2.xyz-light));\n        }\n    }\n    return vec4(sky,0.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light.y=sin(iDate.w)*5.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    THRESH = iMouse.x/iResolution.x;\n\tfragColor = (march(vec3(0,2.*(iMouse.y/iResolution.y-.5), -2), vec3(uv-.5,1)));\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define SHAFT_MULTIPLIER .2\nfloat FOV = 100.;\nvec2 project(vec3 v) {\n    float halfFovTan = tan(FOV/2.)*v.z;\n    return (v.xy/v.z)+.5;\n}\nvec2 dir(vec2 uv, vec2 v) {\n    return (v-uv)/distance(v,uv);\n}\nfloat ray(vec2 uv,vec2 dir,vec2 pix) {\n    vec2 cp = uv;\n    float j = 0.;\n    for (float i=0.;i<1000.;++i) {\n        if(texture(iChannel0,cp).w>0.) {\n            return 0.;\n        }\n        if (cp.y>1.||cp.y<0.) if (cp.x<0.||cp.x>1.) break;\n        cp+=dir*pix;\n        j=i;\n    }\n    return j/1000.;\n}\nvec3 light = vec3(0, 1, 5);\nfloat lv(vec2 cp) {\n \t if (cp.y>1.||cp.y<0.) if (cp.x<0.||cp.x>1.)\n         return .0;\n     return 1.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    light.y=5.*sin(iDate.w);\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec2 pv = project(light);\n    if (distance(uv,pv) < .01) \n    fragColor = vec4(1);\n    else\n\tif (texture(iChannel0,uv).w==1.)\n    fragColor = vec4(texture(iChannel0,uv));\n    else\n    fragColor = vec4(texture(iChannel0,uv))*(1.-SHAFT_MULTIPLIER)+((vec4(SHAFT_MULTIPLIER)*(light.z>0.?1.:0.)*ray(uv,dir(uv,pv),1./iResolution.xy)));\n}","name":"Buf B","description":"","type":"buffer"}]}