{"ver":"0.1","info":{"id":"fd3XW2","date":"1633936753","viewed":161,"name":"Cosmic Brain","username":"shyuriken","description":"Cosmic Brain  with  FOLD","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// AntiAliasing only\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 292 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nfloat luminance(vec3 col) { return dot(col, vec3(.2126729, .7151522, .072175)); }\n\nvec3 FXAA(sampler2D tex, vec2 uv) {\n\tconst vec3 e = vec3(-1, 1, 0);\n\tvec2 offuv = uv;\n\tvec3 colnw = texture(tex, uv + e.xy / iResolution.xy).rgb,\n\t     coln = texture(tex, uv + e.zy / iResolution.xy).rgb,\n\t     colne = texture(tex, uv + e.yy / iResolution.xy).rgb,\n\t     colw = texture(tex, uv + e.xz / iResolution.xy).rgb,\n\t     colm = texture(tex, uv + e.zz / iResolution.xy).rgb,\n\t     cole = texture(tex, uv + e.yz / iResolution.xy).rgb,\n\t     colsw = texture(tex, uv + e.xx / iResolution.xy).rgb,\n\t     cols = texture(tex, uv + e.zx / iResolution.xy).rgb,\n\t     colse = texture(tex, uv + e.yx / iResolution.xy).rgb;\n\tfloat ish,\n\t      lnw = luminance(colnw),\n\t      ln = luminance(coln),\n\t      lne = luminance(colne),\n\t      lw = luminance(colw),\n\t      lm = luminance(colm),\n\t      le = luminance(cole),\n\t      lsw = luminance(colsw),\n\t      ls = luminance(cols),\n\t      lse = luminance(colse),\n\t      maxl = max(ln, max(ls, max(lw, max(le, lm)))),\n\t      diff = maxl - min(ln, min(ls, min(lw, min(le, lm))));\n\tif (diff < max(.0833, .166 * maxl)) return colm;\n\tfloat filterfactor = 0.;\n\tfilterfactor += 2. * (ln + lw + ls + le) + lnw + lne + lsw + lse;\n\tfilterfactor /= 12.;\n\tfilterfactor = clamp(abs(filterfactor - lm) / diff, 0., 1.);\n\tfloat blend = smoothstep(0., 1., filterfactor);\n\tblend *= blend;\n\tish = step(2. * (le + lw - 2. * lm) + (lne + lnw - 2. * ln) + (lse + lsw - 2. * ls), 2. * (ln + ls - 2. * lm) + (lne + lse - 2. * le) + (lnw + lsw - 2. * lw));\n\tfloat psoff = ish >= 1. ? 1. / iResolution.y : 1. / iResolution.x;\n\tif (abs(ish >= 1. ? ln : le - lm) < abs(ish >= 1. ? ls : lw - lm)) psoff = -psoff;\n\tif (ish >= 1.) offuv.y += psoff * blend;\n\telse offuv.x += psoff * blend;\n\n\treturn vec3(textureLod(tex, offuv, 0.).rgb);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) { fragColor = vec4(FXAA(iChannel0, fragCoord / iResolution.xy), 1); }","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Thanks to 'Power Stone (4K)' 's lighting and shading \n// https://www.shadertoy.com/view/fdf3Wn\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 292 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n\nfloat sdHexagram(vec2 p, float r) {\n\tconst vec4 k = vec4(-.5, .8660254, .57735026, 1.7320508);\n\tp = abs(p);\n\tp -= 2. * min(dot(k.xy, p), 0.) * k.xy;\n\tp -= 2. * min(dot(k.yx, p), 0.) * k.yx;\n\tp -= vec2(clamp(p.x, r * k.z, r * k.w), r);\n\treturn length(p) * sign(p.y);\n}\n\nfloat pHexagram(float size, float h, float s, float r, vec3 p) {\n\tfloat m = (h - p.z * s) / h,\n\t      d = sdHexagram(p.xy / m, size) * m;\n\tvec2 w = vec2(d, abs(p.z) - h);\n\treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - r;\n}\n\nfloat sdRoundX(vec2 p, float w, float r) {\n\tp = abs(p);\n\treturn length(p - min(p.x + p.y, w) * .5) - r;\n}\n\nfloat pRoundX(float size, float h, float s, float r, vec3 p) {\n\tfloat m = (h - p.z * s) / h,\n\t      d = sdRoundX(p.xy / m, size, r) * m;\n\tvec2 w = vec2(d, abs(p.z) - h);\n\treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec3 mRotation(mat3 inv_rotation, vec3 p) { return inv_rotation * p; }\n\nfloat sabs(float p) { return sqrt(p * p + 1e-2); }\n\nvec3 mFold(vec3 sw, vec3 t, vec3 p) {\n\tfloat h, a,\n\t      n = sw.x,\n\t      r = sw.y;\n\tbool s = sw.z > 0.;\n\th = floor(log2(n));\n\ta = 6.2832 * exp2(h) / n;\n\tfor (int i = 0; i < int(h) + 2; i++) {\n\t\tvec2 v = normalize(vec2(-cos(a), sin(a)));\n\t\tfloat g = dot(p.xz, v);\n\t\tp.xz -= (g - ((r > 0.) ? sabs(g) : abs(g))) * v;\n\t\ta *= .5;\n\t}\n\n\tp.xz -= clamp(p.xz, s ? -t.xz : t.xz, t.xz);\n\treturn p;\n}\n\nfloat oThicken(float thickness, float d) { return d - thickness; }\n\nfloat oSmoothUnion(float k, float d1, float d2) {\n\tfloat h = clamp(.5 + .5 * (d1 - d2) / k, 0., 1.);\n\treturn mix(d1, d2, h) - k * h * (1. - h);\n}\n\nfloat sdf(vec3 p0) {\n    float sc = 0.65;\n\tp0 = p0/sc;\n\tfloat d1, d2;\n\t{\n\t\tvec3 p1 = mFold(vec3(6, 1, 1), vec3(0, 0, 3), p0);\n\t\t{\n\t\t\tvec3 p2 = mRotation(mat3(.766045, -.642788, 0, .55667, .663414, -.5, .321394, .383022, .866026), p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mFold(vec3(6, 1, 1), vec3(0, 0, 2), p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mRotation(mat3(.642788, -.766044, 0, .766044, .642788, -0, -0, 0, 1), p3);\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 p5 = mFold(vec3(6, 1, 1), vec3(0, 0, 1), p4);\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 p6 = mRotation(mat3(-0, 0, 1, 0, 1, 0, -1, 0, -0), p5);\n\t\t\t\t\t\t\td1 = pRoundX(1.58, .09, 0., .09, p6);\n\t\t\t\t\t\t\t{ d2 = pHexagram(.37*sin(iTime*0.2), 1., 0., .67, mRotation(mat3(.173648, -0, .984808, 0, 1, -0, -.984808, 0, .173648), p6)); }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn oSmoothUnion(.1, d2, oThicken(.08, d1))*sc;\n}\n#define Start0 min(iTime, 0.)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat g = 0., gTime;\n\n\nstruct Hit {\n\tfloat d;\n\tint id;\n};\n\n#define minH(a) if (a.d < h.d) h = a\n\nmat2 rot(float a) {\n\tvec2 cs = cos(vec2(a, a - 1.5705));\n\treturn mat2(cs, -cs.y, cs.x);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nHit map(vec3 p) {\n\tp.y -= 4.;\n\n\tHit h = Hit(abs(p.y + 2.), 1);\n\tfloat d2 = sdf(p);\n\tg += .00008 / (.001 + d2 * d2); \n\tminH(Hit(d2, 4));\n\n\treturn h;\n}\n\nvec3 calcNormal(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\t\n\tfloat s = 1., t = .1, i, h;\n\tfor (i = Start0; i < 15.; i++)\n\t{\n\t\th = map(t * ld + p).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 10.) break;\n\t}\n\treturn sat(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).d / h; }\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -.002); }\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 ld = normalize(vec3(6, 35, -10) - p),\n\t\t n = calcNormal(p, d), c;\n\tfloat gg = g, sp = 1.;\n\n\tif (h.id == 2)\n\t\tc = vec3(.2), sp = 3.;\n\telse if (h.id == 1)\n\t\tc = vec3(.03);\n\telse if (h.id == 3)\n\t\tc = vec3(.6);\n\telse c = vec3(.48, .1, .34);\n\n\tfloat ao = mix(ao(p, n, .2), ao(p, n, 2.), .7),\n\n\tl1 = sat(.1 + .9 * dot(ld, n))\n\t\t * (.3 + .7 * shadow(p, ld)) \n\t\t * (.3 + .7 * ao), \n\t\n\tl2 = sat(.1 + .9 * dot(ld * vec3(-1, 1, -1), n))\n\t\t + pow(sat(dot(rd, reflect(ld, n))), 10.) * sp,\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5;\n\tg = gg;\n\treturn mix((l1 * vec3(.43, .29, .52) +\n\t\t\t\tl2 * ao * vec3(2.11, 1.69, 1.48)) * c,\n\t\t\t   vec3(.05),\n\t\t\t   fre);\n}\n\nvec4 RayCast(inout vec3 p, vec3 rd, float s, float mx) {\n\tfloat d = .01, i;\n\tg = 0.;\n\tHit h;\n\tfor (i = Start0; i < s; i++) {\n\t\th = map(p);\n\n\t\tif (abs(h.d) < .0015)\n\t\t\tbreak;\n\t\td += h.d;\n\t\tif (d > mx)\n\t\t\treturn vec4(0);\n\t\tp += h.d * rd; \n\t}\n\n\tfloat pulse = mix(1., .3, (sin(gTime) * .5 + .5) * smoothstep(13., 15., gTime));\n\treturn vec4(pow(g, pulse) * vec3(.73, .5, .88) + lights(p, rd, d, h), h.id);\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n\tvec3 p = ro;\n\tvec4 col = RayCast(p, rd, 100., 50.);\n\tcol.rgb *= fog(p - ro);\n\n\tif (col.w > 1.) {\n\t\trd = reflect(rd, calcNormal(p, length(p - ro)));\n\t\tp += rd * .01;\n\t\tcol += mix(.2, .3, col.w - 2.)\n\t\t\t   * RayCast(p, rd, 50., 10.)\n\t\t\t   * fog(ro - p);\n\t}\n\treturn max(vec3(0), col.rgb);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tgTime = mod(iTime, 120.);\n   \n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 lookAt = vec3(0, 2, 0),\n         ro = mix(vec3(1, 2, -4), vec3(0, 3.5, -3)+8., smoothstep(0., 1., gTime/4.)),\n         f = normalize(lookAt - ro),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         rd = normalize(f + r * uv.x + cross(f, r) * uv.y);\n         vec3 col = scene(ro, rd);\n\t\n\tfragColor = vec4(vig(pow(col, vec3(.45)) * sat(iTime), fc), 1);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}