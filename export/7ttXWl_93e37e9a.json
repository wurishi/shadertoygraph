{"ver":"0.1","info":{"id":"7ttXWl","date":"1641747132","viewed":807,"name":"Path Tracing ( MIS )","username":"qubailiang00","description":"Write a bug","likes":19,"published":1,"flags":32,"usePreview":1,"tags":["pathtracing","mis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    //vec4 data = texture(iChannel0, fragCoord / iResolution.xy);\n    //vec3 color = data.rgb / data.a;\n    \n    color *= exposure;\n\n    color = aces(color);\n\n    color = linearToSrgb(color);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define skybox 4.0\n\n#define BounceNum 8\n#define TracPerPixelNum 8\n#define ORIGIN vec3(0.0, 0.0, -8.0)\n#define NEAR -6.3\n#define FAR 10000.0\n\n#define LightType 1.0\n#define WallType 2.0\n#define BallType 3.0\n\n#define NLight 1.0\n#define Light0_Pos vec3(-3.0, 9.99, 11.0)\n#define Light0_U vec3(6.0, 0.0, 0.0) \n#define Light0_V vec3(0.0, 0.0, 2.0) \n#define Light0_radiance vec3(21.0)\n\n#define PI 3.1416\n#define sqrt(v) sqrt(max(v, 0.0))\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    vec3 emissive;\n    vec3 specular;\n};\n\nstruct SurfGeoInfo\n{\n    vec3 pos;\n    vec3 normal;\n};\n\nstruct HitSurfInfo\n{\n    float hit;\n    SurfGeoInfo geoInfo;\n    Material material;\n};\n\nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n    float t;\n};\n\n/**\n **************************************\n  *               init               *\n **************************************\n*/\nvoid setRay(inout Ray ray, vec3 ro, vec3 rd, float t) {\n\n    ray.ro = ro;\n    ray.rd = rd;\n    ray.t = t;\n}\n\nRay setRay(vec3 ro, vec3 rd, float t) {\n\n    Ray ray;\n    ray.ro = ro;\n    ray.rd = rd;\n    ray.t = t;\n    return ray;\n}\n\nMaterial setMaterialInfo(vec3 albedo, float roughness, vec3 emissive, vec3 specular) {\n\n    Material info;\n    info.albedo = albedo;\n    info.roughness = roughness;\n    info.emissive = emissive;\n    info.specular = specular;\n    return info;\n}\n\nMaterial setMaterialInfo(Material material) {\n\n    Material info;\n    info.albedo = material.albedo;\n    info.roughness = material.roughness;\n    info.emissive = material.emissive;\n    info.specular = material.specular;\n    return info;\n}\n\nHitSurfInfo initHitSurfInfo() {\n\n    SurfGeoInfo geoInfo;\n    geoInfo.pos = vec3(0.0);\n    geoInfo.normal = vec3(0.0);\n\n    Material matInfo;\n    matInfo.albedo = vec3(0.0);\n    matInfo.roughness = 0.1;\n    matInfo.emissive = vec3(0.0);\n    matInfo.specular = vec3(0.5);\n\n    HitSurfInfo info;\n    info.hit = -1.0;\n    info.geoInfo = geoInfo;\n    info.material = matInfo;\n\n    return info;\n}\n\n/**\n **************************************\n  *             geometry             *\n **************************************\n*/\nbool testSphereGeo(inout Ray ray, inout SurfGeoInfo geoInfo, vec3 pos, float r) {\n\n    vec3 ro = ray.ro - pos;\n    vec3 rd = ray.rd;\n\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n    float h = b * b - 4.0 * c;\n\n    if(h < 0.0) return false;\n    float sqrH = sqrt(h);\n    float t = (-b - sqrH) / 2.0;\n    if(t < 0.0) t = (-b + sqrH) / 2.0;\n\n    if(ray.t > t && t > 0.0) {\n\n        ray.t = t;\n        geoInfo.pos = ray.ro + t * rd;\n        geoInfo.normal = normalize(geoInfo.pos - pos);\n        return true;\n    }\n    else return false;\n}\n\nbool testQuadGeo(inout Ray ray, inout SurfGeoInfo geoInfo, vec3 a, vec3 b, vec3 c, vec3 d) {\n\n    vec3 ro = ray.ro;\n    vec3 rd = ray.rd;\n    \n    vec3 normal = normalize(cross(c - a, b - a));\n    \n    float f = dot(normal, rd);\n    \n    if(abs(f) < 0.001) return false;\n    \n    float t = dot(a - ro, normal) / f;\n    \n    vec3 p = ro + t * rd;\n    \n    vec3 ab = a - b;\n    vec3 bc = b - c;\n    vec3 cd = c - d;\n    vec3 da = d - a;\n    \n    vec3 pb = p - b;\n    vec3 pc = p - c;\n    vec3 pd = p - d;\n    vec3 pa = p - a;\n    \n    vec3 v0 = cross(ab, pb);\n    vec3 v1 = cross(bc, pc);\n    vec3 v2 = cross(cd, pd);\n    vec3 v3 = cross(da, pa);\n    \n    float i = dot(v0, v1);\n    float j = dot(v2, v3);\n    float k = dot(v1, v2);\n    \n    if(i > 0.0 && j > 0.0 && k > 0.0 && ray.t > t && t > 0.0) {\n    \n        ray.t = t;\n        geoInfo.pos = p;\n        geoInfo.normal = normal;\n        return true;\n    }\n    return false;\n}\n\n/**\n **************************************\n  *              object              *\n **************************************\n*/\nbool testBallObj(inout Ray ray, inout SurfGeoInfo info, vec3 pos, float r) {\n\n    return testSphereGeo(ray, info, pos, r);\n}\n\nbool testLightObj(inout Ray ray, inout SurfGeoInfo info, vec3 a, vec3 b, vec3 c, vec3 d) {\n\n    return testQuadGeo(ray, info, a, b, c, d);\n}\n\nbool testWallObj(inout Ray ray, inout SurfGeoInfo info, vec3 a, vec3 b, vec3 c, vec3 d) {\n\n    return testQuadGeo(ray, info, a, b, c, d);\n}\n\n/**\n **************************************\n  *              entity              *\n **************************************\n*/\nvoid traceBallEntity(inout Ray ray, inout HitSurfInfo info){\n\n    {\n        vec3 p = vec3(-7.0, -8.0, 13.0);\n        float r = 2.0;\n    \n        if(testBallObj(ray, info.geoInfo, p, r)) {\n            \n            info.hit = BallType;\n            vec3 albedo = vec3(1.0);\n            float roughness = 0.14;\n            vec3 emissive = vec3(0.0);\n            vec3 specular = vec3(0.9);\n            info.material = setMaterialInfo(albedo, roughness, emissive, specular);\n        }\n    }\n    \n    {\n        vec3 p = vec3(7.0, 0.0, 13.0);\n        float r = 2.0;\n    \n        if(testBallObj(ray, info.geoInfo, p, r)) {\n            \n            info.hit = BallType;\n            vec3 albedo = vec3(0.96, 0.43, 0.6351);\n            float roughness = 0.1;\n            vec3 emissive = vec3(0.0);\n            vec3 specular = vec3(0.1);\n            info.material = setMaterialInfo(albedo, roughness, emissive, specular);\n        }\n    }\n    \n    {\n        vec3 p = vec3(0.0, 0.0, 13.0);\n        float r = 2.0;\n    \n        if(testBallObj(ray, info.geoInfo, p, r)) {\n            \n            info.hit = BallType;\n            vec3 albedo = vec3(0.16, 0.43, 0.351);\n            float roughness = 0.09;\n            vec3 emissive = vec3(0.0);\n            vec3 specular = vec3(0.39);\n            info.material = setMaterialInfo(albedo, roughness, emissive, specular);\n        }\n    }\n    \n}\n\nvoid traceWallEntity(inout Ray ray, inout HitSurfInfo info) {\n\n    {\n        vec3 a = vec3(-10.5, 10.6, 15.0);\n        vec3 b = vec3(-10.5, -10.6, 15.0);\n        vec3 c = vec3(10.5, -10.6, 15.0);\n        vec3 d = vec3(10.5, 10.6, 15.0);\n\n        if(testWallObj(ray, info.geoInfo, a, b, c, d)) {\n        \n            info.hit = WallType;\n            vec3 albedo = vec3(1.0);\n            float roughness = 0.02;\n            vec3 emissive = vec3(0.0);\n            vec3 specular = vec3(0.09);\n            info.material = setMaterialInfo(albedo, roughness, emissive, specular);\n        }\n    }\n    \n    {\n        vec3 a = vec3(-10.0, -10.5, 15.0);\n        vec3 b = vec3(-10.0, -10.5, 10.0);\n        vec3 c = vec3(10.0, -10.5, 10.0);\n        vec3 d = vec3(10.0, -10.5, 15.0);\n\n        if(testWallObj(ray, info.geoInfo, a, b, c, d)) {\n        \n            info.hit = WallType;\n            vec3 albedo = vec3(0.3, 0.97, 0.5);\n            float roughness = 0.04;\n            vec3 emissive = vec3(0.0);\n            vec3 specular = vec3(0.08);//vec3(1.0, 0.782, 0.344);\n            info.material = setMaterialInfo(albedo, roughness, emissive, specular);\n        }\n    }\n    \n    {\n        vec3 a = vec3(-10.0, 10.1, 10.0);\n        vec3 b = vec3(-10.0, -10.5, 10.0);\n        vec3 c = vec3(-10.0, -10.5, 15.0);\n        vec3 d = vec3(-10.0, 10.1, 15.0);\n\n        if(testWallObj(ray, info.geoInfo, a, b, c, d)) {\n        \n            info.hit = WallType;\n            vec3 albedo = vec3(0.24, 0.25, 0.98);\n            float roughness = 0.02;\n            vec3 emissive = vec3(0.0);\n            vec3 specular = vec3(0.09);\n            info.material = setMaterialInfo(albedo, roughness, emissive, specular);\n        }\n    }\n    \n    {\n        vec3 a = vec3(10.0, 10.1, 15.0);\n        vec3 b = vec3(10.0, -10.5, 15.0);\n        vec3 c = vec3(10.0, -10.5, 10.0);\n        vec3 d = vec3(10.0, 10.1, 10.0);\n\n        if(testWallObj(ray, info.geoInfo, a, b, c, d)) {\n        \n            info.hit = WallType;\n            vec3 albedo = vec3(0.95, 0.36, 0.27);\n            float roughness = 0.3;\n            vec3 emissive = vec3(0.0);\n            vec3 specular = vec3(0.09);\n            info.material = setMaterialInfo(albedo, roughness, emissive, specular);\n        }\n    }\n    \n    {\n        vec3 a = vec3(-10.0, 10.0, 10.0);\n        vec3 b = vec3(-10.0, 10.0, 15.1);\n        vec3 c = vec3(10.0, 10.0, 15.1);\n        vec3 d = vec3(10.0, 10.0, 10.0);\n\n        if(testWallObj(ray, info.geoInfo, a, b, c, d)) {\n        \n            info.hit = WallType;\n            vec3 albedo = vec3(0.76, 0.47, 0.18);\n            float roughness = 0.03;\n            vec3 emissive = vec3(0.0);\n            vec3 specular = vec3(0.09);\n            info.material = setMaterialInfo(albedo, roughness, emissive, specular);\n        }\n    }\n}\n\nvoid traceLightEntity(inout Ray ray, inout HitSurfInfo info){\n\n    // vec3 a = vec3(-3.0, 9.99, 11.0);\n    // vec3 b = vec3(-3.0, 9.99, 13.0);\n    // vec3 c = vec3(3.0, 9.99, 13.0);\n    // vec3 d = vec3(3.0, 9.99, 11.0);\n    vec3 a = Light0_Pos;\n    vec3 b = a + Light0_V;\n    vec3 c = b + Light0_U;\n    vec3 d = a + Light0_U;\n    \n    if(testLightObj(ray, info.geoInfo, a, b, c, d)) {\n        \n        info.hit = LightType;\n        vec3 albedo = vec3(1.0);\n        float roughness = 0.5;\n        vec3 emissive = Light0_radiance;\n        vec3 specular = vec3(0.0);\n        info.material = setMaterialInfo(albedo, roughness, emissive, specular);\n    }\n}\n\n\n/**\n **************************************\n  *              utils               *\n **************************************\n*/\nuint wang_hash(inout uint seed) {\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat randomFloat01(inout uint state) {\n\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nmat3 tangentSpaceToWorld(vec3 n) {\n\n    vec3 up = abs(n.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent = normalize(cross(up, n));\n\tvec3 biTangent = cross(n, tangent);\n\treturn mat3(tangent.x, n.x, biTangent.x,\n                tangent.y, n.y, biTangent.y,\n                tangent.z, n.z, biTangent.z);\n}\n\n/**\n **************************************\n  *              sample              *\n **************************************\n*/\nvec3 sampleTest(vec2 u) {\n\n    float cosTheta = 1.0 - u.x;\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\tfloat phi = 2.0 * PI * u.y;\n\treturn vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);\n}\n\nvec3 importanceSampleCos(vec2 u) {\n\n\tfloat sinTheta = sqrt(u.x);\n\tfloat phi = 2.0 * PI * u.y;\n\treturn vec3(cos(phi) * sinTheta, sqrt(1.0 - u.x), sin(phi) * sinTheta);\n}\n\nvec3 importanceSampleGGX(vec2 u, float roughness) {\n\n\tfloat u1 = u.x;\n\tfloat u2 = u.y;\n\tfloat a = roughness * roughness;\n\tfloat a2 = a * a;\n\tfloat phi = 2.0 * PI * u1;\n\tfloat cosTheta2 = (1.0 - u2) / (1.0 + (a2 - 1.0) * u2);\n\tfloat cosTheta = sqrt(cosTheta2);\n\tfloat sinTheta = sqrt(1.0 - cosTheta2);\n\treturn vec3(sinTheta * cos(phi), cosTheta, sinTheta * sin(phi));\n}\n\n/**\n **************************************\n  *               BSDF               *\n **************************************\n*/\nvec3 schlickFresnel(vec3 f0, float LoH) {\n\n\tfloat tmp = 1.0 - clamp(LoH, 0.0, 1.0);\n\tfloat tmp2 = tmp * tmp;\n\tfloat Fc = tmp2 * tmp2 * tmp;\n\treturn f0 * (1.0 - Fc) + vec3(1.0) * Fc;\n}\n\nfloat ggxTerm(float NoH, float a) {\n\n\tfloat a2 = a * a;\n\tfloat t = 1.0 + (a2 - 1.0) * NoH * NoH;\n\treturn a2 / (PI * (t * t));\n}\n\nfloat smithG_GGX(float NoV, float alphaG) {\n\n\tfloat a = alphaG * alphaG;\n\tfloat b = NoV * NoV;\n\treturn 1.0 / (NoV + sqrt(a + b - a * b) + 0.0001);\n}\n\nfloat SmithJointGGXVisibilityTerm (float NoL, float NoV, float roughness) {\n\n    float a = roughness;\n    float lambdaV = NoL * (NoV * (1.0 - a) + a);\n    float lambdaL = NoV * (NoL * (1.0 - a) + a);\n    return 0.5 / (lambdaV + lambdaL);\n}\n\n/**\n **************************************\n  *            BSDF&PDF              *\n **************************************\n*/\nvec3 diffuseBSDF(Material material, vec3 fresnel) {\n\n    return material.albedo * (1.0 - fresnel) / PI;\n}\n\nvec3 diffuseBsdfAndPdf(Material material, float NoL, vec3 fresnel, out float pdf) {\n\n\tpdf = NoL / PI;\n\treturn diffuseBSDF(material, fresnel);\n}\n\n// vec3 specularBSDF(Material material, float NoH, float NoL, float NoV, vec3 fresnel) {\n\n// \tfloat a = material.roughness * material.roughness;\n// \tfloat D = ggxTerm(NoH, a);\n// \tfloat G = smithG_GGX(NoL, a) * smithG_GGX(NoV, a);\n// \treturn D * fresnel * G;\n// }\n\nvec3 specularBsdfAndPdf(Material material, vec3 H, vec3 V, vec3 N, float NoL, float NoV, vec3 fresnel, out float pdf) {\n\n\tfloat NoH = abs(dot(N, H));\n\tfloat VoH = abs(dot(V, H));\n\tfloat a = material.roughness * material.roughness;\n\tfloat D = ggxTerm(NoH, a);\n\tfloat G = smithG_GGX(NoL, a) * smithG_GGX(NoV, a);//SmithJointGGXVisibilityTerm(NoL, NoV, a);\n\t\n\tpdf = D * NoH / (4.0 * VoH + 0.0001);\n    return D * fresnel * G;\n}\n\nvec3 directBsdfAndPdf(HitSurfInfo hitInfo, vec3 V, vec3 L, float NoL, out float pdf) {\n\n    vec3 bsdf = vec3(0.0);\n\tpdf = 0.0;\n\n\tvec3 N = hitInfo.geoInfo.normal;\n    \n\tfloat NoV = dot(V, N);\n\n\tif (NoV > 0.0) {\n\n        vec3 H = normalize(V + L);\n        vec3 fresnel = schlickFresnel(hitInfo.material.specular, dot(L, H));\n        float f = (fresnel.x + fresnel.y + fresnel.z) / 3.0;\n\n\t\tfloat diffPdf = 0.0, specPdf = 0.0;\n\t\tvec3 diffuse = diffuseBsdfAndPdf(hitInfo.material, NoL, fresnel, diffPdf);\n\t\tvec3 specular = specularBsdfAndPdf(hitInfo.material, H, V, N, NoL, NoV, fresnel, specPdf);\n\n\t\tbsdf = diffuse + specular;\n\t\tpdf = (1.0 - f) * diffPdf + f * specPdf;\n\t}\n    return bsdf;\n}\n\n/**\n **************************************\n  *           environment            *\n **************************************\n*/\nvec3 environmentLighting(vec3 dir, vec3 throughput) {\n\n    return srgbToLinear(texture(iChannel1, dir).rgb) * skybox * throughput;\n    //return vec3(0.2, 0.8, 0.9) * throughput;\n}\n\n/**\n **************************************\n  *             MISweight            *\n **************************************\n*/\nfloat powerHeuristic(float f, float g) {\n\n\treturn f * f / (f * f + g * g);\n    //return f / (f + g);\n}\n\n/**\n **************************************\n  *               light              *\n **************************************\n*/\nfloat lightPdf(SurfGeoInfo lightSamplePoint, vec3 objPos) {\n\n\tvec3 dir = objPos - lightSamplePoint.pos;\n\tfloat dist = length(dir);\n\tdir /= dist;\n\n\tif (dist < 0.1) return 0.0;\n\n\tfloat cosTheta = max(0.001, abs(dot(lightSamplePoint.normal, dir)));\n\t\n    float area = length(Light0_U) * length(Light0_V);\n\n\treturn dist * dist / (cosTheta * area);\n}\n\n\nSurfGeoInfo sampleLight(inout uint random) {\n\n    SurfGeoInfo p;\n\tp.pos = Light0_Pos + Light0_U * randomFloat01(random) + Light0_V * randomFloat01(random);\n\tp.normal = normalize(cross(Light0_U, Light0_V));\n    return p;\n}\n\n// ---------------------------------------------------------------------------------------------------\n\nbool notHit(float hit) { return hit < 0.0; }\nbool isLight(float hit) { return hit < LightType + 0.9; }\n\nHitSurfInfo traceScene(Ray ray) {\n\n    HitSurfInfo info = initHitSurfInfo();\n\n    traceWallEntity(ray, info);\n    traceLightEntity(ray, info);\n    traceBallEntity(ray, info);\n    \n    return info;\n}\n\nbool shadow(vec3 ro, vec3 rd) {\n\n    vec3 o = ro + rd * 0.01;\n    vec3 d = rd;\n    float t = FAR;\n\n    HitSurfInfo hitInfo = traceScene(setRay(o, d, t));\n\n    return !isLight(hitInfo.hit);\n}\n\nvec3 calDirectLight(Ray ray, HitSurfInfo hitInfo, inout uint random) {\n\n    vec3 radiance = vec3(0.0);\n\n    if(NLight < 0.5) return radiance; \n\n    SurfGeoInfo lsp = sampleLight(random);\n\n    vec3 L = normalize(lsp.pos - hitInfo.geoInfo.pos);\n\n\tfloat NoL = dot(hitInfo.geoInfo.normal, L);\n    if (NoL < 0.007 || dot(L, lsp.normal) > 0.01 || shadow(hitInfo.geoInfo.pos, L)) return radiance; \n\n\tfloat lPdf = lightPdf(lsp, hitInfo.geoInfo.pos);\n    if (lPdf > 0.0) {\n\n        float pdf = 0.0;\n\t    vec3 bsdf = directBsdfAndPdf(hitInfo, -ray.rd, L, NoL, pdf);\n\n\t    float weight = powerHeuristic(lPdf, pdf);\n\t    radiance = Light0_radiance * bsdf * NoL / lPdf * weight;\n    }\n\treturn radiance;\n}\n\nvec3 render(Ray ray, inout uint random) {\n\n    vec3 radiance = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n\n    HitSurfInfo hitInfo = traceScene(ray);\n    if (notHit(hitInfo.hit)) {\n\n        radiance += environmentLighting(ray.rd, throughput);\n        return radiance;\n    }\n    else if(dot(hitInfo.geoInfo.normal, ray.rd) > 0.0) return radiance; \n    else if(isLight(hitInfo.hit)) return hitInfo.material.emissive;\n\n    for (int bounce = 0; bounce < BounceNum; bounce++) {\n    \n        radiance += calDirectLight(ray, hitInfo, random) * throughput;\n\n        vec2 u2 = vec2(randomFloat01(random), randomFloat01(random));\n        vec3 h = importanceSampleGGX(u2, hitInfo.material.roughness);\n        h = normalize(h * tangentSpaceToWorld(hitInfo.geoInfo.normal));\n        vec3 v = -ray.rd;\n        vec3 fresnel = schlickFresnel(hitInfo.material.specular, dot(v, h));\n        float fresnelLobe = (fresnel.x + fresnel.y + fresnel.z) / 3.0;\n\n\t\tvec3 bsdf = vec3(0.0);\n        float pdf = 0.001;\n\n        vec3 l;\n\n        if(randomFloat01(random) < fresnelLobe) {\n\n            l = normalize(reflect(ray.rd, h));\n\n            float NoL = dot(l, hitInfo.geoInfo.normal);\n            if (NoL > 0.0) {\n\n\t\t\t    bsdf = specularBsdfAndPdf(hitInfo.material, h, v, hitInfo.geoInfo.normal, NoL, dot(hitInfo.geoInfo.normal, v), fresnel, pdf);\n                throughput *= bsdf * NoL / (pdf * fresnelLobe);\n\t\t    }\n            else return radiance;\n        }\n        else {\n\n            vec2 u = vec2(randomFloat01(random), randomFloat01(random));\n            l = importanceSampleCos(u);\n            l = normalize(l * tangentSpaceToWorld(hitInfo.geoInfo.normal));\n\n            float NoL = dot(l, hitInfo.geoInfo.normal);\n            if (NoL > 0.0) {\n\n\t\t    \tbsdf = diffuseBsdfAndPdf(hitInfo.material, NoL, fresnel, pdf);\n                throughput *= bsdf * NoL / (pdf * (1.0 - fresnelLobe));\n\t\t    }\n            else return radiance;\n        }\n\n        setRay(ray, hitInfo.geoInfo.pos + hitInfo.geoInfo.normal * 0.1, l, FAR);\n\n        hitInfo = traceScene(ray);\n        if (notHit(hitInfo.hit)) {\n\n            radiance += environmentLighting(ray.rd, throughput);\n            return radiance;\n        }\n        else if(dot(hitInfo.geoInfo.normal, ray.rd) > 0.0) return radiance; \n        else if(isLight(hitInfo.hit)) {\n\n\t        float lPdf = lightPdf(hitInfo.geoInfo, ray.ro);\n\t        float weight = powerHeuristic(pdf, lPdf);\n            radiance += hitInfo.material.emissive * throughput * weight;\n            return radiance;\n        }\n        \n        {\n        \tfloat p = max(throughput.r, max(throughput.g, throughput.b));\n        \tif (randomFloat01(random) > p) return radiance;\n        \tthroughput *= 1.0 / p;            \n        }\n    }\n    \n    return radiance;\n}\n\nvoid setCamera(vec4 mouse, inout Ray ray){\n\n    vec2 mo = mouse.xy / iResolution.xy;\n    float x = (mo.x * 2.0 - 1.0) * PI;\n    float y = -(mo.y * 2.0 - 1.0) * 1.5707963268;\n    mat4 my = mat4(cos(x), 0.0, sin(x), 0.0,\n                  0.0, 1.0, 0.0, 0.0,\n                  -sin(x), 0.0, cos(x), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n\n    mat4 mx = mat4(1.0, 0.0, 0.0, 0.0,\n                  0.0, cos(y), -sin(y), 0.0,\n                  0.0, sin(y), cos(y), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n\n    ray.ro = (my * mx * vec4(ray.ro, 1.0)).xyz;\n    ray.rd = (my * mx * vec4(ray.rd, 0.0)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint random = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(randomFloat01(random), randomFloat01(random)) - 0.5;\n    vec2 uv = (2.0 * (fragCoord + jitter) - iResolution.xy) / iResolution.y;\n    \n    Ray ray;\n    vec3 o = ORIGIN;\n    vec3 d = normalize(vec3(uv, NEAR) - o);\n    float t = FAR;\n    \n    setRay(ray, o, d, t);\n    //setCamera(iMouse, ray);\n\n    vec3 color = vec3(0.0);\n    \n    for(int i = 0; i < TracPerPixelNum; i++) color += render(ray, random) / float(TracPerPixelNum);\n\n    // vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    // if(iFrame == 0) lastFrameColor = vec4(0.0);\n    \n    // color = isnan(color.x) ? lastFrameColor.rgb : color;\n    \n    // lastFrameColor += vec4(color, 1.0);\n    // fragColor = lastFrameColor;\n    \n    //color = mix(lastFrameColor, color, 1.0 / float(iFrame + 1));\n    //fragColor = vec4(color, 1.0);\n\n\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (/*iMouse.z > 0.0 ||*/ iFrame < 2 || lastFrameColor.a == 0.0) ? 1.0 : 1.0 / (1.0 + (1.0 / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    fragColor = vec4(color, blend);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define exposure 0.2\n\nvec3 aces(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3((f.x < value) ? 1.0 : 0.0, (f.y < value) ? 1.0 : 0.0, (f.z < value) ? 1.0 : 0.0);\n}\n\nvec3 srgbToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0, 1.0);\n    \n    return mix(pow(((rgb + 0.055) / 1.055), vec3(2.4)), rgb / 12.92, LessThan(rgb, 0.04045));\n}\n\nvec3 linearToSrgb(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0, 1.0);\n    \n    return mix(pow(rgb, vec3(1.0 / 2.4)) * 1.055 - 0.055, rgb * 12.92, LessThan(rgb, 0.0031308));\n}","name":"Common","description":"","type":"common"}]}