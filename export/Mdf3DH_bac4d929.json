{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define time (iTime * 0.4)\n#define width  iResolution.x\n#define height iResolution.y\n\nconst float delta  = 0.001;\nconst float PI\t   = 3.14159265;\n\nvec3 rotateX(vec3 pos, float alpha) {\t\t\t\t\n\n\treturn vec3(pos.x, pos.y * cos(alpha) + pos.z * -sin(alpha), pos.y * sin(alpha) + pos.z * cos(alpha));\n\n}\n\n\n\nvec3 rotateY(vec3 pos, float alpha) {\n\n\treturn vec3(pos.x * cos(alpha) + pos.z * sin(alpha), pos.y, pos.x * -sin(alpha) + pos.z * cos(alpha));\n\n}\n\n\n\nvec3 translate(vec3 position, vec3 translation) {\n\n\treturn position - translation;\n\n}\n\n\n\n\n\nfloat cube(vec3 pos,float size){\n\n    return max(max(abs(pos.x)-size,abs(pos.y)-size),abs(pos.z)-size) ;//+ 0.17*sin(pos.z*2.2 + mod(time*0.02, 2.0*PI)-PI);\n\n}\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n\n{\n\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n\n  return length(q)-t.y;\n\n}\n\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n\n{\n\n  return length(max(abs(p)-b,0.0))-r;\n\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n\n{\n\n  return length(p)-s;\n\n}\n\n\n\n\n\n\t\n\n\n\n\n\nfloat opS( float d1, float d2 )\n\n{\n\n    return max(-d1,d2);\n\n}\n\n\n\n\n\n\tvec3 opRep2( vec3 p, vec3 c )\n\n{\n\n   return mod(p,c)-0.5*c;\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nfloat opU( float d1, float d2 )\n\n{\n\n    return min(d1,d2);\n\n}\n\n\n\n\n\n\n\nfloat opDisplace( vec3 p )\n\n{\n\n    float d1 = sdTorus(p, vec2(4.0,2.0));\n\n    float d2 = (sin(p.x*3.0) + sin(p.y*5.0)) *0.2;\n\n    return d1+d2;\n\n}\n\n\n\n\n\n\n\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n\n{\n\n  vec3  di = abs(p) - b;\n\n  float mc = max(di.x, max(di.y,di.z));\n\n  return min(mc,length(max(di,0.0)));\n\n}\n\n\n\nfloat sdCross( in vec3 p )\n\n{\n\n  float da = udRoundBox(p.xyz,vec3(3.0,0.5,0.5), 0.2);\n\n  float db = udRoundBox(p.yzx,vec3(0.5,3.0,0.5), 0.2);\n\n  float dc = udRoundBox(p.zxy,vec3(0.5,0.5,3.0), 0.2);\n\n  return min(da,min(db,dc));\n\n}\n\nint material = 0;\n\n\n\nfloat opRep( vec3 p, vec3 c )\n\n{\n\n    vec3 q = mod(p,c)-0.5*c;\n\n    return sdSphere( q ,0.1);\n\n}\n\nvec3 lightPosition = vec3(0.0,0.0,-1.5);\n\n\nfloat function(vec3 position) {\n\n\n\n\tvec3 pos = rotateY(rotateX(position,time*0.7),time*0.8)+vec3(-0.6,0.6,-0.6)+vec3(60.0*sin(time*0.1),0.0,0.0);\n\n\n\n\tfloat cc = 6.;\n\n\tvec3 q = mod(pos,cc)-0.5*cc;\n\n\tfloat b =// udRoundBox(q, vec3(1.0,1.0,1.0), 0.2)\n\nsdCross(q);\n\n\n\nvec3 pos2 =rotateY(rotateX(position+vec3(0.0,0.0,0.2),time*1.7),time*1.8);\n\n\n\n\n\n\n\nfloat a = opS( opRep(pos2, vec3(0.21)),udRoundBox(pos2, vec3(0.4,0.4,0.4), 0.05));\n\n\n\n//sphere(position-vec3(0.0,0.0,0.5), 0.7));\n\n\n\nfloat c = udRoundBox(q, vec3(1.0,1.0,1.0), 0.2);\n\n\n\nmaterial = 0;\n\nif( c < b)\n\nmaterial = 1;\n\nb= min(b,c);\n\n\n\nif(a < b)\n\nmaterial = 2;\n\n\n\nb =min(b, a);\n\n\n\n;//+0.07*perlin(q*3.0) ;\n\n\n\n\n\n\t//if((mod(pos,cc)-0.5*cc).x> 0.3)\n\n\t\n\n\n\n\treturn b;\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nvec3 ray(vec3 start, vec3 direction, float t) {\n\n\treturn start + t * direction;\n\n}\n\n\n\nvec3 gradient(vec3 position) {\n\n\n\n\treturn vec3(function(position + vec3(delta, 0.0, 0.0)) - function(position - vec3(delta, 0.0, 0.0)),\n\n\tfunction(position + vec3(0.0,delta, 0.0)) - function(position - vec3(0.0, delta, 0.0)),\n\n\tfunction(position + vec3(0.0, 0.0, delta)) - function(position - vec3(0.0, 0.0, delta)));\n\n\n\n\t\n\n}\n\n\n\n\n\n\n\n\n\n\nfloat aoScale = 0.3; // smaller aoScale = more AO\n\nfloat computeAO(vec3 position, vec3 normal) {\n\n\t\n\nfloat sum = 0.0;\n\nfloat stepSize = 0.015;\n\nfloat t = stepSize;\n\n\n\n\tfor(int i=0; i < 8; i++) {\n\n\t\tposition = ray(position, normal, t);\n\n\t\tsum += max(function(position),0.0);\n\n\t\tt+=stepSize;\n\n\t}\n\n\treturn 1.0-clamp(1.0 -(sum * aoScale),0.0, 1.0);\n\n}\n\n\n\nfloat computeShadow(vec3 pos) {\n\n\n\n\tfloat t = 0.0;\n\n\tfloat distance;\n\nvec3 position;\n\nfloat res = 1.0;\n\nfloat k = 10.0;\n\n\tfor(int i=0; i < 64; i++) {\n\n\t\tposition = ray(pos,normalize(lightPosition-pos) , t);\n\n\t\tdistance = function(position);\n\n\n\n\t\tif(distance < 0.007) {\n\n\t\t\tbreak;\n\n\n\n\t\t}\n\n\t\tres = min(res, k*distance/t);\t\n\n\t\tt = t + distance ;\n\n\t}\n\n\tif(length(pos - lightPosition)+0.0 < t) return res;\n\n\treturn 0.0;\n\n}\n\n\n\nvec4 computeReflection(vec3 pos, vec3 viewDirection) {\n\n\tfloat t = 0.0;\n\n\tfloat distance;\n\n\tvec3 position;\n\n       vec3 cameraPosition = pos;\n\n\tvec4 color = vec4(0.0,0.0,0.0,1.0);//vec4(0.0,0.2,0.0,1);\n\n\tvec3 normal;\n\n\tvec3 up = normalize(vec3(-0.0, 1.0,0.0));\n\n\t\n\n\tfor(int i=0; i < 35; i++) {\n\n\t\tposition = ray(cameraPosition,\tviewDirection, t);\n\n\t\tdistance = function(position);\n\n\t\t\n\n\t\n\n\t\t\n\n\t\tif(distance < 0.04) break;\n\n\t\n\n\t\t\n\n\t\t\tt = t + distance;\n\n\t}\n\n\t\t\t\t\t\t\t\t  \n\n\tnormal = normalize(gradient(position));\n\n\t\t\t\n\n\n\n\t\t\n\n\t\t\tfloat ambient = max(dot(normal, normalize(lightPosition-position)),0.0) ;\n\n\t\t\n\n\t\t\t//specular\n\n\t\t\tvec3 E = normalize(cameraPosition - position);\n\n\t\t\tvec3 R = reflect(-normalize(lightPosition-position), normal);\n\n\n\n\t\t\t\n\n\t\t\tfloat specular = pow( max(dot(R, E), 0.0), \n\n\t\t                 8.0);\n\n\n\n\t\t\t\t\t\tfloat alpha = 1.0-clamp( pow(length(position-vec3(0.0,0.0,1.0)),2.0)*0.0016,0.0, 1.0);\n\n\n\n\n\n\t\t\t\n\n\t\t\tvec3 mycolor = vec3(0.9, 0.4, 0.4);\n\n\n\n\t\t\tif(material == 1)\n\n\t\t\t\tmycolor = vec3(0.4, 0.9, 0.4);\n\n\t\t\t\n\n\t\t\tcolor = vec4((  0.6* mycolor)*(0.3+ambient*0.7),1.0);\n\n\t\t\tcolor += vec4(vec3(1.0)*1.0*specular, 1.0);\n\n\n\n\t\t\tcolor = color * alpha + vec4(0.0,0.0,0.0,1.0) *(1.0 -alpha);\t\t\t\t\t\t\t  \n\n\treturn color;\t\t\t\t\t\t\t\t  \n\n}\n\n#define pi 3.14159265\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\t\n\n\tvec3 cameraPosition = vec3(0.0, 0.0, -1.2);\n\n\t\n\n\tfloat aspect = 360.0/640.0;\n\n\tvec3 nearPlanePosition = vec3(((fragCoord.x/width)-0.5),\n\n\t\t\t\t\t\t\t      ((fragCoord.y/height)-0.5)*aspect,\n\n\t\t\t\t\t\t\t       -1.0);\n\n\t\t\t\t\t\t\t  \n\n\tvec3 viewDirection = normalize(nearPlanePosition - cameraPosition);\n\n\tfloat t = 0.0;\n\nfloat l=length(nearPlanePosition - cameraPosition);\n\n\t\n\n\t t =l;\n\n\tfloat distance;\n\n\tvec3 position;\n\n\tvec4 color =vec4(0.0,0.0,0.0,1.0);\n\n\tvec3 normal;\n\n\tvec3 up = normalize(vec3(-0.0, 1.0,0.0));\n\n\t\n\n\tfor(int i=0; i < 64; i++) {\n\n\t\tposition = ray(cameraPosition,\tviewDirection, t);\n\n\t\tdistance = function(position);\n\n\t\t\n\n\t\n\n\t\t\n\n\t\tif(distance < 0.009)break;\n\n\t\t\t\n\n\n\n\t\n\n\n\n\n\n\t\t\tt = t + distance;\n\n\t}\n\n\t\t\n\n\t\n\n\t\t\tnormal = normalize(gradient(position));\n\n\t\t\t\n\n\n\n\t\t\n\n\t\t\tfloat ambient = max(dot(normal, normalize(lightPosition-position)),0.0) ;\n\n\t\t\n\n\t\t\t//specular\n\n\t\t\tvec3 E = normalize(cameraPosition - position);\n\n\t\t\tvec3 R = reflect(-normalize(lightPosition-position), normal);\n\n\n\n\t\t\t\n\n\t\t\tfloat specular = pow( max(dot(R, E), 0.0), \n\n\t\t                 6.0);\n\n\n\n\t\t\tfloat alpha = 1.0-clamp( pow(length(position-vec3(0.0,0.0,1.0)),2.0)*0.0016,0.0, 1.0);\n\n\n\n\n\n\t\t\tvec3 mycolor = vec3(255.0/255.0,127.0/255.0,36.0/255.0);\n\n\n\n\t\t\tif(material == 1) mycolor = vec3(0.45, 0.9, 0.45);\n\n\t\t\tif(material == 2) mycolor = vec3(0.8, 0.8, 1.0) ;\n\n\t\t\tvec4 refl = computeReflection(position+normal *0.04, reflect(viewDirection, normal));\n\n\t\t\t\t\t\tfloat shad = 1.0;//computeShadow(position+normalize(lightPosition-position)*0.008);\n\n\t\t\tcolor = vec4(( refl.xyz*0.5 + 0.6* mycolor)*(0.4+ambient*0.7)*shad,1.0);\n\n\n\n\t\t\tcolor += vec4(vec3(0.7)*1.0*specular, 1.0);\n\n\t\n\n\t\t\tcolor = color * alpha + vec4(0.0,0.0,0.0,1.0) *(1.0 -alpha);\n\n\t\t\t\t\t\t\t\t\t  \n\n\t\t\t\t\t\t\t\t  \n\n\tfragColor = vec4(vec3(((color-0.5)*1.7+0.5)+0.2),1.0); \n\n\t//discard;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdf3DH","date":"1368614646","viewed":406,"name":"reflecting cube","username":"triggerHLM","description":"see iq's tutorial","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["reflection","spheretracing"],"hasliked":0,"parentid":"","parentname":""}}