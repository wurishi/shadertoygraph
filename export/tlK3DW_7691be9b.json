{"ver":"0.1","info":{"id":"tlK3DW","date":"1581087966","viewed":318,"name":"Snake Maze","username":"spalmer","description":"a simple snake game controlled by keyboard\nwhere you try to survive in a maze filled with snakes!\nclick mouse to deactivate attract mode.\nWASD or arrow controls, spacebar to replay.","likes":7,"published":1,"flags":56,"usePreview":0,"tags":["game","retro","8bit","gpusound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Font      iChannel2\n// stock font texture in iChannel2, linear filtered, using sdf in alpha\n\n// display stuff from https://shadertoy.com/view/WlVGDh\n// numeric display based on https://shadertoy.com/view/llySRh\nfloat char(vec2 p, int c)\n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.)\n        return 0.;\n    vec2 q = p/16. + fract(vec2(c, 15-c/16) / 16.);\n    vec4 t = textureLod(Font, q, 0.);\n    float scale = 64./(1.+dot(fwidth(q), vec2(1))); // could be better\n    scale = clamp(scale, 1./1024., 1024.);\n    float g = t.a; // a unorm-encoded signed distance\n    g = .5 - (g - .5) * scale; // antialiasing\n    g = clamp(g, 0., 1.);\n    return g;\n}\n\n// display unsigned int 4 digits base 10\nfloat pUint(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n); i > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    if (abs(n) < 1e-7)\n        v += char(p, 48);\n    return v;\n}\n\n// TODO state0 could go in a global \nvec4 DrawGameBoard(vec2 q, vec2 R, vec4 state0)\n{\n    vec4 c = vec4(0);\n    ivec2 qi = ivec2(floor(q));\n    vec4 statep = texelFetch(BufferB, qi, 0);\n    vec2 qf = fract(q);\n    c.rgb = vec3(statep.x); // show walls as white\n    if (statep.x == 0. && state0.w < 0.)\n        c.r = clamp(sin(iTime*14.),0.,.125);\n    // show snake trails\n    if (statep.z > 0.\n        && statep.y >= 0. && statep.y < 1.) {\n        c.rgb = hue((sqrt(5.)+1.) * 256. * statep.y + 1./3.); \n        // TODO non-player snakes should be different somehow\n        // maybe darker? less saturated? idk.\n        uint si = uint(statep.y * float(nsnakes));\n        vec4 ssi = stateSnake(si, BufferA);\n        // little eyes on the snake heads :) maybe forked tongue occasionally\n        if (abs(int(ssi.x*R.x)-qi.x)+abs(int(ssi.y*R.y)-qi.y) < 1) { //ivec2(ssi.xy) == qi) { //distance(ssi.xy * R, q) < 1.) { \n            vec2 o = dirCodeToVec2(ssi.z); o = vec2(-1,1)*.25*o.yx;\n        \tif (min(length(qf-.5-o), length(qf-.5+o)) < .1) // FIXME antialias please\n\t    \t    c.rgb -= vec3(1.); // show eyes as small black discs\n        }\n    }\n    // show snake heads/faces (slow loop! turned out unnecessary)\n    //for (uint i = 0u; i < nsnakes; ++i) {\n    //     if (distance(stateSnake(i, BufferA).xy * R, q) < 3.)\n    //    \t//if (length(qf-.5) < 1.5) // FIXME antialias please\n\t//    \t    c.rgb += vec3(1.); // show food as small red disc\n    //}\n    if (statep.z > 0. && statep.y < 0.) { \n        if (length(qf-.5) < .5) // FIXME antialias please\n\t        c.r = 1.; // show food as small red disc\n    }\n    if (!all(lessThan(uvec2(ivec2(q)), uvec2(R))))\n        c.rgb = vec3(.0,.1,.2); // past boundary\n    return c;\n}\n\nvec2 GameCamera(vec2 p, vec2 R, vec4 state0)\n{\n    const float zoom = 30.;\n    vec2 q = p/R - .5;\n    q *= zoom/R.y;\n    // display window follows player snake head\n    q += state0.xy;\n    q *= R;\n    // some temporal anti-jittering on camera is desperately needed\n    // for apparently-smooth scrolling\n    float tickfraction = TickFraction(iTime);\n    bool alive = state0.w >= 0.;\n    if (alive) // only if alive, moving\n         q += dirCodeToVec2(state0.z) * tickfraction * .75;\n    // attempting to strike a balance between wall and snake jitter\n    // also unfortunately prediction and direction changes cause pops\n    // TODO so it really could use some kind of smoothing on the camera\n    // when you change directions.  I can probably manage something.\n    return q;\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy;\n\t// player snake head is particle 0\n    vec4 state0 = texelFetch(BufferA, ivec2(0), 0);\n    vec2 q = GameCamera(p, R, state0);\n    c = DrawGameBoard(q, R, state0);\n    bool alive = state0.w >= 0.;\n    float score = floor(abs(state0.w));\n    vec2 uv = p/R;\n    // FIXME more hacks here to fix the broken aa in glyph draw\n    if (!alive) // dead, draw final score larger - FIXME seems blurry\n      c.rgb += vec3(1,1,0) * smoothstep(.2,.8,\n\t\tmax(.2, sin(iTime*14.))*pUint(p/R*2.-vec2(1.15,0), score));\n    else\n      if (uv.x >= .75 && uv.y <= .125)\n        c.rgb += vec3(1)*pUint((p - vec2(R.x*.96,3.))*16./R.y, score);\n    // TODO special FX - glow, etc.  background.  details.\n    // TODO timer ?\n\tc = vec4(pow(c.rgb, vec3(.454545)), 1); // gamma\n}\n\n\n// TODO Sound!!!\n\n //   if (false) { // snake state debug\n //       c = texelFetch(BufferA, ivec2(p*16./R.y), 0);\n //   }\n\n/* // I don't remember what this was for\nif (false && statep.z < 0.) {\n        c.b = 1.; //sqrt(statep.z);\n        //c.rb = vec2(0.); \n        //c.rgb *= hue(statep.y); \n    }   */\n\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n//    if (statep.x == 0. && Tick(iTime, iTimeDelta))\n//        c.rgb = vec3(0.,0.,.1); // flash bg deep blue on ticks\n\n\n//    vec4 statep1 = texelFetch(BufferB, ivec2(p), 1);\n// mip! TODO need mipmap filtering on iChannel1\n// the idea is to use that for some kind of collision avoidance maybe? idk.\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// common definitions\n\n#define BufferA iChannel0\n// BufferA is game entity state in iChannel0\n#define BufferB iChannel1\n// BufferB is game board  state in iChannel1\n\n// it's a little tricky now since they're in separate buffers\n// since if the buffers get resized, it's a pain to detect it \n// and actually respond properly in *both* buffers, now.\n// Also a pain to draw the new state into the game board.\n// Otherwise much cleaner, nicer this way.\n\n// snakes are particles\n// there are currently 256 snakes\n// stored arranged in a square 16x16 pattern in BufferA at lower left of image\n// player is snake 0\n\n// I arrange them all in BufferA pixels at bottom left of image in 16x16 square.\n// if you go over there to that part of the maze, you can see the data probably as a glitch.\n// but the buffer is usually pretty large and you start in the middle, so tend not to get over there.\n\n// if it becomes a problem, I can always move the particles into their own buffer\n// I can think of potential uses for the filtering effects\n\n// BufferB is game board state:\n// x is 1 if wall, 0 if not\n// y is 1 if snake, 0 if not\n// z is a trail length if > 0, decreases each step to move snakes\n\n// FIXME the 16u constant is actually used more, and don't wanna do sqrts and crap later\nconst uint nsnakes = 16u*16u;\n\n// TODO refactor state lookup stuff here\nuint snakeOfPixel(ivec2 ip)\n{\n\treturn all(lessThan(ip, ivec2(16)))\n        ? uint(ip.x + (ip.y<<4))\n        : ~0u;\n}\n\nvec4 stateSnake(uint si, sampler2D bufA)\n{\n    return si >= 256u ? vec4(0) : texelFetch(bufA, ivec2(si&15u, si>>4), 0);\n}\n\n// TODO at least document this pseudo-structure\n// x,y = board position of head\n// z = head facing signs in high bits\n// w = score (affects length - eventually!), negative if dead\nvec4 stateSnake(vec2 p, sampler2D bufA)\n{\n    return texelFetch(bufA, ivec2(p), 0);\n}\n\nvec2 dirToVec2(uint d)\n{\n    // FIXME the table lookup isn't optimal, actually; should compute it\n    const vec2[5] tbl = vec2[5](vec2(0.),vec2(1,0),vec2(0,1),vec2(-1,0),vec2(0,-1));\n    return tbl[d + 1u]; // so ~0 maps to first entry, shift em all over\n//    (du & 1u) != 0u ? 1. : -1.;\n//        vel.y = (du & 2u) != 0u ? 1. : -1.;\n}\n// FIXME why bother with such encoding\nuint dirOfZ(float z)\n{\n    return uint(z*4.0001); // 4 gray levels indicate facing signs\n}\n\nvec2 dirCodeToVec2(float z)\n{\n    return dirToVec2(dirOfZ(z));\n}\n\n\n// earliest use of this method I can find is by las in 2011:\n// http://pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\nvec3 hue(float h)\n{\n\tvec3 h3 = fract(h + vec3(0, 2./3., 1./3.));\n\treturn clamp(abs(h3 * 6. - 3.) - 1., 0., 1.);\n}\n\n// random stuff from https://shadertoy.com/view/3sVXWw\n\nfloat osctri(float x) \n{\n\tfloat i = floor(x); \n\tx -= i; // mirror odds to preserve local contiguity\n\tfloat o = float(int(i) & 1);\n    return o + x - 2.*o*x; // branchless\n}\n\n// a scaled version of smoothstep\nfloat bentstep(float x)\n{\n\treturn ((.75 - .5*x)*x + .75)*x;\n}\n\n// similar to rand(x) but preserves local g0 contiguity; \n// also decorrelates output from input\nfloat oscrand(float x)\n{\n\tx = osctri(x); // fract(x) would destroy contiguity (a little bit)\n\tx = bentstep(x); // *gentle* nonlinear remapping; smoothstep is too much!\n \tx *= 47918.; // tile an even bunch of times after bending\n\tx = osctri(x);\n    return x;\n}\n\n// TODO I want to drive tickspersecond\n// based on skill level, and I want skill\n// to be keyboard controlled so\n// tickspersecond = digit * 2.0\n// but also probably increase \n// over time or with score, somehow.\nconst float tickspersecond = 7.; //3.; //5.; //9.; // TODO arg, change with difficulty\n\nconst float foodLen = 2.; //3.; // escalation factor; growth due to eating\n\nfloat TickFraction(float iTime) \n{\n\treturn fract(iTime * tickspersecond);\n}\n\nint TickIndex(float iTime) \n{\n\treturn int(floor(iTime * tickspersecond));\n}\n\nbool Tick(float iTime, float iTimeDelta) \n{\n\tint t0 = int((iTime - iTimeDelta) * tickspersecond);\n    int t1 = int( iTime               * tickspersecond);\n\treturn t0 != t1;\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define Keyboard  iChannel2\n// Keyboard is in iChannel2  (256 x 3 x r8Uint)\n\n// snakes are just particles that leave trails in the buffer\n// buffer keeps a pheremone trail that fades over time\n// display shows scaled cutoff version of buffer\n\n// read keyboard key, return 1.0 if down\n// ultimately want to do differencing of negatives from positives\nfloat key(int vk) // key down state value as a float fraction\n{\n    float s = texelFetch(Keyboard, ivec2(vk,0), 0).x; // read keyboard key state from texture\n    return step(.5, s); // test if down\n}\nint keybit(int vk) // key down state value as an int 0 or 1 for bitmasking\n{\n    float s = texelFetch(Keyboard, ivec2(vk,0), 0).x; // read keyboard key state from texture\n    s = max(s, texelFetch(Keyboard, ivec2(vk,1), 0).x); // read press state from texture so we don't miss events\n    return s >= .5 ? 1 : 0; // test if down\n}\n//vec2 keyMovement()\n//{\n//    return vec2(key(68)-key(65), key(87)-key(83));\n//}\n// to the 2-bit direction code ENWS\nint keyDir()\n{\n    int r = -1;\n    int x = keybit(68)       | (keybit(65) << 2)\n         | (keybit(87) << 1) | (keybit(83) << 3); // WASD\n       x |= keybit(39)       | (keybit(37) << 2)\n         | (keybit(38) << 1) | (keybit(40) << 3); // arrows\n    int bc = ((x&5)+((x&10)>>1)); //bcount(uint(x)) //;\n    bc = (bc&3) + (bc>>2);\n    if (bc == 1) // only single-keys work\n    \t//r = int(log2(x));\n    \tr = (((x>>0)&1) != 0) ? 0 :\n     \t\t(((x>>2)&1) != 0) ? 2 :\n     \t\t(((x>>1)&1) != 0) ? 1 :\n     \t\t(((x>>3)&1) != 0) ? 3 :\n    \t\t-1;\n    return r;\n}\n\n\n// game state buffer update\n\n// FIXME I'd hate to have to make an input manager pass,\n// but dealing with inputs without missing events\n// is a royal PITA and is cluttering up the game logic\n// the input manager pass isn't the worst idea ever, actually.\n// seems wasteful but it would indeed solve many problems.\n// but managing its state transitions would be just as tricky\n// since it involves the game update transition as well.\n// synchronizing its update with the update for the rest\n// of the state could be problematic.\n\n// I hate the logic already.  Good thing I'm experimenting, not doing something for real!\n// TODO refactor this mess and make it make some sense.\nvoid gameEntityLogic(inout vec4 c, ivec2 ip)\n{\n    ivec2 R = ivec2(iResolution.xy);\n    bool init = iFrame == 0\n        || texelFetch(Keyboard, ivec2(32,1), 0).x > .5    // keybit? idk FIXME keypress?\n        || ivec2(texelFetch(BufferA, R-1, 0).xy) != R  // texel at iResolution-1 holds the buffer resolution\n        ;\n    // BufferA resolution pixel cannot be shared w BufferB but we need one so we can reset the ai snakes and player positions too\n    // TODO either that or we should generate some kind of reset signal for BufferB to use.  That could work.\n    uint i = snakeOfPixel(ip); // else invalid snake id\n    if (init) c = vec4(0.);\n    else {\n        // decided to use a special pixel to buffer input events\n        if (ip == ivec2(0,16)) { //i == nsnakes) { // input queue pixel?\n        // only update keypress bits so we don't miss any events\n        float okd = c.z; // FIXME no need to cram into 0..1 fraction anymore, just store 0. thru 3.\n        uint du = uint(okd*4.000001); // 4 gray levels indicate facing signs\n        int kdir;\n        // keyboard control for snake 0\n            // pretty snappy now, but \n            // prior, had allowed 2-point turn to full reverse within one game tick\n            // if player is fast enough with the keyboard, mashing multiple keys.\n            // the only way I could think of to handle that was to store the original\n            // facing and disallow the opposite of that, also, or, almost as good,\n            // wound up storing the latest key direction into its own special pixel.\n            // FIXME now if you're fast enough, you can't turn backward anymore but\n            // you can have commands seemingly ignored if you quickly turn twice within one tick.\n            // tracking or rejecting both last ticked and last requested separately would help.\n            // TODO maybe just store the keys, into a small ring buffer maybe, \n            // and process them 1 per game tick?  idk how best to handle it yet.\n            // I could also disallow *directly* turning into your own snake,\n            // but that's a bigger crutch.\n        kdir = keyDir();\n\t\tif (kdir >= 0\n               && ((kdir - int(du))&3)!=2 // no backwards!\n               ) {\n           \t uint dir = uint(kdir);\n           \t dir &= 3u;\n           \t c.z = float(dir) / 4.;\n        \t}\n        }       \n        if (!Tick(iTime, iTimeDelta))\n\t    \treturn; // only logic when tick updates\n    }\n    float rand = oscrand(dot(vec2(ip),vec2(.071,.037)) + iTime);\n    if (i != ~0u) { // generic snake logic\n        bool attract = length(iMouse.xy)<=1.;\n        bool isplayer = i == 0u && !attract;\n        uint dir = 0u;\n        vec2 vel = vec2(0.); // old dir\n    //    const ivec2 axis[2] = ivec2[](ivec2( 1,0), ivec2( 0,1)); // sign axis bit order\n        float okd = c.z; //texelFetch(iChannel0, ivec2(i,0), 0).z; //-1.; //\n        uint du = dirOfZ(okd);\n        dir = du;\n        vel = dirToVec2(du);\n        vec2 pos = c.xy * vec2(R); // old pos;        \n        vec2 steer = vec2(0.);\n        int kdir = int(du); // WAS UNINITIALIZED - NO WONDER they were always going right!\n        if (isplayer) { // player - uses ai logic during attract mode\n            // so it seemingly *never* uses *this* frame's input data.   \n            // FIXME that seems bad.  So far, it's very hard to notice the lag.\n            // keyboard control snake 0 from input pixel data\n            kdir = int(texelFetch(BufferA, ivec2(0,16), 0).z*4.000001); // get most recent input event from special pixel\n        } else { // AI snakes\n            if (((uint((iTime+float(i<<1))*7.1))&3u)==0u) // only infrequently\n            \tkdir = int(rand * 347.1 + iTime)&3;\n            // TODO AI - dijkstra, needs mipmaps? idk\n            // pathfinding to food or main snake, or obstacle avoidance\n            // they'll probably be really dumb for a while\n        }\n\t\tif (kdir >= 0\n               && ((kdir - int(du))&3)!=2 // no backwards!\n               ) {\n            du = uint(kdir);\n          \tdir = uint(kdir);\n        }       // if (dot(steer, steer) < 1e-2) steer = vel; // do not allow stopping\n        steer = dirToVec2(du);\n\n   \t\tbool alive = c.w >= 0.;\n    \tfloat score = floor(abs(c.w));\n        if (alive) { // alive = not dead\n         //   dir = du; //(vel.x > 0. ? 1u : 0u) | (vel.y > 0. ? 2u : 0u);\n            if (!isplayer) {\n                for (int tr=4; tr -- > 0; ) {\n                    uint dtry = (du + uint(tr))&3u;\n                    vec2 stry = dirToVec2(dtry);\n                    vec4 ctry = texelFetch(BufferB, ivec2(pos + stry), 0);\n                    if (ctry.x==0. && (ctry.z > 0. && ctry.y < 0.)) {\n                        kdir = int(dtry); // greedy turn to feed on neighboring food\n                        steer = stry;\n                    }\n                }\n            }\n            if (!isplayer) { // AI should avoid obstacles if possible\n                for (int tr=3; tr-- > 0; ) { // pretty exhaustive atm; they're still dumb tho\n            \t\tvec4 ctry = texelFetch(BufferB, ivec2(pos + steer), 0); // check arena ahead\n                    if (ctry.x > 0. || (ctry.z >= 0. && ctry.y >= 0.)) { // obstacles? walls, other snake bodies?\n                \t\t// avoid - just pick new direction- left or right\n                \t\tdu = du - 1u;\n                        if ((iFrame&256)!=0) du ^= 2u; // occasionally turn other way instead\n                        du &= 3u;\n                        dir = du;\n            \t\t\tsteer = dirToVec2(du);            \n                    }\n                }\n            }\n            vel = steer;\n            pos += vel;\n            // sample new location\n            vec4 cnew = texelFetch(BufferB, ivec2(pos), 0);\n            // collision?\n            if (cnew.x > 0. || (cnew.z >= 0. && cnew.y >= 0.\n                            //    && abs(cnew.y*256. - c.y) > 3e-3 // ignore self for now; everyone's dying instantly\n                               )) { \n                // snake death                \n                //c.z = -100.;// must set dir and pos instead as it gets overwritten later\n                // handle zero carefully, because -0 should still be dead, dammit!\n                c.w = min(-1e-3,-abs(c.w)); // die!  you're dead!  don't tick any more.\n            } else {\n                c.xy = pos;\n                // TODO eat, grow?\n                if (cnew.x == 0. && cnew.z > 0. && cnew.y < 0.) { // food?\n                    score += 1.;\n                    c.w = score;\n                }                    \n\t        }\n            // if they die, should turn head into a food!  maybe entire body.\n            // but gameboard alteration must go in the Buffer B shader, not here.\n        } else {\n            // some kind of timer - easiest thing I can think of is to only respawn every so often, globally\n            if (mod(iTime,4.)<.02) //(c.w = -float(--score)) == 0.) // no points left\n            if (!isplayer) {\n            \tpos = vec2(-1); // dead AI snakes teleport out of arena after leaving a food\n               #if 1 \n                // nvm they should teleport somewhere random instead and restart at 0 score\n                //if (attract && i == 0u || totalsnakes == 0)\n                pos = vec2(R)*mix(vec2(.2),vec2(.8),fract(vec2(456.65,357.6)*rand));\n               #endif\n                // was useful when they were dying instantly but now think they should stay dead, unless there aren't any left.\n                c.w = score = 0.;\n            }\n        }\n\n        pos = mod(pos, iResolution.xy); // just in case\n        \n        if (init) {\n            pos = vec2(R) * (i == 0u \n                ? vec2(.5)\n                : fract(vec2(456.65,357.6)*rand));\n            dir = uint(fract(rand * 73.)*4.);\n        \tc.w = 0.; // alive w no score\n        }\n        \n        dir &= 3u;\n        c.z = float(dir) / 4.;\n        c.xy = pos / vec2(R);\n        // c.w's already done I guess\n        // we can't just store into arbitrary locations, so to update the playfield,\n        // must have playfield logic scan for snakes!  will be lagged by one frame.\n    } else { // special pixel for storing buffer resolution\n\t    if (init) {\n            // reciprocal storage finally caused an actual problem:\n            // was breaking the browser thumbnails, so I just store rez directly now\n    \t    if (ip == R-1)\n        \t    c.xy = iResolution.xy; // enables detecting resized buffer\n\t\t    // the very last pixel at iResolution-1 holds the buffer resolution in .xy\n\t    }\n    }\n}\n\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    ivec2 ip = ivec2(p);\n    c = texelFetch(iChannel0, ip, 0);\n    gameEntityLogic(c, ip);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define Keyboard  iChannel2\n\n// leaving BufferB filter linear\n// so can do derivatives if needed, may need mips later\n\n// probably breaks the traversability somehow, but adds variety.\n//#define Z(U)  (((((int(U.x)|int(U.y))>>5)&1)==0) ? 16 : 32)\n#define Z(U)  64\n\n// ALU maze macro based on toy by Fabrice Neyret \n// https://shadertoy.com/view/lt2cRR\n#define maze(U) \\\n   ((int((U)[int(1e4*length(ceil((U)/float(Z(U)))))&1])&(Z(U)-1))!=0)\n// cached to BufferA, just in first frame\n// for some kind of semi-interesting playfield.\n\n\n// game board state buffer update\n\n\nvoid gameBoardLogic(inout vec4 c, ivec2 ip)\n{\n    ivec2 R = ivec2(iResolution.xy); // texel at iResolution-1 holds the buffer resolution in xy\n    bool init = iFrame == 0\n        || texelFetch(Keyboard, ivec2(32,1), 0).x > .5 // spacebar = replay\n \t\t|| ivec2(texelFetch(BufferB, R-1, 0).xy) != ivec2(R) // if resized buffer, reinit\n        ;\n    // can't use BufferA's resolution pixel because BufferA pass already fixed it! too late!\n    if (init) c = vec4(0.);\n    else if (!Tick(iTime, iTimeDelta))\n       return; // only logic when tick updates\n    float rand = oscrand(dot(vec2(ip),vec2(.071,.037)) + iTime);\n\t // generic playfield logic\n    if (!init) {\n        if (c.x == 0.) { // don't mess with walls\n            for (uint sy = 0u; sy < 16u; ++sy) {\n\t\t\t\tfor (uint sx = 0u; sx < 16u; ++sx) {\n\t\t\t\t\tuint si = sx+sy*16u;\n                    vec4 astate = texelFetch(BufferA, ivec2(sx,sy), 0); //stateSnake(si, BufferA)\n                    ivec2 apos = ivec2(astate.xy * vec2(R));\n                    ivec2 rpos = apos - ip;\n                    if (rpos == ivec2(0)) { // check for snake heads!                        \n                    \tc.z = astate.w < 0. ? 1024. : 1. + .005*iTime + foodLen * astate.w;\n                        c.y = astate.w < 0. ? -1. // dead snakes leave food\n                        \t: float(si)/256.; // snake id \n                    }\n                }\n            }\n        }\n        c.z = max(-1., c.z - 1./12.); // dim trail, scrolls body\n    }\n    if (init) {\n        if (rand < 7.9e-3) // initial food scarceness\n            c.z = 1000.;\n        // FIXME maze macro works on floats\n        if (!maze(vec2(ip+1)+float(Z(U))*(.5+mod(iDate.w,17.)))\n          || ip.x==0 || ip.y==0 || ip.x==int(R.x)-1 || ip.y==int(R.y)-1 // border to prevent escape! haha!\n           ) {  // wraparound was neat but not intended.  Kinda confusing.\n            c.x = 1.; c.z = 0.;\n        }\n        if (abs(ip.x-R.x/2)+abs(ip.y-R.y/2) < 20)\n            c.x = 0.; \t// clear out area around player start so they don't immediately hit a wall\n        c.y = -1.;\n        if (ip == R-1) c.xy = vec2(R); // rez pixel at top right\n    }\n}\n\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    ivec2 ip = ivec2(p);\n    c = texelFetch(BufferB, ip, 0);\n    gameBoardLogic(c, ip);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float gain = .08; // hopefully not too annoying when it doesn't work\n// my envelope sucks atm so do not make it too loud or you might blow a speaker\n// you can mute it if you hate it!\n\nvec2 mainSound( in int samp,float time)\n{\n    // A blip in beat with the game tick - better than nothing\n    // and should maybe help people time their turns\n    // unless it's out of sync somehow, but I think that\n    // the way iq does the sound rn it stays sync'd.\n    // But they must reset the iTime to sync.\n    int ti = TickIndex(time); //, 1./iSampleRate\n    float p = 2.;\n    if ((ti & 3) == 0) p *= 1.5;\n    if (((ti>>3) & 1) == 0) p *= 1.2;\n    p = fract(p) + 1.;\n    float p2 = (fract(p * 1.3333) + 1.) * 2.;\n    return vec2(sin(6.2831*220.0*vec2(p,p2)*time)\n                * exp2(-300.0*TickFraction(time))) * gain;\n}\n\n","name":"Sound","description":"","type":"sound"}]}