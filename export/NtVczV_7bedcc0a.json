{"ver":"0.1","info":{"id":"NtVczV","date":"1661853573","viewed":153,"name":"Step Parallax Mapping Bricsys","username":"SergeySivak","description":"A step version of the parallax mapping algorithm","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["stepparallaxmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define heightCoef (20.0)\n#define lightDir normalize(vec3(1.,1.,0.5))\n#define PI 3.14\n#define cameraPos vec3(0.75, 0.75, 2.)\n\nvec3 getNormal(vec2 uv);\nvec3 animateLightPoint();\nvec2 mapParallaxPoint(vec2 textureCoordinates, vec3 directionOfView, float parallaxScale);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvOriginal = fragCoord/iResolution.xy*1.5;\n    \n    vec3 texPosition = vec3(uvOriginal.x, uvOriginal.y, 0.0);\n    vec3 viewDirection = cameraPos - texPosition;\n    \n    const float parallaxScale = (1.0/heightCoef);\n    vec2 uv = mapParallaxPoint(uvOriginal, viewDirection, parallaxScale);\n    if(uv.x > iResolution.x || uv.y > iResolution.y || uv.x < -iResolution.x || uv.y < -iResolution.y)\n        discard;    \n    \n    vec3 lightPos = vec3(5.5, 4.5, 4.5);\n    vec3 L = normalize(lightPos - vec3(uv, 0.));\n    vec3 N = getNormal(uv);\n    //phong\n    float attenuation = dot(N, L);\n    \n    fragColor = vec4(vec3(attenuation), 1.);\n \n}\n\nvec3 getNormal(vec2 uv)\n{\n    vec3 vector1;\n    vec3 vector2;\n    float deltaHeight;\n    float stepUv = 1./512.;\n    \n    deltaHeight = ( texture(iChannel0, vec2(uv.x, uv.y+stepUv)).x - texture(iChannel0, vec2(uv.x, uv.y-stepUv)) ).x * heightCoef;\n    vector1.x = 0.;\n    vector1.y = deltaHeight;\n    vector1.z = 1.0;\n    \n    deltaHeight = ( texture(iChannel0, vec2(uv.x+stepUv, uv.y)).x - texture(iChannel0, vec2(uv.x-stepUv, uv.y)) ).x * heightCoef;\n    vector2.x = 1.;\n    vector2.y = deltaHeight;\n    vector2.z = 1.0;\n    \n    return normalize(cross(vector1, vector2));\n}\n\nvec2 mapParallaxPoint(vec2 texCoords, vec3 viewDir, float parallaxScale)\n{ \n    // количество слоев глубины\n    const float numLayers = 32.0;\n    // размер каждого слоя\n    float layerDepth = 1.0 / numLayers;\n    // глубина текущего слоя\n    float currentLayerDepth = 0.0;\n    // величина шага смещения текстурных координат на каждом слое\n    // расчитывается на основе вектора P\n    vec2 P = viewDir.xy / viewDir.z * parallaxScale; \n    vec2 deltaTexCoords = P / numLayers;\n  \n    // начальная инициализация\n    vec2  currentTexCoords     = texCoords;\n    float currentDepthMapValue = texture(iChannel0, currentTexCoords).x;\n\n    while(currentLayerDepth < currentDepthMapValue)\n    {\n        // смещаем текстурные координаты вдоль вектора P\n        currentTexCoords -= deltaTexCoords;\n        // делаем выборку из карты глубин в текущих текстурных координатах \n        currentDepthMapValue =  texture(iChannel0, currentTexCoords).x;  \n        // рассчитываем глубину следующего слоя\n        currentLayerDepth += layerDepth;  \n    }\n\n    // находим текстурные координаты перед найденной точкой пересечения,\n    // т.е. делаем \"шаг назад\"\n    vec2 prevTexCoords = currentTexCoords + deltaTexCoords;\n\n    // находим значения глубин до и после нахождения пересечения \n    // для использования в линейной интерполяции\n    float afterDepth  = currentDepthMapValue - currentLayerDepth;\n    float beforeDepth = texture(iChannel0, prevTexCoords).x - currentLayerDepth + layerDepth;\n\n    // интерполяция текстурных координат \n    float weight = afterDepth / (afterDepth - beforeDepth);\n    vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);\n\n    return finalTexCoords; \n}    \n\n","name":"Image","description":"","type":"image"}]}