{"ver":"0.1","info":{"id":"Dd2GRz","date":"1667241865","viewed":480,"name":"Tsuru Kadama","username":"panna_pudi","description":"Steve","likes":45,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tsuru Kadama by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, Shane, z0rg, Tater, nekos in general\n// BigWings, FabriceNeyret, iq, and Blackle for sharing their knowledge\n//\n// Used postprocessing shader by Flokaroo for pencil effect\n// https://www.shadertoy.com/view/MsKfRw\n\nvoid blink(inout vec3 col, vec2 uv, vec2 off, float dir) {\n    float e = sd_box(uv - off, vec2(.75, .4)) - 0.015;\n    e = abs(e) - 0.0025;\n    vec2 p = uv * rot(1.075);\n    e *= smoothstep(0., .1, dir * (p.x + 0.01));\n    col = mix(col, vec3(.85), AAstep(0., e));\n}\n\nvoid frame(inout vec3 col, vec2 uv) {\n    float bx = sd_box(uv, vec2(0.75, 0.4)) - 0.015;\n    float dx = abs(bx) - 0.007; \n    dx = AAstep(dx, 0.);\n    bx = AAstep(0., bx);\n    \n    float bd = sd_box(uv - vec2(.045, -.05), vec2(.75, .38)) - .025;\n    float sd = smoothstep(.055, 0., bd);\n    \n    float cracks = texture(iChannel2, uv * .5).b;\n    cracks = smoothstep(.4, 0., cracks);\n    \n    vec3 base = vec3(.83);\n    base = mix(base * .3, base, clamp((uv.y + .5), 0., 1.));\n\n    vec3 edge = vec3(0.001);    \n    blink(edge, uv, vec2(0.005, -0.005), -1.);\n    blink(edge, uv, vec2(0.0025, -0.0025), 1.);\n    \n    vec2 p = abs(uv) - vec2(0.71, 0.36);\n    float cx = AAstep(length(p) - 0.02, 0.);\n    float cxs = AAstep(length(abs(uv - vec2(0.008, -0.005)) - vec2(0.71, 0.36)) - 0.02, 0.);\n    vec3 clips = vec3(0.15) + cracks * 0.25;\n    clips = mix(clips, vec3(0.0), AAstep(0., sd_circle(p, 0.015)));\n    p *= rot(hash21(floor(uv) + 1.) * TAU);\n    clips = mix(clips, vec3(0.), 1. - AAstep(0.001, sd_line(p, vec2(-0.005), vec2(0.005))));\n    \n    col = mix(col, base, bx);\n    col = mix(col, vec3(0.1), min(cracks, bx));\n    col = mix(col, col * .15, min(sd, bx));\n    col = mix(col, col * .10, max(cxs, cx));\n    col = mix(col, edge, dx);\n    col = mix(col, col * .85, max(hash21(uv), bx));\n    col = mix(col, clips, cx);\n}\n\n#define sc (iResolution.x/600.)\n    \nvec2 roffs;\nfloat ramp;\nfloat rsc;\nfloat T;\nvec4 getRand(vec2 pos) {\n    vec2 tres=vec2(textureSize(iChannel1,0));\n    vec2 uv=pos/tres.xy;\n    return textureLod(iChannel1,uv,0.);\n}\n\nvec4 getCol(vec2 pos) {\n    vec4 r1 = (getRand((pos+roffs)*.05*rsc/sc+T*13.)-.5)*10.*ramp;\n    vec2 res0=vec2(textureSize(iChannel0,0));\n \n    vec2 uv=(pos+r1.xy*sc)/iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n\n    return c;\n}\n\nfloat getVal(vec2 pos) {\n    return clamp(dot(getCol(pos).xyz,vec3(.3333)),0.,1.);\n}\n\nvec2 getGrad(vec2 pos, float eps) {\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getVal(pos+d.xy)-getVal(pos-d.xy),\n        getVal(pos+d.yx)-getVal(pos-d.yx))/eps/2.;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    T = floor(iTime / S) * S;\n \n    \n    vec3 col = vec3(0.);\n    vec4 r = getRand(fragCoord*1.2/sqrt(sc))-getRand(fragCoord*1.2/sqrt(sc)+vec2(1,-1)*1.5);\n    vec4 r2 = getRand(fragCoord*1.2/sqrt(sc));\n    \n    float br=0.;\n    roffs = vec2(0.);\n    ramp = .7;\n    rsc=.7;\n    int num=3;\n    for(int i=0; i < num;i++) {\n        float fi=float(i)/float(num-1);\n    \tfloat t= .03 + .25 * fi, w = t*2.;\n    \tramp = .15 * pow(1.3, fi*5.); rsc=1.7*pow(1.3,-fi*5.);\n    \tbr += .6*(.5+fi)*smoothstep(t-w/2.,t+w/2.,length(getGrad(fragCoord,.4*sc))*sc);\n      }\n    col=vec3(1)-.7*br*(.5+.5*r2.z)*3./float(num);\n    col=clamp(col,0.,1.);\n\n    ramp=0.;\n    int hnum=5;\n    #define N(v) (v.yx*vec2(-1,1))\n    #define CS(ang) cos(ang-vec2(0,1.6))\n    float hatch = 0.;\n    float hatch2 = 0.;\n    float sum=0.;\n    for(int i=0;i<hnum;i++) {\n \t\tfloat br=getVal(fragCoord+1.5*sc*(getRand(fragCoord*.02+ T * 1003.).xy-.5))*1.7;\n    \tfloat ang=-.5-.8*float(i)*float(i);\n    \tvec2 uvh=mat2(CS(ang),N(CS(ang)))*fragCoord/sqrt(sc)*vec2(.05,1)*1.3;\n    \tvec4 rh = pow(getRand(uvh-1502.23 *T+vec2(sin(uvh.y),0)),vec4(1.));\n    \thatch += 1.-smoothstep(.5,1.5,(rh.x)+br)-.3*abs(r.z);\n    \thatch2 = max(hatch2, 1.-smoothstep(.5,1.5,(rh.x)+br)-.3*abs(r.z));\n    \tsum+=1.;\n    \tif( float(i)>(1.-br)*float(hnum) && i>=2 ) break;\n    }\n    col*=1.-clamp(mix(hatch/sum,hatch2,.5),0.,1.);\n   \n    frame(col, uv);\n    \n    col = pow(col, vec3(.4545));\n    col = clamp(col, vec3(.0), vec3(1.));\n    \n    fragColour = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nconst float TAU = 2. * PI;\nfloat S = 0.08;\n#define sat(a) clamp(a, 0., 1.)\n#define AAstep(x0, x) clamp(((x) - (x0)) / (1. * 2. / iResolution.y), 0., 1.)\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat hash31(vec3 p) {\n    float n = sin(dot(p, vec3(7, 157, 113)));\n    return fract(262144. * n);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sd_circle(vec2 p, float r) {\n    return length(p)  - r;\n}\n\nfloat sd_box(vec2 p, vec2 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, p.y));\n}\n\nfloat sd_box(vec3 p, vec3 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nfloat sd_line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float k = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return distance(p, mix(a, b, k));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sd_trig(in vec2 p) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0 / k;\n    if (p.x + k * p.y > 0.0)\n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float T;\n\nfloat shape(vec3 p, vec2 id, float time, float dir) {\n    p.y += 0.;\n    p.xy *= 4.55;\n    float a = atan(p.x, p.y);\n    vec3 q = p;\n    float f = length(q.xy) - 1.1;\n    vec2 tube = vec2(f, p.z);\n    tube.x *= cos(a) * tan(a);\n    tube *= rot(a + time * dir);\n    float d = sd_box(tube, vec2(0.2));\n    return d;\n}\n\nfloat map(vec3 p) {\n    float time = T;\n\n    vec2 c = vec2(.60, 1.5);\n    vec2 id = floor(p.xy / c);\n    vec2 q = p.xy - vec2(0., mod(id.x, 2.) * c.y / 2.);\n    vec2 id2 = floor(q.xy / c);\n    \n    p.xy = mod(q + c, c) - 0.5 * c;\n    if (mod(id2.y, 2.) == 0.) p.y *= -1.;\n    \n    float d = length(p) - 0.45;\n    d = shape(p, id, time, mod(id.x, 2.) * 2. - 1.);\n    //d = shape(p, id, time, hash21(id.xx + 10.) * 2. - 1.);\n\n    return d;\n}\n\nvec3 get_norm(float d, vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.0001);\n    return normalize(d - vec3(map(k[0]), map(k[1]), map(k[2])));\n}\n\nvec2 trace(vec3 ro, vec3 rd, int steps) {\n    float t = 0.;\n    for (int i = 0; i < steps; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        float pres = 12.5 / iResolution.y;\n        if ((d) < 0.001)\n            return vec2(d, distance(p, ro));\n        t += d;\n    }\n    return vec2(-1.);\n}\n\nvoid mainImage(out vec4 out_colour, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    if (abs(uv.x) > 0.8 || abs(uv.y) > 0.45) { out_colour = vec4(vec3(0.), 1.); return; }\n    uv *= 1.23; uv.y += 0.04;\n    \n    T = floor(iTime / S) * S;\n    \n    float zoom = 3.0 - 0.1;\n    vec3 rd = normalize(vec3(0., 0., 1.));\n    vec3 ro = vec3(0., 0.2, -3.0) + vec3(uv * zoom, 0.);\n    \n    float fblend = 0.;\n    \n    float sep = -(uv.x-uv.y)+.25;\n    vec2 q = uv - vec2(0.28, -0.15);\n    q *= rot(-1.25);\n    sep = sd_trig(q * 1.1) / 1.1;\n    \n    vec3 col = vec3(0.);\n    vec2 res = trace(ro, rd, 128);\n    \n    float ao=1.;\n    vec3 pos = ro + rd * res.y;\n    vec3 light = normalize(vec3(1,.6,.3));\n    vec3 n = get_norm(res.x, pos); \n    fblend = 1. - smoothstep(-.2, .2, abs(dot(rd, n)) - .2);\n    \n    float fog = clamp(2.5 - .5 * length(pos), 0.,1.);\n    float diff=clamp(dot(normalize(n),normalize(light)),0.,1.)*.6;\n    vec3 sha = vec3(mix(diff, ao, .25)) * fog;\n    col = sha;\n    \n    float px = fwidth(uv.y);\n    col = mix(col, (1. - col) * 0.75, smoothstep(px, -px, sep));\n    \n    vec4 precol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fblend*8.); \n    out_colour = mix(precol, vec4(clamp(col, 0., 1.), 1), blend);\n}","name":"Buffer A","description":"","type":"buffer"}]}