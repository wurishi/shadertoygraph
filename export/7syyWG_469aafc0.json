{"ver":"0.1","info":{"id":"7syyWG","date":"1655466750","viewed":290,"name":"Colorful Smoke Tunnel","username":"meowyih","description":"A very simple shader demostrates how a simplest raymaching works.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymaching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I made this shader just to demostrate how a simplest raymarching works.\n// The code will be explained in my post in the bbs ptt.cc #1Yh87LWt (GameDesign) [ptt.cc]\n//\n// ... Yes, there is still someone using bbs in 2022. *giggle*\n//\n// The code below contains iq's noise 3d function. I found it in someone's \n// shader in shadertoy.com. I don't know where the original code is.\n// Sorry about that.\n\n\n////////////////////////////////////////////////////////////////////////////////////////\n// iq's 3d noise functions from the elevated shader (incl. modifications where needed)\n////////////////////////////////////////////////////////////////////////////////////////\n\n// rotation matrix for fbm octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n              \n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// iq's fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\treturn f/0.875;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n// end of iq's 3d noise functions from the elevated shader\n////////////////////////////////////////////////////////////////////////////////////////\n\n// create a foggy world with a tunnel along the z-axis with 0.8 radius\nfloat world( vec3 pos )\n{\n    return fbm(pos * 4.) - clamp(0.8 - length(pos.xy), 0., 1.);\n}\n\nfloat raymarch( in vec3 ro, in vec3 rd )\n{    \n    float density = 0.;    \n    // we march 20 times to get the density\n    int steps = 20;\n    // each step we move 0.1 unit\n    float t = 0.1;\n    // we start from ro (ray origin)\n    vec3 pos = ro;\n    for(int i=0; i<steps; i++)\n    { \n        pos = pos + t*rd; // move one step\n \n        float den = world( pos ); // get the density of that pos\n        if( den>0.01 )  \n        { \n            density += den * 0.02; // increase the density\n        } \n    }\n    return density;\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3\n    (\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (0,0) is at the center of screen, and y-axis range is from [1, -1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // ray origin, we move forward the origin by time\n    vec3 ro = - vec3(0.,0.,-iTime*2.);\n\n    // ray direction, we rotate the screen by time\n    vec3 rd = normalize( rotateZ(iTime) * vec3(uv,1.) );\n    \n    // get the density\n    float density = raymarch( ro, rd );\n    \n    // add some random color just for fun\n    fragColor = vec4(density) * vec4(sin(uv.x), cos(uv.y), 1./length(uv), 1.) * 5.;\n}\n","name":"Image","description":"","type":"image"}]}