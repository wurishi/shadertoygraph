{"ver":"0.1","info":{"id":"ttlGD8","date":"1556232404","viewed":202,"name":"Ray Marching Fractal Spheres","username":"kindpotato","description":"This is a shit shader I made. I say it is shit because it looks really glitchy. oh well.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractalraymarchingspheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define offsetDist(offset) dist = distance(pos,ballPos+offset)-ballRadius;if (dist < t){t = dist;newPos = ballPos+offset;}\nvec4 distToFractal(vec3 pos){\n    vec3 ballPos = vec3(0);\n    float ballRadius = 1.3;\n    float time = 3.14159265*sin(iTime*1.1)/20.;\n    vec2 rotator = vec2(cos(time),sin(time));\n    vec3 X = vec3(1.5,0,0);\n    vec3 Y = vec3(0,1,0);\n    vec3 Z = vec3(0,0,1);\n    float t = 1000.;\n    vec3 newPos;\n    float dist;\n    \n    for (int i = 0; i < 6; ++i){\n        \n        \n       \n        //float midt = length(pos-ballPos)-ballRadius;\n        offsetDist(vec3(0));\n        ballRadius /= 2.;\n\t\t\n        offsetDist(X)\n       \toffsetDist(Y)\n        offsetDist(Z)\n        offsetDist(-X)\n        offsetDist(-Y)\n        offsetDist(-Z)\n      \t/*if (midt < t){\n            return vec4(normalize(pos-ballPos),midt);\n            \n        }*/\n        \n        X = vec3(rotator.x*X.x - rotator.y*X.y,rotator.x*X.y+rotator.y*X.x,0);\n        X /= 2.;\n        Y /= 2.;\n        \n        Z /= 2.;\n        ballPos = newPos;\n    }\n    return vec4(normalize(pos-newPos),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    float aspect = iResolution.x/iResolution.y;\n    vec3 viewingNormal = normalize( vec3( uv-vec2(0.5,0.5/aspect),1));\n    float time = iTime * 0.1;\n    vec3 cameraPos = 10.*vec3(cos(time),cos(iTime)/5.,sin(time));\n    vec3 currentPos = cameraPos;\n    vec3 Z = -normalize(currentPos);\n    vec3 X = normalize(cross(vec3(0,1,0),Z));\n    vec3 Y = cross(Z,X);\n    viewingNormal = viewingNormal.x * X + viewingNormal.y * Y + viewingNormal.z *Z;\n    fragColor = vec4(0,0,0,1);\n    for (int i = 0; i < 50; ++i){\n        vec4 NT = distToFractal(currentPos);\n        if (NT.w < 0.001){\n            const vec3 lightPos = vec3(2,-10,4);\n            vec3 position = viewingNormal*NT.w;\n            vec3 surfaceToLight = normalize(lightPos - position);\n            vec3 reflected = reflect(viewingNormal,NT.xyz);\n            float sky = asin(dot(NT.xyz,vec3(0,1,0)))/3.141459+0.5;\n            float shine = smoothstep(0.8,1.,dot(reflected,surfaceToLight));\n            float diffuse = dot(NT.xyz,surfaceToLight);\n            fragColor = vec4(vec3(0.1+0.3*shine+0.5*sky+0.3*diffuse),1);\n        }\n        currentPos += viewingNormal*NT.w;\n        \n    }\n}","name":"Image","description":"","type":"image"}]}