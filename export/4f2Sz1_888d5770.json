{"ver":"0.1","info":{"id":"4f2Sz1","date":"1706048359","viewed":111,"name":"Extended Newton Experiments","username":"Seebone","description":"Experimenting and producing fractals with the 2-variable equivalent of newton's method. An improvement on another shader I made a while ago.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sdf","implicit","newton","algorithm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Viewport parameters */\n// The distance from the left to the right of the viewport\n#define WIDTH 4.\n// Don't change:\n#define HEIGHT (WIDTH * iResolution.y/iResolution.x)\n// Coordinates at center of viewport\n#define CENTER (vec2(0.))\n\n/* zero plane */\n// Manual\n//#define Z_LEVEL 0.\n// Animated 0-level\n#define Z_LEVEL smp(iTime, -.9, .105, 20., .1)\n\n/* Field parameters */\n// Curve AA\n#define AA_DIST 1.\nconst float DF_RAMPDOWN_FRAC = .1;\n#define CWP 2.\n#define LAA(dist) (clamp(.5 + (dist*iResolution.x/WIDTH - .5*CWP)/AA_DIST, 0., 1.))\nconst float MAX_CURVE_NUM = 50.;\nconst vec3 FIELD_COL = vec3(0.396,0.137,0.588);\n\n\n/* constants */\n#define M_PI 3.1415926535897932384626433832795\n#define M_TAU 6.2831853071795864769252867665590\n#define M_SQRT2 1.4142135623730950488016887242096\n#define FLT_MAX 3.402823466e+38\n\n\n// https://www.desmos.com/calculator/udnerpr09b\nfloat smp(float x, float yMin, float yMax, float period, float L) {\n    period = abs(period)*.5;\n    L = clamp(L, 0., 1.)*period;\n    // Function\n    x += .5*L;\n    bool a = mod(x,2.*period) >= period;\n    x = (a ? 1. : -1.)*smoothstep(L, period, mod(x, period)) + (a ? 0. : 1.);\n    \n    //shifting\n    return yMin + (yMax - yMin)*x;\n}\n\n// Change to any function\nfloat implicit(float x, float y) {\n      //return x * y * (abs(x) + abs(y) - 1.);\n      //return abs(x+y) + abs(x-y)-1.;\n      return pow(3.*x*x - y*y, 2.)*y*y - pow(x*x + y*y, 4.);\n      //return pow(x*x + y*y, 2.) - 2.*(x*x - y*y);\n      //return tan(x*y*sin(y*x)*cos(x*x)) ;\n      //return cos(x*x) + sin(y*x);\n      //return cos(x * y) + y * sin(x) -1.;\n      //return x*x*x + y*x + y*y - 1.;\n      //return x*x*y + y*y*x;\n      //return sin(y)+cos(x);\n      //return sin(x+y)-cos(x*y) - 1.;\n      //return x*x*x + y*y-1.;\n      //return x*x;\n      //return sin(x*x) - y;\n      //return abs(x*y)-x;\n}\n\n// z-shifted since all algorithms are made to detects roots\nfloat f(vec2 p) {\n    return implicit(p.x, p.y) - Z_LEVEL;\n}\n\n// https://www.desmos.com/calculator/v1mtyxl9rx\nfloat triangle(float x, float L) {\n    x = mod(x,2.*L);\n    return x <= L ? x/L : 2.-x/L;\n}\n\n/*\nvec3 cGrad(vec2 p) {\n    float r = (p.x-CENTER.x)/WIDTH+0.5; // fraction along x-axis\n    float g = (p.y-CENTER.y)/HEIGHT + 0.5; // fraction along y-axis\n    float b = 1.-r; // inverse fraction along x-axis\n    // Distance from upper right corner\n    //float b = distance(vec2(CENTER.x + WIDTH / 2., CENTER.y + HEIGHT / 2.), p)*inversesqrt(WIDTH * WIDTH + HEIGHT * HEIGHT);\n    return pow(clamp(vec3(r,g,b), 0., 1.), vec3(2.2));\n}*/\n\n\nvec3 cGrad(vec2 p) {\n    float r = triangle(p.x-CENTER.x+.5*WIDTH, WIDTH); // fraction along x-axis\n    float g = triangle(p.y-CENTER.y+.5*HEIGHT, HEIGHT); // fraction along y-axis\n    float b = 1.-r; // inverse fraction along x-axis\n    // Distance from upper right corner\n    //float b = distance(vec2(CENTER.x + WIDTH / 2., CENTER.y + HEIGHT / 2.), p)*inversesqrt(WIDTH * WIDTH + HEIGHT * HEIGHT);\n    return pow(clamp(vec3(r,g,b), 0., 1.), vec3(2.2));\n}\n\n/* Works by extending newton's method to 2 variables and treating the found root as the closest point on the curve */\n// Same as dividing by gradient length when iters=1\nvec2 newton2D(vec2 uv, int iters, out float pathLen, out bool rootFound) {\n    const vec2 h = vec2(1e-4, 0.);\n    if (iters == 0) return uv;\n    pathLen = 0.;\n    \n    float fVal;\n    vec2 grad;\n    \n    for(int i = 0; i < iters; i++) {\n        fVal = f(uv);\n        // Expensive:\n        vec2 grad = .5*vec2(f(uv+h) - f(uv-h), f(uv + h.yx) - f(uv - h.yx))/h.x;\n        // Cheap:\n        //grad = vec2(f(uv+h)-fVal, f(uv+h.yx)-fVal) / h.x;\n    \n        float dot2grad = dot(grad, grad);\n        uv -= fVal/dot2grad * grad;\n        pathLen += abs(fVal)*inversesqrt(dot2grad);\n    }\n    \n    rootFound = abs(fVal) <= 1e-1; // actually checking if point is reasonably close to a root\n    return uv;\n}\n\n// https://www.desmos.com/calculator/oel9bzjirl\nfloat DFVisual(float d, float a, float L) {\n    a = clamp(a, 0., 1.);\n    d = fract(d/L);\n    float U = d < 1.-a ? d/(1.-a) : (1.-d)/a;\n    return U;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    const vec2 h = vec2(1e-4, 0.);\n    // Normalizes x-distance to 1 while keeping aspect ratio and shifting so that (0,0) is at center of viewport.\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.x;\n\n    // transforming to correct size and position\n    uv *= WIDTH;\n    uv += CENTER;\n    \n    vec2 uv0 = uv;\n    float pathLen;\n    bool root;\n    uv = newton2D(uv, 50, pathLen, root);\n    \n    vec3 col = vec3(0.); // vec3(0.) can be replaced with cGrad(uv0)\n    \n    if (root) {\n        // Calculate distance:\n        float dist = clamp(distance(uv0, uv),0.,1e30); // good to clamp this\n\n        // Draw fractal:\n        col = cGrad(uv); // try subtracting cGrad(uv0)\n\n        // Comparing distance and length of path taken\n        float pathDiff = clamp(pow((abs(dist-pathLen)), 2.), 0., 1.);\n        float pathRatio = clamp(abs(dist/pathLen), 0., 1.);\n        \n        \n        col *= pathDiff;// shade using path difference\n        col *= 2.*pathRatio;\n        //col = mix(col, vec3(0.,1.,1.), 1.-pathRatio); \n        //col = mix(col, vec3(0.,1.,1.), pathDiff); \n        //col = pathDiff*mix(col, vec3(0.,1.,1.),pathRatio);// draw path ratio\n        \n\n        \n        // Choose one:\n        //float DF = clamp(DFVisual(dist, DF_RAMPDOWN_FRAC, WIDTH/MAX_CURVE_NUM) - pathDiff , 0., 1.);\n        //float DF = clamp(DFVisual(dist, DF_RAMPDOWN_FRAC, WIDTH/MAX_CURVE_NUM) , 0., 1.);\n\n        // Draw distance field:\n        //col = mix(col, vec3(.5), DF);\n\n        //col = mix(vec3(1.), col, LAA(dist)); // draw curve \n    }\n    \n    // Gamma \n    col = pow(col, vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}