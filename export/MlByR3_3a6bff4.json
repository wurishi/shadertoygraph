{"ver":"0.1","info":{"id":"MlByR3","date":"1509545926","viewed":1546,"name":"3D Cube","username":"nhoughto","description":"Cube, 3D","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","floating","rotatingcube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Referencing the tutorial here: http://fabricecastel.github.io/blog/2016-02-11/main.html\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\nconst float S = 0.01;\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n    float s = 1.0;\n    vec3 q = abs(p) - vec3(s);\n    float dist = max(max(q.x, q.y), q.z);\n    if(q.x > 0.0 && q.y > 0.0 && q.z > 0.0){\n        dist = length(q);\n    }\n    return dist;\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n    \tdistanceToNearestSurface(p + deltax)-d,\n        distanceToNearestSurface(p + deltay)-d,\n        distanceToNearestSurface(p + deltaz)-d\n    ));\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n                \nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  \tfloat dist = 0.0;\n    float nearest = 0.0;\n    bool hit = false;\n    for(int i = 0; i < 20; i++){\n        float nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < 0.01){\n            vec3 hit = p + dir * dist;\n            vec3 light = vec3(100.0*sin(iTime),\n                             \t30.0 * cos(iTime),\n                              \t30.0 * cos(iTime));\n            return computeLambert(hit, computeSurfaceNormal(hit), light);\n        }\n        dist += nearest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n  \t// camera attributes\n    // cameraDirection and cameraUp MUST be normalized\n    // (ie. their length must be equal to 1)\n    float cameraDistance = 10.0;\n    vec3 cameraPosition = vec3(cameraDistance * sin(iTime), 0.2 * cameraDistance * cos(iTime), cameraDistance * cos(iTime));\n    vec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0, -1.0 * cos(iTime));\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    // generate the ray for this pixel\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n\tvec3 pixelColor = intersectsWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}