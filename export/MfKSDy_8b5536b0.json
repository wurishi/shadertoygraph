{"ver":"0.1","info":{"id":"MfKSDy","date":"1715739597","viewed":59,"name":"Simple Field of Boxes","username":"triggthediscovery","description":"Simple effect showing a field of (pseudo) 3d boxes. I don't know if this method of pseudo 3D has legs beyond these simple effects, but it works well for situations like this with no occlusion.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float dx = sin(iTime/3.0)/1.0;    \n    float dy = sin(iTime/2.0)*1.3;  \n    float ds = 1.0+(cos(iTime/2.0)/2.0);\n\n    uv.x += dx;\n    uv.y += dy;\n    \n    uv.x -= 0.5;\n    uv.y -= 0.5;\n\n    vec3 col = vec3(0,0,0);\n\n    // set_point controls x/y size.\n    float set_point = ds;\n    // depth controls depth.\n    float depth = 1.0/ds;\n    // WARNING: the rectangular prisims will break if they're\n    // too tall relative to their x/y size. It should work with these\n    // presets but they're fairly temperamental.\n    \n    float x_scale_base = 20.0;\n    float x_amt = depth;\n    float y_scale_base = 10.5;\n    float y_amt = depth/2.0;\n    float parallax_speed = 20.0/depth;\n\n    vec2 uv2 = uv;\n\n    uv2.x += (dx/parallax_speed);\n    uv2.y += (dy/parallax_speed);\n    \n    // This is some precalulation to lessen the code iceburg.\n    float c_0 = float(mod(((uv.y * y_scale_base)), 2.0));\n    float c_1 = float(mod(((uv2.y* (y_scale_base - y_amt))), 2.0));\n    float cx_0 = float(mod(((uv.x * x_scale_base)), 2.0));\n    float cx_1 = float(mod(((uv2.x* (x_scale_base - x_amt))), 2.0));\n    \n    bool bot = c_0 > set_point;\n    bool top = c_1 > set_point;\n    bool bot_x = cx_0 > set_point;\n    bool top_x = cx_1 > set_point;\n\n    // This is for the fronts of the cubes, fairly simple.\n    if (top && top_x) {\n        col = vec3(1);\n    }\n    \n    // This is for the tops and bottoms of the cubes, less simple.\n    // In short, you use the delta between the top and bottom layer\n    // to get the height, which is then used to calculate if you hit\n    // the side.\n    if (bot && !top) {\n        float height = 0.0;\n        float place = 0.0;\n    \n        // This is to check if it's a top or bottom. Once you have\n        // the height, it doesn't matter which it is.\n        if (c_0-c_1 > 1.0) {\n            float dist = abs(-(c_0-c_1-2.0));\n\n            place = c_1 / -dist;\n        } else {\n            float dist = abs(c_1-c_0);\n\n            place = (c_1-set_point) / dist;\n        }\n        \n        height = (place+1.0);\n        \n        float nx = uv.x + ((dx/parallax_speed) * height);\n        \n        if (mod((nx*(x_scale_base - (x_amt * height))), 2.0) > set_point) {\n            if (c_0-c_1 > 1.0) {\n                col = vec3(0.8);\n            } else {\n                col = vec3(0.4);\n            }\n        }\n    }\n    \n    // This is for the sides of the cubes, more or less identical to the tops & bottoms.\n    if (bot_x && !top_x) {\n        float height = 0.0;\n        float place = 0.0;\n    \n        if (cx_0-cx_1 > 1.0) {\n            float dist = abs(-(cx_0-cx_1-2.0));\n\n            place = cx_1 / -dist;\n        } else {\n            float dist = abs(cx_1-cx_0);\n\n            place = (cx_1-set_point) / dist;\n        }\n        \n        height = (place+1.0);\n        \n        float ny = uv.y + ((dy/parallax_speed) * height);\n        \n        if (mod((ny*(y_scale_base - (y_amt * height))), 2.0) > set_point) {\n            if (cx_0-cx_1 > 1.0) {\n                col = vec3(0.7);\n            } else {\n                col = vec3(0.5);\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}