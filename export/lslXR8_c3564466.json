{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//#define NO_BAIL\nconst vec3 grid = vec3(4.0);\nconst vec3 griddiv = vec3(2.0);\nconst vec3 aabb  = vec3(0.75, 0.25, 0.25);\nconst vec3 aabb2 = vec3(0.25, 0.85, 0.25);\nconst vec3 aabb3 = vec3(0.25, 0.25, 0.85);\n\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x+q.y+q.z-h)/3.0 );\n}\n\nfloat box(vec3 p) {\n\treturn min(  pyramid( vec3(p.x,-p.y,p.z)-vec3(0.0,0.0,0.0),1.0),\n\t\tmin( pyramid(p-vec3(0.0, 0.0, 0.0), 0.90),\n\t\tmin(min(length(max(abs(p)-aabb, 0.0)),\n\t\t\tlength(max(abs(p)-aabb2, 0.0))),\n\t\t\tlength(max(abs(p)-aabb3, 0.0)))));\n}\n\nvec3 rot(vec3 p, float f) {\n\tfloat s = sin(f);\n\tfloat c = cos(f);\n\tp.xy *= mat2(c, -s, s, c);\n\tp.yz *= mat2(c, -s, s, c);\n\treturn p;\n}\n\nvec3 trans(vec3 p, out float rotout) {\n\tvec3 rep = floor(p/grid);\n\tp = mod(p,grid)-griddiv;\n\trotout = iTime*0.28 + (rep.x+rep.z+rep.y)*0.3;\n\tp = rot(p, rotout);\n\treturn p;\t\n}\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.02,0.0,0.0);\n\treturn normalize(vec3(\n\t\tbox(p+e.xyy)-box(p-e.xyy),\n\t\tbox(p+e.yxy)-box(p-e.yxy),\n\t\tbox(p+e.yyx)-box(p-e.yyx)));\n}\n\nfloat scene(vec3 p) {\n\tfloat dummy;\n\treturn box(trans(p,dummy));\n}\n\nvec3 normal(vec3 p, float d) {\n\tvec3 e = vec3(0.04,0.0,0.0);\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-d,\n\t\tscene(p+e.yxy)-d,\n\t\tscene(p+e.yyx)-d));\n}\n\nbool raystep(inout float d, inout vec3 p,vec3 ray){\n\tconst float eps=0.016;\n\td=scene(p);\n\tp+=max(eps,d*0.99)*ray;\n\treturn (d < eps);\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n\txy.y *= -iResolution.y / iResolution.x;\n\n\tvec3 ro = 2.0*normalize(vec3(cos(iTime/4.0),cos(iTime/4.0),sin(iTime/4.0)));\n    vec3 eyed = normalize(vec3(0.0) - ro);\n    vec3 ud = normalize(cross(vec3(0.0,1.0,0.0), eyed));\n    vec3 vd = normalize(cross(eyed,ud));\n\n\tconst float fov = 3.14 * 0.7;\n\tfloat f = fov * length(xy);\n\tvec3 rd = normalize(normalize(xy.x*ud + xy.y*vd) + (1.0/tan(f))*eyed);\n\n\tvec3 p = ro;\n\tfloat d=0.017;\n\tfloat dummy;\n\tbool hit=false;\n\t\n\tfor(int i = 0; i < 64; i++) \n\t{\n\t\t#ifdef NO_BAIL\n\t\thit = ( hit == false ) ? raystep(d,p,rd):true;\n\t\t#else\n\t\thit = ( hit == false ) ? raystep(d,p,rd):true;\n\t\tif (hit) continue;\n\t\t#endif\n\t}\n\t\n\tvec3 bg = normalize(p).zzz + 0.21;\n\t\n\tif(d < 0.016) {\n\t\tvec3 n = normal(p,d); \n\t\tvec3 col = vec3(dot(vec3(0.0,0.0,1.0), n));\n\t\tfloat objrot;\n\t\tvec3 objp = trans(p,objrot);\n\t\tvec3 objn = abs(rot(n,objrot));\n\t\t\n\t\tvec2 uv = \n\t\t\t(objn.y > 0.707) ? vec2(objp.zx) : \n\t\t\t(objn.x > 0.707) ? vec2(objp.zy) :\n\t\t\t\t\t\t\t   vec2(objp.xy) ;\n\t\tvec3 tex = texture(iChannel0, uv).rgb;\n\t\tvec3 hl = smoothstep(0.6, 1.0, col);\n\t\tcol *= clamp(tex.xyz+0.13, 0.0, 1.0);\n\n\t\tcol = col + hl*.4;\n\t\tfloat dall = length(p-ro)*1.20;\n\t\tfloat fog = clamp(dall/mix(90.0,40.0,((rd.z+1.0)*0.5)), 0.0, 1.0);\n\n\t\tfragColor = vec4(mix(col, bg, fog),1.0);\n\t}\n\telse {\n\t\tfragColor = vec4(bg, 1.0);\n\t}\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lslXR8","date":"1396842816","viewed":463,"name":"branchless distance field","username":"Panoptics","description":"Building on earlier work. Eliminated branches in inner loop.\nPoint is marched until it hits a surface. Once a surface is hit loop continues, but does nothing more till expired.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","voxel","cubes"],"hasliked":0,"parentid":"","parentname":""}}