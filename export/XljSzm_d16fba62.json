{"ver":"0.1","info":{"id":"XljSzm","date":"1442521880","viewed":148,"name":"8 Sensatron Countdown Sequence","username":"evilzug","description":"a sequence that plays when sensatron is about to head out - colors change from blue, to red, to yellow, to green, to flashing green and white","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sensatron","sensatom","countdown"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"vec3 hsv2rgb_smooth( in vec3 c ) { vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 ); rgb = rgb*rgb*(3.0-2.0*rgb); return c.z * mix( vec3(1.0), rgb, c.y); }\nvec3 outputColor(float aFinalHue, float aFinalSaturation, float aFinalValue) { return hsv2rgb_smooth(vec3(aFinalHue, aFinalSaturation, aFinalValue)); }\nfloat rand(vec2 co) { return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453); }\nfloat convertHue(float aHue) { return aHue/360.0; }\n\nconst float PURPLE = 304.0;\nconst float BLUE = 239.0;\nconst float CYAN = 183.0;\nconst float GREEN = 131.0;\nconst float YELLOW = 62.0;\nconst float ORANGE = 42.0;\nconst float RED = 0.0;\n\nfloat ROWS = 12.0;\n\nfloat evaluateColor(in vec2 fragCoord, in float aCycle, in float aCycleDelay) {\n//float evaluateColor(in float aRow, in vec2 fragCoord, in float aCycle) {\n    float tFinalHue = 0.0;\n    float iCurrentTime = iTime - aCycleDelay;\n    //float iCurrentTime = iTime - (aCycle * aRow);\n    float tPercentTimeUntilAllRed = iCurrentTime/aCycle;\n    if (tPercentTimeUntilAllRed > (fragCoord.x/iResolution.x)) {\n        tFinalHue = convertHue(RED) + sin(iTime*1.1)*.075;\n        if (tPercentTimeUntilAllRed > 1.0) {\n            float tPercentTimeUntilAllYellow = (iCurrentTime-aCycle*12.0)/aCycle;\n            if (tPercentTimeUntilAllYellow > (fragCoord.x/iResolution.x)) {\n                tFinalHue = convertHue(YELLOW) + abs(sin(iTime*0.9)*.05)*-1.0;\n                float tPercentageTimeUntilAllGreen = (iCurrentTime-aCycle*2.0*12.0)/aCycle;\n                if (tPercentageTimeUntilAllGreen > (fragCoord.x/iResolution.x)) { \n                    tFinalHue = convertHue(GREEN);\n                }\n            }\n        }\n    } else {\n        tFinalHue = convertHue(BLUE) + abs(sin(iTime * .6)*.075);\n    }\n    return tFinalHue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float tCountdownTimeInMinutes = 10.0;\n    float tSecondsInAMinute = 60.0;\n    float tTotalTimeInSeconds = tCountdownTimeInMinutes * tSecondsInAMinute;\n    float tColors = 3.0;\n    float tCycle = (tTotalTimeInSeconds/tColors)/ROWS;\n    float tFinalHue = 0.0;\n    float tFinalSaturation = 1.0;\n    if (fragCoord.y > (iResolution.y * (11.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*0.0);\n    } else if (fragCoord.y > (iResolution.y * (10.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*1.0);\n    } else if (fragCoord.y > (iResolution.y * (9.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*2.0);\n    } else if (fragCoord.y > (iResolution.y * (8.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*3.0);\n    } else if (fragCoord.y > (iResolution.y * (7.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*4.0);\n    } else if (fragCoord.y > (iResolution.y * (6.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*5.0);\n    } else if (fragCoord.y > (iResolution.y * (5.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*6.0);\n    } else if (fragCoord.y > (iResolution.y * (4.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*7.0);\n    } else if (fragCoord.y > (iResolution.y * (3.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*8.0);\n    } else if (fragCoord.y > (iResolution.y * (2.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*9.0);\n    } else if (fragCoord.y > (iResolution.y * (1.0/ROWS))) {    \n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*10.0);\n    } else {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*11.0);\n    }\n    \n    float tPercentageTimeUntilDone = iTime/(tCycle*3.0*12.0);\n    if (tPercentageTimeUntilDone > 1.0 ) {\n        tFinalSaturation = abs(sin(iTime)) * .5;\n    }\n    \n\tfragColor = vec4(outputColor(tFinalHue, tFinalSaturation, 1.0), 1.0);\n}\n\n/*\nfor (float i = 0.0; i < 12.0; i++) {\n        if (fragCoord.y > (iResolution.y * (11.0/ROWS)) && \n            fragCoord.y < (iResolution.y * (12.0/ROWS))) { //trying to figure out how to mod with 'i'\n            tFinalHue = evaluateColor(i, fragCoord, tCycle); //???\n            break;\n        }\n    }\n*/\n\n/* previous non-for-looped code\n\n*/","name":"","description":"","type":"image"}]}