{"ver":"0.1","info":{"id":"WsyGRw","date":"1569866947","viewed":203,"name":"Visualiser 103","username":"Cotterzz","description":"This is the third version of my visualiser, it's averaging the whole spectrum over a single octave\nEach colour corresponds to a note.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fft","spectrum","audio","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nThe next version of my audio shader\nhttps://www.shadertoy.com/view/wsKGzD - 102\nhttps://www.shadertoy.com/view/3dV3zh - 101\nThis version shows a single octave which is the average of all octaves\n*/\n\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 toCenter = vec2(0.5)-uv;\n    float angle = (atan(toCenter.y,toCenter.x)+PI)/TWO_PI;\n    float radius = length(toCenter)*2.0;\n    \n    // take the levels from 0.5 to 1.0;\n    float fftA = texture(iChannel0, vec2(0.5+(angle/2.0),0.0)).r;\n    // take the levels from 0.25 to 0.5;\n    float fftB = texture(iChannel0, vec2(0.25+(angle/4.0),0.0)).r;\n    // take the levels from 0.125 to 0.25;\n    float fftC = texture(iChannel0, vec2(0.125+(angle/8.0),0.0)).r;\n    // take the levels from 0.0625 to 0.125;\n    float fftD = texture(iChannel0, vec2(0.0625+(angle/16.0),0.0)).r;\n    // take the levels from 0.03125 to 0.0625;\n    float fftE = texture(iChannel0, vec2(0.03125+(angle/32.0),0.0)).r;\n    // take the levels from 0.015625 to 0.03125;\n    float fftF = texture(iChannel0, vec2(0.015625+(angle/64.0),0.0)).r;\n\t// take the levels from 0.0078125 to 0.015625;\n    float fftG = texture(iChannel0, vec2(0.0078125+(angle/128.0),0.0)).r;\n\t// take the levels from 0.00390625 to 0.0078125;\n    float fftH = texture(iChannel0, vec2(0.00390625+(angle/256.0),0.0)).r;\n    // take the levels from 0.001953125 to 0.00390625;\n    float fftI = texture(iChannel0, vec2(0.001953125+(angle/512.0),0.0)).r;\n    // there are better ways of coding this,\n\t// but this works great for execution,\n\t// and saves on compile time and loop unrolling etc.\n    \n    // leaving this here, even though its not used, this is the entire waveform:\n    // float fftwaveform = texture(iChannel0, vec2(angle,0.0)).r;\n    \n    // add them all together\n    float fftwaveformTotal = fftA+fftB+fftC+fftD+fftE+fftF+fftG+fftH+fftI;\n    \n    // take the levels from 0.0009765625 to 0.001953125;\n    // this last grab of data is just used to taper the display\n\t// and hide an ugly step where the octave starts\n    float fftJ = texture(iChannel0, vec2(0.0009765625+(angle/1024.0),0.0)).r;\n    fftJ *= angle;\n    fftwaveformTotal += fftJ;\n    \n    // take the avaerage\n    float fftwaveform = fftwaveformTotal/10.00;\n    \n    // make it think its just looking at the final octave\n    float frequency = 5000.00 + angle * 5000.00;\n    \n    float halfsteps = 69.00 + 12.00*log2(frequency/440.00);\n    \n    float notes = fract(halfsteps/12.00);\n    \n    float notevolume = step(radius,fftwaveform);\n    \n    float dissonance = abs(fract(notes*12.00)-0.5);\n    \n    float strength = notevolume*(1.0-dissonance);\n    \n    float c = 0.6;\n    \n    vec4 col = ( c + c*cos( TWO_PI * notes + vec4(0,23,21,0)  ) )*strength;\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}