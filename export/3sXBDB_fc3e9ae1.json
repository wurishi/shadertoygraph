{"ver":"0.1","info":{"id":"3sXBDB","date":"1588944061","viewed":268,"name":"ShATI - Enchant√©","username":"Flopine","description":"My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 4th subject: enchanted :) ","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mix","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define time iTime\n#define PI 3.141592\n#define TAU (2.*PI)\n#define ratio vec2(1.,0.9)\n#define dt (mod(time*PI/5.,TAU))\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(12.4,23.1)))*1245.4);}\n\nvec2 hash22(vec2 v) \n{ return fract(sin(vec2(v.x*v.x, v.x*v.y)*245.314)*44.129);}\n\n\n// reference for animation curves: https://easings.net/\nfloat easeInOutCirc(float x)\n{\n    return x < 0.5 ? \n        (1. - sqrt(1. - pow(2. * x, 2.))) / 2. : \n    (sqrt(1. - pow(-2. * x + 2., 2.)) + 1.) / 2.;\n}\n\nvec3 scale_grid(vec2 uv, float detail)\n{\n    uv *=detail;\n\n    vec2 ga = mod(uv, ratio)-ratio*0.5;\n    vec2 gb = mod(uv-ratio*0.5, ratio)-ratio*0.5;\n    vec2 guv = (dot(ga,ga)<dot(gb,gb))? ga:gb;\n    float sdist = max(abs(guv).x, dot(abs(guv),normalize(ratio)));\n    vec2 gid = uv-guv;\n    return vec3(gid,sdist);\n}\n\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat prim1 (vec3 p)\n{\n    return cyl(p.xzy, 0.5+sin(p.y*1.5)*0.4, 1.);\n}\n\n#define anim(ti,u) easeInOutCirc(sin(length(u)+ti)*0.5+0.5)\n\nvec3 new_p;\nfloat g1 = 0.;\nfloat SDF (vec3 p)\n{ \n    p.y += sin(dt)*0.1;\n    new_p = p;\n    vec2 cuv = vec2(atan(p.z,p.x),p.y);\n    vec3 sg = scale_grid(cuv, 2.+anim(dt,p));\n    float mask = sg.z*anim(dt,p);\n    mask = clamp(1.-mask,0.,1.);\n    float d = mix(prim1(p), length(p)-.7, mask);\n    g1 += 0.003/(0.003+d*d);\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat spec (vec3 rd, vec3 n, vec3 l)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(h,n),0.),20.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\t\n    // formula by alkama <3\n    vec3 bg = vec3(pow(\n        \t\t\tsmoothstep(0.045*abs(floor(uv*80.).y),\n                               .0,\n                               length((fract(uv*80.)+vec2(sin(dt),cos(sin(dt))))-hash22(floor(uv*80.)))),\n        \t\t\t10.)\n                  );\n\n    vec3 ro = vec3(0.,0.,-2.7),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        l = vec3(1.,2.,-3.),\n        col = bg;\n\n    float shad; bool hit=false;\n\n    for(float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        d *= 0.6+dither*0.1;\n        p += d*rd;\n    }\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = vec3(shad);\n        col += spec(rd, n, l);\n    }\n    float glow_col = clamp(length(new_p.xy*0.5),0.,1.);\n    col = mix(col, col+g1*vec3(glow_col,glow_col*0.4,0.)*texNoise(uv*0.5).r, anim(dt,uv));\n\n    fragColor = vec4(clamp(col,0.,1.),1.);\n}","name":"Image","description":"","type":"image"}]}