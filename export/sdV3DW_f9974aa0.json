{"ver":"0.1","info":{"id":"sdV3DW","date":"1631600106","viewed":183,"name":"Stepper","username":"neurofuzzy","description":"Traffic jam model. Blue particles move to the right if there is space available. Red particles move up if there is space available. Blue particles have right-of way. Change the filling fraction in Buffer A and observe whether it jams or not.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["automata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Based off of IQ's https://www.shadertoy.com/view/XstGRf\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t=texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n    vec3 col = (t > (1.0/3.0) ) ? ((t > (2.0/3.0))? vec3(1.0,0.0,0.0) : vec3(0.0,0.0,1.0)) : vec3(0.9,0.9,0.9);\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float fillingfraction=0.2;\n\n//converts a float in the range [0,1] to an integer {0,1,2}\nint multistep(float t) {\n    return (t > (1.0/3.0) ) ? ((t > (2.0/3.0))? 2 : 1) : 0;\n}\nfloat multistepf(float t) {\n    return (t > (1.0/3.0) ) ? ((t > (2.0/3.0))? 1.0 : 0.5) : 0.0;\n}\nint Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n\n    // fetch texel\n    return multistep(texelFetch(iChannel0, p, 0 ).x);\n}\n/* Update rules. Cell X gets changed to cell Y based on the five surrounding ones.\na cell is 0 if empty, 1 if occupied with a right-mover, 2 if occupied with an up-mover.\n\nFor the sake of drawing stuff to the screen easily, the numbers {0,1,2} are mapped to\n{0.0,0.5,1.0} in the return values, so that's what assigning to Y means.\n\nTo take these rules and turn them into the \"succinct\" evolutionRule function, I just \nconsider the cases where Y is not set to zero. There's probably a better way to implement\nit, let me know if you figure it out.\n\n\nE A\nB X C -> Y\n  D\n\nIf X=0:\n    Case 1: cell stays empty (3*3*3*2*2=108 possibilities).\n  *     *\n{0,2}   0    * -> 0\n      {0,1}\n    Case 2: filled with a right-mover (3^4=81 possibilities).\n* *\n1 0 * -> 1\n  *\n    Case 3: filled with n up-mover (2*3^3=54 possibilities).\n  *   *\n{0,2} 0 * -> 2\n      2\n\nIf X=1:\n    Case 1: becomes empty (3^4=81 possibilities)\n* *\n* 1 0 -> 1\n  *\n    Case 2: can't move (2*3^4=162 possibilities)\n* *\n* 1 {1,2} -> 1\n  *\n  \nIf X=2:\n    Case 1: becomes empty (2*3^3=54 possibilities)\n{0,2} 0\n  *   2 * -> 0\n      *\n    Case 2: can't move (2*3^4=162 possibilities)\n* {1,2}\n*   2   * -> 2\n    *\n    Case 3: also can't move (3^3=27 possibilities)\n1 0\n* 2 * -> 2\n  *\n \nWe have 3^6=108+81+54+81+162+54+162+27=729 cases, so \nwe know we've dealt with them all.\n*/\nfloat evolutionRule(int A, int B, int C, int D, int X, int E) {\n    float Y=0.0;\n    switch(X) {\n    case 0: //empty cell, might be filled if B or D are nonzero.\n        if(B==1) //right-mover moves in\n            Y=0.5;\n        else if(D==2) //no right-mover, up-mover moves in\n            Y=1.0;\n        //else we just leave Y zero.\n        break;\n    case 1: //right-mover. Mover either moves or stays put.\n        if(C!=0) //no space, mover stays put.\n            Y=0.5;\n        break;\n    case 2: //empty cell, might be filled if B or D are nonzero.\n        if(A!=0 || E==1) //no space, mover stays put.\n            Y=1.0;\n        break;\n    }\n    return Y;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n\n\n    float f =evolutionRule(Cell(px+ivec2(0, 1)),Cell(px+ivec2(-1, 0)),\n        Cell(px+ivec2(1, 0)),Cell(px+ivec2(0, -1)),Cell(px),Cell(px+ivec2(-1, 1)));\n    \n    if( iFrame==0 ) \n        f =((1.0/3.0)+(2.0/3.0)*hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1)))*step(1.0-fillingfraction,hash1(fragCoord.x*32.5+hash1(fragCoord.y*135.1)));\n    \n\tfragColor = vec4( f, 0.0, 0.0, 0.0 );\n}","name":"Buffer A","description":"","type":"buffer"}]}