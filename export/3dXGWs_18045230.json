{"ver":"0.1","info":{"id":"3dXGWs","date":"1547757709","viewed":724,"name":"Bilinear Patch Intersection","username":"fizzer","description":"Analytic bilinear surface ray intersection. Also shows how such a surface is contained within a tetrahedron defined by the same 4 points as the surface itself. Six patches are arranged to make a deformed cube.","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["intersection","surface","analytic","patch","blinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Analytic bilinear surface ray intersection. Also shows how such a surface is contained\n// within a tetrahedron defined by the same 4 points as the surface itself.\n//\n// This can be useful for when rasterising the bounding surface as a pre-step when mixing\n// raytracing with rasterisation.\n//\n// This example also shows the use of ray differentials, using surface differentials\n// obtained directly from the intersection point which are then used to transform the ray\n// differentials in to texture space.\n//\n\n#define SHOW_BOUNDING_POLYTOPE\t0\n#define SHOW_BOUNDING_WIREFRAME\t0\n\n\n// Deformed cube geometry\nvec3 vertices[8];\nint indices[6 * 4];\n\n// Ray intersection test with bilinear surface defined by 4 points\nbool traceBilinearPatch(vec3 ro, vec3 rd, vec3 pa, vec3 pb, vec3 pc, vec3 pd,\n                        inout vec3 outs, inout vec3 outt, inout vec3 outuvi)\n{\n    vec3 va = pc - pa;\n    vec3 vb = (pd - pc) - (pb - pa);\n    vec3 vd = ro - pa;\n    vec3 vc = pa - pb;\n\n    // Note that the coefficients are in reverse order here. Solving this\n    // equation gives 1 / x and avoids a divide-by-zero case for coplanar controlpoints\n    // by switching that case to c = 0 instead of a = 0, thus putting the denominator\n    // in the solution as -b instead of 0.\n    // Thanks to IQ for this trick!\n    \n    float c = dot(cross(vb, vc), rd);\n    float b = dot(cross(va, vc) + cross(vb, vd), rd);\n    float a = dot(cross(va, vd), rd);\n\n    float desc = b * b - 4. * a * c;\n\n    if(desc < 0.0)\n        return false;\n\n    // Put PA at the origin of the coordinate system\n\n    ro -=pa;\n\n    pc = va;\n\n    pd -= pa;\n    pb -= pa;\n    pa -= pa;\n\n    float i;\n    float u, v;\n\n    // Solve for U at each intersection point, which are two quadratics\n\n    float u0 = (2. * a) / (-b - sqrt(desc));\n    float u1 = (2. * a) / (-b + sqrt(desc));\n\n    vec3 pu0 = pb * u0;\n    vec3 pu1 = pb * u1;\n\n    // Solve for V at each intersection point, geometrically\n\n    vec3 vv0 = mix(pc, pd, u0) - pu0;\n    vec3 m20 = ro - pu0 - vv0 * dot(vv0, ro - pu0) / dot(vv0, vv0);\n\n    vec3 vv1 = mix(pc, pd, u1) - pu1;\n    vec3 m21 = ro - pu1 - vv1 * dot(vv1, ro - pu1) / dot(vv1, vv1);\n\n\n    float v0, v1;\n\n    {\n        vec3 n = cross(va + vb * u0, vd + vc * u0);\n        vec3 m = cross(n, rd);\n\n        float da = dot(pu0 - ro, m);\n        float db = dot(pc + (pd - pc) * u0 - ro, m);\n\n        v0 = da / (da - db);\n    }\n\n    {\n        vec3 n = cross(va + vb * u1, vd + vc * u1);\n        vec3 m = cross(n, rd);\n\n        float da = dot(pu1 - ro, m);\n        float db = dot(pc + (pd - pc) * u1 - ro, m);\n\n        v1 = da / (da - db);\n    }\n\n    // Solve for the ray intersection distance at each intersection point\n\n    float da20 = dot(ro - pu0, m20);\n    float db20 = dot((ro + rd) - pu0, m20);\n    float i0 = da20 / (da20 - db20);\n\n    float da21 = dot(ro - pu1, m21);\n    float db21 = dot((ro + rd) - pu1, m21);\n    float i1 = da21 / (da21 - db21);\n\n    // Resolve which valid intersection point is nearest to ray origin\n\n    if(u0 < 0. || u0 > 1. || i0 < 0. || v0 < 0. || v0 > 1.)\n    {\n        u = u1;\n        v = v1;\n        i = i1;\n    }\n    else if(u1 < 0. || u1 > 1. || i1 < 0. || v1 < 0. || v1 > 1.)\n    {\n        u = u0;\n        v = v0;\n        i = i0;\n    }\n    else\n    {\n        u = mix(u0, u1, step(i1, i0));\n        v = mix(v0, v1, step(i1, i0));\n        i = min(i0, i1);\n    }\n\n    if(u < 0. || u > 1. || i < 0. || v < 0. || v > 1.)\n        return false;\n\n    outuvi = vec3(u, v, i);\n\n    // Surface differentials in worldspace\n    outs = pb * u - mix(pc, pd, u);\n    outt = pc * v - mix(pb, pd, v);\n\n    return true;\n}\n\n// Ray intersection test with tetrahedron\nvec2 traceTetrahedron(vec3 ro, vec3 rd, vec3 pa, vec3 pb, vec3 pc, vec3 pd, inout vec3 outn)\n{\n    vec3 tn0 = cross(pb - pa, pc - pa);\n    vec3 tn1 = cross(pb - pc, pd - pc);\n    vec3 tn2 = cross(pd - pa, pb - pa);\n    vec3 tn3 = cross(pc - pa, pd - pa);\n\n    if(dot(pd - pc, tn0) > 0.0)\n    {\n        tn0 = -tn0;\n        tn1 = -tn1;\n        tn2 = -tn2;\n        tn3 = -tn3;\n    }\n\n    float td0 = dot(rd, tn0);\n    float td1 = dot(rd, tn1);\n    float td2 = dot(rd, tn2);\n    float td3 = dot(rd, tn3);\n\n    float tt0 = dot(pa - ro, tn0) / td0;\n    float tt1 = dot(pc - ro, tn1) / td1;\n    float tt2 = dot(pa - ro, tn2) / td2;\n    float tt3 = dot(pa - ro, tn3) / td3;\n\n    float tmin = -1e4, tmax = +1e4;\n\n    if(td0 > 0.0)\n    {\n        tmax = min(tmax, tt0);\n    }\n    else\n    {\n        if(tt0 > tmin)\n        {\n            tmin = tt0;\n            outn = tn0;\n        }\n    }\n\n    if(td1 > 0.0)\n    {\n        tmax = min(tmax, tt1);\n    }\n    else\n    {\n        if(tt1 > tmin)\n        {\n            tmin = tt1;\n            outn = tn1;\n        }\n    }\n\n    if(td2 > 0.0)\n    {\n        tmax = min(tmax, tt2);\n    }\n    else\n    {\n        if(tt2 > tmin)\n        {\n            tmin = tt2;\n            outn = tn2;\n        }\n    }\n\n    if(td3 > 0.0)\n    {\n        tmax = min(tmax, tt3);\n    }\n    else\n    {\n        if(tt3 > tmin)\n        {\n            tmin = tt3;\n            outn = tn3;\n        }\n    }\n\n    return vec2(tmin, tmax);\n}\n\n// Ray intersection test with deformed cube composed of six bilinear patches\nbool traceDeformedCube(vec3 ro, vec3 rd, inout vec3 outs, inout vec3 outt, inout vec3 outuvi)\n{\n    vec3 closest_uvi = vec3(1e4), closest_s = vec3(0), closest_t = vec3(0);\n\n    vec3 uvi, norm, s, t;\n\n    // Intersection test against sides of deformed cube\n\n    for(int i = 0; i < 6; ++i)\n    {\n        vec3 pa = vertices[indices[i * 4 + 0]];\n        vec3 pb = vertices[indices[i * 4 + 1]];\n        vec3 pc = vertices[indices[i * 4 + 2]];\n        vec3 pd = vertices[indices[i * 4 + 3]];\n\n        if(traceBilinearPatch(ro, rd, pa, pb, pc, pd, s, t, uvi))\n        {\n            if(uvi.z > 0.0 && uvi.z < closest_uvi.z)\n            {\n                closest_uvi = uvi;\n                closest_s = s;\n                closest_t = t;\n            }\n        }\n    }\n\n    float u = closest_uvi.x;\n    float v = closest_uvi.y;\n    float i = closest_uvi.z;\n\n    if(u < 0. || u > 1. || i < 0. || v < 0. || v > 1.)\n        return false;\n\n    outs = closest_s;\n    outt = closest_t;\n    outuvi = closest_uvi;\n\n    return true;\n}\n\nvec3 closestPointsOnLines(vec3 p0, vec3 v0, vec3 p1, vec3 v1)\n{\n    return inverse(mat3(v0, -v1, cross(v1, v0))) * (p1 - p0);\n}\n\nfloat lineMask(vec3 ro, vec3 rd, vec3 pa, vec3 pb, float r, float maxt)\n{\n    vec3 t = closestPointsOnLines(ro, rd, pa, pb - pa);\n\n    vec3 lp = mix(pa, pb, clamp(t.y, 0., 1.));\n\n    return step(distance(ro + rd * t.x, lp), r) * step(t.x, maxt);\n}\n\nfloat tetrahedronWireframeMask(vec3 ro, vec3 rd, vec3 pa, vec3 pb, vec3 pc, vec3 pd, float r, float maxt)\n{\n    float mask = 0.;\n\n    mask = max(mask, lineMask(ro, rd, pa, pb, r, maxt));\n    mask = max(mask, lineMask(ro, rd, pb, pd, r, maxt));\n    mask = max(mask, lineMask(ro, rd, pd, pc, r, maxt));\n    mask = max(mask, lineMask(ro, rd, pc, pa, r, maxt));\n    mask = max(mask, lineMask(ro, rd, pa, pd, r, maxt));\n    mask = max(mask, lineMask(ro, rd, pc, pb, r, maxt));\n\n    return mask;\n}\n\nfloat deformedCubeWireframeMask(vec3 ro, vec3 rd, float r, float maxt)\n{\n    float mask = 0.;\n\n    for(int i = 0; i < 6; ++i)\n    {\n        vec3 pa = vertices[indices[i * 4 + 0]];\n        vec3 pb = vertices[indices[i * 4 + 1]];\n        vec3 pc = vertices[indices[i * 4 + 2]];\n        vec3 pd = vertices[indices[i * 4 + 3]];\n\n        mask = max(mask, tetrahedronWireframeMask(ro, rd, pa, pb, pc, pd, r, maxt));\n    }\n\n    return mask;\n}\n\nfloat traceDeformedCubeBounds(vec3 ro, vec3 rd, inout vec3 outn)\n{\n    vec3 closest_uvi = vec3(1e4), closest_s = vec3(0), closest_t = vec3(0);\n\n    float min_i = 1e4;\n\n    // Intersection test against tetrahedral bounds of sides of deformed cube\n\n    for(int i = 0; i < 6; ++i)\n    {\n        vec3 pa = vertices[indices[i * 4 + 0]];\n        vec3 pb = vertices[indices[i * 4 + 1]];\n        vec3 pc = vertices[indices[i * 4 + 2]];\n        vec3 pd = vertices[indices[i * 4 + 3]];\n\n        vec3 n;\n\n        vec2 is = traceTetrahedron(ro, rd, pa, pb, pc, pd, n);\n\n        if(is.x < is.y && is.x < min_i)\n        {\n            min_i = is.x;\n            outn = n;\n        }\n    }\n\n    return min_i;\n}\n\n// Box-filtered grid, from https://iquilezles.org/articles/filterableprocedurals\nfloat grid( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    const float N = 10.0; // grid ratio\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return (1.0-i.x)*(1.0-i.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0., -.1, 4.);\n\n    // Set up primary ray including differentials\n\n    vec3 rd = normalize(vec3(uv.xy, -1.6));\n    vec3 rdx = rd + dFdx(rd);\n    vec3 rdy = rd - dFdy(rd);\n\n    // Base vertices and indices of cube\n\n    vertices[0] = vec3(-1, -1, -1);\n    vertices[1] = vec3(-1, -1, +1);\n    vertices[2] = vec3(-1, +1, -1);\n    vertices[3] = vec3(-1, +1, +1);\n    vertices[4] = vec3(+1, -1, -1);\n    vertices[5] = vec3(+1, -1, +1);\n    vertices[6] = vec3(+1, +1, -1);\n    vertices[7] = vec3(+1, +1, +1);\n\n    indices[0 * 4 + 0] = 0;\n    indices[0 * 4 + 1] = 1;\n    indices[0 * 4 + 2] = 2;\n    indices[0 * 4 + 3] = 3;\n\n    indices[1 * 4 + 0] = 7;\n    indices[1 * 4 + 1] = 6;\n    indices[1 * 4 + 2] = 5;\n    indices[1 * 4 + 3] = 4;\n\n    indices[2 * 4 + 0] = 0;\n    indices[2 * 4 + 1] = 1;\n    indices[2 * 4 + 2] = 4;\n    indices[2 * 4 + 3] = 5;\n\n    indices[3 * 4 + 0] = 2;\n    indices[3 * 4 + 1] = 3;\n    indices[3 * 4 + 2] = 6;\n    indices[3 * 4 + 3] = 7;\n\n    indices[4 * 4 + 0] = 0;\n    indices[4 * 4 + 1] = 2;\n    indices[4 * 4 + 2] = 4;\n    indices[4 * 4 + 3] = 6;\n\n    indices[5 * 4 + 0] = 1;\n    indices[5 * 4 + 1] = 3;\n    indices[5 * 4 + 2] = 5;\n    indices[5 * 4 + 3] = 7;\n\n    // Vertex deformation, twisting etc.\n\n    for(int i = 0; i < 8; ++i)\n    {\n        vec3 p = vertices[i];\n\n        float an = cos(time + p.y) / 2.;\n        p.xz = mat2(cos(an), sin(an), sin(an), -cos(an)) * p.xz;\n\n        an = cos(time*2.+p.x+2.);\n        p.yz = mat2(cos(an),sin(an),sin(an),-cos(an)) * p.yz;\n\n        an = time + 5.;\n        p.xz = mat2(cos(an), sin(an), sin(an), -cos(an)) * p.xz;\n\n        an = time / 3.;\n        p.yz = mat2(cos(an), sin(an), sin(an), -cos(an)) * p.yz;\n\n        vertices[i] = p;\n    }\n\n    // The convex bounds are traced here as a small speedup\n    vec3 boundsn;\n    float bounds_i = traceDeformedCubeBounds(ro, rd, boundsn);\n\n    bool hit = false;\n    vec3 closest_uvi = vec3(1e4), closest_s = vec3(0), closest_t = vec3(0);\n\n    if(bounds_i > 0. && bounds_i < 1e3)\n    {   \n        hit = traceDeformedCube(ro, rd, closest_s, closest_t, closest_uvi);\n    }\n\n    int textureID = 0;\n    float shadow = 1.;\n\n    // Light direction\n    vec3 l = normalize(vec3(6, 7, 0));\n\n    // Intersection with floor\n    float floor_i = (-2. - ro.y) / rd.y;\n\n    if(floor_i > 0.0 && floor_i < closest_uvi.z)\n    {\n        // Ray hit the floor\n        vec3 rp = ro + rd * floor_i;\n\n        closest_s = vec3(1, 0, 0) * .2;\n        closest_t = vec3(0, 0, 1) * .2;\n\n        closest_uvi.x = dot(rp, closest_s);\n        closest_uvi.y = dot(rp, closest_t);\n        closest_uvi.z = floor_i;\n\n        // vec3 dummy_s, dummy_t, dummy_uvi;\n        //if(traceDeformedCube(rp, l, dummy_s, dummy_t, dummy_uvi))\n        //{\n        //   shadow = .5;\n        //}\n\n        textureID = 1;\n    }\n    else if(hit && (closest_uvi.z < floor_i || floor_i < 0.0))\n    {\n        textureID = 2;\n    }\n\n    if(textureID == 0)\n    {\n        // Background\n        fragColor.rgb = vec3(.1);\n    }\n    else\n    {\n        float u = closest_uvi.x;\n        float v = closest_uvi.y;\n        float i = closest_uvi.z;\n\n        vec3 closest_norm = normalize(cross(closest_s, closest_t));\n\n        // Ensure that the normal is forward-facing\n\n        if(dot(rd, closest_norm) > 0.)\n            closest_norm = -closest_norm;\n\n        // Use ray differentials to get intersection points for neighbouring pixels\n        // and transform them in to texture space for texture sampling.\n\n        vec3 rp = ro + rd * i;\n        vec3 rpx = ro + rdx * dot(rp - ro, closest_norm) / dot(rdx, closest_norm);\n        vec3 rpy = ro + rdy * dot(rp - ro, closest_norm) / dot(rdy, closest_norm);\n\n        vec2 duvx = vec2(dot(rpx - rp, closest_s), dot(rpx - rp, closest_t));\n        vec2 duvy = vec2(dot(rpy - rp, closest_s), dot(rpy - rp, closest_t));\n\n        // Texturing\n\n        vec3 c;\n\n        if(textureID == 1)\n        {\n            c = textureGrad(iChannel2, vec2(u, v), duvx / 2., duvy / 2.).rgb;\n            c *= mix(.5, 1., smoothstep(0., 2., length(rp.xz)));\n        }\n        else if(textureID == 2)\n        {\n            c = textureGrad(iChannel0, vec2(u, v), duvx / 2., duvy / 2.).rgb;\n            c *= mix(.5, 1., smoothstep(0., .1, 1. - 2. * max(abs(u - .5), abs(v - .5))));\n            float gridscale = 8.0;\n            vec3 gridc = vec3(grid(vec2(u, v) * gridscale + .05, duvx / 2. * gridscale, duvy / 2. * gridscale));\n            c = mix(gridc, c, smoothstep(.2, .26, fract(time / 5. - .7)) - smoothstep(.7, .76, fract(time / 5. - .7)));\n        }\n\n        // Shading\n\n        vec3 r = reflect(rd, closest_norm);\n        float fres = mix(.01, .8, pow(clamp(1. - dot(-rd, closest_norm), 0., 1.), 2.));\n\n        vec3 spec = texture(iChannel1, r).rgb * .5;\n\n        spec += pow(max(0., dot(closest_norm, normalize(l + normalize(-rd)))), 64.);\n\n        vec3 diff = c * max(0., .5 + .5 * dot(l, closest_norm));\n\n        fragColor.rgb = mix(diff, spec, fres) * shadow;\n    }\n\n\n    #if SHOW_BOUNDING_POLYTOPE\n    if(bounds_i > 0. && bounds_i < 1e3)\n    {\n        boundsn = normalize(boundsn);\n        vec3 bounds_col = vec3(.5 + .5 * dot(boundsn, l));\n        fragColor.rgb = mix(fragColor.rgb, bounds_col, .5);\n    }\n    #endif\n\n    #if SHOW_BOUNDING_WIREFRAME\n    float wireframe_mask = deformedCubeWireframeMask(ro, rd, 0.01, closest_uvi.z);\n    fragColor.rgb = mix(fragColor.rgb, vec3(1), wireframe_mask * .5);\n    #endif\n\n    // Gamma correction\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"}]}