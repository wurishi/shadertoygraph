{"ver":"0.1","info":{"id":"lt3cWX","date":"1534414877","viewed":330,"name":"Refractal","username":"belfry","description":"Testing refraction on a fractal.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fractal","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 e = vec3(1. / iResolution.xy, 0.);\n    vec3 c = texture(iChannel0, uv).rgb;\n\tvec3 u = texture(iChannel0, uv + e.zy).rgb;\n    vec3 d = texture(iChannel0, uv - e.zy).rgb;\n    vec3 l = texture(iChannel0, uv - e.xz).rgb;\n    vec3 r = texture(iChannel0, uv + e.xz).rgb;\n    fragColor = vec4((c+u+d+l+r) / 4., 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// taken from: https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdf(vec3 p) {\n    p -= vec3(0., 0., 2.);\n    for (float i = 1.; i < 6.; i++) {\n        p = abs(p);\n        p -= vec3(.8);\n        float a = 4.3;\n        vec2 c = vec2(cos(a), sin(a));\n        p.xz = mat2(c, -c.y, c.x) * p.xz;\n        a = 4.2;\n        p = abs(p);\n        c = vec2(cos(a), sin(a));\n        p.xy = mat2(c, -c.y, c.x) * p.xy;\n        c = p.yz;\n        p.yz = mat2(c, -c.y, c.x) * p.yz;\n    }\n    return -sphere(p, 1.);\n}\n\nvec3 gradient(vec3 p) {\n    vec2 eps = vec2(0.005, 0.);\n    float dx = sdf(p + eps.xyy) - sdf(p - eps.xyy);\n    float dy = sdf(p + eps.yxy) - sdf(p - eps.yxy);\n    float dz = sdf(p + eps.yyx) - sdf(p - eps.yyx);\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool trace(vec3 pos, vec3 dir, float minT, float maxT, bool inner, \n           float iter, float eps, float stepSize, \n          out float i, out float t, out vec3 p, out float dist) \n{\n    i = 0.;\n    t = minT;\n    bool hit = false;\n    \n    for (; i < iter; i++) {\n        p = t * dir + pos;\n        dist = sdf(p);\n        if (abs(dist) < eps * t) {\n            hit = true;\n            break;\n        }\n        t += (inner ? -dist : dist) * stepSize;\n        if (t > maxT)\n            break;\n    }\n    return hit;\n}\n\nbool refraction(vec3 pos, vec3 dir, float refractCooefficient, float stepSize, \n                out vec3 hitPos, out vec3 hitDir, out float hitObj,\n               out float i, out float t) \n{\n    const float noiseAmount = 0.1;\n    vec3 normal = gradient(pos);\n    float a = abs(dot(normal, -dir));\n    float s = 3000.;\n    //a = 1.;\n    normal += (hash33(floor(pos * s) / s) - 0.5) * noiseAmount * a * a;\n    normal = normalize(normal);\n    float obj;\n    vec3 p;\n    vec3 nextInnerDir = refract(dir, normal, refractCooefficient);\n    if (dot(nextInnerDir, nextInnerDir) != 0.) {\t// not sure if this is necessary\n        for (int j = 0; j < 1; j++) {\t// handle total internal reflection - or maybe rather not, using 1 iteration.\n            // I. first we move through the object (hence inner set to true)...\n            dir = nextInnerDir;\n            trace(pos, dir, .5, 100., true, 800., 0.001, stepSize, i, t, p, obj);\n            normal = gradient(p);\n            a = abs(dot(normal, -dir));\n            //a = 1.;\n            normal += (hash33(floor(p * s) / s) - 0.5) * noiseAmount * a * a;\n            normal = normalize(normal);\n            hitDir = refract(dir, -normal, 1./refractCooefficient);\t// note the flipped normal\n            // II. ...and then we continue tracing outside of it\n            if (dot(hitDir, hitDir) != 0.){\t// check if we don't have an total internal reflection\n                return trace(p, hitDir, 0.2, 100., false, 800., 0.005, stepSize, i, t, hitPos, hitObj);\n            }\n            // in case of a total internal reflection, prepare next trace\n            pos = p;\n            nextInnerDir = reflect(dir, -normal);\t// note the flipped normal\n        }\n    } else {\t// a total internal reflection... on the outside??\n        dir = reflect(dir, normal);\n    }\n    // III. if we ended up with nothing but total internal reflections, \n    // then just move along dir\n    hitDir = dir;\n    return trace(p, hitDir, .2, 100., false, 800., 0.005, stepSize, i, t, hitPos, hitObj);\n    \n}\n\nfloat ambientOcclusion(vec3 p, vec3 normal, float steps, float dist) {\n    float ao = 0.;\n    for (float i = 1.; i <= steps; i++) {\n        float t = i / steps * dist;\n        ao += sdf(p + normal * t) / t;\n    }\n    return clamp(ao / steps, 0., 1.);\n}\n\nfloat translucency(vec3 p, vec3 normal, float steps, float dist) {\n    float ao = 0.;\n    for (float i = 1.; i <= steps; i++) {\n        float t = i / steps * dist;\n        ao += -sdf(p - normal * t) / t;\n    }\n    return smoothstep(0., 1., 1. - ao / steps);\n}\n\nvec3 draw(vec3 p, float i, float t, vec3 normal, vec3 dir) {\n\tvec3 col = vec3(1. - t/9., 0., t/6.) * i / 800.;\n\tfloat ao = ambientOcclusion(p, normal, 3., 1.);\n    float trans = translucency(p, normal, 5., .5);\n    vec3 lightDir = normalize(vec3(1.));\n    float diffuse = max(0., dot(normal, lightDir));\n    float backDiffuse = max(dot(-normal, lightDir), 0.) * trans;\n    float specular = pow(max(dot(-normal, normalize(lightDir + dir)), 0.), 8.);\n    float rim = pow(dot(dir, normal), 5.) * 0.3;\n    col *= vec3(ao * .15 + .55 + diffuse * .6 + backDiffuse * .5 + specular * .8 + rim);\n    col = clamp(col, 0., 1.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 dir = normalize(vec3(uv, 1. / tan(radians(60.) * .5)));\n    vec3 camPos = vec3(0.5, -1., 1.5) - sin(iTime * .1) * .5;\n    \n    float a = iTime * .05;\n    vec2 c = vec2(cos(a), sin(a));\n    dir.xz = mat2(c, -c.y, c.x) * dir.xz;\n    \n    vec3 p;\n    float i, t, dist;\n    trace(camPos, dir, .0, 100., false, 400., 0.005, 1./40., i, t, p, dist);\n    vec3 normal = gradient(p);    \n    vec3 col = draw(p, i, t, normal, dir);\n    \n    vec3 noisyNormal = normalize(normal + (hash33(p) - 0.5 ) *  0.01);\n    vec3 reflectedDir = reflect(dir, noisyNormal);\n    float j, k; vec3 q;\n    trace(p, reflectedDir, .1, 100., false, 400., 0.003, 1./40., j, k, q, dist);\n    col = mix(col * 3., draw(q, j, k, noisyNormal, reflectedDir), .3);\n    \n    float r = smoothstep(0., 1., smoothstep(0.8, .2, sqrt(t) / 2.5));\n    if (r > .01) {\n        bool hit = refraction(p, dir, 1./1.31, 1./40., p, dir, dist, i, t);\n        vec3 normal = gradient(p);\n        if (hit)\n        \tcol = mix(col, 5. * (draw(p, i, t, normal, dir)), r);\n    }\n    \n    uv = pow(abs(2. * fragCoord / iResolution.xy - 1.), vec2(5.));\n    col *= 1. - vec3(pow(uv.x + uv.y, 1./5.)) * .8; \n    col = sqrt(col);\n    col = col.gbr;\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}