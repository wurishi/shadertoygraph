{"ver":"0.1","info":{"id":"Xd3SR8","date":"1458101692","viewed":1777,"name":"Quad Mapping Tool","username":"vamoss","description":"Mapping Tool","likes":37,"published":1,"flags":32,"usePreview":0,"tags":["square","rectangle","mapping","quad","rect","cropping","warper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//adapted from this opengl method:\n//http://stackoverflow.com/questions/16989181/whats-the-correct-way-to-draw-a-distorted-plane-in-opengl\n\n//store the buffer drags values\nvec2 _Values[4];\n\n\n//drags from buffer\n//buffer variables\nconst int maxCount = 4;\nconst float radius = 10.0;\nconst float border = 1.5;\n\nconst float statePos = float(maxCount);\n#define BufA(x) texture(iChannel0, (vec2(x, 0.0) + 0.5) / iResolution.xy)\n\n// From: Iq\n// https://www.shadertoy.com/view/lsBSDm\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    if ( k2==0.0 ) k2 = 0.001; \n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n    if( w<0.0 ) return vec2(-1.0);\n\n    w = sqrt( w );\n    \n    float v1 = (-k1 - w)/(2.0*k2);\n    float v2 = (-k1 + w)/(2.0*k2);\n    float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);\n    float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);\n    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;\n    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;\n    \n    vec2 res = vec2(-1.0);\n\n    if(  b1 && !b2 ) res = vec2( u1, v1 );\n    if( !b1 &&  b2 ) res = vec2( u2, v2 );\n    \n    return res;\n}\n\n\nfloat line(vec2 uv, vec2 origin, vec2 destiny, float radius){\n    destiny -= origin;\n\tfloat color = length( clamp( dot(uv-origin,destiny)/dot(destiny,destiny), 0.,1.) *destiny - uv+origin );\n    return smoothstep(color-0.0005,color+0.0005, radius);    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //read drag buffer\n    vec4 state = BufA(statePos);\n    float curr = 0.0;\n    float dist = radius + 1.0;\n    for (int i = 0; i < maxCount; ++i) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        float d = distance(fragCoord, center);\n        if (d < dist) {\n            dist = d;\n            curr = f;\n        }\n    }\n    for (int i = 0; i < maxCount; i++) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        \n        //store drag values\n        _Values[i] = center/iResolution.xy;\n    }\n    \n    //distort\n    vec3 color = vec3(0.0);//background\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texUv = invBilinear( uv, _Values[0], _Values[1], _Values[2], _Values[3] );\n    if( texUv.x>-0.5 )\n    {\n        color = texture( iChannel1, texUv ).xyz;\n    }\n    \n    //line border\n   \t//*\n    color = mix(color, vec3(0.0, 1.0, 1.0), line(uv, _Values[0], _Values[1], .005));\n    color = mix(color, vec3(1.0, 0.0, 1.0), line(uv, _Values[1], _Values[2], .005));\n    color = mix(color, vec3(1.0, 1.0, 0.0), line(uv, _Values[2], _Values[3], .005));\n    color = mix(color, vec3(0.0, 0.0, 1.0), line(uv, _Values[3],  _Values[0], .005));\n\t/**/\n    \n    //drags\n    //*\n    if (dist < radius) {\n        if (dist > radius - border) {\n            //border\n            color = vec3(0.0, 0.0, 0.0);\n        } else {\n            if (curr == state.x)\n                if (state.z > 0.0)\n                    //mouse pressed\n                    color = vec3(0.0, 1.0, 0.0);\n                else\n                    //last pressed\n                    color = vec3(0.5, 1.0, 1.0);\n            else\n                //standby\n                color = vec3(1.0, 1.0, 1.0);\n        }\n    }\n    /**/\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Drag and drop framework\n// https://www.shadertoy.com/view/4dtSRn\n// by mhnewman\n//\n// maxCount := the maximum number of objects that can be represented.\n//\n// Buffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n//  * .x := the object's x coordinate.\n//  * .y := the object's y coordinate.\n//\n// Buffer pixel (maxCount, 0) := the current state.\n//  * .x := the index of the currently selected object.\n//  * .y := the number of active objects.\n//  * .z := the mouse state.\n//\n// Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\nconst int maxCount = 4;\nconst float radius = 10.0;\n\nconst float statePos = float(maxCount);\nconst float offsetPos = float(maxCount + 1);\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5;\n    \n    if (p.y > 0.0 || p.x > offsetPos) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        float count = 0.0;\n\n        //\n        // Initial conditions\n        //\n        \n        addObject(0.2 * iResolution.x, 0.2 * iResolution.y);\n        addObject(0.8 * iResolution.x, 0.2 * iResolution.y);\n        addObject(0.8 * iResolution.x, 0.8 * iResolution.y);\n        addObject(0.2 * iResolution.x, 0.8 * iResolution.y);\n        \n        if (p.x == statePos)\n            fragColor = vec4(2.0 * statePos, count, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 state = texture(iChannel0, vec2(0.5 + statePos, 0.5) / iResolution.xy);\n    vec4 offset = texture(iChannel0, vec2(0.5 + offsetPos, 0.5) / iResolution.xy);\n\n    if (state.z <= 0.0 && iMouse.z > 0.0) {\n        float r = radius + 1.0;\n        for (int i = 0; i < maxCount; ++i) {\n            float f = float(i);\n            if (f >= state.y)\n                break;\n            vec4 center = texture(iChannel0, vec2(0.5 + f, 0.5) / iResolution.xy);\n            float d = distance(iMouse.xy, center.xy);\n            if (d < r) {\n                r = d;\n                state.x = f;\n                offset = center - iMouse;\n            }\n        }\n        if (r > radius) {\n            if (state.y >= statePos) {\n            \tstate.x = 2.0 * statePos;\n            } else {\n    \t        state.x = state.y;\n        \t    state.y += 1.0;\n        \t}\n        }\n    }\n    state.z = iMouse.z;\n    \n    if (p.x == statePos) {\n        fragColor = state;\n        return;\n    }\n    \n    if (p.x == offsetPos) {\n        fragColor = offset;\n        return;\n    }\n\n    if (p.x == state.x && state.z > 0.0) {\n        fragColor = iMouse + offset;\n        return;\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buf A","description":"","type":"buffer"}]}