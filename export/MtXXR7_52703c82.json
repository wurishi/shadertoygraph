{"ver":"0.1","info":{"id":"MtXXR7","date":"1435246508","viewed":951,"name":"Fish eye procedural texture","username":"Ultraviolet","description":"You can move the camra around by clicking .","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","fisheye","proceduraltexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.1415972\n\nconst float dMin = 0.0;\nconst float dMax = 100.0;\nconst float stp = .05;\n\nconst float AA = 5.0;\n\n\n//vec3 lightDir = normalize(vec3(0, -1, -0.3));\nvec3 lightDir = normalize(vec3(0, 0, -1));\n\nvec3 sunColor = vec3(1.0, 1.0, 1.0);\nvec3 airColor = vec3(0.5, 0.8, 1.0);\nvec3 horizonColor = vec3(1.0, 1.0, 0.8);\n\n\nfloat terrainHeight(vec2 pos)\n{\n\n    float height = 0.0;\n    \n    return height;\n}\n\nvec3 terrainNormal(vec2 pos)\n{    \n    return vec3(0,0,1);\n}\n\nfloat checkerTexture(in vec2 pos)\n{\n    float ind = 1.0;\n    \n    if(mod(pos.x, 1.0) > 0.5)\n        ind *= -1.0;\n    \n    if(mod(pos.y, 1.0) > 0.5)\n        ind *= -1.0;\n    \n    ind = max(ind, 0.0);\n    \n    return ind;\n}\n\nfloat triTexture(in vec2 pos)\n{\n    vec2 pos2 = pos;\n    pos2.x = pos.x  - pos.y * 0.5;\n    pos2.y = pos.y / sqrt(3.0) / 0.5;\n    \n    float ind = 1.0;\n    \n    if(mod(pos2.x, 1.0) > 0.5)\n        ind *= -1.0;\n    \n    if(mod(pos2.y, 1.0) > 0.5)\n        ind *= -1.0;\n    \n    if(mod(pos2.y, 1.0) > 1.0 - mod(pos2.x, 1.0))\n        ind *= -1.0;\n    \n    ind = max(ind, 0.0);\n    \n    return ind;\n}\n\nfloat digitTexture(in vec2 pos)\n{\n    return texture(iChannel1, pos).x;\n}\n\n\nfloat perlinTexture(in vec2 pos)\n{\n    const float N = 5.0;\n    \n    vec2 pos2 = pos;\n    \n    float ind = 0.0;\n    float ampl = 1.0;\n    \n    for(float n = 0.0; n < N; n ++)\n    {\n    \tind += texture(iChannel0, pos / iChannelResolution[0].x).x * ampl;\n    \n        ampl *= 0.5;\n        pos *= 2.0;\n    }\n    \n    return ind / (1.0 - pow(0.5, N+1.0)) * 0.5;\n}\n\nvec3 terrainColor(in vec3 ro, in vec3 rd, in float dist)\n{\n    float k = -ro.z / rd.z;\n    vec3 pos = ro + k * rd;\n    //vec3 color  = vec3(checkerTexture(pos.xy));\n    //vec3 color  = vec3(triTexture(pos.xy));\n    //vec3 color  = vec3(perlinTexture(pos.xy));\n    vec3 color  = vec3(digitTexture(pos.xy*0.1));\n    vec3 normal = terrainNormal(pos.xy);\n    \n    float lightCoeff = abs(dot(normal, -lightDir));\n    lightCoeff = clamp(lightCoeff, 0.0, 1.0);\n    lightCoeff = 0.1 + lightCoeff * 0.9;\n    \n    float angleCoeff = normal.z;\n    //angleCoeff = clamp(angleCoeff, 0.0, 1.0);\n    \n    //return mix(color, vec3(0.5), angleCoeff);\n    \n    return (color* angleCoeff + (1.0-angleCoeff)*vec3(0.5)) * lightCoeff;\n}\n\nvec3 skyColor(in vec3 ro, in vec3 rd)\n{\n    float sunFactor = max(-dot(rd, lightDir), 0.0);\n    float horizonFactor = 1.0 - rd.z;\n        \n    float sun = exp((sunFactor - 1.0) * 100.0);\n    float horizon = exp((horizonFactor - 1.0) * 10.0);\n    \n    return mix(mix(sunColor, airColor, 1.0-sun), horizonColor, horizon);\n}\n\n\nvec3 castRay(in vec3 ro, in vec3 rd)\n{\n    /*\n    float stp_loc = stp;\n    \n    float dd = dMin;\n    \n    for(float d = dMin; d < dMax; d += stp)\n    {\n        vec3 pos = ro + dd * rd;\n        if(pos.z < terrainHeight(pos.xy))\n        {\n            return terrainColor(ro, rd, dd - stp * 0.5);\n        }\n        \n        dd += stp_loc;\n        stp_loc += stp / 10.0;\n    }\n\t*/\n    \n    float t = -ro.z/rd.z;\n    if(t > 0.0)\n        return terrainColor(ro, rd, -t);\n    \n    return skyColor(ro, rd);\n}\n\n\nmat3 idMatrix()\n{\n    return mat3(\n        1.0, 0.0, 0.0, \n        0.0, 1.0, 0.0, \n        0.0, 0.0, 1.0);\n}\n\nmat3 crossProdMatrix(in vec3 v)\n{\n    return mat3(\n         0.0, -v.z,  v.y,\n    \t v.z,  0.0, -v.x,\n    \t-v.y,  v.x,  0.0);\n}\n\nmat3 tensProdMatrix(in vec3 v)\n{\n    return mat3(\n        v.x * v.x, v.y * v.x, v.z * v.x,\n    \tv.x * v.y, v.y * v.y, v.z * v.y,\n    \tv.x * v.z, v.y * v.z, v.z * v.z);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    return idMatrix() * cos(angle) + crossProdMatrix(axis) * sin(angle) + tensProdMatrix(axis) * (1.0 - cos(angle));\n}\n\nmat3 polarTransformation(float longitude, float latitude)\n{\n    vec3 X = vec3(1,0,0);\n    vec3 Y = vec3(0,1,0);\n    vec3 Z = vec3(0,0,1);\n    \n    mat3 m = rotationMatrix(Z, longitude);\n    Y = m * Y;\n    \n    m = rotationMatrix(Y, latitude) * m;\n    X = m * X;\n    Z = m * Z;\n    \n    return mat3(X, Y, Z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(0, 0, 5); // ray origin\n    \n    float longitude = iMouse.x / iResolution.x * 2.0 * PI;//0.0;//\n    float latitude = iMouse.y / iResolution.y * PI - 0.5 * PI;\n    \n    mat3 m = polarTransformation(longitude, latitude);\n    \n    vec3 X = m * vec3(1,0,0);\n    vec3 Y = m * vec3(0,1,0);\n    vec3 Z = m * vec3(0,0,1);\n    \n    //ro = -X * 5.0 + vec3(0,0,5.0);\n    \n    float ratio = iResolution.x / iResolution.y;\n    \n    float focal_length = 0.5;  // equivalent of a 5mm focal length for a 1m wide display\n    float angle = PI;//asin(focal_length);\n    //float angle = PI * 0.4;\n    \n    float alpha_d = (fragCoord.x / iResolution.x - 0.5) * angle;\n    float beta_d  = (fragCoord.y / iResolution.y - 0.5) * angle / ratio;    \n    \n    mat3 m2 = polarTransformation(alpha_d, beta_d);\n    \n\tvec3 color = vec3(0.0);\n    \n    for(float i = 0.0; i < AA; i++)\n    {\n        for(float j = 0.0; j < AA; j++)\n        {\n            float alpha_aa = (i - AA / 2.0) / iResolution.x / AA;\n            float beta_aa  = (j - AA / 2.0) / iResolution.y / AA / ratio;\n\n            mat3 m_aa = polarTransformation(alpha_aa, beta_aa);\n\n\n            vec3 rd = m * m2 * m_aa * vec3(1,0,0);\n\n            color += castRay(ro, rd) / AA / AA;\n        }\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}