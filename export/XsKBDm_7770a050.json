{"ver":"0.1","info":{"id":"XsKBDm","date":"1529109513","viewed":332,"name":"Glass_Lens","username":"PGrad","description":"Glass ball with different indices of refraction for rgb channels.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["reflection","raycasting","refraction","lens","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define EPSILON .0001\n#define SPECULAR_EXPONENT 10.\n#define GLASS_COL vec3(1.)\n#define GLASS_ALPHA .8\n#define GLASS_RADIUS 2.5\n\nvec3 get_highlights(vec3 n, vec3 iXPos, vec3 rd, mat3 view);\nvec4 raycast(vec3 ro, vec3 rd, mat3 view);\n\nfloat iSphere(vec3 ro, vec3 rd) {\n    float r = GLASS_RADIUS;\n    float b = 2. * dot(ro, rd);\n    float c = dot(ro,ro) - pow(r, 2.);\n    \n\tfloat t = (pow(b, 2.) - 4. * c) < 0. ? -1.\n    \t\t\t\t\t                 : ((-b - sqrt(pow(b, 2.) - 4. * c)) / 2.);\n\treturn t;\n}\nvec3 sphereTexMap(vec3 n, sampler2D tex) {\n    float r = sqrt(n.x * n.x + n.z * n.z);\n    float phi = atan(n.y / r);\n    float theta = atan(n.z / n.x);\n    return texture(tex, vec2(theta, phi)).rgb;\n}\nvec3 getRd(vec2 fragCoord, float fov) {\n    vec2 uv = 2. * fragCoord / iResolution.y - 1. - vec2(.7,0);\n    fov = fov * PI / 180.;\n    float focal = 1. / tan(fov / 2.);\n    return normalize(vec3(uv, focal));\n}\nvec3 nSphere(vec3 iXPos, vec4 sph_pos) {\n\treturn normalize(iXPos / sph_pos.w);\n}\nvec3 phong(vec3 n, vec3 l, vec3 eye) {\n    vec3 r = -reflect(l, n);\n    return vec3(pow(max(0., dot(r, eye)), SPECULAR_EXPONENT));\n}\nvec3 env_map(vec3 n, vec3 eye) {\n    vec3 r = -reflect(eye, n);\n    return texture(iChannel0, r).rgb;\n}\nvec4 calc_color(vec3 ro, vec3 rd, float dist, mat3 view, vec3 n, vec3 iXPos) {\n    vec3 col = GLASS_COL;\n    float alpha = GLASS_ALPHA;\n    vec3 highlights = get_highlights(n, iXPos, rd, view);\n    col *= highlights + env_map(n, -rd);\n    return vec4(col, alpha);\n}\nvec4 over(vec4 dest, vec4 src) {\n    return src * src.a + dest * (1. - src.a);\n}\nvec3 blend3(vec3 x) {\n    vec3 y = 1. - x * x; //Bump function\n    y = max(y, vec3(0));\n    return y;\n}\nfloat get_reflect_alpha(vec3 n, vec3 i, vec3 t, float n1, float n2) {\n    float ndoti = clamp(dot(n, -i), 0., 1.);\n    float ndott = clamp(dot(-n, t), 0., 1.);\n    float Rperp = (n1 * ndoti - n2 * ndott) / (n1 * ndoti + n2 * ndott);\n    Rperp *= Rperp;\n    float Rparl = (n2 * ndoti - n1 * ndott) / (n2 * ndoti + n1 * ndott);\n    Rparl *= Rparl;\n    return sin(ndoti) <= (n2 / n1) ? ((Rperp + Rparl) / 2.) : 1.;\n}\nmat3 lookAt(vec3 eye) {\n    vec3 strafe = cross(vec3(0, 1, 0), eye);\n    vec3 up = cross(eye, strafe);\n    mat3 view = mat3(0.);\n    return mat3(normalize(strafe),\n                normalize(up),\n                normalize(eye));\n}\nvec3 get_highlights(vec3 n, vec3 iXPos, vec3 rd, mat3 view) {\n    vec3 toplight = view * vec3(0., 5., 3.);\n    vec3 bottomlight = view * vec3(0., -5., 3.);\n    vec3 topl = normalize(toplight - iXPos);\n    vec3 bottoml = normalize(bottomlight - iXPos);\n    return phong(n, topl, -rd) + phong(n, bottoml, -rd);\n}\nfloat get_highlight_alpha(vec3 n, vec3 iXPos, vec3 rd, mat3 view) {\n    return length(get_highlights(n, iXPos, rd, view));\n}\nvec4 raycast(vec3 ro, vec3 rd, mat3 view) {\n    vec4 cb = vec4(0);\n    vec3 oro = ro;\n    vec3 ord = rd;\n    vec3 glassn = vec3(1.7,1.5, 1.4);\n    for(int rgb_i = 0; rgb_i < 3; ++rgb_i) {\n        ro = oro;\n        rd = ord;\n        float t = iSphere(ro, rd);\n        vec4 color;\n        if(t > -1.) {\n            vec3 n = nSphere(ro + rd * t, vec4(vec3(0), 1.));\n            vec3 oldrd = rd;\n            color = calc_color(ro, rd, t, view, n, ro + rd * t);\n            ro += rd * t;\n            rd = refract(rd, n, 1. / glassn[rgb_i]);\n            color.a = get_reflect_alpha(n, oldrd, rd, 1., glassn[rgb_i]);\n            ro += rd * GLASS_RADIUS * 2.1;\n            ro -= rd * iSphere(ro, -rd);\n            n = -nSphere(ro, vec4(vec3(0), 1));\n            oldrd = rd;\n            rd = refract(rd, n, glassn[rgb_i]);\n            color.a *= get_reflect_alpha(n, oldrd, rd, glassn[rgb_i], 1.);\n            color = over(texture(iChannel0, rd), color);\n            cb[rgb_i] = color[rgb_i];\n            cb.a += color.a;\n        }\n    }\n    if(cb == vec4(0))\n        cb = texture(iChannel0, rd);\n   \treturn cb;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float timestep = iTime * .5;\n    vec3 ro = -10. * vec3(sin(timestep), 0, cos(timestep));\n    mat3 view = lookAt(vec3(0.) - ro);\n    vec3 rd = view * getRd(gl_FragCoord.xy, 35.);\n    vec4 color = raycast(ro, rd, view);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}