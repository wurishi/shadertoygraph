{"ver":"0.1","info":{"id":"XlySRV","date":"1484902707","viewed":249,"name":"Poetic Sunset","username":"ramours","description":"Simple sunset inspired by the work of Baku Hashimoto and Patricio Gonzalez Vivo.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sunset","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nvec3 colorA = vec3(0.39, 0.26, 0.31);\nvec3 colorB = vec3(0.71,0.733,0.82);\nvec3 colorC = vec3(0.19, 0.06, 0.11);\nvec3 colorD = vec3(0.71,0.733,0.82);\nvec3 sunColorA = vec3(0.97,0.,0.);\nvec3 sunColorB = vec3(0.97,0.92,0.3);\n\n// makes a pseudorandom number between 0 and 1\nfloat hash(float n) {\n  return fract(sin(n)*93942.234);\n}\n\nvec4 noise(in vec2 uv)\n{\n\tvec2 r=(456.789*sin(789.123*uv.xy));\n\treturn vec4(fract(r.x*r.y));\n}\n\n// smoothsteps a grid of random numbers at the integers\nfloat noise2(vec2 p) {\n  vec2 w = floor(p);\n  vec2 k = fract(p);\n  k = k*k*(3.-2.*k); // smooth it\n  \n  float n = w.x + w.y*57.;\n  \n  float a = hash(n);\n  float b = hash(n+1.);\n  float c = hash(n+57.);\n  float d = hash(n+58.);\n  \n  return mix(\n    mix(a, b, k.x),\n    mix(c, d, k.x),\n    k.y);\n}\n\n// rotation matrix\nmat2 m = mat2(0.6,0.8,-0.8,0.6);\n\n// fractional brownian motion (i.e. photoshop clouds)\nfloat fbm(vec2 p) {\n  float f = 0.;\n  f += 0.5000*noise2(p); p *= 2.02*m;\n  f += 0.2500*noise2(p); p *= 2.01*m;\n  f += 0.1250*noise2(p); p *= 2.03*m;\n  f += 0.0625*noise2(p);\n  f /= 0.9375;\n  return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime*.2;\n    vec3 color = vec3(0.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 center = vec2(0.5*ratio, (sin(time)+1.)*.4);\n    float dist = distance(uv, center);\n    float initialRadius = .12;\n    \n    // Pick the sky's gradient\n    vec3 t = vec3(cos(uv.y)*cos(uv.y),\n                  sin(uv.y),\n                  sin(uv.y));\n    color = mix(colorA, colorB, t);\n    color = mix(color, colorC, 1.-center.y);\n    \n  \t//color.r *= 1.1;\n    \n    // add \"atmospheric halo\"\"\n    color = mix(color, colorD, smoothstep(uv.y+0.4, uv.y+0.8, center.y));\n    \n    float radius;\n    \n    // add water reflection\n    if (uv.y > .0 && uv.y < .2)\n    {\n        radius = initialRadius+0.02+fbm(uv*40000.)*0.2;\n    }\n    // add the sun color & distortion\n    else\n    {\n    \tradius = initialRadius+fbm(uv*4000.)*0.02;\n    }\n    \n    float p = 1.-step(radius, dist);\n    color += mix(sunColorA, sunColorB, center.y-.1)*p*5.5;\n\n    // add lighting \"auras\" around the sun\n    radius = initialRadius*3.+fbm(uv*center*sin(iTime*.3));\n    p = 1.-smoothstep(radius, radius+0.4, dist);;\n    color += p*0.08*sunColorA;\n\n    radius = initialRadius*1.+fbm(uv*center*2.*abs(sin(iTime*.6)))*0.12;\n    p = 1.-smoothstep(radius, radius+0.4, dist);;\n    color += p*0.12*sunColorB;\n    \n    color *= 1.4;\n\n    // Body of water\n    radius = 0.15+noise(uv).y*0.02;\n    p = 1.-smoothstep(radius, radius+0.1, uv.y);\n    color = mix(color, colorC, vec3(p*1.1*max(.2, (1.-smoothstep(.1, .9, center.y)))));\n    color *= smoothstep(-0.1, .22, uv.y);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}