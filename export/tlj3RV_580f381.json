{"ver":"0.1","info":{"id":"tlj3RV","date":"1560330124","viewed":247,"name":"ZJUGalaxy - Blackhole","username":"zhongjn","description":"CG2019 lecture project ZJUGalaxy\nThis scene demostrates the GRAVITATIONAL LENSING effect\nReference: https://www.shadertoy.com/view/lstSRS","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n    \n    \n    color += GetBloom(uv) * 0.08;\n    \n    color *= 200.0;\n    \n\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n\n    fragColor = vec4(color, 1.0);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uniform sampler2D tex_disc;\nuniform sampler2D tex_previous;\nconst vec3 cam_pos = vec3(0,4.5, -28);\nconst vec3 cam_dir = vec3(0, 0, 1);\nconst float cam_tan_half_v_angle =.5;\nconst float disc_inner = 3.;\nconst float disc_mid = 3.5;\nconst float disc_outer = 6.;\nconst float disc_thickness = 0.2;\nconst float step_time = 0.01;\nconst int steps = 200;\nconst float disc_rot_inner = 0.15;\nconst float disc_rot_outer = 0.02;\nconst float r_cutoff = 28.5;\n\n// const vec3 star_pos = vec3(5,3,-10);\nconst float star_orbit_r = 12.;\nconst float star_orbit_rot = 0.8;\nconst float star_r = 2.;\nconst float star_rot = 0.1;\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat rand(vec2 coord) {\n    return saturate(fract(sin(dot(coord, vec2(12.9898, 78.223))) * 43758.5453));\n}\n\nfloat rand(vec3 coord) {\n    return saturate(fract(sin(dot(coord, vec3(12.9898, 78.223, 21.132))) * 43758.5453));\n}\n\nvec3 to_radial( in vec3 xyz )\n{\n\n\tfloat r = length( xyz );\n\txyz *= 1.f/r;\n\tfloat theta = acos( xyz.y );\n\tfloat phi = atan( xyz.z, xyz.x );\n\tphi += ( phi < 0. ) ? 2. * 3.14159 : 0.;  // only if you want [0,2pi)\n\treturn vec3(phi, theta, r );\n\n}\n\nfloat ray_sphere_intersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n\n\nvoid get_disc(inout vec3 color, inout float alpha_remain, vec3 pos, vec3 old_pos) {\n\n    bool use_mid = abs(pos.y - old_pos.y) > .01;\n    vec2 mid = (pos.y * old_pos.xz - old_pos.y * pos.xz) / (pos.y - old_pos.y);\n    vec2 xz0 = use_mid ? mid : pos.xz;\n    float r = length(xz0);\n    bool crossed = (pos.y * old_pos.y < 0.) || (abs(pos.y) < -.001);\n\tif (r >= disc_inner && r <= disc_outer && crossed) {\n        float alpha = 1.;\n\t\tfloat h_alpha = 0.;\n        //float h_alpha = (r >= disc_inner && r <= disc_mid) ? .8 : 0.;\n        float ratio_mid = r / disc_mid;\n        //h_alpha = (ratio_mid >= 1.) ? max(0., 1. + (r-disc_mid)/(disc_mid-disc_outer)) : h_alpha;\n        h_alpha = (r >= disc_inner) ? saturate(pow(abs(r-disc_outer), 3.) / 8. )  : h_alpha;\n        //h_alpha /= r * r * r / 30.;\n\n        vec3 cc;\n\t\t\n        float angle = atan(xz0.y, xz0.x);\n        float u_inner = fract(iTime * disc_rot_inner +  angle / 2. /3.14159 + .5);\n        float u_outer = fract(iTime * disc_rot_outer +  angle / 2. /3.14159 + .5);\n        float v = 1. - (r - disc_inner) / (disc_outer - disc_inner);\n        \n        vec3 cc_inner = texture(iChannel2, vec2(u_inner, v)).rgb;\n\t\tvec3 cc_outer = texture(iChannel3, vec2(u_outer, v)).rgb;\n\t\tcc = mix(cc_inner, cc_outer, 1. - pow(v, 2.5));\n        \n        alpha = h_alpha;\n        //alpha = (pos.y * old_pos.y > 0.) ? 0. : alpha;\n\n\n        color += alpha * alpha_remain * cc;\n        alpha_remain *= (1. - alpha);\n     }\n\n\tbool in_photon_sphere = dot(pos, pos) <= 1.;\n\talpha_remain = in_photon_sphere ? 0. : alpha_remain;\n     \n}\n\nvoid get_star(inout vec3 color, inout float alpha_remain, vec3 pos, vec3 old_pos) {\n    float alpha = 0.;\n    vec3 cc;\n    \n    vec3 star_pos = vec3(sin(iTime * star_orbit_rot), 0, cos(iTime * star_orbit_rot));\n    star_pos *= star_orbit_r;\n    \n    \n    //vec3 delta = pos - star_pos;\n    vec3 dir = pos - old_pos;\n    vec3 norm_dir = normalize(dir);\n    \n    {\n        float trav = ray_sphere_intersect(pos, norm_dir, star_pos, star_r);\n        if (trav > 0. && trav < length(dir)) {\n            vec3 hit_pos = trav * norm_dir + pos;\n            vec3 delta = hit_pos - star_pos;\n\n            //if (length(delta) <= star_r) {\n                alpha = 1.;\n                vec3 rad = to_radial(delta);\n                float u = rad.x / 2. / 3.14159;\n                float v = rad.y / 3.14159;\n                u = fract(u+iTime*star_rot);\n                cc = texture(iChannel1, vec2(u,v)).rgb * 0.3;\n                //cc = vec3(1.3,.5,0);\n            //}\n\n        }\n    }\n          \n    {\n        float trav = ray_sphere_intersect(pos, norm_dir, star_pos, star_r * 1.5);\n        //vec3 delta = pos - star_pos;\n        if (trav > 0. && trav < length(dir)) {\n\t\t\tvec3 hit_pos = trav * norm_dir + pos;\n            vec3 delta = hit_pos - star_pos;\n            vec3 r_v = cross(normalize(dir), delta / star_r);\n            float r = dot(r_v, r_v);\n            float f = (1.0-sqrt(abs(1.-r)))/(r);\n            f = f*f;\n            vec3 orange = vec3( 1.3, 0.65, 0.3 );\n            cc += vec3( f * 1.75 * orange ) * 1.;\n            alpha += f * 0.4;\n        }\n    }\n    \n    alpha = saturate(alpha);\n    \n    color += alpha * alpha_remain * cc;\n    alpha_remain *= (1. - alpha);\n}\n\nvec3 get_accel(float h2, vec3 pos) {\n    float r2 = dot(pos, pos);\n\tvec3 acc = -1.5 * h2 * pos / pow(r2, 2.5) * 1. ;\n    return acc;\n}\n\nvoid RK4f(float h2, out vec3 fp, out vec3 fv, vec3 p, vec3 v) {\n    fp = v;\n    fv = get_accel(h2, p);\n}\n\n\nvoid light_step(float h2, inout vec3 pos, inout vec3 v) {\n\tfloat r2 = dot(pos, pos);\n\tvec3 acc = get_accel(h2, pos);\n    \n    float dt = step_time;\n    dt *= max(10., length(cam_pos));\n\t    \n    float dd = dot(normalize(pos), normalize(v));\n    float step_add = 0.;\n    step_add += r2 >= 8. ? pow(r2, .35) : 0.;\n    //step_add *= saturate(abs(pos.y));\n    //t *= 1. - dd * 0.5;\n    //dt *= 1. + step_add;\n\t\n\t//t *= 1. + dd * .5;\n    \n    //t *= .11 + saturate(pos.y);\n\n    //d_v = acc * dt;\n    //d_p = v * dt;\n    \n    vec3 d_p, d_v;\n    \n    vec3 kp1, kp2, kp3, kp4;\n    vec3 kv1, kv2, kv3, kv4;\n    RK4f(h2, kp1, kv1, pos, v);\n    RK4f(h2, kp2, kv2, pos + .5 * dt * kp1, v + .5 * dt * kv1);\n    RK4f(h2, kp3, kv3, pos + .5 * dt * kp2, v + .5 * dt * kv2);\n    RK4f(h2, kp4, kv4, pos + 1. * dt * kp3, v + 1. * dt * kv3);\n    \n    d_p = dt * (kp1 + 2. * kp2 + 2. * kp3 + kp4) / 6.;\n    d_v = dt * (kv1 + 2. * kv2 + 2. * kv3 + kv4) / 6.;\n   \n\n    \n    \n\tpos += d_p;\n    v += d_v;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_origin = uv;\n    uv.x += (rand(uv + sin(iTime * 1.0)) / iResolution.x) * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    uv.y += (rand(uv + 1.0 + sin(iTime * 1.0)) / iResolution.y) * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    float rand = (rand(uv + 1.0 + sin(iTime * 1.0)) / 50.);\n\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec3 dir = vec3((uv * 2. - 1.) * vec2(aspect, 1.) * cam_tan_half_v_angle, 1.);\n    //dir.z += rand;\n     //dir = normalize(dir);\n    \n\tvec3 pos = cam_pos;\n\tvec3 h = cross(pos, dir);\n\tfloat h2 = dot(h, h);\n\tvec3 color = vec3(0, 0, 0);\n\tfloat alpha = 1.;\n    \n    \n    // 1. (faster, 120fps)\n   \tif (length(cross(normalize(dir), pos)) > r_cutoff) return;\n   \tfor (int i = 0; i < steps; i++) {\n        vec3 old = pos;\n        light_step(h2, pos, dir);\n        get_disc(color, alpha, pos, old);\n        get_star(color, alpha, pos, old);\n    }\n    \n    \n    // 2. (slower, 30fps)\n\t/*if (length(cross(normalize(dir), pos)) <= r_cutoff)  {\n        for (int i = 0; i < steps; i++) {\n            vec3 old = pos;\n            light_step(h2, pos, dir);\n            get_disc(color, alpha, pos, old);\n        }\n    }*/\n\n    color *= 0.03;\n    \n    const float p = 1.0;\n    vec3 previous = pow(texture(iChannel0, uv_origin).rgb, vec3(1.0 / p));\n    color = pow(color, vec3(1.0 / p));\n    float blendWeight = 0.5 * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    color = mix(color, previous, blendWeight);\n    color = pow(color, vec3(p));\n    \n    fragColor = vec4(saturate(color), 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}