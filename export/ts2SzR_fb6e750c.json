{"ver":"0.1","info":{"id":"ts2SzR","date":"1552763238","viewed":690,"name":"Lightning Fragment Shader","username":"jjxtra","description":"I am working on a potential fragment only lightning effect... Lots of different lines and experimentation, the possibilities are endless. I would love any feedback. This shader code I release as public domain, feel free to use as you see fit. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["line","lines","lightning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------------------\n//License CC0 - http://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n//----------------------------------------------------------------------------------------\n//^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n// - jjxtra\n//\n// lines can be used as great building blocks for many things:\n// lines, curves, grid, shapes, lightning and other special effects\n// mod and sin is cheap on modern GPU\n// throw some of these in an fbm style loop and watch things get crazy\n//\n// I spent an afternoon making all types of lines\n// I am trying them out in a fragment only lightning shader\n// this is one of my hobby projects at the moment as I research where this can go\n// I'm sharing my progress publicly in the hopes of getting feedback\n// \n// * hit pause to see the structure\n//\n// TODO:\n// - Make lightning more jagged and twisted\n// - Add smaller lightnings shooting out from sides\n// - Improve patchwork / foggy areas\n// - Option to isolate to a single column or row\n// - Optimize the code\n// maybe a custom noise texture for distortion and more detail is unavoidable but I am trying to not go that route yet...\n\n#define UVSCALE 8.0\n\n// https://gamedev.stackexchange.com/questions/141916/antialiasing-shader-grid-lines\n#define AA(v) abs(fract(v) - 0.5)\n\n// take only values that are very close to 1.0\n#define CCD 0.001\n#define CC(v) clamp(floor(v + CCD), 0.0, 1.0)\n\nvec2 getpos(vec2 uv)\n{\n    uv = UVSCALE * (uv / iResolution.xy);\n    float aspect = iResolution.x / iResolution.y;\n  \tvec2 ratio = vec2(aspect, 1.0);\n  \treturn (2.0 * uv - 1.0) * ratio;\n}\n\n// http://madebyevan.com/shaders/grid/\n#define AAG(v) abs(fract(v - 0.5) - 0.5) / fwidth(v)\nfloat grid(vec2 xy)\n{\n    vec2 gridLines = AAG(xy);\n    return 1.0 - min(gridLines.x, gridLines.y);\n}\n\nfloat checkerboard(vec2 xy)\n{\n    const float scalar = 0.25;\n    vec2 xyMod = mod(xy * scalar, 1.0);\n    return float((xyMod.x < 0.5f) ^^ (xyMod.y < 0.5f));\n}\n\n// must be >= 2.0, change to modify the spacing between some of the spaced out line calls\n#define MODP 3.0\n\nfloat lightningNoise(vec2 detailPos, vec2 detailPos2, vec2 shapePos)\n{\n    const float offsetScalar = 0.91; // chaos factor\n    const float offsetScalar2 = 0.213; // detail factor\n    const float noiseMultiplier = 1.0;\n    \n    float t = iTime * 4.0;\n    float t2 = t * 1.646579370;\n    \n    // detail #1 noise offset func\n    vec2 noiseXY = AA(((detailPos + t)));\n    float noiseZ = AA(detailPos.y - t2 + noiseXY.x);\n    vec2 offset = vec2(noiseZ, noiseXY.x + noiseXY.y);\n    \n    // modify shape pos by detail #1 noise offset\n    shapePos += (offset * offsetScalar);\n    \n    // detail #2 noise offset func\n    noiseXY = AA(((detailPos2 - t2)));\n    noiseZ = AA(detailPos2.y - t2 + noiseXY.y);\n    offset = vec2(noiseXY.x + noiseXY.y, noiseZ);\n    \n    // modify shape pos by detail #2 noise offset\n    shapePos += (offset * offsetScalar2);\n    \n    // shape pos noise func, swap the x and y for horizontal lightning\n    noiseZ = AA((shapePos.x) + AA((shapePos.y)));\n    \n    // diagonal lightning\n    //noiseZ = AA((shapePos.x) + ((shapePos.y)));\n    \n    return noiseZ * noiseMultiplier;\n}\n\n// simple fbm test with two positions in a loop that are scaled\nfloat lightningNoiseFBM(vec2 p)\n{\n    p *= 0.15;\n\n    const float intensity = 10.0;\n    const float power = 4.0;\n    const float detailScalar = 0.46213;\n    const float detail2Scalar = 1.96213;\n    const float shapeScalar = 1.06213;\n    const float decay = 0.3;\n    float amplitude = 0.8;    \n    float noise = 0.0;\n    vec2 detailPos = p;\n    vec2 detailPos2 = p;\n    vec2 shapePos = p;\n    \n    for (int i = 0; i < 5; i++)\n    {\n        detailPos *= detailScalar;\n        detailPos2 *= detail2Scalar;\n        shapePos *= shapeScalar;\n        \n\t\tnoise += (lightningNoise(detailPos, detailPos2, shapePos) * amplitude);\n\n        amplitude *= decay;\n    }\n    \n    return min(1.0, intensity * pow(noise, power));\n}\n\nvec4 lightningShader(vec2 p)\n{\n    float noise = lightningNoiseFBM(p);\n    vec3 color3 = mix(vec3(0.2, 0.2, 0.8), vec3(1.0, 1.0, 1.0), noise);\n    return vec4(color3 * noise, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat color = 0.0;\n    vec2 p = getpos(fragCoord);\n    fragColor = lightningShader(p);\n    return;\n    \n    // line testing functions...\n    \n\tfloat ax = AA(p.x); // anti alias\n\tfloat ay = AA(p.y);\n\tfloat sx = sin(p.x); // sin\n\tfloat sy = sin(p.y);\n    float asx = max(0.0, sx); // sin max of 0\n    float asy = max(0.0, sy); // \n    float mx = mod(p.x, MODP); // mod of p\n    float my = mod(p.y, MODP);\n    float _max = mod(p.x + ay, MODP); // mod of p + aa\n    float may = mod(p.y + ax, MODP);\n    float msx = mod(p.x + sy, MODP); // mod of p + sin\n    float msy = mod(p.y + sx, MODP);\n    float mxl = float(mx >= 0.5 && mx < 1.5); // if mod within a range (to spread out lines)\n    float myl = float(my >= 0.5 && my < 1.5);\n    float maxl = float(_max >= 0.5 && _max < 1.5); // if mod within a range (to spread out lines)\n    float mayl = float(may >= 0.5 && may < 1.5);\n    float msxl = float(msx >= 0.5 && msx < 1.5); // if mod within a range with sin (to spread out curved lines)\n    float msyl = float(msy >= 0.5 && msy < 1.5);\n    \n    // most of these line functions below can be used inside the lightning noise function\n    // in various ways...\n    \n    //color = checkerboard(vec2(p.x, p.y));\n\t//color = clamp((sx + sy), 0.0, 1.0); // iso checkerboard\n\t//color = ceil(min(1.0, (sx + sy))); // iso checkerboard hard\n    //color = grid(vec2(p.x, p.y)); // grid lines\n    //color = floor(min(1.0, max(ax, ay) + 0.53)); // grid lines without derivatives and division\n    //color = ceil(ay * asx * asy);\n\t//color = ax; // horizontal smoothed line\n\t//color = ay; // vertical smoothed line\n    //color = ay * myl; // horizontal lines spread out\n    //color = ax * mxl; // vertical lines spread out\n\t//color = AA(p.x + p.y); // diagonal top left to bottom right lines\n\t//color = AA(p.x - p.y); // diagonal bottom left to top right lines\n\t//color = max(0.0, sin(p.x + p.y)); // more spread out diagonal top left to bottom right lines\n\t//color = max(0.0, sin(p.x - p.y)); // more spread out diagonal bottom left to top right lines\n\t//color = CC(abs(sin(p.x + p.y))); // more spread out thin hard diagonal top left to bottom right lines\n\t//color = CC(abs(sin(p.x - p.y))); // more spread out thin hard diagonal bottom left to top right lines\n\t//color = AA(ax + p.y); // horizontal jagged line\n\t//color = AA(ay + p.x); // vertical jagged line\n    //color = mayl * AA(ax + p.y); // horizontal jagged line spread out more    \n    //color = maxl * AA(ay + p.x); // vertical jagged line spread out more    \n\t//color = AA(ax + p.x); // thinner vertical line\n\t//color = AA(ay + p.y); // thinner horizontal line\n\t//color = AA(p.x + sy); // curved vertical line\n\t//color = AA(p.y + sx); // curved horizontal line\n    //color = msxl * AA(p.x + sy); // curved vertical line spread out\n    //color = msyl * AA(p.y + sx); // curved horizontal line spread out\n\t//color = max(0.0, sin(p.y + sx)); // wavy horizontal line\n\t//color = max(0.0, sin(p.x + sy)); // wavy vertical line\n\t//color = CC(sin(p.y + sx)); // wavy thin hard horizontal line\n\t//color = CC(sin(p.x + sy)); // wavy thin hard vertical line\n\t//color = CC(abs(sin(p.y + sx))); // thin hard horizontal line\n\t//color = CC(abs(sin(p.x + sy))); // thin hard vertical line\n\t//color = CC(abs(sin(p.x + ay))); // thin hard jagged vertical line\n\t//color = CC(abs(sin(p.y + ax))); // thin hard jagged horizontal line\n    \n\tfragColor = vec4(color, color, color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}