{"ver":"0.1","info":{"id":"DtsBR2","date":"1693190954","viewed":52,"name":"Dynamic Julia Set","username":"halirutan","description":"Dynamic visualization of the Julia Set ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Simple loop to iterate z -> z^2+c for a starting point\n * z and a constant c. Both values are complex numbers represented\n * as vec2(real, imaginary).\n * Returns a value between [0, 1] depending on how fast (if at all) \n * abs(z) > 2 is approached.\n */\nfloat julia(in vec2 z_val, in vec2 c_val) {\n    \n    const float MAX_ITER = 500.0;\n\n    float re = z_val.x;\n    float img = z_val.y;\n    \n    float c_re = c_val.x;\n    float c_img = c_val.y;\n    \n    float iter = 0.0;\n    for (; iter < MAX_ITER; iter += 1.0) {\n    \n        if (img*img + re*re > 4.0) {\n            return iter/MAX_ITER;\n        }\n    \n        // Complex calculation of z = z^2 + c\n        float tmp_r = c_re - img*img + re*re;\n        img = c_img + 2.0*img*re;\n        re = tmp_r;\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\n    // User Settings: Viewport\n    // Select a center point (cx, cy) in the complex plane and\n    // decide for a zoom value. Higher values are for zooming in.\n    // Tip: These value don't need to be constant! Use iTime (seconds) to dynamic movement.\n    float cx = -0.415;\n    float cy = 0.3;\n    //float zoom = 1.0;\n    // Try this:\n    float zoom = 1.0 + 1000.0*pow(sin(0.1*iTime)*sin(0.1*iTime), 3.8);\n    \n    // User Settings: Julia Set constants\n    // Instead of taking just one fixed value C as is usually done,\n    // we use two complex values c1 and c2 for making the visualization \"move\".\n    // You will see all Julia Sets near the path that connects c1 and c2 on the complex plane.\n    // A good approach is to select one beautiful value for c1, use it also for c2 and then slowly\n    // start to vary c2.\n    // You can increase \"movement_speed\" to check if the whole movement looks nice.\n    vec2 c1 = vec2(-0.512511498387847167, 0.521295573094847167);\n    vec2 c2 = vec2(-0.51, 0.52);\n    \n    // User Settings: Speed\n    // Factor that indicates how fast the Julia visualization is moving.\n    float movement_speed = 0.005;\n    // Factor that indicates how fast the colors are chaning.\n    float color_speed = 0.5;\n    \n    \n    // Transformation of the viewport from pixel coordinates into a rectangle\n    // with center at (cx, cy) and a specific scaling depending on zoom.\n    // If you want to know what's going on here, read about homogeneous coordinates.\n    float w = iResolution.x;\n    float h = iResolution.y;\n    zoom = 1.0/zoom;\n    mat3 transformation = mat3(\n      2.0*zoom/w,    0.0,             0.0,\n      0.0,           2.0*zoom/w,      0.0,\n      cx - zoom,     cy - (zoom*h)/w, 1.0\n    );\n    vec3 tmp_uv = transformation * vec3(fragCoord.xy, 1.0);\n    vec2 uv = tmp_uv.xy;\n    \n\n    float t = movement_speed*iTime;\n    \n    // Calculating a helix-like path that moves from c1 to c2 and back repeatetly.\n    float PI = 3.14159267;\n    vec2 line = c2 - c1;\n    vec2 normal = vec2(-line.y, line.x);\n    float sc = 0.1*sin(16.0*PI*t);\n    float t_path = 0.5-0.5*cos(2.0*PI*t);\n    \n    // The final C values used for the current julia set is the position alont the\n    // calculated path at this moment in time.\n    vec2  C = (1.0 - t_path)*c1 + t_path*c2 + normal*sc;\n    float j = julia(uv, C);\n    \n    // Color calculation: The Julia calculation only returns single numbers in the range [0, 1].\n    // Here we do two things:\n    //   - We create a 3D path inside the RBG color cube using trigonometric functions\n    //   - The final path is then continuously rotated around the line from (0,0,0) to (1,1,1) in\n    //     the color cube. This gives a nice and slow changing of colors.\n    \n    float t_color = color_speed * iTime;\n    float f1 = 10.0*(sin(t_color) + 2.0);\n    float f2 = 20.0*(sin(t_color) + 2.0);\n    float f3 = 30.0*(sin(t_color) + 2.0);\n\n    float red = 0.1*cos(sqrt(f1*2.0*PI*j)) + 0.9*j + (0.1+0.1*sin(iTime));\n    float green = 0.2*cos(sqrt(f2*2.0*PI*j)) + 0.5*j*j + 0.3;\n    float blue = j*sin(sqrt(f3*2.0*PI*j)) - 0.5*j*j + 0.5;\n    \n    \n    vec3 col = vec3(\n        (red*(1.0 + 2.0*cos(t_color)))/3.0+(green*(1.0-cos(t_color)-\n          sqrt(3.0)*sin(t_color)))/3.+(blue*(1.0-cos(t_color)+sqrt(3.0)*sin(t_color)))/3.0,\n          \n        (green*(1.0 + 2.0*cos(t_color)))/3.0+(blue*(1.0-cos(t_color)-sqrt(3.0)*sin(t_color)))/3.+\n          (red*(1.0-cos(t_color)+sqrt(3.0)*sin(t_color)))/3.0,\n          \n        (blue*(1.0+2.0*cos(t_color)))/3.0+(red*(1.0-cos(t_color)-sqrt(3.0)*sin(t_color)))/3.+ \n          (green*(1.0-cos(t_color)+sqrt(3.0)*sin(t_color)))/3.0  \n          );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}