{"ver":"0.1","info":{"id":"NssXzn","date":"1618208233","viewed":160,"name":"Rngeasy demo","username":"antovsky","description":"A demo of how the Rngeasy compiles and runs on the GPU and CPU with the same code.\nhttps://github.com/antonthefirst/rngeasy","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["random","generator","library"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    RngState rng = rngSeed(uint(uv.x*iResolution.x));\n   \n    vec3 col = vec3(floatUnit(rng), floatUnit(rng), floatUnit(rng));\n    \n    // Stateless fizzlefade effect\n    u32 i = u32(iTime * 1000.0);\n    u32 idx = u32(fragCoord.x + fragCoord.y * iResolution.x);\n    u32 count = u32(iResolution.x * iResolution.y);\n    u32 seed = 108u;\n    if (shuffle(idx, count, seed) >= i)\n        col = vec3(0.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* CPU/GPU cross compatibility. */\n#ifdef _WIN32\n#pragma once\n\n/* For copysign. */\n#include <math.h>\n\n/* An alias for an unsigned 32bit integer, used as the generic \"bits\" of state. */\ntypedef unsigned int bits32;\n\n/* An alias for unsigned and signed 32bit integers, used as the random numbers. */\ntypedef unsigned int u32;\ntypedef int s32;\n\n/*\n   A placeholder for a quaternion structure, replace it with your own.\n   Convention is Hamiltonian, component order xyzw.\n*/\nstruct quat {\n\tfloat x,y,z,w;\n\tquat() { }\n\tquat(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) { }\n};\n\n/*\n   A placeholder for a vector2 structure, replace it with your own.\n*/\nstruct vec2 {\n\tfloat x, y;\n\tvec2() { }\n\tvec2(float _x, float _y) : x(_x), y(_y) { }\n\tvec2(float _s) : x(_s), y(_s) { }\n\tvec2 operator*(const vec2& rhs) const { return vec2(x * rhs.x, y * rhs.y); }\n};\n\n/*\n   A placeholder for a vector3 structure, replace it with your own.\n*/\nstruct vec3 {\n\tfloat x, y, z;\n\tvec3() { }\n\tvec3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) { }\n\tvec3(float _s) : x(_s), y(_s), z(_s) { }\n\tvec3 operator*(const vec3& rhs) const { return vec3(x * rhs.x, y * rhs.y, z * rhs.z); }\n};\n\n/* Math operators. */\n#define floatSin sinf\n#define floatCos cosf\n#define floatSqrt sqrtf\ninline float inversesqrt(float x) { return 1.0f / floatSqrt(x); } // GPU has a special function for this\ninline float dot(const vec3& a, const vec3& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\ninline float sign(float x) { // GLSL compatibility version\n\tif (x > 0.0f) return 1.0f;\n\telse if (x < 0.0f) return -1.0f;\n\telse return 0.0f;\n}\n\n/* Needed because GPU needs to ignore it. */\n#define INLINE inline\n\n#define RNGSTATE_REF RngState&\n\n#pragma warning( push )\n#pragma warning( disable : 4146 ) // using unary minus on unsigned values\n\n#else\n\n/* An alias for an unsigned 32 bit integer, used as the generic \"bits\" of state. */\n#define bits32 uint\n\n/* An alias for unsigned and signed 32bit integers, used as the random numbers. */\n#define u32 uint\n#define s32 int\n\n/* On GPU you probably want quaternions to just be vec4's. */\n#define quat vec4\n\n/* Math operators. */\n#define floatSin sin\n#define floatCos cos\n#define floatSqrt sqrt\n\n/* GPU doesn't care about inline. */\n#define INLINE  \n\n\n#define RNGSTATE_REF inout RngState\n\n#endif\n\n/* Limits and specifications. */\n#define FLOAT32_MANT_DIG     24                      // # of bits in mantissa\n\n/* Mathematical constants. */\n#define PI 3.14159265358979323846f\n#define TAU (PI*2.0f)\n\n/*\n   Generator state and core function definitions.\n   To replace the generator, any implementation that fits this api should work.\n*/\nstruct RngState { bits32 s0; bits32 s1; }; // Can't forward declare structs on GPU...\nRngState rngSeed(bits32 seed_bits);\nbits32   rngAdvance(RNGSTATE_REF rng);\n\n/*\n   Integers module.\n*/\n\nu32 u32Any(RNGSTATE_REF);                  // [0, INT32_MAX)\nu32 u32To(RNGSTATE_REF, u32 max);          // [0, max)\nu32 u32In(RNGSTATE_REF, u32 min, u32 max); // [min, max]\ns32 s32In(RNGSTATE_REF, s32 min, s32 max); // [min, max]\n\n/*\n   Distributions module.\n*/\nu32  dice(RNGSTATE_REF, u32 sides);                        // Simulate an N-sided die, returns [0, SIDES)\nu32  diceNoRepeat(RNGSTATE_REF, u32 sides, u32 prev_roll); // Same as dice(), but ensure that the roll is different from PREV_ROLL.\nbool oneIn(RNGSTATE_REF, u32 chance);                      // 1:CHANCE that it returns true. (aka. dice(CHANCE) == 0)\n\n/*\n   Floats module.\n*/\nfloat floatUnit(RNGSTATE_REF);                      // [0.0, 1.0]\nfloat floatEUnit(RNGSTATE_REF);                     // [0.0, 1.0)\nfloat floatIn(RNGSTATE_REF, float min, float max);  // [min, max]\n\n/*\n   Vectors module.\n*/\nvec2 vec2InUnitCircle(RNGSTATE_REF);\nvec2 vec2OnUnitCirle(RNGSTATE_REF);\nvec3 vec3InUnitSphere(RNGSTATE_REF); // #TODO\nvec3 vec3OnUnitSphere(RNGSTATE_REF);\nvec3 vec3OnUnitHemisphere(RNGSTATE_REF, vec3 normal); // #TODO\n\n/*\n   Quaternions module.\n*/\nquat quatAny(RNGSTATE_REF);\n\n/*\n   Function implementations.\n*/\nu32 u32Any(RNGSTATE_REF rng) {\n\treturn rngAdvance(rng);\n}\nu32 u32To(RNGSTATE_REF rng, u32 max) {\n\t/*\n\t   This code is adapted from: http://www.pcg-random.org, basic generator C file (http://www.pcg-random.org/downloads/pcg-c-basic-0.9.zip)\n\t   The loop is guaranteed to terminate if the generator is uniform.\n\t   The chance of this loop re-rolling is roughly proportional to the range\n\t   For small ranges up to say 1024, the chance is around 0.00002%, or 1 in 4 million.\n\t   For medium ranges of say 2^16, the changes is around 0.002% or 1 in 66 thousand.\n\t   So it's safe to say for \"most\" cases, it will return without actually looping.\n\t*/\n\tu32 threshold = -max % max;\n\tfor (;;) {\n\t\tu32 r = rngAdvance(rng);\n\t\tif (r >= threshold)\n\t\t\treturn r % max;\n\t}\n}\nu32 u32In(RNGSTATE_REF rng, u32 range_min, u32 range_max) {\n\treturn range_min + u32To(rng, range_max - range_min + u32(1)); // _to excludes the max, so +1\n}\ns32 s32In(RNGSTATE_REF rng, s32 range_min, s32 range_max) {\n\treturn range_min + s32(u32To(rng, u32(range_max - range_min + 1))); // _to excludes the max, so +1\n}\nu32 dice(RNGSTATE_REF rng, u32 sides) {\n\treturn u32To(rng, sides);\n}\n/* #TODO Go Alan go! :)\nu32 diceNoRepeat(RNGSTATE_REF rng, u32 sides, u32 prev_roll) {\n\n}\n*/\nbool oneIn(RNGSTATE_REF rng, u32 chance) {\n\treturn chance != u32(0) ? dice(rng, chance) == u32(0) : false;\n}\n\n/* To have the correct distribution, we cannot simply divide by INT32_MAX, since a float cannot express that value exactly. */\n/* https://prng.di.unimi.it/ section \"Generating uniform doubles in the unit interval\" */\nINLINE float unitFromBits(u32 bits) {\n\t/* Divide is required here for strict correctness; \"times_one_over\" optimization yields slight excess of 1.0 values. (512 of ~16M instead of 256) */\n\treturn float(bits >> (32 - FLOAT32_MANT_DIG)) / float((1 << FLOAT32_MANT_DIG) - 1);\n}\nINLINE float eunitFromBits(u32 bits) {\n\t/* Unlike the [0,1] case, the \"times_one_over\" optimization yields identical results, so we can apply it here. */\n\treturn float(bits >> (32 - FLOAT32_MANT_DIG)) * (1.0f / float((1 << FLOAT32_MANT_DIG)));\n}\n\nfloat floatUnit(RNGSTATE_REF rng) {\n\treturn unitFromBits(rngAdvance(rng));\n}\nfloat floatEUnit(RNGSTATE_REF rng) {\n\treturn eunitFromBits(rngAdvance(rng));\n}\n/* #TODO make sure Snit and ESnit are actually unbiased down to the bit level. */\nfloat floatSnit(RNGSTATE_REF rng) {\n\tu32 b = rngAdvance(rng);\n\treturn unitFromBits(b) * sign((b & u32(0x8000000)) != u32(0) ? +1.0f : -1.0f);\n}\nfloat floatESnit(RNGSTATE_REF rng) {\n\tu32 b = rngAdvance(rng);\n\treturn eunitFromBits(b) * sign((b & u32(0x8000000)) != u32(0) ? +1.0f : -1.0f);\n}\n\nfloat floatIn(RNGSTATE_REF rng, float range_min, float range_max) {\n\treturn range_min + (range_max - range_min) * floatUnit(rng);\n}\n\nvec2 vec2InUnitCircle(RNGSTATE_REF rng) {\n\tfloat a = floatEUnit(rng) * TAU;\n\tfloat r = floatSqrt(floatUnit(rng));\n\treturn vec2(sin(a), cos(a)) * vec2(r);\n}\nvec2 vec2OnUnitCirle(RNGSTATE_REF rng) {\n\tfloat a = floatEUnit(rng) * TAU;\n\treturn vec2(sin(a), cos(a));\n}\nvec3 vec3OnUnitSphere(RNGSTATE_REF rng) {\n\t/* #TODO source? */\n\tfloat s = floatUnit(rng) * TAU;\n\tfloat t = floatUnit(rng) * 2.0f - 1.0f;\n\treturn vec3(floatSin(s), floatCos(s), t) * vec3(inversesqrt(1.0f + t * t));\n}\nvec3 vec3OnUnitHemisphere(RNGSTATE_REF rng, vec3 normal) {\n\t/* #TODO source? */\n\tvec3 v = vec3OnUnitSphere(rng);\n\treturn v * sign(dot(v, normal));\n}\n\nquat quatAny(RNGSTATE_REF rng) {\n\t// from http://planning.cs.uiuc.edu/node198.html\n\tfloat u1 = floatUnit(rng);\n\tfloat u2 = floatUnit(rng);\n\tfloat u3 = floatUnit(rng);\n\treturn quat(floatSqrt(1.0f - u1) * floatSin(TAU * u2), floatSqrt(1.0f - u1) * floatCos(TAU * u2), floatSqrt(u1) * floatSin(TAU * u3), floatSqrt(u1) * floatCos(TAU * u3));\n}\n\n\n/*\n   Generator implementation:\n   Xoroshiro64StarStar generator, seeded with splitmix32.\n   http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n   https://stackoverflow.com/questions/17035441/looking-for-decent-quality-prng-with-only-32-bits-of-state\n*/\n\nINLINE bits32 splitmix32(bits32 b) {\n\tb += bits32(0x9e3779b9);\n\tb ^= b >> 15;\n\tb *= bits32(0x85ebca6b);\n\tb ^= b >> 13;\n\tb *= bits32(0xc2b2ae3d);\n\tb ^= b >> 16;\n\treturn b;\n}\nINLINE RngState rngSeed(bits32 seed_bits) {\n\tRngState rng;\n\t/* s0 and s1 cannot both be 0 for xoroshiro generator, so to avoid this we hash the seed twice\n\t   with splitmix32. Since it is bijective, it guarantees that at least one of them is non-zero\n\t   (because if one is zero, it would hash to nonzero). */\n\trng.s1 = splitmix32(seed_bits);\n\trng.s0 = splitmix32(rng.s1);\n\treturn rng;\n}\nINLINE u32 rotl(const u32 x, s32 k) { return (x << k) | (x >> (32 - k)); }\nINLINE bits32 rngAdvance(RNGSTATE_REF rng) {\n\tu32 s0 = rng.s0;\n\tu32 s1 = rng.s1;\n\tu32 result_starstar = rotl(s0 * u32(0x9E3779BB), 5) * u32(5);\n\ts1 ^= s0;\n\trng.s0 = rotl(s0, 26) ^ s1 ^ (s1 << 9); // a, b\n\trng.s1 = rotl(s1, 13); // c\n\treturn result_starstar;\n}\n\n/* \n   Adapted into a stateless versionfrom:\n   https://blog.demofox.org/2013/07/06/fast-lightweight-random-shuffle-functionality-fixed/\n   https://github.com/Atrix256/RandomCode/blob/master/StoragelessShuffle/Source.cpp\n*/\nINLINE u32 shuffle(u32 idx, u32 count, u32 seed) {\n\t/* Pre-calculate the masks needed for the Feistel network. */\n\t/* If doing this for many indecies in a row, it would make sense to cache this. */\n\tu32 next_pow_4 = u32(4);\n\twhile (count > next_pow_4)\n\t\tnext_pow_4 *= u32(4);\n\tu32 num_bits = u32(0);\n\tu32 mask = next_pow_4 - u32(1);\n\twhile (mask != u32(0)) {\n\t\tmask = mask >> 1;\n\t\tnum_bits++;\n\t}\n\tu32 half_num_bits = num_bits / u32(2);\n\tu32 right_mask = (u32(1) << half_num_bits) - u32(1);\n\tu32 left_mask = right_mask << half_num_bits;\n\n\t/* This will terminate as long as idx starts less than count. */\n\twhile (true)\n\t{\n\t\t/* Split the index. */\n\t\tu32 left = (idx & left_mask) >> half_num_bits;\n\t\tu32 right = (idx & right_mask);\n\t\t/* Do 4 Feistel rounds. */\n\t\tfor (int index = 0; index < 4; ++index)\n\t\t{\n\t\t\tu32 newLeft = right;\n\t\t\tu32 newRight = left ^ (splitmix32(right ^ seed) & right_mask);\n\t\t\tleft = newLeft;\n\t\t\tright = newRight;\n\t\t}\n\t\t/* Re-assemble the bits into a shuffled index. */\n\t\tidx = (left << half_num_bits) | right;\n\n\t\t/* If it's in range, we are done. Otherwise keep trying (reject this result) */\n\t\tif (idx < count)\n\t\t\treturn idx;\n\t}\n\t/* We should never get here. */\n\treturn u32(0);\n}\n\n#ifdef _WIN32\n#pragma warning( pop )\n#endif","name":"Common","description":"","type":"common"}]}