{"ver":"0.1","info":{"id":"3lG3Wh","date":"1578761801","viewed":856,"name":"Chromatic Feedback Lens Flares","username":"spalmer","description":"experimenting with procedural lens flare using feedback buffer chromashift\nmouse looks around, various keys toggle debug features: \nS=current bokeh shape, F=flares in BufferA, B=background, D=dithering\nit's set to cycle shapes every 10 seconds or so\n\n","likes":23,"published":1,"flags":48,"usePreview":0,"tags":["lensflare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy;\n    vec2 q = (p+p)/R.y - vec2(R.x/R.y,1.);\n\tmat3 M = mouselook(iMouse/R.y);\n    vec3 V = M * viewray(q); \n    c.rgb = vec3(0.);\n    if (option(66)) { // B for background\n\t    c.rgb += textureLod(iChannel1, V, 0.).rgb; // cubemap\n    \tc.rgb *= .92 * c.rgb; // un-srgb? it's way bright\n    }\n    if (!option(83)) // S for bokeh shape debug\n        c.rgb += vec3(shapeBokeh((q + vec2(.9,.5))*4., bokehMethod(iTime)));\n\tvec3 flares = texelFetch(iChannel0, ivec2(p), 0).rgb;\n    if (option(70)) // F for flares\n\t    c.rgb += flares;\n    if (option(68)) // D for dither\n\t    c.rgb += .95/256. * rand(fract(dot(p*.1, vec2(.04667, .0675))));\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamma\n    c.a = 1.;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//vec3 Hue(float h) // was thinking something like this originally but decided to chroma shift instead\n//{\n//    return .5+.5*cos((h+vec3(.0,1./3.,2./3.))*2.*3.141592f);\n//}\n//    c.rgb = Hue((iMouse.x-p.x)*.02);\n\nfloat rand(float x) { return sin(x * 49876.5); }\n\nint bokehMethod(float iTime)\n{\n\treturn int(fract(iTime*.1/6.)*6.); //5; //0; //\n}\n\nfloat shapeBokeh(vec2 q, int method)\n{\n    q = abs(q); // may as well, symmetry usually makes things easier for even sided shapes\n    // squinty lines?\n    bool blur = (method & 1) != 0; method >>= 1;\n    uint feat = uint(method) / 6u;\n    uint kind = uint(method) % 6u;\n//    q.y *= 256.*q.x*q.x + 1.001; // trying for stars - fairly convincing I guess\n//      q.x *= 256.*q.y*q.y + 1.001; // stars other way - I like these better sometimes\n\tif ((feat & 4u) != 0u) \n        q.y *= 3.; //6.; //2.; // unbalanced - squish vertically\n//    q.x *= 1./6.; // unbalanced - stretch horizontally\n    float r; // overall shape\n    switch (kind) {\n    \tcase 0u: r = dot(q,q) - .25; break; // round - squared metric\n        case 1u: r = q.y * q.y * (256.*q.x*q.x + 1.001) + q.x*q.x - .25; break; // star\n    \tcase 2u: r = max(q.y, dot(q, vec2(.86602,.5))) - .5; break; // hexagon\n\t\tcase 3u: r = length(q) - .5; break; // round - euclidean metric\n\t    case 4u: r = dot(q, vec2(.7)) - .7; break; // diamond\n        case 5u: r = max(abs(q.x), abs(q.y)) - .5; break; // square\n    } // my star is lame; try  max(0., 1.-abs(q.y*q.x*20.))\n    // how to deal with interior? reflect? falloff? \n//    if (r < .0) r += .05;\n//    r = dot();//\n    if ((feat & 2u) == 0u)\n    \tr = r < .0 ? r * -.5 : r; //max(0, r2); // hollow can be cool if smeared enough - helps when stacked\n    else\n        r = max(0., r);\n    if (blur)\n\t    r *= 6.; // focus / blur - larger makes more crisp\n    else\n        r *= 18.;\n    return exp2(-r); // fade\n}\n\n// both V (pixel ray dir) and L (light dir) are specified in view space\nvec3 LensFlares(vec3 V, vec3 L, int method)\n{ \n\tfloat vl = dot(V, L);\n\tvl = max(vl, 0.); // per-pixel is not as useful but is used to keep flares away from actual light source so it doesn't blow out detail on sun\n\tfloat fl = L.z;\n\tfl = max(fl, 0.); // do not show flares when camera aimed more than 90 degrees away from light\n\tfloat rl = sqrt(fl); // much more visible\n\tvec3 c = vec3(0);\n\tconst int nflares = 24;\n\tconst float rnf = 1. / float(nflares - 1);\n\tfor (int i = 0; i < nflares; ++i) {\n\t\tfloat si = float(i) * rnf;\n\t\tfloat xs = 8. * ((i & 3) == 0 ? -1. : 1.);\n        // FIXME I want a big one right at 0.  until I can get one here, I'll just hack one in the main fn\n\t\tfloat x = .05 + pow(si, 4.) * xs; // index along arc between L dir (0) and F dir (1) of this flare\n\t\tif (abs(x - 1.) < .166) continue; // just don't draw them if they happen to randomly be distributed near 1.0; they're so annoying! wish there was some better way to ensure this; have had no luck fading them out.\n\t\tfloat fhash = rand(si * 55.) * .5 + .5; // why the extra bias?\n\t\tfloat dotrescale = 3.; // larger numbers make flares smaller FIXME need inverted parameterization for scale\n\t\tfloat shrink = 0.;\n\t\tshrink += pow(fhash, 6.) * (rl + 1.);\n\t\tshrink = min(1., shrink + .5 * (1. - rl));\n\t\tdotrescale *= shrink * 24. + 1.; // some are smaller\n\t\tvec2 q = (V.xy - L.xy * (1. - x)) * dotrescale;\n\t\tvec3 cdot = vec3(1);\n\t    // each spot gets its own custom tint? nah, let the chromatic shift in the feedback handle it.\n\t//\tcdot = Hue(si * phi * tau);\n\t//\tcdot = mix(vec3(.75f), vec3(1.f), cdot); // desaturate hack\n\t\tfloat lfs = shapeBokeh(q, method);\n\t\tcdot *= lfs;\n\t\t// max may work better than add here; idea is to prevent stacked overlapped flares at sun\n        // from blowing out quite so much - but then don't need to divide by nflares below.\n        // but add is more realistic.  If you can balance it!\n\t\tc += cdot; //c = max(c, cdot); //\n\t}\n    c *= rnf;\n    vec2 k = V.xy - L.xy; // relative light source itself\n    c = max(c, shapeBokeh(8.*k, method) * .2); // the actual light flare at index 0.\n    c = max(c, shapeBokeh(4.*k, method) * .1); // bigger.\n    c = max(c, shapeBokeh(2.*k, method) * .05); // another bigger one\n    c = max(c, shapeBokeh(1.*k, method) * .025); // another even bigger one faded out more\n\tc *= rl;\n//\tc *= 1 - pow(vl, 16); // HACK fade out on rays looking directly at light (so can see sun behind)\n\tc *= vec3(1,1,1) * 1.; //.125;\n\treturn c;\n}\n\nmat3 cameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\nmat3 mouselook(vec4 mouse)\n{\n    vec3 f = vec3(0, 0, 1);\n    vec2 m;\n    if (length(mouse.xy) < 1e-2) {\n        m = vec2(0);\n    \tm.x += 1.21;\n    } else {\n        m = mouse.xy * 2. - 1.;\n        m.x += .31;\n    }\n    m.y += .05;\n//    if (mouse.z >= 0.) m -= mouse.zw;\n    m *= .7*6.281;\n    m.y = clamp(m.y, -1.57, 1.57);\n    f = vec3(sin(m.x) * cos(m.y), sin(m.y), cos(m.x) * cos(m.y));\n    return cameraMatrix(f);\n}\n\nvec3 viewray(vec2 q) // perspective\n{\n    return normalize(vec3(q, 2.));\n}\n\n\n// can't actually use it in Common, but can be defined here\n#define option(n) (texelFetch(iChannel2, ivec2(n,2), 0).x < .5)\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy;\n    float ta = iTime * .1;\n    vec2 q = (p+p)/R.y - vec2(R.x/R.y,1.);\n    mat3 M = mouselook(iMouse/R.y);\n\tvec3 V = viewray(q);\n    // carefully tuned to appear in the gap between trees in the example cubemap\n    vec3 L = normalize(vec3(-.75,.16,.71)) * M; // in view space\n    //L = normalize(vec3(cos(ta), sin(ta) * .1, 2.));\n    int method = bokehMethod(iTime);\n    c.rgb = vec3(1.12,.96, .92) * 2.5 * LensFlares(V, L, method);\n    // chromatic shift in uv, 3 spectral samples, offset based on light vs. fwd\n    vec2 s = cross(V, L).xy; // something based on angle of V vs. L\n    // careful or it'll do very weird things near the light source!\n    if (dot(s,s) > 1e-9) s = normalize(s) * 7.;\n    vec2 s1 = vec2(-s.y,s.x) - .5*s;\n    vec2 s2 = vec2(s.y,-s.x) - .5*s;\n    vec3 old;\n    if (option(67)) { // C for chroma\n\t    old.r += dot(texelFetch(iChannel0, ivec2(p + s ), 0).rgb, .99*vec3(.9,.1,.1));\n    \told.g += dot(texelFetch(iChannel0, ivec2(p + s1), 0).rgb, .96*vec3(.1,.9,.1));\n    \told.b += dot(texelFetch(iChannel0, ivec2(p + s2), 0).rgb, .92*vec3(.1,.1,.9));\n    \told *= 1.02;\n    }\n    else\n        old.rgb = texelFetch(iChannel0, ivec2(p    ), 0).rgb * 1.04;        \n    if (option(84)) // T for twinkling\n\t    old *= mix(.98,1.,sin(iTime*2.)); // twinkle blinkle\n    old = mix(vec3(.01,.0,.0), old, exp2(-.5*iTimeDelta)); // fade to black/red - TODO depending on F dot L?\n    // HACK retina burn, feedback, fake motion blur, whatever; tuned fast\n    c.rgb = mix(c.rgb, old, exp2(-15.5*iTimeDelta));\n    if (option(77)) // M for mouse\n\tif (iMouse.z >= 0.) { // feed in mouse as rgb dots\n        c.r = min(1., c.r + (distance(iMouse.xy, p + vec2(0.,-5.)) < R.y*.005 ? .1 : 0.));\n        c.g = min(1., c.g + (distance(iMouse.xy, p + vec2( 5.,3.)) < R.y*.005 ? .1 : 0.));\n        c.b = min(1., c.b + (distance(iMouse.xy, p + vec2(-5.,3.)) < R.y*.005 ? .1 : 0.));\n    }\n    c.rgb = clamp(c.rgb, 0., 1.); // fp32 feedback buffer would otherwise let nans persist if they somehow appear\n    c.a = 1.;\n}\n\n    //pow(max(dot(V, L), 0.), 4.) // HACK not same shape as other bokeh\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}