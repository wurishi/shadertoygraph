{"ver":"0.1","info":{"id":"MXyGDR","date":"1717498765","viewed":1182,"name":"three bodies simulation in 2D","username":"segolim","description":"simulating 3 equal masses under Newtonian gravity (verlet integration) in 2D, where the system is typically open.\nslide to adjust initial velocity then click the green button.\nproject for ICP course","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["mechanics","simulation","orbit","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float triangle(vec2 uv, vec2 pos, float size) {\n    uv -= pos;\n    uv.x += size * 0.5;\n    float d = max(abs(uv.y) * 1.1320508 + uv.x * 0.5, -uv.x);\n    return 1.0 - smoothstep(size, size + 0.02, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float start_value = texture(iChannel0, vec2(0.75, 0.25)).x;\n    // initialize values\n    vec4 positions1;\n    vec4 positions2;\n    vec4 positions3;\n    vec2 satel_pos1;\n    vec2 satel_pos2;\n    vec2 satel_pos3;\n    vec2 satel_vel1;\n    vec2 satel_after_im1;\n    vec2 satel_after_im2;   \n    vec2 satel_after_im3;    \n    // Get satellite positions from the specific positions in the combined buffer\n    if (start_value != 0.){\n        positions1 = texture(iChannel0, vec2(0.25, 0.25));\n        positions2 = texture(iChannel0, vec2(0.75, 0.75));\n        positions3 = texture(iChannel0, vec2(0.25,0.75));\n        satel_pos1 = positions1.xy;\n        satel_pos2 = positions2.xy;\n        satel_pos3 = positions3.xy;\n        satel_after_im1 = positions1.zw;\n        satel_after_im2 = positions2.zw;\n        satel_after_im3 = positions3.zw;        \n     }else{\n        satel_pos1 = Satel_init1;\n        satel_pos2 = Satel_init2;\n        satel_pos3 = Satel_init3;\n        satel_vel1 = texture(iChannel1, vec2(0.25, 0.71)).xy;\n        }\n    // add ui\n    float knob1_height = texture(iChannel1, vec2(0.75, 0.25)).x;\n    float knob2_height = texture(iChannel1, vec2(0.75, 0.75)).x;\n    float start_button = Circle(uv, vec2 (0.7,-0.40), 0.08, 0.01);\n    float outline = Circle(uv, vec2 (0.7,-0.40), 0.09, 0.001) - Circle(uv, vec2 (0.7,-0.40), 0.08, 0.001);\n    float slider1 = segment(uv, vec2(-0.8,0.2), vec2(-0.8,-0.2), 0.02);\n    float slider2 = segment(uv, vec2(-0.65,0.2), vec2(-0.65,-0.2), 0.02);\n    float knob1 = rectangle(uv, vec2(-0.8, knob1_height), 0.08, 0.03);\n    float knob2 = rectangle(uv, vec2(-0.65, knob2_height), 0.08, 0.03);\n    float vel_line1 = segment(uv, satel_pos1, satel_pos1 + satel_vel1, 0.01);\n    \n    vec2 arrowhead_pos = satel_pos1 + satel_vel1;\n    vec2 arrowhead_dir = normalize(satel_vel1);\n    float arrowhead_size = 0.03;\n    vec2 arrowhead_perp = vec2(-arrowhead_dir.y, arrowhead_dir.x);\n    vec2 arrowhead_left = arrowhead_pos - arrowhead_dir * arrowhead_size + arrowhead_perp * arrowhead_size;\n    vec2 arrowhead_right = arrowhead_pos - arrowhead_dir * arrowhead_size - arrowhead_perp * arrowhead_size;\n\n    float arrowhead_left_seg = segment(uv, arrowhead_pos, arrowhead_left, 0.01);\n    float arrowhead_right_seg = segment(uv, arrowhead_pos, arrowhead_right, 0.01);\n\n    float headlineV1_1 = segment(uv, vec2(-0.8, 0.25), vec2(-0.775, 0.31), 0.008); // V left part\n    float headlineV1_2 = segment(uv, vec2(-0.8, 0.25), vec2(-0.825, 0.31), 0.008); // V right part\n    \n    \n        // Theta symbol (Î¸)\n    float thetaCircle = Circle(uv, vec2(-0.65, 0.29), 0.0362, 0.0065) - Circle(uv, vec2(-0.65, 0.29), 0.026, 0.003); // outer circle\n \n    float thetaLine = segment(uv, vec2(-0.66, 0.29), vec2(-0.64, 0.29), 0.005); // Horizontal line\n    \n    \n    if (max(max(abs(satel_pos1.x), abs(satel_pos2.x)), abs(satel_pos3.x)) > 0.5 || \n    max(max(abs(satel_pos1.y), abs(satel_pos2.y)), abs(satel_pos3.y)) > 0.5) // add screen scaling\n    {\n        uv = 1.*uv * max(max(max(2. * abs(satel_pos1.x), 2. * abs(satel_pos2.x)), 2. * abs(satel_pos3.x)),\n                        max(max(abs(2.*satel_pos1.y), abs(2.*satel_pos2.y)), abs(2.*satel_pos3.y)));\n    } \n    else {\n    }\n    // Render Earth and satellite\n    float satellite1 = Circle(uv, satel_pos1, 0.03, 0.01);\n    float satellite2 = Circle(uv, satel_pos2, 0.03, 0.01);\n    float satellite3 = Circle(uv, satel_pos3, 0.03, 0.01);\n    float afterimage1 = Circle(uv, satel_after_im1, 0.03, 0.01);\n    float afterimage2 = Circle(uv, satel_after_im2, 0.03, 0.01);\n    float afterimage3 = Circle(uv, satel_after_im3, 0.03, 0.01);\n    \n    // Adjust sky color to be much more blue\n    vec3 skyTexture = texture(iChannel2, uv).rgb;\n    vec3 skyColor = vec3(skyTexture.r * 0.3, skyTexture.g * 0.5, skyTexture.b * 0.8);\n\n    // Adjust Earth texture to be blue and green\n    vec3 earthTexture = texture(iChannel3, uv * 0.5 + 0.5).rgb;\n    vec3 adjustedEarthTexture = vec3(earthTexture.r * 0.6, earthTexture.g * 1.5, earthTexture.b * 2.0);\n\n    // Adjust satellite textures\n    vec3 satellite1Texture = texture(iChannel3, uv * 0.5 + 0.5).rgb;\n    vec3 adjustedS1Texture = vec3(earthTexture.r * 0.8, earthTexture.g * 2.1, earthTexture.b * 1.0);\n    vec3 satellite2Texture = texture(iChannel3, uv * 0.5 + 0.5).rgb;\n    vec3 adjustedS2Texture = vec3(earthTexture.r * 1.6, earthTexture.g * 0.5, earthTexture.b * 1.3);\n    // Combine colors for Earth and satellite\n    vec3 after_im_render = afterimage3 * adjustedEarthTexture + afterimage1 * (adjustedS1Texture) \n    + afterimage2 * adjustedS2Texture;\n    vec3 satel_render =satellite3 * adjustedEarthTexture + satellite1 * (adjustedS1Texture) \n    + satellite2 * adjustedS2Texture;\n    vec3 ui_render = (start_button * vec3(0.2, 0.7, 0.2) + outline * vec3(1., 1., 1.)) + (slider1 + slider2) * vec3(1.) +\n    (knob2 + knob1) * vec3(1.) + vel_line1 * vec3(1.) + arrowhead_left_seg * vec3(1.) + arrowhead_right_seg * vec3(1.) +\n    triangle(uv, vec2(0.7, -0.40), 0.02) * vec3(1.) + headlineV1_1 * vec3(1.) + headlineV1_2 * vec3(1.) +\n    thetaCircle * vec3(1.) + thetaLine * vec3(1.);\n    vec3 temp_ui_render = ui_render*(1.-start_value);\n    vec3 color = skyColor + satel_render + temp_ui_render;\n    fragColor = vec4(color, 1.0)+0.5*vec4(after_im_render,1.);\n//     fragColor = vec4(texture(iChannel0,vec2 (0.75,0.25)));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec2 Satel_init1 = 0.5*vec2(0.9700436, -0.24308753);\nconst vec2 Satel_init2 = -0.5*vec2(0.9700436,-0.24308753);\nconst vec2 Satel_init3 = vec2(0.0, 0.0);\nconst vec2 Satel_initv1 = 0.2*vec2(1.,0.);\nconst vec2 Satel_initv2 = 5.*vec2(0.2, 0.7);\nconst vec2 Satel_initv3 = -10.*vec2(0.27,0.3215);\nconst float Satel3_G_const = 11.7; \nconst float Satel1_G_const = 11.7;\nconst float Satel2_G_const = 11.7;\nconst float dt = 0.002;\nconst float pi = 3.14159;\n\nvec2 G_accel(vec2 Satel1_ic, vec2 Satel2_ic, vec2 Satel3_ic, float G_const2, float G_const3) {\n    vec2 r_Satel2 = Satel2_ic - Satel1_ic  ; // distance between two satellites \n    vec2 r_Satel3 = Satel3_ic - Satel1_ic; // distance between earth and satellite\n    float r_Satel2_abs = length(r_Satel2);\n    float r_Satel3_abs = length(r_Satel3);\n    if (r_Satel2_abs == 0.0) return vec2(0.0);  // Prevent division by zero\n    if (r_Satel3_abs == 0.0) return vec2(0.0);  // Prevent division by zero\n    vec2 satel2_accel = normalize(r_Satel2)* G_const2/(r_Satel2_abs*r_Satel2_abs);\n    vec2 satel3_accel = normalize(r_Satel3) * G_const3 / (r_Satel3_abs * r_Satel3_abs);\n    return satel2_accel + satel3_accel; \n    }\n\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv - p);\n    return smoothstep(r, r - blur, d);\n}\n\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.5*r, d);\n}\nfloat rectangle(vec2 uv, vec2 pos, float width, float height) {\n\tfloat t = 0.0;\n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n\t\t&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n\t\tt = 1.0;\n\t}\n\treturn t;\n}\n\n\n// Function to draw an ellipse\nfloat ellipse(vec2 uv, vec2 center, float rx, float ry, float thickness) {\n    vec2 p = uv - center;\n    float ellipseShape = length(vec2(p.x / rx, p.y / ry)) - 1.0;\n    return smoothstep(0.0, thickness, ellipseShape);\n}\n\n\n        \n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 satel_pos1, satel_pos2, satel_pos3;\n    vec2 prev_satel_pos1, prev_satel_pos2, prev_satel_pos3;\n    vec2 vel1, vel2, vel3;\n    float continue_value=texture(iChannel0, vec2(0.75, 0.25)).x;\n    if (texture(iChannel1, vec2(0.25, 0.25)).x == 0.5 && texture(iChannel0, vec2(0.75, 0.25)).x != 1.0) {\n        // Initial position and velocity setup for both satellites\n        prev_satel_pos1 = Satel_init1;  // Initial position for satellite 1\n        prev_satel_pos2 = Satel_init2;  // Initial position for satellite 2\n        prev_satel_pos3 = Satel_init3;  // Initial position for satellite 2\n\n        vec2 vel1 = 20.*texture(iChannel1, vec2(0.25, 0.71)).xy;\n        vec2 vel2 = Satel_initv2;\n        vec2 vel3 = Satel_initv3;\n\n        vec2 accel1 = G_accel(prev_satel_pos1, prev_satel_pos2, prev_satel_pos3, Satel2_G_const, Satel3_G_const);\n        vec2 accel2 = G_accel(prev_satel_pos2, prev_satel_pos1, prev_satel_pos3, Satel1_G_const, Satel3_G_const);        \n        vec2 accel3 = G_accel(prev_satel_pos3, prev_satel_pos2, prev_satel_pos1, Satel2_G_const, Satel1_G_const);\n\n        satel_pos1 = prev_satel_pos1 + vel1 * dt + 0.5 * accel1 * dt * dt;\n        satel_pos2 = prev_satel_pos2 + vel2 * dt + 0.5 * accel2 * dt * dt;\n        satel_pos3 = prev_satel_pos3 + vel3 * dt + 0.5 * accel3 * dt * dt;\n        continue_value = 1.;\n    } else if (float(texture(iChannel0, vec2(0.75, 0.25)).x) == 1.) {\n        // Verlet integration step for both satellites\n        vec4 last_state1 = texture(iChannel0, vec2(0.25, 0.25)); // Using a specific position in the buffer\n        vec4 last_state2 = texture(iChannel0, vec2(0.75, 0.75)); // Using a different specific position in the buffer\n        vec4 last_state3 = texture(iChannel0, vec2(0.25, 0.75));\n\n        vec2 current_pos1 = last_state1.xy;\n        vec2 prev_pos1 = last_state1.zw;\n\n        vec2 current_pos2 = last_state2.xy;\n        vec2 prev_pos2 = last_state2.zw;\n       \n        vec2 current_pos3 = last_state3.xy;\n        vec2 prev_pos3 = last_state3.zw;      \n\n        vec2 accel1 = G_accel(current_pos1, current_pos2, current_pos3, Satel2_G_const, Satel3_G_const);\n        vec2 accel2 = G_accel(current_pos2, current_pos1, current_pos3, Satel1_G_const, Satel3_G_const);\n        vec2 accel3 = G_accel(current_pos3, current_pos2, current_pos1, Satel2_G_const, Satel1_G_const);       \n\n        satel_pos1 = 2.0 * current_pos1 - prev_pos1 + accel1 * dt * dt;\n        satel_pos2 = 2.0 * current_pos2 - prev_pos2 + accel2 * dt * dt;\n        satel_pos3 = 2.0 * current_pos3 - prev_pos3 + accel3 * dt * dt;\n        prev_satel_pos1 = current_pos1;\n        prev_satel_pos2 = current_pos2;\n        prev_satel_pos3 = current_pos3;\n    }\n\n    // Store the satellite positions and previous positions in specific positions in the buffer\n    if (fragCoord.x < 0.5 * iResolution.x && fragCoord.y < 0.5 * iResolution.y) {\n        fragColor = vec4(satel_pos1, prev_satel_pos1);\n    } else if (fragCoord.x > 0.5 * iResolution.x && fragCoord.y > 0.5 * iResolution.y) {\n        fragColor = vec4(satel_pos2, prev_satel_pos2);\n    } else if (fragCoord.x < 0.5 * iResolution.x && fragCoord.y > 0.5 * iResolution.y) {\n        fragColor = vec4(satel_pos3, prev_satel_pos3);        \n    } else {\n        fragColor = vec4(continue_value);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy; \n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // add mouse\n    float start_value = 0.0;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec4 m = iMouse / iResolution.x;\n    \n    // add sliders\n    float knob1_height = 0.0;\n    float knob2_height = 0.0;\n\n    if (texture(iChannel0, vec2(0.75, 0.25)).x == 1.0) {\n        start_value = 1.0;\n    }\n    else if (length(mouse - vec2(0.9, 0.1)) < 0.07 && texture(iChannel0, vec2(0.75, 0.25)).x != 1.0 && ( m.z>0.0)) {\n        start_value = 0.5;\n    }\n\n    if (mouse.x > 0.02 && mouse.x < 0.08) {\n        knob1_height = min(max(mouse.y - 0.5, -0.2), 0.2);\n    }\n    else if (texture(iChannel1, vec2(0.75, 0.25)).x != 0.0) {\n        knob1_height = texture(iChannel1, vec2(0.75, 0.25)).x;\n    }\n\n    if (mouse.x > 0.11 && mouse.x < 0.17) {\n        knob2_height = min(max(mouse.y - 0.5, -0.2), 0.2);\n    }\n    else if (texture(iChannel1, vec2(0.75, 0.75)).x != 0.0) {\n        knob2_height = texture(iChannel1, vec2(0.75, 0.75)).x;\n    }\n\n    vec2 starting_pos1 = Satel_init1;\n    vec2 starting_pos2 = Satel_init2;\n    vec2 starting_pos3 = Satel_init3;\n    vec2 starting_vel1 = Satel_initv1;\n    vec2 starting_vel2 = Satel_initv2;\n    vec2 starting_vel3 = Satel_initv3;\n\n    if (knob2_height != 0.0 || knob1_height != 0.0) {\n        starting_vel1 = vec2((knob1_height+0.2) * cos(2.*pi * knob2_height / 0.4), (knob1_height+0.2) * sin(2.* pi * knob2_height / 0.4));\n    }\n    \n    if (fragCoord.x < 0.5 * iResolution.x && fragCoord.y < 0.5 * iResolution.y) {\n        fragColor = vec4(start_value);\n    } else if (fragCoord.x > 0.5 * iResolution.x && fragCoord.y < 0.5 * iResolution.y) {\n        fragColor = vec4(knob1_height);\n    } else if (fragCoord.x > 0.5 * iResolution.x && fragCoord.y > 0.5 * iResolution.y) {\n        fragColor = vec4(knob2_height);\n    } else if (fragCoord.x < 0.5 * iResolution.x && fragCoord.y > 0.5 * iResolution.y) {\n        fragColor.xy = starting_vel1;\n        fragColor.zw = vec2(0.0, 0.0);\n    } else {\n        fragColor = vec4(0.0); \n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}