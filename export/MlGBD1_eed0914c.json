{"ver":"0.1","info":{"id":"MlGBD1","date":"1542476572","viewed":773,"name":"eroded volcano","username":"DiogoCosta","description":"Fork of https://www.shadertoy.com/view/XsKGWG\nThis is my first ray march and I worked from first principles, so it's probably terrible and inefficient code!\nJust thought I'd publish the result of stb's algorithm since it works really well here.","likes":22,"published":1,"flags":48,"usePreview":1,"tags":["raymarch","simulation","water","landscape","map","25d","bump","height","snow","mountain","land","volcano","filling","erosion","mount"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define t2D(x, y) texture(iChannel0, fract(uv-vec2(x, y)/res))\n\n\nfloat terrain(vec2 p){\n    float temp=10.;\n    if(abs(p.x)>5. || abs(p.y)>5.) return 0.;\n    return texture(iChannel0, p/10. + vec2(0.5,0.5)).x*2. - 1.2;\n}\n\nfloat water(vec2 p){\n    float temp=10.;\n    if(abs(p.x)>5. || abs(p.y)>5.) return 0.;\n    return texture(iChannel0, p/10. + vec2(0.5,0.5)).y;\n}\n\nvec3 calculate_normal(vec3 p)\n{    \n    float height_mod = 1.;\n    float prec = 0.01;\n    float xp = terrain(p.xz+vec2(prec,0.))*height_mod;\n    float xm = terrain(p.xz-vec2(prec,0.))*height_mod;\n    \n    float zp = terrain(p.xz+vec2(0.,prec))*height_mod;\n    float zm = terrain(p.xz-vec2(0.,prec))*height_mod;\n    \n    //vec3 dx = vec3(p.xz+vec2(0.001, 0.), xp) - vec3(p.xz-vec2(0.001,0.), xm);\n    //vec3 dy = vec3(p.xz+vec2(0.,0.001), zp) - vec3(p.xz-vec2(0.,0.001), zm);\n    \n    vec3 dx = vec3(p.x+prec, xp, p.y) - vec3(p.x-prec, xm, p.y);\n    vec3 dy = vec3(p.x, zp, p.y+prec) - vec3(p.x, zm, p.y-prec);\n    \n    return cross(normalize(dx), normalize(dy));\n}\n\nbool pointTerrain(vec3 p){\n    float terrain_range = 3.;\n    if(abs(p.x)>5. || abs(p.y)>5.) return false;\n    return terrain(p.xz) >= p.y*0.5;\n}\n\nvec3 castRayTerrain2(vec3 camPos, vec3 camDir){\n    for(float i=1.; i<12.; i+=.01){\n    \tvec3 p = camPos + i*camDir;\n        \n        if (p.y <0.) break;\n        if(pointTerrain(p)){\n            vec3 col = vec3(p.xz, terrain(p.xz));\n            vec3 normal = calculate_normal(p);\n            \n            float lightDist = 9.;\n            float lightHeight = 5.;\n            vec3 light_position = vec3(lightDist*cos(-iTime), lightHeight, lightDist*sin(-iTime));\n            light_position = camPos + vec3(-5.,0.,1.);\n            \n            vec3 direction_to_light = normalize(p - light_position);\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n            \n            vec3 color=vec3(1,0,0);\n            float temp = p.y;\n            p.y/=3.5;\n            if(p.y<0.18) color = vec3(0.2,0.2 + 0.8 *p.y*p.y*30.,1)*(p.y*3.+.4);\n            else if(p.y<0.22) color = vec3(246./255.,215./255.,150./255.)*(1.-p.y)*1.5;\n            else if(p.y<0.3) color = vec3(11./255.,102./255.,35./255.);\n            else if(p.y<0.33) color = vec3(139./255.,69./255.,19./255.);\n            else color = vec3(1.);\n                \n            vec3 eye = normalize(vec3(p.x, terrain(p.xz), p.z)-camPos);\n            vec3 reflec = 2.*normal*dot(normal, direction_to_light)-direction_to_light;\n            float spec = dot(eye, reflec);\n            spec = pow(spec, 5.);\n            //spec*=0.2;\n            //spec *= water(p.xz)*300.;\n            spec=0.;\n            \n            color  = 1. * terrain(p.xz) * vec3(.8, .5, .2);\n            color = fbm(p.xz*0.2)*vec3(34./255., 139./255., 34./255.);\n            //color = mix(color, vec3(1.), 0.5*max(0.,));\n            \n            if(normal.y>-0.91) color = mix(color, vec3(139./255.,69./255.,19./255.)*0.4, -normal.y*0.8);\n            //color = mix(color, vec3(114./255., 98./255., 91./255.), terrain(p.xz)*0.9);\n            color = mix(color, vec3(130./255., 100./255., 80./255.), terrain(p.xz)*0.9);\n            \n            if(dot(normal, -vec3(0,1,0))>0.99) color = vec3(1.)*0.6;\n            if(water(p.xz)>0.0002) color = vec3(1.)*0.6;//vec3(139./255.,69./255.,19./255.)*0.4;\n            \n            \n            \n            \n            \n            //spec *= length(color)*length(color)*0.2;\n            diffuse_intensity *=2.;\n            return color*0.1 + color*diffuse_intensity + vec3(1.)*spec;\n        }\n    }\n    return vec3(1.);//vec3(.5,.8,.9);\n}\n\n\n\n\n\nfloat landMap(vec3 p) {\n    return p.z - texture(iChannel0, fract(p.xy)).r;\n}\n\nfloat waterMap(vec3 p) {\n    return p.z - (texture(iChannel0, fract(p.xy)).r+texture(iChannel0, fract(p.xy)).g);\n}\n\nfloat getProx(vec3 p, float dist) {\n    vec3 o = vec3(-dist, dist, 0.);\n    vec2 res = .01 * iResolution.xy;\n\treturn\n    \t(\n            landMap(p+o.xzz/res.xyy) + landMap(p+o.yzz/res.xyy) +\n\t\t\tlandMap(p+o.zxz/res.xyy) + landMap(p+o.zyz/res.xyy) +\n\t\t\tlandMap(p+o.zzx/res.xyy) + landMap(p+o.zzy/res.xyy)  \n\t\t) / dist;\n}\n\n/*\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord.xy / res;\n    \n    float lh = t2D(0.,  0.).r;\n    float wv = t2D(0.,  0.).g;\n    wv=0.;\n    vec3 landCol  = .65 * lh * vec3(.8, .5, .2);\n    vec3 waterCol = max(0., 1.-16.*wv) * vec3(.2, .4, .7);\n    vec3 outCol;\n    \n    vec3 lightPos = normalize(vec3(4.*(iMouse.xy/res-.5), 1.));\n    \n    vec3 p = vec3(uv, lh);\n    \n    vec3 o = vec3(-1., 1., 0.);\n    vec3 landNorm =\n        vec3(\n\t\t\tlandMap(p-o.xzz/res.xyy)-landMap(p-o.yzz/res.xyy),\n\t\t\tlandMap(p-o.zxz/res.xyy)-landMap(p-o.zyz/res.xyy),\n\t\t\tlandMap(p-o.zzx/res.xyy)-landMap(p-o.zzy/res.xyy)\n\t\t);\n    \n    vec3 waterNorm =\n        vec3(\n\t\t\twaterMap(p-o.xzz/res.xyy)-waterMap(p-o.yzz/res.xyy),\n\t\t\twaterMap(p-o.zxz/res.xyy)-waterMap(p-o.zyz/res.xyy),\n\t\t\twaterMap(p-o.zzx/res.xyy)-waterMap(p-o.zzy/res.xyy)\n\t\t);\n    \n    // cheap ao\n    landCol += .1 * getProx(p, .02);\n    landCol += .3 * getProx(p, .07);\n    \n    // add diffuse reflection to landscape\n    landCol += .45 * max(0., dot(normalize(landNorm), lightPos));\n    \n    // mix bump-mapped land and unmodified water color\n    waterCol = mix(waterCol, landCol, .5);\n    \n    // add specular reflection to water\n    vec3 ref = reflect(-lightPos, normalize(waterNorm));\n    waterCol +=  .5 * pow(max(0., dot(normalize(waterNorm), ref)), 8.);\n    \n    // mix land color with water color based on water volume\n    outCol = mix(landCol, waterCol, step(4./65535., wv));\n    \n\tfragColor = vec4(outCol, 1.);\n    //fragColor = vec4(lh, 0, 0, 1.);\n}\n*/\n\nvec3 spherePos = vec3(0,0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    uv-=vec2(0.5,0.5*iResolution.y/iResolution.x);\n    uv*=2.;\n\n    //camera stuff\n    //vec3 camPos = vec3(-2.,0.,-5.*abs(sin(iTime*0.1)));\n    vec3 camPos = vec3(0.,2.+3.*abs(sin(iTime)),-5.);\n    camPos = vec3(0.,2.,-6.);\n    float camDist = 7.;\n    float camSpeed = 0.3;\n    camPos = vec3(camDist*cos(camSpeed*iTime), 4., camDist*sin(camSpeed*iTime));\n    vec3 camDir = normalize(spherePos - camPos);\n    \n    vec3 uvDir = vec3(uv,1);\n    \n    //Getting the 3 camera vectors\n    vec3 camUp = normalize(vec3(0,1,0)-camDir*dot(camDir, vec3(0,1,0)));\n    vec3 camSide = cross(camUp, camDir);\n    \n    //Transforming it into the uv plane\n    vec3 planeCenter = camPos + camDir;\n    vec3 planePoint = planeCenter + uv.x*camSide + uv.y*camUp;\n    \n    uvDir = normalize(planePoint - camPos);\n    \n    \n    //vec3 pointDest = camPos+camDir+ uv.x*camSide*iResolution.x + uv.y*camUp*iResolution.y;\n    //vec3 pointDir = normalize(pointDest - camDir); \n\n    //vec3 col = castRayTerrain2(camPos, pointDir);\n    \n    vec3 col = castRayTerrain2(camPos, uvDir);\n    //vec3 col = castRayTerrain_mod(camPos, uvDir);\n    \n    //vec3 col = castRaySphere(camPos, camDir2);\n    //vec3 col = castRaySphere(camPos, uvDir);\n    \n    //col = calculate_normal(uv.xyy);\n    //col = vec3(fbm(uv));\n    //col = vec3(uv, fbm(vec3(uv*4., 0.)));\n    \n    //col = vec3(uv, 0.)*fbm(vec3(uv, 0.));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fbm(vec3(uv, 0.)));\n    \n    //fragColor=vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).x);\n    //fragColor = vec4(terrain(uv*10.));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 0.5+0.5*(130.0 * dot(m, g));\n}\n\nfloat snoise(float p){\n\treturn snoise(vec2(p,0.));\n}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n#define NUM_OCTAVES 16\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat turbulent(vec2 x) {\n\tfloat v = fbm(x);\n    return 1.-abs((v-0.5)*2.);\n}\n\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn (v+1.)/2.;\n}\n\nfloat turbulent(vec3 x) {\n\tfloat v = fbm(x);\n    return 1.-abs((v-0.5)*2.);\n}\n\nfloat pattern( in vec2 p )\n  {\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),\n                   fbm( p + vec2(5.2,1.3) ) );\n\n    return fbm( p + 4.0*q );\n  }\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nint radius = 1;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// hash without sine - the best choice for adding rain :)\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// multiscale noise from image\nfloat getLand(vec2 p) {\n    float f = 0.;\n    for(int i=0; i<16; i++) {\n        float pwv = pow(1.1, float(i));\n        f += .25 / pwv * texture(iChannel1, p*pwv+.1*iTime+.2+.2*float(i)).r;\n    }\n    return f;\n}\n\n#define t2D(x, y) texture(iChannel0, fract(uv-vec2(x, y)/res))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord.xy / res;\n    \n    vec4 buf[9];\n    buf[0] = t2D(0.,  0.);\n    buf[1] = t2D(1.,  0.);\n    buf[2] = t2D(-1., 0.);\n    buf[3] = t2D(0.,  1.);\n    buf[4] = t2D(0., -1.);\n    buf[5] = t2D(1.,  1.);\n    buf[6] = t2D(-1., 1.);\n    buf[7] = t2D(1., -1.);\n    buf[8] = t2D(-1.,-1.);\n    \n    float lhc = buf[0].r;  // land height (this cell)\n    float wvc = buf[0].g;  // water volume (this cell)\n    float whc = wvc + lhc; // water height (this cell)\n    \n    // land height & water volume (outputs)\n    float lh, wv;\n    \n    // first frame operations\n    if(iFrame<10 || texture(iChannel3, vec2(82.5/256., .2)).r>0.) {\n        wv = 0.;\n        \n        // texture scale\n        //vec2 ts = .125 * vec2(res.x/res.y, 1.);\n        float ts = 3000.;\n        vec2 o = vec2(-.5, .5);\n        vec2 suv = smoothstep(0., 1., uv);\n        \n        // tiled landscape\n        lh =\n            mix(\n                mix(\n                    getLand((fragCoord-o.xx*res)/ts),\n                    getLand((fragCoord-o.yx*res)/ts),\n                    suv.x\n                ),\n                mix(\n                    getLand((fragCoord-o.xy*res)/ts),\n                    getLand((fragCoord-o.yy*res)/ts),\n                    suv.x\n                ),\n                suv.y\n            );\n        float dist = distance(uv*0.5, 0.5*vec2(0.5,0.5));\n        dist=sqrt(dist);\n        dist = max(dist, .5);\n        lh = 1.-dist;\n        \n        float noise = 0.1;\n        lh = lh*(1.-noise) + noise*fbm(uv);\n        \n        dist = distance(uv*0.5, 0.5*vec2(0.5,0.5));\n        dist*=.9; //.9 ideal\n        //dist = pow(dist,2.)*2.;\n        lh=1./dist;\n        lh*=0.1;\n        lh = max(lh, 0.1);\n        lh = min(1.2, lh);\n        \n        noise = 0.35;\n        lh = lh*(1.-noise) + noise*turbulent(uv) + 0.16; //use noise=0.35\n        //lh = lh*(1.-noise) + noise*fbm(uv) + 0.16; //use noise=0.4\n        \n        if(dist < 0.07) lh-=0.2*(1.-dist/ 0.07)  ;\n        //lh=max(min(0.7, dist),0.);\n        //lh*=5.;\n        //lh = 0.5 + fbm(uv)*0.5;\n    }\n    // simulation\n    else {\n\t\tlh = buf[0].r;\n        wv = buf[0].g;\n        for(int i=1; i<9; i++) {\n            float lhi = buf[i].r;  // land height (neighboring cell)\n            float wvi = buf[i].g;  // water volume (neighboring cell)\n            float whi = wvi + lhi; // water height (neighboring cell)\n            float wslope = whi - whc; // water slope\n            float lslope = lhi - lhc; // land slope\n            \n            // normalize corner weights for slopes\n            if(i>4) {\n                wslope /= sqrt(2.);\n                lslope /= sqrt(2.);\n            }\n            \n            if(wvc>0. && wslope<0.) {\n                \n                // give water\n                wv += wslope / 9.;\n                \n                // basic erosion\n                lh += .003 * wslope;\n            }\n            \n            if(wvi>0. && wslope>0.) {\n                \n                // take water (currently less than it should, to help keep water from sticking to slopes)\n                wv += wslope / 12.;\n                \n                // basic erosion\n                lh -= .003 * wslope;\n            }\n            \n            // give & take land base on water slope (help smooth things out)\n            lh += .001 * wslope;\n            \n            // collapse steep land slopes (loss only)(helps widen gullies)\n            if(lslope < -.002-.004*hash12(uv))\n                lh += lslope / 9.;\n        }\n        \n        // add land based on water volume\n        //lh += .001 * wv;\n        \n        // 'evaporation'\n        //wv -= 1. / 65535.;\n        \n        // 'rain'\n        if(hash12(mod(uv+iTime/100., 100.))>.5)\n            wv += 4. / 65535.;\n    }\n    \n    fragColor = vec4(lh, .98*wv, 0., 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}