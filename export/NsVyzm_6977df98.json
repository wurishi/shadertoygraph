{"ver":"0.1","info":{"id":"NsVyzm","date":"1654671850","viewed":223,"name":"Gravity Waves","username":"Amirk","description":"Gravitational waves according to an approximation of general relativity. \"Drag-forces\" due to an accelerating mass-body create waves. You can choose different components with FORCE-macro. Move with mouse.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["wave","gravity","relativity"],"hasliked":0,"parentid":"fsKyzz","parentname":"Non-Newtonian forces"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FORCE force3(p.xz, retardedP1)+force3(p.xz, retardedP2)\n//#define FORCE force2(p.xz, retardedP1)+force2(p.xz, retardedP2)\n//#define FORCE force1(p.xz, retardedP1)+force1(p.xz, retardedP2)\n\n#define MAX_ITER 200.\n#define MAX_DIST 10.\n#define SURF .005\n\n#define BODY 1\n#define SURFACE -1\n\nvec3 col=vec3(0); \n\nvec2 force;\nvec2 retardedP1,retardedP2;\n\n\nvec3 getRayDir(vec2 uv, vec3 ro,vec3 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt-ro);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    vec3 i= ro+f*zoom+uv.x*r+uv.y*u;\n    \n    return normalize( i-ro);\n}\n\nfloat sdSphere(vec3 p, vec3 center, float rad){\nreturn length(p-center)-rad;\n}\n\n\nfloat sdPlane(vec3 p){\n    vec3 s= vec3(9,2.,9);\n    p.y+=s.y*.5;\n    s*=.5;\n    \n    p= abs(p)-s;\n    return length(max(p,0.))+ min(max(p.x,max(p.y,p.z)),0.);\n    \n}\n\nint getMaterial(vec3 p){\n    if(sdSphere(p, vec3(retardedP1.x,0.02,retardedP1.y), .06)<7.*SURF){\n        return BODY; //1 ;\n    }else if(sdSphere(p, vec3(retardedP2.x,0.02,retardedP2.y), .06)<7.*SURF){\n        return BODY; //-1;\n    }\n    else {\n        return SURFACE;\n    }\n       \n}\n\nfloat getDist(vec3 p){\n   \n   float dist =sdPlane(p);\n    \n   vec2 p1=getPos(p10, t);\n   vec2 p2=getPos(p20, t);\n\n   retardedP1=retardedPos(p.xz, p1, t); \n   retardedP2=retardedPos(p.xz, p2, t); \n\n    \n    if(dist<MAX_DIST){\n        //bumpmap:\n        force=FORCE;\n\n        float displacement= length(force);  //*sign(p.y);\n        dist+=displacement;\n        \n    }else\n        return MAX_DIST;\n    \n    //the mass bodies:\n    float material = float(getMaterial(p));\n    float sd1= -material* sdSphere(p, vec3(retardedP1.x,0.02,retardedP1.y), .06);\n    float sd2= -material* sdSphere(p, vec3(retardedP2.x,0.02,retardedP2.y), .06);\n\n    return min(sd2,min(sd1,dist));\n}\n\n\nvec3 getNormal(vec3 p){\n  vec2 e= vec2(.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyy),getDist(p- e.yxy),getDist(p- e.yyx));\n   \n   return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float inside){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec3 p= ro+dO*rd;\n\n      float dS=inside*getDist(p);\n      \n        //conservative stepsize closer to bodies:\n      float d1 =length(p-vec3(retardedP1.x,.02,retardedP1.y));\n      float d2 =length(p-vec3(retardedP2.x,.02,retardedP2.y)); \n\n      if(d1<.9) \n        dS*=(.1+d1);\n      else if(d2<.9) \n        dS*=(.1+d2);\n\n      dO+=dS;\n  \n      if(dO>MAX_DIST){\n          float halo= 3.*i/100.;    \n          col+=halo*halo*vec3(0.4,0.2,1);\n          break;\n          }\n      else if(dS<SURF){ \n          float iter= i+2.*dS/SURF; //smoothiteration\n          float halo= 11.*iter/MAX_ITER;    \n          col+=halo*vec3(0.4,0.2,1);\n          break;\n      }\n      i++;\n    }\n      \n      \n    \n      return dO;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 m = (iMouse.xy-.5)/iResolution.xy;\n\n    \n    //camera: \n    float zoom= 1.;//smoothstep(-1.,3.,iTime);\n\n    vec3 ro= vec3(-1.,.9,-0.);\n    ro.xz*=rot(PI/2.);\n\n\n\n    if(sign(iMouse.z)>0.){\n        ro.yz*=rot(-(m.y-.5)*PI);\n        ro.xz*=rot(-(m.x-.5)*PI);\n    }else{\n        ro.yz*=rot(sin((t*.5-.5)*PI)*.5-PI*.2);\n    }\n    \n    \n    vec3 lookAt=vec3(0,.1,0);\n    \n    vec3 rd= getRayDir(uv, ro, lookAt,zoom);\n   \n    float d= RayMarch(ro,rd,sign(ro.y));\n    \n    vec3 p=ro;\n    \n     if(d<MAX_DIST){//if we hit the object:\n       \n          p= p+ d*rd;\n          \n          //next march if we begin below surface:          \n          if(sign(ro.y)<=0.){\n             vec3 n=getNormal(p);\n\n             //float material = float(getMaterial(p));\n             d= RayMarch(p+5.*SURF*n, rd,1.);\n             p= p+ d*rd;\n             /*\n             if(getMaterial(p)==BODY){\n              col=vec3(0);\n              }\n             */ \n             \n         }\n         /*\n          else if(getMaterial(p)==BODY){\n              col=vec3(1);\n          }\n          */\n          \n    }\n    \n    fragColor = vec4(col,1.);\n}\n    \n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define t iTime*.5\n#define PI 3.14159265359\nconst float radius=0.15;\nconst float M=1.;\nconst float c=1.;\nconst float freq=2.;\n\n\nconst int iterations=20; //try 15 iterations for cool clitch :)\nvec2 p10=radius*vec2(1,0);\nvec2 p20=radius*vec2(-1,0);\n\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nvec2 getPos(vec2 p0, float time){\n    return rot(freq*time)*p0;\n}\n\n\nvec2 retardedPos(vec2 uv, vec2 p0, float time){\n    float upper =time;\n    float lower =0.;\n    float tr = time*.5;\n    int n=0;\n    vec2 retardedP=getPos(p0, tr);\n    while(n<iterations){\n        retardedP=getPos(p0, tr);\n        float dist= length(uv-retardedP);\n        if(dist/c>(time-tr)){\n            upper = tr;\n            tr=(upper+lower)*.5;\n        }else{\n            lower= tr;\n            tr=(upper +lower)*.5;\n        }if(tr<.01){\n           tr=0.;\n           break;\n        }\n        retardedP=getPos(p0, tr);\n        n++;\n    }\n    \n    return retardedP;\n}\n\n\nvec2 force1(vec2 uv, vec2 p){\n//this is the good old newtonian force:\n    vec2 separation=uv-p;\n    float dist=length(separation);\n    float scl=0.01;\n    return -scl*M*pow(dist,-2.)*normalize(separation);\n}\n\n//these are relativistic extra components:\nvec2 force2(vec2 uv, vec2 p){\n    vec2 separation=uv-p;\n    float dist=length(separation);\n    vec2 a = -freq*freq*p;\n    float scl=.05;\n    \n    return scl*4.*M/(c*c*dist)*a;;    \n}\n\nvec2 force3( vec2 uv, vec2 p){\n    vec2 separation=uv-p;\n    float dist=length(separation);\n    vec2 v = freq*rot(PI*.5)*p;\n    vec2 a = -freq*freq*p;\n    float scl=.1;\n    \n    return scl*4.*M*dot(a,separation)/(c*c*c*dist*dist)*v; // +1./(c*c*dist)*a);\n}\n\n\n","name":"Common","description":"","type":"common"}]}