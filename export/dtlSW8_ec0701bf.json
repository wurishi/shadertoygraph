{"ver":"0.1","info":{"id":"dtlSW8","date":"1674698512","viewed":100,"name":"Cool fractal coloring thingy","username":"Naitronbomb","description":"Smooth","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"dtsSWr","parentname":"Smooth Mandelbrot Naitronbomb"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float iterations = 500.0;\n\nfloat color(float x) {\n    return pow(x,0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float toggle = texelFetch( iChannel0, ivec2(32,2), 0 ).x;\n    // Normalized pixel coordinates (from -4 to 4)\n    vec2 pos = 4.0 * (iMouse.xy - iResolution.xy / 2.0)/min(iResolution.x,iResolution.y);\n    pos = vec2(pos.x,-pos.y);\n    vec2 offset = pos;\n   \n    vec2 c = 4.0 * (fragCoord - iResolution.xy / 2.0)/min(iResolution.x,iResolution.y);\n    c = vec2(c.x,-c.y);\n    vec2 c1 = c;\n    c /= pow(10.0,0.0);\n    c += offset;\n\n    vec2 z = c;\n   \n    float iter = iterations;\n    for (float i = 0.0; i < iterations; i++) {\n        z = csin(z)+csinh(vec2(0.0,sin(iTime)))+c;\n        if (cabs(z) > 100.0) {\n            iter = i;\n            break;\n        }\n    }\n    \n    if (iter != iterations) {\n        float log_zn = log(z.x*z.x+z.y*z.y)/2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        \n        iter = iter + 1.0 - nu;\n    }\n    \n    vec3 colorHSL = vec3(360.0 * color(iter/iterations), 1.0, 0.5);\n    \n    float chroma = (1.0-abs(2.0*colorHSL.z-1.0)) * colorHSL.y;\n    \n    float h1 = colorHSL.x/60.0;\n    \n    float x = chroma * (1.0 - abs(mod(h1,2.0)-1.0));\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    if (h1 < 1.0) {\n        col = vec3(chroma,x,0.0);\n    } else if (h1 < 2.0) {\n        col = vec3(x,chroma,0.0);\n    } else if (h1 < 3.0) {\n        col = vec3(0.0,chroma,x);\n    } else if (h1 < 4.0) {\n        col = vec3(0.0,x,chroma);\n    } else if (h1 < 5.0) {\n        col = vec3(x,0.0,chroma);\n    } else if (h1 < 6.0) {\n        col = vec3(chroma,0.0,x);\n    }\n    \n    vec3 m = vec3(colorHSL.z-chroma/2.0);\n\n    // Output to screen\n    fragColor = vec4(col+m,1.0);\n    \n    if (cabs(vec2(c1.x - pos.x,c1.y - pos.y)) < 0.025 && toggle > 0.0) {\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n    } else if (cabs(vec2(c1.x - pos.x,c1.y - pos.y)) < 0.04 && toggle > 0.0) {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    if (cabs(vec2(c1.x,c1.y)) < 0.02 && toggle > 0.0) {\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n    } else if (cabs(vec2(c1.x,c1.y)) < 0.035 && toggle > 0.0) {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float pi = 3.14159;\nfloat e = exp(1.0);\n\nfloat avg(float a, float b) {\n    return (a+b)/2.0;\n}\n\nfloat l(float x ,bool b) {\n    if (b) {\n        return 0.5;\n    } else {\n        return 2.0/3.14159*atan(x);\n    }\n}\n\nfloat cabs(vec2 z) {\n    return sqrt(pow(z.x,2.0)+pow(z.y,2.0));\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y,z.x);\n}\n\nvec2 cm(vec2 z1,vec2 z2) {\n    return vec2(z1.x*z2.x-z1.y*z2.y,z1.y*z2.x+z1.x*z2.y);\n}\n\nvec2 cs(vec2 z) {\n    return vec2(pow(z.x,2.0)-pow(z.y,2.0),2.0*z.x*z.y);\n}\n\nvec2 cd(vec2 z1,vec2 z2) {\n    return vec2(z1.x*z2.x+z1.y*z2.y,-z1.x*z2.y+z1.y*z2.x)/(pow(z2.x,2.0)+pow(z2.y,2.0));\n}\n\nvec2 cexp(vec2 z) {\n    return exp(z.x)*vec2(cos(z.y),sin(z.y));\n}\n\nvec2 cpow1(float n, vec2 z) {\n    return pow(n,z.x)*vec2(cos(z.y*log(n)),sin(z.y*log(n)));\n}\n\nvec2 cpow2(vec2 z, float n) {\n    return pow(cabs(z),n)*vec2(cos(n*arg(z)),sin(n*arg(z)));\n}\n\n// I hate this\nvec2 cpow(vec2 z1, vec2 z2) {\n    if (cabs(z1) > 0.0) {\n        return cexp(z2*log(cabs(z1))+cm(vec2(0,arg(z1)),z2));\n    } else if (z2.x > 0.0) {\n        return vec2(0.0,0.0);\n    } else if (z1.x == 0.0 && z1.y == 0.0 && z2.x == 0.0) {\n        return vec2(0.0/0.0,0.0/0.0);\n    }\n    return vec2(1.0/0.0,0.0);\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x)*cosh(z.y),cos(z.x)*sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x)*cosh(z.y),-sin(z.x)*sinh(z.y));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x)*cos(z.y),cosh(z.x)*sin(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n    return vec2(cosh(z.x)*cos(z.y),sinh(z.x)*sin(z.y));\n}\n\nvec2 csqrt(vec2 z) {\n    return cpow2(z,0.5);\n}\n\nvec2 cln(vec2 z) {\n    return vec2(log(cabs(z)),arg(z));\n}\n\nvec2 clog(vec2 z, float n) {\n    return cd(cln(z),cln(vec2(n,0)));\n}","name":"Common","description":"","type":"common"}]}