{"ver":"0.1","info":{"id":"stXGDB","date":"1622728578","viewed":86,"name":"Value noise 3D __","username":"Envy24","description":"value, noise, random","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","value"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* playlist: https://www.shadertoy.com/playlist/sXfSDS */\n\n/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample3DHashUI32(uint x, uint y, uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 1200u;\n    const uint enthropy1 = 4500u;\n    const uint enthropy2 = 6700u;\n    const uint enthropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = \n        z * enthropy3 * enthropy2 +\n        y * enthropy2 +\n        x;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n\nfloat valuetNoise3D(float u, float v, float w)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n    float fractW = w - floor(w);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n    w = floor(w);\n    \n    // Pseudorandom samples.\n    float sample0 = sample3DHashUI32(uint(u),       uint(v),       uint(w));\n    float sample1 = sample3DHashUI32(uint(u + 1.0), uint(v),       uint(w));\n    float sample2 = sample3DHashUI32(uint(u),       uint(v + 1.0), uint(w));\n    float sample3 = sample3DHashUI32(uint(u + 1.0), uint(v + 1.0), uint(w));\n    float sample4 = sample3DHashUI32(uint(u),       uint(v),       uint(w + 1.0));\n    float sample5 = sample3DHashUI32(uint(u + 1.0), uint(v),       uint(w + 1.0));\n    float sample6 = sample3DHashUI32(uint(u),       uint(v + 1.0), uint(w + 1.0));\n    float sample7 = sample3DHashUI32(uint(u + 1.0), uint(v + 1.0), uint(w + 1.0));\n\n    // Smoothstep.\n    float tU = fractU * fractU * (3.0 - 2.0 * fractU);\n    float tV = fractV * fractV * (3.0 - 2.0 * fractV);\n    float tW = fractW * fractW * (3.0 - 2.0 * fractW);\n\n    // Trilinear interpolation.\n    return \n        sample0 * (1.0 - tU) * (1.0 - tV) * (1.0 - tW) + \n        sample1 * tU         * (1.0 - tV) * (1.0 - tW) +\n        sample2 * (1.0 - tU) * tV         * (1.0 - tW) +\n        sample3 * tU         * tV         * (1.0 - tW) +\n        sample4 * (1.0 - tU) * (1.0 - tV) * tW + \n        sample5 * tU         * (1.0 - tV) * tW +\n        sample6 * (1.0 - tU) * tV         * tW +\n        sample7 * tU         * tV         * tW;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 6.0f;\n    \n    float _u = uv.x + iMouse.x * 0.1f;\n    float _v = uv.y + iMouse.x * 0.1f;\n    float _w = uv.x + iTime * 0.4f;\n\n    float gray = valuetNoise3D(_u, _v, _w) * 0.35f;\n    gray += valuetNoise3D(_u * 2.054f, _v * 2.354f, _w * 2.754f) * 0.125f;\n    gray += valuetNoise3D(_u * 4.554f, _v * 4.254f, _w * 4.154f) * 0.025f;\n    gray += valuetNoise3D(_u * 32.554f, _v * 32.354f, _w * 32.430f) * 0.025f;\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Image","description":"","type":"image"}]}