{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI 3.1415926359\n#define IMPACT_TIME 5.0\n#define TIME_SCALE 0.5   // Slow down the overall motion\n\nfloat hash(vec2 p) {\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(\n        mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),\n        mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),\n        f.y\n    );\n}\n\nvec3 createStarfield(vec2 uv, float time) {\n    vec3 col = vec3(0.0);\n    \n    // Basic star layer\n    for(int i = 0; i < 3; i++) {\n        float layer = float(i) * 0.5;\n        vec2 starUV = uv * (2.0 + layer) + time * (0.1 + layer * 0.1);\n        float starPattern = noise(starUV * 100.0);\n        float stars = pow(starPattern, 20.0) * (2.0 - layer);\n        col += stars * vec3(0.8 + layer * 0.2);\n    }\n    \n    // Add some color variation to larger stars\n    float largeStars = noise(uv * 60.0 + time * 0.05);\n    if(largeStars > 0.97) {\n        float starColor = noise(uv * 2345.67);\n        col += vec3(0.8 + 0.2 * sin(starColor), 0.8, 0.9) * 0.5;\n    }\n    \n    // Add subtle nebula-like effects\n    float nebula = noise(uv * 3.0 + time * 0.01);\n    vec3 nebulaColor = vec3(0.2, 0.1, 0.3) * nebula * 0.15;\n    col += nebulaColor;\n    \n    return col;\n}\n\n// Existing distance functions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b + r;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Helper function for rainbow color\nvec3 getRainbowColor(float t) {\n    vec3 c = 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.33, 0.67)));\n    return c;\n}\n\nvec3 getSpherePosition(float t) {\n    float startZ = 4.0;\n    float impactPos = 1.0;\n    \n    if(t < IMPACT_TIME) {\n        float progress = t / IMPACT_TIME;\n        // Add gentle bobbing motion\n        float bob = sin(t * 3.0) * 0.1 * (1.0 - progress);\n        vec3 currentPos = vec3(\n            sin(t) * 0.2, // Gentle sway\n            0.5 + bob,    // Height + bobbing\n            mix(startZ, impactPos, progress) // Forward motion\n        );\n        return currentPos;\n    } else {\n        float dt = t - IMPACT_TIME;\n        float rebound = exp(-dt * 3.0) * sin(dt * 10.0) * 0.2;\n        return vec3(\n            sin(dt * 2.0) * 0.1,\n            0.5 + rebound,\n            1.5 + cos(dt * 2.0) * 0.1\n        );\n    }\n}\n\n\nmat3 rotateX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotateY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotateZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 getRotationMatrix(vec3 axis, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n    float x = axis.x, y = axis.y, z = axis.z;\n    \n    return mat3(\n        t*x*x + c,   t*x*y - s*z, t*x*z + s*y,\n        t*x*y + s*z, t*y*y + c,   t*y*z - s*x,\n        t*x*z - s*y, t*y*z + s*x, t*z*z + c\n    );\n}\n\nvec3 transformFace(vec3 p, float threshold, vec3 axis, float angle) {\n    vec3 center = axis * threshold;\n    float dotProduct = dot(p, axis);\n    \n    if ((axis.x != 0.0 && abs(p.x) > abs(threshold)) ||\n        (axis.y != 0.0 && abs(p.y) > abs(threshold)) ||\n        (axis.z != 0.0 && abs(p.z) > abs(threshold))) {\n        vec3 centered = p - center * sign(dotProduct);\n        mat3 rot = getRotationMatrix(axis, angle * sign(dotProduct));\n        return centered * rot + center * sign(dotProduct);\n    }\n    return p;\n}\n\nvec3 getFallingPiecePosition(vec3 initialPos, float t) {\n    float impactTime = 5.0;\n    if(t < impactTime) return initialPos;\n    \n    float fallTime = t - impactTime;\n    \n    float rx = fract(sin(dot(initialPos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    float ry = fract(sin(dot(initialPos.yz, vec2(39.346, 23.415))) * 23421.6543);\n    float rz = fract(sin(dot(initialPos.zx, vec2(54.321, 67.890))) * 98765.4321);\n    \n    vec3 impactDir = normalize(vec3(initialPos.x * 0.5, 1.0, -1.0));\n    vec3 vel = impactDir * (3.0 + rx * 2.0);\n    \n    float gravity = -9.81;\n    vec3 pos = initialPos + vel * fallTime + vec3(0.0, 0.5 * gravity * fallTime * fallTime, 0.0);\n    \n    float ground = -1.0;\n    if(pos.y < ground) {\n        pos.y = ground;\n        float slideTime = max(0.0, fallTime - abs(initialPos.y)/abs(vel.y));\n        float slideDistance = slideTime * 0.2;\n        pos.xz += normalize(vel.xz) * slideDistance * exp(-slideTime * 2.0);\n    }\n    \n    return pos;\n}\n\nfloat map(vec3 p) {\n    float size = 0.3;\n    float gap = 0.02;\n    float threshold = (size * 2.0 + gap) * 0.55;\n    float t = mod(iTime, 12.0);\n    float d = 1e10;\n    \n    // Rainbow sphere\n    vec3 spherePos = getSpherePosition(t);\n    vec3 sphereSpaceP = p - spherePos;\n    float sphere = sdSphere(sphereSpaceP, 0.3);\n    d = min(d, sphere);\n    \n    // Check if sphere has reached impact position\n    bool hasImpact = spherePos.z <= 1.01; // Small threshold for impact\n    float explosionTime = hasImpact ? t : IMPACT_TIME;\n    \n    if(t < explosionTime) {\n        vec3 transformedP = p;\n        float moveTime = 1.0;\n        \n        if(t < moveTime) {\n            float angle = smoothstep(0.0, 1.0, t/moveTime) * PI/2.0;\n            transformedP = transformFace(transformedP, threshold, vec3(0.0, 1.0, 0.0), angle);\n        }\n        else if(t < moveTime * 2.0) {\n            float angle = smoothstep(0.0, 1.0, (t-moveTime)/moveTime) * PI/2.0;\n            transformedP = transformFace(transformedP, threshold, vec3(1.0, 0.0, 0.0), angle);\n        }\n        else if(t < moveTime * 3.0) {\n            float angle = smoothstep(0.0, 1.0, (t-moveTime*2.0)/moveTime) * PI/2.0;\n            transformedP = transformFace(transformedP, threshold, vec3(0.0, 0.0, 1.0), angle);\n        }\n        else if(t < moveTime * 4.0) {\n            float angle = smoothstep(0.0, 1.0, (t-moveTime*3.0)/moveTime) * PI/2.0;\n            transformedP = transformFace(transformedP, threshold, vec3(-1.0, 0.0, 0.0), angle);\n        }\n        \n        for(int x = -1; x <= 1; x++) {\n            for(int y = -1; y <= 1; y++) {\n                for(int z = -1; z <= 1; z++) {\n                    vec3 offset = vec3(float(x), float(y), float(z)) * (size * 2.0 + gap);\n                    vec3 q = transformedP - offset;\n                    float cube = sdRoundBox(q, vec3(size), 0.02);\n                    d = min(d, cube);\n                }\n            }\n        }\n    } else {\n        for(int x = -1; x <= 1; x++) {\n            for(int y = -1; y <= 1; y++) {\n                for(int z = -1; z <= 1; z++) {\n                    vec3 initialOffset = vec3(float(x), float(y), float(z)) * (size * 2.0 + gap);\n                    vec3 fallingPos = getFallingPiecePosition(initialOffset, t);\n                    vec3 q = p - fallingPos;\n                    \n                    float rt = t - explosionTime;\n                    q = rotateX(rt * sin(initialOffset.x)) * \n                        rotateY(rt * sin(initialOffset.y)) * \n                        rotateZ(rt * sin(initialOffset.z)) * q;\n                    \n                    float cube = sdRoundBox(q, vec3(size), 0.02);\n                    d = min(d, cube);\n                }\n            }\n        }\n    }\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy * map(p + k.xyy * h) +\n                    k.yyx * map(p + k.yyx * h) +\n                    k.yxy * map(p + k.yxy * h) +\n                    k.xxx * map(p + k.xxx * h));\n}\n\nvec3 getCubeMaterial(vec3 p, vec3 n) {\n    // Material properties\n    vec3 albedo;\n    float roughness;\n    \n    float t = mod(iTime, 12.0);\n    vec3 spherePos = getSpherePosition(t);\n    vec3 sphereSpaceP = p - spherePos;\n    \n    if(sdSphere(sphereSpaceP, 0.3) < 0.001) {\n        if(t < IMPACT_TIME) {\n            // Rainbow color for sphere before impact\n            float colorT = iTime * 0.5 + dot(normalize(sphereSpaceP), vec3(1.0)) * 0.5;\n            return getRainbowColor(colorT);\n        } else {\n            // Gray color for sphere after impact\n            return vec3(0.5);\n        }\n    }\n    \n    // Cube colors\n    vec3 absN = abs(n);\n    float maxComp = max(max(absN.x, absN.y), absN.z);\n    \n    if(t < IMPACT_TIME) {\n        // Gray color for cubes before impact\n        return vec3(0.5);\n    } else {\n        // Dynamic rainbow colors for cube pieces after impact\n        float dt = t - IMPACT_TIME;\n        float colorTime = iTime * 0.5; // Base time for color cycling\n        \n        // Use position and normal to create varied colors across pieces\n        float colorOffset = dot(p, vec3(1.0)) * 0.2;\n        \n        // Create vibrant rainbow colors\n        vec3 color1 = getRainbowColor(colorTime + colorOffset);\n        vec3 color2 = getRainbowColor(colorTime + colorOffset + 0.33);\n        vec3 color3 = getRainbowColor(colorTime + colorOffset + 0.66);\n        \n        // Assign colors based on normal direction with increased saturation\n        if(abs(absN.y - maxComp) < 0.01) {\n            albedo = n.y > 0.0 ? color1 * 1.5 : color2 * 1.5;\n        }\n        else if(abs(absN.x - maxComp) < 0.01) {\n            albedo = n.x > 0.0 ? color2 * 1.5 : color3 * 1.5;\n        }\n        else if(abs(absN.z - maxComp) < 0.01) {\n            albedo = n.z > 0.0 ? color3 * 1.5 : color1 * 1.5;\n        }\n        else {\n            albedo = getRainbowColor(colorTime * 2.0 + colorOffset) * 1.5;\n        }\n        \n        // Add some sparkle effect\n        float sparkle = pow(sin(dt * 10.0 + dot(p, vec3(1.0)) * 5.0) * 0.5 + 0.5, 2.0);\n        return albedo + vec3(sparkle * 0.3);\n    }\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float t = mod(iTime, 12.0);\n    \n    // Camera movement\n    float angle = t * 0.25;\n    float radius = 4.0;\n    float zoomProgress = smoothstep(0.0, IMPACT_TIME, t);\n    radius = mix(radius, 2.5, zoomProgress);\n    \n    // Calculate camera position\n    float heightOffset = smoothstep(0.0, IMPACT_TIME, t) * 0.5;\n    vec3 ro = vec3(\n        radius * cos(angle),\n        2.5 + heightOffset * 0.5,\n        radius * sin(angle)\n    );\n    \n    vec3 lookAt = vec3(0.0, 0.3, 0.0);\n    \n    // Post-explosion camera adjustments\n    if(t >= IMPACT_TIME) {\n        float dt = t - IMPACT_TIME;\n        ro += vec3(\n            sin(dt * 0.5) * 0.2,\n            sin(dt * 0.8) * 0.1,\n            cos(dt * 0.5) * 0.2\n        );\n        lookAt.y += sin(dt * 0.5) * 0.1;\n    }\n    \n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    vec3 rd = normalize(forward + right * uv.x + up * uv.y);\n    \n    // Start with space background instead of solid color\n    vec3 col = createStarfield(uv * 0.5 + vec2(t * 0.05), t * 0.1);\n    float t_march = 0.0;\n    \n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t_march;\n        float h = map(p);\n        if(h < 0.001) {\n            vec3 normal = getNormal(p);\n            vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n            float diff = max(dot(normal, light), 0.0);\n            \n            vec3 baseColor = getCubeMaterial(p, normal);\n            \n            // Check if we're rendering the sphere\n            vec3 spherePos = getSpherePosition(t);\n            vec3 sphereSpaceP = p - spherePos;\n            if(sdSphere(sphereSpaceP, 0.3) < 0.001) {\n                // Enhanced specular for the sphere\n                vec3 viewDir = normalize(ro - p);\n                vec3 halfDir = normalize(light + viewDir);\n                float spec = pow(max(dot(normal, halfDir), 0.0), 64.0);\n                col = baseColor * (diff * 0.6 + 0.4) + vec3(0.5) * spec;\n            } else {\n                // Original lighting for cubes\n                col = baseColor * (diff * 0.8 + 0.2);\n                vec3 ref = reflect(rd, normal);\n                float spec = pow(max(dot(ref, light), 0.0), 32.0);\n                col += vec3(0.2) * spec;\n            }\n            break;\n        }\n        t_march += h;\n        if(t_march > 20.0) break;\n    }\n    \n    // Adjust gamma correction to make stars more visible\n    fragColor = vec4(pow(col, vec3(0.4545)), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfVBDz","date":"1733971043","viewed":58,"name":"C^6","username":"a7desai","description":"Colorful Cosmic Collision Containing Complex Cube","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cube","colorful","cosmic"],"hasliked":0,"parentid":"","parentname":""}}