{"ver":"0.1","info":{"id":"WlSXR3","date":"1566577374","viewed":107,"name":"Ordered Grid","username":"grujicbr","description":"Ordered Grid\n\n3 Versions\n\nBasic - If Statements\nFloat - using float math\nInt - using int math\n\nfloat/int provided by @iq","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["orderedgrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// debug colors, why not\nconst vec3 r = vec3(1.0, 0.0, 0.0);\nconst vec3 g = vec3(0.0, 1.0, 0.0);\nconst vec3 b = vec3(0.0, 0.0, 1.0);\nconst vec3 w = vec3(1.0, 1.0, 1.0);\n\n// Hacked version for prototyping\n#define version_basic\n\n// Float version optimized\n//#define version_float\n\n// integer version optimized\n//#define version_int\n\n// 2x2 rotated grid\n// but we rotate this grid using a 4x4 or 8x8 checkerboard\n// with a 2x2 grid it seems like the red/blue align too much\n// 8x8 checkboard seem's to be better\n//#define animate \n\n#define num_colors 4\n#define num_frames 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Output to screen\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0); \n       \n    // bring back to single pixel for viewing\n    fragCoord *= 0.2 * (1.0 / 4.0) * (iResolution.y / iResolution.x);\n            \n#ifdef version_basic   \n    // compute an index across frames\n    ivec2 p = ivec2(fragCoord); \n    \n    // 8x8 checkboard, can do 4 but too repetative\n    int checkerboard_2x2 = clamp((p.x ^ p.y) & 2, 0, 1);\n    int checkerboard_4x4 = clamp((p.x ^ p.y) & 4, 0, 1);\n    \n    // chunk size\n    float chunkSize = 2.0;\n    // divide in chunks of chunkSize;\n    vec2 scaledPos = fragCoord / chunkSize;\n    ivec2 gradient = ivec2(floor(fract(scaledPos) * chunkSize));\n    \n    int index = -1;\n           \n    if(gradient.x == 0 && gradient.y == 0)\n        index = 0;\n    else if(gradient.x == 1 && gradient.y == 0)\n        index = 1;\n    else if(gradient.x == 0 && gradient.y == 1)\n        index = 3;\n    else if(gradient.x == 1 && gradient.y == 1)\n        index = 2;\n                         \n#ifdef animate  \n    // increase and mod every 8x8 frames\n    index = (index + checkerboard_2x2) % num_colors;\n    if(index == ((iFrame / 60) % num_frames))\n#endif        \n    {       \n    \tif(index == 0)\n            fragColor.rgb = r;\n        else if(index == 1)\n            fragColor.rgb = g;\n        else if(index == 2)\n            fragColor.rgb = b;\n        else if(index == 3)\n            fragColor.rgb = w;       \n    }\n       \n#endif\n        \n#ifdef version_float\n    // non-if statement version as presented by @iq\n    vec2 p = floor(fragCoord);\n    vec3 c = p.xxy + vec3(1,p.y,0);\n    fragColor.xyz = mod(c,2.0);  \n#endif\n        \n#ifdef version_int\n    // integer version as presented by @iq\n    ivec2 p = ivec2(fragCoord);    \n    ivec3 c = p.xxy + ivec3(1, p.y, 0);\n    fragColor.xyz = vec3(c&1);   \n#endif\n}","name":"Image","description":"","type":"image"}]}