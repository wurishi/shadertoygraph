{"ver":"0.1","info":{"id":"4XsfWf","date":"1729168105","viewed":61,"name":"Curious Dynamical System, Part 2","username":"vuenc","description":".","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["dynamicalsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 state = fetchDataFrom(iChannel0, fragCoord).xy;\n    fragColor = fetchDataFrom(iChannel1, state);\n    //fragColor = fetchDataFrom(iChannel1, fragCoord);\n    //fragColor = vec4(state.x/iChannelResolution[0].x, state.y/iChannelResolution[0].y, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define fetchData(addr) texelFetch(iChannel0, ivec2(addr), 0)\n\nconst float LINE_LENGTH = 0.5;\nconst float MAX_RETRIES = 100.0;\nconst float SQUARE_SIZE = 10.;\n\nvoid mainImage( out vec4 updatedState, in vec2 fragCoord )\n{\n    if (iFrame < 100) {\n        //updatedState = vec4(fragCoord.x, fragCoord.y,\n        //    atan(iChannelResolution[0].y-fragCoord.x, iChannelResolution[0].x-fragCoord.y),\n            //0.0,\n        //    0.0);\n        // float x = mod(fragCoord.x + iResolution.x/2., iResolution.x);\n        // float y = mod(fragCoord.y + iResolution.y/2., iResolution.y);\n        float x = fragCoord.x;\n        float y = fragCoord.y;\n        x = x - mod(x, SQUARE_SIZE) + SQUARE_SIZE/2. + mod(x, SQUARE_SIZE) * 5e-6;\n        y = y - mod(y, SQUARE_SIZE) + SQUARE_SIZE/2. + mod(y, SQUARE_SIZE) * 5e-6;\n        float angle = 1.0;\n        updatedState = vec4(x, y, angle, 0.0);\n        return;\n    }\n    vec4 state = fetchData(fragCoord);\n    float width = iChannelResolution[0].x;\n    float height = iChannelResolution[0].y;\n\n    float retries = 0.0;\n    bool legal = false;\n    float x, y, angle;\n\n    while (!legal && retries < MAX_RETRIES) {\n        x = state.x;\n        y = state.y;\n        angle = state.z;\n\n        float angleMagnitudeFactor = pow(x / width, 3.0);\n        float angleCcwProbability = y / height;\n        float pseudorandomNumber = mod(x + y, 1.0) - 0.5;\n        float angleMagnitude =\n            abs((pseudorandomNumber \n                    + float(abs(pseudorandomNumber) < 0.01)\n                    * sign(pseudorandomNumber) * 0.01\n                )\n                * 2.0\n                * (PI * max(0.01, angleMagnitudeFactor) * (retries * retries + 1.0))\n            ) * 8e-1;\n        float angleDirection = float(mod(x+y, 1.0) < angleCcwProbability) * 2.0 - 1.0;\n\n        angle += angleMagnitude * angleDirection;\n        x += cos(angle) * LINE_LENGTH;\n        y += sin(angle) * LINE_LENGTH;\n\n        legal = (0.0 <= x) && (x < width) && (0.0 <= y) && (y < height);\n        retries += 1.0;\n    }\n    if (legal) {\n        updatedState = vec4(x, y, angle, 1.0);\n    } else {\n        // updatedState = vec4(-1, -1, -1, -1);\n        updatedState = state;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define fetchDataFrom(buf, addr) texelFetch(buf, ivec2(addr), 0)\n\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float PI = 3.14159265358979323846264338327950288;","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float psin ( float t ) {\n    return 0.5 * (1.0 + sin(t));\n}\n\nfloat pcos ( float t ) {\n    return 0.5 * (1.0 + cos(t));\n}\nfloat npsin ( float t ) {\n    return 0.5 * (1.0 - sin(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = mod(fragCoord/iResolution.xy + 0.0, 1.0);\n    uv = fragCoord/iResolution.xy;\n    uv.y = 1. - uv.y;\n    uv -= 0.5;\n    //uv = vec2(cos(iTime/5.)*uv.x + sin(iTime/5.)*uv.y, -sin(iTime/5.)*uv.x + cos(iTime/5.)*uv.y);\n    uv.x = cos(iTime/5.)*uv.x + sin(iTime/5.)*uv.y;\n    uv.y = -sin(iTime/5.)*uv.x + cos(iTime/5.)*uv.y;\n    uv += 0.5;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //vec3 col = 0.5 + 0.5*cos(iTime+(10.0/sqrt(iTime+2.0))*uv.xyx+vec3(0,2,4));\n\n    // vec3 col = vec3(float(uv.x <= 0.5 || uv.y > 2./3.)-uv.x*0.4, float(uv.y > 2./3.)-uv.x*0.2, float(uv.x > 0.5 && uv.y < 2./3.)-uv.y*0.2);\n    vec3 col = vec3(float(uv.x <= 0.5 || uv.y > 2./3.), float(uv.y > 2./3.), float(uv.x > 0.5 && uv.y < 2./3.));\n    float t = (pow(iTime, 1.1)/15.)+uv.x*.2+uv.y*.2;\n    col = vec3(pcos(1.1*t)*col.x+psin(1.1*t)*col.y, pcos(0.8*t)*col.y+psin(0.8*t)*col.z, npsin(t)*col.x+pcos(t)*col.z);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}