{"ver":"0.1","info":{"id":"Mlfyz4","date":"1503671141","viewed":979,"name":"Lost_Astronaut","username":"duvengar","description":"Derived and inspired by iq's modelling techniques and Shane's transparency works.\nhttps://www.shadertoy.com/view/Xds3zN\nhttps://www.shadertoy.com/view/lstGRB\n","likes":56,"published":1,"flags":64,"usePreview":0,"tags":["3d","raymarching","transparency","modelling","skull"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lssSW2","filepath":"https://soundcloud.com/establishmentlabel/teaser-francesco-novara-astron-ep","previewfilepath":"https://soundcloud.com/establishmentlabel/teaser-francesco-novara-astron-ep","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Lost_Astronaut\"\n// by Julien Vergnaud @duvengar-2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ====================================================================\n// this shader is inspired by iq's \"Raymarching - Primitives's\",\n// https://www.shadertoy.com/view/Xds3zN\n// and article,\n// https://iquilezles.org/articles/distfunctions\n// and Shane's \"Transparent 3D Noise\" ,\n// https://www.shadertoy.com/view/lstGRB\n// ====================================================================\n\n\n\n#define T iTime\n#define ORANGE vec3(1.0, 0.5, 0.3)\n#define GREEN  vec3(0.0, 1., 0.5)\n#define PINK   vec3(.9, 0.3, 0.4)\n\n\n//==========================================================//\n//                 NOISE 3D\n//\n// 3D noise and fbm function by Inigo Quilez\n//==========================================================//\n\nmat3 m = mat3( .00,  .80,  .60,\n              -.80,  .36, -.48,\n              -.60, -.48,  .64 );\n\nfloat hash( float n )\n{\n    float h =  fract(sin(n) * 4121.15393);\n\n    return  h + .444;   \n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f );\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix( hash(n + 00.00), hash(n + 1.000), f.x),\n                   mix( hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n               mix(mix( hash(n + 113.0), hash(n + 114.0), f.x),\n                   mix( hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm( vec3 p )\n{\n   float f = 0.0;\n\n   f += 0.5000 * noise( p ); p = m * p * 2.1;\n   f += 0.2500 * noise( p ); p = m * p * 2.2;\n   f += 0.1250 * noise( p ); p = m * p * 2.3;\n   f += 0.0625 * noise( p );\n    \n   return f / 0.9375;\n}\n\n\n//==========================================================\n//            signed DISTANCE FIELD PRIMITIVES \n//==========================================================\n//\n// distance field primitives by Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\n//\n//-----------------------------------------------------------\n//                       SPHERE            \n//-----------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\n//-----------------------------------------------------------\n//                        BOX\n//-----------------------------------------------------------\nfloat sdBox( vec3 p, vec3 b )\n{   \n  vec3 d = abs(p) - b ;   \n  return max(min(d.x, min(d.y, d.z)), .0) + length(max(d, .0));\n}\n\n\n\n// polynomial smooth min and max ref iq's article\n// https://iquilezles.org/articles/smin\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\n\nvec3 opRot( vec3 p, float a )\n{\n    float  c = cos(a);\n    float  s = sin(a);\n    mat2   m = mat2(c,-s,s,c);   \n    return vec3(m*p.xy,p.z);\n}\n\n//==========================================================\n//          SKULL SIGNED DISTANCE FIELD \n//==========================================================\n\n\nfloat sdSkull( vec3 p, float s )\n{\n    \n    \n  // --------------------------------------------------------\n  // domain deformation on radius (s) brings some interesting\n  // results this deformation sould be applied to big shapes \n  // in order to preserve details. \n    \n  float ss = noise(p * 9.);\n  ss = mix(s,ss *.5,.1);\n  \n  \n  // sp is using symetry on z axis\n  vec3 sp = vec3(p.x, p.y, abs(p.z));\n    \n      \n  // kind of morphing effect \n // s = clamp(cos(iTime*.5), .20,.35);\n\n  float shape = sdSphere(p - vec3(.0,.05,.0), s * .95 * cos(cos(p.y*11.)* p.z * 2.3) );\n  //---------------------------------------------------------  \n  // first part external skull top\n  // --------------------------------------------------------\n    \n  // globe front \n  shape = smin(shape,  sdSphere (p - vec3(.10, 0.23, 0.00), s * .82), .09);\n    \n  // globe back \n  shape = smin(shape,  sdSphere (p - vec3(-.1, 0.24, 0.00), s * .82), .09);\n    \n  // eye brow\n  shape = smin(shape,  sdSphere (sp - vec3(.25, 0.07, 0.10), s * .36 * cos(p.y * 7.0)), .02);\n    \n  // lateral holes - symmetry\n  shape = smax(shape, -sdSphere (sp - vec3(.15, -.01, 0.31), s * .28 * cos(p.x * .59)), .02);  \n    \n  //checkbones - symmetry\n  shape = smin(shape, sdSphere(sp-vec3(.22,-.13,.18), s*.11),.09);\n  \n  // empty the skull\n  shape = max(shape, -sdSphere(p - vec3(.0,.05,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ));  \n  shape = smax(shape,  -sdSphere (p - vec3(.10, 0.23, 0.00), s * .74),.02);\n  shape = smax(shape,  -sdSphere (p - vec3(-.1, 0.24, 0.00), s * .74),.02);\n  shape = smax(shape,  -sdSphere (p - vec3(.0, 0.24, 0.00), s * .74),.02);\n  \n  // eye balls - symmetry\n  shape = smax(shape, -sdSphere(sp-vec3(.32,-.04,.140), s  * .28 * cos(p.y*10.)),.03);\n  \n  // nose\n  //-----------------------------------------------------------\n    \n  // base nose shape\n  float temp = sdSphere(p- vec3(cos(.0)*.220,-.05, sin(.0)*.3), s * .35 * cos(sin(p.y*22.)*p.z*24.));\n    \n  // substract the eyes balls ( symetrix) & skukl globe\n  temp = smax(temp, -sdSphere(sp-vec3(.32,-.04,.140), s * .35 * cos(p.y*10.)), .02); \n  temp = smax(temp, -sdSphere(p - vec3(.0,.05,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ),.02);\n  \n  // add nose shape to skull \n  shape = smin(shape,temp,.015);  \n  \n  // empty the nose\n  shape = smax(shape, - sdSphere(p- vec3(cos(.0)*.238,-.09, sin(.0)*.3), s * .3 * cos(sin(p.y*18.)*p.z*29.)),.002);\n  \n  // substract bottom\n  shape = smax(shape, -sdSphere(p- vec3(-.15,-0.97, .0), s * 2.5 ),.01);\n    \n  // I like the noise deformation on this edge with ss for the sphere radius.\n  // It give a more natural look to the skull.\n  shape = smax(shape, -sdSphere(p- vec3(-.23,-0.57, .0), abs(ss) * 1.6 ),.01);\n    \n  //--------------------------------------------------------- \n  // skull part2: UP jaws\n  // --------------------------------------------------------\n    \n  temp = smax(sdSphere(p - vec3(.13,-.26,.0), .45 * s), -sdSphere(p - vec3(.125,-.3,.0), .40 * s), .01);\n  \n  // substract back\n  temp = smax(temp,-sdSphere(p - vec3(-.2,-.1,.0), .9 * s), .03);\n  \n  // substract bottom  \n  temp = smax(temp,-sdSphere(p - vec3(.13,-.543,.0), .9 * s), .03);\n  \n  // substract up  \n  temp = max(temp, -sdSphere(p - vec3(.0,.02,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ));  \n  shape = smin(shape, temp, .07);\n    \n   \n  // Teeths - symmetry\n  //-----------------------------------------------------------\n \n  temp = sdSphere(p - vec3(.26, -.29, .018), .053 * s );\n  temp = min(temp, sdSphere(p - vec3(.26, -.29, -.018), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.25, -.29, .05), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.235, -.29, .08), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.215, -.28, .1), .05 * s ));\n  temp = max(temp, -sdSphere(p - vec3(.16, -.35, .0), .33 * s ));   \n  temp = min(temp, sdSphere(sp - vec3(.18, -.28, .115), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.14, -.28, .115), .06 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.11, -.28, .115), .06 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.08, -.28, .115), .06 * s ));\n\n   \n  shape = smin(shape, temp, .03); \n   \n  // DOWN Jaws\n  //-----------------------------------------------------------\n  \n  temp = sdSphere(p - vec3(.1,-.32,.0), .43 * s);  \n  temp = smax (temp, - sdSphere(p - vec3(.1,-.32,.0), .37 * s ),.02);  \n  temp = smax(temp, - sdSphere(p - vec3(.1,-.034,.0), 1.03 * s),.02) ;  \n  temp = smax(temp, - sdSphere(p - vec3(.0,-.4,.0), .35 * s),.02);   \n  // symmetry\n  temp = smin(temp, sdBox(sp - vec3(.04 -.03 * cos(p.y * 20.2),-.23, .27 + sin(p.y)*.27), vec3(cos(p.y*4.)*.03,.12,.014)), .13);\n  temp = max(temp, - sdSphere(sp - vec3(.0,.153,.2), .85 * s)); \n  temp = smin (temp, sdSphere(sp - vec3(.2, -.45, 0.05), .05 * s ),.07);  \n \n  shape = smin(shape, temp, .02);  \n    \n    \n  // Teeths -  symmetry\n  //--------------------------------------------------------\n \n  temp = sdSphere(p - vec3(.23, -.34, .018), .053 * s );\n  temp = min(temp, sdSphere(p - vec3(.23, -.34, -.018), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.22, -.34, .048), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.20, -.34, .078), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.17, -.35, .098), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.14, -.35, .11), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.11, -.35, .11), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.08, -.35, .11), .053 * s));\n      \n \n  shape = 1.5 * smin(shape, temp, .025);  \n    \n  \n    \n return shape ;  \n    \n // return mix(shape, sdSphere(p - vec3(.0, .0, .0), .5), cos(iTime*.1)*.5+.5);\n  //return mix(shape, sdBox(p-vec3(.0),vec3(.45)),abs(cos(iTime)));\n    \n  \n}\t\n\n//==========================================================\n//                      POSITION\n//==========================================================\n\nvec3 skullP ()\n{     \n   return vec3(.0,.0,.0);\n}\n\n//==========================================================\n//                     OBJECTS UNION\n//==========================================================\n\n/*vec2 add(vec2 d1, vec2 d2)\n{\n  \n\treturn (d1.x < d2.x) ? d1: d2 ;   \n}*/\n\n//==========================================================\n//                     SCENE MANAGER  \n//==========================================================\n\nvec2 map(vec3 pos)\n{\n    \n    vec2 scene = vec2(.5 * sdSkull(opRot(pos,T*.1) -  skullP(), .35), 39.);\n    return scene;     \n}\n\n//==========================================================\n//                     RAY CASTER  with transparency\n//\n// derived from iq's original raycaster\n// https://www.shadertoy.com/view/Xds3zN\n// and mixed with shane's transparency layers,\n// https://www.shadertoy.com/view/lstGRB\n//==========================================================\n\nfloat castRayTrans( vec3 ro, vec3 rd )    \n{\n    //int   i  = 0;                                   \n    float layers = 0.;\n    float thD = .0023; \n    float aD = 0.;\n    float col = .0;\n    float t = 1.0;\n       \n    for ( int i = 0; i <= 64; i++)\n    {    \n\t  vec2 res = map(ro + rd * t);                  // map() > response vec2(depth, id)\n      float d = res.x;\n        \n      if(layers > 20. || col > 1. || t > 3.) break; // break when object something is encountred or when outside of bounds\n\n         aD = (thD-abs(d)*13./14.)/thD;\n\n        if(aD > 0.) { \n            \n\t\t    col += aD/(1. + t*t*0.1)*0.1;\n            layers++; \n        }\n       t += max(abs(d)*.8, thD*1.6);\t\t       \n    }\n    return col;\t\t\t\t                        // return color value\n}\n\n\n//==========================================================\n//                       NORMALS \n//==========================================================\n\n\nvec3 calcNormal( vec3 pos )\n{\n    vec2 e = vec2(1., -1.) * .0005;\n    return normalize(e.xyy * map(pos + e.xyy).x + \n\t\t\t\t\t  e.yyx * map(pos + e.yyx).x + \n\t\t\t\t\t  e.yxy * map(pos + e.yxy).x + \n\t\t\t\t\t  e.xxx * map(pos + e.xxx).x );\n}\n\n//==========================================================\n//                       CAMERA \n//==========================================================\n\nmat3 setCamera(vec3 ro)\n{\n  vec3 cw = normalize(- ro);\n  vec3 cp = vec3(sin(.0), cos(.0), .0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  \n  return mat3(cu, cv, cw);\n}\n\n//==========================================================\n//                       MAIN \n//==========================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  // Pixel ratio\n  //-----------------------------------------------------------\n  // for background\n    \n  vec2 uv =(-1. + 2. * fragCoord.xy / iResolution.y)*4.;\n\n  // Pixel ratio for skull\n    \n  vec2 p = (-iResolution.xy + 2.0 * fragCoord)/iResolution.y;\n  vec2 mo = iMouse.xy/iResolution.xy;\n\n  // camera\t\n  //-----------------------------------------------------------\n  // noisy version of skull with distortion applied to camera.\n  // vec3 ro = vec3( 2. * cos(T)+ .2*cos(noise(vec3(p*15.,T))), 1., 2. * sin(T) );\n  // rotation of camera on Y axis.\n    \n  vec3 ro = vec3( 2. * cos(T), 1., 2. * sin(T) );\n  \n  // camera-to-world transformation\n    \n  mat3 ca = setCamera(ro);    \n  \n    \n  // ray direction\n  //-----------------------------------------------------------\n    \n  vec3 rd = ca * normalize(vec3(p.xy, 2.));\n\n  // render\t\n  //-----------------------------------------------------------\n    \n  vec3 tot = vec3(0.3,.30,.7)+ vec3(pow(fbm(vec3( fragCoord*.005,T*.1)),6.))*.2;  \n    \n  // cosmos\n  //-----------------------------------------------------------\n    \n  float ff = smoothstep(.7, 1.1,fbm(.1 * vec3(uv,T ) )); \n  tot *= mix(tot*.6, ORANGE, ff*.9  );\n  ff = smoothstep(.0, 0.9,fbm(.1 * vec3(uv,T ) )); \n  tot *= mix(tot*.4, PINK, ff*2.3  );\n  ff = smoothstep(.5, 0.7,fbm(.1 * vec3(uv,T ) )); \n  tot *= mix(tot*.6, GREEN, ff*.8  );\n  tot += smoothstep(.0,iResolution.y * 3.,iResolution.y-length(fragCoord));\n    \n  // skull\n  //-----------------------------------------------------------\n    \n  vec3 col = vec3(castRayTrans(ro,rd));  ;\n  tot += .9*col-.07;\n\n  // lights & starfield\n  //-----------------------------------------------------------\n    \n  vec2 n = vec2(T*.2,T*.5);\n  tot /= smoothstep(.45,1.1,fbm(vec3(n+fragCoord *.01,.1*T )));\n  tot /= smoothstep(.0,1.,fbm(vec3(  n+fragCoord *.01,.1*T )));\n  tot /= smoothstep(.55,.7,fbm(vec3(6.*uv+n*9. ,.1)));\n  \n\n  fragColor = vec4( tot, 1.0 );\n\n}","name":"Image","description":"","type":"image"}]}