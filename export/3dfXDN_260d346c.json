{"ver":"0.1","info":{"id":"3dfXDN","date":"1551271730","viewed":92,"name":"vcgi demo","username":"Zoz","description":"I used this shader in a presentation about raymarching.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["distancefieldsspheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nfloat FOG_AMOUNT = 0.2;\n\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX*rotY*rotZ;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdSphere(vec3 p) {\n \treturn length(p) - 1.;   \n}\n\nfloat opUnion(float d1, float d2) {\n \treturn min(d1, d2);   \n}\n\nfloat opIntersect(float d1, float d2) {\n \treturn max(d1, d2);   \n}\n\nfloat opComp(float d1, float d2) {\n    return max(d1, -d2);\n}\n\n/*\n// You can do alot of different effects by just modifying the scalar field\n// For example you can interpolate between two distance fields.\nfloat map(vec3 p) {\n    float a = sin(iTime) * .5 + .5;\n    float d1 = sdRoundBox(p, vec3(.5), 0.01);\n    float d2 = sdSphere(p/.7)*.7;\n    return (1. - a) * d1 + d2 * a;\n}\n*/\n\n/*\n// Something a little more complicated\nfloat map(vec3 p) {\n\tFOG_AMOUNT = .4;\n    p += vec3(.5, .5, 0.);\n    p = mod(p, 1.) - .5;\n \tfloat d1 = sdRoundBox(p, vec3(.5), 0.01);\n    float d2 = sdRoundBox(p, vec3(.4, .4, 1.), 0.03);\n    float d3 = sdRoundBox(p, vec3(.4, 1., .4), 0.03);\n    float d4 = sdRoundBox(p, vec3(1., .4, .4), 0.03);\n   \n    \n    \n    float d = opComp(d1, d2);\n    d = opComp(d, d3);\n    d = opComp(d, d4);\n    \n    return d;\n}\n*/\n\n/*\nfloat map(vec3 p) {\n \tfloat d1 = sdRoundBox(p, vec3(.5), 0.01);\n    float d2 = sdRoundBox(p, vec3(.3, .3, 1.), 0.01);\n    \n    float d = opComp(d1, d2);\n    return d;\n}\n*/\n\n\nfloat map(vec3 p) { \n    // Uncomment to get an infinite number of spheres\n    //p = mod(p, 4.) - 2.; \n\treturn length(p) - 1.;\n}\n\n\nfloat render(vec3 o, vec3 r) {\n \tfloat k = 0.;\n    for (int i = 0; i < 64; i++) {\n     \tvec3 p = o + r * k;\n        float m = map(p);\n        k += m;\n    }\n    return k;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(map(p+e.xyy) - map(p-e.xyy),\n        \t\t\t\t  map(p+e.yxy) - map(p-e.yxy),\n    \t \t\t\t      map(p+e.yyx) - map(p-e.yyx))); \n}\n\n// Taken from Inigo Quilez\nvoid applyFog( inout vec3  rgb, in float dist )\n{\n    float fogAmount = 1.0 - exp( -dist*FOG_AMOUNT );\n    vec3  fogColor  = vec3(0.);\n    rgb = mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \t//convert screen space coordinates\n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n    //convert from [0,1] to [-1, 1]\n    uv = uv * 2. - 1.;\n    //fix aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Compute rotation matrix from mouse coordinates\n    vec3 angles = vec3((iMouse.xy/iResolution.xy)*PI,0);\n    angles.xy *= vec2(2.0,1.0);\n    angles.y = clamp(angles.y,0.0,PI/2.0);\n    mat3 rotate = Rotate(angles.yzx);\n    \n    //Calculate ray direction\n    vec3 o = vec3(0., 0., -3.);\n    vec3 r = normalize(vec3(uv, 2.));\n    \n    //mouse rotation\n    o = rotate * o;\n    r = rotate * r;\n    \n    //Calculate ray intersection\n    float d = render(o, r);\n    vec3 p = o + r * d;\n    \n \n    vec3 n = normal(p);\n    //position of light source\n    vec3 lp = vec3(30., 45, -10.);\n    //reflection vector\n   \tr = reflect(normalize(p - lp), n);\n    //vector towards the camera\n    vec3 v = normalize(o - p); \n    \n    //Phong\n    float cr = 0.5;\n    float ca = 0.1;\n    float cl = 0.5;\n    float cp = 0.5;\n    float p_e = 8.;\n    float l = cr * cl * max(0., dot(n, normalize(lp - p))) +\n              cp * cl * pow(max(0., dot(r, v)), p_e) + \n              cr * ca;\n \n    vec3 col = vec3(.2, .2, .9) * l;\n    \n    applyFog(col, d);\n    // Gamma correction & Output to screen\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}