{"ver":"0.1","info":{"id":"3djczc","date":"1587075986","viewed":389,"name":"[TWITCH] Internet Cable","username":"Flopine","description":"A retake on my shader for the Quaterfinals of Revision 202! I made it on Twitch and you can see the replay here: \nhttps://www.twitch.tv/flopine/videos","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","hexagon","glow","shadershowdown","squid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define dt (iTime*0.35)\n#define hr vec2(1., sqrt(3.))\n#define PI 3.141592\n#define TAU (2.*PI)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(32.5,36.4)))*12458.5);}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float id = floor(a/per);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (id > rep*0.5) id = abs(id);\n    return id;  \n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nvec4 hgrid (vec2 uv, float detail)\n{\n    uv *= detail;\n    vec2 ga = mod(uv,hr)-hr*0.5;\n    vec2 gb = mod(uv-hr*0.5,hr)-hr*0.5;\n    vec2 guv = (dot(ga,ga)<dot(gb,gb))? ga:gb;\n    vec2 gid = uv - guv;\n    guv.y = max(abs(guv.x),dot(abs(guv),normalize(hr)));\n    return vec4(guv,gid);\n}\n\nmat2 rot( float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n\nfloat tore (vec3 p, vec2 t)\n{return length(vec2(length(p.xz)-t.x,p.y))-t.y;}\n\nfloat g1 = 0.;\nfloat lumieres (vec3 p)\n{\n    p.xz *= rot(iTime);\n    float lid = moda(p.xz, 8.);\n    p.x -= 5.;\n    p.xy *= rot(sin(iTime)*lid*2.);\n    moda(p.xy, 5.);\n    p.x -= 1.9;\n    float d =  length(p)-0.2;\n    g1 += 0.01/(0.01+d*d);\n    return d;\n}\n\nfloat g2 = 0.;\nfloat pieuvre (vec3 p)\n{\n    p.xz *= rot(dt);\n    p.y += cos(p.z+iTime)*0.6;\n    p.x -= 5.5+sin(p.z+iTime)*0.4;\n    float od = stmin(length(p)-0.6,dot(p, normalize(sign(p)))-0.5,0.2,5.);\n    p.z += 1.8;\n    p.xy *= rot(sin(p.z+iTime));\n    moda(p.xy, 5.);\n    p.x -= 0.4;\n    float c = max(length(p.xy)-(0.01+p.z*0.1),abs(p.z)-1.5);\n    float d = stmin(c,od, 0.2, 5.);\n    g2 += 0.001/(0.001+d*d);\n    return d;\n}\n\nvec3 new_p;\nfloat pieu;\nfloat SDF (vec3 p)\n{\n    p.xz *= rot(-dt);\n    new_p = p;\n    pieu = pieuvre(p);\n    return min(min(pieu,lumieres(p)),-tore(p,vec2(5.,2.)));\n}\n\nfloat lignes (vec2 uv, float detail)\n{\n    uv *= detail;\n    uv = fract(uv)-0.5;\n    return smoothstep(0.1,0.15, abs(uv.y)) * smoothstep(0.2,0.25, abs(uv.x)-0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    uv.x = mix(abs(uv.x)-0.55,uv.x, clamp(floor(sin(iTime*PI/4.))+1.,0.,1.));\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(1.,0.0,-6.),\n        p=ro,\n        rd = normalize(vec3(uv+vec2(0.9,-0.1),1.2)),\n        col = vec3(0.);\n\n    float shad,d=0.;\n    for(float i=0.; i<64.; i++)\n    {\n        d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.9+dither*0.1;\n        p +=d*rd;\n    }\n    \n    \n    float majorAngle = atan(new_p.z,new_p.x);\n    float minorAngle = atan(new_p.y, length(new_p.xz)-5.);\n    vec2 tuv = vec2(majorAngle*PI,minorAngle);\n    vec4 hg = hgrid(tuv,3.);\n    \n    float mask = smoothstep(0.1,0.12,abs((sin(length(vec2(minorAngle))-iTime))-1.));\n    vec3 hcol = vec3(smoothstep(0.3,0.43+sin(length(hg.zw)-iTime),hg.y));\n    vec3 lcol =  vec3(0.,0.8,0.)*(1.-lignes(vec2(majorAngle, minorAngle), 5.));\n    \n    if (d == pieu) col = vec3(shad);\n    else col = mix(lcol, hcol, mask);\n    \n    col *= vec3(1.-shad); \n    col += g1*vec3(0.1,0.8,0.3);\n    col += g2*vec3(0.7,0.1,0.2);\n\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}