{"ver":"0.1","info":{"id":"Wt2XR3","date":"1566635475","viewed":96,"name":"Let there be space","username":"TheRomanOne","description":"playing around with sin waves and dot products","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sin","dot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 2048.\n#define EPS 0.01\n#define PI 3.141592654\n\nfloat time;\nfloat sphere(vec3 p, vec3 center, float radius)\n{\n    return length(center - p) - radius;\n}\n\nmat2x2 rot(float ang)\n{\n    ang *= PI / 180.;\n \treturn mat2x2(cos(ang), sin(ang), -sin(ang), cos(ang));   \n}\n\nfloat terrain(vec3 p)\n{\n    p.z += time;\n    float d = 0.;\n    d += 3.*sin(time+p.z/10.)*cos(time+p.x/10.);\n    d += 7.*sin(p.x*p.z/5500.+time);\n    d += 5.*abs(cos(PI/2. + (p.x+time)/50.));\n    return d;\n}\n\nvec4 map(vec3 p)\n{\n    float h = terrain(p);\n \th *= terrain(p+cos(time+p.z*p.x/50.))/2.;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 rotCenter = vec3(0, 0, 55);\n    \n    float spRotRad = 50.;\n    vec3 spCenter = rotCenter + vec3(\n        10.*sin(5.1235*time) + 50.*sin(time)*cos(time),\n        spRotRad * abs(cos(time)),\n        10.*cos(5.1235*time)\n     );\n\n    float sp = sphere(p, spCenter, 7.5 + 7.5*cos(PI/2. + time));\n\n    \n    float d = p.y + h;\n    vec3 pp = normalize(p - spCenter);\n    \n    if(sp < d)\n    {\n        d = sp;\n        col = vec3(1, .5, .2);\n        col.xy = (rot(time*25.8520) * col.zy)*(h+3.);\n        col.zy = (rot(time*324.753) * col.xz);\n        col.zx = abs(col.zx);\n    }\n    \n    float an = dot(pp, vec3(0, -1, 0)) + .5*sin(time);\n    float rad = .4;\n    if(an > rad)\n    {\n        if(an < rad + .1)\n        {\n            if(an > rad + .09)\n                col = vec3(3.);\n            else col = vec3(0.);\n        }else\n        {\n            col = vec3(.5, 0, 0);\n            col.xy = (rot(time*15.) * col.xy)*(h+.7);\n            col.zy = (rot(time*30.) * col.yx);\n            col.zx = abs(col.zx);\n            col *= vec3(.7, 0.3, .5)*1.2;\n            col *= (an-rad)/rad;\n        }\n    }\n\n    return vec4(col, d);\n}\n\nvec4 march(vec3 ro, vec3 rd)\n{\n    \n    vec4 d=vec4(0.);\n    float dv;\n    for(int i = 0; i < 250; i++)\n    {\n        vec3 newRay = ro + dv * rd;\n        d = map(newRay);\n        if(d.w < EPS || dv > MAX_DIST)\n            break;\n        dv += d.w * .3;\n    }\n    \n    return vec4(d.xyz, dv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime/3.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0, 175, -150. + 2.*iMouse.y);\n    /*if(iMouse.w == 1.)\n        ro.xz *= rot(iMouse.x);*/\n    ro.xz *= rot(iMouse.x + time*20.);\n    ro.yz *= rot(90.*sin(time/10.));\n    ro.y = abs(ro.y)+20.;\n    vec3 lookat = vec3(0, 0, 50);\n\n    vec3 fw = normalize(lookat - ro);\n    vec3 ri = normalize(vec3(fw.z, 0, -fw.x));\n    vec3 up  = cross(fw, ri);\n    \n    vec3 rd = mat3x3(ri, up, fw) * vec3(uv, 1);\n    \n    vec4 d = march(ro, rd);\n    \n    vec3 col;\n    if(d.w < MAX_DIST)\n        col = d.xyz * .3;\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}