{"ver":"0.1","info":{"id":"fsdyRf","date":"1653878044","viewed":62,"name":"CMY","username":"LuncyTB","description":"CMY","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rgb","cmy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Copyright (c) 2022 LuncyTB. All rights reserved.\n */\n\n#define PI 3.1415926535\n#define PI2 (3.1415926535 * 2.0)\n\n#define MAX_TIMES 64.0\n#define MIN_DIS 0.01\n#define MAX_DIS 1e9\n#define e vec2(-0.01, 0.01)\n\nstruct Surface {\n    vec3 normal;\n    vec3 albedo;\n    vec3 other;\n};\n\nmat4 packM(vec3 pos, vec3 rot, vec3 scl) {\n    float cx = cos(rot.x), cy = cos(rot.y), cz = cos(rot.z);\n    float sx = sin(rot.x), sy = sin(rot.y), sz = sin(rot.z);\n    return mat4(\n        cz*cy - sx*sz*sy, cy*sz + sx*cz*sy, -cx*sy, 0.0,\n        -sz*cx, cx*cz, sx, 0.0,\n        cz*sy + cy*sx*sz, sy*sz - cy*sx*cz, cx*cy, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    ) * mat4(\n        scl.x, 0.0, 0.0, 0.0,\n        0.0, scl.y, 0.0, 0.0,\n        0.0, 0.0, scl.z, 0.0,\n        -pos.x, -pos.y, -pos.z, 1.0\n    );\n}\n\nvec3 toLocal(in vec4 pos, in mat4 m) {\n    return (m * pos).xyz;\n}\n\nfloat sdfSphere(in vec3 pos, in float r) {\n    return length(pos) - r;\n}\n\nfloat scene(in vec3 pos) {\n    float d = MAX_DIS;\n    \n    mat4 m0 = packM(\n        vec3(cos(iTime) * 0.6, sin(iTime * 0.6), sin(iTime) * 0.4), \n        vec3(iTime, iTime * 1.5, iTime * 0.5), \n        vec3(1.0));\n    d = min(d, sdfSphere(toLocal(vec4(pos, 1.0), m0), 0.5));\n    \n    return d;\n}\n\nvec3 getNormal(in vec3 pos) {\n    return normalize(\n        e.yxy * scene(pos + e.yxy) + \n        e.yyx * scene(pos + e.yyx) + \n        e.xyy * scene(pos + e.xyy) +\n        e.xxx * scene(pos + e.xxx)\n    );\n}\n\nvoid getFace(in vec3 pos, out Surface face) {\n\n    mat4 m0 = packM(\n        vec3(cos(iTime) * 0.6, sin(iTime * 0.6), sin(iTime) * 0.4), \n        vec3(iTime, iTime * 1.5, iTime * 0.5), \n        vec3(1.0));\n    vec3 pp = toLocal(vec4(pos, 1.0), m0);\n    if (sdfSphere(pp, 0.5) < MIN_DIS) {\n        float lm = 0.3;\n        face = Surface(getNormal(pos), vec3(0.9, 0.3, 0.4), vec3(0.0));\n        float r = mod(atan(pp.y, pp.x), PI2);\n        float r1 = mod(atan(pp.y, pp.x) - PI2 / 6.0, PI2);\n        float k = (pp.z + lm) / lm / 2.0;\n        float p = 1.0 - k;\n        if (abs(r - PI2 * 1.0 / 6.0) < PI / 3.0 * k) face.albedo = vec3(0.9, 0.1, 0.1);\n        if (abs(r - PI2 * 3.0 / 6.0) < PI / 3.0 * k) face.albedo = vec3(0.1, 0.9, 0.1);\n        if (abs(r - PI2 * 5.0 / 6.0) < PI / 3.0 * k) face.albedo = vec3(0.1, 0.1, 0.9);\n        if (abs(r1 - PI2 * 1.0 / 6.0) < PI / 3.0 * p) face.albedo = vec3(0.9, 0.9, 0.1);\n        if (abs(r1 - PI2 * 3.0 / 6.0) < PI / 3.0 * p) face.albedo = vec3(0.1, 0.9, 0.9);\n        if (abs(r1 - PI2 * 5.0 / 6.0) < PI / 3.0 * p) face.albedo = vec3(0.9, 0.1, 0.9);\n        if (pp.z > lm) face.albedo = vec3(0.1);\n        if (pp.z < -lm) face.albedo = vec3(0.9);\n    } else {\n        face = Surface(vec3(0.0), vec3(0.0), vec3(0.0));\n    }\n}\n\nfloat march(in vec3 ray, in vec3 str) {\n    float d = MAX_DIS;\n    float pass = 0.0;\n    \n    for (float i = 0.0; i < MAX_TIMES; i++) {\n        d = min(d, scene(str + ray * pass));\n        pass += d;\n        if (d < MIN_DIS) { return pass; }\n    }\n\n    return MAX_DIS;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dis0 =  min(iResolution.x, iResolution.y) * 0.2;\n    float dis1 =  dis0 * 1.3;\n    vec2 Ctr = iResolution.xy / 2.0;\n    vec2 B = Ctr + vec2(cos(PI * 0.5) * dis0, sin(PI * 0.5) * dis0);\n    vec2 Y = Ctr + vec2(cos(PI * 0.5 - PI2 / 3.0) * dis0, sin(PI * 0.5 - PI2 / 3.0) * dis0);\n    vec2 R = Ctr + vec2(cos(PI * 0.5 + PI2 / 3.0) * dis0, sin(PI * 0.5 + PI2 / 3.0) * dis0);\n    \n    vec3 c = vec3(1.0);\n    \n    vec3 dY = vec3(0.0, 0.0, 1.0);\n    vec3 dB = vec3(1.0, 0.0, 0.0);\n    vec3 dR = vec3(0.0, 1.0, 0.0);\n    \n    if (distance(fragCoord, R) < dis1) {\n        c -= dR;\n    }\n    \n    if (distance(fragCoord, Y) < dis1) {\n        c -= dY;\n    }\n    \n    if (distance(fragCoord, B) < dis1) {\n        c -= dB;\n    }\n\n    // Output to screen\n    fragColor = vec4(mix(c, 1.0 - c, cos(iTime) * 0.5 + 0.5), 1.0);\n    \n    vec3 light0 = normalize(vec3(-0.5, 0.5, -1.0));\n    vec3 light0Col = vec3(1.0, 0.97, 0.9) * 1.5;\n    vec3 env = vec3(0.2, 0.5, 0.6) * 0.4;\n    \n    vec2 vuv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(vec3(vuv.x, 1.0, vuv.y));\n    vec3 pos = vec3(0.5, -2.0, 0.1);\n    \n    float d = march(ray, pos);\n    if (d < MAX_DIS) {\n        Surface face;\n        getFace(pos + ray * d, face);\n        \n        vec3 col = light0Col * face.albedo * max(0.0, dot(face.normal, -light0))\n            + env * face.albedo\n            ;\n        \n        float correction = 2.2;\n        fragColor = vec4(vec3(\n            pow(col.r, 1.0 / correction), \n            pow(col.g, 1.0 / correction), \n            pow(col.b, 1.0 / correction)\n        ), 1.0);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}