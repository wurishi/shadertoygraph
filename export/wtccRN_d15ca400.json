{"ver":"0.1","info":{"id":"wtccRN","date":"1608566153","viewed":115,"name":"Planet Dawn","username":"AzazelN28","description":"Planet Dawn through glass","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["planet","dawn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float distortion = -0.0125; // sin(iTime)*0.05;\n    \n\tuv = brownConradyDistortion(uv, distortion*3.0);\n\tvec2 texuv = uv + vec2(0.0, 0.0);\n    \n    vec2 dist = vec2(-distortion, distortion);\n    \n    vec2 dx = vec2(uv.x - 0.5);\n    vec2 dy = vec2(uv.y - 0.5);\n    \n    vec2 yo = dx * dist;\n    vec2 xo = dy * dist;\n    \n    // Time varying pixel color\n    vec3 col;\n    col.r = texture(iChannel0,texuv+vec2(yo.x, xo.x)).r;\n    col.g = texture(iChannel0,texuv).g;\n    col.b = texture(iChannel0,texuv+vec2(yo.y, xo.y)).b;\n\t\n    col *= grid(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define gridify(uv) smoothstep(-0.002,0.0,uv)\n\n// slightly altered https://www.shadertoy.com/view/wtBXRz\nvec2 brownConradyDistortion(in vec2 uv, in float k1)\n{\n    uv = uv * 2.0 - 1.0;\t// brown conrady takes [-1:1]\n\n    // positive values of K1 give barrel distortion, negative give pincushion\n    float r2 = uv.x*uv.x + uv.y*uv.y;\n    uv *= 1.0 + k1 * r2;\n    \n    // tangential distortion (due to off center lens elements)\n    // is not modeled in this function, but if it was, the terms would go here\n    \n    uv = (uv * .5 + .5);\t// restore -> [0:1]\n    return uv;\n}\n\nfloat grid(in vec2 uv){\n    vec2 fw = fwidth(uv);\n\tfloat xx = smoothstep(-fw.x,fw.x,uv.x) * smoothstep(-fw.x,fw.x,1.0-uv.x);\n\tfloat xy = smoothstep(-fw.y,fw.y,uv.y) * smoothstep(-fw.y,fw.y,1.0-uv.y);\n\treturn xx*xy;\n}\n\nfloat getHeight(sampler2D channel, vec2 uv) {\n  return texture(channel, uv).r;\n}\n\nvec4 bumpFromDepth(sampler2D channel, vec2 uv) {\n  float scale = 0.0001;\n  float height = getHeight(channel, uv);\n  vec2 dxy = height - vec2(\n    getHeight(channel, uv + vec2(scale, 0.)),\n    getHeight(channel, uv + vec2(0., scale))\n  );\n    \n  return vec4(normalize(vec3(dxy * 1. / scale, 1.)), height);\n}\n\nvec4 normalMap(sampler2D channel, vec2 uv) {\n  return vec4(\n    bumpFromDepth(\n      channel,\n      uv\n    ).rgb * .5 + .5, \n    1.\n  );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 18.0;\n\n    vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 upos = fragCoord / iResolution.xy;\n    vec2 npos = 2. * upos - 1.;\n    vec2 cpos = npos * ratio;\n    \n    vec2 pcenter = vec2(0.0, -4.5);\n    vec2 dpos = pcenter - cpos;\n        \n    vec3 norm = normalize(vec3(dpos, sqrt(radius - dot(dpos, dpos))));\n    vec3 light = vec3(\n        0.,\n        -0.4,\n        -0.8\n    );\n    \n    float p_c = cos(PI * 0.5);\n    float p_s = sin(PI * 0.5);\n    \n    float dt = .1;\n    float t_c = cos(iTime * dt);    \n    float t_s = sin(iTime * dt);\n    \n    /*\n    // Rotaci贸n sobre el eje Z\n    mat3 rot = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n    );\n    */\n    \n    /*\n    // Rotaci贸n sobre el eje Y\n    mat3 rot = mat3(\n        c, 0., -s,\n        0., 1., 0.,\n        s, 0., c\n    );\n    */\n    // Rotaci贸n sobre el eje Z\n    mat3 rotZ = mat3(\n        p_c, -p_s, 0.,\n        p_s, p_c, 0.,\n        0., 0., 1.\n    );\n    \n    mat3 rotY = mat3(\n        t_c, 0., -t_s,\n        0., 1., 0.,\n        t_s, 0., t_c    \n    );\n    \n    // Rotaci贸n sobre el eje X\n    mat3 rotX = mat3(\n        1., 0., 0.,\n        0., t_c, -t_s,\n        0., t_s, t_c\n    );\n\n    vec3 tnorm = norm * rotZ * rotY;\n    vec2 tpos = vec2(\n        atan(tnorm.z, tnorm.x),\n        asin(tnorm.y)\n    );\n\n    vec4 bg = texture(iChannel2, upos);\n    vec4 color = texture(iChannel0, tpos);\n    vec4 color2 = texture(iChannel1, tpos);\n    vec4 dnorm = normalMap(iChannel0, tpos);\n\n    float d = length(dpos);\n    float a = clamp(dot(norm, light), 0.0, 1.0);\n    float b = dot(dnorm.xyz, light);\n    float f = pow(a, 2.0) * pow(d, 2.25);\n\n    float x = pow(bg.x, 3.5);\n    fragColor = vec4(x);\n    fragColor += color * color2 * a;\n    fragColor += color * color2 * b;\n    fragColor += color * vec4(0.6,0.7,0.8,1.0) * f;    \n}","name":"Buffer A","description":"","type":"buffer"}]}