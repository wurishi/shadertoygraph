{"ver":"0.1","info":{"id":"X3lcDj","date":"1726673646","viewed":26,"name":"Cheap Real Time Blur","username":"Saphirah","description":"A cheap Blur implementation using cosine interpolation. \nAnimating the blur radius looks mediocre, because we are only sampling 4 pixels.\nBut it is really fast, so perfect for blurring (static) images in real time applications.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blur","realtime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265358979323846;\nconst float blurRadius = 200.0;\n\nfloat getBlurRadius()\n{\n    return blurRadius * (1.0 - pow((sin(iTime) + 1.0) * 0.5, 3.0));\n}\n\nfloat getLOD(){\n    return (1.0 - pow(1.0 - (getBlurRadius() / blurRadius), 20.0)) * 6.0;\n}\n\nvec2 getBlurUV(vec2 fragCoord)\n{\n    return floor(fragCoord / getBlurRadius()) * getBlurRadius() / iResolution.xy;\n}\n\nvec2 getInterpolationDistance(vec2 fragCoord)\n{\n    return mod(fragCoord, getBlurRadius()) / getBlurRadius();\n}\n\nvec4 cosLerp(vec4 x, vec4 y, float a)\n{\n    float cos_a = (1.0 - cos(a * PI)) / 2.0;\n    return x * (1.0 - cos_a) + y * cos_a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 bottomLeft = textureLod(iChannel0, getBlurUV(fragCoord), getLOD());\n    vec4 bottomRight = textureLod(iChannel0, getBlurUV(fragCoord + vec2(getBlurRadius(), 0)), getLOD());\n    vec4 topLeft = textureLod(iChannel0, getBlurUV(fragCoord + vec2(0, getBlurRadius())), getLOD());\n    vec4 topRight = textureLod(iChannel0, getBlurUV(fragCoord + vec2(getBlurRadius(), getBlurRadius())), getLOD());\n\n    vec2 interpolation = getInterpolationDistance(fragCoord);\n\n    vec4 bottom = cosLerp(bottomLeft, bottomRight, interpolation.x);\n    vec4 top = cosLerp(topLeft, topRight, interpolation.x);\n    \n    fragColor = cosLerp(bottom, top, interpolation.y);\n}","name":"Image","description":"","type":"image"}]}