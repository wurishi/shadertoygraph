{"ver":"0.1","info":{"id":"tstBRB","date":"1605736735","viewed":96,"name":"Ray marchingception","username":"CHN","description":"Ray marchingception demo\n\nControls:\n\nCamera movement => arrow keys and N,M for vertical movement\nRay movement => JLKO\nRay rotation => WS for X-axis, AD for Y-axis in local coordinates of the ray\nRay marching iteration count => Z decreases, X increases\n\n","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 20;\nconst float MAX_MARCHING_STEPS_F = 20.;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 150.0;\nconst float EPSILON = 0.0001;\n\nconst float RAY_MIN_DIST = 0.0;\nconst float RAY_MAX_DIST = 50.0;\nconst float RAY_EPSILON = 0.01;\n\nfloat[30] raySafeDsts;\nvec3[30] raySafePoses;\n\nfloat sphereSDF(in vec3 samplePoint, in vec3 pos, in float radius) \n{\n    return length(samplePoint - pos) - radius;\n}\n\nfloat raySDF(in vec3 pos, in vec3 rayOrigin, in vec3 rayDir, in float len, in float thickness)\n{\n    vec3 rayEnd = rayOrigin + rayDir * len;\n    vec3 pa = pos - rayOrigin, ba = rayEnd - rayOrigin;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    \n    return length( pa - ba*h ) - thickness;\n}\n\nvec2 sdfSel(in vec2 sd1, in vec2 sd2){\n\treturn sd1.x > sd2.x ? sd2 : sd1;\n}\n\nfloat demoSceneSDF(in vec3 pos)\n{\n    float depth = MAX_DIST;\n\n    //depth = min(depth, sphereSDF(pos, vec3(6,0,0), 1.));\n    //depth = min(depth, sphereSDF(pos, vec3(10,0,-3), 1.));\n    //depth = min(depth, sphereSDF(pos, vec3(4,2.5,-1.5), 1.));\n    \n    depth = min(depth, sphereSDF(pos, vec3(7,0.5,0), 1.));\n    depth = min(depth, sphereSDF(pos, vec3(10,-3,0), .6));\n    depth = min(depth, sphereSDF(pos, vec3(4,2.5,0), 1.));\n   \t\n    return depth;\n}\n\nfloat mapDemoScene(vec3 pos, vec3 dir)\n{\n    float depth = RAY_MIN_DIST;\n    for (int i = 0; i < int(itrCount.x); i++) {\n        vec3 testPos = pos + depth * dir;\n        float dist = demoSceneSDF(testPos);\n        if (dist < RAY_EPSILON) {\n\t\t\treturn depth;\n        }\n\n        depth += dist;\n        \n        raySafeDsts[i] = dist;\n        raySafePoses[i] = testPos;\n        \n        if (depth >= RAY_MAX_DIST) {\n            return RAY_MAX_DIST;\n        }\n    }\n    return depth;\n}\n\nvec2 sceneSDF(in vec3 pos)\n{\n\tvec2 depth = vec2(MAX_DIST, 0.);\n    \n    depth.x = min(depth.x, demoSceneSDF(pos));\n    depth = sdfSel(depth, vec2(raySDF(pos, rayPos.xyz, rayDir.xyz, mapDemoScene(rayPos.xyz, rayDir.xyz), 0.05), 1.));\n    \n    return depth;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(sceneSDF(p+h.xyy).x - sceneSDF(p-h.xyy).x,\n                           sceneSDF(p+h.yxy).x - sceneSDF(p-h.yxy).x,\n                           sceneSDF(p+h.yyx).x - sceneSDF(p-h.yyx).x ) );\n}\n\nvec4 applyMaterial(in float mat, in float normDotDir)\n{\n    if(mat == 0.)\n    {\n        return vec4(1,1,1,0) * normDotDir;\n    }\n    else if(mat == 1.)\n    {\n        return vec4(1,0,0,0);\n    }\n    return vec4(0);\n}\n\nfloat map(vec3 pos, vec3 dir, out vec4 color) {\n    float depth = MIN_DIST;\n    for (float i = 0.; i < MAX_MARCHING_STEPS_F; i++) {\n        vec3 testPos = pos + depth * dir;\n        vec2 dist = sceneSDF(testPos);\n        if (dist.x < EPSILON) {\n            float normDotDir = dot(-calcNormal(testPos), dir);\n            color = applyMaterial(dist.y, normDotDir);\n\t\t\treturn depth;\n        }\n        \n        depth += dist.x;\n        \n        float ni = (i+1.) / MAX_MARCHING_STEPS_F;\n        \n        for(float j=0.;j<itrCount.x;j++)\n        {\n            float testRayDst = length(testPos - raySafePoses[int(j)]);\n            if(raySafeDsts[int(j)] > testRayDst && raySafeDsts[int(j)] < testRayDst + 0.1)\n            {\n                float j2 = j+1.;\n                color += vec4(fract(j2*24.59864309), fract(j2*42.4592083),fract(j*34.91085143),0) / ni / 10.;\n            }\n        }\n        \n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n            \nvec3 rayDirection(float fieldOfView, vec3 camRot, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    vec3 dir = vec3(xy, -z);\n    dir = apply_rot(rotationMatrix(vec3(1,0,0), camRot.x), dir);\n    dir = apply_rot(rotationMatrix(vec3(0,1,0), camRot.y), dir);\n    dir = apply_rot(rotationMatrix(vec3(0,0,1), camRot.z), dir);\n    return normalize(dir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    loadAll(iChannel0);\n    \n    vec3 camPos = vec3(pos.x, pos.y, pos.z);\n\tvec3 dir = rayDirection(60.0, rot.xyz, iResolution.xy, fragCoord);\n    vec4 color;\n    float dist = map(camPos, dir, color);\n    \n    fragColor = color;\n    //fragColor = vec4(dot(-normal, dir));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float getKeyState(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x * 0.1;\n}\n\nvoid writeDefaults()\n{\n    pos = vec4(6,-0.5,16,0);\n\trayDir = vec4(1,0,0,0);\n    itrCount.x = 8.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    loadAll(iChannel0);\n    oldMousePos = load(iChannel0, _oldMousePos);\n    \n    vec3 posDif;\n    \n    posDif.x = -getKeyState(KEY_LEFT) + getKeyState(KEY_RIGHT);\n    posDif.y = -getKeyState(KEY_N) + getKeyState(KEY_M);\n    posDif.z = -getKeyState(KEY_UP) + getKeyState(KEY_DOWN);\n    \n    posDif = apply_rot(rotationMatrix(vec3(0,1,0), rot.y) * rotationMatrix(vec3(1,0,0), rot.x), posDif);\n    \n    pos.xyz += posDif * 4.; \n    \n    float rayDirDtY = -getKeyState(KEY_A) + getKeyState(KEY_D);\n    float rayDirDtX = -getKeyState(KEY_S) + getKeyState(KEY_W);\n    \n    rayDir.xyz = apply_rot(rotationMatrix(vec3(0,1,0), rayDirDtY * 10.), rayDir.xyz);\n    rayDir.xyz = apply_rot(rotationMatrix(vec3(0,0,-1), rayDirDtX * 10.), rayDir.xyz);\n    \n    rayPos.x += -getKeyState(KEY_J) + getKeyState(KEY_L);\n    rayPos.y += -getKeyState(KEY_K) + getKeyState(KEY_O);\n    \n    itrCount.x += -getKeyState(KEY_Z) * 1.3 + getKeyState(KEY_X) * 1.3;\n    itrCount.x = max(itrCount.x, 0.);\n    if(iFrame == 0)\n    {\n        writeDefaults();\n    \toldMousePos.xyz = iMouse.xyz;\n    }\n    \n    if (oldMousePos.z > 0. && iMouse.z > 0.) {\n    \trot.xy += vec2((-iMouse.y + oldMousePos.y) * 0.05, \n                   \t\t(iMouse.x - oldMousePos.x) * 0.1);  \n    }\n    \n   \toldMousePos.xyz = iMouse.xyz;\n    \n\tfragColor = saveAll(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\n#define KEY_A 65\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_W 87\n\n#define KEY_J 74\n#define KEY_L 76\n#define KEY_K 75\n#define KEY_O 79\n\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_Z 90\n#define KEY_X 88\n\n#define varRow 0\n#define var(name, column, row) ivec2 name = ivec2(column, row)\n\nvar(_pos, 0, varRow);\nvar(_rot, 1, varRow);\nvar(_oldMousePos, 2, varRow);\nvar(_rayDir, 3, varRow);\nvar(_rayPos, 4, varRow);\nvar(_itrCount, 5, varRow);\n\nvec4 pos, rot, oldMousePos, rayDir, rayPos, itrCount;\n\nvec4 load(sampler2D buffer, in ivec2 coord)\n{\n\treturn texelFetch(buffer, coord, 0);\n}\n\nvoid loadAll(sampler2D buffer)\n{\n\tpos = load(buffer, _pos);\n    rot = load(buffer, _rot);\n    rayDir = load(buffer, _rayDir);\n    rayPos = load(buffer, _rayPos);\n    itrCount = load(buffer, _itrCount);\n}\n\nvec4 save(in ivec2 valCoord, in vec4 value, in ivec2 coord)\n{\n\tif(coord == valCoord)\n    {\n    \treturn value;\n    }\n    \n    return vec4(0.);\n}\n\nvec4 saveAll(in vec2 fCoord)\n{\n    ivec2 coord = ivec2(fCoord);\n    \n    vec4 saveVal = vec4(0.);\n      \n    saveVal += save(_pos, pos, coord);\n    saveVal += save(_rot, rot, coord);\n    saveVal += save(_oldMousePos, oldMousePos, coord);\n    saveVal += save(_rayDir, rayDir, coord);\n    saveVal += save(_rayPos, rayPos, coord);\n    saveVal += save(_itrCount, itrCount, coord);\n    \n    return saveVal;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    angle = radians(angle);\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 apply_rot(mat4 r, vec3 p)\n{\n    return (r*vec4(p, 1.)).xyz;\n}","name":"Common","description":"","type":"common"}]}