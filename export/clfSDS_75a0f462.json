{"ver":"0.1","info":{"id":"clfSDS","date":"1675437725","viewed":392,"name":"Landscape Erosion","username":"ArjunJ00","description":"Inspired by Giliam de Carpentier https://www.shadertoy.com/view/4l23Rh","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","landscape","erosion","coast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 12.\n#define MAX_STEPS 50\n#define SURF_DIST 0.01\n#define time -iTime\n\nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nvec3 rayOrigin = vec3(0, 1, 5);\n\n//  Function from IÃ±igo Quiles\n//  www.iquilezles.org/www/articles/functions/functions.htm\nfloat expStep( float x, float k, float n ){\n    return exp( -k*pow(x,n) );\n}\n\n// https://thebookofshaders.com/11/\nfloat random(in vec2 uv)\n{\n    return fract(sin(dot(uv.xy, \n                         vec2(12.9898, 78.233))) * \n                 43758.5453123);\n}\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float a = random(i + vec2(0., 0.));\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(mix(a, b, u.x), \n               mix(c, d, u.x), u.y);\n}\n\n// Giliam de Carpentier https://www.shadertoy.com/view/4l23Rh Noise function to simulate erosion\n// noise with derivatives\nvec3 noised(in vec2 p){\n\tfloat res=0.;\n    vec2 dres=vec2(0.);\n    float f=1.;\n    mat2 j=m2;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        float a=p.x+sin(2.*p.y);\n        res+=sin(a);\n        dres+=cos(a)*vec2(1.,2.*cos(2.*p.y))*j;\n        j*=m2*f;\n        \n\t}        \t\n\treturn vec3(res,dres)/3.;\n}\n\nfloat swissTurbulence(vec2 p )//from http://www.decarpentier.nl/scape-procedural-extensions\n{\n     \n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float warp = 0.15;\n    float sum = 0.;\n     float freq = 1.0, amp = 1.0;\n     vec2 dsum = vec2(0.);\n     for(int i=0; i < 7; i++)\n     {\n         vec3 n = noised((p + warp * dsum)*freq);\n         sum += amp * (1. - abs(n.x));\n         dsum += amp * n.yz * -n.x;\n         freq *= lacunarity;\n         amp *= gain * clamp(sum,0.,1.);\n    }\n    return sum/3.;\n}\n\n\n//https://thebookofshaders.com/13/\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .2;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st - iTime);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec3 sky(in vec2 p)\n{\t\n    return cos(2./vec3(1.,1.5,2.1) + 1.*swissTurbulence(p*10. - .02*time))+.3;\n}\n\n\nfloat DistanceField(vec3 origin)\n{\n    float groundDist = .6*origin.y - swissTurbulence(origin.xz) * smoothstep(-6., 8., origin.x);\n    float seaDist = origin.y - .9*fbm(origin.xz);\n    float d = min(groundDist, seaDist);\n    return d;\n}\n\nfloat RayMarch(vec3 origin, vec3 marchDirection)\n{\n    float distanceTravelled = 0.;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 sphereCastPoint = origin + distanceTravelled * marchDirection;\n        float distanceToSurface = DistanceField(sphereCastPoint);\n        distanceTravelled += distanceToSurface;\n        \n        if(distanceTravelled > MAX_DIST || distanceToSurface <= SURF_DIST)\n            break;\n    }\n    return distanceTravelled;\n}\n\nfloat TreeDistanceField(vec3 origin)\n{\n    float treeDist = .6*origin.y - swissTurbulence(origin.xz) * smoothstep(-6., 8., origin.x);\n    vec4 tree = vec4(vec3(treeDist), 1.);\n    float sphere = length(origin - tree.xyz)-tree.z;\n    return sphere;\n}\n\nfloat RayMarchTrees(vec3 origin, vec3 marchDirection)\n{\n    float distanceTravelled = 0.;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 sphereCastPoint = origin + distanceTravelled * marchDirection;\n        float distanceToTree = TreeDistanceField(sphereCastPoint);\n        distanceTravelled += distanceToTree;\n        \n        if(distanceTravelled > MAX_DIST || distanceToTree <= SURF_DIST)\n            break;\n    }\n    return distanceTravelled;\n}\n\n//Calculate Normal\nvec3 GetNormal(vec3 p)\n{\n    float dist = DistanceField(p);\n    vec2 diff = vec2(.01, 0);\n    vec3 normal = dist - vec3(\n                  DistanceField(p - diff.xyy),\n                  DistanceField(p - diff.yxy),\n                  DistanceField(p - diff.yyx));\n    \n    return normalize(normal);\n    \n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(6, 2, rayOrigin.z);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 normal = GetNormal(p);\n    \n    float diffuse = dot(normal, lightDir);\n    float shadow = RayMarch(p+normal*SURF_DIST * 2., lightDir);\n    if(shadow < length(lightPos - p)) diffuse *= .1;\n    return diffuse;\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float a = 2.;\n    float b = .5;\n    float fogAmount = (a/b) * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    //return mix(rgb, mix(sky(rayDir.xz*(.1+rayDir.y)), fogColor, fogAmount), smoothstep(-0.5, 2., distance)) * smoothstep(-0.5, 2., distance);\n    return mix( rgb, fogColor, fogAmount ) * smoothstep(-1., 2., distance);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 col = vec3(0);\n    \n    rayOrigin += vec3(0, 0, 0.3*iTime);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Raymarch ocean and mountains\n    float dist = RayMarch(rayOrigin, rayDirection);\n    \n    // Lighting and normals\n    vec3 p = rayOrigin + rayDirection * dist;\n    float diffusion = GetLight(p) +.15;\n    \n    dist /= 6.;\n    if(dist < 2.)\n    {\n        // Mountain noise\n        float r = swissTurbulence(p.xz);\n        \n        float fa = smoothstep(-2., 1., uv.x); // right smooth uv.x\n        float fb = smoothstep(0.5, -1., uv.x); // left smooth uv.x\n        \n        // Mountain & sea gradient\n        col = vec3(diffusion *r*r*fa, diffusion *r*fa, diffusion*r*.9*fa);\n        col += vec3(diffusion*r*r*fb, diffusion*r*fb, diffusion*.9*fb);\n        \n        // Mountain Tips\n        float gt = smoothstep(.1, 1.9, swissTurbulence(p.xz));\n        col += vec3(.3 *gt*gt*fa, .3 *gt*fa, .2 *gt*fa)*2.;\n        \n        // Foliage\n        float t0 = smoothstep(0., 1., textureLod(iChannel0, p.xz, 0.).x) * pow(fa, 2.);\n        float t1 = smoothstep(0., 1., textureLod(iChannel1, p.xz, 0.).x) * pow(fa, 2.);\n        float t = mix(t0, t1, 0.3);\n        if(t > 0.5)\n        {\n            float treeDist = RayMarchTrees(rayOrigin, rayDirection);\n            t += treeDist;\n            t /= 20.;\n            col += vec3(diffusion*t*r*.5, diffusion*t*.4, diffusion*t*.2)/1.5;\n        } \n        \n        col += applyFog(col, dist, rayOrigin, rayDirection)*.4 * smoothstep(-1., .25, uv.y);\n        \n    }\n    else\n        col = sky(rayDirection.xz*(.1+rayDirection.y));\n        \n    // Fog    \n    float fog = expStep(uv.y, 100., 2.)/2.5;\n    float f = smoothstep(-.5, 1., fbm(p.xy));\n    col += mix(vec3(fog, fog, fog)/1.5, sky(rayDirection.xz*(.1+rayDirection.y)), f);\n    \n   \n    \n    fragColor = vec4(col, 1.);\n    \n}","name":"Image","description":"","type":"image"}]}