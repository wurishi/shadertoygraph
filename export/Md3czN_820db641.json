{"ver":"0.1","info":{"id":"Md3czN","date":"1518048671","viewed":148,"name":"Complex Arith-ma-tick","username":"BowToes","description":"An attempt of mine to implement trigonometric and hyperbolic functions for complex numbers with likely more complex-valued functions in the future. \nThere are different variables for things like the mouse location, points in the plane, and other things.","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["math","numbers","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n===+\nA lot of algorithms have been taken from a multitude of sources, which are listed in 'common'\nI recommend comparing visual results to something like this:\n\thttp://davidbau.com/conformal/#z\n\t(there's an infobox in the top-right corner)\nAdvice on to how optimize\\reduce this code would be appreciated.\nAlso, you can use this code elsewhere if you like.\n+===\n*/\n\n#define SIN(x) (sin(x)*.5+.5)\n#define COS(x) (cos(x)*.5+.5)\n#define SIN2(x) (SIN(x+halfpi))\n#define COS2(x) (COS(x+halfpi))\n\n#define VECTIME vec2(cos(iTime+halfpi), cos(iTime))\n#define VECTIME2 vec2(cos(t+halfpi), cos(t))\n\n      //|z| is near 0\nconst vec3 c1 = vec3(1.);\n \t  //|z| => +infinity\nconst vec3 c3 = vec3(0.2);\n\t  //|z| is near 1\nconst vec3 c2 = vec3(1.)-c3;\n\n\n//===++===//\n\n//General use.\n\n//Returns radian, of range -Ï€, Ï€\nfloat arg(vec2 z) { return atan(z.y,z.x); }\n\n//Returns radian, of range 0, Ï„ (2Ï€)\nfloat arg2(vec2 z) { return arg(z)+pi; }\n\n//Returns radian, of range -1, 1\nfloat arg3(vec2 z) { return arg(z)/pi; }\n\n//Returns degree, of range 0, 360\nfloat argd(vec2 z) { return arg2(z)*rtod; }\n\n//Returns normalized value, of range 0, 1\nfloat narg(vec2 z) { return arg2(z)/twopi; }\n\nfloat mag(vec2 z)  { return length(z); }\nvec2 conj(vec2 z)  { return vec2(z.x, -z.y); }\n\n//===++===//\n//===++===//\n\n//Basic arithmetic.\n\nvec2 cmul(vec2 z, vec2 w) { return vec2(z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x); }\nvec2 cmul(vec2 z, float w) { return z*w; }\nvec2 csquare(vec2 z) { return vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y); }\nvec2 cdiv(vec2 z, vec2 w) { return vec2((z.x*w.x+z.y*w.y)/(w.x*w.x+w.y*w.y),(z.y*w.x-z.x*w.y)/(w.x*w.x+w.y*w.y)); }\nvec2 cdiv(vec2 z, float w) { return cdiv(z, vec2(w, 0.)); }\nvec2 cdiv(float z, vec2 w) { return cdiv(vec2(z, 0.), w); }\n//Reciprocal\nvec2 recip(vec2 z) { return vec2(z.x/(z.x*z.x+z.y*z.y), -z.y/(z.x*z.x+z.y*z.y)); }\n\nvec2 fromPol(float mag, float arg) { return vec2(mag*cos(arg), mag*sin(arg)); }\nvec2 fromPol(vec2 z) { return vec2(mag(z)*cos(arg(z)), mag(z)*sin(arg(z))); }\n\nvec2 csqrt(vec2 z) { return fromPol(sqrt(mag(z)), arg(z)/2.); }\n\nvec2 imMul(vec2 z) { return vec2(-z.y, z.x); }\n\n//===++===//\n//===++===//\n\n//Exponentiables\n\nvec2 cln (vec2 z) { return vec2(log(mag(z)), arg(z)); }\nvec2 cln (float z){ return cln(vec2(z, 0.)); }\nvec2 clog(vec2 b, vec2 a) { return cdiv(cln(b), cln(a)); }\nvec2 clog(vec2 b, float a) { return cdiv(cln(b), cln(a)); }\nvec2 clog(float b, vec2 a) { return cdiv(cln(b), cln(a)); }\nvec2 cexp(float x) { return vec2(cos(x), sin(x)); }\nvec2 cexp(float x, float y) { return exp(x)*cexp(y); }\nvec2 cexp (vec2 z) { return cexp(z.x, z.y); }\nvec2 cexp2(vec2 z){ return cexp(z.y, z.x); }\n\nvec2 cpow(  vec2 z,  vec2 w)  { if(w==vZero) return vOne; if(z==vZero) return vZero; return cexp(cmul(w, cln(z))); }\nvec2 cpow(  vec2 z, float f) { return cpow(z, vec2(f, 0.)); }\nvec2 cpow( float f,  vec2 w) { return cpow(vec2(f, 0.), w); }\n\nvec2 croot( vec2 w,  vec2 z) { return cpow(z, recip(w)); }\nvec2 croot( vec2 w, float f) { return cpow(f, recip(w)); } \nvec2 croot(float f,  vec2 z) { return cpow(z, 1./f); }\n\n//===++===//\n//===++===//\n\nvec2   csin(vec2 z) { return vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y)); }\nvec2   ccos(vec2 z) { return vec2(cos(z.x)*cosh(z.y), -(sin(z.x)*sinh(z.y))); }\nvec2   ctan(vec2 z) { return cdiv(csin(z), ccos(z)); }\nvec2   ccot(vec2 z) { return cdiv(ccos(z), csin(z)); }\nvec2   csec(vec2 z) { return recip(ccos(z)); }\nvec2   ccsc(vec2 z) { return recip(csin(z)); }\n\nvec2  casin(vec2 z) { return -imMul(cln(imMul(z)+csqrt(vOne-csquare(z)))); }\nvec2  cacos(vec2 z) { return -imMul(cln(z+csqrt(csquare(z)-vOne))); }\nvec2  catan(vec2 z) { return (imMul(cln(vOne-imMul(z))-cln(vOne+imMul(z))))/2.; }\nvec2  cacot(vec2 z) { return catan(recip(z)); }\nvec2  casec(vec2 z) { return cacos(recip(z)); }\nvec2  cacsc(vec2 z) { return casin(recip(z)); }\n\nvec2  csinh(vec2 z) { return vec2(sinh(z.x)*cos(z.y), cosh(z.x)*sin(z.y)); }\nvec2  ccosh(vec2 z) { return vec2(cosh(z.x)*cos(z.y), sinh(z.x)*sin(z.y)); }\nvec2  ctanh(vec2 z) { return cdiv(csinh(z), ccosh(z)); }\nvec2  ccoth(vec2 z) { return cdiv(ccosh(z), csinh(z)); }\nvec2  csech(vec2 z) { return recip(ccosh(z)); }\nvec2  ccsch(vec2 z) { return recip(csinh(z)); }\n\nvec2 casinh(vec2 z) { return cln(z+csqrt(csquare(z)+vOne)); }\nvec2 cacosh(vec2 z) { return cln(z+cmul(csqrt(z+vOne), csqrt(z-vOne))); }\nvec2 catanh(vec2 z) { return (cln(cdiv(vOne+z, vOne-z)))/2.; }\nvec2 cacoth(vec2 z) { return (cln(cdiv(z+vOne, z-vOne)))/2.; }\nvec2 casech(vec2 z) { return cln(recip(z)+cmul(csqrt(recip(z)+vOne), csqrt(recip(z)-vOne))); }\nvec2 cacsch(vec2 z) { return cln(recip(z)+csqrt(recip(csquare(z))+vOne)); }\n\n//Note, some of the inverse functions behave a little strangely, namely cosine.\n//I think that's due to the nature of complex numbers.\n\n//===++===//\n//===++===//\n\n\n//Helps decide some functional coloring, for points near 1, 0, or some value representing infinity. (16 in this case)\nvec3 checkDist(float val, vec3 c1, vec3 c2, vec3 c3, vec3 col)\n{\n    if (isNear(val, 0., prec))\n        return c1;\n    if (isNear(val, 1., prec))\n        return c2;\n    if (val >= 16.)\n        return c3;\n    return col;\n}\n\n#define ZOOM 10.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    float norm = iResolution.y/iResolution.x;\n    \n    //Normalized and not mouse positions.\n    vec2 l = ZOOM*((iMouse.xy/iResolution.xy)-.5);\n    l.y*=iResolution.y/iResolution.x;\n    \n    vec2 pnt = l;\n    //lock(pnt, iChannel0);\n    if(keyClick(65, iChannel0)) pnt = roundTo(pnt, .25);\n    if(keyClick(9, iChannel0)) pnt = normalize(pnt);\n    vec2 tpnt = VECTIME2;\n    \n    //The 'normalized' pixel coordinate. AKA, each point in the complex plane.\n    vec2 z = fragCoord/iResolution.xy;\n    z -= .5;\n    z.y *= norm;\n    z*=ZOOM;\n    \n    //++=The actual function applied to each point z=++//\n    vec2 pixelComp = z;\n    \n    float magnitude = mag(pixelComp);\n    float argument = narg(pixelComp);\n    \n    float hue  = argument;\n    float hue2 = 0.;\n    \n    //Lighter = |z| => 0.\n    // Darker = |z| => infinity.\n    float val = pow(1.4, -magnitude);\n    hue -= hue2;\n    float sat = 1.;\n    vec3 col = hsvToRGB(hue, sat, val);\n    //Displays all zeros, ones, and infinities.\n    col = checkDist(magnitude, c1, c2, c3, col);\n    \n    #ifndef COMPAT\n    if(keyClick(81, iChannel0)) \n        grid(fragCoord, .9, vec3(0., 1., 0.), vec3(0.3, 0.5, 0.8), iResolution.xy/2., iResolution.x/ZOOM, col);\n    //Draws a point at the coordinate of VECTIME2 in the complex plane\n    point(pnt, z, ZOOM/1., vec3(0.6, 0.3, 0.33), col);\n    point(tpnt, z, ZOOM/1., vec3(1.), col);\n    #endif\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Sources:\n===+\nExponentiation:       https://goo.gl/T7NbTu\nComplex Numbers:      https://goo.gl/jzXvvb\nTrig. Functions:      https://goo.gl/aQuPsx   Inverses: https://goo.gl/X1wLHA\nHyperbolic Functions: https://goo.gl/34NSjJ   Inverses: https://goo.gl/zxP8PJ\nC# Complex class:     https://goo.gl/X2CWm1\nMilefoot.com:         https://goo.gl/C3va8S\n+===\n*/\n\n//#define COMPAT\n\n//Precision variable.\nconst float prec = 0.05;\n\nconst float e = exp(1.);\nconst float pi = acos(-1.);\nconst float twopi = acos(-1.)*2.;\nconst float halfpi = acos(-1.)/2.;\n\n//Radians to degrees, acronymed rtod.\nconst float rtod = 180./pi;\n\nconst vec2 vOne \t= vec2(1.0, 0.0);\nconst vec2 vImagOne = vec2(0.0, 1.0);\nconst vec2 vZero \t= vec2(0.0, 0.0);\nconst vec2 vComp \t= vec2(1.0, 1.0);\n\n//===++===//\n//===++===//\n\nvec3 hsvToRGB(float h, float s, float v)\n{\n    vec3 z0 = fract(h+vec3(3.,2.,1.)/3.);  //if h==0 => vec3(0, 2/3, 1/3)\n    vec3 z1 = abs(z0*6.-3.);               //if h==0 => vec3(3, 1, 1)\n    vec3 e0 = vec3(1.);\t\t\t   \t       \n    vec3 e1 = clamp((z1-1.),0.,1.);        //if h==0 => vec3(1, 0, 0)\n    return mix(e0,e1,s)*v; //if v==1 && s==1 && h==0 => vec3(1, 0, 0)\n}\n\nvec3 hslToRGB(float h, float s, float l)\n{\n    float v = (2.*l+s*(1.-abs(2.*l-1.)))/2.;\n    float sv = (2.*(v-l))/v;\n    return hsvToRGB(h, sv, v);\n}\n\n//===++===//\n//===++===//\n\nfloat map(float n, float start1, float stop1, float start2, float stop2) { return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2; }\nbool isBetween(float a, float mn, float mx) { return (a >= mn && a <=mx); }\nbool isNear(float val, float compare, float p) { return isBetween(val, compare-p, compare+p); }\nbool isNear(vec2 val, float compare, float p)  { return isNear(val.x, compare, p)   && isNear(val.y, compare, p); }\nbool isNear(vec2 val, vec2 compare, float p)   { return isNear(distance(compare, val), p, p); }\n\n//===++===//\n//===++===//\n\n//Draws a point at a given position, relative to 'pix', with radius 'r' and color 'cl'\n//Honestly, I'm not sure how 'pix' really affects the output, but it seems to work well.\nvoid point(vec2 pos, vec2 pix, float r, vec3 cl, out vec3 col)\n{\n    if(isNear(pix, pos, r/1024.))\n        col = cl;\n}\n\n//Draws a grid. A bit complicated, but it works.d\nvoid grid(vec2 pix, float thickness, vec3 col, vec3 originCol, vec2 space, float spacing, out vec3 color)\n{\n    if(isNear(mod(space.x-pix.x, spacing), 0., thickness) || isNear(mod(space.y-pix.y, spacing), 0., thickness))\n        color = col;\n    if(isNear(pix.x, space.x, thickness) || isNear(pix.y, space.y, thickness))\n        color = originCol;\n}\n\n//TODO: make this look like David Bau's checkers.\nvoid checker(vec2 pix, float thickness, vec3 col, float spacing, out vec3 color)\n{\n    if(isNear(mod(pix.x, spacing), 0., thickness)||isNear(mod(pix.y, spacing), 0., thickness)) color = col;\n}\n\n//===++===//\n//===++===//\n\nfloat roundTo(float a, float p) { return round(a/p)*p; }\nvec2 roundTo(vec2 a, float p) { return vec2(round(a.x/p)*p, round(a.y/p)*p); }\n\nbool keyClick(int ascii, sampler2D channel) {\n\treturn (texture(channel, vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\nvoid lock(out vec2 a, sampler2D channel) \n{    \n    if(keyClick(17, channel)) a = vec2(a.x, 0.);\n    else if (keyClick(16, channel)) a = vec2(0., a.y);\n}","name":"Common","description":"","type":"common"}]}