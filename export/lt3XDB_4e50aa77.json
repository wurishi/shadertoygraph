{"ver":"0.1","info":{"id":"lt3XDB","date":"1481408870","viewed":218,"name":"Lonely Planet","username":"Draedrus","description":"A planet with a sun and his moon. The seasons are changing with time leading to increased ice in both north & south poles. Also, in the night people are using lights.","likes":2,"published":1,"flags":96,"usePreview":0,"tags":["space","planet","seasons","nightday"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsj3Dm","filepath":"https://soundcloud.com/starryhorizen/silence","previewfilepath":"https://soundcloud.com/starryhorizen/silence","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n// soundcloud from https://soundcloud.com/starryhorizen :)\n\n#define EPS 0.001\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n        color += texture(iChannel0, uv+vec2(-EPS, -EPS)).rgb*0.25;\n        color += texture(iChannel0, uv+vec2(EPS, -EPS)).rgb*0.25;\n        color += texture(iChannel0, uv+vec2(-EPS, EPS)).rgb*0.25;\n        color += texture(iChannel0, uv+vec2(EPS, EPS)).rgb*0.25;\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n/**\n * CAMERA BEHAVIOUR RELATED CONSTANTS\n **/\n#define CAMERA_CONTROLLED\n#define NEAR 0.01\n#define FAR 100.0\n\n#define TIME iTime*0.2\n#define CAMERATIME TIME*0.1\n#define CAMERADIST 50.0\n\n#define RAYMARCHING_NUM_STEPS 60\n\n//\n\n#define CAMPOS vec3(0.0, 0.0, 12.0)\n#define TARGETPOS vec3(0.0, 0.0, 0.0)\n\n#define PLANET_RADIUS 20.0\n#define ATMOSPHERE_RADIUS 21.0\n\n#define TYPE_PLANET 0.0\n\n#define NOISEFUNC(x) noise3D(x*6.0)\n\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\n\n\nfloat hash1D(float x)\n{\n \treturn fract(sin(x*13.14434)*1.40503503);   \n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 10.4294, 42.40594))*13.4959451);    \n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat waterNoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    \n    return mix(\n                mix(hash2D(p)     , hash2D(p+vec2(winx, 0.0)), f.x),\n                mix(hash2D(p+vec2(0.0, winy)), hash2D(p+vec2(winx, winy)), f.x),\n                f.y);\n}\n\nfloat smoothNoise2D(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 70.0;\n    \n    float wx = p.x*winx+winy*p.y;\n    return mix(\n                mix(hash1D(wx+0.0)     ,      hash1D(wx+1.0), f.x),\n                mix(hash1D(wx+0.0+winy), \thash1D(wx+1.0+winy), f.x),\n                f.y);\n}\n\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(hash1D(wx+0.0)     ,      hash1D(wx+1.0), f.x),\n                mix(hash1D(wx+0.0+winy), \thash1D(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(hash1D(wx+0.0+winz)     ,      hash1D(wx+1.0+winz), f.x),\n                mix(hash1D(wx+0.0+winy+winz), hash1D(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n//  Simplex 3D Noise \n//  by Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n   \t\t\tf.z);\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2D(vec2 p) {\n    float total = 0.0;\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3D(vec3 p)\n{\n    float total = 0.0;\n    total  = 0.5000* smoothNoise(p); p = p*2.0;\n    total += 0.2500* smoothNoise(p); p = p*2.0;\n    total += 0.1250* smoothNoise(p); p = p*2.0;\n    total += 0.0625* smoothNoise(p); p = p*2.0;\n    return total;\n}\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdPlainTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h), floor(mix( b.y, a.y, h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    float dmax = max(-d1.x, d2.x);\n\treturn abs(d1.x-dmax)<0.01?d1:d2;\n}\n\n/*******************\n * DEPTH MAP + TYPE\n *******************/\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    \n    d = vec2(sdSphere(p-vec3(0.0, 0.0, 0.0), PLANET_RADIUS)+snoise(p*0.1)*0.4+fbm3D(p*0.6), TYPE_PLANET)-0.5;\n    \n    return d;\n}\n\nvec2 mapAtmosphere(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    \n    d = vec2(sdSphere(p-vec3(0.0, 0.0, 0.0), ATMOSPHERE_RADIUS)+snoise(p*0.4)*0.4+fbm3D(p*0.6), TYPE_PLANET);\n    \n    return d;\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = map(pt).x;\n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\nvec2 raymarchAtmosphere(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_NUM_STEPS; i++ )\n\t{\n        m = mapAtmosphere(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 encodeNormal(vec3 n)\n{\n    return vec2(n.xy*0.5+0.5);\n}\n\nvec2 encodeNormal2(vec3 n)\n{\n    float p = sqrt(n.z*8.0+8.0);\n    return vec2(n.xy/p + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 ro = CAMPOS;\n    //#ifndef CAMERA_CONTROLLED\n        ro.x = cos(CAMERATIME)*CAMERADIST;\n        ro.z = sin(CAMERATIME)*CAMERADIST;\n    //#endif\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    \n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \n    #ifdef CAMERA_CONTROLLED\n    vec2 mv = 3.5*(-1.0 + 2.0*iMouse.xy/iResolution.xy);\n    ro = RotYV3(ro, mv.x);\n    rd = RotYV3(rd, mv.x);\n    #endif\n\n    vec2 rm = vec2(FAR, -1.0);\n    rm = raymarch(ro, rd, NEAR, FAR);\n    //vec2 rma = vec2(FAR, -1.0);\n    //rma = raymarchAtmosphere(ro, rd, NEAR, FAR);\n\n    float normalized = (FAR-rm.x)/(FAR-NEAR);\n    //if(length(ro+rd*rm.x)<2.5) rm.y = abs(1.0/length(ro+rd*rm.x));//0.5;\n    vec3 n = normalize((ro+rd*rm.x-vec3(0.0)));//mapNormal(ro+rd*rm.x, 0.001);\n    n = normalize(n+mapNormal(ro+rd*rm.x, 0.001));\n    //n = (vec3(ro+rd*rm.x)/(FAR-NEAR));\n    fragColor = vec4(rm.x, n.x, n.y, n.z);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n#ifndef GLSL\n//#define textureProj texture2DProj\n#endif\n\n#define CAMERA_CONTROLLED\n\n// HDR sky parameters\n#define SCALE_HEIGHT\t\t 8000.0\n#define SUNDIST \t149597870700.0\n// 6360e3\n#define PLANET_RADIUS 20.0\n#define MOON_RADIUS 2.0\n\n#define MOON_DISTANCE 8.0\n// 6420e3\n#define ATMOSPHERERADIUS \t21.0\n#define SUNINTENSITY\t\t 1000.0\n#define SUNRADIUS \t  695700000.0\n#define MOONRADIUS \t\t1737400.0\n#define EARTHPOS vec3(0.0, 0.0, 0.0)\n#define SUNPOS normalize(vec3(1.0, 0.0, 1.0))*149597870700.0\n#define MOONPOS normalize(vec3(1.0, 0.5, 1.7))*384467700.0\n\n#define NEAR 0.01\n#define FAR 100.0\n\n#define TIME iTime*0.2\n#define TIMESEASONS iTime*0.1\n#define CAMERATIME TIME*0.1\n#define CAMERADIST 50.0\n\n#define WATER_HEIGHT 1.005\n\n#define CAMPOS vec3(0.0, 0.0, 12.0)\n\n#define SUNCOLOR 1.5*vec3(0.7, 0.6, 0.2)\n\nvec3 gsunpos = SUNPOS;\nvec3 gmoonpos = vec3(PLANET_RADIUS+MOON_DISTANCE, 0.0, 0.0);\n\nstruct Camera {\n    mat3 m;\n    mat3 mI;\n};\n\n// Noisy things\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = -B/2.0;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\nfloat hash1D(float x)\n{\n \treturn fract(sin(x*13.14434)*1.40503503);   \n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 10.4294, 42.40594))*13.4959451);    \n}\n\n#define HASHC(x,d) fract(dot(x, d)*0.124243434)\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n        \tfor( int k=-1; k<=1; k++ ) {\n                vec3 p = vec3(i, j, k);\n                float h = hash3D(fl+p);\n                vec3 vp = p-fr+h;\n                float d = dot(vp, vp);\n\n                res +=1.0/pow(d, 8.0);\n            }\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat waterNoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    \n    return mix(\n                mix(hash2D(p)     , hash2D(p+vec2(winx, 0.0)), f.x),\n                mix(hash2D(p+vec2(0.0, winy)), hash2D(p+vec2(winx, winy)), f.x),\n                f.y);\n}\n\nfloat smoothNoise2D(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 70.0;\n    \n    float wx = p.x*winx+winy*p.y;\n    return mix(\n                mix(hash1D(wx+0.0)     ,      hash1D(wx+1.0), f.x),\n                mix(hash1D(wx+0.0+winy), \thash1D(wx+1.0+winy), f.x),\n                f.y);\n}\n\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(hash1D(wx+0.0)     ,      hash1D(wx+1.0), f.x),\n                mix(hash1D(wx+0.0+winy), \thash1D(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(hash1D(wx+0.0+winz)     ,      hash1D(wx+1.0+winz), f.x),\n                mix(hash1D(wx+0.0+winy+winz), hash1D(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\nfloat noiseC3D(vec3 x, vec3 d)\n{\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    return mix(HASHC(p+f, d), HASHC(p+vec3(-0.01, -0.01, -0.01)+f, d), n.z);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n//  Simplex 3D Noise \n//  by Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n   \t\t\tf.z);\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2D(vec2 p) {\n    float total = 0.0;\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p);\n    return total;\n}\n\nfloat fbm3D(vec3 p)\n{\n    float total = 0.0;\n    total  = 0.5000* smoothNoise(p); p = p*2.0;\n    total += 0.2500* smoothNoise(p); p = p*2.0;\n    total += 0.1250* smoothNoise(p); p = p*2.0;\n    total += 0.0625* smoothNoise(p);\n    return total;\n}\n\nfloat fbm3Dsnoise(vec3 p)\n{\n    float total = 0.0;\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3DTex(vec3 p)\n{\n    float total = 0.0;\n    total  = 0.5000* textureProj(iChannel1, p).x; p = p*2.0;\n    total += 0.2500* textureProj(iChannel1, p).x; p = p*2.0;\n    total += 0.1250* textureProj(iChannel1, p).x; p = p*2.0;\n    total += 0.0625* textureProj(iChannel1, p).x;\n    return total;\n}\n\nfloat fbmC3D(vec3 p, vec3 d)\n{\n    float total = 0.0;\n    total  = 0.5000* noiseC3D(p, d); p = p*2.0; d = d*2.0;\n    total += 0.2500* noiseC3D(p, d); p = p*2.0; d = d*2.0;\n    total += 0.1250* noiseC3D(p, d); p = p*2.0; d = d*2.0;\n    total += 0.0625* noiseC3D(p, d);\n    return total;\n}\n\n// end of noisy things\n\n\n/*******************\n * WATER DEPTH MAP + NORMAL\n *******************/\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat mapWater(vec3 p, float planet_radius) {\n    return sdSphere(p, planet_radius)+fbm3D(p*0.5+TIME);\n}\n\nvec3 mapWaterNormal(vec3 pt, float planet_radius, float e) {\n    vec3 normal;\n    normal.z = mapWater(pt, planet_radius);\n    normal.x = mapWater(vec3(pt.x+e,pt.y,pt.z), planet_radius) - normal.z;\n    normal.y = mapWater(vec3(pt.x,pt.y+e,pt.z), planet_radius) - normal.z;\n    normal.z = e;\n    return normalize(normal);\n}\n\n/******************\n * RENDERING\n ******************/\n\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / max(0.0001, 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(roughness, NdotH);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L,\n\tvec3 Lcolor)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)*max(0.0, dot(N, L))*Lcolor+Ks*specularColor*spec) * Oi;\n}\n\nvec3 getAtmosphere(vec3 ro, vec3 rd, vec3 L, vec3 betaR, vec3 betaM)\n{\n    vec3 light = vec3(0.0);\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n    vec3 Pa = ro+rd*tmax;\n    if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);\n    float RdotL = dot(rd, L);\n    float tCurrent = 0.0;\n    float segL = tmax/16.0;\n    if(d>0.0)\n        segL = (tmax-tmin)/16.0;\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 7994.0; // 7994\n    float hm = 1200.0; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation has an error with the first terms in the equation\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    //vec3 betaM = vec3(21e-6);\n    float opticalDepthM = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - PLANET_RADIUS;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = L;//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);\n        float segLLight = tlmax/8.0;\n        float tCurrentLight = 0.0;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < 8; ++j)\n        {\n            // light occlusion by earth\n            float tlmine = -1.0, tlmaxe = -1.0;\n        \tfloat dle = IntersectSphere(X, L, EARTHPOS, PLANET_RADIUS, tlmine, tlmaxe);\n            if(tlmine<0.0)\n            {\n            \n                vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n                float hLight = length(samplePositionLight) - PLANET_RADIUS;\n                if (hLight < 0.0)\n                {\n                    ended = false;\n                    break;\n                }\n                opticalDepthLightR += exp(-hLight / hr) * segLLight;\n                opticalDepthLightM += exp(-hLight / hm) * segLLight;\n                tCurrentLight += segLLight;\n            }\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM * SUNCOLOR);\n}\n\nfloat getCitiesNoise(vec3 x, float height)\n{\n\treturn pow(min(1.0, voronoi3D(x*0.4+height)), 8.0)*fbm3D(x+height)*clamp(snoise(x*2.0+height), 0.0, 2.0)*4.0;\n}\n\nfloat magnify(float x, float o, float n)\n{\n    return pow(x+o, n)-o;\n}\n\nfloat logMagnify(float x)\n{\n    return log(x+1.0);\n}\n\nvec3 getEarthColor(vec3 p, vec3 N, float depth, vec3 ro, vec3 rd, vec3 L)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    #define BEACH vec3(0.2, 0.2, 0.0)\n    #define DESERT vec3(0.7, 0.7, 0.0)\n    #define DESERTROCK vec3(0.6, 0.4, 0.3)\n    #define WHITE vec3(1.0)\n    #define GREEN vec3(0.1, 0.2, 0.1)\n    #define FOREST vec3(0.05, 0.1, 0.05)\n    float height = length(p-vec3(0.0))/PLANET_RADIUS;\n    float normalized_terrain_height = (height-WATER_HEIGHT)*15.0*fbm3D(p);\n    float desert_noise = clamp(fbm3D(p*0.4*vec3(0.7, 1.2, 0.7))*2.0, 0.0, 1.0);\n    float desert_dsm = clamp(fbm3D(p*0.2), 0.0, 1.0);\n    float forest_dsm = clamp(1.0-fbm2D(p.xy*0.08), 0.0, 1.0);\n    color = mix(BEACH,\n        mix(\n            mix(\n                DESERT,\n                DESERTROCK,\n                desert_dsm),\n            mix(\n                mix(\n                    GREEN,\n                    FOREST,\n                    forest_dsm),\n                WHITE,\n\t\t\t\tnormalized_terrain_height),\n        \tdesert_noise),\n         max(1.0, log((height-WATER_HEIGHT))));\n    \n    // north & south poles\n    vec3 aN = abs(normalize(p));\n    float poles = pow(max(0.0, dot(aN, vec3(0.0, 1.0, 0.0))), 3.0+cos(TIMESEASONS));\n    \n    float c = clamp(voronoi3D(p*10.6), 0.0, 0.2);\n    \n    color += clamp((magnify(1.0-clamp(voronoi3D(p*5.6), 0.0, 1.0), 1.0, 3.0)*poles+poles*c), 0.0, 1.0);\n    \n    color = brdf(\n        1.0, // Ks\n        1.0, // Kd\n        1.0, // roughness\n        1.0, // opacity\n        color, // specular\n        color,// diffuse\n        rd,\n    \tN,\n        L,\n    \tSUNCOLOR);\n    // cities by night\n    {\n        float cities_noise = getCitiesNoise(p, height)*hash3D(p);\n        color += mix(\n            \t\tvec3(0.0),\n            \t\tvec3(cities_noise*2.0)*vec3(0.9, 0.5, 0.0),\n            \t\tdesert_noise)*ceil(max(0.0, dot(N, -L)));\n    }\n    \n    return color;\n}\n\nvec3 getMoonColor(vec3 ro, vec3 rd, float t, vec3 L)\n{\n    vec3 p = ro+rd*t;\n \tvec3 N = normalize(p-gmoonpos);\n    float wn = min(1.0, voronoi3D(N*0.9));\n    float f = fbm3D(N*4.0);\n    float lighting = max(0.0, dot(L,N));\n    return vec3(pow(wn, 4.0)+pow(f, 4.0))*log(lighting+1.0);//vec3(max(0.15, wn-f)*lighting);\n}\n\nvec3 decodeNormal(vec2 enc)\n{\n    vec3 n = vec3(0.0);\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\nvec3 decodeNormal2(vec2 enc)\n{\n    vec2 fenc = enc*4.0-2.0;\n    float f = dot(fenc,fenc);\n    float g = sqrt(1.0-f/4.0);\n    vec3 n;\n    n.xy = fenc*g;\n    n.z = 1.0-f/2.0;\n    return n;\n}\n\nvec3 getSpaceColor(vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    float noise = pow(max(0.0, snoise(rd*100.0)-0.8)+1.0, 2.0)-1.0;\n    color = vec3(noise);\n    /*color = texture(iChannel1, rd.xy*1.0).rgb*vec3(0.1, 0.05, 0.1);\n    color += 1.0;\n    color.r = pow(color.r, 2.0);\n    color.g = pow(color.g, 2.0);\n    color.b = pow(color.b, 2.0);\n    color -= 1.0;\n    color *= 0.1;*/\n    return color;\n}\n\n// from https://www.shadertoy.com/view/llj3zV\nvec3 getSunColor( in vec2 uv, in vec2 sp)\n{\n    float t = atan( uv.x - sp.x, uv.y - sp.y );\n    float n = 2.0 + noise3D( vec3( 10.0 * t, iTime, 0.0 ) );\n    float d = length( uv - sp ) * 25.0;\n    return ( ( 1.0 + n ) / ( d * d * d ) ) * vec3(1.0);\n}\n\nfloat doFlare( in vec2 uv, in vec2 dir, float s )\n{\n    float d = length( uv - dot( uv, dir ) * dir );\n    float f = 0.0;\n    f += max( pow( 1.0 - d, 128.0 ) * ( 1.0   * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  64.0 ) * ( 0.5   * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  32.0 ) * ( 0.25  * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  16.0 ) * ( 0.125 * s - length( uv ) ), 0.0 );\n    return f;\n}\n\nfloat doLensGlint( in vec2 uv, in vec2 c, float r, float w )\n{\n    float l = length( uv - c );\n    return length( c ) * smoothstep( 0.0, w * r, l ) * ( 1.0 - smoothstep( w * r, r, l ) );\n}\n// end from\n\nfloat getClouds(vec3 x)\n{\n    float r = length(x);\n    float tho = atan(x.z, r);\n    float phi = atan(x.y, x.x);\n    vec3 dir = vec3(r, tho, phi);\n    \n    \n    float currentFlow = fbm3D((x+TIME)*5.0);\n    return magnify(\n        clamp(\n            fbm3D(\n                (x+TIME+(ATMOSPHERERADIUS-length(x))/(ATMOSPHERERADIUS-PLANET_RADIUS))*0.2\n            )*0.15,\n            0.0, 1.0),\n        1.0, 2.0);\n    x+=TIME;\n    x*=0.2;\n    return \n        (6.0*pow(fbm3D(x), 4.0)+\n        0.5*pow(fbm3D(2.0*x), 4.0)+\n        0.25*pow(fbm3D(4.0*x), 4.0)+\n        0.15*pow(fbm3D(8.0*x), 8.0))*0.2;\n}\n\nvec3 attenuateAtmosphereScattering(vec3 x)\n{\n    x = vec3(pow(x.x, 2.0), pow(x.y, 2.0), pow(x.z, 2.0));\n    return vec3(\n    \tpow(logMagnify(x.x), 1.8),\n    \tpow(logMagnify(x.y), 1.8),\n    \tpow(logMagnify(x.z), 1.8)\n    );\n}\n\nvec3 rendering(vec4 gbuffer, vec3 ro, vec3 rd, vec2 uv, mat3 caInv)\n{\n    vec3 color = vec3(0.0);\n        \n    vec3 p = ro+gbuffer.x*rd;\n    vec3 pw = ro+mapWater(p, PLANET_RADIUS)*rd;\n    vec3 L = normalize(gsunpos);\n    vec3 Lv = -normalize(ro-gsunpos);\n    \n    float moontMin = 0.0;\n    float moontMax = 0.0;\n    float dmoon = IntersectSphere(ro, rd, gmoonpos, MOON_RADIUS, moontMin, moontMax);\n\n    if(gbuffer.x>NEAR && gbuffer.x<FAR)\n    {\n        vec3 N = gbuffer.yzw;//decodeNormal2(gbuffer.zw);//normalize(vec3((gbuffer.z-1.0)*2.0, (gbuffer.z-0.5)*2.0, gbuffer.w));\n        //N.y = -N.y;\n        \t\n        vec3 P = normalize(p);\n        \n        if(length(p)<PLANET_RADIUS*WATER_HEIGHT) // water\n        {\n            N = normalize(p);\n            N = normalize(N+mapWaterNormal(p, PLANET_RADIUS, 0.001));\n            //N.y = rd.y;\n            N.y *= sign(rd.y);\n            color = vec3(0.0, 0.0, 1.0);\n            vec3 R = normalize(p)*0.7;//normalize(p);//normalize(reflect(rd, N));\n            color = getAtmosphere(p, R, L, vec3(5.5e-6, 13.0e-6, 22.4e-6), vec3(21e-6));\n            color = attenuateAtmosphereScattering(color);\n        }\n        else if(length(p)>=PLANET_RADIUS*WATER_HEIGHT && length(p)<PLANET_RADIUS*(WATER_HEIGHT+0.001))\n        {\n            N = normalize(p);\n            N = normalize(N+mapWaterNormal(p, PLANET_RADIUS, 0.001));\n            //N.y = rd.y;\n            N.y *= sign(rd.y);\n            color = vec3(0.0, 0.0, 1.0);\n            vec3 R = normalize(p)*0.7;//normalize(p);//normalize(reflect(rd, N));\n            color = getAtmosphere(p, R, L, vec3(5.5e-6, 13.0e-6, 22.4e-6), vec3(21e-6));\n            color = attenuateAtmosphereScattering(color);\n        \tN = gbuffer.yzw;\n\t\t\tcolor = mix(\n                color,\n                getEarthColor(p, N, (gbuffer.x-NEAR)/(FAR-NEAR), ro, rd, L),\n                0.5);\n            //color = vec3(1.0, 0.0, 0.0);\n        }\n        else\n        {\n            color = getEarthColor(p, N, (gbuffer.x-NEAR)/(FAR-NEAR), ro, rd, L);\n            //color = N;\n        }\n        // moon shadow\n        float minme = 0.0;\n        float maxme = 0.0;\n        float _dmoone = IntersectSphere(p, L, gmoonpos, MOON_RADIUS, minme, minme);\n        if(minme>0.0 && dot(N, normalize(p-gmoonpos))<0.0)\n        {\n        \tcolor *= 0.2;   \n        }\n        \n        float clouds = getClouds(p);\n        N = normalize(p);\n        color+=min(1.0, max(0.0, clouds*max(0.2, dot(N, L))));\n    }\n    else\n    {\n        color = getSpaceColor(rd);\n        float sunp = pow(max(0.0, dot(rd, Lv)), 2048.0);\n        color += vec3(0.7, 0.6, 0.2)*sunp;\n        // making the atmosphere\n        vec3 atm = getAtmosphere(ro, rd, L, vec3(5.5e-6, 13.0e-6, 22.4e-6), vec3(21e-6));\n        float clouds = getClouds(p);\n    \tcolor += mix(getSpaceColor(rd), atm+clouds, atm);\n    }\n    // moon\n    if(moontMin>0.0 && moontMin<gbuffer.x)\n    {\n    \tcolor = getMoonColor(ro, rd, moontMin, L);   \n    }\n    \n    return color;\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\n// the camera construction method is inspired by the one from IQ\nCamera setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n    Camera cam;\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    cam.m = mat3( cu, cv, cw );\n    cam.mI = mat3(\n        \t\tcu.x, cv.x, cw.x,\n        \t\tcu.y, cv.y, cw.y,\n        \t\tcu.z, cv.z, cw.z);\n    return cam;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 ro = CAMPOS;\n    //#ifndef CAMERA_CONTROLLED\n        ro.x = cos(CAMERATIME)*CAMERADIST;\n        ro.z = sin(CAMERATIME)*CAMERADIST;\n    //#endif\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    \n    Camera ca = setCamera(ro, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    rd = ca.m*normalize(vec3(pixel.xy, 2.0));\n    \n    #ifdef CAMERA_CONTROLLED\n    vec2 mv = 3.5*(-1.0 + 2.0*iMouse.xy/iResolution.xy);\n    ro = RotYV3(ro, mv.x);\n    rd = RotYV3(rd, mv.x);\n    #endif\n    \n    // sun\n    gsunpos = vec3(cos(TIME), sin(TIME), sin(TIME))*149597870700.0;\n    \n    gmoonpos = vec3(cos(TIME), 0.0, sin(TIME))*(PLANET_RADIUS+MOON_DISTANCE);\n    \n    \n    vec4 gbuffer = texture(iChannel0, uv);\n    \n    /*mat3 caInv = mat3(ca[0][0], ca[1][0], ca[2][0],\n                      ca[0][1], ca[1][1], ca[2][1],\n                      ca[0][2], ca[1][2], ca[2][2]);*/\n    /*mat3 caInv = mat3(ca[0][0], ca[0][1], ca[0][2],\n                      ca[1][0], ca[1][1], ca[1][2],\n                      ca[2][0], ca[2][1], ca[2][2]);*/\n    \n    vec3 color = rendering(gbuffer, ro, rd, uv, ca.mI);\n    \n    color = tonemapping(color);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}