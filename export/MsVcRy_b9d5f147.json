{"ver":"0.1","info":{"id":"MsVcRy","date":"1522552625","viewed":10951,"name":"rm -f","username":"shau","description":"Playing with fractal by GUIL (again)","likes":100,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO (min(iFrame,0))\n#define T iTime\n#define PI 3.141592\n#define FAR 20.0\n#define EPS 0.005\n\n#define SPHERE_EXTERIOR 1.0\n#define SPHERE_INTERIOR 2.0\n#define FLOOR 3.0\n#define SR 0.2\n\n#define CA vec3(0.5, 0.5, 0.5)\n#define CB vec3(0.5, 0.5, 0.5)\n#define CC vec3(1.0, 1.0, 1.0)\n#define CD vec3(0.0, 0.33, 0.67)\n\n#define CT T / 14.0\n\nconst vec4 sphere = vec4(0.0, 0.0, 0.0, 1.0);\n\nstruct Scene {\n    float t;\n    float id;\n    vec3 n;\n    float stn;\n    float stf;\n};\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {return a + b * cos(6.28318 * (c * t + d));}\nvec3 glowColour() {return palette(T * 0.1, CA, CB, CC, CD);}\nvec2 csqr(vec2 a) {return vec2(a.x * a.x - a.y * a.y, 2.0 * a.x * a.y);}\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat fbm(vec3 x) {\n    float r = 0.0;\n    float w = 1.0;\n    float s = 1.0;\n    for (int i = ZERO; i < 5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat tex(vec3 rp) {\n    rp.xy *= rot(T);\n    if (rp.x > 0.3 && rp.x < 0.5) return 0.0;\n    return 1.0;\n}        \n\n//Cube mapping trick from Fizzer\nfloat pattern(vec3 rp) {\n    vec3 f = abs(rp);\n    f = step(f.zxy, f) * step(f.yzx, f); \n    f.xy = f.x > .5 ? rp.yz / rp.x : f.y > .5 ? rp.xz / rp.y : rp.xy / rp.z; \n    return tex(f);\n}\n\n//See sphere functions IQ\n//https://iquilezles.org/articles/spherefunctions\n//slightly modified for cut patterns\nvec4 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec4(0.0); //missed\n    h = sqrt(h);\n    float tN = -b - h;\n    float tNF = tN;\n    if (pattern(ro + rd * tNF) == 0.0) tNF = 0.0;\n    float tF = -b + h;\n    float tFF = tF;\n    if (pattern(ro + rd * tFF) == 0.0) tFF = 0.0;\n    return vec4(tNF, tFF, tN, tF);\n}\n\nvec3 sphNormal(in vec3 pos, in vec4 sph) {\n    return normalize(pos - sph.xyz);\n}\n\nfloat sphSoftShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    // physically plausible shadow\n    float d = sqrt( max(0.0, sph.w * sph.w - h)) - sph.w;\n    float tN = -b - sqrt( max(h, 0.0));\n    float tF = -b + sqrt( max(h, 0.0));\n    if ((pattern(ro + rd * tN) + pattern(ro + rd * tF)) == 0.0) return 1.0;\n    if (tN > 0.0) return smoothstep(0.0, 1.0, 4.0 * k * d / tN) * 1.0;\n    return 1.0;\n}\n\nfloat sphOcclusion(vec3 pos, vec3 nor, vec4 sph) {\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor, r);\n    float res = d;\n\n    if (d < sph.w) res = pow(clamp((d + sph.w) / (2.0 * sph.w), 0.0, 1.0), 1.5) * sph.w;\n    \n    return clamp(res * (sph.w * sph.w) / (l * l * l), 0.0, 1.0);\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nfloat map(vec3 rp) {\n\treturn min(length(rp) - sphere.w, rp.y + 1.0);\n}\n\nvec3 vMarch(vec3 ro, vec3 rd) {\n\n    vec3 pc = vec3(0.0);\n    float t = 0.0;\n    \n    for (int i = ZERO; i < 96; i++) {\n        \n        vec3 rp = ro + rd * t;\n        float ns = map(rp);\n        float fz = pattern(rp);\n        \n        if ((ns < EPS && fz > 0.0) || t > FAR) break;\n        \n        vec3 ld = normalize(-rp);\n        float lt = length(rp);\n        if (sphIntersect(rp, ld, sphere).x == 0.0 || lt < sphere.w) {\n            lt -= SR;\n            pc += glowColour() * 0.1 / (1.0 + lt * lt * 12.0);        \n        }\n        \n        t += 0.05;\n    }\n    \n    return pc;\n}\n\n//fractal from GUIL\n//https://www.shadertoy.com/view/MtX3Ws\nfloat fractal(vec3 rp) {\n\t\n\tfloat res = 0.0;\n\tfloat x = 0.8 + sin(T * 0.2) * 0.3;\n    \n    rp.yz *= rot(T);\n    \n    vec3 c = rp;\n\t\n    for (int i = ZERO; i < 10; ++i) {\n        rp = x * abs(rp) / dot(rp, rp) - x;\n        rp.yz = csqr(rp.yz);\n        rp = rp.zxy;\n        res += exp(-99.0 * abs(dot(rp, c)));   \n\t}\n    \n    return res;\n}\n\nvec3 fractalMarch(vec3 ro, vec3 rd, float maxt) {\n    \n    vec3 pc = vec3(0.0);\n    float t = 0.0;\n    float ns = 0.;\n    \n    for (int i = ZERO; i < 64; i++) {\n        \n        vec3 rp = ro + t * rd;\n        float lt = length(rp) - SR;\n\n        ns = fractal(rp); \n        \n        if (lt < EPS || t > maxt) break;\n        t += 0.02 * exp(-2.0 * ns);\n\n        pc = 0.99 * (pc + 0.08 * glowColour() * ns) / (1.0 + lt * lt * 1.);\n        pc += 0.1 * glowColour() / (1.0 + lt * lt);  \n    } \n    \n    return pc;\n}\n    \nScene drawScene(vec3 ro, vec3 rd) {\n \n    float mint = FAR;\n    vec3 minn = vec3(0.0);\n    float id = 0.0;\n\n    vec3 fo = vec3(0.0, -1.0, 0.0);\n    vec3 fn = vec3(0.0, 1.0, 0.0);\n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0 && ft < FAR) {\n        mint = ft;\n        id = FLOOR;\n        minn = fn;\n    }    \n    \n    vec4 si = sphIntersect(ro, rd, sphere);\n    if (si.x > 0.0 && si.x < mint) {        \n        vec3 rp = ro + rd * si.x;\n        mint = si.x;\n        id = SPHERE_EXTERIOR;\n        minn = sphNormal(rp, sphere);\n    } else if (si.y > 0.0 && si.y < mint) {        \n        vec3 rp = ro + rd * si.y;\n        mint = si.y;\n        id = SPHERE_INTERIOR;\n        minn = -sphNormal(rp, sphere);\n    }\n    \n    return Scene(mint, id, minn, si.z, si.w);;\n}\n\n//Moody clouds from Patu\n//https://www.shadertoy.com/view/4tVXRV\nvec3 clouds(vec3 rd) {\n    vec2 uv = rd.xz / (rd.y + 0.6);\n    float nz = fbm(vec3(uv.yx * 1.4 + vec2(CT, 0.0), CT)) * 1.5;\n    return clamp(pow(vec3(nz), vec3(4.0)) * rd.y, 0.0, 1.0);\n}\n\n// see https://www.shadertoy.com/view/MtffWs\nvec3 pri(vec3 x) {\n    vec3 h = fract(x / 2.0) - 0.5;\n    return x * 0.5 + h * (1.0 - 2.0 * abs(h));\n}\n\nfloat checkersTextureGradTri(vec3 p, vec3 ddx, vec3 ddy) {\n    p.z += T;\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01; // filter kernel\n    vec3 i = (pri(p + w) - 2.0 * pri(p) + pri(p - w)) / (w * w); // analytical integral (box filter)\n    return 0.5 - 0.5 * i.x *  i.y * i.z; // xor pattern\n}\n\nvec3 texCoords(vec3 p) {\n\treturn 5.0 * p;\n}\n\nvec3 colourScene(vec3 ro, vec3 rd, Scene scene) {\n    \n    vec3 pc = clouds(rd) * glowColour();\n    vec3 gc = vec3(0.0);\n    vec3 lp = vec3(4.0, 5.0, -2.0);\n\t    \n    vec3 rp = ro + rd * scene.t;\n    \t\n    vec3 ld = normalize(lp - rp);\n    float lt = length(lp - rp);\n    float atten = 1.0 / (1.0 + lt * lt * 0.051);\n    \n    if (scene.stn > 0.0) {\n        gc = fractalMarch(ro + rd * scene.stn, rd, scene.stf - scene.stn);\n        pc = gc;\n    }\n\n    if (scene.id == FLOOR) {\n        \n        // calc texture sampling footprint\t\n        vec3 uvw = texCoords(rp * 0.15);\n\t\tvec3 ddx_uvw = dFdx(uvw); \n    \tvec3 ddy_uvw = dFdy(uvw);\n        float fc = checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw);\n        \n    \tfloat diff = max(dot(ld, scene.n), 0.05);\n        float ao = 1.0 - sphOcclusion(rp, scene.n, sphere);  \n        float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 32.0);\n        float sh = sphSoftShadow(rp, ld, sphere, 2.0);\n\n        pc += glowColour() * fc * diff * atten;\n        pc += vec3(1.0) * spec;\n        pc *= ao * sh; \n        \n        vec3 gld = normalize(-rp);\n        if (sphIntersect(rp, gld, sphere).x == 0.0) {\n            pc += glowColour() / (1.0 + length(rp) * length(rp));    \n        }\n    }\n    \n    if (scene.id == SPHERE_EXTERIOR) {\n    \t\n        float ao = 0.5 + 0.5 * scene.n.y;\n        float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 32.0);\n        float fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 2.0);\n        \n        pc *= 0.4 * (1.0 - fres);\n        pc += vec3(1.0) * fres * 0.2;\n        pc *= ao;\n        pc += vec3(1.0) * spec;\n    }\n\n      \n    if (scene.id == SPHERE_INTERIOR) {\n    \tfloat ao = 0.5 + 0.5 * scene.n.y;\n        float ilt = length(rp) - SR;\n        pc += glowColour() * ao / (1.0 + ilt * ilt);\n    }\n    //*/\n    \n    return pc;\n}\n\nvoid setupCamera(vec2 uv, inout vec3 ro, inout vec3 rd) {\n\n    ro = vec3(0.0, 0.0, -4.0);\n    vec3 lookAt = ro + vec3(0.0, 0.0 , 4.0);\n    \n    ro.xz *= rot(T * 0.4);\n    \n    float FOV = PI / 4.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec3 pc = vec3(0.0);\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\tvec3 ro, rd;\n\tsetupCamera(uv, ro, rd);\n    \n    Scene scene = drawScene(ro, rd);\n\tpc = colourScene(ro, rd, scene);    \n    \n    pc += vMarch(ro, rd);\n    \n    fragColor = vec4(pc*2.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}