{"ver":"0.1","info":{"id":"WtS3Wd","date":"1561463611","viewed":167,"name":"Snap To Octant","username":"fizzer","description":"A small function to snap a vector to the closest directional octant. This version is optimised for GLSL code size, for a version optimised for instructioncount / performance see this one by adx: [url]https://www.shadertoy.com/view/tlj3Wc[/url]","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["angle","snap","octant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265358979323;\nconst float th = pi * 3. / 8.;\nconst float sc = 1. / cos(th);\n\nvec2 snapToOctant(vec2 v)\n{\n    v *= sc / length(v); // Set the length of the input\n    return normalize(step(vec2(1), abs(v)) * sign(v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= 1.1;\n\n    // Rotational symmetry test\n    float a = floor(iTime) * pi / 4.; uv *= mat2(cos(a), sin(a), -sin(a), cos(a));\n\n    // Snap\n    vec2 snapped = snapToOctant(uv);\n\n    float th = atan(snapped.y, snapped.x);\n    \n    fragColor.a = 1.;\n    \n    if(length(uv) > 1.)\n    {\n        fragColor.rgb = vec3(smoothstep(1.02, 1.03, length(uv)) * .1);\n    }\n    else\n    {\n        // Angle shade\n        //fragColor.rgb = vec3(th) / pi / 2. + .5;\n\n        // Vector shade\n        fragColor.rgb = vec3(snapped * .5 + .5, .1);\n    }\n    \n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n}\n","name":"Image","description":"","type":"image"}]}