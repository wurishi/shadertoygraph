{"ver":"0.1","info":{"id":"Xtd3W8","date":"1469054647","viewed":195,"name":"testing of the raymarching","username":"jumpy89","description":"Finally tried my hand at this. Got diffuse lighting, soft shadows, ambient occlusion, distance field primitives, and solid geometry working. It's probably all wrong because I did most of it from memory from what I've seen on here previously.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ENABLE_SHADOWS 1\n#define ENABLE_SOFT_SHADOWS 1\n#define ENABLE_AO 1\n#define ENABLE_TONE_MAPPING 1\n\n#define FOV .5\n\n#define MARCH_STEPS 250\n#define MARCH_EPS .000001\n#define MAX_DIST 100.0\n\n#define NORMAL_EPS .00001\n\n#define LIGHT_DIFFUSE vec3(1.0, 0.9, 0.8)\n#define LIGHT_AMBIENT vec3(0.25, 0.25, 0.25)\n\n#define SSDW_K 16.0\n#define SSDW_EPS 0.004\n#define SSDW_STEPS 160\n#define SSDW_STEP_FRAC 0.45\n\n#define AO_STEP_COUNT 10\n#define AO_STEP_SIZE 0.05\n#define AO_K .714\n#define AO_STRENGTH 2.3\n\n#define EXPOSURE 2.8\n\n\n#define LN_2_INV 1.44269504089\n\n\nconst vec3 LIGHT_DIR = normalize(vec3(1.5, -2.0, -1.5));\n\n\n\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    return distance(p, c) - r;\n}\n\n\nfloat sdBoxFast(vec3 p, vec3 c, vec3 s)\n{\n    vec3 d = abs(p - c) - s;\n    return max(d.x, max(d.y, d.z));\n}\n\nfloat sdBox(vec3 p, vec3 c, vec3 s)\n{\n    vec3 d = abs(p - c) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat sgUnion(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\n\nfloat sgUnion(float d1, float d2, float k)\n{\n    return smin(d1, d2, k);\n}\n\n\nfloat sgInterection(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\n\nfloat sgInterection(float d1, float d2, float k)\n{\n    return -smin(-d1, -d2, k);\n}\n\n\nfloat sgDifference(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\n\nfloat sgDifference(float d1, float d2, float k)\n{\n    return -smin(-d1, d2, k);\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 p1 = vec3(cos(iTime * 1.), sin(iTime * 1.) * 0.8 - 0.2, 0.0);\n   \n    float shape1_sphere = sdSphere(p, p1, .8);\n    float shape1_box = sdBox(p, p1, vec3(.6));\n    float shape1_cyl = length((p - p1).xy) - .3;\n    \n    float shape1_blend = (1.1 + cos(iTime * 2.3)) * .6;\n    float shape1_outer = mix(shape1_sphere, shape1_box, shape1_blend);\n    \n   \tfloat shape1 = sgDifference(shape1_outer, shape1_cyl, 8.0);\n    \n    float x = cos(iTime * 1.3);\n    float box = sdBox(p, vec3(x * .5, 0., x * .9), vec3(.2));\n    \n    float shape2 = sgUnion(shape1, box, 16.0);\n    \n    float plane = p.y + .5;\n    float ground = sgDifference(plane, shape1_outer, 8.0);\n\n    float d = sgUnion(shape2, ground);\n    \n    return d;\n}\n\n\n/**\n * Ray march\n * \n *     ro: ray origin\n *     rd: ray direction (normalized)\n */\nvec4 march(vec3 ro, vec3 rd)\n{\n    vec3 p = ro; // Current position\n    float td = 0.0; // Total distance traveled\n    float d; // Current distance to surface\n    float nsteps = 0.0; // Number of steps taken\n    \n    for (int i = 0; i < MARCH_STEPS; i++)\n    {\n        d = map(p);\n        \n        if (d < MARCH_EPS)\n        {\n            td += max(d, 0.0);\n        \tp = ro + td * rd;\n            break;\n        }\n        \n        td += d;\n        p = ro + td * rd;\n        \n        if (td > MAX_DIST)\n        {\n            nsteps = -nsteps;\n            break;\n        }\n        \n        nsteps += 1.0;\n    }\n    \n    return vec4(p, nsteps);\n}\n\n\nfloat softShadow(vec3 ro, vec3 rd)\n{\n    float td = 0.0; // Total distance traveled\n    float d; // Current distance to surface\n    float value = 1.0;\n    float f;\n    \n    for (int i = 0; i < SSDW_STEPS; i++)\n    {\n        f = td / SSDW_K;\n\n        d = map(ro + td * rd) + 0.5 * f;\n        \n        if (d < SSDW_EPS)\n        \treturn 0.0;\n        \n        if (td > MAX_DIST)\n        \tbreak;\n        \n        value = min(value, d / f);\n        \n        td += d * SSDW_STEP_FRAC;\n    }\n    \n    return value;\n}\n\n\nfloat calcAO(vec3 ro, vec3 rd)\n{\n    float td = 0.0; // Total distance traveled\n    float d; // Current distance to surface\n    float sum = 0.0;\n    float r = 1.0;\n    \n    for (int i = 0; i < AO_STEP_COUNT; i++)\n    {\n        td += AO_STEP_SIZE;\n        r *= AO_K;\n\n        d = map(ro + td * rd);\n        \n        sum += r * max(td - d, 0.0);\n    }\n    \n    return max(1.0 - AO_STRENGTH * sum * (1.0 - AO_K) / AO_K, 0.0);\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n    return normalize(vec3( map(p + vec3(NORMAL_EPS, 0.0, 0.0)) - map(p - vec3(NORMAL_EPS, 0.0, 0.0)),\n                           map(p + vec3(0.0, NORMAL_EPS, 0.0)) - map(p - vec3(0.0, NORMAL_EPS, 0.0)),\n                           map(p + vec3(0.0, 0.0, NORMAL_EPS)) - map(p - vec3(0.0, 0.0, NORMAL_EPS))\n                         ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates: origin in center of window, y range is (-1, 1)\n\tvec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy) / iResolution.y;\n    \n    // Ray origin in world coordinates\n    vec3 ro = vec3(0.0, 0.0, -2.5);\n    \n    // Unit vector of ray direction in world coordinates\n    vec3 rd = normalize(vec3(uv * FOV, 1.0));\n    \n    // Ray march, get intersection point and number of steps\n    vec4 m = march(ro, rd);\n    vec3 p = m.xyz;\n    float nsteps = abs(m.w);\n    \n    \n    // Color value of the pixel\n    vec3 col;\n    \n    // Stopped at epsilon or max iterations - consider it an intersection\n    if (m.w >= 0.0)\n    {\n        // Calculate normal\n        vec3 n = calcNormal(p);\n        \n        // Lambertian diffuse reflectance term\n        vec3 ambient = LIGHT_AMBIENT;\n        float diffuse = max(-dot(n, LIGHT_DIR), 0.0);\n        \n        // Calculate shadows\n        #if ENABLE_SHADOWS\n        \n            // Only if diffuse term was positive\n            if (diffuse > 0.0)\n            {\n        \n                // Cool soft shadows\n                #if ENABLE_SOFT_SHADOWS\n                    diffuse *= softShadow(p + 2.0 * SSDW_EPS * n, -LIGHT_DIR);\n\n                // Boring hard shadows\n                #else\n                    // Ray march towards light\n                    vec4 lm = march(p + 2.0 * MARCH_EPS * n, -LIGHT_DIR);\n\n                    // If doesn't escape to infinity, remove lighting value\n                    if (lm.w >= 0.0)\n                        diffuse = 0.0;\n\n                #endif\n    \t\t}\n\n        #endif\n        \n        \n        // Calculate ambient occlusion\n        #ifdef ENABLE_AO\n        \n        \tambient *= calcAO(p, n);\n        \n        #endif\n        \n\n       \t// Color from lighting values\n        col = clamp(ambient + diffuse * LIGHT_DIFFUSE, vec3(0.0), vec3(1.0));\n\n    }\n    // Stopped at max distance\n    else\n    {\n        col = mix(texture(iChannel0, 4.0 * uv / (length(uv) + 2.0)).xyz, vec3(.15), .9);\n    }\n    \n    // If ended loop at max number of steps\n    if (false && abs(nsteps) >= float(MARCH_STEPS))\n    {\n        col.r = mix(col.r, 1.0, .8);\n    }\n    \n    // Tone mapping\n    #if ENABLE_TONE_MAPPING\n    \n    \tcol = 1.0 - LN_2_INV * log(exp(EXPOSURE * -col) + 1.0);\n    \n    #endif\n    \n    // Fragment with color and 1.0 alpha\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}