{"ver":"0.1","info":{"id":"X3tXDN","date":"1719059759","viewed":15,"name":"LorenzDragon's Tail","username":"Grendor","description":"Lorenz Attractor","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lorenzattractor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy shader for enhanced Lorenz Attractor\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time variable\n    float time = iTime * 0.1;\n\n    // Parameters for Lorenz attractor\n    float sigma = 10.0;\n    float rho = 28.0;\n    float beta = 8.0 / 3.0;\n\n    // Initial conditions\n    vec3 p = vec3(0.4, -0.1, 0.0);\n\n    // Number of steps and time step size\n    int steps = 250;\n    float dt = 0.007+ iTime*0.0001 + iTime * 0.00001;\n\n    // Accumulate color\n    vec3 color = vec3(0.0);\n\n    // Integrate Lorenz equations using Euler method\n    for (int i = 0; i < steps; i++)\n    {\n        vec3 dp;\n        dp.x = sigma * (p.y - p.x);\n        dp.y = p.x * (rho - p.z) - p.y;\n        dp.z = p.x * p.y - beta * p.z;\n        p += dp * dt;\n\n        // Map attractor's coordinates to screen space\n        vec2 attractorPos = (p.xy + vec2(20.0)) / 40.0;\n        attractorPos = attractorPos * 2.0 - 1.0;\n        attractorPos.x *= iResolution.x / iResolution.y;\n\n        // Calculate distance and intensity\n        float dist = length(uv - attractorPos);\n        float intensity = 0.005 / (dist * dist);\n\n        // Accumulate color\n        color += 0.005 * intensity * vec3(0.5 + 0.5 * sin(time + float(i) * 0.01), 0.5 + 0.5 * cos(time + float(i) * 0.01), 0.5 + 0.5 * sin(time + float(i) * 0.02));\n    }\n\n    // Output final color\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}