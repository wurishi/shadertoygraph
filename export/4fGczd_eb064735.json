{"ver":"0.1","info":{"id":"4fGczd","date":"1732220667","viewed":36,"name":" Uitvinding van de Stoommachine","username":"Mirtheamvm","description":"Uitvinding van de Stoommachine (18e eeuw)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["stoommachine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader for \"Invention of the Steam Engine\" with enhanced depth, shadow, and industrial color scheme\n\n// User parameters\nuniform float tech_input;      // Technology input for sigmoid function\n\n#define AA 2  // Set AA to 1 if your machine is too slow\n#define METHOD 3\n\n// Sigmoid function for technology growth\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n// Function to compute the quaternion constant c based on the \"Invention of the Steam Engine\"\nvec4 computeC(float time) {\n    float health;\n    float freedom;\n    float interconnectivity;\n    float tech_factor = sigmoid(tech_input);\n\n    // CARE values for the \"Invention of the Steam Engine\"\n    if (time < 0.33) {  // Early phase\n        health = 4.0;\n        freedom = 3.0;\n        interconnectivity = 5.0;\n    } else if (time < 0.66) {  // Acceleration phase\n        health = 5.0;\n        freedom = 6.0;\n        interconnectivity = 7.0;\n    } else {  // Maturity phase\n        health = 6.0;\n        freedom = 7.0;\n        interconnectivity = 8.0;\n    }\n\n    // Normalize the CARE values and compute the quaternion constant\n    return vec4(\n        (5.0 + min(health, 8.5)) / 10.0 * (5.0 + min(freedom, 8.5)) / 10.0 * (5.0 + min(interconnectivity, 8.5)) / 10.0 * tech_factor,\n        0.8 * (5.0 + health) / 10.0 * sin(time * 0.7),\n        0.8 * (5.0 + freedom) / 10.0 * cos(time * 0.5),\n        0.8 * (5.0 + interconnectivity) / 10.0\n    );\n}\n\nvec4 qsqr(in vec4 a) {\n    return vec4(\n        a.x * a.x - a.y * a.y - a.z * a.z - a.w * a.w,\n        2.0 * a.x * a.y,\n        2.0 * a.x * a.z,\n        2.0 * a.x * a.w\n    );\n}\n\nconst int numIterations = 1500; // Higher number of iterations for more detail\n\n// Function to map the fractal and limit bailout-radius for stability\nfloat map(in vec3 p, out vec4 oTrap, in vec4 c, out float iteration) {\n    vec4 z = vec4(p, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z, z);\n    oTrap = vec4(abs(z.xyz), dot(z, z));\n\n    iteration = 0.0;\n    for (int i = 0; i < numIterations; i++) {\n        md2 *= 4.0 * mz2;\n        z = qsqr(z) + c;\n\n        // Add subtle noise for organic deformation\n        z.xyz += 0.1 * sin(5.0 * z.xyz + iTime * 0.04);\n\n        // Orbit trap to enhance visual detail\n        oTrap = min(oTrap, vec4(abs(z.xyz), dot(z, z)));\n        mz2 = dot(z, z);\n        iteration += 1.0;\n\n        // Adjust the bailout threshold for stability and visibility\n        if (mz2 > 30.0) break;\n    }\n\n    return 0.03 * sqrt(mz2 / md2) * log(mz2);  // Adjusted scaling factor for visibility\n}\n\n// Function to get industrial colors for the steam engine theme\nvec3 getSteamEngineColor(float health, float freedom, float interconnectivity) {\n    float totalCARE = (health + freedom + interconnectivity) / 3.0;\n\n    // Define industrial colors\n    vec3 darkSteel = vec3(0.2, 0.2, 0.3);  // Dark steel color\n    vec3 rustyBrown = vec3(0.6, 0.3, 0.1);  // Rusty brown\n    vec3 copper = vec3(0.8, 0.5, 0.2);  // Copper tone\n    vec3 lightGrey = vec3(0.85, 0.85, 0.85);  // Light grey for highlights\n\n    // Gradual transitions between steam engine-inspired colors\n    if (totalCARE <= 5.0) {\n        return mix(darkSteel, rustyBrown, totalCARE / 5.0);  // Transition from steel to rust\n    }\n    if (totalCARE <= 6.0) {\n        return mix(rustyBrown, copper, (totalCARE - 5.0));  // Transition from rust to copper\n    }\n    return mix(copper, lightGrey, (totalCARE - 6.0));  // Transition from copper to light grey\n}\n\n// Function to adjust color based on the CARE-scores using steam engine colors\nvec3 getColor(float iteration, float maxIteration, vec4 oTrap, float health, float freedom, float interconnectivity) {\n    float t = iteration / maxIteration;\n\n    // Get the steam engine color based on CARE values\n    vec3 baseColor = getSteamEngineColor(health, freedom, interconnectivity);\n    \n    // Add orbit trap influence to color for more visual complexity\n    baseColor += 0.15 * vec3(oTrap.x, oTrap.y, oTrap.z) * (1.0 - t);\n    return baseColor;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in vec4 c, out vec4 res, out float iteration) {\n    vec4 tmp;\n    float resT = -1.0;\n    float maxd = 35.0;  // Increased maximum distance for depth\n    float h = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 1500; i++) {\n        if (h < 0.0001 || t > maxd) break;\n        h = map(ro + rd * t, tmp, c, iteration);\n        t += h;\n    }\n    if (t < maxd) {\n        resT = t;\n        res = tmp;\n    }\n    return resT;\n}\n\n// Function to render the fractal and ensure it remains visible\nvec3 render(in vec3 ro, in vec3 rd, in vec4 c, float health, float freedom, float interconnectivity) {\n    const vec3 sun = vec3(0.577, 0.577, 0.577);\n\n    vec4 tra;\n    float iteration;\n    float t = intersect(ro, rd, c, tra, iteration);\n\n    vec3 col;\n    if (t < 0.0) {\n        // Background with consistent beige color\n        col = vec3(0.94, 0.87, 0.78) * (0.7 + 0.3 * rd.y); // Beige background\n    } else {\n        vec3 mate = vec3(0.7, 0.5, 0.3) * 0.3; // Metallic material with copper influence\n        vec3 pos = ro + t * rd;\n        vec3 nor = normalize(pos);  // Normal approximation\n\n        // Get color based on iteration count and orbit trap using the steam engine color scheme\n        col = getColor(iteration, float(numIterations), tra, health, freedom, interconnectivity);\n\n        // Add some subsurface scattering effect for depth\n        float subsurface = clamp(dot(rd, nor) + 0.5, 0.0, 1.0);\n        col += mate * 0.6 * subsurface;\n\n        // Sun lighting with more contrast\n        vec3 lig = sun;\n        float dif = clamp(dot(lig, nor), 0.0, 1.0);\n        col += mate * vec3(1.0, 0.9, 0.8) * dif;\n\n        // Stronger shadows for realistic shading\n        float shadow = 0.6 + 0.4 * cos(t + iTime * 0.05);\n        col *= shadow;\n\n        // Brightness variation for depth perception\n        col *= 0.9 + 0.2 * sin(iTime * 0.1 + iteration);\n    }\n\n    return pow(col, vec3(0.4545));  // Gamma correction for realistic brightness and contrast\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Parameters for animation\n    float time = iTime * 0.0025;  // Slower movement for a calmer effect\n    vec4 c = computeC(time);\n\n    // Set up the camera\n    float r = 3.0;  // Zoom level\nvec3 ro = vec3(r * cos(0.3 + 0.37 * time), 0.3 + 0.8 * r * cos(1.0 + 0.33 * time), r * cos(2.2 + 0.31 * time));\nvec3 ta = vec3(0.0, 0.0, 0.0);\nfloat cr = 0.1 * cos(0.1 * time);\n\n// Compute camera direction vectors\nvec3 cw = normalize(ta - ro);\nvec3 cp = vec3(sin(cr), cos(cr), 0.0);\nvec3 cu = normalize(cross(cw, cp));\nvec3 cv = normalize(cross(cu, cw));\n\n// Ray direction\nvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\nvec3 rd = normalize(p.x * cu + p.y * cv + 2.0 * cw);\n\n// CARE parameters for the \"Invention of the Steam Engine\"\nfloat health, freedom, interconnectivity;\nif (time < 0.33) {\n    // Early phase\n    health = 4.0;\n    freedom = 3.0;\n    interconnectivity = 5.0;\n} else if (time < 0.66) {\n    // Acceleration phase\n    health = 5.0;\n    freedom = 6.0;\n    interconnectivity = 7.0;\n} else {\n    // Maturity phase\n    health = 6.0;\n    freedom = 7.0;\n    interconnectivity = 8.0;\n}\n\n// Render the scene with the steam engine-based color scheme\nvec3 col = render(ro, rd, c, health, freedom, interconnectivity);\n\nfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}