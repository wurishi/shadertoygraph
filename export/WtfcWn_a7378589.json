{"ver":"0.1","info":{"id":"WtfcWn","date":"1591761323","viewed":431,"name":"Grid Ripples","username":"ShnitzelKiller","description":"Testing out a simple way of creating ripples around grid cells using 6 basis functions instead of enumerating all cases like marching squares.","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["2d","ripples","grid","water","marching","squares"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CELL_SIZE 0.05\n//#define SMOOTH_OFFSET 0.2\n#define DENSITY 0.7\n\nfloat rand(in vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\n//1 if there is land, 0 otherwise\nfloat occupancy(in vec2 id) {\n    return step(DENSITY, rand(id));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x/CELL_SIZE + vec2(0.5, 1.7) * iTime + iMouse.xy*CELL_SIZE;\n    vec2 id = floor(uv);\n    vec2 id2 = floor(uv + 0.5);\n    vec2 modpos2 = fract(uv + 0.5)-0.5;\n    \n    vec3 offsets = vec3(-1.,0.,1);\n    bool occ00 = occupancy(id2) > 0.5;\n    bool occ11 = occupancy(id2+offsets.xx) > 0.5;\n    bool occ10 = occupancy(id2+offsets.xy) > 0.5;\n    bool occ01 = occupancy(id2+offsets.yx) > 0.5;\n    \n    //compose wave pattern within each offset grid cell (where each corner is at the center of one of the visual grid cells).\n    //one basis function for each corner block, plus two basis functions for the cases where two opposite corners are occupied\n    //(this gives the smooth ripples in concave regions).\n    float height = 100.;\n    if (occ00)\n    \theight = min(height, length(max(vec2(0.), -modpos2)));\n    if (occ11)\n    \theight = min(height, length(max(vec2(0.), modpos2*offsets.zz)));\n    if (occ10)\n        height = min(height, length(max(vec2(0.), modpos2*offsets.zx)));\n    if (occ01)\n        height = min(height, length(max(vec2(0.), modpos2*offsets.xz)));\n    if (occ11 && occ00) {\n        height = min(height, 0.5-min(length(modpos2 + 0.5*offsets.zx), length(modpos2+0.5*offsets.xz)));\n    }\n    if (occ01 && occ10) {\n        height = min(height, 0.5-min(length(modpos2 + 0.5*offsets.xx), length(modpos2+0.5*offsets.zz)));\n    }\n    /*if (occ11 && occ00) {\n        height = min(height, 0.5-SMOOTH_OFFSET-min(length(min(vec2(0.), (modpos2 + (0.5-SMOOTH_OFFSET)*offsets.zx)*offsets.xz)), length(min(vec2(0.), (modpos2+(0.5-SMOOTH_OFFSET)*offsets.xz)*offsets.zx))));\n    }*/\n    \n    // minimalistic rendering\n    float wavefac = exp(-max(0.,height)*10.) * sin(height*50. - iTime * 5.)*.5+.5;\n    vec2 modpos = fract(uv);\n    modpos = abs(modpos-0.5);\n    modpos *= modpos;\n    fragColor = vec4(mix(mix(vec3(0., 0.4, 1.), vec3(0., 1., 1.), vec3(wavefac)), vec3(0.7, 0.6, 0.4) * 1.-max(modpos.x, modpos.y), vec3(occupancy(id))) ,1.0);\n}","name":"Image","description":"","type":"image"}]}