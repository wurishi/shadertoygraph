{"ver":"0.1","info":{"id":"4cVyWy","date":"1732579630","viewed":45,"name":"fractal ediiitor","username":"hakrackete","description":"change playground size\nalter operations (classic mandelbrot, burnig ship)\nZoom in and out via (K/L)\nexplore Regions of interest with WASD\n\nsingle precision","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["complexnumbers"],"hasliked":0,"parentid":"dljSz3","parentname":"Complex Numbers with Matrices"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Pi = 3.14159265358979f;\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(a.x * b.x - a.y*b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cpot(vec2 z , float n){\n    float r = length(z);\n    float theta = atan(z.y,z.x);\n    r = pow(r,n);\n    theta = theta * n;\n\n    return r * vec2(cos(theta),sin(theta));\n}\n\nvec2 classic(vec2 z,vec2 c){\n    return cmul(z,z) +c;\n}\n\nvec2 classic2(vec2 z,vec2 c){\n    return cpot(z,2.0) +c;\n}\n\nvec2 burning(vec2 z,vec2 c){\n    z = abs(z);\n\n    return cmul(z,z) + c;\n}\n\nvec2 burning2(vec2 z,vec2 c){\n    z = abs(z);\n\n    return cpot(z,2.0) + c;\n}\n\nvec2 whack(vec2 z,vec2 c){\n    z.x = z.x * abs(sin((iMouse.x/10.0) * z.x));\n    return cmul(z,z) + c;\n}\n\nvec2 invc(vec2 z,vec2 c){\n    return cpot(z,2.0) + cpot(c,(iMouse.x/100.0) - 10.0);\n}\n\nvec2 invcburning(vec2 z,vec2 c){\n    z = abs(z);\n    return cpot(z,2.0) + cpot(c,(iMouse.x/50.0) - 10.0);\n}\n\nvec2 invcburning2(vec2 z,vec2 c){\n    z = abs(z);\n    return cpot(z,(iMouse.y/50.0) - 2.0) + cpot(c,(iMouse.x/50.0) - 10.0);\n}\nvec2 invcclassic2(vec2 z,vec2 c){\n    return cpot(z,(iMouse.y/50.0) - 2.0) + cpot(c,(iMouse.x/50.0) - 10.0);\n}\n\nvec2 halfburning(vec2 z,vec2 c){\n\n    return cmul(abs(z),z) + c;\n}\n\n\nvec2 julia(vec2 z,vec2 c){\n\n    return cpot(z,2.0) + (iMouse.xy / iResolution.xy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\n    float zoomlevel = texelFetch(iChannel1,ivec2(1),0).x;\n    float zoom = 1.0 / pow(2.0,zoomlevel - 1.) ;\n\n    vec2 poi= vec2(0.0);\n    float escapeRad = 3.0 ;\n    vec2 offset = vec2(texelFetch(iChannel1,ivec2(0),0));\n    float max_iter = 300.0;\n\n    // compute multiple cells per pixel and take average\n\n\n    float jitter_x = 2.0;\n    float jitter_y = 2.0;\n    float sx = 1.0/jitter_x;\n    float sy = 1.0/jitter_y;\n\n    for (float i = 0.0; i<jitter_x; i++){\n        for (float j = 0.0; j<jitter_y; j++){\n            vec2 jitter = vec2((0.5 + i) * sx,(0.5 + j) * sy);\n        }\n    }\n    vec3 finalcol = vec3(0.0);\n    for (float i = 0.0; i<jitter_x; i++){\n        for (float j = 0.0; j<jitter_y; j++){\n            vec2 jitter = vec2((0.5 + i) * sx,(0.5 + j) * sy);\n            // Normalized pixel coordinates (from -1 to 1)\n            vec2 uv = (2.0f*(fragCoord+ jitter) - iResolution.xy)/iResolution.y;\n            uv *= zoom;\n            uv -= (poi + offset);\n\n\n            vec2 c = uv;\n            vec2 z = c;\n            //max_iter = 80.0;\n\n\n            float it = 0.0f;\n            for(it = 0.0f; it < max_iter; it++){\n                z = burning(z,c);\n                // z = burning2(z,c);\n                // z = classic(z,c);\n                // z = classic2(z,c);\n                // z = julia(z,c);\n                // z = invc(z,c);\n                // z = invcclassic2(z,c);\n\n                // z = halfburning(z,c);\n\n                if(length(z) > escapeRad)\n                    break;\n            }\n            float continous = it + 1.0 - (log(2.0) / length(z)) / log(2.0);\n            //continous = it ;\n\n            vec3 yellow = vec3(1.0,1.0,0.0);\n            vec3 blue = vec3(0.329,0.855,1.0);\n            vec3 col = vec3(0.0);\n            float t = it/max_iter;\n            col.x = (sin(0.16 * continous + 2.0) + 1.0) / 2.0;\n            //col.x = (cos(2.0 *Pi * t) + 0.0) / 2.0;\n\n            col.y = (sin(0.015 * continous + 0.0) + 1.0) / 2.0;\n            // col.y = (cos(2.0 *Pi * t) + 1.0) / 2.0;\n            col.y = pow(t,.5);\n\n            col.z = (sin(1.3 * continous  +2.0) + 1.0) / 2.0;\n            col.z = pow(t,0.1);\n\n\n            if (it == max_iter){\n                col = vec3(0.0);\n            }\n            finalcol += col;\n        }\n    }\n    finalcol /= (jitter_x * jitter_y);\n    fragColor = vec4(finalcol,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        fragColor = vec4(0.0); // All zeros\n    }\n    \n    vec4 key_W = texture(iChannel1, vec2(87.0 / 256.0, 0.0)); // ASCII 87 = 'W'\n    vec4 key_A = texture(iChannel1, vec2(65.0 / 256.0, 0.0)); // ASCII 65 = 'A'\n    vec4 key_S = texture(iChannel1, vec2(83.0 / 256.0, 0.0)); // ASCII 83 = 'S'\n    vec4 key_D = texture(iChannel1, vec2(68.0 / 256.0, 0.0)); // ASCII 68 = 'D'\n    vec4 key_K = texture(iChannel1, vec2(75.0 / 256.0, 0.0)); // ASCII 75 = 'K'\n    vec4 key_L = texture(iChannel1, vec2(76.0 / 256.0, 0.0)); // ASCII 76 = 'L'\n\n\n    // Tastenstatus\n    bool W = key_W.r > 0.5;\n    bool A = key_A.r > 0.5;\n    bool S = key_S.r > 0.5;\n    bool D = key_D.r > 0.5;\n    bool K = key_K.r > 0.5;\n    bool L = key_L.r > 0.5;\n\n    float zoomspeed = 2.0;\n    float movespeed = 0.06;\n\n    if(fragCoord == vec2(0.5)) {  \n        float zoomlevel = texelFetch(iChannel0,ivec2(1),0).x;\n        float zoom = 1.0 / pow(2.0,zoomlevel - 1.) ;\n        // Keyboard Buffer auslesen (256 Pixel, 1D-Textur)\n        \n        \n        vec4 prev = texelFetch(iChannel0,ivec2(fragCoord.xy),0);\n        fragColor = prev; \n        if (W){\n            fragColor.y -= movespeed*zoom;\n        }\n        if (S){\n            fragColor.y += movespeed*zoom;\n        }\n        if (A){\n            fragColor.x += movespeed*zoom;\n        }\n        if (D){\n            fragColor.x -= movespeed*zoom;\n        }}\n    if(fragCoord == vec2(1.5)) {\n        vec4 prev = texelFetch(iChannel0,ivec2(fragCoord.xy),0);\n        fragColor = prev;\n        if (L){\n            fragColor.x += zoomspeed * iTimeDelta;\n        }\n        if (K){\n            fragColor.x -=  zoomspeed * iTimeDelta;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}