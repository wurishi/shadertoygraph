{"ver":"0.1","info":{"id":"wlVGRV","date":"1579679425","viewed":726,"name":"Better marching (updated)","username":"NLIBS","description":"-Dynamic relaxed sphere tracing (seems to always be faster)\n-Early sky detection (would only work for this fractal)\nIt's all at line 102\nCircle colours : outline=overstep, red=slow raymarching, green=fast raymarching, blue/purple=early sky detection","likes":17,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","fast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nExplanation:\n\n\tEarly sky detecion:\n\n\tIf the point in question returns a large enough distance and \n\tits direction from the origin (0,0,0) is similar to the ray \n\tdirection, it is safe to assume the ray will never hit the \n\tobject again, saving alot of time marching into the distance.\n\n\n\tRelaxed sphere tracing:\n\n\tThis is an old technique. You start your marching with an \n\tomega value. This value multiplies the distance at each step\n\tso that marching is faster. The Only problem is that you \n\tmight march right past something (overstep), but its easy to\n\tdetect if this happened. Just see if the previous distance \n\tplus the Current distance is smaller that what you just \n\tstepped by, and if so go back a bit to make sure you are \n\tcorrect. With this old technique the omega value is set \n\tto 1 after an overstep is detected. But we can do better!\n\n\n\tDynamic relaxed sphere tracing (I just made this up):\n\n\tInstead of just reverting to normal raymarching after an\n\toverstep, simply solve for the highest value of omega that\n\tWouldn't have caused any problems and set it to that! \n\tIts also easy to extend on this by bringing the omega closer\n\tto this optimum amount each step, meaning the marching speed\n\tis always as fast as possible! \n\tWe can also use the distance that was calculated at the \n\toverstep point so that no information is thrown away. (line 140)\n\t\n\n\tThanks, I hope this can help someone out!\n*/\n\n//Ps you can comment line 146 to see normal raymarching instead.\n\n\n\n//fractal params\nconst float w0 = 0.;\nconst float scaleM = 2.;\nconst float iters = 8.;\nconst vec4 offsetM = vec4(0,0,0,0.1);\nconst vec4 ScaleC = vec4(1.,1.,1.,0.5);\nconst vec4 scaleC_c = vec4(\n \tScaleC.x*(scaleM-1.)    /scaleM, // the divide is for more _c\n    ScaleC.y*(scaleM-1.)    /scaleM,\n    ScaleC.z*(scaleM-1.)/scaleM*0.5,\n    ScaleC.w*(scaleM-1.)    /scaleM\n);\nconst float scaleC_c2 = scaleC_c.z*.5;\n\n#define angle 0.12\nconst mat2 rot2D = mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n\n//Mixpinski\nfloat de(vec3 p){\n\tvec4 z = vec4(p,w0);\n\n    float i = 0.;\n\tfloat r = 0.;   \n    for (; i<iters; i++){\n        if(z.x+z.y<0.0) z.xy = -z.yx;\n\t\tif(z.x+z.z<0.0) z.xz = -z.zx;\n        if(z.y+z.z<0.0) z.yz = -z.zy;\n        if(z.x+z.w<0.0) z.xw = -z.wx;\n\t\tif(z.y+z.w<0.0) z.yw = -z.wy;\n\t\tif(z.z+z.w<0.0) z.zw = -z.wz;\n\n\t\tz += offsetM;\n        z = scaleM*vec4(z.xyw-scaleC_c.xyw,scaleC_c2-(z.z-scaleC_c2)*sign(z.z)).xywz;\n        z.xy *= rot2D;\n\t}\n\n    return length(z)*exp2(-i)-1./exp2(iters); //.0017\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Boring variables\n    float stime = (iTime+5.5)*0.31415;\n    float zslice = -.158;//cos(stime);\n    vec3 spos = vec3((fragCoord-iResolution.xy*.5f)/iResolution.x * 5.,zslice);\n    vec3 rd = vec3(cos(sin(stime)*.5+.6),sin(sin(stime)*.5+.6),0);\n    vec2 mouseUV = (iMouse.xy-iResolution.xy*.5f)/iResolution.x * 5.;\n    vec3 ro = vec3(mouseUV,zslice);\n    float T = 0.;\n    \n    //Colour \n    float h = de(spos);\n    vec3 col = vec3((6.-h)*0.04);\n    if (h<=0.) col = vec3(1); //.002\n    \n    \n    //The interesting part\n    float omega = 1.;\n    float pom = 1.;\n    float ph = 1e5;\n    vec2 gap = vec2(0.,0.);\n    for (int i = 0; i<10; ++i) {\n        //Position and distance estimation\n        vec3 p = ro+T*rd;\n        h = de(p);\n        \n        //Drawing circles\n        vec2 shade = mix(vec2(0.1,0.9),vec2(0.9,0.1),smoothstep(1.,2.,omega));\n        float edge = clamp((h-length(spos-p))*100.+1.,0.,1.);\n        col.xy = mix(col.xy, col.xy*shade+1.-shade, edge);\n\t\t//for (int i2 = 0; i2<i+1; i2++) {\n        //   \tcol += step(length(spos-p-vec3((float(i2)-float(i)/2.)*0.03,0,0)),.01)*2.*sign(float(i%2)-.5);\n        //}\n        \n        //Overstep recovery\n        float om = (ph+h)/ph;\n        if (om<pom && pom > 1.) { //ph+h<ph*pom\n            col -= smoothstep(0.008,.0,abs(h-length(spos-p)))*6.; //Draw a black outline\n            \n            gap = vec2(h,T);\n            T+=(1.-pom)*ph;\n            pom = 1.;\n            \n        } else {\n            if (h>.2 && dot(p,rd)>0.3) { //Sky bailout\n            \tif (length(spos-p)<h) col.b = col.b*0.1+0.9; \n            \tbreak;\n            }\n            \n            //Variable updates\n        \tT += h * omega;\n            ph = h;\n            pom = omega;\n            \n            //Back to the place where the gap opened (foward)\n        \tif (T>=gap.y-gap.x && gap.y+gap.x > T) {T = gap.y+gap.x*omega; ph = gap.x;};\n        }\n        \n          \n        //Dynamic Omega \n        //omega = clamp((omega+om)*.5,1.,3.);\n        omega = clamp(omega+(om-omega)*.6,1.,3.);\n    }\n\t\n\t\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}