{"ver":"0.1","info":{"id":"4cjfDz","date":"1730615112","viewed":37,"name":"09 - Torus. Rainbow and pulse","username":"scozz","description":"torus with a variety of effects","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 100;\nconst float MAX_DIST = 20.0;\nconst float SURF_DIST = 0.001;\nvec3 light_dir = normalize(vec3(1.0, -1.0, -1.0));\nvec3 light2_dir =  normalize(vec3(-0.5, -1.0, 1.0));\nvec3 light_color = vec3(1.2, 0.4, 0.7);  // Warm light (slight orange)\nvec3 light2_color = vec3(1.0, 0.8, 0.7);  // Cool light (slight blue)\n\nconst float GRAIN_INTENSITY = 0.0241;\n\nconst float DISPERSION_STRENGTH = 0.95;\nconst float RAINBOW_FREQ = 0.5;\n\n//draw a torus\nfloat torus_radius = 1.90;\n\n\nfloat sdCyl(vec3 p, float radius, float ringFrequency, float ringAmplitude) {\n    float d = -(length(p.xy) - radius);\n    float rings = sin(p.z * ringFrequency) * ringAmplitude;\n    return d - rings;\n    //return d;\n}\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nvec3 wavelengthToRGB(float w) {\n    // Approximate visible spectrum (380-750nm)\n    vec3 col = vec3(0.0);\n    \n    // Red component\n    col.r = smoothstep(0.0, 0.2, w) - smoothstep(0.8, 1.0, w);\n    // Green component\n    col.g = smoothstep(0.2, 0.4, w) - smoothstep(0.6, 0.8, w);\n    // Blue component\n    col.b = smoothstep(0.4, 0.6, w) - smoothstep(0.8, 1.0, w);\n    \n    return col;\n}\n\n\n//p is the position of the inverted torus.\n//t.x: This is the major radius of the torus. It's the distance from the center of the torus to the center of the tube.\n//t.y: This is the minor radius of the torus. It's the radius of the tube itself.\nfloat sdTorus( vec3 p, vec2 t )\n{\n      float speed = 8.4;\n      float ringFrequency = 10.4;\n\n      float ringAmplitude = 0.012 + sin(p.z + iTime * 3.0) * 0.03 + 0.02;\n      \n      vec2 q = vec2(length(p.zy)-t.x,p.x);\n      // return -(length(q)-t.y);\n      //apply ring change\n      float rings = sin(iTime * speed + (p.z * ringFrequency)) * ringAmplitude;\n      return -(length(q)-t.y) - rings;\n}\n\n\n//only works for 2d\nmat2 rotate2d(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat scene_sdf(vec3 p)\n{\n    // Calculate rotation angle based on time\n    float angle = iTime * 0.2; // Adjust rotation speed here\n    // Translate the point to the torus center and rotate\n    vec3 translated = vec3( vec2(rotate2d(angle) * p.xy) , p.z); \n\n    // Translate back\n    translated += vec3(0.0, -torus_radius, 0.0);\n    // Calculate the SDF for the rotated torus\n    return sdTorus(translated, vec2(torus_radius, 0.2));\n}\n\n\n\n\nfloat ray_march(vec3 ro, vec3 rd)\n{\n    float d0 = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * d0;\n        float ds = scene_sdf(p);\n        d0 += ds;\n        if(abs(ds) < SURF_DIST || d0 > MAX_DIST) {\n            break;\n        }\n    }\n    \n    return d0;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0);\n    return normalize(vec3(\n        scene_sdf(p + e.xyy) - scene_sdf(p - e.xyy),\n        scene_sdf(p + e.yxy) - scene_sdf(p - e.yxy),\n        scene_sdf(p + e.yyx) - scene_sdf(p - e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    torus_radius += sin(iTime)*0.50 + 1.0;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 0.0); //ray origin\n    vec3 rd = normalize(vec3(uv, 1.0)); //ray direction.\n    //Note that the middle ray is straight, all the others are at a slight angle. this is the rays originating from the 2d projection.\n    \n    //the distance the ray travelled before hitting an object\n    float d = ray_march(ro, rd);\n    \n\n      vec3 col = vec3(0.1);\n    \n    if(d < MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = get_normal(p);\n        \n        float ringr = smoothstep(0.40, 0.0, (sin(iTime) * 0.2 +0.5) * p.z);\n        float ringg = smoothstep(0.5, 1.0, (sin(iTime * 0.2) * 0.4 + 5.1) * p.z);\n        float ringb = smoothstep(0.5, 1.0, 2.0*p.z) * 0.4 + 0.6;\n        vec3 base_color = vec3(ringr, ringg, ringb);\n\n        float diff = max(dot(n, light_dir), 0.1);\n        float diff2 = max(dot(n, light2_dir), 0.1);\n\n        vec3 light_contribution = light_color * diff;\n        vec3 light2_contribution = light2_color * diff2;\n        \n        // Calculate prismatic dispersion\n        float view_angle = acos(dot(rd, n));\n        float dispersion = sin(view_angle * RAINBOW_FREQ + iTime*1.5) * DISPERSION_STRENGTH;\n        \n        // Create rainbow effect based on viewing angle and distance\n        vec3 rainbow = wavelengthToRGB(fract(view_angle * 0.3 + dispersion));\n        \n        // Add fresnel-like effect\n        float fresnel = pow(1.0 - abs(dot(rd, n)), 5.0);\n        \n        // Combine colors with rainbow reflection\n        col = base_color * (light_contribution + light2_contribution);\n        col = mix(col, rainbow, fresnel * 0.0050 + 0.04);\n\n        vec3 ambient = vec3(0.01);\n        col += ambient;\n    } else {\n        col = vec3(0.0,0.0,1.0);\n    }\n        \n         // Add purple fog\n        vec3 fog_color = vec3(0.6, 0.0, 0.9); // Purple color\n        float fog_density = 0.15; // Adjust this to control fog thickness\n        float fog_factor = 1.0 - exp(-d * fog_density);\n\n        // Add some movement to the fog\n        //fog_factor += sin(iTime * 0.5 + length(uv)) * 0.1;\n\n        // Ensure fog_factor stays between 0 and 1\n        fog_factor = clamp(fog_factor, 0.0, 1.0);\n\n        // Mix between scene color and fog color\n        col = mix(col, fog_color, fog_factor);\n        \n        // Add film grain\n       //float grain = random(uv + iTime) * GRAIN_INTENSITY;\n\n        // Add subtle grain variation based on luminance\n        //float luma = dot(col, vec3(0.299, 0.587, 0.114));\n        //grain *= (1.0 - luma) * 2.0;\n\n        // Add temporal variation to grain\n        //grain *= (sin(iTime * 1.0) * 0.5 + 1.5);\n\n        // Apply grain\n        //col += vec3(grain);\n\n\n        fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}