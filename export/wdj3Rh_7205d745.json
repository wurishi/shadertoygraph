{"ver":"0.1","info":{"id":"wdj3Rh","date":"1548186045","viewed":91,"name":"2D Distance functions","username":"yashgugale","description":"shader to create an emoji","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["emoji"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCircle(in vec2 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa-ba*h);\n}\n\n// signed distance to a regular octogon\nfloat sdOctogon( in vec2 p, in float r )\n{\n  // pi/8: cos, sin, tan.\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n\n  // reflections\n  p = abs(p);\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n}\n\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        vec2 qos = d + (c + b*t)*t;\n        res = dot(qos,qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        vec2 qos = d + (c + b*t.x)*t.x;\n        res = dot(qos,qos);\n\n        qos = d + (c + b*t.y)*t.y;\n        res = min(res,dot(qos,qos));\n\n        qos = d + (c + b*t.z)*t.z;\n        res = min(res,dot(qos,qos));\n    }\n    \n    return sqrt( res );\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float hors = mod( floor(iDate.w/3600.0), 24.0 );\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tfloat r = length( uv );\n\tfloat a = atan( uv.y, uv.x )+4.1415926;\n    \n\t// background color\n\tvec3 nightColor = vec3( 0.7, 0.2, 0.8 ) + 0.1*uv.y;\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\n\t//vec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - smoothstep(19.0,21.0, hors ) );\n\n    vec3 col = vec3(0.4, 0.8, 0.1);\n    // inner watch body\t\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\n    \n    //uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec2 leftEye = uv;\n    vec2 rightEye = uv;\n    vec2 leftEyeBrow = uv;\n    vec2 rightEyeBrow = uv;\n    vec2 mouth = uv;\n    vec2 triangle = uv;\n    vec2 vrHeadset = uv;\n    \n    vec2 v0 = vec2(1.0,0.9)*cos(1.1 + vec2(0.0,5.0) )/2.0;\n    vec2 v1 = vec2(1.0,0.9)*cos(1.2 + vec2(1.0,4.0) );\n    vec2 v2 = vec2(1.0,0.9)*cos(1.3 + vec2(2.0,1.0) )/2.0;\n    \n    leftEye.x += 0.5;\n    leftEye.y += -0.3;\n\n    rightEye.x += -0.5;\n    rightEye.y += -0.3;\n    \n\tmouth.y += 0.6;\n\n    leftEyeBrow.y /= 0.5;\n\tleftEyeBrow.y -= 0.9;\n    leftEyeBrow.x += 0.4;\n    \n    rightEyeBrow.y /= 0.5;\n\trightEyeBrow.y -= 0.9;\n    rightEyeBrow.x -= 0.4;\n    \n    triangle.x *= 4.0;\n    triangle.y *= 4.0;\n    \n    vrHeadset.x += 0.0;\n    vrHeadset.y += -0.2;\n    \n    float d1 = sdCircle(leftEye, 0.2);\n    float d2 = sdCircle(rightEye, 0.2);\n    float d3 = sdEllipse(vrHeadset, vec2(0.9, 0.5));\n    float d4 = sdBezier( leftEyeBrow, v0,v1,v2 );\n    float d5 = sdBezier( rightEyeBrow, v0,v1,v2 );  \n    float d6 = sdOctogon(mouth, 0.2); \n    float d7 = sdEquilateralTriangle(triangle);\n    \n\n\n\n    \n    col *= vec3(1.0) + sign(d1) * vec3(0.8, 0.4, 0.7);\n    col *= vec3(1.0) + sign(d2) * vec3(0.7, 0.4, 0.7);\n    col *= vec3(1.0) - sign(d3) * vec3(0.1, 0.4, 0.7);\n    \n\tcol *= 1.0 - exp(-4.0*abs(d4));\n    col *= 1.0 - exp(-4.0*abs(d5));\n    \n    col *= vec3(1.0) - sign(d6) *vec3(0.7, 0.4, 0.3);\n    col *= vec3(1.0) - sign(d7) * vec3(0.2, 0.5, 0.7);\n    // Time varying pixel color\n\n    //col = vec3(1.0) - vec3(0.0, 1.0, 1.0) * sign(d1);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n\n    \n}","name":"Image","description":"","type":"image"}]}