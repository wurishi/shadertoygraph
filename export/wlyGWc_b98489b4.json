{"ver":"0.1","info":{"id":"wlyGWc","date":"1580052685","viewed":605,"name":"Unbiased Progressive MIS PT","username":"Kiord","description":"Small unbiased(?) progressive MIS path tracer. Mulitple Importance Sampling is done between BSDF(surface) sampling and light sampling techniques. Handling of diffuse and specular BRDF, sphere and triangle primitives, and spherical light sources.","likes":16,"published":1,"flags":48,"usePreview":0,"tags":["globalillumination","pathtracing","mis","path","unbiased","progressive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\t\"Unbiased Progressive MIS PT\" by Kiord\n\tThis shader url : https://www.shadertoy.com/view/wlyGWc\n\tScene concept from E. Veach\n\tCreative Commons Attribution-ShareAlike 4.0 International Public License\n\n*/\n\n/*\n\t--INPUTS--\n\n\tA/D\t\t\t- \tstrafe left/right\n\tW/S\t\t\t- \tmove forward/backward\n\tSPACE/LCTRL\t- \tmove up/down\n\tLSHIFT\t\t- \tdouble translation speed while hold. \n\t\t\t\t\tAlso allows to restart the rendering without moving the camera \n\tARROWS\t\t- \tchange camera direction\n\tT\t\t\t-  \tchange illumination sampling techniques (MIS->light->surface->weights...)\n\n\tChange scene by decomment/comment the initialization functions -> Buffer A -> lines 239/240\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n    \n    \n/*\n     Tone Mapping functions from \"Fast PathTracing[Lab]!\" by 834144373(恬纳微晰)   \n     (url : https://www.shadertoy.com/view/XdVfRm)                               \n*/\n   \n    \n    fragColor.rgb = ExposureCorrect(fragColor.rgb,2.1, -0.8);\n    fragColor.rgb = ACESFilmicToneMapping(fragColor.rgb);\n}\n\n/*\n\tSometimes the FPS decrease by half I don't know why yet...\n\t\n*/\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define UP vec3(0,0,1)\n#define MAXLIGHTS 5\n#define MAXSPHERES 15\n#define MAXTRIANGLES 15\n#define PI 3.1415926536\n#define HALF_PI 1.5707963268\n#define TWO_PI 6.28318530718\n#define FOUR_PI 12.56637061436\n#define Gamma 2.2\n// The two dead pixels in the bottom-left corner are used to store camera transform and samples per pixel\n#define POS_SPP_LOCATION ivec2(0,0)\n#define ROT_TECH_LOCATION ivec2(1,0)\n// Benchmark options\n//#define STOP_TIME 10.0f\n//#define STOP_SAMPLES 64u\nfloat seed;\n// Keycodes\nconst int KEY_DOWN  = 37;const int KEY_LEFT  = 38;const int KEY_UP    = 39;\nconst int KEY_RIGHT = 40;const int KEY_SPACE = 32;const int KEY_CTRL  = 17;\nconst int KEY_Z     = 90;const int KEY_Q     = 81;const int KEY_S     = 83;\nconst int KEY_D     = 68;const int KEY_SHIFT = 16;const int KEY_T     = 84;\n// Scene/inputs parameters\nconst float scene_scale = 1.0f;\nconst float translation_speed = 10.0f * scene_scale;\nconst float rotation_speed = 1.0f;\nconst vec3 BACKGROUND_COLOR = vec3(0.0);\n//#define BACKGROUND_IMAGE(d) texture( iChannel2, d.xzy ).rgb\nconst vec4 INITIAL_POS_SPP = scene_scale * vec4(-40.0f,0.0f,-10.0f,1.0f);\nconst vec4 INITIAL_ROT_TECH = vec4(HALF_PI + 0.1f, 0,0,0);\n// Path tracing algorithm parameters\n#define MAX_DEPTH 5u\n#define SPPPF 1u\n#define RUSSIAN_ROULETTE\n#define ALPHA 0.9f\n#define MIS 0\n#define LIGHT_SAMPLING 1\n#define BSDF_SAMPLING 2\n#define WEIGHTS_VISUALIZATION 3\nconst float dither_amount = 1.0f;\n#define CIRCULAR_DITHER\nconst float epsilon = scene_scale * 0.005f;\n\n\nfloat rand1() {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 rand2() {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 rand3() {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n\nvec3 reflection(vec3 dir, vec3 n){\n\treturn -dir + 2.0f * n * dot(dir, n);\n}\n\nbool isBlack(vec3 col){\n\treturn col.r <= 0.0f && col.g <= 0.0f && col.b <= 0.0f;\n}\n\nbool hasNegative(vec3 col){\n\treturn col.r < 0.0f || col.g < 0.0f || col.b <0.0f;\n}\n\nbool isOk(vec3 col){\n\treturn !hasNegative(col) && !any(isnan(col)) && !any(isinf(col));\n}\n\n\nbool samePoint(vec3 a, vec3 b){\n\treturn length(a-b) <= epsilon;\n}\n\nvec4 quat(vec3 axis, float angle){\n    vec3 u = axis * sin(angle*0.5f);\n    return vec4(u, cos(angle*0.5f));\n}\n\nvec3 rotate(vec4 q, vec3 v){\n    vec3 u = q.xyz;\n    float s = q.w;\n    return 2.0f * dot(u, v) * u\n          + (s*s - dot(u, u)) * v\n          + 2.0f * s * cross(u, v);\n}\n\nvec3 rotate(vec3 axis, float angle, vec3 v){\n    float s = sin(angle*0.5f);\n    vec3 u = axis * s;\n    float w = cos(angle*0.5f);\n    \n    return 2.0f * dot(v, u) * u +\n           (w*w  - dot(u,u)) * v +\n           2.0f * w * cross(u, v);\n\n}\n\nvec3 polarToCartesian(vec2 polar){\n\treturn vec3(sin(polar.x) * cos(polar.y), sin(polar.x) * sin(polar.y), cos(polar.x));\n}\n \n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat3(oc * axis.x * axis.x + c         ,  oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, \toc * axis.y * axis.y + c\t\t ,  oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s, \toc * axis.z * axis.z + c\t\t );\n}\n\n\nstruct Camera{\n\tvec3 position;\n    vec3 front;\n    vec3 right;\n    vec3 down;\n    vec2 plane;\n};\n\nstruct PointLight{\n\tvec3 position;\n    vec3 color;\n};\n\nstruct Material{\n    vec3 albedo;\n    vec3 emissive;\n    float shininess;\n};\n    \nstruct Sphere{\n\tvec3 position;\n    float radius;\n    float radius2;\n    Material material;\n};\n    \nstruct Triangle{\n\tvec3 v0;\n    vec3 v1;\n    vec3 v2;\n    Material material;\n};\n\nstruct Scene{\n    Camera camera;\n\tPointLight[MAXLIGHTS] lights;\n    Sphere[MAXSPHERES] spheres;\n \tTriangle[MAXTRIANGLES] triangles;\n    uint[MAXSPHERES] light_spheres;\n    uint[MAXTRIANGLES] light_triangles;\n\tuint nbLights;\n    uint nbLightSpheres;\n    uint nbLightTriangles;\n    uint nbSpheres;\n    uint nbTriangles;\n};\n\nstruct Ray{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct SurfaceLightSample{\n    float pdf;\n    Sphere sphere;\n    vec3 point;\n    vec3 normal;\n};\n    \nstruct DirectionSample{\n    float pdf;\n    vec3 bsdf;\n    vec3 direction;\n};\n    \nstruct Intersection{\n\tbool hit;\n    vec3 point;\n    float t;\n    vec3 normal;\n    Ray ray;\n    Material material;\n    int tptr;\n    int sptr;\n};\n    \nbool isEmissive(in Material mat){\n\treturn mat.emissive.r > 0.0f || mat.emissive.g > 0.0f || mat.emissive.b > 0.0f;\n}\n\nCamera makeCamera(vec3 position, vec3 target, vec2 plane){\n\tvec3 front = normalize(target - position);\n\tvec3 right = cross(UP, front);\n    right.z = 0.0f;\n   \tright = right/ length(right);\n    vec3 down= cross(front, right);\n    down = down/length(down);\n    return Camera(position, front, right, down, plane);\n}\n\nCamera makeCameraFromPolar(vec3 position, vec2 polar, vec2 plane){\n\tvec3 front = polarToCartesian(polar);\n\tvec3 right = cross(UP, front);\n    right.z = 0.0f;\n   \tright = right/ length(right);\n    vec3 down= cross(front, right);\n    down = down/length(down);\n    return Camera(position, front, right, down, plane);\n}\n\nCamera makeCameraFromFrontRight(vec3 position, vec3 front, vec3 right, vec2 plane){\n    vec3 down= cross(front, right);\n    down = down/length(down);\n    return Camera(position, front, right, down, plane);\n}\n\nvoid addQuad(vec3 position, vec2 scale, vec3 axis, float angle, in Material material, inout Scene scene){\n    mat3 R = rotationMatrix(axis, angle);\n    vec3 fl = R * vec3(-0.5f*scale.x, -0.5f*scale.y, 0) + position;\n    vec3 fr = R * vec3(-0.5f*scale.x, 0.5f*scale.y, 0) + position;\n    vec3 bl = R * vec3(0.5f*scale.x, -0.5f*scale.y, 0) + position;\n    vec3 br = R * vec3(0.5f*scale.x, 0.5f*scale.y, 0) + position; \n\tscene.triangles[scene.nbTriangles++] = Triangle(fl, fr, br, material);\n    scene.triangles[scene.nbTriangles++] = Triangle(br, bl, fl, material);\n    if(isEmissive(material)){\n    \tscene.light_triangles[scene.nbLightTriangles++] = scene.nbTriangles-2u;\n        scene.light_triangles[scene.nbLightTriangles++] = scene.nbTriangles-1u;\n    }\n}\n\nvoid addCornell(vec3 position, float scale, in Material mground, in Material mfront, in Material mleft, in Material mright,in Material mup, inout Scene scene){\n   \t//ground\n    addQuad(position + scale *  vec3(0.0,0,-0.5), scale * vec2(1.0f), vec3(0,1,0), 0.0f, mground, scene);\n    // front\n    addQuad(position + scale * vec3(0.5,0,0), scale * vec2(1.0f), vec3(0,1,0), HALF_PI, mfront, scene);\n    // left\n    addQuad(position + scale *  vec3(0,0.5,0), scale * vec2(1.0f), vec3(1,0,0), HALF_PI, mleft, scene);\n    // right\n    addQuad(position + scale *  vec3(0,-0.5,0), scale * vec2(1.0f), vec3(1,0,0), -HALF_PI, mright, scene);\n    //up\n    addQuad(position + scale * vec3(0,0,0.5), scale *  vec2(1.0f), vec3(0,1,0), 0.0f, mup, scene);\n}\n\nvoid addSphere(vec3 position, float radius, Material material, inout Scene scene){\n\tscene.spheres[scene.nbSpheres++] = Sphere(position, radius, radius*radius, material);\n    if(isEmissive(material)){\n    \tscene.light_spheres[scene.nbLightSpheres++] = scene.nbSpheres-1u;\n    }\n}\n\nvec2 randomPolar(float n){\n\tvec2 ksi = rand2();\n    float theta = acos( pow( ksi.x, 1.0f/(n+1.0f)));\n    float phi = ksi.y * 2.0f * PI;\n    return vec2(theta, phi);\n}\n\nvec3 randomDirectionHemisphere(vec3 main_direction, float n){\n\tvec2 perturbation = randomPolar(n);\n    vec3 direction = polarToCartesian(perturbation);\n    if(abs(main_direction.z) > 0.99999f) return sign(main_direction.z) * direction;\n    \n    vec3 axis = normalize(cross(UP, main_direction));\n    float angle = acos(main_direction.z);\n   \t\n    return rotate(axis, angle, direction);\n}\n\n\n\nvec3 BSDF(in Intersection inter, vec3 wi, vec3 wo){\n \tfloat n = inter.material.shininess;\n    bool is_lambert = n == 0.0f;\n    float coswi = dot(inter.normal, wi);\n    vec3 r = float(is_lambert) * inter.normal + \n        \t float(!is_lambert) * reflection(wo, inter.normal);\n    float cosr = dot(wi, r);\n    float coswo = clamp(dot(inter.normal, wo), -1.0f, 1.0f);\n    bool ok = (coswi > 0.0f) && (cosr > 0.0f) && (coswo > 0.0f) ;\n\t\n    vec3 bsdf = float(ok) * inter.material.albedo * pow(abs(cosr), n) * (n + 1.0f + float(is_lambert)) / TWO_PI;\n    return bsdf;\n}\n\n\nvoid sample_BSDF(in Intersection inter, inout DirectionSample ds){\n    float n = inter.material.shininess;\n    bool is_lambert = n==0.0f;\n    vec3 r = float(is_lambert) * inter.normal + \n        \t float(!is_lambert) * reflection(-inter.ray.direction, inter.normal);\n    \n    ds.direction = randomDirectionHemisphere(r, max(n,1.0f));\n    float cosr = dot(r, ds.direction);\n    float correct_r = float(cosr > 0.0f) - float(cosr <= 0.0f);\n    \n    cosr *= correct_r;\n    ds.direction *= correct_r;\n    \n    float coswo = dot(inter.normal, ds.direction);\n    bool ok = coswo > 0.0f;\n    float cosr_pow_n = pow( abs(cosr),n);\n\t\n\tfloat w = (n + 1.0f + float(is_lambert))/ TWO_PI;\n    \t\n    ds.pdf = w * (float(is_lambert) * coswo + \n                  float(!is_lambert) * cosr_pow_n);\n    ds.bsdf = float(ok) * w * inter.material.albedo * cosr_pow_n ;\n}\n\n\nfloat PDF(in Intersection inter,  vec3 wo){\n    float n = inter.material.shininess;\n    bool is_lambert = n==0.0f;\n    vec3 r = float(is_lambert) * inter.normal + \n        \t float(!is_lambert) * reflection(-inter.ray.direction, inter.normal);\n    float cosr = dot(r, wo);\n    float cosr_pow_n = pow( abs(cosr),n);\n    float coswo = dot(inter.normal, wo);\n    \n    \n    float w = (n + 1.0f + float(is_lambert))/ TWO_PI;\n    bool ok = cosr * coswo > 0.0f;\n    \n    \n    float pdf =  float(ok) * w * (float(is_lambert) * coswo + \n                  \t\t   float(!is_lambert) * cosr_pow_n); \n    \n    return pdf;\n}\n\n\nIntersection nope(in Ray ray){\n    const Material dummy_mat = Material(vec3(0), vec3(0), 0.0f);\n\treturn Intersection(false, vec3(0.0f), 0.0f, vec3(0), ray, dummy_mat, 0, 0);\n}\n\nIntersection yay(vec3 point, float t, vec3 normal, in Ray ray, in Material material, int tptr, int sptr){\n    bool ok = dot(ray.direction, normal) <= 0.0f;\n    normal *= (1.0 * float(ok) -1.0f * float(!ok));\n\treturn Intersection(true, point,t, normal, ray, material, tptr, sptr);\n}\n\n\nbool raySphereIntersection(in Ray ray, in Sphere sphere, inout Intersection currentInter, int sptr){\n    vec3 oc = ray.origin - sphere.position;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sphere.radius2;\n    float h = b*b - c;\n    if( h<0.0 ) return false;\n    h = sqrt( h );\n    float t1 = -b-h;\n    float t2 = -b+h;\n    float t = 0.0f;\n    if(t1 < 0.0f && t2 < 0.0f) return false;\n    else if(t1 > 0.0f){\n    \tif(t2 > 0.0f) t = min(t1,t2);\n        else t = t1;\n    }else{\n    \tt = t2;\n    }\n    if(t > currentInter.t && currentInter.hit) return true;\n    vec3 point = ray.origin + t *  ray.direction;\n    vec3 normal = (point - sphere.position) / sphere.radius;   \n    currentInter = yay(point, t, normal, ray, sphere.material,  -1, sptr);\n    return true;\n}\n\n// triangle degined by vertices v0, v1 and  v2\nbool rayTriangleIntersection(in Ray ray,  in Triangle tri, inout Intersection currentInter, int tptr)\n{\n    vec3 v1v0 = tri.v1 - tri.v0;\n    vec3 v2v0 = tri.v2 - tri.v0;\n    vec3 rov0 = ray.origin - tri.v0;\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, ray.direction );\n    float d = 1.0/dot( ray.direction, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t <= 0.0f) return false;\n    if(t > currentInter.t && currentInter.hit) return true;\n    vec3 point = ray.origin + ray.direction * t;\n    currentInter = yay(point, t, normalize(n), ray, tri.material, tptr, -1);\n    return true;\n}\n\n\n\nbool raySceneIntersection(in Ray ray, in Scene scene, inout Intersection inter){\n    for(uint i = 0u ; i < scene.nbSpheres ; ++i){\n    \traySphereIntersection(ray, scene.spheres[i], inter, int(i));\n    }\n    for(uint i = 0u ; i < scene.nbTriangles ; ++i){\n    \trayTriangleIntersection(ray, scene.triangles[i], inter, int(i));\n    }\n    return inter.hit;\n}\n\nbool visibility(in Ray ray, in Scene scene, float tmax){\n    Intersection inter = nope(ray);\n    for(uint i = 0u ; i < scene.nbSpheres ; ++i){\n    \traySphereIntersection(ray, scene.spheres[i], inter, 0);\n        if(inter.hit && inter.t <= tmax + epsilon) return false;\n    }\n    for(uint i = 0u ; i < scene.nbTriangles ; ++i){\n    \trayTriangleIntersection(ray, scene.triangles[i], inter, 0);\n        if(inter.hit && inter.t <= tmax + epsilon) return false;\n    }\n    return true;\n}\n\nbool visibility(in Ray ray, in Scene scene, vec3 point){\n    Intersection inter = nope(ray);\n    raySceneIntersection(ray, scene, inter);\n    return !inter.hit || samePoint(inter.point, point);\n}\n\nfloat PDF_area_sampling_point(in Sphere sphere){\n    \n\treturn 1.0f/ (FOUR_PI * sphere.radius2);\n}\n\nfloat PDF_SA_sampling_point(in Sphere sphere, vec3 viewer){\n \n\tvec3 main_direction = (viewer - sphere.position);\n    float d = length(main_direction);\n    float sinthetamax = sphere.radius /d;\n    float costhetamax = sqrt(1.0 - sinthetamax*sinthetamax);\n    float solid_angle = TWO_PI * (1.0 - costhetamax);\n    return 1.0f / solid_angle;\n}\n\nfloat PDF_area_sampling_point(in Scene scene, in Intersection inter){\n\tbool is_t = inter.tptr >= 0;\n    bool is_s = inter.sptr >= 0;\n    return PDF_area_sampling_point(scene.spheres[inter.sptr]);\n}\n\nfloat PDF_SA_sampling_point(in Scene scene, in Intersection inter){\n\tbool is_t = inter.tptr >= 0;\n    bool is_s = inter.sptr >= 0;\n    return PDF_SA_sampling_point(scene.spheres[inter.sptr], inter.ray.origin);\n}\n\nvoid sampleSphereUniform(vec3 viewer, in Sphere sphere, inout SurfaceLightSample sls){\n    vec2 ksi = rand2();\n    float polar = acos(1.0f - 2.0f * ksi.x);\n    float azimuth = ksi.y * 2.0f * PI;\n    sls.normal = vec3(sin(polar) *cos(azimuth), sin(polar) * sin(azimuth), cos(polar));\n    sls.point = sphere.position + (sphere.radius ) * sls.normal;\n    sls.pdf = 1.0f/ (FOUR_PI * sphere.radius2);\n}\n\nvoid sampleSphereHemisphereCosinus(vec3 viewer, in Sphere sphere, inout SurfaceLightSample sls){\n    \n    vec3 main_direction = normalize(viewer - sphere.position);\n    sls.normal = randomDirectionHemisphere(main_direction, 1.0f);\n    \n    sls.point = sphere.position + (sphere.radius ) * sls.normal;\n    \n    sls.pdf = dot(main_direction, sls.normal) / (PI * sphere.radius2);\n}\n\nvoid sampleSphereHemisphereUniform(vec3 viewer, in Sphere sphere, inout SurfaceLightSample sls){\n    \n    vec3 main_direction = normalize(viewer - sphere.position);\n    sls.normal = randomDirectionHemisphere(main_direction, 0.0f);\n   \tif(dot(sls.normal, main_direction) < 0.0f) sls.normal *= -1.0f;\n    \n    sls.point = sphere.position + (sphere.radius ) * sls.normal;\n    \n    \n    sls.pdf = 1.0f / (TWO_PI * sphere.radius2);\n}\n\n//https://www.akalin.com/sampling-visible-sphere\nvoid sampleSphereSA(vec3 viewer, in Sphere sphere, inout SurfaceLightSample sls){\n    // get costheta and phi\n    vec3 main_direction = (viewer - sphere.position);\n    float d = length(main_direction);\n    main_direction /= d;\n    float d2 = d*d;\n    float sinthetamax = sphere.radius /d;\n    \n    //float thetamax = asin(sinthetamax);\n    float costhetamax = sqrt(1.0f - sinthetamax * sinthetamax);//cos(thetamax);\n    \n    float costheta = 1.0f - rand1()  * (1.0f - costhetamax);\n    \n    float sintheta = sqrt(1.0 - costheta * costheta);//sin(acos(costheta))\n    float phi = rand1() * TWO_PI;\n    \n    // D = 1 - d² sin² θ / r²\n    float sintheta2 =  sintheta * sintheta;\n    float D = 1.0 - d2 * sintheta2 / sphere.radius2;\n    bool D_positive = D > 0.0f;\n    \n    float cosalpha = float(D_positive) * (sintheta2 / sinthetamax +  costheta * sqrt(abs(D)))\n        \t\t\t+float(!D_positive) * sinthetamax;\n    \n    float sinalpha = sin(acos(cosalpha));//sqrt(1.0 - cosalpha * cosalpha);\n\n    vec3 direction = vec3(sinalpha * cos(phi), sinalpha * sin(phi), cosalpha);\n    if(abs(main_direction.z) > 0.99999f){\n        sls.normal = direction * sign(main_direction.z);\n    }\n    else{\n        vec3 axis = normalize(cross(UP, main_direction));\n        float angle = acos(main_direction.z);\n\n        sls.normal = rotate(axis, angle, direction);\n    }\n    sls.point = sphere.position + sphere.radius * sls.normal;\n    float solid_angle = TWO_PI * (1.0 - costhetamax);\n    sls.pdf = 1.0f / solid_angle;\n}\n\n\n\nconst float A = 0.15;//ShoulderStrength\nconst float B = 0.50;//LinearStrength\nconst float C = 0.10;//LinearAngle\nconst float D = 0.20;//ToeStrength\nconst float E = 0.02;\nconst float F = 0.30;\nconst float W = 10.2;\n\nvec3 Uncharted2Tonemap(vec3 x){\n   \treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 ACESFilm(vec3 x ){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp(vec3(0.),vec3(1.),(x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvec3 ExposureCorrect(vec3 col, float linfac, float logfac){\n\treturn linfac*(1.0 - exp(col*logfac));\n}\n\nvec3 LinearToGamma(vec3 linRGB){\n    linRGB = max(linRGB, vec3(0.));\n    return max(1.055 * pow(linRGB, vec3(0.416666667)) - 0.055, vec3(0.));\n}\n\n\nvec3 ACESFilmicToneMapping(vec3 col){\n\tvec3 curr = Uncharted2Tonemap(col);\n    const float ExposureBias = 2.0;\n\tcurr *= ExposureBias;\n    curr /= Uncharted2Tonemap(vec3(W));\n    return LinearToGamma(curr);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////\n//   \t\t\t\t\t\t\t\tScenes                                         //\n/////////////////////////////////////////////////////////////////////////////////////\n\nvoid initVeach(inout Scene scene, inout vec3 position, vec3 delta_p, inout vec2 rotation, vec2 delta_r){\n        \n    // Camera\n\trotation += delta_r;\n    vec3 front = polarToCartesian(rotation);\n    vec3 right = normalize(cross(UP, front));\n    \n    position += front * delta_p.x;\n    position += right * delta_p.y;\n    position.z += delta_p.z;\n    \n    vec2 cplane = vec2(640.0f,360.0f)/640.0f;\n    scene.camera = makeCameraFromFrontRight(position, front, right, cplane);\n    \n    Material diffuse_white = Material(vec3(1), vec3(0), 0.0f);\n    \n    // Walls\n    \n    addQuad(scene_scale * 50.0f * vec3(0,0,-0.5), scene_scale * 50.0f * vec2(1.0f), vec3(0,1,0), 0.0f, diffuse_white, scene);\n    addQuad(scene_scale * 50.0f * vec3(0.5,0,0), scene_scale * 50.0f * vec2(1.0f), vec3(0,1,0), HALF_PI, diffuse_white, scene);\n    \n    // Spheres\n    vec3 sphere_colors[4] = vec3[4](vec3(1.0,0.1,0.1),vec3(0.2,1.0,0.4),vec3(1,0.15,1.0),vec3(0.1,0.3, 1.0));\n    //vec3 sphere_colors[4] = vec3[4](vec3(1,1,1),vec3(1,1,1),vec3(1,1,1),vec3(1,1,1));\n    float factor = 1.0f;\n    float color_multipliers[4] =  float[4](10.0f, 4.0f, 3.0f, 2.8f);\n    float sphere_sizes[4] = float[4](0.1f, 0.4f, 1.0f, 2.0f);\n    vec3 shift = vec3(0, -7.0f, 0);\n    vec3 base = vec3(18.0f, 10.0f , -5.0f);\n    for(uint i = 0u ; i < 4u ; ++i){\n        Material mat = Material(vec3(0), factor *  sphere_colors[i] * color_multipliers[i] / sphere_sizes[i],0.0f);\n        addSphere((scene_scale) * (base + shift * float(i)), scene_scale * sphere_sizes[i], mat, scene);\n    }\n    Material lampmat = Material(vec3(0), vec3(1),0.0f);\n    //addSphere(vec3(0,0,+10), scene_scale * 10.0f, lampmat, scene);\n    // Planes\n    //float shininesses[4] = float[4](250.0f, 2000.0f, 10000.0f, 30000.0f);\n    //float shininesses[4] = float[4](1000.0f, 1000.0f, 1000.0f, 1000.0f);\n    float shininesses[4] = float[4](1.0f, 10.0f, 100.0f, 1000.0f);\n    float multiplier = 250.0f;\n\n\n    float angles[4] = float[4](radians(13.0f), radians(22.0f), radians(32.0f), radians(53.0f));\n    vec3 shifts[4] = vec3[4](vec3(0), vec3(8.0f,0, 3.0f), vec3(14.0f,0, 6.0f), vec3(20.0f,0, 11.0f));\n    for(uint i = 0u ; i < 4u ; ++i){\n    \taddQuad(vec3(0,0,-22.0f*scene_scale) + scene_scale * shifts[i], scene_scale * vec2(5.0f, 25.0f), vec3(0,1,0), angles[i], Material(vec3(1), vec3(0), multiplier * shininesses[i] ), scene);\n    }\n}\n\nvoid initCornell(inout Scene scene, inout vec3 position, vec3 delta_p, inout vec2 rotation, vec2 delta_r){\n        \n    // Camera\n\n\trotation += delta_r;\n    vec3 front = polarToCartesian(rotation);\n    vec3 right = normalize(cross(UP, front));\n    \n    position += front * delta_p.x;\n    position += right * delta_p.y;\n    position.z += delta_p.z;\n    \n    vec2 cplane = vec2(640.0f,360.0f)/640.0f;//1280.0f;\n    scene.camera = makeCameraFromFrontRight(position, front, right, cplane);\n    \n    Material diffuse_white = Material(vec3(1), vec3(0), 0.0f);\n    Material diffuse_red = Material(vec3(1,0,0), vec3(0), 0.0f);\n    Material diffuse_green = Material(vec3(0,1,0), vec3(0), 0.0f);\n    \n    //Cornell\n   \tvec3 center = INITIAL_POS_SPP.xyz + scene_scale * vec3(20,0,-1.8);\n    addCornell(center, scene_scale * 5.0f, diffuse_white, diffuse_white, diffuse_red, diffuse_green, diffuse_white, scene);\n    float light_size = 0.3f;\n    \n    // Lights\n    \n    Material mlight1 = Material(vec3(0), vec3(4)/(light_size), 0.0f);\n    addSphere(center + scene_scale * vec3(0,0,2), scene_scale * light_size, mlight1, scene);\n    \n    Material mlight2 = Material(vec3(0), vec3(1,.25,0)/(light_size), 0.0f);\n    addSphere(center + scene_scale * vec3(-1.5,-1.5 ,-2), scene_scale *2.0f*light_size, mlight2, scene);\n    \n    // Spheres\n    \n    Material msdiffp = Material(vec3(0.8,0.2,0.7), vec3(0), 0.0f);\n    addSphere(center + scene_scale * vec3(1,-1,-1), scene_scale *light_size * 3.0f, msdiffp, scene);\n    \n    Material msdiffy = Material(vec3(1,1,0), vec3(0), 0.0f);\n    addSphere(center + scene_scale * vec3(1,-3,2), scene_scale *light_size * 7.0f, msdiffy, scene);\n        \n    Material msgloss1 = Material(vec3(0.3,0.9,0.9), vec3(0), 10.0f);\n    addSphere(center + scene_scale * vec3(1,2,-1), scene_scale *light_size * 5.0f, msgloss1, scene);\n    \n    Material msspec1 = Material(vec3(1.0,0.5,0.3), vec3(0), 1000.0f);\n    addSphere(center + scene_scale * vec3(0,0,-8), scene_scale *light_size * 20.0f, msspec1, scene);\n    \n    Material msspec2 = Material(vec3(1.0,1.0,1.0), vec3(0), 50000.0f);\n    addSphere(center + scene_scale * vec3(5,5,5), scene_scale *light_size * 20.0f, msspec2, scene);\n    \n    Material msgloss2 = Material(vec3(1.0,0.0,0.7), vec3(0), 1.0f);\n    addSphere(center + scene_scale * vec3(2,0,0.5), scene_scale *light_size * 3.0f, msgloss2, scene);\n    \n \n   \n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float pdfWeArea(in Camera camera){\n    return iResolution.x * iResolution.y / (camera.plane.x * camera.plane.y);\n}\n\nfloat pdfWeSolidAngle(in Camera camera, vec3 direction){\n    float cost = dot(camera.front, direction);\n    return pdfWeArea(camera)/pow(cost,3.0f);\n}\n    \nvec3 We(in Camera camera, vec3 direction){\n    return vec3(pdfWeSolidAngle(camera, direction));\n}\n\n\nRay makeRay(vec2 uv, in Camera camera){\n#ifdef CIRCULAR_DITHER\n    float radius = sqrt(0.5f * dither_amount * rand1());\n    float angle = TWO_PI * rand1();\n    vec2 dither = radius * vec2(cos(angle), sin(angle))/iResolution.xy;\n#else\n    vec2 dither = dither_amount * (0.5 - rand2())/iResolution.xy;\n#endif\n\n    vec3 direction = camera.front - \n        camera.right * (0.5 - uv.x + dither.x) * camera.plane.x - \n        camera.down * (0.5 - uv.y + dither.y) * camera.plane.y;\n    \n    return Ray(camera.position, normalize(direction));\n}\n\n/*\n\tDirect illumination computation with a given sampling technique\n*/\nvec3 directIlluminationMIS(in Scene scene, in Intersection inter, int technique){\n\t\n    vec3 light_contribution = vec3(0);\n    vec3 surface_contribution = vec3(0);\n    float wl = 0.0f;\n    float ws = 0.0f;\n    \n    // Light sampling\n    {\n        float random = rand1();\n        uint index = uint(random * float(scene.nbLightSpheres));\n        SurfaceLightSample sls;\n       \tuint ptr = scene.light_spheres[index];\n        \n        \n        //sampleSphereUniform(inter.point, scene.spheres[ptr], sls);\n        //sampleSphereHemisphereUniform(inter.point, scene.spheres[ptr], sls);\n        //sampleSphereHemisphereCosinus(inter.point, scene.spheres[ptr], sls);\n        sampleSphereSA(inter.point, scene.spheres[ptr], sls);\n\n\n        float pdf = sls.pdf / float(scene.nbLightSpheres);\n        vec3 pointToSample = sls.point - inter.point;\n        float dist = length(pointToSample);\n        pointToSample /= dist;\n        vec3 bsdf = BSDF(inter, -inter.ray.direction, pointToSample);\n        float cosi = abs(dot(inter.normal, pointToSample));\n        vec3 prod = bsdf * cosi;\n\n        if( isOk(prod) && !isBlack(prod)){\n\n            Ray ray_light = Ray(inter.point + pointToSample * epsilon, pointToSample);\n\n            vec3 color = scene.spheres[index].material.emissive;\n            float V = float(visibility(ray_light, scene, sls.point));\n            \n            // Remap pdf to area pdf\n            //float cosl = dot(sls.normal, -pointToSample);\n            //float SA_to_area = cosl/(dist*dist);\n            //pdf /= SA_to_area;\n            light_contribution = (V * color * prod / pdf);\n\t\t\t\n            float pdf_surface = PDF(inter, pointToSample);\n            wl = pdf / (pdf + pdf_surface);\n            wl = clamp(wl, 0.0f, 1.0f);\n        }\n    }\n\n    // Surface sampling\n    {\n        DirectionSample ds;\n        sample_BSDF(inter, ds);\n       \tfloat cosi = dot(inter.normal, ds.direction);\n        vec3 prod = ds.bsdf * cosi;\n        \n       \tif(!isBlack(prod)){\n        \tRay ray_surface = Ray(inter.point + inter.normal * epsilon, ds.direction);\n            Intersection inter_surface = nope(ray_surface);\n            bool touched = raySceneIntersection(ray_surface, scene, inter_surface);\n            if(touched && isEmissive(inter_surface.material)){\n                vec3 color = inter_surface.material.emissive;\n                float cosl = dot(inter_surface.normal, -ds.direction);\n                float SA_to_area = cosl / (inter_surface.t * inter_surface.t);\n                surface_contribution = prod * color / ds.pdf;\n                \n                float pdf_light = (PDF_SA_sampling_point(scene, inter_surface) / float(scene.nbLightSpheres));\n\n                ws = ds.pdf / (pdf_light + ds.pdf);\n                ws = clamp(ws, 0.0f, 1.0f);\n            }\n            \n        }\n\n    }\n    vec3 MIS_contribution = wl * light_contribution +  ws * surface_contribution;\n\t//return MIS_contribution;\n\tvec3 result = float(technique == MIS) * MIS_contribution +\n                  float(technique == LIGHT_SAMPLING) * light_contribution +\n                  float(technique == BSDF_SAMPLING) * surface_contribution + \n                  float(technique == WEIGHTS_VISUALIZATION) * vec3(ws, wl, 0);\n    return result;\n}\n\n/*\n\tBasic path tracing integrator\n*/\nvec3 tracePath(in Ray ray, in Scene scene, int technique){\n    \n    float cost = dot(ray.direction,scene.camera.front);\n    vec3 prod_color = vec3(1); //We(scene.camera, ray.direction);\n    float prod_pdf = 1.0f;//pdfWeSolidAngle(scene.camera,ray.direction);\n    vec3 prod_ratio = vec3(1); // == prod_color / prod_pdf;\n    \n    vec3 res = vec3(0);\n\t\n    Intersection inter;\n    for(uint depth = 0u ; depth < MAX_DEPTH ; ++depth){\n        inter = nope(ray);\n        if(raySceneIntersection( ray, scene, inter)){\n            \n            bool use_emissive = isEmissive(inter.material) && depth == 0u;\n            \n            vec3 contrib = float(use_emissive) * inter.material.emissive +\n            \t   \t\t   float(!use_emissive) * float(!isEmissive(inter.material)) * directIlluminationMIS(scene, inter, technique);\n               \n            //vec3 contrib = float(use_emissive) * inter.material.emissive + directIlluminationMIS(scene, inter, BSDF_SAMPLING);\n            res += prod_ratio * contrib; // == prod_color * contrib / prod_pdf;        \n            \n#ifdef RUSSIAN_ROULETTE\n            float ksi = rand1();\n            if(ksi < ALPHA){\n#endif\n            \tDirectionSample next_dir;\n                sample_BSDF(inter, next_dir);\n    \t\t\t\n                prod_color *= next_dir.bsdf * dot(next_dir.direction, inter.normal);\n                prod_pdf *= next_dir.pdf * ALPHA;\n                prod_ratio = prod_color / prod_pdf;\n                if(!isOk(prod_ratio)){\n                    break;\n                }\n                \n                ray = Ray(inter.point + next_dir.direction*epsilon, next_dir.direction);\n                \n#ifdef RUSSIAN_ROULETTE\n            }else{\n                break;\n            }\n#endif\n            \n        }else{\n#ifdef BACKGROUND_IMAGE\n            res += (prod_color/prod_pdf) * BACKGROUND_IMAGE(ray.direction);\n#else\n            res += (prod_color/prod_pdf) * BACKGROUND_COLOR;\n#endif\n            break;\n    \t}\n\t}\n\treturn res;\n}\n\n\n\n\n\n/*\n\tListen keyboard inputs\n*/\nvoid listenInputs(out vec3 delta_p, out vec2 delta_r, out bool change, out float any_input){\n\tfloat left  = float(texelFetch( iChannel1, ivec2(KEY_LEFT, 0),0 ).x   > 0.0f);\n    float right = float(texelFetch( iChannel1, ivec2(KEY_RIGHT, 0), 0 ).x > 0.0f);\n    float up    = float(texelFetch( iChannel1, ivec2(KEY_UP, 0), 0 ).x    > 0.0f);\n    float down  = float(texelFetch( iChannel1, ivec2(KEY_DOWN, 0), 0 ).x  > 0.0f);\n    float z     = float(texelFetch( iChannel1, ivec2(KEY_Z, 0), 0 ).x     > 0.0f);\n    float q     = float(texelFetch( iChannel1, ivec2(KEY_Q, 0), 0 ).x     > 0.0f);\n    float s     = float(texelFetch( iChannel1, ivec2(KEY_S, 0), 0 ).x     > 0.0f);\n    float d     = float(texelFetch( iChannel1, ivec2(KEY_D, 0), 0 ).x     > 0.0f);\n    float space = float(texelFetch( iChannel1, ivec2(KEY_SPACE, 0), 0 ).x > 0.0f);\n    float ctrl  = float(texelFetch( iChannel1, ivec2(KEY_CTRL, 0), 0 ).x  > 0.0f);\n    float shift = float(texelFetch(iChannel1, ivec2(KEY_SHIFT, 0), 0 ).x  > 0.0f);\n    change = texelFetch( iChannel1, ivec2(KEY_T, 0), 0 ).x     > 0.0f;\n    \n    any_input =clamp(left + right + up + down + z + q + s + d + space + ctrl + shift + float(change), 0.0f, 1.0f);\n    \n    float boost = 1.0f + 3.0f *shift;\n    \n    delta_p.x = ((z-s) * translation_speed * boost) * iTimeDelta;\n    delta_p.y = ((q-d) * translation_speed * boost) * iTimeDelta;\n    delta_p.z = ((space-ctrl) * translation_speed * boost) * iTimeDelta;\n   \n    delta_r.x += ((right-left) * rotation_speed) * iTimeDelta;\n    delta_r.y += ((down-up) * rotation_speed) * iTimeDelta;\n    \n    \n    \n}\n\n\n\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv_swap = uv;\n    uv_swap.x = -uv.x + 1.0f;\n    \n    //834144373's seed, works well\n    float static_seed = (fragCoord.x+iResolution.x*fragCoord.y)/(iResolution.y);\n    float dynamic_seed = iTime*sin(iTime);\n\tseed = static_seed;\n    \n    //////////////////////////////////\n    ///////////// INPUTS /////////////\n    //////////////////////////////////\n    bool is_pos_spp = ivec2(fragCoord) == POS_SPP_LOCATION;\n    bool is_rot_tech = ivec2(fragCoord) == ROT_TECH_LOCATION;\n    bool is_common = !is_pos_spp && !is_rot_tech;\n    float any_input = 0.0f;\n    bool change = false;\n\tvec3 delta_p = vec3(0);\n    vec2 delta_r = vec2(0);\n\tvec4 pos_spp = texelFetch( iChannel0, POS_SPP_LOCATION, 0 );\n    vec4 rot_tech = texelFetch( iChannel0, ROT_TECH_LOCATION, 0 );\n    bool changed = rot_tech.w > 0.0f;\n   \tif(!is_common)\n        listenInputs(delta_p, delta_r, change, any_input);\n    //////////////////////////////////\n    /////// SCENE DEFINITION /////////\n    //////////////////////////////////\n    \n    seed += float(pos_spp.a > 1.f) * dynamic_seed;\n    \n\tScene scene;\n    initVeach(scene, pos_spp.xyz, delta_p, rot_tech.xy, delta_r);\n    //initCornell(scene, pos_spp.xyz, delta_p, rot_tech.xy, delta_r);\n\t\n    //////////////////////////////////\n    /////// SCENE RENDERING //////////\n    //////////////////////////////////\n    \n   \t// Handle special cases for memory storage\n   \t \n    C = float(is_common) * texture(iChannel0,uv) + \n        float(is_pos_spp) * pos_spp + \n        float(is_rot_tech) * rot_tech;\n    C.z = float(!is_rot_tech) * C.z  + \n          float(is_rot_tech) * float((int(C.z) + int(change && !changed)) % 4);\n    C.a = (1.0f - any_input * float(!changed)) * float(is_pos_spp) * pos_spp.a + 1.0f;\n    C.a = float(!is_rot_tech) * C.a + float(is_rot_tech) * float(change);\n        \t\n       \n\t\n    \n    vec3 col = vec3(0);\n    for(uint i = 1u ; i <= SPPPF ; ++i){ // Make SPPPF samples per pixel per frame\n        Ray ray = makeRay(uv_swap, scene.camera);\n        col += tracePath(ray, scene, int(rot_tech.z));\n    }\n    \n    col /= float(SPPPF);\n    \n    \n    col = clamp(col, 0.0f, 1000.0f); // Avoid NaNs and Infs\n\t\n    if(iFrame == 0){ // reset\n        C = float(is_common) * vec4(col,0) +\n            float(is_rot_tech) * INITIAL_ROT_TECH +\n            float(is_pos_spp) * INITIAL_POS_SPP;\n    }\n    else{\n        \n#ifdef STOP_TIME\n\t\tif(iTime>STOP_TIME){\n       \t\treturn;\n        }\n#endif\n\n#ifdef STOP_SAMPLES\n\t\tif(iFrame > int(STOP_SAMPLES * SPPPF)){\n       \t\treturn;\n        }\n#endif\n        // Update pixel value if not a memory storage pixel\n       \tC.rgb = C.rgb * float(!is_common) + float(is_common) * mix(C.rgb ,col,1./pos_spp.a);\t\t\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}