{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// This shader has been automatically generated from ToodeeSculpt (https://github.com/Geolm/ToodeeSculpt)\n// MIT License\n\n// Copyright (c) 2024 Geolm\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n//----------------------------------------------------------------------------------------------------------------------------------------------------------\n// Signed Distance Field functions\n//----------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nvec2 skew(vec2 v) {return vec2(-v.y, v.x);}\nfloat cross2(vec2 a, vec2 b ) {return a.x*b.y - a.y*b.x;}\n\n//-----------------------------------------------------------------------------\nfloat sd_disc(vec2 position, vec2 center, float radius)\n{\n    return length(center-position) - radius;\n}\n\n//-----------------------------------------------------------------------------\nfloat sd_segment(vec2 position, vec2 a, vec2 b)\n{\n    vec2 pa = position-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\n//-----------------------------------------------------------------------------\nfloat sd_oriented_box(vec2 position, vec2 a, vec2 b, float width)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (position-(a+b)*0.5);\n    q = mat2(d.x,-d.y,d.y,d.x)*q;\n    q = abs(q)-vec2(l,width)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n//-----------------------------------------------------------------------------\nfloat sd_triangle(vec2 p, vec2 p0, vec2 p1, vec2 p2 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp(dot(v0,e0)/dot(e0,e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1*clamp(dot(v1,e1)/dot(e1,e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2*clamp(dot(v2,e2)/dot(e2,e2), 0.0, 1.0);\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min(min(vec2(dot(pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x)),\n                       vec2(dot(pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x))),\n                       vec2(dot(pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x)));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n//-----------------------------------------------------------------------------\n// based on https://www.shadertoy.com/view/tt3yz7\nfloat sd_ellipse(vec2 p, vec2 e)\n{\n    vec2 pAbs = abs(p);\n    vec2 ei = 1.f / e;\n    vec2 e2 = e*e;\n    vec2 ve = ei * vec2(e2.x - e2.y, e2.y - e2.x);\n    \n    vec2 t = vec2(0.70710678118654752, 0.70710678118654752);\n\n    // hopefully unroll by the compiler\n    for (int i = 0; i < 3; i++) \n    {\n        vec2 v = ve*t*t*t;\n        vec2 u = normalize(pAbs - v) * length(t * e - v);\n        vec2 w = ei * (v + u);\n        t = normalize(clamp(w, vec2(0.0), vec2(1.0)));\n    }\n    \n    vec2 nearestAbs = t * e;\n    float dist = length(pAbs - nearestAbs);\n    return dot(pAbs, pAbs) < dot(nearestAbs, nearestAbs) ? -dist : dist;\n}\n\n//-----------------------------------------------------------------------------\nfloat sd_oriented_ellipse(vec2 position, vec2 a, vec2 b, float width)\n{\n    float height = length(b-a);\n    vec2  axis = (b-a)/height;\n    vec2  position_translated = (position-(a+b)* 0.5);\n    vec2 position_boxspace = mat2(axis.x,-axis.y, axis.y, axis.x)*position_translated;\n    return sd_ellipse(position_boxspace, vec2(height * 0.5, width * 0.5));\n}\n\n//-----------------------------------------------------------------------------\nfloat sd_oriented_pie(vec2 position, vec2 center, vec2 direction, vec2 aperture, float radius)\n{\n    direction = -skew(direction);\n    position -= center;\n    position = mat2(direction.x,-direction.y, direction.y, direction.x) * position;\n    position.x = abs(position.x);\n    float l = length(position) - radius;\n\tfloat m = length(position - aperture*clamp(dot(position,aperture),0.0,radius));\n    return max(l,m*sign(aperture.y*position.x - aperture.x*position.y));\n}\n\n//-----------------------------------------------------------------------------\nfloat sd_oriented_ring(vec2 position, vec2 center, vec2 direction, vec2 aperture, float radius, float thickness)\n{\n    direction = -skew(direction);\n    position -= center;\n    position = mat2(direction.x,-direction.y, direction.y, direction.x) * position;\n    position.x = abs(position.x);\n    position = mat2(aperture.y,aperture.x,-aperture.x,aperture.y)*position;\n    return max(abs(length(position)-radius)-thickness*0.5,length(vec2(position.x,max(0.0,abs(radius-position.y)-thickness*0.5)))*sign(position.x) );\n}\n\n//-----------------------------------------------------------------------------\nfloat sd_uneven_capsule(vec2 p, vec2 pa, vec2 pb, float ra, float rb)\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    q.x = abs(q.x);\n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cross2(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n\n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\n//----------------------------------------------------------------------------------------------------------------------------------------------------------\n// SDF Operator\n//----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nvec2 smooth_minimum(float a, float b, float k)\n{\n    if (k>0.f)\n    {\n        float h = max( k-abs(a-b), 0.0 )/k;\n        float m = h*h*h*0.5;\n        float s = m*k*(1.0/3.0); \n        return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n    }\n    else\n    {\n        // \"hard\" min\n        return vec2(min(a, b),  (a<b) ? 0.0 : 1.0);\n    }\n}\n\n// ---------------------------------------------------------------------------------------------------------------------------\nfloat smooth_substraction(float d1, float d2, float k)\n{\n    if (k>0.f)\n    {\n        float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n        return mix(d1, -d2, h) + k*h*(1.0-h);\n    }\n    else\n    {\n        return max(-d2, d1);\n    }\n}\n\n// ---------------------------------------------------------------------------------------------------------------------------\nfloat smooth_intersection(float d1, float d2, float k )\n{\n    if (k>0.f)\n    {\n        float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n        return mix(d2, d1, h) + k*h*(1.0-h);\n    }\n    else\n    {\n        return max(d1, d2);\n    }\n}\n\nvec4 map(vec2 p)\n{\n    float d = 100000.0;\n    vec2 blend = vec2(0.0);\n    vec3 color = vec3(0.0);\n    float pixel_size = length(dFdx(p) + dFdy(p));\n    \n    float d0 = sd_oriented_ring(p, vec2(0.148019, 0.512636), vec2(0.930708, -0.365763), vec2(0.388980, 0.921246), 0.296761, 0.015179);\n\tblend = smooth_minimum(max(d, 0.0), d0, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.894118, 0.580392, 0.227451), blend.y);\n\tfloat d1 = sd_oriented_ring(p, vec2(0.669731, 0.495234), vec2(-0.769614, -0.638509), vec2(0.461548, 0.887115), 0.190443, 0.017876);\n\tblend = smooth_minimum(max(d, 0.0), d1, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.894118, 0.580392, 0.227451), blend.y);\n\tfloat d2 = sd_oriented_box(p, vec2(0.460339, 0.687485), vec2(0.468147, 0.317646), 0.058977);\n\tblend = smooth_minimum(max(d, 0.0), d2, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.894118, 0.580392, 0.227451), blend.y);\n\tfloat d3 = sd_disc(p, vec2(0.351584, 0.154854), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d3, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d4 = sd_oriented_ellipse(p, vec2(0.263025, 0.182241), vec2(0.333785, 0.203770), 0.061003);\n\tblend = smooth_minimum(max(d, 0.0), d4, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d5 = sd_disc(p, vec2(0.369991, 0.219624), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d5, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d6 = sd_disc(p, vec2(0.417578, 0.141030), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d6, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d7 = sd_disc(p, vec2(0.463819, 0.116860), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d7, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d8 = sd_oriented_ellipse(p, vec2(0.496753, 0.114346), vec2(0.567513, 0.135874), 0.061003);\n\tblend = smooth_minimum(max(d, 0.0), d8, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d9 = sd_oriented_ellipse(p, vec2(0.544684, 0.180733), vec2(0.604661, 0.133325), 0.061003);\n\tblend = smooth_minimum(max(d, 0.0), d9, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d10 = sd_disc(p, vec2(0.326142, 0.260342), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d10, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d11 = sd_oriented_ellipse(p, vec2(0.335369, 0.294370), vec2(0.406128, 0.315898), 0.061003);\n\tblend = smooth_minimum(max(d, 0.0), d11, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d12 = sd_disc(p, vec2(0.446354, 0.213901), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d12, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d13 = sd_disc(p, vec2(0.508073, 0.195220), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d13, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d14 = sd_disc(p, vec2(0.577413, 0.231733), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d14, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d15 = sd_disc(p, vec2(0.626415, 0.192896), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d15, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d16 = sd_oriented_ellipse(p, vec2(0.597197, 0.235284), vec2(0.675347, 0.296738), 0.077667);\n\tblend = smooth_minimum(max(d, 0.0), d16, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d17 = sd_oriented_ellipse(p, vec2(0.544710, 0.271475), vec2(0.622860, 0.332930), 0.077667);\n\tblend = smooth_minimum(max(d, 0.0), d17, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d18 = sd_disc(p, vec2(0.509818, 0.262534), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d18, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d19 = sd_disc(p, vec2(0.428377, 0.291357), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d19, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d20 = sd_disc(p, vec2(0.471476, 0.314507), 0.047971);\n\tblend = smooth_minimum(max(d, 0.0), d20, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.392157, 0.490196, 0.203922), blend.y);\n\tfloat d21 = sd_triangle(p, vec2(0.438407, 0.689106), vec2(0.419175, 0.689409), vec2(0.436905, 0.388257));\n\tblend = smooth_minimum(max(d, 0.0), d21, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.894118, 0.580392, 0.227451), blend.y);\n\tfloat d22 = sd_triangle(p, vec2(0.502995, 0.690176), vec2(0.468915, 0.690049), vec2(0.496241, 0.370410));\n\tblend = smooth_minimum(max(d, 0.0), d22, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.894118, 0.580392, 0.227451), blend.y);\n\tfloat d23 = sd_triangle(p, vec2(0.420673, 0.686123), vec2(0.384470, 0.729082), vec2(0.456068, 0.688188));\n\tblend = smooth_minimum(max(d, 0.0), d23, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.894118, 0.580392, 0.227451), blend.y);\n\tfloat d24 = sd_triangle(p, vec2(0.436016, 0.686592), vec2(0.465208, 0.684277), vec2(0.469089, 0.747822));\n\tblend = smooth_minimum(max(d, 0.0), d24, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.894118, 0.580392, 0.227451), blend.y);\n\tfloat d25 = sd_triangle(p, vec2(0.465738, 0.694375), vec2(0.498281, 0.685713), vec2(0.536662, 0.737617));\n\tblend = smooth_minimum(max(d, 0.0), d25, 0.014444);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.894118, 0.580392, 0.227451), blend.y);\n\tfloat d26 = sd_oriented_ellipse(p, vec2(0.467730, 0.456147), vec2(0.466415, 0.538047), 0.041146);\n\tblend = smooth_minimum(max(d, 0.0), d26, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.121569, 0.054902, 0.109804), blend.y);\n\tfloat d27 = sd_oriented_ring(p, vec2(0.349695, 0.196370), vec2(-0.824219, -0.566271), vec2(0.995544, 0.094294), 0.022157, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d27, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d28 = sd_oriented_ring(p, vec2(0.382593, 0.163451), vec2(-0.084703, -0.996406), vec2(0.862652, -0.505798), 0.023529, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d28, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d29 = sd_oriented_ring(p, vec2(0.365907, 0.279303), vec2(-0.420292, 0.907389), vec2(0.995546, 0.094276), 0.022131, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d29, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d30 = sd_oriented_ring(p, vec2(0.586050, 0.280020), vec2(0.487879, 0.872911), vec2(0.995460, 0.095181), 0.022177, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d30, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d31 = sd_oriented_ring(p, vec2(0.625367, 0.246810), vec2(0.979818, -0.199894), vec2(0.852265, -0.523110), 0.013039, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d31, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d32 = sd_oriented_ring(p, vec2(0.613612, 0.218588), vec2(0.529148, -0.848530), vec2(0.853725, -0.520724), 0.012995, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d32, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d33 = sd_oriented_ring(p, vec2(0.470153, 0.277831), vec2(0.035026, 0.999386), vec2(0.967941, -0.251177), 0.024020, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d33, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d34 = sd_oriented_ring(p, vec2(0.510673, 0.256706), vec2(0.487844, 0.872931), vec2(0.995510, 0.094658), 0.022166, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d34, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d35 = sd_oriented_ring(p, vec2(0.541993, 0.185858), vec2(0.375865, -0.926674), vec2(0.931034, 0.364932), 0.025166, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d35, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d36 = sd_oriented_ring(p, vec2(0.580260, 0.189399), vec2(0.240820, -0.970570), vec2(0.999501, 0.031592), 0.013402, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d36, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d37 = sd_oriented_ring(p, vec2(0.458892, 0.121669), vec2(-0.420181, 0.907440), vec2(0.995553, 0.094208), 0.022159, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d37, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d38 = sd_oriented_ring(p, vec2(0.493334, 0.137293), vec2(0.159743, 0.987159), vec2(0.879974, -0.475022), 0.013997, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d38, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\tfloat d39 = sd_oriented_ring(p, vec2(0.312871, 0.252201), vec2(-0.387374, 0.921923), vec2(0.999515, 0.031152), 0.013363, 0.003333);\n\tblend = smooth_minimum(max(d, 0.0), d39, pixel_size);\n\td = blend.x;\n\tcolor = mix(color, vec3(0.243137, 0.129412, 0.215686), blend.y);\n\n    \n\n    return vec4(color.r, color.g, color.b, d);\n}\n\n\n//----------------------------------------------------------------------------------------------------------------------------------------------------------\n// Pixel shader\n//----------------------------------------------------------------------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord/iResolution.y;\n\n    p.y = 1.0 - p.y;\n\n    vec4 color_distance = map(p);\n\n    vec3 col = mix( vec3(0.0), vec3(color_distance.rgb), 1.0-smoothstep(0.0,length(dFdx(p) + dFdy(p)), color_distance.a) );\n\n    \n\tfragColor = vec4(col,1.0);\n    \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfyBDd","date":"1734574505","viewed":80,"name":"tree from ToodeeSculpt","username":"Geolm","description":"Testing the export function of my 2d sdf editor. This is work in progress, software not public yet.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","editor","generated"],"hasliked":0,"parentid":"","parentname":""}}