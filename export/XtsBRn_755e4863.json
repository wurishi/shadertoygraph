{"ver":"0.1","info":{"id":"XtsBRn","date":"1512527437","viewed":222,"name":"CS1230 Lab10","username":"vkazas","description":"cs1230","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["cs1230"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE 0\n#define TERRAIN 1\n#define SEALEVEL 3\n#define NO_INTERSECT 2\n#define HELIX 5\n#define CLOUD 4\n\n#define LOD_NORM 9\n#define LOD_RAY 4\n\n#define SEALEVEL_HEIGHT 5.0\n#define CLOUD_HEIGHT_MIN 70.0\n#define CLOUD_HEIGHT_MAX 74.0\n\n#define AA  0\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, TERRAIN, or NO_INTERSECT\n};\n\nfloat hash21(vec2 p) {\n    float h = dot(vec2(p),vec2(127.1,311.7));\n    return fract(sin(h)*43758.5453123) * 2.0 - 1.0;\n}\n\nfloat hash31(vec3 p) {\n    p = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat valueNoise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n    vec2 u = pf*pf*pf*(6.0*pf*pf - 15.0*pf + 10.0);\n\n    float va = hash21(pi + vec2(0.0, 0.0));\n    float vb = hash21(pi + vec2(1.0, 0.0));\n    float vc = hash21(pi + vec2(0.0, 1.0));\n    float vd = hash21(pi + vec2(1.0, 1.0));\n\n    return mix(mix(va, vb, u.x), mix(vc, vd, u.x), u.y);\n}\n\nfloat valueNoise(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = fract(p);\n    vec3 u = pf*pf*pf*(6.0*pf*pf - 15.0*pf + 10.0);\n\n    float va = hash31(pi + vec3(0.0, 0.0, 0.0));\n    float vb = hash31(pi + vec3(1.0, 0.0, 0.0));\n    float vc = hash31(pi + vec3(0.0, 1.0, 0.0));\n    float vd = hash31(pi + vec3(1.0, 1.0, 0.0));\n    float ve = hash31(pi + vec3(0.0, 0.0, 1.0));\n    float vf = hash31(pi + vec3(1.0, 0.0, 1.0));\n    float vg = hash31(pi + vec3(0.0, 1.0, 1.0));\n    float vh = hash31(pi + vec3(1.0, 1.0, 1.0));\n\n    return mix(mix(mix(va, vb, u.x), mix(vc, vd, u.x), u.y),\n               mix(mix(ve, vf, u.x), mix(vg, vh, u.x), u.y), u.z);\n}\n\nfloat fbmTerrain(vec2 p, int level) {\n    float amp = 0.51;\n    float freq = 0.03;\n    float sum = 0.0;\n\n    for (int i = 0; i < level; i++) {\n        float vNoise = valueNoise(p * freq);\n        sum += amp * vNoise;\n        freq *= 2.01;\n        amp *= -0.49;\n    }\n    sum = pow(sum, 2.0);\n    return sum * 45.0;\n}\n\nfloat fbmCloud(vec3 p, int level) {\n    float amp = 0.51;\n    float freq = 0.03;\n    float sum = 0.0;\n\n    for (int i = 0; i < level; i++) {\n        float vNoise = valueNoise(p * freq);\n        sum += amp * vNoise;\n        freq *= 2.01;\n        amp *= -0.49;\n    }\n    \n    sum = (sum + 1.) * .5;\n    return sum;\n}\n\nfloat fbmSealevel(vec3 p, int level) {\n    float amp = 0.51;\n    float freq = 0.03;\n    float sum = 0.0;\n\n    for (int i = 0; i < level; i++) {\n        float vNoise = valueNoise(p * freq);\n        sum += amp * vNoise;\n        freq *= 2.01;\n        amp *= -0.49;\n    }\n    return sin(sum * 10.);\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 2.0, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat mapTerrain(vec3 p, int level) {\n\tfloat dist = p.x*p.x + p.z*p.z;\n    float delta = 0.;\n    float h = fbmTerrain(p.xz, level);\n\n    if (dist > 1600.) delta = - h * 1.0;\n    else delta = - h + exp(-dist/500.-1.)*50.;\n\n\n    return p.y -4. + delta;\n}\n\nfloat mapSealevel(vec3 p, int level) {\n    return p.y - SEALEVEL_HEIGHT - fbmSealevel(vec3(p.xz * .1, iTime * .5) * 5., level);\n}\n\nconst float theta = 3.14 * 2. / 16.;\nconst mat2 rotate2D = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n\nfloat mapHelix(vec3 p) {\n    p.y = mod(p.y, 22.2);\n    vec3 offset = vec3(7., 3., 0.);\n    float dh = 1.2;\n    vec3 dimen = vec3(2.5, .1, 1.);\n    float res = 100000.0;\n    for (int i=0; i<16; i++) {\n        res = min(res, udBox(p - offset, dimen)); p.xz = rotate2D * p.xz; p.y -= dh;\n    }\n\treturn res;\n}\n\nfloat mapCloud(vec3 p) {\n    if (p.y < CLOUD_HEIGHT_MAX && p.y > CLOUD_HEIGHT_MIN) return -1.;\n\treturn min(abs(p.y - CLOUD_HEIGHT_MIN), abs(p.y - CLOUD_HEIGHT_MAX));\n}\n\nPrimitiveDist map(vec3 p) {\n    float terrainDist = mapTerrain(p, LOD_RAY);\n    float sealevelDist = mapSealevel(p, LOD_RAY - 1);\n    float helixDist = mapHelix(p);\n    //float cloudDist = mapCloud(p);\n    PrimitiveDist res = PrimitiveDist(terrainDist, TERRAIN);\n    float dist = res.dist;\n    float which = float(res.primitive);\n    //if (cloudDist < res.dist) res = PrimitiveDist(cloudDist, CLOUD);\n    which = mix(float(SEALEVEL), which, step(dist, sealevelDist));\n    dist = mix(sealevelDist, dist, step(dist, sealevelDist));\n    which = mix(float(HELIX), which, step(dist, helixDist));\n    dist = mix(helixDist, dist, step(dist, helixDist));\n\n    //if (sealevelDist < res.dist) res = PrimitiveDist(sealevelDist, SEALEVEL);\n    //if (helixDist < res.dist) res = PrimitiveDist(helixDist, HELIX);\n\n    return PrimitiveDist(dist, int(which));\n\n}\n\nPrimitiveDist mapUnderSea(vec3 p) {\n    float terrainDist = mapTerrain(p, LOD_RAY);\n    float helixDist = mapHelix(p);\n\n    PrimitiveDist res = PrimitiveDist(terrainDist, TERRAIN);\n\n    if (helixDist < res.dist) res = PrimitiveDist(helixDist, HELIX);\n\n    return res;\n}\n\nconst float epsilon = 0.01;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p, int which) {\n    vec3 norm = vec3(0.);\n    if (which == TERRAIN) {\n        norm.x = mapTerrain(p + e.xyy, LOD_NORM) - mapTerrain(p - e.xyy, LOD_NORM);\n        norm.y = mapTerrain(p + e.yxy, LOD_NORM) - mapTerrain(p - e.yxy, LOD_NORM);\n        norm.z = mapTerrain(p + e.yyx, LOD_NORM) - mapTerrain(p - e.yyx, LOD_NORM);\n    } else if (which == SEALEVEL){\n        norm.x = mapSealevel(p + e.xyy, LOD_NORM) - mapSealevel(p - e.xyy, LOD_NORM);\n        norm.y = mapSealevel(p + e.yxy, LOD_NORM) - mapSealevel(p - e.yxy, LOD_NORM);\n        norm.z = mapSealevel(p + e.yyx, LOD_NORM) - mapSealevel(p - e.yyx, LOD_NORM);\n    } else {\n        norm.x = map(p + e.xyy).dist - map(p - e.xyy).dist;\n        norm.y = map(p + e.yxy).dist - map(p - e.yxy).dist;\n        norm.z = map(p + e.yyx).dist - map(p - e.yyx).dist;\n    }\n\n    return normalize(norm);\n}\n\n\nPrimitiveDist raymarchUnderSea(vec3 ro, vec3 rd, float maxDist, float marchSpeed) {\n    float marchDist = 0.001;\n    float boundingDist = maxDist;\n    float threshold = 0.1;\n\n    // Fill in the iteration count\n    for (int i = 0; i < 100; i++) {\n        // Fill in loop body\n        vec3 pos = ro + rd * marchDist;\n        PrimitiveDist near = mapUnderSea(pos);\n        if (near.dist < threshold)\n            return PrimitiveDist(marchDist, near.primitive);\n        marchDist += near.dist * marchSpeed;\n        if (marchDist > boundingDist) break;\n    }\n\n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd, float maxDist, float marchSpeed) {\n    float marchDist = 0.001;\n    float boundingDist = maxDist;\n    float threshold = 0.1;\n\n    // Fill in the iteration count\n    for (int i = 0; i < 200; i++) {\n        // Fill in loop body\n        vec3 pos = ro + rd * marchDist;\n        PrimitiveDist near = map(pos);\n        if (near.dist < threshold)\n            return PrimitiveDist(marchDist, near.primitive);\n        marchDist += near.dist * marchSpeed;\n        if (marchDist > boundingDist) break;\n    }\n\n    if ((ro.y < CLOUD_HEIGHT_MIN && rd.y > 0.) || (ro.y > CLOUD_HEIGHT_MAX && rd.y < 0.)) \n        return PrimitiveDist(-1.0, CLOUD);\n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 generateTerrainColor(vec3 pos, vec3 norm, vec3 lig) {\n    vec3 col = vec3(0.0);\n\n    vec3 lightGreen = vec3(0.564, 0.833, 0.564);\n    vec3 lawnGreen = vec3(0.498, 0.99, 0);\n    vec3 springGreen = vec3(0.0, 1.0, 0.5);\n    vec3 greenYellow = vec3(.678, 0.99, .184);\n    vec3 olive = vec3(0.5, 0.5, 0.0);\n\n    vec3 grass1 = vec3(.125, .365, .0);\n    vec3 grass2 = vec3(.16, .274, .141);\n    vec3 grass3 = vec3(.0, .2, .0);\n    vec3 grass4 = vec3(.45, .6, .0);\n\n    vec3 earth      = vec3(.824, .706, .549);\n    vec3 calcaire   = vec3(.624, .412, .118);\n    vec3 rocks      = vec3(.412, .388, .422);\n    vec3 beach      = vec3( 1.0, .894, .710);\n\n    float posNoise = valueNoise(pos.xz) + 1.0 * 0.5;\n    float darkness = 1.;\n      \n    // Ambient\n    float ambient = 0.2;\n    // Diffuse\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n    \n    // Shadow\n    /*\n    if (dot(norm, lig) > 0.) {\n        PrimitiveDist res = raymarch(pos + norm * .8, lig, 30., .8);\n        vec3 shadPos = pos + res.dist * lig;\n        if (res.primitive == HELIX || res.primitive == TERRAIN) {\n            darkness = smoothstep(0., 30., res.dist) * .8;\n        }\n    }*/\n\n\n    // base color\n    col = mix (        beach,    earth, smoothstep(0.0 , 0.08 , pos.y) );\n    col = mix ( col, calcaire, smoothstep(0.08, 0.3 , pos.y) );\n    col = mix ( col,    rocks, smoothstep(0.3, 10.0  , pos.y) );\n\n    return (ambient + diffuse * col) * darkness;\n}\n\nvec3 generateHelixColor(vec3 ro, vec3 rd, vec3 norm, vec3 lig) {\n    float ambient = 0.1;\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n    float specular = pow(clamp(dot(rd, reflect(lig, norm)), 0.0, 1.0), 16.);\n    \n    vec3 col = vec3(1., 1., .93);\n    return ambient + col * (diffuse + specular);\n}\n\nvec3 generateSeaColor(vec3 ro, vec3 rd, vec3 norm, vec3 lig) {\n    float ndotr = dot(norm, rd);\n    float r0 = .6;\n    r0 = min(r0 + .3 * max(valueNoise(vec3(ro.xz * 5., iTime * 10.)) - .2, 0.), 1.0);\n    float fresnel = r0 + (1. - r0) * pow(1.0 - abs(ndotr), 5.);\n    vec3 col = vec3(.292, .434, .729), reflCol, refrCol;\n    float darkness = 1.;\n    \n    // Reflection\n    vec3 reflD = reflect(rd, normalize(norm + vec3(.0, .3, .0)));\n    PrimitiveDist res = raymarch(ro, reflD, 100., .5);\n    vec3 reflPos = ro + res.dist * reflD;\n    if (res.primitive == TERRAIN) {\n        reflCol = generateTerrainColor(reflPos, calcNormal(reflPos, TERRAIN), lig);\n    } else if (res.primitive == HELIX) {\n    \treflCol = generateHelixColor(reflPos, reflD, calcNormal(reflPos, HELIX), lig);\n    }\n    \n    // Refraction\n    vec3 refrD = refract(rd, vec3(0., 1., 0.), .8);\n    res = raymarchUnderSea(ro, refrD, 20., .8);\n    vec3 refrPos = ro + res.dist * refrD;\n    //refrCol = texture(iChannel1, refrPos.xz * 2.).xyz;\n    if (res.primitive == TERRAIN) {\n        refrCol = generateTerrainColor(refrPos, calcNormal(refrPos, TERRAIN), lig);\n    } else if (res.primitive == HELIX) {\n    \trefrCol = generateHelixColor(refrPos, refrD, calcNormal(refrPos, HELIX), lig);\n    }\n    \n    col = mix(col, fresnel * reflCol + (1. - fresnel) * refrCol, .8);\n\n    // Shadow\n    res = raymarch(ro + vec3(0, .15, 0.), lig, 30., .5);\n    vec3 shadPos = ro + res.dist * lig;\n    if (res.primitive == HELIX || res.primitive == TERRAIN) {\n\t\tdarkness = 1. - 1. / (1. + res.dist * .1 + res.dist * .005);\n    }\n    \n    float ambient = 0.2;\n    float diffuse = clamp(dot(norm, lig), 0.0, 1.0);\n    float specular = pow(clamp(dot(rd, reflect(lig, norm)), 0.0, 1.0), 32.);\n    \n    return (ambient + col * (diffuse + specular)) * darkness;\n}\n\nvec3 generateCloudColor(vec3 ro, vec3 rd) {\n    vec3 bgc = vec3(0.3, .55, .8);\n    vec4 sum = vec4(0.);\n    float dist;\n    if (ro.y < CLOUD_HEIGHT_MIN) {\n    \tdist = (CLOUD_HEIGHT_MIN - ro.y) / rd.y + .01;\n        ro = ro + dist * rd;\n    } else if (ro.y > CLOUD_HEIGHT_MAX) {\n    \tdist = -(ro.y - CLOUD_HEIGHT_MAX) / rd.y + .01;\n        ro = ro + dist * rd;\n    }\n    \n    vec3 cloud1 = vec3(1.0,0.95,0.8);\n    vec3 cloud2 = vec3(0.25,0.3,0.35);\n    \n    //rd.y = max(rd.y, .2);\n    rd.y = sqrt(abs(rd.y)) * sign(rd.y);\n    //rd = normalize(rd);\n    \n    while ((sum.a < 1.0) && (ro.y > CLOUD_HEIGHT_MIN) && (ro.y < CLOUD_HEIGHT_MAX)) {\n    \tfloat density = fbmCloud(ro * rd.y, LOD_NORM) * .1;\n        vec3 col = mix(cloud1, cloud2, density);\n        sum.a += density;\n        sum.rgb += col * density * density * 15.;\n        ro = ro + rd * .5;\n    }\n    bgc = mix(bgc, sum.rgb, sum.a);\n\treturn bgc;\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n\n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(0.5,0.5,0.5));\n    vec3 lightCol = vec3(1., 1., 1.);\n\n    // Normal vector\n    vec3 nor = calcNormal(pos, which);\n\n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == TERRAIN) {\n        //material = texCube(iChannel0, pos, nor);\n        col = generateTerrainColor(pos, nor, lig);    \n    } else if (which == HELIX) {\n        col = generateHelixColor(pos, rd, nor, lig);\n    } else if (which == SEALEVEL){\n      \tcol = generateSeaColor(pos - rd * .05, rd, nor, lig);\n    } else if (which == CLOUD) {\n    \tcol = generateCloudColor(ro, rd);\n    }\n    \n    // Applying the phong lighting model to the pixel.\n    //col += vec3(((ambient + diffuse + specular) * darkness));\n    //col += vec3(ambient + diffuse + specular);\n\n    return col;\n}\n\nvec3 postProcess(vec3 col, vec2 uv) {\n    // Rain\n    vec2 rainUV = (uv * vec2(5., .3) + vec2(.8 * iTime - (uv.x + uv.y) * 1., .8 * iTime)) * 30. ;\n    float rain = max(valueNoise(rainUV), 0.) * .5;\n    col = mix(col, vec3(rain), .1);  \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float height = iTime * 2.;\n    \n    vec3 rayOrigin = vec3(20.0 * sin(iTime * .1), 20., 20.0 * cos(iTime * .1));\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0, 10., 0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n    \n    // Construct the ray direction vector\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    // AA\n    if (AA == 1) {\n        vec2 uvSize = 2. / iResolution.yx;\n    \t\n        for (int dx = -1; dx <= 1; dx += 2) {\n            for (int dy = -1; dy <= 1; dy += 2) {\n            \tvec2 puv = uv + vec2(float(dx) * uvSize.x * .25, float(dy) * uvSize.y * .25);\n                    vec3 rayDirection = vec3(puv, focalLength);\n                    rayDirection = normalize(puv.x * cameraRight + puv.y * cameraUp + focalLength * cameraForward);\n\n                    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection, 500., .5);\n                    vec3 tcol = vec3(0.3, .55, .8);\n                    if (rayMarchResult.primitive != NO_INTERSECT) {\n                      tcol = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n                    }\n\n                    // Postprocess\n    \t\t\t\ttcol = postProcess(tcol, uv);\n                col += tcol;\n            }\n        }\n        col *= .25;\n    } else if (AA == 0) {\n        vec3 rayDirection = vec3(uv, focalLength);\n        rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + focalLength * cameraForward);\n\n        PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection, 500., .5);\n        \n        if (rayMarchResult.primitive != NO_INTERSECT) {\n            col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n        }\n\n        // Postprocess\n        col = postProcess(col, uv);\n    }\n      \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}