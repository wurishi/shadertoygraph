{"ver":"0.1","info":{"id":"3dKGzW","date":"1569826923","viewed":212,"name":"Game 2D","username":"rmmcal","description":"Game 2D  - (\"Table hockey\"/\"Air Game\") Keeping the mouse pressed...  \nBlue => Player and computer\nRed => Ball\nGreen => Goal","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["2d","game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//---------------------------------------------------------\n// Brasil/Amazonas/Manaus\n// \n// Created by Rodrigo Cal (twitter: @rmmcal) - 2019/09\n//\n// Next pass: _PlayGame_\n//---------------------------------------------------------\n//  Play the game :)\n//\n///////////////////////////////\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define time iTime\n#define mouse iMouse.xy/iResolution.xy-.5\n#define resolution iResolution.xy\nuniform sampler2D backbuffer;\n\n#define PI 3.1416*2.\n\n//function header\nfloat grid(float scale, vec2 coordinate);\nfloat extract_bit(float n, float b);\nfloat sprite(float n, vec2 p);\nfloat digit(float n, vec2 p);\nfloat print_number(float index, vec2 position);\nfloat chr(float n, vec2 p);\n\n//////////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/distfunctions2d  \nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat sdLine2( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )+(step(0.5,mod(floor(length(pa)*100.),2.)*1000.));\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat printn(float n, vec2 p, vec2 t, vec2 s ){\n\tfloat d = 1.-smoothstep(0.,0.01, sdBox(p.xy-t,s) ) ;\n\td = min(d,  print_number(n, ceil((p.xy-t)*s*700.)) * 0.55) ;\n\treturn d;\t\n}\n//////////////////////////////////////////////////////////////////////\n\nvoid mainBuffer(  out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = (( gl_FragCoord.xy / resolution.xy -.5)*1.2)+.5;\n \tvec2 r = resolution;\n\tvec2 pm = (mouse)*vec2(2.,1.);\n\t\n\tconst int total = 3;\n\tconst int len = 4*total+1;\n\tvec4 m[len];\n\tfor (int i = 0 ; i < len; i++) \n\t\tm[i] = texture(iChannel0, vec2(float(i)+.5,0.)/r)*2.-1.;\n\t\n\tif (gl_FragCoord.y == .5)\n\t{\n\t\t// sequential logic\n\t\t\n\t\t\n\t\tif (distance( p-vec2(1.0,-.5), pm) < 0.15 || time < 2. ){ // Action Reset button\n\t\t\tm[0] *= 0.;\n\t\t\tfor (int i = 1+4; i < len; i+=4)\n\t\t\t{\t\n\t\t\t\tfloat f = float(i);\n\t\t\t\tm[i].xy = (fract(vec2(f*.123,f*.951))*2.-1.)*vec2(1.,.5)*.7;\n\t\t\t\tm[i].z = 1.;\n\t\t\t\tm[i+1] *= 0.;\n\t\t\t\tm[i+2] *= 0.;\n\t\t\t\tm[i+3] *= 0.;\n\t\t\t}\n\t\t} \n\t\t\n\t\tm[0].xy = pm;\n\t\tm[1].xyz = vec3(pm,1.);\n\t\tm[2].xy = (m[9].xy - m[1].xy)*.71;\n\t\tm[3] = vec4(0.,0.,1.,1.);\n\t\t \n\t\tfor (int j = 1; j < len; j+=4)\n\t\tfor (int i = 1; i < len; i+=4)\n\t\t{\n\t\t\tif (i <= j)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tm[i].z = 1.;\n\t\t\tvec2 p1 = m[i].xy;\n\t\t\tvec2 p1i = m[i+1].xy;\n\t\t\t\n\t\t\tvec2 p2 = m[j].xy;\n\t\t\tvec2 p2i = m[j+1].xy;\n\t\t\t\n\t\t\tfloat m1 = .1*m[i].z;\n\t\t\tfloat m2 = .1*m[j].z;\n\t\t\t\n\t\t\tif (distance( p2,p1)<((m1+m2)*1.)) // check collision\n\t\t\t{\t\n\t\t\t\tfloat theta1 = atan(p1i.y, p1i.x);\n\t\t\t\tfloat theta2 = atan(p2i.y, p2i.x);//atan2(v2.y, v2.x);\n\t\t\t\tfloat phi = atan(p2.y - p1.y, p2.x - p1.x);\n\t\t\t\tfloat m1z = m1;\n\t\t\t\tfloat m2z = m2;\n\t\t\t\tfloat v1z = length(p1);\n\t\t\t\tfloat v2z = length(p2);\n\t\t\t\t\n\t\t\t\tm[i+1].x = (v1z * cos(theta1 - phi) * (m1 - m2) + 2. * m2z * v2z * cos(theta2 - phi)) / (m1 + m2) * cos(phi) + v1z * sin(theta1 - phi) * cos(phi + PI / 2.);\n\t\t\t\tm[i+1].y = (v1z * cos(theta1 - phi) * (m1 - m2) + 2. * m2z * v2z * cos(theta2 - phi)) / (m1 + m2) * sin(phi) + v1z * sin(theta1 - phi) * sin(phi + PI / 2.);\n\t\n\t\t\t\tm[j+1].x = (v2z * cos(theta2 - phi) * (m2 - m1) + 2. * m1z * v1z * cos(theta1 - phi)) / (m1 + m2) * cos(phi) + v2z * sin(theta2 - phi) * cos(phi + PI / 2.);\n\t\t\t\tm[j+1].y = (v2z * cos(theta2 - phi) * (m2 - m1) + 2. * m1z * v1z * cos(theta1 - phi)) / (m1 + m2) * sin(phi) + v2z * sin(theta2 - phi) * sin(phi + PI / 2.);\n\t\n\t\t\t\tm[i+2] = vec4(1.,0.5,0.5,1.);\n\t\n\t\t\t}\n\t\t\t\n\t\t\tif (i > 8 ) // only balls (not players)\n\t\t\t{\n\t\t\t\tif ( m[i].x >= 0.89)\n\t\t\t\t{\n\t\t\t\t\tm[0].z += .01; \n\t\t\t\t\tif (m[0].z >= 1.)\n\t\t\t\t\t\tm[0].z = 0.; \t\n\t\t\t\t}\n\t\t\t\tif ( m[i].x <= -0.89)\n\t\t\t\t{\n\t\t\t\t\tm[0].w += .01; \n\t\t\t\t\tif (m[0].w >= 1.)\n\t\t\t\t\t\tm[0].w = 0.; \t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t{ // \"AI\" Player Computer.\n\t\t\t\t\tvec2 dir = m[i].xy - m[5].xy;\n\t\t\t\t\tfloat g = step( 0.8, m[i].x )*step( 0.8, m[6].x );\n\t\t\t\t\tm[6].xy = (dir -vec2(-0.07+min(0.,-pow(m[i+1].x,4.)),0.))*vec2(1.,2.)*.71;\n\t\t\t\t\t\n\t\t\t\t\tif (distance( m[5].xy ,m[i].xy )<((m1+m2)) && m[5].x > 0.85)\n\t\t\t\t\t{\n\t\t\t\t\t\tm[5].xy += vec2(0.2,0.);\n\t\t\t\t\t}\n\t\t\t\t\tif (distance( m[5].xy ,m[i].xy )<((m1+m2)*.2) )\n\t\t\t\t\t{\n\t\t\t\t\t\tm[5].xy += vec2(0.1,0.);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (m[i].x < -0.9 || m[i].x > 0.9)\n\t\t\t{\n\t\t\t\tm[i].x = clamp(m[i].x, -.9,.9);\n\t\t\t\tm[i+1].x *= -1.2;\n\t\t\t}\n\t\t\tif (m[i].y < -0.4 || m[i].y > 0.3 )\n\t\t\t{\n\t\t\t\tm[i].y = clamp(m[i].y, -.4,.29);\n\t\t\t\tm[i+1].y *= -1.2;\n\t\t\t}\n\t\t\t\n\t\t\tfloat sc = 0.6;\n\t\t\tm[i].xy += m[i+1].xy*.05 * (1.-clamp(-sc, sc, length(m[i+1].xy)));\n\t\t\tm[i+2] = vec4(1.,0.,0.,1.);\n\t\t}\t\t\n\t\t\n\t\tm[7] = vec4(0.,0.,1.,1.);\n\t\n\t\tfor (int i = 0 ; i < len; i++) \n\t\t\tif (gl_FragCoord.x == float(i)+.5)\n\t\t\t\tfragColor = clamp(m[i]*.5+.5, 0., 1.);\n\t\t\t\n\t}\n\telse\n\t{\n\t\t// UI\n\t\t\n\t\tp = (p-.5)*r/r.yy;\n\t\tvec4 d = vec4(1.);\n\t\t\n\t\td = mix(d, vec4(1.,1.,0.,1.), 1.-smoothstep(0.,0.01, length(p+vec2(1.0,-.5))-.1) ); // button\n\t\t\n\t\td = mix(d, vec4(vec3(0.9),1.), step(.01,-sdBox(p.xy-vec2(-0.0,-.04),vec2(1.04,.45)))* grid(10.,gl_FragCoord.xy) ); // grid\n\t\td = mix(d, vec4(0.0,.5,.5,1.), 1.-smoothstep(0.,0.01, sdBox(p.xy-vec2(0.,-.04),vec2(0.003,.45)) )) ; // div lines\n\t\td = mix(d, vec4(0.0,.9,.0,1.), 1.-smoothstep(0.,0.00, sdBox(p.xy-vec2(step(.8, p.x)*2.-1.,-.04),vec2(0.04,.45)) )); // gol\n\t\td = mix(d, vec4(0.,.0,.9,1.), 1.-smoothstep(0.,0.01, abs(sdBox(p.xy-vec2(-0.0,-.04),vec2(1.04,.45))) )) ; // board\n\t\t\n\t\tfor (int i = 1; i < len; i+=4)\n\t\t{\t\n\t\t\td = mix(d, m[i+2], 1.-smoothstep(0.,0.01, length(p-m[i].xy)-m[i].z*.1) ); // ball\n\t\t\td = mix(d, vec4(0.,1.,.5,1.), 1.-smoothstep(0.,0.01, sdLine(p, m[i].xy, m[i].xy+m[i+1].xy*.1)) ); // dir\n\t\t}\n\n\t\td = mix(d, vec4(0.,.5,.5,1.), 1.-smoothstep(0.,0.01, sdBox(p.xy-vec2(-0.4,.45),vec2(.1,.05)) )) ; // score box\n\t\td = mix(d, vec4(0.,1.,.5,1.), printn(m[0].z*100., p.xy,vec2(-0.41,.43),vec2(.1,.1)) ) ; // score play 1\n\n\t\td = mix(d, vec4(0.,.5,.5,1.), 1.-smoothstep(0.,0.01, sdBox(p.xy-vec2(0.4,.45),vec2(.1,.05)) )) ; // score box\n\t\td = mix(d, vec4(0.,1.,.5,1.), printn(m[0].w*100., p.xy,vec2(0.41,.43),vec2(.1,.1)) ) ; \t// score play 2\n\n \t\tfloat t = 0.;\t\n\t\tfor (float i = 0.; i < 7.; i++) t = max(t, chr(i, p.xy*90. -vec2(i*4.-21.,39.))); \t\n\t\td = mix(d, vec4(0.,1.,.5,1.), t ) ;\n\t\t\n\t\td = mix(d, vec4(0.,1.,.5,1.), chr(1., p.xy*90. -vec2(-90.,39.)) ) ; // UI Reset button\n\t\td = mix(d, vec4(0.,1.,.5,1.), printn(2019., p.xy,vec2(0.11,.44),vec2(.2,.2)) ) ;\n\t\td = mix(d, vec4(0.,1.,.5,1.), printn(-9., p.xy,vec2(0.25,.44),vec2(.2,.2)) ) ;\n\n\t\tfragColor = vec4( vec3( d.xyz), 1.0 );\n\t}\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mainBuffer(fragColor, fragCoord);\n   // fragColor = vec4(.5);\n}\n\n// print digits from : http://glslsandbox.com/e#57264.0\n//\n\n//\n//the rest of these functions are just for drawing the numbers and grid\n\n//draws a grid\nfloat grid(float scale, vec2 coordinate)\n{\n\treturn max(float(mod(coordinate.x, scale) < 1.), float(mod(coordinate.y, scale) < 1.));\n}\n\n//returns the bit 1 or 0 from number n at power b\nfloat extract_bit(float n, float p)\n{\n\tn = floor(n);\n\tp = floor(p);\n\tp = floor(n/pow(2.,p));\n\treturn float(mod(p,2.) == 1.);\n}\n\n\n//draws the bits of n into a 3 by 5 sprite over p\nfloat sprite(float n, vec2 p)\n{\n\tp \t\t= floor(p);\n\tfloat bounds \t= float(all(lessThan(p, vec2(3., 5.))) && all(greaterThanEqual(p,vec2(0,0))));\n\treturn extract_bit(n, (2. - p.x) + 3. * p.y) * bounds;\n}\n\n\n//maps input n to the corrosponding float representing it's sprite graphic\nfloat digit(float n, vec2 p)\n{\n\tn = mod(floor(n), 10.0);\n\tif(n == 0.) return sprite(31599., p);\n\telse if(n == 1.) return sprite( 9362., p);\n\telse if(n == 2.) return sprite(29671., p);\n\telse if(n == 3.) return sprite(29391., p);\n\telse if(n == 4.) return sprite(23497., p);\n\telse if(n == 5.) return sprite(31183., p);\n\telse if(n == 6.) return sprite(31215., p);\n\telse if(n == 7.) return sprite(29257., p);\n\telse if(n == 8.) return sprite(31727., p);\n\telse if(n == 9.) return sprite(31695., p);\n\telse return 0.0;\n}\n\n//prints a number n\nfloat print_number(float number, vec2 position)\n{\t\n\tfloat result\t= 0.;\n\tresult \t\t+= number < 0. ? sprite(24., position + vec2(4., 0.)) : 0.;\t\t\n\tfor(int i = 8; i >= 0; i--)\n\t{\n\t\tfloat place = pow(10., float(i));\n\t\tif(number >= place || float(i) < 1.)\n\t\t{\n\t\t\tresult\t \t+= digit(abs(number/place), position);\n\t\t\tposition.x \t-= 4.;\n\t\t}\n\t}\n\treturn result;\n}\n\n////////////\n\nfloat chr(float n, vec2 p)\n{\n\tif(n == 0.) return 0.;\n\telse if(n == 1.) return sprite(31661., p);\n\telse if(n == 2.) return sprite(24429., p);\n\telse if(n == 3.) return sprite(24429., p);\n\telse if(n == 4.) return sprite(31015., p);\n\telse if(n == 5.) return sprite(31725., p);\n\telse if(n == 6.) return sprite(18727., p);\n\telse return 0.0;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}