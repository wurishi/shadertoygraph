{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Studied the shader here: https://www.shadertoy.com/view/4ds3zs\n// And decided to try and write a raytracer myself.\n// Some code is very similar.\n\nconst int SPHERE_ID = 1;\nconst int PLANE_ID = 2;\n\nstruct ray\n{\n \tvec3 origin;\n    vec3 direction;\n};\n    \nstruct sphere\n{\n    vec3 position;\n \tfloat radius;   \n};\n\n// Based on the following formula:\n// http://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\nfloat iSphere(in vec3 ro, in vec3 rd, in vec3 sc, in float sr)\n{\n    vec3 m = ro - sc;\n    float dotRdM = dot(rd, m);\n    \n    float a = dot(rd, rd);\n    float b = 2.0*dotRdM;\n    float c = (dot(m, m) - sr*sr);\n    \n    float d = pow(dotRdM,2.0)-dot(m, m)+sr*sr;\n    \n    if(d < 0.0)\n    {\n        return -1.0;\n    }\n    \n    return -dotRdM-sqrt(d);\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd)\n{\n    return -ro.y/rd.y;\n}\n\nint intersectScene(ray r, sphere s, inout float dist)\n{\n    dist = 10000.0;\n    \n    float distSphere = iSphere(r.origin, r.direction, s.position, s.radius);\n    float distPlane = iPlane(r.origin, r.direction);\n    \n    int id = -1;\n    \n    if(distSphere > 0.0)\n    {\n        id = SPHERE_ID;\n        dist = distSphere;\n    }\n    \n    if(distPlane > 0.0 && distPlane < dist)\n    {\n        id = PLANE_ID;\n        dist = distPlane;\n    }\n    \n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light direction\n    vec3 lightDir = normalize(vec3(0.57703));\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 scale = vec3(1.0, iResolution.y/iResolution.x, 1.0);\n    \n    // Sphere\n    sphere sphere;\n    sphere.radius = 0.5;\n    sphere.position = vec3(0.0, 1.0, 1.0) * scale;\n    \n    // View ray\n    ray viewRay;\n    viewRay.origin = vec3(0.0, 0.6, 3.0);\n\tviewRay.direction = normalize(vec3( (uv * 2.0 - 1.0), -1.0) * scale);\n    \n    float dist;\n    int id = intersectScene(viewRay, sphere, dist);\n\tvec3 hitPos = viewRay.origin + dist * viewRay.direction;\n    \n    vec3 col = vec3(0.6, 0.6, 1.0);\n    \n    if(id == SPHERE_ID)\n    {\n        vec3 normal = (hitPos - sphere.position) / sphere.radius;\n        \n        // Diffuse lighting\n        float diff = max(0.0, dot(normal, lightDir));\n\n        col = vec3(1.0, 0.5, 0.5)*diff;\n    }\n    else if(id == PLANE_ID)\n    {\n        vec3 normal = vec3(0.0, 1.0, 0.0);\n        \n        // Ambient occlusion\n        float amb = smoothstep(0.0, 2.0* sphere.radius, length(hitPos.xz-sphere.position.xz));\n        \n        col = vec3(0.3, 0.8, 0.3) * amb;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xd2XRW","date":"1410080545","viewed":233,"name":"Tracing rays","username":"mathiassoeholm","description":"Tracing rays","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""}}