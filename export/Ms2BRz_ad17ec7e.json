{"ver":"0.1","info":{"id":"Ms2BRz","date":"1499820618","viewed":1158,"name":"Chain Spell","username":"leon","description":"Raymarching sketch about magic. I've started with the three turning spells, then a broken chain and finally a storm trapped in a sphere.  \nUse mouse to move camera.","likes":60,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","magic","chain","spell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Raymarching sketch about magic.\n// I've started with the three turning spells,\n// then a broken chain and finally a storm trapped in a sphere.\n\n// Leon 12 / 07 / 2017\n// using lines of code of IQ, Mercury, LJ, Koltes, Duke\n\n#define PI 3.14159\n#define TAU PI*2.\n#define t iTime\n\n// number of ray\n#define STEPS 30.\n\n// distance minimum for volume collision\n#define BIAS 0.001\n\n// distance minimum \n#define DIST_MIN 0.01\n\n// rotation matrix\nmat2 rot (float a) { float c=cos(a),s=sin(a);return mat2(c,-s,s,c); }\n\n// distance field funtions\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdTorus( vec3 p, vec2 s ) {\n  vec2 q = vec2(length(p.xz)-s.x,p.y);\n  return length(q)-s.y;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// smooth minimum\nfloat smin (float a, float b, float r) {\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b,a,h)-r*h*(1.-h);\n}\n\n// dat one line random function \nfloat rand(vec2 co) { return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453); }\n\n// polar domain repetition\nvec3 moda (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an/2.;\n    float c = floor(a/an);\n    a = mod(a,an)-an/2.;\n    return vec3(vec2(cos(a),sin(a))*length(p),c);\n}\n\n// the rythm of animation\n// change the 3. to have more or less spell\nfloat getLocalWave (float x) { return sin(-t+x*3.); }\n\n// displacement in world space of the animation\nfloat getWorldWave (float x) { return 1.-.1*getLocalWave(x); }\n\n// camera control\nvec3 camera (vec3 p) {\n    p.yz *= rot((PI*(iMouse.y/iResolution.y-.5)));\n    p.xz *= rot((PI*(iMouse.x/iResolution.x-.5)));\n    return p;\n}\n \n// position of chain\nvec3 posChain (vec3 p, float count) {\n    float za = atan(p.z,p.x);\n    vec3 dir = normalize(p);\n    \n    // domain repetition\n    vec3 m = moda(p.xz, count);\n    p.xz = m.xy;\n    float lw = getLocalWave(m.z/PI);\n    p.x -= 1.-.1*lw;\n    \n    // the chain shape\n    p.z *= 1.-clamp(.03/abs(p.z),0.,1.);\n    \n    // animation of breaking chain\n    float r1 = lw*smoothstep(.1,.5,lw);\n    float r2 = lw*smoothstep(.4,.6,lw);\n    p += dir*mix(0., 0.3*sin(floor(za*3.)), r1);\n    p += dir*mix(0., 0.8*sin(floor(za*60.)), r2);\n    \n    // rotate chain for animation smoothness\n    float a = lw * .3;\n    p.xy *= rot(a);\n    p.xz *= rot(a);\n    return p;\n}\n\n// distance function for spell\nfloat mapSpell (vec3 p) {\n    float scene = 1.;\n    float a = atan(p.z,p.x);\n    float l = length(p);\n    float lw = getLocalWave(a);\n    \n    // warping space into cylinder\n    p.z = l-1.+.1*lw;\n    \n    // torsade effect\n    p.yz *= rot(t+a*2.);\n    \n    // long cube shape\n    scene = min(scene, sdBox(p, vec3(10.,vec2(.25-.1*lw))));\n    \n    // long cylinder cutting the box (intersection difference)\n    scene = max(scene, -sdCylinder(p.zy, .3-.2*lw));\n    return scene;\n}\n\n// distance function for the chain\nfloat mapChain (vec3 p) {\n    float scene = 1.;\n    \n    // number of chain\n    float count = 21.;\n    \n    // size of chain\n    vec2 size = vec2(.1,.02);\n    \n    // first set of chains\n    float torus = sdTorus(posChain(p,count).yxz,size);\n    scene = smin(scene, torus,.1);\n    \n    // second set of chains\n    p.xz *= rot(PI/count);\n    scene = min(scene, sdTorus(posChain(p,count).xyz,size));\n    return scene;\n}\n\n// position of core stuff\nvec3 posCore (vec3 p, float count) {\n    \n    // polar domain repetition\n    vec3 m = moda(p.xz, count);\n    p.xz = m.xy;\n    \n    // linear domain repetition\n    float c = .2;\n    p.x = mod(p.x,c)-c/2.;\n    return p;\n}\n\n// distance field for the core thing in the center\nfloat mapCore (vec3 p) {\n    float scene = 1.;\n    \n    // number of torus repeated\n    float count = 10.;\n    float a = p.x*2.;\n    \n    // displace space\n    p.xz *= rot(p.y*6.);\n    p.xz *= rot(t);\n    p.xy *= rot(t*.5);\n    p.yz *= rot(t*1.5);\n    vec3 p1 = posCore(p, count);\n    vec2 size = vec2(.1,.2);\n    \n    // tentacles torus shape\n    scene = min(scene, sdTorus(p1.xzy*1.5,size));\n    \n    // sphere used for intersection difference with the toruses\n    scene = max(-scene, sdSphere(p,.6));\n    return scene;\n}\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    // raymarch camera\n\tvec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 eye = camera(vec3(uv,-1.5));\n    vec3 ray = camera(normalize(vec3(uv,1.)));\n    vec3 pos = eye;\n    \n    // dithering\n\tvec2 dpos = ( coord.xy / iResolution.xy );\n\tvec2 seed = dpos + fract(iTime);\n    \n    float shade = 0.;\n    for (float i = 0.; i < STEPS; ++i) {\n        \n        // distance from the different shapes\n\t\tfloat distSpell = min(mapSpell(pos), mapCore(pos));\n\t\tfloat distChain = mapChain(pos);\n        float dist = min(distSpell, distChain);\n        \n        // hit volume\n        if (dist < BIAS) {\n            \n            // add shade\n            shade += 1.;\n            \n            // hit non transparent volume\n            if (distChain < distSpell) {\n                \n                // set shade and stop iteration\n                shade = STEPS-i-1.;\n                break;\n            }\n        }\n        \n        // dithering\n        dist=abs(dist)*(.8+0.2*rand(seed*vec2(i)));\n        \n        // minimum step\n        dist = max(DIST_MIN,dist);\n        \n        // raymarch\n        pos += ray*dist;\n    }\n    \n    // color from the normalized steps\n    color = vec4(shade/(STEPS-1.));\n}","name":"Image","description":"","type":"image"}]}