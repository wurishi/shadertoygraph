{"ver":"0.1","info":{"id":"MlByzh","date":"1507375374","viewed":755,"name":"Pixel Heart","username":"fizzer","description":".","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["pixel","heart","shiny","pixelart","cracked"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pattern[64];\nfloat patternArrayLookup(float index);\nvoid populatePatternTable();\n\nconst float pi = acos(-1.);\n\n\n// Noise functions from IQ.\nfloat hash(float n)\n{\n    return fract(sin(mod(n,3.1415926*2.0)*sign(n))*43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nfloat valnoise(vec2 p)\n{\n    vec2 c=floor(p);\n    vec2 f=fract(p);\n    return mix (mix(noise(c+vec2(0,0)), noise(c+vec2(1,0)), f.x),\n                mix(noise(c+vec2(0,1)), noise(c+vec2(1,1)), f.x), f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float f=0.;\n    float s=1.;\n    for(int i=0;i<6;++i)\n    {\n        f+=(valnoise(p*s)-.5)/s;\n        s*=2.;\n    }\n    return f;\n}\n\n// Distance field function.\nfloat f(vec3 p,float cracks)\n{\n    vec3 op=p;\n\n    // Mirror symmetry of heart.\n    p.x=abs(p.x)-.4;\n\n    // Rotation for the angle of each heart half.\n    float a=-.75;\n    p.xy*=mat2(cos(a),sin(a),-sin(a),cos(a));\n\n    // Stretch the middle part of the space.\n    p.y=clamp(abs(p.y+.3)-.5,0.,1.);\n\n    // Mirror symmetry of sphere-like shape.\n    p=abs(p);\n\n    float d=-1e4;\n    \n    // Sphere-like shape created by combining a set of planes using subtractive CSG.\n    for(int i=0;i<5;++i)\n        for(int j=0;j<3;++j)\n        {\n            // Phi and Theta angles for the plane normal.\n            float ph=float(i)/4.*pi/2.;\n            float te=float(j)/4.*pi/2.+.4*1.4*sin(float(i))*.64;\n            \n            // Construct plane normal.\n            vec3 pn=vec3(cos(ph)*cos(te),sin(te),sin(ph)*cos(te));\n            pn=normalize(pn*vec3(1,1,.4));\n\n            // Perform the subtraction.\n            d=max(d,dot(p,pn)-.62+pn.z*.2+clamp(-op.y,0.,1.)/15.);\n        }\n\n    // Add cracks if desired.\n    d+=cracks*.7*(1.-clamp(abs(fbm(op.xy*1.2+10.35))*38.-.1,0.,1.))*.005*smoothstep(.1,.51,valnoise(op.xy*4.+.75));    \n\n    return d;\n}\n\nvec3 sampleNormal(vec3 rp,float cracks)\n{\n    vec2 e=vec2(2e-4,0);\n\n    float d=f(rp,cracks);\n    float d0=f(rp+e.xyy,cracks);\n    float d1=f(rp+e.yxy,cracks);\n    float d2=f(rp+e.yyx,cracks);\n    vec3 n=normalize(vec3(d0-d,d1-d,d2-d));\n\n    return n;\n}\n\nfloat sampleCurvature(vec3 p)\n{\n    vec3 EPS=vec3(15e-3,0,0);\n    vec3 n0 = sampleNormal(p,0.);\n    vec3 n1 = sampleNormal(p + EPS.xyy,0.);\n    vec3 n2 = sampleNormal(p + EPS.yxy,0.);\n    vec3 n3 = sampleNormal(p + EPS.yyx,0.);\n\n    return length(n1 - n0) + length(n2 - n0) + length(n3 - n0);\n}\n\n\nfloat mind=1e4;\n\n// SDF raymarching function.\nfloat trace(vec3 ro,vec3 rd)\n{\n    float t=0.,d=0.;\n    for(int i=0;i<50;++i)\n    {\n        d=f(ro+rd*t,1.);\n        mind=min(mind,d);\n        if(d<1e-3||t>10.)break;\n        t+=d;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tpopulatePatternTable();\n        \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n    vec2 t=(uv.xy*2.-1.)*.9;\n    t.x *= iResolution.x / iResolution.y;\n\n    vec2 pix=floor(t*70.);\n    t=pix/70.;\n\n    // Set up primary ray.\n    vec3 ro=vec3(0.1,-.1,2.4);\n    vec3 rd=normalize(vec3(t.xy,-1.5));\n    float an=0.25;\n\n    rd.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xz;\n    ro.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xz;\n\n\n    an=3.;\n\n    rd.xy=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xy;\n    ro.xy=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xy;\n\n\n    // Trace primary ray.\n    float g = trace(ro,rd);\n\n    \n    if(g>4.)\n    {\n        // Shade the background.\n        fragColor.rgb=mix(vec3(.15),vec3(.4),clamp((mind-.03)/.015,0.,1.))*vec3(1,.8,.81);\n        fragColor.rgb*=(5.-t.x+t.y)/2.5;\n\n        fragColor.rgb*=mix(vec3(1,.25,.25)/2.,vec3(1),smoothstep(-.5,1.1,distance(t,vec2(.15,-.15)/2.)));\n\n    }\n    else\n    {\n        // Shade the heart.\n        vec3 rp=ro+rd*g;\n\n        vec3 n=sampleNormal(rp,1.);\n        float c=sampleCurvature(rp);\n\n        vec3 r=reflect(rd,n);\n\n        fragColor.rgb=vec3(0,0,1)/20.+vec3(.6+.4*n.x)*vec3(1,.5,.5)+step(.07,abs(c))/3.*0.1;\n        fragColor.rgb+=pow(clamp(r.x,0.,1.),16.)*(1.+c*4.);\n        fragColor.rgb+=pow(clamp(-r.x+r.y/8.,0.,1.),6.)*(1.+c)*.3;\n\n        fragColor.rgb+=.03*(1.-smoothstep(0.,.05,abs(t.x*2.-t.y-.2+n.x*.5)-.1));\n        fragColor.rgb+=.01*(1.-smoothstep(0.,.05,abs(t.x*2.-t.y-.5+n.x*.5)-.0));\n        fragColor.rgb+=.015*(1.-smoothstep(0.,.05,abs(t.x*2.-t.y+.6+n.x*.5)-.1));\n    }\n\n    // Shade lensflare #1\n    {\n        vec2 p=t-vec2(-.41,0.4);\n        fragColor.rgb+=.2*vec3(1,.5,.5)*(.01/(abs(p.y)+0.01)/(abs(p.x)+.02))/3.*exp(-length(p));\n    }\n\n    // Shade lensflare #2\n    {\n        vec2 p=t-vec2(.63,0.);\n        fragColor.rgb+=.06*vec3(1,.5,.5)*(.01/(abs(p.y)+0.01)/(abs(p.x)+.02))/3.*exp(-length(p));\n    }\n\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\n\n\n    // Create a polygonal border shape.\n    {\n        float md=-1e4;\n        for(int i=0;i<7;++i)\n        {\n            float a=float(i)*1.9+cos(float(i)*7.)*.4+7.;\n            vec2 n=vec2(cos(a),sin(a));\n            float d=dot(t-vec2(-.01,.02),n)-.9;\n            md=max(md,d);\n        }\n        fragColor.rgb*=1.-clamp(md*148.,0.,1.);\n        fragColor.rgb+=(1.-clamp(abs(md)*18.,0.,1.))*vec3(1,.5,.5)/5.;\n        fragColor.rgb+=.112*clamp(md*148.,0.,1.)*length(t.xy);\n    }\n\n\n    // Apply Bayer ordered dither.\n    fragColor.rgb=(floor(fragColor.rgb*64.-patternArrayLookup(((mod(pix.x,8.))) + 8. * ((mod(pix.y,8.))))/64.))/64.;\n\n    fragColor.rgb=pow(fragColor.rgb,vec3(.9));\n}\n\n// This is a workaround for the lack of dynamic array lookup in GLES.\nfloat patternArrayLookup(float index)\n{\n    if(index<0.5)return pattern[0];\n    if(index<1.5)return pattern[1];\n    if(index<2.5)return pattern[2];\n    if(index<3.5)return pattern[3];\n    if(index<4.5)return pattern[4];\n    if(index<5.5)return pattern[5];\n    if(index<6.5)return pattern[6];\n    if(index<7.5)return pattern[7];\n    if(index<8.5)return pattern[8];\n    if(index<9.5)return pattern[9];\n    if(index<10.5)return pattern[10];\n    if(index<11.5)return pattern[11];\n    if(index<12.5)return pattern[12];\n    if(index<13.5)return pattern[13];\n    if(index<14.5)return pattern[14];\n    if(index<15.5)return pattern[15];\n    if(index<16.5)return pattern[16];\n    if(index<17.5)return pattern[17];\n    if(index<18.5)return pattern[18];\n    if(index<19.5)return pattern[19];\n    if(index<20.5)return pattern[20];\n    if(index<21.5)return pattern[21];\n    if(index<22.5)return pattern[22];\n    if(index<23.5)return pattern[23];\n    if(index<24.5)return pattern[24];\n    if(index<25.5)return pattern[25];\n    if(index<26.5)return pattern[26];\n    if(index<27.5)return pattern[27];\n    if(index<28.5)return pattern[28];\n    if(index<29.5)return pattern[29];\n    if(index<30.5)return pattern[30];\n    if(index<31.5)return pattern[31];\n    if(index<32.5)return pattern[32];\n    if(index<33.5)return pattern[33];\n    if(index<34.5)return pattern[34];\n    if(index<35.5)return pattern[35];\n    if(index<36.5)return pattern[36];\n    if(index<37.5)return pattern[37];\n    if(index<38.5)return pattern[38];\n    if(index<39.5)return pattern[39];\n    if(index<40.5)return pattern[40];\n    if(index<41.5)return pattern[41];\n    if(index<42.5)return pattern[42];\n    if(index<43.5)return pattern[43];\n    if(index<44.5)return pattern[44];\n    if(index<45.5)return pattern[45];\n    if(index<46.5)return pattern[46];\n    if(index<47.5)return pattern[47];\n    if(index<48.5)return pattern[48];\n    if(index<49.5)return pattern[49];\n    if(index<50.5)return pattern[50];\n    if(index<51.5)return pattern[51];\n    if(index<52.5)return pattern[52];\n    if(index<53.5)return pattern[53];\n    if(index<54.5)return pattern[54];\n    if(index<55.5)return pattern[55];\n    if(index<56.5)return pattern[56];\n    if(index<57.5)return pattern[57];\n    if(index<58.5)return pattern[58];\n    if(index<59.5)return pattern[59];\n    if(index<60.5)return pattern[60];\n    if(index<61.5)return pattern[61];\n    if(index<62.5)return pattern[62];\n    if(index<63.5)return pattern[63];\n    return 0.0;\n}\n\nvoid populatePatternTable()\n{\n    // This table is from http://www.efg2.com/Lab/Library/ImageProcessing/DHALF.TXT.\n    pattern[0x00]=   0.; pattern[0x01]= 32.; pattern[0x02]=  8.; pattern[0x03]= 40.; pattern[0x04]=  2.; pattern[0x05]= 34.; pattern[0x06]= 10.; pattern[0x07]= 42.;   /* 8x8 Bayer ordered dithering  */\n    pattern[0x08]=  48.; pattern[0x09]= 16.; pattern[0x0a]= 56.; pattern[0x0b]= 24.; pattern[0x0c]= 50.; pattern[0x0d]= 18.; pattern[0x0e]= 58.; pattern[0x0f]= 26.;   /* pattern.  Each input pixel   */\n    pattern[0x10]=  12.; pattern[0x11]= 44.; pattern[0x12]=  4.; pattern[0x13]= 36.; pattern[0x14]= 14.; pattern[0x15]= 46.; pattern[0x16]=  6.; pattern[0x17]= 38.;   /* is scaled to the 0..63 range */\n    pattern[0x10]=  60.; pattern[0x19]= 28.; pattern[0x1a]= 52.; pattern[0x1b]= 20.; pattern[0x1c]= 62.; pattern[0x1d]= 30.; pattern[0x1e]= 54.; pattern[0x1f]= 22.;   /* before looking in this table */\n    pattern[0x20]=   3.; pattern[0x21]= 35.; pattern[0x22]= 11.; pattern[0x23]= 43.; pattern[0x24]=  1.; pattern[0x25]= 33.; pattern[0x26]=  9.; pattern[0x27]= 41.;   /* to determine the action.     */\n    pattern[0x20]=  51.; pattern[0x29]= 19.; pattern[0x2a]= 59.; pattern[0x2b]= 27.; pattern[0x2c]= 49.; pattern[0x2d]= 17.; pattern[0x2e]= 57.; pattern[0x2f]= 25.;\n    pattern[0x30]=  15.; pattern[0x31]= 47.; pattern[0x32]=  7.; pattern[0x33]= 39.; pattern[0x34]= 13.; pattern[0x35]= 45.; pattern[0x36]=  5.; pattern[0x37]= 37.;\n    pattern[0x30]=  63.; pattern[0x39]= 31.; pattern[0x3a]= 55.; pattern[0x3b]= 23.; pattern[0x3c]= 61.; pattern[0x3d]= 29.; pattern[0x3e]= 53.; pattern[0x3f]= 21.;\n}\n","name":"Image","description":"","type":"image"}]}