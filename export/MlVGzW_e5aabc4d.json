{"ver":"0.1","info":{"id":"MlVGzW","date":"1473631245","viewed":236,"name":"heightfield area lighting","username":"Pyry","description":"gpu murdering area lighting on a heightfield\nclick the mouse to move the light position around","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["heightfield","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a lot of this is cobbled together from iq's \"balls and occlusion\"\n// https://www.shadertoy.com/view/ldX3Ws\n\n#define RIPPLE_FREQ 80.0\n#define RIPPLE_AMP 0.022\n\nvec4 test_heightfield(vec2 uv) \n{\n    // just do a ripple pattern because that's easy\n    vec2 rr = uv - vec2(0.5, 0.28);\n    float r = length(rr);\n    float height = RIPPLE_AMP * sin(RIPPLE_FREQ * r + iTime) + RIPPLE_AMP;\n    \n    // analytic partial derivatives are then also easy\n    float dr = RIPPLE_AMP * RIPPLE_FREQ * cos(RIPPLE_FREQ * r + iTime);\n\tvec2 dxy = normalize(rr) * dr;\n    \n    // normal that is tangent to (1,0,dx), (0,1,dy) is just (-dx, -dy, 1.0)\n    vec3 vvv = normalize(vec3(-dxy.x, -dxy.y, 1.0));\n    \n    // return normal+height packed into rgba\n    return vec4(vvv, height);\n}\n\nfloat test_height(vec3 pos)\n{\n    // just do a ripple pattern because that's easy\n    vec2 rr = pos.xy - vec2(0.5, 0.28);\n    float r = length(rr);\n    float height = RIPPLE_AMP * sin(RIPPLE_FREQ * r + iTime)  + RIPPLE_AMP;\n    return height;\n}\n\n#define eps 0.001\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n#define TRACE_ITERS 10\n#define TRACE_DELTA 0.01\n#define LIGHT_HEIGHT 0.1\n#define LIGHT_SIZE 0.2\n\nvec3 light_strip(in vec2 planepos) {\n    vec2 mousepos = iMouse.xy / iResolution.xx;\n    if(planepos.x + LIGHT_SIZE > mousepos.x && planepos.x - LIGHT_SIZE < mousepos.x \n       && planepos.y + LIGHT_SIZE > mousepos.y && planepos.y - LIGHT_SIZE < mousepos.y){\n        return vec3(1.0,1.0,1.0);\n    } else {\n        return vec3(0.0,0.0,0.0);\n    }\n}\n\nvec2 intersect_light_plane(in vec3 ro, in vec3 rd) {\n    // ro.z + rd.z*t = LIGHT_HEIGHT\n    float t = (LIGHT_HEIGHT - ro.z) / rd.z;\n    return ro.xy + t*rd.xy;\n}\n\nvec3 sample_plane_light( in vec3 ro, in vec3 rd )\n{\n    vec3 curpos = ro + rd; // step it once to avoid issues with a point shadowing itself\n    \n    // Are if statements still a performance killer?\n\tfor( int i=0; i<TRACE_ITERS; i++ )\n\t{\n        float field_h = test_height(curpos);\n        if(curpos.z < field_h) return vec3(0.0, 0.0, 0.0);\n        curpos = curpos + rd;\n\t}\n    if(rd.z > 0.0){\n        vec2 planepos = intersect_light_plane(ro, rd);\n        return light_strip(planepos);\n    } else {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvec3 sample_lighting(vec2 fragCoord, vec3 pos, vec3 nor)\n{\n    vec3 total_light = vec3(0.0, 0.0, 0.0);\n    \n    // see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n    // (link provided by nimitz)\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n   \tvec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float off = texture( iChannel1, fragCoord.xy/iChannelResolution[1].xy, -100.0 ).x;\n\tfor( int j=0; j<24; j++ )\n\t{\n        // This is blatantly stolen from iq's thing, so I'm not really sure what distribution\n        // of sampling directions this produces\n\t\tvec2  aa = hash2( off + float(j)*203.1 );\n\t\tfloat ra = sqrt(aa.y);\n\t\tfloat rx = ra*cos(6.2831*aa.x); \n\t\tfloat ry = ra*sin(6.2831*aa.x);\n\t\tfloat rz = sqrt( 1.0-aa.y );\n\t\tvec3  rr = vec3( rx*uu + ry*vv + rz*nor );\n        \n        // I'm going to go ahead and weight according to dot(normal, rr) = rz on the assumption\n        // that the above produces a uniform-ish distribution over the hemisphere\n        total_light += sample_plane_light(pos, rr*TRACE_DELTA) * rz;\n\t}\n    \n    // this is not the \"physically correct\" normalization but :effort:\n\ttotal_light /= 24.0;\n    return total_light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx; // Note division by xx to get same scale in x and y\n    vec4 norm_height = test_heightfield(uv);\n    \n    vec3 pos = vec3(uv, norm_height.w);\n    vec3 lighting = sample_lighting(fragCoord, pos, norm_height.xyz);\n    fragColor = vec4(lighting, 1.0); // probably should put a togamma here\n}","name":"Image","description":"","type":"image"}]}