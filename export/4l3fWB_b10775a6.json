{"ver":"0.1","info":{"id":"4l3fWB","date":"1549945018","viewed":82,"name":"cogs2","username":"teraspora","description":"Mouse changes scale and orbit of one cog","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415922653589793234\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My inline library of useful functions:\n// =======================================\n\nfloat hue(vec3 col) {\n    return rgb2hsl(col).s;\n}\n\nvec3 changeHue(vec3 col, float newHue) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.s = newHue;\n    return hsl2rgb(colHSL);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance order 1\n    if (order <= 0.) return 0.;\t\t\t\t// i.e. Manhattan distance\n\treturn abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order)), 1. / order)); \n}\n\nfloat minkl(vec2 v, float order) {\t// Minkowski distance order 1\n    if (order <= 0.) return 0.;\t\t\t\t// i.e. Manhattan distance\n\treturn abs(pow(abs(pow(v.x, order)) + abs(pow(v.y, order)), 1. / order)); \n}\n\nfloat saw_wave(float val, float amp) {\n    return (val - floor(val)) * amp;\n}\n\nfloat sq_wave(float val, float amp) {\n    float oe = sign(sin(pi * val));\n    return oe * amp / pi;\n}\n\nfloat yes(float x, float a, float b, float c) {\n\treturn sin(exp(a * x) - b * sin(c * x));\n}\n\nvec2 yes(vec2 v, float a, float b, float c) {\n\treturn vec2(yes(v.x, a, b, c), yes(v.y, a, b, c));\n}\n\nvec3 yes(vec3 v, float a, float b, float c) {\n\treturn vec3(yes(v.x, a, b, c), yes(v.y, a, b, c), yes(v.z, a, b, c));\n}\n\nfloat afsin(float amp, float freq, float x) {\n\treturn amp * sin(freq * x);\n}\n\nfloat afcos(float amp, float freq, float x) {\n\treturn amp * cos(freq * x);\n}\n\nfloat nafsin(float amp, float freq, float x) {\n\tfloat a = afsin(amp, freq, 0.);\n    float b = afsin(amp, freq, 1.);\n    float afs = afsin(amp, freq, x);\n    if (b == a || (a == 0. && b == 1.)) return afs;\n    return (afs - a) / (b - a);\n}\n\nfloat nafcos(float amp, float freq, float x) {\n\tfloat a = afcos(amp, freq, 0.);\n    float b = afcos(amp, freq, 1.);\n    float afc = afcos(amp, freq, x);\n    if (b == a || (a == 0. && b == 1.)) return afc;\n    return (afc - a) / (b - a);\n}\n\nvec2 nafcos(float amp, float freq, vec2 v) {\n    return vec2(nafcos(amp, freq, v.x), nafcos(amp, freq, v.y));\n}\n\n\n\n\nfloat cog_sq(vec2 v, float amp, float freq, float depth) {\n    float lv = length(v);\n    float phix = atan(v.y, v.x) * freq / pi;\n    float dl = sq_wave(phix, depth);\n    float m = step(amp, lv + dl);\n    return m;\n}   \n\nfloat cog_saw(vec2 v, float amp, float freq, float depth) {\n    float lv = length(v);\n    float phix = atan(v.y, v.x) * freq / pi;\n    float dl = saw_wave(phix, depth);\n    float m = step(amp, lv + dl);\n    return m;\n}   \n\nfloat cog_yes(vec2 v, float amp, float freq, float depth) {\n    float lv = length(v);\n    float phix = atan(v.y, v.x) * freq / pi;\n    float dl = yes(phix, 0.5, 3., depth);\n    float m = step(amp, lv + dl);\n    return m;\n}   \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n    uv.x *= iResolution.x /iResolution.y;\n\tvec3 col = vec3(1);;\n    float t = iTime;\n    float scale =  0.1 + 3. * nmouse().x + 0.5 * nsin(t / 32.);\n    uv /= scale;\n    vec2 mouse = 2. * iMouse.xy/iResolution.xy - 1.;\n    mouse.x *= iResolution.x /iResolution.y;\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    vec2 st = rotate(uv, t * 1.4142) + mouse;\n    float m;\n    \n    if (true) {\n        m = cog_saw(st, 0.4, 12., 0.21);\n        col = vec3(m);\n        st = uv + vec2(0.6, 0.5);\n        st = rotate(st, -t);    \n        m = cog_saw(st, 0.3, 7., 0.31);\n        col *= vec3(m);\n\n        st = uv + vec2(-0.6, -0.5);\n        st = rotate(st, -t / 2.);    \n        m = cog_saw(st, 0.2, 6., 0.11);\n        col *= vec3(m);\n\n\n        st = uv + vec2(-0.6, 0.5);\n        st = rotate(st, t / 4.);    \n        m = cog_sq(st, 0.3, 4., 0.41);\n        col *= vec3(m);\n\n\n        st = uv + vec2(0.6, -0.5);\n        st = rotate(st, t / 2.5);    \n        m = cog_sq(st, 0.4, 12., 0.36);\n        col *= vec3(m);\n    }\n    \n    st = abs(uv); // + vec2(0.9, 0.7);\n    st = rotate(st, t / 5.5);    \n    m = cog_yes(st, nafcos(0.5, 5., st.x), nafcos(0.7, 3., sin(iTime / 3.)), nafcos(0.2, 11., st.y));\n    col *= vec3(m);\n    \n    col *= 1. - vec3(length(uv), 0.2, minkl(uv, 2.));\n    float cdelta = mod(t / 4., 32.) / 32.;\n    col = changeHue(col, fract(hue(col) + cdelta)); \n    \n    \n    \n    \n    \n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}