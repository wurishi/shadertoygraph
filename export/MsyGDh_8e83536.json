{"ver":"0.1","info":{"id":"MsyGDh","date":"1454219020","viewed":3346,"name":"fishing village v2","username":"ejang","description":" I used this image as a reference: http://pre03.deviantart.net/35e5/th/pre/f/2016/003/6/e/fishing_village_by_artofchirag-d9mknu3\nThis is the same as my previous shader https://www.shadertoy.com/view/4dVGzD, but with some extra features and optimizations.","likes":57,"published":1,"flags":0,"usePreview":1,"tags":["procedural","raymarching","terrain","settlement"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Eric Jang (c) 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define clamp01(a) clamp(a,0.0,1.0)\n#define opS(d1,d2) max(-d1,d2)\n// union 2 objects carrying material info\n#define opU(a,b) ((a.x < b.x) ? a : b) \n\n#define PI 3.14159\n#define BOAT_SPEED .4\n//#define disable_village 1\n\n// rendering docks is slow. Think of better way to do this.\n//#define DOCKS 1\n\n#define WOOD_MAT 0.\n#define STRAW_MAT 1.\n#define VILLAGE_MAT 2.\n#define DOCKS_MAT 3.\n#define DUDE_MAT 4.\n#define FISH_MAT 5.\n\n#define ID_NONE -1\n#define ID_SKY 0\n#define ID_WATER 1\n#define ID_MOUNTAIN 2\n#define ID_VILLAGE 3\n\nvec3 sun_dir=normalize(vec3(0.18,0.1,1.));\n\nfloat boat_dx;\n#define START_POS vec3(7.,0.,7.6)\n\n// hash maps sequences to random-ish values\nfloat hash(float u)\n{\n    float f=u*13.1;\n    return fract(sin(f)*134735.3);\n}\n\nfloat Hash2d(vec2 uv) { return fract(sin(uv.x + uv.y * 37.0)*104003.9); }\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(84.54531253,42.145259123,23.349041223));}\n\nvec3 rX(const in vec3 v, const in float cs, const in float sn) {return mat3(1.0,0.0,0.0,0.0,cs,sn,0.0,-sn,cs)*v;}\nvec3 rY(const in vec3 v, const in float cs, const in float sn) {return mat3(cs,0.0,-sn,0.0,1.0,0.0,sn,0.0,cs)*v;}\nvec3 rZ(const in vec3 v, const in float cs, const in float sn) {return mat3(cs,sn,0.0,-sn,cs,0.0,0.0,0.0,1.0)*v;}\n\n// modeling functions\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )// h = radius, height\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dPlane(in vec3 ro, in vec3 rd)\n{\n    vec3 p0=vec3(0.);\n    vec3 n=vec3(0.,1.,0.);\n    return dot(p0-ro,n)/dot(rd,n);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    // 4 slightly different shifted versions\n    // of the same set of blocky tiles.\n    // we blend them together in x,y directions via\n    // 3 mix operations\n    // a=mix h00, h10 across x axis, \n    // b=mix h10, h11 across x axis\n    // c=mix a,b across y axis\n    // to get smooth clouds texture.\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + vec2(1,0));\n    float h01 = Hash2d(fl + vec2(0,1));\n    float h11 = Hash2d(fl + vec2(1,1));\n    return mix(mix(h00, h10, fr.x), mix(h01, h11, fr.x), fr.y);\n}\n\nfloat clouds(in vec3 rd)\n{\n    vec2 p=rd.xz/rd.y; // rd.xz/rd.y scales down farther in horizon \n \tfloat n = noise2d(p*1.0); \n    n += noise2d(p*2.0)*0.5;\n    n += noise2d(p*4.0)*0.25;\n    n += noise2d(p*8.0)*0.125;\n    \n\t// n = mix(n * 0.4, n, clamp01(abs(rd.y*3.)));  // fade clouds in distance    \n    n = mix(n,0.4*n, clamp01(abs(rd.y*3.2)));  // clouds thicker farther away (personal pref)\n    return n;\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c ) // c=vec3(bottom radius, angle , height)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdHouse(vec3 p, vec3 i, vec3 o, float h1, float h2) \n{ \n    // implemented as the intersection of an inner\n    // udroundbox and outer udroundbox rotated 45 degrees\n    // i and o are the xyz scales, respectively.\n    // o is shifted down h units prior\n    return max(udRoundBox(p-vec3(0.,-h1,0.),i,.01),\n               udRoundBox(rZ(p-vec3(0.,-h2,0.),0.707106,0.707106),o,.01));\n}\n\nvec2 sdvillage(in vec3 p, float seed)\n{\n    vec3 R,q,q2; float d;\n    vec3 scale=vec3(.5,1.,1.);\n    \n    vec2 dm=vec2(1000.,ID_NONE);\n    for (float i=0.; i<4.; i+=1.) {\n        R=hash3(seed+i)-.5; // dx, dy, ry\n        q=p-vec3(i*3.2-R.x,R.y,-R.x);\n        // rotate\n        q=rY(q,cos(R.z),sin(R.z));\n        \n        d=sdHouse(q, vec3(1.,1.,1.), vec3(2.), -.6, 1.);\n        dm=opU(dm,vec2(d,VILLAGE_MAT));\n        \n        q.y-=1.1;\n        float roof=opS(sdTriPrism((q-vec3(0.,-.1,0.))*scale,vec2(.8,1.4)),\n                       sdTriPrism(q*scale,vec2(.8,1.3)));\n        dm=opU(dm,vec2(roof,DOCKS_MAT));\n        \n        // second story\n        if (hash(seed+i)>0.3) {\n            q2=q-vec3(0.,1.,0.);\n            d=sdHouse(q2, vec3(1.,2.,1.), vec3(2.), -.6, 1.);\n            dm=opU(dm,vec2(d,VILLAGE_MAT));\n            q2.y-=1.1;\n            float roof=opS(sdTriPrism((q2-vec3(0.,-.1,0.))*scale,vec2(.8,1.4)),\n                           sdTriPrism(q2*scale,vec2(.8,1.3)));\n            dm=opU(dm,vec2(roof,DOCKS_MAT));\n        }    \n    }\n    \n    return dm;\n}\n\n// signed distance function for village\nfloat sdBoardWalk(in vec3 p, in vec2 s)\n{\n    // s = width, half length\n    float d= udRoundBox(p,vec3(s.x,0.03,s.y/2.),0.03);\n    float rx, dx, dz;\n    float l; vec3 q;\n    float k=0.;\n    for (float i=-2.; i<2.; i+=1.)\n    {\n        dz=i*s.y/4.+s.y/8.;\n        for (float j=0.; j<2.; j+=1.)\n        {\n            if (hash(k)>.05)\n            {\n               dx=(2.*j-1.)*s.x+.04;\n                q=p-vec3(dx,0.,dz);\n                rx=(Hash2d(vec2(i,j))-.5)*.4;\n                q=rX(q,cos(rx),sin(rx));\n                d=min(d,sdCappedCylinder(q,vec2(.01,.7)));\n            }\n        }\n        k+=1.;\n    }\n    return d;\n}\n\n\nvec2 sddocks(in vec3 p)\n{   \n    vec2 s=vec2(.5,2.); // .5 wide, 4. long\n    float d=10000.;\n    float t, ry;\n    float i=2.;\n\n    \n#if 0\n        t=hash(i);\n        ry=(t-.5)*.8;\n        d=min(d,sdBoardWalk(rY(p-vec3(0.,0.,i*1.5),cos(ry),sin(ry)),vec2(.5,1.7+.1*t)));\n#endif\n\treturn vec2(d,DOCKS_MAT);\n}\n\nvec2 sdboat(in vec3 p) // sanpan-style boat.\n{\n    // wood stuff\n    // hull\n    vec3 q=rZ(p,cos(.03),sin(.03));\n    float d=sdTriPrism((q-vec3(0.,-1.2,0.))*vec3(1.,-1.,1.),vec2(3.,.5)); // size, z-thickness\n    \n    vec2 offset=vec2(0.2,14.6);\n    float cylinder= length(q.xy-offset)-14.5;\n    d=opS(cylinder,d);\n    \n    float inner=udRoundBox(q-vec3(0.,0.3,0.),vec3(2.4,.2,.4),.03);\n    d=opS(inner,d);\n    \n    // dude\n   q=p-vec3(1.8,0.,0.2);\n   float d2=sdSphere(q-vec3(0.,1.04,0.),.15); \n   \n   float torso=sdEllipsoid( q-vec3(0.11,0.62,0.),vec3(.07,.2,.14) );\n   torso=smin(torso,sdEllipsoid(q-vec3(0.05,0.45,0.),vec3(.09,.1,.15)),.12);\n   d2=smin(d2,torso,.1);\n   float legs=sdEllipsoid(q-vec3(0.11,0.14,.08), vec3(.03,.1,.03));\n    legs=min(sdEllipsoid(q-vec3(0.11,0.14,-.08), vec3(.03,.1,.03)),legs);    \n   d2=smin(legs,d2,.1);\n\n    // pole\n#if 1\n   float pole=sdCappedCylinder(rZ(q-vec3(1.2,0.,0.16),cos(-1.),sin(-1.)),vec2(.02,2.4));\n\td=min(d,pole);\n#endif\n    \n    // straw stuff\n    // roof\n   vec3 q1=p-vec3(-0.5,0.,0.);\n   \n   float roof=opS(\n   \tsdCappedCylinder(q1.yxz,vec2(.48,.9)),\n   \tsdCappedCylinder(q1.yxz,vec2(.5,.8 ))\n   );\n   q1.x-=0.6;\t\n   q1=rZ(q1,cos(.05),sin(.05));\n   //float roof1=opS(sdCappedCylinder(q1.yxz,vec2(.51,.6)),\n   //                sdCappedCylinder(q1.yxz, vec2(.54,.5)));\n   float roof1=sdCappedCylinder(q1.yxz, vec2(.54,.5));\n   roof1=opS(udRoundBox(q1-vec3(0.,-.85,0.),vec3(1.),0.01),roof1);\n   roof=min(roof,roof1);\n    \n   // hat\n   vec3 q2=rX(q-vec3(0.,1.25,0.), cos(.1), sin(.1));\n   float hat=sdCappedCone(q2,vec3(.2,.4,.18));\n    \n\n   vec2 dude=vec2(d2,DUDE_MAT);\n   vec2 wood=vec2(d,WOOD_MAT);\n   vec2 straw=vec2(min(hat,roof),STRAW_MAT);\n   vec2 tm=opU(dude,opU(wood,straw));\n    \n#if 1\n   // fish (q3 is fish coordinates)\n   float fs=1000.; float f; vec3 q3;\n   for (float i=0.; i<3.; i+=1.) {\n   \tq3=p-vec3(-1.6,0.15,-.2+i*.25);\n    f=sdEllipsoid(q3,vec3(.3,.05,.15));\n   \tfs=min(f,fs);\n   }\n   \n    vec2 fish=vec2(fs,FISH_MAT);    \n    tm=opU(fish,tm);\n#endif\n    \n    return tm;\n   \t\n    \n}\n\nvec2 scene(in vec3 p)\n{    \n#ifdef disable_village\n    return vec2(10000.,ID_NONE);\n#endif\n    // houses\n\tvec2 v1= sdvillage(rY(p-vec3(-2.,1.,20.),cos(-2.),sin(-2.)),0.);\n    vec2 v2= sdvillage(rY(p-vec3(16.,.5,25.),cos(2.),sin(2.)),221.);\n    vec2 tm=opU(v1,v2);\n    \n#ifdef DOCKS\n    // docks\n    float ry=1.2;\n    vec3 q1=rY(p-vec3(-1.4,0.3,7.),cos(ry),sin(ry));\n  \tvec2 docks=sddocks(q1);\n    tm=opU(docks,tm); \n#endif\n    \n    // boat\n    vec3 q2=rY(p-START_POS,cos(.3),sin(.3))-vec3(boat_dx,0.,0.); // boat coordinates\n\tvec2 boat= sdboat(q2);\n    \n    return opU(tm,boat);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    vec3 e = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scene(p+e.xyy).x - scene(p-e.xyy).x,\n        scene(p+e.yxy).x - scene(p-e.yxy).x,\n        scene(p+e.yyx).x - scene(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec3 background(in vec3 rd)\n{\n        vec3 col;\n    \n    // skycol fades into horizoncol closer to horizon\n    vec3 skyCol = vec3( 0.49, 0.352, 0.294);\n    vec3 horizonCol = vec3(0.866667, 0.47451, 0.270588);\n    col=skyCol;\n    col=mix(horizonCol,skyCol,clamp01(rd.y)*7.);\n    \n    // sunlight\n    float sunlight=clamp01(pow(dot(rd,sun_dir),4.));\n    \n    // add sun\n    //float sundot = smoothstep(.996,.999,sunlight);\n    float sundot=1.-smoothstep(0.03,0.06,length(rd-sun_dir));\n    col+=sundot*vec3(1.0,0.913725,0.458824);\n    \n    // clouds\n    vec3 cloudcol=vec3( 0.623529,  0.298039,  0.164706)*1.5;\n\n    //return cloudcol*sunlight;\n    //col=vec3(clouds(rd));\n    //col=mix(col,cloudcol*sunlight,clouds(rd));\n    col=mix(col,cloudcol,clouds(rd));\n    return clamp01(col);  \n    \n #if 0\n    \n    vec3 col=vec3( 0.49, 0.352, 0.294); // sky color\n    // add sun\n    float sundot=1.-smoothstep(0.03,0.06,length(rd-sun_dir));\n    col+=sundot*vec3(1.0,0.913725,0.458824);\n   \n    // clouds\n    \n    vec3 cloudcol=vec3(0.772549, 0.388235, 0.211765);\n    col=mix(col,cloudcol*sunlight,clouds(rd));\n    \n    return col;\n#endif\n}\n\n// FBM loop is inlined via macro\n#define F (texture(iChannel0,p*s/1e3)/(s+=s)).x\nfloat fbm(in vec2 p, in float s) { return F+F+F; }\n\nvec3 cheapFog(in vec3 ro, in vec3 rd, in vec3 bgc, in vec3 p)\n{\n  float xscale=sqrt(clamp01(.8-abs(rd.x-.2))); // denser in valley\n  float yscale=clamp01(1.-p.y*.02); // denser closer to ground\n  float zscale=clamp01(sqrt(p.z*.01));// gets denser as we go farther out\n  float n=clamp01(fbm(p.xy+iTime*4.,.1));\n  float fog=xscale*yscale*zscale*n;\n  //return vec3(fog);\n  // lighting\n  float sunlight=clamp01(pow(dot(rd,sun_dir),4.));\n  vec3 fogc=mix(vec3(1.),vec3(0.843137,0.461373,0.247059),sunlight);\n  // TODO - fog has to get lighting from sun.\n  return mix(bgc,fogc,fog);\n  //return mix(bgc,,fog);\n}\n\nfloat watermap( in vec2 p ) { // -.04,.2 controls water flow in XZ plane\n\treturn fbm((p-iTime*vec2(-.04,.2))*10.,.5);\n}\n\nvec3 shade(vec3 p, float m)\n{\n    vec3 n=calcNormal(p);\n   \tvec3 sun_dir=normalize(vec3(-0.28,3.,1.));\n    vec3 col;\n    vec3 q2=rY(p-START_POS,cos(.3),sin(.3))-vec3(boat_dx,0.,0.); // boat coordinates\n\tif (m==WOOD_MAT) {\n        col=vec3(0.152941,0.0627451,0.0392157);\n    }\n    else if (m==DOCKS_MAT) {\n        vec3 wood1=vec3(0.36, 0.275, 0.1625);\n        vec3 wood2=vec3(0.152941,0.0627451,0.0392157);\n        col=mix(wood1,wood2,Hash2d(floor(p.xz*vec2(4.,1.))));   \n    }\n    else if (m==STRAW_MAT) {\n        \n        vec4 t=texture(iChannel1,q2.xz/2.);\n        col=t.xyz;\n    } else if (m==DUDE_MAT) {\n        vec3 fleshcol=vec3(0.909804,  0.713725,  0.541176);\n        vec3 pantscol=vec3(0.266667,  0.376471,  0.509804);\n        col=mix(pantscol,fleshcol,smoothstep(.4,.45,q2.y));\n    } else if (m==VILLAGE_MAT) {\n        col=vec3(0.152941,0.0627451,0.0392157)*.1;\n        // add windows\n        vec3 wcol1=vec3(0.972549, 0.294118, 0.137255);\n        vec3 wcol2=vec3( 1.0,0.709804,0.415686);\n        \n        vec4 t=texture(iChannel1,.2+p.xy*vec2(.15,.05));\n        //return vec3(1.-t.x*t.y);\n        float w1=smoothstep(0.7,.8,1.-t.x); // cooler orange glow\n        float w2=smoothstep(0.8,0.9,1.-t.x); // hotter yellow light\n        //return vec3(w2);\n        // skip phong lighting and go straight to color\n        return mix(col,mix(wcol1,wcol2,w2*w1),pow(w1,.2));\n    } else if (m==FISH_MAT) {\n        float shine=pow(smoothstep(.8,.99,dot(n,vec3(0.,.98,.2))),6.);\n        col=mix(vec3( 0.459, 0.482, 0.514),vec3( 0.870588, 0.819608, 0.760784),shine);\n        //col=vec3(pow(smooths(dot(n,vec3(0.,1.,0.))),4.));\n    }\n    \n    col*=1.1*clamp01( dot( n, sun_dir ) ); // phong lighting   \n    return col;\n}\n\n// render subcall (for water refl). returns object id and color.\n// this does shading calculations.\nint trace(in vec3 ro, in vec3 rd, out vec3 col, out vec3 p)\n{\n    int obj=ID_SKY;   \n    col=background(rd); // default color = sky\n    \n    // mountains\n    // exponential jump + binary search refinement\n    float h; float h2;\n\tfloat t=0.;\n    float jump;\n    for (int i=0; i<100; i++) {\n        jump=0.05*t+0.1;\n        t+=jump;\n        p=ro+t*rd;\n        \n        // foreground mountains\n        float vwidth=0.7;// valley width\n        float xscale=abs(rd.x-.2)*2.; // valley centered around sun\n\t\tfloat zscale=abs(p.z)/15.; // river gets wider closer to camera        \n        h=fbm(p.xz*3.,.3)*xscale*zscale-.25;\n        \n        // background mountains\n        float zscale2=p.z/20.-.7; // only show up in background\n        vec4 tex=texture(iChannel2,p.xz/140.);\n        h2=((tex.x-.4)*zscale2*max(xscale+.15,0.)-.2)*30.;\n        \n        // binary search refinement\n        if (p.y <h || p.y<h2) {\n            for (int j=0; j<5; j++) {\n                float dir=(p.y<h || p.y<h2) ? -1. : 1.;\n                jump*=.5;\n                t+=dir*jump;\n                p=ro+t*rd;\n            }\n        }\n        \n        if (p.y<h) {\n            col=vec3(0.180392, 0.0745098, 0.031372)*2.*(1.-sqrt(h));\n            obj=ID_MOUNTAIN;\n           break;\n        } else if (p.y < h2) {\n            col=mix(vec3(0.180392, 0.0745098, 0.031372)*.5,vec3(0.72549,  0.392157,  0.231373)*.8,t/300.);\n            obj=ID_MOUNTAIN;\n            break;\n        } else if (p.y<0.){\n            obj=ID_NONE;\n        }\n    }\n    \n    // trace village\n    t=0.1;\n    vec2 dm;\n    vec3 p2;\n    for (int i=0; i<40; i++)\n    {\n        p2=ro+rd*t;\n        dm=scene(p2);\n        if (dm.x<0.01 || t>500.) break;\n        t+=dm.x;\n    }\n   \tif (t<1000. && t<length(p-ro))\n    {\n        p=p2;\n        col=shade(p2,dm.y);\n    \tobj=ID_VILLAGE;\n    }\n    // is water\n    if (p.y<0. && p2.y<0.){\n        obj=ID_NONE;\n    }\n    \n\treturn obj;\n}\n\n#define BUMP 0.1\n// dx,dz control turbulence of normal displacement for reflection\n#define dx vec2(.1,0.)\n#define dz vec2(0.,.1)\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 p; float d;\n    vec3 col=vec3(0.);\n    \n  \t// intersect foreground\n    int obj=trace(ro,rd,col,p);\n    vec3 p2;\n\n    if (obj==ID_NONE) { // we must have hit water == ID_NONE   \n        d=dPlane(ro,rd);\n        float fresnel;// bool refl;\n        p=ro+d*rd;\n        vec3 n=normalize(vec3(\n            -BUMP*(watermap(p.xz+dx)-watermap(p.xz-dx))/(2.*BUMP), // central difference approximation of normal\n            1.,\n            -BUMP*(watermap(p.xz+dz)-watermap(p.xz-dz))/(2.*BUMP)\n        ));\n        fresnel = pow(1.0-abs(dot(n,rd)),5.);\n        rd = reflect( rd, n);\n        ro=p;\n        trace(ro,rd,col,p2);    \n        vec3 watercol=vec3( 0.439216  ,0.270588 , 0.203922);\n        col=mix(col,watercol,1.-fresnel);\n    }\n    \n    col=cheapFog(ro,rd,clamp01(col),p);\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    boat_dx=-mod(iTime*BOAT_SPEED+5.8,25.);\n\n    // alternate animation - boat sailing down the river\n    //ry=-1.7+sin(iTime)*.01;\n    //vec3 q2=rY(p-vec3(3.,0.,1.4),cos(ry),sin(ry))-vec3(-mod(iTime*BOAT_SPEED+8.,50.),0.,0.);\n    vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y; // x=(-1.5,1.5), y=(1,1)\n    \n    vec3 ro=vec3(0.,1.5,0.); // eye location\n    vec3 ta=vec3(0.,3.,20.); // look location\n    vec3 up = vec3( 0.0, 1.0, 0.0 ); // up axis of world\n    float d = 2.5; // distance between eye and film plane\n    \n    // build ray\n    vec3 ww = normalize( ta - ro); // film plane normal\n    vec3 uu = normalize(cross( up, ww )); // horizontal axis of film plane\n    vec3 vv = normalize(cross(ww,uu)); // vertical axis of film plane\n    vec3 rd = normalize( p.x*uu + p.y*vv + d*ww );\n    \n    vec3 col=render(ro,rd);\n    \n    // vignette\n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= 0.5 + 0.5*pow(20.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.4);\n\n    fragColor=vec4(col,1.); \n}\n","name":"","description":"","type":"image"}]}