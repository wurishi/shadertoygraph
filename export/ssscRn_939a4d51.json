{"ver":"0.1","info":{"id":"ssscRn","date":"1641627709","viewed":247,"name":"Alphabet Crash","username":"kastorp","description":"boing!","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["collision","font","letter"],"hasliked":0,"parentid":"NtGSzc","parentname":"Letter crash"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Alphabet Crash by Kastorp\n//--------------------------------------------------------------------\n\nvec4 getHit(float k){ return  texelFetch(iChannel0,ivec2(k,2),0);}\n\nvec3 pal( in float t){\n     vec3 a=vec3(0.5,0.5,0.5),  b=vec3(0.5,0.5,0.5),   c=vec3(1.0,1.0,1.0),   d=vec3(0.0,0.33,0.67) ;\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 uv =  (1.0 - U.yx / R.yx) *U.xy / R.xy;      \n    float vig = pow(uv.x*uv.y * 10.0, 0.15); \n    O =vig* vec4(vig,.7,.5,0);\n    \n    U=(U-R*.5)/R.y*2.5;    \n   for(int i=0;i<NL;i++){\n    vec3 t= getLetter(iChannel0,iChannel2, U,i);\n    vec3 col=  pal(float(i)/float(NL));\n    O = mix(O, -vec4(col,0)*t.x*60., smoothstep(.003,-0.003,t.x));\n   }\n    \n    \n} ","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec4 getPos(int id){ return  texelFetch(iChannel0,ivec2(id,0),0);}\nvec4 getVel(int id){ return  texelFetch(iChannel0,ivec2(id,1),0);}\nvec4 getHit(float k) { return  texelFetch(iChannel0,ivec2(k,2),0);}\n\n\nvec4 getCollision(int ch1,int ch2, vec4 l1, vec4 l2,  vec2 cm)\n{\n    bool hit=false;       \n    vec3 t1d,t2d;      \n    for(int i=0;i<NIT;i++){     \n        t1d = letter2(iChannel2,cm,ch1,l1),\n        t2d = letter2(iChannel2,cm,ch2,l2);              \n        hit = max(t1d.x, t2d.x) <.002;\n        //cm += ( t1d.x*t1d.yz + t2d.x*t2d.yz)*.5;\n        cm += (max(t1d.x, t2d.x)<0. ?.1:1. )* ((t1d.x>t2d.x)  ? t1d.x*t1d.yz : t2d.x*t2d.yz);  //MATTZ algorithm\n    } \n    return vec4(cm,hit?normalize(-t1d.yz+t2d.yz):vec2(0));   \n}\n\nfloat cross2(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\nvec2 cross2(vec2 a, float b) {\n    return vec2(a.y * b, a.x * -b);\n}\nvec2 cross2(float a, vec2 b) {\n    return vec2(b.y * -a, b.x * a);\n}\n\n//based on https://www.shadertoy.com/view/NtlGz7 by TDM\nvoid solveCollision(vec4 l1,vec4 l2,vec4 v1, vec4 v2, vec4 c , inout vec3 dPos, inout vec3 dVel){\n      \n   \n#if 0   \n    //no rotation   \n    vec2 n= c.zw;\n    vec4 rv=v2-v1,rp=l2-l1;\n    float pen=min(dot(rv.xy,n),0.);\n    dPos+= vec3(pen*n*2.,0);\n    dVel+= vec3(dot(rv.xy,n) <0.? dot(rv.xy,n)*n*.8:vec2(0),0.);\n#else\n    \n    //TODO:\n    // apply real mass, inertia and barycenter from here https://www.shadertoy.com/view/flySzm\n\n    vec2 n= - c.zw;\n    \n    // inverse of mass and inertia\n    float IM1=1.,IM2=IM1,\n          II1=15.,II2=II1;           \n          \n    vec2 arm1=c.xy-l1.xy,\n         arm2=c.xy-l2.xy;\n    \n    vec2 cv1=v1.xy + cross2(v1.z,arm1),\n         cv2=v2.xy + cross2(v2.z,arm2),\n         rv=cv1-cv2;\n    \n    float w1 = cross2(arm1,n),\n          w2 = cross2(arm2,n);\n          \n    float a =(1.0 + ELASTICITY) * dot(n,rv);\n    float b = IM1 + IM2 +\n            w1 * w1 * II1 +\n            w2 * w2 * II2;\n    float lambda = max(-a / b, 0.0);\n    \n    dVel += vec3(n * (lambda * IM1), cross2(arm1, n) * lambda* II1);\n    \n    float pen =min(dot(rv.xy,n),-.002);\n    dPos -= vec3(pen*n,v1.w);\n#endif\n\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    \n    if(U.x>float(NL+1) || U.y>2.) discard;\n    int id =int(U.x-.5);\n    \n    \n    vec3 dPosT=vec3(0),dPosM=dPosT, dVelT=vec3(0);\n    \n    float dt=1.;\n    //collision routine \n    for(int id2=0;id2<NL;id2++){\n        if(id==id2) continue;\n\n        vec4 l1,l2;\n        int ch1=getLetterData(iChannel0,id,l1);\n        int ch2=getLetterData(iChannel0,id2,l2);\n        vec4 v1=getVel(id),\n             v2=getVel(id2);  \n \n        //predict future position:\n        l1+=vec4(v1.xy,0,v1.z)*dt;  l2+=vec4(v2.xy,0,v2.z)*dt;\n\n        vec3 dPos=vec3(0), dVel=vec3(0);\n        float hitt=0.;\n        \n        for(int k=0;k<NCP;k++) {           \n            float j= -2. + 4.*float(k)/float(NCP-1);\n            vec2 cm= (l1.xy*.1+l2.xy*.9) +  (l1.xy-l2.xy)*.5 *mat2(0,-j,j,0);\n            vec4 cl=getCollision( ch1, ch2,  l1,  l2,   cm);  \n            \n            if(length(cl.zw)>0.) {\n          \n                 solveCollision( l1,l2,v1,v2,  cl,  dPos, dVel);\n                 hitt++;\n                 \n            } \n        }  \n        \n        if(length(dPosM.xy)<length(dPos.xy))dPosM=dPos;\n        dPosT+= dPos/max(hitt,1.);\n        dVelT+=dVel/max(hitt,1.);  \n    }\n    \n        \n    if(U.y<1.){\n        //position\n        if((iFrame%FRAMES)==0){\n          float x =float(id)/float(NL);\n          vec2 p0=  vec2(2.- fract(x*3.)*4.,-1.+floor(x*3.));\n      \n          O= vec4(p0 ,25-id,0);\n        \n       } else{\n           O=   getPos(id);           \n           vec4 vel = getVel(id);\n           O.xy+=vel.xy*dt;\n           O.w+=vel.z*dt;            \n           \n            O.xyz+=(dPosT*(1.- REPOS) + dPosM*.5*REPOS);\n       }\n    }  else if(U.y<2.){  \n        //velocity\n        float a =6.28* float(id)/float(NL);\n        if((iFrame%FRAMES)==0) O*=0.;\n        else{\n            O=  getVel(id);\n            O.xy-=dt*normalize(getPos(id).xy)*.00004; //attraction\n            \n            //O.y=dt * (getPos(id).y<-1. && O.y<0.? .05:-.003);\n            O.xyz+=dVelT;                                                            \n        }\n        \n    }  \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NCP 40  //number of collision points\n#define NIT 15 //number of iterations for each collision point\n#define FRAMES 1000 //numbrer of frames for each reset\n#define ELASTICITY  0.75\n#define REPOS .05 //enforce distance \n#define NL 26\n\n#define R iResolution.xy\n#define ROT(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvec3 letter(sampler2D chn,vec2 p,int ch){\n    ch+=65;\n    if(max(abs(p.x),abs(p.y))>.5)  return vec3(length(p)-.3,-normalize(p));\n    vec2 cp = vec2(ivec2(ch%16, 15-ch/16));\n    vec4 d= textureLod(chn, (p+ cp + 0.5)/16., 0.) ;\n    vec2 grad=vec2(-1,1) *(d.yz-vec2(.5))*2.;\n    float dst=(d.w-.515);\n    //return vec3(length(p)-.3, -normalize(p)); //debug with circle\n    return vec3(dst,normalize(grad));\n}\nvec3 letter2(sampler2D chn, vec2 p,int ch,vec4 t){\n    p=(p-t.xy)/t.z*ROT(t.w);\n    vec3 d=letter(chn,p,ch);\n    return vec3(d.x*t.z,d.yz*ROT(-t.w));\n\n}\nint getLetterData(sampler2D chn, int id,out vec4 data){\n    data=  texelFetch(chn,ivec2(id,0),0);\n    int ch = int(data.z);\n    data.z=.7; \n    return ch;\n}\n\nvec3 getLetter(sampler2D chnData, sampler2D chnFont,vec2 p, int id){\n    vec4 data=  texelFetch(chnData,ivec2(id,0),0);\n    int ch = int(data.z);\n    data.z=.7;\n    return letter2(chnFont,p,ch,data);\n}","name":"Common","description":"","type":"common"}]}