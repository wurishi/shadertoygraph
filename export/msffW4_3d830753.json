{"ver":"0.1","info":{"id":"msffW4","date":"1728897349","viewed":23,"name":"Going 3D Adding Colour","username":"DynameshDude","description":"Learning how to go 3D","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"cdXBWN","parentname":"Going 3D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Function for colour\nvec3 palette (float t)\n{\n    //Variables that contain gradient colours (vec3)\n    vec3 a = vec3(0.058, 0.168, 0.448);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(1.448, 0.142, 0.278);\n    vec3 e = vec3(1.448, -3.142, 0.278);\n    \n    return a + b* +sin(8.28318*(c*t+d));\n }\n\n\n\n\n//Function that takes raycasting, the ray direction and a point and returns the distance between these vectors\nfloat Distance(vec3 raycast, vec3 raycastDirec, vec3 point)\n{\n    return length (cross(point - raycast, raycastDirec))/length (raycastDirec);\n}\n\n\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord )\n{\n\n\nvec3 finalColour =vec3(0.0);\n\n\n    //UVs are 0 to 1\n    vec2 uv = fragCoord/iResolution.xy;\n    \n        //Centring UV origin\n        uv -= 0.5;\n        //uv = fract(uv);\n        //uv -= 0.5;\n        \n        //Use the rotation matrix to rotate UVs\n        //float rotation = 0.5;\n        //uv *= mat2(-tan(rotation), sin(rotation), 1.0, 0.5);\n\n        //Takes resolution change into account and retains shader ratio\n        uv.x *= iResolution.x/iResolution.y;\n\n        //Going 3D here//\n        //Make raycast a vector3 (Cam 3D VECTOR) \n        //Minus is the negative depth (before the screen)\n        vec3 raycast = vec3(0.0, 0.0, -1.5);\n        vec3 raycastDirec = vec3(uv.x, uv.y, 0.0) - raycast;\n\n        //Initialize t variable to animate point\n        float t = iTime;\n\n        //The ray need to hit something\n        //Location if the point is behind the screen\n        //Control the size of point at z(b) depth\n        vec3 point = vec3(0.0, 0.0, 0.1 + sin(t));\n\n        //Calculate the vector between the cam vector to any point in 3D\n        float distance = Distance(raycast, raycastDirec, point);\n        \n        //Assigns colour and offsets the gradient\n        vec3 Colour = palette(length(uv* distance)* 10.0 - iTime* 0.5);\n        \n        //Frequency of circles according to sign function\n        distance -= sin(distance * 100.0 + iTime)/2.0;\n        \n        distance = pow(0.1/distance, 0.5);\n        \n        \n        finalColour +=  distance* Colour;\n\n    \n    //Output to screen\n    //If the distance is close to the point, the colour will be darker\n    //If the distance is far from the point, the colour will be lighter\n    //Using smooth step to clamp the depth\n    distance = smoothstep(0.01, 0.8, distance);\n    \n    fragColor = vec4(distance *finalColour, 1.0);\n}","name":"Image","description":"","type":"image"}]}