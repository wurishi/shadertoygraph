{"ver":"0.1","info":{"id":"ltBcDy","date":"1510000303","viewed":324,"name":"MCMC: Metropolis-Hastings","username":"tale3d","description":"Image morphing with Markov Chain Monte Carlo. \nPart 2: Metropolis-Hastings ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["stochastic","mcmc","teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//everything happens in Buffer A, here we just render a texture that is created in there\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 tex = texture(iChannel0, uv);\n    //as we store \"optimal\" intensity in y channel, render just y channel\n    fragColor = vec4(tex.y);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Metropolis-Hastings example\n\n//noise functions in this example are taken from here:\n//https://www.shadertoy.com/view/4ssXRX\n\n//pseudo-random number generator, taken from https://www.shadertoy.com/view/4djSRW \n#define HASHSCALE1 443.8975\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//uniform sampling\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n//gaussian-like sampling, mean 0 and variance 1\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\n\n//function for gaussian, m is mean, deviation is 1 \nfloat gaussian(float x, float m) {\n    return 0.3989*exp(-(x-m)*(x-m)*0.5);\n}\n\n//target function/distribution that we are sampling from.\n//here we use a very simple one: difference between the colour in the target texture and the current colour\nfloat target(float x, vec2 uv)\n{\n    //reading from the target texture\n    vec4 targetcolor = texture(iChannel2, uv);\n\n    float targetintensity = targetcolor.x*0.3 + targetcolor.y*0.59 + targetcolor.z*0.11;\n    return 1.0/((x-targetintensity)*(x-targetintensity)+0.01);\n}\n\n//in the texture for each pixel we store current sample in x(r) channel,\n// the best sample with respect to the target function is in y(g) channel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n \n    //reading current sample from the texture\n    float xn = color.x;\n\n    //sampling random values - thanks Renats for this quick hack \n    float a = hash11(uv.x*iTime)+xn;\n    float b = hash11(uv.y*iTime)+xn;\n    //metropolis-hastings goes here\n    float xstar = n4rand(vec2(a,b));\n    \n    float r = target(xstar,uv)*gaussian(xn, xstar)/(target(xn,uv)*gaussian(xstar, xn));\n    float alpha = min(1.0, r);\n    float u = nrand(uv*iTime);\n    if (u < alpha) xn = xstar;\n    \n    //read optimal sample from the texture\n    float optimal = color.y;\n    //compare optimal with the current one\n    if (target(optimal, uv) < target(xn, uv))\n        optimal = xn;\n    \n    //save current and optimal back to the texture\n    fragColor = vec4(xn, optimal, 0, 0);\n    //for the first second, display (and store to channel0) texture from channel 1\n    if (iTime < 1.0) \n    {\n        vec4 color = texture(iChannel1, fragCoord.xy / iResolution.xy);\n\n\t\tfloat intensity = color.x*0.3 + color.y*0.59 + color.z*0.11;\n        fragColor = vec4(intensity);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}