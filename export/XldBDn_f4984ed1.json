{"ver":"0.1","info":{"id":"XldBDn","date":"1539208942","viewed":342,"name":"raymarch with sfx","username":"vadevaman","description":"Some bugs appear by distance, much learning to do. What are the main differences in raytracing and raymarching? Raymarching is an aproach mostly used on terrain rendering, so its quite amazing that it can do this also!","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["raymarch","spheres","quads"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4tXGzr","filepath":"https://soundcloud.com/because/metronomy-the-look","previewfilepath":"https://soundcloud.com/because/metronomy-the-look","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//gFlex Engine - v.0.2017-08\n//Copyright (c) 2009 - Ravel Tammeleht\n//{print os}{print date}\n//Using Renderer:{print renderer}\n\n// Default cliping colors\n#define backgroundColor vec3(0.32,0.42,0.65)\n#define defaultColor vec3(1,0.25,0.21)\t\n\n// Lighting Parameters\n#define defaultLightColor vec3(1.,.9,.8)\n#define ambientColor vec3(.05,.1,.15)\n#define lightPosition vec3(5,2,5)\n\n// Common Variables\n#define PI 3.14\n#define right vec3(1,0,0)\n#define up vec3(0,1,0)\n#define forwad vec3(0,0,1)\n#define normalBiasFactor 0.01\n\n// Scene variables\n#define camRotationSpeed 0.10\n#define defaultGamma 2.2\n//#define DEBUGNORMAL\n#define MUSICLIT\n#define FASTVERSION\nint sphCount;\n// Signed Distance Field\n// outputs a \"signed distance field\" (SDF), with negative values for points inside the sphere and positive for outside points.\n\nfloat Sphere(vec3 centre, float radius, vec3 point)\n{\n    return length(centre-point)-radius;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nfloat quad(in vec3 p)\n{    \n    float thickness = 0.001;\n    vec3 triPos = vec3(0.0,1.0,0.0);\n    vec4 size = vec4(-2,2,0.0,0.5);\n\tvec3 v1 = vec3(size.x,size.z,0.0); // bottom left\n\tvec3 v2 = vec3(size.y,size.z,0.0); // bottom right\n\tvec3 v3 = vec3(size.x,size.w,0.0); // top left\n\tvec3 v4 = vec3(size.y,size.w,0.0); // top right\n\tfloat t0 = udTriangle( v1, v2, v3, triPos+p ) - thickness; // botom left to botom right to top left\n\tfloat t1 = udTriangle( v3, v2, v4, triPos+p ) - thickness; // top left to \n    float q = min( t0, t1 ); // resulting tri quad\n    return q;\n}\n\nfloat mesh(in vec3 p)\n{  \n    // Temporary mesh test\n    // 10 quads + 20 tri's\n    // quad\n    float d = 1.0;\n    for(int i=0; i < 10; i++)\n    {      \n        d = min(d,quad(p+vec3(0,0,i)));\n    }  \n    return d;\n}\n\nfloat map( in vec3 p)\n{\n    // triangle\t\n    /*\n    float modFactor = 0.0;//iTime;\n\tvec3 v1 = 1.0*cos( modFactor + vec3(0.0,1.0,1.0) + 0.0 );\n\tvec3 v2 = 1.0*cos( modFactor + vec3(0.0,2.0,3.0) + 2.0 );\n\tvec3 v3 = 1.0*cos( modFactor + vec3(0.0,3.0,5.0) + 4.0 );\n\tfloat d1 = udTriangle( v1, v2, v3, p ) - 0.01;\n    */\n    float d1 = mesh(p);\n    // ground plane\n\tfloat gp = p.y + 1.0;\n\n    return min( d1, gp );\n}\nvec3 musixLit = vec3(0.0);\n// here are all the intersections\n// our goal is to transfer vert data in this method. Also it might be wise to store UV coords in this method aswell? Y/N\nfloat Scene(vec3 pos)\n{\n    float f=1.0;// declare our entrance \n    \n    \n    // Intersect with objects\n    float sphRadius = 0.25;\n    int gridWidthStep = 10;\n    int gridHeightStep = 10;\n    #ifdef FASTVERSION\n    gridWidthStep = 5;\n    gridHeightStep = 4;\n    #endif\n    vec3 gridPosition = vec3(0,0,5);\n    // lets add some sound effects, for some reason my browser lags like hell, \n    // and it requests to open a webcam, anyoen knows whatsup with that?\n    vec4 s = vec4(texture(iChannel1,vec2(0.0,0.0)).r,\n                  texture(iChannel1,vec2(0.216,0.0)).r,\n                  texture(iChannel1,vec2(0.332,0.0)).r,\n                  texture(iChannel1,vec2(0.351,0.0)).r);\n            vec2 p = vec2(0.0,0.0);\n    p += vec2(s.x - s.w, s.z - s.y);\n    \n    //float anim = cos(iTime*0.5);\n    float anim = p.x*0.1423; // px life bro\n    musixLit = s.rgb * 1.2;\n    // loops can get messy really quickly, I am aware, improwements are welcome.\n    for(int i=0; i < gridWidthStep; i++)\n    {\n        for(int j=0; j < gridHeightStep; j++)\n        {\n                             \n    \t\tf = min(f,Sphere(gridPosition + vec3(i-(gridWidthStep/2),gridPosition.y+anim,j-(gridHeightStep/2)),sphRadius,pos));\n            sphCount ++; // keep track of how many spheres we have in scene.\n        }\n    }\n    /*\n    f = min(f,Sphere(vec3(1,-1,0),1.,pos));\n    f = min(f,Sphere(vec3(0,1,0),1.,pos));\n    // lets add some more, for sake of experience\n    f = min(f,Sphere(vec3(-1,-1,-1),0.3,pos));\n    f = min(f,Sphere(vec3(0,1,-1),0.3,pos));\n   */\n    // Intersect with map/scene/triangles\n    f = min(f,map(pos));\n    return f;\n}\n\n// Kuna me töötame nüüd 3D ruumis, siis me lsiame pöörlemise.\nvoid Rotate(inout vec3 vector, vec2 angle)\n{\n    vector.yz = cos(angle.y)*vector.yz\n        +sin(angle.y)*vec2(-1,1)*vector.zy;\n    vector.xz = cos(angle.x)*vector.xz\n        +sin(angle.x)*vec2(-1.,1.)*vector.zx;\n}\n\n// Part 1 Basics of Drawing Circles\nvoid _mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 0\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    // 1 (requires uv's from step 0!)\n    //fragColor = vec4(Sphere(vec3(0),0.5, vec3(uv,0)));\n    \n    // 2\n    // Let's center the sphere at the center of the screen. Change the uv to:\n    vec2 uv = 8.*(fragCoord-iResolution.xy*.5)/iResolution.x;\n    //float sdf = Sphere(vec3(0),0.5, vec3(uv,0));\n    // 3.\n    float sdf = Scene(vec3(uv,0));\n    fragColor = vec4(step(.0,sdf));\n}\n\nfloat ShadowMarch( vec3 pos, vec3 light )\n{\n    vec3 ray = normalize(light-pos);\n    float e = length(light-pos);\n    float t = .02; // step away from the surface\n    for ( int i=0; i < 200; i++ )\n    {\n        float h = Scene(pos+ray*t);\n        if ( h < .001 )\n        {\n            return 0.; // hit something\n        }\n        if ( t >= e )\n        {\n            break;\n        }\n        t += h;\n    }\n    return 1.; // didn't hit anything\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\n// Our custom lighting function\nvoid AddLighting(vec3 pos, out vec4 fragColor,out vec3 normalDir)\n{     \n    // Nüüd kus meil on kujuteldavad 3d objektid olemas, lisame valgustuse.\n    vec3 shade = fragColor.rgb;\n    float t = Scene(pos);\n    if(Scene(pos) < normalBiasFactor)// did the ray hit anything?\n    {\n        vec3 normal;\n        normal.x = Scene(pos + normalBiasFactor * right) - Scene(pos- normalBiasFactor * right);\n        normal.y = Scene(pos + normalBiasFactor * up) - Scene(pos- normalBiasFactor * up);\n        normal.z = Scene(pos + normalBiasFactor * forwad) - Scene(pos- normalBiasFactor * forwad);\n        normal = normalize(normal);\n        normalDir = .5 + .5 * normal; // test the value; This also outputs the normal value for furhther use with reflections etc.\n        \n        vec3 lightSource = lightPosition; // position of the light\n        vec3 lightDir = lightSource-pos; // convert to local space\n        \n        float light = 0.0; // Our light pixel        \n        vec3 ambient = ambientColor;\n        vec3 lightCol = defaultLightColor;\n        #ifdef MUSICLIT\n        //music tint\n        vec3 musicColors = vec3(musixLit.x,musixLit.y,musixLit.z);\n        lightCol = musicColors;\n        ambient = 0.5-musicColors*0.8;\n        #endif\n        float ndotl = max(.0,dot(normal,normalize(lightDir))); \n        light = ndotl;\n        \n        // now add shadows\n\t\tfloat sha = calcSoftshadow( pos + normal*0.01, lightDir, 100.0 );\n\t\tfloat occ = calcOcclusion( pos, normal );\n        \n        light *= ShadowMarch( pos, lightSource );\n        \n        // sum up the lighting pass\n        shade.rgb = light * lightCol + ambient;\n        \n        \n\t\t//shade =  vec3(0.9,0.6,0.3)*clamp( ndotl, 0.0, 1.0 ) * sha;\n\t\tshade += vec3(0.5,0.6,0.7)*clamp( normal.y, 0.0, 1.0 )*occ;\n\t\tshade += ambient;\n    }  \n    \n    shade *= exp( -0.2*t );\n    shade *= 1.0 - smoothstep( 5.0, 10.0, t );\n\tshade = pow( clamp(shade,0.0,1.0), vec3(0.45) ); \n    \n    fragColor = vec4(shade,1); \n}\n\n// Part 2 Raymarching\n// Kujuta ette, et sinu monitori ekraan on aken 3D maailma. Me uurime välja, millised pixlid representeerivad objekte\n// (NB) Objekte on võimalik kategoriseerida. Seega optimiseerimine on teretulnud.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Raymarch\n    vec3 ray = normalize( vec3(\n        (fragCoord-iResolution.xy*.5)/iResolution.x, // pixel pos on screen\n        1. ) ); // place the screen 1 unit in front of eye        \n    vec3 pos = vec3(0,0,-8); // move eye 8 units back from scene    \n    vec2 angle = vec2(iTime * camRotationSpeed,.3);\n    if(iMouse.z>=.0) angle = (iMouse.xy/iResolution.xy-.5)*PI;\n    Rotate(pos,angle);\n    Rotate(ray,angle);\n    //fragColor = vec4(step(.0, Scene(ray * -zDepth +pos) ));    \n    \n    // Järgnev kood on killuke maagiat, kuna sellega saame me pinnaseid tuvastada.\n    // The SDF Tells ushow far we are from the closest surface at any point in space.\n    // So we can safely move that far in the direction of the ray without hitting anything.\n    // If we repeat this process enough times, the ray will end up almost exactly \n    // touching the surface of the object, so let's add a SDF Loop\n    fragColor = vec4(backgroundColor,1);\t// Define the background pixels\n    for( int i=0; i < 100; i++ )\n    {\n        float h = Scene(pos); // read the SDF - the distance to the closest surface\n        if( h< normalBiasFactor ) // if we're nearly touching a surface, paint the pixel black\n        {\n            fragColor = vec4(defaultColor,1);\n            break;\n        }\n        pos += ray*h;\n    }    \n    // We are doing lighting in its unique method.\n    vec3 normalDir;\n    AddLighting(pos,fragColor,normalDir);\n    #ifdef DEBUGNORMAL\n    fragColor.rgb = normalDir;\n    #endif\n    // Add gamam correction\n    fragColor.rgb = pow(fragColor.rgb,vec3(1.0/defaultGamma));\n}","name":"Image","description":"","type":"image"}]}