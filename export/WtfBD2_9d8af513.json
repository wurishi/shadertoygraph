{"ver":"0.1","info":{"id":"WtfBD2","date":"1597779581","viewed":170,"name":"Reflect shader Testing","username":"ptemoche","description":"I am learning.\nIt's not the best way but I am trying.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define MIN_DIST 0.01\n#define AA 8\n#define rn 4\n#define normal_desv 0.0\n#define eAA 0.001\n#define wAA 9.0\n\nmat3 RotY(float angle){\n \n    return mat3(cos(angle), 0.0,sin(angle),\n                0.0,       1.0,0.0       ,\n                -sin(angle),0.0,cos(angle));\n    \n}\n\nfloat hash21(vec2 st){\n \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n    \n}\n\nvec3 hash33(vec3 p){\n \n    return vec3(hash21(p.xy),hash21(p.yz),hash21(p.xz));\n}\n\nvec4 min_v4(vec4 a, vec4 b){\n \treturn(a.w<b.w)?a:b;   \n}\n\nvec4 sd_sphere(vec3 p, vec4 s, vec3 mat){\n    return vec4(mat,length(p-s.xyz)-s.w);\n}\nvec4 sd_cel(vec3 p, vec4 s, vec3 mat){\n    vec3 pos = sin(p*10.0+iTime)*0.5;\n    \n    float l = (length(p-s.xyz)-s.w+(pos.x*pos.y*pos.z))*0.5;\n    return vec4(mat,l);\n}\nvec4 sd_plane(vec3 pos, vec3 N, float d, vec3 mat){\n \n    vec3 p = pos*N;\n        \n    return vec4(mat,(d+p.x+p.y+p.z)*0.5);\n    \n}\n\n\n\nvec4 map(vec3 pos){\n \n    vec4 d = sd_sphere(pos, vec4(0.75,sin(iTime*2.0)*0.5,4.0+cos(iTime*2.0),0.45),vec3(0.7,0.1,0.1));\n    d = min_v4(d,sd_cel(pos, vec4(-1,0,4,0.45),vec3(0.1,0.9,0.9)));\n    d = min_v4(d,sd_sphere(pos, vec4(-1,-1,4.5,0.5),sin(pos*10.0)*0.5+0.5 ));\n    d = min_v4(d,sd_sphere(pos, vec4(-0.1,-1.1,4.6,0.4),sin(pos+iTime*5.0)*0.5+0.5));\n    d = min_v4(d,sd_sphere(pos, vec4(-0.5,-1.3,3.5,0.2),vec3(0.05,0.05,0.05)));\n    d = min_v4(d,sd_plane(pos,vec3(0.0,1.0,0.0),1.5,vec3(0.95,0.95,0.95)));\n    d = min_v4(d,sd_plane(pos,vec3(1.0,0.0,0.0),1.5,vec3(0.5,0.25,0.5)));\n    d = min_v4(d,sd_plane(pos,vec3(-1.0,0.0,0.0),1.5,vec3(0.1,0.1,0.95)));\n    d = min_v4(d,sd_plane(pos,vec3(0.0,-1.0,0.0),1.5,vec3(0.95,0.95,0.1)));\n    d = min_v4(d,sd_plane(pos,vec3(0.0,0.0,-1.0),5.0,vec3(0.1,0.95,0.1)));\n    d = min_v4(d,sd_plane(pos,vec3(0.0,0.0,1.0),1.0,vec3(0.1,0.95,0.1)));\n   \n   \n    \n    return d;\n}\n\nvec4 raymarching(vec3 o, vec3 dir){\n    \n    float d = 0.0;\n    vec4 t = vec4(0);\n    \n    for(int i = 0; i<MAX_STEPS;++i){\n     \tvec3 pos = o+dir*d;\n        t = map(pos);\n        d+=t.w;\n        \n        if(abs(t.w)<MIN_DIST || d>MAX_DIST)\n            break;\n    }\n    \n    t.w = d;\n    return t;\n    \n}\n\nvec3 getNormal(vec3 pos){\n \n    vec2 e = vec2(0.01,0.0);\n    \n    return normalize(map(pos).w-vec3(\n    \t\t\t\t\t\tmap(pos-e.xyy).w,\n        \t\t\t\t\tmap(pos-e.yxy).w,\n        \t\t\t\t\tmap(pos-e.yyx).w\n    \t\t\t\t\t\t)+sin(hash33(pos))*normal_desv);\n    \n}\n\nfloat getLigth(vec3 pos){\n \n    vec3 ligth  = vec3(1,1,3);\n    vec3 l = normalize(pos-ligth);\n    vec3 N = getNormal(pos);\n    float dif = clamp(dot(N,-l),0.0,1.0);\n    float spec = pow(clamp(dot(-l,reflect(normalize(pos),N)),0.0,1.0),200.0);\n    float amb = clamp(dot(N,normalize(vec3(0.0,-1.0,-1.0))),0.0,1.0);\n    float fresnel = 1.0-clamp(dot(N,normalize(-pos)),0.0,1.0);\n    float l_d = dif*0.4+spec*0.9+amb*0.1+fresnel*0.75;\n    \n    float d = raymarching(pos+N*0.1,-l).w;\n    \n    if(length(ligth-pos)>d)\n        l_d*=0.95;\n    \n\treturn l_d;    \n}\n\nvec3 getColor(vec3 origin, vec3 dir,int bounce){\n \n    vec3 col = vec3(0.0);\n    \n    \n    \n    for(int i = 0; i < bounce;++i){\n     \n        vec4 r_pos = raymarching(origin,dir);\n    \n        vec3 p = origin+dir*r_pos.w;\n\t\t\n        col += r_pos.xyz*getLigth(p)*(pow(2.0,float(bounce-1-i))/(pow(2.0,float(bounce))-1.0));\n        \n        \n        dir = reflect(normalize(p-origin),getNormal(p));\n        origin = p+dir*0.05;\n          \n    }\n    \n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    vec2 rot = (iMouse.xy*6.2831)/iResolution.xy;\n    vec3 origin = vec3(sin(rot),0.0);\n    vec3 dir = normalize(vec3(uv,1.0+origin.z)-origin);\n    \n    \n\tcol = (getColor(origin, dir, rn)*wAA)/(float(AA)+wAA);\n    \n    vec3 e = vec3(eAA,-eAA,0.0);\n    vec3 e2 = vec3(eAA,-eAA,0.0)*0.7071;\n    vec3 sampling[8];\n    sampling[0]=e.xzz;\n    sampling[1]=e.zyz;\n    sampling[2]=e.yzz;\n    sampling[3]=e.zxz;\n    sampling[4]=e2.xxz;\n    sampling[5]=e2.yxz;\n    sampling[6]=e2.xyz;\n    sampling[7]=e2.yyz;\n    \n    for(int i = 0; i<AA;++i){\n     \n        \n        vec3 dir = normalize(dir+sampling[i]);\n\n        col += getColor(origin,dir,1)/(float(AA)+wAA);\n        \n    }\n    //col = pow(col, vec3(0.4545));\n    // Output to screen\n    if(0.2126*col.r+0.7152*col.g+0.0722*col.b<0.6)\n        col*=1.0;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}