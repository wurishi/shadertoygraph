{"ver":"0.1","info":{"id":"7tyczd","date":"1662002877","viewed":107,"name":"GLSL_COLORSCROLL","username":"derhenryschmidt","description":"CECOCECO","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["henry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float angle = 180.0;\nfloat offset = 0.;\nfloat speed = .2;\nfloat color_width = 6.;\n\nfloat disturbance_strength = 2.0;\nfloat disturbance_speed = .3;\n\nbool smooth_transitions = true;\nint color_count = 6;\n\nvec4 color_1 = vec4(1.0, 0.3, 0.0, 1.0);\nvec4 color_2 = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 color_3 = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 color_4 = vec4(0.2, 0.9, 0.9, 1.0);\nvec4 color_5 = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 color_6 = vec4(0.0, 0.0, 0.0, 1.0);\n\nvec4 get_color(vec2 uv, float t) {\n    float _angle = -angle - 90.0; // Applying requested rotation rules\n    float hue = uv.x * cos(radians(_angle)) - uv.y * sin(radians(_angle)); // Rotation\n    hue = fract(hue + fract((t * speed) + offset)) * ((float(color_count)) / 6.0) * (1.0 /\n    float(color_count));\n    float x = 1. - abs(mod(hue / (1./ 6.), 2.) - 1.);\n    vec4 rainbow;\n\t \n    float y = x * float(color_count) * 2.; // has to be * (ColorCount * 2)\n\t \n    /*\n    The following blocks are divided as such:\n             [ColorA -> ColorB]\n             [ColorB]\n             [ColorB -> Color C]... and so on\n    */\n\t \n\n    if (y < 1.0) {\n        if (color_count == 1) { rainbow = color_1; }\n        else if (color_count == 2) { rainbow = smooth_transitions ? mix(color_2, color_1, y) : color_1; }\n        else if (color_count == 3) { rainbow = smooth_transitions ? mix(color_3, color_1, y) : color_1; }\n        else if (color_count == 4) { rainbow = smooth_transitions ? mix(color_4, color_1, y) : color_1; }\n        else if (color_count == 5) { rainbow = smooth_transitions ? mix(color_5, color_1, y) : color_1; }\n        else rainbow = smooth_transitions ? mix(color_6, color_1, y) : color_1;\n    } else if (y > 1.0 && y < 2.) {\n        rainbow = color_1;\n    } else if (y > 2. && y < 3.) {\n         rainbow = smooth_transitions ? mix(color_1, color_2, y-2.0) : color_2;\n    } else if (y > 3. && y < 4.) {\n         rainbow = color_2;\n    } else if (y > 4. && y < 5.) {\n         rainbow = smooth_transitions ? mix(color_2, color_3, y-4.0) : color_3;\n    } else if (y > 5. && y < 6.) {\n         rainbow = color_3;\n    } else if (y > 6. && y < 7.) {\n         rainbow = smooth_transitions ? mix(color_3, color_4, y-6.0) : color_4;\n    } else if (y > 7. && y < 8.) {\n         rainbow = color_4;\n    } else if (y > 8. && y < 9.) {\n         rainbow = smooth_transitions ? mix(color_4, color_5, y-8.0) : color_5;\n    } else if (y > 9. && y < 10.) {\n         rainbow = color_5;\n    } else if (y > 10. && y < 11.) {\n         rainbow = smooth_transitions ? mix(color_5, color_6, y-10.) : color_6;\n    } else if (y > 11.) {\n         rainbow = color_6;\n    }\n    return rainbow;\n}\n\nvec2 random(vec2 uv){\n    uv = vec2( dot(uv, vec2(127.1,311.7) ),\n    dot(uv, vec2(269.5,183.3) ) );\n    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);\n}\n\nfloat noise(vec2 uv) {\n    vec2 uv_index = floor(uv);\n    vec2 uv_fract = fract(uv);\n    vec2 blur = smoothstep(0.0, 1.0, uv_fract);\n    return mix( mix( dot( random(uv_index + vec2(0.0,0.0) ), uv_fract - vec2(0.0,0.0) ),\n    dot( random(uv_index + vec2(1.0,0.0) ), uv_fract - vec2(1.0,0.0) ), blur.x),\n    mix( dot( random(uv_index + vec2(0.0,1.0) ), uv_fract - vec2(0.0,1.0) ),\n    dot( random(uv_index + vec2(1.0,1.0) ), uv_fract - vec2(1.0,1.0) ), blur.x), blur.y) + 0.5;\n}\n\nvec2 distort_uv(vec2 uv) {\n    vec2 use_uv = uv;\n\n    float value = noise(use_uv);\n    float xoff = noise(use_uv + vec2(iTime*disturbance_speed, 15.0));\n    float yoff = noise(use_uv - vec2(15.0, iTime*disturbance_speed));\n    vec2 uv_offset = vec2(xoff, yoff) * disturbance_strength;\n    return uv + uv_offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= (10. - color_width);\n    fragColor = get_color(distort_uv(uv), iTime);\n}","name":"Image","description":"","type":"image"}]}