{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"vec3 analyzeGradient(vec3 gradient)\n{\n\tfloat l = log(length(gradient));\n    return mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), l);\n}\n\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nvec2 r(vec2 v,float y)\n{\n    return cos(y)*v+sin(y)*vec2(-v.y,v.x);\n}\n \nfloat boxRed(vec3 p){\n    p += vec3(-2.5, - 0.5 + 0.25 * sin(iTime * 3.0), -2);\n    //p.xy = r(p.xy, iTime);\n    //p.zy = r(p.zy, iTime);\n    return sdBox(p, vec3(0.5 + 0.1 * sin(10.0 * p.y + iTime * 2.0), 0.5, 0.5 + 0.1 * sin(10.0 * p.y + iTime * 2.0)));\n}\n\nfloat planeBlue(vec3 p){\n    vec4 n = vec4(0.0, 1.0, 0.0, 2.0);\n    n.w += 0.3 * sin(p.x + iTime) * sin(p.z + 3.0 * iTime);\n    return sdPlane(p, n);\n\n}\n\nfloat f(vec3 p)\n{\n    return min(boxRed(p), planeBlue(p));\n}\n\nvec3 draw(float d){\n    return vec3(0.0);\n}\n\nvec3 track(vec3 p){\n    //vec2 s = vec2(6, 6);\n    //s = r(s.xy, iTime);\n    //p.xz += s.xy;\n    //p.xz = r(p.xz, iTime * 0.1);\n\t//return p;\n    return p;\n}\n\nvec3 marchRay3(vec3 ro, vec3 rd, float rIndexOld){\n    const vec2 e = vec2(0.01, 0);\n    \n    const int numLights = 1;\n    vec3 lights[numLights];\n    lights[0] = vec3(-2.0, 2.0, -1.0);\n\n    vec3 mat[5];\n    mat[0] = vec3(0.7, 0.7, 1.0);\n    mat[1] = vec3(0.7, 0.7, 1.0);\n    mat[2] = vec3(0.7, 0.7, 0.7);\n    mat[3] = vec3(0, 0, 0);\n    mat[4] = vec3(8, 1.3, 0);\n    \n    vec3 pixel = vec3(0.0);\n    \n    float t = 0.0;\n    const int maxSteps = 64;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        //Define Material Colors\n        vec3 ambientColor = vec3(0.5, 0.5, 0.0);\n        vec3 diffuseColor = vec3(0.5, 0.5, 0.0);\n        vec3 specularColor = vec3(0.8, 0.8, 0.0);\n\n        //Calc new pos and distance to surface\n        vec3 p = ro + rd * t * 0.7;\n        p = track(p);\n        float d = f(p);\n        //If surface hit\n        if(d < 0.001)\n        {\n            if(planeBlue(p) < boxRed(p)){\n            \tmat[0] = vec3(0.7, 0.7, 1.0);\n                mat[1] = vec3(0.7, 0.7, 1.0);\n                mat[2] = vec3(0.7, 0.7, 0.7);\n                mat[3] = vec3(0, 0, 0);\n                mat[4] = vec3(8, 1.3, 0);\n            }\n            else{\n            \tmat[0] = vec3(1, 0.325, 0.05);\n                mat[1] = vec3(1, 0.325, 0.05);\n                mat[2] = vec3(1, 0.6397, 0.25);\n                mat[3] = vec3(0, 0, 0);\n                mat[4] = vec3(8, 1.3, 0);\n            }\n            //Set ambient color\n            pixel = vec3(0.1, 0.1, 0.1) * mat[0];\n\n            //calculate normal of surface for later use\n            vec3 normal = normalize(vec3(f(p+e.xyy)-f(p-e.xyy), f(p+e.yxy)-f(p-e.yxy), f(p+e.yyx)-f(p-e.yyx)));\n\n            //check for shadows and add colors with light\n            for(int l = 0; l < numLights; l++){\n\n                //Calc origin and direction of shadowray\n                vec3 srd = normalize(lights[l] - p);\n                vec3 sro = p + srd * 0.1;\n\n                float ts = 0.0;\n                bool shit = false;\n                for(int i = 0; i < maxSteps; ++i)\n                {\n                    //Calc new pos and distance to shadow-throwing object\n                    vec3 ps = sro + srd * ts;\n                    float ds = f(ps);\n                    //if object hit, continue, else color it more\n                    if(ds < 0.01)\n                    {\n                        shit = true;\n                        break;\n                    }\n\n                    ts += ds;\n                }\n                if(!shit){\n                    //set diffuse color\n                    float diffuseFactor = dot(normal, srd);\n                    pixel += mat[1] * diffuseFactor;\n                    //set specular color\n                    vec3 S = srd - 2.0 * dot(srd, normal) * normal;\n                    float specularFactor = dot(rd, S);\n                    if(specularFactor > 0.0){\n                        pixel += mat[2] * pow(specularFactor, mat[4].x);\n                    }\n                }\n            }\n\n            //no reflection & refraction for last iteration\n            break;\n        }\n\n        t += d;\n    }\n    return pixel;\n\n}\n\nvec3 marchRay2(vec3 ro, vec3 rd, float rIndexOld){\n    const vec2 e = vec2(0.01, 0);\n    \n    const int numLights = 1;\n    vec3 lights[numLights];\n    lights[0] = vec3(-2.0, 2.0, -1.0);\n\n    vec3 mat[5];\n    mat[0] = vec3(0.7, 0.7, 1.0);\n    mat[1] = vec3(0.7, 0.7, 1.0);\n    mat[2] = vec3(0.7, 0.7, 0.7);\n    mat[3] = vec3(1, 1, 0);\n    mat[4] = vec3(8, 1.3, 0);\n    \n    vec3 pixel = vec3(0.0);\n    \n    float t = 0.0;\n    const int maxSteps = 64;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        //Define Material Colors\n        vec3 ambientColor = vec3(0.5, 0.5, 0.0);\n        vec3 diffuseColor = vec3(0.5, 0.5, 0.0);\n        vec3 specularColor = vec3(0.8, 0.8, 0.0);\n\n        //Calc new pos and distance to surface\n        vec3 p = ro + rd * t * 0.7;\n        p = track(p);\n        float d = f(p);\n        //If surface hit\n        if(d < 0.001)\n        {\n            \n            if(planeBlue(p) < boxRed(p)){\n            \tmat[0] = vec3(0.7, 0.7, 1.0);\n                mat[1] = vec3(0.7, 0.7, 1.0);\n                mat[2] = vec3(0.7, 0.7, 0.7);\n                mat[3] = vec3(1, 1, 0);\n                mat[4] = vec3(8, 1.3, 0);\n            }\n            else{\n            \tmat[0] = vec3(1, 0.325, 0.05);\n                mat[1] = vec3(1, 0.325, 0.05);\n                mat[2] = vec3(1, 0.6397, 0.25);\n                mat[3] = vec3(1, 1, 0);\n                mat[4] = vec3(8, 1.3, 0);\n            }\n            //Set ambient color\n            pixel = vec3(0.1, 0.1, 0.1) * mat[0];\n\n            //calculate normal of surface for later use\n            vec3 normal = normalize(vec3(f(p+e.xyy)-f(p-e.xyy), f(p+e.yxy)-f(p-e.yxy), f(p+e.yyx)-f(p-e.yyx)));\n\n            //check for shadows and add colors with light\n            for(int l = 0; l < numLights; l++){\n\n                //Calc origin and direction of shadowray\n                vec3 srd = normalize(lights[l] - p);\n                vec3 sro = p + srd * 0.1;\n\n                float ts = 0.0;\n                bool shit = false;\n                for(int i = 0; i < maxSteps; ++i)\n                {\n                    //Calc new pos and distance to shadow-throwing object\n                    vec3 ps = sro + srd * ts;\n                    float ds = f(ps);\n                    //if object hit, continue, else color it more\n                    if(ds < 0.01)\n                    {\n                        shit = true;\n                        break;\n                    }\n\n                    ts += ds;\n                }\n                if(!shit){\n                    //set diffuse color\n                    float diffuseFactor = dot(normal, srd);\n                    pixel += mat[1] * diffuseFactor;\n                    //set specular color\n                    vec3 S = srd - 2.0 * dot(srd, normal) * normal;\n                    float specularFactor = dot(rd, S);\n                    if(specularFactor > 0.0){\n                        pixel += mat[2] * pow(specularFactor, mat[4].x);\n                    }\n                }\n            }\n\n            //reflection & refraction\n            float rIndex = mat[4].y;\n\n            float R = dot(normal,-rd);\n            float T = 1.0 - R;\n\n            if(mat[3].x == 1.0 && 0.0 == mat[3].y){\n                R = 1.0;\n            }\n\n            if(mat[3].x == 1.0 || 1.0 == mat[3].y && R > 0.0){\n                vec3 rrd = reflect(-rd, normal);\n                pixel += mat[2] * marchRay3(p + rrd * 0.02, rrd, mat[4].y) * R;\n            }\n\n            if(1.0 == mat[3].y && T > 0.0){\n                vec3 rrd = refract(rd, normal, rIndexOld / mat[4].y);\n                //pixel += mat[2] * marchRay3(p + rrd * 0.02, rrd, mat[4].y) * T;\n            }\n            break;\n        }\n\n        t += d;\n    }\n    return pixel;\n\n}\n\nvec3 marchRay(vec3 ro, vec3 rd, float rIndexOld){\n    const vec2 e = vec2(0.01, 0);\n    \n    const int numLights = 1;\n    vec3 lights[numLights];\n    lights[0] = vec3(-2.0, 2.0, -1.0);\n\n    vec3 mat[5];\n    mat[0] = vec3(0.7, 0.7, 1.0);\n    mat[1] = vec3(0.7, 0.7, 1.0);\n    mat[2] = vec3(0.7, 0.7, 0.7);\n    mat[3] = vec3(1, 1, 0);\n    mat[4] = vec3(8, 1.3, 0);\n    \n    vec3 pixel = texture(iChannel0, rd).rgb;\n    \n    float t = 0.0;\n    const int maxSteps = 128;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        //Define Material Colors\n        vec3 ambientColor = vec3(0.5, 0.5, 0.0);\n        vec3 diffuseColor = vec3(0.5, 0.5, 0.0);\n        vec3 specularColor = vec3(0.8, 0.8, 0.0);\n\n        //Calc new pos and distance to surface\n        vec3 p = ro + rd * t * 0.7;\n        p = track(p);\n        float d = f(p);\n        //If surface hit\n        if(d < 0.001)\n        {\n            if(planeBlue(p) < boxRed(p)){\n            \tmat[0] = vec3(0.7, 0.7, 1.0);\n                mat[1] = vec3(0.7, 0.7, 1.0);\n                mat[2] = vec3(0.7, 0.7, 0.7);\n                mat[3] = vec3(1, 1, 0);\n                mat[4] = vec3(8, 1.3, 0);\n            }\n            else{\n            \tmat[0] = vec3(1, 0.325, 0.05);\n                mat[1] = vec3(1, 0.325, 0.05);\n                mat[2] = vec3(1, 0.6397, 0.25);\n                mat[3] = vec3(1, 1, 0);\n                mat[4] = vec3(8, 1.3, 0);\n            }\n            //Set ambient color\n            pixel = vec3(0.1, 0.1, 0.1) * mat[0];\n\n            //calculate normal of surface for later use\n            vec3 normal = normalize(vec3(f(p+e.xyy)-f(p-e.xyy), f(p+e.yxy)-f(p-e.yxy), f(p+e.yyx)-f(p-e.yyx)) / 2.0 / e.x);\n            //pixel = analyzeGradient(normal);\n            //break;\n\n            //check for shadows and add colors with light\n            for(int l = 0; l < numLights; l++){\n\n                //Calc origin and direction of shadowray\n                vec3 srd = normalize(lights[l] - p);\n                vec3 sro = p + srd * 0.1;\n\n                float ts = 0.0;\n                bool shit = false;\n                for(int i = 0; i < maxSteps; ++i)\n                {\n                    //Calc new pos and distance to shadow-throwing object\n                    vec3 ps = sro + srd * ts;\n                    float ds = f(ps);\n                    //if object hit, continue, else color it more\n                    if(ds < 0.01)\n                    {\n                        shit = true;\n                        break;\n                    }\n\n                    ts += ds;\n                }\n                if(!shit){\n                    //set diffuse color\n                    float diffuseFactor = dot(normal, srd);\n                    pixel += mat[1] * diffuseFactor;\n                    //set specular color\n                    vec3 S = srd - 2.0 * dot(srd, normal) * normal;\n                    float specularFactor = dot(rd, S);\n                    if(specularFactor > 0.0){\n                        pixel += mat[2] * pow(specularFactor, mat[4].x);\n                    }\n                }\n            }\n\n            //reflection & refraction\n            float rIndex = mat[4].y;\n\n            float R = dot(normal,-rd);\n            float T = 1.0 - R;\n\n            if(mat[3].x == 1.0 && 0.0 == mat[3].y){\n                R = 1.0;\n            }\n\n            if(mat[3].x == 1.0 || 1.0 == mat[3].y && R > 0.0){\n                vec3 rrd = reflect(-rd, normal);\n                pixel += mat[2] * marchRay2(p + -rrd * 0.02, -rrd, mat[4].y) * R;\n            }\n\n            if(1.0 == mat[3].y && T > 0.0){\n                vec3 rrd = refract(rd, normal, rIndexOld / mat[4].y);\n                //pixel += mat[2] * marchRay2(p + rrd * 0.02, rrd, mat[4].y) * T;\n            }\n            break;\n        }\n\n        t += d;\n    }\n    return pixel;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec3 eye = vec3(0, 0, -1);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n \n    vec2 uv = fragCoord.xy * vec2(2.0) / iResolution.xy - vec2(1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 forward = normalize(cross(right, up));\n    vec3 ro = eye + forward + right * uv.x + up * uv.y;\n    vec3 rd = normalize(ro - eye);\n \n    vec3 pixel = vec3(0.0); // Sky color\n    \n    float rIndexOld = 1.0;\n    pixel = marchRay(ro, rd, rIndexOld);\n \n    fragColor = vec4(pixel, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdSXz3","date":"1414434957","viewed":160,"name":"First Try Raymarching","username":"Yatekii","description":"asdasd","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["adasd"],"hasliked":0,"parentid":"","parentname":""}}