{"ver":"0.1","info":{"id":"7lcXzj","date":"1639398164","viewed":157,"name":"Exact Pixel Coverage","username":"chronos","description":"Attempt to demonstrate the concept of exact* pixel coverage, i.e. area based prefiltering. WIP.\nNote that if there would be more shapes, then their Z order and their combined overlap would have to be considered also.\n\n*for an inexact definition of 'exact'","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["pixel","filtering","box","area","aabb","analytic","boxes","prefiltering","coverage","prefilter"],"hasliked":0,"parentid":"7ttSRS","parentname":"Exact Grid Pixel Coverage"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct box // axis aligned 2D rectangle\n{\n    vec2 corner1; // (left, bottom)\n    vec2 corner2; // (right, top)\n};\n\nfloat width(box b)\n{\n    return b.corner2.x - b.corner1.x;\n}\n\nfloat height(box b)\n{\n    return b.corner2.y - b.corner1.y;\n}\n\nvec2 width_height(box b)\n{\n    return b.corner2 - b.corner1;\n}\n\nfloat filled_rect(vec2 p, vec2 corner, float width, float height)\n{\n    return float(\n        p.x >= corner.x && p.x <= corner.x + width &&\n        p.y >= corner.y && p.y <= corner.y + height\n    );\n}\n\nfloat rect(vec2 p, vec2 corner, float width, float height)\n{\n    return float(\n        (\n            p.x == corner.x || p.x == corner.x + width ||\n            p.y == corner.y || p.y == corner.y + height\n        )\n        &&\n        (\n            p.x >= corner.x && p.x <= corner.x + width &&\n            p.y >= corner.y && p.y <= corner.y + height\n        )\n    );\n}\n\nfloat filled_rect(vec2 p, box b)\n{\n    return float(\n        p.x >= b.corner1.x && p.x <= b.corner2.x &&\n        p.y >= b.corner1.y && p.y <= b.corner2.y\n    );\n}\n\nfloat rect(vec2 p, box b)\n{\n    return float(\n        (\n            p.x == b.corner1.x || p.x == b.corner2.x ||\n            p.y == b.corner1.y || p.y == b.corner2.y\n        )\n        &&\n        (\n            p.x >= b.corner1.x && p.x <= b.corner2.x &&\n            p.y >= b.corner1.y && p.y <= b.corner2.y\n        )\n    );\n}\n\nfloat And(float a, float b)\n{\n    return min(a, b);\n    //return a * b;\n}\n\nfloat Or(float a, float b)\n{\n    return max(a, b);\n    //return a + b - a * b;\n}\n\nfloat area(box b)\n{\n    return width(b) * height(b);\n}\n\nbox intersect(box a, box b)\n{\n    box c;\n    c.corner1 = max(a.corner1, b.corner1);\n    c.corner2 = min(a.corner2, b.corner2);\n    return c;\n    \n}\n\nfloat overlap(box a, box b)\n{\n    return area(intersect(a,b));\n}\n\nfloat over(box a, box b)\n{\n    return overlap(a,b) / area(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    vec2 p = floor(fragCoord);\n    \n    \n    // box pixel = box(p, p+1.); // Not used for now, but you would clip against this in an actual pixel coverage implementation\n    \n    vec2 q = iMouse.xy;\n    vec2 corner1 = floor(iResolution.xy/vec2(3.,4));\n    vec2 corner2 = floor(corner1 + iResolution.y/2.);\n    box a = box(corner1, corner2);\n    vec2 half_width_height = floor(width_height(a)/2.);\n    box b = box(q - half_width_height, q+half_width_height);\n    float r1 = rect(p, a);\n    float r2 = rect(p, b);\n    float r3 = filled_rect(p, intersect(a, b));\n \n    float r = Or(r1, r2);\n    r = Or(r, r3);\n \n    float r4 = filled_rect(p, a) * over(a, b);\n \n    vec3 color = vec3(max(r, r4));\n\n\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}