{"ver":"0.1","info":{"id":"MssyRB","date":"1489107485","viewed":172,"name":"my lemond bike frame","username":"polyrhythm","description":"getting used to modeling in SDF. any ideas on controlling the artifacting around the blends of the cylinders?\n\nflames welcome","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["bike"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n#define SUN_DIR normalize(vec3(0.75, 2.25, 0.75))\n#define GAMMA 2.2\n#define PI 3.14159265359\n\n// -----------------\n// domain distortion\n// -----------------\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// -----------------\n// obj combination\n// -----------------\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\n// -----------------\n// sdf\n// -----------------\nfloat sdCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sdBoxCheap(vec3 p, vec3 b) {\n\treturn vmax(abs(p) - b);\n}\n\nfloat sdBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\n// -----------------\n// terrain\n// -----------------\nfloat f(vec2 p)\n{\n    return sin(p.x) * sin(p.y);\n}\n\nvec3 getTerrainNormal(vec3 p)\n{\n    vec3 n;\n    float eps = 0.02;\n    n.x = f(vec2(p.x - eps, p.z)) - f(vec2(p.x + eps, p.z));\n    n.y = 2.0 * eps;\n    n.z = f(vec2(p.x, p.z - eps)) - f(vec2(p.x, p.z + eps));\n    \n    return normalize(n);\n}\n\nfloat traceTerrain(vec3 ro, vec3 rd, out float resT)\n{\n    const float minT = 5.0;\n    const float maxT = 10.0;\n    float lh = 0.0;\n    float ly = 0.0;\n    float delta = 0.01;\n    for (float t = minT; t < maxT;) {\n        vec3 p = ro + rd * t;\n        float h = f(p.xz);\n        if (p.y < h) {\n         \tresT = t - delta * delta + (lh - ly) / (p.y - ly - h + lh);\n            return 1.0;\n        }\n        \n        delta = 0.01 * t;\n        t += delta;\n        lh = h;\n        ly = p.y;\n    }\n    \n    return 0.0;\n}\n\n// -----------------\n// scene\n// -----------------\nconst float SPHERE = 1.0;\nconst float GROUND = 2.0;\nconst float FRAME = 3.0;\nconst float WALL = 4.0;\n\nvec2 map(vec3 p)\n{\n    float d1 = p.y + 1.0;\n    \n    vec3 wP = p;\n    wP.x -= 1.6;\n    \n    // wall\n    vec3 wallP = wP;\n    wallP.y -= 0.5;\n    wallP.x += 2.0;\n    float wall = sdBox2Cheap(wallP.xy, vec2(0.1, 2.5));\n    \n    vec3 windowP = wP;\n    windowP.x += 2.3;\n    windowP.y -= 0.75;\n    windowP.z -= 0.1;\n    float window = sdBoxCheap(windowP, vec3(0.5, 0.8, 0.6));\n    \n    wall = max(-window, wall);\n    \n    \n    // position the frame\n    vec3 fP = p;\n    fP.y += 0.35;\n    pR(fP.xy, radians(13.0));\n    \n    // downtube\n    vec3 dtP = fP;\n    dtP.z += 0.1;\n    pR(dtP.yz, radians(-50.0));\n    float downtube = sdCylinder(dtP, 0.05, 0.9);\n    \n    // headtube\n    vec3 htP = fP;\n    htP.y -= 0.65;\n    htP.z += 0.825;\n    pR(htP.yz, radians(20.0));\n    float headtube = sdCylinder(htP, 0.065, 0.2);\n    \n    //toptube\n    vec3 ttP = fP;\n    pR(ttP.yz, radians(95.0));\n    ttP.z += 0.65;\n    ttP.y -= 0.0;\n    float toptube = sdCylinder(ttP, 0.05, 0.80);\n    \n    // seattube\n    vec3 stP = fP;\n    pR(stP.yz, radians(15.0));\n    stP.z -= 0.7;\n    stP.y -= 0.45;\n    float seattube = sdCylinder(stP, 0.05, 0.75);\n    \n    // seatstays\n    vec3 ssP = fP;\n    ssP.x = abs(ssP.x);\n    ssP.z -= 1.22;\n    ssP.x -= 0.1;\n    ssP.y -= 0.1;\n    pR(ssP.zy, radians(35.0));\n    pR(ssP.xy, radians(5.0));\n    float seatstays = sdCylinder(ssP, 0.015, 0.55);\n    \n    // chainstays\n    vec3 csP = fP;\n    csP.x = abs(csP.x);\n    csP.x -= 0.08;\n    csP.z -= 1.1;\n    csP.y += 0.445;\n    pR(csP.zy, radians(100.0));\n    pR(csP.xy, radians(8.0));\n    float chainstays = sdCylinder(csP, csP.y * 0.03 + 0.03, 0.45);\n    \n    float f1 = fOpUnionRound(downtube, seattube, 0.15);\n    float f2 = fOpUnionRound(f1, chainstays, 0.1);\n    float f3 = fOpUnionRound(f2, headtube, 0.05);\n    float f4 = fOpUnionRound(f3, seatstays, 0.05);\n    float frame = fOpUnionRound(f4, toptube, 0.05);\n    \n    vec2 result;\n    \n    result.x = min(frame, min(wall, d1));\n    result.y = FRAME;\n    if (result.x == d1) result.y = GROUND;\n    else if (result.x == wall) result.y = WALL;\n    \n    return result;\n}\n\nvec2 trace(vec3 ro, vec3 rd, out float resT, out vec3 pos)\n{\n    const float EPSILON = 0.002;\n    const float MAX_DIST = 100.0;\n    const int STEPS = 92;\n    float t = 0.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        pos = ro + rd * t;\n        vec2 d = map(pos);\n        \n        if (d.x < EPSILON) {\n            resT = d.x;\n            \n            return d;\n        }\n        \n        if (d.x > MAX_DIST) {\n            return vec2(-1.0);\n        }\n        \n        t += d.x * 0.7;\n    }\n    \n    return vec2(-1.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    const float k = 18.0;\n \tfloat t;\n    const float mint = 0.01;\n    const float maxt = 30.0;\n    \n    for (t = mint; t < maxt;)\n    {\n     \tfloat h = map(ro + rd * t).x;\n        if (h < 0.0001) {\n         \treturn 0.0;   \n        }\n        \n        res = min(res, k * h / t);\n        \n        t += h;\n    }\n    \n    return res;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n;\n    const vec3 eps = vec3(0.02, 0.0, 0.0);\n    n.x = map(p + eps.xyy).x - map(p - eps.xyy).x;\n    n.y = map(p + eps.yxy).x - map(p - eps.yxy).x;\n    n.z = map(p + eps.yyx).x - map(p - eps.yyx).x;\n    \n    return normalize(n);\n}\n\nvec3 renderTerrain(vec3 ro, vec3 rd)\n{\n    vec3 sky = vec3(0.1, 0.2, 0.3) + (ro.y * ro.y) * 0.2;\n \tfloat resT;\n    float t = traceTerrain(ro, rd, resT);\n    \n    if (t == 0.0) {\n        return sky;\n    }\n    \n    vec3 n = getTerrainNormal(ro + rd * resT);\n    \n    float incidence = saturate(dot(n, SUN_DIR));\n    vec3 Fd = vec3(0.1, 0.2, 0.3) * incidence;\n    \n    Fd = mix(Fd, vec3(sky), 1.0 - exp(-length(ro + rd * resT) * 0.5) * 3.0);\n    \n    return Fd;\n}           \n\nvec3 render(vec3 ro, vec3 rd, out vec3 pos)\n{\n    vec3 colour = vec3(0.7, 0.7, 0.9);\n    float resT;\n    vec2 t = trace(ro, rd, resT, pos);\n    vec3 volumetric = vec3(0.0);\n    \n    if (pos.x < -0.5) {\n        return renderTerrain(ro, rd);\n    }\n    \n    if (t.x <= 0.0) {\n    \treturn colour;\n    }\n    \n    vec3 diffuseColour;\n    vec3 n;\n    float shininess;\n    \n    if (t.y == GROUND) {\n        diffuseColour = vec3(0.3, 0.7, 0.2);\n        n = vec3(0.0, 1.0, 0.0) + texture(iChannel1, pos.xz * 0.3).xyz;\n    }\n    else if (t.y == FRAME) {\n     \tdiffuseColour = vec3(1.0);\n        n = getNormal(pos);;\n    }\n    else if (t.y == WALL) {\n        diffuseColour = vec3(0.05, 0.2, 0.1);\n        n = getNormal(pos);\n    }\n    \n    float LoV = saturate(dot(SUN_DIR, normalize(-pos)));\n    \n    // diffuse\n    float incidence = saturate(dot(SUN_DIR, n));\n    vec3 Fd = diffuseColour * incidence;\n    \n    if (incidence > 0.0) {\n     \tFd *= shadow(pos, SUN_DIR);   \n    }\n    \n    return Fd;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 r = iResolution.xy;\n    vec2 m = vec2(0.0);\n    vec2 q = fragCoord.xy / r.xy;\n    vec2 uv = q * 2.0 - 1.0;\n    uv.x *= r.x / r.y;\n    if (iMouse.z > 0.0) {\n   \t    m += (2.0 * iMouse.xy - r.xy) / r.yy;\n    }\n \n    float dist = 2.5;\n    vec3 ro = vec3(dist * clamp(cos(iTime * 0.1 + 6.0 * m.x), 0.5, 1.0),\n                   clamp(1.0 + m.y * 4.0, 0.5, 2.0),\n                   dist * clamp(sin(iTime * 0.1 + 6.0 * m.x), 0.2, 0.25));\n        \n    vec3 target = vec3(0.0);\n    mat3 ca = setCamera(ro, target, 0.0);\n    vec3 rd = ca * normalize(vec3(uv.xy, 1.5));\n    \n    vec3 pos;\n    vec3 colour = render(ro, rd, pos);\n    \n    // indoor \"fog\"\n    if (pos.x > -0.5 || pos.y > 10.0 && pos.x > 1.0) {\n    \tcolour = mix(colour, vec3(0.0), 1.0 - exp(-length(pos)) * 0.5);\n    }\n    \n    // vignette\n    colour *= 0.5 + 0.8 * pow(8.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.25);\n    \n    // gamma correct\n    colour = pow(colour, vec3(1.0 / GAMMA));\n    \n\tfragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}