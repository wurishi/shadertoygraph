{"ver":"0.1","info":{"id":"ldVBDc","date":"1601415607","viewed":472,"name":"Spiky Weirdness","username":"blurryroots","description":"^^","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["superformula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TWO_PI 6.28319\n\nfloat superformula (float angle, vec4 shape, vec2 symmetry) {    \n    float m = shape.x;\n    float n1 = shape.y;\n    float n2 = shape.z;\n    float n3 = shape.w;\n    float a = symmetry.x;\n    float b = symmetry.y;\n\n    float rpart = (m * angle) / 4.;\n    float apart = abs (cos (rpart) / a);\n    float bpart = abs (sin (rpart) / b);\n\n    float r = pow (\n        pow (apart, n2) + pow (bpart, n3),\n        -1. / n1\n    );\n    \n    return r;\n}\n\nfloat angleBetween (vec2 a, vec2 b) {\n    float cosTheta = dot (a, b) / (length (a) * length (b));\n    \n    return acos (cosTheta);\n}\n\nvec4 createShape (float t) {    \n    float m = 1. + abs (sin (t) + cos (1.6 * t)) * 8.;\n    float n1 = 1. + abs (sin (2. * t) * 4.);\n    float n2 = 1. + (cos (t + PI / 1.6) * 2.);\n    float n3 = 2. + sin (1.6 * t + PI) * 4.;\n    \n    return vec4 (m, n1, n2, n3);\n}\n\nvec2 createSymmetry (float t) {\n    return  vec2 (.5 + sin (t + PI / 2.) * .5, .5 + cos (t) * .5);\n}\n\nfloat calculateRadius (float angle, vec4 shape, vec2 symmetry, float dampening) {\n    float maxRadius = iResolution.y / 2.;\n\n    return maxRadius * superformula (angle, shape, symmetry) * dampening;\n}\n\nfloat combineShapes (float angle, float x, vec4 shapeA, vec2 symmetryA, vec4 shapeB, vec2 symmetryB, float dampening) {\n\tfloat rA = calculateRadius (angle, shapeA, symmetryA, dampening);\n    float rB = calculateRadius (angle, shapeB, symmetryB, dampening);\n\t\n    return mix (rA, rB, x);\n} \n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float radius = iResolution.y / 2.;\n    float dampening = 0.6;\n    vec2 offset = vec2(0., 20);\n    \n    vec2 center = iResolution.xy / 2.;\n    vec2 d = fragCoord - (center + offset);\n    vec2 up = vec2 (0., 1.);\n        \n    float angle = angleBetween (up, d);\n    float t = iTime * 0.6;\n    //vec2 symmetry = createSymmetry (t);\n    //vec4 shape = createShape (t);\n    vec2 symmetry = vec2(0.618,1.618);\n    vec4 shape;\n    {\n    float m =   1.618 *7.\n         ,n1 = 0.618\n         ,n2 = 0.618\n         ,n3 = 0.618\n         ;\n\tshape = vec4(m,n1,n2,n3);\n    }\n    //float shape_border_radius = superformula (angle, shape, symmetry) * radius * dampening;\n    vec4 shape2;\n    {\n    float m =  10.0\n         ,n1 = 1.0\n         ,n2 = 3.0\n         ,n3 = 6.0\n         ;\n\tshape2 = vec4(m,n1,n2,n3);\n    }\n    \n    float shape_border_radius = combineShapes (angle, 0.0, shape * abs(sin(iTime)), symmetry, shape2, symmetry, dampening);\n    \n    float sample_radius = length (d); \n    vec3 color_core = vec3 (0.9);\n    vec3 color_rim = vec3 (0.);\n    float gradient_exponent = 0.08;\n    float rim_thickness = 1.1;\n    \n    if (0. < sample_radius) {\n        float border_distance = pow(1. - sample_radius / shape_border_radius, gradient_exponent);\n        vec3 gradient_color = mix (color_rim, color_core, border_distance);\n        \n        if (sample_radius <= shape_border_radius) {\n        \tfragColor = vec4 (gradient_color, 1.);\n        }\n        else if (sample_radius <= (shape_border_radius+rim_thickness)) {\n        \tfragColor = vec4(color_rim, 1.);\n        }\n    }\n    else {\n        fragColor = vec4 (0., 0., 0., 0.);\n    }\n}","name":"Image","description":"","type":"image"}]}