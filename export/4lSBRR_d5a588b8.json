{"ver":"0.1","info":{"id":"4lSBRR","date":"1521550623","viewed":483,"name":"Pathtracing Demo","username":"Crow","description":"pathtracing","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raycasting","dof","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(1.0 / 2.2));    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nreferences:\n\t实时碰撞检测算法技术(Real-Time Collision Detection)\n\thttps://www.cnblogs.com/samen168/p/5162337.html\n\thttps://www.shadertoy.com/view/llGSDD\t\n\thttps://www.shadertoy.com/view/4lcSRn\n\thttps://www.shadertoy.com/view/Xt3SzX\n\thttps://www.shadertoy.com/view/4dtGWB\n\thttps://www.shadertoy.com/view/lldGDj\n*/\n\n#define FARCLIP 20.0\n#define PI 3.1416\n#define DOFRADIUS 0.1\n#define DOFDISTANCE 6.0\n\nstruct Ray \n{\n    vec3 ori;\n\tvec3 dir;\n};\n\nstruct Hit \n{\n\tfloat dis;\n    vec3 nor;\n\tfloat mat;\n};\n    \nHit CreateHit(Ray ray)\n{\n    Hit hit;\n    hit.dis = FARCLIP;\n    hit.nor = ray.dir;\n    hit.mat = 0.0;\n    return hit;\n}\n\nvoid SetHit(inout Hit hit, float dis, vec3 nor, float mat)\n{\n    hit.dis = dis;\n    hit.nor = nor;\n    hit.mat = mat;\n}\n\nHit IntersectCube(Ray ray, vec3 minPos, vec3 maxPos, float mat)  //AABB, Cull Off\n{\n    Hit hit = CreateHit(ray);\n    vec3 tMin = (minPos - ray.ori) / ray.dir;\n    vec3 tMax = (maxPos - ray.ori) / ray.dir;\n    vec3 t1 = min(tMin, tMax);      \n    vec3 t2 = max(tMin, tMax);\n    float hitNear = max(max(t1.x, t1.y), t1.z);\n    float hitFar = min(min(t2.x, t2.y), t2.z);\n    if (hitFar < hitNear || hitFar < 0.0)\n        return hit;\n    \n    float hitDis = mix(hitFar, hitNear, step(0.0, hitNear));\n    vec3 hitPos = ray.ori + ray.dir * hitDis;\n    vec3 hitNor = mix(vec3(-1.0), vec3(0.0), step(vec3(0.0001), abs(hitPos - minPos)));\n    hitNor = mix(vec3(1.0), hitNor, step(vec3(0.0001), abs(hitPos - maxPos)));    \n    SetHit(hit, hitDis, hitNor, mat);\n    return hit;\n}\n\nHit IntersectSphere(Ray ray, vec3 pos, float radius, float mat)  //Cull Off\n{\n    Hit hit = CreateHit(ray);\n    vec3 oc = pos - ray.ori;\n    float proj = dot(oc, ray.dir);\n    float disSqu = radius * radius - (dot(oc, oc) - proj * proj);\n    if (disSqu < 0.0)\n        return hit;\n\n    float dis = sqrt(disSqu);\n    float hitFar = proj + dis;\n    if (hitFar < 0.0)\n        return hit;\n    \n    float hitNear = proj - dis;\n    float hitDis = mix(hitFar, hitNear, step(0.0, hitNear));\n    SetHit(hit, hitDis, normalize(ray.ori + ray.dir * hitDis - pos), mat);\n    return hit;    \n}\n\nHit IntersectTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, float mat)  //Cull Off\n{\n    Hit hit = CreateHit(ray);\n    vec3 edge1 = v1 - v0;\n\tvec3 edge2 = v2 - v0;\n\tvec3 p = cross(ray.dir, edge2);    \n\tfloat det = dot(edge1, p);\n    vec3 t = ray.ori - v0;\n    if (det < 0.0)\n    {\n        det = -det;\n        t = -t;\n    }    \n\tfloat u = dot(t, p);\n\tif (u < 0.0 || u > det)\n\t    return hit;\n    \n\tvec3 q = cross(t, edge1);\n\tfloat v = dot(ray.dir, q);\n\tif (v < 0.0 || u + v > det)\n\t    return hit;\n    \n    float hitDis = dot(edge2, q);\n    if (hitDis < 0.0)\n\t    return hit;\n    \n    vec3 hitNor = normalize(cross(edge1, edge2));    \n    SetHit(hit, hitDis / det, hitNor, mat);\n\treturn hit;\n}\n\nHit IntersectCylinder(Ray ray, vec3 pa, in vec3 pb, float radius, float mat)\n{\n    Hit hit = CreateHit(ray);    \n    vec3 cc = (pa + pb) * 0.5;\n    float ch = length(pb - pa);\n    vec3 ca = (pb - pa) / ch;\n    ch *= 0.5;\n    vec3 oc = ray.ori - cc;\n    float card = dot(ca, ray.dir);\n    float caoc = dot(ca, oc);    \n    float a = 1.0 - card * card;\n    float b = dot(oc, ray.dir) - caoc * card;\n    float c = dot(oc, oc) - caoc * caoc - radius * radius;\n    float h = b * b - a * c;\n    if (h < 0.0)\n        return hit;\n    \n    h = sqrt(h);\n    float hitFar = (-b + h) / a;\n    if (hitFar < 0.0)\n        return hit;\n    \n    float hitNear = (-b - h) / a;\n    float y = caoc + hitNear * card;\n    if (abs(y) < ch)\n    {\n        if (hitNear < 0.0)\n            return hit;\n        \n        SetHit(hit, hitNear, normalize(oc + hitNear * ray.dir - ca * y), mat);\n        return hit;\n    }\n    \n    float sy = sign(y);\n    float tp = (sy * ch - caoc) / card;\n\tif(tp > 0.0 && abs(b + a * tp) < h)\n        SetHit(hit, tp, ca * sy, mat);    \n    return hit;\n}\n\nHit IntersectCapsule(Ray ray, vec3 pa, in vec3 pb, float radius, float mat)\n{\n    Hit hit = CreateHit(ray);    \n    vec3 cc = (pa + pb) * 0.5;\n    float ch = length(pb - pa);\n    vec3 ca = (pb - pa) / ch;\n    ch *= 0.5;\n    vec3 oc = ray.ori - cc;\n    float card = dot(ca,ray.dir);\n    float caoc = dot(ca,oc);    \n    float raSqu = radius * radius;\n    float a = 1.0 - card * card;\n    float b = dot(oc, ray.dir) - caoc * card;\n    float c = dot(oc, oc) - caoc * caoc - raSqu;\n    float h = b * b - a * c;\n    if (h < 0.0)\n        return hit;\n    \n    h = sqrt(h);\n    float hitFar = (-b + h) / a;\n    if (hitFar < 0.0)\n        return hit;\n    \n    float hitNear = (-b - h) / a;\n    float y = caoc + hitNear * card;\n    if (abs(y) < ch)\n    {\n        if (hitNear < 0.0)\n            return hit;\n        \n        SetHit(hit, hitNear, normalize(oc + hitNear * ray.dir - ca * y), mat);\n        return hit;\n    }\n    \n    float sy = sign(y);\n    oc = (cc + sy * ca * ch) - ray.ori;\n    b = dot(ray.dir, oc);\n    h = raSqu - (dot(oc, oc) - b * b);\n    if (h < 0.0)\n        return hit;\n    \n    hitNear = b - sqrt(h);\n    if(hitNear > 0.0)\n        SetHit(hit, hitNear, normalize(ray.dir * hitNear - oc), mat);\n    return hit;\n}\n\nHit IntersectScene(Ray ray)\n{\n    Hit hit = IntersectCylinder(ray, vec3(0.0, -0.5, 0.0), vec3(0.0, 0.0, 0.0), 5.0, 1.0);\n    Hit hit2 = IntersectSphere(ray, vec3(2.8, 1.0, 0.5), 1.0, 2.0);\n    if (hit2.dis < hit.dis) hit = hit2;\n    hit2 = IntersectCube(ray, vec3(-1.0, 0.0, -3.0), vec3(1.0, 2.0, -1.0), 3.0);\n    if (hit2.dis < hit.dis) hit = hit2;\n    hit2 = IntersectCapsule(ray, vec3(-0.5, 0.5, 1.0), vec3(1.0, 0.5, 3.0), 0.5, 4.0);\n    if (hit2.dis < hit.dis) hit = hit2;\n    \n    vec3 points[4];\n    points[0] = vec3(-2.5, 2.0, 0.5);\n    points[1] = vec3(-3.5, 0.0, -0.7);\n    points[2] = vec3(-3.5, 0.0, 1.7);\n    points[3] = vec3(-1.5, 0.0, 0.5);\n    hit2 = IntersectTriangle(ray, points[0], points[1], points[2], 5.0);\n    if (hit2.dis < hit.dis) hit = hit2;\n    hit2 = IntersectTriangle(ray, points[0], points[2], points[3], 5.0);\n    if (hit2.dis < hit.dis) hit = hit2;\n    hit2 = IntersectTriangle(ray, points[0], points[3], points[1], 5.0);\n    if (hit2.dis < hit.dis) hit = hit2;\n    \n    return hit;\n}\n\n//---material--------------------------------------------------\nstruct Mat\n{\n    vec3 col;\n    float rou;\n    float spe;    \n    vec3 emi;\n    float refr;\n};\n\nMat CreateMat(vec3 col, float rou, float spe, vec3 emi, float refr)\n{\n    Mat mat;\n    mat.col = col;\n    mat.rou = rou;\n    mat.spe = spe;\n    mat.emi = emi;\n    mat.refr = refr;\n    return mat;\n}\n\nMat GetMat(float matId)\n{\n    if(matId < 1.5)\n    {\n        return CreateMat(vec3(0.9), 0.9, 0.1, vec3(0.0), 0.0);\n    }\n    else if(matId < 2.5)\n    {\n        return CreateMat(vec3(0.4, 0.7, 0.9), 0.02, 1.0, vec3(0.0), 1.5);\n    }\n    else if(matId < 3.5)\n    {\n        return CreateMat(vec3(0.8, 0.3, 0.2), 0.7, 0.3, vec3(0.0), 0.0);\n    }\n    else if(matId < 4.5)\n    {\n        return CreateMat(vec3(0.1, 0.5, 0.2), 0.3, 0.7, vec3(0.2, 2.0, 0.3), 0.0);\n    }\n    else\n    {\n        return CreateMat(vec3(0.8, 0.7, 0.3), 0.0, 0.99, vec3(0.0), 0.0);\n    }\n}\n\n//---render-------------------------------------------------\nfloat seed = 0.0;\nfloat Rand() { return fract(sin(seed++) * 43758.5453123); }\n\nvec3 Jitter(vec3 d, float phi, float sina, float cosa) \n{\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u * cos(phi) + v * sin(phi)) * sina + w * cosa;\n}\n\nfloat FresnelSchlick(float inCosine, float normalReflectance)\n{\n    float oneMinusCos = 1.0 - inCosine;\n\tfloat fresnel = normalReflectance + (1.0 - normalReflectance) * pow(oneMinusCos, 5.0);\n\treturn fresnel;\n}\n\nfloat FresnelRefraction(float cosi, float cost, float etai, float etat)\n{\n    float rs = (etat * cosi - etai * cost) / (etat * cosi + etai * cost);\n    float rp = (etai * cosi - etat * cost) / (etai * cosi + etat * cost);\n    return (rs * rs + rp * rp) * 0.5;\n}\n\nvec3 Render(Ray ray)\n{    \n    vec3 lightDir = normalize(vec3(1.0, -1.0, 0.0));\n    vec3 lightCol = vec3(10.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    for(int i = 0; i < 6; i++)\n    {\n        Hit hit = IntersectScene(ray);\n        if(hit.mat > 0.5)\n        {\n            Mat mat = GetMat(hit.mat);\n            \n            float nv = dot(hit.nor, -ray.dir);\n            float refr = mat.refr;            \n            vec3 refrDir = vec3(0.0);\n            float fresnel = 0.0;\n            if(refr > 0.0)\n            {\n                float sig = sign(nv);\n                hit.nor *= -sig;\n                nv *= sig;\n                \n                float isInside = clamp(-sig, 0.0, 1.0);\n                refr = mix(1.0 / refr, refr, isInside);\n                refr = mix(refr, 0.0, step(1.0 - refr * refr * (1.0 - nv * nv), 0.0));\n                \n                refrDir = normalize(refract(ray.dir, -hit.nor, refr));\n            \tfloat nr = max(dot(hit.nor, refrDir), 0.0);\n                fresnel = isInside > 0.5 ? FresnelRefraction(nv, nr, refr, 1.0) : FresnelRefraction(nv, nr, 1.0, refr);\n            }\n            else\n            {\n                fresnel = FresnelSchlick(nv, mat.spe);\n            }\n            \n            float r1 = 2.0 * PI * Rand();\n            float r2 = Rand();\n            vec3 ranDir = Jitter(hit.nor, r1, sqrt(r2), sqrt(1.0 - r2));\n            \n            col += mat.emi * mask;\n            mask *= mat.col;\n            \n            ray.ori += ray.dir * hit.dis + hit.nor * 0.001;             \n            if(refr > 0.0 && Rand() > 0.25 + 0.5 * fresnel)\n            {\n                ray.dir = mix(ranDir, refrDir, 1.0 - mat.rou);\n            }\n            else\n            {                \n                ray.dir = mix(ranDir, reflect(ray.dir, hit.nor), fresnel * (1.0 - mat.rou));\n            }   \n            ray.dir = normalize(ray.dir);\n        }\n        else\n        {\n            col += texture(iChannel1, ray.dir).rgb * mask;\n            col += pow(max(dot(lightDir, -ray.dir), 0.0), 128.0) * lightCol * mask;\n            break;\n        }          \n    }\n    \n    return col;\n}\n//--------------------------------------------------------\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec2 RandV2(float radius)\n{\n    float r1 = 2.0 * PI * Rand();\n    float r2 = Rand();\n    return vec2(r2 * cos(r1), r2 * sin(r1)) * radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;    \n\tvec4 zeroUVCol = texture(iChannel0, vec2(0.5,0.5) / iResolution.xy);\n    if(fragCoord.xy == vec2(0.5))\n    {\n        fragColor = vec4(mouse, (length(mouse - zeroUVCol.xy) > 0.001 || iFrame == 0) ? float(iFrame) : zeroUVCol.z, 1.0);\n        return;\n    }\n    \n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qAA = (fragCoord.xy + RandV2(1.0)) / iResolution.xy;\n    vec2 p = qAA * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n    \n    vec3 camPos = vec3(7.0 * cos(7.0 * mouse.x), 5.0 - 4.0 * mouse.y, 7.0 * sin(7.0 * mouse.x));\n    vec3 camLookAt = vec3(0.0, 1.0, 0.0);    \n    mat3 camMatrix = SetCamera(camPos, camLookAt, 0.0);\n    vec3 rayDir = normalize(camMatrix * vec3(p.xy, 1.5));\n    \n    //---dof---\n    Ray ray;\n    ray.ori = camPos + (camMatrix * vec3(RandV2(DOFRADIUS), 0.0));\n    ray.dir = normalize(camPos + rayDir * DOFDISTANCE - ray.ori);\n    \n    vec3 col = Render(ray);    \n    float weight = max(1.0 / (float(iFrame) - zeroUVCol.z + 1.0), 0.0001);\n    vec3 lastCol = texture(iChannel0, q).rgb;        \n    fragColor = vec4(mix(lastCol, col, weight), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}