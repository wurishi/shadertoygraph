{"ver":"0.1","info":{"id":"3ldyRM","date":"1610294716","viewed":224,"name":"Ray Tracing Attempt 2","username":"m1ke","description":"Second attempt at ray tracing\n\nUPDATES\n-----------\n10/01/2021: added skybox reflection","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["rtx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//VARS\nconst vec4 LightInformation = vec4(0,1,1,1);\nconst int BounceLimit = 10;\nconst vec3 CameraPosition = vec3(0,0,0);\n\nstruct Ray \n{\n  vec3 origin;\n  vec3 direction;\n};\nRay newRay(vec3 origin, vec3 direction)\n{\n  Ray ray;\n  ray.origin = origin;\n  ray.direction = direction;\n  return ray;\n}\nstruct Hit \n{\n  float distance;\n  vec3 point;\n  vec3 normal;\n  vec3 colour;\n  float specularity;\n};\nHit newHit()\n{\n  Hit hit;\n  hit.distance = 100.0f;\n  hit.point = vec3(0.0f,0.0f,0.0f);\n  hit.normal = vec3(0.0f,0.0f,0.0f);\n  hit.colour = vec3(0.0f,0.0f,0.0f);\n  hit.specularity = 0.0f;\n  return hit;\n}\nRay CameraRay(vec2 uvCoord)\n{\n    vec3 origin = CameraPosition; //cameras position\n    vec3 direction = normalize(vec3(uvCoord.x, uvCoord.y, -1.0));\n    \n    float rotX = (0.5f) * 3.14;\n    float rotY = (0.5f) * 3.14;\n    vec2 uv = 2.5 * (uvCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n    vec3 camO = vec3(cos(rotX), cos(rotY), sin(rotX));\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD, vec3(0, 1, 0)));\n    vec3 camU = cross(camR,camD);\n    \n    direction = normalize(uv.x * camR + uv.y * camU + camD);;\n    \n    return newRay(origin, direction);\n}\nstruct Sphere\n{\n  vec3 position;\n  float radius;\n  vec3 colour;\n  float specularity;\n};\nSphere newSphere(vec3 position, float radius, vec3 colour, float sp)\n{\n  Sphere s;\n  s.position = position;\n  s.radius = radius;\n  s.colour = colour;\n  s.specularity = sp;\n  return s;\n}\nvoid IntersectSphere(Ray ray, inout Hit hit, Sphere sphere)\n{\n  vec3 d = ray.origin - sphere.position;\n  float p1 = -dot(ray.direction, d);\n  float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;\n  if (p2sqr < 0.0f)\n  {\n    return;\n  }\n  float p2 = sqrt(p2sqr);\n  float t = p1 - p2 > 0.0f ? p1 - p2 : p1 + p2;\n  if (t > 0.0f && t < hit.distance)\n  {\n      hit.distance = t;\n      hit.point = ray.origin + t * ray.direction;\n      hit.normal = normalize(hit.point - sphere.position);\n      hit.colour = sphere.colour;\n      hit.specularity = sphere.specularity;\n  }\n}\nHit IntersectRay(Ray ray)\n{\n  Sphere tempSphere = newSphere(vec3(0,sin(iTime),-5), 2.0f, vec3(0.0f,0.0f,0.0f), 1.0f);\n  //Sphere tempSphere2 = newSphere(vec3(2.5f,0,-5), 1.0f, vec3(0.0f,0.0f,0.0f), 1.0f);\n  //Sphere tempSphere3 = newSphere(vec3(-2.5f,0,-5), 1.0f, vec3(0.0f,0.0f,0.0f), 1.0f);\n  //Sphere tempSphere4 = newSphere(vec3(0.0f,sin(iTime)*0.5f,-1.0f), 0.25f, vec3(0.0f,0.0f,0.0f), 1.0f);\n\n\n\n  Hit hit = newHit();\n  IntersectSphere(ray, hit,tempSphere);\n  //IntersectSphere(ray, hit,tempSphere2);\n  //IntersectSphere(ray, hit,tempSphere3);\n  //IntersectSphere(ray, hit,tempSphere4);\n  return hit;\n}\nvec3 SampleSkybox(vec3 dir)\n{\n    return vec3(texture(iChannel0, dir));\n}\nRay ReflectRay(Ray r, Hit h)\n{\n    vec3 p = h.point+h.normal*0.001f;\n    vec3 d = reflect(r.direction, h.normal)-r.origin;\n    return newRay(p, d);\n}\nvec3 IlluminateRay(Hit hit, Ray r)\n{\n  if (hit.distance != 100.0f)\n  {\n    Ray shadowRay = newRay(hit.point + hit.normal * 0.001f, -1.0f * LightInformation.xyz);\n    Hit shadowHit = IntersectRay(shadowRay);\n    if (shadowHit.distance != 100.0f)\n    {\n      //ray hit illuminated object\n      float brightness = dot(hit.normal, LightInformation.xyz) * LightInformation.w;\n      \n      Ray reflectRay = ReflectRay(r, hit);\n      Hit lastHit = hit;\n      \n      \n      vec3 col = vec3(0);\n      \n      for (int i = 0; i < BounceLimit; i++)\n      {\n          Hit reflectHit = IntersectRay(reflectRay);\n          if (reflectHit.distance != 100.0f)\n          {\n              //hit again\n              col = mix(lastHit.colour, reflectHit.colour, lastHit.specularity);\n              reflectRay = ReflectRay(reflectRay, reflectHit);\n              lastHit = reflectHit;\n          }\n          else\n          {\n              //shoots off\n              col = mix(lastHit.colour, SampleSkybox(reflectRay.direction),lastHit.specularity) ;\n          }\n      }\n      \n      return col * brightness;\n    }\n    else\n    {\n      //in shadow\n      return vec3(0,0,0);\n    }\n  }\n  else\n  {\n    //ray missed\n    return SampleSkybox(r.direction);\n  }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    Ray ray = CameraRay(fragCoord);\n    Hit hit = IntersectRay(ray);\n    vec3 colour = IlluminateRay(hit, ray);\n    \n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}