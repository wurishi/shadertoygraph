{"ver":"0.1","info":{"id":"WdlyWX","date":"1585880026","viewed":106,"name":"SimpleSDF","username":"zchajax","description":"sdf + raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SC (250.0)\n\n//------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p)\n{\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(in vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdTorus(in vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 sceneSDF(in vec3 p)\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    res = opU(res, vec2(sdPlane(p), 1.));\n    res = opU(res, vec2(sdSphere(p - vec3(-0.5, .2, 0.), .2), 2.));\n    res = opU(res, vec2(sdBox(p - vec3(.3, .2, 0.), vec3(.2, .2, .2)), 3.));\n    res = opU(res, vec2(sdTorus(p - vec3(.2, .09, -.7), vec2(.2, .08)), 4.));\n   \n    return res;\n}\n\nfloat checkers( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x + q.y, 2.);\n}\n\nvec3 normal(in vec3 p)\n{\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          sceneSDF(p + epsilon.xyy).x - sceneSDF(p - epsilon.xyy).x,\n          sceneSDF(p + epsilon.yxy).x - sceneSDF(p - epsilon.yxy).x,\n          sceneSDF(p + epsilon.yyx).x - sceneSDF(p - epsilon.yyx).x);\n    return normalize(n);\n}\n\nvec2 rayMarching(in vec3 ro, in vec3 rd, float tmin, float tmax)\n{\n    vec2 res = vec2(-1.0,-1.0);\n    float t = tmin;\n    for (int i = 0; i < 1000; i++)\n    {\n        vec2 h = sceneSDF(ro + rd * t);\n        if (h.x < .002 || h.x > tmax)\n        {\n            res = vec2(t, h.y);\n            break;\n        }\n        t += h.x;\n    }\n    res.x = t;\n    \n    return res;\n}\n\n// Distance Field Soft Shadow\nfloat shadow(in vec3 p, in vec3 rd)\n{\n    float hit = 1.;\n    float t = .02;\n    \n    for (int i = 0; i < 20; i++) \n    {\n        vec2 h = sceneSDF(p + rd * t);\n        if (h.x < .001) return 0.;\n        t += h.x;\n        hit = min(hit, 10. * h.x / t);\n    }\n\n    // return clamp(hit, 0., 1.);\n    return smoothstep(0., 1., hit);\n}\n\nvec3 albedo(in vec3 p , in vec2 res)\n{\n    vec3 albedo;\n    \n    if (res.y == 1.)\n        // checker\n        albedo = .4 + vec3(.6) * checkers(p.xz * 3.);\n    else if (res.y == 2.) \n        albedo = vec3(0., .5, 0.);\n    else if (res.y == 3.)\n        albedo = vec3(0., .5, .5);\n    else \n        albedo = vec3(.5, 0., 0.);\n    return albedo;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, out float t)\n{\n    float tmin = .02;\n    float tmax = 20.;\n    \n    vec2 res = rayMarching(ro, rd, tmin, tmax);\n    \n    t = res.x;\n    \n    vec3 p = ro + rd * t;\n    \n    vec3 col;\n    \n    vec3 lightDir = normalize(vec3(0.6, 0.7, -0.7));\n    \n    if (t > tmax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n\t\t\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 v = -normalize(rd);\n        vec3 n = normal(p);\n\t\tvec3 l = lightDir;\n        vec3 r = normalize(reflect(-l, n));\n        \n        vec3 albedo = albedo(p, res);\n        \n        vec3 diff = max(dot(l, n), 0.) * albedo;\n        \n        float spec = max(dot(r, normalize(v)), 0.);\n        spec = pow(spec, 100.);\n        spec = clamp(spec, 0., 1.);\n        \n        float shadow = shadow(p, l);\n        \n        col = vec3(diff + spec) * shadow;\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC, 2.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    return col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    vec3 camPos = vec3(0., 0.8, 0.);\n    vec3 camTarget = vec3(0.);\n    \n    camPos.x += 1.8 * cos(iTime * 0.1 + mo.x * 3.);\n    camPos.y += mo.y;\n   \tcamPos.z += 1.8 * sin(iTime * 0.1 + mo.x * 3.);\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n    float t;\n    vec3 col = render(ro, rd, t);\n    \n    // Gama\n   \tcol = pow(clamp(col, 0., 1.), vec3(0.45));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}