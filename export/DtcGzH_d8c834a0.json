{"ver":"0.1","info":{"id":"DtcGzH","date":"1681917132","viewed":70,"name":"Triangle Frustum culling","username":"WilstonOreo","description":"There was no triangle frustum intersection test, so I decided to write one on my own, based on https://www.shadertoy.com/view/wlsfRs ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["intersection","frustum","culling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS .000002\n\n#define AA 4\n\n// uncomment this to enable backface culling\n//#define CULL_BACKFACE\n\nconst vec3 cameraPosition = vec3(0., 2., 12.);\n\nstruct Ray\n{\n\tvec3 origin, direction;  \n};\n\nstruct Frustum\n{\n    Ray a,b,c,d;\n};\n\nconst int frustumSize = 16;\n\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * uvec2(1597334673U, 3812015801U);\n\tn = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n\treturn vec2(n) * (1. / float(0xffffffffU));\n}\n\nmat3 getCameraMatrix(vec3 origin, vec3 target)\n{\n    vec3 lookAt = normalize(target - origin);\n    vec3 right = normalize(cross(lookAt, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, lookAt));\n    return mat3(right, up, lookAt);\n}\n\nRay getCameraRay(vec2 uv)\n{\n    vec3 origin = cameraPosition;\n    vec3 target = vec3(0., 1., 0.);\n    mat3 camera = getCameraMatrix(origin, target);\n    vec3 direction = camera * vec3(uv, 2.);\n    return Ray(origin, direction);\n}\n\nRay getFrustumRay(ivec2 screenCoord) {\n    return getCameraRay((2.0 * vec2(ivec2(screenCoord) / ivec2(frustumSize) * ivec2(frustumSize) )  - iResolution.xy )/ iResolution.y );\n}\n\n/**\nTomas MÃ¶ller & Ben Trumbore (1997) Fast, Minimum Storage Ray-Triangle Intersection,\nJournal of Graphics Tools\nhttps://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\n*/\nvec4 rayTriangleIntersect(Ray ray, vec3 A, vec3 B, vec3 C)\n{\n\tvec4 result = vec4(-1.);\n    vec3 e1 = B - A; vec3 e2 = C - A;\n    vec3 dxe2 = cross(ray.direction, e2);\n    float det = dot(dxe2, e1);\n    // ray parallel to triangle plane\n\tif (abs(det) < EPS\n#ifdef CULL_BACKFACE\n\t// triangle facing away from camera (with vertices wound counter-clockwise)\n\t|| det < EPS\n#endif\n\t) return result;\n    float invDet = 1. / det;\n    vec3 t = ray.origin - A;\n    float u = dot(dxe2, t) * invDet;\n    vec3 txe1 = cross(t, e1);\n    float v = dot(txe1, ray.direction) * invDet;\n    \n    float d = dot(txe1, e2) * invDet;\n\n    // For simple ray-intersection, we could early exit here, however for frustum culling we need the exact distance values\n    //if (u < 0. || v < 0. || u + v > 1.) return vec3(d, u,v);\n    \n    return vec4(d, u, v, det);\n}\n\n\nfloat frustumTriangleCulling(Frustum f, vec3 A, vec3 B, vec3 C) {\n\n    vec4 a = rayTriangleIntersect(f.a, A, B, C);\n    vec4 b = rayTriangleIntersect(f.b, A, B, C);\n    vec4 c = rayTriangleIntersect(f.c, A, B, C);\n    vec4 d = rayTriangleIntersect(f.d, A, B, C);\n    \n   if (a.y < 0.0 && b.y < 0.0 && c.y < 0.0 && d.y < 0.0)\n       return -1.0;\n   \n   if (a.z < 0.0 && b.z < 0.0 && c.z < 0.0 && d.z < 0.0)\n       return -1.0;  \n        \n   a.y += a.z;\n   b.y += b.z;\n   c.y += c.z;\n   d.y += d.z;\n        \n   if ((a.y > 1.0) && (b.y  > 1.0) && (c.y > 1.0) && (d.y > 1.0))\n       return -1.0;\n \n   float mindist = min(min(a.x, b.x), min(c.x, d.x));\n   if ((a.x > 0.0 && a.w >0.0) || (b.x > 0.0 && b.w > 0.0) || (c.x > 0.0 && c.w > 0.0) || (d.x > 0.0 && d.w >0.0))\n       \n       return 1.0;\n   \n   return mindist > 0.0 ? 1.0 : -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0.);\n    int aaSamples = AA * AA;\n    \n    Frustum f;\n    ivec2 screenCoord = ivec2(fragCoord);\n    \n    f.a = getFrustumRay(screenCoord);\n    f.b = getFrustumRay(screenCoord + ivec2(frustumSize, 0.0));\n    f.c = getFrustumRay(screenCoord + ivec2(0.0, frustumSize));\n    f.d = getFrustumRay(screenCoord + ivec2(frustumSize));\n    \n    float t = iTime * .25;\n\n    vec3 A = vec3(0., -4. * sin(t), -2. * cos(t));\n    vec3 B = vec3(4. * cos(t), 4. * sin(t), -2.);\n    vec3 C = vec3(-3. * cos(t), 1., 4. * sin(t));\n\n    if (frustumTriangleCulling(f, A, B, C) > 0.0) {\n        for (int i = 0; i < aaSamples; ++i)\n        {\n            // Find x & y subpixel jitter locations\n            float x = mod(float(i), float(AA));\n            float y = mod(float(i / AA), float(AA));\n        \n            // Subpixel jitter\n            vec2 jitter = (hash21(uint(i)) + vec2(x, y)) / float(AA);\n            \n            vec2 uv = (2. * (fragCoord + jitter) - iResolution.xy) / iResolution.y;\n        \n            Ray ray = getCameraRay(uv);\n        \n        \n            vec4 tri = rayTriangleIntersect(ray, A, B, C); \n        \n            // Color the triangle using barycentric weights\n        \n            if (tri.y < 0.) {\n                col += vec3(1,1,0);\n            } else if (tri.z < 0.) {\n                col += vec3(0,1,1);\n            } else if (tri.y + tri.z > 1.) {\n                col += vec3(1,0,1);\n            } else\n            if (tri.x > 0.) {\n                col += vec3(tri.yz, 1. - tri.y - tri.z);\n            } \n        }\n    } else {\n        // Draw grid\n        if (screenCoord.x % frustumSize == 0 || screenCoord.y % frustumSize == 0) \n            col += vec3(0.15,0.15,0.15) * float(aaSamples);\n\n    }\n\n    \n    fragColor = vec4(col/float(aaSamples), 1.);\n}","name":"Image","description":"","type":"image"}]}