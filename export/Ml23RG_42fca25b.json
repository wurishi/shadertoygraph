{"ver":"0.1","info":{"id":"Ml23RG","date":"1430089258","viewed":762,"name":"Rainbow Panorama Sponge","username":"jnorberg","description":"falling through an infinite number of rainbow colored menger sponges","likes":20,"published":1,"flags":8,"usePreview":0,"tags":["mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2015-04-26 jnorberg\n// I wanted to test out panoramic projection\n\n// menger sponge \"inspired\" by FMS_Cat 20141207 Menger Sponge\n// AO from iq's Raymarching - Primitives\n\n\nfloat box(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat bar(vec2 p,vec2 b)\n{\n    vec2 d=abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat crossBar(vec3 p,float b)\n{\n    float\n        da=bar(p.xy,vec2(b)),\n        db=bar(p.yz,vec2(b)),\n        dc=bar(p.zx,vec2(b));\n    \n    return min(da,min(db,dc));\n}\n\nfloat distFunc(vec3 p)\n{\n    // repeating space\n    p.x = mod( p.x+0.4, 0.8 ) - 0.4; \n    p.y = mod( p.y+0.4, 0.8 ) - 0.4; \n    p.z = mod( p.z+0.4, 0.8 ) - 0.4; \n\n    float ret=box(p,vec3(0.3));\n\n    for( float c = 0.0 ; c < 4.0 ; c += 1.0)\n    {\n        float pw=pow(3.0,c);\n        ret=max(ret,-crossBar(mod(p+.15/pw,.6/pw)-.15/pw,.1/pw));\n    }\n    return ret;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat d=1E-3;\n\treturn normalize(vec3(\n\t\tdistFunc(p+vec3(d,0.,0.))-distFunc(p+vec3(-d,0.,0.)),\n\t\tdistFunc(p+vec3(0.,d,0.))-distFunc(p+vec3(0.,-d,0.)),\n\t\tdistFunc(p+vec3(0.,0.,d))-distFunc(p+vec3(0.,0.,-d))\n\t));\n}\n\nfloat getAO( vec3 pos, vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<3; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = distFunc( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //return;\n    \n\tvec2 pix=( fragCoord.xy*2.0 - iResolution.xy) / iResolution.x;\n\t\n    vec3 camP=vec3(\n        0.05 * sin(iTime*0.2 ),\n        0.05 * sin(iTime*0.15 ),\n        0.1*iTime\n    );\n\n\tvec3 camC= camP + vec3(\n        0.3 * sin(iTime*0.05),\n        0.3 * sin(iTime*0.06),\n        1.);\n\n    vec3 camA=vec3(0.3*sin(iTime*0.03),0.8,0.);\n\tvec3 camS=cross(normalize(camC-camP),camA);\n\tvec3 camU=cross(camS,normalize(camC-camP));\n    \n    vec3 camF = normalize(camC-camP );\n\n    // panoramic projection by aiming rays using angles\n    vec3 ray=normalize(\n        camS*sin(pix.x*3.5) + camF*cos(pix.x*3.5) +\n        camU*pix.y*3.14\n    );\n    \n\tfloat dist=0.;\n\tfloat rayL=0.;\n\tvec3 rayP=camP;\n    \n    for(int i=0;i<32;i++){\n        dist=distFunc(rayP);\n        rayL+=dist;\n        rayP=camP+ray*rayL;\n    }\n\t\n    vec3 nor=getNormal(rayP);\n\n    // lame point light at camera\n    float lum=0.5-dot(ray,nor);\n    lum *= 1.0/(rayL*4.0 + 1.0);\n    lum *= getAO( rayP, nor );\n        \n    // phase\n    float p = 3.0*rayP.x + 3.0*rayP.y + 3.0*rayP.z;\n        \n    // rainbow\n    float r = 0.6 + 0.4 * sin( p );\n    float g = 0.6 + 0.4 * sin( p + 1.03);\n    float b = 0.6 + 0.4 * sin( p + 2.07 );\n        \n    // brighten color\n    float m = max(r, max(g,b));\n    vec3 colHi = vec3(r,g,b) / m;\n        \n    // darken (but saturated) color\n    float lo = min(colHi.r, max(colHi.g,colHi.b));\n    vec3 colLo = colHi - vec3(lo);\n    \n    // final color\n    fragColor=vec4(mix(colLo,colHi,lum),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"// 2015-04-26 jnorberg\n// simplest \"music\" I could come up with\n\nfloat env( float t ) { return t / ( 0.1 + 15.0 * t*t ); }\n\n\nfloat pi = 3.14159265359;\nfloat tau = 2.0 * 3.14159265359;\n\nfloat note( float n ) { return 440.0 * pow( 2.0, ( n-49.0) / 12.0 ); }\n\nfloat bass( float time, float f, float c )\n{\n    float wf = mix(0.1,111.0, c );\n    float w0 = 0.25 + floor( wf ); // bandwidth (has to be integer) creates a \n    float w1 = w0 + 1.0;\n    float wfrac = fract( wf );\n    \n    float p = mod( time*f, tau );\n    float saw = 1.0 - p / pi; // saw full aliasing \n    \n    // sinc-like features ahoy\n    float s = 0.6; // \"strength\" basically fake \"q\", try lowering for extra crunch\n    float i = tau - p; // i \"inverted p\"\n    float d0 = 1.0 / (1.0 + s * p );\n    float d1 = 1.0 / (1.0 + s * i );\n\n    float sinc_0 = -cos(p*w0) * d0 + cos(i*w0) * d1;\n    float sinc_1 = -cos(p*w1) * d0 + cos(i*w1) * d1;\n\n    return saw + mix( sinc_0, sinc_1, wfrac );\n}\n\n\nvec2 mainSound( in int samp,float time)\n{\n    float t = time;\n    float i2 = floor( fract( t / 4.0) * 2.0 );\n    float i4 = floor( fract( t / 8.0) * 2.0 );\n    \n    // three envelopes\n    float e0 = env( fract( 0.5*t) );\n    float e1 = env( fract( 0.5*t+0.33) );\n    float e2 = env( fract( 0.5*t+0.66) );\n    \n    float f = 6.2831*110.0 + 20.0*sin(t*0.15); // old recording :)\n    float f0 = f * 2.0;\n    float f1 = f0 * 3.0/2.0;\n    float f2 = f0 * 5.0/4.0;\n\n    // re-tune\n    f0 *= mix(1.0, 0.5, i2 ) * mix(1.0, 2.0, i4 );\n    f1 *= mix(1.0, 1.12246204831, i4 );\n    f2 *= mix(1.0, 1.05946309436, i4 );\n    \n    // mix\n    float v =\n        0.3 * bass( fract(0.125 * t) * 2.0, f, 0.1 + 0.06 * sin( 0.125*t*pi) ) +\n        sin( (0.9 + e0 * 5.0 )*sin(f0*t)) * e0 +\n        sin( (0.9 + e1 * 4.0 )*sin(f1*t)) * e1 +\n        sin( (0.9 + e2 * 3.0 )*sin(f2*t)) * e2;\n\n    return vec2( v * 0.3 );\n}\n","name":"Sound","description":"","type":"sound"}]}