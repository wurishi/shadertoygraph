{"ver":"0.1","info":{"id":"dtj3Rw","date":"1673051250","viewed":49,"name":"CrystalBallTelo","username":"StormCreeper","description":"Simple cloud sim in a ball","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"dlBGRh","parentname":"Nuage rend 01"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 40.\n#define STEPS2 20.\n#define SHOOT_DISTANCE 4.\n\n#define rotY iMouse.x / iResolution.x * 6.3 \n#define rotX iMouse.y / iResolution.y * 2. - 1.\n\nvec3 lightDir = normalize(vec3(1, 1, 1));\nvec3 lightPos = vec3(0.2);\nvec3 lightColor = vec3(1., 0.3, 0.3);\n\nint numLights = 3;\n\nvec3 lightPoss[3] = vec3[](vec3(0.), vec3(0.), vec3(0.));\nvec3 lightColors[3] = vec3[](vec3(1., 0.3, 0.3), vec3(0.3, 1.0, 0.3), vec3(0.3, 0.4, 1.0));\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nvec3 mix3(vec3 a, vec3 b, vec3 c) {\n    return vec3(\n        mix(a.x, b.x, c.x),\n        mix(a.y, b.y, c.y),\n        mix(a.z, b.z, c.z)\n    );\n}\n\nvec3 pow3(vec3 a, float p) {\n    return vec3(\n        pow(a.x, p),\n        pow(a.y, p),\n        pow(a.z, p)\n    );\n}\n\nvoid initLights() {\n    float freq = .04;\n    lightPoss[0] = texture(iChannel0, vec3(iTime * freq, .5, .5)).xyz * 2. - 1.;\n    lightPoss[1] = texture(iChannel0, vec3(iTime * freq, .2, .8)).xyz * 2. - 1.;\n    lightPoss[2] = texture(iChannel0, vec3(iTime * freq, .3, .2)).xyz * 2. - 1.;\n}\n\nfloat fallof(float d) {\n    return pow(1.-d*d, 0.05);\n}\n\nfloat density(vec3 pos) {\n    float dens = 0.;\n    \n    float freq = 0.1;\n    float amp = 1.;\n    \n    //return pow(fallof(length(pos)), 10.);\n    \n    for(int i = 0; i<5; i++) {\n        dens += texture(iChannel0, pos * freq + vec3(iTime * 0.05)).y * amp;\n        freq *= 2.;\n        amp /= 2.;\n    }\n    \n    //dens = fallof(length(pos));\n    \n    return pow(max(min(dens*0.99, 1.), 0.00) * fallof(length(pos)), 10.);\n}\n\nvec3 so = vec3(0);\nfloat sr = 1.;\n\nbool raySphereIntersection(vec3 ro, vec3 rd, out float do1, out float do2) {\n    vec3 offset = ro - so;\n    float a = 1.0;\n    float b = 2.0 * dot(offset, rd);\n    float c = dot(offset, offset) - sr * sr;\n    float d = b*b - 4.0 * a * c;\n    \n    do1 = -1.;\n    do2 = -1.;\n    \n    if(d > 0.0) {\n        float d1 = (-b - sqrt(d)) / (2.0 * a);\n        float d2 = (-b + sqrt(d)) / (2.0 * a);\n        \n        do1 = min(d1, d2);\n        do2 = max(d1, d2);\n        \n        return true;\n    }\n    return false;\n}\n\nfloat mieScattering(vec3 dir, vec3 ldir) {\n    float cost = dot(dir, ldir);\n    float i0 = 0.7;\n    \n    return i0*(1. + cost*cost);\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90) {\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2) {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            if (sinT2 > 1.0)\n                return f90;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        return mix(f0, f90, ret);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    initLights();\n    \n    mat4 rotView = rotationX(rotX) * rotationY(rotY);\n    \n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    vec3 origin = (vec4(0, 0, -2.1, 0) * rotView).xyz;\n    \n     vec3 dir = (vec4(normalize(vec3(uv.x, uv.y, 0.9)), 0) * rotView).xyz;\n    \n    vec3 color = vec3(1);\n    \n    float do1, do2;\n    \n    float dOffset = 0.;\n    if(raySphereIntersection(origin, dir, do1, do2)) {\n        do1 = max(0., do1);\n    \n        float troughput = 1.;\n        vec3 light = vec3(0.);\n\n        for(float i = 0.; i<STEPS; i++) {\n            float dist = do1 + (i / STEPS) * (do2-do1);\n            vec3 pos = origin + dir * dist;\n            if(length(pos) < 1.) {\n                float dens = density(pos);\n\n                float dt1, dt2;\n                raySphereIntersection(pos, lightDir, dt1, dt2);\n\n                vec3 lightThrough = vec3(1);\n\n\n                if(dens > 0.05) {\n\n                    for(float j = 0.; j<STEPS2; j++) {\n                        float dist2 = j / STEPS2 * dt2;\n                        vec3 pos2 = pos + lightDir * dist2;\n                        float dens2 = density(pos2);\n                        lightThrough *= exp(-dens2 * 0.2);\n                    }\n                }\n                float lastTroughput = troughput;\n                troughput *= exp(-dens * 0.5);\n\n                light += vec3(0.5, 0.4, 1.0) * (lastTroughput - troughput) * lightThrough * exp(-dens * 0.01);// * mieScattering(dir, lightDir);\n\n                // point light\n\n                for(int k = 0; k<numLights; k++) {\n\n                    vec3 pldir = normalize(lightPoss[k] - pos);\n                    float pldist = length(lightPoss[k] - pos);\n\n                    float att = 3.;\n\n                    light += 2. * (lastTroughput - troughput) * lightColors[k] * exp(-pldist * att);// * mieScattering(dir, pldir);\n                }\n            }\n        }\n\n        vec3 skyColor = texture(iChannel1, dir).xyz;\n        vec3 ponSphere = origin + dir * do1;\n        color = mix(vec3(light), skyColor, troughput);\n        color = mix(color, vec3(0.7, 0.2, 0.7), 1. - exp(-(do2-do1) * 0.1));\n        color = mix(color, mix(texture(iChannel1, reflect(dir, normalize(ponSphere))).xyz, vec3(0.7, 0.2, 0.7), 0.5), FresnelReflectAmount(1., 1.5, normalize(ponSphere), dir, 0.1, 1.)*0.7);\n    } else {\n        vec3 skyColor = texture(iChannel1, dir).xyz;\n        color = skyColor;\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}