{"ver":"0.1","info":{"id":"MclSDl","date":"1707732516","viewed":29,"name":"[inspirnathan] 11 - FresnelRimLi","username":"hrst4","description":"[inspirnathan] 11 - FresnelRimLi","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n//from https://inspirnathan.com/posts/58-shadertoy-tutorial-part-12\n#define PART 2\n/*\nBonjour, chers amis ! Bienvenue à la douzième partie de ma série de tutoriels Shadertoy.\nDans ce tutoriel, nous allons apprendre à ajouter un éclairage périphérique \nautour d'une sphère en utilisant la réflexion de Fresnel.\n\n# Configuration initiale\n\nNous allons commencer avec un modèle de marche de rayons basique.\n*/\n#if PART == 0\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  vec3 offset = vec3(0, 0, -2);\n  return length(p - offset) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1);\n  vec3 col = vec3(0);\n\n  vec3 ro = vec3(0, 0, 3);\n  vec3 rd = normalize(vec3(uv, -1));\n\n  float d = rayMarch(ro, rd);\n  \n  if (d > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n    vec3 p = ro + rd * d;\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(4, 4, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float diffuse = clamp(dot(normal, lightDirection), 0., 1.);\n    vec3 diffuseColor = vec3(0, 0.6, 1);\n\n    col = diffuse * diffuseColor;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nLorsque vous exécutez ce code, vous devriez voir une sphère bleue avec seulement \nune réflexion diffuse (lambertienne).\nhttps://inspirnathan.com/_nuxt/img/img-1.32001be.png\n\n# Réflexion de Fresnel\n\nLes équations de Fresnel décrivent la réflexion et la transmission de la lumière lorsqu'elle\nest incidente sur une interface entre deux milieux optiques différents. \n\nEn termes plus simples, cela signifie que les objets peuvent être éclairés de manière légèrement\ndifférente lorsque vous les regardez sous des angles rasants.\n\nLe terme \"support optique\" fait référence au type de matériau à travers lequel la lumière passe.\nLes différents matériaux ont tendance à avoir des indices de réfraction différents,\nce qui donne l'impression que la lumière est courbée.\n\nhttps://inspirnathan.com/_nuxt/img/img-2.3f62fd3.png\n\nL'air est un type de milieu. Son indice de réfraction est généralement d'environ 1,000293.\nLes matériaux tels que le diamant ont un indice de réfraction élevé.\nL'indice de réfraction du diamant est de 2,417.\nUn indice de réfraction élevé signifie que la lumière semble se courber encore plus.\n\nLes équations de Fresnel peuvent être très compliquées.\nPour les images de synthèse, on utilise généralement l'approximation de Schlick pour évaluer\nla contribution de Fresnel à la réflexion.\n\nhttps://inspirnathan.com/_nuxt/img/img-3.8c1eaf9.png\n\nL'équation ci-dessus calcule la contribution de Fresnel à la réflexion,\nR où R0 est le coefficient de réflexion pour la lumière entrant parallèlement à la normale\n(typiquement lorsque θ est égal à zéro).\n\nLa valeur de cos θ est égale au produit de points entre la normale de la surface et la direction\nd'où provient la lumière incidente. Dans notre code, cependant, nous utiliserons la direction du rayon, rd.\n\nPour les besoins de nos exemples, nous supposerons que l'indice de réfraction de l'air\net de la sphère sont tous deux égaux à un. Cela simplifiera nos calculs. \nCela signifie que R0 est égal à zéro.\n\nn1 = 1\nn2 = 1\n\nR0 = ((n1 - n2)/(n1 + n2)) ^ 2\nR0 = ((1 - 1)/(1 + 1)) ^ 2\nR0 = 0\n\nAvec R0 égal à zéro, nous pouvons encore simplifier l'équation de réflexion de Fresnel.\n\nR = R0 + (1 - R0)(1 - cosθ)^5\n\nSince R0 = 0,\nR = (1 - cosθ)^5\n\n\nDans le code GLSL, cela peut s'écrire comme suit :\n\nfloat fresnel = pow(1. - dot(normal, -rd), 5.);\n\nCependant, nous bloquons les valeurs pour nous assurer que la fourchette se situe entre zéro et un. \nNous utilisons également -rd. Si vous utilisez un rd positif, vous ne verrez peut-être pas que \nla couleur n'est appliquée qu'au bord de la sphère.\n\nfloat fresnel = pow(clamp(1. - dot(normal, -rd), 0., 1.), 5.);\n\n\nNous pouvons multiplier cette valeur de Fresnel par une valeur de couleur, \nafin d'appliquer un bord coloré autour de notre sphère bleue. Voici le code terminé :\n\n*/\n\n#elif PART == 1\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  vec3 offset = vec3(0, 0, -2);\n  return length(p - offset) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1);\n  vec3 col = vec3(0);\n\n  vec3 ro = vec3(0, 0, 3);\n  vec3 rd = normalize(vec3(uv, -1));\n\n  float d = rayMarch(ro, rd);\n  \n  if (d > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n    vec3 p = ro + rd * d;\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(4, 4, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float diffuse = clamp(dot(normal, lightDirection), 0., 1.);\n    vec3 diffuseColor = vec3(0, 0.6, 1);\n\n    float fresnel = pow(clamp(1. - dot(normal, -rd), 0., 1.), 5.);\n    vec3 rimColor = vec3(1, 1, 1);\n\n    col = diffuse * diffuseColor + fresnel * rimColor; // add the fresnel contribution\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nSi vous exécutez ce code, vous devriez voir un mince bord blanc autour de notre sphère bleue.\nCela simule l'effet de la lumière frappant un angle rasant de notre sphère.\nhttps://inspirnathan.com/_nuxt/img/img-4.6ac6d90.png\n\nVous pouvez jouer avec l'exposant et la couleur du bord pour obtenir un effet de type \"champ de force\".\n\nfloat fresnel = pow(clamp(1. - dot(normal, -rd), 0., 1.), 0.5);\nvec3 rimColor = vec3(1, 0, 1);\n\ncol = diffuse * diffuseColor + fresnel * rimColor;\n\n\n*/\n\n#elif PART == 2\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nfloat sdSphere(vec3 p, float r )\n{\n  vec3 offset = vec3(0, 0, -2);\n  return length(p - offset) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1);\n  vec3 col = vec3(0);\n\n  vec3 ro = vec3(0, 0, 3);\n  vec3 rd = normalize(vec3(uv, -1));\n\n  float d = rayMarch(ro, rd);\n  \n  if (d > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n    vec3 p = ro + rd * d;\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(4, 4, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float diffuse = clamp(dot(normal, lightDirection), 0., 1.);\n    vec3 diffuseColor = vec3(0, 0.6, 1);\n\n    float fresnel = pow(clamp(1. - dot(normal, -rd), 0., 1.), 0.5);\n    vec3 rimColor = vec3(1, 0, 1);\n\n    col = diffuse * diffuseColor + fresnel * rimColor;\n\n    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\n# Conclusion\n\nDans cet article, nous avons appris à ajouter un éclairage périphérique autour des objets \nen appliquant la réflexion de Fresnel. \n\nSi vous avez affaire à des objets qui imitent le verre ou le plastique, \nl'ajout de la réflexion de Fresnel peut contribuer à les rendre un peu plus réalistes.\n\n*/\n#endif\n","name":"Image","description":"","type":"image"}]}