{"ver":"0.1","info":{"id":"tttcDs","date":"1610283387","viewed":177,"name":"Ray Tracing in One Weekend 2","username":"Davigo","description":"I tried to translate the c++ code of the book into glsl and that's the result. It is better to pause the execution so as not to overload the computer.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float MAXFLOAT = 1000.;\nfloat DEPTH = 10.;\nfloat PI = 3.14159265359;\n\n//Lambertian class\nstruct lambertian {\n    vec3 albedo;\n};\n\n//Metal class\nstruct metal {\n    vec3 albedo;\n    float fuzz;\n};\n\n//Dielectric class\nstruct dielectric {\n    float ref_idx;\n};\n\n//Material class\nstruct material {\n    lambertian l;\n    metal m;\n    dielectric d;\n    float num_m;    \n};\n\n//Ray class\nstruct ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n//Sphere class\nstruct sphere {\n    vec3 center;\n    float radius;\n    material mat;\n};\n\n//Hitable list class\nstruct hitable_list {\n    sphere list[8];\n    int list_size;\n};\n\n//Camera class\nstruct camera {\n    vec3 origin;\n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lens_radius;\n};\n\nstruct hit_record {\n    float t;\n    vec3 p;\n    vec3 normal;\n    material mat;\n};\n\nvec3 unit_vector(vec3 v) {\n    return v/length(v);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//Ray functions\nvec3 point_at_parameter(ray r, float t) {\n    return r.origin + t*r.direction;\n}\n\n//Sphere function\nbool hit(sphere s, ray r, float t_min, float t_max, inout hit_record rec) {\n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(r.direction, oc);\n    float c = dot(oc, oc) - s.radius*s.radius;\n    float discriminant = half_b*half_b - a*c;\n    if (discriminant > 0.) {\n        float temp = (-half_b - sqrt(discriminant))/a;\n        if (temp < t_max && temp > t_min) {\n            rec.t = temp;\n            rec.p = point_at_parameter(r, rec.t);\n            rec.normal = (rec.p - s.center) / s.radius;\n            rec.mat = s.mat;\n            return true;\n        }\n        temp = (-half_b + sqrt(discriminant))/a;\n        if (temp < t_max && temp > t_min) {\n            rec.t = temp;\n            rec.p = point_at_parameter(r, rec.t);\n            rec.normal = (rec.p - s.center) / s.radius;\n            rec.mat = s.mat;\n            return true;\n        }\n    }\n    return false;\n}\n\n//Hitable list functions\nbool hit(hitable_list hl, ray r, float t_min, float t_max,inout hit_record rec) {\n    hit_record temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    for (int i = 0; i < hl.list_size; i++) {\n        if (hit(hl.list[i], r, t_min, closest_so_far, temp_rec)) {\n            hit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n        }\n    }\n    return hit_anything;\n}\n\n//Camera functions\ncamera create_camera(vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect, float aperture, float focus_dist) {\n    camera cam;\n    cam.lens_radius = aperture/2.;\n    float theta = vfov*PI/180.;\n    float half_height = tan(theta/2.);\n    float half_width = aspect*half_height;\n    cam.origin = lookfrom;\n    cam.w = unit_vector(lookfrom - lookat);\n    cam.u = unit_vector(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin - half_width*focus_dist*cam.u - half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\n    \n    return cam;\n}\n\nvec3 random_in_unit_disk(vec2 uv) {\n    vec3 p;\n    float s = 0.;\n    do {\n        p = 2.0*vec3(rand(uv/iTime*(s+23.345)), rand(uv/iTime*(s+345.43)), 0.) - vec3(1., 1., 0.);\n        s++;\n    } while (dot(p, p) >= 1.);\n    return p;\n}\n\nray get_ray(camera cam, vec2 uv) {\n    vec3 rd = cam.lens_radius*random_in_unit_disk(uv);\n    vec3 offset = cam.u*rd.x + cam.v*rd.y;\n    return ray(cam.origin + offset, cam.lower_left_corner + uv.x*cam.horizontal + uv.y*cam.vertical - cam.origin - offset);\n}\n\n//Lambertian functions\nvec3 random_in_unit_sphere(vec2 uv) {\n    vec3 p;\n    float s = 0.;\n    do {\n        p = 2.0*vec3(rand(uv/iTime*(s+23.345)), rand(uv/iTime*(s+345.43)), rand(uv/iTime*(s+12345.43))) - vec3(1., 1., 1.);\n        s++;\n    } while (dot(p, p) >= 1.);\n    return p;\n}\n\nbool scatter(lambertian l, ray r, hit_record rec, inout vec3 attenuation, inout ray scattered, vec2 uv) {\n    vec3 target = rec.p + rec.normal + random_in_unit_sphere(uv);\n    scattered = ray(rec.p, target-rec.p);\n    attenuation = l.albedo;\n    return true;\n}\n\n//Metal functions\nvec3 reflect(vec3 v, vec3 n) {\n    return v - 2.*dot(v,n)*n;\n}\n\nbool scatter(metal m, ray r_in, hit_record rec, inout vec3 attenuation, inout ray scattered, vec2 uv) {\n    vec3 reflected = reflect(unit_vector(r_in.direction), rec.normal);\n    scattered = ray(rec.p, reflected + m.fuzz*random_in_unit_sphere(uv));\n    attenuation = m.albedo;\n    return (dot(scattered.direction, rec.normal) > 0.); \n}\n\n//Dielectric functions\nbool refract(vec3 v, vec3 n, float ni_over_nt, inout vec3 refracted) {\n    vec3 uv = unit_vector(v);\n    float dt = dot(uv, n);\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\n    if (discriminant > 0.) {\n        refracted = ni_over_nt*(uv - n*dt) - n*sqrt(discriminant);\n        return true;\n    }\n    return false;\n}\n\nfloat schlick(float cosine, float ref_idx) {\n    float r0 = (1.-ref_idx) / (1.+ref_idx);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\n\nbool scatter(dielectric d, ray r_in, hit_record rec, inout vec3 attenuation, inout ray scattered, vec2 uv) {\n    vec3 outward_normal;\n    vec3 reflected = reflect(r_in.direction, rec.normal);\n    float ni_over_nt;\n    attenuation = vec3(1., 1., 1.);\n    vec3 refracted;\n    float reflect_prob;\n    float cosine;\n    if (dot(r_in.direction, rec.normal) > 0.) {\n        outward_normal = -rec.normal;\n        ni_over_nt = d.ref_idx;\n        cosine = d.ref_idx * dot(r_in.direction, rec.normal) / length(r_in.direction);\n    } else {\n        outward_normal = rec.normal;\n        ni_over_nt = 1./d.ref_idx;\n        cosine = -dot(r_in.direction, rec.normal) / length(r_in.direction);\n    }\n    if (refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\n        reflect_prob = schlick(cosine, d.ref_idx);\n    } else {\n        scattered = ray(rec.p, reflected);\n        reflect_prob = 1.;\n    }\n    if (rand(uv/iTime*(23.345)) < reflect_prob) {\n        scattered = ray(rec.p, reflected);\n    } else {\n        scattered = ray(rec.p, refracted);\n    }\n    return true;\n}\n\n//Scene function\nsphere[8] random_scene(vec2 uv) {\n    lambertian d_l = lambertian(vec3(1., 1., 1.));\n    metal d_m = metal(vec3(1., 1., 1.), 1.);\n    dielectric d_d = dielectric(1.);\n    \n    int n = 8;\n    sphere list[8];\n    list[0] = sphere(vec3(0.,-1000.,0.), 1000., material(lambertian(vec3(.5, .5, .5)), d_m, d_d, 0.));\n    int i = 1;\n    for (float a = -1.; a < 1.; a++) {\n        for (float b = -1.; b < 1.; b++) {\n            float choose_mat = rand(vec2((a+796.343)*(b+56.768)));\n            vec3 center = vec3(a+5.+0.9*rand(vec2((a+654.432)*(b+907.576))),\n                                .2,\n                                b+0.9*rand(vec2((a+653.35)*(b+654.87))));\n            if (length(center - vec3(4., .2, 0.)) > .9) {\n                if (choose_mat < .4) { //diffuse\n                    list[i++] = sphere(center, 0.2, material(lambertian(vec3(\n                                                                            rand(vec2((a+769.09)*(b+654.354)))*rand(vec2((a+86.965)*(b+7976.79))), \n                                                                            rand(vec2((a+765.758)*(b+964.345)))*rand(vec2((a+4568.554)*(b+687.234))), \n                                                                            rand(vec2((a+321.32)*(b+546.234)))*rand(vec2((a+234.123)*(b+532.134)))\n                                                                            )), \n                                                                            d_m, d_d, 0.));\n                }\n                else if (choose_mat < .8) { //metal\n                    list[i++] = sphere(center, 0.2, material(d_l, metal(vec3(\n                                                                            .5*(1. + rand(vec2((a+786.456)*(b+23.345)))), \n                                                                            .5*(1. + rand(vec2((a+321.425)*(b+166.7643)))), \n                                                                            .5*(1. + rand(vec2((a+256.345)*(b+7689.432))))\n                                                                            ), .5*rand(vec2((a+215.76)*(b+4326.76)))), \n                                                                            d_d, 1.));                \n                } else { // glass\n                    list[i++] = sphere(center, .2, material(d_l, d_m, dielectric(1.5), 2.));\n                }\n            }\n        }\n    }\n    \n    list[i++] = sphere(vec3(0.,1.,0.), 1., material(d_l, d_m, dielectric(1.5), 2.));\n    list[i++] = sphere(vec3(-4.,1.,0.), 1., material(lambertian(vec3(.4, .2, .1)), d_m, d_d, 0.));\n    list[i++] = sphere(vec3(4.,1.,0.), 1., material(d_l, metal(vec3(.7, .6, .5), 0.), d_d, 1.));\n    return list;\n}\n\nvec3 color(ray r, hitable_list world, vec2 uv) {\n    hit_record rec;\n    vec3 mult = vec3(1.);\n    ray aux_r = ray(r.origin, r.direction);\n    for (float i = 0.; i < DEPTH; i++) {\n        if (!hit(world, aux_r, 0.001, MAXFLOAT, rec)) break;\n        ray scattered;\n        vec3 attenuation;\n        if ((rec.mat.num_m == 0. && scatter(rec.mat.l, aux_r, rec, attenuation, scattered, uv)) || \n            (rec.mat.num_m == 1. && scatter(rec.mat.m, aux_r, rec, attenuation, scattered, uv)) ||\n            (rec.mat.num_m == 2. && scatter(rec.mat.d, aux_r, rec, attenuation, scattered, uv))) {\n            mult *= attenuation;\n        } else {\n            return vec3(0, 0, 0);\n        }\n        aux_r = scattered;\n    }\n    vec3 unit_direction = unit_vector(r.direction);\n    float t = .5*(unit_direction.y + 1.);\n    return mult*((1.-t)*vec3(1., 1., 1.) + t*vec3(.5, .7, 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lookfrom = vec3(13., 2., 3.);\n    vec3 lookat = vec3(0., 0., 0.);\n    float dist_to_focus = 10.;\n    float aperture =  .1;\n    camera cam = create_camera(lookfrom, lookat, vec3(0., 1., 0.), 20., iResolution.x/iResolution.y, aperture, dist_to_focus);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    \n\n    \n    //sphere list[10];\n    //list[0] = sphere(vec3(0.,0.,-1.), 0.5, material(lambertian(vec3(.1, .2, .5)), d_m, d_d, 0.));\n    //list[1] = sphere(vec3(0.,-100.5,-1.), 100., material(lambertian(vec3(.8, .8, 0.)), d_m, d_d, 0.));\n    //list[2] = sphere(vec3(1.,0.,-1.), .5, material(d_l, metal(vec3(.8, .6, .2), 0.), d_d, 1.));\n    //list[3] = sphere(vec3(-1.,0.,-1.), .5, material(d_l, d_m, dielectric(1.5), 2.));\n    //list[4] = sphere(vec3(-1.,0.,-1.), -.45, material(d_l, d_m, dielectric(1.5), 2.));\n    hitable_list world = hitable_list(random_scene(fragCoord/iResolution.xy), 8);\n\n    vec2 uv;\n    vec3 col;\n    float ns = 10.;\n    for (float s = 0.; s < ns; s++) {\n        uv =  vec2(fragCoord + vec2(rand(uv/iTime*(s+23.345)), rand(uv/iTime*(s+345.43))))/iResolution.xy;\n        ray r = get_ray(cam, uv);\n        col += color(r, world, uv);\n    }\n    col /= ns;\n    col = sqrt(col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}