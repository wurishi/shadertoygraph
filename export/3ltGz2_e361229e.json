{"ver":"0.1","info":{"id":"3ltGz2","date":"1576906050","viewed":245,"name":"PostProcessing_Gaussian Blur","username":"lypion","description":"PostProcessing, Bluring of image, Gaussian filter","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["postprocessing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n---Base---\n\tInspired by https://www.shadertoy.com/view/XdfGDH\n\n---Main Content---\n\t1. Postprocessing of image. Use Gaussian filter to blur the image\n*/\n\n/*\nThis is a Guassian filter function:\nf(sigma, param) = 1 / (sigma * sqrt(2 * PI)) * exp(-param * param / (2 * sigma * sigma);\nsigma--the standard deviation of the Gaussian filter\nparam--the calculating variable\n*/\nfloat CalGaussianFilterValue(float sigma, float param)\n{\n    return 0.3989f * exp(-param * param * 0.5f / (sigma * sigma)) / sigma;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //the range we sample the filter, you can change this value to change the level of the blur\n    const int range = 4;\n    //the total number of sample points\n    const int samplePointCount = 2 * range + 1;\n    const float sigma = 4.0;\n    float kernel[samplePointCount];\n    for(int i = 0; i <= range; i++)\n    {\n        kernel[i] = kernel[samplePointCount - i - 1] = CalGaussianFilterValue(sigma, float(i - range));\n    }\n    //store the total value of the kernel array, for keeping the brightness of the image\n    float total = 0.0;\n    for(int i = 0; i < samplePointCount; i++)\n    {\n        total += kernel[i];\n    }\n\n    vec3 finalCol = vec3(0.0);\n    for(int h = -range; h <= range; h++)\n    {\n        for(int v = -range; v <= range; v++)\n        {\n            vec2 uv = (fragCoord + vec2(h, v)) / iResolution.xy;\n            //because we use gaussian filter both horizontally and vertically,\n            //so we need to multiply twice the kernel\n            finalCol += (kernel[v + range] * kernel[h + range] * texture(iChannel0, uv)).rgb;\n        }\n    }\n \n    fragColor = vec4(finalCol / (total * total), 1.0);\n}","name":"Image","description":"","type":"image"}]}