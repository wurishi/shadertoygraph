{"ver":"0.1","info":{"id":"Xdsfz7","date":"1495445339","viewed":218,"name":"pruebas_06","username":"ps","description":"Pruebas de implementación de raymarching para trabajo de investigación de la asignatura rendering avanzado","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingterrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// recursos interesantes \n// elevated de iq https://www.shadertoy.com/view/MdX3Rr\n// raymarching de iq https://iquilezles.org/articles/rmshadows\n// iluminación de iq https://iquilezles.org/articles/outdoorslighting\n// (buena explicación de raymarching) tutorial para esfera con iluminacion phong mediante raymarching http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\n\n// Constantes.\n#define STEPS 64\n#define EPS 0.002\n#define FAR 1000.0\n#define PI 3.14159265359\n\n#define WATER_LEVEL 2.01\n\n#define SC (250.0)\n\n//función de ruido extraida de https://www.shadertoy.com/view/MlfXWH\nvec3 noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Quintic because everyone else is using the cubic! :D\n    vec2 df = 30.0*f*f*(f*(f-2.0)+1.0);\n    f = f*f*f*(f*(f*6.-15.)+10.);\n    \n    float a = textureLod(iChannel0, (i+vec2(0.5, 0.5))/256., 0.0).r;\n    float b = textureLod(iChannel0, (i+vec2(1.5, 0.5))/256., 0.0).r;\n    float c = textureLod(iChannel0, (i+vec2(0.5, 1.5))/256., 0.0).r;\n    float d = textureLod(iChannel0, (i+vec2(1.5, 1.5))/256., 0.0).r;\n    \n    float k = a-b-c+d;\n    float n = mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n    \n    return vec3(n, vec2(b-a+k*f.y, c-a+k*f.x)*df);\n}\n\nmat2 m = mat2(0.8,-0.6,0.6,0.8);\n\nfloat escala=0.90; // creo que con esto se controla la escala del terreno o algo\n// fractal brownian motion, hace 4 repeticiones de la función de ruido, a mas pasadas mas detalles\n// en este caso no necesitamos mucho detalle para la geometría general\nfloat fbmM(vec2 p) {\n    vec2 df = vec2(0.0);\n    float f = 2.0, w = 0.5;\n    \n    for (int i = 0; i < 4; ++i) {\n        vec3 n = noise(p);\n        df += n.yz;\n        f += abs(w * n.x/ (1.0 + dot(df, df)));\n        w *= 0.5; p = 2.*m*p;\n    }\n    return escala*f;\n}\n// lo utilizaremos para calcular las normales por lo que le daremos mas detalle (mas pasadas)\nfloat fbmH(vec2 p) {\n    vec2 df = vec2(0.0);\n    float f = 2.0, w = 0.5;\n    \n    for (int i = 0; i < 10; ++i) {\n        vec3 n = noise(p);\n        df += n.yz;\n        f += abs(w * n.x/ (1.0 + dot(df, df)));\n        w *= 0.4; p = 2.*m*p;\n    }\n    return escala*f;\n}\n/*\n\n\n*/\n// map lo usaban el ejemplo https://www.shadertoy.com/view/MlfXWH para calcular las normales\n// pero se podría omitir como he hecho en el codigo de intersect\nfloat map(vec3 p) {\n    return p.y - fbmM(p.xz);\n}\nfloat mapH(vec3 p) {\n    return p.y - fbmH(p.xz);\n}\n\n/*\n// escena donde se guardara la composición de objetos de la escena\nfloat scene(vec2 posxz){\n  return fbmM(posxz);\n}*/\n\n// modificado de la demo de elevated https://www.shadertoy.com/view/MdX3Rr\nfloat intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax, out bool isWater)\n{\n    vec3 pos;\n    isWater = false;\n    float t = 0.0;\n\t\tfor( int i=0; i<256; i++ )\n\t{\n        pos = ro + t*rd;\n        if(pos.y < WATER_LEVEL){\n            isWater = true;\n            return t;\n        }\n\t\tfloat h = pos.y - fbmM( pos.xz);\n\t\tif( h<(EPS*t) || t>tmax ) break;\n\t\tt += 0.25*h;\n\t}\n\n\treturn t;\n}\n\n\n// extraido de https://www.shadertoy.com/view/MlfXWH\nvec3 calcNormal(vec3 p) {\n    vec2 q = vec2(0., EPS);\n    return normalize(vec3(mapH(p+q.yxx) - mapH(p-q.yxx),\n                \t\t  mapH(p+q.xyx) - mapH(p-q.xyx),\n                \t\t  mapH(p+q.xxy) - mapH(p-q.xxy)));\n}\n\nvec3 makeFog(in vec3 realColor, vec3 fogColor, float distancia, float fogDensity){\n    float theE = 2.718281828459045235360;\n\tfloat res = 1.0/(pow(theE,((distancia*fogDensity)*(distancia*fogDensity)*(distancia*fogDensity))));\n    return mix(fogColor,realColor,res);\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * Ka: Ambient color\n * Kd: Diffuse color\n * Ks: Specular color\n * Ke: Emissive Color\n * alpha: Shininess coefficient\n * pos: position of point being lit\n * eye: the position of the camera\n * rayDir: direction from Camera to point\n * N: point normal\n * Ia: Ambient Intesity\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 Ka, vec3 Kd, vec3 Ks, vec3 Ke, float alpha, vec3 pos, vec3 eye, vec3 rayDir, vec3 N, vec3 Ia) {\n\t\n\tvec3 color=vec3(0.0);\n\t\n\t// Ambiental\n\tcolor+= Ia * Ka;\n\t#define OMNI 0\n\t#define FOCAL 1\n\t#define DIR 2\n\t#define LIGHT_TYPE OMNI\n\t// Cambiar el valor de LIGHT_TYPE por el tipo de luz deseado\n\t\n\t// Procesamiento de variables previas necesarias\n\t// Color de la Luz\n\tvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\t\n\t// Posición de Origen\n\t#if (LIGHT_TYPE == OMNI) || (LIGHT_TYPE == FOCAL)\n\t\tvec3 lightPosition = vec3(\n\t\t\teye.x+10.0 * sin(iTime),\n\t\t\teye.y+2.0,\n\t\t\teye.z+10.0 * cos(iTime)\n\t\t);\n\t#endif\n\t// Dirección de la Luz\n\t#if (LIGHT_TYPE == DIR) || (LIGHT_TYPE == FOCAL)\n\t\tvec3 lightDirection = normalalize(\n\t\t\tvec3(\n\t\t\t\teye.x+10.0 * sin(iTime),\n\t\t\t\teye.y+2.0,\n\t\t\t\teye.z+10.0 * cos(iTime)\n\t\t\t)\n\t\t);\n\t#endif\n\t\n    \n    // ILUMINATE\n\tvec3 V=-rayDir;\n\t#if (LIGHT_TYPE == OMNI)\n\t\t// Difusa\n\t\tvec3 pointToLight = lightPosition - pos;\n\t\t//float distanceToLight = length(pointToLight);\n\t\tvec3 L = normalize(pointToLight);\n\t\tvec3 power = lightColor;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\t\tvec3 diff = power * Kd * dot(N, L);\n\t\tcolor+=clamp(diff,0.0,1.0);\n\n\t\t// Especular\n\t\tvec3 R = reflect(-L,N);\n\t\tfloat Sfactor = max(dot(R,V),0.0000001);\n\t\tSfactor=pow(Sfactor,alpha);\n\t\tvec3 spec = power * Ks * Sfactor;\n\t\tcolor+=clamp(spec,0.0,1.0);\n\t#endif\n\t// Other type of light\n\tcolor+=Ke;\n    return color;\n}\n\nfloat fogAngleFixer(vec3 angle){\n\treturn clamp(-angle.y*2.0+0.2,0.0,1.0);   \n}\nfloat fogAngleFixer2(vec3 angle){\n\treturn clamp(angle.y*3.0-1.5,0.0,1.0);   \n}\nvec3 getBackground(vec3 angle){\n    float heigh = clamp(angle.y*2.0+0.2,0.0,1.0);\n    return vec3(0.3*(1.0-heigh),0.5*heigh*0.5+0.5,1.0*heigh/2.0+0.5);\n}\n//  matParams\n// x -> Reflection Intensity\n// y -> Ambient Occlusion\n// z -> shininess\nvec3 getColor(vec3 pos, vec3 norm, out vec4 matParams){\n    matParams.z = 20.0;\n    float col1=0.0,col2 = 0.0, col3 = 0.0;\n\t// Snow material\n    col1 = clamp((pos.y-2.1) * 10.0, 0.0, 1.0); // Height Filter\n    col1 = min(col1,fogAngleFixer2(norm)); // Inclination filter\n    // Green Material\n    col3 = clamp((-pos.y+2.1) * 10.0, 0.0, 1.0); // Height Filter\n    col3 = min(col3,fogAngleFixer2(norm)); // Inclination filter\n    col3 -= max(col1+col3-1.0,0.0); // Asserve that the cum of color not exceed from 1\n    // Stone Material\n    col2 = 1.0 - col1 - col3;\n    matParams.x = col1*0.001;\n    if(pos.y <= WATER_LEVEL){\n        matParams = vec4(1.0,1.0,20.0,1.0);\n        return vec3(0.6796875,0.90625,0.98046875);\n    }\n    return\n        col1 * vec3(0.8,0.8,0.8) +\n        col2 * vec3(0.54296875,0.55078125,0.4765625) +\n        col3 * vec3(0.5390625,0.6953125,0.359375);\n}\nvec4 render ( vec3 ro, in vec3 rd){\n    vec3 light1 = normalize( vec3(4.8,10.4,4.3) );\n\tfloat tmin = 1.0;\n    float tmax = 100.; // distancia maxima del rayo\n\tvec3 col;\n\tvec3 colorGround=vec3(0.474, 0.313, 0.086);\n    vec3 colorBackground=vec3(0.1,0.1,0.8);\n    float fogDensity = 0.05;\n    fogDensity*=fogAngleFixer(rd);\n    vec3 fogColor = vec3(1.0,1.0,1.0);\n    //return vec4(fogDensity);\n \n    \n    bool isWater = false;\n\tfloat t = intersect( ro, rd, tmin, tmax, isWater);\n    if (t>tmax){\n\n        //draw background\n        col = getBackground(rd);// colorBackground;\n        t = -1.0;\n        col = makeFog(col, fogColor, tmax, fogDensity);\n        \n    \n    }else{\n        //draw terrain\n        vec3 pos = ro + t*rd;\n        //vec3 matGround=colorGround;\n        vec3 nor = isWater? vec3(0.0,1.0,0.0):calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        // return vec4 (nor,1. ); //descomentar para mostrar las normales\n        vec4 matParams=vec4(1.0);\n        vec3 Kd=getColor(pos,nor, matParams);\n\t\tvec3 Ka = Kd; // * ambient Occlussion\n\t\tvec3 Ke = vec3(0.0); // Emisive\n\t\tvec3 Ks = vec3(matParams.x); // reflection component\n        float shininess = matParams.z;\n\t\tvec3 Ia = vec3 (0.3);\n\n        vec3 eye=ro;\n        vec3 color = phongIllumination(Ka, Kd, Ks, Ke, shininess, pos, eye, rd, nor,Ia);\n\t\t//return vec4(color,1.0);\n      //  col=color;\n\t\tcol = makeFog(color, fogColor, t*3.0, fogDensity); // descomentar para generar niebla en la zona de abajo\n        \n    }\n\treturn vec4(col,t);\n}\nvec2 rot2D(vec2 p, float angle) {\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Pixeles de la imagen\n\t//vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    //vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n   \n    vec2  m = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\n\tdir.xz = rot2D(dir.xz, 180. * m.x);\n    \n    vec3 ro = vec3(0.0, 3.8, +2.5-iTime); // inicio de rayo\n    vec3 rd = normalize(vec3(uv, -1.0)); // direccion de rayo\n    vec4 res= render(ro,dir); //funcion que nos devolverá el color del fragmento\n\t\n\tfragColor = vec4(res.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}