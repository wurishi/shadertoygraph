{"ver":"0.1","info":{"id":"4l2GWR","date":"1428101055","viewed":657,"name":"Flatland Radiance","username":"huwb","description":"Some hacky flatland radiance. I'm beginning to experiment with flatland GI and thought I'd share this test. Click for plot. If anyone knows other flatland lighting shaders please link in the comments. No occlusion, lights are additive.","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["flatland","radiance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// the pixel intensity is the integral of the angle subtended by each light, multiplied by\n// the light intensity. there is no other light attenuation/decay. i think this is correct\n// but please comment if not.\n\n#define PI 3.14159265\n#define TWOPI (2.*PI)\n#define CIRCLE_RADIUS (0.05*(.5-.5*cos(max(iTime-5.,0.))))\n#define CIRCLE_INTEN 4.\n\nfloat uWidth()\n{\n    return iResolution.x / iResolution.y;\n}\n\nvec2 circleCenter()\n{\n    // very dodgy bouncing\n    float x = 2.*fract(iTime/16.);\n    x = 1. - abs(x-1.);\n    x = CIRCLE_RADIUS + x*(uWidth()-2.*CIRCLE_RADIUS);\n    x = .1;\n    \n\tfloat bouncePeriod = 5.3 * exp(-.009*iTime);\n    float y = mod(iTime,bouncePeriod)/bouncePeriod;\n    float amp = .7;\n    y = amp - (amp/.25)*(y-0.5)*(y-0.5);\n    y *= exp(-.02*iTime);\n    y += CIRCLE_RADIUS;\n    y = .9;\n    return vec2(x,y);\n}\n\nfloat line(vec2 uv, vec2 start, vec2 end, float I )\n{\n    vec2 v1 = start - uv;\n    vec2 v2 = end - uv;\n    float dotP = clamp( dot(v1,v2)/(length(v1)*length(v2)), -1., 1. );\n    return I * acos( dotP ) / TWOPI;\n}\n\n// ray-line intersect\nfloat rayLine( vec2 p, vec2 d, vec2 start, vec2 end, float I )\n{\n    // do ray-line segment intersection by computing angle to line\n    // segment start and end points and detecting if ray direction\n    // is in the angle range. really ugly, should have just looked\n    // up the geometric line-line intersection!\n    \n    vec2 off1 = start - p;\n    float theta1 = atan( off1.y, off1.x );\n    if( theta1 < 0. ) theta1 += TWOPI;\n    \n    vec2 off2 = end - p;\n    float theta2 = atan( off2.y, off2.x );\n    if( theta2 < 0. ) theta2 += TWOPI;\n    \n    float thetaAvg = (theta1+theta2)/2.;\n    float thetaDif = abs(theta1-theta2);\n    if( thetaDif > PI )\n    {\n        // wrong way around, flip\n        thetaDif = TWOPI - thetaDif;\n    \td = -d;\n    }\n    \n    float theta = atan( d.y, d.x );\n    if( theta < 0. ) theta += TWOPI;\n    \n    if( abs(theta-thetaAvg) > thetaDif/2. )\n        return 0.;\n    \n    return line(p,start,end,I);\n}\n\nvec2 doLine( vec2 uv, vec2 m, vec2 d, vec2 start, vec2 end, float I )\n{\n    vec2 res;\n    \n    res.x = line( uv, start, end, I );\n    res.y = rayLine( m, d, start, end, I );\n    \n    return res;\n}\n\nfloat circle( vec2 uv, vec2 center, float radius, float I )\n{\n    vec2 off = uv - center;\n    float dist2 = dot( off, off );\n    float radius2 = radius * radius;\n    \n    return dist2 < radius2 ? I : 0.5*I*(1.-sqrt(1.-radius2/dist2));\n}\n\n// ray-circle intersect\nfloat rayCircle( vec2 p, vec2 d, vec2 center, float radius, float I )\n{\n    // ray-circle intersection\n    if( dot(p-center,p-center) < radius*radius )\n        return 0.;\n    \n    float t = dot(d, center-p);\n    if( t < 0. )\n        return 0.;\n    \n    return length(p+t*d - center) > radius ? 0. : circle( p, center, radius, I );\n}\n\n#define LINE(sx,sy,ex,ey,i) { lin = doLine( uv, m, d, vec2(sx,sy), vec2(ex,ey), i ); l += lin.x; I += lin.y; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= uWidth();\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    m.x *= uWidth();\n    \n    // BG\n    float gridSz = .45;\n    float bg = 0.;\n    if( mod(uv.x,gridSz) > gridSz/2. ) bg = 1. - bg;\n    if( mod(uv.y,gridSz) > gridSz/2. ) bg = 1. - bg;\n    fragColor.rgb = mix( vec3(.075,.075,.075), vec3(.1,.1,.1), bg );\n    fragColor.g *= 0.8; \n\tfragColor.a = 1.;\n    \n    \n    // now draw radiance polar plot around mouse\n    vec2 off = uv - m;\n    float I = 0.;\n    // raytrace backwards along -off\n    vec2 d = normalize(-off);\n\n    \n    // sum radiance from lights\n    //fragColor += line( uv, vec2(0.4,0.4), vec2(0.6,0.6), 2. );\n    float lineI = .6;\n    float x = .375;//.6;\n    float y = 0.02;//-.25;\n    vec2 lin;\n    float l;\n    vec3 col = vec3(1.,1.,1.);\n    \n    l = 0.;\n    LINE( x, y+.3, x,y+.6, lineI*1.8 )\n    LINE( x, y+.45, x+.2,y+.45, lineI*.6 )\n    LINE( x+.2, y+.45, x+.2,y+.3, lineI*.8 )\n    fragColor.rgb += l * col;\n    \n    x += .3;\n    l = 0.;\n    LINE( x, y+.45, x,y+.3, lineI*.8 )\n    \n    // add some fancy flourescent tube flashing\n    float thresh = min(iTime/3., .99);\n    lineI *= smoothstep(1.-thresh,1.-thresh+.1,texture( iChannel0, vec2(iTime,iTime*1.3) ).x);\n    \n    LINE( x, y+.3, x+.2,y+.3, lineI*1.2 )\n    LINE( x+.2, y+.45, x+.2,y+.3, lineI*.8 )\n    fragColor.rgb += l * col;\n    \n    x += .3;\n    l = 0.;\n    LINE( x, y+.45, x, y+.3, lineI*.8 )\n    LINE( x+.2, y+.45, x+.2, y+.3, lineI*.8 )\n    LINE( x, y+.3, x+.2, y+.3, lineI*1.3 )\n    LINE( x+.1, y+.3, x+.1, y+.375, lineI*.3 )\n    fragColor.rgb += l * col;\n    \n    // add some more fancy flourescent tube flashing\n    thresh = min((iTime-1.)/2., 1.);\n    lineI *= smoothstep(1.-thresh,1.-thresh+.1,texture( iChannel0, vec2(iTime,iTime*1.3) ).x);\n    \n    lineI *= .83;\n    x += .3;\n    l = 0.;\n    LINE( x, y+.3, x, y+.6, lineI )\n    LINE( x, y+.45, x+.2, y+.45, lineI )\n    LINE( x, y+.3, x+.2, y+.3, lineI*1.3 )\n    LINE( x+.2, y+.45, x+.2, y+.3, lineI*1.3 )\n    fragColor.rgb += l * col;\n\n    \n    fragColor += circle( uv, circleCenter(), CIRCLE_RADIUS, CIRCLE_INTEN );\n    I += rayCircle( m, d, circleCenter(), CIRCLE_RADIUS, CIRCLE_INTEN );\n    \n    \n    // draw polar plot of radiance\n    float band = 4./iResolution.x;\n    I = max(I,2.*band);\n    float len = length(off);\n    float alpha = .5 \n        + .5*smoothstep( I-2.*band, I-band, len ) // stroke outside\n        - smoothstep( I-band, I, len );\n   \tfragColor.rgb = mix(fragColor.rgb, vec3(1.,0.,0.), alpha*alpha );\n    \n    // \"tonemapping\"\n    fragColor.x = pow(fragColor.x,1.5);\n    fragColor.y = pow(fragColor.y,1.4);\n    fragColor.z = pow(fragColor.z,1.3);\n}\n","name":"","description":"","type":"image"}]}