{"ver":"0.1","info":{"id":"ttXcDH","date":"1592055299","viewed":86,"name":"PathTracing HR","username":"HuRamb","description":"Casual Shatertoy Path Tracing","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = LinearToSRGB(ACESToneMapping(texture(iChannel0, fragCoord / iResolution.xy).rgb));\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define cCameraOrigin vec3(0., 0., 0.)\n#define cCameraFOV 110.\n#define cMinRayDistance 0.1f\n#define cMaxRayDistance 10000.f\n#define cPI 3.14159265359 \n#define c2PI 3.14159265359\n#define cGeometricTolerance 0.01\n#define cEpsilon 0.0001\n#define cMaxBounce 10u\n#define cRaysPerFrame 1u\n#define cSphereLine 6u\n#define cRussianRoulette\n\nuint WangHash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat(inout uint state)\n{\n    return float(WangHash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat(state) * 2.0f - 1.0f; // 1. * cos(theta)\n    float a = RandomFloat(state) * c2PI; \t\t// phi\n    float r = sqrt(1.0f - z * z);\t\t\t\t// sin(theta) = sqrt(1 - cos2(theta))\n    float x = r * cos(a);\t\t\t\t\t\t// 1. * sin(theta) * cos(phi)\n    float y = r * sin(a);\t\t\t\t\t\t// 1. * sin(theta) * sin(phi)\n    return vec3(x, y, z);\t\t\t\t\t\t\n}\n\nfloat degToRad(in float deg){\n    return deg / 180.f * cPI;\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        lessThan(rgb, vec3(0.0031308f))\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        lessThan(rgb, vec3(0.04045f))\n    );\n}\n\nvec3 saturate(vec3 v){\n    return clamp(v, 0., 1.);\n}\n\nvec3 ACESToneMapping(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct ShaderState{\n    uint randSeed;\n};\n    \nstruct Material{\n    vec3 emissive;\n    vec3 albedo;\n    float specularity;\n    float roughness;\n    vec3 specularColor;\n};\n\nstruct RayHit{\n    float rayDistance;\n    vec3 position;\n    vec3 normal;\n    \n    Material material;\n};\n    \nbool Ray_Quad(in vec3 rayPosition, in vec3 rayDirection, inout RayHit hitInfo,\n             in vec3 planePosition, in vec3 planeBasisA, in vec3 planeBasisB){\n    \n    vec3 quadNormal = normalize(cross(planeBasisA, planeBasisB));\n    if(dot(rayDirection, quadNormal) > 0.){\n        quadNormal = - quadNormal;\n    }\n    float rayDistance = dot(planePosition - rayPosition, quadNormal) / dot(rayDirection, quadNormal);\n    if(rayDistance < cMinRayDistance || rayDistance > hitInfo.rayDistance){\n        return false;\n    }\n    \n    vec3 hitPosition = rayPosition + rayDistance * rayDirection;\n    \n    vec3 hitVector = hitPosition - planePosition;\n    float projA = dot(hitVector, normalize(planeBasisA));\n    float projB = dot(hitVector, normalize(planeBasisB));\n    \n    if(projA > 0. && projA < length(planeBasisA)\n       && projB > 0. && projB < length(planeBasisB)){\n        hitInfo.rayDistance = rayDistance;\n        hitInfo.position = hitPosition;\n        hitInfo.normal = quadNormal;\n        return true;\n    }\n    \n\treturn false;\n}\n\nbool Ray_Sphere(in vec3 rayPosition, in vec3 rayDirection, inout RayHit hitInfo,\n               in vec3 sphereCenter, in float sphereRadius){\n    \n    vec3 rayProjection = rayPosition - sphereCenter;\n    float b = dot(rayProjection, rayDirection);\n    float c = dot(rayProjection, rayProjection) - sphereRadius * sphereRadius;\n    \n    // solving quadratic a*x*x + b*x + c = 0\n    float discriminant = b * b - c;\n    if(discriminant < 0.){\n        return false;\n    }\n    \n    float insideFactor = 1.f;\n    float rayDistance = - b - sqrt(discriminant);\n    if(rayDistance < 0.){\n        insideFactor = -1.f;\n        rayDistance = - b + sqrt(discriminant);\n    }\n    \n    if(rayDistance > cMinRayDistance && rayDistance < hitInfo.rayDistance){\n        hitInfo.rayDistance = rayDistance;\n        hitInfo.position = rayPosition + rayDistance * rayDirection;\n        hitInfo.normal = normalize(hitInfo.position - sphereCenter) * insideFactor;\n    \treturn true;   \n    }\n    \n    return false;\n}\n\nvec3 GetRayColor(inout ShaderState state, in vec3 startPosition, in vec3 startDirection){\n    vec3 rayColor = vec3(0., 0., 0.);\n    vec3 rayThroughput = vec3(1., 1., 1.);\n    \n    RayHit hitInfo;\n    hitInfo.rayDistance = cMaxRayDistance;\n    \n    vec3 rayPosition = startPosition;\n    vec3 rayDirection = startDirection;\n   \n    for(uint bounce = 0u; bounce < cMaxBounce; ++bounce){\n        uint hitCount = 0u;\n        \n        // ---- scene\n        // -- light\n        {\n            vec3 quadPosition = vec3(-2.5, 10. - cGeometricTolerance, 17.5);\n            vec3 quadBasisA = vec3(5., 0., 0.);\n            vec3 quadBasisB = vec3(0., 0., 5.);\n            \n            Material material;\n            material.albedo = vec3(0., 0., 0.);\n            material.emissive = vec3(1., 0.9, 0.7) * 20.;\n\n            if(Ray_Quad(rayPosition, rayDirection, hitInfo, quadPosition, quadBasisA, quadBasisB)){\n                hitInfo.material = material;\n                ++hitCount;\n            }\n        }\n        // -- box\n        // - back\n        {\n            vec3 quadPosition = vec3(-10. - cGeometricTolerance, -10. - cGeometricTolerance, 25.);\n            vec3 quadBasisA = vec3(20. + 2. * cGeometricTolerance, 0., 0.);\n            vec3 quadBasisB = vec3(0., 20. + 2. * cGeometricTolerance, 0.);\n            \n            Material material;\n            material.albedo = vec3(.7, .7, .7);\n            material.emissive = vec3(0., 0., 0.);\n\n            if(Ray_Quad(rayPosition, rayDirection, hitInfo, quadPosition, quadBasisA, quadBasisB)){\n                hitInfo.material = material;\n                ++hitCount;\n            }\n        }\n        // - bottom\n        {\n            vec3 quadPosition = vec3(-10. - cGeometricTolerance, -10., 15.);\n            vec3 quadBasisA = vec3(20. + 2. * cGeometricTolerance, 0., 0.);\n            vec3 quadBasisB = vec3(0., 0., 20. + 2. * cGeometricTolerance);\n            \n            Material material;\n            material.albedo = vec3(.7, .7, .7);\n            material.emissive = vec3(0., 0., 0.);\n\n            if(Ray_Quad(rayPosition, rayDirection, hitInfo, quadPosition, quadBasisA, quadBasisB)){\n\t\t\t\thitInfo.material = material;\n                ++hitCount;\n            }\n        }\n        // - top\n        {\n            vec3 quadPosition = vec3(-10. - cGeometricTolerance, 10., 15.);\n            vec3 quadBasisA = vec3(20. + 2. * cGeometricTolerance, 0., 0.);\n            vec3 quadBasisB = vec3(0., 0., 20. + 2. * cGeometricTolerance);\n            Material material;\n            material.albedo = vec3(.7, .7, .7);\n            material.emissive = vec3(0., 0., 0.);\n\n            if(Ray_Quad(rayPosition, rayDirection, hitInfo, quadPosition, quadBasisA, quadBasisB)){\n                hitInfo.material = material;\n                ++hitCount;\n            }\n        }\n        // - left\n        {\n            vec3 quadPosition = vec3(-10., -10. - cGeometricTolerance, 15.);\n            vec3 quadBasisA = vec3(0., 20. + 2. * cGeometricTolerance, 0.);\n            vec3 quadBasisB = vec3(0., 0., 20. + 2. * cGeometricTolerance);\n            \n            Material material;\n            material.albedo = vec3(.7, .1, .1);\n            material.emissive = vec3(0., 0., 0.);\n\n            if(Ray_Quad(rayPosition, rayDirection, hitInfo, quadPosition, quadBasisA, quadBasisB)){\n                hitInfo.material = material;\n                ++hitCount;\n            }\n        }\n        // - right\n        {\n            vec3 quadPosition = vec3(10., -10. - cGeometricTolerance, 15.);\n            vec3 quadBasisA = vec3(0., 20. + 2. * cGeometricTolerance, 0.);\n            vec3 quadBasisB = vec3(0., 0., 20. + 2. * cGeometricTolerance);\n            \n            Material material;\n            material.albedo = vec3(.1, .7, .1);\n            material.emissive = vec3(0., 0., 0.);\n\n            if(Ray_Quad(rayPosition, rayDirection, hitInfo, quadPosition, quadBasisA, quadBasisB)){\n                hitInfo.material = material;\n                ++hitCount;\n            }\n        }\n        \n        // -- small spheres\n        {\n            vec3 sPosition = vec3(-7., 0., 20.);\n            vec3 ePosition = vec3(7., 0., 20.);\n            float sRoughness = 0.;\n            float eRoughness = 1.;\n            \n            float sphereRadius = (ePosition.x - sPosition.x) / float(cSphereLine) * 0.5;\n            Material material;\n            material.specularity = 1.;\n            material.specularColor = vec3(.3, 1., .3);\n            \n            for(uint isphere = 0u; isphere < cSphereLine; ++isphere){\n                float mixFactor = float(isphere) / float(cSphereLine - 1u);\n                vec3 spherePosition = mix(sPosition, ePosition, mixFactor);\n                material.roughness = mix(sRoughness, eRoughness, mixFactor);\n                if(Ray_Sphere(rayPosition, rayDirection, hitInfo, spherePosition, sphereRadius)){\n                    hitInfo.material = material;\n                    ++hitCount;\n                }\n            }\n        }\n        \n        // -- big spheres\n        // - left\n        {\n            vec3 spherePosition = vec3(-7. + cGeometricTolerance, -7. + cGeometricTolerance, 20.);\n            float sphereRadius = 3.;\n\n\t\t\tMaterial material;\n            material.albedo = vec3(.9, .9, .5);\n            material.emissive = vec3(0., 0., 0.);\n            material.specularity = .1;\n            material.roughness = .2;\n            material.specularColor = vec3(.9, .9, .9);\n            \n            if(Ray_Sphere(rayPosition, rayDirection, hitInfo, spherePosition, sphereRadius)){\n                hitInfo.material = material;\n                ++hitCount;\n            }\n        }\n        // - middle\n        {\n            vec3 spherePosition = vec3(0., -7. + cGeometricTolerance, 20.);\n            float sphereRadius = 3.;\n            \n            Material material;\n            material.albedo = vec3(.9, .5, .9);\n            material.emissive = vec3(0., 0., 0.);\n            material.specularity = .3;\n            material.roughness = .2;\n            material.specularColor = vec3(.9, .9, .9);\n\n            if(Ray_Sphere(rayPosition, rayDirection, hitInfo, spherePosition, sphereRadius)){\n                hitInfo.material = material;\n                ++hitCount;\n            }\n        }\n        // - right\n        {\n            vec3 spherePosition = vec3(7. - cGeometricTolerance, -7. + cGeometricTolerance, 20.);\n            float sphereRadius = 3.;\n            \n            Material material;\n            material.albedo = vec3(.5, .9, .9);\n            material.emissive = vec3(0., 0., 0.);\n            material.specularity = .5;\n            material.roughness = .5;\n            material.specularColor = vec3(.9, 0., 0.);\n\n            if(Ray_Sphere(rayPosition, rayDirection, hitInfo, spherePosition, sphereRadius)){\n                hitInfo.material = material;\n                ++hitCount;\n            }\n        }\n\n        \n        // ---- cubemap\n        if(hitCount == 0u){\n        \thitInfo.material.albedo = SRGBToLinear(texture(iChannel1, rayDirection).rgb);\n            hitCount = 1u;\n        }\n        \n        // ---- ray commit\n        \n        rayColor += hitInfo.material.emissive * rayThroughput;\n        \n        if(hitCount == 0u){    \n            break;\n        }\n        \n        // ---- russian roulette\n        #ifdef cRussianRoulette\n        float rayRelevance = max(rayThroughput.r, max(rayThroughput.g, rayThroughput.b));\n        if(RandomFloat(state.randSeed) > rayRelevance){\n            break;\n        }\n        \n        rayThroughput *= 1. / rayRelevance;\n        #endif\n\n        // ---- prepare for next bounce        \n        rayPosition = hitInfo.position + cEpsilon * hitInfo.normal;\n        \n        vec3 diffuseDirection = normalize(hitInfo.normal + RandomUnitVector(state.randSeed));\n        \n        float raySpecularity = RandomFloat(state.randSeed);\n        if(raySpecularity < hitInfo.material.specularity){\n            rayDirection = mix(reflect(rayDirection, hitInfo.normal), diffuseDirection, hitInfo.material.roughness * hitInfo.material.roughness);\n            rayThroughput *= hitInfo.material.specularColor;\n        }else{\n            rayDirection = diffuseDirection;\n            rayThroughput *= hitInfo.material.albedo;\n        }\n        \n        hitInfo.rayDistance = cMaxRayDistance;\n    }\n\n    return rayColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ---- camera\n   \tvec3 rayOrigin = cCameraOrigin;\n    float rayOriginToScreen = 1. / tan(degToRad(cCameraFOV * 0.5));\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    // ---- state initialization\n    ShaderState state;\n    #if 0\n    state.randSeed = uint(iResolution.x);\n    WangHash(state.randSeed);\n    state.randSeed += uint(iResolution.y);\n    WangHash(state.randSeed);\n    state.randSeed += uint(iFrame);\n    WangHash(state.randSeed);\n    #else\n    state.randSeed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    #endif\n    \n    // ---- tracing\n    vec3 rayColor = vec3(0., 0., 0.);\n    for(uint ray = 0u; ray < cRaysPerFrame; ++ray){\n        vec2 originJitter = vec2(RandomFloat(state.randSeed), RandomFloat(state.randSeed));\n        vec3 rayTarget = vec3((fragCoord + originJitter) / iResolution.xy * 2.f - 1.f, rayOriginToScreen);\n        rayTarget.y *= aspectRatio;\n\n        vec3 rayDirection = normalize(rayTarget - rayOrigin);\n        \n        rayColor += GetRayColor(state, rayOrigin, rayDirection);\n        WangHash(state.randSeed);\n    }\n    rayColor /= float(cRaysPerFrame);\n    \n    // ---- contribution texture\n    bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n    vec4 currentColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (spacePressed || currentColor.a == 0.) ? 1. : 1. / (1. + (1. / currentColor.a));\n    rayColor = mix(currentColor.rgb , rayColor, blend);\n    \n    fragColor = vec4(rayColor, blend);\n}","name":"Buffer A","description":"","type":"buffer"}]}