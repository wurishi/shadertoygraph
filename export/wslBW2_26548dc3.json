{"ver":"0.1","info":{"id":"wslBW2","date":"1589136749","viewed":141,"name":"Worley Noise Ripples","username":"susanxie","description":"simple worley noise ripple effect","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["worley","ripple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 random1(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(324.1, 21.7)),\n                 dot(p, vec2(45.5,234.3))))\n                 * 345.098);\n}\n\nfloat WorleyNoise1(vec2 uv) {\n    const float dimen = 10.0; // dimension\n    uv[0] *= dimen;\n    float ratio = iResolution.y / iResolution.x;\n    uv[1] *= dimen * ratio; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n        \n        for(int y = -1; y <= 1; ++y) {\n            for(int x = -1; x <= 1; ++x) {\n                vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n                vec2 point = random1(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n                vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    \n    return minDist;\n}\n\nfloat WorleyNoise2(vec2 uv) {\n    const float dimen = 10.0; // dimension\n    uv[0] *= dimen;\n    float ratio = iResolution.y / iResolution.x;\n    uv[1] *= dimen * ratio; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n        \n        for(int y = -1; y <= 1; ++y) {\n            for(int x = -1; x <= 1; ++x) {\n                vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n                vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n                vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    \n    return minDist;\n}\n\nfloat WorleyNoise3(vec2 uv) {\n    const float dimen = 8.0; // dimension\n    uv[0] *= dimen;\n    float ratio = iResolution.y / iResolution.x;\n    uv[1] *= dimen * ratio; \n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n        \n        for(int y = -1; y <= 1; ++y) {\n            for(int x = -1; x <= 1; ++x) {\n                vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n                vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n                vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    \n    return minDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 uvInt;\n    vec2 temp = vec2(0., 2.);\n    vec3 col;\n    float noise1 = WorleyNoise1(uv);\n    float noise2 = WorleyNoise2(uv);\n    float noise3 = WorleyNoise3(uv);\n    float diam1 = 0.1 * (sin((iTime + 9.) * 0.5) / cos((iTime + 9.) * 0.5));\n    float diam2 = 0.1 * (sin(iTime * 0.5) / cos(iTime * 0.5));\n    float diam3 = 0.1 * (sin((iTime + 4.) * 0.5) / cos((iTime + 4.) * 0.5));\n    float diam4 = 0.1 * (sin((iTime - 5.) * 0.5) / cos((iTime - 5.) * 0.5));\n    \n    float diam5 = 0.1 * (sin((iTime + 2.) * 0.5) / cos((iTime + 2.) * 0.5));\n    float diam6 = 0.1 * (sin(iTime - 9. * 0.5) / cos(iTime - 9. * 0.5));\n\n    if (noise1 >= diam1 && noise1 <= diam1 + 0.016) {\n        col = vec3(1.0);\n    } else {\n        col = vec3(0.);\n    }\n    \n    if (noise1 >= diam2 && noise1 <= diam2 + 0.015) {\n        col += vec3(1.0);\n    } else {\n        col += vec3(0.);\n    }\n    \n    if (noise2 >= diam3 && noise2 <= diam3 + 0.013) {\n        col += vec3(1.0);\n    } else {\n        col += vec3(0.);\n    }\n    \n    if (noise2 >= diam4 && noise2 <= diam4 + 0.014) {\n        col += vec3(1.0);\n    } else {\n        col += vec3(0.);\n    }\n    \n    if (noise3 >= diam5 && noise3 <= diam5 + 0.01) {\n        col += vec3(1.0);\n    } else {\n        col += vec3(0.);\n    }\n    if (noise3 >= diam6 && noise3 <= diam6 + 0.01) {\n        col += vec3(1.0);\n    } else {\n        col += vec3(0.);\n    }\n        \n    // Output to screen\n    col *= 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    fragColor += vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}