{"ver":"0.1","info":{"id":"slVyWR","date":"1661319996","viewed":66,"name":"Roots Of Unity (Euler Identity)","username":"Envy24","description":"Just different ways to calculate roots of unity.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["complex","frequency","roots","unity","euler","identity","demoivre"],"hasliked":0,"parentid":"7dVfD1","parentname":"Plotter template_"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  5.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define TAU                         6.2831853071795862\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float f, float dfdx)\n{\n    float signed_dist = NDC.y - f;\n    return SMAA(abs(signed_dist) / sqrt(1.0 + dfdx * dfdx));\n}\nfloat draw_implicit_func(vec2 NDC, float fxy, vec2 grad)\n{\n    return SMAA(abs(fxy) / sqrt(1.0 + grad.x*grad.x + grad.y*grad.y));\n}\n\nvec2 conjugate(vec2 z) { return vec2(z.x, -z.y); }\n\n/* */\nvec2 Euler_Identity(float imaginary_exponent)\n{\n    return vec2(cos(imaginary_exponent), sin(imaginary_exponent));\n}\n/* */\nvec2 nth_root_of_unity(float base_freq, float root_index)\n{\n    float imaginary_exponent = base_freq * root_index;\n    return vec2(cos(imaginary_exponent), sin(imaginary_exponent));\n}\n/* */\nvec2 nth_root_of_unity2(float number_of_roots, float root_index)\n{\n    float imaginary_exponent = (TAU / number_of_roots) * root_index;\n    return vec2(cos(imaginary_exponent), sin(imaginary_exponent));\n}\n/*\n    Version for inlining.\n*/\nvec2 nth_root_of_unity3(float base_freq, float root_index)\n{\n    vec2 nth_root = vec2(1, 0); // Main root.\n    vec2 phasor = vec2(cos(base_freq), sin(base_freq));\n    \n    for (float i = 0.; i < root_index; i += 1.)\n    {\n        // Complex multiplication.\n        float re = nth_root.x*phasor.x - nth_root.y*phasor.y;\n        float im = nth_root.x*phasor.y + nth_root.y*phasor.x;\n        \n        nth_root.x = re;\n        nth_root.y = im;\n    }\n    \n    return nth_root;\n}\n/* \n    Another version for inlining.\n*/\nvec2 nth_root_of_unity4(\n    float number_of_roots,\n    float root_index)\n{\n    float base_freq = TAU / number_of_roots,\n          h = number_of_roots*0.5,\n          r = mod(root_index, h);\n          \n    vec2 nth_root = vec2(1, 0); // Main root.\n    vec2 phasor = vec2(cos(base_freq), sin(base_freq));\n\n    for (float i = 0.; i < r; i += 1.)\n    {\n        // Complex multiplication.\n        float re = nth_root.x*phasor.x - nth_root.y*phasor.y;\n        float im = nth_root.x*phasor.y + nth_root.y*phasor.x;\n        \n        nth_root.x = re;\n        nth_root.y = im;\n    }\n    \n    nth_root = root_index == h ? vec2(-1., 0.) : nth_root;\n    \n    return\n        root_index < h ?\n            nth_root :\n            conjugate(nth_root);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 1.1\n#define YSCALE 1.0\n#define OFFSET vec2(0., 0.)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n\n#define FUNC(x, y) ( x*x+y*y-1. )\n#define GRAD(x, y) ( vec2(2.*x, 2.*y) )\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC)*0.2; color -= y_axis(NDC)*0.2;\n         color.rb -= draw_implicit_func(NDC, FUNC(NDC.x, NDC.y), GRAD(NDC.x, NDC.y));\n\n    float N = 64.;//floor(sinOSC(0., 64., iTime*0.25));\n    float base_freq = TAU / N;\n    vec2 turn = vec2(cos(base_freq), sin(base_freq));\n    vec2 nth_root = vec2(1., 0.); // Main root.\n    \n    for (float n = 0.; n < N; n += 1.)\n    {\n        //nth_root = Euler_Identity(base_freq * n);\n        //nth_root = nth_root_of_unity(base_freq, n);\n        //nth_root = nth_root_of_unity3(base_freq, n);\n        //nth_root = nth_root_of_unity4(N, n);\n        \n        /* inlined version (more efficient) */\n        // Complex multiplication.\n        float re = nth_root.x*turn.x - nth_root.y*turn.y;\n        float im = nth_root.x*turn.y + nth_root.y*turn.x;\n        \n        nth_root.x = re;\n        nth_root.y = im;\n        /* inlined version (more efficient) */\n        \n        color = mix(color, vec3(1, 0, 1), SMAA(diskSDF_L2(NDC, nth_root, UNIT*0.5)));\n    } \n    \n    float root_index = floor(iTime);\n    \n    // Forward.\n    nth_root = nth_root_of_unity(base_freq, root_index);\n    //nth_root = nth_root_of_unity2(N, root_index);\n    //nth_root = nth_root_of_unity3(base_freq, root_index);\n    color = mix(color, vec3(0, 0, 1), SMAA(diskSDF_L2(NDC, nth_root, UNIT*1.2)));\n    \n    // Reverse.\n    nth_root = conjugate(nth_root);\n    //nth_root = nth_root_of_unity(-base_freq, root_index);\n    //nth_root = nth_root_of_unity2(N, root_index); nth_root.y *= -1.;\n    //nth_root = nth_root_of_unity3(-base_freq, root_index);   \n    color = mix(color, vec3(1, 0, 0), SMAA(diskSDF_L2(NDC, nth_root, UNIT*1.2))); \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}