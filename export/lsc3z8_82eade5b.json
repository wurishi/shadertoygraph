{"ver":"0.1","info":{"id":"lsc3z8","date":"1448129931","viewed":375,"name":"Distance Field Playbox","username":"Hamneggs","description":"Have you ever wanted to try out a distance field, but didn't want to write out all the rest of the ray-marcher to do it? Well here's a basic marcher that only needs your new distance field! See comments for more.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","test","distance","field","area","playbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\n\n\tVersion 1.1: MOUSE INTERACTIVITY :)\n    Version 1.11: Fixed preview.\n\tNow uses TekF's polar camera to provide intuitive mouse\n\trotation, and also rid ourselves of that pesky cam-dir==Y||-Y \n\tproblem. Some camera parameters are provided in the \n \tconsts below.\n\n\tThis is a basic ray marcher already set up so that people can\n\tjust insert their own distance fields for testing. Want to\n\tbuild a CSG lamppost from distance primitives but don't want\n\tto write the rest of the marcher to do so? Just use this.\n\t\n\tTo add your distance function, just spice up the existing\n\tdist() function.\n\n\tTo add textures, #define an id for each element you want\n\ttextured, then add calls to u() within distID to determine\n\tthe nearest object and its ID.\n\tNext add checks for each of those IDs in tex() and do whatever\n\ttexturing you want.\n\n\tThis shell of a shader uses Oren Nayar shading and a shoddy\n\tinterpretation of IQ's 3 light system to get you going.\n\n\tAlso, the plane is at Y=0, and the grid is 1x1, and don't make the\n\tcamera direction Y or -Y. The math it's based on hates that. Hates\n\tit a lot.\n\n\tDisclaimer: This started life as a tool for me to make stuff, so\n\tif it doesn't suit your personal needs, make it do so yourself.\n*/\n\t\n\n// Occlusion samples.\n#define OCC_SAMPLES 4.0\n// Occlusion attenuation samples.\n#define OCC_FACTOR 1.5\n// Light and reflection penumbra factors.\n#define PENUMBRA_FACTOR 15.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 4.0\n// Main marching steps.\n#define V_STEPS 100\n// Shadow marching steps.\n#define S_STEPS 20\n// Maximum successful marching distance.\n#define EPSILON .00025\n// Max ray depth.\n#define MAX_DEPTH 30.0\n\n// This is for texturing. For each item you want textured,\n// give it an ID and add it to the distID function using\n// the unioning function u(), then add code to check for \n// the ID in tex().\n#define ID_PLANE 1.0\n\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t\t\t// An up vector.\nconst vec3 SUN_DIR = vec3(0.408248, 0.816497, -0.408248); \t// Sun direction.\nconst vec3 SKY_COLOR_A = vec3(0.53,0.81,0.92);\t\t\t    // Sky color.\nconst vec3 SKY_COLOR_B = vec3(0.23,0.34,0.85);\t\t\t\t// High angle sky.\nconst vec3 SUN_COLOR = vec3(4.0);\t\t\t\t\t\t\t// Sun color.\nconst vec3 GROUND_COLOR = vec3(0.73,0.60,0.47);\t\t\t\t// Average color of the ground for GI.\nconst vec3 TILEA = vec3(.4, .4, .366);\t\t\t\t\t\t// The fist tile color.\nconst vec3 TILEB = vec3(0.32, 0.32, 0.2928);\t\t\t\t// ... and the second as well.\n\n// Camera parameters.\nconst vec3 CAM_LOOK_AT = vec3(0.0, 1.0, 0.0);\nconst float CAM_DIST_AWAY = 4.0; // How far away the camera is from CAM_LOOK_AT.\nconst float CAM_ZOOM = 1.0;\n\n/*\n\tTEKF's wonderful polar camera. (https://www.shadertoy.com/view/XdsGDB)\n*/\nvoid camPolar( out vec3 p, out vec3 d, in vec3 o, in vec2 r, in float dist, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = cos(r);\n\tvec4 s;\n\ts.xy = sin(r);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\td.xy = fragCoord.xy - iResolution.xy*.5;\n\td.z = iResolution.y*zoom;\n\td = normalize(d);\n\t\n\t// rotate ray\n\td.yz = d.yz*c.x + d.zy*s.zx;\n\td.xz = d.xz*c.y + d.zx*s.yw;\n\t\n\t// position camera\n\tp = o - dist*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u(vec2 a, vec2 b )\n{\n    if(a.s < b.s) return a;\n    else return b;\n}\n\n/*\n\tReturns the distance to an XZ plane at Y=0.\n*/\nfloat plane( in vec3 p )\n{\n    return p.y;\n}\n\n/////////////////////////////////////////////////\n// ADD EXTRA DISTANCE FIELD STUFF HERE AND ABOVE.\n/*\n\tThe scene's distance function.\n\tAdd what ever distance field primitives you want above, then\n\tuse them to create your object in this function.\n*/\nfloat dist( in vec3 p )\n{\n    return plane(p);\n}\n\n/////////////////////////////////////////////////\n// REGISTER YOUR NEW OBJECT HERE FOR TEXTURING.\n/*\n\tReturns the id and distance of the nearest object.\n*/\nvec2 distID( in vec3 p )\n{\n    return u(vec2(plane(p),ID_PLANE), vec2(EPSILON*2000.0, 999.0));\n    /* E.g.\n\tvec2 closest = u(vec2(yourObjectA(p), ID_YOUR_OBJ_A),\n\t\t\t         vec2(yourObjectB(p), ID_YOUR_OBJ_B);\n\t\t closest = u(closest, vec2(plane(p), ID_PLANE);\n\t*/\n}\n\n/*\n\tMixes between two colors based on the upward angle of the\n\tray direction for a plausible sky.\n*/\nvec3 sky( vec3 d )\n{\n    vec3 flatD = normalize(vec3(d.x,0.0,d.z));\n    return mix(SKY_COLOR_B, SKY_COLOR_A, clamp(dot(flatD,d),0.0,1.0));\n}\n\n/*\n\tReturns a \"texel\" in a tile texture, whose contrast is reduced by distance.\n*/\nvec3 tile_tex( vec3 p, vec3 e )\n{    \n    // The tile is absolute value of the difference in the modulo of the x and z terms of the position.\n    float tile = abs(floor(mod(p.x, 2.0)) - floor(mod(p.z, 2.0)));\n    // We add a term to soften the edge with distance for psuedo anisotropic filtering.\n    tile += (length(p-e)/MAX_DEPTH);\n    \n    // Finally we return the mix of the two tile colors, based on the tile difference.\n    return mix( TILEA, TILEB, smoothstep(0.0, 1.0, tile));\n}\n\n/////////////////////////////////////////////////\n// WRITE SOME SWEET TEXTURE FUNCTIONS AND THROW\n// 'EM IN HERE\n/*\n\tTakes a position and eye coordinate and returns the\n\ttexture of the nearest object to the given position.\n*/\nvec3 tex( vec3 p, vec3 e )\n{\n    float id = distID(p).t;\n    if(id == ID_PLANE) return tile_tex(p,e);\n    /* e.g.\n\telse if(id == YOUR_OBJ_A) return radTexA(whatevs);\n\telse if(id == YOUR_OBJ_B) return radTexB(whatevs);\n\t*/\n    else return vec3(.8);\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction d\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n*/\nvoid march( inout vec3 p, vec3 d )\n{\n\tfloat r = dist(p+d*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || r > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += d*r;\n        r = dist(p);\n\t}\n\treturn;\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat shadow( in vec3 start, in vec3 ldir, in float p )\n{    \n\tfloat t = EPSILON;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float d = dist( start + ldir * t );\n        if ( d < EPSILON*.1 )\n            return 0.0;\n\t\t\n\t\tres = min( res, p * d / t );\n        t += d;\n\t\t\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n/*\n\tIQ's really compact implementation of Oren Nayar reflectance.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion(vec3 pos, vec3 norm)\n{\n\tfloat result = .0;\n    float s = -OCC_SAMPLES;\n    const float unit = 1.0/OCC_SAMPLES;\n\tfor(float i = unit; i < 1.0; i+=unit)\n\t{\n\t\tresult += pow(2.0,i*s)*(i-dist(pos+i*norm));\n\t}\n\treturn 1.0-result*OCC_FACTOR;\n}\n\nvec3 light( in vec3 p, in vec3 d, in vec3 e, in vec3 n )\n{\n    // Get ambient occlusion and shadow values.\n    float amb = occlusion(p,n);\n    float sdw = shadow(p,SUN_DIR,PENUMBRA_FACTOR);\n    \n    // Get light colors and irradiance for the three lights.\n    vec3 skc = orenNayar(n,-d,UP)*sky(d);\n    vec3 sun = orenNayar(n,-d,SUN_DIR)*SUN_COLOR;\n    vec3 gnd = orenNayar(n,-d,-SUN_DIR)*GROUND_COLOR;\n    \n    // Modulate those by ambient occlussion and shadowing.\n    skc *= amb;\n    gnd *= amb;\n    sun *= sdw;\n    \n    // Return the sum.\n    return skc+gnd+sun+vec3(.05);\n}\n/*\n\tShades a point, giving it lighting and taking into account distance.\n*/\nvec3 shade(vec3 p, vec3 d, vec3 e)\n{\n    // Get the position's distance from the camera.\n    float l = length(p-e);\n    // Also get the surface normal.\n    vec3 n = norm(p);\n    // And let's get the sky color since we need it.\n    vec3 s = sky(d);\n    // If the ray didn't hit anything, we shortcut out.\n    if(l >= MAX_DEPTH)return s;\n    // Otherwise we do texturing and lighting for this point.\n    vec3 result = tex(p,e)*light(p,d,e,n);\n    // Smooth out the transition between geometry and emptiness.\n\treturn mix(s,result,clamp(MAX_DEPTH-l,0.0,1.0));\n}\n\n/*\n\tPerforms some quick post-processing. Does gamma correction\n\tand adds a soft vignette just to make whatever you're doing\n\tlook pretty.\n*/\nvec3 postProcess( vec2 uv, vec3 c )\n{\n    float vig = 1.0-dot(uv,uv)*.3;\n    return pow(c,vec3(1.0/2.2))*vig;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Position, direction, and eye.\n    // Notice that it spells out the Processing file extension?\n    vec3 p,d,e;\n    \n    // Camera position and direction.\n    vec3 cp = vec3(0.0, 1.0, -5.0);\n    vec3 cd = normalize(vec3(0.0, 0., 1.0));\n    \n    // Set up the camera.\n    vec2 m;\n    if(length(iMouse.xy)<=.001) m = vec2(.5,.1);\n    else m = iMouse.yx/iResolution.yx;\n    m *= vec2(1.5,6.28); // Movement scaling.\n    camPolar(p, d, CAM_LOOK_AT, m, CAM_DIST_AWAY, CAM_ZOOM, fragCoord );\n\t// Store the eye position.\n    e = vec3(p);\n    \n    // Do the actual ray marching.\n    march(p,d);\n    \n    // Store the final pixel color.\n    fragColor = postProcess(uv,shade(p,d,e)).rgbb;\n}","name":"Image","description":"","type":"image"}]}