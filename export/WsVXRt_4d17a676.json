{"ver":"0.1","info":{"id":"WsVXRt","date":"1575527318","viewed":225,"name":"Training 05 (Copo)","username":"coposuke","description":"Traning","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["training"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 onepix = 1.0 / iResolution.xy;\n    vec2 uv1 = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv2 = fragCoord / iResolution.xy;\n    \n    vec3 distortion = texture(iChannel1, uv2 * 0.2 + iTime * 0.1).rgb;\n    vec2 distortionUV = distortion.xz * 0.01;\n    vec2 direction = normalize(distortion.xz);\n    \n    float power = distance(vec2(0.0), ((fragCoord.xy * 2.0 - iResolution.xy) / max(iResolution.x, iResolution.y)));\n    power = power * power * 5.0;\n    \n    vec3 color = texture(iChannel0, uv2 + distortionUV).rgb;\n    float r = texture(iChannel0, uv2 + distortionUV + onepix * direction * power).r;\n    float g = color.g;\n    float b = texture(iChannel0, uv2 + distortionUV - onepix * direction * power).b;\n    color.rgb = vec3(r,g,b);\n    \n    fragColor.rgb = color * color * 1.2;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI      3.14159265357989\n#define PI_2    6.28318530715978\n\nmat3 rotate(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct geometry\n{\n    int type;\n    vec3 position;\n    vec3 normal;\n    float dist;\n};\n    \nstruct info\n{\n    int type;\n    float dist;\n};\n    \n\nfloat sdBox(vec3 rayPos, vec3 size)\n{\n    vec3 q = abs(rayPos) - size;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n    \nmat2 rotate(float angle)\n{\n    return mat2 (cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\nvec2 pmod(vec2 rayPos, float r, out float id)\n{\n    float a = atan(rayPos.x, rayPos.y) + PI / r;\n    float n = PI_2 / r;\n    a = (id = floor(a / n)) * n;\n    return rayPos * rotate(-a);\n}\n\ninfo map(vec3 rayPos)\n{\n    vec2 result = vec2(0, 1e+4);\n    \n    rayPos = rotate(-iTime, vec3(0,1,0)) * rayPos;\n    \n    float id = 0.0;\n    rayPos.xz = pmod(rayPos.xz, 20.0, id);\n    rayPos.y += id;\n    rayPos.y = mod(rayPos.y, 20.0) - 10.0;\n    \n    float scale = 1.5;\n    float scaleSum = 1.0;\n    \n    vec3 ifsPos = rayPos - vec3(0, 0, 10.0);\n    for(int i=0; i<6; i++)\n    {\n        float sdDist = float(i==0) * (length(ifsPos) - 1.0) + float(i>0) * sdBox(ifsPos, vec3(0.5));\n        sdDist = sdDist / scaleSum;\n        \n        result = (result.y < sdDist) ? result : vec2(i+1, sdDist);\n\n        ifsPos = abs(ifsPos) - vec3(1,1,1) * (5.0 + (sin(iTime) * 0.5 + 0.5));\n        ifsPos.xz *= rotate(1.);\n        ifsPos.xy *= rotate(1.);\n        ifsPos *= scale;\n        scaleSum *= scale;\n    }\n    \n    info ret = info(int(result.x), result.y);\n    return ret;\n}\n\n\nvec3 computeNormal(vec3 rayPos, vec3 rayDir)\n{\n    const float EPSILON = 1e-3;\n    return normalize(vec3(\n        map(vec3(rayPos.x + EPSILON, rayPos.y, rayPos.z)).dist - map(vec3(rayPos.x - EPSILON, rayPos.y, rayPos.z)).dist,\n        map(vec3(rayPos.x, rayPos.y + EPSILON, rayPos.z)).dist - map(vec3(rayPos.x, rayPos.y - EPSILON, rayPos.z)).dist,\n        map(vec3(rayPos.x, rayPos.y, rayPos.z + EPSILON)).dist - map(vec3(rayPos.x, rayPos.y, rayPos.z - EPSILON)).dist\n    ));\n}\n    \ngeometry raymarch(vec3 camPos, vec3 camRay)\n{\n    geometry result;\n    vec3 rayPos = camPos;\n    float dist = 0.0;\n    \n    for(int i=0 ; i<200 ; ++i)\n    {\n        rayPos += camRay * dist;\n        info inf = map(rayPos);\n        dist = inf.dist;\n        \n        if(dist < 1e-3)\n        {\n            result.type = inf.type;\n            result.dist = dist;\n            result.position = rayPos + camRay * dist;\n            result.normal = computeNormal(rayPos, camRay);\n            break;\n        }\n    }\n    \n    return result;\n}\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    mat3 camMat = rotate(0.25, vec3(1,0,0));\n    vec3 camPos = camMat * vec3(0,0,-30.0 - 10.0 * sin(iTime)) + vec3(0,mod(iTime * 10.0, 20.0),0);\n    vec3 camRay = camMat * normalize(vec3(uv, 2.0));\n    vec3 lightDir = normalize(vec3(-1,1,-1));\n    \n    geometry result = raymarch(camPos, camRay);\n    \n    float light = 0.0;\n    light += float(result.type == 0) * ((fragCoord.y / iResolution.y) * 0.5 + 0.5);\n    light += float(result.type != 0) * clamp(dot(lightDir, result.normal), 0.2, 1.0);\n    \n    vec3 shadow = vec3(0);\n    shadow += float(result.type == 0) * vec3(0.42, 0.22, 0.54);\n    shadow += float(result.type == 1) * vec3(0.69, 0.55, 0.65);\n    shadow += float(result.type == 2) * vec3(0.69, 0.89, 0.84);\n    shadow += float(result.type == 3) * vec3(0.95, 0.65, 0.65);\n    shadow += float(result.type == 4) * vec3(0.69, 0.55, 0.65);\n    shadow += float(result.type >= 5) * vec3(0.90, 0.95, 0.93);\n    \n    vec3 diffuse = vec3(0);\n    diffuse += float(result.type == 0) * vec3(0.90, 0.95, 0.93);\n    diffuse += float(result.type == 1) * vec3(0.69, 0.89, 0.84);\n    diffuse += float(result.type == 2) * vec3(0.95, 0.65, 0.65);\n    diffuse += float(result.type == 3) * vec3(0.69, 0.55, 0.65);\n    diffuse += float(result.type == 4) * vec3(0.90, 0.95, 0.93);\n    diffuse += float(result.type >= 5) * vec3(0.95, 0.65, 0.65);\n\n\tfragColor.rgb = mix(shadow, diffuse, light);\n}","name":"Buffer A","description":"","type":"buffer"}]}