{"ver":"0.1","info":{"id":"M32czD","date":"1727080698","viewed":23,"name":"InkSplash","username":"mffvd","description":"particle based ink flow","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fluid","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the resolution and time from ShaderToy uniforms\n    vec2 resolution = iResolution.xy;\n    float time = iTime * 6.0;\n\n    // Get the normalized coordinates of the current pixel\n    vec2 uv = fragCoord / resolution;\n\n    // Scale uv to the screen size (from 0 to resolution)\n    vec2 pixelPos = uv * resolution;\n\n    // Initialize h with value 1.0\n    float h = 1.0;\n\n    // Number of points\n    const int numPoints = 6;\n\n    // Points' initial positions\n    vec2 initialPoints[numPoints];\n    initialPoints[0] = vec2(100.0, 100.0);\n    initialPoints[1] = vec2(200.0, 100.0);\n    initialPoints[2] = vec2(150.0, 250.0);\n    initialPoints[3] = vec2(50.0, 150.0);\n    initialPoints[4] = vec2(250.0, 200.0);    \n    initialPoints[5] = vec2(250.0, 200.0);\n\n    \n    // Points' velocities (vx, vy)\n    vec2 velocities[numPoints];\n    velocities[0] = vec2(50.0, 40.0);  // Point 1 velocity (vx, vy)\n    velocities[1] = vec2(-60.0, 30.0); // Point 2 velocity\n    velocities[2] = vec2(40.0, -50.0); // Point 3 velocity\n    velocities[3] = vec2(-30.0, 60.0); // Point 4 velocity\n    velocities[4] = vec2(70.0, -40.0); // Point 5 velocity    \n    velocities[5] = vec2(-70.0, -40.0); // Point 5 velocity\n\n\n    // Loop through each point and calculate its new position based on time\n    for (int i = 0; i < numPoints; i++) {\n        // Calculate the bouncing effect by simulating the direction change\n        vec2 point = initialPoints[i] + velocities[i] * time;\n\n        // If the point crosses the boundaries, reverse its movement direction\n        point.x = abs(mod(point.x, 2.0 * resolution.x) - resolution.x);\n        point.y = abs(mod(point.y, 2.0 * resolution.y) - resolution.y);\n\n        // Calculate squared distance between the current pixel and the point\n        float distSquared = (pixelPos.x - point.x) * (pixelPos.x - point.x) +\n                            (pixelPos.y - point.y) * (pixelPos.y - point.y);\n\n        // Apply the logarithmic formula to the distance\n        h *= /*log2*/(distSquared + 1.0) / 200000.0; // Adding 1.0 to avoid log2(0)\n    }\n\n    // Threshold and clamping\n    float h2 = h*(resolution.x/15.0);//> 0.5 ? 1.0 : 0.0; \n    // Set the final color based on h\n    vec3 color = vec3(h2) * 255.0;               // Color calculated from h\n    fragColor = vec4(color / 255.0, 1.0);       // Final fragment color with normalized RGB and alpha\n}","name":"Image","description":"","type":"image"}]}