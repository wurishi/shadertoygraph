{"ver":"0.1","info":{"id":"MsycWD","date":"1523843464","viewed":286,"name":"Ray Marcher /w reflections","username":"konidia","description":"Finally I have made a real ray marching shader with hard shadows and reflections. I do really need criticisms, comments, tips & tricks and advises on improving the performance and the look of the shader :)\n\nMove view with mouse","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","shadow","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.5e-3\n#define MAX_DIST 1e2\n//previously\t\t  250\n#define MAX_ITERATION 96\n#define MAX_REFLECT 4\n\n// Move view with mouse\n\nvec3 sunPos = vec3(7,7,7);\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    float fovScalar;\n};\n\nvoid setCamera(vec3 pos, vec3 forward, vec3 upGuide, float fov, out Camera cam)\n{\n    cam.pos = pos;\n    cam.forward = normalize(forward);\n    cam.right = cross(-cam.forward, normalize(upGuide));\n    cam.up = cross(cam.right, -cam.forward);\n    cam.fovScalar = tan(radians(fov/2.0));\n}\n\nRay castRay(vec2 uv, in Camera cam)\n{\n    uv *= cam.fovScalar;\n    return Ray(\n        cam.pos,\n        normalize(cam.forward + uv.x * cam.right + uv.y * cam.up)\n    );\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nfloat minDist(vec3 p)\n{\n    float t = MAX_DIST;\n    t = min(sdSphere(vec3(2,  sin(iTime/2.),      0) -p, 1.), t);\n    t = min(sdSphere(vec3(-2, sin(iTime/2.+0.5),  0) -p, 1.), t);\n    t = min(sdSphere(vec3(0,  sin(iTime/2.+0.9),  2) -p, 1.), t);\n    t = min(sdSphere(vec3(0,  sin(iTime/2.+1.3), -2) -p, 1.), t);\n    t = min(sdSphere(sunPos                     -p, 1.), t);\n    //t = min(p.y + 2., t); //credit: MacsSlow\n    return t;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    // credit: MacsSlow\n    vec2 eps = vec2(MIN_DIST, 0);\n    return normalize(\n        vec3(minDist(p+eps.xyy),\n             minDist(p+eps.yxy),\n             minDist(p+eps.yyx)) - minDist(p)\n    );\n    /*\n    return normalize(\n        vec3(minDist(p+eps.xyy)-minDist(p-eps.xyy),\n             minDist(p+eps.yxy)-minDist(p-eps.yxy),\n             minDist(p+eps.yyx)-minDist(p-eps.yyx))\n    );*/\n}\n\nvec3 calcOrigin(vec3 p)\n{\n    return p - calcNormal(p);\n}\n\nvec3 calcColor(vec3 p)\n{\n    p = calcOrigin(p);\n    p = vec3(p.x, 0., p.z);\n    float m = min(p.x, min(p.y, p.z));\n    p = (p + abs(m)) / 2.;\n    return normalize(p);\n}\n\nvec3 calcLight(Ray r)\n{\n    r.dir = normalize(sunPos - r.pos);\n    vec3 spot = r.pos;\n    \n    float t = minDist(r.pos);\n    for(int i = 0; i < MAX_ITERATION; ++i)\n    {\n        if(t <= MIN_DIST)\n        {\n            if(sdSphere(sunPos-r.pos, 1.) <= MIN_DIST)\n            {\n                return\n                    vec3(max(dot(calcNormal(spot),normalize(sunPos-spot)),0.0))+0.05;\n            }\n        }\n        r.pos += r.dir * t;\n        t = minDist(r.pos);\n    }\n    return vec3(0.05);\n}\n\nvec3 calcFinalColor(Ray r)\n{\n    vec3 col = calcColor(r.pos)*calcLight(r);\n    \n    for(int i = 1; i < MAX_REFLECT; ++i)\n    {\n        vec3 normal = calcNormal(r.pos);\n    \tr.dir = reflect(r.dir, normal);\n    \t\n    \tr.pos += normal*MIN_DIST;\n    \tfloat t = minDist(r.pos);\n        \n        for(int j = 0; j < MAX_ITERATION; ++j)\n        {\n            if(t >= MAX_DIST)\n                return col;\n            if(t <= MIN_DIST)\n            {\n                col += calcColor(r.pos)*0.75*calcLight(r);\n                break;\n            }\n            r.pos += r.dir * t;\n            t = minDist(r.pos);\n        }\n    }\n    return col;\n}\n\nvec3 render(Ray r)\n{\n    float t = minDist(r.pos);\n    for(int i = 0; i < MAX_ITERATION; ++i)\n    {\n        if(t >= MAX_DIST)\n            return vec3(0);\n        if(t <= MIN_DIST)\n        {\n            return calcFinalColor(r);\n        }\n        r.pos += r.dir * t;\n        t = minDist(r.pos);\n    }\n    return vec3(0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    Camera cam;\n    vec3 pos = vec3(7.*cos(iMouse.x/iResolution.x*6.28),\n                    6,\n                    -7.*sin(iMouse.x/iResolution.x*6.28));\n    setCamera(pos, -pos, vec3(0,1,0), 60.0, cam);\n\t\n    vec3 col = render(castRay(uv, cam));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}