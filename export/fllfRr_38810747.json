{"ver":"0.1","info":{"id":"fllfRr","date":"1650553871","viewed":171,"name":"Stage template","username":"Eltaurus","description":"a basic environment template with mouse camera control and rotation inertia\nUPD: now with motion blur and dithering","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["motionblur","antialiasing","dither","template","cameracontrol","inertia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//input const\nconst float fov0=40.;  //hoizontal fov, degrees\nconst int   SSAA=3;    //number of subsambples along each axis \nconst float SHUTTER=1.; //..angle as a fraction of 2 pi (=0 for no motion blur)\nconst float MBDITHER=1.; //motion blur dithering [0.,1.]\n\n//system const\nconst float pi=radians(180.);\nconst float fov=2.*tan(radians(fov0)*.5);\nconst float e=1e-4; // precision -- increase to ~1e-2 in case of bugging shadows\n\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\nconst ivec2 EULER = ivec2(2, 1);\nconst ivec2 VELOCITY = ivec2(4, 1);\n\n\nmat3 RM(float psi, float theta) {\n\n    \n    float cX = cos(theta);\n    float sX = sin(theta);\n    float cZ = cos(psi);\n    float sZ = sin(psi);\n    \n    return \n  mat3( \n         cZ, sZ, 0, //wtf\n        -sZ, cZ, 0,\n          0,  0, 1\n)*mat3(\n        1,   0,  0,\n        0,  cX, sX,\n        0, -sX, cX\n      );\n}\n\nfloat line(vec2 p1, vec2 p2, vec2 p, float dash_l,float thickness, float smoothing) {\n\n    vec2 p2p1 = p2-p1;\n    float interval = clamp(dot(p2p1,p-p1)/dot(p2p1,p2p1),0.,1.);\n\n    float dash=.5*interval/dash_l+.25;\n    float dashfunc = clamp(2.*dash_l*mod(dash,1.)-.5*dash_l,0.,dash_l)+2.*dash_l*floor(dash);\n\n    return smoothstep(thickness*(1.+smoothing),thickness*(1.-smoothing),length(p1+p2p1*dashfunc-p));\n\n}\n\n\nvec2 toComp (vec3 point) {\n    return -point.xy/point.z/fov;\n}\n\nfloat hashSin (float seed){// -> [-1,1]\n    return sin(2.4*seed); //approx golden angle\n}\n\nfloat hashSinFrac (float seed){// -> [-1,1]\n    return 2.*fract(1142.*sin(2.4*seed))-1.; \n}\n\nvoid sampleImage(out vec4 fragColor, in vec2 fragCoord, in vec3 euler)\n{\n    vec2 comp = (fragCoord-.5*iResolution.xy)/iResolution.x; //comp space x: [-.5,.5], y ...     \n    vec4 color;  \n    \n    //Camera settings\n    float psi=euler.x;\n    float theta=euler.y;\n    mat3 M=RM(psi,theta);   \n    vec3 ro=M*vec3(0,0,10);//10.*vec3(sin(psi)*sin(theta),-cos(psi)*sin(theta),cos(theta));\n    vec3 rd0=M*vec3(0,0,-1);   \n    vec3 rd=normalize(rd0+M*fov*vec3(comp,0));  \n    \n    \n    //walls setup\n    vec3 corner=vec3(5,5,1.5)*sign(rd);    \n    vec3 walls_t=(corner-ro)/rd, wall_n;\n    vec2 grid_coord;\n    if ((walls_t.x<walls_t.y || walls_t.y<0.) && (walls_t.x<walls_t.z || walls_t.z<0.) && walls_t.x>0.) {\n        grid_coord=(ro+rd*walls_t.x).yz;\n        wall_n = vec3(1,0,0);\n    }\n    else if ((walls_t.y<walls_t.x || walls_t.x<0.) && (walls_t.y<walls_t.z || walls_t.z<0.) && walls_t.y>0.) {\n        grid_coord=(ro+rd*walls_t.y).zx;\n        wall_n = vec3(0,1,0);\n    }\n    else {\n        grid_coord=(ro+rd*walls_t.z).xy;\n        wall_n = vec3(0,0,1);\n    }\n    \n    //Background\n    fragColor=vec4(0,.01,.04,0)*pow(abs(dot(wall_n,rd)),1.); //imitate AO?\n    \n        //walls grid\n    float thickness=.01,smoothness=1.,size=1.,brightness=.1;\n    fragColor+= brightness*vec4(\n    max(smoothstep(thickness*(1.+smoothness), thickness, fract(grid_coord.x/size))+\n    smoothstep(1.-thickness*(1.+smoothness), 1.-thickness, fract(grid_coord.x/size)),\n    smoothstep(thickness*(1.+smoothness), thickness, fract(grid_coord.y/size))+\n    smoothstep(1.-thickness*(1.+smoothness), 1.-thickness, fract(grid_coord.y/size)))\n    );       \n    thickness=.01,smoothness=1.,size=.5,brightness=.04;\n    fragColor+= brightness*vec4(\n    max(smoothstep(thickness*(1.+smoothness), thickness, fract(grid_coord.x/size))+\n    smoothstep(1.-thickness*(1.+smoothness), 1.-thickness, fract(grid_coord.x/size)),\n    smoothstep(thickness*(1.+smoothness), thickness, fract(grid_coord.y/size))+\n    smoothstep(1.-thickness*(1.+smoothness), 1.-thickness, fract(grid_coord.y/size)))\n    );\n\n    \n    //cage\n    vec3 verteces[8] = vec3 [8] (vec3(1,1,1),vec3(-1,1,1),vec3(1,-1,1),vec3(-1,-1,1),vec3(1,1,-1),vec3(-1,1,-1),vec3(1,-1,-1),vec3(-1,-1,-1));\n    ivec2 edges[12] = ivec2 [12] (ivec2(0,1),ivec2(0,2),ivec2(0,4),ivec2(1,3),ivec2(3,2),ivec2(2,6),ivec2(4,6),ivec2(1,5),ivec2(3,7),ivec2(5,7),ivec2(5,4),ivec2(7,6));     \n    vec3 tangent1[12] = vec3[12] (vec3(0,-1,0),vec3(0,0,-1),vec3(-1,0,0),vec3(0,0,-1),vec3(0,1,0),vec3(-1,0,0),vec3(0,0,1),vec3(1,0,0),vec3(1,0,0),vec3(0,0,1),vec3(0,-1,0),vec3(0,1,0));\n    vec3 tangent2[12] = vec3[12] (vec3(0,0,-1),vec3(-1,0,0),vec3(0,-1,0),vec3(1,0,0),vec3(0,0,-1),vec3(0,1,0),vec3(-1,0,0),vec3(0,-1,0),vec3(0,1,0),vec3(1,0,0),vec3(0,0,1),vec3(0,0,1));  \n \n         //projecting verteces into comp space\n    for (int i=0;i<(verteces.length());++i) {\n    verteces[i]=1.*transpose(M)*verteces[i]+vec3(0,0,10);\n    }\n        //dashed cage edges\n    for (int i=0;i<(edges.length());++i) {\n     fragColor+=.5*smoothstep(-.01,.01,dot(tangent1[i],rd))*smoothstep(-.01,.01,dot(tangent2[i],rd))*line(toComp(verteces[edges[i][0]]),toComp(verteces[edges[i][1]]),comp,1./21.,0.0005,.5);\n    }\n    \n    \n//    \n//\n//\n    //scene\n    color=vec4(1,.8,.2,smoothstep(.22,0.,length(comp)))+smoothstep(.15,.0,length(comp))*vec4(1,1,.9,0);//put displayed object here\n    fragColor=vec4(color.xyz*color.a+fragColor.xyz*(1.-color.a),1.-(1.-color.a)*(1.-fragColor.a));\n//\n//\n//\n     \n     \n        //overlay solid cage edges\n    color=vec4(0);   \n    for (int i=0;i<(edges.length());++i) {\n    color=max(color,(1.-smoothstep(-.01,.01,dot(tangent1[i],rd))*smoothstep(-.01,.01,dot(tangent2[i],rd)))*line(toComp(verteces[edges[i][0]]),toComp(verteces[edges[i][1]]),comp,1.,0.0007,.5));\n    }\n    fragColor+=.8*color;\n    \n    //tangents\n    //    vec3 edge_centers[12];\n    //    for (int i=0;i<(edges.length());++i) {\n    //    edge_centers[i]=.5*(verteces[edges[i][0]]+verteces[edges[i][1]]);\n    //    tangent1[i]=transpose(M)*tangent1[i];\n    //    tangent2[i]=transpose(M)*tangent2[i];\n    //    fragColor+=vec4(1,0,0,0)*line(toComp(edge_centers[i]),toComp(edge_centers[i]+.2*tangent1[i]),comp,1.,0.001,.7);\n    //      fragColor+=vec4(0,1,0,0)*line(toComp(edge_centers[i]),toComp(edge_centers[i]+.2*tangent2[i]),comp,1.,0.001,.7);\n    //    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   //  display buffer\n   //  fragColor=texelFetch(iChannel1, ivec2(fragCoord), 0);return;\n  \n  \n   vec4 euler=load(EULER);\n   vec4 v=load(VELOCITY); \n   \n   \n   vec4 subsampleColor;\n   float ss2=float(SSAA*SSAA), temporalOffset, temporalDither;\n   fragColor=vec4(0);   \n     \n   //supersampling loops\n   for (int i=0;i<SSAA;++i) {\n   for (int j=0;j<SSAA;++j) {\n       temporalDither = MBDITHER*hashSinFrac(3.*float(i+SSAA*j)+fragCoord.x+iResolution.x*fragCoord.y);\n       temporalOffset = SHUTTER*(.0-(float(i+SSAA*j)+.5+.5*temporalDither)/ss2);  //.0 = shutter phase\n       sampleImage(subsampleColor,fragCoord+(vec2(i,j)+.5)/float(SSAA)-.5, euler.xyz+temporalOffset*v.xyz);\n       fragColor+=subsampleColor;  \n   }}\n    \n   fragColor/=ss2;\n\n   //gamma correction\n   //fragColor*=3.*fragColor;\n  \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n\nconst ivec2 EULEROLD = ivec2(2, 2);\nconst ivec2 EULER = ivec2(2, 1);\nconst ivec2 VELOCITY = ivec2(4, 1);\nconst vec2 sensitivity=vec2(.003,0.00);\nconst float dissipation=.015;\nconst vec4 v0=vec4(0.005,0.,0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx=ivec2(fragCoord);\n    if ((ipx!=EULEROLD)&&(ipx!=EULER)&&(ipx!=VELOCITY)) discard;\n    \n    vec4 eulerold=load(EULEROLD);\n    vec4 euler=load(EULER); \n    vec4 v=load(VELOCITY); \n\n\n    if (iMouse.z>0.){\n    vec4 offset=vec4(sensitivity*vec2(1,-1)*(abs(iMouse.zw)-iMouse.xy),0,0);\n    v=offset-(euler-eulerold);\n    euler=eulerold+offset;\n    } else {\n    eulerold=euler;\n    euler+=v;\n    //toggle constant rotation\n    if (texelFetch( iChannel1, ivec2(32,2),0).x>0. ) {\n        v=v0+(v-v0)*(1.-dissipation);\n    } else{\n        v*=(1.-dissipation);}\n    }\n    \n    \n // old toggle \n //   if (texelFetch( iChannel1, ivec2(32,2),0).x>0. ) {\n //       euler+=vec4(0.002,0.,0,0);\n //   }\n\n\n    if (iFrame==0) {\n    v=vec4(0);\n    euler=vec4(radians(60.),radians(75.),0,0);\n    }\n    \n     \n    store(VELOCITY, v);\n    store(EULER, euler); \n    store(EULEROLD, eulerold);\n\n\n}","name":"Buffer A","description":"","type":"buffer"}]}