{"ver":"0.1","info":{"id":"3dfSD4","date":"1551253432","viewed":144,"name":"SherfeyFractal Spin Around","username":"JohnShadow","description":"SpinAround! basically the bulb version of my fractal. Less spooky too","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["private"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxsteps 100\n#define maxDist 100.0\nfloat sdf(vec3 x)\n{\n    //sphereical sdf zooming in over time.\n\t//this can use any sdf fuction, even other fractals.\n    return distance(x, vec3(0,0,0)) -3.0;\n}\nvec3 normalSphere (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( sdf(p + vec3(eps, 0, 0) ) - sdf(p - vec3(eps, 0, 0)),\n \t  sdf(p + vec3(0, eps, 0) ) - sdf(p - vec3(0, eps, 0)),\n\t  sdf(p + vec3(0, 0, eps) ) - sdf(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat fractal(vec3 pos)\n{\n\t//vec3 eye = vec3(12.0*sin(iTime), cos(iTime), cos(iTime)*12.0);\n    //sample sphere find normal for later casting onto sphere\n    float sl = sdf(pos);\n    vec3 samp = pos;\n    float l = 0.;\n    for(int i = 0; i < 10; ++i) //fractal iterations\n    {\n        samp = abs(samp) - 1.0;\n        samp /= dot(samp,samp);\n    }\n    l = (distance(samp, vec3(0,0,0))) + sl;\n\treturn l;\n}\nvec3 normal (vec3 p)\n{\n const float eps = 0.0001;\n \n return normalize\n ( vec3\n \t( fractal(p + vec3(eps, 0, 0) ) - fractal(p - vec3(eps, 0, 0)),\n \t  fractal(p + vec3(0, eps, 0) ) - fractal(p - vec3(0, eps, 0)),\n\t  fractal(p + vec3(0, 0, eps) ) - fractal(p - vec3(0, 0, eps))\n \t)\n );\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvec4 map(vec2 fragCoord)\n{\n    vec3 viewDir = rayDirection(60.0, iResolution.xy, fragCoord);\n    \n    vec3 eye = vec3(12.0*sin(iTime), cos(iTime), cos(iTime)*12.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\n    float angle = 0.5;\n    vec3 marchpos = eye, dir = worldDir, n = dir;\n    float totaldist = 0.0;\n    float steps = 0.0;\n    for(int i = 0; i < maxsteps; ++i)\n    {\n        float dist = fractal(marchpos);\n        totaldist += dist;\n        marchpos += dir * dist;\n        if(dist < 0.0001)\n        {\n\t\t\tn = normal(marchpos);\n\t\t\tbreak;\n        }\n        ++steps;\n    }\n    //lighting n dot l\n    vec3 light = vec3(0.0, 1.0, 0.5);\n    float l = max(dot(n, light)*0.5,0.1);\n    float sky = dot(n, vec3(0,-1.0,0));\n    vec3  color = sky*vec3(0.5,0.5,0.3) + (1.0-sky)*vec3(0.2,0.5,0.8);\n    if(totaldist < maxDist)\n    \treturn vec4(color * 0.5 + vec3(l) + vec3(n)*0.1, 1.0);\n    else\n        return vec4(vec3(color),1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = map(fragCoord);\n}","name":"Image","description":"","type":"image"}]}