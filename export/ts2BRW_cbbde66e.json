{"ver":"0.1","info":{"id":"ts2BRW","date":"1590040062","viewed":145,"name":"metaboze again","username":"kaiware007","description":"metaboze again","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG 6.0\n\n#define AA 1\n\n// Distance functions by iq\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc)\n{\n    vec3 q = opBendXY(p, 2.0);\n    \n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 0.5 * M_PI2) * 0.05,0.05) * sc);\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015,0.05) * sc);\n}\n\nfloat sdCheep(vec3 p, float flip, float sc)\n{\n\tp.x *= flip;\n    \n    float x = 0.05;\n    float z = -0.18;\n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(0,1,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, 100.0/sc), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, 0.0025 * sc);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, 0.0025 * sc);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -100.0/sc), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, 0.0025 * sc);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    \n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.125) * sc, vec3(0.015,0.0025,0.1) * sc, 0.0001);\n}\n\nvec2 sdBoze(vec3 p, float sc)\n{\n    // scale\n\t//p = p / sc;\n    //float s = (sc.x + sc.y + sc.z) / 3.0;\n    //float s2 = 1.0 / s;\n    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    //vec3 p2 = p / vec3(1.0,1.0,0.9);\n    //float d1 = sdRoundedCylinder(p2 + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    // ear\n    float d2 = sdEar(p, 1.0, sc);\n    d = opUnion(d, d2);\n    float d3 = sdEar(p, -1.0, sc);\n    d = opUnion(d, d3);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(p, vec3(EYE_SPACE, 0.06, 0.125) * sc, vec3( EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    float d5 = sdCapsule(p, vec3(-EYE_SPACE,0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(opUnion(d4, d5), MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(p, 1.0, sc);\n    float d8 = sdCheep(p, -1.0, sc);\n    vec2 cheep = vec2(opUnion(d7, d8), MAT_CHEEP);\n\n    // eyebrows\n    float d9 = sdEyeBrow(p, 1.0, sc);\n    float d10 = sdEyeBrow(p, -1.0, sc);\n    eye.x = opUnion(eye.x, opUnion(d9, d10));\n    \n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(1.);\n    \n    //p = rotate(p, M_PI, vec3(0,1,0));\n    //float timeSpeed = iTime * 0.5;\n    //float timeSpeed = iTime * 0.10398* M_PI2;\n    float timeSpeed = iTime * 0.1* M_PI2;\n    //float timeSpeed = iTime * 0.1* M_PI2;\n    \n    // Boze Twist\n    for(float i = 0.0; i < 8.0; i++)\n    {\n        vec3 q = p;\n        //q = rotate(q, M_PI + timeSpeed * 15.0 + i * 0.125, vec3(0,1,0));\n        //q = rotate(q, M_PI , vec3(0,1,0));\n        //q = rotate(q, M_PI + timeSpeed * 2.0, vec3(0,1,0));\n        float y = fract(8.0 + timeSpeed - i * 0.125);\n\t\tfloat size = min(y * 5.0, 1.05);\n        //float k = mod(floor(timeSpeed + i), 8.0);\n        //float k = mod(timeSpeed + i - (1.0 - size), 8.0);\n        //float k = mod(timeSpeed + i, 8.0);\n        //float k = mod(i - (1.0 - size), 8.0);\n        float k = mod(timeSpeed *4.0+ i - (1.0 - size), 8.0);\n    \tfloat angle = k * (M_PI2 * 0.125);\n        //float angle = i * (M_PI2 * 0.125);\n\t\t//float size = i * 0.125;\n        //float size = 1.0;\n\n        q = rotate(q, M_PI, vec3(0,1,0));\n        vec2 v = vec2(cos(angle), sin(angle)) * 0.5; \n    \tq.xz += v.xy;\n        //q.z -= 0.5;\n        //q.z += v.x;\n        q.y += y;\n        \n   \t \tq = rotate(q, M_PI * 0.4, vec3(v.x, 0.0, v.y));\n        float tp = min(y*3.0, 1.0);\n        q = TwistY(q, (1.0 - tp) * M_PI * 20.0);\n    \tresult = opSU(sdBoze(q, size), result, max(0.22 * tp, 0.1));\n    }\n    \n    // Background\n    //float y = fract(8.0 + timeSpeed);\n    vec3 q = opRep(p + vec3(0., iTime * 0.1 * M_PI2, 0.), vec3(1,1,1));\n    float l = sdRoundBox(q, vec3(0.75), 0.0);\n    float l2 = sdCylinder(p, vec3(0.,0.,2.25));\n    float l3 = sdCylinder(p, vec3(0.,0.,0.125));\n    //vec2 br = vec2(max(-l,l2), MAT_BG);\n    vec2 br = vec2(min(max(-l2, l), l3), MAT_BG);\n    //vec2 br = vec2(l2, MAT_BG);\n    //vec2 br = vec2(l, MAT_BG);\n    \n    result = opU(br, result);\n    \n    return result;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n///////////////////////////////////////////////////////////////////////\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 nor = norm(p);\n    vec3 sky = vec3(0);\n    if (depth > 100.0) {\n        col = sky;\n        //col = vec3(fract(iTime * 0.5), 0.0, 0.0);\n        //vec3 lig = normalize( vec3(1.0,0.2,1.0) );\n        //col = background(ray, lig);\n    } else {\n        float roughness, metalness;\n        float t = iTime * M_PI2 * 0.1;\n        float red = max(0., sin(t * 5.0));\n        //float red = 1.;\n        if(mat.y == MAT_BLACK) {\n            col = vec3(0.0 + red, 0.0, 0.0);\n            roughness = 0.8;\n            metalness = 0.0;\n        } else if(mat.y == MAT_FACE) {\n        \tcol = vec3(1.0 + red, 0.8, 0.6);\n            roughness = 0.8;\n            metalness = 0.0;\n        } else if(mat.y == MAT_BROW) {\n            col = vec3(1.0 + red, 0, 0);\n            roughness = 0.1;\n            metalness = 0.0;\n        } else if(mat.y == MAT_CHEEP) {\n            col = vec3(1.0 + red, 0.3, 0.5);\n            roughness = 0.1;\n            metalness = 0.0;\n        } else if(mat.y == MAT_BG) {\n            //col = vec3(0.4, 0.02, 0.05);\n            float e = smoothstep(abs(mod(p.y + 0.25 + t, 0.5) - 0.25), 0.0, 0.0125); \n            //float e = smoothstep(mod(abs(p.y - 0.5) + iTime * 0.5, 0.5),0.,0.025); \n            //col = e ? vec3(1.4, 0.02, 0.05) * max(0., sin(iTime * 5.0)): vec3(0.01, 0., 0.);\n            col = mix(vec3(1.4, 0.02, 0.05) * red, vec3(0.03, 0., 0.), e);\n            roughness = e > 0.0 ? 0.01 : 0.25;\n            metalness = e > 0.0 ? 0.8 : 0.1;\n        }\n\n        vec3 result = vec3(0.);\n        result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n        //result += calcAmb(p, nor, col, ray);\n        col = result;\n    }\n    return col;\n}\n\n#define MAX_MARCH 100\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    \n    int count = 0;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x <= 0.000001) {\n        \tbreak;\n        }\n        t += mat.x;\n        count++;\n    }\n    if(count == MAX_MARCH)\n    {\n        mat.y == MAT_BLACK;\n    }\n    p = p + t * ray;\n    return materialize(p, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        \n    float t = iTime * M_PI2 * 0.1047;\n\t//vec3 ro = vec3(cos(iTime)*2.0, 0.25, sin(iTime)*2.0 );\n    //vec3 ro = vec3(0.0, -1.0, -2.1);\n    //vec3 ro = vec3(0.0, -0.75, -2.1);\n    //vec3 ro = vec3(0.0, -0.75 + sin(iTime * 1.5)*0.25, -2.1);\n    vec3 ro = vec3(cos(t)*2.0, -0.75 + sin(t)*0.25, sin(t)*2.0 );\n    vec3 ta = vec3(0., -0.05, 0.);\n    \n    //mat3 c = camera(ro, ta, cos(t * 0.35)*0.25);\n    mat3 c = camera(ro, ta, cos(t*2.0)*0.25);\n    //mat3 c = camera(ro, ta, 0.);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = trace(ro, ray);\n    \n    tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}