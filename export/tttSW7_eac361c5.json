{"ver":"0.1","info":{"id":"tttSW7","date":"1590691423","viewed":172,"name":"Abstract Wave Thing","username":"bad_dreams_","description":"ðŸŒŠ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["wave","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float waveDistance(vec3 point) {\n  float amplitude = clamp(cos(iTime * 0.25) * 0.35, -0.25, 0.25);\n  float y = sin((point.x - (iTime * 0.5)) * 2.0) * amplitude;\n  float body = point.y - y;\n    \n  float box = boxDistance(point, vec3(0.0, 0.0, 0.0), vec3(20.0, 1.0, 0.25));\n  \n  return opIntersect(box, body);\n}\n\nfloat sceneDistance(vec3 point) {\n  float waveA = waveDistance(point);\n  float waveB = waveDistance(point + vec3(1.5, 0.0, -1.8));\n  float waveC = waveDistance(point + vec3(1.5, 0.0, -3.6));\n\n  float plane = boxDistance(point, vec3(0.0, -1.0, 0.0), vec3(20.0, 1.0, 20.0));\n  float troughA = boxDistance(point, vec3(0.0, 0.0, 0.0), vec3(20.0, 1.0, 0.25));  \n  float troughB = boxDistance(point, vec3(0.0, 0.0, 1.8), vec3(20.0, 1.0, 0.25));  \n  float troughC = boxDistance(point, vec3(0.0, 0.0, -3.6), vec3(20.0, 1.0, 0.25));\n    \n  vec3 studSpaceA = opRepeatX(point - vec3(iTime * 0.1, 0.2, 0.9), 1.0);\n  vec3 studSpaceB = opRepeatZ(studSpaceA, 2.0);\n  float studs = sphereDistance(studSpaceB, 0.25);\n\n  float ground = opSubtract(troughC, opSubtract(troughB, opSubtract(troughA, plane)));\n    \n  float waves = opUnion(opUnion(waveA, waveB), waveC);\n  \n  return opSubtract(studs, opUnion(waves, ground));\n}\n\nvec3 sceneNormal(vec3 point) {\n  const float epsilon = 0.005;\n  const vec3 xOffset = vec3(epsilon, 0.0, 0.0f);\n  const vec3 yOffset = vec3(0.0, epsilon, 0.0);\n  const vec3 zOffset = vec3(0.0, 0.0, epsilon);\n\n  vec3 direction = vec3(\n    sceneDistance(point + xOffset) - sceneDistance(point - xOffset),\n    sceneDistance(point + yOffset) - sceneDistance(point - yOffset),\n    sceneDistance(point + zOffset) - sceneDistance(point - zOffset)\n  );\n\n  return normalize(direction);\n}\n\nfloat ao(vec3 point, vec3 normal) {\n  float dist = 0.17;\n  float occlusion = 1.0;\n  for (int index = 0; index < 10; index += 1) {\n    occlusion = min(occlusion, sceneDistance(point + dist * normal) / dist);\n    dist *= 0.6;\n  }\n\n  return max(occlusion, 0.0);\n}\n\nfloat softShadow(vec3 origin, vec3 direction, float softness) {\n  float s = 1.0;\n  float time = 0.0;\n  for (int index = 0; index < 40; index += 1) {\n    float dist = sceneDistance(origin + direction * time);\n    s = min(s, 0.5 + (0.5 * dist) / (softness * time));\n    if (s < 0.0) { break; }\n\n    time += dist + 0.0001;\n  }\n\n  s = max(s, 0.0);\n  return s * s * (3.0 - (2.0 * s));\n}\n\nfloat sceneEnergy(vec3 point, vec3 viewDirection) {\n  // const vec3 lightDirection = normalize(vec3(2.0, 1.0, 3.0));\n  vec3 lightDirection = normalize(vec3(2.0, 1.0, cos(iTime * 0.1) * 3.0));\n  vec3 normal = sceneNormal(point);\n    \n  vec3 skin = normal * 0.005;\n\n  // Super rough reading of the rendering equation follows.\n  float incidence = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    \n  vec3 bounceDirection = reflect(viewDirection, normal);\n  float reflection = texture(iChannel0, bounceDirection).r;\n  float diffuse = texture(iChannel1, normal).r;\n    \n  float fresnel = 1.0 - abs(dot(viewDirection, normal));\n  float hemisphere = mix(diffuse, reflection, fresnel * 0.3) * 0.5;\n  float occlusion = ao(point, normal) * 0.5 + 0.5;\n  \n  vec3 halfVector = normalize(lightDirection + -viewDirection);\n  float normalDotHalf = max(dot(normal, halfVector), 0.0);\n  float specular = pow(normalDotHalf, 0.8) * 0.4;\n\n  float shadow = softShadow(point + skin, lightDirection, 0.15);\n  return (hemisphere * occlusion * (1.0 - ((1.0 - shadow) * 0.5)))\n    + (incidence * shadow * occlusion)\n    + (specular * shadow);\n}\n\nvec3 sceneColor(vec2 uv) {\n  vec3 origin = vec3(1.0, 1.45, -1.4);\n  vec3 direction = normalize(vec3(uv.x, uv.y, 0.9));\n      \n  mat4 yaw = rotateY(3.14159 * 0.1);\n  mat4 pitch = rotateX(-3.14159 * 0.27);\n  direction = (yaw * pitch * vec4(direction, 0.0)).xyz;\n\n  bool hit = false;\n\n  vec3 testPoint;\n  for (float time = 0.0; time < 6.5; time += 0.0001) {\n    testPoint = origin + direction * time;\n    float dist = sceneDistance(testPoint);\n    time += dist;\n\n    if (dist < 0.0001) {\n      hit = true;\n      break;\n    }\n  }\n\n  return hit\n    ? vec3(sceneEnergy(testPoint, direction))\n    : vec3(0.0);\n}\n\nvec2 coordToUv(vec2 coord) {\n  return (coord - (iResolution.xy * 0.5)) / iResolution.y;\n}\n\nfloat vignette(vec2 uv) {\n  return smoothstep(0.8, 0.1, length(uv) / 2.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - (iResolution.xy * 0.5)) / iResolution.y;\n  vec2 coord = fragCoord + vec2(0.5);\n  \n  // MSAA Offsets.\n  float a = (3.0 / 8.0);\n  float b = (1.0 / 8.0);\n\n  vec3 acc = vec3(0.0);\n  acc += sceneColor(coordToUv(coord + vec2(-a, b)));\n  acc += sceneColor(coordToUv(coord + vec2(-b, -a)));\n  acc += sceneColor(coordToUv(coord + vec2(a, -b)));\n  acc += sceneColor(coordToUv(coord + vec2(b, a)));\n  vec3 color = acc / 4.0;\n    \n  float exposure = 0.65;\n  vec3 tonemapped = hejl(color * exposure, 1.0);\n  vec3 vignetted = tonemapped * vignette(uv);\n  \n  vec3 gammaCorrected = pow(vignetted, vec3(1.0 / 2.2));\n  \n  fragColor = vec4(gammaCorrected, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 normalToColor(vec3 direction) { return (direction + 1.0) * 0.5; }\nfloat opUnion(float a, float b) { return min(a, b); }\nfloat opSubtract(float a, float b) { return max(-a, b); }\nfloat opIntersect(float a, float b) { return max(a, b); }\nvec3 opRepeatX(vec3 point, float period) {\n  float adjustedPeriod = (0.5 * period);\n  vec3 repeated = mod(point + adjustedPeriod, period) - adjustedPeriod;\n  return vec3(repeated.x, point.y, point.z);\n}\n\nvec3 opRepeatZ(vec3 point, float period) {\n  float adjustedPeriod = (0.5 * period);\n  vec3 repeated = mod(point + adjustedPeriod, period) - adjustedPeriod;\n  return vec3(point.x, point.y, repeated.z);\n}\n\nmat4 rotateX(float angle) {\n  float x = cos(angle);\n  float y = sin(angle);\n    \n  return mat4(\n    1, 0, 0, 0,\n    0, x, -y, 0,\n    0, y, x, 0,\n    0, 0, 0, 1\n  );\n}\n\nmat4 rotateY(float angle) {\n  float x = cos(angle);\n  float y = sin(angle);\n    \n  return mat4(\n    x, 0, y, 0,\n    0, 1, 0, 0,\n    -y, 0, x, 0,\n    0, 0, 0, 1\n  );\n}\n\n// https://twitter.com/jimhejl/status/633777619998130176\nvec3 hejl(vec3 color, float whitePoint) {\n    vec4 vh = vec4(color, whitePoint);\n    vec4 va = 1.425 * vh + 0.05;\n    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;\n    return vf.rgb / vf.www;\n}\n\nfloat boxDistance(vec3 point, vec3 position, vec3 extents) {\n  vec3 adjusted = point - position;\n  vec3 d = abs(adjusted) - extents;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sphereDistance(vec3 point, float radius) {\n  return length(point) - radius;\n}","name":"Common","description":"","type":"common"}]}