{"ver":"0.1","info":{"id":"WlV3zG","date":"1579225446","viewed":71,"name":"Ray Marching - Comini","username":"comini","description":"Ray marching shader ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","graphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvec4 qsqr( in vec4 a ) // square a quaterion\n{\n    return vec4( a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,\n                 2.0*a.x*a.y,\n                 2.0*a.x*a.z,\n                 2.0*a.x*a.w );\n}\n\nfloat map(in vec3 p, in vec4 c)\n{\n    vec4 z = vec4(p,0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n\n\n    float n = 1.0;\n    for( int i=0; i<11; i++ )\n    {\n        // dz -> 2·z·dz, meaning |dz| -> 2·|z|·|dz|\n        // Now we take thr 2.0 out of the loop and do it at the end with an exp2\n        md2 *= mz2;\n        // z  -> z^2 + c\n        z = qsqr(z) + c;  \n\n        mz2 = dot(z,z);\n        if(mz2>4.0) break;\n        n += 1.0;\n    }\n\n    return 0.25*sqrt(mz2/md2)*exp2(-n)*log(mz2);  // d = 0.5·|z|·log|z| / |dz|\n}\n\n\nfloat sceneSDF(vec3 p)\n{\n    vec3 center = vec3(-sin(iTime)*0.2, 1, 1);\n    float radius = 0.1;\n    float sphere = length(p - center) - radius;\n    \n    vec3 boxCenter = vec3(sin(iTime)*0.2, 1, 1);\n    vec3 q = abs(p - boxCenter) - vec3(0.1);\n  \tfloat box = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    \n    return smin(box, sphere, 0.2);\n    \n    // float time = iTime*.15;\n    // vec4 c = 0.45*cos( vec4(0.5,3.9,1.4,1.1) + time*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n    \n    // return map(p, c);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n    \n{  \n    vec3 rayOrigin = vec3(0, 1, 0);\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.x;\n    \n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    vec3 lightPosition = vec3(sin(iTime), 1, cos(iTime));\n    vec3 lightColor = vec3(1);\n    \n    vec3 lightDirection = normalize(lightPosition - vec3(uv, 0));\n    \n    vec3 sphereColor = vec3(1, 0, 0);\n\n    vec3 ambient = 0.2 * lightColor;\n   \n    float depth = 0.;\n    \n    for (int i = 0; i < 100; i++) {\n        \n        vec3 point = rayOrigin + depth * rayDirection;\n        float dist = sceneSDF(point);\n        \n        if (dist < EPSILON) {\n            float diff = max(dot(estimateNormal(point), lightDirection), 0.0);\n\t\t\tvec3 diffuse = diff * lightColor;\n            \n            fragColor = vec4((ambient + diffuse) * sphereColor, 1);\n            return;\n        }\n        \n        depth += dist;\n    }\n    \n    fragColor = vec4(0);\n    \n}\n                                  ","name":"Image","description":"","type":"image"}]}