{"ver":"0.1","info":{"id":"7dSyWK","date":"1644339139","viewed":163,"name":"Ray Marching trainings","username":"jin_x","description":"Ray Marching tests","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time (iTime*.5)\n#define TAU 6.28318530718\n#define USE_TEXTURE\n#define TEX_ANGULAR\n#define PLUMP .015*sint(1.,0.,1.)\n#define TWIST .6\n\n////////////////////////////////////////////////////////////////////////////////\n// SIGNED DISTANCE FUNCTIONS                                                  //\n////////////////////////////////////////////////////////////////////////////////\n\n// SDFs are taken from https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCone(vec3 p, vec2 c, float h)\n{\n    float q = length(p.xz);\n    return max(dot(c.xy, vec2(q,p.y)), -h-p.y);\n}\n\nfloat sdDeathStar(vec3 p2, float ra, float rb, float d)\n{\n    // sampling independent computations (only depend on shape)\n    float a = (ra*ra - rb*rb + d*d) / (2.*d);\n    float b = sqrt(max(ra*ra-a*a, 0.));\n\t\n    // sampling dependant computations\n    vec2 p = vec2(p2.x, length(p2.yz));\n    if( p.x*b-p.y*a > d*max(b-p.y,0.0) )\n        return length(p-vec2(a,b));\n    else\n        return max( (length(p          )-ra),\n                   -(length(p-vec2(d,0))-rb));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdBoxFrame(vec3 p, vec3 b, float e)\n{\n    p = abs(p) - b;\n    vec3 q = abs(p+e) - e;\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.)) + min(max(p.x, max(q.y, q.z)), 0.),\n        length(max(vec3(q.x, p.y, q.z), 0.)) + min(max(q.x, max(p.y, q.z)), 0.)),\n        length(max(vec3(q.x, q.y, p.z), 0.)) + min(max(q.x, max(q.y, p.z)), 0.));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// EXTRA FUNCTIONS (INCLUDING MAIN SDF)                                       //\n////////////////////////////////////////////////////////////////////////////////\n\n// Sine in range from vmin to vmax\nfloat sinr(float x, float vmin, float vmax)\n{\n    return (sin(x)*.5+.5) * (vmax-vmin) + vmin;\n}\n\n// Sine of time with specified speed in range from vmin to vmax\nfloat sint(float speed, float vmin, float vmax)\n{\n    return sinr(time*speed, vmin, vmax);\n}\n\n// Sine of time with specified speed\nfloat sint(float speed)\n{\n    return sin(time*speed);\n}\n\n// Rotate 2D point p by angle a\nvec2 rot2(vec2 p, float a)\n{\n    float sin_a = sin(a);\n    float cos_a = cos(a);\n    return vec2(p.x*cos_a - p.y*sin_a, p.x*sin_a + p.y*cos_a);\n}\n\n// Rotate 3D point p by angles time*a, time*b, time*c plus c\nvec3 rotate(vec3 p, vec3 a, float c)\n{\n    p.xz = rot2(p.xz, time*a.y + c);  // around axis Y\n    p.yz = rot2(p.yz, time*a.x + c);  // around axis X\n    p.xy = rot2(p.xy, time*a.z + c);  // around axis Z\n    return p;\n}\n\nfloat rand(vec3 p)\n{\n    return length(sin(p*50.));\n}\n\n// Signed Distance Function of object(s) with output of point near object and object index (0 or 1)\nfloat sdf(vec3 p1, vec3 p2, out vec3 po, out int index)\n{\n    // Calculate SDFs of 2 objects\n    float obj1 = min(sdTorus(p1, vec2(sint(2.5, .05, .2), sint(5.5, .01, .03))),\n                     sdBoxFrame(p1, vec3(sint(2., .1, .2)), sint(3.5, .01, 0.025)))\n                     - rand(p1)*PLUMP;\n    float obj2 = max(sdBox(p2, vec3(.15)),\n                     -sdSphere(p2, sint(1.5, .17, .23)))\n                     //-sdDeathStar(p + m*1.5, .2, .18, sint(1., .05, .3)))\n                     - rand(p2)*PLUMP;\n\n    // Store point near object and object index\n    if (obj1 < obj2) { po = p1; index = 0; }\n    else { po = p2; index = 1; }\n\n    // Return combined SDF\n    return min(obj1, obj2);\n}\n\n// Get texture value (0..1) at point on the object\nfloat texture_at(vec3 p)\n{\n#ifdef TEX_ANGULAR\n    vec3 texpos = mod(vec3(atan(p.z, p.y), atan(p.z, p.x), atan(p.y, p.x)), TAU) / TAU;\n#else\n    vec3 texpos = mod(p, 1.);\n#endif\n    ivec3 itexpos = ivec3(fract(texpos*10.) * 32.);  // position 0..31\n    p = abs(p);\n    int itex;  // texture value (0..31)\n    if (p.x > p.y && p.x > p.z) { itex = itexpos.y^itexpos.z; }  // side of x\n    else if (p.y > p.x && p.y > p.z) { itex = itexpos.x^itexpos.z; }  // side of y\n    else  { itex = itexpos.x^itexpos.y; }  // size of z\n    return float(itex) / 32.;  // normalizing to 0..1\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// MAIN CODE                                                                  //\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (x = -xres/yres*0.5..xres/yres*0.5, y = -0.5..0.5)\n    vec2 xy = fragCoord/iResolution.xy;\n    vec2 uv = xy - .5;\n    uv *= vec2(max(iResolution.x/iResolution.y, 1.), max(iResolution.y/iResolution.x, 1.));\n\n    // Background with blue rays\n    float ray_col = sinr(atan(uv.y, uv.x)*20. + time*5. + sin(length(uv)*30.)*TWIST*sint(1.5), .25, .75);\n    vec3 col = vec3(0, ray_col*.1, ray_col) * length(texture(iChannel0, xy));\n\n    // Ray Marching preparations\n    const int iters = 64;  // maximal number of iterations\n    const float dmax = 3.;  // maximal distance from ray origin point\n    const vec3 pos_speed = vec3(2, 1.5, 2.5);  // position change speeds\n    const vec3 rot_speed = vec3(1.2, 1., 1.5);  // ray point rotation speeds (reversed rotation of objects)\n    float twist = length(uv) * TWIST;  // twist (distortion) of objects\n\n    vec3 rp = vec3(0, 0, -1.2);  // ray origin point coordinate\n    vec3 rd = normalize(vec3(uv, 1));  // ray direction\n\n    // Position of objects relative to center (applied before rotation)\n    vec3 pos = vec3(sint(pos_speed.x)*1.5, sint(pos_speed.y), sint(pos_speed.z)) * .2;\n\n\n    // Ray Marching\n    for (int i = 0; i < iters; ++i) {\n        // Rotate point around objects\n        vec3 rp1 = rotate(rp - pos, rot_speed, twist);      // rotate (and twist) ray point for object 1 (rotate object 1 if fact)\n        vec3 rp2 = rotate(rp + pos, -rot_speed*2., twist);  // rotate (and twist) ray point for object 2 with double speed (rotate object 2 if fact)\n        // Calculate\n        int index;  // object index\n        vec3 po; // point near object (almost on object)\n        float dist = sdf(rp1, rp2, po, index);  // get nearest distance to objects, point near object and object index\n        if (dist > dmax) { break; }  // too far (ray goes out of objects)\n        if (dist < .001) {  // close enough (hit to object)\n            float intensity = 1. - float(i)*.05;\n#ifdef USE_TEXTURE\n            float tex = texture_at(po) * 2.;\n#else\n            float tex = 0.;\n#endif\n            if (index == 0) {  // object 1\n              col = vec3(intensity, intensity * tex, 0);  // i=0 - most bright color, i=iters-1 - black\n            } else {  // object 2\n              col = vec3(intensity * tex, intensity, 0);\n            }\n            break;\n        }\n        rp += rd * dist;  // move ray point in direction 'rd' by distance 'dist'\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}