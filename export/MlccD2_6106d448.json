{"ver":"0.1","info":{"id":"MlccD2","date":"1534098165","viewed":194,"name":"Estimating Normal","username":"theGiallo","description":"Estimating normal of points with least squares of 5x5 neighborhood.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["normal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float H_SCALE = iResolution.y * 0.5 * sphere_radius;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 p = texture( iChannel0, uv );    \n\n    vec2  A[] = vec2 [25](vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),\n                          vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),\n                          vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),\n                          vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),\n                          vec2(0),vec2(0),vec2(0),vec2(0),vec2(0)  );\n    float b[] = float[25](0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0  );\n\tfor ( int i = -2; i != 3; ++i )\n    {\n\t\tfor ( int j = -2; j != 3; ++j )\n    \t{\n\t\t\tvec2 p_c = fragCoord + vec2( i, j );\n\t\t\tvec2 p_uv = p_c / iResolution.xy;\n            vec4 p_v = texture( iChannel0, p_uv, 0.0 );\n            int I = i + 2;\n            int J = j + 2;\n            int idx = I * 5 + J;\n            vec3 v = vec3( -i, -j, p_v.r * H_SCALE );\n\t\t\tA[idx] = v.xy;\n            b[idx] = v.z - p.z * H_SCALE;\n    \t}\n    }\n    \n    mat2 AT_A = mat2(0);\n   \tfor ( int i = 0; i != 25; ++i )\n    {\n    \tfor ( int c = 0; c != 2; ++c )\n        {\n            for ( int r = 0; r != 2; ++r )\n    \t\t{\n\t\t        AT_A[c][r] += A[i][r] * A[i][c];\n\t\t\t}\n        }\n    }\n    \n    mat2 iAT_A = inverse( AT_A );\n\n\n    vec2 noz = vec2(0,0);// = inverse( AT_A ) * AT * b;\n    \n\tfor ( int i = 0; i != 25; ++i )\n    {\n        for ( int c = 0; c != 2; ++c )\n    \t{\n\t    \tfor ( int r = 0; r != 2; ++r )\n\t    \t{\n                noz[c] += iAT_A[c][r] * A[i][c] * b[i];\n            }\n        }\n    }\n    \n    vec3 n;\n    vec2 noz2 = noz * noz;\n    n.z = 1.0 / ( noz2.x + noz2.y + 1.0 );\n    n.xy = noz * n.z;\n    n = normalize( n ) * 0.5 + 0.5;\n\n    if ( iMouse.x < fragCoord.x )\n    {\n        fragColor = p;\n    } else\n    {\n        if (  HAS_TO_SHOW_DEBUG_SPHERE\n           && ( ( uv.y <= 0.5 && iMouse.y > iResolution.y * 0.5 )\n             || ( uv.y > 0.5 && iMouse.y <= iResolution.y * 0.5 )\n              )\n           )\n        {\n            fragColor.rgb = sphere( vec2( fragCoord ), iResolution.xy ).xyz * 0.5 + 0.5;\n        } else\n        {\n    \t\t// Output to screen\n    \t\tfragColor = vec4(n,1.0);\n        }\n    }\n}\n\n\n\n#if 0\n// OLD ONE NOT WORKING CORRECTLY\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float H_SCALE = 1.0 / 140.0;// iResolution.y / 2.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3  A[] = vec3 [25](vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),\n                          vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),\n                          vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),\n                          vec3(0),vec3(0),vec3(0),vec3(0),vec3(0),\n                          vec3(0),vec3(0),vec3(0),vec3(0),vec3(0)  );\n    float b[] = float[25](0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0  );\n\tfor ( int i = -2; i != 3; ++i )\n    {\n\t\tfor ( int j = -2; j != 3; ++j )\n    \t{\n\t\t\tvec2 p_c = fragCoord + vec2( i, j );\n\t\t\tvec2 p_uv = p_c / iResolution.xy;\n            vec4 p_v = texture( iChannel0, p_uv, 0.0 );\n            int I = i + 2;\n            int J = j + 2;\n            int idx = I * 5 + J;\n\t\t\tA[idx] = vec3( -i, -j, 1 );\n            b[idx] = p_v.r * H_SCALE;\n    \t}\n    }\n    \n    mat3 AT_A = mat3(0);\n   \tfor ( int i = 0; i != 25; ++i )\n    {\n    \tfor ( int c = 0; c != 3; ++c )\n        {\n            for ( int r = 0; r != 3; ++r )\n    \t\t{\n\t\t        AT_A[c][r] += A[i][r] * A[i][c];\n\t\t\t}\n        }\n    }\n    \n    mat3 iAT_A = inverse( AT_A );\n\n\n    vec3 n = vec3(0,0,0);// = inverse( AT_A ) * AT * b;\n    \n\tfor ( int i = 0; i != 25; ++i )\n    {\n        for ( int c = 0; c != 3; ++c )\n    \t{\n\t    \tfor ( int r = 0; r != 3; ++r )\n\t    \t{\n                n[c] += iAT_A[c][r] * A[i][c] * b[i];\n            }\n        }\n    }\n    \n    //n.z /= 140.0; // NOTE(theGiallo): this seems to fix the normal value\n    \n    // NOTE(theGiallo): z seems to have this value at peak\n    //n.z /= 337.48442;\n    //n.xy *= 0.0;\n    //n.xyz = vec3(n.z > 337.48442 ? 1.0 : 0.0);\n    \n    n = normalize( n ) * 0.5 + 0.5;\n\n    if ( iMouse.x < fragCoord.x )\n    {\n        fragColor = texture( iChannel0, uv );\n    } else\n    {\n        if (  ( uv.y < 0.5 && iMouse.y > iResolution.y * 0.5 )\n           || ( uv.y > 0.5 && iMouse.y < iResolution.y * 0.5 ) )\n        {\n            fragColor.rgb = sphere( vec2( fragCoord ), iResolution.xy ).xyz * 0.5 + 0.5;\n        } else\n        {\n    \t\t// Output to screen\n    \t\tfragColor = vec4(n,1.0);\n        }\n    }\n}\n\n#endif","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 c = texture( iChannel0, uv );\n    #if 0\n    fragColor = c;\n    #elif 0\n    fragColor.xyz = vec3(length(c.xyz)/3.0);\n    #else\n    fragColor.xyz = vec3((c.r+c.g+c.b)/3.0);\n    #endif\n    \n    \n    if ( HAS_TO_SHOW_DEBUG_SPHERE )\n    {\n    \tvec4 sph = sphere( vec2( fragCoord ), iResolution.xy );\n    \tfragColor.rgb = vec3(sph.w);\n\t}\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define KEY_SPACE 0x20\n#define KEYBOARD_CHANNEL iChannel1\n#define HAS_TO_SHOW_DEBUG_SPHERE ( texelFetch( KEYBOARD_CHANNEL, ivec2(KEY_SPACE,2),0 ).x > 0. )\n\nfloat sphere_radius = 0.9;\nvec4 sphere( vec2 fragCoord, vec2 iResolution )\n{\n    vec4 ret;\n    vec2 uvc = ( fragCoord - iResolution.xy * 0.5 ) / ( iResolution.y * 0.5 );\n    float r = sphere_radius;\n    float d = min( r, length(uvc)  ) / r;\n    ret.w = 1.0 - d * d;\n    ret.xy = uvc;\n    ret.z = ret.w;\n    float _in = float( ret.w > 0.0 );\n    ret.xyz = normalize( ret.xyz ) * _in + vec3(0,0,1) * ( 1.0 - _in );\n    \n    return ret;\n}","name":"Common","description":"","type":"common"}]}