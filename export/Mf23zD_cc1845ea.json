{"ver":"0.1","info":{"id":"Mf23zD","date":"1703928675","viewed":28,"name":"light in space","username":"nayk","description":"stars, colorful, neon","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["colorful","stars","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* originals https://www.shadertoy.com/view/DtGyWh https://www.shadertoy.com/view/4tyfWy https://www.shadertoy.com/view/wllcDM*/\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(23,13,21))*.5+.5)\nconst float pi = acos(-1.);\nconst float tau = 2.*pi;\n\nmat2 rot(float a){\n    float c=cos(a);float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat light(vec2 p, float t) {\n       \n    p.y *= 2.7;\n      \n    float d = length(p);\n\n    p.x *= p.y*7.;\n\n    float a = sin(t*.7 + d*6.5);\n    \n    p *= a*abs(sin(t*.3 + d*3.1))*pow(abs(sin(t*.3)), 2.);\n        \n    float c = .0005/(sin(length(p*.3)));\n    \n    return pow(c, .6);\n}\n\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define PHI 1.618033988749895\n#define BUMP_EPS 0.004\n#define FAR 100.\n\n\nfloat tt, g_mat;\nfloat closest = FAR;\n\n\n\n\nfloat fadeInOut(float t1, float t2, float fadeTime) {\n    return smoothstep(t1, t1+fadeTime, iTime)-smoothstep(t2-fadeTime, t2, iTime);\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n// Amazing fractal texture from jarble https://www.shadertoy.com/view/csl3zl\nvec2 triangle_wave(vec2 a){\n    \n    vec2 a2 = vec2(1.,0.5),\n    \n    a1 = a-a2;\n    \n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nfloat getDepth(sampler2D sampler, vec2 uv) {\n    uv = clamp(uv, vec2(.0), vec2(1.));\n    vec2 eps = vec2(0.004, 0); \n    float vc = texture(sampler, uv).r;\n    float vu = texture(sampler, uv-eps.yx).r;\n    float vb = texture(sampler, uv+eps.yx).r;\n    float vr = texture(sampler, uv+eps.xy).r;\n    float vl = texture(sampler, uv-eps.xy).r;\n    \n    return clamp((vc + vu + vb + vr + vl)/5., 0., .4);\n    \n}\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\nvec3 kalei(vec3 p) {\n    float iter = 3.;\n\n\n    float s= 1.;\n    for(float i=0.; i< iter; i++) {\n        p = abs(p);  \n        p.xz *= rot(i/iter*PI+.2*tt);\n        p -= .1;\n         \n    }\n\n    return clamp(p, -1e5, 1e5);\n\n}\n\n\n// n-fold symmetry by mla\nvec2 foldSym(vec2 p, float N) {\n\n    float t = atan(p.x,-p.y);\n    t = mod(t+PI/N,2.0*PI/N)-PI/N;\n    return length(p)*vec2(cos(t),sin(t));\n}\n\nvec3 transform(vec3 p) {\n\n    p *= 1.5;\n    \n    p.xy = foldSym(p.xy, 6.);\n    p.xy = abs(p.xy)-0.25*SIN(.3*tt);\n\n    p = kalei(p);\n    \n p.z+=(iTime);\n    p.yz *= rot(PI*.5);\n    p.xz *= rot(.2*tt);\n\n    float r = 1.;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n    \n\n    float rev = 2.;\n    float a = atan(p.z, p.x);\n    \n \n    cp *= rot(rev*a+.3*tt);\n    cp= abs(cp) - mix(.4, 1., SIN(tt));\n    cp= mix(cp, abs(cp) - .2, smoothstep(10., 11., iTime));\n    cp *= rot(.5*tt);\n\n\n    return vec3(cp, p.z);\n}\n\nvec3 transform2(vec3 p) {\n\n    p *= .8;\n\n    p.xy = foldSym(p.xy, 3.); \n    p.xy = abs(p.xy)-0.3*SIN(-.3*tt);  \n    p.yz *= rot(PI*.25);\n    \n\n    float r = 1.;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n \n\n    float rev = 1.;\n    float a = atan(p.z, p.x);\n    \n \n    cp *= rot(rev*a+.3*tt);\n    cp= abs(cp) - mix(.4, 1., SIN(tt));\n    // cp=abs(cp) - .5;\n    cp *= rot(-.5*tt);\n\n    return vec3(cp, p.z);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp((a-b)/k * .5 + .5, 0.0, 1.0);\n  return mix(a, b, h) - h*(1.-h)*k;\n}\n\nfloat map(vec3 p) {   \n  \n    vec3 bp = p;\n    float edge = 0.05;\n   \n \n   \n    vec2 cp = transform(p).xy;\n    vec2 cp2 = transform2(p).xy;\n   \n    float dr = rect(cp.xy, vec2(.3, .3), edge);\n    float dr2 = rect(cp2.xy, vec2(.08), 0.02);\n   \n    float d = smin(dr, dr2,.8);\n    \n    g_mat = dr < dr2 ? 0. : 1.;\n    \n    return .5*d;\n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\nfloat bumpSurf3D( in vec3 p){\n\n    p.z += .3*tt;\n    p = abs(mod(p*4., 2.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n\n\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const float eps = BUMP_EPS;\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = vec3( bumpSurf3D(vec3(p.x-eps, p.y, p.z))-ref,\n                      bumpSurf3D(vec3(p.x, p.y-eps, p.z))-ref,\n                      bumpSurf3D(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n\t\n}\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvec2 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    \n    \n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n        closest = min(closest, d/t);\n        if(abs(d) < 0.0001 || t > FAR) break;\n \n        t += d;\n        p += rd*d;\n       \n    }\n    \n    return vec2(t, mat);\n}\n\nfloat n21(vec2 p) {\n      return fract(sin(dot(p, vec2(524.423,123.34)))*3228324.345);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0., 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n}\nfloat glory_noble_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec4 O2=O;\n    \n    vec2 p = (C-.5*iResolution.xy)/iResolution.y;\n     \tvec2 uv = (C - .5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n  tt = .5*iTime;\n    vec3 ro = vec3(uv*6.,-4.),\n          rd = vec3(0,0,1.),\n          lp = vec3(3., 0., -2),\n          lp2 = vec3(-3., 0., -2);\n\n    \n   \n       \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.165,0.208,0.298);\n    vec3 c2 = vec3(0.180,0.337,0.337);\n    \n    // light color\n    vec3 lc1 = vec3(0.573,0.424,0.976);\n    vec3 lc2 = vec3(0.573,0.922,0.969);\n    \n    \n    // currently only one pass\n    for(float i = 0.; i < 1.; i++) {\n        float steps = i > 0. ? 50. : 250.;\n        vec2 rm = raymarch(ro, rd, steps);\n        mat = rm.y;\n        \n        vec3 p = ro + rm.x*rd;\n        \n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                                e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n\n\n        \n        if(mat == 1.) {\n        \n            vec3 pt = transform2(p);\n            vec3 np = transform2(n);\n            n = doBumpMap(pt, n, mix(0., .001, length(p.xy)-.5));\n        }\n    \n     \n        if(rm.x < 50.) {\n        \n            vec3 l = normalize(lp-p);\n            vec3 l2 = normalize(lp2-p);\n            float dif = max(dot(n, l), .0);\n            float dif2 = max(dot(n, l2), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n\n            float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n            vec3 n2 = n;\n            n2.xy += noise(p.xy) * .5 - .025;\n            n2 = normalize(n2);\n            float height = atan(n2.y, n2.x);\n\n            vec3 iri = spectral_zucconi6(height*1.11)*smoothstep(.8, .2, abs(n2.z))-.02;\n       \n          \n            col += dif*lc1*.5 + .5*dif2*lc2 + .5*iri ;\n           \n          \n            if(mat > 0.) {\n                n += .4*texture(iChannel1, n.xy*200.).rgb;\n                rd = reflect(rd, n);\n                \n               // rd.yz *= rot(PI*.8);\n         \n              \n                \n            \n\n    \n              \n            } \n            if(mat == 1.)\n              col = mix(col, col*spectral_zucconi6(p.z*.2+length(p.xy*.2)*.2+.05*tt), .95);\n            if(mat == 0.) \n              col = mix(col, col*(mix(.6, .0, length(p*.5)-.3+.3*sin(tt))+vec3(1.000,0.506,0.239)*spectral_zucconi6(length(p.xy*.4)+.6+.1*tt)), 1.);\n\n        } else {\n            col =  mix(c1-.2, c2, (.3-pow(dot(uv, uv), .8)))*.2+.04; // background\n            // outer glow (inspired from https://www.shadertoy.com/view/ldB3Rz)\n            float f = 1.0 - clamp(closest * 0.5, 0.0, 1.0);\t\t\n\n            float glowAmount = 0.0;\n       \n            glowAmount +=  pow(f, 400.0) * (0.08+.1*SIN(tt));\n            vec3 glowColor = spectral_zucconi6(length(p.xy*.2)+.6);\n            col += glowColor * glowAmount;\n        } \n    \n    }\n\n    \n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv)); // dithering\n    \n    col *= 1.8;\n    col *= mix(.2, 1., (1.3-pow(dot(uv, uv), .5))); // vignette\n    col = pow(col, vec3(.7)); // gamma\n   \n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n    O2 = vec4(glory_noble_star(uv,anim) * vec3(0.55,0.5,0.55)*.3, 1.0);\n    O+=O2;\n    // anim between 0.9 - 1.1\n \n    \n    for(int i=0;i<12;i++) {\n        col[i] += light(p, -iTime + float(i)*.03);\n    }\n    \n    p.xy = p.yx;\n    \n    for(int i=0;i<12;i++) {\n        col[i] += light(p, -iTime + float(i)*.03);\n    }\n    \n  \n    vec3 nat,q,r=iResolution,\n    \n    d2=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,f=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(f*.1),sin(.8))*1./e/8e3\n    )\n    {\n        nat=f*d2;\n        \n        a=23.;\n        p=mod(p-a,a*2.)-a;\n        s=3.;\n        for(int i=0;i++<8;){\n             nat=.3-abs( nat);\n           \n             nat.x< nat.z? nat=nat.zyx:nat;\n             nat.z< nat.y? nat= nat.xzy: nat;\n             nat.y< nat.x? nat= nat.zyx: nat;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n             nat=abs( nat)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*cos(iTime*.3))*3.,\n                   100,\n                    5.+cos(iTime*.5)*5.\n                 )*col+O2.xyz;\n         }\n       //  g+=e=length(p.yz)/s;\n         f+=e=length( nat.yx)/s;\n    }\n    \n}","name":"Image","description":"","type":"image"}]}