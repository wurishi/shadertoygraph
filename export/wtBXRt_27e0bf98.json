{"ver":"0.1","info":{"id":"wtBXRt","date":"1566745777","viewed":854,"name":"LiveCodingPractice008(1h)","username":"Hirai_worthless","description":"1hour is too short!!!!!!!!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat PI = 3.14159265;\n\nfloat genTerra(vec2 uv){\n\treturn sin(uv.x  /2. + iTime / 2.) * sin(uv.y / 2. + iTime / 2.) * 0.5;\n}\n\nmat2 genRot(float v){\n\treturn mat2(cos(v),-sin(v),sin(v),cos(v));\n}\n\nfloat map(vec3 p){\n\tfloat terrain = -abs(-p.y)-(-2. + genTerra(p.xz));\n\t\n\tvec3 q = p;\n\tvec3 r = p;\n\tvec3 s = p;\n\tq.y += mod(iTime * sign(p.x -1.0) + q.z / 5.,2.);\n\tq.xz = (fract(q.xz / 3. + 0.5) - 0.5) * 3.; \n\tq.y *= sign(p.x - 1.0);\n\tr.xz = (fract(r.xz / 3. + 0.5) - 0.5) * 3.; \n\ts.x += mod(iTime * sign(p.y),2.);\n\ts.x *= sign(p.y);\n\ts.y = abs(s.y);\n\ts.y += 2.;\n\ts.z += 1.5;\n\ts.yz = (fract(s.yz / 3. + 0.5) - 0.5) * 3.; \n\tq.y = (fract(q.y / 2. + 0.5) - 0.5) * 2.; \n\ts.x = (fract(s.x / 2. + 0.5) - 0.5) * 2.;\n\tfloat sp = min(length(q) - 0.35,length(q - vec3(0.,0.8,0.)) - 0.15);\n\tsp = min(sp, max(length(q.xz) - 0.05,abs(q.y - 0.4) - 0.5));\n\tfloat sp2 = min(length(s) - 0.35,length(s - vec3(0.8,0.,0.)) - 0.15);\n\tsp2 = min(sp2, max(length(s.yz) - 0.05,abs(s.x - 0.4) - 0.5));\n\tsp = min(sp,sp2);\n\tfloat hole = length(r.xz) - 3. * (1. / (1. +  abs(r.y) * abs(r.y)));\n\tfloat cliff = min(abs(r.x) - 0.25,abs(r.z) - 0.25);\n\tterrain = max(terrain,-hole);\n\tterrain = max(terrain,-cliff);\n\treturn min(terrain,sp);\n}\n\nvec3 getNormal(vec3 p){\n\tvec3 x = dFdx(p);\n\tvec3 y = dFdy(p);\n\treturn normalize(cross(x,y));\n}\n\nvec4 trace(vec3 o,vec3 r){\n\tvec4 data;\n\tfloat t = 0.;\n\tfor(int i = 0; i < 128; i++){\n\t\tvec3 p = o + r * t;\n\t\tfloat d = map(p);\n\t\tt += d * 0.5;\n\t}\n\tvec3 p = o + r * t;\n\tvec3 n = getNormal(p);\n\treturn vec4(n,t);\n}\n\nvec3 cam(){\n\tvec3 c = vec3(1.,0.,-2.5 + iTime * 3.);\n\t//c.xy += vec2(cos(time/4.),sin(time/4.)) * 0.5;\n\treturn c;\n}\n\nvec3 ray(vec2 uv,float z){\n\tvec3 r = normalize(vec3(uv,z));\n\tr.xz *= genRot(PI / 8.);\n\tr.yz *= genRot(iTime / 8.);\n\tr.xy *= genRot(iTime / 4.);\n\treturn r;\n}\n\nvec3 getColor(vec3 o,vec3 r,vec4 d){\n\tfloat t = d.w;\n\tvec3 n = d.xyz;\n\tfloat tmp1 = dot(r,n);\n\tvec3 bc = vec3(1. - tmp1 * 0.85);\n\tvec3 p = o + r * t;\n\t//bc = min(fract(p.x),fract(p.z+time)) < 0.05 ? vec3(1.0) : bc;\n\tvec3 cc;\n\tfloat at = atan(r.y/r.x) * 2.;\n\tfloat tmp2 = at + iTime;\n\tcc.x = sin(tmp2);\n\tcc.y = sin(tmp2 + PI * 2. / 3.);\n\tcc.z = sin(tmp2 - PI * 2. / 3.);\n\tcc = cc / 2. + 0.5;\n\tcc = fract(p.z - iTime) < 0.25 ? vec3(1.) : cc;\n\tbc *= cc;\n\t\n\tfloat fog = 1. / (1. + t * t * 0.015);\n\treturn mix(bc,vec3(0.),1. - fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = ( (fragCoord.xy * 2. - iResolution.xy) / iResolution.y );\n\tvec3 c = cam();\n\tvec3 r = ray(uv,1.5 + 0.5 * sin(iTime/2.) );\n\tvec4 d = trace(c,r);\n\tvec3 color = getColor(c,r,d);\n\n\tfragColor = vec4( color, 1.0 );\n\n}","name":"Image","description":"","type":"image"}]}