{"ver":"0.1","info":{"id":"MXSSDw","date":"1710675536","viewed":58,"name":"colors of 2d tan uv mapping","username":"chenxianming","description":"colors of tan uv mapping\nwrote this code hash function reference from Dave_Hoskins's hashOld12","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","jigsaw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n\n    vec2 u = ( V * 2. - I.xy ) / A - iTime * .1, u2 = u;\n    \n    vec3 c;\n    float p;\n    \n    \n    vec2 t = round( u / (s*2.) );\n    u += s;\n    vec2 t2 = round( u / (s*2.) );\n    u -= (s*2.) * round( u / (s*2.) );\n    \n    u = abs(u);\n    \n    \n    u2 += s/2.;\n    vec2 tt = round( u2 / s );\n    u2 -= s * round( u2 / s );\n    u2 -= s * clamp( round(u2/s), 0., 1. );\n    \n    if( h( t ) * h(tt) < .2 )\n    \n    p = min(\n        u.x + u.y - s,\n        length(u2)-s/4.\n    );\n    \n    else\n    \n    p = max(\n        u.x + u.y - s,\n        -( length(u2)-s/4. )\n    );\n    \n\n    c += smoothstep( 5. / A, -5. / A, p );\n    \n    colors( c, t2, 5. );\n    \n    c = mix(\n        c,\n        vec3(1),\n        smoothstep( 5. / A, 0., abs(p) )\n    );\n    \n    c = mix(\n        c,\n        texture( iChannel0, V / iResolution.xy ).rgb,\n        texture( iChannel0, V / iResolution.xy )[ int( round( fract( iTime * .5 ) * 2. ) ) ]\n    );\n    \n\n    U = vec4( c, 1. );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    vec2 u = ( V * 2. - I.xy ) / A - iTime * .1, u2 = u;\n    \n    vec3 c;\n    float p;\n    \n    vec2 t = round( u / (s * 2.) );\n    u -= (s * 2.) * round( u / (s * 2.) );\n    \n    u = abs(u);\n    \n    u2 += s * .5;\n    \n    vec2 tt = round( u2 / s );\n    u2 -= s * round( u2 / s );\n    u2 -= s * clamp( round(u2/s), 0., 1. );\n    \n    if( h( t ) * h(tt) > .2 )\n    \n    p = min(\n        u.x + u.y - s,\n        length(u2)-s/4.\n    );\n    \n    else\n    \n    p = max(\n        u.x + u.y - s,\n        -( length(u2)- s/4.)\n    );\n    \n    c += smoothstep( 5. / A, -5. / A, p );\n    \n    colors( c, t, -5. );\n\n    c = mix(\n        c,\n        vec3(0),\n        smoothstep( 5. / A, 0., abs(p) )\n    );\n\n    U = vec4(c,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define I iResolution\n#define A min( I.x, I. y )\n#define s .15 // scale\n\nfloat h(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvoid colors( inout vec3 c, vec2 t, float o ){\n    \n    float r = h( t - o );\n    \n    vec3 q;\n    \n    if( r > -.0 && r < .25 )\n        q = vec3(.023,.6,.7);\n\n    if( r > .25 && r < .5 )\n        q = vec3(0.8,0.2,0.4);\n        \n    if( r > .5 && r < .75 )\n        q = vec3(.01,0.4,0.3);\n        \n    if( r > .75 && r < 1. )\n        q = vec3(0.7,0.5,0.3);\n\n    \n    c = mix(\n        c,\n        q * .7 + h(t) * .3,\n        c.x * h( t )\n    );\n    \n}\n","name":"Common","description":"","type":"common"}]}