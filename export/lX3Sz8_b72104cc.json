{"ver":"0.1","info":{"id":"lX3Sz8","date":"1718589550","viewed":114,"name":"Real-Time 2D SDF Generation v2","username":"MediocreProgrammer","description":"Generates a signed distance field for a texture. The frame time is proportional to the range used (e.g., a range of 80 is roughly twice as slow as a range of 40). Hopefully this is fast enough to run in real time.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"l33SR8","parentname":"Real-Time 2D SDF Generation"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nBasic idea:\nThis uses the Euclidean distance transform in 2D, except all squaring\nis done in the second pass, which then outputs the square root of the\nsquare distance.\n*/\n\n// The range can be changed in the Common tab.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 dist = float(RANGE) * texture(iChannel0, uv).rg;\n    float signedDistance = max(0.0, dist.r - 0.5) - max(0.0, dist.g - 0.5);\n    \n    // Display different effects\n    \n    vec3 color;\n    if (uv.x >= 0.5)\n    {\n        if (uv.y >= 0.5)\n        {\n            color = vec3(clamp(signedDistance - 14.5, 0.0, 1.0));\n            color = mix(vec3(0.33), vec3(1.0), color);\n            color = pow(color, vec3(1.0 / 2.2)); // Adjust for gamma\n            color = min(color, 1.0 - texture(iChannel1, uv).b);\n        }\n        else\n        {\n            // Minor artifacting can be spotted near 0 distance\n            signedDistance = mod(signedDistance, 9.0);\n            color = vec3(clamp(abs(signedDistance - 1.5), 0.0, 1.0));\n            /*\n            color = vec3(\n                0.5 / sqrt(2.0) * (dFdx(signedDistance) + dFdy(signedDistance)) + 0.5\n            );\n            */\n            color = pow(color, vec3(1.0 / 2.2)); // Adjust for gamma\n        }\n    }\n    else\n    {\n        color = vec3(signedDistance / (2.0 * float(RANGE)) + 0.5);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    color = fract(color + 0.05 * iTime);\n    vec3 quantized = round(color);\n    float level = max(quantized.r, max(quantized.g, quantized.b));\n    quantized = vec3(level, 1.0 - level, level);\n    fragColor = vec4(quantized, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0, 0.0) / iResolution.xy;\n    \n    vec2 dist = vec2(RANGE + 1);\n    \n    for (int i = RANGE; i >= 1; --i)\n    {\n        vec2 offset = float(i) * pixelSize;\n        vec2 xDist = vec2(i);\n        dist = mix(dist, xDist, texture(iChannel0, uv + offset).rg);\n        dist = mix(dist, xDist, texture(iChannel0, uv - offset).rg);\n    }\n    \n    vec4 texColor = texture(iChannel0, uv);\n    dist = mix(dist, vec2(0.0), texColor.rg);\n    fragColor = vec4(1.0 / float(RANGE) * dist, texColor.ba);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(0.0, 1.0) / iResolution.xy;\n    \n    vec4 texColor = texture(iChannel0, uv);\n    vec2 distSquare = texColor.rg;\n    distSquare *= distSquare;\n    \n    for (int i = 1; i <= RANGE; ++i)\n    {\n        vec2 offset = float(i) * pixelSize;\n        vec2 yDistSquare = 1.0 / float(RANGE) * vec2(i);\n        yDistSquare *= yDistSquare;\n        vec2 xDistSquare;\n        vec2 currDistSquare;\n        \n        xDistSquare = texture(iChannel0, uv + offset).rg;\n        xDistSquare *= xDistSquare;\n        currDistSquare = xDistSquare + yDistSquare;\n        distSquare = mix(\n            distSquare, currDistSquare, lessThan(currDistSquare, distSquare)\n        );\n        \n        xDistSquare = texture(iChannel0, uv - offset).rg;\n        xDistSquare *= xDistSquare;\n        currDistSquare = xDistSquare + yDistSquare;\n        distSquare = mix(\n            distSquare, currDistSquare, lessThan(currDistSquare, distSquare)\n        );\n    }\n    \n    fragColor = vec4(sqrt(distSquare), texColor.ba);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\nconst int RANGE = 40;\n","name":"Common","description":"","type":"common"}]}