{"ver":"0.1","info":{"id":"7tGczd","date":"1662001304","viewed":94,"name":"Torus Slices","username":"ScalarField","description":"Just showing two ways of slicing a rotationally symmetric solid to integrate over it (discs and \"shells\"). I wanted an illustration of this to use as a visual aid while explaining it, and this is a test of one such idea. Will add to this in the future.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching parameters\n#define RM_ITERS 100\n#define RM_MAX_DIST 50.0\n#define RM_HIT_DIST 1e-3\n\n#define PI 3.14159265\n\n// Coordinate system:\n// - right-handed coordinate system for world space\n// - +z direction is up\n\n// Quaternion stuff (xyz stores vector part, w stores scalar part)\n\n// Axis-angle to unit quaternion\nvec4 quat(vec3 axis, float angle){\n    return vec4(sin(angle/2.0)*normalize(axis), cos(angle/2.0));\n}\n\n// Quaternion rotation\nvec3 rotate(vec4 q, vec3 v){\n    return v + 2.0*cross(q.xyz, q.w*v + cross(q.xyz, v));\n}\n\n// Useful functions #################################################################\n\nfloat smoothMin(float a, float b, float k){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smoothMax(float a, float b, float k){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return h*h*h*k*(1.0/6.0) - min(-a, -b);\n}\n\n// CSG operations\nfloat sdfUnion(float a, float b, float k){ return smoothMin(a, b, k); }\nfloat sdfInt(float a, float b, float k){ return smoothMax(a, b, k); }\nfloat sdfDiff(float a, float b, float k){ return smoothMax(a, -b, k); }\n\n// Aliases for unsmoothed versions\nfloat u_sdfUnion(float a, float b){ return min(a, b); }\nfloat u_sdfInt(float a, float b){ return max(a, b); }\nfloat u_sdfDiff(float a, float b){ return max(a, -b); }\n\n// Scene primitive SDFs #############################################################\n\n// Torus (position, [\"main\" radius, \"tube\" radius])\nfloat sdfRing(vec3 p, vec2 r){\n    vec2 v = vec2(length(p.xy) - r.x, p.z);\n    return length(v) - r.y;\n}\n\nfloat sdf(vec3 pos){\n    \n    const float pieces = 10.;\n    float d = 100.0;\n    float freq = 0.2;\n    \n    if( int(mod(iTime/5., 2.0)) == 0 ){\n        for(float i=0.;i<pieces;i++){\n\n\n            float s = 0.5-0.5*cos(2.*PI*iTime*freq);\n            float si = -s+i*2.0*s/pieces;\n            float z1 = -0.3+i*0.6/pieces;\n            float z2 = -0.3+(i+1.)*0.6/pieces;\n\n            float di = u_sdfInt(\n                sdfRing(pos-vec3(0.0, 0.0, si), vec2(0.7, 0.3)),\n                u_sdfInt(\n                    si+z1-pos.z,\n                    pos.z-z2-si\n                )\n            );\n            d = min(d, di);\n        }\n    } else {\n        for(float i=0.;i<pieces;i++){\n\n            float freq = 0.2;\n            float s = 0.5-0.5*cos(2.*PI*iTime*freq);\n            float si = -s+i*2.0*s/pieces;\n            float r1 = 0.4+i*0.6/pieces;\n            float r2 = 0.4+(i+1.)*0.6/pieces;\n\n            float di = u_sdfInt(\n                sdfRing(pos-vec3(0.0, 0.0, si), vec2(0.7, 0.3)),\n                u_sdfInt(\n                    r1 - length(pos.xy),\n                    length(pos.xy) - r2\n                )\n            );\n            d = min(d, di);\n        }\n    }\n    \n    return d;\n}\n\n// Rendering stuff ##################################################################\n\n// Numerical gradient calculation\nvec3 grad(vec3 pos){\n    \n    \n    vec2 eps = vec2(1e-3, 0.0);\n    return normalize(vec3(\n        sdf(pos+eps.xyy) - sdf(pos-eps.xyy),\n        sdf(pos+eps.yxy) - sdf(pos-eps.yxy),\n        sdf(pos+eps.yyx) - sdf(pos-eps.yyx)\n    )); \n\n}\n\n// Move from src along dir until collision with scene; return distance travelled\nfloat raymarch(vec3 src, vec3 dir){\n    \n    float dist = 0.0;\n    \n    for(int i=0;i<RM_ITERS;i++){\n        \n        vec3 pos = src + dir*dist;\n\n        float d = sdf(pos);\n        \n        if(d < RM_HIT_DIST || dist > RM_MAX_DIST){ break; }\n        \n        dist += d;\n        \n    }\n    \n    return dist;\n    \n}\n\n// Soft shadows as per https://iquilezles.org/articles/rmshadows/\nfloat getShadow(vec3 src, vec3 dir, float minDist, float k){\n\n    float shadow = 1.0;\n    float d = minDist;\n    \n    for(int i=0;i<50 && d < 50.;i++){\n        \n        float r = sdf(src + d*dir);\n        \n        if(r < 0.001){\n            return 0.0;\n        }\n        shadow = min(shadow, k*r/d); \n        d += r;\n        \n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n\n}\n\n// Identify point on scene and figure out its color\nvec3 colorPixel(vec3 src, vec3 dir){\n\n    float d = raymarch(src, dir);\n    \n    vec3 pos = src + dir*d;\n    vec3 norm = grad(pos);\n     \n    if(d > RM_MAX_DIST){ return vec3(0.0); }\n    \n    vec3 materialColor = vec3(1.0, 0.0, 0.0);\n    \n    vec3 light1 = normalize(vec3(1.0, 2.0, 1.0));\n    vec3 light2 = normalize(vec3(-1.0, -1.0, -2.0));\n    vec3 light3 = normalize(vec3(1.0, 0.0, 1.0));\n    \n    return + materialColor*( \n        0.3*clamp(dot(norm, light1), 0.0, 1.0)*getShadow(pos, light1, 0.05, 15.0) +\n        0.3*clamp(dot(norm, light2), 0.0, 1.0)*getShadow(pos, light2, 0.05, 15.0) +\n        0.3*clamp(dot(norm, light3), 0.0, 1.0)*getShadow(pos, light3, 0.05, 15.0) +\n        0.1\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 xy = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    float freq = 0.05;\n    vec4 q = quat(vec3(-1.0, 0.0, 1.0), 2.*PI*iTime*freq);\n    \n    vec3 cameraPos = rotate(q, vec3(0.0, -3.0, 0.0));\n    vec3 rayDir = rotate(q, vec3(xy.x, 1.0, xy.y));\n    \n    vec3 col = colorPixel(cameraPos, normalize(rayDir));\n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}