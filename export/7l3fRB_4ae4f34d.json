{"ver":"0.1","info":{"id":"7l3fRB","date":"1663279897","viewed":142,"name":"Clouds3d-220915","username":"diasgc","description":"Clouds","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based in https://www.shadertoy.com/view/wdsfDH\n\n#define FBM 2\n#define FBM2_K 0.56\n#define NOISE 1\n#define NUM_OCTAVES 3\n#define CLOUDS 1\n \n\nvec3 skytop = vec3(0.05, 0.2, 0.5);\n\nvec3 light = normalize(vec3(0.1, 0.25, 0.9));\n\nfloat camZ = 1000.;\n\nvec2 cloudrange = vec2(0.0, 10000.0);\n\nconst float cloudL = 1.0;\n\nconst float cloudD = 0.0;\n\nconst vec3 ambL = vec3(.09,.05, .0);\n\nconst vec3 ambD = vec3(.025,.09, .01);\n\nconst float speed = 5e2;\n\nmat3 m = mat3(0.00, 1.60, 1.20,\n\n             -1.60, 0.72, -0.96,\n\n             -1.20, -0.96, 1.28);\n\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\n\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\n\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\n\n// hash function              \n\nfloat hash(float n){\n\n    return fract(cos(n) * 114514.1919);\n\n}\n\n \n\n// 3d noise functions\n\nfloat noise(in vec3 p){\n\n#if NOISE == 1\n\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n    \n#else\n\n    vec3 x = floor(p);\n    vec3 f = smoothstep(0.0, 1.0, fract(p));\n\n    float n = x.x + x.y * 10.0 + x.z * 100.0;\n\n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 10.0), hash(n + 11.0), f.x), f.y),\n        mix(mix(hash(n + 100.0), hash(n + 101.0), f.x),\n            mix(hash(n + 110.0), hash(n + 111.0), f.x), f.y), f.z);\n            \n#endif\n\n}\n\n \n\n// Fractional Brownian motion\n\nfloat fbm(vec3 x){\n\n#if FBM == 1\n\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100.);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n\n#elif FBM == 2\n\n    float f = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n        f += a * noise(x);\n        x = m * x;\n        a *= FBM2_K;\n    }\n    return f;\n    \n#else\n\n    float f = 0.5000 * noise(x);\n    x = m * x;\n    f += 0.2500 * noise(x);\n    x = m * x;\n    f += 0.1666 * noise(x);\n    x = m * x;\n    f += 0.0834 * noise(x);\n    return f;\n\n#endif\n\n}\n\n \n\nvec3 camera(float time){\n\n    return vec3( 5000., 3000., speed * time);\n\n}\n\n\nvec4 clouds(in float limit, in float step, in vec2 ms, in vec3 campos, in vec3 fragAt){\n    \n    vec4 sum = vec4( 0. );    \n    vec3 cL = vec3(cloudL) + ms.x * ambL;\n    vec3 cD = vec3(cloudD) - ms.y * ambD;\n\n    for (float depth = 0.0; depth < limit; depth += step ){\n\n        vec3 ray = campos + fragAt * depth;\n        \n        if (cloudrange.x < ray.y && ray.y < cloudrange.y){\n\n#if CLOUDS == 1\n            float alpha = smoothstep(0.3 + 0.4 * sum.z, 1.0, fbm(ray * 0.00025));\n#else\n            float alpha = smoothstep(0.5, 1.0, fbm(ray * 0.00025));\n#endif\n            vec3 localcolor = mix(cL, cD, alpha);\n            alpha = (1.0 - sum.a) * alpha;\n            sum += vec4(localcolor * alpha, alpha);\n        }\n\n    }\n    return sum;\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy;\n\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 ms = 0.5 + 1.5 * iMouse.xy / iResolution.xy;\n\n \n\n    float time = (iTime + 13.5 + 44.) * 1.0;\n\n    vec3 campos = camera(time);\n\n    vec3 camtar = camera(time + 0.4);\n\n \n\n    vec3 front = normalize(camtar - campos);\n\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n\n    vec3 up = normalize(cross(right, front));\n\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    vec3 sunAt = normalize((2. * uv.x - 1.0 )* right + (2.0 * uv.y - 1.0) * up + front);\n    \n\n    // clouds\n\n    vec4 sum = clouds( 4e4, 300., ms, campos, fragAt);\n\n    float alpha = smoothstep(0.4, 1.0, sum.a - 0.00025);\n\n    sum.rgb /= sum.a + 0.00025;\n\n \n\n    float sundot = clamp(dot(sunAt, light), 0.0, 1.0);\n    \n    float sunInt = clamp(exp((1.-ms.x) * 50.), 1.,100.);\n\n    vec3 col = 0.8 * (skytop);\n\n    col += 0.47 * vec3(1.9, 1.114, 0.0010) * pow(sundot, sunInt);\n\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n\n    \n\n    sum.rgb -= 0.1 * vec3(0.8, 0.75, 0.7) * pow(sundot, 13.0) * alpha;\n\n    \n\n    sum.rgb += 0.4 * vec3(1.3, 1.2, 1.0) * pow(sundot, 5.0) * (1.0 - alpha);\n\n \n    col += sum.rgb * sum.a * 0.5;\n\n    col = mix(col, sum.rgb, sum.a);\n\n \n\n    //fragColor = vec4(col, 1.0);\n\n    fragColor = vec4(col, sum.a);\n\n}\n","name":"Image","description":"","type":"image"}]}