{"ver":"0.1","info":{"id":"dsccz4","date":"1694785990","viewed":84,"name":"Dancing in Pastel","username":"agrajag","description":"Converts the video image from your webacm into pastel colors with thick white outlines.\n\nThe colors vary in intensity with the beat of the music (optional). Works best with a heavy bassline.\n\nSet \"webcam\" for iChannel0 and \"microphone\" for iChannel1!","likes":1,"published":1,"flags":6,"usePreview":0,"tags":["video","camera","outlines","comic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* INPUTS */\n\nvec4 getWebcamPixelAt (sampler2D channel, vec2 pos) {\n    return texture(channel, pos);\n}\n\n\nfloat getAmp (sampler2D channel, float frequency) {\n    return texture(channel, vec2(frequency / 512.0, 0)).x;\n}\n\n\n/* IMAGE FILTERS */\n\nvec2 mirrorHorizontally (vec2 uv) {\n    uv.x = 1.0 - uv.x;\n    \n    return uv;\n}\n\n\n/* COLOR FILTERS */\n\n/**\n * THIS DOES NOT DO ANYTHING!\n * (although it follows the source precisely)\n *\n * Change brightness.\n *\n * Source: https://www.shadertoy.com/view/XdcXzn\n */\nvec4 filterBrightness (vec4 col, float brightness) {\n    mat4 brightnessMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        brightness, brightness, brightness, 1.0\n    );\n     \n    return col * brightnessMatrix;\n}\n\n/**\n * Change contrast.\n *\n * Source: https://www.shadertoy.com/view/XdcXzn\n */\nvec4 filterContrast (vec4 col, float contrast) {\n    float t = (1.0 - contrast) / 2.0;\n    \n    mat4 contrastMatrix = mat4(\n        contrast, 0.0, 0.0, 0.0,\n        0.0, contrast, 0.0, 0.0,\n        0.0, 0.0, contrast, 0.0,\n        t, t, t, 1.0\n    );\n    \n    return col * contrastMatrix;\n}\n\nvec4 filterSaturation (vec4 col, float saturation) {\n    vec3 luminance = vec3(0.3086, 0.6094, 0.0820);\n    \n    float invertedSaturation = 1.0 - saturation;\n    \n    vec3 r = vec3(luminance.x * invertedSaturation);\n    r += vec3(saturation, 0.0, 0.0);\n    \n    vec3 g = vec3(luminance.y * invertedSaturation);\n    g += vec3(0.0, saturation, 0.0);\n    \n    vec3 b = vec3(luminance.z * invertedSaturation);\n    b += vec3(0.0, 0.0, saturation);\n    \n    mat4 saturationMatrix = mat4(\n        r,             0.0,\n        g,             0.0,\n        b,             0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n    \n    return col * saturationMatrix;\n}\n\nvec4 filterShiftColors (vec4 col, vec4 newCol) {\n    return col * newCol;\n}\n\nvec4 filterInvert (vec4 col) {\n    return vec4(1.0, 1.0, 1.0, 1.0) - col;\n}\n\n\n/**\n * Edge detection with a Sobel filter.\n *\n * Source: https://www.shadertoy.com/view/MlBSWW\n */\nvec2 mirror (vec2 coord, bool doMirror) {\n    if (doMirror) {\n        return vec2(1.0 - coord.x, coord.y);\n    } else {\n        return coord;\n    }\n}\nvec4 filterEdgeDetection (sampler2D channel, vec2 coord, vec3 res, float intensity, bool doMirror) {\n   \n    mat3 sobelX = mat3(\n        -1.0, -2.0, -1.0,\n         0.0,  0.0,  0.0,\n         1.0,  2.0,  1.0\n    );\n    mat3 sobelY = mat3(\n        -1.0,  0.0,  1.0,\n        -2.0,  0.0,  2.0,\n        -1.0,  0.0,  1.0\n    );\n    float sumX = 0.0;\n    float sumY = 0.0;\n    vec4 col;\n    \n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j++)\n        {\n            // Texture coordinates should be between 0.0 and 1.0:\n            float x = (coord.x + float(i)) / res.x;\t\n    \t\tfloat y = (coord.y + float(j)) / res.y;\n            \n            // Convolve kernels with image:\n            sumX += length(texture(channel, mirror(vec2(x, y), doMirror)).xyz) * float(sobelX[1+i][1+j]);\n            sumY += length(texture(channel, mirror(vec2(x, y), doMirror)).xyz) * float(sobelY[1+i][1+j]);\n        }\n    }\n    \n    float g = abs(sumX) + abs(sumY);\n    \n    if (g > 1.0 / intensity) {\n        col = vec4(1.0, 1.0, 1.0, 0.0);\n    } else {\n        col = col * 0.0;\n    }\n    \n    return filterInvert(col);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Define coordinate system:\n    vec2 uv = fragCoord / iResolution.xy; // coordinates range is [0..1], 0/0 is lower left\n    uv.x *= iResolution.x / (iResolution.y * aspectRatio); // fix aspect ratio\n\n    // Get camera picture:\n    vec4 webcamCol = getWebcamPixelAt(iChannel0, mirrorHorizontally(uv));\n    \n    // Get edges:\n    vec4 colEdges = webcamCol;\n    colEdges = filterEdgeDetection(\n        iChannel0,\n        fragCoord,\n        vec3(iResolution.y * aspectRatio, iResolution.y, iResolution.z),\n        1.0,\n        true\n    );\n    \n    vec4 colEdgesBlack = colEdges;\n    \n    if (true) {\n        colEdges = filterInvert(colEdges);\n        colEdges = filterShiftColors(colEdges, vec4(0.0, 1.0, 0.5, 1.0));\n        colEdges = filterInvert(colEdges);\n    }\n    \n    // Use sound to vary color intensity (works even without sound input):\n    float paletteShift = 2.8; // use this variable to shift palette\n    //float amp = pow(getAmp(iChannel1, 1.4), 3.0) * 12.0 - 1.0;\n    float amp = pow(getAmp(iChannel1, 0.4), 3.0) * 15.0 - 1.0;\n    float colorIntensity = paletteShift;\n    if (amp > 1.0) {\n        colorIntensity *= amp;\n    }\n    \n    // Output to screen:\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0); // basic white canvas\n    fragColor *= filterSaturation(filterContrast(webcamCol, 1.2), colorIntensity);\n    fragColor += filterInvert(filterShiftColors(colEdgesBlack, vec4(1.0, 0.0, 1.0, 1.0)));\n    fragColor += filterInvert(colEdgesBlack);\n    \n    if (amp > 1.15) {\n        //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}