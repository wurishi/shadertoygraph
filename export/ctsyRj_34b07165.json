{"ver":"0.1","info":{"id":"ctsyRj","date":"1690947944","viewed":145,"name":"ray marching TEST 2","username":"Swifter","description":"someone cooked here....","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV = 40.;\nconst float maxDist = 1000.;\n\nconst vec3 sunDirection = normalize(vec3(1.,0.2,-0.3));\n\n#define DEG2RAD 0.01745329251\n\nfloat easeInOutQuint(float x) {\n    return x < 0.5 ? 16. * x * x * x * x * x : 1. - pow(-2. * x + 2., 5.) / 2.;\n}\n\nfloat easeInCubic(float x) {\n    return x * x * x;\n}\n\nvec3 easeInCubic(vec3 v) {\n    return vec3(\n        easeInCubic(v.x),\n        easeInCubic(v.y),\n        easeInCubic(v.z)\n    );\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rotateX(float angle, vec3 vector) {\n    return vec3(\n        vector[0] * cos(angle) - vector[1] * sin(angle),\n        vector[0] * sin(angle) + vector[1] * cos(angle),\n        vector[2]\n    );\n}\n\nvec3 rotateY(float angle, vec3 vector) {\n    return vec3(\n        vector[0] * cos(angle) + vector[2] * sin(angle),\n        vector[1],\n        -vector[0] * sin(angle) + vector[2] * cos(angle)\n    );\n}\n\nvec3 rotateZ(float angle, vec3 vector) {\n    return vec3(\n        vector[0],\n        vector[1] * cos(angle) - vector[2] * sin(angle),\n        vector[1] * sin(angle) + vector[2] * cos(angle)\n    );\n}\n\nvec3 rotateVector(vec3 vector, vec3 rotation) {\n    vector = rotateZ(rotation[0] * DEG2RAD, vector);\n    vector = rotateY(rotation[1] * DEG2RAD, vector);\n    vector = rotateX(rotation[2] * DEG2RAD, vector);\n    return vector;\n}\n\nfloat sphereSDF(vec3 center, float radius, vec3 point) {\n    return length(center - point) - radius;\n}\n\nfloat sdBox( vec3 center, vec3 corner, vec3 point)\n{\n  vec3 p = point - center;\n  vec3 b = corner;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nconst vec3 FORWARD = vec3(0.,0.,1.);\n\nconst float outlineDist = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = clamp(iMouse.xy / iResolution.xy, 0., 1.);\n    \n    float gridSpace = 70. * (1. - mouse.x) + 20.;\n    vec3 sphereCenter = vec3(gridSpace * 0.5, gridSpace * 0.5, gridSpace * 0.5);\n    \n    // Calculate vector direction\n    float curFOV = FOV * (0.5 + mouse.x * 0.5 + mouse.y);\n    float aspect = iResolution.x / iResolution.y;\n    float verticalFOV = 2. * atan(tan(curFOV * DEG2RAD / 2.) * aspect) / DEG2RAD;\n    \n    float bottomXrot = -verticalFOV/2.;\n    float topXrot = verticalFOV/2.;\n    float leftYrot = -curFOV/2.;\n    float rightYrot = curFOV/2.;\n    \n    float Xrot = mix(bottomXrot, topXrot, uv.x);\n    float Yrot = mix(leftYrot, rightYrot, -uv.y);\n    \n    // Raycast\n    \n    vec3 cameraRotation = vec3(0., 0., mouse.y * 360.); \n    vec3 cameraForward = rotateVector(FORWARD, cameraRotation);\n    vec3 ray = rotateVector(cameraForward, vec3(Xrot, Yrot, 0.));\n    \n    float distTravelled = 0.;\n    vec3 curPos = vec3(0,0,0);\n    \n    vec3 f = vec3(0.,0.,0.);\n    float sphereDot = 0.;\n    float outline = 0.;\n    bool outlineEscaped = false;\n    \n    vec3 curSunDirection = normalize(sunDirection + vec3(0.,cos(iTime), sin(iTime)));\n    \n    float lightness = cos(curPos.y / 400. + curPos.y / 80. + iTime / 1.) * 0.5 + 0.5;\n    \n    while (distTravelled < maxDist) {\n        vec3 newSpace = curPos;\n        \n        newSpace = rotateVector(newSpace, vec3(\n            curPos.x / 20.,\n            mod(iTime * 2., 360.) + -newSpace.y / 40. * mouse.y - newSpace.x / 40. * cos(iTime * 0.2),\n            -newSpace.x / 20. * sin(iTime * 0.2)\n        ));\n        \n        newSpace += sin(iTime * 0.1) * distTravelled / 20.;\n        newSpace += rotateVector(cameraForward, vec3(90., 0., 90.)) * 500. * mouse.y;\n        newSpace.y += sin(iTime * 0.6 + newSpace.x / 80. + newSpace.y / 90.) * 1.5;\n        newSpace.x += sin(iTime * 2.6 + newSpace.z / 20.) * 0.2;\n    \n        vec3 pos = mod(newSpace, gridSpace);\n        float radius = 1. + mouse.x + sin(iTime / 2. + curPos.y / 50.) * 0.5 + mouse.y * 2.5 * mouse.x;\n        float sdf = length(pos - sphereCenter) - radius;\n        // float sdf = sdBox(sphereCenter, vec3(1.,1.,1.) * radius, curPos);\n        \n        if (sdf < outlineDist) {\n            if (!outlineEscaped) {\n                vec3 normal = normalize(pos - sphereCenter);\n                float sunStrength = clamp(dot(normal, curSunDirection), 0., 1.);\n                // sunStrength = easeInCubic(sunStrength);\n                outline = 1. - distTravelled / maxDist;\n                outline *= sunStrength;\n                sphereDot = sunStrength;\n            }\n        }\n        else if (outline > 0.) {\n            outlineEscaped = true;\n        }\n           \n        if (sdf < 0.02) {\n            vec3 normal = normalize(pos - sphereCenter);\n            float sunStrength = clamp(dot(normal, curSunDirection), 0., 1.);\n            float highlight = easeInCubic(sunStrength);\n            vec3 newCol = hsv2rgb(vec3(mod(sunStrength + 0.5, 1.), 0.1, highlight * 0.3));\n            newCol = mix(newCol, 0.4 + 1. - easeInCubic(1. - newCol), lightness);\n            f = newCol;\n            \n            if (!outlineEscaped) {\n                outline = 0.;\n            }\n            \n            break;\n        }\n        \n        curPos += ray * sdf;\n        distTravelled += sdf;\n    }\n    \n    float finalSunDir = dot(normalize(curPos), rotateVector(curSunDirection, vec3(-90., 0., 0.)));\n    vec3 atmosphere = hsv2rgb(vec3(finalSunDir / 4., finalSunDir, 0.6));\n    vec3 pretty = hsv2rgb(vec3(uv.x / 4. + iTime / 30. + uv.y / 13., 0.4, 0.9));\n    atmosphere = mix(pretty, atmosphere, mouse.x);\n    \n    float d = distTravelled / maxDist;\n    f = mix(f, atmosphere, d);\n    f += outline * hsv2rgb(vec3(sphereDot + 0.3, lightness * 0.6, 0.8));\n    \n    // Export\n    vec3 col = f;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}