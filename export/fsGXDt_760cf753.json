{"ver":"0.1","info":{"id":"fsGXDt","date":"1635463159","viewed":173,"name":"box wave","username":"do","description":"fwidth test, see difference at edge","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["fwidth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//box wave\n//2021\n//do\n\nconst float PI  =  radians(180.0);\n\nfloat hash(float p) {\nreturn fract(sin(p) * 4358.5453);\n}\n\nfloat hash(vec2 p) {\nreturn fract(sin(dot(p.xy,vec2(12.9898,78.233))) * 43758.5357); \n} \n\nfloat noise(vec3 x) {\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix(hash(  n +   0.0) , hash(   n +   1.0)  ,f.x),\n                   mix(hash(  n + 157.0) , hash(   n + 158.0)   ,f.x),f.y),\n               mix(mix(hash(  n + 113.0) , hash(   n + 114.0)   ,f.x),\n                   mix(hash(  n + 270.0) , hash(   n + 271.0)   ,f.x),f.y),f.z);\n}\n\nmat2 rot(float a) {\n\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nfloat checker(vec2 p) {\n\n    vec2 w = fwidth(p)-0.001;\n    vec2 i = 2.*(abs(fract((p-.5*w)*.5)-.5)\n             - abs(fract((p+.5*w)*.5)-.5))/w;\n    return 0.5 - 0.5 * i.x * i.y;\n}\n\nvec2 opu(vec2 d1,vec2 d2) {\n\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nfloat box(vec3 p,vec3 b) {\n\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec2 scene(vec3 p) { \n\nvec2 res = vec2(1.0,0.0);\n\nfloat t = iTime;\n\nvec3 q = p;\n\nq.z += t*2.; \nq.xz *= sin(q.xz * .5 + noise(q + noise(q)) + t ) + .5;\nq.z *= cos(q.z * .5 + noise(q) + t) + .5; \n\nfloat pl = dot(q*.5,vec3(.5,-1.,0.));\n\nres = opu(res,vec2(max(-pl,box(p,vec3(1.))-.15),2.));\nres = opu(res,vec2(p.y+1.,1.));\n\nreturn res;\n\n}\n\nvec2 rayScene(vec3 ro,vec3 rd) {\n    \n    float depth = 0.0;\n    float d = -1.0;\n\n       for(int i = 0; i < 245; i++) {\n\n        vec3 p = ro + depth * rd;\n        vec2 dist = scene(p);\n   \n        if(abs( dist.x) < 0.001 || 150. <  dist.x ) { break; }\n\n        depth += dist.x;\n        d = dist.y;\n\n        }\n \n        if(150. < depth) { d = -1.0; }\n\n        return vec2(depth,d);\n\n}\n\nfloat shadow(vec3 ro,vec3 rd ) {\n\n    float res = 1.0;\n    float t = 0.005;\n    float ph = 1e10;\n    \n    for(int i = 0; i < 245; i++ ) {\n\n        float h = scene(ro + rd * t  ).x;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h-y*y);         \n        res = min(res,125. * d/max(0.,t-y));\n        ph = h;\n        t += h;\n    \n        if(res < 0.00001 || t >  10. ) { break; }\n        }\n\n        return clamp(res,0.0,1.0);\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.0,-1.0) * 0.0001;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));\n\n}\n\nvec3 rayCamDir(vec2 uv,vec3 camPosition,vec3 camTarget,float fPersp) {\n\n     vec3 camForward = normalize(camTarget - camPosition);\n     vec3 camRight = normalize(cross(vec3(0.0,1.0,0.0),camForward));\n     vec3 camUp = normalize(cross(camForward,camRight));\n\n     vec3 vDir = normalize(uv.x * camRight + uv.y\n     * camUp + camForward * fPersp);  \n\n     return vDir;\n}\n\nvec3 render(vec3 ro,vec3 rd) {\n\nvec2 d = rayScene(ro, rd);\n\nvec3 cf = vec3(1.);                         \nvec3 col = cf - max(rd.y,0.);\n\nif(d.y >= 0.) {\n\nvec3 p = ro + rd * d.x;\nvec3 n = calcNormal(p);\nvec3 l = normalize( vec3(25.,45.,33.));\nl.xz *= rot(iTime*.05);\n\nvec3 h = normalize(l - rd);\nvec3 r = reflect(rd,n);\n\nfloat amb = sqrt(clamp(0.5 + 0.5 * n.y,0.0,1.0));\nfloat dif = clamp(dot(n,l),0.0,1.0);\n\nfloat spe = pow(clamp(dot(n,h),0.0,1.0),16.)\n* dif * (.04 + 0.9 * pow(clamp(1. + dot(h,rd),0.,1.),5.));\n\nfloat fre = pow(clamp(1. + dot(n,rd),0.0,1.0),2.0);\nfloat ref = smoothstep(-.2,.2,r.y);\n\nvec3 linear = vec3(0.);\n\ndif *= shadow(p,l);\nref *= shadow(p,l);\n\nlinear += dif * vec3(.5);\nlinear += amb * vec3(.06,.05,.01); \nlinear += ref * vec3(.0045,.0044,.004); \nlinear += fre * vec3(.005,.0033,.001);\n\n//anti aliased with fwidth on xz plane\nif(d.y == 2.) {\n    col = vec3(checker(p.xz*12.) * .5 + .1);\n}\n\nif(d.y == 1.) {\n    col = vec3(.5);\n} \n\ncol = col * linear;\ncol += 5. * spe * vec3(1.,.5,.5 );\n}\n\nreturn col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\nvec3 cam_target =  vec3(0.);\nvec3 cam_pos = vec3(3.,5.,6.);\ncam_pos.xz *= rot(iTime * .12);\n\nvec2 uv =  -1. + 2. * fragCoord.xy / iResolution.xy;\nuv.x *= iResolution.x / iResolution.y; \n\nvec3 dir = rayCamDir(uv,cam_pos,cam_target,5.);\nvec3 color = render(cam_pos,dir);\ncolor = pow(color,vec3(.4545));      \nfragColor = vec4(color,1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}