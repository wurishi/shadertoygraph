{"ver":"0.1","info":{"id":"M3G3DV","date":"1718233200","viewed":66,"name":"Fork DVD Bounce - color","username":"berelium","description":" Fork of \"Fork DVD Bounce honestcactus\" by honestcactus. https://shadertoy.com/view/43VGWy\nAdded color on bounce, as author requested.\nI let it run for a while and the colors did become \"spazzy\" after a long period, so may need something to stabilize it.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["waves","logo","color","bounce","dvd","cineshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Fork DVD Bounce honestcactus\" by honestcactus. https://shadertoy.com/view/43VGWy\n// 2024-06-12 22:48:37\n\n\n#define PI 3.14159265359\n\n\n//#define DEBUG\n\n\n// ==== ADDITIONS ====\nfloat hash12(vec2 p) { // @Dave_Hoskins : https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hsl2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n// ===================\n  \n    \nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float m = vmin(s);\n\treturn (length(p / s) * m) - m;\n}\n\nfloat halfEllip(vec2 p, vec2 s) {\n    p.x = max(0., p.x);\n    float m = vmin(s);\n\treturn (length(p / s) * m) - m;\n}\n\n\nfloat fBox(vec2 p, vec2 b) {\n\treturn vmax(abs(p) - b);\n}\n\nfloat dvd_d(vec2 p) {\n    float d = halfEllip(p, vec2(.8, .5));\n    d = max(d, -p.x - .5);\n    float d2 = halfEllip(p, vec2(.45, .3));\n    d2 = max(d2, min(-p.y + .2, -p.x - .15));\n    d = max(d, -d2);\n    return d;\n}\n\nfloat dvd_v(vec2 p) {\n    vec2 pp = p;\n    p.y += .7;\n    p.x = abs(p.x);\n    vec2 a = normalize(vec2(1,-.55));\n    float d = dot(p, a);\n    float d2 = d + .3;\n    p = pp;\n    d = min(d, -p.y + .3);\n    d2 = min(d2, -p.y + .5);\n    d = max(d, -d2);\n    d = max(d, abs(p.x + .3) - 1.1);\n\treturn d;\n}\n\n\nfloat dvd_c(vec2 p) {\n    p.y += .95;\n\tfloat d = ellip(p, vec2(1.8,.25));\n    float d2 = ellip(p, vec2(.45,.09));\n    d = max(d, -d2);\n    return d;\n}\n\nfloat dvd(vec2 p) {\n    p.y -= .345;\n    p.x -= .035;\n    p *= mat2(1,-.2,0,1);\n\tfloat d = dvd_v(p);\n    d = min(d, dvd_c(p));\n    p.x += 1.3;\n    d = min(d, dvd_d(p));\n    p.x -= 2.4;\n    d = min(d, dvd_d(p));\n    return d;\n}\n\n\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\n\n\nvoid drawHit(inout vec4 col, vec2 p, vec2 hitPos, float hitDist) {\n\n    float d = length(p - hitPos);\n    \n    #ifdef DEBUG\n    col = mix(col, vec4(0,1,1,0), step(d, .1)); return;\n    #endif\n    \n    float wavefront = d - hitDist * 1.5;\n    float freq = 2.;\n    \n    float ripple = sin((wavefront * freq) * PI*2. - PI/2.);\n    \n    float blend = smoothstep(3., 0., hitDist);\n    blend *= smoothstep(.2, -.5, wavefront);\n    blend *= rangec(-4., .0, wavefront);\n    \n\n    float height = (ripple * blend);\n    col.a -= height * 1.9 / freq;\n}\n\nvec2 ref(vec2 p, vec2 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal) + offset;\n\tp -= (2. * t) * planeNormal;\n    return p;\n}\n\n\n\n\n// Flip every second cell to create reflection\nvoid flip(inout vec2 pos) {\n    vec2 flip = mod(floor(pos), 2.);\n    pos = abs(flip - mod(pos, 1.));\n}\n\nfloat stepSign(float a) {\n    //return sign(a);\n\treturn step(0., a) * 2. - 1.;\n}\n\nvec2 compassDir(vec2 p) {\n    //return sign(p - sign(p) * vmin(abs(p))); // this caused problems on some GPUs\n    vec2 a = vec2(stepSign(p.x), 0);\n    vec2 b = vec2(0, stepSign(p.y));\n    float s = stepSign(p.x - p.y) * stepSign(-p.x - p.y);\n    return mix(a, b, s * .5 + .5);\n}\n\nvec2 calcHitPos(vec2 move, vec2 dir, vec2 size) {\n    vec2 hitPos = mod(move, 1.);\n    vec2 xCross = hitPos - hitPos.x / (size / size.x) * (dir / dir.x);\n    vec2 yCross = hitPos - hitPos.y / (size / size.y) * (dir / dir.y);\n   \thitPos = max(xCross, yCross);\n    hitPos += floor(move);\n    return hitPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    #ifdef DEBUG\n    \t//p.xy += vec2(1.2, .6);\n    \t//p *= 3.5;\n    \tp *= 2.;\n   \t#endif\n    \n    vec2 screenSize = vec2(iResolution.x/iResolution.y, 1.) * 2.;\n\n    float t = iTime;\n    vec2 dir = normalize(vec2(9.,16) * screenSize );\n    vec2 move = dir * t / 1.5;\n    float logoScale = .1;\n    vec2 logoSize = vec2(2.,.85) * logoScale * 1.;\n\n    vec2 size = screenSize - logoSize * 2.;\n    \n    // Remap so (0,0) is bottom left, and (1,1) is top right\n    move = move / size + .5;\n\n    // Calculate the point we last crossed a cell boundry\n    vec2 lastHitPos = calcHitPos(move, dir, size);\n    vec4 col = vec4(1,1,1,0);\n    vec4 colFx = vec4(1,1,1,0);\n    vec4 colFy = vec4(1,1,1,0);\n    vec2 e = vec2(.8,0)/iResolution.y;\n\n    #ifdef DEBUG\n\t\tcol.rgb = vec3(0.);\n    #endif\n    \n   \t#ifdef DEBUG\n\t\tconst int limit = 1;\n   \t#else\n    \tconst int limit = 5;\n    #endif\n\t\n    for (int i = 0; i < limit; i++) {\n        vec2 hitPos = lastHitPos;\n \n        if (i > 0) {\n            // Nudge it before the boundry to find the previous hit point\n            hitPos = calcHitPos(hitPos - .00001/size, dir, size);\n        }\n        \n        lastHitPos = hitPos;\n\n    }\n        \n    // Flip every second cell to create reflection\n    flip(move);\n\n    // Remap back to screen space\n    move = (move - .5) * size;\n    \n\n    // invert colours\n    col.rgb = clamp(1. - col.rgb, vec3(0), vec3(1));\n    col.rgb /= 3.;\n    \n\n    \n    \n    #ifdef DEBUG\n        float b = vmin(abs(fract(p / screenSize) - .5) * 2.);\n        b /= fwidth(b) * 2.;\n        b = clamp(b, 0., 1.);\n        b = 1. - b;\n        col.rgb = mix(col.rgb, vec3(0), b);\n    #endif\n    \n    // dvd logo\n\tfloat d = dvd((p - move) / logoScale);\n    d /= fwidth(d);\n    d = 1. - clamp(d, 0., 1.);\n    col.rgb = mix(col.rgb, vec3(1), d);\n    \n    // ADDITION : Pick color by last hit position\n    col.rgb *= hsl2rgb(vec3(hash12(lastHitPos/size), 0.6, 0.5));\n\n    // gamma\n    col.rgb = pow(col.rgb, vec3(0.4545));\n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"DVD\",\n\t\"description\": \"\",\n\t\"model\": \"person\"\n}\n*/","name":"Image","description":"","type":"image"}]}