{"ver":"0.1","info":{"id":"slffzX","date":"1651197633","viewed":91,"name":"Temple of the Drowned God","username":"brandonson","description":"Looks like whatever god was here could not defeat Poseidon.\n\nFirst shader (at least, first public one). Many thanks to iq for his tutorial videos, without which this probably would not exist.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","temple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Inspired by, but not a copy of, iq's temple: https://www.youtube.com/watch?v=-pdSjBPH3zM&t=5885s\n\n//The temple/water/ground/rock functions are my own, but the more standard box/cone/noise functions are borrowed from other sources.\n\n//The raymarching through noisy terrain is slow, unfortunately.\n//Turning off the noise offsets greatly improves performance, but significantly reduces the visual quality of the island and temple.\n\n#define SKY_ENABLED\n#define NOISE_OFFSETS\n\n// Decreasing can improve performance, but below about 100 looks awful\nconst int MARCH_ITERS = 256;\n\nconst float HIT_DIST = 0.0001;\n\n// Unexpectedly, even this massive clip bound has little effect on perf when reduced.\n// The noise marching is just such a dominant factor that this doesn't matter.\nconst float CLIP = 5000.0;\nconst float DEFAULT_ALBEDO = 0.2;\nconst vec3 SUN_POS = vec3(7.0, 1.5, 3.0) * 2.0;\n\nconst vec3 SUN_COLOR = vec3(6.0, 5.0, 4.0);\nconst vec3 SKY_COLOR = vec3(0.5, 0.7, 0.9);\n// The 'backlight' is in the opposite direction from the sun\nconst vec3 BACKLIGHT_COLOR = vec3(0.4, 0.25, 0.2);\n\nconst vec3 AMBIENT = vec3(0.05, 0.05, 0.2);\n\nconst int DEFAULT_MAT = 0;\nconst int GROUND_MAT = 1;\nconst int WATER_MAT = 2;\nconst int ROCKS_MAT = 3;\nconst vec3[] MATERIALS =\n    vec3[](vec3(0.3, 0.175, 0.1), vec3(0.03, 0.08, 0.01),\n           vec3(0.000, 0.008, 0.12), vec3(0.03, 0.03, 0.027));\nconst float[] MAT_SPECULAR = float[](0.0, 0.0, 1.15, 2.0);\nfloat staticNoise = -200.0;\n\n// hash() and noise() is from Inigo Quilez \"Noise - value - 3D\"\n// https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p) // replace this by something better\n{\n  p = fract(p * 0.3183099 + .1);\n  p *= 17.0;\n  return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\nfloat noise(in vec3 x) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  return mix(\n      mix(mix(hash(p + vec3(0, 0, 0)), hash(p + vec3(1, 0, 0)), f.x),\n          mix(hash(p + vec3(0, 1, 0)), hash(p + vec3(1, 1, 0)), f.x), f.y),\n      mix(mix(hash(p + vec3(0, 0, 1)), hash(p + vec3(1, 0, 1)), f.x),\n          mix(hash(p + vec3(0, 1, 1)), hash(p + vec3(1, 1, 1)), f.x), f.y),\n      f.z);\n}\n\n// https://www.shadertoy.com/view/tdBXWK\nfloat fbm(in vec3 p) {\n  float res = 0.;\n  vec3 q = p;\n  float amp = 1.0; //\n  for (int i = 0; i < 5; i++) {\n    float fi = float(i);\n    res += amp * noise(q);\n    amp *= 0.5; //\n    q *= 2.0;\n  }\n  return res;\n}\n\n// from iquilezles.org/articles/distfunctions opRepLim\nvec3 repetitionWithLimit(in vec3 p, in float c, in vec3 below, in vec3 above) {\n  vec3 repeat = p - c * clamp(round(p / c), -below, above);\n  return repeat;\n}\nvec3 repetitionWithLimit(in vec3 p, in float c, in vec3 lim) {\n  return repetitionWithLimit(p, c, lim, lim);\n}\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat dot2(in vec3 v) { return dot(v, v); }\nfloat ndot(in vec2 a, in vec2 b) { return a.x * b.x - a.y * b.y; }\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2(k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot2(ca), dot2(cb)));\n}\n\nfloat columns(in vec3 p) {\n  float heightMod = sin(0.25 * p.z);\n  p.x += -3.0;\n  p.y -= 2.0;\n  p = repetitionWithLimit(p, 8.0, vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0));\n  float d = length(p.xz) - 0.35 + (0.025 * p.y);\n  d -= 0.05 * (0.5 + 0.5 * pow(sin(p.y * 15.0), 3.0));\n  d -= 0.1 * pow(0.5 + 0.5 * sin(p.y * 15.0), 0.05);\n  d = max(d, p.y - 4.0 + heightMod);\n  d = max(d, -p.y - 6.0);\n  return d;\n}\n\nfloat roof(in vec3 p) {\n#ifdef NOISE_OFFSETS\n  float theNoise = fbm(p / 2.0);\n#else\n  float theNoise = 1.0;\n#endif\n  p.x += -3.0 + 4.0;\n  p.y -= 5.75 - sin(0.25 * p.z);\n\n  float xSize = 6.0 * pow(0.5 + 0.5 * cos(1.5 * p.z), 0.001) - 0.5 * theNoise;\n  xSize += 0.2 * pow(0.5 + 0.5 * sin(3.0 * (p.z + abs(p.y - 5.75))), 15.0);\n  float zSize = 10.0 - 0.25 * theNoise;\n  zSize +=\n      0.1 * pow(0.5 + 0.5 * cos(3.0 * (p.x - abs(p.y - 5.75) / 3.0)), 15.0);\n  return sdRoundBox(p, vec3(xSize, 0.1 * theNoise, zSize), 0.2);\n}\n\nfloat templeBase(in vec3 p) {\n\n#ifdef NOISE_OFFSETS\n  float hMod = 0.05 * fbm(p);\n#else\n  float hMod = 0.0;\n#endif\n  p.x += -3.0;\n  p.y += 3.375;\n\n  p = repetitionWithLimit(p, 4.0, vec3(2.0, 0.0, 2.0), vec3(0.0, 0.0, 2.0));\n\n  float topLevel = sdRoundBox(p, vec3(1.9, 0.2 + 0.5 * hMod, 1.9), .2);\n\n  p.x -= 2.0;\n  p.z -= 2.0;\n  p.y += 0.21;\n\n  p = repetitionWithLimit(p, 4.0, vec3(1.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0));\n\n  float bottomLevel = sdRoundBox(p, vec3(1.9, 0.2 + hMod, 1.9), .2);\n  return min(topLevel, bottomLevel);\n}\n\nfloat temple(in vec3 p) {\n  float d = columns(p);\n  d = min(d, roof(p));\n  d = min(d, templeBase(p));\n  return d;\n}\n\nfloat ground(in vec3 p) {\n  p.y += 13.60;\n#ifdef NOISE_OFFSETS\n  p.y -= 0.45 * fbm(p / 1.25);\n#endif\n  float shrink = p.y * 0.3;\n  return sdCappedCone(p, 10.0 - shrink, 45.0, 15.0) - shrink;\n}\n\n// Applies a very slight curve, which improves the horizon a bit.\nfloat curvature(in vec3 p, in float d) { return d + 0.05 * length(p.xz); }\n\nfloat water(in vec3 p) {\n  float base = dot(p, vec3(0, 1.0, 0)) + 2.75;\n  float waves =\n      base + (2.0 * 0.5 + 0.5 * (1.0 - smoothstep(10.0, 100.0, abs(p.z)))) *\n                 (0.5 + 0.5 * sin(0.4 * p.z + 3.0 * iTime));\n  waves += 0.5 * (0.5 + 0.5 * pow(sin(0.1 * p.x + iTime), 2.0));\n  float longwaves = waves + 7.0 * (0.5 + 0.5 * cos(0.025 * p.z + iTime));\n  return curvature(p, longwaves);\n}\n\nfloat rocks(in vec3 p) {\n  float noiseVal = 15.0 * fbm(vec3(p.xz / 20.0, 1.0));\n  float islands = p.y + noiseVal + 5.0;\n\n  return curvature(p, islands);\n}\n\nvoid checkIntersect(inout float minRecord, float check, inout int mat,\n                    int newMat) {\n  if (check < minRecord) {\n    minRecord = check;\n    mat = newMat;\n  }\n}\n\nfloat intersect(in vec3 p, out int matIndex) {\n  float d = temple(p);\n  matIndex = DEFAULT_MAT;\n\n  checkIntersect(d, ground(p), matIndex, GROUND_MAT);\n  checkIntersect(d, water(p), matIndex, WATER_MAT);\n  checkIntersect(d, rocks(p), matIndex, ROCKS_MAT);\n\n  return d;\n}\n\nfloat intersect(in vec3 p) {\n  int mat;\n  return intersect(p, mat);\n}\n\nvec3 calcNormal(in vec3 pos) {\n  vec2 e = vec2(0.0001, 0.0);\n  return normalize(vec3(intersect(pos + e.xyy) - intersect(pos - e.xyy),\n                        intersect(pos + e.yxy) - intersect(pos - e.yxy),\n                        intersect(pos + e.yyx) - intersect(pos - e.yyx)));\n}\n\nvec3 camera() {\n  //TODO mouse movement?\n  float animProgress = 0.2 * iTime;\n\n  return vec3(+20.0 + 30.0 * sin(animProgress), 13.5, 25.0);\n}\n\nvec3 getMaterial(int matIndex, vec3 p) {\n  vec3 mat = MATERIALS[matIndex];\n  // These are a bit of a hack, but they improve things a little bit.\n  if (matIndex == GROUND_MAT) {\n    // First, apply some noisiness - it makes the ground a bit patchier\n    float theNoise = fbm(p);\n    mat += vec3(0.02, 0.015, 0.01) * abs(1.0 - theNoise);\n    // Now, apply a yellowing/browning changge as we get lower\n    mat += vec3(0.25, 0.15, 0.1) * (abs(p.y) /20.0);\n    // Finally, vary the 'saturation'. (It might not actually be saturation, but it works).\n    // Basically this gives some color variety, and makes it feel a bit rockier.\n    mat *= theNoise * 0.5;\n  } else if (matIndex == WATER_MAT) {\n    // This is just a quick and dirty hack to lighten water near the ground cone\n    // It's not hugely noticeable, but it makes it look a bit better.\n    float groundBreakMult = 1.0 + clamp(0.4 - ground(p), 0.0, 1.0);\n    mat *= groundBreakMult;\n\n    //Also give the ocean colors a bit of variety with noise.\n    float theNoise = 1.0 - pow(fbm(p / 20.0), 0.05);\n    mat += vec3(0.75, 0.75, 0.75) * 0.5*theNoise;\n  }\n  return mat;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd, out int materialIndex,\n               out vec3 material) {\n  float marched = 0.0;\n  vec3 rayPos;\n  for (int i = 0; i < MARCH_ITERS; i++) {\n    rayPos = ro + marched * rd;\n    float dist = intersect(rayPos, materialIndex);\n    if (abs(dist) < HIT_DIST)\n      break;\n    marched += dist;\n    if (marched > CLIP)\n      break;\n  }\n\n  if (marched > CLIP)\n    marched = -1.0;\n  else {\n    material = getMaterial(materialIndex, rayPos);\n  }\n\n  return marched;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd) {\n  int matIdx;\n  vec3 hitMat;\n  return raymarch(ro, rd, matIdx, hitMat);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 point = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n  // Ray origin\n  vec3 ro = camera();\n\n  vec3 ta = vec3(0.0, 0.0, 0.0);\n\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  vec3 rd = normalize(point.x * uu + point.y * vv + 1.5 * ww);\n\n  // If you want a basic diffuse sky in the background, this will work\n  vec3 col = vec3(0.1, 0.25, 0.6) - 0.7 * rd.y;\n  \n  int matIndex;\n  vec3 material;\n\n  float marched = raymarch(ro, rd, matIndex, material);\n\n  if (marched > 0.0) {\n    vec3 pos = ro + (marched * rd);\n    vec3 normal = calcNormal(pos);\n\n    vec3 specLightDir = normalize(SUN_POS - pos);\n    vec3 specReflectDir = reflect(specLightDir, normal);\n\n    // There are almost certainly additional lighting calculations that could be added,\n    // but I'm not experienced enough to know what they are.\n    vec3 sunDir = normalize(SUN_POS);\n    float sunDiffuse = clamp(dot(normal, sunDir), 0.0, 1.0);\n    float sunShadow = step(raymarch(pos + normal * 0.0001, sunDir), 0.0);\n    float backlitDiffuse =\n        clamp(dot(normal, vec3(-sunDir.x, sunDir.y, -sunDir.z)), 0.0, 1.0);\n    float specIntensity = MAT_SPECULAR[matIndex] *\n                          pow(clamp(dot(specReflectDir, rd), 0.0, 1.0), 50.0);\n    float attenuation = pow(marched, 2.0) / pow(CLIP, 6.0);\n\n#ifdef SKY_ENABLED\n    float skyDiffuse =\n        clamp(0.5 + 0.5 * dot(normal, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n#endif\n\n    col = material * SUN_COLOR * sunDiffuse * sunShadow;\n    col += material * BACKLIGHT_COLOR * backlitDiffuse;\n    col += material * SUN_COLOR * specIntensity;\n    col += vec3(0.01, 0.0075, 0.0075) - attenuation;\n    col += material * AMBIENT;\n\n#ifdef SKY_ENABLED\n    col = mix(SKY_COLOR, col, exp(marched * -0.00005));\n    col += material * SKY_COLOR * skyDiffuse;\n#endif\n  }\n\n  // gamma\n  col = pow(col, vec3(0.4545));\n\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}