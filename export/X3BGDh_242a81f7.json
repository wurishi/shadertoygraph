{"ver":"0.1","info":{"id":"X3BGDh","date":"1708388333","viewed":98,"name":"Single-loop grid neighbor visit","username":"chronos","description":"Just a simple one this time. See description.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["grid","loop","traversal","single","neighbour","neighbor","visit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\n    Just a simple trick to iterate over cell neighbors.\n    Probably well known, and probably there are better ways, but this was the first that came to mind\n    Just sharing in case anyone finds it useful :)\n    ( Or in case anyone would like to point out one of those better ways :D )\n    \n    Roughly analogous to stepping in the direction of the tangent vector of a circle and normalizing.\n\n    // Iterate grid neighbours in this order with a single loop:\n    \n    3  2  1\n    4  .  0\n    5  6  7\n    \n    vec2 p = vec2(1,0);\n    for(int i = 0; i < 8; i++)\n    {\n        vec2 p2 = p + vec2(-p.y, p.x);       Rotate offset 90 degrees counter-clockwise and Step\n        p = p2 / max(abs(p2.x), abs(p2.y));  // Normalize to square\n    }\n\n\n*/\n\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-= a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 2.;\n\n    vec2 uv = zoom*(2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec2 p = uv;\n\n    // Rot 90 ccw:\n    vec2 rot = vec2(-p.y, p.x);\n\n    // Step:\n    vec2 p2 = p + rot;\n\n    p2 /= max(abs(p2.x), abs(p2.y));\n\n    // square normalize:\n    color.rg +=  p2*.5 + .5;\n    color.b += 1.-(p2.y*.5 + p2.x*.5 + .5);\n    color = pow(clamp(color, 0., 1.), vec3(2.2));\n    color *= 0.25;\n\n    // Draw arrows\n    p = vec2(1,0);\n    for(int i = 0; i < 8; i++)\n    {\n        // Rot 90 ccw:\n        vec2 rot = vec2(-p.y, p.x);\n\n        // Step:\n        vec2 p2 = p + rot;\n\n        // normalize\n        p2 = p2 / max(abs(p2.x), abs(p2.y));\n        \n        vec2 p3 = mix(p, p2, .95);\n        float d = seg(mix(p, p2, .1), p3, uv);\n        float a = smoothstep(0., -0.01, d-.03);\n        color = mix(color, vec3(1), a);\n        \n        d = ((abs(p3 - uv).x + abs(p3-uv).y)) - 0.05;\n        a = smoothstep(0., -0.01, d);\n        color = mix(color, vec3(1), a);\n        \n        p = p2;\n    }\n\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}