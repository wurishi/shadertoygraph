{"ver":"0.1","info":{"id":"ssjSzw","date":"1619942022","viewed":129,"name":"Fog on the plane2","username":"Marina033","description":"fog","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float INF = 1e10;\nconst float MARCH_SIZE = 0.1; // very impotant value \nconst int MAX_STEPS = 100;\n\nfloat ABSORPTION = 1.3;\nfloat ATTENUATION1 = 5.0;\nfloat NOISE_AMPLITUDE = 1.0;\nvec3 randDir; // for soft shadows\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\nconst int FOGGY = 4;\n\n/*vec3 SPHERE_POS = vec3(0, 2, 2);\nfloat SPHERE_RADIUS = 2.0;\nvec3 SPHERE_COLOR = vec3(0.0, 0.5, 0.5);*/\n\nvec3 FOG_POS = vec3(0, 0.5, 2);\nfloat FOG_RADIUS = 1.5;\nvec3 FOG_COLOR = vec3(0.5, 0.9, 0.5);\n\n\nvec3 LIGHT1_POS = vec3(0, 2, 0);\nfloat LIGHT1_RADIUS = 5.0; // TODO this light should not visible\nfloat LIGHT1_RADIUS_INNER = 3.5;\nvec3 LIGHT1_COLOR = vec3(0.5, 1, 1);\n\nfloat plane_intersection(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-0.5  - pos.y) / dir.y;\n    if (t <= 0.0) return INF;    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) return INF;        \n    normal = vec3(0, 1, 0);\n    return t;\n}\n\n\n\n\nvec3 computeLight(vec3 pos, vec3 normal, vec3 color) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distsq1 = dot(toLight1, toLight1);\n    //these string for shadow\n    //float att1 = isOcluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : ATTENUATION1 / distsq1; // attenuation\n    float att1 = clamp((LIGHT1_RADIUS - length(toLight1) + LIGHT1_RADIUS_INNER) / (LIGHT1_RADIUS - LIGHT1_RADIUS_INNER), 0.0, 1.0);\n    return color * (max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n            + texture(iChannel2, pos).rgb * 0.3 //ambient from forest\n            \n            );\n    \n}\n\n\nfloat sphereSdf(vec3 pos, vec3 spherePos, float radius) {\n    float scale = mix(0.25, 1.0, 0.0);\n    return length((pos - spherePos) * vec3(scale, 1.0, scale)) - radius;\n    //return length(pos - spherePos) - radius;\n}\nfloat rand(float frame){\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\n\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled) {\n    return exp(-absorptionCoefficient * distanceTraveled); // e^(-kd);\n}\nfloat fogDensity(vec3 pos, float sdf) {\n\n    vec3 localCurPos = pos - LIGHT1_POS;\n    vec2 rot1 = vec2(cos(0.0), -sin(0.0));\n    vec2 rot2 = vec2(sin(0.0), cos(0.0));\n    localCurPos.xz = vec2(dot(rot1, localCurPos.xz), dot(rot2, localCurPos.xz));\n               \n    float density = texture(iChannel1, (LIGHT1_POS + localCurPos) * 0.05).r; // плотность\n    return min(density, -sdf); // для красивого тумана на краях\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randValue = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 10)));\n    randDir = normalize(randValue - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randValue.x - 0.5) * 2.0) / iResolution.x;\n    //anti aliasing\n    \n    vec3 cameraPos = vec3(0, 3, -8);\n    vec3 front = normalize(-cameraPos);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec= normalize(front + uv.x * right + uv.y * up);\n    vec3 curPos = cameraPos;\n    vec3 curDir = viewVec;\n    \n    \n    \n    \n    \n   \n   \n    \n    for (int i = 0; i < 10; i++) {\n        float t = INF;\n        float tFog = INF;\n        int matType;\n        vec3 color = vec3(0, 1, 0);// texture(iChannel1, curDir).rgb;\n        vec3 result = texture(iChannel2, curDir).rgb;\n        vec3 normal;\n        vec3 planeNormal;\n        vec3 fogNormal; // does not use\n        vec3 worldPos;\n        vec3 curPosFog = curPos;\n        vec3 colorMult = vec3(1,1,1);\n        \n        \n        \n        \n        \n        \n        \n        \n        \n       \n        float planeT = plane_intersection(curPos, curDir, planeNormal);\n        if (planeT < t) {\n            t = planeT;\n            worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.05).rgb;\n            normal = planeNormal;\n            result = computeLight(worldPos, normal, color) * colorMult; \n        } \n        \n       \n\n\n        //drawing fog\n        vec3 fogEffect = vec3(0.0);\n        float opacity = 1.0;\n        curPosFog = curPos; \n        for (int i = 0; i < MAX_STEPS; i++) {\n            if (t < MARCH_SIZE * float(i)) { // чтобы туман пропал при приближении к предметам\n                break;\n            }\n            curPosFog = curPos +  curDir * MARCH_SIZE * float(i);\n            float sdf = sphereSdf(curPosFog, FOG_POS, FOG_RADIUS);\n            if (sdf < 0.0) {\n                float prevOpacity = opacity;\n                \n                \n                float fogDens = fogDensity(curPosFog, sdf);\n                opacity *= BeerLambert(ABSORPTION * fogDens, MARCH_SIZE);\n                float absorption = prevOpacity - opacity;\n                vec3 fogColor = FOG_COLOR * texture(iChannel1, curPosFog * 0.05).r;\n                vec3 ambient = texture(iChannel2, curDir).rgb * 0.3;\n                fogEffect += vec3(absorption) * fogColor * ambient;\n                \n                vec3 toLight1 = LIGHT1_POS - curPosFog;\n                float att1 = clamp((LIGHT1_RADIUS - length(toLight1) + LIGHT1_RADIUS_INNER) / (LIGHT1_RADIUS - LIGHT1_RADIUS_INNER), 0.0, 1.0);\n               \n                \n                fogEffect += fogColor * LIGHT1_COLOR * absorption * att1;\n              \n              \n              \n            }\n            \n           \n        }\n        result = mix(fogEffect, result, opacity) * colorMult;\n        \n        \n        \n       \n      \n        fragColor = vec4(result, 1.0);\n        \n    }\n}","name":"Image","description":"","type":"image"}]}