{"ver":"0.1","info":{"id":"3tGXDD","date":"1582691893","viewed":167,"name":"1d celular automata","username":"lucastakejame","description":"4 CAs starting at the center ","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["ca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.;\n    fragColor = texelFetch(iChannel0, ivec2((fragCoord-iResolution.xy/2.)*1./zoom + iResolution.xy/2. ),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n\n// makes CA slide towards center after a few seconds\n#define MOVE 0\n// 4 celular automata at the center\n#define CENTER4CA 1\n\n// number of input cels to iterate the CA\n// \n#define INPUT_COUNT 3\n\n// in seconds\n#define RULE_PERIOD 6.\n#define RULE(t) RLS[int(t)%RLS.length()]\n\n\n#define t(fragCoord) texelFetch(iChannel0, ivec2(fragCoord), 0)\n#define eq(a,b) (abs(a - b) < 1.)\n\n\n// interesting rules\n// 111 110 101 100 011 010 001 000 ids\n// 0x00011110 rule 30 in binary\n// possible rules are in the range of [0, 2^INPUT_COUNT - 1]\nint[] RLS = int[](22, 30, 45, 54, 57, 60, 62, 73, 75, 86, 89, 110, 169);\n\nvec2 zRot(vec2 p, float a)\n{\n    vec2 r = vec2(cos(a), sin(a));\n    return vec2(p.x*r.x - p.y*r.y, p.x*r.y + p.y*r.x);\n}\n\nstruct CA\n{\n\tvec2 center;\n    // time direction\n    vec2 dir;\n    int rule;\n};\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat next(vec2 idxCenter, CA c)\n{\n    //idxCenter -= dir;\n    \n    int inputCount = INPUT_COUNT;\n    float bitPos = exp2(float(inputCount-1));\n    int id = 0;\n    \n    // perpendicular to time direction\n    vec2 dirRot = zRot(c.dir, PI/2.);\n    \n    for(int i = -(inputCount/2); i <= (inputCount/2); i++)\n    {\n        vec2 offset = dirRot*float(i);\n        \n        #if MOVE\n        // after a time pixel will read it self instead of self-c.dir\n\t\toffset -= c.dir*(iTime<12.?1.:0.);\n        #else\n\t\toffset -= c.dir;\n        #endif\n        \n        id += ( t(idxCenter + offset).a > 0.)? int(bitPos) : 0;\n\t\tbitPos/=2.;\n    }\n    // tip from FabriceNeyret2\n    return float( ((c.rule >>= id) & 1)*(id + 1));\n}\n\nvec4 runCA(CA c, vec2 fragCoord)\n{\n    vec4 fragColor;\n    vec2 dist = fragCoord - c.center;\n    float d = dot(dist, c.dir);\n    \n\t// draw horizontal line with 1 black dot\n    if( abs(d) < 1.)\n    {\n       \t// initial condition\n        float val = (length( fragCoord - c.center) < 1.)?0.:1.;\n        fragColor = vec4(val);\n    }\n\t// 0 whats behind the line and out of a 45 degree cone\n    else if( d < 0. || dot(normalize(dist), c.dir) < cos(PI/4.))\n    {\n        fragColor = vec4(0.);\n    }\n    else\n    {\n        float n = next(fragCoord, c);\n        float m = float(1U<<INPUT_COUNT);\n        // got the coloring idea from @mla's https://www.shadertoy.com/view/tlKSWD\n        // added a twist\n        fragColor = n == 0.? vec4(0.): vec4(hsv2rgb(vec3(mod(n+length(dist/100.), m)/m, 1., 1.)), 1.);\n    }\n    return fragColor;\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CA c;\n    vec2 newCoord = fragCoord - vec2(iResolution.xy/2.);\n    \n    float t = (RULE_PERIOD > 0.)?iTime*1./float(RULE_PERIOD): 0.;\n    \n    // [WIP] not working yet, wanna set 4 CA growind in perpendicular directions\n    #if CENTER4CA\n    \t if(newCoord.x >  abs(newCoord.y)){c.rule = RULE(t + 0.); c.dir = vec2(1., 0.);}\n    else if(newCoord.y >  abs(newCoord.x)){c.rule = RULE(t + 1.); c.dir = vec2(0., 1.);}\n    else if(newCoord.x < -abs(newCoord.y)){c.rule = RULE(t + 2.); c.dir = vec2(-1., 0.);}\n    else\t\t\t\t\t\t\t\t  {c.rule = RULE(t + 3.); c.dir = vec2(0., -1.);}\n\n    c.center = vec2(iResolution.xy/2.) + 3.*c.dir;\n    #else\n    c.rule = RULE(t);\n    c.center = vec2(0., iResolution.y/2.);\n    c.dir = normalize(vec2(1., 0.));\n    #endif\n    fragColor = runCA(c, fragCoord);  \n}","name":"Buffer A","description":"","type":"buffer"}]}