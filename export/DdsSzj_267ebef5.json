{"ver":"0.1","info":{"id":"DdsSzj","date":"1669218655","viewed":446,"name":"Pathtraced SSS","username":"Poisson","description":"It's very inefficient.","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","sss","raytracer","ray","volume","volumetric","glass","pathtracing","pathtracer","skin","path","spectral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// more realistic color range\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .06;\n    float c = 2.1;\n    float d =  .7;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = data.rgb/data.w;\n    \n    col = pow(col,vec3(.4545)); // gamma correction\n    col = ACES(col);\n    \n    // vignette\n    vec2 p = fragCoord/iResolution.xy;\n    col *= clamp(pow(100. * p.x*p.y*(1.-p.x)*(1.-p.y), .1), 0., 1.);\n    // dithering\n    col += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.;\n        \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SAMPLES 8 // renders per frame\n\n// ray indices\n#define RED 0\n#define GREEN 1\n#define BLUE 2\n\nfloat seed; // randoms seed\n\n// hash functions by me\nfloat hash1() {return fract(sin(seed+=.1)*4561.7564);}\n\nvec2 hash2() {return fract(sin(seed+=.1)*vec2(8472.5636,9854.4213));}\n\nvec3 hash3() {return fract(sin(seed+=.1)*vec3(7653.1285,6912.8512,5914.7134));}\n\n// random normalized vector\nvec3 uniformVector() {\n    vec3 v = hash3()*2.-1.;\n    return normalize(v);\n}\n\n// generate a value that depend on the ray index\nfloat rayValues(int n, vec3 v) {\n    return n==RED ? v.x : n==GREEN ? v.y : v.z;\n}\n\n// sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra, vec3 mat, int type,\n                   float tmax, inout vec3 outn, inout vec3 outmat, inout int outtype) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c;\n    if (h<0.) return tmax;\n    \n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    float t = t1<.0001 ? t2 : t1;\n    if (t>.0001 && t<tmax) {\n        outn = (oc + rd*t)/ra;\n        outmat = mat;\n        outtype = type;\n        return t;\n    }\n    return tmax;\n}\n\n// box intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat boxIntersect(vec3 ro, vec3 rd, vec3 ce, vec3 ra, vec3 mat, int type,\n                   float tmax, inout vec3 outn, inout vec3 outmat, inout int outtype) {\n    vec3 oc = ro - ce;\n\n    vec3 m = 1./rd;\n    vec3 n = -m*oc;\n    vec3 k = abs(m)*ra;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n\t\n\tif(tN>tF || tF<0.) return tmax;\n    \n    float t = tN<.0001 ? tF : tN;\n    if (t>.0001 && t<tmax) {\n\t\toutn = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        outmat = mat;\n        outtype = type;\n\t    return t;\n    }\n    return tmax;\n}\n\n// materials indices\n#define LAMBERTIAN 0 // diffuse\n#define DIELECTRIC 1 // transparent\n#define EMISSIVE 2 // light\n\n// n is the normal\n// mat is the color of the object\n// type is the type of material: lambertian, dielectric or emissive\n\nfloat intersect(vec3 ro, vec3 rd, int ray, out vec3 n, out vec3 mat, out int type) {\n    float t = 1e10;\n\n    // inside: atmospheric volume\n    t = sphIntersect(ro, rd, vec3(0,0,.1), .8-.1*hash1()*rayValues(ray, vec3(3,1,1)), vec3(1), LAMBERTIAN, t, n, mat, type);\n    // outside: transparent sphere\n    t = sphIntersect(ro, rd, vec3(0,0,.1), .8, vec3(1,.85,.7), DIELECTRIC, t, n, mat, type);\n    \n    // inside: atmospheric volume\n    t = sphIntersect(ro, rd, vec3(0,0,-1.3), .5-.1*hash1()*rayValues(ray, vec3(2,1,1)), vec3(1), LAMBERTIAN, t, n, mat, type);\n    // outside: transparent sphere\n    t = sphIntersect(ro, rd, vec3(0,0,-1.3), .5, vec3(1,.85,.7), DIELECTRIC, t, n, mat, type);\n\n    // floor\n    t = boxIntersect(ro, rd, vec3(0,-.8,0), vec3(2,0,2), vec3(.3,.4,.5), LAMBERTIAN, t, n, mat, type);\n    \n    // light\n    t = sphIntersect(ro, rd, vec3(0,1,-1.3), .3, vec3(16), EMISSIVE, t, n, mat, type);\n    \n    return t;\n}\n\n// diffuse BRDF\nvec3 cosineDirection(vec3 n) {\n  \tvec2 r = hash2();\n    \n\tvec3 u = normalize(cross(n, vec3(0,1,1)));\n\tvec3 v = cross(u, n);\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(2.*3.141592*r.x); \n\tfloat ry = ra*sin(2.*3.141592*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\treturn normalize(rx*u + ry*v + rz*n);\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd, int ray) {\n    vec3 col = vec3(1);\n    \n    for (int i=0; i<24; i++) { // 24 ray bounces\n        vec3 n, mat; int type;\n        float t = intersect(ro, rd, ray, n, mat, type);\n        if (t>=1e10) {\n            if (i==0) return vec3(.5+.5*rd.y)*.01; // background\n            return vec3(0);\n        } else {\n            vec3 p = ro + rd*t;\n            ro = p;\n            \n            col *= mat; // multiply the color by the material albedo\n            \n            if (type==LAMBERTIAN) { // diffuse object\n                rd = cosineDirection(n);\n            } else if (type==DIELECTRIC) { // transparent object\n                float fre = dot(rd, n); // fresnel\n                float s = sign(fre);\n                vec3 m = -n*s;// normal inside and outside\n                float ior = 1.3; // refraction index\n                float v = (.5-.5*s)/ior+ior*(.5+.5*s);\n                // refracted ray + a bit of randomness for a better effect\n                rd = normalize(refract(rd, m, v) + .5*uniformVector());\n            } else if (type==EMISSIVE) {\n                return col;\n            }\n        }\n    }\n    return vec3(0); // return black\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n\tvec3 w = normalize(ta - ro);\n\tvec3 u = normalize(cross(w, vec3(0,1,0)));\n\tvec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0);\n    for (int i=0; i<SAMPLES; i++) {\n    seed = float(i)+iTime+dot(sin(fragCoord),vec2(443.712,983.234));\n        \n    vec2 of = hash2()-.2;\n    vec2 p = (fragCoord+of - .5*iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n    \n    float an = m.x*3.141592-1.8; // camera rotation\n    vec3 ro = vec3(-4.*sin(an), m.y*3.+1., -4.*cos(an)); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n\n    // 3 renders: red, green and blue\n    vec3 col = vec3(render(ro, rd, RED).r,\n                    render(ro, rd, GREEN).g,\n                    render(ro, rd, BLUE).b);\n    tot += col;\n    }\n    tot /= float(SAMPLES);\n    \n    // accumulate\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z>0.) data*=0.;\n    data += vec4(tot,1);\n\n    // output\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}