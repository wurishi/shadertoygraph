{"ver":"0.1","info":{"id":"7dGfDh","date":"1658079655","viewed":109,"name":"A-Star, Bidirectional Dijkstra","username":"mattdeeds","description":"This animation compares three algorithms for finding the shortest path from the red dot to the blue dot: A-Star, Bidirectional Dijkstra, and Bidirectional A-Star.  It assumes a grid-like connected graph between the two points.  Click to place destination.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["visualization","search"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// When trying to predict the quickest route, we need to use\n// a fast (e.g. 100kph) estimate for speed - the route might be about to get on a freeway.\n// However, most of the time the track will continue on a slower road, e.g. 50kph\n// The ratio of these is what I call kLengthQuality here.  Reasonable values are 0.3 to 0.7\n#define kLengthQuality 0.5\n\nfloat a_cost(vec2 o, vec2 d, vec2 pos) {\n  vec2 aod = abs(pos - o);\n  float o_cost = aod.x + aod.y;\n  float d_cost = length(pos - d) * kLengthQuality;\n  return o_cost + d_cost;\n}\n\nfloat bd_cost(vec2 o, vec2 d, vec2 pos) {\n  vec2 ao = abs(pos - o);\n  float o_cost = ao.x + ao.y;\n  vec2 ad = abs(pos - d);\n  float d_cost = ad.x + ad.y;\n  return min(o_cost, d_cost);\n}\n\nfloat bda_cost(vec2 o, vec2 d, vec2 pos) {\n  float o_cost = a_cost(o, d, pos);\n  float d_cost = a_cost(d, o, pos);\n  return min(o_cost, d_cost);\n}\n\nfloat cost(vec2 o, vec2 d, vec2 pos) {\n  return bda_cost(o, d, pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n\n    vec2 o = vec2(-0.5, -0.25);\n    vec2 d = vec2(0.5, 0.25);\n    \n    if (length(iMouse.xy) > 0.0) {\n      d = 2.0 * (iMouse.xy - 0.5 * iResolution.xy) /iResolution.y;\n    }\n    \n    vec3 c = vec3(bda_cost(o, d, uv), bd_cost(o, d, uv), a_cost(o, d, uv));\n    \n    vec3 col = vec3(1.0, 1.0, 1.0) * mod(c - iTime * 0.1, 1.0);\n    if (length(o - uv) < 0.02) {\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    if (length(d - uv) < 0.02) {\n      col = vec3(0.0, 0.0, 1.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}