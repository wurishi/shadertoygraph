{"ver":"0.1","info":{"id":"tsXXRS","date":"1552804576","viewed":1357,"name":"Atmosphere Scattering","username":"codeonwort","description":"Trying to implement the paper \"Precomputed Atmospheric Scattering\"\n- I can't understand the zero scattering term...\n- This shader calculates only single scattering.\n- TODO: multiple scattering.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/////////////////////////////////////////////////////////////////////\n// TODO: Need physically correct measures. Remove these magic numbers.\n//\n// https://en.wikipedia.org/wiki/Luminosity\n//     luminosity of the Sun which is 3.86Ã—1026 W\n//\n// what???\n//     sun_luminosity / (sun_dist^2 * 4pi) = 13.61839144264511 * 10^2 (Watts / meter^2)\n#define SunColor              vec3(1.0, 1.0, 1.0)\n#define SunIntensity          13.61839144264511\n#define SunDiskMultiplier     10.0\n#define MAGIC_RAYLEIGH        1.0\n#define MAGIC_MIE             0.2\n/////////////////////////////////////////////////////////////////////\n\n// Animates the sun height if 0\n#define FIXED_SUN_DIRECTION  0\n#define SunDirection          normalize(vec3(0.0, -0.3, 1.0))\n\n#define PI                    3.14159265359\n#define FOV                   60.0\n\n// Unit: meters\n// 149,600,000 km = (1.496 * 10^11) m\n#define SUN_DISTANCE          1.496e11\n// 695,510 km = (6.9551 * 10^8) m\n#define SUN_RADIUS            6.9551e8\n// 6360 km = (6.36 * 10^6) m\n#define EARTH_RADIUS          6.36e6\n#define ATMOSPHERE_RADIUS     6.42e6\n#define Hr                    7.994e3\n#define Hm                    1.2e3\n\n// Unit: 1 / meters\n#define BetaR                 vec3(5.8e-6, 13.5e-6, 33.1e-6)\n#define BetaM                 vec3(21e-6)\n\nsphere_t atmosphere = sphere_t(vec3(0.0), ATMOSPHERE_RADIUS);\n\nfloat phaseR(float cosTheta)\n{\n    return 3.0 / (16.0 * PI) * (1.0 + cosTheta * cosTheta);\n}\nfloat phaseM(float t)\n{\n    const float g = 0.76;\n    float gg = g * g;\n    float tt = t * t;\n    float gt = g * t;\n    \n    float num = 3.0 * (1.0 - gg) * (1.0 + tt);\n\tfloat denom = (8.0 * PI) * (2.0 + gg) * pow(1.0 + gg - 2.0 * gt, 1.5);\n    return num / denom;\n}\n\n// Radiance of sun before hitting the atmosphere\nvec3 sunImage(ray_t camera, vec3 sunDir)\n{\n    // EARTH_RADIUS is too small compared to SUN_DISTANCE\n    //float denom = exp(0.5 * (log(SUN_DISTANCE + EARTH_RADIUS) + log(SUN_DISTANCE - EARTH_RADIUS)));\n    \n    float threshold = asin(SUN_RADIUS / SUN_DISTANCE);\n    float angle = acos(dot(camera.direction, -sunDir));\n    if(angle <= threshold * SunDiskMultiplier)\n    {\n        return SunIntensity * SunColor;\n    }\n    return vec3(0.0);\n}\n\nvec3 scene(ray_t camera, vec3 sunDir)\n{\n    hit_t hit = no_hit;\n    intersect_sphere(camera, atmosphere, hit);\n    \n    vec3 AtmosphereScattering = vec3(0.0);\n    bool isGround = false;\n    \n    const int numSteps = 64;\n    const int inscatSteps = 16;\n    \n    float mu = dot(-sunDir, camera.direction);\n    vec3 Sun = SunIntensity * SunColor;\n    vec3 T = vec3(0.0);\n    \n    vec3 P = camera.origin;\n    float seg = hit.t / float(numSteps);\n    vec3 P_step = camera.direction * seg;\n    \n    // from eye to the outer end of atmosphere\n    for(int i=0; i<numSteps; ++i)\n    {\n        float height = length(P) - EARTH_RADIUS;\n        if(height < 0.0)\n        {\n            isGround = true;\n            break;\n        }\n        \n        // optical depth\n        T += seg * (BetaR * exp(-height / Hr));\n        T += seg * (BetaM * exp(-height / Hm));\n        \n        // single scattering\n        hit_t hit2 = no_hit;\n        ray_t ray2 = ray_t(P, -sunDir);\n        intersect_sphere(ray2, atmosphere, hit2);\n        \n        float segLight = hit2.t / float(inscatSteps);\n        vec3 PL_step = ray2.direction * segLight;\n        vec3 PL = P;\n        \n        vec3 TL = vec3(0.0);\n        bool applyScattering = true;\n        for(int j=0; j<inscatSteps; ++j)\n        {\n            float height2 = length(PL) - EARTH_RADIUS;\n            if(height2 < 0.0)\n            {\n                applyScattering = false;\n                break;\n            }\n            \n            TL += segLight * BetaR * exp(-height2 / Hr);\n        \tTL += segLight * BetaM * exp(-height2 / Hm);\n            \n            PL += PL_step;\n        }\n        if(applyScattering)\n        {\n            TL = exp(-TL);\n\n            vec3 SingleScattering = vec3(0.0);\n            // scattering = transmittance * scattering_coefficient * phase * radiance\n            SingleScattering += MAGIC_RAYLEIGH * seg * exp(-T) * (BetaR * exp(-height / Hr)) * phaseR(mu) * (TL * Sun);\n            SingleScattering += MAGIC_MIE * seg * exp(-T) * (BetaM * exp(-height / Hm)) * phaseM(mu) * (TL * Sun);\n            AtmosphereScattering += SingleScattering;\n        }\n        \n        P += P_step;\n    }\n    \n    // Just magic number\n    if(isGround)\n    {\n        float r = 1.0 - 1.0 / (1.0 + 0.000001 * length(hit.origin - camera.origin));\n        return vec3(r, 0.4, 0.2);\n    }\n    \n    T = exp(-T);\n    \n    // Zero scattering\n\tvec3 L0 = T * sunImage(camera, sunDir);\n    AtmosphereScattering += L0;\n    \n    return AtmosphereScattering;\n}\n\nvoid rotateY(inout vec3 v, float dt)\n{\n    float vx = v.x;\n    v.x = cos(dt) * v.x + sin(dt) * v.z;\n    v.z = -sin(dt) * vx + cos(dt) * v.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u_res = iResolution.xy;\n    vec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\tfloat fov = tan(radians(FOV / 2.0));\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n\tvec3 point_cam = vec3((2.0 * point_ndc - 1.0) * aspect_ratio * fov, -1.0);\n    \n    vec3 eye = vec3(0.0, EARTH_RADIUS, 0.0);\n\tvec3 look_at = vec3(0.0, EARTH_RADIUS + 10.0, -30.0);\n\tray_t eye_ray = get_primary_ray(point_cam, eye, look_at);\n    \n    if(iMouse.z > 0.0) rotateY(eye_ray.direction, (iResolution.x/2.0 - iMouse.x) * 0.01);\n\n#if FIXED_SUN_DIRECTION\n    vec3 sunDir = SunDirection;\n#else\n\tfloat angle_min = 45.0 * (PI / 180.0);\n    float angle_max = 95.0 * (PI / 180.0);\n    float t = fract(iTime * 0.1);\n    t = (t <= 0.5)\n        ? (angle_min + (angle_max - angle_min) * t * 2.0)\n        : (angle_max + (angle_min - angle_max) * (t - 0.5) * 2.0);\n    vec3 sunDir = vec3(0.0, -cos(t), sin(t));\n#endif\n    \n    vec3 finalColor = scene(eye_ray, sunDir);\n    finalColor = pow(finalColor, vec3(1.0 / 2.2));\n    \n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ray, sphere code from https://www.shadertoy.com/view/XtBXDw\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n};\n    \nstruct hit_t {\n\tfloat t;\n\tvec3 normal;\n\tvec3 origin;\n};\n    \n#define max_dist 1e8\nhit_t no_hit = hit_t(\n\tfloat(max_dist + 1e1), // 'infinite' distance\n\tvec3(0., 0., 0.), // normal\n\tvec3(0., 0., 0.) // origin\n);\n\nray_t get_primary_ray(\n\tin vec3 cam_local_point,\n\tinout vec3 cam_origin,\n\tinout vec3 cam_look_at)\n{\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n    ray_t r;\n    r.origin = cam_origin;\n    r.direction = normalize(fwd + up * cam_local_point.y - right * cam_local_point.x);\n\treturn r;\n}\n\nvoid intersect_sphere(\n\tin ray_t ray,\n\tin sphere_t sphere,\n\tinout hit_t hit\n){\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n//\tif (tca < 0.) return;\n\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2)\n\t\treturn;\n\n\tfloat thc = sqrt(radius2 - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\n\tif (t0 < 0.) t0 = t1;\n\tif (t0 > hit.t)\n\t\treturn;\n\n\tvec3 impact = ray.origin + ray.direction * t0;\n\n\thit.t = t0;\n\thit.origin = impact;\n\thit.normal = (impact - sphere.origin) / sphere.radius;\n}\n","name":"Common","description":"","type":"common"}]}