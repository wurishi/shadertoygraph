{"ver":"0.1","info":{"id":"Wl2Gz3","date":"1560527550","viewed":487,"name":"iQ vs nN interpolation","username":"Carandiru","description":"Original Natural Neighbour Interpolation code by Paniq @ https://www.shadertoy.com/view/XlSGRR\nrndC by iq\n\nleft - iq\nright - nn\n\nA comparison of iq's awesome gpu bilinear interpolation hack to the best interpolation available to date, Natural Neighbour.\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["interpolation","natural","neighbour","rndc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original Natural Neighbour Interpolation code by Paniq @ https://www.shadertoy.com/view/XlSGRR\n// rndC by iq\n// modified by Carandiru for my own research and learning and a good reference\n\n#define select(iffalse, iftrue, condition) mix(iffalse, iftrue, condition)\n\nfloat m;\n\nfloat compute_area(in vec2 uv) {\n    vec2 n = abs(normalize(uv));\n    vec4 p = (vec4(n.xy,-n.xy)-length(uv)*0.5f) / n.yxyx;\n    vec4 h = max(vec4(0.0f),sign(1.0f-abs(p)));\n    // fix p becoming NaN; unfortunately 0*(1/0) doesn't\n    // fix the value\n    //p.x = (h.x < 0.5f)?0.0f:p.x;\n    //p.y = (h.y < 0.5f)?0.0f:p.y;\n    //p.z = (h.z < 0.5f)?0.0f:p.z;\n    //p.w = (h.w < 0.5f)?0.0f:p.w;\n\tp = select(p, vec4(0.0f), lessThan(h, vec4(0.5f)));\t\n    \n    p = (p+1.0f)*0.5f;\n    \n    return 0.5f*(h.y*(p.y*p.x*h.x + (p.y+p.w)*h.w) + (p.x+p.z)*h.x*h.z);\n}\n\n// https://www.shadertoy.com/view/MtjBWz - thanks iq\nvec2 rndC(in vec2 uv) // good function\n{\n    uv = uv + 0.5f;\n    vec2 iuv = floor( uv );\n    vec2 fuv = fract( uv );\n    \n    // * insert your interpolation primitive operation here *\n\tuv = iuv + fuv*fuv*(3.0f-2.0f*fuv); // smoothstep\n    //uv = iuv + fuv*fuv*fuv*(fuv*(fuv*6.0f-15.0f)+10.0f); // quintic\n    \n\treturn(uv - 0.5f);  // returns in same unit as input, voxels\n}\n\nconst float uv_scale = 8.0f;\nconst vec2 texsize = vec2(64.0);\nvec3 fetch_nn(vec2 uv) {\n    return texture(iChannel0, (vec2(uv + 0.5f)) / texsize).rgb;\n    // if no repeat required can also use:\n    //return texelFetch(iChannel0, ivec2(uv + 0.5f), 0).rgb;\n}\nvec3 fetch_iq(vec2 uv) {\n    return texture(iChannel0, rndC(uv) / texsize).rgb;\n    // needs hw interpolators (good gravy)\n}\n\nvec3 samplef(in vec2 in_uv) {\n    vec2 suv = (in_uv + iTime / uv_scale);\n    vec2 n = floor(suv);\n    vec2 f = fract(suv)*2.0-1.0;\n    \n    vec3 total = vec3(0.0);\n    float w = 0.0;\n    \n    vec2 uv;\n    for (uv.y = -1.0f; uv.y <= 1.0f; ++uv.y) {\n        for (uv.x = -1.0f; uv.x <= 1.0f; ++uv.x) {\n            float a;    \n            a = compute_area(f-uv*2.0);\n            total += fetch_nn(n + uv) * a;\n            w += a;\n        }\n    }\n    \n    return ((in_uv.x+in_uv.y-m*uv_scale) < 0.5)?fetch_iq(suv):(total/w);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    m =( iMouse.x / iResolution.x)*2.0-1.0;\n    \n\tfragColor = vec4(samplef(uv * uv_scale),1.0);\n}","name":"Image","description":"","type":"image"}]}