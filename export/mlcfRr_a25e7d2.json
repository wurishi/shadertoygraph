{"ver":"0.1","info":{"id":"mlcfRr","date":"1700865940","viewed":33,"name":"Ray Sphere Intersection Diagram","username":"chronos","description":"Diagram showing the length of the intersection of a ray with a circle/disc or equivalently a sphere/ball. This can be used for volume rendering. You the  length of the segment only depends on the radius and the distance between the ray and ball center.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","volume","sphere","intersection","circle","disc","diagram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Ray Sphere Intersection Diagram by chronos\n\n    This diagram shows how you can get the length of the line segment of\n    the intersection between a ray and a sphere (when the ray starts outside the sphere).\n    \n    All you need to know is the radius of the sphere and\n    the distance between the sphere center and the ray (i.e height).\n    \n    To see why, try to convince yourself that no matter the incoming angle and position of the ray,\n    you can always rotate the coordinate system such that it is oriented in the same way as this diagram,\n    where the orthogonal offset between the ray and sphere center points straight 'up' (this is arbitrary).\n    \n    Then, since the sphere is rotationally symmetric around this axis, it does not matter which way the ray enters,\n    the length will be the same.\n    \n    This can be used for e.g volumetric splatting.\n\n*/\n\nfloat char(vec2 uv, vec2 position, float size, int ascii_code)\n{\n    uv = (uv-position) / (size*percent);\n    ivec2 ij = ivec2(uv * 64.) + ascii_to_offset(ascii_code);\n    float mask = step(0., min(min(uv.x, 1.-uv.x), min(uv.y, 1.-uv.y)));\n    return texelFetch(iChannel0, ij, 0).r * mask;\n}\n\nfloat char_shadow(vec2 uv, vec2 position, float size, int ascii_code, float shadow_offset, float shadow_blur)\n{\n    uv = (uv-(position+vec2(shadow_offset,-shadow_offset))) / (size*percent);\n    ivec2 ij = ivec2(uv * 64.) + ascii_to_offset(ascii_code);\n    float mask = step(0., min(min(uv.x, 1.-uv.x), min(uv.y, 1.-uv.y)));\n    float d = texelFetch(iChannel0, ij, 0).a;\n    float f = smoothstep(0.5+shadow_blur,0.5-shadow_blur, d); \n    return f * mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv_text = uv;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    mat2 rot = mat2(1);\n    \n    // Enable this to make the ray direction rotate,\n    // and see that the same approach works regardless.\n    // Here, I just did this by rotating the entire uv coordinate system,\n    // except for the text which needs to be upright,\n    // but the result is equivalent.\n    #if 0\n    float t = iTime * 0.5;\n    float c = cos(t), s = sin(t);\n    rot = mat2(c,s,-s,c);\n    uv = rot * uv;\n    mouse = rot * mouse;\n    #endif\n\n    if(length(iMouse.xy) < 10.)\n        mouse = vec2(0., sin(iTime) * .8);\n \n    vec3 bg_color = vec3(0.2, 0.30, 0.5);\n    vec3 color = bg_color; //vec3(0);\n\n    // Used for aliasing / smoothing\n    float pix_size = 2./iResolution.y;\n    float rpix_size = 1./pix_size;\n    \n    float r = 0.75;     // circle radius\n    float h = mouse.y;  // height\n    \n    // we know y, which is equal to the height h, so we only need to find the two x values\n    // Use Pythagoras\n    float x = sqrt(r*r - h*h); // intersection points are plus/minus x\n    \n    float d, a; // distance & alpha\n    \n    // Optionally fill in the disc with the extinction factor\n    #if 1\n    if(length(uv) <= r)\n    {\n        float extinction_coeff = .075; // scale down to make a little less visually intrusive\n        \n        float ext = 1.-exp(- extinction_coeff * abs(2.*sqrt(r*r - uv.y*uv.y)));\n\n        d = length(uv);\n        a = ext * smoothstep(r+pix_size, r, d);\n        \n        // Dither, 'cause we don't like banding 'round these here parts\n        float dither_strength = 1./256.;\n        float dither = dither_strength*(texelFetch(iChannel1, ivec2(fragCoord) % textureSize(iChannel1, 0), 0).r - .5);\n        a = clamp(a + dither, 0., 1.);\n        \n        // Disable this toggle to more clearly show analytic volume integral\n        #if 1\n            color = mix(color, vec3(1), a); \n        #else\n            color = mix(color, vec3(a), 1.); \n        #endif\n    }\n    #endif\n    \n    // Draw circle\n    \n    d = length(uv)-r;\n    a = smoothstep(2., 1., abs(d)*rpix_size);\n    a *= .9;\n    color = mix(color, vec3(1,1,1), a);\n    \n    // Draw offset distance from center\n    d = uv.y - (h/2.);\n    a  = smoothstep(pix_size, 0., abs(d)-abs(h/2.)); // horizontal slab with thickness h from the origin\n    a *= smoothstep(1.5, 0.75, abs(uv.x)*rpix_size); // cut out a line thin vertical slice of the slab\n    color = mix(color, vec3(0, 1, 0), a);\n    \n    // Draw offset vertical line for x coordinate\n    d = uv.y - (h/2.);\n    a  = smoothstep(pix_size, 0., abs(d)-abs(h/2.));   // horizontal slab with thickness h from the origin\n    a *= smoothstep(1.5, 0.75, abs(uv.x-x)*rpix_size); // cut out a line thin vertical slice of the slab\n    a *= .25;\n    color = mix(color, vec3(1), a);\n    \n    // Draw offset vertical line for x coordinate\n    d = uv.x - (x/2.);\n    a  = smoothstep(pix_size, 0., abs(d)-abs(x/2.));   // vertical slab with thickness h from the origin\n    a *= smoothstep(1.5, 0.75, abs(uv.y)*rpix_size); // cut out a line thin vertical slice of the slab\n    a *= .25;\n    color = mix(color, vec3(1), a);\n    \n    // Draw circle center\n    d = length(uv);\n    a = smoothstep(point_radius+pix_size, point_radius, d);\n    color = mix(color, vec3(1), a);\n    \n    // Draw ray\n    d = uv.y - h;\n    a = smoothstep(1.5, 0.75, abs(d)*rpix_size);\n    a *= .5;\n    color = mix(color, vec3(1), a);\n    \n    // Draw intersection points\n        // Draw colored ray segment in interior\n        d = abs(uv.x)-x;\n        a = smoothstep(pix_size, 0., d); // vertical slab with thickness 2x centered on origin\n        a *= smoothstep(1.5, 0.75, abs(uv.y - h)*rpix_size);\n        color = mix(color, vec3(0,1,0), a);\n\n        // Draw first intersection\n        d = distance(uv, vec2(x, h));\n        a = smoothstep(point_radius+pix_size, point_radius, d);\n        color = mix(color, vec3(1), a);\n        \n        // Draw second intersection\n        d = distance(uv, vec2(-x, h));\n        a = smoothstep(point_radius+pix_size, point_radius, d);\n        color = mix(color, vec3(1), a);\n    ///////////\n\n    // Draw diagram annotations\n    \n    const float shadow_alpha = 40.*percent;\n    \n    vec2 X = vec2(x, 0);\n    float charX = char(uv_text, transpose(rot)*X, 10., ascii_X);\n    float charX_shadow = shadow_alpha*char_shadow(uv_text, transpose(rot)*X, 10., ascii_X, .3*percent, 5.*percent);\n    \n    vec2 Y = vec2(0, h);\n    float charY = char(uv_text, transpose(rot)*Y, 10., ascii_Y);\n    float charY_shadow = shadow_alpha*char_shadow(uv_text, transpose(rot)*Y, 10., ascii_Y, .3*percent, 5.*percent);\n    \n    color = mix(color, vec3(0), charX_shadow);\n    color = mix(color, vec3(1), charX);\n    \n    color = mix(color, vec3(0), charY_shadow);\n    color = mix(color, vec3(1), charY);\n    \n    color = sRGBencode(color);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\nconst float percent = .01;\nconst float line_width = 1. * percent;\nconst float point_radius = 2. * percent;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nivec2 ascii_to_index(int ascii_code)\n{\n    const int row_len = 16;\n    const int glyph_size = 64;\n    int y = ascii_code / 16;\n    int x = ascii_code - y * 16;\n    return ivec2(x,y+1);\n}\n\nivec2 index_to_offset(ivec2 index)\n{\n    return ivec2(index.x * 64, 1024 - index.y * 64);\n}\n\nivec2 ascii_to_offset(int ascii_code)\n{\n    return index_to_offset(ascii_to_index(ascii_code));\n}\n\n/*\nfloat character(vec2 uv, vec2 position, float size, int ascii_code, int text_index)\n{\n    //float pixel_size = 1. / iResolution.y;\n    const float percent = .01;\n    uv = (uv-position) / (size*percent) - vec2(text_index, 0)*.5;//(size * pixel_size);\n    ivec2 ij = ivec2(uv * 64.) + ascii_to_offset(ascii_code);\n    float mask = step(0., uv.x) * step(0., 1.-uv.x) * step(0., uv.y) * step(0., 1.-uv.y);\n    return texelFetch(iChannel0, ij, 0).r * mask;\n}\n*/\n\n\n/*\n    \n    \"ASCII\" CODE TABLES FOR character() FUNCTION\n\n*/\n#define ascii_arrow_left 16\n#define ascii_arrow_up 17\n#define ascii_arrow_right 18\n#define ascii_arrow_down 19\n\n#define ascii_arrow_left_right 20\n#define ascii_arrow_up_down 21\n#define ascii_arrow_up_left 22\n#define ascii_arrow_up_right 23\n#define ascii_arrow_down_right 24\n#define ascii_arrow_down_left 25\n#define ascii_arrow_counter_clockwise 26\n#define ascii_arrow_clockwise 27\n#define ascii_arrow_STAR 28\n#define ascii_arrow_smiley 29\n\n#define ascii_space 32\t\n#define ascii_exclam 33\t\n#define ascii_quotation 34\t\n#define ascii_hash 35\t\n#define ascii_dollar 36\t\n#define ascii_percent 37\t\n#define ascii_ampersand 38\t\n#define ascii_apostrophe 39\t\n#define ascii_lparen 40\t\n#define ascii_rparen 41\t\n#define ascii_star 42\t\n#define ascii_plus 43\t\n#define ascii_comma 44\t\n#define ascii_minus 45\t\n#define ascii_period 46\t\n#define ascii_slash 47\t\n#define ascii_0 48\t\n#define ascii_1 49\t\n#define ascii_2 50\t\n#define ascii_3 51\t\n#define ascii_4 52\t\n#define ascii_5 53\t\n#define ascii_6 54\t\n#define ascii_7 55\t\n#define ascii_8 56\t\n#define ascii_9 57\t\n#define ascii_colon 58\t\n#define ascii_semicolon 59\t\n#define ascii_lt 60\t\n#define ascii_equals 61\t\n#define ascii_gt 62\t\n#define ascii_questionmark 63\t\n#define ascii_at 64\t\n#define ascii_A 65\t\n#define ascii_B 66\t\n#define ascii_C 67\t\n#define ascii_D 68\t\n#define ascii_E 69\t\n#define ascii_F 70\t\n#define ascii_G 71\t\n#define ascii_H 72\t\n#define ascii_I 73\t\n#define ascii_J 74\t\n#define ascii_K 75\t\n#define ascii_L 76\t\n#define ascii_M 77\t\n#define ascii_N 78\t\n#define ascii_O 79\t\n#define ascii_P 80\t\n#define ascii_Q 81\t\n#define ascii_R 82\t\n#define ascii_S 83\t\n#define ascii_T 84\t\n#define ascii_U 85\t\n#define ascii_V 86\t\n#define ascii_W 87\t\n#define ascii_X 88\t\n#define ascii_Y 89\t\n#define ascii_Z 90\t\n#define ascii_lbracket 91\t\n#define ascii_backslash 92\t\n#define ascii_rbracket 93\t\n#define ascii_hat 94\t\n#define ascii_underscore 95\t\n#define ascii_accent 96\t\n#define ascii_a 97\t\n#define ascii_b 98\t\n#define ascii_c 99\t\n#define ascii_d 100\t\n#define ascii_e 101\t\n#define ascii_f 102\t\n#define ascii_g 103\t\n#define ascii_h 104\t\n#define ascii_i 105\t\n#define ascii_j 106\t\n#define ascii_k 107\t\n#define ascii_l 108\t\n#define ascii_m 109\t\n#define ascii_n 110\t\n#define ascii_o 111\t\n#define ascii_p 112\t\n#define ascii_q 113\t\n#define ascii_r 114\t\n#define ascii_s 115\t\n#define ascii_t 116\t\n#define ascii_u 117\t\n#define ascii_v 118\t\n#define ascii_w 119\t\n#define ascii_x 120\t\n#define ascii_y 121\t\n#define ascii_z 122\t\n#define ascii_lbrace 123\t\n#define ascii_pipe 124\t\n#define ascii_rbrace 125\t\n#define ascii_tilde 126\t\n\t\n#define ascii_blank2 127\n\n#define ascii_alpha   128\n#define ascii_beta    129\n#define ascii_gamma   130\n#define ascii_delta   131\n#define ascii_epsilon 132\n#define ascii_zeta    ascii_z\n#define ascii_eta     ascii_n\n#define ascii_theta   133\n#define ascii_iota    ascii_i\n#define ascii_kappa   ascii_k\n#define ascii_lambda  134\n#define ascii_mu      135\n#define ascii_nu      ascii_v\n#define ascii_xi      136\n#define ascii_omicron ascii_o\n#define ascii_pi      137\n#define ascii_rho     138\n#define ascii_sigma   139\n#define ascii_tau     140\n#define ascii_upsilon ascii_u\n#define ascii_phi     141\n#define ascii_chi     ascii_x\n#define ascii_psi     142\n#define ascii_omega   143\n\n#define ascii_ALPHA   ascii_A\n#define ascii_BETA    ascii_B\n#define ascii_GAMMA   144\n#define ascii_DELTA   145\n#define ascii_EPSILON ascii_E\n#define ascii_ZETA    ascii_Z\n#define ascii_ETA     ascii_H\n#define ascii_THETA   146\n#define ascii_IOTA    ascii_I\n#define ascii_KAPPA   ascii_K\n#define ascii_LAMBDA  147\n#define ascii_MU      ascii_M\n#define ascii_NU      ascii_N\n#define ascii_XI      ascii_X\n#define ascii_OMICRON ascii_O\n#define ascii_PI      148\n#define ascii_RHO     ascii_P\n#define ascii_SIGMA   149\n#define ascii_TAU     ascii_T\n#define ascii_UPSILON ascii_Y\n#define ascii_PHI     150\n#define ascii_CHI     ascii_X\n#define ascii_PSI     151\n#define ascii_OMEGA   152\n","name":"Common","description":"","type":"common"}]}