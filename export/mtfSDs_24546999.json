{"ver":"0.1","info":{"id":"mtfSDs","date":"1675477189","viewed":158,"name":"gt02","username":"ChunderFPV","description":"Sphere grid to fake 3d grid with points moving along the lines.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","grid","transform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define H(a) (sin(vec3(0,1.047,2.094)+vec3((a)*6.2832))*.5+.5)\n#define RT(a) mat2(cos(m.a*1.57+vec4(0,-1.57,1.57,0)))\n#define G(v) max( H(u.v+s), H(1./u.v+s) ) * gt(u.v)\n#define C(u,mt,pr) max(0., 1.-length((fract(u-vec2(mt, 0)+.5)-.5)/fwidth(u)/2.))\n#define MC(v1,v2,v3) C(u.v1, cs.v2, pr) * min(1., 1./abs(u.v3))*.6\n\nfloat gt(float x) // grid transform\n{\n    if (abs(x) < 1.) x = 1./x; // reciprocals\n    float l = max(0., 1.-(abs(fract(x+.5)-.5)/fwidth(x))), // lines\n          g = 1.-abs(sin(x*3.1416)), // glow\n          d = min(1., 1./abs(x)); // darken\n    return (l+g*.5+.2)*d;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    vec3  u, c, v, g, cs;\n    vec2  R = iResolution.xy,\n          m = (iMouse.xy/R*4.)-2.,\n          o;\n    float S = 7., // scale\n          p = 2., // aa pass\n          T = iTime,\n          t = T/5.,\n          tr = smoothstep(0., 1., sin(t)*.6+.5), // transform with time\n          s = sin(T)*.2; // oscillate hue with time\n    if (iMouse.z < 1.) m = vec2(sin(t/2.)*.4, sin(t)*.3); // rotate with time\n    for (int k = 0; k < int(p*p); k++) // aa loop\n    {\n        o = vec2(k%2, k/2)/p; // aa offset\n        u = normalize(vec3((XY-.5*R+o)/R.y, .5))*S; // 3d coords\n        u.yz *= RT(y), // pitch\n        u.xz *= RT(x); // yaw\n        \n        g = u*u;          // sqrt grid\n        u = abs(u/u.yzx); // quotient grid\n        u *= u; // make into sqrt grid (think inverse)\n        u = u*(1.-tr)+g*tr; // transform coords\n        v = G(x) + G(y) + G(z); // adding the quotient grids\n        \n        // moving cells\n        cs = (T/50.)*round(u); // cell speed\n        v += MC(xy, y, x)+\n             MC(yx, x, y)+\n             MC(zy, y, z)+\n             MC(yz, z, y)+\n             MC(xz, z, x)+\n             MC(zx, x, z);\n        \n        c += v;\n    }\n    c /= p*p;\n    RGBA = vec4(c*sqrt(c)*1.3, 1);\n}","name":"Image","description":"","type":"image"}]}