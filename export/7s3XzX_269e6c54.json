{"ver":"0.1","info":{"id":"7s3XzX","date":"1634220725","viewed":204,"name":"md stippling","username":"ax","description":"stippling via n-body sim (use higher res when you have more particles)\nChrome/iOS might have an iteration ceiling .... per node.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["particles","stippling","md"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// STEP 4. Visualization\n//\n// BufferA holds vec2(qLUT) \n// BufferB holds vec2(acc) [non integrated]\n// BufferC holds vec2(vel) and vec2(acc), phase-2\n// BufferD holds vec2(pos) latest positions\n//\n\n\n// Adapt to current Display size\n//\nvec2 coord(in vec2 xy, in vec2 u_resolution) {\n    // 1. Normalize\n    xy /= u_resolution.xy;\n    // correct aspect ratio\n    if (u_resolution.x > u_resolution.y) {\n        xy.x *= u_resolution.x / u_resolution.y;\n        xy.x += (u_resolution.y - u_resolution.x) / u_resolution.y / 2.0;\n    } else {\n        xy.y *= u_resolution.y / u_resolution.x;\n        xy.y += (u_resolution.x - u_resolution.y) / u_resolution.x / 2.0;\n    }\n    // 2. Centering\n    return (xy - 0.5);\n}\n\n//  1-pixel size in 'uv' space (0,1)\n#define rx 1.0 / min(iChannelResolution[2].x, iChannelResolution[2].y)\n\nfloat circle(in vec2 center, in float radius, in vec2 thisST) {\n    //  checks distance(via length) between current (s,t) and cxy.\n    float d = radius - (length(thisST - center));  // d is -ve if (s,t) not within circle.\n    return smoothstep(0.0, 2.0 * rx, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  if (iFrame <= 5) return;\n  \n  // Debug viz\n//  vec4 check = 0.01 * texture(iChannel1, fragCoord/iChannelResolution[0].xy);\n//  fragColor = vec4(check);\n//  return;\n\n\n  int ifx = int(fragCoord.x);\n  int ify = int(fragCoord.y);\n\n//  vec2 pos = texelFetch(iChannel3, ivec2(ifx,ify), 0).xy;\n//  vec4 lastVelAcc = texelFetch(iChannel2, ivec2(ifx,ify),0); \n//  vec2 vel = lastVelAcc.xy;\n//  vec2 acc = lastVelAcc.zw;\n\n  vec2 thisST = coord(fragCoord, iChannelResolution[2].xy);\n  \n  vec4 buf = vec4(vec3(1.),1.);\n  \n  for (int i = 0; i < u_numDots; i++) {\n\n    int x = i % u_workWidth;\n    int y = i / u_workWidth;\n    vec2 dotPos = 0.5 * texelFetch(iChannel3, ivec2(x,y), 0).xy;  \n  \n    vec4 color = vec4(0.,0.,0., 1.);\n    float c = circle(dotPos, dotSize, thisST);\n    buf = mix(buf, color, c);\n    \n  }\n\n  fragColor = vec4(buf);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// STEP 0. SUPER UGLY SERIAL Initialization\n//\n// BufferA holds vec2(qLUT) \n// BufferB holds vec2(acc) [non integrated]\n// BufferC holds vec2(vel) and vec2(acc), phase-2\n// BufferD holds vec2(pos) latest positions\n//\n\n// Brightness\n#define LUM(P) 0.2989*(P).r + 0.5870*(P).g + 0.1140*(P).b;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  float Epsilon = 0.0000001;  \n  int ifx = int(fragCoord.x);\n  int ify = int(fragCoord.y);\n\n\n  if (iFrame < 3) {   // Ugly 2-pass Charge Summation\n\n    // Reject\n    if (ifx > u_simXY || ify > u_simXY) {\n      fragColor = vec4(0.,0.,0., 0.);  \n      return;\n    }\n\n    // Pass-1 at iFrame == 1 (rowSum)\n    if (ifx == u_simXY && ify < u_simXY) {\n      float rowSum = 0.; \n      for (int x = 0; x < u_simXY; x++) {\n        vec2 uv = vec2(float(x)+0.5, fragCoord.y)/iChannelResolution[1].xy;\n        vec3 p = texture(iChannel0, uv).rgb;\n        rowSum += LUM(p);\n      }\n      fragColor = vec4(rowSum);\n      return;\n    }\n\n    // Pass-2 at iFrame == 2 (total)\n    if (ifx == u_simXY && ify == u_simXY) {\n      float graySum = 0.; \n      for (int y = 0; y < u_simXY; y++) {\n        vec2 uv = vec2(float(u_simXY)+0.5, float(y)+0.5)/iChannelResolution[1].xy;      \n        vec3 p = texture(iChannel0, uv).rgb;\n        graySum += LUM(p);\n      }\n      fragColor = vec4(graySum);\n      return;\n    }\n\n    // The REST just copy\n//    int    lod = int(log2( float(int(iChannelResolution[1].x)/u_simXY)) );\n//    vec4     p = texelFetch(iChannel1, ivec2(ifx,ify), lod);\n    \n    vec4     p = texture(iChannel1, (512./float(u_simXY)) * fragCoord/iChannelResolution[1].xy);\n\n    float gray = LUM(p);\n    fragColor  = vec4(vec3(gray), 1.0);\n      \n  } else if (iFrame == 3) { // Charge normalizatioon\n\n    vec2     gsUV = vec2(float(u_simXY)+0.5)/iChannelResolution[0].xy;      \n    float graySum = texture(iChannel0, gsUV).r;\n    \n    float bmpChargeTotal = (blankLevel * float(u_simXY*u_simXY)) - graySum;\n    float dotChargeTotal = float(u_numDots) * u_dotCharge;\n    float bmpCharge = dotChargeTotal / bmpChargeTotal;\n    \n    float gray = texture(iChannel0, fragCoord/iChannelResolution[0].xy).r;\n    fragColor = vec4( ((blankLevel - gray) * bmpCharge), 0., 0., 1. );\n\n  } else if (iFrame == 4) { // Build Charge LUT (phase-1)\n\n    // # of work tiles to share the workload\n    ivec2 numTile = ivec2(iChannelResolution[0])/ivec2(u_simXY);\n    \n    // Compute Reject\n    if ( ifx > (u_simXY * numTile.x) || ify > (u_simXY * numTile.y) ) {\n      fragColor = vec4(0.,0.,0., 0.);  \n      return;\n    }\n\n    // Job scheduling\n    // Each tile will take care of one band (divided in Y-direction)\n    ivec2 tileID = ivec2(ifx,ify)/u_simXY;    \n    int bandNum  = tileID.x + tileID.y * numTile.x;\n    int bandLoad = u_simXY / (numTile.x * numTile.y);  // Height of charge field to process for each Tile\n\n    // Remap ifx & ify to the first BASIC tile ifx,ify\n    ifx -= tileID.x * u_simXY;\n    ify -= tileID.y * u_simXY;\n    \n    // Force field LUT computation\n    int    simXY_2 = u_simXY / 2;\n    float _simXY_2 = 1./float(simXY_2);\n    vec2   _uv_res = 1./iChannelResolution[0].xy;\n\n    // Our sampling point: pos\n    vec2 pos  = (vec2(ifx,ify) - vec2(simXY_2)) * vec2(_simXY_2);\n    vec2 qLUT = vec2(0.);\n\n    // Workout load start and end\n    int start = bandNum * bandLoad;\n    int end   = start + bandLoad;\n\n    for (int fpy = start; fpy < end; fpy++) {  // seems iOS limit: 35 * u_simXY of a for loop\n    \n      int fpx = 0;\n      while (fpx < u_simXY) {\n       \n          // lookup the charge of the field particle\n          vec2 bmpUV = (vec2(fpx,fpy) + vec2(.5)) * _uv_res;      \n          float bmpQ = texture(iChannel0, bmpUV).r;\n\n          // physical location of the field particle\n          vec2 bmpXY = (vec2(fpx,fpy) - vec2(simXY_2)) * vec2(_simXY_2);\n\n          // Periodic boundary\n          vec2 dp = bmpXY - pos;\n\n          if (dp.x > 1.) dp.x -= 2.;\n          else if (dp.x < -1.) dp.x += 2.;\n          if (dp.y > 1.) dp.y -= 2.;\n          else if (dp.y < -1.) dp.y += 2.;      \n\n          float d2 = dot(dp, dp) + 0.00003;  // Super Sharp\n          float d  = sqrt(d2);\n\n          if (abs(d - 0.) > Epsilon) {\n            float q = bmpQ / d2;\n            qLUT += q * dp / d;\n          }\n          fpx++;\n      }\n    }\n     \n     // FINAL BufferA, iChannel0 layout: vec4( vec2(qLUT), 0., 0. )\n     // qLUT is to be sampled by the dot's current position in the field\n     fragColor = vec4(qLUT, 0., 0.);\n\n  } else if (iFrame == 5) { // Build Charge LUT (phase-2)\n\n    // # of work tiles to share the workload\n    ivec2 numTile = ivec2(iChannelResolution[0])/ivec2(u_simXY);\n    \n    // Compute Reject\n    if ( ifx > (u_simXY * numTile.x) || ify > (u_simXY * numTile.y) ) {\n      fragColor = vec4(0.,0.,0., 0.);  \n      return;\n    }\n\n    // Job scheduling\n    // Each tile will take care of one band (divided in Y-direction)\n    ivec2 tileID = ivec2(ifx,ify)/u_simXY;    \n\n    // Integrate the results from all the TILES\n    if ( tileID == ivec2(0) ) {\n\n      vec2     acc = vec2(0.);\n      ivec2 target = ivec2(0);\n      for (int y = 0; y < numTile.y; y++) {\n        target.y = ify + y * u_simXY;\n        for (int x = 0; x < numTile.x; x++) {\n          target.x = ifx + (x * u_simXY);\n          acc += texelFetch(iChannel0, target, 0).xy;\n        }\n      }\n      fragColor = vec4(acc, 0., 0.);    \n      \n    } else {\n    \n      fragColor = texelFetch(iChannel0, ivec2(ifx,ify), 0);\n    \n    }\n\n  } else { // Maintain Data state\n\n    // Compute Reject\n//    if ( ifx > u_simXY || ify > u_simXY ) {\n//      return;\n//    }\n    // Keep data ALIVE\n    fragColor = texelFetch(iChannel0, ivec2(ifx,ify), 0);\n      \n  }\n  \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\n// STEP 1. Acceleration and Velocity Update\n//\n// BufferA holds vec2(qLUT) \n// BufferB holds vec2(acc) [non integrated]\n// BufferC holds vec2(vel) and vec2(acc), phase-2\n// BufferD holds vec2(pos) latest positions\n//\n\n// STEP 1 specific\nconst float u_dt    = timeStep;\nconst float u_dt_2  = 0.5 * u_dt;\nconst float u_vMax  = u_dMax / timeStep;  \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  if (iFrame <= 5) return;\n\n  float Epsilon = 0.0000001;  \n  int ifx = int(fragCoord.x);\n  int ify = int(fragCoord.y);\n\n  // # of tiles to share the workload\n  int workHeight = u_numDots / u_workWidth;  \n  ivec2 numTile = ivec2(iChannelResolution[1])/ivec2(u_workWidth, workHeight);\n\n  // minimum workload = u_workWidth seems good choice\n  int workload = u_workWidth;\n  int workers = u_numDots / workload;\n  numTile.y = (workers / numTile.x);\n  if (workers % numTile.x > 0) numTile.y++;\n\n  // Compute Reject\n  if ( ifx > (u_workWidth * numTile.x) || ify > (workHeight * numTile.y) ) {\n    fragColor = vec4(0.,0.,0.,0.);  \n    return;\n  }\n\n  // Job scheduling\n  // Each tile will take care of one band\n  ivec2 tileID = ivec2(ifx,ify)/ivec2(u_workWidth, workHeight);    \n  int tileNum  = tileID.x + tileID.y * numTile.x;\n\n  // Remap ifx & ify to the first BASIC tile ifx,ify\n  ifx -= tileID.x * u_workWidth;\n  ify -= tileID.y * workHeight;\n\n  // Our particle's position ( Lookup from iChannel3 )\n  vec2 pos = texelFetch(iChannel3, ivec2(ifx,ify), 0).xy;\n  vec2 acc = vec2(0.);\n    \n  // Force between particles\n  //\n  int dotIndex = (ify * u_workWidth) + ifx;  // this dot's index\n  \n  int start = tileNum * workload;\n  int end   = start + workload;\n  if (end > u_numDots) end = u_numDots;\n\n  for (int i = start; i < end; i++) {\n\n    if (dotIndex == i) continue;  // skip oneself\n\n    int x = i % u_workWidth;\n    int y = i / u_workWidth;\n    vec2 dotPos = texelFetch(iChannel3, ivec2(x,y), 0).xy;  \n        \n    vec2 dp = dotPos - pos;\n\n    if (dp.x > 1.0) dp.x -= 2.0;\n    else if (dp.x < -1.0) dp.x += 2.0;\n    if (dp.y > 1.0) dp.y -= 2.0;\n    else if (dp.y < -1.0) dp.y += 2.0;\n\n    float d2 = dot(dp, dp) + 0.00003;\n    float d  = sqrt(d2);\n\n    if (abs(d - 0.0) > Epsilon) {\n      float q = u_dotCharge / d2;\n      acc -= q * dp / d;\n    }\n    \n  }   \n\n  fragColor = vec4(acc, 0., 0.);\n  \n/*\n  a1 *= u_dotCharge;\n\n  //\n  vec4 lastVelAcc = texelFetch(iChannel1, ivec2(ifx,ify),0); \n  vec2 v0 = lastVelAcc.xy;\n  vec2 a0 = lastVelAcc.zw;\n\n  vec2  vel = (u_sustain * v0) + (u_dt_2 * (a0 + a1));\n  float len = length(vel);\n  if (len > u_vMax) vel *= (u_vMax/len);\n  \n  fragColor = vec4(vel, a1);\n*/\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//\n// STEP 2. Acceleration Integration\n//\n// BufferA holds vec2(qLUT) \n// BufferB holds vec2(acc) [non integrated]\n// BufferC holds vec2(vel) and vec2(acc), phase-2\n// BufferD holds vec2(pos) latest positions\n//\n\n// STEP 2 specific\nconst float u_dt    = timeStep;\nconst float u_dt_2  = 0.5 * u_dt;\nconst float u_vMax  = u_dMax / timeStep; \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  if (iFrame < 5) return;\n\n  float Epsilon = 0.0000001;  \n  int ifx = int(fragCoord.x);\n  int ify = int(fragCoord.y);\n\n  // # of tiles to share the workload\n  int workHeight = u_numDots / u_workWidth;\n  ivec2 numTile = ivec2(iChannelResolution[1])/ivec2(u_workWidth, workHeight);\n\n/*\n  // Verify if workload too light -> over-comm\n  int workload = u_numDots / (numTile.x * numTile.y);\n  if (workload < u_minWork) {\n    workload = u_minWork;\n    int workers = u_numDots / u_minWork;\n    numTile.y = (workers / numTile.x);\n    if (workers % numTile.x > 0) numTile.y++;\n  }\n*/\n\n  int workload = u_workWidth;\n  int workers = u_numDots / workload;\n  numTile.y = (workers / numTile.x);\n  if (workers % numTile.x > 0) numTile.y++;\n\n\n  // Compute Reject\n  if ( ifx > u_workWidth || ify > workHeight ) {\n    fragColor = vec4(0.,0.,0.,0.);  \n    return;\n  }\n\n  // Initialize vel & acc in Buffer-C\n  if (iFrame == 5) {  \n    fragColor = vec4(0.);\n    return;\n  }\n\n  // RECURRENT computation starts here\n  \n  // Job scheduling\n  ivec2 tileID = ivec2(ifx,ify)/ivec2(u_workWidth, workHeight);    \n  vec2 a1 = vec2(0.);\n\n  // Integrate the intermediate results by (iChannel1, Buffer B)\n  ivec2 target = ivec2(0);\n  for (int y = 0; y < numTile.y; y++) {\n    target.y = ify + y * workHeight;\n    for (int x = 0; x < numTile.x; x++) {\n      target.x = ifx + (x * u_workWidth);\n      a1 += texelFetch(iChannel1, target, 0).xy;\n    }\n  }\n\n  // Our particle's position (iChannel3, BufferD)\n  vec2 pos = texelFetch(iChannel3, ivec2(ifx,ify), 0).xy;\n  \n  // Force from field via LUT (iChannel0, BUfferA)\n  vec2 qLutUV = 0.5 * (pos + 1.);\n  qLutUV *= vec2(float(u_simXY))/iChannelResolution[0].xy;\n  a1     += texture(iChannel0, qLutUV).xy;\n  \n  // FINAL charge computed\n  a1 *= u_dotCharge;\n\n  // Velocity Verlet step\n  vec4 lastVelAcc = texelFetch(iChannel2, ivec2(ifx,ify), 0); \n  vec2 v0 = lastVelAcc.xy;\n  vec2 a0 = lastVelAcc.zw;\n\n  vec2  vel = (u_sustain * v0) + (u_dt_2 * (a0 + a1));\n  float len = length(vel);\n  if (len > u_vMax) vel *= (u_vMax/len);\n  \n  fragColor = vec4(vel, a1);\n\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//\n// Simulation settings\n//\n\n// Electrostatic field (image) resolution (square shaped)\n// Warning: on iOS, lower this number if image field has no effect.\n//\nconst int   u_simXY      = 200;\n\n// # of particles and per-particle charge\nconst int   u_numDots    = 8192;   // Multiple of 'u_workWidth'\nconst float u_dotCharge  = 0.25;\n\n// Inter-particle SIM job scheduling parameters\nconst int   u_workWidth  = 256;   // workgroup's width (Must < iChannelRes.x)\n\n// Blank threshold\nconst float blankLevel   = 0.7;\n\n// STEP 1 & 2 shared\nconst float u_sustain    = 0.9;\nconst float u_dMax       = 0.005;\nconst float timeStep     = 0.001;\n\n// Visualization\nconst float dotSize      = 0.006;\n\n\n// Hash used for initial particle position initialization\n//\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//\n// STEP 3. Position Update\n//\n// BufferA holds vec2(qLUT) \n// BufferB holds vec2(acc) [non integrated]\n// BufferC holds vec2(vel) and vec2(acc), phase-2\n// BufferD holds vec2(pos) latest positions\n//\n\n// STEP 3 specific\nconst float u_dt    = timeStep;\nconst float u_dtt   = u_dt * u_dt;\nconst float u_dt_2  = 0.5 * u_dt;     // timestep Halved\nconst float u_vMax  = u_dMax / u_dt; \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  if (iFrame < 5) return;\n\n  float Epsilon = 0.0000001;  \n  int ifx = int(fragCoord.x);\n  int ify = int(fragCoord.y);\n\n  int workHeight = u_numDots / u_workWidth;\n\n  // Reject\n  if (ifx > u_workWidth || ify > workHeight) {\n    fragColor = vec4(0.,0.,1.,1.);\n    return;\n  }\n\n  // Initialize positions in Buffer-D\n  if (iFrame == 5) {  \n    vec2 dotPos = 2. * (hash22(vec2(ifx,ify)) - vec2(0.5));  \n    fragColor = vec4(dotPos, 0., 0.);\n    return;\n  }\n \n  // RECURRENT computation starts here\n  //\n  // Particle pos from iChannel3, BufferD\n  vec2 pos    = texelFetch(iChannel3, ivec2(ifx,ify), 0).xy;\n  // Particle vel & acc from iChannel2, BufferC\n  vec4 velAcc = texelFetch(iChannel2, ivec2(ifx,ify),0);\n  \n  vec2 vel = velAcc.xy;\n  vec2 acc = velAcc.zw;\n  \n  vec2 dp = (vel * u_dt) + (0.5f * acc * u_dtt);\n  \n  float len = length(dp);\n  if (len > u_dMax) dp *= (u_dMax/len);\n\n  //  Make periodic\n  pos += dp;   \n  if (pos.x < -1.0) pos.x += 2.0;\n  else if (pos.x > 1.0) pos.x -= 2.0;\n  if (pos.y < -1.0) pos.y += 2.0;\n  else if (pos.y > 1.0) pos.y -= 2.0;\n  \n  fragColor = vec4(pos, 0., 0.);  \n\n}\n","name":"Buffer D","description":"","type":"buffer"}]}