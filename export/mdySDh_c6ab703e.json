{"ver":"0.1","info":{"id":"mdySDh","date":"1681041414","viewed":129,"name":"Directed Photon Mapping V4","username":"gcgac","description":"The latest Directed Photon Mapping algorithm (Stochastic Directed Photon Mapping), this time with multiple bounces and DOF. It pathtraces, calculating radiance using my algorithm, DPM. The GI is extreme for example's sake. Reposted with a new feature.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["gi","global","illumination","mapping","tracing","tracer","estimation","event","photon","next"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0,uv);\n    vec3 c = data.xyz/data.w;\n    fragColor = vec4(vec3(c),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Thanks to Inigo Quilez for the PRNG and normal function\n//@spinningcube has been helpful, thanks!\n// the reflections have some bugs, but the final version will be released soon.\n\n\nint seed = 3;\nfloat arpeture_size = 2.0;\nfloat check_radius = 5.0;\nfloat bri = 0.7;\nfloat gamma = 2.2;\nfloat refl = 0.5;\nvec3 rgb;\nint frand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat rand(void) { return float(frand())/32767.0; }\nvec3 point;\nvec3 lightpos;\nfloat hash1( uint n ) {\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nfloat sde;\nvec3 pos;\nfloat maxl = 10000.0;\n\n\nfloat plane_sde(vec3 ray, vec3 nor, float planey, vec3 col, float ref){\n    if (dot(ray,nor)+planey < sde){\n        sde = dot(ray,nor)+planey;\n        rgb = col;\n        refl = ref;\n    }\n    return dot(ray,nor)+planey;\n}\n\n\nfloat sphere_sde(vec3 ray, vec3 position, float radius, vec3 col, float ref){\n    if (length(position-ray)-radius < sde){\n        sde = length(position-ray)-radius;\n        rgb = col;\n        refl = ref;\n    }\n    return length(position-ray)-radius;\n}\n\n \nfloat calc_sdf(vec3 ray){\n    sde = maxl;\n    plane_sde(ray,vec3(0,1,0),10.0,vec3(bri,bri,bri),1.0);\n    //plane_sde(ray,vec3(0,-1,0),100.0,vec3(1,1,1));\n    //plane_sde(ray,vec3(1,0,0),40.0,vec3(0,1,0));\n    //plane_sde(ray,vec3(-1,0,0),40.0,vec3(1,0,0));\n    sphere_sde(ray,vec3 (-20.0,0.0,80.0),5.0, vec3(bri,0,0),0.0);\n    sphere_sde(ray,vec3 (-10.0,-5.0,80.0),5.0, vec3(bri,bri,bri),1.0);\n    sphere_sde(ray,vec3 (10.0,2.0,80.0),10.0, vec3(0,bri,bri),0.0);\n    sphere_sde(ray,vec3 (-20.0,-5.0,50.0),5.0, vec3(0,bri,0),0.0);\n    return sde;\n}\n\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(calc_sdf(p+h.xyy) - calc_sdf(p-h.xyy),\n                           calc_sdf(p+h.yxy) - calc_sdf(p-h.yxy),\n                           calc_sdf(p+h.yyx) - calc_sdf(p-h.yyx) ) );\n}\n\n\nvec4 raycol(vec3 orig, vec3 dir, float ml){\n    float len = 0.0;\n    sde = ml;\n    float steps = 0.0;\n    pos = orig;\n\n    while (len < ml && sde > 0.01){\n        sde = calc_sdf(pos);\n        pos += dir*sde;\n        len += sde;\n        steps += 1.0;\n    }\n    return vec4(pos,steps);\n}\n\n\nvec3 sphrand(){\n    point = vec3(2.0);\n    while(length(point)>=1.0){\n        point = vec3(rand()*2.0-1.0,rand()*2.0-1.0,rand()*2.0-1.0);\n    }\n    return point;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 newfrag = vec2(fragCoord.x+iResolution.x/2.0,fragCoord.y+iResolution.y/2.0); \n    uvec2 p = uvec2((newfrag-.5*iResolution.xy)/iResolution.y*1000.0);\n    seed = int(round(hash1( p.x + 1920U*p.y + (1920U*1080U))*100.0*float(iFrame)));\n    vec2 th = fragCoord/iResolution.xy;\n    vec3 colour = vec3(0);\n    for (int i = 0; i<1; i++){\n        vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y+sphrand().xy/iResolution.xy;\n        vec3 pos = vec3(sphrand().x*arpeture_size,sphrand().y*arpeture_size,-1.0);\n        vec3 direction = normalize(normalize(vec3(uv.x,uv.y,1.0))*80.0-pos);\n        vec4 o;\n        float steps;\n        vec3 newdir = direction;\n        o = raycol(pos,direction,500.0);\n        if (sde <= 0.01){\n            sde = 0.01;\n            vec3 tcol = vec3(1.0);\n            float bounces = 0.0;\n            //newdir = calcNormal(o.xyz);\n            while (sde<=0.01 && bounces<3.0){\n                steps =o.w;\n                vec3 pre = rgb;\n                float pref = refl;\n                vec3 inter = o.xyz+calcNormal(o.xyz)/10.0;\n                for (int i = 0; i<10; i++){\n                    vec3 offset = sphrand();\n                    offset *= 200.0;\n                    lightpos = vec3(-60,200.0,-100.0)+offset;\n                    offset = sphrand();\n                    offset *= check_radius;\n                    vec3 hit = raycol(lightpos,normalize(o.xyz+offset-lightpos),length(o.xyz+offset-lightpos)).xyz;\n                    if (length(hit-o.xyz)<check_radius){\n                        pre += rgb;//*dot(calcNormal(hit),normalize(lightpos-hit))*dot(n,calcNormal(hit))*(1.0-length(hit-inter)/check_radius);\n                    }\n                }\n                if (pref<rand()){\n                    newdir = sphrand();\n                    if (dot(newdir,calcNormal(o.xyz))<0.0){\n                        newdir *= -1.0;\n                    }\n                } else{\n                    vec3 normal = calcNormal(o.xyz);\n                    newdir = newdir-2.0*dot(newdir,normal)*normal;\n                }\n                pre /= 10.0;\n                tcol *= pre;\n                o = raycol(inter,normalize(newdir),500.0);\n                bounces += 1.0;\n            }\n            colour += tcol;\n        } else{\n            colour += 0.7;\n        }\n    }\n    colour /= 1.0;                \n    vec4 data = texture(iChannel0,th);\n    data += vec4(pow(colour,vec3(1.0/gamma)),1);\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}