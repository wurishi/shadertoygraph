{"ver":"0.1","info":{"id":"wlX3D8","date":"1556334882","viewed":203,"name":"581 Final Proj Part2","username":"zheng516","description":"581 final part2","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["581finalpart2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Joseph Klinger - University of Pennsylvania\n// https://github.com/klingerj\n// https://www.linkedin.com/in/josephklinger/\n// Inspired by: https://www.shadertoy.com/view/MsSGD1\n// Idea also inspired from this course taught by Rachel Hwang at UPenn: https://cis700-procedural-graphics.github.io/\n\n// Raymarching params\n#define T_MAX 50.0\n\n// Colors\n#define GRAPHITE_COLOR vec3(0.3)\n#define RED_LINE_COLOR vec3(1.0, 0.41, 0.73)\n#define BLUE_LINE_COLOR vec3(0.58, 0.83, 0.95)\n#define PAPER_COLOR vec3(0.8, 0.8, 0.73)\n\n#define SHADOWS\n#define LIGHT_VEC normalize(vec3(0.0, 0.8, -1.0))\n\n// 3D Noise by IQ\nfloat Noise3D( in vec3 pos )\n{\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv + 0.5) / 256.0, 0.0).yx;\n    return -1.0 + 2.0 * mix( rg.x, rg.y, f.z );\n}\n\nfloat ComputeFBM( in vec3 pos )\n{\n    float amplitude = 0.25;\n    float sum = 0.0;\n    sum += Noise3D(pos) * amplitude;\n    return clamp(sum, 0.0, 1.0);\n}\n\n// Credit to IQ: https://iquilezles.org/articles/distfunctions\n\n\nfloat SDF_Box( in vec3 pos, in vec3 b )\n{\n     return length(max(abs(pos) - b, 0.0));\n}\n\n\n// tea pot and cup==================================\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n\tfloat h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\treturn mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat cupSDF(vec3 p) {\t\n    float dst = 0.0;\n\tfloat d1 = sdRoundedCylinder(-p, 0.12, 0.1, 0.1);\n   \tfloat d2 = sdCappedCylinder(vec3(0.,0.2,0.)-p, vec2(.1,.35));\n    dst = opSmoothSubtraction(d2, d1, 0.2);    \n    return dst;   \n}\n\n//Bezier curve utility func=====================\nfloat U(in vec2 a, in vec2 b){\n  return (a.x*b.y-b.x*a.y);\n}\n\n\nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n//Tea pot distance func=============================================\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nvoid potAssgn(){\n\t //pot=====\n    // Teapot body profil (8 quadratic curves) \n    A[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n    //=========\n}\n\nfloat potSDF(vec3 p) {\n\n// Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .7); \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.0);\n\n    return dTeapot;\n}\n\n\n// Cheap, pseudorandom number generator taken from: https://www.shadertoy.com/view/MscSzf\n/*\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}*/\n\n\nfloat rand( float p )\n{\n    p = dot(p,1271311.7);// dot(p,vec2(269.5,183.3)) ;\n\treturn fract(sin(p)*43758.5453);\n}\n\n\nfloat SceneMap( in vec3 pos )\n{\n   \n\tfloat sdf = potSDF(pos- vec3 (0.0, 0.0, 0.0));\n    sdf = min(sdf, cupSDF(pos- vec3(0.8, 0.2, -1.0)));\n   \tsdf = min(sdf, SDF_Box(pos - vec3(0.0, 0.0, 0.0), vec3(4.0, 0.02, 4.0) * 0.5));\n \n    return sdf;\n}\n\nvec3 ComputeNormal( in vec3 pos )\n{\n    vec2 epsilon = vec2(0.0, 0.001);\n    return normalize( vec3( SceneMap(pos + epsilon.yxx) - SceneMap(pos - epsilon.yxx),\n                            SceneMap(pos + epsilon.xyx) - SceneMap(pos - epsilon.xyx),\n                            SceneMap(pos + epsilon.xxy) - SceneMap(pos - epsilon.xxy)));\n}\n\nvec3 RaymarchScene( in vec3 origin, in vec3 dir )\n{\n    float distance, lastDistance = 10000000.0;\n    const float EDGE_THRESHOLD = 0.015;\n    float dt = 0.01;\n    float t = 0.01;\n    float hitSomething, isOnEdge = 0.0;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        distance = SceneMap(origin + t * dir);\n        \n        // If we get very close to an object and we also moved away since the last iteration\n        if (distance < EDGE_THRESHOLD && distance > lastDistance + 0.00001)\n        {//edge detection\n            hitSomething = 1.0;\n            isOnEdge = 1.0;\n            break;\n        }\n        \n        if(distance < 0.001)\n        {\n            hitSomething = 1.0;\n            break;\n        }\n        else if (t > T_MAX)\n        {\n            break;\n        }\n        \n        t += distance;\n        lastDistance = distance;\n    }\n    return vec3(t, hitSomething, isOnEdge);\n}\n\nvec3 GetBackgroundColor( in vec2 coord )\n{\n    // Blue notebook paper lines\n    vec3 col = PAPER_COLOR;\n    \n    \n    //bool isOnRedLine = false;\n    /*\n    if (coord.x <= 86.5 && coord.x >= 85.0) // red notebook paper line\n    {\n        col *= RED_LINE_COLOR;\n        isOnRedLine = true;\n    }*/\n   /* \n    if (mod(coord.y, 20.0) <= 1.0 && mod(coord.y, 20.0) >= -1.0)\n    {\n        col *= BLUE_LINE_COLOR;\n        if (isOnRedLine) // mix the red and blue ink if the lines intersect\n        {\n            col *= RED_LINE_COLOR;\n        }\n        \n    }*/\n    \n    \n    // Accounting for the mottling in paper\n    float mottling = ComputeFBM(vec3(coord, 1.0) * 1.0);\n    //float mottling = 0.0;\n    return mix(col, vec3(0.0, 0.0, 0.0), pow(mottling, 0.8));\n}\n\nvec3 GetHatchingColor( in vec2 coord, in float lightIntensity, in vec3 camRight, in vec3 camUp, in bool isGradientEnabled, in float doOffsetHatching )\n{    \n    vec3 hatchingColor = GetBackgroundColor(coord);\n    \n    // Make the hatching look more consistent at full resolution\n    coord = coord / iResolution.xy * 1024.0;\n    \n    // Just catch a flag saying we want to jitter the hatching-\n    // For example, make the outline or shadow hatching look\n    // noncontinuous with any nearby dark hatching\n    coord += vec2(75.0, 15.0) * doOffsetHatching;\n    \n    float lineWidth, lineFreq, hatching;\n    \n    float thresh1 = 0.5;\n    float thresh0 = thresh1 + 0.075;\n    float thresh2 = thresh1 - 0.1;\n    float thresh3 = 0.2;\n    float thresh4 = thresh3 - 0.1;\n    \n    // This code could probably be a lot less verbose but oh well\n    \n    // Threshold 1\n    lineWidth = 0.015 * (0.5 * sin((coord.x - 0.25 * coord.y) * 0.04167 + 0.15 * (coord.x + coord.y)) + 0.5) + 1.0;\n    lineFreq = 10.0;\n    hatching = mod(coord.x + coord.y * 0.15 * (sin(abs(coord.y + coord.x) * 0.00390625 * 0.75)), lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh1)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh0)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh0 - lightIntensity) / (thresh0 - thresh1);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }\n    }\n    \n    \n    // Threshold 2\n    lineWidth = 1.0 * (0.5 * sin((coord.x + 0.75 * coord.y) * 0.0625 + 0.15 * (coord.x - 0.5 * coord.y)) + 0.5) + 1.0;\n    lineFreq = 14.0;\n    hatching = mod(coord.x + coord.y, lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh2)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t   hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh1)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh1 - lightIntensity) / (thresh1 - thresh2);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }\n    }\n    \n    // Threshold 3\n    lineWidth = 1.0 * (0.5 * sin((coord.x + 1.0 * coord.y) * 0.03125 + 0.15 * (coord.x - 1.5 * coord.y)) + 0.5) + 1.5;\n    lineFreq = 8.0;\n    hatching = mod(coord.x - 0.75 * coord.y, lineFreq) + 2.0 * (rand(coord.x + 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh3)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh2)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh2 - lightIntensity) / (thresh2 - thresh3);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }        \n    }\n    \n    \n    // Threshold 4\n    lineWidth = 1.25;\n    lineFreq = 7.0;\n    hatching = mod(coord.x + 0.15 * coord.y, lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh4)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh3)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh3 - lightIntensity) / (thresh3 - thresh4);\n       \t       weight = pow(weight, 2.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }  \n    }\n    return hatchingColor;\n    \n}\n\n// Credit to IQ: https://iquilezles.org/articles/rmshadows\nfloat SoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.05;\n    while(t <= 10.0)\n    {\n        float h = SceneMap(ro + rd * t);\n        if (h < 0.001)\n        {\n            return 0.0;\n        }\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\n// \"Plasma\": Compute ray jitter using \"plasma\": http://lodev.org/cgtutor/plasma.html\nfloat Plasma( in vec2 sp, in float timeStutter )\n{    \n    float plasma = 0.5 * sin(sp.x * 8.0 + timeStutter) + 0.5;\n    plasma *=  sin((sp.x + sp.y) * 8.0 + timeStutter) + 0.5;\n    plasma *= 0.5 * sin(length(sp) * 15.0 + timeStutter) + 0.5;\n    return plasma;\n}\n\nvec3 CastRay( in vec2 sp, in vec3 origin, out vec3 camRight, out vec3 camUp ) // need the camRight vector in the hatching color function\n{\n    // Compute local camera vectors\n    vec3 refPoint = vec3(0.0, 0.4, 0.0);\n    vec3 camLook = normalize(refPoint - origin);\n    camRight = normalize(cross(camLook, vec3(0.0, 1.0, 0.0)));\n    camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = refPoint + sp.x * camRight + sp.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    potAssgn();\n    \n    vec2 screenPoint = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Compute ray direction\n    float radius = 4.0;\n    float speed = 0.015625;\n    \n    // camera \n    vec3 rayOrigin = vec3(cos(iMouse.x * speed) * radius, -5.0 * ((iMouse.y / iResolution.y) - 0.8), sin(iMouse.x * speed) * radius);\n    vec3 camRight, camUp;\n    vec3 rayDirection = CastRay(screenPoint, rayOrigin, camRight, camUp);\n    \n    // Compute ray jitter using fake noise stuff using sin() - see the Plasma() function\n    float timeStutter = floor(iTime * 12.0) * 16.0;\n    timeStutter = mod(timeStutter, 2048.0); // the plasma function broke when iTime reached high values, mod every 2^24\n    \n    const bool isGradientEnabled = true;\n    \n    // Compute a direction to offset the .xy component of each ray via a gradient\n    vec2 fragSize = 1.0 / iResolution.xy;\n    vec2 offsetDir = normalize(vec2(cos(cos(iTime * 2.0)), sin(cos(iTime * 2.0)))) * 0.75;\n    rayDirection.xy += max(Plasma(screenPoint, timeStutter), 0.05) * offsetDir * 0.00390625; // that's 1 / 256\n    \n    vec3 result = RaymarchScene(rayOrigin, rayDirection);\n    \n    if (result.y > 0.0)\n    {\n        vec3 isectPoint = rayOrigin + result.x * rayDirection;\n        vec3 normal = ComputeNormal(isectPoint);\n        float lightIntensity = clamp(dot(normal, LIGHT_VEC), 0.0, 1.0);\n        \n        vec3 col;\n        \n        // Compute shadows\n        float shadowing = 1.0;\n        #ifdef SHADOWS\n            shadowing= SoftShadow(isectPoint, LIGHT_VEC, 7.0);\n        #endif\n        \n        // Shade depending on whether or not we are on an outline\n       \n        col = mix(GetHatchingColor(fragCoord.xy, min(shadowing, lightIntensity), camRight, camUp, isGradientEnabled, 0.0),\n                  GetHatchingColor(fragCoord.xy, 0.0, camRight, camUp, isGradientEnabled, 0.0),\n                  result.z);\n        \n        \n       // col = GetHatchingColor(fragCoord.xy, min(shadowing, lightIntensity), camRight, camUp, isGradientEnabled, 0.0);\n        //col = GetHatchingColor(fragCoord.xy, 0.0, camRight, camUp, isGradientEnabled, 0.0);\n                        \n        fragColor = vec4(col, 1.0);\n    }\n    else // we miss geometry completely\n    {\n        fragColor = vec4(GetBackgroundColor(fragCoord.xy), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}