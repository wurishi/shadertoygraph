{"ver":"0.1","info":{"id":"fsccRX","date":"1653853468","viewed":165,"name":"Maxwell 2D Plane wave","username":"Amirk","description":"The plane wave is created with \"Total field-Scattered field\" method/trick which manipulates the curls to create a one directional plane wave. \n","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["refraction","maxwell","electrodynamics"],"hasliked":0,"parentid":"sd3yzB","parentname":"Maxwell 2D "},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col=vec3(0);\n\n    float EZ = texture(iChannel0,uv).r*3.;\n    float HX= 0.;// texture(iChannel0,uv).g*40.;\n    float HY= 0.; //texture(iChannel0,uv).b*40.;\n    \n    float energy=0.5*(er*EZ*EZ+(HX*HX+HY*HY)/ur); //energy in the field\n    \n    float d=length(fragCoord.xy-iResolution.xy*0.5);\n    er+= smoothstep(iResolution.y/4.+s,iResolution.y/4.,d);\n    ur+= smoothstep(iResolution.y/4.+s,iResolution.y/4.,d);\n\n     col= color(1.51*EZ)/(er*0.5);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//this Buffer updates magnetic field H with curls of E with buffer B\n\n\nivec2 per(int px, int py){\n  ivec2 r = ivec2(textureSize(iChannel0, 0));\n  ivec2 p=ivec2(px,py);\n  \n  return p = (p+r) % r; \n}\n\n    //We store Ez as col.r and Hx,Hy as col.g, col.b\n\nfloat Ez(int i, int j){\n    //if(per(i,j).y==0) return 0.;\n\n\n    return texelFetch(iChannel0, per(i,j),0).r;\n}\nfloat Hx(int i, int j){\n    //if(per(i,j).y==0) return 0.;\n\n\n    return texelFetch(iChannel0, per(i,j),0).g;\n}\nfloat Hy(int i, int j){\n   // if(per(i,j).y==0) return 0.;\n\n\n    return texelFetch(iChannel0, per(i,j),0).b;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec3 col = vec3(0);\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n    \n    float EZ,HX,HY;\n    t=dt*float(iFrame);\n\n\n    \n    //define smooth obstacle:\n    float d=length(fragCoord.xy-iResolution.xy*0.5);\n    er+= (erObs-er)*smoothstep(iResolution.y/4.+s,iResolution.y/4.,d);\n    ur+= (urObs-ur)*smoothstep(iResolution.y/4.+s,iResolution.y/4.,d);\n\n    \n    EZ=Ez(i,j);\n  \n    float ExCurl=  (Ez(i,j+1)-Ez(i,j))/dz;\n    float EyCurl= -(Ez(i+1,j)-Ez(i,j))/dz;\n\n    //\"Totalfield-Scatteredfield method:\n    //input source plane wave by modifying the curl:\n    if(i==sourceLoc-1) EyCurl += Esource(t)/dz; \n    \n    //update H:\n    HX=Hx(i,j) + mH*( ExCurl );\n    HY=Hy(i,j) + mH*( EyCurl );\n    \n    \n    //store fields in color channels:\n    col.rgb=vec3(EZ,HX,HY);\n    \n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":" //speed of light c:\n #define c  1. \n //grid cell size:\n #define dz 0.1\n //relative permittivity:\n float er = 1.0;\n //relative permeability:\n float ur = 1.0;\n //timestep is chosen so that one grid cell is traversed in excatly two time steps. \n //First time step is to update H, the second to update E.\n #define dt dz/(2.0*c)\n //some precalculations:\n #define mE c*dt/(er)\n #define mH -c*dt/(ur)\n  \n #define sourceLoc int(iResolution.x/4.)\n \n //smoothing factor of the obstacle boundary:\n float s=50.;\n float erObs=1.;\n float urObs=3.;\n\n \n float t;\n\n\n//a gaussian pulse at x, y:\nfloat Esource(float time){ \n        return .1*exp(-(time-dt*100.0)*(time-dt*100.0)*.4);\n    \n}\n\nfloat Hsource(float time){ \n       //there is this phase shift in H wave, since H field \"lives time dt/2 ahead\" of E field.\n       float phase =dz/(2.*c)+dt/2.;\n       float amp=-1.; //-sqrt(er/ur);\n        \n       return .1*amp*exp(-(time-dt*100.0+phase)*(time-dt*100.0+phase)*.4); \n}\n\nvec3 color(float t)\n{\n vec3 col;\n col.r = 0.5-0.5*cos(2.*3.1416*(1.5*t+1.9));\n col.g = 0.5-0.5*cos(2.*3.1416*(.9*t+.15));\n col.b = 0.5-0.5*cos(2.*3.1416*(1.7*t+.2));\n return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this Buffer updates electric field E with curls of H using buffer A\n\n\n//periodic boundary:\n ivec2 per(int px, int py){\n  ivec2 r = ivec2(textureSize(iChannel0, 0));\n  ivec2 p=ivec2(px,py);\n  \n  return p = (p+r) % r; \n}\n\n\n    //We store Ez as col.r and Hx,Hy as col.g, col.b\n\nfloat Ez(int i, int j){\n    \n    //if(per(i,j).y==0) return 0.;\n \n    return texelFetch(iChannel0, per(i,j),0).r;\n}\n\nfloat Hx(int i, int j){\n    //if(per(i,j).y==0) return 0.;\n\n    return texelFetch(iChannel0, per(i,j),0).g;\n}\n\nfloat Hy(int i, int j){\n   // if(per(i,j).y==0) return 0.;\n\n    return texelFetch(iChannel0, per(i,j),0).b;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = vec3(0);\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n    \n    t=dt*float(iFrame);\n    \n    float EZ,HX,HY;\n    \n    //define smooth obstacle:\n    \n    float d=length(fragCoord.xy-iResolution.xy*0.5);\n    er+= (erObs-er)*smoothstep(iResolution.y/4.+s,iResolution.y/4.,d);\n    ur+= (urObs-ur)*smoothstep(iResolution.y/4.+s,iResolution.y/4.,d);\n   \n    \n    float HCurl= ((Hy(i,j)-Hy(i-1,j))-(Hx(i,j)-Hx(i,j-1)))/dz;\n    \n    //\"Totalfield-Scatteredfield method:\n    //input source plane wave by modifying the curl:\n    if(i==sourceLoc) HCurl -= Hsource(t)/dz; \n    \n    //update E:\n    EZ=Ez(i, j)+ mE* (HCurl);\n    \n   /* //add point sources:\n    EZ+=source(t, ivec2(iResolution.xy/4.), i,j);\n    \n    if(iMouse.z>0.){\n        EZ+=source(dt*50., ivec2(iMouse.xy), i, j);\n    }\n    */\n    \n    HX=Hx(i,j);\n    HY=Hy(i,j);\n    \n    //store fields in color channels:\n    col.rgb=vec3(EZ,HX,HY);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}