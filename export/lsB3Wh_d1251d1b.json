{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"float ss(float x, float a,float p){\n\treturn a*pow(0.5+0.5*sin(x),p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uvmod = vec2(0.03-ss(iTime*3.0+3.14159,0.03,0.3),0.0);\n\tfragColor = vec4(texture(iChannel0,uv-uvmod).r,\n                     texture(iChannel0,uv).g,\n                     texture(iChannel0,uv+uvmod).b,\n                     1.0);\n\t\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat ss(float x, float a){\n\treturn a*(0.5+0.5*sin(x));\n}\n\nfloat ss(float x, float a,float p){\n\treturn a*pow(0.5+0.5*sin(x),p);\n}\n\nfloat distfunc(vec3 pos)\n{\n\tvec3 npos = pos;\n    float s1 = sphere(npos, 1.5\n\t\t\t\t\t  +ss(pos.y*3.0+iTime*10.0,0.05)\n\t\t\t\t\t  +ss(pos.x*3.0+iTime*10.0,0.1)\n\t\t\t\t\t );\n\t\n\t// movement amplitude for all blobs\n\t// same formula as camera shake (should make them global I guess)\n\tfloat amp = ss(iTime*3.0,2.0);\n\t\n\t\n\t// Note that the x coords are all pushed towards the cam (by pow'ing the sin on x)\n\t// No point twiddling blobs where we can't see them\n\tnpos = pos-amp*vec3(pow(sin(iTime*1.7),2.0),cos(iTime*3.0),sin(iTime));\n\tfloat s2 = sphere(npos, 0.2+ss(iTime*0.45,0.6));\n\t\n\tnpos = pos-amp*vec3(pow(sin(iTime*-1.3),2.0),cos(iTime*0.3)*0.7,sin(iTime*1.1));\n\tfloat s3 = sphere(npos, 0.2+ss(iTime*1.945,0.6));\n\t\n\tnpos = pos-amp*vec3(pow(sin(iTime*0.3),2.0),cos(iTime*-1.9),sin(iTime*0.7));\n\tfloat s4 = sphere(npos, 0.2+ss(iTime*2.3,0.6));\n\t\n\tfloat smoother = 8.0;\n\t//mix the blobby\n\treturn smin(smin(smin(s1,s2,smoother),s3,smoother),s4,smoother);\n}\n\nvec3 render(vec2 screenPos){\n\tvec3 upDirection = vec3(0.0, 1.0, 0.0);  // global up\n\t\n\tvec3 cameraOrigin = vec3(5.0, 0.0, 0.0); // where cam is\n\tvec3 cameraTarget = vec3(0.0, 0.0, 0.0); // where it's pointing\n\tvec3 cameraDir = normalize(cameraTarget - cameraOrigin); // camera is pointing this way\n\tvec3 cameraRight = normalize(cross(upDirection, cameraOrigin)); // right is htis way\n\tvec3 cameraUp = cross(cameraDir, cameraRight); // up is that way\n\t\n\t// hey look over there\n\tvec3 camWobble = pow(ss(iTime*3.0,1.0),1.1)*0.01*vec3(sin(iTime*30.0),sin(iTime*11.0),sin(iTime*37.0));\n\tvec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir+camWobble);\n\t\n\t\n\tconst int MAX_ITER = 200; // max jumps\n\tconst float MAX_DIST = 20.0; // ain't nothing out here, give up\n\tconst float EPSILON = 0.001; // basically there\n\t\n\tfloat totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = EPSILON;\n\t\n\tfor (int i = 0; i < MAX_ITER; i++)\n\t{\n\t\t// Either we've hit the object or hit nothing at all, either way we should break out of the loop\n\t\tif (dist < EPSILON || totalDist > MAX_DIST)\n\t\t\tcontinue; // If you use windows and the shader isn't working properly, change this to continue;\n\t\n\t\tdist = distfunc(pos); // Evalulate the distance at the current point\n\t\ttotalDist += dist;\n\t\tpos += dist * rayDir; // Advance the point forwards in the ray direction by the distance\n\t}\n\t\n\tvec3 c = texture(iChannel0,-rayDir).rgb;;\n\t\n\tif (dist < EPSILON)\n\t{\n\t\tvec2 eps = vec2(0.0, EPSILON);\n\t\tvec3 normal = normalize(vec3(\n\t\t\tdistfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n\t\t\tdistfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n\t\t\tdistfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n\t\t\n\t\tvec3 lightDir = normalize(vec3(2.0,-1.0,-.5));\n\t\t\n\t\tfloat diffuse = max(0.0, dot(lightDir, normal));\n\t\tfloat specular = 0.1+pow(diffuse, 32.0);\n\t\tfloat edging = pow(length(normal*vec3(0.0,1.0,1.0)),4.0); // I really should redo this to move with the camera...\n\t\t;\n\t\tc =\n\t\t\t0.5*specular\n\t\t\t+0.7*diffuse*vec3(0.1,1.0,0.1)\n\t\t\t+0.7*edging*vec3(0.5,1.0,0.5)*diffuse\n\t\t\t;\n\t\tc = mix(c,texture(iChannel0,reflect(-rayDir,normal)).rgb,c.r); // mix by r because it mostly comes from the specular\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; // screenPos can range from -1 to 1\n\tscreenPos.y /= iResolution.x / iResolution.y; // Correct aspect ratio\n\t\n\tvec3 c = render(screenPos);\n\n\t\n\tfragColor = vec4(c,1.0);\n\t\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lsB3Wh","date":"1386863730","viewed":904,"name":"blobatron - multipass","username":"squeakyneb","description":"First raymarchy thing (the concept finally clicked in my head today!). Based on tutorial code by /u/xpansive and smin() from iq's site. Sort of based on the classic Xbox boot animation. I plan to work on this one more.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","cubemap"],"hasliked":0,"parentid":"","parentname":""}}