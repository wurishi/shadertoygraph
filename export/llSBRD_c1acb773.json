{"ver":"0.1","info":{"id":"llSBRD","date":"1514879945","viewed":906,"name":"Soulstone pt1","username":"mmerchante","description":"Currently building a soulstone, but thought this crystal looks nice enough :)","likes":44,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment these defines to switch implementation\n\n// BASIC CURVATURE: We only add the curvature to the sdf when evaluating the normal\n#define NORMAL_CURVATURE_BASIC\n\n// How vertical/horizontal the crystal is :)\n#define CRYSTAL_SCALE 1.0\n#define CRYSTAL_VERTICAL_ANISOTROPY 1.3\n\n// ---------------------------------------------------------\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define MAX_STEPS 50\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define FIXED_STEP_SIZE .05\n\n#define MAX_DISTANCE 15.0\n#define MIN_DISTANCE .5\n#define EPSILON .01\n#define EPSILON_NORMAL .1\n\n#define MATERIAL_NONE -1\n#define MATERIAL_CRYSTAL 1\n\n// ---------------------------------------------------------\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n} \n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// hg\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// hg\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\n// iq\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return saturate(a + b * cos(6.28318 * (c * t + d)));\n}\n\n// iq\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// iq\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\n// iq\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\n// iq\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.yz)-t.x,p.x);\n  return length8(q)-t.y;\n}\n\n// iq\nvec2 opU(vec2 d1, vec2 d2 )\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\n// iq\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\n// iq\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\n// iq\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n// iq\nmat3x3 rotationAxisAngle( const vec3 v, float a )\n{\n    float si = sin( a );\n    float co = cos( a );\n    float ic = 1.0f - co;\n\n    return mat3x3( v.x*v.x*ic + co,       v.y*v.x*ic - si*v.z,    v.z*v.x*ic + si*v.y,\n                   v.x*v.y*ic + si*v.z,   v.y*v.y*ic + co,        v.z*v.y*ic - si*v.x,\n                   v.x*v.z*ic - si*v.y,   v.y*v.z*ic + si*v.x,    v.z*v.z*ic + co );\n}\n\n// iq\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat longTailImpulse(float k, float x, float c)\n{\n    return mix(impulse(k, x), impulse(k, (x+1.0/k) * c), step(1.0/k, x));\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random(inout uint seed)\n{\n\tseed = hash(seed);\n\treturn floatConstruct(seed);\n}\n\nfloat hash31(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n// ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n    \n// ---------------------------------------------------------\n\nfloat density(vec3 p)\n{\n    vec3 p0 = p;\n    vec3 pp = p + mod(iTime, 2.0) * .35;\n    p *= .3;\n    float res = 0.0;\n    \n    // credit to guil for this hybrid fractal:\n    // https://www.shadertoy.com/view/MtX3Ws\n    // Anything can work here, the idea is to warp the fracture cuts\n\tfor (int i = 0; i < 4; ++i) \n    {\n        p = .7 * abs(p) / dot(p,p) - .95;\n        p.yz = csqr(p.yz);\n        p = p.zxy;\n\t}    \n   \n    p = pp + p * .5;\n    \n    float d = 0.0;\n\tuint seed = uint(14041956 + int(iTime * .5));\n    \n    // The fractal warping now distorts the planar cuts in meaningful ways ;)\n\tfor(int i = 0; i < 6; ++i)\n\t{\n        // Folding\n\t\tp.yxz = clamp(p, -1.0, 1.0) * 2.0 - p;\n        \n        vec3 axis = normalize(vec3(random(seed), random(seed) * 2.0, random(seed)) * 2.0 - vec3(1.0));\n        vec3 offset = vec3(0.0, random(seed) * 2.0 - 1.0, 0.0);\n\t\t\n        float proj = dot(p - offset, axis);\n\t\td += smoothstep(.1, .0, abs(proj));\n\t}\n    \n    d = d * .5 + saturate(1.0 - length(p0 * (1.0 + sin(iTime * 2.0) * .5))) * (.75 + d * .25);\n    \n\treturn d * d + .05;\n}\n\nfloat sdf_simple(vec3 p)\n{\n    float d = 0.0;\n\tuint seed = uint(14041956 + int(iTime * .5));\n    \n    float sides = 6.0;\n    float sideAmpl = PI * 2.0 / sides;\n    \n    // Side planes\n\tfor(float i = 0.0; i < sides; i++)\n\t{\n        float angle = mix(i, i+1.0, random(seed)) * sideAmpl;\n        float verticalOffset = 0.0; //random(seed) * 2.0 - 1.0;\n        vec3 offset = vec3(cos(angle), verticalOffset * .25, sin(angle));\n        vec3 axis = normalize(offset);\n        offset = offset * CRYSTAL_SCALE / CRYSTAL_VERTICAL_ANISOTROPY;\n\t\t\n\t\td = max(d, dot(p - offset, axis));\n\t}\n\n    vec3 offset = vec3(0.0, 2.0, 0.0);\n    \n    // Cap planes\n\tfor(float i = 0.0; i < sides; i++)\n\t{\n        float angle = mix(i, i+1.0, random(seed)) * sideAmpl;\n        vec3 axis = normalize(vec3(cos(angle), .5 + random(seed), sin(angle)));\n\t\t\n        // UP\n\t\td = max(d, dot(p - offset * CRYSTAL_SCALE * CRYSTAL_VERTICAL_ANISOTROPY, axis));\n        \n        // DOWN\n        d = max(d, dot(p + offset * CRYSTAL_SCALE * CRYSTAL_VERTICAL_ANISOTROPY, -axis));\n\t}\n        \n\treturn d;\n}\n\nfloat curv_modifier(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;   \n    \n    float t1 = sdf_simple(p + e.yxx), t2 = sdf_simple(p + e.xxy);\n    float t3 = sdf_simple(p + e.xyx), t4 = sdf_simple(p + e.yyy);\n    \n    return (.25/e.y) * (t1 + t2 + t3 + t4 - 4.0 * sdf_simple(p));\n}\n\nfloat sdf_modifier(vec3 p)\n{\n    return 0.0;// -curv_modifier(p, .15) * .1;\n}\n\nfloat sdf_complex(vec3 p)\n{\n    return sdf_simple(p) + sdf_modifier(p);\n}\n\n// https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;\n    \n    float t1 = sdf_simple(p + e.yxx), t2 = sdf_simple(p + e.xxy);\n    float t3 = sdf_simple(p + e.xyx), t4 = sdf_simple(p + e.yyy);\n    \n    return .25/e.y*(t1 + t2 + t3 + t4 - 4.0 * sdf_simple(p));\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf_complex(p + eps.xzz) - sdf_complex(p + eps.yzz);\n\tfloat dY = sdf_complex(p + eps.zxz) - sdf_complex(p + eps.zyz);\n\tfloat dZ = sdf_complex(p + eps.zzx) - sdf_complex(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nint SampleMaterial(vec3 p)\n{\n    // We only have one material\n    return MATERIAL_CRYSTAL;\n}\n\nCamera GetCamera(vec2 uv, float zoom)\n{\n    float dist = 3.0 / zoom;\n    float time = iTime;\n    \n    vec3 target = vec3(0.0, sin(iTime * 2.0) * .25, 0.0);\n    vec3 p = vec3(0.0, 1.5, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward + left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\nIntersection Raymarch(Camera camera)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.materialID = MATERIAL_NONE;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; ++j)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf_simple(p) * .9;\n        //outData.density += sdfDensity(p);\n        \n\t\toutData.totalDistance += outData.sdf;\n        \n\t\tif(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n    \n    \n    // INNER MEDIUM\n    if(outData.sdf < EPSILON)\n    {\n        float t = FIXED_STEP_SIZE;\n        float d = 0.0;\n        \n        vec3 hitPosition = camera.origin + camera.direction * (outData.totalDistance + FIXED_STEP_SIZE);\n        \n        vec3 normal = sdfNormal(hitPosition, 1.0);\n        vec3 refr = refract(camera.direction, normal, .9);\n        \n        for(int i = 0; i < 50; ++i)\n        {            \n            vec3 p = hitPosition + refr * t;\n            \n            if(sdf_simple(p) > EPSILON)\n                break;\n            \n            d += density(p);            \n            t += FIXED_STEP_SIZE;\n        }\n        \n        outData.density = d;\n\t\toutData.materialID = SampleMaterial(camera.origin + camera.direction * outData.totalDistance);\n    \toutData.totalDistance *= .99;\n        outData.mediumDistance = t;\n    }\n    \n    return outData;\n}\n\nvec3 gradient(float factor)\n{\n\tvec3 a = vec3(0.478, 0.4500, 0.500);\n\tvec3 b = vec3(0.500);\n\tvec3 c = vec3(0.1688, 0.748, 0.1748);\n\tvec3 d = vec3(0.1318, 0.388, 0.1908);\n\n\treturn palette(factor, a, b, c, d);\n}\n\nvec3 triplanar(vec3 P, vec3 N)\n{   \n    vec3 Nb = abs(N);\n    \n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\n    \n    vec3 c0 = texture(iChannel1, P.xy).rgb * Nb.z;\n    vec3 c1 = texture(iChannel1, P.yz).rgb * Nb.x;\n    vec3 c2 = texture(iChannel1, P.xz).rgb * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\nvec3 Render(Camera camera, Intersection isect, vec2 uv)\n{\n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n    if(isect.materialID > 0)\n    {        \n        vec3 lPos = camera.origin - camera.left * 2.0 + camera.up * 2.0;\n        vec3 normal = sdfNormal(p, EPSILON_NORMAL);\n        vec3 toLight = normalize(lPos - p);\n        \n        vec3 tx = triplanar(p * .85 - p.zzz * .3, normal);\n        float c = curv(p, .1 + tx.r * .85);        \n        normal = normalize(normal - vec3(c * .3) + (tx * .25 - .125));\n        \n        float rim = pow(smoothstep(0.0, 1.0, 1.0 - dot(normal, -camera.direction)), 7.0);\n        vec3 H = normalize(toLight - camera.direction);        \n        float specular = pow(max(0.0, dot(H, normal)), tx.r * 5.0 + c * 25.0);        \n        \n        vec3 R = reflect(camera.direction, normal);\n        vec3 refl = texture(iChannel0, R).rgb ;\n                \n        vec3 glow = mix(vec3(1.0, .15, .15), vec3(1.0, .45, .15), (isect.density) * .05) * (isect.density) * .04;        \n        glow *= smoothstep(.5, 1.0, c) * 1.5 + 1.0;\n        \n        // Fake transmission\n        glow *= 1.0 + pow(exp(-isect.mediumDistance), 2.0) * 4.0;\n        \n        return (refl + specular) * vec3(.15, .1, .1) * rim + rim * c * .15 * vec3(.1, .4, .8) + glow;\n    }\n    \n    float vignette = 1.0 - pow(length(uv + hash31(p) * .2) / 2., 2.0);\n    return vec3(.15, .025, .1) * vignette * vignette * .25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n        \n    Camera camera = GetCamera(uv, .5);\n    Intersection isect = Raymarch(camera);    \n    vec3 color = Render(camera, isect, uv);\n        \n    uv.y += sin(iTime * 2.0) * .1; // synced to cam position, super fake\n \tvec3 glowColor = vec3(1.0, .7, .15);\n    uv *= .7;\n    vec3 fx = glowColor * pow(saturate(1.0 - length(uv * vec2(.75, .9))), 2.0);\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.5, 1.0))), 2.0);\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.25, 7.0))), 2.0) * .25;\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.1, 7.0))), 2.0) * .15;\n    \n    float intensity = pow(texture(iChannel1, vec2(iTime * .03)).r, 2.0);\n    color += fx * fx * fx * intensity * .2;\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}