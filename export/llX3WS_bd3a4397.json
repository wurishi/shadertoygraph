{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n#define CIRCLE_NUMBER 3\n#define SAMPLE_PER_CIRCLE 8\n#define PI 3.141592\n\nfloat blurThickness = 1.0;\n\nfloat borderThickness = 0.5;\nfloat colorMargin = 10.0;\n\nvec3 keyColorRGB = vec3(13.0 / 254.0, 162.0 / 254.0, 38.0 / 254.0);\n\nfloat scaleFloat(float value, float min, float max)\n{\n    return (clamp((value - min) / (max - min), 0.0, 1.0));\n}\n\n\nvec3 rgbToLab(vec3 color)\n{\n    vec3 linearRGB;\n    // convert sRGB (R,G,B) to linear-rgb (r,g,b)\n    linearRGB.r = (color.r <= 0.04045) ? color.r / 12.92 : pow((color.r + 0.055) / 1.055, 2.4);\n\tlinearRGB.g = (color.g <= 0.04045) ? color.g / 12.92 : pow((color.g + 0.055) / 1.055, 2.4);\n\tlinearRGB.b = (color.b <= 0.04045) ? color.b / 12.92 : pow((color.b + 0.055) / 1.055, 2.4);\n \n    vec3 converted;\n\t// convert to XYZ (assuming sRGB was D65)\n\tconverted.x =  linearRGB.r * 0.4124564 + linearRGB.g * 0.3575761 + linearRGB.b * 0.1804375;\n\tconverted.y =  linearRGB.r * 0.2126729 + linearRGB.g * 0.7151522 + linearRGB.b * 0.0721750;\n\tconverted.z =  linearRGB.r * 0.0193339 + linearRGB.g * 0.1191920 + linearRGB.b * 0.9503041;\n \n\t// Rescale X/Y/Z relative to white point D65\n\tfloat Xr = 0.95047, Yr = 1.0, Zr = 1.08883;\n    vec3 relative;\n\trelative.x = converted.x / Xr;\n\trelative.y = converted.y / Yr;\n\trelative.z = converted.z / Zr;\n \n\t// tristimulus function\n\tfloat eps = 216.0 / 24389.0, k = 24389.0 / 27.0;\n    vec3 tristimulus;\n\ttristimulus.x = (relative.x <= eps) ? (k * relative.x + 16.0)/ 116.0 : pow(relative.x, 1.0 / 3.0);\n\ttristimulus.y = (relative.y <= eps) ? (k * relative.y + 16.0)/ 116.0 : pow(relative.y, 1.0 / 3.0);\n\ttristimulus.z = (relative.z <= eps) ? (k * relative.z + 16.0)/ 116.0 : pow(relative.z, 1.0 / 3.0);\n \n\t// tranform to LAB\n    vec3 lab;\n\tlab.x = (116.0 * tristimulus.y) - 16.0;\n\tlab.y = 500.0 * (tristimulus.x - tristimulus.y);\n\tlab.z = 200.0 * (tristimulus.y - tristimulus.z);\n    return (lab);\n}\n\nfloat deltaE2000(vec3 color1, vec3 color2)\n{\n\tfloat Lstd = color1.x;\n\tfloat astd = color1.y;\n\tfloat bstd = color1.z;\n\n\tfloat Lsample = color2.x;\n\tfloat asample = color2.y;\n\tfloat bsample = color2.z;\n\n\tfloat _kL = 1.0;\n\tfloat _kC = 1.0;\n\tfloat _kH = 1.0;\n\n\tfloat Cabstd = sqrt(astd*astd+bstd*bstd);\n\tfloat Cabsample = sqrt(asample*asample+bsample*bsample);\n\n\tfloat Cabarithmean= (Cabstd + Cabsample)/2.0;\n\n\tfloat G= 0.5*( 1.0 - sqrt( pow(Cabarithmean,7.0)/(pow(Cabarithmean,7.0) + pow(25.0,7.0))));\n\n\tfloat apstd= (1.0+G)*astd; // aprime in paper\n\tfloat apsample= (1.0+G)*asample; // aprime in paper\n\tfloat Cpsample= sqrt(apsample*apsample+bsample*bsample);\n\n\tfloat Cpstd = sqrt(apstd*apstd+bstd*bstd);\n\t// Compute product of chromas\n\tfloat Cpprod = (Cpsample*Cpstd);\n\n\n\t// Ensure hue is between 0 and 2pi\n\tfloat hpstd = atan(bstd,apstd);\n\tif (hpstd < 0.0)\n        hpstd += 2.0 * PI;  // rollover ones that come -ve\n\n\tfloat hpsample = atan(bsample, apsample);\n\tif (hpsample < 0.0)\n        hpsample += 2.0 * PI;\n\tif ((abs(apsample) + abs(bsample)) == 0.0)\n        hpsample= 0.0;\n\n\tfloat dL= (Lsample-Lstd);\n\tfloat dC= (Cpsample-Cpstd);\n\n\t// Computation of hue difference\n\tfloat dhp= (hpsample-hpstd);\n\tif (dhp > PI)  dhp -= 2.0 * PI;\n\tif (dhp < -PI) dhp += 2.0 * PI;\n\t// set chroma difference to zero if the product of chromas is zero\n\tif (Cpprod == 0.0)\n        dhp= 0.0;\n\n\t// Note that the defining equations actually need\n\t// signed Hue and chroma differences which is different\n\t// from prior color difference formulae\n\n\tfloat dH = 2.0 * sqrt(Cpprod) * sin(dhp / 2.0);\n\t//%dH2 = 4*Cpprod.*(sin(dhp/2)).^2;\n\n\t// weighting functions\n\tfloat Lp= (Lsample+Lstd)/2.0;\n\tfloat Cp= (Cpstd+Cpsample)/2.0;\n\n\t// Average Hue Computation\n\t// This is equivalent to that in the paper but simpler programmatically.\n\t// Note average hue is computed in radians and converted to degrees only\n\t// where needed\n\tfloat hp= (hpstd+hpsample)/2.0;\n\t// Identify positions for which abs hue diff exceeds 180 degrees\n\tif (abs(hpstd-hpsample)  > PI )\n        hp -= PI;\n\t// rollover ones that come -ve\n\tif (hp < 0.0)\n        hp += 2.0 * PI;\n\n\t// Check if one of the chroma values is zero, in which case set\n\t// mean hue to the sum which is equivalent to other value\n\tif (Cpprod==0.0)\n        hp = hpsample + hpstd;\n\n\tfloat Lpm502= (Lp-50.0)*(Lp-50.0);;\n\tfloat Sl= 1.0+0.015*Lpm502/sqrt(20.0+Lpm502);\n\tfloat Sc= 1.0+0.045*Cp;\n\tfloat T= 1.0 - 0.17*cos(hp - PI/6.0) + 0.24*cos(2.0*hp) + 0.32*cos(3.0*hp+PI/30.0) - 0.20*cos(4.0*hp-63.0*PI/180.0);\n\tfloat Sh= 1.0 + 0.015*Cp*T;\n\tfloat delthetarad= (30.0*PI/180.0)*exp(- pow(( (180.0/PI*hp-275.0)/25.0),2.0));\n\tfloat Rc=  2.0*sqrt(pow(Cp,7.0)/(pow(Cp,7.0) + pow(25.0,7.0)));\n\tfloat RT= -sin(2.0*delthetarad)*Rc;\n\n\t// The CIE 00 color difference\n\treturn (sqrt( pow((dL/Sl),2.0) + pow((dC/Sc),2.0) + pow((dH/Sh),2.0) + RT*(dC/Sc)*(dH/Sh)));\n}\n\nbool passTest(vec3 color)\n{\n    vec3 keyColor = rgbToLab(keyColorRGB);\n    float error = deltaE2000(rgbToLab(color), keyColor);\n    return (error < colorMargin);\n}\n\nvec3 circleSampleColor(vec2 dist1, vec2 center1, vec2 dist2, vec2 center2)\n{\n    vec2 curRadius1 = vec2(0.0);\n    vec2 curRadius2 = vec2(0.0);\n\tvec3 returnValue = vec3(0.0);\n    \n    for (int c = 0; c < CIRCLE_NUMBER; ++c)\n    {\n    \tfloat normalizedAngle = 0.0;\n        curRadius1 += dist1;\n        curRadius2 += dist2;\n        for (int s = 0; s < SAMPLE_PER_CIRCLE; ++s)\n        {\n            float angle = normalizedAngle * 3.1415 * 2.0;\n            vec2 uvToSample1 = center1 + vec2(cos(angle), sin(angle)) * curRadius1;\n            vec2 uvToSample2 = center2 + vec2(cos(angle), sin(angle)) * curRadius2;\n            vec3 sampledColor1 = texture(iChannel0, uvToSample1).rgb;\n            vec3 sampledColor2 = texture(iChannel1, uvToSample2).rgb;\n            if (passTest(sampledColor1))\n\t\t\t\treturnValue += sampledColor2 / float(CIRCLE_NUMBER * SAMPLE_PER_CIRCLE);\n            else\n                returnValue += sampledColor1 / float(CIRCLE_NUMBER * SAMPLE_PER_CIRCLE);\n            normalizedAngle += 1.0 / float(SAMPLE_PER_CIRCLE);\n        }\n    }\n    return (returnValue);\n}\n\nfloat circleSample(vec2 dist, vec2 center)\n{\n    vec2 curRadius = vec2(0.0);\n\tfloat returnValue = 0.0;\n    \n    for (int c = 0; c < CIRCLE_NUMBER; ++c)\n    {\n    \tfloat normalizedAngle = 0.0;\n        curRadius += dist;\n        for (int s = 0; s < SAMPLE_PER_CIRCLE; ++s)\n        {\n            float angle = normalizedAngle * 3.1415 * 2.0;\n            vec2 uvToSample = center + vec2(cos(angle), sin(angle)) * curRadius;\n            vec3 sampledColor = texture(iChannel0, uvToSample).rgb;\n            if (passTest(sampledColor) == false)\n                returnValue += 1.0 / float(CIRCLE_NUMBER * SAMPLE_PER_CIRCLE);\n            normalizedAngle += 1.0 / float(SAMPLE_PER_CIRCLE);\n        }\n    }\n    return (returnValue);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 flipUv = vec2(uv.x, 1.0 - uv.y);\n    vec4 colorVideo = texture(iChannel0, uv);\n    vec4 colorBack = texture(iChannel1, flipUv);\n    \n    float blendRatio;\n    float colorRatio = 1.0;\n\tfloat blurRatio = 1.0;\n\n    if (passTest(colorVideo.rgb))\n    {\n\t\tblendRatio = 0.0;\n    }\n    else\n    {\n        float passRate = circleSample(vec2(borderThickness) / iChannelResolution[0].xy, uv);\n\t\tcolorRatio = scaleFloat(passRate, 0.4, 1.0);\n        blurRatio = scaleFloat(passRate, 0.5, 1.0);\n\t\tblendRatio = blurRatio;\n    }\n    \n    vec3 blurred = circleSampleColor(vec2(blurThickness) / iChannelResolution[0].xy, uv, \n                           \t\t\tvec2(blurThickness) / iChannelResolution[1].xy, flipUv);\n \tvec3 noBlurFinalColor = mix(colorBack.rgb, colorVideo.rgb, blendRatio);\n    vec3 finalColor = mix(blurred, noBlurFinalColor, blurRatio);\n    vec3 finalGrey = vec3(0.2126 * finalColor.r + 0.7152 * finalColor.g + 0.0722 * finalColor.b) * 0.8;\n    vec3 pixelColor = mix(finalGrey, finalColor, colorRatio);    \n    fragColor = vec4(pixelColor, 1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llX3WS","date":"1424707019","viewed":512,"name":"Color keying","username":"paulbaron","description":"Remove the green background from videos (color correction on borders and blur)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["basiccolorkeyingusingciede2000colordifference"],"hasliked":0,"parentid":"","parentname":""}}