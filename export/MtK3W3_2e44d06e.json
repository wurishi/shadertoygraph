{"ver":"0.1","info":{"id":"MtK3W3","date":"1477252399","viewed":297,"name":"circle inversion fractal","username":"jz","description":"crude way of making some circle inversion fractals I saw on numberphile\n\nI know there are if statements and whatnot and I'm sure the rest can also be optimized ","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["fractal","circle","inversion","reallyunoptimized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define L_SIDE_POS 150.0\n#define S_SIDE_POS 42.4\n#define L_SQR 22500.0\n#define S_SQR 900.0\n\nvec3 getInverse(vec2 p) {\n    float theta = iTime;\n    mat2 sideRotation = mat2(\n        cos(theta), -sin(theta),\n        sin(theta), cos(theta)\n    );\n    mat2 innerRotation = mat2(\n        cos(-theta), -sin(-theta),\n        sin(-theta), cos(-theta)\n    );\n    \n    float sq_radii[8];\n    sq_radii[0] = S_SQR;\n    sq_radii[1] = L_SQR;\n    sq_radii[2] = L_SQR;\n    sq_radii[3] = L_SQR;\n    sq_radii[4] = L_SQR;\n    sq_radii[5] = S_SQR;\n    sq_radii[6] = S_SQR;\n    sq_radii[7] = S_SQR;\n\n    vec2 centers[8];\n    centers[0] = innerRotation*vec2(S_SIDE_POS, 0.0);\n    centers[1] = sideRotation*vec2(-L_SIDE_POS,  L_SIDE_POS);\n    centers[2] = sideRotation*vec2( L_SIDE_POS,  L_SIDE_POS);\n    centers[3] = sideRotation*vec2(-L_SIDE_POS, -L_SIDE_POS);\n    centers[4] = sideRotation*vec2( L_SIDE_POS, -L_SIDE_POS);\n    centers[5] = innerRotation*vec2(-S_SIDE_POS, 0.0);\n    centers[6] = innerRotation*vec2(0.0,  S_SIDE_POS);\n    centers[7] = innerRotation*vec2(0.0, -S_SIDE_POS);\n    \n    float inside = 0.0;\n    float insideSqRadius;\n    vec2 insideCenter;\n    for (int i = 0; i < 8; ++i) {\n        vec2 pShift = p - centers[i];\n        float sqMag = dot(pShift, pShift);\n        float insideCurrent = 1.0 - step(0.0, sqMag - sq_radii[i]);\n        inside += insideCurrent;\n        if (insideCurrent > 0.0) {\n            insideSqRadius = sq_radii[i];\n\t        insideCenter = centers[i];\n        }\n    }\n    \n    if (inside > 0.0) {\n        // perform inversion\n        vec2 pShift = p - insideCenter;\n        float mag = sqrt(dot(pShift, pShift));\n        // sqR = magP*magP1\n        float magP1 = insideSqRadius / mag;\n        vec2 p1 = insideCenter + normalize(pShift)*magP1;\n        return vec3(p1, inside);\n    } else {\n        return vec3(p, inside);\n    }\n}\n\n// colormap functions from these guys:\n// https://github.com/kbinani/glsl-colormap/blob/master/shaders/IDL_Green-White_Linear.frag\nfloat colormap_red(float x) {\n    return 1.61361058036781E+00 * x - 1.55391688559828E+02;\n}\n\nfloat colormap_green(float x) {\n    return 9.99817607003891E-01 * x + 1.01544260700389E+00;\n}\n\nfloat colormap_blue(float x) {\n    return 3.44167852062589E+00 * x - 6.19885917496444E+02;\n}\n\nvec4 colormap(float x) {\n    float t = x * 255.0;\n    float r = clamp(colormap_red(t) / 255.0, 0.0, 1.0);\n    float g = clamp(colormap_green(t) / 255.0, 0.0, 1.0);\n    float b = clamp(colormap_blue(t) / 255.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n\n#define MAX_IT 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cCoord = fragCoord.xy - iResolution.xy*0.5;\n    \n \tfloat steps = 0.0;\n    for (int i = 0; i < MAX_IT; ++i) {\n\t    vec3 res = getInverse(cCoord);\n        steps += res.z;\n        cCoord = res.xy;\n    }\n    \n    vec4 c0 = vec4(0, 0, 0, 1);\n    vec4 c1 = vec4(0, 1, 0, 1);\n    steps /= float(MAX_IT);\n\tfragColor = colormap(steps);\n    \n    // circle positions\n    //float inside = getInverse(fragCoord.xy - iResolution.xy*0.5).z;\n    //fragColor = vec4(inside, inside, inside, 1.0);\n}","name":"Image","description":"","type":"image"}]}