{"ver":"0.1","info":{"id":"XllfDf","date":"1513688530","viewed":115,"name":"Thumpout","username":"nyu","description":"my first (failed) attempt for a 8k demoscene.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 lens_distortion(vec2 r, float alpha) {\n\treturn r * (1.0 - alpha * dot(r, r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = gl_FragCoord.xy / iResolution.xy;\n    //vec2 remapped = coord * 2.0 + 1.0;\n    vec2 remapped = coord;\n\n    fragColor.xyz = texture(iChannel0, coord).xyz;\n    return;\n    \n    // lens distortion\n    fragColor.xyz = texture(iChannel0, (lens_distortion(remapped, 0.2) / 2.0) + 0.5).xyz;\n\n    // chromatic aberation\n    float chromaticAmount = clamp(-0.005, 0.005, smoothstep(0.35, 1.8, length(remapped)));\n    vec2 uvRed = coord;\n    vec2 uvBlue = coord;\n    float s = abs(sin(iTime * 1.0)) * chromaticAmount;\n    uvRed.x += s;\n    uvBlue.x -= s;\n\n    fragColor.xyz =  texture(iChannel0, coord).xyz;\n\n    fragColor.r = texture(iChannel0, uvRed).r;\n    fragColor.b = texture(iChannel0, uvBlue).b;\n\n    // vigneting\n    fragColor *= 1.0 - smoothstep(0.15, 1.3, length(remapped));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n\n\nfloat fresnel(in vec3 normal, in vec3 viewDir, in float IOR) {\n    float R0 = ((-1.0/(IOR+2.6)) * 2.4) + 0.75;\n    return  R0 + (1.0 - R0) * exp(((1.0 - dot(-viewDir, normal)) - 1.0) * 4.6);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, in float cr) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 add(in vec4 d1, in vec4 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\nfloat sub(in float d1, in float d2) {\n    return max(-d1, d2);\n}\n\n\nfloat sdSphere(in vec3 p, in float s) {\n    return length(p)-s;\n}\n\nfloat Box(in vec3 p, in vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 rotateAroundZ(in vec3 p, in float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2  m = mat2(c, -s, s, c);\n    return vec3(m * p.xy, p.z);\n}\nvec2 sdBezier(in vec3 A,in vec3 B,in vec3 C,in vec3 pos) {\n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n    vec2 res;\n    vec3 qos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n    float p = ky - kx * kx;\n    float p3 = p * p *p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n\n   if(h >= 0.0) {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0/3.0));\n        float g = uv.x + uv.y - kx;\n        g = clamp( g, 0.0, 1.0 );\n        // 1 root\n         qos = d + (c + b * g) * g;\n        res = vec2( length(qos),g);\n   } else {\n        float z = sqrt(-p);\n        float v = acos( q/(p * z * 2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n        // 3 roots\n         qos = d + (c + b * t.x) * t.x;\n        float dis = dot(qos,qos);\n        res = vec2(dis,t.x);\n        qos = d + (c + b * t.y) *t.y;\n        dis = dot(qos,qos);\n        if( dis < res.x ){\n            res = vec2(dis,t.y );\n        }\n        qos = d + (c + b * t.z) * t.z;\n        dis = dot(qos,qos);\n        if( dis<res.x ) {\n            res = vec2(dis,t.z );\n        }\n        res.x = sqrt( res.x );\n    }\n    return res;\n}\n\nvec4 tentacle(in vec3 pos, in float height) {\n    vec3 a = vec3(0.0, 0.0,0.0);\n    vec3 b = vec3(1.0, 2.0,0.0);\n    vec3 c = vec3(-abs(cos(iTime + height)) + b.x - 1.5, -abs(sin(iTime + height)) + b.y - 0.5,0.0);\n    vec2 h = sdBezier( a, b, c, pos );\n    float distA = length(pos - a);\n    float distC = length(pos - c);\n    float th = mix(5.5, 0.1, 0.5 * (distC - distA)); //thickness\n    float kh = (th + h.y)/8.0;\n    float ra = 0.3 - 0.28*kh + 0.3*exp(-15.0*kh);\n    float d = h.x - ra;\n    vec2 tentLeft = vec2(0.5 * d, kh);\n\n    a = vec3(-3.0, 0.0,0.0);\n    b = vec3(-4.0, 2.0,0.0);\n    c = vec3(abs(cos(iTime + height)) + b.x + 1.5, -abs(sin(iTime + height)) + b.y - 0.5,0.0);\n    distA = length(pos - a);\n    distC = length(pos - c);\n    th = mix(5.5, 0.1, 0.5 * (distC - distA)); //thickness\n    h = sdBezier( a, b, c, pos );\n    kh = (th + h.y)/8.0;\n    ra = 0.3 - 0.28*kh + 0.3*exp(-15.0*kh);\n    d = h.x - ra;\n    return vec4(min(tentLeft.x, 0.5 * d), min(tentLeft.y, kh), 1.0, 1.0);\n}\n\nvec4 tunnel(in vec3 pos) {\n    vec3 newp = pos; //rotateAroundZ(pos, PI / 4.0 + sin(iTime + 0.5) * PI / 12.0);\n    float around = Box(newp, vec3(3.1, 3.1 + sin(iTime) * 0.2, 50.0));\n    float hole = Box(newp, vec3(3.0, 3.0 + sin(iTime) * 0.2, 50.1));\n    return vec4(sub(hole, around), vec3(0.393, 0.304, 0.8));\n}\n\nvec4 character(in vec3 pos) {\n    vec3 newp = pos;\n    float speed = 1.0; // default\n    float baseTime = iTime * speed;\n    vec3 camera = vec3(0.0, 0.3, baseTime);\n    \n    //float b = Box(rotateAroundZ(newp - vec3(sin(newp.z) / 2.0, -1.0, camera.z + 5.0 + 5.0 * abs(sin(iTime * 10.0))), 45.0 * sin(iTime * newp.z / 1000.0)), vec3(0.4, 0.4, 0.4 * sin(iTime / 15.0)));\n    //newp -= vec3(sin(newp.z) / 2.0, -1., camera.z + 10.0);\n    //newp -= vec3(0.0, sin(newp.z) * 0.3, 0.0);\n    //return vec4(b, vec3(0.3, 0.2, 0.7));\n    //return vec4(sdSphere(pos, 0.4), vec3(0.3, 0.2, 0.7));\n    return vec4(1.0);\n}\nfloat sdCone(in vec3 p,in vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nvec4 scene(in vec3 pos) {\n    float distDebugPosCubes = Box(vec3(vec3(2.0) - mod(pos, 4.0)), vec3(abs(sin(iTime*4.0)) * 0.3));\n    vec4 debugPosCubes = vec4(distDebugPosCubes, pos);\n    // road\n    vec3 roadPos = pos - vec3(sin(pos.z) / 2.0, -1.6, 0.0);\n    roadPos.z = mod(roadPos.z, 2.0);\n    float box =  Box(roadPos, vec3(0.9, 0.3, 9.0));\n    float obox = Box(roadPos + vec3(0.0, -0.5, 0.0), vec3(0.8, 0.4, 9.1));\n    vec4 t;\n    if (mod(pos.z, 75.0) > 32.0) {\n        t = tentacle(vec3(pos.x, roadPos.y, mod(pos.z, 6.0)) - vec3(1.5, 0.0, 3.0), pos.z);\n    } else {\n        t = tunnel(roadPos);\n    }\n    vec3 roadColour = vec3(0.0, 0.0, 0.0);\n    if (roadPos.x < 0.77 && roadPos.x > -0.77) {\n        float time = iTime * ((sin(iTime) + (sin(2.0 * iTime) / 2.0)) / 2.0) + 0.2;\n        roadColour.b = max(sin((abs(roadPos.x * 5.0) - time)), 0.0);\n        roadColour.b = pow((roadColour.b), 5.0);\n        roadColour.rg = vec2(mix(0.0, 1.0, smoothstep(0.5, 1.0, roadColour.b)));\n        roadColour *= 2.0;\n    }\n    vec4 road = vec4(sub(obox, box), roadColour + vec3(0.1, 0.1, 0.4));\n    vec4 rc = add(road, character(pos));\n    //vec4 coneTest = vec4(Box(vec3(vec3(2.0) - mod(rotateAroundZ(pos, 0.5 * pos.y), 4.0)), vec3(0.3)), vec3(0.1, 0.1, 0.4));\n    return add(rc, t);\n    return vec4(1.0);\n}\n\nvec3 genNormal(in vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy*scene(pos + e.xyy).x + \n            e.yyx*scene(pos + e.yyx).x + \n            e.yxy*scene(pos + e.yxy).x + \n            e.xxx*scene(pos + e.xxx).x );\n}\n\nvec3 AO(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    vec4 dd;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        dd = scene(aopos);\n        occ += -(dd.x-hr)*sca;\n        sca *= 0.95;\n    }\n    float ao = 1.0 - 3.0 * occ;\n    if (length(dd.yzw) > 1.0 && ao < 1.0) {\n        return dd.yzw * (1.0 - ao); \n    } else {\n        return vec3(clamp(ao, 0.0, 1.0));\n    }\n}\n\n#define MAX_RAYMARCH_ITERATIONS 512 // enough for tests\n//#define MAX_RAYMARCH_ITERATIONS 2048 // production level\n// IQ Raymarching iquilezles.org/articles/distfunctions\nvec4 castRay(in vec3 rayOrigin, in vec3 rayDirection, out  float complexity) {\n    const  float depthMin = 1.0;\n    const  float depthMax= 60.0;\n\n    float depth = depthMin;\n    vec3 m = vec3(0.0, 0.0, 0.0);\n    complexity = 0.0;\n    for(int i=0; i < MAX_RAYMARCH_ITERATIONS; i++) {\n        float precis = 0.00005 * depth;\n        vec4 res = scene(rayOrigin + rayDirection * depth);\n        if(res.x < precis || depth > depthMax) {\n           break;\n        }\n        depth += res.x;\n        m = res.yzw;\n        ++complexity;\n    }\n\n    complexity /= float(MAX_RAYMARCH_ITERATIONS);\n\n    const  float depthFadeSize = 20.0;\n    if (depth >= depthMax) {\n        m *= 0.0;\n    } else if (depth > (depthMax - 20.0)) {\n        m *= smoothstep(depthMax, depthMax - 20.0, depth);\n    }\n    return vec4(depth, m);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float speed = 1.0; // default\n    highp float baseTime = iTime * speed;\n\n    vec3 camera = vec3(0.0, 0.3, baseTime);\n    vec2 coord = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    coord.y /= iResolution.x / iResolution.y;\n    vec3 viewDir = setCamera(camera, camera + vec3(0.0, 0.5, 20.0), 0.0) * normalize(vec3(coord, 2.));\n    viewDir.xz *= sqrt((0.5 * coord) + 1.0);\n\n    float complexity;\n    vec4 data = castRay(camera, viewDir, complexity);\n\n    vec3 hitPosition = camera + data.x * viewDir;\n    vec3 normal = vec3(0.0);\n    vec3 ao = vec3(1.0);\n    vec4 reflection;\n    float refComplexity = 1.0;\n    if (data.x < 59.0) {\n        normal = genNormal(hitPosition);\n        ao = AO(hitPosition, normal);\n        vec3 refDir = reflect(viewDir, normal);\n        reflection = castRay(hitPosition, refDir, refComplexity);\n        vec3 refHitPos = hitPosition + reflection.x * refDir;\n    } else {\n        reflection = vec4(60.0, 0.0, 0.0, .0);\n    }\n\n    float f = fresnel(normal, viewDir, 1.4) + 0.1;\n    fragColor.xyz = mix(data.yzw, reflection.yzw, f) * ao;\n    \n}","name":"Buf A","description":"","type":"buffer"}]}