{"ver":"0.1","info":{"id":"wtcGDj","date":"1577639066","viewed":1019,"name":"Cel Shaded Primitives","username":"onlinerocker","description":"Some cel shaded primitives!\n\nShading is done with color quantization, outlines are drawn when a ray barely misses an object.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","celshading","celshading","shading","spheretracing","toon","cel","colorquantization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n//SETTINGS:\n#define VIEW_DIST 40.0\n#define FAST false\n//change FAST to 'true' to increase performance, will cause distortions on trees\n//change VIEW_DIST for farther or shorter render distance\n\n//Struct containing information about an object in the scene\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    float id;\n    \n    vec3 color;\n    vec3 normal;\n};\n\n//Struct containing resulting information from a ray march\nstruct MarchRes\n{\n \tfloat totalDist;\n    float minDist;\n    float glowAmt;\n    float edDist;\n    \n    vec3 curRay;\n    bool edge;\n    Object obj;\n};\n    \n//Struct containing information about a light in the scene\nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n\n/*\n   The distance functions below were taken from\n   Inigo Quilez's website.\n\n   They can all be found here:\n   https://iquilezles.org/articles/distfunctions\n*/\n    \n//Signed distance function for a plane\nfloat sdPlane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\n//Signed distance function for a vertical capsule\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n      p.y -= clamp( p.y, 0.0, h );\n      return length( p ) - r;\n}\n\n//Signed distnace function for a sphere\nfloat sdSphere(vec3 pos, float rad)\n{\n \treturn length(pos) - rad;\n}\n\n//Signed distance function for an ellipsoid\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//Signed distance function for an octahedron\nfloat sdOctahedron( vec3 p, float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n//Signed distance function for a round box\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//Signed distance function for a torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n//Signed distance function for a rounded cylinder\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n//Signed distance function for a hex-prism\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n        length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n        p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//Signed distance function for a tri-prism\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n    \n//Determines if a given position is inside any of the scene's objects\nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    \n    o.dist = 1000.0;\n    o.normEps = 0.001;\n    o.color = vec3(0);\n    \n    vec3 boardPos = pos;\n    boardPos.z = mod(boardPos.z, 10.0);\n    boardPos.x = mod(boardPos.x, 12.0);\n\tfloat dBoard = sdRoundBox(boardPos - vec3(0,-3,0), vec3(12, 0.5, 10.0), 0.1);\n    if(dBoard < o.dist)\n    {\n        o.dist = dBoard;\n        o.difVal = 1.0;\n        \n        vec3 col;\n        col = vec3(0, 0.3, 0);\n\n        o.color = col;\n        o.specVal = 200.0;\n        o.specKs = 0.0;\n    }\n    \n    float ang = PI/2.0;\n    vec3 objPos = pos - vec3(0.0, -1.0, 0.0); \n    \n    float dSphere = sdSphere(objPos, 1.4);\n    \n    \n    if(dSphere < o.dist){\n        o.dist = dSphere;\n        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 1.0;\n    }\n    \n    ang = PI/4.0;\n    objPos = pos - vec3(4.0, -1.0, 0.0); \n    objPos.xz = mat2(cos(ang), -sin(ang), sin(ang), cos(ang)) * objPos.xz;\n  \n    float dBox = sdRoundBox(objPos, vec3(1.0), 0.05);\n    if(dBox < o.dist)\n    {\n        o.dist = dBox;\n        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 1.0;        \n    }\n    \n    ang = PI/4.0;\n    objPos = pos - vec3(-4.0, -1.0, 0.0); \n    objPos.xz = mat2(cos(ang), -sin(ang), sin(ang), cos(ang)) * objPos.xz;\n\n    float dOct = sdOctahedron(objPos, 1.5);\n    if(dOct < o.dist)\n    {\n        o.dist = dOct;\n        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 1.0;        \n    }\n    \n    objPos = pos - vec3(0.0, -2.1, 3.5); \n\n    float dTor = sdTorus(objPos, vec2(1.1, 0.3));\n    if(dTor < o.dist)\n    {\n        o.dist = dTor;\n        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 1.0;        \n    }\n    \n    objPos = pos - vec3(0.0, -0.5, -3.5); \n\n    float dCyl = sdRoundedCylinder(objPos, 0.5, 0.1, 1.5);\n    if(dCyl < o.dist)\n    {\n        o.dist = dCyl;\n        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 1.0;        \n    }\n    \n    objPos = pos - vec3(-4.0, -2.0, 3.5); \n    float dCap = sdVerticalCapsule(objPos, 2.3, 0.5);\n    if(dCap < o.dist)\n    {\n        o.dist = dCap;\n        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 1.0;        \n    }\n    \n    objPos = pos - vec3(-4.0, -1.0, -3.5);  \n    float dHex = sdHexPrism(objPos, vec2(1.0));\n    if(dHex < o.dist)\n    {\n        o.dist = dHex;\n        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 1.0;        \n    }\n  \n    objPos = pos - vec3(4.0, -1.0, -3.5);  \n    float dTri = sdTriPrism(objPos, vec2(1.0));\n    if(dTri < o.dist)\n    {\n        o.dist = dTri;\n        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 1.0;        \n    }\n    \n    vec3 treePos = pos;\n    vec2 id = floor(vec2(treePos.x/10.0, treePos.z/10.0));\n    treePos.xz = abs(treePos.xz);\n    treePos.xz = mod(treePos.xz, 10.0);\n    treePos -= vec3(5.5, -7, 6.5);\n    float h = sin(id.x) * 337.0 * sin(id.y) * 43.3;\n    h = 1.5 + mod(h, 3.0);\n    \n    /*\n        NOTE:\n        If uncommented, the following two lines will make the trees move up and down:\n    */\n    \n    //float timeMod = 0.5 + mod(id.x*123.0 / id.y*1234.0, 1.0);\n    //h *= sin(iTime*1.0 + 43.445*id.y + 122.89*id.x);\n    \n    treePos.y -= h;\n    \n    float treeBound = sdVerticalCapsule(treePos, 7.5, 0.75);\n    \n    if(treeBound < o.dist && step(length(pos.xz), VIEW_DIST-13.0) > 0.0)\n    {\n        \n        float dTree = sdVerticalCapsule(treePos, 7.5, 0.5);\n        dTree = min(dBoard, dTree);\n        if(dTree < o.dist)\n        {\n            o.dist = dTree;   \n            o.difVal = 0.9;\n            float modi = 2.0*(round(step(sin(pos.z*PI), 0.0)) - 0.5);\n            float yStep = smoothstep(0.0, 0.3, treePos.y);\n\n            vec3 colTrunk = vec3(0.4, 0.3, 0) + vec3(sin(10.0*floor(10.0*treePos.y)))*0.05;\n            vec3 col = mix(vec3(1)*(round(step((modi)*sin(pos.x*1.0*PI), 0.0))),colTrunk, yStep);\n\n            o.color = col;\n            o.specVal = 200.0;\n            o.specKs = 0.0;\n        }\n        //tree leaves\n        vec3 leafPos = pos;\n        leafPos.xz = abs(leafPos.xz);\n        leafPos.xz = mod(leafPos.xz, 10.0);\n        leafPos -= vec3(5.5, 1.5, 6.5);\n        leafPos.y -= h;\n\n        float dLeaf = sdEllipsoid(leafPos, vec3(1.5, 1.0, 1.5));\n        dTree = min(dTree, dLeaf);\n        if(dLeaf < o.dist)\n        {\n            o.dist = dTree;   \n            o.difVal = 0.9;\n\n            float modi = 2.0*(round(step(sin(pos.z*1.*PI), 0.0)) - 0.5);\n\n            float yStep = smoothstep(-1.0, -0.8, leafPos.y);\n            vec3 col = mix(vec3(0.4, 0.3, 0) ,vec3(0, 0.3, 0), yStep);\n\n            o.color = col;\n            o.specVal = 200.0;\n            o.specKs = 0.0;\n        }\n    }\n    \n    return o;\n}\n\n//Calculates the surface normal at a given position\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \n//Marches a ray from a given position, in a given direction\n//at a given speed. Returns a struct containing information\n//about what it interesected.\nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n    res.glowAmt = 1.0;\n    res.minDist = 1000.0;\n\n    for(int x=0; x<150; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        if(abs(o.dist) < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n            \n        if(o.dist > res.minDist && o.dist < 0.1 && !res.edge) { res.edge = true; res.edDist = o.dist; }\n        \n        if(o.dist < res.minDist) res.minDist = o.dist;\n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        \n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\n//Determines if a shadow is being projected by a light source at a given position\nfloat calcShadow(vec3 pos, Light l)\n{\n    MarchRes res;\n    \n    if(VIEW_DIST > 20.0)\n \t\tres = marchRay(pos, normalize(l.pos - pos), 0.3); //march slower to prevent shadow artifacts\n    else\n    \tres = marchRay(pos, normalize(l.pos - pos), 1.0);\n        \n    if(res.totalDist < VIEW_DIST)\n        return 0.1;\n\treturn 1.0;\n}\n\n//Smoothly rounds to the nearest float value. Range defines\n//the range in which the value should be interpolated.\nfloat smoothRound(float v, float roundTo, float range)\n{\n    \n    float val = v/roundTo;\n    float frac = fract(val);\n    \n    if(abs(frac - 0.5) <= range) //If we're close to the rounded \"border\", do an interpolate between the values\n        \t\t\t\t\t\t //on each side of the border\n    {\n        float rd = round(val);\n        if(frac < 0.5)\n            val = mix((rd)*roundTo, (rd+1.0)*roundTo, smoothstep(0.5-range, 0.5, frac));\n\t\tif(frac >= 0.5)\n            val = rd*roundTo;//notice: this is equivalent to... mix((rd+1.0)*roundTo, (rd)*roundTo, smoothstep(0.5-range, 0.5, frac));\n    }\n    else //Rounds to nearest float value.\n    {        \n     \tval = round(val);   \n        val *= roundTo;\n    } \n    \n    return val;\n}\n\n//Calculates diffuse lighting\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    float val = clamp(dot(o.normal, dir), 0.0, 1.0);\n    float oVal = val;\n    \n    val = smoothRound(val, 0.33, 0.05);\n\n    vec3 col = (o.color) * l.intensity * l.color * val * o.difVal;   \n\n    return col;\n}\n\n//Calculates specular lighting\n//Steps the value with a smoothstep between 0.45 and 0.55.\n//This achives a \"cel-shaded\" specular effect\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    \n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n    \n    vec3 col = o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n    \n    return smoothstep(0.45, 0.55, col); //Stepping the value for cel-shaded effect\n}\n\n//The main function that returns the color\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y; //Converting UV coords to [-1, 1]\n\tvec3 camEye = vec3(0,0.0,9.0); //Setting camera position\n    vec3 dir = normalize(vec3(uv, -1)); //Setting up direction of ray\n    \n\n    float camAng = -PI/2.0 + iTime/4.0 + iMouse.x/20.0; //Camera yaw\n    float camAngX = -PI/6.0; //Camera pitch\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) ); //Rotation matrix for yaw\n    mat2 rotCamX = mat2( vec2(cos(camAngX), sin(camAngX)), vec2(-sin(camAngX), cos(camAngX)) ); //Rotation matrix for pitch\n\t\n    camEye.yz = rotCamX * camEye.yz; //Setting camera pitch\n    camEye.xz = rotCam * camEye.xz; //Setting camera yaw\n    \n    //Here we rotate the direction of our ray\n    dir.yz = rotCamX * dir.yz; //Setting ray pitch\n    dir.xz = rotCam * dir.xz; //Setting ray yaw\n\n    //Setting up our light source\n    Light light;\n    light.intensity = 1.4;\n    light.pos = vec3(5, 50, 50);\n    light.color = vec3(1);\n    \n    //Start ray marching...\n\tMarchRes res = marchRay(camEye, dir, FAST ? 1.0 : 0.3); //March our ray and get the result\n    vec3 pos = res.curRay;  \n    \n    //Color the background sky...\n    float y = uv.y + 1.0;\n    y = y / 1.62;\n    y = clamp(y, 0.7, 1.0);\n    vec3 col = (vec3(0.3, 0.46, 0.95)*(y) + vec3(1)*(1.0 - y));\n\n    //If our ray hit something within the view distance, determine what color it is\n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, pos) * calcShadow(pos, light); //Calculate diffuse lighting\n        col += calcSpecLight(res.obj, light,pos, camEye) * calcShadow(pos, light); //Calculate specular lighting\n    }\n    if(res.edge) col = mix(vec3(0), col, smoothstep(0.07, 0.1, res.edDist)); //If this is an edge, draw the outline\n\n    fragColor = vec4(col,1.0); //Set final color\n}","name":"Image","description":"","type":"image"}]}