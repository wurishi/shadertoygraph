{"ver":"0.1","info":{"id":"Nl3XRB","date":"1639299510","viewed":706,"name":"TDF2021 ShaderShowdown Semifinal","username":"phi16","description":"2\n\nsorry for too heavy shader\n\n[url]https://youtu.be/bp37xTVNRrM?t=8428[/url]","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["shadershowdown"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LOOP 40\n// original is 100\n\n#define LOOP2 2\n// original is 8\n\nfloat time = 0.;\n\nfloat rand(vec2 p) {\n  return fract(sin(dot(p,vec2(1,1.001)))*10000.);\n}\n\nvec3 trace(float x, out vec3 t) {\n  int u = int(floor(x));\n  float f = fract(x);\n  vec3 o0 = vec3(rand(vec2(u+0,0))-0.5, rand(vec2(u+0,1))-0.5, u+0) * vec3(40,20,60);\n  vec3 t0 = vec3(rand(vec2(u+0,2))-0.5, rand(vec2(u+0,3))-0.5, 1) * vec3(40,40,15)* 8.;\n  vec3 o1 = vec3(rand(vec2(u+1,0))-0.5, rand(vec2(u+1,1))-0.5, u+1) * vec3(40,20,60);\n  vec3 t1 = vec3(rand(vec2(u+1,2))-0.5, rand(vec2(u+1,3))-0.5, 1) * vec3(40,40,15) * 8.;\n  vec3 o = mix(o0,o1,6.*pow(f,5.) - 15.*pow(f,4.) + 10.*pow(f,3.));\n  o += t0 * pow(1.-f,3.) * f;\n  o -= t1 * pow(f,3.) * (1.-f);\n  t = (o1-o0) * (30.*pow(f,4.) - 60.*pow(f,3.) + 30.*pow(f,2.));\n  t += t0 * (-3.*pow(1.-f,2.) * f + pow(1.-f,3.));\n  t -= t1 * (3.*pow(f,2.)*(1.-f) - pow(f,3.));\n  return o;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b) {\n  vec3 pa=p-a,ba=b-a;\n  float h = clamp(dot(pa, ba)/dot(ba,ba),0.,1.);\n  return length(pa-ba*h);\n}\n\nfloat map(vec3 o) {\n  float x = floor(time*4.)/4.;\n  vec3 T;\n  vec3 p = trace(x,T);\n  for(int i=-1;i<LOOP2;i++) {\n    x += 1./4.;\n    vec3 q = trace(x,T);\n    if(capsule(o,p,q) < rand(vec2(x,0)) * 4. + 1.5) return 0.;\n    p = q;\n  }\n  if(rand(o.xz) < 0.1 || rand(o.xy) < 0.01 || rand(o.yz) < 0.01) return 1.;\n  return 0.;\n}\n\n\nfloat vao(vec2 s, float c) {\n  return (s.x+s.y+max(c,s.x*s.y))/3.;\n}\n\nfloat ao(vec3 ii, vec3 ir, vec3 tw) {\n  vec3 tu = tw.yzx;\n  vec3 tv = tw.zxy;\n  vec4 s = vec4(map(ii-tu),map(ii-tv),map(ii+tu),map(ii+tv));\n\n  vec4 c = vec4(map(ii-tu-tv),map(ii-tu+tv),map(ii+tu-tv),map(ii+tu+tv));\n  float v = mix(mix(vao(s.xy, c.x),vao(s.xw, c.y),dot(ir,tv)+0.5),\n  mix(vao(s.zy, c.z),vao(s.zw, c.w),dot(ir,tv)+0.5),dot(ir,tu)+0.5);\n  return 1.-pow(v,2.)*0.5;\n  \n}\nbool castf(vec3 o, vec3 d, out vec3 ii, out vec3 ir, out vec3 tw) {\n  vec3 u = floor(o);\n  vec3 s = sign(d);\n  d = abs(d);\n  vec3 r = (o-u-0.5)*s+0.5;\n  for(int i=0;i<LOOP;i++) {\n    if(map(u) > 0.5) {\n      ii = u;\n      ir = (r-0.5)*s;\n      return true;\n    }\n    vec3 l = (1.-r)/d;\n    vec3 m = step(l,l.yzx) * step(l,l.zxy);\n    tw = -s*m;\n    r += d*length(l*m) - m;\n    u += m*s;\n  }\n  return false;\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\ntime = iTime*160./120.;\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y /iResolution.x, 1);\ntime +=( rand(uv*1000.+time)*0.01 + fract(fragCoord.x/2.) * 0.04 + fract(fragCoord.y/2.) * 0.02) *0.5;\n  vec3 c = vec3(0);\n  \n  vec3 T;\n  vec3 o = trace(time,T);\n  vec3 d = vec3(uv,1.+dot(uv,uv)*0.5);\n  trace(time+0.1,T);\n  T = normalize(T);\n  vec3 B = normalize(cross(T,vec3(0,1,0)));\n  vec3 N = cross(B,T);\n  d = d.x*B + d.y*N + d.z*T;\n  vec3 ii,ir,tw;\n  if(castf(o,d,ii,ir,tw) || true) {\n    vec3 pos = ii+ir+0.5;\n    vec3 normal = sign(ir)*normalize(pow(abs(ir),vec3(10)));\n    c = vec3(1);\n    c *= ao(ii+tw,ir,tw);\n    c  *= exp(-pow(distance(pos,o),2.)*0.001);\n    \n    vec3 pl = trace(time+0.4, T);\n    vec3 sd = normalize(pl-pos);\n    float ra = max(0.,dot(normal, sd)) / pow(distance(pl,pos), 0.5);\n    castf(pos-d*0.01, sd, ii,ir,tw);\n    if(distance(pos,ii+ir+0.5) < distance(pl,pos)) ra *= 0.0;\n    \n    if(distance(o,pl) < distance(o,pos)) ra += 0.1 / distance(pl, o+dot(pl-o,d)*d) * 9.;\n    \n    pl = trace(time+0.15 + (cos(time*3.1415926535)*0.5+0.5)*0.2, T);\n    sd = normalize(pl-pos);\n    float ga = max(0.,dot(normal, sd)) / pow(distance(pl,pos), 0.2);\n    if(distance(pos,ii+ir+0.5) < distance(pl,pos)) ga *= 0.0;\n    ga *= cos(ii.z+ir.z+0.5)*0.5+0.5;\n    if(distance(o,pl) < distance(o,pos)) ga += 0.1 / distance(pl, o+dot(pl-o,d)*d) * 2.;\n    \n    float rim = pow(1.-max(0.,dot(normal,normalize(o-pos))), 2.);\n   c *= (ga*vec3(1,0,0.5) + ra*vec3(0,0.5,1)+rim*vec3(0.5,0.25,0.75)*0.1) * 8.;\n  }\n  \n // now I have completed all things I prepared beforreeeee\n  \n   // what should i do\n  c *=cos(dot(uv,uv));\n\tfragColor = vec4(c,1);\n}\n\n","name":"Image","description":"","type":"image"}]}