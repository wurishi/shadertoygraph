{"ver":"0.1","info":{"id":"4tlcRS","date":"1505975133","viewed":196,"name":"Implicit Surfaces","username":"jgkling","description":"Goopy","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 50.f\n#define T_MAX 3.5f\n\nconst float k_smooth = 24.0;\n\n// Exponential Smooth Min - from IQ's article: https://iquilezles.org/articles/smin\nfloat SmoothMin_IQ( in float a, in float b )\n{\n    float res = exp(-k_smooth * a) + exp(-k_smooth * b);\n    return -log(res) / k_smooth;\n}\n\n// IQ's Signed Distance Functions: https://iquilezles.org/articles/distfunctions\n\nfloat SDF_Sphere( in vec3 pos, in float radius )\n{\n    return length(pos) - radius;\n}\n\nfloat SDF_Torus( in vec3 pos, in vec2 t)\n{\n    vec2 qos = vec2(length(pos.xz) - t.x, pos.y);\n    return length(qos) - t.y;\n}\n\nfloat SDF_RoundedBox( vec3 pos, vec3 b, float r )\n{\n  return length(max(abs(pos) - b, 0.0)) - r;\n}\n\nfloat SceneMap( in vec3 pos )\n{\n    // Bounding Volume\n    float distToBoundingSphere = SDF_Sphere(pos, 1.0);\n    if(distToBoundingSphere < 0.025f)\n    {\n        // Cached calls to sin\n        float sin_norm1 = (sin(iTime) + 1.0) * 0.5; // remap to [0,1]\n        float sin_norm2 = (sin(iTime * 0.2) + 1.0) * 0.5; // remap to [0,1]\n        float sin_norm3 = (sin(iTime * 0.6) + 1.0) * 0.5; // remap to [0,1]\n        float sin1 = sin(iTime * 0.5);\n        float sin2 = sin(iTime * 1.2);\n        float sin3 = sin(iTime * 1.5);\n        \n        float sdf1 = SDF_Sphere(pos - vec3(0.0, sin(iTime * 0.25) * 0.3, 0.0), (sin_norm1 * 0.8 + 0.8) * 0.25);\n        float sdf2 = SDF_Torus(pos - 0.5 * vec3(0.0, sin1, 0.0), vec2((sin_norm3) * 0.44, 0.025));\n        float sdf3 = SDF_Torus(pos - 0.5 * vec3(0.0, sin(iTime * 1.7), 0.0), vec2((sin_norm2) * 0.6, 0.05));\n        float sdf4 = SDF_Torus(pos - 0.5 * vec3(0.0, sin(iTime * 1.4 + 1.0), 0.0), vec2((sin_norm2) * 0.5, 0.06));\n        float sdf5 = SDF_Torus(pos - 0.5 * vec3(0.0, sin2, 0.0), vec2((sin_norm3) * 0.8, 0.07));\n        float sdf6 = SDF_RoundedBox(pos - 0.5 * vec3(sin1, sin(iTime * 1.2), 0.0), vec3(0.025) * (sin_norm1 * 0.5 + 0.75), 0.025);\n        float sdf7 = SDF_RoundedBox(pos - 0.5 * vec3(sin(iTime * 1.5 + 1.0), sin(iTime * 0.5 + 1.0), 0.0), vec3(0.075) * (sin_norm1 * 0.5 + 0.45), 0.025);\n        float sdf8 = SDF_RoundedBox(pos - 0.5 * vec3(sin(iTime * 0.5 + 0.5), sin(iTime * 1.2 + 0.5), 0.0), vec3(0.075) * (sin_norm1 * 0.5 + 0.75), 0.025);\n        float sdf9 = SDF_RoundedBox(pos - 0.5 * vec3(sin(iTime * 0.5 + 1.0), sin(iTime * 1.5 + 0.5), 0.0), vec3(0.075) * (sin_norm1 * 0.5 + 0.45), 0.025);\n        float sdf10 = SDF_RoundedBox(pos - 0.5 * vec3(sin2, sin(iTime * 0.8 + 0.5), 0.0), vec3(0.075) * (sin_norm1 * 0.5 + 0.75), 0.025);\n        \n        // Exponential Smooth Min - from IQ's article: https://iquilezles.org/articles/smin\n        sdf1 = exp(-k_smooth * sdf1) +\n               exp(-k_smooth * sdf2) +\n               exp(-k_smooth * sdf3) +\n               exp(-k_smooth * sdf4) +\n               exp(-k_smooth * sdf5) +\n               exp(-k_smooth * sdf6) +\n               exp(-k_smooth * sdf7) +\n               exp(-k_smooth * sdf8) +\n               exp(-k_smooth * sdf9) +\n               exp(-k_smooth * sdf10);\n               \n        return -log(sdf1) / k_smooth;\n    }\n    else\n    {\n        return distToBoundingSphere;\n    }\n}\n\nvec3 ComputeNormal( in vec3 pos )\n{\n    vec2 epsilon = vec2(0.0, 0.001);\n    return normalize( vec3( SceneMap(pos + epsilon.yxx) - SceneMap(pos - epsilon.yxx),\n                            SceneMap(pos + epsilon.xyx) - SceneMap(pos - epsilon.xyx),\n                            SceneMap(pos + epsilon.xxy) - SceneMap(pos - epsilon.xxy)));\n}\n\n\nvec3 LightContrib( in vec3 lightDir, in vec3 lightCol, in vec3 normal, in vec3 camLook )\n{\n    vec3 baseCol = vec3(0.2);\n    vec3 specularColor = vec3(0.9);\n    float lambertDot = clamp(dot(normal, lightDir), 0.001, 1.0);\n    float phongDot = pow(clamp(dot(camLook, reflect(lightDir, normal)), 0.0, 1.0), 40.0);\n    \n    vec3 diffuseTerm = baseCol * pow(lambertDot, 2.0) * lightCol;\n    vec3 specularTerm = 0.1 * phongDot * specularColor;\n    \n    return lightCol * (diffuseTerm + specularTerm);\n}\n\nvec3 ComputeLighting( in vec3 normal, in vec3 camLook )\n{\n    vec3 accumLight = vec3(0.0);\n    \n    accumLight += LightContrib(normalize(vec3(0.0, 1.0, -1.0)), vec3(0.92, 0.82, 0.22), normal, camLook);\n    accumLight += LightContrib(normalize(vec3(0.5, -0.75, -1.0)), vec3(0.98, 0.8, 0.2), normal, camLook);\n    accumLight += LightContrib(normalize(vec3(0.0, -1.0, 1.0)), vec3(0.4, 0.4, 0.8), normal, camLook);\n    accumLight += LightContrib(normalize(vec3(-5.0, 2.0, 0.75)), vec3(0.8, 0.8, 0.45) * 1.1, normal, camLook);\n    accumLight += LightContrib(normalize(vec3(0.75, 0.25, 0.55)), vec3(0.85, 0.85, 0.42) * 1.1, normal, camLook);\n    \n    return accumLight;\n}\n\nvec3 RaymarchScene( in vec3 origin, in vec3 dir )\n{\n    float distance;\n    float t = 0.01;\n    float hitSomething = 0.0;\n    \n    float i;\n    for(i = 0.0; i < MAX_ITERATIONS; i += 1.0)\n    {\n        distance = SceneMap(origin + t * dir);\n        \n        if(distance < 0.01)\n        {\n            hitSomething = 1.0;\n            break;\n        } else if (t > T_MAX)\n        {\n            break;\n        }\n        \n        t += distance;\n    }\n    return vec3(t, hitSomething, i);\n}\n\nvec4 cosinePallette(float i)\n{\n    float r = 0.5f + 0.5f * cos(6.28318 * (0.05f * i + 0.3f));\n    float g = 0.5f + 0.5f * cos(6.28318 * (1.0f * i + 0.1f));\n    float b = 0.5f + 0.5f * cos(6.28318 * (0.0f * i + 0.1f));\n    return vec4(r, g, b, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPoint = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Compute ray direction\n    float distance = 2.5;\n    vec3 rayOrigin = vec3(cos(iTime * 0.5) * distance, 0.0, sin(iTime * 0.5) * distance); // camera position\n    vec3 rayDirection;\n    \n    // Ray casting\n    vec3 refPoint = vec3(0.0, 0.0, 0.0);\n    vec3 camLook = normalize(refPoint - rayOrigin);\n    vec3 camRight = normalize(cross(camLook, vec3(0.f, 1.f, 0.f)));\n    vec3 camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = refPoint + screenPoint.x * camRight + screenPoint.y * camUp;\n    rayDirection = normalize(rayPoint - rayOrigin);\n    \n    vec3 result = RaymarchScene(rayOrigin, rayDirection);\n    \n    vec4 finalColor;\n    if(result.y > 0.0)\n    {\n        vec3 normal = ComputeNormal(rayOrigin + result.x * rayDirection);\n        finalColor = vec4(ComputeLighting(normal, camLook), 1.f);\n    }\n    else\n    {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        float sinThing = sin(iTime * 0.175f + 2.f * (uv.x * uv.y));\n        float cosThing = cos(iTime * 0.175f+ 3.f * (uv.x + uv.y));\n        float sinThing2 = sin(iTime * 0.125f + 2.f * (length(screenPoint)));\n        float colorThing = (sinThing * cosThing * sinThing2) * 0.5f + 0.5f;\n        finalColor = vec4(cosinePallette(colorThing) * 0.5f);\n    }\n    fragColor = vec4(pow(finalColor.xyz, vec3(1.f / 2.2f)), 1.f);\n}","name":"Image","description":"","type":"image"}]}