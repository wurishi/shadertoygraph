{"ver":"0.1","info":{"id":"XsyGDV","date":"1456417452","viewed":225,"name":"Raycasting test (Anastadunbar)","username":"anastadunbar","description":"It made me do this because of https://www.shadertoy.com/view/MdXXz2. It's like ray-marching without ray problems.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raycaster","layer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//SETTINGS\nconst int LOOPS = 1000;\nfloat DEPTH_DIV = 120.;\nfloat SCALE_DIV = 50.;\nconst float PRECISE = 1.;\nbool VOLUME = false;\n\n#define PI 3.1415926535897932384626433832795028\nvec3 rX(vec3 p, float a) { //YZ\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.y = c * q.y - s * q.z;\n\tp.z = s * q.y + c * q.z;\n    return p;\n}\n\nvec3 rY(vec3 p, float a) { //XZ\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x + s * q.z;\n\tp.z = -s * q.x + c * q.z;\n    return p;\n}\n\nvec3 rZ(vec3 p, float a) { //XY\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x - s * q.y;\n\tp.y = s * q.x + c * q.y;\n    return p;\n}\n\n//Map, 1 is wall, 0 is empty.\nfloat map(vec3 p) { \n    float time = iTime;\n    p = rY(p,(fract(time*.4)*float(mod(time*.4,4.)>3.)*(PI*2.)));\n    float tunnel = float((p.x > 5. || p.x < -5.) || (p.y > 3. || p.y < -3.));\n    float radius = 1.4;\n    float sphere = float(length(p-vec3(asin(sin(time))*2.8,abs(sin(time*3.)*2.)-((3.-(radius/2.))),5.)) < radius);\n    radius = 0.2;\n    vec3 pos = vec3(0.,.7,1.4);\n    pos = rX(p-pos,time);\n    float bar = float((pos.y > -radius) && (pos.y < radius) && (pos.z > -radius) && (pos.z < radius));\n    return tunnel+sphere+bar;\n}\n\n#define clamps(x) clamp(x,0.,1.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    DEPTH_DIV *= PRECISE; SCALE_DIV *= PRECISE;\n\tvec2 uv = (fragCoord.xy / iResolution.xy)-.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Raycaster / Layering\n    vec3 p; //Position\n    float a = 0.; //\"Alpha\"\n    for (int i = 0; i < LOOPS*int(max(PRECISE,1.)); i++) {\n        vec3 pos = vec3(uv*((float(i)/SCALE_DIV)+1.),float(i)/DEPTH_DIV);\n        if (map(pos) >= 1.) {\n            if (VOLUME) {\n                a += 1./float(LOOPS*int(max(PRECISE,1.)));\n            } else {\n                a = 1.;\n                break; //Pixel doesn't need to be filled anymore. Stop the loop.\n            }\n        } else {\n            p = pos;\n        }\n    }\n    float fog = (p.z*DEPTH_DIV)/(float(LOOPS)*PRECISE);\n    if (VOLUME) {\n        fragColor = vec4(vec3(a),1.0);\n    } else {\n\t\tfragColor = vec4(fract(p)*(1.-pow(fog,4.)),1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}