{"ver":"0.1","info":{"id":"ctVcDD","date":"1700245445","viewed":60,"name":"Perlin Noise testing","username":"Elyades","description":"Trying to make some texture","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float frac(float x)\n{\n    return( x - float(floor(x)));\n}\n\nfloat smooth1(float x)\n{\n    if (x < 0.0){return 0.0;}\n    else if (x > 1.0){return 1.0;}\n    else{return( x*x*(3.0 - 2.0*x));}\n}\n\nfloat interpolate(float x, float a, float b)\n{\n    return(a + smooth1(x)*(b-a));\n}\n\nfloat prodGrid(vec2 uv, vec2 node, vec2 randVec)\n{\n    vec2 diff = uv - node;\n    return(diff.x*randVec.x + diff.y*randVec.y);\n}\n\nfloat perlinNoise(vec2 uv)\n{\n    vec2 roundDown = floor(uv);\n    vec2 roundUp = roundDown + vec2(1.0);\n    float dx = frac(uv.x); float dy = frac(uv.y);\n    \n    float rand = cos(100000000.0*(0.5*roundDown.x + 0.5*roundDown.y));\n    vec2 randVec = vec2(rand, sqrt(1.0-rand*rand));\n    \n    float prod1 = prodGrid(uv,roundDown,randVec);\n    float prod2 = prodGrid(uv, vec2(roundUp.x,roundDown.y) ,randVec);\n    float lerp1 = interpolate(dx, prod1, prod2);\n    float prod3 = prodGrid(uv, vec2(roundDown.x,roundUp.y) ,randVec);\n    float prod4 = prodGrid(uv,roundUp,randVec);\n    float lerp2 = interpolate(dx, prod3, prod4);\n    \n    float final = interpolate(dy,lerp1,lerp2);\n    return(final);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)*7.0/iResolution.y;\n    \n    float final = perlinNoise(uv);\n    \n    vec3 col = vec3(final);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}