{"ver":"0.1","info":{"id":"md3BW7","date":"1697227449","viewed":53,"name":"13. Rise","username":"Ladus","description":"Inktober 2023 Day 13. A blood moon rises. Code turned out a bit messy, but I like the visuals.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["inktober","rise","bloodmoon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nvec2 normalizeScreenSpace(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 1.-(iResolution.y/iResolution.x);\n    uv = (uv - vec2(0.5))*2.;\n    return uv;\n}\n\nfloat sdfCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// Hash12 By Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rotate(float a) {\n    a *= PI * 2.;\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 Noise(vec2 s) {\n    return vec2(hash12(s),hash12(s+vec2(3.245,2.144)));\n}\n\nvec2 GetNeighborVector(vec2 offset, vec2 li) {\n    vec2 wI = li + offset;\n    vec2 wRandomVector = Noise(wI);\n    return wI + wRandomVector;\n}\n\nfloat distanceFromNeighbor(vec2 neighbor, vec2 li, vec2 l) {\n    vec2 wLs = GetNeighborVector(neighbor, li);\n    return 1.-distance(l, wLs);\n}\n\nfloat Spheres(vec2 s, float t) {    \n    s.y -= t*0.4;\n    vec2 l = s * 1.;\n    vec2 li = floor(s*1.);\n    \n    vec2 randomVector = Noise(li);\n    vec2 ls = li + randomVector;\n    \n    float distanceFromCenter = 1.-distance(l, ls);\n    float result = distanceFromCenter;\n    \n    float distanceFromN = distanceFromNeighbor(vec2(0., 1.), li, l);\n    result = max(result, distanceFromN);\n    float distanceFromNE = distanceFromNeighbor(vec2(1., 1.), li, l);\n    result = max(result, distanceFromNE);\n    float distanceFromE = distanceFromNeighbor(vec2(1., 0.), li, l);\n    result = max(result, distanceFromE);\n    float distanceFromES = distanceFromNeighbor(vec2(1., -1.), li, l);\n    result = max(result, distanceFromES);\n    float distanceFromS = distanceFromNeighbor(vec2(0., -1.), li, l);\n    result = max(result, distanceFromS);\n    float distanceFromSW = distanceFromNeighbor(vec2(-1., -1.), li, l);\n    result = max(result, distanceFromSW);\n    float distanceFromW = distanceFromNeighbor(vec2(-1., 0.), li, l);\n    result = max(result, distanceFromW);\n    float distanceFromNW = distanceFromNeighbor(vec2(-1., 1.), li, l);\n    result = max(result, distanceFromNW);\n\n    return pow(result,2.);\n}\n\nfloat spheresNoisy(vec2 p, float r) {\n    //p.y -= iTime*0.4;\n\n    float sinRotate = sin(iTime/5.)*0.0;\n    float spheres = Spheres(vec2(1.,4.)*rotate(0.7+sinRotate)*p*4.*vec2(atan(rotate(0.7-sinRotate)*p*PI)*Noise(((fract(iTime/3.))+12.124*atan(rotate(0.7+sinRotate)*p*PI))+3.)), iTime);\n    float spheres1 = Spheres(vec2(1.,4.)*rotate(0.2-sinRotate)*p*4.*vec2(atan(rotate(0.2+sinRotate)*p*PI)*Noise(((fract(iTime/3.))+12.124*atan(rotate(0.2-sinRotate)*p*PI))+3.)), iTime);\n    float spheres2 = Spheres(vec2(1.,4.)*rotate(0.34+sinRotate)*p*4.*vec2(atan(rotate(0.34-sinRotate)*p*PI)*Noise(((fract(iTime/3.))+12.124*atan(rotate(0.34+sinRotate)*p*PI))+3.)), iTime);\n    spheres *= spheres1 * spheres2 * 4.;\n    return spheres;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aa = 0.003;\n    vec2 p = normalizeScreenSpace(fragCoord);\n    \n    // Scale\n    p *= 0.5;\n    \n    // Create whole circular gradient\n    float angle = 1. - max((clamp(0.,1.,atan(p.x,p.y) / PI) / 2.), ((clamp(0.,1.,atan(-p.x,-p.y) / PI) / 2.) + 0.5 ));\n    \n    float offset = 0.005;\n    float sinRotate = sin(iTime/5.)*0.0;\n    float spheresM = spheresNoisy(p+vec2(0.,0.),sinRotate);\n    float spheresN = spheresNoisy(p+vec2(0.0,offset),sinRotate);\n    float spheresE = spheresNoisy(p+vec2(offset,0.0),sinRotate);\n    float spheresS = spheresNoisy(p+vec2(0.0,-offset),sinRotate);\n    float spheresW = spheresNoisy(p+vec2(-offset,0.),sinRotate);\n    float spheres = (spheresM+spheresN+spheresE+spheresS+spheresW)/5.;\n\n    // Moon\n    float circle = sdfCircle(p,0.2);\n    float circleMask = smoothstep(0.+aa,0.-aa, circle);\n    float glow = pow((1.-clamp(circle, 0., 1.) - circleMask),6.)*0.5;\n    float animatedGlow = spheres * glow * 4.;\n    float moonSurface = (1.-pow(clamp(circle+1.,0.,1.),7.)*0.8+0.1) * circleMask;\n    float glowThinRing = pow(smoothstep(-0.1,0.02,circle)*smoothstep(0.8,0.,circle),8.);\n\n    float moonSurfaceNoice = ((clamp(pow(Spheres(p*9.*moonSurface,0.),.3),0.,.8)*4.) * (moonSurface*0.2) * circleMask);\n\n    // Output to screen\n    float v = moonSurfaceNoice+animatedGlow+(glowThinRing*0.5);\n    \n    vec3 color = clamp(mix(vec3(.01,0.001,0.005),vec3(1.,0.,0.),v),0.,1.);\n    vec3 blendedColor = clamp(color * vec3(glowThinRing),0.,1.);\n    color = mix(color,blendedColor, .8)*1.2;\n    \n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}