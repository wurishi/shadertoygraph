{"ver":"0.1","info":{"id":"MfdyDM","date":"1731469946","viewed":96,"name":"Rayzee","username":"orblivius","description":"Rayzee visualizer","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["2d","3d","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rayzee visualizer by Orblivius\n// Based on work of others \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define PI 3.141592\n\n#define rot(x) mat2(cos(x+vec4(0,11,33,0)))\n\n//Rodrigues-Euler axis angle rotation\n#define ROT(p,axis,t) mix(axis*dot(p,axis),p,cos(t))+sin(t)*cross(p,axis)\n\n#define H(h)  (  cos(  h/3. + vec3(1,1,0) )*.9 + .8 + .25  * (sin(iTime*.3))  )\n\n#define H2(h)  (  cos(  h*2. + vec3(0,2,1) )*.9 + .7 +  .25 * abs(sin(iTime*.1)) )\n\n#define M(c)  log(2.+c)\n\n#define R iResolution\n\nconst float pi = 3.14159265;\nconst float halfpi = pi * 0.5;\n\nmat2 mm2(in float a){float c = abs( cos(a) ), s = sin(a);return mat2(c,-s,s,c);}\n\n\n\n#define cut_factor (0.3)\n#define black_hole_distance (20.)\n\nfloat saturate( float a )\n{\n\treturn clamp( a, 0.0, 1.0 );\n}\nvec3 aces_approx(vec3 v) {\nv = max(v, 0.0);\nv *= 0.6f;\nfloat a = 2.51f;\nfloat b = 0.03f;\nfloat c = 2.43f;\nfloat d = 0.59f;\nfloat e = 0.14f;\nreturn clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n//\n// Fractional Brownian Motion code by IQ.\n\nfloat noise( float x, float y )\n{\n\treturn sin(1.5*x)*sin(1.5*y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm4( float x, float y )\n{\n    vec2 p = vec2( x, y );\n    float f = 0.0;\n    f += 0.5000*noise( p.x, p.y ); p = m*p*2.02;\n    f += 0.2500*noise( p.x, p.y ); p = m*p*2.03;\n    f += 0.1250*noise( p.x, p.y ); p = m*p*2.01;\n    f += 0.0625*noise( p.x, p.y );\n    return f/0.9375;\n}\n\n// Thanks, Inigo!\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n//\n\nconst float linesmooth = 0.0333;\n\nfloat myfunc(vec2 uv, out vec3 ledcolor)\n{\n    // quantize coordinates\n    const float bands = 30.0;\n    const float segs = 20.0;\n    vec2 p;\n    p.x = floor(uv.x*bands)/bands;\n    p.y = floor(uv.y*segs)/segs;\n\n    // read frequency data from first row of texture\n    float fft  = texture( iChannel1, vec2(p.x,0) ).x;\n\n    // led color\n    vec3 color = mix(vec3(0.0, .0, 1.0), vec3(2.0, 0.0, 0.0), sqrt(uv.y));\n\n    float mask = (p.y < fft) ? 1.0 : 0.0;\n\n    // led shape\n    vec2 d = fract((uv - p) *vec2(bands, segs)) - 0.5;\n    float led = smoothstep(0.5, 0.35, abs(d.x)) *\n                smoothstep(0.5, 0.35, abs(d.y));\n    ledcolor = led*color*mask;\n    return mask; \n}\n\nvec2 normalizeCoord(vec2 coord)\n{\n    vec2 uv = coord.xy / iResolution.xy;                      // normalize  0   <-->   1\n    uv -= .5;                                                 // center    -0.5 <-->   0.5\n    uv *= iResolution.xy/(min(iResolution.x, iResolution.y)); // fix aspect ratio\n    return uv; \n}\n\nvec2 polarizeCoord(vec2 coord)\n{\n    float angle = atan(coord.x, coord.y); \n    float d = length(coord); \n    vec2 st = vec2(angle, d); \n    return st; \n}\n\nfloat mirrorAngle(float angle)\n{\n    return abs(angle)/pi; \n}\n\nfloat diskify(float d)\n{\n    return smoothstep(0.1, 1., d*2.);  \n}\n\nfloat spin(float angle)\n{\n    return angle+cos(iTime*0.3);\n}\n\n\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map(float v, float v_min, float v_max, float out1, float out2)\n{\n    if ( v_max - v_min == 0. )\n        return out2;\n        \n     return (clamp(v,v_min,v_max) - v_min) / (v_max - v_min) * (out2-out1)+out1;\n}\n\nfloat angle_diff_grad(float angle1, float angle2)\n{\n    float d = abs(angle1 - angle2);\n    return d < 180. ? d : 360. - d;\n}\n\n\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\n\tvec4 w, d;\n\n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\n\tw = max(0.6 - w, 0.0);\n\n\td.x = dot(random3(s), x);\n\td.y = dot(random3(s + i1), x1);\n\td.z = dot(random3(s + i2), x2);\n\td.w = dot(random3(s + 1.0), x3);\n\n\tw *= w;\n\tw *= w;\n\td *= w;\n\n\treturn dot(d, vec4(52.0));\n}\n\nfloat stepping(float t)\n{\n    if(t < 0.)\n    {\n        return -1. + pow(1. + t, 2.);\n    }\n    else\n    {\n        return 1. - pow(1. - t , 2.);\n    }\n}\n\nvoid mainImage( out vec4 O, vec2 U) {\n      float w = texture(iChannel1, vec2(.05)).x;\n               vec2 uv = (U * 2. - iResolution.xy) / iResolution.y;\n  \n\n   // fcol.xyz = pow(fcol.xyz, vec3(3.));  \n  vec2 screenCenter = 0.5 * iResolution.xy;\n    O = texture(iChannel0, (U - screenCenter) * clamp((0.89 + w / 6.), 0.96, 1.02) / iResolution.xy + 0.5);\n\n    vec3 c=vec3(0);\n    vec4 rd = normalize( vec4(U-.5*R.xy, .7*R.y, R.y))*200.;\n    \n    float sc,dotp,totdist=0., tt=iTime, t=0.;\n    \n    for (float i=0.; i<35.; i++) {\n        \n        vec4 p = vec4( rd*totdist);\n            \n        p.xyz += vec3(0.,0,-50.+40.*w);\n        \n        p.yz *= rot(-tt);\n           \n        p.yzw = p.xyz;\n        \n        sc = .6; \n       p.xz *= rot(tt);\n       \n        \n       p.xw *= rot(-tt*.4);\n        \n        vec4 w = p;\n        \n        for (float j=0.; j<7.; j++) {\n          \n            p = abs(p)*.7;\n       \n            dotp = max(1./dot(w,w),.05 + .01);\n            sc *= dotp; \n            \n            p = p * dotp - .35; \n            \n            w = .35 * log(1.-exp(-p*p)*p) - .15;\n        }\n         \n        float dist = length( 1. - p) /sc ;  //funky distance estimate\n        float stepsize = dist/100. + 1e-6;     \n        totdist += stepsize;                  //move the distance along rd\n        \n        //accumulate color, fading with distance and iteration count\n        c +=\n            ( .03 * H2(  atan( p.w, p.z )) \n           + .06 * mix( vec3(1), H(M(sc)),.95) )*  exp(-i*i*stepsize*stepsize*5e1);\n    }\n    float aspect = iResolution.x/iResolution.y;\n    vec2 mainuv = ( U.xy / iResolution.xy );\n   \n    vec2 _uv = (U.xy - iResolution.xy/2.) / min(iResolution.x, iResolution.y);\n    float distance = 2. / length(_uv);\n    float angle = angle_diff_grad( map( atan(_uv.y, _uv.x), -pi,pi,0.,360.), 0. );\n    \n    float finalval = 0.0;\n    float rings = 50.0;\n\n    float scale = 10.;\n   \n     vec2 uv2 = U/iResolution.xy;\n    uv2 = 2.*uv2 - 1.;\n    uv2.x *= iResolution.x/iResolution.y;\n   \n   \n   // _uv *= 8.;\n   _uv *= 0.25;\n   uv2 *= 7.;\n   \n      \n    /////////////////////////\n    vec3 colo = vec3(0);\n    float s = 0.;\n\n    const float N = 30.;\n    const float stripe_fact = 1.4;\n    const float stripe_width = 0.8; // [0..1]\n    \n    float r = length(uv2);\n    float th = (atan(uv2.y,uv2.x)+pi)/(2.*pi); // [0..1]\n    th += .1*iTime;\n    float ith = mod(floor(th*N)/N,1.);\n    float fth = mod(th,1./N)*N;\n    \n\n    vec3 finalColor =  vec3(0);\n    float color = 0.;\n    float alpha = 0.;\n    float normal_distance = 0.;\n    if ( distance < black_hole_distance)\n    {\n        normal_distance = map(distance,0.,black_hole_distance,1.,0.);\n   float beat = iTime;     alpha = pow(\n           abs( snoise(vec3(angle, map(distance,0.,black_hole_distance,0.,5.) + 1.5*beat, -beat*0.25 )))\n           ,2.);\n           \n        if (alpha > cut_factor)\n        {\n           alpha = map(alpha, cut_factor, 1., 0., normal_distance * 6.);\n           color = snoise(vec3(_uv.x,_uv.y, normal_distance));\n           finalColor = hsv2rgb( vec3( color, normal_distance, alpha ));\n         }\n    } \n    s =  step(1., r) ; // empty core\n    s *= step(.35, abs(fth)*r ); // cones\n    \n   float samp = texture(iChannel1, vec2(ith, 0.5)).r;\n   s *= step(fract(4.*r*stripe_fact), stripe_width); // stripes\n   s *= step(1.35*r, floor( (1.5 + 8.*samp)*stripe_fact )/stripe_fact );\n\n   colo = vec3(s);\n   colo = s * hsv2rgb( vec3( ith, 1., (1.5-normal_distance )) );\n      \n      \n    vec2 uv4 = mainuv * scale - scale * 0.5;\n    uv4.x *= aspect;\n  \n    float mainval = 2.0;\n  \tfloat inverseLength = saturate( length( uv4 ) );\n        \n    float core = pow(mod(inverseLength - iTime * 0.1, 1.0),texture(iChannel1, vec2(0.05, 0)).x*2.0+.25) * rings;\n    float coreident = ceil( core );\n    \n    float colorIdent = fbm4( coreident, iTime * 0.1 );\n    float music = texture(iChannel1, vec2(1.0-coreident/rings, 0)).x;\n    music *= music;\n\n    vec2 rotatedUVs = uv4 * mm2( halfpi + fbm4( coreident * 0.1 , iTime*.3 + music/10.0) * pi * pi );\n    rotatedUVs *= mm2( halfpi - fbm4( coreident * 2.0 , iTime*.3 + music/10.0 ) * pi * pi );\n    float arc = (( pi + atan( rotatedUVs.y, rotatedUVs.x ) ) / halfpi)/pi;\n    float arcmod = abs(sin(  arc*colorIdent*colorIdent*100.0+music*music*1.0)) \n                 * abs(sin( -arc*colorIdent*colorIdent*100.0+music*music*1.0));\n    float arcpos = smoothstep( 0.2, 0.2025 - coreident * 0.0001, arcmod);\n   \n\n    mainval *= colorIdent * arcpos * music;\n        \n    float coresmooth = fract( core ) * fract( -core );\n  \tfloat corewidth  = fwidth( coresmooth );\n   \tfloat edgethreshold = 0.1;\n    mainval *= smoothstep( edgethreshold - corewidth, edgethreshold + corewidth, coresmooth );\n    finalval += mainval;\n \n    vec2 uv3 = normalizeCoord(U); \n    uv3.y = -uv3.y;\n    vec2 st = polarizeCoord(uv3); \n    st.x = mirrorAngle(st.x); \n    st.y = diskify(st.y); \n    \n    vec3 col2 = vec3(0);\n    float mask = myfunc(st, col2); \n    \n    float ra = arcmod;\n   \n    r = length(rotatedUVs);\n    max( finalval, 0.0 ) + 0.0025 * coresmooth;\n    finalval = min( finalval, r  );\n    float cc = r; //(r < 0.98) ? 1. : 0.;\n    float c2 = (r <= min(ra, ra * mainval)) ? 1. : 0.;\n   \n      \n    vec3 tint = palette(arc+iTime*.05,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n   \n    c = 1. - exp(-c*c*c);\n    \n    O =   vec4(c*c,1);\n    O = O + vec4( (max(1.-w,.2) * (.5 * finalColor) + aces_approx ( cc * (  (col2)  * 1.0-(1.0-tint)*.15))), 1.0 );\n\n               \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Fork of \"rayzy\" by pb. https://shadertoy.com/view/XfSyRG\n// 2024-11-04 21:30:39\n\n//philip.bertani@gmail.com\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n        uv = u/R;\n\n    O *= 0.;\n\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    //golfed by fabriceneyret2\n    for (int k; k < 25; k++)      \n        O += gk1s[k] * texture(iChannel0, uv + ( vec2(k%5,k/5) - 2. ) / R );\n}\n\n\n","name":"Buffer B","description":"","type":"buffer"}]}