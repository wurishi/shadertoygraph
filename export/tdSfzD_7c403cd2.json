{"ver":"0.1","info":{"id":"tdSfzD","date":"1589616142","viewed":180,"name":"Interactive Monte Carlo Pt.2","username":"fluxatron","description":"Pt3: https://www.shadertoy.com/view/wdjfRm\n\nStill a WIP. Thought I'd publish cuz it just looks damn cool :)\nThe black and white is actually a bug but i've left it here for style points.\n\nBased on Ray Tracing books by Peter Shirley","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","interactive","montecarlo","unbiased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl ////////////////////////////////////\nconst mat3 ACESInputMat  = mat3(0.59719, 0.07600, 0.02840,    0.35458, 0.90834, 0.13383,    0.04823,  0.01566, 0.83777);\nconst mat3 ACESOutputMat = mat3(1.60475,-0.10208,-0.00327,   -0.53108, 1.10813,-0.07276,   -0.07367, -0.00605, 1.07602);\nvec3 RRTAndODTFit(vec3 v) { return (v * (v + 0.0245786) - 0.000090537) / (v * (0.983729 * v + 0.4329510) + 0.238081); }\nvec3 ACESFitted(vec3 color) { return clamp(ACESOutputMat * RRTAndODTFit(ACESInputMat * color), 0.0, 1.0); }\n\n\nfloat DecodeFrame()\n{\n    return texelFetch(iChannel0, ivec2(0,0), 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec3 col = texture(iChannel0, uv).rgb / float(DecodeFrame()+1.); // Divide accumulation buffer by num frames\n    col = ACESFitted(col);\n    col = pow(col, vec3(0.4545)); // Gamma 1/2.2\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_BOUNCES 10\n#define SAMPLES_PER_PIXEL 8\n\nconst int _numSpheres = 5;\nSphere[_numSpheres] _spheres;\nvoid InitScene()\n{\n    vec3 v = vec3(.15,.5,.85);\n    \n    _spheres[0].Center = vec3(-1.2,0,0);\n    _spheres[0].Radius = 0.5;\n    _spheres[0].Mat.BaseColor = v.brr;\n    _spheres[0].Mat.IsMetal = true;\n    _spheres[0].Mat.Roughness = 0.03;\n    _spheres[0].Mat.Emissive = 0.;\n    \n\t_spheres[1].Center = vec3(0,0,0);\n    _spheres[1].Radius = 0.5;\n    _spheres[1].Mat.BaseColor = v.rbr;\n    _spheres[1].Mat.IsMetal = false;\n    _spheres[1].Mat.Roughness = 0.;\n    _spheres[1].Mat.Emissive = 0.;\n    \n    _spheres[2].Center = vec3(1.2,0,0);\n    _spheres[2].Radius = 0.5;\n    _spheres[2].Mat.BaseColor = v.rrb;\n    _spheres[2].Mat.IsMetal = true;\n    _spheres[2].Mat.Roughness = 0.03;\n    _spheres[2].Mat.Emissive = 0.;\n    \n    // Ground\n\t_spheres[3].Center = vec3(0,-100.5,0);\n    _spheres[3].Radius = 100.;\n    _spheres[3].Mat.BaseColor = v.ggg;\n    _spheres[3].Mat.IsMetal = false;\n    _spheres[3].Mat.Roughness = 0.1;\n    _spheres[3].Mat.Emissive = 0.;\n    \n    // Light    \n\t_spheres[4].Center = vec3(2.5);\n    _spheres[4].Radius = 1.;\n    _spheres[4].Mat.BaseColor = v.rbr;\n    _spheres[4].Mat.IsMetal = false;\n    _spheres[4].Mat.Roughness = 0.;\n    _spheres[4].Mat.Emissive = 10.;\n}\n\n\n// OTHER //////////////////////////////////////////////////////////////////////////////////\n    \nvec4 EncodeNumFramesAccumulated(float frame)\n{\n    return vec4(frame,0,0,0);\n}\n\nfloat DecodeNumFramesAccumulated()\n{\n    return texelFetch(iChannel0, ivec2(0,0), 0).r;\n}\n\nmat3 ViewMatrix(vec3 eye, vec3 target, float roll)\n{\n\tvec3 rollVec = vec3(sin(roll), cos(roll), 0.);\n\tvec3 w = normalize(eye-target); // right handed TODO Change all math to left handed? \n\tvec3 u = normalize(cross(w,rollVec));\n\tvec3 v = normalize(cross(u,w));\n    return mat3(u, v, w);\n}\n      \n\n// SCENE //////////////////////////////////////////////////////////////////////////////////\n           \nbool HitSphere(Sphere sph, Ray ray, float tMin, float tMax, inout Hit outHit)\n{\n    vec3 oc = ray.Origin - sph.Center;\n    \n    float a = dot(ray.Dir, ray.Dir);\n    float half_b = dot(oc, ray.Dir);\n    float c = dot(oc, oc) - sph.Radius*sph.Radius;\n    float discriminant = half_b*half_b - a*c;\n    \n    \n    if (discriminant > 0.) \n    {\n        float root = sqrt(discriminant);\n        float temp = (-half_b - root)/a;\n       \n        if (temp > tMin && temp < tMax) \n        {\n            outHit.LengthAlongRay = temp;\n            outHit.Pos = ray.Origin + ray.Dir*temp;\n            \n            //vec3 outwardNormal = (hit.Pos - sph.Center) / sph.Radius;\n            //hit.IsFrontFace = dot(outwardNormal, ray.Dir) < 0.;\n            //hit.Normal = hit.IsFrontFace ? outwardNormal : -outwardNormal;\n            outHit.Normal = (outHit.Pos - sph.Center) / sph.Radius;\n            outHit.Mat = sph.Mat;\n        \treturn true;\n        }\n        \n        temp = (-half_b + root)/a;\n        if (temp > tMin && temp < tMax)\n        { \n            outHit.LengthAlongRay = temp;\n            outHit.Pos = ray.Origin + ray.Dir*temp;\n            \n            //vec3 outwardNormal = (hit.Pos - sph.Center) / sph.Radius;\n            //hit.IsFrontFace = dot(outwardNormal, ray.Dir) < 0.;\n            //hit.Normal = hit.IsFrontFace ? outwardNormal : -outwardNormal;\n            outHit.Normal = (outHit.Pos - sph.Center) / sph.Radius;\n            outHit.Mat = sph.Mat;\n        \treturn true;\n        }\n    }\n    \n    return false;\n}\n\nbool FindClosestHit(Ray ray, inout Hit outHit)\n{\n    float tMin = 0.0001;\n    float closestSoFar = BIG_FLOAT;\n    \n    bool hitAnything = false;\n\n    Hit tempHit;\n    for (int i = 0; i < _numSpheres; i++)\n    {\n        Sphere sph = _spheres[i];\n        if (HitSphere(sph, ray, tMin, closestSoFar, tempHit))\n        {\n\t\t\thitAnything = true;\n            closestSoFar = tempHit.LengthAlongRay;\n            outHit = tempHit;\n        }\n    }\n    \n    return hitAnything;\n}\n\nvec3 Color(Ray ray, vec2 uv, float sa)\n{\n    const float epsilon = 0.001;\n    \n\tvec3 attenuation = vec3(1);\n\tvec3 emitted = vec3(0);\n    Hit hit;\n    \n    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++)\n    {\n\t\tif (FindClosestHit(ray, hit))\n        {\n            // Update the ray for next bounch\n        \tray.Origin = hit.Pos + hit.Normal * epsilon; // Slightly off the hit surface\n            float raySeed = sa + 7.1*float(iFrame) + 5681.123 + float(bounce)*92.13;\n        \t\n           \t\n            float roughness = hit.Mat.Roughness;\n            bool isMetal = hit.Mat.IsMetal;\n            \n            if (isMetal)\n            {\n                ray.Dir = reflect(ray.Dir, hit.Normal) + roughness*RandomInUnitSphere(raySeed+17.1321);\n            }\n            else // lambertian\n            {\n                ray.Dir = hit.Normal + RandomUnitVector(raySeed);\n            }\n            \n            ray.Dir = normalize(ray.Dir); // not 100% if i need to normalize for correct results, but it gives me peace of mind for now.\n            \n            attenuation *= hit.Mat.BaseColor;\n            \n               \n            if (hit.Mat.Emissive > epsilon)\n            {\n            \temitted += vec3(hit.Mat.Emissive); // this part is buggy. this image shoudl actually be coloured :)\n                return attenuation + emitted;\n            }\n           // col += hit.Mat.Emissive;\n        }\n        else\n        {\n            // Sky colour and leave\n            //col *= 1.*mix(vec3(1.), vec3(.5,.7,1.), 0.5*uv.y + .5);\n            attenuation *= vec3(0.0);\n            //col *= vec3(1);\n            break;\n        }\n    }\n    \n    return attenuation + emitted;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 oldCol = vec3(0);\n    \n    // HandleState\n    {\n        float numFramesAccumulated = DecodeNumFramesAccumulated();\n        oldCol = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;       \n        \n        if(iFrame == 0 || numFramesAccumulated < 1.) \n        {\n            oldCol = vec3(0,0,0);\n        }\n\n        // Track accumulated frames\n        if (ivec2(fragCoord) == ivec2(0,0))\n        {\n            numFramesAccumulated++;\n\n             // Get mouse state\n            bool mousePressed = iMouse.z > 0.0;\n            if (mousePressed)\n            {\n            \tnumFramesAccumulated = 0.;\n            }\n\n            fragColor = EncodeNumFramesAccumulated(numFramesAccumulated);\n            return;\n        }\n    }\n \n    \n    float aspect = iResolution.x / iResolution.y;\n    //vec2 uv = (2.*(fragCoord) - iResolution.xy) / iResolution.yy; // -(aspect,1) -> (aspect,1)\n    vec2 uvNorm = (fragCoord) / iResolution.xy;                   //       (0,0) -> (1,1)\n\tvec2 m = (2.*iMouse.xy - iResolution.xy) / iResolution.yy;    // -(aspect,1) -> (aspect,1)\n    \n    InitScene();\n    \n    vec3 newCol = vec3(0);\n    for (int sampleId = 0; sampleId < SAMPLES_PER_PIXEL; sampleId++)\n    {\n\n    \tfloat sa = hash11( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*hash11(float(iFrame*sampleId)) );\n    \n        // Camera ray\n        Ray ray;\n        {\n            // Define ray vector in the image plane\n            vec2 pixelOffset = hash21(sa+13.271) / iResolution.xy;\n            float fovFactor = 2.;\n            float zoom = 3.;\n            float horizontal = fovFactor*aspect;\n            float vertical = fovFactor;\n            vec3 lowerLeftCorner = -vec3(horizontal/2., vertical/2., zoom);\n            vec3 lensRay = normalize(lowerLeftCorner + vec3((uvNorm.x+pixelOffset.x)*horizontal, (uvNorm.y+pixelOffset.x)*vertical, 0.));\n\n\n            float camDist = 4.;\n            ray.Origin = camDist * vec3(-sin(m.x*PI), smoothstep(0.,2.,clamp(2.*m.y + 1.,0.,2.)), -cos(m.x*PI));\n            ray.Dir = ViewMatrix(ray.Origin, vec3(0), 0.) * lensRay;\n        }\n\n \n    \tnewCol += Color(ray, uvNorm, sa);\n    }\n    newCol /= float(SAMPLES_PER_PIXEL);\n    \n    \n    fragColor = vec4(oldCol + newCol, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BIG_FLOAT 9999999.\n#define PI 3.1415926\n#define TAU 6.2831853\n\n// TYPES //////////////////////////////////////////////////////////////////////////////////\n\nstruct Material\n{\n    vec3 BaseColor; // IsMetal ? Reflectance : Albedo\n\tbool IsMetal;\n    float Roughness;\n    float Emissive;\n};\nstruct Sphere\n{\n    vec3 Center;\n    float Radius;\n    Material Mat;\n};\nstruct Ray \n{\n    vec3 Origin;\n    vec3 Dir;\n};\nstruct Hit \n{\n    vec3 Pos; // point in space\n    vec3 Normal; // normal of hit surface\n    float LengthAlongRay; // length along ray of hit\n   //bool IsFrontFace; // whether we hit the outside or inside of the surface\n    //int MatId;\n    Material Mat;\n    //bool IsMetal;\n    //bool BaseColor; // IsMetal ? Reflectance : Albedo\n};\n    \n// RANDOM /////////////////////////////////////////////////////////////////////////////////\n\n// 1 out, 1 in... https://www.shadertoy.com/view/4djSRW\nfloat hash11(float seed)\n{\n    seed = fract(seed * .1031);\n    seed *= seed + 33.33;\n    seed *= seed + seed;\n    return fract(seed);\n}\n//  1 out, 2 in...  https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 seed)\n{\n\tvec3 p3  = fract(vec3(seed.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// 2 out, 1 in... https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float seed)\n{\n\tvec3 p3 = fract(vec3(seed) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 RandomUnitVector(float seed) \n{\n    vec2 rand = hash21(seed);\n    float a = rand.x*TAU;     //  0 to TAU\n    float z = rand.y*2. - 1.; // -1 to 1\n    float r = sqrt(1. - z*z);\n    return vec3(r*cos(a), r*sin(a), z);\n}\n\nvec3 RandomInUnitSphere(float seed)\n{\n    vec3 hash = hash31(seed);\n    \n    float theta = hash.x * TAU;\n    float v = hash.y;\n    float r = pow(hash.z, 0.333333);\n    \n    float phi = acos((2.*v)-1.);\n    float sinphi = sin(phi);\n    \n    vec3 p;\n    p.x = r * sinphi * cos(theta);\n    p.y = r * sinphi * sin(theta);\n    p.z = r * cos(phi); \n    \n    return p;\n}\n\nvec3 RandomInHemisphere(float seed, vec3 normal) \n{\n    vec3 p = RandomInUnitSphere(seed);\n    return (dot(p, normal) > 0.0) ? p : -p;\n}\n","name":"Common","description":"","type":"common"}]}