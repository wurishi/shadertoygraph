{"ver":"0.1","info":{"id":"csSXWw","date":"1670352123","viewed":331,"name":"chat-gpt's raymarching","username":"01000001","description":"this shader was created by chatGPT based on a simple prompt input.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//RAW CODE AND PROMPT CAN BE FOUND IN THE COMMON TAB\n\n\n#define MAX_STEPS 100\n#define MAX_DISTANCE 5.0\n#define SPHERE_RADIUS 0.5\n#define SPHERE_POSITION vec3(0.0, 0.0, 0.0)\n\n// Calculates the distance to a sphere\nfloat distanceToSphere(vec3 p, vec3 c, float r) {\n  return length(p - c) - r;\n}\n\n// Calculates the normal vector for a sphere at a given point\nvec3 normalForSphere(vec3 p, vec3 c, float r) {\n  return normalize(p - c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Calculate the ray direction based on the current pixel\n  vec2 uv = (fragCoord.xy / iResolution.x) - vec2(0.5);\n  //original uv coordinates:   vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec3 ray = normalize(vec3(uv.xy, -1.0));\n  \n              //////////////////////\n              //declaring some variables missing from the raw output\n              vec3 cameraPosition = vec3(0, 0.5, 2);\n              vec3 lightDirection = normalize(vec3(1, 1, -1));\n              ////////////////////////\n  \n\n  // Set the initial distance to the maximum distance\n  float distance = MAX_DISTANCE;\n\n  // Perform raymarching\n  for (int i = 0; i < MAX_STEPS; i++) {\n    // Calculate the current position\n    vec3 p = cameraPosition + ray * distance;\n\n    // Calculate the distance to the sphere\n    float d = distanceToSphere(p, SPHERE_POSITION, SPHERE_RADIUS);\n\n    // If the distance is less than the threshold, we have found the surface\n    if (d < 0.001) {\n      // Calculate the surface normal\n      vec3 n = normalForSphere(p, SPHERE_POSITION, SPHERE_RADIUS);\n\n      // Calculate the diffuse lighting\n      float diffuse = dot(lightDirection, n);\n\n      // Set the fragment color\n      fragColor = vec4(vec3(diffuse), 1.0);\n      return;\n    }\n\n    // Update the distance\n    distance -= d;\n\n    // If the distance is greater than the maximum distance, break\n    if (distance > MAX_DISTANCE) {\n      break;\n    }\n  }\n\n  // If the ray did not hit the sphere, set the fragment color to black\n  fragColor = vec4(0.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/*\n\n//PROMPT: write a raymarching algorithm in glsl that renders a sphere with shading\n\n//THE CODE IN THIS BLOCK COMMENT IS THE RAW CODE COPIED FROM CHAT GPT\n\n\n#define MAX_STEPS 100\n#define MAX_DISTANCE 5.0\n#define SPHERE_RADIUS 0.5\n#define SPHERE_POSITION vec3(0.0, 0.0, 0.0)\n\nvoid main() {\n  // Calculate the ray direction based on the current pixel\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  vec3 ray = normalize(vec3(uv.xy, -1.0));\n\n  // Set the initial distance to the maximum distance\n  float distance = MAX_DISTANCE;\n\n  // Perform raymarching\n  for (int i = 0; i < MAX_STEPS; i++) {\n    // Calculate the current position\n    vec3 p = cameraPosition + ray * distance;\n\n    // Calculate the distance to the sphere\n    float d = distanceToSphere(p, SPHERE_POSITION, SPHERE_RADIUS);\n\n    // If the distance is less than the threshold, we have found the surface\n    if (d < 0.001) {\n      // Calculate the surface normal\n      vec3 n = normalForSphere(p, SPHERE_POSITION, SPHERE_RADIUS);\n\n      // Calculate the diffuse lighting\n      float diffuse = dot(lightDirection, n);\n\n      // Set the fragment color\n      gl_FragColor = vec4(vec3(diffuse), 1.0);\n      return;\n    }\n\n    // Update the distance\n    distance -= d;\n\n    // If the distance is greater than the maximum distance, break\n    if (distance > MAX_DISTANCE) {\n      break;\n    }\n  }\n\n  // If the ray did not hit the sphere, set the fragment color to black\n  gl_FragColor = vec4(0.0);\n}\n\n// Calculates the distance to a sphere\nfloat distanceToSphere(vec3 p, vec3 c, float r) {\n  return length(p - c) - r;\n}\n\n// Calculates the normal vector for a sphere at a given point\nvec3 normalForSphere(vec3 p, vec3 c, float r) {\n  return normalize(p - c);\n}\n*/","name":"Common","description":"","type":"common"}]}