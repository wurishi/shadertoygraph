{"ver":"0.1","info":{"id":"MfcyzB","date":"1730913750","viewed":99,"name":"Cubemap Gore","username":"vladdoc","description":"Sunset with stars","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["procedural","gradient","cubemap"],"hasliked":0,"parentid":"XXBcDV","parentname":"Sunset with stars"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat random1( vec2 p )\n{\n    const vec2 r = vec2(23.14069263277926,2.665144142690225);\n    return fract( cos( mod( 123456789., 256. * dot(p,r) ) ) );\n}\n\nfloat random2(in vec2 xy, in float seed){\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n#define SEED  2.0\n#define SEED2 123411.0\n#define SEED3 43758.5453\n\nfloat random3(vec3 x) {\n    return fract(sin(x.x + x.y * 57.0 + x.z * 113.0) * SEED3);\n}\n\nvec4 StarColor(in vec2 frag)\n{\n\n    uint kek = floatBitsToUint(iTime);\n    kek = kek & 255u;\n    float fkek = float(kek);\n    return vec4(\n        max(random2(frag, fkek), 0.6),\n        max(random2(frag, fkek + 1.0), 0.6), \n        max(random2(frag, fkek + 2.0), 0.6), \n        0.8);\n}\n\nvec4 StarSample(in vec3 dir, in vec2 fragCoord)\n{\n    //fragCoord /= 2.0;\n    vec2 uv = DirToUV(dir);\n    uv *= fragCoord;\n    uv = floor(uv / 16.0) * 16.0;\n    uv /= fragCoord;\n    \n    vec2 dd = vec2(\n        dFdx(fragCoord.x),\n        dFdy(fragCoord.y)\n    );\n    \n    vec2 uv1 = vec2(\n        uv.x + dd.x,\n        uv.y\n    );\n    \n    vec2 uv2 = vec2(\n        uv.x,\n        uv.y + dd.y\n    );\n    \n    vec2 uv3 = vec2(\n        uv.x + dd.x,\n        uv.y + dd.y\n    );\n\n    float cubemapRes = iResolution.x / 2.0;\n\n    vec3 lowresDir = SetDirRes(dir, cubemapRes);\n\n    vec4 hasStars = vec4(\n        random3 (lowresDir),\n        random3 (lowresDir + vec3(uv1, 0)),\n        random3 (lowresDir + vec3(uv2, 0)),\n        random3 (lowresDir + vec3(uv3, 0))\n    );\n    \n    const float threshold = 0.995;\n\n    \n    vec4 starColor = StarColor(fragCoord);\n    vec4 halfColor = starColor / 2.0;\n    \n    vec4 colors[4];\n    colors[0] = hasStars[0] > threshold ? starColor : halfColor;\n    colors[1] = hasStars[1] > threshold ? starColor : halfColor;\n    colors[2] = hasStars[2] > threshold ? starColor : halfColor;\n    colors[3] = hasStars[3] > threshold ? starColor : halfColor;\n    \n    vec4 outc = colors[0];\n    outc = mix(outc, colors[1], 0.5);\n    outc = mix(outc, colors[2], 0.5);\n    outc = mix(outc, colors[3], 0.5);\n\n    //return hasStars[0] > threshold ? outc : vec4(0);\n    \n    \n    if(hasStars[0] > threshold) \n    //if(dot(hasStars, vec4(1, 1, 1, 1)) > 3.5) \n        return StarColor(fragCoord);\n    else\n        return vec4(0);\n}\n\nvec4 StarSampleOld(in vec2 fragCoord)\n{\n   bool hasStar = random1(fragCoord) > 0.99999;\n\n   if(hasStar) \n       return StarColor(fragCoord);\n   else \n       return vec4(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uvClip = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0; // <-1.0,1.0>\n    \n    vec3 ro = vec3(0, 0, 0);\n    \n    vec3 rd = GetDir(uvClip, mouse);\n\n    float deltaTime = min(iTime * 0.004, 1.0);\n\n    vec4 orange = vec4(1, 0.33, 0.0, 1.0) - deltaTime * 0.2;\n    vec4 darkblue = vec4(0, 0, 0.5, 1.0) - deltaTime;\n    \n    float planetRoundness = (cos(UVToRadians(uv.x)) * 0.1);\n    \n    float vertical_shift = rd.y - planetRoundness;\n    \n    float more_blue = 0.3;\n    \n    float sunset_offset = min(vertical_shift + more_blue + deltaTime * 2.0, 1.0);\n    \n    // gradient that changes over time simulating the sunset\n    vec4 col = mix(orange, darkblue, sunset_offset);\n    \n    vec4 star = StarSample(rd, fragCoord);\n    //vec4 star = texture(iChannel2, rd);\n    vec4 pixel = texture(iChannel1, rd);\n    \n    col = mix(col, pixel, 0.5);\n    \n    if(luma(pixel) > 0.9) \n        col = mix(col, star, star.w);\n    \n\n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626433832795\n#define TAU 6.2831853071795864\n#define PI_DIV_2 (PI * 0.5)\n\n#define HFOV (PI * 0.7)\n\nfloat ClipToUV(in float clip)\n{\n    return (clip + 1.0) * 0.5; \n}\n\nvec2 ClipToUV(in vec2 clip)\n{\n    return vec2(\n       (clip.x + 1.0) * 0.5,\n       (clip.x + 1.0) * 0.5\n    );\n}\n\nfloat UVToClip(in float uv)\n{\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nvec2 UVToClip(in vec2 uv)\n{\n    uv.x = uv.x * 2.0 - 1.0;\n    uv.y = uv.y * 2.0 - 1.0;\n    return uv;\n}\n\nfloat UVToRadians(in float x)\n{\n    return (HFOV * 0.5) * UVToClip(x);\n}\n\nvec2 Rotate2D(in vec2 uv, in float angle) \n{ \n    float sin = sin(angle);\n    float cos = cos(angle);\n    \n    return uv * mat2(\n        +cos, +sin,\n        -sin, +cos\n    );\n}\n\nvec2 Rotate2DByDegree(vec2 uv, float angle) {\n \n    angle = radians(angle);\n    return Rotate2D(uv, angle);\n}\n\n// FPS camera\nvec3 GetDir(in vec2 uv, in vec2 mouse)\n{\n    vec3 rd = vec3(uv, 1.);\n    \n    rd.yz = Rotate2D(rd.yz, PI_DIV_2 * mouse.y);\n    rd.xz = Rotate2D(rd.xz, PI * mouse.x);\n    \n    return normalize(rd);\n}\n\nfloat luma(in vec3 color) \n{\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat luma(in vec4 color) \n{\n    return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nvec2 DirToUV(vec3 dir)\n{\n    return vec2(\n        (atan(dir.x, dir.z) / TAU) + 0.5,\n        (asin(dir.y) / PI) + 0.5\n    );\n}\n\nvec3 RandomSpherePoint(vec3 rand) {\n  float ang1 = (rand.x + 1.0) * PI; // [-1..1) -> [0..2*PI)\n  float u = rand.y; // [-1..1), cos and acos(2v-1) cancel each other out, so we arrive at [-1..1)\n  float u2 = u * u;\n  float sqrt1MinusU2 = sqrt(1.0 - u2);\n  float x = sqrt1MinusU2 * cos(ang1);\n  float y = sqrt1MinusU2 * sin(ang1);\n  float z = u;\n  return vec3(x, y, z);\n}\n\n\nbool EpsilonEqual(float a, float b, float epsilon)\n{\n    return abs(a - b) < epsilon;\n}\n\nbool EpsilonEqual(vec2 a, vec2 b, float epsilon)\n{\n    return EpsilonEqual(a.x, b.x, epsilon) &&\n           EpsilonEqual(a.y, b.y, epsilon);\n}\nbool EpsilonEqual(vec3 a, vec3 b, float epsilon)\n{\n    return EpsilonEqual(a.x, b.x, epsilon) &&\n           EpsilonEqual(a.y, b.y, epsilon) &&\n           EpsilonEqual(a.z, b.z, epsilon);\n}\n\nbool EpsilonEqual(vec4 a, vec4 b, float epsilon)\n{\n    return EpsilonEqual(a.x, b.x, epsilon) &&\n           EpsilonEqual(a.y, b.y, epsilon) &&\n           EpsilonEqual(a.z, b.z, epsilon) &&\n           EpsilonEqual(a.w, b.w, epsilon);\n}\n\nfloat max3(vec3 p) \n{\n   return max(max(p.x, p.y), p.z);\n}\n\nfloat fprecision(float x, float samples)\n{\n    return round(x * samples) / samples;\n}\n\nvec2 fprecision(vec2 v, float samples)\n{\n    return vec2(\n        fprecision(v.x, samples),\n        fprecision(v.y, samples)\n    );\n}\n\nvec3 fprecision(vec3 v, float samples)\n{\n    return vec3(\n        fprecision(v.x, samples),\n        fprecision(v.y, samples),\n        fprecision(v.z, samples)\n    );\n}\n\nvec3 SetDirRes(vec3 v, float res)\n{\n    return normalize(fprecision(v, res));\n}\n\n// Cubemap code\n/*\nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat random1( vec2 p )\n{\n    const vec2 r = vec2(23.14069263277926,2.665144142690225);\n    return fract( cos( mod( 123456789., 256. * dot(p,r) ) ) );\n}\n\nfloat random2(in vec2 xy, in float seed){\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n#define SEED  2.0\n#define SEED2 123411.0\n#define SEED3 43758.5453\n\nfloat random3(vec3 x) {\n    return fract(sin(x.x + x.y * 57.0 + x.z * 113.0) * SEED3);\n}\n\nvec4 StarColor(in vec2 frag)\n{\n\n    uint kek = floatBitsToUint(iTime);\n    kek = kek & 255u;\n    float fkek = float(kek);\n    return vec4(\n        max(random2(frag, fkek), 0.6),\n        max(random2(frag, fkek + 1.0), 0.6), \n        max(random2(frag, fkek + 2.0), 0.6), \n        0.8);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    vec2 uv = DirToUV(rayDir);\n    uv *= fragCoord;\n\n    bool hasStar = random2(uv, SEED) > 0.998;\n\n    if(hasStar) fragColor = StarColor(fragCoord);\n    else fragColor = vec4(0);\n}\n*/\n\n","name":"Common","description":"","type":"common"}]}