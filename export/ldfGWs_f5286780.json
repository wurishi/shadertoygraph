{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//\tCreative Commons CC0 1.0 Universal (CC-0)\n//\t\n//\tarea lights based on Brian Karis's Siggraph 2013 presentation\n//\thttp://blog.selfshadow.com/publications/s2013-shading-course/\n//\t\n//\tkind of pointless for a ray marched scene, but they work with rasterized stuff too.\n//\tI still need to do attenuation and some noodling. comments too, though everything's\n//\tin the course notes at the site above for anyone interested.\n//\t\n//\traymarching code and anything else that looks well written courtesy of iq.\n//\t\n//\t~bj.2013\n\n//#define DISABLE_ALBEDO\n//#define DISABLE_NORMALS\n//#define DISABLE_ROUGHNESS\n\nfloat sphereRad;\nvec3 spherePos;\nfloat tubeRad;\nvec3 tubeStart;\nvec3 tubeEnd;\n\nfloat specTrowbridgeReitz( float HoN, float a, float aP )\n{\n\tfloat a2 = a * a;\n\tfloat aP2 = aP * aP;\n\treturn ( a2 * aP2 ) / pow( HoN * HoN * ( a2 - 1.0 ) + 1.0, 2.0 );\n}\n\nfloat visSchlickSmithMod( float NoL, float NoV, float r )\n{\n\tfloat k = pow( r * 0.5 + 0.5, 2.0 ) * 0.5;\n\tfloat l = NoL * ( 1.0 - k ) + k;\n\tfloat v = NoV * ( 1.0 - k ) + k;\n\treturn 1.0 / ( 4.0 * l * v );\n}\n\nfloat fresSchlickSmith( float HoV, float f0 )\n{\n\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - HoV, 5.0 );\n}\n\nfloat sphereLight( vec3 pos, vec3 N, vec3 V, vec3 r, float f0, float roughness, float NoV, out float NoL )\n{\n\tvec3 L\t\t\t\t= spherePos - pos;\n\tvec3 centerToRay\t= dot( L, r ) * r - L;\n\tvec3 closestPoint\t= L + centerToRay * clamp( sphereRad / length( centerToRay ), 0.0, 1.0 );\t\n\tvec3 l\t\t\t\t= normalize( closestPoint );\n\tvec3 h\t\t\t\t= normalize( V + l );\n\t\n\tNoL\t\t\t\t= clamp( dot( N, l ), 0.0, 1.0 );\n\tfloat HoN\t\t= clamp( dot( h, N ), 0.0, 1.0 );\n\tfloat HoV\t\t= dot( h, V );\n\t\n\tfloat distL\t\t= length( L );\n\tfloat alpha\t\t= roughness * roughness;\n\tfloat alphaPrime\t= clamp( sphereRad / ( distL * 2.0 ) + alpha, 0.0, 1.0 );\n\t\n\tfloat specD\t\t= specTrowbridgeReitz( HoN, alpha, alphaPrime );\n\tfloat specF\t\t= fresSchlickSmith( HoV, f0 );\n\tfloat specV\t\t= visSchlickSmithMod( NoL, NoV, roughness );\n\t\n\treturn specD * specF * specV * NoL;\n}\n\nfloat tubeLight( vec3 pos, vec3 N, vec3 V, vec3 r, float f0, float roughness, float NoV, out float NoL )\n{\n\tvec3 L0\t\t\t= tubeStart - pos;\n\tvec3 L1\t\t\t= tubeEnd - pos;\n\tfloat distL0\t= length( L0 );\n\tfloat distL1\t= length( L1 );\n\t\n\tfloat NoL0\t\t= dot( L0, N ) / ( 2.0 * distL0 );\n\tfloat NoL1\t\t= dot( L1, N ) / ( 2.0 * distL1 );\n\tNoL\t\t\t\t= ( 2.0 * clamp( NoL0 + NoL1, 0.0, 1.0 ) ) \n\t\t\t\t\t/ ( distL0 * distL1 + dot( L0, L1 ) + 2.0 );\n\t\n\tvec3 Ld\t\t\t= L1 - L0;\n\tfloat RoL0\t\t= dot( r, L0 );\n\tfloat RoLd\t\t= dot( r, Ld );\n\tfloat L0oLd \t= dot( L0, Ld );\n\tfloat distLd\t= length( Ld );\n\tfloat t\t\t\t= ( RoL0 * RoLd - L0oLd ) \n\t\t\t\t\t/ ( distLd * distLd - RoLd * RoLd );\n\t\n\tvec3 closestPoint\t= L0 + Ld * clamp( t, 0.0, 1.0 );\n\tvec3 centerToRay\t= dot( closestPoint, r ) * r - closestPoint;\n\tclosestPoint\t\t= closestPoint + centerToRay * clamp( tubeRad / length( centerToRay ), 0.0, 1.0 );\n\tvec3 l\t\t\t\t= normalize( closestPoint );\n\tvec3 h\t\t\t\t= normalize( V + l );\n\t\n\tfloat HoN\t\t= clamp( dot( h, N ), 0.0, 1.0 );\n\tfloat HoV\t\t= dot( h, V );\n\t\n\tfloat distLight\t= length( closestPoint );\n\tfloat alpha\t\t= roughness * roughness;\n\tfloat alphaPrime\t= clamp( tubeRad / ( distLight * 2.0 ) + alpha, 0.0, 1.0 );\n\t\n\tfloat specD\t\t= specTrowbridgeReitz( HoN, alpha, alphaPrime );\n\tfloat specF\t\t= fresSchlickSmith( HoV, f0 );\n\tfloat specV\t\t= visSchlickSmithMod( NoL, NoV, roughness );\n\t\n\treturn specD * specF * specV * NoL;\n}\n\nvec3 areaLights( vec3 pos, vec3 nor, vec3 rd )\n{\n\tfloat noise\t\t=  texture( iChannel1, pos.xz ).x * 0.5;\n\tnoise\t\t\t+= texture( iChannel1, pos.xz * 0.5 ).y;\n\tnoise\t\t\t+= texture( iChannel1, pos.xz * 0.25 ).z * 2.0;\n\tnoise\t\t\t+= texture( iChannel1, pos.xz * 0.125 ).w * 4.0;\n\t\n\tvec3 albedo\t\t= pow( texture( iChannel0, pos.xz ).xyz, vec3( 2.2 ) );\n\talbedo\t\t\t= mix( albedo, albedo * 1.3, noise * 0.35 - 1.0 );\n\tfloat roughness = 0.7 - clamp( 0.5 - dot( albedo, albedo ), 0.05, 0.95 );\n\tfloat f0\t\t= 0.3;\n\t\n\t#ifdef DISABLE_ALBEDO\n\talbedo\t\t\t= vec3(0.1);\n\t#endif\n\t\n\t#ifdef DISABLE_ROUGHNESS\n\troughness\t\t= 0.05;\n\t#endif\n\t\n\tvec3 v\t\t\t= -normalize( rd );\n\tfloat NoV\t\t= clamp( dot( nor, v ), 0.0, 1.0 );\n\tvec3 r\t\t\t= reflect( -v, nor );\n\t\n\tfloat NdotLSphere;\n\tfloat specSph\t= sphereLight( pos, nor, v, r, f0, roughness, NoV, NdotLSphere );\n\t\n\tfloat NdotLTube;\n\tfloat specTube\t= tubeLight( pos, nor, v, r, f0, roughness, NoV, NdotLTube );\n\t\n\tvec3 color\t\t= albedo * 0.3183 * ( NdotLSphere + NdotLTube ) + specSph + specTube;\n\treturn pow( color, vec3( 1.0 / 2.2 ) );\n}\n\nvec3 rotYaw( vec3 v, float a )\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn v * mat3( c, 0,-s,\t0, 1, 0,\ts, 0, c );\n}\n\nvec3 rotPitch( vec3 v, float a )\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn v * mat3( 1, 0, 0,\t0, c,-s,\t0, s, c );\n}\n\nvoid updateLights()\n{\n\tsphereRad\t\t= cos( iTime * 0.3 ) * 0.025 + 0.05;\n\tspherePos\t\t= vec3( sin( iTime * 0.25 ), abs( cos( iTime ) * 0.25 ) + sphereRad, 0.0 );\n\t\n\ttubeRad\t\t\t= sin( iTime * 0.1 ) * 0.005 + 0.01;\n\tvec3 tubePos\t= vec3( 0.0, sin( iTime * 0.3 ) * 0.1 + 0.2, cos( iTime * 0.25 ) );\t\n\n\tvec3 tubeVec\t= rotPitch(rotYaw(vec3(0,0,0.2), iTime*-1.5 ), cos( iTime*0.5 ) * 0.3 );\n\t\n\ttubeStart\t\t= tubePos + tubeVec;\n\ttubeEnd\t\t\t= tubePos - tubeVec;\n}\n\n//--------------------------------------------------------------------------\n//\teverything below here is based on iq's Raymarching - Primitives shader\t\n//\thttps://www.shadertoy.com/view/Xds3zN\n//\t\n//--------------------------------------------------------------------------\n\n\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: https://iquilezles.org/articles/distfunctions\n\n\nvec2 map( in vec3 pos )\n{\n\tvec2 sphere\t\t= vec2( length( pos - spherePos ) - sphereRad, 2.0 );\n\n\tvec3 pa\t\t\t= pos - tubeStart;\n\tvec3 ba\t\t\t= tubeEnd - tubeStart;\n\tvec2 tube\t\t= vec2( length( pa - ba * clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 ) ) - tubeRad, 2.0 );\n\tfloat bump\t\t= 0.0;\n\t\n\t#ifndef DISABLE_NORMALS\n\tbump\t\t\t= texture( iChannel0, pos.xz * 6.0 ).x * 0.002;\n\t#endif\n\t\n\tvec2 res\t\t= vec2( pos.y + bump, 1.0 );\n\tres\t\t\t\t= ( res.x < sphere.x ) ? res : sphere;\n\tres\t\t\t\t= ( res.x < tube.x ) ? res : tube;\n\t\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd,20.0);\n    if( res.y>-0.5 )\n    {\n\t\tif( res.y == 2.0 )\n\t\t\treturn vec3(1);\n\n        vec3 pos = ro + res.x * rd;\n        vec3 nor = calcNormal( pos );\n\n\t\tcol = areaLights( pos, nor, rd );\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\tfloat time = 15.0 + iTime*0.1;\n\tvec3 ro = vec3(1.2*cos(time),0.3+0.2*cos(time),1.2*sin(time));\n\tvec3 ta = vec3(0,0,0);\n\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\t\n\tupdateLights();\n    vec3 col = render( ro, rd );\n\n\tfragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldfGWs","date":"1381667687","viewed":9384,"name":"Area lights","username":"ben","description":"my first shader. yay!  I have no idea what I'm doing. yaaay!\n\narea lights with glossy reflections and approximate energy conservation from Brian Karis's Siggraph talk. I'm not sure I've done the tube correctly. or the sphere. or anything else.","likes":122,"published":1,"flags":0,"usePreview":0,"tags":["lighting"],"hasliked":0,"parentid":"","parentname":""}}