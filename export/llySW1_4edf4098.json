{"ver":"0.1","info":{"id":"llySW1","date":"1484966034","viewed":10738,"name":"accelerated ray marching","username":"nshelton","description":"accelerated sphere tracing ?? is it any faster??? see \"omega\" variable\n\nmarching loop implements the optimization here : http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf","likes":57,"published":1,"flags":0,"usePreview":0,"tags":["sphere","tracing","accelerated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define MAX_ITER 20\n#define MAX_ITER 50\n\n// palettes from https://www.shadertoy.com/view/XtGGzG\nvec3 magma_quintic( float x )\n{\n\tx = clamp( x, 0.0, 1.0);\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( -0.023226960, +1.087154378, -0.109964741, +6.333665763 ) ) + dot( x2.xy, vec2( -11.640596589, +5.337625354 ) ),\n\t\tdot( x1.xyzw, vec4( +0.010680993, +0.176613780, +1.638227448, -6.743522237 ) ) + dot( x2.xy, vec2( +11.426396979, -5.523236379 ) ),\n\t\tdot( x1.xyzw, vec4( -0.008260782, +2.244286052, +3.005587601, -24.279769818 ) ) + dot( x2.xy, vec2( +32.484310068, -12.688259703 ) ) );\n}\n\nvec3 plasma_quintic( float x )\n{\n\tx = clamp( x, 0.0, 1.0);\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),\n\t\tdot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),\n\t\tdot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat3 ir;\n\nfloat DE(vec3 p) {                  \n\tvec3 p_o = p;\n    float d = 1e10;\n    float s = 1.;\n    vec3 t = vec3(0.1 + 0.2 * iMouse.xy/iResolution.xy, 0.1 + 0.1 * sin(iTime/200.));\n    vec3 dim = vec3(0.01, 0.9, 0.02);\n    for ( int i = 0; i < 10; i ++)\n    {\n        p -= t*s;\n        p = (ir * (p-t/s));\n     \td = min\t(d, sdBox(p*s, dim/s  )/s ) ;\n \t\tp = abs(p);\n        float circleSize = 0.03 * (sin(iTime + length(p_o) * 5.) ) + 0.01;\n        d = min(d, length(p - t) - circleSize/s);\n        s *= s;\n    }\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    vec3 cam = vec3(0,0, -3.);\n    vec3 ray = normalize( vec3(uv, 1.0));\n    \n    vec3 color = vec3(0.1, 0.1, 0.1);\n    vec3 p;\n    float depth = 0.1;\n    bool hit = false;\n    float iter = 0.0;\n    \n    float fog = 0.0;\n    vec3 sun = normalize( vec3(1,1,1));\n\n    ir = rotationMatrix(normalize(vec3(sin(iTime/50.0),sin(iTime/100.0),sin(iTime/150.0))), 1.5 + iTime/30.0);\n    \n    mat3 mv = rotationMatrix(vec3(0,1,0), iTime/10.0);\n        \n    cam = mv * cam;\n    ray = mv * ray;\n    \n    float t_min = 0.4;\n    float t_max = 5.0;\n    \n    float omega = 2.0;\n    float stepLength = 0.0;\n    float t = t_min;\n\tfloat candidate_error = 100.0;\n\tfloat candidate_t = t_min;\n\tfloat previousRadius = 0.0;\n    \n    float pixelRadius = 0.001;\n\n    // naive raymarching on right half of the screen for comparison\n    if (uv.x > 0.0)\n        omega = 1.;\n    \n    for( int i= 0; i < MAX_ITER; i ++) {\n        p = t * ray + cam;\n        \n        float signedRadius = DE(p); \n        float radius = abs(signedRadius);\n        \n        bool sorFail = omega > 1.0 && (radius + previousRadius) < stepLength;\n        \n        if (sorFail) { \n            stepLength -= omega * stepLength;\n            omega = 1.0;\n            \n\t\t} else { \n            stepLength = signedRadius * omega;\n        } \n        \n        \n        previousRadius = radius;\n        float error = radius / t;\n\n        \n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n        t += stepLength;\n        iter ++;\n        \n        if (!sorFail && error < pixelRadius || t > t_max) {\n            break;\n            hit = true;\n        }\n    }\n    \n    float fakeAO = 1.0 - iter / float(MAX_ITER);    \n\n    color = vec3(plasma_quintic(fakeAO));    \n    \n    vec2 uv_n = fragCoord.xy / iResolution.xy;\n\n   // color = pow(color, vec3(0.9));\n    if (uv_n.y < 0.05) {\n        color = plasma_quintic(uv_n.x);\n    }\n    \n\tfragColor = vec4(color ,1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}