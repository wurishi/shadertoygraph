{"ver":"0.1","info":{"id":"7tcyz7","date":"1659454464","viewed":80,"name":"Literally Every Apple Commercial","username":"wikiemol","description":"Apple is releasing their new grey square","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["joke"],"hasliked":0,"parentid":"flcyzN","parentname":"Refresher"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHAPE(a, b) scene(a, b)\n\n\n\nfloat sphere(vec3 point, vec3 position) {\n    return length(point - position) - 0.5;\n}\n\nfloat prism(vec3 point, vec3 position) {\n    point = point - position;\n    float width = 0.3;\n    float height = 0.3;\n    float depth = 0.3;\n    \n    return max(abs(point.x) - width, max(abs(point.z) - depth, abs(point.y) - height));\n}\n\nfloat plane(vec3 point, vec3 position) {\n    point = point - position;\n    return abs(point.y);\n}\n\nfloat scene(vec3 point, vec3 position) {\n    //return min(\n        //plane(point, vec3(0., -2.0, 0.)), \n        return prism(point, position);\n    //);\n}\n\nvec3 normal(vec3 point, vec3 position) {\n    float diff = 0.01;\n    \n    float dist = SHAPE(point, position);\n    float distx = SHAPE(vec3(point.x + diff, point.y, point.z), position);\n    float partialX = (distx - dist)/diff;\n    \n    float disty = SHAPE(vec3(point.x, point.y + diff, point.z), position);\n    float partialY = (disty - dist)/diff;\n\n\n    float distz = SHAPE(vec3(point.x, point.y, point.z + diff), position);\n    float partialZ = (distz - dist)/diff;\n    \n    return normalize(-vec3(partialX, partialY, partialZ));\n\n}\n\n\nstruct MarchResult\n{\n  // Point on the surface\n  vec3 point;\n  // Distance from the surface\n  float distanceFromSurface;\n};\n\nMarchResult march(vec3 lensCoordinate, vec3 shapePos) {\n    vec3 ray = normalize(lensCoordinate);\n    float t = 0.0;\n    float rayDistance = 1. / 0.;\n    for (int i = 0; i < 400; i++) {\n        rayDistance = SHAPE(ray * t, shapePos);\n        t += rayDistance * 0.9;\n    }\n    return MarchResult(ray * t, rayDistance) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0 * (fragCoord/iResolution.xy - 0.5);\n    // Making it so that x is same scale as y\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    float focalLength = 3.0;\n\n    // Considering camera to be origin (0), lens coordinate is \n    // the 3d coordinate on the surface of the lens which is receiving\n    // light.\n    vec3 lensCoordinate = vec3(uv, focalLength);\n    \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n\n    //vec3 shapePos = vec3(cos(iTime), 0.0, sin(iTime) + 2.0);\n    //vec3 shapePos = vec3(cos(iTime), sin(iTime), 5.0 + cos(iTime)*sin(iTime));\n    vec3 shapePos = vec3(0.0, 0.0, focalLength + 4.0);\n\n\n    vec3 lightPos = vec3(3. * cos(iTime), 2.0, 3.0 * sin(iTime) + 8.0);\n    float diffuseIllum = 5.;\n    float specIllum = 2.;\n\n\n    MarchResult result = march(lensCoordinate, shapePos);\n    if (result.distanceFromSurface < 0.1) {\n        vec3 normal = normalize(normal(result.point, shapePos));\n        vec3 lightRay = result.point - lightPos;\n        vec3 lightReflect = reflect(-lightRay, normal);\n        float sqrDistFromLight = diffuseIllum /pow(distance(result.point, lightPos), 2.);\n        float diffuse = (0.01 + smoothstep(0., 1., sqrDistFromLight*0.3*dot(lightRay, normal)));\n        float specular = (smoothstep(0., 1., specIllum* 0.3 * dot(normalize(lightReflect), normalize(result.point))));\n        \n        fragColor = vec4(vec3(diffuse + specular),1.0);\n    } else {\n        fragColor = vec4(vec3(0.), 1.0);\n    }\n\n    \n}","name":"Image","description":"","type":"image"}]}