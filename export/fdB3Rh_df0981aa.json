{"ver":"0.1","info":{"id":"fdB3Rh","date":"1616897443","viewed":225,"name":"Raymarching Spheres","username":"warptarium","description":"This shader raymarches two spheres.\n\nIt uses an improvised phong shading method to calculate light, and uses sin/cos rotation to move the spheres.\n\nThe camera is rotated using an x axis rotation matrix.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define SURF_DIST 0.03\n#define MAX_DIST 100.0\n#define GREEN vec3(0, 1.0, 0.0)\n#define RED vec3(1.0, 0.0, 0.0)\n#define AMB_LIGHT_STRENGTH 0.1\n#define SPECULAR_LIGHT_STRENGTH 0.5\n\n/*\n    Created by Weston McNamara\n*/\n\n\n//x axis rotation matrix\nmat3 rotX(float angle) \n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3\n    (\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, c, s,\n\t\t0.0, -s, c\n\t);\n}\n\n//SDF to first sphere\nfloat sdfSphere(vec3 p) \n{\n    vec4 sphere = vec4(0, 1.1, 9, 1);\n    sphere.xz += vec2(-sin(iTime), cos(iTime))  * 5.;\n    \n    return length(p - sphere.xyz) - sphere.w;\n} \n\n//SDF to second sphere\nfloat sdfSphere2(vec3 p) \n{\n    vec4 sphere = vec4(0, 1.1, 9, 1);\n    sphere.x += sin(iTime) * 6.0;\n    \n    return length(p - sphere.xyz) - sphere.w;\n} \n\n//signed distance to axis aligned plane\nfloat sdfPlane(vec3 p) \n{\n    return p.y; //y at zero\n}\n\n//signed distance to scene\nfloat sdfScene(vec3 p) \n{\n    return min(sdfPlane(p), min(sdfSphere(p), sdfSphere2(p)));\n}\n\n//scene raymarching function\nfloat sceneMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) \n    {\n        vec3 p = ro + rd * dO;\n        float dS = sdfScene(p);\n        dO += dS;\n        \n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n//weird calculus trick to get normal vector\nvec3 genNormal(vec3 p) \n{\n    float d = sdfScene(p); //very close to 0\n    \n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = vec3\n    (\n        d - sdfScene(p - e.xyy),\n        d - sdfScene(p - e.yxy),\n        d - sdfScene(p - e.yyx)\n    );\n        \n    return normalize(n);\n}\n\n//calculate the color of a pixel with a origin and direction\nvec3 calculateColor (vec3 ro, vec3 rd, vec2 uv) \n{\n    vec3 lightPos = vec3(0.0, 7.0, 8.0);\n\n    //march the scene coordinate\n    float d = sceneMarch(ro, rd);\n    \n    //Background color\n    if (d > MAX_DIST)\n        return vec3(0.0, 0.2, 0.4) * d;\n        \n    //create a point for the light to be calculated on\n    vec3 p = ro + rd * d;\n    \n    lightPos.xy += vec2(sin(iTime), cos(iTime)) * 2.;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = genNormal(p);\n    \n    //diffuse\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    //specular\n    //https://learnopengl.com/Lighting/Basic-Lighting\n    vec3 viewDir = normalize(p - ro);\n    vec3 incident = reflect(-viewDir, n);\n    \n    float spec = pow(max(dot(viewDir + n * SURF_DIST, incident), 0.0), 66.0) * SPECULAR_LIGHT_STRENGTH;\n    \n    //Sample shadows\n    float shadowDist = sceneMarch(p + n, lightPos - p);\n    \n    if (shadowDist < distance(p, lightPos))\n    {\n        //in shadow\n        dif *= 0.1;\n        spec = 0.0; //remove specular highlight in shadow\n    }\n    \n    return vec3(dif + AMB_LIGHT_STRENGTH + spec) * vec3(0.1, 0.2, 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //center uvs\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; \n    \n    //camera data\n    vec3 ro = vec3(0, 2, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1) * (rotX(cos(iTime) / 5.0)) - 0.1);\n    \n    //calculate color\n    vec3 col = calculateColor(ro, rd, uv); \n    \n    //output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}