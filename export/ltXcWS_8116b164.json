{"ver":"0.1","info":{"id":"ltXcWS","date":"1506223118","viewed":69,"name":"[HP] Refraction","username":"radikai","description":"Playing with path tracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["refractiontest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kTwoPi            6.28318530718\n#define kPi               3.14159265359\n#define kHalfPi           1.57079632679\n#define kQuarterPi        0.78539816339\n\n#define kDeg2Rad          (kPi/180.0)\n#define kRad2Deg          (180.0/kPi)\n\n#define kTextColor1       vec3(1.00, 0.75, 0.75)\n#define kTextColor2       vec3(0.75, 1.00, 0.75)\n#define kTextColor3       vec3(0.75, 0.75, 1.00)\n#define kTextSize         8.0\n\n#define kStepCount        64\n#define kBounceCount      16\n#define kGradEps          0.0001\n#define kPrecis           0.0002\n#define kTMax             32.0\n\n#define kSeed             123.0\n\n#define kCamDist          2.5\n#define kCamFov           70.0\n\n#define kRefractIdx       1.12\n#define kInvRefractIdx    (1.0 / kRefractIdx)\n\n#define kIdCube           1\n\n#define kForceScene       1\n#define kForceCost        0\n#define kMaxSteps         (4 * kStepCount)\n\n#define kSimpleScene      0\n\n#define kTest             1\n\nvec2 uAspect;\nvec3 uMouse;\nvec2 uUv;\n\n// --------------------------------------------------------------------------------\n// Debug print\n// --------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/4sBSWW\nfloat digitBin(const int x)\n{\n\treturn x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n// https://www.shadertoy.com/view/4sBSWW\nfloat printValue(const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces)\n{\n\tif ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tfloat fReducedRangeValue = fValue;\n\t\t\t\t// jpr: fixed negative values\n\t\t\t\tif(fDigitIndex < 0.0) { fReducedRangeValue = mod( fValue, sign(fValue) ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n\t\t\t\tfCharBin = digitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n\t\t}\n\t}\n\treturn floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nstruct Debug_t {\n\tfloat unset;\n\tvec3 value1, value2, value3;\n} gDbg = Debug_t(1.0, vec3(0.0), vec3(0.0), vec3(0.0));\n\nvoid setDebugVectors(const vec3 value1, const vec3 value2, const vec3 value3)\n{\n\tgDbg.value1 = mix(gDbg.value1, value1, gDbg.unset);\n\tgDbg.value2 = mix(gDbg.value2, value2, gDbg.unset);\n\tgDbg.value3 = mix(gDbg.value3, value3, gDbg.unset);\n\tgDbg.unset = 0.0;\n}\n\nvoid drawDebugVectors(inout vec3 col, in vec2 fragCoord)\n{\n\tcol = mix(col, kTextColor1, printValue((fragCoord - vec2(0.0,   25.0)) / kTextSize, gDbg.value1.x, 4.0, 3.0));\n\tcol = mix(col, kTextColor1, printValue((fragCoord - vec2(0.0,   15.0)) / kTextSize, gDbg.value1.y, 4.0, 3.0));\n\tcol = mix(col, kTextColor1, printValue((fragCoord - vec2(0.0,    5.0)) / kTextSize, gDbg.value1.z, 4.0, 3.0));\n\n\tcol = mix(col, kTextColor2, printValue((fragCoord - vec2(80.0,  25.0)) / kTextSize, gDbg.value2.x, 4.0, 3.0));\n\tcol = mix(col, kTextColor2, printValue((fragCoord - vec2(80.0,  15.0)) / kTextSize, gDbg.value2.y, 4.0, 3.0));\n\tcol = mix(col, kTextColor2, printValue((fragCoord - vec2(80.0,   5.0)) / kTextSize, gDbg.value2.z, 4.0, 3.0));\n\n\tcol = mix(col, kTextColor3, printValue((fragCoord - vec2(160.0, 25.0)) / kTextSize, gDbg.value3.x, 4.0, 3.0));\n\tcol = mix(col, kTextColor3, printValue((fragCoord - vec2(160.0, 15.0)) / kTextSize, gDbg.value3.y, 4.0, 3.0));\n\tcol = mix(col, kTextColor3, printValue((fragCoord - vec2(160.0,  5.0)) / kTextSize, gDbg.value3.z, 4.0, 3.0));\n}\n\n// --------------------------------------------------------------------------------\n// Math\n// --------------------------------------------------------------------------------\n\nmat3 rotateX(float a)\n{\n\treturn mat3(1.0, 0.0, 0.0, 0.0, cos(a), sin(a), 0.0, -sin(a), cos(a));\n}\n\nmat3 rotateY(float a)\n{\n\treturn mat3(cos(a), 0.0, -sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a));\n}\n\nmat3 rotateZ(float a)\n{\n\treturn mat3(cos(a), sin(a), 0.0, -sin(a), cos(a), 0.0, 0.0, 0.0, 1.0);\n}\n\nhighp float rand1d(float v)\n{\n\thighp float a  = 12.9898;\n\thighp float c  = 43758.5453;\n\thighp float dt = v * a;\n\thighp float sn = mod(dt, 3.14);\n\treturn fract(sin(sn) * c);\n}\n\nhighp float rand2d(vec2 v)\n{\n\thighp float a  = 12.9898;\n\thighp float b  = 78.233;\n\thighp float c  = 43758.5453;\n\thighp float dt = dot(v.xy, vec2(a, b));\n\thighp float sn = mod(dt, 3.14);\n\treturn fract(sin(sn) * c);\n}\n \n// --------------------------------------------------------------------------------\n// SDF\n// --------------------------------------------------------------------------------\n\nstruct Sample_t {\n\tfloat d;\n\tint id;\n};\n\n// https://iquilezles.org/articles/morenoise/\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// returns 3D value noise\nfloat noise( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    float n = noise(p*20.0);\n\treturn 0.005*n + length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nSample_t front(Sample_t s1, Sample_t s2)\n{\n\tif (s1.d < s2.d)\n\t\treturn s1;\n\telse\n\t\treturn s2;\n}\n\nSample_t map(vec3 p)\n{\n#if !kSimpleScene\n\tvec3 mp = mod(clamp(p, -1.0, 1.0), vec3(1.0)) - 0.5;\n\tp.xz = mp.xz;\t\n#endif\n\tSample_t s = Sample_t(sdRoundBox(p, vec3(0.2, 0.4, 0.2), 0.05), kIdCube);\n\treturn s;\n}\n\n// --------------------------------------------------------------------------------\n// Ray marching\n// --------------------------------------------------------------------------------\n\nstruct Hit_t {\n\tvec3 rayPos, rayDir; // viewspace ray position and direction\n\tfloat rayLen;        // total ray length incl all bounces\n\tvec3 normal;         // surface normal\n\tint id;              // object id\n\tint steps;           // step count\n};\n\n// https://www.shadertoy.com/view/Xds3zN\nvec3 grad(vec3 p)\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(p+eps.xyy).d - map(p-eps.xyy).d,\n        map(p+eps.yxy).d - map(p-eps.yxy).d,\n        map(p+eps.yyx).d - map(p-eps.yyx).d );\n    return normalize(nor);\n}\n\n\nHit_t march(const vec3 origin, const vec3 dir, const float tMin, const float tMax, const float prevT, const float stepAlpha, const bool internal, const int prevSteps, const int bounce, const bool debug)\n{\n\tfloat t = tMin;\n\tvec3 p;\n\tSample_t s;\n\tint i = 0;\n\tfor (; i < kStepCount; ++i) {\n\t\tp = origin + t * dir;\n\t\ts = map(p);\n\t\tt += stepAlpha * (internal ? -s.d : s.d); // sdf is negative inside the volume; flip sign to continue forward \n\t\tif (abs(s.d) < (kPrecis * t) || t > tMax)\n\t\t\tbreak;\n\t}\n    if (i == kStepCount)\n        t = tMax;\n\treturn Hit_t(p, dir, prevT + t, grad(p), s.id, i + prevSteps);\n}\n\nHit_t marchTransparent(in vec3 origin, in vec3 dir, const float tMin, const float tMax, const float stepAlpha, const bool debug)\n{\n\tbool internal = false;\n\tint i = 1;\n\tHit_t hit = march(origin, dir, tMin, tMax, 0.0, stepAlpha, internal, 0, 0, debug);\n\tfor (; i < kBounceCount; ++i) {\n        if (hit.rayLen >= kTMax) break;\n\n\t\tfloat refractiveIndex = internal ? kInvRefractIdx : kRefractIdx;\n\t\tvec3 refractiveDir = refract(dir, internal ? -hit.normal : hit.normal, refractiveIndex);\n        if (refractiveDir == vec3(0)) {\n            dir = reflect(dir, internal ? -hit.normal : hit.normal);\n        } else {\n            dir = refractiveDir;\n            internal = !internal;\n        }\n\n        float separation = 0.001;\n        float startDistance = separation / abs(dot(dir, hit.normal));\n\n\t\torigin = hit.rayPos + startDistance * dir;\n\t\thit = march(origin, dir, tMin, tMax, hit.rayLen, stepAlpha, internal, hit.steps, i, debug);\n\t}\n\n    if (debug) { setDebugVectors(vec3(i, hit.steps, hit.rayLen), hit.rayPos, hit.rayDir); }\n    \n    return hit;\n}\n\n// --------------------------------------------------------------------------------\n// Materials\n// --------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n\treturn a + b*cos(6.28318*(c*t+d));\n}\n\nvec3 shade(Hit_t hit, in vec2 fragCoord, const bool debug)\n{\n\tif (hit.rayLen >= kTMax) {\n\t\treturn texture(iChannel0, hit.rayDir).xyz;\t\n\t} else {\n\t\treturn vec3(0);\n\t}\n}\n\nvec3 cost(Hit_t hit, in vec2 fragCoord, const bool debug)\n{\n\tfloat t = float(hit.steps) / float(kMaxSteps);\n\tvec3 col = pal(t, vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(0.5,0.5,0.5),vec3(0.5,0.0,0.75));\n\treturn col;\n}\n\n// --------------------------------------------------------------------------------\n// Entrypoint\n// --------------------------------------------------------------------------------\n\nvec3 getColor(in vec2 fragCoord, const bool debug)\n{\n\tvec2 uv     = fragCoord.xy / iResolution.xy;\n\tuv          = uv * 2.0 - 1.0;\n\tuv.y       *= uAspect.y;\n\n\tmat3 view   = rotateY(kPi * uMouse.x) * rotateX(kQuarterPi * max(1.0 - uMouse.y, 0.0));\n\tvec3 origin = view * vec3(0.0, 0.0, -kCamDist + uMouse.y);\n\tvec3 dir    = view * normalize(vec3(uv, 1.0 / tan(kDeg2Rad * kCamFov / 2.0)));\n\n\tHit_t hit = marchTransparent(origin, dir, 0.0, kTMax, 1.0, debug);\n\n#if kForceScene\n\tvec3 col = shade(hit, fragCoord, debug);\n#elif kForceCost\n\tvec3 col = cost(hit, fragCoord, debug);\n#else\n\tvec3 col  = (uMouse.z == 1.0)\n\t\t? cost(hit, fragCoord, debug)\n\t\t: shade(hit, fragCoord, debug);\n#endif\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tuAspect     = iResolution.xy / iResolution.x;\n\n\tuMouse.xy   = iMouse.xy / iResolution.xy;\n\tuMouse.xy   = uMouse.xy * 2.0 - 1.0;\n\tuMouse.z    = 1.0 - step(iMouse.z, 0.0);\n\n    bool down = (iMouse.z > 0.0);\n    if (!down) {\n        uMouse.xy = vec2(sin(0.1 * iTime), cos(0.1 * iTime));\n    }\n\n    vec3 col    = getColor(fragCoord, false);\n\n#if kTest\n    vec3 test   = getColor(iMouse.xy, true);\n\tdrawDebugVectors(col, fragCoord);\n#endif\n\n    col = pow(col,vec3(0.4545));\n\tfragColor.rgb = col;\n}\n","name":"Image","description":"","type":"image"}]}