{"ver":"0.1","info":{"id":"M3S3WW","date":"1708447500","viewed":166,"name":"Iron Star","username":"DominicKarma","description":"Translated thing I made in HLSL a while ago. Has a few residual oddities to it, and the textures aren't the original intended ones due to Shadertoy limitations.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["iron","ironstar","deadsun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sphereSpinSpeed 0.15\n\n#define heatCrackEmergePower 0.04\n#define heatCrackGlowIntensity 1.25\n#define specialHeatCrackIntensity 0.0\n#define heatDistortionMaxOffset 0.018\n#define specialHeatCrackDirection vec2(1.0, 0.0)\n\n#define metalCrackIntensity 0.18\n#define metalCrackSize 0.8\n#define metalCrackHeatInterpolant 0.0\n\n#define highlightSharpness 6.6\n#define minHighlightBrightness 0.4\n#define maxHighlightBrightness 1.6\n#define highlightPosition vec2(0.58, 0.58)\n#define brightHighlightColor vec3(0.95, 0.92, 0.86)\n#define dullHighlightColor vec3(0.65, 0.58, 0.56)\n\n#define underglowStartInterpolant 0.56\n#define underglowEndInterpolant 0.7\n#define underglowColor vec3(0.7, 0.02, 0.08)\n\n#define collapseInterpolant 0.0\n\nfloat saturate(float x) \n{\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat QuadraticBump(float x)\n{\n    return x * (4.0 - x * 4.0);\n}\n\nvec4 ApplyMetalCrackEffects(vec4 baseColor, vec2 sphereCoords, float crack)\n{\n    // Apply subtractive blending with the crack color.\n    baseColor -= metalCrackIntensity * crack;\n    \n    // Brighten colors moderately darkened by the cracks.\n    // This is done to help make it look like the contours of the cracks are natural, with parts that are naturally exposed to light.\n    float luminosity = (baseColor.r + baseColor.g + baseColor.b) * 0.3333;\n    float edge = QuadraticBump(smoothstep(0.01, 0.4, luminosity)) * mix(0.25, 0.3, metalCrackHeatInterpolant);\n    \n    return baseColor + edge * baseColor.a;\n}\n\nvec4 ApplyHeatCrackEffects(vec4 baseColor, vec2 sphereCoords, float metalCrack, float highlightBrightness, float specialCrackIntensity)\n{\n    // Sample two noise textures to calculate the crack's texture.\n    float crackNoiseIntensity = saturate(texture(iChannel3, sphereCoords * 1.8).x + texture(iChannel1, sphereCoords * 0.7).x);\n    \n    // Increase the crack noise near the special crack position.\n    crackNoiseIntensity -= saturate(specialCrackIntensity) * specialHeatCrackIntensity;\n    \n    float metalInfluence = (smoothstep(0.8, 1.7, metalCrack) * metalCrack * metalCrackHeatInterpolant + sin(iTime * 0.7 + sphereCoords.x * 20.5) * 0.2) * 0.25;\n    \n    float crack = crackNoiseIntensity * 0.75 + distance(sphereCoords, vec2(0.5)) * heatCrackEmergePower - metalInfluence;\n    \n    // Create the outer red aesthetic.\n    baseColor.r += smoothstep(0.41, 0.37, crack) * heatCrackGlowIntensity / highlightBrightness;\n    \n    // Create the semi-inner orange aesthetic. Since this is green it will combine with the aforementioned red to create oranges and yellows.\n    baseColor.g += smoothstep(0.37, 0.27, crack) * heatCrackGlowIntensity / highlightBrightness;\n    \n    // Create the inner white aestheic. Since this is blue it will combined with the aforementioned red and green to create a bright white color.\n    baseColor.b += smoothstep(0.26, 0.25, crack) * heatCrackGlowIntensity / highlightBrightness;\n    \n    // Darken the edges to black for contrast reasons.\n    baseColor = mix(baseColor, vec4(0, 0, 0, 1), smoothstep(0.4, 0.41, crack) * smoothstep(0.46, 0.41, crack) * 0.6 - metalInfluence * 1.5);\n    \n    // Return the result.\n    return baseColor;\n}\n\nvec4 ApplyBottomUnderglow(vec4 baseColor, vec2 sphereCoords)\n{\n    // Calculate the glow intensity based on the distance to the bottom of the sphere, as well as the opacity of the color.\n    // If the opacity is zero, this naturally cancels out, to prevent additively drawn colors from interfering with invisible pixels.\n    float glowInterpolant = smoothstep(underglowStartInterpolant, underglowEndInterpolant, 1.0 - sphereCoords.y) * baseColor.a;\n    \n    // Combine the glow interpolant with the underglow color.\n    vec4 glowColor = vec4(underglowColor, 1) * glowInterpolant;\n    \n    // Apply additive blending.\n    return baseColor + glowColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coords = (fragCoord - iResolution.xy * 0.5)/iResolution.xx * 1.4 + 0.5;\n\n    // Calculate the pixel's angle from the center.\n    float angle = atan(coords.y - 0.5, coords.x - 0.5);\n    \n    // Calculate the specular highlight based on distance to the highlight's position.\n    float highlight = exp(distance(coords, highlightPosition) * -highlightSharpness);\n    float highlightPulse = (cos(iTime * 2.0) * 0.5 + 0.5) * 1.2;\n    float highlightBrightness = mix(minHighlightBrightness, highlightPulse + maxHighlightBrightness, highlight);\n    \n    // Calculate the highlight color.\n    vec4 highlightColor = vec4(mix(dullHighlightColor, brightHighlightColor, highlight), 1.0) * highlightBrightness;\n    \n    // Ensure that the highlight doesn't make colors transparent. That'd be silly!\n    highlightColor.a = 1.0;\n    \n    // Calculate information pertaining to the special heat crack visual.\n    float sphereSpinTime = iTime * sphereSpinSpeed;\n    vec2 specialCrackPosition = specialHeatCrackDirection * 0.35 + 0.5;\n    float specialCrackIntensity = 0.12 / distance(coords, specialCrackPosition + texture(iChannel1, coords * 3.0 + vec2(sphereSpinTime * 3.0, 0)).r * pow(specialHeatCrackIntensity, 2.0) * 0.4);\n    specialCrackIntensity = pow(specialCrackIntensity, 2.0);\n    \n    // Calculate the distance to the center of the star. This is magnified a bit for intensity purposes in later equations.\n    vec2 coordsNormalizedToCenter = (coords - 0.5) * 2.0;\n    float distanceFromCenterSqr = dot(coordsNormalizedToCenter, coordsNormalizedToCenter) * 2.0;\n    \n    // Calculate a glow color in accordance with the special crack.\n    vec4 glowBaseColor = vec4(1, 0.01 + specialCrackIntensity * 0.2, 0, 1);\n    vec4 glow = glowBaseColor * smoothstep(0.1, 0.7, distanceFromCenterSqr) * smoothstep(0.8, 0.71, distanceFromCenterSqr) * pow(specialCrackIntensity, 1.15) * specialHeatCrackIntensity * float(specialHeatCrackIntensity > 0.08) * 3.0;\n    distanceFromCenterSqr += cos(angle * 12.5 + iTime * 9.0) * length(glow) * heatDistortionMaxOffset;\n    \n    // Ensure that the star is cut off at the edges to ensure a circular shape.\n    float starOpacity = smoothstep(0.707, 0.68, distanceFromCenterSqr);\n    \n    // Calculate coordinates relative to the sphere.\n    // This pinch factor effectively ensures that the UVs are relative to a circle, rather than a rectangle.\n    // This helps SIGNIFICANTLY for making the texturing look realistic, as it will appear to be traveling on a\n    // sphere rather than on a sheet that happens to overlay a circle.\n    float spherePinchFactor = (1.0 - sqrt(abs(1.0 - distanceFromCenterSqr))) / distanceFromCenterSqr + 0.001;\n    \n    // Exaggerate the pinch slightly.\n    spherePinchFactor = pow(spherePinchFactor, 1.5);\n    \n    // Combine everything into the sphere coords.\n    // This technically has a seam, but whatever.\n    vec2 sphereCoords = fract((coords - 0.5) * spherePinchFactor + 0.5 + vec2(sphereSpinTime, 0.0));\n    \n    // Calculate crack values for the metal crack.\n    float metalCrack = pow(1.0 - texture(iChannel0, sphereCoords * 3.8).x, 2.5) * (1.0 + metalCrackSize);\n    \n    // Ensure that the crack gets cut off naturally. This is meant to be a bit like a step function except a bit more smooth.\n    metalCrack *= smoothstep(0.38, 0.7, metalCrack);\n    \n    // Calculate the final color, applying metallic and heat cracks.\n    vec3 ironColor = texture(iChannel2, sphereCoords * 2.0).xyz;\n    vec4 baseColor = vec4(pow(ironColor.x, 1.5), pow(ironColor.y, 1.5), pow(ironColor.z, 1.5), 1.0);\n    baseColor = ApplyMetalCrackEffects(baseColor, sphereCoords, metalCrack);\n    baseColor = ApplyHeatCrackEffects(baseColor, sphereCoords, metalCrack, highlightBrightness, specialCrackIntensity);\n\n    // Combine everything together.\n    float brightness = collapseInterpolant * 0.6 + 1.0;\n    vec4 result = (baseColor * starOpacity * highlightColor + glow) * brightness;\n    \n    // Apply a bottom underglow to the sphere.\n    result = ApplyBottomUnderglow(result, sphereCoords);\n    \n    fragColor = result + result.a * collapseInterpolant * 0.6;\n}","name":"Image","description":"","type":"image"}]}