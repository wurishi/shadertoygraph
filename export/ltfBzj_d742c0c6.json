{"ver":"0.1","info":{"id":"ltfBzj","date":"1512486429","viewed":278,"name":"Little Cubes","username":"shau","description":"3D","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define EPS 0.005\n#define FAR 200.0 \n#define PI 3.14159265359\n#define T iTime * 2.0\n\nvec3 lp = vec3(4.0, 5.0, -2.0);\n\nstruct Box {\n    float tN;\n    float tF;\n    vec3 nN;\n    vec3 nF;\n    float wN;\n    float wF;\n};\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n//wireframe edges\nfloat tex(vec3 rp) {\n    float bs = 0.9;\n    if (abs(rp.x) < bs && abs(rp.y) < bs) return 0.0;\n    return 1.0;   \n}        \n\n// Cube mapping routine from Fizzer\n// I'm not sure where I got this from\nfloat fizz(vec3 rp) {\n    vec3 f = abs(rp);\n    f = step(f.zxy, f) * step(f.yzx, f); \n    f.xy = f.x > .5 ? rp.yz / rp.x : f.y > .5 ? rp.xz / rp.y : rp.xy / rp.z; \n    return tex(f);\n}\n\n// https://iquilezles.org/articles/boxfunctions\nBox boxIntersection(vec3 ro, vec3 rd, vec3 boxSize) {\n\n    Box box = Box(0.0, 0.0, vec3(0.0), vec3(0.0), 0.0, 0.0);\n\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0) return box;\n\n    float fzN = fizz(ro + rd * tN);\n    float fzF = fizz(ro + rd * tF);\n\n    vec3 nN = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    vec3 nF = -sign(rd) * step(t2.xyz, t2.yzx) * step(t2.xyz, t2.zxy); \n\n    return Box(tN, tF, nN, nF, fzN, fzF);\n}\n\nBox translateBox(vec3 ro, vec3 rd, float i) {\n\n    vec3 bc = vec3(-i * (1.4 - i * 0.06), sin(T * 0.5 + i) * 1.4, 0.0); //box center\n    vec3 boxSize = vec3(1.0 - i * 0.1);\n\n    ro += bc;\n\n    ro.xz *= rot(T + i * 0.25);\n    rd.xz *= rot(T + i * 0.25);\n    ro.xy *= rot(-T - i * 0.5);\n    rd.xy *= rot(-T - i * 0.5);\n\n    Box box = boxIntersection(ro, rd, boxSize);\n\n    //unwind rotation of normals\n    box.nN.xy *= rot(T + i * 0.5);\n    box.nF.xy *= rot(T + i * 0.5);\n    box.nN.xz *= rot(-T - i * 0.25);\n    box.nF.xz *= rot(-T - i * 0.25);\n\n    return box;\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nfloat floorTex(vec3 rp) {\n    rp.x += T * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n\nstruct Scene {\n    float t;\n    vec3 nN;\n    vec3 pc;\n    float edge;\n    float k;            \n};\n\nScene drawBoxes(vec3 ro, vec3 rd, vec3 pc) {\n\n    vec3 sc = vec3(0.0);\n    float edge = 0.0;\n    float k = 0.0;\n\n    Box nearest = Box(FAR, FAR, vec3(0.0), vec3(0.0), 0.0, 0.0);\n    float index = 0.0;\n\n    for (int i = 0; i < 8; i++) {\n        float fi = float(i);\n        Box box = translateBox(ro, rd, fi);\n        if (box.tN > 0.0) {\n            if (box.wN > 0.0) edge = 1.0;\n            if (box.wF > 0.0) edge = 1.0;\n            if (box.tN < nearest.tN) {\n                nearest = box;\n                index = fi;\n            }\n        }\n    }\n\n    if (edge > 0.0) {\n        sc = vec3(0.0, 1.0, 0.0);\n    } else {\n        sc = pc;\n    }\n\n    if (nearest.tN < FAR) {\n\n        k = clamp(index * 0.06, 0.0, 1.0);\n\n        vec3 rp = ro + rd * nearest.tN;\n        vec3 ld = normalize(lp - rp);\n        float lt = length(lp - rp);\n        float diff = max(dot(nearest.nN, ld), 0.05);\n        float spec = pow(max(dot(reflect(-ld, nearest.nN), -rd), 0.0), 16.0);\n        float atten = 1. / (1.0 + lt * lt * .05);\n        vec3 fsc = vec3(0.0, 1.0, 0.0) * diff * atten;\n        fsc += vec3(0.05, 0.0, 0.4) * nearest.nN.y * -0.04;\n        fsc += vec3(1.0) * spec;\n\n        rp = ro + rd * nearest.tF;\n        ld = normalize(lp - rp);\n        spec = pow(max(dot(reflect(-ld, nearest.nF), -rd), 0.0), 16.0);\n        fsc += vec3(1.0) * spec * 0.5 * k;\n\n        sc = mix(fsc, sc, k);\n    }\n\n    return  Scene(nearest.tN, nearest.nN, sc, edge, k);\n}\n\nfloat shadow(vec3 rp) {\n\n    float sh = 1.0;\n\n    vec3 ld = normalize(lp - rp); \n    float lt = length(lp - rp); \n\n    Scene boxes = drawBoxes(rp, ld, vec3(0.0)); \n    if (boxes.t > 0.0 && boxes.t < lt) {\n        sh = 0.14 + (boxes.k * (1.0 - boxes.edge) * 0.86);\n        sh *= boxes.t;\n    }\n\n    return clamp(sh, 0.1, 1.0);\n}\n                        \nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    ro = lookAt + vec3(0.0, 0.5 + (sin(T * 0.2) + 1.0) * 0.3, -12.0 - (sin(T * 0.3) + 1.0));\n\n    ro.xz *= rot(T * 0.2);\n\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n            \n    vec3 pc = vec3(0.0); \n    float mint = FAR; \n\n    vec3 ro, rd; \n    setupCamera(fragCoord, ro, rd);\n\n    vec3 fo = vec3(0.0, -3.0, 0.0); \n    vec3 fn = vec3(0.0, 1.0, 0.0); \n\n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0 && ft < FAR) {\n\n        mint = ft;\n\n        vec3 rrd = reflect(rd, fn);\n        vec3 rp = ro + rd * ft; \n        vec3 ld = normalize(lp - rp); \n        float lt = length(lp - rp); \n        float diff = max(dot(fn, ld), 0.05); \n        float spec = pow(max(dot(reflect(-ld, fn), -rd), 0.0), 8.0); \n        float shad = shadow(rp); \n        float atten = 1. / (1.0 + lt * lt * .03); \n\n        vec3 sc = vec3(0.4, 1.0, 0.4) * floorTex(rp); \n\n        Scene boxes = drawBoxes(rp, rrd, vec3(0.0));\n        if (boxes.t > 0.0 && boxes.t < FAR) {\n            sc += boxes.pc * exp(boxes.t * -boxes.t * 0.0005);\n        }\n\n        sc += vec3(1.0) * spec; \n        pc = sc * diff * atten; \n        pc *= shad;\n    }\n\n    Scene boxes = drawBoxes(ro, rd, pc);\n    if (boxes.t < mint) {\n\n        pc = boxes.pc;\n\n        vec3 rrd = reflect(rd, boxes.nN);\n        vec3 rro = ro + rd * (boxes.t - EPS);\n        float rft = planeIntersection(rro, rrd, fn, fo);\n        if (rft > 0.0 && rft < FAR) {\n            vec3 frp = rro + rrd * rft;\n            vec3 rld = normalize(lp - frp);\n            float rlt = length(lp - frp);\n            float rdiff = max(dot(fn, rld), 0.05);\n            float ratten = 1. / (1.0 + rlt * rlt * .03);\n            vec3 rsc = vec3(0.4, 1.0, 0.4) * floorTex(frp);\n            rsc *= rdiff * ratten;\n            pc += rsc * exp(rft * -rft * 2.5) * 0.3;\n        }\n    }\n\n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}