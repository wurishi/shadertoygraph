{"ver":"0.1","info":{"id":"wslyzf","date":"1585347475","viewed":432,"name":"Blob Wave","username":"Slime0","description":"Damn, look at that blob wave","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["wave","refraction","yellow","blob","purple","glitter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float MAX_GRADIENT = 55.0; // should be actual maximum rate of change of GetHeight()\n#define DEBUG_MAX_GRADIENT 0 // make MAX_GRADIENT as low as possible without letting any white appear\nfloat GetHeight( vec2 uv )\n{\n    if ( uv.x < 0.0 )\n        return 1.0;\n\n    float updown = sin( uv.x * 12.0 + iTime * 0.6 ) * mix( 1.0, 0.2, uv.x ) * 0.12;\n    float yspread = (uv.y - 0.5) * mix( 1.0, 0.1, uv.x ) + 0.5;\n    float leftright = sin( (yspread + updown) * 20.0 );\n    \n    float checker = sin( (uv.x + iTime * 0.05) * 40.0 ) * sin( uv.y * 10.0 - iTime * 1.0 ) * 0.5 + 0.5;\n    \n    float yCenterToEdge = (uv.y - 0.5) / 0.5;\n    yCenterToEdge *= yCenterToEdge;\n    float xpow = mix( 0.17, 0.25, yCenterToEdge );\n    \n    float phase = fract( pow( uv.x, xpow ) * 40.0 + leftright * 0.32 + checker * 0.2 + iTime * 0.1 * 1.4 );\n    \n    //phase = phase * phase;\n    \n    float wave = cos( phase * 2.0 * 3.14159 ) * 0.5 + 0.5;\n    //wave += cos( phase * 2.0 * 3.14159 * 14.0 ) * 0.005;\n    \n    //wave = pow( wave, 4.0 );\n    \n    float height = mix( 1.0, wave, pow( uv.x, 0.8 ) );\n    return height;\n}\n\n\nconst float BUMP_STRENGTH = 0.03;\n\nfloat GetUnshadowedLightFrac( vec2 uv, float startHeight, vec3 lightDir )\n{\n    const float SOFT_SHADOW_SLOPE = 4.0;\n    const float DIST_THRESHOLD = 0.001;\n\n    lightDir /= length( lightDir.xy ); // MAX_GRADIENT is in XY direction only\n    lightDir.z /= BUMP_STRENGTH;\n    \n    vec3 pos = vec3( uv, startHeight ) + lightDir * DIST_THRESHOLD;\n    float traveledDist = DIST_THRESHOLD;\n    \n    float softShadowAmount = 1.0;\n    \n    for ( int step = 0; step < 50; step++ )\n    {\n        float height = GetHeight( pos.xy );\n        if ( height > pos.z )\n            return 0.0f;\n        float diff = pos.z - height;\n        \n        softShadowAmount = min( diff / (SOFT_SHADOW_SLOPE * traveledDist), softShadowAmount );\n        \n        float minDistToHit = diff / MAX_GRADIENT + DIST_THRESHOLD;\n        traveledDist += minDistToHit;\n        \n        pos += lightDir * minDistToHit;\n        if ( pos.z > 1.0 + SOFT_SHADOW_SLOPE )\n            break;\n    }\n    \n    return softShadowAmount;\n}\n\nvec3 Color( float x )\n{\n    const vec3 c0 = vec3( 1.0, 0.8, 0.5 ) * 1.8;\n    const vec3 c1 = vec3( 1.0, 0.5, 0.25 ) * 1.1;\n    const vec3 c2 = vec3( 0.5, 0.15, 0.4 ) * 0.8;\n    const vec3 c3 = vec3( 0.2, 0.04, 0.35 ) * 0.5;\n    const vec3 c4 = vec3( 0.001, 0.003, 0.05 );\n    if ( x < 0.4 )\n    {\n        if ( x < 0.1 )\n            return mix( c0, c1, x / 0.1 );\n        else\n        \treturn mix( c1, c2, (x - 0.1) / 0.3 );\n    }\n    else\n    {\n        if ( x < 0.6 )\n        \treturn mix( c2, c3, (x - 0.4) / 0.2 );\n        else\n        {\n    \t\tx = min( x, 1.0 );\n    \t\treturn mix( c3, c4, (x - 0.6) / 0.4 );\n        }\n    }\n}\n\nfloat sinsin( vec2 uv )\n{\n    return min( abs( sin( uv.x ) * sin( uv.y ) ) * 1.2, 1.0 );\n}\n\nfloat Glitter( vec2 uv )\n{\n    uv *= 0.8;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.x += sin( uv.y * 20.0 ) * 0.03;\n    float x = sinsin( (uv.xx * vec2( 0.64, 0.77 ) + uv.yy * vec2( 0.77, -0.64 )) * 300.0 );\n    x *= sinsin( (uv.xx * vec2( 0.34, 0.94 ) + uv.yy * vec2( 0.94, -0.34 )) * 211.0 );\n    x *= sinsin( (uv.xx * vec2( 0.99, 0.12 ) + uv.yy * vec2( 0.12, -0.99 )) * 73.0 );\n    // return x; // to see what's going on here\n    return pow( x * 1.015, 100.0 );\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float height = GetHeight( uv );\n    \n    vec3 eps = vec3( 0.002, 0.002, 0.0 ); // vec3( vec2( 2.0 ) / iResolution.xy, 0.0 );\n    vec2 gradient = (vec2( height ) - vec2( GetHeight( uv + eps.xz ), GetHeight( uv + eps.zy ))) / eps.xy;\n    \n    vec3 normal = normalize( vec3( gradient * BUMP_STRENGTH, 1.0 ) );\n    \n    // sphere normal\n    //normal = vec3( uv - vec2( 0.5, 0.5 ), 0.0 ) * 2.0;\n    //normal.z = sqrt( 1.0 - dot( normal.xy, normal.xy ) );\n    \n    //const vec3 lightDir = normalize( vec3( -0.8, 0.5, 1.0 ) );\n    //vec3 lightPos = vec3( 0.5 + 0.3 * cos( iTime ), 0.5 + 0.3 * sin( iTime ), 0.2 );\n    vec3 lightPos = vec3( -0.2, 0.7, 0.4 );\n    vec3 lightDir = lightPos - vec3( uv, height * BUMP_STRENGTH );\n    float lightDist = length( lightDir );\n    float lightAttenuation = 1.2f; // / (1.0f + lightDist * lightDist * 0.2);\n    lightDir /= lightDist;\n    \n    //float dust = pow( texture( iChannel0, uv * 0.1 + vec2( iTime * 0.0015, height * -0.01 ) ).x * 1.05, 80.0 );\n    float dust = Glitter( uv + vec2( iTime * 0.04, height * -0.02 ) );\n    dust = mix( 0.0, dust, uv.x );\n    \n    vec3 reflectDir = vec3( 0.0, 0.0, -1.0 ) + normal * (2.0 * normal.z);\n    float specPower = mix( 140.0, 10.0, min( dust, 1.0 ) );\n    float spec = pow( max( dot( reflectDir, lightDir ), 0.0 ), specPower ) * lightAttenuation;\n    spec = mix( spec * 2.0, spec * 5.0, dust );\n    \n    float diffuse = max( dot( normal, lightDir ), 0.0 ) * lightAttenuation;\n    float shadow = GetUnshadowedLightFrac( uv, height, lightDir ); // pow( height, 0.5 );\n    diffuse *= shadow;\n    float ambientOcclusion = pow( height, 0.5 );\n    const float ambient = 0.01;\n    \n    vec3 albedo = Color( uv.x + (height - 1.0) * 0.05 ); // texture( iChannel0, uv - vec2( 0.0, height * 0.03 ) ).xyz;\n    albedo += vec3( 1.0, 0.5, 0.1 ) * dust;\n    \n    vec3 color = albedo * (diffuse + ambient * ambientOcclusion);\n    color += spec * shadow * vec3( 1.3, 1.0, 0.7 );\n    //color += vec3( 1.0, 0.3, 0.1 ) * 0.1 * dust;\n    \n    /*float skyReflectAmount = max( reflectDir.z, 0.0 );\n    vec2 skyPos = reflectDir.xy / reflectDir.z * 0.02 * vec2( -1.0, 1.0 );\n    //skyPos = uv;\n    vec3 skyColor = texture( iChannel0, skyPos ).yzx;\n    //skycolor = pow( skyColor, vec3( 7.0, 10.0, 5.0 ) );\n    skyColor = pow( skyColor * 1.3, vec3( 7.0, 10.0, 5.0 ) * 1.5 );\n    color += skyColor * skyReflectAmount * 0.5;*/\n    \n    vec3 refractDir = refract( vec3( 0.0, 0.0, -1.0 ), normal, 0.95 );\n    /*float refractAmount = pow( max( -refractDir.z, 0.0 ), 3.0 );\n    refractDir /= -refractDir.z;\n    vec3 groundColor = texture( iChannel0, refractDir.xy * 0.1 ).xyz;\n    //color += albedo * groundColor * refractAmount * (1.0 - diffuse);\n    color += groundColor.x * refractAmount * (1.0 - diffuse) * vec3( 0.1, 0.2, 0.6 ) * 0.2;*/\n    \n    //color = refractDir * 0.5 + 0.5;\n    //if ( refractDir.x < 0.0 )\n    //\tcolor += pow( -refractDir.x, 1.0 );\n    \n    const float GroundZ = -1.0;\n    // intersect refractDir with z = GroundZ plane\n    vec2 groundPos = uv + refractDir.xy * GroundZ / refractDir.z;\n    // find light ray intersect with z = 0\n    vec3 groundLightDir = vec3( -0.2, 0.2, 1.0 ); // lightPos - vec3( groundPos, GroundZ );\n    vec2 groundShadowPos = groundPos + groundLightDir.xy * (-GroundZ / groundLightDir.z);\n    float groundBrightness = pow( GetHeight( groundShadowPos ), 10.0 );\n    vec3 groundColor = pow( texture( iChannel0, groundPos ).xzy, vec3( 5.0 ) ) * vec3( 0.6, 0.3, 0.5 ) * 0.5;\n    color += mix( vec3( 0.0 ), groundColor, uv.x ) * groundBrightness;\n    \n    o = vec4( color, 1.0 );\n    \n    //o = vec4( vec3( height ), 1.0 );\n    \n    #if DEBUG_MAX_GRADIENT\n    \to = vec4( vec3( pow( length( gradient.xy ) / MAX_GRADIENT, 100.0 ) ), 1.0 );\n    #endif\n    \n    o = sqrt( o ); // totally accurate gamma correction\n}\n","name":"Image","description":"","type":"image"}]}