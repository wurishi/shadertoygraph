{"ver":"0.1","info":{"id":"7tVfz1","date":"1664195846","viewed":322,"name":"Walk on a Sphere","username":"TheTurk","description":"Move: W, A, S, D or arrow keys and mouse\nJump: Space\nCamera: C\nFly: F","likes":25,"published":1,"flags":48,"usePreview":0,"tags":["3d","mouse","game","collision","sdf","camera","keyboard","physics","firstperson","jump","character","gravity","move","controller","wasd","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 read(ivec2 offset) {\n    return texelFetch(iChannel1, offset, 0);\n}\n\nbool keyIsToggled(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 2), 0).x > 0.0;\n}\n\nSDF SceneEvaluateAxes(vec3 position) {\n    float baseRadius = 0.015;\n    float tipRadius = 0.08;\n    float tipHeight = 0.3;\n    vec3 characterPosition = read(bufferOffsetCharacterPosition).xyz;\n    vec4 characterOrientation = read(bufferOffsetCharacterOrientation);\n    position -= characterPosition;\n    position = QuaternionRotate(QuaternionInvert(characterOrientation), position);\n    vec3 right = vec3(1.0, 0.0, 0.0);\n    SDF arrow1 = SDFArrow(position - vec3(0.0, colliderRadius, 0.0), vec3(0.0), right, baseRadius, tipRadius, tipHeight);\n    arrow1.material = 4.0;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    SDF arrow2 = SDFArrow(position - vec3(0.0, colliderRadius, 0.0), vec3(0.0), up, baseRadius, tipRadius, tipHeight);\n    arrow2.material = 5.0;\n    vec3 forward = vec3(0.0, 0.0, 1.0);\n    SDF arrow3 = SDFArrow(position - vec3(0.0, colliderRadius, 0.0), vec3(0.0), forward, baseRadius, tipRadius, tipHeight);\n    arrow3.material = 6.0;\n    return SDFUnion(arrow1, SDFUnion(arrow2, arrow3));\n}\n\nSDF SceneEvaluateCharacter(vec3 position) {\n    vec3 characterPosition = read(bufferOffsetCharacterPosition).xyz;\n    vec4 characterOrientation = read(bufferOffsetCharacterOrientation);\n    position -= characterPosition;\n    position = QuaternionRotate(QuaternionInvert(characterOrientation), position);\n    SDF body = SDFSphere(position - vec3(0.0, colliderRadius, 0.0), colliderRadius);\n    body.material = 3.0;\n    return body;\n}\n\nSDF SceneEvaluate(vec3 position) {\n    SDF scene = SceneEvaluateSphere(position);\n    bool thirdPersonMode = !keyIsToggled(67);\n    if (thirdPersonMode) {\n        SDF character = SceneEvaluateCharacter(position);\n        scene = SDFUnion(scene, character);\n    }\n    return scene;\n}\n\nvec3 SceneGetNormal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        SceneEvaluate(position + vec3(epsilon, 0, 0)).d - SceneEvaluate(position + vec3(-epsilon, 0, 0)).d,\n        SceneEvaluate(position + vec3(0, epsilon, 0)).d - SceneEvaluate(position + vec3(0, -epsilon, 0)).d,\n        SceneEvaluate(position + vec3(0, 0, epsilon)).d - SceneEvaluate(position + vec3(0, 0, -epsilon)).d\n    );\n    return normalize(gradient);\n}\n\nstruct Hit {\n    float t;\n    SDF field;\n};\n\nbool RendererRaycast(vec3 rayOrigin, vec3 rayDirection, inout Hit hit) {\n    int stepCount = 256;\n    float maximumDistance = 100.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        SDF field = SceneEvaluate(currentPosition);\n        if (field.d < 0.001 * max(t, 1.0)) {\n            hit.t = t;\n            hit.field = field;\n            return true;\n        }\n        t += field.d;\n    }\n    hit.t = t;\n    hit.field = SDF(t, 0.0);\n    return true;\n}\n\nbool RendererRaycastAxes(vec3 rayOrigin, vec3 rayDirection, inout Hit hit) {\n    int stepCount = 64;\n    float maximumDistance = 10.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        SDF field = SceneEvaluateAxes(currentPosition);\n        if (field.d < 0.001 * max(t, 1.0)) {\n            hit.t = t;\n            hit.field = field;\n            return true;\n        }\n        t += field.d;\n    }\n    return false;\n}\n\nvec3 RendererGetColor(vec3 rayOrigin, vec3 rayDirection) {  \n    bool thirdPersonMode = !keyIsToggled(67);\n   \n    Hit hit;\n    RendererRaycast(rayOrigin, rayDirection, hit);\n    vec3 color = vec3(1.0);\n    if (hit.t > 0.0) {\n        vec3 position = rayOrigin + rayDirection * hit.t;\n        vec3 normal = SceneGetNormal(position);\n        if (hit.field.material == 3.0) {\n            vec4 characterOrientation = read(bufferOffsetCharacterOrientation);\n            vec3 up = QuaternionRotate(characterOrientation, vec3(0.0, 1.0, 0.0));\n            color = vec3(1.0, 0.0, 0.0) * ((dot(normal, up) + 1.0) * 0.5); \n        } else {\n            color = vec3(0.6);\n            float u = (atan(-position.x, -position.z) / pi + 1.0) * 0.5;\n            float v = 0.5 + asin(position.y / length(position)) / pi;\n            vec2 uv = vec2(u, v);\n            uv *= 16.0;\n            uv = fract(uv * 0.5) - 0.5;\n            float mask = step(uv.x * uv.y, 0.0);\n            color -= vec3(0.2) * mask;\n            if (thirdPersonMode) {\n                // analytical ambient occlusion https://www.shadertoy.com/view/4djSDy\n                vec4 characterOrientation = read(bufferOffsetCharacterOrientation);\n                vec3 characterPosition = read(bufferOffsetCharacterPosition).xyz;\n                characterPosition += QuaternionRotate(characterOrientation, vec3(0.0, colliderRadius, 0.0));\n                characterPosition -= position;\n                float m = length(characterPosition);\n                float angle = dot(normal, characterPosition / m);\n                float h = m / colliderRadius;\n                float occlusion = max(0.0, angle) / (h * h);\n                color *= 1.0 - occlusion;\n            }\n          \n        }\n        color = mix(color, vec3(0.9), 1.0 - exp(-0.003 * hit.t * hit.t));\n    }\n\n    if (thirdPersonMode) {\n        if (RendererRaycastAxes(rayOrigin, rayDirection, hit)) {\n            if (hit.field.material == 4.0) {\n                color = vec3(1.0, 0.0, 0.0);\n            } else if (hit.field.material == 5.0) {\n                color = vec3(0.0, 1.0, 0.0);\n            } else if (hit.field.material == 6.0) {\n                color = vec3(0.15, 0.3, 1.0);\n            }\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 characterOrientation = read(bufferOffsetCharacterOrientation);\n    vec3 cameraPosition = read(bufferOffsetCameraPosition).xyz;\n    vec4 cameraOrientation = read(bufferOffsetCameraOrientation);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(2);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = (2.0 * uv - iResolution.xy) / iResolution.y;\n            vec3 rayOrigin = cameraPosition;\n            vec3 rayDirection = normalize(vec3(uv, fieldOfView));\n            rayDirection = QuaternionRotate(cameraOrientation, rayDirection);\n            vec3 color = RendererGetColor(rayOrigin, rayDirection);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n    result = pow(result, vec3(1.0 / 2.2));\n\tfragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float pi = 3.141592;\n\nfloat colliderRadius = 0.25;\nfloat sphereRadius = 5.0;\nfloat fieldOfView = 1.5; // 67 degrees; 1.0 / tan(angle * 0.5 * PI / 180.0) \n\nfloat friction = 15.0;\nfloat gravity = 15.0;\nbool stickToGround = true;\nfloat walkSpeed = 4.0;\nfloat flySpeed = 10.0;\nfloat groundAcceleration = 20.0;\nfloat airAcceleration = 5.0;\nbool turnWithMouse = true;\nfloat mouseSensitivity = 0.25;\n\nconst ivec2 bufferOffsetCharacterPosition = ivec2(0, 0);\nconst ivec2 bufferOffsetCharacterVelocity = ivec2(1, 0);\nconst ivec2 bufferOffsetCharacterOrientation = ivec2(5, 0);\nconst ivec2 bufferOffsetCameraPosition = ivec2(0, 1);\nconst ivec2 bufferOffsetCameraOrientation = ivec2(4, 1);\nconst ivec2 bufferOffsetProgramState = ivec2(0, 2);\nconst ivec2 bufferOffsetCameraPitch = ivec2(0, 4);\nconst ivec2 bufferOffsetLastMouseState = ivec2(0, 5);\n\nmat3 MatrixFromAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nvec4 QuaternionFromAxisAngle(vec3 axis, float angle) {\n    return vec4(axis * sin(angle * 0.5), cos(angle * 0.5));\n}\n\nvec4 QuaternionMultiply(vec4 lhs, vec4 rhs) {\n    return vec4(\n        lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y,\n        lhs.w * rhs.y - lhs.x * rhs.z + lhs.y * rhs.w + lhs.z * rhs.x,\n        lhs.w * rhs.z + lhs.x * rhs.y - lhs.y * rhs.x + lhs.z * rhs.w,\n        lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z\n    );\n}\n\nvec3 QuaternionRotate(vec4 quaternion, vec3 vector) {\n    vec3 t = 2.0 * cross(quaternion.xyz, vector);\n    return vector + quaternion.w * t + cross(quaternion.xyz, t);\n}\n\nvec4 QuaternionNormalize(vec4 quaternion) {\n    return vec4(quaternion) / length(quaternion);\n}\n\nvec4 QuaternionConjugate(vec4 quaternion) {\n    return vec4(-quaternion.xyz, quaternion.w);\n}\n\nvec4 QuaternionInvert(vec4 quaternion) {\n    return vec4(-quaternion.xyz, quaternion.w) / dot(quaternion, quaternion);\n}\n\nvec4 QuaternionFromMatrix(mat3 r) {\n    float trace = r[0][0] + r[1][1] + r[2][2];\n    vec4 quaternion = vec4(0.0);\n    if (trace > 0.0) {\n        float s = sqrt(trace + 1.0) * 2.0;\n        quaternion.w = 0.25 * s;\n        quaternion.x = (r[1][2] - r[2][1]) / s;\n        quaternion.y = (r[2][0] - r[0][2]) / s;\n        quaternion.z = (r[0][1] - r[1][0]) / s;\n        return quaternion;\n    }\n    if (r[0][0] > r[1][1] && r[0][0] > r[2][2]) {\n        float s = sqrt(1.0 + r[0][0] - r[1][1] - r[2][2]) * 2.0;\n        quaternion.w = (r[1][2] - r[2][1]) / s;\n        quaternion.x = 0.25 * s;\n        quaternion.y = (r[1][0] + r[0][1]) / s;\n        quaternion.z = (r[2][0] + r[0][2]) / s;\n        return quaternion;\n    }\n    if (r[1][1] > r[2][2]) {\n        float s = sqrt(1.0 + r[1][1] - r[0][0] - r[2][2]) * 2.0;\n        quaternion.w = (r[2][0] - r[0][2]) / s;\n        quaternion.x = (r[1][0] + r[0][1]) / s;\n        quaternion.y = 0.25 * s;\n        quaternion.z = (r[2][1] + r[1][2]) / s;\n        return quaternion;\n    }\n    float s = sqrt(1.0 + r[2][2] - r[0][0] - r[1][1]) * 2.0;\n    quaternion.w = (r[0][1] - r[1][0]) / s;\n    quaternion.x = (r[2][0] + r[0][2]) / s;\n    quaternion.y = (r[2][1] + r[1][2]) / s;\n    quaternion.z = 0.25 * s;\n    return quaternion;\n}\n\nvec4 QuaternionLookAt(vec3 target, vec3 from) {\n    vec3 forward = normalize(target - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return QuaternionFromMatrix(mat3(right, up, forward));\n}\n\nmat3 MatrixFromQuaternion(vec4 quaternion) {\n    float x2 = quaternion.x * quaternion.x * 2.0;\n    float y2 = quaternion.y * quaternion.y * 2.0;\n    float z2 = quaternion.z * quaternion.z * 2.0;\n    float xy = quaternion.x * quaternion.y * 2.0;\n    float yz = quaternion.y * quaternion.z * 2.0;\n    float zx = quaternion.z * quaternion.x * 2.0;\n    float xw = quaternion.x * quaternion.w * 2.0;\n    float yw = quaternion.y * quaternion.w * 2.0;\n    float zw = quaternion.z * quaternion.w * 2.0;\n    vec3 column1 = vec3(1.0 - y2 - z2, xy + zw, zx - yw);\n    vec3 column2 = vec3(xy - zw, 1.0 - z2 - x2, yz + xw);\n    vec3 column3 = vec3(zx + yw, yz - xw, 1.0 - x2 - y2);\n    return mat3(column1, column2, column3);\n}\n\nstruct SDF {\n    float d;\n    float material;\n};\n\nSDF SDFBox(vec3 position, vec3 halfSize, float chamferRadius) {\n    position = abs(position) - halfSize + chamferRadius;\n    float d = length(max(position, 0.0)) + min(max(position.x, max(position.y, position.z)), 0.0) - chamferRadius;\n    return SDF(d, 0.0);\n}\n\nSDF SDFSphere(vec3 position, float radius) {\n    float d = length(position) - radius;\n    return SDF(d, 0.0);\n}\n\nSDF SDFSegment(vec3 position, vec3 start, vec3 end, float radius) {\n    position = position - start;\n    end = end - start;\n    float height = min(max(dot(position, end) / dot(end, end), 0.0), 1.0);\n    float d = length(position - end * height);\n    return SDF(d - radius, 0.0);   \n}\n\nSDF SDFArrow(vec3 position, vec3 start, vec3 end, float baseRadius, float tipRadius, float tipHeight) {\n    vec3 t = start - end;\n    float l = length(t);\n    t /= l;\n    l = max(l, tipHeight);\n    position -= end;\n    if (t.y + 1.0 < 0.0001) {\n        position.y = -position.y;\n    } else {\n        float k = 1.0 / (1.0 + t.y);\n        vec3 column1 = vec3(t.z * t.z * k + t.y, t.x, t.z * -t.x * k);\n        vec3 column2 = vec3(-t.x, t.y, -t.z);\n        vec3 column3 = vec3(-t.x * t.z * k, t.z, t.x * t.x * k + t.y);\n        position = mat3(column1, column2, column3) * position;\n    }\n    vec2 q = vec2(length(position.xz), position.y);\n    q.x = abs(q.x);\n    // tip\n    vec2 e = vec2(tipRadius, tipHeight);\n    float h = clamp(dot(q, e) / dot(e, e), 0.0, 1.0);\n    vec2 d1 = q - e * h;\n    vec2 d2 = q - vec2(tipRadius, tipHeight);\n    d2.x -= clamp(d2.x, baseRadius - tipRadius, 0.0);\n    // base\n    vec2 d3 = q - vec2(baseRadius, tipHeight);\n    d3.y -= clamp(d3.y, 0.0, l - tipHeight);\n    vec2 d4 = vec2(q.y - l, max(q.x - baseRadius, 0.0));\n    float s = max(max(max(d1.x, -d1.y), d4.x), min(d2.y, d3.x));\n    float d = sqrt(min(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3)), dot(d4, d4))) * sign(s);\n    return SDF(d, 0.0);\n}\n\nSDF SDFUnion(SDF a, SDF b) {\n    if (a.d < b.d) {\n        return a;\n    }\n    return b;\n}\n\nSDF SceneEvaluateSphere(vec3 position) {\n    SDF sphere = SDFSphere(position, sphereRadius);\n    sphere.material = 1.0;\n    return sphere;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool keyIsPressed(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 0), 0).x > 0.0;\n}\n\nbool keyIsToggled(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 2), 0).x > 0.0;\n}\n\nbool checkBufferOffset(vec2 fragCoord, ivec2 offset) {\n    return int(fragCoord.x) == offset.x && int(fragCoord.y) == offset.y;\n}\n\nvoid write(vec4 value, ivec2 offset, inout vec4 fragColor, vec2 fragCoord) {\n    if (checkBufferOffset(fragCoord, offset)) {\n        fragColor = value;\n    }\n}\n\nvec4 read(ivec2 offset) {\n    return texelFetch(iChannel1, offset, 0);\n}\n\nstruct Camera {\n    vec3 position;\n    vec4 orientation;\n};\n\nvoid CameraLoadState(out Camera camera) {\n    camera.position = read(bufferOffsetCameraPosition).xyz;\n    camera.orientation = read(bufferOffsetCameraOrientation);\n}\n\nvoid CameraSaveState(Camera camera, inout vec4 fragColor, vec2 fragCoord) {\n    write(vec4(camera.position, 0.0), bufferOffsetCameraPosition, fragColor, fragCoord);\n    write(camera.orientation, bufferOffsetCameraOrientation, fragColor, fragCoord);\n}\n\nstruct Character {\n    vec3 position;\n    vec3 velocity;\n    vec4 orientation;\n    vec4 info1;\n};\n\nvoid CharacterLoadState(out Character character) {\n    character.position = read(bufferOffsetCharacterPosition).xyz;\n    character.velocity = read(bufferOffsetCharacterVelocity).xyz;\n    character.orientation = read(bufferOffsetCharacterOrientation);\n}\n\nvoid CharacterSaveState(Character character, inout vec4 fragColor, vec2 fragCoord) {\n    write(vec4(character.position, 0.0), bufferOffsetCharacterPosition, fragColor, fragCoord);\n    write(vec4(character.velocity, 0.0), bufferOffsetCharacterVelocity, fragColor, fragCoord);\n    write(character.orientation, bufferOffsetCharacterOrientation, fragColor, fragCoord);\n}\n\nSDF SceneEvaluate(in vec3 position) {\n    SDF scene = SceneEvaluateSphere(position);\n    return scene;\n}\n\nvec3 SceneGetNormal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        SceneEvaluate(position + vec3(epsilon, 0, 0)).d - SceneEvaluate(position + vec3(-epsilon, 0, 0)).d,\n        SceneEvaluate(position + vec3(0, epsilon, 0)).d - SceneEvaluate(position + vec3(0, -epsilon, 0)).d,\n        SceneEvaluate(position + vec3(0, 0, epsilon)).d - SceneEvaluate(position + vec3(0, 0, -epsilon)).d\n    );\n    return normalize(gradient);\n}\n\nstruct Hit {\n    float t;\n    float fraction;\n    vec3 normal;\n};\n\nbool SceneRaycast(vec3 rayOrigin, vec3 rayDirection, float maximumDistance, inout Hit hit) {\n    int stepCount = 16;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        SDF field = SceneEvaluate(currentPosition);\n        if (field.d < 0.001) {\n            hit.t = t;\n            hit.fraction = t / maximumDistance;\n            hit.normal = SceneGetNormal(currentPosition);\n            return true;\n        }\n        t += field.d * 0.5;\n        if (t > maximumDistance) {\n            return false;\n        }\n    }\n    hit.t = t;\n    hit.fraction = t / maximumDistance;\n    hit.normal = SceneGetNormal(rayOrigin + rayDirection * t);\n    return true;\n}\n\nbool SceneRaycast(vec3 from, vec3 to, inout Hit hit) {\n    float maximumDistance = length(to - from);\n    vec3 rayDirection = normalize(to - from);\n    return SceneRaycast(from, rayDirection, maximumDistance, hit);\n}\n\nstruct Contact {\n    vec3 normal;\n    float penetrationDistance;\n};\n\nbool SceneContactTest(vec3 center, float radius, inout Contact contact) {  \n    SDF field = SceneEvaluate(center);\n    if (field.d < radius) {\n        contact.normal = SceneGetNormal(center);\n        contact.penetrationDistance = abs(field.d - radius);\n        return true;\n    }\n    return false;\n}\n\nvoid CharacterUpdate(inout Character character, Camera camera, float deltaTime) {\n    bool leftPressed = keyIsPressed(65) || keyIsPressed(37);\n    bool rightPressed = keyIsPressed(68) || keyIsPressed(39);\n    bool upPressed = keyIsPressed(87) || keyIsPressed(38);\n    bool downPressed = keyIsPressed(83) || keyIsPressed(40);\n    bool spacePressed = keyIsPressed(32);\n    float xAxis = (leftPressed ? -1.0 : 0.0) + (rightPressed ? 1.0 : 0.0);\n    float yAxis = (upPressed ? 1.0 : 0.0) + (downPressed ? -1.0 : 0.0);\n\n    bool isFlying = keyIsToggled(70);\n    if (isFlying) {\n        character.velocity = QuaternionRotate(camera.orientation, vec3(xAxis, 0.0, yAxis) * flySpeed);\n        character.position += character.velocity * deltaTime;\n    } else {\n        vec3 up = normalize(character.position);\n    \n        Contact contact;\n        bool touchesGround = SceneContactTest(character.position + QuaternionRotate(character.orientation, vec3(0.0, colliderRadius, 0.0) + vec3(0.0, -0.02, 0.0)), colliderRadius, contact);\n   \n        Hit hit;\n        float groundClearance = 1.0;\n        if (SceneRaycast(character.position, character.position + QuaternionRotate(character.orientation, vec3(0.0, -1.0, 0.0)), hit)) {\n            groundClearance = hit.t;\n        } \n        \n        if (touchesGround) {\n            character.info1.w = 5.0;\n        }\n\n        if (touchesGround && groundClearance < 0.2) {\n            float speed = length(character.velocity);\n            if (speed > 0.0001) {\n                float minimumSpeed = 0.5; // minimum speed for friction calculation\n                float newSpeed = max(speed - max(speed, minimumSpeed) * friction * deltaTime, 0.0);\n                character.velocity *= newSpeed / speed;\n            }\n            vec3 verticalVelocity = dot(character.velocity, up) * up;\n            vec3 horizontalVelocity = character.velocity - verticalVelocity;\n            vec3 impulse = QuaternionRotate(character.orientation, vec3(turnWithMouse ? xAxis : 0.0, 0.0, yAxis) * groundAcceleration * walkSpeed);\n            horizontalVelocity += impulse * deltaTime; \n            if (length(horizontalVelocity) > walkSpeed) { // limit horizontal speed to walk speed\n                horizontalVelocity = normalize(horizontalVelocity) * walkSpeed; \n            }\n            character.velocity = horizontalVelocity + verticalVelocity;\n            if (!stickToGround) {\n                character.velocity += (-up * gravity) * deltaTime; \n            }\n        } else {\n            vec3 verticalVelocity = dot(character.velocity, up) * up;\n            vec3 horizontalVelocity = character.velocity - verticalVelocity;\n            vec3 impulse = QuaternionRotate(character.orientation, vec3(turnWithMouse ? xAxis : 0.0, 0.0, yAxis) * airAcceleration * walkSpeed);\n            horizontalVelocity += impulse * deltaTime;  \n            if (length(horizontalVelocity) > walkSpeed) { // limit horizontal speed to walk speed\n                horizontalVelocity = normalize(horizontalVelocity) * walkSpeed; \n            }\n            character.velocity = horizontalVelocity + verticalVelocity;\n            character.velocity += (-up * gravity) * deltaTime; \n        }\n  \n        if (spacePressed) {\n            if (groundClearance < 0.2) {\n                vec3 verticalVelocity = dot(character.velocity, up) * up;\n                character.velocity -= verticalVelocity;\n                character.velocity += up * 5.0; \n            }\n        }\n\n        int stepCount = 5;\n        float stepSize =  deltaTime / float(stepCount);\n        for (int i = 0; i < stepCount; i++) { \n            character.position += character.velocity * stepSize;\n            vec3 center = character.position + QuaternionRotate(character.orientation, vec3(0.0, colliderRadius, 0.0));\n            Contact contact;\n            if (SceneContactTest(center, colliderRadius, contact)) {\n                 character.position += contact.normal * (contact.penetrationDistance + 0.001);\n                 vec3 perpendicularVelocity = dot(character.velocity, contact.normal) * contact.normal;\n                 character.velocity -= perpendicularVelocity;\n            }\n        }\n    }\n   \n    // align orientation with gravity\n    vec3 up = normalize(QuaternionRotate(QuaternionInvert(character.orientation), character.position));\n    vec3 right = normalize(cross(up, vec3(0.0, 0.0, 1.0)));\n    vec3 forward = cross(right, up);\n    vec4 rotation = QuaternionFromMatrix(mat3(right, up, forward));\n    character.orientation = QuaternionMultiply(character.orientation, rotation);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (fragCoord.x > 8.0 || fragCoord.y > 8.0) {\n        discard;\n    }\n    \n    if (fragCoord.y > 2.0 && fragCoord.x > 1.0) {\n        discard;\n    }\n   \n    Character character;\n    CharacterLoadState(character);\n    Camera camera;\n    CameraLoadState(camera);\n    float cameraPitch = read(bufferOffsetCameraPitch).x;\n    float programState = read(bufferOffsetProgramState).x;\n    if (programState == 0.0) {\n        programState = 1.0;\n        character.position.y = sphereRadius;\n        character.orientation = vec4(0.0, 0.0, 0.0, 1.0);\n        cameraPitch = pi * 0.1;\n    } \n    vec4 currentMouseState = iMouse;\n    vec4 lastMouseState = read(bufferOffsetLastMouseState);\n    \n    float deltaTime = 1.0 / 60.0;\n    \n    if (turnWithMouse) {\n        if (currentMouseState.z > 0.0 && lastMouseState.z > 0.0) { // only if mouse is pressed and was pressed before\n            vec2 delta = currentMouseState.xy - lastMouseState.xy;\n            cameraPitch = clamp(cameraPitch - delta.y * deltaTime * mouseSensitivity, -pi * 0.5, pi * 0.5);\n            character.orientation = QuaternionMultiply(character.orientation, QuaternionFromAxisAngle(vec3(0, 1, 0), delta.x * deltaTime * mouseSensitivity));\n        }\n        camera.orientation = QuaternionMultiply(character.orientation, QuaternionFromAxisAngle(vec3(1, 0, 0), cameraPitch));\n    } else {\n        bool leftPressed = keyIsPressed(65) || keyIsPressed(37);\n        bool rightPressed = keyIsPressed(68) || keyIsPressed(39);\n        float xAxis = (leftPressed ? -1.0 : 0.0) + (rightPressed ? 1.0 : 0.0);\n        character.orientation = QuaternionMultiply(character.orientation, QuaternionFromAxisAngle(vec3(0, 1, 0), xAxis * deltaTime * 3.0));\n        camera.orientation = character.orientation;\n    }\n            \n    CharacterUpdate(character, camera, deltaTime);\n    \n    bool firstPersonMode = keyIsToggled(67);\n    if (firstPersonMode) {\n        camera.position = character.position + QuaternionRotate(character.orientation, vec3(0.0, 1.5, 0.0));\n    } else {\n        camera.position = character.position + QuaternionRotate(camera.orientation, vec3(0.0, 0.0, -5.0));\n    }\n       \n    CharacterSaveState(character, fragColor, fragCoord);\n    CameraSaveState(camera, fragColor, fragCoord);\n    write(vec4(programState, 0.0, 0.0, 0.0), bufferOffsetProgramState, fragColor, fragCoord);\n    write(vec4(cameraPitch, 0.0, 0.0, 0.0), bufferOffsetCameraPitch, fragColor, fragCoord);\n    write(currentMouseState, bufferOffsetLastMouseState, fragColor, fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"}]}