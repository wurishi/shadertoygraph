{"ver":"0.1","info":{"id":"tljGRG","date":"1560060228","viewed":255,"name":"Pile space","username":"edo_m18","description":"Pile space","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["cylinder","pile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MlfGzj","filepath":"https://soundcloud.com/elektrik-dreams-music/nicola-cite-borderline-original-mix-out-now-on-beatport","previewfilepath":"https://soundcloud.com/elektrik-dreams-music/nicola-cite-borderline-original-mix-out-now-on-beatport","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCylinder(vec3 p, vec3 c)\n{\n    return length(p.xz - c.xy) - c.z;\n}\n\nfloat map(vec3 p)\n{\n    float i = texture(iChannel0, vec2(0.1, 0.5)).x;\n    \n    float h = 1.8;\n    float grid = 1.3;\n    \n    vec3 g = ceil(p / grid);\n    \n    float rxz = rand(g.xz) * i;\n    \n    p = -abs(p);\n    \n    float d1 = p.y + h + rxz;\n    float d2 = p.x + h * 0.6;\n    \n    vec3 q = Repeat(p, vec3(grid));\n    float dc = sdCylinder(q, vec3(0.1, 0.0, .5));\n    return max(max(d1, dc), d2);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0);\n    float d = map(p);\n    \n    vec3 n = d - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx));\n    return normalize(n);\n}\n\nmat3 camera(vec3 ro, vec3 ta, vec3 up)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(cos(iTime * 0.1), sin(iTime * 0.1), iTime * 5.);\n    vec3 ta = vec3(cos(iTime), sin(iTime), iTime * 5. + 10.);\n    \n    vec3 up = normalize(vec3(0.5, 1.0, 0.0));\n    vec3 ray = camera(ro, ta, up) * normalize(vec3(uv, 1.5));\n    \n    float d = 0., t = 0.;\n    \n    vec3 p = ro;\n    \n    const int MAX_MARCH = 128;\n    int march = 0;\n    for (int i = 0; i < MAX_MARCH; i++)\n    {\n        d = map(p);\n        \n        march = i;\n        \n        if (d < 0.01) break;\n        \n        p += ray * d;\n        t += d;\n    }\n    \n    vec3 col = vec3(0);\n    \n    if (d < 0.01)\n    {\n        vec3 n = getNormal(p);\n        float v = max(0., dot(n, -ray));\n        col = vec3(v);\n    }\n    \n    float fog = min(1.0, (1.0 / float(MAX_MARCH)) * float(march));\n    vec3 rgb = hue2rgb(sin(iTime * 0.1));\n    vec3 fog2 = t * 0.01 * rgb;\n    col = col * fog + fog2;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define Repeat(p, span) mod(p, span) - 0.5 * (span)\n\nfloat rand(vec3 p)\n{\n    return fract(sin(dot(p, vec3(43.5824, 17.394, 30.234)) * 41345.3431));\n}\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p, vec2(43.5824, 17.394)) * 41345.3431));\n}\n\nvec3 hue2rgb(float h)\n{\n    return clamp(abs(mod(h * 6. + vec3(0, 4, 2), 6.) - 3.) - 1., 0., 1.);\n}","name":"Common","description":"","type":"common"}]}