{"ver":"0.1","info":{"id":"wlycWc","date":"1612047464","viewed":56,"name":"Genuary 2021 – 02 – Rule 30 ","username":"endymion","description":"Rule 30 + Triangles. Big props to\n\n* Shane - https://www.shadertoy.com/user/Shane\n* Andrew Hung - https://www.shadertoy.com/user/laserdog\n* Microwerx - https://www.shadertoy.com/user/microwerx","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["triangles","rule30"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nconst vec2 s = vec2(1, .8660254);\nconst vec2 scale = vec2(2., 1.);\nconst ivec2 rule30start = ivec2(500, 500);\n\n/**\n * @overview\n * Big credits go to [*Shane*](https://www.shadertoy.com/user/Shane) \n * and [*Andrew Hung*](https://andrewhungblog.wordpress.com/2018/07/28/shader-art-tutorial-hexagonal-grids/)\n * for explaining hex and triangle grids to me.\n */\n\n/**\n * Hashed vector\n */\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453); }\n\n/**\n * Simple mapping from one range to another\n */\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n/**\n * Get triangle coordinates\n * Big kudos to *Shane* for writing super readable code. \n * @src https://www.shadertoy.com/view/tsVSzG\n */\nvec4 getTriangle(vec2 p, inout float itri) {\n    \n    // Scale coordinates down\n    p /= s;\n    \n    // Offset alternate rows\n    float ys = mod(floor(p.y), 2.) * .5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    \n    // Two triangles pack into each square cell, and each triangle uses the bottom \n    // left point as it's unique identifier. The two points are stored here.\n    vec4 ip4 = floor(p.xyxy + ipY) - ipY + .5; \n    \n    // The local coordinates of the two triangles are stored here.\n    vec4 p4 = fract(p.xyxy - ipY) - .5;\n    \n    // Which triangle are we in? \n    float i = (abs(p4.x) * 2. + p4.y < .5) ? 1. : -1.;\n    itri = i;\n    \n    p4 = i > 0.? vec4(p4.xy * s, ip4.xy) : vec4(p4.zw * s, ip4.zw);  \n    \n    return p4;\n}\n\n/**\n * Get and blend colors. \n * Credits to *Shane* for good blending techniques.\n * @src https://www.shadertoy.com/view/Xljczw\n */\nvec4 getTriangleColor(vec2 st) {\n    float itri;\n    vec4 triangle = getTriangle(st, itri);\n    \n    vec3 v = texelFetch(iChannel0, ivec2(triangle.zw * 10.), 0).rgb;\n    \n    float rnd = hash21(triangle.zw);\n    rnd = sin(rnd * 6.283 + iTime * 0.5) * .5 + .5; // Animating the random number.\n    \n    \n    float blink = smoothstep(0., .125, rnd); // Smooth blinking transition.\n    float blend = dot(sin(st * 3.14159 * 2. - cos(st.yx * 3.14159 * 2.) * 3.14159), vec2(.25)) + .1; // Screen blend.\n    \n    \n    vec3 bg = vec3(0.994, 0.408, 0.6);\n    \n    vec3 colorA = v.r > 0.5 ? vec3(0.998, 0.545, 0.675) : vec3(0.755, 0.407, 0.82);\n    vec3 colorB = v.r > 0.5 ? vec3(0.999, 0.578, 0.843) : vec3(0.719, 0.191, 1.0);\n    \n    vec3 col;\n    float t = smoothstep(0., 1., abs(map(fract(iTime * .075), 0., 1., -1., 1.)));\n    col = max(mix(bg, mix(colorA, colorB, t * 0.75 + st.y * 0.25), blink), 0.); \n    \n    //return vec4(hue(triangle.x), 1.);\n    return vec4(col, 1.);\n}\n\n/**\n * @main\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st *= vec2(1., 1.) *  10.;\n    \n    fragColor = getTriangleColor(st);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * @overview\n * @src https://www.shadertoy.com/view/4dVczK\n * First attempt at running Rule 30 as part of Genuary 2021-02. \n * Huge props to *microwerx* for a bunch of inspiration for this code. \n */\n\n/**\n * @const\n * Colors\n */\nconst vec3 colorBlack = vec3(0.0);\nconst vec3 colorWhite = vec3(1.0);\n\n/**\n * @const\n * Texel states\n */\nconst int painted = 1;\nconst int blank = 0;\n\n/**\n * @const\n * @src https://mathworld.wolfram.com/Rule30.html\n * Rule 30 – basically the first three values are the arguments, the 4th value the outcome\n */\nconst ivec4 rule30set[8] = ivec4[8](\n  ivec4(painted, painted, painted, blank),\n  ivec4(painted, painted, blank, blank),\n  ivec4(painted, blank, painted, blank),\n  ivec4(painted, blank, blank, painted),\n  ivec4(blank, painted, painted, painted),\n  ivec4(blank, painted, blank, painted),\n  ivec4(blank, blank, painted, painted),\n  ivec4(blank, blank, blank, blank)\n);\n\n/**\n * @function\n * Loops through the rules array and outputs the color\n * based on the given parent's states\n */\nvec3 rule30(int a, int b, int c) {\n  for (int i = 0; i < 8; i++) {\n    if (rule30set[i].xyz == ivec3(a, b, c)) \n      return rule30set[i].w == painted ? colorBlack : colorWhite;\n  }\n}\n\n/**\n * @main\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n  \n  // Set fallback colors of parent pixels to white\n  vec3 va = colorWhite;\n  vec3 vb = colorWhite;\n  vec3 vc = colorWhite;\n  \n  // Get texture from buffer (self)\n  vec3 original = texture(iChannel0, uv).rgb;\n  ivec2 iuv = ivec2(fragCoord);\n  ivec2 iwh = ivec2(iResolution.xy);\n\n  // Load parent texel color values\n  if (iuv.x > 0 && iuv.x < iwh.x - 1) {\n    va = texelFetch(iChannel0, iuv + ivec2(-1, 1), 0).rgb;\n    vb = texelFetch(iChannel0, iuv + ivec2( 0, 1), 0).rgb;\n    vc = texelFetch(iChannel0, iuv + ivec2( 1, 1), 0).rgb;\n  }\n  \n  // Determine texel state based on the red channel \n  // we could use any channel here, since we're\n  // painting with black. \n  int a = (va.r < 0.5) ? painted : blank;\n  int b = (vb.r < 0.5) ? painted : blank;\n  int c = (vc.r < 0.5) ? painted : blank;\n  \n  // Look up current fragment's color\n  vec3 color = rule30(a, b ,c);\n\n  // Retain rows from previous render\n  if (iuv.y == iwh.y - 1) {\n    fragColor = vec4(original, 1.0);\n  } else {\n    fragColor = vec4(color, 1.0);\n  }\n\n  // Seed with black at the beginning, then use white for the rest\n  if (iTime < 0.2) {\n    if ((iuv.y == iwh.y - 1) && iuv.x == (iwh.x >> 1)) {\n      fragColor = vec4(colorBlack, 1.0);\n    } else {\n      fragColor = vec4(colorWhite, 1.0);\n    }\n  }\n}","name":"Buffer A","description":"","type":"buffer"}]}