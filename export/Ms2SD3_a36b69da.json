{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Caosdoar 2014 (caosdoar@gmail.com)\n\n// Disable the dispersion or use the real refraction indices.\n#define DISPERSION_ENABLED 1\n#define DISPERSION_EXAGERATED 1\n\n// Constants\nfloat k_air = 1.000277; // Air refraction index\nfloat k_water = 1.333; // Water refraction index\n\n// Red 680nm, Green 532nm, Blue 472nm\n// http://refractiveindex.info/?shelf=main&book=H2O&page=Hale\n#if !DISPERSION_EXAGERATED\nvec3 k_water_rgb = vec3(1.3310, 1.3337, 1.3361); // Practically invisible...\n#else\nvec3 k_water_rgb = vec3(1.32, 1.33, 1.34); // Exagerated!\n#endif\n\n// Spherical to cartesian coordinates\nvec3 sphe2cart(vec2 p)\n{\n    vec2 s = sin(p);\n    vec2 c = cos(p);\n    return vec3(c.x*s.y, c.y, s.x*s.y);\n}\n\n// Ray-sphere intersection\nfloat sphere(vec3 o, vec3 l, vec3 c, float r2)\n{\n    const float eps = 0.0001;\n    \n    float a_ = dot(l,l);\n\tvec3 p = o - c;\n    float b_ = 2.0 * dot(l,p);\n    float c_ = dot(p,p) - r2;\n    \n    float a = b_*b_-4.0*a_*c_;\n    if (a < 0.0) return -1.0;\n    a = sqrt(a);\n    float t2 = -b_ + a;\n    if (t2 < eps) return -1.0;\n    float t1 = -b_ - a;\n    float result = (t1 > eps && t1 < t2) ? t1 : t2;\n    return result * 0.5 / a_;\n}\n\nvec3 refract_snell(vec3 l, vec3 n, float n0, float n1)\n{\n    // Snell's law\n    // http://en.wikipedia.org/wiki/Snell's_law\n    float c = dot(l, -n);\n    float r = n0/n1;\n    float c1 = sqrt(1.0 - r*r*(1.0-c*c));\n    return r*l + (r*c-c1)*n;\n}\n\nvec3 refract_dispersion_sphere(vec3 p, vec3 dir, float refraction_index)\n{\n    vec3 so = vec3(0.0,0.0,3.6);\n    float r = 1.0;\n    float r2 = r*r;\n    float t = sphere(p, dir, so, r2);\n    if (t > 0.0)\n    {\n        p = p+t*dir; // First intersection point\n    \tvec3 normal = normalize(p-so); // Normal of the sphere\n        dir = refract_snell(dir, normal, k_air, refraction_index); // Outside ray refraction\n        float t2 = sphere(p, dir, so, r2);\n        if (t2 > 0.0)\n        {\n            p = p+t2*dir; // Second intersection point\n            normal = normalize(so-p); // Inside normal of the sphere\n            dir = refract_snell(dir, normal, refraction_index, k_air); // Inside ray refraction\n        }\n\t}\n    return dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    /*vec3 co = vec3(0.0, 0.0, 0.0);\n    vec3 cc = sphe2cart(vec2(iTime, 0.0));*/\n    vec3 cc = vec3(0.0,0.0,3.6);\n    vec3 co = 3.6 * sphe2cart(vec2(iTime*0.5, 3.14159*0.5+0.25*sin(iTime))) + cc;\n    vec3 cf = normalize(cc-co);\n    vec3 cr = normalize(cross(cf, vec3(0.0,1.0,0.0)));\n    vec3 cu = normalize(cross(cr, cf));\n    uv *= 3.14159 * 0.25;\n    \n    vec3 rd = normalize(cr*uv.x + cu*uv.y + cf);\n    \n    vec3 dir = rd;\n    vec3 p = co;\n\n\t\n#if !DISPERSION_ENABLED\n    vec3 so = vec3(0.0,0.0,3.6);\n    float r = 1.0;\n    float r2 = r*r;\n    float t = sphere(co, rd, so, r2);\n    if (t > 0.0)\n    {\n        p = p+t*dir;\n    \tvec3 normal = normalize(p-so);\n        dir = refract(rd, normal, k_air, k_water);\n        float t2 = sphere(p, dir, so, r2);\n        if (t2 > 0.0)\n        {\n            p = p+t2*dir;\n            normal = normalize(so-p);\n            dir = refract(dir, normal, k_water, k_air);\n        }\n\t}\n    \n    fragColor = texture(iChannel0, dir);\n#else\n    vec3 dir_r = refract_dispersion_sphere(p, dir, k_water_rgb.r);\n    vec3 dir_g = refract_dispersion_sphere(p, dir, k_water_rgb.g);\n    vec3 dir_b = refract_dispersion_sphere(p, dir, k_water_rgb.b);\n    fragColor = vec4(\n        texture(iChannel0, dir_r).r,\n        texture(iChannel0, dir_g).g,\n        texture(iChannel0, dir_b).b,\n        1.0);\n#endif\n\n    /*\n\t// Test used to validate with mitsubas renderer reference.\n\tt = 5.0 / dir.z - p.z;\n    p = p+t*dir;\n\n    float colour = mod(floor(p.x * 5.0) + floor(p.y * 5.0), 2.0) * 0.5;\n    fragColor = vec4(colour);\n\t*/\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Ms2SD3","date":"1416783158","viewed":842,"name":"Refractive sphere","username":"caosdoar","description":"A simple example on how the Snell's law works.\nThe sphere uses the water index refraction with the red and blue wavelengths exaggerated to show the colour dispersion.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["refraction","water","snell"],"hasliked":0,"parentid":"","parentname":""}}