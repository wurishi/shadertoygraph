{"ver":"0.1","info":{"id":"tddcWj","date":"1601790280","viewed":71,"name":"Sierpinski Torus Interior","username":"rodolphito","description":"Remix of https://www.shadertoy.com/view/MsX3Wj and https://www.shadertoy.com/view/3sfcRj\n\nI threw this together real quick to reproduce hallucination visuals I had","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["torus","sierpinski","interior"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Thank you iquilez for some of the primitive distance functions!\n\n\nconst float AA = 2.0;\nbool docolor = true;\nint depth =8; // Levels of triangle\nfloat pcolorchange = 0.25; // Probability of color change at a given level\n\nconst float PI = 3.14159265358979323846264;\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuint randseed = 1U;\nuint xorshift() {\n  // Xorshift*32\n  // From George Marsaglia: http://www.jstatsoft.org/v08/i14/paper\n  randseed ^= randseed << 13;\n  randseed ^= randseed >> 17;\n  randseed ^= randseed << 5;\n  return randseed;\n}\n\nfloat rand() {\n  return float(xorshift())/pow(2.0,32.0);\n}\n\nvec3 getspherecolor(vec2 z) {\n    \n    z += (z.x + z.y) * -(3.0-sqrt(3.0))/6.0;\n    \n    uint index = uint(floor(dot(floor(z), vec2(5.,7.))));\n    \n    z = fract(z);\n    if (z.x + z.y > 1.) z = 1. - z;\n  float E = 10.0;\n  float t = 0.5;\n  uint epoch = uint((t+0.5*E+1.0)/(E+2.0));\n  t = mod(t,E+2.0)-1.0;\n  t = max(t,0.0);\n  if (t > 0.5*E) t = max(0.5*E,t-1.0);\n  t = min(t,E-t); // t < 0.5*E\n  randseed = ihash(epoch^index+1U); // 0 hashes to 0!\n  vec3 col = hsv2rgb(vec3(rand() + iTime * 0.1,0.8, 0.5 + 50.0 * z.x * z.y * (1. - z.x - z.y)));\n  for (int i = 0; i < depth; i++) {\n    int j;\n    if  (z.x > 0.5) { j = 0; z = 2.0*vec2(z.x-0.5,z.y); }\n    else if (z.y > 0.5) { j = 1; z = 2.0*vec2(z.x,z.y-0.5); }\n    else if (z.x + z.y < 0.5) { j = 2; z = 2.0*z; }\n    else { j = 3; z = 0.5-z; }\n    index = (index << 2) + uint(j);\n    randseed = ihash(epoch^index+1U); // 0 hashes to 0!\n    if (rand() < pcolorchange) col = hsv2rgb(vec3(rand() + iTime * 0.1,0.8,0.5 + 50.0 * z.x * z.y * (1. - z.x - z.y)));\n  }\n  return docolor ? col : vec3(0.8);\n}\n\n\n\nconst int MAX_PRIMARY_RAY_STEPS = 64; //decrease this number if it runs slow on your computer\n\nvec2 rotate2d(vec2 v, float a) { \n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); \n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distanceField(vec3 p) {\n\treturn -sdTorus(p, vec2(4.0, 3.0));\n}\n\nvec3 castRay(vec3 pos, vec3 dir, float treshold) {\n\tfor (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {\n\t\t\tfloat dist = distanceField(pos);\n\t\t\t//if (abs(dist) < treshold) break;\n\t\t\tpos += dist * dir;\n\t}\n\treturn pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 mousePos = (iMouse / iResolution.xyxy) * 2.0 - 1.0;\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraPos = vec3(0.0, 0.0, -3.8);\n\t\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.5);\n\tvec3 planeU = vec3(1.0, 0.0, 0.0) * 0.8;\n\tvec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 1.0, 0.0);\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\t\n\tvec3 rayPos = castRay(cameraPos, rayDir, 0.01);\n\t\n\tfloat majorAngle = atan(rayPos.x, -rayPos.z) * 0.5 + iTime * 0.2;\n\tfloat minorAngle = atan(length(rayPos.xz) - 4.0, rayPos.y) + iTime * 0.1;\n\tvec2 coord = vec2(majorAngle, minorAngle) / PI * 0.5;\n\tvec3 color = getspherecolor(rotate2d(coord + 37., 37.));\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}