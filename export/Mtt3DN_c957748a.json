{"ver":"0.1","info":{"id":"Mtt3DN","date":"1469464394","viewed":386,"name":"Snorlax - Made with editor tool","username":"Nesvi7","description":"An snorlax created with a tool I'm developing inside unity to create raymarched models. This tool will be soon on github too. I don't really like the current materials.\n\nMaking of with the tool: https://twitter.com/nesvi7/status/757549046554824704","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//By Nestor Vina\n\n// ray marching\nconst int max_iterations = 100;\nconst float stop_threshold = 0.02;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst vec3 sunDir = normalize(vec3(1.0,-1.0,1.0));\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n\nvec3 rotate( vec3 p, vec3 rot ){\n    rot.z = -rot.z;\n    /*rot.y = -rot.y;\n    rot.x = -rot.x;*/\n    mat3 ry = mat3(cos(rot.y), 0.0,-sin(rot.y),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(rot.y), 0.0, cos(rot.y)  );\n    \n\tmat3 rz = mat3(cos(rot.z),-sin(rot.z), 0.0,\n\t\t\t   sin(rot.z), cos(rot.z), 0.0,\n\t\t\t   0.0, 0.0, 1.0 );\n     \n\tmat3 rx = mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(rot.x), sin(rot.x), \n\t\t\t   0.0,-sin(rot.x), cos(rot.x) );\n    return p*rz*ry*rx;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opUS( vec2 d1, vec2 d2, float smoothv )\n{\n\treturn vec2(smin(d1.x,d2.x, smoothv), (d1.y<d2.y)?d1.y:d2.y);\n}\n\nfloat grassFloor( vec3 p )\n{    //0.25 0.3\n\treturn -p.y-(texture(iChannel0,p.xz*0.25).xyz+texture(iChannel0,p.xz*0.25).xyz).x*clamp(length(p.xz)/10.0,0.3,0.3) + (sin(length(p.xz*0.2)+iTime)+cos((p.x+p.z)*0.1)) * clamp(length(p.xz)/100.0,0.0,1.0);\n}\n\nfloat animate(float state1, float state2, float speed){\n\treturn mix(state1,state2,(sin(iTime * speed)+1.0)*0.5);\n}\n\nvec3 animate(vec3 state1, vec3 state2, float speed){\n\treturn mix(state1,state2,(sin(iTime * speed)+1.0)*0.5);\n}\n\nvec2 map( vec3 p) {\n    //This is generated with the editor\n    float smoothv = 8.0;\n    vec2 theDistMap;\n    theDistMap = vec2(sdEllipsoid(rotate(p+vec3(0.184,4.657,2.539008),vec3(0,0,1.04074)),vec3(0.7983306,0.3005614,0.3005613)),0.);//SpherePrimitive (21)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-2.004,4.657,2.539008),vec3(0,0,5.24191)),vec3(0.7983306,0.3005614,0.3005613)),0.),smoothv);//SpherePrimitive (20)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-0.33,3.71,2.539008),vec3(0,0,1.04074)),vec3(1.797465,0.6767231,0.676723)),0.),smoothv);//SpherePrimitive (19)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-1.46,3.69,2.539008),vec3(0,0,5.24191)),vec3(1.797465,0.6767231,0.676723)),0.),smoothv);//SpherePrimitive (18)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(p+vec3(-0.9,0.07,2.539008),vec3(2.891563,2.358033,2.458335)),0.),smoothv);//SpherePrimitive (17)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(p+vec3(-2.37,-1.28,2.539008),vec3(1.54646,2.071041,1.581679)),0.),smoothv);//SpherePrimitive (6)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(p+vec3(0.62,-1.28,2.539008),vec3(1.54646,2.071041,1.581679)),0.),smoothv);//SpherePrimitive (5)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(p+vec3(-2.76,-3.44,2.539008),vec3(0.9098507,0.6588253,0.909851)),1.),smoothv);//SpherePrimitive (16)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(1.61,1.53,2.539008),vec3(0,0,0.05597721)),vec3(2.088583,0.8877339,0.856907)),0.),smoothv);//SpherePrimitive (15)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(p+vec3(-0.9,-0.92,2.539008),vec3(3.05492,2.401215,2.595999)),0.),smoothv);//SpherePrimitive (3)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(p+vec3(0.86,-3.44,2.539008),vec3(0.9098507,0.6588253,0.909851)),1.),smoothv);//SpherePrimitive (11)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(p+vec3(-0.9,0.69,2.539008),vec3(2.67366,2.180336,2.273079)),0.),smoothv);//SpherePrimitive (14)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(p+vec3(-0.9,3.46,2.539008),vec3(1.780099,1.520442,1.27847)),0.),smoothv);//SpherePrimitive (13)\n    theDistMap = opUS( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-3.38,1.53,2.539008),vec3(0,0,6.21458)),vec3(2.088583,0.8877339,0.856907)),0.),smoothv);//SpherePrimitive (12)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-2.397,-3.624,2.172),vec3(6.276079,1.48114,0.01412571)),vec3(0.6999256,0.149456,0.149456)),2.));//SpherePrimitive (35)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-2.807,-3.622,2.098),vec3(0.0298735,1.741581,0.04428608)),vec3(0.8622792,0.1841235,0.1841235)),2.));//SpherePrimitive (34)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-3.326,-3.589,2.048),vec3(0.3574849,5.10397,6.271338)),vec3(0.6553322,0.1399339,0.1399339)),2.));//SpherePrimitive (33)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(0.388,-3.721,2.184),vec3(0,1.570796,0)),vec3(0.6553322,0.1399339,0.1399339)),2.));//SpherePrimitive (32)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(0.858,-3.782,2.232),vec3(0.05113041,1.161677,0.01545978)),vec3(0.8622792,0.1841235,0.1841235)),2.));//SpherePrimitive (31)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(1.269,-3.75,2.45),vec3(0.003413021,0.7975222,0.01543972)),vec3(0.8622792,0.1841235,0.1841235)),2.));//SpherePrimitive (30)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-5.115,1.524,2.177),vec3(0,0,0.008595686)),vec3(0.4133087,0.08935363,0.08935362)),2.));//SpherePrimitive (29)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-5.286,1.723,2.386),vec3(0,0,0.008595686)),vec3(0.4133087,0.08935363,0.08935362)),2.));//SpherePrimitive (28)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-5.286,1.723,2.625),vec3(0,0,0.008595686)),vec3(0.4133087,0.08935363,0.08935362)),2.));//SpherePrimitive (27)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(-5.286,1.668,2.831),vec3(0,0,0.008595686)),vec3(0.4133087,0.08935363,0.08935362)),2.));//SpherePrimitive (26)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(3.54,1.55,2.831),vec3(0,0,0.008595686)),vec3(0.4133087,0.08935363,0.08935362)),2.));//SpherePrimitive (25)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(3.54,1.605,2.625),vec3(0,0,0.008595686)),vec3(0.4133087,0.08935363,0.08935362)),2.));//SpherePrimitive (24)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(3.54,1.605,2.386),vec3(0,0,0.008595686)),vec3(0.4133087,0.08935363,0.08935362)),2.));//SpherePrimitive (23)\n    theDistMap = opU( theDistMap,vec2(sdEllipsoid(rotate(p+vec3(3.426,1.406,2.177),vec3(0,0,0.008595686)),vec3(0.4133087,0.08935363,0.08935362)),2.));//SpherePrimitive (22)\n\n    //End of generated part\n    theDistMap = opU( theDistMap,vec2(grassFloor(p + vec3(0.0,-4.0,0.0)),4.0));    \n    return theDistMap;\n}\n\n// ray marching\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}\n\t}\n\treturn vec2(end,-1.0);\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( -xy, -z ) );\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nvec3 snorlaxNail( vec3 v, vec3 n, vec3 eye ) {\n    vec3 albedo = vec3(1.0,0.9,0.9);\n    vec3 ambient = vec3(0.05,0.05,0.05);\n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    vec3 diffuse = vec3(0.4,0.4,0.4)*dot(sunDir,n);\n    return albedo+diffuse;\n}\n\nvec3 snorlaxBodySpot( vec3 v, vec3 n, vec3 eye ) {\n    vec3 albedo = vec3(0.937,0.847,0.690);\n    vec3 ambient = vec3(0.05,0.05,0.05);\n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(1.0,0.0,0.0) * fresnel(n,viewDir,2.0);    \n    vec3 diffuse = vec3(0.2)*dot(sunDir,n);\n    return mix(albedo,fresnelColor,0.15)+diffuse;\n}\n\nvec3 snorlaxBlack( vec3 v, vec3 n, vec3 eye ) {\n    vec3 albedo = vec3(0.1,0.1,0.1);\n    vec3 ambient = vec3(0.05,0.05,0.05);    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);\n    vec3 diffuse = vec3(0.2)*dot(sunDir,n);\n    return albedo+diffuse;\n}\n\nvec3 snorlaxBody( vec3 v, vec3 n, vec3 eye ) {\n    \n    float distToSpot = sdEllipsoid(v+vec3(-0.9,0.17,0.52),vec3(2.633887,2.86443,2.633886));\n    distToSpot = min( distToSpot,sdEllipsoid(v+vec3(-0.9,3.2,0.84),vec3(1.464067,1.592216,1.464067)));\n    distToSpot = max( distToSpot, -sdEllipsoid(rotate(v+vec3(-0.9,10.24,3.03),vec3(0.2538913,0,0)),vec3(0.7843115,6.743474,0.7843112)));\n    \n    float eyes = sdEllipsoid(rotate(v+vec3(-1.502,3.537,1.162),vec3(5.546469,0,0)),vec3(0.5,0.1721386,0.5));\n    eyes = min( eyes, sdEllipsoid(rotate(v+vec3(-0.398,3.537,1.162),vec3(5.546469,0,0)),vec3(0.5,0.1721386,0.5)));\n    eyes = sdEllipsoid(rotate(v+vec3(-1.502,3.537,1.162),vec3(5.546469,0,0)),vec3(0.5,0.1721386,0.5));\n    \n    float rightEye = sin(v.x*1.0+3.2)-v.y - 2.9;\n    rightEye += clamp((v.x-1.8)*10000.0,0.0,100.0);\n    rightEye += clamp((-v.x+1.1)*10000.0,0.0,100.0);\n    \n    float leftEye = sin(v.x*1.0-1.8)-v.y - 2.9;\n    leftEye += clamp((v.x-0.7)*10000.0,0.0,100.0);\n    leftEye += clamp((-v.x+0.0)*10000.0,0.0,100.0);\n    \n    eyes = min(rightEye, leftEye);\n    \n    float mouth = sin(v.x*0.5+1.1)*2.0-v.y - 5.2;\n    mouth += clamp((v.x-1.6)*10000.0,0.0,100.0);\n\tmouth += clamp((-v.x+0.2)*10000.0,0.0,100.0);\n    \n    if( distToSpot <= 0.02 ){\n        if(eyes <= 0.00001 && eyes >= -0.06)\n            return snorlaxBlack(v,n,eye);\n        else if( mouth <= 0.0001 && mouth > -0.06 ){\n        \t return snorlaxBlack(v,n,eye);\n        }\n        else\n        \treturn snorlaxBodySpot(v,n,eye);        \n    }\n    \n    vec3 albedo = vec3(0.105,0.341,0.48627);\n    vec3 ambient = vec3(0.05,0.05,0.05);\n    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.0,0.0,0.2) * fresnel(n,viewDir,2.0);    \n    \n    vec3 diffuse = vec3(0.2)*dot(sunDir,n);\n   \n    return albedo+diffuse+fresnelColor;\n}\n\nfloat shadowCast( vec3 origin, vec3 dir, float start, float end ){\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n\t\tif ( dist <= stop_threshold ) \n\t\t\treturn 0.0;\n\t\tdepth += dist;\n\t\tif ( depth >= end) return 1.0;\n\t}\n\treturn 1.0;\n}\n\nvec3 floorShading( vec3 v, vec3 n, vec3 eye ){  \n    vec3 tintColor = vec3(0.2,0.5,0.0);\n    float height = (texture(iChannel0,v.xz*0.25).x+texture(iChannel0,v.xz*0.25).x);\n    height = clamp (height, 0.0,3.0);\n    vec3 albedo = height * tintColor*1.5;\n    \n    vec3 normal = texture(iChannel1,v.xz*0.05).xyz;\n    \n    vec3 lightColor = vec3(0.2,0.2,0.2);\n    float shadow = clamp(shadowCast(v,sunDir,0.5,100.0),0.0,1.0);\n    vec3 diffuse = clamp(albedo*dot(sunDir,n),0.0,1.0)*0.5;\n    \n    return diffuse + shadow*lightColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, -2.0, 16.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2(0.4,iMouse.x/iResolution.x*10.0));//vec2(-0.2, iTime/2.0 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n    vec3 fogColor = vec3(0.3,0.6,0.9);\n\t// ray marching\n    vec2 rayResult = ray_marching( eye, dir, 0.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n\t\tfragColor = vec4(fogColor,1.0);//Background color\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );    \n    \n    if( rayResult.y == 0.0 )\n    \tfragColor = vec4(snorlaxBody( pos, n, eye ), 1);\n    else if( rayResult.y == 1.0)\n    \tfragColor = vec4(snorlaxBodySpot( pos, n, eye ),1.0);\n    else if( rayResult.y == 2.0 )\n        fragColor = vec4(snorlaxNail( pos, n, eye ),1.0);\n    else if( rayResult.y == 4.0 )\n        fragColor = vec4(floorShading( pos, n, eye ),1.0);\n    fragColor = vec4(mix( fragColor.xyz,fogColor, clamp((depth-20.0)*0.006,0.0,1.0)),1.0);\n}","name":"Image","description":"","type":"image"}]}