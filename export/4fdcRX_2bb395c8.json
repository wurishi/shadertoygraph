{"ver":"0.1","info":{"id":"4fdcRX","date":"1730957200","viewed":36,"name":"Kleinian Mimick","username":"IgorZdrowowicz","description":"based on my previous \"deformed kleinian\" shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","kleinian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//use mouse!\n//golfed by Gigachad FabriceNeyret2\n//beta version commented below :)\n\n#define cinv(z)   vec2( (z).x, -(z).y ) / dot(z, z)\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         M = iMouse.xy, c,\n         z = 5.*  ( u+u - R ).yx / R.y + .8; \n         z.y *= -1.;\n       \n    c = clamp( length(M) > 30. \n                  ? M / R\n                  : cos(iTime*.5 + vec2(0,33)) * .5 + .7,\n                0.,1.) * .2 - .1\n                       + vec2(.31,.11);\n   \n    for (int i; i++ < 333; )    \n        z = exp2(z.x) * cos( z.y * log(2.) + vec2(0,11) ), // cpow( vec2(2,0), z)\n        z += cinv( mat2(z,-z.y,z) * c ), // cinv( cmul(z, c) )\n        z = cinv(-z*.49 + vec2(2, 0) ),            \n        z = cinv( z + vec2(.16, 0)),       \n        z = cinv( z - vec2(2, 0) ),\n        z = cinv( z - vec2(.15, 0));\n        \n    float l = length(z);\n    O = l > 11. ? vec4(l, 1, 1, 0) : vec4(0);\n}\n\n//\n//vec2 complex_mult(vec2 a, vec2 b)\n//{\n//    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n//}\n\n//vec2 rotate(vec2 v, float angle) \n//{\n//    angle = angle * (3.14159 / 180.0);\n//    float c = cos(angle);\n//    float s = sin(angle);\n//    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n//}\n\n//vec2 complex_pow(vec2 z1, vec2 z2)\n//{\n//    float a2b2 = z1.x * z1.x + z1.y * z1.y;\n//    float t1 = pow(a2b2, z2.x / 2.0) * exp(-z2.y * atan(z1.y, z1.x));\n//    float t2 = z2.x * atan(z1.y, z1.x) + 0.5 * z2.y * log(a2b2);\n//    return vec2(t1 * cos(t2), t1 * sin(t2));\n//}\n//\n//vec2 circinv(vec2 z)\n//{\n//    float dotz = dot(z, z);\n//    return vec2(z.x / dotz, -z.y / dotz);\n//}\n//\n//void mainImage(out vec4 fragColor, in vec2 fragCoord)\n//{\n//    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;    \n//    vec2 z = (uv * 10.0) + 0.8; \n//    z = rotate(z, -90.0);\n//    vec2 power_base = vec2(2.0, 0.0);    \n//    float scale_factor = -0.49;\n//    vec2 mouse = iMouse.xy;\n//\n//if (length(iMouse.xy) < 30.0) \n//{\n//    mouse.x = cos(iTime * 0.5) * 0.5+ 0.7;\n//    mouse.y = sin(iTime * 0.5) * 0.5+ 0.7;\n//    mouse *= iResolution.xy;\n//}\n//    mouse = (mouse.xy / iResolution.xy - 0.5) * 2.0;\n//    \n//    float bCx = 0.3;  \n//    float bCy = 0.1;  \n//    vec2 c = vec2(\n//        \n//        bCx + clamp(mouse.x * 0.1, -0.1, 0.1) + 0.01,       \n//        bCy + clamp(mouse.y * 0.1, -0.1, 0.1) + 0.01\n//    );\n//    vec2 c1 = vec2(2.0, 0.0);\n//    vec2 c2 = vec2(0.16, 0.0);\n//    vec2 c3 = vec2(-2.0, 0.0);\n//    vec2 c4 = vec2(-0.15, 0.0);\n//    \n//    for (int i = 0; i < 333; i++)\n//    {    \n//        vec2 z_pow = complex_pow(power_base, z);        \n//        z = z_pow;\n//        vec2 z_mul = complex_mult(z, c);   \n//        z = z + circinv(z_mul);\n//        z *= scale_factor;\n//        z += c1;\n//        z = circinv(z);       \n//        z += c2;        \n//        z = circinv(z);        \n//        z += c3;       \n//        z = circinv(z);        \n//        z += c4;        \n//        z = circinv(z);\n//    } \n//        \n//    float leng = length(z);\n//\n//    if (leng > 11.) \n//    {\n//    fragColor = vec4(leng, 1.0, 1.0, 0.0);\n//    } \n//    else \n//    {       \n//    fragColor = vec4(0.0, 0.0, 0.0, 1.0);      \n//    }\n//}\n","name":"Image","description":"","type":"image"}]}