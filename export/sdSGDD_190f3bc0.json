{"ver":"0.1","info":{"id":"sdSGDD","date":"1617457564","viewed":112,"name":"Planet with an atmosphere","username":"chrizzo","description":"A planet with a simple atmosphere. The atmosphere is calculated as N equally spaced shells around the planet with exponentially decaying density. ","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["planet","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 base = texture(iChannel0, fragCoord / iResolution.xy);\n    vec4 atmosphere = texture(iChannel1, fragCoord / iResolution.xy);\n    vec4 universe = texture(iChannel2, fragCoord / iResolution.xy);\n    \n    vec4 obscuredUniverse = clamp(universe - atmosphere * 2.0, 0.0, 1.0);\n    \n    vec3 color = base.xyz + atmosphere.xyz + obscuredUniverse.xyz;\n    // Output to screen\n    fragColor = vec4(color.xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float RADIUS = 0.3;\nconst vec2 CENTER = vec2(0.6, 0.6);\n\nconst int ATMOSPHERE_STEPS = 8; // number of iterations\nconst float ATMOSPHERE_SIZE = 0.03; // atmosphere size relative to the unit sphere\nconst float ATMOSPHERE_DENSITY = 8000.0; // \n\n// minimum density to render. \nconst float ATMOSPHERE_EPSILON = 0.005;\n\n// Must fulfill:= exp(-ATMOSPHERE_SIZE * ATMOSPHERE_FALLOFF - 1) <= ATMOSPHERE_EPSILON\nconst float ATMOSPHERE_FALLOFF = (log(1.0 / ATMOSPHERE_EPSILON) - 1.0) / ATMOSPHERE_SIZE; \n\nconst float RAYLEIGH_SCATTERING_STRENGTH = 2.0;\n\nconst float TIME_SCALE = -2.0;\n\n\n/*\n * Convert a point on the unit circle in the xy plane\n * to the point on the unit sphere with positive Z\n */\nvec3 diskToSphere(vec2 xy) {\n    // Sphere: x ** 2 + y ** 2 + z ** 2 = 1\n    float zSquare = 1.0 - xy.x * xy.x - xy.y * xy.y;\n    return vec3(xy, sqrt(zSquare));\n}\n\n\n/**\n * A simplified model for rayleigh scattering, linearly blending together \n * a sunset-red and daylight-blue sky\n */\nvec3 rayleighScatter(vec3 color, float amount) {\n    const vec3 rayleighWeights = pow(465.0 / vec3(620, 535, 465), vec3(4.0));\n    vec3 rayleighModifier = pow(rayleighWeights, vec3(1.0 - RAYLEIGH_SCATTERING_STRENGTH * amount));\n    return color * rayleighModifier;\n}\n\n/**\n * A simplified model for rayleigh scattering, linearly blending together \n * a sunset-red and daylight-blue sky\n */\nvec3 rayleighScatterDiffuse(vec3 color, float amount) {\n    const vec3 rayleighWeights = pow(465.0 / vec3(620, 535, 465), vec3(4.0));\n    return color * (1.0 + amount * (1.0 - rayleighWeights));\n}\n\n/**\n * Atmosphere density at an altitude above the unit sphere\n */\nfloat atmosphereDensity(float altitude) {\n    return exp(-(ATMOSPHERE_FALLOFF * altitude + 1.0));\n}\n\n\n/**\n * Calculates the Z distance to the surface or the rear-facing side of the atmosphere.\n */\nfloat depthAtPoint(vec3 xyz, float radiusRatio) {\n    float zprime = diskToSphere(xyz.xy / radiusRatio).z * radiusRatio;\n    float zrear = length(xyz.xy) > 1.0 ? -zprime : xyz.z;\n    float inRadius = length(xyz.xy) < radiusRatio ? 1.0 : 0.0;\n    return inRadius * (zprime - zrear);\n}\n\n\n/**\n * Calculates the Z distance to the surface or the rear-facing side of the atmosphere.\n */\nfloat depthAtAltitude(vec3 xyz, float altitude) {\n    float radiusRatio = 1.0 + altitude;\n    float zprime = diskToSphere(xyz.xy / radiusRatio).z * radiusRatio;\n    float zrear = length(xyz.xy) > 1.0 ? -zprime : xyz.z;\n    float inRadius = length(xyz.xy) < radiusRatio ? 1.0 : 0.0;\n    return inRadius * (zprime - zrear);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iDate[3] * TIME_SCALE;\n    vec3 solDir = normalize(vec3(sin(time * 0.1), 0.5 * cos(time * 0.1 - 1.57), 0.866 * cos(time * 0.1)));\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 center = iResolution.xy * CENTER;\n    float radius = length(iResolution.xy) * RADIUS;\n    vec2 rxy = (fragCoord - center);\n    vec2 normalxy = rxy / radius;\n    vec3 normalxyz = diskToSphere(normalxy);\n    \n    vec3 bump0 = texture(iChannel0, normalxyz * iChannelResolution[0] * 0.005).xyz - 0.5;\n    vec3 bump1 = texture(iChannel0, normalxyz * iChannelResolution[0] * 0.01).xyz - 0.5;\n    vec3 bump2 = texture(iChannel0, normalxyz * iChannelResolution[0] * 0.02).xyz - 0.5;\n    vec3 bump3 = texture(iChannel0, normalxyz * iChannelResolution[0] * 0.04).xyz - 0.5;\n    vec3 bump = bump0 + 0.5 * bump1 + 0.25 * bump2 + 0.125 * bump3;\n    \n    vec3 realxyz = normalize(normalxyz + 0.2 * bump);\n    \n    float diffuseLight = 0.03 + 0.97 * clamp(dot(solDir, realxyz), 0.0, 1.0);\n    \n    float inRadius = length(normalxy) < 1.0 ? 1.0 : 0.0;\n    \n    \n    float discriminant = dot(solDir, -normalxyz) - sqrt(pow(length(-normalxyz), 2.0) - 1.0);\n    float isNearTangent = 1.0 - clamp(-float(discriminant), 0.0, 1.0);\n\n    \n    float ocean = dot(realxyz, bump) < -0.1 ? 1.0 : 0.0;\n    float b = 0.2;\n    float r = dot(realxyz, bump) > 0.5 ? 1.0 : 0.0;\n    float g = 1.0 - ocean;\n    vec3 diffuseColor = 0.7 * vec3(0.1 * r + 0.9 * g, g, b) * diffuseLight;\n    \n\n    vec3 halfway = (normalize(normalxyz) + solDir) / 2.0;\n    float specularLight = dot(halfway, normalxyz);\n    \n    vec3 specularColor = vec3(ocean * pow(abs(specularLight), 9.0));\n\n    vec3 col = diffuseColor + specularColor;\n\n    fragColor = vec4(col * inRadius,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iDate[3] * TIME_SCALE;\n    float atmosphere_size = ATMOSPHERE_SIZE;\n    \n    vec3 solDir = normalize(vec3(sin(time * 0.1), 0.5 * cos(time * 0.1 - 1.57), 0.866 * cos(time * 0.1)));\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 center = iResolution.xy * CENTER;\n    float radius = length(iResolution.xy) * RADIUS;\n    \n    \n    vec2 rxy = (fragCoord - center);\n    vec2 unitxy = rxy / radius;\n    vec3 unitxyz = diskToSphere(unitxy);\n    \n    float light = clamp(0.0, 1.0, dot(solDir, unitxyz));\n    \n    int steps = ATMOSPHERE_STEPS;\n    float stepsize = atmosphere_size / float(steps);\n        \n    vec3 atmosphere = vec3(0.0);\n    for (int i = 1; i <= steps; i++ ) {\n        float altitude = float(i) * stepsize;\n        float radiusRatio = 1.0 + altitude;\n        float depth = depthAtAltitude(unitxyz, altitude);\n    \n        vec3 atmospherexyz = diskToSphere(unitxyz.xy / radiusRatio) * radiusRatio;\n        // estimator for sunset\n        // derived from circle-ray intersection discriminant term\n        float discriminant = dot(-solDir, atmospherexyz) - sqrt(pow(length(atmospherexyz), 2.0) - 1.0);\n        float isNearTangent = 1.0 - clamp(-float(discriminant), 0.0, 1.0);\n        float value = (1.0 - isNearTangent) * depth * atmosphereDensity(altitude);\n        vec3 color = rayleighScatter(vec3(value), isNearTangent);\n        atmosphere += color;\n    }\n        \n    fragColor = vec4((ATMOSPHERE_DENSITY * stepsize) * atmosphere,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * TIME_SCALE;\n    vec3 solDir = normalize(vec3(sin(time), 0.5 * cos(time - 1.57), 0.866 * cos(time)));\n    \n    vec4 noiseA = texture(iChannel0, (fragCoord) / iChannelResolution[0].xx);\n    vec4 noiseB = texture(iChannel0, (fragCoord*1.6) / iChannelResolution[0].xx + 0.5);\n    vec4 noiseC = texture(iChannel0, (fragCoord) / iChannelResolution[0].xx + 0.8);\n    vec3 starmap = vec3(2.0) * noiseC.x * float(noiseA.x + noiseB.x > 1.75);\n    \n    vec2 center = iResolution.xy * CENTER;\n    float radius = length(iResolution.xy) * RADIUS;\n    vec2 rxy = (fragCoord - center);\n    vec2 normalxy = rxy / radius;\n    float obscured = float(length(normalxy) > 1.0);\n    \n    fragColor = vec4(vec3(starmap * obscured), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}