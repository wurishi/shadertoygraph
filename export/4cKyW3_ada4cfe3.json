{"ver":"0.1","info":{"id":"4cKyW3","date":"1732486303","viewed":191,"name":"RT Glacial Valleys","username":"Kerdek","description":"A mountain terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["noise","terrain","fbm","ice","snow","mountain","erosion"],"hasliked":0,"parentid":"NscGWl","parentname":"Glacial valleys"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// linear sRGB component to nonlinear sR'G'B' component\nfloat srgb_gamma(\n  float v) {\n  return v <= 0.0031308\n    ? v * 12.92\n    : 1.055 * pow(v, 0.41666666666) - 0.055; }\n\nvec3 srgb_gamma(\n  vec3 v) {\n  return vec3(\n    srgb_gamma(v.r),\n    srgb_gamma(v.g),\n    srgb_gamma(v.b)); }\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n  o = texelFetch(iChannel0, ivec2(u), 0);\n  o.rgb /= o.a;\n  o.rgb = max(vec3(0.0), o.rgb);\n  o.rgb = srgb_gamma(o.rgb);\n  o.a = 1.0; }","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uint seed;\n\nvoid srand(uvec3 coord) {\n  uvec3 p = uvec3(37769685u, 26757677u, 20501397u) * coord;\n  seed = p.x ^ p.y ^ p.z; }\n\nfloat unitrand() {\n  return pow(2.0, -32.0) * float(seed *= 594156893u); }\n\nfloat boxrand() {\n  return pow(2.0, -32.0) * float(int(seed *= 594156893u)); }\n\nvec3 axial(\n  vec3 n,\n  float v) {\n  float u = 6.28318530718 * boxrand();\n  float r = sqrt(1.0 - pow(v, 2.0));\n  vec3 t = normalize(abs(n.y) < 0.5 ? vec3(-n.z, 0.0, n.x) : vec3(-n.y, n.x, 0.0));\n  vec3 b = cross(n.xyz, t.xyz);\n  return vec3(v * n.xyz + r * (cos(u) * t + sin(u) * b)); }\n\nvec3 power_icdf(vec3 spec_dir, float power) {\n  return axial(spec_dir, pow(unitrand(), 1.0 / (power + 1.0))); }\n\nfloat PI = acos(-1.0);\nconst float inv_4pi = 0.07957747154;\n\nfloat power_pdf(\n  vec3 spec_dir,\n  float power,\n  vec3 rd) {\n  return (power + 1.0) / (2.0 * PI) * pow(max(0.0, dot(spec_dir, rd)), power); }\n\nmat2 rotate2D(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r)); }\n\n\nvec2 fluid(vec2 uv){\n  float turbulence = 5.0;\n  vec2 result = uv;\n  for (float i = 1.; i < 3.; i += 1.) {\n    float s2 = (sin(uv.x*i))/turbulence;\n    uv.y += s2;\n    float s1 = cos(uv.y*i)/turbulence;\n    uv.x += s1;\n    uv=uv.yx; }\n  return (uv-result).yx; }\n\nvec3 fbm0(in vec2 uv) {\n  float value = 0.0;\n  float amplitude = 0.75, n2 = 0.0;\n  vec2 n1 = vec2(0.0);\n  float terrain_scale = 1.0;\n  uv *= terrain_scale;\n  vec2 uv1 = uv;\n  uv += uv;\n  for (int i = 0; i < 18; i++)\n  {\n    vec2 f1 = fluid(uv).yx;\n    uv += f1;\n    n1 = f1;\n    uv1 = uv;\n    n2 = n1.x + n1.y;\n    value -= abs(n2) * amplitude;\n    value = sqrt(value * value + 0.0001);\n    amplitude *= 0.37;\n    uv += uv; }\n  return vec3(value/terrain_scale,uv); }\n\nfloat fbm(vec2 uv){\n  return fbm0(uv).x; }\n\nfloat map(vec3 p) {\n  return 0.4 * (p.y - fbm(p.xz)); }\n\nfloat eps = 1e-3;\n\nvec3 getNormal(vec3 p) {\n  float d = map(p);\n  vec2 e = vec2(eps, 0);\n  return normalize(d - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx))); }\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww); }\n\nfloat logistic(float x) {\n  return exp(x) / (exp(x) + 1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  srand(uvec3(fragCoord, iFrame));\n  float sun_size = 0.00000951927;\n  float sun_cosine = 1.0 - sun_size;\n  float sun_density = 1.0 / sun_size;\n  const vec3 sun_dir = normalize(vec3(-.8, .15, -.3));\n  \n  vec2 uv = (fragCoord - iResolution.xy * .5 + boxrand()) / length(iResolution.xy);\n  vec3 camPos = vec3(8., 2., 5.);\n  vec3 camTarget = vec3(1., 1., 4.);\n  mat3 mat = lookAt(camPos, camTarget, 0.0);\n  vec3 ro = camPos;\n  ro.y += fbm(ro.xz)-1.8;\n  vec3 rd = normalize(mat * vec3(uv.xy, 0.5));\n  rd.xz *= rotate2D(1.0);\n  float t = 0.0;\n  float tp = 1.0;\n  vec3 Lo = vec3(0.0);\n  for(int i = 0; i < 2048; i++) {\n    vec3 p = ro + t * rd;\n    if (t > 20.0) {\n      vec3 col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n\t\tvec2 sc = ro.xz + rd.xz*(250000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/250.0)) );\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n      if (dot(rd, sun_dir) > sun_cosine) {\n        col += sun_density; }\n      Lo += tp * col;\n      break; }\n    float h = map(p);\n    if(h < eps) {\n      vec3 n = getNormal(p);\n      if (dot(rd, n) > 0.0) {\n        t += h + eps;\n        continue; }\n      ro = p; t = 0.0;\n      vec3 sun_rd = axial(sun_dir, 1.0 - sun_size * unitrand());\n      vec3 bsdf_rd = power_icdf(n, 1.0);\n      float sun_prob = dot(sun_rd, n) > 0.0 ? 1.0 : 0.0;\n      float bsdf_prob = 1.0;\n      float prob_sum = sun_prob + bsdf_prob;\n      if (prob_sum == 0.0) {\n        break; }\n      sun_prob /= prob_sum;\n      bsdf_prob /= prob_sum;\n      float roll = unitrand();\n      rd =\n        roll < sun_prob ? sun_rd :\n        bsdf_rd;\n      float sun_dist = rd == sun_rd || dot(rd, sun_dir) >= sun_cosine ? 2.0 * sun_density * inv_4pi : 0.0;\n      float bsdf = power_pdf(n, 1.0, rd);\n      float dist = bsdf_prob * bsdf + sun_prob * sun_dist;\n      if (dist == 0.0) {\n        break; }\n      tp *= (0.2 + 0.6 * logistic(50.0 * p.y - 8.0)) * bsdf / dist; }\n    t += h; }\n  fragColor = vec4(Lo, 1.0);\n  fragColor += texelFetch(iChannel0, ivec2(fragCoord), 0); }","name":"Buffer A","description":"","type":"buffer"}]}