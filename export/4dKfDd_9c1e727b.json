{"ver":"0.1","info":{"id":"4dKfDd","date":"1559925657","viewed":1463,"name":"Morning Dew","username":"BigWIngs","description":"See comments","likes":46,"published":1,"flags":64,"usePreview":1,"tags":["drops"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ldSXzt","filepath":"https://soundcloud.com/pauldavids/looping-1","previewfilepath":"https://soundcloud.com/pauldavids/looping-1","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Morning Dew by Martijn Steinrucken aka BigWings - 2019\n// Twitter: @The_ArtOfCode\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Music - Paul Davids - Live Looping 1\n// https://soundcloud.com/pauldavids/looping-1\n\n#define MAX_STEPS 200\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 50.\n#define RAY_PRECISION 0.03\n\n#define REFLECTIONS\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nvec2 m; // mouse\n\nfloat X2(float x) {return x*x;}\n\nfloat N31(vec3 t) {return fract(sin((t.x+t.y*10.+ t.z*100.)*9e2));}\nvec4 N14(float t) {return fract(sin(vec4(1., 3., 5., 7.)*9e2));}\n\nfloat LN(float x) {return mix(N(floor(x)), N(floor(x+1.)), fract(x));}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\n\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n    float d;\t// distance to the object\n    float md;\t// closest distance\n    float m; \t// material\n    vec3 p;\t\t// world space position\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n};\n\n\nray GetRay(vec2 uv, vec3 p, vec3 lookAt, float zoom, vec3 up) {\n\t\n    vec3 f = normalize(lookAt-p),\n    \t r = normalize(cross(up, f)),\n    \t u = cross(f, r),\n    \t c = p+f*zoom,\n         i = c+r*uv.x+u*uv.y;\t// point in 3d space where cam ray intersects screen\n    \n    ray cr;\n    \n    cr.o = p;\t\t\t\t\t\t\n    cr.d = normalize(i-p);\t\t// ray dir is vector from cam pos to screen intersect \n\treturn cr;\n}\n\nfloat remap01(float a, float b, float t) { return (t-a)/(b-a); }\nfloat remap(float a, float b, float c, float d, float t) { return sat((b-a)/(t-a)) * (d-c) +c; }\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd));\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/rect.zw;\n}\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\n\n\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return length(p-pos)-s; }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec3 c ) {\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nmat2 Rot(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\treturn mat2(c, -s, s, c);\n}\n\n\n\n\nfloat Bounce2(float t) {\n    \n    t *= 2.75+.3;\n    t-=1.+.3;\n    \n\tfloat a = 0.;\n    float b = 1.-t*t;\n    float c = -4.*(t-1.)*(t-1.5);\n    float d = -4.*(t-1.5)*(t-1.75);\n    \n    float ab = smin(a, b, -.1);\n    float cd = smin(c, d, -.1);\n    \n    float y = smin(ab, cd, -.1);\n    \n    return y;\n}\n\nfloat Wave(float d, float t) {\n\tfloat x = d-t*10.;\n    \n    float wave = sin(x)/(1.+x*x);\n    float s = S(14., 0., d);\n    return wave*s*s*1.5;\n}\n\nfloat V2(vec3 p, float t) {\n\t\n   \n    \n   // p *= mix(1., .5, S(.8, .99, t));\n    //p *= 1.-.5*t;\n    \n    float dc = length(p.xz);\n    \n    float m = iMouse.x/iResolution.x;\n   //t = m;\n    t *= 2.;\n    \n    float eject = S(0., .1, t);\n    float eject2 = eject*S(.3, .1, t);\n    float dropSize = mix(1., .5, eject);\n    \n    float t1 = t;\n    float t2 = t-.75;\n    float t3 = t-.875;\n    \n    float t4 = t-.4;\n    \n    float w1 = Wave(dc, t1)* S(0., .05, t1);\n    float w2 = Wave(dc, t2)* S(0., .05, t2);\n    float w3 = Wave(dc, t3)* S(0., .05, t3);\n    \n    float w4 = Wave(dc, t4)* S(0., .05, t4);\n    \n    float wave = w1 + .5*w2 + .25*w3 + .25*w4;\n    \n    float cw = Wave(0., t1) + Wave(0., t2)*.5 + Wave(0., t3)*.4;\n    \n    float b = Bounce2(t*1.);\n    float y = b*6.+dropSize+cw-.1;\n    y -= .6*S(1., .85, t);\n    y += (1.-eject)*.5;\n    y -= eject2;\n    \n    \n    float x = sin(t*30.+p.z*9.)*.05*b;\n    float z = sin(t*33.+p.x*7.)*.05*b;\n    \n    float drop = length(p-vec3(x, y, z))-dropSize;\n    \n    float surf = abs(p.y);\n    \n    surf -= wave;\n    \n    surf *= .75;\n    float d = smin(surf, drop, eject2*2.);\n    \n    x = z = 0.;\n   // t = (t-1.);\n    \n    y = -(t-.2)*(t-.5)*100.-.5;\n    drop = length(p-vec3(x, y, z))-.5;\n    d = smin(d, drop, max(1.-y, .1));\n    \n    y = -(t-.15)*(t-.55)*100.-.5;\n    d = smin(d, length(p-vec3(x, y, z))-.25, .8);\n    \n    y = -(t-.13)*(t-.56)*100.-.25;\n    d = smin(d, length(p-vec3(x, y, z))-.15, .8);\n    \n    return d;\n}\n\nfloat V3(vec3 p, float t) {\n    vec2 size = vec2(25.);\n    vec2 id = floor(p.xz/size);\n    p.xz = mod(p.xz, vec2(size))-size*.5;\n    \n    float n = N21(id);\n    \n    t = fract(t*.2+n);\n    \n   return V2(p, t);\n}\n\nfloat map( vec3 p ) {\n    \n    float t = iTime;\n   // t += sin(t*.3);\n    //p.xz += t*2.;\n    \n    float d = V3(p, t);\n    \n    float s = sin(PI*.25);\n    float c = cos(PI*.25);\n    mat2 rot = mat2(c, -s, s, c);\n    \n   // p.xz *= 2.*rot;\n    p.xz += vec2(12.34, 34.45);\n    d = smin(d, V3(p, t), .1);\n    \n    return d;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=0; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos =  nor * hr + pos;\n        totao += -(map( aopos )-hr)*sca;\n        sca *= .5;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\n\nde castRay( ray r, float precis ) {\n    \n    float t = iTime;\n    float dS;\n    \n    de o;\n    o.d = MIN_DISTANCE;\n    o.md = MAX_DISTANCE;\n    o.m = -1.0;\n    \n    float d;\n    for( int i=0; i<MAX_STEPS; i++ ) {\n        o.p =  r.o+r.d*o.d;\n \n        d = map(o.p);\n        \n        o.md = min(o.md, d);\n        if( d<precis || o.d>MAX_DISTANCE ) break;\n        \n        o.d += d;\n    }\n    \n    if(d<precis) o.m = 1.;\n    \n    return o;\n}\n\nvec3 calcNormal( de o )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(o.p+eps.xyy) - map(o.p-eps.xyy),\n\t    map(o.p+eps.yxy) - map(o.p-eps.yxy),\n\t    map(o.p+eps.yyx) - map(o.p-eps.yyx) );\n\treturn normalize(nor);\n}\n\nvec3 Bg(vec3 rd) {\n    float y = iMouse.y/iResolution.y;\n    y = sin(iTime*.1)*.15+.7;\n\treturn vec3(.5)*(rd.y+1.)*y;\n}\n\nvec3 render( vec2 uv, ray cam ) {\n    \n    float t = iChannelTime[0];\n    \n    vec3 col = vec3(0.);\n    de o = castRay(cam, RAY_PRECISION);\n    \n    vec3 n = calcNormal(o);\n    \n    float d = length(o.p-cam.o);\n    float fresnel = 1.-sat( dot(-cam.d, n) );\n    \n    if(o.m==1.) {\n    \tfloat ao = calcAO(o.p, n);\n        \n        float dif = .1+sat(dot(n, vec3(.577)));\n        dif = mix(ao, dif, .5);\n        \n        \n        col = vec3(dif);\n        \n        \n        #ifdef REFLECTIONS\n        ray r;\n        r.d = reflect(cam.d, n);\n        r.o = o.p+r.d*.1;\n        \n        de ro = castRay(r, .03);\n        float ref = 0.;\n        if(ro.m==1.) {\n        \tvec3 rn = calcNormal(ro);\n            \n            float rao = calcAO(ro.p, rn);\n        \n        \tfloat rdif = .1+sat(dot(rn, vec3(.577)));\n        \tref = mix(rao, rdif, .5)*.3;\n            \n        }\n        \n        col += ref*fresnel;\n        #endif\n    }\n    vec3 bg = Bg(cam.d);\n    col = mix(bg, col, (1.-fresnel)*S(50., 0., d));\n   // col = bg;\n    return col;\n}\n\nvec3 FlightPath(float t) {\n    //t *= .3;\n    float a = sin(t)*.5+.5;\n    float b = a*a;\n    float x = -sin(t*.25)*30.;\n    float y = sin(t*.225)+1.2 + sin(.2456*t)+1.5;\n   // y = mix(2., 12., b*b);\n\treturn vec3(x, y, t*10.);\n}\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n    float t = iTime;\n    \n    uv = (2.*uv - (o.xy=iResolution.xy) ) / o.y ;  \t// -1 <> 1\n   \tm = iMouse.xy/iResolution.xy;\t\t\t\t\t// 0 <> 1\n    \n    float turn =m.x*6.283;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(\t  c,  0., s,\n                   \t\t  0., 1., 0.,\n                   \t\t  s,  0., -c);\n    \n    m.y -= .5;\n    s = sin(m.y*PI*.5);\n    c = cos(m.y);\n    vec3 pos = vec3(0., (1.-s)*6., -6.*c)*rotX;\n   \tvec3 lookAt = vec3(0., 1.5, 0.);\n    \n    float y = sin(t)*2.+1.;\n    pos = FlightPath(t);\n    lookAt = FlightPath(t+1.1)+vec3(0., -2.5, .1);\n    \n    float a = sin(t*.25)*.25;\n    vec3 up = vec3(sin(a), cos(a), 0.);\n    ray r = GetRay(uv, pos, lookAt, 1., up);\n\n    vec3 col = render(uv, r);\n    \n    \n    if(pos.y>0.)\n    col = 1.-col;\n    //col *= 1.5;\n    \n    col *= 1. - dot(uv, uv)*.125;\n    col *= 1.5;\n    \n    col *= col;\n    \n     col *= vec3(1., .9+sin(t*.36)*.1, .9+sin(t*.3)*.1);\n   \n    o = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n#define PI 3.14159265\n#define R3 1.732051\n\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11  is also first 32bits of M1*M1\n\n#define N21 N21dot\n\n// from James_Harnett - Simplest Fastest 2d Hash \n// https://www.shadertoy.com/view/MdcfDj\nfloat hash( uvec2 q ) {\n    q *= uvec2(M1, M2); \n    \n    uint n = (q.x ^ q.y) * M1;\n    \n    return float(n) * (1.0/float(0xffffffffU));\n}\n\n// Returns hexagonal coordinates. \n// XY = polar uv coords,  ZW = hex id \nvec4 HexCoordsPolar(vec2 uv) {\n    vec2 s = vec2(1, R3);\n    vec2 h = .5*s;\n\n    vec2 gv = s*uv;\n    \n    vec2 a = mod(gv, s)-h;\n    vec2 b = mod(gv+h, s)-h;\n    \n    vec2 ab = dot(a,a)<dot(b,b) ? a : b;\n    vec2 st = vec2(atan(ab.x, ab.y), length(ab));\n    vec2 id = gv-ab;\n    \n    return vec4(st, id);\n}\n\n// Returns hexagonal coordinates. \n// XY = polar uv coords,  ZW = hex id \nvec4 HexCoords(vec2 uv) {\n    vec2 s = vec2(1, R3);\n    vec2 h = .5*s;\n\n    vec2 gv = s*uv;\n    \n    vec2 a = mod(gv, s)-h;\n    vec2 b = mod(gv+h, s)-h;\n    \n    vec2 ab = dot(a,a)<dot(b,b) ? a : b;\n    vec2 st = ab;//vec2(atan(ab.x, ab.y), length(ab));\n    vec2 id = gv-ab;\n    \n    return vec4(st, id);\n}\n\n\n// returns the distance from a point to a rect (center-size)\nfloat DistRect(vec4 r, vec2 p) { \n\tvec2 d = max(abs(p - r.xy) - r.zw*.5, 0.);\n    return dot(d, d);\n}\n\nfloat GetT(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b-a;\n    vec2 pa = p-a;\n    \n    float t = dot(ba, pa)/dot(ba, ba);\n    \n    return t;\n}\n\nvec2 ClosestPointSeg2D(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b-a;\n    vec2 pa = p-a;\n    \n    float t = dot(ba, pa)/dot(ba, ba);\n    t = sat(t);\n    \n    return a + ba*t;\n}\n\nfloat DistSeg2d(vec2 uv, vec2 a, vec2 b) {\n\treturn length(uv-ClosestPointSeg2D(uv, a, b));\n}\n\nfloat N(float p) {\n\treturn fract(sin(p*6453.2)*3425.2);\n}\n\n\n\nvec3 N23(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 N23(float x, float y) {return N23(vec2(x, y));}\n\nfloat N21sin(vec2 p) {\n    p = p*132.3+vec2(345.45,2345.3);\n\treturn fract(sin(p.x+p.y*1534.2)*7363.2);\n}\n\nfloat N21dot(vec2 p) {\n    p = fract(p*vec2(345.45,2345.3));\n    p += dot(p, p+123.345);\n\treturn fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p) {\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 N12(float p) {\n    float x = N(p);\n\treturn vec2(x, N(p*100.*x));\n}\n\n\n\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat N2(float x, float y) { return N2(vec2(x, y)); }\n\nfloat SmoothNoise(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n    \n    float top = mix(N2(id.x, id.y), N2(id.x+1., id.y), m.x);\n    float bot = mix(N2(id.x, id.y+1.), N2(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nfloat LayerNoise(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.)*.5;\n    c += SmoothNoise(uv*16.)*.25;\n    c += SmoothNoise(uv*32.)*.125;\n    c += SmoothNoise(uv*65.)*.0625;\n    \n    return c / 2.;\n}\n\nvec3 SmoothNoise3(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n    \n    vec3 top = mix(N23(id.x, id.y), N23(id.x+1., id.y), m.x);\n    vec3 bot = mix(N23(id.x, id.y+1.), N23(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nvec3 LayerNoise3(vec2 uv) {\n    vec3 c = SmoothNoise3(uv*4.);\n    c += SmoothNoise3(uv*8.)*.5;\n    c += SmoothNoise3(uv*16.)*.25;\n    c += SmoothNoise3(uv*32.)*.125;\n    c += SmoothNoise3(uv*65.)*.0625;\n    \n    return c / 2.;\n}\n\n\nvec2 Rot2d(vec2 p, float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    return vec2(p.x*s-p.y*c, p.x*c+p.y*s);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = sat( 0.5+0.5*(b-a)/k );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k ) {\n    float h = sat( 0.5+0.5*(b-a)/k );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}","name":"Common","description":"","type":"common"}]}