{"ver":"0.1","info":{"id":"ftXGRn","date":"1621358239","viewed":84,"name":"Shifting Mandelbrot Julia Grid","username":"Symbroson","description":"Random \"pattern\" I've found while writing a julia grid shader.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["grid","juliaset","mandelbrotset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.1415926\n#define R (iResolution.xy)\n#define A fragCoord\n#define WALL 40.\n\n#define GRID_RDENS 1.5  // .3 1.5 ...\n#define GRIDW (R.x/GRID_RDENS)\n#define GRIDH (GRIDW*R.y/R.x)\n\n#define ZOOMF 2.\n#define ZOOMT 1.\n#define ZOOMO 1.2\n\n#define RTIMEF 5.\n#define ROTT 20.\n#define ROTD 10.\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1, 2.0/3.0, 1.0/3.0, 3);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);\n}\n\nvec2 powC2(vec2 z) {\n    return vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y);\n}\n\n// 2d point rotation\nvec2 rotate(vec2 pos, vec2 center, float angle)\n{\n    pos -= center;\n    float x = pos.x * cos(angle) - pos.y * sin(angle);\n    float y = pos.y * cos(angle) + pos.x * sin(angle);\n    return vec2(x, y) + center;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // constants\n    float t = iTime / RTIMEF;\n    vec2 f = vec2(GRIDW, GRIDH);\n    vec2 k = vec2(-.17, 0); // move set grid\n \n    float scale = (1. + sin(t/ZOOMT)) * ZOOMF + ZOOMO;\n    vec2 v = .8 * vec2(cos(20. * t/41.), sin(20. * t/23.));\n\n    /*/ // set\n    vec2 z = (A/R - 0.5) * scale;\n    vec2 p = .7 * vec2(cos(SHIFTF * t/SHIFTX), sin(SHIFTF * t/SHIFTY));\n    /*/ // grid\n    vec2 z = (mod(f*A, R)/R - 0.5) * scale;\n    vec2 p = f*(A/R - 0.5)+ vec2(-0.5);\n    p = (floor(p)/f + k + v/ROTD) * scale;\n    //*/\n\n    z.y *= f.x*R.y / (f.y*R.x);\n    z = rotate(z, vec2(0), PI*iTime/ROTT);\n\n    // p marker\n    vec2 d = (A - (1. - v) * R / 2.);\n    if(d.x*d.x + d.y*d.y < 9.) {\n        fragColor= vec4(1.,0.,0.,1.);\n        return;\n    }\n    \n    float i;\n    for(i = 0.; i < WALL; i++)\n    {\n        z = powC2(z) + p;\n        if(z.x*z.x + z.y*z.y >= 10.) break;\n    }\n    \n    // rotate hue without converting to hsb first has some mystical effect\n    vec3 c = vec3(iTime / 50., float(i) / WALL, sin(4. * float(i) / WALL));\n    fragColor= vec4(hsv2rgb(c),1.);\n}\n","name":"Image","description":"","type":"image"}]}