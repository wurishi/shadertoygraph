{"ver":"0.1","info":{"id":"cdyczh","date":"1695763489","viewed":92,"name":"simplesdf","username":"KingCake","description":"simple sdf test projects","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// QOL settings\nbool FIXED_MOUSE = true; // the best view\nbool DEBUG_COUNT = false; // march iterations count\nfloat ITEMS_COUNT = 4.0; // number of boxes around the sphere, less = faster\n\n// scene settings\nconst vec3 AMBIENT = vec3(0.25, 0.25, 0.25);\n\n// algorithhm settings\n#define PI 3.14159265359\nconst float INF = 100.0;\nconst float MIN_DIST = 0.01;\nconst float DELTA = 0.01;\nconst int MAX_ITTERS = 128;\nconst float STEP_COEF = 0.95;\nconst vec3 VEC_NULL = vec3(0, 0, 0);\n\nconst float SCREEN_WIDTH = 50.0;\nconst float SCREEN_HEIGHT = 50.0;\n\n// normal operations\n\nvec4 intersection_sdf(vec4 dist_first, vec4 dist_second) {\n    return (dist_first.w > dist_second.w) ? dist_first : dist_second;\n}\n\nvec4 union_sdf(vec4 dist_first, vec4 dist_second) {\n    return (dist_first.w < dist_second.w) ? dist_first : dist_second;\n}\n\nvec4 substraction_sdf(vec4 dist_first, vec4 dist_second) {\n    return (dist_first.w > -dist_second.w) ? dist_first : vec4(dist_second.xyz, -dist_second.w);\n}\n\n// smooth operations by hg_sdf\n\nfloat union_sdf_smooth_hg(float a, float b, float r) {\n    vec2 u = max(vec2(r - a, r - b), vec2(0));\n    return max(r, min(a, b)) - length(u);\n}\n\nfloat intersection_sdf_smooth_hg(float a, float b, float r) {\n    vec2 u = max(vec2(r + a, r + b), vec2(0));\n    return min(-r, max(a, b)) + length(u);\n}\n\nfloat substraction_sdf_smooth_hg(float a, float b, float r) {\n    return intersection_sdf_smooth_hg(a, -b, r);\n}\n\n// smooth operations by iq\n\nvec4 union_sdf_smooth(vec4 a, vec4 b, float k) {\nfloat h = clamp(0.5 + 0.5*(b.w-a.w)/k, 0.0, 1.0);\nvec3 color = mix(b.rgb, a.rgb, h);\nreturn vec4(color, mix(b.w, a.w, h) - k*h*(1.0-h));\n}\n\nvec4 intersection_sdf_smooth(vec4 a, vec4 b, float k) {\nfloat h = clamp(0.5 - 0.5*(b.w-a.w)/k, 0.0, 1.0);\nvec3 color = mix(b.rgb, a.rgb, h);\nreturn vec4(color, mix(b.w, a.w, h) + k*h*(1.0-h));\n}\n\nvec4 substraction_sdf_smooth(vec4 a, vec4 b, float k) {\nfloat h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0.0, 1.0);\nvec3 color = mix(a.rgb, b.rgb, h);\nreturn vec4(color, mix(a.w, -b.w, h) + k*h*(1.0-h));\n}\n\n// point operations by kctf\n\nvec3 moduled_point(vec3 p, float module) {\n    if (module == 0.0) {\n        return p;\n    }\n    p = mod(p + module / 2.0, module) - module / 2.0;\n    return p;\n}\n\nvec3 moduled_point_plane_xy(vec3 p, float module) {\n    if (module == 0.0) {\n        return p;\n    }\n    p.xy = mod(p.xy + module / 2.0, module) - module / 2.0;\n    return p;\n}\n\nvec3 moduled_point_plane_xz(vec3 p, float module) {\n    if (module == 0.0) {\n        return p;\n    }\n    p.xz = mod(p.xz + module / 2.0, module) - module / 2.0;\n    return p;\n}\n\nvec3 moduled_point_plane_yz(vec3 p, float module) {\n    if (module == 0.0) {\n        return p;\n    }\n    p.yz = mod(p.yz + module / 2.0, module) - module / 2.0;\n    return p;\n}\n\nvec3 twisted_point(vec3 p, vec3 k) { // remade id code\n    vec3 q = p;\n    float c = 0.0;\n    float s = 0.0;\n    if (k.x != 0.0) {\n        c = cos(k.x * p.x);\n        s = sin(k.x * p.x);\n        mat2  m = mat2(c, -s, s, c);\n        q = vec3(m * q.yz, q.x);\n    }\n    if (k.y != 0.0) {\n        c = cos(k.y * p.y);\n        s = sin(k.y * p.y);\n        mat2  m = mat2(c, -s, s, c);\n        q = vec3(m * q.xz, q.y);\n    }\n    if (k.z != 0.0) {\n        c = cos(k.z * p.z);\n        s = sin(k.z * p.z);\n        mat2  m = mat2(c, -s, s, c);\n        q = vec3(m * q.xy, q.z);\n    }\n    return q;\n}\n\nvec3 bended_point(vec3 p, vec3 k) { // remade iq code\n    vec3 q = p;\n    float c = 0.0;\n    float s = 0.0;\n    if (k.x != 0.0) {\n        c = cos(-k.x * p.y);\n        s = sin(-k.x * p.y);\n        mat2  m = mat2(c, -s, s, c);\n        vec2 a = m*p.xy;\n        q = vec3(a.y, a.x, p.z);\n    }\n    if (k.y != 0.0) {\n        c = cos(k.y * p.x);\n        s = sin(k.y * p.x);\n        mat2  m = mat2(c, -s, s, c);\n        q = vec3(m*p.xy,p.z);\n    }\n    if (k.z != 0.0) {\n        c = cos(-k.z * p.y);\n        s = sin(-k.z * p.y);\n        mat2  m = mat2(c, -s, s, c);\n        vec2 a = m*p.zy;\n        q = vec3(a.y, p.x, a.x);\n    }\n    return q;\n}\n\nvec3 repeated_point(vec3 p, float module, vec3 l) { // by iq\n    vec3 q = p - module * clamp(round(p / module), -l, l);\n    return q;\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotated_point(vec3 p, vec3 ang) {\n    p.zy = p.zy * rot(ang.x);\n    p.xz = p.xz * rot(ang.y);\n    p.xy = p.xy * rot(ang.z);\n    return p;\n}\n\n// basic shapes distances\n\nfloat dist_sphere(const vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat dist_box(const vec3 p, vec3 box) {\n    vec3 q = abs(p) - box;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat dist_plane(vec3 p, vec3 n, float h)\n{\nreturn dot(p, normalize(n)) + h;\n}\n\nfloat dist_square(vec3 p, vec3 n, vec3 o, float a, float b) {\n    return max(abs(dot(p - o, n)) - a, abs(dot(p - o, cross(n, vec3(0, 0, 1)))) - b);\n}\n\nfloat dist_segment(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float k = clamp(dot(p - a, b - a) / (ab.x * ab.x + ab.y * ab.y + ab.z * ab.z), 0.0, 1.0);\n    return length(p - a - k * (b - a));\n}\n\nfloat onion(float dist, float thickness) {\n    return abs(dist) - thickness;\n}\n\nvec3 fix_color(vec3 color) {\n    return clamp(color, 0.3, 1.0);\n}\n\nvec3 blend_texture(sampler2D channel, vec3 p, float freq) {\n    p *= freq;\n    vec3 color_xy = texture(channel, p.xy).rgb;\n    vec3 color_xz = texture(channel, p.xz).rgb;\n    vec3 color_yz = texture(channel, p.yz).rgb;\n    vec3 color = (color_xy + color_xz + color_yz) / 3.0;\n    return color;\n}\n\nvec4 scene_distance(vec3 p) {\n    p += vec3(0, 0, 10);\n\n    vec4 dist = vec4(vec3(1, 1, 1), 1000);\n\n    vec3 floor_color = blend_texture(iChannel1, p, 0.1);\n    dist = union_sdf(dist,\n        vec4(floor_color, dist_box(p - vec3(0, -20, 0), vec3(50, 10, 100)))\n    );\n\n    vec3 pp = rotated_point(p, vec3(cos(iTime), iTime, sin(iTime)));\n\n    //vec3 scolor = vec3(abs(sin(iTime * 0.8)), cos(iTime * 0.4) / 2.0 + 0.5, 0.6);\n    vec3 scolor = blend_texture(iChannel0, p, 0.3);\n    dist = union_sdf(dist,\n        vec4(scolor, dist_sphere(pp - vec3(0, 0, 0), 5.0))\n    );\n\n    dist = substraction_sdf(dist,\n        vec4(scolor, dist_sphere(pp - vec3(0, 0, 0), 4.6))\n    );\n\n    float cross_width = 0.15;\n    float cross_length = 1.75;\n    float cross_smooth = 2.5;\n    dist = union_sdf_smooth(dist,\n        vec4(scolor.zxy * 2.0, dist_box(pp - vec3(0, 0, 0), 3.3 * vec3(cross_length, cross_width, cross_width))), cross_smooth\n    );\n    dist = union_sdf_smooth(dist,\n        vec4(scolor.zxy * 2.0, dist_box(pp - vec3(0, 0, 0), 3.3 * vec3(cross_width, cross_length, cross_width))), cross_smooth\n    );\n    dist = union_sdf_smooth(dist,\n        vec4(scolor.zxy * 2.0, dist_box(pp - vec3(0, 0, 0), 3.3 * vec3(cross_width, cross_width, cross_length))), cross_smooth\n    );\n\n    p = twisted_point(p, 0.8 * vec3(sin(iTime) / 10.0, cos(iTime) * 0.1, -sin(iTime) * 0.1));\n\n    vec3 q = vec3(1, 0, 0);\n    vec3 color = vec3(0.9, 0.2, 0.1);\n\n    float max_i = ITEMS_COUNT;\n\n    for (float i = 0.0; i < max_i; ++i) {\n        q = q.yzx;\n        q = rotated_point(q, vec3(0, sin(iTime), cos(sqrt(i)) * iTime / 4.0));\n        \n        // color = vec3(random(float(i)), random(float(i * i)), random(float(i * 5.0)));\n        // color = color.yzx;\n        // color = rotated_point(color, vec3(iTime, sin(iTime), color.x));\n\n        vec3 texcolor = blend_texture(iChannel2, p, 0.3);\n        dist = union_sdf_smooth(dist,\n            vec4(fix_color(texcolor * 2.0), dist_box(p - q * 7.5, 1.4 * vec3(1, 1, 1))), (i + 4.0) * 0.35\n        );\n    }\n\n    q = vec3(1, 0, 0);\n    color = vec3(0.9, 0.2, 0.1);\n    for (float i = 0.0; i < max_i; ++i) {\n        q = q.yzx;\n        q = rotated_point(q, vec3(0, sin(iTime), cos(sqrt(i)) * iTime / 4.0));\n        \n        // color = color.yzx;\n        // color = rotated_point(color, vec3(iTime, sin(iTime), color.x));\n\n        dist = substraction_sdf_smooth(dist,\n            vec4(vec3(0), dist_sphere(p - q * 5.0, 1.5)), 1.0\n        );\n    }\n\n    return dist;\n}\n\nvec3 scene_normal(const vec3 p) {\n    float d = scene_distance(p).w;\n    vec2 e = vec2(DELTA, 0);\n    vec3 n = d - vec3(scene_distance(p - e.xyy).w, scene_distance(p - e.yxy).w, scene_distance(p - e.yyx).w);\n    return normalize(n);\n}\n\n\nvec4 light(vec3 point, vec3 normal, vec3 light_origin, vec3 color) {\n    vec3 light_dir = normalize(light_origin - point);\n    float diffuse = clamp(dot(normal, light_dir), 0.3, 1.0);\n    vec3 diffuse_color = color * diffuse;\n    return vec4(diffuse_color, 1.0);\n}\n\n\nvec4 march_ray(vec3 p, const vec3 dir) {\n    vec3 color = vec3(0, 0, 0);\n    vec4 inter;\n    for (int i = 0; i < MAX_ITTERS; ++i) {\n        inter = scene_distance(p);\n        float dist = inter.w;\n        \n        if (dist < MIN_DIST) {\n            color = inter.rgb;\n            break;\n        }\n        p += dir * dist * STEP_COEF;\n\n        if (dist > INF + 1.0) {\n            break;\n        }\n    }\n\n    return inter;\n}\n\nvec3 victorious_march(const vec3 origin, const vec3 direction) {\n    vec3 dir = normalize(direction);\n    vec3 p = origin;\n    vec3 color = AMBIENT;\n\n    vec4 inter;\n\n    int i = 0;\n    for (;i < MAX_ITTERS; ++i) {\n        inter = scene_distance(p);\n        float dist = inter.w;\n        \n        if (dist < MIN_DIST) {\n            color = inter.rgb;\n            break;\n        }\n        p += dir * dist * STEP_COEF;\n\n        if (dist > INF + 1.0) {\n            break;\n        }\n    }\n\n    // lighting\n    if (inter.w < MIN_DIST) {\n        vec3 normal = scene_normal(p);\n        vec3 light_origin = vec3(15, 10, -10);\n        color = light(p, normal, light_origin, inter.rgb).rgb;\n\n        // march ray to light\n        vec3 dir_to_light = normalize(light_origin - p); \n        p += normal * MIN_DIST * 1.1 + dir_to_light;\n        vec4 inter_to_light = march_ray(p, dir_to_light);\n        if (inter_to_light.w < MIN_DIST) {\n            color *= vec3(0.5, 0.5, 0.5);\n        }\n\n        // vec3 tx_color = blend_texture(iChannel0, p, normal);\n        // color = tx_color;\n    }\n\n    if (DEBUG_COUNT)\n        color = vec3(float(i) / float(MAX_ITTERS));\n    \n    return color;\n}\n\nvec3 ray_direction(vec3 camera, vec3 direction, float screen_dist, vec2 uv_pixel) {\n    uv_pixel.y = 1.0 - uv_pixel.y;\n    direction = normalize(direction);\n    vec3 screen_point = camera + direction * screen_dist;\n    vec3 screen_up = vec3(0, 1, -0.044);\n    vec3 screen_right = cross(direction, screen_up);\n\n    vec3 screen_center = screen_point;\n    vec3 screen_top_left = screen_center - screen_right * SCREEN_WIDTH / 2.0 + screen_up * SCREEN_HEIGHT / 2.0;\n\n    vec3 screen_pixel = screen_top_left + screen_right * SCREEN_WIDTH * uv_pixel.x - screen_up * SCREEN_HEIGHT * uv_pixel.y;\n    vec3 direction_pixel = normalize(screen_pixel - camera);\n\n    return direction_pixel;\n}\n\nfloat fps_real = 60.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // define ray origin and camera\n    vec3 camera = vec3(-24, 5, -10);\n    vec3 origin = vec3(0, 0, 0);\n    \n    float screen_dist = 50.0;\n\n    // get pixel and mouse coordinates\n    vec2 uv_pixel = fragCoord/iResolution.xy;\n    vec2 uv_mouse = iMouse.xy/iResolution.xy;\n\n    if (FIXED_MOUSE) { // for the best view\n        uv_mouse = vec2(0.4, 0.5);\n    }\n\n    // fix aspect ratio\n    uv_pixel.x *= iResolution.x / iResolution.y;\n\n    // rotate camera\n    camera = rotated_point(camera, vec3(0, uv_mouse.x * PI * 2.0, 0));\n\n    // ray direction\n    vec3 direction = ray_direction(camera, origin - camera, screen_dist, uv_pixel);\n\n    // march\n    vec3 color = victorious_march(camera, direction);\n\n    // output to screen\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y\n    );\n\n\treturn res*res;\n}\n\nvec4 noise4(vec2 p) {\n    p.x = noise(p);\n    float r = noise(p.xy);\n    float g = noise(p.yx);\n    float b = noise(vec2(p.x - p.y, p.x * p.y));\n    float a = noise(p.yy);\n    return vec4(r, g, b, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = noise4(fragCoord / 200.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}