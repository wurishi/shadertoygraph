{"ver":"0.1","info":{"id":"MsyXz3","date":"1465679625","viewed":758,"name":"2D Light","username":"Hexus","description":"Basic 2D lambertian lighting heavily based on the lwjgl shader tutorial.\n\nhttps://github.com/mattdesl/lwjgl-basics/wiki/ShaderLesson6#lambertian-illumination-model\n\nThere's code in here for rendering with a normal map that's currently unused.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","lighting","light","lambert","diffuse","lambertian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define LIGHT_ONLY\n\nvec4  colour    = vec4(1);\nvec4  ambient   = vec4(0);\nfloat intensity = 1.0;\nfloat radius    = 256.0;\nvec3  falloff   = vec3(0.1, 3, 100);\n\n// By Valve, found it here: https://www.shadertoy.com/view/4tfGWl\nvec3 dither(vec2 vScreenPos)\n{\n\tvec3 vDither = vec3(dot(vec2(171.0, 231.0), vScreenPos.xy + vec2(iTime)));\n\tvDither.rgb = fract(vDither.rgb / vec3(103.0, 71.0, 97.0)) - vec3(0.5, 0.5, 0.5);\n\treturn ( vDither.rgb / 255.0 ) * 0.375;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Pulse the radius\n    radius += sin(iTime * 3.0) * 50.0;\n    \n    // Correct the fragment and mouse coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 pos;\n    \n    if (iMouse.z > 0.0) {\n        // Mouse positioning\n    \tpos = vec3(mouse.xy, 0.01);\n    } else {\n        // Automatic movement\n\t\tpos = vec3(\n            sin(iTime * 0.5),\n            cos(iTime * 0.5),\n            0.01 //sin(iTime * 2.0) * 0.5\n        );\n        \n        pos.xy = pos.xy * 0.3 + 0.5;\n    }\n    \n    // Sample the diffuse and normal textures\n    vec4 diffuse = texture(iChannel0, uv);\n    vec4 normal = texture(iChannel1, uv);\n\t\n    // Calculate the delta position of the light\n\tvec3 delta = vec3(pos.xy - uv.xy, pos.z);\n    \n    // Ensure a fixed light radius\n\tdelta.x /= radius / iResolution.x;\n\tdelta.y /= radius / iResolution.y;\n    \n    // Calculate the distance from the fragment to the light\n    float dist = length(delta);\n\t\n    // Calculations for normal maps\n\t//vec3 n = normalize(normal.rgb * 2.0 - 1.0);\n\t//vec3 l = normalize(delta);\n    \n    // Optional normal Y inversion\n    //n.y = 1.0 - n.y;\n\t\n\tvec3 d = colour.rgb * colour.a ;\n    //d *= max(dot(n, l), 0.0); // Apply the normal to the light colour\n\tvec3 a = ambient.rgb * ambient.a;\n    \n    // Calculate light attenuation\n\tfloat attenuation = intensity / (falloff.x + (falloff.y * dist) + (falloff.z * dist * dist));\n\t\n    // Alternative attenuation expressions\n    //attenuation = clamp(intensity - dist, 0.0, 1.0); attenuation *= attenuation;\n    //attenuation = clamp(intensity - (dist * dist) / (radius * radius), 0.0, 1.0); attenuation *= attenuation;\n    //attenuation = intensity - dist;\n    \n    // Bring together the ambient and diffuse colour with attenuation\n    vec3 light = a + d * attenuation;\n    \n    // Gamma correction\n    light = pow(light, vec3(1.0 / 2.2));\n    \n    // Dithering\n    light += dither(fragCoord.xy) * 6.0;\n    \n    #ifdef LIGHT_ONLY\n    \tvec4 result = vec4(light, attenuation);\n    #else\n    \tvec4 result = vec4(vec3(diffuse.r) * light, diffuse.a);\n    #endif\n    \n\tfragColor = result;\n}\n","name":"Image","description":"","type":"image"}]}