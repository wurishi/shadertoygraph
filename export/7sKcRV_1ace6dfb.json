{"ver":"0.1","info":{"id":"7sKcRV","date":"1655230771","viewed":64,"name":"RayTracing MultiShadow","username":"modern_shinobi","description":"Multiple spheres raytracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spheres","glsl","shadows","raytrace","multiple"],"hasliked":0,"parentid":"7dKcRG","parentname":"RayTracing Simple"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float FLOAT_MAX = 10e+10;\n\n// Common structures definition\nstruct Sphere{\n    float radius;\n    vec3 center;\n    vec3 color;\n    vec3 normal;\n};\n\nstruct Plane{\n    float height;\n    vec3 color;\n    vec3 normal;\n};\n\nstruct Light{\n    vec3 dir;\n    float mag;\n    vec3 color;\n    vec3 ray;\n};\n\nstruct Ray{\n    vec3 dir;\n    vec3 origin;\n};\n\nstruct Hit{\n    float d;\n    vec3 point;\n};\n\n\n// Raycasting Functions definition\nHit RayCastPlane(vec3 rayOrigin, vec3 rayDir, inout Plane plane, float delta){\n    Hit hit = Hit(-1.0, vec3(0));\n    // Move hitpoint by delta to avoid 'acne'\n    rayOrigin += delta * plane.normal;\n    if (rayDir.y != 0.0){\n        hit.d = (plane.height - rayOrigin.y)/rayDir.y;\n        hit.point = rayOrigin + hit.d * rayDir;\n    }\n    return hit;\n}\n\nHit RayCastSphere(vec3 rayOrigin, vec3 rayDir, inout Sphere sphere){\n    Hit hit = Hit(-1.0, vec3(0));\n\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayDir, rayOrigin-sphere.center);\n    float c = dot(rayOrigin-sphere.center, rayOrigin-sphere.center) - \n                sphere.radius * sphere.radius;\n    \n    float det = b*b - 4.0*a*c;\n    if (det >= 0.0){\n        float d1 = (-b-sqrt(det))/2.0*a;\n        float d2 = (-b+sqrt(det))/2.0*a;\n        hit.d = min(d1,d2);\n        hit.point = rayOrigin + hit.d * rayDir;\n        sphere.normal = normalize(hit.point - sphere.center);\n    }\n    return hit;\n}\n\nfloat RandFloat(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Main Function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Camera\n    vec3 cameraPos = vec3(0,1,-1);\n    Ray ray;\n    ray.origin = cameraPos;\n    ray.dir = normalize(vec3(cameraPos.x+uv.x, cameraPos.y+uv.y, 0) - cameraPos);\n    \n    // Light\n    Light light;\n    light.dir = vec3(sin(iTime), -1, cos(iTime));\n    // light.dir = vec3(1, -1, 1);\n    light.mag = 1.0;\n    light.color = vec3(1,1,1);\n    \n    light.dir = normalize(light.dir);\n    light.ray = light.dir * light.mag;\n    \n    // Objects\n    Plane ground;\n    ground.height = 0.0;\n    ground.color = vec3(0.33,0.75,0);\n    ground.normal = vec3(0,1,0);\n    \n    const int N = 3;\n    Sphere[N] spheres;\n    \n    spheres[0].radius = 1.0;\n    spheres[0].center = vec3(-0.5,1,4);\n    spheres[0].color = vec3(1,0.1,0.1);\n    \n    spheres[1].radius = 1.5;\n    spheres[1].center = vec3(0.8,1.5,6);\n    spheres[1].color = vec3(0.3,0.3,1);\n    \n    spheres[2].radius = 0.5;\n    spheres[2].center = vec3(-1,0.5,3);\n    spheres[2].color = vec3(1,1,0);\n\n    // Raycast Calculations\n    \n    // Plane calculations\n    Hit hitGround = RayCastPlane(ray.origin, ray.dir, ground, 0.0);\n    // Sphere calculations\n    Hit[N] hitSphere;\n    for (int i=0; i<N; i++){\n        hitSphere[i] = RayCastSphere(ray.origin, ray.dir, spheres[i]);\n    }\n    \n    // Finding closest object to camera\n    vec3 col = vec3(0,0,0);\n    int hitObj = -1;\n    Hit hit = Hit(FLOAT_MAX, vec3(0));\n    // Color and overall distance calculations\n    if (hitGround.d > 0.0){\n        hitObj = 0;\n        hit = hitGround;\n        col = ground.color * dot(ground.normal, -light.ray);\n    }\n    // Minimum distances for all spheres\n    for (int i=0; i<N; i++){\n        if (hitSphere[i].d < 0.0) hitSphere[i].d = FLOAT_MAX;\n        if (hitSphere[i].d < hit.d){\n            hitObj = i+1;\n            hit = hitSphere[i];\n            col = spheres[i].color * dot(spheres[i].normal, -light.ray);\n        }\n    }\n    if (hit.d == FLOAT_MAX){\n        if (RandFloat(uv) < 0.001)\n            col = vec3(1,1,1);\n    }\n\n    // Shadow of ground plane calculation\n    Hit hitShadow = RayCastPlane(hit.point, -light.dir, ground, 10e-5);\n    if (hitShadow.d >= 0.0)\n        col *= 0.0;\n    // Shadows of all objects calculation\n    for (int i=0; i<N; i++){\n        hitShadow = RayCastSphere(hit.point, -light.dir, spheres[i]);\n        if (hitShadow.d >= 0.0)\n            col *= 0.3;\n    }\n\n    // d = min(hitGround.d, hitSphere.d);\n    // col = vec3(1.0/d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}