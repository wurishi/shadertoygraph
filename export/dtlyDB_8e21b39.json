{"ver":"0.1","info":{"id":"dtlyDB","date":"1691152581","viewed":74,"name":"Henyey-Greenstein function","username":"Envy24","description":"Henyey-Greenstein scattering function.\nhttps://omlc.org/classroom/ece532/class3/hg.html","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["plotter","graphs","henyey","explicit","greenstein"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ORIGIN                    ( vec2(0,0.5) )\n#define SCENE_SCALE               ( 2.55 )\n#define UNIT                      ( 4.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx);\n    return SMAA(abs(sdf) / dsdx);\n    //return SMAA(abs(sdf) / dsdx - 0.005); // for small thickness\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n\n// Henyey-Greenstein scattering function\n#define PI                          3.1415926535897932\nfloat g_ = 0.;\nfloat HenyeyGreenstein(float theta, float g)\n{\n    float s = 1./(4.*PI),\n          numer = 1. - g*g,\n          denom = 1. + g*g - 2.*g*cos(theta);\n    return s * numer / pow(denom, 3./2.);\n}\nfloat HenyeyGreenstein_(float cos_th, float g)\n{\n    float s = 1./2.,\n          numer = 1. - g*g,\n          denom = 1. + g*g - 2.*g*cos_th;\n    return s * numer / pow(denom, 3./2.);\n}\n\nfloat log10(float x) { return log(x) / log(10.); }\n\n// Explicit function definition.\n//float explicit(float x) { return HenyeyGreenstein(x, g_); } // Linear scale\nfloat explicit(float x) { return log10(HenyeyGreenstein(x, g_)); } // Log 10 scale, every horizontal line is power of 10.\n                                                                   // Black horizontal line is y == 1.\nfloat explicit_dydx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.01;\n    return ( explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n    /* Analytic derivative. If you know expression. *\n    return -M*sin(M*x);\n    /**/\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.9), SMAA(log10ScaleSDF(NDC)) );\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(horizontal_lineSDF(NDC, -1.)) ); // x_axis for log10\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n\n    /* Explicit function y=f(x) */\n         g_ = 0.;\n         color = mix(color, vec3(1,0,0), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n         g_ = 0.3;\n         color = mix(color, vec3(0,1,0), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n         g_ = 0.5;\n         color = mix(color, vec3(0,0,1), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n         g_ = 0.8;\n         color = mix(color, vec3(1,0,1), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n         g_ = 0.9;\n         color = mix(color, vec3(0,1,1), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n         g_ = 0.95;\n         color = mix(color, vec3(.7,.5,.1), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cell\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat log10ScaleSDF(vec2 NDC)\n{\n  NDC = fract(NDC);\n  float ln10 = log(10.),\n        e_pow = exp(NDC.y * ln10),\n        nearest_e_pow = floor(e_pow + 0.5);\n        \n  return abs( log(nearest_e_pow) / ln10 - NDC.y );\n}","name":"Common","description":"","type":"common"}]}