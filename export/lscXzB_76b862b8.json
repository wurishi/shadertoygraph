{"ver":"0.1","info":{"id":"lscXzB","date":"1460012180","viewed":836,"name":"Musical Glowing Tubes","username":"ksamksamksam","description":"Forest of abstract tree-like tubes with a starry sky background and dense mist rising. Glowing blobs climb up the tubes to the beat of the music. Wait for it...","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","music","audio","texturemapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DIST = 1000.0; //Max distance from camera that we want to \n\t\t\t\t\t\t\t   //render objects.\nconst float PI = 3.141592654;\n\nvec2 tubeSpace = vec2(15,25); //Space we want to fill with tubes.\n\nconst int numTubes = 45; //This is only a const because GLSL doesn't like\n\t\t\t\t\t\t //dynamic indexing so I refuse to make it all caps\n\t\t\t\t\t\t //or put it where its const friends are.\n\nvec4 tubes[numTubes]; //I'm representing the tubes as 4D vectors where \n\t\t\t\t\t  //tube.x is the x-coordinate of the tube, tube.y is \n\t\t\t\t\t  //the z-coordinate, tube.z is the radius, and tube.w\n\t\t\t\t\t  //is the current position of the tube's glowing blob.\n\nconst int numLights = numTubes + 1; //Each blob is a light source plus the main light.\nvec3 lights[numLights];\n\nfloat mainLi = 2.75; //Intensity of the main light.\nfloat blobLi = 0.2; //Intensity of the blob lights.\nfloat mainKf = 1.0; //Falloff factor of the main light.\nfloat blobKf = 1.0; //Falloff factor of the blob lights.\n\nvec3 cam = vec3(0.0,0.0,-10.0);\n\nvec4 ambColor;\nvec4 tubeColor = vec4(.11,.11,.11,1.0);\nvec4 blobColor = vec4(1,.55,0.0,1.0);\nvec4 mainColor = vec4(1.0,1.0,1.0,1.0);\n\n/* Hash-based noise stolen from https://www.shadertoy.com/view/4sfGzS.\n * Yes, I realize that iq was trying the demonstrate that the texture-based\n * noise was better but I wanted all inputs to be easily substituted and the\n * noise texture would have to be static. Plus, the hash function doubles as\n * a seeded random number generator.\n */\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n/* Given a color vector, clamps the color values to be between 0-1.\n*/\nvec4 clampColor(vec4 col)\n{\n    return vec4(min(max(0.0,col.x),1.0), min(max(0.0,col.y),1.0), min(max(0.0,col.z),1.0), min(max(0.0,col.w),1.0));\n}\n\n/* Given a tube, ray origin point p1, and second point on the ray p2,\n * if there is an intersection between the ray and the tube return true\n * and store the point of intersection in intPt; otherwise return false.\n */\nbool tubeRayIntersect(out vec3 intPt, in vec4 tube, in vec3 p1, in vec3 p2)\n{\n    //Since the tubes have no rotation, we don't care where along the y-axis\n    //the ray hits and can therefore ignore the y-coordinate of the ray\n    vec2 flatp1 = vec2(p1.xz);\n    vec2 flatp2 = vec2(p2.xz);\n    \n    //We can perform a simple ray-circle intersection between a cross-section\n    //of the tube and our newly flattened ray.\n    vec2 center = vec2(tube.xy);\n    float radius = float(tube.z);\n    \n    //We get p1 position in circle space.\n    vec2 localP1 = flatp1 - center;\n    \n    //Calculate and normalize the ray direction vector, then drop the\n    //y-coordinate of that.\n    vec3 orRayDir = normalize(p2 - p1);\n    vec2 rayDir = vec2(orRayDir.xz);\n    \n    //Caculate ray-circle intersection\n    float a = dot(rayDir,rayDir);\n    float b = dot(rayDir,localP1);\n    float c = dot(localP1,localP1) - (radius*radius);\n    float delta = (b * b) - (a * c);\n    \n    //No intersection\n    if (delta <= 0.0)\n    {\n        return false;\n    }\n    \n    else \n    {\n        //Calculate t with some quadratic magic and store intersection point\n        //where ro + rd*t = y into intPt.\n        float t = (-b-sqrt(delta)*sign(radius))/a;\n        intPt = p1 + (orRayDir*t);\n        return true;\n    }\n}\n\n/* Given a tube and a point on that tube, calculate the uv position on the\n * texture which corresponds to that point. (texture mapping on a cylinder)\n */\nvec2 pointToTexture(vec3 pt, vec4 tube)\n{\n    //Get x and y of vector from center of the tube to our point\n    float newz = pt.z - tube.y;\n    float newx = pt.x - tube.x;\n    \n    //Calculate the angle in radians between the above vector and an arbitrary\n    //starting point; the proportion of this angle to 2PI is the u component\n    //and the y-coordinate over the tube's diameter is out v component\n\tfloat xfrac =  (atan( tube.w*newz , tube.w*newx)+PI*0.5)/(3.0*PI);\n    float yfrac = pt.y/(3.5*PI*tube.z);\n    \n    return vec2(xfrac,yfrac);\n}\n\n/* Calculate the surface normal of the given tube at the given point\n*/\nvec3 tubeNormal(in vec4 tube, in vec3 pt)\n{\n    vec2 n = normalize(vec2(pt.xz) - vec2(tube.xy));\n    \n    return vec3(n.x, 0.0, n.y);\n}\n\n/* Function stolen from https://www.shadertoy.com/view/Xsd3R2 and modified.\n * Given a point and an array of noise parameters, calculate the fractal\n * noise value of a point. If called upon to animate the fractal, do so using\n * the current time.\n*/\nfloat fractal_noise(vec3 p, float[5] c, bool anim)\n{\n    float f = 0.0;\n    \n    // add animation if warranted\n    if (anim)\n    {\n    \tp = p - vec3(1.0, 1.0, 0.0) * iTime * 0.04;\n    }\n    \n    //fractal-ing the noise\n    p = p * 2.0;\n    f += c[0] * noise(p); p = 2.0 * p;\n\tf += c[1] * noise(p); p = 2.0 * p;\n\tf += c[2] * noise(p); p = 2.0 * p;\n\tf += c[3] * noise(p); p = 2.0 * p;\n    f += c[4] * noise(p);\n    \n    return f;\n}\n\n/* We want to create a mist coming up from the ground. Given a point on the \n * screen, calculate the density of the mist at that point.\n */\nfloat mistDensity(vec3 pt)\n{\n    //I'm using animated fractal noise to simulate the cloudy mist effect.\n    float consts[5];\n    consts[0] = 0.5;\n    consts[1] = 0.5;\n    consts[2] = 0.25;\n    consts[3] = 0.0625;\n    consts[4] = 0.03125;\n    \n    float den = fractal_noise(pt, consts, true);\n    \n    den = clamp(den, 0.0, 1.0);\n    \n    //We want to ramp off the density as the mist goes higher up the screen.\n    den *= (.79)/((pt.y+1.5)/4.0)-1.1;\n    \n    return den;\n}\n\n/* We want to create a starry sky background.\n*/\nvec4 starrySky(vec3 pt)\n{\n    //Dark blue sky\n    vec4 color = vec4(.01,0.007,.015,1.0);\n    \n    //Come up with something to seed our random number generator. It doesn't \n    //make much sense, but I like the idea of seeding with a texture, even \n    //the actual texture won't be reflected in the distribution of the stars.\n    vec2 uv = (.5 * (pt.xy * iResolution.yy + iResolution.xy))/iResolution.xy;   \n    float prob = length(clampColor(texture(iChannel2,uv)));\n\t\n    if (hash(prob) > .992)\n    {\n        //Add stars, and make 'em sparkle by attenuating their value based on\n        //the sine of the current time. Throw in some randomness based on the\n        //screen point position so they're staggered.\n        color = clampColor(hash(length(pt))*(2.0*sin(iTime+100.0*hash(length(pt))))*vec4(.4,.4,.4,1.0));\n    }\n    \n    return color;\n}\n\n/* I have a disclaimer: I am well aware of iq's awesome and efficient ray\n * marching algorithm that is loads better than whatever I hacked here, but\n * I didn't want the meat of my shader to be cannibalized, since I'm supposed\n * to demonstrate what I can do, not what I can steal effectively (although \n * this is also an important skill that I must say I excel at). I usually don't\n * like to reinvent the wheel so were this a production project, I would steal\n * whatever I could with the proper authorization.\n * \n * That said, this uses a very simple ray casting algorithm that calculates the\n * diffuse term of the one primitive it can handle (cylinders) using the Lambert\n * shading model. It takes in a screen point as input and stores the color of\n * scene at that point in the vec4 color.\n */\nvoid render(out vec4 color, in vec3 pix)\n{\n    //First, our background.\n    color = starrySky(pix);\n    \n    //We want to store the distance of the closest object we have hit so far.\n    //We also want to store the tube that we have hit, if we have hit one.\n    float closeDist = MAX_DIST;\n    vec4 hitTube = vec4(-1,-1,-1,-1);\n\n    vec3 intPt, light, lightNorm, camNorm;\n    vec4 lightcolor, texColor, tempColor, blobC;\n    float f, intensity, falloff, col1, diffDot, lightFac, blobDot, blobK;\n    float consts[5];\n    \n    for (int i = 0; i < numTubes; i++)\n    {\n        \n        //If we've intersected our tube, AND it's closer than the max distance\n        //AND it's closer than the last closest tube we hit...\n        if (tubeRayIntersect(intPt, tubes[i], cam, pix) && length(intPt-pix)<closeDist && length(intPt-pix)<MAX_DIST)\n        {   \n            //...we can get this party started. First we set the color\n            //vector to black because we're going to be adding color onto it.\n            color = vec4(0.0,0.0,0.0,1.0);\n            \n            //We're adding texture to the tubes with fractal noise.\n            consts[0] = 0.3;\n            consts[1] = 0.25;\n            consts[2] = 0.125;\n            consts[3] = 0.2625;\n            consts[4] = 0.0;\n            \n            f = fractal_noise(intPt, consts, false);\n            \n            //Calculate the textured color by combining the noise and the\n            //tube's default color.\n            texColor = (3.0*tubeColor + 2.0*tubeColor * f)*(0.3333333);\n            \n            //Set our new closest distance and hit tube.\n            closeDist = length(intPt-pix);\n            hitTube = tubes[i];\n            \n            //Store the normal from the camera to the intersection point.\n            camNorm = normalize(cam-intPt);\n\n            //Calculating the diffuse color contribution of each light to\n            //our tube such that diffuse = color * brightness factor\n            for (int j = 0; j < numLights; j++)\n            {\n                //By default, since most of the lights will be blob lights,\n                //we will assume this is a blob light and set its parameters\n                //accordingly.\n                lightcolor = blobColor;\n                intensity = blobLi;\n                falloff = blobKf;\n                light = lights[j];\n                \n                //BUT, if this is the first light in the list, we will assume\n                //it's the main light and set its parameters based on that. It's\n                //kind of a yucky way of doing things but I tried making a Light\n                //struct so I could package all this up and it slowed the shader\n                //WAY down.\n                if (j == 0)\n                {\n                    lightcolor = mainColor;\n                    intensity = mainLi;\n                    falloff = mainKf;\n                }\n                                \n                \n                //Light attenuation factor: light falls off at a rate proportional \n                //to the inverse square of the distance between surface and \n                //source light [Lambert's first law].  1/(c1+c2*d+c3*d^2).\n                col1 = (1.15/(falloff))/(1.0*falloff + .07 *(length(light-intPt))+ .015 * falloff * (length(light-intPt) * length(light - intPt))); \n\n                //brightness is dependent on angle from light source\n                lightNorm = normalize(light-intPt);\n                diffDot = dot(lightNorm, tubeNormal(tubes[i], intPt));\n                diffDot = max(0.0, diffDot);\n                \n                //Combine these all with the light intensity and color\n                lightFac = diffDot * col1 * intensity;\n                tempColor = vec4(lightcolor[0]*texColor[0], lightcolor[1]*texColor[1], lightcolor[2]*texColor[2],1.0);\n            \t\n                //add to the color at this point\n                color += lightFac * tempColor; \n            }\n            \n            //Color contribution from our blob. Depends on angle from camera\n            //and our point's distance from the blob. I'm faking the look of\n            //internal illumination with the color falloff.\n            blobDot = dot(camNorm, tubeNormal(tubes[i], intPt));\n            blobK = blobDot/(length(intPt-vec3(tubes[i].x,tubes[i].w,tubes[i].y)))-.3;\n            blobC = max(0.0,blobK)*blobColor;\n            \n            //add a texture to the blob color to make it seem like the tube has\n            //an internal structure that is being lit up\n            blobC = (2.0*blobC + 3.0*blobC*texture(iChannel0,pointToTexture(intPt, tubes[i])))*(1.0/3.0);\n\n            //Add it all up with the ambient color\n\t\t\tcolor = clampColor(color + ambColor + blobC);  \n        }\n    }\n    \n    //Throw in our mist. Calculate mist density, then figure out if there's a\n    //tube in the way. The tube will occlude the mist depending on its distance\n    //from camera. Trying to create the appearance that the mist covers a 3D\n    //space despite being 2D.\n    float tubeFac = 1.0;\n    \n    if (hitTube != vec4(-1))\n    {\n        tubeFac = smoothstep(-4.0,15.0,hitTube.y);\n    }\n    \n    color += tubeFac*vec4(.15,.15,.15,0.0)*mistDensity(pix);\n}\n\n/* Main image function where we write to our pixel.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Grab the frequency and waveform from out audio input.\n    float freq = texture(iChannel1, vec2(0.5, 0.0)).x;\n    float wave = (2.0*texture( iChannel1, vec2(.1,0.5) ).z);\n    \n    //Set the main light position, which will move around slightly based\n    //on the audio wave.\n    vec3 light = vec3(-5.0,0.0,-5.0);\n    light.x = wave*cos(iTime);\n    light.y = wave*sin(iTime);\n    \n    //Attenuate blob color based on frequency and wavelength of the audio\n    blobColor.yz -= wave/5.0;\n    blobColor *= 3.0*freq;\n    \n    //attenuate main light intensity based on the frequency of the audio\n    mainLi = mainLi + 2.0*freq;\n    \n    //gently move the ambient color across the color spectrum based on the sine\n    //of the global time\n    ambColor = vec4(cos(iTime)/40.0+.01, sin(iTime)/75.0+.01, (cos(iTime)+sin(iTime))/100.0+.01, 1.0);\n    \n    //Add our main light to the light list\n    lights[0] = light;\n    \n    //Set up our tubes scattered across the tube space.\n    float ycurr = 1.0;\n    float xcurr = -12.0;\n    \n    int currTubeNum = 0;\n    \n    //Amount that we want to stagger every other row of tubes.\n    float stagger = 1.9;\n    \n    for (int i = 0; i < numTubes; i++)\n    {   \n        //Set the position of the tube's blob. It will move up the length of \n        //the tube, while also animating to the audio. The blobs in each tube\n        //all start at different locations along the tube.\n        float blobLoc = hash(float(i))*wave*70.0-50.0+(fract(iTime))*50.0;\n        \n        //If we've reached the top of the tube, go back down.\n        if (blobLoc > 5.0)\n        {\n            blobLoc -= 15.0;\n        }\n        \n        //Add this tube and its blob light source to the tube and light lists.\n        tubes[i] = vec4(xcurr, ycurr, 0.5,blobLoc);\n        lights[i+1] = vec3(xcurr, blobLoc, ycurr);\n        \n        //Move to the x location where we will place our next tube.\n        xcurr += tubeSpace.x/5.0;\n        \n        //If we've reached the end of an even row, jump to the next row\n        //without staggering.\n        if (mod(ycurr,2.0)==0.0 && xcurr > 12.0+stagger)\n        {\n            xcurr = -12.0;\n            ycurr += tubeSpace.y/5.0;\n        }\n        \n        //If we're at the end of an odd row, jump to the next row with some\n        //stagger\n        if (mod(ycurr,2.0)!=0.0 && xcurr > 12.0)\n        {\n            xcurr = -12.0+stagger;\n            ycurr += tubeSpace.y/5.0;\n        }\n    }\n    \n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;  \n    \n    //Render!\n    render(fragColor, vec3(p, cam.z+2.0));\n}","name":"Image","description":"","type":"image"}]}