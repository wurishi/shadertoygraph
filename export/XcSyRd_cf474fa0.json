{"ver":"0.1","info":{"id":"XcSyRd","date":"1722794308","viewed":84,"name":"The Gate by the WildLochs","username":"Pulzar","description":"6th place in Assembly Summer 2024 4k intro.\n\nAdapted from final commit to our git repo. Readme in Common. Contains all bugs and stupid comments as is.\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["assembly","4kintro","assembly2024","assemblysummer2024"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* uses some snippets from:\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\n//precision mediump float;\n#define u_resolution iResolution\n//#define u_time iTime*60./116.\n\nfloat u_time ()\n{\n    return iTime*60./116.;\n}\n\nconst float PI = 22./7.;\n\nvec3 no(vec3 v) { return normalize(v); }\nfloat cl(float a, float b, float c) { return clamp(a,b,c); }\n\n// Rotate\nmat2 rot2D(float angle) {\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat hash(vec2 p, int algo)\n{\n    if (algo == 1) {\n        float h = dot(p,vec2(127.1,311.7));\n        return fract(sin(h)*43758.5453123);\n    }\n    p = 50. * fract( p*0.3183099);\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise(vec2 p, float scale, int a)\n{\n    vec2 i = floor( p ),\n    f = fract( p ),\n\tu = f*f*(3.-2.*f);\n    float sc = scale;\n    if (a == 1) sc = 2.;\n    return -scale+sc*mix( mix( hash( i + vec2(0.), a),\n                              hash( i + vec2(1.0,0.0), a ), u.x),\n                         mix( hash( i + vec2(0.0,1.0), a),\n                              hash( i + vec2(1.), a), u.x), u.y);\n}\n\n/////////////////\n//   GEOMETRY  //\n/////////////////\n/*float sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}*/\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox2(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h, float rot )\n{\n    p.xy *= rot2D(rot);\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*.866025+p.y*.5,-p.y)-h.x*.5);\n}\n\nfloat sdPyramid( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.577;// 35027;\n}\n\n//////////////////\n//   ANIMATION  //\n//////////////////\n\n// POSITIONS\n//const vec3 glyph1Pos = vec3(1.7,-1.1,0.0);\n//const vec3 glyph2Pos = vec3(2.0,0.0,0.0);\n\n//const vec3 glyph4Pos = vec3(0.0,2.0,0.0)\n//const vec3 glyph6Pos = vec3(1.5 * -1.,1.4,0.0);\n//const vec3 glyph7Pos = vec3(1.7 * -1.,-1.1,0.0);\n\n// DELAYS\nfloat STARTDELAY = 9., glow = 0.;\n\n// POSITIONS\n\n\n// COLORS\nvec3 chevronColor = vec3(0.36, 0.9, 0.0);\n\n//  with duration d, startTime s and speed up with timeFact\nfloat timedSine(vec3 i) {\n    return min((u_time()  - i.y)*i.z, i.x*PI);\n}\n\nfloat calcFactor (float startTime)\n{\n    return STARTDELAY + STARTDELAY*cl(sin(timedSine(vec3(1.5, startTime, 4.)) * 0.06), -.9, .9);\n}\n\n// Animate ring movements\nvec3 ringAnim(vec3 p) {\n    for (float i = 0.; i < 7.; i++) {\n        float rotateDelay = STARTDELAY + (i * 3.), o=1.;\n        if(u_time() > rotateDelay) {\n            if(mod(i,2.) >= 1.) o = -1.;\n            p.xy *= rot2D(calcFactor(rotateDelay)*o);\n        }\n    }\n    return p;\n}\n\n// Animate prism movements\nfloat prismAnim(vec2 i) {\n    if(u_time() >= i.y) {\n        i.x += (.045*cl(sin((timedSine(vec3(3., i.y, 40.)) * .4)),-.8, .8));\n    }\n    return i.x;\n}\n\n//////////////\n//   SCENE  //\n//////////////\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv, 1., 1);\n    vec2 wv = 1.0-abs(sin(uv));\n    wv = mix(wv, abs(cos(uv)),wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nvec3 map(vec3 p, int displace)\n{\n    float mat = 0., glo = 1e3,\n    // Ring boxes\n    an = PI/12.,\n    step,\n    anRot = floor(atan(p.y,p.x)/an + .5)*an;\n    vec3 q = p;\n    q.xy = rot2D(anRot)*q.xy;\n    float d = length(max(abs(q.xy - vec2(1.8,0.))-vec2(0.24,0.14),0.)) - .02,\n\n    // Main ring\n    d2 = abs(length(p.xy) - 1.8) - .2;\n    d = min(d,d2);\n\n    // Inner ring\n    d2 = smax(  abs(length(p.xy) - 1.75) - .08, abs(p.z - .1)-.04, .005 );\n    d = max(-d2,d);\n\n    // Depth slice rings\n    d = smax( d, abs(p.z)-.1, .02 );\n\n    //Rotating glyphs\n    vec3 p2 = ringAnim(p), q2=p2;\n    an = PI/16.;\n    q2.xy = rot2D(floor((atan(p2.y,p2.x)/an) + .5)*an)*q2.xy;\n    d2 = sdBox2( q2.xyz - vec3(1.75,0.,0.), vec3(.04, .14, .05) ) - .02 + noise(p.xy*100.,1e-3,0);\n    d = min(d, d2);\n    if (d==d2) mat = 6.;\n\n    // Gate Base\n    d2 = 1e3;\n    float stepDist = 1.5, h = 0.0, d3, choppy=4., freq=0.6, amp=.2;\n    for(int i = 0; i < 4; i++) {\n        step = sdBox2(vec3(p.x,p.y+stepDist+0.05,p.z), vec3(2., .2,stepDist)) - .05;\n        d2 = min(d2, step);\n        stepDist += .2;\n    }\n    d2 += noise(p.xz * 50.+200., .007, 0);\n    d = min(d, d2);\n    if (d==d2) mat = 2.0;\n\n    if (displace == 1) {\n        vec2 uv = p.xy;\n        for(int i = 0; i < 4; i++) {\n            d3 = sea_octave((uv+u_time())*freq,choppy);\n            d3 += sea_octave((uv-u_time())*freq,choppy);\n            h += d3 * amp;\n            uv *= mat2(1.6,1.2,-1.2,1.6); freq *= 1.9; amp *= 0.22;\n            choppy = mix(choppy,1.0,0.4);\n        }\n    }\n    d2 = max(-sdCappedCylinder(p, 2.0, min((1.7 - (u_time() - 28.9)*2.5),2.3)), sdCappedCylinder(p, .025, 1.6) - h*0.15);\n    d2 = max(d2, sdCappedCylinder ( p, 0.3, 1.7));\n    d = min(d, d2);\n    if (d==d2) {\n        mat = 1.0;\n    }\n\n    // sand\n    d2 = (p.y +3.7) + noise((vec2((p.x),(p.z*.44-40.))*.04)+100., 20., 0) + .25*sin(p.z*.5+u_time());\n    d = min(d,d2);\n    if (d==d2) mat = 3.0;\n\n    // pyradmid\n    d2 = sdPyramid(p+vec3(-75., 0., 100.), 60.);\n    d = min(d, d2);\n    if (d==d2) mat=3.;\n    // Prisms\n    for(float i = 0.; i < 8.; i++ ) {\n        q = p;\n        anRot = 24.67 / (PI * 2.) + (i+1.) * PI / 4.;\n\n        // Nudge first and the last prism out of the ground\n        if (i == 1.) anRot += .2;\n        if (i == 7.) anRot -= .2;\n        q.xy = rot2D(anRot) * q.xy;\n        float rotateDelay = STARTDELAY + (i - 1.) * 3. + 1.5;\n        // We can now call each prism by it's index\n        // draw all except the middle bottom prism\n        if (i > 0.) {\n            q.x -= 1.95;\n            vec3 q2 = q; // new point for movable parts\n            if(u_time() > rotateDelay) q2.x = prismAnim(vec2(q2.x, rotateDelay));\n            float prismTop = sdTriPrism(vec3(q.x - .06, q.y, q.z), vec2(.1,.15), .5) -.01;\n            d2 = max(-sdTriPrism(vec3(q2.x - .14, q2.y - 0. , q2.z), vec2(.22), .5) - .01 , sdTriPrism(vec3(q2.x, q2.y, q2.z ), vec2(.2,.12), .5) - .02);\n            d2 = min(d2, prismTop);\n            d = min(d, d2);\n            // glyph locking thing material\n            if (d == d2) mat = 4.;\n            // glyph locking prism material\n            if( d == prismTop) if(u_time() > rotateDelay + .2) {\n                mat = 5.;\n                glo = min(d2, prismTop);\n            }\n        }\n    }\n\n    return vec3( d, mat, glo);\n}\n\n////////////////\n//   DRAWING  //\n////////////////\n\nfloat rayMarch(vec3 ro, vec3 rd, int a) {\n    vec3 d;\n    float t = 0.; // total distance travelled\n    // Raymarching\n    for (int i = 0; i < 100; i++) {\n        d = map(ro + rd * t, 0); // Get distance to objects\n        if (a==0&&d.z<0.3) glow += pow(0.01/d.z,0.8)*0.6;\n        t += d.x; // \"march\" the ray\n        if (d.x < 1e-3 || t > 500.) break;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.01, 0.);\n    vec3 n = map(p, 1).x - vec3(\n        map(p-e.xyy,1).x,\n        map(p-e.yxy,1).x,\n        map(p-e.yyx,1).x);\n    return no(n);\n}\n\nfloat getLight(vec3 p, vec3 lightPos, float intensity, float shadow, vec3 n, float atte) {\n    vec3 l = no(lightPos - p);\n    float len = length( lightPos - p ); // Distance from the light to the surface point.\n    float dif = cl(dot(n, l)*intensity, 0., intensity) * 1.0 / (1.0 + atte*len),\n    d = rayMarch(p+n*.0025, l, 1);\n    if(d<length(lightPos-p)) dif *= shadow;\n    return dif;\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\nfloat specular(vec3 normal,vec3 lightPos,vec3 rayOrigin,float specular) {\n    float nrm = (specular + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(rayOrigin,normal),lightPos),0.0),specular) * nrm;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye) {\n\n    vec3 color = vec3(0.0, 0.1, 0.3) + diffuse(n,l,60.0) * vec3(0.11, 0.16, 0.18) * 0.3;\n    color -= vec3(0.07, 0.15, 0.66) * cl(1.-dot(n, -eye), 0., 1.);\n    color += vec3(specular(n,l,eye,60.0))*0.2;\n    return color;\n}\n\n\nvec3 applyFog(vec3 col, float t, vec3 rd, vec3  lightDir, float b ) {\n    vec3 fogColor = mix( vec3(0.34, 0.11, 0.34), // blue\n                         vec3(0.93, 0.37, 0.16), // yellow\n                         pow(max( dot(rd, lightDir), 0.) ,8.));\n    return mix( col, fogColor, 1.0 - exp(-t*b) );\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = no(l-p),\n        r = no(cross(vec3(0.,1.,0.), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = no(i);\n    return d;\n}\n\nvec3 postProcess(vec3 col) {\n    // Vignette\n    //col *= smoothstep(0.9, 0.5, length(gl_FragCoord.xy/u_resolution.xy-vec2(.5)));\n    // Colour mapping\n    col *= vec3(.9, 0.8, 0.7);\n    // gamma\n    col = pow( col, vec3(.45) );\n    // Contrast = a\n    col = smoothstep(0., 1., col);\n\n    // fade out at the end\n    col += 1.0 - vec3(cl((46. - u_time())*.5, 0., 1.0));\n    return col;\n}\n\nvec3 cameraPos()\n{\n    // first zoom in to the gate\n    vec3 cPos = vec3(0., cl(6.-u_time(),2.,6.), cl((100.-u_time()*11.),6.,100.));\n    if (u_time() > 7.5) cPos += vec3(0., cl(7.5-u_time(),-1.,0.), 0.);\n    // close up shot for 1st glyph lock\n    if (u_time() > 10.5) cPos = vec3(2.,-1.,1.);\n    // zoom away for 2nd glyph animation\n    if (u_time() > 12.) cPos = vec3(-1., -.7, 4.);\n    if (u_time() > 14.5) {\n    cPos = vec3(0., 0., 4.);\n    cPos.yz *= rot2D(-0.6-(cos(u_time()-15.))*0.05);\n    cPos.xz *= rot2D(sin((u_time()-16.5)*0.1));\n    }\n    if (u_time() > 23.5)\n    {\n        cPos = vec3(3., -.7, 4.);\n    }\n    if (u_time() > 32.5)\n    {\n        cPos = vec3(-20.,10.,50.);\n    }\n    if (u_time() > 36.5) {\n        cPos = vec3(3., -.7, 4.);\n        cPos.yz *= rot2D(((1.-cos(u_time()-36.5))*-0.025));\n        cPos.xz *= rot2D(sin((u_time()-36.5)*0.07));\n    }\n\n    return cPos;\n}\n\nvec3 cameraPointAt() {\n    vec3 p = vec3(0., -.5, 0.);\n    // look at 1st glyph\n    if (u_time() > 10.5) p = vec3(1.7,-1.1,0.);\n    // look gate at distance\n    if(u_time() > 12.) p = vec3(0.);\n    if(u_time() > 14.5) p = mix(vec3(1.5,1.4,0.0),vec3(-1.5,1.4,0.0), (u_time()-16.5)*0.13);\n    if(u_time() > 23.5) p = vec3(0.);\n    return p;\n}\n\n// flash screen with glyph color when it is locked\nvec3 colorFlashesAnim(vec3 col) {\n    if(u_time() > 10.75) {\n        float x = smoothstep(-1.,.8,sin((timedSine(vec3(.8, 10.75, 8.))*2.)));\n        col = mix(col, chevronColor * (x * 1.4), x *.76);\n    }\n    return col;\n}\n\nvec3 addSpecular(vec3 nor, vec3 rod, float amount, float phong)\n{\n    return vec3(specular(nor,no(vec3(0.0,0.3,0.8)),no(rod),pow(10.,phong)))*amount;\n}\n\nvec3 sceneGate(vec2 uv)\n{\n    // Initialization\n    vec3 ro = cameraPos(),\n    rd = getCameraRayDir(uv, ro, cameraPointAt(), cl((43.-u_time())*-2.,2.,25.)),\n    col = vec3(0.);\n    float d = rayMarch(ro, rd,0), mat = 0.;\n\n    if (d < 500.) {\n        // Lighting\n        vec3 p = ro + rd * d,\n        n = getNormal(p);\n        mat = map(p,0).y;\n        // Light 1 Arguments\n        // 1: Ray starting point\n        // 2: Light position\n        // 3: Light intensity\n        // 4: Shadow intensity\n\n        // Lights\n        col += vec3(0.82, 0.5, 0.9) * getLight(p,  vec3( 10., 15., 25.), 1., .2,n,1e-10);\n        col += vec3(0.79, 0.66, 0.43) * getLight(p,  vec3( 4., 2., -15.), 1., 1.,n,1e-10);\n        col += vec3(0.0, 0.06, 0.7) * getLight(p,  vec3( 0., 0., 5.),cl((u_time()-29.0)*100.,0.,50.), 0.0,n,3.1);\n        // indirect lightning -> vec3 in normalize is light direction\n        col += vec3(0.29, 0.28, 0.33) * cl( dot( n, no(vec3(0. , 1., 10.))), 0., 1.);\n\n        if(mat==0.)\n            col *= vec3(0.2, 0.3, 0.3) + addSpecular(n,rd,.5, 2.);\n        if(mat==1.)\n            col *= getSeaColor(p, n, no(vec3(0.0,0.3,0.8)),no(rd));\n        if(mat==2.)\n            col *= vec3(0.7, 0.7, 0.4) + noise (p.xz*3.+1.5, 0.1,0);\n        if(mat==3.)\n            col *= vec3(.8, .8, .5) + noise(p.xz*500.+1e5, .3,0);\n        if(mat==4.)\n            col *= vec3(0.0, 0.08, 0.11) + addSpecular(n,rd,0.3,0.7);\n        if(mat ==5.)\n           col = chevronColor*0.4;// * pow(cl(1. -dot(n, -rd), 0., 1.), .3);\n        if(mat == 6.)\n            col *= vec3(0.01, 0.04, 0.06) + addSpecular(n,rd,.1, 2.5);\n   }\n   col += glow * chevronColor*.25;\n   return postProcess(colorFlashesAnim(applyFog(col, d, rd, vec3(0., -.1, -1.), .01)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(sceneGate( (fragCoord.xy * 2. - u_resolution.xy) / u_resolution.y), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Readme.txt\n__  .__               ________        __\n_/  |_|  |__   ____    /  _____/_____ _/  |_  ____\n\\   __\\  |  \\_/ __ \\  /   \\  ___\\__  \\\\   __\\/ __ \\\n |  | |   Y  \\  ___/  \\    \\_\\  \\/ __ \\|  | \\  ___/\n |__| |___|  /\\___  >  \\______  /____  /__|  \\___  >\n           \\/     \\/          \\/     \\/          \\/\n         4k intro for Assembly 2024 by the WildLochs\n                                   WD, Pulzar, Reaby\n\nWindows, GLSL, Compofiller Studio, Sointu, Crinkler,\nShader Minifier, Renoise\n\nThanks\nInigo Quilez, The Art of Code, SimonDev, kishimisu,\nshadertoy.com, sizecoding.org\n\nSpecial thanks\npestis / brainlez Coders!, Yzi/Fit\n\nWater displacement inspired from\n\"Seascape\" by Alexander Alekseev aka TDM - 2014\nhttps://www.shadertoy.com/view/Ms2SD1\nLicense Creative Commons\nAttribution-NonCommercial-ShareAlike 3.0 Unported\n*/","name":"Common","description":"","type":"common"}]}