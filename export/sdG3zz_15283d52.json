{"ver":"0.1","info":{"id":"sdG3zz","date":"1630957684","viewed":370,"name":"Triangle Tessellation","username":"PrzemyslawZaworski","description":"BufferA contains code for tessellation, where triangles positions are calculated from input index. Useful for vertex / compute shaders.\nChange tessellation factor in Common tab.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["procedural","tutorial","triangle","shader","tessellation","vertex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 Hash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    uint n = h32^(h32 >> 16);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat Triangle(vec2 p, vec2 a, vec2 b, vec2 c) \n{\n    vec2 ca = c - a, ba = b - a, pa = p - a, pb = p - b;\n    vec2 cb = c - b, pc = p - c, ac = a - c;\n    if ((ca.x * ba.y - ca.y * ba.x) < 0.0) { vec2 t = b; b = a; a = t; }\n    float d = (pa.x * ba.y - pa.y * ba.x) / length(ba);\n    d = min(d, (pb.x * cb.y - pb.y * cb.x) / length(cb));\n    d = min(d, (pc.x * ac.y - pc.y * ac.x) / length(ac)); \n    return step(0.0, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uint vertexCount = TessellationFactor * TessellationFactor * 3u;\n    fragColor = vec4(0.0);\n    for (uint i = 0u; i < vertexCount; i = i + 3u)\n    {\n        uint x = uint(mod(float(i), iResolution.y));\n        uint y = i / uint(iResolution.y);\n        vec2 a = texelFetch(iChannel0, ivec2(x + 0u, y), 0).xy;\n        vec2 b = texelFetch(iChannel0, ivec2(x + 1u, y), 0).xy;\n        vec2 c = texelFetch(iChannel0, ivec2(x + 2u, y), 0).xy;\n        fragColor += Triangle(uv, a, b, c) * vec4(Hash(i+13u), 1);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// GPU PRO 3, Advanced Rendering Techniques, A K Peters/CRC Press 2012\n// Chapter 1 - Vertex shader tessellation, Holger Gruen\nvoid Tessellation(uint id, uint tessellationFactor, vec3[3] vertexBuffer, out vec4 glPosition) \n{\n    if (id > (tessellationFactor * tessellationFactor * 3u)) return;\n    vec3 p1 = vertexBuffer[0];\n    vec3 p2 = vertexBuffer[1];\n    vec3 p3 = vertexBuffer[2];\n    uint subtriangles = (tessellationFactor * tessellationFactor);\n    float triangleID = float (( id / 3u ) % subtriangles); \n    float row = floor (sqrt( triangleID ));\n    uint column = uint(triangleID - ( row * row ));\n    float incuv = 1.0 / float(tessellationFactor);\n    float u = (1.0 + row) / float(tessellationFactor);\n    float v = incuv * floor (float(column) * 0.5);\n    u -= v;\n    float w = 1.0 - u - v;\n    uint vertexID = id / 3u / subtriangles * 3u + (id % 3u);\n    switch(vertexID % 3u)\n    {\n        case 0u:\n            if ((column & 1u) != 0u)\n            {\n                v += incuv, u -= incuv;\n            }\n            break;\n        case 1u:\n            if ((column & 1u) == 0u)\n            {\n                v += incuv, u -= incuv;\n            }\n            else\n            {\n                v += incuv, u -= incuv;\n                w += incuv, u -= incuv;\n            }\n            break;\n        case 2u:\n            if ((column & 1u) == 0u)\n            {\n                u -= incuv, w += incuv;\n            }\n            else \n            {\n                w += incuv, u -= incuv;\n            }\n            break;\n    }\n    glPosition = vec4(u * p1 + v * p2 + w * p3, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint vertexCount = TessellationFactor * TessellationFactor * 3u;\n    uint index = uint(int(fragCoord.y) * int(iResolution.y) + int(fragCoord.x)) % vertexCount;\n    vec4 glPosition = vec4(0.0);\n    Tessellation(index, TessellationFactor, VertexBuffer, glPosition);\n    fragColor = glPosition;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"uint TessellationFactor = 16u;\nconst vec3 VertexBuffer[3] = vec3[3](vec3(0.00, 0.75, 0.00), vec3(0.75, -0.75, 0.00), vec3(-0.75, -0.75, 0.00));","name":"Common","description":"","type":"common"}]}