{"ver":"0.1","info":{"id":"DltGz8","date":"1681942254","viewed":49,"name":"RGB Färjan","username":"testaccountplsignore","description":"very serious shader, serious comments only","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["farjan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RM_ITER 256\n#define HIT_DST 0.005\n#define TRAVEL_DST 128.0\n#define DYDX_DST 0.01\n\nconst float PI = acos(-1.);\n\nmat2 rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));\n}\n\n//patented high quality färjan model\nfloat farjan(vec3 p){    \n    vec3 px = p;\n    float hull = box(px,vec3(4,1,1));\n    vec3 pp = px;\n    pp.x-=3.;\n    pp.xy*=rot(2.4);\n    float d=max(pp.y,hull);\n    \n    px.xy += vec2(.1,-1.33);\n    float deck = box(px,vec3(3.5,.33,1.));\n    d = min(d,deck);\n    \n    vec3 py = px + vec3(-1.4,.08,0.);\n    py.x *= .6;\n    float bridge = length(py)-1.;\n    d = min(d,bridge);\n    \n    px += vec3(1.8,-.7,0.55);\n    px.xy *= rot(-.5);\n    float chimney1 = box(px,vec3(.5,1.2,.25));\n    d = min(d,chimney1);\n    \n    px.z -= 1.1;\n    float chimney2 = box(px,vec3(.5,1.2,.25));\n    d = min(d,chimney2);\n    \n    return d;\n}\n\nfloat msin(float x){return .5*(sin(iTime+x)+1.);}\n\nfloat scene_distance(vec3 p, out vec3 ocol){\n    vec3 sea_col = vec3(0.3,0.4,1.0) * .1*(sin(iTime*3.)+9.);\n    vec3 f_col = .8*vec3(.5+msin(0.),msin(.66*PI),msin(1.33*PI));\n    \n    float sea = (sin(p.x + iTime*3.)+1.0)*cos(p.z*0.5)*(sin(iTime*5.0)*0.3);\n    float p1d = p.y - sea;\n    \n    vec3 px = p - vec3(-1.,0.25,10.);\n    px.x += sin(iTime*.5)*.5;\n    px.xy *= rot(sin(iTime*4.)*.05);\n    float f = farjan(px);\n    \n    float sd;\n    if(f<p1d){\n        sd=f;\n        ocol=f_col;\n    }\n    else{\n        sd=p1d;\n        ocol=sea_col;\n    }\n    \n    return sd;\n}\n\nvoid raymarch(in vec3 ro, in vec3 rd, out vec3 cp, out vec3 ocol, out float td, out float sd){\n    vec3 cp_l = ro;\n    float td_l = 0.0;\n    float sd_l;\n    vec3 ocol_l;\n    for(int i=0;i<RM_ITER;i++){\n        sd_l = scene_distance(cp_l, ocol_l);\n        if(sd_l<HIT_DST || td_l>TRAVEL_DST){break;}\n        td_l += sd_l;\n        cp_l += rd * sd_l;\n    }\n    cp = cp_l;\n    td = td_l;\n    sd = sd_l;\n    ocol = ocol_l;\n}\n\nvec3 surface_normal(vec3 p, float sd){\n    vec3 ocol;\n    vec2 e = vec2(0.,DYDX_DST);\n    float dx = scene_distance(p - e.yxx, ocol);\n    float dy = scene_distance(p - e.xyx, ocol);\n    float dz = scene_distance(p - e.xxy, ocol);\n    vec3 n = sd - vec3(dx,dy,dz);\n    return normalize(n);\n}\n\nfloat lighting(vec3 p, float sd){\n    vec3 light1 = vec3(0.0,50.0,-15.0);\n    vec3 l1v = normalize(light1 - p);\n    vec3 pn = surface_normal(p, sd);\n    float diffuse = clamp(dot(l1v,pn),0.,1.);\n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*fragCoord/iResolution.x - vec2(1.,iResolution.y/iResolution.x);\n    vec3 ro = vec3(0.0,3.5,0.0);\n    vec3 rd = normalize(vec3(uv,1.0));\n    \n    vec3 cp;\n    vec3 ocol;\n    float td;\n    float sd;\n    raymarch(ro,rd,cp,ocol,td,sd);\n   \n    vec3 col = 1.-vec3(.9,.8,.3)*uv.y;\n    if(td < TRAVEL_DST){col = ocol * lighting(cp,sd);}\n    fragColor = vec4(col,1.0);\n} \n \n","name":"Image","description":"","type":"image"}]}