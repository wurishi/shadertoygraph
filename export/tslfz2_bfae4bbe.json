{"ver":"0.1","info":{"id":"tslfz2","date":"1588697185","viewed":313,"name":"Optical overflow","username":"BagelOrb","description":"Measuring optical flow and exaggerating it.\n\nUsing a hierarchical adaptation of the Lucasâ€“Kanade method.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat compression = .02;\nfloat compress(float f)\n{ return (f * compression) *.5 + .5; }\nfloat decompress(float f)\n{ return (f - .5) * 2. / compression; }\nvec2 compress2(vec2 v)\n{ return vec2(compress(v.x), compress(v.y)); }\nvec2 decompress2(vec2 v)\n{ return vec2(decompress(v.x), decompress(v.y)); }\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= .5;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec4 flow = texture(iChannel3, fragCoord / iResolution.xy);\n    vec4 flow_raw = texture(iChannel1, fragCoord / iResolution.xy);\n    \n    uv += decompress2(flow.rg) * .05;\n    \n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n    //fragColor = (flow + .5) * 5.;\n    //fragColor.xy = decompress2(flow_raw.xy)*4.;\n    //fragColor.xy = decompress2(flow.xy) + .5;\n    //fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// generate multiple scaled images\n\nbool subdivisions = true;\n\nvec4 green = vec4(.05,.637,.148,1.);\n\nfloat d(vec4 a, vec4 b)\n{\n    return length(a.rgb - b.rgb);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (subdivisions)\n    {\n        uv *= 2.;\n        for (int i = 0; i < 6; i++)\n        {\n            if (uv.x < 1.) { break; }\n            uv = uv - vec2(1., 0.);\n            uv *= 2.;\n        }\n    }\n    vec4 original = texture(iChannel0, uv);\n    fragColor = original;\n    \n    fragColor *= smoothstep(.2, .3, d(original, green));\n    fragColor += smoothstep(.3, .2, d(original, green)) * texture(iChannel1, uv);\n    fragColor.rgb -= green.rgb * smoothstep(.5, .3, d(fragColor, green));\n    \n    fragColor = fragColor * 1.2 - .1;\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// flow field\n\n\n\n\nfloat field_r = 5.;\n\n\nfloat compression = .02;\nfloat compress(float f)\n{ return (f * compression) *.5 + .5; }\nfloat decompress(float f)\n{ return (f - .5) * 2. / compression; }\nvec2 compress2(vec2 v)\n{ return vec2(compress(v.x), compress(v.y)); }\nvec2 decompress2(vec2 v)\n{ return vec2(decompress(v.x), decompress(v.y)); }\n\nbool outOfBounds(vec2 coord)\n{\n    if (coord.x < 0.\n        || coord.y < 0.\n        || coord.x >= iResolution.x\n        || coord.y >= iResolution.y)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }   \n}\n\nfloat dx(vec2 pos, vec2 initial)\n{\n    vec4 here = texture(iChannel0, (pos + initial) / iResolution.xy);\n    vec4 next = texture(iChannel0, ((pos + initial) + vec2(1., 0.)) / iResolution.xy);\n    return length(next.rgb - here.rgb) / sqrt(3.); \n}\n\nfloat dy(vec2 pos, vec2 initial)\n{\n    vec4 here = texture(iChannel0, (pos + initial) / iResolution.xy);\n    vec4 next = texture(iChannel0, ((pos + initial) + vec2(0., 1.)) / iResolution.xy);\n    return length(next.rgb - here.rgb) / sqrt(3.); \n}\n\nfloat dt(vec2 pos, vec2 initial)\n{\n    vec4 here = texture(iChannel2, pos / iResolution.xy);\n    vec4 next = texture(iChannel0, (pos + initial) / iResolution.xy);\n    return length(next.rgb - here.rgb) / sqrt(3.); \n}\n\n\nvec2 flow(vec2 pos)\n{\n    mat2 translations = mat2(0.,0.,0.,0.);\n    vec2 deltas = vec2(0.,0.);\n    \n    \n    vec2 smaller_pos = vec2(1., 0.) - .5 * (vec2(1.,0.) - pos);\n    vec2 initial = 1.8 * decompress2(texture(iChannel3, smaller_pos).xy);\n    \n    for (float x = - field_r; x <= field_r; x++)\n    for (float y = - field_r; y <= field_r; y++)\n    {\n        if (outOfBounds(pos + vec2(x, y)))\n        {\n            continue;\n        }\n        float dxx = dx(pos + vec2(x,y), initial);\n        float dyy = dy(pos + vec2(x,y), initial);\n        float dtt = dt(pos + vec2(x,y), initial);\n        \n    \tdeltas.x -= dxx * dtt;\n    \tdeltas.y -= dyy * dtt;\n        \n        translations[0][0] += dxx * dxx;\n        translations[0][1] += dxx * dyy;\n        translations[1][1] += dyy * dyy;\n        \n    }\n    translations[1][0] = translations[0][1];\n    \n    if (determinant(translations) < .001) return vec2(0., 0.);\n    \n    return inverse(translations) * deltas;// + initial;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    float total_w = 0.;\n    vec2 pos_total = vec2(0.,0.);\n    for (float x = - field_r; x <= field_r; x++)\n    for (float y = - field_r; y <= field_r; y++)\n    {\n        if (outOfBounds(fragCoord + vec2(x, y)))\n        {\n            continue;\n        }\n        vec2 rel = vec2(x, y);\n        float w = weight(fragCoord, fragCoord + rel, rel);\n        total_w += w;\n        pos_total += w * rel;\n    }\n    vec2 flow = pos_total / total_w;\n    */\n    vec2 flow = flow(fragCoord);\n    \n    fragColor = vec4(0.,0.,0.,1.);\n    fragColor.rg = compress2(flow);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// previous frame\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// morfed flow\n\n\nfloat blur_r = 10.;\n\nbool outOfBounds(vec2 coord)\n{\n    if (coord.x < 0.\n        || coord.y < 0.\n        || coord.x >= iResolution.x\n        || coord.y >= iResolution.y)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 flow = texture(iChannel1, fragCoord / iResolution.xy);\n    vec4 current = texture(iChannel3, fragCoord / iResolution.xy);\n    \n    \n    float total_w = 0.;\n    vec4 blur_total = vec4(0.,0.,0.,1.);\n    for (float x = - blur_r; x <= blur_r; x++)\n    for (float y = - blur_r; y <= blur_r; y++)\n    {\n        if (outOfBounds(fragCoord + vec2(x, y)))\n        {\n            continue;\n        }\n        float w = 1. / (.5 + length(vec2(x,y)));\n        total_w += w;\n        blur_total += w * texture(iChannel1, (fragCoord + vec2(x,y)) / iResolution.xy);\n    }\n    vec4 blurred = blur_total / total_w;\n    \n    vec4 here = blurred;// * .75 + .25 * flow;\n    \n    fragColor = current * .9 + .1 * here;\n}","name":"Buf D","description":"","type":"buffer"}]}