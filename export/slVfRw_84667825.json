{"ver":"0.1","info":{"id":"slVfRw","date":"1665569211","viewed":161,"name":"Hex Pattern Generator II","username":"spontificus","description":"sooo... this was meant to be a tool for something else, but it's quite pretty in its own right, ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["experimental","hexagonal"],"hasliked":0,"parentid":"7lKBzh","parentname":"NoName Paint II"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of https://www.shadertoy.com/view/stVBRR\n// thanks!\n\n#define C(c) O+= char(U,64+c) ; U.x+=.5\n#define LF (U.y++)\n#define CR (U.x = (( uv.x - position.x)*64.0/FontSize))\n#define NL (CR,LF)\n\nint mouseI;\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n\n// takes in a hexgrid coordinate and displays the squared hexgrid distance\n// haaaaaack\n// torn between cleaning this up, or just spinning my own\n//\nvec4 text( vec2 uv, ivec3 coord )\n{\n    vec4 O = vec4(0.0);\n    uv /= iResolution.y;\n    float FontSize = 2.;\n    vec2 position = vec2(1.,0.05 - FontSize / 64.0);\n    vec2 U = ( uv - position)*64.0/FontSize;\n    bool positive = true;\n    \n    int num = coord.x*coord.x + coord.y*coord.y + coord.x*coord.y;\n    while (num > 10) {\n        int chr = num%10;\n        if (chr>0) {\n            C(-16+chr);\n        } else {\n            C(-16);\n        }\n        num = num/10;\n    }    \n   \n    if (num < 10) {\n        C(-16+num);\n    } else {\n         C(-16);\n         C(-15);\n    }\n    C(-177); // sqrt glyph. we're printing this in reverse, look the other way\n    C(-3);   // =\n   \n   \n    num = ((coord.z));\n    if (num < 0) {\n        positive = false;\n        num = abs(num);\n    }\n    \n    while (num > 10) {\n        int chr = num%10;\n        if (chr>0) {\n            C(-16+chr);\n        } else {\n            C(-16);\n        }\n        num = num/10;\n    }       \n    if (num < 10) {\n        C(-16+num);\n    } else {\n         C(-16);\n         C(-15);\n    }\n    if (positive == false) {\n        positive = true;\n        C(-19);\n    }\n    \n    C(-20);  //,\n    \n    num = ((coord.y));\n    if (num < 0) {\n        positive = false;\n        num = abs(num);\n    }\n    \n    while (num > 10) {\n        int chr = num%10;\n        if (chr>0) {\n            C(-16+chr);\n        } else {\n            C(-16);\n        }\n        num = num/10;\n    }       \n    if (num < 10) {\n        C(-16+num);\n    } else {\n         C(-16);\n         C(-15);\n    }\n    if (positive == false) {\n        positive = true;\n        C(-19);\n    }\n    \n    C(-20);  // ,\n    \n    num = coord.x;\n    if (num < 0) {\n        positive = false;\n        num = abs(num);\n    }\n    while (num > 10) {\n        int chr = num%10;\n        if (chr>0) {\n            C(-16+chr);\n        } else {\n            C(-16);\n        }\n        num = num/10;\n    }    \n   \n    if (num < 10) {\n        C(-16+num);\n    } else {\n         C(-16);\n         C(-15);\n    }\n    if (positive == false) {\n        positive = true;\n        C(-19);\n    }\n    \n    NL;\n   // C(coord.x);\n    \n    return O.xxxx;\n}\n\n// end of forkiness\n\n\nbool myInRange(int t, int v1, int v2) {\n    return (abs(t - v1) + abs(v2 - t) <= abs(v2 - v1));\n}\n\n// centered and anti-square\nivec3 screenToHex( vec2 p ) {\n    int j = int(iResolution.y-p.y)/2 - int(iResolution.y/4.);\n    int i = (int(p.x) - j )/2 - int(iResolution.x/4.);\n    return ivec3(i,j,-(i+j));\n}\n\n\n// squarerootless solution\nint hexDist(ivec3 p1, ivec3 p2) {\n    return (p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y) + (p2.x-p1.x)*(p2.y-p1.y);\n    //return int(sqrt(float((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y) + (p2.x-p1.x)*(p2.y-p1.y))));\n}\n\n// precomputing k=-(i+j) shaves a couple percent\nint hexDist(int i, int j) {\n    return i*i + j*(i+j);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec3 center = ivec3(0,0,0);\n    ivec3 fragHex = screenToHex(fragCoord.xy);\n    ivec3 mouseHex = screenToHex(iMouse.xy);\n    int mouseDist = hexDist(mouseHex,center);\n    int mdist = hexDist(mouseHex,center);\n    int pdist = hexDist(fragHex,center);\n    \n    mouseI = mouseHex.x;\n    int mouseJ = mouseHex.y;\n    int fragI = fragHex.x;\n    int fragJ = fragHex.y;\n   \n    int rangeMin = -7;\n    int rangeMax = 7;   \n   \n   /*\n    if(abs(pdist-mdist) > rangeMax)\n        if (!myInRange(pdist,mdist-30,mdist+30)) \n            discard;\n   */\n    vec4 col = vec4(.1,.1,.1,1.);\n   \n\n    if ( fragHex == mouseHex ) {\n        col = vec4(1., 1., 1., 1.);\n    }\n    \n     \n    // center dot\n    if (fragI == 0 && fragJ == 0) {\n        col = vec4(1., 1., 1., 1.);   \n    }\n\n    if (mdist % pdist == 0) {\n        col += vec4(0.,1.,1., 1.);   \n    }\n    if (pdist % mdist == 0) {\n        if (abs(fragI) % 2 == abs(mouseI) % 2 && abs(fragJ) % 2 == abs(mouseJ) % 2) {\n            col += vec4(1.,0.,1., 1.);   \n        } else {\n            col += vec4(.5,.5,.0, 1.);   \n        }\n        \n    }\n    \n\n    if (pdist == mouseDist ) {\n       col = vec4(1.,1.,1., 1.);   \n    }\n    \n    int r = max(abs(mouseI),abs(mouseJ)) - min(abs(mouseI),abs(mouseJ));\n    for (int i = 0; i<r; i++) {\n        int ld = 0;\n        if (mouseI<mouseJ) {\n            ld = hexDist(mouseI + i, mouseJ);\n        } else {\n            ld = hexDist(mouseI, mouseJ + i);\n        }\n        if (pdist == ld ) {\n            float cr = .75 * (float(i)/float(r));\n            col += vec4(0.,cr,0., 1.); \n        }\n    }\n    \n    r = (abs(mouseI)+abs(mouseJ));\n    for (int i = max(mouseI,mouseJ); i<r; i++) {\n        int ld = 0;\n        if (mouseI<mouseJ) {\n            ld = hexDist(mouseI, i);\n        } else {\n            ld = hexDist( i, mouseJ);\n        }\n        if (pdist == ld ) {\n            float cr = .75 * (float(i)/float(r));\n            col += vec4(0.,0.,cr, 1.); \n        }\n    }\n    \n    col += text(fragCoord,mouseHex);\n    \n//    if ( col == vec4(.1,.1,.1,1.) ) {\n //       discard;\n  //  }\n    \n    fragColor = col;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}