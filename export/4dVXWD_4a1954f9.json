{"ver":"0.1","info":{"id":"4dVXWD","date":"1464463802","viewed":294,"name":"Seascape with geometry","username":"udart","description":"Combination of seascape\nhttps://www.shadertoy.com/view/Ms2SD1\nand this\nhttps://www.shadertoy.com/view/Mdt3RX\n\nJust learning by cutting and pasting and tinkering.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sea","radiolarian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PHI (sqrt(5.)*0.5 + 0.5)\n#define PI 3.14159265\n\n#define t iTime\n\n\nvec2 rot2D(vec2 p, float angle) {\n\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n        \n    \n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\nvec3 pModDodecahedron(inout vec3 p) {\n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n    p.z = abs(p.z);\n    \n    pR(p.xz, -halfDdihedral);\n    pR(p.xy, faceAngle / 4.);\n    \n   \tp.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n   \tp.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n\tpModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n    \n    return p;\n}\n\nvec3 pModIcosahedron(inout vec3 p) {\n\n    vec3 v1 = normalize(vec3(1, 1, 1 ));\n    vec3 v2 = normalize(vec3(0, 1, PHI+1.));\n\n    float sides = 3.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n\n    p.z = abs(p.z);    \n    pR(p.yz, halfDdihedral);\n    \n   \tp.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n     \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n  \n    pR(p.zy, halfDdihedral);\n   \tp.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n\tpModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n\n\treturn p;\n}\n\nfloat spikeModel(vec3 p) {\n    pR(p.zy, PI/2.);\n    return fCone(p, 0.25, 3.);\n}\n\nfloat spikesModel(vec3 p) {\n    float smoother = 0.6;\n    \n    pModDodecahedron(p);\n    \n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n    float spikeA = spikeModel(p);\n    \n    pR(p.zy, -dihedral);\n\n    float spikeB = spikeModel(p);\n\n    pR(p.xy, -faceAngle);\n    pR(p.zy, dihedral);\n    \n    float spikeC = spikeModel(p);\n    \n    return fOpUnionRound(\n        spikeC,\n        fOpUnionRound(\n            spikeA,\n            spikeB,\n            smoother\n       \t),\n        smoother\n   \t);\n}\n\nfloat coreModel(vec3 p) {\n    float outer = length(p) - .9;\n\tfloat spikes = spikesModel(p);\n    outer = fOpUnionRound(outer, spikes, 0.4);\n\treturn outer;\n}\n\nfloat exoSpikeModel(vec3 p) {\n    pR(p.zy, PI/2.);\n    p.y -= 1.;\n    return fCone(p, 0.5, 1.);\n}\n\nfloat exoSpikesModel(vec3 p) {\n    pModIcosahedron(p);\n\n    vec3 v1 = normalize(vec3(1, 1, 1 ));\n    vec3 v2 = normalize(vec3(0, 1, PHI+1.));\n\n    float dihedral = acos(dot(v1, v2));\n\n    float spikeA = exoSpikeModel(p);\n    \n    pR(p.zy, -dihedral);\n\n    float spikeB = exoSpikeModel(p);\n\n    return fOpUnionRound(spikeA, spikeB, 0.5);\n}\n\nfloat exoHolesModel(vec3 p) {\n    float len = 3.;\n    pModDodecahedron(p);\n    p.z += 1.5;\n    return length(p) - .65;\n}\n\nfloat exoModel(vec3 p) {    \n    float thickness = 0.18;\n    float outer = length(p) - 1.5;\n    float inner = outer + thickness;\n\n    float spikes = exoSpikesModel(p);\n    outer = fOpUnionRound(outer, spikes, 0.3);\n\t\n    float shell = max(-inner, outer);\n\n    float holes = exoHolesModel(p);\n\tshell = fOpIntersectionRound(-holes, shell, thickness/2.);\n    \n\treturn shell;\n}\n\n// Based on Template 3D by iq: https://www.shadertoy.com/view/ldfSWs\n\nfloat doModel(vec3 p) {\n    p.y -= 3.0;\n    \n    p.xz = rot2D(p.xz, (iTime) * 45.);\n    \n    float exo = exoModel(p);\n    float core = coreModel(p);\n    return min(exo, core);\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n    float an = 10.0 * mouse.x + PI / 2.;\n    //an = 10.;\n\n    //float d = 2. + sin(an) * 1.6;\n    float d = 2. + (1. - mouse.y) * 10.;\n    camPos = vec3(\n        sin(an),\n        sin(mouse.y * PI / 2.),\n        cos(an)\n    ) * d;\n\n   \tcamTar = vec3(0);\n}\n\nvec3 doBackground(void) {\n    return vec3(0.0);\n}\n\nvec3 doMaterial(in vec3 pos, in vec3 nor) {\n    return vec3(0.25);\n}\n\n\nfloat doRulerModel(vec3 p) {\n    return 1000.0;\n    float t = 0.1;\n    return abs(p.y) - mod(t/5., 1.);\n}\n\nfloat rule(float d, float scale) {\n    return mix(1., .35, smoothstep(.6, 1., abs(fract(d * scale) * 2. - 1.)));\n}\n\nvec3 rulerColor(float t) {\n    t = clamp(log(t+1.0), 0.0, 1.0);\n    return mix(mix(vec3(0.,.1,1.), vec3(1.,.1,0.), t*5.), vec3(1.0), smoothstep(.2,.5,t));\n}\n\nvec3 doRulerMaterial(vec3 p, float d, float t) {\n    float lt = log(t) / log(10.0);\n    float s = pow(10.0, -floor(lt));\n    float m = smoothstep(0.0, 0.33, fract(lt));\n    float r = rule(d, s * 10.) * mix(rule(d, s * 100.0), rule(d, s), m);\n    return mix(rulerColor(s * d), rulerColor(s * d * 0.1), m) * 0.8 * r;\n}\n\nfloat doCombinedModels(vec3 p) {\n    return min(doModel(p), doRulerModel(p));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd);\n\nvec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal) {\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    //vec3 lig = normalize(vec3(1.1, 0.7, 0.9));\n    vec3 lig = normalize(vec3(0.0,1.0,0.8)); \n    float dif = max(dot(nor, lig), 0.0);\n    float sha = 0.0;\n    if (dif > 0.01) sha = calcSoftshadow(pos + 0.01 * nor, lig);\n    lin += dif * vec3(2.) * sha;\n\n    // ambient light\n    //-----------------------------\n    //lin += vec3(0.5);\n\n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal * lin;\n\n    // fog\n    //-----------------------------\n    //col *= exp(-0.01 * dis * dis);\n\n    //Specular\n    float nrm = (60.0 + 8.0) / (3.1415 * 8.0);\n    col += pow(max(dot(reflect(rd,nor),lig),0.0),60.0) * nrm;\n \n//////experiment\n    \n    float fresnel = 1.0 - max(dot(nor,rd),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n    \n    //sky color\n\tvec3 e = reflect(rd,nor);\n    \n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    //Reflected\n    vec3 reflected = ret*0.05;\n\n    //Sea color\n    vec3 base = vec3(0.03,0.01,0.01);\n    vec3 scolor = vec3(0.1,0.04,0.0);\n\n    float diffuse = pow(dot(nor,lig) * 0.4 + 0.6,80.0)*200.0;\n  \t\n    //Refracted\n    vec3 refracted = base + diffuse * scolor * 0.32; \n    \n\t//Experiment - overwrite color\n\tcol = mix(refracted,col,fresnel);    \n    \n    //\n    \n    return col;\n}\n\nvec3 calcIntersection(in vec3 ro, in vec3 rd) {\n    const float maxd = 100.0;    // max trace distance\n    const float precis = 0.00001; // precission of the intersection\n    vec3 p;\n    float h = precis * 2.0;\n    float d, r;\n    float t = 0.0;\n    float res = -1.0;\n    for (int i = 0; i < 90; i++) // max number of raymarching iterations is 90\n    {\n        if (h < precis || t > maxd) break;\n        p = ro + rd * t;\n        r = doRulerModel(p);\n        d = doModel(p);\n        h = min(d, r);\n        t += h;\n    }\n\n    if (t < maxd) res = t;\n    return vec3(res, r < d ? 1.0 : 0.0, d);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    const float eps = 0.002; // precision of the normal computation\n\n    const vec3 v1 = vec3(1.0, -1.0, -1.0);\n    const vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    const vec3 v4 = vec3(1.0, 1.0, 1.0);\n\n    return normalize(v1 * doCombinedModels(pos + v1 * eps) + \n                     v2 * doCombinedModels(pos + v2 * eps) +\n                     v3 * doCombinedModels(pos + v3 * eps) + \n                     v4 * doCombinedModels(pos + v4 * eps));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd) {\n    float res = 1.0;\n    float t = 0.0005; // selfintersection avoidance distance\n    float h = 1.0;\n    for (int i = 0; i < 40; i++) { // 40 is the max numnber of raymarching steps\n        h = doModel(ro + rd * t);\n        res = min(res, 64.0 * h / t); // 64 is the hardness of the shadows\n        t += clamp(h, 0.01, 2.0);     // limit the max and min stepping distances\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\n/*\n\"Seascape\" by Alexander Alekseev aka TDM - 2014\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tdmaav@gmail.com\n*/\n\nconst int NUM_STEPS = 4;\n//const float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\n\n// sea\nconst int ITER_GEOMETRY = 1; //3\nconst int ITER_FRAGMENT = 4; //5\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.03,0.01,0.01);\nconst vec3 SEA_WATER_COLOR = vec3(0.1,0.04,0.0);\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p)*200.0;\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret*0.05;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p, float SEA_TIME) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p, float SEA_TIME) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps, float SEA_TIME) {\n    vec3 n;\n    n.y = map_detailed(p, SEA_TIME);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z), SEA_TIME) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps), SEA_TIME) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p, float SEA_TIME) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx, SEA_TIME);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm, SEA_TIME);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p, SEA_TIME);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat EPSILON_NRM\t= 0.1 / iResolution.x;\n\tfloat SEA_TIME = iTime * SEA_SPEED;\n\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    //vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);   \n    vec3 ang = vec3(0.0, 0.3, 0.0);\n    vec3 ori = vec3(0.0,4.5, 7.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n\n    //360 camera\n//   vec2 texCoord = fragCoord.xy / iResolution.xy; \n//    vec2 thetaphi = ((texCoord * 2.0) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n//    dir = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n\n\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p, SEA_TIME);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM, SEA_TIME);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n  \n    \n        //\n    \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n    \n    //\n\n    vec3 t = calcIntersection(ori, dir);\n    if (t.x > -0.5) {\n        // geometry\n        vec3 pos = ori + t.x * dir;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal;\n        if (t.y > 0.) {\n            mal = doRulerMaterial(pos, t.z, t.x);\n        \t//mal = doLighting(pos, nor, rd, t.x, mal);\n        } else {\n            mal = doMaterial(pos, nor);\n        }\n        \n        color = doLighting(pos, nor, dir, t.x, mal);\n    }\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}","name":"Image","description":"","type":"image"}]}