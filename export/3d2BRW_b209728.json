{"ver":"0.1","info":{"id":"3d2BRW","date":"1589666125","viewed":381,"name":"Infinite Split & Zoom","username":"ayquo","description":"We are Hork.\nInfinite journey to the center of a cube","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["ray","zoom","marching","infinite","split"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Haico ten Lohuis - Ayquo 2020\n// 2020-05-16 Initial release\n// 2020-06-08 Added reflection\n\n// RayMarching starting point - https://www.shadertoy.com/view/WtGXDD\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s*.5;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// Create multiple copies of an object - https://iquilezles.org/articles/distfunctions\nvec3 opRepLim( in vec3 p, in float s, in vec3 lima, in vec3 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\nfloat getDistCubes(vec3 p, float layer, float scale, float tx) {\n    vec3 dim = vec3(scale);\n    float f = (1.+tx+layer)*scale;\n    vec3 pr = opRepLim(p, f, vec3(-1.), vec3(1.));    \n\treturn max(sdBox(pr, dim), -sdBox(p, dim*1.1));\n}\n\nfloat getDist(vec3 p, float tx) {\n    float dim = mix(1., 3., tx);\n    float r = sdBox(p, vec3(dim));\n    for (float layer=0.; layer<ZOOM_LAYERS; layer+=1.)\n    {    \n        r = min(r, getDistCubes(p, layer, dim*pow(3., layer), tx));\n    }    \n    return r;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float tx) {\n    float dO=0.;    \n    vec3 p;\n    float dS;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n        p = ro + rd*dO;\n        dS = getDist(p, tx);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }    \n    return dO;\n}\n\nvec3 getNormal(vec3 p, float tx) {\n    float d = getDist(p, tx);\n    vec2 e = vec2(.001, 0);    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy, tx),\n        getDist(p-e.yxy, tx),\n        getDist(p-e.yyx, tx)\n    );    \n    return normalize(n);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n\tr = normalize(cross(vec3(0,1,0), f)),\n    u = cross(f,r),\n    c = p+f*z,\n    i = c + uv.x*r + uv.y*u,\n    d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*.25;\n    float tm = mod(t, 1.);\n    // Weighted average of linear and squared time, for smooth transitions\n    float tx = (tm*tm*2.+tm*3.)/5.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;   \n    vec3 cp = vec3(9., 6, -3);\n    cp.xy *= rot(t/1.5);\n    vec3 cd = getRayDir(uv, cp, vec3(0), 1.);\n    vec3 col;\n\tfloat dist= 0.;\n    float firstHitDist = 0.;\n    int passCount = 0;    \n    while (passCount <= MAX_REFLECTION_DEPTH) {\n\t\tdist = rayMarch(cp, cd, tx);    \n        dist -= EPSILON;\n        if (0==passCount) {\n        \tfirstHitDist = dist;\n        }        \n        if (MAX_DIST-EPSILON<dist) {\n            if (0==passCount) {\n                // Didn't hit anything first time\n                fragColor=vec4(BG_COLOR, 1.);\n                return;\n            } else {\n                // Reflected at least once, but did not hit anything this time\n                fragColor=vec4(col, 1.0);\n                break;\n            }\n        }        \n        if(MAX_DIST-EPSILON>dist) {\n            vec3 p = cp + cd * dist;\n            vec3 n = getNormal(p, tx);        \n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n            if (0 == passCount) {\n\t            col = dif*BASE_COLOR;\n            } else {\n    \t        col = (col*10. + dif*BASE_COLOR)/11.;\n            }            \n            cp = p;\n        \tcd = reflect(cd, n);            \n        }        \n        passCount++;\n    }\n\n    // Fog\n    // Near\n    col *= clamp(exp( -0.0008 * firstHitDist * firstHitDist * firstHitDist ), 0.02, 1.);\n    // Far\n    col *= clamp(exp( -0.00008 * firstHitDist * firstHitDist), 0.02, 1.); \n    \n    // Ramping up the brightness by some arbitrary value because otherwise it looks too dark and dull\n    col *= 2.5;    \n    \n    // Gamma correction\n    col = pow(col, vec3(.4545));    \n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS \t\t\t\t100\n#define MAX_DIST \t\t\t\t400.\n#define SURF_DIST \t\t\t\t.001\n#define ZOOM_LAYERS \t\t\t4.\n#define BG_COLOR \t\t\t\tvec3(0.)\n#define BASE_COLOR \t\t\t\tvec3(.3, .6, 1.)\n#define CUBE_OFFSET_COUNT \t\t26\n#define EPSILON \t\t\t\t.0025\n#define MAX_REFLECTION_DEPTH\t3\n","name":"Common","description":"","type":"common"}]}