{"ver":"0.1","info":{"id":"NlGBWw","date":"1664557086","viewed":126,"name":"Perspective interpolation","username":"vegvarizalan","description":"This shader is intended to illustrate how perspective interpolation is implemented. The code simulates a simple graphics pipeline, and applies perspective interpolation to the texture coordinate vertex attributes (tcN).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["perspective","interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 sampleTex(vec2 tc)\n{\n    float count = 10.0;\n    int x = int(tc.x*count);\n    int y = int(tc.y*count);\n    return (x+y) % 2 == 0\n        ? vec3(1.0, 1.0, 1.0)\n        : vec3(0.0, 0.0, 0.0);\n}\n\nvec4 transformPoint(vec3 p) { return vec4(p.x, p.y, 1.0/p.z, p.z); }\n\nvec2 getBarycentric(vec2 a, vec2 b, vec2 c, vec2 p)\n{\n    float v = (p.y-c.y - (p.x-c.x)*(a.y-c.y)/(a.x-c.x)) / (((b.y-c.y) - (b.x-c.x) *(a.y-c.y)/(a.x-c.x)));\n    float u = (p.x-c.x - v * (b.x-c.x)) / (a.x-c.x);\n    return vec2(u,v);\n}\n\nvec3 recombine(vec2 uv, vec3 a, vec3 b, vec3 c) { return uv.x * a + uv.y * b + (1.0-uv.x-uv.y) * c; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tc = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n\n    // --- Vertex input ---\n\n    // Primitives: {p1,p2,p3}; {p4,p2,p3}\n    vec3 p1 = vec3(-1.0, -0.5, 1.0);  vec2 tc1 = vec2(0.0,0.0);\n    vec3 p2 = vec3(1.0, -0.5, 1.0);   vec2 tc2 = vec2(1.0,0.0);\n    vec3 p3 = vec3(-1.0, 0.5, 3.0);   vec2 tc3 = vec2(0.0,1.0);\n    vec3 p4 = vec3(1.0, 0.5, 3.0);    vec2 tc4 = vec2(1.0,1.0);\n\n    // --- Vertex shader ---\n\n    vec4 pp1 = transformPoint(p1); tc1 *= pp1.z;\n    vec4 pp2 = transformPoint(p2); tc2 *= pp2.z;\n    vec4 pp3 = transformPoint(p3); tc3 *= pp3.z;\n    vec4 pp4 = transformPoint(p4); tc4 *= pp4.z;\n\n    // --- Rasterizer stage ---\n\n    vec2 b1 = getBarycentric(pp1.xy/pp1.w, pp2.xy/pp2.w, pp3.xy/pp3.w, tc);\n    vec2 b2 = getBarycentric(pp4.xy/pp4.w, pp2.xy/pp2.w, pp3.xy/pp3.w, tc);\n\n    vec2 uv = vec2(-1, -1);\n    vec3 tc_invZ;\n    if (b1.x >= 0.0 && b1.y >= 0.0 && b1.x+b1.y <= 1.0) {\n        // {p1,p2,p3}\n        uv = b1;\n        tc_invZ = recombine(b1, vec3(tc1, pp1.z), vec3(tc2, pp2.z), vec3(tc3, pp3.z));\n    } else if (b2.x >= 0.0 && b2.y >= 0.0 && b2.x+b2.y <= 1.0) {\n        // {p4,p2,p3}\n        uv = b2;\n        tc_invZ = recombine(b2, vec3(tc4, pp4.z), vec3(tc2, pp2.z), vec3(tc3, pp3.z));\n    } else {\n        // No primitive hit\n    }\n\n    // --- Pixel shader ---\n\n    // {p1,p2,p3}\n    if (uv.x >= 0.0) {\n        fragColor = vec4(sampleTex(tc_invZ.xy/tc_invZ.z), 0.0);\n    } else {\n        // Empty pixel\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}