{"ver":"0.1","info":{"id":"NtXXzN","date":"1639616512","viewed":101,"name":"a few spheres","username":"vivavolt","description":"Bare-bones ray marcher for drawing infinite spheres.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spheres","raymarcher"],"hasliked":0,"parentid":"MlKBzm","parentname":"Infinite Spheres (Bare-bones)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define max_iters 500\nfloat max_dist = 1000.0;\nvec3 bg_col = vec3(0.8, 0.8, 1.0);\nvec3 fg_col = vec3(1.0, 1.0, 0.6);\n\n/**\n * Rotation matrix from angles\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n//the signed distance field function\n//used in the ray march loop\nfloat sdf(vec3 p) {\n    //a sphere of radius 1.\n    return length( p ) - 1.;\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 pal_col(in float t) {\n    return pal(t, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n//1 : retrieve the fragment's coordinates\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\t//preserve aspect ratio\n\tuv.x *= iResolution.x / iResolution.y;\n\n    vec3 camera_pos = vec3(100.*sin(iTime*0.01),\n             50.*cos(iTime*0.01),\n             100.*cos(iTime*0.01)\n            );\n    vec3 camera_dir = vec3(sin(iTime*0.2),\n             cos(iTime*0.8+0.4),\n             cos(iTime*0.2)\n            );\n\n//2 : camera position and ray direction\n\tvec3 pos = camera_pos;\n\tvec3 dir = camera_dir*.5 * normalize( vec3( uv, 3.0 ) );\n\n    vec2 mos = (iMouse.xy / iResolution.xy) - vec2(0.5);\n    pos = rotateY(iTime / 6.0) * pos;\n    dir = rotateY(mos.x * 3.0) * rotateX(mos.y * 3.0) * dir;\n    \n//3 : ray march loop\n    //ip will store final color\n\tvec3 col = bg_col;\n\n\t//variable step size\n\tfloat t = 0.0;\n\n\tfor(int i = 0; i < max_iters; i++) {\n        //update position along path\n        vec3 ip = pos + dir * t;\n\n        //gets the shortest distance to the scene\n        float m = 8.0;\n        ip = abs(mod(ip, m) - m*0.5);\n\t\tfloat d = sdf( ip );\n\n        //break the loop if the distance was too small\n        //this means that we are close enough to the surface\n        if (d < 0.01) {\n            float a = float(i) / float(max_iters);\n            float diffuse = dot(ip, vec3(0.6, 0.8, 0.0))*0.5 + 0.5;\n            \n            // colour based on depth\n            col = pal_col( a*10.);\n            break;\n        }\n\n\t\t//increment the step along the ray path\n\t\tt += d;\n\n        //break if too far\n        if (t > max_dist) {\n            break;\n        }\n\t}\n        \n\n//4 : apply color to this fragment\n\tfragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}