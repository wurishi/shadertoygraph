{"ver":"0.1","info":{"id":"tstGz4","date":"1568000215","viewed":273,"name":"Grid Pattern Bombing - Starfield","username":"gressettd","description":"Layers of scaled, rotated and offset grids used to create a random star-field. In the mean time, just for fun, depicted our galaxy, presently moving 500 km per second through space!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["grid","pattern","patternbombing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat Map( float range_a_point, float a0, float a1, float b0, float b1 )\n{\n    return (((range_a_point - a0) * (abs(b1-b0)))/abs(a1-a0)) + b0;\n}\n\n\nvec4 ComputeSpiral(\n\tvec2 p,\n\tfloat points,\n\tfloat shape,  // def 0.3\n\tfloat spiral, // def 1.0\n    float angleOffs,\n\tfloat ccScale)\n{\n\tshape = clamp(shape, 0.2, 0.8);\n\tspiral = clamp(spiral, 0.1, 8.0);\n\tvec2 st = vec2(atan(p.x, p.y), length(p));\n\tvec2 uv = vec2((st.x  - angleOffs)/ 6.28 + 0.5+(st.y * spiral), st.y);\n\t\n\n\tfloat x = uv.x * points;\n\tfloat m = min(fract(x), fract(1.0 - x)); // sawtooth pattern\n\tfloat c = smoothstep(0.0, 0.1,\n\t\tm*shape +  // lower saw amp\n\t\t0.2 -    // raise saw up\n\t\tuv.y);\n\n\treturn vec4(c, uv.x * ccScale, uv.y * ccScale, m * ccScale);\n}\n\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\n\n\nvec4 NebulaColor(float t)\n{\n    return ComputeWaveGradientRGB(\n        \tt,\n        \tvec4(0.607, 0.848, 1.788,1.0), \n        \tvec4(-0.102, -0.222, 0.854,1.0),\n        \tvec4(0.004, 0.350, 0.763,1.0),\n        \tvec4(-0.023, 0.097, -0.023,1.0));\n}\n\nfloat Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\nfloat Random1DB(float seed)\n{\n\treturn fract(sin(seed)* (65536.0*3.14159265359));\n}\n\nfloat Random3D(vec3 p)\n{\n    \n    vec3 comparator = vec3(\n\t\tfract(123456.34 * p.x), \n\t\tfract(78956.789 * p.y),\n\t\tfract(234512.987 * p.z));\n    \n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude + 0.001);\n\treturn random;\n}\n\nfloat Random2D(vec2 p)\n{\n\tvec2 comparator = vec2(\n\t\tfract(123456.34 * p.x), \n\t\tfract(78956.789 * p.y));\n    \n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude);\n\treturn random;\n}\n\nvec2 Random2DVector(vec2 p, float s)\n{\n    float x = fract(sin(dot(p,vec2(127.1,311.7)))*18.5453 * (1.0+s));\n    float y = fract(sin(dot(p,vec2(113.7,217.1)))*54.1853 * (2.0+s));\n    return vec2(x,y);\n}\n\nvec2 RandomVector2(float p) \n{\n    vec3 p3 = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n    return fract(vec2(p3.x * p3.y, p3.z * p3.x));\n}\n\nvec2 Rotate2D(vec2 v, float a) \n{\n\t\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat Star(vec2 p, vec2 tx, float r, float s)\n{\n    p -= tx;\n    float d = (r * 1.0) / dot(p,p);\n    d += d * (sin(s*15.0)*0.25+0.5);\n    return d;\n}\n\n\nfloat Star2(vec3 cell, vec2 ext, float seed)\n{\n    float cellID = cell.x;\n    vec2 cellCoord = cell.yz;\n    float rnd = Random1D(cellID + seed);\n    float rnd2 = Random1DB(cellID);\n    \n    // some cells are empty\n    if(rnd > rnd2)\n        return 0.0;\n    \n    vec2 ra = Random2DVector(vec2(cellID,cellID), seed + (cellID * seed));\n    ra = clamp(ra, 0.25, 0.75);\n    \n    float pen = 2.0 / (float(iResolution.x) * ext.x);\n    pen = max(pen, 0.001);\n    \n    float rad = 0.01 * pen;\n    return Star(cellCoord, ra, rad, seed);\n    \n}\n\n// apply multiple layers \nfloat BombStars(\n    vec2 uv, \n    float seed, \n    int iterations, \n    float lacunarity)\n{\n        \n    float intensity = 0.0;\n    float bombSeed = seed;\n    float scale = 1.0;\n    \n    for(int it = 0; it < 16; it++) \n    {\n        // rotate, scale, and offset a grid for this iteration.\n        vec2 pos = uv + vec2(3.0 * float(it) * Random1D(bombSeed));\n        float angle = 3.14159 * Random1D(bombSeed);\n        pos = Rotate2D(pos, angle);        \n        pos = pos * scale;\n                \n        // get current cell\n       \tvec2 cell = floor(pos);\n        float cellID = (10.0*Random2D(cell)) + (Random2D(floor(uv*scale)));\n\t\tvec2 cellCoords = fract(pos);\n        \n        vec2 extents = vec2(1.0/scale);\n\n        // get a star\n        float star = \n            Star2(vec3(cellID, cellCoords), extents, bombSeed);\n        \n        // dampen by layer depth\n        float depth = star / scale;\n\n        intensity = max(depth,intensity);       \n\n        // set up for next iteration\n        bombSeed = Random1D(bombSeed + seed +1.618);\n        scale *= lacunarity;\n    }\n                        \n    return intensity;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    \n    \n    vec2 p =  pos.xy / iResolution.x;\n    float spin= iTime;\n    vec2 galaxyPos = p - vec2(0.5,0.25);\n    galaxyPos *= 1.5;\n    \n    float dust = Map( clamp(1.0-length(galaxyPos),0.0,0.8), 0.0, 1.0, 0.0, 0.3);\n    vec4 dustColor = dust * NebulaColor(0.2);\n    \n    vec2 starPos = p + vec2(iTime*0.1,0.0);\n    float stars = BombStars(starPos, 1.618, 16, 1.2);\n    vec3 starColor = stars * vec3(1.0,1.0,0.82);\n        \n    vec4 pattern = ComputeSpiral(galaxyPos, 6.0, 0.3, 2.0, spin, 0.4);\n    float nebInt =  pattern.x * pattern.w;\n        \n    vec4 nebColor = pattern.w * pattern.x * NebulaColor(nebInt);\n    \n    float center = Star(galaxyPos, vec2(0,0), 0.0051, 0.5);\n    vec3 centerColor = center * vec3(1.0,1.0,0.82);\n    \n    vec3 col = dustColor.xyz + starColor + nebColor.xyz + centerColor;\n    \n    \n    // Output to screen\n    fragColor = vec4(\n        col,\n        1.0);\n}","name":"Image","description":"","type":"image"}]}