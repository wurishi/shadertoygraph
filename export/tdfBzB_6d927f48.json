{"ver":"0.1","info":{"id":"tdfBzB","date":"1588540858","viewed":119,"name":"lirfu's first sphere tracer","username":"lirfu","description":"A simple sphere tracing playground\n\nFeatures:\n* Spheres\n* Rotating light\n* Mouse controlled rotation movement and zoom\n* Ray marching\n* Phong shading\n* Diffuse, normal, object id views\n* Orthogonal and perspective camera","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["phong","raytrace","spheretrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sample(x) texture(iChannel0, (x)/iResolution.xy)\n\nfloat G( in vec2 p, in float sigma ) {\n\treturn exp(-(dot(p,p)) / (2. * sigma * sigma)) / (2. * pi * sigma * sigma);\n}\n\nvec3 GaussBlur( in vec2 co, in int dim, in float sigma ) {\n    vec3 c = vec3(0);\n    float z = 0.;\n    for (int i = -dim; i <= dim; ++i) {\n\t\tfor (int j = -dim; j <= dim; ++j) {\n\t\t\tfloat g = G(vec2(i,j), sigma);\n            c += g * sample( co + vec2(i,j) ).rgb;\n            z += g;\n\t\t}\n\t}\n    return c / z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec4 value = texture(iChannel0, uv);\n    \n    fragColor.xyz = GaussBlur(fragCoord, 3, .6);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define N_MARCH 256\n#define EPS_MARCH 1e-6\n#define EPS_BOUNCE 1e-4\n\n#define pi 3.141592653589\n\n\n// Coordinate system.\n\nvec3 up = vec3(0., 1., 0.);\nvec3 forward = vec3(0., 0., -1.);\nvec3 right = vec3(-1., 0., 0.);\n\n\n// Ray tracing stuff.\n\nstruct Ray\n{\n    float t;\n    vec3 r0;\n    vec3 rd;\n};\n\nstruct Hit\n{\n    uint obj_id;\n    float dist;\n    vec3 point;\n    vec3 normal;\n};\n\n\n// Camera definitions.\n\nstruct Camera\n{\n    vec3 l;\n\tvec3 dir;\n};\n    \nRay orthogonal(in Camera cam, in vec2 uv, float sensor_size)\n{\n    vec3 X = cross(up, cam.dir);\n    return Ray(0., cam.l + sensor_size * (uv[0] * X + vec3(0., uv[1], 0.)), cam.dir);\n}\n\nRay perspective(in Camera cam, in vec2 uv, float fov)\n{\n    vec3 X = cross(up, cam.dir);\n    vec3 sensor = uv[0] * X + vec3(0., uv[1], 0.) + cam.dir / tan(fov / 2.);\n    return Ray(0., cam.l + sensor, normalize(sensor));\n}\n\n\n// Object definitions.\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    uint mat;\n};\n\n    \n// Material definitions.\nstruct PhongMaterial\n{\n    vec3 emissive;\n    vec3 diffuse;\n    vec3 specular;\n    float specular_shine;\n    float ambient;\n};\n\n// Scene hits.\n    \nfloat scene_hit(in Sphere s, in vec3 point, out vec3 norm)\n{\n    norm = point - s.center;\n    return max(length(norm) - s.radius, 0.);\n}\n\nvoid update_hit(inout Hit h, uint id, float dist, vec3 normal)\n{\n    if (dist < h.dist)\n    {\n        h.obj_id = id;\n        h.dist = dist;\n        h.normal = normal;\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//// Controls\n//\n// Mouse drag X - rotate around y-axis (up)\n// Mouse drag Y - zoom in or out on the object\n//\n    \n    \n////// Geometry and scene\n\n    \n// Materials.\nPhongMaterial[] materials = PhongMaterial[] (\n    PhongMaterial(vec3(0.), vec3(0.), vec3(0.), 0., 0.008),  // Skybox\n    PhongMaterial(vec3(1.), vec3(0.), vec3(0.), 0.,   0.0),  // Light\n    PhongMaterial(vec3(0.), vec3(.8, .05, .05), vec3(1.) * 0.4, 8., 0.008),  // Plastic\n    PhongMaterial(vec3(0.), vec3(.6,  .6,  .6), vec3(1.), 256., 0.008)   // Metal (sort of)\n);\n\n\n\n// Camera params.\nCamera cam = Camera(vec3(0.,0.,-10.), vec3(0., 0., 1.));\n\n\n// Objects.\nSphere skybox = Sphere(vec3(0.,0.,0.), 1e32, 0u);\nSphere light = Sphere(vec3(-3.,3.,0),    .06,  1u);\nSphere s1 = Sphere(vec3( 0.,-0.5, 0.),  2.,  2u);\nSphere s2 = Sphere(vec3( 2., 0.5, 1.5), 1.3, 3u);\nSphere s3 = Sphere(vec3(-2., 0.5,-1.5), 1.3, 3u);\n\n\nSphere get_obj(uint obj_id)\n{\n    switch (obj_id)\n    {\n        case 0u: return skybox;\n        case 1u: return light;\n        case 2u: return s1;\n        case 3u: return s2;\n        case 4u: return s3;\n    }\n}\n\n\n// Scene definition.\n\nHit scene(in vec3 point)\n{\n    Hit h;\n    h.point = point;\n    h.dist = 1e32;\n    \n    float dist;\n    vec3 normal;\n    \n    dist = scene_hit(light, point, normal);\n    update_hit(h, 1u, dist, normal);\n    \n    dist = scene_hit(s1, point, normal);\n    update_hit(h, 2u, dist, normal);\n    \n    dist = scene_hit(s2, point, normal);\n\tupdate_hit(h, 3u, dist, normal);\n    \n    dist = scene_hit(s3, point, normal);\n    update_hit(h, 4u, dist, normal);\n    \n    return h;\n}\n\n\n// Ray marching.\n\nHit trace(inout Ray orig)\n{\n    Hit hit = scene(orig.r0 + orig.t * orig.rd);\n    for(int i = 0; i < N_MARCH && hit.dist >= EPS_MARCH; i++)\n    {\n        orig.t += hit.dist;\n        hit = scene(orig.r0 + orig.t * orig.rd);\n    }\n    if(hit.dist > EPS_MARCH) hit.obj_id = 0u;\n    return hit;\n}\n\n\n// Shading\n\nfloat stencil(Hit hit)\n{\n    return float(min(hit.obj_id, 1u));\n}\n\nvec3 shade_diffuse(Hit hit, Ray r)  // Diffuse buffer.\n{    \n\tSphere s = get_obj(hit.obj_id);\n    return materials[s.mat].diffuse;\n}\n\nvec3 shade_obj_id(Hit hit, Ray r)  // Object ID buffer.\n{\n    return stencil(hit) * vec3(float(hit.obj_id % 4u) / 3., float(hit.obj_id % 8u) / 7., hit.obj_id % 2u);\n}\n\nvec3 shade_normal(Hit hit, Ray r)  // Normals buffer.\n{\n    return stencil(hit) * (normalize(hit.normal) + 1.) / 2.;\n}\n\n\nvec3 calc_phong(uint mat_id, vec3 normal, vec3 R, vec3 location, vec3 ligth_contrib)\n{    \n    vec3 N = normalize(normal);\n    vec3 V = normalize(cam.l - location);\n    vec3 L = normalize(light.center - location);\n\n    vec3 ambient =  materials[mat_id].diffuse  * materials[mat_id].ambient;\n    vec3 diffuse =  materials[mat_id].diffuse  * max(0., dot(N, L));\n    vec3 specular = materials[mat_id].specular * pow(max(0., dot(V, reflect(-L, N))), materials[mat_id].specular_shine);\n\n    return ambient + ligth_contrib * (diffuse + specular);\n}\n\nfloat point_shadow_test(in Hit hit, in Sphere l)\n{\n    Ray shadow_ray = Ray(0., hit.point, normalize(l.center - hit.point));\n    shadow_ray.r0 += shadow_ray.rd * EPS_BOUNCE;\n    Hit shadow_hit = trace(shadow_ray);\n    return float(shadow_hit.obj_id == 1u);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat sphere_shadow_test(in Hit hit, in Sphere l, int N, float rand)\n{\n    float count = 0.;\n    vec3 r = vec3(0.);\n    for(int i = 0; i < N; i++)\n    {\n        Ray shadow_ray = Ray(0., hit.point, normalize(l.center + r - hit.point));\n        shadow_ray.r0 += shadow_ray.rd * EPS_BOUNCE;\n        Hit shadow_hit = trace(shadow_ray);\n        count += float(shadow_hit.obj_id == 1u) * dot(shadow_hit.normal, -shadow_ray.rd);\n        \n        r = normalize( (vec3(rand*float(i)/float(N)) * 2. - 1.) ) * l.radius;\n    }\n    return float(count) / float(N);\n}\n\nvec3 shade_phong(Hit hit, Ray r, float rand)  // Final image.\n{\n    if (hit.obj_id == 0u) return materials[0].diffuse * materials[0].ambient;\n    if (hit.obj_id == 1u) return materials[light.mat].emissive;\n    \n\tSphere s = get_obj(hit.obj_id);\n    \n    // Shadow test - if ray doesn't hit the light, use only ambient.\n    int N = 1;\n    float contrib = point_shadow_test(hit, light);\n   \n    return calc_phong(s.mat, hit.normal, r.rd, s.center, materials[light.mat].emissive * vec3(contrib)) + materials[s.mat].emissive;\n}\n\n\n////// Main method\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uv_n = (uv * 2. - 1.) * vec2(1., iResolution.y / iResolution.x);\n    \n    // Modify light color with time.\n    float t = iTime * 0.1;\n    materials[1].emissive = clamp(vec3(1.6) + sin(vec3(t, t + pi * 2./3., t + pi * 4./3.)), vec3(0.), vec3(1.));\n    \n    // Rotate light.\n    vec3 ax = vec3(0., 1., 0.);\n    float a = iTime;\n    light.center = ax * dot(ax, light.center) + cos(a) * cross(cross(ax, light.center), ax) + sin(a) * cross(ax, light.center);\n    \n    // Zoom camera.\n    float zoom = 5. + 10. * iMouse.y / iResolution.y;\n    \n    // Rotate camera.\n    float phi = -pi * (iMouse.x / iResolution.x * 2. - 1.);\n    cam.l = zoom * vec3(-sin(phi), 0., -cos(phi));\n    cam.dir = normalize(-cam.l);\n    \n    //Ray r = orthogonal(cam, uv_n, 5.);\n    Ray r = perspective(cam, uv_n, pi / 4.);\n    Hit h = trace(r);\n    \n    vec3 img = shade_phong(h, r, rand(fragCoord));\n    \n    \n    img = pow(img, vec3(1./2.2));  // Gamma correction.\n    fragColor = vec4(img, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}