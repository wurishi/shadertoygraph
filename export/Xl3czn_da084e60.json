{"ver":"0.1","info":{"id":"Xl3czn","date":"1661833414","viewed":332,"name":"Water Physical Simulation","username":"NAME_REDACTED","description":"Water physics (2D wave equation) with refraction, dispersion, caustics, and specular reflections. Try drawing on the screen to make beautiful caustics (you can turn off wind/rain effects by commenting out their defs in Common).","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["refraction","water","caustics","physics","dispersion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RENDER_MODE RENDER_TEXTURE\n//#define GRAYSCALE_TEXTURE\n\nconst float eta = REFRACTIVE_INDEX_AIR / REFRACTIVE_INDEX_WATER; //ratio of refraction\nconst float dispersionR = 1. - DISPERSION;\nconst float dispersionB = 1. + DISPERSION * 1.25;\nconst float etar = REFRACTIVE_INDEX_AIR / (REFRACTIVE_INDEX_WATER - DISPERSION);\nconst float etab = REFRACTIVE_INDEX_AIR / (REFRACTIVE_INDEX_WATER + DISPERSION * 1.25);\n\n//coordinate system is left-handed - positive z is away from the viewer\n//const float aspectRatio = 9./16.; //inverse of 16:9 aspect ratio\nconst vec3 viewPos = vec3(.5,.5,-2.); //eye at the center of the image, 2 screen lengths above (avg for fullscreen)\nconst float specularPower = 32.;\nconst vec3 lightDir = normalize(SPECULAR_LIGHT_DIR);\nconst vec3 ncld = normalize(CAUSTICS_LIGHT_DIR);\nconst vec3 viewDir = vec3(0,0,1); //looking into the screen\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatioCorrection = iResolution.x / iResolution.y;\n    vec2 uvCorrected = uv * vec2(aspectRatioCorrection, 1.);\n\n    vec3 rgb, normal;\n    vec4 caustic;\n    //float dx, dy;\n    //vec2 onePixel = 1./iResolution.xy;\n   // vec2 onePixelX = vec2(1./iResolution.x, 0.);\n    //vec2 onePixelY = vec2(0., 1./iResolution.y);\n    \n    #if RENDER_MODE == RENDER_DEPTH\n        float depth = texelFetch(iChannel1, ivec2(fragCoord * GRID_RATIO), 0).x * 255.;\n        caustic = texelFetch(iChannel2, ivec2(fragCoord * GRID_RATIO), 0);\n        //rgb = hsv2rgb(vec3(height,1.,1.));\n        if (depth >= 0.)\n            fragColor = vec4(depth,0,caustic.r,1); //red is wave trough (shallow water)\n        else\n            fragColor = vec4(0,-depth,caustic.r,1); //green is wave crest (deeper water)\n    #elif RENDER_MODE == RENDER_SPREAD\n        vec4 pixel = texelFetch(iChannel0, ivec2(fragCoord * GRID_RATIO), 0);\n    \tfloat spread = pixel.w; //no spread is black\n    \tif (spread < 1.)\n            fragColor = vec4(1. - spread, 0., 0., 1); //tighter spread turns red\n    \telse\n            fragColor = vec4(0., 0., spread - 1., 1); //looser spread turns blue\n    #elif RENDER_MODE == RENDER_GRADIENT\n        normal = texelFetch(iChannel1, ivec2(fragCoord), 0).yzw;\n        fragColor = vec4(normal.x, -normal.x, -normal.z, 1);\n    #elif RENDER_MODE == RENDER_NORMAL\n        normal = texelFetch(iChannel1, ivec2(fragCoord * WATER_GRID_RATIO), 0).yzw;\n    \tfloat angle = atan(normal.y/normal.x) / TAU;\n    \tif (normal.x < 0.) angle += .5;\n        rgb = hsv2rgb(vec3(angle, 1., atan(length(normal.xy)) / HALF_PI + .25));\n        fragColor = vec4(rgb,1);\n    #elif RENDER_MODE == RENDER_CAUSTICS\n        //caustic = texelFetch(iChannel2, ivec2(fragCoord * CAUSTICS_GRID_RATIO), 0);\n    \tcaustic = texture(iChannel2, uv * GRID_RATIO);\n        /*\n        //sharpness filter\n        vec4 neighbors = texelFetch(iChannel2, ivec2(fragCoord.x - 1., fragCoord.y), 0)\n            + texelFetch(iChannel2, ivec2(fragCoord.x + 1., fragCoord.y), 0)\n            + texelFetch(iChannel2, ivec2(fragCoord.x, fragCoord.y - 1.), 0)\n            + texelFetch(iChannel2, ivec2(fragCoord.x, fragCoord.y + 1.), 0);\n        const float p = 5.;\n        caustic = caustic * (1. + 4. * p) - neighbors * p;\n\t\t*/\n        //vec4 rgbTex = texture(iChannel3, uv);\n    \tvec4 rgbTex = vec4(1.,1.,1.,1) * .5;\n        //vec4 rgbTex = vec4(.66, .85, 1, 1.) * .5;\n        fragColor = rgbTex * caustic;\n    #elif RENDER_MODE == RENDER_REFRACTION\n    \t\tvec3 cDelta = texelFetch(iChannel0, ivec2(fragCoord * GRID_RATIO), 0).yzw;\n    \t#ifndef ENABLE_CAUSTIC_DISPERSION\n            cDelta.xy -= (uv * GRID_RATIO);\n    \t#endif\n    \t\tfloat angle = atan(cDelta.y / cDelta.x) / PI;\n    \t\tif (cDelta.x < 0.) angle += .5;\n    \t\tfragColor = vec4(hsv2rgb(vec3(angle,\n                                          1.,\n                                          atan(length(cDelta.xy) * 30.) / HALF_PI )), \n                             1);\n    #else\n    \t#if PERFORMANCE == 4 \n    \t\tvec4 wave = texelFetch(iChannel1, ivec2(fragCoord), 0); //1:1 grid ratio\n    \t#else\n\t        vec4 wave = texture(iChannel1, uv * GRID_RATIO);\n    \t#endif\n        float waveDepth = wave.x;\n        \n        \n        //calculate local water depth  \n        float pWd;// = WATER_DEPTH;\n        float ep = .1; \n        float ep2 = 1. - ep;\n        float invEp = .5/ep;\n        float dd = 0., ddy = 0.;\n        if (uv.x < ep) dd = (ep - uv.x) * invEp; //left wall\n        else if (uv.x > ep2) dd = (uv.x - ep2) * invEp; //right wall\n        if (uv.y < ep) ddy = (ep - uv.y) * invEp; //bottom wall\n        else if (uv.y > ep2) ddy = (uv.y - ep2) * invEp; //top wall\n        dd = max(dd,ddy);\n        pWd = WATER_DEPTH - dd;\n        \n        if (waveDepth >= pWd)\n        {\n            fragColor = texture(iChannel3, uv);\n            return;\n        }\n                \n        //calculate refracted position\n        vec3 waterNormal = wave.yzw;\n        vec3 waterSurfacePosition = vec3(uv, waveDepth);\n        vec3 eyeToWater = waterSurfacePosition - viewPos;\n        vec3 rayDir = normalize(eyeToWater);\n        float localwd = pWd - waveDepth;\n\t    vec3 refractDir = refract(rayDir, waterNormal, eta);\n    \t//extend the ray to where it intersects the floor\n        vec2 posShift = refractDir.xy * localwd / (vec2(aspectRatioCorrection, 1.) * refractDir.z);\n        vec2 newPos = uv + posShift;\n    \n        \n        #ifdef ENABLE_CAUSTICS\n        /*\n    \t\tif (newPos.x >= 1. && (newPos.x > newPos.y && newPos.x > 1. - newPos.y))\n                caustic = CAUSTIC_BASE_COLOR * dot(vec3(SQRT2, 0, SQRT2), ncld);\n\t\t\telse if (newPos.x < 0. && (newPos.x < newPos.y && newPos.x < 1. - newPos.y))\n                caustic =  CAUSTIC_BASE_COLOR * dot(vec3(-SQRT2, 0, SQRT2), ncld);\n            else if (newPos.y >= 1.)\n                caustic = CAUSTIC_BASE_COLOR * dot(vec3(SQRT2, 1, SQRT2), ncld);\n            else if (newPos.y < 0.)\n                caustic = CAUSTIC_BASE_COLOR * dot(vec3(SQRT2, -1, SQRT2), ncld);\n            else\n            */\n            if (newPos.x < 0. || newPos.x >= 1. ||\n                newPos.y < 0. || newPos.y >= 1.)\n                caustic = CAUSTIC_BASE_COLOR * CAUSTIC_BRIGHTNESS;\n              else\n\t            caustic = texture(iChannel2, newPos * GRID_RATIO);\n        #else\n        \t#define caustic 1. //compiler should optimize this away\n        #endif\n\n        #ifdef ENABLE_DISPERSION\n\t\t\t#ifdef FAST_DISPERSION\n    \t\t//calculate dispersion without extra calls to refract(). does not work with grayscale textures\n\t        vec4 pixelColor = vec4(\n                \t\t\ttexture(iChannel3, (uv + posShift * dispersionR)).r, \n                            texture(iChannel3, newPos).g, \n                            texture(iChannel3, (uv + posShift * dispersionB)).b, 1);\n            #else\n            vec2 rayLen = localwd / (vec2(aspectRatioCorrection, 1.) * refractDir.z); //we could do separate corrections for each ray, but the difference is negligible\n\n            vec2 newPosr = uv + refract(rayDir, waterNormal, etar).xy * rayLen;\n            vec2 newPosb = uv + refract(rayDir, waterNormal, etab).xy * rayLen;\n\n            vec4 pixelColor = vec4(texture(iChannel3, newPosr).r, \n                                   texture(iChannel3, newPos).g, \n                                   texture(iChannel3, newPosb).b, 1);\n            #endif\n\n        #else\n            #ifdef GRAYSCALE_TEXTURE\n              vec4 pixelColor = vec4(texture(iChannel3, newPos).r);\n            #else\n              vec4 pixelColor = texture(iChannel3, newPos);\n            #endif\n        #endif //dispersion\n\t    fragColor = pixelColor * caustic;\n        \n#ifdef ENABLE_SPECULAR_REFLECTIONS\n        //move the light vector like the sun rising and setting\n        //we could even do some sunset colors on the specular lighting if we want to get fancy\n/*        \nfloat time = fract(iTime * .2)*PI*2.;\nif (time > PI) time = PI - (time - PI);\nfloat sinTime = sin(time);\nvec3 lightDirection = normalize(vec3(cos(time), sinTime * .5 - .25, sinTime)); \n*/\n        float spec = pow(max(0.0, dot(reflect(-lightDir, waterNormal), viewDir)), specularPower);\n        fragColor += SPECULAR_COLOR * spec;\n        //fragColor = vec4(normalDirection,1);\n#endif //specular reflections\n      \n    #endif //render_mod\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//#define PAUSE_PHYSICS\n\n//generation\n#define ENABLE_RAIN\n#define ENABLE_WIND\n\n//render options\n#define ENABLE_SPECULAR_REFLECTIONS\n#define ENABLE_DISPERSION //chromatic dispersion for rays traveling to screen\n#define ENABLE_CAUSTICS //expensive but nice-looking light patterns\n#define ENABLE_CAUSTIC_DISPERSION //chromatic dispersion for caustic rays\n\n//optimizations [4]\n#define PERFORMANCE 2\t\t//enum: 1=SPEED, 2=BALANCED, 3=QUALITY; 4=PRODUCTION; greatly affects speed\n//#define CAUSTIC_CHECKERBOARD\n\n//aesthetic constants\n#define WATER_DEPTH 1.35 //screen-height multiples\n#define DISPERSION .02 //[1]\n//rain\n#define RAIN_DROP_WEIGHT .00125\n#define RAIN_DROP_SIZE 7.\n#define RAIN_DROP_DELAY 10. //average delay btw rain drops\n//wind\n#define WIND_SPEED 10.\n#define WIND_FRQ 25.\n#define WIND_STRENGTH .001\n//specular parameters\n#define SPECULAR_LIGHT_DIR vec3(0.35, -0.3, 1)\n#define SPECULAR_COLOR vec4(1,1,1,1)\n//caustics parameters\n#define CAUSTICS_LIGHT_DIR vec3(0.05, -.05, 1.)\n#define CAUSTIC_STEP_SIZE_PX\t\t1 //controls quality of caustics [2]\n#define CAUSTIC_SEARCH_RADIUS\t \t40//int(pixels) - controls range of caustics; affects speed exponentially [2]\n#define CAUSTIC_PHOTON_SHARPNESS\t500. //arbitrary units. should be max value that doesn't display artifacts [2]\n//const vec4 CAUSTIC_BASE_COLOR = (vec4(1,1,1,1) - (vec4(1., .33, 0., 0.) * atan(WATER_DEPTH) / 1.5)) * .7; //attenuate low-frequency light\nconst vec4 CAUSTIC_BASE_COLOR = mix(vec4(.8, .9, 1, 1), vec4(0, .1, .6, 1), atan(WATER_DEPTH / 3.) / 1.57) * .66;\n#define CAUSTIC_BRIGHTNESS\t\t\t1.5\n\n//user interface constants\n#define DRAW_SIZE 50 //pixels\n#define DRAW_POWER -.05//negative pulls the water, positive pushes away\n\n//physics constants\n#define VISCOSITY .996 //viscosity multiplier [3].  determines how quickly the waves lose energy.\n#define REFRACTIVE_INDEX_AIR 1.000293 //actual is 1.000293\n#define REFRACTIVE_INDEX_WATER 1.3330 //650nm = 1.331, 520(G) = 1.3334, 465(B) = 1.3364\n\n//immutable constants - don't change these!\n#define PI\t\t3.1415926535979\n#define TAU\t\t6.2831853071796\n#define HALF_PI 1.5707963267949\n#define SQRT2\t1.4142135623731\n//RENDER_MODE enum\n#define RENDER_DEPTH 0 //shows depth value of water surface\n#define RENDER_GRADIENT 1 //shows delta-depth of water surface\n#define RENDER_NORMAL 2 //shows direction of water surface curvature\n#define RENDER_SPREAD 3 //shows how much each photon spread out (caustics only)\n#define RENDER_CAUSTICS 4 //shows only caustics\n#define RENDER_REFRACTION 5 //shows amount of light refraction\n#define RENDER_TEXTURE 6 //total everything\n\n#if PERFORMANCE == 1\n\t#define GRID_RATIO .33333333333 //for low-end cards\n#elif PERFORMANCE == 3\n\t#define GRID_RATIO .75 //slow, but good quality\n#elif PERFORMANCE == 4\n\t#define GRID_RATIO 1. //production-quality. VERY SLOW.\n#else //default value = BALANCED\n\t#define GRID_RATIO .5 //decent quality, fast\n#endif\n\n//some functions\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat lenSq(vec2 p)\n{\n    return dot(p,p);\n}\n\n/*\n---notes---\nI made it as physically accurate as possible, while taking some steps to keep the speed reasonable.\nThere are a lot of tunable parameters here.\n\n[1] The \"dispersion\" value represents the divergence between the refractive indices at the red and blue\nwavelengths, as compared to green.  Instead of calling refract() three times with different indices,\nwe call it once for green and then multiply the horizontal shift by the dispersion factor to get the\nblue and red shifts. However this effect doesn't become apparent until the water is very deep, so the\ndispersion factor was increased to amplify the effect.\n\n[2] the CAUSTIC_SEARCH_RADIUS, along with CAUSTIC_STEP_SIZE_PX, determines the number of ray checks per pixel\nand directly affects rendering speed.  The number of ray checks increases exponentially with the search radius.\nThe search radius should be large enough to not miss any photon contributions - how large this number needs to\nbe will depend on how steep the waves are and how deep the WATER_DEPTH is.  If you see excessive dark areas forming,\nthen you need to increase this radius.  A good stopping point is 48° from the target pixel, as that is the\ncritical angle.  The CAUSTIC_STEP_SIZE_PX is in water grid pixel units.\nIt is automatically adjusted by the WATER_GRID_RATIO.\n\nCaustic photon sharpness is an arbitrary number. It should be as high as possible without causing artifacts.\nThere are some automatic adjustments made to it when other variables are changed.\n\n[3] Viscosity is a multiplier representing the rate of wave energy loss due to internal friction.\n\n[4] Optimizations: there are several optimizations available.  You may need to enable some of them\nin order to go fullscreen.  Following is a list of optimizations and what they do:\n\nPERFORMANCE: A number (1-4) indicating the speed-vs-quality factor. It defines the grid size of the water\nand the caustic light patterns, as a ratio to the screen size. Grid ratios are 1/3, 1/2, 3/4, and 1, respectively.\nCompute time increases with the square of the grid size, so 50% grid size is 4x faster.\n\nCAUSTIC_CHECKERBOARD: Since ray checking is done per-pixel, we can use the checkerboard pattern with frame blending\nto speed up caustic light rendering. This nearly doubles the caustic rendering speed and doesn't reduce sharpness,\nhowever it leaves a sort of ghost pattern which may be undesirable, and at high resolutions may cause visible artifacts.\n\nCAUSTIC_STEP_SIZE_PX: Increasing this value will increase caustic rendering speed, but will automatically reduce\nphoton sharpness so as not to prevent artifacts.\n\n*/\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//packing = x: surface depth, yzw: water normal\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef PAUSE_PHYSICS\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    return;\n    #endif\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    if (uv.x > GRID_RATIO || uv.y > GRID_RATIO) {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    float onePx = 1. / iResolution.y;\n\n    float oldDepth = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n  \n    //note - using ivec here seems to cause some weird shit to happen (does it?)\n    float right = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(1, 0), 0).x;\n    float up = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(0, 1), 0).x;\n    float left =texelFetch(iChannel0, ivec2(fragCoord) - ivec2(1, 0), 0).x;\n    float down =  texelFetch(iChannel0,  ivec2(fragCoord) - ivec2(0, 1), 0).x;\n    float deltaAvg = (\n        right + left +\n        up + down)\n        * .25 - oldDepth;\n    \n    float depth = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n\n    //precalculate the water normal - points up (-Z) toward the viewport\n    //compute the water normal by crossing points on a triangle computed from the derivatives\n    //NOTE:Using  dFdx, dFdy is faster than manually calculating derivatives,\n    //but doesn't look as good.\n    vec3 waterNormal = normalize(cross(vec3(0, onePx, up - down), vec3(onePx, 0, right - left)));\n    \n    fragColor = vec4( ((2. * oldDepth - depth) + deltaAvg * 2.) * VISCOSITY\n        \t\t\t, waterNormal);\n\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define rnd(v)   fract( 43758.5453 * sin( v * 78.233 ) ) //stolen from some other shadertoy, forgot which one\n\nfloat rain_drop_mul = 1. / RAIN_DROP_SIZE;\nconst vec3 lightDir = normalize(CAUSTICS_LIGHT_DIR); \nconst float eta = REFRACTIVE_INDEX_AIR / REFRACTIVE_INDEX_WATER; //ratio of refraction\nconst float draw_size = float(DRAW_SIZE) * GRID_RATIO;\n//const float water_to_caustics_ratio = CAUSTICS_GRID_RATIO / WATER_GRID_RATIO;\nconst float water_depth = WATER_DEPTH * GRID_RATIO;\nconst float draw_power = DRAW_POWER * GRID_RATIO;\nconst vec3 referenceRay = refract(lightDir, vec3(0,0,1.), eta);\n \n\n//packing = x: water surface depth, yz: photon position (or delta-p), w: photon spread\n//or if dispersion is enabled,\n//yz: photon position delta xy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef PAUSE_PHYSICS\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    return;\n    #endif\n\n    vec2 uv = fragCoord/iResolution.xy;\n    if (uv.x > GRID_RATIO || uv.y > GRID_RATIO) {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    float aspectRatioCorrection = iResolution.y / iResolution.x;\n\n    float depth = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    \n    vec4 oldPix = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float oldDepth = oldPix.x;\n\n\tfloat l = texelFetch(iChannel1, ivec2(fragCoord) - ivec2(1,0), 0).x;\n    float r = texelFetch(iChannel1, ivec2(fragCoord) + ivec2(1,0), 0).x;\n    float u = texelFetch(iChannel1, ivec2(fragCoord) - ivec2(0,1), 0).x;\n    float d = texelFetch(iChannel1, ivec2(fragCoord) + ivec2(0,1), 0).x;\n                \n    float deltaAvg = (l+r+u+d) * .25 - oldDepth;\n    \n    float result = ((2. * oldDepth - depth) + deltaAvg * 2.) * VISCOSITY;\n\n    #ifdef ENABLE_CAUSTICS\n    //calculate refracted ray positions - will be 1 physics-frame old, but saves both speed and space\n        //note: maybe could skip calculating the ray if it is beyond the critical angle\n    vec3 lightRay = refract(lightDir, oldPix.yzw, eta);\n    float lightRayLength = (water_depth - result) / lightRay.z;\n    vec2 posShift = vec2(lightRay.x * aspectRatioCorrection, lightRay.y) * lightRayLength;\n    vec2 newPos = uv + posShift;\n    //compute spread\n    float oldArea = (iResolution.x + iResolution.y) / (iResolution.x * iResolution.y);\n    float newArea = length(dFdx(newPos)) + length(dFdy(newPos));\n    float spread = oldArea / newArea;\n    //if (spread < 1.) spread = spread * spread; //further expand unfocused\n    #ifdef ENABLE_CAUSTIC_DISPERSION\n      //spread = spread * spread; //square the spread if we're using lenSq in BufferC\n      vec2 lightIntersect = posShift; //only give the shift\n    #else\n      vec2 lightIntersect = newPos; //give actual position\n    #endif\n    #else\n    const vec2 lightIntersect = vec2(0, 0);\n    const float spread = 1.;\n    #endif\n    \n    //user input\n    if (iMouse.z > 0.) {\n        float dist = length(iMouse.xy * GRID_RATIO - fragCoord) / draw_size;\n        if (dist <= 1.) {\n            result += smoothstep(1.,0.,dist) * draw_power / iResolution.y;\n        }\n    }\n\n    #ifdef ENABLE_RAIN\n    //some quick, very-pseudo random numbers\n    vec2 rainPos = iResolution.xy * vec2(rnd(iTime), rnd(iTime + 1.6741));//vec2(fract(iTime * 674.23527), fract((iTime + 1.54361) * 123.32522351));\n    float len = 1. + length(fragCoord - rainPos * GRID_RATIO * RAIN_DROP_DELAY);\n    if (len < RAIN_DROP_SIZE) {\n        result += RAIN_DROP_WEIGHT * smoothstep(1.0, 0., len * rain_drop_mul);\n    }\n    #endif\n    \n    #ifdef ENABLE_WIND\n    /* //just a moving circle\n    float isp = iTime * WIND_SPEED;\n    vec2 wp = ((vec2(cos(isp), sin(isp)) + \n               vec2(cos(isp * WIND_ALPHA), sin(isp * WIND_ALPHA)) * .5)\n                     * .33 + .5) * GRID_RATIO;\n    float dist = length(wp - uv) / WIND_BETA;\n    if (dist <= 1.) {\n        result += smoothstep(1.,0.,dist) * WIND_STRENGTH / iResolution.y;\n    }\n    */\n    \n    //add some random disturbance\n    //slow waves\n    float wind_mul = WIND_FRQ * (2. + sin(iTime));\n    float siny = sin(iTime * WIND_SPEED + uv.y * wind_mul);\n    result += ( sin(uv.x * wind_mul * 1.78 + siny) ) * WIND_STRENGTH / iResolution.y;\n    //float siny2 = sin(iTime * WIND_SPEED * -2. * sin(iTime) + uv.y * WIND_FRQ * 2.17);\n    //result += ( sin(uv.x * WIND_FRQ * 3.73 + siny2) )* WIND_STRENGTH / iResolution.y;\n    #endif\n    \n    fragColor = vec4( result, lightIntersect, spread);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//real caustics - make patterns by focusing light\nconst vec3 lightDir = normalize(CAUSTICS_LIGHT_DIR); //must use overhead vector for fast caustics\nconst vec3 viewDir = vec3(0,0,1); //looking into the screen\nconst vec3 water_normal = vec3(0,0,-1);\nconst float aspectRatio = 16. / 9.;\nconst float eta = REFRACTIVE_INDEX_AIR / REFRACTIVE_INDEX_WATER; //ratio of refraction\nconst int num_caustic_steps = int(float(CAUSTIC_SEARCH_RADIUS) / float(CAUSTIC_STEP_SIZE_PX) * GRID_RATIO);\n\n//here we make some derivative constants to balance our defined constants with each other\nconst float water_depth = WATER_DEPTH * GRID_RATIO;\nconst int caustic_photon_count = int(pow(float(num_caustic_steps), 2.) * PI); //area of circle\nconst float inv_caustic_steps = 1. / (1. + float(num_caustic_steps));\nconst float caustic_step_size_local = float(CAUSTIC_STEP_SIZE_PX) * GRID_RATIO;\nconst float photon_radius = CAUSTIC_PHOTON_SHARPNESS / float(CAUSTIC_STEP_SIZE_PX);// / (GRID_RATIO);\n//get a starting location for our caustic photon search\nconst vec2 search_offset = refract(lightDir, water_normal, eta).xy * water_depth / refract(lightDir, water_normal, eta).z;\n//begin complicated procedure of trying to maintain a proper brightness level\nconst float photon_brightness = CAUSTIC_BRIGHTNESS\n    * pow(photon_radius, 2.)\n    * pow(float(CAUSTIC_STEP_SIZE_PX), 1.5)\n    / sqrt(float(num_caustic_steps)) \n    * GRID_RATIO * GRID_RATIO\n    #ifdef CAUSTIC_CHECKERBOARD\n    * 2.\n    #endif\n    / 1.; //final adjustment term\n\n//for chromatic dispersion\nconst float dispR = 1. - DISPERSION * 3.; //stronger dispersion factor for caustics\nconst float dispB = 1. + DISPERSION * 3.; //because it looks better\nconst float photon_radius_2 = photon_radius * photon_radius * 1.;\n\n#define sigmoid(x) 2./(1.+exp(3.-(3.*x)))\n\n//since we can't project photons onto the ground like we'd like to,\n//in the previous buffer we precalculated the location the photon would have landed,\n//now we just heave to search all the neighbors to find out which ones casted\n//a photon (close to) this position.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifndef ENABLE_CAUSTICS\n    return;\n#endif\n    vec2 resolution = iResolution.xy * GRID_RATIO;\n    float caustic_step_contribution = photon_brightness / (resolution.x * resolution.y);\n    //float aspectRatioCorrection = iResolution.x / iResolution.y;\n    \n\tvec2 uv = fragCoord / iResolution.xy;\n    if (uv.x > GRID_RATIO || uv.y > GRID_RATIO) {\n        fragColor = CAUSTIC_BASE_COLOR;\n        return;\n    }\n\n    ivec2 coord_water = ivec2(fragCoord - search_offset * iResolution.y);\n    vec3 uvp = vec3(uv, water_depth);\n\n    #ifdef CAUSTIC_CHECKERBOARD\n    \tint fp = (iFrame % 2);\n    \t//int pixelOffset = fp * CAUSTIC_STEP_SIZE_PX;\n        //coord_water.y -= pixelOffset; //every other\n    \tconst int I_STEP = 2;\n    #else\n    \tconst int fp = 0;\n    \tconst int I_STEP = 1;\n    #endif\n    \n    float causticP = 0.; //colorless brightness\n    vec3 causticC = vec3(0,0,0); //colored brightness\n    int cStep = CAUSTIC_STEP_SIZE_PX * I_STEP;\n    int py = coord_water.y - (num_caustic_steps + 1) * CAUSTIC_STEP_SIZE_PX; //starting y-coord\n    for (int i = -num_caustic_steps; i <= num_caustic_steps; i += 1) {\n        py += CAUSTIC_STEP_SIZE_PX;\n        \n        //some early bailing... seems to be the same speed with or without but may help on some cards\n        if (py < 0) continue; //skip this row\n        if (py >= int(resolution.y) - 1) break; //nothing more to see here\n        \n        #ifdef CAUSTIC_CHECKERBOARD\n        \t#define DO_OFFSET + ((py + fp) % 2);\n        #else\n        \t#define DO_OFFSET\n        #endif\n        float mul = cos(float(i) * (inv_caustic_steps * HALF_PI));\n        int xWidth = int(float(CAUSTIC_STEP_SIZE_PX * num_caustic_steps) * mul);\n        int px0 = max(coord_water.x - xWidth, 0) DO_OFFSET;\n        int px1 = min(coord_water.x + xWidth, int(iResolution.x * GRID_RATIO));\n        \n        for (int px = px0; px <= px1; px += cStep) {\n            vec4 wave = texelFetch(iChannel0, ivec2(px, py), 0);\n          #ifdef ENABLE_CAUSTIC_DISPERSION \n            //[1]\n            //fast dispersion approximation\n            vec2 wCoord = (vec2(px, py) / iResolution.xy) - uv; //water test pos, relative to floor pos\n            float dist = length(wCoord + wave.yz);\n            vec3 distLItoUV = vec3(length((wCoord + wave.yz * dispR) ),\n                                   length((wCoord + wave.yz)),\n                                   length((wCoord + wave.yz * dispB)) );\n            float focus, br;\n            br = wave.w ;\n            focus = wave.w * photon_radius;\n            vec3 len = (1. - distLItoUV * focus) * caustic_step_contribution * br * br;\n            causticC += max(len, 0.);\n          #else\n            float focus = wave.w * photon_radius;\n            float br = wave.w;\n            //if (abs(wave.w - (1. + sin(iTime))) > .1) br = 0.;\n            float distLItoUV = length(wave.yz - uv);            \n            causticP += max((1. - distLItoUV * focus) * caustic_step_contribution * br * br, 0.);\n          #endif\n        } //next px\n    } //next py\n    \n    fragColor = \n    #ifdef CAUSTIC_CHECKERBOARD\n\t    mix(texelFetch(iChannel2, ivec2(fragCoord), 0), \n    #endif\n    #ifdef ENABLE_CAUSTIC_DISPERSION\n    \tCAUSTIC_BASE_COLOR + vec4(causticC, 1.)\n    #else\n    \tfragColor = CAUSTIC_BASE_COLOR + vec4(causticP, causticP, causticP, 1.0)\n    #endif //dispersion\n    #ifdef CAUSTIC_CHECKERBOARD\n    \t, .75)\n    #endif //caustic frame blending\n        ;\n}\n\n/* [1]\n            //very slow dispersion calculations\n            vec2 waterUv = vec2(px, py) / iResolution.xy;\n            vec2 aspectRatioCorrection = vec2(iResolution.y / iResolution.x, 1.);\n            vec3 normal = texelFetch(iChannel1, ivec2(px, py), 0).yzw;\n            float lwd = water_depth - wave.x;\n            vec3 lightRayR = refract(lightDir, normal, etar);\n            vec3 lightRayB = refract(lightDir, normal, etab);\n            vec2 lpr = (waterUv + lightRayR.xy * aspectRatioCorrection * (lwd / lightRayR.z)) * water_to_caustics_ratio;\n            vec2 lpb = (waterUv + lightRayB.xy * aspectRatioCorrection * (lwd / lightRayB.z)) * water_to_caustics_ratio;           \n            vec3 len =1. - photon_radius * vec3(length(lpr - uv), length(lightIntersect - uv), length(lpb - uv));\n*/","name":"Buffer C","description":"","type":"buffer"}]}