{"ver":"0.1","info":{"id":"cdf3Ws","date":"1667158974","viewed":104,"name":"[ConcoursJFIG2022] moon","username":"ChGrenier","description":"a stylized representation of the Garonne under the moon.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["concoursjfig2022","bordeaux","portofthemoon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---- outils -----------------------------------------\nfloat rndi(int i, int j)\n{\n\tvec2 uv = vec2(.5+float(i),.5+float(j))/ iChannelResolution[0].x;\n\treturn texture(iChannel0,uv).r;\n}\n\nfloat transfer_function(float N1, float N2){\n\n    float R = sqrt(N1*N1 + N2*N2);\n    \n    float angle_rot = 0.4*sin(6.*R + iTime) + 0.1*sin(12.*R + 2.4*iTime);\n    \n    float n1 = N1*cos(angle_rot) - N2*sin(angle_rot);\n    float n2 = N1*sin(angle_rot) + N2*cos(angle_rot);\n    \n    float Atan = atan(n1, n2);\n    \n    return Atan;\n}\n\nfloat phasor_ish(float x){\n    float Ssin = sin(2.*x) + sin(4.*x + 0.7) + 0.5*sin(6.*x-1.);\n    float Scos = cos(2.*x) + cos(4.*x + 0.7) + 0.5*cos(6.*x-1.);\n    \n    float phase = atan(Ssin/Scos);\n    \n    return phase;\n}\n\n\n\n\n\n\n// ---- Gabor -----------------------------------------\nfloat gaussian(float x){\n    float size = 0.24;\n    return exp(-(x*x)/(size*size));\n}\n\nvec2 gabor(vec2 position, vec2 direction, float freq){\n    float gauss = gaussian(position.x)*gaussian(position.y);\n    \n    vec2 var_temps = -vec2(0.075*iTime, 0.05*iTime);\n    \n    float sinus = 0.5*sin(2.*_PI_*freq*dot(position+var_temps, direction));\n    float cosinus = 0.5*cos(2.*_PI_*freq*dot(position+var_temps, direction));\n    \n    return vec2(gauss*sinus, gauss*cosinus);\n}\n\nvec2 Gabor_noise(vec2 uv, int nb_kernel, float freq, float omega){\n    vec2 noises= vec2(0., 0.);\n    \n    for (int i=0; i<nb_kernel; i++) {\n    \n\t\tvec2 pos = vec2(1.5*rndi(i,0),rndi(i,1));\n\t\tvec2 dir = vec2(rndi(i,2),rndi(i,3)) + vec2(cos(omega), sin(omega));\n        \n        vec2 gabor_noise = gabor(uv-pos, dir, freq);\n        \n\t\tnoises += vec2(gabor_noise.x, gabor_noise.y);\n\t}\n    \n    return noises;\n}\n\n\n\n\n\n\n//----shapes-----------------------------------------\nfloat circle(vec2 uv, float ampl, float origine, float perturbation){\n    float forme = origine - ampl*sqrt(uv.x*uv.x + uv.y*uv.y);\n    float shape = perturbation + forme;\n    \n    return smoothstep(0.02, 0.01, shape);\n}\n\nfloat moon_shape(vec2 uv, float perturbation){\n    uv += vec2(-0.05, 0.2);\n    \n    float shape1 = circle(uv, 1.1, 0.2, perturbation);\n    float shape2 = circle(uv-vec2(0.15, 0.), .9, 0.2, perturbation);\n    \n    float shape = shape1-shape2;\n    \n    return clamp(shape, 0., 1.);\n}\n\nfloat city_shape(vec2 uv, float perturbation){\n    uv += perturbation;\n    float x_value = 0.04*floor(2.*sin(5.*uv.x+5.5) + \n                               0.9*sin(24.*uv.x+0.24) + \n                               0.2*sin(124.*uv.x+2.));\n    \n    float value = smoothstep(0.1, 0.11, uv.y-x_value);\n    return value;\n}\n\nfloat basilique_shape(vec2 uv, float perturbation){\n    uv += perturbation;\n    \n    // tour\n    float shape1 = smoothstep(-0.1, -0.05, 12.*abs(uv.x-0.24)-uv.y);\n    shape1 += smoothstep(0.04, 0.045, abs(uv.x-0.24));\n    shape1 = clamp(1.-shape1, 0., 1.);\n    \n    // batiement bas\n    float shape2 = smoothstep(0.31, 0.32, 1.-uv.y);\n    shape2 += smoothstep(-0.2, -0.19, 4.*uv.x-uv.y);\n    shape2 = clamp(1.-shape2, 0., 1.);\n    \n    float shape = shape1+shape2;\n    \n    return shape;\n}\n\nfloat fish_shape(vec2 uv, vec2 pos, float direction, float size, float perturbation){\n    //direction = 1. : regarde vers la gauche, -1. : regarde vers la droite\n    \n    uv *= size;\n    \n    uv.y += 0.05*cos(6.*uv.x-direction*5.*iTime);\n    uv.x *= direction;\n    \n    uv += pos;\n    uv += size*perturbation;\n\n    //tete\n    float rond = sqrt(dot(uv+vec2(0.13, 0.), uv+vec2(0.13, 0.)));\n    rond = smoothstep(0.15, 0.155,rond);\n    \n    // corps\n    float triangle = smoothstep(0.1, 0.11, abs(3.*uv.y)+uv.x-0.25);\n    triangle += smoothstep(0.16, 0.15, uv.x+0.25);\n    \n    // nageoires\n    vec2 ob_uv = vec2(uv.x-0.03, uv.x-1.5*uv.y);\n    float paddle_d = sqrt(((ob_uv.x+0.01)*(ob_uv.x+0.01))/(2.*2.) + (ob_uv.y*ob_uv.y)/(1.*1.));\n    paddle_d = smoothstep(0.07, 0.075,paddle_d);\n    \n    ob_uv = vec2(uv.x-0.03, uv.x+1.5*uv.y);\n    float paddle_g = sqrt(((ob_uv.x+0.01)*(ob_uv.x+0.01))/(2.*2.) + (ob_uv.y*ob_uv.y)/(1.*1.));\n    paddle_g = smoothstep(0.07, 0.075,paddle_g);\n    \n    float paddle = - (1.-paddle_g) - (1.-paddle_d);\n    \n    // queue\n    float tail = smoothstep(0.1, 0.11, pow(3.*uv.y,2.)-uv.x+0.35);\n    tail += smoothstep(0.103, 0.1, (0.004*cos(70.*uv.y)+pow(uv.y,2.))-0.4*uv.x+0.27);\n    \n    \n    float shape = rond - (1.-triangle) + paddle - (1.-tail);\n    shape = 1.-clamp(shape, 0., 1.);//1.-clamp(1., 0., shape);\n    \n    return shape;//clamp(0., 1., shape);\n}\n\n\n\n\n// =====================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // ---- noises -----------------------------------------------------------\n    float freq = mix(5., iResolution.x/10., 0.);\n    float omega = _PI_/4.;\n    int nb_kernel = 100;\n    \n    vec2 noises = Gabor_noise(uv, nb_kernel, freq, omega);\n    \n    float eau = transfer_function(noises.x, noises.y);\n    float perturbation = 0.01*noises.x*noises.y;\n    \n    // ---- decor -------------------------------------------------------------\n    float lune = moon_shape(uv-vec2(0.5), perturbation);\n    \n    float ville = city_shape(uv-0.7, perturbation);\n    ville += basilique_shape(uv, perturbation);\n    ville = clamp(ville, 0., 1.);\n    \n    \n    // ---- poissons ----------------------------------------------------------\n    float fish_1_pos_x = 2.*phasor_ish(0.06*iTime-2.7)-0.9;\n    float fish_1_pos_y = -(0.6*sin(iTime*0.1+30.) + 0.5);\n    vec2 fish_1_pos = vec2(fish_1_pos_x, fish_1_pos_y);\n    \n    float fish_1 = fish_shape(uv, fish_1_pos, 1., 2., perturbation);\n    \n    \n    \n    float fish_2_pos_x = 2.*phasor_ish(-0.1*iTime-3.5)-0.9;\n    float fish_2_pos_y = -(0.5*cos(iTime*0.1+24.) + 0.5);\n    vec2 fish_2_pos = vec2(-fish_2_pos_x, fish_2_pos_y);\n    \n    float fish_2 = fish_shape(uv, fish_2_pos, -1., 2., perturbation);\n    \n    \n    \n    // ---- rendu -------------------------------------------------------------\n    vec3 col_eau = (1.-(ville + lune + fish_1 + fish_2)) * color_map_fond(eau);\n    \n    vec3 col_reflet_lune = lune * color_map_lune(eau);\n    vec3 col_reflet_ville = ville * color_map_ville(eau);\n    vec3 col_reflet_fish = fish_1 * color_map_poisson(eau) + fish_2 * color_map_poisson(eau);\n    \n    vec3 col = col_eau + col_reflet_lune + col_reflet_ville + col_reflet_fish;\n\n    float test = fish_2;\n\n    // ---- Output to screen --------------------------------------------------\n    fragColor = vec4(col, 1.);\n    //fragColor = vec4(vec3(test), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// les cartes de couleurs\n//------------------------\n\n#define _2PI_ 6.283185307\n#define _PI_ 3.14159265358979\n\n\nvec3 color_map_fond(float intensite){\n    float R, G, B;\n    \n    float inty = (intensite + _PI_)/(2.*_PI_);\n    float it = inty-0.1;\n    float it2 = inty-1.;\n    \n    if(inty<0.1){\n        R = -2.0*it;\n        G = -9.3*it;\n        B = -18.0*it;\n    }\n    else if(inty>0.9){\n        R = 0.13;\n        G = 0.65;\n        B = 0.80;\n    }\n    else{\n        R = 0.20*it;\n        G = 0.93*it;\n        B = 1.80*it;\n    }\n    \n    return vec3(R, G, B);\n}\n\n\nvec3 color_map_lune(float intensite){\n    float R, G, B;\n    \n    float inty = (intensite + _PI_)/(2.*_PI_);\n    float it = inty-0.1;\n    float it2 = inty-1.;\n    \n    if(intensite<0.1){\n        R = -1.*it + 0.5;\n        G = -1.3*it + 0.75;\n        B = -1.*it + 1.;\n    }\n    else if(intensite>0.9){\n        R = 2.;\n        G = 2.;\n        B = 2.;\n    }\n    else{\n        R = 0.5*it + 0.5;\n        G = 1.23*it + 0.7;\n        B = 2.1*it + 1.;\n    }\n    \n    return vec3(R, G, B);\n}\n\n\nvec3 color_map_ville(float intensite){\n    float R, G, B;\n    \n    float inty = (intensite + _PI_)/(2.*_PI_);\n    float it = inty-0.1;\n    float it2 = inty-1.;\n    \n    if(intensite<0.1){\n        R = 0.00;\n        G = 0.02;\n        B = 0.07;\n    }\n    else if(intensite>0.9){\n        R = 0.00;\n        G = 0.05;\n        B = 0.08;\n    }\n    else{\n        R = -0.2;\n        G = it*0.43 - 0.2;\n        B = it*1.30 - 0.4;\n    }\n    \n    return vec3(R, G, B);\n}\n\n\nvec3 color_map_poisson(float intensite){\n    float R, G, B;\n    \n    float inty = (intensite + _PI_)/(2.*_PI_);\n    float it = inty-0.1;\n    float it2 = inty-1.;\n    \n    if(intensite<0.1){\n        R = 0.00;\n        G = 0.00;\n        B = 0.25;\n    }\n    else if(intensite>0.9){\n        R = 0.00;\n        G = 0.15;\n        B = 0.30;\n    }\n    else{\n        R = it*0.00;\n        G = it*0.43;\n        B = it*1.30;\n    }\n    \n    return vec3(R, G, B);\n}","name":"Common","description":"","type":"common"}]}