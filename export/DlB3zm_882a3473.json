{"ver":"0.1","info":{"id":"DlB3zm","date":"1673015562","viewed":371,"name":"Spherical / Octahedral mapping","username":"EisernSchild","description":"Trying to map a sphere accordingly in 2D UV","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["texture","uv","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Spherical / Octahedral mapping\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n    Sphereical / Octahedral mapping\n    \n    Another approach to spherical mapping. Half spherical, other\n    half octahedral mapped.\n    \n    I'm trying to convert octahedral side from hexagonal to cartesian \n    to provide the (2D) UV map.\n    \n    Use Mouse to rotate/zoom.\n    \n*/\n\n#define PI 3.141592654f\n\n#define NOISE_BLEND\n// #define NORMAL_COLOR\n\n// intersection\nstruct Intersection\n{\n    // hit entry, exit (T + position)\n    vec4 vTen, vTex;\n    // normal entry, exit\n    vec3 vNen, vNex;\n};\n\n/// Hex to cartesian coordinates\nvec2 HexXY(vec2 vUv)\n{\n\t// get cartesian coords\n\treturn vec2( (vUv.x * 3.f - vUv.y * 1.5f) / sqrt(3.f), vUv.y * 1.5f );\n}\n\n// spherical mapping by sphere normal...\n// from http://www.raytracerchallenge.com/bonus/texture-mapping.html\nvec2 spherical_map(vec3 vNor)\n{\n    // compute the azimuthal angle : -π < theta <= π\n    // angle increases clockwise as viewed from above,\n    // which is opposite of what we want, but we'll fix it later.\n    float fTheta = atan(vNor.x, vNor.z);\n\n    // compute the polar angle : 0 <= phi <= π\n    float fPhi = acos(vNor.y);\n\n    // -0.5 < raw_u <= 0.5\n    float fRaw_U = fTheta / (2.f * PI);\n\n    // 0 <= u < 1\n    // here's also where we fix the direction of u. Subtract it from 1,\n    // so that it increases counterclockwise as viewed from above.\n    float fU = 1.f - (fRaw_U + .5f);\n\n    // we want v to be 0 at the south pole of the sphere,\n    // and 1 at the north pole, so we have to \"flip it over\"\n    // by subtracting it from 1.\n    float fV = 1.f - fPhi / PI;\n\n    return vec2(fU, fV);\n}\n\n// octahedral mapping by sphere normal...\nvec2 octahedral_map(vec3 vNor)\n{\n    // octahedral map\n    return HexXY(vec2( max(max(\n                    abs(abs(vNor.x) - abs(vNor.z)) , \n                    abs(abs(vNor.y) - abs(vNor.x)) ), \n                    abs(abs(vNor.z) - abs(vNor.y)) ),\n                 min(min(\n                    abs(abs(vNor.x) - abs(vNor.z)) , \n                    abs(abs(vNor.y) - abs(vNor.x)) ), \n                    abs(abs(vNor.z) - abs(vNor.y)) )));\n}\n\n// sphere intersection... based on work from iq : https://iquilezles.org/articles/intersectors/\nIntersection iSphere(in vec3 vOri, in vec3 vDir, in vec3 vCen, float fRad)\n{\n    // get local origin\n    vec3 vOriL = vOri - vCen;\n    \n    // ortho project local origin->direction\n    float fOD = dot(vOriL, vDir);\n    \n    // square distance origin->center minus radius\n    float fOR = dot(vOriL, vOriL) - fRad*fRad;\n    \n    // square hit center (!)\n    float fTHitS = fOD*fOD - fOR;\n    \n    // no intersection\n    Intersection sRet = Intersection( vec4(-1.f), vec4(-1.f), vec3(0.f), vec3(0.f));\n    if( fTHitS < .0f ) return sRet;\n    \n    // hit distance to center disk\n    fTHitS = sqrt(fTHitS);\n    \n    // hit vector + position\n    sRet.vTen.x = -fOD - fTHitS;\n    sRet.vTex.x = -fOD + fTHitS;\n    sRet.vTen.yzw = vOri + vDir * sRet.vTen.x;\n    sRet.vTex.yzw = vOri + vDir * sRet.vTex.x;\n    \n    // normals\n    sRet.vNen = normalize(sRet.vTen.yzw - vCen);\n    sRet.vNex = normalize(sRet.vTex.yzw - vCen);\n\n    // return with normals\n    return sRet;\n}\n\n// lookat matrix.. from https://www.shadertoy.com/view/Xtl3W2\nmat3 LookAt(in vec3 vOri, in vec3 vTar, in float fRoll )\n{\n    vec3 vW = normalize( vTar - vOri );\n    vec3 vU = normalize( cross(vW, vec3(sin(fRoll),cos(fRoll),0.0) ) );\n    vec3 vV = normalize( cross(vU,vW));\n    return mat3( vU, vV, vW );\n}\n\n// simple checkers\nfloat checkers_001(vec2 vUv, float fDist)\n{\n    return mix(0.3, smoothstep(0.005, 0.005 + fDist * 0.005, min(fract(vUv.x), fract(vUv.y))) * (max(mod(floor(vUv.x), 2.), mod(floor(vUv.y), 2.)) * .25 + .75),\n        (1. - smoothstep(0.995 - fDist * 0.005, 0.995, max(fract(vUv.x), fract(vUv.y)))));\n}\n\n// simplex noise by iq : https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvoid mainImage( out vec4 cOut, in vec2 vUv )\n{\n\t// create view ray\n    vec2 vP = (-iResolution.xy + 2.0 * vUv.xy) / iResolution.y;\n    vec2 vM = (iMouse.z > 0.f) ? abs(iMouse.xy / iResolution.xy) * vec2(8.f, 3.f) + 1.f : vec2(iTime, 2.f);\n    vec3 vOri = vec3(sin(vM.x) * vM.y, 2.f, cos(vM.x) * vM.y);\n\tvec3 vDir = normalize(LookAt(vOri, vec3(0.f), 0.f) * vec3(vP.xy, 2.f) );\n    \n    // get sphere\n    Intersection sInt = iSphere(vOri, vDir, vec3(0.f), 1.f);\n    vec3 vPos = sInt.vTen.yzw;\n    vec3 vNor = sInt.vNen;\n    float fTHit = sInt.vTen.x;\n    if (fTHit > 0.f)\n    {       \n        // spherical map\n        vec2 vSUv = spherical_map(vNor);\n        vec4 cOutS = mix(vec4(.2f, .2f, .2f, 1.f), vec4(1.f), checkers_001(vSUv * 16.f, fTHit * 3.f));\n        \n        // octahedral map\n        vec2 vOUv = octahedral_map(vNor);\n        vec4 cOutH = mix(vec4(.2f, .2f, .2f, 1.f), vec4(1.f), checkers_001(vOUv * 6.f, fTHit * 9.f));\n        \n        // half sphere each mapping\n        cOut = (vNor.x > 0.f) ? cOutS : cOutH;\n        \n        #ifdef NOISE_BLEND\n        // blend with noise by time\n        float fNoise = ((vNor.x > 0.f) ? noise(vSUv * 32.f) : noise(vOUv * 16.f)) * .5f + .5f;\n        cOut.xyz = mix(cOut.xyz, vec3(fNoise), (sin(iTime) + 1.f) * .5f);\n        #endif\n        \n        #ifdef NORMAL_COLOR\n        // set normal color ?\n        vec3 vNorRGB = vec3(\n            (vNor.x > 0.f) ? 1.f : 0.f,\n            (vNor.y > 0.f) ? 1.f : 0.f,\n            (vNor.z > 0.f) ? 1.f : 0.f);\n        cOut.xyz = mix(cOut.xyz, vNorRGB, .2f);\n        #endif\n        \n        // simple diffuse\n        cOut.xyz *= max(dot(normalize(vec3(-4.f, 5.f, -6.f)), vNor), 0.3f);\n    }\n    else\n        cOut = vec4(abs(vDir.y) + (sin(vDir.x * PI * 16.f) + cos(vDir.z * PI * 16.f)) * .01f);\n}","name":"Image","description":"","type":"image"}]}