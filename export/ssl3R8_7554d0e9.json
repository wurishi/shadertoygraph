{"ver":"0.1","info":{"id":"ssl3R8","date":"1615849974","viewed":95,"name":"kifs2d _6L","username":"sus1357","description":"colors in the current version are a bit too bright in the middle to appreciale all the beautiful inner shapes, I still have to learn a bit more about color mixing xD","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//here between time = 210 and 230 some organic-looking beauty\n\nvec2 DOMAIN_XY = vec2(16., 9.);   // RAZMER OBLASTI\nfloat speed = 25.;                // skorost' metamorfoz (???)\nbool strobo_on = false; //ORIG was true, and fancy was false\nbool fancy_colors_on = true; \n                                // KIFS-konstanti\nconst int N = 3;               // N - kol-vo vektorov simmetrii\nconst int N_but_fancy = 3;    // esli hochu uzaty tol'ko chasty vektorov\nconst int ITER = 8;       // WHYYY IT MUST BE CONSTANT, STUPID GLSL LOOPS\n\n                         //colors constants\nvec3 white = vec3(1.,1.,1.);\nvec3 black = vec3(0.,0.,0.);\nvec3 red   = vec3(1.,0.,0.);\nvec3 blue  = vec3(0.,0.,1.);\nvec3 green = vec3(0.,1.,0.);\n                     //      funksii      kogda tut dve leviye (lol) kosiye cherti, ploho))\nfloat gauss(in vec2 p, in float s) {return exp( -(p.x*p.x+p.y*p.y)/(2.*s*s) );}\n        //tupoy 2d gauss s centrom v (0,0)\nfloat gauss_1d(float x, float m, float s) {return exp( -((x-m)*(x-m))/(2.*s*s) );}\n   //1d gauss, ne delil na sigmu (s), no pohuy ( return (1/.s)*exp(...) )\nvec2 a2v(in float a){return vec2(cos(radians(a)), sin(radians(a)));}\n  //gradus -> vektor simmetrii\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // sozdal prostranstvo (uv) razmerom v DOMAIN s tsentrom v (0,0)\n    vec2 uv = fragCoord*DOMAIN_XY/iResolution.xy - .5*DOMAIN_XY;\n\n                         //  | | |\n // KIFS KIFS KIFS KIFS KIFS v v v\n// -------- initialization ----------\n    float scale = 2.;\n    \n        vec2 symm[N];                                //symm[0] = a2v(60.); symm[1] = a2v(-60.);\n    \n    symm[0] = a2v(0.);           //a2v(60. + iTime*speed); //symm[0] = a2v(-60. + iMouse.x); symm[1] = a2v(60. + iMouse.y);\n    symm[1] = a2v(45. + (5./360.)*iTime*speed); //a2v(-60.);\n    symm[2] = a2v(135.);\n    \n        float rot[N];\n    \n    rot[0] = 0.;\n    rot[1] = 90.+iTime*speed; // in mandelbulber alpha (Rotate_Z) = 90.\n    rot[2] = 0.; // 0 or 90 ???\n    \n        mat2 rot_matr[N];\n    \n    rot_matr[1][0][0] = cos(radians(rot[1])); rot_matr[1][0][1] = -sin(radians(rot[1]));\n    rot_matr[1][1][0] = sin(radians(rot[1])); rot_matr[1][1][1] = cos(radians(rot[1]));\n    \n        bool mirror[N];\n        \n    mirror[0] =\n    mirror[1] = \n    mirror[2] = false; // in mandelbulber gamma (Rotate_(X or Y)) = 180.\n    \n    \n    vec2 offset = vec2(.0,.0);                //vec2 offset = vec2(-1.+2.*iMouse.x/iResolution.x, -1.+2.*iMouse.y/iResolution.y);\n        \n        float dist[N];\n    \n    dist[0] = -1.;\n    dist[1] = -1.;\n    dist[2] = -1.;\n    \n\n\nfloat color_over_iterations = 0.;\nfloat coi_const = 1.;\n\nfloat mod_const = pow(scale, float(ITER)); // eta konstanta delaet tolschinu\n                                                  // polos, kotoraya ZAVISIT ot ITER, POSTOYANNOY\nfloat w = 0.05 * mod_const; // tolschina polosok napravlennikh vdol' osey\n\n\n// --------  algorithm  ------------- \n    for(int i=0; i<ITER; i++) {\n        for(int n=0; n<N_but_fancy; n++) {\n            // rotate and mirror-rotate\n            if ( rot[n] != 0.0 ) {\n                uv = rot_matr[n] * uv;\n            }\n        \n          // symm vecs \n            float len = dot(uv, symm[n]);\n            if( len < dist[n] ) {\n                uv -= 2.0*(len - dist[n])*symm[n]; //uv -= 2.0*(len - dist[i])*symm[i]\n            }\n        }\n        \n        // scaling\n        uv*=scale;\n        uv -= (scale - 1.) * offset;\n        \n        if(strobo_on) { // stroboscope\n            if(float(i) > mod(30.*iTime, float(ITER))) break; \n        }\n        \n        \n        float x_ = float(int( (uv.y<w)&&(uv.y>-w) ));\n        float y_ = float(int( (uv.x<w)&&(uv.x>-w) ));\n        color_over_iterations += coi_const*(x_+y_);\n        \n    }\n  // --------------------------------\n // Output to screen\n \n    vec3 koltso  = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime) , 1. ) * red;\n    vec3 koltso2 = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime)+1.5*sin(.6*iTime)+3. , 1.5 )\n                        *\n                   (.9*green + .2*blue);\n    vec3 col_g = gauss(uv, .1)*white;\n   \n\n\n    //vec2 norm = fragCoord/iResolution.xy;\n    //vec3 col_ex = 0.5 + 0.5*cos(2.35+norm.xyx+vec3(0,2,4));\n    //col_ex *= step( max( mod(uv.x, mod_const), mod(uv.y, mod_const) ), 0.9*mod_const );\n    \n    \n    \n    \n\n    \n     // col_ex *= .75*sin(iTime)+.5;\n    //fragColor = vec4(col+col_g+koltso,1.0);\n   // fragColor = vec4(col_g+koltso+koltso2+col_ex,1.0);\n   \n    vec3 result = col_g + // mertsaniye\n                  + koltso + \n                  + koltso2\n                  ;\n    if(fancy_colors_on) {\n        //float mod_const = pow(scale, float(ITER)); // eta konstanta delaet tolschinu\n                                                  // polos, kotoraya ZAVISIT ot ITER, POSTOYANNOY\n        //float w = 0.05 * mod_const; // tolschina polosok napravlennikh vdol' osey\n    \n        vec3 x_positive = float(int((uv.x>0.0)&&(uv.y<w)&&(uv.y>-w)))*red; // osi\n        vec3 x_negative = float(int((uv.x<0.0)&&(uv.y<w)&&(uv.y>-w)))*0.2*red; \n        vec3 y_positive = float(int((uv.y>0.0)&&(uv.x<w)&&(uv.x>-w)))*(red+green);\n        vec3 y_negative = float(int((uv.y<0.0)&&(uv.x<w)&&(uv.x>-w)))*0.2*(red+green);\n        vec3 osi = x_positive + x_negative + y_positive + y_negative;\n\n        vec2 xy_examp = fragCoord/iResolution.xy;\n        vec3 col_examp = 0.5 + 0.5*cos(iTime+xy_examp.xyx+vec3(0,2,4));\n        \n        result += .5*(-osi*col_examp + osi + col_examp); //poloski + tsvetovoye resheniye\n    }\n    \n    vec2 xy_examp = fragCoord/iResolution.xy;\n        vec3 col_examp = 0.5 + 0.5*cos(iTime+xy_examp.xyx+vec3(0,2,4));\n        \n    //result = smoothstep(result, col_examp, white);\n    \n    result += (\n    1.-mod(color_over_iterations, 2.))*col_examp;\n    \n    fragColor = vec4(result ,1.0);                             \n}","name":"Image","description":"","type":"image"}]}