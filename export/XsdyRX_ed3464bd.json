{"ver":"0.1","info":{"id":"XsdyRX","date":"1519677325","viewed":129,"name":"coolstuff","username":"inantop","description":"coolcoolcoolio","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["coolcool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 perspective(float fovy, float aspect, float near, float far)\n{\n\tmat4 result;\n    float rad = fovy * 3.14159265 / 180.0;\n    float tanHalfFovy = tan(rad / 2.0);\n    result[0][0] = 1.0 / (aspect * tanHalfFovy);\n    result[1][1] = 1.0 / tanHalfFovy;\n    result[2][2] = - (far + near) / (far - near);\n    result[2][3] = - 1.0;\n    result[3][2] = - (2.0 * far * near) / (far - near);\n    return result;\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n    mat4 Result = mat4(1.0);\n    \n    vec3  f = normalize(center - eye);\n    vec3  u = normalize(up);\n    vec3  s = normalize(cross(f, u));\n    \n    u = cross(s, f);\n    Result[0][0] = s.x;\n    Result[1][0] = s.y;\n    Result[2][0] = s.z;\n    Result[0][1] = u.x;\n    Result[1][1] = u.y;\n    Result[2][1] = u.z;\n    Result[0][2] =-f.x;\n    Result[1][2] =-f.y;\n    Result[2][2] =-f.z;\n    Result[3][0] =-dot(s, eye);\n    Result[3][1] =-dot(u, eye);\n    Result[3][2] = dot(f, eye);\n    return Result;   \n}\n\nvec3 unproject(vec3 win, mat4 mvp, vec4 vp)\n{\n    mat4 inv = inverse(mvp);\n\n    vec4 tmp = vec4(win, 1.0);\n    tmp.x = (tmp.x - vp.x) / vp.z;\n    tmp.y = (tmp.y - vp.y) / vp.w;\n    tmp.x = tmp.x * 2.0 - 1.0;\n    tmp.y = tmp.y * 2.0 - 1.0;\n\n    vec4 obj = inv * tmp;\n    obj /= obj.w;\n\n    return vec3(obj);\n}\n\n/* Rays */\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Sphere\n{\n    vec3 position;\n\tfloat radius;\n    vec3 color;\n};\n    \nstruct Box\n{\n    vec3 position;\n    vec3 size;\n    vec3 color;\n};\n    \nstruct Light\n{\n    vec3 position;\n    vec3 color;\n};\n    \nstruct Camera\n{\n    vec3 position;\n    vec3 target;\n    vec3 up;\n};\n\nstruct Plane\n{\n    vec4 plane;\n};\n    \nvec3 ScreenToWorld(in vec3 screen, in Camera c)\n{\n    mat4 p = perspective(60., iResolution.x / iResolution.y, 0.01, 1000.0);\n    mat4 v = lookAt(c.position, c.target, c.up);\n    return unproject(screen, p * v, vec4(0.0, 0.0, iResolution.x, iResolution.y));\n}\n\nfloat pointDistance(in vec3 worldPos, in Box box)\n{\n    vec3 v = abs(worldPos - box.position) - box.size;\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat pointDistance(in vec3 worldPos, in Sphere s)\n{\n\treturn distance(worldPos, s.position) - s.radius;   \n}\n\nfloat pointDistance(in vec3 worldPos, in Plane p)\n{\n  \t// n must be normalized\n    vec4 n = p.plane;\n  \treturn dot(worldPos,n.xyz) + n.w;\n}\n\nfloat sdf_smin(float a, float b)\n{\n    const float k = 16.;\n\tfloat res = exp(-k*a) + exp(-k*b);\n\treturn -log(max(0.0001,res)) / k;\n}\n\nbool approx(in float a, in float b)\n{\n    return abs(a-b) < 0.05;\n}\n\nfloat sdf_subtract(float a, float b)\n{\n    return max(-a, b);\n}\n\nfloat sdf_add(float a, float b)\n{\n    return min(a,b);\n}\n\nfloat sdf_smooth_add(float a, float b)\n{\n    return sdf_smin(a,b);\n}\n\nfloat sdf_intersect(float a, float b)\n{\n    return max(a,b);\n}\n\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec3 q = (inverse(m)*vec4(p,0.0)).xyz;\n    return q;\n}\n\nfloat makeYouiLogo(in vec3 worldPos, in vec3 logoPos)\n{\n    vec2 skew = vec2(2.8, 5.0);\n    skew = -normalize(skew);\n    mat4 xSkew = mat4(1.0, 0.0, 0.0, 0.0, skew.x, skew.y, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n    worldPos = opTx(worldPos, xSkew);\n    \n    vec2 h = vec2(1.0, 0.6);\n    vec3 q = abs(worldPos - logoPos);\n    \n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat map(in vec3 worldPos, out vec3 objColor)\n{   \n    bool first = true;\n    float minDist = 100000.;\n    \n\tBox b;\n    b.position = vec3(0.0, 0.0, 0.0);\n    b.size = vec3(1.0, 1.0, 1.0);\n    \n    Sphere s;\n    s.position = vec3(0.0, 0.0, 1.7 * cos(iTime));\n    s.radius = 1.0;\n    \n    Sphere s2;\n    s2.position = vec3(0.0, 0.0, -1.7 * cos(iTime));\n    s2.radius = 1.0;\n    \n    Sphere s3;\n    s3.position = vec3(1.7 * cos(iTime), 0.0, 0.0);\n    s3.radius = 1.0;\n    \n    Sphere s4;\n    s4.position = vec3(-1.7 * cos(iTime), 0.0, 0.0);\n    s4.radius = 1.0;\n    \n    float shape2;\n    shape2 = sdf_smooth_add(pointDistance(worldPos, s), pointDistance(worldPos, s2));\n    shape2 = sdf_smooth_add(shape2, pointDistance(worldPos, s3));\n    shape2 = sdf_smooth_add(shape2, pointDistance(worldPos, s4));\n    \n    float shape1;\n    //shape1 = pointDistance(worldPos, b);\n    shape1 = makeYouiLogo(worldPos, vec3(0.0,0.0,0.0));\n    \n    float lerp = clamp(abs(sin(iTime)) * 1.8 - 0.4, 0.0, 1.0); //linger at ends\n    \n    float morph = shape1 * lerp + (1.0 - lerp) * shape2;\n    \n    objColor = vec3(240.0/255.0, 23.0/255.0, 44.0/255.0);\n    \n    return morph;\n}\n\nfloat map(in vec3 worldPos)\n{\n    vec3 dontCare;\n    return map(worldPos, dontCare);\n}\n\nvec4 simpleLambert(in vec3 normal, in vec3 color, in vec3 lColor, in vec3 lDir, in vec3 eye)\n{  \n   vec3 halfVec = (lDir + eye) / 2.;\n   float s = pow(dot(normal, halfVec), 8.0) * 0.5;\n    \n   float ndotl = max(dot(normal, lDir), 0.0);\n   ndotl = clamp(ndotl, 0.0, 1.0);\n    \n   vec3 environment = texture(iChannel0, reflect(-eye, normal)).rgb;\n   float REFLECTIVITY = .4;\n    \n   vec3 baseColor = environment * REFLECTIVITY + color * (1.0 - REFLECTIVITY);\n    \n   vec4 col;\n   const float AMBIENT = 0.8;\n   col = vec4(baseColor * AMBIENT + baseColor * lColor * ndotl + s, 1.0);\n   return col;\n}\n\nvec3 normal (in vec3 point)\n{\n\tconst float eps = 0.01;\n    \n    return normalize(vec3(map(point + vec3(eps, 0, 0)) - map(point - vec3(eps, 0, 0)),\n                     map(point + vec3(0, eps, 0)) - map(point - vec3(0, eps, 0)),\n                     map(point + vec3(0, 0, eps)) - map(point - vec3(0, 0, eps))));\n}\n\nvec4 raymarch(in Ray ray, in Light l, in Camera c)\n{\n    const int STEPS = 128;\n    const float MIN_DISTANCE = 0.01;\n    \n    vec4 col;\n\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 objColor;\n        \n        float dist = map(ray.origin, objColor);\n        if (dist < MIN_DISTANCE)\n        {\n            col = simpleLambert(normal(ray.origin), objColor, l.color, normalize(l.position - ray.origin), normalize(c.position - ray.origin));\n\n            return col;\n        }\n        ray.origin += dist / 2.0 * ray.direction;\n    }\n    return texture(iChannel0, ray.direction);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera c;\n    c.position = vec3(3.0, 3.0, 3.0);\n    c.target = vec3(0.0, 0.0, 0.0);\n    c.up = vec3(0.0, 1.0, 0.0);\n       \n    Light l;\n    l.position = vec3(0.0, 5.0, 0.0);\n    l.color = vec3(1.0, 0.8, .8);\n    \n    const float ANIMATION_SPEED = .8;\n    float adjustedTime = ANIMATION_SPEED * iTime;\n    c.position = vec3(cos(adjustedTime) * 5.0, 2.0, sin(adjustedTime) * 5.0);\n    \n    Ray worldRay;\n    worldRay.origin = ScreenToWorld(vec3(fragCoord, 0.0), c);\n    worldRay.direction = normalize(ScreenToWorld(vec3(fragCoord, 1.0), c) - worldRay.origin);\n\n    fragColor = raymarch(worldRay, l, c);\n}","name":"Image","description":"","type":"image"}]}