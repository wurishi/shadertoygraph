{"ver":"0.1","info":{"id":"WsSBzt","date":"1591916670","viewed":104,"name":"Little ShaderToy","username":"hummingbird","description":"Trying to fiddle with shader toy. Wrote a simple raymarching scene for testing purposes. Find all the SDF function references from https://iquilezles.org/articles/distfunctions/distfunctions.htm","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera{\n\tvec3 origin;\n    vec3 target;\n    vec3 up;\n    float vfov;\n    float focal_length;\n    float aspect_ratio;\n};\n    \n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p, vec3 center){\n\treturn length(p- center) - 1.0;\n}\n\nfloat planeSDF(vec3 p, vec3 normal, float height){\n\treturn dot(p-vec3(0.0,1.0,0.0)*height, normal);\n\n}\n\nfloat roundBoxSDF( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdOctahedron( vec3 p, vec3 center, float s)\n{\n  p = abs(p - center);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sceneSDF(vec3 p){\n  \n    float roundBox = roundBoxSDF(p,vec3(1.0),.25);\n    float sphere = sphereSDF(p, vec3(0.0,0.0,1.5*sin(iTime)));\n    \n    float oct = sdOctahedron(p, vec3(0.0,2.0*sin(iTime), 0.0), 1.0);\n    \n    float result = differenceSDF(roundBox,sphere);\n    result = unionSDF(result, oct);\n    return result;\n}\n\n\nvec3 getSceneNormal(vec3 p){\n\treturn normalize(vec3(sceneSDF(vec3(p.x+0.0001,p.y,p.z)) -sceneSDF(vec3(p.x-0.0001,p.y,p.z)),\n                               sceneSDF(vec3(p.x,p.y+0.0001,p.z)) -sceneSDF(vec3(p.x,p.y-0.0001,p.z)),\n                               sceneSDF(vec3(p.x,p.y,p.z+0.0001)) -sceneSDF(vec3(p.x,p.y,p.z-0.0001))                 \n                              ));\n}\n\nmat4 getViewMatrix(Camera cam){\n\tvec3 f = normalize(cam.target - cam.origin);\n    vec3 r = normalize(cross(f, cam.up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n    \tvec4(r,0.0),\n        vec4(u,0.0),\n        vec4(f,0.0),\n        vec4(cam.origin.x,cam.origin.y,cam.origin.z,1.0)\n    );\n\n}\n\nvec3 getCameraRay(vec2 uv, Camera cam){\n    float half_height = tan(radians(cam.vfov/2.0));\n    float half_width = half_height*cam.aspect_ratio; \n    vec3 lower_left = vec3(-half_width, -half_height, cam.focal_length);\n    vec4 view_plane_point = vec4(lower_left + vec3(2.0*half_width,0.0,0.0)*uv.x+vec3(0.0,2.0*half_height,0.0)*uv.y,1.0);\n    view_plane_point = getViewMatrix(cam)*view_plane_point;\n    return normalize(view_plane_point.xyz-cam.origin);\n    \n}\n\n// map from 0 -  255 to 0 - 1\nvec3 normalizedRGB(vec3 rgb){\n\treturn vec3(rgb/255.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \n    // screen UV\n    vec2 uv = fragCoord / iResolution.xy;\n    // fragColor = vec4(uv.x, uv.y, 0.0,1.0);\n   \n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 horizontal = vec3(2.0 * aspect_ratio,0.0,0.0);\n    vec3 vertical = vec3(0.0,2.0,0.0);\n    vec3 lower_left = vec3(-horizontal.x/2.0,-vertical.y/2.0,1.0);\n    \n    // handle input\n    bool isLeft = iMouse.x < iResolution.x/2.0;\n    \n    // setup camera\n    Camera cam;\n    cam.origin = vec3(10.0*cos(iTime/5.0),5.0,10.0*sin(iTime/5.0));\n    // cam.origin = vec3(0.0,5.0,-10.0);\n    cam.target = vec3(0.0,0.0,0.0);\n    cam.up = vec3(0.0,1.0,0.0);\n    cam.vfov = 30.0;\n    cam.focal_length = 1.0;\n    cam.aspect_ratio = aspect_ratio;\n    \n    // render sky\n    fragColor.xyz = mix(vec3(55.0,87.0,99.0)/225.0,vec3(121.0,249.0,255.0)/225.0,uv.y );\n   \n    // render scene\n    vec3 rayDir = getCameraRay(uv, cam);\n    vec3 p = cam.origin;\n    for(int i=0;i<250;i++){\n        float d = sceneSDF(p);\n        p = p+rayDir*d;\n        if(d<0.0001){\n            vec4 finalColor = vec4(0.0,0.0,0.0,1.0);\n            vec3 albedo = vec3(normalizedRGB(vec3(230.0, 141.0, 64.0)));\n            vec3 specular = vec3(0.0,1.0,1.0);\n            vec3 ambient = vec3(0.1,0.1,0.3);\n            vec3 N = getSceneNormal(p);\n            vec3 L = normalize(vec3(1.0,1.0,0.0) - vec3(0.0,0.0,5.0));\n            vec3 E = normalize(cam.origin-p);\n            vec3 H = normalize(L+E);\n            \n            float NdotH = max(dot(N,H), 0.0);\n            float NdotL = max(dot(N, L),0.0);\n            \n            float specularIntensity = pow(NdotH, 300.0);\n            finalColor.xyz = albedo * NdotL + specular*specularIntensity + ambient;\n            finalColor.xyz = pow(finalColor.xyz, vec3(1.0/ 2.2));\n           \n       \n        \tfragColor = finalColor;\n            return;\n        }\n    \n    } \n}","name":"Image","description":"","type":"image"}]}