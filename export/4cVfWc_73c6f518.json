{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define ITERATION_NUM 99\nconst float MAT_1=1.0;\nconst float MAT_2=2.0;\nconst float pi = acos(-1.0);\nvec3 pale_aqua=vec3(0.76,0.89,0.89);\nvec3 wedgwood_blue=vec3(0.08,0.51,0.67);\nvec2 opUnion(vec2 d1,vec2 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat checkerboard3d(vec3 p,vec3 scale)\n{\n    return 0.1 + 0.9* mod(floor(p.x*scale.x) +floor(p.y*scale.y) +  floor(p.z*scale.z),2.0);\n}\n\n//float checkerboard3d(vec3 p,vec3 scale)\n//{\n//    return 1.0* mod(floor(p.x*scale.x) +floor(p.y*scale.y) +  floor(p.z*scale.z),2.0);\n//}\n\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvec2 map(vec3 p) \n{\n    vec2 d;\n    d=vec2(sdBox(p,vec3(1.0)), MAT_1);\n    d=opUnion(d,vec2(sdBox(p+vec3(-2.0,0.0,0.0),vec3(0.5)), MAT_2));\n\treturn d;\n}\n\nvec3 materialize(vec3 p, float depth,vec2 mat,vec2 uv)\n{\n    vec3 col=mix(pale_aqua, wedgwood_blue,uv.y+0.7);\n    if (depth > 10.0)\n    {\n    }\n    else\n    {\n        vec3 s=vec3(5.0);\n        float check=checkerboard3d(p,s);\n        if(mat.y==MAT_2)\n        {\n            col =vec3(check);\n        }\n        if(mat.y*check==MAT_1)\n        {\n            col =vec3(0.0);\n        }\n     }\n     return col;\n}\nvec3 raymarch(vec3 ro, vec3 rd,vec2 uv)  \n{\n\tvec3 p;\n    vec2 d;\n\tfloat depth;\n\tfor(int i=0; i<ITERATION_NUM; i++) \n\t{\n        p=ro+rd*depth;\n\t\td = map(p);\n\t\tif(d.x<0.00001)\n\t\t{\n\t\t    break;\n\t\t}\n\t\tdepth += d.x;\n\t}\n\treturn  materialize(p,depth,d,uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    vec3 target = vec3( 0.75,0.75, -0.75 );\n    vec3 origin = target + vec3( 6.5*cos(0.1*iTime + 7.0*mo.x), 4.2, 6.5*sin(0.1*iTime + 7.0*mo.x) );\n    mat3 camera = SetCamera( origin, target, 0.0 );\n \n    vec3 rd = camera * normalize(vec3(p,3.5)); \n\tvec3 col=raymarch(origin , rd,p);    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cVfWc","date":"1734534433","viewed":35,"name":"checkbox_1","username":"Acre","description":"The back was supposed to be transparent.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""}}