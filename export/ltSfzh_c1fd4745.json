{"ver":"0.1","info":{"id":"ltSfzh","date":"1514568082","viewed":868,"name":"pt - next event estimation?","username":"MacSlow","description":"Almost happy with my first path-tracer. it converges quickly (when played) but it's still slow on IGPs. In case fails to compile: https://www.youtube.com/watch?v=cAxfPFxsuEM Have to fix ray-triangle intersections.","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["3d","pathtracing","study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// pt - a basic pathtracer for learning the fundamentals\n//\n// Copyright 2017-2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    // pull pixel-value from previous frame and average it with current value\n    vec3 col = texture (iChannel0, fragCoord / iChannelResolution[0].xy).rgb;\n    float f = texture (iChannel1, vec2 (.5)).r;\n    if (iFrame > 0 && iMouse.z <= .0)\n        col /= (float (iFrame) - f);\n\n\tfragColor = vec4 (col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// pt - a basic pathtracer for learning the fundamentals\n//\n// Copyright 2017-2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nprecision highp float;\n\nconst int MAX_SAMPLES = 8;\nconst int MAX_BOUNCES = 5;\n\nstruct Ray {\n\tvec3 ro; // ray origin\n    vec3 rd; // ray direction\n};\n\nstruct Result {\n    bool  hit;    // did a ray hit anything?\n    vec3  point;  // where did it hit in world-space\n    vec3  normal; // surface-normal at the hit-point\n    float dist;   // distance from ro to hit-point\n    int   id;     // material-id at that hit-point\n};\n\nstruct Triangle {\n\tvec3 a; // first vertex\n\tvec3 b; // second vertex\n\tvec3 c; // third vertex\n};\n\nstruct Material {\n    vec3  diffuse;     // base-color\n    float emissive;    // light/emissive strength\n    bool  doesReflect; // flag indicating if surface reflects\n    float reflAmount;  // factor for reflection influence\n    bool  doesRefract; // flag indicating if surface refracts\n    float ior;         // index of refraction\n};\n\nconst Material material[8] = Material[8] (Material (vec3 (.5, .7, 1.), // Blinn/Phong: diffuse\n                                              .0,                // Blinn/Phong: emissive\n                                              true,             // does reflect\n                                              .95,               // reflection strength\n                                              false,             // does refract\n                                              .31),              // ior\n\n                                    Material (vec3 (.2, 1., .2), // Blinn/Phong: diffuse\n                                              .0,                // Blinn/Phong: emissive\n                                              true,              // does reflect\n                                              .85,               // reflection strength\n                                              false,             // does refract\n                                              .31),              // ior\n\n                                    Material (vec3 (1., .2, .2), // Blinn/Phong: diffuse\n                                              .0,                // Blinn/Phong: emissive\n                                              true,              // does reflect\n                                              .75,               // reflection strength\n                                              false,             // does refract\n                                              .31),              // ior\n\n                                    Material (vec3 (.85),          // Blinn/Phong: diffuse\n                                              .0,                  // Blinn/Phong: emissive\n                                              true,                // does reflect\n                                              .1,                  // reflection strength\n                                              false,               // does refract\n                                              .85),                // ior\n\n                                    Material (vec3 (.85),          // Blinn/Phong: diffuse\n                                              .0,                  // Blinn/Phong: emissive\n                                              false,               // does reflect\n                                              .15,                 // reflection strength\n                                              false,               // does refract\n                                              .85),                // ior\n                                 \n                                    Material (vec3 (1., .75, .5),  // Blinn/Phong: diffuse\n                                              12.,                 // Blinn/Phong: emissive\n                                              false,               // does reflect\n                                              .15,                 // reflection strength\n                                              false,               // does refract\n                                              .85),                // ior\n\n                                    Material (vec3 (1., .75, .5),  // Blinn/Phong: diffuse\n                                              .0,                  // Blinn/Phong: emissive\n                                              false,               // does reflect\n                                              .15,                 // reflection strength\n                                              true,                // does refract\n                                              .25),                // ior\n\n                                    Material (vec3 (.5, 1., .75),  // Blinn/Phong: diffuse\n                                              .0,                  // Blinn/Phong: emissive\n                                              false,               // does reflect\n                                              .15,                 // reflection strength\n                                              true,                // does refract\n                                              .125));               // ior\n\nconst float PI = 3.14159265359;\nconst Result nullResult = Result (false, vec3 (.0), vec3 (.0), .0, 0);\nmat2 r2d (in float r) { float c = cos (r); float s = sin (r); return mat2 (vec2 (c, s), vec2 (-s, c));}\nResult minResult (in Result a, in Result b) {\n    if (!a.hit)\n        return b;\n\n    if (!b.hit)\n        return a;\n\n    bool favourA = a.dist <= b.dist;\n    return  Result (true,\n                    favourA ? a.point : b.point,\n                    favourA ? a.normal : b.normal,\n                    favourA ? a.dist : b.dist,\n                    favourA ? a.id : b.id);\n}\n\nResult sphereIntersect (in Ray ray, in vec3 p, in float r, in int id) {\n    Result res = nullResult;\n\n    // set up coefficients a, b and c\n    float b = dot (2. * ray.rd, ray.ro - p);\n    vec3 op = ray.ro - p;\n    float c = dot (op, op) - r * r;\n    float discriminant = b * b - 4. * c;\n    if (discriminant < .0) return res;\n    float d = sqrt (discriminant);\n\n    // compute possible values for t\n    float t1 = (-b + d) * .5;\n    float t2 = (-b - d) * .5;\n\n    if (t1 > .0 && t2 > .0) {\n        if (t1 < t2) {\n            vec3 i1 = ray.ro + t1 * ray.rd;\n            float d1 = distance (i1, ray.ro);\n            res.hit = true;\n            res.point = i1;\n            res.normal = normalize (i1 - p);\n            res.dist = d1;\n            res.id = id;\n        } else {\n            vec3 i2 = ray.ro + t2 * ray.rd;\n            float d2 = distance (i2, ray.ro);\n            res.hit = true;\n            res.point = i2;\n            res.normal = normalize (i2 - p);\n            res.dist = d2;\n            res.id = id;\n        }\n    }\n\n    return res;\n}\n\nResult planeIntersect (in Ray ray, in vec3 p, in vec3 n, in int id) {\n    Result res = nullResult;\n\n\t// are ray and plane parallel?\n    if (dot (n, ray.rd) > 1e-6) {\n        return res;\n    }\n\n    // determine ray-plane intersection point\n    vec3 i = ray.ro + (dot(p - ray.ro, n) / dot (ray.rd, n)) * ray.rd;\n\n    // prepare result\n    res.hit = true;\n    res.point = i;\n    res.normal = normalize (n);\n    res.dist = distance (i, ray.ro);\n    res.id = id;\n\n    return res;\n}\n\n// still broken\nResult triangleIntersect (in Ray ray, in Triangle tri, in int id) {\n    Result res = nullResult;\n\n    // for the moment (of laziness and to save a\n    // dot-product) we assume ab & bc are not colinear\n    vec3 ab = tri.b - tri.a;\n    vec3 bc = tri.c - tri.b;\n    vec3 ca = tri.a - tri.c;\n    vec3 n = normalize (cross (ab, bc));\n\n    res = planeIntersect (ray, tri.a, n, id);\n    if (!res.hit)\n        return nullResult;\n\n    // height-vectors\n    vec3 p = bc * dot (bc, ab) - tri.a;\n    vec3 q = ca * dot (ca, bc) - tri.b;\n    vec3 r = ab * dot (ab, ca) - tri.c;\n\n    // determine barycentric coordinates\n    float a = 1. - dot (p, tri.a - res.point) / dot (p, ab);\n    float b = 1. - dot (q, tri.b - res.point) / dot (q, bc);\n    float c = 1. - dot (r, tri.c - res.point) / dot (r, ca);\n\n    if (a + b + c <= 1.)\n\t    return res;\n    else\n        return nullResult;\n}\n\nRay cameraRay (in vec2 uv, in vec3 ro, in vec3 lookAt, in float zoom) {\n\tRay ray = Ray (vec3 (.0), vec3 (.0));\n\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 forward = normalize (lookAt - ro);\n    vec3 right = normalize (cross (worldUp, forward));\n    vec3 up = normalize (cross (forward, right));\n    vec3 camCenter = ro + zoom * forward;\n    vec3 i = camCenter + uv.x * right + uv.y * up;\n    vec3 rd = normalize (i - ro);\n\n    ray.ro = ro;\n    ray.rd = rd;\n\n\treturn ray;\n}\n\nvec3 lightPos() {\n    float t = iMouse.z > .0 ? iTime : texture (iChannel1, vec2 (.5)).g;\n\treturn vec3 (-1.75 + cos (t), 1.25, .0 + sin (t));\n}\n\nfloat lightSize () {\n    float t = iMouse.z > .0 ? iTime : texture (iChannel1, vec2 (.5)).g;\n\treturn .4 + .1 * cos (t);\n}\n\nResult lightIntersect (in Ray ray) {\n\treturn sphereIntersect (ray, lightPos(), lightSize(), 5);\n}\n\nbool intersectShadow (in Ray ray, in float dist) {\n    Result ball1 = sphereIntersect (ray, vec3 (1.5, -1., 2.0), 1., 0);\n    Result ball2 = sphereIntersect (ray, vec3 (1., -1.5, -1.0), .5, 3);\n    Result ball3 = sphereIntersect (ray, vec3 (-1., -1.25, -2.0), .75, 6);\n    Result ball4 = sphereIntersect (ray, vec3 (-.75, -1.25, .0), .75, 7);\n    Result ball5 = sphereIntersect (ray, vec3 (1., -.5, -1.0), .5, 3);\n    Result ball6 = sphereIntersect (ray, vec3 (1., .5, -1.0), .5, 3);\n    Result ball7 = sphereIntersect (ray, vec3 (1., 1.5, -1.0), .5, 3);\n\n    Result res = minResult (ball1, ball2);\n    res = minResult (ball3, res);\n    res = minResult (ball4, res);\n    res = minResult (ball5, res);\n    res = minResult (ball6, res);\n    res = minResult (ball7, res);\n\n    if (res.dist > .0001 && res.dist < dist)\n        return true;\n\n    return false;\n}\n\nResult intersect (in Ray ray) {\n    Result res = nullResult;\n\n    Result ball1 = sphereIntersect (ray, vec3 (1.5, -1., 2.0), 1., 0);\n    Result ball2 = sphereIntersect (ray, vec3 (1., -1.5, -1.0), .5, 3);\n    Result ball3 = sphereIntersect (ray, vec3 (-1., -1.25, -2.0), .75, 6);\n    Result ball4 = sphereIntersect (ray, vec3 (-.75, -1.25, .0), .75, 7);\n    Result ball5 = sphereIntersect (ray, vec3 (1., -.5, -1.0), .5, 3);\n    Result ball6 = sphereIntersect (ray, vec3 (1., .5, -1.0), .5, 3);\n    Result ball7 = sphereIntersect (ray, vec3 (1., 1.5, -1.0), .5, 3);\n    \n    Result light = lightIntersect (ray);\n\n    Result plane1 = planeIntersect (ray, vec3 (.0, -2., .0), vec3 (.0, 1., .0), 4);\n    Result plane2 = planeIntersect (ray, vec3 (.0, .0, 4.), vec3 (.0, .0, -1.), 1);\n    Result plane3 = planeIntersect (ray, vec3 (-4.0, .0, 0.), vec3 (1., .0, 0.), 4);\n    Result plane4 = planeIntersect (ray, vec3 (4.0, .0, 0.), vec3 (-1., .0, 0.), 0);\n    Result plane5 = planeIntersect (ray, vec3 (.0, 2.0, 0.), vec3 (.0, -1.0, 0.), 4);\n    Result plane6 = planeIntersect (ray, vec3 (.0, .0, -4.), vec3 (.0, .0, 1.), 2);\n    Result plane7 = planeIntersect (ray, vec3 (.0, .0, 7.), vec3 (1., .0, -1.), 3);\n\n    res = minResult (plane1, plane2);\n    res = minResult (plane3, res);\n    res = minResult (plane4, res);\n    res = minResult (plane5, res);\n    res = minResult (plane6, res);\n    res = minResult (plane7, res);\n\n    res = minResult (ball1, res);\n    res = minResult (ball2, res);\n    res = minResult (ball3, res);\n    res = minResult (ball4, res);\n    res = minResult (ball5, res);\n    res = minResult (ball6, res);\n    res = minResult (ball7, res);\n    res = minResult (light, res);\n\n    return res;\n}\n\nfloat seed = .0;\nfloat rand() { return fract (sin (seed++) * 43758.5453123); }\n\nvec3 cosineDirection (in vec3 n) {\n\tfloat u = rand();\n    float v = rand();\n\n    float a = 6.2831853 * v;\n    u = 2. * u - 1.;\n    return normalize( n + vec3(sqrt(1.-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nvec3 randomSphereDirection () {\n    vec2 r = vec2 (rand () * 6.2831, rand() * 6.2831);\n\tvec3 dr = vec3 (sin (r.x) * vec2 (sin (r.y), cos (r.y)), cos (r.x));\n\treturn dr;\n}\n\nvec3 sampleLight (in vec3 ro) {\n    vec3 n = randomSphereDirection() * lightSize();\n    return lightPos() + n;\n}\n\nvec3 bsdf (in vec3 rd, in Result res) {\n    // specular - brdf - not correct yet\n    if (material[res.id].doesReflect) {\n        vec3 ref = normalize (reflect (rd, res.normal));\n        if (material[res.id].reflAmount < rand ()) {\n\t\t\treturn ref;\n        } else {\n\t\t\treturn cosineDirection (ref);\n        }\n    }\n\n    // transparent - btdf - wip\n    if (material[res.id].doesRefract) {\n        return normalize (refract (rd,\n                                   res.normal,\n                                   material[res.id].ior));\n    }\n\n    // diffuse - brdf\n\treturn cosineDirection (res.normal);\n}\n\nvec3 trace (in Ray ray, in int bounces) {\n    vec3 tcol = vec3 (.0);\n    vec3 fcol = vec3 (1.);\n    bool specBounce = true;\n\n    // create light-paths with bounces segments/depth iteratively\n    for (int i = 0; i < bounces; ++i)\n    {\n        // intersect scene\n        Result res = intersect (ray);\n\n        // hit light-source\n        if (material[res.id].emissive > .0) {\n            //if (specBounce)\n\t            tcol += fcol * material[res.id].diffuse * material[res.id].emissive;\n\n            return tcol;\n        }\n\n        // prepare ray for indirect lighting gathering\n        ray.rd = bsdf (ray.rd, res);\n        ray.ro = res.point + .0001 * ray.rd;\n        specBounce = false;\n\n        fcol *= material[res.id].diffuse;\n\n        // next event estimation\n        vec3 ld = sampleLight (ray.ro) - ray.ro;\n        vec3 nld = normalize (ld);\n        float lSize = lightSize ();\n        vec3 lDir = lightPos () - ray.ro;\n        if (!specBounce && i < bounces - 1 && !intersectShadow (Ray (ray.ro, nld), length (ld))) {\n            float cos_a_max = sqrt (1. - clamp (lSize * lSize / dot (lDir, lDir), 0., 1.));\n            float weight = 2. * (1. - cos_a_max);\n            vec3 lightColor = material[5].emissive * material[5].diffuse;\n            tcol += (fcol * lightColor) * (weight * clamp (dot (nld, res.normal), 0., 1.));\n        }\n    }\n\n    return tcol;\n}\n\nvec3 getColor (in Ray ray) {\n    vec3 col = vec3 (.0);\n\n    for (int i = 0; i < MAX_SAMPLES; ++i) {\n        // accumulate path\n        col += trace (ray, MAX_BOUNCES);\n    }\n    col = col / float (MAX_SAMPLES);\n\n    // apply tonemapping & gamma correction\n    col = col / (1. + col);\n    col = sqrt (col);\n\n    return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    // normalize and aspect-correct UVs\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    // generate primary ray from camera\n    vec3 ro = vec3 (.0, .0, -3.);\n    ro.xz *= r2d (PI * sin (.5*PI*(iMouse.x/iResolution.x * 2. - 1.)));\n    ro.yz *= r2d (.25 * PI * sin (-.5*PI*(iMouse.y/iResolution.y * 2. - 1.)));\n    vec3 lookAt = vec3 (.0);\n    float zoom = 1.75;\n    Ray ray = cameraRay (uv, ro, lookAt, zoom);\n\n    // init seed for the random hemisphere sampling\n    vec2 tmp = uv + vec2 (1. + fract (iTime));\n\tseed = dot (tmp, tmp);\n\n    // pull pixel-value from previous frame and average it with current value\n    vec3 col = getColor (ray);\n    if (iMouse.z <= .0) // only accumulate color when camera is not moved via mouse\n    \tcol += texture (iChannel0, fragCoord / iChannelResolution[0].xy).rgb;\n\n\tfragColor = vec4 (col, 1.);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// pt - a basic pathtracer for learning the fundamentals\n//\n// Copyright 2017-2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// this is just used to introduce some \"state\" for storing the last frame and\n// timestamp when the LMB was released\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    float f = float (iFrame - 1);\n    float t = iTime;\n    if (iMouse.z <= .0) {\n        f = texture (iChannel0, vec2 (.5)).r;\n        t = texture (iChannel0, vec2 (.5)).g;\n    }\n    fragColor = vec4 (f, t, .0, .0);\n}","name":"Buf B","description":"","type":"buffer"}]}