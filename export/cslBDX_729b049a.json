{"ver":"0.1","info":{"id":"cslBDX","date":"1689434026","viewed":56,"name":"Mugen Tsukuyomi (hypnosis)","username":"forestdevil","description":"changed curl to exponent, more meaningful variable names, tweakable predefines, much math involved","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","spiral","spiral","hypnosis"],"hasliked":0,"parentid":"llccWH","parentname":"the tunnel"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _2PI 6.28318530717958\n#define _AA float(2)\n#define _USE_RAINBOW\n#define _RAINBOW float(1.5)\n#define _SPEED1 float(-4)\n#define _SPEED2 float(-5)\n#define _TILT1 float(5)\n#define _TILT2 float(45)\n#define _DISTORT1 vec4(2., 1.4, 1., .35)\n#define _USE_DIM\n#define _DIM float(.05)\n\nfloat swril(vec2 uv, float speed,\n    float tilt,   // tilt angle\n    float parts,  // how many parts\n    vec4 distort, // x: strength, y: size, z: speed, w: size changing range\n    vec2 window   // value limits, x: low, y: high\n    )\n{ \n    float r = length(uv);\n    float theta = atan(uv.y, uv.x);\n    \n    float mask = 1.;\n    if(distort.x > 1.) {\n        speed *= -1.;\n        float dsize = distort.y + sin(iTime * distort.z) * distort.w;\n        r = abs(log(r/dsize) / log(distort.x));\n        float rpeak = -log(dsize) / log(distort.x); // when r == 1, most distored\n        mask = clamp(abs(r - rpeak)*r, 0., 1.);\n    }\n    \n    theta = mod(theta - iTime * speed, _2PI);\n    float b = tan(radians(tilt));\n    float d = exp(_2PI*b);\n    float k = floor(log(r) / _2PI / b);\n    \n    float c = 0.;\n    float delta = _2PI/ parts;   \n    for(float i = 0.; i < parts; i++)\n    {    \n        float gamma = mod(theta + delta * i, _2PI);\n        float low = exp((gamma + k * _2PI) * b);\n        if (r < low) \n        {\n            low /= d;\n        }\n        float high = low * d;\n        c += smoothstep(low, high, r * parts);\n    }\n    return smoothstep(window.x, window.y, c) * mask;\n}\n\nfloat render(vec2 p)\n{\n    vec2 uv = 5. * (p - .5 * iResolution.xy) / iResolution.x;\n    \n    return \n        // layer 1: the slower highly twisted wirl\n        (swril(uv, _SPEED1, _TILT1, 1., _DISTORT1, vec2(0.5, 1)))\n        // layer 2: the 3 faster scanning wirls\n        * (swril(uv, _SPEED2, _TILT2, 3., vec4(0.), vec2(0., 1.))) \n        #ifdef _USE_DIM\n        // layer 3: dim in the center\n        * sin(length(uv) - _DIM)\n        #endif\n        ;\n}\n\nvec3 renderRGB(vec2 p)\n{\n    #ifdef _USE_RAINBOW\n        // rgb rainbow..\n        return vec3(render(p), render(p + _RAINBOW), render(p + _RAINBOW * 2.));\n    #else\n        return vec3(render(p));\n    #endif\n}\n\nvec3 aa(vec2 p)\n{\n    vec3 a = vec3(0.);\n    float step = 1. / _AA;\n    for (float x = -.5; x < .5; x += step)\n        for (float y = -.5; y < .5; y += step)\n            a += renderRGB(p + vec2(x, y));\n    return a / _AA / _AA;\n}\n\n#define _CANVAS_CENTER vec2(0, iResolution.y * .1)\n//#define _USE_TINT_COLOR\n#define _TINT_COLOR vec4(.8, 0, .1, 1)\nvoid mainImage(out vec4 o, in vec2 i)\n{\n    o = vec4(aa(i - _CANVAS_CENTER), 1)\n#ifdef _USE_TINT_COLOR\n        * _TINT_COLOR\n#endif\n        ;\n}\n","name":"Image","description":"","type":"image"}]}