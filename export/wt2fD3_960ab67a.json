{"ver":"0.1","info":{"id":"wt2fD3","date":"1600069916","viewed":332,"name":"FXAA checkerpattern filter","username":"Stephen_epa","description":"FXAA algorithm vertify, practice","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fxaapostprocessing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DIFF_LUM_ABS_HOLD 0.0833 \n#define DIFF_LUM_RES_HOLD 0.166\n\nfloat luminance(vec3 col) {\n    return dot(col, vec3(0.2126729f,  0.7151522f, 0.0721750f));\n}\n\nvec3 FXAA(in sampler2D tex, vec2 uv) {\n    vec3 e = vec3(-1., 1., 0.);\n    vec2 offuv = uv;\n\tvec3 colnw = texture(tex, uv + e.xy / iResolution.xy).rgb;\n    vec3 coln  = texture(tex, uv + e.zy / iResolution.xy).rgb;\n    vec3 colne = texture(tex, uv + e.yy / iResolution.xy).rgb;\n    vec3 colw  = texture(tex, uv + e.xz / iResolution.xy).rgb;\n    vec3 colm  = texture(tex, uv + e.zz / iResolution.xy).rgb;\n    vec3 cole  = texture(tex, uv + e.yz / iResolution.xy).rgb;\n    vec3 colsw = texture(tex, uv + e.xx / iResolution.xy).rgb;\n    vec3 cols  = texture(tex, uv + e.zx / iResolution.xy).rgb;\n    vec3 colse = texture(tex, uv + e.yx / iResolution.xy).rgb;\n    \n    float lnw = luminance(colnw), ln = luminance(coln), lne = luminance(colne),\n          lw  = luminance(colw),  lm = luminance(colm), le  = luminance(cole),\n          lsw = luminance(colsw), ls = luminance(cols), lse = luminance(colse);\n    \n    float maxl = max(ln, max(ls, max(lw, max(le, lm))));\n    float minl = min(ln, min(ls, min(lw, min(le, lm))));\n    float diff = maxl - minl;\n    if (diff < max(DIFF_LUM_ABS_HOLD, DIFF_LUM_RES_HOLD * maxl))\n        return colm;\n    \n    float filterfactor = 0.;\n    filterfactor += 2. * (ln + lw + ls + le) + lnw + lne + lsw + lse;\n    filterfactor /= 12.;\n    filterfactor = abs(filterfactor - lm);\n    filterfactor = clamp(filterfactor / diff, 0., 1.);\n    // hack\n    float blend = smoothstep(0., 1., filterfactor);\n    blend *= blend;\n    \n    \n    float hedge = 2.*(ln + ls - 2.*lm) + (lne + lse - 2.*le) + (lnw + lsw - 2.*lw);\n    float vedge = 2.*(le + lw - 2.*lm) + (lne + lnw - 2.*ln) + (lse + lsw - 2.*ls);\n    \n    float ish = step(vedge, hedge);\n    float psoff = ish >= 1.0 ? 1./iResolution.y : 1./iResolution.x;\n    \n    float pleft = ish >= 1.0 ? ln : le;\n    float pright = ish >= 1.0 ? ls : lw;\n    \n    // opposite dir is more diff\n    if (abs(pleft - lm) < abs(pright - lm))\n        psoff = -psoff;\n    if (ish >= 1.0) {\n        offuv.y += psoff * blend;\n    } else {\n        offuv.x += psoff * blend;\n    }\n    \n    return vec3(textureLod(tex, offuv, 0.).rgb);\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat p = iTime * .3333;\n    float floatx = min(mod(p, 2.), mod(2.-p, 2.));\n    vec3 col = vec3(0.);\n    if (uv.x >= floatx) {\n        col = FXAA(iChannel0, uv);\n    } else {\n        col = texture(iChannel0, uv).rgb;\n    }\n\n    col = mix(col, vec3(0.), step(abs(uv.x - floatx), .001));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define stepsize 50\n#define maxdistant 120.0\n\n// -------------------- sdf stuff ------------------\nfloat sdfSp(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdfBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfPlaneY(vec3 p, float h)\n{\n    return p.y - h;\n}\n// --------------------------------------------end\n\n// scene description\nfloat map(vec3 p) {\n    return sdfPlaneY(p, .1);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\nvoid lookAt(inout vec3 ro, inout vec3 rd, vec3 tg) {\n    vec3 ot = normalize(tg - ro);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 rr = normalize(cross(ot, up));\n    up = normalize(cross(rr, ot));\n    rd = mat3(rr, up, ot) * rd;\n}\n\nfloat march(vec3 o, vec3 d) {\n    float total = 0.;\n    float ep = 0.0001;\n    vec3 np = o;\n    for (int i = 0; i < stepsize; ++i) { \n        float dt = map(np);\n        if (dt <= ep || total > maxdistant) break;\n        np = np + dt * d;\n        total += dt;\n    }\n    if (total >= maxdistant) return maxdistant;\n    return total;\n}\n\nvec3 checkerPattern(vec3 p, float t) {\n    if (t >= maxdistant)\n        return vec3(1.);\n    vec2 uv = p.xz;\n    float col = step(0.0001, mod(floor(uv.x) + floor(uv.y), 2.));\n    return vec3(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n\tvec2 muv = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0., 3.5, 15.);\n    vec3 rd = vec3(uv, 1);\n    rd = normalize(rd);\n    \n    lookAt(ro, rd, vec3(0.));\n    float d = march(ro, rd);\n    vec3 p = ro + d * rd;\n    \n    vec3 col = checkerPattern(p, d);\n    fragColor = vec4(col,0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}