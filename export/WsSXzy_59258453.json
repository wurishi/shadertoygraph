{"ver":"0.1","info":{"id":"WsSXzy","date":"1554323887","viewed":495,"name":"Blackhole raymarch","username":"magician0809","description":"Blackhole raymarch","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//physics constants\n#define _c 2.99792458e8\n#define _c2 8.9875517873681764e16\n#define _G 6.67259e-11\n\n//Gargantua\n#define POS vec3(0)\n#define MASS 1.9891e38\n#define NORM normalize(vec3(0.2,1,-0.1))\n#define ADISK 0.2\n\n//events horizon\n//why it's not 2*G*M/c2 ?\n//I just try G*M/c2 and image is correct.\n//maybe somewhere is wrong.\n\n//#define EVENTS_HORIZON (_G * MASS / _c2)\n#define SCHWARZSCHILD_RADIUS (2.0 * _G * MASS / _c2)\n\n//when DIST is too big, a circle border of Lens appears. It's caused by floating point arithmetic itself.\n//just set mass and light speed lower to fix it.\n#define DIST (SCHWARZSCHILD_RADIUS * 10.0)\n\n#define ITER 128\n\n#define Time (iTime * 0.05)\n\nstruct BlackHole\n{\n    vec3 pos;\n    float mass;\n    vec3 norm;\n    float adisk;\n};\n\nBlackHole GetBlackHole()\n{\n    BlackHole bh;\n    bh.pos = POS;\n    bh.mass = MASS;\n    bh.norm = NORM;\n    bh.adisk = ADISK;\n    return bh;\n}\n\n//draw accretion disk 绘制光环\nvec3 RenderAccretionDisk(BlackHole bh, vec3 ro, vec3 rd)\n{\n    float t = -ro.z / rd.z;\n    vec2 cp = ro.xy + t * rd.xy; //intersection 交点\n    float l = length(cp);\n    float p = _G * bh.mass;\n    //if reach events horizon then break\n    if (l < SCHWARZSCHILD_RADIUS) return vec3(0.0);\n    \n    //float v2 = p / l / _c2; //v2 = g*R = G*M/R, squared spin velocity 公转速度平方\n    float v2 = SCHWARZSCHILD_RADIUS / l;\n    \n    float v = sqrt(v2);\n    vec2 vd = normalize(vec2(cp.y, -cp.x));\n    float f = sqrt(1.0 - v2) / (1.0 - v * dot(vd, rd.xy)); //doppler effect\n    float val = f * smoothstep(bh.adisk, 0.0, abs(bh.adisk * 1.05 - pow(v, 4.0)));\n    \n    //texture\n    vec2 uv;\n    uv.x = atan(cp.y, cp.x) / PI - v * 2.5;\n    uv.y = 0.25 / v + Time;\n    vec3 col = pow(textureLod(iChannel0, uv, 3.0).rgb, vec3(2.2)) * 10.0;\n    \n    return val * mix(col, vec3(1.0), 0.2);\n}\n\n//draw accretion disk 绘制光环\nvec3 RenderAccretionDisk2(BlackHole bh, vec3 ro, vec3 rd)\n{\n    float l = length(ro);\n    float p = _G * bh.mass;\n    //if reach events horizon then break\n    if (l < SCHWARZSCHILD_RADIUS) return vec3(0.0);\n    \n    //float v2 = p / l / _c2; //v2 = g*R = G*M/R, squared spin velocity 公转速度平方\n    float v2 = SCHWARZSCHILD_RADIUS / l;\n    \n    float v = sqrt(v2);\n    vec2 vd = normalize(vec2(ro.y, -ro.x));\n    float f = sqrt(1.0 - v2) / (1.0 - v * dot(vd, rd.xy)); //doppler effect\n    float val = f * smoothstep(bh.adisk, 0.0, abs(bh.adisk * 1.05 - pow(v, 4.0)));\n    \n    //thickness\n    float thickness = 0.25;\n    val *= smoothstep(SCHWARZSCHILD_RADIUS * thickness, 0.0, abs(ro.z)) / thickness;\n    \n    //texture\n    vec2 uv;\n    uv.x = atan(ro.y, ro.x) / PI - v * 2.5;\n    uv.y = 0.25 / v + Time;\n    vec3 col = pow(textureLod(iChannel0, uv, 3.0).rgb, vec3(2.2)) * 400.0;\n    \n    //noise\n    float n = texture(iChannel1, uv).r;\n    col *= n;\n    \n    return col * val / float(ITER);\n}\n\n//raymarch through gravitation field 引力场中的光线追踪\nvec4 Lens(BlackHole bh, inout vec3 ro, inout vec3 rd)\n{\n    //calculate dt (for constant deltapos length, approximative) 计算dt，以近似确保迭代位移大小恒定\n    //equation: dp = dpl * v/c = v * dt = normalize(v' + a * dt) * c * dt\n    /*float aa = _c;\n    float bb = _c2 * (1.0 - dpl / p * _c2);\n    float cc = -_c * dpl;\n    float dd = bb*bb - 4.0 * aa * cc;\n    float dt = (sqrt(dd) - bb) / (2.0 * aa);*/\n    const float dpl = 2.0 * DIST / float(ITER);\n    const float dt = (sqrt(_c2 + 4.0 * dpl) - _c) * 0.5; //let p=0, simplified 简化算式令p=0\n    \n    vec4 res = vec4(0.0);\n    float p = _G * bh.mass;\n    vec4 rot = Rotation2FWD(bh.norm, 1.0);\n    ro = QuatMul(rot, ro - bh.pos);\n    rd = QuatMul(rot, normalize(rd));\n    for (int i = 0; i < ITER; i++)\n    {\n        //distance to center 到中心距离\n        float l = length(ro);\n        \n        //if reach events horizon then break\n        if (l <= SCHWARZSCHILD_RADIUS) {res.a = 1.0; break;}\n        \n        //acceleration, velocity, deltapos 加速度，速度，位移计算\n        //vec3 a = -p / (l*l*l) * ro;\n        vec3 a = -2.0 * p / (l*l*l) * ro;\n        \n        vec3 v = _c * rd + a * dt;\n        rd = normalize(v); //constant light speed\n        v = _c * rd;\n        vec3 dp = v * dt;\n        \n        //hit accretion disk 与吸积盘相交\n        //float d = ro.z * (ro.z + dp.z);\n        //if (d <= 0.0) {res.rgb += RenderAccretionDisk(bh, ro, rd);}\n        res.rgb += RenderAccretionDisk2(bh, ro, rd);\n        \n        ro += dp;\n    }\n    rot = QuatInv(rot);\n    ro = QuatMul(rot, ro) + bh.pos;\n    rd = QuatMul(rot, rd);\n    return res;\n}\n\nCamera GetCamera()\n{\n    Camera cam;\n    cam.target = vec3(0);\n    cam.dist = DIST*(1.0-iMouse.x/iResolution.x);\n    cam.near = 0.001;\n    cam.far = 2.0 * DIST;\n    cam.fov = 60.0;\n    cam.aspect = iResolution.x/iResolution.y;\n    cam.rot = QuatAA(-iMouse.y/iResolution.y * 2.0*PI, vec3(1,0,0));\n    return cam;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera cam = GetCamera();\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 ro, rd;\n    ScreenRay(uv, cam, ro, rd);\n    \n    BlackHole bh = GetBlackHole();\n    vec4 bhc = Lens(bh, ro, rd);\n\n    bhc.rgb = bhc.rgb / (1.0 + bhc.rgb);\n    bhc.rgb = pow(bhc.rgb, vec3(0.45454545)); //linear to gamma\n    \n    fragColor = vec4(bhc.rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n\n//----------------------------------------------Quaternion 四元数算法\n\n//inverse rotation 逆旋转\nvec4 QuatInv(vec4 q)\n{\n    return vec4(q.xyz, -q.w);\n}\n\n//from euler angles 欧拉角四元数 (no z)\nvec4 QuatEA(vec2 eulers)\n{\n    vec2 eh = eulers * 0.5;\n    float c1 = cos(eh.x), c2 = cos(eh.y);\n    float s1 = sin(eh.x), s2 = sin(eh.y);\n    vec4 nq;\n    nq.x = s1 * c2;\n    nq.y = c1 * s2;\n    nq.z = -s1 * s2;\n    nq.w = c1 * c2;\n    return nq;\n}\nvec4 QuatAA(float angle, vec3 axis)\n{\n    angle *= 0.5;\n    float sn = sin(angle);\n    vec4 nq;\n    nq.xyz = axis * sn;\n    nq.w = cos(angle);\n    nq = normalize(nq);\n    return nq;\n}\n\n//quaternion multiply 四元数乘法 (quat * vec3)\nvec3 QuatMul(vec4 lhs, vec3 rhs)\n{\n    float x1 = lhs.x, y1 = lhs.y, z1 = lhs.z, w1 = lhs.w;\n    float x2 = rhs.x, y2 = rhs.y, z2 = rhs.z;\n    float nx = w1 * x2 + y1 * z2 - z1 * y2;\n    float ny = w1 * y2 - x1 * z2 + z1 * x2;\n    float nz = w1 * z2 + x1 * y2 - y1 * x2;\n    float nw = x1 * x2 + y1 * y2 + z1 * z2;\n    vec3 nv;\n    nv.x = nw * x1 + nx * w1 - ny * z1 + nz * y1;\n    nv.y = nw * y1 + nx * z1 + ny * w1 - nz * x1;\n    nv.z = nw * z1 - nx * y1 + ny * x1 + nz * w1;\n    return nv;\n}\n\n//rotation to vec3(0,0,1)\nvec4 Rotation2FWD(vec3 v, float t)\n{\n    v *= t;\n    vec4 nq = vec4(v.y, -v.x, 0.0, v.z + 1.0);\n    nq = normalize(nq);\n    return nq;\n}\n\n//rotate vec3(0,0,1)\nvec3 RotateFWD(vec4 q)\n{\n    vec3 nv;\n    nv.x = 2.0 * (q.x * q.z + q.y * q.w);\n    nv.y = 2.0 * (q.y * q.z - q.x * q.w);\n    nv.z = 1.0 - 2.0 * (q.x * q.x + q.y * q.y);\n    return nv;\n}\n\n\n//---------------------------------------------------Camera 摄像机\nstruct Camera\n{\n    vec3 target; //target position 相机目标位置\n    float dist; //target distance 相机目标距离\n    vec4 rot; //rotation 相机朝向\n    float near; //near clip plane 相机近裁面\n    float far; //far clip plane 相机远裁面\n    float fov; //field of view 视野角度\n    float aspect; //screen w/h 屏幕宽高比\n};\n\n//coordinate transform 坐标转换\n//屏幕空间到相机空间\nvec3 ScreenToCamera(vec2 uv, float ld, Camera cam)\n{\n    vec3 pos;\n    pos.z = mix(cam.near, cam.far, ld);\n    pos.xy = (uv - 0.5) * 2.0;\n    pos.x *= cam.aspect;\n    float t = tan(radians(cam.fov * 0.5));\n    pos.xy *= pos.z * t;\n    return pos;\n}\n//屏幕像素到世界空间射线\nvoid ScreenRay(vec2 uv, Camera cam, out vec3 ro, out vec3 rd)\n{\n    vec3 far = ScreenToCamera(uv, 1.0, cam);\n    vec3 near = cam.near / cam.far * far;\n    vec3 cpos = cam.target - cam.dist * RotateFWD(cam.rot);\n    ro = QuatMul(cam.rot, near) + cpos;\n    rd = QuatMul(cam.rot, far);\n}\n","name":"Common","description":"","type":"common"}]}