{"ver":"0.1","info":{"id":"wlX3Rr","date":"1625280959","viewed":124,"name":"UFO? (Apr 16 2019)","username":"hmaon","description":"old WIP prototype for the \"Party Ship\" 4k intro, released to a collective yawn from the audience at Revision 2019\nIt implements simple raymarched volumetric lighting.\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 7/3/21 - tweaked some raymarching limits for slight performance improvements\n\nvec4 Ls[3];\nvec3 colors[3];\nfloat outer_radius=50.0;\n\nvec3 ufoPos;\n\nconst int NUM_LS=2;\nconst float MAX_DISTANCE=160.0;\n\nconst float PI=3.14159;\nconst float PI2=PI*2.;\nconst float modVal=13.;\nconst float stepbias=0.05;\n\nvec4 bgA=vec4(.1,.2,.9,1.0);\nvec4 bgB=vec4(.1,.5,.1,1.);\n\nvec3 origin;\nvec3 ray;\nfloat fresnel;\nfloat trav;\n\nstruct Detc\n{\n    float d;\n    vec4 c;\n} df;\n\n    \nDetc opU(Detc a,Detc b)\n{\n    if (a.d<=b.d) return a;\n    else return b;\n}\n\nDetc opI(Detc a,Detc b)\n{\n    if (a.d >=b.d) return a;\n    else return b;\n}\n\nDetc opSub(Detc a,Detc b)\n{\n    b.d*=-1.;\n    b.c=a.c;\n    if (a.d >b.d) return a;\n    else return b;\n}\n\n\nvec2 texUV;\n\n// primitives mainly copied from iq's codes\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\nDetc deBox(vec3 p,vec3 b,vec4 col)\n{\n    return Detc(sdBox(p,b),col);\n}\n\nDetc deSphere(vec3 p,float r,vec4 col)\n{\n    return Detc(length(p)-r,col);\n}\n\nDetc deTorus(vec3 p, vec2 t, vec4 col)\n{\n    return Detc(length( vec2(length(p.xy)-t.x,p.z) )-t.y, col);\n}\n\n\n// ping-pong function\nfloat pp(float x,float lim)\n{\n    return abs(mod(x,lim*2.)-lim);\n}\n\n// vec2 ping-pong function!\nvec2 pp(vec2 a,float lim)\n{\n    return abs(mod(a,vec2(lim*2.))-lim);\n}\n    \nDetc mapEtc(in vec3 point);\nfloat map(in vec3 point)\n{\n    return mapEtc(point).d;\n}\n\n// also from iq somewhere\nvec3 rayDirection(float fieldOfView,vec2 size,vec2 fragCoord) {\n    vec2 xy=fragCoord-size / 2.0;\n    float z=size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy,-z));\n}\n\n// so's this, from iq that is\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e=vec2(1.0,-1.0)*0.5773*0.0005;\n\n    return normalize(e.xyy*map(pos+e.xyy)+\n                      e.yyx*map(pos+e.yyx)+\n                      e.yxy*map(pos+e.yxy)+\n                      e.xxx*map(pos+e.xxx));\n}\n\n\nvec3 doLRay(vec3 origin,vec3 normal,int shadowLimit,float absorption)\n{    \n    vec3 diffuse=vec3(0.);\n    \n    for (int i=0; i<NUM_LS; i++)\n    {    \n        \n        vec3 p=origin;\n        vec3 Ldir=(Ls[i].xyz+texture(iChannel0,(p.xy+p.zz)*.005).rgb*.75)-p;\n        float LDD=dot(Ldir,Ldir);\n        float LD=sqrt(LDD); // magnitude of Ldir\n        float lum=Ls[i].a / LDD;\n        Ldir=Ldir / LD; // normalize(Ldir)\n        float nld=dot(normal,Ldir);\n        \n        nld=normal.x<1.5 ? 1. : nld;\n        \n        if (nld >0.99)\n        {             \n            float strav=0.;\n            vec3 ray=Ldir;\n            p+=normal*0.08;\n            for (int j=0; j<=shadowLimit; j++)\n            {\n               float shadowd=map(p);\n\n               p+=ray*(shadowd+stepbias);\n               strav+=shadowd+stepbias;\n                \n               if (strav >LD)\n               {         \n                   diffuse+=colors[i]*nld*lum*mix(1.,1./strav,absorption); \n                   break;\n               }\n\n               if (shadowd<stepbias)\n               {\n                   \n                   break;\n               }\n            }\n        }\n    }    \n    \n    return diffuse;\n}\n\n\n\nvec4 doRay(int limit,int shadowLimit)\n{   \n\n    trav=.0;\n    float d;\n    vec3 diffuse=vec3(0.);\n    vec3 vol=vec3(0.);\n    \n    vec3 p=origin; \n    vec3 prevp=p;\n    float debug=0.;\n        \n    df=Detc(9999.,vec4(0.));\n    \n    for (int i=0; i<=limit;++i) \n    {\n        df=mapEtc(p);\n        d=df.d;\n\n        if (trav >MAX_DISTANCE || i ==limit)\n        {\n            return vec4(sqrt(vol),0.); // sometimes you just have to sqrt() a value for the look\n        }\n        \n        if (d<stepbias)\n        {\n            break;\n        }\n        \n        \n        vol+=doLRay((prevp+p)*.5,vec3(-2.,0.,0.),12,.4)*.2*length(prevp-p); // comment this out for great fps\n        \n        d=min(d,.85);\n                \n        prevp=p;\n        p=p+ray*(d+stepbias);\n        trav+=d+stepbias;\n    }\n    \n    vec3 normal=calcNormal(p);\n    \n    float c1=-dot(normal,ray);\n    vec3 R1=ray+(2.0*normal*c1);\n    fresnel=1.25-.5* abs(c1);\n    origin=p;\n        \n\n    texUV=normal.xz+p.yy*.001;\n    vec4 tex=vec4(1.0);\n    tex*=df.c;\n            \n    vec3 amb=vec3(0.2,0.1,0.1);    \n\n    diffuse=doLRay(p,normal,shadowLimit,0.);\n    \n    ray=R1;\n    \n    vec4 color=vec4(sqrt(vol)+tex.rgb*(amb+diffuse),tex.a);\n    \n    return color;\n}\n\n\nvec4 doFragment(in vec2 fragCoord)\n{\n    origin=vec3(0.0,0.0,1.0);\n    \n    ray=rayDirection(60.0,iResolution.xy,fragCoord);\n\n    vec4 baseColor=doRay(108,24);\n    \n    vec4 reflection=vec4(0.);\n    \n     \n    if (trav<MAX_DISTANCE)\n    {\n        origin+=ray*0.2;\n        reflection=doRay(64,16)*fresnel; // reflections also hit FPS and aren't needed to demonstate the volumetric lighting effect\n    }\n        \n    vec3 c=max(baseColor,(reflection*0.7)*baseColor.a).rgb; // a bit of a hack here\n    return vec4(c,1.0);        \n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    colors[0]=vec3(.1,.2,.9);\n    colors[1]=vec3(.1,.5,.1);\n    colors[2]=vec3(.1,.1,.7);\n    ufoPos=vec3(cos(iTime*.5)*7.,sin(iTime)*3.,-30.);\n    Ls[1]=vec4(ufoPos+vec3(sin(iTime*5.),0.0,cos(iTime*3.))*.3,33.0);\n    \n    Ls[0]=Ls[1]+vec4(cos(iTime)*9., sin(iTime)*9.,cos(iTime*2.3)*9.,0.0);\n    Ls[0].a=6.0;\n   \n    fragColor=doFragment(fragCoord);\n}\n \n\nDetc mapEtc(in vec3 p)\n{    \n    const vec4 red=vec4(1.0,.2,.2,.35);\n    const vec4 green=vec4(.2,1.0,.2,.35);\n    const vec4 blue=vec4(.2,.2,1.0,.35);\n\n    float mt=mod(iTime,PI2);\n    \n    vec3 pos=ufoPos;\n    \n    Detc df=Detc(9999.,vec4(0));    \n    \n    df=opU(df,deSphere(p-pos+vec3(0.,6.,0.),10.,red+green));  // UFO\n    df=opI(df,deSphere(p-pos-vec3(0.,6.,0.),10.,blue+green)); // UFO\n\n    const float r=4.0;\n    const float y=-1.6;\n    const float sr=2.;\n    \n    // portholes?\n    for (int i=0; i<4; i++)\n    {\n        float th=float(i)*PI*.5+mt;\n        df=opSub(df,deSphere(p-pos-vec3(cos(th)*r,y /* +sin(th+iTime*3.22) */,sin(th)*r),sr,red));\n    }\n        \n    df=opSub(df,deSphere(p-pos-vec3(0.,-.55,0.),2.7,red)); // internal cavity\n    \n    df=opSub(df,deSphere(p-pos-vec3(0.,4.,0.),2.3,red)); // top window\n\n    float s=sin(iTime*.3), c=cos(iTime*.3);\n    vec3 ppp = p-Ls[0].rgb;\n    vec3 pppp;    \n    pppp.x = c * ppp.x + s * ppp.y;\n    pppp.y = -s * ppp.x + c * ppp.y;\n    pppp.z = ppp.z;\n    \n    //df=opU(df, deTorus(pppp, vec2(2., .5), green));  // unfinished framerate-killing donut thing\n    \n    return df;\n}","name":"Image","description":"","type":"image"}]}