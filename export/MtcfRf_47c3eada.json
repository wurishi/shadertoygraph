{"ver":"0.1","info":{"id":"MtcfRf","date":"1540572700","viewed":108,"name":"Carnival Entrance","username":"Shadeyboi","description":"Environment Shader #2","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["environment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}    \n    \n    \n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n    \n    \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\n// ============================\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// ============================\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n\n//=======================\n\nShape Hallway(vec3 c){\n  Shape shape;\n    vec4 color = vec4(.65);\n    vec3 r = c;\n    vec3 t = c;\n    vec3 g = c;\n    vec3 cut = c;\n    vec3 s = c;\n    vec3 l = c;\n    \n    c.z = repeat(c.z, 2.);\n    r.z = repeat(r.z, 1.5);\n    t.z = repeat(t.z, 3.);\n    g.z = repeat(g.z, 2.);\n    cut.z = repeat(cut.z, 2.);\n    s.z = repeat(s.z, 2.);\n    l.z = repeat(l.z, 2.);\n    \n    //Columns, connecting bar, and floor\n    c.x = abs(c.x)-.5;\n    vec4 colColor = vec4(1.);\n    float c1 = sdCylinder(c-vec3(1.4, .0, 0.), vec3(.1, 1.1, 0.3)); //Columns\n    float b1 = fBox(c-vec3(1.5, .8, 0.), vec3(.3, 0.1, 1.)); //Connecting Bar\n    float fl = fBox(c-vec3(0., -1., 0.), vec3(1.8, .05, 1.)); //Floor\n    \n    //Column cutouts\n    cut.x = abs(cut.x)-.5;\n    float c2 = sdCylinder(cut-vec3(1.4, 0., -.2), vec3(.1, 1., .1));\n    \n    //Chandelier Hangings\n    g.x = abs(g.x*2.)-.5;\n    g.y -= .3;\n    g.xy *= rot(g.x+radians(75.));\n    vec4 hangColor = vec4(0., 0., 1., 0.);\n    float g1 = fBox(g-vec3(.3, -.5, 0.), vec3(.05, 1.5, .04));\n    \n    //Roof\n    r.xy *= rot(-r.x*.25);\n    vec4 roofC = vec4(1., 0., 0., 1.);\n    float ro = fBox(r-vec3(0., 1.5, 0.), vec3(1.2, .1, .8)); \n    \n    //Side Streamers\n    s.x = abs(s.x)-.54;\n    s.yz *= rot(-s.z+radians(90.));\n    vec4 streamers = vec4(abs(sin(iTime)), 0., cos(iTime), 1.);\n    float s1 = fBox(s-vec3(1.5, 0., .1), vec3(.05, 1.5, .04));\n    \n    //Lights\n    l.x = abs(l.x)-.33;\n    vec4 lColor = vec4(1., 1., 0., 1.);\n    float light = sphere(l-vec3(0., .75, 0.), .1);\n    \n    shape.dist = fOpUnionChamfer(c1, b1, .1);\n    shape.dist = fOpUnionChamfer(ro, shape.dist, .01);\n    shape.dist = fOpUnionChamfer(shape.dist, fl, .2);\n    shape.dist = fOpUnionChamfer(shape.dist, g1, .25);\n    shape.dist = max(shape.dist, -c2);\n    shape.dist = fOpUnionStairs(shape.dist, s1, .2, .2);\n    shape.dist = fOpUnionRound(shape.dist, light, .05);\n    \n    shape.color = color;\n    shape.color = mix(colColor, roofC, mixColors(ro, c1, .01));\n    shape.color = mix(hangColor, shape.color, mix(shape.dist, g1, .6));\n    shape.color = mix(streamers, shape.color, mix(shape.dist, s1, .99));\n    shape.color = mix(lColor, shape.color, mix(shape.dist, light, .999999999));\n    \n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape hall = Hallway(c);\n  return hall;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}