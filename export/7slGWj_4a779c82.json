{"ver":"0.1","info":{"id":"7slGWj","date":"1617384069","viewed":290,"name":"Beat of broken hearts","username":"Hultsborn10","description":"Ett försök att härma grafiken bakom Klara Hammarström i låten Beat of broken hearts, Melodifestivalen 2021","likes":8,"published":1,"flags":64,"usePreview":0,"tags":["melodifestivalen","klarahammarstrm","beatofbrokenhearts"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MlBSRw","filepath":"https://soundcloud.com/noa-edwardsson/we-are-the-ones","previewfilepath":"https://soundcloud.com/noa-edwardsson/we-are-the-ones","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float RAYS = 54.0;\n//https://soundcloud.com/castorcinema/beat-of-broken-hearts-feat\n//https://soundcloud.com/clemenswenners/africa\n//https://soundcloud.com/noa-edwardsson/we-are-the-ones\n//https://soundcloud.com/br-ndon-kucharek/rings-of-saturn-utopia\n//https://soundcloud.com/mukunda-mtandari/smooth-and-sexy-smooth-jazz-for-lovers\n\nfloat R21(vec2 uv)\n{\n    float a = abs(sin(uv.x*1.1));\n    float b = abs(cos(uv.y*104.7));\n    return(a*b);\n}\n\n\n//Avståndet mellan punkten p och linjen från a till b\nfloat DistLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    //Längden av skuggan av ap utmed ab\n    float lShadow = dot(ap, ab);\n    //Längden av ab\n    float lab = dot(ab, ab);\n    //Låt t bli kvoten (andelen) av ab som skuggan utgör\n    //Se till att den inte blir negativ\n    float t = clamp(lShadow/lab, 0.0, 1.0);\n    //Ta fram vektorn från punkten p till toppen av skuggan,\n    vec2 sp = ap - ab*t;\n    //returnera längden av den nya vektorn\n    return length(sp);\n}\n\nfloat GetDist(vec2 uv, vec2 rayP)\n{\n    vec2 origin = vec2(0.0,0.0);\n    float d = DistLine(uv, origin, rayP);\n    float w = 0.05;\n    float wz = 0.01;\n    float c = smoothstep(w/RAYS, w/RAYS+wz, d);\n    /*\n    vec2 top = vec2(0.0, 5.0 );\n    vec2 bottom = vec2(0.0, -5.0);\n    vec2 lef = vec2(-5.0, 0.0);\n    vec2 rig = vec2(5.0, 0.0);\n    float d1 = DistLine(uv, top, bottom);\n    float d2 = DistLine(uv, lef, rig);\n    c = min(d1,d2);\n    */\n    //return smoothstep(0.5, 0.0, c);\n    return c;\n}\n\nvec2 GetRayPoint(float rayNumber, float length)\n{\n    float angle = rayNumber/RAYS*6.28;\n    float x = cos(angle)*length;\n    float y = sin(angle)*length;\n    vec2 p = vec2(x,y);\n    return p;\n}\n\nvec2 Rotate(vec2 uv, float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    float x = c*uv.x + s*uv.y;\n    float y = s*uv.x - c*uv.y;\n    return vec2(x,y);\n}\n\nfloat GetRayNumber(vec2 uv)\n{\n    //Beräkna en vinkel som går från -0.5 till 0.5\n    float angle = (atan(uv.y, uv.x)/6.28);\n    //Multiplicera med antalet strålar\n    float ray = angle*RAYS;\n    return ray;\n}\n\nfloat GetRayWheel(vec2 uv, float freqOffset, float raylength, float rotate)\n{\n    uv = Rotate(uv, rotate);\n    float ray = GetRayNumber(uv);\n    //Raycenter är ett heltal från -antal strålar/2 till +RAYS/2\n    float raycenter = floor(ray);\n    //Ta fram längden på strålen från frekvensspektrat i musiken\n    float frequency = raycenter + RAYS/2.0;\n    if (frequency < 0.1) frequency = RAYS;\n    frequency += freqOffset;\n    float fft = raylength * texelFetch(iChannel0, ivec2(frequency, 0), 0).x;\n    \n    //Beräkna avståndet till de två närmaste strålarna\n    vec2 p = GetRayPoint(raycenter, fft);\n    float d = (1.0-GetDist(uv, p));\n    //Första halva topp-punkten\n    float pSize = 0.99;\n    float pc = smoothstep(pSize, 1.0, 1.0-length(uv-p));\n    //Blinkning till topp-punkten\n    float pcBlink = 0.5 + 0.5*sin(iTime*20.0+raycenter);\n    pc *=pcBlink;\n    \n    raycenter = ceil(ray); \n    frequency = raycenter + RAYS/2.0;\n    if (frequency < 0.1) frequency = RAYS;\n    frequency += freqOffset;\n    //Ta fram längden på strålen från frekvensspektrat i musiken\n    fft = raylength * texelFetch(iChannel0, ivec2(frequency, 0), 0).x;\n    p = GetRayPoint(raycenter, fft);\n    d += (1.0-GetDist(uv, p));\n    float c = d*length(uv);\n    //Blinkning till topp-punkten\n    if ((RAYS/2.0-raycenter)<0.1) raycenter = -raycenter;\n    pcBlink = 0.5 + 0.5*sin(iTime*20.0+raycenter);\n    //Andra halvan av topp-punkten\n    pc += smoothstep(pSize, 1.0, 1.0-length(uv-p))*pcBlink;\n    c *= R21(uv);\n    return 10.0*c+25.0*pc;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5 vertically)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    //uv*=0.5;\n    uv = Rotate(uv,-iTime*0.1);\n    //vec3 col = vec3(0.9, 0.2 , 0.1);//röd-orange\n    vec3 col = 0.3+0.3*vec3(sin(iTime*0.5),sin(iTime*0.4),sin(iTime*0.3));\n    float c = GetRayWheel(uv, 0.0, 1.0, 0.0);\n    //float rotation = 3.14/RAYS;\n    //\n    float rotation = -iTime*0.1;\n    c += 1.4*GetRayWheel(uv, 2.0*RAYS, 0.4, rotation);\n    //\n    rotation = -iTime*0.2;\n    c += 1.4*GetRayWheel(uv, RAYS, 0.75, rotation);\n    col *= c;\n    //en ljus cirkel\n    float d = 1.0-length(uv);\n    vec3 dcol = vec3(0.5, 0.5, 0.1);\n    col += d*dcol;\n    //en vit cirkel\n    d = smoothstep(0.8, 1.0,1.0-length(uv));\n    dcol = vec3(.5);\n    col += d*dcol;\n    //col = d*dcol;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}