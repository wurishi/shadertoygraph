{"ver":"0.1","info":{"id":"DdyXWw","date":"1681420241","viewed":140,"name":"Scattered dice","username":"amgb2","description":"First attempt at a ray marching shader. Finding decent-looking lighting and material parameters is really hard!","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","raymarching","distancefield","sdf","dice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 LOOK_POS = vec3(0.0, 0.0, -50.0);\nconst vec3 LIGHT_DIR = normalize(vec3(3.0, 2.0, 2.0));\nconst vec3 SKY_DIR = normalize(vec3(-1.0, -1.0, 5.0));\nconst vec3 UP = vec3(0.0, 0.0, 1.0);\nconst float FOV = 0.5;\n\nconst int FLOOR = 1;\nconst int DICE_BODY = 2;\nconst int DICE_SPOT = 3;\n\nfloat unitBox(in vec3 p, out vec3 n)\n{\n    // SDF for a single cube of side 2 units centred at the origin\n    vec3 cp = clamp(p, -1.0, 1.0);\n    n = normalize(p - cp);\n    return length(p - cp);\n}\n\nfloat spot(in vec3 p, in vec3 s, out vec3 n)\n{\n    // SDF for a spot at position s\n    // note the return value is positive inside the spot\n    n = normalize(s - p);\n    return SPOT_SIZE - length(p - s);\n}\n\nfloat diceSDF(in vec3 p, out vec3 n, out int material)\n{\n    // SDF for a single dice centred at the origin\n    material = DICE_BODY;\n    vec3 p2 = p / (DICE_SIZE - BEVEL);\n    float res = unitBox(p2, n) - BEVEL;\n    if (res > 0.002) { return res; }\n    float spotRes;\n    vec3 spotN;\n    for (int i = 0; i < NUM_SPOTS; i++) {\n        spotRes = spot(p, spots[i], spotN);\n        if (spotRes > res) {\n            res = spotRes;\n            n = spotN;\n            material = DICE_SPOT;\n        }\n    }\n    return res;\n}\n\nfloat rotatedDiceSDF(in vec3 p, in float sine, in float face, out vec3 n, out int material) {\n    float sphereDist = length(p) - DICE_MAX_RADIUS;\n    if (sphereDist > 0.001) {\n        // early out if we're not very close to the dice\n        return sphereDist;\n    }\n    float cosine = sqrt(1.0 - sine * sine);\n    if (face >= 7.0) {\n        cosine = - cosine;\n    }\n    mat3 transform;\n    int f = int(face) % 6;\n    switch (f) {\n        // this was tedious to work out!\n        case 1:\n            // default transform: rotate around z axis only\n            transform = mat3(cosine, sine, 0.0, -sine, cosine, 0.0, 0.0, 0.0, 1.0);\n            break;\n        case 2:\n            transform = mat3(cosine, 0.0, -sine, -sine, 0.0, -cosine, 0.0, 1.0, 0.0);\n            break;\n        case 3:\n            transform = mat3(0.0, sine, -cosine, 0.0, cosine, sine, 1.0, 0.0, 0.0);\n            break;\n        case 4:\n            transform = mat3(0.0, sine, cosine, 0.0, cosine, -sine, -1.0, 0.0, 0.0);\n            break;\n        case 5:\n            transform = mat3(cosine, 0.0, sine, -sine, 0.0, cosine, 0.0, -1.0, 0.0);\n            break;\n        default:\n            transform = mat3(cosine, -sine, 0.0, -sine, -cosine, 0.0, 0.0, 0.0, -1.0);\n            break;\n    }\n    float result = diceSDF(transform * p, n, material);\n    n = inverse(transform) * n;\n    return result;\n}\n\nfloat sdf(in vec3 pos, out int material, out vec3 normal)\n{\n    ivec2 cell = ivec2(round(pos.xy / POISSON_GRID_SIZE));\n    float best_d = 1000.0;\n    vec3 best_normal;\n    int best_material;\n    for (int dx = -2; dx <= 2; dx++) {\n        for (int dy = -2; dy <= 2; dy++) {\n            // only if there is a dice in this cell\n            ivec2 c = cell + ivec2(dx, dy);\n            vec4 data = texelFetch(iChannel0, emod(c, POISSON_GRID_CELLS), 0);\n            if (data.r > 0.0) {\n                vec3 dicePos = vec3(vec2(c) * POISSON_GRID_SIZE, 0.0);\n                dicePos.x += data.b * POISSON_GRID_SIZE;\n                dicePos.y += data.a * POISSON_GRID_SIZE;\n                vec3 n;\n                int m;\n                float dd = rotatedDiceSDF(pos - dicePos, data.g, data.r, n, m);\n                if (dd < best_d) {\n                    best_d = dd;\n                    best_normal = n;\n                    best_material = m;\n                }\n            }\n        }\n    }\n    normal = best_normal;\n    material = best_material;\n    float fd = pos.z + DICE_SIZE;\n    if (fd < best_d) {\n        material = FLOOR;\n        normal = vec3(0.0, 0.0, 1.0);\n        return fd;\n    }\n    return best_d;\n}\n\nbool isLit(in vec3 pos, in vec3 rd)\n{\n    float dist = 0.0;\n    float mult = 1.0;\n    if (pos.z > DICE_SIZE) {\n        if (rd.z > 0.0) {\n            return true;\n        }\n        float h = pos.z - DICE_SIZE;\n        float sf = h / -rd.z;\n        pos += rd * sf;\n        dist += sf;\n    }\n    while (dist < 1000.0) {\n        int _material;\n        vec3 _normal;\n        float d = sdf(pos, _material, _normal);\n        if (d < 0.001) {\n            return false;\n        }\n        dist += d;\n        pos += rd * d;\n    }\n    return true;\n}\n\n\nvec3 castRay(in vec3 pos, in vec3 rd, out vec3 normal)\n{\n    float dist = 0.0;\n    float mult = 1.0;\n    vec3 add = vec3(0.0);\n    if (pos.z > DICE_SIZE) {\n        if (rd.z > 0.0) {\n            return vec3(0.0);\n        }\n        float h = pos.z - DICE_SIZE;\n        float sf = h / -rd.z;\n        pos += rd * sf;\n        dist += sf;\n    }\n    while (dist < 1000.0) {\n        int material;\n        vec3 normal;\n        float d = sdf(pos, material, normal);\n        if (d < 0.001) {\n            if (material == FLOOR) {\n                float dotP = dot(rd, normal);\n                rd -= 2.0 * dotP * normal;\n                pos += rd * 0.001;\n                mult *= 0.3;\n                if (isLit(pos + normal * 0.001, LIGHT_DIR)) {\n                    add += vec3(0.02);\n                }\n            } else {\n                vec3 albedo = vec3(0.3, 0.0, 0.0);\n                if (material == DICE_SPOT) {\n                    albedo = vec3(0.2);\n                }\n                float intensity = dot(normal, SKY_DIR) * 0.2;\n                float specular = 0.0;\n                if (isLit(pos + normal * 0.001, LIGHT_DIR)) {\n                    float dp = clamp(dot(normal, LIGHT_DIR), 0.0, 1.0);\n                    intensity += dp * 1.5;\n                    specular = clamp(pow(dp, 25.0), 0.0, 1.0);\n                }\n                return (albedo * intensity * (1.0 - specular) + specular) * mult + add;\n            }\n        }\n        dist += d;\n        pos += rd * d;\n    }\n    return add;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = mod(iTime / 15.0, PI * 2.0);\n    vec3 cam_pos = vec3(cos(t)*150.0, sin(t)*100.0, 15.0);\n    vec3 cam_dir = normalize(LOOK_POS - cam_pos);\n    vec3 cam_r = normalize(cross(cam_dir, UP));\n    vec3 cam_u = normalize(cross(cam_r, cam_dir));\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n    vec3 rd = normalize(cam_dir + ((cam_r * uv.x) + (cam_u * uv.y)) * FOV);\n    vec3 normal;\n    vec3 col = castRay(cam_pos, rd, normal);      \n\n    // Gamma correct\n    col = pow(col, vec3(1.0 / 2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// positions of the dice\n// red=0 for no dice, 1-6 for the top face, 7-12 for the top face rotated 180\n// if red>0, green=sin(a) of the rotation matrix\n// if red>0, blue and alpha are the offset from the cell centre\n\nvoid rand4(vec2 n, out float a, out float b, out float c, out float d) {\n    a = fract(SEED + hash1(n) + hash1(float(iFrame)));\n    b = hash1(a);\n    c = hash1(b);\n    d = floor(fract(hash1(c) * 32.0) * 12.0) + 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    if (max(x, y) > POISSON_GRID_CELLS) {\n        return;\n    }\n    vec4 current = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    if (current.r > 0.0 || iFrame > 100) {\n        fragColor = current;\n        return;\n    }\n    int index = (x % 5) * 5 + (y % 5);\n    if ((iFrame * INDEX_STEP) % 25 != index) {\n        fragColor = current;\n        return;\n    }\n    float a, b, c, d;\n    rand4(fragCoord.xy, a, b, c, d);\n    vec3 newPos = (vec3(x, y, 0.0) + vec3(b, c, 0.0)) * POISSON_GRID_SIZE;\n    for (int dx = -2; dx <= 2; dx++) {\n        for (int dy = -2; dy <= 2; dy++) {\n            ivec2 nbCell = ivec2(x+dx, y+dy);\n            vec4 nbData = texelFetch(iChannel0, emod(nbCell, POISSON_GRID_CELLS), 0);\n            if (nbData.r > 0.0) {\n                vec3 nbPos = (vec3(vec2(nbCell), 0.0) + vec3(nbData.b, nbData.a, 0.0)) * POISSON_GRID_SIZE;\n                if (length(nbPos - newPos) < DICE_SEP) {\n                    fragColor = vec4(0.0);\n                    return;\n                }\n            }\n        }\n    }\n    float rot = sin((a - 0.5) * PI);\n    fragColor = vec4(d, rot, b, c);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.141592653;\nconst float SEED = 0.74;\n\nconst float DICE_SIZE = 1.6;\nconst float DICE_MAX_RADIUS = DICE_SIZE * sqrt(3.0);\nconst float DICE_SEP = DICE_SIZE * sqrt(2.0) * 2.0;\nconst float BEVEL = 0.25;\nconst float SPOT_CTR = DICE_SIZE + 0.27;\nconst float SPOT_SIZE = 0.38;\nconst float SPOT_SPC = 0.82;\n\nconst int POISSON_GRID_CELLS = 20;\nconst int POISSON_GRID_COUNT = POISSON_GRID_CELLS * POISSON_GRID_CELLS;\nconst int INDEX_STEP = 67; // must be coprime to grid count\nconst float POISSON_GRID_SIZE = 2.0 * DICE_MAX_RADIUS / sqrt(2.0);\n\n// why does no platform do modulus right?\nint emod(int a, int b) {\n    return (a % b + b) % b;\n}\n\nivec2 emod(ivec2 a, int b) {\n    return ivec2(emod(a.x, b), emod(a.y, b));\n}\n\n// taken from Inigo Quilez's rainforest landscape\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\n// spot positions on the dice\nconst int NUM_SPOTS = 21;\nconst vec3 spots[NUM_SPOTS] = vec3[NUM_SPOTS](\n    // 1 on top (z=1)\n    vec3(0.0, 0.0, SPOT_CTR),\n    // 2 on the far side (y=1)\n    vec3(-SPOT_SPC, SPOT_CTR, SPOT_SPC),\n    vec3(SPOT_SPC, SPOT_CTR, -SPOT_SPC),\n    // 3 on the right (x=1)\n    vec3(SPOT_CTR, SPOT_SPC, -SPOT_SPC),\n    vec3(SPOT_CTR, 0.0, 0.0),\n    vec3(SPOT_CTR, -SPOT_SPC, SPOT_SPC),\n    // 4 on the left (x=-1)\n    vec3(-SPOT_CTR, SPOT_SPC, -SPOT_SPC),\n    vec3(-SPOT_CTR, -SPOT_SPC, SPOT_SPC),\n    vec3(-SPOT_CTR, SPOT_SPC, SPOT_SPC),\n    vec3(-SPOT_CTR, -SPOT_SPC, -SPOT_SPC),\n    // 5 on the near side (y=-1)\n    vec3(-SPOT_SPC, -SPOT_CTR, SPOT_SPC),\n    vec3(SPOT_SPC, -SPOT_CTR, -SPOT_SPC),\n    vec3(0.0, -SPOT_CTR, 0.0),\n    vec3(SPOT_SPC, -SPOT_CTR, SPOT_SPC),\n    vec3(-SPOT_SPC, -SPOT_CTR, -SPOT_SPC),\n    // 6 on the bottom (z=-1)\n    vec3(-SPOT_SPC, SPOT_SPC, -SPOT_CTR),\n    vec3(SPOT_SPC, -SPOT_SPC, -SPOT_CTR),\n    vec3(SPOT_SPC, 0.0, -SPOT_CTR),\n    vec3(-SPOT_SPC, 0.0, -SPOT_CTR),\n    vec3(SPOT_SPC, SPOT_SPC, -SPOT_CTR),\n    vec3(-SPOT_SPC, -SPOT_SPC, -SPOT_CTR)\n    );","name":"Common","description":"","type":"common"}]}