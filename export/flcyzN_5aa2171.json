{"ver":"0.1","info":{"id":"flcyzN","date":"1659450964","viewed":65,"name":"Refresher","username":"wikiemol","description":"Refresher","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHAPE(a, b) scene(a, b)\n#define PI 3.1415926538\n\n\nfloat sphere(vec3 point, vec3 position) {\n    return length(point - position) - 0.5;\n}\n\nfloat prism(vec3 point, vec3 position) {\n    point = point - position;\n    float width = 0.3;\n    float height = 0.3;\n    float depth = 0.3;\n    \n    return max(abs(point.x) - width, max(abs(point.z) - depth, abs(point.y) - height)) - .5;\n}\n\nfloat plane(vec3 point, vec3 position) {\n    point = point - position;\n    return abs(point.y);\n}\n\nfloat scene(vec3 point, vec3 position) {\n    float angle = 2.0 * iTime + clamp(-1.,  1., 0.3 * point.y);\n    mat3 rotXZ = mat3(-sin(angle), 0.0, cos(angle),\n                   0.0, 1.0, 0.0,\n                   cos(angle), 0.0, sin(angle));\n    mat3 rotYZ = mat3(1.0, 0.0, 0.0,\n                   0.0, -sin(angle), cos(angle),\n                   0.0, cos(angle), sin(angle));\n    return min(\n        plane(point, vec3(0., -2.0, 0.)), \n        prism(position + rotXZ * rotYZ * (point -  position), position)\n    );\n}\n\nvec3 normal(vec3 point, vec3 position) {\n    float diff = 0.01;\n    \n    float dist = SHAPE(point, position);\n    float distx = SHAPE(vec3(point.x + diff, point.y, point.z), position);\n    float partialX = (distx - dist)/diff;\n    \n    float disty = SHAPE(vec3(point.x, point.y + diff, point.z), position);\n    float partialY = (disty - dist)/diff;\n\n\n    float distz = SHAPE(vec3(point.x, point.y, point.z + diff), position);\n    float partialZ = (distz - dist)/diff;\n    \n    return normalize(-vec3(partialX, partialY, partialZ));\n\n}\n\n\nstruct MarchResult\n{\n  // Point on the surface\n  vec3 point;\n  // Distance from the surface\n  float distanceFromSurface;\n};\n\nMarchResult march(vec3 lensCoordinate, vec3 shapePos) {\n    vec3 ray = normalize(lensCoordinate);\n    float t = 0.0;\n    float rayDistance = 1. / 0.;\n    for (int i = 0; i < 400; i++) {\n        rayDistance = SHAPE(ray * t, shapePos);\n        t += rayDistance * 0.9;\n    }\n    return MarchResult(ray * t, rayDistance) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0 * (fragCoord/iResolution.xy - 0.5);\n    // Making it so that x is same scale as y\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    float focalLength = 2.0;\n\n    // Considering camera to be origin (0), lens coordinate is \n    // the 3d coordinate on the surface of the lens which is receiving\n    // light.\n    vec3 lensCoordinate = vec3(uv, focalLength);\n    \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n\n    //vec3 shapePos = vec3(cos(iTime), 0.0, sin(iTime) + 2.0);\n    //vec3 shapePos = vec3(cos(iTime), sin(iTime), 5.0 + cos(iTime)*sin(iTime));\n    vec3 shapePos = vec3(0.0, 0.0, focalLength + 4.0);\n\n\n    vec3 lightPos = vec3(3. * cos(iTime), 2. * cos(2. * iTime)*sin(2. * iTime), focalLength + 1.);\n    float diffuseIllum = 6.;\n    float specIllum = 10.;\n\n\n    MarchResult result = march(lensCoordinate, shapePos);\n    if (result.distanceFromSurface < 0.1) {\n        \n        //Basic phong illumination\n        vec3 normal = normalize(normal(result.point, shapePos));\n        vec3 lightRay = result.point - lightPos;\n        vec3 lightReflect = reflect(-lightRay, normal);\n        float invSqr = 1. /(1. * dot(lightRay, lightRay));\n        float diffuse = (0.05 +  smoothstep(0., 1., diffuseIllum * invSqr * 0.3*dot(lightRay, normal)));\n        float specular = smoothstep(0., 1., \n            invSqr \n            * specIllum \n            * 0.3 \n            * pow(dot(normalize(lightReflect), normalize(result.point)), 90.0)\n        );\n        \n        fragColor = vec4(col * (diffuse + specular ),1.0);\n        \n    } else {\n        fragColor = vec4(vec3(0.), 1.0);\n    }\n\n    \n}","name":"Image","description":"","type":"image"}]}