{"ver":"0.1","info":{"id":"7sXGzM","date":"1618436552","viewed":155,"name":"Hidden sphere","username":"Pr0fed","description":"Its been a long time i was doing something.. I'd like to focus on scenes like that. This was done with small effort, i know you can tell that. But i've burned out recently, so i decided to make it in a small steps. Stay safe all.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = ACESFilm(texture(iChannel0, uv).xyz);\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Set it bigger to less noise and accurate render.\n#define MAX_WEIGHT 250.0\n\n#define FAR 150.0\n\n#define SAMPLES 4\n#define MAX_BOUNCES 3\n\n#define PI  3.14159265359\n#define PI2 6.28318530717\n\nconst float GAMMA = 2.2;\n\n///-- Scene Objects -------------------------------------------------------\n\n\n///-- Helper Functions -----------------------------------------------------\n    \nfloat seed = 0.0;\nvec2 UV = vec2(0.0);\n\nfloat random() \n{\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233)) + seed++) * 43758.5453);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x * 8.3e-3 + co.y ) * vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x * 0.3e-3 + co.y ) * vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n\n#define NUM_OCTAVES 2\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s)\n{\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) \n{\n\tvec2 i = floor(p); p -= i; //p *= p*(3. - p*2.);  \n    \n    p *= p*p*(p*p*6. - p*15. + 10.); \n    \n    return dot(mat2(fract(sin(mod(vec4(0, 1, 113, 114) + \n    dot(i, vec2(1, 113)), 6.2831853))*43758.5453)) * \n    vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n}\n\nvec2 path(in float t)\n{ \n    return vec2(3);\n}\n\n// Triangle function.\nvec2 tri(in vec2 x)\n{\n    return abs(x - floor(x) - .5);\n} \n\n// Smooth version.\nvec2 triS(in vec2 x)\n{\n    return cos(x * 6.2831853)*.25 + .25;\n}\n\n// Standard 2D rotation formula.\nmat2 r2(in float a)\n{ \n    float c = cos(a);\n    float s = sin(a); \n    return mat2(c, s, -s, c); \n}\n\n// Height function layers. \nfloat h1(vec2 p)\n{ \n    return dot(tri(p + tri(p.yx * .5 + .35)), vec2(1)); \n}\n\nfloat h1Low(vec2 p)\n{ \n    return dot(triS(p + triS(p.yx * .5 + .25)), vec2(1)); \n}\n\n\n// Terrain height function. Just a few layers.\nfloat h(vec2 p) \n{\n    float ret = 0.;\n    float m = 1.;\n    float a = 1.;\n    float s = 0.;\n    \n    ret += a * h1Low(p / m);\n    p = r2(1.5/3.73)*p;\n    m *= -.375;\n    s += a;\n    a *= .3;\n    \n    \n    for(int i=1; i < 8; i++) \n    {\n        ret += a * h1(p/m);\n        p = r2(0.2187)*p;\n        m *= -.375;\n        s += a;\n        a *= .25;\n    }\n    \n    ret /= s;\n    \n    return ret * 0.25 + ret * ret * ret * .75;\n}\n\n// Surface function.\nfloat surfaceFunc(vec3 q)\n{\n    // Height.\n    float sf = h(q.xz/20.);\n    return (.5 - sf) * 8.;\n}\n\n\n// The distance function. Just some geometric objects and some terrain.\nfloat map(vec3 p)\n{\n    // Wrap everything around the path.\n    p.xy -= path(p.z);\n    \n    // The surface function. Essentially, the bumps we add to the terrain.\n    float sf = surfaceFunc(p);\n    \n    // The terrain, which we're lowering a bit.\n    float terr = p.y + sf;\n\n    // Return the minimum distance.\n    return terr;\n}\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) \n{\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// Main tracing function.\nbool trace(vec3 ro, vec3 rd, out vec3 hitPos, out vec3 normal, out int ID) \n{\n    float closestSoFar = 150.0;\n    float t;\n    float d;\n    bool isHit = false;\n    \n    ID = -1;\n    \n    // First check map.\n    for (int i = 0; i < 200; i++)\n    {\n        d = map(ro + rd * t);\n        \n        if(abs(d) < .001 * (t *.1 + 1.))\n        {\n            hitPos = ro + rd * t;\n            normal = getNormal(hitPos);\n            ID = 2;\n            isHit = true;\n            closestSoFar = t;\n            break;\n        }\n        else if (t > FAR) break;\n        \n        t += d * .55;\n    }\n    \n    vec3 sphereC = vec3(4.0, 0.1, 28.0);\n    float sphereR = 1.63;\n        \n    // Sphere intersection formula.\n    vec3 oc = ro - sphereC;\n    float a = dot(rd, rd);\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sphereR * sphereR;\n    float discriminant = b * b - a * c;\n\n    if (discriminant > 0.0001) \n    {\n        // We only need the closer side of a sphere.\n        float t = (-b - sqrt(discriminant)) / a;\n\n        if (t < 0.001) \n        {\n            t = (-b + sqrt(discriminant)) / a;\n        }\n        \n        if (t > 0.001 && t < closestSoFar) \n        {\n            hitPos = ro + rd * t;\n            normal = (hitPos - sphereC) / sphereR;\n            ID = 1;\n            isHit = true;\n        }\n    }\n\n    return isHit;\n}\n\n// Triplanar blending.\nvec3 tex3D(sampler2D t, in vec3 p)\n{\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n\n    return (tx * tx + ty * ty + tz * tz);\n}\n\n\nvec3 getSceneColor(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 color = vec3(0.0);\n    vec3 hitPos;\n    vec3 normal;\n    int ID;\n    \n    for (int b = 0; b < MAX_BOUNCES; b++) \n    { \n        if(trace(ro, rd, hitPos, normal, ID))\n        {\n            // Sphere.\n            if(ID == 1)\n            {\n                color += vec3(10.0) * vec3(0.513, 0.588, 0.537);\n                break;\n            }\n        \n            // Rocks.\n            else if(ID == 2)\n            {\n                vec3 dir = normal + randomUnitVector() * 1.1;\n                color = pow(texture(iChannel1, hitPos.xz * 0.3).xyz, vec3(4.0));\n                ro = hitPos;\n                rd = dir;\n            }\n        }\n\n        else\n        {\n            if(b == 0)\n            {\n                vec2 seed = uv.xy * 2.0;\t\n                seed = floor(seed * iResolution.x);\n                vec3 rnd = nrand3( seed );\n                float starcolor =  float(pow(rnd.y, 50.0));\n                color = (0.12 * (1.8-uv.y) * vec3(0.113, 0.488, 0.837)) + vec3(starcolor);\n                break;\n            }\n            \n            color *= vec3(0.3);\n            break;\n        }\n    }\n    \n    return color;\n}\n\n///-------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime;\n\n    // Basic normalization.\n    UV = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    // Camera stuff taken from https://www.shadertoy.com/view/ldtSR2.\n    const float fov = 80.0;\n    float halfWidth = tan(radians(fov) * 0.5);\n    float halfHeight = halfWidth / aspect;\n    \n    const float dist = 7.5;\n        \n    vec3 origin = vec3(14.0, 3.0, 35.0);\n    vec3 lookAt = vec3(-8.0, 1.4, 10.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    \n    vec3 w = normalize(origin - lookAt);\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n    \n    vec3 lowerLeft = origin - halfWidth * u - halfHeight * v - w;\n    vec3 horizontal = u * halfWidth * 2.0;\n    vec3 vertical = v * halfHeight * 2.0;\n    \n    vec3 color = vec3(0.0);\n    \n    // We add random amount for a better AA. More samples - smoother.\n    for (int s = 0; s < SAMPLES; s++) \n    {        \n     \tvec3 direction = lowerLeft - origin;\n        direction += horizontal * (pixelSize.x * random() + UV.x);\n        direction += vertical * (pixelSize.y * random() + UV.y);\n        color += getSceneColor(origin, direction, UV);\n    }\n    \n    color /= float(SAMPLES);\n       \n    vec3 previousColor = texture(iChannel0, UV).rgb;\n    \n    float weight = min(float(iFrame + 1), float(MAX_WEIGHT));\n    \n    vec3 newColor = mix(previousColor, color, 1.0 / weight);\n    \n    fragColor = vec4(newColor, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}