{"ver":"0.1","info":{"id":"4tBSWc","date":"1446761784","viewed":327,"name":"PairOfPants","username":"jt","description":"Visualization of the pair-of-pants function\n[url]https://en.wikipedia.org/wiki/Pair_of_pants_(mathematics)[/url]\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","visualization","implicitsurface","pairofpants","cobordism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// PairOfPants-function visualization - written 2015 by Jakob Thomsen\n// (intended to be used to improve SineTree https://www.shadertoy.com/view/MljXDV)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define pi 3.1415926\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nfloat mirror(float v)\n{\n    return abs(2.0 * fract(v * 0.5) - 1.0);\n}\n\nfloat fn(vec3 v)\n{\n    v.xy *= 1.75;\n    v.z = v.z / 2.0 - 0.5;\n    //v.x *= 1.75;\n    //v.z = mirror(v.z) - 1.0;\n    // https://en.wikipedia.org/wiki/Pair_of_pants_(mathematics)\n    // implicit surface formula from http://tube.geogebra.org/m/437815\n    // (NOTE: original formula without abs doesn't run on all systems - thanks again, Fabrice!)\n    //return (1.0+v.z)*(pow(abs(v.x-1.0),2.0)+v.y*v.y-0.5)*(pow(abs(v.x+1.0),2.0)+v.y*v.y-0.5)-v.z*(v.x*v.x+v.y*v.y-0.5);\n    // Compactified formula by FabriceNeyret2\n    float d = dot(v.xy,v.xy);\n    return (1.+v.z) * (d-2.*v.x+.5) * (d+2.*v.x+.5) - v.z*(d-.5);\n}\n\nvec3 nrm(vec3 v)\n{\n    vec3 n;\n    float d = 0.01;\n    n.x = fn(v + vec3(d, 0.0, 0.0)) - fn(v + vec3(-d, 0.0, 0.0));\n    n.y = fn(v + vec3(0.0, d, 0.0)) - fn(v + vec3(0.0, -d, 0.0));\n    n.z = fn(v + vec3(0.0, 0.0, d)) - fn(v + vec3(0.0, 0.0, -d));\n    return normalize(n);\n}\n\nfloat comb(float v, float s)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), s);\n}\n\nvec4 tex(vec3 v)\n{\n    float d = abs(v.z * 20. + sfract(-iTime, 4.) * 5.); \n    vec4 c = vec4(0.5 + 0.5 * nrm(v), 1.0);\n    return exp(-d*d) + c * abs(nrm(v).x);\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float phi = iTime*.1,  C=cos(phi), S=sin(phi);\n\n    vec3 v = vec3(uv, depth);\n    \n    v *= mat3( 0, 1,-1,\n              -1,-1,-1, \n               1,-1,-1 );\n\n    v.zy *=  mat2 (C,S,-S,C); // could be mixed above\n    \n    return v;\n}\n\nvoid mainImage( out vec4 o,  vec2 uv )\n{\n    float t = iTime * 0.1;\n    vec2 R  = iResolution.xy;\n        uv = ( 2. * uv - R)  / R.y;\n\n    vec3 w = vec3(0), v;\n    \n    for(float layer = 0.; layer < 1.; layer += 1./256.) \n        v = camera(uv, 2. * layer - 1.),\n        abs(v.x) < 1. && abs(v.y) < 1. && abs(v.z) < 1. && abs(fn(v)) < .05 ?  w = v : w;\n    \n    // o = tex(w);\n    o = all(equal(w, vec3(0))) ? vec4(0.0) : tex(w); // avoids flashing background\n}\n","name":"Image","description":"","type":"image"}]}