{"ver":"0.1","info":{"id":"4ljXzz","date":"1441116777","viewed":861,"name":"Digital Crystal Tunnel","username":"WilstonOreo","description":"Fiddling with Abstract Corridor","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","trianglenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535898\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 2x2 matrix rotation.\nmat2 rot2(float a){\n    \n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n\nfloat surfFunc(in vec3 p){\n    \n\treturn dot(tri(p*0.75 + tri(p*0.4).yzx), vec3(0.5 + 0.4*clamp(3.0*sin(iTime*0.72+5.21),-1.0,1.0)));\n}\nvec2 path(in float z){ float s = sin(z/24.)*cos(z/3.); return vec2(s*12., -s*6.0); }\n\n// Standard tunnel distance function with some perturbation thrown into the mix. A floor has been \n// worked in also. A tunnel is just a tube with a smoothly shifting center as you traverse lengthwise. \n// The walls of the tube are perturbed by a pretty cheap 3D surface function.\nfloat map(vec3 p){\n\n    // Square tunnel.\n    // For a square tunnel, use the Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5 + 0.1* clamp(60.0*sin(iTime*0.04),-1.0,1.0));\n    float n = 1.- max(tun.x, tun.y) + (0.6-surfFunc(p));\n    return n; \n}\n\n// Surface normal.\nvec3 getNormal(in vec3 p) {\n\t\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\n\t));\n\n}\n\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// I think it's based on a discrete finite difference approximation to the continuous\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \n// which is pretty handy.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values. Almost common sense... almost. :) If anyone \n// could provide links to some useful articles on the function, I'd be greatful.\n//\n// Original usage (I think?) - Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 1.0/(w*w+0.004) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, iTime);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, -0.125);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy *= rot2( -path(lookAt.z).x/32. );\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = 0.0, dt;\n\tfor(int i=0; i<64; i++){\n\t\tdt = map(camPos + rd*t);\n\t\tif( t>150.){ break; } \n\t\tt += dt*0.75;\n\t}\n\t\n    // The final scene color. Initated to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(dt<0.005){\n\t\n\t    t += dt;\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n    \t// Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld)*0.1, 2.0);\n\t   \n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= distlpsp;\n\t    // Light attenuation, based on the distances above.\n\t    float atten = min(1./(distlpsp), 1.);\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.25;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t   \n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n\t   \n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 0.1);\n        \n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.5+0.5; \n    \t\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        //\n        // Glow.\n      \n        // Shading.\n        \n        float gridValue = clamp(4.0*cos(iTime*0.412),-1.0,1.0);\n        \n        sceneCol = atten * vec3( fre*crv*4. ) * vec3(0.1*-gridValue,0.8+0.3 * gridValue,1.0 * - gridValue);\n        \n        // Drawing the lines on the walls. Comment this out and change the first texture to\n        // granite for a granite corridor effect.\n        sceneCol *= clamp((gridValue + 1.0 )*abs(curve(sp, 0.0125)) - gridValue * (1.0 - abs(curve(sp, 0.0125))), .0, 1.);        \n\t   \n\t\n\t}\n\t\n\tfragColor = vec4(clamp(sceneCol, 0., 1.), 1.0);\n\t\n}","name":"","description":"","type":"image"}]}