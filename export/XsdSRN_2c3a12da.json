{"ver":"0.1","info":{"id":"XsdSRN","date":"1458024531","viewed":174,"name":"Cube thingy","username":"sillsm","description":"Spinning cube thing. Using dFdx and dFdy to compute surface normals w.r.t window coordinates.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Max Sills 2016, licensed under the MIT license.\n// Spinning cube thing, alternative to iq normal func, but rough edges.\n//\n// Quaternion rotation around axis, of angle, centered at center.\nvec3 qRotate(vec3 axis, float angle, vec3 center, vec3 point)\n{\naxis = normalize(axis);\nfloat x = axis.x * sin(angle / 2.);\nfloat y = axis.y * sin(angle / 2.);\nfloat z = axis.z * sin(angle / 2.);\nfloat w = cos(angle / 2.);\n\nmat3 rotation = mat3(1. - 2.*y*y - 2.*z*z, 2.*(x*y+w*z), 2.*(x*z-w*y),\n                     2.*(x*y-w*z), 1. - 2.*x*x - 2.*z*z, 2.*(y*z +w*x),\n                     2.*(x*z + w*y), 2.*(y*z-w*x),1. - 2.*x*x - 2.*y*y);\n     \nreturn center + (rotation * (point-center));\n}\n\n// Rounded box minus a sphere with oscilating radius.\nfloat udBox( vec3 p, vec3 b )\n{\n  p = qRotate(vec3(0,1.,1.),iTime,vec3(0.), p);\n  return max(length(max(abs(p)-b,0.0)) - 1., -1.*(length(p) - 2.-.5*abs(cos(iTime))));\n}\n\n\nvec4 trace(vec3 eye, vec3 viewportxy)\t\t\t\t// You -could- do this recursively, but itterative is simpler and safer\n{\n    vec3 p = vec3(0);\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i)\t\t\t\t// We know what direction the pixel is, and we want to know\n    {\t\n        //   the amount t must be to get to it\n        p = viewportxy + (t* normalize(viewportxy-eye));\t\t\t\t// Pick a point along the ray r at a distance t from the origin \n        //float distance = distanceFromEdge(p);   // Let d be the new distance from the circle edge, negative or positive\n        float dist = udBox(p, vec3(1,1,1));\n        //dist = distanceFromEdge(p);\n        t += dist * .9;\t\t\t\t\t// Now change the distance factor t by half the distance we currently are from edge\n    }\n    return vec4(p,t);\t\t\t\t\t\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// Scale pixel coords to 0..1 range instead\n    uv = uv * 2.0 - 1.0;\t\t\t\t\t\t// Now to the -1 to +1 range\n    uv.x *= iResolution.x / iResolution.y;\t\t// Correct for aspect ratio; rescale texcoords horizontally based on it\n    \n    // assuming viewing plane \n    // Image plane is at (0, 0, -2)\n    vec3 viewportxy = vec3(uv , -10.0);\t\t// Direction to the pixel (unit vector, no magnitude)\n    vec3 eye = vec3(0, 0, -15);\t\t\t// Camera origin at 0,0,-3\n    \n    vec4 tr     = trace(eye, viewportxy);\t\t\n    vec3 pos    = normalize(tr.xyz);\n    vec3 ref    = vec3(0.,0.,1.);\n    float t     = tr.w;\n    \n    // Normal computation. Nifty and without ref to distance function.\n    // But super aliased unless using rounded corners.\n    vec3 x = dFdx(tr.xyz);\n    vec3 y = dFdy(tr.xyz);\n    vec3 normal = normalize(cross(x,y));\n    \n    normal = qRotate(vec3(0.,1.,1.),iTime,vec3(0.), normal);\n    normal = abs(normal);\n\n    fragColor = 5.*(1./t)*vec4(normal,0);;\n}","name":"Image","description":"","type":"image"}]}