{"ver":"0.1","info":{"id":"4fdfW4","date":"1733121664","viewed":222,"name":"water surface","username":"Jatpeng","description":"water surface","likes":8,"published":3,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\n// 基础参数配置\nconst float WAVE_LAYERS = 50.0;        // 波浪层数\nconst float MAX_DETAIL = 50.0;         // 最大细节级别\n\nconst float BASE_SCALE = 4.0;          // 基础缩放\n\nconst float DETAIL_FACTOR = 0.64600;   // 细节因子 - 控制涟漪大小\nconst float GEOMETRY_FACTOR = 0.45;    // 几何变形因子\n\nconst float INTENSITY = 0.059451;      // 波数量系数 (0.01-0.09)\nconst float VIEW_ANGLE = -0.990;       // 视角旋转角度 - 影响波浪外观\nconst float SPEED = 1.0;               // 动画速度\n\nconst float MIN_EFFECT = 0.1;          // 最小效果阈值\nconst float HEIGHT_SCALE = 1.50;       // 高度缩放因子\n\n// 2D旋转矩阵\nmat2 rotate2D(float angle) {\n    return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\nvec2 calculateWaveEffect(vec3 position, float scale) {\n    float rippleEffect = 0.0;  // 涟漪效果累积值\n    float waveEffect = 0.0;    // 波浪效果累积值\n    \n    // 循环增加细节，直到达到最大细节级别\n    for(; scale < MAX_DETAIL;) {\n        scale /= DETAIL_FACTOR;  // 增大scale (因为DETAIL_FACTOR < 1.0)\n        \n        // 对xz平面进行旋转，创造不同方向的波纹\n        position.xz *= rotate2D(scale);\n        \n        // 计算涟漪效果\n        rippleEffect += abs(\n            dot(\n                sin(position * scale) / scale,  // 创建缩放的正弦波\n                position - position + 0.6       // 等于常数0.6\n            )\n        );\n        \n        // 计算波浪效果\n        waveEffect += abs(\n            dot(\n                // 在xz平面创建移动的正弦波\n                sin(position.xz * scale * 0.33 + (iTime * SPEED)) / scale,\n                // 使用屏幕分辨率比调整波形\n                iResolution.xy / iResolution.xy\n            )\n        );\n    }\n    \n    return vec2(rippleEffect, waveEffect);\n}\n\n// 计算几何变形\nvec3 calculateGeometry(vec2 fragCoord, float scale, float geometryFactor) {\n    vec3 position = vec3((fragCoord - iResolution.xy / scale) / iResolution.y * geometryFactor, \n                        geometryFactor - scale);\n    \n    // 应用视角变换                    \n    position.yz *= rotate2D(VIEW_ANGLE);\n    position.y *= HEIGHT_SCALE;\n    \n    return position;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 texcoord = fragCoord/iResolution.xy;\n    vec4 baseColor = texture(iChannel1, texcoord);\n    \n    float geometryFactor = 0.0;\n    float finalIntensity = 1.0;\n    float rippleEffect = 0.0;\n    float waveEffect = 0.0;\n    \n    // 主循环生成波浪效果\n    for(int i = 0; i < int(WAVE_LAYERS); i++) {\n        float scale = BASE_SCALE;\n        \n        // 累积几何变形\n        geometryFactor += min(waveEffect, max(MIN_EFFECT, rippleEffect)) * GEOMETRY_FACTOR;\n        \n        // 计算位置\n        vec3 position = calculateGeometry(fragCoord, scale, geometryFactor);\n        \n        // 初始化波浪效果\n        rippleEffect = position.y;\n        waveEffect = position.y;\n        \n        // 计算波浪效果\n        vec2 effects = calculateWaveEffect(position, scale);\n        rippleEffect += effects.x;\n        waveEffect += effects.y;\n        \n        // 累积强度\n        if(waveEffect > INTENSITY * INTENSITY) {\n            finalIntensity += rippleEffect * finalIntensity * INTENSITY;\n        } else {\n            finalIntensity += -exp(-waveEffect * waveEffect) * finalIntensity * INTENSITY;\n        }\n    }\n    \n    // 输出最终颜色\n    fragColor = vec4(vec3(finalIntensity*0.2), 1.0);\n}","name":"Image","description":"","type":"image"}]}