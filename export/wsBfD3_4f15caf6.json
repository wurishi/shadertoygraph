{"ver":"0.1","info":{"id":"wsBfD3","date":"1590964098","viewed":278,"name":"Motes","username":"stb","description":"From the archive. I made this back in 2015 when I was using a different name... not that it matters since I don't think I ever posted it :D\n\nMouse to rotate camera.\n","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","ray","voxels","raycasting","voxel","particles","sprites","casting","pollen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\tMotes\n\t2015-2020 stb (was BeyondTheStatic back then)\n\tUses raycasting to step through cubic cells. Sprites are 2D and always exist inside a cell otherwise\n\tthere would be clipping, or there would neighbors needing to be checked on (not always a bad thing).\n\tTraces forward from the camera and uses adaptive depth control for a speedup.\n\tFor more info on adaptive depth control, see: http://povray.org/documentation/view/3.6.1/258/\n*/\n\n#define iGlobalTime iTime\n\nconst float ADC\t\t= 0.03;\t// adaptive depth control bailout\t0.0 - 1.0\nconst float maxDist\t= 20.;\t// maximim draw distance\t\t\t0.0 - ?.?\n\nfloat rand(vec3 p){ return fract(sin(dot(p, vec3(12.9898, 78.233, 9.4821)))*43758.5453); }\n\nvec3 rand3v(vec3 p) {\n\tmat3 m = mat3(15.2, 27.6, 35.7, 53.1, 75.8, 99.8, 153.2, 170.6, 233.7);\n\treturn fract(sin(m * p) * 43648.23);\n}\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 res\t= iResolution.xy;\n    vec2 uv\t\t= (fragCoord-.5*res) / res.y;\n\tvec2 mPos\t= 3.5 * (iMouse.xy-.5*res) / res.y;\n    \n    mPos += vec2(.2*iTime, 5.+.073*iTime);\n    \n    vec3 camPos\t= vec3(.0, .0, -15.);\n    vec3 rayDir\t= normalize(vec3(uv, .8));\n    \n    camPos.yz = rotate(camPos.yz, mPos.y);\n    camPos.xz = rotate(camPos.xz, mPos.x);\n    rayDir.yz = rotate(rayDir.yz, mPos.y);\n    rayDir.xz = rotate(rayDir.xz, mPos.x);\n    \n    camPos.y += iGlobalTime;\n    \n    vec3 adj, xV, yV, zV, V_;\n    vec3 po\t= sign(rayDir);\n    vec3 V\t= camPos, LV;\n    float dist;\n    \n    // light pos, background\n    vec3 lPos\t= normalize(vec3(.5, -1., .25));\n    vec3 bg\t\t= vec3(.1, .3, 1.) + .06*vec3(1.5, .875, .5)*pow(length(rayDir+lPos)/1., 4.);\n    \n    vec4 RGBA\t= vec4(vec3(0.), 1.);\n    \n    // loop extents should accomodate maxDist\n    for(int i=0; i<150; i++) {\n        dist = length(V-camPos);\n        \n        LV = V;\n        \n        adj = mix(floor(V+po), ceil(V+po), .5-.5*po) - V;\n        \n        xV = adj.x * vec3(1., rayDir.yz/rayDir.x);\n        yV = adj.y * vec3(rayDir.xz/rayDir.y, 1.);\n        zV = adj.z * vec3(rayDir.xy/rayDir.z, 1.);\n\n        V_ = vec3(length(xV)<length(yV) ? xV : yV.xzy);\n    \tV_ = vec3(length(V_)<length(zV) ? V_ : zV);\n        \n        V += V_;\n        if(dist>maxDist || RGBA.a<ADC) break;\n        if(rand(floor((V+LV)/2.))>.5){\n            float pRad = .25*fract(3.141592*rand(floor((V+LV)/2.)));\n            vec3 pOff = 10.*rand3v(floor((V+LV)/2.));\n            pOff = -vec3(sin(iGlobalTime+pOff.x), cos(iGlobalTime+pOff.y), sin(iGlobalTime+pOff.z))*pRad;\n            vec3 pVec = camPos + rayDir * length(floor((V+LV)/2.)+.5-camPos-pOff)+pOff;\n            float circ = length( pVec-floor((V+LV)/2.)-.5 )+.5-pRad*1.25;\n            float alph = float(clamp(smoothstep(0., 1., 2.-4.*circ), 0., 1.));\n            \n            // fake particle lighting\n            //circ += length( pVec-floor((V+LV)/2.)-.5+.2*lPos )+.5-pRad*1.25; \n            circ += 2.*dot( pVec-floor((V+LV)/2.)-.5, lPos );\n            \n            vec3 vCol = (circ/1.+.3) * vec3(.8, 1., .6);\n            RGBA.rgb +=\n                \tRGBA.a * alph\n                \t* mix(vCol, bg, dist/maxDist);\n            RGBA.a *= 1.00001 - alph;\n       \t}\n    }\n    \n    RGBA.rgb += bg * RGBA.a;\n    \n    \n    fragColor = vec4(sqrt(RGBA.rgb), 1.);\n}","name":"Image","description":"","type":"image"}]}