{"ver":"0.1","info":{"id":"3sKGDR","date":"1570012318","viewed":318,"name":"\"FakeSteve\" from Minecraft","username":"rmmcal","description":"Dance Steve!!!! :)  Like for the \"Steve\" xD ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","cartoon","minecraft","steve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/3sKGDR\n//\n// by @rmmcal  2019/10\n\nstruct Hit{\n    vec3 p;               // point when hitted\n\tfloat distanceRadius; // min distance 3d radius hit => all sides <=\n    int id;       \t\t  // id hit\n};\n\nstruct RayHit{\n    vec3 uv;  // TODO: uvtexture\n\tvec3 pos; // current position    \n\tvec3 dir; // current direction\n    vec3 clo; // close \n    vec3 nor; // TODO: normal \n    vec3 refl; // TODO: reflection direction\n    vec3 refr; // TODO: fraction   direction  \n    Hit hit;  // hit object\n    float distanceTotal; // total\n};\n\nHit hit(int id, vec3 p, float distanceRadius )\n{\n    Hit hit;\n    hit.id =  id;\n    hit.p  =  p;\n    hit.distanceRadius = distanceRadius;\n    return hit;\n}    \n\nHit join(Hit hit1, Hit hit2)\n{\n    if (hit1.distanceRadius < hit2.distanceRadius)\n        return hit1;\n    else \n        return hit2;\n    \n}\n\nHit intercept(Hit hit1, Hit hit2)\n{\n    if (hit1.distanceRadius > hit2.distanceRadius)\n        return hit1;\n    else \n        return hit2;    \n}\n\nHit sub(Hit hit1, Hit hit2)\n{\n    float d = max(hit1.distanceRadius,-hit2.distanceRadius);\n    Hit h = hit(hit1.id, hit2.p,d );\n    return h;\n}\n\nvec2 rotate(vec2 v, float angle){\n    float c = cos(angle); \n    float s = sin(angle); \n    return mat2(c, -s, s, c) * v;\n}\n\nfloat loop2(float f, float p){\n\treturn abs(fract(iTime*f+p)*2.-1.)*2.-1.;\n}\n\nfloat sphere(vec3 p, vec3 t, float radius){\n    return length(p-t)-radius; //length(s)\n}\n\nfloat box(vec3 p, vec3 t, vec3 s) { \n    return length(max(abs(p-t)-s,0.0)); \n}\n\nHit mapDistance(vec3 p){\n    Hit h; h.distanceRadius = 1000.;\n    \n    float t = min(1.,iTime*iTime*iTime*iTime*iTime*.001); // dance\n    float t2 = max(0., min(1.,iTime*iTime*(iTime-20.)*.001)); // walk... (20sec)\n    float t2_5 = max(0., min(1.,pow(iTime-100.,3.)*.001)); // jump...  (100sec)\n    float t3 = 1.-max(0., min(1.,pow(iTime-230.,3.)*.001)); // end music... (230secs)\n    float t4i = max(0., min(1.,pow(iTime-240.,3.)*.001)); // end all... (240 secs)\n    float t4 = 1.-t4i; // end ...\n  \tt  *= t3;\n    t2 *= t3;\n    \n    p.x += t2*cos(iTime)*4.;\n    p.xz = rotate(p.xz,loop2(1.,0.)*t);\n    \n    h = hit(10, p, p.y+1.9);\n \n    p.y += (pow(cos(iTime*9.),5.)*1.-.5)*t2_5*t2;\n    \n    vec3 p1 = p; p1.yz = rotate(p.yz,.5+loop2(1.,0.)*t);\n    h = join(h, hit(1, p1, box(p1,vec3(-0.5, -1.,0), vec3(.5,1.0,0.5))));\n    \n   \tvec3 p2 = p; p2.yz = rotate(p.yz,(.5+loop2(1.,.5)+.5)*t);\n    h = join(h, hit(2, p2, box(p2,vec3(0.5, -1.,0), vec3(.5,1.0,0.5))));\n   \n    \n  \tvec3 p3 = p; p3.yz = rotate(p.yz,(-loop2(1.,.4)+0.1)*t);\n    h = join(h, hit(3, p3,box(p3,vec3(0., 1.,0), vec3(1.,1.0,0.5))));\n   \n    p.xz = rotate(p.xz,loop2(1.,0.)*.3*(1.-t)*(t4+.1*t4i));\n\tp.yz = rotate(p.yz,loop2(2.,0.5)*.3*(1.-t)*(t4+.4*t4i));\n   \n    vec3 p4h = p; p4h.yz = rotate(p.yz,(-loop2(1.,.3)+0.1)*t);\n    h = join(h, hit(6, p4h, box(p4h,vec3(0.,2.9,0), vec3(.6,.4,.5))));\n  \n    vec3 p4 = p; p4.yz = rotate(p.yz,(-loop2(1.,.3)+0.1)*t);\n    h = join(h, hit(4, p4, box(p4,vec3(0.,2.5,0), vec3(.6,.5,.5))));\n   \n    vec3 p4e1 = p; p4e1.yz = rotate(p.yz,(-loop2(1.,.3)+0.1)*t);\n    h = join(h, hit(7, p4h, box(p4e1,vec3(-0.3,2.6,0), vec3(.12,.1,.5))));\n\n    vec3 p4e2 = p; p4e2.yz = rotate(p.yz,(-loop2(1.,.3)+0.1)*t);\n    h = join(h, hit(7, p4h, box(p4e2,vec3(0.3,2.6,0), vec3(.12,.1,.5))));\n\n    vec3 p4ey1 = p; p4ey1.yz = rotate(p.yz,(-loop2(1.,.3)+0.1)*t);\n    h = join(h, hit(8, p4h, box(p4ey1,vec3(-0.2,2.6,0), vec3(.12,.1,.5))));\n\n    vec3 p4ey2 = p; p4ey2.yz = rotate(p.yz,(-loop2(1.,.3)+0.1)*t);\n    h = join(h, hit(8, p4h, box(p4ey2,vec3(0.2,2.6,0), vec3(.12,.1,.5))));\n\n    \n    vec3 p4b = p; p4ey2.yz = rotate(p.yz,(-loop2(1.,.3)+0.1)*t);\n    h = join(h, hit(9, p4h, box(p4ey2,vec3(0.,2.4,0), vec3(.12,.1,.5))));\n    h = join(h, hit(9, p4h, box(p4ey2,vec3(0.,2.2,0), vec3(.32,.1,.5))));\n\n  \n    vec3 p5 = p; p5.yz = rotate(p.yz-vec2(1.+t4i,0.),(.5+loop2(1.,0.)*3.)*t4);\n    h = join(h, hit(5, p5, box(p5,vec3(-1.5, 1.,0), vec3(.5,1.0,0.5))));\n    \n    vec3 p6 = p; p6.yz = rotate(p.yz-vec2(1.+t4i,0.),(.5+loop2(1.,0.3)*1.)*t4-3.*t4i);\n    h = join(h, hit(5, p6, box(p6,vec3(1.5, 1.,0), vec3(.5,1.0,0.5))));\n  \n    //h = join(h,  hit(2, p, sphere(p,vec3(-3.,0.,-4), 1.)));\n \t//h = join(h,  hit(9, p, sphere(p,vec3(-.0,0.,-4.), 1.)));\n \t// h = sub(h,  hit(6, p, sphere(p,vec3(-.8), 1.)));\n    return h;\n}\n\nvec3 close3d(RayHit h){ \n    vec2 f = vec2(1.,0.);\n    vec3 d = normalize(h.dir);\n    vec3 p = h.pos;\n\tfloat dx = mapDistance(p - d * f.xyx).distanceRadius ;\n\tfloat dy = mapDistance(p - d * f.yxx).distanceRadius ;\n\tfloat dz = mapDistance(p - d * f.yyx).distanceRadius ;\n\treturn (vec3(dx, dy, dz)) * (h.distanceTotal > 100. ? 0.:1.) ;\n}\n\n// Calculate vector normal to pos\nvec3 normal3d(RayHit h)\n{\n  vec3 pos = h.pos;\n  vec3 eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  float ref;\n  nor.x = mapDistance(pos+eps.xyy).distanceRadius - mapDistance(pos-eps.xyy).distanceRadius;\n  nor.y = mapDistance(pos+eps.yxy).distanceRadius - mapDistance(pos-eps.yxy).distanceRadius;\n  nor.z = mapDistance(pos+eps.yyx).distanceRadius - mapDistance(pos-eps.yyx).distanceRadius;\n  return -normalize(nor);\n}\n\nRayHit raymarching(inout RayHit ray)\n{\n    RayHit nohit;\n    ray.uv = ray.dir;\n    \n    //ray\n    for (int i = 0; i < 200; i++)\n    {        \n      \tHit hit = mapDistance(ray.pos);\n        ray.hit = hit;\n        ray.distanceTotal\t+= hit.distanceRadius;           // total\n        ray.pos \t\t\t+= hit.distanceRadius * ray.dir; // walk point to direction\n        \n        if (hit.distanceRadius < .01) break;\t\t\t\t\t\t// so close... performance otimization...\n        if (hit.distanceRadius > 200.) { ray = nohit; break; }\t// so far..... performance otimization...\n \n    }\n    if (ray.pos.x != 0.){\n        ray.clo = close3d(ray);\n        ray.nor = normal3d(ray);\n        ray.refl = reflect(ray.dir, ray.nor );\n    }\n    \n    return ray;\n}\n\nvec3 getColor(RayHit r){\n    vec3 col = vec3(1.);\n    switch(r.hit.id)\n    {\n        case 0: \n\t\t\tcol = vec3(0.,0.7,0.9); // sky\n       \t\tbreak;\n        case 1: \n\t\t\tcol *= vec3(.1,0.1,0.6); // rigth leg\n       \t\tbreak;\n        case 2: \n\t\t\tcol *= vec3(.1,0.1,0.6); // left leg\n       \t\tbreak;\n        case 3: \n\t\t\tcol *= vec3(0.0,0.6,.6); // body\n       \t\tbreak;\n        case 4: \n\t\t\tcol *= vec3(.8,.65,0.6); // face\n            break;\n        case 5:\n\t\t\tcol *= vec3(.8,.65,0.6); // arms\n            break;\n        case 6:\n\t\t\tcol *= vec3(.18,.15,0.1); // hair\n            break;\n        case 8: \n\t\t\tcol *= vec3(.34,.27,0.72); // yey\n            break;\n        case 9: \n\t\t\tcol *= vec3(.5,.34,0.28); // mouth / nose\n            break;\n        case 10: \n\t\t\tcol *= vec3(.6,.7,0.3); //grass\n            break;\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n\tvec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (uv-.5)*aspectRatio;\n    \n    RayHit r;\n    r.pos = vec3(.0,.0,-20.);\n    r.dir = vec3(p.xy*1.,1.);\n    \n    raymarching(r);\n    \n  \n   \n    vec3 col = getColor(r);\n    //vec3 colr = getColor(rr);\n    \n    \n    // Output to screen  \n    switch(int(mod(float(floor(iTime*.01-.05)), 2.)))\n    {\n        case 0:\n\t\t\tfragColor = vec4(vec3(col),1.0);\n        \tbreak;\n\t\tcase 1:\n\t\t\tfragColor = vec4(vec3(col)*r.clo,1.0);\n\t\t\tbreak;\n        case 2:\n        \tRayHit rr = r;\n            rr.dir = r.refl;\n            rr.pos += r.refl;\n            raymarching(rr); // reflection\n\n\t\t\tfragColor = vec4(getColor(r)*r.clo+getColor(rr)*rr.clo*.2,1.0);\n\t\t\t//fragColor = vec4(getColor(r)*r.clo*max(0.1,r.nor.z)+getColor(rr)*rr.clo*.3,1.0);\n\t\t\tbreak;\n        \n    }\n}","name":"Image","description":"","type":"image"}]}