{"ver":"0.1","info":{"id":"wtcXW4","date":"1582378128","viewed":143,"name":"Yellowish","username":"Ayoub","description":"Inspired by Unity's 2019 splash screen. The deformed shape is ray marched by estimating the distance from all the animated points (Similar to Voronoi noise).","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["unitysplashscreenvoronoiraymarchreflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//returns how far a point is from the scene\nfloat distanceField(vec3 p, vec3 center)\n{\t\n    \n    \tfloat minDist = MAX_DIST;\n    \tfloat t = .0;\n    \tfloat d;\n   \t\tvec3 rp, ap;\n    \n\t\tvec3 tmpc; //temporary center\n   \t\tfloat tmpr; //temporary radius\n    \t//Time factor\n    \tfloat time = iTime * SPEED;\n\t\tvec3 cap;\n    \tfor(int i=1; i < NUM_MAIN_POINTS; i++)\n    \t{\n        \trp = rand3(vec3(5*i));\n        \t\n            ap = (RADIUS/2.0 + 0.05)*(sin(rp * time)) + center;\n            tmpc = ap;\n            tmpr = rp.y * 0.25;\n\n            d = distance(ap,p) - (tmpr);\n            t+=exp(-SMOOTHNESS*d);\n\n            if(d < minDist)\n        \t{\n            \tminDist = d;\n                cap = ap;\n            }\n           \tfor(int j = 1; j < NUM_SECONDARY_POINTS; j++)\n            {\n            \trp = rand3(vec3(10*j));\n                ap = (tmpr/2.0 + 0.05)*(sin(rp * time)) + tmpc;\n                d = distance(ap,p) - (0.1 * rp.y);\n            \n            \tt+=exp(-SMOOTHNESS*d);\n            \n        \t\tif(d < minDist)\n        \t\t{\n            \t\tminDist = d;\n                \tcap = ap;\n            \t}\n    \t\t}\n\n        }\n        float res = (-(1.0/SMOOTHNESS)*log( t ));\n    \treturn res;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 offset = vec3(0.001,.0,.0);\n\tfloat ox = distanceField(p + offset.xyy, CENTER) - distanceField(p - offset.xyy, CENTER) ;\n\tfloat oy = distanceField(p + offset.yxy, CENTER) - distanceField(p - offset.yxy, CENTER) ;\n\tfloat oz = distanceField(p + offset.yyx, CENTER) - distanceField(p - offset.yyx, CENTER) ;\n\n\treturn normalize(vec3(ox, oy, oz)) ;\n}\n\nvec3 SampleLight(Ray r)\n{\n    vec3 res = vec3(0);\n    //Reflections\n\tvec3 refl = 0.2*texture(iChannel0, r.d).xyz;\n\tres += mix(RLC,refl, dot(r.d, RLD));\n    return res;\n}\n\n\nRayHit raymarch(Ray r)\n{\n    //Ray hit\n    RayHit rh;\n    rh.hit  = false;\n    r.col = BG;\n    rh.ray = r;\n    //distance at each iteration\n    float d;\n    //total traveled distance\n    float td = .0;\n    //Current point during the marching\n    vec3 p = r.o;\n    vec3 n;\n    int i;\n    \n    for(int s=0; s <= MAX_STEPS; s++)\n    {\n        d = distanceField(p, CENTER);\n        if(d < HIT)\n        {\n            rh.hit = true;\n            rh.normal = getNormal(p);\n            vec3 ref = reflect(rh.ray.d, rh.normal);\n            Ray rf;\n            rf.o = p;\n            rf .d = ref;\n            rh.ray.col = SampleLight(rf);\n            rh.dist = td;\n            break;\n\n        }\n        //Updating parameters for next iteration\n        td+=d;\n        if(td > MAX_DIST)\n            break;\n        p = r.o + td*r.d;\n        \n    }\n    return rh;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);;\n    \n    //Camera setup\n    Ray r;\n    r.o = vec3(0.1);;\n    r.d = normalize(vec3(uv.x,uv.y,1.0) - r.o);\n    RayHit rh = raymarch(r);\n    \n\tif(rh.hit)\n    {\n     float factor = ComputeFresnellReflectance(rh);\n\t col = vec3(0.5*RLC);\n     col= (1.0-factor)* col + factor *rh.ray.col;\n    }\n\n    //GAMMA\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 100\n#define MAX_DIST 20.0\n\n#define HIT 0.001\n#define SMOOTHNESS 25.\n#define METALIC 0.8\n#define SNELL_INDEX 0.2\n//LIGHT\n#define RLD normalize(CENTER - 20.0*vec3(1.0,0.5,0.5))\n#define RLC vec3(0.9, 0.28, 0.05)\n\n#define BG vec3(0)\n\n#define NUM_MAIN_POINTS 10\n#define NUM_SECONDARY_POINTS 15\n\n#define CENTER vec3(0,0,1.2)\n#define RADIUS 0.4\n\n//Animation speed\n#define SPEED 0.8\n\nstruct Ray\n{\n    vec3 o;//origin\n    vec3 d;//unit direction\n    float n; //Snell's law indice\n    vec3 col;\n};\n\nstruct RayHit\n{\n    bool hit; // Whether the ray hit an object in the scene or not\n    vec3 pos; //Hit position\n    Ray ray;\n    float dist;\n    vec3 normal;\n};\n\n\nvec3 rand3(vec3 co)\n{\n    return vec3(fract(sin(dot(co.xzy ,vec3(96.833,12.9898,78.233))) * 43758.5453),\n                fract(sin(dot(co.yxz ,vec3(12.9898, 17.948,96.833))) * 39698.5673),\n                fract(sin(dot(co.zyx ,vec3(17.948,9.5108,87.833))) * 50698.753));       \n}\n\n//returns a signed distance between a point p and a sphere\nfloat sphere(vec3 p, vec3 c, float r)\n{\n    return (distance(p,c)-r);\n}\n\n//Schlick's approximation\nfloat ComputeFresnellReflectance(const RayHit ri)\n{\n    float R, Ro, cosTheta, c5;\n \n    cosTheta = 1. + dot(ri.normal, ri.ray.d);\n    c5 = cosTheta*cosTheta*cosTheta*cosTheta*cosTheta;\n\n    Ro = (1.0 - SNELL_INDEX) / (1.0 + SNELL_INDEX);\n    Ro *= Ro;\n\n    R = Ro + (1.-Ro)*c5;\n    \n    float o = METALIC + (1.-METALIC)*R;\n    return clamp(o, 0., 1.);\n}\n","name":"Common","description":"","type":"common"}]}