{"ver":"0.1","info":{"id":"wddGDS","date":"1569257286","viewed":211,"name":"Camera Blur butno its abberation","username":"JuliaPoo","description":"i have nothing better to do but procrastinate on actual stuff i need to do.\n\nalso was too lazy to make commons work so here's arnd 3k chars of code duplicated in the 2 buffers\n\nalso bad code. might fix later.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["cube","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv2 = fragCoord/R.xy;\n   \tfloat aberr = length(uv2);\n    float degree = texture(iChannel1, uv2).x/20.;\n    vec2 uv_off = distance(uv2, vec2(.5)) * vec2(aberr,aberr*aberr)*degree * R.x/R.y;\n    fragColor = vec4(1);\n    for(int i = 0; i < 3; i++) {\n        vec2 uv = uv2 + uv_off*(1. - float(i) + .5);\n        vec3 col = texture(iChannel0, uv).xyz;;\n        fragColor[i] = col[i];\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float END = 20.;\nconst float ep = 0.001;\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat cube(vec3 p, float b, float r){\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r){\n \treturn length(p) - r;  \n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\nfloat light(vec3 p){\n    vec3 move = 1.5*vec3(cos(iTime)*sin(iTime), sin(iTime)*sin(iTime), cos(iTime));\n    vec3 p_ = p - move; p_.xy *= rot(iTime * 3.); p_.zy *= rot(iTime * 2.);\n\treturn min(cube(p_, .17, 0.), sphere(p + move, .2)); \n}\n\nfloat obj(vec3 p){\n    vec3 pos = p;\n    pos.xy *= rot(iTime * .3);\n    float cube1 = cube(pos, 1., 0.);\n    pos = p;\n    pos.zy *= rot(iTime * .4);\n    float cube2 = cube(pos, 1., 0.);\n    pos = p;\n    pos.zx *= rot(iTime * .7);\n    float cube3 = cube(pos, 1., 0.);\n\treturn max(max(cube1, cube2), cube3);   \n}\n\nfloat mirror(vec3 p){\n    \n    return cube(p + vec3(0., 3.2, 0.), 2., 0.);\n}\n\nfloat SDscene(vec3 p){\n   \n\tfloat obj = obj(p);\n    float mirror = mirror(p);\n    float light = light(p);\n    float d = min(min(obj, mirror), light);\n    \n    return d;\n}\n\nvec3 SDnormal(vec3 p){\n    \n    //Calculates the normal vector of SDscene\n    \n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z))-SDscene(vec3(p.x-ep,p.y,p.z)),\n    SDscene(vec3(p.x,p.y+ep,p.z))-SDscene(vec3(p.x,p.y-ep,p.z)),\n    SDscene(vec3(p.x,p.y,p.z+ep))-SDscene(vec3(p.x,p.y,p.z-ep))\n    ));\n}\n\nfloat depth(vec3 ro, vec3 rd, float sig, inout float min_l){\n    \n    //Returns depth from ro given raydirection\n    \n    int max=300;\n    vec3 p;\n    \n    float dist=0., d;\n    for (int i=0; i<max; i++){\n        p = ro + dist*rd;\n    \td = SDscene(p)*sig;\n        if (light(p) < min_l){ min_l = light(p);}\n    if (abs(d)<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > END){\n        return END;\n    }\n  }\n}\n\nvoid ray_mirror(inout vec3 ro, inout vec3 rd, inout float d, inout float min_l, inout vec3 col, inout vec3 scale){\n    \n    int Nmax = 20, count = 0;\n    while (count < Nmax){\n        \n        ro += SDnormal(ro)*ep*3.;\n        rd = normalize(reflect(rd, SDnormal(ro)));\n        d = depth(ro, rd, 1., min_l);\n        ro += d*rd;\n       \n        if (abs(mirror(ro)) > ep){break;}\n        \n        count += 1;\n    }\n}\n\nvoid ray_obj(inout vec3 ro, inout vec3 rd, inout float Dglass, inout float d, inout float min_l, inout vec3 col, inout vec3 scale){\n    \n    int Nmax = 20, count = 0, count2 = 0;\n    vec3 p, rd_;\n    while (count < Nmax){\n        \n        //Go into glass\n        rd = normalize(refract(rd, SDnormal(ro), 0.6));\n        ro -= SDnormal(ro) * ep*3.;\n        d = depth(ro, rd, -1., min_l);\n        ro += rd * d;\n    \tDglass += d;\n        \n        //internal refraction\n    \trd_ = refract(rd, -SDnormal(ro), 1.5);\n       \twhile (length(rd_) < 0.0001 && count2 < Nmax){\n            \n            rd = normalize(reflect(rd, -SDnormal(ro)));\n            ro -= SDnormal(ro) * ep*3.;\n            d = depth(ro, rd, -1., min_l);\n            ro += d*rd;\n            \n            Dglass += d;\n            rd_ = refract(rd, -SDnormal(ro), 1.5);\n            count2 += 1;\n        }\n  \n        if (length(rd_) > 0.0001){rd = normalize(rd_);}\n        ro += SDnormal(ro) * ep*3.;\n        d = depth(ro, rd, 1., min_l);\n        ro += rd * d;\n        \n        if (abs(obj(ro)) > ep){break;}\n        \n        //if (mirror(ro) > ep){ break;}\n      \t\n\t\tcount += 1;\n    }\n  \t\n    vec3 tint = vec3(exp(Dglass*-0.3),exp(Dglass*-0.9),exp(Dglass*-0.9));\n    scale *= tint;\n    col += pow(clamp(abs(1./min_l)*0.05, 0., 1.), .7) * scale;\n    Dglass = 0.;\n}\n\n\nvoid fresnel(vec3 ro, vec3 rd, inout float refl, inout float refr){\n \t   \n   \tfloat b = ((1. - 1.5)/(1. + 1.5));\n    float r0 = b*b;\n    refl = r0 + (1. - r0)*pow((1. - abs(dot(SDnormal(ro), normalize(rd)))), 5.);\n    refr = 1.-refl;\n    //refl = .5; refr = .5;\n}\n\nvec3 render(vec2 uv){\n    vec3 col;\n    \n    //Camera\n    float ScreenSize = 4.;\n    float shake = 0.3*sin(.3*iTime);\n    \n    float zoom = 2.5;\n    float k = 0.4;\n    float osc = sin(iTime*.3); //3.5 + 2.*osc*osc\n  \tvec3 ro = 4.*vec3(sin(k*iTime), shake, cos(k*iTime)) + vec3(0.,1.,0.);\n  \tvec3 lookat = vec3(0,0,0);\n    \n    \n  \tvec3 fw = normalize(lookat - ro);\n  \tvec3 r = normalize(cross(vec3(0,1.,0), fw));\n  \tvec3 up = normalize(cross(fw,r));\n  \tvec3 scrC = ro + (zoom)*fw;\n  \tvec3 scrP = scrC + (uv.x*r + uv.y*up) * ScreenSize;\n  \tvec3 rd = normalize(scrP - ro);\n    \n    float Dglass, min_l = END;\n    float d = depth(ro, rd, 1., min_l);\n    ro += d*rd;\n    \n    vec3 ro_, rd_, scale_;\n    float refl, refr;\n    vec3 scale = vec3(1.);\n    int Nmax = 15, count;\n    while (count < Nmax){\n        //hits background\n        if (d > END - ep){\n            col += texture(iChannel0, ro).xyz * scale;\n            col += pow(clamp(abs(1./min_l)*0.05, 0., 1.), 2.) * scale;\n            break;\n        }\n        \n        //hit light\n        else if (light(ro) < ep){\n        \tcol += vec3(1.)*scale;\n            break;\n        }\n\n        //hit obj\n        else if (obj(ro) < ep){\n            fresnel(ro, rd, refl, refr);\n            ro_ = ro; rd_ = rd; scale_ = scale;\n            scale *= refr;\n            scale_ *= refl;\n            ray_obj(ro, rd, Dglass, d, min_l, col, scale);\n            ray_mirror(ro_, rd_, d, min_l, col, scale_);\n        }\n\n        //hit mirror\n        else if (mirror(ro) < ep){\n            ray_mirror(ro, rd, d, min_l, col, scale);\n        }\n        \n        else{d = END;}\n        \n        col += pow(clamp(abs(1./min_l)*0.05, 0., 1.), 2.) * scale;\n        count += 1;\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t\n    //Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5*R)/R.x;\n    vec3 col = render(uv);\n   \tfragColor = vec4(col,1.);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float END = 20.;\nconst float ep = 0.001;\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat cube(vec3 p, float b, float r){\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r){\n \treturn length(p) - r;  \n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\nfloat light(vec3 p){\n    vec3 move = 1.5*vec3(cos(iTime)*sin(iTime), sin(iTime)*sin(iTime), cos(iTime));\n    vec3 p_ = p - move; p_.xy *= rot(iTime * 3.); p_.zy *= rot(iTime * 2.);\n\treturn min(cube(p_, .17, 0.), sphere(p + move, .2)); \n}\n\nfloat obj(vec3 p){\n    vec3 pos = p;\n    pos.xy *= rot(iTime * .3);\n    float cube1 = cube(pos, 1., 0.);\n    pos = p;\n    pos.zy *= rot(iTime * .4);\n    float cube2 = cube(pos, 1., 0.);\n    pos = p;\n    pos.zx *= rot(iTime * .7);\n    float cube3 = cube(pos, 1., 0.);\n\treturn max(max(cube1, cube2), cube3);   \n}\n\nfloat mirror(vec3 p){\n    \n    return cube(p + vec3(0., 3.2, 0.), 2., 0.);\n}\n\nfloat SDscene(vec3 p){\n   \n\tfloat obj = obj(p);\n    float mirror = mirror(p);\n    float light = light(p);\n    float d = min(min(obj, mirror), light);\n    \n    return d;\n}\n\nvec3 SDnormal(vec3 p){\n    \n    //Calculates the normal vector of SDscene\n    \n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z))-SDscene(vec3(p.x-ep,p.y,p.z)),\n    SDscene(vec3(p.x,p.y+ep,p.z))-SDscene(vec3(p.x,p.y-ep,p.z)),\n    SDscene(vec3(p.x,p.y,p.z+ep))-SDscene(vec3(p.x,p.y,p.z-ep))\n    ));\n}\n\nfloat depth(vec3 ro, vec3 rd){\n    \n    //Returns depth from ro given raydirection\n    \n    int max=300;\n    vec3 p;\n    \n    float dist=0., d;\n    for (int i=0; i<max; i++){\n        p = ro + dist*rd;\n    \td = SDscene(p);\n    if (abs(d)<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > END){\n        return END;\n    }\n  }\n}\n\nvec3 render(vec2 uv, float focus){\n    vec3 col;\n    \n    //Camera\n    float ScreenSize = 4.;\n    float shake = 0.3*sin(.3*iTime);\n    \n    float zoom = 2.5;\n    float k = 0.4;\n    float osc = sin(iTime*.3); //3.5 + 2.*osc*osc\n  \tvec3 ro = 4.*vec3(sin(k*iTime), shake, cos(k*iTime)) + vec3(0.,1.,0.);\n  \tvec3 lookat = vec3(0,0,0);\n    \n    \n  \tvec3 fw = normalize(lookat - ro);\n  \tvec3 r = normalize(cross(vec3(0,1.,0), fw));\n  \tvec3 up = normalize(cross(fw,r));\n  \tvec3 scrC = ro + (zoom)*fw;\n  \tvec3 scrP = scrC + (uv.x*r + uv.y*up) * ScreenSize;\n  \tvec3 rd = normalize(scrP - ro);\n    \n    float d = depth(ro, rd);\n    \n    return vec3((d - focus)/END);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5*R)/R.x;\n    \n    float focus = 2.;\n    vec3 col = render(uv, focus);\n   \tfragColor = vec4(col,1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}