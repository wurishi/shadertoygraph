{"ver":"0.1","info":{"id":"mlc3Rs","date":"1682933289","viewed":88,"name":"Cube Tunnel Variation 2","username":"gam0022","description":"Another Variation of https://www.shadertoy.com/view/dlcGRs","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Cube Tunnel Variation \" by gam0022. https://shadertoy.com/view/dlc3Rs\n// 2023-05-01 09:23:36\n\nfloat beat, beatTau;\nvec3 target;\n\n#define time iTime\n#define PI acos(-1.)\n#define TAU (PI * 2.)\n#define saturate(x) clamp(x, 0., 1.)\n#define SOL 0.\n#define VOL 1.\n\nfloat phase(float x) { return floor(x) + 0.5 + 0.5 * cos(TAU * 0.5 * exp(-5.0 * fract(x))); }\n\nvoid rot(inout vec2 p, float t) { p = mat2(cos(t), sin(t), -sin(t), cos(t)) * p; }\n\nvec3 pal(float x) { return mix(saturate(sin((vec3(0.333, 0.6666, 0) + x) * TAU)), vec3(1), 0.1); }\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nvoid U(inout vec4 m, float d, float a, float b, float c) { m = d < m.x ? vec4(d, a, b, c) : m; }\n\n\n\nvec4 map(vec3 p) {\n    vec3 pos = p;\n    // rot(p.xy, 0.2 * pos.z);\n    vec4 m = vec4(1, VOL, 0, 0);\n    vec3 a = vec3(14, 12, 12);\n    p = mod(p, a) - 0.5 * a;\n    vec3 of = vec3(3, 1, 1);\n    vec3 ro = vec3(0.8 + 0.05 * sin(phase(time) * 0.2 * TAU), 0.4, 0.4);\n    p -= of;\n    for (int i = 0; i < 5; i++) {\n        p = abs(p + of) - of;\n        rot(p.zy, TAU * ro.x);\n        rot(p.xz, TAU * ro.y);\n        rot(p.yx, TAU * ro.z);\n    }\n\n    U(m, sdBox(p, vec3(1, 1, 1)), SOL, 0.5, 1.);\n    float hue = 0.3;\n    float emi = saturate(cos(TAU * (pos.z / 8. + time)));\n    U(m, sdBox(p, vec3(0.1, 1.1, 1.1)), VOL, hue, emi);\n    U(m, sdBox(p, vec3(1.1, 1.1, 0.1)), VOL, hue + 0.5, emi);\n\n    vec3 p2 = pos - target;\n    of = vec3(0.3, 0.1, 0.1);\n    ro = vec3(0.3 + 0.1 * sin(phase(time) * 0.2 * TAU), 0.5, 0.4 + 0.05 * sin(phase(time)));\n    p2 -= of;\n    for (int i = 0; i < 3; i++) {\n        p2 = abs(p2 + of) - of;\n        rot(p2.zy, TAU * ro.x);\n        rot(p2.xz, TAU * ro.y);\n        rot(p2.yx, TAU * ro.z);\n    }\n\n    // U(m, length(p2 - target) - 1, VOL, 0.3, 1);\n    emi = 1.;\n    float s = 0.2;\n    U(m, sdBox(p2, s * vec3(1)), SOL, 0.5, 1.);\n    U(m, sdBox(p2, s * vec3(0.1, 1.1, 1.1)), VOL, 0.3 + beat / 8., emi);\n    U(m, sdBox(p2, s * vec3(1.1, 1.1, 0.1)), VOL, 0.8 + beat / 8., emi);\n\n    return m;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float bpm = 120.;\n    beat = time * bpm / 60.;\n    beatTau = TAU * beat;\n    target = vec3(0, 0, time * 10.);\n\n    vec3 col = vec3(0);\n    vec3 ro, ray;\n\n    if (mod(beat, 32.) < 4.) {\n        ro = vec3(0, 0, time * 10. - 5.);\n        ray = vec3(uv, 1);\n        // rot(ray.xy, time);\n    } else {\n        ro = target + vec3(5. * cos(beatTau / 32.), 2. * sin(beatTau / 16.), 5. * sin(beatTau / 32.));\n        vec3 up = vec3(0, 1, 0);\n        vec3 fwd = normalize(target - ro);\n        vec3 right = normalize(cross(up, fwd));\n        up = normalize(cross(fwd, right));\n        ray = normalize(right * uv.x + up * uv.y + fwd);\n    }\n\n    float t = 0.;\n    for (int i = 0; i < 300; i++) {\n        vec3 p = ro + t * ray;\n        vec4 m = map(p);\n        float d = m.x;\n        if (m.y == SOL) {\n            if (d < 0.001) {\n                col += vec3(1) * float(i) * 0.01;\n                break;\n            }\n            t += 0.5 * d;\n        } else {\n            col += clamp(pal(m.z) * m.w * 0.01 / abs(d), 0.0, 0.3);\n            t += 0.25 * abs(d) + 0.01;\n        }\n    }\n\n    col = mix(vec3(0), col, exp(-0.1 * t));\n\n    col = saturate(col);\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}