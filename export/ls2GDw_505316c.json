{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Define all the things!\n//==RAY MARCHING CONSTANTS=========================================================\n#define EPSILON .015\n#define MAX_VIEW_STEPS 64\n#define MAX_SHADOW_STEPS 32\n#define OCCLUSION_SAMPLES 4.0\n#define OCCLUSION_FACTOR 1.75\n#define MAX_DEPTH 10.0\n#define FEATURE_BUMP_FACTOR .03\n#define GROUND_BUMP_FACTOR .03\n#define SMIN_FACTOR 48.15\n\n//==OBJECT CONSTANTS========================================================\n#define GROUND_NORMAL vec3(0.0, 1.0, 0.0)\n#define GROUND_HEIGHT 1.0\n\n#define TREE_PROP vec3(0., 0.1, .1)\n#define TREE_REP vec3(1.0, 0.0, 2.0)\n\n#define TREE_SNOW_PROP vec3(-.015, 0.0965, .0825)\n#define TREE_SNOW_REP vec3(1.0, 0.0, 2.0)\n\n#define SNOW_BOTTOM vec3(-0.1,-1.0, 0.1)\n#define SNOW_TOP vec3(0.005, -.0, 0.1)\n#define SNOW_RAD .1\n\n#define SNOW_BUMP iChannel0\n#define TREE_BUMP iChannel1\n#define TREE_SNOW_BUMP iChannel2\n\n#define TREE_TEX_SCALE .4\n#define SNOW_TEX_SCALE .35\n#define TREE_SNOW_TEX_SCALE .45\n\n#define LIGHT_SPREAD .2\n#define LIGHT_COLOR vec4(1.0, 1.0, .95, 1.0)\n#define LIGHT_BRIGHT 0.667\n#define AMBIENT_COLOR vec4(.6, .6, 1.0, 1.0)\n#define AMBIENT_LIGHT .0125\n#define PEN_FACTOR 5.0\n\n//==RENDERING STRUCTURES===========================================================\n/*\n\tA structure for a spotlight.\n*/\nstruct SpotLight\n{\n\tvec3 position, direction;\n\tvec4 color;\n\tfloat brightness;\n\tfloat spread;\n\tfloat penumbraFactor;\n} light;\n\n//==CAMERA FUNCTIONS================================================================\n/*\n\tTEKF https://www.shadertoy.com/view/XdsGDB\n\tSet up a camera looking at the scene.\n\torigin - camera is positioned relative to, and looking at, this point\n\tdist - how far camera is from origin\n\trotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n\tzoom - the relative length of the lens\n*/\nvoid camPolar( out vec3 pos, out vec3 dir, in vec3 origin, in vec2 rotation, in float dist, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = cos(rotation);\n\tvec4 s;\n\ts.xy = sin(rotation);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tdir.xy = fragCoord.xy - iResolution.xy*.5;\n\tdir.z = iResolution.y*zoom;\n\tdir = normalize(dir);\n\t\n\t// rotate ray\n\tdir.yz = dir.yz*c.x + dir.zy*s.zx;\n\tdir.xz = dir.xz*c.y + dir.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - dist*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n//==TEXTURING FUNCTIONS=============================================================\n/*\n\tBy Reinder. Takes a 3D coordinate, and returns a texel based on which plane(s)\n\tit lies in.\n*/\nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler )\n{\n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.zx )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n\n//==ASSORTED MATH STUFFS============================================================\n/*\n\tReturns a smoothed minumum between two values. (By Inigo Quilez)\n*/\nfloat smin( float a, float b, float k )\n{ \n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n//==DISTANCE FUNCTIONS==============================================================\n// aka the Inigo Quilez section\n/*\n\tReturns the distance to the surface of a plane with the given height and normal.\n\tThis is signed as well; if you are below the plane you will get negative values.\n*/\nfloat distPlaneBump(vec3 samplePos, vec3 planeNormal, float planeHeight, sampler2D image, float scale)\n{\n\tfloat bump = 0.0;\n\tfloat dist = dot(samplePos, normalize(planeNormal)) + planeHeight;\n\tif(dist < GROUND_BUMP_FACTOR*2.0)\n\t\tbump = texture(image, samplePos.xz*scale).r*GROUND_BUMP_FACTOR;\n\treturn (dist-GROUND_BUMP_FACTOR)+bump;\n}\n\n/*\n\tReturns the distance to a repeated cylinder, with no image based surface displacement.\n*/\nfloat distCylinder( vec3 pos, vec3 properties )\n{\n\tpos.xz += sin(pos.zx)*.25;\n\tpos.xz = mod(pos.xz,TREE_REP.xz);\n\tpos.xz -= vec2(TREE_REP.xz*.5);\n\t\n\treturn length(pos.xz-properties.xy)-properties.z;\n}\n\n/*\n\tReturns the distance to a repeated cylinder, with image based surface displacement.\n*/\nfloat distCylinderBump( vec3 pos, vec3 properties, sampler2D image, float scale)\n{\n\t// Add in a bit of positional variation.\n\tpos.xz += sin(pos.zx)*.25;\n\t\n\t// Mod the position along the XZ plane for repetition.\n\tpos.xz = mod(pos.xz,TREE_REP.xz);\n\t\n\t// Bring the location back to the center of the modded domain.\n\tpos.xz -= vec2(TREE_REP.xz*.5);\n\t\n\t// Create a variable to store potential bump.\n\tfloat bump = 0.0;\n\t\n\t// Find the distance from the point to the object\n\t// accounting for minimum bump height.\n\tfloat dist = length(pos.xz-properties.xy)-properties.z;\n\t\n\t// If it's less than the maximum bump height we need to figure\n\t// out the specific distance to the object including proper bump.\n\tif(dist < FEATURE_BUMP_FACTOR*2.0)\n\t{\n\t\t// Get a general okay flat-surface normal.\n\t\tvec2 normal = normalize(pos.xz-properties.xy);\n\t\t\n\t\t// Get the bumpheight by sampling the red channel of a texture.\n\t\tbump = tex3D(pos*scale+pos, vec3(normal.x, 0.0, normal.y), image).r*FEATURE_BUMP_FACTOR;\n\t}\n\treturn dist-bump;\n}\n\n/*\n\tReturns the distance to a repeated capsule shape.\n*/\nfloat distCapsule(vec3 pos, vec3 a, vec3 b, float r, sampler2D image, float scale)\n{\n\tpos.xz += sin(pos.zx)*.25;\n\tpos.xz = mod(pos.xz,TREE_REP.xz);\n\tpos.xz -= vec2(TREE_REP.xz*.5);\n\t\n    vec3 pa = (pos) - a;\n\tvec3 ba = b - a;\n    float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );\n\t\n\tfloat bump = 0.0;\n\tfloat dist = length( pa - ba*h ) - r;\n\tif(dist < FEATURE_BUMP_FACTOR)\n\t{\n\t\tvec2 normal = normalize(pos.xy);\n\t\tvec3(normal.x, 0.0, normal.y);\n\t\tbump = tex3D(pos*scale, vec3(normal.x, 0.0, normal.y), image).r*FEATURE_BUMP_FACTOR*.5;\n\t}\n\treturn dist + bump;\n}\n\n/*\n\tReturns the distance to the nearest snow feature, whether it's the ground, the\n\ttree collection, or the windswept bits.\n*/\nfloat distSnow(vec3 pos)\n{\n\treturn min(smin(distPlaneBump(pos, GROUND_NORMAL, GROUND_HEIGHT, SNOW_BUMP, SNOW_TEX_SCALE), \n\t\t\t\t\t   distCapsule(pos, SNOW_BOTTOM, SNOW_TOP, SNOW_RAD, SNOW_BUMP, SNOW_TEX_SCALE), SMIN_FACTOR), \n\t\t\tdistCylinderBump(pos, TREE_SNOW_PROP, TREE_SNOW_BUMP, SNOW_TEX_SCALE));\n}\n\n/*\n\tReturns the distance to the nearest tree.\n*/\nfloat distTree(vec3 pos)\n{\n\treturn distCylinderBump(pos, TREE_PROP, TREE_BUMP, TREE_TEX_SCALE);\n}\n\n/*\n\tReturns the base normal of a repeated cylinder.\n*/\nvec3 getCylinderNormal(vec3 pos, vec3 properties)\n{\n\t// Perform modulation to keep in line with our cylinder distance function.\n\tpos.xz = mod(pos.xz,TREE_REP.xz);\n\tpos.xz -= vec2(TREE_REP.xz*.5);\n\t\n\t// Since we can assume that the cylinder is vertical,\n\t// the only coordinates that matter are x and z.\n\t// This speeds up normal generation quite a bit.\n\tvec2 normal = normalize(pos.xz-properties.xy);\n\treturn vec3(normal.x, 0.0, normal.y);\n}\n\n/*\n\tReturns the distance to the nearest point in the scene.\n*/\nfloat getDist(vec3 samplePos)\n{\n\t\t\n\treturn min(distTree(samplePos),\n\t\t\t   distSnow(samplePos));\n}\n\n/*\n\tReturns the color of the nearest object in the scene.\n*/\nvec4 getColor(vec3 samplePos)\n{\n\t// If we are closer to snow, return the color of the snow.\n\tif(distSnow(samplePos) < distTree(samplePos))\n\t{\n\t\treturn vec4(1.0);\n\t}\n\t// Otherwise return our \"wood\" texture.\n\telse return tex3D(samplePos*4.0, getCylinderNormal(samplePos, TREE_PROP), iChannel0)*vec4(.75, .75, .85, 1.0);\n}\n\n//==RAY MARCHING FUNCTIONS=========================================================\n/*\n\t\tMarches the 3D point <pos> along the given direction.\n\tWhen the point is either stepped the maximum number of times,\n\thas passed the maximum distance, or is within a set distance\n\tfrom geometry the function returns. \n\t\tNote that the position is passed by reference and is modified\n\tfor use within the function.\n*/\nvoid marchThroughField(inout vec3 pos, vec3 dir)\n{\n\tfloat dist;\n\t\n\tfor(int i = 0; i < MAX_VIEW_STEPS; i++)\n\t{\n\t\tdist = getDist(pos);\n\t\tif(dist < EPSILON || dist > MAX_DEPTH)\n\t\t\treturn;\n\t\telse\t\n\t\t\tpos += dir*dist*.75;\n\t}\n\treturn;\n}\n\n//==LIGHTING FUNCTIONS==============================================================\n/*\n\tReturns the surface normal of a point in the distance function.\n*/\nvec3 getNormal(vec3 pos)\n{\n\tfloat d=getDist(pos);\n\t// Create the normal vector by comparing the distance near our point.\n\treturn normalize(vec3( getDist(pos+vec3(EPSILON,0,0))-d, getDist(pos+vec3(0,EPSILON,0))-d, getDist(pos+vec3(0,0,EPSILON))-d ));\n}\n\n/*\n\tReturns the amount of fog in a scene at the given distance.\n*/\nvec4 addFog(float dist, vec4 before, vec4 fogColor)\n{\n\treturn mix(before, fogColor, pow((dist/MAX_DEPTH),2.0));\n}\nvec4 addFog( \tin float dist, // camera to point distance\n\t\t\t\tin vec4  before,      // original color of the pixel\n               \tin vec3  camPos,   // camera position\n               \tin vec3  rayDir )  // camera to point vector\n{\n\tfloat b = 1.4, c = .01;\n    float fogAmount = c * exp(-camPos.y*b) * (1.0-exp( -dist*rayDir.y*b ))/rayDir.y;\n    vec4  fogColor  = AMBIENT_COLOR;\n    return mix( before, fogColor, fogAmount );\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tWritten from Inigo Quilez' algorithm.\n*/\nfloat calcOcclusion(vec3 pos, vec3 surfaceNormal)\n{\n\tfloat result = 0.0;\n\tvec3 normalPos = pos;\n\tfor(float i = 0.0; i < OCCLUSION_SAMPLES; i+=1.0)\n\t{\n\t\tnormalPos += surfaceNormal * (1.0/OCCLUSION_SAMPLES);\n\t\tresult += (1.0/exp2(i)) * (i/OCCLUSION_SAMPLES)-getDist(normalPos);\n\t}\n\treturn 1.0-(OCCLUSION_FACTOR*result);\n}\n\n/*\n\tCalculates how much light remains if shadows are considered.\n\tGenerally IQ's soft shadow algorithm.\n*/\nfloat calcShadow( vec3 samplePos, vec3 lightDir, SpotLight light)\n{\t\n\tfloat dist, originDist;\n\tfloat result = 1.0;\n\tfloat lightDist = length(light.position-samplePos);\n\t\n\tvec3 pos = samplePos+(lightDir*(EPSILON+FEATURE_BUMP_FACTOR));\n\t\n\tfor(int i = 0; i < MAX_SHADOW_STEPS; i++)\n\t{\n\t\tdist = getDist(pos);\n\t\tpos+=lightDir*dist;\n\t\toriginDist = length(pos-samplePos);\n\t\tif(dist < EPSILON)\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\t\tif(originDist >= lightDist || originDist >= MAX_DEPTH)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\tif( originDist < lightDist )\n\t\t{\n\t\t\tresult = min( result, lightDist*light.penumbraFactor*dist / originDist );\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n\tReturns the product of the Phong lighting equation on a point in space given\n\ta (SPOT) light and the surface's material.\n*/\nvec4 calcLighting(vec3 samplePos, vec3 eye)\n{\n\tfloat lightDist = length(light.position-samplePos);\n\tvec3 lightDir = normalize(light.position-samplePos);\n\tvec3 eyeDir = normalize(samplePos-eye);\n\tvec3 surfaceNormal = getNormal(samplePos);\n\tvec3 reflection = normalize(reflect(eyeDir, surfaceNormal));\n\t\n\tfloat specular, diffuse, ambient = AMBIENT_LIGHT;\n\tfloat attenuation, shadow, occlusion;\n\t\n\tfloat spotCos = dot(-lightDir, light.direction);\n\tfloat spotCoefficient = smoothstep( 1.0-light.spread, 1.0, spotCos );\n\t\n\t// If it's outside of the light's cone we don't need to calculate any terms.\n\tif(spotCos < 1.0-light.spread)\n\t{\n\t\tspecular = 0.0;\n\t\tdiffuse = 0.0;\n\t\tattenuation = 0.0;\n\t\tshadow = 0.0;\n\t}\n\telse\n\t{\n\t\tspecular = pow(max( 0.0, dot(lightDir, reflection)*spotCoefficient), 80.0);\n\t\tdiffuse = max( 0.0, dot(lightDir, surfaceNormal)*spotCoefficient);\n\t\tattenuation = min(1.0, (1.0/(lightDist/light.brightness)));\n\t\tshadow = calcShadow(samplePos, lightDir, light);\n\t}\n\tocclusion = calcOcclusion(samplePos, surfaceNormal);\n\tvec4 objectColor = getColor(samplePos);\n\treturn light.color*objectColor*clamp(((specular+diffuse)*shadow*attenuation), 0.0, 1.0)+(ambient*occlusion*AMBIENT_COLOR*objectColor);\n}\n\n/*\n\tShade a point after it has been marched and found.\n*/\nvec4 shade(vec3 pos, vec3 dir, vec3 eye)\n{\n\tfloat dist = length(eye-pos);\n\treturn addFog(dist, calcLighting(pos, eye), eye, dir);\n}\n\t\t\t\t\t\t\t\t\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 pos, dir, eye;\n\t\n\tvec2 facing = (iMouse.yx/iResolution.yx)-vec2(.5);\n\tvec3 camPos = vec3(0.0, .025*abs(sin(iTime*5.0)), iTime-.5);\n\tvec3 lightPos = vec3(0.0, .025*abs(sin(iTime*5.0))-.01, iTime);\n\tvec3 lightDir = normalize(vec3(sin(facing.y), sin(facing.x)*2.0, cos(facing.y)));\n\tfacing.x = -facing.x;\n\t\n\tlight = SpotLight(lightPos,\n\t\t\t\t\tlightDir, \n\t\t\t\t\tLIGHT_COLOR, \n\t\t\t\t\tLIGHT_BRIGHT, LIGHT_SPREAD, PEN_FACTOR);\t\t\t\t   \n\t\n\tcamPolar(pos, dir, camPos, facing, .05, 1.0, fragCoord);\n\teye = vec3(pos);\n\t\n\tmarchThroughField(pos, dir);\n\t\n\tfragColor = shade(pos, dir, eye);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls2GDw","date":"1389615058","viewed":2756,"name":"Snowy Woods","username":"Hamneggs","description":"My first scenic shader :) Use the mouse to look around a bit.","likes":50,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fog","bumpmapping","trees","snow","imagebaseddisplacement","somber","halcyon","cubemapfog","scenic"],"hasliked":0,"parentid":"","parentname":""}}