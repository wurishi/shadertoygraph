{"ver":"0.1","info":{"id":"wslyz7","date":"1584477260","viewed":75,"name":"CS180 stuff","username":"ajnambiar","description":"project","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Using functions of primitive SDFs found at https://iquilezles.org/articles/distfunctions\n\n// Basic scene creation (Raymarching algorithm and lighting/shadow work) using https://www.shadertoy.com/view/wdXGDr\n\n\n\n\n// This function returns the mapping of distance function to find the nearest object at point (pos) \n// for use in the raymarching algorithm. This is where the bulk of the project is being done in terms of modeling. \nfloat map( in vec3 pos )\n{\n    float res = 0.0;\n    float cut = sdBox(pos-vec3(2.2,0.,0.), vec3(1.05,.5,.5));\n    \n    float engine = sdCylinder(pos, vec3(.2 ,0.,0), vec3(1.19 ,0.,0), 0.15 );\n    engine = min(engine, sdCylinder(pos-vec3(0,-.1,.2), vec3(.5 ,0.,0), vec3(1.13 ,0.,0), 0.1 ));\n    engine = min(engine, sdCylinder(pos-vec3(0,-.1,-.2), vec3(.5 ,0.,0), vec3(1.13 ,0.,0), 0.1 ));\n    engine = min(engine, sdCylinder(pos-vec3(0,.1,.2), vec3(.5 ,0.,0), vec3(1.13 ,0.,0), 0.1 ));\n    engine = min(engine, sdCylinder(pos-vec3(0,.1,-.2), vec3(.5 ,0.,0), vec3(1.13 ,0.,0), 0.1 ));\n    vec3 q = pos - vec3(.98 ,.25,0);\n    vec4 w = opElongate( q, vec3(0.1,0.,0.1) );\n    engine = min( engine, w.w+sdTorus( w.zxy, vec2(0.05,0.005) ) );\n    //engine = min(engine, sdTorus((pos-vec3(1.2,0.5,-0.3)).zxy,vec2(.1,.01)));\n    engine = min(engine,sdSolidAngle(-(pos - vec3(1.4,0,0)).zxy, vec2(2.5,4)/5.0, 0.3 ));\n    engine = min(engine,sdSolidAngle(-(pos - vec3(1.3,0.1,0.2)).zxy, vec2(1.5,4)/5.0, 0.25 ));\n    engine = min(engine,sdSolidAngle(-(pos - vec3(1.3,-0.1,0.2)).zxy, vec2(1.5,4)/5.0, 0.25 ));\n    engine = min(engine,sdSolidAngle(-(pos - vec3(1.3,0.1,-0.2)).zxy, vec2(1.5,4)/5.0, 0.25 ));\n    engine = min(engine,sdSolidAngle(-(pos - vec3(1.3,-0.1,-0.2)).zxy, vec2(1.5,4)/5.0, 0.25 ));\n\n\n    \n    \n    float body = sdRoundCone(pos, vec3(-1.35,0,0),vec3(.7,0,0), .09,.35 );\n    \n    cut = sdBox(pos-vec3(2.05,0.,0.), vec3(1.05,.5,.5));\n    float capsule = opSubtraction(cut, sdEllipsoid(pos-vec3(.6, .0,0),vec3(.7, .4,.4)));\n    \n    body = min(body, capsule);\n    body = smin(body, engine, 50.);\n    //body = min(body, sdCylinder(pos - vec3(-.6,0,0),vec3(0.5,0,0),vec3(1.0,0,0),5.0));\n    \n    float wings = sdRhombus(pos, 1.0, .6, .03,.15);\n    wings = smin(wings, sdRhombus(pos-vec3(.5,0,0), .5, .8, .04 ,.15),50.);\n    \n\n    res = smin(wings, body, 50.);\n    return res;\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n \n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n     // camera movement\t\n\tfloat an = 0.5*(iTime);\n\tvec3 ro = vec3(2.0*cos(an) , 1,1.0*sin(an)-.5);\n    vec3 ta = vec3( 0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\t\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\t\n        \n        // raymarch\n        const float tmax = 10.;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// List of SDFs being used to build the overall model\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}","name":"Common","description":"","type":"common"}]}