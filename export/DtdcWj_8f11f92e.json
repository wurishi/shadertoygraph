{"ver":"0.1","info":{"id":"DtdcWj","date":"1699655196","viewed":23,"name":"tpp125","username":"dinel123","description":".\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 c;   \n    float r;  \n    int i;    \n};\n\nstruct Plane {\n    vec3 n;     \n    vec3 p;   \n    int i;    \n};\nstruct Box {\n    vec3 min;   \n    vec3 max;   \n    int i;\n     \n};\nstruct Cylinder {\n    vec3 center;   \n    float radius;   \n    float height;   \n    int i;   \n};\nstruct Ellipsoid {\n    vec3 center;  \n    vec3 radii;  \n    int i;        \n};\n\nstruct Hit {\n    float t;  \n    vec3 n;    \n    int i;      \n};\n\nstruct Ray {\n    vec3 o;     \n    vec3 d;     \n};\n\nstruct Material\n{   vec3 kd;   \n    vec3 ka;   \n    \n    vec3 ks;   \n    float shininess;   \n      \n};\n\nfloat Checkers(in vec2 p) {\n     \n    vec2 w = fwidth(p) + 0.001;\n     \n    vec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n   \n    return 0.5 - 0.5 * i.x * i.y;\n}\n\nvec3 Hemisphere(int seed, vec3 n) {\n    float a = fract(sin(176.19 * float(seed)));   \n    float b = fract(sin(164.19 * float(seed)));\n\n    float u =  2.0 * 3.1415 * a;   \n    float v = acos(2.0 * b - 1.0);   \n\n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v));   \n    if (dot(d, n) < 0.0) {\n        d = -d;   \n    }\n\n    return d;\n}\n\nvec3 Point(Ray ray, float t) {\n    return ray.o + t * ray.d;\n}\n\nvec3 UniformTexture(vec3 color) {\n    return color;\n}\nRay homothetieRay(Ray ray, float rapport){\n    ray.d=(1.005+rapport*0.005*(cos(iTime)))*ray.d;\n    return ray;\n} \nvec3 ConcentricTexture(vec3 p, vec3 center, vec3 color1, vec3 color2, float bandWidth) {\n    float distance = length(p - center);\n    float pattern = sin(distance / bandWidth);\n    return mix(color1, color2, (pattern + 1.0) / 2.0);\n}\n\nvec3 RadialTexture(vec3 p, vec3 axis, vec3 color1, vec3 color2, float bandWidth) {\n  \n    vec3 projection = dot(p, axis) * axis;\n    float distance = length(p - projection);\n    float pattern = sin(distance / bandWidth);\n    return mix(color1, color2, (pattern + 1.0) / 2.0);\n}\n\nvec3 ambient = vec3(0.1, 0.1, 0.1);\nvec3 diffuse = vec3(0.20, 0.3, 0.3);\nvec3 specular = vec3(1.0, 1.0, 1.0);\nfloat shininess = 5.0;\n\n\nMaterial Texture(vec3 p, int i) {\n    Material mat;\n    \n     \n    float checkerSize = 1.0;\n    vec3 concentricCenter = vec3(0.0);\n    float concentricBandWidth = 1.0;\n    vec3 radialAxis = vec3(0.0, 1.0, 0.0);\n    float radialBandWidth = 1.0;\n\n    if (i == 0) {\n         \n        float f = Checkers(p.xy * checkerSize);\n        vec3 color = mix(vec3(1.0), vec3(0.0), f); \n        mat.kd = color;\n    } else if (i == 1) {\n         \n        mat.kd = vec3(1.0, 0.5, 0.0); \n    } else if (i == 2) {\n        \n       mat.kd = vec3(1.0, 0.0, 0.0);\n    } else if (i == 3) {\n         \n        mat.kd = RadialTexture(p, radialAxis, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), radialBandWidth);\n    } else {\n \n        mat.kd = vec3(0.5);\n    }\n    \n     \n    mat.ka = ambient;\n    mat.ks = specular;\n    mat.shininess = shininess;\n \n    return mat;\n}\nRay translateRay(Ray ray, vec3 offset) {\n    ray.o += offset*cos(iTime);\n    return ray;\n}\nbool IntersectSphere(Ray ray, Sphere sph, out Hit x) {\n \n    vec3 oc = ray.o - sph.c;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.r * sph.r;\n    float d = b * b - c;\n     ray = translateRay(ray,vec3(0.,0.,1.));\n    if (d > 0.0) {\n        float t = -b - sqrt(d);\n        if (t > 0.0) {\n            vec3 p = Point(ray, t);\n            x = Hit(t, normalize(p - sph.c), sph.i);\n\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectPlane(Ray ray, Plane pl, out Hit x) {\n    float t = -dot(ray.o - pl.p, pl.n) / dot(ray.d, pl.n);\n    if (t > 0.0) {\n        x = Hit(t, vec3(0, 0, 1), 0);\n        return true;\n    }\n    return false;\n}\nRay RotateRay(Ray ray, float angle, vec3 axis) {\n     \n    axis = normalize(axis);\n\n    \n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    mat3 rotationMatrix = mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.x * axis.z + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n\n     \n    ray.d = rotationMatrix * ray.d;\n\n    \n    ray.o = rotationMatrix * (ray.o - axis) + axis; \n\n    return ray;\n}\nbool IntersectBox(Ray ray, Box box, out Hit x) {\n    float tMin = (box.min.x - ray.o.x) / ray.d.x;\n    float tMax = (box.max.x - ray.o.x) / ray.d.x;\n    const vec3 rotationAxis = vec3(1.0, 0.0, 0.0);  \n    float rotationAngle = iTime;  \n\n \n  \n     ray = translateRay(ray,vec3(0.,0.,1.));\n    if (tMin > tMax) {\n        float temp = tMin;\n        tMin = tMax;\n        tMax = temp;\n    }\n\n    float tyMin = (box.min.y - ray.o.y) / ray.d.y;\n    float tyMax = (box.max.y - ray.o.y) / ray.d.y;\n\n    if (tyMin > tyMax) {\n        float temp = tyMin;\n        tyMin = tyMax;\n        tyMax = temp;\n    }\n\n    if ((tMin > tyMax) || (tyMin > tMax)) {\n        return false;\n    }\n\n    if (tyMin > tMin) {\n        tMin = tyMin;\n    }\n\n    if (tyMax < tMax) {\n        tMax = tyMax;\n    }\n\n    float tzMin = (box.min.z - ray.o.z) / ray.d.z;\n    float tzMax = (box.max.z - ray.o.z) / ray.d.z;\n\n    if (tzMin > tzMax) {\n        float temp = tzMin;\n        tzMin = tzMax;\n        tzMax = temp;\n    }\n\n    if ((tMin > tzMax) || (tzMin > tMax)) {\n        return false;\n    }\n\n    if (tzMin > tMin) {\n        tMin = tzMin;\n    }\n\n    if (tzMax < tMax) {\n        tMax = tzMax;\n    }\n\n    if (tMin < 0.0) {\n        tMin = tMax;\n        if (tMin < 0.0) {\n            return false;\n        }\n    }\n    \n    vec3 intersectionPoint = Point(ray, tMin);\n    vec3 normal;\n\n    if (tMin == (box.min.x - ray.o.x) / ray.d.x) {\n        normal = vec3(-1.0, 0.0, 0.0);\n    } else if (tMin == (box.max.x - ray.o.x) / ray.d.x) {\n        normal = vec3(1.0, 0.0, 0.0);\n    } else if (tMin == (box.min.y - ray.o.y) / ray.d.y) {\n        normal = vec3(0.0, -1.0, 0.0);\n    } else if (tMin == (box.max.y - ray.o.y) / ray.d.y) {\n        normal = vec3(0.0, 1.0, 0.0);\n    } else if (tMin == (box.min.z - ray.o.z) / ray.d.z) {\n        normal = vec3(0.0, 0.0, -1.0);\n    } else {\n        normal = vec3(0.0, 0.0, 1.0);\n    }\n\n    x = Hit(tMin, normal, box.i);\n    return true;\n}\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x) {\n    const vec3 rotationAxis = vec3(1.0, 0.0, 0.0);  \n    float rotationAngle = iTime;  \n\n     \n    ray = RotateRay(ray, rotationAngle, rotationAxis);\n\n    vec3 oc = ray.o - ellipsoid.center;\n    vec3 invRadii = 1.0 / ellipsoid.radii;\n    oc *= invRadii;\n    vec3 d = ray.d * invRadii;\n      ray = translateRay(ray,vec3(0.,0.,1.));\n    float a = dot(d, d);\n    float b = 2.0 * dot(oc, d);\n    float c = dot(oc, oc) - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        float t = min(t1, t2);\n\n        if (t > 0.0) {\n            vec3 p = Point(ray, t);\n            x = Hit(t, normalize(p - ellipsoid.center), ellipsoid.i);\n            return true;\n        }\n    }\n\n    return false;\n    \n}\nfloat IntersecterCylindre(vec3 pos, vec3 dir, vec3 center, float radius, float height) {\n    float a = dot(dir.xz, dir.xz);\n    float b = 2.0 * dot(dir.xz, pos.xz - center.xz);\n    float c = dot(pos.xz - center.xz, pos.xz - center.xz) - radius * radius;\n  \n    float delta = b * b - 4.0 * a * c;\n    if (delta < 0.0) {\n        return -1.0;\n    }\n    \n    float t1 = (-b - sqrt(delta)) / (2.0 * a);\n    float t2 = (-b + sqrt(delta)) / (2.0 * a);\n\n    float y1 = pos.y + t1 * dir.y;\n    float y2 = pos.y + t2 * dir.y;\n\n    if (y1 >= center.y && y1 <= center.y + height && t1 > 0.0) {\n        return t1;\n    } else if (y2 >= center.y && y2 <= center.y + height && t2 > 0.0) {\n        return t2;\n    }\n\n    return -1.0;\n}\n\nvec3 NormaleCylindre(vec3 p, vec3 center) {\n    vec3 n = normalize(p - center);\n    n.y = 0.0;\n    return n;\n}\n\nbool Intersect(Ray ray, out Hit x) {\n    // Sphères\n     const Sphere sph3 = Sphere(vec3(0.0, 0.0, 1.0), 0.50, 1);\n    const Sphere sph4 = Sphere(vec3(0.0, 1.950, 1.0), 0.50, 1);\n    const Sphere sph1 = Sphere(vec3(0.0, 5.0, 1.0), 1.0, 1);\n     const Cylinder cy1 = Cylinder(vec3(0.0, 0.0, 1.0), 0.5, 2.0, 1);\n    const Sphere sph2 = Sphere(vec3(2.0, 0.0, 2.0), 1.0, 2);\n    const Plane pl = Plane(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -10.0), 0);\n    const Box box = Box(vec3(-1.0, -1.0, 0.5), vec3(1.0, 1.0, 2.5), 2);\n    const Ellipsoid ellipsoid = Ellipsoid(vec3(5.0, 7.0, 1.0), vec3(4, 2, 1), 2); // Exemple d'ellipsoïde\n    const Cylinder cyl1 = Cylinder(vec3(1.0, 3.0, 5.0), 0.5, 2.0, 1);\n    x = Hit(1000.0, vec3(0), -1);\n    Hit current;\n    bool ret = false;\n     if (IntersectSphere(ray, sph3, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectSphere(ray, sph4, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if (IntersectSphere(homothetieRay(ray,0.5), sph1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectSphere(ray, sph2, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectPlane(ray, pl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n     if (IntersectBox(ray, box, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectEllipsoid(ray, ellipsoid, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n   float tCylinder = IntersecterCylindre(ray.o, ray.d, cyl1.center, cyl1.radius, cyl1.height);\n    if (tCylinder > 0.0 && tCylinder < x.t) {\n        x = Hit(tCylinder, NormaleCylindre(Point(ray, tCylinder), cyl1.center), cyl1.i);\n        ret = true;\n        \n    }   float ptCylinder = IntersecterCylindre(ray.o, ray.d, cy1.center, cy1.radius, cy1.height);\n    if (ptCylinder > 0.0 && tCylinder < x.t) {\n        x = Hit(tCylinder, NormaleCylindre(Point(ray, tCylinder), cyl1.center), cyl1.i);\n        ret = true;\n    }\n\n\n    if (IntersectPlane(ray, pl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    return ret;\n}\n\nvec3 Background(vec3 rd) {\n    return mix(vec3(0.8, 0.8, 0.9), vec3(0.7, 0.7, 0.8), rd.z);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 Color(Material mat, vec3 n,vec3 p, vec3 v, vec3 l) {\n    \n    Hit osef;\n   \n    \n    vec3 light=normalize(vec3(0,1,1));\n     if(!Intersect(Ray(p+n*0.01,light),osef)){\n   \n   \n    vec3 r = reflect(-l, n);\n    \n    \n    vec3 ambient = mat.ka;\n    \n    \n    float diff = max(dot(n, l), 0.0);\n    vec3 diffuse = mat.kd * diff;\n    \n    \n    float spec = pow(max(dot(r, v), 0.0), mat.shininess);\n    vec3 specular = mat.ks * spec;\n    \n     \n    return ambient + diffuse + specular;\n    }\n}\n\n \nvec3 Shade(Ray ray)\n{\n    \n    Hit x;\n    bool idx=Intersect(ray,x);\n    \n     if (idx) {\n        vec3 p = Point(ray, x.t);\n        Material mat = Texture(p, x.i);\n        \n         \n        vec3 viewDir = normalize(ray.o - p);\n        \n         \n        vec3 lightDir = normalize(vec3(1, 1, 1));\n        \n        return Color(mat, x.n,p, viewDir, lightDir);\n    } else {\n        return Background(ray.d);\n    }\n    \n    return vec3(0);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n     \n    vec3 ro = 22.0 * normalize(vec3(sin(2.0 * 3.14 * mouse.x), cos(2.0 * 3.14 * mouse.x), 1.4 * (mouse.y - 0.1)));\n    vec3 ta = vec3(0.0, 0.0, 1.5);\n    mat3 ca = setCamera(ro, ta);\n\n     \n    vec3 rd = ca * normalize(vec3(uv.xy * tan(radians(22.5)), 1.0));\n    vec3 col = Shade(Ray(ro, rd));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}