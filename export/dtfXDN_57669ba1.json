{"ver":"0.1","info":{"id":"dtfXDN","date":"1674765709","viewed":178,"name":"Little sailing boat","username":"ianertson","description":"A little sailing boat","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raymarching","ray","raymarch","clouds","water","boat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n\n#define ZERO (min(0, int(iTime)))\n\n#define STEPS 100\n#define NEAR 0.003\n#define FAR 100.0\n\n#define RGB(v) (v / 255.)\n\n#define BLUE0   RGB(vec3(15,94,156))\n#define BLUE1   RGB(vec3(35,137,218))\n#define BLUE2   RGB(vec3(28,163,236))\n#define BLUE3   RGB(vec3(90,188,216))\n#define BLUE4   RGB(vec3(116,204,244))\n\nvec3 noise(vec3 p, float freq, float lod) {\n    vec3 n = vec3(0.0);\n    n += textureLod(iChannel2, p*freq, lod).xyz; freq *= 2.0;\n    n += textureLod(iChannel2, p*freq, lod).xyz; freq *= 2.0;\n    n += textureLod(iChannel2, p*freq, lod).xyz; freq *= 2.0;\n    return n / 3.0;\n}\n\nfloat noise(vec2 p, float freq) {\n    float n = 0.0;\n    n += texture(iChannel1, p*freq).r; freq *= 2.0;\n    n += texture(iChannel1, p*freq).r; freq *= 2.0;\n    n += texture(iChannel1, p*freq).r; freq *= 2.0;\n    n += texture(iChannel1, p*freq).r; freq *= 2.0;\n    return n /4.0;\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n#define ENTITY_NONE 0\n#define ENTITY_HULL 1\n#define ENTITY_PILLAR 2\n#define ENTITY_SAIL 3\n#define ENTITY_PLANE 4\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    int entity;\n    vec3 entPos;\n    float depth;\n    vec3 reflection_dir;\n    bool hit;\n    int skip;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n};\n\nvoid dataInit(inout Data data) {\n    data.point = vec3(0.);\n    data.normal = vec3(0.);\n    data.uv = vec2(0.);\n    data.dist = FAR;\n    data.entPos = vec3(0.);\n    data.depth = 0.0;\n    data.reflection_dir = vec3(0.0);\n    data.hit = false;\n    data.skip = -1;\n}\n\nfloat sphereSDF(vec3 p, vec3 spherePos, float radius) {\n    return length(p - spherePos) - radius;\n}\n\nfloat coneSDF( vec3 p, vec2 c ) {\n    float q = length(p.xz);\n    return dot(c,vec2(q,p.y));\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    \n    return e + i;\n}\n\nfloat boatHullSDF(vec3 p) {\n    float sphere = sphereSDF(p, vec3(0.), 1.);\n    p.z *= 0.45;\n   \n    vec3 conePos = p;\n    conePos.xy *= rot(radians(180.));\n    \n    conePos.y -= 1.5;\n    float cone = coneSDF(conePos, vec2(0.7, 0.5));\n    float slice = p.y-0.1;\n    \n    cone = max(cone, slice);\n    \n    return max(smin(sphere, cone, 0.3), slice) / (1.0+0.45);\n}\n\nfloat boatSDF(vec3 p, inout float hull2) {\n\n    p.z *= 0.5;\n    float hull = boatHullSDF(p);\n    \n    p.y += 0.4;\n    p.z *= 1.0;\n    p.x *= 1.1;\n    hull2 = boatHullSDF(p) / (1.05);\n    return max(-hull, hull2);\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.0));\n}\n\nfloat sailSDF(vec3 p) {\n    float windT = T*0.05;\n    p.xy -= max(0.0, 1.0 - p.z)*0.25*(noise((p*0.01) + vec3(cos(windT), sin(windT), sin(windT+0.215)), 1., 0.).xy*2.0-1.0);\n    p.z += 2.6;\n    p.x *= 5.;\n    p.z *= 0.5;\n    float slice = p.z-2.;\n    p.zy *= rot(radians(90.));\n    \n    float cone = coneSDF(p, vec2(1., 0.5));\n    cone = max(cone, slice);\n    \n    return cone / 6.;\n}\n\nfloat getDistWater(vec3 p, inout float waterHeight) {\n\n    float offsetT = T*0.1;\n    vec3 offset = vec3(cos(offsetT), sin(offsetT), sin(offsetT+0.2915)) * 0.1;\n    p.z += T;\n    vec3 n0 = noise(p/FAR, 0.5, 0.);\n    vec3 n1 = noise(((p/FAR)+(n0*0.1))+offset, 1., 0.);\n    vec3 n2 = noise(((p/FAR)*2.) - offset, 1., 1.);\n    \n    vec3 n = (n0 + n1 + n2) / 3.;\n    \n    waterHeight = n.y*2.5;\n    \n    p.y += 0.2;\n    p.y -= waterHeight;\n    \n    return p.y+1.;\n}\n\nfloat getDist(vec3 p, inout int entity, inout vec3 entPos, int skip) {\n    \n    float waterHeight = 0.0;\n    float plane = getDistWater(p, waterHeight);\n    vec3 boatPos = vec3(0.0, -1.0, 0.0);\n    \n    boatPos.y += 0.25*(0.5+(0.5*cos(T)));\n   \n    float boatInside = 0.0;\n    float boat = boatSDF(p + boatPos, boatInside);\n    float cyl = cylinderSDF(p + boatPos, vec3(0.0, -1.5, 0.0), vec3(0.0, 3.0, 0.0), 0.1);\n    float sail = sailSDF((p + boatPos) + vec3(0.0, -2.2, 1.3));\n    \n    plane = max(-boatInside, plane);\n    \n    float minDist = FAR;\n    \n    entity = ENTITY_NONE;\n    \n    if (cyl < minDist && skip != ENTITY_PILLAR) { entPos = -boatPos; entity = ENTITY_PILLAR; minDist = cyl; }\n    if (sail < minDist && skip != ENTITY_SAIL) { entPos = -boatPos; entity = ENTITY_SAIL; minDist = sail; }\n    if (boat < minDist && skip != ENTITY_HULL) { entPos = -boatPos; entity = ENTITY_HULL; minDist = boat; }\n    if (plane < minDist && skip != ENTITY_PLANE) { entity = ENTITY_PLANE; minDist = plane; }\n    \n    return minDist;\n}\n\nvec3 getNormal(vec3 p, inout int entity, inout vec3 entPos, int skip) {\n    vec2 e = vec2(0.1, 0.0);\n    \n    return normalize(getDist(p, entity, entPos, skip) - vec3(\n        getDist(p + e.xyy, entity, entPos, skip),\n        getDist(p + e.yxy, entity, entPos, skip),\n        getDist(p + e.yyx, entity, entPos, skip)\n    ));\n}\n\nvec2 getUv(in Data data) {\n    vec3 p = data.point - data.entPos;\n    vec3 n = data.normal;\n    \n    float up = abs(dot(n, vec3(0.0, 1.0, 0.0)));\n    float left = abs(dot(n, vec3(1.0, 0.0, 0.0)));\n    float front = abs(dot(n, vec3(0.0, 0.0, 1.0)));\n    \n    // unrolled \"sort\"\n    int idx = 0;\n    float maxDist = -100.;\n    if (up > maxDist) { maxDist = up; idx = 0; }\n    if (left > maxDist) { maxDist = left; idx = 1; }\n    if (front > maxDist) { maxDist = front; idx = 2; }\n    \n    switch (idx) {\n        case 0: return p.xz; break;\n        case 1: return p.zy; break;\n        case 2: return p.xy; break;\n    }\n    \n    return p.xz;\n}\n\nvec3 getSailDiffuse(in Data data) {\n    float n = texture(iChannel1, data.uv*0.09).r;\n    float n2 = texture(iChannel1, n+(data.uv*0.09)).r;\n    return clamp((vec3(n2 + n) / 3.0) + 0.45, 0.0, 1.0);\n}\n\nvec3 getPlaneDiffuse(in Data data) {\n    data.point.z += T;\n    vec3 n = noise(data.point*0.2, 1., 0.);\n    vec3 a = mix(BLUE0, BLUE1, n.x);\n    vec3 b = mix(BLUE1, BLUE2, n.y);\n    vec3 c = mix(BLUE2, BLUE3, n.z);\n    vec3 d = mix(c, BLUE4, (n.x+n.y+n.z)/3.);\n    return (a+b+c+d)/3.0;\n}\n\nvec3 getDiffuse(in Data data) {\n    switch (data.entity) {\n        case ENTITY_HULL: return texture(iChannel0, data.uv).rgb; break;\n        case ENTITY_SAIL: return getSailDiffuse(data); break;\n        case ENTITY_PILLAR: return texture(iChannel0, data.uv).rgb; break;\n        case ENTITY_PLANE: return getPlaneDiffuse(data); break;\n        default: return vec3(0.); break;\n    }\n    return vec3(0.);\n}\n\nvec3 getBump(in Data data) {\n    if (data.entity != ENTITY_HULL && data.entity != ENTITY_PILLAR) return data.normal;\n    return extractBump(iChannel0, data.uv, data.normal, 0.008, 0.2);\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    data.dist = FAR;\n    data.depth = 1.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(p, data.entity, data.entPos, data.skip);\n        dist += next;\n        if (abs(next) <= NEAR || abs(dist) >= FAR) break;\n    }\n\n    if (dist >= FAR) return false;\n    \n    vec3 p = ro+rd*dist;\n    data.point = p;\n    data.dist = min(FAR, abs(dist));\n    data.normal = getNormal(p, data.entity, data.entPos, data.skip);\n    data.uv = getUv(data);\n    data.depth = data.dist / FAR;\n    data.hit = true;\n    \n    return true;\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec2 uv = rd.xz / rd.y;\n    uv.xy += T*0.1;\n    float cloud = noise(uv, 0.1);\n    vec3 blue = mix(BLUE0, BLUE1, cloud);\n    return blue+cloud;\n}\n\nvec3 render(vec3 ro, vec3 rd, inout Data data, float fog) {\n    vec3 col = vec3(0.);\n    \n    Light light = Light(vec3(1., -1.0, -2.), vec3(1.), 8.);\n    \n    if (march(ro, rd, data)) {\n        vec3 normal = getBump(data);\n        vec3 L = normalize(light.pos);\n        vec3 viewdir = normalize(data.point - ro);\n        vec3 reflection_dir = normalize(reflect(viewdir, normal) * -1.);\n        data.reflection_dir = reflection_dir;\n        vec3 light_reflect_dir = reflect(-L, normal);\n        float VdotR = max(dot(viewdir, light_reflect_dir), 0.0);\n        vec3 albedo = vec3(1.);\n        vec3 diffuse = getDiffuse(data);\n        float NdotL = max(0.0, dot(normal, L));\n        float lightDist = distance(data.point, light.pos);\n        float spec = pow(VdotR,16.0);\n        float att = NdotL;\n        col += (diffuse + spec) * att;\n    } else {\n        col += sky(ro, rd);\n    }\n    \n    return col + (data.depth*fog)*2.*BLUE2;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 lookAt = point;\n    float zoom = 1.;\n    vec3 camForward = normalize(lookAt - ro);\n    vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n    vec3 camUp = -cross(camRight, camForward);\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    vec3 ro = vec3(0.0, 1.0, -10.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(m.y*M_PI);\n        rd.yz *= rot(m.y*M_PI);\n        ro.xz *= rot(m.x*M_PI);\n        rd.xz *= rot(m.x*M_PI);\n    } else {\n        float moveT = T*0.5;\n        ro.y += (0.5+(0.5*(sin(moveT)))) * TAU;\n        ro.x -= ((cos(moveT-0.5))) * TAU;\n        rd = look(uv, vec3(0.0), ro);\n    }\n    \n    ro.y = max(0.5, ro.y);\n    rd = normalize(rd);\n    \n    Data data;\n    dataInit(data);\n    \n    col += render(ro, rd, data, 1.0);\n    \n    if (data.hit && data.entity == ENTITY_PLANE) {\n        Data refdata;\n        dataInit(refdata);\n        refdata.skip = data.entity;\n        col /= M_PI;\n        vec3 refCol = render(data.point, -data.reflection_dir, refdata, 0.0);\n        col += refCol / M_PI;\n    }\n    \n    col /= vec3(0.86238) + col;\n    col = saturate(col, 1.1);\n    col += luma(col) / TAU;\n    col = pow(col, vec3(1.0 / 1.6));\n    O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n\nvec3 extractBump(sampler2D tex, vec2 uv, vec3 worldNormal, float z, float mi) {\n  vec3 color = texture(tex, uv).rgb;\n  vec2 texelSize = 1.0 / vec2(textureSize(tex, 0));\n  vec3 dx = texture(tex, uv + vec2(texelSize.x, 0)).rgb - color;\n  vec3 dy = texture(tex, uv + vec2(0, texelSize.y)).rgb - color;\n  float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n  vec3 a = normalize(vec3(dy.r - dx.r, dx.g - dy.g, z));\n  vec2 aspect = 1.0 / vec2(textureSize(tex, 0));\n  vec3 px = color;\n  vec2 value = vec2(0.0);\n  for (float i = 0.0; i < TAU; i += TAU / 16.0) {\n    vec2 dir = vec2(sin(i), cos(i));\n    vec3 next = texture(tex, uv + dir * aspect * 6.0).rgb;\n    value += dir * distance(px, next);\n  }\n  vec3 b = vec3(value, z);\n  vec3 n = normalize(mix(a, b, 0.5));\n\n  return mix(worldNormal, n + worldNormal, mi);\n}","name":"Common","description":"","type":"common"}]}