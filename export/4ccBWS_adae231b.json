{"ver":"0.1","info":{"id":"4ccBWS","date":"1733410644","viewed":182,"name":"Ray trace caching/sharing","username":"Fewes","description":"Practical \"single shot\" multi-bounce GI:\nTrace 8 rays per pixel. Store hits (UV) in buffer. Use hits to gather multiple bounces (max of 2 due to shadertoy buffer limit). Hits are shared among neighbours to increase rays per pixels in a semi-plausible way.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["gi","tracing","cornell","multibounce"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Render bounce 2 and composite\n\nvec3 TonemapACES(vec3 color)\n{\n    return (color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14);\n}\nvec3 TonemapReinhard(vec3 color)\n{\n    return 1.0 - 1.0 / (1.0 + color);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 ro, rd;\n    GetCamera(uv, iResolution, ro, rd);\n    \n    vec4 geo = texture(iChannel0, uv);\n    vec3 p = ro + rd * geo.w;\n    vec3 n = DecodeNormal(geo.xy);\n    int m = int(geo.z);\n    \n    if (p.z < -0.999) { fragColor = vec4(0.0); return; }\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec2 lp = vec2(-(mouse.x-0.5),-(mouse.y-0.5));\n    float theta = -iTime*0.5+1.0;\n    vec3 ld = normalize(vec3(lp,-0.1));\n    vec3 lr = vec3(1);\n    \n    vec3 emissive;\n    vec3 albedo = GetAlbedo(m, emissive);\n    \n    vec3 direct = texture(iChannel2, uv).rgb;\n    vec3 bounce1 = texture(iChannel3, uv).rgb;\n    \n    vec3 bounce2 = vec3(0.0);\n    \n    float radianceSum = 0.0;\n#if NEIGHBOUR_SHARE_COUNT > 0\n    int iterations = 1 + NEIGHBOUR_SHARE_COUNT;\n#else\n    int iterations = 1;\n#endif\n    vec2 shareRadius = NEIGHBOUR_SHARE_RADIUS / geo.w / iResolution.xy * 100.0;\n    for (int j = 0; j < iterations; j++)\n    {\n        int z = j + NEIGHBOUR_SHARE_COUNT * 2;\n#ifdef NEIGHBOUR_TEMPORAL_JITTER\n        z += iFrame;   \n#endif\n        vec2 hash = hash23(vec3(fragCoord, z)) - 0.5;\n        hash *= j == 0 ? 0.0 : 1.0;\n\n        vec2 hitsUV = uv + hash * shareRadius;\n        vec4 geo3 = texture(iChannel0, hitsUV);\n        vec3 n3 = DecodeNormal(geo3.xy);\n\n        if (dot(n, n3) < 1.0 - NEIGHBOUR_NORMAL_THRESHOLD || abs(geo.w - geo3.w) > NEIGHBOUR_DEPTH_THRESHOLD)\n        {\n            continue;\n        }\n\n        vec4 encodedHits = texture(iChannel1, hitsUV);  \n        vec2 hits[RAY_COUNT];\n        DecodeHits(encodedHits.r, hits[0], hits[1]);\n        DecodeHits(encodedHits.g, hits[2], hits[3]);\n        DecodeHits(encodedHits.b, hits[4], hits[5]);\n        DecodeHits(encodedHits.a, hits[6], hits[7]);\n    \n        for (int i = 0; i < RAY_COUNT; i++)\n        {\n            vec2 hitUV = hits[i];\n            if (max(hitUV.x,hitUV.y)<PACK_MIN*2.0) continue; // No hit\n            vec3 radiance = textureLod(iChannel3, hitUV, BOUNCE_MIP).rgb;\n            \n#ifdef RECONSTRUCT_BRDF\n            vec4 geo2 = texture(iChannel0, hitUV);\n            vec3 rd2 = GetRay(hitUV, iResolution);\n            vec3 p2 = ro + rd2 * geo2.w;\n            float costh = clamp(dot(n, normalize(p2 - p)), 0.0, 1.0) * 2.0;\n#else\n            float costh = 1.0;\n#endif\n\n#if BOUNCE_COUNT > 1\n            bounce2 += radiance * costh;\n#endif\n        }\n        \n        radianceSum += 1.0;\n    }\n    bounce2 /= float(RAY_COUNT) * radianceSum;\n    \n    bounce2 *= albedo;\n    \n    vec3 color = direct + bounce1 + bounce2;\n    \n    color *= 10.0;\n    color = TonemapReinhard(color);\n    color = pow(color, vec3(1.0 / 2.2));\n    \n#ifdef VALIDATE_CACHE\n    vec4 encodedHits = texture(iChannel1, uv);\n    vec2 hits[RAY_COUNT];\n    DecodeHits(encodedHits.r, hits[0], hits[1]);\n    DecodeHits(encodedHits.g, hits[2], hits[3]);\n    DecodeHits(encodedHits.b, hits[4], hits[5]);\n    DecodeHits(encodedHits.a, hits[6], hits[7]);\n    if (uv.x < 0.5)\n    {\n        color = vec3(encodedHits.xy, 0);\n    }\n    else\n    {\n        color = vec3(hits[VALIDATE_CACHE], 0);\n    }\n#endif\n    \n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Buffer A: Geomety buffer\n// Buffer B: Ray hit cache\n// Buffer C: Direct\n// Buffer D: Bounce 1\n// Image:    Bounce 2 + composite\n\n#define CACHE // If enabled, tracing only happens during the first frame (except for sun shadow)\n\n#define BOUNCE_COUNT 2 // Can be 0, 1 or 2\n\n// Share neighbour hits stochastically, effectively getting 8*n rays per pixel in total.\n#define NEIGHBOUR_SHARE_COUNT 8 // Set to 0 to view only hits belonging to each pixel\n#define NEIGHBOUR_SHARE_RADIUS 1.0 // Higher value = smoother but less accurate bounces.\n#define NEIGHBOUR_NORMAL_THRESHOLD 0.2 // [0, 1]\n#define NEIGHBOUR_DEPTH_THRESHOLD 0.3 // [0, inf]\n#define NEIGHBOUR_TEMPORAL_JITTER\n\n// Normally, we importance sample the BRDF using a uniform power cosine distribution.\n// However, when sharing hits between neighbours, this no longer results in correct weighting,\n// as a neighbour's distribution usually doesn't align with the current pixel's one.\n// Enabling this define instead replaces the cosine distribution with a uniform hemisphere.\n// The BRDF is then used like normal when gathering by reconstructing the ray direction using the hit position.\n// Unfortunately this is quite costly as the gbuffer has to be sampled for each hit,\n// so if the loss in directionality is acceptable it is preferable to leave this disabled.\n//#define RECONSTRUCT_BRDF\n\n#define ENABLE_SUN\n\n//#define ENABLE_EMISSIVE_CUBE // If changed, must reset time or disable CACHE to take effect\n//#define ANIMATE_EMISSIVE_CUBE // CACHE must be disabled\n\n#define BOUNCE_MIP 0.0 // Smoother bounces but reduced details and added leaking.\n\n#define TRACE_MIN_Z 1e-3\n\n//#define VALIDATE_CACHE 0 // Compare cached with actual trace hits. Must reset or undef CACHE to take effect.\n\n// Don't change these\n#define RAY_COUNT 8\n#define HIT_MAX 255u\n#define CAM_Z 1.0\n#define Z_CLIP -5.001\n\nvec3 GetRay(vec2 uv, vec3 res)\n{\n    return normalize(vec3((uv - 0.5) * vec2(res.x / res.y, 1.0), CAM_Z));\n}\nvoid GetCamera(vec2 uv, vec3 res, out vec3 ro, out vec3 rd)\n{\n    ro = vec3(0, 0, -3);\n    rd = GetRay(uv, res);\n}\nvec2 GetUV(vec3 ro, vec3 p, vec3 res)\n{\n    vec3 rd = normalize(p - ro);\n    return rd.xy / (rd.z / CAM_Z) / vec2(res.x / res.y, 1.0) + 0.5;\n}\n\nvec3 GetAlbedo(int m, out vec3 emissive)\n{\n    vec3 albedo = vec3(0.0);\n    emissive = vec3(0.0);\n    if (m == 0)\n    {\n        albedo = vec3(0.5);\n    }\n    if (m == 1)\n    {\n        albedo = vec3(1, 0, 0);\n    }\n    if (m == 2)\n    {\n        albedo = vec3(0, 1, 0);\n    }\n    if (m == 3)\n    {\n        emissive = normalize(vec3(6.0, 5.0, 3.0)) * 3.0;\n    }\n    return albedo;\n}\n\n// https://iquilezles.org/articles/intersectors/\nvec2 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra, out vec3 n)\n{\n    n = vec3(0.0);\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    vec2 t = vec2( -b-h, -b+h );\n    n = normalize((ro + rd * t.x) - ce);\n    return t;\n}\nvec2 boxIntersection(vec3 ro, vec3 rd, vec3 boxCenter, vec3 boxSize, out vec3 outNormal)\n{\n    ro -= boxCenter;\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) :\n                           step(t2,vec3(tF));\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nfloat Trace(vec3 ro, vec3 rd, float time, out int m, out vec3 n)\n{\n    bool hit = false;\n    \n    m = 0;\n \n    vec3 cn, bn;\n    float ct = sphIntersect(ro, rd, vec3(0.0, -0.5, 0.0), 0.5, cn).x;\n    float bt = boxIntersection(ro, rd, vec3(0.0), vec3(1.0), bn).y;\n    \n    float t = ct;\n    n = cn;\n    if ((bt < t || t < 0.0) && bt > 0.0 && bn.z < 0.5)\n    {\n        t = bt;\n        n = bn;\n        m = n.x > 0.5 ? 1 : (n.x < -0.5 ? 2 : 0);\n    }\n    \n#ifdef ENABLE_EMISSIVE_CUBE\n    #ifdef ANIMATE_EMISSIVE_CUBE\n    float x = (cos(time) + 1.0) * 0.3 + 0.1;\n    float z = (cos(time * 0.9) + 1.0) * 0.3 + 0.1;\n    #else\n    float x = 0.5;\n    float z = 0.5;\n    #endif\n    vec3 ebn;\n    float ebt = boxIntersection(ro, rd, vec3(0,1,0), vec3(x,0.001,z), ebn).x;\n    if ((ebt < t || t < 0.0) && ebt > 0.0)\n    {\n        t = ebt;\n        n = ebn;\n        m = 3;\n    }\n#endif\n    \n    return t;\n}\nfloat Trace(vec3 ro, vec3 rd, float time)\n{\n    int m;\n    vec3 n;\n    return Trace(ro, rd, time, m, n);\n}\n\nfloat TraceShadow(vec3 ro, vec3 rd, float time)\n{\n    return Trace(ro + rd * TRACE_MIN_Z, rd, time) > 0.0 ? 0.0 : 1.0;\n}\n\nvec3 DecodeNormal(vec2 xy)\n{\n    return vec3(xy, -sqrt(1.0 - clamp(dot(xy, xy), 0.0, 1.0)));\n}\n\nvec3 UniformPowerCosine(vec2 uv, float power)\n{\n\tfloat theta = acos(pow(1.0 - uv.x, 1.0 / (1.0 + power)));\n\tfloat phi = 2.0 * 3.1415926 * uv.y;\n\n\tvec3 ray;\n\tray.x = sin(theta) * cos(phi);\n\tray.y = sin(theta) * sin(phi);\n\tray.z = cos(theta);\n\n\treturn ray;\n}\n\nvec3 ChangeBasisZ(vec3 rayIn, vec3 up)\n{\n\tvec3 b1 = up;\n\tvec3 different = (abs(b1.x) < 0.5) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n\tvec3 b2 = normalize(cross(b1, different));\n\tvec3 b3 = cross(b2, b1);\n\n\treturn normalize(rayIn.x * b3 + rayIn.y * b2 + rayIn.z * b1);\n}\n\nvec3 RandomUnitVector(vec2 rand)\n{\n    float PI2 = 6.28318530718;\n    float z = 1.0 - 2.0 * rand.x;\n    float xy = sqrt(1.0 - z * z);\n    float theta = 6.28318530718 * rand.y;\n    float sn = sin(theta);\n    float cs = cos(theta);\n    return vec3(sn * xy, cs * xy, z);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// https://www.shadertoy.com/view/tdscWS\n#define PACK_MIN 2e-3\nhighp uint packUnorm(mediump uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nmediump uvec4 unpackUnorm(highp uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packUnorm(  vec4  a) { return uintBitsToFloat(packUnorm(uvec4(round(clamp(a, PACK_MIN, 1.)*255.)))); }\nvec4  unpackUnorm(float a) { return vec4(unpackUnorm(floatBitsToUint(a))) / 255.; }\n\nfloat EncodeHits(vec2 hit1, vec2 hit2)\n{\n    return packUnorm(vec4(hit1, hit2));\n}\nvoid DecodeHits(float hits, out vec2 hit1, out vec2 hit2)\n{\n    vec4 e = unpackUnorm(hits);\n    hit1 = e.xy; hit2 = e.zw;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Render geometry buffer (normals + depth)\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n#ifdef CACHE\n    vec2 prevResolution = texture(iChannel0, vec2(0)).xy;\n    vec2 delta = prevResolution - iResolution.xy;\n    if (iFrame > 0 && dot(delta, delta) < 1e-3)\n    {\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n    {\n        fragColor = vec4(iResolution.xy, 0, 0);\n        return;\n    }\n#endif\n\n    vec3 ro, rd;\n    GetCamera(uv, iResolution, ro, rd);\n    \n    float proj = (ro.z - Z_CLIP) / rd.z;\n    \n    int m;\n    vec3 n;\n    float t = Trace(ro + rd * proj, rd, iTime, m, n) + proj;\n    \n    fragColor = vec4(n.xy, m, t);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Trace rays and store hits\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n#ifdef CACHE\n    vec2 prevResolution = texture(iChannel1, vec2(0)).xy;\n    vec2 delta = prevResolution - iResolution.xy;\n    if (iFrame > 0 && dot(delta, delta) < 1e-3)\n    {\n        fragColor = texture(iChannel1, uv);\n        return;\n    }\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n    {\n        fragColor = vec4(iResolution.xy, 0, 0);\n        return;\n    }\n#endif\n\n    vec3 ro, rd;\n    GetCamera(uv, iResolution, ro, rd);\n    vec4 geo = texture(iChannel0, uv);\n    vec3 p = ro + rd * geo.w;\n    vec3 n = DecodeNormal(geo.xy);\n    \n    if (p.z < -0.999) { fragColor = vec4(0.0); return; }\n    \n    vec2 hits[RAY_COUNT];\n    for (int i = 0; i < RAY_COUNT; i++)\n    {\n        vec2 jitter = hash23(vec3(fragCoord, i + iFrame));\n        vec3 rd2 = UniformPowerCosine(jitter, 1.0);\n        rd2 = ChangeBasisZ(rd2, n);\n        \n#ifdef RECONSTRUCT_BRDF\n        rd2 = RandomUnitVector(hash23(vec3(fragCoord, i + iFrame)));\n        rd2 *= sign(dot(n, rd2));\n#endif\n        \n        float t = Trace(p - rd * 1e-5, rd2, iTime);\n        vec3 radiance = vec3(0.0);\n        vec2 hit = vec2(0.0);\n        if (t > 0.0)\n        {\n            vec3 p2 = p + rd2 * t;\n            vec2 hitUV = GetUV(ro, p2, iResolution);\n            vec4 geo2 = texture(iChannel0, hitUV);\n            vec3 n2 = DecodeNormal(geo2.xy);\n            if (distance(ro, p2) <= geo2.w + 1e-3 && dot(rd2, n2) < 0.0) // Occlusion check\n            {\n                hit = hitUV;\n            }\n        }\n        hits[i] = hit;\n    }\n    \n    // Encode hits in RGBAFloat (16 bits per hit)\n    // R: Hit 1, 2\n    // G: Hit 3, 4\n    // B: Hit 5, 6\n    // A: Hit 7, 8\n    fragColor.r = EncodeHits(hits[0], hits[1]);\n    fragColor.g = EncodeHits(hits[2], hits[3]);\n    fragColor.b = EncodeHits(hits[4], hits[5]);\n    fragColor.a = EncodeHits(hits[6], hits[7]);\n    \n#ifdef VALIDATE_CACHE\n    if (uv.x < 0.5)\n    {\n        fragColor = vec4(hits[VALIDATE_CACHE], 0, 0);\n    }\n#endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Render direct lighting\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 ro, rd;\n    GetCamera(uv, iResolution, ro, rd);\n    vec4 geo = texture(iChannel0, uv);\n    vec3 p = ro + rd * geo.w;\n    vec3 n = DecodeNormal(geo.xy);\n    int m = int(geo.z);\n    \n    if (p.z < -0.999) { fragColor = vec4(0.0); return; }\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec2 lp = vec2(-(mouse.x-0.5),-(mouse.y-0.5));\n    float theta = -iTime*0.5+1.0;\n    vec3 ld = normalize(vec3(lp,-0.1));\n    if (iMouse.x < 10.0)\n    {\n        ld = normalize(vec3(cos(theta), sin(theta), -1));\n    }\n    \n    vec3 lr = vec3(1);\n    \n    vec3 emissive;\n    vec3 albedo = GetAlbedo(m, emissive);\n    \n    vec3 color = emissive;\n#ifdef ENABLE_SUN\n    float shadow = TraceShadow(p + n * 1e-3 - rd * 1e-2, ld, iTime);\n    float brdf = clamp(dot(n, ld), 0.0, 1.0);\n    color += albedo * lr * brdf * shadow;\n#endif\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Render bounce 1\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 ro, rd;\n    GetCamera(uv, iResolution, ro, rd);\n    vec4 geo = texture(iChannel0, uv);\n    vec3 p = ro + rd * geo.w;\n    vec3 n = DecodeNormal(geo.xy);\n    int m = int(geo.z);\n    \n    if (p.z < -0.999) { fragColor = vec4(0.0); return; }\n    \n    vec3 emissive;\n    vec3 albedo = GetAlbedo(m, emissive);\n    \n    vec3 bounce1 = vec3(0.0);\n    \n    float radianceSum = 0.0;\n#if NEIGHBOUR_SHARE_COUNT > 0\n    int iterations = 1 + NEIGHBOUR_SHARE_COUNT;\n#else\n    int iterations = 1;\n#endif\n    vec2 shareRadius = NEIGHBOUR_SHARE_RADIUS / geo.w / iResolution.xy * 100.0;\n    for (int j = 0; j < iterations; j++)\n    {\n        int z = j + NEIGHBOUR_SHARE_COUNT;\n#ifdef NEIGHBOUR_TEMPORAL_JITTER\n         z += iFrame;   \n#endif\n        vec2 hash = hash23(vec3(fragCoord, z)) - 0.5;\n        hash *= j == 0 ? 0.0 : 1.0;\n\n        vec2 hitsUV = uv + hash * shareRadius;\n        vec4 geo3 = texture(iChannel0, hitsUV);\n        vec3 n3 = DecodeNormal(geo3.xy);\n        \n        if (dot(n, n3) < 1.0 - NEIGHBOUR_NORMAL_THRESHOLD || abs(geo.w - geo3.w) > NEIGHBOUR_DEPTH_THRESHOLD)\n        {\n            continue;\n        }\n\n        vec4 encodedHits = texture(iChannel1, hitsUV);   \n        vec2 hits[RAY_COUNT];\n        DecodeHits(encodedHits.r, hits[0], hits[1]);\n        DecodeHits(encodedHits.g, hits[2], hits[3]);\n        DecodeHits(encodedHits.b, hits[4], hits[5]);\n        DecodeHits(encodedHits.a, hits[6], hits[7]);\n    \n        for (int i = 0; i < RAY_COUNT; i++)\n        {\n            vec2 hitUV = hits[i];\n            if (max(hitUV.x,hitUV.y)<PACK_MIN*2.0) continue; // No hit\n            vec3 radiance = textureLod(iChannel2, hitUV, BOUNCE_MIP).rgb;\n            \n#ifdef RECONSTRUCT_BRDF\n            vec4 geo2 = texture(iChannel0, hitUV);\n            vec3 rd2 = GetRay(hitUV, iResolution);\n            vec3 p2 = ro + rd2 * geo2.w;\n            float costh = clamp(dot(n, normalize(p2 - p)), 0.0, 1.0) * 2.0;\n#else\n            float costh = 1.0;\n#endif\n            \n#if BOUNCE_COUNT > 0\n            bounce1 += radiance * costh;\n#endif\n        }\n        \n        radianceSum += 1.0;\n    }\n    bounce1 /= float(RAY_COUNT) * radianceSum;\n\n    vec3 color = bounce1 * albedo;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}