{"ver":"0.1","info":{"id":"mlSXWR","date":"1675899529","viewed":135,"name":"Yet Another TexBomb","username":"LVutner","description":"implementation of \"Procedural Stochastic Textures by Tiling and Blending\" paper","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["textures","stochastic","texturebombing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Procedural Stochastic Texturing implementation\n\n    Info:\n        It is a rough implementation of stochastic texturing from \n        Procedural Stochastic Textures by Tiling and Blending paper.\n\n    References:\n        [T. Deliot & E. Heitz, 2019] \"Procedural Stochastic Textures by Tiling and Blending\"\n        [iq] https://www.shadertoy.com/view/XlXcW4\n\n    Credits:\n        @FabriceNeyret2 - For variance preservation trick\n        @iq - For integer hash \n*/\n\n//Settings\n#define PRESERVE_VARIANCE //Enables variance preservation\n#define TILING_FACTOR 8.0 //Tiling factor\n\n//Thanks iq!\nvec2 hash(vec2 pix)\n{\n    uvec2 x = uvec2(pix);\n    x = ((x>>8u)^x.yx)*1103515245u;\n    x = ((x>>8u)^x.yx)*1103515245u;\n \n    return vec2(x) * (1.0 / float(0xffffffffu));\n}\n\n//Stochastic texturing\nvec4 stochastic_tiling(sampler2D sampled_tex, vec2 uv)\n{\n    //Skew input space into simplex triangle grid\n    vec2 skewed_uv = mat2(1.0, 0.0, -0.57735027, 1.15470054) * (uv * 3.464);\n\n\t//Compute local triangle vertex IDs and local barycentric coordinates\n\tvec2 vertex_id = floor(skewed_uv);\n    vec3 barycentric = vec3(fract(skewed_uv), 0);\n\tbarycentric.z = 1.0 - barycentric.x - barycentric.y;\n\n    //XY - vertex uv, Z - weight\n\tvec3[3] vert_weight;\n    vert_weight[0] = barycentric.z > 0.0 ? vec3(vertex_id, barycentric.z) : vec3(vertex_id + vec2(1.0, 1.0), -barycentric.z);\n    vert_weight[1] = barycentric.z > 0.0 ? vec3(vertex_id + vec2(0.0, 1.0), barycentric.y) : vec3(vertex_id + vec2(1.0, 0.0), 1.0 - barycentric.y);\n    vert_weight[2] = barycentric.z > 0.0 ? vec3(vertex_id + vec2(1.0, 0.0), barycentric.x) : vec3(vertex_id + vec2(0.0, 1.0), 1.0 - barycentric.x);\n\n    //Calculate derivatives to avoid triangular grid artifacts\n    vec4 dxdy = vec4(dFdx(uv), dFdy(uv));\n\n    //Blend textures together\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\tcolor += textureGrad(sampled_tex, uv + hash(vert_weight[0].xy), dxdy.xy, dxdy.zw) * vert_weight[0].z;\n    color += textureGrad(sampled_tex, uv + hash(vert_weight[1].xy), dxdy.xy, dxdy.zw) * vert_weight[1].z;\n    color += textureGrad(sampled_tex, uv + hash(vert_weight[2].xy), dxdy.xy, dxdy.zw) * vert_weight[2].z;\n\n    \n#ifdef PRESERVE_VARIANCE\n    //Variance preservation\n    //Thanks to FabriceNeyret\n    vec2 resolution = vec2(textureSize(iChannel0, 0));\n    float lowest_mip = log(min(resolution.x, resolution.y)) / log(2.0) + 1.0;    \n    \n    vec4 mean = textureLod(sampled_tex, vec2(0.0), lowest_mip);\n    float moments = length(vec3(vert_weight[0].z, vert_weight[1].z, vert_weight[2].z));\n    color = (color - mean) / moments + mean;\n#endif\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //UVs\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //Correct aspect ratio\n    uv-= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv+= 0.5;\n\n    //Tile image N times\n    uv *= TILING_FACTOR;\n\n    //Sample texture with new UVs\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    //Perform stochastic texturing on right side\n    if((fragCoord / iResolution.xy).x > 0.5)\n        col = stochastic_tiling(iChannel0, uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col * 1.,1.0);\n}","name":"Image","description":"","type":"image"}]}