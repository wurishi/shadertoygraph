{"ver":"0.1","info":{"id":"DdjfRt","date":"1690024136","viewed":111,"name":"SH vs ambient and directional","username":"sjb","description":"Round trip ambient and directional lighting (of a diffuse surface) through spherical harmonics and back, plot the results on polar graphs.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Shader code to round trip ambient + directional light through SH and back.\n    \n    See https://www.sjbrown.co.uk/posts/ambient-and-directional-lighting-in-spherical-harmonics/\n    for the derivations.\n    \n    Each plot is a polar plot of intensity varying with the angle of the surface\n    relative to the light source.  The plots vary in the order of SH used, and\n    whether or not the SH representation of directional lights have been scaled\n    to match exactly when facing the light source (so the red and blue lines\n    intersect at the top of the plot).\n    \n    From left to right:\n      * Order 1 SH (scaled to match)\n      * Order 1 SH (not scaled)\n      * Order 2 SH (scaled to match)\n      * Order 2 SH (not scaled)\n    \n    The colored lines are:\n      * Green: original ambient + directional (should not be visible, covered by blue)\n      * Red: lighting as SH\n      * Blue: extracted ambient + directional\n    \n    Click/drag the mouse to change the amount of ambient + directional\n      * Mouse x coordinate: amount of directional light\n      * Mouse y coordinate: amount of ambient light\n    \n    The light direction slowly rotates when not clicking the mouse, otherwise it is\n    locked to come from the top of the screen.\n*/\n\n#define PI 3.1415926535\n\n#define C0 (sqrt(1.0/PI)/2.0)\n#define C1 (sqrt(3.0/PI)/2.0)\n#define C2 (sqrt(15.0/PI)/2.0)\n#define C3 (sqrt(5.0/PI)/4.0)\n#define C4 (sqrt(15.0/PI)/4.0)\n\n// no factor of pi here\n#define Z0 (1.0)\n#define Z1 (2.0/3.0)\n#define Z2 (1.0/4.0)\n\nvoid ZeroSH(inout float s[9])\n{\n    for (int i = 0; i < 9; ++i)\n        s[i] = 0.0;\n}\n\nvoid AddDeltaSH2(vec3 d, float p, inout float s[9])\n{\n    vec3 dc = d.yzx*d.zxy;\n    vec3 d2 = d*d;\n    s[0] += C0*p;\n    s[1] += d.x*C1*p;\n    s[2] += d.y*C1*p;\n    s[3] += d.z*C1*p;\n    s[4] += dc.x*C2*p;\n    s[5] += dc.y*C2*p;\n    s[6] += dc.z*C2*p;\n    s[7] += (3.0*d2.z - 1.0)*C3*p;\n    s[8] += (d2.x - d2.y)*C4*p;\n}\n\nvoid AddDeltaSH1(vec3 d, float p, inout float s[9])\n{\n    s[0] += C0*p;\n    s[1] += d.x*C1*p;\n    s[2] += d.y*C1*p;\n    s[3] += d.z*C1*p;\n}\n\nvoid Convolution(inout float s[9])\n{\n    s[0] *= Z0;\n    \n    s[1] *= Z1;\n    s[2] *= Z1;\n    s[3] *= Z1;\n    \n    s[4] *= Z2;\n    s[5] *= Z2;\n    s[6] *= Z2;\n    s[7] *= Z2;\n    s[8] *= Z2;\n}\n\nfloat EvalSH(vec3 d, float s[9])\n{\n    vec3 dc = d.yzx*d.zxy;\n    vec3 d2 = d*d;\n    return C0*s[0]\n        + d.x*C1*s[1]\n        + d.y*C1*s[2]\n        + d.z*C1*s[3]\n        + dc.x*C2*s[4]\n        + dc.y*C2*s[5]\n        + dc.z*C2*s[6]\n        + (3.0*d2.z - 1.0)*C3*s[7]\n        + (d2.x - d2.y)*C4*s[8];\n}\n\nfloat DiffuseDotSkip0(float Le[9], vec3 dir)\n{\n    float Ld[9];\n    ZeroSH(Ld);\n    AddDeltaSH2(dir, 1.0, Ld);\n    Convolution(Ld);\n    \n    float sum = 0.0;\n    for (int i = 1; i < 9; ++i)\n        sum += Le[i]*Ld[i];\n    return sum;\n}\n\nvoid AddAmbientLightSH(float p, inout float s[9])\n{\n    s[0] += p*(2.0*sqrt(PI));\n}\n\nvoid AddDirectionalLightSH1(vec3 d, float p, bool scale_to_match, inout float s[9])\n{\n    AddDeltaSH1(d, p*(scale_to_match ? (4.0*PI/3.0) : PI), s); \n}\n\nvoid AddDirectionalLightSH2(vec3 d, float p, bool scale_to_match, inout float s[9])\n{\n    AddDeltaSH2(d, p*(scale_to_match ? (16.0*PI/17.0) : PI), s); \n}\n\n#define Y_AXIS_RANGE 6.0\n#define X_AXIS_RANGE (Y_AXIS_RANGE*iResolution.x/iResolution.y/4.0)\n#define AXIS_RANGE vec2(X_AXIS_RANGE, Y_AXIS_RANGE)\n\n#define AA_SIZE (2.5*Y_AXIS_RANGE/iResolution.y)\n\nvoid DrawLine(inout vec3 canvas, vec3 col, float dist)\n{\n    canvas = mix(canvas, col, smoothstep(0.707, 0.0, abs(dist/AA_SIZE)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    bool is_l1 = uv.x < 0.5;\n    uv.x = uv.x*2.0 - (is_l1 ? 0.0 : 1.0);\n    bool scale_to_match = uv.x < 0.5;\n    uv.x = uv.x*2.0 - (scale_to_match ? 0.0 : 1.0);\n    vec2 sample_coord = mix(-0.5*AXIS_RANGE, 0.5*AXIS_RANGE, uv);\n    \n    vec3 col = vec3(1.0);\n    \n    float original_Kd = 0.9;\n    float original_Ka = 0.2;\n    float angle = PI/2.0;\n\n    if (iMouse.z > 0.0) {\n        original_Kd = iMouse.x/iResolution.x;\n        original_Ka = iMouse.y/iResolution.y;\n    } else {\n        angle += iTime;\n    }\n    \n    vec3 light_dir = normalize(vec3(cos(angle), sin(angle), 0.0));\n\n    // polar axes\n    vec3 sample_vec = vec3(sample_coord, 0.0);\n    float sample_dist = length(sample_vec);\n    vec3 sample_dir = sample_vec/sample_dist;\n    DrawLine(col, vec3(0.7), sample_dist - 1.0);\n    if (sample_dist < 1.7) {\n        DrawLine(col, vec3(0.7), sample_coord.x);\n        DrawLine(col, vec3(0.7), sample_coord.y);\n    }\n    \n    float original_lighting = original_Ka + original_Kd*max(0.0, dot(light_dir, sample_dir)); \n    DrawLine(col, vec3(0.0, 1.0, 0.0), sample_dist - original_lighting);\n\n    float La[9];\n    ZeroSH(La);\n    AddAmbientLightSH(1.0, La);\n    Convolution(La);\n\n    if (is_l1) {\n        float Le[9];\n        ZeroSH(Le);\n        AddAmbientLightSH(original_Ka, Le);\n        AddDirectionalLightSH1(light_dir, original_Kd, scale_to_match, Le);\n        Convolution(Le);\n\n        DrawLine(col, vec3(1.0, 0.0, 0.0), sample_dist - EvalSH(sample_dir, Le));\n\n        vec3 fitted_dir = normalize(vec3(Le[1], Le[2], Le[3]));\n        float ed1 = DiffuseDotSkip0(Le, fitted_dir);\n        float fitted_Kd, fitted_Ka;\n        if (scale_to_match) {\n            fitted_Kd = ed1*(9.0/4.0);\n            fitted_Ka = Le[0]*(0.5/sqrt(PI)) - fitted_Kd/3.0;\n        } else {\n            fitted_Kd = ed1*3.0;\n            fitted_Ka = Le[0]*(0.5/sqrt(PI)) - fitted_Kd/4.0;\n        }\n\n        float fitted_lighting = fitted_Ka + fitted_Kd*max(0.0, dot(fitted_dir, sample_dir)); \n        DrawLine(col, vec3(0.0, 0.0, 1.0), sample_dist - fitted_lighting);\n    } else {\n        float Le[9];\n        ZeroSH(Le);\n        AddAmbientLightSH(original_Ka, Le);\n        AddDirectionalLightSH2(light_dir, original_Kd, scale_to_match, Le);\n        Convolution(Le);\n\n        DrawLine(col, vec3(1.0, 0.0, 0.0), sample_dist - EvalSH(sample_dir, Le));\n\n        vec3 fitted_dir = normalize(vec3(Le[1], Le[2], Le[3]));\n        float ed1 = DiffuseDotSkip0(Le, fitted_dir);\n        \n        float fitted_Kd, fitted_Ka;\n        if (scale_to_match) {\n            fitted_Kd = ed1*(204.0/79.0);\n            fitted_Ka = Le[0]*(0.5/sqrt(PI)) - fitted_Kd*(4.0/17.0);\n        } else {\n            fitted_Kd = ed1*(192.0/79.0);\n            fitted_Ka = Le[0]*(0.5/sqrt(PI)) - fitted_Kd/4.0;\n        }\n\n        float fitted_lighting = fitted_Ka + fitted_Kd*max(0.0, dot(fitted_dir, sample_dir)); \n        DrawLine(col, vec3(0.0, 0.0, 1.0), sample_dist - fitted_lighting);\n    }\n    \n    vec2 text_uv = floor(uv*iResolution.xy*vec2(0.25, 1.0)/DOWN_SCALE);\n    print_pos = floor(vec2(iResolution.x/8.0, iResolution.y*0.8)/DOWN_SCALE) - vec2(STRWIDTH(6.0), 0.0);\n    float text = 0.0;\n    if (is_l1) {\n        text += char(ch_L, text_uv);\n        text += char(ch_1, text_uv);\n    } else {\n        text += char(ch_L, text_uv);\n        text += char(ch_2, text_uv);\n    }\n    text += char(ch_spc, text_uv);\n    if (!scale_to_match) {\n        text += char(ch_N, text_uv);\n        text += char(ch_o, text_uv);\n        text += char(ch_t, text_uv);\n        text += char(ch_spc, text_uv);\n    }\n    text += char(ch_S, text_uv);\n    text += char(ch_c, text_uv);\n    text += char(ch_a, text_uv);\n    text += char(ch_l, text_uv);\n    text += char(ch_e, text_uv);\n    text += char(ch_d, text_uv);\n    col = mix(col, vec3(0.0), text);    \n\n\tfragColor = vec4(pow(col, vec3(1.0/2.2)),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 8x12 Font from https://www.shadertoy.com/view/Mt2GWD\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n","name":"Common","description":"","type":"common"}]}