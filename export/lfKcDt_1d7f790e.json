{"ver":"0.1","info":{"id":"lfKcDt","date":"1732697717","viewed":72,"name":"random tempo-optical illusion","username":"afrodex","description":"shader for randomized textures in 3d\nuncomment different col to see steps\ncurrently: randomizing positions of flames within cell","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","random","4dillusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//find distance from point to nearest object in scene\n//also defines objects in the scene\n#define MAX_STEPS 100  //maximum number of steps to take in marcher\n#define MAX_DIST 50.  //the largest step size in marcher\n#define SURF_DIST .01  //maximum distance to register a hit\n#define STEP_SIZE .45   //scaling factor for step size to account for distortions\n\n\nmat2 rot(float a){\n    float sine = sin(-a);\n    float cosine = cos(-a);\n    \n    return mat2(cosine, -sine, sine, cosine);\n}\n\nfloat sdfHeart(vec4 sphere, vec3 p){\n\n\n    float a = 0.;\n    a = .1+.1*sin(6.28*iTime);\n    a = .1+.1*pow(.5+.5*sin(6.28*iTime), 4.);\n    a = .1+.1*pow(.5+.5*sin(6.28*iTime+.3*p.y*p.y), 4.);\n    \n    sphere.w += a;\n    \n    float xTrans = p.x;\n    float yTrans = .1+1.2*p.y-abs(p.x)*sqrt(1.7-abs(p.x));\n    float zTrans = (2.5-p.y*.3)*p.z;\n    \n    \n    \n    return length(sphere.xyz - vec3(xTrans, yTrans, zTrans)) - sphere.w;\n\n}\n\nvec2 GetDist(vec3 p){\n    vec4 s = vec4(0, 1, 0, 1); //sphere data: x, y, z, radius\n    float sphereDist = length(p-s.xyz) - s.w;\n    float heartDist = sdfHeart(s, p);\n    float planeDist = p.y;\n    //float boxDist = length(max(abs(p-1.) - vec3(.5), 0.));\n    float m = iMouse.x/iResolution.x;\n    m = 0.;\n    float comboDist = mix(sphereDist, heartDist, m);\n    float hit = sign(planeDist - comboDist);\n    float d = min(comboDist, planeDist);\n    hit = sign(SURF_DIST - comboDist);\n    hit = step( comboDist, .01);\n    return vec2(d, hit);\n}\n\n//ray marching loop\nvec2 RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; //distance marched so far\n    float hit = 1.;\n    for (int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dO*STEP_SIZE;    //march the distance dO in the direction rd from point ro\n        vec2 dist = GetDist(p);\n        float dS = dist.x;  //calculate the distance to the nearest object in the scene from current point\n        dO += dS;               //increase the total distance for the next iteration\n        hit = dist.y;\n        if (dO>MAX_DIST || dS<SURF_DIST) break; //break out of loop if past the maximum distance or a hit is registered\n    }\n\n    return vec2(dO, hit);\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 d = GetDist(p);  //find distance to nearest point\n    vec2 e = vec2(.01, 0.); //amount to step in each direction\n    \n    //use step to find new distance in each direction\n    //swizzle the e around to make the coding simpler\n    vec3 norm = d.x - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x\n        );\n        \n    return normalize(norm);\n}\n\n//gives light value at this point in the scene \nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, -4);     //position of light in the scene\n    lightPos.xz+= vec2(sin(iTime), cos(iTime))*2.;\n    vec3 lightDir = normalize(lightPos - p);  //direction from light to point\n    vec3 norm = GetNormal(p);\n    \n    float dif = clamp(dot(lightDir, norm), 0., 1.); //lighting value at this point; between 0, 1\n    float shadDist = RayMarch(p+norm*SURF_DIST*1.5, lightDir).x;   //distance to nearest object between this point and the light source\n    if (shadDist<length(lightPos-p)) dif *=.1;\n    return dif;\n}\n\nfloat mask(vec2 uv){\n    mat2 spin = mat2(cos(iTime), -1.*sin(iTime), sin(iTime), cos(iTime));\n    uv = uv * spin;\n    return step(abs(uv.x), .2) * step(abs(uv.y), .1);\n}\n\n\nfloat rand(vec2 uv){\n\n    uv = fract(uv*vec2(456.324, 948.163));\n    uv += dot(uv, uv + 34.94);\n    return (fract(uv.x*uv.y));\n    //return fract(sin(dot(uv.xy, vec2(15685.64, 95367.564869)))*1918990.);\n}\n\nvec3 noise(vec2 uv, vec2 fragCoord, float hit){\n\n    //uv = \n\n    vec2 mv = (fragCoord.xy - ceil(35.*iTime) - .5*iResolution.xy)/iResolution.x;\n\n    return vec3(hit * rand(mv) + (1.-hit)*rand(uv));\n\n}\n\nvec3 flame(vec2 uv, float offset, float dir){\n    \n    uv = (uv + vec2(.6*(offset-.5), .7*(offset - .5)+.2)) * vec2(3., 6.);\n    offset *= 6.283;\n    float s = sin(uv.y);\n    float c = .7*cos(uv.y);\n    float center = .5*(s + c);\n    float angle = 2.*iTime * dir + (1. + .1*offset*offset) + 0.3*uv.y + offset;\n    float rot = sin(angle);\n    float quiver = .2*uv.y*cos(uv.y - 2.*iTime - offset);\n    \n    float bar = step(abs(uv.x-rot*center - quiver),abs(rot*c))*step(abs(uv.y-1.55), 3.1);\n    \n    vec3 o = vec3(1., .65, 0.);\n    vec3 y = vec3(1., .9, 0.);\n    \n    float front = step(mod(angle, 6.2839), 3.14159);\n    float back = 1. - front;\n    \n    return bar * (front*y + back*o);\n\n}\n\nvec2 rayTrace (vec2 uv){\n\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy)/iResolution.x;\n    float mcos = sqrt(1.-mouse.x*mouse.x);   //cosine version of mouse x\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec3 cam = vec3(0, 1, -6); //relative position of camera\n    //cam.xz = length(cam.xz)*vec2(mouse.x, -mcos);    //position with rotation from mouse\n    cam.xz *= rot(asin(mouse.x));\n    vec3 raydir = normalize(vec3(uv.x, uv.y, 1));    //direction of rays coming from camera\n    raydir.xz *= rot(asin(mouse.x));\n    //raydir = normalize(raydir - normalize(vec3(cam.x, 0., cam.z)));\n    vec2 d = RayMarch(cam, raydir);   //distance to nearest object from camera\n    \n    vec3 p = cam + raydir * d.x*STEP_SIZE;   //hit position of current ray to nearest object (world space)\n    \n    float dif = GetLight(p);    //light value from that object\n\n    //vec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.x;\n    //vec2 m = (iMouse.xy - .5*iResolution.xy)/iResolution.x;\n\n    //col = vec3(rand(uv+d));\n    //col = vec3(dif);\n    float m = floor(d.y*2.-.5);  //floor is here because of weird artifacts\n    return vec2(dif, d.y);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy)/iResolution.x;\n    float mcos = sqrt(1.-mouse.x*mouse.x);   //cosine version of mouse x\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec3 cam = vec3(0, 1, -6); //relative position of camera\n    //cam.xz = length(cam.xz)*vec2(mouse.x, -mcos);    //position with rotation from mouse\n    cam.xz *= rot(asin(mouse.x));\n    vec3 raydir = normalize(vec3(uv.x, uv.y, 1));    //direction of rays coming from camera\n    raydir.xz *= rot(asin(mouse.x));\n    //raydir = normalize(raydir - normalize(vec3(cam.x, 0., cam.z)));\n    vec2 d = RayMarch(cam, raydir);   //distance to nearest object from camera\n    \n    vec3 p = cam + raydir * d.x*STEP_SIZE;   //hit position of current ray to nearest object (world space)\n    \n    float dif = GetLight(p);    //light value from that object\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 mv = (fragCoord.xy - ceil(35.*iTime) - .5*iResolution.xy)/iResolution.x;\n    //vec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.x;\n    //vec2 m = (iMouse.xy - .5*iResolution.xy)/iResolution.x;\n\n    //col = vec3(rand(uv+d));\n    //col = vec3(dif);\n    float m = floor(.5*(1.+ d.y));  //floor is here because of weird artifacts\n    //col = vec3(m * rand(mv) + (1.-m)*rand(uv));\n\n    //col = noise(uv, fragCoord, m);\n    vec2 xy = fragCoord.xy/iResolution.y;\n    vec2 scale = 10. * vec2(3., 2.); \n    uv=xy*scale;\n    vec2 rep = fract(uv) - .5;\n    vec2 index = vec2(.333, .5)*(xy*vec2(3., 2.)-rep);\n    index = floor(uv);\n    vec4 grid = vec4(rep.x, rep.y, index.x, index.y); \n    vec2 gId1 = grid.zw + vec2(-1., -1.);\n    col = vec3(rep.x, rep.y, 0.);\n    col = vec3(index.x, index.y, 0.);\n    //col = flame(uv, 0., 1.);\n    //col = vec3(xy.x, xy.y, 0.);\n    //col = vec3(grid.z, grid.w, 0.);\n    //col = vec3(gId1.x, gId1.y, 0.);\n    col = vec3(grid.w - gId1.y)*.5;\n    //col = vec3(rand(grid.zw));\n    //col = vec3(rayTrace(grid.zw - .5).x);\n    col = flame(grid.xy, rand(grid.zw/scale), rayTrace(grid.zw/scale - .5).y);\n    //col += flame(grid.xy+1./scale, rand(gId1.xy/scale), rayTrace(gId1.xy/scale - .5).y);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}