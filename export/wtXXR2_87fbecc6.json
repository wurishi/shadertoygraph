{"ver":"0.1","info":{"id":"wtXXR2","date":"1563535128","viewed":81,"name":"It's a shader about Ray","username":"unindicated","description":"I done it","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float distFromSphere(vec3 pos, vec3 spherePos, float radius) \n{\n    return distance(spherePos, pos) - radius;\n}\n\nfloat sdf(vec3 curPos) {\n    vec3 spherePos0 = vec3(-1.5, 0.0 + sin(iTime * 0.5), 10.0);\n    float sphereRadius0 = 3.0;\n    \n    vec3 spherePos1 = vec3(1.5 + sin(iTime), 0.0, 10.0);\n    float sphereRadius1 = 2.0;   \n    \n    float dist0 = distFromSphere(curPos, spherePos0, sphereRadius0);\n    float dist1 = distFromSphere(curPos, spherePos1, sphereRadius1);\n        \n    float dist = max(dist0, dist1);\n    \n    return dist;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray = initialRayNormal(fragCoord, iResolution);\n\tfloat totalDist = 0.0;\n    vec3 curPos = vec3(0);\n    float lastDist = 100.0;\n    int count = 0;\n\n\n    \n    while(lastDist > 0.0002 && \n          totalDist < 100.0 && \n          count < 100) {\n        \t\n        float dist = sdf(curPos);\n        \t\n        totalDist += dist;\n        count++;\n        \n        curPos += ray * dist;\n        \n        lastDist = dist;\n    }\n        \n    float epsilon = 0.01;\n    float x = sdf(vec3(curPos.x+epsilon, curPos.y, curPos.z)) - lastDist;\n    float y = sdf(vec3(curPos.x, curPos.y+epsilon, curPos.z)) - lastDist;\n    float z = sdf(vec3(curPos.x, curPos.y, curPos.z+epsilon)) - lastDist;\n    vec3 normal = normalize(vec3(x,y,z));\n    \n    vec3 colour = normal * 0.5 + 0.5 * float(count) * 0.01 * ( sin(iTime*3.3) + 0.9 );\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float PI = 3.1415927;\t\n\nvec3 nearPlanePixelPos(vec2 fragCoord, vec3 resolution) {\n    float nearPlaneDist = 1.0;\n    vec2 posXY = ( fragCoord - ( resolution.xy * 0.5 ) ) / resolution.x;\n    vec3 pos = vec3(posXY, nearPlaneDist);\n    return pos;\n}\n\nvec3 initialRayNormal(vec2 fragCoord, vec3 resolution) {\n    vec3 pixelCamPos = nearPlanePixelPos(fragCoord, resolution);\n    return normalize(pixelCamPos);\n}\n\nbool intersectionDistance(vec3 rayNormal, vec3 spherePos, float radius, out float dist) {\n\n    vec3 toSphereN = normalize(spherePos);\n    float cosAngle = dot(rayNormal, toSphereN);\n    \n    if(cosAngle<0.0) {\n        return false;\n    }\n    \n    float c = length(spherePos);\n    float A = acos(cosAngle);\n    float sinA = sin(A);\n    \n    if(sinA * c > radius) {\n        return false;\n    }\n    \n    // law of sines\n    // see: https://en.wikipedia.org/wiki/Law_of_sines\n    // \"The ambiguous case of triangle solution\"\n    float a = radius;\n    float d = sinA / a;\n    float C = PI - asin( d * c );\n    // sum of angles\n    float B = PI - ( A + C );\n    // law of cosines\n    float bSquared = (a*a) + (c*c) - 2.0 * a * c * cos(B);\n    float b = sqrt(bSquared);\n    dist = b;\n    return true;\n}\n\nbool intersectedSpherePoint(vec3 rayNormal, vec3 spherePos, float radius, out vec3 point) {\n    float dist;\n    if(intersectionDistance(rayNormal, spherePos, radius, dist)) {\n        point = rayNormal * dist;\n        return true;\n    } else {\n    \treturn false;\n    }\t\n}","name":"Common","description":"","type":"common"}]}