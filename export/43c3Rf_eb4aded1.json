{"ver":"0.1","info":{"id":"43c3Rf","date":"1716803791","viewed":310,"name":"Fork Voxel AA rasmusgo 662","username":"rasmusgo","description":"I solved the derivatives of hit point by projecting the derivatives of ray direction along the ray and onto the voxel surface.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"l3tGWM","parentname":"Voxel AA"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    I'm trying to calculate the world-space screen derivatives\n    so I can do proper anti-aliasing on blocks.\n    fwidth(world) works on block faces, but breaks along block edges.\n    \n    The color output is displaying the difference between my derivatives and fwidth\n    So ideally the only difference should be along block edges and block faces should be black\n    This is working correctly when iTime==0.0, but as soon as we begin to rotate, the derivatives break.\n    It gets close around 90 degrees, but it's still wrong.\n    \n    I can't seem to figure it out, so any ideas might help.\n    Thanks for your time.\n*/\n\n//Max number of voxel steps\n#define STEPS 255.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float C = cos(iTime);\n    float S = sin(iTime);\n    //View rotation matrix\n    mat3 view = mat3(C,0,S, 0,1,0, -S,0,C); //mat3(1,0,0, 0,C,S, 0,-S,C);\n    //view *= mat3(0.8,0.6,0, -0.6,0.8,0, 0,0,1);\n    //view = mat3(1);\n    //Ray direction\n    vec3 ray = normalize(iResolution.xyy*.5 - vec3(fragCoord,0));\n    vec3 dir = ray * view;\n    //Prevent division by 0 errors\n    dir += vec3(dir.x==0.0, dir.y==0.0, dir.z==0.0) * 1e-5;\n    \n    vec3 ddx_dir = dFdx(dir);\n    vec3 ddy_dir = dFdy(dir);\n    \n    //Camera position with mouse control\n    vec3 pos = vec3(iMouse.xy-iResolution.xy*0.5, 0.0) * view/32.0;\n    //Scroll forward\n    //pos.z += iTime/.1;\n    pos.z+=8.;\n    \n    //Sign direction for each axis\n    vec3 sig = sign(dir);\n    //Step size for each axis\n    vec3 stp = sig / dir;\n    \n    //Voxel position\n    vec3 vox = floor(pos);\n    //Initial step sizes to the next voxel\n    vec3 dep = ((vox-pos + 0.5) * sig + 0.5) * stp;\n    //Adds small biases to minimize same depth conflicts (z-fighting)\n    dep += vec3(0,1,2) * 1e-5;\n    \n    //Axis index\n    vec3 axi;\n    \n    //Loop iterator\n    float steps = 0.0;\n    //Loop through voxels\n    for(float i = 0.0; i<STEPS; i++)\n    {\n        //Check map\n        if (dot(sin(vox*.13),cos(vox.yzx*.17))+vox.y*.1>1.6) break;\n        //Increment steps\n        steps++;\n        \n        //Select the closest voxel axis\n        axi = step(dep, min(dep.yzx, dep.zxy));\n        axi *= 1.-axi.zxy;\n        //Step one voxel along this axis\n        vox += sig * axi;\n        //Set the length to the next voxel\n        dep += stp * axi;\n    }\n    //Get normal\n    vec3 nor = sig * axi;\n    //Viewspace normal\n    vec3 vnor = view * nor;\n    //Hit coordinates\n    float dist = dot(dep-stp, axi);\n    vec3 hit = pos + dir*dist;\n    \n    //////////SOLUTION IS HERE!!!!!!!!\n    //My derivatives\n    vec3 ddx_hit = dist * (ddx_dir - dot(ddx_dir, nor) / dot(dir, nor) * dir);\n    vec3 ddy_hit = dist * (ddy_dir - dot(ddy_dir, nor) / dot(dir, nor) * dir);\n    vec3 w1 = abs(ddx_hit) + abs(ddy_hit);\n    \n    /////////FWIDTH FOR COMPARISON\n    //Fwidth\n    vec3 w2 = fwidth(hit);\n    \n    vec3 width = \n    mod(dot(ceil(fragCoord*.1),vec2(1)),2.)>.5?\n    w1 : w2;\n    \n    \n    vec3 grid = clamp((abs(0.5-fract(hit+0.5+nor*0.5))) / width, 0.0, 1.0);\n    vec3 col = sqrt(grid.x*grid.y*grid.z) * (nor*.5+.5); //nor\n    vec3 sky = 1.0+(dir.y-1.0) * vec3(0.3,0.2,0.1);\n    col = mix(col, sky, sqrt(steps/STEPS));\n    \n    //Display the difference\n    fragColor = vec4(abs(w1-w2)*9.,1);//vec4(col*col,1);//\n}","name":"Image","description":"","type":"image"}]}