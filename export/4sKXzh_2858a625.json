{"ver":"0.1","info":{"id":"4sKXzh","date":"1462888800","viewed":395,"name":"Borderlands Vault Opt","username":"Draedrus","description":"https://www.shadertoy.com/view/lsVSzR optimization. A portal inspired from the Borderlands Vault.","likes":7,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","optimized","vault","borderlands"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsfGDS","filepath":"https://soundcloud.com/amicozer-suemark/borderlands-2-theme-song-no-place-for-a-hero","previewfilepath":"https://soundcloud.com/amicozer-suemark/borderlands-2-theme-song-no-place-for-a-hero","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n * thanks Amicozer for -No Place For A Hero- song from the Borderlands\n * thanks again to IQ for letting me discover raymarching algorithms\n ***********************************************************************/\n\n#ifdef GLSL\n#define textureProj texture2DProj\n#endif\n\n#define SOFTSHADOWS\n//#define LIGHTMOVING\n\n#define NUM_STEPS 120\n#define SAND_OCTAVES 6\n#define SAND_GRAINS 1\n#define CAMDIST 4.0\n#define CAMROTSPEED 0.5\n#define PORTALSPEED 0.5\n#define LIGHTSPEED 0.00\n#define FAR 50.0\n#define NEAR 0.002\n\n#define CAMPOS vec3(5.0, 1.0, -5.0)\n#define TARGETPOS vec3(0.0, 1.0, 0.0)\n\n#define COLORSAND vec3(0.9, 0.9, 0.5)\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n#define TYPE_FLOOR 0.0\n#define TYPE_TEMPLE 1.0\n#define TYPE_SAND 2.0\n#define TYPE_PORTAL_BLOCKS 3.0\n#define TYPE_PORTAL_EDGE 4.0\n#define TYPE_OTHER_FLOOR 5.0\n#define TYPE_OTHER_TEMPLE 6.0\n#define TYPE_OTHER_WATER 7.0\n#define TYPE_OTHER_PORTALBLOCKS 8.0\n#define TYPE_OTHER_PORTALEDGE 9.0\n#define TYPE_OTHER_GARDENS 10.0\n#define TYPE_OTHER_GARDENFLOWERS 11.0\n#define TYPE_OTHER_GARDENTREES 12.0\n\n//#define HIGHQUALITY\n\n#define ROTX(P, A) P*mat3(1.0, 0.0, 0.0, 0.0, cos(A), -sin(A), 0.0, sin(A), cos(A))\n#define ROTY(P, A) P*mat3(cos(A), 0.0, -sin(A), 0.0, 1.0, 0.0, sin(A), 0.0, cos(A))\n#define ROTZ(P, A) P*mat3(cos(A), -sin(A), 0.0, sin(A), cos(A), 0.0, 0.0, 0.0, 1.0)\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n\nLight _light = Light(\n    vec3(0.0, 0.0, 0.0),\n    -normalize(TARGETPOS-vec3(0.0, 4.5, 4.5)),\n    vec4(1.0, 1.0, 0.3, 1.0),\n    2.0,\n    2.0);\n\nvec3 ray_dir = vec3(0.0);\n\n/*******************\n * TOOLS\n *******************/\n\nvec2 UVTwist(in vec2 uv, float a) {\n    float cA = cos(a+iTime*PORTALSPEED);\n    float sA = sin(a+iTime*PORTALSPEED);\n\treturn uv*mat2(cA, -sA, sA, cA);   \n}\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\n\n/********************\n * NOISES\n ********************/\n\nfloat hash(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 49.4294, 42.40594))*13.4959451);    \n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h), floor(mix( b.y, a.y, h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat polsmaxf( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, 1.0-h ) - k*h*(1.0-h);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<-d2.x) ? d1 : d2;\n}\n\nvec2 opBlend( vec2 d1, vec2 d2, float p )\n{\n    return polsmin( d1, d2, p);\n}\n\nvec3 opCheapBend( vec3 p )\n{\n    p = RotXV3(p, 3.14/2.0);\n    p = RotYV3(p, 3.14/2.0);\n    float c = cos(3.5*p.y);\n    float s = sin(3.5*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(p.xy*m, p.z);\n}\n\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\nfloat mapTemple(vec3 p) {\n    return polsmaxf(max(max(\n        \t\t\tsdHexPrism(p - vec3(-8.0, 0.0, 0.0), vec2(4.0, 4.0)),\n        \t\t\t-sdSphere(p - vec3(-4.0, 5.0, 4.0), 3.0)),\n               \t\t-sdSphere(p - vec3(-2.0, 4.0, 0.0), 4.0)),\n               \t\t-sdSphere(p - vec3(-4.0, 4.5, -4.0), 5.0), 0.5\n        );\n}\n\nfloat heightMap(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = 0.2;\n    for(int i=0;i<5;++i) {\n        h += texture(iChannel1, p.xz*f).r*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapWater(vec3 p) {\n    return udBox(p, vec3(0.5, 0.01, 0.5));\n}\n\nfloat mapTerrain(vec3 p, float s) {\n    float hm = heightMap(p, s);\n    return min(\n        \tsdTorus(p-vec3(-1.0, -0.2, 0.0), vec2(0.7, 0.2))-hm*0.3,\n        \tsdPlane(p)+hm\n    \t);\n}\n\nfloat heightMapSand(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = 0.2;\n    for(int i=0;i<SAND_OCTAVES;++i) {\n        h += snoise(p.xz*f)*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    for(int i=0;i<SAND_GRAINS;++i) {\n        h += hash3D(p.xyz*f)*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapSand(vec3 p, float s) {\n\treturn sdPlane(p)+heightMapSand(p, s);\n}\n\nfloat mapPortalBloc(vec3 p, vec3 s) {\n    #ifdef HIGHQUALITY\n    return udRoundBox(p, s, 0.02)+voronoi3D(p*10.0)*0.03;\n    #else\n    return udRoundBox(p, s, 0.02);\n    #endif\n}\n\nfloat mapPortalBlocs(vec3 p) {\n    float s = sin(iTime)*0.03;\n    return \n            min(mapPortalBloc(opCheapBend(p-vec3(0.0, 1.7+s, 0.0)), vec3(0.1, 0.4, 0.06))\n                /*min(\n                    mapPortalBloc(opCheapBend(p-vec3(0.0, 1.7, 0.0)), vec3(0.2, 0.1, 0.06)),\n                    min(\n                        mapPortalBloc(RotXV3(p-vec3(0.0, 1.6, -0.15), -0.5), vec3(0.05, 0.2, 0.1)),\n                        mapPortalBloc(RotXV3(p-vec3(0.0, 1.6, 0.15), 0.5), vec3(0.05, 0.2, 0.1))\n                    )\n                )*/,\n               min(\n                min(\n                    mapPortalBloc(RotXV3(p-vec3(0.0, 0.0-s, -0.5), -0.08), vec3(0.05, 0.2, 0.05)),\n                    min(\n                        mapPortalBloc(RotXV3(p-vec3(0.0, 0.55+s, -0.45), -0.15), vec3(0.05, 0.2, 0.05)),\n                    \tmapPortalBloc(RotXV3(p-vec3(0.0, 1.1-s, -0.35), -0.30), vec3(0.05, 0.2, 0.05))\n                    )\n                ),\n                min(\n                    mapPortalBloc(RotXV3(p-vec3(0.0, 0.0+s, 0.5), 0.08), vec3(0.05, 0.2, 0.05)),\n                    min(\n                        mapPortalBloc(RotXV3(p-vec3(0.0, 0.55-s, 0.45), 0.15), vec3(0.05, 0.2, 0.05)),\n                    \tmapPortalBloc(RotXV3(p-vec3(0.0, 1.1+s, 0.35), 0.30), vec3(0.05, 0.2, 0.05))\n                    )\n                )\n        \t   )\n            );\n}\n\nfloat mapPortalEdge(vec3 p) {\n    float s = sin(iTime)*0.03;\n    p.z += sin(p.y*10.0+iTime*PORTALSPEED)*0.01;\n    return min(\n        \tudTriangle(p, vec3(0.0, -0.2, -0.5), vec3(0.0, 1.6+s, 0.0), vec3(0.0, -0.2, 0.5)),\n        \tmin(\n        \t\tudTriangle(p, vec3(0.0, -0.2, -0.5), vec3(0.0, 1.6+s, 0.0), vec3(0.0, 1.2, -0.4)),\n        \t\tudTriangle(p, vec3(0.0, 1.2, 0.4), vec3(0.0, 1.6+s, 0.0), vec3(0.0, -0.2, 0.5))\n             )\n        \t);\n}\n\n/**********************\n * MAP OTHERS ELEMENTS\n **********************/\n\nfloat mapOtherTemple(vec3 p) {\n    return min(min(min(\n        \tsdHexPrism(p - vec3(-8.0, 0.0, 0.0), vec2(4.0, 4.0)),\n        \tsdCapsule(p - vec3(-8.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 4.0, 0.0), 2.0)),\n            sdTriPrism(p - vec3(20.0, 0.0, 0.0), vec2(2.0, 0.1))),\n            udBox(p - vec3(20.0, 0.0, 0.0), vec3(8.0, 0.05, 0.1))\n        );\n}\n\nfloat mapOtherGardens(vec3 p) {\n    return udBox(p, vec3(28.0, 0.005, 1000.0));\n}\n\nfloat mapOtherGardenFlowers(vec3 p) {\n    return min(\n        \tudBox(p - vec3(0.0, 0.0, 0.5), vec3(27.0, 0.07, 0.2)),\n        \tudBox(p - vec3(0.0, 0.0, -0.5), vec3(27.0, 0.07, 0.2))\n        \t);\n}\n\nfloat mapOtherGardenTrees(vec3 p) {\n    return min(min(min(\n        \t\tsdSphere(p-vec3(20.0, 0.5, 0.8), 0.2),\n        \t\tsdSphere(p-vec3(25.0, 0.5, 0.8), 0.2)),\n                sdSphere(p-vec3(20.0, 0.5, -0.8), 0.2)),\n               \tsdSphere(p-vec3(25.0, 0.5, -0.8), 0.2));\n    /*if(abs(p.z)>5.0) return -1.0;\n    float c = 1.5;\n    p = p - vec3(20.0, 1.0, 0.0);\n    p.z = mod(p.z, c)-0.5* c;\n    return sdSphere(p, 0.2);*/\n}\n\nfloat mapOtherHeightMap(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = 0.2;\n    for(int i=0;i<5;++i) {\n        h += texture(iChannel0, p.xz*f).r*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapOtherWater(vec3 p) {\n    return udBox(p, vec3(0.5, 0.01, 0.5));\n}\n\nfloat mapOtherTerrain(vec3 p, float s) {\n    return min(\n        \tsdTorus(p-vec3(-1.0, -0.2, 0.0), vec2(0.7, 0.2)),\n        \tsdPlane(p)+heightMap(p, s)\n    \t);\n}\n\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nvec2 mapActual(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = opU(vec2(mapPortalBlocs(p), TYPE_PORTAL_BLOCKS), vec2(mapTerrain(p, 0.2), TYPE_FLOOR));\n    d = opU(vec2(mapTemple(p - vec3(-30.0, 0.0, 0.0)), TYPE_TEMPLE), d);\n    d = opU(vec2(mapSand(p, 0.4)-0.0, TYPE_SAND), d);\n    if(dot(ray_dir, vec3(-1.0, 0.0, 0.0))>0.0) {\n    \td = opU(vec2(mapPortalEdge(p), TYPE_PORTAL_EDGE), d);\n    }else{\n    }\n    return d;\n}\n\nvec3 mapActualNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapActual(pt).x;    \n    normal.x = mapActual(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapActual(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n/*******************\n * MAP PORTAL OTHER SIDE\n *******************/\n\nvec2 mapOther(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(mapOtherTerrain(p, 0.2), TYPE_OTHER_FLOOR);\n    d = opU(vec2(mapOtherTemple(p - vec3(-30.0, 0.0, 0.0)), TYPE_OTHER_TEMPLE), d);\n    d = opU(vec2(mapOtherGardens(p - vec3(-30.0, 0.0, 0.0)), TYPE_OTHER_GARDENS), d);\n    d = opU(vec2(mapOtherGardenFlowers(p - vec3(-30.0, 0.0, 0.0)), TYPE_OTHER_GARDENFLOWERS), d);\n    d = opU(vec2(mapOtherGardenTrees(p - vec3(-30.0, 0.0, 0.0)), TYPE_OTHER_GARDENTREES), d);\n    d = opU(vec2(mapOtherWater(p-vec3(-1.0, -0.04, 0.0)), TYPE_OTHER_WATER), d);\n    return d;\n}\n\nvec3 mapOtherNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapOther(pt).x;    \n    normal.x = mapOther(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapOther(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = mapActual(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\nvec2 raymarchOther(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = mapOther(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\n/************************\n * RENDERING\n ************************/\n\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = NEAR;\n    for(int i = 0; i<10;i++) {\n        float h = mapActual(ro + rd*t).x;\n        if( h<0.001 || t>FAR)\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat shadowOther( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = NEAR;\n    for(int i = 0; i<10;i++) {\n        float h = mapOther(ro + rd*t).x;\n        if( h<0.001 || t>FAR)\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n/*float shadow(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float t = tmin;\n    for( int i=0; i<10; ++i )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        if( h<tmin || t>tmax) break;\n        t+=h;//float(i)/30.0;\n    }\n    return clamp(1.0-(tmax-t)/(tmax-tmin), 0.0, 1.0);\n}*/\n\nfloat portalBlocDisp(vec3 p) {\n    vec2 uv = p.yz;\n\tvec4 horizEdge = vec4( 0.0 );\n    float x = 0.005, y = x;\n\thorizEdge -= texture( iChannel1, vec2( uv.x - x, uv.y - y ) ) * 1.0;\n\thorizEdge -= texture( iChannel1, vec2( uv.x - x, uv.y     ) ) * 2.0;\n\thorizEdge -= texture( iChannel1, vec2( uv.x - x, uv.y + y ) ) * 1.0;\n\thorizEdge += texture( iChannel1, vec2( uv.x + x, uv.y - y ) ) * 1.0;\n\thorizEdge += texture( iChannel1, vec2( uv.x + x, uv.y     ) ) * 2.0;\n\thorizEdge += texture( iChannel1, vec2( uv.x + x, uv.y + y ) ) * 1.0;\n\tvec4 vertEdge = vec4( 0.0 );\n\tvertEdge -= texture( iChannel1, vec2( uv.x - x, uv.y - y ) ) * 1.0;\n\tvertEdge -= texture( iChannel1, vec2( uv.x    , uv.y - y ) ) * 2.0;\n\tvertEdge -= texture( iChannel1, vec2( uv.x + x, uv.y - y ) ) * 1.0;\n\tvertEdge += texture( iChannel1, vec2( uv.x - x, uv.y + y ) ) * 1.0;\n\tvertEdge += texture( iChannel1, vec2( uv.x    , uv.y + y ) ) * 2.0;\n\tvertEdge += texture( iChannel1, vec2( uv.x + x, uv.y + y ) ) * 1.0;\n\tvec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));\n    return (edge.r+edge.g+edge.b)*0.33;\n}\n\nvec3 rendering(vec3 ro, vec3 rd, vec2 rm, vec2 uv) {\n    vec3 p = ro+rd*rm.x;\n    vec3 n;\n    if(rm.y!=TYPE_PORTAL_EDGE)\n    \tn = normalize(mapActualNormal(p, 0.001));\n    vec3 color;\n    #ifdef DEPTHMODE\n    color.r = color.g = color.b = (FAR-rm.x)/(FAR-NEAR);//*max(0.0, dot(n, -l));\n    color.rgb *= max(0.0, dot(-l, n))*1.0/(0.3*length(p - lPos));\n    #else\n    if(rm.x>NEAR && rm.x<FAR) {\n        if(rm.y==TYPE_PORTAL_BLOCKS) {\n            color = textureProj(iChannel0, p.xzy*1.0).rgb*vec3(0.7, 0.8, 1.1);\n            float v = portalBlocDisp(p);//pow(voronoi3D(p*10.0), 2.0)*2.0;\n            float tf = abs(fract(iTime*0.5)-0.5);\n            color = mix(color, vec3(0.0, v+v>0.5?tf:0.0, v+v>0.5?tf:0.0), 0.5);\n        \tcolor = color*max(0.0, dot(_light.d, n))*1.0/(0.3*length(p - _light.o));\n        }else if(rm.y >= TYPE_PORTAL_EDGE){\n            \n            vec3 worldColor;\n            vec2 rmo = raymarchOther(ro, rd, NEAR, FAR);\n            vec3 po = ro+rd*rmo.x;\n    \t\tvec3 no = normalize(mapOtherNormal(po, 0.001));\n\n            if(rmo.y == TYPE_OTHER_FLOOR){\n                worldColor = texture(iChannel0, po.xz).rgb*max(0.0, dot(_light.d, no))*1.0;\n            }else if(rmo.y == TYPE_OTHER_WATER) {\n                worldColor = vec3(0.4, 0.4, 1.0);   \n            }else if(rmo.y == TYPE_OTHER_TEMPLE) {\n                n *= texture(iChannel0, po.zy).r;\n                worldColor = vec3(1.0)*max(0.0, dot(_light.d, no));\n            }else if(rmo.y == TYPE_OTHER_GARDENS) {\n                worldColor = vec3(0.0, 1.0, 0.0)*max(0.0, dot(_light.d, no));\n            }else if(rmo.y == TYPE_OTHER_GARDENFLOWERS) {\n                worldColor = (\n                            mix(vec3(1.0, 1.0, 0.0),\n                                texture(iChannel2, po.xz*0.01).rgb,\n                                0.8)\n                        )*max(0.0, dot(_light.d, no));\n            }else if(rmo.y == TYPE_OTHER_GARDENTREES) {\n                n*=texture(iChannel1, uv*10.0).r;\n                worldColor = vec3(0.0, 1.0, 0.0)*max(0.0, dot(_light.d, no));\n            }\n            #ifdef SOFTSHADOWS\n            worldColor*=shadowOther(ro, rd, 8.0);\n            #endif\n            worldColor = mix(worldColor, mix(vec3(1.0), vec3(0.3, 0.3, 1.0), uv.y), 1.0-(FAR-rmo.x)/(FAR-NEAR));\n                    //= texture(iChannel2, uv).rgb;\n            //worldColor = vec3((FAR-rmo.x)/(FAR-NEAR));\n            // COMPUTING PORTAL EFFECT\n            vec3 portalColor = texture(iChannel0, UVTwist(uv-vec2(0.5, 0.5), 1.0)).rgb;\n    \t\t\n            portalColor += abs(pow(fract((p.y+iTime)*24.145)-0.5, 4.0));\n            p.z *= 1.9;\n            p.y *= 1.0;\n            portalColor.b += pow(length(vec3(0.0, 0.7, 0.0)- p)*1.2, 4.0);\n            // END COMPUTING PORTAL EFFECT\n            color = mix(worldColor, portalColor, 0.5);\n        }else if(rm.y == TYPE_FLOOR){\n            color = texture(iChannel1, p.xz).rgb*max(0.0, dot(_light.d, n))*1.0;\n            #ifdef SOFTSHADOWS\n        \tcolor *= shadow(p, _light.d, 8.0);\n            #endif\n        }else if(rm.y == TYPE_SAND) { // SAND\n         \tcolor = COLORSAND*max(0.0, dot(_light.d, n))*1.0;\n            #ifdef SOFTSHADOWS\n        \tcolor *= shadow(p, _light.d, 8.0);  \n            #endif\n        }else if(rm.y == TYPE_TEMPLE) {\n            vec3 c = texture(iChannel1, p.zy*2.0).rgb;\n            color = c.rgb*max(0.0, dot(_light.d, n*c.r));\n            #ifdef SOFTSHADOWS\n        \tcolor *= shadow(p, _light.d, 2.0);\n            #endif\n        }\n        // SKY COLOR\n        vec3 skyColor = mix(vec3(1.0), COLORSKY, uv.y+0.2);\n        float sunGrad = pow(max(0.0, dot(-_light.d, rd)), 4.0);\n        skyColor = mix(skyColor, vec3(sunGrad, sunGrad, 1.0), sunGrad);\n        // MIXING\n        color = mix(color, skyColor, 1.0-(FAR-rm.x)/(FAR-NEAR));\n    }else{\n        color = mix(vec3(1.0), COLORSKY, uv.y+0.2);\n        float sunGrad = pow(max(0.0, dot(-_light.d, rd)), 4.0);\n        color = mix(color, vec3(sunGrad, sunGrad, 1.0), sunGrad);\n    }\n    return color;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    \n    ro = roi;/*+vec3(\n        cos(t)*CAMDIST,\n        0.0,\n        sin(t)*CAMDIST);*///vec3(cos(t), 4.0, sin(t))*CAMDIST;\n\trd = normalize(rdi*rotY);\n}\n\nvoid lightPos(float t, out vec3 lPos) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    lPos = lPos*rotX*rotY;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n    pixel.x *= 0.6;\n\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = vec3(pixel, 1.0);\n\tvec3 lPos = vec3(0.0, 5.0, 0.0);\n    \n    ro.x = TARGETPOS.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    ro.z = TARGETPOS.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    rd = normalize(rd);\n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \n    ray_dir = rd;\n    \n    vec2 rm = raymarch(ro, rd, NEAR, FAR);\n    #ifdef LIGHTMOVING\n    lightPos(Time*LIGHTSPEED, lPos);\n    _light.o = lPos;\n    _light.d = normalize(ro+rd*rm.x-lPos);\n    #endif\n    \n    vec3 color = rendering(ro, rd, rm, uv);\n    #endif\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}