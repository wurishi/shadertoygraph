{"ver":"0.1","info":{"id":"4l2SzD","date":"1459037247","viewed":171,"name":"Marchtesting","username":"Exca","description":"just testing raymarching","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON=0.05;\nconst int STEPS=200;\nconst float MAX_DIST=30.;\n    \n//Distance functions\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 sphere(vec3 p, float r, float m){\n return vec2( length(p)-r, m);   \n}\n\n//Smoothing function by iq.\n//Great source for computer graphics: https://iquilezles.org/\nvec2 smin(vec2 ca, vec2 cb, float k)\n{\n    float a = ca.x;\n    float b = cb.x;\n \tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n    return mix(cb,ca,h)-k*h*(1.-h);\n}\n\nvec2 distFunc(vec3 p)\n{\n    vec2 b1 = vec2(box(p + vec3(1.,0.,0.),vec3(1.1+sin(iTime)*1.,\n                                               1.1+sin(iTime*0.7)*0.4,\n                                               1.1+cos(iTime)*0.2)),3.);\n    vec2 s1 = sphere(p+vec3(sin(iTime*0.3)*0.4, 0.,0.), 0.5,1.);\n   \tvec2 s2 = sphere(p+vec3(sin(iTime)*1.1, cos(iTime*.6)*cos(iTime)*2.,0.), 0.9,0.);\n    vec2 s3 = sphere(p+vec3(cos(iTime)*2.1, cos(iTime*.6)*cos(iTime)*2.,0.), 0.4,2.);\n    vec2 uni =smin(s2,s1,0.5);\n    uni = smin(uni,s3,0.5);\n    uni = smin(b1,uni,0.5);\n    return uni;\n}\n\nbool near(float cmp, float to)\n{\n   return cmp - to < 0.1; \n}\n\nvec3 calcLight(vec3 p, vec2 object, vec3 rd)\n{\n    vec2 eps = vec2(0.0, EPSILON);\n    vec2 d1 = distFunc(p + eps.yxx);\n    vec2 d2 = distFunc(p - eps.yxx);\n\tvec3 normal = normalize(vec3(\n    d1.x - d2.x,\n    distFunc(p + eps.xyx).x - distFunc(p - eps.xyx).x,\n    distFunc(p + eps.xxy).x - distFunc(p - eps.xxy).x));\n    \n    vec3 diffuse = vec3(max(0.0, dot(-rd, normal)));\n    \n    diffuse*=vec3(sin(iTime*0.37+2.9)+normal.x,cos(iTime*0.43)+normal.y,sin(iTime*0.27)+normal.x);\n\tdiffuse*=1.-mod(p.x,0.1)*3.;\n\tdiffuse*=1.-mod(p.z,0.1)*2.;\n\t\n    //diffuse*=object.y;\n    if(near(object.y,0.))\n    \tdiffuse=vec3(1.,1.,0.8)*diffuse;\n    else if(near(object.y,1.))\n    \tdiffuse=vec3(0.7,1.,1.)*diffuse;\n    else if(near(object.y,2.))\n    \tdiffuse=vec3(1.,0.9,1.)*diffuse;\n    else if(near(object.y,3.))\n    \tdiffuse=vec3(0.7,0.9,1.)*diffuse;\n\tvec3 specular = pow(diffuse, vec3(32.0));\n\treturn vec3(diffuse + specular);\n\t\n}\n\n\nvec3 setCamera( in vec3 eye, in vec3 target, in vec2 uv )\n{\n    float fov = 1.0;\n\t\n\tvec3 forward = normalize( target - eye );\n    vec3 up = normalize( cross(forward,vec3(0.0,1.0,0.0) ) );\n    vec3 right = normalize( cross(up,forward));\n\tvec3 raydir = normalize( uv.x*up + uv.y*right + fov*forward );\n\treturn raydir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv*=2.;\n    uv-=1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 eye = vec3(cos(iTime*0.1)*4.,2., sin(iTime)*3.);\n    vec3 lookAt =  vec3(0.,0.,0.);\n    \n    vec3 rayDir = setCamera(eye, lookAt, uv);\n    uv = fragCoord.xy / iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = eye;\n    \n    \n    float t = 0.;\n    \n    \n    vec3 color = vec3(0.);\n    \n    for(int i =0; i<STEPS;i++){\n        vec3 p = rayDir*t+ro;\n        vec2 dist = distFunc(p);\n        if(dist.x < EPSILON)\n        {\n         \tcolor = calcLight(p,dist,rayDir);   \n            break;\n        }\n        if(t > MAX_DIST)\n        {\n         \t//color = vec3(0., 1., 0.);\n            color = vec3(sin(iTime*0.37+2.9)+uv.x,cos(iTime*0.43)+uv.y,sin(iTime*0.27)+uv.x);\n\t\t\tcolor*=1.-mod(uv.x,0.04)*10.;\n\t\t\tcolor*=1.-mod(uv.y,0.04)*10.;\n            break;\n        }\n        t += dist.x;\n        \n    }\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}