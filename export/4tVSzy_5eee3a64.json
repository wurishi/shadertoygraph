{"ver":"0.1","info":{"id":"4tVSzy","date":"1484870530","viewed":95,"name":"UFO IN THE FOG","username":"XRNZ","description":":D","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ufofog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Blobs\n// Eric Galin\n// Modif Emmanuel Schmuck : \"UFO in the fog\"\n// densité du fog ajustable dans la fonction mainImage\n// objet : specular + diffuse funky obtenue dans shadestep\n// \n// \"aura\" dans la fonction Aura\n// fog en plusieurs couches dans la fonction mainImage\n\nconst float pi = 3.1415;\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=12.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\nconst vec3 blue = vec3(0.2,0.2,0.7);\nconst vec3 red = vec3(0.7,0.2,0.2);\nconst vec3 black = vec3(0.0,0.0,0.0);\nconst vec3 white = vec3 (1.0,1.0,1.0);\n\n// Transforms\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  p.z=-p.z;\n  float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n\n\n// Diffuse de Phong\nfloat PhongDiff(vec3 n, vec3 l)\n{   \n    float ph = dot(n,l);\n    \n    if(ph<0.0){ph=0.0;}\n    \n    return ph;\n}\n\n//Specular de Phong\nfloat PhongSpec(vec3 n, vec3 l, vec3 rd, float a)\n{   \n    //reflection\n    vec3 r = normalize( 2.0*(dot(n,l))*n-l);\n    \n    float diff = 1.0*pow(dot(r,rd),a);\n    \n    return diff;\n}\n\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  \n   float t=8.0*float(n)/(float(Steps-1));\n    \n     vec3 cc = (0.5+0.5*cos(50.0*t))*vec3(1.0,1.0,1.0);\n   return cc;\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(float i, float t, vec3 p, vec3 n, vec3 rd, int s)\n{\n    \n const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n    \n    float alpha = 30.0;\n\n\t//animation de l'intensité et couleur en fonction du temps\n    \n    float f = 0.5+0.5* cos(3.0*t);\n    \n    //couleur\n    vec3 c = ShadeSteps(s);\n        \n    c = mix(c,vec3(f,0.0,1.0-f),0.5);\n    \n    vec3 l = normalize(lightPos - p);\n\n    float diff = PhongDiff(n,l);\n    \n    if(diff!=0.0){diff+=PhongSpec(n,l,rd,alpha);}\n    \n    c = c*(i+1.5*i*diff);\n\n\n  return c;\n}\n\n\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453123); \n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat turbulence(in vec3 p)\n{\n    // Add scaled noises\n    float t=noise(p);\n    t+=0.25*noise(2.0*p);\n    t+=0.125*noise(5.0*p);\n    t+=0.025*noise(13.0*p);\n    // Scale\n    t/=(1.0+0.25+0.125+0.025);\n    return t;\n}\n\n\n//\"aura\" autour de l'objet, basée sur les steps de calcul\nvec3 Aura(vec3 cc, int s, float _smin, float _smax, float t){\n\t\n    vec3 c;\n\n    float mx;\n    \n    float offset = 30.0*cos(3.0*t) ;\n    \n    float smin = _smin+ offset;\n    float smax = _smax + offset;\n\n    mx=pow((1.0-abs(0.5*(smax+smin)-float(s))/(0.5*(smax-smin))),3.0);\n    \n    //couleur en fonction du step -> \"courbes de niveau\" colorées\n    c = 1.55*mx*vec3(1.0*mx*abs(cos(0.75*float(s)))\n                       ,0.0\n                        ,(1.0-mx)*abs(sin(0.51*float(s))));\n    \n    c = mix(cc,c,mx);\n    \n    return c;\n}\n\n//logistic curve\nfloat sigmoid(float x, float slope){\n    \n    return 1.0 / (1.0+exp(-slope*x));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //param de densité du fog\n  \n    float dens = 10.0;\n    \n    //couleur du fog\n    \n    vec3 fog = black;\n    \n    float moveSpeed = 8.0;\n    \n    \n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  //aller-retours vers l'objet\n  float a=iTime*0.5;\n  ro = rotateY(ro*(1.2+0.4*cos(0.1*moveSpeed*a)), a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n    \n  //diffuse intensity\n  float intensity = 1.7;\n\n  float t = SphereTrace(ro, rd, hit,s);\n    \n  vec3 pos=ro+t*rd;\n    \n  // Shade background\n \n  vec3 rgb = 0.75*white + 0.35*blue + 0.15*red;\n    \n\n    \n    //depth\n    float d = (t-rA)/(rB-rA);\n    \n\n    //courbe de densité du fog (logistic curve) normée\n    float b = sigmoid(d,dens);\n    \n\n    if (hit)\n  {\n                \n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\t\t\n\n      //objet blendé avec le background selon la densité\n       rgb = mix(Shade(intensity,a,pos, n, rd, s),rgb,b);\n\n          \n  }\n   \n    //param de temps\n    float dt1 = 0.10*iTime;\n    float dt2 = 0.06*iTime;\n    \n    //offsets de position pour les turbulences\n    \n    float offsetX1 = pixel.x +4.0*cos(dt1)+2.4*sin(0.3*dt1);\n    float offsetY1 = pixel.y +4.0*sin (dt1)+2.4*cos(0.3*dt1);\n    float offsetZ1 = 1.0*b;\n    \n    float offsetX2 = pixel.x +3.0*cos(dt2)+3.0*sin(0.3*dt2);\n    float offsetY2 = pixel.y +3.0*sin (dt2)+3.0*cos(0.3*dt2);\n    float offsetZ2 = 1.0*b;\n\n    //turbulences multiples pour le fog\n    float turb1 = turbulence(5.0*vec3(offsetX1,offsetY1,offsetZ1));\n    float turb2 = turbulence(12.0*vec3(offsetX1,offsetY1,offsetZ1));\n    float turb3 = turbulence(5.0*vec3(offsetX2,offsetY2,offsetZ2));\n    float turb4 = turbulence(12.0*vec3(offsetX2,offsetY2,offsetZ2));\n\n   \n     float f =  0.9*b+0.10*(0.7*turb1+0.3*turb2);\n        \n     f = 0.5+abs(f*f-0.5);\n    \n     //si on est sur l'objet, on attenue le fog en fonction de la densité\n    if(hit){f = f * b * b;}\n    \n    //1ère couche de fog\n    rgb = mix(rgb,fog,f);\n    \n    f =  0.5*(0.7*turb3+0.3*turb4);\n    \n    f = f*f;\n    \n    //si on est sur l'objet, on attenue le fog en fonction de la densité\n    if(hit){f = f * b * b;}\n    \n    //deuxième couche de fog;\n    rgb = mix(rgb,fog,f);\n        \n\n    \n    if(!hit){\n        \n        \n        float auraStep = 200.0;\n        float auraWidth = 150.0;\n        float mx = sigmoid(0.5+0.5*cos(0.1*moveSpeed*a),0.33*dens);\n        \n        //\"aura\" animée autour de l'objet\n       rgb = mix(Aura(rgb,s,auraStep,auraStep+auraWidth,a),rgb,mx);\n    \n    }\n    \n\n  fragColor=vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}