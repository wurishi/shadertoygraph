{"ver":"0.1","info":{"id":"3lVyRG","date":"1611238151","viewed":515,"name":"Gravity Probe Î²","username":"igneus","description":"If the shader errors or won't compile, try setting kTextureResolution to 0 in the Common source file.\n\nFull blog post is here http://benspencer.io/post/gravity-probe-pt0/","likes":23,"published":1,"flags":48,"usePreview":0,"tags":["sdf","pathtracer","mis","renderer","compressor","unbiased","lossy","jpeg2000"],"hasliked":0,"parentid":"WlcyDr","parentname":"Gravity Probe scratchpad"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////////////////////////\n/* \n   Copyright (c) 2021 Ben Spencer   \n   Released under the MIT Licence\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n \n\n   ************************************ I M P O R T A N T ***************************************\n\n   IF THE SHADER IS SLOW TO COMPILE OR NOT COMPILING AT ALL, TRY SETTING A LOWER TEXTURE \n   RESOLUTION BY CHANGING THE VALUE OF kTextureResolution TO 0\n\n   **********************************************************************************************\n    \n   KEYBOARD COMMANDS:\n   Hit a key then click and drag to adjust the parameter\n    \n   Q - Truck the camera up, down, left and right\n   W - Adjust the camera focal length\n   Z - Adjust the camera focal plane\n   A - Adjust the degree of chromatic lens aberration\n   S - Adjust the refractive index of the dielectric\n   D - Adjust the frequency and contrast of the zone plate test pattern\n   Z - Adjust the shape of the bloom in the x and y directions\n   X - Adjust the gain and gamma of the composited image\n   V - Adjust the saturation of the composited image   \n   \n//////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n// Film grain is the pattern formed by the heterogeneous distribution of silver particles accross the film medium. \n// https://en.wikipedia.org/wiki/Film_grain\nfloat filmGrain(in vec2 fragCoord)\n{  \n    vec2 uv = xyToUvr(fragCoord, iResolution).xy;\n    \n    float octaves = 0.0;\n    octaves += 1.0 * (texture(iChannel1, vec2(mod(uv.x * kFilmGrainFreq, 1.0), mod(uv.y * kFilmGrainFreq, 1.0))).x);\n    octaves += 1.0 * (texture(iChannel1, vec2(mod(uv.x * 2.0 * kFilmGrainFreq, 0.9), mod(uv.y * 2.0 * kFilmGrainFreq, 0.9))).x);\n    octaves /= 2.0;\n    \n    return 1.0 + (octaves - 0.5) * kFilmGrainStrength;\n} \n\n// Vignetting is an effect caused by composite lenses whereby the image appears darker around the edges.\n// Despite being an artefact of lens design, it is often applied deliberately as an artistic effect to \n// frame the image and draw the eye inward toward the center. \nfloat vignette(in vec2 fragCoord)\n{\n    vec3 uvr = xyToUvr(fragCoord, iResolution);\t\t\t\t\n    return mix(1.0, max(0.0, 1.0 - pow(uvr.z * kVignetteScale, kVignetteExponent)), kVignetteStrength);\n}\n\n// Samples a nice loading icon that's displayed for a few frames while the texture is being decompressed.\nvec3 loading(vec2 fragCoord)\n{    \n    // Define some constants here as derived from the main parameters in the Common source file\n    #define kLoadingMidpoint     (0.5 * (kLoadingOuterRadius + kLoadingInnerRadius))\n    #define kLoadingThickness    (0.5 * (kLoadingOuterRadius - kLoadingInnerRadius))\n    #define kLoadingThicknessSqr (kLoadingThickness*kLoadingThickness)\n    #define kLoadingCycle        20\n    \n    // Exclude anything outside the outer radius\n    if(length2(xyToUv(fragCoord, iResolution).xy - vec2(0.5)) > sqr(kLoadingOuterRadius * 1.2)) { return kZero; }\n    \n    // Define an arc that cyclically folds and unfolds\n    float phiStart = mix(mod(float(iFrame) * (1.0 / float(kLoadingCycle)), 1.0), 0.0, float((iFrame / kLoadingCycle) & 1));\n    float phiEnd = mix(1.0, mod(float(iFrame) * (1.0 / float(kLoadingCycle)), 1.0), float((iFrame / kLoadingCycle) & 1));\n    vec2 phiStartUv = vec2(cos(phiStart * kTwoPi), sin(phiStart * kTwoPi) ) * kLoadingMidpoint;\n    vec2 phiEndUv = vec2(cos(phiEnd * kTwoPi), sin(phiEnd * kTwoPi)) * kLoadingMidpoint;\n    \n    // Sub-sample this function so we get nice anti-aliasing\n    vec3 sum = kZero;\n    for(int y = 0; y < kLoadingAASamples; y++)\n    {\n        for(int x = 0; x < kLoadingAASamples; x++)\n        {\n            // Derive the uv coordinates in the range [-0.5, 0.5], plus the radius from the center\n            vec2 uv = xyToUv(fragCoord * float(kLoadingAASamples) + vec2(x, y), iResolution * float(kLoadingAASamples)) - vec2(0.5);   \n            float r = length(uv);\n            \n            // If we're inside the outer band, draw it and we're done.\n            if(r > kLoadingOuterRadius * 1.1 && r < kLoadingOuterRadius * 1.14) { sum += vec3(0.2); continue; }\n            \n            // If we're outside the perimiter of the main arc, we're done.\n            if(r < kLoadingInnerRadius || r > kLoadingOuterRadius) { continue; }\n\n            // The angle of phi, normalised to [0, 1]\n            float phi = (atan(-uv.y, -uv.x) + kPi) / kTwoPi;            \n            \n            // If we're outside the arc...\n            if(phi < phiStart || phi > phiEnd)\n            {\n               // If we're within reach of an endpoint, set phi to that point. Otherwise, we're done.\n               if(length2(phiStartUv - uv) < kLoadingThicknessSqr) { phi = phiStart; }\n               else if(length2(phiEndUv - uv) < kLoadingThicknessSqr) { phi = phiEnd; }\n               else { continue; }\n            }           \n            \n            sum += vec3(0.8);\n        }\n    }\n    \n    return sum / float(kLoadingAASamples * kLoadingAASamples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    kFragCoord = ivec2(fragCoord);\n    pcgInitialise(iFrame);\n    \n    // If the texture's not loaded yet, display the loading icon.\n    ivec4 textureState = getTextureState(iChannel2, iFrame);\n    if(kEnableTexture == 1 && textureState.y == kTextureNotReady)\n    {\n        fragColor = vec4(loading(fragCoord), 1.0);\n        return;\n    }\n    \n    // Compute and apply the second of the two bloom passes.\n    vec3 rgb = kZero; \n    if(kApplyBloom)\n    {\n        rgb += bloom(fragCoord, iResolution, ivec2(0, 1), iChannel0, iChannel2) * kBloomGain;\n        \n        if(kDebugBloom)\n        {\n            fragColor = vec4(rgb, 1.0);\n            return;\n        }\n    }\n    \n    // Fetch the rendered output and clamp it.\n    vec4 texel = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    rgb = max(kZero, rgb + texel.xyz / max(1.0, texel.w));\n    \n    // Adjust levels\n    ivec3 keyState = ivec3(getUserParameter(KEY_X, iChannel2).zwy);\n    float gamma = kCompGamma, gain = kCompGain;\n    if(keyState.z != KEY_UNDEFINED)\n    {\n        gamma = 1.0 / (0.5 + 1.5 * float(keyState.y) / iResolution.y);\n        gain = 0.5 + 1.5 * float(keyState.x) / iResolution.x;\n    }    \n    rgb = pow(rgb * gain, vec3(gamma));\n    \n    // Apply saturation\n    keyState = ivec3(getUserParameter(KEY_C, iChannel2).zwy);\n    float saturation = kCompSaturation;\n    if(keyState.z != KEY_UNDEFINED)\n    {\n        saturation = 2.0 * float(keyState.y) / iResolution.y;\n    }    \n    rgb = mix(vec3(luminance(rgb)), rgb, saturation);\n    \n    // Clamp everything to one so the film grain will composite correctly.\n    rgb = min(kOne, rgb);\n    \n    // Apply the film grain and vignette effects\n    if(kApplyFilmGrain) { rgb *= filmGrain(fragCoord); }\n    if(kApplyVignette) { rgb *= vignette(fragCoord); }\n    \n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*//////////////////////////////////////////////////////////////////////////////////////////////////\n\n   Copyright (c) 2021 Ben Spencer   \n   Released under the MIT Licence\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n   \n    \n   Description:\n   \n   This file is responsible for the texture decompression and internal state. The blocks of data\n   in the buffers below contain three representations of the input image at different resolutions.\n   Which resolution the decoder uses can be selected by modifying the kTextureResolution macro in\n   the Common source file. Larger images mean a slower compilation time than smaller ones. Older systems\n   are likely to struggle with the highest resolutions, so choose level 0 if compilation takes a long time\n\n//////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n#if kEnableTexture\n\n#if kTextureResolution == 2\nconst uint[] encoded = uint[](\n0x2000083u,0x90200u,0x86013fu,0x1ae01e0u,0x2200220u,0x22b023fu,0x23f023fu,0x23f023fu,0x23f023fu,0x23f023fu,0x23f02a8u,0x31a0347u,0x37e0383u,0x3b203f8u,0x3f803f8u,0x3f803fau,\n0x3ff0404u,0x4060406u,0x4060430u,0x47404a9u,0x4ec04ecu,0x5000526u,0x5260526u,0x526052au,0x5340543u,0x5570557u,0x557057eu,0x5a905dfu,0x6150619u,0x6270633u,0x6330633u,0x633063bu,\n0x63f0646u,0x6540654u,0x6540654u,0x65f068au,0x68a068au,0x6a006cdu,0x6cd06cdu,0x6cd06cdu,0x6ce06d5u,0x6e006e0u,0x6e006e0u,0x7030741u,0x7410741u,0x77907ccu,0x7cc07ccu,0x7cc07ceu,\n0x7ce07d6u,0x7d807d8u,0x7d807d8u,0x7e6080cu,0x80c080cu,0x82f085eu,0x85e085eu,0x85e0860u,0x8660867u,0x8670867u,0x8670867u,0x879087fu,0x87f0884u,0x8a008acu,0x8b108b1u,0x8b108b1u,\n0x8b108b1u,0x8b108b1u,0x8b108b1u,0x8b108b1u,0x8b208bcu,0x8bc08bcu,0x8bc08bcu,0x8bc08bcu,0x8be08c1u,0x8c108c1u,0x8c108c1u,0x8c108c1u,0x8c308dfu,0x8eb08ebu,0x8eb08ebu,0x8eb08eeu,\n0x8f80912u,0x91f091fu,0x91f091fu,0x91f0920u,0x92e0940u,0x9500950u,0x9500950u,0x9500953u,0x9630978u,0x9860986u,0x9860986u,0x9860987u,0x99009a0u,0x9af09afu,0x9af09afu,0x9af09b2u,\n0x9c109d6u,0x9e309e3u,0x9e309e3u,0x9e309e3u,0x9e409f6u,0x9f609f6u,0x9f609f6u,0x9f609f7u,0x9fc0a0cu,0xa0f0a0fu,0xa0f0a0fu,0xa0f0a10u,0xa120a18u,0xa180a18u,0xa180a18u,0xa180a1du,\n0xa240a2du,0xa2d0a2du,0xa2d0a2du,0xa2d0a2fu,0xa3c0a3cu,0xa3c0a3cu,0xa3c0a3cu,0xa3c0a41u,0xa4f0a51u,0xa510a51u,0xa510a51u,0xa510a51u,0xa510a51u,0xa510a51u,0xa510a51u,0xa510a52u,\n0xa520a52u,0xa520a52u,0xa520000u,0xa520a5bu,0xa710ab1u,0xb420c30u,0xbbbb5550u,0xe56f3298u,0xb2190fa3u,0x8a4a92fu,0xaba096fau,0x135da764u,0x340dbc3fu,0x91f42871u,0xd4d9ada9u,\n0xd9a497cdu,0x9aaeb844u,0xb7adae0fu,0x768e9bd0u,0xa41ca6b3u,0xfb721087u,0xae1958feu,0x65561b54u,0x3780a121u,0xf0d6613eu,0xe644617fu,0x7e0e9049u,0x290e9066u,0xf93b596cu,0xe1631971u,\n0x9da36a28u,0x6e731511u,0x2190209du,0x1f38e9c6u,0x37476e22u,0x35c132eu,0x6f59270eu,0x71b7ec7eu,0xc1e844f9u,0xf86055ceu,0x6d5fd00cu,0x61c9fabfu,0xb97614cfu,0x8ca1a551u,0x6690f912u,\n0xb252f1e3u,0xbcd3df12u,0xbbce6725u,0x41d5b08cu,0x7fb4dcc9u,0xeab48b12u,0xa7951d32u,0x16f89bf2u,0x8a03bcu,0x8d6eddfau,0x7a9f7d31u,0x8cb1732fu,0x4edaa072u,0x87aea3b0u,0xde0993c3u,\n0xcd7a3d91u,0x56e7dc89u,0xe23a34fau,0xbe2e7278u,0x1218586du,0x99d44972u,0x872ad883u,0xff4d9b82u,0x6af785au,0x73c67ef3u,0xd06bf8d5u,0x65e5f628u,0x9975c108u,0x1ed91dcbu,0x1387b842u,\n0x4ebe790cu,0x9fd3e4f7u,0x6851547u,0xc2e99988u,0x9eb2de29u,0x638af09au,0x45ac5e9eu,0x9b108c80u,0x4ec01f04u,0x22e852edu,0xa25a228fu,0xff9956dfu,0x56061032u,0x4ed0fa70u,0x978bc93au,\n0x409b5c80u,0xfca41bebu,0x8ad7318fu,0x5d8acd8du,0xd4fa914du,0x6e002456u,0x9082ac12u,0x3cc2527au,0xdf6ece82u,0x969dc54eu,0xce57618du,0x907abbc1u,0x5a6e6196u,0x4f12ccb5u,0xb203e203u,\n0x26fe87a3u,0xcfb4a8bau,0xdb21c66u,0xd5032554u,0x6fc668ceu,0xab81438au,0x13f12db5u,0xf9e25819u,0x5dabd18u,0xd5c45731u,0x794504d2u,0xfee358dbu,0xc5e1f675u,0xf303eea1u,0x6f9e2342u,\n0x7fd57630u,0x5fc73007u,0xfbcfd877u,0xd90a655fu,0x975114cu,0x1fb82133u,0xcccee0efu,0x6663ee16u,0x972af52au,0xa88687u,0x709b41e9u,0xf5f670bbu,0xd80c6e6fu,0x92014d41u,0x964b211au,\n0x694a97b7u,0x80f6366au,0x2bd5c9d2u,0x26163292u,0xca858e05u,0xb9615544u,0x7390c59au,0x2603124u,0xfaef296au,0x9229b095u,0x1cebd439u,0x3171eb6au,0xe323ececu,0xa55b2fcfu,0x27c4ab35u,\n0xfeccd293u,0x553b5339u,0x45579775u,0x59918233u,0xdc47654au,0xb0fe09beu,0xfa6eee7fu,0xd39aa52du,0xb08d788eu,0xb38cd68au,0xf0c7d3a5u,0x48ef2827u,0x876aef6u,0x3b0fe38du,0x1293c49du,\n0xd23f7807u,0x21c8b2c3u,0xbd24da8eu,0xd48a8503u,0x48b7ecffu,0xe0bdb3a6u,0xe7c9010bu,0x390ffe38u,0xe04fe729u,0xb9c9c51eu,0xeba5a27fu,0x1aed3f1du,0x4adf0f6cu,0xdeea625cu,0xbbbad6cu,\n0xa084599fu,0x60db43ffu,0x45d224cdu,0x970b151fu,0xde1d1a97u,0x2155ee5cu,0x423ab363u,0x86ee8f6au,0x7d2adb3du,0xe5299659u,0xb797b800u,0x0u,0x0u,0x1facd07du,0x14b2cc07u,0x6aeb285eu,\n0x401ddddfu,0x1f3c3f28u,0x8a548f16u,0x85af342du,0xf0f7f934u,0x17255546u,0x8b4b60ccu,0x33e42cb6u,0x25c914f4u,0xa52cb6d0u,0x57c7aba6u,0x9ab890fbu,0xe5bd220cu,0xd1cd6cc4u,0x8d2b94cau,\n0x65e79c73u,0x1b9cf6eau,0x80f623a4u,0x37e80e50u,0xc00eb332u,0xbdb92935u,0xdfdc46aeu,0xca452ebfu,0xc3d2772au,0x2aeebca1u,0x712a63c1u,0x8cda264bu,0x31375273u,0x888f8348u,0x51499c10u,\n0xd02ede97u,0x4089019cu,0x346bec59u,0x8b2690f5u,0x2c997999u,0xc75aa6c0u,0x12175d74u,0x87ffcd34u,0xc73d5367u,0x85c606f8u,0xf31cc146u,0xee0054a3u,0xc6d121d8u,0x6f3e3220u,0x75c7b67eu,\n0x13202e6fu,0x9e42c72u,0x25b1ff6du,0xb5e94753u,0x702770fau,0xeb51714u,0x5897f52cu,0x8dfa2e82u,0xe063b564u,0x73aea3b5u,0xb3cf7479u,0x28ee8daau,0x3b2c45c0u,0xf1905302u,0xfa2d1da8u,\n0x2050ca40u,0xc821a0f8u,0x1c9239a1u,0xceb5e530u,0x76f82f1u,0x8576f33bu,0xb885f87cu,0x80a58b25u,0x6779580eu,0x1c8842d2u,0xd3d5fbd3u,0x887cb131u,0x24fba1c0u,0x619b094fu,0x7fa609c6u,\n0x97aa1d57u,0x15a3e680u,0xc119f377u,0x3afcdccu,0x55859e25u,0xe6ca6249u,0x3f5f2666u,0x226d5738u,0x2f54433au,0x9d871946u,0xe02e7965u,0x46b49878u,0x5aae573au,0xad09d13u,0x9358d7c4u,\n0x78267e64u,0x4821ae03u,0xc61eb946u,0x49fe1343u,0x825641adu,0x4db78efeu,0xc178977au,0xd51cc4ccu,0xfe2a97e4u,0x700dd8b5u,0x577e9e9cu,0x873e7a32u,0xf26a1eddu,0x29e21ad2u,0xb1bd6a56u,\n0xab000000u,0x0u,0x9u,0xc36c874du,0xc91429b4u,0x6b056d77u,0x86de876du,0xf567fb34u,0x8512d837u,0x6c608ae2u,0xa86feeeeu,0x590fe0a0u,0x78f33a3du,0x854b803u,0x6b0905ebu,0x63bdbab9u,\n0x594b0dccu,0x418590ceu,0xeed66780u,0xca62f2b8u,0xbb298857u,0x852ad32au,0x4432f049u,0x57504848u,0xac828599u,0x729d627au,0x194e241au,0x7417a3dau,0xf4b106f3u,0xfd42ee7u,0xa756f3aau,\n0xb86280f5u,0x6e9bc98eu,0xad5a6caau,0x99ca5330u,0xd3f2f9e4u,0xc8183685u,0x41a2a215u,0x77440c0cu,0xb1a794bu,0xdf52a514u,0xe11e5dfcu,0x5d94a92du,0x718ebf83u,0xba8b3670u,0x2aa6c1bfu,\n0xb681492bu,0xdc04129du,0xbd70b994u,0x27ffd6deu,0x21e35966u,0x0u,0x325cu,0x44dd7674u,0x8bfbea54u,0x37e43012u,0x5a0766c9u,0x1c743d09u,0xb5b77d74u,0x16a4f581u,0x820bcbceu,\n0x747c8453u,0x17c8b1e8u,0xe05885c7u,0x8b1ca889u,0x9b9043f9u,0x89a7f020u,0xb92f1056u,0x1539dee0u,0xcddf47e2u,0x8c3c0e6cu,0xff506568u,0x2b13e472u,0x6e1cdc79u,0x18853b67u,0xd7eafe6fu,\n0x3cafd4fcu,0xd8ee39ecu,0x1f38481u,0xf565f582u,0x5b7dcc60u,0x8f13481cu,0x545d1c18u,0x9c24d22au,0x859559b4u,0x40856edu,0xc0b710e4u,0x5799fd10u,0x4f621ce5u,0xca91ccccu,0xebe5f1e7u,\n0x5af67d5fu,0x3fb58910u,0x26c11125u,0x45dc10eu,0xf6ac1478u,0x294eb89eu,0x3e4795c5u,0x9d697d38u,0xeb433240u,0xcb465314u,0xf8d9506cu,0x8ee8948u,0xe16d7302u,0xe391df11u,0x5211428fu,\n0xe8f26444u,0xf03c79bcu,0xd1d4db63u,0x1f26060cu,0xae6191du,0x5cebc7b3u,0x8f45b437u,0x5269907du,0x9d5a0000u,0x0u,0x4cc8d51u,0x2bb80cf6u,0xbad1b875u,0x43052243u,0x926601a3u,\n0x3bab98d6u,0x3f55b9cbu,0xefa03012u,0x250d7f92u,0xb0000000u,0x0u,0x2cd7e47au,0x39197409u,0x61875f49u,0x7d6e2a53u,0x7ef6c8bu,0x6304e84du,0x228906fcu,0x52524816u,0x2a1aad75u,\n0xedef473fu,0xb9f6fe39u,0x8867981u,0xa5d8af8fu,0x2c98c244u,0x9f2f1dcbu,0x3243602cu,0x4cce9518u,0x343cb8a8u,0x60000000u,0x5720eu,0x6699cc15u,0x1f78af38u,0xce20d1afu,0xba301836u,\n0x775bdd45u,0x7a864c23u,0xcf2842du,0x8cf77532u,0x74e12413u,0xcfe8ff14u,0x2043098eu,0xfb37b1bbu,0x5821c936u,0x44f41c36u,0xb017308cu,0x5006881fu,0xc1dbd471u,0x928a265eu,0xdc50b40fu,\n0x5a98f14fu,0xa31363cdu,0x23a12ad3u,0xb2fba52du,0x7b3b73c8u,0x88a6ec62u,0x2f2020bau,0xb3ab4b77u,0x38cdf90cu,0xaed9e3f5u,0x5d2ebaa1u,0x38e34040u,0xa0033955u,0xb11505a1u,0x93d70dedu,\n0x1cf2b3f3u,0xb432dc7u,0xfcdf4a70u,0xfa3598ecu,0x8ae0b954u,0x4ba8d3ccu,0xe1101a12u,0xa4fa1a8du,0xebc037e1u,0x2526e44u,0x303631e1u,0xbb6b4108u,0xa23af146u,0x3aa62b38u,0xdff544d5u,\n0x7fde4286u,0x6d885eb0u,0xcabd6c8bu,0xcacc0cd5u,0xa705fb5fu,0xa6303ba7u,0xfc0196a8u,0xc4b600c0u,0x6981f595u,0xdea0af5du,0x63f5aa31u,0x37861815u,0xe22415d7u,0xa668705u,0x8eb20a72u,\n0xc555c8acu,0xc0ade147u,0x8240f5c4u,0xa35f1bb9u,0x712e760du,0x60cd9332u,0xeaab1cdfu,0xd427d9a8u,0x3b9ce09cu,0x2b290981u,0x893a479cu,0x18b3e321u,0x1189bbb6u,0xa6f68f05u,0x8c49c4b8u,\n0x2d32e23au,0xaa5d1424u,0x1b3cbd3cu,0x52a28f8u,0xa2c98434u,0x82366069u,0x83c10ccu,0x35c555e5u,0xad130ceeu,0x9c1b148eu,0xc525e2ffu,0xc667003fu,0x25cb594eu,0x5618446cu,0xba36fe4du,\n0x2e86b649u,0x131022f9u,0x9c6b366au,0xe02063b3u,0x1fe2a38eu,0x21eb5f67u,0x7f1c1478u,0xe807d603u,0xbbc1f31au,0xdf800000u,0xaab2au,0xa742deb5u,0x8514737u,0x4fabf67u,0xa2a43756u,\n0x4b264427u,0x446e99d5u,0x43d3e90fu,0x8cdf62a6u,0x27f0f673u,0x4457c2c5u,0x59b6844cu,0x5b092aa2u,0x26f5da74u,0xddb17d80u,0x64c4c4a9u,0x817f9b9du,0xd241225eu,0xb3c2641du,0xbf7193ddu,\n0x50633e4cu,0x857fcb9eu,0x2df923ebu,0xb20fdfecu,0x6bc6516du,0xbe5b25b2u,0xd774bd62u,0x2dbc6d4u,0xba562bfau,0x11be4ab7u,0x8a0d618bu,0x6a0a330au,0xf4765534u,0x61d99bf4u,0xe7f8ebe0u,\n0x87d73e09u,0xfadeefb6u,0x75c889f3u,0x21790700u,0xf5c396dfu,0xa46c532fu,0x746451bdu,0x59683f42u,0x7b689718u,0x5eed2344u,0x6ab39dccu,0xd1348956u,0x254bfad9u,0xe1bad27bu,0x310777c9u,\n0x9a16dbc3u,0x8034d598u,0x7821ff04u,0x4989ac9fu,0x1dc579adu,0x68682e67u,0x1fdc7106u,0xfa6475aeu,0xb45e4826u,0xead0f73cu,0x3e4356ebu,0x72e38513u,0x593100cu,0xc995e79bu,0xa1cb5e3fu,\n0xcf2b71b1u,0x306b65b2u,0xa3051117u,0x8bcc0cdcu,0x27562dd5u,0x57d569e4u,0x4cb4e1f5u,0x2bd0545du,0x4dd413cdu,0x492911dbu,0xf4a7c8d4u,0x2a8acc86u,0x7b60e7a9u,0xf7904fb1u,0xcdfb14a8u,\n0xbc523651u,0x4811bb02u,0x53f1d51fu,0x9cecf8b1u,0x5eeeaa67u,0xfe28add6u,0xaa1a1c8cu,0x62aed07du,0x16094433u,0x43c7255fu,0x18c19f6au,0x640c30d4u,0xd0775fb6u,0xca8edeau,0xe0272380u,\n0xd5969be6u,0x1416eaa1u,0x69bcf475u,0x65f8763bu,0x609b8625u,0xcee0bb2du,0x5e23d7dfu,0x415af787u,0xc996b5u,0xace0eed0u,0x667ece02u,0x412eb3du,0x2ba5cd20u,0xfa4d87adu,0x57fab955u,\n0xaef5d2f0u,0xaf34e43fu,0x6b7e2f17u,0x4fbdb700u,0x1ac6f4bu,0x31d06cebu,0xe2875b13u,0x37d8bb04u,0x36091c67u,0x633d46b8u,0xe0f09a20u,0x578427c6u,0xd4cfe2e7u,0xdaa2edu,0x290021e9u,\n0xbb2a50fau,0xf0323470u,0x24353a55u,0xc8bb03a5u,0xe738c9au,0x48327019u,0xd3de1205u,0x8fc786ebu,0xd5a4093fu,0x18cc06eau,0x7ade349eu,0x66ca5615u,0xa9eca67du,0xfbbd8490u,0xe7402a49u,\n0xae17d37au,0xeda2cb88u,0x20eff9a1u,0x85beb7bau,0xdc7efe88u,0xf0009830u,0x4abfe8dfu,0x820881bau,0xd7f12c05u,0xaa9a652du,0xa9eee775u,0x66524e15u,0x5570332au,0xe113b8e3u,0xa4430208u,\n0x5c7b800fu,0x7f047ee9u,0x2425a16cu,0xca81ee00u,0xcdd229d3u,0xd3b0b53fu,0xa80e297du,0x1a2b00dau,0xd90ccfe5u,0x887d951u,0x2ece88a2u,0x285083bdu,0xbf52a3fdu,0xf7d81ed0u,0x35f3db29u,\n0x9f29223au,0x603a124cu,0xf9e012e1u,0x38261bacu,0xa8721dccu,0xcd493f49u,0xba9ca2b2u,0xcc6e02e2u,0xb61a80a6u,0xd0773299u,0xeca2697cu,0x90caede7u,0x20383b79u,0x3e41b83u,0x5f659f1u,\n0x2e148e96u,0xc1459d8bu,0x2a42dd1au,0x6e6d4c6du,0x1c290b99u,0xb91170e6u,0x6419ccbdu,0xf7c51c6bu,0x700e2346u,0xbe93084bu,0x389e4fdbu,0x43242637u,0xabee2279u,0xc9f9d96u,0xf708da4du,\n0x9880dd80u,0x6fa7a7d9u,0xf75e7025u,0x76119662u,0x50605f60u,0x4932320au,0x2aee2083u,0xeb637370u,0x8878bdcu,0x890d22eu,0xab04d7bcu,0x1805fbf2u,0x4c5b6b56u,0x92000000u,0x0u,0x66u,\n0x22ffff43u,0xf806e748u,0x2000u,0x61f958f5u,0x743b08b5u,0x38c5dbefu,0x6198f5f0u,0x70de58abu,0x1551dd6u,0xd6e1e16eu,0x5b9a7941u,0x2147b5ebu,0x5db712b8u,0xce35f139u,0x905c6edcu,\n0x75a829d5u,0x2b93349fu,0xc45cb404u,0xaac41507u,0x7d31e08eu,0xb2976dc2u,0xd8d0c691u,0x68e2761fu,0x237dc857u,0x6eeb66e9u,0xb0c1ba1fu,0x8d38383u,0xa01727a7u,0x25f78d26u,0x41d2bea0u,\n0xaf24451du,0x14228e82u,0x890d9aau,0xc52fc800u,0x13091149u,0x48770889u,0xe34b8e36u,0x7ff7c7e1u,0x2b4822u,0x252fde84u,0x57eb91e7u,0x6e2635f1u,0x285ef94cu,0x9a4dec87u,0xe5e4661cu,\n0x738113au,0x5794ee4du,0xd2375abfu,0x18ead107u,0xd2ce98a0u,0xf3351c38u,0xa7d1c4d6u,0x4afa52f8u,0xf10ce0d4u,0x7b547fbeu,0xfe7b1c95u,0x4ea8254eu,0xd609ccb3u,0x41740970u,0xe555ae14u,\n0x375afbb1u,0x1de31425u,0x34369d89u,0x2bcead4bu,0xea6cf176u,0xf925a0d9u,0x5aa6a4c9u,0x3f74ce1u,0xdb3705b5u,0x33449609u,0xc64e9572u,0xa55e2797u,0x1dca9c37u,0xe718b407u,0x4e74dbddu,\n0xd638fa3bu,0xa4e71bf5u,0x6146b472u,0x961f191eu,0xf8d7a1bfu,0xb7342aa7u,0xa82ac4bdu,0x9a410f22u,0xafc3da9fu,0x13b03526u,0xeee3f727u,0x24f562c5u,0xa853ce86u,0x820b5552u,0x98f7e814u,\n0x9dfaeda0u,0x7492e07fu,0xe5bcc0a7u,0x1428852bu,0xa8e27c73u,0xe4aaaf5eu,0x4968892cu,0xd2d4de9u,0x3df2e109u,0x3ed673c0u,0x8d5c3ab4u,0x5f00dc06u,0x336b6e13u,0x1ce00f86u,0xf21b3966u,\n0x9e0ef969u,0x643d7a3du,0x965878f5u,0x30972dacu,0x93f0d441u,0x70b3113u,0xa6e4e57eu,0xa25a03d9u,0xaab3c853u,0xd35bdfeu,0x7b1cd47fu,0x30218108u,0x33d46a25u,0x60a12bdu,0x80000000u,\n0xce3e3u,0x90000000u,0x23a350bfu,0xa4987946u,0xfadf3756u,0x5143ccb5u,0x80000000u,0xaf8cb8e0u,0x462e186au,0xe90a01cdu,0x8e4c39fdu,0xec3fc2eu,0x7248au,0x88500000u,0x0u,0x784cu,\n0x5d6387cu,0xe6229ef9u,0xd4b94b44u,0x74ebfe42u,0x5642d090u,0xb22132c0u,0x796c4fafu,0xf806f9c9u,0x161e375cu,0xc2c6046fu,0xe69ad2f4u,0x4af623f4u,0x4c62365bu,0x8ea1119fu,0xc4db1731u,\n0xe278f1b6u,0x584e40acu,0xe64b2aefu,0x4c6f5852u,0x459813a3u,0xf69a7c6cu,0xda25b8f3u,0xedeb1320u,0x7d264bbu,0x9c4f9019u,0xd44d9bc1u,0xa6ddc3ffu,0xf0d3724cu,0x272df807u,0x8fbb7603u,\n0x263796acu,0x9805c2f7u,0x8c5a711u,0x5596dcddu,0xfe2c1da6u,0x8e9dcfe4u,0xc8c3c2e3u,0xb6e76314u,0x16b9793u,0x78400000u,0x0u,0x60b6bd0u,0xb6bde5afu,0xce17748au,0x37041b8u,\n0x45ad7be7u,0xd66c61d7u,0xcc261019u,0x36947f1eu,0x1f1d303du,0xd534db74u,0x98448fd8u,0xe1012e5fu,0x7dee7f89u,0x9d45e8e3u,0x79a872e7u,0xada39ad5u,0xd8f928c6u,0x4f3002c5u,0xbe768eb1u,\n0xf9265507u,0x8e3adab6u,0x4e99782du,0xb9c51f93u,0xe896510du,0xdd89d81cu,0x3fe2a88bu,0xee771a4bu,0x36c05c59u,0xba478315u,0x9378905bu,0x4b59f0c4u,0xd87ce73cu,0x5593de97u,0xeb07db51u,\n0xf360ab4du,0xb5b4b00eu,0x5e09f608u,0xdf6cb8d9u,0x57083112u,0x60293db2u,0x9c5696b9u,0xa95bbcf9u,0xcfae2358u,0x118ea795u,0xa2cb0395u,0x3bab3039u,0xb540f263u,0xa131d835u,0xaff88943u,\n0x2e1b899bu,0x280a9f7du,0x5aefdb5eu,0xdaca8733u,0x711849c7u,0x9ff127cbu,0x5dfbb886u,0x10dc3daeu,0x6abe54e8u,0xc64085e1u,0xe668a82fu,0xa9a296adu,0xe70fe7aau,0x2b25a96bu,0xd0a0b37au,\n0xc5caab7fu,0xbb343f30u,0xc26b0000u,0x0u,0xd8a8u,0xf5aaaafau,0x7ebfb213u,0xced38e34u,0x226d74d6u,0x494dda1fu,0x4ccee543u,0x25ed09efu,0x5a4c85c8u,0x34b71e45u,0xe4afdedbu,\n0x66d5bfb9u,0xa3448035u,0x84b6a06du,0x157f76b8u,0xb20dbb57u,0xa31dad05u,0xaae75015u,0x2a0f92c8u,0xfaf61541u,0x33650966u,0x2d8d0f1u,0xb8d9e29fu,0xda52f3a9u,0x8758f2d6u,0x352b8297u,\n0x2276bb07u,0xf914e9c1u,0xc22f2681u,0xfdec0b81u,0x2d929803u,0x5291a973u,0xed1d7943u,0x334b2e9du,0x5eb1c9e5u,0x10060d0fu,0x4b86f0a1u,0xa3c8413cu,0xa7639e73u,0x46b34471u,0xbcb0e408u,\n0xb5add73eu,0x325465e4u,0x4aea6143u,0x82aec6a5u,0x8c4a3fa4u,0x617eee45u,0xe0f11a3du,0x88ff44c7u,0xd9a99531u,0x1d7e9eb2u,0x69154ff8u,0x0u,0x49f1d97u,0x3a549652u,0xa759c3d5u,\n0x52c71016u,0x54239362u,0xa64ac27cu,0x7d4796e1u,0x1909dddcu,0xa44603a7u,0xd53dd32u,0xab9dd8feu,0x7cf7e4ccu,0x9e1eb2a2u,0x1dabe17au,0xf6b64b98u,0x79a714bau,0x420bb5fbu,0x65a74c1eu,\n0x3723f792u,0xbdf17c37u,0x2d6ad21u,0xf8c6a029u,0xd997ad02u,0xbb3ed667u,0xf89c308fu,0xda87au,0x1e020795u,0x91cdaea8u,0x55104983u,0x6671b8ffu,0x1630e5e1u,0x9b7c7643u,0xf63ac042u,\n0x572fca28u,0x6636f37au,0xc97df1f6u,0x86616030u,0xf68728dcu,0x3c23c920u,0x181f424cu,0xe26edebu,0x6508effbu,0xb613c5ecu,0xe8249efdu,0xc49019c3u,0xb53f793fu,0x1218bfccu,0x8674c92cu,\n0x134b56a7u,0xbf663d8du,0xe3e866d9u,0xb3b6b5au,0xc2e77c10u,0x974dcc5cu,0xb5359b55u,0xca46bc8du,0x486f4d29u,0xd26761eau,0x167464c8u,0x8b6f57d8u,0x2c8c4854u,0x14cae87bu,0xf36ff428u,\n0x535c179bu,0x8d21b5dbu,0xc4500000u,0x89efbda7u,0xc5f3f5b9u,0x2fd6dbbcu,0x62b72643u,0xf33e69fcu,0x36a5d8fau,0xc7e67d15u,0x9d4daf7u,0xdf44cfeeu,0x67715104u,0x6a7c0fa3u,0x1bdaa1eu,\n0x3bd25a4u,0x3919f9ddu,0x66b4cb48u,0xbd151c8eu,0x3827f4b8u,0x80690394u,0xcd9596deu,0xc5100000u,0x81c60449u,0xe62203fau,0xfe9829beu,0xd4a2fdddu,0xeec65778u,0x3f3dd93eu,0xee612b0bu,\n0xb8f8f94du,0x726b1d88u,0x4947d253u,0x9035b144u,0xe1ed6c5du,0x7c9e2c4cu,0x932a81bau,0xa353ed19u,0x15c5f590u,0x29c00929u,0x75d93695u,0x18633b66u,0xae71e172u,0x15c30d10u,0x8fe58818u,\n0x51364084u,0xa48570d6u,0xc1374b1u,0x9bffc6f3u,0xc8076b08u,0x8ad64ff7u,0xdecf2928u,0xb05646aeu,0xc4e7f95u,0x32e006a1u,0x6db49914u,0x707f23c0u,0xdbb6cc29u,0x1fa33b48u,0xf64b54b7u,\n0xde91c480u,0xaaa09fu,0x4d035d5eu,0xfbf36c3eu,0xa0438000u,0xf187509eu,0xfcdba44bu,0x34618160u,0xf65c19f8u,0x939f8e6au,0x2856ba30u,0x6c11e6aau,0xd9155ec2u,0xd4b56a48u,0x8a80000u,\n0xec1e684bu,0x8bf42339u,0x3ec641b8u,0x783d732au,0x5a4b4841u,0x35183942u,0x69992531u,0x237f64d8u,0x4ecc5046u,0xd7595fb3u,0xaaad2c56u,0x6f5c2f18u,0x681f4f1du,0x6ede62bu,0x4000000u,\n0x8fe6af5au,0x49fa14ecu,0xe89829cau,0x8c4c9e5du,0xb9cc60ccu,0xd4e1ab18u,0x56c4db18u,0x485ca876u,0x872b16a4u,0xfdfa9e4fu,0x83e0196eu,0xa46ab865u,0xc0deda89u,0x452d725bu,0xb1821630u,\n0x6efb204au,0xf3ae9f86u,0x94448872u,0x40cbb474u,0x98801400u,0x1666062u,0x1140835du,0x7ba5b3cdu,0xa35a1089u,0xdd5e9b06u,0xd82731edu,0xc9f7f5fdu,0xd9a3cef5u,0x57ecddf8u,0x7f165e56u,\n0x79a6df1bu,0x31ec604cu,0xa59cb47cu,0x7423d541u,0x7988f8edu,0x40a57efbu,0x7e89056eu,0x8cc077c3u,0xe2aad3c3u,0xf54eab0du,0x6dc60246u,0x39354e5au,0x93c7c89au,0x9e218c72u,0xe2732e9au,\n0x6c0cf4fbu,0xa91e98du,0x5edc95b6u,0xda69ba7au,0xb750da98u,0x598788a9u,0xc287b752u,0xfb7bddeeu,0xbe2b3730u,0xd4231e37u,0xebc7b022u,0x2f8a8451u,0x128ac539u,0xd0000000u,0xebbdcad1u,\n0x1d1900d2u,0x27e1b633u,0x13b2f3acu,0xa41f2766u,0x3f838e24u,0x5e7f97d7u,0x3781298eu,0x2542faeeu,0x56397c60u,0xdb03aa7du,0xd6c87456u,0x369897cfu,0x26b031d8u,0xf49578c9u,0x9e381054u,\n0x4f6f7693u,0x93ebdfceu,0x27ca97ccu,0xf1a889fau,0x3d03452bu,0x801e04f7u,0x488810b9u,0x8e46a6fu,0x8a959fcbu,0x723a47d2u,0x81468327u,0x5356d3du,0x256120efu,0x8e5225c1u,0x6ec7d568u,\n0x69056e6cu,0xa5e37375u,0x92b0e99eu,0xcc392107u,0xad63eab0u,0xc3a142adu,0x55096a20u,0xb6093dbcu,0x7757cc6u,0x8c3bd71fu,0xd14b8535u,0xd8000000u,0x14416f4u,0xdde16fd3u,0x33138d0u,\n0x64e2ea1bu,0x2749c77au,0xad4dbf00u,0x89ff9319u,0xb30471fu,0xb8c23e1du,0xf3d8ddb4u,0x1ff09c9du,0x5412fd26u,0xefa9afd1u,0x7f19fa5cu,0x59cb4ed9u,0x9f0ca536u,0xe4e29b4u,0xad5d380fu,\n0x3cd7a7a2u,0x1f4a27ddu,0xbf7d9980u,0x914e6eeu,0x9491b33fu,0x629db7dfu,0xa963661cu,0x65b7e032u,0x93703aa1u,0x8d25fb42u,0x9ce14b2u,0x3a9f8c60u,0xff604b0eu,0xf99b94a5u,0xab8f98e0u,\n0xac47661u,0x1c719a75u,0x6eb05aa2u,0xf63d5281u,0x5e73abefu,0x8bbd38cau,0xe01e5b33u,0x424daa95u,0x7f030d90u,0xf3af382u,0x7e47f755u,0xea87e927u,0xa20edc96u,0x9d15de93u,0x2d010ed9u,\n0x5e3d876du,0x3ea2313u,0x5ba2381au,0xfea29a90u,0xd63d6e91u,0x8b954aa8u,0xe4ff9a28u,0xc7670467u,0x25a6f4b9u,0x1e21c2b9u,0x56c15f44u,0x5429409du,0xddb96138u,0xfb8aff2au,0xb6e71aa6u,\n0xda3df19bu,0x91aad6fu,0xc0d96656u,0x3c359f97u,0xef5f4374u,0x268d80ecu,0x2f0c66f2u,0xfe8daee3u,0xf278aeceu,0xd6e84a07u,0xfb1cf685u,0xf19c76bu,0x7be04072u,0xb20e21b3u,0xac1d8bc1u,\n0xb56fc015u,0xfa59e516u,0x71b6bcceu,0xb1090d28u,0x36b784c7u,0xaa8440f2u,0xfbeffdd6u,0x178115d6u,0xbea3f030u,0x4ac1e526u,0x6d2d5a28u,0xcadec9fau,0xe6bd2f78u,0x6d8c6882u,0xa800d418u,\n0xa6c4e823u,0x6bab8fceu,0x13b8e0fu,0x278778e4u,0x837ff810u,0x2ab966aau,0x1b2faf19u,0xaa04357eu,0x2501c585u,0xa4c57245u,0x4a4d27d0u,0x3ba95b26u,0xae628866u,0x5da8e49u,0x42f94000u,\n0x0u,0x160u,0xb23c4000u,0x1u,0x6225f94fu,0xfef6652bu,0x9b5429c5u,0x1be18190u,0x6c465c5cu,0x973b1afu,0xd06da8e4u,0x1a51fac2u,0x8cfc9976u,0x537bf4d8u,0x2460cc9eu,0xf9b221e8u,\n0x12eb270u,0xe4000000u,0xe5fd64cdu,0x23ccd44au,0x1fd50163u,0x8c6dd071u,0x48b4b29eu,0xc05ca660u,0x5fe5ce6u,0x16d89c8cu,0x54c94d05u,0x3da36d19u,0x4e08c35u,0x547f8000u,0xfc074dbeu,\n0xe3b3c4d7u,0xc767c29cu,0xde77bcb2u,0x76a43677u,0x330425f0u,0x9ec22317u,0x9f95e40u,0x614028d9u,0xae27907fu,0x3d3fab78u,0xa0000000u,0xfe950caau,0xa2cfa15eu,0xcce4452du,0x3655e89du,\n0x3fd1d667u,0x51207eefu,0xa2980000u,0xec8c6b1eu,0xa9cb2574u,0xd58bd920u,0x66fa49c6u,0x3e8c2680u,0x414d2b41u,0x924d6fe3u,0xc77c3924u,0xf1631e91u,0x575454b2u,0x422be013u,0xd9fe0a58u,\n0x37b06c7du,0x1df01800u,0x3u,0x5f368c2eu,0xb1014f20u,0xa61e97b6u,0xc264ee44u,0xff67af97u,0x1c6c7aeeu,0xf6441f44u,0x741b212bu,0x7ff48b7bu,0x54ddbb80u,0x23u,0x7c46b4bu,0x4532107eu,\n0x2931285cu,0xca3acc59u,0x3730f91cu,0x11821210u,0x6b993f8u,0xb40edb4au,0xbb1a2dbu,0xb8d5559du,0xf94a0013u,0xcc7b2088u,0x63d69f21u,0xb516f6adu,0x6a928287u,0x76178640u,0x48a1af31u,\n0x6bdafa14u,0xd4442e6au,0xcf0dbea2u,0x3c76f6f9u,0xd6d8c2c0u,0x3176bbf6u,0x8031d125u,0x5035b036u,0x856c15c8u,0x91041ba6u,0xda6e0447u,0xf79bbf65u,0xfba1b881u,0xf00b7487u,0x8e49d47au,\n0xd6ea8123u,0x10759b7eu,0x35a8d11bu,0x829868du,0xfed78209u,0x725f7938u,0xdf4e12c1u,0x59937c46u,0xf0e30583u,0x20000000u,0x2u,0xb2fa3b0eu,0x6f48edafu,0xf5627cbfu,0xe58622c4u,\n0x19d08298u,0x44703a70u,0xab9768ddu,0x12ae9cc8u,0x6c81802au,0x52107d3fu,0xcc86bf7bu,0x891c8cc3u,0x5f9ed552u,0xf74b1348u,0x40ef5b9cu,0x6528005du,0x61b53313u,0x3ea2e256u,0xed76db38u,\n0x1a34a488u,0xaff7dd54u,0x2u,0x885b9ecfu,0xd1b06636u,0x831064f2u,0x69bcbd01u,0xa31f99ddu,0x5faf6783u,0x28f9acaau,0x36b2b930u,0x32f624f6u,0x76cfe344u,0xe206f3deu,0xded8023du,\n0x953de1u,0xf4478157u,0x5947e2adu,0xa524875eu,0x2906e8abu,0xc969705u,0x2cd65fb9u,0x8c4ed272u,0x75f1b49du,0x4a1a9258u,0x5eb7af7fu,0x967561d4u,0x89ec1a59u,0xabe8098bu,0x49484233u,\n0x17bcb376u,0x87735c35u,0xdf3554f5u,0xf0ef074bu,0x71443411u,0x9c25510au,0xc05933a7u,0x2d952268u,0x81b1f027u,0x995a56f7u,0x1486e075u,0x9e997936u,0x8e7bbceau,0xe6c54ea1u,0xffc5e3eu,\n0x7d7af094u,0x51342000u,0x5be600u,0x42d89ce8u,0x4c195f1eu,0xaf485118u,0xcb8f1d8bu,0x1b3f8f93u,0x9b943d22u,0xbb780000u,0xdd6aeefdu,0x7919190fu,0x51c8ae8du,0x7a030cddu,0xc24d4297u,\n0x923cc007u,0x387954cau,0x79a0cf82u,0xc7c7b183u,0xb76f932cu,0xa4c70540u,0x2ba7c3c6u,0x81ed984bu,0x766cc626u,0x38db5823u,0x9dce4097u,0xf11ee25eu,0x9747e817u,0x27c4a848u,0xf0a802e3u,\n0xd6c6ea00u,0x67f321eeu,0xfcf02679u,0x392ef6dfu,0x52194539u,0xe9f1ec36u,0x64c49617u,0xa1531f57u,0x5a65dfc1u,0xa45ece77u,0x9cca67eu,0xd3ae76c2u,0x26b8fd64u,0xbb6b1e4au,0x651bf317u,\n0x13e421a4u,0xc349c568u,0x3f189cbu,0xfda9eba6u,0xdca84d4cu,0x23bc875bu,0x2962b33au,0x6ca4315eu,0xf78a8e89u,0x9b46d1d6u,0x5c0c8000u,0xf0a91a2cu,0xc4d8b03au,0x61026b00u,0xe7b85db8u,\n0xb17d47b6u,0x6d5b9961u,0x8251c27u,0x86e33647u,0x35d8036u,0x868bb544u,0xa919470cu,0x3b6db3f9u,0x3a4a8134u,0xb0d86b29u,0x4702198bu,0x6c23e8f4u,0x7d9747ffu,0x70f3478fu,0xddaddc1fu,\n0xa133c25u,0x9309698bu,0xc7836a5fu,0xb61187cbu,0x926f27du,0xb90baf9cu,0x2d521ce3u,0xa31007e8u,0x34f9bac4u,0xf68573fbu,0xd4b4dec6u,0xfcc8c95cu,0xbc9af789u,0xf7687446u,0x522beb6u,\n0xf2de37b3u,0xca436d69u,0x4b7917d9u,0xe30f3c1cu,0xd15dd174u,0xd6e35f38u,0x2244039au,0x344ea81du,0x245a9fffu,0x49e02c6eu,0xe837aacau,0xdd357574u,0x26eeefeau,0xaa2992f4u,0xdac81afeu,\n0x387a43d4u,0xe7a27d1au,0xa2081209u,0xdb72d667u,0x12214d35u,0xe09f98c2u,0x80c73470u,0xb8a3e2f0u,0x2cadcbb0u,0x253f77e6u,0xf894bc94u,0x34f9d412u,0x3a900000u,0x3890b4ebu,0x114ecf34u,\n0x6fe9a013u,0xf385375bu,0x1f485dc3u,0xb8dfd0ceu,0xa57e26ecu,0xfef09dcfu,0x98fcc89fu,0x17665a4bu,0x25a78ae3u,0x40d42cb6u,0xf6c05fdcu,0xc0b52974u,0xd75dd7ecu,0x2fe58784u,0x14198874u,\n0x76f21c1eu,0x4a89731fu,0x9056d171u,0xb9a9a869u,0x942e4dd5u,0x1c72bcc7u,0x28b61b7bu,0x4335b94bu,0x8cc4ef61u,0xf5cac340u,0x1f6c02deu,0xf4871f25u,0xc063401au,0xbe6539e4u,0xc7a670acu,\n0x69ae54aeu,0xbe089349u,0xae8465e1u,0x51f16ccfu,0x4e79791cu,0x41a707a3u,0xf2ad8341u,0x40e77f5cu,0x7cdb62dcu,0x92d1c5d8u,0xb54bdd3du,0x587ec695u,0x1404459du,0xc0a318dfu,0x86af4b2bu,\n0x14db98f7u,0xef472fd5u,0x5ce47e17u,0xbd0f02ebu,0xf8eb6740u,0x334b3f83u,0x29c4ebb5u,0x234b8b42u,0x6c000000u,0xfe4e8d84u,0xa0dd2419u,0x5564dee0u,0x390ebba9u,0x64064cc5u,0x61671c23u,\n0x1fe11c0du,0x245b0c7fu,0x2b2ab060u,0xf41cc7b4u,0x2bfa6cbu,0x8f2243aau,0x47a6be27u,0x36ee707fu,0xdd89632au,0x1ee0a9e3u,0x8f24eeb0u,0xa93d0c66u,0xb5c01d36u,0xaa17f5a4u,0x4ad7dff4u,\n0x6f7ea7a2u,0xfb6307d4u,0xefb120bcu,0x71573ed9u,0xac5d06cau,0xcf0e1920u,0xf914a054u,0xbc905134u,0xfd7779a4u,0x4fc1d2a7u,0x46ff6c2du,0x3240d215u,0xd8b6ad2u,0xd80cd5ecu,0x88a52bccu,\n0x1534168bu,0xfed5efdu,0xb04c18fbu,0x730a30dbu,0xc5c7b29fu,0xf1e6bb48u,0x78bae390u,0x8fcc1591u,0x89acd1ebu,0xc5d50e6u,0xfbfddc4u,0xbe3c80cbu,0x291ddfccu,0x76bd667cu,0xf313df95u,\n0xeada28ecu,0xaf0ff9d4u,0xf4fa7ee2u,0x674c9d36u,0xe5a96ddfu,0x42350e28u,0xa23d5bbu,0xac00bfe1u,0x637a4292u,0x589285ebu,0x82b7ea9cu,0x68532cd7u,0x96c7e8fbu,0x4f2f4df9u,0xedffdd6bu,\n0x1d793428u,0xc10894cfu,0x235f296cu,0x9b489b57u,0x510a8924u,0x1d85dc10u,0xd066d4d3u,0x52a28d72u,0xf67ce5d2u,0xb7267a00u,0x75ef2551u,0x2be7661au,0x7fc03b60u,0x8efae809u,0xd768c2e2u,\n0xc2dd7316u,0x6a400000u,0x2878du,0x6a500000u,0xd87c6e2du,0x46568911u,0x88908adeu,0xfb79f688u,0x2f3a2899u,0xe1573143u,0x20c559edu,0x58000000u,0xfea571a3u,0xbc000000u,0x2bb167c7u,\n0xe56638d4u,0x736340b7u,0xee7371b6u,0xa675c4a0u,0x6863659du,0x5a35e859u,0x5bfd6011u,0xcd27222cu,0xeb4c3cb2u,0x4d9bafa1u,0xe27178e7u,0x5fc7bb6du,0x1ccf71b0u,0xe05d4bbfu,0x3af547c7u,\n0xb05ce9f7u,0x3ec4b5au,0x1e0a730du,0xe08f5461u,0xfe67de2eu,0x4ea257b3u,0xc442e9e7u,0x591460ecu,0x3a3d5b1eu,0x3060fc18u,0x6a464426u,0xaa650513u,0xafa1e0c1u,0x75ec86f7u,0x76183d9u,\n0xe59206fu,0x4ab74a57u,0x93ed28e8u,0x36187658u,0x93529052u,0x6ec745d3u,0xe43bcf94u,0xe35803e2u,0x44e4247du,0xd483c80au,0xf7e5e182u,0xa7c87376u,0x78dc5eceu,0x6449d774u,0x228362c2u,\n0xb1760032u,0xc6ea1024u,0x113d979bu,0x38521492u,0xc0ba9a88u,0x79f48600u,0x34428fd8u,0x85030ecau,0x343b6132u,0x6346b211u,0x3fef7904u,0x358d51bau,0xa877b1d1u,0xa720249du,0x6d4fba37u,\n0xa4ec1492u,0xc11b4878u,0x764bb075u,0x556527b4u,0x2ae25784u,0xa84a4b7fu,0x4b722ca4u,0x74b22724u,0x1cfd5f33u,0x3152fcbu,0xe66deda4u,0x5cf48b7fu,0x3ddafd4au,0x75e7762eu,0x54540036u,\n0x6b62d24au,0xf5062ceeu,0x55e1806du,0xd1a78f4cu,0x2d48dab7u,0x1b41f1fcu,0x924a49b1u,0x7ca793f0u,0xbe5748f5u,0xe6d65585u,0x91f99db0u,0xf1117273u,0x1b5aa130u,0x84c5fc5au,0xa7ffd707u,\n0xb94e09cdu,0xdf0f48feu,0xbf6e6ebau,0x5c4bfad4u,0xf833b221u,0x8d945452u,0x44861c6u,0xf7084aafu,0xb007a462u,0xd4da1482u,0x1589790bu,0x15a54bdfu,0x83e34d90u,0x8d5fe305u,0x975792c0u,\n0x38c7be40u,0x2505f65fu,0x719ef3eeu,0x2f6e2f6au,0xce7621c9u,0x9b3bb822u,0xa541850bu,0xfcec96d0u,0x795e7183u,0xfbf6de2fu,0x96478bd1u,0x4ae6907bu,0x58ab0524u,0x3f2f70efu,0x6c248187u,\n0xa6b41987u,0x5104b256u,0x56565c02u,0xe01ef329u,0x1b6237e5u,0xbeb345e1u,0x8d8da69eu,0x866d1d44u,0x68c23087u,0x10b454ebu,0xd1d186b1u,0x87a41fb5u,0x6800000u,0x46926012u,0xc39f6800u,\n0x191992b8u,0x68934fd8u,0x5c7561bu,0xee5e0a18u,0xcc162bdeu,0x91c00000u,0xe874d30au,0x55c552b4u,0xbf0636f8u,0x8f6152c3u,0xd7c5d9e2u,0xb734163eu,0x4d3670c9u,0x6585ae06u,0x46c4f2e7u,\n0xab916d2bu,0x42ac0999u,0xc2cef1f1u,0x7ca2ef34u,0x25a1fb30u,0xca4e9db6u,0x209a6bacu,0x971623fu,0x810cb220u,0x40u,0xecb8ba89u,0x93092adcu,0xd502dfbcu,0x5c6a000eu,0x7cb6ca89u,\n0xf416e600u,0x0u,0x1c635u,0x9e2f671au,0x40cd0840u,0x40000u,0x655f6234u,0x2f3cdfaau,0x881d32afu,0x7cfaf755u,0x92182e53u,0xf41a55b1u,0x79b7526cu,0x7762afcbu,0xf3ed2c9bu,0x5709b182u,\n0x2511b8c1u,0x73dfee0eu,0xfb329698u,0x1f2194deu,0xb5068fb2u,0x9224457bu,0x6987c8deu,0xd97fd62u,0xbbb3c25eu,0xad5add7cu,0x4a0b9181u,0xf2b6f54fu,0xf9ab1665u,0x5832a492u,0x73f845d1u,\n0x67d56d25u,0xcc027bdfu,0x132c0000u,0xfd38d35au,0xb8da474eu,0x1d58ff8bu,0xb4b90a8cu,0xa571bec1u,0x5fae2275u,0xb3d34463u,0x8910aff9u,0xc1d337f1u,0x7583887cu,0x47d05b36u,0xe0000000u,\n0x1c53u,0x7a486d00u,0x0u,0x0u,0x8000000u,0x20dc00u,0x7596a5u,0x20291692u,0xc698e906u,0xd461d89du,0xabec3e68u,0xaef2bdb7u,0x902b56b7u,0xd45a8eadu,0x58f7488du,0x31abf900u,0x61a417u,\n0x1a000000u,0xd0b0c2u,0xc51d4a3cu,0xad514000u,0x619d479du,0x4e21dc00u,0xfa9e7f50u,0x3e635553u,0xc8a5a67au,0x2755e41cu,0xf96e7e42u,0x2f5bb66bu,0xf89dc927u,0x595b7e60u,0x735d5df9u,\n0xfd4086b9u,0xe20d7e52u,0x10cd6adau,0xff3a67a6u,0x49d5b278u,0x7e047fa1u,0x83b3cb04u,0x9403585au,0x8d1da824u,0x8447d987u,0xb0bd219du,0x4134ff3cu,0x3cc2f2fau,0xd47aa22u,0x61a05545u,\n0xcdabc3aau,0x55be0517u,0x6747b25u,0x30000000u,0xcd5bb22u,0xe94772a2u,0x2c6e2c3u,0xdb37c66au,0x6a58184au,0x9e56842fu,0xf421e4bcu,0xb8d50f04u,0xafc7a9d2u,0xfa883fffu,0x85cf2ec6u,\n0x24346c00u,0x43b6f3u,0x4510f993u,0x48b04880u,0x875bab4fu,0xfb43eefau,0x7f38253eu,0x35fa4d48u,0x759c9d98u,0x3b2d0ca3u,0x791848a0u,0xdc9c75fcu,0xc53844b4u,0x5a3e62a4u,0xea6adba8u,\n0xb3ef152bu,0xbe3654f7u,0x7ad934f0u,0x272638bcu,0x7d31ca80u,0x7fbb98adu,0x99781b0u,0x1a4e5c35u,0x985b5d0au,0x7eb2073u,0x2e8f17ebu,0xd8530b7fu,0x7d98cbbdu,0x97d9b3ecu,0xbc946949u,\n0x16f897f7u,0x721d2610u,0xb9c454fau,0xa2639e65u,0xfcedfb88u,0x4412519du,0x71f79fb1u,0x35903e16u,0x971cc65bu,0xa0a2b100u,0x6273837u,0x16f9e1ecu,0x53e48728u,0x4d436ee2u,0xd2b0ddd7u,\n0x2deda3d8u,0x728ecca8u,0x8cdb9f18u,0x858a87beu,0xb01dd307u,0xbafe7da9u,0xf0c4c382u,0xbc16eef0u,0xfb200u,0x844590d5u,0x94cf70b0u,0x7826b920u,0x7b8c3a3fu,0xd7f5a8dbu,0xa3fcf169u,\n0xeb942304u,0xc556bfa9u,0x448c662bu,0x58eaf316u,0x117e9f01u,0xb1fedb0fu,0xa4195c5cu,0xd4900000u,0xffae6691u,0x2ca269c8u,0x53e7525au,0xaa5619c1u,0x4a3a48a8u,0x4742d061u,0xaaa60b0eu,\n0x2f03f9b1u,0xb4a193f1u,0x7d108d1bu,0x67d0764au,0xcf8504d8u,0xa75b5c6au,0xef772901u,0x853de69bu,0x4f338c8du,0xd59a1aa6u,0xbd9e0000u,0xf453927eu,0x79e89650u,0xeebbd364u,0xdb236065u,\n0x8e3cd94eu,0x3e132cb9u,0x3eda6e30u,0x8bc0b4e6u,0xcc526292u,0x2bde9910u,0x843f1d54u,0xdd7a7215u,0x2d2b35bbu,0xab8fecdau,0xfac6f9c3u,0xc0000000u,0x1f7c4au,0x5388a2beu,0xe8000000u,\n0xef1a34c5u,0x4f610aacu,0xdeac04c2u,0x9507a4bfu,0xc562ce72u,0x8c23f478u,0x569a6443u,0x83d1409bu,0x77927e05u,0x733acd5fu,0xc1d75df9u,0x154e4b0cu,0x52820e56u,0x11ccf6eu,0x3ab560b8u,\n0x5cc0000u,0xfaa15dd0u,0xfd1f251eu,0xfea426c5u,0x7740889fu,0xe64a3a35u,0xc56b7157u,0x11d7ec02u,0x23313cb1u,0xec86d506u,0xd265a595u,0xc3425690u,0xce614904u,0x64d4f27u,0xa23518adu,\n0xfc6ee64du,0x818f694du,0x8533d829u,0x99e209f2u,0x62d5e579u,0xbd9213cu,0x78000000u,0xdc5111edu,0x39fb9a78u,0x45b0250cu,0xd23ac128u,0x1b12cb97u,0x2301f92eu,0x8535832fu,0xad21019eu,\n0xb77d9a3au,0xed52c0c1u,0xcdda762cu,0x2db0be0bu,0x6f1b46adu,0xd0000000u,0x19fab08u,0xc29ed036u,0xde692908u,0xebd4a05u,0xd6d0abf5u,0xc790ea63u,0x23efb1f3u,0x41d94444u,0x89f05238u,\n0xa059cc00u,0xfea44274u,0x261d6f06u,0xd8eadcb5u,0x3adc62f3u,0xbd0598eau,0xd9245e8eu,0x9d569007u,0x76db24eeu,0xb7520481u,0xe4f1ef13u,0x12789742u,0xa3f69b16u,0xe61883b5u,0xd084cc4au,\n0x789763a7u,0x24000000u,0xf817577fu,0xe8846575u,0x286f3b20u,0x1dc101cbu,0xd1620082u,0x878985f2u,0x39f6ebd0u,0x7a9ff6fcu,0x230ce8c5u,0x9f3549u,0x48c6e7c9u,0xf895451cu,0xfd65db30u,\n0xac847245u,0xba3de2e0u,0x7acddce2u,0x16e71152u,0xa8000000u,0xd460563bu,0x28a5384eu,0xfb1b8412u,0x48b5f89cu,0x8f8e7fd0u,0xf5420307u,0x12afa24bu,0x60260f58u,0x6b9f5d8bu,0x501f73f6u,\n0x73f6c36du,0xfa928ab0u,0x1ef93641u,0x66d4cab4u,0x3f800000u,0xf047a5d7u,0x16526412u,0x564f3103u,0xa2a406dbu,0xb8fd9908u,0x5654c8bau,0x689a40d9u,0x79067926u,0x76b55614u,0x42bd7126u,\n0xb9900bd0u,0x3482d8fbu,0x3f0b1c1u,0x2855b2ecu,0xad4e66fau,0x53f44311u,0x18694849u,0x113f59f4u,0x6895a253u,0x1d69ea00u,0xc763bb58u,0xea6f27b7u,0xfc9929d5u,0xf89094deu,0xe06cc1bau,\n0x1d6548bcu,0x1835c63u,0x33eef882u,0x9657a366u,0x28682e46u,0x63133d2eu,0x912ac6ddu,0x613c6231u,0xa4c4a240u,0x94400u,0xbdd6b937u,0xe86d5b39u,0xccf2ef2du,0xd96af114u,0x7de1058eu,\n0xea9949bdu,0xd36725cdu,0xeae097dbu,0xb8459863u,0x9db5aca0u,0xb439080au,0x9555725u,0x877afca1u,0xd38f9dd3u,0xbfc9e654u,0xe86cff2u,0xc71900a8u,0xc09245a0u,0x8bdd6be6u,0xed97f6aau,\n0x2965f74u,0x4f3aeebu,0xd6c60961u,0xe69f0000u,0xc26eae34u,0x6a8d2be4u,0x6ccefc14u,0x8d866c30u,0xbbfd3c98u,0xcd7a5d1bu,0x2377ee09u,0xd7dbc6d2u,0x68478308u,0xe06dfbb0u,0x78705031u,\n0xcdca114bu,0xc95c9534u,0x95ab6289u,0xe4c6af24u,0xc61b0000u,0x51c94766u,0xb0aec326u,0x779c8000u,0x27600u,0x143d7cu,0x6e000000u,0xd8e45e93u,0xcc37938du,0x76f9354u,0xe66f98e0u,\n0xf06a4e7cu,0x872c8be8u,0x6605c329u,0xdbe3e6cbu,0x886fd417u,0x13d9bd33u,0x3dc10000u,0x5c09f4f9u,0x93410d42u,0x3537d020u,0x3bef1c5au,0x81244ca7u,0xad43a92au,0xc33a0000u,0xd8e36488u,\n0x7ec3729au,0xbcf19fb9u,0x5506eee4u,0x2aead62du,0xcc04e241u,0xcfb4cf53u,0x3ee51bdu,0xe0000000u,0x31a851e2u,0x6d638ee0u,0x22fd4231u,0x814fa6ccu,0xc5127ddu,0x14b7017bu,0xb37deea4u,\n0x49699e96u,0x2597a8aau,0xf0aba65eu,0xc698e444u,0x888774f1u,0x59187835u,0x2a62a36cu,0xb0000000u,0xc559d381u,0x483ed854u,0x3733c5ccu,0x5944c589u,0x3df2a260u,0xfb7c5b1fu,0x21754a07u,\n0xa3978476u,0x1ae995f6u,0xdfe7ce6au,0x764e409du,0x8d4de6b8u,0xa034e52au,0x43b51bb2u,0x5e63e322u,0xe52509cbu,0xbce8bc60u,0x9a362854u,0xc8cf7320u,0x816e408au,0x8000000u,0xb247d800u,\n0x200000u,0xfd5eu,0x2fea6u,0x3ffe8u,0x5fff3u,0x4fffbu,0xbfffcu,0x9fffdu,0x6fffeu,0x200000u,0xeba9u,0x2f405u,0x3fc18u,0x4fd3fu,0x5fe5cu,0x6fec9u,0x7ff2bu,0x8ff5cu,0x9ff8bu,0xbffa5u,\n0xdffbcu,0xaffd2u,0xcffdfu,0xeffeau,0xffff0u,0x13fff5u,0x12fff8u,0x11fffbu,0x10fffcu,0x1afffdu,0x15fffeu,0x200000u,0xc3bbu,0x2d267u,0x3e0eeu,0x4e709u,0x5ec7fu,0x7ef89u,0x6f249u,\n0x8f41eu,0x9f5c3u,0xaf71du,0xbf822u,0xcf8f1u,0xff9b7u,0xdfa71u,0xefb06u,0x10fb80u,0x11fbeau,0x13fc4fu,0x15fcaeu,0x16fcf3u,0x17fd2du,0x12fd67u,0x19fd96u,0x18fdc0u,0x1cfde5u,\n0x23fe04u,0x1dfe23u,0x20fe42u,0x1bfe5cu,0x1afe76u,0x2bfe90u,0x2cfeaau,0x29fec4u,0x25fed9u,0x27feeeu,0x1eff03u,0x31ff18u,0x33ff27u,0x26ff36u,0x24ff45u,0x14ff54u,0x2aff63u,0x1fff72u,\n0x44ff7cu,0x3bff86u,0x32ff90u,0x2fff9au,0x30ffa4u,0x28ffaeu,0x22ffb8u,0x35ffc2u,0x53ffc7u,0x36ffccu,0x2effd1u,0x3dffd6u,0x3fffdbu,0x40ffe0u,0x55ffe5u,0x38ffeau,0x2dffefu,0x21fff4u,\n0x41fff9u,0x39fffeu,0x200000u,0x8dd5u,0x29bc3u,0x3a79cu,0x5afddu,0x4b709u,0x7bc75u,0x6c18bu,0xac4e2u,0x8c838u,0xbcb77u,0x9ce8du,0xfd14du,0xdd3cdu,0xcd623u,0x13d822u,0x12d9b8u,\n0x10db37u,0x11dca2u,0xede0cu,0x18df4cu,0x1ce08bu,0x15e1cau,0x1de2f5u,0x14e40au,0x1fe509u,0x1ee5f4u,0x17e6c9u,0x1be79eu,0x19e873u,0x2be933u,0x16e9f2u,0x31eab1u,0x24eb70u,0x2aec1au,\n0x39ecb0u,0x28ed45u,0x30edc4u,0x32ee43u,0x2ceec2u,0x1aef41u,0x48efacu,0x5bf017u,0x20f081u,0x46f0ebu,0x27f155u,0x3bf1bfu,0x26f229u,0x75f293u,0x29f2fdu,0x38f352u,0x2ff3a7u,0x4cf3fcu,\n0x2df451u,0x25f4a6u,0x35f4fbu,0x22f550u,0x21f5a5u,0x69f5e5u,0x5cf624u,0x23f663u,0x36f6a2u,0x51f6e1u,0x37f720u,0x47f75fu,0x4df79eu,0x33f7ddu,0x2ef81cu,0x73f847u,0x4bf871u,0x70f89bu,\n0x49f8c5u,0x4ef8efu,0x5ff919u,0xadf943u,0x41f96du,0x77f997u,0x3af9c1u,0x4af9ebu,0x40fa15u,0x99fa3fu,0x4ffa69u,0x3ffa93u,0x43fabdu,0x78fae7u,0x6dfb11u,0x76fb3bu,0xb4fb51u,0x58fb66u,\n0x52fb7bu,0xd2fb90u,0x57fba5u,0x97fbbau,0xb7fbcfu,0x7afbe4u,0x81fbf9u,0xfdfc0eu,0x92fc23u,0x10bfc38u,0x9cfc4du,0xabfc62u,0x83fc77u,0xacfc8cu,0x63fca1u,0x79fcb6u,0x6efccbu,\n0x3efce0u,0xc6fcf5u,0x5efd0au,0x8cfd1fu,0xd8fd34u,0x5dfd49u,0x3dfd5eu,0x91fd73u,0xcafd88u,0x72fd9du,0xa3fdb2u,0xf7fdc7u,0xa8fddcu,0x54fdf1u,0x50fe06u,0x5afe1bu,0xb3fe30u,0x8dfe45u,\n0xa7fe5au,0xb9fe6fu,0x34fe84u,0x8efe99u,0x64feaeu,0x96fec3u,0xd3fed8u,0x89feedu,0x6bff02u,0x7eff17u,0xdaff2cu,0x56ff41u,0xd0ff56u,0x82ff6bu,0xa1ff80u,0x85ff95u,0x125ffaau,\n0x74ffbfu,0x10dffd4u,0xb8ffe9u,0xc9fffeu,0x200000u,0x4ac3u,0x2564du,0x360d6u,0x467dbu,0x56da0u,0x672a4u,0x777a7u,0xb7c2au,0x117facu,0x8832eu,0xf8670u,0x1089b2u,0xa8cb4u,0x158f76u,\n0x991f7u,0x139478u,0x1896bau,0x1b98fbu,0xd9afbu,0x309cbcu,0x1f9e7du,0xea03eu,0x1aa1feu,0x19a3beu,0x2ea53fu,0x26a6c0u,0x37a841u,0x16a9c1u,0xcab41u,0x2cacc1u,0x14ae01u,0x17af41u,\n0x3bb081u,0x1db1c1u,0x29b2c1u,0x40b3c1u,0x21b4c1u,0x23b5c1u,0x11fb681u,0x3ab741u,0x4ab801u,0x59b8c1u,0x31b981u,0x28ba41u,0x2fbb01u,0xaabbc1u,0x32bc81u,0x2dbd41u,0x7abe01u,\n0x72bec1u,0x12bf80u,0x5ac03fu,0x86c0feu,0x44c1bdu,0x35c27cu,0x42c33bu,0x8ac3bbu,0x22c43bu,0xa5c4bbu,0x7cc53bu,0x1b1c5bbu,0x34c63bu,0x4dc6bbu,0x1cc73bu,0x92c7bbu,0x88c83bu,\n0xbbc8bbu,0x177c93bu,0x63c9bbu,0x130ca3bu,0x49cabbu,0x57cb3bu,0x169cbbbu,0x9fcc3bu,0x76ccbbu,0xa4cd3bu,0xb2cdbbu,0xbcce3bu,0x55cebbu,0x6fcf3bu,0x20cfbbu,0xdfd03bu,0x4bd0bbu,\n0x51d13bu,0x8bd1bbu,0x5dd23bu,0x2ad2bau,0x131d339u,0x73d3b8u,0x80d437u,0x8fd4b6u,0x6ed535u,0x64d5b4u,0x36d633u,0xeed6b2u,0x24d731u,0x94d7b0u,0x56d82fu,0x68d8aeu,0x71d92du,\n0x83d9acu,0x38da2bu,0x95daaau,0xcedb29u,0x161dba8u,0x78dc27u,0x15bdca6u,0x3cdd25u,0x8cdda4u,0x48de23u,0x3edea2u,0xd1df21u,0x6bdfa0u,0x67e01fu,0x1ee09eu,0xdce11du,0x12ce19cu,\n0x58e21bu,0x75e29au,0x6ae319u,0x74e359u,0xa9e399u,0x136e3d9u,0x52e419u,0x87e459u,0x4fe499u,0x185e4d9u,0x25be519u,0x115e559u,0x5ce599u,0x182e5d9u,0x45e619u,0x97e659u,0x11ee699u,\n0xf7e6d9u,0x173e719u,0xe7e759u,0x117e799u,0xf2e7d9u,0xe6e819u,0x89e859u,0x79e899u,0x139e8d9u,0x16fe919u,0xd4e959u,0x27ae999u,0x20de9d8u,0x7dea17u,0xefea56u,0x66ea95u,0xcdead4u,\n0x122eb13u,0x81eb52u,0xe4eb91u,0x82ebd0u,0x3dec0fu,0x19dec4eu,0x85ec8du,0x123ecccu,0xaded0bu,0x112ed4au,0x1a8ed89u,0x180edc8u,0x25fee07u,0x50ee46u,0x1e8ee85u,0x144eec4u,0x167ef03u,\n0x10fef42u,0xb5ef81u,0xd6efc0u,0x54efffu,0x90f03eu,0x5ef07du,0x14cf0bcu,0x233f0fbu,0x2bf13au,0xd3f179u,0xf0f1b8u,0x191f1f7u,0x26ef236u,0x162f275u,0xa2f2b4u,0x4cf2f3u,0xbdf332u,\n0x96f371u,0x6cf3b0u,0x2e6f3efu,0x93f42eu,0x33f46du,0x10df4acu,0x7ef4ebu,0x1d0f52au,0x109f569u,0x1bdf5a8u,0xabf5e7u,0x273f626u,0x5ff665u,0x17ff6a4u,0xf9f6e3u,0xcaf722u,0xecf761u,\n0xeaf7a0u,0x77f7dfu,0xccf81eu,0x7bf85du,0x8df89cu,0xaef8dbu,0x69f91au,0x312f959u,0x43f998u,0xb3f9d7u,0x1a5fa16u,0x111fa55u,0xa3fa94u,0x252fad3u,0x1d1fb12u,0xa6fb51u,0x9afb90u,\n0x100fbcfu,0x283fc0eu,0x4efc4du,0xc1fc8cu,0x25afccbu,0x166fd0au,0xb8fd49u,0x39fd88u,0x14efdc7u,0x230fe06u,0xf1fe45u,0x234fe84u,0x9efec3u,0x2c7ff02u,0x53ff41u,0x9cff80u,0x62ffbfu,\n0x27fffeu);\n#elif kTextureResolution == 1\nconst uint[] encoded = uint[](\n0x1000023u,0x80100u,0x2600c9u,0x1120128u,0x14a014au,0x14a014du,0x14d018eu,0x1d801e7u,0x2010203u,0x2110229u,0x229023cu,0x263027cu,0x2a002a0u,0x2a202afu,0x2af02beu,0x2d202e6u,\n0x2ff02ffu,0x3030306u,0x3060306u,0x3080314u,0x3140314u,0x3190324u,0x3240324u,0x32d0346u,0x3460346u,0x3510368u,0x3680368u,0x3680376u,0x3760376u,0x37a0387u,0x3870387u,0x38e038eu,\n0x38e038eu,0x3980399u,0x3990000u,0x39903a2u,0x3b803f4u,0x4a70000u,0xf8d3b088u,0x81e87b58u,0x4e5812d6u,0xe85def78u,0xc3880b7du,0x42ccbd78u,0x46483af0u,0x530e0698u,0xfaed1245u,\n0x226ce4dcu,0x5d419cc2u,0x78c66f26u,0xb4c295b6u,0x41bab7bdu,0x655097d0u,0x7835259eu,0x9b9da198u,0x6e220d4cu,0xea40fad3u,0xa9766e8fu,0xadc1566eu,0xe587625au,0xf676ae62u,0x302b17e5u,\n0x88815e30u,0xb1e50cf8u,0xe5805771u,0x34d4b92eu,0xf1ce1481u,0xbef01d3au,0x2abb2178u,0x87e463f7u,0x4112139cu,0x77907677u,0x59bcdba5u,0xbd2d2b78u,0xabbaedcu,0x5b90be45u,0x24c5558au,\n0xdd573226u,0x8ff7b8dbu,0xbda95ad3u,0xe1d94749u,0xe17fb4b3u,0x25457ca2u,0x3fb8d6f2u,0x99abbb20u,0x2579e98bu,0x7715fd40u,0xc1bd01e9u,0x7f22d3e3u,0xc6fd7deu,0x6ae4d1acu,0x10ea6ac4u,\n0xde8c533bu,0x4a6a34fu,0x9af6d813u,0xa8cd6b93u,0x49595f97u,0x147cc982u,0x420c5fa3u,0xb51f3a82u,0xa1fe62d7u,0xaaea394eu,0x48ab0a29u,0xb478103fu,0x63b758bdu,0x9f043d8bu,0x47f8b90fu,\n0xfd0f8d7cu,0x3a901d1fu,0xd7c801u,0xdadb3748u,0x3d7be449u,0xb110fa42u,0x8a20b1adu,0x37d271a0u,0xa14cf458u,0x12736310u,0x361d038bu,0x68ffd95fu,0x7bf552e1u,0x45e79cd0u,0x8bc2e4f8u,\n0xc0993cd8u,0x9d7562d3u,0xf156d618u,0x8223597fu,0x9dba6569u,0xf60b2fb5u,0x59170b3du,0xbe299aa2u,0x78f7bf11u,0xbc2258bau,0xc0dc27aeu,0xae9519f1u,0xcdfb4cb6u,0xc2e27957u,0x62885610u,\n0x229e2285u,0x3bd29014u,0xa9572c3bu,0x3376dcf2u,0x23c0471bu,0xcb1c77a1u,0x44c0b21bu,0x56a0ea48u,0xba15229fu,0x8a957aa8u,0x23bf721du,0x3eb5dc0au,0x1366c515u,0x7b9c53bfu,0xf0615517u,\n0xa692e071u,0x66fab18du,0x817f2a67u,0xbbc16a0eu,0xcb980db6u,0x2fb09e8fu,0x7410a686u,0x73d8e0u,0x2b9b49fdu,0xe083122au,0xc01c3088u,0x55a21e3cu,0x57e73bd5u,0xb2008b07u,0xa8bb64b7u,\n0x2ff8ce93u,0x8d12e75bu,0x9cf95829u,0x8215d826u,0x799030bu,0x4d06f0b2u,0xd0ce96bau,0xee233e07u,0x7b63aa69u,0x943ca234u,0x525cd0bbu,0x1b8f0060u,0x64bd3e29u,0xead8ea50u,0x46abca11u,\n0x911e7c17u,0x176bbff0u,0x1f19a7b0u,0xfaa2b3feu,0xd5c73583u,0xda3af694u,0xee815d3au,0x530df5b0u,0x711e86dcu,0x68263f08u,0x33a275a3u,0x501c1f5bu,0xbcecb636u,0x5011fd90u,0x1819a94eu,\n0xe0d4c920u,0x7ba9d7e1u,0x7078557du,0x77c40000u,0x0u,0x1d2874u,0xf8697fc1u,0x3d80339au,0xc9fb4a46u,0x6594e1e2u,0x1afd8afbu,0x4e85fc13u,0x7335e12au,0x9f948b0u,0x1464848eu,\n0xf4313f99u,0x639a914cu,0x53f9e5f0u,0x53789730u,0x3e591840u,0xb1b8eadu,0x3979b20eu,0xa098bf5u,0x11ed4b53u,0x79874f21u,0x2d8e98cbu,0xc5e9c263u,0xc6d194ffu,0xac9009dfu,0x41202862u,\n0x5c59b27au,0x82da4299u,0x24999b3du,0xa1b6b6a5u,0xab38a81eu,0x4447ae95u,0xc77baa35u,0xe430a9a6u,0xdb4fd6c0u,0x918ae55cu,0xf5a6dc7cu,0xa61f04bcu,0x80fb28adu,0xadac0694u,0x96ce6668u,\n0x10bf9f06u,0xb1a6226fu,0xb46d873u,0x23dbea7bu,0x9c688ebau,0x39dfcf29u,0xe0069u,0xced3dc3fu,0x9712402cu,0xd1d46a0fu,0x2da6cf20u,0x5a553a3u,0x8ce4b76eu,0x93e41eaau,0xb8470ba7u,\n0x56596cu,0xedbeb856u,0x614ace01u,0x9b2810d5u,0x7b63649au,0xce1cab44u,0x3feeccadu,0xd22f28ccu,0xe58512e5u,0x77c2d45cu,0xb2346886u,0x48333d3u,0x93f05143u,0x1d6960ebu,0x5f8a52e0u,\n0x4ba76e32u,0x74b60000u,0x0u,0x1fe9u,0x58f150au,0x76f21f5au,0x9b95ca87u,0x75b3f568u,0x316a8e03u,0xa6a48b9au,0x3e33bee8u,0xbacc7e1au,0x414cba81u,0xde91e2c4u,0x623cae04u,0x81418bfau,\n0xd473a546u,0xe7c17f4u,0x34bca2a0u,0xc94e5ce8u,0xe61d1fb7u,0x2cb2d38au,0x374207b7u,0xb24ee0b4u,0x34u,0xcb0ee4a5u,0x16ec79fbu,0x99281b5u,0x5ce4ae79u,0x7f3d8bddu,0x7ad7546cu,\n0x6ca0a0aau,0x4a76f69au,0x4eaf8668u,0xeb93d30eu,0xf2e3d29au,0x25b69eefu,0x2525fe43u,0xb57812bcu,0xf4fa8943u,0x944dce04u,0x35417944u,0x803d70b0u,0xec038f2bu,0x2e7d4f39u,0x500746b3u,\n0x77db1be0u,0x3b02fe86u,0x60cf0433u,0x571663e5u,0x94858d17u,0x3177add2u,0x202d85c2u,0x31c6b06cu,0x45726227u,0xd4ae8b7u,0xab495541u,0xb1c45d40u,0x193du,0x225028f0u,0x80000000u,\n0x3eu,0xc87fe4bbu,0xdbda31bdu,0xda51b739u,0x8b4280cau,0x55a8960bu,0x2c5fa675u,0x426c0c75u,0x39b479ccu,0xc9930da8u,0x81b25b63u,0x78a5c6efu,0xc807e0f7u,0xcdc34926u,0x52f5fce1u,\n0xe9d68cbbu,0x8b3cb330u,0xeb3e5a5fu,0x225298eu,0x53f7bc93u,0x1a028398u,0xe7eeccd0u,0x89bf52fau,0xf43cb695u,0xd301324fu,0xfd10756au,0xa2c59097u,0xb92bb761u,0x950982bu,0x754db906u,\n0xa3ac53c4u,0xe54a79e6u,0xe276b29bu,0xac3715cfu,0xe17efbe0u,0xeb170b2fu,0x74334413u,0x461009edu,0x4992289du,0x3cfaefe4u,0x121a7d4bu,0xb37142e2u,0xfbb14e04u,0xc1a0bdd2u,0xb657be58u,\n0x3a359a61u,0xf24387f9u,0x96b76d83u,0x16dd743fu,0xe7f05deau,0x10b18747u,0x481b5f42u,0x9b83aaa6u,0xf54546fau,0xf73a335fu,0xe371d6abu,0x6a37ada9u,0xef7e283bu,0xad27e5c8u,0xaa3464d4u,\n0x52097365u,0x50ff3f2eu,0x45484eb6u,0x502f1499u,0xf676e740u,0x50u,0xdb239f3au,0x920bb858u,0x7d9a9de3u,0x546293b7u,0xdaace54du,0xc9cad7dfu,0x77a2da3bu,0xef78d528u,0x3939828du,\n0x36d78d14u,0x979cfde5u,0x2a89d7e3u,0x792c9db1u,0xf9e5c330u,0x4939de9eu,0x4965831au,0x55709223u,0xade6ba2du,0x8865e83fu,0x3568437bu,0x249939e7u,0x2c00b182u,0x89b9007fu,0xd04cedafu,\n0x2ac186f5u,0x8cb618c9u,0x97f36137u,0x1c28a8a9u,0x2baea4e3u,0xf9e675d5u,0xbc2dac19u,0x63e8448au,0x93dbcce8u,0xe1e81ee6u,0x258bea3au,0x7d9b5352u,0xa716c49au,0x1f541e5du,0x920d5a99u,\n0x1e447380u,0xbe0b02fbu,0x270ac960u,0xf127fe9du,0xc2b185c9u,0xbe94b12u,0x5d721180u,0xbc6a1510u,0x8160df0u,0x365c190eu,0xf99d51du,0xb54b2e03u,0xbb12e6aau,0xb3ed4591u,0x7d50a407u,\n0xcaa8f9b2u,0xa80fa9dbu,0x6d5b708fu,0xaa6f7005u,0x7c48af1cu,0x74dd283du,0xf948033eu,0x3558067u,0x7701ddbeu,0xfa092d9eu,0x2dc69aaau,0x15b43c42u,0x80d1a6feu,0x60d5b1a2u,0x5a00ba27u,\n0x5b608009u,0x4f495296u,0x5c4e409cu,0x6d000000u,0x1e42143eu,0x2db34116u,0xae190abeu,0xda8bea6cu,0xf1fc0adcu,0x49c58753u,0xb65dc170u,0x1f5be16bu,0x448a91adu,0x2595614du,0xd057e1acu,\n0x277f9dceu,0x4d718a1du,0x26b88fcdu,0x60000000u,0xbe0b45b2u,0x73875389u,0x7cdda981u,0x72808ec3u,0xfc776336u,0xbd204007u,0x51fdb94u,0xf9d628e2u,0x28a0a613u,0x906e0494u,0x62493428u,\n0x7972c37au,0xb9e1ac57u,0xb39fbeddu,0x4cec6c91u,0x4a6d1a66u,0xa822e63cu,0xfb334c65u,0xd13bc2eeu,0xddbf11d2u,0xc206d8dau,0xeb392826u,0x62a5c88fu,0xd539d656u,0xb3542406u,0x78000000u,\n0xa7a41u,0x79e40000u,0xd0d9fdcbu,0x3c2eacacu,0x7c9ec6bbu,0xba66a671u,0x163cafffu,0xc4d34560u,0x1d5e5889u,0xbf938927u,0x89d6b2a2u,0x2b0fbabfu,0x98b93c1du,0x84a5aadeu,0x7defcce0u,\n0xb8b00000u,0xb0036283u,0xaa136cdbu,0xd420ac94u,0x81ab1b4u,0x610ba99eu,0x96c2ad38u,0x51693ecdu,0x1930b0e5u,0xffd5e07eu,0x5bcc0f51u,0x659c350au,0x62616b9au,0xe6dfdb3eu,0x3cbe71b0u,\n0xd1825feeu,0x866f6fc6u,0x7b5208a8u,0x53783179u,0x5fc5df1u,0xe5c227c8u,0xc8f6bb2eu,0x958e0557u,0xf3bb27fdu,0x85e00000u,0x55u,0xdc358171u,0x3cb9314u,0x8baccf40u,0x5915450fu,\n0x2bc94578u,0x24e2a8b3u,0xcc4550ebu,0xf9330f1fu,0x21b733f8u,0xba9482c4u,0x5d640362u,0x3eacfc75u,0x6a7b2860u,0x22825944u,0xa2d33c2fu,0x8e4b9e61u,0xf883e51eu,0x7c000000u,0x50u,\n0xfd224752u,0xc9a42ff7u,0x839eec81u,0x3e183d53u,0x9c14acd6u,0xae03be24u,0x966df5b6u,0xe793fd1cu,0x9c2bf1d3u,0xfd28bdd3u,0x5436dcd2u,0x549e6700u,0x85319dffu,0x59cc7121u,0x77ae520au,\n0xe19b8d25u,0x6b212d96u,0xaaf0196u,0x829697fbu,0xb4947e2au,0x6d70f13cu,0x26adabe6u,0x17c20490u,0xf3bff8a2u,0x19133563u,0x65d57851u,0x34c7b049u,0x32243cd0u,0xa5b35dafu,0x847f7a9au,\n0x372fd43fu,0xd5a5d154u,0xe745bcf1u,0xfa0cbdcfu,0x8ffc28feu,0xe63f465cu,0x8289c93fu,0x48000000u,0x77u,0x796a236du,0x45cf555au,0xd1988a49u,0x83e78cdcu,0xe674b3a1u,0x50e2628bu,\n0xa2dbb38au,0x899914e9u,0x2600beb4u,0x6994d7afu,0x886b1d1eu,0xee4e2e2bu,0x2f359e22u,0xb7776cabu,0x20a13fd2u,0x6fede123u,0xbd8c693eu,0x8a51651eu,0xa8d0b683u,0xb4d07f9bu,0xe41a9bd2u,\n0xb8fd74cau,0xdfc46e7fu,0x183d6000u,0xad5u,0xfd1780ccu,0xc828798cu,0xb8d9f08eu,0x28b2f26au,0x5dba53fdu,0x9724040bu,0xc2fc3b2au,0x8916898du,0x4d8d8631u,0x5512ce95u,0x62a73f71u,\n0x418c0c40u,0x2c8f28cu,0x5208f13au,0x9b27a17fu,0xdedebaf1u,0xd91c3f8cu,0x87fc509eu,0x9f2cc84bu,0x1d338e68u,0x67f64c88u,0xf8eaa0f3u,0x75aa8a43u,0x4e9343e6u,0xd22fb1f6u,0x309f2e04u,\n0x53e2532au,0x3fc34e72u,0x10233455u,0x1ad00728u,0xf849b480u,0x545943a0u,0x5427426cu,0x60461790u,0x80000000u,0x4f3dd4aeu,0x33da70c0u,0xb0b7c188u,0xb5b97df0u,0x456fb2b7u,0xb9eccaafu,\n0x3c094942u,0xbdad9d42u,0x25157f10u,0xa67fc7a9u,0x9afce8bfu,0x31f1355eu,0x947a3f06u,0x88357037u,0x29000000u,0x1c9e6u,0x6dce6c63u,0xe3a884c0u,0x165076bu,0x84a3cd83u,0x600cefeeu,\n0xbc499656u,0x25ddb9ecu,0xc0480a2du,0xab3d7dfeu,0x39161f9au,0xd375eaf9u,0xe3c954b2u,0x800b371u,0x5c800000u,0xf4bb43f4u,0x76917052u,0x2cda1644u,0xc4efe759u,0xcd37c7ecu,0x89a2e289u,\n0x1ab0e805u,0xad960068u,0xcc512493u,0x9cedd3dcu,0xa974ef98u,0x59b52287u,0x66ca7ea8u,0xe84c1370u,0x59d88a2au,0xdf94ccd4u,0x47ed6783u,0x44ebd745u,0x8f2fa800u,0xf03da000u,0xd26202cu,\n0x52550990u,0xb3c3503du,0x3eabdac1u,0x89748e2fu,0xdb4ed5aeu,0x33df74f7u,0x8397f4a9u,0x8b8d4326u,0x890998fdu,0xa5462469u,0xfed6fbbau,0xb0903872u,0xbb2a6ccbu,0x8187d5e7u,0x6edbfeeeu,\n0x198edb95u,0xbccb8c55u,0xb9a00000u,0x60600000u,0x9e754876u,0xba8c142bu,0x818af61cu,0x5cfd16u,0xae7e91e5u,0xa53ce3a3u,0x9a78570au,0xbd7acab5u,0x4de134e5u,0xbd44a4c1u,0xbfa48cdbu,\n0xf093344bu,0x161e7e1bu,0xf4f0822cu,0xb5aed847u,0x2dc46ad4u,0x30516109u,0xe0fbe833u,0xabcdc1d3u,0xb00810b0u,0x592d4d49u,0x3c9fd906u,0x830f0071u,0xa44b459cu,0x86a41c40u,0xd16742f1u,\n0x6c382915u,0x9a1fc160u,0x8ac00000u,0xeef6e0e4u,0x86297626u,0x28c00000u,0xe52228u,0xa4d80000u,0x2607b1bu,0x3a24f493u,0xe2b7c8dbu,0xcbe34901u,0x8f259c7eu,0xff8bd483u,0xab03bcecu,\n0xf7204feau,0xa0003692u,0x9fa14c2cu,0x86d9f073u,0xc4217b0u,0x2ae027bu,0xa3776a8bu,0x920c139cu,0x5297246cu,0x35000000u,0x2dd3acu,0xb63ee8b6u,0x23055b09u,0x22fce80du,0x8d0e6860u,\n0x5d11db35u,0xe73fdedeu,0xce7915d4u,0xecb60c6cu,0x5f8680f5u,0xdbe734e9u,0xc189183u,0xd0adefe9u,0x71f25aefu,0xac3bbb1bu,0xd21460c5u,0x5f273678u,0x4f17ccfeu,0x74dd99c8u,0x8bd75f00u,\n0xb8e9150u,0x5b8af079u,0xff1f1501u,0xbed7ec01u,0x1c1c8516u,0x19bf9f57u,0x519f45f8u,0xee1e517au,0xd5c61a1eu,0x399beaefu,0x771f4d76u,0xee776f1u,0xcb527dd7u,0xfdd32872u,0x8915388du,\n0xf5d0eaecu,0xc5f8ec55u,0x34bbb61du,0xafd30501u,0xb9a35f75u,0x59f7620fu,0xdef3985u,0x1303391au,0xc7695e11u,0x27a69400u,0xb76c78e0u,0x3125f781u,0xb42da092u,0x4cc34636u,0x4d8b4d77u,\n0x5654d2cu,0x4a2036cdu,0xc4adbf1du,0x17c83deau,0xec13b330u,0xcb000000u,0xff47c561u,0xe3b9e9f9u,0x4e4f192u,0x985a1c12u,0x8eed27edu,0x45f67f4au,0x89419ea3u,0xf52791afu,0x161d5e41u,\n0xf8e4045fu,0xd3a0bdeau,0x5b4e4a5cu,0xb0d22c26u,0x1c40b5bfu,0x6cb2a93cu,0xe8f49048u,0x24b4aef1u,0x34e28ea1u,0x4cc2cae1u,0xd39c75edu,0x264c245u,0x2285dffeu,0x7c000000u,0x4ec09726u,\n0x2314d554u,0x74572540u,0xd4a3bd1bu,0xf0427586u,0x9eac542bu,0x1694c27fu,0x12d8a08au,0x87340094u,0x3ee4710u,0xe8bad31eu,0xc2052690u,0x84d9359du,0xe37c1400u,0x9d023d14u,0xee6d22ffu,\n0x4c647182u,0xf0000000u,0x9752f998u,0x95e7cb60u,0xf6ad2acu,0xa7bebdbfu,0xb16ae584u,0xd08eb5c3u,0xe3197567u,0x4fd2ec55u,0x8284a3d4u,0xce2598e9u,0x2d20fba8u,0x68b06587u,0xf917d000u,\n0x18283ef0u,0x970a638eu,0x97b57fe1u,0xb16cb998u,0x538397b9u,0xaaaaa52du,0x56a3b00u,0xcf9f5d7du,0x5ee282c8u,0xf0956629u,0xd06a9d3eu,0xdfae25ddu,0x99cec370u,0x8ddc5a8bu,0x519e03cau,\n0xe1492443u,0xaf544680u,0x283dc17au,0x200000u,0xfbeau,0x2fdcbu,0x3ff85u,0x5ffbfu,0x4ffedu,0x7fff6u,0x6fffcu,0x8fffeu,0x200000u,0xe517u,0x2eef2u,0x3f7b7u,0x5f9d1u,0x4fbe6u,0x7fcebu,\n0x6fdb0u,0x9fe25u,0x8fe94u,0xbfee9u,0xaff1eu,0xdff48u,0xfff6du,0xcff92u,0x10ffb1u,0xeffcbu,0x11ffe5u,0x13ffefu,0x19fff4u,0x17fff9u,0x14fffeu,0x200000u,0xaf15u,0x2bf01u,0x3ced8u,\n0x5d643u,0x4dceeu,0x7e1d9u,0x6e5aeu,0x8e898u,0x9eb03u,0xaed02u,0xceeecu,0xbf0acu,0xdf241u,0xff36bu,0x11f480u,0x14f56au,0x12f63fu,0x10f6feu,0x17f7a9u,0x13f853u,0x15f8e8u,0x23f967u,\n0xef9e6u,0x22fa50u,0x1bfabau,0x25fb24u,0x18fb79u,0x1dfbceu,0x1afc23u,0x21fc62u,0x1ffca1u,0x19fce0u,0x29fd1fu,0x1efd5eu,0x20fd88u,0x28fdb2u,0x2bfddcu,0x16fe06u,0x32fe30u,0x2dfe5au,\n0x26fe84u,0x3ffe99u,0x2ffeaeu,0x24fec3u,0x36fed8u,0x2efeedu,0x4dff02u,0x47ff17u,0x3cff2cu,0x38ff41u,0x2cff56u,0x3dff6bu,0x45ff80u,0x3aff95u,0x30ffaau,0x1cffbfu,0x43ffd4u,0x35ffe9u,\n0x31fffeu,0x200000u,0x58fcu,0x26684u,0x3724cu,0x47990u,0x78093u,0x58757u,0xb8d5au,0x692ddu,0x996dfu,0x89aa0u,0xa9de2u,0x12a0e3u,0xfa3a4u,0x10a665u,0xea925u,0x18aba6u,0xdade7u,\n0x11afe7u,0x15b1a8u,0x16b368u,0x14b528u,0x1ab6a8u,0x19b828u,0x13b9a8u,0x17bb28u,0x2abc68u,0xcbda8u,0x26bee8u,0x1cc028u,0x1dc168u,0x3ac2a8u,0x36c3e8u,0x49c527u,0x70c627u,0x1fc727u,\n0x45c827u,0x35c927u,0x32ca27u,0x3bcb27u,0x54cc27u,0x31cd26u,0x59ce25u,0x5ccf24u,0x1ed023u,0x30d0e3u,0x41d1a3u,0x2fd263u,0x5bd323u,0x24d3e3u,0x23d4a3u,0x37d563u,0x7cd623u,0x3ed6e3u,\n0x22d7a3u,0x21d862u,0x42d921u,0x2cd9e0u,0x38da9fu,0x3ddb5eu,0x84dc1du,0x65dcdcu,0x2ddd9bu,0x52de1bu,0x167de9bu,0x5adf1bu,0x7adf9bu,0x75e01bu,0x83e09bu,0x39e11bu,0x77e19bu,\n0x73e21au,0x8be299u,0xb6e318u,0x62e397u,0x85e416u,0xa5e495u,0x79e514u,0x89e593u,0xf1e612u,0x1be691u,0x28e710u,0x27e78fu,0x5de80eu,0x68e88du,0x8ae90cu,0x88e94cu,0x22ee98cu,\n0x273e9ccu,0x47ea0cu,0x13bea4cu,0x48ea8cu,0x78eaccu,0x186eb0cu,0x5feb4cu,0x4ceb8cu,0xa9ebccu,0x4dec0cu,0x2eec4cu,0x6cec8cu,0x7eecccu,0x57ed0bu,0x15fed4au,0x3fed89u,0x318edc8u,\n0xb0ee07u,0x7dee46u,0x69ee85u,0x50eec4u,0x181ef03u,0x1b0ef42u,0x129ef81u,0x16befc0u,0xd5efffu,0xc0f03eu,0xeaf07du,0x46f0bcu,0xa3f0fbu,0x20ff13au,0x20f179u,0x4af1b8u,0x9af1f7u,\n0x8ff236u,0x117f275u,0x176f2b4u,0x18bf2f3u,0x132f332u,0x4ff371u,0x6ef3b0u,0x6af3efu,0x7ff42eu,0x72f46du,0x8cf4acu,0xbef4ebu,0x110f52au,0x8ef569u,0x2c1f5a8u,0x10bf5e7u,0x5ef626u,\n0x146f665u,0x1b3f6a4u,0x185f6e3u,0x43f722u,0x64f761u,0x111f7a0u,0x13cf7dfu,0xabf81eu,0xdbf85du,0xe8f89cu,0xaaf8dbu,0x122f91au,0x27af959u,0xa2f998u,0x23ff9d7u,0x29fa16u,0x24cfa55u,\n0x265fa94u,0x53fad3u,0x6bfb12u,0x63fb51u,0x34fb90u,0xadfbcfu,0x87fc0eu,0xa4fc4du,0x67fc8cu,0x66fccbu,0x135fd0au,0xcafd49u,0x115fd88u,0xa7fdc7u,0x25fe06u,0x2bfe45u,0x40fe84u,\n0xa0fec3u,0x4eff02u,0xd0ff41u,0x9dff80u,0x3cffbfu,0xdefffeu); \n#else \nconst uint[] encoded = uint[](\n0x80000bu,0x70080u,0xd008au,0xaf00b5u,0xc600e8u,0x1100114u,0x11f0126u,0x136013cu,0x147014cu,0x153015au,0x1620000u,0x162016bu,0x18101f4u,0xfbcc3f85u,0x74076d2fu,0x9c50dc51u,\n0xd40230a5u,0xf9fe1b4au,0xf9a46638u,0x81145aacu,0x5a948abbu,0x3ac9509cu,0xa5b07067u,0x4fecba65u,0xa7d7ddffu,0x9559fd6du,0xec35aa0u,0xe9933c33u,0xcd474c8cu,0xb749ba03u,0xa3740dafu,\n0x62e08639u,0xbf9b4b0eu,0xa6b9f85au,0xae542bdcu,0xcf2cb006u,0xc44bbd4eu,0xac1a4bf4u,0x3e5b847eu,0x579b3f81u,0x9911d05au,0x69934fcau,0xdf9440f7u,0x1a48bca0u,0x775768b6u,0xf6f96e2eu,\n0x206f9325u,0xb0149f01u,0xfb213e81u,0xe33d7e42u,0xf6d7c6fu,0x8fccada8u,0x8f888c3fu,0xc552fa86u,0x9e1b6125u,0xd652e8e2u,0xd614aeb4u,0x7be97d57u,0x4bbf4bbu,0x362e6dbfu,0x9545fe8eu,\n0xd38fce2fu,0x7f011aa0u,0x1c6f405u,0xaa32e064u,0xdeb8dc92u,0x72ad9153u,0x239d843eu,0x9a99fcc0u,0xc13bbb1fu,0x747419fu,0xc55f9a8du,0xf2e3ef78u,0x5b438aa3u,0x83afa3d2u,0xcd01be09u,\n0xb9909fb7u,0x2378e984u,0xed572c9u,0xc0226e22u,0x92132084u,0xf755aa3au,0xe2080b6cu,0x40974a0cu,0x503fe612u,0xc07ca42au,0x66b6142cu,0xc7e1b037u,0x42190c87u,0x7a6a726bu,0xc1ba427au,\n0x91306636u,0x4c2ef7c9u,0x2ecc47ccu,0x7cbf8568u,0x1d7fe208u,0x292a0f2du,0x782e3f2bu,0x4b22494bu,0x8ca1bf56u,0x5dc6d0fcu,0xbc43053cu,0x37efa57fu,0xa0153ab8u,0xf21cde9du,0x149d93ecu,\n0x9ce33b3eu,0xd7423fb0u,0xfd17562fu,0xce04466bu,0xaefb1526u,0xa80ec582u,0xa6a28594u,0xa8a33602u,0x411fa262u,0xae5dbb51u,0xd104450au,0x4884eb57u,0x88fdc05u,0xfae8db44u,0xd6967244u,\n0x76ccbc41u,0xccade37du,0x35569bfdu,0x432f59f4u,0x705a5cc0u,0xaca4415du,0xf525d0ddu,0x152e5754u,0xc6163a0eu,0x785bdc66u,0x936c8c1au,0xb71932d0u,0x22f8d7c9u,0x4b0eb396u,0x3ae9e7c4u,\n0x507f785cu,0xf07c0000u,0x0u,0x169edabu,0x877197fbu,0x60f4c225u,0x83320b68u,0xb26bb4eeu,0xa1103798u,0x6871c8c7u,0xd3371391u,0xde76b83du,0x960c7f4du,0x6bba814du,0xd843705u,\n0xf4fe9086u,0x7afc0083u,0x37b43c61u,0xac74f0f7u,0x1d3b55c7u,0xf149347u,0xecee2541u,0x52a6282eu,0x20d13d64u,0x7ba434a6u,0xa2fc0180u,0xedcbe13cu,0x5f2290d0u,0xf3210720u,0x39eef6d6u,\n0x8485a466u,0xdfb08e57u,0xcd883c31u,0xf24c14ebu,0x4003c8f1u,0x748159bdu,0xb5407ca1u,0x79f93556u,0x5b1a1880u,0x82u,0xae41e786u,0x86f3a6c0u,0xe595c37u,0x69c615ffu,0x89d6e980u,\n0x1c5fu,0x9803ad00u,0xd60879du,0x3033f47bu,0x6d856e35u,0xa86e1986u,0xac62e63eu,0x93f2b960u,0x59e14094u,0x2e82f15au,0x93c3e85au,0xb5e634e0u,0xb555d602u,0x31b8ece0u,0xa9f96b9du,\n0x6d2c6590u,0xa0000000u,0x85369u,0xdd5df787u,0xb556db6cu,0x2b757b23u,0x62701bf4u,0xb728324eu,0xb7400c01u,0x3c6056beu,0x6a03d880u,0x1efead3cu,0x4986f78u,0x118f279au,0x9edcd1f9u,\n0x8461d94cu,0x7857ce9u,0x67bcc27du,0xd3a9a948u,0x4fe6b7cfu,0x23ec78adu,0x4f8a2dcdu,0xd4ab4e47u,0x55a40f70u,0xc82f118fu,0x9bc0f133u,0x12f4149bu,0xb75a82dau,0x6453e0a5u,0x7a6c13bbu,\n0xfc2b06f7u,0x4a0edb70u,0x77c403e3u,0x761fe6cu,0x8f31c048u,0xa779ba4u,0x5b5u,0x1933157au,0x4bd9bff1u,0x6fff4805u,0x25f45bbcu,0xb0056aa3u,0xd1e19f21u,0xe54812e0u,0x7f1f6dfdu,\n0xd6dd2ea9u,0x5c3a416cu,0xbe3f8c7u,0xbda23555u,0x91207e59u,0xfc389d6au,0xc3a9cc93u,0x1b259d9du,0xd7f4a5c5u,0x10efdbb6u,0x58be7d92u,0x2bbba968u,0x37b9201au,0x25752544u,0x3ac75e7eu,\n0xcecf3c76u,0x1a6b54adu,0xa7713316u,0xb167c38eu,0xe1c266dau,0x855752fau,0x6e9f077au,0x4cba24d9u,0xbe36a8d7u,0x3c63c95cu,0x562894a2u,0xa3d62a43u,0x9400f5e5u,0x4664e540u,0x966b9040u,\n0x5b294600u,0x878e2d40u,0xf18cf59du,0xf1e33a3fu,0xdaf46ac0u,0xb6a8d1cbu,0xf41d8ea2u,0x5f37ca57u,0x335ff9a0u,0xd818657eu,0xbc51360u,0x35ffcedcu,0xf72a6feau,0xe6372768u,0x7e083128u,\n0xc0000000u,0x12u,0xfafab6u,0xfc3972f4u,0xdb00df5du,0x8d880532u,0xfda69a5eu,0x37c80000u,0x17d9901u,0xaceea46du,0x20b27bccu,0x7cbd0d7u,0x1b44af46u,0x349b6db0u,0xd9033fb4u,\n0xcfcd9465u,0x4c1e8ecau,0x1015360bu,0xbced6ef5u,0xf3f3a1f8u,0x71acb004u,0x2066d92eu,0x58a075e3u,0x3356a800u,0x1af7e03u,0xdda4355au,0x64a7ae8eu,0x12bba002u,0xde21f56au,0xd0ffc700u,\n0x2dbf77u,0x766fcdd9u,0x6c166b9cu,0xad6d97dcu,0xf794cb22u,0x5affc53du,0x87d598e2u,0x9dd2d795u,0xc9a6b37bu,0xacf21ca7u,0x288ad000u,0xaafu,0xec78ea46u,0x20d210a2u,0x7f0b312bu,\n0xe0898000u,0x58c73318u,0xf85f7826u,0xe0e3ef2cu,0xf23c2f69u,0xf9863ee0u,0x70eb2cd3u,0x5a99b004u,0x61111eeeu,0x3f405994u,0x806cb6a4u,0x5a306db4u,0x34f1bde9u,0x29520123u,0x40000000u,\n0xdb59b1e4u,0x480bbdfeu,0x2776334eu,0xea8bc954u,0xb7934c2fu,0x78cbec91u,0xd76e13feu,0xaa450000u,0x200000u,0xf7f8u,0x3fb3du,0x2fe82u,0x5ff21u,0x4ffb0u,0x7ffdau,0x6fff9u,0x9fffeu,\n0x200000u,0xd3dcu,0x2e171u,0x3eedcu,0x5f331u,0x4f730u,0x7f8dau,0x6fa6fu,0x9fbc4u,0x8fcaeu,0xbfd6du,0xafe02u,0xdfe97u,0x10ff01u,0xcff56u,0x11ff80u,0x12ff95u,0xfffaau,0x19ffbfu,\n0x17ffd4u,0x15ffe9u,0x13fffeu,0x200000u,0x7733u,0x388fau,0x298c0u,0x4a1c3u,0x5aa06u,0x6b007u,0xeb448u,0x7b889u,0x9bc8au,0xcc00bu,0xac38bu,0x8c6ccu,0x15ca0cu,0xfcc8cu,0xbcf0cu,\n0x1ad14cu,0x11d38cu,0x17d58cu,0x12d70cu,0xdd88cu,0x13da0bu,0x16db4bu,0x14dc8au,0x18ddc9u,0x1edec9u,0x1ddfc9u,0x19e0c9u,0x21e1c8u,0x1be2c7u,0x23e3c6u,0x3ae486u,0x10e546u,0x30e605u,\n0x22e6c4u,0x87e783u,0x24e842u,0x39e901u,0x2ee981u,0xa4ea01u,0x2cea81u,0x83eb01u,0x28eb80u,0x42ebffu,0x1fec7eu,0x26ecfdu,0x31ed7cu,0x4dedfbu,0x2bee7au,0x20eef9u,0x34ef78u,0x33eff7u,\n0x73f076u,0x2df0f5u,0x10df135u,0x65f175u,0x72f1b5u,0x9ff1f5u,0x7ef235u,0x68f275u,0x228f2b4u,0x89f2f3u,0x242f332u,0x64f371u,0x163f3b0u,0x8af3efu,0xfbf42eu,0x7df46du,0x13df4acu,\n0x8bf4ebu,0x7bf52au,0x25f569u,0x129f5a8u,0x76f5e7u,0x54f626u,0x46f665u,0xdbf6a4u,0x3cf6e3u,0x41f722u,0x44f761u,0x149f7a0u,0x7cf7dfu,0x5df81eu,0x26df85du,0x7af89cu,0x1a7f8dbu,\n0x31ef91au,0x79f959u,0x2af998u,0x67f9d7u,0x5cfa16u,0x1cfa55u,0x1b1fa94u,0x62fad3u,0xc3fb12u,0x35fb51u,0x132fb90u,0xaafbcfu,0x4afc0eu,0x92fc4du,0x52fc8cu,0xe7fccbu,0x78fd0au,\n0x8dfd49u,0x61fd88u,0x4bfdc7u,0x55fe06u,0x50fe45u,0x6efe84u,0xf2fec3u,0xf3ff02u,0x29ff41u,0x3fff80u,0x36ffbfu,0x32fffeu);\n#endif\n\n// Wavelet coefficiencts are compressed more or less aggressively depending on the band they belong to. This is determined by the quantisation\n// rate which is defined by the compressor and hard-coded here for now.\nuint[] quantRates = uint[](10u,27u,97u,377u,1027u,1027u,1027u,1027u,1027u);\n\n// Macroblocks are groups of coefficients that are independently compressed.\n#define kBlockSize                32\n#define kBlockArea                (kBlockSize * kBlockSize)\n\n// Some global variables that are set at the start of each shading operation\nint kImageSize = 0;\nint kVisibleImageSize = 0;\nint kBlockRowsCols = 0;\nint kNumBlocks = 0;\nint kNumPrecincts = 0;\n\n// This function retrieves a specific encoded bit and increments the look-up indices accordingly\nuvec3 unpackBit(in uvec3 indices, uint inLength)\n{\n    // The bit index is one plus the index to be retrieved. If we're at bit zero then increment the index of the encoded uint\n    // and reset the bit index to 32u.\n    if (indices.y == 0u)\n    {\n        if (indices.x == inLength - 1u) { return uvec3(indices.xy, 0u); }\n        indices.x++;\n        indices.y = 32u;\n    }\n    \n    // Unpack and return the indices and the data we want.\n    //   x: The index of the current encoded uint\n    //   y: The index of the current encoded bit + 1\n    //   z: The retrived bit itself\n    return uvec3(indices.x, indices.y - 1u, (encoded[indices.x] >> (indices.y - 1u)) & 1u);\n}\n\n/**\nFixed model arithmetic decoder\nThis function ingests the raw compressed stream and returns the quantised coefficient at a particular index in the block.\nThe serial nature of these decoders means that we're doing a ton of redunant processing to decode the image this way. \nHowever, since the framerate is locked to 60fps, it doesn't actually help us to pass the codec state between frames \nto reduce redundancy.\n**/\nuint decodeMacroblock(ivec2 dataOffsets,           // The start and end of the encoded data\n                      ivec2 modelOffsets,          // The stard and end of the model used to decode the data\n                      int outElementIdx)           // The index of the 16-bit value we want to retrieve\n{    \n    // Prime the registers \n    uint f = encoded[dataOffsets.x];\n    uint i0 = 0u;\n    uint i1 = 0xffffffffu;\n   \n    // Move some indices into local variables for simplicty\n    uvec3 bitIndices = uvec3(dataOffsets.x, 0u, 0u);\n    uint inEncodedEnd = uint(dataOffsets.y);\n    int modelStart = modelOffsets.x;\n    int modelEnd = modelOffsets.y;\n\n    for (int decodeIdx = 0; decodeIdx <= kBlockArea; decodeIdx++)\n    {\n        uint di = i1 - i0;\n        uint diHi = di >> 16;\n        uint diLo = di & 0xffffu;\n\n        // Binary search for the element corresponding to the value contained in the register, f\n        int j0 = modelStart, j1 = modelEnd - 1;\n        while (j1 - j0 > 0)\n        {\n            int jMid = j0 + (j1 - j0) / 2;\n            uint fMid = i0 + (diHi * (encoded[jMid] & 0xffffu)) + ((diLo * (encoded[jMid] & 0xffffu)) >> 16u);\n            if (fMid <= f) { j0 = jMid + 1; }\n            else { j1 = jMid; }\n        }\n        if (j1 == modelStart) { j1 = modelStart + 1; }\n\n        // Retrieve the symbol from the model. Return if it's the one we're looking for.\n        uint symbol = encoded[j1] >> 16u;\n        if (decodeIdx == outElementIdx) \n        {   \n            return symbol;\n        }\n\n        // Update the interval based upon the element in the model\n        i1 = i0 + (diHi * (encoded[j1] & 0xffffu)) + ((diLo * (encoded[j1] & 0xffffu)) >> 16u);\n        i0 = i0 + (diHi * (encoded[j1 - 1] & 0xffffu)) + ((diLo * (encoded[j1 - 1] & 0xffffu)) >> 16u);\n\n        // If we're in an underflow state, do a bit of trickery to clear it\n        if (((i1 >> 30u) & 3u) == 2u && ((i0 >> 30u) & 3u) == 1u)\n        {\n            int nudge;\n            for (nudge = 0; nudge <= 29; nudge++)\n            {\n                uint bitmask = 1u << (29 - nudge);\n                if ((i0 & bitmask) == 0u || (i1 & bitmask) != 0u) { break; }\n            }\n            if (nudge == 29) { return 0u; } // Would normally assert here, but we can't\n\n            nudge++;\n\n            // Update the registers to clear the underflow\n            f = (f << nudge) ^ (1u << 31u);\n            i0 = (i0 << nudge) ^ (1u << 31u);\n            i1 = (i1 << nudge) ^ (1u << 31u);\n\n            // Unpack some more bits\n            for (int shift = nudge - 1; shift >= 0; shift--) \n            { \n                bitIndices = unpackBit(bitIndices, inEncodedEnd);\n                f |= bitIndices.z << shift; \n            }\n        }\n        // Not an underflow state, so just sweep off as many prefixing bits as we can\n        else\n        {\n            int nudge;\n            for (nudge = 0; nudge < 31; nudge++)\n            {\n                uint bitmask = 1u << (31 - nudge);\n                if ((i0 & bitmask) != (i1 & bitmask)) { break; }\n            }\n\n            if (nudge > 0)\n            {\n                f <<= nudge;\n                i0 <<= nudge;\n                i1 <<= nudge;\n\n                // Unpack some more bits\n                for (int shift = nudge - 1; shift >= 0; shift--) \n                { \n                    bitIndices = unpackBit(bitIndices, inEncodedEnd);\n                    f |= bitIndices.z << shift; \n                }\n            }\n        }\n    }\n\n    return 0u; // Should never be here\n}\n\n\n// Recovers two adjacent 16-bit offsets from the table of encoded values\nivec2 unpackOffset(in int tableOffset, in int idx)\n{\n    ivec2 rvalue;\n    rvalue.x = int((encoded[tableOffset + (idx >> 1)] >> (16 - 16 * (idx & 1))) & 0xffffu);\n    rvalue.y = int(((encoded[tableOffset + ((idx + 1) >> 1)] >> (16 - 16 * ((idx + 1) & 1))) & 0xffffu));\n    return rvalue;\n}\n\n\n// Returns the index of the precinct at the input pixel coordinates\nint getPrecinct(int x, int y)\n{\n    int maxXy = max(x, y);\n    return kNumPrecincts - 1 - ((maxXy == 0) ? 0 : int(log2(float(maxXy))));\n}\n\n\n// Decodes and de-quantises the wavelet coefficients for the input pixel coordinates.\n// TODO: A trivial improvement here would be to decode a block of 4 values at once. \nfloat decodeWaveletCoefficients(int x, int y)\n{\n    if(x < 0 || x >= kVisibleImageSize || y < 0 || y >= kVisibleImageSize) { return 0.0; }\n    \n    int u = x / kBlockSize, v = y / kBlockSize;             // The coordinates of the block\n    int blockIdx = v * kBlockRowsCols + u;                  // The index of the block as measured row by row\n    int i = x - u * kBlockSize, j = y - v * kBlockSize;     // The local pixel coordinates relative to the block                          \n    int subIdx = j * kBlockSize + i;                        // The index of the pixel relative to the block as measured row by row\n    \n    // Unpack the offsets representing the start and end of the encoded data block\n    ivec2 dataOffsets = unpackOffset(2, blockIdx);    \n    \n    // Unpack the offsets of the model corresponding the precinct containing the block\n    int precinct = getPrecinct(x, y);\n    int modelIdx = min(precinct, kNumPrecincts - 5);    \n    ivec2 modelOffsets = unpackOffset(int(encoded[0] & 0xffffu), modelIdx);    \n    \n    // Decode the block to retrieve a single coefficient\n    uint quantised = (dataOffsets.y - dataOffsets.x == 0) ? 0u : decodeMacroblock(dataOffsets, modelOffsets, subIdx);\n    \n    // De-quantise the coefficient using the quantisation rate for this block\n    uint quantRange = quantRates[precinct];\n    float pixel = float(quantised >> 1u) / float(quantRange);\n\n    // Negate the value if the sign bit is set, and we're done\n    return pixel - float(quantised & 1u) * 2.0 * pixel;\n}\n\n\n// Bi-orthogonal CohenâDaubechiesâFeauveau wavelet coefficients\n// https://en.wikipedia.org/wiki/Cohen-Daubechies-Feauveau_wavelet\n// NOTE: The coefficients in the Wikipedia page have the wrong offsets\nfloat[] cdf97InverseFather = float[](0.0, \n                                     -0.091271763114 * 0.5, \n                                     -0.057543526229 * 0.5, \n                                     0.591271763114 * 0.5,\n                                     1.11508705 * 0.5,\n                                     0.591271763114 * 0.5,\n                                     -0.057543526229 * 0.5,\n                                     -0.091271763114 * 0.5,\n                                     0.0,\n                                     0.0);\n                                     \nfloat[] cdf97InverseMother = float[](0.0,\n                                     0.026748757411 * 0.5,\n                                     0.016864118443 * 0.5,\n                                     -0.078223266529 * 0.5,\n                                     -0.266864118443 * 0.5,\n                                     0.602949018236 * 0.5,\n                                     -0.266864118443 * 0.5,\n                                     -0.078223266529 * 0.5,\n                                     0.016864118443 * 0.5,\n                                     0.026748757411 * 0.5);\n\n\n// Orthogonal Haar wavelet coefficients\n// https://en.wikipedia.org/wiki/Haar_wavelet\nfloat[] haarInverseFather = float[](0.5, 0.5);\nfloat[] haarInverseMother = float[](0.5, -0.5);\n\n\n// Discrete inverse wavelet transform for the Haar basis\n// https://en.wikipedia.org/wiki/Discrete_wavelet_transform\nfloat inverseHaarTransform(ivec2 xy, ivec2 basis, ivec2 sourceOffset, int size, sampler2D sampler)\n{\n    int halfSize = size / 2;\n    ivec2 xyLow = xy - basis * (xy + ivec2(1, 1)) / 2; \n    ivec2 xyHigh = xyLow + basis * halfSize;\n    int pairIdx = sum((xyLow + xyLow * basis) - xy);\n    \n    float r;\n    if(pairIdx == 0)\n    {\n        r = haarInverseFather[0] * texelFetch(sampler, xyLow + sourceOffset, 0).x +\n            haarInverseMother[0] * texelFetch(sampler, xyHigh + sourceOffset, 0).x;\n    }\n    else\n    {\n        r = haarInverseFather[1] * texelFetch(sampler, xyLow + sourceOffset, 0).x +\n            haarInverseMother[1] * texelFetch(sampler, xyHigh + sourceOffset, 0).x;\n    }\n    \n    return r * 2.0;\n}\n\n\n// Discrete inverse wavelet transform using the CohenâDaubechiesâFeauveau basis\nfloat inverseCDF97Transform(ivec2 xy, ivec2 basis, ivec2 sourceOffset, int size, sampler2D sampler)\n{\n    int halfSize = size / 2;\n    ivec2 xyLow = xy - basis * (xy + ivec2(1, 1)) >> 1; \n    ivec2 xyHigh = xyLow + basis * halfSize;       \n    ivec2 origin = (basis.x == 1) ? ivec2(0, xy.y) : ivec2(xy.x , 0); \n    int pairIdx = (basis.x == 1) ? (xy.x & 1) : (xy.y & 1);    \n    int i = (basis.x == 1) ? (xy.x >> 1) : (xy.y >> 1);\n    \n    float r = 0.0;     \n    for (int b = -2; b <= 2; b++)\n    {       \n        int bFather = i + b;\n        int bMother = bFather;\n        if (bFather < 0) \n        { \n            bFather = -bFather; \n            bMother = -bMother - 1;\n        }\n        else if (bFather > halfSize - 1) \n        { \n            bFather = 1 + 2 * (halfSize - 1) - bFather; \n            bMother = 2 * (halfSize - 1) - bMother;\n        }\n     \n        int k0 = -(2 * b) + 4;\n        int k1 = k0 + 1;\n        if (pairIdx == 0 && k0 >= 0)\n        {\n            r += cdf97InverseFather[k0] * texelFetch(sampler, origin + basis * bFather + sourceOffset, 0).x + \n                 cdf97InverseMother[k0] * texelFetch(sampler, origin + basis * (halfSize + bMother) + sourceOffset, 0).x;\n        }\n        else if (pairIdx == 1 && k1 < 10)\n        {\n            r += cdf97InverseFather[k1] * texelFetch(sampler, origin + basis * bFather + sourceOffset, 0).x + \n                 cdf97InverseMother[k1] * texelFetch(sampler, origin + basis * (halfSize + bMother) + sourceOffset, 0).x;\n        }\n    }\n\n    return r * 2.0;\n}\n\n\n// The lowest levels of coefficients are transformed with the Haar wavelet to avoid having to deal with \n// doubly reflected boundaries\nfloat inverseWaveletTransform(ivec2 xy, ivec2 basis, ivec2 sourceOffset, int size, sampler2D sampler)\n{\n    return (size <= 4) ? inverseHaarTransform(xy, basis, sourceOffset, size, sampler) :\n                         inverseCDF97Transform(xy, basis, sourceOffset, size, sampler);\n}\n\n// Decompression is a multi-stage process (decoding, inverse transform, inverse gamma). This function\n// manages that process frame-by-frame. \nbool decompressTextureImpl(ivec2 xyLocal, ivec2 xySource, sampler2D sampler, int frameIdx, out float L)\n{              \n    // Define the decompression schedule for each pass\n    int[] interval = int[](1, kNumPrecincts * 2, 1);    \n    int[] schedule = int[](0, 0, 0, 0);\n    for(int i = 0; i < 3; i++) { schedule[i + 1] = schedule[i] + interval[i]; }\n    \n    // Pass 0: decode coefficients\n    if(frameIdx == schedule[0])\n    {\n        L = decodeWaveletCoefficients(xyLocal.x, xyLocal.y);\n        return true;\n    }\n\n    // Pass 1..N: inverse wavelet transform each scale\n    if(frameIdx >= schedule[1] && frameIdx < schedule[2])\n    {     \n        int passIdx = frameIdx - schedule[1];\n        int subPassIdx = passIdx % 2;\n        int blockIdx = passIdx / 2;\n\n        if(blockIdx > kNumPrecincts) { return false; }\n\n        int span = 1 << (blockIdx + 1);\n        ivec2 basis = ivec2(passIdx % 2, (passIdx + 1) % 2);        \n\n        if(span > kVisibleImageSize || xyLocal.x >= span || xyLocal.y >= span) { return false;  }\n\n        L = inverseWaveletTransform(xyLocal, basis, xySource, span, sampler);        \n        return true;\n    }\n\n    // Pass N+1: clamp and apply inverse gamma\n    if(frameIdx == schedule[2])\n    {\n        L = clamp(texelFetch(sampler, xyLocal + xySource, 0).x, 0.0, 1.0);\n        L = pow(L, 1.0 / 2.2);\n        return true;\n    }\n   \n    return false;\n}\n\n// The texture size is the first 16-bit value in the encoded block\nint getTextureSize() { return int(encoded[0] >> 16); }\n\n// The visible texture size may be less than the actual texture size if the shader buffer is too small to fit.\n// TODO: Compute this value analytically rather than numerically\nint getVisibleTextureSize()\n{\n    int imageSize = getTextureSize();\n    int visibleImageSize;\n    for(visibleImageSize = 2; visibleImageSize < imageSize; visibleImageSize <<= 1)\n    {\n        if(2 * (visibleImageSize << 1) > int(iResolution.x) || (visibleImageSize << 1) + 1 > int(iResolution.y))\n        {\n            return visibleImageSize;\n        }\n    }\n    return visibleImageSize;\n}\n\n\n// We use two texture-sized blocks of the framebuffer which we toggle between at each frame to progressively decode\n// the final image. \nvec4 decompressTexture(ivec2 xy, sampler2D sampler)\n{     \n    ivec4 textureState = getTextureState(sampler, iFrame);    \n    \n    // All done? Just return the existing texel.\n    if(textureState.y == kTextureReady) { return texelFetch(sampler, xy, 0); }\n    \n    // Get the frame index and number of precincts\n    int frameIdx = getFrameIdx(textureState, iFrame);   \n    kNumPrecincts = int(encoded[1] >> 16u);\n\n    // We store some additional state information about the texture and the current frame in the bottom\n    // rows of the framebuffer. \n    if(xy.y == 0)\n    {       \n        if(xy.x == 0)\n        {\n            // The first vec4 stores the texture state:\n            // x - Current frame\n            // y - Texture decompression status (used by the renderer)\n            // z - Visible texture size\n            // w - Full texture size\n            uint checkDigit = uint(texelFetch(sampler, ivec2(1, 0), 0).x);\n            if(checkDigit != 0u && checkDigit != encoded[0] >> 16u) { return vec4(0.0); }\n\n            vec4 fragColor;\n            fragColor.z = float(getVisibleTextureSize());\n            fragColor.w = float(getTextureSize());\n            if(textureState.x == 0)\n            {\n                fragColor.x = float(iFrame + 1); \n                fragColor.y = float(kTextureNotReady);\n            }\n            else\n            {           \n                fragColor.x = float(textureState.x);\n                fragColor.y = float((frameIdx < 1 + kNumPrecincts * 2 + 5) ? kTextureNotReady : kTextureReady);\n            }\n            return fragColor;\n        }\n        else if(xy.x == 1) { return vec4(encoded[0] >> 16u, 0.0, 0.0, 0.0); }\n    } \n    \n    // Frame index isn't valid yet, so just quit. \n    if(frameIdx < 0) { return vec4(0.0); }\n    \n    // Set some global variables\n    kImageSize = textureState.w;\n    kVisibleImageSize = textureState.z; \n    kBlockRowsCols = kImageSize / kBlockSize;\n    kNumBlocks  = kBlockRowsCols * kBlockRowsCols;    \n    \n    // Derive the local coordinate space for the frame and the coordinates of the source pixel where we'll be reading from\n    ivec2 xyLocal = xy - ivec2(frameIdx % 2, 0) * kVisibleImageSize - ivec2(0, kTextureStartRow);\n    ivec2 xySource = ivec2((frameIdx + 1) % 2, 0) * kVisibleImageSize + ivec2(0, kTextureStartRow);\n    \n    // Out of bounds of the local frame? Just copy what's there and return\n    if(xyLocal.x < 0 || xyLocal.x >= kVisibleImageSize || xyLocal.y < 0 || xyLocal.y >= kVisibleImageSize) \n    {\n        return texelFetch(sampler, xy, 0);\n    }  \n    \n    // If the decompression succeeded, write out the returned value. Otherwise, just copy the source texel. \n    float L;\n    if(decompressTextureImpl(xyLocal, xySource, sampler, frameIdx, L))\n    {\n        return vec4(L, L, L, 1.0);\n    }\n    else\n    {\n        return texelFetch(sampler, xyLocal + xySource, 0);\n    }\n} \n\n// End of pre-processor block that allows us to disable the texture\n#endif \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    ivec2 xy = ivec2(fragCoord);\n    \n    // The second row of the framebuffer contains the states for the user input parameters\n    if(xy.y == kSettingsStateRow)\n    {\n        if(xy.x == 256)\n        {\n            vec2 mouseState = texelFetch(iChannel0, ivec2(256, kSettingsStateRow), 0).xy;\n            fragColor.y = float(mouseState.x > 0.0 && iMouse.z < 0.0);\n            fragColor.x = iMouse.z;\n        }\n        else if(xy.x < 256)\n        {\n            int keyState = int(texelFetch(iChannel1, ivec2(xy.x, 0), 0).x != 0.0);\n            vec2 mouseState = texelFetch(iChannel0, ivec2(256, kSettingsStateRow), 0).xy;\n            ivec4 toggleState = ivec4(texelFetch(iChannel0, ivec2(xy.x, kSettingsStateRow), 0));\n            \n            fragColor.x = float(keyState);\n            fragColor.y = float(toggleState.y);\n            if(fragColor.y == float(KEY_ON) && ((mouseState.x > 0.0 && iMouse.z < 0.0) || mouseState.y == 1.0))\n            {\n                fragColor.y = float(KEY_OFF);\n            }\n            else if(toggleState.x != keyState)\n            {\n                fragColor.y = (toggleState.y == 0) ? 1.0 : float((toggleState.y << 1) % 15);\n            }        \n            fragColor.zw = (int(fragColor.y) == KEY_ON) ? vec2(iMouse.x, iMouse.y) : vec2(toggleState.zw);            \n        }\n        return;\n    }\n\n#if kEnableTexture\n    fragColor = decompressTexture(ivec2(fragCoord), iChannel0);\n#endif\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*//////////////////////////////////////////////////////////////////////////////////////////////////\n\n   Copyright (c) 2021 Ben Spencer   \n   Released under the MIT Licence\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n   \n\n   Description:\n   \n   This file defines the major input parameters and a host of universal and other supporting functions\n   which are used throughout the shader.\n\n//////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n#define kTextureResolution        1               // 0 -> 128x128, 1 -> 256x256, 2 -> 512x512        \n\n#define kEnableTexture            1               // Enable or disable the texture               \n\n#define kApplyFilmGrain           true            // Apply film grain as a post-process\n#define kApplyBloom               true            // Apply lens bloom as a post-process\n#define kApplyVignette            true            // Apply vignette as a post-process\n\n#define kFilmGrainStrength        0.3             // The strength of film grain post-process\n#define kFilmGrainFreq            2.0             // The relative frequency of the film grain effect. Higher = finer grain.\n\n#define kVignetteStrength         0.7             // The strength of the vignette effect\n#define kVignetteScale            0.7             // The scale of the vignette effect\n#define kVignetteExponent         4.0             // The rate of attenuation of the vignette effect\n\n#define kCompGamma                0.9             // The gamma correction coefficient applied to the composite image\n#define kCompGain                 1.0             // The gain coefficient applied to the composite image\n#define kCompSaturation           1.0             // The saturation level of the composite image\n\n#define kBloomGain                3.0             // The strength of the bloom effect \n#define kBloomTint                vec3(1.0)       // The tint applied to the bloom effect\n#define kBloomWidth               0.2             // The width of the bloom effect as a proportion of the buffer width\n#define kBloomHeight              0.1             // The height of the bloom effect as a proportion of the buffer height\n#define kBloomShape               1.0             // The fall-off of the bloom shape. Higher value = steeper fall-off\n#define kBloomDownsample          6               // How much the bloom buffer is downsampled. Higher value = lower quality, but faster\n#define kDebugBloom               false           // Show only the bloom in the final comp\n \n#define kSpectralIntegrator       true            // Enables the spectral integrator. Allows for dispersive lens and dielectric effects.\n#define kHaltonSpectralSampler    true            // Sample the spectral component using a scrambled radix-2 Halton sequence for faster convergence\n#define kAnalyticLights           true            // Estimates the reflected radiance analytically using contour integrals. This method does not handle occlusion.\n#define kDebugNormals             false           // Disregard all shading effects and just show surface normals\n#define kLightsVisibleToCamera    true            // Whether the emitter is visible to camera rays\n    \n#define kCameraPos                vec3(0.0, 0.0, 10.0) // The position of the camera\n#define kCameraLookAt             vec3(0.0)       // The point the camera is looking at\n#define kCameraAA                 2.0             // The width/height of the anti-aliasing kernel in pixels\n#define kCameraSensorSize         0.035           // The size of the camera sensor in meters\n#define kCameraFocalLength        0.115           // The focal length of the lens in meters\n#define kCameraAberration         0.03            // The degree of spectral aberration of the lens\n#define kCameraFringing           0.0             // The bias of the aberration towards blue frequencies\n\n#if kTextureResolution == 0                       // The f-stop of the lens. If we're using the low-res texture, add a bit more DOF blur\n#define kCameraFStop              1.0\n#else                                               \n#define kCameraFStop              1.5             \n#endif\n\n#define kDielectricIor            1.5690          // The index of refraction of the dielectric material\n#define kDielectricDispersion     5.0             // The degree of chromatic dispersion in the dielectric material\n#define kDielectricAbsorption     vec3(1.0)       // The Beer-Lambert absorption coeffient of the dielectric material\n\n#define kZonePlateTest            false           // Replaces the decoded texture with a simple zone plate test\n#define kZonePlateFreq            5.0             // The relative frequency of the zone plat pattern\n\n#define kLoadingInnerRadius       0.05            // The inner radius of the loading icon\n#define kLoadingOuterRadius       0.07            // The outer radius of the loading icon\n#define kLoadingAASamples         3               // The number of anti-aliasing samples of the loading icon\n\n#define kEmitterRadiance          vec3(3.0)       // The colour and intensity of the light\n\n#define kMaxPathDepth             8               // The maximum number of bounces before the path is terminated\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Try and bump the level of precision if we're on a mobile device\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Some mathematical constants, helper functions and precomputed values\n#define kPi                    3.14159265359\n#define kTwoPi                 (2.0 * kPi)\n#define kHalfPi                (0.5 * kPi)\n#define kRoot2                 1.41421356237\n#define kFltMax                3.402823466e+38\n#define kIntMax                0x7fffffff\n#define kOne                   vec3(1.0)\n#define kZero                  vec3(0.0)\n#define kPink                  vec3(1.0, 0.0, 0.2)\nfloat toRad(float deg)         { return kTwoPi * deg / 360.0; }\nfloat toDeg(float rad)         { return 360.0 * rad / kTwoPi; }\nfloat sqr(float a)             { return a * a; }\nint sqr(int a)                 { return a * a; }\nint mod2(int a, int b)         { return ((a % b) + b) % b; }\nfloat length2(vec2 v)          { return dot(v, v); }\nint sum(ivec2 a)               { return a.x + a.y; }\nfloat luminance(vec3 v)        { return v.x * 0.17691 + v.y * 0.8124 + v.z * 0.01063; }\nfloat mean(vec3 v)             { return v.x / 3.0 + v.y / 3.0 + v.z / 3.0; }\nvec4 mul4(vec3 a, mat4 m)      { return vec4(a, 1.0) * m; }\nvec3 mul3(vec3 a, mat4 m)      { return (vec4(a, 1.0) * m).xyz; }\n\n// Flags signalling whether the texture has been loaded\n#define kRenderReady           2\n#define kTextureReady          1\n#define kTextureNotReady       0\n\n// Constants for the Fowler-Noll-Vo hash function\n// https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function\n#define kFNVPrime              0x01000193u\n#define kFNVOffset             0x811c9dc5u\n#define kDimsPerBounce         4\n\n// Keyboard codes\n#define KEY_Q            81\n#define KEY_W            87\n#define KEY_E            69\n#define KEY_A            65\n#define KEY_S            83\n#define KEY_D            68\n#define KEY_Z            90\n#define KEY_X            88\n#define KEY_C            67\n#define KEY_V            86\n#define KEY_F            70\n\n// Key states\n#define KEY_UNDEFINED    0\n#define KEY_TO_ON        1\n#define KEY_ON           2\n#define KEY_TO_OFF       4\n#define KEY_OFF          8\n#define KEY_REFRESH      (KEY_ON | KEY_TO_OFF)\n\n#define kTextureStartRow          4\n#define kAutomataRow              2\n#define kSettingsStateRow         1\n#define kTextureStateRow          0\n\nivec2 kFragCoord;\nuvec4 rngSeed; \n\n// Retrieves the user-specified parameter from the texture state\nvec4 getUserParameter(int keyCode, sampler2D sampler)\n{\n    return texelFetch(sampler, ivec2(keyCode, 1), 0);\n}\n\n// Maps the input xy texel coordinates to UV [0.0, 1.0] and distance R from center\nvec2 xyToUv(in vec2 xy, in vec3 iResolution)\n{\n    vec2 uv = vec2(xy.x / iResolution.x, xy.y / iResolution.y);\n    uv.x = (uv.x - 0.5) * (iResolution.x / iResolution.y) + 0.5;     \n    return uv;\n}\n\n// Maps the input xy texel coordinates to UV [-1.0, 1.0] and distance R from center\nvec3 xyToUvr(in vec2 xy, in vec3 iResolution)\n{\n    vec2 uv = xyToUv(xy, iResolution);    \n    float x = 2.0 * (uv.x - 0.5);\n    float y = 2.0 * (uv.y - 0.5);\n    \n    return vec3(uv, sqrt(x*x + y*y) / kRoot2);\n}\n\n// Gets the texture state from the decoder\nivec4 getTextureState(sampler2D sampler, int iFrame)\n{\n    return ivec4(texelFetch(sampler, ivec2(0, 0), 0));\n}\n\n// Extracts the relative frame index from the texture state and the absolute frame index\nint getFrameIdx(ivec4 textureState, int iFrame)\n{\n    return (textureState.x == 0) ? -1 : (iFrame - int(textureState.x) - 2);\n}\n\n// Compute a 32-bit Fowler-Noll-Vo hash for the given input\nuint hashOf(uint i)\n{\n    uint h = (kFNVOffset ^ (i & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 8u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 16u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 24u) & 0xffu)) * kFNVPrime;\n    return h;\n}\n\n// Reverse the bits of 32-bit inteter\nuint radicalInverse(uint i)\n{\n    i = ((i & 0xffffu) << 16u) | (i >> 16u);\n    i = ((i & 0x00ff00ffu) << 8u) | ((i & 0xff00ff00u) >> 8u);\n    i = ((i & 0x0f0f0f0fu) << 4u) | ((i & 0xf0f0f0f0u) >> 4u);\n    i = ((i & 0x33333333u) << 2u) | ((i & 0xccccccccu) >> 2u);    \n    i = ((i & 0x55555555u) << 1u) | ((i & 0xaaaaaaaau) >> 1u);        \n    return i;\n}\n\n// Mix and combine two hashes\nuint hashCombine(uint a, uint b)\n{\n    return (((a << (31u - (b & 31u))) | (a >> (b & 31u)))) ^\n            ((b << (a & 31u)) | (b >> (31u - (a & 31u))));\n}\n\nvec3 hue(float phi)\n{\n    float phiColour = 6.0 * phi / kTwoPi;\n    int i = int(phiColour);\n    vec3 c0 = vec3(((i + 4) / 3) & 1, ((i + 2) / 3) & 1, ((i + 0) / 3) & 1);\n    vec3 c1 = vec3(((i + 5) / 3) & 1, ((i + 3) / 3) & 1, ((i + 1) / 3) & 1);             \n    return mix(c0, c1, phiColour - float(i));\n}\n\n// Seperable bloom function. This filter requires two passes in the horizontal and vertical directions which are combined as a post-process\n// effect after each frame. The accuracy/cost of the effect can be tuned by dialing the kBloomDownsample parameter. \nvec3 bloom(vec2 fragCoord, vec3 iResolution, ivec2 delta, sampler2D renderSampler, sampler2D stateSampler)\n{    \n    vec2 scaledResolution = vec2(iResolution.x, iResolution.y) / float((delta.x == 1) ? kBloomDownsample : 1);\n   \n    if(fragCoord.x > scaledResolution.x || fragCoord.y > scaledResolution.y) { return kZero; }\n    \n    ivec3 keyState = ivec3(getUserParameter(KEY_Z, stateSampler).zwy);\n    float bloomSize;\n    if(delta.x == 1)\n    {\n        bloomSize = (keyState.z != KEY_UNDEFINED) ? (0.4 * float(keyState.x) / iResolution.x) : kBloomWidth;\n    }\n    else\n    {\n        bloomSize = (keyState.z != KEY_UNDEFINED) ? (0.4 * float(keyState.y) / iResolution.y) : kBloomHeight;\n    }\n    \n    int kKernelWidth = int(bloomSize * max(iResolution.x, iResolution.y) + 0.5) / ((delta.x == 1) ? kBloomDownsample : 1);\n    vec3 sumWeights = vec3(0.0);\n    vec3 sumRgb = vec3(0.0);\n    for(int i = -kKernelWidth; i <= kKernelWidth; i++)\n    {      \n        vec2 xy = vec2(fragCoord.x + float(i * delta.x), fragCoord.y + float(i * delta.y));\n        \n        if(delta.x == 1) { xy *= float(kBloomDownsample); }\n        else { xy /= float(kBloomDownsample); }\n        \n        if(xy.x < 0.0 || xy.x > iResolution.x || xy.y < 0.0 || xy.y > iResolution.y) { continue; }\n            \n        vec4 texel = texture(renderSampler, xy / iResolution.xy);\n        vec3 rgb = max(texel.xyz / max(1.0, texel.w), vec3(0.0));            \n        float d = float(abs(i)) / float(kKernelWidth);\n           \n        vec3 weight = kOne;\n        if(i != 0)\n        {\n            // Currently using a single weight although this effect can be done per-channel\n            float kernel = pow(max(0.0, (exp(-sqr(d * 4.0)) - 0.0183156) / 0.981684), kBloomShape);            \n            weight = kOne * kernel;\n        }\n            \n        sumRgb += ((delta.y == 1) ? rgb : max(kZero, rgb - kOne)) * weight;         \n        sumWeights += weight;\n    }\n    \n    sumRgb = sumRgb / sumWeights;\n    \n    return (delta.x == 1) ? sumRgb : (sumRgb * kBloomTint);\n}\n\n// Permuted congruential generator from \"Hash Functions for GPU Rendering\" (Jarzynski and Olano)\n// http://jcgt.org/published/0009/03/02/paper.pdf\nuvec4 pcgAdvance()\n{\n    rngSeed = rngSeed * 1664525u + 1013904223u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    rngSeed ^= rngSeed >> 16u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    return rngSeed;\n}\n\n// Seed the PCG hash function with the current frame multipled by a prime\nvoid pcgInitialise(int frame)\n{    \n    rngSeed = uvec4(frame * 20219, frame * 7243, frame * 12547, frame * 28573);\n}\n\n// Generates a tuple of canonical random number and uses them to sample an input texture\nvec4 rand(sampler2D sampler)\n{\n    return texelFetch(sampler, (kFragCoord + ivec2(pcgAdvance() >> 16)) % 1024, 0);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nvec4 rand()\n{\n    return vec4(pcgAdvance()) / float(0xffffffff);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*//////////////////////////////////////////////////////////////////////////////////////////////////\n\n   Copyright (c) 2021 Ben Spencer   \n   Released under the MIT Licence\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n   \n         \n   Description:   \n    \n   This file contains the ray tracing and rendering code.\n\n//////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n// Define some material IDs corresponding to the objects that are hit\n#define kMaterialNull            -1\n#define kMaterialPhoto           0\n#define kMaterialDielectric      1\n#define kMaterialNormals         2\n#define kMaterialEmitter         3\n#define kMaterialConductor       4\n\n// Define whether to sample the lights, BRDF or both with MIS\n#define kSampleMis               0\n#define kSampleLights            1\n#define kSampleBrdf              2\n\n#define kInvalidHit              -1.0\n\nivec4 kTextureStats;\nbool refreshView;\n\n// Define state variables for various user-defined attributes\n#define SETTING_CAMERA_POS       0\n#define SETTING_CAMERA_FLENGTH   1\n#define SETTING_CAMERA_FSTOP     2\n#define SETTING_LENS_ABERRATION  3\n#define SETTING_ETA              4\n#define SETTING_ZONEPLATE        5\n#define SETTING_ABSORPTION       6\n#define NUM_SETTINGS             7\nivec3 kSettings[NUM_SETTINGS];\n\n// The minimum amount of data required to define an infinite ray in 3D space\nstruct RayBasic\n{\n    vec3   o;                   // Origin \n    vec3   d;                   // Direction  \n};\n\n// The \"full fat\" ray objects that most methods will refer to\nstruct Ray\n{\n    RayBasic od;                // Origin/direction\n    float    tNear;             // The parameterised intersection along the ray, defined in cartesian coordinates as o + d * tNear\n    \n    vec3     n;                 // Normal at the intersected surface\n    vec2     uv;                // UV parameterisation coordinate at the intersected surface\n    bool     backfacing;        // Whether the intersection with a forward- or backward-facing surface\n    vec3     weight;            // The weight/throughput of the ray depending on context\n    float    pdf;               // The value of a probability density function incident to the intersection, depending on context\n    float    kickoff;           // The degree to which extant rays should be displaced from the surface to prevent self-intersection\n    float    lambda;            // The wavelength of the ray used by the spectral integrator\n};\n\n// Fast construction of orthonormal basis using quarternions to avoid expensive normalisation and branching \n// From Duf et al's technical report https://graphics.pixar.com/library/OrthonormalB/paper.pdf, inspired by\n// Frisvad's original paper: http://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\nmat4 createBasis(vec3 n)\n{\n    float s = sign(n.z);\n    float a = -1.0 / (s + n.z);\n    float b = n.x * n.y * a;\n    \n    return mat4(vec4(1.0f + s * n.x * n.x * a, s * b, -s * n.x, 0.0),\n                vec4(b, s + n.y * n.y * a, -n.y, 0.0),\n                vec4(n, 0.0), \n                vec4(0.0, 0.0, 0.0, 1.0));\n}\n\n\n// Creates a 4x4 identity matrix\nmat4 identity()\n{\n    return mat4(vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));\n}\n\n// Builds a composite matrix from three Euler angles, scale and translation vectors\nmat4 compound(float thetaX, float thetaY, float thetaZ, vec3 scale, vec3 translate)\n{   \n    mat4 mat = mat4(vec4(1.0, 0.0, 0.0, -translate.x),\n                    vec4(0.0, 1.0, 0.0, -translate.y),\n                    vec4(0.0, 0.0, 1.0, -translate.z),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n                \n    if(scale != vec3(1.0))\n    {\n        vec3 invScale = vec3(1.0) / scale;\n        mat *= mat4(vec4(invScale.x, 0.0, 0.0, 0.0),\n                    vec4(0.0, invScale.y, 0.0, 0.0),\n                    vec4(0.0, 0.0, invScale.z, 0.0),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n    }\n    \n    if(thetaX != 0.0)\n    {\n        float cosTheta = cos(thetaX), sinTheta = sin(thetaX);\n        mat *= mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                    vec4(0.0, cosTheta, -sinTheta, 0.0),\n                    vec4(0.0, sinTheta, cosTheta, 0.0),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n    }\n    if(thetaY != 0.0)\n    {\n        float cosTheta = cos(thetaY), sinTheta = sin(thetaY);\n        mat *= mat4(vec4(cosTheta, 0.0, sinTheta, 0.0),\n                    vec4(0.0, 1.0, 0.0, 0.0),\n                    vec4(-sinTheta, 0.0, cosTheta, 0.0),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n    }\n    if(thetaZ != 0.0)\n    {\n        float cosTheta = cos(thetaZ), sinTheta = sin(thetaZ);\n        mat *= mat4(vec4(cosTheta, -sinTheta, 0.0, 0.0),\n                    vec4(sinTheta, cosTheta, 0.0, 0.0),\n                    vec4(0.0, 0.0, 1.0, 0.0),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n    }\n                   \n    return mat;\n}\n\n\n// Quick and dirty method for sampling the unit disc from two canonical random variables. For a better algorithm, see\n// A Low Distortion Map Between Disk and Square (Shirley and Chiu)\nvec2 sampleUnitDisc(vec2 xi)\n{\n    float phi = xi.y * kTwoPi;   \n    return vec2(sin(phi), cos(phi)) * sqrt(xi.x);   \n}\n\n\n// Samples the radix-2 Halton sequence from seed value, i\nfloat haltonBase2(uint i)\n{    \n    return float(radicalInverse(i)) / float(0xffffffffu);\n}\n\n\n// Transforms a ray into the object space\nRayBasic toObjectSpace(RayBasic ray, mat4 matrix)\n{\n    RayBasic transformed;\n    transformed.d = mul3(ray.d + ray.o, matrix);\n    transformed.o = mul3(ray.o, matrix);\n    transformed.d = transformed.d - transformed.o;\n    \n    return transformed;\n}\n\n\n// Creates a camera ray according based on the fragment coordinate\nRay createCameraRay(vec2 fragCoord)\n{     \n    // Generate 4 random numbers from a continuous uniform distribution\n    vec4 xi = rand(iChannel1);\n    \n    // The value of mu is used to sample the spectral wavelength but also the chromatic aberration effect.\n    // If we're using the Halton low-disrepancy sampler, hash the input values and sample the sequence\n    float mu = xi.y;\n    if(kHaltonSpectralSampler)\n    {\n        uint hash = hashCombine(0x01000193u, hashCombine(hashOf(uint(fragCoord.x)), hashOf(uint(fragCoord.y))));\n        mu = haltonBase2(uint(iFrame) + hash);\n    }    \n    \n    vec3 screenUvr = xyToUvr(fragCoord, iResolution);\n    \n    // Get the camera position, either from the built-in constant or from the user setting \n    vec3 cameraPos = kCameraPos;\n    if(kSettings[SETTING_CAMERA_POS].z != KEY_UNDEFINED)\n    {        \n        vec2 normMousePos = (vec2(kSettings[SETTING_CAMERA_POS].xy) - iResolution.xy * 0.5) / iResolution.xy;\n        float kCameraTheta = 0.5 * sin(kHalfPi * normMousePos.x);\n        float kCameraPhi = 0.5 * sin(kHalfPi * normMousePos.y);\n        cameraPos = vec3(sin(kCameraTheta), sin(kCameraPhi), cos(kCameraTheta)) * 10.0;\n    }\n    \n    // Apply the lens aberration. Since we aren't using a physically based camera model, this effect isn't accurate. However it \n    // gives us more artistic constrol and overdriving it creates some nice-looking effects\n    float aberration = 1.0;\n    if(kSpectralIntegrator)\n    {\n        aberration = kCameraAberration;\n        if(kSettings[SETTING_LENS_ABERRATION].z != KEY_UNDEFINED)\n        {\n            vec2 normMousePos = (vec2(kSettings[SETTING_LENS_ABERRATION].xy) - iResolution.xy * 0.5) / iResolution.xy;\n            aberration = sqr(screenUvr.z * (normMousePos.x + 0.5));\n        }\n        aberration = mix(1.0, pow(mu, 1.0  / (1.0 + kCameraFringing)), aberration);\n    }    \n    \n    // Define our camera vectors and orthonormal basis\n    #define kCameraUp vec3(0.0, 1.0, 0.0)    \n    vec3 kCameraForward = kCameraLookAt - cameraPos;\n    float focalDistance = length(kCameraForward);\n    kCameraForward /= focalDistance;\n    \n    mat4 basis;\n    basis[0] = vec4(normalize(cross(kCameraForward, kCameraUp)), 0.0);\n    basis[1] = vec4(cross(basis[0].xyz, kCameraForward), 0.0);\n    basis[2] = vec4(kCameraForward, 0.0);\n    basis[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    // Define the focal length and F-number depending, either from built-in or user-defined values\n    float focalLength = kCameraFocalLength;\n    if(kSettings[SETTING_CAMERA_FLENGTH].z != KEY_UNDEFINED)\n    {\n        focalLength = mix(0.01, 1.0, pow(float(kSettings[SETTING_CAMERA_FLENGTH].y) / iResolution.y, 2.0));\n    } \n    float fStop = kCameraFStop;\n    if(kSettings[SETTING_CAMERA_FSTOP].z != KEY_UNDEFINED)\n    {\n        fStop = mix(0.1, 32.0, pow(float(kSettings[SETTING_CAMERA_FSTOP].y) / iResolution.y, 3.0));\n    }     \n    \n    // Solve the thin-lens equation. http://hyperphysics.phy-astr.gsu.edu/hbase/geoopt/lenseq.html\n    float d1 = 0.5 * (focalDistance - sqrt(-4.0 * focalLength * focalDistance + sqr(focalDistance)));\n    float d2 = focalDistance - d1; \n    \n    // Generate a position on the sensor, the focal plane, and the lens. This lens will always have circular bokeh\n    // but with a few minor additions it's possible to add custom shapes such as irises. We reuse some random numbers\n    // but this doesn't really matter because the anti-aliasing kernel is so small that we won't notice the correlation \n    vec2 sensorPos = xi.zx * kCameraSensorSize * kCameraAA / max(iResolution.x, iResolution.y) + \n                     kCameraSensorSize * (fragCoord - vec2(iResolution) * 0.5) / float(max(iResolution.x, iResolution.y)) * aberration;    \n    vec2 focalPlanePos = vec2(sensorPos.x, sensorPos.y) * d2 / d1;    \n    vec2 lensPos = sampleUnitDisc(xi.xy) * 0.5 * focalLength / fStop;\n    \n    // Assemble the ray\n    Ray ray;\n    ray.od.o = mul3(vec3(lensPos, d1), basis);\n    ray.od.d = normalize(mul3(vec3(focalPlanePos, focalDistance), basis) - ray.od.o);\n    ray.od.o += cameraPos;\n    ray.tNear = kFltMax;\n    ray.weight = vec3(1.0, 1.0, 1.0);\n    ray.pdf = kFltMax;\n    \n    // Sample the wavelength (in Angstroms)  \n    ray.lambda = mix(3800.0, 7000.0, mu);    \n\n    return ray;    \n} \n\n\n// Creates an extrant ray\nRay createRay(vec3 o, vec3 d, vec3 kickoff, vec3 weight, float pdf, float lambda)\n{\n    Ray ray; \n    ray.od.o = o;\n    ray.od.d = d;\n    ray.od.o += kickoff;\n    ray.tNear = kFltMax;\n    ray.weight = weight;\n    ray.pdf = pdf;\n    ray.lambda = lambda;\n    return ray;\n}\n\n\n// Derives a ray from another ray\nRay deriveRay(in Ray ray, float tNear, vec3 n, bool backfacing, vec2 uv, float kickoff)\n{\n    Ray derivative = ray;\n    derivative.tNear = tNear;\n    derivative.n = n;\n    derivative.backfacing = backfacing;\n    derivative.kickoff = kickoff;\n    derivative.uv = uv;\n    return derivative;\n}\n\n\n// Creates a null or empty ray\nRay nullRay()\n{\n    Ray ray;\n    ray.pdf = 0.0;\n    ray.tNear = kInvalidHit;\n    return ray;\n}\n\n\n// Ray-plane intersection test\nRay testRayPlane(in Ray ray, mat4 matrix, bool bounded)\n{\n    RayBasic localRay = toObjectSpace(ray.od, matrix);\n    if(abs(localRay.d.z) < 1e-10) { return nullRay(); } \n\n    float t = localRay.o.z / -localRay.d.z;\n    if (t <= 0.0 || t >= ray.tNear) { return nullRay(); }\n    \n    float u = (localRay.o.x + localRay.d.x * t) + 0.5;\n    float v = (localRay.o.y + localRay.d.y * t) + 0.5;\n    \n    if(bounded && (u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0)) { return nullRay(); }\n        \n    // If we've hit the surface and it's the closest intersection, calculate the normal and UV coordinates\n    // A more efficient way would be to defer this process to avoid unncessarily computing normals for occuluded surfaces.\n    vec3 hitLocal = localRay.o + localRay.d * t;\n    vec3 nLocal = vec3(0.0, 0.0, 1.0) + hitLocal;\n    mat4 invMatrix = inverse(matrix);\n    vec3 hitGlobal = mul3(hitLocal, invMatrix);\n    vec3 nGlobal = mul3(nLocal, invMatrix);    \n    \n    return deriveRay(ray, t, normalize(nGlobal - hitGlobal), localRay.d.z > 0.0, vec2(u, v), 1e-4);\n}\n\n\n// Finds the roots of a quadratic equation of the form a.x^2 + b.x + c = 0\nbool quadraticSolve(float a, float b, float c, out float t0, out float t1)\n{\n    float b2ac4 = b * b - 4.0 * a * c;\n    if(b2ac4 < 0.0) { return false; } \n\n    float sqrtb2ac4 = sqrt(b2ac4);\n    t0 = (-b + sqrtb2ac4) / (2.0 * a);\n    t1 = (-b - sqrtb2ac4) / (2.0 * a);    \n    return true;\n}\n\n\n// Ray-sphere intersection test\nRay testRaySphere(in Ray ray, mat4 matrix)\n{\n    RayBasic localRay = toObjectSpace(ray.od, matrix);\n    \n    // A ray intersects a sphere in at most two places which means we can find t by solving a quadratic\n    float a = dot(localRay.d, localRay.d);\n    float b = 2.0 * dot(localRay.d, localRay.o);\n    float c = dot(localRay.o, localRay.o) - 1.0;\n    \n    float t0, t1;\n    if(!quadraticSolve(a, b, c, t0, t1)) { return nullRay(); }\n    \n    if(t1 < t0) \n    { \n        float swap = t1;\n        t1 = t0;\n        t0 = swap; \n    }\n\n    float tNear = ray.tNear;\n    vec3 n;\n    if(t0 > 0.0 && t0 < tNear)\n    {\n        n = localRay.o + localRay.d * t0;\n        tNear = t0;\n    }\n    else if(t1 > 0.0 && t1 < tNear)\n    {\n        n = localRay.o + localRay.d * t1;\n        tNear = t1;\n    }\n    else { return nullRay(); }\n    \n    vec3 hitLocal = n;\n    vec3 nLocal = n * 2.0;\n    mat4 invMatrix = inverse(matrix);\n    vec3 hitGlobal = mul3(hitLocal, invMatrix);\n    vec3 nGlobal = mul3(nLocal, invMatrix);    \n\n    return deriveRay(ray, tNear, normalize(nGlobal - hitGlobal), dot(localRay.o, localRay.o) < 1.0, vec2(0.0), 1e-5);\n}\n\n// Tests a ray with a cyclinder and returns the value of t or -1.0 if it's not a valid hit\nfloat testRayCylinder(in RayBasic ray, mat4 matrix, float L, float R, out float tNear, out vec3 n, out vec2 uv, out bool backfacing, out float kickoff)\n{\n    ray = toObjectSpace(ray, matrix);\n    \n    float a = sqr(ray.d.x) + sqr(ray.d.y);\n    float b = 2.0 * (ray.o.x * ray.d.x + ray.o.y * ray.d.y);\n    float c = sqr(ray.o.x) + sqr(ray.o.y) - R*R;\n    \n    float t0, t1;\n    if(!quadraticSolve(a, b, c, t0, t1)) { return -1.0; }\n\n    if(t1 < t0) \n    { \n        float swap = t1;\n        t1 = t0;\n        t0 = swap; \n    }\n\n    vec3 hit;\n    float halfL = L / 2.0;\n    float t = tNear;\n    if(t0 > 0.0 && t0 < t)\n    {\n        hit = ray.o + ray.d * t0;\n        if(hit.z > -halfL && hit.z < halfL)\n        {\n            t = t0;\n        }\n    }\n    if(t1 > 0.0 && t1 < t)\n    {\n        hit = ray.o + ray.d * t1;\n        if(hit.z > -halfL && hit.z < halfL)\n        {\n            t = t1;\n        }\n    }\n    \n    return (t == tNear) ? -1.0 : t;\n}\n\n// Tests a ray with the rounded tube signed distance function.\n// https://en.wikipedia.org/wiki/Signed_distance_function\nRay testRayTubeSDF(in Ray ray, mat4 matrix, float L, float R, float isoF)\n{\n    RayBasic localRay = toObjectSpace(ray.od, matrix);\n    \n    float t = 0.0;   \n    vec3 p, pRing;\n    float F;\n    int i;\n    const int kMaxSteps = 50;\n    bool inside;\n    \n    for(i = 0; i < kMaxSteps; i++)\n    {             \n        p = localRay.o + localRay.d * t;\n        if(p.z >= 0.0) {  p.z -= min(L * 0.5, p.z);}\n        else {  p.z += min(L * 0.5, -p.z); }\n        \n        vec3 pPlane = vec3(p.xy, 0.0);\n        float pPlaneLen = length(pPlane);        \n        pRing = (pPlaneLen < 1e-10) ? vec3(0.0) : (p - (pPlane * R / pPlaneLen));         \n        F = length(pRing) - isoF;\n        \n        if(i == 0) { inside = F < 0.0; }\n        \n        if(abs(F) < 0.005) break;\n        \n        t += abs(F);\n    }\n    \n    if(i == kMaxSteps || t > ray.tNear) { return nullRay(); }\n \n    vec3 nLocal = normalize(-pRing); \n    mat4 invMatrix = inverse(matrix);\n    vec3 hitGlobal = mul3(p, invMatrix);\n    vec3 nGlobal = mul3(nLocal, invMatrix);  \n    \n    return deriveRay(ray, t, -normalize(nGlobal - hitGlobal), inside, vec2(0.0), 1e-2);\n}\n\n\n// Small function that \"peels\" off luminance values above the threshold and remaps them to [0, 1]\nfloat peel(float L, float threshold) { return max(0.0, L - threshold) / (1.0 - threshold); }\n\n// Apply a sepia grade to the monochrome texture\n// https://en.wikipedia.org/wiki/Sepia_(color)\nvec3 grade(float L)\n{\n    #define kGradeGamma            2.2\n    #define kGradeOffset           0.0\n    #define kGradeGain             1.12\n    #define kGradeTint             vec3(0.165, 0.165, 0.204)\n    \n    // Apply gain and gamma correction\n    L = min(pow(L * kGradeGain + kGradeOffset, kGradeGamma), 1.0);\n\n    // We derive the sepia tone by fitting three, second order polynomials to samples taken from\n    // the original Einstein photo.\n    vec3 sepia;\n    sepia.x = 0.268143 * L*L + 0.239786 * L + 0.183071;\n    sepia.y = 0.278571 * L*L + 0.212143 * L + 0.079285;\n    sepia.z = 0.125714 * L*L + 0.141429 * L + 0.172857;    \n    \n    // The black levels in the original photo have been significantly lifted by the film stock. We can reproduce this effect\n    // by applying a simple per-channel minimum that the gives the same \"clamped\" effect with a slighly blueish tint\n    sepia = max(sepia, kGradeTint);\n    \n    // The photo of Maryam was shot on modern film so it lacks the \"burn out\" present in the original NASA shot. \n    // Instead, we can add a little additional definition and highlighting to her features to get a similar effect.\n    vec3 comp = sepia * (1.0 + peel(L, 0.7) * 0.2);\n    \n    // Clamp to [0, 1]\n    return clamp(comp, vec3(0.0), vec3(1.0));\n}\n\n\n// Sample the texture that we decoded and which is stored in Buffer A\nvec3 sampleDecodedTexture(vec2 uv, vec3 defaultColour)\n{     \n    // Outside the image? Just return the default \"wall\" colour\n    if(uv.x <= 0.0 || uv.x >= 1.0 || uv.y <= 0.0 || uv.y >= 1.0) { return defaultColour; }\n    \n    // The zone plate is a multi-frequency pattern that's useful for testing anti-aliasing filters\n    if(kEnableTexture == 0 || kZonePlateTest) \n    { \n        float zonePlateFreq = kZonePlateFreq;\n        float zonePlateExponent = 1.0;\n        if(kEnableTexture == 1 && kSettings[SETTING_ZONEPLATE].z != KEY_UNDEFINED)\n        {\n            zonePlateFreq = 50.0 * float(kSettings[SETTING_ZONEPLATE].x) / iResolution.x;\n            zonePlateExponent = 0.01 + 2.0 * float(kSettings[SETTING_ZONEPLATE].y) / iResolution.y;\n        }\n        float albedo = 0.5 + cos(zonePlateFreq * 512.0 * (sqr(uv.x - 0.5) + sqr(uv.y - 0.5))) * 0.5; \n        return vec3(pow(albedo, zonePlateExponent));\n    }\n    \n    // Recover the actual integer XY coordinates \n    uv = (vec2(0.0, float(kTextureStartRow)) + vec2(uv.x, 1.0 - uv.y) * vec2(float(kTextureStats.z - 1), float(kTextureStats.z - 1))) / vec2(iResolution);\n\n    // Sample and grade\n    return grade(texture(iChannel0, uv).x);\n}\n\n\n// Reflection and refraction. Not used because we use WebGL's built-in functions, but helpful to keep them here anyway.\nvec3 reflectRay(vec3 i, vec3 n) { return n * 2.0 * dot(-i, n) + i; }\nvec3 refractRay(vec3 i, vec3 n, float eta)\n{    \n    float nDoti = -dot(i, n);\n    float alpha = 1.0 - eta * eta * (1.0 - nDoti * nDoti);    \n    return (alpha < 0.0) ? reflectRay(n, i) : (i * eta + n * (eta * nDoti - sqrt(alpha)));\n}\n\n\n// Calculate the real component of Fresnel reflection for the given pair of refractive indices\nfloat fresnel(float cosI, float eta1, float eta2)\n{\n    float sinI = sqrt(1.0 - cosI * cosI);\n    float beta = 1.0 - sqr(sinI * eta1 / eta2);\n   \n    if(beta < 0.0) { return 1.0; }\n    \n    float alpha = sqrt(beta);\n    return (sqr((eta1 * cosI - eta2 * alpha) / (eta1 * cosI + eta2 * alpha)) +\n            sqr((eta1 * alpha - eta2 * cosI) / (eta1 * alpha + eta2 * cosI))) * 0.5;\n}\n\n\n// Simple specular reflection\nRay sampleConductor(Ray incident)\n{\n    vec3 p = incident.od.o + incident.od.d * incident.tNear;\n    vec3 r = reflect(incident.od.d, incident.n);    \n    return createRay(p, r, incident.n * incident.kickoff, incident.weight, 0.0, incident.lambda);\n}\n\n\n// Apply the Beer-Lambert law to calculate the degree of absorption as light travels through a dielectric \n// https://en.wikipedia.org/wiki/Beer-Lambert_law\nvec3 computeDielectricAbsorption(float distance)\n{\n    if(kSettings[SETTING_ABSORPTION].z == KEY_UNDEFINED) { return kDielectricAbsorption; }\n    \n    float x = float(kSettings[SETTING_ABSORPTION].x) / iResolution.x - 0.5;\n    float y = float(kSettings[SETTING_ABSORPTION].y) / iResolution.y - 0.5;\n    float phi = atan(y, x) + kPi;\n    float r = sqrt(x*x + y*y) * 3.0;\n    r = r*r*r;\n    \n    return exp(-distance * hue(phi) * r);\n}\n\n\n// Sample dielectric transmission\nRay sampleDielectric(Ray incident, int depth, vec2 fragCoord)\n{     \n    // Either use the built-in or user-defined index of refraction\n    float ior = (kSettings[SETTING_ETA].z != KEY_UNDEFINED) ? (1.0 + 2.0 * float(kSettings[SETTING_ETA].x) / iResolution.x) : kDielectricIor;\n\n    // If we're using the spectral integrator, apply Cauchy's equation to apply dielectric dispersion\n    // https://en.wikipedia.org/wiki/Cauchy%27s_equation\n    if(kSpectralIntegrator) \n    { \n        float dispersion = (kSettings[SETTING_ETA].z != KEY_UNDEFINED) ? \n                           (10.0 * pow(float(kSettings[SETTING_ETA].y) / iResolution.y, 2.0)) : kDielectricDispersion;\n        \n        ior += dispersion * 5.31e3 / sqr(incident.lambda * 0.1); \n    }\n    \n    vec2 eta;\n    vec3 n;\n    if(incident.backfacing) \n    {\n        eta = vec2(ior, 1.0);  \n        n = -incident.n;        \n        \n        // Apply absorbtion if applicable\n        incident.weight *= computeDielectricAbsorption(incident.tNear);\n    }\n    else\n    {\n        eta = vec2(1.0, ior);\n        n = incident.n;\n    }  \n    \n    // Calculate the Fresnel coefficient and associated vectors\n    float F = fresnel(dot(-incident.od.d.xyz, n), eta.x, eta.y);     \n    float xi = rand(iChannel1).x;\n    vec3 i = incident.od.d;\n    vec3 p = incident.od.o + incident.od.d * incident.tNear;\n    \n    // Most GPUs can't do recursion, so we use purely stochastic sampling to determine whether to reflect transmit the extant ray.\n    // Whether or not this effect is physically based depends on how we choose to model the system. Maxwell's equations\n    // describe reflection and refraction as a division of energy as the electromagnetic wavefront propagates from one \n    // medium to the next. On the other hand, a quantum mechanical model treats a single photon as a superposition of \n    // reflection and refraction whose wave equation collapses when the photon is detected. \n    if(xi <= F)\n    {           \n        vec3 r = reflect(i, n);    \n        return createRay(p, r, n * incident.kickoff, incident.weight, 0.0, incident.lambda);\n    }\n    else\n    {\n        vec3 t = refract(i, n, eta.x / eta.y);\n        return createRay(p, t, -n * incident.kickoff, incident.weight, 0.0, incident.lambda);\n    }\n}\n\n\n// The power and balance heuristics are weighting functions that allow multiple estimators to be seamlessly combined in a provably optimal\n// way (for single samples)\n// Optimally Combining Sampling Techniques for Monte Carlo Rendering (Veach and Guibas)\n// https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.127.8105&rep=rep1&type=pdf\nfloat powerHeuristic(float pdf1, float pdf2)\n{\n    return 2.0 * sqr(pdf1) / (sqr(pdf1) + sqr(pdf2));\n}\n\n\n// Multiple-importance sample the quad light and the surface together (Veach and Guibas). We treat all diffuse surface\n// and perfect Lambertian reflectors which greatly simplifies these calculations. Normally, BRDF and light sampling would\n// be separated into polymorphic objects and evaluated orthogonally to the integration step. See Phar, Jacob and Humphreys'\n// indespensible book, \"Physically Based Rendering: From Theory to Implementation\" for in-depth commentary on how this is done. \n// https://www.pbrt.org\nRay sampleQuadLightMonteCarlo(in Ray incident, int depth, vec2 fragCoord, vec3 albedo, mat4 emitterMatrix, vec2 emitterSize, vec3 emitterRadiance, int sampleMode)\n{             \n    // Single-sample MIS means we decide whether to sample the light or the BRDF using a purely stochastic process\n    vec3 xi = rand(iChannel1).xyz;\n    \n    // Sample the light\n    if(sampleMode == kSampleLights || (sampleMode == kSampleMis && xi.z <= 0.5))\n    {                      \n        // Sample a point on the light \n        vec3 hitPos = incident.od.o + incident.od.d * incident.tNear;        \n        mat4 invMatrix = inverse(emitterMatrix);\n        xi.xy -= vec2(0.5);\n        vec3 lightPos = mul3(vec3(xi.xy, 0.0), invMatrix);  \n        \n        // Compute the normalised extant direction based on the light position local to the shading point\n        vec3 extantDir = lightPos - hitPos;       \n        float lightDist = length(extantDir);        \n        extantDir /= lightDist;\n        \n        // Test if the emitter is behind the shading point\n        if(dot(extantDir, incident.n) <= 0.0) { return nullRay(); }            \n        \n        // Test if the emitter is rotated away from the shading point\n        vec3 lightNormal = mul3(vec3(xi.xy, 1.0), invMatrix);\n        float cosPhi = dot(extantDir, normalize(lightNormal - lightPos));\n        if(cosPhi < 0.0) { return nullRay(); }\n        \n        // Compute the projected solid angle of the light        \n        float solidAngle = cosPhi * min(10.0, emitterSize.x * emitterSize.y / sqr(lightDist));            \n        \n        // Compute the PDFs of the light and BRDF\n        float cosTheta = dot(incident.n, extantDir);        \n        float pdfBrdf = cosTheta / kPi;\n        float pdfLight = 1.0 / solidAngle;  \n\n        // Calculate the ray throughput in the event that is hits the light\n        vec3 throughput = incident.weight * albedo * emitterRadiance * solidAngle * cosTheta / kPi;          \n        \n        if(sampleMode == kSampleMis) { throughput *= powerHeuristic(pdfLight, pdfBrdf); }\n         \n        // Create the ray from the sample light direction and the calculated throughput\n        return createRay(hitPos, \n                           extantDir, \n                           (incident.backfacing ? -incident.n : incident.n) * incident.kickoff,\n                           throughput,\n                           -1.0,\n                           incident.lambda);  \n        \n    }    \n    // Sample the BRDF\n    else if(sampleMode == kSampleBrdf || (sampleMode == kSampleMis && xi.z > 0.5))\n    {\n        // Sample the Lambertian direction\n        vec3 r = vec3(sampleUnitDisc(xi.xy), 0.0);\n        r.z = sqrt(1.0 - sqr(r.x) - sqr(r.y));\n    \n        // Transform it to world space\n        mat4 basis = createBasis(incident.n);\n        vec3 extantDir = mul3(r, basis);      \n\n        // Create the ray from the sampled BRDF direction\n        return createRay(incident.od.o + incident.od.d * incident.tNear, \n                           mul3(r, basis), \n                           (incident.backfacing ? -incident.n : incident.n) * incident.kickoff,\n                           incident.weight * albedo,\n                           r.z / kPi,\n                           incident.lambda);                         \n     }\n     \n     return nullRay();\n}\n\n\n// Evaluate the value from the quad light when a ray intersects it\nvec3 evaluateQuadLight(Ray incident, vec2 emitterSize, vec3 emitterRadiance, int sampleMode)\n{             \n    if(sampleMode == kSampleBrdf) { return emitterRadiance * incident.weight; }\n    \n    float solidAngle = dot(incident.n, incident.od.d) * emitterSize.x * emitterSize.y / sqr(incident.tNear);\n    \n    float pdfBrdf = incident.pdf;\n    float pdfLight = 1.0 / solidAngle;\n    \n    return emitterRadiance * powerHeuristic(pdfBrdf, pdfLight) * incident.weight;\n}\n\n\n// Stokes' theorem means we can precisely evaluate the irradiance from an arbirary, unoccluded polygon\n// \"Closed-Form Expressions for Irradiance from Non-Uniform Lambertian Luminaires\" (Chen and Arvo)\n// https://core.ac.uk/download/pdf/216151544.pdf\nvec3 evaluateQuadLightContour(Ray incident, mat4 emitterMatrix, vec3 emitterRadiance)\n{\n    mat4 invMatrix = inverse(emitterMatrix);\n    vec3 pShade = incident.od.o + incident.od.d * incident.tNear;\n    vec3 p[4] = vec3[4](normalize(mul3(vec3(-0.5, -0.5, 0.0), invMatrix) - pShade),\n                        normalize(mul3(vec3(0.5, -0.5, 0.0), invMatrix) - pShade),\n                        normalize(mul3(vec3(0.5, 0.5, 0.0), invMatrix) - pShade),\n                        normalize(mul3(vec3(-0.5, 0.5, 0.0), invMatrix) - pShade));   \n    \n    float E = 0.0;\n    for(int i = 0; i < 4; i++)\n    {\n        int j = (i + 1) % 4;\n        E += acos(clamp(dot(p[i], p[j]), -1.0, 1.0)) * normalize(cross(p[i], p[j])).z;\n    }    \n    \n    return E * emitterRadiance * incident.weight / (2.0 * kPi);\n}\n\n\n// This function is the heart of our path tracer. It tests a ray with scene geometry and then shades it according\n// to its detected properties. \nRay traceWavefront(in Ray ray, out vec3 L, vec2 fragCoord, int depth)\n{        \n    int materialIdx = kMaterialNull;        \n    int sampleMode = kSampleLights;\n    \n    #define kGlassOffset vec3(-0.5, 0.0, 0.0)\n    #define kEnvironment vec3(0.0)\n    #define kWallColour  vec3(0.745, 0.682, 0.584)\n               \n    // Test the back wall i.e. the surface on which the built-in photo of Maryam is displayed\n    mat4 textureMatrix = compound(0.0, 0.0, 0.0, vec3(10.0), vec3(0.0, -0.7, -8.0)); \n    Ray hit = testRayPlane(ray, textureMatrix, false);\n    if(hit.tNear != kInvalidHit)\n    { \n        materialIdx = kMaterialPhoto; \n        ray = hit;\n    }    \n    \n    // Test the emitter quad\n    vec2 emitterSize = vec2(20.0, 10.0);\n    mat4 emitterMatrix = compound(toRad(-35.0), 0.0, 0.0, vec3(emitterSize, min(emitterSize.x, emitterSize.y)), vec3(0.0, -7.0, -4.0));   \n    if(depth > 1 || kLightsVisibleToCamera)\n    {\n        hit = testRayPlane(ray, emitterMatrix, true);\n        if(hit.tNear != kInvalidHit) \n        { \n            materialIdx = kMaterialEmitter; \n            ray = hit;\n        }\n    }\n    \n    // Test the dielectric sphere a.k.a. the fused quartz gyroscope \n    mat4 sphereMatrix = compound(0.0, 0.0, 0.0, vec3(0.3), vec3(0.0, 0.0, 0.0) + kGlassOffset);    \n    hit = testRaySphere(ray, sphereMatrix);\n    if(hit.tNear != kInvalidHit) \n    { \n        materialIdx = kMaterialDielectric;\n        ray = hit;\n    }\n    \n    // Test the acrylic \"plinth\" on which the sphere rests\n    mat4 cylinderMatrix = compound(toRad(90.0), 0.0, 0.0, vec3(1.0), vec3(0.0, -0.81, 0.0) + kGlassOffset); \n    hit = testRayTubeSDF(ray, cylinderMatrix, 1.0, 0.065, 0.02);\n    if(hit.tNear != kInvalidHit)\n    { \n        materialIdx = kMaterialDielectric; \n        ray = hit;\n    }\n    \n    // If we're in debug mode, always shade the normals\n    if(materialIdx != kMaterialNull && kDebugNormals) { materialIdx = kMaterialNormals; }\n\n    switch(materialIdx)\n    {\n        // Diffuse material containing the photo\n        case kMaterialPhoto: \n        {\n           // Sample the texture\n           vec3 albedo = sampleDecodedTexture(ray.uv, kWallColour);\n           \n           if(kAnalyticLights)\n           {\n               // If we're using analytic lights, compute the energy reflected from the Lambertian surface and return. Don't bother to test for occlusion.\n               L += evaluateQuadLightContour(ray, emitterMatrix, kEmitterRadiance) * albedo;           \n               return nullRay();\n           }\n           else\n           {\n               // Monte Carlo sampling is slower but much more versatile\n               Ray extant = sampleQuadLightMonteCarlo(ray, depth, fragCoord, albedo, emitterMatrix, emitterSize, kEmitterRadiance, sampleMode);\n               if(extant.pdf != 0.0) { return extant; }    \n           }\n           break;\n        } \n        \n        // Emitter material\n        case kMaterialEmitter:\n        {\n            if(!ray.backfacing) { return nullRay(); }\n            \n            if(ray.pdf == 0.0) // Specular ray or not using light sampling\n            {\n                L += vec3(kEmitterRadiance) * ray.weight;\n            }\n            else if(ray.pdf < 0.0) // Explicit light sample so the weight is actually the throughput\n            {\n                L += ray.weight;\n            }\n            else // BRDF sample\n            {\n                L = evaluateQuadLight(ray, emitterSize, kEmitterRadiance, sampleMode);\n            }\n            break;\n        }\n        \n        // Dielectric material\n        case kMaterialDielectric:  { return sampleDielectric(ray, depth, fragCoord); break; } \n        \n        // Perfect specular conductor\n        case kMaterialConductor:   { return sampleConductor(ray); break; }\n        \n        // Normals debug shader\n        case kMaterialNormals:     { L += ray.n; break; }\n        \n        // Ray hit nothing, so add the radiance from the environment\n        default:                   { L += kEnvironment; break; }\n    }\n    \n    // Didn't generate a ray? Too bad. \n    return nullRay();\n}\n\n\n// A Gaussian function that we use to sample the XYZ standard observer \nfloat CIEXYZGauss(float lambda, float alpha, float mu, float sigma1, float sigma2)\n{\n   return alpha * exp(sqr(lambda - mu) / (-2.0 * sqr(lambda < mu ? sigma1 : sigma2)));\n}\n\n\n// Create a camera ray and iteratively fire it into the scene until either it terminates or reaches max depth\nvec3 traceCameraRay(vec2 fragCoord, int sampleIdx)\n{\n    // Create a new camera ray and store the sampled wavelength (we reuse the same ray at each bounce)\n    Ray ray = createCameraRay(fragCoord);\n    float lambda = ray.lambda;\n    \n    vec3 L = vec3(0.0);\n    int depth = 0;\n    for(depth = 0; depth < kMaxPathDepth; depth++)\n    {\n        // Passing Ray structures by reference breaks the shader on Macs. This explains\n        // the clunky approach to returning extant rays by value.\n        ray = traceWavefront(ray, L, fragCoord, depth + 1);\n        if(ray.tNear == kInvalidHit) { break; }\n    }\n      \n    if(kSpectralIntegrator)\n    {  \n        // Here we use a set of fitted Gaussian curves to approximate the CIE XYZ standard observer.\n        // See https://en.wikipedia.org/wiki/CIE_1931_color_space for detals on the formula\n        // This allows us to map the sampled wavelength to usable RGB values. This code needs cleaning \n        // up because we do an unnecessary normalisation steps as we map from lambda to XYZ to RGB.\n        \n        #define kRNorm (7000.0 - 3800.0) / 1143.07\n        #define kGNorm (7000.0 - 3800.0) / 1068.7\n        #define kBNorm (7000.0 - 3800.0) / 1068.25\n\n        // Sample the Gaussian approximations\n        vec3 xyz;\n        xyz.x = (CIEXYZGauss(lambda, 1.056, 5998.0, 379.0, 310.0) + \n                 CIEXYZGauss(lambda, 0.362, 4420.0, 160.0, 267.0) + \n                 CIEXYZGauss(lambda, 0.065, 5011.0, 204.0, 262.0)) * kRNorm;\n        xyz.y = (CIEXYZGauss(lambda, 0.821, 5688.0, 469.0, 405.0) + \n                 CIEXYZGauss(lambda, 0.286, 5309.0, 163.0, 311.0)) * kGNorm;\n        xyz.z = (CIEXYZGauss(lambda, 1.217, 4370.0, 118.0, 360.0) + \n                 CIEXYZGauss(lambda, 0.681, 4590.0, 260.0, 138.0)) * kBNorm;\n\n        // XYZ to RGB linear transform\n        vec3 rgb;\n        rgb.r = (2.04159 * xyz.x - 0.5650 * xyz.y - 0.34473 * xyz.z) / (2.0 * 0.565);\n        rgb.g = (-0.96924 * xyz.x + 1.87596 * xyz.y + 0.04155 * xyz.z) / (2.0 * 0.472);\n        rgb.b = (0.01344 * xyz.x - 0.11863 * xyz.y + 1.01517 * xyz.z) / (2.0 * 0.452);\n        \n        L *= rgb;\n    }\n   \n    return L;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Initialise the PCG random number generator\n    kFragCoord = ivec2(fragCoord);\n    pcgInitialise(iFrame);\n    \n    // Set the texture stats in a global variable\n    kTextureStats = getTextureState(iChannel0, iFrame);\n    \n    // Load the settings for the user-configurable parameters so we can easily access them\n    kSettings[SETTING_CAMERA_POS] = ivec3(getUserParameter(KEY_Q, iChannel0).zwy);\n    kSettings[SETTING_CAMERA_FLENGTH] = ivec3(getUserParameter(KEY_W, iChannel0).zwy);\n    kSettings[SETTING_CAMERA_FSTOP] = ivec3(getUserParameter(KEY_E, iChannel0).zwy);\n    kSettings[SETTING_LENS_ABERRATION] = ivec3(getUserParameter(KEY_A, iChannel0).zwy);\n    kSettings[SETTING_ETA] = ivec3(getUserParameter(KEY_S, iChannel0).zwy);\n    kSettings[SETTING_ZONEPLATE] = ivec3(getUserParameter(KEY_F, iChannel0).zwy);    \n    kSettings[SETTING_ABSORPTION] = ivec3(getUserParameter(KEY_D, iChannel0).zwy);\n    \n    // If the user is dragging the mouse, stop accumulating and just show a single sample\n    refreshView = iMouse.z > 0.0 && (\n                       ((kSettings[SETTING_CAMERA_POS].z & KEY_REFRESH) != 0) || \n                       ((kSettings[SETTING_CAMERA_FLENGTH].z & KEY_REFRESH) != 0) || \n                       ((kSettings[SETTING_CAMERA_FSTOP].z & KEY_REFRESH) != 0) || \n                       ((kSettings[SETTING_LENS_ABERRATION].z & KEY_REFRESH) != 0) ||\n                       ((kSettings[SETTING_ABSORPTION].z & KEY_REFRESH) != 0) ||\n                       ((kSettings[SETTING_ZONEPLATE].z & KEY_REFRESH) != 0) ||\n                       ((kSettings[SETTING_ETA].z & KEY_REFRESH) != 0));\n    \n    // Load the previously accumulated values if applicable\n    fragColor = (refreshView || (kEnableTexture == 1 && kTextureStats.y == kTextureNotReady)) ? \n                 vec4(0.0, 0.0, 0.0, 0.0) : texelFetch(iChannel2, ivec2(fragCoord), 0); \n    \n    // Trace the camera ray and increment the sample count\n    fragColor.xyz += traceCameraRay(fragCoord, 0);    \n    fragColor.w += 1.0;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*//////////////////////////////////////////////////////////////////////////////////////////////////\n\n   Copyright (c) 2021 Ben Spencer   \n   Released under the MIT Licence\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n         \n   Description:   \n   \n   This file exists purely to execute the first of two passes of the lens bloom post-process\n   filter. \n   \n//////////////////////////////////////////////////////////////////////////////////////////////////*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if(kApplyBloom)\n    {    \n        fragColor.xyz = bloom(fragCoord, iResolution, ivec2(1, 0), iChannel0, iChannel2); \n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}