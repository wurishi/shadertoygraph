{"ver":"0.1","info":{"id":"wsjczR","date":"1586009042","viewed":67,"name":"luces--Test-v1","username":"jorge2017a1","description":"luces--Test-v1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lucestestv1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//por jorge2017a1---\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n\nvec3 lPos1,lPos2,lPos3;\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    float Numcolor;\n    float NumObj;\n};\n\nstruct TResultadoHit\n{\n   float tipo;\n   float NumObj;\n   float dist;\n   float Numcolor;\n};\n    \n    \n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n\nTResultadoHit opUResultado(TResultadoHit d1, TResultadoHit d2 ) \n{\n  TResultadoHit resp;\n    \n    if (d1.dist < d2.dist){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///-----------------------------------------\n\nTResultadoHit setResultadoDistNcT(float dist, float Numcolor,float tipo,float NumObj)\n{   \n  TResultadoHit resp;\n    resp.tipo =tipo;\n    resp.dist =dist;\n    resp.Numcolor =Numcolor;\n    resp.NumObj=NumObj;\n    \n  return resp;   \n}\n\n///-----------------------------------------\nTResultadoHit GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    \n    float planeInferior = p.y+2.0;  //piso inf\n    float planeSuperior = 10.0-p.y;  //piso inf\n    float planeLIzq = p.x+10.0; //pared izq\n    float planeLDer = 10.0-p.x;  //pared der\n    float planeAtras = -p.z+40.5;  //pared atras\n    \n    \n    vec3 pp;\n    pp=p;\n    //vec3 res;\n    TResultadoHit res;\n    \n    res = setResultadoDistNcT(9999.9,-1.,-1.,-1.);\n    \n    \n \n    res=opUResultado(res, setResultadoDistNcT(planeSuperior,8.,1. ,1.));  \n    res=opUResultado(res, setResultadoDistNcT(planeInferior,8.,1. ,2.));  \n    res=opUResultado(res, setResultadoDistNcT(planeLIzq,5. ,1.0,3.));\n    res=opUResultado(res, setResultadoDistNcT(planeLDer,3.,1. ,4.));\n    res=opUResultado(res, setResultadoDistNcT(planeAtras,4. ,1.0,5.));\n\n    \n    float sdBoxFoco1= sdSphere(p- lPos1, 0.5);\n    float sdBoxFoco2= sdSphere(p- lPos2, 1.0);\n    float sdBoxFoco3= sdSphere(p- lPos3, 1.0);\n  \n    \n    \n    res=opUResultado(res, setResultadoDistNcT(sdBoxFoco1,2.,2.0 ,6.));\n    res=opUResultado(res, setResultadoDistNcT(sdBoxFoco2,3.,2.0 ,7.));\n    res=opUResultado(res, setResultadoDistNcT(sdBoxFoco3,5.,2.0 ,8.));\n    \n    \n    float sdBox1= sdBox(p- vec3(0.0,3.0,-2.0), vec3(0.5,0.4,0.5));\n    res=opUResultado(res, setResultadoDistNcT(sdBox1,5.,3.0 ,9.));\n    \n    mObj.dist =  res.dist;\n    mObj.Numcolor = res.Numcolor;\n    mObj.tipo =  res.tipo;\n    \n    return res;\n}\n\n\n//-----------------------------------\n\nTResultadoHit RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n\n        TResultadoHit distHit = GetDist(p);\n        \n        t_near += distHit.dist;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return setResultadoDistNcT(-1.,-1.0,-1.0,-1.);\n\n    \t}else if(distHit.dist < SURF_DIST){\n            \n\n            return setResultadoDistNcT(t_near,distHit.Numcolor,distHit.tipo,distHit.NumObj);\n        }    \n        \n    }\n    \n    \n\n    return setResultadoDistNcT(-1.0,-1.0,-1.0,-1.0);\n}\n\n//-----------------------------------\n\nvec3 GetNormal(vec3 p) {\n    // vec2 e = vec2(0.0035, -0.0035);\n    vec2 e = vec2(0.0035, -0.0035);   \n    \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).dist + \n        e.yyx * GetDist(p + e.yyx).dist + \n        e.yxy * GetDist(p + e.yxy).dist + \n        e.xxx * GetDist(p + e.xxx).dist);\n    \n    \n    return normalize(n);\n}\n\n\n\n//--------------------------------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        return vec3(0.,0.,0.);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(0.,0.,1.);\n    } \n    if(i== 2 )\n    {\n       return vec3(0.,1.,0.);\n    } \n    if(i== 3 )\n    {\n        return vec3(0.,1.,1.);\n    } \n    if(i== 4 )\n    {\n        return vec3(1., 0., 0.);\n    } \n    \n    if(i== 5 )\n    {\n        return vec3(1., 0.,1.);\n        } \n    if(i== 6 )\n    {\n        \n    \treturn vec3(1., 1., 0.);\n    } \n        \n    if(i== 7 )\n    {\n        return vec3(1., 1., 1.);\n       } \n    if(i== 8 )\n    {\n       \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.8); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    \n  \n    \t\n}\n\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n//-------------------------------------------------\n\n\n///--------------------------------------\n\n\nvec3 light(vec3 pos, vec3 lightPos, vec3 lightCol, float intensity, float hard)\n{\n    vec3 n = GetNormal(pos);\n    vec3 lightDir = normalize(lightPos - pos);\n    float dp = dot(n, lightDir);\n    float attenuation = pow(distance(lightPos, pos), 2.0);\n    //float shdw = shadow(pos, lightPos, hard);\n    float shdw = 0.25;\n    \n    return lightCol * max(dp, 0.0) / attenuation * intensity * shdw;\n}\n\nvec3 lighting(vec3 pos,TResultadoHit Obj  )\n{\n    // the lighting setup of the scene is described here\n   \t vec3 col = vec3(0.0, 0.0, 0.0); // ambient light\n    \tcol += light(pos, lPos1, getSphereColor(int( 2.0)), 100.0, 4.0); \n    \tcol += light(pos, lPos2, getSphereColor(int( 3.0)), 100.0, 4.0); \n    \tcol += light(pos, lPos3, getSphereColor(int( 5.0)), 100.0, 16.0); \n            \n       \n    \n    return col;\n}\n\n//-----------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n    lPos1 =vec3(0.0+3.0*sin(iTime),4.0+2.0*cos(iTime),0.0);\n    lPos2 =vec3(0.0+5.0*cos(iTime),3.0+3.0*cos(iTime),20.0);\n    lPos3 =vec3(0.0+4.5*cos(iTime),2.5+5.0*cos(iTime),10.0);\n    \n  \n    \n    vec3 ro = vec3(0 ,5.5,-5.0);\n    vec3 rd =normalize(vec3(uv,0.5) );\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t\n    \n    //vec2 d = RayMarch(ro, rd);\n    TResultadoHit d = RayMarch(ro, rd);\n    \n    Obj=mObj;\n    \n    \n    if(d.dist == -1.){\n        //col = getSphereColor(int( d.Numcolor)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.dist ); \n    glpRoRd=p;\n    \n   \n    float dif=0.35;\n    \n    \n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.Numcolor));\n    \n    vec3 nor= GetNormal( p);\n        \n    col=vec3(0.0);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    \n      col= result*dif;\n      vec3 col2;\n       col2 = lighting(p, d);\n      col =col+col2*1.0;\n       \n      col = pow(col, vec3(1.0/2.2));   \n        \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"}]}