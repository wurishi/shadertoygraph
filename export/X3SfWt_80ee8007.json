{"ver":"0.1","info":{"id":"X3SfWt","date":"1730538776","viewed":67,"name":"Comfy gums illustration","username":"Miolith","description":"This is just an illustration I will need to explain few things about one of my shaders [url]https://shadertoy.com/view/lffGWX[/url]","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["illustration","hyperellipse","comfy","gums","schema"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Comfy gums\" by Miolith. https://shadertoy.com/view/lffGWX\n// 2024-10-27 19:11:20\n\nconst float fovDegrees = 50.;\nconst float fov = 1.0 / tan(radians(fovDegrees) * 0.5);\n\nconst float cameraOffset = 5.0;\n\nmat2 rotation(float angle)\n{\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n}\n\nfloat draw2d_line(vec2 uv, vec2 startPoint, vec2 endPoint)\n{\n    vec2 ap = uv - startPoint;\n    vec2 line = endPoint - startPoint;\n    float h = clamp(dot(ap, line) / dot(line, line), 0., 1.);\n    return distance(uv, startPoint + h * line);\n}\n\nvoid draw_line(vec2 uv, vec3 point1, vec3 point2, inout vec3 col)\n{\n    float dist = draw2d_line(\n        uv,\n        point1.xy / (point1.z + cameraOffset) * fov,\n        point2.xy / (point2.z + cameraOffset) * fov\n    );\n    \n    col = mix(col, vec3(0.0), smoothstep(0.006, 0.0, dist));\n}\n\nfloat hyperellipseSdf(vec3 pos, vec3 center, float radius)\n{\n    float n = 4.;\n    return pow(dot(pow(abs(pos - center), vec3(n)), vec3(1)), 1./n) - radius;\n}\n\nfloat opLimitedRepetition( in vec3 p, in float s, in vec3 l )\n{\n    vec3 q = p - s*clamp(round(p/s),-l,l);\n    return hyperellipseSdf( q, vec3(0.0),0.35 );\n}\n\nfloat scene(vec3 ray_pos)\n{\n    ray_pos.z -= 5.0;\n    ray_pos.xy *= rotation(radians(-10.) +  iTime);\n    ray_pos.xz *= rotation(radians(30.) +  iTime);\n    ray_pos *= 1.2;\n    \n    float sphere = opLimitedRepetition(ray_pos, 1.0, vec3(1.0));\n    \n    return sphere / 1.2;\n}\n\nvec3 palette( float t, vec3 a, vec3 b,  vec3 c, vec3 d)\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 colorize(float t)\n{\n    return palette(t,\n        vec3(1.000,0.761,0.678),\n        vec3(1.000,0.714,0.620),\n        vec3(1.000,1.000,1.000),\n        vec3(0.541,0.420,0.376)\n    );\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nfloat dot2(vec3 p) { return dot(p,p); }\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    vec3 ray_origin = vec3(uv, fov - cameraOffset);\n    \n    vec2 start_xy = uv;\n    vec3 ray_dir = normalize(vec3(start_xy, fov));\n    \n    float t = 0.0;\n    \n    float time = iTime / 2.0;\n    \n    const vec3 middle = vec3(0, 0, 5);\n    const vec3 start = middle + vec3(-2.);\n\n    vec3 ray_pos = ray_origin;\n    for (int i = 0; i < 80; i++)\n    {\n        ray_pos = ray_origin + ray_dir * t;\n\n        float dist = scene(ray_pos);\n        \n        t += dist;\n        \n        if (dist > 100.0 || dist < 0.001) break;\n    }\n    \n    vec3 forward = vec3(0,0,1);\n    mat3 rot = rotationMatrixAxisAngle(\n        normalize(normalize(middle - start) + forward),\n        radians(180.)\n    );\n      \n    const float size = 2.85;\n    const float depth = 6.;\n    \n    vec3 p1 = start + rot * vec3(size, size, depth);\n    vec3 p2 = start + rot * vec3(-size, size, depth);\n    vec3 p3 = start + rot * vec3(-size, -size, depth);\n    vec3 p4 = start + rot * vec3(size, -size, depth);\n    \n    const float scale = 0.48;\n    \n    vec3 small_p1 = start + rot * vec3(size, size, depth)*scale;\n    vec3 small_p2 = start + rot * vec3(-size, size, depth)*scale;\n    vec3 small_p3 = start + rot * vec3(-size, -size, depth)*scale;\n    vec3 small_p4 = start + rot * vec3(size, -size, depth)*scale;\n    \n    vec3 planeNormal = normalize(cross(small_p2 - small_p1, small_p4 - small_p1));\n    float h = dot(small_p1, planeNormal);\n    \n    if (t >= 100.0)\n    {\n        col = vec3(1.0);\n        draw_line(uv, start, p1, col);\n        draw_line(uv, p4, p1, col);\n        draw_line(uv, p1, p2, col);\n        \n        draw_line(uv, small_p4, small_p1, col);\n        draw_line(uv, small_p1, small_p2, col);\n        \n        ray_pos = ray_origin;\n        float t2 = 0.0;\n        for (int i = 0; i < 80; i++)\n        {\n            ray_pos = ray_origin + ray_dir * t2;\n\n            float dist = udQuad(\n                ray_pos, small_p1, small_p2, small_p3, small_p4\n            ) - 0.001;\n\n            t2 += dist;\n\n            if (dist > 10.0 || dist < 0.001) break;\n        }\n        \n        if (t2 < 10.)\n        {\n            col = col * vec3(1.0,0.8,0.8);\n        }\n    }\n    else\n    {\n    \n        col = vec3(1.000,0.761,0.678) * exp(-(t - cameraOffset)*0.04);\n        vec3 normal = normalize(start - middle);\n        \n        if (dot(planeNormal, ray_pos) < h)\n        {\n            col = mix(col, vec3(1,0,0), 0.2);\n            col = mix(col, vec3(1,0,0), smoothstep(0.8,0.9, sin((uv.x +uv.y)*100.)));\n        }\n    }\n    \n    \n\n    \n    draw_line(uv, start, p2, col);\n    draw_line(uv, start, p3, col);\n    draw_line(uv, start, p4, col);\n    \n    \n    draw_line(uv, p2, p3, col);\n    draw_line(uv, p3, p4, col);\n    \n    draw_line(uv, small_p2, small_p3, col);\n    draw_line(uv, small_p3, small_p4, col);\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}