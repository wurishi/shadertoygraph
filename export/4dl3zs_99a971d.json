{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n Playing around with some materials and shadows. Mouse rotates the camera.\n\n 10/08/13: \n\tpublished\n\nmuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\n#define occlusion_enabled\n#define occlusion_pass1_quality 40\n#define occlusion_pass2_quality 8\n\n#define noise_use_smoothstep\n\n#define object_count 8\n#define object_speed_modifier 1.0\n\n#define render_steps 128\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321); //decent hash for noise generation\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat hashmix(vec3 p0, vec3 p1, vec3 interp)\n{\n\tfloat v0 = hashmix(p0.xy+vec2(p0.z*143.0,0.0),p1.xy+vec2(p0.z*143.0,0.0),interp.xy);\n\tfloat v1 = hashmix(p0.xy+vec2(p1.z*143.0,0.0),p1.xy+vec2(p1.z*143.0,0.0),interp.xy);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec3(0.0),vec3(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[2]);\n}\n\nfloat noise(vec3 p) // 3D noise\n{\n\tvec3 pm = mod(p,1.0);\n\tvec3 pd = p-pm;\n\treturn hashmix(pd,(pd+vec3(1.0,1.0,1.0)), pm);\n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0,+1.0);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nbool iswallx(vec2 p)\n{\n\tif (p.y==4.0 && p.y<=8.0 && p.x>=-4.0 && p.x<=8.0) return true;\n\tif (p.y>=-4.0 && p.y<=0.0 && p.x>=-4.0 && p.x<=4.0) return true;\n\treturn false;\n}\n\nbool iswallz(vec2 p)\n{\n\tif (p.y>=0.0 && p.y<=12.0 && p.x>=4.0 && p.x<=8.0) return true;\n\tif (p.y>=-8.0 && p.y<=0.0 && p.x>=-12.0 && p.x<=-8.0) return true;\n\treturn false;\n}\n\nfloat spheres(vec3 p)\n{\n\tp.xz += vec2(2.0);\n\tbool wallx=iswallx(p.xz);\n\tbool wallz=iswallz(p.xz);\n\tp.xz = mod(p.xz,vec2(4.0));\n\tp.xz -= vec2(2.0);\n\tvec3 b=vec3(wallx?2.0:1.0,1.0,wallz?2.0:1.0);\n\t//float d=0.1;\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat flr(vec3 p)\n{\n\treturn p.y+1.0;\n}\n\nfloat dist(vec3 p)//distance function\n{\n\t//float t = iTime+4.0;\n\tfloat d = 1000.0;//p.y+2.0;\n\t\n\td = min(spheres(p),flr(p));\n\t\n\treturn d;\n}\n\nfloat amb_occ(vec3 p)\n{\n\tfloat acc=0.0;\n\t#define ambocce 0.2\n\n\tacc+=dist(p+vec3(-ambocce,-ambocce,-ambocce));\n\tacc+=dist(p+vec3(-ambocce,-ambocce,+ambocce));\n\tacc+=dist(p+vec3(-ambocce,+ambocce,-ambocce));\n\tacc+=dist(p+vec3(-ambocce,+ambocce,+ambocce));\n\tacc+=dist(p+vec3(+ambocce,-ambocce,-ambocce));\n\tacc+=dist(p+vec3(+ambocce,-ambocce,+ambocce));\n\tacc+=dist(p+vec3(+ambocce,+ambocce,-ambocce));\n\tacc+=dist(p+vec3(+ambocce,+ambocce,+ambocce));\n\treturn 0.5+acc /(16.0*ambocce);\n}\n\nfloat occ(vec3 start, vec3 light_pos, float size)\n{\n\tvec3 dir = light_pos-start;\n\tfloat total_dist = length(dir);\n\tdir = dir/total_dist;\n\t\n\tfloat travel = .1;\n\tfloat o = 1.0;\n\tvec3 p=start;\n\t\n\tfloat search_travel=.0;\n\tfloat search_o=1.0;\n\t\n\tfloat e = .5*total_dist/float(occlusion_pass1_quality);\n\t\n\t//pass 1 fixed step search\n\t\n\tfor (int i=0; i<occlusion_pass1_quality;i++)\n\t{\n\t\ttravel = (float(i)+0.5)*total_dist/float(occlusion_pass1_quality);\n\t\tfloat cd = dist(start+travel*dir);\n\t\tfloat co = cd/travel*total_dist*size;\n\t\tif (co<search_o)\n\t\t{\n\t\t\tsearch_o=co;\n\t\t\tsearch_travel=travel;\n\t\t\tif (co<.0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t//pass 2 tries to find a better match in close proximity to the result from the \n\t//previous pass\n\t\t\n\tfor (int i=0; i<occlusion_pass2_quality;i++)\n\t{\n\t\tfloat tr = search_travel+e;\n\t\tfloat oc = dist(start+tr*dir)/tr*total_dist*size;\n\t\tif (tr<.0||tr>total_dist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (oc<search_o)\n\t\t{\n\t\t\tsearch_o = oc;\n\t\t\tsearch_travel = tr;\n\t\t}\n\t\te=e*-.75;\n\t}\n\t\n\to=max(search_o,.0);\n\n\treturn o;\n}\n\nfloat occ(vec3 start, vec3 light_pos, float size, float dist_to_scan)\n{\n\tvec3 dir = light_pos-start;\n\tfloat total_dist = length(dir);\n\tdir = dir/total_dist;\n\t\n\tfloat travel = .1;\n\tfloat o = 1.0;\n\tvec3 p=start;\n\t\n\tfloat search_travel=.0;\n\tfloat search_o=1.0;\n\t\n\tfloat e = .5*dist_to_scan/float(occlusion_pass1_quality);\n\t\n\t//pass 1 fixed step search\n\t\n\tfor (int i=0; i<occlusion_pass1_quality;i++)\n\t{\n\t\ttravel = (float(i)+0.5)*dist_to_scan/float(occlusion_pass1_quality);\n\t\tfloat cd = dist(start+travel*dir);\n\t\tfloat co = cd/travel*total_dist*size;\n\t\tif (co<search_o)\n\t\t{\n\t\t\tsearch_o=co;\n\t\t\tsearch_travel=travel;\n\t\t\tif (co<.0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t//pass 2 tries to find a better match in close proximity to the result from the \n\t//previous pass\n\t\t\n\tfor (int i=0; i<occlusion_pass2_quality;i++)\n\t{\n\t\tfloat tr = search_travel+e;\n\t\tfloat oc = dist(start+tr*dir)/tr*total_dist*size;\n\t\tif (tr<.0||tr>total_dist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (oc<search_o)\n\t\t{\n\t\t\tsearch_o = oc;\n\t\t\tsearch_travel = tr;\n\t\t}\n\t\te=e*-.75;\n\t}\n\t\n\to=max(search_o,.0);\n\n\treturn o;\n}\n\nvec3 normal(vec3 p,float e) //returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nvec3 background(vec3 p,vec3 d)//render background\n{\n\td=rotate_z(d,-1.0);\n\tvec3 color = mix(vec3(.9,.6,.2),vec3(.1,.4,.8),d.y*.5+.5);\n\treturn color*(noise(d)+.1*pow(noise(d*4.0),4.0));\n\t//return texture(iChannel0,d).xyz*vec3(.2,.4,.6);\n}\n\nfloat noise(float p)\n{\n\tfloat pm = mod(p,1.0);\n\tfloat pd = p-pm;\n\treturn hashmix(pd,pd+1.0,pm);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\treturn hashmix(pd,(pd+vec2(1.0,1.0)), pm);\n}\n\nvec3 object_material(vec3 p, vec3 d) //computes the material for the object\n{\n\tvec3 n = normal(p,.02); //normal vector\n\tvec3 r = reflect(d,n); //reflect vector\n\tfloat ao = amb_occ(p); //fake ambient occlusion\n\tvec3 color = vec3(.0,.0,.0); //variable to hold the color\n\tfloat reflectance = 1.0+dot(d,n);\n\t//return vec3(reflectance);\n\t\n\tfloat or = occ(p,p+r*10.0,0.5,10.0);\n\t\n\tvec3 diffuse_acc = vec3(.0);\n\t\n\tfloat t = iTime*.1;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tvec3 offs = vec3(\n\t\t\t-sin(5.0*(1.0+fi)*123.4+t),\n\t\t\t-sin(4.0*(1.0+fi)*723.4+t),\n\t\t\t-sin(3.0*(1.0+fi)*413.4+t));\n\t\n\t\tvec3 lp = offs*4.0;\n\t\tvec3 ld = normalize(lp-p);\n\t\t\n\t\tfloat diffuse = dot(ld,n);\n\t\tfloat od=.0;\n\t\tif (diffuse>.0)\n\t\t{\n\t\t\tod = occ(p,lp,1.1);\n\t\t}\n\t\t\n\t\tfloat spec = pow(dot(r,ld)*.5+.5,100.0);\n\t\t\n\t\tvec3 icolor = vec3(1.0)*diffuse*od + vec3(spec)*od*reflectance;\n\t\tdiffuse_acc += icolor;\n\t}\n\n\tif(spheres(p)<flr(p))\n\t{\n\t\tvec3 tex = vec3(.0);\n\t\ttex += texture(iChannel1,p.yz*0.63+.33).xyz*abs(n.x);\n\t\ttex += texture(iChannel1,p.zx*0.63+.66).xyz*abs(n.y);\n\t\ttex += texture(iChannel1,p.xy*0.63+.99).xyz*abs(n.z);\n\t\ttex *= vec3(.5,.5,.7);\n\t\tcolor = tex*diffuse_acc+background(p,r)*(.1+or*reflectance)*1.8;\n\t}\n\telse\n\t{\n\t\tvec3 tex = texture(iChannel0,p.xz*.25).xyz;\n\t\tcolor = tex*diffuse_acc+background(p,r)*(.1+or*reflectance)*1.5;\n\t}\n\n\t\n\treturn color*min(ao*1.9,1.0)*.8;\n\t\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\tfloat t = iTime*.5*object_speed_modifier + 30.0;\n\tmouse += vec3(sin(t)*.25,sin(t)*.02,cos(t)*.20);\n\t\n\tfloat offs0=5.0;\n\tfloat offs1=1.0;\n\t\n\t//setup the camera\n\tvec3 p = vec3(.9,-0.9,-1.0);\n\tp = rotate_x(p,mouse.y*9.0+offs0);\n\tp = rotate_y(p,mouse.x*9.0+offs1);\n\tp *= (abs(p.y*2.0+1.0)+1.0);\n\tvec3 d = vec3(uv,1.0);\n\td.z -= length(d)*.6; //lens distort\n\td = normalize(d);\n\td = rotate_x(d,mouse.y*9.0+offs0);\n\td = rotate_y(d,mouse.x*9.0+offs1);\n\t\n\tvec3 sp = p;\n\tvec3 color;\n\tfloat dd,td;\n\t\n\t//raymarcing \n\tfor (int i=0; i<render_steps; i++)\n\t{\n\t\tdd = dist(p);\n\t\tp+=d*dd;\n\t\ttd+=dd;\n\t\tif (dd>5.0) break;\n\t}\n\t\n\tif (dd<0.1)\n\t{\n\t\tcolor = object_material(p,d);\n\t}\n\telse\n\t{\n\t\tcolor = background(p,d);\n\t}\n\t\n\tcolor = mix(background(p,d),color,1.0/(td*.1+1.0));\n\t\n\tcolor = mix(color*color,color,1.4);\n\tcolor *=.8;\n\tcolor -= length(uv)*.1;\n\tcolor = cc(color,.5,.5);\n\tcolor += hash(uv.xy+color.xy)*.02;\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dl3zs","date":"1377251093","viewed":415,"name":"Wolfeinstein3d","username":"Alberton","description":"Forked from mu6k https://www.shadertoy.com/view/lds3RX","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","shadow","lighting","cubes","spheres","occlusion"],"hasliked":0,"parentid":"","parentname":""}}