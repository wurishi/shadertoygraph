{"ver":"0.1","info":{"id":"3l3fWN","date":"1612841536","viewed":70,"name":"noise 2d breakdown (vlllll)","username":"valalalalala","description":"Noise is super neat and useful and I've been carrying it around for a while and finally decided to break it out into pieces and document it a bit. \n\nThe scale is shown in the bottom right and is controlled with the mouse (y). Different hashing is neat too","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"noise 2d breakdown\"                                      // //\n     //                                                            //  //\n    //  Noise is super neat and useful and I've been carrying it  //   //\n   //  around for a while and finally decided to break it down   //    //   \n  //  into pieces and document it a bit                         //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     // \n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// iq's Noise - gradient - 2D\n// https://www.shadertoy.com/view/XdXGW8\n//\n// markjarzynski's Hash Functions for GPU Rendering\n// https://www.shadertoy.com/view/XlGcRh\n//\n// My little debugging font\n// https://www.shadertoy.com/view/WtGyWD\n////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////\n// macro-a-ronie\n\n#define UNIT(txt) ( txt * 2.  - iResolution.xy ) / iResolution.y\n#define F21(h)    ( fract( (h).x + (h).y ) )\n#define FBM_NOT\n\n////////////////////////////////////////////////////////////////\n// corners of the square\n\nconst vec2 corner_00 = vec2( 0, 0 );\nconst vec2 corner_10 = vec2( 1, 0 );\nconst vec2 corner_01 = vec2( 0, 1 );\nconst vec2 corner_11 = vec2( 1, 1 );\n\n////////////////////////////////////////////////////////////////\n// pick ur poison...\n\nvec2 hash( vec2 uv ) {\n    //return hash_iq( uv );\n    //return hashwithoutsine22(uv);\n    //return clamp( hash_pcg4d( uv ), -1., 1. );\n    //return hash_m1( uv );\n    //return hash_m2( uv );\n    return hash_sin(uv);\n}\n\n////////////////////////////////////////////////////////////////\n// IQ's https://www.shadertoy.com/view/XdXGW8, gradient - 2D \n\nfloat noise_iq( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n////////////////////////////////////////////////////////////////\n// same as IQ's 2D gradient noise, but peeled apart\n\nfloat noise_breakdown( vec2 uv ) {\n    vec2 i = floor( uv );\n    vec2 f = fract( uv );\n\n    /*\n        hash_00         hash_10\n               +-------+\n               |       |\n               | f     |\n               |       |\n               +-------+\n        hash_01         hash_11\n    */\n\n    // hash values at each corner\n    \n    vec2 hash_00 = hash( i + corner_00 );\n    vec2 hash_10 = hash( i + corner_10 );\n    vec2 hash_01 = hash( i + corner_01 );\n    vec2 hash_11 = hash( i + corner_11 );\n        \n    // offset from corners\n    \n    vec2 offset_00 = f - corner_00;\n    vec2 offset_10 = f - corner_10;\n    vec2 offset_01 = f - corner_01;\n    vec2 offset_11 = f - corner_11;\n        \n    // scalar projection \n    \n    float h_00 = dot( hash_00, offset_00 );\n    float h_10 = dot( hash_10, offset_10 );\n    float h_01 = dot( hash_01, offset_01 );\n    float h_11 = dot( hash_11, offset_11 );\n        \n    //////////////////////////////////////////////\n    // interpolate the values\n    \n    // the Hermite interpolation\n\n    vec2 s = smoothstep( .0, 1., f );\n    \n    // horizontally \n    \n    float h_y0 = mix( h_00, h_10, s.x );\n    float h_y1 = mix( h_01, h_11, s.x );\n    \n    // vertically\n\n    return mix( h_y0, h_y1, s.y );\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat noise( in vec2 p ) {\n    return noise_iq( p );\n}\n\nvec4 fbm( vec2 uv, vec3 scales, vec3 weights ) {\n    vec4 v = vec4(\n        noise( uv * scales.x ), \n        noise( uv * scales.y ), \n        noise( uv * scales.z ),\n        .0\n    );\n    v.w = dot( v.xyz, weights );\n    return v;\n}\n\nfloat fbm( vec2 uv ) {\n    return fbm( uv, vec3( 2., 3., 5. ), vec3( .6, .3, .1 ) ).w;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = UNIT( fragCoord );\n    vec2 ms = iMouse.z > .0 ? UNIT( iMouse.xy ) : vec2( .0 );\n    \n    vec2 og = uv;\n    uv.x += iTime * .1;\n\n    //////////////////////////////////////////////\n    \n    float scale = 4.4 + 22.22 * ( .5 + ms.y );\n    vec2 st = uv * scale;\n    \n    //////////////////////////////////////////////\n    // get the values\n    \n    float h = F21( hash( st )  ) * .5 + .5;\n    \n    #ifndef FBM\n    float n = noise_breakdown( st );\n    #else\n    float n = fbm( st );\n    #endif\n    \n    //////////////////////////////////////////////\n    // convert to grayscale\n    \n    // show hash on left, noise on right\n    \n    float right = step( .0, og.x - ms.x );\n    float v = mix( h, n, right );\n    \n    //////////////////////////////////////////////\n    // march a test sphere\n    \n    float q = 1. + v *.1;\n    \n    vec3 eye = vec3( .0, .0, 2. );    \n    vec3 direction = normalize( vec3( og, -1. ) );\n    float d = march( eye, direction, q );\n        \n    if ( d < MARCH.z ) {\n        vec3 p = eye + direction * d;\n        vec3 n = mapNormal( p, d, q );\n        v = abs( n.x + n.y + n.z ) / 3.;\n        v = pow( v, .5 );\n    }\n    \n    // dividing line for no real reason\n        \n    v *= step( .007, abs( og.x - ms.x ) );\n    \n    //////////////////////////////////////////////\n    // show the scale....\n\n    vec3 color = vec3( v );\n    color = digitIn( color,  og - vec2(1.1,-.9),  44., scale );\n    \n    //////////////////////////////////////////////\n    // le fin\n\n    fragColor = vec4( color, 1. ); \n}\n\n// EOF\n////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////\n// a few different hash functions\n\nvec2 hash_sin(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nvec2 hash_iq( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n//https://www.shadertoy.com/view/XlGcRh\nvec2 hashwithoutsine22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nuvec4 pcg4d(uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec2 hash_pcg4d( vec2 s ) {\n    float q = 1000.;\n    s = ( s + .5 ) * q;\n       \n    uvec4 u = uvec4(s, uint(s.x) ^ uint(s.y), uint(s.x) + uint(s.y)); // Play with different values for 3rd and 4th params. Some hashes are okay with constants, most aren't.\n    uvec4 p = pcg4d(u);\n    s = vec2( float( p.x ) / q, float( p.y ) / q );\n    return s * 2. - 1.;\n}\n\n// just a playing around some ...\nvec2 hash_m1( vec2 uv ) {    \n    vec3 q = fract( uv.xyx * vec3( 13.7, 11.5, 17.3 )); \n    q += dot( q.zxy, vec3( 15.3, 13.7, 21.2 ) );\n    return fract( vec2( q.x * q.z, q.y * q.z ) ) * 2. - 1.;\n}\n\nvec2 hash_m2( vec2 uv ) {    \n    vec3 q = fract( uv.xyx * vec3( 13.7, 11.5, 17.3 )); \n    q *= dot( q.zxy, vec3( 15.3, 13.7, 21.2 ) );\n    return fract( vec2( q.x * q.z, q.y * q.z ) ) * 2. - 1.;\n}\n\n////////////////////////////////////////////////////////////////\n// little marching code....\n\nconst vec3 MARCH = vec3( .0, .01, 88. );\n\n#define NX1 map( p - MARCH.yxx * d, q )\n#define NX2 map( p - MARCH.xyx * d, q )\n#define NX3 map( p - MARCH.xxy * d, q )\n\nfloat map( vec3 p, float q ) {\n    return length( p ) - q; // noisy ball\n}\n\nfloat march( vec3 eye, vec3 direction, float q ) {\n    float total = .0, now;\n    vec3 current = eye;\n    for( int i = 0 ; i < int( MARCH.z ) ; i++ ) {\n        total += ( now = map( current, q ) );\n        if ( abs( now ) < MARCH.y || total > MARCH.z ) break;\n        current += now * direction;\n    }\n    return total + MARCH.z * step( MARCH.z, total );\n}\n\nvec3 mapNormal( vec3 p, float d, float q ) {\n    return normalize( map( p,q ) - vec3( NX1, NX2, NX3 ) );\n}\n\n\n// from my https://www.shadertoy.com/view/WtGyWD\n\nconst int CHARACTERS[14] = int[14](31599,9362,31183,31207,23524,29671,29679,30994,31727,31719,1488,448,2,3640);\n\nfloat digitIsOn( int digit, vec2 id ) {   \n    if ( id.x < .0 || id.y < .0 || id.x > 2. || id.y > 4. ) return .0;\n    return floor( mod( float( CHARACTERS[ int( digit ) ] ) / pow( 2., id.x + id.y * 3. ), 2. ) );\n}\n\nfloat digitSign( float v, vec2 id ) {\n    return digitIsOn( 10 - int( ( sign( v ) - 1. ) * .5 ), id );\n}\n\nint digitCount( float v ) {\n    return int( floor( log( max( v, 1. ) ) / log( 10. ) ) );\n}\n\nfloat digitFirst( vec2 uv, float scale, float v, int decimalPlaces ) {\n    vec2 id = floor( uv * scale );\n\n    if ( .0 < digitSign( v, id ) ) return 1.;\n    v = abs( v );\n    \n    int digits = digitCount( v );\n    float power = pow( 10., float( digits ) );\n    \n    float offset = floor( .1 * scale );\n    id.x -= offset;\n    \n    float n;\n    for ( int i = 0 ; i < 33 ; i++, id.x -= offset, v -= power * n, power /= 10. ) {\n        n = floor( v / power );\n        if ( .0 < digitIsOn( int( n ), id ) ) return 1.;   \n        if ( i == digits ) {\n            id.x -= offset;\n            if ( .0 < digitIsOn( int( 12 ), id ) ) return 1.;\n        }  \n        if ( i >= digits + decimalPlaces ) return .0;    \n    }  \n    return .0;\n}\n\nfloat digitFirst( vec2 uv, float scale, float v ) {\n    return digitFirst( uv, scale, v, 3 );\n}\n\nvec3 digitIn( vec3 color, vec3 fontColor, vec2 uv, float scale, float v ) {\n    float f = digitFirst( uv, scale, v );\n    return mix( color, fontColor, f );\n}\n\nvec3 digitIn( vec3 color, vec2 uv, float scale, float v ) {\n    return digitIn( color, vec3(1.), uv, scale, v );\n}\n","name":"Common","description":"","type":"common"}]}