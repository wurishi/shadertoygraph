{"ver":"0.1","info":{"id":"XfXGWs","date":"1703711986","viewed":34,"name":"FDM 1D wave in X with reset","username":"zeroDarkThirty","description":"• press [r] to reset or start\n• bounds are not correct!","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["fdm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 H = texelFetch( iChannel0, ivec2( fragCoord ), 0 );\n    \n    // tanH helps keep it bounded, setting a value -1<>1 to a color pallete to make it look nice!\n    \n    vec3 col = pal( tanh(H.y), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    fragColor.xyz = col;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Use this site to find JS event key code\n   https://www.toptal.com/developers/keycode\n   I arbitrarily used [r]\n*/\n\nconst int KEY_RESET  = 82;\n#define KEY(N) texelFetch( iChannel1, ivec2( N, 0 ), 0 ).x\n\n\n/* goal is to approximate U𝑡𝑡 = αU𝑥𝑥 using FDM\n   α == c² * dt² / dx², here α is, arbitrarily, set to .1\n   \n   update logic (not at bounds):\n   -----------------------------\n   \n       uNext = α( uLeft - 2*uCenter + uRight ) + 2*uCenter - uCenterPrev\n       \n       \n   shader explanation:\n   ------------------- \n   \n       • iChannel0 is stored in Buffer A, everytime it is called, it accesses the current rgba pixel value\n       using this and texelFetch we can access neighboring pixels!\n       \n       • uCenterPrev is tricky, fragColor is a 4D vector. We can store the current\n       uCenter value in fragColor.y. This vector is saved in buffer A. When the next frame comes,\n       accessing fragColor.y will contain the prevoius uCenter.\n   \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float alpha = 0.1; // Arbitrary! but should be lower than 0.5\n    vec2 coordXY = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n    \n    float uC = coordXY.x; // u Centered \n    float uP = coordXY.y; // u Previous \n    \n    float uL = texelFetch(iChannel0, ivec2(fragCoord + vec2(-1., 0.)), 0).x; // u Left\n    float uR = texelFetch(iChannel0, ivec2(fragCoord + vec2(1., 0.)), 0).x; // u Right\n    \n    float u = alpha * (uL + uR - 2.*uC) + 2.*uC - uP;\n        \n    fragColor = vec4(u,uC,0.0,0.0);\n    \n    //fragColor.y = uC;\n    \n    if ( KEY(KEY_RESET) > 0.5 || iFrame < 11  ) \n    {\n    \n        // reset, set middle of frame to be a vertical gaussian displacement.\n        \n        \n        fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        float d = exp(-pow((fragCoord.x-iResolution.x/2.)/10.,2.));\n        fragColor = vec4(d,d,d,d);\n    };    \n\n}","name":"Buffer A","description":"","type":"buffer"}]}