{"ver":"0.1","info":{"id":"XfsGD8","date":"1703010576","viewed":41,"name":"other cosmic and coloful","username":"nayk","description":"space,cosmos.stars,colorful,space","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["colorful","space","space","cosmosstars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*originals https://www.shadertoy.com/view/7dVGDd https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/DtGyWh  */\n\n\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; // the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.2-dm; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\n\nvec3 color(float t) {\n  vec3 c1 = vec3(1.0, 0.0, 0.0);\n  vec3 c2 = vec3(0.0, 1.0, 0.0);\n  vec3 c3 = vec3(0.0, 0.0, 1.0);\n  vec3 c4 = vec3(1.0, 1.0, 0.0);\n  vec3 c5 = vec3(1.0, 0.0, 1.0);\n  vec3 c6 = vec3(0.0, 1.0, 1.0);\n\n  float r = cos(t) * 0.5 + 0.5;\n  if (r < 0.23) return mix(c1, c2, r * 5.0);\n  if (r < 0.44) return mix(c2, c3, (r - 0.2) * 5.0);\n  if (r < 0.65) return mix(c3, c4, (r - 0.4) * 5.0);\n  if (r < 0.86) return mix(c4, c5, (r - 0.6) * 5.0);\n  return mix(c5, c6, (r - 0.8) * 7.0);\n}\n#define R2(p,a,r) mix(a*dot(p,a),p,cos(r)) + abs(sin(r)*cross(p,a))\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,1.);\nfloat time=iTime*speed+.25;\n\nvec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n   \n    // distance of current pixel from center\nfloat cLength = length(cPos);\n\n dir.xy+= (cPos/cLength)*cos(cLength*10.0-iTime*1.0) * 0.03;\n\n    vec4 O=fragColor;\n    vec2 C=fragCoord;\n O=vec4(0);\n   \n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n   \n      vec2 st = vec2 (atan(uv.x, uv.y), length (uv)) ;\n    uv = vec2 (st.x / 1.2831+.5- (-iTime + st.y), st.y);\n    float c = 0.0;\n   \n   \n   \n\n   \n   \n \n\n   \n \n   \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        p=g*d;\n       \n        p.z+=-iTime*2.3;\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=5.;\n       \n         \n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n           \n            p.x<p.z?p=p.zyx:p;\n  p.z<p.y?p=p.zxy:abs(fract(p));\n           \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(1.*sin((iTime*1.2)), 50.+cos((iTime*0.1))*5., 2.+cos(0.5*(iTime)) )+dir;\n         }\n        g+=e=length(p.yz)/s;\n       \n    }\n \n\nvec3 from=vec3(1.,.5,0.5)+O.xyz;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\n    fragColor+=O;\n   \n}\n\n","name":"Image","description":"","type":"image"}]}