{"ver":"0.1","info":{"id":"NdsyzM","date":"1642999694","viewed":354,"name":"Super Mario 64","username":"LucasR","description":"Inspired by https://twitter.com/SpaceLiminalBot/status/1479452745379815424","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","mario"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is my first \"real\" ray marching scene\n// the idea was to recreate an image I saw on Twitter\n// from a Super Mario 64 level\n// and experiment with texturing procedural surfaces\n// I learned how to use buffers, do texturing,\n// how to pixelate a procedural texture, bump mapping\n// and made a simple vignetting function\n\n// TO WORK ON:\n// Optimize and make the code cleaner because right now it's a mess\n\nconst int MAX_MARCHING_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 22.;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005; // used in calcNormal()\nconst float MIN_SHADOW = .4;\nconst float PI = 3.1415926;\n\nvec3 rotX(vec3 p, float theta){ // Rotation matrix around the X axis\n    float c = cos(theta);\n    float s = sin(theta);\n    p.yz = mat2(c,-s,s,c)*p.yz;\n    return p;\n}\n\nvec3 rotY(vec3 p, float theta){ // Rotation matrix around the Y axis\n    float c = cos(theta);\n    float s = sin(theta);\n    p.xz = mat2(c,-s,s,c)*p.xz;\n    return p;\n}\n\nvec3 rotZ(vec3 p, float theta){ // Rotation matrix around the Z axis\n    float c = cos(theta);\n    float s = sin(theta);\n    p.xy = mat2(c,-s,s,c)*p.xy;\n    return p;\n}\n\nmat2 rot(float theta){ // 2D rotation matrix\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash(vec2 p){\n// source: https://www.shadertoy.com/view/lsf3WH\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise(in vec2 p){ // same source as hash()\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nstruct Material{\n    float k_a; // ambient\n    float k_d; // diffuse\n    float k_s; // specular\n    float alpha; // shininess -- related to roughness\n};\n\nstruct Surface{\n    float sd; // signed distance\n    vec3 col; // colour\n    Material mat; // Phong shading constants\n};\n\nfloat sdSphere(vec3 p, float r, vec3 offset){\n    return length(p - offset) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h){\n// source: https://iquilezles.org/articles/distfunctions\n  // n must be normalized\n  return dot(p, n) + h;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); } // by Iñigo Quilez\n\nfloat opExtrussion(in vec3 p, in float sdf, in float h){\n// source: https://www.shadertoy.com/view/4lyfzw\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdSquareStairs(in vec2 p, in float s, in float n){\n// source: https://www.shadertoy.com/view/ftVSDd\n    // constant for a given shape\n    const float kS2 = sqrt(2.0);\n    float w = 2.0*n+1.0;\n    \n    // pixel dependent computations\n    p = vec2( abs(p.y+p.x), p.y-p.x ) * (0.5/s);\n\n    float x1 = p.x-w;\n    float x2 = abs(p.x-2.0*min(round(p.x/2.0),n))-1.0;\n    \n    float d1 = dot2( vec2(x1, p.y) + clamp(0.5*(-x1-p.y), 0.0, w  ) );\n    float d2 = dot2( vec2(x2,-p.y) + clamp(0.5*(-x2+p.y), 0.0, 1.0) );\n\n    return sqrt(min(d1,d2)) *\n           sign(max(x1-p.y,(x2+p.y)*kS2)) *\n           s*kS2;\n}\n\nfloat sdBox(vec3 p, vec3 b, vec3 offset){\n    p = p - offset;\n    vec3 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    return d;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n// source: https://iquilezles.org/articles/distfunctions\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\nvec3 opRepLim(in vec3 p, in float c, in vec3 l){\n// source (modified): https://iquilezles.org/articles/distfunctions\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nSurface minWithCol(Surface s1, Surface s2){\n    if(s2.sd < s1.sd) return s2;\n    return s1;\n}\n\nfloat blink(float t){ // thanks to Iñigo Quilez for this function. Taken from his \"Selfie girl\" video\n    float alpha = min(1., mod(t, 3.1));\n    return smoothstep(0., 0.1, alpha) - smoothstep(0.18, 0.4, alpha);\n}\n\nfloat sdMario(vec3 p, vec3 offset, float scale){\n    float head = sdSphere(vec3(p.x, p.y/1.2, p.z), 3.*scale, offset);\n    float nose = sdSphere(p, .6*scale, offset+vec3(0.2, -.3, 3.));\n    float Mario = head;\n    Mario = min(Mario, nose);\n    return Mario;\n}\n\nSurface sdScene(vec3 p){\n    Material boxMat   = Material(.05, .2, .2 , 5. );\n    Material ceilMat  = Material(.05, .2, .0 , 10.);\n    Material floorMat = Material(.05, .2, .0 , 1. );\n    Material wallMat  = Material(.05, .2, .02, 5. );\n    Material railMat  = Material(.05, .2, .1 , 1. );\n    Material doorMat  = Material(.05, .2, .15, 2. );\n    Material MarioMat = Material(.05, .2, .00, 2. );\n    \n    float txScale = 1.36; // texture scale\n    vec2 uvPlane = (p.zy/5. + vec2(.6, .6)) / txScale;\n    uvPlane = vec2(uvPlane.x/(iResolution.x/iResolution.y), uvPlane.y);\n    \n    float pixelScale = 7.; // pixel factor for floor and stairs texture\n    vec3 floorCol  = vec3(1., 0., 0.) * clamp(noise(7.*floor(p.xz*pixelScale)/pixelScale), .2, .8);\n    vec3 stairsCol = vec3(1., 0., 0.) * clamp(noise(7.*floor(p.xy*pixelScale)/pixelScale), .2, .8);\n    vec4 temp = texture(iChannel0, uvPlane); // assign texture to temp variable to do only one texture fetch\n    vec3 wallCol = temp.rgb;\n    float wallDisp = temp.a; // displacement map stored in alpha channel\n    vec3 ceilCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.));\n    vec3 railCol = vec3(0.8);\n    vec3 railTCol = vec3(.3, .15, 0.);\n    vec3 doorCol = vec3(.2, .1, 0.);\n    \n    Surface sideWalls = Surface(sdPlane( vec3(abs(p.x), p.y, p.z) , vec3(-1., 0., 0.), 6.), wallCol, wallMat);\n    \n    sideWalls.sd -= wallDisp; // displace wall with brick texture\n    Surface theFloor = Surface(sdPlane(p, vec3(0., 1., 0.), 3.), floorCol, floorMat);\n    Surface theCeil = Surface(sdPlane(p, vec3(0., -1., 0.), 3.8), ceilCol, ceilMat);\n    \n    uvPlane = (p.xy/5. + vec2(1.22, .6)) / txScale; // redefine plane UVs to work with back wall\n    uvPlane = vec2(uvPlane.x/(iResolution.x/iResolution.y), uvPlane.y); // adjust aspect ratio\n    temp = texture(iChannel0, uvPlane);\n    wallCol = temp.rgb;\n    vec3 boxCol = wallCol;\n    wallDisp = temp.a;\n    Surface backWall = Surface(sdPlane(p, vec3(0., 0., 1.), 15.), wallCol, wallMat);\n    backWall.sd = abs(backWall.sd)-.01 - wallDisp;\n    // abs makes it have finite thickness, so later I can cut it and it has a proper hole that goes through\n    Surface box = Surface(sdBox(p, vec3(5.3, 1.8, 1.), vec3(-2., -1.3, -13.)), boxCol, boxMat);\n    box.sd -= wallDisp;\n    vec3 railPos = vec3(1.5, -.5, 12.1);\n    float railR = 0.096*step(p.y, .75) + 0.084 * p.y * ( step(p.y, 2.75)-step(p.y, .75) ); // rail radius\n    vec3 pRail = opRepLim(p+railPos, .6, vec3(8., 0., 0.));\n    Surface rail = Surface(sdCapsule(pRail, vec3(0.), vec3(0., .65, 0.), railR), railCol, railMat);\n    Surface railTop = Surface(sdCapsule(p, vec3(-6., 1.3, -12.1), vec3(3.5,1.3,-12.1), .1), railTCol, railMat);\n    \n    vec3 pStairs = p + vec3(-4.6, 1.2, 12.5); // move stairs\n    pStairs = rotY(pStairs, -PI/2.); // rotate stairs\n    Surface stairs = Surface(opExtrussion(pStairs,\n    sdSquareStairs( pStairs.xy , .2, 4.), 1.2), stairsCol, floorMat);\n    \n    Surface doorCut = Surface(sdBox(p, vec3(.6, 1.5, .15), vec3(-1.5, 1.75, -15.)), doorCol, doorMat);\n    Surface doorFrame = Surface(sdBox(p, vec3(.7, 1.6, .12), vec3(-1.5, 1.75, -15.)), doorCol*.1, doorMat);\n    doorFrame.sd = max(doorFrame.sd, -doorCut.sd); // cut hole in frame\n    backWall.sd = max(backWall.sd, -doorCut.sd); // cut hole in wall\n    \n    // make door and rotate it\n    vec3 hinge = vec3(0.5, 0., 0.) - vec3(-1.5, 1.75, -15.); // use door position and hinge offset\n    vec3 pDoor = p + hinge;\n    float t = .8*blink(iTime/2.-.5);\n    pDoor = rotY(pDoor, t) - hinge;\n    Surface door = Surface(sdBox(pDoor, vec3(.6, 1.5, .1), vec3(-1.5, 1.75, -15.)), doorCol, doorMat);\n    \n    float MarioScale = .3;\n    p = rotZ(p, -PI/20.);\n    p -= vec3(-1.5, 1.5, -6.5);\n    p /= MarioScale;\n    vec2 MarioUVs = (p.xy + vec2(2.2, 0.))/4.5 * step(p.z, -30.); // change offset accordingly\n    p *= MarioScale;\n    temp = texture(iChannel1, MarioUVs);\n    vec3 MarioCol = temp.rgb;\n    vec3 hatCol = vec3(1., temp.a, temp.a);\n    Surface Mario = Surface(sdMario(p, vec3(0., 0.7, -12.), MarioScale), MarioCol, MarioMat);\n    Surface MarioHat = Surface(sdSphere(vec3(p.x, p.y*5., p.z), .5, vec3(0., 7., -11.)),\n    vec3(1., 0., 0.), MarioMat);\n    \n    Surface co;\n    co = theFloor;\n    co = minWithCol(co, Mario);\n    co = minWithCol(co, MarioHat);\n    co = minWithCol(co, door);\n    co = minWithCol(co, doorFrame);\n    co = minWithCol(co, rail);\n    co = minWithCol(co, railTop);\n    co = minWithCol(co, stairs);\n    co = minWithCol(co, box);\n    co = minWithCol(co, sideWalls);\n    co = minWithCol(co, theCeil);\n    co = minWithCol(co, backWall);\n    return co;\n}\n\nvec3 calcNormal(vec3 p){\n  vec2 e = vec2(1.0, -1.0) * EPSILON;\n  return normalize(\n    e.xyy * sdScene(p + e.xyy).sd +\n    e.yyx * sdScene(p + e.yyx).sd +\n    e.yxy * sdScene(p + e.yxy).sd +\n    e.xxx * sdScene(p + e.xxx).sd);\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end){\n    float depth = start;\n    Surface co; // closest object\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++){\n        vec3 p = ro + depth*rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if(co.sd < PRECISION || depth > end) break;\n    }\n    co.sd = depth;\n    return co;\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Surface co){\n    // ambient light is calculated outside this function\n    // diffuse\n    float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n    //vec3 diffuse = co.mat.k_d * dotLN * co.col / (co.sd * co.sd); // added falloff\n    vec3 diffuse = co.mat.k_d * dotLN * co.col; // without falloff\n    \n    // specular\n    float dotRV = clamp(dot(reflect(lightDir, normal), rd), 0., 1.);\n    vec3 i_s = vec3(1.); // reflection colour\n    //vec3 specular = co.mat.k_s * pow(dotRV, co.mat.alpha) * i_s / (co.sd* co.sd); // added falloff\n    vec3 specular = co.mat.k_s * pow(dotRV, co.mat.alpha) * i_s; // without falloff\n    \n    return diffuse + specular;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt){\n// source: https://www.shadertoy.com/view/ltyXD3\n    float res = 1.0;\n    float t = mint;\n    \n    for(int i = 0; i < 16; i++) {\n        float h = sdScene(ro + rd * t).sd;\n        res = min(res, 8.0*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > maxt) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat vignette(vec2 fragCoord, float size, float blur){\n    blur *= iResolution.x; // makes it work with full screen and small viewport\n    vec2 uv = fragCoord - .5 * iResolution.xy;\n    uv.y *= iResolution.x/iResolution.y;\n    float vg = length(uv) - size;\n    return smoothstep(blur, 0., vg);\n}\n\n/*void mainImage(out vec4 fragColor, in vec2 fragCoord){ // for previewing the texture\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 uvTex = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uvTex).rgb;\n    //vec3 col = vec3(texture(iChannel0, uvTex).a);\n    fragColor = vec4(col, 1.);\n}*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0., 0., 3.); // ray origin -- camera position\n    vec3 rd = normalize(vec3(uv, -1.)); // ray direction\n    \n    //vec2 mouse = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    //rd = rotY(rotX(rd, mouse.y), mouse.x); // rotate the camera with the mouse\n    \n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n    \n    vec3 bgCol = vec3(.835, 1., 1.); // i_a in Phong shading\n    \n    vec3 col = vec3(0.);\n    \n    if(co.sd >= MAX_DIST){\n        col = bgCol;\n    }\n    else{\n        vec3 p = ro + rd*co.sd; // point on surface\n        vec3 normal = calcNormal(p);\n        \n        vec3 lightPos = vec3(3., 3., -5.);\n        vec3 lightDir = normalize(lightPos - p);\n        float lightStr = 5.; // light strength\n        \n        // ambient\n        vec3 i_a = bgCol;\n        vec3 ambient = co.mat.k_a * i_a;\n        \n        vec3 colLight = phong(lightDir, normal, rd, co);\n        \n        // soft shadows\n        float shadowMask = clamp(softShadow(p, lightDir, 0.02, 2.5), MIN_SHADOW, 1.0);\n        col = ambient;\n        col += colLight * lightStr * shadowMask;\n    }\n    col *= vignette(fragCoord, 1., .75);\n    col = pow(col, vec3(.4545)); // gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer generates the texture for the walls and their displacement map\n\nfloat circle(vec2 uv, vec2 pos, float r, float blur){\n    float d = length(uv-pos);\n    return smoothstep(r, r-blur, d);\n}\n\nfloat square(vec2 uv, vec2 pos, vec2 size, float blur){\n    float d = max(abs(uv.x-pos.x) - size.x, abs(uv.y-pos.y) - size.y);\n    return smoothstep(size.x, size.x-blur, d);\n}\n\nfloat cloud(vec2 uv, vec2 pos, float size){\n    uv = (uv - pos)/size + vec2(.35, 0.);\n    float blur = 0.08;\n    float mask = circle(uv, vec2(0.),   .2, blur); // leftmost\n    mask += circle(uv, vec2(.2 ,  .15), .2, blur); // above and to the right of previous\n    mask += circle(uv, vec2(.15, -.15), .2, blur); // below prev\n    mask += circle(uv, vec2(.7 , 0. ),  .2, blur); // rightmost\n    mask += circle(uv, vec2(.5 ,  .2),  .2, blur); // upper right\n    mask += circle(uv, vec2(.45, -.1),  .2, blur); // lower right\n    mask += circle(uv, vec2(.3 , 0. ),  .2, blur); // fill middle\n    mask = clamp(mask, 0., 1.);\n    \n    uv /= vec2(1., 1.5);\n    mask -= circle(uv, vec2(.25, 0.), .08, blur/1.5); // left eye\n    mask -= circle(uv, vec2(.45, 0.), .08, blur/1.5); // right eye\n    \n    return clamp(mask, 0., 1.);\n}\n\nfloat smin(float a, float b, float k){ // smooth min\n// source: https://inspirnathan.com/posts/51-shadertoy-tutorial-part-5\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k){ // smooth max - same source as smin()\n    return -smin(-a, -b, k);\n}\n\nfloat bush(vec2 uv, vec2 pos, float size){\n    uv = (uv - pos)/size + vec2(.35, 0.);\n    float blur = 0.08;\n    float mask = square(uv, vec2(0., -4.)*size, vec2(size, size*3.), blur);\n    mask = max(circle(uv, vec2(0.), size*2., blur), mask);\n    \n    return clamp(mask, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float pixelScale = 50.; // pixelation amount\n    uv = floor(uv*pixelScale)/pixelScale; // pixelate texture\n    \n    float disp = 0.; // displacement map\n    \n    vec3 col = mix(vec3(105., 164., 202.)/255., vec3(20., 26., 85.)/255., uv.y*2.); // sky\n    \n    // bushes, left to right\n    vec3 lightBushCol = vec3(37., 113., 46.)/255.;\n    vec3 darkBushCol = vec3(28., 66., 25.)/255.;\n    \n    float lightBushMask =              bush(uv, vec2(-.7,  -.2),  .26);\n    lightBushMask = max(lightBushMask, bush(uv, vec2(-.5,  -.4),  .25));\n    lightBushMask = max(lightBushMask, bush(uv, vec2(-.26, -.25), .27));\n    lightBushMask = max(lightBushMask, bush(uv, vec2(-.06, -.45), .24));\n    lightBushMask = max(lightBushMask, bush(uv, vec2(.18,  -.1),  .28));\n    lightBushMask = max(lightBushMask, bush(uv, vec2(.43,  -.28), .27));\n    lightBushMask = max(lightBushMask, bush(uv, vec2(.58,  -.2),  .2 ));\n    lightBushMask = max(lightBushMask, bush(uv, vec2(.78,  -.13), .26));\n    lightBushMask = max(lightBushMask, bush(uv, vec2(.95,  -.35), .23));\n    \n    float darkBushMask =             bush(uv, vec2(-.75, -.6),  .35);\n    darkBushMask = max(darkBushMask, bush(uv, vec2(-.35, -.65), .35));\n    darkBushMask = max(darkBushMask, bush(uv, vec2( .0,  -.7),  .37));\n    darkBushMask = max(darkBushMask, bush(uv, vec2( .4,  -.6),  .37));\n    darkBushMask = max(darkBushMask, bush(uv, vec2( .82, -.55), .35));\n    \n    // clouds\n    uv = vec2(mod(uv.x - iTime*.1 + 1., 2.) - 1., uv.y); // move only clouds\n    float cloudMask = cloud(uv, vec2(-.6, .05), .4); // left cloud\n    cloudMask += cloud(uv, vec2(0., .25), .4); // middle cloud\n    cloudMask += cloud(uv, vec2(.5, .15), .4); // right cloud\n    \n    col += cloudMask;\n    \n    col = lightBushMask * lightBushCol + (1.-lightBushMask) * col;\n    col = darkBushMask * darkBushCol + (1.-darkBushMask) * col;\n    \n    // bricks displacement map in alpha channel\n    uv = (fragCoord - .5 * iResolution.xy) / iResolution.y; // reset UVs so they don't move\n    uv = vec2(uv.x, uv.y)/3.5 + vec2(0., .15);\n    float bS = .02; // brick size\n    float bB = .05; // brick blur\n    uv = vec2(uv.x, mod(uv.y, 6.*bS) - 1.5*bS);\n    disp  = square(vec2(mod(uv.x, 4.*bS), uv.y), vec2(2.*bS, 0.), vec2(bS, bS/2.5), bB);\n    disp += square(vec2(mod(uv.x-2.*bS, 4.*bS), uv.y-3.*bS), vec2(2.*bS, 0.), vec2(bS, bS/2.5), bB);\n    \n    disp = sqrt(clamp(disp, .0, .1))/3.; // added sqrt to shape the falloff\n    fragColor = vec4(col, disp);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer generates the texture for Mario's head\n\nfloat circle(vec2 uv, vec2 pos, float r, float blur){\n    float d = length(uv-pos);\n    return smoothstep(r, r-blur, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv.x *= iResolution.y/iResolution.x; // adjust for aspect ratio\n    \n    uv.x = abs(uv.x);\n    float pixelScale = 25.; // pixelation amount\n    uv = floor(uv*pixelScale)/pixelScale; // pixelate texture\n    \n    vec3 col = vec3(1., .81, .76); // skin colour\n    float blur = .08;\n    vec2 eyesUVs = vec2(uv.x, uv.y/1.5);\n    \n    float scleras = circle(eyesUVs, vec2(.16, .1), .15, blur);\n    col += scleras;\n    \n    float irises = circle(eyesUVs, vec2(.11, .08), .13, blur);\n    col = mix(col, vec3(.1, .1, 1.), irises);\n    \n    float pupils = circle(eyesUVs, vec2(.09, .08), .075, blur/2.);\n    col = mix(col, vec3(0.), pupils);\n    \n    col += circle(uv, vec2(.075, .1), .04, blur); // highlights\n    \n    blur /= 1.3;\n    \n    float moustache = circle(uv, vec2(.02, -.15), .1, blur);\n    moustache = clamp(moustache + circle(uv, vec2(.12, -.2), .1, blur), 0., 1.);\n    moustache = clamp(moustache + circle(uv, vec2(.24, -.17), .1, blur), 0., 1.);\n    moustache = clamp(moustache + circle(uv, vec2(.34, -.1), .1, blur), 0., 1.);\n    moustache = clamp(moustache - circle(uv, vec2(0., .315), .52, blur), 0., 1.);\n    \n    float eyebrows = circle(uv, vec2(.15, .25), .15, blur);\n    eyebrows -= circle(uv, vec2(.15, .22), .15, blur);\n    col = mix(col, vec3(0.), clamp(moustache + eyebrows, 0., 1.));\n    \n    col = mix(col, vec3(1., 0., 0.), step(-uv.y+.45, 0.));\n    \n    fragColor = vec4(col, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}