{"ver":"0.1","info":{"id":"cdScWW","date":"1687716638","viewed":169,"name":"Attractors Plotter 3D","username":"Envy24","description":"More attractors: http://www.3d-meier.de/tut19/Seite0.html\nOther plotters:\nhttps://www.shadertoy.com/view/csXcD4\nhttps://www.shadertoy.com/view/ddB3R1\nhttps://www.shadertoy.com/view/cdj3zz\nhttps://www.shadertoy.com/view/fl3GW7","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["attractor","chaos","dynamic","lorenz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Iterative Solvers from: https://www.shadertoy.com/view/llB3WK\n*/\nvec3 runge_kutta4(vec3 P, float dt)\n{\n\tvec3 k0 = DDT(P);\n    vec3 k1 = DDT(P + k0 * dt * 0.5);\n    vec3 k2 = DDT(P + k1 * dt * 0.5);\n    vec3 k3 = DDT(P + k2 * dt);\n    return P + (k0 + 2.0 * (k1 + k2) + k3) * dt / 6.0;\n}\n\nvec3 midpoint(vec3 P, float dt)\n{\n    vec3 k0 = DDT(P);\n    return P + DDT(P + k0 * dt * 0.5) * dt;\n}\n\nvec3 euler(vec3 P, float dt)\n{\n    return P + DDT(P) * dt;\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n\tvec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), false),\n         M = map_to_centered_ndc(iMouse.xy, 1., vec2(0), false);\n \n    mat3 transform = \n        LMB_IS_HOLD == true ?\n            rotateAroundX(-M.y*PI) * rotateAroundY(-M.x*PI) :\n            //rotateAroundX(90.*TO_RAD) * rotateAroundY(iTime);\n            rotateAroundY(iTime);\n            //mat3(1);\n    transform *= mat3(ATTRACTOR_SCALE);\n  \n    vec3 P = P0;\n    float min_dist = 99.0;\n    \n    for (int i = 0; i < NUM_OF_POINTS; ++i) {\n        vec3 prevP = P;\n        \n        // Solve system of differential equations:\n        P = SOLVER(P);\n        \n        // Segment points (orthographic projection).\n        vec2 B = ((prevP - SHIFT) * transform).xy,\n             E = ((    P - SHIFT) * transform).xy; \n\n\t\tmin_dist = min(min_dist, segmentSDF(NDC, B, E, 0.));\n    }\n    \n\tO = mix(vec4(1), vec4(0), smoothstep(3./iResolution.y, 0., min_dist));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n#define TO_DEG                      57.295779513082323          // Convert radians to degrees\n\n/*\n    Rotation Matricies:\n*/\nmat3 rotateAroundX(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n       \n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c,   -s,\n        0.0, s,   c);\n}\n\nmat3 rotateAroundY(float a)\n{\n    float s = sin(a);\n    float c = cos(a);   \n    \n    return mat3(\n        c,   0.0, -s,\n        0.0, 1.0, 0.0,\n        s,   0.0, c);\n}\n\nmat3 rotateAroundZ(float a)\n{\n    float s = sin(a);\n    float c = cos(a);   \n    \n    return mat3(\n        c,  -s,   0.0,\n        s,   c,   0.0,\n        0.0, 0.0, 1.0);\n}\n\n/*\n    SDFs:\n*/\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n/* \n    Attractors:\n*/\n\n#define X ( P.x )\n#define Y ( P.y )\n#define Z ( P.z )\n\n\n/* Lorenz Attractor *\n#define ATTRACTOR_SCALE  ( 0.03 )\n#define P0               ( vec3(0.01, 0.,0.) )      // Initial point\n#define SHIFT            ( vec3(8.5, -0.5, 27.0) )\n#define NUM_OF_POINTS    ( 3000 )\n#define DT               ( 0.01 )\n#define DDT(P)           ( LorenzAttractor(P) )\n#define SOLVER(P)        ( euler(P, DT) )\nvec3 LorenzAttractor(in vec3 P)\n{\n\tconst float SIGMA = 10.0;   // 1.0\n\tconst float RO = 28.0;     // 16.8\n\tconst float BETA = 8.0 / 3.0;\n\n    return vec3(\n        SIGMA * (Y - X),\n\t\t(X * (RO - Z) - Y),\n\t\t(X * Y - BETA * Z)\n    );\n}\n/* Aizawa Attractor */\n#define ATTRACTOR_SCALE  ( 0.6 )\n#define P0               ( vec3(0.1,0,0) )              // Initial point\n#define SHIFT            ( vec3(0, 0, 0.6) )\n#define NUM_OF_POINTS    ( 3000 )\n#define DT               ( 0.05 )\n#define DDT(P)           ( AizawaAttractor(P) )\n#define SOLVER(P)        ( midpoint(P, DT) )\nvec3 AizawaAttractor(in vec3 P)\n{  \t\n    const float a = 0.95;\t\n    const float b = 0.7;\n    const float c = 0.6;\n    const float d = 3.5;\n    const float e = 0.25; \t\n    const float f = 0.1;\n        \n    return vec3(\n        ((Z - b) * X - d * Y),\n\t\t(d * X + (Z - b) * Y),\n\t\t(c + a * Z - Z*Z*Z / 3.0 - (X*X + Y*Y)*(1.0 + e*Z) + f * Z * X*X*X)\n    );\n}\n/* Rossler Attractor *\n#define ATTRACTOR_SCALE  ( 0.03 )\n#define P0               ( vec3(1,1,1) )              // Initial point\n#define SHIFT            ( vec3(0, 0, 10) )\n#define NUM_OF_POINTS    ( 3000 )\n#define DT               ( 0.05 )\n#define DDT(P)           ( RosslerAttractor(P) )\n#define SOLVER(P)        ( midpoint(P, DT) )\nvec3 RosslerAttractor(in vec3 P)\n{  \t\n    const float a = 0.1;\t\n    const float b = 0.1;\n    const float c = 14.0;\n    \n    return vec3(\n        (-Y - Z),\n\t\t(X + a * Y),\n\t\t(b + Z * (X - c))\n    );\n}\n/* Dequan Li Attractor *\n#define ATTRACTOR_SCALE  ( 0.005 )\n#define P0               ( vec3(.349,0,-.16) )          // Initial point\n#define SHIFT            ( vec3(0, 0, 100) )\n#define NUM_OF_POINTS    ( 3000 )\n#define DT               ( 0.004 )\n#define DDT(P)           ( DequanLiAttractor(P) )\n#define SOLVER(P)        ( runge_kutta4(P, DT) )\nvec3 DequanLiAttractor(in vec3 P)\n{  \t\n    const float a = 40.;\t\n    const float c = 1.833;\n    const float d = 0.16;\n    const float e = 0.65;\n    const float k = 55.;\n    const float f = 20.;\n       \n    return vec3(\n        (a * (Y - X) + d * X * Z),\n\t\t(k * X + f * Y - X * Z),\n\t\t(c * Z + X * Y - e * X * X)\n    );\n}\n/* Halvorsen Attractor *\n#define ATTRACTOR_SCALE  ( 0.07 )\n#define P0               ( vec3(1,0,0) )          // Initial point\n#define SHIFT            ( vec3(0, -4, -3) )\n#define NUM_OF_POINTS    ( 3000 )\n#define DT               ( 0.008 )\n#define DDT(P)           ( HalvorsenAttractor(P) )\n#define SOLVER(P)        ( midpoint(P, DT) )\nvec3 HalvorsenAttractor(in vec3 P)\n{\n    const float dt = 0.003;   \t\n    const float a = 1.4;\t\n       \n    return vec3(\n        (-a * X - 4. * Y - 4. * Z - Y * Y),\n\t    (-a * Y - 4. * Z - 4. * X - Z * Z),\n\t\t(-a * Z - 4. * X - 4. * Y - X * X)\n    );\n}\n/**/","name":"Common","description":"","type":"common"}]}