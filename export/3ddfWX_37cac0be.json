{"ver":"0.1","info":{"id":"3ddfWX","date":"1606140854","viewed":318,"name":"sharingan_Itachi","username":"Learner_CC","description":"ゆるせ、サスケ、これでさいごだ！","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","noise","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// sharingan_Itachi - by CC - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// -------- const parameter -------- //\nconst float PI = 3.1415926;\n\n// -------- Transform -------- //\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\nmat2 scale(vec2 scale){\n    return mat2(scale.x, 0.0,\n                0.0, scale.y);\n}\n// -------- Basic graphic -------- //\nfloat circle( vec2 p, float r ){\n    return 1.0 - smoothstep(0.9* r, r,length(p) - r);\n}\n\nfloat ring( vec2 p, float r ){\n    return circle(p, r) - circle(p, r - 0.03);\n}\n\nfloat semicircle(vec2 p, float r) {\n    float pct = 1.0 - smoothstep(0.9 * r, r,length(p) - r); \n    pct *= step(0.0, p.y);\n    return pct;\n}\n\n// ---------------- //\nfloat gouYu(vec2 p, float progress) {\n    float pct = circle(p, 0.2 - 0.1 * progress);\n    pct += semicircle(p + vec2(-0.2 - 0.2 * progress, 0.0), 0.3);\n    pct -= semicircle(p + vec2(-0.6, 0.0), 0.15 + 0.05 * progress);   \n    return step(1.0, pct);\n}\n\nfloat eye(vec2 p, float gouyuState) {\n    float pct = circle(p, 0.5);   \n    \n    float scale = 3.0 - 2.0 * gouyuState;  // 3.0     1.0\n    float offsetScale = 1.5 - 1.4 * gouyuState; //1.5   0.2\n    \n    vec2 uv = scale * p;\n    \n    // ---- gouyu ---- //\n\n    vec2 offset = - offsetScale * vec2(cos(PI / 3.0), sin(PI / 3.0));\n    vec2 pTemp = rotate2d(PI) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);\n    pTemp = rotate2d(5.0 * PI / 3.0) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);   \n    pTemp = rotate2d(-5.0 * PI / 3.0) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);   \n    \n    // ---- ring ---- //\n    pct -= (1.0 - 4.0 * gouyuState) * circle(p, 0.06);\n    pct -= ring(p, 0.28) * (1.0 - gouyuState);\n    pct -= ring(p, 0.48);\n    \n    // ---- color ---- // \n    float opacity = 1.0 - length(p) * length(p) * length(p);\n    return pct * opacity;\n}\nfloat eyeSocket(vec2 uv, float height, float bottomPoint) {\n    float x = clamp(0.0, 1.0, 1.0 - uv.x);\n    float y = clamp(0.0, 1.0, uv.y);\n    float pct = 1.0;\n\n    float upborder = -height * (x * x * x - 1.0);\n    float bottomborder = height / (bottomPoint * bottomPoint) * (x - bottomPoint) * (x - bottomPoint);\n    bottomborder *= step(x, bottomPoint);\n    \n    pct *= smoothstep(0.96 * y, y, upborder) * step(0.0, x);\n    pct *= (1.0 - smoothstep(0.9 * y, y, bottomborder));\n    return pct;\n}\n\nvec4 sharingan(vec2 st, float openProcess, float mangekyoSharinganProgress, float t) {\n    \n    vec4 color = vec4(0.0);\n    float height = 0.55 * abs(mod(0.5 * iTime, 1.1) - 0.55);\n    height = 0.55 * openProcess;\n\n    float t1 = (clamp(t, 2.0, 8.0) - 2.0) / 6.0;\n    float x = sin(t1 * PI * 0.5);\n    x = x * x * x;\n    mat2 eyeRotate = rotate2d(-x * x * 16.0) * 1.0;\n    //eyeRotate = mat2(1.0, 0.0, 0.0, 1.0);\n    \n    vec2 eyeoffset = vec2(-1.5, -1.012);\n    float pct = eyeSocket(st, height, 0.28); \n    color += vec4(pct) - circle(3.6 * st  + eyeoffset, 0.5) * pct;  \n\n    pct *= eye((3.6 * st + eyeoffset) * eyeRotate, mangekyoSharinganProgress);\n  \n    color += vec4(pct) * vec4(1.0, 0.0, 0.0, 0.0);\n    //color += circle(3.6 * st  + eyeoffset, 0.08 * mangekyoSharinganProgress);\n\n    // ----  ---- //\n    float opacity = 0.2;\n    float t2 = clamp(t, 0.5, 1.5) - 0.5;\n    //t2 = 1.0;\n    float scale = clamp(.2 / t2, 0.3, 1.0);\n    opacity = (scale - 0.3) * 0.5  * step(1.0, openProcess);\n    pct = eye((3.6 * st + eyeoffset) * scale * eyeRotate, mangekyoSharinganProgress);\n    color += vec4(pct) * vec4(1.0, 0.0, 0.0, 0.0) * opacity;\n    \n    return color;\n}\n\n// -------- Background -------- //\n#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 4.5\n#define WIND vec2(-0.2, -0.0)\n\nconst vec3 skycolor = vec3(0.55, 0.0, 0.0);\nconst vec3 bgcolor = vec3(0.1, 0.0, 0.0);\n// ---- Noise ---- //\nvec2 random2(vec2 st) {\n    st = vec2(dot(st, vec2(127.1, 311.7)), dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat perlin_noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(\n            dot(random2(i + vec2(0.0)), f - vec2(0.0)),\n            dot(random2(i + vec2(1.0,0.0)), f - vec2(1.0, 0.0)),\n            u.x\n        ),\n        mix(            \n            dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n            dot(random2(i + vec2(1.0,1.0)), f - vec2(1.0, 1.0)),\n            u.x\n        ),\n        u.y\n    );\n}\n\nfloat noise3D(vec3 x) {\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n    p.z += WIND.x * 10.0 * iTime;\n    vec2 uv = (p.xz + vec2(37.0, 17.0) * p.y) + f.xz;\n    return perlin_noise(uv);\n}\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    p = p * 0.4;\n    f += noise3D(p); p = 2.0 * p;\n    f += 0.50000 * noise3D(p); p = 2.0 * p;\n\tf += 0.25000 * noise3D(p); p = 2.0 * p;\n\tf += 0.12500 * noise3D(p); p = 2.0 * p;\n\tf += 0.06250 * noise3D(p); p = 2.0 * p;\n    f += 0.03125 * noise3D(p);\n    \n    return f;\n}\n\nfloat density(vec3 pos) {\n    float den = 3.0 * fbm(pos * 0.3) - 2.0 + (pos.y - MIN_HEIGHT);\n    float edge = 1.0 - smoothstep(MIN_HEIGHT, MAX_HEIGHT, pos.y);\n    edge *= edge;\n    den *= edge;\n    den = clamp(den, 0.0, 1.0);\n    return den;\n}\nfloat planeIntersect( vec3 ro, vec3 rd, float plane)\n{\n    float h = plane - ro.y;\n    return h/rd.y;\n}\nvec3 raymarching(vec3 ro, vec3 rd, float t, vec3 backCol) {\n    vec4 sum = vec4(0.0);\n    vec3 pos = ro + rd * t;\n    for (int i = 0; i < 40; ++i) {\n        if (sum.a > 0.99 ||\n        pos.y < (MIN_HEIGHT - 1.0) ||\n        pos.y > (MAX_HEIGHT + 1.0)) break;\n\n        float den = density(pos);\n        if (den > 0.01) {\n            float dif = clamp((den - density(pos)) / 0.6, 0.0, 1.0);\n            vec3 lin = vec3(0.0);\n            vec4 col = vec4( mix( vec3(1.0,0.95,0.8)*1.1, vec3(0.35,0.4,0.45), den), den);\n            \n            col.rgb *= lin;\n            sum = sum + col*(1.0 - sum.a);    \n        }\n        t += max(0.05, 0.02 * t);\n       pos = ro + rd * t;\n\n       \n    }\n    sum = clamp(sum, 0.0, 1.0);\n    float h = rd.y;\n    sum.rgb = mix(sum.rgb, backCol, exp(-20.*h*h) );\n    return mix(backCol, sum.xyz, sum.a);\n}\nvec3 Tsukuyomi(vec2 uv) {\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.1, 1.0));\n\n    float dist = planeIntersect(ro, rd, 3.0);\n\n    \n    vec3 color = mix(bgcolor, skycolor, uv.y * 0.5 + 0.5);\n\n    if (dist > 0.0) {\n        color = raymarching(ro, rd, dist, color);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float time = mod(iTime, 15.0);\n    \n    vec2 st = uv;\n    st.x *= iResolution.x / iResolution.y;\n    st = st * 2.0 - 1.0;\n    st *= 1.5;\n    st.x -= 1.2;\n    \n    float pct = 0.0;\n    vec4 color = vec4(0.0);\n    // -------- eye -------- //\n    float openProcess = clamp(time, 0.0, 0.5) * (12.0 - clamp(time, 11.5, 12.0)) * 4.0;\n    float sharinganProgress = (clamp(time, 4.0, 6.0) - 4.0) * 0.5;\n    color = sharingan(st - vec2(0.4, 0.0), openProcess, sharinganProgress, time);\n    st.x = -st.x;\n    color += sharingan(st - vec2(0.4, 0.0), openProcess, sharinganProgress, time);\n    \n\n    // -------- Bg -------- //\n    st = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.xy;\n    color += vec4(Tsukuyomi(st), 1.0) * ((clamp(2.0 * time, 1.0, 3.0) - 1.0) / 2.0);\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}