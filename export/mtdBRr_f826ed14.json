{"ver":"0.1","info":{"id":"mtdBRr","date":"1701017882","viewed":84,"name":"MPR/GJK 3D Distance","username":"kastorp","description":"MPR/GJK  adaptation to show minimum vector distance\n","likes":11,"published":1,"flags":16,"usePreview":0,"tags":["distance","minkowski","mpr","gjk"],"hasliked":0,"parentid":"mlcyW4","parentname":"MPR 3D collision"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MPR/GJK 3D distance by kastorp\n//----------------------------------------\n//  MPR/GJK 3D algorithm porting from libccd\n//\n//  mouse: move shape \n//  space: align shapes\n//  b: toggle shadow\n//  c: toggle debug view (raycast iteration count)\n//  d: show simplex vertices\n//  1-2-3 toggle views\n//\n// additional experiments (uncomment in common file)\n//   SHOW_MD: show minkowski difference shape \n//   DEBUG: show ray distance from object 1, using MPR/GJK distance\n//   GJK_DIST: use GJK for distance (default)\n//----------------------------------------------\n\n\nobj segment(vec3 v1, vec3 v2, float tk,int id){\n    vec3 c = (v1+v2)*.5;\n    vec3 b = (v2-v1)*.5;\n    return  obj(c,vec4(b,tk),M_ID,8,id);\n}\n\nobj sphere(vec3 c,  float r,int id){\n    return  obj(c,vec4(vec3(r),0.),M_ID,1,id);\n}\n\nmat3 aa2m(vec4 aa){\n    float c =cos(aa.w), s = sin(aa.w), t =1. - c;\n    return outerProduct(aa.xyz,aa.xyz)*t +\n        + mat3 ( c, -aa.z*s, aa.y*s, aa.z*s, c, -aa.x*s, -aa.y*s, aa.x*s, c);\n}\nvec4 m2aa(mat3 m) {//singularities not handled\n    #define mm(a,b) (m[a][b] - m[b][a]) \n    return vec4(normalize(vec3(mm(2,1), mm(0,2), mm(1,0))),\n                acos(( m[0][0] + m[1][1] + m[2][2] - 1.)/2.)); \n}\n\n\n\nvec3 va,vb; //distance vector\n     \nint res_distance;\n\nbool trace(vec3 ro, vec3 rd, out vec3 nor, out vec3 pos, out float dist, out int id,out int iter){\n    bool hit=false;\n    \n    obj[] o =  obj[](     \n        o1,\n        o2,\n#ifdef SHOW_MD\n        sphere(vec3(0,0,0),  .02,6),\n        obj( vec3(0,0,0),  vec4(.4,.4,.4,0),M_ID,10, 3),\n        \n#endif\n        segment(va,vb,.005,res_distance<0?6:5),\n        obj( vec3(0,-.5,0),  vec4(2.,.01,1,0),M_ID,0, 4)\n     );\n    \n    \n    \n    dist=1e5;    \n    for(int i=min(0,iFrame);i<o.length();i++){\n        vec3 n; \n        float d=-1e5;\n        obj oo=o[i];\n        int res= int(rayVsSupport(oo,ro,rd,d, n, iter));\n        d=  (dot(oo.c-ro,rd) -d) ;\n            \n        if(  d >0. && res==1  ){              \n              hit=true;\n              if(d<dist){nor=n;pos=ro + d*rd;id=oo.id; dist=d;}     \n         }\n    }\n    return hit;\n}\n\n\n\nvoid mainImage(out vec4 O, in vec2 I) {\n\n    vec2 uv = (I - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 M = iMouse.z>0.?(iMouse.xy - 0.5 * iResolution.xy) / iResolution.y:vec2(iTime*.2,0.5);\n    float tm = .5*iTime;\n\n    vec3   ro= vec3(sin(tm),.5,cos(tm));\n    //alternate views (toggle with 1-2-3)\n    if(texelFetch(iChannel3,ivec2(49,2),0).x>.5 ) ro= vec3(-1,0,0.001);  \n    if(texelFetch(iChannel3,ivec2(50,2),0).x>.5 ) ro= vec3(.001,0,1);  \n    if(texelFetch(iChannel3,ivec2(51,2),0).x>.5 ) ro = vec3(0,1,0.001);  \n    \n     vec3 rd0 =-normalize(ro); \n     vec3 rx =normalize(cross(rd0,VAXIS)),\n          ry =cross(rx,rd0);\n     vec3 rd=normalize(rd0+uv.x*rx+uv.y*ry); \n     \n\n     o1=  obj(  vec3(-.3,0,0) + (iMouse.z>0.?   M.x*rx +M.y*ry:vec3(0)), vec4(.3,.03,.03,0.),\n              aa2m(vec4(normalize(vec3(1,1,0)),0.5*tm)),\n              0, 1 );\n\n     o2=  obj( vec3(.3,0,0), vec4(.2,.2,.2,.0),\n              aa2m(vec4(normalize(vec3(0,1,1)),tm)),\n              0,2);\n   \n    float ch =mod(tm/3.,6.);\n    o2.s = int(ch);\n\n    if(texelFetch(iChannel3,ivec2(32,2),0).x>.5) o2.rm=o1.rm; //align\n   \n   \n    \n    //getIntersect();\n    res_distance  = getDistance(o1,o2,va,vb);\n\n#ifdef GJK_DIST\n   O=vec4(res_distance==4);\n#else\n    O=vec4(0);\n#endif\n    \n    //PALETTE:\n    vec3[] cols =vec3[] (vec3(0),vec3(1,0,0),vec3(0,0,1),vec3(0,1,0),vec3(.5),vec3(1),vec3(1,1,0),vec3(1,0,1),vec3(0,1,1));\n    vec3 nor,pos,pos2;\n    \n    float dist; int iter=0,id,id2;\n    bool hit=trace(ro,rd,nor,pos,dist,id,iter);\n    if (hit){\n       vec3 ld=normalize(vec3(1,3,.5));\n       float gr =  max(max(sin(pos.x*62.8),sin(pos.y*62.8)),sin(pos.z*62.8));\n       vec3 col= cols[id];\n       if(texelFetch(iChannel3,ivec2(68,2),0).x>.5 ){\n           if(id==1) {      \n               if(min(min(length(pos-s1.a), length(pos-s1.b)), length(pos-s1.c))<.02) col=vec3(1);\n               if(length(pos-s1.d)<.02) col=vec3(.5);\n\n           }\n           if(id==2) {      \n               if(min(min(length(pos-s2.a), length(pos-s2.b)), length(pos-s2.c))<.02) col=vec3(1);\n               if(length(pos-s2.d)<.02) col=vec3(.5);\n           }\n       }\n       O = vec4(col,1.) * (.6+ smoothstep(1.,1.-min(fwidth(gr),.1),gr)*.1 - dot(nor,ld)*.3);\n               \n       if(texelFetch(iChannel3,ivec2(66,2),0).x<.5){\n            bool sh =dot(nor,ld)>=-0. || trace(pos+ld*TOLERANCE,ld,nor,pos2,dist,id2,iter);\n            if(sh )O*=.5;\n       }\n       \n       if(id==4 || id==2) {\n           //distance function is a subcase (distance with point)\n           o2=  obj( pos, vec4(0), M_ID,-1,2);\n           int res= getDistance(o1,o2,va,vb); \n           O+= .2*smoothstep(-.1,.1,sin(length(va-vb)*62.8))*(res<0?vec4(2,2,0,0):vec4(1));\n       }\n       \n      if(texelFetch(iChannel3,ivec2(67,2),0).x>.5){ \n        O=vec4(iter)/80.; //DEBUG ITERATIONS\n      }\n    }\n#ifdef DEBUG  \n    else{\n        //ray vs object distance\n        o2= segment(ro-rd*5., ro+rd*5., .0,5);\n        int res =getDistance(o1,o2,va,vb); \n        O+= .2+.2*smoothstep(-.1,.1,sin(length(va-vb)*62.8))*(res<0?vec4(2,2,0,0):vec4(1));\n    }\n#endif\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define MAX_ITER 20\n#define SHADOW\n#define TOLERANCE 1e-5\n#define VAXIS vec3(0,1,0)\n//#define SHOW_MD\n//#define DEBUG\n#define GJK_DIST\n\n\nstruct obj{\n    vec3 c; //center\n    vec4 b; //bounding box (w=thickness)\n    mat3 rm; //rotation (xyz=axis, w=angle)\n    int s; //shape \n    int id; //material id\n};\n\n\nobj _ob1,_ob2;\n\n\nstruct simplex{\n    vec3 a,b,c,d; //simplex\n};\n\nsimplex s,s1,s2;\n\nmat3 M_ID=mat3(1,0,0,0,1,0,0,0,1);\n\n\n#define  tripleCross(a,b,c) cross(a,cross(b,c))\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//-------------------\n\nvec3 supMax(vec3 d, vec3 a, vec3 b)\n{\n    return dot(d,a) > dot(d,b) ? a : b;\n}\n\n\n\nconst float phi=(sqrt(5.)-1.)*.5,phi2=phi*phi;\n\n#ifdef SHOW_MD\nvec3 supports(vec3 dir, obj o){\n#else\nvec3 support(vec3 dir, obj o){\n#endif\n    dir=transpose(o.rm)*normalize(dir);\n    vec2 dirH=normalize(dir.xy);\n    \n    vec3 s;\n    switch (o.s) {\n        default:                \n        case -1:\n            s= vec3(0);          \n            break;\n        case 0: //BOX\n            s=sign(dir)*o.b.xyz;\n            \n            break;\n        case 1: //ELLIPSOID\n            s= normalize(dir*o.b.xyz)*(o.b.xyz);\n           break;\n        case 2: //CYLINDER\n           s=supMax( dir,        \n            vec3(dirH*o.b.x, o.b.y), \n            vec3(dirH*o.b.x, -o.b.y) \n            );\n           break;   \n        case 3: //CONE\n           s=supMax( dir,        \n            vec3(dirH*o.b.x, -o.b.z) ,\n            vec3(0,0,o.b.z)\n            );\n           break;                    \n        case 4: //TETRAHEDRON\n              s=  supMax(dir,\n                          supMax( dir,vec3(o.b),vec3(o.b.x,-o.b.yz)),\n                          supMax( dir,vec3(-o.b.x,o.b.y,-o.b.z),vec3(-o.b.xy,o.b.z))\n                      );\n              break;\n        case 5: //ICOSAHEDRON\n                //h=0.  Tetradecahedron\n              s=  o.b.xyz/(1.+phi)* supMax(dir,\n                         sign(dir)*vec3(1.,1.+phi,0),\n                         supMax(dir, sign(dir)*vec3(0,1.,1.+phi),sign(dir)*vec3(1.+phi,0,1.))\n                      );             \n              break;\n        case 6: //DODECAHEDRON\n               //h=1. romboid dodecahedron                      \n              s=  o.b.xyz/(1.+phi)* supMax(dir,\n                         supMax(dir, sign(dir)*(1.),sign(dir)*vec3(1.+ phi,1.-phi2,0)),\n                         supMax(dir, sign(dir)*vec3(0,1. +phi,1.-phi2),sign(dir)*vec3(1.-phi2,0,1.+ phi))\n                      );\n             break;\n      //  case 7: //RANDOM ROCK\n      //      s=sign(dir)*.3;\n      //      for(float j=0.;j<10.;j++) s=supMax(dir,s,-1.+ 2.*hash31(float(o.id)*.22+11.2*j));\n      //      s*=o.b.xyz;  \n      //       break;   \n        case 8: //SEGMENT\n           s=supMax( dir,        \n            vec3(o.b.xyz),\n            vec3(-o.b.xyz)\n            ); \n           break;           \n\n    } \n    //if(o.s==0 && o.b.w==0. && edges  ){\n    //    s +=  0.001* supMax(dir, supMax(dir, sign(dir)*vec3(1,0,0), sign(dir)*vec3(0,1,0)), sign(dir)*vec3(0,0,1));\n    //}\n    return (s +dir*o.b.w) *transpose(o.rm) +o.c; \n        \n} \n\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n//baricentric coordinates of closest point\nvec3   PointTriDistK(in vec3 p,  in vec3 b, in vec3 c, in vec3 d)\n{\n    float k1,k2,k3;\t\n    vec3 v10 = c - b; vec3 p0 = p - b;\n    vec3 v21 = d - c; vec3 p1 = p - c;\n    vec3 v02 = b - d; vec3 p2 = p - d;\n    vec3 nor = cross( v10, v02 );\n    \n         if( dot(cross(v10,nor),p0)<0.0 ) { k2= clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 ); k3=0.;k1=1.-k2;}\n    else if( dot(cross(v21,nor),p1)<0.0 ) { k3= clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 ); k1=0.;k2=1.-k3;}\n    else if( dot(cross(v02,nor),p2)<0.0 ) { k1= clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 ); k2=0.;k3=1.-k1;}\n    else {    \n        k1 = dot(cross(c,d),nor);  \n        k2 = dot(cross(d,b),nor);  \n        k3 = dot(cross(b,c),nor);\n    }\n    return vec3(k1,k2,k3)/(k1+k2+k3);  \n}\n\n\nobj o1,o2;\n#ifdef SHOW_MD\nobj oa,ob;\nvec3 support(vec3 dir, obj o){\n   if(o.s==10)return supports(dir,oa)-supports(-dir,ob) +o.c;\n   else return supports(dir,  o);\n}\n#endif\n\n// adapted from:  https://www.shadertoy.com/view/wstyRB\n//  Casts ray in rd direction from ro, estimates depth and normal \nbool rayVsSupport( obj o,vec3 ro, vec3 rd,out float depth, out vec3 normal , out int it)\n{   \n     ro*=-1.;rd*=-1.; o.c*=-1.;  //needed for asymmetric support functions\n    vec3 dir, tmp;   \n    simplex _s;\n    \n    //RX=horizontal axis, RY=vertical axis    \n    vec3 rx =normalize(cross(rd,VAXIS)),ry=cross(rx,rd);\n    mat3 rmai=mat3(rx,ry,rd), rma=transpose(rmai); \n    //switch to local coordinates\n    ro*=rmai;\n    rd=vec3(0,0,1);\n  \n          \n    o.c*=rmai; \n    o.rm= rma*o.rm ;  \n    o.c =  cross(cross(rd,ro-o.c),rd); \n   \n    _s.a= o.c;\n    \n#ifdef SHOW_MD\n    if(o.s==10){   \n        oa=o1;\n        ob=o2;\n        \n        oa.c*=rmai; \n        oa.rm= rma*oa.rm ;  \n        oa.c =  cross(cross(rd,ro-oa.c),rd); \n        \n        ob.c*= rmai; \n        ob.rm= rma*ob.rm ;  \n        ob.c =  cross(cross(rd,ro-ob.c),rd);\n        \n        _s.a+= oa.c-ob.c;\n    } \n#endif  \n\n    _s.b=support(vec3(-_s.a.xy, 0.),o);\n    if (dot(-_s.a.xy, _s.b.xy) <= 0.) return false;\n    \n    #define perp2d(v)  ((v).yx*vec2(-1,1))  //(cross(v,vec3(0,0,-1)).xy) \n    \n    dir = vec3(perp2d(_s.b-_s.a),0.);\n    if (dot(dir.xy, _s.a.xy) >= 0.)\n    {\n        dir.xy *= -1.;\n        tmp = _s.a; _s.a = _s.b; _s.b = tmp;\n    }\n    _s.c=support(dir,o);\n    if (dot(_s.c.xy, dir.xy) <= 0.)\n        return false;\n    \n    for (int i = 0;; ++i)\n    {\n         it++;\n        if (i == 6) return false;\n        if (dot(dir.xy = perp2d(_s.c-_s.a), _s.c.xy) < 0.)\n            {_s.b = _s.c;}\n        else if (dot(dir.xy = perp2d(_s.b-_s.c), _s.c.xy) < 0.)\n             {_s.a = _s.c;}\n        else break; // Origin in triangle -> intersection!\n        \n        _s.c=support(dir,o);    \n        if (dot(_s.c.xy, dir.xy) <= 0.)\n            return false;\n    }\n  \n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n        it++;\n        dir = normalize(cross(_s.b-_s.a, _s.c-_s.a));\n        //dir*=-1.; // uncomment to get exit point\n        _s.d=support(dir,o);\n\n        if (abs(dot(dir, _s.d) - dot(dir, _s.a)) < TOLERANCE)break;\n\n        // xd = origin left of xd line\n        bool ad = dot(perp2d(_s.d-_s.a), _s.d.xy) > 0.;\n        bool bd = dot(perp2d(_s.d-_s.b), _s.d.xy) > 0.;\n        bool cd = dot(perp2d(_s.d-_s.c), _s.d.xy) > 0.;\n\t\t\n        // Choose triangle that intersects z-axis furthest in z direction\n        if (ad && !bd) {_s.c = _s.d;}\n        else if (bd && !cd) {_s.a = _s.d;}\n        else if (cd && !ad) {_s.b = _s.d;}\n        else break; // Should not happen\n\n\t}\n\n    normal = normalize(cross(_s.b-_s.a, _s.c-_s.a));\n    depth = _s.a.z + dot(_s.a.xy, normal.xy)/normal.z ;\n    normal*=-rma;\n    \n    return true;\n}\n\n\n//Minkowsky difference support function\nvec3 supportD(vec3 dir,out vec3  s1, out vec3 s2){\n    s1 = support(dir,_ob1) ;     \n    s2 = support(-dir,_ob2) ;   \n    return s1-s2;\n}\n\n//------------------------------------\n\nint discoverPortal(bool skip)\n{\n    vec3 dir; \n   \n    // vertex a is center of portal\n    s1.a=_ob1.c;s2.a=_ob2.c; s.a= s1.a-s2.a; \n    \n    \n    if (s.a==vec3(0)) {s1.a+= vec3(1e-3,0,0); s.a+=vec3(1e-3,0,0);}\n     \n    // vertex b = support in direction of origin\n\tdir= -(s.a);  \n    s.b = supportD(dir,s1.b,s2.b);\n\n    // test if origin isn't outside of b\n    if ( dot(s.b, dir) <=0. && skip) return -1;\n\n    // vertex c\n\tdir = cross(s.a, s.b);\t\t\t\t\t \t\t\t\t\t   \n    if (length(dir)==0.){\n        if (s.b == (_ob1.c-_ob2.c)) return 1; // origin lies on b\n        else return 2; // origin lies on a-b segment\n    }\n    \n\ts.c= supportD((dir),s1.c,s2.c);\n    if ( dot(s.c, dir) <=0. &&skip) return -1;\n\n    // vertex d direction\n\n\tdir= (cross(s.b-s.a,s.c-s.a));\n\n    // it is better to form portal faces to be oriented \"outside\" origin\n\n    if (dot(dir, s.a) > 0.){\n        vec3 t =s.b; s.b=s.c;s.c=t; t =s1.b; s1.b=s1.c;s1.c=t; t =s2.b; s2.b=s2.c;s2.c=t;//swap\n        dir *=-1.;\n    }\n    \n\n    for ( int iter=0;iter <10;iter++){\n\t\ts.d= supportD(dir,s1.d,s2.d);        \n        if (dot(s.d, dir) <=0. &&skip) return -1;\n        \n        // test if origin is outside (b, a, d) - set c as d and continue\n        if ( dot(cross (s.b,s.d), s.a)  < 0. ){\n\t\t\ts.c=s.d;s1.c=s1.d;s2.c=s2.d;                  \n        }\n              \n        // test if origin is outside (d, a, c) - set b as d and continue\n        else if (dot(cross (s.d,s.c), s.a) < 0. ){\n            s.b=s.d;s1.b=s1.d;s2.b=s2.d;\n        }        \n        dir =(cross( s.b-s.a, s.c-s.a));\n    }\n    return 0;\n}\n\n\nfloat  PointOutsideTri(in vec3 p,  in vec3 b, in vec3 c, in vec3 d)\n{\n    float k1,k2,k3;\t\n    vec3 v10 = c - b; vec3 p0 = p - b;\n    vec3 v21 = d - c; vec3 p1 = p - c;\n    vec3 v02 = b - d; vec3 p2 = p - d;\n    vec3 nor = cross( v10, v02 );\n    if(nor==vec3(0)) return 1.;\n    \n    return  min(min(dot(cross(v10,nor),p0),  \n             dot(cross(v21,nor),p1)),  \n             dot(cross(v02,nor),p2)) ; \n    \n}\n\nint refinePortal(bool skip)\n{\n    vec3 dir;\n    vec3 v4,v41,v42;\n    int iter=2;\n    \n    while (iter<MAX_ITER){\n        iter++;\n        // compute direction outside the portal (from v0 throught v1,v2,v3 face)\n        dir= (cross( s.c-s.b, s.d-s.b));\n\n        // test if origin is inside the portal\n        if ( dot(dir, s.b)>= 0. && skip) return iter;\n\n        // get next support point\n        v4 = supportD(dir,v41,v42);\n       \n        // find the smallest dot product of dir and {a-v4, b-v4, c-v4}\n        float dv1 = dot(s.a, dir);\n        float dv2 = dot(s.b, dir);\n        float dv3 = dot(s.c, dir);\n        float dv4 = dot(v4, dir);\n\n        // test if v4 can expand portal to contain origin and if portal\n        // expanding doesn't reach given tolerance\n        if ( dot(v4, dir)<0. && skip) return -iter ;\n  \n         bool portalReachTolerance=   (min(min(dv4 - dv1, dv4 - dv2),dv4 - dv3))  <=TOLERANCE;\n\n        if( portalReachTolerance)  {\n#ifndef DEBUG\n            return iter;\n#else\n            //IF COPLANAR CHECK IF INSIDE PORTAL - SEEMS REDUNDANT\n            if(skip )return iter;\n            float k= PointOutsideTri(v4,s.b,s.c,s.d);\n            if(k==0.) return iter;\n            if(k<0. && iter>MAX_ITER-2) return iter;\n            if(k>0. && iter>MAX_ITER-2) return -iter;\n#endif            \n        }\n  \n        // expandPortal( v4);\n        // b-c-d triangle must be rearranged to face outside Minkowski\n        // difference (direction from a). \n        vec3 v4a =cross( v4,s.a);\n        \n        // xv = origin left of xv line\n        bool bv =dot (s.b, v4a)>0.,cv=dot (s.c, v4a)>0.,dv=dot (s.d, v4a)>0.;\n#ifdef DEBUG            \n        if(all(bvec3(bv,cv,dv)) ) return -1;\n        if(!any(bvec3(bv,cv,dv)) ) return -1;\n#endif\n               \n        \n        if (bv && !cv) {s.d=v4;s1.d=v41;s2.d=v42;}\n        else if (cv && !dv) {s.b=v4;s1.b=v41;s2.b=v42;}\n        else if (dv && !bv)  {s.c=v4;s1.c=v41;s2.c=v42;}\n        else return -1;  //should not happen  \n                \n    }\n    return -iter;\n}\n\n\n\n\n\nint getDistanceMPR(obj o1 , obj o2 ,out vec3 v1,out vec3 v2)\n{\n    int res;\n    _ob1 =o1;\n    _ob2 =o2;\n    s2.b=s2.c=s2.d=s2.a=o2.c;\n    s1.b=s2.c=s1.d=s1.a=o1.c;\n    \n    res = discoverPortal(false);\n    if(res==0) res=refinePortal(false);\n\n    vec3 k =  PointTriDistK(vec3(0),s.b,s.c,s.d);   \n    v1=  (s1.b*k.x+s1.c*k.y+s1.d*k.z) ;\n    v2=  (s2.b*k.x+s2.c*k.y+s2.d*k.z) ;\n    \n    return res;\n}\n\n\n\n\n\n#ifndef GJK_DIST\n    #define getDistance(o1 ,o2 ,v1,v2) getDistanceMPR(o1 ,o2 ,v1,v2)\n#else\n    #define getDistance(o1 ,o2 ,v1,v2) getDistanceGJK(o1 ,o2 ,v1,v2)\n\n// static variables\nint cnt; // simplex size from 0 to 4 \nfloat D; //distance\nvec4 BC; // baricenter coordinates\n\n\n// Input: the support function value (sp=difference, sp1=ob 1, sp2=obj2) for the current simplex\n// Output: updated simplex s,s1,s2 of the next region between: \n//  3 regions, if cnt=2 (segment)\n//  7 regions, if cnt=3 (triangle)\n//  15 regions, if cnt=4 (tretrahedron)\n// Output: the input direction for the next support function evaluation\n// output: uodated distance (D), baricenter coordinates (NC)  and simplex size (cnt)\n// https://gist.github.com/vurtun/29727217c269a2fbf4c0ed9a1d11cb40    \nint gjk(vec3 sp,vec3 sp1, vec3 sp2 , out vec3 supd)\n{\n\n    /* I.) Initialize */ \n    /* II.) Check for duplications */\n\n    ///* III.) Add vertex into simplex */\n    if(cnt==0) {s.a = sp;s1.a=sp1; s2.a=sp2;}\n    if(cnt==1) {s.b = sp;s1.b=sp1; s2.b=sp2;}\n    if(cnt==2) {s.c = sp;s1.c=sp1; s2.c=sp2;}\n    if(cnt==3) {s.d = sp;s1.d=sp1; s2.d=sp2;}\n    \n    BC[cnt++] = 1.0;\n\n    vec3 a= s.a;\n    vec3 b= s.b;\n    vec3 c= s.c;\n    vec3 d= s.d;\n    \n    /* IV.) Find closest simplex point */\n    switch (cnt) {\n    case 1: break;\n    case 2: {\n        /* -------------------- Line ----------------------- */\n\n\n        /* compute barycentric coordinates */\n\n        float u = dot(b, b-a);\n        float v = dot(a, a-b);\n       // if (v <= 0.0f) {\n       //     /* region A */\n       //     BC[0] = 1.;\n       //     cnt = 1;\n       //     break;\n       // }\n        if (u <= 0.0) {\n            /* region B */\n            s.a = s.b; s1.a=s1.b;s2.a=s2.b;\n            //BC[0] = 1.0;\n            cnt = 1;\n            break;\n        }\n        /* region AB */\n        BC.xy  = vec2(u,v);\n        cnt = 2;\n    } break;\n    case 3: {\n        /* -------------------- Triangle ----------------------- */\n\n        /* compute barycentric coordinates */\n        float u_ab = dot(b, b-a);\n        float v_ab = dot(a, a-b);\n\n        float u_bc = dot(c, c-b);\n        float v_bc = dot(b, b-c);\n\n        float u_ca = dot(a, a-c);\n        float v_ca = dot(c, c-a);\n\n       // if (v_ab <= 0.0 && u_ca <= 0.0) {\n       //     /* region A */\n       //     cnt = 1;\n       //     break;\n       // }\n       // if (u_ab <= 0.0 && v_bc <= 0.0) {\n       //     /* region B */\n       //     s.a=s.b; s1.a=s1.b;s2.a=s2.b;\n       //     cnt = 1;\n       //     break;\n       // }\n        if (u_bc <= 0.0 && v_ca <= 0.0) {\n            /* region C */\n            s.a = s.c; s1.a=s1.c;s2.a=s2.c;\n            cnt = 1;\n            break;\n        }\n        /* calculate fractional area */\n        vec3 n=cross( b-a, c-a);\n        float u_abc = dot(cross( b, c), n);\n        float v_abc = dot(cross( c, a), n);\n        float w_abc = dot(cross( a, b), n);\n\n        if (u_ab > 0.0 && v_ab > 0.0 && w_abc <= 0.0) {\n            /* region AB */\n            BC.xy = vec2(u_ab,v_ab);\n            cnt = 2;\n            break;\n        }\n        if (u_bc > 0.0 && v_bc > 0.0 && u_abc <= 0.0) {\n            /* region BC */\n            s.a = s.b; s1.a=s1.b;s2.a=s2.b;\n            s.b = s.c; s1.b=s1.c;s2.b=s2.c;\n            BC.xy = vec2(u_bc, v_bc);\n            cnt = 2;\n            break;\n        }\n        if (u_ca > 0.0 && v_ca > 0.0 && v_abc <= 0.0) {\n            /* region CA */\n            s.b = s.a; s1.b=s1.a;s2.b=s2.a;\n            s.a = s.c; s1.a=s1.c;s2.a=s2.c;\n            BC.xy = vec2(u_ca, v_ca);\n            cnt = 2;\n            break;\n        }\n        /* region ABC */\n       //(u_abc > 0.0f && v_abc > 0.0f && w_abc > 0.0f);\n        BC.xyz = vec3(u_abc,v_abc,w_abc);\n        cnt = 3;\n    } break;\n    case 4: {\n        /* -------------------- Tetrahedron ----------------------- */\n\n        /* compute barycentric coordinates */\n        //float u_ab = dot(b, b-a);\n        //float v_ab = dot(a, a-b);\n\n        //float u_bc = dot(c, c-b);\n        //float v_bc = dot(b, b-c);\n\n        //float u_ca = dot(a, a-c);\n        //float v_ca = dot(c, c-a);\n\n        float u_bd = dot(d, d-b);\n        float v_bd = dot(b, b-d);\n\n        float u_dc = dot(c, c-d);\n        float v_dc = dot(d, d-c);\n\n        float u_ad = dot(d, d-a);\n        float v_ad = dot(a, a-d);\n\n        /* check verticies for closest point */\n       // if (v_ab <= 0.0 && u_ca <= 0.0 && v_ad <= 0.0) {\n       //     /* region A */\n       //     cnt = 1;\n       //     break;\n       // }\n       // if (u_ab <= 0.0f && v_bc <= 0.0f && v_bd <= 0.0) {\n       //     /* region B */\n       //     s.a = s.b; s1.a=s1.b;s2.a=s2.b;\n       //     cnt = 1;\n       //     break;\n       // }\n       // if (u_bc <= 0.0f && v_ca <= 0.0f && u_dc <= 0.0) {\n       //     /* region C */\n       //     s.a = s.c; s1.a=s1.c;s2.a=s2.c;\n       //     cnt = 1;\n       //     break;\n       // }\n        if (u_bd <= 0.0f && v_dc <= 0.0f && u_ad <= 0.0) {\n            /* region D */\n            s.a = s.d; s1.a=s1.d;s2.a=s2.d;\n            cnt = 1;\n            break;\n        }\n        /* calculate fractional area */\n        vec3 n = cross(d-a, b-a);\n        float u_adb = dot(cross(d, b), n);\n        float v_adb = dot(cross(b, a), n);\n        float w_adb = dot(cross(a, d), n);\n\n        n= cross( c-a, d-a);\n        float u_acd = dot(cross( c, d), n);\n        float v_acd = dot(cross( d, a), n);\n        float w_acd = dot(cross( a, c), n);\n\n        n= cross(b-c, d-c);\n        float u_cbd = dot(cross( b, d), n);\n        float v_cbd = dot(cross( d, c), n);\n        float w_cbd = dot(cross( c, b), n);\n\n        n= cross( b-a, c-a);\n        float u_abc = dot(cross( b, c), n);\n        float v_abc = dot(cross( c, a), n);\n        float w_abc = dot(cross( a, b), n);\n\n     //   /* check edges for closest point */\n     //   if (w_abc <= 0.0 && v_adb <= 0.0 && u_ab > 0.0 && v_ab > 0.0) {\n     //       /* region AB */\n     //       BC.xy =vec2( u_ab,v_ab);\n     //       cnt = 2;\n     //       break;\n     //   }\n     //   if (u_abc <= 0.0 && w_cbd <= 0.0 && u_bc > 0.0 && v_bc > 0.0) {\n     //       /* region BC */\n     //       s.a = s.b; s1.a=s1.b;s2.a=s2.b;\n     //       s.b = s.c; s1.b=s1.c;s2.b=s2.c;\n     //       BC.xy = vec2(u_bc, v_bc);\n     //       cnt = 2;\n     //       break;\n     //   }\n     //   if (v_abc <= 0.0 && w_acd <= 0.0 && u_ca > 0.0 && v_ca > 0.0) {\n     //       /* region CA */\n     //       s.b = s.a; s1.b=s1.a;s2.b=s2.a;\n     //       s.a = s.c; s1.a=s1.c;s2.a=s2.c;\n     //       BC.xy = vec2(u_ca, v_ca);\n     //       cnt = 2;\n     //       break;\n     //   }\n        if (v_cbd <= 0.0 && u_acd <= 0.0 && u_dc > 0.0&& v_dc > 0.0) {\n            /* region DC */\n            s.a = s.d; s1.a=s1.d;s2.a=s2.d;\n            s.b = s.c; s1.b=s1.c;s2.b=s2.c;\n            BC.xy =vec2( u_dc,v_dc);\n            cnt = 2;\n            break;\n        }\n        if (v_acd <= 0.0 && w_adb <= 0.0 && u_ad > 0. && v_ad > 0.0) {\n            /* region AD */\n            s.b = s.d; s1.b=s1.d;s2.b=s2.d;\n            BC.xy = vec2(u_ad, v_ad);\n            cnt = 2;\n            break;\n        }\n        if (u_cbd <= 0.0 && u_adb <= 0.0 && u_bd > 0.0&& v_bd > 0.0) {\n            /* region BD */\n            s.a = s.b; s1.a=s1.b;s2.a=s2.b;\n            s.b = s.d; s1.b=s1.d;s2.b=s2.d;\n            BC.xy =vec2( u_bd, v_bd);\n            cnt = 2;\n            break;\n        }\n        /* calculate fractional volume (volume can be negative!) */\n        #define f3box(x,y,z) dot(cross(x,y),z)\n        float denom = f3box(c-b, a-b, d-b);\n        float volume = (denom == 0.) ? 1.0: 1.0/denom;\n        float u_abcd = f3box(c, d, b) * volume;\n        float v_abcd = f3box(c, a, d) * volume;\n        float w_abcd = f3box(d, a, b) * volume;\n        float x_abcd = f3box(b, a, c) * volume;\n\n        /* check faces for closest point */\n        if (x_abcd < 0.0 && u_abc > 0.0 && v_abc > 0.0 && w_abc > 0.0) {\n            /* region ABC */\n            BC.xyz=vec3( u_abc, v_abc, w_abc);\n            cnt = 3;\n            break;\n        }\n        if (u_abcd < 0.0 && u_cbd > 0.0 && v_cbd > 0.0 && w_cbd > 0.0) {\n            /* region CBD */\n            s.a = s.c; s1.a=s1.c;s2.a=s2.c;\n            s.c = s.d; s1.c=s1.d;s2.c=s2.d;\n            BC.xyz = vec3(u_cbd, v_cbd, w_cbd);\n            cnt = 3;\n            break;\n        }\n        if (v_abcd < 0.0 && u_acd > 0.0 && v_acd > 0.0 && w_acd > 0.0) {\n            /* region ACD */\n            s.b = s.c; s1.b=s1.c;s2.b=s2.c;\n            s.c = s.d; s1.c=s1.d;s2.c=s2.d;\n            BC.xyz = vec3(u_acd, v_acd, w_acd);\n            cnt = 3;\n            break;\n        }\n        if (w_abcd < 0.0 && u_adb > 0.0 && v_adb > 0.0 && w_adb > 0.0) {\n            /* region ADB */\n            s.c = s.b; s1.c=s1.b;s2.c=s2.b;\n            s.b = s.d; s1.b=s1.d;s2.b=s2.d;\n            BC.xyz = vec3(u_adb,v_adb,w_adb);\n            cnt = 3;\n            break;\n        }\n        /* region ABCD */\n        //assert(u_abcd >= 0.0f && v_abcd >= 0.0f && w_abcd >= 0.0f && x_abcd >= 0.0f);\n        BC = vec4(u_abcd,v_abcd,w_abcd,x_abcd);\n        cnt = 4;\n    } break;}\n\n    /* V.) Check if origin is enclosed by tetrahedron */\n    if (cnt == 4) {\n        //hit = 1;\n        return 0;\n    }\n    /* VI.) Ensure closing in on origin to prevent multi-step cycling */\n    /* VII.) New search direction */\n    vec3 pnt;\n    vec3 dir = vec3(0);\n\n    switch (cnt) {\n        case 1: {\n            /* --------- Point -------- */\n             dir=  -s.a;\n             pnt= s.a;\n            } break; \n        case 2: {\n            /* --------- Line -------- */\n            dir= cross( cross(s.b - s.a, -s.b), s.b - s.a);\n            pnt = (s.a* BC.x + s.b * BC.y )/(BC.x+BC.y);\n        } break;\n        case 3: {\n            /* ------- Triangle ------ */\n             vec3 n =  cross(  s.b- s.a,  s.c -s.a);\n            if (dot(n, s.a) <= 0.0)\n                dir=  n;\n            else dir = - n;\n            pnt=  (s.a* BC.x+ s.b * BC.y+ s.c * BC.z)/(BC.x+BC.y+BC.z);\n        } break;\n    }\n\n    float d2 = dot(pnt, pnt);\n    if (d2 >= D) return 0; \n    D = d2;\n\n    \n    if (dot(dir,dir) < TOLERANCE*TOLERANCE) return 0;\n\n    supd=dir;\n    return 1;\n}   \n\nint getDistanceGJK(obj o1 , obj o2 ,out vec3 v1,out vec3 v2)\n{\n\n    int res;\n    _ob1 =o1;\n    _ob2 =o2;\n    s2.b=s2.c=s2.d=s2.a=o2.c;\n    s1.b=s2.c=s1.d=s1.a=o1.c;\n    s.a=s1.a-s2.a;\n    \n    cnt=0;\n    D= 1e5;\n    vec3 dir =s.a;\n    for(int it=0;it<MAX_ITER;it++){\n        vec3 sp,sp1,sp2;\n        \n        sp=supportD(dir, sp1,sp2);\n        if(gjk(sp,sp1,sp2,dir)==0) break;\n    }\n    if(cnt==1){ v1=s1.a;v2=s2.a;}\n    else if(cnt==2){ v1=(s1.a*BC.x+s1.b*BC.y)/(BC.x+BC.y);v2=(s2.a*BC.x+s2.b*BC.y)/(BC.x+BC.y);}\n    else if(cnt==3){ v1=(s1.a*BC.x+s1.b*BC.y+s1.c*BC.z)/(BC.x+BC.y+BC.z);v2=(s2.a*BC.x+s2.b*BC.y+s2.c*BC.z)/(BC.x+BC.y+BC.z);}\n    else if(cnt==4){ v1=(s1.a*BC.x+s1.b*BC.y+s1.c*BC.z+s1.d*BC.w)/(BC.x+BC.y+BC.z+BC.w);v2=(s2.a*BC.x+s2.b*BC.y+s2.c*BC.z+s2.d*BC.w)/(BC.x+BC.y+BC.z+BC.w);}\n    \n    \n    return cnt;\n    \n}\n\n#endif\n\n/*\n\n\n// Iq:  https://www.shadertoy.com/view/ttfGWl\nfloat  PointTriDist2(in vec3 p,  in vec3 v0, in vec3 v1, in vec3 v2, out vec3 dir  )\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v02 = v0 - v2; vec3 p2 = p - v2;\n    vec3 nor = cross( v10, v02 );\n\n    if( dot(cross(v10,nor),p0)<0.0 ) dir=  v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    else if( dot(cross(v21,nor),p1)<0.0 ) dir= v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    else if( dot(cross(v02,nor),p2)<0.0 ) dir= v2 + v02*clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 );\n    else dir= p - nor*dot(nor,p0)/dot2(nor);\n    return dot2(p-dir);  \n}\n\nvoid findPos(out vec3 p1,out vec3 p2,bool face)\n{\n    vec3  dir;\n    float k0,k1,k2,k3, sum;\n\n    dir= normalize(cross( s.c-s.b, s.d-s.b));\n    \n    // use barycentric coordinates of tetrahedron to find origin    \n    k0 = dot(cross(s.b,s.c),s.d);\n    k1 = dot(cross(s.d,s.c),s.a);\n    k2 = dot(cross(s.a,s.b),s.d); \n    k3 = dot(cross(s.c,s.b),s.a);  \n\n\tsum = k0 + k1 + k2 + k3;\n    if (sum<=0. || face){\n\t\tk0 = 0.;\n        k1 = dot(cross(s.c,s.d),dir);  \n        k2 = dot(cross(s.d,s.b),dir);  \n        k3 = dot(cross(s.b,s.c),dir);   \n\t\tsum = k1 + k2 + k3;\n\t}\n    \n     p1= (s1.a*k0+s1.b*k1+s1.c*k2+s1.d*k3)/sum;\n     p2= (s2.a*k0+s2.b*k1+s2.c*k2+s2.d*k3)/sum;\n\n}\nvoid findPenetr(out float depth, out vec3 dir, out vec3 pos){\n\n    \n    vec3 v4,v41,v42;\n    int iterations;\n\n    iterations = 0;\n    while (true){\n        // compute portal direction and obtain next support point\n        dir= normalize(cross( s.c-s.b, s.d-s.b));\n        v4 =supportD(dir,v41,v42);\n\n        float dv1 = dot(s.a, dir);\n        float dv2 = dot(s.b, dir);\n        float dv3 = dot(s.c, dir);\n        float dv4 = dot(v4, dir);\n        bool portalReachTolerance=   (min(min(dv4 - dv1, dv4 - dv2),dv4 - dv3)  <= 1e-4);\n        \n        // reached tolerance -> find penetration info\n        if (portalReachTolerance|| iterations > MAX_ITER){\n            depth = PointTriDist2(vec3(0) ,s.b,s.c,s.d, dir);\n            depth = sqrt(depth);\n            if (depth==0.){\n                // If depth is zero, then we have a touching contact.\n                // So following findPenetrTouch(), we assign zero to\n                // the direction vector (it can actually be anything\n                // according to the decription of ccdMPRPenetration\n                // function).\n                dir=vec3(0);\n            }else{\n                dir=normalize(dir);\n            }\n\n            // barycentric coordinates:\n            vec3 p1,p2;\n            findPos(p1,p2,false);\n            pos=(p1+p2)*.5;\n\n            return;\n        }\n\n        //ExpandPortal(v4)\n        // b-c-d triangle must be rearranged to face outside Minkowski\n        // difference (direction from a).     \n        vec3 v4a =cross( v4,s.a);   \n        if (dot(s.b, v4a) > 0.) {\n            if(dot (s.c, v4a) > 0.) {s.b=v4;s1.b=v41;s2.b=v42;}\n            else  {s.d=v4;s1.d=v41;s2.d=v42;}\n        }\n        else{\n            if(dot(s.d, v4a) > 0.)  {s.c=v4;s1.c=v41;s2.c=v42;}\n            else {s.b=v4;s1.b=v41;s2.b=v42;}\n        } \n        iterations++;\n    }\n}\n\nint MPRPenetration(obj o1 , obj o2 , out float depth, out vec3 dir, out vec3 pos)\n{\n    \n    int res;\n    _ob1 =o1;\n    _ob2 =o2;\n    \n    // Phase 1: Portal discovery\n    res = discoverPortal(true);\n    if (res < 0){\n        // Origin isn't inside portal - no collision.\n        return -1;\n\n    }else if (res == 1){\n        // Touching contact on portal's b.\n            // Touching contact on portal's b - so depth is zero and direction\n            // is unimportant and pos can be guessed\n            depth = 0.;\n            dir= vec3(0); \n            pos=(s1.b+s2.b)*.5;\n            return 1;\n\n    }else if (res == 2){\n        // Origin lies on a-b segment.\n        // Depth is distance to b, direction also and position must be\n        // computed\n         pos=(s1.b+s2.b)*.5;\n         depth = length(s.b);\n         dir =normalize(s.b);\n         return 2;\n\n    }else if (res == 0){\n        // Phase 2: Portal refinement\n        res = refinePortal(true);\n        if (res < 0)  return -1;\n        // Phase 3. Penetration info\n        findPenetr(depth, dir, pos);\n        return res;\n    }\n\n    return 0;\n}\n\nint getDistanceGJK_light(obj o1 , obj o2 ,out vec3 v1,out vec3 v2)\n{\n\n    int res;\n    _ob1 =o1;\n    _ob2 =o2;\n    s2.b=s2.c=s2.d=s2.a=o2.c;\n    s1.b=s2.c=s1.d=s1.a=o1.c;\n    \n    s1.a=_ob1.c;s2.a=_ob2.c; s.a= s1.a-s2.a; \n     \n    if (s.a==vec3(0)) {s1.a+= vec3(1e-3,0,0); s.a+=vec3(1e-3,0,0);}\n     \n    // vertex b = support in direction of origin\n\tvec3 dir= -(s.a);  \n    s.b = supportD(dir,s1.b,s2.b);\n     \n     \n    // vertex c\n\tdir = cross(s.a, s.b);\t\t\t\t\t \t\t\t\t\t   \n    if (length(dir)==0.){\n        if (s.b == (_ob1.c-_ob2.c)) return 1; // origin lies on b\n        else return 2; // origin lies on a-b segment\n    }\n    \n\ts.c= supportD((dir),s1.c,s2.c);\n\n    float dm=1e5;\n    for (int  iter= 0; iter < MAX_ITER; ++iter) {\n         // vertex d direction\n         vec3 ABC= cross(s.b-s.a,s.c-s.a);\n         if(ABC==vec3(0.) ) return -1; \n         \n         dir= (ABC);\n         if (dot(dir, s.a) > 0.){\n            vec3 t =s.b; s.b=s.c;s.c=t; t =s1.b; s1.b=s1.c;s1.c=t; t =s2.b; s2.b=s2.c;s2.c=t;//swap\n            dir *=-1.;\n        }\n        s.d = supportD(dir,s1.d,s2.d);\n       \n        vec3  DO=  -s.d,\n              DB=  s.b-s.d,\n              DC=  s.c-s.d,\n              DA=  s.a-s.d,\n              DBC= cross(DB, DC),\n              DCA= cross(DC, DA),\n              DAB= cross(DA, DB);             \n       \n       if(DBC==vec3(0.) || DCA==vec3(0.) || DAB==vec3(0.)) break; ; \n        \n        bool\n            ad = dot(DBC, DO)* dot(DBC, DA)>=0.,\n            bd = dot(DCA, DO)* dot(DCA, DB)>=0.,\n            cd = dot(DAB, DO)* dot(DAB, DC)>=0.;\n              \n        if (!ad ) {s.a = s.d; s1.a=s1.d;s2.a=s2.d;}\n        else if ( !bd) {s.b = s.d; s1.b=s1.d;s2.b=s2.d;}\n        else if ( !cd  ) { s.c = s.d;s1.c=s1.d;s2.c=s2.d;}\n        else if(ad && bd && cd) return -iter; \n        \n        vec3 k =  PointTriDistK(vec3(0),s.a,s.b,s.c);   \n        v1=  (s1.a*k.x+s1.b*k.y+s1.c*k.z) ;\n        v2=  (s2.a*k.x+s2.b*k.y+s2.c*k.z) ;\n        float dt =length(v1-v2);\n        if(dm-dt<1e-6)  break;\n        else dm=dt;\n    }\n    \n    return res;\n}\n\nbool GJK_Intersect(obj o1, obj o2) {\n\n    _ob1 =o1;\n    _ob2 =o2;\n    s2.b=s2.c=s2.d=s2.a=o2.c;\n    s1.b=s2.c=s1.d=s1.a=o1.c;\n\t\t// Keep track of how many vertices of the simplex are known\t\t\n\t\tint n = 2;\n\n\t\t// Use some arbitrary initial direction\n\t\tvec3 d = vec3(1, 0, 0);\n\t\ts.b = supportD(d,s1.b, s2.b);\n\n\t\t// If no points are beyond the origin, the origin is outside the minkowski sum\n\t\t// No collision is possible\n\t\tif(dot(d,s.b) < 0.)  return false;\n\n\t\t// Get another point in the opposite direction of the first\n\t\td = -s.b;\n        s.a = supportD(d,s1.a, s2.a);\n\t\t\n\t\t// Same story as above\n\t\tif(dot(d,s.a) < 0.)\t return false;\n\n\t\t// Pick a direction perpendiclar to the line\n\t\tvec3 tmp = s.b-s.a;\n\t\tvec3 tmp2 = -s.a;\n\t\td = cross(tmp2,tmp);\n\n\t\t// We have two points, now we start iterating to get the simplex closer\n\t\t// and closer to the origin of the minkowski sum\n\t\t// Also we're dealing with floating point numbers and erros, so cap\n\t\t// the maximum number of iterations to deal with weird cases\n\t\tfor(int i = 0; i < MAX_ITER; ++i)\n\t\t{\n            vec3 a1,a2;\n\t\t\tvec3 a = supportD(d,a1,a2);\n\n\t\t\t// Dejavu\n\t\t\tif(dot(d,a) < 0.) return false;\n\n\t\t\t// We still only have a triangle\n\t\t\t// Our goal is to find another point to get a tetrahedron that might\n\t\t\t// enclose the origin\n\t\t\tif(n == 2)\n\t\t\t{\n\t\t\t\tvec3 aO = -a;\n\n\t\t\t\t// Edges we'll be testing and the triangle's normal\n\t\t\t\tvec3 ab = s.a-a;\n\t\t\t\tvec3 ac = s.b-a;\n\t\t\t\tvec3 abc = cross(ab,ac);\n\n\t\t\t\tvec3 abp = cross(ab,abc);\n\n\t\t\t\tif(dot(abp,aO) > 0.)\n\t\t\t\t{\n\t\t\t\t\t// Origin lies outside near edge ab\n\t\t\t\t\ts.b = s.a; s1.b=s1.a;s2.b=s2.a;\n\t\t\t\t\ts.a = a; s1.a=a1;s2.a=a2;\n\t\t\t\t\td = cross(cross(ab,aO),ab);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvec3 acp = cross(abc,ac);\n\n\t\t\t\tif(dot(acp,aO) > 0.)\n\t\t\t\t{\n\t\t\t\t\t// Origin lies outside near edge ac\n\t\t\t\t\ts.a = a; s1.a=a1;s2.a=a2;\n\t\t\t\t\td = cross(cross(ac,aO),ac);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// At this point the origin must be within the triangle\n\t\t\t\t// However we need to know if it is above or below\n\t\t\t\tif(dot(abc,aO) > 0.)\n\t\t\t\t{\n\t\t\t\t\t\n                    s.c = s.b; s1.c=s1.b;s2.c=s2.b;\n                    s.b = s.a; s1.b=s1.a;s2.b=s2.a;\n                    s.a = a; s1.a=a1;s2.a=a2;\n\t\t\t\t\td = abc;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n                    s.c = s.a; s1.c=s1.a;s2.c=s2.a;\n\t\t\t\t\ts.a = a; s1.a=a1;s2.a=a2;\n\t\t\t\t\td = -abc;\n\t\t\t\t}\n\n\t\t\t\t// We do however need a tetrahedron to eclose the origin\n\t\t\t\tn = 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// By now we do have a tetrahedron, start checking if it contains the origin\n\t\t\tvec3 aO = -a;\n\t\t\tvec3 ab = s.a- a;\n\t\t\tvec3 ac = s.b -a;\n\t\t\tvec3 ad = s.c- a;\n\n\t\t\tvec3 abc = cross(ab,ac);\n\t\t\tvec3 acd = cross(ac,ad);\n\t\t\tvec3 adb = cross(ad,ab);\n\n\n\n\t\t\t// Check if the point is inside the tetrahedron\n\t\t\tint ABC = 0x1;\n\t\t\tint ACD = 0x2;\n\t\t\tint ADB = 0x4;\n\t\t\tint tests =\n\t\t\t\t(dot(abc,aO) > 0. ? ABC : 0) |\n\t\t\t\t(dot(acd,aO) > 0. ? ACD : 0) |\n\t\t\t\t(dot(adb,aO) > 0. ? ADB : 0);\n\n\t\t\t// Behind all three faces, collision!\n\t\t\tif(tests == 0)\n\t\t\t\treturn true;\n\n\t\t\t// Behind one face\n\t\t\tif(tests == ABC)\n\t\t\t\t{ //ONEFACE\n                    if(dot(cross(abc,ac),aO) > 0.)\n                    {\n                        // In the region of AC\n                        s.a = a;s1.a=a1,s2.a=a2; \n                        d = cross(cross(ac,aO),ac);\n                        n = 2;\n                    }\n                    else  if(dot(cross(ab,abc),aO) > 0.) \n                    {   // In the region of AB  \n                        s.b= s.a; s1.b=s1.a;s2.b=s2.a; \n                        s.a = a;s1.a=a1,s2.a=a2; \n                        d = cross(cross(ab,aO),ab);  \n                        n = 2;\n                    } \n                    else \n                    {  // In the region of ABC\n                        s.c= s.b;s1.c=s1.b;s2.c=s2.b; \n                        s.b= s.a;s1.b=s1.a;s2.b=s2.a; \n                        s.a = a;s1.a=a1,s2.a=a2; \n                        d = abc; \n                    } \n                }\n\n\t\t\telse if(tests == ACD)\n\t\t\t{\n\t\t\t\t// Rotate ACD into ABC\n                s.a = s.b; s1.a=s1.b;s2.a=s2.b;\n                s.b = s.c; s1.b=s1.c;s2.b=s2.c;\n\n\t\t\t\tab = ac;\n\t\t\t\tac = ad;\n\t\t\t\tabc = acd;\n\n\t\t\t\t{ //ONEFACE\n                    if(dot(cross(abc,ac),aO) > 0.)\n                    {\n                        // In the region of AC\n                        s.a = a;s1.a=a1,s2.a=a2; \n                        d = cross(cross(ac,aO),ac);\n                        n = 2;\n                    }\n                    else  if(dot(cross(ab,abc),aO) > 0.) \n                    {   // In the region of AB  \n                        s.b= s.a; s1.b=s1.a;s2.b=s2.a; \n                        s.a = a;s1.a=a1,s2.a=a2; \n                        d = cross(cross(ab,aO),ab);  \n                        n = 2;\n                    } \n                    else \n                    {  // In the region of ABC\n                        s.c= s.b;s1.c=s1.b;s2.c=s2.b; \n                        s.b= s.a;s1.b=s1.a;s2.b=s2.a; \n                        s.a = a;s1.a=a1,s2.a=a2; \n                        d = abc; \n                    } \n                }\n\n\t\t\t}\n\n\t\t\telse if(tests == ADB)\n\t\t\t{\n\t\t\t\t// Rotate ADB into ABC\n                s.b = s.a; s1.b=s1.a;s2.b=s2.a;\n                s.a = s.c; s1.a=s1.c;s2.a=s2.c;\n\n\t\t\t\tac = ab;\n\t\t\t\tab = ad;\n\t\t\t\tabc = adb;\n\n\t\t\t\t{ //ONEFACE\n                    if(dot(cross(abc,ac),aO) > 0.)\n                    {\n                        // In the region of AC\n                        s.a = a;s1.a=a1,s2.a=a2; \n                        d = cross(cross(ac,aO),ac);\n                        n = 2;\n                    }\n                    else  if(dot(cross(ab,abc),aO) > 0.) \n                    {   // In the region of AB  \n                        s.b= s.a; s1.b=s1.a;s2.b=s2.a; \n                        s.a = a;s1.a=a1,s2.a=a2; \n                        d = cross(cross(ab,aO),ab);  \n                        n = 2;\n                    } \n                    else \n                    {  // In the region of ABC\n                        s.c= s.b;s1.c=s1.b;s2.c=s2.b; \n                        s.b= s.a;s1.b=s1.a;s2.b=s2.a; \n                        s.a = a;s1.a=a1,s2.a=a2; \n                        d = abc; \n                    } \n                }\n\t\t\t}\n\n\t\t\t// Behind two faces\n\t\t\telse if(tests == (ABC | ACD))\n\t\t\t\t{//TWOFACE\n\t\t\t\tif(dot(cross(abc,ac),aO) > 0.)\n\t\t\t\t{\n\t\t\t\t\t// Origin is beyond AC from ABCs view\n\t\t\t\t\t// Only need to test ACD\n\t\t\t\t\ts.a= s.b;s1.a=s1.b;s2.a=s2.b; \n\t\t\t\t\ts.b= s.c;s1.b=s1.c;s2.b=s2.c; \n\n\t\t\t\t\tab = ac;\n\t\t\t\t\tac = ad;\n\t\t\t\t\tabc = acd;\n\n\t\t\t\t\t{ //ONEFACE\n                    if(dot(cross(abc,ac),aO) > 0.)\n                        {\n                            // In the region of AC\n                            s.a = a;s1.a=a1,s2.a=a2; \n                            d = cross(cross(ac,aO),ac);\n                            n = 2;\n                        }\n                        else  if(dot(cross(ab,abc),aO) > 0.) \n                        {   // In the region of AB  \n                            s.b= s.a; s1.b=s1.a;s2.b=s2.a; \n                            s.a = a;s1.a=a1,s2.a=a2; \n                            d = cross(cross(ab,aO),ab);  \n                            n = 2;\n                        } \n                        else \n                        {  // In the region of ABC\n                            s.c= s.b;s1.c=s1.b;s2.c=s2.b; \n                            s.b= s.a;s1.b=s1.a;s2.b=s2.a; \n                            s.a = a;s1.a=a1,s2.a=a2; \n                            d = abc; \n                        } \n                    }\n\t\t\t\t}\n\n\t\t\t\t// At this point we're over ABC or over AB\n\t\t\t\t// Revert back to a single face\n\t\t\t\telse if(dot(cross(abc,ac),aO) > 0.)\n\t\t\t\t{\n\t\t\t\t\t// In the region of AC\n\t\t\t\t\ts.a = a;s1.a=a1,s2.a=a2; \n\t\t\t\t\td = cross(cross(ac,aO),ac);\n\t\t\t\t\tn = 2;\n\t\t\t\t}\n\t\t\t\telse   if(dot(cross(ab,abc),aO) > 0.) \n\t\t\t\t{   // In the region of AB  \n\t\t\t\t\ts.b= s.a;s1.b=s1.a;s2.b=s2.a; \n\t\t\t\t\ts.a = a;s1.a=a1,s2.a=a2; \n\t\t\t\t\td = cross(cross(ab,aO),ab);  \n\t\t\t\t\tn = 2;\n\t\t\t\t} \n\t\t\t}\n\n\t\t\telse if(tests == (ACD | ADB))\n\t\t\t{\n\t\t\t\t// Rotate ACD, ADB into ABC, ACD\n\t\t\t\tvec3 tmp = s.a,t1=s1.a, t2=s2.a;\n\t\t\t\ts.a = s.b; s1.a=s1.b;s2.a=s2.b;\n                s.b = s.c; s1.b=s1.c;s2.b=s2.c;\n                s.c = tmp; s1.c=t1;s2.c=t2;\n\t\t\t\t\n\n\t\t\t\ttmp = ab;\n\t\t\t\tab = ac;\n\t\t\t\tac = ad;\n\t\t\t\tad = tmp;\n\n\t\t\t\tabc = acd;\n\t\t\t\tacd = adb;\n\n\t\t\t\t{//TWOFACE\n\t\t\t\tif(dot(cross(abc,ac),aO) > 0.)\n\t\t\t\t{\n\t\t\t\t\t// Origin is beyond AC from ABCs view\n\t\t\t\t\t// Only need to test ACD\n\t\t\t\t\ts.a= s.b;s1.a=s1.b;s2.a=s2.b; \n\t\t\t\t\ts.b= s.c;s1.b=s1.c;s2.b=s2.c; \n\n\t\t\t\t\tab = ac;\n\t\t\t\t\tac = ad;\n\t\t\t\t\tabc = acd;\n\n\t\t\t\t\t{ //ONEFACE\n                    if(dot(cross(abc,ac),aO) > 0.)\n                        {\n                            // In the region of AC\n                            s.a = a;s1.a=a1,s2.a=a2; \n                            d = cross(cross(ac,aO),ac);\n                            n = 2;\n                        }\n                        else  if(dot(cross(ab,abc),aO) > 0.) \n                        {   // In the region of AB  \n                            s.b= s.a; s1.b=s1.a;s2.b=s2.a; \n                            s.a = a;s1.a=a1,s2.a=a2; \n                            d = cross(cross(ab,aO),ab);  \n                            n = 2;\n                        } \n                        else \n                        {  // In the region of ABC\n                            s.c= s.b;s1.c=s1.b;s2.c=s2.b; \n                            s.b= s.a;s1.b=s1.a;s2.b=s2.a; \n                            s.a = a;s1.a=a1,s2.a=a2; \n                            d = abc; \n                        } \n                    }\n\t\t\t\t}\n\n\t\t\t\t// At this point we're over ABC or over AB\n\t\t\t\t// Revert back to a single face\n\t\t\t\telse if(dot(cross(abc,ac),aO) > 0.)\n\t\t\t\t{\n\t\t\t\t\t// In the region of AC\n\t\t\t\t\ts.a = a;s1.a=a1,s2.a=a2; \n\t\t\t\t\td = cross(cross(ac,aO),ac);\n\t\t\t\t\tn = 2;\n\t\t\t\t}\n\t\t\t\telse   if(dot(cross(ab,abc),aO) > 0.) \n\t\t\t\t{   // In the region of AB  \n\t\t\t\t\ts.b= s.a;s1.b=s1.a;s2.b=s2.a; \n\t\t\t\t\ts.a = a;s1.a=a1,s2.a=a2; \n\t\t\t\t\td = cross(cross(ab,aO),ab);  \n\t\t\t\t\tn = 2;\n\t\t\t\t} \n\t\t\t}\n\t\t\t}\n\n\t\t\telse if(tests == (ADB | ABC))\n\t\t\t{\n\t\t\t\t// Rotate ADB, ABC into ABC, ACD\n                vec3 tmp = s.b, t1=s1.b, t2=s2.b;\n\t\t\t\ts.b = s.a; s1.b=s1.a;s2.b=s2.a;\n                s.a = s.c; s1.a=s1.c;s2.a=s2.c;\n                s.c = tmp; s1.c=t1;s2.c=t2;\n\n\n\t\t\t\ttmp = ac;\n\t\t\t\tac = ab;\n\t\t\t\tab = ad;\n\t\t\t\tad = tmp;\n\n\t\t\t\tacd = abc;\n\t\t\t\tabc = adb;\n\n\t\t\t\t{//TWOFACE\n\t\t\t\tif(dot(cross(abc,ac),aO) > 0.)\n\t\t\t\t{\n\t\t\t\t\t// Origin is beyond AC from ABCs view\n\t\t\t\t\t// Only need to test ACD\n\t\t\t\t\ts.a= s.b;s1.a=s1.b;s2.a=s2.b; \n\t\t\t\t\ts.b= s.c;s1.b=s1.c;s2.b=s2.c; \n\n\t\t\t\t\tab = ac;\n\t\t\t\t\tac = ad;\n\t\t\t\t\tabc = acd;\n\n\t\t\t\t\t{ //ONEFACE\n                    if(dot(cross(abc,ac),aO) > 0.)\n                        {\n                            // In the region of AC\n                            s.a = a;s1.a=a1,s2.a=a2; \n                            d = cross(cross(ac,aO),ac);\n                            n = 2;\n                        }\n                        else  if(dot(cross(ab,abc),aO) > 0.) \n                        {   // In the region of AB  \n                            s.b= s.a; s1.b=s1.a;s2.b=s2.a; \n                            s.a = a;s1.a=a1,s2.a=a2; \n                            d = cross(cross(ab,aO),ab);  \n                            n = 2;\n                        } \n                        else \n                        {  // In the region of ABC\n                            s.c= s.b;s1.c=s1.b;s2.c=s2.b; \n                            s.b= s.a;s1.b=s1.a;s2.b=s2.a; \n                            s.a = a;s1.a=a1,s2.a=a2; \n                            d = abc; \n                        } \n                    }\n\t\t\t\t}\n\n\t\t\t\t// At this point we're over ABC or over AB\n\t\t\t\t// Revert back to a single face\n\t\t\t\telse if(dot(cross(abc,ac),aO) > 0.)\n\t\t\t\t{\n\t\t\t\t\t// In the region of AC\n\t\t\t\t\ts.a = a;s1.a=a1,s2.a=a2; \n\t\t\t\t\td = cross(cross(ac,aO),ac);\n\t\t\t\t\tn = 2;\n\t\t\t\t}\n\t\t\t\telse   if(dot(cross(ab,abc),aO) > 0.) \n\t\t\t\t{   // In the region of AB  \n\t\t\t\t\ts.b= s.a;s1.b=s1.a;s2.b=s2.a; \n\t\t\t\t\ts.a = a;s1.a=a1,s2.a=a2; \n\t\t\t\t\td = cross(cross(ab,aO),ab);  \n\t\t\t\t\tn = 2;\n\t\t\t\t} \n\t\t\t}\n\t\t\t}\n\n\t\t\t//  this shouldn't happen\n\t\t\telse return true;\n\t\t}\n\n\t\t// Out of iterations, \n\t\treturn true;\n\t}\n*/\n\n","name":"Common","description":"","type":"common"}]}