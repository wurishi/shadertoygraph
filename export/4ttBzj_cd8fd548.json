{"ver":"0.1","info":{"id":"4ttBzj","date":"1542973714","viewed":559,"name":"3D Metashapes","username":"tholzer","description":"Simple metallic metaball-style effect using raymarching with polynomial blending between shape primitives.\nThis fork uses different kind of shapes (ball, roundedCube, torus).\nEnable SYMMETRY for symmetric shapes.","likes":11,"published":1,"flags":64,"usePreview":0,"tags":["3d","raymarching","reflection","metaballs","blob","shapes","colorize","metashapes","metallic","contouraa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"MlXXWB","filepath":"https://soundcloud.com/virgill/4klang-eisenerz","previewfilepath":"https://soundcloud.com/virgill/4klang-eisenerz","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//---------------------------------------------------------\n// Shader:   3dMetaShapes.glsl    \n//\n//   v1.0  2018-11-23  initial release\n//   v1.1  2018-12-13  changing rot(...)\n//\n// Simple metallic metaball-style effect using raymarching \n// with polynomial blending between shape primitives.\n//\n// refs: https://www.shadertoy.com/view/Xtfyzr by Lazzux\n//       https://www.shadertoy.com/view/ldSGWR by jaburns\n// \n// tags: 3d, metashapes, metaballs, blob, raymarching, \n//       reflection, colorize, shapes, metallic, contourAA\n//\n//---------------------------------------------------------\n\n#define xSYMMETRY\n\nconst   int MAX_ITER = 64;      // max. iterations\nconst float MAX_DIST = 30.0;    // max. march distance\nconst float EPSILON = 0.1;      // precision\n\nconst float PI = 3.14159265359;\n\nvec3 rot (vec3 p, float x, float y, float z)\n{\t\n  vec3 a = normalize (vec3 (sin(2.0+x),sin(2.0+y),sin(2.0+z)));\n  float s = sin (iTime);\n  float c = cos (iTime);\n  float oc = 1.0 - c;\n/*\n  mat4 m = mat4 (oc*a.x*a.x + c,      oc*a.x*a.y - a.z*s,  oc*a.z*a.x + a.y*s,  0.0,\n                 oc*a.x*a.y + a.z*s,  oc*a.y*a.y + c,      oc*a.y*a.z - a.x*s,  0.0,\n                 oc*a.z*a.x - a.y*s,  oc*a.y*a.z + a.x*s,  oc*a.z*a.z + c,      0.0,\n                 0.0,                 0.0,                 0.0,                 1.0);\n  return (m*vec4(p,0.0)).xyz;\n*/\n  return p * mat3 (oc*a.x*a.x + c,      oc*a.x*a.y - a.z*s,  oc*a.z*a.x + a.y*s,  \n                   oc*a.x*a.y + a.z*s,  oc*a.y*a.y + c,      oc*a.y*a.z - a.x*s,  \n                   oc*a.z*a.x - a.y*s,  oc*a.y*a.z + a.x*s,  oc*a.z*a.z + c    );\n    \n}\n\n//-----------------------------------------------------------------------------\n// primitives:       x,y,z: center position\n// shader:  https://www.shadertoy.com/view/Xds3zN\n// info: https://iquilezles.org/articles/distfunctions\n//-----------------------------------------------------------------------------\n\nfloat ball (vec3 pos, float x, float y, float z) \n{\n#ifdef SYMMETRY\n  pos.x = abs(pos.x);\n#endif    \n  return length(pos - vec3(x,y,z))-1.4;\n}\n\nfloat rCube (vec3 pos, float x, float y, float z)   // rounded cube\n{\n  const float BOX_SIZE = 0.7;\n  const float BOX_EDGE = 0.2;\n#ifdef SYMMETRY\n  pos.x = abs(pos.x);\n#endif    \n  return length(max(abs(rot(pos - vec3(x,y,z),x,y,z))-vec3(BOX_SIZE),0.0))-BOX_EDGE;\n}\n\nfloat torus(vec3 pos, float x, float y, float z)\n{\n  const float TORUS_RADIUS = 2.0;\n  const float TORUS_DIM = 0.4;\n#ifdef SYMMETRY\n  pos.x = abs(pos.x);\n#endif    \n  pos = rot(pos - vec3(x,y,z),x,y,z);\n  return length(vec2(length(pos.xz)-TORUS_RADIUS,pos.y))-TORUS_DIM;   \n}\n\n//--- shapes ---\n\nfloat ballA (vec3 p) {return ball  (p, 3.3*sin(0.8*iTime), 0.5, 0.0); }\n\nfloat cubeA (vec3 p) {return rCube (p, 3.3*sin(0.8*iTime), 0.5, 0.0); }\n\nfloat ballB (vec3 p) {return ball  (p, 0.5, 2.4*sin (0.2*iTime), 3.0*cos (1.1*iTime)); }\n\nfloat cubeB (vec3 p) {return rCube (p, 0.5, 2.4*sin (0.2*iTime), 3.0*cos (1.1*iTime)); }\n\nfloat ballC (vec3 p) {return ball  (p, 0.9+ 0.2*sin(0.6*iTime), 3.0*cos (iTime), 0.3); } \n\nfloat ballD (vec3 p) {return ball  (p, 2.4*cos (0.3*iTime), 1.5*sin (2.0*iTime), -0.2); }\n\nfloat torusA(vec3 p) {return torus (p, 2.4*cos (0.1*iTime), 4.5*sin (0.2*iTime), -0.2); }\n\n//-- merging ---\n\nfloat blend (float a, float b) \n{\n\tconst float k = 0.8;    // fusion factor\n    float h = clamp (0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\n\nfloat distanceFunction (vec3 p) \n{\n  float       bf= cubeA(p);\n  bf = blend (bf, cubeB(p));\n  bf = blend (bf, ballC(p));\n  bf = blend (bf, ballD(p));\n  bf = blend (bf, torusA(p));\n  return bf;\n}\n\t\nvec3 colorFunction (vec3 p) \n{\n\tconst vec3 colorA = vec3(0.6, 0.3, 0.1);\n\tconst vec3 colorB = vec3(0.4, 0.6, 0.6);\n\tconst vec3 colorC = vec3(0.1, 0.8, 0.1);\n\tconst vec3 colorD = vec3(0.2, 0.2, 1.0);\n\tconst vec3 colorE = vec3(1.2, 1.2, 1.0);\n\treturn max(0.0,2.0 -ballA(p))*colorA*0.5\n\t\t + max(0.0,2.0 -ballB(p))*colorB*0.5\n\t\t + max(0.0,2.0 -ballC(p))*colorC*0.5\n\t\t + max(0.0,2.0 -ballD(p))*colorD*0.5;\n\t\t + max(0.0,2.0-torusA(p))*colorE*0.5;\n}\n\nvec3 background (vec3 dir)\n{\n\treturn 0.5*texture (iChannel0, dir).xyz;\n}\n\nfloat rayMarching (vec3 ro, vec3 rd, out vec3 pos)\n{\n\tfloat totalDist = 0.0;\n\tpos = ro;\n\tfloat dist = EPSILON;\n\t\n\tfor (int i = 0; i < MAX_ITER; i++) {\n\t\tif (dist < EPSILON || totalDist > MAX_DIST) break;\n\t\tdist = distanceFunction(pos);\n\t\ttotalDist += dist*0.98;\n\t\tpos = ro + totalDist * rd;\n\t}\t\t\n\treturn dist;\n}\n\n//--- calculate surface normal ---\nvec3 calcNormal (in vec3 pos)\n{\n\tconst vec3 eps = vec3 (0.0001, 0, 0);\n    float d = distanceFunction(pos);\n    return normalize( \n      vec3 (distanceFunction(pos+eps.xyy) - d,\n\t        distanceFunction(pos+eps.yxy) - d,\n\t        distanceFunction(pos+eps.yyx) - d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // screen position\n  vec2 screenPos = 2.0 * fragCoord.xy / iResolution.xy -1.0;\n  screenPos.x *= iResolution.x / iResolution.y;\n  vec2 mPos = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n\n  // camera\n  vec3 cameraOrigin = vec3 (0.0);\n  if (iMouse.x < 33.)    // return to auto rotate ?\n  {\n    float rotAngle = iTime*0.1;\n    float vAngle = 0.5;\n    if (iMouse.x > 11.) vAngle *= 5.0 * mPos.y;\n    cameraOrigin = vec3(5.0*sin(rotAngle), vAngle, 5.0*cos(rotAngle));\n  }\n  else cameraOrigin = vec3(5.0*sin(PI*mPos.x), 5.0*mPos.y, 5.0*cos(PI*mPos.x));\n\t\n  const vec3 cameraTarget = vec3(0.0,  0.5, 0.0);\n  const vec3 upDirection  = vec3(0.0, -1.0, 0.0);\n  vec3 cameraDir   = normalize(cameraTarget - cameraOrigin);\t\n  vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n  vec3 cameraUp    = cross(cameraDir, cameraRight);\n  \n  vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\t\n  vec3 color = background (rayDir);\n  vec3 pos;\n  float dist = rayMarching (cameraOrigin, rayDir, pos);\n  if (dist < EPSILON)\n  {\t\t\n    vec3 normal = calcNormal(pos);  \n    vec3 newDir = reflect (rayDir, normal);\n    vec3 pos2;\n    dist = rayMarching (pos+0.01*newDir, newDir, pos2);\n\t\t\n    vec3 backColor = color; \n    color = 3.*background (newDir) * colorFunction (pos);\n\t\t\n    float AA = 2.0*(dot (normal, -rayDir)); \n    color *= AA;\n\n    // contour antialiasing without multisampling !\n    const float aaLimit = 0.2;\n    if (AA < aaLimit)\n    {\n  //  if (iMouse.z > 0.0) backColor = vec3(1,0,0); // debug AA background pixels are red\n      color = mix (backColor, color, clamp (AA / aaLimit, 0.0, 1.0));\n    }\n  }\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}