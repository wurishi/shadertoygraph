{"ver":"0.1","info":{"id":"cttGRM","date":"1682126990","viewed":75,"name":"mouse goes over what?","username":"valalalalala","description":"Stores information about what the mouse was over in the frame in pixel (0,0). The color of the background will match the shade of the ball the mouse is over. Mouse button must be down to work ","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["mouse","pack","unpack","mouseover"],"hasliked":0,"parentid":"ctBXzm","parentname":"Grundschattierer"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        //////////////////////////////////////////////////////////////////////\n       //                                                                 ////\n      //  \"mouse goes over what?\"                                        // //\n     //                                                                 //  //\n    //  Working towards getting \"mouseOver\" information from a shader  //   // \n   //  back up to the js driver. This demo stores the type/id of any  //    //\n  // object under the mouse (when button is down)                    //    //\n //                                                                 //    //\n/////////////////////////////////////////////////////////////////////    //\n//                                                                 //   //\n// Creative Commons Attribution-NonCommercial-ShareAlike           //  //\n// 3.0 Unported License                                            // //                                                                 // // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2023                               ////\n//                                                                 ///\n/////////////////////////////////////////////////////////////////////\n\n// all the action is in BufferA\n\nvoid mainImage( out vec4 result, in vec2 st ){    \n    result = texelFetch(iChannel0, ivec2(st), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////\n\nconst float TAU = 99733. / 15873., ZED = .0, HALB = .5, EINS = 1., PI  = HALB * TAU;\nconst vec3 V101 = vec3( -EINS, ZED, +EINS );\nconst float EPSILON = .001, ZFAR = 199., VIEW_DISTANCE = 5.5;\n\n////////////////////////////////////////////////////////////////////////////////////\n\n#define iMinnie   vec2 ms = minnie( iMouse, iResolution.xy, iTime * .0220 )\n#define iuv       vec2 uv = pixelToUv( st, iResolution.xy );\n\n#define cost( x ) triangle( x )\n#define sint( x ) triangle( x + TAU * .25 )\n#define SCALE_AND_OFFSET(v,o)   (o + v * o) \n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) / resolution.y;\n}\n\nfloat modScale( float f, float s ) {\n    return mod( f, s ) / s;\n}\n\nfloat triangle( float x ) {\n    return 4. * abs( modScale( x, TAU ) - .5 ) -1.;\n}\n\nvec3 colorF( float f ) {\n    return vec3( f, SCALE_AND_OFFSET( vec2( cost( f ), sint( f )  ), .5 ) );\n}\n\nvec2 trig( float angle ) {\n    return vec2( cost( angle ), sint( angle ) );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Ray { \n    vec3 eye; \n    vec3 dir; \n};\n\nvec2 minnie( in vec4 mouse, in vec2 rez, in float time ) {\n    return mix(\n        abs( trig( time * 10. ) ),\n        mouse.xy / rez,\n        step( 3e3 + EPSILON, max( mouse.z, mouse.w ) )\n    );\n}\n\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nRay makeRay( in vec2 uv, in vec2 ms, float depth ) {\n    vec2 t = trig( ms.x * PI );\n    vec3 eye = depth * vec3( t.y, sin( ms.y * 1.88 ), t.x );    \n    vec3 dir = normalize( makeCamera( eye, V101.yyy, ZED ) * vec3( uv, EINS ) - eye );\n    return Ray( eye, dir );\n}\n\nRay makeRay( in vec2 uv, in vec2 ms ) {\n    return makeRay( uv, ms, VIEW_DISTANCE );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Hit {\n    float type;\n    float depth;\n};\n\nvoid mino( inout Hit m, in Hit q ) {\n    if ( q.depth < m.depth ) m = q;\n}\n\nHit map( vec3 p ) {\n    float d = .525;\n    float r = .252;\n    float id = EINS;\n    Hit h1 = Hit( id++, length( p + d * V101.xyz ) - r );\n    Hit h2 = Hit( id++, length( p + d * V101.zyz ) - r );\n    Hit h3 = Hit( id++, length( p + d * V101.xyx ) - r );\n    Hit h4 = Hit( id++, length( p + d * V101.zyx ) - r );\n    mino( h1, h2 );\n    mino( h1, h3 );\n    mino( h1, h4 );    \n    return h1;\n}\n\nHit march( vec3 eye, vec3 direction ) {\n    Hit h;\n    for (float i=.0,dd=.0,m=.0;i<77.;i++,dd+=m,eye+=m*direction) {\n        h = map(eye);\n        m = h.depth;\n        if(abs(m)<.001) {\n            h.depth = dd;\n            return h;\n        }\n    }\n    h.type = ZED;\n    return h;\n}\n\n\nfloat abbyNormal( in Hit h, in Ray rae ) {\n    vec3 p = rae.eye + rae.dir * h.depth;\n    float dp = abs( map( p ).depth );\n    float dq = abs( map( p + EPSILON ).depth );\n    float a = max( dp, dq );\n    float b = dp + dq - a;\n    return ( a - b ) / a;\n}\n\n/////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////////////////////////\n// pack/unpack from IQ: https://www.shadertoy.com/view/ldj3zG\n\nconst vec4 bitShL = vec4(16777216., 65536., 256., 1.);\nconst vec4 bitShR = 1./bitShL;\n\nvec4 pack_F1_UB4( in float value ){\n    vec4 res = fract( value*bitShL );\n\tres.yzw -= res.xyz/256.;\n\treturn res;\n}\nfloat unpack_F1_UB4( in vec4 value ) { \n    return dot( value, bitShR );\n}\n#define ftoV4( v ) pack_F1_UB4( v )\n#define v4toF( v ) unpack_F1_UB4( v )\n\n// vec3 version\nvec3 pack_F1_UB3( in float value ){\n    vec3 res = fract( value*bitShL.yzw );\n\tres.xyz -= res.xyz/256.0;\n\treturn res;\n}\nfloat unpack_F1_UB3( in vec3 value ) { \n    return dot( value, bitShR.yzw );\n}\n#define fToV3( v ) pack_F1_UB3( v )\n#define v3ToF( v ) unpack_F1_UB3( v )\n\n// more from iY0Yi: https://www.shadertoy.com/view/Ws3cRS \n\n\n/////////////////////////////////////////////////////////////////////\n// small ray marching for the main use case\n\nvec3 demo( in vec2 st, bool packIt ) {\n    iMinnie; iuv;\n    \n    Ray rae = makeRay( uv, ms );\n    Hit h = march( rae.eye, rae.dir );\n\n    const float SCALE = 5.; // <-- be sure to \"normalize\" it, but leave some room\n    if ( packIt ) {\n        return fToV3( h.type / SCALE );\n    }\n    \n    float shade = abbyNormal( h, rae ) + .11;\n\n    if ( EPSILON > h.type ) {\n        shade = .33;\n        vec4 ms = texelFetch( iChannel0, ivec2(0), 0 );\n        h.type = v3ToF( ms.xyz ) * SCALE;\n    }\n    \n    return colorF( h.type * 1.7 ) * shade;\n}\n\nvoid mainImage( out vec4 result, in vec2 st ) {\n    bool storeMouse = 0 == int( st.x ) + int( st.y );\n    vec2 px = storeMouse ? iMouse.xy : st;\n    result = vec4( demo( px, storeMouse ), EINS );\n}","name":"Buffer A","description":"","type":"buffer"}]}