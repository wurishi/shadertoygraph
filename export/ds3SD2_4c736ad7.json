{"ver":"0.1","info":{"id":"ds3SD2","date":"1680438143","viewed":173,"name":"Reflections with a ray marcher","username":"MrHAX00","description":"Wanted to see if I could make a somewhat realistic lighting system with ray marching.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lighting","spheres","raymarcher","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"RayResult March(Ray Ray)\n{\n\n    float Marched = 0.;\n    Material CurrentMaterial;\n    vec3 Normal = vec3(0.);\n    \n    for (int i = 0; i < MaxIteration; ++i) {\n        float Distance = MaxDistance;\n        \n        for (i = 0; i < nSphere; i++) {\n            Sphere Current = Spheres[i];\n            vec3 Delta = Ray.Origin  + Ray.Direction * Marched - Current.Position;\n            float CurrentDistance = length(Delta) - Current.Radius;\n            Distance = min(\n                Distance,\n                CurrentDistance\n            );\n            \n            if (Distance == CurrentDistance) {\n                CurrentMaterial = Current.Material;\n                Normal = normalize(Delta);\n            }\n        }\n        \n        Marched += Distance;\n        if (Marched >= MaxDistance) {\n            CurrentMaterial = Material(\n                vec3(1.),\n                0.\n            );\n            break;\n        } else if (Distance <= MinDistance) {\n            break;\n        }\n    }\n    return RayResult(\n        Ray.Origin + Ray.Direction * Marched,\n        Normal,\n        CurrentMaterial\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    // Time varying pixel color\n    Ray CurrentRay = Ray(\n        vec3(0.),\n        normalize(vec3(uv, 1.))\n    );\n    \n    vec3 Color = vec3(1.);\n    vec3 Brightness = vec3(0.);\n    for (int i = -1; i < Bounces; i++) {\n        RayResult Result = March(CurrentRay);\n        vec3 Normal = CurrentRay.Direction - 2. * dot(CurrentRay.Direction, Result.Normal) * Result.Normal;\n        CurrentRay = Ray(\n            Result.Hit + Normal * MinDistance * 3.,\n            Normal\n        );\n        \n        vec3 ResultColor = Result.Material.Color;\n        Brightness += ResultColor * Result.Material.Emission;\n        Color *= ResultColor;\n        \n        if (length(Result.Hit) > MaxDistance) {\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(Color * Brightness,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MaxIteration 30\n#define MaxDistance 100.\n#define MinDistance .001\n#define Bounces 10\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n\nstruct Material\n{\n    vec3 Color;\n    float Emission;\n};\n\nstruct RayResult\n{\n    vec3 Hit;\n    vec3 Normal;\n    Material Material;\n};\n\nstruct Sphere\n{\n    vec3 Position;\n    float Radius;\n    Material Material;\n};\n\n#define nSphere 5\nconst Sphere[nSphere] Spheres = Sphere[nSphere](\n    Sphere(\n        vec3(0., 0., 5.),\n        1.,\n        Material(\n            vec3(.2, .4, 1.),\n            0.\n        )\n    ),\n    Sphere(\n        vec3(0., -20., 5.),\n        19.,\n        Material(\n            vec3(1., .4, .2),\n            0.\n        )\n    ),\n    Sphere(\n        vec3(20., 30., 50.),\n        50.,\n        Material(\n            vec3(1., 1., 1.),\n            .6\n        )\n    ),\n    Sphere(\n        vec3(-10., 10., -50.),\n        50.,\n        Material(\n            vec3(1., 1., 1.),\n            .6\n        )\n    ),\n    Sphere(\n        vec3(-80., 0., 15.),\n        50.,\n        Material(\n            vec3(.7, .4, 1.),\n            1.\n        )\n    )\n);","name":"Common","description":"","type":"common"}]}