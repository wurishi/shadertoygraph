{"ver":"0.1","info":{"id":"DtycRm","date":"1700024445","viewed":131,"name":"Stars and neitrino star","username":"nayk","description":"star galaxy colorful","likes":6,"published":1,"flags":1,"usePreview":0,"tags":["stargalaxycolorful"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* originals https://www.shadertoy.com/view/ldBXDD  https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/clyyRw https://www.shadertoy.com/view/ctKyRD */\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define TAU 6.28318530718\nconst vec4 colmod = vec4(0.0, 0.3, 1.0, 0.0);\nconst float freq = 3.0;\nconst int N = 10;\n\nmat2 scale(vec2 scl, float stretch) {\n    vec2 _scl = (vec2(1.0) / scl);\n\n    return mat2(\n        _scl.x, stretch,\n        stretch, _scl.y\n    \n    );\n}\n\nmat2 rotate(float angle) {\n    return mat2(\n        cos(angle),-sin(angle),\n        sin(angle),cos(angle)\n    );\n}\n#define Bright .05         // brightness\n#define Fog    .03         // fog thickness\n#define\tRSize  .3          // size of ray marching steps\n#define\tRStep  24. / RSize // # of ray steps\n\n#define res iResolution.xy\n\nfloat map(in vec3 p) {\n\n    // rotation\n    vec2 a = iTime/res.yx;\n    float s, c;\n    p.yz = mat2(c=cos(a.y), s=-sin(a.y), -s, c) * p.yz;\n    p.xz = mat2(c=cos(a.x), s=-sin(a.x), -s, c) * p.xz;\n\n    // mirrored inversion\n    float k = length(p) < 1. ? dot(p, p) : 1.;\n    \n    // invert coords\n    p /= k * .77;\n    \n    // repeat coords\n    p = mod(p+iTime*vec3(.1, .2, .3), 2.) - 1.;\n    \n    // x, y, & z bars\n    return\n        min(\n            min(\n                length(p.xy),\n                length(p.xz)\n            ),\n            length(p.yz)\n        ) * k;\n}\n\nvec3 march(vec3 ray, vec3 dir) {\n\n\t// initial color = sky\n    vec3 c = vec3(.1, 0., .7);\n    \n    // initial alpha value\n    float a = 1.;\n    \n    // march\n    for(float i=0.; i<RStep; i++) {\t\n    \n        // distance estimate at ray position\n\t\tfloat d = map(ray) * RSize;\n        \n        // advance ray\n        ray += d * dir;\n        \n        // mix glowing lines with col\n        c = mix(vec3(3., 2.5, 1.), c, a);\n        \n        // substract from alpha\n        a -= Bright / (d+Fog) / pow(RStep, 2.);\n        \n        // escape when alpha falls below a certain value\n        if(a<.9) break;\n\t}\n    \n    return c;\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.01,fade=0.51;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*0.13;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.003),sin(iTime*0.003),-sin(iTime*0.003),cos(iTime*0.003));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\t //dark matter\n\t\ta*=a*a; // add contrast\n\t\t\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s,s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.005);\n\tfloat time=iTime*speed+.25;\n\n\t vec4 color = vec4(0.0);\n    vec2 ratio = vec2(iResolution.x / iResolution.y, 1.0);\nvec4 fo = fragColor;\nvec2  fc= fragCoord;\n  \n    \n    vec3 rayBeg\t= vec3(0., 0., -4.);\n    vec3 rayDir\t= normalize(vec3(uv, 2.));\n    \n    fo = vec4(march(rayBeg, rayDir), 1.);\n    uv *= ratio; uv += 0.5;\n     \tvec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // distance of current pixel from center\n\tfloat cLength = length(cPos);\n\n\tdir.xy = fragCoord.xy/iResolution.xy+(cPos/cLength)*cos(cLength*5.0-iTime*1.0) * 0.03;\n\t\n    \n \n    // Small spheres\n    vec2 translate, uv2; float fi;\n    \n    for ( int i = 1; i <= N; i++ ) {\n        fi = float(i);\n        \n        float x = step(0.0, fi);\n    \n        translate = vec2(\n            cos(iTime + fi) * fi,\n            sin(iTime + fi)\n        );\n        \n        uv2 = uv + translate * 0.1;\n        color += 0.01/distance(uv2, vec2(0.5)) * fi / 4.0;\n    }\n    \n      \n    // Central glow\n    color += 0.01/distance(uv, vec2(0.5)) * 12.0;\n    \n    \n    // Jets\n    float f = sin(iTime * freq);\n    \n    uv -= 0.5;\n    uv *= rotate( TAU + (f / 5.0) );\n    uv *= scale( vec2(1.1), 1.05 + (f / 15.0));\n    uv += 0.5;\n    \n    float jd = distance(uv, vec2(0.5));\n    color += 0.01/jd * 2.0;\n    \n    \n    \n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n    fragColor*=vec4(color+fo);\n}","name":"Image","description":"","type":"image"}]}