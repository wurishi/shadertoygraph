{"ver":"0.1","info":{"id":"4tjXzc","date":"1445517467","viewed":327,"name":"Derp Test","username":"bit2shift","description":"Click'n'Drag to reset camera.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","noisy","scrubmotionblur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor /= fragColor.a;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int STEPS = 512;\nconst int REFLECTIONS = 2;\nconst float FOV = 120.0;\nconst float SPREAD_MARCH = 0.005;\nconst float SPREAD_LIGHT = 0.005;\n\n////////////////////////////////////////////////////////////////\n// Primitive definitions\n////////////////////////////////////////////////////////////////\n\nfloat cube(vec3 p, float s)\n{\n    vec3 d = (abs(p) - s);\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return (length(p) - s);\n}\n\n////////////////////////////////////////////////////////////////\n// Primitive instances\n////////////////////////////////////////////////////////////////\n\nconst int ID_BACKGROUND = 109;\nconst int ID_OBJECT_A = 123;\n\nstruct object\n{\n    float dist;\n    int id;\n};\n\nobject closest(object a, object b)\n{\n    if(a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\nobject background(vec3 p)\n{\n    return object(-cube(p, 20.0), ID_BACKGROUND);\n}\n\nobject obj_a(vec3 p)\n{\n    const float c = 10.0;\n    return object(sphere(mod(p, c) - 0.5 * c, 2.0), ID_OBJECT_A);\n}\n\nobject scene(vec3 p)\n{\n    return closest(background(p), obj_a(p));\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat map(vec3 p)\n{\n    return scene(p).dist;\n}\n\nfloat diff(vec3 p, vec3 h)\n{\n    return (map(p + h) - map(p - h)) / (2.0 * length(h));\n}\n\nvec3 norm(vec3 p)\n{\n    mat3 e = mat3(EPSY);\n    float x = diff(p, e[0]);\n    float y = diff(p, e[1]);\n    float z = diff(p, e[2]);\n    return normalize(vec3(x, y, z));\n}\n\n////////////////////////////////////////////////////////////////\n\nvec4 noise(vec3 v)\n{\n    float t = (60.0 * iTime);\n    vec3 r = vec3(cos(t), sin(t), t);\n    return (0.5 - texture(iChannel1, 16.0 * (v + r)));\n}\n\nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nray march(ray r, vec2 uv)\n{\n    int count = 0;\n    for(int i = 0; i < STEPS; i++)\n    {\n        object hit = scene(r.origin);\n        if(on_surface(hit.dist))\n        {\n            if((hit.id == ID_OBJECT_A) && (count++ < REFLECTIONS))\n            {\n                r.direction = reflect(r.direction, norm(r.origin));\n                hit.dist = EPSY;\n            }\n            else\n                break;\n        }\n        r.origin += hit.dist * r.direction;\n        r.direction += SPREAD_MARCH * noise(r.direction).xyz;\n    }\n    return r;\n}\n\nstruct light\n{\n    vec3 origin;\n    float range;\n    vec4 color;\n};\n\nvec4 lighting(ray r, vec2 uv, light l)\n{\n    vec3 ln = (l.origin - r.origin);\n    if(dot(ln, norm(r.origin)) > 0.0)\n    {\n        r.origin -= EPSY * r.direction;\n        r.direction = normalize(ln);\n        r.origin += EPSY * r.direction;\n        for(int i = 0; i < STEPS; i++)\n    \t{\n            object hit = closest(scene(r.origin), object(sphere(r.origin - l.origin, l.range), 69));\n            if(on_surface(hit.dist))\n            {\n                if(hit.id == 69)\n                    return l.color;\n                else\n                    break;\n            }\n            r.origin += hit.dist * r.direction;\n            r.direction += SPREAD_LIGHT * noise(r.direction).xyz;\n        }\n    }\n    return vec4(0);\n}\n\nlight red   = light(vec3(8, 0, 0), 0.05, vec4(1, 0, 0, 0));\nlight green = light(vec3(0, 8, 0), 0.05, vec4(0, 1, 0, 0));\nlight blue  = light(vec3(0, 0, 8), 0.05, vec4(0, 0, 1, 0));\n\nmat3 rotX(float angle)\n{\n    float cs = cos(radians(angle));\n    float sn = sin(radians(angle));\n    \n    vec3 c0 = vec3(1,   0,  0);\n    vec3 c1 = vec3(0,  cs, sn);\n    vec3 c2 = vec3(0, -sn, cs);\n    return mat3(c0, c1, c2);\n}\n\nmat3 rotY(float angle)\n{\n    float cs = cos(radians(angle));\n    float sn = sin(radians(angle));\n    \n    vec3 c0 = vec3(cs, 0, -sn);\n    vec3 c1 = vec3( 0, 1,   0);\n    vec3 c2 = vec3(sn, 0,  cs);\n    return mat3(c0, c1, c2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = ((2.0 * fragCoord) - iResolution.xy) / min(iResolution.x, iResolution.y) * tan(radians(FOV) / 2.0);\n    vec3 uvw = normalize(vec3(uv, 1));\n    \n    mat3 rot = rotY(iMouse.x) * rotX(iMouse.y);\n    ray camera = ray(rot * vec3(0, 0, -16), rot * uvw);\n    \n    ray p = march(camera, uv);\n    \n    vec4 new = (lighting(p, uv, red) + lighting(p, uv, green) + lighting(p, uv, blue));\n    vec4 old = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    fragColor = new + old * step(0.0, -iMouse.z);\n    fragColor.a++;\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float EPSY = 0.001;\n\nbool on_surface(float dist)\n{\n    return (dist >= 0.0) && (dist < EPSY);\n}\n","name":"Common","description":"","type":"common"}]}