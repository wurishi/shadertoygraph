{"ver":"0.1","info":{"id":"McGcz1","date":"1731702986","viewed":153,"name":"Rise and Fall","username":"incre_ment","description":"Another variation of a recent shader:\nhttps://www.shadertoy.com/view/MctcWN\nThis one loops from tt=0 -> tt=1.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","domainrepetition","loop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Another variation of a recent shader:\n// https://www.shadertoy.com/view/MctcWN\n\n// This one loops from tt=0 -> tt=1.\n\nvec3 boxSize = vec3(.495,1.,.495);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col = vec3(0);\n  float tt = fract(.3*iTime);\n   \n  vec3 camPos = vec3(0, 0., 5.5); \n  vec3 rayDir = normalize(vec3(uv, -1));\n  \n  float depth = 0.0;\n  vec3 p = vec3(0);\n  vec3 offFinal;\n  float yDim = 2.* boxSize.y;\n  \n  for(int numIter = 0; numIter < 50; numIter++){\n    p = camPos + depth * rayDir;\n    \n    // Rotate the rays\n    p.xz *= rotation(TAU/13.);   \n    p.yz *= rotation(-TAU/6.);\n    \n    // Make the blocks rise.\n    p.y -= yDim*tt;\n\n    // Domain Repetition\n    vec2 cellID = floor(p.xz);\n    p.xz = fract(p.xz) - .5;\n    \n    // Neighbor checking and box SDF\n    float d = 1E20;\n    float nReach = 2.;\n    for(float i = -nReach ; i <= nReach ; i++)\n      for(float j = -nReach ; j <= nReach ; j++){\n        float offFac = TAU*fract(142.23*sin((20.+ cellID + vec2(i,j)).x * (10.+ cellID + vec2(i,j)).y));   \n        \n        float tStart = .5* offFac / TAU;\n        float tEnd = tStart + .50;\n        \n        float ttt;\n        if (tt > tStart && tt < tEnd){\n          ttt = 2.0 * (tt - tStart);\n        }\n        else if (tt < tStart) ttt = 0.;\n        else if (tt > tEnd) ttt = 1.;\n   \n        vec3 off2 = vec3(0.,-yDim*easeOutBounce(ttt),0.);\n        float dd = sdBox(p-off2-vec3(i,0.0,j), boxSize);\n       \n        if(dd < d){\n          offFinal = off2;\n          d = dd;\n        }   \n      }\n      \n    depth += d;\n    if (d < .0001 || depth > 50.0) break;\n  }\n  \n  float d = depth;\n\n  if (d > 50.) {\n    col = vec3(0.);  \n  } else {\n  \n    p -= offFinal;\n    vec2 side;\n    float outline;\n    float star;\n    float s1 = .92;\n    float s2 = .95;\n    if(abs(p.x) <= boxSize.x && abs(p.y) <= boxSize.y){\n      side = p.xy;\n      outline = smoothstep(s1*boxSize.x,s2*boxSize.x, abs(side.x));\n      outline += smoothstep(s1*boxSize.y,s2*boxSize.y,abs(side.y));\n      \n      vec2 star_uv = 4. * side;\n      vec2 starID = floor(star_uv);\n      star_uv = fract(star_uv) - .5;\n      float off = fract(323.23*sin(starID.x/10.) * 12.*sin(starID.y/10.));\n      float star_rad = .2 + .1*sin(2.*TAU*tt + TAU*off);\n      star = length(star_uv) - star_rad;\n      \n    }\n    else if(abs(p.y) <= boxSize.y && abs(p.z) <= boxSize.z){\n      side = p.yz;\n      outline = smoothstep(s1*boxSize.y,s2*boxSize.y, abs(side.x));\n      outline += smoothstep(s1*boxSize.z,s2*boxSize.z, abs(side.y));\n      \n      vec2 star_uv = 4. * side;\n      vec2 starID = floor(star_uv);\n      star_uv = fract(star_uv) - .5;\n      float off = fract(323.23*sin(starID.x/10.) * 12.*sin(starID.y/10.));\n      float star_rad = .2 + .1*sin(2.*TAU*tt + TAU*off);\n      star = length(star_uv) - star_rad;    \n      \n    }\n    else{\n      side = p.xz;\n      outline = smoothstep(s1*boxSize.x,s2*boxSize.x,abs(side.x));\n      outline += smoothstep(s1*boxSize.z,s2*boxSize.z,abs(side.y)); \n    }\n    \n    col = vec3(outline);\n    col += smoothstep(0.,-fwidth(star),star);\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\nfloat PI = 3.14159;\nfloat TAU = 2.*3.14159;\n\n\n// Thanks IQ!\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// easings.net\nfloat easeOutBounce(float x){\nfloat n1 = 7.5625;\nfloat d1 = 2.75;\n\nif (x < 1. / d1) {\n    return n1 * x * x;\n} else if (x < 2. / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n} else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n} else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984375;\n}\n\n}","name":"Common","description":"","type":"common"}]}