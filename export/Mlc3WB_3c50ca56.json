{"ver":"0.1","info":{"id":"Mlc3WB","date":"1471265192","viewed":221,"name":"Shading test","username":"rimina","description":"On my way to find nice looking shading.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","refraction","shading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 80.0\n#define FAR_R 80.0\n#define STEPS 80\n#define GAMMA vec3(2.2)\n\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat vmax3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n\nfloat fSphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax3(min(d, vec3(0)));\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n    vec3 c = floor((p + size*0.5)/size);\n    p = mod(p + size*0.5, size) - size*0.5;\n    return c;\n}\n\nfloat sdf(vec3 p){\n    \n    //some performance tests...\n    //pMod2(p.xz, vec2(10.));\n    //pMod3(p, vec3(10.));\n    \n    return min(fSphere(p-vec3(-1.0, 0. ,0.), 0.5),min(fBox(p, vec3(0.025, 1.0, 1.5)), fBox(p-vec3(1.0, 0. , 0.), vec3(0.5))));\n}\n\nvec3 normal( vec3 p ){\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tsdf(p+eps.xyy)-sdf(p-eps.xyy),\n\t\tsdf(p+eps.yxy)-sdf(p-eps.yxy),\n\t\tsdf(p+eps.yyx)-sdf(p-eps.yyx)\n\t));\n}\n\n//Ambien occlusion & shadow coeffience function modified from\n//las's (Mercury) and dechipher's (YUP) methods from pouet raymarching thread\n//PRAMETERS:\n//  p = position,\n//  n = normals (ao) or unit vector of light direction (shadow)\n//  k = constant\n\nfloat ambientOcclusion(vec3 p, vec3 n, float k){\n    float s = sgn(k);\n    float o = s*.5+.5;\n    for(float i = 0.; i < 6.; ++i){\n        o -= (i*k - sdf(p+n*i*k*s))/exp2(i);\n    }\n    return max(min(o, 1.), 0.);\n}\n\nvec3 march(in vec3 ro, in vec3 rd, inout float t){\n\n    vec3 p = ro;\n    for(int i = 0; i < STEPS; ++i){\n        float d = sdf(p);\n        t += d;\n        p += rd*d;\n        \n        if(d < 0.01 || t > FAR){\n            break;\n        }\n        \n    }\n    return p;\n}\n\n\nmat4 marchRF(in vec3 ro, in vec3 rd, in vec3 ro2, in vec3 rd2, inout vec2 t){\n    vec3 n = normal(ro);\n    vec3 n2 = normal(ro2);\n    \n    vec3 rdRefract= refract(rd2, n2, 1.31);\n    \n    vec3 rdReflect = reflect(rd, n);\n    \n    vec3 pRefract = ro2;\n    vec3 pReflect = (ro+(0.01*n));\n    \n    bool refractDone = false;\n    bool reflectDone = false;\n    \n    for(int i = 0; i < STEPS; ++i){\n        float d1 = sdf(pRefract);\n        float d2 = sdf(pReflect);\n        \n        if(!refractDone){\n             t.x += d1;\n             pRefract += rdRefract*d1;\n        }\n        \n        if(!reflectDone){\n        \tt.y += d2;\n        \tpReflect += rdReflect*d2;\n        }\n        \n        if(d1 < 0.0001 || t.x > FAR_R){\n            refractDone = true;\n        }\n        \n        if(d2 < 0.0001 || t.y > FAR_R){\n            reflectDone = true;\n        }\n        \n        if(refractDone && reflectDone){\n            break;\n        }\n        \n    }\n    \n    return mat4(\n        vec4(pRefract, 0.),\n        vec4(pReflect, 0.),\n        vec4(rdRefract, 0.),\n    \tvec4(rdReflect, 0.));\n    \n}\n\nvec3 shade(in vec3 p, in vec3 ld, in vec3 rd){\n    vec3 n = normal(p);\n    \n    float lambertian = max(dot(-ld, n), 0.0);\n    float angle = max(dot(reflect(-ld, n), rd), 0.0);\n    float specular = pow(angle, 80.0);\n    \n    float ao = ambientOcclusion(p, n, 0.5);\n    \n    \n    vec3 c = ao*vec3(0.5)+lambertian*vec3(0.5, 0.5, 0.6)*0.5+specular*vec3(0.6)*0.6;\n    return c;\n}\n\n\n\n\n// Functio to set camera\n// o = camera origin\n// target = camera target (lookAt)\n// cr = right angle\nmat3 setCamera(vec3 o, vec3 target, float cr ){\n\tvec3 cw = normalize(target-o);//z\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);//up\n\tvec3 cu = normalize( cross(cw,cp) );//x\n\tvec3 cv = normalize( cross(cu,cw) );//y\n\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 v = -1.0+2.0*uv;\n    v.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(cos(iTime*0.5)*3.5, 0.0, sin(iTime*0.5)*3.5);\n    vec3 rt = vec3(0., 0., 0.);\n    \n    mat3 cam = setCamera(ro, rt, 0.);\n    vec3 rd = normalize(cam*vec3(v.xy, radians(90.)));\n    \n    float t = 0.01;\n    vec3 p = march(ro, rd, t);\n    \n    vec3 ld = (rt-ro)/distance(rt, ro);\n\tfragColor.rgb = shade(p, ld, rd);\n    fragColor.a = 1.0;\n     \n    if (t < FAR){\n        \n        vec3 col = vec3(1.);\n        vec3 p2 = p;\n        vec3 rd2 = rd;\n        for(int i = 0; i < 8; ++i){\n        \n            vec2 td = vec2(0.);\n            mat4 pr = marchRF(p, rd, p2, rd2, td);\n\n            if(td.x < FAR_R){\n               col = shade(pr[0].xyz, ld, pr[2].xyz);\n               fragColor.rgb = mix(fragColor.rgb, col, 0.25);\n                \n                p2 = pr[0].xyz;\n                rd2 = pr[2].xyz;\n            }\n            if(td.y < FAR_R){\n                col = shade(pr[1].xyz, ld, pr[3].xyz);\n                fragColor.rgb = mix(fragColor.rgb, col, 0.25);\n                \n                p = pr[1].xyz;\n                rd = pr[3].xyz;\n            }\n            else{\n                fragColor.rgb = mix(fragColor.rgb, vec3(1.), 0.042);\n                break;\n            }\n        }\n    }\n    else{\n        fragColor = vec4(1.);\n    }\n    \n    \n    fragColor.rgb = pow(fragColor.rgb, 1.0/GAMMA);\n}","name":"Image","description":"","type":"image"}]}