{"ver":"0.1","info":{"id":"styyDy","date":"1662116146","viewed":274,"name":"Fancy Voxel Raycasting","username":"yrkv","description":"Implemented a few features, such as easy texturing, simple transparency with refraction, and reflections. Unfortunately It's slower and clearly not branchless, but still neat.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raycasting","voxel"],"hasliked":0,"parentid":"4dX3zl","parentname":"Branchless Voxel Raycasting"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\nTODO:\n- fix refraction/reflection\n- improve performance\n- lighting (?)\n*/\n\n#define TIME_SPEED 0.5\n#define MAX_RAY_STEPS 640\n#define MAX_REFLECTIONS 3\n#define GLASS_RI 1.5\n\n\n// make glass hazy by adding noise to normal. Uncomment to enable\n//#define HAZY_GLASS 0.05\n\nconst vec4 ONES = vec4(1.0);\nconst vec4 ZEROS = vec4(0.0);\nconst vec2 _01 = vec2(0.0, 1.0);\n\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBoxRot( vec3 p, vec3 b, float r ) {\n  p.xz = rotate2d(p.xz, r);\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nbool getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n    //float d = min(sdBoxRot(p, vec3(3.0), 0.), -sdSphere(p, 25.0));\n    float d = min(\n        sdSphere(p, 1.0), min(\n        max(-sdSphere(p, 3.5), sdBoxRot(p, vec3(3.0), 0.)),\n        min(max(-sdSphere(p, 7.5), sdBoxRot(p, vec3(6.0), 0.785398)),-sdSphere(p, 25.0))\n    ));\n\treturn d < 0.0;\n}\n\n\n\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// using a as alpha, implementing https://en.wikipedia.org/wiki/Alpha_compositing\nvec4 blend(vec4 above, vec4 below) {\n    float alpha = mix(below.a, 1., above.a);\n    return vec4(mix(below*below.a, above, above.a).rgb / alpha, alpha);\n}\n\nvec4 blend(vec4 above, vec3 below) {\n    return vec4(mix(below, above.rgb, above.a), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV);\n    vec3 rayPos = vec3(0.0, 1.0 * sin(iTime * 2.7 * TIME_SPEED), -12.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, iTime * TIME_SPEED);\n\trayDir.xz = rotate2d(rayDir.xz, iTime * TIME_SPEED);\n\t\n\tivec3 mapPos = ivec3(floor(rayPos));\n\tvec3 deltaDist = 1. / abs(rayDir);\n\tivec3 rayStep = ivec3(sign(rayDir));\n    vec3 sideDist = (sign(rayDir) * (0.5 - fract(rayPos)) + 0.5) * deltaDist;\n\n\t\n    float refractive_index = 1.0;\n\tbvec3 mask;\n    \n    vec4 color;\n    fragColor = vec4(0.);\n    \n    //float depth = 0.;\n    int reflections = 0;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (getVoxel(mapPos)) {\n        \n            if (mapPos == clamp(mapPos, -5, 4)) {\n                // calculate end of ray\n                float m = dot(vec3(mask), sideDist - deltaDist);\n                rayPos = rayPos + rayDir * m;\n                \n                // apply white and dullness based on dist from origin\n                color = vec4(min(2.5 / length(rayPos), 1.0));\n                fragColor = blend(fragColor, color);\n            \n                // reflect ray\n                if (reflections < MAX_REFLECTIONS) {\n                    vec3 normal = vec3(mask) * sign(rayDir);\n                    rayDir = reflect(rayDir, normal);\n                    reflections++;\n                } else {\n                    break;\n                }\n\n                // \"restart\" raycasting\n                mapPos = ivec3(floor(rayPos + 0.));\n                deltaDist = 1. / abs(rayDir);\n                rayStep = ivec3(sign(rayDir));\n                sideDist = (sign(rayDir) * (0.5 - fract(rayPos)) + 0.5) * deltaDist;\n            } else if (mapPos == clamp(mapPos, -12, 11)) {\n                float m = dot(vec3(mask), sideDist - deltaDist) + 0.001;\n                vec3 hit = (rayPos + rayDir * m);\n                \n                // refract ray\n                float eta = refractive_index / GLASS_RI;\n                if (eta != 1.0) {\n                    vec3 normal = -vec3(mask) * sign(rayDir);\n                    \n                    #ifdef HAZY_GLASS\n                        normal = normalize(normal + (hash33(hit*100.) - 0.5)*HAZY_GLASS);\n                    #endif\n                    rayDir = refract(rayDir, normal, eta);\n                    \n                    // scuffed attempt at making the glass a bit reflective\n                    //float R_0 = pow((refractive_index - GLASS_RI) /\n                    //                (refractive_index + GLASS_RI), 2.);\n                    //float cos_i = dot(-normal, rayDir);\n                    //float R = R_0 + (1. - R_0)*pow(1. - cos_i, 5.);\n                    \n                    //if (hash13(hit*100. + iTime) > R*2.) {\n                    //    rayDir = refract(rayDir, normal, eta);\n                    //} else {\n                    //    rayDir = reflect(rayDir, normal);\n                    //}\n                }\n                refractive_index = GLASS_RI;\n                \n                // \"restart\" raycasting\n                rayPos = hit;\n                mapPos = ivec3(floor(rayPos + 0.));\n                deltaDist = 1. / abs(rayDir);\n                rayStep = ivec3(sign(rayDir));\n                sideDist = (sign(rayDir) * (0.5 - fract(rayPos)) + 0.5) * deltaDist;\n                \n                // alpha is proportional to amount of ray within the voxel,\n                // seems to make it mostly seamless between two transparent voxels.\n                float t = min(min(sideDist.x, sideDist.y), sideDist.z);\n                color = vec4(abs(hit) / 10., t*0.3);\n                fragColor = blend(fragColor, color);\n            } else {\n                break;\n            }\n        } else if (refractive_index != 1.0) {\n            // refract/reflect when light exits the glass\n            vec3 m = vec3(mask) * (sideDist - deltaDist) + 0.001;\n            vec3 hit = (rayPos + rayDir * dot(m, ONES.xyz));\n\n            vec3 normal = -vec3(mask) * sign(rayDir);\n            #ifdef HAZY_GLASS\n                normal = normalize(normal + (hash33(hit*100.) - 0.5)*HAZY_GLASS);\n            #endif\n            vec3 r = refract(rayDir, normal, refractive_index);\n            if (r == ZEROS.xyz) {\n                // reflect if total internal reflection\n                if (reflections < MAX_REFLECTIONS) {\n                    rayDir = reflect(rayDir, normal);\n                    reflections++;\n                } else {\n                    break;\n                }\n            } else {\n                // otherwise use refraction ray\n                rayDir = r;\n                refractive_index = 1.0;\n            }\n\n            rayPos = hit;\n            mapPos = ivec3(floor(rayPos));\n            deltaDist = 1. / abs(rayDir);\n            rayStep = ivec3(sign(rayDir));\n            sideDist = (sign(rayDir) * (0.5 - fract(rayPos)) + 0.5) * deltaDist;\n        }\n        \n        \n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\n        sideDist += vec3(mask) * deltaDist;\n        mapPos += ivec3(mask) * rayStep;\n        \n        //depth += 1.;\n        \n\t}\n    \n    // needs +0.001 to definitely be in the hit block\n    float m = dot(vec3(mask), sideDist - deltaDist) + 0.001; \n    vec3 hit = rayPos + rayDir * m;\n    \n    \n    color.xyz = hash13(vec3(mapPos))*0.2 + fract(hit)*0.2 + 0.5;\n    fragColor = blend(fragColor, color.xyz);\n    \n    //fragColor = vec4(depth / float(MAX_RAY_STEPS));\n}","name":"Image","description":"","type":"image"}]}