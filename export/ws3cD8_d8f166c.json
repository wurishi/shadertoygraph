{"ver":"0.1","info":{"id":"ws3cD8","date":"1600822623","viewed":202,"name":"Screen Space Penumbras","username":"Assossa","description":"Inspired by https://www.imgtec.com/blog/implementing-fast-ray-traced-soft-shadows-in-a-game-engine/","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","shadows","screenspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHT_SIZE 0.1\n#define SAMPLE_RADIUS 4\n#define BLUR_SIGMA 5.0\n\nconst float sigmaQuotient = 2. * pow(BLUR_SIGMA, 2.);\n\nvec4 getDataFromWorld(vec3 camPos, vec3 worldPos) {\n    vec3 dir = normalize(worldPos - camPos);\n    dir /= dir.z;\n    \n    vec2 fragCoord = dir.xy;\n    fragCoord *= iResolution.y;\n    fragCoord += iResolution.xy;\n    fragCoord *= 0.5;\n    \n    return texelFetch(iChannel0, ivec2(fragCoord), 0);\n}\n\nfloat calculateShadow(vec3 camPos, vec3 pos, vec3 nml, float penumbraSize) {\n    vec3 lightPos = lightPosition(iTime);\n    float stepSize = penumbraSize / float(SAMPLE_RADIUS);\n    \n    float isUp = step(0.99, dot(nml, vec3(0, 1, 0)));\n    vec3 tempAxis = mix(vec3(0, 1, 0), vec3(1, 0, 0), vec3(isUp));\n    \n    vec3 sideAxis = normalize(cross(nml, tempAxis)) * stepSize;\n    vec3 upAxis = normalize(cross(sideAxis, nml)) * stepSize;\n    \n    float shadowSum = 0.0;\n    \n    for(int y = -SAMPLE_RADIUS; y <= SAMPLE_RADIUS; ++y) {\n        for(int x = -SAMPLE_RADIUS; x <= SAMPLE_RADIUS; ++x) {\n\t\t\tvec3 p = pos + (sideAxis * float(x)) + (upAxis * float(y));\n            vec4 data = getDataFromWorld(camPos, p);\n            vec3 pNml = normalize(data.xyz);\n            \n            float nmlDiff = dot(pNml, nml);\n            float contribution = exp(-(float(x*x + y*y) / sigmaQuotient)) / (sigmaQuotient * PI);\n            \n            float shadow = distance(p, lightPos) - data.w;\n            \n            shadowSum += contribution * smoothstep(0., 0.1, shadow);\n        }\n    }\n\n    return 1. - shadowSum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float dist = length(data.xyz);\n    vec3 nml = normalize(data.xyz);\n    float occluderDist = data.w;\n    \n    vec3 camPos = camPosition(iTime);\n\tvec3 camDir = camDirection(fragCoord, iResolution.xy, iTime);\n    vec3 lightPos = lightPosition(iTime);\n    \n    vec3 hit = camPos + camDir * dist;\n    \n    float depthFog = 1. - smoothstep(6.0, 10.0, dist);\n    float diffuse = dot(nml, normalize(lightPos - hit)) * 0.5 + 0.5;\n    float lightDist = distance(lightPos, hit);\n    \n    float penumbraSize = LIGHT_SIZE * (occluderDist / lightDist);\n    float shadow = calculateShadow(camPos, hit, nml, penumbraSize);\n    \n    fragColor = vec4(diffuse) * depthFog * shadow;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This is meant to emulate the shadow data you would have access\n// to with a traditional rasterization renderer and shadow maps\n\nfloat scene(vec3 p) {\n\treturn min(\n\t\tp.y + 1.,\n\t\tlength(p) - 1.\n\t);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(0.01, 0.0);\n\treturn normalize(vec3(\n\t\tscene(p + e.xyy) - scene(p - e.xyy),\n\t\tscene(p + e.yxy) - scene(p - e.yxy),\n\t\tscene(p + e.yyx) - scene(p - e.yyx)\n\t));\n}\n\nfloat raymarch(vec3 p, vec3 d) {\n\tfloat dist = 0.0;\n\tfor(int i = 0; i < 64; ++i) dist += scene(p + d * dist);\n\treturn dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 camPos = camPosition(iTime);\n\tvec3 camDir = camDirection(fragCoord, iResolution.xy, iTime);\n\t\n\tfloat dist = raymarch(camPos, camDir);\n    vec3 hit = camPos + camDir * dist;\n    vec3 nml = normal(hit);\n\t\n\tvec3 lightPos = lightPosition(iTime);\n\tfloat occluderDist = raymarch(lightPos, normalize(hit - lightPos));\n    \n    fragColor = vec4(nml * dist, occluderDist);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\nvec3 lightPosition(float iTime) {\n    return vec3(8. * cos(iTime), 10., 8. * sin(iTime));\n}\n\nvec3 camPosition(float iTime) {\n    return vec3(0, 0, -3);\n}\n\nvec3 camDirection(vec2 fragCoord, vec2 iResolution, float iTime) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\treturn normalize(vec3(uv, 1));\n}","name":"Common","description":"","type":"common"}]}