{"ver":"0.1","info":{"id":"fdtfDn","date":"1656410013","viewed":74,"name":"my_name","username":"vladimir_azarov_onu","description":"name and sirname","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["letters"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n\n#define d2(x) ((x)*(x))\n\n#define w(x) (float(x) / 32.0)\n#define h(x) (float(x) / 18.0)\n\n#define eps (1.8e-4)\n\n\nstruct SegLine {\n    vec2 p1, p2;\n    float from, to;\n};\n\nstruct HorLine {\n    float y;\n    float from, to;\n};\n\nstruct VertLine {\n    float x;\n    float from, to;\n};\n\nstruct SegCircle {\n    vec2 center;\n    float radius;\n    float wh;\n    int angle;\n    float e;\n};\n\nSegLine lines[] = SegLine[](\n    SegLine(vec2(w(7), h(10)), vec2(w(8), h(13)), w(7), w(8)),\n    SegLine(vec2(w(8), h(13)), vec2(w(9), h(10)), w(8), w(9)),\n    \n    SegLine(vec2(w(10.5), h(10)), vec2(w(11), h(12)), w(10.5), w(11)),\n    SegLine(vec2(w(11), h(12)), vec2(w(11.5), h(10)), w(11), w(11.5)),\n    \n    SegLine(vec2(w(8.5), h(6)), vec2(w(9), h(8)), w(8.5), w(9)),\n    SegLine(vec2(w(9), h(8)), vec2(w(9.5), h(6)), w(9), w(9.5)),\n    \n    SegLine(vec2(w(10), h(6)), vec2(w(10.5), h(8)), w(10), w(10.5)),\n    SegLine(vec2(w(10.5), h(8)), vec2(w(11), h(6)), w(10.5), w(11)),\n    \n    SegLine(vec2(w(11.5), h(6.05)), vec2(w(12), h(8)), w(11.5), w(12)),\n    SegLine(vec2(w(12), h(8)), vec2(w(12.5), h(6.05)), w(12), w(12.5)),\n  \n    SegLine(vec2(w(11.5), h(6)), vec2(w(11.75), h(5.5)), w(11.5), w(11.75)),\n    SegLine(vec2(w(12.5), h(6)), vec2(w(12.25), h(5.5)), w(12.25), w(12.5)),\n    \n    SegLine(vec2(w(13), h(6.1)), vec2(w(14), h(7.9)), w(13), w(14)),\n    \n    SegLine(vec2(w(14.5), h(6)), vec2(w(15), h(8)), w(14.5), w(15)),\n    SegLine(vec2(w(15.5), h(6)), vec2(w(15), h(8)), w(15), w(15.5)),   \n    SegLine(vec2(w(15.5), h(6)), vec2(w(16), h(8)), w(15.5), w(16)),\n    SegLine(vec2(w(16.5), h(6)), vec2(w(16), h(8)), w(16), w(16.5)),\n    \n    SegLine(vec2(w(17), h(6.1)), vec2(w(18), h(7.9)), w(17), w(18))\n);\n\nHorLine hlines[] = HorLine[](\n  HorLine(h(11.5), w(7.5), w(8.5)),\n  HorLine(h(11), w(10.75), w(11.25)),\n  HorLine(h(9.75), w(10.25), w(7)),\n  HorLine(h(7), w(10.25), w(10.75)),\n  HorLine(h(6), w(11.4), w(12.6))\n \n);\n\nVertLine vlines[] = VertLine[](\n    VertLine(w(12), h(10), h(12)),\n    VertLine(w(14.5), h(10), h(12)),\n    VertLine(w(7), h(6), h(9)),\n    VertLine(w(13), h(6), h(8)),\n    VertLine(w(14), h(6), h(8)),\n    \n    VertLine(w(17), h(6), h(8)),\n    VertLine(w(18), h(6), h(8)),\n    VertLine(w(18.5), h(6), h(8))\n);\n\nSegCircle sc[] = SegCircle[](\n    SegCircle(vec2(w(9.5), h(11.45)), 0.0275, 0.8, 1, eps),\n    SegCircle(vec2(w(9.5), h(10.5)), 0.0275, 0.8, 1, eps),\n    \n    SegCircle(vec2(w(12), h(11.5)), 0.027, 0.8, 1, eps),\n    \n    SegCircle(vec2(w(13.5), h(11)), 0.055, 0.3, 1, eps * 2.0),\n    SegCircle(vec2(w(13.5), h(11)), 0.055, 0.3, -1, eps * 2.0),\n    \n    SegCircle(vec2(w(14.5), h(11.5)), 0.0275, 0.8, 1, eps),\n    SegCircle(vec2(w(14.5), h(10.5)), 0.0275, 0.8, 1, eps),\n    SegCircle(vec2(w(7), h(6.75)), 0.04, 0.8, 1, eps),\n    SegCircle(vec2(w(7), h(8.25)), 0.04, 0.8, 1, eps),\n    \n    SegCircle(vec2(w(18.5), h(7.5)), 0.0275, 0.8, 1, eps)\n);\n\n        float dot_pr(vec2 v1, vec2 v2)\n        {\n            return v1.x * v2.x + v1.y * v2.y;\n        }\n\n    bool isin_segCircle(vec2 p, SegCircle c)\n    {\n        if (abs(d2((p.x - c.center.x)/c.wh) + d2(p.y - c.center.y) - d2(c.radius)) > c.e)\n            return false;\n\n        float a = -PI / 2.0 + float(c.angle) * PI / 2.0;\n        vec2 n = vec2(cos(a) * c.radius, sin(a) * c.radius);\n        return dot_pr(n, p - c.center) > 0.0;\n    }\n\n    bool ison_horline(vec2 p, HorLine l)\n    {\n        return abs(p.y - l.y) < 0.005 && p.x >= l.from && p.x <= l.to;\n    }\n\n    bool ison_vertline(vec2 p, VertLine l)\n    {\n        return abs(p.x - l.x) < 0.003 * iResolution.y / iResolution.x\n            && p.y >= l.from && p.y <= l.to;\n    }\n\n\n\n    bool close_to_line(vec2 p, SegLine l)\n    {\n        float xc = (p.x - l.p1.x) / (l.p2.x - l.p1.x);\n        float yc = (p.y - l.p1.y) / (l.p2.y - l.p1.y);\n         return abs(xc - yc) < 0.08 && p.x >= l.from && p.x <= l.to;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; \n    int i;\n    vec3 col = vec3(1.0);\n   \n     if (mod(uv.x+0.001, 1.0 / 32.0) < 0.002\n             ||abs(mod(uv.y, 1.0 / 18.0)) < 0.002) {\n       col = vec3(0.0, 1.0, 0.0);\n     }\n    \n      for (i = 0; i < lines.length(); ++i) {\n        if (close_to_line(uv, lines[i]))\n          col = vec3(0);\n      }  \n    \n       for (i = 0; i < sc.length(); ++i) {\n         if (isin_segCircle(uv, sc[i]))\n           col = vec3(0);\n       }\n    \n        for (i = 0; i < hlines.length(); ++i) {\n          if (ison_horline(uv, hlines[i]))\n            col = vec3(0);\n        }\n    \n         for (i = 0; i < vlines.length(); ++i) {\n           if (ison_vertline(uv, vlines[i]))\n             col = vec3(0);\n         }\n    \n          fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}