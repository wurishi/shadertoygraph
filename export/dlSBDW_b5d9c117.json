{"ver":"0.1","info":{"id":"dlSBDW","date":"1694035547","viewed":219,"name":"Saturn and sun","username":"imadr","description":"Needs some kind of AA","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["space","planet","saturn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n       \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    float border_size = 0.1;\n    if(uv.y > 1.0-border_size) col = vec3(0.01);\n    if(uv.y < 0.0+border_size) col = vec3(0.01);\n\n    float exposure = 2.;\n    float gamma = 2.2;\n    col = vec3(1.0) - exp(-col * exposure);\n    \n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;\n    fragColor = vec4(col, 1.)+texture(iChannel1, uv)/255.;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SATURN 1.0\n#define RINGS 2.0\n#define SUN 3.0\n#define PI 3.14159265359\n\nfloat cylider( vec3 point, float height, float radius ){\n  vec2 d = abs(vec2(length(point.xz),point.y)) - vec2(radius,height);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 point, float radius){\n    return length(point)-radius;\n}\n\nvec2 vec_min(vec2 a, vec2 b){\n    return a.x > b.x ? b : a;\n}\n\nvec3 glow = vec3(0);\nvec3 sun_color = vec3(1, 0.957, 0.878);\nvec3 sun_pos = vec3(7., 1.5, 7.);\n\nfloat fov = 20.;\n\nconst vec3 saturn_pos = vec3(0., 0., 0.);\nconst vec3 saturn_rot = vec3(-0.18, 0.4, 0.1);\n\nTransform saturn_transform = Transform(\n    saturn_pos, saturn_rot\n);\n\nTransform ring_transform = Transform(\n    saturn_pos, saturn_rot\n);\n\nstruct Scene {\n    vec2 s;\n};\n\nstruct MarchOut {\n    float depth;\n    float col;\n};\n\nScene scene(vec3 point){\n    vec2 saturn = vec2(sphere(transform(point, saturn_transform), 2.), SATURN);\n    vec3 r_t = transform(point, ring_transform);\n    float r = cylider(r_t, 0.00001, 4.4);\n    r = max(-cylider(r_t, 1., 3.), r);\n\n\n    vec2 sun = vec2(sphere(point-sun_pos, 0.1), SUN);\n    glow += .0001 / (0.001 + sun.x * sun.x * sun.x * sun.x) * sun.y;\n\n    float ring1 = cylider(r_t, 2., 3.55);\n    float ring2 = cylider(r_t, 1., 3.6);\n    float ring3 = cylider(r_t, 2., 4.07);\n    float ring4 = cylider(r_t, 1., 4.1);\n    float ring5 = cylider(r_t, 2., 3.1);\n    float ring6 = cylider(r_t, 1., 3.15);\n    r = max(-max(-ring1, ring2), r);\n    r = max(-max(-ring3, ring4), r);\n    r = max(-max(-ring5, ring6), r);\n\n    vec2 rings = vec2(r, RINGS);\n\n    return Scene(\n        vec_min(sun, vec_min(rings, saturn))\n    );\n\n}\n\nMarchOut march(vec3 ray_origin, vec3 ray_direction){\n    vec3 current_point = ray_origin;\n    float dist_total = 0.;\n    float col;\n    for(int i = 0; i < 4000; i++){\n        current_point = ray_origin+ray_direction*dist_total;\n        Scene s = scene(current_point);\n        col = s.s.y;\n        float dist = s.s.x;\n        dist_total += dist;\n        if(dist < 0.00001){\n            break;\n        }\n        if(dist_total > 1000.){\n            col = 0.;\n            break;\n        }\n    }\n\n    return MarchOut(dist_total, col);\n}\n\nvec3 normal(vec3 point){\n    if(point.z > 1000.) return vec3(0.);\n    float dist = scene(point).s.x;\n    float delta = 0.001;\n    vec2 dir = vec2(delta, 0.);\n    float dx = scene(point+dir.xyy).s.x-dist;\n    float dy = scene(point+dir.yxy).s.x-dist;\n    float dz = scene(point+dir.yyx).s.x-dist;\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat lighting(vec3 point, vec3 normal, vec3 light_pos){\n    vec3 direction_to_light = normalize(light_pos);\n    MarchOut m = march(point+normal*0.001, direction_to_light);\n    if(m.col != SUN && m.depth < length(light_pos-point)){\n        return 0.;\n    }\n    return max(0., dot(normal, direction_to_light));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 camera_pos;\n    vec3 camera_target;\n\n    vec3 camera_move;\n\n    const int num_scenes = 2;\n    const float scenes[num_scenes] = float[num_scenes](\n        7.0, 5.0\n    );\n    float sum_scenes = 0.;\n    for(int i = 0; i < num_scenes; i++){\n        sum_scenes += scenes[i];\n    }\n    float scene_timer = mod(iTime, sum_scenes);\n    float sum = 0.;\n    int current_scene = 0;\n    for(int i = 0; i < num_scenes; i++){\n        sum += scenes[i];\n        if(scene_timer < sum ){\n            current_scene = i;\n            break;\n        }\n    }\n        \n    if(current_scene == 1){\n        camera_move.x = (scene_timer*-0.05)+1.5;\n        camera_move.z = scene_timer*0.05;\n        camera_pos = vec3(20, -10., 80.);\n        camera_target = saturn_pos - camera_move;\n    }\n    else if(current_scene == 0){\n        camera_move.x = (scene_timer*0.3)-3.;\n        camera_move.y = (scene_timer*-0.1)+0.5;\n        camera_pos = vec3(0, 0., -150.);\n        camera_target = saturn_pos - camera_move;\n    }\n\n    mat3 matrix = lookat_matrix(camera_pos, camera_target, 0.0);\n    mat3 inv_matrix = inverse(matrix);\n    vec3 view = matrix * normalize(vec3(uv / fov, 1.0));\n    vec3 world_up = matrix * vec3(0.0, 0.0, 1.0);\n\n    MarchOut march_out = march(camera_pos, view);\n    float depth = march_out.depth;\n    vec3 col = vec3(0.);\n\n    vec3 background;\n    bool is_background = false;\n    if(march_out.col < 0.9){\n        float stars_size = 1500.;\n        float stars_number = 0.15;\n        float stars_attenuation = 50.0;\n        float stars = pow(fbm(stars_size * view) + stars_number, stars_attenuation);\n        \n        if(sun_pos.z < camera_pos.z){\n            glow = vec3(0.);\n        }\n        background = vec3(stars) + glow * sun_color;\n        is_background = true;\n    }\n\n    vec3 point = camera_pos+view*depth;\n    vec3 norm = normal(point);\n    vec3 light_pos = sun_pos;\n    float directional_light = lighting(point, norm, light_pos)*1.4;\n\n    vec3 light = vec3(0);\n    vec3 ambient_light = vec3(0.);\n    if(march_out.col == SATURN){\n        vec3 point_t = transform(point, saturn_transform);\n\n        vec3 l = normalize(light_pos+ 2.0*(light_pos-\n                           dot(light_pos, world_up) * world_up));\n        float d1 = dot(norm, -view);\n        float d2 = dot(l, view);\n        float rim_light = d2 * smoothstep( 0.0, 0.1, d1 ) * pow( 1.0 - d1, 3.0 );\n\n        light += ambient_light + directional_light + rim_light*vec3(1.7, 2.3, 5.)/10.;\n\n        float atmosphere = sin((\n         perlin_noise(vec3(0, point_t.y, 0)*3.)\n         + perlin_noise(point_t*2.)/10.\n         + perlin_noise(point_t*5.)/20.\n         + perlin_noise(point_t*10.)/20.\n         )*20.);\n\n        col = vec3(\n        mix(vec3(0.82, 0.678, 0.451),\n            vec3(0.773, 0.624, 0.38), atmosphere));\n    }\n    else if(march_out.col == RINGS){\n        vec3 point_t = transform(point, ring_transform);\n        light += ambient_light + directional_light;\n\n        float ring =\n        sin(distance(vec3(0.), point_t)*10.)*4. +\n        sin(distance(vec3(0.), point_t)*80.)*1.\n        ;\n\n        col = vec3(\n        mix(vec3(0.357, 0.325, 0.275)*1.1,\n            vec3(0.494, 0.443, 0.376)*0.94, ring));\n    }\n    else if(march_out.col == SUN){\n        light = vec3(10.0);\n        col = sun_color;\n    }\n    col *= light;\n\n    if(is_background){\n        col = background;\n    }\n\n    vec2 sun_screenspace = (inv_matrix*((\n        sun_pos-camera_pos)/(distance(camera_pos, sun_pos)))).xy*fov;\n \n    if(sun_pos.z > camera_pos.z){\n        col += flare(uv, sun_screenspace)/10.;\n        col += glare(uv, sun_screenspace)/10.;\n    }\n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Transform {\n    vec3 pos;\n    vec3 rot;\n};\n\nfloat hash(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p){\n    vec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3){\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash32(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec4 hash42(vec2 p){\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nfloat perlin_noise(vec3 p){\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm(vec3 p){\n    float f;\n    f  = 0.5000 * perlin_noise(p); p *= 2.1;\n    f += 0.2500 * perlin_noise(p); p *= 2.2;\n    f += 0.1250 * perlin_noise(p); p *= 2.3;\n    f += 0.0625 * perlin_noise(p);\n    return f;\n}\n\nmat3 lookat_matrix(vec3 origin, vec3 target, float roll) {\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nmat3 rotateX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotateY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotateZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nvec3 rotate(vec3 p, vec3 angles) {\n    mat3 m = rotateX(angles.x) * rotateY(angles.y) * rotateZ(angles.z);\n    return p*m;\n}\n\nvec3 transform(vec3 p, Transform t){\n    vec3 p_ = p-t.pos;\n    p_ = rotate(p_, t.rot);\n    return p_;\n}\n\nvec3 translate(vec3 p, vec3 t){\n    return p+t;\n}\n\n// thanks mu6k https://www.shadertoy.com/view/4sX3Rs\nvec3 flare(vec2 uv,vec2 pos)\n{\n\tvec2 uvd = uv*(length(uv));\n\t\t\n\tfloat f0 = 2.0/(length(uv-pos)*20.0+1.0);\n\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tuvx = mix(uv,uvd,-.4);\n\t\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\t\n\tuvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r += f2+f4+f5+f6;\n    c.g += f22+f42+f52+f62;\n    c.b += f23+f43+f53+f63;\n\tc = f0 + c*7.5 - vec3(length(uvd)*.1);\n\n\treturn c;\n}\n\nfloat glare(vec2 uv, vec2 pos){\n    vec2 main = uv-pos;\n\tfloat ang = atan(main.y, main.x);\t\n\tfloat f0 = 0.5/(length(uv-pos)*10.0);\n    return f0*(sin((ang)*6.0)*0.5+2.5);\n}","name":"Common","description":"","type":"common"}]}