{"ver":"0.1","info":{"id":"XlXfWs","date":"1514150746","viewed":155,"name":"Ray-marched Reflective Spheres","username":"jchabin1","description":"It's a bunch a spheres its pretty sick","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarcing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float EPSILON = 0.00001;\n\nfloat sphere(vec3 p, vec3 pos, float size){\n    return length(p - pos) - size;\n}\n\nfloat box(vec3 p, vec3 pos, vec3 size){\n    return length(max(abs(p - pos) - size, 0.0));\n}\n\nfloat sceneDist(vec3 p){\n    return sphere(mod(p, 2.0), vec3(1.0, 1.0, 1.0), 0.3 + 0.3 * sin(iTime));\n}\n\nvec3 getNormal(vec3 p){\n    float EPSILON = EPSILON * 100.0;\n    return normalize(vec3(\n        sceneDist(vec3(p.x + EPSILON, p.y, p.z)) - sceneDist(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneDist(vec3(p.x, p.y + EPSILON, p.z)) - sceneDist(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneDist(vec3(p.x, p.y, p.z  + EPSILON)) - sceneDist(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mouse;\n    if(iMouse.z > 0.0)\n    \tmouse = vec2(iMouse.x / iResolution.x * 2.0 - 1.0, iMouse.y / iResolution.y * 2.0 - 1.0);\n    else\n        mouse = vec2(0.0);\n    vec2 cameraAngle = vec2(-PI / 4.0 + iTime * 0.1 + PI * mouse.x, PI * mouse.y);\n\tvec3 camera = vec3(0.0, iTime, 0.0);\n    float fov = PI / 2.0;\n    \n    vec2 pos = vec2((2.0 * (fragCoord.x / iResolution.x) - 1.0), (2.0 * (fragCoord.y / iResolution.y) - 1.0) / iResolution.x * iResolution.y);\n    \n    float t = 0.0;\n    vec3 direction = normalize(vec3(sin(pos.x * fov + cameraAngle.x), sin(pos.y * fov + cameraAngle.y), cos(pos.x * fov + cameraAngle.x) * cos(pos.y * fov + cameraAngle.y)));\n    \n    vec4 color = texture(iChannel0, direction); // Sky color\n    color = vec4(0.0);\n    \n    vec3 p = camera;\n    vec3 light = vec3(sin(iTime), 0.0, cos(iTime));\n    for(t = 0.0; t < 75.0; t++){\n        float dist = sceneDist(p);\n        if(dist < EPSILON){\n            vec3 normal = getNormal(p);\n            direction = reflect(direction, normal);\n            //direction = refract(normalize(direction), getNormal(p), 1.0 / 1.5);\n            color = mix(color, vec4(dot(normalize(light), getNormal(p))), 0.5);\n            color = mix(color, texture(iChannel0, direction), 0.5);\n            dist += EPSILON;\n        }\n        p = p + dist * direction;\n    }\n            \n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}