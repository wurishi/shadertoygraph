{"ver":"0.1","info":{"id":"fd3Szj","date":"1633474669","viewed":231,"name":"isp-glassball-12-mix","username":"harry7557558","description":"Experimental.\nhttps://github.com/harry7557558/Shadertoy/tree/master/isp-glass","likes":10,"published":1,"flags":32,"usePreview":1,"tags":["scattering","emission","henyeygreenstein","glassball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork https://www.shadertoy.com/view/NscXRj\n\nvoid mainImage(out vec4 c, in vec2 g) {\n    c = texelFetch(iChannel0, ivec2(g), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926\n#define ZERO min(iTime, 0.)\n\n\nuint seed = 0u;\nuint randu() { return seed = seed * 1664525u + 1013904223u; }\nfloat rand01() { return float(randu()) * (1./4294967296.); }\n\n\n\nvec3 light(vec3 rd) {\n    vec3 col = texture(iChannel1, rd.yzx).xyz;\n    vec3 bri = vec3(1.0) + vec3(1.0) * pow(max(dot(rd, normalize(vec3(-0.2, -0.5, 0.5))), 0.), 4.);\n    return 0.1 * col * bri;\n}\n\n\n// sphere intersection function\nbool intersectSphere(vec3 o, float r, vec3 ro, vec3 rd,\n        inout float t, inout vec3 n) {\n    ro -= o;\n    float b = -dot(ro, rd), c = dot(ro, ro) - r * r;\n    float delta = b * b - c;\n    if (delta < 0.0) return false;\n    delta = sqrt(delta);\n    float t1 = b - delta, t2 = b + delta;\n    if (t1 > t2) t = t1, t1 = t2, t2 = t;\n    if (t1 > t || t2 < 0.) return false;\n    t = t1 > 0. ? t1 : t2;\n    n = normalize(ro + rd * t);\n    return true;\n}\n\n\n// scattering / importance sampling functions\n\nvec3 sampleCosWeighted(vec3 n) {\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    float rn = rand01();\n    float an = 2.0*PI*rand01();\n    vec2 rh = sqrt(rn) * vec2(cos(an), sin(an));\n    float rz = sqrt(1. - rn);\n    return rh.x * u + rh.y * v + rz * n;\n}\n\nvec3 sampleFresnelDielectric(vec3 rd, vec3 n, float n1, float n2) {\n    float eta = n1 / n2;\n    float ci = -dot(n, rd);\n    if (ci < 0.0) ci = -ci, n = -n;\n    float ct = 1.0 - eta * eta * (1.0 - ci * ci);\n    if (ct < 0.0) return rd + 2.0*ci*n;\n    ct = sqrt(ct);\n    float Rs = (n1 * ci - n2 * ct) / (n1 * ci + n2 * ct);\n    float Rp = (n1 * ct - n2 * ci) / (n1 * ct + n2 * ci);\n    float R = 0.5 * (Rs * Rs + Rp * Rp);\n    return rand01() > R ?\n        rd * eta + n * (eta * ci - ct)  // refraction\n        : rd + 2.0*ci*n;  // reflection\n}\n\nvec3 sampleUniformSphere() {\n    float u = 2.0*PI*rand01();\n    float v = 2.0*rand01()-1.0;\n    return vec3(vec2(cos(u), sin(u))*sqrt(1.0-v*v), v);\n}\n\nvec3 sampleHenyeyGreenstein(vec3 wi, float g) {\n    if (g == 0.0) return sampleUniformSphere();\n    if (g >= 1.0) return wi;\n    if (g <= -1.0) return -wi;\n    float us = rand01();\n    float vs = 2.0*PI*rand01();\n    float z = (1.0+g*g-pow((1.0-g*g)/(2.0*g*(us+(1.0-g)/(2.0*g))),2.0))/(2.0*g);\n    vec2 xy = vec2(cos(vs), sin(vs)) * sqrt(1.0-z*z);\n    vec3 u = normalize(cross(wi, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, wi);\n    vec3 wo = normalize(xy.x*u + xy.y*v + z*wi);\n    return wo;\n}\n\n\n\nconst int mat_none = -1;\nconst int mat_background = 0;\nconst int mat_lambertian = 1;\nconst int mat_refractive = 2;\n\n\n// https://www.shadertoy.com/view/XljGzV\nvec3 hsl2rgb(float h, float s, float l) {\n    vec3 rgb = clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return l + s * (rgb-0.5)*(1.0-abs(2.0*l-1.0));\n}\n// https://www.shadertoy.com/view/Nd33zB\nvec3 ryb2rgb(vec3 ryb) {\n    const vec3 ryb000 = vec3(1, 1, 1);\n    const vec3 ryb001 = vec3(0.163, 0.373, 0.6);\n    const vec3 ryb010 = vec3(1, 1, 0);\n    const vec3 ryb100 = vec3(1, 0, 0);\n    const vec3 ryb011 = vec3(0, 0.66, 0.2);\n    const vec3 ryb101 = vec3(0.5, 0, 0.5);\n    const vec3 ryb110 = vec3(1, 0.5, 0);\n    const vec3 ryb111 = vec3(0, 0, 0);\n    return mix(mix(\n        mix(ryb000, ryb001, ryb.z),\n        mix(ryb010, ryb011, ryb.z),\n        ryb.y), mix(\n        mix(ryb100, ryb101, ryb.z),\n        mix(ryb110, ryb111, ryb.z),\n        ryb.y), ryb.x);\n}\n\n// play around this\nvoid calcAbsorb(in vec3 p, out vec3 emi, out vec3 tabs, out vec3 sabs, out float k, out float g) {\n    p -= vec3(0, 0, 1);  // center of sphere\n    emi = vec3(0.0);\n    vec3 q = p;\n    float a = 0.4*q.z;\n    q.xy = mat2(cos(a), -sin(a), sin(a), cos(a)) * q.xy;\n    vec3 c = mix(vec3(0.8,0.2,0.1), vec3(0.1,0.2,0.8), 0.5+0.5*q.z);\n    for (float i=0.; i<4.; i++) {\n        float d = 0.5+0.5*asin(sin(6.0*atan(q.y, q.x)));\n        float r = length(q);\n        if (d<0.05 && r<1.0) emi += 30.0*exp2(i)*c * max(vec3(-1.6)+vec3(2.)*r+vec3(0.2)*cos(20.*PI*r), vec3(0.));\n        q *= 2.0;\n        c = mix(c, vec3(0,1,0.5), 0.2);\n    }\n    tabs = vec3(0.0);\n    sabs = vec3(1.0);\n    k = 0.0;\n    g = 0.5;\n}\n\nvoid calcScatter(in vec3 ro, inout vec3 rd,\n        inout float mt, inout vec3 m_col, out vec3 m_emi, out int material, inout vec3 min_n) {\n    float p = 1.0, hit_p = rand01();\n    float dt = 0.015;\n    m_emi = vec3(0.0);\n    for (float t = 1e-4; t < mt-dt; t += dt) {\n        vec3 emi, tabs, sabs; float k, g;\n        calcAbsorb(ro + rd * (t+0.5*dt), emi, tabs, sabs, k, g);\n        float dp = exp(-k*dt);\n        if (p * dp < hit_p) {\n            dt *= log(p/hit_p)/k;\n            mt = t + dt;\n            rd = sampleHenyeyGreenstein(rd, g);\n            m_col *= sabs * exp(-tabs*dt);\n            material = mat_none;\n            min_n = vec3(0.0);\n            return;\n        }\n        p *= dp;\n        m_col *= exp(-tabs*dt);\n        m_emi += m_col * emi * dt;\n    }\n    material = mat_refractive;\n}\n\n\nvec3 mainRender(vec3 ro, vec3 rd) {\n\n    vec3 m_col = vec3(1.0), t_col = vec3(0.0), col;\n    bool is_inside = false;\n\n    for (int iter = int(ZERO); iter < 128; iter++) {\n        ro += 1e-4f*rd;\n        //if (is_inside != (length(ro-vec3(0,0,1))<1.0)) return vec3(1, 0, 0);\n\n        vec3 n, min_n;\n        float t, min_t = 1e12;\n        vec3 min_ro = ro, min_rd = rd;\n        vec3 min_emi = vec3(0.0);\n        int material = mat_background;\n\n        // plane\n        t = -ro.z / rd.z;\n        if (t > 0.0) {\n            min_t = t, min_n = vec3(0, 0, 1);\n            min_ro = ro + rd * t, min_rd = rd;\n            col = vec3(0.9, 0.95, 0.98);\n            material = mat_lambertian;\n        }\n\n        // object\n        t = min_t;\n        if (intersectSphere(vec3(0.0, 0.0, 1.0), 1.0, ro, rd, t, n)) {\n            min_t = t, min_n = n;\n            if (is_inside) {\n                col = vec3(1.0);\n                min_rd = rd;\n                calcScatter(ro, min_rd, min_t, col, min_emi, material, min_n);\n                min_ro = ro + rd * min_t;\n            }\n            else {\n                min_ro = ro + rd * t, min_rd = rd;\n                col = vec3(1.0);\n                material = mat_refractive;\n            }\n        }\n\n        // update ray\n        if (material == mat_background) {\n            col = light(rd);\n            return m_col * col + t_col;\n        }\n        ro = min_ro, rd = min_rd;\n        min_n = dot(rd, min_n) < 0. ? min_n : -min_n;  // ray hits into the surface\n        if (material == mat_lambertian) {  // diffuse\n            rd = sampleCosWeighted(min_n);\n        }\n        else if (material == mat_refractive) {  // steel ball\n            vec2 eta = is_inside ? vec2(1.5, 1.0) : vec2(1.0, 1.5);\n            rd = sampleFresnelDielectric(rd, min_n, eta.x, eta.y);\n        }\n        m_col = m_col * col;\n        t_col += min_emi;\n        if (dot(rd, min_n) < 0.0) {\n            is_inside = !is_inside;\n        }\n    }\n    return m_col + t_col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // random number seed\n    seed = uint(fragCoord.x)*uint(fragCoord.y)*uint(iFrame+1);\n    seed = randu() + 161u*uint(fragCoord.y);\n    seed = randu() + 239u*uint(fragCoord.x);\n    seed = randu() + 197u*uint(iFrame+1);\n\n    // camera\n    float rx = iMouse.z==0.?0.3:2.0*(iMouse.y/iResolution.y)-0.5;\n    float rz = iMouse.z==0.?-1.2:-iMouse.x/iResolution.x*4.0*3.14;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = 10.0*w + vec3(0, 0, 0.7);\n    vec2 uv = 2.0*(fragCoord.xy+vec2(rand01(),rand01())-0.5)/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 3.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    // calculate pixel color\n    vec3 col = mainRender(ro, rd);\n    vec4 rgbn = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z>0.) rgbn.w = 0.0;\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)/(rgbn.w+1.0), rgbn.w+1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}