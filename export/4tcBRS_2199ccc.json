{"ver":"0.1","info":{"id":"4tcBRS","date":"1540194431","viewed":243,"name":"3d painting","username":"lucastakejame","description":"[WIP]\nUsing a pseudo volume texture (in buffer A) to paint in 3d.\n\npainting:\nmouse button : paint\nU : red +\nJ : red -\nI : green +\nK : green -\nO : blue +\nL : blue -\nHold E : eraser\n\ncam control:\nA , D : rotation\nW, S : height\n\nR : reset\nP : show PVT buffer","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["3d","paint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float uvRatio = iResolution.x/iResolution.y;\n\tnMuv = iMouse.xy/iResolution.y - vec2(uvRatio/2., .5);\n\n    vec2 cellSzNorm = vec2(uvRatio/grid.x, 1./grid.y);\n    vec2 uv = fragCoord/iResolution.y - vec2(uvRatio/2., .5);\n\n   \t// reading inputs\n    float yaw = texelFetch(iChannel1, yawPixel, 0).x;\n    float height = texelFetch(iChannel1, heightPixel, 0).x;\n    \n\tcamUpdate(yaw, height, uvRatio, uv, ro, rd, camForward, camUp, camRight);\n    \n    float brushSize = texelFetch(iChannel1, brushSizePixel, 0).x; \n    \n   \tvec3 rdMouse = normalize( (ro + camForward*tan30*uvRatio/2.) \n                               + camRight*nMuv.x\n                               + camUp * nMuv.y\n                               - ro );\n    \n    bool showPVT = texelFetch(iChannel1, showPVTPixel, 0).x > 0.5;\n\n    // TODO: start tracing from intersection of volumebox and ray.\n    \n    // Ray tracing\n    for(float dist = traceInit; dist < traceEnd; dist += traceStep)\n    {\n        // read current voxel color\n\t    vec3 voxPos = ro + rd*dist;\n    \tvec4 color;\n    \tvoxColor(iChannel0, cellSzNorm, voxPos, color);\n        \n        \n        if(isVoxInBrush(iChannel0, cellSzNorm, brushSize, voxPos, ro, rdMouse))\n        {\n            fragColor = vec4(voxPos, 1.);\n\n            break;\n        }\n        else if(isPainted(color))\n        {\n            \n            // TODO: find way to get normal from PVT instead of SDF scene\n            // maybe use blank pixels to store distance field.\n            vec3 n = grad(voxPos);\n            \n            // normalize color to homogenize shading\n           \tfragColor = abs( normalize(color)*vec4(dot(n, normalize(lightPos - voxPos))) )\n                \t+ abs( normalize(color)*vec4(dot(n, normalize(lightPos2 - voxPos))) );\n\n            // without light\n            // fragColor = color;\n            break;\n        }\n        else\n        {\n            fragColor = vec4(.6,.2,.5,0.);\n        }\n    }\n    \n    // Show brush colow in screen left bottom corner\n    if(length(fragCoord) < 20.)\n    {\n\t\tfragColor = texelFetch(iChannel1, brushColorPixel, 0);;\n    }\n    \n    // show buffer A\n\tif(showPVT)\n    {\n    \tfragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    }\n    \n    // show buffer B\n\t// fragColor = texture(iChannel1, fragCoord.xy/iResolution.xy);\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Display Pseudo Volume Texture created from fScene\n\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel2, vec2(key, 0.5/3.) ).x > 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalizing axis Y\n\tfloat uvRatio = iResolution.x/iResolution.y;\n\n    // cell size normalized (to y axis)\n\tvec2 cellSzNorm = vec2(uvRatio/grid.x, 1./grid.y);\n    \n    // pixel coordinates mapped to x:[-uvRatio/2., uvRatio/2.] and y:[-.5, .5]\n    vec2 uv = fragCoord/iResolution.y - vec2(uvRatio/2., .5);\n    \n    nMuv = iMouse.xy/iResolution.y - vec2(uvRatio/2., .5);\n\n    // gets position in Voxel space of this uv \n    vec3 voxPos;\n   \tuvToVox(uv, cellSzNorm, voxPos);\n    \n    \n    // reading inputs\n    float yaw = texelFetch(iChannel1, yawPixel, 0).x;\n    float height = texelFetch(iChannel1, heightPixel, 0).x;\n    bool reset = isKeyPressed(KEY_R);\n    brushColor = texelFetch(iChannel1, brushColorPixel, 0);\n\n    float brushSize = texelFetch(iChannel1, brushSizePixel, 0).x; \n    \n   \n    // update cam variables to get where cam is on Image tab\n    camUpdate(yaw, height, uvRatio, uv, ro, rd, camForward, camUp, camRight);\n    \n   \tvec3 rdMouse = normalize( (ro + camForward*tan30*uvRatio/2.) \n                               + camRight*nMuv.x\n                               + camUp * nMuv.y\n                               - ro );\n    \n    // draws scene to PVT then keeps reading itself to record changes\n    if(iFrame == 0 || reset)\n    {\n\t \tfragColor = (fScene(voxPos) <= 0.0 )? vec4(1.): vec4(0.);\n    }\n    else\n    {\n        \n        if(iMouse.z > 0. \n           && isVoxInBrush(iChannel0, cellSzNorm, brushSize, voxPos, ro, rdMouse))\n        {\n            fragColor =  ( !isKeyPressed(KEY_E) )? brushColor: vec4(0.,0.,0.,0.) ;\n        }\n        else\n        {\n        \tfragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n        }\n        \n        \n        \n        // debug pvt\n        \n        // making volume ranges fit in [0,1]\n        voxPos += volumeExtent;\n       \tvoxPos /= volumeExtent*2.;\n        \n        //fragColor = vec4(vec3(voxPos), 1.);\n        //fragColor = (voxPos.x > 0.5)?vec4(1.):vec4(0.,0.,0.,1.);\n\t}\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// location in texture buffer B where these infos are stored\nconst ivec2 yawPixel = ivec2(0,0);\nconst ivec2 heightPixel = ivec2(1,0);\nconst ivec2 brushColorPixel = ivec2(2, 0);\nconst ivec2 brushSizePixel = ivec2(3, 0); // distance from camera\nconst ivec2 showPVTPixel = ivec2(4, 0);\n\n\n// number of columns and rows of cell grid\nconst vec2 grid = vec2(16., 9.);\nconst float nCells = grid.x*grid.y;\n\nconst vec3 volumeExtent = vec3(.5, .5, .5);\n\nconst float tan30 = sqrt(3.)/3.; \nconst float M_PI = 3.1415;\n\n// epsilon on normal calculation\nconst float EPS = .01;\n\nconst vec3 lightPos = vec3(2., 2., 2.);\nconst vec3 lightPos2 = vec3(-2., -2., -2.);\n\n// trace distance from camera\nconst float traceInit = .8;\nconst float traceEnd = 3.;\n// The bigger the step, faster rendering, lower quality\nfloat traceStep = .01;\n\n// Camera vars, need to be calculated on buffer A and Image\nvec3 ro;\nvec3 rd;\nvec3 camForward;\nvec3 camUp;\nvec3 camRight;\n\n\n// mouse coordinate that will be mapped into x:[-uvRatio/2.,uvRatio/2.] and y:[-.5, .5]\nvec2 nMuv;\n\n// Used to change color of voxel in pvt texture\nfloat brushRadius = .003;\nvec4 brushColor;\n\n\nfloat map(float v, float min0, float max0, float min1, float max1)\n{\n    return (v-min0)*(max1-min1)/(max0-min0) + min1;\n}\n\nbool isPainted(vec4 color)\n{\n    return color.a > .0;\n}\n\nvoid camUpdate(in float yaw, in float pitch, in float uvRatio, in vec2 uv, out vec3 ro, out vec3 rd, out vec3 camForward, out vec3 camUp, out vec3 camRight )\n{\n    float initialDist = -uvRatio/1. - .15;\n    \n    //rotate yaw and pitch around origin\n    float sinYaw = sin(yaw);\n    float cosYaw = cos(yaw);\n    float sinPitch = sin(pitch);\n    float cosPitch = cos(pitch);\n    ro = vec3(initialDist*cosPitch*cosYaw, initialDist*cosPitch*sinYaw, initialDist*sinPitch);\n        \n        \n    // cam always looking to origin\n    camForward = normalize(-ro);\n    camUp =\t\t normalize( \n        \t\t\t\t\tvec3(0.,0.,1.)\n                          - dot(camForward, vec3(0.,0.,1.))*normalize(camForward) \n                          );\n    camRight = -cross(camForward, camUp);\n \t\n    rd = normalize( (ro + camForward*tan30*uvRatio/2.) \n                        + camRight*uv.x\n                        + camUp * uv.y\n                        - ro );\n}\n\n\n\n//Let this pseudo volume texture contain slices of a volume\n//1 slice at the top, 1 at the bottom and the other (slicesPerSide^2)-2 in between equally spaced\n\n// Sample voxel color with interpolating PVT layers\nvoid voxColor(in sampler2D chan, in vec2 cellSzNorm, in vec3 voxPos, out vec4 color)\n{\n    float uvRatio = cellSzNorm.x*grid.x;\n        \n    // if out of bounds\n    if(!( -volumeExtent.x <= voxPos.x && voxPos.x <= volumeExtent.x\n       && -volumeExtent.y <= voxPos.y && voxPos.y <= volumeExtent.y\n       && -volumeExtent.z <= voxPos.z && voxPos.z <= volumeExtent.z) )\n    {\n        color = vec4(0.);\n        return;\n    }\n    \n    // uv inside cell and mapped to x:[0, uvRatio] y:[0,1.]\n    // considering voxPos.xy is in x:[-volumeExtent.x, volumeExtent.x] y:[-volumeExtent.y, volumeExtent.y]\n    vec2 localUV = ((voxPos.xy + volumeExtent.xy)/(2.*volumeExtent.xy))\n        \t\t\t*cellSzNorm;    \n    \n    \n \tfloat zLayer = (voxPos.z + volumeExtent.z)*(nCells - 1.)/(2.*volumeExtent.z);\n    \n    // index of first layer to be interpolated\n    float zLayer0 = trunc(zLayer);\n\t\n\t// index of second layer to be interpolated, clamping on last one\n    float zLayer1 = clamp(zLayer0 + 1., 0., nCells-1.);\n    \n    // alpha of interpolation\n\tfloat zLayerInter = fract(zLayer);\n    \n\t\n    vec2 layerOffset0 = vec2(mod(zLayer0, grid.x)*cellSzNorm.x,\n                            trunc(zLayer0/grid.x)*cellSzNorm.y);\n    vec2 layerOffset1 = vec2(mod(zLayer1, grid.x)*cellSzNorm.x,\n                            trunc(zLayer1/grid.x)*cellSzNorm.y);\n\n    // uv.x must be normalized to read texture\n   \tvec2 uv0 = (layerOffset0 + localUV)/vec2(uvRatio, 1.); \n   \tvec2 uv1 = (layerOffset1 + localUV)/vec2(uvRatio, 1.); \n\tvec4 color0 = texture(chan, uv0);\n    vec4 color1 = texture(chan, uv1);\n\n\tcolor = mix(color0, color1, zLayerInter);\n\n}\n\n// Converts uv from PVT to voxel position in a box of extent volumeExtent around origin\n// uv here is expected to be mapped in x:[-uvRatio/2, uvRatio/2], y:[-.5, .5]\nvoid uvToVox(in vec2 uv, in vec2 cellSzNorm, out vec3 voxPos)\n{\n    float uvRatio = cellSzNorm.x*grid.x;\n\n    float columns = grid.x;\n    \n    voxPos.x = fract( (uv.x+uvRatio/2.)/cellSzNorm.x )*2.*volumeExtent.x - volumeExtent.x;\n    \n    voxPos.y = fract( (uv.y+.5)/cellSzNorm.y )*2.*volumeExtent.y - volumeExtent.y;\n    \n    float layer = trunc((uv.x+uvRatio/2.)/cellSzNorm.x) \n        \t\t+ (columns)*trunc((uv.y+.5)/cellSzNorm.y);\n    \n    voxPos.z = ( layer/(nCells - 1.) )*2.*volumeExtent.z - volumeExtent.z;\n\n}\n\n\n// decides if given voxel is inside brush volume\nbool isVoxInBrush(sampler2D chan, vec2 cellSzNorm, float brushSize, vec3 voxPos, vec3 ro, vec3 rdMouse)\n{\n    // TODO: Find better way to use brush on surface only        \n    // current vox color\n    vec4 colorVox0;\n    voxColor(chan, cellSzNorm, voxPos, colorVox0);\n\n    // next vox in rdMouse direction color\n    vec4 colorVox1;\n    voxColor(chan, cellSzNorm, voxPos + rdMouse*brushRadius/20., colorVox1);\n\n    // previous vox in rdMouse direction color\n    vec4 colorVox2;\n    voxColor(chan, cellSzNorm, voxPos - rdMouse*brushRadius/12., colorVox2);\n\n\n    // TODO: Think of way to paint slower\n    // maybe work adding alpha values\n    bool draw = //!isPainted(colorVox0) \n        \t\t//&& \n        isPainted(colorVox1)\n        && \n        dot(voxPos-ro, vec3(0.) - ro) > 0.\n        \t //!isPainted(colorVox2) && isPainted(colorVox0)\n        ;\n\n    // mouse cone apperture\n    float inMouseDir = dot(normalize(rdMouse), normalize(voxPos-ro));\n    \n    return inMouseDir >= (1.-brushSize) && draw;\n}\n\n\n// SDF function of sphere\nfloat fSphere(vec3 p, float radius)\n{\n    return distance(p, vec3(0.))-radius;\n}\n\nfloat fScene(vec3 p)\n{\n    return fSphere(p, .3);\n}\n\n// This will return the normal in the SDF fScene\nvec3 grad(vec3 p)\n{\n    return normalize( vec3(\n    \tfScene(p + vec3(EPS, 0., 0.)) - fScene(p - vec3(EPS, 0., 0.)),\n    \tfScene(p + vec3(0., EPS, 0.)) - fScene(p - vec3(0., EPS, 0.)),\n    \tfScene(p + vec3(0., 0., EPS)) - fScene(p - vec3(0., 0., EPS))\n    ) );\n}\n\n///// KeyBoard reading stuff\n// key definitions stolen from : https://www.shadertoy.com/view/Xst3zX\n\n// list of keys coordinates\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\n\n    \n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This texture will keep track of input values\n\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel0, vec2(key, 0.5/3.) ).x > 0.;\n}\n\n/*\nUsing a pseudo volume texture (in buffer A) to paint in 3d.\n\npainting:\nmouse button : paint\nU : red +\nJ : red -\nI : green +\nK : green -\nO : blue +\nL : blue -\nE : eraser\n\ncam control:\nA , D : rotation\nW, S : height\n\nR : reset\nP : show PVT buffer\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy/iResolution.xy;\n    ivec2 iCoord = ivec2(fragCoord);\n    \n    if(iCoord == yawPixel)\n    {\n        float yaw = mod(\n            texture(iChannel1, uv).x\n            + float(isKeyPressed(KEY_A))*-.05\n\t\t\t+ float(isKeyPressed(KEY_D))*.05, 2.*M_PI);\n        \n        fragColor = vec4(yaw, 0., 0., 1.);\n    }\n    else if(iCoord == heightPixel)\n    {\n        float height = clamp(\n            texture(iChannel1, uv).x\n            + float(isKeyPressed(KEY_W))*-.1\n\t\t\t+ float(isKeyPressed(KEY_S))*.1, -M_PI*.3, M_PI*.3);\n        \n        fragColor = vec4(height, 0., 0., 1.);\n    }\n    else if(iCoord == brushColorPixel)\n    {\n        vec4 color = vec4(\n            clamp(texture(iChannel1, uv).x\n            + float(isKeyPressed(KEY_U))*.1\n\t\t\t+ float(isKeyPressed(KEY_J))*-.1, 0., 1.),\n            clamp(texture(iChannel1, uv).y\n            + float(isKeyPressed(KEY_I))*.1\n\t\t\t+ float(isKeyPressed(KEY_K))*-.1, 0., 1.),\n            clamp(texture(iChannel1, uv).z\n            + float(isKeyPressed(KEY_O))*.1\n\t\t\t+ float(isKeyPressed(KEY_L))*-.1, 0., 1.),\n            !isKeyPressed(KEY_E)\n        );\n        \n        fragColor = color;\n    }\n    else if(iCoord == brushSizePixel)\n    {\n        float dist = clamp(texture(iChannel1, uv).x\n            + float(isKeyPressed(KEY_F))*-.0001\n\t\t\t+ float(isKeyPressed(KEY_G))*.0001, 0.0001, 0.01);\n        \n        fragColor = vec4(dist, 0., 0., 1.);\n    }\n    else if(iCoord == showPVTPixel)\n    {\n        fragColor = vec4(isKeyPressed(KEY_P), 0., 0., 1.);\n    }\n    else\n    {\n\t    fragColor = texture(iChannel1, uv);\n    }\n    \n        \n}","name":"Buffer B","description":"","type":"buffer"}]}