{"ver":"0.1","info":{"id":"XdXyz8","date":"1486887992","viewed":471,"name":"Cloudball","username":"Hadyn","description":"Experimenting with 3D noise functions and raymarching.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud","3dnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by hadyn lander\n\n#define STEPS 16\n#define FOV 120.\n#define NEARPLANE 0.0001\n#define UP vec3(0.0, 1.0, 0.0)\n#define SUN_VECTOR normalize(vec3(1,0.65,0))\n\n// I borrowed this useful function from: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// 3D noise by IQ https://www.shadertoy.com/view/Xsl3Dl\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n// knightly's rotated gradient suggestion\nvec3 knightlyHash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\tp = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n#if 1\n\tfloat t=iTime*0.5;\n\tmat2 m=mat2(cos(t),-sin(t), sin(t),cos(t));\n\tp.xz=m*p.xz;\n#endif\n\treturn p;\n}\n\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( knightlyHash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( knightlyHash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( knightlyHash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( knightlyHash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( knightlyHash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( knightlyHash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( knightlyHash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( knightlyHash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fractalNoise( in vec3 pos)\n{\n \tvec3 q = pos + vec3(0, -iTime*0.025, 0);\n    float f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n\n    //f = noise(pos*2.0);\n\tf = smoothstep( -0.7, 0.7, f ); \n    return f;\n}\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n// Based on IQ's tutorial https://iquilezles.org/blog/?p=2411\nvec2 sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(1.0 / 0.0);\n    h = sqrt( h );\n    return vec2(-b - h, -b +h);\n}\n\n\nvoid marchRay( vec3 ro, vec3 rd, inout vec3 finalCol)\n{ \n    \n    vec2 intersect = sphIntersect(ro, rd, vec4(0,0,0.0,1.5));\n    if(intersect.x == 1.0/0.0 || intersect.y < 0.0)\n        return;\n    \n    intersect.x = max(intersect.x, 0.0);\n    ro += rd * intersect.x;    \n    float intersectionLength = (intersect.y - intersect.x);\n    \n    float stepLength = intersectionLength/float(STEPS-1);\n    \n    float density = 0.0;\n    float t = 0.0;\n\tfor( int i=0; i<STEPS; i++ )\n\t{        \n        vec3 p = ro + t*rd;\n        density += smoothstep(0.5, 0.65, fractalNoise(p*0.65));\n        t += stepLength;\n\t}\n    density /= float(STEPS);\n    float edgeDot = abs(dot(rd, normalize(ro)));\n    float edgeFade = 1.0-pow(1.0-edgeDot, 4.0);\n    density *= edgeFade;\n    //density += 0.5*abs(dot(rd, normalize(ro)));\n    density = smoothstep(0.2, 0.65, density);\n    density *= intersectionLength/3.0;\n    \n    // Cloud colour\n    finalCol.rgb = mix(finalCol, vec3(1), density);\n    \n    // Orb shading\n    float orbDot = 0.5+0.5*(dot(SUN_VECTOR, normalize(ro)));\n    finalCol = mix(finalCol, vec3(1.0), 0.5*orbDot*edgeFade*(intersectionLength/3.0) );\n    \n    // Edge halo\n    float edgeRing = 0.75*pow(1.0-abs(2.0*pow(1.0-edgeDot, 2.0)-1.0), 4.0);\n    finalCol = mix(finalCol, vec3(0.5) + 0.5*(finalCol + vec3(0.5)), edgeRing);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 R = iResolution.xy,\n    uv = ( fragCoord - .5*R) / R.y;\n    \n    vec2 mouse = ( iMouse.xy - .5*R) / R.y;\n    mouse *= step(0.0,iMouse.z);\n    \n    float camDist = 1.0/tan(radians(FOV*0.5));\n    \n    vec3 camForward = vec3(0, 0, 1);\n    camForward = mat3(rotationMatrix(UP, mouse.x*-radians(180.0) + iTime*radians(10.0))) * camForward;\n\tvec3 camRight = cross(UP, camForward);\n    camForward = mat3(rotationMatrix(camRight, mouse.y*radians(90.0) )) * camForward;\n\tvec3 camUp = cross(camForward, camRight);\n    vec3 vectorToPixel = vec3(uv.xy,camDist)*NEARPLANE;\n   \tvectorToPixel = (uv.x*camRight + uv.y*camUp + camDist*camForward)*NEARPLANE;\n    vec3 camPosition = camForward * (-2.4 + 0.5*sin(0.1*(iTime-32.0)));\n\n    float skyDot = dot(normalize(vectorToPixel), SUN_VECTOR);\n    // BG gradient:\n    vec3 bgCol = mix(vec3(0.2, 0.1, 0.4), vec3(0.4, 0.6, 1.0), 0.5+0.5*skyDot);\n    // Add sun flare:\n    bgCol = mix( bgCol, vec3(1.15, 1.0, 1.5), pow(max(1.0-degrees(acos(clamp(skyDot, 0.0, 1.0)))*0.015, 0.0), 8.0));\n    vec3 result = vec3(bgCol);\n    marchRay(camPosition, normalize(vectorToPixel), result);\n    //fragColor = vec4(mix(bgCol, result.rgb, result.a), 1.0);\n    fragColor = vec4(result, 1);\n}","name":"Image","description":"","type":"image"}]}