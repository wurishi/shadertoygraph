{"ver":"0.1","info":{"id":"Md3BzN","date":"1524249020","viewed":422,"name":"spiraltest","username":"halcy","description":"set SPEC_INTENS to a high value to make everything look, well, more intense.","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsjXzy","filepath":"https://soundcloud.com/user-188235281/prototyperaptor-awe","previewfilepath":"https://soundcloud.com/user-188235281/prototyperaptor-awe","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Various knobs to twiddle\n#define MIN_DIST 0.001\n#define STEP_MULTIPLIER 0.9\n#define NORMAL_OFFSET 0.01\n#define MAX_STEPS 64\n#define RAY_FUZZ 0.001\n#define SPEC_INTENS 0.7\n\n// Shit sync\n#define BPM 128.0\n#define SPEED (BPM / 60.0) * 3.14 * 0.25\n\n// Palette helper\nvec3 color(float inVal, float glow) {\n\tvec3 col = \n        mix(\n           mix(\n           \tvec3(0.3, 0.3, 0.4),\n           \tvec3(0.2, 0.5, 1.0),\n           \tabs(clamp(inVal - 0.75, 0.0, 0.25)) * 4.0\n           ),\n           vec3(0.5, 1.0, 1.0) * (0.8 + glow * 3.0),\n           abs(clamp(inVal - 0.9, 0.0, 0.1)) * 10.0\n        );\n    return col;\n}\n\n// For fuzzing up rays a little\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// Distance / color combiner\nvec4 distcompose(vec4 dista, vec4 distb, float softness) {\n    float mixfact = clamp(0.5 + 0.5 * (distb.a - dista.a) / softness, 0.0, 1.0);\n    return mix(distb, dista, mixfact) - vec4(0.0, 0.0, 0.0, softness * mixfact * (1.0 - mixfact));\n}\n\n// World\nvec4 distfunc(vec3 pos, float glow) {\n  \tfloat dist = -(length(pos.xy) - 0.4 + cos(pos.z * 20.0 + atan(pos.y, pos.x)) * 0.04);\n    \n    float abspos = pos.z - iTime * 0.2 * SPEED;\n    dist -= texture(iChannel0, vec2((cos(abspos * 1.3) + 1.0) / 2.0, 0.0)).r * 0.1 * SPEC_INTENS;\n    \n    float ranp = sin(pos.z + iTime * 2.0 * SPEED);\n    float line = (length(pos.xy - vec2(0.0, 0.1)) - 0.001) + (ranp > 0.7 ? 0.0 : 1000.0);\n    \n    ranp = sin(pos.z + iTime * 1.7 * SPEED);\n    line = min(line, (length(pos.xy - vec2(-0.2, 0.06)) - 0.001) + (ranp > 0.7 ? 0.0 : 1000.0));\n    \n    ranp = sin(pos.z + iTime * 2.2 * SPEED);\n    line = min(line, (length(pos.xy - vec2(-0.2, -0.11)) - 0.001) + (ranp > 0.7 ? 0.0 : 1000.0));\n    \n    ranp = sin(pos.z + iTime * 2.5 * SPEED);\n    line = min(line, (length(pos.xy - vec2(0.1, -0.2)) - 0.001) + (ranp > 0.7 ? 0.0 : 1000.0));\n    \n    vec4 lines = vec4(0.8, 0.8, 1.0, line);\n    \n        \n    float colsel = cos(sin(atan(pos.y, pos.x) * 5.0 + pos.z * 10.0));\n    float colval = cos(sin(atan(pos.y, pos.x) * 10.0 + pos.z * 20.0));\n\t\n    if(mod(iTime * SPEED, 3.14 * 0.5) < 3.14 * 0.25) {\n    \tglow = glow * (colsel < 0.75 ? 2.0 : 0.2);\n    }\n    else {\n        glow = glow * (colsel > 0.75 ? 2.0 : 0.2);\n    }\n    vec4 tube = vec4(color(colval, glow), dist);\n    return(distcompose(tube, lines, 0.0));\n}\n\n// Renderer\nvec4 pixel(vec2 fragCoord) {\n    float glow = abs(cos(mod(iTime * 2.0 * SPEED, 3.14 / 2.0))) / 3.0;\n    \n    // Screen -1 -> 1 coordinates\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    // Camera as eye + imaginary screen at a distance\n    vec3 eye = vec3(cos(iTime * SPEED) * 0.1, 0.0, iTime * 0.2 * SPEED);\n    vec3 lookat = vec3(cos(iTime * SPEED) * 0.1, 0.0, iTime * 0.2 * SPEED + 1.0);\n    vec3 lookdir = normalize(lookat - eye);\n    vec3 left = normalize(cross(lookdir, vec3(cos(iTime * 0.1 * SPEED), -sin(iTime * 0.1 * SPEED), 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    vec3 ray = normalize(pixelpos - eye);\n    ray += hash33(ray) * RAY_FUZZ;\n    \n    vec3 lightpos = vec3(eye.x, eye.y, eye.z + 0.8);\n    \n    // March\n    vec3 pos = eye;\n    float dist = 0.0;\n    float curdist = 1.0;\n    float iters = float(MAX_STEPS);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        curdist = distfunc(pos, glow).a;\n        dist += curdist * STEP_MULTIPLIER;\n        pos = eye + ray * dist;\n        if(curdist < MIN_DIST) {\n        \titers = float(i);\n            break;\n        }\n    }\n    \n    vec3 shadowray = normalize(lightpos - pos);    \n    vec2 d = vec2(NORMAL_OFFSET, 0.0);\n    vec3 normal = normalize(vec3(\n        distfunc(pos + d.xyy, glow).a - distfunc(pos - d.xyy, glow).a,\n        distfunc(pos + d.yxy, glow).a - distfunc(pos - d.yxy, glow).a,\n        distfunc(pos + d.yyx, glow).a - distfunc(pos - d.yyx, glow).a\n    ));\n    float light = min(1.0, max(0.0, dot(normal, shadowray)) + 0.01);\n    vec4 color = light * distfunc(pos, glow);\n    color = color + vec4(0.5, 1.0, 1.0, 1.0) * iters * 0.05 * glow;\n\treturn(color);\n}\n\n// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pixel(fragCoord);\n}","name":"Image","description":"","type":"image"}]}