{"ver":"0.1","info":{"id":"XtVBWG","date":"1561906832","viewed":341,"name":"snowoman","username":"lovelyH","description":"Winter shader with female snowman (snowoman).\nPublished at Nova 2019 demoparty in 4KB gfx category.","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["snow","boobs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// iCam = vec3( 2.15, -7.57, 2.56 );\n/// iCamRX = 1.383\n/// iCamRZ = -0.625\n\n// #define EDITOR_MODE\n//#define DEBUG_MODE\n#ifndef EDITOR_MODE\n#define ANIMATED_MODE\n#endif\n\n#ifdef DEBUG_MODE\n#define E 0.01\n#else\n#define E 0.00001\n#endif\n\n#define INF 1000.0\n\n\n\n\n/// smooth mix\nfloat smoothmix( float val1, float val2, float x){\n\tx= clamp(x,0.0,1.0);\n\treturn mix( val1, val2, -(2.*x*x*x - 3.*x*x) );\n}\n\n/// rand 2d\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n/// classic noise 2d\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n/// rand 1D\n///@todo implementit it right, don't just use 2D, it's overkill\nfloat rand(float a){\n\treturn rand( vec2(a) );\n}\n\n/// classic noise 3d\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat noise(vec3 p){\n\tvec3 a = floor(p);\n\tvec3 d = p - a;\n\td = d * d * (3.0 - 2.0 * d);\n\n\tvec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n\tvec4 k1 = permute(b.xyxy);\n\tvec4 k2 = permute(k1.xyxy + b.zzww);\n\n\tvec4 c = k2 + a.zzzz;\n\tvec4 k3 = permute(c);\n\tvec4 k4 = permute(c + 1.0);\n\n\tvec4 o1 = fract(k3 * (1.0 / 41.0));\n\tvec4 o2 = fract(k4 * (1.0 / 41.0));\n\n\tvec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n\tvec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n\treturn o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n/// FBM (perlin noise) 2D\n///@warning require noise\n#define FBM_NUM_OCTAVES 5\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < FBM_NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n/// FBM (perlin noise) 2D\n/// return value from 0.0 to 1.0\n///@warning require noise\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < FBM_NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n\n\nfloat max3(float a, float b, float c){return max(max(a,b),c);}\nfloat min3(float a, float b, float c){return min(min(a,b),c);}\n\n\n\nfloat mulPower( float power, float value ){ return 1.0 + power * (clamp(value,0.0,1.0) - 1.0); }\n\n\n\nvec2 rot( vec2 p, float l ){\n\tfloat s=sin(l),c=cos(l);\n\treturn vec2(\n\t\tc*p.x - s*p.y,\n\t\ts*p.x + c*p.y\n\t);\n}\n\n\n\nfloat cube(vec3 p, vec3 size){\n\tp= abs(p) - size;\n\treturn min( 0.0, max3( p.x, p.y, p.z ) ) + max( 0.0, length( max( p, 0.0 ) ) );\n}\n\n\nfloat cylinder(vec3 p, float radius, float height ){\n\tp= abs(p);\n\tvec2 ph= vec2( length(p.xy) - radius, p.z - height );\n\treturn min( 0.0, max( ph.x, ph.y ) ) + max( 0.0, length( max( ph, 0.0 ) ) );\n}\n\n\n\nfloat cone(vec3 p, float radius, float height){\n\tfloat lpxy= length(p.xy);\n\n\tfloat rc1= length( p - vec3(0,0,height)); /// top\n\tfloat rc2= length( vec2( lpxy - radius, p.z ) ); /// side \n\tfloat rc3; /// more or less inside\n\tfloat rc3h; /// more or less inside\n\tfloat rc3d= length(vec2(radius,height));\n\t{\n\t\tfloat sl= height / rc3d;\n\t\tfloat cl= radius / rc3d;\n\t\t\n\t\tvec2 h= vec2( lpxy - radius, p.z );\n\t\tvec2 h2= vec2(\n\t\t\tcl*h.x - sl*h.y,\n\t\t\tsl*h.x + cl*h.y\n\t\t);\n\n\t\trc3= h2.y;\n\t\trc3h= h2.x;\n\t}\n\n\tif( false ){\n\t}else if(height < p.z ){ /// top\n\t\t// return min( rc1, rc3);\n\t\tif( 0.0 < rc3h + rc3d )\n\t\t\treturn rc3;\n\t\telse\n\t\t\treturn rc1;\n\t}else if( radius < lpxy ){ /// side outside\n\t\tif( p.z <= 0.0 || 0.0 < rc3h ){\n\t\t\treturn rc2;\n\t\t}else{\n\t\t\treturn min( rc2, max( rc3, -p.z) );\n\t\t}\n\t}else if(p.z <= 0.0){ /// bottom\n\t\treturn -p.z;\n\t}else{ /// inside or close to side\n\t\treturn min3( rc3, rc1, rc2);\n\t}\n}\n\n\n\nint mapMatId= 0;\nconst vec3 ghostPos= vec3(-14.5, 16.0, 1.2 );\n\n\n\nfloat map(vec3 p){\n\tvec3 ph;\n\tfloat r, rc;\n\n\t/// ground\n\tmapMatId= 0;\n\tr= p.z;\n\n\t/// snowman balls\n\tph= p-vec3(0,0,0.4);\n\trc= length(ph)-0.5 - 0.05;\n\tph.z -= 0.7;\n\trc= min( rc, length(ph)-0.4 - 0.05 );\n\tph.z -= 0.6;\n\trc= min( rc, length(ph)-0.3 - 0.05 );\n\n\t/// breast\n\tph= p-vec3(0.0,-0.30,1.25);\n\tph.x= abs(ph.x)-0.15;\n\trc= min( rc, length(ph)-0.17 - 0.05);\n\n\t/// snow 2 apply\n\tif( rc < r ){\n\t\tmapMatId= 5;\n\t\tr= rc;\n\t}\n\n\t/// snow modification\n\t#ifndef DEBUG_MODE\n\tr += 0.1 * fbm( p*1.9 );\n\t#endif\n\n\t/// nose\n\tph= p - vec3( -0.0, -0.1, 1.7 );\n\tph.yz= vec2( ph.z, -ph.y );\n\trc= cone( ph, 0.05, 0.4 ) - 0.02;\n\tif( rc < r ){\n\t\tmapMatId= 2;\n\t\tr= rc;\n\t}\n\n\t/// eyes & lips & nipples\n\tph= p-vec3(0.0,-0.27,1.8); /// eyes\n\tph.x= abs(ph.x)-0.1;\n\trc= length(ph)-0.05;\n\tph= p-vec3(0.0,-0.27,1.55); /// lips\n\tph.x= abs(ph.x)-0.05;\n\trc= min( rc, length(ph)-0.04 );\n\tph.x -= 0.10;\n\tph.y -= 0.03;\n\tph.z -= 0.02;\n\trc= min( rc, length(ph)-0.04 );\n\tph= p-vec3(0.0,-0.47,1.26); /// nipples\n\tph.x= abs(ph.x)-0.18;\n\trc= min( rc, length(ph)-0.04);\n\tif( rc < r ){ /// apply\n\t\tmapMatId= 3;\n\t\tr= rc;\n\t}\n\n\t/// hat\n\tph= p-vec3(0.0,-0.0,1.97);\n\trc= cylinder(ph,0.22,0.02);\n\trc= min( rc, cylinder(ph,0.15,0.2) );\n\tif( rc < r ){ /// apply\n\t\tmapMatId= 7;\n\t\tr= rc;\n\t}\n\n\t/// animal feeder\n\t{\n\t\tph= p- vec3(-6.5,18.0,0.0);\n\t\t\n\t\t/// columns\n\t\tvec3 ph2= ph;\n\t\tph2.xy= abs(ph2.xy) - 0.8;\n\t\trc= cube(ph2,vec3(0.1,0.1,1.0));\n\t\t\n\t\t/// roof\n\t\tph2= ph;\n\t\tph2.x= abs(ph2.x) - 0.5;\n\t\tph2.z -= 1.36;\n\t\tph2.xz= rot( ph2.xz, 0.25*3.141592653589 );\n\t\trc= min( rc, cube(ph2,vec3(0.9,1.1,0.03)));\n\n\t\t/// side walls\n\t\tph2= ph - vec3(0,0,0.6);\n\t\tph2.z= abs(ph2.z) - 0.3;\n\t\tph2.x= abs(ph2.x) - 0.8;\n\t\trc= min( rc, cube(ph2,vec3(0.1,0.9,0.1)));\n\n\t\t/// back wall\n\t\tph2= ph - vec3(0,0,0.6);\n\t\tph2.z= abs(ph2.z) - 0.3;\n\t\tph2.y -= 0.8;\n\t\trc= min( rc, cube(ph2,vec3(0.9,0.1,0.1)));\n\n\t\t/// apply\n\t\tif( rc < r ){\n\t\t\tmapMatId= 4;\n\t\t\tr= rc;\n\t\t}\n\t}\n\n\t/// trees - R.I.P. GPU\n#ifdef DEBUG_MODE\n\tfloat ax=0.0, ay=0.0;\n#else\n\tfor(float ax=-1.0;ax<=1.0;ax++)for(float ay=-1.0;ay<=1.0;ay++)\n#endif\n\t{\n\t\tconst float va= 4.0;\n\t\tph= p;\n\t\tvec3 phi= p;\n\t\tphi.xy= (floor( phi.xy / va ) + vec2(ax,ay) ) * va;\n\n\t\tif( 12.0 < length(phi) )\n\t\t{\n\t\t\tph.xy -= phi.xy;\n\t\t\tph.xy -= va/2.0;\n\t\t\tph.xy += (-1.0 * 2.0*rand(phi.xy)) * va / 6.0;\n\t\t\t\n\t\t\trc= cone( ph, 0.1 + 0.15*rand(phi.xy+0.04), 2.5 + 0.2*rand(phi.xy+0.05) );\n\t\t\tif( rc < r ){\n\t\t\t\tmapMatId= 6;\n\t\t\t\tr= rc;\n\t\t\t}\n\t\t\tph.z -= 0.7 + 0.3*rand(phi.xy+0.01);\n\t\t\trc= cone( ph, 1.0, 1.0 );\n\n\t\t\tph.z -= 0.5 + 0.3*rand(phi.xy+0.02);\n\t\t\trc= min( rc, cone( ph, 0.8, 0.8 ) );\n\n\t\t\tph.z -= 0.4 + 0.3*rand(phi.xy+0.03);\n\t\t\trc= min( rc, cone( ph, 0.6, 0.8 ) );\n\n\t\t\trc -= 0.2;\n\n\t\t\tif( rc < r ){\n\t\t\t\tfloat rcb= rc;\n\t\t\t\t#ifndef DEBUG_MODE\n\t\t\t\t\trc= max( rc, 0.57-fbm(24.0*p) );\n\t\t\t\t#endif\n\t\t\t\tif( rc < r )\n\t\t\t\t{\n\t\t\t\t\tmapMatId= rc==rcb ? 0 : 1;\n\t\t\t\t\tr= rc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/// ghost\n\tph= p - ghostPos;\n\tif( 0.0 < ph.z )\n\t\trc= length(ph);\n\telse\n\t\trc= length(ph.xy);\n\trc -= .5;\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmapMatId= 8;\n\t}\n\n\t/// done\n\treturn r;\n}\n\n\n\n/// https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n\t// float res = 1.0;\n\t// for( float t=mint; t < maxt; )\n\t// {\n\t// \tfloat h = map(ro + rd*t);\n\t// \tif( h<0.001 )\n\t// \t\treturn 0.0;\n\t// \tres = min( res, k*h/t );\n\t// \tt += h;\n\t// }\n\t// return res;\n\n    float res = 1.0;\n    float ph = 1e20;\n    float t= mint;\n    #ifdef DEBUG_MODE\n    for( int a=0;a<0x8;a++)\n    #else\n    for( int a=0;a<0x40;a++)\n    #endif\n    {\n\t\tfloat h = map(ro + rd*t);\n\t\t// if( h < E )\n\t\t// \treturn 0.0;\n\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, 10.0*d/max(0.0,t-y) );\n\t\tph = h;\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\tvec3 p= sp;\n\tfloat dis= map(p);\n\tbool isHit= false;\n\tfloat t= dis;\n\t#ifdef DEBUG_MODE\n\tfor(int a=0;a<0x40;a++)\n\t#else\n\tfor(int a=0;a<0x200;a++)\n\t#endif\n\t{\n\t\tp= sp + t * dir;\n\t\tdis= map(p);\n\t\tif( dis < E ){\n\t\t\tisHit= true;\n\t\t\tbreak;\n\t\t}\n\t\tt += dis;\n\t}\n\n\tif( isHit ){\n\t\tint matId= mapMatId;\n\t\tvec2 h= vec2(0,E);\n\t\tvec3 nor= normalize(vec3(\n\t\t\tmap(p+h.yxx) - map(p-h.yxx),\n\t\t\tmap(p+h.xyx) - map(p-h.xyx),\n\t\t\tmap(p+h.xxy) - map(p-h.xxy)\n\t\t\t));\n\n\t\tfloat cs= 1.0;\n\t\tfor( float d=0.003; d < 0.04; d *=1.5 ){\n\t\t\tcs= min( cs, max( 0.0, map( p + d * nor ) / d ) );\n\t\t}\n\n\t\t/// shadows + dot nor sunDir\n\t\tfloat sun= 1.0;\n\t\tconst vec3 sunDir= normalize( vec3( 0.35, -0.23, 0.9 ) );\n\t\t{\n\t\t\tfloat dsd= dot(nor,sunDir);\n\t\t\tif( dsd < 0.0 ){\n\t\t\t\tsun= 0.0;\n\t\t\t}else{\n\t\t\t\tsun= shadow( p+2.*E*nor, sunDir, 0.01, 50.0, 2.0 );\n\t\t\t\tsun= clamp( sun, 0.0, 1.0 );\n\t\t\t\tsun *= (dsd);\n\t\t\t}\n\t\t}\n\n\t\t/// base color\n\t\tvec3 baseColor= vec3(1);\n\t\tswitch(matId){\n\t\t\tcase 0: baseColor= vec3(.9); break; /// snow 1\n\t\t\tcase 1: baseColor= vec3(.10,.50,.10); break; /// green\n\t\t\tcase 2: baseColor= vec3(.60,.15,.05); break; /// carrot\n\t\t\tcase 3: baseColor= vec3(.30,.30,.30) * fbm( p*28.0 ); break; /// coal\n\t\t\tcase 4: baseColor= vec3(.70,.50,.20); break; /// wood\n\t\t\tcase 5: baseColor= vec3(.9); break; /// snow 2\n\t\t\tcase 6: baseColor= vec3(.20,.13,.05); break; /// tree wood\n\t\t\tcase 7: baseColor= vec3(.25,.15,.30) * mulPower(0.75,fbm(p*19.0)); break; /// hat\n            case 8: return vec3(.15,.01,.01)*pow(clamp( 9.0*(0.1 - length(vec2( abs(rot(p.xy-ghostPos.xy,-0.4).x)-.15, p.z-ghostPos.z))) , 0.0, 1.0 ), 2.0); /// ghost\n\t\t\tdefault: baseColor= vec3(1,0,0); break;\n\t\t}\n\n\t\t/// final result\n\t\treturn baseColor\n\t\t\t* mulPower( 0.5, dot(nor,-dir) )\n\t\t\t* mulPower( 0.13, cs )\n\t\t\t\n\t\t\t* mulPower( mix( 0.8, 0.95, clamp(0.05*length(p), 0.0, 1.0 )), sun )\n\n\t\t\t* mulPower( 1.0, 1.0 / (1.0 + 0.00015*t*t*t) )\n\n\t\t\t* ( matId==0 ? mulPower( ( 0.050*(length(p) + 2.0) ) , fbm(p*0.9) ) : mulPower( 0.4 , fbm(p*4.1) ) )\n\t\t;\n\t}else{\n\t\treturn vec3(0);\n\t}\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t#ifdef EDITOR_MODE\n\tvec3 p= iCam;\n\tfloat rx= iCamRX;\n\tfloat rz= iCamRZ;\n\t#else\n\tvec3 p= vec3(2.1538, -7.57222, 2.560973);\n\tfloat rx= 1.383296;\n\tfloat rz= -0.625;\n\t#ifdef ANIMATED_MODE\n\t{\n\t\tfloat t= (iTime+40.0) * 1.0;\n\t\tp.x += 0.7*sin(t*0.1);\n\t\tp.y += 0.06*cos(t*0.17);\n\t\trz -= 0.15*sin(t*0.1);\n\t\trx += 0.07*sin(t*0.04+0.5);\n\t}\n\t#endif\n\t#endif\n\n\tvec3 dir= normalize( vec3( uv.x, uv.y, -4.0 ) );\n\tdir.yz= rot(dir.yz, rx );\n\tdir.xy= rot(dir.xy, -rz );\n\n\tfragColor.xyz= render( p, dir );\n}\n\n","name":"Image","description":"","type":"image"}]}