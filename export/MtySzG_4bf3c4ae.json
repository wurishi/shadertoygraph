{"ver":"0.1","info":{"id":"MtySzG","date":"1487611335","viewed":170,"name":"Subzero","username":"njo","description":"Wanted to try some terrain and water generation using noise. Here is the result!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","water","ice","terraingeneration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCALE (200.0)\n#define SCALE_INV (1.0/SCALE)\n#define MAX_HEIGHT (SCALE)\n#define WATER_BASE (MAX_HEIGHT * 0.5)\n#define SUN_DIR (normalize(vec3(1.5, 0.8, -1.0)))\n#define SUN_COLOR (vec3(1.0, 1.0, 0.9))\n#define VIEW_DIR (vec3(0.0, 0.0, -1.0))\n#define MAX_DRAW (10.0 * SCALE)\n#define PRECISION (0.01 * SCALE)\n#define WATER 1\n#define LAND 2\n#define SKY 3\n\nfloat noise(vec2 p) {\n    return textureLod(iChannel0, p, 0.0).x;\n}\n\nfloat f(vec2 p) {\n   \tvec2 v = p * 0.0108 * SCALE_INV;\n    float sum = 0.0;\n    float div = 0.0;\n    for (int i = 1; i < 33; i = i * 2) {\n        sum += (1.0 / float(i)) * noise(v * float(i));\n        div += 1.0 / float(i);\n    }\n    \n\tfloat height = sum / div;\n    height = pow(height, 1.2) * 1.1;\n    return height * SCALE;\n}\n\nvec3 get_normal(vec3 p) {\n    float eps = 0.009 * SCALE;\n    vec3 n = vec3( f(vec2(p.x-eps,p.z)) - f(vec2(p.x+eps,p.z)),\n                         2.0*eps,\n                         f(vec2(p.x,p.z-eps)) - f(vec2(p.x,p.z+eps)) );\n    return normalize(n);\n}\n\nvec3 fog(vec3 col, float dist) {\n    //https://iquilezles.org/articles/fog\n    float fog_amount = 1.0 - exp(-dist * SCALE_INV * 0.2);\n    vec3 fog_col = vec3(1.0, 1.0, 1.0);\n    return mix(col, fog_col, fog_amount);  \n}\n\nvec3 terrain_color(vec3 p, vec3 cam_pos, vec3 n) {\n    return vec3(0.55, 0.59 ,0.64) * 1.7;\n    return vec3(1.0);\n    return mix(vec3(1.0), vec3(0.0, 0.0, 0.1), clamp(dot(n, vec3(0.0, -1.0, 0.0)), 0.0, 14.0) );\n}\n\nvec3 sky_color(vec3 dir) {\n \treturn mix(vec3(0.3, 0.6, 0.8), SUN_COLOR, pow(max(dot(dir, SUN_DIR), 0.0), 10.0));\n}\n\nfloat refl_ray(vec3 origin, vec3 dir) {\n    for (float t = 0.0; t < MAX_HEIGHT; t += 1.0) {\n   \t\tvec3 p = origin + dir * t;\n        if (p.y - f(p.xz) < PRECISION) {\n            return t;\n        }\n    }\n    return MAX_HEIGHT;\n}\n\nfloat refr_ray(vec3 origin, vec3 dir) {\n    float t = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 p = t * dir + origin;\n        float h = p.y - f(p.xz);\n        if (h < 0.01) {\n            return t;\n        }\n        t += 0.6 * h;\n    }\n    return t;\n}\nfloat shadow(vec3 ro) {\n    //https://iquilezles.org/articles/rmshadows\n    float res = 1.0;\n    float t = 2.0;\n    float k = 16.0;\n\tfor(int i = 0; i < 64; i++ ){\n\t    vec3 p = ro + t * SUN_DIR;\n        float h = p.y - f(p.xz);\n        float c = k * h / t;\n\n\t\tres = min(res, c);\n\t\tt += 0.25 * h;\n        if(res < 0.001 || p.y > MAX_HEIGHT) {\n            break;\n        }\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n    \nvec3 water_color(vec3 water_pos, vec3 cam_pos, vec3 dir, vec3 n) {\n    vec3 view = normalize(water_pos - cam_pos);\n    vec3 deep_col = vec3(0.0, 0.0, 0.08);\n    vec3 shal_col = vec3(0.0, 0.23, 0.3);\n    \n    vec3 col = mix(deep_col, shal_col, 1.0 - max(dot(-view, n), 0.0));\n\n    vec3 rd = normalize(reflect(dir, n));\n    \n    float t = refl_ray(water_pos, rd);\n    vec3 ter_pos = t * rd + water_pos;\n    vec3 refl_col = t >= MAX_HEIGHT ? sky_color(rd) : terrain_color(ter_pos, cam_pos, get_normal(ter_pos));\n    \n    rd = normalize(refract(dir, n, 3.0/4.0)); \n    t = refr_ray(water_pos, rd);\n    ter_pos = t * rd + water_pos;\n    vec3 refr_col = terrain_color(ter_pos, cam_pos, get_normal(ter_pos));\n    \n    refr_col = mix(refr_col, vec3(0.0, 0.05, 0.0), clamp(length(ter_pos.y - water_pos.y)*0.08, 0.0, 1.0));\n    col = col + mix(refl_col, refr_col, clamp(pow(dot(-view, n), 1.0), 0.0, 1.0));\n    return col;\n}\nfloat wnoise(vec2 p) {\n    //http://www.decarpentier.nl/scape-procedural-basics\n    return 1.0 - abs(textureLod(iChannel0, p, 0.0).x * 2.0 - 1.0);\n}\n\nfloat water_fbm(vec2 p, float time) {\n   \tvec2 v = p * 0.022 * SCALE_INV;\n    float sum = 0.0;\n    float div = 0.0;\n    for (int i = 1; i < 9; i = i * 2) {\n        sum += (1.0 / float(i)) * wnoise(v * float(i) + time * 0.0003);\n        div += 1.0 / float(i);\n    }\n    \n\tfloat height = sum / div;\n    return pow(height , 4.0) * 8.0;\n}\n\nfloat water_level(vec2 p, float time) {\n    return water_fbm(p, time) + WATER_BASE;\n}\n\n\nvec3 get_wn(vec3 p, float time) {\n    float eps = 0.01 * SCALE;\n    vec3 n = vec3(water_level(vec2(p.x-eps,p.z), time) - water_level(vec2(p.x+eps,p.z), time),\n                  2.0*eps,\n                  water_level(vec2(p.x,p.z-eps), time) - water_level(vec2(p.x,p.z+eps), time));\n    return normalize(n);\n}\nvec3 render(vec3 ray_origin, vec3 direction) {\n    float time = iTime * 5.0; \n\tfloat t = 0.0;\n\n    float water_lvl;\n    vec3 col;\n    vec3 p;\n    int type = SKY;\n    vec3 n;\n    for (int i = 0; i < 256; i++) {\n        p = t * direction + ray_origin;\n        water_lvl = water_level(p.xz, time);\n        float tlvl = f(p.xz);\n        float s = max(tlvl, water_lvl);\n        if ((p.y > MAX_HEIGHT && direction.y > 0.0) || t > MAX_DRAW) {\n            break;\n        }       \n        if (p.y - water_lvl < PRECISION) {\n            type = WATER;\n            break;\n        }\n        if (p.y - tlvl < PRECISION) {\n            type = LAND; \n            break;\n        }\n        t += 0.2 * (p.y - s);    \n    }\n    if (type == WATER) {\n        vec3 wpos = vec3(p.x, water_lvl, p.z);\n        n = get_wn(wpos, time);\n        col = water_color(wpos, ray_origin, direction, n);\n        \n    } else if (type == LAND) {\n        n = get_normal(p);\n        col = terrain_color(p, ray_origin, n);\n    } else {\n        col = sky_color(direction);\n    }\n    if (type != SKY) {\n        //https://iquilezles.org/articles/outdoorslighting\n        float sha = shadow(p);\n        float sun = clamp(dot(n, SUN_DIR), 0.0, 1.0);\n        float sky = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n        float ind = clamp(dot(n, normalize(SUN_DIR * vec3(-1.0, 0.0, -1.0))), 0.0, 1.0);\n        vec3 lin = sun * vec3(1.3, 1.3, 1.3) * sha * 0.8;\n        lin += sky * vec3(0.3, 0.3, 0.3);\n        lin += ind * vec3 (0.3, 0.3, 0.3);\n        col = lin * col;\n\n    }\n            \n    return fog(col, length(p - ray_origin));\n}\n                    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float z = -iTime * 20.0;\n    vec2 forward_pos = vec2(1000.0, z - 10.0);\n    vec2 prev_pos = vec2(1000.0, z + 10.0);\n    vec2 cur_pos = vec2(1000.0, z);\n    \n    float height = (max(f(forward_pos),WATER_BASE ) + max(f(prev_pos), WATER_BASE)) * 0.5;\n    vec3 camera_pos = vec3(cur_pos.x, height + 50.0, cur_pos.y);\n    vec3 camera_forward = normalize(vec3(0.0, -0.5, -1.0));\n    vec3 camera_up = normalize(vec3(0.0, 1.0, -0.5));\n    vec3 camera_right = vec3(1.0, 0.0, 0.0);\n \n    // Pixel pos in [-1 + 1/res, 1 - 1/res]\n    vec2 pixel_pos = (2.0*fragCoord.xy - iResolution.xy)/iResolution.xy;\n   \t// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays\n    pixel_pos.x *= iResolution.x / iResolution.y; // Aspect ratio\n\n    vec3 ray_dir = normalize(normalize(camera_forward) + camera_up * pixel_pos.y + camera_right * pixel_pos.x);    \n\n    vec3 ray_origin = camera_pos;\n\n  \tvec3 col = render(ray_origin, ray_dir);  \n    fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}