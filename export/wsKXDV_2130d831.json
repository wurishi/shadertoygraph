{"ver":"0.1","info":{"id":"wsKXDV","date":"1575056769","viewed":436,"name":"Heaven and Hell","username":"adurdin","description":"Thanks to iq for his “Happy Jumping” tutorial video! I followed along, and changed things up to make this, and then norgg collaborated with me on the alternate version.","likes":23,"published":1,"flags":0,"usePreview":1,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by andy durdin and norgg (@adurdin, @norgg)\n// This work is licensed under a Creative Commons\n// Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Based on “Happy Jumping” by Inigo Quilez\n\n#define TERRAIN_DETAIL 1\n#define SKY_DETAIL 1\n#define COLOR_GRADING 1\n\n// input: h in [0,360] and s,v in [0,1] - output: r,g,b in [0,1]\nvec3 hsl2rgb(vec3 c){return mix(c.bbb,mix(clamp(vec3(-1,2,2)-abs(c.r-vec3(3,2,4))*vec3(-1,1,1),0.,1.),vec3(c.b>.5),abs(.5-c.b)*2.),c.g);}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r;\n//         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\nfloat sdSphere( in vec3 pos, float rad )\n{\n    return length(pos) - rad;\n}\n\nfloat sdStick( in vec3 p, vec3 a, vec3 b, float ra, float rb )\n{\n    vec3 ba = b-a;\n    vec3 pa = p-a;\n\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0,1.0 );\n    float r = mix( ra, rb, h );\n    return length(pa - h*ba) - r;\n}\n\nfloat sdEllipsoid( in vec3 pos, vec3 rad )\n{\n    float k0 = length(pos/rad);\n    float k1 = length(pos/rad/rad);\n    return k0*(k0-1.0)/k1;\n}\n\nfloat smin( in float a, in float b, float k )\n{\n    float h = max( k - abs(a-b), 0.0 );\n    return min(a,b) - h*h/(k*4.0);\n}\n\nfloat smax( in float a, in float b, float k )\n{\n    float h = max( k - abs(a-b), 0.0 );\n    return max(a,b) + h*h/(k*4.0);\n}\n\nvec4 char_evil( in vec3 q, float atime, float sy, float sz, float cc, float ss, float y, float y2, float y3 )\n{\n    float d = 999.0;\n    vec4 res = vec4(d,-1.0,0.0,0.0);\n\n    // Body coordinate ref\n    vec3 b = q;\n    vec3 sb = vec3( abs(b.x), b.yz );\n\n    // body\n    {\n    vec3 rad = vec3(0.25,0.25*sy,0.25*sz);\n    float d = sdEllipsoid(q, rad);\n    if( d<res.x ) res = vec4(d,18.0,1.0,0.0);\n    }\n\n    // legs\n    {\n    vec3 legBase = vec3(0.15,-0.25,0.0);\n    legBase.y += 0.1/sy;\n    float la = -sign(b.x)*cos(3.1416*atime);\n    float ccc = cos(la);\n    float sss = sin(la);\n    vec3 legEnd = legBase + 0.2*vec3(0.2, -ccc, sss);\n    float d2 = sdStick( sb,\n                  legBase,\n                  legEnd,\n                  0.03,\n                  0.06 );\n    d = smin(res.x,d2,0.02);\n    if( d<res.x ) res = vec4(d, 16.0,1.0,0.0);\n    }\n\n    // Head coordinate ref\n    vec3 neck = vec3(0.0,0.0,0.12);\n    vec3 h = q - neck;\n\n    // Head rotation\n    float hr = -1.0+2.0*smoothstep( -0.2,0.2, -0.4*sin(atime * 1.7) );\n    float hp = -1.0+2.0*smoothstep( -0.4,0.4, 0.1+0.15*cos(atime * 3.3) );\n    //hr = -5.0*(iMouse.x/iResolution.x - 0.5); // mouse control\n    //hp = -2.0*(iMouse.y/iResolution.y - 0.5); // mouse control\n    cc = cos(hr);\n    ss = sin(hr);\n    h.xz = mat2(cc,-ss,ss,cc)*h.xz;\n    cc = cos(hp);\n    ss = sin(hp);\n    h.yz = mat2(cc,-ss,ss,cc)*h.yz;\n\n    vec3 sh = vec3( abs(h.x), h.yz );\n\n    // pants (using head coordinates so they angle when the head does)\n    if (h.y < 0.0) { res.y = 6.0; }\n\n    // head\n    {\n\n    float d2 = sdEllipsoid(h - vec3(0.0,0.28,0.0), vec3(0.15,0.2,0.23));\n    float d3 = sdEllipsoid(h - vec3(0.0,0.28,-0.05), vec3(0.23,0.2,0.2));\n\n    d2 = smin(d2,d3, 0.05);\n    d = smin(res.x,d2, 0.15);\n    if( d<res.x ) res = vec4(d, 12.0,1.0,0.0);\n    }\n\n    // eyebrows\n    {\n    vec3 eb = sh - vec3(0.04,0.33,0.16);\n    float er = -0.8;\n    cc = cos(er);\n    ss = sin(er);\n    eb.xy = (mat2(cc,ss,-ss,cc))*eb.xy;\n    float d2 = sdEllipsoid(eb, vec3(0.06,0.03,0.07));\n    d = smin(d,d2, 0.02);\n    //d = min(d,d2);\n    if( d<res.x ) res = vec4(d, 12.0,1.0,0.0);\n    }\n\n    // wrinkles\n    {\n    float ry = (h.y-0.03) - 1.3*h.x*h.x;\n    d += 0.001*sin(ry*160.0) * (1.0 - smoothstep(0.0,0.05,abs(ry)));\n    if( d<res.x ) res = vec4(d, 12.0,1.0,0.0);\n    }\n\n    // arms\n    {\n    float d2 = sdStick( sh + neck,\n                  vec3(0.20,0.25,0.1+-0.05),\n                  vec3(0.3+0.1*y3,-0.1+0.4*y3,0.1+0.05),\n                  0.03,\n                  0.06 );\n    d = smin(d,d2,0.02);\n    if( d<res.x ) res = vec4(d, 12.0,1.0,0.0);\n    }\n\n    // ears\n    {\n    float d2 = sdStick( sh,\n                  vec3(0.1,0.4,-0.01),\n                  vec3(0.2,0.4+0.15*y2,0.02-0.1*y2),\n                  0.01,\n                  0.03 );\n    d = smin(d,d2,0.04);\n    if( d<res.x ) res = vec4(d, 12.0,1.0,0.0);\n    }\n\n    // unicorn horn\n    {\n    float ro = -0.6;\n    float cc = cos(ro);\n    float ss = sin(ro);\n    vec3 hh = (sh - vec3(0.1, 0.4, 0.1));\n    hh.xy = mat2(cc,-ss,ss,cc)*hh.xy;\n    float d = sdStick(hh,\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 0.2, 0.0),\n        0.03,\n        0.01);\n    if( d<res.x ) res = vec4(d, 17.0,1.0,0.0);\n    }\n\n    // mouth\n    {\n    float d = sdEllipsoid(h - vec3(0.0,0.15 - 2.0*h.x*h.x*h.x,0.15), vec3(0.2,0.04 + 0.02 * sin(atime * 1.3),0.2));\n    float occ = 1.0-smoothstep( -0.01,0.001, -d );\n    d = smax(res.x,-d,0.01);\n    if( d>res.x ) res = vec4(d, 12.0,occ,0.0);\n    }\n\n    // tooth\n    {\n    //float d = sdRoundBox( h - vec3(0.0,0.19 + 0.005 * sin(atime * 1.3),0.16), vec3(0.02,0.011,0.01), 0.005 );\n    float y = 0.005 * sin(atime * 1.3);\n    float d = sdRoundBox( sh - vec3(0.018,0.19 + y,0.16), vec3(0.01,0.011,0.01), 0.005 );\n//  d = min(d, sdRoundBox( sh - vec3(0.058,0.185 + y,0.15), vec3(0.01,0.011,0.01), 0.005 ));\n    d = min(d, sdStick( sh, vec3(0.058,0.19 + y,0.15), vec3(0.058,0.16 + y,0.15), \n                       0.01, 0.001 ));\n    if( d<res.x ) res = vec4(d,20.0,1.0,0.0);\n    }\n\n    // eye\n    {\n    // Eye rotation\n    vec3 e = h - vec3(0.08,0.28,0.16);\n\n    // Maybe there's a way to get the eyes to repeat without\n    // symmetry, but if so I don't know what it would be.\n    // The \"limited repetition\" example's opRepLim works,\n    // but I don't know how to do get two eyes with it instead\n    // of three:\n    //\n    //    float rep_s = 0.16;\n    //    vec3 rep_lim = vec3(1.0, 0.0, 0.0);\n    //    vec3 e_rep = e - rep_s*clamp( round(e/rep_s), -rep_lim,rep_lim );\n    //    e = e_rep;\n    //\n    // So I'm just going to do each eye separately with its own coordinate\n    // basis instead*:\n    //\n    // (*also lets me rotate the eyes differently, which is better anyway!)\n\n    vec3 e0 = e;\n    vec3 e1 = e - vec3(-0.16, 0.0, 0.0);\n\n    // Horizontal eye movement beyond -0.7..0.7 looks weird. \n    // Vertical eye movement beyond -0.5..0.8 looks weird.\n    // But we don't use the full range here, because we're also\n    // tilting the head.\n    const float es = 0.05; // eye smoothing\n    float etime = atime + 0.1; // eyes lead the head movement by a moment.\n    float er = -0.5*(-1.0 + 2.0*smoothstep( -es, es, sin(etime * 1.7) ));\n    float ep = 0.1 + 0.45*(-1.0 + 2.0*smoothstep( -es, es, cos(etime * 3.3) ));\n    //er = clamp( -5.0*(iMouse.x/iResolution.x - 0.5), -0.7,0.7 ); // mouse control\n    //ep = clamp( -2.0*(iMouse.y/iResolution.y - 0.5), -0.5,0.8 ); // mouse control\n\n    // BUG: eyes ought to look at something in world coordinates,\n    // and remain stable even when the head and body move. But\n    // that's hard... I'm not set up to do the inverse transforms :(\n    \n    // The eyes rotate less when moving towards the nose.\n    float er0 = (er < 0.0 ? er : 0.4 * er);\n    float cc0 = cos(er0);\n    float ss0 = sin(er0);\n    e0.xz = mat2(cc0,-ss0,ss0,cc0)*e0.xz;\n    float er1 = (er > 0.0 ? er : 0.4 * er);\n    float cc1 = cos(er1);\n    float ss1 = sin(er1);\n    e1.xz = mat2(cc1,-ss1,ss1,cc1)*e1.xz;\n    // But both eyes pitch identically.\n    cc = cos(ep);\n    ss = sin(ep);\n    e0.yz = mat2(cc,-ss,ss,cc)*e0.yz;\n    e1.yz = mat2(cc,-ss,ss,cc)*e1.yz;\n    \n    // Eye occlusion\n    float eo = 1.0-5.0*smoothstep( 0.06,0.4, sh.x );\n\n    // Left eye (e0)\n    d = sdSphere( e0, 0.05 );\n    if( d<res.x ) res = vec4(d,13.0,eo,0.0);\n    // pupil\n    d = sdSphere( e0 - vec3(0.00,0.00,0.04), 0.02 );\n    if( d<res.x ) res = vec4(d,14.0,1.0,0.0);\n\n    // Right eye (e1)\n    d = sdSphere( e1, 0.05 );\n    if( d<res.x ) res = vec4(d,13.0,eo,0.0);\n    // pupil\n    d = sdSphere( e1 - vec3(0.00,0.00,0.04), 0.02 );\n    if( d<res.x ) res = vec4(d,14.0,1.0,0.0);\n    }\n\n    // --- wings ---\n    \n    {\n    float ws = 2.3;\n    vec3 wo = mix(sb, sh, 0.8) - vec3(0.0,0.1,-0.16);\n\n    //float wf = 0.5 + 0.6 * sin(ws * atime);\n    //float cc = cos(wf);\n    //float ss = sin(wf);\n    //wo.yz = mat2(cc,ss,-ss,cc) * wo.yz;\n    \n    float wr = -0.1 - 0.8 * pow(abs(sin(ws * atime)), 0.5);\n    cc = cos(wr);\n    ss = sin(wr);\n    wo.xy = mat2(cc,ss,-ss,cc) * wo.xy;\n    \n    float d = sdEllipsoid( wo - vec3(0.5,0.0 -1.6*pow(wo.x-0.3,2.0),0.0), vec3(0.3,0.15,0.01) );\n    \n    if( d<res.x ) res = vec4(d,19.0,0.0,0.0);\n    }\n\n    return res;\n}\n\nvec4 char_happy( in vec3 q, float atime, float sy, float sz, float cc, float ss, float y, float y2, float y3 )\n{\n    float d = 999.0;\n    vec4 res = vec4(d,-1.0,0.0,0.0);\n\n    // Body coordinate ref\n    vec3 b = q;\n    vec3 sb = vec3( abs(b.x), b.yz );\n\n    // body\n    {\n    vec3 rad = vec3(0.25,0.25*sy,0.25*sz);\n    float d = sdEllipsoid(q, rad);\n    if( d<res.x ) res = vec4(d,8.0,1.0,0.0);\n    }\n\n    // legs\n    {\n    vec3 legBase = vec3(0.15,-0.25,0.0);\n    legBase.y += 0.1/sy;\n    float la = -sign(b.x)*cos(3.1416*atime);\n    float ccc = cos(la);\n    float sss = sin(la);\n    vec3 legEnd = legBase + 0.2*vec3(0.2, -ccc, sss);\n    float d2 = sdStick( sb,\n                  legBase,\n                  legEnd,\n                  0.03,\n                  0.06 );\n    d = smin(res.x,d2,0.02);\n    if( d<res.x ) res = vec4(d, 6.0,1.0,0.0);\n    }\n\n    // Head coordinate ref\n    vec3 neck = vec3(0.0,0.0,0.12);\n    vec3 h = q - neck;\n\n    // Head rotation\n    float hr = -1.0+2.0*smoothstep( -0.2,0.2, -0.4*sin(atime * 1.7) );\n    float hp = -1.0+2.0*smoothstep( -0.4,0.4, 0.1+0.15*cos(atime * 3.3) );\n//    hr = -5.0*(iMouse.x/iResolution.x - 0.5); // mouse control\n//    hp = 2.0*(iMouse.y/iResolution.y - 0.5); // mouse control\n    cc = cos(hr);\n    ss = sin(hr);\n    h.xz = mat2(cc,-ss,ss,cc)*h.xz;\n    cc = cos(hp);\n    ss = sin(hp);\n    h.yz = mat2(cc,-ss,ss,cc)*h.yz;\n\n    vec3 sh = vec3( abs(h.x), h.yz );\n\n    // pants (using head coordinates so they angle when the head does)\n    if (h.y < 0.0) { res.y = 6.0; }\n\n    // head\n    {\n\n    float d2 = sdEllipsoid(h - vec3(0.0,0.28,0.0), vec3(0.15,0.2,0.23));\n    float d3 = sdEllipsoid(h - vec3(0.0,0.28,-0.05), vec3(0.23,0.2,0.2));\n\n    d2 = smin(d2,d3, 0.05);\n    d = smin(res.x,d2, 0.15);\n    if( d<res.x ) res = vec4(d, 2.0,1.0,0.0);\n    }\n\n    // eyebrows\n    {\n    vec3 eb = sh - vec3(0.12,0.36-0.03*y,0.13);\n    float er = 0.5;\n    cc = cos(er);\n    ss = sin(er);\n    eb.xy = (mat2(cc,ss,-ss,cc))*eb.xy;\n    float d2 = sdEllipsoid(eb, vec3(0.06,0.035,0.05));\n    d = smin(d,d2, 0.04);\n    if( d<res.x ) res = vec4(d, 2.0,1.0,0.0);\n    }\n\n    // wrinkles\n    {\n    float ry = (h.y-0.03) - 1.3*h.x*h.x;\n    d += 0.001*sin(ry*160.0) * (1.0 - smoothstep(0.0,0.05,abs(ry)));\n    if( d<res.x ) res = vec4(d, 2.0,1.0,0.0);\n    }\n\n    // arms\n    {\n    float d2 = sdStick( sh + neck,\n                  vec3(0.20,0.25,0.1+-0.05),\n                  vec3(0.3+0.1*y3,-0.1+0.4*y3,0.1+0.05),\n                  0.03,\n                  0.06 );\n    d = smin(d,d2,0.02);\n    if( d<res.x ) res = vec4(d, 2.0,1.0,0.0);\n    }\n\n    // ears\n    {\n    float d2 = sdStick( sh,\n                  vec3(0.1,0.4,-0.01),\n                  vec3(0.2,0.4+0.15*y2,0.02-0.1*y2),\n                  0.01,\n                  0.03 );\n    d = smin(d,d2,0.04);\n    if( d<res.x ) res = vec4(d, 2.0,1.0,0.0);\n    }\n\n    // unicorn horn\n    {\n    float ro = 0.7;\n    float cc = cos(ro);\n    float ss = sin(ro);\n    vec3 hh = (h - vec3(0.0, 0.4, 0.1));\n    hh.yz = mat2(cc,-ss,ss,cc)*hh.yz;\n    float d = sdStick(hh,\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 0.3, 0.0),\n        0.05,\n        0.01);\n    if( d<res.x ) res = vec4(d, 7.0,1.0,0.0);\n    }\n\n    // mouth\n    {\n    float d = sdEllipsoid(h - vec3(0.0,0.15 + 5.0*h.x*h.x,0.15), vec3(0.1,0.04,0.2));\n    float occ = 1.0-smoothstep( -0.01,0.001, -d );\n    d = smax(res.x,-d,0.04);\n    if( d>res.x ) res = vec4(d, 2.0,occ,0.0);\n    }\n\n    // tooth\n    {\n    float d = sdRoundBox( h - vec3(0.0,0.19,0.16), vec3(0.02,0.011,0.01), 0.005 );\n//    float d = sdRoundBox( sh - vec3(0.018,0.19,0.16), vec3(0.01,0.011,0.01), 0.005 );\n    if( d<res.x ) res = vec4(d,3.0,1.0,0.0);\n    }\n\n    // eye\n    {\n    // Eye rotation\n    vec3 e = h - vec3(0.08,0.28,0.16);\n\n    // Maybe there's a way to get the eyes to repeat without\n    // symmetry, but if so I don't know what it would be.\n    // The \"limited repetition\" example's opRepLim works,\n    // but I don't know how to do get two eyes with it instead\n    // of three:\n    //\n    //    float rep_s = 0.16;\n    //    vec3 rep_lim = vec3(1.0, 0.0, 0.0);\n    //    vec3 e_rep = e - rep_s*clamp( round(e/rep_s), -rep_lim,rep_lim );\n    //    e = e_rep;\n    //\n    // So I'm just going to do each eye separately with its own coordinate\n    // basis instead*:\n    //\n    // (*also lets me rotate the eyes differently, which is better anyway!)\n\n    vec3 e0 = e;\n    vec3 e1 = e - vec3(-0.16, 0.0, 0.0);\n\n    // Horizontal eye movement beyond -0.7..0.7 looks weird. \n    // Vertical eye movement beyond -0.5..0.8 looks weird.\n    // But we don't use the full range here, because we're also\n    // tilting the head.\n    const float es = 0.05; // eye smoothing\n    float etime = atime + 0.1; // eyes lead the head movement by a moment.\n    float er = -0.5*(-1.0 + 2.0*smoothstep( -es, es, sin(etime * 1.7) ));\n    float ep = 0.1 + 0.45*(-1.0 + 2.0*smoothstep( -es, es, cos(etime * 3.3) ));\n//    er = clamp( -5.0*(iMouse.x/iResolution.x - 0.5), -0.7,0.7 ); // mouse control\n//    ep = clamp(  2.0*(iMouse.y/iResolution.y - 0.5), -0.5,0.8 ); // mouse control\n\n    // BUG: eyes ought to look at something in world coordinates,\n    // and remain stable even when the head and body move. But\n    // that's hard... I'm not set up to do the inverse transforms :(\n    \n    // The eyes rotate less when moving towards the nose.\n    float er0 = (er < 0.0 ? er : 0.4 * er);\n    float cc0 = cos(er0);\n    float ss0 = sin(er0);\n    e0.xz = mat2(cc0,-ss0,ss0,cc0)*e0.xz;\n    float er1 = (er > 0.0 ? er : 0.4 * er);\n    float cc1 = cos(er1);\n    float ss1 = sin(er1);\n    e1.xz = mat2(cc1,-ss1,ss1,cc1)*e1.xz;\n    // But both eyes pitch identically.\n    cc = cos(ep);\n    ss = sin(ep);\n    e0.yz = mat2(cc,-ss,ss,cc)*e0.yz;\n    e1.yz = mat2(cc,-ss,ss,cc)*e1.yz;\n    \n    // Eye occlusion\n    float eo = 1.0-5.0*smoothstep( 0.06,0.4, sh.x );\n\n    // Left eye (e0)\n    d = sdSphere( e0, 0.05 );\n    if( d<res.x ) res = vec4(d,3.0,eo,0.0);\n    // pupil\n    d = sdSphere( e0 - vec3(0.00,0.00,0.04), 0.02 );\n    if( d<res.x ) res = vec4(d,4.0,1.0,0.0);\n\n    // Right eye (e1)\n    d = sdSphere( e1, 0.05 );\n    if( d<res.x ) res = vec4(d,3.0,eo,0.0);\n    // pupil\n    d = sdSphere( e1 - vec3(0.00,0.00,0.04), 0.02 );\n    if( d<res.x ) res = vec4(d,4.0,1.0,0.0);\n    }\n\n    // --- wings ---\n    \n    {\n    float ws = 24.0;\n    vec3 wo = mix(sb, sh, 0.8) - vec3(0.0,0.1,-0.16);\n\n    float wf = 0.5 + 0.6 * sin(ws * atime);\n    float cc = cos(wf);\n    float ss = sin(wf);\n    wo.yz = mat2(cc,ss,-ss,cc) * wo.yz;\n    \n    float wr = -0.8 + 0.1 * sin(ws * atime);\n    cc = cos(wr);\n    ss = sin(wr);\n    wo.xy = mat2(cc,ss,-ss,cc) * wo.xy;\n    \n    float d = sdEllipsoid( wo - vec3(0.5,0.0,0.0), vec3(0.5,0.15,0.05) );\n    \n    if( d<res.x ) res = vec4(d,9.0,9.0,0.0);\n    }\n\n    return res;\n}\n\nvec4 terrain_evil( in vec3 pos, float atime, vec3 cen )\n{\n    float d = 999.0;\n    vec4 res = vec4(d,-1.0,0.0,0.0);\n\n    // terrain\n    float fh = -0.1 + 0.09*(sin(atime+2.0*pos.x)+ 0.8 * sin(atime*1.7+1.3*pos.z));\n    float l = length((pos - cen).xz);\n\n#if TERRAIN_DETAIL && 0\n    float gt = fract(atime);\n    fh -= 0.1\n        *sin(gt*8.0+l*2.0)\n        *exp( -1.0*l*l )\n        *exp( -1.0*gt )\n        *smoothstep(0.0,0.1,gt);\n#endif\n\n    d = pos.y - fh;\n    res = (d<res.x) ? vec4(d,11.0,1.0,0.0) : res;\n\n#if TERRAIN_DETAIL\n    // lava trees\n    {\n    vec3 q = vec3( mod(abs(pos.x), 3.0)-1.5,\n                   pos.y,\n                   mod(pos.z+1.5, 3.0)-1.5 );\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*31.1 + id.y*31.7;\n    float fy = fract(id.x*1.72+atime*1.225);\n    float y = 0.9*pow(fy, 0.5);\n    vec3 rad = vec3(0.7,1.0+0.5*sin(fid*431.19),0.8);\n    // rad -= 0.05*(sin(pos.x*3.0)+sin(pos.y*6.0)+sin(pos.z*5.0));\n    rad *= clamp(2.0*fy*(1.0-fy), 0.001, 1.0);\n    float d2 = sdEllipsoid( q-vec3(0.5,y,0.0), rad );\n    float f = smoothstep( -0.2,0.2,\n        sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z) );\n    d2 -= 0.007*f; // non-euclidean distortion of surface.\n    d = smin(d, d2, 0.7);\n\n    // Reduce step size for terrain to increase accuracy\n    // (preventing artifacts when the raymarcher goes inside\n    // the terrain because of the noneuclidean distortions).\n    // (this is a hacky solution)\n//    d *= 0.9;\n\n    res = (d<res.x) ? vec4(d,11.0,1.0,0.0) : res;\n    }\n\n    // candy\n    {\n    vec3 q = vec3( mod(pos.x+0.25, 0.5)-0.25,\n                   pos.y - fh,\n                   mod(pos.z+0.25, 0.5)-0.25);\n\n    vec2 id = floor((pos.xz+0.25)/0.5);\n    vec2 fid = vec2( id.x*21.1 + id.y*11.7,\n                      id.x*13.1 + id.y*51.7 );\n    vec2 dis = cos(fid);\n    vec3 ofs = vec3( dis.x*0.1,\n                     -0.25+0.2*fract(fid.x)+0.1*sin(atime*1.2+fid.x),\n                     dis.y*0.1);\n    vec3 group = vec3( 0.0,\n                       -0.05*(1.0 - cos(pos.x)*cos(pos.x)),\n                       0.0 );\n    vec3 so = q - ofs - group;\n    \n    float angle = 0.0 + sin(fid.x);\n    float cc = cos(angle);\n    float ss = sin(angle);\n    so.xz = mat2(cc, ss, -ss, cc) * so.xz;\n \n        \n    vec3 sso = vec3(abs(so.x), so.yz);\n    float d = sdSphere( so, 0.1 );\n    \n    float co = 0.5+0.5*clamp( (pos.y-fh)/0.03, 0.0,1.0 );\n\n    res = (d<res.x) ? vec4(d,15.0,co,0.0) : res;\n        \n    d = sdSphere( sso - vec3(0.034, 0.02, 0.09), 0.025);\n    d = max(res.x,-d);\n    res = (d>res.x) ? vec4(d,19.0,0.01,0.0) : res;\n    }\n#endif\n\n    return res;\n}\n\nvec4 terrain_happy( in vec3 pos, float atime, vec3 cen )\n{\n    float d = 999.0;\n    vec4 res = vec4(d,-1.0,0.0,0.0);\n\n    // terrain\n    float fh = -0.1 + 0.05*(sin(2.0*pos.x)+sin(2.0*pos.z));\n    float l = length((pos - cen).xz);\n\n#if TERRAIN_DETAIL && 0\n    float gt = fract(atime);\n    fh -= 0.1\n        *sin(gt*8.0+l*2.0)\n        *exp( -1.0*l*l )\n        *exp( -1.0*gt )\n        *smoothstep(0.0,0.1,gt);\n#endif\n\n    d = pos.y - fh;\n    res = (d<res.x) ? vec4(d,1.0,1.0,0.0) : res;\n\n#if TERRAIN_DETAIL\n    // trees\n    {\n    vec3 q = vec3( mod(abs(pos.x), 3.0)-1.5,\n                   pos.y,\n                   mod(pos.z+1.5, 3.0)-1.5 );\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*31.1 + id.y*31.7;\n    float fy = fract(id.x*1.72+atime*0.125);\n    float y = 2.0*fy;\n    vec3 rad = vec3(0.7,1.0+0.5*sin(fid*431.19),0.8);\n    rad -= 0.05*(sin(pos.x*3.0)+sin(pos.y*6.0)+sin(pos.z*5.0));\n    rad *= clamp(4.0*fy*(1.0-fy), 0.001, 1.0);\n    float d2 = sdEllipsoid( q-vec3(0.5,y,0.0), rad );\n    float f = smoothstep( -0.2,0.2,\n        sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z) );\n    d2 -= 0.007*f; // non-euclidean distortion of surface.\n    d = smin(d, d2, 0.3);\n\n    // Reduce step size for terrain to increase accuracy\n    // (preventing artifacts when the raymarcher goes inside\n    // the terrain because of the noneuclidean distortions).\n    // (this is a hacky solution)\n//    d *= 0.9;\n\n    res = (d<res.x) ? vec4(d,1.0,1.0,0.0) : res;\n    }\n\n    // candy\n    {\n    vec3 q = vec3( mod(pos.x+0.25, 0.5)-0.25,\n                   pos.y - fh,\n                   mod(pos.z+0.25, 0.5)-0.25 );\n    vec2 id = floor((pos.xz+0.25)/0.5);\n    vec2 fid = vec2( id.x*21.1 + id.y*11.7,\n                      id.x*13.1 + id.y*51.7 );\n    vec2 dis = cos(fid);\n    vec3 ofs = vec3( dis.x*0.1,\n                     -0.25+0.3*fract(fid.x),\n                     dis.y*0.1);\n    vec3 group = vec3( 0.0,\n                       -0.05*(1.0 - cos(pos.x)*cos(pos.x)),\n                       0.0 );\n    float d = sdSphere( q - ofs - group, 0.1 );\n    float co = 0.5+0.5*clamp( (pos.y-fh)/0.03, 0.0,1.0 );\n\n    res = (d<res.x) ? vec4(d,5.0,co,0.0) : res;\n    }\n#endif\n\n    return res;\n}\n\nvec4 map( in vec3 pos, float atime )\n{\n    float t = fract(atime);\n    float y = 4.0*t*(1.0 - t);\n    float dy = 4.0*(1.0 - 2.0*t);\n    // delayed parabolas\n    float t2 = fract(atime - 0.2);\n    float y2 = 4.0*t2*(1.0 - t2);\n    float t3 = fract(atime + 0.15);\n    float y3 = 4.0*t3*(1.0 - t3);\n\n    vec2 uu = normalize(vec2(1.0,-dy));\n    vec2 vv = vec2(-uu.y, uu.x);\n\n    float itime = floor(atime);\n    float ftime = fract(atime);\n\n    // position\n    float x = -1.0+2.0*abs(fract(0.5*atime) - 0.5)/0.5;\n    vec3 cen = vec3( 0.6 * sin(atime),\n                     //0.8*pow(pow(y,2.0-y), 0.4)+0.15, // temp\n                     0.7 + 0.3 * sin(atime),\n                     itime+pow(ftime,0.7) );\n    float sy = 0.7 + 0.3*y;\n    float sz = 1.0/sy;\n\n    // ref coords\n    vec3 q = pos - cen;\n\n    float ro = 0.3*x;\n    float cc = cos(ro);\n    float ss = sin(ro);\n    q.xy = mat2(cc,-ss,ss,cc)*q.xy;\n\n\n    // Swap the character and the terrain\n    float ttime = mod(atime+2.0, 10.0);\n    float ctime = mod(atime+1.0, 10.0);\n    float tx = 0.0;\n    const float ts = 20.0;\n    if( ttime < 2.0 ) tx = ts*(ttime - 1.0);\n    else if( ttime < 5.0 ) tx = ts;\n    else if( ttime < 7.0 ) tx = -ts*((ttime - 5.0) - 1.0);\n    else tx = -ts;\n    \n\n    vec4 res, res2;\n\n    if( ctime<5.0 ) {\n        res = char_happy( q, atime, sy, sz, cc, ss, y, y2, y3 );\n    } else {\n        res = char_evil( q, atime, sy, sz, cc, ss, y, y2, y3 );\n    }\n    if( pos.x < tx) {\n        res2 = terrain_happy( pos, atime, cen );\n    } else {\n        res2 = terrain_evil( pos, atime, cen );\n    }\n    res = (res2.x < res.x) ? res2 : res;\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, float atime )\n{\n    vec2 e = vec2(0.0001,0.0);\n    return normalize( vec3( map(pos+e.xyy,atime).x-map(pos-e.xyy,atime).x,\n                            map(pos+e.yxy,atime).x-map(pos-e.yxy,atime).x,\n                            map(pos+e.yyx,atime).x-map(pos-e.yyx,atime).x ) );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float atime )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; ++i )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, atime ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( (1.0 - 2.0*occ), 0.0,1.0 );\n}\n\nfloat castShadow( in vec3 ro, in vec3 rd, float atime )\n{\n    float res = 1.0;\n    // Start a bit out to prevent self-shadowing \"onion rings\" due\n    // to noneuclidean distances (this is a hacky solution, and it\n    // will prevent any real small self-shadowing that we want, that\n    // we were getting at t=0.01)\n    float t = 0.05;\n    for( int i=0; i<100; ++i )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos,atime ).x;\n        // Divide by t to get cone tracing.\n        // A smaller constant factor gives softer shadows.\n        res = min( res, 16.0*h/t );\n        if( h<0.0001 ) break;\n        t += h * 0.5; // Step shadows slower to reduce banding.\n        if( t>20.0 ) break;\n    }\n\n    return clamp( res, 0.0,1.0 );\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd, float atime )\n{\n    vec3 m = vec3(-1.0,1.0,0.0);\n    float t = 0.01;\n    for( int i=0; i<512; ++i )\n    {\n        vec3 pos = ro + t*rd;\n        vec4 h = map( pos,atime );\n        m = h.yzw;\n        if( abs(h.x)<(0.001*t) ) break;\n        t += h.x;\n        if( t>20.0 ) break;\n    }\n    if( t>20.0 ) m = vec3(-1.0,1.0,0.0);\n    return vec4(t,m);\n}\n\nvec3 sky_evil(vec3 rd, float atime)\n{\n    // sky (the default colour)\n    vec3 col = vec3(0.35,0.2,0.1) - 0.7*rd.y; // sky base\n    col = clamp( col, 0.0,1.0 );\n\n#if SKY_DETAIL\n    // clouds\n    vec2 uv = rd.xz/rd.y; // How is this derived??\n    vec2 uv0 = uv + atime*vec2(0.1, -0.08);\n    vec2 uv1 = uv + atime*vec2(0.2, -0.10);\n    float cl = 0.6*( sin(1.0*uv0.x) + sin(1.0*uv0.y) )\n             + 0.3*( sin(2.0*uv1.x) + sin(2.0*uv1.y) );\n    col = mix( col, vec3(1.0,0.5,0.5) * 0.0002,\n               smoothstep( -0.4,0.4, -0.5+cl ) );\n\n    // horizon glow/fog\n    col = mix( col, vec3(0.95,0.7,0.5), exp(-10.0*rd.y) );\n#endif\n    return col;\n}\n\nvec3 sky_happy(vec3 rd, float atime)\n{\n    // sky (the default colour)\n    vec3 col = vec3(0.4,0.75,1.0) - 0.7*rd.y; // sky base\n    col = clamp( col, 0.0,1.0 );\n\n#if SKY_DETAIL\n    // clouds\n    vec2 uv = rd.xz/rd.y; // How is this derived??\n    vec2 uv0 = uv + atime*vec2(0.1, -0.08);\n    vec2 uv1 = uv + atime*vec2(0.2, -0.10);\n    float cl = 0.6*( sin(1.0*uv0.x) + sin(1.0*uv0.y) )\n             + 0.3*( sin(2.0*uv1.x) + sin(2.0*uv1.y) );\n    col = mix( col, vec3(0.3,0.7,0.95),\n               smoothstep( -0.15,0.15, -0.5+cl ) );\n\n    // horizon glow/fog\n    col = mix( col, vec3(0.5,0.7,0.9), exp(-10.0*rd.y) );\n#endif\n    return col;\n}\n\nvec3 sky(vec3 rd, float atime)\n{\n    // Swap the character and the terrain\n    float ttime = mod(atime+1.5, 10.0);\n    float tx = 0.0;\n    if( ttime < 1.0 ) tx = 1.0-ttime;\n    else if( ttime < 5.0 ) tx = 0.0;\n    else if( ttime < 6.0 ) tx = (ttime - 5.0);\n    else tx = 1.0;\n\n    vec3 sky1 = sky_happy(rd, atime);\n    vec3 sky2 = sky_evil(rd, atime);\n    return mix(sky1, sky2, tx);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n\n    // time\n    float atime = mod(iTime, 60.0);\n//    atime = 134.7; // paused in sunlight\n//    atime = 4.0; // paused in shadow\n//    atime = 40.8; // paused 3/4 view\n//    atime = 110.25; // paused looking almost at camera\n//    atime = 20.13; // paused half in shadow\n\n    // character pos\n    float t = fract(atime-0.1);\n    float y = 4.0*t*(1.0 - t); // from character y, slightly advanced\n\n    // camera angle\n    float an = -0.2+0.4*sin(0.15*atime);\n//    an = 10.0*(iMouse.x/iResolution.x - 0.5); // mouse control\n\n    // camera distance\n    float cd = 2.5-0.9*sin(0.1*atime)*sin(0.1*atime);\n    // camera offset\n    vec3 co = vec3(cd*sin(an),1.0,cd*cos(an)); // temp\n    // target\n    vec3 ta = vec3(0.0,0.7+0.0*0.2*y,atime); // temp\n\n    // float above floor\n    vec3 ro = ta + co;\n    float fh = -0.1 + 0.05*(sin(2.0*ro.x)+sin(2.0*ro.z)); // from terrain\n    ro.y = fh + 0.22 + 0.5*sin(0.2*atime)*sin(0.2*atime);\n\n    // camera shake when bouncing\n    // temp\n//    float bt = -1.0+2.0*abs(fract(atime-0.1) - 0.5)/0.5;\n//    float bou = 0.8*smoothstep(0.2,1.0,bt);\n//    ro += bou*vec3(0.05,-0.12,0.05)*sin(atime*12.0 + vec3(2.0,2.0,4.0));\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n    vec3 col = sky(rd, atime);\n\n    vec4 tm = castRay( ro, rd, atime );\n    if( tm.y>0.0 )\n    {\n        float t = tm.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, atime );\n\n        // albedo\n        vec3 al = vec3(0.18);\n        // specular\n        float ks = 1.0;\n\n        // happy materials\n        if( tm.y<1.5 )\n        {\n            // terrain\n            al = vec3(0.05,0.1,0.02);\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z) );\n            al += 0.2*f*vec3(0.06,0.06,0.02);\n            // get darker and redder as it grows higher\n            al = mix( al, vec3(0.005, 0.0005, 0.0), 0.3*pos.y );\n            // specular is only high near ground level\n            ks = clamp( 2.0 - 1.5*pos.y, 0.0,3.0 );\n        }\n        else if( tm.y<2.5 || (tm.y >= 7.5 && tm.y < 8.5) )\n        {\n            // body\n            al = vec3(0.02,0.1,0.3);\n            ks = 0.5;\n\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -2.0,2.0,\n                sin(30.0*pos.x*0.1)+sin(30.0*pos.y*0.1)+sin(30.0*pos.z*0.5) );\n            al = mix(al, vec3(0.4, 0.1, 0.2), 1.0 - f);\n        }\n        else if( tm.y<3.5 )\n        {\n            // eyes\n            al = vec3(0.4,0.4,0.4);\n            ks = 2.0;\n        }\n        else if( tm.y<4.5 )\n        {\n            // pupils\n            al = vec3(0.02);\n            ks = 10.0;\n        }\n        else if( tm.y<5.5 )\n        {\n            // candy\n            al = vec3(0.1, 0.02, 0.01);\n            vec2 id = floor((pos.xz+0.25)/0.5);\n            float fid = id.x*11.1 + id.y*31.7;\n            al += vec3(0.01,0.06,0.02)*cos( fid*10.0 + vec3(0.0, 0.2, 0.4) );\n            ks = 1.0;\n        }\n        else if( tm.y<6.5 )\n        {\n            // pants\n            al = vec3(0.4, 0.1, 0.2);\n            ks = 3.0;\n        }\n        else if( tm.y<7.5 )\n        {\n            // horn\n            float hue = fract(atime * 3.0) * 6.28;\n            al = hsl2rgb(vec3(hue, 0.9, 0.4));\n            ks = 10.0;\n        }\n        else if( tm.y<9.5 )\n        {\n            // wings\n            al = vec3(0.4, 0.1, 0.2);\n            ks = 5.0;\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(80.0*pos.x)+sin(80.0*pos.y)+sin(2.0) );\n            al += 0.2*f*vec3(0.06,0.06,0.02);\n        }\n        else if( tm.y<10.5 )\n        {\n            // everything else\n            al = vec3(0.0,0.0,0.0);\n            ks = 0.0;\n        }\n        // evil materials\n        else if( tm.y<11.5 )\n        {\n            // terrain\n            al = vec3(0.4,0.03,0.01);\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z) );\n            al += 0.2*f*vec3(0.06,0.06,0.02);\n            // get darker and redder as it grows higher\n            al = mix( al, vec3(0.007, 0.0003, 0.0), 0.15*(pos.y + 6.0) );\n            // specular is only high near ground level\n            ks = clamp( 2.0 - 1.5*pos.y, 0.0,3.0 );\n        }\n        else if( tm.y<12.5 || (tm.y >= 17.5 && tm.y < 18.5) )\n        {\n            // body\n            al = vec3(0.02,0.1,0.3);\n            ks = 0.5;\n\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -2.0,2.0,\n                sin(30.0*pos.x*0.1)+sin(30.0*pos.y*0.1)+sin(30.0*pos.z*0.5) );\n            al = mix(al, vec3(0.4, 0.1, 0.2), 1.0 - f);\n        }\n        else if( tm.y<13.5 )\n        {\n            // eyes\n            al = vec3(0.6,0.0,0.0);\n            ks = 2.0;\n        }\n        else if( tm.y<14.5 )\n        {\n            // pupils\n            al = vec3(0.02);\n            ks = 10.0;\n        }\n        else if( tm.y<15.5 )\n        {\n            // candy\n            al = vec3(0.1, 0.1, 0.1);\n            vec2 id = floor((pos.xz+0.25)/0.5);\n            float fid = id.x*11.1 + id.y*31.7;\n            al += vec3(0.01,0.06,0.02)*cos( fid*10.0 + vec3(0.0, 0.2, 0.4) );\n            ks = 1.0;\n        }\n        else if( tm.y<16.5 )\n        {\n            // pants\n            al = vec3(0.4, 0.1, 0.2);\n            ks = 3.0;\n        }\n        else if( tm.y<17.5 )\n        {\n            // horn\n            float hue = fract(atime * 0.1) * 6.28;\n            al = hsl2rgb(vec3(hue, 0.9, 0.4));\n            ks = 10.0;\n        }\n        else if( tm.y<19.5 )\n        {\n            // wings\n            al = vec3(0.0, 0.0, 0.0);\n            ks = 0.3;\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(80.0*pos.x)+sin(80.0*pos.y)+sin(2.0) );\n            //al += 0.2*f*vec3(0.06,0.06,0.02);\n        }\n        else if( tm.y<20.5 )\n        {\n            // eyes\n            al = vec3(0.5,0.5,0.1);\n            ks = 3.0;\n        }\n        else\n        {\n            // everything else\n            al = vec3(0.0,0.0,0.0);\n            ks = 0.0;\n        }\n        al = clamp( al, vec3(0.0), vec3(1.0) );\n\n        float occ = calcOcclusion( pos, nor, atime )*tm.z;\n        vec3 sun_dir = normalize( vec3(0.8,0.4,0.7) );\n        float sun_dif = clamp( dot(nor,sun_dir), 0.0,1.0 );\n        // push specular out of place a little\n        vec3 sun_hal = normalize(sun_dir - rd + vec3(0.0, 0.25, -0.5));\n        float sun_sha = castShadow( pos + nor*0.001, sun_dir, atime );\n        vec3 sun_sha_pen = vec3(sun_sha,\n                                mix( sun_sha, sun_sha*sun_sha, 0.5 ),\n                                sun_sha*sun_sha); // for orangey penumbras.\n        float sun_spe = ks*pow( clamp(dot(nor,sun_hal),0.0,1.0), 8.0 )*sun_dif\n                          *(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0,1.0 );\n        float sky_ref = smoothstep( 0.0,1.5/ks, reflect(rd,nor).y );\n        float bou_dif = clamp( 0.01 + 0.99*dot(nor,vec3(0.0,-1.0,0.0)), 0.0,1.0 );\n        float fre = clamp( 1.0 + dot(rd,nor), 0.0,1.0 );\n\n        // Check if the guy is generally in shadow (so we can reduce\n        // sss when he is. And only apply this to the guy's body, not\n        // the whole scene!\n        // (Previously it was being applied when he looked down :D\n        // and it made the whole terrain flicker when applied D: )\n        float guy_sha = 1.0;\n        if (tm.y > 1.5 && tm.y <= 2.5) {\n        float itime = floor(atime);\n        float ftime = fract(atime);\n        float y = 4.0*ftime*(1.0 - ftime);\n        float x = -1.0+2.0*abs(fract(0.5*atime) - 0.5)/0.5;\n        vec3 cen = vec3( x*0.4,\n                         pow(y,2.0-y)+0.15,\n                         itime+pow(ftime,0.7) );\n        // offset the body raycast by a bunch to prevent it intersecting\n        // the body/head. We only want to consider environment shadows!\n        guy_sha = castShadow( cen+0.8*sun_dir, sun_dir, atime );\n        }\n\n        // diffuse (sun, sky, bounce)\n        vec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(9.1,6.0,2.2)*sun_sha_pen;\n        lin += 1.5*sky_dif*vec3(0.5,0.8,3.9)*occ;\n        lin += 0.75*bou_dif*vec3(0.3,1.08,0.2)*occ;\n        // fake sss\n        lin += 2.0*fre*vec3(1.5,0.5,0.4)\n                  *(0.5+0.5*sun_dif) // reduce a little in unlit areas.\n                  *(0.15+0.85*guy_sha) // reduce a lot when guy in shadow.\n                  *(0.5+0.5*tm.z); // reduce a ton when in forced-occlusion places.\n        col = al*lin;\n\n        // specular\n        col += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        col += sky_ref*0.1*vec3(0.6,0.9,2.0)*sky_dif*occ;\n\n        // haze\n        col = mix( col, vec3(0.95,0.7,0.5), 1.0-exp(-0.00005*t*t*t) );\n\n#if COLOR_GRADING\n        // Inigo hack: boost reds in the lighting colours.\n        // Like a curves adjustment. Artistic more than realistic.\n        col = pow( col, vec3(0.8,0.9,1.0) );\n#endif\n\n//        col = vec3(tm.z*tm.z);\n//        col = vec3(occ*occ);\n//        col = vec3( guy_sha );\n        }\n\n    // Convert to gamma space.\n    col = pow( col, vec3(0.4545) );\n\n#if COLOR_GRADING\n    // Exposure and contrast adjustment:\n    // (Normally would do this in linear space, but this s-curve is only\n    // good between 0 and 1.)\n    col = clamp( 1.05*col, 0.0,1.0 ); // 5% exposure gain & clamp to prevent burn.\n    vec3 contrasty = col*col*(3.0 - 2.0*col); // shallow s-curve.\n    col = mix( col, contrasty, 0.25 ); // Just use a bit of the contrasty colours.\n#endif\n\n    fragColor = vec4(col,1.0);\n}\n\n\nvoid mainImage2(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n\n    // time\n    float atime = mod(iTime, 60.0);\n//    atime = 134.7; // paused in sunlight\n//    atime = 4.0; // paused in shadow\n//    atime = 40.8; // paused 3/4 view\n//    atime = 110.25; // paused looking almost at camera\n//    atime = 20.13; // paused half in shadow\n\n    // character pos\n    float t = fract(atime-0.1);\n    float y = 4.0*t*(1.0 - t); // from character y, slightly advanced\n\n    // camera angle\n    float an = -0.2+0.4*sin(0.15*atime);\n//    an = 10.0*(iMouse.x/iResolution.x - 0.5); // mouse control\n\n    // camera distance\n    float cd = 2.5-0.9*sin(0.1*atime)*sin(0.1*atime);\n    // camera offset\n    vec3 co = vec3(0.0,0.0,cd);//vec3(cd*sin(an),1.0,cd*cos(an)); // temp\n    // target\n    vec3 ta = vec3(0.0,0.7+0.0*0.2*y,atime); // temp\n\n    // float above floor\n    vec3 ro = ta + co;\n    float fh = -0.1 + 0.05*(sin(2.0*ro.x)+sin(2.0*ro.z)); // from terrain\n    ro.y = fh + 0.22 + 0.5*sin(0.2*atime)*sin(0.2*atime);\n\n    // camera shake when bouncing\n    // temp\n//    float bt = -1.0+2.0*abs(fract(atime-0.1) - 0.5)/0.5;\n//    float bou = 0.8*smoothstep(0.2,1.0,bt);\n//    ro += bou*vec3(0.05,-0.12,0.05)*sin(atime*12.0 + vec3(2.0,2.0,4.0));\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n    // sky (the default colour)\n    vec3 col = vec3(0.4,0.75,1.0) - 0.7*rd.y; // sky base\n    col = clamp( col, 0.0,1.0 );\n\n#if SKY_DETAIL\n    // clouds\n    vec2 uv = rd.xz/rd.y; // How is this derived??\n    vec2 uv0 = uv + atime*vec2(0.1, -0.08);\n    vec2 uv1 = uv + atime*vec2(0.2, -0.10);\n    float cl = 0.6*( sin(1.0*uv0.x) + sin(1.0*uv0.y) )\n             + 0.3*( sin(2.0*uv1.x) + sin(2.0*uv1.y) );\n    col = mix( col, vec3(0.3,0.7,0.95),\n               smoothstep( -0.15,0.15, -0.5+cl ) );\n\n    // horizon glow/fog\n    col = mix( col, vec3(0.5,0.7,0.9), exp(-10.0*rd.y) );\n#endif\n\n    vec4 tm = castRay( ro, rd, atime );\n    if( tm.y>0.0 )\n    {\n        float t = tm.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, atime );\n\n        // albedo\n        vec3 al = vec3(0.18);\n        // specular\n        float ks = 1.0;\n\n        if( tm.y<1.5 )\n        {\n            // terrain\n            al = vec3(0.05,0.1,0.02);\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z) );\n            al += 0.2*f*vec3(0.06,0.06,0.02);\n            // get darker and redder as it grows higher\n            al = mix( al, vec3(0.005, 0.0005, 0.0), 0.3*pos.y );\n            // specular is only high near ground level\n            ks = clamp( 2.0 - 1.5*pos.y, 0.0,3.0 );\n        }\n        else if( tm.y<2.5 || (tm.y >= 7.5 && tm.y < 8.5) )\n        {\n            // body\n            al = vec3(0.02,0.1,0.3);\n            ks = 0.5;\n\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -2.0,2.0,\n                sin(30.0*pos.x*0.1)+sin(30.0*pos.y*0.1)+sin(30.0*pos.z*0.5) );\n            al = mix(al, vec3(0.4, 0.1, 0.2), 1.0 - f);\n        }\n        else if( tm.y<3.5 )\n        {\n            // eyes\n            al = vec3(0.4,0.4,0.4);\n            ks = 2.0;\n        }\n        else if( tm.y<4.5 )\n        {\n            // pupils\n            al = vec3(0.02);\n            ks = 10.0;\n        }\n        else if( tm.y<5.5 )\n        {\n            // candy\n            al = vec3(0.1, 0.02, 0.01);\n            vec2 id = floor((pos.xz+0.25)/0.5);\n            float fid = id.x*11.1 + id.y*31.7;\n            al += vec3(0.01,0.06,0.02)*cos( fid*10.0 + vec3(0.0, 0.2, 0.4) );\n            ks = 1.0;\n        }\n        else if( tm.y<6.5 )\n        {\n            // pants\n            al = vec3(0.4, 0.1, 0.2);\n            ks = 3.0;\n        }\n        else if( tm.y<7.5 )\n        {\n            // horn\n            float hue = fract(atime * 3.0) * 6.28;\n            al = hsl2rgb(vec3(hue, 0.9, 0.4));\n            ks = 10.0;\n        }\n        else if( tm.y<9.5 )\n        {\n            // wings\n            al = vec3(0.4, 0.1, 0.2);\n            ks = 5.0;\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(80.0*pos.x)+sin(80.0*pos.y)+sin(2.0) );\n            al += 0.2*f*vec3(0.06,0.06,0.02);\n        }\n        else\n        {\n            // everything else\n            al = vec3(0.0,0.0,0.0);\n            ks = 0.0;\n        }\n        al = clamp( al, vec3(0.0), vec3(1.0) );\n\n        float occ = calcOcclusion( pos, nor, atime )*tm.z;\n        vec3 sun_dir = normalize( vec3(0.8,0.4,0.7) );\n        float sun_dif = clamp( dot(nor,sun_dir), 0.0,1.0 );\n        // push specular out of place a little\n        vec3 sun_hal = normalize(sun_dir - rd + vec3(0.0, 0.25, -0.5));\n        float sun_sha = castShadow( pos + nor*0.001, sun_dir, atime );\n        vec3 sun_sha_pen = vec3(sun_sha,\n                                mix( sun_sha, sun_sha*sun_sha, 0.5 ),\n                                sun_sha*sun_sha); // for orangey penumbras.\n        float sun_spe = ks*pow( clamp(dot(nor,sun_hal),0.0,1.0), 8.0 )*sun_dif\n                          *(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0,1.0 );\n        float sky_ref = smoothstep( 0.0,1.5/ks, reflect(rd,nor).y );\n        float bou_dif = clamp( 0.01 + 0.99*dot(nor,vec3(0.0,-1.0,0.0)), 0.0,1.0 );\n        float fre = clamp( 1.0 + dot(rd,nor), 0.0,1.0 );\n\n        // Check if the guy is generally in shadow (so we can reduce\n        // sss when he is. And only apply this to the guy's body, not\n        // the whole scene!\n        // (Previously it was being applied when he looked down :D\n        // and it made the whole terrain flicker when applied D: )\n        float guy_sha = 1.0;\n        if (tm.y > 1.5 && tm.y <= 2.5) {\n        float itime = floor(atime);\n        float ftime = fract(atime);\n        float y = 4.0*ftime*(1.0 - ftime);\n        float x = -1.0+2.0*abs(fract(0.5*atime) - 0.5)/0.5;\n        vec3 cen = vec3( x*0.4,\n                         pow(y,2.0-y)+0.15,\n                         itime+pow(ftime,0.7) );\n        // offset the body raycast by a bunch to prevent it intersecting\n        // the body/head. We only want to consider environment shadows!\n        guy_sha = castShadow( cen+0.8*sun_dir, sun_dir, atime );\n        }\n\n        // diffuse (sun, sky, bounce)\n        vec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(9.1,6.0,2.2)*sun_sha_pen;\n        lin += 1.5*sky_dif*vec3(0.5,0.8,3.9)*occ;\n        lin += 0.75*bou_dif*vec3(0.3,1.08,0.2)*occ;\n        // fake sss\n        lin += 2.0*fre*vec3(1.5,0.5,0.4)\n                  *(0.5+0.5*sun_dif) // reduce a little in unlit areas.\n                  *(0.15+0.85*guy_sha) // reduce a lot when guy in shadow.\n                  *(0.5+0.5*tm.z); // reduce a ton when in forced-occlusion places.\n        col = al*lin;\n\n        // specular\n        col += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        col += sky_ref*0.1*vec3(0.6,0.9,2.0)*sky_dif*occ;\n\n        // haze\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp(-0.00005*t*t*t) );\n\n#if COLOR_GRADING\n        // Inigo hack: boost reds in the lighting colours.\n        // Like a curves adjustment. Artistic more than realistic.\n        col = pow( col, vec3(0.8,0.9,1.0) );\n#endif\n\n//        col = vec3(tm.z*tm.z);\n//        col = vec3(occ*occ);\n//        col = vec3( guy_sha );\n        }\n\n    // Convert to gamma space.\n    col = pow( col, vec3(0.4545) );\n\n#if COLOR_GRADING\n    // Exposure and contrast adjustment:\n    // (Normally would do this in linear space, but this s-curve is only\n    // good between 0 and 1.)\n    col = clamp( 1.05*col, 0.0,1.0 ); // 5% exposure gain & clamp to prevent burn.\n    vec3 contrasty = col*col*(3.0 - 2.0*col); // shallow s-curve.\n    col = mix( col, contrasty, 0.25 ); // Just use a bit of the contrasty colours.\n#endif\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}