{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//---------------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------------\n// Name: Squares and Hexes\n//\n// Author: John Kloetzli \n//         @JJcoolkl\n//\n// Description: Comparison of square and hex lattice sampling patterns with equal sample density.  Includes \n// point and linear reconstruction filters.  Hex math routines from Innchyn Her[1] and hex b-spline \n// formulation from Van De Ville[2].  Test fuction inspired by test volume by Marschner and Lobb[3].\n//\n// Top: Hex point filter\n// Left: Hex linear filter\n// Bottom: Square point filter\n// Right: Square linear filter\n//\n// References:\n//\n// [1] Innchyn Her: Geometric Transformations on the Hexagonal Grid, IEEE Transactions on Image Processing,\n//     Vol.4, No.9, Sept. 2995.\n//\n// [2] Dimitri Van De Ville et al.: Hex-Splines: A Novel Spline Family for Hexagonal Lattices, IEEE \n//     Transactions on Image Processing, Vol. 13, No. 6, June 2004\n//     http://infoscience.epfl.ch/record/63112/files/vandeville0402.pdf\n//\n// [3] Stephen Marschner and Richard Lobb: An Evaluation of Reconstruction Filters for Volume Rendering,\n//     Proceedings of Visualization '94, pages 100-107, Oct. 1994.\n//     http://www.cs.cornell.edu/~srm/publications/Vis94-filters.pdf\n// \n//---------------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------------\n\n#define FREQ \t\t20.0\n#define PI \t\t\t3.14159\n#define SQRT3 \t\t1.73205\n#define HEX_NORM \t1.07456 // sqrt( 2 / sqrt(3) )\n\n//#define SHOW_SQR_ERROR\n\n\n//filtering test function\nfloat EvalTestSignal( vec2 pos )\n{\n\tpos.x += sin( iTime ) * .2;\n\tpos.y += cos( iTime ) * .2;\n\t\n\tfloat fDist = sqrt( pos.x * pos.x + pos.y * pos.y );\n\tfloat fEval = PI * fDist * FREQ;\n\t\n\treturn sin(fEval * sqrt(fDist) ) / 4.0 + 0.5;\n}\n\n//---------------------------------------------------------------------------------------------\n// Project between square and hex basis.  I am not representing the z term of hex coordinate since it\n// is mathematically redundent.  Correct for smaller voronoi region produced by hex basis so we are\n// comparing equal sample density.\n//---------------------------------------------------------------------------------------------\nvec2 ToHex( vec2 pos )\n{\n\tpos.y *= (sqrt(3.0)/2.0);\n\tpos.y -= 0.5 * pos.x;\n\t\n\treturn pos * HEX_NORM;\n}\nvec2 FromHex( vec2 hex_pos )\n{\n\thex_pos /= HEX_NORM;\n\t\n\thex_pos.y += 0.5 * hex_pos.x;\n\thex_pos.y *= (2.0 / sqrt(3.0));\n\treturn hex_pos;\n}\n\n\n//---------------------------------------------------------------------------------------------\n// Sample wrapper in square basis.  Put whatever you want in here.\n//---------------------------------------------------------------------------------------------\nfloat Sample( vec2 pos )\n{\n\treturn EvalTestSignal( pos );\n\t//return texture( iChannel0, pos*0.5 + 0.5 ).x;\n}\nfloat Sample_Hex( vec2 hex_pos )\n{\n\treturn Sample( FromHex( hex_pos ) );\n}\n\n//---------------------------------------------------------------------------------------------\n// Rounding in square and hex domains.\n//---------------------------------------------------------------------------------------------\nvec2 hex_round( vec2 hex_val )\n{\n\tvec3 temp = vec3( hex_val.x, hex_val.y, -hex_val.x-hex_val.y );\n\tvec3 ret = round( temp );\n\t\n\tvec3 relative = ret - temp;\n\tif( (ret.x + ret.y + ret.z) > 0.0 )\n\t\trelative = temp - ret;\n\t\n\tif( relative.x < relative.y && relative.x < relative.z ){\n\t\tret.x = -ret.y -ret.z;\n\t}else if( relative.y < relative.z ){\n\t\tret.y = -ret.x - ret.z;\n\t}\n\t\n\treturn ret.xy;\n}\n\n//Linear hex spline basis function in hex basis from [2], updated to be evaluated in hex space.\n#define MIRROR( x,y,z ) { x=-x; float temp=y; y=-z; z=-temp; }\nfloat linear_hex_spline( vec2 hex_pos )\n{\n\tfloat hex_pos_z = -hex_pos.x -hex_pos.y;\n\tif( hex_pos_z > 0.0 ) MIRROR( hex_pos_z, hex_pos.x, hex_pos.y );\n\tif( hex_pos.x < 0.0 ) MIRROR( hex_pos.x, hex_pos.y, hex_pos_z );\n\tif( hex_pos.y > 0.0 ) MIRROR( hex_pos.y, hex_pos_z, hex_pos.x );\n\tif( hex_pos.y <= hex_pos_z )\n\t{\n\t\tfloat temp = hex_pos_z;\n\t\thex_pos_z = hex_pos.y;\n\t\thex_pos.y = temp;\n\t}\n\tif( hex_pos.y > hex_pos.x - 1.0 )\n\t{\n\t\tfloat a = hex_pos.x - hex_pos.y;\n\t\tfloat b = hex_pos.x + 2.0 * hex_pos.y;\n\n\t\treturn \n\t\t\t( (1.0-a) * (1.0-b) ) + \n\t\t\t( a * (1.0-b) + (1.0-a) * b ) / 3.0;\n\t}\n\tif( hex_pos_z > hex_pos.x - 2.0 )\n\t{\n\t\tfloat a = 2.0 - (2.0 * hex_pos.x) - hex_pos.y;\n\t\tfloat b = -hex_pos.x + hex_pos.y + 2.0;\n\n\t\treturn a * b / 3.0;\n\n\t}\n\n\treturn 0.0;\n}\n\n//---------------------------------------------------------------------------------------------\n// Vairous reconstruction filtering functions for square and hex domains\n//---------------------------------------------------------------------------------------------\nfloat Square_Point( vec2 pos, float sample_dist )\n{\n\tvec2 sample_pos = round( pos / sample_dist ) * sample_dist;\n\t\n\treturn Sample( sample_pos );\n}\nfloat Square_Linear( vec2 pos, float sample_dist )\n{\n\tpos /= sample_dist;\n\tvec2 base_pos = vec2( floor( pos.x ), floor( pos.y ) );\n\tvec2 interp = pos - base_pos;\n\tvec2 interp_i = vec2(1.0,1.0) - interp;\n\t\n\tvec2 sample_0;\n\tvec2 sample_1;\n\t\n\tvec2 temp;\n\ttemp = base_pos * sample_dist; \tsample_0.x = Sample( temp );\n\ttemp.x += sample_dist;\t\t\tsample_0.y = Sample( temp );\n\ttemp.y += sample_dist;\t\t\tsample_1.y = Sample( temp );\n\ttemp.x -= sample_dist;\t\t\tsample_1.x = Sample( temp );\n\t\n\tvec2 sample_3 = sample_1 * interp.y + sample_0 * interp_i.y;\n\treturn sample_3.y * interp.x + sample_3.x * interp_i.x;\n}\n\nfloat Hex_Point( vec2 pos, float sample_dist )\n{\n\tpos = hex_round( ToHex( pos / sample_dist ) ) * sample_dist;\n\t\n\treturn Sample_Hex( pos );\n}\nfloat Hex_Linear( vec2 pos, float sample_dist )\n{\n\tvec2 hex_pos = ToHex( pos / sample_dist );\n\t\n\tvec2 hex_center = hex_round( hex_pos );\n\tvec2 hex_frac = hex_pos - hex_center;\n\t\n\tfloat \n\tret  = linear_hex_spline( hex_frac               ) * Sample_Hex( (hex_center               ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2( 1, 0) ) * Sample_Hex( (hex_center + vec2( 1, 0) ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2( 0, 1) ) * Sample_Hex( (hex_center + vec2( 0, 1) ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2( 1,-1) ) * Sample_Hex( (hex_center + vec2( 1,-1) ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2(-1, 1) ) * Sample_Hex( (hex_center + vec2(-1, 1) ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2(-1, 0) ) * Sample_Hex( (hex_center + vec2(-1, 0) ) * sample_dist );\n\tret += linear_hex_spline( hex_frac - vec2( 0,-1) ) * Sample_Hex( (hex_center + vec2( 0,-1) ) * sample_dist );\n\t\n\treturn ret;\n}\n\n\n//---------------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Position of pixel in sample space\n\tvec2 pos = ((fragCoord.xy / iResolution.xy) - vec2(.5,.5)) * vec2(2,2);\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tpos.y /= aspect_ratio;\n\t\n\t//Distance between samples in the virtual sampling grid\n\tfloat lerp = sin(iTime * .2)*.5 + .5;\n\tfloat sample_dist = .02;//.015 * lerp + .025 * (1.0 - lerp);\n\t\n\t//Window management\n\tfloat fHeight = Sample( pos );\n\tif( pos.x*2.0 > -pos.y )\n\t{\n\t\tif( pos.y < pos.x*2.0 ){\n\t\t\tfHeight = Square_Linear( pos, sample_dist );\n\t\t}else{\n\t\t\tfHeight = Hex_Point( pos, sample_dist );\n\t\t}\n\t}else{\n\t\tif( pos.y > pos.x*2.0 ){\n\t\t\tfHeight = Hex_Linear( pos, sample_dist );\n\t\t}else{\n\t\t\tfHeight = Square_Point( pos, sample_dist );\n\t\t}\n\t}\n\t\n#ifdef SHOW_SQR_ERROR\n\tfloat diff = (fHeight - Sample( pos ));\n\tfHeight = diff * diff * 80.0;\n#endif\n\t\n\tfragColor = vec4( fHeight, fHeight, fHeight, 1 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfSW7","date":"1401931129","viewed":702,"name":"Squares and Hexes","username":"jjcoolkl","description":"Comparison of hex-based sampling with square samples.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","filtering"],"hasliked":0,"parentid":"","parentname":""}}