{"ver":"0.1","info":{"id":"3dVGzD","date":"1570023669","viewed":181,"name":"Raycast using SDF functions","username":"0xAA55","description":"My test with SDF ray cast. I'm trying to learn how to use this thing to make a physics engine.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raycast","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.141592653589793238462643\n#define ITER_COUNT 80\n#define REFLECT_COUNT 80\n#define SAMPLE_COUNT 1\n\nmat3 mat_rotx(float angle)\n{\n    float sa = sin(angle);\n    float ca = cos(angle);\n    \n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n    \tvec3(0.0,  ca,  sa),\n    \tvec3(0.0,  sa, -ca)\n    );\n}\n\nmat3 mat_roty(float angle)\n{\n    float sa = sin(angle);\n    float ca = cos(angle);\n    \n    return mat3(\n        vec3( ca, 0.0, -sa),\n    \tvec3(0.0, 1.0, 0.0),\n    \tvec3( sa, 0.0,  ca)\n    );\n}\n\nmat3 mat_rotz(float angle)\n{\n    float sa = sin(angle);\n    float ca = cos(angle);\n    \n    return mat3(\n        vec3( ca,  sa, 0.0),\n    \tvec3(-sa,  ca, 0.0),\n    \tvec3(0.0, 0.0, 1.0)\n    );\n}\n\nmat3 mat_iden()\n{\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n    \tvec3(0.0, 1.0, 0.0),\n    \tvec3(0.0, 0.0, 1.0)\n    );\n}\n\nmat3 mat_cam(in vec3 ro, in vec3 ct)\n{\n    vec3 cd = normalize(ct - ro); // Camera direction\n    vec3 up = vec3(0,1,0);\n    vec3 cr = cross(up, cd);\n    vec3 cu = cross(cd, cr);\n    return mat3(cr, cu, cd);\n}\n\nmat3 mat_cam_ypr(float yaw, float pitch, float roll)\n{\n    return mat_roty(yaw) * mat_rotx(pitch + PI * 0.5) * mat_rotz(roll);\n}\n\nfloat max_comp3(vec3 v)\n{\n    return max(v.x, max(v.y, v.z));\n}\n\n// https://www.0xaa55.com/forum.php?mod=viewthread&tid=785\nint holdrand = 1;\n\nvoid srand(float seed)\n{\n    holdrand = int(seed * 65536.0);\n}\n\nfloat rand()\n{\n    holdrand = holdrand * 214013 + 2531011;\n    return float((holdrand >> 16) % 32768) / 32768.0f;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0))\n         + min(max(d.x, max(d.y, d.z)), 0.0); // remove this line for an only partially signed sdf \n}\n\n// Another capsule function that differs from iq's capsule, the capsule is centered.\nfloat sdCapsule(vec3 p, float h, float r)\n{\n    float hh = h * 0.5;\n    p.y = max(abs(p.y) - hh, 0.0);\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 castBB(in vec3 box_size, in vec3 ro, in vec3 rd) // Cast to a bounding box for a distance\n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * box_size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    if(tN > tF || tF < 0.0) return vec2(-1.0);\n    \n    return vec2(tN, tF);\n}\n\nvec2 nearest_item(vec2 o1, vec2 o2)\n{\n    return o1.x <= o2.x ? o1 : o2;\n}\n\nvec2 map_dist(vec3 p)\n{\n    vec3 objc_1 = vec3(-2.0, 0.0, 0.0);\n    vec3 objc_2 = vec3( 0.0, 0.0, 0.0);\n    vec3 objc_3 = vec3( 2.5, 0.0, 0.0);\n    vec3 objc_4 = vec3( 0.0,-3.0, 0.0);\n    vec3 objc_5 = vec3( 0.0, 0.0, 10.0); // The position of 2 walls\n    vec3 objc_6 = vec3( 0.0, 0.0,-10.0);\n    vec3 objc_7 = vec3( 0.0, 0.0, 3.0);\n    \n    vec3 size_1 = vec3( 1.0, 2.0, 1.0) * 0.5;\n    vec3 size_2 = vec3( 1.0, 1.0, 0.5) * 0.5;\n    vec3 size_4 = vec3( 8.0, 0.25, 8.0) * 0.5;\n    vec3 size_5 = vec3( 20.0, 20.0, 1.0) * 0.5;\n    vec3 size_6 = vec3( 20.0, 20.0, 1.0) * 0.5;\n    \n    // Rotation of object 1\n    mat3 m_1 = mat_rotz(PI * 0.25) * mat_roty( iTime * PI * 0.1);\n    // Rotation of object 2\n    mat3 m_2 = mat_roty(PI * 0.25) * mat_rotx(-iTime * PI * 0.2);\n    // Very little rotation of object 5\n    mat3 m_5 = mat_rotx( sin(iTime * PI * 0.1) * PI * 0.01) * mat_roty( cos(iTime * PI * 0.2) * PI * 0.01);\n    \n    vec2 ret = vec2(1e10, -1.0);;\n    vec3 p_of_1 = inverse(m_1) * (p - objc_1);\n    vec3 p_of_2 = inverse(m_2) * (p - objc_2);\n    vec3 p_of_4 = (p - objc_4);\n    vec3 p_of_5 = inverse(m_5) * (p - objc_5);\n    vec3 p_of_6 = (p - objc_6);\n    vec3 p_of_7 = (p - objc_7);\n    ret = nearest_item(ret, vec2(sdBox(p_of_1, size_1), 1.0));\n    ret = nearest_item(ret, vec2(sdBox(p_of_2, size_2), 2.0));\n    ret = nearest_item(ret, vec2(sdBox(p_of_4, size_4) - .5, 4.0));\n    ret = nearest_item(ret, vec2(sdBox(p_of_5, size_5) - .5, 5.0));\n    ret = nearest_item(ret, vec2(sdBox(p_of_6, size_6) - .5, 6.0));\n    ret = nearest_item(ret, vec2(sdCapsule(p_of_7, 1.0, 0.5) - .5, 6.0));\n    \n    vec3 o2nearesto1_p = inverse(m_2) * (objc_3 - p);\n    // The point that's most near to object 1, and it's inside the object 2\n    o2nearesto1_p = min(abs(o2nearesto1_p), size_2) * sign(o2nearesto1_p);\n    vec3 p_of_3 = inverse(m_1) * (p - objc_3 + m_2 * o2nearesto1_p);\n    ret = nearest_item(ret, vec2(sdBox(p_of_3, size_1), 3.0));\n    \n    return ret;\n}\n\nvec3 map_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map_dist( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_dist( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_dist( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_dist( pos + e.xxx ).x );\n}\n\nvec2 map_cast(in vec3 ro, in vec3 rd, in float mint, in float maxt)\n{\n    float t = mint;\n    vec2 not_cast = vec2(-1.0,-1.0);\n    for(int iter = 0; iter < ITER_COUNT; iter++)\n    {\n        vec2 d = map_dist(ro + rd * t);\n        if(abs(d.x) < 0.0001 * t) return vec2(t, d.y);\n        t += d.x;\n        if(t > maxt) return not_cast;\n    }\n    return not_cast;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat soft_shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for(int iter = 0; iter < ITER_COUNT; iter++)\n    {\n        vec2 d = map_dist(ro + rd * t);\n        if(d.x < 0.0001)\n            return 0.0;\n        res = min(res, k * d.x / t);\n        t += d.x;\n    }\n    return res;\n}\n\nvec4 get_color_reflect(float obj)\n{\n    if(abs(obj - 1.0) <= 0.0001)\n    {\n        return vec4(0.5, 0.75, 1.0, 0.5);\n    }\n    else if(abs(obj - 2.0) <= 0.0001)\n    {\n        return vec4(0.25, 1.0, 0.25, 0.5);\n    }\n    else if(abs(obj - 3.0) <= 0.0001)\n    {\n        return vec4(0.375, 0.875, 1.0, 0.75);\n    }\n    else if(abs(obj - 4.0) <= 0.0001)\n    {\n        return vec4(1.0, 1.0, 1.0, 0.0);\n    }\n    else if(abs(obj - 5.0) <= 0.0001)\n    {\n        return vec4(1.0, 1.0, 1.0, 0.5);\n    }\n    else if(abs(obj - 6.0) <= 0.0001)\n    {\n        return vec4(1.0, 1.0, 1.0, 0.5);\n    }\n    else\n    {\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}\n\nvec4 render(in vec3 ro, in vec3 rd)\n{\n    vec3 light_dir = normalize(vec3(0.1, -1.0, 0.1));\n    vec3 accum = vec3(0);\n    vec3 mask = vec3(1);\n    float num_cast = 0.;\n    \n    for(int iter_ray = 0; iter_ray < REFLECT_COUNT; iter_ray ++)\n    {\n        vec2 fm = map_cast(ro, rd, 0.01, 40.0);\n        if(fm.y < 0.0) break;\n        \n        vec3 cast_point = ro + rd * fm.x;\n        vec3 cast_normal = map_normal(cast_point);\n\n        vec4 color_obj = get_color_reflect(fm.y);\n        vec3 diffuse = texture(iChannel1, cast_normal).xyz * color_obj.xyz * soft_shadow(cast_point, -light_dir, 0.01, 40.0, 16.0);\n        vec3 specular = color_obj.xyz * (1.0 - color_obj.w);\n        accum += mask * diffuse;\n        mask *= specular;\n        num_cast++;\n        \n        ro = cast_point;\n        rd = reflect(normalize(rd), cast_normal);\n    }\n    \n    if(num_cast > .5)\n    {\n    \treturn vec4(accum + mask * texture(iChannel0, rd).xyz, 1.0);\n    }\n    else\n    {\n        return texture(iChannel0, rd);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ang = vec3(iTime * PI * 0.01, sin(iTime * PI * 0.02) * PI * 0.125, 0.0);\n    vec3 mm = vec3((iMouse.xy - iResolution.xy * 0.5) * 2.0 / iResolution.yy, 0.0) * vec3(-1,1,1);\n    ang += mm * PI;\n    mat3 mc = mat_cam_ypr(ang.x, ang.y, ang.z);\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) * 2.0 / iResolution.yy;\n    vec3 ro = -mc[2] * 8.0;\n    vec3 rd = normalize(mc * vec3(uv, 1.75));\n    \n    srand(fragCoord.x + fragCoord.y * iResolution.x + fract(iTime) + float(iFrame));\n    \n    vec4 ray_result = render(ro, rd);\n    for(int iter_sample = 1; iter_sample < SAMPLE_COUNT; iter_sample++)\n    {\n        ray_result += render(ro, rd);\n    }\n    ray_result /= vec4(SAMPLE_COUNT);\n    // Output to screen\n    fragColor = ray_result;\n}","name":"Image","description":"","type":"image"}]}