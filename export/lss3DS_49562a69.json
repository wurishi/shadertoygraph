{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Created by ThiSpawn - 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// the base unit is the meter !\n\n//===============================================================================================\n// MATH CONSTANTS\n//===============================================================================================\n\nconst float PI = 3.14159265358979323846;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\n//===============================================================================================\n// COLOR SPACE TOOLS\n//===============================================================================================\n\nconst mat3 mRGB2XYZ = mat3(0.5141364, 0.3238786 , 0.16036376,\n\t\t\t\t           0.265068 , 0.67023428, 0.06409157,\n\t\t\t\t\t       0.0241188, 0.1228178 , 0.84442666);\n\nconst mat3 mXYZ2RGB = mat3( 2.5651, -1.1665, -0.3986,\n\t\t\t\t           -1.0217,  1.9777,  0.0439,\n\t\t\t\t\t        0.0753, -0.2543,  1.1892);\n\nvec3 rgb_to_yxy(vec3 cRGB)\n{\n\tvec3 cYxy;\n    vec3 cXYZ = mRGB2XYZ * cRGB;\n    cYxy.r = cXYZ.g;\n    float temp = dot(vec3(1.0, 1.0, 1.0), cXYZ.rgb); \n    cYxy.gb = cXYZ.rg / temp;\n    return cYxy;\n}\n\nvec3 yxy_to_rgb(vec3 cYxy)\n{\n    vec3 cXYZ = vec3(cYxy.r * cYxy.g / cYxy.b,\n                     cYxy.r,\n                     cYxy.r * (1.0 - cYxy.g - cYxy.b) / cYxy.b);\n    return mXYZ2RGB * cXYZ;\n}\n\nconst vec3 vGammaPowerInverse = vec3(2.2);\nconst vec3 vGammaPower = vec3(0.454545);\n\nvec3 linear_to_gamma(vec3 c)\n{\n\treturn pow(clamp(c, 0.0, 1.0), vGammaPower);\n}\n\nvec3 gamma_to_linear(vec3 c)\n{\n\treturn pow(clamp(c, 0.0, 1.0), vGammaPowerInverse);\n}\n\n//===============================================================================================\n// SCENE PARAMETERS\n//===============================================================================================\n\n// North is pointed by x\n// East is pointed by z\n// Sea Level : y = 0.0\n\nstruct slight // spotlight \n{\n    vec3 pos; \t// position\n\tvec3 d; \t// diameter\n\tfloat i;\t// intensity\n    vec3 c; \t// color\n};\n\n// TODO : fix misplaced stuff from sun_t to planet_t\n\t\nstruct planet_t\n{\n\tfloat rs;  \t\t// sea level radius\n\tfloat ra; \t\t// atmosphere radius\n    vec3  beta_r;\t// rayleigh scattering coefs at sea level\n\tvec3  beta_m; \t// mie scattering coefs at sea level\n    float sh_r; \t// rayleigh scale height\n\tfloat sh_m; \t// mie scale height\n};\n\nplanet_t earth = planet_t(\n    6360.0e3, 6420.0e3,\n    vec3(5.5e-6, 13.0e-6, 22.1e-6),\n\tvec3(18.0e-6), // looks better than 21\n\t7994.0, 1200.0\n);\n\nstruct sun_t\n{  \n\tfloat i;\t\t// sun intensity\n\tfloat mc;\t    // mean cosine\n\tfloat azi; \t\t// azimuth\n\tfloat alt; \t\t// altitude\n\tfloat ad; \t\t// angular diameter (between 0.5244 and 0.5422 for our sun)\n    vec3 color;\n};\n\nsun_t sun = sun_t(\n    20.0,\n    0.76,\n    4.4,\n    PI_2,\n    0.009250245, // 0.53 degree\n    vec3(1.0, 1.0, 1.0)\n);\n\n// Use http://www.esrl.noaa.gov/gmd/grad/solcalc/azel.html to get azimuth and altitude\n// of our sun at a specific place and time\n\n//===============================================================================================\n// RAY MARCHING STUFF\n//===============================================================================================\n\n// pred : rd is normalized\nbool intersect_with_atmosphere(in vec3 ro, in vec3 rd, in planet_t planet, out float tr)\n{\n\tfloat c = length(ro); // distance from center of the planet :)\n\tvec3 up_dir = ro / c;\n\tfloat beta = PI - acos(dot(rd, up_dir)); \n\tfloat sb = sin(beta);\n\tfloat b = planet.ra;\n\tfloat bt = planet.rs - 10.0;\n\t\n\ttr = sqrt((b * b) - (c * c) * (sb * sb)) + c * cos(beta); // sinus law\n\t\n\tif (sqrt((bt * bt) - (c * c) * (sb * sb)) + c * cos(beta) > 0.0)\n\t\treturn false;\n\t\n\treturn true;\n}\n\nconst int SKYLIGHT_NB_VIEWDIR_SAMPLES = 12;\nconst int SKYLIGHT_NB_SUNDIR_SAMPLES = 6;\n\nfloat compute_sun_visibility(in sun_t sun, float alt)\n{\n\tfloat vap = 0.0;\n\tfloat h, a;\n\tfloat vvp = clamp((0.5 + alt / sun.ad), 0.0, 1.0); // vertically visible percentage\n\tif (vvp == 0.0)\n\t\treturn 0.0;\n\telse if (vvp == 1.0)\n\t\treturn 1.0;\n\t\t\n\tbool is_sup;\n\t\n\tif (vvp > 0.5)\n\t{\n\t\tis_sup = true;\n\t\th = (vvp - 0.5) * 2.0;\n\t}\n\telse\n\t{\n\t\tis_sup = false;\n\t\th = (0.5 - vvp) * 2.0;\n\t}\n\t\n\tfloat alpha = acos(h) * 2.0;\n\ta = (alpha - sin(alpha)) / (2.0 * PI);\n\t\n\tif (is_sup)\n\t\tvap = 1.0 - a;\n\telse\n\t\tvap = a;\n\n\treturn vap;\n}\n\n// pred : rd is normalized\nvec3 compute_sky_light(in vec3 ro, in vec3 rd, in planet_t planet, in sun_t sun)\n{\n    float t1;\n\t\n    if (!intersect_with_atmosphere(ro, rd, planet, t1) || t1 < 0.0)\n\t\treturn vec3(0.0);\n    \n    float sl = t1 / float(SKYLIGHT_NB_VIEWDIR_SAMPLES); // seg length\n    float t = 0.0;\n\t\n\tfloat calt = cos(sun.alt);\n\tvec3 sun_dir = vec3(cos(sun.azi) * calt,\n\t\t\t\t\t\tsin(sun.alt),\n\t\t\t\t\t\tsin(sun.azi) * calt);\n\tfloat mu = dot(rd, sun_dir);\n    \n\tfloat mu2 = mu * mu;\n\tfloat mc2 = sun.mc * sun.mc;\n\t\n\t// rayleigh stuff\n\tvec3 sumr = vec3(0.0);\n    float odr = 0.0; // optical depth\n\tfloat phase_r = (3.0 / (16.0 * PI)) * (1.0 + mu2);\n\t\n\t// mie stuff\n\tvec3 summ = vec3(0.0);\n\tfloat odm = 0.0; // optical depth\n\tfloat phase_m = ((3.0 / (8.0 * PI)) * ((1.0 - mc2) * (1.0 + mu2))) /\n\t\t            ((2.0 + mc2) * pow(1.0 + mc2 - 2.0 * sun.mc * mu, 1.5));\n    \n    for (int i = 0; i < SKYLIGHT_NB_VIEWDIR_SAMPLES; ++i)\n\t{\n\t\tvec3 sp = ro + rd * (t + 0.5 * sl);\n        float h = length(sp) - planet.rs;\n        float hr = exp(-h / planet.sh_r) * sl;\n\t\todr += hr;\n        float hm = exp(-h / planet.sh_m) * sl;\n        odm += hm;\n\t\tfloat tm;\n\t\tfloat sp_alt = PI_2 - asin(planet.rs / length(sp));\n\t\tsp_alt += acos(normalize(sp).y) + sun.alt;\n\t\tfloat coef = compute_sun_visibility(sun, sp_alt);\n\t\tif (intersect_with_atmosphere(sp, sun_dir, planet, tm) || coef > 0.0)\n\t\t{\n\t\t\tfloat sll = tm / float(SKYLIGHT_NB_SUNDIR_SAMPLES);\n\t\t\tfloat odlr = 0.0;\n            float odlm = 0.0;\n\t\t\tfor (int j = 0; j < SKYLIGHT_NB_SUNDIR_SAMPLES; ++j)\n\t\t\t{\n\t\t\t\tvec3 spl = sp + sun_dir * ((float(j) + 0.5) * sll);\n\t\t\t\tfloat spl_alt = PI_2 - asin(planet.rs / length(spl));\n\t\t\t\tspl_alt += acos(normalize(spl).y) + sun.alt;\n\t\t\t\tfloat coefl = compute_sun_visibility(sun, spl_alt);\n\t\t\t\tfloat hl = length(spl) - planet.rs;\n\t\t\t\todlr += exp(-hl / planet.sh_r) * sll * (1.0 - log(coefl + 0.000001));\n\t\t\t\todlm += exp(-hl / planet.sh_m) * sll * (1.0 - log(coefl + 0.000001));\n\t\t\t\t\n\t\t\t}\n            vec3 tau_m = planet.beta_m * 1.05 * (odm + odlm);\n\t\t\tvec3 tau_r = planet.beta_r * (odr + odlr);\n            vec3 tau = tau_m + tau_r;\n\t\t\tvec3 attenuation = exp(-tau);\n\t\t\tsumr += hr * attenuation * coef;\n\t\t\tsumm += hm * attenuation * coef;\n\t\t}\n        t += sl;\n    }\n    float direct_coef = 1.0;\n\tif (acos(mu) < sun.ad * 0.6) // makes it a bit bigger\n    \tdirect_coef = 3.0 + sin(mu / (sun.ad * 0.5)) * 3.0;\n    return 0.8 * sun.i * direct_coef * (sumr * phase_r * planet.beta_r + summ * phase_m * planet.beta_m);\n}\n\n//===============================================================================================\n// MAIN\n//===============================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\tfloat view_coef = 0.8;\n    if (p.y < 0.0)\n    {\n    \tp.y = 1.0 + p.y;\n        view_coef = 4.8;\n    }\n\n\tvec3 c_position = vec3(0.0, 1.0, 0.0);\n    vec3 c_lookat   = vec3(-0.04, 1.0, -1.0);\n\tvec3 c_updir    = vec3(0.0, 1.0, 0.0);\n\t\n    vec3 view_dir = normalize(c_lookat - c_position);\n\t\n    vec3 uu = normalize(cross(view_dir, c_updir));\n    vec3 vv = normalize(cross(uu, view_dir));\n\tvec3 rd = normalize(p.x * uu + p.y * vv + view_coef * view_dir);\n\t\n\tsun.alt = 4.0 * -sun.ad + 1.6 * PI_4 * (0.5 + cos(0.46 * iTime) / 2.0);\n\n\tvec3 gp = c_position + vec3(0.0, earth.rs + 1.0, 0.0);\n\tvec3 res = compute_sky_light(gp, rd, earth, sun);\n\t\n\t//================================\n\t// POST EFFECTS\n\t\n    if(q.x > 0.0 )\n    {\n        float crush = 0.6;\n        float frange = 7.9;\n        float exposure = 48.0;\n        res = log2(1.0+res*exposure);\n        res = smoothstep(crush, frange, res);\n        res = res*res*res*(res*(res*6.0 - 15.0) + 10.0);\n    }\n    \n    if (q.y < 0.5 && q.y > 0.498)\n        res = vec3(0.0);\n    \n\t// switch to gamma space before perceptual tweaks\n\tres = linear_to_gamma(res);\n\t\n\t// vignetting\n\t// tensor product of the parametric curve defined by (4(t-tÂ²))^0.1\n\tres *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.1);\n\t\n\t\n\tfragColor = vec4(res, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lss3DS","date":"1378785907","viewed":5583,"name":"Sunsets","username":"ThiSpawn","description":"the scratchapixel implementation enhanced with per sample sun area visibility.","likes":139,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","aerialperspective","atmosphericscattering"],"hasliked":0,"parentid":"","parentname":""}}