{"ver":"0.1","info":{"id":"7lKcz1","date":"1661110040","viewed":40,"name":"Path Tracing CSG","username":"kastorp","description":"this time with pathtracing\nBased on Ray Tracing - Primitives. Created by Reinder Nijhoff\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["csg","pathtracing"],"hasliked":0,"parentid":"7t3yWl","parentname":"RayTracing CSG 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/tl23Rm\n//\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t\n\n\n    vec4 data = texelFetch(iChannel0, ivec2(fc), 0);\n    vec3 col = data.rgb / data.w;\n    \n    // gamma correction\n    col = max( vec3(0), col - 0.004);\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define MAXN 3 //maximum number of intervals 1-6\n\n//----------------------\n#define NOHIT 1e5\n#define ZERO min(iFrame, 0)\n#define time iTime*2.\n\n//structs:\n// Its= ray intersection distance + normal \n// Span = interval between entry point and exit point on convex shape\n// Shape= ordered array of spans on a CSG shape\nstruct Its\n{\n\tfloat t;\n\tuint n;    //normal \n\t\n};\n\nconst Its  NO_its=Its(NOHIT,0u);\nstruct Span\n{\n\tIts n;\n\tIts f;\n\tbool merged;\n};\n\nstruct Shape\n{\n\tint l; \n\tSpan[MAXN] s;\n};\n\n\nvoid init(inout Shape y){\n\ty.l=0;\n}\n\n\n\nvoid add(inout Shape y,  Span x){\n\n\n    if(y.l>=MAXN) return;\n    int id=y.l++; \n\n\tif(id==0) y.s[0]=x;\n#if (MAXN>1)      \n    else if(id==1) y.s[1]=x;\n#endif\n#if (MAXN>2)   \n    else if(id==2) y.s[2]=x;\n#endif\n#if (MAXN>3)    \n    else if(id==3) y.s[3]=x;\n#endif \n#if (MAXN>4)  \n    else if(id==4) y.s[4]=x;\n#endif\n#if (MAXN>5)  \n    else if(id==5) y.s[5]=x;\n#endif\n#if (MAXN>6)  \n    else if(id==6) y.s[6]=x;\n#endif\n\n\n}\n\nbool seq(inout Its a1, inout Its a2, inout Its a3,inout Its a4)\n{\n    return a1.t<a2.t && a2.t<a3.t && a3.t<a4.t;\n}\nbool seq(inout Its a1,inout Its a2)\n{\n    return a1.t<a2.t ;\n}\nShape getShape( Span x){\n    Shape s;s.l=0;  add(s,x);\n    return s;\n}\n\n\nbool no_hit(Span x) {return x.n.t==NOHIT || x.f.t<0.; }\n\n//-------------------------------\n//UNION A+B:\nvoid addMerge(inout Shape cs,  Span y,bool reduce){\n    if(reduce){\n        if(y.merged) return;\n        for(int j=0;j<cs.l;j++)\n        {           \n            Span x=cs.s[j];\n            if(x.merged) continue;\n            else if(seq(x.f,y.n)|| seq(y.f,x.n )) continue;\n            else if(seq(x.n,y.n,x.f,y.f)) {cs.s[j].merged=true; y=Span(x.n,y.f,false);}\n            else if(seq(y.n,x.n,y.f,x.f)) {cs.s[j].merged=true; y=Span(y.n,x.f,false);}\n            else if(seq(x.n,y.n,y.f,x.f)) {cs.s[j].merged=true; y=Span(x.n,x.f,false);}\n            else if(seq(y.n,x.n,x.f,y.f)) {cs.s[j].merged=true; y=Span(y.n,y.f,false); }\n        }\n    }\n    add(cs,y);    \n}\n\nShape Union(Shape as, Shape bs,bool reduce){   \n    Shape cs;\n    init(cs);\n    for(int i=0;i<as.l;i++) addMerge(cs,as.s[i],reduce);\n    for(int i=0;i<bs.l;i++) addMerge(cs,bs.s[i],reduce);\n\n    if(!reduce) return cs;    \n    //ds=REDUCE(cs)\n    Shape ds;\n    init(ds);\n    for(int i=0;i<cs.l;i++) if(!cs.s[i].merged) add(ds,cs.s[i]);\n    return ds;\n}\n\n \n\n//-------------------------------\n//INTERSECTION A*B:\nShape Inter(Shape as, Shape bs){ \n    Shape cs;\n    init(cs);\n    for(int i=0;i<as.l;i++) {\n        Span a=as.s[i];\n        if(no_hit(a)) continue;\n        for(int j=0;j<bs.l;j++) {\n            Span b=bs.s[j];\n            if(no_hit(b)) continue;\n            else if(seq( a.f,b.n)|| seq(b.f,a.n )) continue;\n            else if(seq(a.n,b.n,a.f,b.f)) add(cs,Span(b.n,a.f,false));\n            else if(seq(b.n,a.n,b.f,a.f)) add(cs,Span(a.n,b.f,false));\n            else if(seq(a.n,b.n,b.f,a.f)) add(cs,b);\n            else if(seq(b.n,a.n,a.f,b.f)) add(cs,a);\t\t\n        }\n    }\n    return cs;\n}\n//-----------------------------\n//SUBTRACTION A-B:\nShape Sub(Shape as, Span b){\n    Shape cs;\n    init(cs);\n     for(int j=0;j<as.l;j++) {\n        Span a=as.s[j];\n        if(no_hit(a) ) continue;\n        if(seq( a.f,b.n)) add(cs,a);\n        else if(seq(b.f,a.n )) add(cs,a);\n        else if(seq(a.n,b.n,a.f,b.f)) add(cs,Span(a.n,b.n,false)); \n        else if(seq(b.n,a.n,b.f,a.f)) add(cs,Span(b.f,a.f,false)); \n        else if(seq(a.n,b.n,b.f,a.f)) {add(cs,Span(a.n,b.n,false)); add(cs,Span(b.f,a.f,false)); }\n        else if(seq(b.n,a.n,a.f,b.f)) continue;\t\n    }\n    return cs;\n}\n\nShape Sub(Shape as, Shape bs){ \n    for(int i=0;i<bs.l;i++) {\n        Span b=bs.s[i];        \n        if(!no_hit(b)) as=Sub( as,  b);        \n    }\n    return as;\n}\n\n//----------------------------\n\n\n//IQ normal compression https://www.shadertoy.com/view/llfcRl\nuint direct_32( in vec3 nor )\n{\n    nor /= max(max(abs(nor.x),abs(nor.y)),abs(nor.z));\n\n    vec3 v = 0.5 + 0.5*nor;\n    uvec3 d = uvec3(round(v*vec3(2047.0,1023.0,2047.0)));\n    return d.x|(d.y<<11u)|(d.z<<21u);\n}\n\nvec3 i_direct_32( uint data )\n{\n    uvec3 d = uvec3( data, data>>11, data>>21 ) & uvec3(2047u,1023u,2047u);\n    vec3 v = vec3(d)*2.0/vec3(2047.0,1023.0,2047.0) - 1.0;\n    return normalize(v);\n}\n//-----------Intersection primitives--------------------\nSpan iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return Span(NO_its,NO_its,true); // no intersection\n    h = sqrt( h );\n    vec3 oNor =normalize(ro-(b+h)*rd); \n    vec3 fNor= normalize(ro-(b-h)*rd); \n    if( h-b < 0. ) return  Span(NO_its,NO_its,true);\n    return Span(Its(-b-h,direct_32(oNor)) , Its(-b+h,direct_32(-fNor)),false);\n}\n\nSpan iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return Span(NO_its,NO_its,true); // no intersection\n    vec3 oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); \n     vec3  fNor=- sign(rd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy); \n    return  Span(Its(tN,direct_32(oNor)) , Its(tF,direct_32(fNor)),false);\n}\n\nSpan iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d= -(dot(ro,n)+h)/dot(rd,n);\n    vec3  u = normalize(cross(n,vec3(0,0,1))), v = normalize(cross(u,n) );\n    vec3 oFuv=vec3(1.,dot(ro+d*rd,u), dot(ro+d*rd,v));\n    vec3 oNor=n;\n    if(d<0.)  return Span(NO_its,NO_its,true);\n    return Span(Its(d,direct_32(oNor)),NO_its,false);\n}\n/*\nSpan iCylinder( in vec3 ro, in vec3 rd,  in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, \n{\n    Span no_hit =  Span(NO_its,NO_its,true);;\n\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 )  return no_hit;\n    h = sqrt(h);\n    \n    float t = (-k1-h)/k2;\n    float y = baoc + t*bard; \n    float t2 = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;   \n    \n    if( (y<0.0 || y>baba )  && abs(k1+k2*t2)>h)  return no_hit;\n    Its iN,iF;\n    vec3 w = normalize(ba), u = normalize(cross(ba,vec3(0,0,1))), v = normalize(cross(u,w) );\n    \n    //entry point\n    vec3 q = (oc+t*rd-ba)*mat3(u,v,w);   \n    if( y>0.0 && y<baba ) iN= Its( t, direct_32((oc+t*rd - ba*y/baba)/ra) ); \n    else iN= Its(t2, direct_32(ba*sign(y)/baba )); \n        \n  \n    //exit point\n    t = (-k1+ h)/k2;\n    y = baoc + t*bard; \n    t2 = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    q = (oc+t*rd-ba)*mat3(u,v,w); \n    if( y>0.0 && y<baba ) iF= Its( t, direct_32((oc+t*rd - ba*y/baba)/ra) ); \n    else iF= Its(t2, direct_32(ba*sign(y)/baba) ); \n    \n    return Span(iN , iF ,false);\n  \n}*/\n\n//---------mixed functions--------------------------\n\n\nstruct Hit{   \n    float d;\n    vec3 n;\n    float id;\n};\n\n\nHit FastUnion( Hit a, Hit b)\n{\n   if(a.d<b.d ) return a;\n   else return b;\n}\n#define Add(_ro,_func) _ro = FastUnion(_ro,_func);\n\nuint erot(uint n, vec3 ax, float ro) {\n    vec3 p= i_direct_32(n) ;\n    return direct_32(mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p));\n}\nvec3 erot(vec3 p, vec3 ax, float ro) {\n\n    return (mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p));\n}\n\nvoid erot(inout Shape s,vec3 ax, float an){\n    for(int i=0;i <s.l;i++){\n        s.s[i].n.n=erot(s.s[i].n.n, ax, an);\n        s.s[i].f.n=erot(s.s[i].f.n, ax, an);\n    }   \n}\n//unused here\n#define  RotGroup( _p, _rd, _ro, _ax,  _c ,  _a,  _body) \\\n     vec3 _rdt= _rd; \\\n    _p=erot( _p , _ax, _a); \\\n    _rdt=  normalize(erot( _rdt , _ax, _a)); \\\n    _body \\\n    _ro.n=  normalize(erot( _ro.n , _ax, -_a)); \\\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Raytracing CSG 2  by Kastorp\n//------------------------------\n//another experiment: a sphere with 21 subtractions\n//Artifacts are  due to limiting the number of intervals MAXN to 4\n//NOTE: poor performances with openGL\n//------------------------------------\n\nHit Ray(Shape y,float mat){\n       \n    float tMin=NOHIT;\n    int idm=-1;\n    \n    for(int i=0;i<y.l;i++) if(y.s[i].n.t<tMin && y.s[i].f.t>1e-4 ) {idm=i;tMin=y.s[i].n.t;}\n    if(idm<0) return Hit(NOHIT,vec3(0),mat);\n    \n    Its ix = y.s[idm].n;\n    if(ix.t<0. ) ix= y.s[idm].f;\n    \n    return Hit( ix.t,i_direct_32(ix.n),mat);\n}\nShape gear(vec3 rd,vec3 ro ,float n,float v) {\n    float tk=.2,sz=tk*n*1.2;\n    Shape s= getShape(iSphere(ro,rd,sz));\n    s= Inter(s,getShape(iBox(ro,rd,vec3(sz,sz,.08))));\n    s= Sub(s,getShape(iSphere(ro,rd,sz-tk*2.)));\n    Shape s2; \n    for(int i=0;i<int(n);i++){\n        float  an=3.14/n*float(i)+iTime/n*v;\n        vec3  ax=vec3(0,0,1),\n              rro= erot(ro,  ax, an),\n              rrd= erot(rd,  ax, an);\n        s2= getShape(iBox(rro,rrd,vec3(sz+tk,tk,sz+tk)));\n        erot(s2,ax,-an);        \n        s= Sub(s,s2);  \n        \n    }\n    s2= getShape(iSphere(ro,rd,sz-tk));\n    s2= Sub(s2,getShape(iSphere(ro,rd,sz-3.*tk)));\n    s2= Inter(s2,getShape(iBox(ro,rd,vec3(sz,sz,.1))));\n    s= Union(s2,s,true);\n    return s;\n}\nHit trace(vec3 rd,vec3 ro ) { \n   \n\n    Shape s= getShape(iPlane(ro,rd,vec3(0,1.,0),0.));\n    Hit r =  Ray(s,1.);\n\n#if 1\n    s= getShape(iSphere(ro-vec3(0.,2.,0.),rd,2.));\n    Shape s2;  \n    \n    for(int i=0;i<21;i++){\n        float tk=.1, h=-1.65 + .55 *float(i%7);\n        vec3 sz= i>=14?vec3(3.,3.,tk) : i>=7? vec3(tk,3.,3.):vec3(3.,tk,3.);\n        vec3 pos = i>=14? vec3(0,2.,h): i>=7? vec3(h,2.,0.):vec3(0.,2.+h,0.);\n        s2= getShape(iBox(ro-pos,rd,sz));\n        s= Sub(s,s2);    \n    }\n   Add(r,Ray(s,3.)); \n#else\n\n    Add(r,Ray(gear(rd,ro-vec3(0,2.,0),5.,1.),3.));\n    Add(r,Ray(gear(rd,ro-vec3(1.75,3.0,0),4.,-1.),3.));\n#endif\n   return r; \n           \n   \n}\n\n\n#define PATH_LENGTH 8\n#define MAX_DIST 1e10\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray tracer helper functions\n//\n\nfloat FresnelSchlickRoughness( float cosTheta, float F0, float roughness ) {\n    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);\n}\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec3 modifyDirectionWithRoughness( const vec3 normal, const vec3 n, const float roughness, inout float seed ) {\n    vec2 r = hash2(seed);\n    \n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\t\n    float a = roughness*roughness;\n    \n\tfloat rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));\n\tfloat ra = sqrt(abs(1.-rz*rz));\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    \n    vec3 ret = normalize(rr);\n    return dot(ret,normal) > 0. ? ret : n;\n}\n\nvec2 randomInUnitDisk( inout float seed ) {\n    vec2 h = hash2(seed) * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n//\n// Scene description\n//\n\nvec3 rotateY( const in vec3 p, const in float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n      \nvec3 worldhit( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal ) {\n    vec3  d = vec3(dist, 0.);\n    Hit h =trace(rd,ro);\n    if( h.d<d.y && h.d>d.x &&  h.d< NOHIT) {\n        normal=h.n;\n        d=vec3(d.y, h.d, h.id);\n    }\n\treturn d;    \n}\n\n//\n// Palette by Íñigo Quílez: \n// https://www.shadertoy.com/view/ll2GD3\n//\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos(6.28318530718*(c*t+d));\n}\n\nfloat checkerBoard( vec2 p ) {\n   return mod(floor(p.x) + floor(p.y), 2.);\n}\n\nvec3 getSkyColor( vec3 rd ) {\n    vec3 col = mix(vec3(1),vec3(.5,.7,1), .5+.5*rd.y);\n    float sun = clamp(dot(normalize(vec3(-.4,.7,-.6)),rd), 0., 1.);\n    col += vec3(1,.6,.1)*(pow(sun,4.) + 10.*pow(sun,32.));\n    return col;\n}\n\n#define LAMBERTIAN 0.\n#define METAL 1.\n#define DIELECTRIC 2.\n\nfloat gpuIndepentHash(float p) {\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid getMaterialProperties(in vec3 pos, in float mat, \n                           out vec3 albedo, out float type, out float roughness) {\n    albedo = pal(mat*.59996323+.5, vec3(.5),vec3(.5),vec3(1),vec3(0,.1,.2));\n\n    if( mat < 1.5 ) {            \n        albedo = vec3(.25 + .25*checkerBoard(pos.xz ));\n        roughness = .75 * albedo.x - .15;\n        type = METAL;\n    } else {\n        type = floor(gpuIndepentHash(mat+.3) * 3.);\n        roughness = (1.-type*.475) * gpuIndepentHash(mat);\n    }\n}\n\n//\n// Simple ray tracer\n//\n\nfloat schlick(float cosine, float r0) {\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\nvec3 render( in vec3 ro, in vec3 rd, inout float seed ) {\n    vec3 albedo, normal, col = vec3(1.); \n    float roughness, type;\n    \n    for (int i=0; i<PATH_LENGTH; ++i) {    \n    \tvec3 res = worldhit( ro, rd, vec2(1e-9, 100), normal );\n\t\tif (res.z > 0.) {\n\t\t\tro += rd * res.y;\n       \t\t\n            getMaterialProperties(ro, res.z, albedo, type, roughness);\n            \n            if (type < LAMBERTIAN+.5) { // Added/hacked a reflection term\n                float F = FresnelSchlickRoughness(max(0.,-dot(normal, rd)), .04, roughness);\n                if (F > hash1(seed)) {\n                    rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);\n                } else {\n                    col *= albedo;\n\t\t\t        rd = cosWeightedRandomHemisphereDirection(normal, seed);\n                }\n            } else if (type < METAL+.5) {\n                col *= albedo;\n                rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);            \n            } else { // DIELECTRIC\n                vec3 normalOut, refracted;\n                float ni_over_nt, cosine, reflectProb = 1.;\n                if (dot(rd, normal) > 0.) {\n                    normalOut = -normal;\n            \t\tni_over_nt = 1.4;\n                    cosine = dot(rd, normal);\n                    cosine = sqrt(1.-(1.4*1.4)-(1.4*1.4)*cosine*cosine);\n                } else {\n                    normalOut = normal;\n                    ni_over_nt = 1./1.4;\n                    cosine = -dot(rd, normal);\n                }\n            \n\t            // Refract the ray.\n\t            refracted = refract(normalize(rd), normalOut, ni_over_nt);\n    \t        \n        \t    // Handle total internal reflection.\n                if(refracted != vec3(0)) {\n                \tfloat r0 = (1.-ni_over_nt)/(1.+ni_over_nt);\n\t        \t\treflectProb = FresnelSchlickRoughness(cosine, r0*r0, roughness);\n                }\n                \n                rd = hash1(seed) <= reflectProb ? reflect(rd,normal) : refracted;\n                rd = modifyDirectionWithRoughness(-normalOut, rd, roughness, seed);            \n            }\n        } else {\n            col *= getSkyColor(rd);\n\t\t\treturn col;\n        }\n    }  \n    return vec3(0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool reset = iFrame == 0;\n            \n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.0) : \n              abs(iMouse.xy)/iResolution.xy - .5;\n        \n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    if (round(mo*iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\n        reset = true;\n    }\n    \n    vec3 ro = vec3(+4.5*(mo.x), 2., +4.5*(.5-mo.y));\n    vec3 ta = vec3(0.,2.,-10.);\n    mat3 ca = setCamera(ro, ta, 0.);    \n    vec3 normal;\n    \n    float fpd = .7;//data.x;\n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n        // Calculate focus plane.\n        float nfpd =  worldhit(ro, normalize(vec3(.0,0.4,0)-ro), vec2(0, 100), normal).y;\n\t\tfragColor = vec4(nfpd, mo*iResolution.xy, iResolution.x);\n    } else { \n        vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n        float seed = float(baseHash(floatBitsToUint(p- iTime)))/float(0xffffffffU);\n\n        // AA\n        p += 2.*hash2(seed)/iResolution.y ;\n        vec3 rd = ca * normalize( vec3(p.xy,1.6) );  \n\n        // DOF\n        vec3 fp = ro + rd * fpd;\n        ro = ro + ca * vec3(randomInUnitDisk(seed), 0.)*.003;\n        rd = normalize(fp - ro);\n\n        vec3 col = render(ro, rd, seed);\n\n        if (reset) {\n           fragColor = vec4(col, 1);\n        } else {\n           fragColor = vec4(col, 1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}