{"ver":"0.1","info":{"id":"3tVGzw","date":"1578622341","viewed":91,"name":"Flying thingys","username":"vstelegin","description":"Learning the basics","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["noise","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\tvec3 col = texture(iChannel0, uv).rgb ;/// float(iFrame);\n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 light1 = normalize(vec3(1.0, 1.0, -1.0));\nconst vec3 light2 = normalize(vec3(-1.0,0.0, 0.0));\nfloat scene(vec3 p){\n    float speed = iTime;\n    speed *= 0.1;\n    vec3 offset = vec3(0,0,1.0);\n    p.z += speed *0.5;\n    p.x += sin(p.y + speed * p.z * 0.0001) + sin(p.z * 0.1);\n    p.y += sin(p.x + speed) + p.z * 0.1;\n    p = mod(p,5.) - 2.5;\n\treturn length( p.x*p.z*p.y * 10.9) - 1.0;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tscene(p+e.xyy) - scene(p-e.xyy),\n\t\tscene(p+e.yxy) - scene(p-e.yxy),\n\t\tscene(p+e.yyx) - scene(p-e.yyx) );\n    return normalize(n);\n}\nfloat seed = 0.0;\nfloat rand(float factor) { return fract(sin(factor + seed++)*43758.5453123); }\nfloat hash( in vec2 p )  \n{\n    p.x += rand(iTime);\n    p.y += rand(iTime * 3.321);\n    p  = 55.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord+fragCoord - iResolution.xy) / iResolution.y;\n\tvec2 uv2d = fragCoord/iResolution.xy;\n\t\n    \n\tvec3 ro = vec3(hash(uv)*0.01,hash(uv + 1.0)*0.01,-20);\n    vec3 rd = vec3(uv.rg, 1);\n    \n    rd = normalize(rd);\n    float d = 2.0;\n    float raystep = 0.01;\n    for (int i=0; i<320; i++){\n        \n    \tvec3 p = ro + rd * d;\n    \tfloat r = scene(p);\n        int outside = int (r > 0.001);\n        d += float(outside) * r;\n    }\n    vec3 p = ro + rd * d;\n    float result = step(scene(p), 1.0);\n    vec3 normal =  nor(p, 0.01);\n   \tfloat diffuse = dot(light1,normal);\n    diffuse = clamp(diffuse, 0.0, 1.0);\n    float specular = dot(reflect(rd,normal), light2);\n    specular = clamp(specular*specular,0.0,1.0);\n    vec3 color = vec3 (1.0, 1.0, 1.0);\n    float fog = clamp( 0.1*(26.0 - d) ,0.0, 1.0);\n    vec4 finalColor = vec4( (diffuse * color + specular) * result * fog,0);\n    fragColor = texture(iChannel0, uv2d)*0.95 + finalColor *0.05;\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}