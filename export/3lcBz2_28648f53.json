{"ver":"0.1","info":{"id":"3lcBz2","date":"1613041960","viewed":144,"name":"Raymarching Fork - Soft Shadows","username":"Vasky","description":"Soft shadows were added\nOriginal shader: https://www.shadertoy.com/view/WsByzK","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingheightmapplanedepth"],"hasliked":0,"parentid":"WsByzK","parentname":"Raymarching plane height map"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @author ciphered <https://ciphrd.com>\n// @license MIT\n//\n// -----------\n//\n// This shader was made to be working with a vertical plane, parallel to the view screen,\n// passing by (0;0;0). This constraint allows for great optimizations, because this shader \n// is intended to be working along texture manipulations to play with the surface.\n//\n// 2 parallel planes are defined in the space, in front of the camera, with a gap between\n// them corresponding to the DEPTH parameter. For each ray casted from the camera, we first\n// find the intersection between the ray and the first plane. From there, we start marching\n// along the ray and sample the height map at each step to find if whether we're in the\n// volume or not. Once we reach a point within the volume, we can find the point that belongs\n// to the surface and light it accordingly by computing the height map gradient.\n//\n// This is basically a fancy 3d texture renderer\n//\n// If you change the input texture, adjust the DEPTH accordingly\n//\n// Keep in mind that the textures do not represent to height of the elements within, only\n// the default one works correctly for this example\n//\n//\n// LIMITATIONS\n//\n// I coudln't find a way to get soft shadows, if you do feel free to make me know in the comments\n// This version does not provide a COLOR MAP, however it's pretty easy to color the surface using a\n// color map, just copy the getHeightMapValue function to sample from a color map instead of a depthmap\n//\n//\n// ## Soft shadows were added by Vasky ##\n\n\n#define PI 3.14159265359\n#define MAX_ITERATIONS 200\n\n// needs to be adujested to match the input texture\n#define DEPTH 0.6\n\n// the step size for the ray marching\n#define PRECISION 0.006\n\n// the lower this is, the more precise the normals get (too much precision results in the\n// apparition of normal artifacts\n#define EPSILON 0.002\n\n//shading algorithm (1 - hard shadows, 2 (or any other number) - soft shadows)\n#define VAR 2\n\n\n// returns the intersection point between the ray and the hightest point on the plane\nvec3 boundsSDF (vec3 ro, vec3 rd, float h) {\n    // the z length of the target vector\n    float dz = ro.z - h;\n    float t = dz / rd.z;\n    return vec3(\n    \tro.x - rd.x * t,\n        ro.y - rd.y * t,\n        ro.z - rd.z * t\n    );\n}\n\n// returns the height map value of any point in space\n// this is done by projecting the point on the vertical plane\nfloat getHeightMapValue (vec3 p) {\n    // yes this is a projection\n    vec2 tuv = p.xy;\n    tuv.x+= iTime * .1;\n    tuv = fract(tuv - .5);\n    \n    vec3 hm = texture(iChannel0, tuv).rgb;\n    \n    return .9 * (hm.r+hm.g+hm.b)/3. + 0.1;\n}\n\nvec3 calcNormal (vec3 p) {\n\tfloat hx1 = getHeightMapValue(vec3(p.x - EPSILON, p.y, 0.0)) * DEPTH;   \n    float hx2 = getHeightMapValue(vec3(p.x + EPSILON, p.y, 0.0)) * DEPTH;\n    vec3 pu = normalize(vec3(2.0 * EPSILON, 0.0, hx2 - hx1));\n    \n    float hy1 = getHeightMapValue(vec3(p.x, p.y, 0.0)) * DEPTH;\n    float hy2 = getHeightMapValue(vec3(p.x, p.y + EPSILON, 0.0)) * DEPTH;\n    vec3 pv = normalize(vec3(0.0, EPSILON, hy2 - hy1));\n    \n    return cross(pu, pv);\n}\n\nvec3 calcLight( in vec3 pos , in vec3 lightp, in vec3 lightc, in vec3 camdir, float spec)\n{    \n\tvec3 normal = calcNormal(pos);\n    vec3 lightdir = normalize(pos - lightp);\n    float cosa = pow(0.5+0.5*dot(normal, -lightdir), 3.0);\n    float cosr = max(dot(-camdir, reflect(lightdir, normal)), 0.0);\n    \n    vec3 ambiant = vec3(0.1);\n    vec3 diffuse = vec3(0.5 * cosa);\n    vec3 phong = vec3(0.1 * pow(cosr, spec)) * .4;\n    \n    return lightc * (ambiant + diffuse + phong);\n}\n\nvec4 raymarching (vec3 p, vec3 dir) {\n    vec3 prev = p;\n    vec3 curr = p;\n    float lastD = p.z;\n    float hmap = 0.;\n    float df = 0.;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n    \tprev = curr;\n        curr = prev + dir * PRECISION;\n        \n        if (curr.z < 0.0) {\n        \treturn vec4(0, 0, 1, 0);    \n        }\n        \n        hmap = getHeightMapValue(curr);\n        // distance to the displaced surface\n        float df = curr.z - hmap * DEPTH;\n        \n        // if we have an intersection\n        if (df < 0.0) {\n        \t// linear interpolation to find more precise df\n            float t = lastD / (abs(df)+lastD);\n            vec3 pi = prev + t * (curr - prev);\n            float h = getHeightMapValue(pi);\n            return vec4(pi, h);\n        } else {\n         \tlastD = df;\n        }\n    }\n    \n    //return vec4(0, 0, 1, 0);\n}\n\n// computes a sharp shadow for a given point p of the surface\nfloat shadow (vec3 p, vec3 lpos) {\n    vec3 dir = normalize(lpos - p);\n    vec3 curr = p;\n    float hmap;\n      \n    if (VAR==1)\n    {\n        //hard shadows\n        for (int i = 0; i < MAX_ITERATIONS; i++) \n        {\n            curr+= dir * PRECISION;\n\n            if (curr.z < 0.0) \n            {\n                return 0.0;\n            }\n\n            hmap = getHeightMapValue(curr);\n\n            // distance to the displaced surface\n            float df = curr.z - hmap * DEPTH;\n\n            if (df < 0.0) \n            {\n                return 1.0;\n            }\n        }\n    }\n    else\n    {\n        //Soft shadows\n        //the idea was taken from shader by Inigo Quilez: https://www.shadertoy.com/view/MdX3Rr\n        //And from his article about soft shadow: https://iquilezles.org/articles/rmshadows\n        float sh = 1.0;\n        \n        //detail level\n        float t = 0.0005;\n        \n        for (int i=0;i<400; i++)\n        {\n            vec3 pos = p + t*lpos; \n            hmap = getHeightMapValue(pos);\n            float h = pos.z-DEPTH*hmap;\n            float softness = 0.2;\n            sh = min(sh, softness*h/t);\n            //t += t*h; //standart solution\n            t += clamp(h,0.0,0.0001); //works a little bit better with extreme light angles\n            \n        }\n        return clamp( sh, 0.0, 1.0 );\n    }\n    \n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x*= iResolution.x/iResolution.y;\n    \n    float camZ = 1.2;// + cos(iTime*.1) * .1;\n    \n    vec3 ro = vec3(0.0, 0.0, camZ);\n    vec3 cw = normalize(vec3(0.0, 0.0, 0.0) - ro);\n    vec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = mat3(cu, cv, cw) * normalize(vec3(uv, 1.0));\n    \n    vec4 col = vec4(0, 0, 0, 1);\n    \n    // the intersection to the highest plane\n    vec3 inter = boundsSDF(ro, rd, DEPTH);\n    \n    // the raymarching\n    vec4 rm = raymarching(inter.xyz, rd);\n    \n    if (rm.w > 999.0) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec3 normal = calcNormal(rm.xyz);\n    \n    vec3 lpos = vec3(cos(iTime)*20., sin(iTime)*20., 7.0);\n    //vec3 lpos = vec3(4.0, 4.0, 2.0);\n    \n    col.rgb = calcLight(rm.xyz , lpos, vec3(1.0, 1.0, 1.0), rd, 0.5);\n    \n    // we get the shadow\n    float shad = shadow(rm.xyz, lpos);\n    if (VAR==1)\n    {\n       col.rgb*= 0.5 + .5 * (1. - shad);\n    }\n    else\n    {\n        float diff = 0.2;\n        col.rgb *= vec3(diff + (1.0-diff) * (shad));\n    }\n    \n    //col.rgb = normal;\n   \n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}