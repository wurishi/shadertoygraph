{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n// Deform - square tunnel : REDUX\n// Modifications by Stanley Hayes\n// Original Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Hsv conversion from http://ploobs.com.br/?p=1499\n\nvec3 Hue(float a){\nvec3 K = vec3(3,2,1)/3.;\nreturn clamp(abs(fract(vec3(a)+K)*6. - vec3(3.)) - K.xxx, 0., 1.);}\nvec3 HSVtoRGB(vec3 HSV){return vec3(((Hue(HSV.x) - 1.0) * HSV.y + 1.0) * HSV.z);}\n\n \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float Time = iTime * .4;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    // angle of each pixel to the center of the screen\n        \n    // modified distance metric. Usually distance = (xÂ² + yÂ²)^(1/2). By replacing all the \"2\" numbers\n    // by 32 in that formula we can create distance metrics other than the euclidean. The higher the\n    // exponent, then more square the metric becomes. More information here:\n    \n    // http://en.wikipedia.org/wiki/Minkowski_distance\n    \n    float exp = 1.0;\n    float crayStationsCoef = .501; \n    p.x +=  sin(pow(Time,.5))*crayStationsCoef*.9;\n   //p.y +=  cos(Time)*crayStationsCoef*10.0;\n    float a = atan(p.y,p.x) + Time * sin(Time)*.002 + iMouse.x * .0001;\n    float r = pow( pow(p.x*p.x,exp) + pow(p.y*p.y,exp), 1.0/(exp * 2.0) ) + sin(Time)*crayStationsCoef + .16;\n    a += pow(r,50.); \n    r = r * r; \n    \n    // index texture by angle and radious, and animate along radius    \n    vec2 uv = vec2( 0.5/r + 0.5*Time + iMouse.y,                    a/3.1416 );\n    r -= sin(Time)*.05;    \n       \n    // fecth color and darken in the center\n    vec3 col =  texture( iChannel0, uv ).xyz * r;\n    col = HSVtoRGB(vec3(sin(col.r)*.3+.5, 1.0, 1.0)); \n\t\n    col.r *= (sin(uv.x*5.0)*.7 + 1.0) * .9;\n    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xlf3zS","date":"1422746746","viewed":340,"name":"TunnelOrb","username":"StanRee","description":"Another Play On Iq's Tunnel","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""}}