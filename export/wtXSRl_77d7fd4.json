{"ver":"0.1","info":{"id":"wtXSRl","date":"1563877302","viewed":433,"name":"2d-sdf-shadow","username":"liutp","description":"2d shadow with sdf","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","sdf","shadow","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MinY 0.0\n\nvec2 translate(vec2 p, vec2 t){\n\treturn p - t;\n}\n\nfloat box(vec2 p, vec2 size, float radius) {\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat boxDist(vec2 p, vec2 boxOrg, vec2 boxSize, float radius){\n    return box(translate(p, boxOrg), boxSize, radius);\n}\n\n//获取p点的SDF(Signed-Distance-Field)值\nfloat sdf(vec2 p) {\n    float a1 =  boxDist(p, vec2(200.0, 150.0+MinY), vec2(40.0, 40.0), 0.0);\n    float a2 =  boxDist(p, vec2(350.0, 250.0+MinY), vec2(40.0, 40.0), 0.0);\n    float a3 =  boxDist(p, vec2(500.0, 150.0+MinY), vec2(40.0, 40.0), 0.0);\n    float a4 =  boxDist(p, vec2(500.0, 350.0+MinY), vec2(40.0, 40.0), 0.0);\n    float a5 =  boxDist(p, vec2(100.0, 350.0+MinY), vec2(40.0, 40.0), 0.0);\n    float l = min(min(min(min(a1, a2), a3), a4), a5);\n    return l/max(iResolution.x, iResolution.y);\n}\n\n#define EPSILON 0.01\n#define MAX_MARCHING_STEPS 64\nfloat shadow(vec2 light, vec2 pos, float hard) {\n\tfloat l = abs(length( light - pos));\n    vec2  viewRayDirection = (light-pos)/l;\n\n    float res = 1./hard;\n    float dt = 0.01;\n\n    float ph = 1e20;\n\n    //最多尝试MAX_MARCHING_STEPS次\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i){\n        float sd = sdf(pos + viewRayDirection*dt)*max(iResolution.x, iResolution.y);\n        if (sd < EPSILON) {return 0.0;}\n        \n        {\n            //GDC 2018,Sebastian Aaltonen\n            float y = sd*sd/(2.0*ph);\n            float d = sqrt(sd*sd-y*y);\n            res = min( res, d/max(0.0,dt-y));\n            ph = sd;\n        }\n        {\n            //res = min(res, sd/dt);\n        }\n        if (res<=EPSILON/hard) {res = 0.0; break;}\n        \n        dt += max(1.0, abs(sd));\n\t\tif (dt >= l) break;\n    }\n    \n    return smoothstep(0.0,1.0, res*hard);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //vec2 c = iResolution.xy / 2.0;\t//画布中点\n\tvec2 mouseP = vec2(iMouse.x+0.0, iMouse.y+0.0);\t//目标点\n\t//vec2 p = vec2(gl_FragCoord.x+0.0,gl_FragCoord.y+0.0);\t//目标点\n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n    vec2 c_uv = vec2(0.5,0.5);\n    vec2 mouse_uv = mouseP/iResolution.xy;\n\n    vec4 col = vec4(1.0);\n    \n    col *= vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(c_uv - uv));\n        \n    vec2 p = uv*iResolution.xy;\n    col *= clamp(min(mod(p.x, 10.0), mod(p.y, 10.0)), 0.9, 1.0);\n\n\n    col = sdf(p)<0.0?vec4(1.0, 0.5, 0.7, 1.0):col;\n\n    col *= shadow(mouseP, p, 48.0);\n\n    if (length(p-mouseP)<(4.0)) {\n        col = vec4(1,1,1,1);\n    }\n\n    fragColor = clamp(col, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}