{"ver":"0.1","info":{"id":"slGBDG","date":"1665146696","viewed":257,"name":"Ray-Marched Ambient Occlusion","username":"TheTurk","description":"Ray-marched ambient occlusion using Monte Carlo Sampling (left) and Quasi-Monte Carlo Sampling (right).","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["ray","sdf","marching","ao","occlusion","ambient","monte","carlo","hammersley","pcg","quasi","murmur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.141592;\n\n// murmur hash function https://sites.google.com/site/murmurhash/\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\nuint randState;\n\n// pcg pseudo random number generator https://www.pcg-random.org/\nuint rand() {\n    uint state = randState;\n    randState = randState * 747796405U + 2891336453U;\n    uint x = ((state >> ((state >> 28U) + 4U)) ^ state) * 277803737U;\n    return (x >> 22U) ^ x;\n}\n\nstruct Hit {\n    float t;\n    float d;\n};\n\nuint reverse(uint bits) {\n    bits = (bits << 16U) | (bits >> 16U);\n    bits = ((bits & 0x00ff00ffU) << 8U) | ((bits & 0xff00ff00U) >> 8U);\n    bits = ((bits & 0x0f0f0f0fU) << 4U) | ((bits & 0xf0f0f0f0U) >> 4U);\n    bits = ((bits & 0x33333333U) << 2U) | ((bits & 0xccccccccU) >> 2U);\n    bits = ((bits & 0x55555555U) << 1U) | ((bits & 0xaaaaaaaaU) >> 1U);\n    return bits;\n} \n\nvec2 hammersley(int i, int sampleCount) {   \n    return vec2(float(i) / float(sampleCount), float(reverse(uint(i))) / float(0xffffffffU));\n} \n\nfloat sdf(in vec3 position) {\n    float d1 = length(position - vec3(0.0, 1.0, 0.0)) - 1.0;\n    float d2 = position.y;\n    return min(d1, d2);\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\nbool raycast(vec3 rayOrigin, vec3 rayDirection, inout Hit hit) {\n    int stepCount = 256;\n    float maximumDistance = 50.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0005 * max(t, 1.0)) {\n            hit.t = t;\n            hit.d = d;\n            return true;\n        }\n        t += d;\n    }\n    hit.t = t;\n    hit.d = t;\n    return true;\n}\n\nfloat testOcclusion(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128;\n    float maximumDistance = 5.0;\n    float t = 0.01;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0005 * max(t, 1.0)) {\n            return 1.0;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\n// monte carlo sampling\nfloat ambientOcclusion1(vec3 position, vec3 normal) {    \n    // build orthonormal basis https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n    float s = normal.z < 0.0 ? -1.0 : 1.0;    \n    float a = 1.0 / (1.0 + abs(normal.z));\n    float b = -s * normal.x * normal.y * a;\n    vec3 right = vec3(1.0 - normal.x * normal.x * a, s * b, s * -normal.x);\n    vec3 forward = vec3(b, s - normal.y * normal.y * a * s, -normal.y);\n    mat3 orientation = mat3(right, normal, forward);\n    int sampleCount = 32;\n    float occlusion = 0.0;\n    for (int i = 0; i < sampleCount; i++) {\n        // pick random point\n        vec2 uv = vec2(rand(), rand()) / float(0xffffffffU);\n        // project on hemisphere\n        float r = sqrt(uv.x);\n        float theta = 2.0 * PI * uv.y;\n        float x = r * cos(theta);\n        float y = sqrt(1.0 - uv.x);\n        float z = r * sin(theta);\n        vec3 rayDirection = orientation * vec3(x, y, z);\n        occlusion += testOcclusion(position, rayDirection);\n    }\n    return occlusion / float(sampleCount);\n}\n\n// quasi-monte carlo sampling\nfloat ambientOcclusion2(vec3 position, vec3 normal) {\n    // build orthonormal basis https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n    float s = normal.z < 0.0 ? -1.0 : 1.0;    \n    float a = 1.0 / (1.0 + abs(normal.z));\n    float b = -s * normal.x * normal.y * a;\n    vec3 right = vec3(1.0 - normal.x * normal.x * a, s * b, s * -normal.x);\n    vec3 forward = vec3(b, s - normal.y * normal.y * a * s, -normal.y);\n    mat3 orientation = mat3(right, normal, forward);\n    vec2 offset = vec2(rand(), rand()) / float(0xffffffffU);\n    int sampleCount = 32;\n    float occlusion = 0.0;\n    for (int i = 0; i < sampleCount; i++) {\n        // pick random point\n        vec2 uv = fract(hammersley(i, sampleCount) + offset);\n        // project on hemisphere\n        float r = sqrt(uv.x);\n        float theta = 2.0 * PI * uv.y;\n        float x = r * cos(theta);\n        float y = sqrt(1.0 - uv.x);\n        float z = r * sin(theta);\n        vec3 rayDirection = orientation * vec3(x, y, z);\n        occlusion += testOcclusion(position, rayDirection);\n    }\n    return occlusion / float(sampleCount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint seed = 0x578437adU; \n    randState = hash(uvec2(uint(fragCoord.x), uint(fragCoord.y)), seed); \n      \n    float yaw = 0.0;\n    float pitch = 0.0;\n    if (iMouse.z > 0.0) {\n        float mouseSensitivity = 0.5;\n        vec2 delta = iMouse.xy - abs(iMouse.zw);\n        float deltaTime = 1.0 / 60.0;\n        pitch = clamp(delta.y * deltaTime * mouseSensitivity, -PI * 0.5, PI * 0.05);\n        yaw = -delta.x * deltaTime * mouseSensitivity;\n    }\n\n    mat3 cameraOrientation = rotationMatrixAxisAngle(vec3(0.0, 1.0, 0.0), yaw);\n    cameraOrientation *= rotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), pitch);\n\tvec3 cameraPosition = vec3(0.0, 1.0, 0.0) + cameraOrientation * vec3(0.0, 0.0, 3.0);\n\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv, -1.5));\n    rayDirection = cameraOrientation * rayDirection;\n    vec3 color = vec3(0.0);\n    Hit hit;\n    if (raycast(cameraPosition, rayDirection, hit)) {\n        vec3 position = cameraPosition + rayDirection * hit.t;\n        vec3 n = normal(position);\n        float occlusion = uv.x < 0.0 ? ambientOcclusion1(position, n) : ambientOcclusion2(position, n);\n        color = vec3(1.0) * (1.0 - occlusion);\n    }\n    color = mix(color, vec3(0.0), 1.0 - exp(-0.01 * hit.t * hit.t));       \n    color = pow(color, vec3(0.4545));\n    color *= smoothstep(0.0, 3.0, (abs(uv.x) - 0.001) * iResolution.y);\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}