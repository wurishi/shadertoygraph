{"ver":"0.1","info":{"id":"MXcSWN","date":"1719029048","viewed":44,"name":"twisting tubes","username":"valvw","description":" tubes","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tube","twisting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 200;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 50.0;\nconst float EPSILON = 0.0001;\n\nconst float TUBES = 4.0; \n\n// Function to generate random noise\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\n// Function to generate smooth noise\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n// Function to create twisting effect\nvec3 twist(vec3 p, float amount) {\n    float theta = amount * noise(p.xy * 0.1 + p.z * 0.01);\n    float c = cos(theta);\n    float s = sin(theta);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xy, p.z);\n}\n\n// Function to create a twisted tube\nfloat tubeSDF(vec3 p, float radius) {\n    p = twist(p, 3.0);\n    p = twist(p, 1.9);\n    p = twist(p, 0.75);\n    return length(p.yz) - radius;\n}\n\n// Function to calculate the distance to the scene\nfloat sceneSDF(vec3 p) {\n    float scene = MAX_DIST;\n    \n    for (float i = 0.0; i < TUBES; i += 1.0) {\n        float angle = 6.28 * (i / TUBES);\n        vec3 dp = vec3(0.0, sin(angle + iTime), cos(angle + iTime)) * 0.5;\n        dp.x += sin(iTime + i * 3.14 / TUBES) * 0.5; // Добавлено случайное смещение по x в диапазоне от -0.5 до 0.5\n        dp.yz += vec2(noise(vec2(iTime + i, 0.0)), noise(vec2(0.0, iTime + i))) * 0.5 - 0.25; // Случайные смещения в диапазоне от -0.5 до 0.5\n        scene = min(scene, tubeSDF(p - dp, 0.1));\n    }\n    \n    return scene;\n}\n\n// Function to find the shortest distance to the surface\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}      \n\n// Function to calculate the ray direction\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// Function to estimate the normal at a point\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// Function to calculate ambient occlusion\nfloat ao(vec3 eye) {\n    float depth = 0.01;\n    vec3 norma = estimateNormal(eye);\n    float accum = 0.0;\n    for (int i = 0; i < 10; i++) {\n        float dist = sceneSDF(eye + depth * norma);\n        accum += (depth - dist) / depth;\n        depth += 0.02;\n    }\n    return 1.0 - min(accum * 0.06, 1.0);\n}\n\n// Phong illumination model\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 lightPos = vec3(4.0, 4.0, 4.0);\n    vec3 lightIntensity = vec3(0.9, 0.8, 0.7);\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = reflect(-L, N);\n    \n    float dotLN = max(dot(L, N), 0.0);\n    float dotRV = max(dot(R, V), 0.0);\n    \n    color += lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n    \n    return color;\n}\n\n// Background color function\nvec3 bgColor(float x) {\n    return vec3(0.1, 0.2, 0.3) * (0.7 + 0.3 * cos(x - iTime * 2.0) + sin(iTime * 4.0) * 0.05);\n}\n\n// View matrix function\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 6.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    vec3 bgc = bgColor(worldDir.x * 30.0);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(bgc, 1.0);\n        return;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.4, 0.6);\n    vec3 K_d = vec3(0.3, 0.6, 0.9);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye) * (0.5 + 0.5 * ao(p));\n    color = mix(color, bgc, pow(smoothstep(5.0, 30.0, dist), 2.0));\n    \n    fragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}