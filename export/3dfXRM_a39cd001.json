{"ver":"0.1","info":{"id":"3dfXRM","date":"1550800316","viewed":239,"name":"Is this hell?","username":"saidwho12","description":"Mwahahahah!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","test","noise","particles","smoke","particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//###############################################################################\n\n//----------------------------------------------------------------------------------------\nfloat hashOld12(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvec3 hashOld33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33w(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031f, 0.1030f, 0.0973f));\n    p3 += dot(p3, p3.yxz+19.19f);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 hash33s(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031f, 0.11369f, 0.13787f));\n    p3 += dot(p3, p3.yxz + 19.19f);\n    return -1.0f + 2.0f * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n// I think from iq...\nfloat simplex(vec3 pos)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(pos + (pos.x + pos.y + pos.z) * K1);\n    vec3 d0 = pos - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33s(i)), dot(d1, hash33s(i + i1)), dot(d2, hash33s(i + i2)), dot(d3, hash33s(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n\nfloat simplexFbm(vec3 pos, float octaves, float persistence, float scale)\n{\n    float final        = 0.0;\n    float amplitude    = 1.0;\n    float maxAmplitude = 0.0;\n\n    for(float i = 0.0; i < octaves; ++i)\n    {\n        final        += simplex(pos * scale) * amplitude;\n        scale        *= 2.0;\n        maxAmplitude += amplitude;\n        amplitude    *= persistence;\n    }\n\n    return (min(final, 1.0f) + 1.0f) * 0.5f;\n}\n\n#define PI acos(-1.)\n#define TAU (PI+PI)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec3 hsv(float x) {\n\treturn .5+.5*sin(x+vec3(0,TAU/3.,2.*TAU/3.));\n}\n\nfloat aspect;\n\n\nfloat getTime(float id, float time) {\n    return time + hash11(id);\n}\n\nvec2 getPosition(float id, float time) {\n\tvec2 h = hash21(id);\n    float speed = .5+hash11(id);\n    vec2 p = fract(h + vec2((.0025+.01*hash11(id))\n                            *sin( (speed*h.y + getTime(id,time))*PI ),\n                            .25*time))*2.-1. ;\n    return p *vec2(aspect,1);\n}\n\nfloat getAngle(float id, float time) {\n\treturn ((hash11(id)*2.-1.)+time)*TAU;\n}\n\nfloat getSmoke(vec2 p, float id, float time) {\n\tfloat t = getTime(id,time);\n    vec2 c = getPosition(id,t);\n    \n    float r = .3+hash11(id)*.25;\n    float d = length(p-c)-r;\n    float a = .3+hash11(id)*.8;\n    return (.5+.5*simplex(vec3(rot(getAngle(id,.15*t))*(2.*(p-c)),hash11(id)+.25*t)))\n        * smoothstep(0., -r*.75, d) * a * exp(-3.*(c.y*.5+.5));\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R = iResolution.xy, p = (u+u-R)/R.y;\n    aspect = R.x/R.y;\n    vec2 uv = u/R;\n    \n    //p = rot(-PI/4.) * p;\n    vec2 p0 = (p - vec2(.025*sin((p.x-iTime)*PI)*sin(p.y*PI),iTime)) * vec2(6.,1.);\n    float a = pow(.5+.5*simplexFbm(vec3(p0,.75*iTime),4.,.7,1.),1.4+2.5*uv.y) * exp(-4.*u.y/R.y);\n\tO *= 0.;\n    O.rgb = mix(O.rgb, hsv((1.-a)*TAU/4.), a);\n    \n    int i = -1, N = 25;\n    while(++i<N) {\n        float alpha = getSmoke(p,float(i),iTime);\n    \tO.rgb = mix(O.rgb, vec3(.5),  alpha);\n    }\n    \n   O.rgb = sqrt(O.rgb);// gamma 2.2\n}","name":"Image","description":"","type":"image"}]}