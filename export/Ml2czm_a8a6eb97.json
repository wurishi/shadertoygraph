{"ver":"0.1","info":{"id":"Ml2czm","date":"1508102579","viewed":675,"name":"spherical voronoise","username":"mattz","description":"It's [url]https://www.shadertoy.com/view/Xd23Dh[/url], but on a sphere.","likes":19,"published":1,"flags":16,"usePreview":0,"tags":["sphere","voronoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* spherical voronoise, by mattz. \n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   Use cube-to-sphere projection to do iq's Voronoise on a sphere. See:\n\n     - https://iquilezles.org/articles/voronoise\n     - https://www.shadertoy.com/view/Xd23Dh\n\n   Mouse rotates (or click in bottom left for auto-rotate and demo).\n\n   Keys do things:\n\n\t E - change kernel exponent (when not auto-rotating)\n     R - toggle randomization (when not auto-rotating)\n     P - toggle points\n     W - toggle warp through tangent function\n     C - toggle color/bw\n\n     N,M - change number of points \n\n   Much of the code below could be simplified/optimized. \n\n*/\n\n/* Number of points per edge of the cube face (we will have 6*N^2 points) */\nfloat N = 8.0;\n\n/* Bunch o' settings */\nfloat warp_fraction = 1.0;\nfloat randomize_amount = 1.0;\nfloat enable_color = 1.0;\nfloat enable_points = 1.0;\nfloat voronoi_exp = 1.0;\n\nfloat dot_size = 1.0;\n\n/* Bunch o' other globals. */\nconst float farval = 1e5;\nconst vec3 tgt = vec3(0);\nconst vec3 cpos = vec3(0,0,2.8);\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\nconst float dot_step = 0.005;\n\n/* Magic angle that equalizes projected area of squares on sphere. */\n#define MAGIC_ANGLE 0.868734829276 // radians\n\nfloat warp_theta = MAGIC_ANGLE;\nfloat tan_warp_theta;\n\n\n/* Return a permutation matrix whose first two columns are u and v basis \n   vectors for a cube face, and whose third column indicates which axis \n   (x,y,z) is maximal. */\nmat3 getPT(in vec3 p) {\n\n    vec3 a = abs(p);\n    float c = max(max(a.x, a.y), a.z);    \n\n    vec3 s = c == a.x ? vec3(1.,0,0) : c == a.y ? vec3(0,1.,0) : vec3(0,0,1.);\n\n    s *= sign(dot(p, s));\n    vec3 q = s.yzx;\n    return mat3(cross(q,s), q, s);\n\n}\n\n/* Warp to go cube -> sphere */\nvec2 warp(vec2 x) {\n    return tan(warp_theta*x)/tan_warp_theta;\n}\n\n/* Unwarp to go sphere -> cube */\nvec2 unwarp(vec2 x) {\n    return atan(x*tan_warp_theta)/warp_theta; \n}\n\n/* Return squared great circle distance of two points projected onto sphere. */\nfloat sphereDist2(vec3 a, vec3 b) {\n\t// Fast-ish approximation for acos(dot(normalize(a), normalize(b)))^2\n    return 2.0-2.0*dot(normalize(a),normalize(b));\n}\n\n\n\n/* RGB from hue. */\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n\n/* Get index (0-5) for axis. */\nfloat axisToIdx(vec3 axis) {\n    \n    float idx = dot(abs(axis), vec3(0.0, 2.0, 4.0));\n    if (dot(axis, vec3(1.0)) < 0.0) { idx += 1.0; }\n    \n    return idx;\n    \n}\n\n/* From https://www.shadertoy.com/view/4djSRW */\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nbool wrapCube(in mat3 PT, \n              inout vec2 uvn,\n              out mat3 PTn) {\n    \n    // new uv location might have gone off edge of cube face\n    // ...see if it has by comparing to clamped version\n    vec2 uvn_clamp = clamp(uvn, -1.0, 1.0);\n    vec2 extra = abs(uvn_clamp - uvn);\n\n    // it doesn't make sense to go over both corners so only allow\n    // overflow/underflow in u or v but not both\n    if (min(extra.x, extra.y) > 0.0) {\n        \n        return false;\n        \n    } else {            \n\n        // check if we have gone off starting face\n        float esum = extra.x + extra.y;\n\n        if (esum > 0.0) {\n            // need to re-establish what face we are on\n            vec3 p = PT * vec3(uvn_clamp, 1.0 - esum);\n            PTn = getPT(p);\n            uvn = (p * PTn).xy;\n        } else {\n            // same as starting face\n            PTn = PT;\n        }\n\n        return true;\n        \n    }\n    \n}\n\n\n/* Color the sphere/cube points. */\nvec3 gcolor(vec3 pos) {\n\n    // get permutation matrix \n    mat3 PT = getPT(pos);\n    \n    // project to cube face\n    vec3 cf = pos * PT; \n    \n    // UV is in [-1, 1] range\n    vec2 uv = cf.xy / cf.z; \n    \n    // unwarp from sphere -> cube (approximtion of atan)\n    uv = unwarp(uv);      \n    \n    // for viz only\n    pos /= (dot(pos, PT[2]));\n    \n    // quantize uv of nearest cell\n    vec2 uv_ctr = (floor(0.5*N*uv+0.5) + 0.5)*2.0/N;\n    \n    // for drawing grid lines below\n    vec2 l = abs(mod(uv + 1.0/N, 2.0/N) - 1.0/N)*0.5*N;\n\n    vec3 csum = vec3(0);\n\tfloat wsum = 0.0;\n    \n    float h = mix(2.4, 1.8, warp_fraction) / N;\n    \n    float d1 = 1e5;\n    vec3 p1 = vec3(0);\n\n    // for neighbors in 4x4 neighborhood\n    for (float du=-2.0; du<2.0; ++du) {\n        for (float dv=-2.0; dv<2.0; ++dv) {\n            \n            mat3 PTn;\n            \n            // any time you see 2.0/N it maps from [-1, 1] to [0, N]\n            vec2 uvn = uv_ctr + vec2(du, dv)*2.0/N;\n            \n            if (wrapCube(PT, uvn, PTn)) {\n\n                // now generate a unique id for the cell\n                vec2 ssn = floor((uvn*0.5 + 0.75)*N);\n                float faceid = axisToIdx(PTn[2]);\n                vec3 id = vec3(ssn, faceid);\n                \n                // generate 3 random #'s from id\n                vec3 r = hash33(id);\n                \n                // randomize dot position within cell\n                uvn += (r.xy-0.5)*2.0*(randomize_amount)/N;\n\n                // random material\n                float mn = r.z;\n                \n                // warp cube -> sphere\n                uvn = warp(uvn);\n\n                // can save 1 multiplication over general matrix mult.\n                // because we know last coord is 1\n                vec3 pn = PTn[0]*uvn.x + PTn[1]*uvn.y + PTn[2];\n\n                // update distances if closer\n                float dp = sqrt(sphereDist2(pn, pos));\n                \n                if (dp < d1) {\n                    d1 = dp;\n                    p1 = pn;\n                }\n               \n                float ws = pow(smoothstep(h, 0.0, dp), voronoi_exp);\n\n                csum += ws * mix(vec3(mn), hue(mn), enable_color);\n                wsum += ws;\n\n            }\n            \n        }\n            \n    }\n\n       \n    vec3 c = csum / wsum;\n    \n    c = mix(c, vec3(0), smoothstep(dot_step, 0.0, d1-dot_size)*enable_points);\n    \n    return c;\n\n    \n    \n}\n\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n\n/* Adapted from https://iquilezles.org/articles/distfunctions */\nfloat sdCube(vec3 p, float r) {    \n    vec3 d = abs(p) - r;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d,0.0));    \n}\n\n\n\n/* Distance function to scene is a single cube/sphere. */\nvec2 map(in vec3 pos) {\t\n\n    float d = length(pos)-1.0;\n    vec2 rval = vec2(d, 3.0);\n\n    return rval;\n\n}\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n/* IQ's distance marcher. */\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\n    const float precis = 0.002;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;        \n    }    \n\n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n\n\n/* Pretty basic shading function. */\nvec3 shade( in vec3 ro, in vec3 rd ){\n\n    vec2 tm = castRay(ro, rd, dmax);        \n\n    vec3 c;\n\n\n    if (tm.y < 0.0) {\n\n        c = vec3(1.0);\n\n    } else {        \n\n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);\n        \n        \n        vec3 color = gcolor(pos);\n\n        vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        c = diffamb + spec;\n\n    }\n\n    return c;\n\n}\n\n\n/* Bunch of ASCII keycodes */\nconst float KEY_M = 77.5/256.0;\nconst float KEY_N = 78.5/256.0;\nconst float KEY_P = 80.5/256.0;\nconst float KEY_C = 67.5/256.0;\nconst float KEY_E = 69.5/256.0;\nconst float KEY_R = 82.5/256.0;\nconst float KEY_S = 83.5/256.0;\nconst float KEY_W = 87.5/256.0;\n\n/* Compare key state to default state. */\nfloat keyState(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.75)).x - default_state );\n}\n\n\n/* ...finally! */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float t;\n\n    t = iTime;\n\n    N = pow(2.0, 2.0+keyState(KEY_N, 1.0)+2.0*keyState(KEY_M, 0.0));\n\n    dot_size = 0.18 / N;\n\n    warp_fraction = keyState(KEY_W, 1.0);        \n    randomize_amount = keyState(KEY_R, 1.0);\n    enable_color = keyState(KEY_C, 0.0);\n    enable_points = keyState(KEY_P, 0.0);\n    voronoi_exp = 1.0 + 20.0*keyState(KEY_E, 0.0);\n     \n    // For demonstration, warp_theta varies, but it should just be MAGIC_ANGLE for \"production\" code.\n    warp_theta = max(warp_fraction*MAGIC_ANGLE, 0.001);\n    tan_warp_theta = tan(warp_theta);\n\n  \n    /* Handle mouse motion for rotation. */\n    float thetay = (t-7.0) * 0.1;\n    float thetax = (t-7.0) * 0.05;        \n    \n    vec2 p;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        \n        thetax = (iMouse.y - .5*iResolution.y) * 5.0/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * -10.0/iResolution.x; \n        \n    } else {\n        \n        vec2 p = 0.5 - 0.5*sin( iTime*vec2(1.01,1.71) );\n        randomize_amount = p.y;\n        voronoi_exp = 1.0 + 20.0*pow(p.x, 4.0);\n\n    }\n\n    Rview = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);        \n    L = Rview*L;\n\n   \t/* Render. */\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor.xyz = shade(ro, rd);\n\n\n}\n","name":"Image","description":"","type":"image"}]}