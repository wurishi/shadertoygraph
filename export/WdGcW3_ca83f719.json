{"ver":"0.1","info":{"id":"WdGcW3","date":"1603834881","viewed":274,"name":"Parallel Dragon Curve","username":"Blake447","description":"Simple demonstration rendering a dragon curve using a fully parallel algorithm ideal for use on a GPU. As far as I'm aware I haven't seen any one else use this particular method","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractal","dragon","dragoncurve","harterheighway","paperfolding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdfLineSegment(vec2 p, vec2 a, vec2 b)\n{\n    float h = clamp(dot(p - a, normalize(b - a)), 0.0, 1.0);\n    return length(p - (a + (b - a) * h) );\n}\n\nfloat sdf0(vec2 uv, vec2 p, vec2 middle_point, float size, float invalidation)\n{\n    float d = sdfLineSegment(uv, p, middle_point);\n    if (invalidation > 0.5)\n    {\n        vec2 offset = p - middle_point;\n\n        d = 0.5;\n    }\n\n    return d;\n}\n\nvec2 T(vec2 v, int i)\n{\n    float t = (float(i) + 1.0) * 3.14159265 * 0.25;\n\n    float scale = pow(2.0, float(i - 1) / 2.0);\n    mat2x2 change_of_basis = mat2x2(cos(t), sin(t), -sin(t), cos(t)) / scale;\n    mat2x2 invert_of_basis = mat2x2(cos(t), -sin(t), sin(t), cos(t)) * scale;\n\n    vec2 v_index = floor((change_of_basis*v)*0.5 + vec2(0.5, 0.5));\n    float direction = 1.0 - 2.0 * ( mod(v_index.x + v_index.y + 4096.0, 2.0));\n\n    vec2 v_center = (invert_of_basis*v_index*2.0);\n    vec2 v_off = v - v_center;\n\n    vec2 v_prime = vec2(v_off.x + v_off.y * direction, v_off.y - v_off.x * direction) + v_center;\n\n    return v_prime;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_original = fragCoord/iResolution.xx*5.0;\n    uv_original = mat2x2(cos(iTime*0.1), -sin(iTime*0.1), cos(iTime*0.1), sin(iTime*0.1))*uv_original;\n    \n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5,0.5);\n    uv *= vec2(1.0, iResolution.y/iResolution.x);\n    \n    float sin_time = 7.0 + 7.0 * sin(iTime*0.5);\n    \n    int ITERATIONS = int(sin_time);\n    //int ITERATIONS = 12;\n    const float size = 5.0;\n    \n    \n    for (int k = 0; k < ITERATIONS; k++)\n    {\n        uv = vec2(uv.x + uv.y, uv.y - uv.x);\n    }\n    vec2 uv_scaled = uv * size * 0.5;\n    vec2 uv_midpoint = floor(uv * size*0.5 + vec2(0.5, 0.5));\n\n    vec2 p_cont = uv_scaled;\n\n    vec2 p0 = uv_midpoint + vec2(0.5, 0);\n    vec2 p1 = uv_midpoint + vec2(0, 0.5);\n    vec2 p2 = uv_midpoint - vec2(0.5, 0);\n    vec2 p3 = uv_midpoint - vec2(0, 0.5);\n\n    vec2 m = uv_midpoint;\n\n    vec2 c0 =  vec2(0.5, 0.0);\n    vec2 c1 =  vec2(0.0, 0.5);\n    vec2 c2 = -vec2(0.5, 0.0);\n    vec2 c3 = -vec2(0.0, 0.5);\n\n    vec2 v0 = p0;\n    vec2 v1 = p1;\n    vec2 v2 = p2;\n    vec2 v3 = p3;\n\n\n    for (int j = 0; j < ITERATIONS; j++)\n    {\n        c0 = T(c0, j);\n        c1 = T(c1, j);\n        c2 = T(c2, j);\n        c3 = T(c3, j);\n\n\n        v0 = T(v0, j);\n        v1 = T(v1, j);\n        v2 = T(v2, j);\n        v3 = T(v3, j);\n\n        p_cont = T(p_cont, j);\n    }\n\n    vec2 comparison = c0;\n\n    vec4 invalidate0 = vec4(step(0.05, length(v0 - c0)), step(0.05, length(v1 - c0)), step(0.05, length(v2 - c0)), step(0.05, length(v3 - c0)));\n    //int4 invalidate1 = int4(step(0.05, length(v0 - c1)), step(0.05, length(v1 - c1)), step(0.05, length(v2 - c1)), step(0.05, length(v3 - c1)));\n    //int4 invalidate2 = int4(step(0.05, length(v0 - c2)), step(0.05, length(v1 - c2)), step(0.05, length(v2 - c2)), step(0.05, length(v3 - c2)));\n    //int4 invalidate3 = int4(step(0.05, length(v0 - c3)), step(0.05, length(v1 - c3)), step(0.05, length(v2 - c3)), step(0.05, length(v3 - c3)));\n\n\n    float d0_sdf = sdf0(uv_scaled, p0, uv_midpoint, size, invalidate0.x);\n    float d1_sdf = sdf0(uv_scaled, p1, uv_midpoint, size, invalidate0.y);\n    float d2_sdf = sdf0(uv_scaled, p2, uv_midpoint, size, invalidate0.z);\n    float d3_sdf = sdf0(uv_scaled, p3, uv_midpoint, size, invalidate0.w);\n\n\n\n    float dist = min(min(d0_sdf, d1_sdf), min(d2_sdf, d3_sdf));\n    //float distance = length(uv_scaled - uv_midpoint) * length(uv_scaled);\n    //float distance = length( (mapping + int2(32, 32)) / float(size) - i.uv) * size;\n\n\n    float dist_scale = 0.25;\n    float dist_smooth = 0.05;\n\n    float dragon_edge = 1.0-step(dist_scale, dist);\n    \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv_original.xyx+vec3(0,2,4));\n\n    fragColor = vec4(col*dragon_edge, 1);\n}","name":"Image","description":"","type":"image"}]}