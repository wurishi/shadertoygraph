{"ver":"0.1","info":{"id":"tsVyWc","date":"1618953974","viewed":578,"name":"Postprocesses_pt2_23","username":"edwardbraed","description":"Continuing a set of \"one fetch\" filters from: https://www.shadertoy.com/view/wsKyWK\nSimple \"two and more fetch\" filters set","likes":20,"published":1,"flags":0,"usePreview":1,"tags":["sobel","filters","blur","bokeh","postprocess","chromatic","bevel","gaussian","set","convolutional"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define gray(rgb) (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114)\n#define cmpv(v, b) (v.x > b.x && v.y > b.y && v.x < (b.x + 1.0) && v.y < (b.y + 1.0))\n#define norm(a) (a + 1.0) * 0.5\n#define m_p 3.1415926538\n#define m_dp 6.283185308\n\n//=========================================================\n\nvec3 bevel(sampler2D tex, vec2 uv, vec2 d, float p)\n{\n    d *= 1.0 / vec2(textureSize(tex, 0));\n    vec3 a1 = texture(tex, uv - d).xyz;\n    vec3 b2 = texture(tex, uv + d).xyz;\n    return vec3(0.5) + gray(vec3(a1 * p - b2 * p));\n}\n\n\n//=========================================================\n\nvec3 conv3x3(sampler2D tex, vec2 uv, float ss, mat3 k)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0)) * ss;\n    vec3 v = vec3(0.0);\n    v += texture(tex, uv + s * vec2(-1.0, -1.0)).xyz * k[0][0];\n    v += texture(tex, uv + s * vec2( 0.0, -1.0)).xyz * k[1][0];\n    v += texture(tex, uv + s * vec2( 1.0, -1.0)).xyz * k[2][0];\n    \n    v += texture(tex, uv + s * vec2(-1.0,  0.0)).xyz * k[0][1];\n    v += texture(tex, uv).xyz                        * k[1][1];\n    v += texture(tex, uv + s * vec2( 1.0,  0.0)).xyz * k[2][1];\n    \n    v += texture(tex, uv + s * vec2(-1.0,  1.0)).xyz * k[0][2];\n    v += texture(tex, uv + s * vec2( 0.0,  1.0)).xyz * k[1][2];\n    v += texture(tex, uv + s * vec2( 1.0,  1.0)).xyz * k[2][2];\n    \n    return v;\n}\n\n//=========================================================\n\nvec3 chromatic(sampler2D tex, vec2 uv, vec2 d, vec3 cf)\n{\n    return vec3(texture(iChannel0, uv + d * cf.r).r,\n                texture(iChannel0, uv + d * cf.g).g,\n                texture(iChannel0, uv + d * cf.b).b);\n}\n\n//=========================================================\n\nvec3 coarse(sampler2D tex, vec2 uv, vec2 k, float ss)\n{\n    vec2 ts = vec2(textureSize(tex, 0));\n    vec2 sz = 1.0 / (ts / k);\n    uv = floor(uv / sz) * sz;\n    vec2 s = 1.0 / ts;\n    vec3 avg = vec3(0.0);\n    vec2 hk = k * 0.5;\n    for(float x = 0.0 - hk.x; x < hk.x; x += 1.0)\n    {\n        for(float y = 0.0 - hk.y; y < hk.y; y += 1.0)\n            avg += texture(tex, uv + s * vec2(x,y) * ss).rgb;\n    }\n    return avg / (k.x * k.y);\n}\n\n//=========================================================\n\nvec3 radial_blur(sampler2D tex, vec2 uv, int sc, float ss, float p, vec2 c)\n{\n    int hsc = sc / 2;\n    vec3 avg = vec3(0.0);\n    for(int x = 0; x < sc; x++)\n    {\n        float v = float(x - hsc) * p;\n        avg += texture(tex, uv + c * v).rgb;\n    }\n    avg *= 1.0 / float(sc + 1);\n    float dist = distance(c, uv);\n    return mix(texture(tex, uv).rgb, avg, clamp(dist * ss, 0.0, 1.0));\n}\n\n//=========================================================\n\nvec3 direct_blur(sampler2D tex, vec2 uv, vec2 d, int k)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    d *= s;\n    vec2 b = -0.5 * d * float(k - 1);\n    vec3 avg = vec3(0.0);\n    for(int x = 0; x < k; x++)\n        avg += texture(tex, uv + b + d * float(x) * 2.0).rgb;\n    return avg / float(k);\n}\n\n//=========================================================\n\nvec3 blur(sampler2D tex, vec2 uv, vec2 k, float ss)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    vec3 avg = vec3(0.0);\n    vec2 hk = k * 0.5;\n    for(float x = 0.0 - hk.x; x < hk.x; x += 1.0)\n    {\n        for(float y = 0.0 - hk.y; y < hk.y; y += 1.0)\n            avg += texture(tex, uv + s * vec2(x,y) * ss).rgb;\n    }\n    return avg / (k.x * k.y);\n}\n\n//=========================================================\n\nvec3 gaussian(sampler2D tex, vec2 uv, float k, float ss)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    float hk = k * 0.5;\n    vec3 sum = vec3(0.0);\n    for(float x = 0.0 - hk; x < hk; x += 1.0)\n    {\n        for(float y = 0.0 - hk; y < hk; y += 1.0)\n        {\n            float sigma = k * 0.25; \n            sigma *= sigma;\n            float gc = 1.0 / (2.0 * m_p * sigma) * exp(-((x * x + y * y) / (2.0 * sigma)));\n            //gc - gauss coof, thanks: https://www.shadertoy.com/view/4tSyzy\n            sum += texture(tex, uv + s * vec2(x,y) * ss).rgb * gc;\n        }\n    }\n    return sum;\n}\n\n//=========================================================\n\n\nvec3 smoothing(sampler2D tex, vec2 uv, vec2 k, float ss)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    vec3 avg = vec3(0.0);\n    vec2 hk = k * 0.5;\n    for(float x = 0.0 - hk.x; x < hk.x; x += 1.0)\n    {\n        for(float y = 0.0 - hk.y; y < hk.y; y += 1.0)\n            avg += texture(tex, uv + s * vec2(x,y) * ss).rgb;\n    }\n    return max(texture(tex, uv).rgb, avg / (k.x * k.y));\n}\n\n//=========================================================\n\nvec3 quadBokeh(sampler2D tex, vec2 uv, float k, float ss, float p)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    float hk = k * 0.5;\n    vec3 mcol = vec3(0.0);\n    vec3 avg = vec3(0.0);\n    for(float x = 0.0 - hk; x < hk; x += 1.0)\n    {\n        for(float y = 0.0 - hk; y < hk; y += 1.0)\n        {\n            vec3 col = texture(tex, uv + s * vec2(x,y) * ss).rgb;\n            mcol = max(mcol, col);\n            avg += col;\n        }\n    }\n    return mix(avg / (k * k), mcol, p);\n}\n\n//=========================================================\n\nvec3 radialBokeh(sampler2D tex, vec2 uv, float k, float ss, float p)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    float hk = k * 0.5;\n    vec3 mcol = vec3(0.0);\n    vec3 avg  = vec3(0.0);\n    for(float x = 0.0 - hk; x < hk; x += 1.0)\n    {\n        for(float y = 0.0 - hk; y < hk; y += 1.0)\n        {\n            float l = length(vec2(x,y));\n            if(l <= hk)\n            {\n                vec3 col = texture(tex, uv + s * vec2(x,y) * ss).rgb;\n                mcol = max(mcol, col);\n                avg += col;\n            }\n        }\n    }\n    return mix(avg / pow(m_p * hk, 2.0), mcol, p);\n}\n\n//=========================================================\n\nvec3 ngonBokeh(sampler2D tex, vec2 uv, float k, float ss, float p, float vc, float a)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    float hk = k * 0.5;\n    vec3 mcol = vec3(0.0);\n    vec3 avg  = vec3(0.0);\n    float rc = 0.0;\n    for(float x = 0.0 - hk; x < hk; x += 1.0)\n    {\n        for(float y = 0.0 - hk; y < hk; y += 1.0)\n        {\n            vec2 pt = vec2(x, y);\n\n            float an = a + atan(pt.x, pt.y);\n            float ngon = cos(an - (m_dp * floor((m_p + vc * an) / m_dp)) / vc) / cos(m_p / vc);\n            float ngonSdf = ngon * length(pt) - hk;\n    \n            if(ngonSdf <= 0.0)\n            {\n                vec3 col = texture(tex, uv + s * vec2(x,y) * ss).rgb;\n                mcol = max(mcol, col);\n                avg += col;\n                rc += 1.0;\n            }\n        }\n    }\n    return mix(avg / rc, mcol, p);\n}\n\n//=========================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 auv = vec2(uv.x * aspect, uv.y) * 0.5;\n    \n    const vec2 cells = vec2(4, 3);                  // cells count\n    vec2 cell = cells * uv;                         // curr cell\n    vec2 pos = auv * cells;                         // pos in cell\n    vec2 ss = 1.0 / (iResolution.xy * cells);       // sample step\n    vec2 cc = (floor(cell) + 0.5) / cells * 0.5;    // cell center\n    cc.x *= aspect;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float t = abs(sin(iTime * 1.5));\n    \n    if(cmpv(cell, vec2(0.0, 0.0))) //---------------------------\n    {\n        vec2  d = vec2(1.0); // direction\n        float p = 2.0;       // power\n        \n        d.y *= sin(iTime * 2.0);\n        col = bevel(iChannel0, pos, d, p);\n    }\n    else if(cmpv(cell, vec2(1.0, 0.0))) //----------------------\n    {\n        float ss = 3.0;  // sample strength\n        mat3 k = mat3(vec3(-1.0, -1.0, -1.0),\n                      vec3(-1.0,  9.0, -1.0),\n                      vec3(-1.0, -1.0, -1.0)); // Sharpen kernel\n                       \n        ss *= t;\n        col = conv3x3(iChannel0, pos, ss, k);\n    }\n    else if(cmpv(cell, vec2(2.0, 0.0))) //----------------------\n    {\n        vec2 d  = vec2(0.0, 0.2);      // direction\n        vec3 cf = vec3(0.4, 0.1, 0.1); // channels factor\n        \n        d.y *= t;\n        col = chromatic(iChannel0, pos, d, cf);\n    }\n    else if(cmpv(cell, vec2(3.0, 0.0))) //----------------------\n    {\n        vec2  k  = vec2(20.0); // kernel\n        float ss = 1.0;        // sample strength\n        \n        k = floor(mix(vec2(1.0), k, t));\n    \tcol = coarse(iChannel0, pos, k, ss);\n    }\n    else if(cmpv(cell, vec2(0.0, 1.0))) //----------------------\n    {\n        int   sc = 10;       // sample count\n        float ss = 2.0;      // sample strength\n        float p  = 0.1;      // power\n        vec2  c  = cc - auv; // center\n\n        p *= t;\n        col = radial_blur(iChannel0, pos, sc, ss, p, c);\n    }\n    else if(cmpv(cell, vec2(1.0, 1.0))) //----------------------\n    {\n        vec2 d = vec2(4.0); // dir\n        int  k = 16;        // kernel\n\n        k = int(t * float(k) + 1.0);\n        col = direct_blur(iChannel0, pos, d, k);\n    }\n    else if(cmpv(cell, vec2(2.0, 1.0))) //----------------------\n    {\n        vec2  k  = vec2(20.0); // kernel\n        float ss = 3.0;        // sample strength\n        \n        k = floor(mix(vec2(1.0), k, t));\n        col = blur(iChannel0, pos, k, ss);\n    }\n    else if(cmpv(cell, vec2(3.0, 1.0))) //----------------------\n    {\n        float k  = 20.0; // kernel\n        float ss = 3.0;  // sample strength\n        \n        k = max(3.0, floor(k * t));\n        col = gaussian(iChannel0, pos, k, ss);\n    }\n    else if(cmpv(cell, vec2(0.0, 2.0))) //----------------------\n    {\n        vec2  k  = vec2(25.0); // kernel\n        float ss = 3.0;        // sample strength\n        \n        k = floor(mix(vec2(1.0), k, t));\n        col = smoothing(iChannel0, pos, k, ss);\n    }\n    else if(cmpv(cell, vec2(1.0, 2.0))) //----------------------\n    {\n        float k  = 20.0; // kernel\n        float ss = 2.0;  // sample strength\n        float p  = 0.5;  // bokeh power\n        \n        k = floor(mix(1.0, k, t));\n        col = quadBokeh(iChannel0, pos, k, ss, p);\n    }\n    else if(cmpv(cell, vec2(2.0, 2.0))) //----------------------\n    {\n        float k  = 20.0; // kernel\n        float ss = 2.0;  // sample strength\n        float p  = 0.8;  // bokeh power\n        \n        k = floor(mix(2.0, k, t));\n        col = radialBokeh(iChannel0, pos, k, ss, p);\n    }\n    else if(cmpv(cell, vec2(3.0, 2.0))) //----------------------\n    {\n        float k  = 20.0; // kernel\n        float ss = 3.0;  // sample strength\n        float p  = 0.7;  // bokeh power\n        float vc = 5.0;  // ngon vertices count\n        float a  = 0.3;  // angle ngon\n        \n        k = floor(mix(2.0, k, t));\n        col = ngonBokeh(iChannel0, pos, k, ss, p, vc, a);\n    }\n    \n    // draw grid\n    for(float x = 0.0; x < cells.x; x += 1.0)\n        for(float y = 0.0; y < cells.y; y += 1.0)\n            col *= smoothstep(0.0, 0.010, abs(cell.x - x)) * smoothstep(0.0, 0.010, abs(cell.y - y));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}