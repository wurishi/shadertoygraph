{"ver":"0.1","info":{"id":"Wsy3zm","date":"1569880011","viewed":712,"name":"[twitch] The Orb of Great Power","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/TheOrbOfGreatPower.glsl","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","explosion","translucency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/TheOrbOfGreatPower.glsl\n*/\n\nfloat time=0.0;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nfloat rnd(float a) {\n  return fract(sin(a*452.655)*387.521);  \n}\n\nvec3 rnd3(float a) {\n  return fract(sin(a*vec3(845.652,257.541,289.675))*vec3(354.852,685.527,947.544));\n}\n\nvec3 rndcol(float a) {\n  vec3 r=rnd3(a);\n  //r/=dot(r,vec3(0.33));\n  r/=max(r.x, max(r.y,r.z));\n  return r;\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*357.542+uv.yx*685.427),vec2(925.674)));\n  \n}\n\nvec3 kifs(vec3 p, float t, float t3) {\n  \n  vec3 bp=p;\n  float s=0.0 + smoothstep(0.0,1.0,fract(t3))*10.0;\n  for(int i=0; i<3; ++i) {\n    float t2 = t + float(i);\n    p.xz *= rot(t2);\n    p.xy *= rot(t2*0.7);\n    \n    // using smooth minimum on all 3 channels to make a \"smooth\" symmetry\n    p=smin(p, -p, -3.0);\n    //p=abs(p);\n    p-=s;// + sin(t*0.2-length(p)*1.0) * 0.5;\n    s*=0.7;\n  }\n  \n  \n  return p;\n}\n\nfloat exspeed = 0.25;\nfloat explode(vec3 p, float t, float offset) {\n  \n  // rotating and swirling in all directions\n  p.xz *= rot(p.y*0.09+t*0.15);\n  p.xy *= rot(p.z*0.052+t*0.18);\n  \n  float t1 = t * exspeed + offset;\n  vec3 p2 = kifs(p, t*0.1, t1);\n  vec3 p3 = kifs(p+vec3(3,2,1), t*0.13, t1);\n  \n  float fade = 1.0-pow(fract(t1),10.0);\n  \n  float d1 = length(p2)-1.5*fade;\n  d1=min(d1, length(p2.xz)-0.8*fade);\n  float d2 = length(p3)-1.4*fade;\n  d2=min(d2, length(p3.xz)-0.8*fade);\n  \n  return smin(d1,d2, -1.0);\n}\n\nfloat box(vec3 p, float r) {\n  p=abs(p)-r;\n  return max(p.x, max(p.y,p.z));\n}\n\nfloat box(vec2 p, float r) {\n  p=abs(p)-r;\n  return max(p.x, p.y);\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\n\nfloat at=0.0;\nfloat at2=0.0;\nbool metal=false;\nvec3 pos1 = vec3(0);\nvec3 pos2 = vec3(0);\nfloat map(vec3 p) {\n  \n  #if 0\n  // having fun with repetition and rotations\n  float t=time*0.2;\n  p.z += t*15;\n  p.x += sin(p.z*0.037+t)*33;\n  p.y += sin(p.z*0.027+t*0.7)*23;\n  p.xy *= rot(p.z*0.02+t*5.0);\n  //p.xz *= rot(p.y*0.015+t*0.7);\n  \n  float dist = 35;\n  p.z = (fract(p.z/dist-0.5)-0.5)*dist;\n  p=abs(p);\n  #endif\n    \n  // we compute two explosion at the same time\n  // offseted in time so one explosion start when the other disappear\n  float m1 = explode(p+pos1, time, 0.0);\n  float m2 = explode(p+pos2, time, 0.5);\n  \n  at += 0.8/(2.0+abs(m1));\n  at2 += 0.8/(2.0+abs(m2));\n  \n  float m3 = min(abs(m1),abs(m2));\n  \n  vec3 bp=p;\n  bp += smoothstep(-0.5,0.5,sin(p.yzx*1.0))*0.2;\n  float other = (length(bp)-15.0)*0.8;\n  \n  #if 0\n  // Tried to add a \"cage\" but it's less great\n  for(int i=0;i<2;++i) {\n    float t3=time*0.1+i;\n    p.xz *= rot(0.7);\n    p.xy *= rot(0.7);\n    p=abs(p)-5.6;\n    //p=smin(p, -p, -2.0)-3;\n  }\n  float s=0.5;\n  other=min(other, cyl(p.xy, s));\n  other=min(other, cyl(p.yz, s));\n  other=min(other, cyl(p.xz, s));\n  //other=smin(other, length(bp)-25,-10);\n  other=max(other, length(bp)-35);\n  \n  //other = max(-(length(p)-8.5),sqrt(abs(p.x)+abs(p.y)+abs(p.z))-1.2*3);\n  #endif \n  \n  metal=other<m3;\n  \n  return min(m3, other);\n}\n\nvoid cam(inout vec3 p) {\n  \n  float t=time*0.3;\n  p.xz *= rot(t);\n  p.xy *= rot(t*1.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  time = mod(iTime, 300.0);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  // pick a random position for each explosion\n  pos1 = (rnd3(floor(time*exspeed))-0.5) * 20.0;\n  pos2 = (rnd3(floor(time*exspeed+0.5)+37.2)-0.5) * 20.0;\n  \n  float fade1 = 1.0-pow(fract(time*exspeed),10.0);\n  float fade2 = 1.0-pow(fract(time*exspeed+0.5),10.0);\n  \n  // pick a random color for each explosion\n  vec3 c1 = rndcol(floor(time*exspeed)+17.3);\n  vec3 c2 = rndcol(floor(time*exspeed+0.5)+37.5);\n  \n  vec3 s=vec3(0,0,-60);\n  vec3 r=normalize(vec3(-uv, 1));\n  \n  cam(s);\n  cam(r);\n  \n  float dither = mix(1.0, rnd(uv), 0.1);\n  \n  vec2 off=vec2(0.01,0);\n  \n  vec3 col=vec3(0);\n  vec3 p=s;\n    // this is done to ensure the loop is not unrolled, so compile time doesnt explode\n  float iterationcount = (90.0+min(time,0.0));\n  for(float i=0.0; i<iterationcount; ++i) {\n    // we use the absolute value of the distance field, so we can also march inside the surface\n    float d=abs(map(p))*dither;\n    if(d<0.01) {\n      if(metal) {\n        vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n        r=reflect(r,n);\n      }\n      // instead of breaking when we find a surface, we continue to march forward with a slight offset\n      d=0.1;\n      //break;\n    }\n    col += pow(at * 0.010,3.0) * c1 * fade1;\n    col += pow(at2 * 0.010,3.0) * c2 * fade2;\n    p+=r*d;\n  }\n    \n  col *= 3.0;\n  \n  // the dark souls\n  //col *= smoothstep(0.0,0.01,length(uv)-0.25);\n  \n  // bloom to white on primary colors\n  col += max(vec3(0),col.yzx-1.0);\n  col += max(vec3(0),col.zxy-1.0);\n  \n  //col=smoothstep(0,1,col);\n  col=1.0-exp(-col);\n  col=pow(col, vec3(1.0));\n  \n  \n  //col += pow(1-i/101.0,6) * 1.5;\n  \n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}