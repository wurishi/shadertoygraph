{"ver":"0.1","info":{"id":"MfSGWV","date":"1704630725","viewed":28,"name":"Shadow fix","username":"MindFlyer","description":"Fixing ray-marched shadow artifacts related to deformed SDFs.\nSee line 88.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOCAL_LENGTH = 1.2;\nconst int MAX_RAY_STEPS = 1000;\nconst int MAX_SHADOW_STEPS = 50;\nconst float MIN_RAY_DIST = 0.001;\nconst float MAX_RAY_DIST = 100.;\nconst float RAY_PRECISION = 0.00001;\nconst float NORMAL_PRECISION = 0.0001;\nconst float SHADOW_DARKNESS = 0.5;\nconst float SHADOW_HARDNESS = 50.0;\nconst float GAMMA = 1.75;\n\nbool RIGHT;\n\nvec3 lightPos = vec3(-5.,7.,5.);\n\nvec3 move(vec3 point, vec3 delta){\n    return point - delta;\n}\n\nmat2 rotation(float angle){\n    float s=sin(angle), c=cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdPlane(vec3 p, float h){\n    return p.y - h;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nvec3 opTwist(vec3 p, float k){\n    return vec3(rotation(k*p.z)*p.xy, p.z);\n}\n\nvec2 opUnion(vec2 d1, vec2 d2){\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 sceneDist(vec3 p){\n    // floor\n    vec2 res = vec2(sdPlane(p, -1.75), 0.);\n    \n    // twisting box\n    vec3 q = move(p.xzy, vec3(1,2,0));\n    q = opTwist(q, -1.5*(sin(iTime) * 0.5 + 0.5));\n    res = opUnion(res, vec2(sdBox(q, vec3(0.5,0.5,1.))*0.75, 1.));\n    \n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd){\n    vec2 res;\n    float depth = MIN_RAY_DIST;\n    for(int i = 0; i < MAX_RAY_STEPS; i++){\n        vec3 p = ro + depth * rd;\n        res = sceneDist(p);\n        float d = res.x;\n        if(d < RAY_PRECISION)\n            break;\n        depth += d;\n        if(depth >= MAX_RAY_DIST)\n            return vec2(MAX_RAY_DIST, -1.);\n    }\n    return vec2(depth, res.y);\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(1.0, -1.0);\n  vec2 ee = e * NORMAL_PRECISION;\n  return normalize(\n        e.xyy * sceneDist(p + ee.xyy).x +\n        e.yxy * sceneDist(p + ee.yxy).x +\n        e.yyx * sceneDist(p + ee.yyx).x +\n        e.xxx * sceneDist(p + ee.xxx).x);\n}\n\nfloat getShadow(vec3 ro, vec3 rd){\n    float exposure = 1.;\n    float depth = MIN_RAY_DIST;\n    for(int i = 0; i < MAX_SHADOW_STEPS; i++){\n        vec3 p = ro + depth * rd;\n        float d = sceneDist(p).x;\n        if(d < RAY_PRECISION) return 1. - SHADOW_DARKNESS;\n        if(RIGHT) // correction\n            if(d < 0.01) i--;\n        exposure = min(exposure, d / depth);\n        depth += d;\n        if(depth >= MAX_RAY_DIST) break;\n    }\n    exposure = clamp(exposure * SHADOW_HARDNESS, 0., 1.);\n    return mix(1., exposure, SHADOW_DARKNESS);\n}\n\nvec3 getColor(vec3 ro, vec3 rd){\n        vec2 res = rayMarch(ro, rd);\n        float d = res.x;\n        float m = res.y;\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n\n        vec3 col;\n        if(m < -0.5) // background\n            col = vec3(0.);\n        else if (m < 0.5) // floor\n            col = vec3(0.3 + 0.7*mod(floor((p.x+1.)*0.5) + floor(p.z*0.5), 2.0));\n        else // twisting boxes\n            col = vec3(1,1,0);\n\n        // lighting and shading\n        if(m > -0.5){\n            vec3 lightDir = normalize(lightPos - p);\n            \n            // smooth shadow\n            col *= getShadow(p, lightDir);\n            \n            // diffuse lighting\n            col *= dot(n, lightDir)*.5 + .5;\n            \n            // distance attenuation\n            col *= smoothstep(50., 15., distance(p, lightPos));\n        }\n        return col;\n}\n\nvec3 rayDir(vec2 uv, vec3 forward, vec3 up, float focal){\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return normalize(focal * forward + uv.x * right + uv.y * up);\n}\n\nvec2 normalizeCoords(vec2 p){\n    return (2.0*p-iResolution.xy)/iResolution.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = normalizeCoords(fragCoord);\n    RIGHT = uv.x > 0.;\n    uv.x = abs(uv.x);\n    \n    vec3 ro = vec3(0.,2.,6.);\n    vec3 rd = rayDir(uv, normalize(-ro - vec3(0.,1.,0.)), vec3(0.,1.,0.), FOCAL_LENGTH);\n    \n    // render scene\n    vec3 col = getColor(ro, rd);\n    \n    // gamma correction\n    col = pow(col, vec3(1./GAMMA));\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}