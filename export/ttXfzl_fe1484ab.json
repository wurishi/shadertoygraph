{"ver":"0.1","info":{"id":"ttXfzl","date":"1597433663","viewed":132,"name":"Ray Marching + Shadows","username":"Burnout6010","description":"Two ray marched scenes with real-time shadows","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","mandelbulb","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Hold & drag on window to move view\n#define PI 3.1415f\n#define mandelbulb 1 //1 is Mandelbulb scene, 0 is spheres scene\n\n//The shortest distance function of a plane\nfloat GetPlaneSDF(vec3 point, vec3 normal, float height)\n{\n    return dot(point, normal) - height;\n}\n\n//The shortest distance function of a sphere\nfloat GetSphereSDF(vec3 point, vec3 spherePos, float radius)\n{\n    return (length(point - spherePos) - radius);\n}\n\n//The shortest distance function of Mandelbulb\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat GetMandelbulbSDF(vec3 pos)\n{\n    float power = 6.f + sin(iTime) * 0.1f;\n    //float power = iMouse.x / (iResolution.y*0.1f) + sin(iTime) * 0.1f;\n    vec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 128; i++)\n    {\n\t\tr = length(z);\n\t\tif (r > 2.f) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y, z.x);\n\t\tdr =  pow( r, power - 1.0) * power * dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn 0.5f * log(r) * r/dr;\n}\n\n//Following describes the scene\nfloat GetSceneSDF(vec3 point)\n{\n    #if mandelbulb\n    \n    //Mandelbulb scene\n    return GetMandelbulbSDF(point);\n    \n    #else\n    \n    //Other scene\n    float sphereRadius = (sin(iTime) + 2.f) * 3.f;\n    \n    //Spheres\n    float s1 = GetSphereSDF(point, vec3(0.f,0.f,20.f), sphereRadius * 0.75f);\n    float s2 = GetSphereSDF(point, vec3(10.f,0.f,25.f), sphereRadius);\n    float s3 = GetSphereSDF(point, vec3(-10.f,0.f,25), sphereRadius);\n    float spheres = max(min(s2,s3), -s1);\n    \n    //Planes\n    float p1 = GetPlaneSDF(point, vec3(0.f, 1.f, 0.f), -10.f);\n    float planes = p1;\n    \n    //Total\n    return min(spheres, planes);\n    #endif\n}\n\n//Estimate the normal of a given point using the scene\nvec3 GetNormal(vec3 point)\n{\n    //Get distance\n\tfloat dist = GetSceneSDF(point);\n    vec2 e = vec2(.01, 0); //faster to type out\n    \n    //Obtain normal\n    return normalize(dist + vec3(\n        GetSceneSDF(point + e.xyy),\n        GetSceneSDF(point + e.yxy),\n        GetSceneSDF(point + e.yyx)));\n}\n\n//Perform the raymarching itself\nfloat DoMarch(vec3 dir, vec3 origin)\n{\n    //Settings\n \tconst int maxStep = 512;\n    const float maxDistance = 512.f;\n    const float minStep = 1.f / 8192.f;\n    \n    //Start\n    float total = 0.f;\n    float step = GetSceneSDF(origin);\n    \n    //March into the scene for a maximum amount of steps\n    for(int i=0; i < maxStep; ++i)\n    {\n        vec3 point = origin + dir * total;\n        step = GetSceneSDF(point);\n        total += step;\n        \n        //If step was quite small, end\n        if(step < minStep)\n        {\n            return total;\n        }\n    }\n    \n    //If too far, we didn't hit anything\n    if(total > maxDistance)\n    {\n        return 0.f;\n    }\n    \n    return total;\n}\n\n//Perform some lighting calculations\nvec3 DoLight(vec3 pos, vec3 viewDir)\n{\n    //Different lights for different scenes\n    #if mandelbulb\n    vec3 lightDir = normalize(vec3(0.3f, -0.57f, -0.95f)); //light\n    #else\n    vec3 lightDir = normalize(vec3(sin(iTime), -0.57f, cos(iTime))); //light\n    #endif\n    \n    vec3 normal = GetNormal(pos);\n    float value = clamp(dot(-lightDir, normal), 0.f, 1.f);\n\t\n\tif(DoMarch(-lightDir, pos + normal * 0.01f) != 0.f) //No hit == sees light\n    {\n        value *= 0.2f;\n    }\n    \n\tvec3 col = vec3(value * 0.85f, value * 0.85f, value * 0.75f); //sun\n    col += vec3(0.05f, 0.05f, 0.075f); //ambient\n    \n    //Phong\n    vec3 refle = normalize( (normal * 2.f * (dot(normal, lightDir))) - lightDir);\n    float spec = pow(max(dot(viewDir, refle), 0.f), 2.f);\n    col.xyz += spec * 0.2f;\n    \n    //Return result\n    return clamp(col, 0.f, 1.f);\n}\n\n//Creates the look at matrix for given cam pos and a target to look towards\nmat4 LookAt(vec3 camPos, vec3 target)\n{\n    vec3 forward = normalize(target - camPos);\n    vec3 right = normalize(cross(vec3(0.f, 1.f, 0.f), forward));\n    vec3 up = normalize(cross(forward, right));\n    \n    return mat4(\n        vec4(right, 0.f),\n        vec4(up, 0.f),\n        vec4(forward, 0.f),\n        vec4(camPos, 1.f));\n}\n\n//The main program\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Readjust fragcoords to have 0,0 in the middle\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    //Mouse remapped to -1, 1\n    vec2 mouse = ((iMouse.xy-0.5f*iResolution.xy)/iResolution.xy) * 2.f;\n\n    //Setup ray\n    const float camDist = -2.5f;\n    vec3 camPos = vec3(0.f, 0.f, 0.f)\n        + vec3(sin(-mouse.x * PI), -mouse.y, cos(-mouse.x * PI)) * camDist;\n    vec3 camTarget = vec3(0.f, 0.f, 0.f);\n    \n    //Direction of the ray for this fragment, rotated by the LookAt matrix\n    vec3 dir = (LookAt(camPos, camTarget) * normalize(vec4(uv, 1.f, 0.f))).xyz;\n    \n    //March and obtain colour if there is a hit\n    vec3 col = vec3(0.f, 0.f, 0.f);\n    float dist = DoMarch(dir, camPos);\n    if(dist != 0.f)\n    {\n        vec3 pos = camPos + dir * dist;\n        vec3 viewDir = normalize(pos - camPos);\n        col = DoLight(pos , viewDir);\n    }\n    \n    //Display result\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}