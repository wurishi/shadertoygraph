{"ver":"0.1","info":{"id":"cslfRr","date":"1695954554","viewed":43,"name":"Raymarching Attenuation","username":"jsparger","description":"Calculate attenuation when passing through objects","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DISTANCE = 50.0;\nconst float MIN_DISTANCE = .01;\nconst int MAX_STEPS = 8*2048;\n\n// signed distance from p to xy plane at origin\nfloat sd_xy_plane(vec3 p) {\n    return p.z;\n}\n\n// signed distance from p to sphere at origin\nfloat sd_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// signed distance from p to box at origin \n// whose half-dimensions are b.x, b.y, b.z\nfloat sd_box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat smoothMin(float a, float b, float k) {\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) - h * h * h * k * 1.0 / 6.0;\n}\n\nvec2 smooth_csg_union(vec2 d1, vec2 d2, float k) {\n    float mat = d1.x < d2.x ? d1.y : d2.y;\n    float d = smoothMin(d1.x, d2.x, k);\n    return vec2(d,mat);\n}\n\n// Constructive Solid Geometry union operation\n// d1 and d2 are vectors where\n// x is the distance and\n// y is the material density\nvec2 csg_union(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\n// Constructive Solid Geometry intersection operation\n// d1 and d2 are vectors where\n// x is the distance and\n// y is the material density\nvec2 csg_intersection(vec2 d1, vec2 d2) {\n    return d1.x > d2.x ? d1 : d2;\n}\n\n// signed distance for our scene + density\nvec2 scene_map(in vec3 p) {\n    // create the plane\n    float plane_z = 0.5;\n    float d_plane = sd_xy_plane(p-plane_z);\n    float m_plane = 0.2;\n    vec2 plane = vec2(d_plane, m_plane);\n    \n    // create the box\n    vec3 box_pos = vec3(0,0,0);\n    vec3 box_dims = vec3(1.5,1.5,1.5);\n    float d_box = sd_box(p-box_pos, box_dims);\n    float m_box = 0.1;\n    vec2 box = vec2(d_box, m_box);\n\n    // create the sphere\n    vec4 sphere_dims = vec4(3.0,0,0,3.0);\n    float d_sphere = sd_sphere(p-sphere_dims.xyz, sphere_dims.w);\n    float m_sphere = 0.2;\n    vec2 sphere = vec2(d_sphere, m_sphere);\n    \n    return csg_union(\n        box,\n        sphere\n    );\n}\n\nvec2 raymarch(in vec3 ro, in vec3 rd) {    \n    float d = 0.0;\n    float mfp = 0.0;\n    for(int i = 0; i < MAX_STEPS; ++i) {\n        vec2 res = scene_map(ro + rd*d);\n        float step = max(abs(res.x), MIN_DISTANCE);\n        bool inside = res.x < 0.0;\n        d += step;\n        float density = inside ? res.y: 0.0;\n        mfp += step*density; \n        if (d > MAX_DISTANCE) break;\n    }\n    \n    return vec2(d, mfp);\n}\n\n// Compute camera-to-world transformation.\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n#endif\n//HSV (hue, saturation, value) to RGB.\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // camera\n    //vec3 ro = vec3(3.0*sin(iTime),3.0*cos(iTime),15);\n    //vec3 rd = normalize(vec3(uv.x, uv.y, -1));\n    \n    // Bad rotateable camera\n    // camera (ro = ray origin)\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 ro = vec3( 4.0*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 15.0*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    \n    // raymarch\n    vec2 d = raymarch(ro, rd);\n    float transmitted = exp(-1.0*d.y);\n    //vec3 col = vec3(transmitted);\n    //vec3 col = hsv2rgb(vec3(1.0, 1.0-transmitted, 1.0));\n    //vec3 col = vec3(d.x)/length(ro.z);\n    vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(transmitted,transmitted,transmitted,1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}