{"ver":"0.1","info":{"id":"7ddSDB","date":"1633975702","viewed":88,"name":"Arrows1","username":"rudros","description":"Very small but (hopefully) readable ray-caster","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","mini"],"hasliked":0,"parentid":"MdlGWs","parentname":"Boxes1"},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.1415326\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n// Distance of point p to ring #ringNum\nfloat distanceTo(vec3 p, float size) {\n//    p.xz = abs(abs(p.xz)-size*2.2)*rotate2D(PI/6.);\n    p.y += size;  // Ring location\n    return length(p-clamp(p,-size,size));\n}\n\n// Closest point of all the rings\nfloat worldSDF(vec3 p) {\n    float minDist = 1.;\n    for(float j=6.; j>0.; j--) { // Number of rings\n        float size = exp(-j);  // Ring size\n        p.xz = abs(abs(p.xz)-size*2.2)*rotate2D(PI/6.); // Mutation affects the following rings, so can't be moved above\n        float curDist = distanceTo(p, size);\n        minDist = min(minDist, curDist); \n    }\n    return minDist;\n}\n\nvec3 cameraMotion(vec3 p) {\n    p.yz *= rotate2D(-0.8);\n    p.xz *= rotate2D(iTime);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float i;\n    float minDist, eyeDist;\n\n    vec3 eyePos = vec3(0, 0, -1);\n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x, 1.);\n    ray = normalize(ray);\n\n    // Camera motion\n    eyePos = cameraMotion(eyePos);\n    ray = cameraMotion(ray);\n\n    for(minDist=1.; i<100. && minDist>.001; i++) {  \n        // Point to check\n        vec3 p = eyePos+eyeDist*ray;\n        \n        minDist = worldSDF(p);\n        // Move point forward\n        eyeDist += minDist*.5;\n    }\n    // Adjust steps by current distance to surface to fix banding\n    i += minDist*2000.;\n    fragColor = vec4(0) + 100./(i*i);\n}\n","name":"Image","description":"","type":"image"}]}