{"ver":"0.1","info":{"id":"WlcGWS","date":"1577354443","viewed":110,"name":"PolarFunctions","username":"cRocANSTRaphAYOu","description":"Several animated polar functions, easily selectable, including:\n* polar rainbow (animated polar coordinate system)\n* n-petaled rose\n* polar sine wave\n* spur gear\n* that's actually it so far.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math","polarcoordinates","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//------------------------------------------------------------------+\n//                                                                  |\n// SUMMARY                                                          |\n//                                                                  |\n// I made this shader to demo some polar coordinates animations     |\n// in Shadertoy. This was for my own amusement and reinforcement,   |\n// but I hope it can also be useful for somebody else. There are    |\n// a lot of amazing shaders on this site but it's hard to learn     |\n// from advanced projects with a lot going on at once.              |\n// this module allows you to experiment with ONE FUNCTION AT A TIME |\n// so that you can understand how all its parameters work.          |\n//                                                                  |\n// EDIT: 12/26/19                                                   |\n//                                                                  |\n// Switch statements don't work universally with mobile devices so  |\n// I changed them to IF's.                                          |\n//------------------------------------------------------------------+\n\n//----------------------------------------------------------------+\n// Petals Function:\t\t\t\t\t\t\t\t\t\t\t\t  |\n// First input is the cardinal coordinate system for our pixels.  |\n// Second input is the number of petals.                          |\n//----------------------------------------------------------------+\nvec2 Petals(vec2 uv, float n)\n{\n \tfloat t = atan(uv.y,uv.x) + iTime;\n    float r = 0.5*(1.0 + cos(n*t));\n    \n    return vec2(r,t);\n}\n\n//-----------------------------------------+\n// Polar Sine Function:\t\t\t\t       |\n// Useful for adjusting into blobs, gears, |\n// and other crazy things.                 |\n//-----------------------------------------+\nvec2 PolarSine(vec2 uv, float radius, float amplitude, float frequency, bool absVal)\n{\n    float t = atan(uv.y,uv.x) + iTime;\n    float trigPart = (absVal == false) ? sin(t*frequency) : abs(sin(t*frequency));\n    float r = radius + amplitude * trigPart;\n    \n    return vec2(r,t);\n}\n\n//----------------------------------------------+\n// Gear Function:\t    \t\t\t            |\n// ...having said that, I am using a different  |\n// function to approximate a gear. Making gears |\n// that mesh properly is interesting and you    |\n// don't need a bachelors degree to figure it   |\n// out, but it is a lot of computation that I   |\n// won't bother with now...stay tuned, though ;)|\n//----------------------------------------------+\n// using formula from Mathematics Stack Exchange:\n// https://math.stackexchange.com/questions/100655/cosine-esque-function-with-flat-peaks-and-valleys\nvec2 Gear(vec2 uv, float radius, float amplitude, float sharpness, float frequency)\n{\n    float t = frequency*(atan(uv.y,uv.x) + iTime);\n    float tooth = sqrt((1.0 + sharpness*sharpness)/(1.0 + sharpness*sharpness * cos(t)*cos(t)))*cos(t);\n    float r = radius + amplitude * tooth;\n    \n    return vec2(r,t);\n}\n\n//------+\n// MAIN |\n//------+\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center cardinal coordinate system with square resolution:\n    vec2 uv =  ( fragCoord -0.5 * iResolution.xy )/ iResolution.y;\n    \n    // Set up polar coordinate system:\n    // *2 so top/bottom of screen is +-1, not +-1/2\n    float r = length(uv)*2.0;\n    float t = atan(uv.y,uv.x);\n    vec2 polar = vec2(r,t);\n\n    // initialize color vector, mask:\n    vec3 col = vec3(0);\n    vec3 mask = vec3(0);\n    \n    //--------------------+\n    // CASES: EXPERIMENT! |\n    //--------------------+\n    \n    // CASE 1: Animated Polar Coordinates\n\t// CASE 2: N-Petaled Rose\n    // CASE 3: Polar Sine Wave\n    // CASE 4: Spur Gear\n    \n    \n    // SET THIS VALUE AND HIT PLAY.\n    // YOU CAN ADJUST FUNCTION ARGUMENTS FOR EACH CASE.\n    \n    \n    \n    int int_value = 4;\n    \n    \n    \n    \n    if (int_value == 1) \n    {\n        //---------------------------+\n        // Time-varying pixel color: |\n        //---------------------------+\n        \n        col = 0.5 + 0.5*cos(iTime+polar.xyx+vec3(0,2,4));\n     }\n    \n    else if (int_value == 2)\n    {\n        //-------------------+\n        // Draw some petals: |\n        //-------------------+\n        // uv, number of petals\n\n    \tvec2 petals = Petals(uv, 5.0);\n        // we only draw pixels <= the petal radius:\n    \tif (polar.x <= petals.x)\n    \t{\n            mask.x += petals.x;\n            mask.y += petals.y;\n            mask.z = mask.x;\n        }\n        col = 0.5 + 0.5*cos(iTime+polar.xyx+vec3(0,2,4));\n        col *= mask.x;\n    }\n    \n    else if (int_value == 3)\n    {\n        //------------------+\n        // Polar Sine Wave: |\n        //------------------+\n        // uv, radius, amplitude, frequency, \"use absolute value?\" (T/F)\n\n    \tvec2 polarSine = PolarSine(uv, 0.85, 0.15, 16.0, false);\n        // we only draw pixels <= the circle radius:\n    \tif (polar.x <= polarSine.x)\n    \t{\n            mask.x += polarSine.x;\n            mask.y += polarSine.y;\n            mask.z = mask.x;\n        }\n        col = 0.5 + 0.5*cos(iTime+polar.xyx+vec3(0,2,4));\n        col *= mask.x;\n    }\n    \n    else if (int_value == 4)\n    {\n        //-------+\n        // Gear: |\n        //-------+\n        // uv, radius, amplitude, sharpness, frequency\n        \n        vec2 gear = Gear(uv, 0.925, 0.075, 5.0, 16.0);\n        // we only draw pixels <= the circle radius:\n    \tif (polar.x <= gear.x)\n    \t{\n            mask.x += gear.x;\n            mask.y += gear.y;\n            mask.z = mask.x;\n        }\n        col = 0.5 + 0.5*cos(iTime+polar.xyx+vec3(0,2,4));\n        col *= mask.x;\n    }\n    \n    //-----------------\n    // Output to screen\n    fragColor = vec4(col.xy, 0.0,1.0);\n}","name":"Image","description":"","type":"image"}]}