{"ver":"0.1","info":{"id":"fd2XDz","date":"1620044805","viewed":83,"name":"Waves of ball sea","username":"seven_dc","description":"Raymarching rolling wave with metabalzz","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["waves","raymarch"],"hasliked":0,"parentid":"sdsSzl","parentname":"Fork Rolling wa seven_dc 329"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 40\n#define MAX_DIST 50.\n#define SURF_DIST .01\n#define CLOSE_SURF_DIST .1\n\nfloat smin( float a, float b, float k ) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDistance(vec3 point) {\n\t\n    float texture = sin((iTime + point.x)*.2)*2.4+\n        sin((iTime + point.x)*.25)*1.1+\n        sin(point.z*2.5+sin(iTime)*.1)*.15+\n        sin(point.x*5.+point.z*.015)*.41;\n    \n    float planeDist = point.y + texture*.5;\n    \n    vec4 sphere = vec4(1., 1., 1.5, 0.5);\n    vec3 spoint = vec3(mod(point.x, 2.), point.y, mod(point.z, 3.));\n    float sphereDist =  length(spoint-sphere.xyz)-sphere.w-sin(point.x+point.z+iTime)*.1;\n    \n    return smin(planeDist, sphereDist, .9);\n}\n\n\nvec3 GetNormal(vec3 point) {\n  float distance = GetDistance(point);\n  vec2 e = vec2(.01,0);\n  \n  vec3 normal = distance - vec3(\n      GetDistance(point-e.xyy),\n      GetDistance(point-e.yxy),\n      GetDistance(point-e.yyx));\n  \n  return normalize(normal);\n}\n\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int steps = MAX_STEPS; \n    int c = 0; // close of surface\n    \n    for(int i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        \n        if (distance<CLOSE_SURF_DIST) c++;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance,c);\n}\n\nfloat GetLight(vec3 point, vec3 normal, vec3 lightPos) {    \n  \n  vec3 direction = normalize(lightPos-point);\n  \n  float dif = clamp(dot(normal, direction), 0., 1.);\n  \n  vec2 d = RayMarch(point+normal*.1, direction);\n  if ( d.x < length(lightPos-point)) {\n      dif *= .5;\n  } else {\n      dif -= d.y*.01;\n  }\n  \n  return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0.-sin(iTime*.1), 3.5, 0);\n    vec3 rayDirection = normalize(vec3(uv.x-sin(iTime*.1), uv.y-0.45, 1));\n\n    vec2 d = RayMarch(rayOrgin, rayDirection);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 lightPos = vec3(1.-sin(iTime*.1), 5.5, 1);\n    \n    if (d.x < 120.) {\n        vec3 p = rayOrgin + rayDirection * d.x;\n        vec3 n = GetNormal(p);\n        float light = GetLight(p, n, lightPos);\n        // color\n        float dist = d.x/36.;\n        col = vec3(\n            light*0.9-dist,\n            light*0.9-dist/1.5+(d.y*20.04),\n            light-dist/2.5+(d.y*20.8)\n        );\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}