{"ver":"0.1","info":{"id":"wtVSDw","date":"1582991302","viewed":93,"name":"Cubemapped Sphere","username":"spalmer","description":"cubemapping a sphere.  dipping toe into the water of Cube A buffer.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere","cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float orbit_scale = 3.; // of radius of object\n\n// camera code is mostly in Common now.\n\nconst float radius = 2.; // of object resting on ground to examine\n\n// I'm *this* close to copying this into Cube A, but without the sphere.\n// But that's not smart.  I want to come up with a scene management system\n// that can all go in Common tab.\n\n// anyway there's no lighting whatsoever.\n// Grids are antialiased.  Kinda.\n// none of the graphics are really the point. \nvec3 RenderScene(vec3 ro, vec3 rd, float time)\n{\n    vec3 c = vec3(0.); vec3 op = vec3(0.,radius,0.);\n    uint i = 0u; // sky is id 0\n    float d = 1e4, dtemp; // prep trace scene\n    #if PLANE\n    ConsiderObject(dtemp, d, i, tracePlaneY(ro, rd), 1u);\n    #endif\n    ConsiderObject(dtemp, d, i, traceBall((ro - op) / radius, rd) * radius, 2u);\n    vec3 csky = rd * .5 + .5; //const vec3 csky = vec3(.5, .7, .9); //\n    vec3 hp = ro + d * rd; // hit pos\n    switch (i) {\n        case 0u: { // sky\n            c.rgb = csky, d = 1e4;\n        \tbreak;\n        }\n        #if PLANE\n        case 1u: { // plane\n            //vec2 hp = ro.xz + d * rd.xz; // hit pos\n            // I'd rather just stripe the object in this one\n    \t\tfloat stripe = cos(hp.x) * cos(hp.z); //1.; // 2d grid texture\n            stripe *= stripe; stripe = 1. - stripe; stripe *= stripe;\n            stripe = mix(stripe, .3, min(1., .4*length(fwidth(hp.xz)))); // aa\n        //    if (d == 0.) stripe = sin(iTime*12.); // beneath? flash\n            c.rgb = vec3(.5*stripe, .5, 0.); // colorize\n        \tbreak;\n        }\n        #endif\n        case 2u: { // sphere\n            hp -= op;\n            // lod 4 is very blurry but with the smooth debug normal sky function, \n            // linear artifacts aren't too objectionable even at lod 6. or so\n            c.rgb = textureLod(iChannel0, hp, 2.).rgb; // cube map A - lod 10. is 1x1\n            c.rgb = pow(c.rgb, vec3(2.2)); // de-srgb-gamma\n            // TODO antialias silhouette edge!  ;)\n\t        break;\n        }\n        default:\n\t        break;\n    }\n    float dfade = exp2(-.02*d);\n    c.rgb = mix(csky, c.rgb, dfade);\n    return c;\n}\n\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    c = vec4(0.,0.,0.,1.);\n    vec2 R = iResolution.xy\n        , M = iMouse.xy\n        , q = StoQ(   p, R)\n        , m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n        m = vec2(.2 + .02*iTime,-.15); // unattended, mouse in bottom left corner?\n    vec3 object_pos = vec3(0., radius, 0.)\n        , camera_dir = OrbitCamera(m)\n        , camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n  #if 1 && PLANE\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n  #endif\n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = pi/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos, rd = normalize(cam * vd); // view ray\n    c.rgb = RenderScene(ro, rd, iTime);\n//    c.rgb = Unwrap(iChannel0, q * .76);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // gamma (disable for texture cube sources, or fix those on load)\n}\n\n    // TODO dither\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"\n\nvoid mainCubemap(out vec4 o, vec2 p, vec3 ro, vec3 rd)\n{\n    if (iFrame > 1) discard; // compute into both double buffers then done\n    // Ray direction as color\n    vec3 col = .5 + .5*rd;\n\t// p provides the fragCoord 0.5..1023.5 and \n    // from the signs of rd, we can obtain the face index\n    //int i = CubeFaceOfDir(rd);\n    // Output to cubemap, 6*(2^10)^2 rgba16f  half-precision sfloats\n    o = vec4(col,1.0);\n    o.rgb = pow(o.rgb, vec3(1./2.2)); // srgb-gamut?\n    // not much point to gamma and de-gamma when buffer is half precision,\n    // besides consistency with other cubemap textures.\n    // my guess is that the sampler isn't setup for srgb properly anyway\n    // so all the filtering will be done in wrong gamma anyway, but oh well.\n    // maybe I can find out for sure and do the right thing for st.com.\n    // my guess is in that case it's best not to gamma & de-gamma at all.\n    // but then that's no longer consistent.  gah!  gamma is a pita.\n}\n\n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define PLANE 1\n\nconst float pi = acos(-1.); //3.1415927;\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\n// build a 3x3 camera orientation matrix given forward direction vector, assuming up is +Y\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n// then transform by pw = MC * pv;\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * pi, 1.));\n} // returns forward vector camera aims along\n\n\n// I'm sure you can put the sphere and plane \n// to good use as bounding and clipping shapes.\n#if PLANE\nfloat tracePlaneY(vec3 ro, vec3 rd)\n{\n    return ro.y <= 0. ? 0. : rd.y >= -5e-3 ? -1. : ro.y / -rd.y;\n}\n#endif\n\n// I needed an object to rotate around.  So...\n// first I stripped down my rootfinder a bit\nfloat Root(vec3 f) // first zero crossing of polynomial quadric function\n{ // f(t) = dot(f, vec3(1.,vec2(1.,t)*t)) == 0\n\tfloat d = sqrt(.25 * f.y * f.y - f.x * f.z);\n\tif (f.y * f.z < 0.) d = -d;\n\treturn (d - .5 * f.y) / f.z;\n} // see also The Quadratic Equation\n// actually I don't believe it actually works in the general case anymore\n// it only handles the inputs that traceBall gives it\n// then I just inlined thru my traceSphere for radius=1\n// this I'm sure has its origins somewhere in probably RTCD by Ericson;\n// I'm not the first to pose the problem this way.\n// Considering that by now it's a hash of a riff of a take\n// of a redux of a 10th iteration on whatever it was,\n// I'm not sure how to attribute the concept, really.\n// In any case I just wrote this function from scratch:\nfloat traceBall(vec3 ro, vec3 rd)\n{\n\treturn Root(vec3(dot(ro, ro) - 1., 2. * dot(ro, rd), 1.));\n}\n// BTW: it doesn't handle camera inside sphere properly, doesn't handle negative radii, etc.\n// it's a very simple ball tracer function just for this example.\n// In fact I may wind up having to fix some of that.\n\n// TODO surely there's a better scene integration mechanism to be written here\n// first 3 are inout arguments, last 2 unmodified.\n// sorry about the dtemp var hack, it's pretty lame.\n/// macro is to future-proof check of bounding volume etc.\n#define ConsiderObject(dtemp, dmin, imin, dobj, iobj) \\\ndtemp = dobj; \\\nif (0. <= dtemp && dtemp < dmin) \\\n{ dmin = dtemp; imin = iobj; }\n///\n// TODO wrap in do{...}while(false)\n\n\n// I put all this into a toy:  https://shadertoy.com/view/tlyXzG\nint CubeFaceOfDir(vec3 d)\n{\n    vec3 a = abs(d);\n    int f = a.x >= a.y ? (a.x >= a.z ? 0 : 2) : (a.y >= a.z ? 1 : 2);\n    int i = f + f;\n    if (d[f] < 0.) ++i;\n    return i;\n}\n\n/* // there's no sense repeating that, now that I refactored it, may as well use it\nvec3 DirToCubeFace(vec3 d)\n{\n    vec3 a = abs(d);\n    int f = a.x >= a.y ? (a.x >= a.z ? 0 : 2) : (a.y >= a.z ? 1 : 2);\n    vec2 uv;\n    float w;\n    switch (f) {\n        case 0: uv = d.yz; break;\n        case 1: uv = d.xz; break;\n        case 2: uv = d.xy; break;\n    }\n    w = d[f];\n    uv /= a[f];\n    int i = f + f;\n    if (w < 0.) { \n        ++i; // negative face = odd index\n        uv.x = -uv.x;\n    }\n    return vec3(uv, float(i));\n}\n*/\n// takes normalized direction vector, returns uv in c.xy and face id in c.z\nvec3 DirToCubeFace(vec3 d)\n{\n    int i = CubeFaceOfDir(d)\n    , f = i >> 1;\n    vec2 uv;\n    switch (f) {\n        case 0: uv = d.yz; break;\n        case 1: uv = d.xz; break;\n        case 2: uv = d.xy; break;\n    }\n    uv /= abs(d[f]); // project\n    if ((i&1) != 0) // negative faces are odd indices\n        uv.x = -uv.x; // flip u\n    return vec3(uv, float(i));\n}\n// takes uv in c.xy and face id in c.z, returns unnormalized direction vector\nvec3 CubeFaceToDir(vec3 c)\n{\n    int i = int(c.z); \n    vec3 d = vec3(c.xy, 1. - 2. * float(i & 1));\n    d.x *= d.z; // only unflip u\n    switch (i >> 1) { // f\n        case 0: d = d.zxy; break;\n        case 1: d = d.xzy; break;\n        case 2: d = d.xyz; break;\n    }\n    return d; // needs normalized probably but texture() doesn't mind.\n}\n\n// in mainCubemap we get vec2 p and vec3 rd\n// so would be easy to get the uv already but\n// the face index is DirToCubeFace(rd).z\n\n// just for debugging so probably broken and imprecise.\n// in fact it's a big ol' kludge atm.\nvec3 Unwrap(samplerCube ch, vec2 q)\n{\n    vec2 uv = q * .5 + .5;\n    uv *= 4.;\n    uv -= vec2(.0,.5);\n    int i = -1;\n    if (uv.y >= 1. && uv.y < 2.) {\n        int f = int(floor(uv.x));\n        if (f >= 0 && f < 2) i = 3*f + 1;\n     \telse if (f >= 2 && f < 4) i = 5*f - 10;\n        if (f == 2) uv = vec2(uv.y, -uv.x); // maybe rotate, different directions\n        else if (f == 0) uv = vec2(-uv.y, uv.x);\n    } else {\n\t    if (int(uv.x) == 1) {\n\t        if (uv.y >= 0. && uv.y < 1.) { i = 3; uv.x = 0.-uv.x; }\n\t        else if (uv.y >= 2. && uv.y < 3.) { i = 2; uv.y = 0.-uv.y; }\n\t    }\n    }\n\tif (!(i >= 0)) return vec3(.5);\n    uv = fract(uv);\n    vec3 d = CubeFaceToDir(vec3(uv * 2. - 1., float(i)));\n    return textureLod(ch, d, 0.).rgb;\n}\n\n","name":"Common","description":"","type":"common"}]}