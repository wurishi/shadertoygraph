{"ver":"0.1","info":{"id":"tlB3WG","date":"1560951455","viewed":220,"name":"Moon Flyby","username":"SSHantaram","description":"Raymarched plane with procedural noise perturbations.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","bump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float BUMP_FACTOR = 0.5;\n\n\n// 3D hash function\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// 3D precedural noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    // interpolate between hashes of adjacent grid points\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// 3D noise layered in several octaves\nfloat layeredNoise(in vec3 x) {\n    return 0.7*noise(x) + 0.2*noise(x*4.0) + 0.07*noise(x*8.0) + 0.02*noise(x*16.0) + 0.01*noise(x*32.0);\n}\n\n// singed distance function of the y=0 plane\nfloat planeSDF(vec3 p) {\n    return p.y;\n}\n\n// singed distanc function of plane with noise bump map\nfloat bumpPlaneSDF(vec3 p) {\n    // get distance to plane as usual\n    float d = planeSDF(p);\n    \n    vec3 normal;\n    float bump = 0.0;\n    \n  \t// only consider bumps if close to plane\n    if(d < BUMP_FACTOR*1.5)\n\t{\t\n\t\tnormal = vec3(0.0, 1.0, 0.0);\n\t\tbump = layeredNoise(p)*BUMP_FACTOR;\n\t}\n    return d - bump;\n}\n\n// singed distance function to enire scene\nfloat sceneSDF(vec3 samplePoint) {\n    return bumpPlaneSDF(samplePoint);\n}\n\n// returns the distanse to the scene along this ray\n// by raymarching using the sceneSDF\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    //raymarching loop\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        // get distance to scene\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        // exit if close enough\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        // step closer\n        depth += dist;\n        // exit if too far\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// estimate normal by aproximatind the first deriviative of the sceneSDF\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// generate camera transform\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n// lambert shading coefficient with raymarched shadows\nfloat lambertShading(vec3 p, vec3 lightDir) {\n    vec3 n = estimateNormal(p);\n    \n    // lambert shading coefficient\n    float brightness = max(0.0, dot(-lightDir, n));\n    \n    // trace ray from surface point in direction of the light source\n    // offset in direction of the normal to avoid self intersection\n    float distToLight = shortestDistanceToSurface(p + n * EPSILON * 100.0, -lightDir, MIN_DIST, MAX_DIST);\n    \n    // in shadow\n    if (distToLight + 10.0 * EPSILON < MAX_DIST) {\n        return 0.0;\n    }\n    \n    return brightness;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n   \tvec3 eye = vec3(2.0*sin(iTime*0.3 - 3.0), 3.0, iTime);\n    mat3 viewToWorld = viewMatrix(eye, eye + vec3(2.0*sin(iTime*0.3), -3.0, 8.0), vec3(0.2*sin((iTime-1.0)*0.3), 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 lightDir = normalize(vec3(-1.0, -1.0, -3.0));\n    \n    vec3 ambientLight = vec3(0.01, 0.01, 0.005);\n    vec3 diffuseColor = vec3(0.8, 0.8, 0.8);\n    \n    vec3 color = ambientLight;\n    \n    color += diffuseColor*lambertShading(p, lightDir);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}