{"ver":"0.1","info":{"id":"ldBcWW","date":"1492065597","viewed":217,"name":"Slide Operation","username":"gaz","description":"idia from sdCapsule","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotate(in vec3 axis, in float theta)\n{\n  axis = normalize(axis);\n  float x = axis.x, y = axis.y, z = axis.z, s = sin(theta), c = cos(theta), o = 1.0-c;\n  return mat3(\n    o*x*x+c,o*x*y+z*s,o*z*x-y*s,\n    o*x*y-z*s,o*y*y+c,o*y*z+x*s,\n    o*z*x+y*s,o*y*z-x*s,o*z*z+c);\n}\n\nvec4 opSlide(vec3 p, vec3 a, vec3 b, vec3 up){\n  vec3 ba = b - a;\n  float h = clamp(dot(p-a, ba) / dot(ba, ba), 0., 1.);\n  p -= a + ba * h;\n  vec3 w = normalize(ba), u = normalize(cross(up, w)), v = cross(w, u);\n  return vec4(p * mat3(u, v, w), h);\n}\n\n/*\nvec4 opSlide(in vec3 p, in vec3 a, in vec3 b, in vec3 up)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  vec3 hor = normalize(cross(ba, up));\n  vec3 ver = normalize(cross(ba, hor));\n  p = p - (a + ba * h);\n  return vec4(dot(p, hor), dot(p, ver), dot(p, normalize(ba)), h);\n}\n*/\n\nfloat sdSphere(in vec3 p, in float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism(in vec3 p, in vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat udRoundBox(in vec3 p, in vec3 b, in float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat deJyabara(in vec3 p, in float t)\n{\n\tfloat de2 = abs(length(p.xz) - 0.5 + 0.02 * sin(t * 30.0));\n    vec2 d = abs(vec2(de2, p.y)) - vec2(0.08, 0.0);\n  \treturn min(max(d.x, d.y), -0.03) + length(max(d, 0.0));  \n}\n\nfloat map(in vec3 p)\n{\n\tvec3 a = rotate(normalize(vec3(1, 2, -3)), iTime*0.5) * vec3(0.8);\n \tvec3 b = rotate(normalize(vec3(2, 1, -1)), iTime*0.3) * vec3(-0.7);\n \tvec3 up = normalize(vec3(1,2,3));   \n\tvec4 op = opSlide(p, a, b, up);\n\tp = op.xyz; \n\tswitch (int(floor(mod(iTime * 0.3, 5.0)))) {\n\tcase 0:\n  \t\treturn length(max(abs(p) - vec3(0.5, 0.2, 0.0), 0.0)) - 0.05;\n  \tcase 1:\n\t\treturn sdTorus(p, vec2(0.5, 0.2));\n  \tcase 2:\n\t\treturn sdHexPrism(p.xzy, vec2(0.3, 0.2));\n  \tcase 3:\n\t\treturn sdSphere(p, 0.35);\n  \tcase 4:\n\t\treturn deJyabara(p.xzy, op.w);\n  \t}\n}\n\nvec3 calcNormal(in vec3 p)\n{\n  vec2 e = vec2(1.0, -1.0) * 0.002;\n  return normalize(\n    e.xyy*map(p+e.xyy)+e.yyx*map(p+e.yyx)+ \n    e.yxy*map(p+e.yxy)+e.xxx*map(p+e.xxx)\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n  vec3 ro = vec3(0, 0, 3);\n  vec3 rd = normalize(vec3(p, -1.5));\n  vec3 col = vec3(0.1, 0.6, 0.7) * p.y * p.y;\n  float maxd = 10.0;\n  float t = 0.0, d;\n  for(int i = 0; i < 128; i++)\n  {\n    t += d = map(ro + rd * t);\n    if(d < 0.001 || t > maxd) break;\n  }\n  if(t < maxd)\n  {\n    vec3 p = ro + rd * t;\n    vec3 normal = calcNormal(p);\n    vec3 light = normalize(vec3(1));\n    col = \n      mix(\n        col,\n        clamp(\n          vec3(1.0, 0.2, 0.2) *\n          clamp((dot(normal, light)+0.5)*0.7, 0.3, 1.0) *\n          max(0.0, 0.7+0.3*normal.y) +\n          pow(\n            clamp(\n              dot(reflect(normalize(p - ro), normal), light),\n              0.0, 1.0\n            ),\n            80.0\n          ) * step(0.5, dot(normal, light)),\n          0.0,1.0\n        ),\n        exp(-pow(length(p - ro),2.0)*0.02)\n      );\n  \tcol = pow(col, vec3(0.7));\n  }\t\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}