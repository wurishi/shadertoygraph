{"ver":"0.1","info":{"id":"stSfWK","date":"1653110112","viewed":45,"name":"Real raymarch","username":"TeamwinFTW","description":"Mountains","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DELTA 0.0001\n#define COLLISIONLENGTH 0.005\n#define VIEWDISTANCE 10.0\n\n#define BRIGHTNESS 5.0\n#define FOV 10.0\n#define PI 3.1415926\n\n\n//Interpolation used when blending between cell corners\nfloat sineint (float x){\n\n   float sineval = (0.5+cos(x*3.14159)*0.5);\n   float floatval = 1.0-x;\n   float mixfac = 1.0;\n   \n   //return pow(sineval,0.85)*mixfac + floatval*(1.0-mixfac);\n   return pow(1.0-x,1.7);\n\n}\n//Pseudo-RNG used to determine values at set points\nfloat PRNG2d(vec2 coord,float seed){\n\n    seed = mod(seed+ 0.01,100.0);\n    seed = seed/20.0;\n    coord = mod(coord,1000.0);\n    float x = mod(pow(coord.x,1.541523) * 0.1588235 + seed/20.65546689 + pow(coord.y * seed/8.51325,1.563) * 5.55464, 0.2)/0.2;\n    x = clamp(x,0.0,1.0);\n    x = mod(coord.x * 1.365448 * (seed/5.23648564) + coord.y * 2.21658+ x*2.05213,x)/x;\n    x = clamp(x,0.0,1.0);\n    x = mod(pow (coord.y + coord.x,x)*20.0,1.0);\n    \n    return x;\n}\n\nfloat Noise(vec2 InputCoord, float seed, float scale)\n{\n\n    \n    \n    InputCoord = InputCoord*scale;\n    \n    //Cell corner positions\n    vec2 cor1 = vec2(floor(InputCoord.x),floor(InputCoord.y));\n    vec2 cor2 = vec2(ceil(InputCoord.x),floor(InputCoord.y));\n    vec2 cor3 = vec2(floor(InputCoord.x),ceil(InputCoord.y));\n    vec2 cor4 = vec2(ceil(InputCoord.x),ceil(InputCoord.y));\n    //Distances to Cell corners\n    float dist1 = distance(InputCoord,cor1);\n    float dist2 = distance(InputCoord,cor2);\n    float dist3 = distance(InputCoord,cor3);\n    float dist4 = distance(InputCoord,cor4);\n    //Values of cell corners\n    float val1 = PRNG2d(cor1,seed);\n    float val2 = PRNG2d(cor2,seed);\n    float val3 = PRNG2d(cor3,seed);\n    float val4 = PRNG2d(cor4,seed);\n    //Absolute weight of corners based on proximity \n    float weight1 = sineint(clamp(dist1,0.0,1.0));\n    float weight2 = sineint(clamp(dist2,0.0,1.0));\n    float weight3 = sineint(clamp(dist3,0.0,1.0));\n    float weight4 = sineint(clamp(dist4,0.0,1.0));\n    \n    //Factor used to trim weights to add to 1.0\n    float TrimFactor = 1.0/(weight1 + weight2 + weight3 + weight4);\n    //TrimFactor = 1.0;\n    float value = val1*weight1*TrimFactor + val2*weight2*TrimFactor + val3*weight3*TrimFactor + val4*weight4*TrimFactor;\n    return value;   \n}\n\n\n//Sphere SDF\nfloat spheredist(vec3 ICoord)\n{\n    float scale = 5.0;\n    vec3 SCoord = vec3(2.0,4.0,20.0);\n    float radius = 3.0;\n    \n    float distToCenter = distance(ICoord,SCoord); \n    \n    float noiseval = Noise(vec2(ICoord.x,ICoord.z),20.0,0.5)*0.5\n    +Noise(vec2(ICoord.x,ICoord.z),10.0,1.0)*0.25+\n    Noise(vec2(ICoord.x,ICoord.z),50.0,2.0)*0.125+\n    Noise(vec2(ICoord.x,ICoord.z),2.0,4.0)*0.0625+\n    Noise(vec2(ICoord.x,ICoord.z),1.0,8.0)*0.03125+\n    Noise(vec2(ICoord.x,ICoord.z),8.0,16.0)*0.015625+\n    Noise(vec2(ICoord.x,ICoord.z),16.0,32.0)*0.0078125+\n    Noise(vec2(ICoord.x,ICoord.z),32.0,64.0)*0.00390625/*+\n    Noise(vec2(ICoord.x,ICoord.z),64.0,128.0)*0.00195312+\n    Noise(vec2(ICoord.x,ICoord.z),52.0,256.0)*0.00097656*/;\n    \n    \n    \n    \n    \n    \n    \n    \n    noiseval = (noiseval-0.5)*scale;\n    \n    noiseval = ICoord.y-noiseval+1.0;\n    return noiseval/scale;\n    \n    \n    \n    \n    \n    //return distToCenter - radius;\n    \n\n}\n//Noise SDF\nfloat Noisedist(vec3 ICoord)\n{\n    float noiseval = Noise(vec2(ICoord.x,ICoord.z),20.0,1.0);\n    noiseval = ICoord.y-noiseval;\n \n \n    return noiseval;\n}\nvec3 fieldDelta(vec3 ICoord)\n{\n\n    vec3 Delta = vec3(\n    spheredist(ICoord)-spheredist(ICoord+vec3(DELTA,0.0,0.0)),\n    spheredist(ICoord)-spheredist(ICoord+vec3(0.0,DELTA,0.0)),\n    spheredist(ICoord)-spheredist(ICoord+vec3(0.0,0.0,DELTA)));\n    \n    Delta = Delta*vec3(-1.0/DELTA);\n    \n    return Delta;\n\n}\nvec3 lighting(vec3 normals, vec3 lightdir, vec3 color, float roughness)\n{\n    vec3 Output = color;\n    vec3 reflecVec = reflect(vec3(0.0,0.0,1.0),normals);\n    lightdir = normalize(lightdir)*float(lightdir!=vec3(0.0,0.0,0.0));\n    \n    Output = color*dot(normals,lightdir)*roughness;\n    Output += (1.0-roughness)* pow(clamp(dot(lightdir,reflecVec),0.0,1.0),1.0/roughness);\n    \n    return max(Output,0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 fixeduv = vec2(uv.x*(iResolution.x/iResolution.y),uv.y);\n    fixeduv = fixeduv-vec2((iResolution.x/iResolution.y)/2.0,0.5);\n    fixeduv*=2.0;\n    \n    float radfov = FOV * (PI/180.0);\n    \n    vec3 norm = vec3(0.0);\n    float zdepth = 0.0;\n    vec3 RayCoord = vec3(fixeduv,0.0);\n    float RayDist = 0.01;\n    vec2 offsetfactor = tan(radfov) * fixeduv;\n    vec3 vecoffset = vec3(0.0);\n    int i = 0;\n    do {\n        \n        RayDist = spheredist(RayCoord);\n        vecoffset = vec3(RayDist*offsetfactor, RayDist);\n\n        vecoffset = vecoffset*(RayDist/length(vecoffset));\n        \n        RayCoord = RayCoord+vecoffset;\n        zdepth += RayDist;\n        \n        \n        \n        \n        \n        if (RayDist < COLLISIONLENGTH) {\n            \n            norm = fieldDelta(RayCoord);\n            RayDist = VIEWDISTANCE+20.0;\n       \n       }\n        i+=1;\n       } \n    while (RayDist < VIEWDISTANCE);\n    //Surface Shader code\n\n    vec3 CamRay = normalize(vec3(offsetfactor,1.0));    \n    float fresnel = dot(-CamRay,norm);\n    \n    vec3 col;\n    vec3 color = vec3(0.5,1.0,1.0);\n    vec2 evenMouse = iMouse.xy*2.0/iResolution.xy-1.0;\n    color = vec3(Noise(evenMouse,1.0,4.0),Noise(evenMouse,2.0,4.0),Noise(evenMouse,3.0,4.0));\n    color = color*BRIGHTNESS;\n    vec3 lightdir = normalize(vec3(evenMouse,distance(evenMouse,vec2(0.0))-0.4));\n    col = (vec3(0.1)+lighting(norm,lightdir,color,0.5))*float(zdepth<100.0) ;\n    \n    // Output to screen\n    //fragColor = float(zdepth < 50.0) * vec4(1.0-fresnel);\n    fragColor = vec4(col,1.0);    \n}","name":"Image","description":"","type":"image"}]}