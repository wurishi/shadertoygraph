{"ver":"0.1","info":{"id":"WtXSWH","date":"1562745709","viewed":118,"name":"Midpoint polygon","username":"tgsstdio","description":"Draws polygon with circular hole with triangles\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["polygon","hole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CONTROLS NO OF POINTS ON POLYGON\n#define TWO_PI 6.283185307179586476925286766559\n\n#define LOOP_IN_SECS 15.0\n\n#define MIN_N 3\n#define MAX_N 12\n\n// TIME FUNCTIONS see https://www.shadertoy.com/view/MtXyD2\n\n// CONTROLS NO OF QUADS PER TRI\n\n#define SUBDIVISION_LOOP_IN_SECS 0.75\n#define NO_OF_DIVISIONS 4\n\nconst int sections[NO_OF_DIVISIONS] = int[](\n    6,\n    12,\n    24,\n    30  \n);    \n\n\n// CONTROLS RADIUS OF INNER HOLE\n\n#define MID_POINT 0.25\n#define RANGE_OF_TRIG_FUNC 0.24\n#define TWO_PI 6.283185307179586476925286766559\n// in hertz (per sec)\n#define FREQUENCY 0.5\n\n// RENDER SCALE\n\nconst float UNIT_SCALE = 4.0;\n\n// https://www.shadertoy.com/view/XsXSz4\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec2 getMidpoint(vec2 a, vec2 b)\n{\n    vec2 dir = b - a;\n    return a + 0.5 * dir;\n}\n\nvec2 getInnerPoint(vec2 p1, vec2 p2, float ratio)\n{\n    vec2 dir = p2 - p1;\n    return p1 + (ratio * dir);\n}\n\nvec2 getRadialPoint(vec2 centre, vec2 outer, float radius)\n{\n    vec2 n = normalize(outer - centre);    \n    return centre + radius * n;\n}\n\nvec4 drawColouredQuad(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec4 outColor = vec4(0,0,0,0);\n    // QUAD 2\n    \t// outer [i+1] -> outer[i] \n    \t// inner [i+1] -> inner[i]\n    \t// inner[i+1], inner[i], outer[i+1]\n    if (sdTriangle(a, b, c, uv) <= 0.0) {       \n    \toutColor += vec4(1,0,1,1);       \n    }            \n   \n   \t// inner[i], outer[i], outer[i+1]    \n    if (sdTriangle(a, c, d, uv) <= 0.0) {       \n    \toutColor += vec4(1,1,0,1);       \n    }        \n    return outColor;\n}\n\nvec4 drawArm(vec2 centre, vec2 uv, vec2 left, vec2 right, float radius, int division)\n{\n    vec2 left_i = getRadialPoint(centre, left, radius);\n    \n    vec2 right_i = getRadialPoint(centre, right, radius);\n    \n    vec2 top_0 = left;\n    vec2 inside_0 = left_i;\n    \n    vec4 outColor = vec4(0,0,0,0);\n\n    float offset = 1. / float(division);\n    for (int i = 1; i < division; i += 1)\n    {\n        vec2 top_1 = getInnerPoint(left, right, float(i) * offset);  \n        vec2 inside_1 = getRadialPoint(centre, top_1, radius); \n\t\toutColor += drawColouredQuad(uv, top_0, inside_0, inside_1, top_1);\n        top_0 = top_1;\n        inside_0 = inside_1;\n    } \n\n    \n    outColor += drawColouredQuad(uv, top_0, inside_0, right_i, right);\n    return outColor;\n}\n\nvec4 drawCorner3(vec2 centre, vec2 uv, vec2 right, vec2 mid, vec2 left, float radius, int noOfQuads)\n{ \n    // QUAD 1\n    return drawArm(centre, uv, left, mid, radius, noOfQuads / 2)\n   \t + drawArm(centre, uv, mid, right, radius, noOfQuads / 2);        \n   // return outColor;\n}\n\nvec4 drawDot(vec2 pt, vec2 uv)\n{\n    vec2 diff = uv - pt;\n    if (dot(diff, diff) <= 0.005)\n    {\n        return vec4(0,1,0,1);\n    }\n    return vec4(0,0,0,0);\n}\n\nvec4 drawArcOnCorner(vec2 centre, vec2 uv, in vec2[MAX_N] points,\n                     int left, int mid, int right,\n                     float innerRadius, int division)\n{\n    vec2 mid_l = getMidpoint(points[mid], points[left]);\n    vec2 mid_r = getMidpoint(points[mid], points[right]);      \n        \n    return drawCorner3(centre, uv, mid_r, points[mid], mid_l, innerRadius, division);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // SCREEN CORRECTION TO SQUARE\n    float fov = (iResolution.y / iResolution.x);\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= 0.5;\n    uv.y *= fov;\n    \n    // SCALE \n    uv *= UNIT_SCALE;  \t     \n    \n    float radius = 2.0;        \n    \n    float halfHeight = radius * sqrt(3.)/4.;\n    float halfWidth = radius * .5;    \n    \n    vec2 a =  vec2(0.,  halfHeight); \n    vec2 b = vec2(-halfWidth, -halfHeight);    \n    vec2 c = vec2(halfWidth, -halfHeight);  \n\n    // INTERSECTION OF MIDPOINT\n    // CENTRE CAN BE ANYTHING\n    vec2 centre = vec2(0.);  \n    \n    vec2 mid_a_b = getMidpoint(a, b);\n    vec2 mid_b_c = getMidpoint(b, c);\n    vec2 mid_c_a = getMidpoint(c, a);     \n    \n    // TOP: subdividing sections by value within int array           \n    float gapTimeStep = mod(iTime, SUBDIVISION_LOOP_IN_SECS) / SUBDIVISION_LOOP_IN_SECS;         \n\n    int division = sections[int(gapTimeStep * float(NO_OF_DIVISIONS))];  \n   // int division = 6;\n    float innerRadius = MID_POINT + RANGE_OF_TRIG_FUNC * sin( FREQUENCY * TWO_PI * iTime);    \n    \n    \n    //fragColor += drawCorner3(centre, uv, mid_c_a, a, mid_a_b, innerRadius, division / 3);\n    //fragColor += drawCorner3(centre, uv, mid_a_b, b, mid_b_c, innerRadius, division / 3);\n    //fragColor += drawCorner3(centre, uv, mid_b_c, c, mid_c_a, innerRadius, division / 3);    \n    \n    // 2ND from top: switching color values within array\n    float timeStep = mod(iTime, LOOP_IN_SECS) / LOOP_IN_SECS;                     \n    \n    int count = MIN_N + int(timeStep * float(MAX_N - MIN_N + 1));\n    //int count = 4;\n    \n    float angleOffset = TWO_PI / float(count);\n    \n    float angle = 0.;  \n\n    if (count % 2 == 0)\n    {\n        // 45 degrees\n        angle += angleOffset / 2.;\n    }\n    \n    fragColor += drawDot(centre, uv);\n    \n    // DRAW CIRCLES ON POLYGON CORNERS\n    vec2 points[MAX_N];\n    for (int i = 0; i < count; i++)\n    {       \n        points[i] = vec2(sin(angle), cos(angle));\n        fragColor += drawDot(points[i], uv);\n        angle += angleOffset;\n    }    \n    \n    // DRAW FACES FOR EACH CORNER\n    int leftIndex = count - 1;\n    int midIndex = 0;\n    int rightIndex = 1;\n    for (int i = 0; i < count - 1; i++)\n    {       \n       // vec2 left = points[leftIndex];\n       // vec2 mid = points[midIndex];\n       // vec2 right = points[rightIndex];\n        \n    \t//vec2 mid_l = getMidpoint(mid, left);\n    \t//vec2 mid_r = getMidpoint(mid, right);      \n        \n        fragColor += drawArcOnCorner(centre, uv, points, leftIndex, midIndex, rightIndex, innerRadius, division);\n        leftIndex = i;\n        midIndex++;\n        rightIndex++;            \n    }        \n\n    rightIndex = 0;\n    fragColor += drawArcOnCorner(centre, uv, points, leftIndex, midIndex, rightIndex, innerRadius, division);    \n}","name":"Image","description":"","type":"image"}]}