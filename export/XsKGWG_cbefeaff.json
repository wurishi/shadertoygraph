{"ver":"0.1","info":{"id":"XsKGWG","date":"1456179578","viewed":3210,"name":"poor hydraulic erosion","username":"stb","description":"You may have to reset the time when this is first loaded, due to image downloading.\nShould now look better in fullscreen.\nMouse to move sun; press r to restart with new landscape.","likes":87,"published":1,"flags":48,"usePreview":0,"tags":["2d","simulation","water","landscape","map","25d","bump","height","land","filling","erosion","basin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t2D(x, y) texture(iChannel0, fract(uv-vec2(x, y)/res))\n\nfloat landMap(vec3 p) {\n    return p.z - texture(iChannel0, fract(p.xy)).r;\n}\n\nfloat waterMap(vec3 p) {\n    return p.z - (texture(iChannel0, fract(p.xy)).r+texture(iChannel0, fract(p.xy)).g);\n}\n\nfloat getProx(vec3 p, float dist) {\n    vec3 o = vec3(-dist, dist, 0.);\n    vec2 res = .01 * iResolution.xy;\n\treturn\n    \t(\n            landMap(p+o.xzz/res.xyy) + landMap(p+o.yzz/res.xyy) +\n\t\t\tlandMap(p+o.zxz/res.xyy) + landMap(p+o.zyz/res.xyy) +\n\t\t\tlandMap(p+o.zzx/res.xyy) + landMap(p+o.zzy/res.xyy)  \n\t\t) / dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord.xy / res;\n    \n    float lh = t2D(0.,  0.).r;\n    float wv = t2D(0.,  0.).g;\n    \n    vec3 landCol  = .65 * lh * vec3(.8, .5, .2);\n    vec3 waterCol = max(0., 1.-16.*wv) * vec3(.2, .4, .7);\n    vec3 outCol;\n    \n    vec3 lightPos = normalize(vec3(4.*(iMouse.xy/res-.5), 1.));\n    \n    vec3 p = vec3(uv, lh);\n    \n    vec3 o = vec3(-1., 1., 0.);\n    vec3 landNorm =\n        vec3(\n\t\t\tlandMap(p-o.xzz/res.xyy)-landMap(p-o.yzz/res.xyy),\n\t\t\tlandMap(p-o.zxz/res.xyy)-landMap(p-o.zyz/res.xyy),\n\t\t\tlandMap(p-o.zzx/res.xyy)-landMap(p-o.zzy/res.xyy)\n\t\t);\n    \n    vec3 waterNorm =\n        vec3(\n\t\t\twaterMap(p-o.xzz/res.xyy)-waterMap(p-o.yzz/res.xyy),\n\t\t\twaterMap(p-o.zxz/res.xyy)-waterMap(p-o.zyz/res.xyy),\n\t\t\twaterMap(p-o.zzx/res.xyy)-waterMap(p-o.zzy/res.xyy)\n\t\t);\n    \n    // cheap ao\n    landCol += .1 * getProx(p, .02);\n    landCol += .3 * getProx(p, .07);\n    \n    // add diffuse reflection to landscape\n    landCol += .45 * max(0., dot(normalize(landNorm), lightPos));\n    \n    // mix bump-mapped land and unmodified water color\n    waterCol = mix(waterCol, landCol, .5);\n    \n    // add specular reflection to water\n    vec3 ref = reflect(-lightPos, normalize(waterNorm));\n    waterCol +=  .5 * pow(max(0., dot(normalize(waterNorm), ref)), 8.);\n    \n    // mix land color with water color based on water volume\n    outCol = mix(landCol, waterCol, step(4./65535., wv));\n    \n\tfragColor = vec4(outCol, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// hash without sine - the best choice for adding rain :)\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// multiscale noise from image\nfloat getLand(vec2 p) {\n    float f = 0.;\n    for(int i=1; i<=16; i++) {\n        float pwv = pow(1.1, float(i));\n        f += .25 / pwv * texture(iChannel1, p*pwv+.1*mod(iDate.w, 1000.)+.2+.2*float(i)).r;\n    }\n    return f;\n}\n\n#define t2D(x, y) texture(iChannel0, fract(uv-vec2(x, y)/res))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord.xy / res;\n    \n    vec4 buf[9];\n    buf[0] = t2D(0.,  0.);\n    buf[1] = t2D(1.,  0.);\n    buf[2] = t2D(-1., 0.);\n    buf[3] = t2D(0.,  1.);\n    buf[4] = t2D(0., -1.);\n    buf[5] = t2D(1.,  1.);\n    buf[6] = t2D(-1., 1.);\n    buf[7] = t2D(1., -1.);\n    buf[8] = t2D(-1.,-1.);\n    \n    float lhc = buf[0].r;  // land height (this cell)\n    float wvc = buf[0].g;  // water volume (this cell)\n    float whc = wvc + lhc; // water height (this cell)\n    \n    // land height & water volume (outputs)\n    float lh, wv;\n    \n    // first frame operations\n    if(iFrame<10 || texture(iChannel3, vec2(82.5/256., .2)).r>0.) {\n        wv = 0.;\n        \n        // texture scale\n        //vec2 ts = .125 * vec2(res.x/res.y, 1.);\n        float ts = 3000.;\n        vec2 o = vec2(-.5, .5);\n        vec2 suv = smoothstep(0., 1., uv);\n        \n        // tiled landscape\n        lh =\n            mix(\n                mix(\n                    getLand((fragCoord-o.xx*res)/ts),\n                    getLand((fragCoord-o.yx*res)/ts),\n                    suv.x\n                ),\n                mix(\n                    getLand((fragCoord-o.xy*res)/ts),\n                    getLand((fragCoord-o.yy*res)/ts),\n                    suv.x\n                ),\n                suv.y\n            );\n    }\n    // simulation\n    else {\n\t\tlh = buf[0].r;\n        wv = buf[0].g;\n        for(int i=1; i<9; i++) {\n            float lhi = buf[i].r;  // land height (neighboring cell)\n            float wvi = buf[i].g;  // water volume (neighboring cell)\n            float whi = wvi + lhi; // water height (neighboring cell)\n            float wslope = whi - whc; // water slope\n            float lslope = lhi - lhc; // land slope\n            \n            // normalize corner weights for slopes\n            if(i>4) {\n                wslope /= sqrt(2.);\n                lslope /= sqrt(2.);\n            }\n            \n            if(wvc>0. && wslope<0.) {\n                \n                // give water\n                wv += wslope / 9.;\n                \n                // basic erosion\n                lh += .003 * wslope;\n            }\n            \n            if(wvi>0. && wslope>0.) {\n                \n                // take water (currently less than it should, to help keep water from sticking to slopes)\n                wv += wslope / 12.;\n                \n                // basic erosion\n                lh -= .003 * wslope;\n            }\n            \n            // give & take land base on water slope (help smooth things out)\n            lh += .001 * wslope;\n            \n            // collapse steep land slopes (loss only)(helps widen gullies)\n            if(lslope < -.002-.004*hash12(uv))\n                lh += lslope / 9.;\n        }\n        \n        // add land based on water volume\n        //lh += .001 * wv;\n        \n        // 'evaporation'\n        //wv -= 1. / 65535.;\n        \n        // 'rain'\n        if(hash12(mod(uv+iTime/100., 100.))>.5)\n            wv += 4. / 65535.;\n    }\n    \n    fragColor = vec4(lh, .98*wv, 0., 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}