{"ver":"0.1","info":{"id":"XX2cRh","date":"1726945497","viewed":88,"name":"Polar Grid Raymarch study","username":"Elsio","description":"Eu comecei arrancando toda a beleza do shader do mestre @shane. Eu vivo fazendo isso. \nMas as vezes fica interessante publicar pois a técnica escondida por trás de toda aquela beleza, na minha opinião, precisa ser esmiuçada e disseminada. ","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","grid","geometry","polar","traversal"],"hasliked":0,"parentid":"XXscRs","parentname":"Polar Grid Raymarch Traversal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define h21(p) fract(sin(dot(p, vec2(1456.4, 2179.45)) * 112.))\n#define rot(a) mat2(cos(a +  PI * vec4(0, 1.5, .5, 0)))\n#define cor(a) cos(h21(a) * 2. + vec4(2, 3, 4, 0) / 2.5) * .6 + .6\n#define t iTime\n#define FAR  20.\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\nvec2 gRd, id;\nfloat gCD, top;\nfloat spc = 1. / 3.;\n\nfloat smax(float a, float b) {\n    float k = .04;\n    float f = max(0., 1. - abs(b - a) / k);\n    return max(a, b) + k * .25 * f * f;\n}\n\n\nfloat opExtrusion(float sdf, float pz, float h) {\n    vec2 p = vec2(sdf, abs(pz - h / 2.) - h / 1.94);\n    return min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\n\nfloat circInters(vec2 ro, float ra) {\n    float b = dot(ro, normalize(gRd));\n    vec2  qc = ro - b * normalize(gRd);\n    float h = ra * ra - dot(qc, qc);\n    \n    if(h < 0.) return 1e8;\n    \n    h = sqrt(h);\n    vec2 pI = vec2(-b - h, -b + h);\n    \n    return pI.y < 0.\n                ? 1e8\n                : pI.x < 0.\n                       ? pI.y\n                       : pI.x;\n}\n\n\nfloat tower(vec2 q, float spc, float aNum){\n    float d =  abs( // paredes\n                   mod(\n                       length(q) - spc / 2.,\n                       spc\n                   ) \n                   - spc / 2.\n               ) - spc / 2.1 ;\n    \n    // envolve\n    if(aNum > 1.) {\n        vec2 a = rot(PI / aNum - id.y) * q,\n             b = rot(-PI / aNum - id.y) * q;\n\n        d = smax(d, max(-a.y, b.y));\n    }\n    \n    // fendas\n    if(h21(id + 1.) > .5) \n        d = max(d, -d - .12);\n    \n    return d;\n}\n\nfloat rayLine(vec2 ro, vec2 n) {\n    float dn = dot(-ro, n) / dot(gRd, n);\n    return dn < 0. ? 1e8 : dn;\n}\n\n// traversal distance limit (from @shane)\nvoid gcd(vec2 p, float aNum, vec2 id, mat2 gRot){\n    vec2 n = gRot \n               * cos(id.y - PI / aNum + vec2(PI / 2., 0));\n    gCD = \n        min(\n            min(\n                circInters(p, (id.x + .5) * spc),\n                circInters(p, (id.x - .5) * spc)\n            ),\n            min(\n                rayLine(p, n),\n                rayLine(p, rot(TAU / aNum) * n)\n            )\n        ) + .0015;\n}\n\n\nfloat map(vec3 p) {\n    float d, aNum, hight;\n    vec2 q = p.xz;\n    \n    id.x = round(length(q) / spc);\n    \n    mat2 gRot = rot(tanh(cos(id.x * 1.5 + t) * 5.) * .25);\n    \n    q *= gRot;\n    \n    aNum = max(id.x / spc, 1.);\n    \n    id.y = (\n               floor(\n                   mod(atan(q.y, q.x), TAU) * aNum / TAU\n               ) + .5\n           ) * TAU / aNum;\n    \n        \n    gcd(p.xz, aNum, id, gRot);\n    \n               \n    hight = length(\n                tanh(\n                    cos(t * (id.y + vec2(0, 11)) * .1) * 8.\n                ) * .5 + 1.\n            );\n    \n    top = p.y - hight;\n    \n    d = tower(q, spc, aNum);\n        \n    return opExtrusion(d, p.y, hight)\n                + max(d, -.03) * .4\n                - tanh(cos(d * 29.) * 25.) * .008;\n}\n\nvec3 normal(vec3 p) {\n    vec3 e = vec3(.001, 0, 0);\n    vec3 v = vec3(\n                 map(p - e.xyy),\n                 map(p - e.yxy),\n                 map(p - e.yyx)\n             ) - map(p);\n    return normalize(-v);\n}\n\n\nfloat march(vec3 ro, vec3 D) {\n    gRd = D.xz;\n    \n    float s, d, iter = 128., i;\n    while(i++ < iter) {\n        s = map(ro + d * D);\n        if(s < .001 || d > FAR) break;\n        d += min(s * .9, gCD);\n    }\n    \n    return min(d, FAR);\n}\n\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n         u = (u - r * .5) / r.y;\n    \n    vec3 p = vec3(0, 3.5, -4),\n         rd = normalize(vec3(u, 2.5 + cos(t) * .5));\n    \n    rd.zy *= rot(cos(t * .21) * .1 + .45);\n    rd.zx *= rot(sin(t * .37) * .17);\n    p += cos(t * vec3(1, 8, 4) / 10.) * vec3(6, 1, 6) / 4.;\n    \n    float d = march(p, rd);\n    vec3 n;\n    \n    o = vec4(.2);\n    if(d < FAR) {\n        n = normal(p + d * rd);\n        if(top > 0.) o = cor(id);\n    }\n    \n    o = pow(o * length(sin(n * 2.4) * .45 + .45), vec4(.45));\n}","name":"Image","description":"","type":"image"}]}