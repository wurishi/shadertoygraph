{"ver":"0.1","info":{"id":"wtKSzD","date":"1582846567","viewed":635,"name":"Underwater world","username":"maksy","description":"Underwater world","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["voronoi","terrain","caustics","underwater","godray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Resources:\n * https://www.shadertoy.com/view/4ljXWh\n * https://www.youtube.com/watch?v=l-07BXzNdPw\n */\n#define PI 3.141592\n#define MAX_STEPS 250\n#define MAX_DIST 100.0\n#define SURF_DIST .001\n\n#define GROUND 0\n#define WATER 1\n\nstruct Obj {\n\tint type;\n    float dist;\n    vec3 hitPos;\n};\n\n//2D signed hash function:\nvec2 Hash2(vec2 P) {\n\treturn 1.-2.*fract(cos(P.x*vec2(91.52,-74.27)+P.y*vec2(-39.07,09.78))*939.24);\n}\n\n//2D Simplex gradient noise.\nfloat Simplex(vec2 P) {\n    //Skewing and \"unskewing\" constants as decribed here: https://en.wikipedia.org/wiki/Simplex_noise\n    #define S (sqrt(.75)-.5)\n\t#define G (.5-inversesqrt(12.))\n   \n    //Calculate simplex cells.\n    vec2 N = P+S*(P.x+P.y);\n    vec2 F = floor(N);\n    vec2 T = vec2(1,0)+vec2(-1,1)*step(N.x-F.x,N.y-F.y);\n    \n    //Distance to the nearest cells.\n    vec2 A = F   -G*(F.x+F.y)-P;\n    vec2 B = F+T -G*(F.x+F.y)-G-P;\n    vec2 C = F+1.-G*(F.x+F.y)-G-G-P;\n    \n    //Calculate weights and apply quintic smoothing.\n    vec3 I = max(.5-vec3(dot(A,A),dot(B,B),dot(C,C)),0.);\n    I = I*I*I*(6.*I*I,-15.*I+10.);\n    I /= dot(I,vec3(1));\n    \n    //Add up the gradients.\n    return .5+(dot(Hash2(F),A)*I.x+\n        \t   dot(Hash2(F+T),B)*I.y+\n        \t   dot(Hash2(F+1.),C)*I.z);\n}\n\n\n/*\n * Fractal Brownian Motion adds different iterations of noise (octaves) \n * by incrementing the frequencies in regular steps and decrease the amplitude \n * of the noise. It makes the noise more granular and add more fine details.\n*/\nfloat fbm(in vec2 uv, int octaves, float octaveWeight) {\n    \n    float h = 0.; // height\n    float m = 0.4; // octave multiplier\n    \n    for (int i = 0; i < octaves; i++) {\n\t\th += octaveWeight * Simplex(uv * m);\n        octaveWeight *= .4;\n        m *= 2.0;\t         \n    }\n    return h;\n}\n\nObj getDist(vec3 p) {\t\n       \n    // distance to the ground\n    float height = fbm(vec2(p.x, p.z), 2, 0.4); \n    height = fbm(vec2(p.x, p.z), 6, 1.5);\n    float planeDist = p.y - height-3.;\n   \n    Obj obj = Obj(GROUND, planeDist, p);\n\n    return obj;\n}\n\nObj rayMarch(vec3 ro, vec3 rd) {\n\t\n    float t = 0.0;\n    \n    Obj hitObj = Obj(WATER, t, ro + rd);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \t\n        vec3 p = ro + rd*t;\n        hitObj = getDist(p);      \n        t += hitObj.dist;\n        \n        // the ray has marched far enough but hit nothing. \n        // Render the pixel as a part of the sky.\n        if (t > MAX_DIST) {\n        \thitObj = Obj(WATER, t, p);\n            break;\n        }\n\n        // the ray has marched close enough to an object\n        if (abs(hitObj.dist) < SURF_DIST * (1.0+t)) {\n            hitObj = Obj(hitObj.type, t, p);\n        \tbreak;\n        }\n        \n        hitObj.dist = t;\n    }\n    \n    return hitObj;\n}\n\nvec3 getNormal(vec3 p) \n{\n\tfloat d = getDist(p).dist;\n    \n    // use offset samples to compute normal\n    vec2 e = vec2(.01, 0.);    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).dist,\n        getDist(p-e.yxy).dist,\n        getDist(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 lightPos) {\n    \n    // compute the light vector and its normal   \n    lightPos.xz += vec2(sin(iTime*0.5), cos(iTime*0.5))*1.4;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    // calculate diffuse lightning\n    // dot product gives values between -1 to 1 hence the range\n    // is clamped to 0 to 1\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    return dif;\n}\n\n// calculates the intersection of the given plane and ray\nvec3 intersectPlane(vec3 ori, vec3 dir, vec3 planePos) {\n    \n    vec3 planeNormal = vec3(0, 1, 0);\n    \n\tfloat a = dot(dir, planeNormal);\n   \n    float distToPlane = dot(ori-planePos, planeNormal);\n    vec3 intersectPt = ori + dir*abs(distToPlane/a);\n    \n    return intersectPt;\n}\n\n// ############################\n// # CAUSTICS \n// ############################\nvec2 N22(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);\n}\n\nfloat voronoi(vec2 p) {\n\n    // divide the screen into a grid\n    p *= 3.;\n    // this is the id of a grid cell. X and y go from -3 to 3.\n    vec2 id = floor(p);     \n    // Coordinates inside a grid cell\n    vec2 gv = fract(p);\n    \n    float minDist = 9.;\n    \n    // loop through 9 grid cells around the point and check \n    // which is the closest cell\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 n = N22(id+offset);\n            // multiply because gv goes from -0.5 to .0.5\n            vec2 p = .5+0.5*sin(n*iTime*4.);\n      \n            vec2 r = offset + p - gv;\n            float d = dot(r, r);\n            \n            if (d < minDist) {\n            \tminDist = d;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\n// creates fake caustics with voronoi patterns and fBMs\nfloat caustics(vec2 p) {\n    float v = 0.0;\n    float a = 0.4;\n    for (int i = 0; i<3; i++) {\n        v += voronoi(p)*a;\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  \n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nfloat godRays(vec3 rayDir) {\n \t\n    vec3 col = vec3(0.);\n    float y = rayDir.y * 0.5 + 0.5;\n    \n    float a = atan(rayDir.x, rayDir.z);\n    \n    float rays = sin(a*28.+iTime) * sin(a*27.-iTime) * sin(a*22.);\n    rays = max(0., rays);\n    // cut the lower part of the rays\n    rays *= smoothstep(0.2, 1., y);\n    // decrease brightness\n    rays *= smoothstep(.7, 0., y);\n    \n    return rays+0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // normalize coordinates ranging from -0.5 to 0.5 and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n   \n    vec3 GROUND_COLOR = vec3(0.25);\n    vec3 HORIZON_COLOR = vec3(0.0, 0.05, 0.2);\n    vec3 LIGHT_DIR = vec3(1, 5, -4);\n    \n    // camera\n    vec3 camPos = vec3(3.0*sin(iTime*0.25), 7.0, -1.*iTime);\n    camPos = vec3(10.0*sin(iTime*0.2), 7., -9.);\n    //camPos = vec3(3., 6., -9.);\n    \n    vec3 camTarg = vec3(1., 4., 4.);\n    mat3 camMat = lookAt(camPos, camTarg, 0.0);\n    vec3 rayDir = normalize(camMat * vec3(uv.xy, 1.0));\n   \n    vec3 col = vec3(1.0);\n    \n    Obj hitObj = rayMarch(camPos, rayDir);\n   \t\n    if (hitObj.type == WATER) {\n    \n      col = mix(vec3(1.), HORIZON_COLOR, pow(1.0 - pow(rayDir.y, 4.), 50.0));\n    \n    } else if (hitObj.type == GROUND) {\n      \n        float dif = getLight(hitObj.hitPos, LIGHT_DIR) * hitObj.hitPos.y * 0.26;\n        col = vec3(dif);\n                     \n        float caust = caustics(uv)*3.5;       \n        col *= clamp(caust, 0.5, 1.);       \n        \n        // Use Beer's law for calculating attenuation\n\t\tvec3 attenuation = exp(-vec3(0.3, 0.15, 0.08)*hitObj.dist);\n        col = mix(HORIZON_COLOR, col, attenuation);\n    }\n    \n    float godRay = godRays(rayDir);\n  \n    vec3 lightColor = mix(vec3(1.), col, 1.0 - uv.y);\n    vec3 finalColor = mix(col, lightColor, godRay);\n    \n    col = pow(finalColor,vec3(.454545));\n \tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}