{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// the size of each dot, in UV space\n#define BIT_SIZE 0.0125\n\n// used when controlling scale with the mouse\n#define SCALE_MIN BIT_SIZE / 2.0\n#define SCALE_MAX 0.0625\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // let mouse y control scale if mouse button pressed\n    float scale = BIT_SIZE;\n    if( iMouse.z > 0.0 )\n        scale = iMouse.y / iResolution.y * (SCALE_MAX - SCALE_MIN) + SCALE_MIN;\n    \n    // get the uv coordinate of our pixel.\n    // Make UV's square and scroll the image to the left, starting at the right\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x = max(0.0,uv.x + iTime - iResolution.x / iResolution.y);\n        \n    // put it up near the middle of the screen and bail out below the x axis.\n    uv.y -= 0.5;\n    if (uv.y < 0.0)\n        fragColor = vec4(vec3(0.0),1.0);\n    \n\t// if our column number (y) has our row bit set (x), then\n    // set the color to white, else set it to black\n    float row = floor(uv.y / scale);\n    float col = floor(uv.x / scale);\n    float color=mod(floor(col/pow(2.0,row)),2.0);\n    \n    // make each bit into an anti aliased circle\n    float rx = fract(uv.x / scale) - 0.5;\n    float ry = fract(uv.y / scale) - 0.5;\n    float dist = sqrt(rx*rx+ry*ry);\n    color *= smoothstep(0.6,0.3,dist);\n    \n    // return the color\n    fragColor = vec4(vec3(color),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lssXDs","date":"1408065064","viewed":715,"name":"1, 2, 3 fractal","username":"demofox","description":"Creating a fractal is as easy as 1,2,3 (;\nVisualization of counting in binary.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""}}