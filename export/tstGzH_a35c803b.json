{"ver":"0.1","info":{"id":"tstGzH","date":"1567838398","viewed":232,"name":"Menger Space","username":"senzheng","description":"A Menger Space","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","space","menger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Hit {\n    float d;\n    vec2 uv;\n    vec3 col;\n    float ref;\n    float spe;\n    float rough;\n    float lightD;\n    vec3 lightCol;\n    float lightStrength;\n};\n    \nvec3 ro, lookAt, camup;\n#define MAX_RAYMARCHING_COUNT 250\n#define PRECISION 0.00001\n#define FAR 20.\n#define mouse (iMouse.xy / iResolution.xy)\n#define time iTime\n#define PI 3.1415926\n\nvec2 rotate(vec2 v, float a) {\n    return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\nfloat rand(vec3 p) {\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n    return dot(abs(p), vec3(1.0));\n}\nvec3 hash( vec3 p )\n{\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    \n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nvec3 noise3(vec3 p)\n{\n    return vec3(noise(p), noise(p + vec3(31.54, 72.4, 54.425)), noise(p + vec3(156.456, 87.45, 99.45)));\n}\nfloat fbm(in vec3 x)\n{\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<2; i++)\n    {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.0;\n    }\n    return rz;\n}\nvec3 fbm3(in vec3 x)\n{\n    vec3 rz = vec3(0.);\n    float a = .45;\n    for (int i = 0; i<3; i++)\n    {\n        rz += noise3(x)*a;\n        a*=.3;\n        x*= 4.;\n    }\n    return rz;\n}\n\n// color\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//sdf\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCross2( vec3 p )\n{\n  float da = udRoundBox(p, vec3(99999, 1.0, 1.0), 0.2);\n  float db = udRoundBox(p.yzx, vec3(1.0-0.05, 99999, 1.0-0.05), 0.);\n  float dc = udRoundBox(p.zxy, vec3(1.0, 1.0, 99999), 0.1);\n  return min(da, min(db, dc));\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n// OP\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nHit opUnion( Hit h1, Hit h2 ) {  \n    float d1 = h1.d;\n    float d2 = h2.d;\n    float resd = min(d1,d2); \n    if (resd == d1) return h1;\n    else return h2;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d2,d1); }\n\nHit opSubtraction( Hit h1, Hit h2 ) {  \n    float d1 = h1.d;\n    float d2 = h2.d;\n    float resd = max(-d2,d1); \n    return Hit(resd, h1.uv, h1.col, h1.ref, h1.spe, h1.rough, h1.lightD, h1.lightCol, h1.lightStrength);\n}\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n//------------------------------------------------------------------\n\nmat3 setCamera(vec3 ro, vec3 lookAt, vec3 cp) {\n    vec3 cw = normalize(lookAt-ro);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat sponge(vec3 p, float factor, float phiFactor, float reverseYFactor){\n    vec3 backuppos = p;\n    float r = length(p);\n    float theta = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    p = vec3(r*sin(theta)*cos(phi*phiFactor),\n               r*sin(theta)*sin(phi*phiFactor),\n               r*cos(theta));\n    float yfactor = mix(1.0, p.y, factor);\n    p *= yfactor;\n    \n    float dscale = 1.0 / phiFactor / yfactor / (r+1.0) * phi * 0.25;\n    float d = sdBox(p, vec3(1.0)) * dscale ;\n    \n    float scale = 1.0;\n    for (int i = 0 ; i < 4 ; i++) {\n        vec3 a = mod(p*scale+1.0, 2.0) - 1.0;\n        float c = sdCross2(a * 3.0) / scale * dscale;\n        scale *= 3.0;\n        d = opSubtraction(d, c);\n    }\n    \n    d = opIntersection(d*1.0, sdRoundBox(backuppos, vec3(1.), 0.1));\n    return d;\n}\n\nvec3 distortSpace(vec3 p) {\n    vec3 backupPos = p;\n    \n    p.xy = rotate(p.xy, -0.3*time + p.z);\n    return p;\n}\n\n\nHit innerspace(vec3 p) {\n    p = distortSpace(p);\n    p = mod(p, vec3(3.0)) - 1.5;\n    float d = sponge(p, 1.0, 1.0, 0.0);\n    \n    return Hit(d, vec2(0), vec3(0.6, 0.65, 0.7), 0.0, 0.5, 0.0, d, vec3(0), 0.0);\n}\n\nHit myLight(vec3 p) {\n    p = distortSpace(p);\n    //p.y += sin(p.z + p.x +time)*0.5;\n    p += vec3(0.5);\n    p = mod(p, vec3(1.6, 1.6, 100.)) - vec3(0.8, 0.8, 50.0);\n    float d = sdBox(p, vec3(0.001, 0.001, 100));\n    \n    return Hit(d, vec2(0.0), vec3(1.0), 0.0, 0.0, 0.0, d, vec3(0.2, 0.6, 1.0), 1.0);\n}\n\nHit map2(vec3 p) {\n    return opUnion(innerspace(p), myLight(p));\n}\n\nvec3 calcuNormal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n    return normalize(e.yxx*map2(p + e.yxx).d + e.xxy*map2(p + e.xxy).d + \n                     e.xyx*map2(p + e.xyx).d + e.yyy*map2(p + e.yyy).d );   \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map2( ro + rd*t ).d;\n        res = min( res, 5.0*h/t );\n        t += clamp( h, 0.02, 0.2 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.2, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map2( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec4 render(vec3 ro, vec3 rd, vec2 samplepos) {\n    Hit hitdata;\n    float t = 0.1 + 0.2 * texture(iChannel0, samplepos*100.0+time).r;\n    float told = t, mid, dn;\n    float d = map2(rd*t + ro).d;\n    float sgn = sign(d);\n    \n    vec3 col = vec3(1.0, 0.0, 0.0);\n    vec3 bgCol = vec3(0.1);\n    bgCol = vec3(0.9, 0.4, 0.1)*1.5;\n    \n    // light source\n    vec3 lp = ro;\n    vec3 atm = vec3(0.0);\n    float att = 1.0;\n    \n    float forwardstep = FAR / float(MAX_RAYMARCHING_COUNT);\n    \n    for (int i = 0 ; i < MAX_RAYMARCHING_COUNT ; i++) {\n        \n        vec3 sp = ro + rd*t;\n        vec3 sundir = lp - sp;\n        float sundist = length(sundir);\n        vec3 ld = normalize(sundir);\n        \n        hitdata = map2(rd*t + ro);\n        d = hitdata.d;\n        \n        \n        float illum = 0.0;\n        illum = 100.0 / (hitdata.lightD*hitdata.lightD+0.0001);\n        atm += illum * 0.00005 * att * hitdata.lightCol * hitdata.lightStrength;\n        \n        if (sign(d) != sgn || d < PRECISION) {\n        \n            if (sign(d) != sgn) {\n                hitdata = map2(rd*told + ro);\n                dn = sign(hitdata.d);\n                vec2 iv = vec2(told, t);\n                \n                for (int j = 0 ; j < 8 ; j++) {\n                    mid = dot(iv, vec2(.5));\n                    //float d = map2(rd*mid + ro);\n                    hitdata = map2(rd*t + ro);\n                    d = hitdata.d;\n                    if (abs(d) < PRECISION) break;\n                    iv = mix(vec2(iv.x, mid), vec2(mid, iv.y),step(0.0, d*dn));\n                }\n                t = mid;\n            }\n            \n            vec3 nor = normalize(calcuNormal(sp));\n            //nor = normalize(nor + 0.5*tex3D( iChannel1, sp*1.0, nor ));\n   \n            float shd = calcSoftshadow( sp, ld, 0.02, FAR );\n            float occ = calcAO( sp, nor );\n            \n            \n            vec3 hal = normalize( lp - rd );\n            float amb = clamp( 0.3+ 0.7*nor.y, 0.0, 1.0 );\n            float dif = max( dot( ld, nor ), 0.0);\n            float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 64.0)*dif;\n            \n            \n            // surface color\n            col = hitdata.col;\n            vec2 uv = hitdata.uv;\n            \n            vec3 lin = vec3(1.) * dif * shd;\n            lin += 0.8*amb*vec3(1.0)*occ;\n            lin += hitdata.spe*spe*vec3(1., 0.4, 0.2)*occ;\n            col *= lin;\n            \n            // Fog\n            col = mix(col, bgCol, smoothstep(1., FAR, pow(t,1.2)));\n            \n            break;\n        } else if (t >= FAR || i+1 == MAX_RAYMARCHING_COUNT) {\n            col = bgCol;\n            break;\n        }\n        \n        att *= 0.98;\n        \n        told = t;\n        t += min(d, forwardstep*1.0);\n        t = min(FAR, t);\n    }\n    // Light\n    col += atm*0.2;\n    col = pow(col, vec3(1.3));\n    \n    return vec4(col, t);\n}\n\nvoid campath(float t, out vec3 cam,  out vec3 lookAt,  out vec3 camup) {\n    cam = vec3(sin(t)*0.5, cos(t)*0.5, t*0.6);\n    lookAt = cam + vec3(0.0, 0.0, -0.1);\n    camup = vec3(cos(t*0.5), sin(t*0.5), 0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    campath(time, ro, lookAt, camup);\n    mat3 viewMat = setCamera(ro, lookAt, camup);\n    \n    vec3 rd = viewMat * normalize(vec3(p, 0.5));\n    vec4 col = render( ro, rd, p );\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}