{"ver":"0.1","info":{"id":"DdKXzh","date":"1681651941","viewed":186,"name":"Satisfying Jigsaw ","username":"shau","description":"Emulating jigsaw loop by Wren from Corridor Crew. ","likes":18,"published":1,"flags":32,"usePreview":1,"tags":["loop","jigsaw","satisfying"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j=ZERO; j<80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec2 uv = U / R;\n    C = vec4(vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.).xyz, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nvec4 position(float startTime, float x)\n{\n    const float jh = J1+J2*2.0+J3*2.0;\n    float z = 40.0 - S(0.0,2.0,AT - startTime)*40.0;\n    float y = jh - clamp(AT - startTime - 2.0,0.0,2.0)*jh;\n    float r = S(0.0,7.0,z*0.1)*z*0.5;\n    return vec4(x,y,z,r);\n}\n\nvec4 metadata(float geometryId)\n{\n    vec3 col = vec3(0.0,0.0,0.0);\n    if (geometryId==1.0) col = vec3(1.0,0.0,0.0);\n    if (geometryId==2.0) col = vec3(0.0,0.0,1.0);\n    if (geometryId==3.0) col = vec3(0.0,1.0,0.0);\n    if (geometryId==4.0) col = vec3(1.0,0.5,0.0);\n    return vec4(col,geometryId);\n}\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec4 pos1 = vec4(0.0), meta1 = vec4(0.0),\n         pos2 = vec4(0.0), meta2 = vec4(0.0),\n         light = vec4(0.0);\n    \n    light.x = S(0.8,0.5,fract(AT*0.25));\n    \n    if (AT<4.0)\n    {\n        pos1 = position(-4.0,0.0);\n        meta1 = metadata(1.0);\n        pos2 = position(0.0,2.0);\n        meta2 = metadata(2.0);        \n    }\n    else if (AT<8.0)\n    {\n        pos1 = position(0.0,2.0);\n        meta1 = metadata(2.0);\n        pos2 = position(4.0,4.0);\n        meta2= metadata(3.0);        \n    }\n    else if (AT<12.0)\n    {\n        pos1 = position(4.0,4.0);\n        meta1 = metadata(3.0);\n        pos2 = position(8.0,6.0);\n        meta2= metadata(4.0);        \n    }\n    else\n    {\n        pos1 = position(8.0,6.0);\n        meta1 = metadata(4.0);\n        pos2 = position(12.0,8.0);\n        meta2= metadata(1.0);        \n    }\n    \n    \n    if (U==JIGSAW_1_POS) C = pos1;\n    if (U==JIGSAW_1_META) C = meta1;\n    if (U==JIGSAW_2_POS) C = pos2;\n    if (U==JIGSAW_2_META) C = meta2;\n    if (U==JIGSAW_LIGHT) C = light;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime * 0.4\n#define AT mod(T,16.0)\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n\n#define JIGSAW_1_POS vec2(10.5,0.5)\n#define JIGSAW_1_META vec2(11.5,0.5)\n#define JIGSAW_2_POS vec2(12.5,0.5)\n#define JIGSAW_2_META vec2(13.5,0.5)\n#define JIGSAW_LIGHT vec2(14.5,0.5)\n\n#define J1 2.0\n#define J2 0.1\n#define J3 0.1\n\n#define S(x,y,z) smoothstep(x,y,z)\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define EPS 0.002\n#define FAR 50.0\n\n#define PIECE_1_POS texture(iChannel0,JIGSAW_1_POS/R)\n#define PIECE_1_META texture(iChannel0,JIGSAW_1_META/R)\n#define PIECE_2_POS texture(iChannel0,JIGSAW_2_POS/R)\n#define PIECE_2_META texture(iChannel0,JIGSAW_2_META/R)\n#define LIGHT texture(iChannel0,JIGSAW_LIGHT/R)\n\n#define ATL AT*0.5\n\n//Dave Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Shane IQ\nfloat n3D(vec3 p) \n{    \n\tconst vec3 s = vec3(7,157,113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0.,s.yz,s.y + s.z) + dot(ip,s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453),fract(sin(h + s.x)*43758.5453),p.x);\n    h.xy = mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\n\n// borrowed from shane\n// Standard smooth 2D value noise. Based on IQ's original.\n// This one is self contained, so there's no need for an outside hash function.\nfloat n2D(vec2 p) \n{\t\n\tvec2 f = fract(p); // Fractional cell position.    \n    f *= f*(3. -2.*f);// Smooth step\n    // Random values for all four cell corners.\n\tvec4 h = fract(sin(vec4(0, 41, 289, 330) + dot(floor(p), vec2(41, 289)))*43758.5453);\n\th = sin(h*6.283)*.5 + .5; // Animation.\n    // Interpolating the random values to produce the final value.\n\treturn dot(vec2(1. - f.y, f.y), vec2(1. - f.x, f.x)*mat2(h));\n    \n}\n\n//distance functions from IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// sphere of size ra centered at point ce\n// returns x = distance to near face and y = 1.0 if hit \nvec2 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0,0.0); // no intersection\n    h = sqrt( h );\n    return vec2(-b-h,1.0);\n}\n\n// returns x = distance to near and y = 1.0 if hit \nvec2 planeIntersect(vec3 ro, vec3 rd, vec3 n, vec3 o) \n{\n    float t = dot(o-ro,n)/dot(rd,n);\n    return (t>0.0&&t<FAR) ? vec2(t,1.0) : vec2(-1.0,0.0); \n}\n\nvec2 near(vec2 a, vec2 b)\n{\n    float s = step(a.x,b.x);\n    return s*a + (1.0-s)*b;\n}\n\nvec4 near(vec4 a, vec4 b)\n{\n    float s = step(a.x,b.x);\n    return s*a + (1.0-s)*b;\n}\n\nfloat p1(vec3 p, float y)\n{\n    float t = sdBox(p,vec3(1.0,y,1.0));\n    t = min(t, sdCappedCylinder(p - vec3(0.0,0.0,1.2),y,0.4));\n    t = max(t, -sdCappedCylinder(p - vec3(0.0,0.0,-0.8),y+0.1,0.4));\n    p.x = abs(p.x);\n    t = min(t, sdCappedCylinder(p - vec3(1.2,0.0,0.0),y,0.4));\n    return t;\n}\n\nvec3 piece1(vec3 p)\n{\n    vec2 t = vec2(p1(p,J1),1.0);\n    p.y = abs(p.y);\n    float l = p1(p-vec3(0.0,J1+J2,0.0),J2);\n    t = near(t, vec2(l,2.0));\n    t = near(t, vec2(p1(p-vec3(0.0,J1+J2+J2+J3,0.0),J3),3.0));\n    if (abs(p.y)>J1+J2+J2) l = FAR;\n    return vec3(t,l);\n}\n\nfloat p2(vec3 p, float y)\n{\n    float t = sdBox(p,vec3(1.0,y,1.0));\n    t = max(t, -sdCappedCylinder(p - vec3(0.0,0.0,0.8),y+0.1,0.4));\n    t = min(t, sdCappedCylinder(p - vec3(0.0,0.0,-1.2),y,0.4));\n    p.x = abs(p.x);\n    t = max(t, -sdCappedCylinder(p - vec3(0.8,0.0,0.0),y+0.1,0.4));\n    return t;\n}\n\nvec3 piece2(vec3 p)\n{\n    vec2 t = vec2(p2(p,J1),1.0);\n    p.y = abs(p.y);\n    float l = p2(p-vec3(0.0,J1+J2,0.0),J2);\n    t = near(t, vec2(l,2.0));\n    t = near(t, vec2(p2(p-vec3(0.0,J1+J2+J2+J3,0.0),J3),3.0));\n    if (abs(p.y)>J1+J2+J2) l = FAR;\n    return vec3(t,l);\n}\n\nfloat p3(vec3 p, float y)\n{\n    float t = sdBox(p,vec3(1.0,y,1.0));\n    p.xz = abs(p.xz);\n    t = min(t, sdCappedCylinder(p - vec3(1.2,0.0,0.0),y,0.4));\n    t = max(t, -sdCappedCylinder(p - vec3(0.0,0.0,0.8),y+0.1,0.4));\n    return t;\n}\n\nvec3 piece3(vec3 p)\n{\n    vec2 t = vec2(p3(p,J1),1.0);\n    p.y = abs(p.y);\n    float l = p3(p-vec3(0.0,J1+J2,0.0),J2);\n    t = near(t, vec2(l,2.0));\n    t = near(t, vec2(p3(p-vec3(0.0,J1+J2+J2+J3,0.0),J3),3.0));\n    if (abs(p.y)>J1+J2+J2) l = FAR;\n    return vec3(t,l);\n}\n\nfloat p4(vec3 p, float y)\n{\n    float t = sdBox(p,vec3(1.0,y,1.0));\n    p.xz = abs(p.xz);\n    t = max(t, -sdCappedCylinder(p - vec3(0.8,0.0,0.0),y+0.1,0.4));\n    t = min(t, sdCappedCylinder(p - vec3(0.0,0.0,1.2),y,0.4));\n    return t;\n}\n\nvec3 piece4(vec3 p)\n{\n    vec2 t = vec2(p4(p,J1),1.0);\n    p.y = abs(p.y);\n    float l = p4(p-vec3(0.0,J1+J2,0.0),J2);\n    t = near(t, vec2(l,2.0));\n    t = near(t, vec2(p4(p-vec3(0.0,J1+J2+J2+J3,0.0),J3),3.0));\n    if (abs(p.y)>J1+J2+J2) l = FAR;\n    return vec3(t,l);\n}\n\nvec3 jigsawPiece(vec3 p, float r, float id)\n{\n    p.xz *= rot(r);\n    vec3 piece = piece1(p); //default id for 1.0 and 5.0\n    if (id==2.0)\n    {\n        piece = piece2(p); \n    }\n    if (id==3.0)\n    {\n        piece = piece3(p); \n    }\n    if (id==4.0)\n    {\n        piece = piece4(p); \n    }\n    return piece;\n}\n\nvec4 map(vec3 p, vec4 bounds) \n{\n    vec4 t = vec4(FAR,0.0,FAR,0.0);\n    p.x += ATL;\n    //jigsaw pieces\n    if (bounds.x>0.0)\n    {\n        t = near(t,vec4(jigsawPiece(p-PIECE_1_POS.xyz,PIECE_1_POS.w,PIECE_1_META.w),10.0));\n    }\n    if (bounds.y>0.0)\n    {\n        t = near(t,vec4(jigsawPiece(p-PIECE_2_POS.xyz,PIECE_2_POS.w,PIECE_2_META.w),11.0));\n    }\n    \n    //floor  \n    if (bounds.z>0.0)\n    {\n        float x = sdBox(p-vec3(0.0,-10.0,0.0),vec3(100.0,10.0,100.0)); \n        x = max(x, -sdBox(p-vec3(0.0,-10.0,0.0),vec3(100.0,20.0,1.0))); \n        vec3 q = p;\n        q.x += 1.0;\n        q.x = mod(q.x,4.0) - 2.0;\n        x = max(x, -sdCappedCylinder(q - vec3(1.0,-10.0,-1.2),100.0,0.4));\n        x = min(x, sdCappedCylinder(q-vec3(-1.0,-10.0,-0.8),10.0,0.4));\n        q = p;\n        q.x -= 1.0;\n        q.x = mod(q.x,8.0) - 4.0;\n        x = min(x, sdCappedCylinder(q-vec3(-1.0,-10.0,0.8),10.0,0.4));\n        x = min(x, sdCappedCylinder(q-vec3(-3.0,-10.0,0.8),10.0,0.4));\n        x = max(x, -sdCappedCylinder(q-vec3(1.0,-10.0,1.2),100.0,0.4));\n        x = max(x, -sdCappedCylinder(q-vec3(3.0,-10.0,1.2),100.0,0.4));\n        //fill hole behind jigsaw\n        float bpfl = floor(ATL*0.5),\n              adv = bpfl*2.0;\n        if (float(ATL*0.5)>0.5) adv+=1.0;\n        x = min(x, sdBox(p-vec3(-101.0,-10.0,0.0),vec3(100.0+adv,10.0,100.0)));     \n        t = near(t,vec4(x,4.0,FAR,0.0)); \n    }\n    return t;\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz,vec4(1.0)).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) \n{\n    float ra = 0., w = 1., d = 0.;\n    for (int i=ZERO; i<5; i++){\n        d = float(i) / 5.;\n        ra += w * (d - map(p + n*d,vec4(1.0)).x);\n        if (ra>1.) break;\n        w *= .5;\n    }\n    return 1. - clamp(ra,0.,1.);\n}\n\n//shane\n//https://www.shadertoy.com/view/ld3Szs\nfloat thickness(in vec3 p, in vec3 n){\n    \n    float sNum = 4.0, sca = 1.0, occ = 0.0;\n    for(float i=0.0; i<sNum + 0.001; i++ ){\n    \n        float hr = 0.05 + 0.4*i/sNum; \n        float dd = map(p - n*hr,vec4(1.0)).x;\n        occ += (hr - min(dd,0.0))*sca;\n        sca *= 0.9;\n    }\n    return 1.0 - max(occ/sNum,0.0); \n    \n}\n\nvec3 getColour(float id)\n{\n    vec3 col = vec3(0.0);\n    if (id==10.0) col = PIECE_1_META.xyz;\n    if (id==11.0) col = PIECE_2_META.xyz;\n    return col;\n}\n\nvec4 getPosition(float id)\n{\n    vec4 pos = vec4(0.);\n    if (id==10.0) pos = PIECE_1_POS;\n    if (id==11.0) pos = PIECE_2_POS;\n    return pos;\n}\n\nvec4 getBounds(vec3 ro, vec3 rd)\n{\n    vec3 offs = vec3(ATL,0.0,0.0);\n    vec2 sb1 = sphIntersect(ro,rd,PIECE_1_POS.xyz-offs,3.2),\n         sb2 = sphIntersect(ro,rd,PIECE_2_POS.xyz-offs,3.2),\n         fb = planeIntersect(ro,rd,vec3(0.0,1.0,0.0),vec3(0.0));\n    float advance = (sb1.x>0.0) ? sb1.x : 0.0;\n    if (sb2.x>0.0) advance = min(advance,sb2.x);\n    if (fb.x>0.0) advance = min(advance,fb.x);\n    return vec4(sb1.y,sb2.y,fb.y,advance);\n}\n\n//IQ\n//https://www.shadertoy.com/view/lsKcDD\nfloat shadow(vec3 ro, vec3 rd)\n{\n    vec4 bounds = getBounds(ro,rd);\n    float res = 1.0;\n    float t = bounds.w*0.9; //advance ray\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=ZERO; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, bounds ).x;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>20.0 ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec4 march(vec3 ro, vec3 rd, vec4 bounds, int steps, inout vec3 glow) \n{\n    float t = bounds.w*0.9, //advance ray \n          l = 0.0; \n    vec2 id = vec2(0.0);   \n    for (int i=ZERO; i<steps; i++)\n    {\n        vec4 ns = map(ro + rd*t,bounds);\n        if (abs(ns.x)<EPS)\n        {\n            id = ns.yw;\n            break;\n        }\n        t += ns.x;\n        glow += 0.1*mix(getColour(ns.w),vec3(1.0),0.1)/(1.0+ns.z*ns.z*800.0);\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n        \n    }\n    return vec4(t,id,l);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nstruct SCENE\n{\n    vec3 col;\n    float t;\n    float ra;\n    bool bounce;\n};\n\nSCENE render(vec3 ro, vec3 rd, int steps)\n{\n    vec4 bounds = getBounds(ro,rd);\n    vec3 qrd = rd;\n    qrd.xz *= rot(0.9); \n    SCENE scene = SCENE(vec3(0.0),0.0,0.0,false);\n    //vec3 pc = vec3(0.0),\n    vec3 pc = texture(iChannel1,qrd).xyz,\n         lp = vec3(-33.0,31.0,-70.0),\n         glow = vec3(0.0);\n\n    vec4 s = march(ro,rd,bounds,steps,glow);\n    if (s.x>0.0)\n    {\n        scene.t = s.x;\n\n        vec3 p = ro + rd*s.x,\n             q = p,\n             n = normal(p),\n             ld = normalize(lp-p),\n             col = getColour(s.z);\n        vec4 pos = getPosition(s.z);\n        \n        //shading\n        float diff = max(0.05,dot(ld,n)),\n              spec = pow(max(dot(reflect(-ld,n),-rd),0.0),16.0),\n              fres = pow(clamp(dot(n,rd)+1.0,0.0,1.0),8.0),\n              ao = AO(p,n);\n        \n        if (s.y==1.0) \n        {\n            //main body\n            //fake sss\n            vec3 hf = normalize(ld+n);\n            float th = thickness(p,n);\n            float tdiff = pow(clamp(dot(rd,-hf),0.0,1.0),1.0);\n            float trans = max((tdiff+0.25)*th*1.5,0.0);\n            trans = pow(trans,2.0); \n            //translate jigsaw piece position\n            q.x += ATL;\n            q -= pos.xyz; \n            q.xz *= rot(pos.w);\n            float nz = n3D(q*vec3(4.0,9.0,5.0));\n            float lx = length(p-pos.xyz);\n            pc = col*nz*ao*diff/(1.0+lx*lx*0.3);\n            pc += mix(pc,col*2.0,abs(hf.y))*trans*0.2;\n            pc += vec3(1.0)*(fres+spec);\n            \n            scene.bounce = true;\n            scene.ra = 0.2+fres+spec;\n        }\n        if (s.y==2.0) \n        {\n            //light\n            pc = mix(col,vec3(1.0),0.2)*ao;\n        }\n        \n        if (s.y==3.0 || s.y==4.0)\n        {\n            //floor and jigsaw cap\n            float sh = shadow(p+EPS*n,ld);\n            q.x += ATL;\n            if (s.y==3.0)\n            {\n                //cap of jigsaw piece translation\n                q.xz -= pos.xz;\n                q.xz *= rot(pos.w);  \n                q.x += pos.x;\n            }\n                    \n            vec2 ts = mod(q.xz,8.0)-4.0; //tiling space\n            vec2 ts2 = mod(q.xz,4.0)-2.0; //for chessboard\n            vec2 x = floor(ts*0.5); //cut tiled space into 16 ids\n            float h1 = hash12(x);\n            float nz = n2D(ts*vec2(1.21,2.17)*1.4); //make some noise!!!\n            ts *= rot((h1-0.5)*0.6);\n            float nz2 = n2D(ts*vec2(51.37,9.17)*(0.8+h1*0.2));\n            nz = mix(1.0-nz2,nz,S(0.3,0.7,nz2));//*n2D((ts2+1.3)*vec2(2.1,2.37)*1.7);\n            \n            pc = vec3(0.1);\n            scene.ra = nz2*0.4;\n            if (ts2.x*ts2.y>0.0)\n            {\n                //chess board\n                pc = vec3(0.05);\n                scene.ra = nz*0.17;\n            }\n            if (s.y==4.0&&p.y<0.0)\n            {\n                //trench\n                pc = vec3(0.0);\n            }\n            \n            vec3 lPos = PIECE_1_POS.xyz - p - vec3(ATL,0.0,0.0);\n            ld = normalize(lPos);\n            float lt = length(lPos);\n            pc += vec3(PIECE_1_META.xyz)*max(0.01,dot(ld,n))/(1.0+lt*lt*0.4)*LIGHT.x;\n            lPos = PIECE_2_POS.xyz - p - vec3(ATL,0.0,0.0);\n            ld = normalize(lPos);\n            lt = length(lPos);\n            pc += vec3(PIECE_2_META.xyz)*max(0.01,dot(ld,n))/(1.0+lt*lt*0.4);\n            if (n.y>0.5)\n            {\n               scene.bounce = true;\n            }\n            scene.ra*=sh;\n            pc *= ao*diff;\n        } \n        \n        pc += vec3(0.03)*max(0.0,-n.z);\n    }\n    \n    scene.col = pc+(glow*1.6);    \n    return scene;\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec3 pc = vec3(0.0),\n         la = vec3(0.0,1.0,0.0),\n         ro = vec3(3.0+sin(T*0.133)*2.0,6.0-sin((T+1.3)*0.23)*2.0,-7.0+sin(T*0.17)*1.8);\n         \n    vec3 rd = camera(U,ro,la,1.2);\n    SCENE scene = render(ro,rd,140);\n    float dof = 0.0;\n    if (scene.t>0.0)\n    {\n        pc = scene.col;\n        vec3 p = ro+rd*scene.t;\n        dof = length(p)/FAR;\n        if (scene.bounce)\n        {\n            vec3 p = ro+rd*scene.t;\n            vec3 n = normal(p);\n            vec3 rrd = reflect(rd,n);\n            SCENE refl = render(p+EPS*n,rrd,80);\n\n            pc += refl.col*scene.ra*0.7;\n\n        }\n\n        float l = length(p.xz);\n        pc /= (1.0+l*l*0.02); //fog\n    }\n    \n    pc = pow(ACESFilm(pc),vec3(0.4545));\n    //pc = pow(pc,vec3(0.4545));\n    C = vec4(pc*1.3,dof);\n}","name":"Buffer B","description":"","type":"buffer"}]}