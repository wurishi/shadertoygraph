{"ver":"0.1","info":{"id":"4l2yWy","date":"1510005730","viewed":136,"name":"MCMC: Gibbs sampling","username":"tale3d","description":"Image morphing with Markov Chain Monte Carlo. \nPart 3: Gibbs sampling ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["stochastic","mcmc","teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//everything happens in Buffer A, here we just render a texture that is created in there\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 tex = texture(iChannel0, uv);\n    fragColor = tex;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Gibbs sampling example\n\n#define ITERATIONS 20\n\n//noise functions in this example are taken from here:\n//https://www.shadertoy.com/view/4ssXRX\n\n//uniform sampling\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n//the samplimg function for the target distribution\n//obtained by using inverse mapping method:\n//assume that we hav distribution target = 1/[(p-s).(p-s)+0.01], \n//get cumulative distribution as cumulative = Integrate[target, -infinity, x]\n//and solve for x cumulative(x) = u, where u is a uniform random\n\n//long story short, below is a result of all the steps in inverse mapping\nfloat sampletarget(float a, float b, vec2 uv)\n{\n\tfloat u = nrand(uv*iTime);\n    float sqb = sqrt(b);\n    return a+sqb*tan(u*sqb*3.14-1.57);   \n}\n\n//if we assume that we sample 1/((p-t).(p-t)+0.01) with one variable fixed,\n//it can be rewritten as 1/[(p.c-a)^2 + b], \n//for example, for x it gives\n// 1/[(p.x-a).(p.x-a)+b], where a is t.x and b is 0.01+(p.y-a.y)^2+(p.z-a.z)^2\nfloat sampleconditional(vec3 rgb, vec2 uv, int coord)\n{\n    vec4 targetcolor = texture(iChannel2, uv);\n\n    //sampling x with y and z fixed - conditional\n    if (coord == 0)\n    {\n        float a = targetcolor.x-rgb.x;\n        float b = dot(targetcolor.yz-rgb.yz,targetcolor.yz-rgb.yz)+0.01;\n        return sampletarget(a, b, uv);\n    }\n    //sampling z\n    if (coord == 2)\n    {\n        float a = targetcolor.z-rgb.z;\n        float b = dot(targetcolor.xy-rgb.xy,targetcolor.xy-rgb.xy)+0.01;\n        return sampletarget(a, b, uv);\n    }\n    //otherwise sampling y\n    float a = targetcolor.y-rgb.y;\n    float b = dot(targetcolor.xz-rgb.xz,targetcolor.xz-rgb.xz)+0.01;\n    return sampletarget(a, b, uv);\n}\n\n//target function/distribution that we are sampling from.\n//here we use a very simple one: difference between the colour in the target texture and the current colour\nfloat target(vec3 rgb, vec2 uv)\n{\n    //reading from the target texture\n    vec4 targetcolor = texture(iChannel2, uv);\n    \n    return 1.0/(dot(targetcolor.xyz-rgb,targetcolor.xyz-rgb) + 0.01); \n}\n\n\n//in the texture for each pixel we store current sample in x(r) channel,\n// the best sample with respect to the target function is in y(g) channel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv); \n    \n    float t = target(color.rgb, uv);    \n    \n    vec3 c;\n    c.x = color.x; c.y = color.y; c.z = color.z;\n\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        float rn = sampleconditional(c, uv, 0);\n        c.x = rn;\n        float gn = sampleconditional(c, uv, 1);\n\t\tc.y = gn;\n        float bn = sampleconditional(c, uv, 2);\n        c.z = bn;\n    }\n    c.x = clamp(c.x, 0.,1.);\n    c.y = clamp(c.y, 0.,1.);\n    c.z = clamp(c.z, 0.,1.);\n\n    float nt = target(c, uv);\n    if (nt > t)\n        fragColor = vec4(c, 1.0);\n    else\n        fragColor = color;\n\n    if (iTime < 1.0) \n    {\n        vec4 color = texture(iChannel1, fragCoord.xy / iResolution.xy);\n\n        fragColor = color;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}