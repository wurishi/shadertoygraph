{"ver":"0.1","info":{"id":"WdVfWz","date":"1606926157","viewed":129,"name":"RayMarching School Project","username":"Meneur07","description":"Abstract Raymarching Project","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int stepsMax = 1000;\nconst float tEpsilon = 0.01; // Marching epsilon\nconst float tMin = 1.0; // Minimum ray marching distance from origin\nconst float tMax = 50.0; // Maximum\n\nvec3 rayDir = vec3(0.0);\nvec3 rayOrigin = vec3(0.0);\nfloat angle = 0.0;\nfloat zoom = 2.0;\n\nconst int iNull = -1;\nconst int iTerrain = 0;\nconst int iEau = 1;\nconst int iSoleil = 2;\nconst int iColumn = 3;\nconst int iMax = 3;\n\nvec2 column1pos = vec2(5.5, 11.0);\nvec2 column2pos = vec2(8.0, 0.0);\nvec2 column3pos = vec2(-25.0, -5.0);\n\nfloat island = 0.0; \n\n//---------------------------------------------------------------------------------------------\n// Transforms\nvec3 rotateY(vec3 p, float a)\n{\n   mat3 rm = mat3(\n      +cos(a), 0.0, +sin(a), \n          0.0, 1.0,     0.0,\n      -sin(a), 0.0, +cos(a)\n   );\n   return rm*p;\n}\nvec3 zoomZ(vec3 p, float z)\n{\n\tp.z += z;\n    p = normalize(p);\n    return p;\n}\nfloat map(float value, float min1, float max1, float min2, float max2)\n{\n    float perc = (value - min1) / (max1 - min1);\n    return perc * (max2 - min2) + min2;   \n}\nvec2 rand(vec2 co)\n{\n    return vec2(\n        fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453),\n        fract(cos(dot(co.yx ,vec2(8.64947,45.097))) * 43758.5453)\n    )*2.0-1.0;\n}\n\n//---------------------------------------------------------------------------------------------\n// Smooth functions\nfloat falloff( float r, float R )\n{\n   float x = clamp(r/R,0.0,1.0);\n   float y = (1.0-x*x);\n   return y*y*y;\n}\nfloat easeOutQuart( float x, float s, float e ) \n{\t\n    return s + (e-s) * (1.0 - pow(x - 1.0, 4.0));\n}\nfloat easeInQuart( float x, float s, float e ) \n{\t\n    return s + (e-s) * (pow(x, 4.0));\n}\nfloat easeInOutQuart( float x, float s, float e )\n{\n\treturn (x < 0.5) ? easeInQuart((x)*2.0, s, (e-s)/2.0) : easeOutQuart((x-0.5)*2.0, (e-s)/2.0, e);  \n}\n\n//---------------------------------------------------------------------------------------------\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n   return e*falloff(length(p-c),R);\n}\nfloat stars(vec2 p)\n{\n \tvec2 ip = floor(p);\n    vec2 fp = fract(p)*2.0-1.0;\n    vec2 rp = rand(ip)*0.5;\n    return length(fp+rp);\n}\n\n//---------------------------------------------------------------------------------------------\n// Noise et Turbulence\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n//---------------------------------------------------------------------------------------------\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n//---------------------------------------------------------------------------------------------\nfloat ridged( in vec2 p)\n{\n    return 2.0*(0.5 - abs(0.5 - noise(p)));\n}\n//---------------------------------------------------------------------------------------------\nfloat turbulence(in vec2 p, in float amplitude, in float fbase, in float attenuation, in int noctave) {\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*ridged(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\n//---------------------------------------------------------------------------------------------\n// Potential field of the objects\n// p : point\n// index : index of the object\nfloat object(vec3 p, int index)\n{\n\tswitch (index)\n    {\n        case iNull:\n        \treturn p.z;\n        break;\n    \tcase iTerrain: \n        \tint octaves = 1+int(map(max(distance(p, rayOrigin), 0.0), 0.0, 200.0, 9.0, 2.0));\n        \tfloat terr = -p.y + 0.1*sin(0.35*iTime)*island - turbulence(p.xz, 1.5, 0.07, 0.5, octaves);\n        \tfloat sphere1 = point(p, vec3(0.0, 0.0, 5.5), 1.0, 5.0)-0.5;\n        \tfloat sphere2 = point(p, vec3(6.0, 0.0, 3.5), 1.0, 6.0)-0.5;\n        \tfloat sphere3 = point(p, vec3(-26.0, 1.0, 1.0), 1.0, 6.5)-0.5;\n        \tfloat sphere4 = point(p, vec3(8.0, -0.5, -4.0), 1.0, 4.0)-0.5;\n        \tfloat sphere5 = point(p, vec3(4.0, 0.0, 12.0), 1.0, 2.5)-0.5;\n        \tfloat sphere6 = point(p, vec3(7.25, -0.6, 10.0), 1.0, 1.0)-0.5;\n        \tfloat spheresUnion = max(max(max(sphere1, sphere2), max(sphere3, sphere4)), max(sphere5, sphere6));\n            return mix(terr, min(terr, spheresUnion), island);\n        break;\n        case iEau:\n        \tvec2 randTime = vec2(0.1*iTime, 0.05*iTime);\n            return -p.y - 0.85 - turbulence(p.xz + randTime, 0.075, 0.08, 0.5, 6);\n        break;\n        case iSoleil:\n        \t//float turb = turbulence(p.xy + vec2(iTime, iTime), 0.5, 0.095, 0.5, 5);\n            return point(p, vec3(-24.0, 2.0, -25.0), 1.0, 20.0) - 0.5;\n        break;\n        case iColumn:\n        \tfloat y1 = p.y - mod(2.0*iTime,  4.0) + 4.0  / 2.0;\n            float y2 = p.y - mod(2.5*iTime, 15.0) + 15.0 / 2.0;\n            float y3 = p.y - mod(4.0*iTime, 40.0) + 40.0 / 2.0;\n        \tfloat c1 = 0.12 + 0.08*exp(-20.0*y1*y1) - distance(p.xz, column1pos);\n        \tfloat c2 = 0.15 + 0.08*exp(-20.0*y2*y2) - distance(p.xz, column2pos);\n        \tfloat c3 = 0.22 + 0.16*exp(-20.0*y3*y3) - distance(p.xz, column3pos); \n        \treturn max(max(c1, c2), c3); \n        break;\n    }\n}\n\n//---------------------------------------------------------------------------------------------\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p, int index)\n{\n   \tfloat eps = 0.0001;\n   \tvec3 n; \n    float v = object(p, index);\n    n.x = object( vec3(p.x+eps, p.y, p.z), index ) - v;\n    n.y = object( vec3(p.x, p.y+eps, p.z), index ) - v;\n    n.z = object( vec3(p.x, p.y, p.z+eps), index ) - v;\n   \treturn normalize(n);\n}\n\n//---------------------------------------------------------------------------------------------\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\nvec3 Trace(vec3 origin, vec3 dir)\n{\n    \n    // TRACE parameters\n    vec3 pos = origin;\n    float t = tMin;\n\tbool hit = false;\n    bool keepTracing = true;\n    float reflections = 0.0;\n    float refractions = 0.0;\n    int index = iNull;\n    int s;\n    \n    // SHADE parameters\n   \tvec3 lightPos = vec3(5.0, 5.0, 3.0);\n   \tvec3 lightColor = vec3(1.0, 1.0, 0.8);\n    vec3 waterColor = vec3(0.0, 0.0, 0.35);\n    vec3 hazeColor = vec3(1.0, 0.9, 0.9);\n    vec3 fogColor = vec3(1.0, 1.0, 0.0);\n    vec3 objColor = vec3(0.0, 0.0, 0.0);\n    float lightInfluence = 0.5;\n    float hazeCoef = 0.0;\n    float cloudCoef = 0.0;\n    \n    // Throwing the ray\n    for(s = 0; keepTracing; s++)\n    {\n        pos = origin + t*dir;\n        \n        // Checking for collisions with objects from the pool of objects\n        float vMin = -999.0;\n        for(int i = 0; i <= iMax; i++)\n        {\n            // Skip water checks if there was already a reflection\n            if (reflections > 0.5 && i == iEau)\n            {\n             \tcontinue;   \n            }\n            \n            // Calculating distance and updating the minimal march vMin\n            float v = object(pos, i);\n            vMin = -min(-vMin, -v);\n            \n            // If there's a collision with an object\n            if (v > 0.0)\n            {\n                // Reflection Blocking Coefficient\n                float rxb_time = 0.1*iTime*iResolution.x;\n                float rxb_dist = distance(column1pos, pos.xz)*iResolution.x;\n                float rxb_thickness = (1200.0*exp(-0.01*rxb_dist)*2.0);\n                float rxb = 1.0-clamp(round(mod(rxb_dist - rxb_time, 160.0)/rxb_thickness), 0.0, 1.0);\n                \n                // Refraction Blocking Coefficient\n                float rfb_y = (pos.y - 0.1*iTime - 0.3*pos.x)*iResolution.y;\n            \tfloat rfb = 1.0-round(clamp(mod(rfb_y, 85.0)/26.0, 0.0, 1.0));\n                \n\t\t\t\t// If reflecting\n                if (i == iEau && rxb < 0.5)\n                {\n                    // Reset time / steps / origin / change direction of ray\n                \tt = 0.0;\n                    s = 0;\n                    origin = pos;\n                    vec3 n = ObjectNormal(pos, i);\n                    dir = normalize(dir - 2.0*dot(dir, n)*n);\n                    reflections++; \n                }\n                else if (i == iColumn && refractions < 0.5 && rfb < 0.5)\n                {\n                    // Reset time / steps / origin / change direction of ray\n                \tt = 0.0;\n                    s = 0;\n                    origin = pos;\n                    vec3 n = ObjectNormal(pos, i);\n                    dir = -refract(-dir, n, 1.1);\n                    refractions++;\n                }\n                // Otherwise if it's a regular collision\n                else if (i != iColumn || (i == iColumn && refractions < 0.5))\n                {\n                    // Set hit to true and save the collision index\n                    hit = true;\n                    index = i;\n                }\n                \n                break;\n            } \n        } \n        // Checking for density of haze in space\n        {\n            float turb1 = map(turbulence(pos.xy, 1.0, 0.005, 0.1, 4), -1.0, 1.0, 0.0, 1.0); \n            hazeCoef +=  0.004*turb1;\n        }\n        // Checking for density of clouds in space\n        {\n            float turb1 = sin(pos.x)*cos(pos.z);\n            float turb2 = 1.2*sin(pos.x-0.5*iTime)*cos(pos.z-iTime);\n            cloudCoef += 0.0087*clamp(-max(-0.5 - pos.y - turb1, -0.5 + pos.y - turb2), 0.0, 1.0);\n        }\n        \n        keepTracing = (s < stepsMax && t < tMax && !hit);\n        t += max(tEpsilon, -vMin/2.0);\n\t\n    }\n    \n  \t// Compute SHADE\n    vec3 n = ObjectNormal(pos, index); \n    \n    // If the ray didn't hit anything,\n    if (!hit)\n    {\n        objColor = mix(vec3(0.9, 0.2, 0.0), vec3(0.60, 0.52, 0.75), dir.y*2.4 + 0.7);\n        objColor = mix(objColor, vec3(0.9, 0.9, 1.0), 1.0-smoothstep(0.05, 0.07, stars((dir.xz - 0.02*iTime) * 6.0)));\n        lightInfluence = 0.0;\n    }\n    \n    // If the ray did hit something\n    else \n    {\n        switch (index)\n        {\n            case iTerrain:\n                float isoline = clamp(round(mod(pos.y*iResolution.y, 120.0)/(2.0*10.0)), 0.0, 1.0);\n                float cturb = turbulence(pos.xy, 1.0, 0.075, 0.75, 8)*0.5;\n                vec3 c1 = vec3(0.25, 0.10, 0.00);\n                vec3 c2 = vec3(0.40, 0.35, 0.30);\n                objColor = mix(c1, c2, pos.y + cturb);\n            \tif (-pos.y > 0.6)\n                {\n                    objColor += (1.0+((pos.y)/0.6))*0.8*vec3(1.0, 0.8, 1.0);\n                }\n            \tfloat verticality = abs(dot(n, vec3(0.0, -1.0, 0.0))); \n                objColor += pow(verticality, 4.0)*vec3(0.0, 0.65, 0.0);\n                lightInfluence = 0.45;\n            break;\n            case iEau:\n            \tobjColor = vec3(0.3, 0.0, 0.0);\n            \tlightInfluence = 0.25;\n            break;\n            case iSoleil:\n                objColor = vec3(1.0, 0.9, 0.0);\n                lightInfluence = 0.15;\n            break;\n            case iColumn:\n            \tobjColor = vec3(0.3, 0.0, 0.0);\n            \tlightInfluence = 0.05;\n            break;\n        }\n    }\n    \n    vec3 color;\n    \n    // Apply water shade on colour\n    objColor = mix(objColor, waterColor, reflections*0.5 + refractions*0.5);\n    // Apply light on colour\n    vec3 l = normalize(lightPos - pos);\n    float lightCoef = (dot(n, l) + 1.0)/2.0; //not even Phong shading\n   \tcolor = mix(objColor, lightCoef*lightColor, lightInfluence); \n    // Apply distance fog on colour\n   \tfloat fogCoef = 0.7*float(s)/(float(stepsMax-1)); \n   \tcolor = mix(color, fogColor, fogCoef);\n    // Apply haze on colour\n    color = mix(color, hazeColor, hazeCoef);\n    // Apply cloud on colour\n    color += hazeColor*cloudCoef;\n    \n   \treturn color;\n\n}\n\n//---------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// Input\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // Compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    rayDir = vec3(asp*pixel.x, pixel.y, -4.0);\n    rayOrigin = vec3(0.0, 0.0, 15.0);\n\n    // Camera Movements\n    island = easeInOutQuart(clamp((iTime-4.5)/5.5, 0.0, 1.0), 0.0, 1.0); \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    angle = -0.40-(0.005 + island*0.005)*iTime;\n    zoom = max(2.0+(0.005 + island*0.010)*iTime, -1.0);\n    rayOrigin.y = max(0.25-(0.005 + island*0.010)*iTime, 0.0);\n    \n    rayDir = zoomZ(rayDir, zoom);\n    rayOrigin = rotateY(rayOrigin, angle);\n    rayDir = rotateY(rayDir, angle);\n\n    // Trace ray, shade destination\n    vec3 rgb = Trace(rayOrigin, rayDir);\n\n    // Output\n   \tfragColor = vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}