{"ver":"0.1","info":{"id":"sllfDB","date":"1688130120","viewed":150,"name":"CitySkyline","username":"rooby","description":"First ever shader","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sunset","city","skyline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int AA = 2; // Anti-aliasing\nconst float water_height = -0.4;\nconst float ground_height = -0.37;\n\nvec3 render(vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv = uv - vec2(iResolution.x/iResolution.y/2., 0.5);\n\n    float y = uv.y;\n\n    if (uv.y <= water_height) {\n        uv.y = -(uv.y - water_height) + water_height;\n        uv.x += 0.01*sin(100.*uv.y*uv.y)*y;\n    }\n\n    // Sun colors\n    vec3 sun_col1 = vec3(246, 245, 77) / 255.; // orange\n    vec3 sun_col2 = vec3(254, 177, 57) / 255.; // yellow\n    \n    // Sky colors\n    vec3 sky_col1 = vec3(245, 83, 83) / 255.; // red\n    vec3 sky_col2 = vec3(20, 63, 107) / 255.; // dark blue\n\n    // Building color\n    vec3 conc_col = vec3(127, 128, 118) / 255.;\n\n    // Water color\n    vec3 water_col = 1.5 * vec3(15,94,156) / 255.;\n\n    // Center of sun\n    vec2 center = vec2(0, -0.2);\n    \n    // Compute sun color\n    float radius = 0.17;\n    float circleDist = length(uv - center) - radius;\n    float r = smoothstep(0.0, 0.5, circleDist);\n    vec3 sun_col = r * sun_col2 + (1.0 - r) * sun_col1;\n\n    // Gompute sky color\n    radius = 2.5 * radius;\n    circleDist = length(uv - center) - radius;\n    r = smoothstep(0.0, .5, circleDist);\n    vec3 sky_col = r * sky_col2 + (1.0 - r) * sky_col1;\n\n    // Determine gradient between sun and sky\n    r = smoothstep(0.0, .05, circleDist);\n    vec3 col = r * sky_col + (1.0 - r) * sun_col; \n\n    // Darken sky color further away from sun\n    r = smoothstep(0.0, 1.0, 0.5*circleDist);\n    col = (1.-r) * col;\n    \n    // First row of buildings\n    float sineDist = -0.2*sin(50. + floor(40.*(uv.x))) - 0.1*sin(100. + floor(50.*(uv.x))) + 0.2 + uv.y + floor(7. * uv.x * uv.x);\n    r = smoothstep(0.0, 0.01, sineDist);\n    col = r * col + 1.8 * (0.5 + uv.y) * (1.0 - r) * conc_col;\n\n    // Third row of buildings\n    sineDist = -0.1*sin(2. + floor(35.*(uv.x))) - 0.05*sin(98. + floor(45.*(uv.x))) + 0.4 + uv.y + floor(4.* uv.x * uv.x);\n    r = smoothstep(0.0, 0.01, sineDist);\n    col = r * col + 1.1*(0.2 + uv.y) * (1.0 - r) * conc_col;\n\n    // Second row of buildings\n    sineDist = -0.2*sin(1. + floor(35.*(uv.x))) - 0.1*sin(98. + floor(45.*(uv.x))) + 0.4 + uv.y + floor(4.* uv.x * uv.x);\n    r = smoothstep(0.0, 0.01, sineDist);\n    col = r * col + (0.5 + uv.y) * (1.0 - r) * conc_col;\n\n    // Ground\n    vec2 d = abs(uv - vec2(0, water_height)) - vec2(0.49, 0.02);\n    float dist = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    r = smoothstep(0., 0.01, dist);\n    col = r * col + (0.5 + uv.y) * (1. - r) * conc_col;\n\n    // Water\n    dist = y - water_height;\n    r = smoothstep(0.0, 0.01, dist);\n    float r2 = smoothstep(0.0, 1.0, 0.5*circleDist);\n    col = r * col + (1.-r2) * (1.0 - r) * water_col * col;  \n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    float A = float (AA*AA);\n    \n    for (int x=0; x < AA; x++)\n        for (int y=0; y < AA; y++)\n            col += render(fragCoord + vec2(x, y) - A / 2.) / A;\n\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}