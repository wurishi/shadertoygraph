{"ver":"0.1","info":{"id":"ftyfRw","date":"1664255030","viewed":356,"name":"Edge Detection - Gavin","username":"whereisgavin","description":"I compare a random sample from a small local area around each pixel to determine how different each pixel is from its neighbors.\n\nPlay with the const variables at the top!","likes":7,"published":1,"flags":2,"usePreview":0,"tags":["interactive","filter","webcam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//////////////////////////\nconst bool WEBCAM = false;\n\nconst float RADIUS = 0.05; //MOST IMPORTANT, CHANGE THIS: 0 < RADIUS < 1.0\n\nconst bool HIGHLIGHT_DARKER = true;\nconst bool HIGHLIGHT_LIGHTER = true;\nconst bool VIEW_ORIG = false;\nconst bool VHS = false;\n\nconst float CONTRAST = 1.0;\n\nconst int NUM_SAMPLES = 10;\n//////////////////////////\n\n\n\nvec3 localDiff(vec2 uv, int seed)\n{   \n    //Distortion\n    float mag = RADIUS;\n    \n    int xDistMagSeed = seed * iFrame * 3;\n    int yDistMagSeed = seed * iFrame * 4;\n    \n    float xDistMag = nextFloat(xDistMagSeed, mag);\n    float yDistMag = nextFloat(yDistMagSeed, mag);\n    \n    int angleSeed = 20 * iFrame * seed;\n    int radiusSeed = 7 * iFrame * seed;\n    \n    float angle = VHS ? 0.0 : nextFloat(angleSeed);\n    \n    \n    vec2 distortion = nextFloat(radiusSeed) *\n                      vec2(cos(angle * 2.0 * PI),  \n                           sin(angle * 2.0 * PI));\n                      \n    distortion.x *= xDistMag;\n    distortion.y *= yDistMag;\n                          \n    vec2 distUv =  distortion + uv;\n    \n    //Sample\n    vec3 samp = WEBCAM ? texture(iChannel0, uv).xyz\n                       : texture(iChannel1, uv).xyz;\n    vec3 distSamp = WEBCAM ? texture(iChannel0, distUv).xyz\n                           : texture(iChannel1, distUv).xyz;\n                \n    //Contrast\n    samp += (samp - 0.5) * (CONTRAST - 1.0);\n    distSamp += (distSamp - 0.5) * (CONTRAST - 1.0);\n    \n    //Edge Detection\n    float diff = length(distSamp) - length(samp);\n    float bright = 0.3;\n    diff = diff * bright * ((1.0 / sqrt(RADIUS) + 1.0));\n    float posDiff = max(diff, 0.0);\n    posDiff = (posDiff * posDiff) / bright;\n    float negDiff = -1.0 * min(diff, 0.0);\n    negDiff = (negDiff * negDiff) / bright;\n    \n            //Similar Neighbors.. maybe useful for autoexposure?\n            float same = max(1.0 - 20.0 * abs(diff), 0.0);\n            \n    return vec3(negDiff, same, posDiff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //UV\n    float scale = iResolution.y / iChannelResolution[0].y;\n    vec2 uv = fragCoord / (scale * iChannelResolution[0].xy);;\n    uv.x = 1.0 - uv.x;\n    \n    //Map Edges    \n    vec3 diff = vec3(0.0);\n    for (int s = 0; s < NUM_SAMPLES; s++)\n    {\n        int seed = (int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x)) * iFrame;\n        diff += localDiff(uv, seed * (s + 9));\n    }\n    \n    vec3 outline = vec3(HIGHLIGHT_LIGHTER ? diff.x : 0.0, \n                    0.0, \n                    HIGHLIGHT_DARKER ? diff.z : 0.0) \n                    / float(NUM_SAMPLES);\n    \n    //Output\n    vec3 color = vec3(outline.r, 0.33 * outline.b, 0.67 * outline.b);\n    \n    if (VIEW_ORIG)\n    {\n        vec3 samp = WEBCAM ? texture(iChannel0, uv).xyz\n                           : texture(iChannel1, uv).xyz;\n        samp += (samp - 0.5) * (CONTRAST - 1.0);\n        color = samp;\n    }\n    \n    if (VHS)\n    {\n        vec3 samp = WEBCAM ? texture(iChannel0, uv).xyz\n                           : texture(iChannel1, uv).xyz;\n        //THIS SECTION USES OUTLINE TO ADD PSEUDO VHS CHROMA SHIFT\n        color = samp;\n\n        //Cool TV effect\n        color *= vec3(1.0 + 0.3 * (diff.r - 2.0 * diff.b), 0.8 , 0.9);\n\n        //Noise\n        float noise = 0.7;\n        int seed = (int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x)) * iFrame;\n        float gray = (1.0 + noise * 0.5) - nextFloat(seed) * noise;\n        color = color * gray;\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926535;\nint MIN = -2147483648;\nint MAX = 2147483647;\n\nint xorshift(in int value) {\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nint nextInt(inout int seed) {\n    seed = xorshift(seed);\n    return seed;\n}\n\nfloat nextFloat(inout int seed) {\n    seed = xorshift(seed);\n    // FIXME: This should have been a seed mapped from MIN..MAX to 0..1 instead\n    return abs(fract(float(seed) / 3141.592653));\n}\n\nfloat nextFloat(inout int seed, in float max) {\n    return nextFloat(seed) * max;\n}\n\nmat3 rotX(float angle)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(angle), sin(angle),\n                0.0, -sin(angle), cos(angle));\n}\n\nmat3 rotY(float angle)\n{\n    return mat3(cos(angle), 0.0, -sin(angle),\n                0.0, 1.0, 0.0,\n                sin(angle), 0.0, cos(angle));\n}\n\nmat3 rotZ(float angle)\n{\n    return mat3(cos(angle), sin(angle), 0.0,\n                -sin(angle), cos(angle), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nmat3 rotation( float x, float y, float z )\n{\n    return rotY(y) * rotX(x) * rotZ(z);\n}","name":"Common","description":"","type":"common"}]}