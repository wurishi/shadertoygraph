{"ver":"0.1","info":{"id":"XtcyDf","date":"1534278437","viewed":146,"name":"3D Disc Symmetry","username":"dust","description":"A quick shader to get my mind around aiekick's rotational symmetry function (https://www.shadertoy.com/view/XtBcRV).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","sdf","symmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uses aiekick's symmetry function\n// aiekick: https://www.shadertoy.com/view/XtBcRV\n// iq's optimized alternative: https://www.shadertoy.com/view/XtSczV\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Simple marching loop\n    vec3 eyePos = vec3(0, 0.0, -3.0);\n    vec3 rayDir = RayDir(fragCoord,\n                         iResolution.xy);\n    float currRayDist = 0.0;\n    vec3 rgb = vec3(0.125, 0.125, 0.125);\n    vec2 scTime = vec2(sin(iTime / 2.0), cos(iTime / 2.0));\n    vec3 sph2Pos = vec3(0.0, 2.0, 0.0);\n    for (int i = 0; i < 256; i += 1)\n    {\n        vec3 ray = eyePos + (rayDir * currRayDist);\n        vec3 rayRotated = QtnRotate(eyePos + (rayDir * currRayDist),\n                             \t\tvec4(vec3(0,0,1) * sin(iTime), cos(iTime)));\n        ray = rayRotated;\n        vec2 ray2D = ray.xy;\n        const float radsPerSph = 3.14159f / 8.0f;\n        float theta = (mod(atan(ray2D.y, ray2D.x), radsPerSph * 2.0)) - radsPerSph;\n        ray2D = vec2(cos(theta), sin(theta)) * length(ray2D);\n        float dist = SphDF(vec3(ray2D, ray.z), \n                           vec3(1.0, 0.0, 0.0), \n                           0.25);\n        if (dist < 0.001)\n        {\n            rgb = normalize(ray) + vec3(abs(sin(scTime.x * 2048.0 * sin(iTime / 16.0) * dist)), \n                                        abs(cos(scTime.x * 2048.0 * sin(iTime / 16.0) * dist)), \n                                        abs(sin(float(i) * dist)));\n            break;\n        }\n        else\n        {\n            currRayDist += dist;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float SphDF(vec3 coord,\n            vec3 sphPos,\n            float r)\n{\n    // Fixed-position unit sphere at the origin\n    return length(coord - sphPos) - r;\n}\n\n// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz, qtn.w * -1.0);\n}\n\n// Compute the product of two quaternions\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\nvec3 RayDir(vec2 pixPos,\n            vec2 viewSizes)\n{\n    vec3 dir = vec3(pixPos - (viewSizes / 2.0),\n                \tviewSizes.y / tan(1.62 / 2.0));\n    return normalize(dir);\n}\n","name":"Common","description":"","type":"common"}]}