{"ver":"0.1","info":{"id":"l3syDH","date":"1728163702","viewed":23,"name":"Hyperbolic Plane Constructions","username":"evvsb","description":"Final artefact for HPQ\nSome bugs need to be smoothed out alongside adding better antialiasing","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["mouse","construction","hyperbolic","geodesic"],"hasliked":0,"parentid":"4cjfz3","parentname":"geodesic in half plane model"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// need to put everything into functions and draw proper costruction lines somehow for poincare\n#define lineWidth 1.0 / iResolution.y\n#define smoothWidth 3./iResolution.y\n\n// uncomment for antialiasing of line segments\n//#define antialias\n\n\n// uncomment to show:\n//   - 2 other green geodesics\n//   - construction lines for the yellow geodesic\n//   - the 2 or 3 points\n//   - the full geodesics\n\n//#define showTriangle\n//#define showConstructions\n#define showPoints\n#define showFullGeodesics\n\n// uncomment for poincare disk model (work in progress)\n//#define poincare\n//#define showInversePoints\n\nvec2 complex_conjugate(vec2 a)\n{\n    return vec2(a.x,-a.y);\n}\n\nvec2 complex_inversion(vec2 a)\n{\n    return vec2(a.x,-a.y)/vec2(a.x*a.x+a.y*a.y);\n}\n\nvec4 calcCentreMidpoint(vec2 a, vec2 b) {\n    vec2 midpoint = vec2((a.x+b.x)/2.,(a.y+b.y)/2.);\n    float gradient = (b.y-a.y)/(b.x-a.x);\n    float perpGradient = -1./gradient;\n    \n    float c = midpoint.y-perpGradient*midpoint.x;\n    float xintercept = -c / perpGradient;\n    float radius = length(a-vec2(xintercept,0.));\n       \n    return vec4(xintercept, midpoint, radius);\n}\n\n\nvoid circleSDF(vec2 uv, vec2 p, float r, inout vec3 pixel, vec3 col)\n{\n    float t = length(uv-p);\n \n    if (t<r+0.0025 && t>r-0.0025)\n    {\n        pixel=col;\n    }\n    \n     //  float t = 1.0 - smoothstep(0.0, lineWidth, abs(r-dist));\n    //if (t+0.5*lineWidth > r && t-0.5*lineWidth < r) {\n        \n  //      pixel = mix(pixel, col, smoothstep(smoothWidth, 0.0, p.x - lineWidth));\n   // }\n    \n    //return length(uv-p)-r;\n}\nvoid outDiskSDF(vec2 uv, vec2 p, float r, inout vec3 pixel, vec3 col) {\n    if(length(uv-p)>r){pixel=col;}\n}\nvoid diskSDF(vec2 uv, vec2 p, float r, inout vec3 pixel, vec3 col){\n    float dist = length(uv-p);\n    if (dist<r){pixel=col;}\n}\n  \n\nvoid arcSDF(vec2 uv, vec2 p, float r, inout vec3 pixel, vec3 col, vec2 a, vec2 b) {\n     if (length(uv-p)<r+0.003 && length(uv-p)>r-0.003) {\n        if (a.x<b.x && uv.x>a.x && uv.x<b.x) {\n            pixel = col;\n        } else if (a.x>b.x && uv.x<a.x && uv.x>b.x) {\n            pixel = col;\n        }\n    }\n}\n\n// credit to iq\nvoid lineSegSDF(vec2 p, vec2 a, vec2 b, inout vec3 pixel, in vec3 col, float thickness) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float dist = length(pa - h*ba);\n\n    #ifdef antialias\n   // thanks @elenzil for the help on antialiasing\n        pixel = mix(pixel, col, smoothstep(smoothWidth, 0.0, dist - lineWidth));\n\t//return length(pa - h * ba);\n    #else\n         if (dist < thickness) {\n            pixel = col;\n         }\n    #endif   \n}\n\nvoid verticalLineSDF(vec2 p, vec2 a, inout vec3 pixel, in vec3 col)\n{\n    if (p.x > a.x-0.0025 && p.x < a.x+0.0025) {\n        pixel = col;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*vec2(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv.y += .8;\n    //bg\n    vec3 col = vec3(0.4,0.5,0.6);\n   \n    \n    vec2 mouse = 2.0*vec2(iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    mouse.y+= .8;\n    \n    \n    // points\n    vec2 a = vec2(-0.5, 0.5); // pink point\n    \n    if (mouse.y>=0.){\n        a = vec2(mouse.x, mouse.y);\n    } else {\n        a = vec2(mouse.x, 0.);\n    }\n    vec2 b = vec2(0.5,0.5); // red point\n    vec2 c = vec2(0.7,0.7); // green point\n     \n    // centres midpoints and radii\n    vec4 AB = calcCentreMidpoint(a, b);\n    vec2 centreAB = vec2(AB.x, 0.);\n    vec2 midpointAB = AB.yz;\n    float radiusAB = calcCentreMidpoint(a,b).w;\n    vec4 BC = calcCentreMidpoint(b,c);\n    vec2 centreBC = vec2(BC.x, 0.);\n    float radiusBC = BC.w;    \n    vec2 centreCA = vec2(calcCentreMidpoint(c,a).x,0.);\n    float radiusCA = calcCentreMidpoint(c,a).w;\n    \n    // options\n    #ifndef poincare\n        #ifdef showFullGeodesics\n            circleSDF(uv,centreAB,radiusAB,col, vec3(0.2,0.3,0.4));\n            #ifdef showTriangle\n                circleSDF(uv, centreBC, radiusBC,col,vec3(0.2,.3,.4));\n                circleSDF(uv,centreCA,radiusCA, col, vec3(.2,.3,.4));\n            #endif\n        #endif\n\n        #ifdef showConstructions\n            if (a.x!=b.x) {\n                lineSegSDF(uv,  a, b, col, vec3(1.), 0.005);    \n\n                lineSegSDF(uv, midpointAB, centreAB, col, vec3(0.), 0.005);\n            }\n            circleSDF(uv,midpointAB,0.005,  col, vec3(1.,1.,0.));\n\n        #endif\n\n        if (a.x!=b.x) {\n            arcSDF(uv, centreAB, radiusAB, col, vec3(1.,1.,0.2), a, b);\n\n\n        } else {\n            #ifdef showFullGeodesics\n                verticalLineSDF(uv, a, col, vec3(.2,.3,.4));\n            #endif\n            lineSegSDF(uv, a, b, col, vec3(1.,1.,0.2), 0.0025);\n\n        }    \n        #ifdef showTriangle\n            if (a.x!=c.x) {\n                arcSDF(uv, centreCA, radiusCA, col, vec3(0.2,0.8,0.1), c, a);\n            } else {\n                //broken\n                lineSegSDF(uv, a, b, col, vec3(1.,1.,0.2), 0.025);\n\n            } \n            arcSDF(uv, centreBC, radiusBC, col, vec3(0.2,0.8,0.1), b, c);\n         //   arcSDF(uv, centreCA, radiusCA, col, vec3(0.2,0.8,0.1), c, a);\n\n        #endif\n\n        // drawing points\n        #ifdef showPoints\n            diskSDF(uv,b,0.005,col, vec3(1.,0.,0.));\n            diskSDF(uv,a,0.005,col, vec3(1.,0.,1.));\n            #ifdef showTriangle\n                diskSDF(uv, c, 0.005, col, vec3(.1,.5,.1)); \n            #endif\n            \n        #endif\n        if (uv.y<0.) {\n            col = vec3(0.6);\n        }\n        \n    //poincare disk model\n    #else \n        uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n        uv *= 1.05;\n        mouse = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n        mouse *= 1.05;\n                  \n        // background colour\n        col = vec3(0.6);\n        // poincare disk\n        diskSDF(uv,vec2(0.), 1., col, vec3(0.4,0.5,0.6));\n\n        // plotting points and inverse points\n        b = vec2(mouse.x,mouse.y);\n        a = vec2(0.5,0.5);\n        vec2 a1 = complex_inversion(complex_conjugate(a));\n        vec2 b1 = complex_inversion(complex_conjugate(b));\n        \n        //midpoints\n        vec2 midpointaa1 = vec2(calcCentreMidpoint(a,a1).yz);\n        vec2 midpointbb1 = vec2(calcCentreMidpoint(b,b1).yz);\n        \n        // drawing the perp bisector by finding equation of perp line then a pair of coords \n        // on that line. then finding the y intercept of both to find the equations \n        \n        // --- to do, draw proper costruction lines somehow --- \n        float gradient = (a.y-a1.y)/(a.x-a1.x);\n        float perpGradient2 =-1./((b.y-b1.y)/(b.x-b1.x));\n        float perpGradient1 = -1./gradient;\n        float yintercept1 = midpointaa1.y-perpGradient1*midpointaa1.x;\n        float yintercept2 = midpointbb1.y-perpGradient2*midpointbb1.x;\n        // then finding intersection between two perp bisectors and distance between the \n        // point of itnersection and a, therefore finding the radius + drawing the geodesic\n   \n        float crossX = (yintercept2 - yintercept1)/(perpGradient1-perpGradient2);\n        float crossY = perpGradient1 * crossX + yintercept1;\n        float rad = length(b - vec2(crossX,crossY));\n        #ifdef showFullGeodesics\n            circleSDF(uv,vec2(crossX, crossY),rad, col, vec3(1.,1.,0.));\n        #endif\n        #ifdef showConstructions\n            vec2 onLine = vec2(calcCentreMidpoint(a,a1).x, 0.);\n            lineSegSDF(uv, a, a1, col, vec3(0.), 0.0025);\n\n            lineSegSDF(uv, midpointaa1, onLine, col, vec3(0.), 0.0025);\n            //midpoints\n            diskSDF(uv, midpointaa1, 0.007, col, vec3(1.,1.,0.));\n\n            diskSDF(uv, midpointbb1, 0.007, col, vec3(1.,1.,0.));\n            //centre of geodesic circle\n            circleSDF(uv,vec2(crossX, crossY),0.005, col, vec3(1.,1.,0.));\n\n        #endif\n        //colouring over the outside of the circle again at the end\n        \n        #ifndef showConstructions\n            outDiskSDF(uv, vec2(0.), 1., col, vec3(.6));\n        #endif\n        //points and inverse points\n        diskSDF(uv,a,0.007,col, vec3(1.,0.,0.));\n        diskSDF(uv,b,0.007,col, vec3(1.,.2,1.));\n        #ifdef showInversePoints\n            diskSDF(uv, b1, 0.007, col, vec3(1.));\n            diskSDF(uv, a1, 0.007, col, vec3(1.));\n        #endif\n       \n    #endif\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}