{"ver":"0.1","info":{"id":"tlVXz1","date":"1583438121","viewed":100,"name":"Torus rotating","username":"Kaola","description":"Move view with mouse, position with wasd + space and shift.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int maxRaySteps = 85; // = Contrast and loss of Detail \nconst float MinDistance = 0.01;\nconst float MaxDistance = 1000.0;\n\nconst float speed = 1.1;\nconst float shadowStrength = .13; //SoftShadow\n\nconst float RED = 11.2; //any number\nconst float GREEN = 1.2; // any number\nconst float BLUE = 0.95; //0-1\nconst vec3 lightsource = vec3(4.0,15.0,4.0);\n\n\nmat2 Rot(float a){\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat SDFCapsule(vec3 pos, vec3 a, vec3 b, float radius){ \n    vec3 ap = pos-a;\n    vec3 ab = b-a;\n    float distToA = dot(ap,ab) / dot(ab,ab);\n    distToA = clamp(distToA, 0.0, 1.0);\n\tvec3 nearPoint = a+ab*distToA;\n    float dist = length(pos-nearPoint)-radius;\n    \n    return dist;\n\n}\n\nfloat SDFTorus(vec3 TorusPos, float radius, float thickness){\n\tfloat x = length(TorusPos.xz)-radius;\n    float y = TorusPos.y;\n\tfloat dist = length(vec2(x, y));\n    \n    return (dist - thickness/2.0) ;//+ ( sin(TorusPos.x+.2)*sin(TorusPos.z+.92)*sin(TorusPos.y*.5))-.21;\n\n}\n\nfloat SDFCube(vec3 CubePos, float size){\n    return abs(length(max(abs(CubePos)-size, 0.0)));\n\n\n\n}\n\nfloat SDFSphere(vec3 SpherePos, float radius){\n\t\n    return length(SpherePos)-radius;\n}\n\n\nfloat DE(vec3 pos) {\n    vec3 bp = pos-vec3(10.,1.,0.);\n    bp.xz *= Rot(iTime*1.2);\n\n    vec3 tp = pos-vec3(4.0,5.0,4.0);\n    tp.xy *= -Rot(iTime*.5*speed);\n    tp.yz *= Rot(iTime*.2*speed+5.);\n    tp.xz *= -Rot(iTime*.5*speed+2.);\n    \n   \tvec3 tp2 = pos - vec3(4.,5.,4.);\n    tp2.xy *= Rot(iTime*.5*speed+.2);\n    tp2.yz *= -Rot(iTime*.2*speed+.2);\n    tp2.xz *= Rot(iTime*.5*speed+.5);\n    \n    vec3 tp3 = pos - vec3(4.,5.,4.);\n    tp3.xy *= Rot(iTime*.3*speed+.8);\n    tp3.yz *= -Rot(iTime*.7*speed+2.2);\n    tp3.xz *= Rot(iTime*.1*speed+2.5);\n    \n    vec3 sp = pos - vec3(-6.,5.,5.);\n    sp *= vec3(1.,4.,1.);\n    sp /= 4.;\n    \n    float TorusDist = min(SDFTorus(tp3,6.,1.5),min(SDFTorus(tp2,3.,1.),SDFTorus(tp,1.,.5)));\n    float CapsuleDist = SDFCapsule(pos,vec3(4.5*cos(iTime*speed)+4.,4.,4.5*sin(iTime*speed)+4.),vec3(4.5*cos(iTime*speed)+4.,6.,4.5*sin(iTime*speed)+4.),0.2);\n    float Capsule2Dist = SDFCapsule(pos,vec3(3.,4.*-cos(iTime*speed+1.57)+5.,4.*-sin(iTime*speed+1.57)+4.),vec3(5.,4.*-cos(iTime*speed+1.57)+5.,5.*-sin(iTime*speed+1.57)+4.),0.2);\n    float PlaneDist = pos.y+10.0;\n    \n    \n    float neardistance = min(min(min(TorusDist,PlaneDist),CapsuleDist),Capsule2Dist);\n    \n    return max(neardistance,0.);\n}\n\n\nfloat shade(vec3 pos, vec3 light){\n\t\n    vec3 lightdir = normalize(light-pos);\n    float maxDist = length(pos-light);\n    float minDist = shadowStrength;\n    pos += lightdir * minDist*0.5;\n    float totalDist = .0;\n    for(int steps = 0; steps<maxRaySteps; steps++){\n        vec3 p = pos + totalDist * lightdir;\n        float ldistance = DE(p);\n        totalDist += ldistance; \n        if(steps>1 && minDist>ldistance){minDist = ldistance;}\n        if(totalDist>maxDist){break;}\n    }\n    return clamp(pow(minDist*(1./shadowStrength)+0.01,0.5),0.,1.);\n\n}\n\n\n\nvec2 trace(vec3 position, vec3 direction){\n\tfloat totalDistance = 0.0;\n    int finalsteps = 0;\n    for(int steps=0;steps<maxRaySteps;steps++){\n    \tvec3 p = position + totalDistance*direction;\n        float ldistance = DE(p);\n        totalDistance += ldistance;\n        finalsteps = steps;\n        if(ldistance<MinDistance){break;}\n        if(totalDistance>MaxDistance){\n            finalsteps = maxRaySteps;\n            break;}\n    }\n    float AmbOcc = 1. - float(finalsteps) / float(maxRaySteps);\n    \n    return vec2(totalDistance, AmbOcc);\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n    vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 )*6.28318530718;\n    \n    vec3 ray = normalize( vec3( (fragCoord.xy-iResolution.xy*.5)/iResolution.x, 2. ) );\n    \n    ray.zy = ray.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ray.yz;\n    ray.xz = ray.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ray.zx;\n\t\n    \n    vec3 eye = camPos.xyz+vec3(4.,5.,-10.);\n    \n    float color = 0.;\n    \n    vec2 temp = trace(eye, ray);\n    float totalDist = temp.x;\n    float Ambient = temp.y;\n    \n    if(totalDist<MaxDistance*0.5){\n       \tcolor = pow(clamp(0.,1.,1./totalDist),.02);\n    \tvec3 point = eye + ray * totalDist;\n    \tvec3 lightdir = normalize(point-lightsource);\n        color = pow(shade(point, lightsource) * color,.4);}\n    else if(totalDist>MaxDistance*0.5 && totalDist < MaxDistance){\n        float gradient = (totalDist - 1000. * -1.) / 500.;}\n    \n    Ambient *= clamp(0.5*rand(vec2(iTime,1./iTime)),0.9,1.);\n    \n    color *= Ambient;\n\n    \n    \n    \n    \n    fragColor = vec4(0.25*(1.0/(color+RED)),pow(color,GREEN), color*BLUE, 1.0);\n    //fragColor = vec4(light,light, light, 1.0);\n\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Hazel Quantock 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float accel = .2;\nconst float decay = .60; // how much velocity is preserved per frame (proportionally)\n\n\nconst float yMul = -1.0;\n\n\n\n// keys are javascript keycode\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\t\t\t\t\tconst int Key_Shift = 16;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n            vec4 camVel = textureLod( iChannel0, vec2(3.5,.5)/iResolution.xy, 0.0 );\n            \n            fragColor = camPos + camVel;\n\n            //if ( camPos.y < .0 ) { fragColor.y = .0; }\n\n            // fly\n            fragColor.w = ReadKeyToggle(Key_F);\n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = textureLod( iChannel0, vec2(2.5,.5)/iResolution.xy, 0.0 );\n            vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 );\n\n            vec2 mouseRot = (iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( int(fragCoord.x) == 1 )\n            {\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n        else if ( int(fragCoord.x) == 3 )\n        {\n            vec4 camPos = texture( iChannel0, vec2(.5,.5)/iResolution.xy, -100.0 );\n            vec4 camVel = texture( iChannel0, vec2(3.5,.5)/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 )*6.28318530718;\n            \n           \n            \n\n            \n            vec3 forward = vec3(0,0,1)*accel;\n            vec3 right = vec3(1,0,0)*accel;\n\t\t\tvec3 up = vec3(0,1,0)*accel;\n           \n                forward.zy = forward.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*forward.yz;\n                right.zy = right.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*right.yz;\n            \t\n                \n            forward.xz = forward.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*forward.zx;\n\t\t    right.xz = right.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*right.zx;\n            \n            camVel.xyz += (ReadKey(Key_W)-ReadKey(Key_S)) * forward;\n            camVel.xyz += (ReadKey(Key_D)-ReadKey(Key_A)) * right;\n\t\t\tcamVel.xyz += (ReadKey(Key_Space)-ReadKey(Key_Shift)) * up;\n            \n            camVel *= decay; // exponential decay\n            \n            \n            fragColor = camVel;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}