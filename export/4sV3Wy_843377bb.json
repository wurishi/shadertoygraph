{"ver":"0.1","info":{"id":"4sV3Wy","date":"1456222175","viewed":190,"name":"Basic ray sphere","username":"Liuban","description":"Doing a basic test with ray tracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","reflects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n\tvec3 origin;\n\tvec3 direction;\t\n};\n\nstruct Sphere {\n\tvec3 center;\n\tfloat radius;\n    vec4 color;\n};\n\nstruct Plane {\n\tvec3 p;\n    vec3 normal;  \n    vec4 color;\n};\n    \nstruct DirectionalLight {\n\tvec3 dir;\n    vec3 diff;\n    vec3 spec;\n};\n    \nDirectionalLight light;\nPlane ground;\nSphere spheres[3];\nconst int amount = 3;\nconst int bounces = 1;\n   \nfloat interesect_ray_plane(Ray R, Plane P, out vec3 hitpos, out vec3 normal) {\n\tfloat a = dot(P.normal, (P.p - R.origin));\n    float b = dot(P.normal, R.direction);\n    return a / b;\n}\n\nfloat interesect_ray_sphere(Ray R, Sphere S, out vec3 hitpos, out vec3 normal) {\n\tvec3 v = R.origin - S.center;\n\tfloat B = dot(R.direction, v);\n\tfloat C = dot(v,v) - S.radius * S.radius;\n\tfloat B2 = B * B;\n\tfloat f = B2 - C;\n\tif(f < 0.0) {\n\t\treturn 0.0;\n\t}\n\tfloat s = sqrt(f);\n\tfloat t0 = -B + s;\n\tfloat t1 = -B - s;\n\tfloat t = min(max(t0, 0.0), max(t1, 0.0));\n\tif(t == 0.0) {\n\t\treturn 0.0;\n\t}\n\thitpos = R.origin + t * R.direction;\n\tnormal = normalize(hitpos - S.center);\n\treturn t;\n}\n\nfloat applyDirLight(DirectionalLight light, vec3 view_dir,\n                   vec3 norm,\n                   inout vec4 frag, in vec4 albedo, float intensity) {\n    \n\tvec3 light_dir = light.dir;\n\n\tfloat angle = clamp(dot(norm, light_dir), 0.0, 1.0);\n\tvec4 diff = vec4(light.diff * angle, 0.0) * albedo;\n\tvec4 spec = vec4(0.0);\n\tif(angle > 0.0) {\n\t\tvec3 vec_l = normalize(light_dir + view_dir);\n\t\tspec = vec4(light.spec, 1.0);\n\t\tfloat s = pow(max(dot(norm, vec_l), 0.0), 150.0);\n\t\tspec *= s;\n\t}\n\tfrag += (diff + spec) * intensity;\n    return angle;\n}\n\nvoid applyBounce(vec3 origin, vec3 norm, vec3 view_dir, inout vec4 frag, float intensity) {\n\tfloat t;\n    float inten = intensity;\n    vec3 hitpos;\n    vec3 normal;\n    vec3 valid_hitpos = origin;\n    vec3 valid_normal = norm;\n    int bounce_id = 0;\n    for(int bounce_id = 0; bounce_id < bounces; bounce_id++) {\n        float min_t = 1000000.0;\n        bool found = false;\n    \tfor(int i=0; i<amount; i++) {\n            Ray ray;\n            ray.origin = valid_hitpos;\n            ray.direction = valid_normal;\n            t = interesect_ray_sphere(ray, spheres[i], hitpos, normal);\n            if(t != 0.0) {\n                if(t < min_t) {\n                    found = true;\n                    view_dir = ray.origin - spheres[i].center;\n                    min_t = t;\n                    valid_hitpos = hitpos;\n                    valid_normal = normal;\n                    applyDirLight(light, view_dir,\n                       valid_normal,\n                       frag, spheres[i].color, 2.0);\n                }\n            }\n        }\n        if(!found) {\n            \tbreak;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Init ray\n    Ray ray;\n\tvec2 p = (2.0 * fragCoord - vec2(640.0, 480.0)) / 480.0;\n\tray.origin = vec3(0.0, 2.0, 6.0);\n\tray.direction = normalize( vec3(p,-2.0));\n    //Init floor\n    ground.p = vec3(0.0, -4.0, 0.0);\n    ground.normal = vec3(0.0, 1.0, 0.0);\n    ground.color = vec4(0.6, 0.6, 1.0, 1.0);\n    //Init spheres\n    spheres[0] = Sphere(vec3(4.0 * cos(iTime), sin(iTime) * 2.0 + 1.5, sin(iTime) * 4.0 - 6.0), 1.0, vec4(1.0, 0.0, 0.0, 1.0));\n\tspheres[1] = Sphere(vec3(1.5, -1.5, -4.0),1.0, vec4(0.5, 1.0, 0.0, 1.0));\n    spheres[2] = Sphere(vec3(0.0, 0.0, -8.0), 2.5, vec4(1.0, 0.7, 0.0, 1.0));\n    //Init lights\n    light.dir = normalize(vec3(0.5, 0.5, 1.0));\n    light.diff = vec3(1.0, 1.0, 1.0);\n    light.spec = vec3(1.0);\n    \n    //Start calculation\n    vec3 view_dir;\n    vec3 hitpos;\n\tvec3 normal;\n\tfloat t;\n\tfloat min_t = 1000000.0;\n\tvec3 valid_hitpos;\n\tvec3 valid_normal;\n    bool found = false;\n    t = interesect_ray_plane(ray, ground, hitpos, normal);\n    if(t >= 0.0) {\n        found = true;\n    \tfragColor = vec4(0.0);\n        float inten = applyDirLight(light, view_dir, ground.normal, fragColor, ground.color, 1.0);\n    }\n\tfor(int i=0; i<amount; i++) {\n\t\tt = interesect_ray_sphere(ray, spheres[i], hitpos, normal);\n\t\tif(t != 0.0) {\n\t\t\tif(t < min_t) {\n                found = true;\n                view_dir = ray.origin - spheres[i].center;\n\t\t\t\tmin_t = t;\n\t\t\t\tvalid_hitpos = hitpos;\n\t\t\t\tvalid_normal = normal;\n                fragColor = vec4(0.0);\n                float inten = applyDirLight(light, view_dir,\n                   valid_normal,\n                   fragColor, spheres[i].color, 1.0);\n\t\t\t\tapplyBounce(valid_hitpos, valid_normal, view_dir, fragColor, inten);\n\t\t\t}\n        }\t\t \n\t} \n    if(!found) {\n\t    fragColor = vec4(0.4, 0.4, 1.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}