{"ver":"0.1","info":{"id":"MdKGRm","date":"1453842554","viewed":111,"name":"Circles_17627","username":"ddsol","description":"Makes circles","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define SMOOTH\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxRadius = min(iResolution.x, iResolution.y) * 0.5; //Radius of the circle in pixels\n    \n    vec2 center = iResolution.xy * vec2(0.5); //Center of the circle in pixels\n    \n    center += vec2(sin(iTime*1.22),cos(iTime*1.37))*vec2(maxRadius / 4.0);\n\n    vec2 relative = fragCoord.xy - center; //Coordinate relative to center of circle in pixels\n\n    vec2 unit = relative / vec2(maxRadius); //Coordinate relatyive to center of circle in units -1.0 to 1.0 (double unit really).\n    \n    float smoothing = 1.0/min(iResolution.x, iResolution.y)*1.5; //Size of smoothing area relative to (double) unit circle\n    \n    //Web rgba format colors\n    vec4 color1 = vec4(120,60,0,0.8) / vec4(255,255,255,1.0);\n    float radius1 = 0.5+sin(iTime)*0.2; //Radius is relative to maxRadius\n    \n    vec4 color2 = vec4(0,120,30, 1.0) / vec4(255,255,255,1);\n    float radius2 = 0.85+sin(iTime*0.77)*0.15; //Radius is relative to maxRadius\n    \n    \n    float dist = length(unit); //Distance to center where 1 = at edge of maxRadius circle\n    \n    #ifdef SMOOTH\n    \n\n    \t//make input colors  (sRGB) linear\n        float gamma = 2.2;\n        color1.rgb = pow(color1.rgb, vec3(gamma));\n        color2.rgb = pow(color2.rgb, vec3(gamma));\n    \n        //Use smoothstep to go from inside to outside circle to do anti-aliasing\n    \tvec4 col = mix(\n            mix(\n                color1,\n                color2,\n                smoothstep(\n                    radius1 - smoothing,\n                    radius1 + smoothing,\n                    dist\n                )\n            ),\n            vec4(0,0,0,0),\n            smoothstep(\n                radius2 - smoothing,\n                radius2 + smoothing,\n                dist\n            )\n        );\n\n        //Gamma correction (prevents color fringes)\n        //Turn color back to sRGB\n        col.rgb = pow(col.rgb, vec3(1.0 / gamma));\n        fragColor = col;\n    \n    #else\n    \n        if (dist<radius1) {\n            fragColor = vec4(color1,1);\n        } else if (dist<radius2) {\n            fragColor = vec4(color2,1);\n        } else {\n            fragColor = vec4(0);\n        }\n\n    #endif\n    \n    //pre-multiply rgb because shadertoy has no real transparency.\n    fragColor.rgb *=fragColor.a;\n    \n}","name":"Image","description":"","type":"image"}]}