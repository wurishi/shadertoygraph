{"ver":"0.1","info":{"id":"4scXW7","date":"1459579728","viewed":253,"name":"Rectangle Circle Line Collisions","username":"anastadunbar","description":"Collision functions for making games that doesn't have built-in collision functions.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","collision","geometry","intersect","shape","touch","bounding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Collision functions.------------------------------------------------------------------------------------------\n//First two ones is very obvious if you are a GLSL user.\nbool onedimensional_bounding(float p1,float t1,float p2,float t2) {\n\treturn (p1<(p2+t2) && p2<(p1+t1));\n}\nbool circle_point_bounding(vec2 pos,float rad,vec2 point) {\n    return (length(pos-point)<rad);\n}\nbool circle_circle_bounding(vec2 pos1,float rad1,vec2 pos2,float rad2) {\n    return (length(pos1-pos2)<rad1+rad2);\n}\n//http://stackoverflow.com/a/402010/4538129\nbool circle_rectangle_bounding(vec2 cpos,float rad,vec2 rpos,vec2 rsize) {\n    vec2 circleDistance = abs(cpos.xy-rpos.xy);\n    if (circleDistance.x > ((rsize.x/2.) + rad)||circleDistance.y > ((rsize.y/2.) + rad)) { return false; }\n    if (circleDistance.x <= (rsize.x/2.)||circleDistance.y <= (rsize.y/2.)) { return true; }\n    float cornerDistance = pow(circleDistance.x-(rsize.x/2.),2.)+pow(circleDistance.y-(rsize.y/2.),2.);\n    return (cornerDistance <= rad*rad);\n}\n//http://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other\nbool rectangle_rectangle_bounding(vec2 rpos1, vec2 rsize1, vec2 rpos2, vec2 rsize2) {\n    rpos1.xy-=rsize1.xy/2.;\n    rpos2.xy-=rsize2.xy/2.;\n  float ulx = max(rpos1.x,rpos2.x);\n  float uly = max(rpos1.y,rpos2.y);\n  float lrx = min(rpos1.x+rsize1.x,rpos2.x+rsize2.x);\n  float lry = min(rpos1.y+rsize1.y,rpos2.y+rsize2.y);\n  return (ulx <= lrx && uly <= lry);\n}\n//https://www.shadertoy.com/view/4dfXDn\nfloat lineDist(vec2 p, vec2 start, vec2 end)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj );\n}\n//I won't read this -> http://stackoverflow.com/questions/1073336/circle-line-segment-collision-detection-algorithm\nbool circle_line_bounding(vec2 cpos,float rad,vec2 aline,vec2 bline) {\n\treturn (lineDist(cpos,aline,bline)<rad);\n}\n//Graphics------------------------------------------------------------------------------------------------------\n#define PI 3.14159265358979323\nfloat fsin(float x) { return sin(fract(x)*PI*2.); }\nfloat fpsin(float x) { return (sin(fract(x)*PI*2.)+1.)/2.; }\n#define clamps(x) clamp(x,0.,1.)\nfloat pz = 0.003; //Point size\nvec3 draw1(vec2 uv,float time) { //Circle, Circle\n    vec3 c1 = vec3(0.5,fpsin(time*.5),0.3);\n    vec3 c2 = vec3(0.7,fpsin(time*.3),0.2);\n    float g = clamps(step(length(uv-c1.xy),c1.z)+step(length(uv-c2.xy),c2.z))-clamps(step(length(uv-c1.xy),pz)+step(length(uv-c2.xy),pz));\n    //float c = float(circle_point_bounding(c1.xy,c1.z,c2.xy));\n    float c = (float(circle_circle_bounding(c1.xy,c1.z,c2.xy,c2.z))*.5)+((float(circle_circle_bounding(c1.xy,c1.z,uv,c2.z))+float(circle_circle_bounding(uv,c1.z,c2.xy,c2.z)))*.25);\n\treturn vec3(g,c,0.);\n}\nvec3 draw2(vec2 uv,float time) { //Circle, Rectangle\n    vec3 c1 = vec3(fpsin(time*.2),fpsin(time*.5),0.25);\n    vec4 r1 = vec4(0.5,fpsin(time*.13),.5,.5);\n    float g = clamps(step(length(uv-c1.xy),c1.z)+step(max(abs((uv.x-r1.x)/(r1.z/2.)),abs((uv.y-r1.y)/(r1.w/2.))),1.))-step(length(uv-c1.xy),pz);\n    float c = (float(circle_rectangle_bounding(uv,c1.z,r1.xy,r1.zw))*.5)+(float(circle_rectangle_bounding(c1.xy,c1.z,r1.xy,r1.zw))*.5);\n\treturn vec3(g,c,0.);   \n}\nvec3 draw3(vec2 uv,float time) { //Rectangle, Rectangle\n    vec4 r1 = vec4(fpsin((time+.3)*.3),fpsin(time*.13),.3,.3);\n    vec4 r2 = vec4(0.5,fpsin(time*.53),.2,.5);\n    float g = clamps(step(max(abs((uv.x-r1.x)/(r1.z/2.)),abs((uv.y-r1.y)/(r1.w/2.))),1.)+step(max(abs((uv.x-r2.x)/(r2.z/2.)),abs((uv.y-r2.y)/(r2.w/2.))),1.))-(step(length(uv-r1.xy),pz)+step(length(uv-r2.xy),pz));\n    float c = (float(rectangle_rectangle_bounding(r1.xy,r1.zw,r2.xy,r2.zw))*.5)+((float(rectangle_rectangle_bounding(uv,r1.zw,r2.xy,r2.zw))+float(rectangle_rectangle_bounding(r1.xy,r1.zw,uv,r2.zw)))*.25);   \n\treturn vec3(g,c,0.);\n}\nvec3 draw4(vec2 uv,float time) { //Circle, Line\n    vec3 c1 = vec3(fpsin(time*.2),fpsin(time*.5),0.25);\n    vec4 l1 = vec4(0.5,0.3,0.7,0.8);\n    float g = (clamps(step(length(uv-c1.xy),c1.z)+step(lineDist(uv,l1.xy,l1.zw),pz))-step(length(uv-c1.xy),pz));\n    float c = (float(circle_line_bounding(uv,c1.z,l1.xy,l1.zw))+float(circle_line_bounding(c1.xy,c1.z,l1.xy,l1.zw)))*.5;\n\treturn vec3(g,c,0.);   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.xy)-.5;\n    uv.x /= iResolution.y/iResolution.x;\n    uv += .5;\n    float time = iTime;\n    vec3 col = vec3(0.);\n    float show = mod(time*.2,4.);\n    if(show>=0.&&show<1.){col=draw1(uv,time);}\n    if(show>=1.&&show<2.){col=draw2(uv,time);}\n    if(show>=2.&&show<3.){col=draw3(uv,time);}\n    if(show>=3.&&show<4.){col=draw4(uv,time);}\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}