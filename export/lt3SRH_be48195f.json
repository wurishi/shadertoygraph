{"ver":"0.1","info":{"id":"lt3SRH","date":"1478072557","viewed":729,"name":"Smooth Life Growing Blobs","username":"sparrow","description":"Riffing off of davidar's Smooth Life Gliders.  (https://www.shadertoy.com/view/Msy3RD).  Added continuous timestepping.\nI was originally trying to re-create SmoothLifeL, but this turned out to a happy accident.  ","likes":18,"published":1,"flags":32,"usePreview":1,"tags":["automata","continuous","smoothlife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float s = texture(iChannel0, uv).r;\n    // TODO: more interesting color functions.\n    vec3 color = vec3(0.5, 0.36, 1.0);\n\tfragColor = vec4(color * s, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// based on <https://git.io/vz29Q>\n// Copied from davidar's Smooth Life Gliders (https://www.shadertoy.com/view/Msy3RD)\n//\n// ---------------------------------------------\n// SmoothLife (discrete time stepping 2D)\nstruct SmoothLifeParameters {\n\tfloat ra;       // outer radius\n\tfloat rr;       // ratio of radii\n\tfloat b;        // smoothing border width\n\tfloat b1;       // birth1\n\tfloat b2;       // birth2\n\tfloat d1;       // survival1\n\tfloat d2;       // survival2\n\tfloat sn;       // sigmoid width for outer fullness\n\tfloat sm;       // sigmoid width for inner fullness\n    float dt;       // dt per frame\n};\n\n// SmoothLifeL\nconst SmoothLifeParameters p = SmoothLifeParameters(12.0,\n                                                    3.0,\n                                                    1.0,\n                                                    0.305,\n                                                    0.443,\n                                                    0.556,\n                                                    0.814,\n                                                    0.028,\n                                                    0.147,\n                                                    .089);\n    \nfloat smooth_s(float x, float a, float ea) \n{ \n    return 1.0 / (1.0 + exp((a - x) * 4.0 / ea));\n}\n\nfloat sigmoid_ab(float x, float a, float b)\n{\n    return smooth_s(x, a, p.sn) * (1.0 - smooth_s(x, b, p.sn));\n}\n\nfloat sigmoid_mix(float x, float y, float m)\n{\n    float sigmoidM = smooth_s(m, 0.5, p.sm);\n    return mix(x, y, sigmoidM);\n}\n\n// the transition function\n// (n = outer fullness, m = inner fullness)\nfloat snm(float n, float m)\n{\n    return sigmoid_mix(sigmoid_ab(n, p.b1, p.b2), sigmoid_ab(n, p.d1, p.d2), m);\n}\n\nfloat ramp_step(float x, float a, float ea)\n{\n    return clamp((a - x) / ea + 0.5, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // inner radius:\n    const float rb = p.ra / p.rr;\n    // area of annulus:\n    const float PI = 3.14159265358979;\n    const float AREA_OUTER = PI * (p.ra*p.ra - rb*rb);\n    const float AREA_INNER = PI * rb * rb;\n    \n    // how full are the annulus and inner disk?\n    float outf = 0.0, inf = 0.0;\n    for (float dx = -p.ra; dx <= p.ra; dx++) {\n        for (float dy = -p.ra; dy <= p.ra; dy++) {\n        \tvec2 d = vec2(dx, dy);\n        \tfloat r = length(d);\n        \tvec2 txy = fract((fragCoord + d) / iResolution.xy);\n        \tfloat val = texture(iChannel0, txy).x;\n        \tfloat inner_kernel = ramp_step(r, rb, p.b);\n        \tfloat outer_kernel = ramp_step(r, p.ra, p.b) * (1.0 - inner_kernel);\n        \tinf  += val * inner_kernel;\n        \toutf += val * outer_kernel;\n        }\n    }\n    outf /= AREA_OUTER; // normalize by area\n    inf /= AREA_INNER; // normalize by area\n    \n    float s = texture(iChannel0, uv).x;\n    float deriv = 2.0 * snm(outf, inf) - 1.0;\n    s = clamp(s + (deriv * p.dt), 0.0, 1.0);  // Apply delta to state\n    if (iFrame < 10 || iMouse.z > 0.) {\n        s = texture(iChannel1, uv).x > 0.3 ? 1.0 : 0.0;\n    }\n    fragColor = vec4(s, s, s, 1);\n}","name":"Buf A","description":"","type":"buffer"}]}