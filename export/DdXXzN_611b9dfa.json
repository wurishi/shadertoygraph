{"ver":"0.1","info":{"id":"DdXXzN","date":"1668550706","viewed":246,"name":"Test Erosion Algo","username":"Hatchling","description":"Modified spalmer's algorithm to start with large scale and gradually reduce to small scale so it converges. Unfortunately near the end you get banding.","likes":14,"published":3,"flags":32,"usePreview":1,"tags":["procedural","terrain","distance","erosion"],"hasliked":0,"parentid":"Ds23D3","parentname":"Erosion Terrain Fork"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of Hatchling's excellent http://shadertoy.com/view/ddS3WR\n// swapped distance field extrapolation and ray marcher\n// Golfed from 11934 ch down to 4611 so far.\n// With some more effort I could probably improve the noise\n// and fine tune the shape of the mountains more.\n// But I'm pretty happy with it at this point.\n\n#define quat vec4\n\nquat FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis),\n       halfAngle = mag * .5,\n       scalar = sin(halfAngle) / max(mag, .00001);\n    return vec4(angleAxis * scalar, cos(halfAngle));\n}\n\nvec3 qmul(quat q, vec3 v)\n{\n    vec3 t = 2. * cross(q.xyz, v);\n    return v + vec3(q.w * t) + cross(q.xyz, t);\n}\n\nquat qmul(quat a, quat b)\n{\n    quat q;\n    q = vec4(\n        a.wwww * b \n      + (a.xyzx * b.wwwx + a.yzxy * b.zxyy) * vec4(1, 1, 1,-1) \n      - a.zxyz * b.yzxz\n        );\n    return q;\n}\n\n#define CH iChannel0\n#define CHR iChannelResolution[0]\n\nfloat maxHeight()\n{\n    return .3; //200. / CHR.x;        \n}\n\nfloat precis()\n{\n    return 1.5 / CHR.x;        \n}\n\nfloat terrain(vec2 p)\n{\n    p.x /= CHR.x / CHR.y;    \n    p += .5;        \n    if (clamp(p, 0., 1.) != p) return .5;    \n    vec4 t = texture(CH, p);\n    return t.r * maxHeight();\n}\n\nvec3 terrainGrad(vec3 p, out vec2 curv)\n{    \n    float prec = precis();\n    float hC = terrain(p.xz);    \n    vec3 pC = vec3(p.x, hC, p.z),\n      pR = p + vec3(prec, 0,  0),\n      pL = p - vec3(prec, 0,  0),\n      pT = p + vec3( 0, 0, prec),\n      pB = p - vec3( 0, 0, prec);    \n    pR.y = terrain(pR.xz);\n    pL.y = terrain(pL.xz);\n    pT.y = terrain(pT.xz);\n    pB.y = terrain(pB.xz);    \n    vec3 n = normalize(cross(pT - pB, pR - pL));    \n    float cx = dot(pC + pC - pR - pL, n),\n          cy = dot(pC + pC - pT - pB, n);\n    curv = vec2(cx, cy) / prec;\n    return n;\n}\n\n// recombined\nvec3 skybox(vec3 dir, bool blurry)\n{\n    float g = dir.y * .5 + .5;\n    if (!blurry) {\n        g *= g;\n        g *= g;\n    }\n    g = 1.-g;\n    g *= g * g;\n    if (!blurry) {\n        g *= g;\n        g *= g;\n    }\n    g = 1.-g;\n    if (!blurry) {\n        g = smoothstep(0., 1., g);\n        g = smoothstep(0., 1., g);\n        g = smoothstep(0., 1., g);\n        g = smoothstep(0., 1., g);\n    }    \n    vec3 h = pow(vec3(g), vec3(8, 1, 1));\n    h = vec3(1.)-h;\n    h = pow(h, vec3(.4, .5, 4));\n    h = vec3(1.)-h;    \n    return mix(vec3(.99,.99,.99), vec3(.01,.02,.2), h) * 2.;\n}\n\nvec3 render(vec3 camPos, vec3 camDir)\n{\n    vec3 sky = skybox(camDir, false); // we'll need it regardless\n    if (camPos.y >= 0. && camDir.y >= 0.) \n        return sky; // early out\n\n    const float range = .7;\n    vec3 p = camPos, near = p, far = p + camDir * range;\n    float maxD = 1.;\n    bool hit = false;\n    // prone to undermarching b/c distance scaling is so wack, plus it's noisy\n    // perhaps should run another eikonal smoothing pass to compute actual SDF\n    // or simply use the gamma trick for mip maximum\n    float t = 0.;\n    for (int iter = 384; --iter > 0 && t < range; ) {\n        p = t * camDir + camPos;\n        float h = (p.y - terrain(p.xz)) / maxHeight() / 18.;\n        if (abs(h) < .002 * t) {\n            hit = true; \n            break;\n        }\n        t += .7 * h; // / range;\n    }\n    if (!hit) return sky;\n    maxD = t/range;\n    \n    vec2 curve2;\n    vec3 normal = terrainGrad(p, curve2);\n    \n    vec2 posCurve2 =  max(vec2(0), curve2);\n    vec2 negCurve2 = -min(vec2(0), curve2);\n    \n    float posCurve = posCurve2.x + posCurve2.y;\n    posCurve = posCurve / (.2 + posCurve);\n    float negCurve = negCurve2.x + negCurve2.y;\n    negCurve = negCurve / (.2 + negCurve);\n    float curve = (curve2.x + curve2.y);\n    curve = curve / (.2 + abs(curve));\n    \n    p = vec3(p.x, terrain(p.xz), p.z);\n\n    vec3 albedo  = vec3(1);\n    \n    float slopeFactor;\n    float heightFactor;\n    {\n        heightFactor = p.y / maxHeight();\n        \n        heightFactor = smoothstep(0., 1., heightFactor);        \n        heightFactor = smoothstep(0., 1., heightFactor);\n        \n        slopeFactor = abs(normal.y);\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        //slopeFactor *= slopeFactor;\n        slopeFactor = 1.-slopeFactor;\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        //slopeFactor *= slopeFactor;\n        slopeFactor = 1.-slopeFactor;\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        \n        const vec3\n            flatLow = vec3(.1, .4, .1),\n            flatHigh = vec3(.7, .7, .5),        \n            slopeLow = vec3(.4, .7, .2),\n            slopeHigh = vec3(.3, .2, .1);\n        \n        vec3 flatColor = mix(flatLow, flatHigh, heightFactor);\n        vec3 slopeColor = mix(slopeLow, slopeHigh, heightFactor);\n        \n        albedo = mix(slopeColor, flatColor, slopeFactor);\n    }\n    \n    albedo = mix(albedo, (albedo+vec3(.7))*vec3(.7,.6,.3), posCurve); \n    \n    float rivers;\n    {\n        rivers = max(0.,negCurve - posCurve);\n        \n        rivers = pow(rivers, pow(2., mix(.5, -.7, slopeFactor) + mix(-.7, .7, heightFactor)));   \n\n        rivers = smoothstep(0., 1., rivers);\n        rivers = smoothstep(0., 1., rivers);\n        \n        albedo = mix(albedo, vec3(.1,.2,.5), rivers); \n    }\n    float snow = pow(heightFactor, 8.);\n    albedo = min(mix(albedo, vec3(8), snow), 1.);\n\n    albedo *= albedo; // guess all those colors were specified in sRGB gamma?\n\n    const vec3 lightDir = normalize(vec3(0, 3, 5)),\n      lightColor = 2. * vec3(1., .75, .5);    \n    float nl = max(0., dot(normal, lightDir));\n    \n    float specm = 0.;\n    specm = mix(specm, .5, posCurve);\n    specm = mix(specm, 3., rivers);\n    specm = mix(specm, 2., snow);\n\n    float spec = max(0., dot(camDir, reflect(lightDir, normal))); // phong specular\n    spec = pow(spec, 128.);\n\n    float ambient = normal.y * .5 + .5; // hemisphere ambient\n    ambient *= .2*exp2(-4. * negCurve);\n    vec3 ambientColor = ambient * skybox(normal, true);\n\n    vec3 color = nl*lightColor*(albedo + spec*specm) + ambientColor * albedo;\n\n    float d2 = t*t; //dot(p - camPos, p - camPos);  \n    color = mix(sky, color, exp2(-3.*d2)); // fog  \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 d = normalize(vec3(fragCoord - .5*iResolution.xy, iResolution.y)), // ray dir\n       e = vec3(0, maxHeight() * 1., -.5); // eye pos    \n    quat pan = FromAngleAxis(vec3(0, iTime * .1, 0)),\n       tilt = normalize(quat(1,0,0,4));\n    e = qmul(pan, e);\n    d = qmul(qmul(pan, tilt), d);    \n    vec3 c = render(e, d);\n    fragColor = vec4(c / (c + .3), 1);\n}  \n    // just show the heightmap\n    //fragColor = textureLod(iChannel0, fragCoord/iResolution.xy, 0.);\n    //fragColor /= fragColor.a;\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// from Eikonal FIM at http://shadertoy.com/view/7dGSz3\n// RNG\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0) - textureLod(tex, fragCoord, 20.0);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    uint rngState = uint\n    (\n        uint(iFrame) * uint(1973) \n    ) | uint(1);\n    \n    //o = vec4(sampleRandom(iChannel3, p, rngState).g);\n    //return;\n\n #define decode(x) (((x) - bias) * e)\n #define T(x) decode(textureLod(iChannel2, (x)/r, 0.).r - textureLod(iChannel2, (x)/r, 20.).r + 0.5)\n    vec2 r = iResolution.xy;\n    const float bias = .5, // meh\n        e = exp2(8.5); // controls steepness\n    o = texelFetch(iChannel2, ivec2(0), 0);\n    \n    float time = iTime * 4.0 + 1.5;\n    float temperature = time*time*10.1+1.0;\n    float scaleTemperature = sqrt(time);\n    \n    float d = T(p);\n    // handle resolution change, for full screen support\n    if (iFrame < 1 || !(length(o.yz-r) < .5) || iChannelResolution[3].x < 1.) {\n        d = sampleRandom(iChannel3, p * scaleTemperature, rngState).g;\n    } else {\n        float od = d/e + bias; // undoes some stuff in T FIXME\n        // compute local gradient\n        vec2 g = vec2(T(p + vec2(1,0))\n                    - T(p - vec2(1,0))\n                    , T(p + vec2(0,1))\n                    - T(p - vec2(0,1))) * .5;\n        float dsgn = sign(d);\n        dsgn *= 50.0 / (temperature); // slow melt rate\n        const float stretch = 1.001;\n        vec2 q = p - dsgn * inversesqrt(dot(g, g)) * g;\n        d = T(q)\n            + dsgn * stretch;\n        d /= e;\n        d += bias;\n        d = mix(od, d, .8);\n        float noise = sampleRandom(iChannel3, p*sqrt(time), rngState).g;\n              \n        d += noise*2.0 / (temperature);\n       d = clamp(d, 0., 1.);\n    }\n    //d = sampleRandom(iChannel3, p * (iTime*iTime+1.0), rngState).g/ (iTime*iTime+1.0);\n    o = vec4(d,d,d,1);\n    if (ivec2(p) == ivec2(0))\n        o.yz = r;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}