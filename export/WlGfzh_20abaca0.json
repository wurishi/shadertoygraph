{"ver":"0.1","info":{"id":"WlGfzh","date":"1614227421","viewed":64,"name":"Desert1","username":"treize","description":"Desert","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sprocedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATION_NUM 50\nconst float pi = acos(-1.0);\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat sphere(vec3 rayPos, float r) \n{\n    float d=length(rayPos)-r;\n\treturn d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nfloat map(vec3 rayPos) \n{\n    float fbm=FBM24(rayPos.xz, 0.5,2.0);\n    fbm=mix(0.8,fbm,0.8);\n\tfloat floor_height\t=  0.25-fbm;\n    float d=sphere(rayPos,1.2);\n    floor_height+=rayPos.y;\n\td=\topIntersection(d,floor_height); \t\t\t\n\treturn d;\n}\n\nvec3 getnormal(vec3 p)\n{\n    vec2 e =vec2(0.01,0.0);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx)));\n}\nvec3 lighting(vec3 p,vec3 lp,vec3 lc)\n{\n    vec3 normal=getnormal(p);\n    vec3 lightdir=normalize(lp);\n    float NdotL = max(dot(lightdir,normal),0.0);\n    vec3 col = vec3(NdotL)+lc;\n    return col;\n}\n\nvec3 raymarch(vec3 rayOrigin, vec3 rayDirection) \n{\n\tvec3 rayPos, col = vec3(0.0);\n\tfloat depth = 0.0;\n\tfor(int i=0; i<ITERATION_NUM; i++) \n\t{\n        rayPos=rayOrigin+rayDirection*depth;\n\t\tfloat d = map(rayPos);\n\t\tif(d<0.01)\n\t\t{\n            col=lighting( rayPos,vec3(1.0,0.0,-1.0),vec3(0.2,0.2,0.2));\n            if(rayPos.y>0.0)\n            {\n            \tvec3 sand;\n                float line;\n                Sand(rayPos.xz,vec2(5.0),10.0,vec3(1.0,0.7,0.4),sand,line);\n                col+=sand;\n            }\n            else\n            {\n                col=vec3(0.7,0.4,0.2);\n            }\n\t\t    break;\n\t\t}\n\t\tdepth += d;\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 origin = vec3(1.0, 1.5, 2.0);\n    vec3 target = vec3(0.0);\n    float rotate=0.0;\n    float screen_z=2.0;\n    mat3 camera = SetCamera(origin, target, rotate);\n    vec3 rayDirection = camera * normalize(vec3(p, screen_z));\n\tvec3 col=raymarch(origin , rayDirection);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float random_seed2(vec2 uv)\n{\n\treturn fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\nfloat ValueNoise(vec2 uv)\n{\n\tvec2 i = floor(uv);\n\tvec2 f = fract(uv);\n\tf = f * f * (3.0 - 2.0 * f);\n\tfloat r0 = random_seed2(i);\n\tfloat r1 = random_seed2(i + vec2(1.0, 0.0));\n\tfloat r2 = random_seed2(i+vec2(0.0, 1.0));\n\tfloat r3 = random_seed2(i + vec2(1.0, 1.0));\n\tfloat bottomOfGrid =mix(r0, r1, f.x);\n\tfloat topOfGrid = mix(r2, r3, f.x);\n\tfloat t = mix(bottomOfGrid, topOfGrid, f.y);\n\treturn t;\n}\nfloat FBM24(vec2 uv, float amplitude, float frequency)\n{\n\tfloat result = 0.;\n\tfloat amplitude2 = amplitude;\n\tfloat frequency2 = frequency;\n\tfor (int i = 0; i < 4; i++)\n\t{\n        result += ValueNoise(uv * frequency2) * amplitude2;\n\t\tamplitude2 *= 0.5;\n\t\tfrequency2 *= 2.0;\n\t}\n\treturn result;\n}\nfloat DomainWarp(vec2 p, float G,int loop)\n{\n    float val = 0.0;\n    for (int i = 0; i < loop; i++)\n    {\n        vec2 dir = vec2(sin(G * val), cos(G * val));\n        val = FBM24(p + dir,1.0,1.0);\n    }\n    return val;\n}\nvoid Sand(vec2 UV,vec2 UVScale,float Scale,vec3 FilterColor,out vec3 Out,out float Line)\n{\n    vec2 p=UV*UVScale;\n    float noise=DomainWarp(p, 3.0,7);\n    float value=1.0+cos(noise*Scale)/2.0;\n    float value2=1.0+tan(noise*Scale)/ 2.0;\n    vec3 sand=FilterColor*value;\n    Out=sand;;\n\n    Line=pow(clamp(value2,0.0,1.0)*2.4,4.0);\n}","name":"Common","description":"","type":"common"}]}