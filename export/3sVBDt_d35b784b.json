{"ver":"0.1","info":{"id":"3sVBDt","date":"1608410910","viewed":284,"name":"Westworld Needle","username":"athibaul","description":"Model of the 3D-printing needle from the title sequence of science-fiction series Westworld.","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","distancefunction","modeling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 fibonacciSpiral(float i, float n)\n{\n    float r = sqrt(i/n);\n    float th = 2.*3.1415926/1.618033 * i;\n    return r*vec2(cos(th),sin(th));\n}\n\nvec3 SSDOF( vec2 fragCoord )\n{\n    // Screen-space depth of field\n    \n    // Adapted from\n    // http://developer.amd.com/wordpress/media/2012/10/Scheuermann_DepthOfField.pdf\n    vec4 bufA = texture(iChannel0, fragCoord/iResolution.xy);\n    float z = bufA.w;\n    // Screen-space depth-of-field\n    //float focusPlane = camDist(time);\n    //float farBlur = z < 50. ? 0.02 : 0.0011; // Don't blur the background\n    //float bluriness = abs((z-focusPlane)/z) * farBlur;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float bluriness = 0.02 * smoothstep(0.0, 2.0, length(uv));\n    float blurRadius = bluriness * iResolution.y;\n    \n    // Combine level-of-detail blurring and several texture fetches\n    float lod = log2(blurRadius);\n    vec3 col = vec3(0);\n    float NUM_TAPS = 16.;\n    for(float i=0.; i<NUM_TAPS; i++)\n    {\n        col += textureLod(iChannel0, (fragCoord+fibonacciSpiral(i,NUM_TAPS)*blurRadius)/iResolution.xy, lod-1.).rgb;\n    }\n    \n    return col/NUM_TAPS;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    time = clamp(iTime/20., 0., 1.);\n    vec3 col = SSDOF(fragCoord);\n    \n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    // ACES tone mapping\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Used in https://www.shadertoy.com/view/ts3Bz7\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n    \n    fragColor = vec4(pow(col,vec3(1./2.2)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float spNum = float(iFrame);\n    vec2 coordJitter = texelFetch(iChannel0, ivec2(mod(fragCoord+31.*spNum, 1024.)), 0).rg;\n    //vec2 coordJitter = vec2(0);\n    vec2 uv = ((fragCoord+coordJitter)*2.-iResolution.xy)/iResolution.y;\n\n    \n    time = min((iTime-4.)/20., 1.);\n    float needleX = 0.3 * (1.-time) * (1.-time);\n    needlePoint = needleX * vec3(1,0.4,0) + vec3(0,0,0.01);\n\n    float th = -3.1416/2. + 0.1*sin(10.*time)*(1.-time) + 0.02*cos(0.7*iTime);\n    float jitterZ = 0.03*cos(iTime) + 0.03*sin(0.62*iTime) - 0.3*(1.-time)*(1.-time);\n    //float fov = 0.2 * pow(2.5, 1.-exp(-0.2*time));\n    vec3 ro = needlePoint + camDist(time)*normalize(vec3(cos(th), sin(th), jitterZ));\n    vec3 camFwd = normalize(needlePoint-ro);\n    //vec3 camFwd = vec3(-1,0,0);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    vec3 rd = normalize(camFwd + 0.5*(uv.x*camRight+uv.y*camUp));\n    \n    \n    float t;\n    vec3 col = render(ro, rd, t);\n    float z = t*dot(rd, camFwd);\n    fragColor = vec4(col, z);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n\n\nfloat T_MAX = 1.0;\n\n// *******************************************************\n// Primitive distance functions adapted from Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdCyl( vec3 p, float h2, float r2 )\n{\n    float h = h2*0.5, r=r2*0.5;\n    vec2 d = abs(vec2(length(p.xy),p.z-h)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n// *******************************************************\n\n// Hash function by Dave Hoskins\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec3 p)\n{\n    vec3 ip = floor(p), fp = fract(p);\n    fp = smoothstep(0., 1., fp);\n    vec2 e = vec2(0, 1);\n    return mix(\n        mix(\n            mix(hash13(ip+e.xxx), hash13(ip+e.yxx), fp.x),\n            mix(hash13(ip+e.xyx), hash13(ip+e.yyx), fp.x), fp.y),\n        mix(\n            mix(hash13(ip+e.xxy), hash13(ip+e.yxy), fp.x),\n            mix(hash13(ip+e.xyy), hash13(ip+e.yyy), fp.x), fp.y),\n        fp.z);\n}\n\n\n// *******************************************************\n\nstruct Hit { float d; int mat; };\n\nfloat opU( float a, float b, float k )\n{\n    // Smooth min function\n    return 0.5*(a+b - sqrt((a-b)*(a-b)+k*k));\n}\n\nfloat opU( float a, float b )\n{\n    return min(a, b);\n}\n\nHit opU( Hit a, Hit b )\n{\n    if(a.d < b.d) return a;\n    return b;\n}\n\nfloat sdNeedle( vec3 p )\n{\n    // Needle head is formed by stacking a bunch of cylinders\n    float d = 1e5;\n    vec3 q = p;\n    q.z += 0.001;\n    d = abs(sdCyl(q, 0.040, 0.0013)) - 0.0001;\n    d = max(d, 0.001+dot(q, normalize(vec3(1,0,-1))));\n    d = opU(d, sdCyl(q-vec3(0,0,0.005), 0.007, 0.002));  q -= vec3(0.0, 0.002, 0.04);\n    d = opU(d, sdCyl(q, 0.025, 0.012)); q -= vec3(0.0, 0.006, 0.025);\n    d = opU(d, sdCyl(q, 0.050, 0.026), 0.0015); q -= vec3(0, 0, 0.05);\n    d = opU(d, sdCyl(q, 0.036, 0.035)); q -= vec3(0, 0, 0.036);\n    d = opU(d, sdCyl(q, 0.020, 0.042)); q -= vec3(0, 0.022, 0.020);\n    d = opU(d, sdCyl(q, 0.020, 0.090)); q -= vec3(0, 0.022, -0.01);\n    d = opU(d, sdCyl(q, 0.010, 0.042)); q -= vec3(0, -0.022, 0.01 + 0.02);\n    d = opU(d, sdCyl(q, 0.100, 0.150), 0.001);\n    return d;\n}\n\nfloat sdBones( vec3 p )\n{\n    // A bunch of very organic shapes\n    // Part of bone sticking out\n    float d = sdCapsule(p, vec3(-0.01, 0, -0.01), vec3(-0.03, 0, -0.02), 0.01);\n    d = opU(d, sdCapsule(p, vec3(-0.023, 0.002, -0.02), vec3(-0.03, 0.02, -0.06), 0.012), 0.005);\n    d = opU(d, sdCapsule(p, vec3(-0.01, -0.005, -0.05), vec3(-0.04, -0.015, -0.065), 0.01), 0.01);\n    // Bone going down\n    d = opU(d, sdCapsule(p, vec3(-0.04, -0.012, -0.065), vec3(-0.06, 0, -0.14), 0.01), 0.01);\n    d = opU(d, sdCapsule(p, vec3(0.0, 0.0, -0.10), vec3(-0.03, 0, -0.12), 0.015), 0.01);\n    d = opU(d, sdCapsule(p, vec3(-0.03, 0.02, -0.06), vec3(-0.075, 0, -0.2), 0.02), 0.01);\n    // Some distortion\n    d += 0.005 * (noise(60.*p) - 0.5);\n    // Bone going right\n    float d2 = sdCapsule(p, vec3(0.02, -0.015, -0.08), vec3(0.24, 0.1, -0.05), 0.02);\n    d2 = opU(d2, sdCapsule(p, vec3(-0.01, 0.01, -0.065), vec3(0.08, 0.01, -0.06), 0.015), 0.01);\n    d2 = opU(d2, sdCapsule(p, vec3(0.03, 0.0, -0.1), vec3(0.3, 0.05, -0.05), 0.02), 0.005);\n    d2 = opU(d2, sdCapsule(p, vec3(0.15, 0.03, -0.07), vec3(0.45, 0.15, 0.0), 0.02+0.015*smoothstep(0.0,0.4,p.x)), 0.01);\n    // Some distortion\n    d2 += 0.005 * (noise(vec3(10.,60.,50.)*p) - 0.5);\n    \n    d = opU(d, d2);\n    \n    \n    return d;\n}\n\n\nfloat time = 0.0;\nvec3 needlePoint;\nfloat camDist(float time) { return 0.35 * pow(0.3, smoothstep(1., 0., time)); }\nHit map( vec3 p )\n{\n    vec3 q = p-needlePoint;\n    q.xy *= R(0.53);\n    q.yz *= R(-0.5*(1.-time)*(1.-time));\n    q.xz *= R(1.1 - (1.-time)*(1.-time)); q.xy *= R(-1.2);\n    Hit d = Hit(sdNeedle(q), 0);\n    d = opU(d, Hit(sdBones(p), 1));\n    \n    // Thread printed by the needle\n    q = p;\n    float thickness = 0.00002+0.005*(1.-exp(-5.*length(q-needlePoint)));\n    //q.z += 0.005*(1.-cos(q.x/0.45*6.28));\n    d = opU(d, Hit(sdCapsule(q, vec3(needlePoint), vec3(0.45,0.15,0), thickness), 2));\n    \n    return d;\n}\n\nfloat bumpmap( vec3 p, float detail )\n{\n    Hit hit = map(p);\n    float d = hit.d;\n    if(hit.mat == 1)\n    {\n        // Tiny bumps on the bones\n        // Only visible if larger than the smallest visible details\n        float noises = (noise(800.*p.yzx) - 0.5);\n        noises += (noise(1600.*p) - 0.5) * clamp(1./(detail*2000.)-0.5,0.,1.);\n        noises += (noise(4107.*p)-0.5)  * clamp(1./(detail*6000.)-0.5,0.,1.);\n        d += 0.0001 * smoothstep(-0.5,0.5, noises);\n    }\n        \n    return d;\n}\n\nvec3 normal( vec3 p, float detail )\n{\n    vec2 e = 0.0001*vec2(1,-1);\n    return normalize(\n      e.xxx*bumpmap(p+e.xxx, detail)\n    + e.xyy*bumpmap(p+e.xyy, detail)\n    + e.yxy*bumpmap(p+e.yxy, detail)\n    + e.yyx*bumpmap(p+e.yyx, detail));\n}\n\nHit raymarch( vec3 ro, vec3 rd )\n{\n    Hit hit;\n    float t=0.;\n    for(int i=0; i<100; i++)\n    {\n        hit = map(ro+t*rd);\n        if(hit.d < 0.00001 + 0.001*t || t > T_MAX) break;\n        t += hit.d * 0.9;\n    }\n    return Hit(t, hit.mat);\n}\n\nvec3 light1pos = normalize(vec3(-0.2,0.5,1));\nvec3 light3pos = normalize(vec3(0.6,1,1));\nvec3 skyColor(vec3 rd)\n{\n    vec3 col = vec3(2) * pow(0.5+0.5*dot(rd, light3pos), 10.);\n    col += vec3(4) * pow(0.5+0.5*dot(rd, light1pos), 8.);\n    return col;\n}\n\nvec3 shadeSubsurface( vec3 p, vec3 n, vec3 rd, float sssDist )\n{\n    vec3 surfCol = vec3(0.8);\n    float sssPowerLaw = 2.0;\n    sssDist *= sssPowerLaw;\n    float d1 = map(p).d, d2 = map(p+sssDist*light1pos).d;\n    vec3 lig = pow(vec3(clamp((d2-d1)/sssDist, 0., 1.)), sssPowerLaw*vec3(1.,1.2,1.4)) * vec3(1.,1.15,1.3);\n    vec3 diffuse = surfCol * lig;\n    \n    vec3 specular = skyColor(reflect(rd, n)) * smoothstep(-0.2,0.2, (d2-d1)/(sssDist*sssPowerLaw));\n    float fre = 0.1 + 0.9*pow(clamp(1.-dot(n,-rd),0.,1.), 5.) * (0.5+0.5*n.z);\n    vec3 col = mix(diffuse, specular, fre) * (1.+0.15*vec3(1,0,-1));\n    \n    return col;\n}\n\nvec3 shadeSurface( vec3 p, vec3 rd, int mat, float detail )\n{\n    vec3 n = normal(p, detail);\n    vec3 rrd = reflect(rd, n);\n    \n    vec3 diffuse;\n    vec3 col;\n    if(mat == 0)\n    {\n        vec3 specular = skyColor(rrd);\n        diffuse = 0.5*vec3(0.25,0.3,0.3) * clamp(dot(n, normalize(vec3(1,0,-0.5))), 0., 1.);\n        specular += vec3(100) * pow(0.5+0.5*dot(rrd, normalize(vec3(0.6,1,1))), 100.);\n        specular *= 0.3;\n        // Hand-paint the reflection of bone\n        specular += vec3(2.,1.8,1.6) * pow(0.5+0.5*dot(rrd, normalize(vec3(0,0,-1))), 10.) * smoothstep(-0.15,0.0,p.x);\n        float fre = 0.1 + 0.9*pow(clamp(1.-dot(n,-rd),0.,1.), 2.);\n        col = mix(diffuse, specular, fre);\n    }\n    else if(mat == 1)\n    {\n        // Bone material\n        col = shadeSubsurface(p, n, rd, 0.02);\n    }\n    else if(mat == 2)\n    {\n        // Muscle material\n        col = shadeSubsurface(p, n, rd, 0.01);\n    }\n    col *= vec3(0.3,0.4,0.5);\n    return col;\n}\n\n\nvec3 render( vec3 ro, vec3 rd, out float t )\n{\n    Hit hit = raymarch(ro, rd);\n    t = hit.d;\n    vec3 col;\n    if(t < T_MAX)\n    {\n        vec3 p = ro+t*rd;\n        float detail = t * length(fwidth(rd)) * sqrt(0.5); // \n        col = shadeSurface(p, rd, hit.mat, detail);\n    }\n    else\n    {\n        // Render sky\n        col = skyColor(rd) * vec3(0.3,0.4,0.5) * 0.05 * pow(5., (1.-time)*(1.-time));\n    }\n    return col;\n}\n","name":"Common","description":"","type":"common"}]}