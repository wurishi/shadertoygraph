{"ver":"0.1","info":{"id":"Wl2SW3","date":"1567519151","viewed":266,"name":"voronoi melon","username":"takumifukasawa","description":"noted refs in the code","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","raymarch","sdf","cubemap","fruit","melon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//---------------------------------------------------------------------------------------------\n// # refs\n// - iq's some articles and codes. (AO, SDF, ... and more)\n//   - ex1. system: https://www.shadertoy.com/view/3lsSzf\n//   - ex2. voronoi: https://www.shadertoy.com/view/ldl3W8\n// - https://qiita.com/edo_m18/items/c8995fe91778895c875e\n// - https://www.shadertoy.com/view/wtjGWy\n// - https://gamedevelopment.tutsplus.com/articles/use-tri-planar-texture-mapping-for-better-terrain--gamedev-13821\n//---------------------------------------------------------------------------------------------\n\n//---------------------------------------------------------------------------------------------\n// configs\n//---------------------------------------------------------------------------------------------\n\n// toggle movable\n#define MOVABLE_NET_LINE\n\n#define EPS .0001\n#define NORMAL_EPS .0001\n#define PI 3.14159265359\n#define PI2 PI * 2.\n\n#define MAT_BODY 1.\n#define MAT_NET_LINE 2.\n#define MAT_BRANCH 3.\n\n#define saturate(a) clamp(a, 0., 1.)\n#define repeat(a, b) mod(a, b) - b * .5 \n\nprecision highp float;\n\n//---------------------------------------------------------------------------------------------\n// utils\n//---------------------------------------------------------------------------------------------\n\nbool checkMat(float material, float check) {\n\treturn material < (check + .5);\n}\n\nmat3 camera(vec3 o, vec3 t) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat2 rot2(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n) {\n    vec3 blending = abs(n);\n    blending = normalize(max(blending, EPS));\n    \n    float b = (blending.x + blending.y + blending.z);\n    blending /= b;\n    \n    vec4 xaxis = texture(tex, p.yz); // yz plane\n    vec4 yaxis = texture(tex, p.xz); // xz plane\n    vec4 zaxis = texture(tex, p.xy); // xy plane\n\n    return (xaxis * blending.x + yaxis * blending.y + zaxis * blending.z).rgb;\n}\n\n//---------------------------------------------------------------------------------------------\n// voronoi\n//---------------------------------------------------------------------------------------------\n\nvec2 hash2(vec2 p) {\n\treturn fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43.75);\n}\n\nvec3 voronoi(vec2 x) {\n\tvec2 n = floor(x);\n    vec2 f = fract(x);\n    \n    vec2 mg, mr;\n    \n    float offs = 0.;\n    #if defined MOVABLE_NET_LINE \n      offs = iTime * 2.4;\n    #endif\n    \n    \n    float md = 8.;\n    for(int j = -1; j <= 1; j++) {\n        for(int i = -1; i <= 1; i++) {\n        \tvec2 g = vec2(float(i), float(j));\n            vec2 o = hash2(n + g);\n            o = .5 + .5 * sin(PI2 * o + offs);\n        \tvec2 r = g + o - f;\n            float d = dot(r, r);\n            \n            if(d < md) {\n            \tmd = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    \n\t// for border\n    // original loop num is 2\n    md = 8.;\n    for(int j = -1; j <= 1; j++) {\n        float fj = float(j);\n        for(int i = -1; i <= 1; i++) {\n            float fi = float(i);\n        \tvec2 g = mg + vec2(fi, fj);\n            vec2 o = hash2(n + g);\n            o = .5 + .5 * sin(PI2 * o + offs);\n            vec2 r = g + o - f;\n            \n            vec2 mrr = mr - r;\n            if(dot(mrr, mrr) > .0001) {\n                md = min(md, dot(.5 * (mr + r), normalize(r - mr)));\n            }\n        }\n    }\n    \n    return vec3(md, mr);\n}\n\n//---------------------------------------------------------------------------------------------\n// sdf\n//---------------------------------------------------------------------------------------------\n\n// ra: radius\n// rb: round\n// h: height\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2. * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rb;\n}\n\n// a: begin pos\n// b: begin thin\n// ra: end pos\n// rb: end thin\nfloat sdStick(in vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tvec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float r = mix(ra, rb, h);\n\treturn length(pa - h * ba) - r;\n}\n\nfloat sdElipsoid(in vec3 pos, vec3 rad) {\n\tfloat k0 = length(pos / rad);\n\tfloat k1 = length(pos / rad / rad);\n\treturn k0 * (k0 - 1.) / k1;\n}\n\nfloat smin(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn min(a, b) - h * h / (k * 4.);\n}\n\nfloat smax(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn max(a, b) + h * h / (k * 4.);\n}\n\n//---------------------------------------------------------------------------------------------\n// raymarch\n//---------------------------------------------------------------------------------------------\n\nvec2 scene(vec3 p) {\n    // dummy float max and min\n    vec2 res = vec2(10000., -10000.);\n    \n    p -= vec3(0., -.25, 0.);\n    \n    // net line height\n    float nh = .05;\n    \n    // melon size\n    vec3 ms = vec3(1.35, 1.49, 1.35);\n\n    // body\n    {\n        vec3 _p = p;\n        _p.xz = _p.xz * .95;\n\n        // dent by net line height\n        float d = sdElipsoid(_p, ms - vec3(nh));\n\n        float d2 = sdElipsoid(p - vec3(0., 1.7, 0.), vec3(.2, .2, .2));\n        d = smax(d, -d2, .4);\n\t    \t        \n\t\tif(d < res.x) res = vec2(d, MAT_BODY);\n    }\n    \n    // net line\n    {\n        vec3 _p = p;\n        _p.xz = _p.xz * .95;\n\n        float d = sdElipsoid(_p, ms);\n\n        vec3 _p1 = _p;\n        vec3 _p2 = _p;\n        vec3 _p3 = _p;\n        _p1.xy *= rot2(PI2 * .4);\n        _p2.xy *= rot2(PI2 * .8);\n        _p3.xy *= rot2(PI2 * 1.1);\n        float seed = 13.;\n        vec3 v = voronoi(((_p1.xy) + vec2(2., 0.)) * seed);\n        float vo = smoothstep(.09, .24, saturate(v.x));\n        d += vo * .05;\n        \n        float d2 = sdElipsoid(p - vec3(0., 1.7, 0.), vec3(.2, .2, .2));\n        d = smax(d, -d2, .4);\n\n\t\tif(d < res.x) res = vec2(d, MAT_NET_LINE);\n    }\n\n    // branch\n    {\n        vec3 _p = p;\n        float ty = .04 * p.x * p.x;\n        // left\n\t\tfloat dl = sdStick(_p - vec3(0., 1.6 + ty, 0.), vec3(0., 0., 0.), vec3(-1., .02, 0.), .08, .06);\n        // right\n        float dr = sdStick(_p - vec3(0., 1.6 + ty, 0.), vec3(0., 0., 0.), vec3(1.2, .1, 0.), .08, .06);\n        // branch\n        float dc = sdStick(_p - vec3(0., 1.6 + ty, 0.), vec3(0., 0., 0.), vec3(0., -.2, 0.), .04, .12);\n        float dd = 0.;\n        dd = smin(dl, dr, .05);\n        dd = smin(dd, dc, .05);\n        if(dd < res.x) res = vec2(dd, MAT_BRANCH);\n    }\n    \n    return res;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy).x - scene(p - e.xyy).x,\n            scene(p + e.yxy).x - scene(p - e.yxy).x,\n            scene(p + e.yyx).x - scene(p - e.yyx).x\n        )\n    );\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n\tfloat tmin = .01;\n    float tmax = 80.;\n    float m = -1.;\n    float t = tmin;\n    for(int i = 0; i < 64; i++) {\n\t\tvec3 pos = ro + rd * t;\n        vec2 h = scene(pos);\n        m = h.y;\n        if(abs(h.x) < (.001 * t)) break;\n        t += h.x;\n        if(t > tmax) break;\n    }\n    if(t > tmax) m = -1.;\n    return vec2(t, m);\n}\n\n//---------------------------------------------------------------------------------------------\n// lightings\n//---------------------------------------------------------------------------------------------\n\nfloat calcOcculusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.;\n    float sca = 1.;\n    for(int i = 0; i < 5; i++) {\n    \tfloat h = .01 + .11 * float(i) / 4.;\n        vec3 opos = pos + h * nor;\n        float d = scene(opos).x;\n        occ += (h - d) * sca;\n        sca *= .95;\n    }\n    return clamp(1. - 2. * occ, 0., 1.);\n}\n\n//---------------------------------------------------------------------------------------------\n// main\n//---------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n\tvec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(mouse * vec2(2., 3.), 5.4);\n    vec3 target = vec3(0.);\n    float fov = 1.5;\n    \n    vec3 rd = camera(ro, target) * normalize(vec3(uv, fov));\n    \n\tvec2 result = raymarch(ro, rd);\n\tvec3 color = vec3(0.);\n    \n    if(result.y > 0.) {\n\t    float depth = result.x;\n    \tfloat material = result.y;    \n   \n    \tvec3 position = ro + rd * depth;\n    \tvec3 normal = getNormal(position);\n    \n    \tvec3 objColor = vec3(0.);\n\n        vec3 pattern = tex3D(iChannel1, position, normal);\n               \n        if(checkMat(material, MAT_BODY)) {\n            objColor = mix(vec3(110., 212., 100.) / 255., pattern, .4);\n        } else if (checkMat(material, MAT_NET_LINE)) {        \t\n            objColor = mix(vec3(239., 255., 206.) / 255., pattern, .3);\n        } else if (checkMat(material, MAT_BRANCH)) {  \n            objColor = mix(vec3(168., 207., 136.) / 255., pattern, .5);\n        }\n        \n        float occ = calcOcculusion(position, normal);         \n\t\tfloat occRate = .2; // for adjustment\n        objColor *= mix(1., occ, occRate);\n        \n    \t// directional lighting\n    \tvec3 lightPos = vec3(-.2, .2, 1.);\n    \tvec3 lightColor = vec3(.94);\n        \n        // half lambert\n    \tfloat diffuse = saturate(dot(normal, normalize(lightPos))) * .5 + .5;\n    \n        vec3 r = reflect(rd, normal);\n        vec3 rc = texture(iChannel0, r).xyz;\n\t\tvec3 ambient = rc * .2;\n        \n    \tcolor += objColor * (diffuse * lightColor + ambient);\n    } else {\n    \tvec4 cubemap = texture(iChannel0, rd);\n        color += cubemap.xyz;\n    }\n    \n    // gamma\n    //color = pow(color, vec3(.4545));\n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}