{"ver":"0.1","info":{"id":"dsVXRz","date":"1680782687","viewed":28,"name":"colorful cross joyeuxbe","username":"joyeuxbe","description":"croix colorée qui fait des mouvements en boucle.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cross","christian"],"hasliked":0,"parentid":"mdVXRz","parentname":"Fork Projet-3D joyeuxbe 177"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nprecision mediump sampler3D;\n//Attendus pour le projet : rendu 6 avril\n//Fonction de distance 2D / 3D\n    //Union - intersections - Subtraction\n    //Transformations Linéaires (rotations - Translations - scaling)\n    //Pertubations - repetitions - symétrie - pliage - etc...\n//Lancé de rayon (marching)\n    //rayons de caméra - Animé\n    //multiplicité des rayons\n//Shading (modèle de Phong)\n    //Diffus - spéculaire - couleur\n    //Variations des parametres\n//Texture (Perlin noise)\n    //Perlin - fractales\n    //Variations mathematiques\n\n//Noté sur les features - techniques - originalité\n// + noté sur la démo : demo - pitch - storytelling\n// mini rapport : description de la scène (features) - documentation (controles, parametres) - screenshot\n\n\n// screen resolution\n#define R iResolution.xy\n\n// minimum distance to objects\n#define DIST_MIN 1.\n\n// maximum distance to objects\n#define DIST_MAX 50.0\n\n// max number of steps for the ray-marching\n#define RAY_MARCH_STEPS 100\n\n// consider hit if we reach this distance\n#define RAY_MARCH_PRECI 0.0001\n\n// for ray direction computation\n#define PI 3.14159265359\nuniform sampler3D textureSampler; // Déclare la variable sampler\n//precision textureSampler sampler3D;\n// ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n};\n\n//UTILS :\n//union substraction intersections\nfloat opSmoothUnion( float d1, float d2, float k ) { // source Quilez\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) { // source Quilez\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) { // source Quilez\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n    \n\n\n\n//SHAPES\nfloat sdBox( vec3 p, vec3 b )\n{ // source Quilez\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//FUNCTIONS :\nvec3 rotate(in vec3 uv, in float a){\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*uv.x-sa*uv.y, sa*uv.x+ca*uv.y, uv.z);\n}\n\nfloat hash13(vec3 p) { //aléatoire - source prof\n    return fract(sin(dot(p,vec3(12.9898,78.233,45.5432)))*43758.5453123);\n}\n\nfloat vnoise(in vec3 x) { //bruit - source prof\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(\n                mix(mix(hash13(p+vec3(0.,0.,0.)),hash13(p+vec3(1.,0.,0.)),f.x),\n                      mix(hash13(p+vec3(0.,1.,0.)),hash13(p+vec3(1.,1.,0.)),f.x),f.y),\n                mix(mix(hash13(p+vec3(0.,0.,1.)),hash13(p+vec3(1.,0.,1.)),f.x),\n                      mix(hash13(p+vec3(0.,1.,1.)),hash13(p+vec3(1.,1.,1.)),f.x),f.y),f.z);\n}\n\nfloat fnoise(in vec3 p,in float amplitude,in float frequency,in float persistence, in int nboctaves) {//source prof\n    float a = amplitude;\n    float f = frequency;\n    float n = 0.0;\n\n    for(int i=0;i<nboctaves;++i) {\n        n = n+a*vnoise(p*f);\n        f = f*2.;\n        a = a*persistence;\n    }\n    \n    return n;\n}\n\nSurface scene(in vec3 p) { // source le cours\n    vec3 t = (p+iTime)*6.;\n    float cosRotation = cos(iTime*1.);\n    p = rotate(p, cosRotation) * cos(iTime); //rotationne la croix\n    float pavedroit = sdBox( p, vec3(0.2*0.5,2.5*0.5,0.2*0.5));//p *(cos(iTime)) pour grandir et retrecir\n    float pavedroit2 = sdBox( vec3(p.x, p.y-0.5, p.z), vec3(1.4*0.5, 0.2*0.5,0.2*0.5)); \n    float croix = opSmoothUnion(pavedroit,pavedroit2,0. );\n\n    return Surface(croix,vec3(1.,0.,0.));\n}\n\nSurface march(in Ray r) { // source le cours\n    vec3 col = vec3(0.); // background color\n    float t = DIST_MIN;\n    float dist = 0.0;\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n        dist += s.t;\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n        if (dist >= DIST_MAX || s.t < RAY_MARCH_PRECI) { \n            col = vec3(0.2, 0.5, 1.0); \n            return Surface(s.t, col); // ajoute le fond\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(0));\n}\n\nvec3 normalAt(in Surface s,in Ray r) { // source le cours\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\n\nvec3 marble(in vec3 position)\n{\n  float scale = 4.0; // L'échelle du marbre\n  float turbulence = 4.; // La turbulence du marbre\n  float frequency = 4.; // La fréquence du marbre\n  \n  // Créer une série de bruits en utilisant des fréquences multiples\n  for (int i = 0; i < 4; i++) {\n    float f = pow(2.0, float(i));\n  }\n\n  // Créer un motif bizarre en utilisant la valeur de bruit et l'échelle\n  vec3 marble = vec3(0.) - vec3(1.) * cos(vec3(position.x*(cos(iTime*5.)), position.y*cos(iTime*4.), position.z*sin(iTime*2.)) * scale ); //cos et sin de iTime c'est pour que ça change h24 de couleur ambiance vomi un peu\n  vec3 t = (position+iTime*0.)*1.;\n  float d = fnoise(t,0.5,0.5,0.9,3); \n  // Ajouter des nuances de gris pour donner une apparence de marbre\n  marble = mix(vec3(d-0.4, d-0.4, d-0.4), marble, 0.4);\n  \n  return marble;\n}\n\n\n\nvec3 shade(in Surface s,in Ray r) {\n    vec3 n = normalAt(s,r);//normale\n    vec3 l = normalize(vec3(1.,1.,-1.)); //direction de la lumière\n    vec3 v = -r.d;\n    vec3 e = reflect(-l,n);\n    vec3 Kd = marble(r.o+s.t*r.d); // on peut le remplacer par une texture\n    vec3 Ks = vec3(1.); //ça fait briller les arêtes de la forme\n    vec3 Ka = vec3(0.); //le blanc de la lumière\n    float sh = 50.;\n    \n    float diff = dot(n,l)*0.5+0.5;//gère les ombres\n    float spec = pow(max(dot(e,v),0.),sh);\n    \n    return Ka + Kd*diff + Ks*spec; //formule de la lumière\n}\n\n\nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position\n    vec2 m = iMouse.xy/R.y;\n    \n    // camera position\n    float DP = 10.;\n    float d = DP/2.;\n    vec3 ro = vec3(d*cos(6.0*m.x),DP/5.0,d*sin(6.0*m.x) );\n\n    //vec3 ro = vec3(0.,0.,-7.);\n\n    // target point\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + zf*cw);\n\n    return Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    \n\n    Ray r = camRay(uv);\n    Surface s = march(r);\n    vec3 c = vec3(0.5);\n    \n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}