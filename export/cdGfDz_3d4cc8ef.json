{"ver":"0.1","info":{"id":"cdGfDz","date":"1699141809","viewed":38,"name":"Fork M1 - Ray t mmaouche 688","username":"mmaouche","description":"Source code for ray-tracing assignment","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"fl2yz3","parentname":"M1 - Ray tracing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Ellipsoid {\n    vec3 center;   // Center\n    vec3 axes;     // Half-axes (semi-major, semi-minor, and vertical)\n    int i;         // Texture Id\n    vec3 color;    // Color\n};\n\nstruct Cylinder {\n    vec3 position;  // Position of the center of the cylinder\n    float radius;   // Radius of the cylinder\n    float height;   // Height of the cylinder\n    vec3 color;     // Color of the cylinder\n    int i;          // Texture Id\n};\n\nstruct Capsule {\n    vec3 start;      // Start point of the capsule\n    vec3 end;        // End point of the capsule\n    float radius;    // Radius of the capsule\n    int i;           // Texture Id\n};\n\nstruct Box {\n    vec3 min; // Minimum corner\n    vec3 max; // Maximum corner\n    int i;    // Texture Id\n};\n\nstruct Torus {\n    vec3 center;  // Center of the torus\n    float R;      // Major radius (distance from center to the center of the tube)\n    float r;      // Minor radius (radius of the tube)\n    int i;        // Texture Id\n};\n\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct SDFShape {\n    vec3 position; // Position de la forme\n    float size;    // Taille ou rayon de la forme\n    int i;         // ID de texture (si nécessaire)\n};\n\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material {\n    vec3 d;            // Diffuse color\n    float reflectivity; // Reflectivity (0.0 for fully diffuse, 1.0 for fully reflective)\n    float refractionIndex;\n};\n\n\nfloat SDFBox(vec3 p, float size) {\n    vec3 d = abs(p) - (vec3(size, size, size));\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\nvec3 UniformTexture(vec3 p)\n{\n    return vec3(0.5);  // Couleur grise uniforme\n}\n\nvec3 CheckerboardTexture(vec3 p, float cellSize)\n{\n    ivec3 c = ivec3(floor(p / cellSize));  // Cellule du damier en fonction de la position\n    int isOdd = (c.x + c.y + c.z) & 1;  // Vérifier si la cellule est impaire\n\n    if (isOdd == 1)\n    {\n        return vec3(0.2, 0.2, 0.2);  // Couleur sombre\n    }\n    else\n    {\n        return vec3(0.8, 0.8, 0.8);  // Couleur claire\n    }\n}\n\nvec3 ConcentricTexture(vec3 p, vec3 center, float numRings) {\n    float distance = length(p - center);\n    float ringWidth = 1.0 / numRings;\n    int ring = int(distance / ringWidth);\n\n    vec3 colors[3];\n    colors[0] = vec3(0.2, 0.4, 0.8);  // Couleur du centre\n    colors[1] = vec3(0.6, 0.8, 0.2);  // Couleur des anneaux\n    colors[2] = vec3(0.8, 0.2, 0.2);  // Couleur de la bordure\n\n    return colors[ring % 3];\n}\n\n\nvec3 RadialTexture(vec3 p, vec3 axis)\n{\n    float distance = length(p - axis);\n    vec3 centerColor = vec3(0.2, 0.4, 0.8);  // Couleur du centre\n    vec3 borderColor = vec3(0.8, 0.2, 0.2);  // Couleur de la bordure\n\n    float t = smoothstep(0.0, 0.2, distance);  // Transition douce entre les couleurs\n\n    return mix(centerColor, borderColor, t);\n}\n\n\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i)\n{\n    if (i == 1)\n    {\n        return Material(vec3(.8, .5, .4),1.0,1.0); // Matériau pour les cases spéculaires\n    }\n    else if (i == 0)\n    {\n        // Vous pouvez utiliser des coordonnées de texture pour créer un motif de damier\n        float checker = Checkers(p.xz);  // Utilisation des coordonnées xz pour créer un damier\n        if (checker > 0.5)\n        {\n            // Case diffuse\n            return Material(vec3(.4, .5, .7),0.0,1.0);\n        }\n        else\n        {\n            // Case spéculaire\n            return Material(vec3(.8, .5, .4),0.0,1.0);\n        }\n        \n    }\n    return Material(vec3(0),0.0,1.0);\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233)) * 43758.5453));\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\n\nvec3 MarbleTexture(vec2 st) {\n    vec2 p = st * 5.0; // Réglez l'échelle du marbre ici\n    float turbulence = 0.0;\n    float amplitude = 1.0;\n\n    for (int i = 0; i < 4; i++) { // Réglez le nombre d'octaves pour la complexité\n        turbulence += amplitude * noise(p);\n        p *= 2.0; // Réglez la fréquence du marbre\n        amplitude *= 0.5; // Réglez l'amplitude pour l'atténuation des octaves supérieurs\n    }\n\n    return vec3(turbulence); // Utilisez la valeur de bruit pour la couleur\n}\n\n// Fonction de translation d'un rayon\nRay TranslateRay(Ray ray, vec3 translation) {\n    // Crée la matrice de translation\n    mat4 translationMatrix = mat4(\n        1.0, 0.0, 0.0, translation.x,\n        0.0, 1.0, 0.0, translation.y,\n        0.0, 0.0, 1.0, translation.z,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    // Applique la translation à l'origine du rayon\n    ray.o = (translationMatrix * vec4(ray.o, 1.0)).xyz;\n\n    return ray;\n}\n\n// Fonction de rotation d'un rayon autour de l'axe Y\nRay RotateRayY(Ray ray, float angleInRadians) {\n    // Crée la matrice de rotation autour de l'axe Y\n    mat4 rotationMatrix = mat4(\n        cos(angleInRadians), 0.0, sin(angleInRadians), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin(angleInRadians), 0.0, cos(angleInRadians), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    // Applique la rotation à la direction du rayon\n    ray.d = (rotationMatrix * vec4(ray.d, 0.0)).xyz;\n\n    return ray;\n}\n\n// Fonction d'homothétie d'un rayon\nRay ScaleRay(Ray ray, vec3 scale) {\n    // Crée la matrice d'homothétie\n    mat4 scaleMatrix = mat4(\n        scale.x, 0.0, 0.0, 0.0,\n        0.0, scale.y, 0.0, 0.0,\n        0.0, 0.0, scale.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    // Applique l'homothétie à la direction du rayon\n    ray.d = (scaleMatrix * vec4(ray.d, 0.0)).xyz;\n\n    return ray;\n}\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x) {\n    vec3 ro = (ray.o - ellipsoid.center) / ellipsoid.axes;\n    vec3 rd = ray.d / ellipsoid.axes;\n\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        float t = min(t1, t2);\n\n        if (t > 0.0) {\n            vec3 p = Point(ray, t);\n            x = Hit(t, normalize(p - ellipsoid.center), ellipsoid.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool IntersectCylinder(Ray ray, Cylinder cylinder, out Hit x) {\n    vec3 oc = ray.o - cylinder.position;\n    vec3 d = ray.d;\n\n\n    float a = dot(d.xy, d.xy);\n    float b = 2.0 * dot(oc.xy, d.xy);\n    float c = dot(oc.xy, oc.xy) - cylinder.radius * cylinder.radius;\n\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n\n        float z1 = ray.o.z + t1 * d.z;\n        float z2 = ray.o.z + t2 * d.z;\n\n        if (t1 > 0.0 && z1 >= 0.0 && z1 <= cylinder.height) {\n            vec3 p1 = Point(ray, t1);\n            x = Hit(t1, normalize(p1 - cylinder.position), cylinder.i);\n            return true;\n        }\n\n        if (t2 > 0.0 && z2 >= 0.0 && z2 <= cylinder.height) {\n            vec3 p2 = Point(ray, t2);\n            x = Hit(t2, normalize(p2 - cylinder.position), cylinder.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool IntersectCapsule(Ray ray, Capsule capsule, out Hit x) {\n\n    vec3 axis = normalize(capsule.end - capsule.start);\n    vec3 oc = ray.o - capsule.start;\n    float t = dot(oc, axis);\n    t = clamp(t, 0.0, length(capsule.end - capsule.start));\n\n  \n    vec3 closestPoint = capsule.start + axis * t;\n    Sphere sphere = Sphere(closestPoint, capsule.radius, capsule.i);\n    return IntersectSphere(ray, sphere, x);\n}\n\nbool IntersectBox(Ray ray, Box box, out Hit x)\n{\n\n\n    vec3 tMin = (box.min - ray.o) / ray.d;\n    vec3 tMax = (box.max - ray.o) / ray.d;\n\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n\n    if (tNear > tFar || tFar < 0.0)\n    {\n        return false;\n    }\n\n\n    vec3 p = Point(ray, tNear);\n    vec3 n = normalize(sign(p - (box.max + box.min) * 0.5));\n\n\n    x = Hit(tNear, n, box.i);\n    return true;\n}\n\nbool IntersectTorus(Ray ray, Torus torus, out Hit x)\n{\n\n\n    float R = torus.R;\n    float r = torus.r;\n    vec3 center = torus.center;\n\n    vec3 oc = ray.o - center;\n\n    float a = dot(ray.d, ray.d);\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - (R * R + r * r);\n    float d = 2.0 * R * r;\n\n    float discriminant = b * b - a * c;\n\n    if (discriminant >= 0.0)\n    {\n        float t1 = (-b - sqrt(discriminant)) / a;\n        float t2 = (-b + sqrt(discriminant)) / a;\n\n        float phi1 = atan(oc.y, oc.x);\n        float phi2 = atan(oc.y, oc.x) + 3.14159265359 * 2.0;\n\n        vec3 p1 = Point(ray, t1);\n        vec3 p2 = Point(ray, t2);\n\n        float torusDist1 = length(vec2(length(p1.xz - center.xz), p1.y - center.y) - vec2(R, 0));\n        float torusDist2 = length(vec2(length(p2.xz - center.xz), p2.y - center.y) - vec2(R, 0));\n\n        if (torusDist1 < r && p1.y >= center.y && p1.y <= center.y + 2.0 * r && (phi1 >= 0.0 && phi1 <= 3.14159265359 * 2.0))\n        {\n            x = Hit(t1, normalize(p1 - vec3(center.x, p1.y, center.z)), torus.i);\n            return true;\n        }\n        if (torusDist2 < r && p2.y >= center.y && p2.y <= center.y + 2.0 * r && (phi2 >= 0.0 && phi2 <= 3.14159265359 * 2.0))\n        {\n            x = Hit(t2, normalize(p2 - vec3(center.x, p2.y, center.z)), torus.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool IntersectSDFShape(Ray ray, SDFShape shape, out Hit x) {\n    vec3 p = (ray.o - shape.position);\n    float d = SDFBox(p, shape.size);\n\n    if (d < 0.0) {\n        x = Hit(0.0, normalize(p), shape.i);\n        return true;\n    }\n\n    return false;\n}\n\n\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray, out Hit x) {\n    const Sphere sph1 = Sphere(vec3(0.0, 0.0, 1.0), 1.0, 1);\n    const Sphere sph2 = Sphere(vec3(2.0, 0.0, 2.0), 1.0, 1);\n    const Plane pl = Plane(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.0), 0);\n    const Ellipsoid ell = Ellipsoid(vec3(5.0, 0.0, 3.0), vec3(1.0, 0.5, 1.0), 4, vec3(0.0, 0.0, 1.0)); \n    const Cylinder cyl = Cylinder(vec3(-3.0, 0.0, 1.0), 1.0, 4.0, vec3(1.0, 0.0, 0.0), 4); \n    const Capsule cap = Capsule(vec3(2.0, 5.0, 1.0), vec3(2.0, 3.0, 1.0), 0.7, 5); \n    const Box box1 = Box(vec3(4., -4., 0.5), vec3(2., -2., 2.5), 2);\n    const Torus torus = Torus(vec3(3.0, 3.0, 4.0), 0.8, 1.0, 3); \n    \n    \n\n    \n\n    x = Hit(1000.0, vec3(0), -1);\n    Hit current;\n    bool ret = false;\n\n    if (IntersectSphere(ray, sph1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectSphere(ray, sph2, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectPlane(ray, pl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectEllipsoid(ray, ell, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectCylinder(ray, cyl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectCapsule(ray, cap, current) && current.t < x.t) {\n    x = current;\n    ret = true;\n}\n\n\n    if (IntersectBox(ray, box1, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectTorus(ray, torus, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    \n    \n\n    return ret;\n}\n\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n)\n{\n    vec3 light=normalize(vec3(1,1,1));\n    \n    float diff=clamp(dot(n,light),0.,1.);\n    vec3 col=m.d*diff+vec3(.2,.2,.2);\n    return col;\n}\n\nbool IsShadowed(vec3 point, vec3 lightPos) {\n    vec3 shadowRayDir = normalize(lightPos - point);\n    Ray shadowRay = Ray(point, shadowRayDir);\n    Hit shadowHit;\n\n    return Intersect(shadowRay, shadowHit) && shadowHit.t < length(lightPos - point);\n}\n\nvec3 Refract(vec3 incident, vec3 normal, float ior) {\n    float cosi = dot(incident, normal);\n    float eta = 1.0 / ior;\n\n    if (cosi < 0.0) {\n        cosi = -cosi;\n        normal = -normal;\n    } else {\n        eta = ior;\n    }\n\n    float k = 1.0 - eta * eta * (1.0 - cosi * cosi);\n    \n    if (k < 0.0) {\n        return vec3(0.0); \n    } else {\n        return eta * incident - (eta * cosi + sqrt(k)) * normal;\n    }\n}\n\n// Rendering\nvec3 Shade(Ray ray, int numAmbientRays) {\n    vec3 col = vec3(0.0);\n    Hit x;\n\n    int maxReflectionBounces = 1;\n\n    for (int bounce = 0; bounce <= maxReflectionBounces; bounce++) {\n        if (Intersect(ray, x)) {\n            vec3 p = Point(ray, x.t);\n            Material mat = Texture(p, x.i);\n            vec3 normal = x.n;\n            \n            if (x.i == 2) {\n            vec2 st = vec2(p.x, p.y); \n            vec3 marbleColor = MarbleTexture(st); \n            return marbleColor;\n            }\n            \n            if (x.i == 4) { \n              return ConcentricTexture(p, vec3(-3.0, 0.0, 1.0), 3.0);\n            }\n            \n            if (x.i == 5) {  \n              return UniformTexture(p);\n            }\n            \n            float ambientOcclusion = 0.0;\n            for (int i = 0; i < numAmbientRays; i++) {\n                vec3 randomDir = normalize(vec3(random(vec2(i, bounce)), random(vec2(i, bounce + 1)), random(vec2(i, bounce + 2))));\n                Ray ambientRay = Ray(p, randomDir);\n\n                if (!IsShadowed(p, Point(ambientRay, 1.0))) {\n                    ambientOcclusion += 1.0;\n                }\n            }\n            ambientOcclusion /= float(numAmbientRays);\n\n            // Composante ambiante\n            vec3 ambient = mat.d * ambientOcclusion;\n\n            // Diffuse and specular components\n            vec3 totalDiffuse = vec3(0.0);\n            vec3 totalSpecular = vec3(0.0);\n\n            vec3 pointLightColor = vec3(1.0, 1.0, 1.0);  // Light color\n            vec3 pointLightPos = vec3(3.0, 3.0, 4.0);  // Light position\n            vec3 pointLightDir = normalize(pointLightPos - p);\n            \n            if (!IsShadowed(p, pointLightPos)) {\n                // Pas d'ombre, appliquez la composante diffuse\n                float diff = max(dot(normal, pointLightDir), 0.0);\n                col += pointLightColor * mat.d * diff;\n\n                // Specular component (Phong model)\n                vec3 viewDir = normalize(ray.o - p);\n                vec3 reflectDir = reflect(-pointLightDir, normal);\n                float pointLightSpec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 32.0);\n                col += vec3(1.0, 1.0, 1.0) * pointLightSpec;\n            } else {\n                // Dans l'ombre, renvoyez une couleur d'ombre\n                col += vec3(0.0);\n            }\n\n            // Diffuse component\n            float diff = max(dot(normal, pointLightDir), 0.0);\n            totalDiffuse += pointLightColor * mat.d * diff;\n\n            // Specular component (Phong model)\n            vec3 viewDir = normalize(ray.o - p);\n            vec3 reflectDir = reflect(-pointLightDir, normal);\n            float pointLightSpec = pow(clamp(dot(viewDir, reflectDir), 0.0, 0.8), 32.0);\n\n            totalSpecular += vec3(1.0, 1.0, 1.0) * pointLightSpec;\n\n            if (mat.reflectivity > 0.0 && bounce < maxReflectionBounces) {\n                vec3 reflectedDir = reflect(ray.d, normal);\n                ray = Ray(p, reflectedDir);\n\n            } else {\n                col = ambient + (totalDiffuse + totalSpecular);\n                break;\n            }\n        } else {\n            col = Background(ray.d);\n            break;\n        }\n    }\n\n    return col;\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\n    \n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n\n    // Render\n    vec3 col=Shade(Ray(ro,rd),2);\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}