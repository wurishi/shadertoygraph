{"ver":"0.1","info":{"id":"dt23RK","date":"1675443927","viewed":167,"name":"Rockpools, bumps from depthmap","username":"DwayneBrah","description":"I needed a more efficient way of faking bumpmaps using parallax scrolling by outsourcing it to the GPU.\n\nThis works well, but i sure went overboard on the embelishments.\nStripped down, this is a nice efficient way of adding dimension to scrolling games.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["water","parallax","bumpmapping","bumpmap","pools","beach","depthmap","rockpools"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// No polygons or trigonometry functions were hurt during production \n\n\n\n\n// OK. This started out as a very efficient faux-bumpmapper \n// designed to replace a non-GL, complex paralax scroller in my android game\n\n// I got carried away and added a ton of other things that dent performance significantly.\n// This is by no means a set of best practices, i don't think any of the effects are calculated \n// with correct triganometry. But it sure is useful in adding depth to game backgrounds etc.\n\n// I've left this over-verbose version here for easy comprehension.\n\nfloat phase;\nvec2 light_direction = vec2(0.040, 0.040);\nfloat extrude_amount = 0.12;\nfloat water_level = 0.34;\nfloat height_multiplier_master = 1.00;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    if (mouse.x == 0.00) {\n        mouse.x = 0.50;\n        mouse.y = 0.50;\n    }\n    \n    \n    // Phase and pan\n    phase = iTime/10.00;\n    vec2 pan_offset = vec2(sin(phase), cos(phase));\n    float view_distance = sin(phase)*0.40+0.90;\n    \n    \n    \n    // Zoom calcs\n    vec2 from_middle = (uv-vec2(0.5,0.5));\n    vec2 full_zoom_pixel_offset = 0.00-(from_middle*extrude_amount);\n    \n    vec2 base_texture_coord = (uv+pan_offset)*view_distance;\n    \n    \n    vec2 flat_image_coord = base_texture_coord;\n    vec4 flat_image = texture(iChannel1, flat_image_coord);\n    \n    \n    float decided_lightness = 1.00;\n    float decided_height_level = 0.00;\n    float decided_height_level_actual = 0.00;\n    \n    vec2 decided_zoomed_texture_coord;\n    vec4 decided_zoomed_image = flat_image;\n    \n    \n    float current_check_height = 0.00;\n    float current_step = 0.00;\n    \n\n    float height_step = 0.06;\n    for (float zoom_level_to_check = 0.00; zoom_level_to_check < 1.00; zoom_level_to_check += 0.10) {\n        \n        // Get height at this zoom level\n        vec2 zoomed_texture_coord = base_texture_coord+(full_zoom_pixel_offset*zoom_level_to_check);\n        vec4 zoomed_texture = texture(iChannel0, zoomed_texture_coord);\n        vec4 zoomed_image_for_bumps = texture(iChannel1, zoomed_texture_coord);\n        float this_zoomed_height = zoomed_texture.r;\n        \n        // vary height\n        float height_multiplier = height_multiplier_master * sin(zoomed_texture_coord.x);\n        this_zoomed_height -= height_multiplier*0.05;\n        \n        // Experimental crude bumpmapping from image\n        float ground_intensity = (zoomed_image_for_bumps.r + zoomed_image_for_bumps.g +zoomed_image_for_bumps.b)/3.00;\n        this_zoomed_height -= (0.30-clamp(ground_intensity, 0.00, 0.30))*0.10;\n        \n        // Where is the slope facing?\n        vec4 zoomed_texture_displaced = texture(iChannel0, zoomed_texture_coord+light_direction);\n        float facing_height = zoomed_texture_displaced.r;\n        float steepness = facing_height/this_zoomed_height;\n        float gradient_to_light = 0.50;\n        float gradient_closeness = gradient_to_light-steepness;\n        float lightness = 1.00 / gradient_closeness;\n        lightness = 1.00 + 1.00 * gradient_closeness;\n        \n        vec2 zoomed_image_coord = base_texture_coord+(full_zoom_pixel_offset*zoom_level_to_check);\n        vec4 zoomed_image = texture(iChannel1, zoomed_image_coord*1.1);\n        \n        // Log the highest point found\n        if (this_zoomed_height >= current_check_height) {\n            \n            // Fading the edges - not essential looks better with fewer slices\n            float fadedness = (this_zoomed_height - current_check_height)*10.00;\n            \n            if (fadedness < 1.00) {\n                 decided_zoomed_image = mix(decided_zoomed_image, zoomed_image, fadedness);\n            } else {\n                 decided_zoomed_image = zoomed_image;\n            }\n            \n            \n            decided_zoomed_texture_coord = zoomed_texture_coord;\n            decided_lightness = lightness;\n            decided_height_level = current_check_height;\n            decided_height_level_actual = this_zoomed_height;\n        }\n        \n        current_step += 1.00;\n        \n        \n        float perspective_exaggerate = 0.006;\n        current_check_height = (current_step*height_step)*(1.00-(current_step*perspective_exaggerate));\n\n    }\n    \n    // Find shadow\n    vec2 shadow_sample_offset;\n    vec2 zoomed_texture_coord_shadow_sample;\n    float shadow_amount = 0.00;\n    for (float shadow_distance = -0.10; shadow_distance < 1.00; shadow_distance += 0.20) {\n        \n        shadow_sample_offset = vec2(light_direction.x, light_direction.y)*shadow_distance;\n        zoomed_texture_coord_shadow_sample = decided_zoomed_texture_coord+shadow_sample_offset;\n        vec4 zoomed_texture_shadow_sample = texture(iChannel0, zoomed_texture_coord_shadow_sample);\n        float this_shadow_sample_height = zoomed_texture_shadow_sample.r;\n        \n        float shadow_angle = 0.19;\n        if (decided_height_level_actual-0.15 < water_level) {\n            if (water_level <= this_shadow_sample_height) {\n                shadow_amount = 0.02;\n            } else {\n                // Diminished shadows underwater\n                shadow_amount = 0.00;\n            }\n        } else {\n            // If above water\n            if (decided_height_level_actual+shadow_angle < this_shadow_sample_height) {\n                shadow_amount = 0.30;\n            }\n\n        }\n        \n    }\n    \n    \n    // Calculate coast\n    float cost_size = 0.30;\n    float coast_amount = 0.00;\n    if (decided_height_level < water_level+cost_size) {\n        if (decided_height_level > water_level-cost_size) {\n            \n            float dist_from_surface = abs (water_level-decided_height_level);\n            dist_from_surface *= (1.00/cost_size);\n            if (dist_from_surface == 0.00) {\n                dist_from_surface = 0.01;\n            }\n            \n            coast_amount = 0.10*(0.20/dist_from_surface);\n            \n        }\n    }\n    \n\n    // Mixing\n    vec4 final_color = decided_zoomed_image;\n    \n    // Improve land visibilty\n    float base_lightness = 0.10;\n    final_color = final_color + base_lightness;\n\n    // Apply shadow to land\n    final_color -= shadow_amount;\n    \n    // Apply coast\n    if (coast_amount > 0.00) {\n        \n       vec4 coast_color = vec4(-0.10, -0.20, -0.80, 1.00);\n       final_color = mix(final_color, coast_color, coast_amount*0.33);\n        \n    }\n    \n    // Lighting\n    float lighting_amount = 1.00;\n    float lightness_multiplier = (-0.00+decided_lightness*lighting_amount);\n    lightness_multiplier = clamp(lightness_multiplier, -0.20, 1.20);\n    vec4 final_color_lit = final_color*lightness_multiplier;\n    final_color = mix(final_color, final_color_lit, 0.70);\n    \n    // Fake occlusion at depth\n    vec4 fog_color = vec4(0.04, 0.15, 0.15, 1.00);\n    float fog_height = 0.30;\n    if (decided_height_level_actual < fog_height) {\n    \n        float fog_intensity = 1.00 - (decided_height_level_actual*(1.00/fog_height));\n        final_color = mix(final_color, fog_color, fog_intensity); \n        \n    }\n    \n    // Water\n    vec2 sheen_point = vec2(0.75, 0.75);\n    float distace_from_sheen = abs(distance(sheen_point, uv));\n    if (decided_height_level < water_level) {\n    \n        vec4 water_color = vec4(68.00/256.00, 200.00/256.00, 255.00/256.00, 1.00);\n\n        final_color = final_color*water_color;\n        float water_lightness = 0.60;\n        final_color *= water_lightness;\n        \n        // water sheen\n        float sheen_dropoff = 0.80;\n        float sheen_amount = 0.05/(distace_from_sheen*sheen_dropoff);\n        \n        float sheen_mix = 0.90;\n        float default_sheen = 0.20;\n        if (shadow_amount == 0.00) {\n            final_color += clamp((sheen_amount)*sheen_mix, 0.00, 0.80);\n        }\n        \n        final_color += default_sheen;\n        \n    }\n    \n    // Specular\n    float clamp_start = 0.90;\n    if (shadow_amount == 0.00 && (decided_height_level > water_level || coast_amount > 0.10)) {\n        float sheen_amount = 2.10/(distace_from_sheen*1.60);\n    \n        float specular_clamp = clamp(lightness_multiplier, clamp_start, 2.00)-clamp_start;\n        float specular_amount = specular_clamp*specular_clamp*specular_clamp;\n        final_color += specular_amount*sheen_amount;\n    }\n    \n    // Vignette\n    float vignette_intensity = 0.10;\n    float closeness_to_edge_x = abs(uv-0.50).x * 2.00;\n    float closeness_to_edge_y = abs(uv-0.50).y * 2.00;\n    float vignette_darkening = (closeness_to_edge_x*closeness_to_edge_x*closeness_to_edge_x + closeness_to_edge_y*closeness_to_edge_y);\n    final_color -= mix(final_color, vec4(0.00, 0.00, 0.00, 1.00), 1.00-vignette_darkening*vignette_intensity);\n    \n    // Output\n    fragColor = final_color;\n\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}