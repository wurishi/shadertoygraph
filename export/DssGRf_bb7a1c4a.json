{"ver":"0.1","info":{"id":"DssGRf","date":"1666562927","viewed":197,"name":"Slime Battles","username":"fenix","description":"While fiddling around with the automaton in Euler Tangles, I somehow got this result that looks to me like blobs of goo fighting for territory, so I leaned into that idea with some rendering changes.\n*space to reset*\n*mouse to add noise*","likes":6,"published":3,"flags":48,"usePreview":0,"tags":["2d","slime","automata","cellular","battle","automaton"],"hasliked":0,"parentid":"sl3BRr","parentname":"Slime Battles (old preview...?)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  While fiddling with the automaton in Euler Tangles\n//\n//      https://www.shadertoy.com/view/fl3fzr\n//\n//  I somehow got this result that looks  to me like blobs of goo fighting for\n//  territory, so I leaned into that idea with some rendering changes. \n//\n//  Buffer A runs the cellular automaton/particle sim\n//  Buffer B just renders the particle densities so we can filter them next\n//  Buffer C performs a density blur to smooth the gradients for rendering\n// \n// ---------------------------------------------------------------------------------------\n\nvec3 floatToColor(float f)\n{\n    return normalize(sin((f) * vec3(1, 2, 8) + vec3(2,6,8)) * 0.5 + 0.5);\n}\n\nvec2 grad(vec2 fragCoord, ivec2 delta)\n{\n    return vec2(texelFetch(iChannel1, ivec2(fragCoord) + delta.xy, 0).x - \n        texelFetch(iChannel1, ivec2(fragCoord) - delta.xy, 0).x,\n        texelFetch(iChannel1, ivec2(fragCoord) + delta.yx, 0).x - \n        texelFetch(iChannel1, ivec2(fragCoord) - delta.yx, 0).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    cellData d = unpackCell(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    \n    vec2 g = grad(fragCoord, ivec2(1, 0));\n    g = mix(g, g + normalize(g), smoothstep(0.04, 0.06, length(g)));\n    vec3 n = normalize(vec3(g, 1));\n    const vec3 lightDir = normalize(vec3(1,-1,1));\n    float dp = dot(n, lightDir);\n    float spec = pow(dp, 15.) * .3;\n    float diff = dp * 0.6 + 0.4;\n    \n    fragColor = vec4(floatToColor(d.color) * d.trailDensity, 1) * diff + spec;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float MAX_AGE = 40000.0; // Particles die after this many frames\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    \n    if (ifc == ivec2(0))\n    {\n        // Reset if resolution doesn't match\n        if (iFrame == 0 || abs(state.xy) != iResolution.xy || keyDown(KEY_SPACE))\n        {\n            fragColor = vec4(-iResolution.xy, vec2(-1));\n        }\n        else\n        {\n            if (iMouse.z > 0.)\n            {\n                state.zw = iMouse.xy / iResolution.xy;\n            }\n            else\n            {\n                state.zw = vec2(-1.);\n            }\n            \n            fragColor = vec4(abs(state.xy), state.zw);\n        }\n        return;\n    }\n    \n    float h = hash(\n        ifc.x + \n        ifc.y*int(iResolution.x) + \n        iFrame*int(iResolution.x*iResolution.y)\n    );\n    \n    if (false)\n    {\n        // Clear buffer\n        cellData init;\n        init.pos = vec2(0.5, 0.5);\n        init.vel = vec2(0);\n        init.density = 0.0;\n        init.trailDensity = 0.0;\n        init.color = 0.0;\n        init.age = 0.0;\n        \n        fragColor = packCell(init);\n\n        return;\n    }\n    \n    if (state.z >= 0.0)\n    {\n        float d = linePointDist2(iMouse.xy/iResolution.xy, state.zw, fragCoord/ iResolution.xy);\n\n        h += .000001/d;\n    }\n\n    if (h > 0.99999 || iFrame == 0 || state.x < 0.)\n    {\n        // Spawn new particle\n        vec3 h3 = hash3(uvec3(fragCoord, iFrame));\n\n        cellData newParticle;\n        newParticle.pos = vec2(0.5, 0.5); // Start in the middle of the cell\n        newParticle.vel = vec2(h3.x - 0.5, h3.y - 0.5);\n        newParticle.density = 1.0;\n        newParticle.trailDensity = 1.0;\n        newParticle.color = h3.z;\n        newParticle.age = 0.;\n        \n        fragColor = packCell(newParticle);\n    }\n    else\n    {\n        float newDensity = 0.;\n        vec2 newVel = vec2(0), newPos = vec2(0);\n        cellData d = unpackCell(texelFetch(iChannel0, ivec2(fragCoord), 0));\n\n        float h1 = hash(\n            ifc.x*int(iResolution.x) + \n            ifc.y*int(iResolution.y) + \n            iFrame*int(iResolution.x*iResolution.y)\n        );\n        float h2 = hash(int(h1*994888228.));\n\n        // Search the nearest NxN cells to find any that has density that wants to move into our cell\n        // Bigger RANGE makes larger velocities possible, but starts to be prohibitively expensive\n        const int RANGE = 4;\n        ivec2 dir = ivec2(sign(vec2(h1 - 0.5, h2 - 0.5)));\n        for (int x = -RANGE; x <= RANGE; ++x)\n        {\n            for (int y = -RANGE; y <= RANGE; ++y)\n            {\n                if (ifc.x + x < 0 || ifc.x + x >= int(iResolution.x)) continue;\n                if (ifc.y + y < 0 || ifc.y + y >= int(iResolution.y)) continue;\n\n                cellData nb = unpackCell(texelFetch(iChannel0, ivec2(fragCoord) + dir * ivec2(x, y), 0));\n\n                vec2 nbPos = nb.pos + vec2(x, y);\n                vec2 newNbPos = nbPos + nb.vel * float(RANGE);\n\n                if (nb.density > 0. && nb.age < 1.0) // Note: also rejecting particles here thar are too old\n                {\n                    // Draw smooth line from old position to new, even if it jumped past our position\n                    float aa = smoothstep(2.2, 0.1, sqrt(linePointDist2(fragCoord + newNbPos, fragCoord + nbPos, fragCoord)));\n                    \n                    // Use full color if we're drawing on black\n                    d.color = d.trailDensity < .2 || aa > .2 ? nb.color : d.color;\n                    d.trailDensity += aa;\n                    \n                    if (all(greaterThan(newNbPos, vec2(0))) && all(lessThan(newNbPos, vec2(1))))\n                    {\n                        newPos = newNbPos;\n                        newVel = nb.vel;\n                        newDensity = 1.;\n                    \n                        d.age = nb.age;\n                        d.color = nb.color; // Copy over the whole color so it doesnt get lost even with thin lines\n                    }\n                }\n            }\n        }\n\n        // Record data in fragColor\n        d.pos = newPos;\n        d.vel = newVel;\n        d.density = newDensity * 1000.;\n        d.trailDensity *= 0.999; // Fade out painted areas slowly\n        d.age += 1. / MAX_AGE;\n\n        fragColor = packCell(d);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float pack2(vec2 v)\n{\n    return uintBitsToFloat(packSnorm2x16(v));\n}\n\nvec2 unpack2(float f)\n{\n    return unpackSnorm2x16(floatBitsToUint(f));\n}\n\nstruct cellData\n{\n    vec2 pos; // position within the cell, 0 ... 1\n    vec2 vel; // -1 ... 1, multiplied by RANGE\n    float density; // either 0 or 1, depending on if a particle is present\n    float trailDensity; // allows particles to leave trails behind, 0 ... 1\n    float color; // color of trail, 0 ... 1\n    float age; // 0 ... 1\n};\n\ncellData unpackCell(vec4 c)\n{\n    cellData d;\n    \n    d.pos = unpack2(c.x);\n    d.vel = unpack2(c.y);\n    vec2 den = unpack2(c.z);\n    d.density = den.x;\n    d.trailDensity = den.y;\n    vec2 colorAge = unpack2(c.w);\n    d.color = colorAge.x;\n    d.age = colorAge.y;\n    \n    return d;\n}\n\nvec4 packCell(cellData d)\n{\n    float x = pack2(d.pos);\n    float y = pack2(d.vel);\n    float z = pack2(vec2(d.density, d.trailDensity));\n    float w = pack2(vec2(d.color, d.age));\n    \n    return vec4(x, y, z, w);\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat2 rot2(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat length2(vec2 a)\n{\n    return dot(a, a);\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    return dot(closestDelta, closestDelta);\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    fragColor.x = unpackCell(texelFetch(iChannel0, ivec2(fragCoord), 0)).density * 20.;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N = 13; // 7                              // target sampling rate\nfloat         w = .1,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  w = 5./R.y; \\\n              z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nfloat convol2D(vec2 U) {                                                     \n    float  O = 0.0;  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z ).x;                 \n    }                                                                       \n    return O/t;                                                             \n}      \n\nfloat square(float x) { return x*x; }\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init \n    vec2 U = u / R.y;  \n    O = texelFetch(iChannel1, ivec2(u), 0);\n    O.x = mix(O.x, max(0., convol2D(U)), 0.1);\n    if (iFrame == 0) O == vec4(0);\n}\n\n","name":"Buffer C","description":"","type":"buffer"}]}