{"ver":"0.1","info":{"id":"4dKyRz","date":"1520859671","viewed":13325,"name":"Ray Marching Demo For Beginner","username":"Trashe725","description":"This is a simple demonstration I made for some ray marching beginners.\nYou can drag your mouse to move the origin/target point. \nClick arrow to increase/decrease the marching step.\n\nhave fun :p\n\ninspired by GPU Gem2 Chapter 8: https://imgur.com/YcpvFej","likes":89,"published":1,"flags":32,"usePreview":0,"tags":["2d","raymarching","beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VIG 1\n#define FAR_PLANE 100.\n\nfloat asp;\nvec4 bufA;\nvec4 bufB;\nvec4 bufC;\nvec4 bufD;\n\nfloat word_map(vec2 uv, vec2 pos, int ascii, vec2 unit)\n{\n    return get_text(uv, pos, ascii, unit, iChannel3);\n}\n\nfloat map001(vec2 p)\n{\n\tfloat h;\n    h = line(p, vec2(-asp, -0.8), vec2(-asp*0.8, -0.8));\n    h = min(h, line(p,  vec2(-asp*0.8, -0.8),  vec2(-asp*0.8, 0.2)));\n    h = min(h, line(p,  vec2(-asp*0.8, 0.2),   vec2(-asp*0.5, 0.2)));\n    h = min(h, line(p,  vec2(-asp*0.5, 0.2),   vec2(-asp*0.5, -0.8)));\n    h = min(h, line(p,  vec2(-asp*0.5, -0.8),  vec2(-asp*0.05, -0.8)));\n    h = min(h, line(p,  vec2(-asp*0.05, -0.8), vec2(asp*0.2, -0.4)));\n    h = min(h, line(p,  vec2(asp*0.2, -0.4),   vec2(asp*0.45, -0.8)));\n    h = min(h, line(p,  vec2(asp*0.45, -0.8), vec2(asp, -0.8)));\n    return h;\n}\n\n\nfloat map002(vec2 p)\n{\n\tfloat h;\n    h = circle(p, vec2(0., -asp*1.7), asp*1.5);\n    h = min(h, box(p, vec2(0., 0.15), vec2(asp*0.3,0.2)));\n    return h;\n}\n\nfloat map003(vec2 p)\n{\n\tfloat h;\n    h = triangle(p, vec2(0., 0.2), vec2(-0.2, -0.2), vec2(0.2, -0.2));\n    h = min(h, triangle(p-vec2(0.5, 0.4), vec2(0., -0.2), vec2(-0.2, 0.2), vec2(0.2, 0.2)));\n    h = min(h, triangle(p-vec2(-0.5, 0.4), vec2(0., -0.2), vec2(-0.2, 0.2), vec2(0.2, 0.2)));\n    \n    h = min(h, triangle(p-vec2(0.5, -0.4), vec2(0., 0.2), vec2(-0.2, -0.2), vec2(0.2, -0.2)));\n    h = min(h, triangle(p-vec2(-0.5, -0.4), vec2(0., 0.2), vec2(-0.2, -0.2), vec2(0.2, -0.2)));\n    \n    h = min(h, triangle(p-vec2(-1.0, 0.), vec2(0., 0.2), vec2(-0.2, -0.2), vec2(0.2, -0.2)));\n    h = min(h, triangle(p-vec2(1.0, 0.), vec2(0., 0.2), vec2(-0.2, -0.2), vec2(0.2, -0.2)));\n    \n    return h;\n}\n\n// from iq\nfloat map004(vec2 c)\n{\n    c.x *= -1.;\n    c -= vec2(0.9, -0.8);\n    \n\tfloat h;\n    \n    vec2 z = vec2(0.);\n    vec2 dz = vec2(0.);\n    float m = 0.;\n    \n    for(int i = 0; i < 20;++i)\n    {\n        if(m > 1024.)\n            break;\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n        z = cx_pow2(z) + c;\n        \n        m = dot(z,z);\n    }\n    \n    float d = 0.5*sqrt(m/dot(dz,dz))*log(m);\n\n    return d*0.8;\n}\n\n//------------------------------------\n//- you can change this map function -\n//------------------------------------\nfloat map(vec2 p)\n{\n    int m = int(GET_MAP_NUM);\n    if(m == 0)\n\t\treturn map001(p);\n    else if(m == 1)\n        return map002(p);\n    else if(m == 2)\n        return map003(p);\n    else\n        return map004(p);\n    \n}\n\nvec4 sphere_range(vec4 col, vec2 p, vec2 center, float r)\n{\n\tfloat h;\n    \n    h = circle(p, center , r);\n    col = blend(col, vec4(0.435, 0.8, 0., smoothstep(0.01, 0., abs(h))));\n    \n    return col;\n}\n\nvec4 sphere_point(vec4 col, vec2 p, vec2 center, vec3 inner_col, vec3 outer_col)\n{\n\tfloat h;\n    \n    h = circle(p, center, 0.02);\n    col = blend(col, vec4(inner_col, smoothstep(0.01, 0., h)));\n    \n    h = circle(p, center, 0.02);\n    col = blend(col, vec4(outer_col, smoothstep(0.01, 0., abs(h))));\n    \n    return col;\n}\n\nvec4 sphere_search(vec4 col, vec2 p, vec2 center)\n{\n\tfloat d = map(center)*0.99;\n    \n    float h;\n    \n    col = sphere_range(col, p, center, d);\n    col = sphere_point(col, p, center, vec3(0., 0.8, 1.), vec3(0., 0.435, 1.));\n    \n    return col;\n}\n\nvec4 put_text_point_num(vec4 col, vec2 uv, vec2 pos, float scale, int num)\n{\n\tfloat unit = asp * scale * 0.1;\n    float h = 0.;\n    vec2 sc = vec2(unit, unit);\n    int d = num % 10;\n    int t = num / 10;\n    \n    \n    h = max(h, word_map(uv, pos, 80, sc));\n    \n    if(t > 0)  // Ptd\n    {\n    \th = max(h, word_map(uv, pos+vec2(unit*0.3, -unit*0.1), 48+t, sc*0.6));\n        h = max(h, word_map(uv, pos+vec2(unit*0.5, -unit*0.1), 48+d, sc*0.6));\n    }\n    else  //Pd\n    {\n    \th = max(h, word_map(uv, pos+vec2(unit*0.3, -unit*0.1), 48+d, sc*0.6));\n    }\n    \n    col = blend(col, vec4(0., 0.435, 1., h));\n    \n    return col;\n}\n\nvec4 draw_ray(vec4 col, vec2 p, vec2 a, vec2 b)\n{\n\tfloat h = line(p, a, b);\n    col = blend(col, vec4(0., 0.435, 1., smoothstep(0.01, 0., abs(h))));\n    return col;\n}\n\nvec4 draw_arrow(vec4 col, vec2 p, vec2 a, vec2 b)\n{\n    vec2 l = (a-b);\n    \n    float ang = 3.1415926/6.;\n    \n    vec2 r1 = vec2(cos(ang), sin(ang));\n    vec2 r2 = vec2(cos(-ang), sin(-ang));\n    vec2 p1 = b+l*mat2(r1.x, -r1.y, r1.y, r1.x)*0.2;\n    vec2 p2 = b+l*mat2(r2.x, -r2.y, r2.y, r1.x)*0.2;\n    \n    \n    float h = line(p, a, b);\n    h = min(h, line(p, b, p1));\n    h = min(h, line(p, b, p2));\n    \n    col = blend(col, vec4(0., 0.435, 1., smoothstep(0.01, 0., abs(h))));\n \treturn col;\n}\n\n\nvec4 draw_map(vec4 col, vec2 p)\n{\n    float h = map(p);\n    \n    col = blend(col, vec4(vec3(.7), smoothstep(0.01, 0., h)));\n    col = blend(col, vec4(vec3(.0), smoothstep(0.01, 0., abs(h))));\n    \n\treturn col;\n}\n\nvec3 render(vec2 p)\n{\n    vec2 p0_center = GET_ORIGIN;\n\tvec2 p4_center = GET_TARGET;\n    \n    vec2 pos = p0_center;\n    vec2 dir = normalize(p4_center - p0_center);\n    mat2 text_rt = mat2(0.5, -0.866, 0.866, 0.5);\n    vec2 text_dir = text_rt*dir;\n    \n\tvec4 bg = vec4(1.);\n    vec4 canvus1 = vec4(0.);\n    vec4 canvus2 = vec4(0.);\n    vec4 canvus3 = vec4(0.);\n    \n    if(is(GET_DRAW_MAP)){ //draw map\n    \tcanvus1 = draw_map(canvus1, p);\n    }\n\n    if(is(GET_DRAW_START)){  //draw start\n\n        //second march: draw point\n        pos = p0_center;\n        float len = 0.;\n        canvus2 = sphere_point(canvus2, p, pos, vec3(0., 0.8, 1.), vec3(0., 0.435, 1.));\n        \n        canvus3 = put_text_point_num(canvus3, p, pos+text_dir*0.08, .6, 0);\n\n        for(int i=0;i<int(GET_STEP_COUNT);++i){  //step count\n            len = map(pos);\n            canvus2 = sphere_range(canvus2, p, pos, len);\n            pos += dir * len;\n            canvus3 = sphere_point(canvus3, p, pos, vec3(0., 0.8, 1.), vec3(0., 0.435, 1.));\n            canvus3 = put_text_point_num(canvus3, p, pos+text_dir*0.08, .6, i+1);\n            if(len > FAR_PLANE)\n                break;\n        }\n        \n        \n        if(int(GET_STEP_COUNT) == 0){  //step count\n        \tcanvus1 = draw_arrow(canvus1, p, p0_center, p0_center+dir*0.2);\n        }\n        else\n        {\n        \tcanvus1 = draw_ray(canvus1, p, p0_center, pos);\n        }\n    }\n    \n    \n    if(is(GET_SHOW_TAR)){  //show target position\n    \tcanvus3 = sphere_point(canvus3, p, p4_center, vec3(1., 0.64, 0.85), vec3(1., 0., 0.));\n    }\n    \n    bg = mix(bg, canvus1, canvus1.a);\n    bg = mix(bg, canvus2, canvus2.a);\n    bg = mix(bg, canvus3, canvus3.a);\n    \n    \n    return bg.rgb;\n}\n\nvoid initBuffer()\n{\n\tbufA = texture(iChannel1, vec2(0.0, 0.0));\n    bufB = texture(iChannel1, vec2(1.0, 0.0));\n    bufC = texture(iChannel1, vec2(0.0, 1.0));\n    bufD = texture(iChannel1, vec2(1.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    initBuffer();\n    \n    asp = iResolution.x/iResolution.y;\n    \n    vec2 uv =( -iResolution.xy + 2.*fragCoord.xy )/ iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    col = render(uv);\n    \n    vec4 gui = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    col = mix(col, gui.rgb, gui.a);\n    \n    //iq's vingette from:\n    //https://www.shadertoy.com/view/XdKyRR\n#if VIG\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );       \n    col *= 0.9 + 0.1*texture(iChannel2, fragCoord.xy/256.).x;\n#endif\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat asp;\nvec4 bufA;\nvec4 bufB;\nvec4 bufC;\nvec4 bufD;\n\n\nvec4 gui_check_box(vec4 col, vec2 uv, vec2 pos, float scale, bool check)\n{\n    \n    float unit = asp * 0.01 * scale;\n    float h = box(uv, pos, vec2(1.8*unit));\n    col = mix(col, vec4(vec3(0.9, 0.9, 1.), 1.), smoothstep(0.01, 0., h));\n    col = mix(col, vec4(vec3(0., 0., 0.5), 1.), smoothstep(0.01, 0., abs(h)));\n    \n    \n    if(check)\n    {\n        const vec2 dir1 = normalize(vec2(-1., 1.2));\n        const vec2 dir2 = normalize(vec2(1., 1.));\n    \th = line(uv, pos+vec2(0., unit*-0.5), pos+dir1*unit*2.1);\n        col = mix(col, vec4(1., 0., 0., 1.), smoothstep(0.01, 0., abs(h)));\n        h = line(uv, pos+vec2(0., unit*-0.5), pos+dir2*unit*4.2);\n        col = mix(col, vec4(1., 0., 0., 1.), smoothstep(0.01, 0., abs(h)));\n    }\n    \n    return col;\n}\n\nvec4 gui_arrow_left(vec4 col, vec2 uv, vec2 pos, float scale, bool check)\n{\n    float unit = asp * 0.01 * scale;\n    float h;\n    \n    h = triangle(uv, pos+vec2(unit*1.8, -unit*2.), pos+vec2(unit*1.8, unit*2.), pos+vec2(-unit*1.8, 0.));\n    if(!check) h = abs(h);\n    col = mix(col, vec4(vec3(0.5), 1.), smoothstep(0.01, 0., h));\n    \n    \n    return col;\n}\n\nvec4 gui_arrow_right(vec4 col, vec2 uv, vec2 pos, float scale, bool check)\n{\n\tfloat unit = asp * 0.01 * scale;\n    float h;\n    \n    h = triangle(uv, pos+vec2(-unit*1.8, -unit*2.), pos+vec2(-unit*1.8, unit*2.), pos+vec2(unit*1.8, 0.));\n    if(!check) h = abs(h);\n    col = mix(col, vec4(vec3(0.5), 1.), smoothstep(0.01, 0., h));\n    \n    \n    return col;\n}\n\nfloat word_map(vec2 uv, vec2 pos, int ascii, vec2 unit)\n{\n    return get_text(uv, pos, ascii, unit, iChannel1);\n}\n\nvec4 put_text_drawmap(vec4 col, vec2 uv, vec2 pos, float scale)\n{\n\tfloat unit = asp * scale * 0.1;\n    float h = 0.;\n    vec2 sc = vec2(unit, unit*0.8);\n    \n    // S\n    h = max(h, word_map(uv, pos, 83, sc));\n    // h\n    h = max(h, word_map(uv, pos+vec2(unit*0.4, 0.), 104, sc));\n    // o\n    h = max(h, word_map(uv, pos+vec2(unit*0.8, 0.), 111, sc));\n    // w\n    h = max(h, word_map(uv, pos+vec2(unit*1.2, 0.), 119, sc));\n    // M\n    h = max(h, word_map(uv, pos+vec2(unit*2.0, 0.), 77, sc));\n    // a\n    h = max(h, word_map(uv, pos+vec2(unit*2.4, 0.), 97, sc));\n    // p\n    h = max(h, word_map(uv, pos+vec2(unit*2.8, 0.), 112, sc));\n    \n    \n    col = mix(col, vec4(1.-vec3(h), 1.), h);\n    \n    return col;\n}\n\nvec4 put_text_drawstart(vec4 col, vec2 uv, vec2 pos, float scale)\n{\n\tfloat unit = asp * scale * 0.1;\n    float h = 0.;\n    vec2 sc = vec2(unit, unit*0.8);\n    \n    // M\n    h = max(h, word_map(uv, pos, 77, sc));\n    // a\n    h = max(h, word_map(uv, pos+vec2(unit*0.4, 0.), 97, sc));\n    // r\n    h = max(h, word_map(uv, pos+vec2(unit*0.8, 0.), 114, sc));\n    // c\n    h = max(h, word_map(uv, pos+vec2(unit*1.15, 0.), 99, sc));\n    // h\n    h = max(h, word_map(uv, pos+vec2(unit*1.5, 0.), 104, sc));\n    \n    col = mix(col, vec4(1.-vec3(h), 1.), h);\n    \n    return col;\n}\n\nvec4 put_text_target(vec4 col, vec2 uv, vec2 pos, float scale)\n{\n\tfloat unit = asp * scale * 0.1;\n    float h = 0.;\n    vec2 sc = vec2(unit, unit*0.8);\n    \n    // S\n    h = max(h, word_map(uv, pos, 83, sc));\n    // h\n    h = max(h, word_map(uv, pos+vec2(unit*0.4, 0.), 104, sc));\n    // o\n    h = max(h, word_map(uv, pos+vec2(unit*0.8, 0.), 111, sc));\n    // w\n    h = max(h, word_map(uv, pos+vec2(unit*1.2, 0.), 119, sc));\n    \n    // T\n    h = max(h, word_map(uv, pos+vec2(unit*2.0, 0.), 84, sc));\n    // a\n    h = max(h, word_map(uv, pos+vec2(unit*2.35, 0.), 97, sc));\n    // r\n    h = max(h, word_map(uv, pos+vec2(unit*2.8, 0.), 114, sc));\n    // g\n    h = max(h, word_map(uv, pos+vec2(unit*3.15, 0.), 103, sc));\n    // e\n    h = max(h, word_map(uv, pos+vec2(unit*3.5, 0.), 101, sc));\n    // t\n    h = max(h, word_map(uv, pos+vec2(unit*3.95, 0.), 116, sc));\n    \n    col = mix(col, vec4(1.-vec3(h), 1.), h);\n    \n    return col;\n}\n\nvec4 put_text_fixed(vec4 col, vec2 uv, vec2 pos, float scale, bool p)\n{\n\tfloat unit = asp * scale * 0.1;\n    float h = 0.;\n    vec2 sc = vec2(unit, unit*0.8);\n    \n    // F\n    h = max(h, word_map(uv, pos, 70, sc));\n    // i\n    h = max(h, word_map(uv, pos+vec2(unit*0.35, 0.), 105, sc));\n    // x\n    h = max(h, word_map(uv, pos+vec2(unit*0.7, 0.), 120, sc));\n    // e\n    h = max(h, word_map(uv, pos+vec2(unit*1.05, 0.), 101, sc));\n    // d\n    h = max(h, word_map(uv, pos+vec2(unit*1.4, 0.), 100, sc));\n    \n    if(p){\n        //o\n    \th = max(h, word_map(uv, pos+vec2(unit*2.1, 0.), 111, sc));\n        //r\n        h = max(h, word_map(uv, pos+vec2(unit*2.45, 0.), 114, sc));\n        //i\n        h = max(h, word_map(uv, pos+vec2(unit*2.8, 0.), 105, sc));\n        //g\n        h = max(h, word_map(uv, pos+vec2(unit*3.15, 0.), 103, sc));\n        //i\n        h = max(h, word_map(uv, pos+vec2(unit*3.5, 0.), 105, sc));\n        //n\n        h = max(h, word_map(uv, pos+vec2(unit*3.85, 0.), 110, sc));\n    }\n    else{\n        //t\n    \th = max(h, word_map(uv, pos+vec2(unit*2.1, 0.), 116, sc));\n        //a\n        h = max(h, word_map(uv, pos+vec2(unit*2.45, 0.), 97, sc));\n        //r\n        h = max(h, word_map(uv, pos+vec2(unit*2.8, 0.), 114, sc));\n        //g\n        h = max(h, word_map(uv, pos+vec2(unit*3.15, 0.), 103, sc));\n        //e\n        h = max(h, word_map(uv, pos+vec2(unit*3.5, 0.), 101, sc));\n        //t\n        h = max(h, word_map(uv, pos+vec2(unit*3.85, 0.), 116, sc));\n    }\n    \n    col = mix(col, vec4(1.-vec3(h), 1.), h);\n    \n    return col;\n}\n\nvec4 put_text_step_count(vec4 col, vec2 uv, vec2 pos, float scale, int count)\n{\n\tfloat unit = asp * scale * 0.1;\n    float h = 0.;\n    vec2 sc = vec2(unit, unit*0.8);\n    \n    int d = count % 10;\n    int t = count / 10;\n    \n    h = max(h, word_map(uv, pos+vec2(unit*0.35, 0.), 48+d, sc));\n    \n    if(t > 0)\n    {\n    \th = max(h, word_map(uv, pos, 48+t, sc));\n    }\n    \n    col = mix(col, vec4(1.-vec3(h), 1.), h);\n    \n    return col;\n}\n\nvec4 put_text_step(vec4 col, vec2 uv, vec2 pos, float scale)\n{\n\tfloat unit = asp * scale * 0.1;\n    float h = 0.;\n    vec2 sc = vec2(unit, unit*0.8);\n    \n    // S\n    h = max(h, word_map(uv, pos, 83, sc));\n    // t\n    h = max(h, word_map(uv, pos+vec2(unit*0.35, 0.), 116, sc));\n    // e\n    h = max(h, word_map(uv, pos+vec2(unit*0.7, 0.), 101, sc));\n    // p\n    h = max(h, word_map(uv, pos+vec2(unit*1.05, 0.), 112, sc));\n    \n    col = mix(col, vec4(1.-vec3(h), 1.), h);\n    \n    return col;\n}\n\nvec4 put_text_map(vec4 col, vec2 uv, vec2 pos, float scale)\n{\n\tfloat unit = asp * scale * 0.1;\n    float h = 0.;\n    vec2 sc = vec2(unit, unit*0.8);\n    \n    // M\n    h = max(h, word_map(uv, pos, 77, sc));\n    // a\n    h = max(h, word_map(uv, pos+vec2(unit*0.35, 0.), 97, sc));\n    // p\n    h = max(h, word_map(uv, pos+vec2(unit*0.7, 0.), 112, sc));\n    \n    col = mix(col, vec4(1.-vec3(h), 1.), h);\n    \n    return col;\n}\n\nvoid initBuffer()\n{\n\tbufA = texture(iChannel0, vec2(0.0, 0.0));\n    bufB = texture(iChannel0, vec2(1.0, 0.0));\n    bufC = texture(iChannel0, vec2(0.0, 1.0));\n    bufD = texture(iChannel0, vec2(1.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    asp = iResolution.x/iResolution.y;\n    vec2 uv = (-iResolution.xy + 2.*fragCoord.xy)/iResolution.y;\n    vec4 col = vec4(vec3(1.), 0.);\n    \n    initBuffer();\n    \n    col = gui_check_box(col, uv, vec2(-asp*0.9, 0.9), 0.8, is(GET_DRAW_MAP));    //draw map\n    col = put_text_drawmap(col, uv, vec2(-asp*0.84, 0.9), 0.7);\n    \n    col = gui_check_box(col, uv, vec2(-asp*0.9, 0.78), 0.8, is(GET_DRAW_START));  //draw start\n    col = put_text_drawstart(col, uv, vec2(-asp*0.84, 0.78), 0.7);\n    \n    col = gui_check_box(col, uv, vec2(-asp*0.9, 0.66), 0.8, is(GET_SHOW_TAR));   //show target point\n    col = put_text_target(col, uv, vec2(-asp*0.84, 0.66), 0.7);\n    \n    col = gui_check_box(col, uv, vec2(-asp*0.9, 0.54), 0.8, is(FIX_ORI));   //fix origin point\n    col = put_text_fixed(col, uv, vec2(-asp*0.84, 0.54), 0.7, true);\n    \n    col = gui_check_box(col, uv, vec2(-asp*0.9, 0.42), 0.8, is(FIX_TAR));   //fix target point\n    col = put_text_fixed(col, uv, vec2(-asp*0.84, 0.42), 0.7, false);\n    \n    col = gui_arrow_left(col, uv, vec2(-asp*0.9, 0.30), 0.8, GET_STEP_COUNT!=MAX_STEP_COUNT);  //step count\n    col = put_text_step_count(col, uv, vec2(-asp*0.84, 0.30), 0.7, int(GET_STEP_COUNT));\n    col = gui_arrow_right(col, uv, vec2(-asp*0.77, 0.30), 0.8, GET_STEP_COUNT!=MIN_STEP_COUNT);\n    col = put_text_step(col, uv, vec2(-asp*0.72, 0.3), 0.7);\n    \n    col = gui_arrow_left(col, uv, vec2(-asp*0.9, 0.18), 0.8, GET_MAP_NUM!=MAX_MAP_COUNT);  //map count\n    col = put_text_step_count(col, uv, vec2(-asp*0.84, 0.18), 0.7, int(GET_MAP_NUM)+1);\n    col = gui_arrow_right(col, uv, vec2(-asp*0.77, 0.18), 0.8, GET_MAP_NUM!=MIN_MAP_COUNT);\n    col = put_text_map(col, uv, vec2(-asp*0.72, 0.18), 0.7);\n    \n    fragColor = col;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// bufA\n// vec2(0 ~ 0.5, 0 ~ 0.5)\n// \t\tr : draw map  (check box)\n// \t\tg : draw start (check box)\n// \t\tb : show end pos (check box)\n//      a : fixed origin point (check box)\n\n// bufB\n// vec2(0.5 ~ 1, 0 ~ 0.5)\n//\t\tr : step count\n//\t\tg : fixed target point(check box)\n//\t\tb : key event\n//\t\ta : iMouse.z\n\n// bufC\n// vec2(0 ~ 0.5, 0.5 ~ 1)\n//      r : key drag flag\n//      g : map number\n//      b : \n//      a :\n\n// bufD\n// vec2(0.5 ~ 1, 0.5 ~ 1)\n//      r : origin.x\n//      g : origin.y\n//      b : target.x\n//      a : target.y\n\n#define KEY_DOWN 1\n#define KEY_UP 2\n#define KEY_HOLD 3\n#define KEY_DRAG 4\n\nvec4 bufA;\nvec4 bufB;\nvec4 bufC;\nvec4 bufD;\n\nfloat asp;\n\nint inbox(vec2 uv, vec2 pos, vec2 range)\n{\n\tif(uv.x > pos.x-range.x && uv.x < pos.x+range.x)\n        if(uv.y > pos.y-range.y && uv.y < pos.y+range.y)\n            return 1;\n    return 0;\n}\n\nvoid keydown_event()\n{\n\tvec2 uv = (-iResolution.xy + 2. * iMouse.xy) / iResolution.y;\n    float asp = iResolution.x/iResolution.y;\n    \n    //draw map check box\n    if(inbox(uv, vec2(-asp*0.9, 0.9), vec2(asp*0.0144)) > 0)\n    {\n    \tSET_DRAW_MAP(GET_DRAW_MAP > 0. ? 0.:1.);\n    }\n    \n    //draw start check box\n    else if(inbox(uv, vec2(-asp*0.9, 0.78), vec2(asp*0.0144)) > 0)\n    {\n    \tSET_DRAW_START(GET_DRAW_START > 0. ? 0.:1.);\n    }\n    \n    //show target point check box\n    else if(inbox(uv, vec2(-asp*0.9, 0.66), vec2(asp*0.0144)) > 0)\n    {\n    \tSET_SHOW_TAR(GET_SHOW_TAR > 0. ? 0.:1.);\n    }\n    \n    //fix origin point check box\n    else if(inbox(uv, vec2(-asp*0.9, 0.54), vec2(asp*0.0144)) > 0)\n    {\n    \tFIX_ORI = FIX_ORI > 0. ? 0.:1.;\n    }\n    \n    //fix target point check box\n    else if(inbox(uv, vec2(-asp*0.9, 0.42), vec2(asp*0.0144)) > 0)\n    {\n    \tFIX_TAR = FIX_TAR > 0. ? 0.:1.;\n    }\n    \n    //increase step count\n    else if(inbox(uv, vec2(-asp*0.9, 0.30), vec2(asp*0.0144)) > 0)\n    {\n    \tSET_STEP_COUNT(clamp(GET_STEP_COUNT+1., MIN_STEP_COUNT, MAX_STEP_COUNT));\n    }\n    \n    //decrease step count\n    else if(inbox(uv, vec2(-asp*0.77, 0.30), vec2(asp*0.0144)) > 0)\n    {\n    \tSET_STEP_COUNT(clamp(GET_STEP_COUNT-1., MIN_STEP_COUNT, MAX_STEP_COUNT));\n    }\n    \n    //increase map count\n    else if(inbox(uv, vec2(-asp*0.9, 0.18), vec2(asp*0.0144)) > 0)\n    {\n    \tSET_MAP_NUM(clamp(GET_MAP_NUM+1., MIN_MAP_COUNT, MAX_MAP_COUNT));\n    }\n    \n    //decrease map count\n    else if(inbox(uv, vec2(-asp*0.77, 0.18), vec2(asp*0.0144)) > 0)\n    {\n    \tSET_MAP_NUM(clamp(GET_MAP_NUM-1., MIN_MAP_COUNT, MAX_MAP_COUNT));\n    }\n    \n    //move point\n    else if(!(uv.x < -asp*0.5 && uv.y > 0.1))\n    {\n        if(!is(FIX_ORI) && !is(FIX_TAR)){\n            uv = clamp(uv, vec2(-asp*0.5, -asp), vec2(asp, asp));\n            SET_ORIGIN(uv);\n            SET_TARGET(uv);\n        }\n        KEY_DRAG_FLAG = 1.0;\n    }\n}\n\nvoid keyup_event()\n{\n    KEY_DRAG_FLAG = 0.0;\n}\n\nvoid keydrag_event()\n{\n    vec2 uv = (-iResolution.xy + 2. * iMouse.xy) / iResolution.y;\n    if(!is(FIX_ORI) && !is(FIX_TAR))  //drag target\n    {\n    \tSET_TARGET(uv);\n    }\n\tif(is(FIX_ORI) && !is(FIX_TAR))  //drag target\n    {\n        SET_TARGET(uv);\n    }\n    else if(!is(FIX_ORI) && is(FIX_TAR))  //drag origin\n    {\n    \tSET_ORIGIN(uv);\n    }\n}\n\n//key down = 1 , key up = 2 , other = 0\nint handle_click(vec4 bufB)\n{\n\tif(P_MOUSE_Z < 0.5 && iMouse.z > 0.5)\n        return KEY_DOWN;\n    \n    if(P_MOUSE_Z > 0.5 && iMouse.z < 0.5)\n        return KEY_UP;\n    \n    if(P_MOUSE_Z > 0.5, iMouse.z > 0.5)\n        return KEY_HOLD;\n    \n    return 0;\n}\n\n\nvoid initBuffer()\n{\n\tif(iTime < 0.05)\n    {\n        //buf A\n\t\tDRAW_MAP = 0.;\n\t\tDRAW_START = 0.;\n\t\tSHOW_TAR = 0.;\n\t\tFIX_ORI = 0.;\n\n\t\t//buf B\n\t\tSTEP_COUNT = 0.;\n\t\tFIX_TAR = 0.;\n\t\tKEY_EVENT = 0.;\n\t\tP_MOUSE_Z = 0.;\n\n\t\t//buf C\n\t\tKEY_DRAG_FLAG = 0.;\n        MAP_NUM = 0.;\n        bufC.ba = vec2(0.);\n\n\t\t//buf D\n\t\tORIGIN = vec2(0.);\n\t\tTARGET = vec2(0.);\n    }\n    else\n    {\n    \t// get previous state\n    \tbufA = texture(iChannel0, vec2(0.0, 0.0));\n    \tbufB = texture(iChannel0, vec2(1.0, 0.0));\n    \tbufC = texture(iChannel0, vec2(0.0, 1.0));\n    \tbufD = texture(iChannel0, vec2(1.0, 1.0));\n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    asp = iResolution.x/iResolution.y;\n    vec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    initBuffer();\n    \n    //get click event\n    int click = handle_click(bufB);\n    if(click == KEY_DOWN)\n    {\n    \tkeydown_event();\n    }\n    else if(click == KEY_UP)\n    {\n    \tkeyup_event();\n    }\n    else if(is(KEY_DRAG_FLAG))\n    {\n    \tkeydrag_event();\n    }\n    \n    KEY_EVENT = float(click);\n    P_MOUSE_Z = iMouse.z;\n    \n    if(uv.x < 0.0 && uv.y < 0.0)\n    \tfragColor = bufA;\n    else if(uv.x > 0.0 && uv.y < 0.0)\n        fragColor = bufB;\n    else if(uv.x < 0.0 && uv.y > 0.0)\n        fragColor = bufC;\n    else\n        fragColor = bufD;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// bufA\n// vec2(0 ~ 0.5, 0 ~ 0.5)\n// \t\tr : draw map  (check box)\n// \t\tg : draw start (check box)\n// \t\tb : show end pos (check box)\n//      a : fixed origin point (check box)\n\n// bufB\n// vec2(0.5 ~ 1, 0 ~ 0.5)\n//\t\tr : step count\n//\t\tg : fixed target point(check box)\n//\t\tb : key event\n//\t\ta : iMouse.z\n\n// bufC\n// vec2(0 ~ 0.5, 0.5 ~ 1)\n//      r : key drag flag\n//      g : map number\n//      b : \n//      a :\n\n// bufD\n// vec2(0.5 ~ 1, 0.5 ~ 1)\n//      r : origin.x\n//      g : origin.y\n//      b : target.x\n//      a : target.y\n\n\n// step limit\n#define MAX_STEP_COUNT 25.\n#define MIN_STEP_COUNT 0.\n\n\n//map limit\n#define MAX_MAP_COUNT 3.\n#define MIN_MAP_COUNT 0.\n\n// origin\n#define ORI vec2(asp*0.5, 0.2)\n// target\n#define TAR vec2(-asp*0.4, -0.5)\n\n\n\n//buf A\n#define DRAW_MAP bufA.r\n#define DRAW_START bufA.g\n#define SHOW_TAR bufA.b\n#define FIX_ORI bufA.a\n\n//buf B\n#define STEP_COUNT bufB.r\n#define FIX_TAR bufB.g\n#define KEY_EVENT bufB.b\n#define P_MOUSE_Z bufB.a\n\n//buf C\n#define KEY_DRAG_FLAG bufC.r\n#define MAP_NUM bufC.g\n\n//buf D\n#define ORIGIN bufD.rg\n#define TARGET bufD.ba\n\n//set offset\n#define DEFAULT_SHOW 1\n\n#if DEFAULT_SHOW\n\t#define STEP_COUNT_OFFSET 4.\n\t#define INVERSE(x) 1.-(x)\n\t#define ORIGIN_OFFSET ORI\n\t#define TARGET_OFFSET TAR\n\t#define MAP_OFFSET 0.\n#else\n\t#define STEP_COUNT_OFFSET 0.\n\t#define INVERSE(x) (x)\n\t#define ORIGIN_OFFSET vec2(0.)\n\t#define TARGET_OFFSET vec2(0.)\n\t#define MAP_OFFSET 0.\n#endif\n\n\n// get/set function (with offset)\n#define GET_STEP_COUNT STEP_COUNT+STEP_COUNT_OFFSET\n#define SET_STEP_COUNT(x) STEP_COUNT=(x)-STEP_COUNT_OFFSET\n#define GET_DRAW_MAP INVERSE(DRAW_MAP)\n#define SET_DRAW_MAP(x) DRAW_MAP=INVERSE(x)\n#define GET_DRAW_START INVERSE(DRAW_START)\n#define SET_DRAW_START(x) DRAW_START=INVERSE(x)\n#define GET_SHOW_TAR INVERSE(SHOW_TAR)\n#define SET_SHOW_TAR(x) SHOW_TAR=INVERSE(x)\n#define GET_ORIGIN ORIGIN+ORIGIN_OFFSET\n#define SET_ORIGIN(x) ORIGIN=(x)-ORIGIN_OFFSET\n#define GET_TARGET TARGET+TARGET_OFFSET\n#define SET_TARGET(x) TARGET=(x)-TARGET_OFFSET\n#define GET_MAP_NUM MAP_NUM+MAP_OFFSET\n#define SET_MAP_NUM(x) MAP_NUM=(x)-MAP_OFFSET\n\nvec4 blend(vec4 a, vec4 b)\n{\n\tif(a.a == 0.)\n    {\n    \treturn b;\n    }\n    else\n    {\n    \treturn mix(a, b, b.a);\n    }\n}\n\nvec2 cx_pow2(vec2 a)\n{\n\treturn vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y);\n}\n\nbool is(float n)\n{\n\treturn n > 0.5;\n}\n\nfloat box(vec2 p, vec2 c, vec2 sz)\n{\n\tvec2 d = abs(p-c) - sz;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tvec2 e0 = b - a;\n\tvec2 e1 = c - b;\n\tvec2 e2 = a - c;\n\n\tvec2 v0 = p - a;\n\tvec2 v1 = p - b;\n\tvec2 v2 = p - c;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat circle(vec2 p, vec2 c, float r)\n{\n\treturn length(p-c) - r;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\nvec2 get_text_position(int ascii)\n{\n\tint x = (ascii % 16);\n    int y = 15-(ascii / 16);\n    \n    return vec2(float(x), float(y))*0.0625;\n}\n\nfloat get_text(vec2 uv, vec2 pos, int ascii, vec2 unit, sampler2D buf)\n{\n    vec2 p = clamp(uv-pos, -unit/2., unit/2.);\n    p += unit/2.;\n    p /= unit*16.;\n    \n    return smoothstep(0.55, 0.46, textureLod(buf, get_text_position(ascii)+p, 1.).a);\n}\n\n","name":"Common","description":"","type":"common"}]}