{"ver":"0.1","info":{"id":"lcV3Dc","date":"1713402305","viewed":45,"name":"Liminal Drops V1","username":"FatLenny","description":"@kishimisu youtube tutorial for raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tutorial","canvas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Liminal Drops\" by FatLenny. https://shadertoy.com/view/Xcc3zN\n// 2024-04-17 19:21:00\n\n// Fork of \"Basic Raymarching Shader\" by None. https://shadertoy.com/view/-1\n// 2024-03-26 05:42:39\n\n    //DEFINING OBJECTS IN OUR SCENE\n\n    // this function takes a 3D point as input and returns the distance to the nearest object in the scene\n\n\nfloat sdSphere(vec3 p, float s) {\n   \n    \n    // for now, returns distance to a sphere of radius 1.0 located at the origin\n    return length(p) - s;  \n    \n}\n\nfloat sdCube( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot2d(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rot3d(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis, p) * axis, p, cos(angle))\n               + cross(axis, p) *sin(angle);\n}\n\n//SMOOTH COMBINING OF SHAPES WHERE K IS SMOOTHIG FACTOR\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat ssub( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sint( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec3 palette(in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.2, 0.4, 0.55);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat map(vec3 p) {\n    vec2 mp = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;// Normalize mouse position to fit canvas\n    //vec3 spherePos = vec3(mp.x,mp.y, 1.0);// Initialize position at zero\n    //vec3 spherePos = vec3(0, 0, 0);// Initialize position at zero\n    vec3 fs = p;\n    fs.x += 3.5;\n    fs.z -= 2.2;\n    fs.y += iTime;\n    fs.y = mod(fs.y, 13.0) - 6.5;\n    \n    //float angle = iTime;\n    //float ssc = 0.5; // Sphere scaling factor\n    //float csc = 2.0; // Cube scaling factor\n    \n    float sphere = sdSphere(fs, 1.5);// Return a new sphere whose old location has been \n \n    vec3 es = p;\n    es.x += 3.5;\n    es.z -= 2.2;\n    es.y += iTime;\n    es.y = mod(es.y, 13.0) - 6.5;\n \n    float sphere2 = sdSphere(es, 2.0);// clone sphere for effects\n    \n    // MOUSE SPHERE\n    vec3 mfs = p;\n    mfs.x -= 2.0;\n    mfs.x -= 6.25-1.0;\n    mfs.z -= 5.2;\n    mfs.z -= 10.25-1.0;\n    mfs.y -= iTime*5.0;\n    mfs.y = mod(mfs.y, 3.0) - 1.5;\n    \n    //float angle = iTime;\n    //float ssc = 0.5; // Sphere scaling factor\n    //float csc = 2.0; // Cube scaling factor\n    \n    float msphere = sdSphere(mfs, 0.3);// Return a new sphere whose old location has been \n     \n    //MOUSE SPHERE EFFECTS \n    vec3 mes = p;\n    mes.x -= 2.0;\n    mes.x -= 6.25-1.0;\n    mes.z -= 5.2;\n    mes.z -= 10.25-1.0;\n    mes.y -= iTime*5.0-1.2;\n    mes.y = mod(mes.y, 3.0) - 1.5;\n \n    float msphere2 = sdSphere(mes, 1.5);// clone sphere for effects\n     \n    \n    vec3 cs = p;\n    cs.y -= 3.5;\n    cs.xz = fract(cs.xz) - 0.5;\n       \n    vec3 cs2 = p;\n    cs2.y -= 2.5;\n    cs2.xz = fract(cs2.xz) - 0.5;\n    \n    \n    \n    float cubesky = sdCube(cs, vec3(1.0));\n    \n    vec3 cg = p;\n    cg.y += 3.5;\n    cg.xz = fract(cs.xz) - 0.5;\n    \n    float cubeground = sdCube(cg, vec3(1.0));\n    //vec3 ct = p;// Vector used to transform the cube\n\n    //vec3 fc = ct;// Vector used to fractalize the cube\n    //vec3 fp = p;// Vector used to fractalize the scene\n    \n    \n    //ct.y += 0.5;\n    \n    \n    //ct.z -= iTime * 0.8;\n    \n    //ct.xz = fract(ct.xz) - 0.5;\n    \n    //ct.yz *= rot2d(angle);// Rotate around x axis\n    //ct.xz *= rot2d(angle);// Rotate around y axis\n    //ct.xy *= rot2d(angle);// Rotate around z axis\n   \n   \n    // Order of operations for transformations is important because you will get a \n    // different outcome depending on the order they are applied in\n   \n    \n    \n   \n    //float cube = sdCube(ct, vec3(0.1));\n    \n    \n    float ground = p.y + 4.5;// The ground is wherever is directly under the ray, ot its y position plus an offset\n    float mground = p.y + 4.5;\n    \n    float skyhole;\n    float groundhole;\n    \n    skyhole = ssub(msphere2, cubesky, 0.5);\n    groundhole = ssub(sphere2, ground, 2.0);    \n     \n    float skydrip;\n    float grounddrip;\n    \n    float shapes;\n\n    \n    skydrip = smin(sphere, skyhole, 2.0);\n    grounddrip = smin(msphere, groundhole, 2.0);\n    \n    shapes = min(skydrip, grounddrip);\n  \n    return shapes;// Combining all of our shapes and the ground with smoothing \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float fov = 1.0;\n    \n    // INITIALIZATION FOR RAYMARCHING\n\n    // fragCoord holds coords of every pixel\n    vec2 uv =(fragCoord *2.0 - iResolution.xy) / iResolution.y; \n    \n    // Normalize mouse position to fit canvas\n    vec2 mp = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mp2 = (iMouse.zw * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // corresponds to the camera's curent position in our world\n    vec3 ro = vec3(0, 0, -3);// Ray origin \n  \n    // we can use UV as x and y coords because we decided to alignd the world x and y axis with our UV coords\n    // this allows each pizel to have a unique direction spreading out from the center of our screen\n    // this effectively creates a virtual canvas to project the world to\n    // Step 1: \n    // vec3 rayDirection = vec3(uv, 1);\n    \n    // now we normalize the vectors to ensure they all have a length of 1.0 which is crucial for distance calcs    \n    // step 2:\n    vec3 rd = normalize(vec3(uv * fov, 1)); // Ray direction\n\n    // this represents the final pixel color once we have completed the raymarch\n    vec3 col = vec3(0.0);   \n    \n    //create a float to keep track of the current distance the point has traveled from rayOrigin \n    float dt = 0.0;// Distance traveled\n    \n    // CAMERA ROTATION\n    \n    // Vertical rotation\n    ro.yz *= rot2d(+0.4);\n    rd.yz *= rot2d(+0.4);\n    ro.yz *= rot2d(-0.1);\n    rd.yz *= rot2d(-0.1);\n    \n    // Horizontal rotation\n    //ro.xz *= rot2d(-mp.x*2.0);\n    //rd.xz *= rot2d(-mp.x*2.0);\n    //ro.xz *= rot2d(-mp2.y*4.0-45.0);\n    //rd.xz *= rot2d(-mp2.y*4.0-45.0);\n    \n    // END OF INITIALIZATION\n\n    // BEGIN RAYMARCHING\n    \n    // i represents the current raymarching step with a max of 80 iterations\n    // the max iterations affects the QUALITY of the result and the PERFORMANCE\n    // too few steps may not allow the ray to reach an object, while too many will impast shader performance\n    // this parameter needs to be adjusted to fit your specific scene\n    int i;\n    for(i = 0; i < 80; i++)\n    {\n    \n        // create a vec3 that indicates the position along the ray based on its distance from the origin\n        // we use this point to compute the distance to the closest object in the scene\n        // the point starts at the ray's origin because distTraveled is initialized to 0.0\n        // we do this using signed distance functions (SDF)\n        // info on SDF related to raymarching: https://iquilezles.org/articles/distfunctions/\n        vec3 p = ro + rd * dt;// Position along ray\n\n        // use mapDistance function to get the distance to the scene given our current position along the ray\n        // this value represents the distance the point can travel in any direction until encountering an object\n        float ds = map(p); // Distance to scene\n\n        // here we are \"marching\" the ray forward based on the distance we got from getDistance()\n        // in other words we are calculating the distance to the closest object in the scene\n        // we then use this distance to \"safely\" march the ray forward, knowing we will not hit an object at that distance\n        // now we repeat the for loop until we either hit an object or exceed the max marching steps we set \n        dt += ds;\n        \n        // This stuups the raymarching when the distance to the object is so small that we nonnot need to do 80 iterations\n        // withouy this the max number of iterations would be performed every time and could greatly reduce performance \n        // if the threshold is set too high, you will lose deatil\n        // if too low the performance gains will be negligible\n        //finalColor = vec3(i) / 80.0;\n        if (ds < 0.001) break;\n        \n        // stops loop early if the ray has travaeled too far by putting a cap on the distance it is allowed to travel\n        if (dt > 100.0) break;\n        \n        // we can combine the previous 2 checks into one line: if(distanceToScene < 0.001 || distTraveled > 100.0) break;\n        \n    }\n    \n    //COLORING\n    \n    // this outputs a greyscale image based on distance from the origin\n    // by default this will display any value greater than 1 as pureb white, so we need to fix that\n    // we can either move the camera closer to the objects or divide distTraveled by an arbitrary number until we can see things\n    // here I am using the divide by an arbitrary number method\n    col = palette(dt * 0.006 + float(i)*0.005);\n     \n    // fragColor holds RGB and alpha values of a pixel\n    // we use finalColor as the output of our shader instead of displaying the UV coords like it normally would\n    fragColor = vec4(col, 1);\n \n    // HOW WAS THE SPHERE GENERATED?\n\n}","name":"Image","description":"","type":"image"}]}