{"ver":"0.1","info":{"id":"ctBBD1","date":"1694017469","viewed":159,"name":"Simplex noise normalized N-dim","username":"Suslik","description":"My implementation of gradient-based as well as value-based simplex noise in the general n-dimensional case. Upper row is value noise, lower row is gradient noise. From left to right: 2d/3d/4d noises.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","simplex","ndim"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//For some reason all implementations of simplex noise that I saw on shadertoy are restricted to a specific dimensionality,\n//when simplex noise actually shines in higher dimensions.\n\n//This implementation uses macros to produce code that works in 2d/3d\n//and 4d cases. Unfortunately there's still some functions (like ComponentOrder) that I have not yet found a way to implement\n//efficiently in higher dimensions, so they have hardcoded implementations only for 2d/3d and 4d cases.\n\n//Contrary to many other implementations, mine works correctly in nasty cases when the sampled point sits on a shared boundary of\n//two tetrahedra.\n\nvec3 CheckRange(float v)\n{\n    if(v < 0.05f || v > 0.95f)\n        return vec3(0.0f, 1.0f, 0.0f);\n    if(v < -0.0f || v > 1.0f)\n        return vec3(1.0f, 0.0f, 0.0f);\n    return vec3(v);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    vec4 pos4 = vec4(uv * 15.0f + vec2(17.9f), iMouse.z > 0.5f ? (500.0f + iMouse.x / 50.0f) : iTime * 1.0f, iMouse.z > 0.5f ? (500.0f + iMouse.y / 50.0f) : sin(3.0f * iTime));\n\n    \n    vec3 col = vec3(0.0f);\n    \n    ivec2 cellIndex = ivec2(floor(fragCoord/iResolution.xy * vec2(3.0f, 3.0f)));\n    \n    if(cellIndex.x == 0)\n    {\n      if(cellIndex.y == 0)\n      {\n          col = CheckRange(GetGradSimplexNoise(pos4.xy));\n      }else\n      if(cellIndex.y == 1)\n      {\n          col = CheckRange(GetGradSimplexNoiseOriginal(pos4.xy, 0.6f));\n         \n      }else\n      {\n          col = GetValueSimplexNoise(pos4.xy);\n      }\n    }\n    if(cellIndex.x == 1)\n    {\n      if(cellIndex.y == 0)\n      {\n          col = CheckRange(GetGradSimplexNoise(pos4.xyz));\n      }else\n      if(cellIndex.y == 1)\n      {\n          col = CheckRange(GetGradSimplexNoiseOriginal(pos4.xyz, 0.6f));\n         \n      }else\n      {\n          col = GetValueSimplexNoise(pos4.xyz);\n      }\n    }\n    if(cellIndex.x == 2)\n    {\n      if(cellIndex.y == 0)\n      {\n          col = CheckRange(GetGradSimplexNoise(pos4.xyzw));\n      }else\n      if(cellIndex.y == 1)\n      {\n          col = CheckRange(GetGradSimplexNoiseOriginal(pos4.xyzw, 0.6f));\n         \n      }else\n      {\n          col = GetValueSimplexNoise(pos4.xyzw);\n      }\n    }    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.141592f\n//http://www.jcgt.org/published/0009/03/02/paper.pdf\nuvec3 hash33UintPcg(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy; //swizzled notation is not exactly the same because components depend on each other, but works too\n\n    v ^= v >> 16u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy;\n    return v;\n}\n\nvec3 hash3i3f(ivec3 seed)\n{\n    uvec3 hash_uvec3 = hash33UintPcg(uvec3(seed));\n    return vec3(hash_uvec3) * (1.0f / float(~0u));\n}\n\n//these hashes create a random unit vector in floatN from an intN seed\nvec2 hashis(ivec2 seed)\n{\n    float ang = hash3i3f(seed.xyy).x * 2.0f * pi;\n    return vec2(cos(ang), sin(ang));\n}\n\nvec3 hashis(ivec3 seed)\n{\n    vec3 h = hash3i3f(seed.xyz);\n    float ang = h.x * 2.0f * pi;\n    float z = h.z * 2.0f - 1.0f;\n    float m = sqrt(clamp(1.0f - z * z, 0.0f, 1.0f));\n    return vec3(cos(ang) * m, sin(ang) * m, z);\n    return normalize(hash3i3f(seed) - vec3(0.5));\n}\n\nvec4 hashis(ivec4 seed)\n{\n    uvec3 seed3 = hash33UintPcg(uvec3(hash33UintPcg(uvec3(seed.xyz)).xy, seed.w));\n    vec2 xy = hash3i3f(ivec3(seed3)).xy;\n    vec2 zw = hash3i3f(ivec3(seed3) + ivec3(1)).xy;\n    return normalize(vec4(xy, zw) - vec4(0.5));\n}\n\nvec3 hashif3(ivec2 seed)\n{\n    return hash3i3f(seed.xyy);\n}\n\nvec3 hashif3(ivec3 seed)\n{\n    return hash3i3f(seed);\n}\n\nvec3 hashif3(ivec4 seed)\n{\n    uvec3 seed3 = hash33UintPcg(uvec3(hash33UintPcg(uvec3(seed.xyz)).xy, seed.w));\n    return hash3i3f(ivec3(seed3));\n}\n\n//For a given component number i, ComponentOrder3(pos)[i] returns how many p[j] are greater than p[i]\n//For example, for vector (0.4, 0.5, 0.3), g = (1, 0, 2)\nvec2 ComponentOrder(vec2 pos)\n{\n    float c = step(pos.y, pos.x);\n    return vec2(1.0 - c, c);\n}\nvec3 ComponentOrder(vec3 pos)\n{\n    vec3 res = vec3(0.0, ComponentOrder(pos.yz));\n    vec2 c = step(pos.yz, pos.xx);    \n    res += vec3(2.0 - dot(c, vec2(1.0)), c);\n    return res;\n}\nvec4 ComponentOrder(vec4 pos)\n{\n    vec4 res = vec4(0.0, ComponentOrder(pos.yzw));\n    vec3 c = step(pos.yzw, pos.xxx);    \n    res += vec4(3.0 - dot(c, vec3(1.0)), c);\n    return res;\n}\n\n//This is mostly based on the wiki article\n//https://en.wikipedia.org/wiki/Simplex_noise\nfloat SimplexF(int n)\n{\n    return (sqrt(float(n) + 1.0) - 1.0) / float(n);\n}\n\nfloat SimplexG(int n)\n{\n    return (1.0 - 1.0 / sqrt(float(n) + 1.0)) / float(n);\n}\n\n//Distance between two hypertetrahedron vertices of the skewed lattice. Exact for N=2, inexact for N>2\nfloat SimplexGridStep(int n)\n{\n    //return length(vecN(1.0, 0.0, 0.0...) - vecN(SimplexG(n)))\n    float G = SimplexG(n);\n    return sqrt((1.0 - G) * (1.0 - G) + G * G * float(n - 1));\n}\n\n//Escribed radius for a hypertetrahedron with a unit edge. Exact.\n//Derived by analyzing analytical solutions for N=1,2,3 and 4, seems like a pretty clear progression. Have not tested for N>4\nfloat GetEscribedSimplexRadius(int n)\n{\n    return sqrt(float(n) / (2.0f * (float(n) + 1.0f)));\n}\n\n//This is found empirically and seems to produce noise in the 0..1 range for the original simplex noise weights\nfloat SimplexGradNormalFactor(int n)\n{\n    return 3.0f * sqrt(float(n));\n}\n\n//poor man's templates\n#define SIMPLEX_GRID_DEFINITIONS(N)\\\n    struct SimplexVerticesN                                                \\\n    {                                                                      \\\n        ivecN pos[N];                                                      \\\n    };                                                                     \\\n    /*for a given n generates                */                            \\\n    /*res =    (0,  0,  ..  0,  1,  1, .., 1)*/                            \\\n    /*          0   1   .. n-1  n  n+1 .., N */                            \\\n    vecN ShiftedOnesN(float n)                                             \\\n    {                                                                      \\\n      return step(vecN(n), step_vecN);                                     \\\n    }                                                                      \\\n    SimplexVerticesN SchlafliOrthosceme(vecN pos)                          \\\n    {                                                                      \\\n        /*From https://en.wikipedia.org/wiki/Simplex_noise*/               \\\n        /*For example, the point (0.4, 0.5, 0.3) would lie inside the simplex with vertices (0, 0, 0), (0, 1, 0), (1, 1, 0), (1, 1, 1).*/\\\n        /*The yi' coordinate is the largest, so it is added first. It is then followed by the xi' coordinate, and finally zi'.*/\\\n                                                                           \\\n        /*These can be arranged into a matrix of rows:*/                   \\\n        /*(0, 1, 0)*/                                                      \\\n        /*(1, 1, 0)*/                                                      \\\n        /*(1, 1, 1).*/                                                     \\\n                                                                           \\\n        /*Each column has a bunch of zeroes at first and then remaining ones. The number of zeroes is equal to its position in sorted order g[i]*/\\\n                                                                           \\\n        vecN g = ComponentOrder(pos);                                      \\\n                                                                           \\\n        matN p_T;                                                          \\\n        for(int i = 0; i < N; i++)                                         \\\n            p_T[i] = ShiftedOnesN(g[i]);                                   \\\n                                                                           \\\n        matN p = transpose(p_T);                                           \\\n        SimplexVerticesN vertices;                                         \\\n                                                                           \\\n        for(int i = 0; i < N; i++)                                         \\\n            vertices.pos[i] = ivecN(p[i]);                                 \\\n        return vertices;                                                   \\\n    }                                                                      \\\n    float VertexWeight(vecN delta, float r2)                               \\\n    {                                                                      \\\n        float s = max(r2 - dot(delta, delta), 0.0f);                       \\\n        return s * s * s * s / (r2 * r2 * r2 * r2);                        \\\n    }                                                                      \\\n    vecN SkewLattice(vecN pos)                                             \\\n    {                                                                      \\\n        return pos + dot(vecN(1.0f), pos) * SimplexF(N);                   \\\n    }                                                                      \\\n    vecN UnskewLattice(vecN skewed_pos)                                    \\\n    {                                                                      \\\n        return skewed_pos - dot(vecN(1.0f), skewed_pos) * SimplexG(N);     \\\n    }                                                                      \\\n    struct SimplexNodesN                                                   \\\n    {                                                                      \\\n        ivecN indices[N+1];                                                \\\n        vecN pos[N+1];                                                     \\\n        float weights[N+1];                                                \\\n    };                                                                     \\\n    /*rel_verts and rel_pos are relative to verts[0]*/                     \\\n    vecN GetBarycentricWeights(matN rel_verts, vecN rel_pos)               \\\n    {                                                                      \\\n        return inverse(rel_verts) * rel_pos;                               \\\n    }                                                                      \\\n    float GetRadialWeight(vecN delta)                                      \\\n    {                                                                      \\\n        /*return max(0.0f, 1.0f - length(delta) / (1.5f * GetEscribedSimplexRadius(N) * SimplexGridStep(N)));*/\\\n        return smoothstep(0.0f, 1.0f, max(0.0f, 1.0f - length(delta) / SimplexGridStep(N)));     \\\n    }                                                                      \\\n    SimplexNodesN GetSimplexNodes(vecN pos)                                \\\n    {                                                                      \\\n        SimplexNodesN nodes;                                               \\\n                                                                           \\\n        vecN skewed_pos = SkewLattice(pos);                                \\\n        ivecN base = ivecN(floor(skewed_pos));                             \\\n                                                                           \\\n        SimplexVerticesN ortho = SchlafliOrthosceme(skewed_pos - vecN(base));\\\n        for(int i = 0; i < N+1; i++)                                       \\\n        {                                                                  \\\n            nodes.indices[i] = base + ((i==0) ? ivecN(0) : ortho.pos[i - 1]);\\\n            nodes.pos[i] = UnskewLattice(vecN(nodes.indices[i]));          \\\n        }                                                                  \\\n        matN barycentric_verts;                                            \\\n        for(int i = 0; i < N; i++)                                         \\\n            barycentric_verts[i] = nodes.pos[i + 1] - nodes.pos[0];        \\\n        vecN weightsn = GetBarycentricWeights(barycentric_verts, pos - nodes.pos[0]);\\\n        for(int i = 0; i < N; i++)                                         \\\n            nodes.weights[i + 1] = weightsn[i];                            \\\n        nodes.weights[0] = 1.0f - dot(vecN(1), weightsn);                  \\\n        float total = 1e-5f;                                               \\\n        for(int i = 0; i < N+1; i++)                                       \\\n        {                                                                  \\\n            nodes.weights[i] = nodes.weights[i] * GetRadialWeight(pos - nodes.pos[i]);       \\\n            total += nodes.weights[i];                                     \\\n        }                                                                  \\\n        for(int i = 0; i < N+1; i++)                                       \\\n        {                                                                  \\\n            nodes.weights[i] /= total;                                     \\\n        }                                                                  \\\n                                                                           \\\n        return nodes;                                                      \\\n    }                                                                      \\\n    SimplexNodesN GetSimplexNodesOriginal(vecN pos, float r2)              \\\n    {                                                                      \\\n        SimplexNodesN nodes;                                               \\\n                                                                           \\\n        vecN skewed_pos = SkewLattice(pos);                                \\\n        ivecN base = ivecN(floor(skewed_pos));                             \\\n                                                                           \\\n        SimplexVerticesN ortho = SchlafliOrthosceme(skewed_pos - vecN(base));\\\n        for(int i = 0; i < N+1; i++)                                       \\\n        {                                                                  \\\n            nodes.indices[i] = base + ((i==0) ? ivecN(0) : ortho.pos[i - 1]);\\\n            nodes.pos[i] = UnskewLattice(vecN(nodes.indices[i]));          \\\n            nodes.weights[i] = VertexWeight(nodes.pos[i] - pos, r2);       \\\n        }                                                                  \\\n        return nodes;                                                      \\\n    }                                                                      \\\n    float GetGradSimplexNoiseOriginal(vecN pos, float r2)                  \\\n    {                                                                      \\\n        SimplexNodesN nodes = GetSimplexNodesOriginal(pos, r2);            \\\n        float res = 0.0f;                                                  \\\n        for(int i = 0; i < N+1; i++)                                       \\\n        {                                                                  \\\n            vecN delta = pos - nodes.pos[i];                               \\\n            vecN node_grad = hashis(nodes.indices[i]);                     \\\n            /*no explanation for why normal_factor is this value*/         \\\n            /*determined emplirically, seems to work*/                     \\\n            res += dot(delta, node_grad) * nodes.weights[i] * SimplexGradNormalFactor(N);\\\n        }                                                                  \\\n        return res * 0.5f + 0.5f;                                          \\\n    }                                                                      \\\n    float GetGradSimplexNoise(vecN pos)                                    \\\n    {                                                                      \\\n        SimplexNodesN nodes = GetSimplexNodes(pos);                        \\\n        float res = 0.0f;                                                  \\\n        for(int i = 0; i < N+1; i++)                                       \\\n        {                                                                  \\\n            vecN delta = pos - nodes.pos[i];                               \\\n            vecN node_grad = hashis(nodes.indices[i]);                     \\\n            float maxVal = GetEscribedSimplexRadius(N) * SimplexGridStep(N);\\\n            res += dot(delta, node_grad) * nodes.weights[i] / maxVal;      \\\n        }                                                                  \\\n        return res * 0.5f + 0.5f;                                          \\\n    }                                                                      \\\n    vec3 GetValueSimplexNoise(vecN pos)                                    \\\n    {                                                                      \\\n        SimplexNodesN nodes = GetSimplexNodes(pos);                        \\\n        vec3 res = vec3(0.0f);                                             \\\n        for(int i = 0; i < N+1; i++)                                       \\\n        {                                                                  \\\n            vec3 node_val = hashif3(nodes.indices[i]);                     \\\n            res += node_val * nodes.weights[i];                            \\\n        }                                                                  \\\n        return res;                                                        \\\n    }    \n    \n\n\n\n\n#define vecN vec2\n#define matN mat2\n#define ivecN ivec2\n#define SimplexVerticesN SimplexVertices2\n#define step_vecN vec2(0.5, 1.5)\n#define ShiftedOnesN ShiftedOnes2\n#define SimplexNodesN SimplexNodes2\nSIMPLEX_GRID_DEFINITIONS(2)\n#undef vecN\n#undef matN\n#undef ivecN\n#undef SimplexVerticesN\n#undef step_vecN\n#undef ShiftedOnesN\n#undef SimplexNodesN\n\n#define vecN vec3\n#define matN mat3\n#define ivecN ivec3\n#define SimplexVerticesN SimplexVertices3\n#define step_vecN vec3(0.5, 1.5, 2.5)\n#define ShiftedOnesN ShiftedOnes3\n#define SimplexNodesN SimplexNodes3\nSIMPLEX_GRID_DEFINITIONS(3)\n#undef vecN\n#undef matN\n#undef ivecN\n#undef SimplexVerticesN\n#undef step_vecN\n#undef ShiftedOnesN\n#undef SimplexNodesN\n\n\n#define vecN vec4\n#define matN mat4\n#define ivecN ivec4\n#define SimplexVerticesN SimplexVertices4\n#define step_vecN vec4(0.5, 1.5, 2.5, 3.5)\n#define ShiftedOnesN ShiftedOnes4\n#define SimplexNodesN SimplexNodes4\nSIMPLEX_GRID_DEFINITIONS(4)\n#undef vecN\n#undef matN\n#undef ivecN\n#undef SimplexVerticesN\n#undef step_vecN\n#undef ShiftedOnesN\n#undef SimplexNodesN\n  \n","name":"Common","description":"","type":"common"}]}