{"ver":"0.1","info":{"id":"XXffWM","date":"1728453054","viewed":35,"name":"prefilter versus supersample","username":"sh1boot","description":"Comparison of pre-smoothed signal (top two lines) being downsampled, against smoothed-with-supersampling (top and third lines) downsampling.  Keys 1 and 2 toggle cubic interpolation.  Hold shift to replace linear with lanczos intepolation.","likes":6,"published":3,"flags":48,"usePreview":0,"tags":["antialiasing","prefiltering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float plot(float y) {\n    float d = 1.4 * (abs(dFdx(y)) + abs(dFdy(y)));\n    d = min(d, 0.1);\n    float pw = 3.0 / iResolution.x * 2.0;\n    float width = 1.0 * length(vec2(dFdx(y), pw));\n    return smoothstep(-d, d, width - abs(y));\n}\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    fragCoord -= 0.5;\n    int x = int(floor(fragCoord.x));\n    float y = fragCoord.y * float(rows) / iResolution.y;\n    int row = int(floor(y));\n    y -= float(row);\n    vec4 v = texelFetch(iChannel2, ivec2(x, row), 0);\n\n    fragColour  = vec4(0,0.5,1,1) * plot(v[3] - y);\n    fragColour += vec4(0.8,0.0,0,1)\n                * v[2] * nearby(y, 0.5, 0.05);\n\n    fragColour += vec4(1,1,1,1) * plot(v[1] - y);\n    fragColour += vec4(0.5,0.5,0,1)\n                * v[0] * nearby(v[1], y, 0.10);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float xscale = 32.0;\nconst int rows = 4;\n\nconst int gap = 16;\nconst int wing = 5;\nconst int fwidth = 2 * wing + 1;\nconst int column = 64;\n\n\nfloat sinc(float x) {\n    x *= 3.1415926535;\n    if (abs(x) < 0.000001) return 1.0;\n    return sin(x) / x;\n}\n\nfloat nearby(float x, float y, float d) {\n    return smoothstep(-d, -0.5 * d, -abs(x - y));\n}\n\n\nfloat cubic(float t) {\n    const float a = -0.75;\n    t = abs(t);\n    float t3 = t * t * t;\n    float t2 = t * t;\n    if (t <= 1.) return (a + 2.) * t3 - (a + 3.) * t2 + 1.;\n    if (t < 2.) return a * t3 - 5. * a * t2 + 8. * a * t - 4. * a;\n    return 0.;\n}\n\n\nfloat lanczos(float x, float fc) {\n#if 1\n    return sinc(x * fc) * sinc(x / float(wing + 1));\n#else\n    return sinc(x * fc) * 0.5 * (1.0 + cos(x * 3.1415926535 / float(wing + 1)));\n#endif\n}\n\nfloat lanczos(int i, float fc) {\n    return lanczos(float(i), fc);\n}\n\nvec4 lookup(float x, int row, sampler2D t, vec2 r) {\n    vec2 uv = vec2(x, row);\n    uv += 0.5;\n    return texture(t, uv / r);\n}\n\nvec4 ss_lookup(float x, int row, sampler2D t, vec2 r) {\n    vec4 sum = vec4(0);\n    for (int i = -2; i <= 2; ++i) {\n        const float w[5] = float[5]( 0.5, 1.75, 3.5, 1.75, 0.5 );\n        float fi = float(i) * xscale;\n        sum += w[i + 2] * lookup(x + fi, row, t, r);\n    }\n    return sum / 8.0;\n}\n\nvec4 linear(float x, int row, vec2 grid, sampler2D t, vec2 res) {\n    vec4 basis = lookup(x, row, t, res).zwxy;\n    x -= grid.x;\n    x /= grid.y;\n    float qx = floor(x);\n    float phase = x - qx;\n    qx *= grid.y;\n    qx += grid.x;\n\n    float r = lookup(qx, row, t, res)[1];\n    r += (lookup(qx + grid.y, row, t, res)[1] - r) * phase;\n    float d = 2.8 * abs(dFdx(x));\n    basis[0] = smoothstep(-d, 0.0, -abs(fract(phase + 0.5) - 0.5));\n    basis[1] = r;\n    return basis;\n}\n\nvec4 ss_linear(float x, int row, vec2 grid, sampler2D t, vec2 res) {\n    vec4 basis = ss_lookup(x, row, t, res).zwxy;\n    x -= grid.x;\n    x /= grid.y;\n    float qx = floor(x);\n    float phase = x - qx;\n    qx *= grid.y;\n    qx += grid.x;\n\n    float r = ss_lookup(qx, row, t, res)[1];\n    r += (ss_lookup(qx + grid.y, row, t, res)[1] - r) * phase;\n    float d = 2.8 * abs(dFdx(x));\n    basis[0] = smoothstep(-d, 0.0, -abs(fract(phase + 0.5) - 0.5));\n    basis[1] = r;\n    return basis;\n}\n\nvec4 cubic(float x, int row, vec2 grid, sampler2D t, vec2 res) {\n    vec4 basis = lookup(x, row, t, res).zwxy;\n    x -= grid.x;\n    x /= grid.y;\n    float qx = floor(x);\n    float phase = x - qx;\n    qx *= grid.y;\n    qx += grid.x;\n\n    float r = 0.0;\n    for (int i = -1; i <= 2; ++i) {\n        float fi = float(i);\n        float w = cubic(fi - phase);\n        fi *= grid.y;\n        r += w * lookup(qx + fi, row, t, res)[1];\n    }\n    float d = 2.8 * abs(dFdx(x));\n    basis[0] = smoothstep(-d, 0.0, -abs(fract(phase + 0.5) - 0.5));\n    basis[1] = r;\n    return basis;\n}\n\nvec4 ss_cubic(float x, int row, vec2 grid, sampler2D t, vec2 res) {\n    vec4 basis = ss_lookup(x, row, t, res).zwxy;\n    x -= grid.x;\n    x /= grid.y;\n    float qx = floor(x);\n    float phase = x - qx;\n    qx *= grid.y;\n    qx += grid.x;\n\n    float r = 0.0;\n    for (int i = -1; i <= 2; ++i) {\n        float fi = float(i);\n        float w = cubic(fi - phase);\n        fi *= grid.y;\n        r += w * ss_lookup(qx + fi, row, t, res)[1];\n    }\n    float d = 2.8 * abs(dFdx(x));\n    basis[0] = smoothstep(-d, 0.0, -abs(fract(phase + 0.5) - 0.5));\n    basis[1] = r;\n    return basis;\n}\n\nvec4 lanczos(float x, int row, vec2 grid, float fc, sampler2D t, vec2 res) {\n    vec4 basis = lookup(x, row, t, res).zwxy;\n    x -= grid.x;\n    x /= grid.y;\n    float qx = floor(x);\n    float phase = x - qx;\n    qx *= grid.y;\n    qx += grid.x;\n\n    float r = 0.0;\n    for (int i = -wing; i <= wing; ++i) {\n        float fi = float(i);\n        float w = lanczos(fi - phase, fc);\n        fi *= grid.y;\n        r += w * lookup(qx + fi, row, t, res)[1];\n    }\n    float d = 2.8 * abs(dFdx(x));\n    basis[0] = smoothstep(-d, 0.0, -abs(fract(phase + 0.5) - 0.5));\n    basis[1] = r * fc;\n    return basis;\n}\n\nvec4 ss_lanczos(float x, int row, vec2 grid, float fc, sampler2D t, vec2 res) {\n    vec4 basis = ss_lookup(x, row, t, res).zwxy;\n    x -= grid.x;\n    x /= grid.y;\n    float qx = floor(x);\n    float phase = x - qx;\n    qx *= grid.y;\n    qx += grid.x;\n\n    float r = 0.0;\n    for (int i = -wing; i <= wing; ++i) {\n        float fi = float(i);\n        float w = lanczos(fi - phase, fc);\n        fi *= grid.y;\n        r += w * ss_lookup(qx + fi, row, t, res)[1];\n    }\n    float d = 2.8 * abs(dFdx(x));\n    basis[0] = smoothstep(-d, 0.0, -abs(fract(phase + 0.5) - 0.5));\n    basis[1] = r * fc;\n    return basis;\n}\n\nvec4 linear_or_cubic(float x, int row, vec2 grid, sampler2D t, vec2 res, sampler2D kbd, int key) {\n    vec4 v;\n    if (texelFetch(kbd, ivec2(key,2),0).r < 0.5) {\n        v = cubic(x, row, grid, t, res);\n    } else {\n        if (texelFetch(kbd, ivec2(16,0),0).r < 0.5) {\n            v = linear(x, row, grid, t, res);\n        } else {\n            v = lanczos(x, row, grid, 1.0, t, res);\n        }\n    }\n    return v;\n}\n\nvec4 ss_linear_or_cubic(float x, int row, vec2 grid, sampler2D t, vec2 res, sampler2D kbd, int key) {\n    vec4 v;\n    if (texelFetch(kbd, ivec2(key,2),0).r < 0.5) {\n        v = ss_cubic(x, row, grid, t, res);\n    } else {\n        if (texelFetch(kbd, ivec2(16,0),0).r < 0.5) {\n            v = ss_linear(x, row, grid, t, res);\n        } else {\n            v = ss_lanczos(x, row, grid, 1.0, t, res);\n        }\n    }\n    return v;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash14(vec4 p4) {\n    // https://www.shadertoy.com/view/4djSRW\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    fragCoord -= 0.5;\n    int row = int(floor(fragCoord.y));\n    if (row < 8) {\n        if (row < 1) {\n            vec4 magic = vec4(0.1010101, -0.3344556677, 99.987, 555.5);\n            fragColour = vec4(hash14(fragCoord.x * magic));\n        } else {\n            float fc = 1.0 / (float(row) + 1.0);\n            vec2 grid = vec2(0,1);\n            fragColour = lanczos(fragCoord.x, row - 1, grid, fc,\n                             iChannel0, iChannelResolution[0].xy);\n        }\n    } else {\n        discard;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    fragCoord -= 0.5;\n    float x = fragCoord.x / xscale + float(column);\n    int row = int(fragCoord.y);\n\n    vec2 grid = vec2(0, 1);\n    fragColour = linear_or_cubic(x, row, grid,\n                     iChannel0, iChannelResolution[0].xy, iChannel3, 49);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    fragCoord -= 0.5;\n    float x = fragCoord.x;\n    int row = int(floor(fragCoord.y));\n    if (row < rows) {\n        bool odd = (row & 1) == 1;\n        row /= 2;\n        vec2 grid = vec2(\n            xscale * 2.0 * (sin(iTime * 0.111) + 1.0),\n            xscale / (sin(iTime * 0.21) * 0.3 + 0.75));\n\n        vec4 v;\n        if (odd) {\n            v = ss_linear_or_cubic(x, row, grid, iChannel0,\n                iChannelResolution[0].xy, iChannel3, 50);\n        } else {\n            v = linear_or_cubic(x, row, grid, iChannel0,\n                iChannelResolution[0].xy, iChannel3, 50);\n        }\n        fragColour  = v;\n    } else {\n        discard;\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}