{"ver":"0.1","info":{"id":"NlfyD2","date":"1648681745","viewed":106,"name":"Hexagon Sponge","username":"uiop","description":"just a test of a fractal","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 bg(vec3 n){\n    return vec3(10.f*n.y-9.5f,10.f*n.y-9.5f,10.f*n.y-9.5f);\n}\nvec3 rotx(vec3 p, float a){\n    float s = sin(a);\n    float c = cos(a);\n    return(vec3(p.x*c+p.y*s,-p.x*s+p.y*c,p.z));\n}\nvec3 radialz(vec3 p, float n,float r){\n    float dir = atan(p.x,p.y)+r;\n    float len = length(vec2(p.x,p.y));\n    dir = abs(mod(dir,3.141592f*2.0f/n)-3.141592f/n);\n    return vec3(sin(dir)*len, cos(dir)*len, p.z);\n}\n\nfloat sdSph(vec3 p, float r){\n    return length(p) - r;\n}\n\nvec4 getSDF(vec3 p,float time){\n    /*float n = 1.f + round(abs(p.x)-0.5f);\n    float m = 1.f + round(abs(p.y)-0.5f);\n    float s = 1.f + 0.1f*round(abs(p.z)-0.5f);\n    float q = round(p.x - 0.5f) + round(p.y - 0.5f) + round(p.z-0.5f);\n    float r = 0.0825f+0.0425f*sin(round(p.x - 0.5f) + round(p.y - 0.5f) + round(p.z-0.5f));\n    float t = sdSph((radialz(radialz(rotx((mod(p.xyz,1.f)-0.5f).xzy,time*q*0.1f).xzy,n,time*s)+vec3(0,0,-0.1f).xzy,m,time*s*2.f)+vec3(0,-0.1,0)).xzy,r);\n    */\n    vec3 pos = p;\n    float s = 1.;\n    vec4 col = vec4(0,0,0,0);\n    for(int i = 0; i < 14; i++){\n        pos = radialz(pos,6.,time*0.11).xzy-s*vec3(0.3,0.+0.1*cos(time*0.52),0.5);\n        s = s*(0.6+0.07*cos(0.05*time));\n        col += vec4(length(pos),length(pos.y)*0.3*float(i),20./float(i+18)*pos.z,0);\n    }\n    vec4 t = vec4(col.r,col.g,col.b,sdSph(pos,0.001f));\n    return t;\n    \n}\n\nvec3 refl(vec3 d, vec3 n){\n    return d - 2.f * n * dot(d,n);\n}\n\nvec3 findNormal(vec3 p, float d,float t){\n    return normalize(vec3(getSDF(p + vec3(d,0,d),t).w - getSDF(p - vec3(d,0,0),t).w,\n    getSDF(p + vec3(0,d,0),t).w - getSDF(p - vec3(0,d,0),t).w,\n    getSDF(p + vec3(0,0,d),t).w - getSDF(p - vec3(0,0,d),t).w\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 1.f;\nfloat time = iTime*speed;\n\n    vec2 uv = (fragCoord-0.5f*iResolution.xy)/iResolution.x;\n    \n    // Setup\n    vec3 pos = vec3(0.0*sin(time*0.1f),-1.0*sin(time*0.08f)+1.0,-1.5*cos(time*0.08f));\n    //vec3 dir = normalize(rotx(rotx(vec3(uv.x,uv.y,1),time*0.2f).zxy,time*0.1f).zxy);\n    vec3 dir = normalize(rotx(vec3(uv.x,uv.y,-1.).zxy,cos(time*0.08)).zxy);\n    int ma = 100;\n    vec4 col = vec4(0,0,0,0);\n    float mindist = 100000.;\n    \n    bool hit = false;\n    vec4 newcol;\n    for(int i = 0; i < ma; i ++){\n        vec4 oc = getSDF(pos,time);\n        newcol = oc;\n        float dis = oc.w;\n        mindist = min(dis,mindist);\n        \n        col += vec4(.01/dis);\n        if(dis < 0.0001){\n            i = ma;\n            hit = true;\n        }\n        if(dis > 10.){\n            i = ma;\n        }\n        pos += dir * dis;\n    }\n    if(hit){\n        col = newcol;\n    }else{\n    mindist = mindist + 0.1;\n        col = vec4(.1/mindist,.09/mindist,.05/mindist,1.);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}