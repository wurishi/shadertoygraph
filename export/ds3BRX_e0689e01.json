{"ver":"0.1","info":{"id":"ds3BRX","date":"1698098567","viewed":15,"name":"Basic_roulia","username":"roulia_","description":"Lumière, sphère, cylindre, plan, cône","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["base"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NB_PLAN 2\n#define NB_SPHERE 3\n#define NB_CYL 1\n#define NB_CONE 1\n#define NB_LUM 3\n\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nstruct Lum {\n    vec3 Color;\n    vec3 Pos;\n};\n\nstruct Plan {\n    vec3 Dir1;\n    vec3 Dir2;\n    vec3 Color;\n    vec3 Center;\n    float h;\n    float w;\n};\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n   vec3 Color;\n};\n\nstruct Cylindre {\n   vec3 Center;\n   vec3 Dir;  \n   vec3 Color;\n   float r;\n   float h;\n};\n\nstruct Cone {\n    vec3 Center;\n    vec3 Dir;\n    vec3 Color;\n    float r;\n    float s;\n    float h;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    vec3 vertical = vec3(0.0,0.0,1.0);\n    C.View = (LookAt - Obs) / length(LookAt - Obs);\n    C.Horiz = normalize(cross(vertical, C.View));\n    C.Up = normalize(cross(C.View,C.Horiz));\n    C.Obs = Obs;\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H/2.0/tan(aperture * 3.1415 / 180.0 /2.0);\n    return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   r.Dir = C.View * C.z + (XY.x - 0.5 * C.W) * C.Horiz + (XY.y - 0.5 * C.H) * C.Up;\n   return r;\n}\n\nLum lum(in vec3 Color, in vec3 Pos) {\n    Lum L;\n    L.Color = Color;\n    L.Pos = Pos;\n    return L;\n}\n\nPlan plan(vec3 center, vec3 d1, vec3 d2, vec3 color, float h, float w) {\n    Plan P;\n    P.Dir1 = d1;\n    P.Dir2 = d2;\n    P.Center = center;\n    P.Color = color;\n    P.h = h;\n    P.w = w;\n    return P;\n}\n\nCylindre cylindre(vec3 center, vec3 d, vec3 color, float r, float h) {\n    Cylindre C;\n    C.Center = center;\n    C.Dir = d;\n    C.Color = color;\n    C.r = r;\n    C.h = h;\n    return C;\n}\n\nCone cone(vec3 center, vec3 d, vec3 color, float r, float s, float h) {\n    Cone C;\n    C.Center = center;\n    C.Dir = d;\n    C.Color = color;\n    C.r = r;\n    C.s = s;\n    if (h>s) {h=s;}\n    C.h = h;\n    return C;\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    \n    float a = dot(R.Dir,R.Dir);\n    float b = 2.0*dot(R.Dir,(R.Origin - S.Center));\n    float c = dot(R.Origin - S.Center, R.Origin - S.Center) - S.R*S.R;\n    float delta = b*b - 4.0*a*c;   \n        \n    if (delta > 0.0) {\n        float t1 = (-b - sqrt(delta)) / (2.0*a);\n        float t2 = (-b + sqrt(delta)) / (2.0*a);\n        t = t1;\n        if (t1 < 0.0) {\n            t = t2;\n            if (t2 < 0.0) {return false;}\n        }\n    \n    } else if (delta == 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n        if (t < 0.0) {return false;}\n    } else {\n        t = -1.0;\n        return false;\n    }\n    return true;\n}\n\nbool intersect_plan(in Ray R, in Plan P, out float t) {\n    vec3 n = cross(P.Dir1,P.Dir2);\n    if (dot(n,R.Dir)!=0.0) {\n        mat3 X = mat3(R.Dir,-P.Dir1,-P.Dir2);\n        mat3 Xinv = inverse(X);\n        vec3 V0 = P.Center - R.Origin;\n        vec3 C = Xinv*V0;\n        t = C.x;\n        float u = C.y;\n        float v = C.z;\n        \n        if ( ( P.h > 0.0 && P.h < abs(u) )||  ( P.w > 0.0 && P.w < abs(v) ) )  {\n            t = -1.0;\n            return false;\n        }\n        if (t > 0.0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool intersect_cylindre(in Ray R, in Cylindre C, out float t,  out bool devant, out vec3 color) {\n  \n    vec3 x = R.Dir - dot(C.Dir,R.Dir)*C.Dir;\n    vec3 y = R.Origin - C.Center - dot(C.Dir,R.Origin-C.Center)*C.Dir;\n    float a = dot(x,x);\n    float b = 2.0*dot(x,y);\n    float c = dot(y,y) - C.r*C.r;\n    \n    float delta = b*b - 4.0*a*c;   \n    \n    \n    if (delta > 0.0) {\n        float t1 = (-b - sqrt(delta)) / (2.0*a);\n        float t2 = (-b + sqrt(delta)) / (2.0*a);\n        t = t1;\n        float l = dot(C.Dir,C.Center - (R.Origin + t*R.Dir));\n        devant = true;\n        if ( C.h > 0.0 && (-(C.h /2.0) > l || l > C.h/2.0 )) {\n            t = t2;\n            devant = false;\n            //color = vec3(1,0,0);//rouge\n            l = dot(C.Dir,C.Center - (R.Origin + t*R.Dir));\n            if ( C.h > 0.0 && (-(C.h /2.0) > l || l > C.h/2.0 )) {\n                t=-1.0;\n                return false;\n            }\n        }\n        \n        if (t < 0.0) {\n            t = t2;\n            devant = false;\n            //color = vec3(0,1,0);//vert\n            if (t < 0.0) {t=-1.0; return false;}\n        }\n    \n    } else if (delta == 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n        //color = vec3(0,0,1); //bleu\n        if (t < 0.0) {t=-1.0; return false;}\n    } else {\n        t = -1.0;\n        return false;\n    } \n    return true;\n}\n\nbool intersect_cone(in Ray R, in Cone C, out float t, out bool devant) {\n  \n    vec3 x = R.Dir - dot(C.Dir,R.Dir)*C.Dir;\n    vec3 y = R.Origin - C.Center - dot(C.Dir,R.Origin-C.Center)*C.Dir;\n    float a1 = dot(x,x);\n    float b1 = 2.0*dot(x,y);\n    float c1 = dot(y,y);\n    float a2 = C.r*C.r/(C.s*C.s)*pow(dot(C.Dir,R.Dir),2.0);\n    float b2 = 2.0*C.r*C.r/(C.s*C.s)*dot(C.Dir,R.Dir)*dot(C.Dir,R.Origin-C.Center) - 2.0*C.r*C.r/C.s*dot(C.Dir,R.Dir);\n    float c2 = C.r*C.r/(C.s*C.s)*pow(dot(C.Dir,R.Origin-C.Center),2.0) - 2.0*C.r*C.r/C.s*dot(C.Dir,R.Origin-C.Center) + C.r*C.r;\n    float a = a1 -a2;\n    float b = b1- b2;\n    float c = c1- c2;\n    \n    \n    float delta = b*b - 4.0*a*c;   \n    \n    \n    if (delta > 0.0) {\n        float t1 = (-b - sqrt(delta)) / (2.0*a);\n        float t2 = (-b + sqrt(delta)) / (2.0*a);\n        t = t1;\n        float l = dot(C.Dir,C.Center +(R.Origin + t*R.Dir));\n        devant = true;\n        if ( C.h > 0.0 && (0.0 > l || l > C.h )) {\n            t = t2;\n            devant = false;\n            //color = vec3(1,0,0);//rouge\n            l = dot(C.Dir,C.Center + (R.Origin + t*R.Dir));\n            if ( C.h > 0.0 && (0.0 > l || l > C.h )) {\n                t=-1.0;\n                return false;\n            }\n        }\n        \n        if (t < 0.0) {\n            t = t2;\n            devant = false;\n            //color = vec3(0,1,0);//vert\n            if (t < 0.0) {t=-1.0; return false;}\n        }\n    \n    } else if (delta == 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n        //color = vec3(0,0,1); //bleu\n        if (t < 0.0) {t=-1.0; return false;}\n    } else {\n        t = -1.0;\n        return false;\n    } \n    return true;\n}\n\nvec3 apply_light_sphere(in Ray R, in Sphere S, in Lum L, in float t, in Sphere spheres[NB_SPHERE], in Plan plans[NB_PLAN],in Cylindre cylindres[NB_CYL], in Cone cones[NB_CONE], in int i) {\n    float costheta = dot(normalize(S.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n    if (costheta < 0.0){costheta=0.0;}\n    \n    Ray Rl;\n\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = L.Pos - Rl.Origin;\n    \n    //Ombres sphères sur sphères\n    float t2 = -1.0;\n    for(int j = 0; j < NB_SPHERE; j++) {\n        if (j != i && length(spheres[j].Center - L.Pos) > 0.1) {\n            t2 = -1.0;\n            if (intersect_sphere(Rl, spheres[j], t2)){\n                if (t2 > 0.01 && t2 < 0.99) {\n                    return vec3(0,0,0);\n                }  \n            }\n        }\n    }\n    \n    //Ombres plan sur sphère\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        if (intersect_plan(Rl, plans[j], t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cylindres sur sphère\n    t2 = -1.0;\n    for(int j = 0; j < NB_CYL; j++) {\n        bool devant;\n        vec3 color;\n        if (intersect_cylindre(Rl, cylindres[j], t2, devant, color)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cones sur sphère\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        bool devant;\n        if (intersect_cone(Rl, cones[j], t2, devant)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    return vec3(S.Color*L.Color*costheta);\n}\n\nvec3 apply_light_plan(in Ray R, in Plan P, in Lum L, in float t, in Sphere spheres[NB_SPHERE], in Plan plans[NB_PLAN], in Cylindre cylindres[NB_CYL], in Cone cones[NB_CONE], in int i) {\n    vec3 n = cross(P.Dir1,P.Dir2);\n    float costheta = dot(normalize(n),normalize((R.Origin + t*R.Dir)- L.Pos));\n    if (costheta < 0.0){costheta=0.0;}\n    \n    Ray Rl;\n\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = L.Pos - Rl.Origin;\n    \n    //Ombres plan sur plan\n    float t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        if (j != i) {\n            t2 = -1.0;\n            if (intersect_plan(Rl, plans[j], t2)){\n                if (t2 > 0.01 && t2 < 0.99) {\n                    return vec3(0,0,0);\n                }  \n            }\n        }\n    }\n    \n    //Ombres sphère sur plan\n    t2 = -1.0;\n    for(int j = 0; j < NB_SPHERE; j++) {\n        if (intersect_sphere(Rl, spheres[j], t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cylindres sur plan\n    t2 = -1.0;\n    for(int j = 0; j < NB_CYL; j++) {\n        bool devant;\n        vec3 color;\n        if (intersect_cylindre(Rl, cylindres[j], t2, devant, color)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cones sur plan\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        bool devant;\n        if (intersect_cone(Rl, cones[j], t2, devant)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    return vec3(P.Color*L.Color*costheta);\n}\n\nvec3 apply_light_cylindre(in Ray R, in Cylindre C, in Lum L, in float t, bool devant, in Sphere spheres[NB_SPHERE], in Plan plans[NB_PLAN], in Cylindre cylindres[NB_CYL],in Cone cones[NB_CONE], in int i) {\n    float costheta = dot(normalize(C.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n    if (!devant) {\n        costheta = dot(-normalize(C.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n    }\n    if (costheta < 0.0){costheta=0.0;}\n\n    \n    Ray Rl;\n\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = L.Pos - Rl.Origin;\n    \n   \n    //Ombres cylindres sur cylindres\n    float t2 = -1.0;\n    for(int j = 0; j < NB_CYL; j++) {\n        if (j != i && length(cylindres[j].Center - L.Pos) > 0.1) {\n            t2 = -1.0;\n            bool devant;\n            vec3 color;\n            if (intersect_cylindre(Rl, cylindres[j], t2, devant, color)){\n                if (t2 > 0.01 && t2 < 0.99) {\n                    return vec3(0,0,0);\n                }  \n            }\n        }\n    }\n    \n    //Ombres plan sur cylindre\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        if (intersect_plan(Rl, plans[j], t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres sphère sur cylindre\n    t2 = -1.0;\n    for(int j = 0; j < NB_SPHERE; j++) {\n        if (intersect_sphere(Rl, spheres[j], t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cones sur cylindre\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        bool devant;\n        if (intersect_cone(Rl, cones[j], t2, devant)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    return vec3(C.Color*L.Color*costheta);\n}\n\nvec3 apply_light_cone(in Ray R, in Cone C, in Lum L, in float t, bool devant, in Sphere spheres[NB_SPHERE], in Plan plans[NB_PLAN], in Cylindre cylindres[NB_CYL], in Cone cones[NB_CONE], in int i) {\n    float costheta = dot(normalize(C.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n    if (!devant) {\n        costheta = dot(-normalize(C.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n    }\n    if (costheta < 0.0){costheta=0.0;}\n\n    Ray Rl;\n\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = L.Pos - Rl.Origin;\n    \n    \n    //Ombres cone sur cone\n    float t2 = -1.0;\n    for(int j = 0; j < NB_CYL; j++) {\n        if (j != i && length(cones[j].Center - L.Pos) > 0.1) {\n            t2 = -1.0;\n            bool devant;\n            vec3 color;\n            if (intersect_cone(Rl, cones[j], t2, devant)){\n                if (t2 > 0.01 && t2 < 0.99) {\n                    return vec3(0,0,0);\n                }  \n            }\n        }\n    }\n    \n    \n    //Ombres plan sur cone\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        if (intersect_plan(Rl, plans[j], t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres sphère sur cone\n    t2 = -1.0;\n    for(int j = 0; j < NB_SPHERE; j++) {\n        if (intersect_sphere(Rl, spheres[j], t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cylindre sur cone\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n    vec3 color;\n            if (intersect_cylindre(Rl, cylindres[j], t2, devant,color)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    return vec3(C.Color*L.Color*costheta);\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    float pi = 3.1415;\n    Camera C = camera(\n       vec3(10.0, 0.0, 0.0),\n       vec3(0.0, 0.0, 0.0),\n       50.0  \n    );\n    \n    //Plan\n    Plan plans[NB_PLAN];\n    Plan P = plan(vec3(0.0,0.0,-4.0),vec3(-1.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(1,1,1),-1.0,-1.0);\n    plans[0] = P;\n   \n    Plan P1= plan(vec3(-5.0,-4.0,0.0),vec3(0.0,0.0,1.0),vec3(0.0,1.0,0.0),vec3(1,1,1),5.0,15.0);\n    plans[1] = P1;\n    \n    //Sphères   \n    Sphere spheres[NB_SPHERE];\n    \n    Sphere S;\n    S.Center = vec3(0.0,4.0,0.0);\n    S.R = 0.6;\n    S.Color = vec3(1,1,1);//col;\n    spheres[0] = S;\n   \n    Sphere S2;\n    float a = iTime; \n    vec3 offset = vec3(1.2, 0.0, 0.0);\n    mat3 rotZ = rotateZ(a);\n    vec3 rotatedOffset = rotZ*offset;\n    \n    \n    S2.Center = spheres[0].Center + rotatedOffset;\n    S2.R = 0.3;\n    S2.Color = vec3(1,1,1);//vec3(1,1,0.5); //0.5 + 0.5*cos(2.0*iTime+vec3(0,1,2));\n    spheres[1] = S2;\n   \n    Sphere S3;\n    S3.Center = vec3(2.0,2.0,2.0);\n    S3.R = 0.6;\n    S3.Color = vec3(1,1,1);\n    spheres[2] = S3;\n    \n    \n    //Cylindre\n    Cylindre cylindres[NB_CYL];\n    Cylindre Cy = cylindre(vec3(0.0,-4.0,0.0),vec3(0.0,0.0,1.0),vec3(1,0,0),0.5,2.0);\n    cylindres[0] = Cy;\n    \n    //Cones\n    Cone cones[NB_CONE];\n    Cone Co = cone(vec3(0.0,0.0,1.0),vec3(0.0,0.0,1.0),vec3(0,1,0),1.0,6.0,3.0);\n    cones[0] = Co;\n\n\n    //Lumières\n    Lum lumieres[NB_LUM];\n    \n    /*\n    Lum L;\n    a = iTime*2.0;\n    L.Color = vec3(0,0,0); //rouge\n    offset = vec3(0.0,7.0,0.0);\n    rotZ = rotateZ(a);\n    rotatedOffset = rotZ*offset;\n    L.Pos = spheres[0].Center + rotatedOffset;\n    lumieres[0] = L;\n    */\n    \n    Lum L2;\n    a = iTime/2.0;\n    L2.Color = vec3(1.0*(sin(2.0*iTime)),1.0*cos(iTime),0.0); //jaune\n    offset = vec3(0.0, 0.0, 1.5);\n    mat3 rotX = rotateX(a);\n    rotatedOffset = rotX*offset;\n    L2.Pos = spheres[2].Center + rotatedOffset;\n    lumieres[0] = L2;\n    \n    \n    Lum L3;\n    L3.Color = vec3(0,1,0); //verte\n    L3.Pos = vec3(0.0,0.0,2.0); // + rotatedOffset;\n    lumieres[2] = L3;\n    \n    /*\n    Lum L4;\n    L4.Color = vec3(0,0,0); //bleu\n    L4.Pos = cylindres[0].Center + vec3(0.0,-5.0,0.0);\n    lumieres[2] = L4;\n    */\n    \n    Lum L5;\n    L5.Color = vec3(1,1,1); //blanc\n    L5.Pos = vec3(40.0,4.0,5.0);\n    lumieres[1] = L5;\n    \n\n\n    //Couleur fond\n    fragColor = vec4(0.2,0.2,0.2,1);\n    \n    //Intersection rayon-objets\n    float best_dist = 999999.0;\n    \n    //Intersection sphere Camera+Lumiere+Ombres\n    for(int i = 0; i < NB_SPHERE; i++) { //pour toutes les sphères\n       Ray R = launch(C, fragCoord);\n       float t = 0.0;     \n       if (intersect_sphere(R, spheres[i], t)) {\n           if (t>0.0 && t< best_dist) {\n               best_dist = t;\n               fragColor = vec4(0,0,0,1);\n               for(int j = 0; j < NB_LUM; j++) { //pour toutes les lumieres\n                   fragColor = vec4(fragColor.xyz + apply_light_sphere(R,spheres[i], lumieres[j], best_dist, spheres, plans, cylindres, cones, i) ,1);\n               }\n           }\n       }\n    }\n    //intersection plan Camera+Lumiere+Ombres\n    //best_dist = 999999.0;\n    for (int i = 0; i < NB_PLAN ; i++) {\n       Ray R = launch(C, fragCoord);\n       float t = 0.0;\n       if (intersect_plan(R,plans[i],t)) {\n           if (t>0.0 && t< best_dist) {\n               best_dist = t;\n               fragColor = vec4(0,0,0,1);\n               for(int j = 0; j < NB_LUM; j++) { //pour toutes les lumieres\n                   fragColor = vec4(fragColor.xyz + apply_light_plan(R,plans[i], lumieres[j], best_dist, spheres, plans, cylindres, cones, i) ,1);\n               }\n           }\n       }\n     }\n    //Intersection cylindre Camera+Lumiere+Ombres\n    best_dist = 999999.0;\n    for(int i = 0; i < NB_CYL; i++) { //pour toutes les cylindres\n       Ray R = launch(C, fragCoord);\n       float t;     \n       bool devant;\n       if (intersect_cylindre(R, cylindres[i], t, devant, cylindres[i].Color)) {\n           if (t>0.0 && t< best_dist) {\n               best_dist = t;\n               fragColor = vec4(0,0,0,1);\n               for(int j = 0; j < NB_LUM; j++) { //pour toutes les lumieres\n                   fragColor = vec4(fragColor.xyz + apply_light_cylindre(R,cylindres[i], lumieres[j], best_dist,devant, spheres, plans, cylindres, cones, i) ,1);\n               }\n           }\n       }\n    }\n    \n    //Intersection cone Camera+Lumiere+Ombres\n    best_dist = 999999.0;\n    for(int i = 0; i < NB_CONE; i++) { //pour toutes les cones\n       Ray R = launch(C, fragCoord);\n       float t;     \n       bool devant;\n       if (intersect_cone(R, cones[i], t, devant)) {\n           if (t>0.0 && t< best_dist) {\n               best_dist = t;\n               fragColor = vec4(0,0,0,1);\n               for(int j = 0; j < NB_LUM; j++) { //pour toutes les lumieres\n                   fragColor = vec4(fragColor.xyz + apply_light_cone(R,cones[i], lumieres[j], best_dist,devant, spheres, plans,cylindres, cones, i) ,1);\n               }\n           }\n       }\n    }\n    \n   \n}\n","name":"Image","description":"","type":"image"}]}