{"ver":"0.1","info":{"id":"clVcR3","date":"1700969350","viewed":24,"name":"RT : Light Spheres 1","username":"ukidaveyash","description":"Basic Ray trace example","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed = 0.0;\n\nvec3 bgColor = vec3(0, 0.5, 1);\nint light_num = 2;\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n    bool lht_src;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n\n// Intersectio code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c; \n    float t = 1000000.0; // initialize to a large number\n    if (disc > 0.0) {\n        t = min((-b - sqrt(disc)), (-b + sqrt(disc))); // Lesser of two roots\n        if (t > 0.00001) {\n            return t;\n        }\n    }\n    return t;\n}\n\n\nconst int NUM_SPHERE = 6;\nSphere spheres[NUM_SPHERE];\n\n\n\nfloat theta = 0.0;\nvoid rotateSceneTenDegrees(int f) {\n    theta += float(f)/5.0 * 3.1415/45.0;\n    vec3 v1 = spheres[2].center - vec3(0.0, 0.0, -4.0);\n    vec3 axis = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 newv = v1*cos(theta) + cross(axis, v1)* sin(theta) + axis*dot(axis, v1)*(1.0-cos(theta));\n    spheres[2].center = newv + vec3(0.0, 0.0, -4.0);\n}\n\nvoid makeScene(int f) {\n    spheres[0] = Sphere(1.0, vec3(0.0, 0.00, -6), vec3(1, 0, 0), false);\n    spheres[1] = Sphere(1.5, vec3(-2, 1.00, -10), vec3(0.25, 0.35, 0.1), false);\n    spheres[2] = Sphere(0.1, vec3(1, 0, -2), vec3(1.0, 1.0, 1.0), true);\n    rotateSceneTenDegrees(f);\n}\n\nint numSamples = 4;\n\n\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   vec3 lightOrigin = spheres[light_num].center;\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   vec3 lightColor = spheres[light_num].color; // Light color\n   \n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       float t = 1000000.0;\n       Sphere sphere;\n       for (int j=0; j < 3; j++) {\n           float t_temp = raySphereIntersect(ray, spheres[j]);\n           if (t_temp < t) {\n               t = t_temp;\n               sphere = spheres[j];\n           }\n       }\n       \n       if (t < 1000000.0) { // Ray hit\n           vec3 hit = ray.origin + t*ray.direction; // Hit position\n           vec3 norm = normalize(hit - sphere.center);\n           \n           //Light calc\n           vec3 lightDir = normalize(lightOrigin - hit);\n           vec3 reflectDir = reflect(lightDir, norm);  \n           float angle = dot(lightDir, norm);\n           float spec = max(dot(ray.direction, reflectDir), 0.0);\n           spec = pow(spec, 16.0);\n\n           \n           // Shadows\n           Ray sh_Ray = Ray(hit, lightDir);\n           float t_sh = 1000000.0;\n           float shadow = 1.0;\n           t_sh = raySphereIntersect(sh_Ray, spheres[0]);\n           if((t_sh > 0.00001) && t_sh < raySphereIntersect(sh_Ray, spheres[2])) {\n               shadow = 0.1;\n           }\n           \n                     \n                      \n           vec3 diffuse = max(angle, 0.0) * lightColor;\n           vec3 ambient = lightColor*0.05;\n           vec3 specular = 1.5 * spec * lightColor;  \n           float u = asin(norm.x)/3.14 + 0.5;\n           float v = asin(norm.y)/3.14 + 0.5;\n           vec3 tex = texture(iChannel0, vec2(u, v)).xyz;\n           // Color apply\n           if(sphere.lht_src == false) {\n               samp = samp + (ambient + diffuse + specular) * shadow * sphere.color;\n           }\n           else {\n               samp = samp + sphere.color;\n           }\n       } \n   }\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}