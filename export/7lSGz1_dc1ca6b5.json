{"ver":"0.1","info":{"id":"7lSGz1","date":"1623442630","viewed":73,"name":"Mummotunneli","username":"elefAntti","description":"Classic tunnel effect with a bit of a different mood.\nOriginally made with\nhttps://soundcloud.com/jasmine-thompson/mad-world-1\nbut that stopped working so changed to\nhttps://soundcloud.com/elginpark/mad-world-donnie-darko","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"tslfWj","parentname":"AV00X_StartingPoint2"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"ltsXDX","filepath":"https://soundcloud.com/elginpark/mad-world-donnie-darko","previewfilepath":"https://soundcloud.com/elginpark/mad-world-donnie-darko","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GammaValue 0.45\n#define VignetteStrength 1.8\n#define FocalLength 1.0\n#define MaxDistance 140.0\n#define Speed 1.0\n#define Delay 1.3\n#define PI 3.14159\n#define DTR (PI/180.0)\n\n#define LIGHT_ON_TIME 155.0\n\n\n#define RING_DIST 7.0\n\n\nfloat pulse(float x, float len)\n{\n    x *= 1.1/len;\n    return smoothstep(0.0, 1.0, x) * smoothstep(1.1, 1.0, x);\n}\n\nfloat timeDelayPerRing(float time)\n{\n    if(time < 4.0)\n    {\n        return 0.0;\n    }\n    time -= 4.0;\n    \n    return (smoothstep(6.0, 7.0, time)-0.5) * 2.0 * 0.35;\n}\n\nfloat ringRotation(float time)\n{\n    return sin(time*PI * 5.0/24.0) * pulse(time - 12.0, 20.0)\n        + max(0.0, time - 60.0) * 3.0\n        - max(0.0, time - 82.4) * 3.0\n        + max(0.0, time - 113.5) * 3.0\n        - max(0.0, time - 123.0) * 3.0\n        - max(0.0, time - 145.0) * 0.5\n        + max(0.0, time - 305.0) * 0.5;\n}\n\nfloat timeDelayPerSector(float time)\n{\n    return 0.0;\n}\n\nfloat tileRadialOffset(float time)\n{\n    return smoothstep(58.0, 62.0, time) \n    * (sin(time / 2.0) + 0.9) * 5.0;\n}\n\nvec2 ringCenterOffset(float time)\n{\n    return vec2(sin(time /2.0), sin(time/3.0))\n    *  (1.0 - smoothstep(146.0, 153.0, time)) \n    * smoothstep(43.0, 45.0, time) * 3.0;\n}\n\nfloat move(float time)\n{\n    return (max(0.0, time - 40.0) - max(0.0, time - 182.0))*20.0;\n}\n\nfloat cameraFlip(float time)\n{\n    return (0.5 - smoothstep(92.0, 97.0, time)) *2.0;\n}\n\nfloat tileRotation(float time)\n{\n    float angle = smoothstep(2.1, 3.1, time) * 2.0 * PI;\n    angle += smoothstep(3.6, 4.6, time) * 1.0 * PI;\n    angle += smoothstep(0.0, 0.25, (time + 4.0)* 5.0) * PI;\n    angle += 0.0;\n    return angle;\n}\n\nfloat tileRotation2(float time)\n{\n    float angle = smoothstep(0.0, 1.0, time) * 1.0 * PI;\n    angle += smoothstep(3.6, 4.6, time) * 1.0 * PI;\n    return angle;\n}\n\nfloat milling(float time)\n{\n    return smoothstep(33.0, 34.0, time) *  (1.0 - smoothstep(142.0, 144.0, time)) * 1.5;\n}\n\nmat3 cameraLookAt( vec3 lookAt )\n{\n    lookAt = normalize(lookAt);\n    lookAt.y *= -1.0;\n    lookAt.x *= -1.0;\n    vec3 x = vec3( lookAt.z, 0, -lookAt.x ); \n    vec3 y = cross( lookAt, x );\n    return mat3( x, y, lookAt );\n}\n\n\nmat2 rot(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n//model&scene is (dist, material, glow)\nvec3 combine(vec3 scene, vec3 model)\n{\n    if(model.x < scene.x)\n    {\n        scene.xy = model.xy; \n    }\n    scene.z += model.z;\n    return scene;\n}\n\n//model is (dist, material, glow)\nvec3 glow(vec3 model, float intensity)\n{\n    model.z = intensity / ( model.x * model.x);\n    return model;\n}\n\nfloat distTorus(vec3 pos, float r1, float r2)\n{\n    vec2 cut = vec2(length(pos.xz)-r1, pos.y);\n    return length(cut) - r2;\n}\n\nfloat distBox(vec3 pos, vec3 scale)\n{  \n    float dist = max(max(abs(pos.x) - scale.x, abs(pos.y)) - scale.y, abs(pos.z) - scale.z);\n    return dist;\n}\n\n\n//The main distance field function\n//--------------------------------------------------------------\nvec3 distSlate(vec3 pos, float time, float idA, float idB)\n{\n    pos += vec3(0.0, 15.0, 0.0);\n    \n    pos.y += tileRadialOffset(time);\n     \n    pos += milling(time) \n        * sin(time* hash33(vec3(idA, idB, 0.0)))\n        * vec3(0.01, 1.0, 0.01);\n    \n    pos.yz *= rot(tileRotation(time));\n    pos.xy *= rot(tileRotation2(time));\n    float box = distBox(pos, vec3(3.0, 0.3, 3.0));\n    return vec3(box, 1.0, 0.0);\n}\n\nvec3 distRing(vec3 pos, float time, float ring)\n{\n\n    \n    vec3 res = vec3(MaxDistance, 0.0, 0.0);\n    if(time > LIGHT_ON_TIME)\n    {\n        vec3 glowPos = hash33(vec3(ring, 0.0, 0.0)) * 10.0;\n        glowPos.z = 1.5;\n        float glowDist = length(pos - glowPos) - 0.2;\n        res = combine(res, glow(vec3(glowDist, 2.0, 0.0), sin(time) * 0.1 + 0.1));\n    }\n    pos.xy *= rot(ringRotation(time));\n    float angle = 30.0 * DTR;\n\n    float theta = atan(pos.x, pos.y);\n    \n    float theta_prime = theta / angle;\n    \n    float sector = floor(theta_prime);\n    \n    float angle_in_sect = fract(theta_prime) * angle + PI * 1.5 - 0.5 * angle;\n    \n    time += timeDelayPerSector(time) * sector;\n    \n    float d = length(pos.xy);\n    pos.xy = vec2(cos(angle_in_sect), sin(angle_in_sect)) * d;\n    \n    res = combine(res, distSlate(pos, time, sector, ring));\n    \n    \n    return res;\n}\n\nvec3 distTube(vec3 pos, float time)\n{\n    pos.z += move(time);\n    float ring_id = floor(pos.z/RING_DIST);\n\n    pos.z = mod(pos.z, RING_DIST);    \n    vec3 dz = vec3(0.0, 0.0, RING_DIST);\n    float dt = timeDelayPerRing(time);\n    time += ring_id * dt;\n    \n    vec3 res = distRing(pos, time, ring_id);\n    if(time > 148.0)\n    {\n        res = combine(res, distRing(pos + dz, time - dt, ring_id - 1.0));\n    }\n    \n    if(time < 157.0)\n    {\n        res = combine(res, distRing(pos - dz, time + dt, ring_id + 1.0));\n    }\n    \n    return res;\n}\n\n//Computes the normal of the distance field \nvec3 normModel(vec3 pos, float time)\n{\n    vec3 delta = vec3(0.0001,0.0001, 0.0);\n    float dist = distTube(pos, time).x;\n    return normalize(vec3(\n         distTube(pos + delta.xzz, time).x - dist,\n         distTube(pos + delta.zxz, time).x - dist,\n         distTube(pos + delta.zzx, time).x - dist\n    ));\n}\n\n\n//Cast a ray in the distance field. Return the distance it travelled before hitting something.\nvec3 castRay(vec3 pos, vec3 dir, float time, float maxDist, float distMultiplier)\n{\n    float totalDist = 0.0;\n    float totalGlow = 0.0;\n    \n    for(int i = 0; i < 80; ++i)\n    {\n        vec3 currentPos = pos + dir * totalDist;\n        vec3 model = distTube(currentPos, time);\n        float distToSurface = model.x * distMultiplier;\n        totalGlow += model.z ;\n        totalDist += distToSurface;\n        \n        if(distToSurface < 0.001 || totalDist > MaxDistance)\n        {\n            return vec3(totalDist, model.y, totalGlow);\n        }\n        \n        if(length(currentPos.xy) > 35.0)\n        {\n            return vec3(totalDist, 0, totalGlow);\n        }\n    }\n    \n    return vec3(maxDist, 0.0, totalGlow);\n}\n\n//Schlick's approximation of Fresnel factor\nfloat reflectionCoef(float cos_theta, float R0)\n{\n    return max(0.0, R0 + (1.0 - R0) * pow(1.0 - cos_theta, 5.0));\n}\n\n//Main image function (frag coords, time) -> color\nvec3 rtMain(in vec2 fragCoord, in float time, float focalLength)\n{\n    vec2 position = fragCoord * 2.0 - 1.0;\n    vec3 rayDir = normalize(vec3( position, focalLength));\n\n    vec3 cameraPos = vec3( -1.0, 1.0, -30.0 );\n    cameraPos.z *= cameraFlip(time);\n    cameraPos.xy += ringCenterOffset(time);\n    rayDir *= cameraLookAt(-cameraPos);\n\n    vec3 rayResult = castRay(cameraPos, rayDir, time, MaxDistance, 1.0);\n    \n    float distToSurface = rayResult.x; \n    vec3 cameraRayEnter = cameraPos + rayDir * (distToSurface);    \n    vec3 surfaceNormal = normModel(cameraRayEnter, time);\n    vec3 reflRay = reflect(rayDir, surfaceNormal);\n    \n    \n    float backgroundMask = min(min(1.0, round(rayResult.y)),\n          smoothstep(MaxDistance, MaxDistance - 60.0, distToSurface));\n\tvec3 fgColor = max(0.0, dot(-surfaceNormal, vec3(0.1,0.1, 0.8))) * vec3(1.0, 0.9, 0.9) + vec3(0.3);\n\n    vec3 bgColor = texture(iChannel0, rayDir).rgb;\n    vec3 reflColor = texture(iChannel0, reflRay).rgb;\n    \n    float refCoef = reflectionCoef(dot(-surfaceNormal, rayDir), 0.6);\n    fgColor = mix(fgColor, reflColor, refCoef);\n    \n    float low_freq  = texture( iChannel1, vec2(0.05, 0.25) ).x; \n    float mid_freq  = texture( iChannel1, vec2(0.6, 0.25) ).x; \n    \n    \n    float glow = rayResult.z * (0.1 + mid_freq * 2.0);\n    \n    vec3 glowColor = vec3(1.0, low_freq, low_freq); \n    \n\treturn mix(bgColor, fgColor, backgroundMask) + smoothstep(0.0, 1.0, glow)*glowColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y / iResolution.x;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5f)) * vec2(1.0, aspect) + vec2(0.5);\n    \n    vec3 color = rtMain(uv, (iTime - Delay) * Speed, FocalLength);\n\n    //Gamma\n    color.rgb = pow(color.rgb, vec3(GammaValue));\n\n    //Saturate channels\n    color.rgb = min(color.rgb, vec3(1.0));\n    \n    color.rgb += texture(iChannel2, uv*2.0 + vec2(0.0, iTime*10.0)).rrr * 0.1;\n    \n    //Vignette\n    color.rgb *= pow(1.0 - length(uv - vec2(0.5, 0.5)) * VignetteStrength, 0.5); \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}","name":"Common","description":"","type":"common"}]}