{"ver":"0.1","info":{"id":"sdd3zX","date":"1630858196","viewed":166,"name":"Experimental 3D noise atlas ","username":"Langwedocjusz","description":"As of writing this shader I did not research ways of storing 3d noise information properly, this is just my initial experiment.\nCommenting out \"TEST_CUBE\" shows the same noise being used to displace the surface of a sphere.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TEST_CUBE\n\n//TO-DO: Get rid of the ugly discontinuity at the axes\n\n//===============================================================\n#define MAX_MARCH_STEPS 64\n#define MAX_MARCH_DIST 25.0\n#define MIN_MARCH_DIST 0.0001\n\nfloat sdfSphere(vec3 point, float radius );\nfloat sdfBox( vec3 p, vec3 b );\nfloat Map(vec3 point);\nfloat March(vec3 origin, vec3 direction);\nvec3 getNormal(vec3 point);\nfloat getDiffuse(vec3 point, vec3 normal);\n//==============================================================\n\nvec2 getUV(vec3 q, inout float x, inout float y){\n    //components of q should be normalized to [0:1]\n    //\"fractional\" coordinates:\n    vec2 ts = q.xy / TILES;\n    \n    //coordinates of particular tile:\n    float n = floor(TILES * TILES * q.z);\n    x = mod(n, TILES);\n    y = (n - x) / TILES;\n    \n    //combination:\n    return (vec2(y,x)/ TILES) + ts;\n}\n\nfloat getNoise(vec3 p, float scale){\n    vec3 q = mod(p, scale) / scale;\n    \n    //offset of one layer:\n    float thiccness = 1.0/(TILES*TILES);\n    vec3 offset = vec3(0.0, 0.0, thiccness);\n    vec3 q2 = q.z >= thiccness ? q - offset : vec3(0.0, 0.0, 1.0) + q - offset;\n\n    float x,y,x2,y2;\n\n    vec2 uv  = getUV(q, x, y);\n    vec2 uv2 = getUV(q2, x2, y2);\n    \n    float w = mod(TILES*TILES*q.z, 1.0);\n    \n    //Using biquadradic interpolation within each layer \n    //and cubic between them (slower than linear, but smooth)\n    float w2 = -2.0*w*w*w + 3.0*w*w;\n    return w2 * sample_biquadratic(iChannel0, iResolution.xy, uv, vec2(y,x)).r \n           + (1.0 - w2) * sample_biquadratic(iChannel0, iResolution.xy, uv2, vec2(y2,x2)).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize coordinates to (-1:1) with aspect ratio correction\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Raymarching\n    vec3 color;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    vec3 origin = vec3(0.0, 0.0, -2.0);\n    \n    float dist = March(origin, ray);\n    \n    if(dist >= MAX_MARCH_DIST){\n        color = vec3(0.0, 0.0, 0.1);\n    }\n    \n    else {\n        vec3 point = origin + dist * ray;\n        vec3 normal = getNormal(point);\n        \n        #ifdef TEST_CUBE\n        float scale = 0.5 * sqrt(2.0);\n        scale += 0.5 + sin(iTime/3.0);\n        color = getNoise(point, scale) * vec3(1.0);\n        #else\n        color = (0.9*getDiffuse(point, normal)+0.1)*vec3(1.0);\n        #endif\n    }\n    \n    //Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n//=====================================================================\n//Usual raymarching stuff:\n\nfloat sdfSphere(vec3 point, float radius ) {\n    return length(point) - radius;\n}\n\nfloat sdfBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat Map(vec3 point){\n    #ifdef TEST_CUBE\n    float theta = iTime / 2.0;\n    mat3 rot = mat3(cos(theta), 0.0, -sin(theta),\n                    0.0,        1.0,  0.0,\n                    sin(theta), 0.0,  cos(theta));\n    vec3 q = rot * point;\n    return sdfBox(q, vec3(0.70));\n    #else\n    float scale = 2.0 + sin(iTime/3.0);\n    return sdfSphere(point, 1.0) - 0.3*getNoise(point, scale);\n    #endif\n}\n\nfloat March(vec3 origin, vec3 direction){\n    float total_dist = 0.0;\n    float current_dist;\n    for (int i=0; i<MAX_MARCH_STEPS; i++){\n        current_dist = Map(origin + total_dist * direction);\n        if (current_dist < MIN_MARCH_DIST){\n            return total_dist;\n        }\n        total_dist += current_dist;\n        if (total_dist >= MAX_MARCH_DIST){\n            return MAX_MARCH_DIST;\n        }\n        \n    }\n    return total_dist;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 point ){\n    const float h = 0.0001; \n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*Map( point + k.xyy*h ) + \n                      k.yyx*Map( point + k.yyx*h ) + \n                      k.yxy*Map( point + k.yxy*h ) + \n                      k.xxx*Map( point + k.xxx*h ) );\n}\n\nfloat getDiffuse(vec3 point, vec3 normal){\n    vec3 sun_dir = normalize(vec3(1.0, 1.0, -1.0));\n    return saturate( dot(sun_dir, normal) );\n    //return lorentz(point.z, 2.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Number of tiles in a single row/column of the atlas\n#define TILES 5.0\n\nfloat saturate (float x) {return clamp(x, 0.0, 1.0);}\nfloat lorentz (float x, float a) {return 1.0/(1.0 + a*x*x);}\n\n//===================================================\n//Biquadratic interpolation from here: https://www.shadertoy.com/view/wtXXDl\n\n//This bit is supposed to prevent artifacts caused by sampling adjacent textures\nvoid restrict_to_tile(inout vec2 uv, vec2 tile){\n    uv.x = uv.x - floor(TILES*uv.x)/TILES + tile.x/TILES;  \n    uv.y = uv.y - floor(TILES*uv.y)/TILES + tile.y/TILES;\n}\n\nvec4 sample_biquadratic(sampler2D channel, vec2 res, in vec2 uv, vec2 tile) {\n    restrict_to_tile(uv, tile);\n\n    vec2 q = fract(uv * res);\n    vec2 c = (q*(q - 1.0) + 0.5) / res;\n    vec2 w0 = uv - c;\n    vec2 w1 = uv + c;\n    \n    restrict_to_tile(w0, tile);\n    restrict_to_tile(w1, tile);\n    \n    \n    vec4 s = texture(channel, vec2(w0.x, w0.y))\n    \t   + texture(channel, vec2(w0.x, w1.y))\n    \t   + texture(channel, vec2(w1.x, w1.y))\n    \t   + texture(channel, vec2(w1.x, w0.y));\n\treturn s / 4.0;\n}\n\n\n//=====================================================\n//ALL NOISE FUNCTIONS TAKEN FROM HERE: https://www.shadertoy.com/view/3dVXDc\n\n// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\n// Tileable 3D worley noise\nfloat worleyNoise(vec3 uv, float freq)\n{    \n    vec3 id = floor(uv);\n    vec3 p = fract(uv);\n    \n    float minDist = 10000.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            for(float z = -1.; z <= 1.; ++z)\n            {\n                vec3 offset = vec3(x, y, z);\n            \tvec3 h = hash33(mod(id + offset, vec3(freq))) * .5 + .5;\n    \t\t\th += offset;\n            \tvec3 d = p - h;\n           \t\tminDist = min(minDist, dot(d, d));\n            }\n        }\n    }\n    \n    // inverted worley noise\n    return 1. - minDist;\n}\n\n// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n// chapter in GPU Pro 7.\nfloat worleyFbm(vec3 p, float freq)\n{\n    return worleyNoise(p*freq, freq) * .625 +\n        \t worleyNoise(p*freq*2., freq*2.) * .25 +\n        \t worleyNoise(p*freq*4., freq*4.) * .125;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 res;\n    \n    if (iFrame < 1){\n        res = iResolution;\n    }\n    \n    //Generate texture atlas once per resolution change:\n    if (iFrame<1 || res != iResolution) {\n        res = iResolution;\n        vec2 ts = TILES*mod(uv, 1.0/TILES);\n    \n        float x = floor(TILES*uv.x), y = floor(TILES*uv.y);\n        float n = TILES*x+y;\n        float depth = n / (TILES * TILES);\n    \n        vec3 color = vec3(0.0);\n        color = worleyFbm(vec3(ts, depth), 8.0) * vec3(1.0);\n    \n        fragColor = vec4(color, 1.0);\n    }\n    \n    //Reuse data:\n    else {\n        \n        fragColor = texture(iChannel0, uv);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}