{"ver":"0.1","info":{"id":"fdVBzD","date":"1657805162","viewed":87,"name":"Quadratic solvers","username":"Envy24","description":"Based on this shader: https://www.shadertoy.com/view/fsB3Wt\nFormulas for factoring terms: https://www.desmos.com/calculator/uh9mtw2wiw","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","quadratic","newton","raphson","halley","numeric","secant","regulafalsi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  6.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat quadratic(vec2 NDC, float a, float b, float c)\n{\n    float df   = NDC.y - ((a * NDC.x  + b) * NDC.x + c),\n          dfdx = a * 2.0 * NDC.x + b;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            2.*TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5)) :\n            2.*TO_CENTERED_NDC(SC);\n\n    //float a = 1., b = 0., c = -1.;\n    /* Quadratic */\n    float a = sinOSC(-1.25, 1.25, iTime * 0.15), b = sinOSC( -2.0,  2.0, iTime * 0.6), c = sinOSC( -1.0,  1.0, iTime * 0.45);\n    /* Linear *\n    float a =                               0.0, b = sinOSC( -2.0,  2.0, iTime * 0.6), c = sinOSC( -1.0,  1.0, iTime * 0.45);\n    /* Identity 0 == 0 *\n    float a =                               0.0, b =                              0.0, c =                               0.0;\n    /**/\n\n    /**/\n    // Cauchy's bounds\n    float upper_bound = max(0.0, 1.0 + max(-a/a, max(-b/a, -c/a)));\n    float lower_bound = max(0.0, 1.0 + max( a/a, max( b/a,  c/a)));\n\n    vec3 color = (NDC.x <= upper_bound && NDC.x >= -lower_bound) ? vec3(.9,.9,.9) : vec3(1.);\n         color -= quadratic(NDC, a, b, c);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    vec2 roots[2];\n    \n    // Non-numeric solvers.\n    int num = solve2(roots, a, b, c);\n    \n    // Numeric solvers.\n    //int num = solve2n(roots, a, b, c);\n\n    for (int r=0; r < num; ++r) \n    {\n        float x = roots[r].x;\n        color = mix(color, vec3(1, 0, 0), SM(diskSDF_L2(NDC, vec2(x, 0.0), 0.03)));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}  \n\n/*\n    Return value:\n        0 - two complex roots;\n        1 - one real root, but root[0] == root[1];\n        2 - two real roots;\n*/\nint solveQuadratic(\n    inout vec2[2] roots,\n    float a, float b, float c)\n{\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0)\n    {\n        float INVa = 1.0 / (2. * a);\n        float SQRT = sqrt(-discriminant);\n\n        roots[0].x = -b * INVa; roots[0].y = SQRT * INVa;\n        roots[1].x = -b * INVa; roots[1].y = -SQRT * INVa;\n\n        return 0;\n    }\n\n    if (discriminant == 0.0)\n    {\n        float Re = -b / (2. * a);\n\n        roots[0].x = Re; roots[0].y = 0.0;\n        roots[1].x = Re; roots[1].y = 0.0;\n\n        return 1;\n    }\n\n    float INVa = 1.0 / (2. * a);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - b) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-b - SQRT) * INVa; roots[1].y = 0.0;\n\n    return 2;\n}\n\nint solveQuadraticForReal2(\n    inout vec2[2] roots,\n    float a, float b, float c)\n{\n    float discriminant = b * b - 4.0 * a * c;\n    float INVa = 1.0 / (2. * a);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - b) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-b - SQRT) * INVa; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n// source: https://www.youtube.com/watch?v=ok0EZ0fBCMA\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    float a, float b, float c)\n{\n    float discriminant = b * b - 4.0 * a * c;\n    float sqrt_D = sqrt(discriminant);\n    float sign_b = b >= 0.? 1. : -1.;\n    roots[1].x = -(b + sign_b*sqrt_D) / (2.*a);\n    roots[0].x = -(2.*c) / (b+sign_b*sqrt_D);\n    \n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n// explanation: https://www.youtube.com/watch?v=7gJdMEIBGSg\nint solveQuadraticPoShenLoh(\n    inout vec2[2] roots,\n    float a, float b, float c)\n{\n    float B = b / a, C = c / a,\n          M = -B * 0.5,\n          U = sqrt(M*M - C);\n\n    roots[0].x = M - U; roots[0].y = 0.0;\n    roots[1].x = M + U; roots[1].y = 0.0;\n    \n    return 2;\n}\n\n/* \n    Returns number of real roots.       \n*/\nint solve2(\n    inout vec2[2] roots,\n    float a, float b, float c)\n{\n    // Quadratic equation?\n    if (a != 0.0)\n    {\n        //return solveQuadratic(roots, coef);\n        return solveQuadraticForReal(roots, a, b, c);\n        //return solveQuadraticPoShenLoh(roots, a, b, c);\n    }\n\n    // Linear equation?\n    if (b != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -c/b; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (c == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}\n\n/* Numeric solvers. */\nfloat findQuadraticRootNewtonRaphson(\n    float x, float a, float b, float c)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float dfdx = 2. * a * x + b;\n    bool quit = abs(dfdx) <= EPSILON;\n    \n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {\n        float f = (a * x + b) * x + c;\n        x -= f / dfdx;          \n        dfdx = 2. * a * x + b;\n        quit = (abs(f) <= tolerance) || (abs(dfdx) <= EPSILON);\n    }\n\n    return x;\n}\n\nfloat findQuadraticRootHalley(\n    float x, float a, float b, float c)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float f = (a * x + b) * x + c;\n    float dfdx = 2. * a * x + b;\n    float ddfddx = 2. * a;\n    float denom = 2.*dfdx*dfdx - f * ddfddx;\n    bool quit = abs(denom) <= EPSILON;\n    \n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {       \n        x -= (2.*f*dfdx) / denom;\n        \n        f = (a * x + b) * x + c;\n        dfdx = 2. * a * x + b;\n        ddfddx = 2. * a;\n        denom = 2.*dfdx*dfdx - f * ddfddx;\n        \n        quit = (abs(f) <= tolerance) || (abs(denom) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuadraticRootBisection(\n    float xl, float xr, float a, float b, float c)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (a * xl + b) * xl + c,  // f(xl)\n        (a * xr + b) * xr + c); // f(xr)\n        \n    float f = 0.5;\n        \n    for (int i = 0; (i < 10) && (abs(f) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float x = X[0] + (X[1] - X[0]) * 0.5;\n              f = (a * x + b) * x + c;\n\n        int w_idx = int(sign(F[0]) != sign(f));\n        \n        F[w_idx] = f; X[w_idx] = x;\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\nfloat findQuadraticRootHybrid(\n    float xl, float xr, float a, float b, float c)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (a * xl + b) * xl + c,  // f(xl)\n        (a * xr + b) * xr + c); // f(xr)\n       \n    float x = 0.0, f = 0.0;\n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {\n        x = (X[0] * F[1] - X[1] * F[0]) / (F[1] - F[0]);\n        f = (a * x + b) * x + c;\n    \n        int w_idx = int(abs(f - F[0]) < abs(f - F[1]));\n\n        F[w_idx] = f; X[w_idx] = x;\n\n        quit = (abs(f) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuadraticRootRegulaFalsi(\n    float xl, float xr, float a, float b, float c)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (a * xl + b) * xl + c,   // f(xl)\n        (a * xr + b) * xr + c ); // f(xr)\n\n    float x = 0.0, f = 0.0;\n\n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        x = X[0] -  F[0] * ((X[1] - X[0]) / (F[1] - F[0]));\n        f = (a * x + b) * x + c;\n\n        int w_idx = int(f * F[1] > 0.);\n\n        F[w_idx] = f; X[w_idx] = x;\n\n        quit = (abs(f) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return x;\n}\n/* Numeric solvers. */\n\n/* \n    Returns number of real roots.       \n*/\nint solve2n(\n    inout vec2[2] roots,\n    float a, float b, float c)\n{\n    // Quadratic equation?\n    if (a != 0.0)\n    {\n        // No real roots?\n        if (b * b - 4.0 * a * c < 0.0) { return 0; }\n    \n        // Find first root.\n        //roots[0].x = findQuadraticRootNewtonRaphson(0.01, a, b, c);\n        //roots[0].x = findQuadraticRootSecant(0.01, a, b, c);\n        //roots[0].x = findQuadraticRootBisection(-1.0, 1.0, a, b, c);\n        roots[0].x = findQuadraticRootRegulaFalsi(-4.1, 4., a, b, c);\n        //roots[0].x = findQuadraticRootHalley(0.01, a, b, c);\n        //roots[0].x = findQuadraticRootHybrid(-4.1, 4.0, a, b, c);\n\n        // Conver equation to form: (x-r0)(a0*x+b0)=0\n        float a0 = a;\n        float b0 = b + a * roots[0].x;\n        \n        // Solver linear term for second root.\n        roots[1].x = -b0/a0;\n\n        return 2;\n    }\n\n    // Linear equation?\n    if (b != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -c/b; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (c == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}","name":"Common","description":"","type":"common"}]}