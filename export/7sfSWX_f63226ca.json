{"ver":"0.1","info":{"id":"7sfSWX","date":"1619328560","viewed":134,"name":"twisting tori","username":"johnowhitaker","description":"Messing with signed distance functions trying to replicate something like https://observablehq.com/@makio135/ouroboros \nLooks a little glitchy in places due to my hacky height-adjusting code.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sdf","ouroboros"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// For ray marching:\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// FROM https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// From ??\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t0.0,                                0.0,                                0.0,                                1.0\n\t);\n}\n\n// They key SDF\nfloat weirdTorus( vec3 p, vec2 t, float time_offset)\n{\t\n    \n    // Varying width based on angle\n    float angle = acos(dot(normalize(p.xz), normalize(vec2(sin(iTime+time_offset), cos(iTime+time_offset)))));\n    float width = -0.018 + t.y*abs(sin(angle*1.5));\n    \n    // Mess with height\n    float static_angle = acos(dot(normalize(p.xz), normalize(vec2(0., 1.))));\n    p.y += 0.06*cos(static_angle*4.); // These values need tweaking...\n    p.x += 0.06*cos(static_angle*3.14);\n\n    \n    // Torus:\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-width;\n}\n\n\n\n// Three together with some rotation between them \nfloat sceneSDF(vec3 samplePoint) { \n\n    samplePoint *= 0.7;\n\n    // Rotate viewing angle\n    samplePoint = (rotation3d(vec3(0.4,0.,0.1), 0.5)*vec4(samplePoint, 0.)).xyz;\n    \n    // The first twisty torus\n    float t1 = weirdTorus(samplePoint, vec2(0.4,0.050),  0.);\n    \n    // Rotate and add a second one then a third\n    samplePoint = (rotation3d(vec3(0., 1., 0.), 0.3)*vec4(samplePoint, 0.)).xyz;\n    float t2 = weirdTorus(samplePoint, vec2(0.4, 0.05), 0.);\n    samplePoint = (rotation3d(vec3(0., 1., 0.), 0.3)*vec4(samplePoint, 0.)).xyz;\n    float t3 = weirdTorus(samplePoint, vec2(0.4, 0.05), 0.);\n    \n    // Combine and return the final distance\n    return min(t1, min(t2, t3));\n\n}\n\n// Ray marching stuff from https://www.shadertoy.com/view/llt3R4\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\n// Generating the final image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 dir = rayDirection(0.298 * 100., iResolution.xy, fragCoord.xy);\n    vec3 eye = vec3(0., 0, 5.); // Can edit this to move based on mouse position for interactivity\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.4, 0.2, 0.3, 0.5);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    // An estimated normal\n    vec3 n = estimateNormal(p);\n    \n    // Lighting - fake image based lighting as shown in https://www.youtube.com/watch?v=FilPE91ACOA&t=1s\n    vec3 color = vec3(pow(length(sin(n*2.)*.5+.5)/sqrt(3.), 2.));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}