{"ver":"0.1","info":{"id":"XcyXDc","date":"1715834793","viewed":104,"name":"Pencil Mordor","username":"jKubitschek","description":"Fbm terrain with interesting color scheme and theme","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["terrain","fbm","stylized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// hashes are hash without sine from https://www.shadertoy.com/view/XlGcRh\n\nvec3 hash133(vec3 p3) { //hash without sine, \n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3) {  // same as other hashes\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define HD_INTERP 1\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    #if HD_INTERP==1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #endif    \n    \n    float va = hash12( i + vec2(0.0,0.0) );\n    float vb = hash12( i + vec2(1.0,0.0) );\n    float vc = hash12( i + vec2(0.0,1.0) );\n    float vd = hash12( i + vec2(1.0,1.0) );\n    \n    float k0 = va;\n    float k1 = vb - va;\n    float k2 = vc - va;\n    float k4 = va - vb - vc + vd;\n\n    return vec3( va+(vb-va)*u.x+(vc-va)*u.y+(va-vb-vc+vd)*u.x*u.y, // value\n                 du*(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va) );     // derivative                \n}\n#define NUM_OCT_F_H 16\nvec3 fbmg_h(vec2 x, float time) { // taken from iq\n    //float G = exp2(-H);\n    vec2 st = (x - 0.4*time*vec2(1., 1.))*0.6;\n    float f = 0.4;\n    float a = 1.0;\n    float t = 0.0;\n    vec3 n = vec3(0.);\n    vec2 d = vec2(1.);\n\n    for (int i = 0; i < NUM_OCT_F_H; ++i) {\n        float ang = hash11(float(i));\n        float co = cos(ang);\n        float si = sin(ang);\n        mat2 rot = mat2( co, -si,\n                si, co);\n        n = noised(f*rot*st);\n        d += n.yz; // not actually the derivative, but prettier picture\n        t += a*n.x * 1./(1.0 + dot(d, d));\n        f *= 2.0;\n        //a *= G;\n        a *= 0.5;\n    }\n    return 4.0*vec3(t + 0.1, d);\n}\n\n#define NUM_OCT_F 8\nvec3 fbmg(vec2 x, float time) { // taken from iq\n    //float G = exp2(-H);\n    vec2 st = (x - 0.4*time*vec2(1., 1.))*0.6;\n    float f = 0.4;\n    float a = 1.0;\n    float t = 0.0;\n    vec3 n = vec3(0.);\n    vec2 d = vec2(1.);\n\n    for (int i = 0; i < NUM_OCT_F; ++i) {\n        float ang = hash11(float(i));\n        float co = cos(ang);\n        float si = sin(ang);\n        mat2 rot = mat2( co, -si,\n                si, co);\n        n = noised(f*rot*st);\n        d += n.yz; // not actually the derivative, but prettier picture\n        t += a*n.x * 1./(1.0 + dot(d, d));\n        f *= 2.0;\n        //a *= G;\n        a *= 0.5;\n    }\n    return 4.0*vec3(t + 0.1, d);\n}\n\n#define NUM_OCT_F_Q 3\nvec3 fbmg_q(vec2 x, float time) { // taken from iq\n    //float G = exp2(-H);\n    vec2 st = (x - 0.4*time*vec2(1., 1.))*0.6;\n    float f = 0.4;\n    float a = 1.0;\n    float t = 0.0;\n    vec3 n = vec3(0.);\n    vec2 d = vec2(1.);\n\n    for (int i = 0; i < NUM_OCT_F_Q; ++i) {\n        float ang = hash11(float(i));\n        float co = cos(ang);\n        float si = sin(ang);\n        mat2 rot = mat2( co, -si,\n                si, co);\n        n = noised(f*rot*st);\n        d += n.yz; // not actually the derivative, but prettier picture\n        t += a*n.x * 1./(1.0 + dot(d, d));\n        f *= 2.0;\n        //a *= G;\n        a *= 0.5;\n    }\n    return 4.0*vec3(t + 0.1, d);\n}\n\n#define NUM_OCT_F_QQ 1\nvec3 fbmg_qq(vec2 x, float time) { // taken from iq\n    //float G = exp2(-H);\n    vec2 st = (x - 0.4*time*vec2(1., 1.))*0.6;\n    float f = 0.4;\n    float a = 1.0;\n    float t = 0.0;\n    vec3 n = vec3(0.);\n    vec2 d = vec2(1.);\n\n    for (int i = 0; i < NUM_OCT_F_QQ; ++i) {\n        float ang = hash11(float(i));\n        float co = cos(ang);\n        float si = sin(ang);\n        mat2 rot = mat2( co, -si,\n                si, co);\n        n = noised(f*rot*st);\n        d += n.yz; // not actually the derivative, but prettier picture\n        t += a*n.x * 1./(1.0 + dot(d, d));\n        f *= 2.0;\n        //a *= G;\n        a *= 0.5;\n    }\n    return 4.0*vec3(t + 0.1, d);\n}\n\n\n#define NUM_OCT_S 6\nvec3 fbms(vec2 x) { // taken from iq\n    //float G = exp2(-H);\n    vec2 st = (x - 0.4*iTime*vec2(1., 1.))*0.6;\n    float f = 0.4;\n    float a = 1.0;\n    float t = 0.0;\n    vec3 n = vec3(0.);\n    vec2 d = vec2(1.);\n\n    for (int i = 0; i < NUM_OCT_F; ++i) {\n        float ang = hash11(float(i));\n        float co = cos(ang);\n        float si = sin(ang);\n        mat2 rot = mat2( co, -si,\n                si, co);\n        n = noised(f*rot*st);\n        d += n.yz; // not actually the derivative, but prettier picture\n        float m = 1./(1.0 + dot(d,d));\n        t += a*n.x * m;\n        f *= 2.0;\n        //a *= G;\n        a *= 0.5;\n    }\n    return 4.0*vec3(t + 0.1, d);\n}\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 map(vec3 p, float time) {\n    vec2 g = vec2(0.);\n    g = vec2(p.y - fbmg(p.xz, time).x, 1.0);\n\n    //vec2 c = vec2(p.y - fbmc(p.xz).x + 2., 2.0);\n\n    //return opU(g, c);\n    return g;\n}\n\nvec3 normal(vec2 p, float t, float time) {\n    vec2 e = vec2(0.001 * max(1.0, t), 0.0);\n    return normalize(vec3(fbmg_h(p + e.xy, time).x - fbmg_h(p - e.xy, time).x,\n                            2.0*e.x,\n                          //map(p + e.yxy).x - map(p - e.yxy).x,\n                          fbmg_h(p + e.yx, time).x - fbmg_h(p - e.yx, time).x ));\n}\n\n#define LANG -0.35\n#define CL (0.9393727)\n#define SL (-0.342898)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = 2.0*(fragCoord)/iResolution.x - vec2(1.0);\n    float mo = 2. * iMouse.x / iResolution.x - 1.;\n    if( iMouse.z<=0.00001 ) mo=0.0;\n    float time = 50.*mo + iTime + 21.;\n\n\n    vec3 ro = vec3(0.0); ro.y = fbmg_q(ro.xz, time).x + 1.2;\n    vec3 look = normalize(vec3(coord, -1.0 + 0.1*sin(time) + 0.1*cos(time)));\n    \n    //float cl = cos(LANG);\n    //float sl = sin(LANG);\n    mat3 rm = mat3( 1, 0, 0, \n                    0, CL, SL,\n                    0, -SL, CL );\n    //look *= rm;\n    // calculate all this explicitly\n    //vec3 look = vec3(0. , 0.342898, -0.939373);\n\n    // mouse inputs\n\n    float ang = time * 0.1;\n    float co = cos(ang);\n    float si = sin(ang);\n    mat3 rot = mat3( co, 0, -si,\n            0, 1, 0,\n            si, 0, co);\n    look *= rm*rot;\n\n    vec3 skyblue = vec3(0.01, 0.48, 0.89);\n    vec3 brown = 0.85*vec3( 0.65, 0.47, 0.29 );\n    vec3 col = vec3(0.);\n\n    vec2 t = vec2(0.0);\n    for (int throw = 0; throw < 100; ++throw) { // number of marches\n\n        if (t.x > 40.0) { // gone too far, don't bother, give up search\n            t.y = 0.0;\n            break;\n        }\n\n        vec3 pos = ro + t.x*look;\n\n        vec2 h = map(pos, time);\n\n        if (h.x < 0.001) {\n            break;\n        }\n\n        t = vec2( t.x + 0.3 * h.x, h.y );\n    }\n\n    if (t.y == 1.) {\n        //col = vec3(0.14);\n        vec3 n = normal(ro.xz + t.x*look.xz, t.x, time);\n        col = vec3(0.14) * dot(n, normalize(vec3( 0 , .5 , .8 )));\n        float edgeC = dot(n, normalize(vec3( 1., 0., 0.)) );\n        col = mix( col, vec3(1.0), abs( dot(n, normalize(vec3( 1., 0., 0.)) )) );\n    } else {    \n        col = mix( vec3(1.0), vec3(0.4), abs(fbms(coord * (1. + 0.25*fbms(coord).x)).x - 1.5) );\n    }\n    //col = vec3(abs(coord.y) );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}