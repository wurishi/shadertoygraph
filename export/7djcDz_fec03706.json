{"ver":"0.1","info":{"id":"7djcDz","date":"1644408373","viewed":230,"name":"PBR Homework","username":"Xia","description":"references: https://learnopengl.com/PBR/IBL/Specular-IBL","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["ibl","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float FOV = 90.0;\nconst float PI = 3.14159265359;\nconst vec3 albedo = vec3(1.0, 0.0, 0.0);\nconst float ao = 1.0;\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdScene(vec3 p)\n{\n    \n    return sdSphere(p - vec3(0.0, 0.0, 0.0), 1.0);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float start)\n{  \n    float depth = start;\n   \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * depth;\n        float dist = sdScene(p);\n        depth += dist;\n        \n        if(depth > MAX_DIST || dist < EPSILON) break;\n    }\n    \n    return depth;\n}\n\nvec3 RayDir(float fieldOfView, vec2 size, vec2 fragCoord) \n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 GetWorldNormal(vec3 p)\n{\n    float d = sdScene(p);\n   \n    vec3 n = d - vec3(\n       sdScene(p - vec3(EPSILON, 0, 0)),\n       sdScene(p - vec3(0, EPSILON, 0)),\n       sdScene(p - vec3(0, 0, EPSILON)));\n      \n    return normalize(n);\n}\n\nmat4 viewMatrix(vec3 ro, vec3 lookat, vec3 up) \n{\n    vec3 f = normalize(lookat - ro);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(0.0, dot(N, H));\n    float NdotH2 = NdotH * NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat RadicalInverse_VdC(uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i) / float(N), RadicalInverse_VdC(i));\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness*  roughness;\n\t\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\t\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\t\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(0.0, dot(N, V));\n    float NdotL = max(0.0, dot(N, L));\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}   \n\nvec3 DirectLighting(vec3 P, vec3 N, vec3 ro, float metallic, float roughness)\n{\n    vec3 LightPos = vec3(1.5, 1.5, 0.5);\n    vec3 LightColor = vec3(10.0, 10.0, 10.0);\n    \n    N = normalize(N);\n    vec3 V = normalize(ro - P);\n    \n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, albedo, metallic);\n    \n    vec3 L = normalize(LightPos - P);\n    vec3 H = normalize(V + L);\n    float distance = length(LightPos - P);\n    float attenuation = 1.0 / (distance * distance);\n    vec3 radiance = LightColor * attenuation;\n\n    float NDF = DistributionGGX(N, H, roughness);   \n    float G   = GeometrySmith(N, V, L, roughness);      \n    vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0);\n           \n    vec3 numerator    = NDF * G * F; \n    float denominator = 4.0 * max(0.0, dot(N, V)) * max(0.0, dot(N, L)) + 0.0001;\n    vec3 specular = numerator / denominator;\n        \n    vec3 kS = F;\n    \n    vec3 kD = vec3(1.0) - kS;\n    \n    kD *= 1.0 - metallic;\t  \n\n    float NdotL = max(0.0, dot(N, L));        \n\n    vec3 Lo = (kD * albedo / PI + specular) * radiance * NdotL;\n\n    return Lo;\n}\n\n// Irradiance Map\nvec3 Irradiance(vec3 N)\n{\n    N = normalize(N);\n\n    vec3 irradiance = vec3(0.0);   \n    \n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, N));\n    up         = normalize(cross(N, right));\n       \n    float sampleDelta = 0.5;\n    float nrSamples = 0.0f;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; \n            irradiance += texture(iChannel0, sampleVec).rgb * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n    return irradiance;\n\n}\n// Pre-filtered Environment Map\nvec3 Prefilter(vec3 N, float roughness)\n{\n    N = normalize(N);\n    \n    vec3 R = N;\n    vec3 V = R;\n\n    const uint SAMPLE_COUNT = 32u;\n    vec3 prefilteredColor = vec3(0.0);\n    float totalWeight = 0.0;\n    \n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(0.0, dot(N, L));\n        if(NdotL > 0.0)\n        {\n            float D   = DistributionGGX(N, H, roughness);\n            float NdotH = max(0.0, dot(N, H));\n            float HdotV = max(0.0, dot(H, V));\n            float pdf = D * NdotH / (4.0 * HdotV) + 0.0001; \n\n            float resolution = 512.0;\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n\n            float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n            \n            prefilteredColor += textureLod(iChannel0, L, mipLevel).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n\n    prefilteredColor = prefilteredColor / totalWeight;\n    \n    return prefilteredColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 viewrd = RayDir(FOV, iResolution.xy, fragCoord);\n    vec3 ro = vec3(3.5 * sin(iTime * 0.2), 0.5, -3.5* cos(iTime * 0.2));\n    vec3 lookat = vec3(0.0);\n    \n    vec3 rd = (viewMatrix(ro, lookat, vec3(0.0, 1.0, 0.0)) * vec4(viewrd, 0.0)).xyz;\n    \n    float dist = RayMarch(ro, rd, MIN_DIST);\n    \n    vec3 P = ro + rd * dist;\n    vec3 N = GetWorldNormal(P);\n    \n    vec3 V = normalize(vec3(ro - P));\n    vec3 R = reflect(-V, N);\n    \n    // metallic and rounghness\n    float metallic = 0.0;\n    float roughness = 0.0;\n    \n    vec3 Lo = DirectLighting(P, N, ro, metallic, roughness);\n    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metallic);\n    \n    vec3 F = fresnelSchlickRoughness(max(0.0, dot(N, V)), F0, roughness);\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\t  \n    vec3 irradiance = Irradiance(N);\n    vec3 diffuse      = irradiance * albedo;\n    \n    vec3 prefilteredColor = Prefilter(R, roughness);\n    vec2 brdf  = texture(iChannel1, vec2(max(0.0, dot(N, V)), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * brdf.x + brdf.y) * 0.7;\n\n    vec3 ambient = (kD * diffuse + specular) * ao;\n    vec3 color = vec3(0.0);\n    \n    color = ambient + Lo;\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0 / 2.2)); \n    \n    if (dist > MAX_DIST - EPSILON) \n    {\n        color = texture(iChannel0, rd).rgb;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Specular BRDF Integration Map\n\nconst float PI = 3.14159265359;\n\nfloat RadicalInverse_VdC(uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n\treturn vec2(float(i) / float(N), RadicalInverse_VdC(i));\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n\tfloat a = roughness * roughness;\n\t\n\tfloat phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\n\tvec3 H;\n\tH.x = cos(phi) * sinTheta;\n\tH.y = sin(phi) * sinTheta;\n\tH.z = cosTheta;\n\t\n\tvec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\tvec3 tangent   = normalize(cross(up, N));\n\tvec3 bitangent = cross(N, tangent);\n\t\n\tvec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\treturn normalize(sampleVec);\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(0.0, dot(N, V));\n    float NdotL = max(0.0, dot(N, L));\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0; \n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    \n    const uint SAMPLE_COUNT = 64u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(0.0, L.z);\n        float NdotH = max(0.0, H.z);\n        float VdotH = max(0.0, dot(V, H));\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 integratedBRDF = IntegrateBRDF(uv.y, uv.x);\n   \tfragColor = vec4(integratedBRDF, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}