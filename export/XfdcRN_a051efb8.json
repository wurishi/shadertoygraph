{"ver":"0.1","info":{"id":"XfdcRN","date":"1730331559","viewed":79,"name":"Primitive Pythagorean Tripletree","username":"rikr","description":"Primitive Pythagorean Tripletree By Rik Riesmeijer, I was interested in experimenting with this, so I thought I would share this fun stuff for all to tinker around with.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["experiment","primitives","tree","rotation","rotation","float","primitive","pythagorean","coprimes","triple","pythagoreantriples","trinary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tree Of Primitive Pythagorean Triples.\n// Made By Rik Riesmeijer - No Righst Reserved (CC0).\nvoid mainImage(out vec4 c, vec2 v) {\n    // Normalize coordinates.\n    v = 124.3 * v / iResolution.yy;\n    \n    // As shown in: https://en.wikipedia.org/wiki/Tree_of_primitive_Pythagorean_triples\n    // 1.) The Barning Trinary Tree:\n    //      + This tree is given by 3x3 matrices to transform into\n    //        each one of the three branches at a given triple in the tree.\n    //      + This tree is rooted at the a well known primitive pythagorean triple,\n    //        namely at (4, 3, 5) where 4^2 + 3^2 = 5^2 and thus (0.8, 0.6) is a unit\n    //        vector of the 2d plane. (Often used as neat trick for easy rotations.)\n    //      + This tree can be shown to contain all possible pythagorean triples, see source.\n    //      + This tree can be shown to only contain primitive pythagorean triples.\n    //      + The dynamics of A, B and C can be shown to be somewhat predictable for\n    //        predictable circumstances.\n    //      + The dynamics of A, B and C can be shown to be infinitely unpredictable for\n    //        equally suited unpredictable choices of tree traversal dynamic.\n    //      + This tree could be suited as a higher dimensional continuation of\n    //        irreducible element enumeration in an intuitive (Euclidean) domain,\n    //        one of which is the binary tree of coprime numbers, called the Stern-Brocot tree.\n    //      + A, B and C are as follows:\n    vec3 root;\n    root = vec3(4.0, 3.0, 5.0);\n    mat3 A, B, C;\n    A = mat3( 1.0, -2.0,  2.0,\n              2.0, -1.0,  2.0,\n              2.0, -2.0,  3.0);\n    B = mat3( 1.0,  2.0,  2.0,\n              2.0,  1.0,  2.0,\n              2.0,  2.0,  3.0);\n    C = mat3(-1.0,  2.0,  2.0,\n             -2.0,  1.0,  2.0,\n             -2.0,  2.0,  3.0);\n             \n    // 2.) Equivalently we can give other A, B and C as 2x2 matrices in a different tree based on:\n    //     i  ) a = m^2 - n^2,\n    //     ii ) b = 2mn,\n    //     iii) c = m^2 + n^2.\n    //     This gives the following setup (more similar to the aforementioned Stern-Brocot tree):\n    mat2 AA, BB, CC;\n    AA = mat2(2.0, -1.0,\n              1.0,  0.0);\n    BB = mat2(2.0,  1.0,\n              1.0,  0.0);\n    CC = mat2(1.0,  2.0,\n              0.0,  1.0);\n              \n    // 3.) Price Tree: finally, as mentioned by the above source article. Taking perhaps some other\n    //     primitive pythagorean triple as its root, we can also make a different choice for\n    //     the first matrix configuration of A, B and C given by Price, transscribed here as follows:\n    vec3 root1;\n    root1 = vec3(5.0, 12.0, 13.0);\n    mat3 AAA, BBB, CCC;\n    AAA = mat3( 2.0,  1.0, -1.0,\n               -2.0,  2.0,  2.0,\n               -2.0,  1.0,  3.0);\n    BBB = mat3( 2.0,  1.0,  1.0,\n                2.0, -2.0,  2.0,\n                2.0, -1.0,  3.0);\n    CCC = mat3( 2.0, -1.0,  1.0,\n                2.0,  2.0,  2.0,\n                2.0,  1.0,  3.0);\n                \n    // Some experiments I'm doing, feel free to share anything cool you yourself find in the way of it.\n    int branchchoice = int(1) % 3;\n    int maxiteration = 15 - (int(iTime * 3.0) % 14);\n    int iterationcount = 0;\n    while(min(v.x, v.y) > 12.0 && iterationcount < maxiteration) {\n        if(v.x < v.y) {\n            v = v.yx;\n            branchchoice += 1;\n        }\n        v = vec2(v.x / 1.5, v.y - 2.0);\n        if(branchchoice == 0) {\n            root  = A   * root;\n            root1 = AAA * root1;\n        }\n        if(branchchoice == 1) {\n            root  = B   * root;\n            root1 = BBB * root1;\n        }\n        if(branchchoice == 2) {\n            root  = C   * root;\n            root1 = CCC * root1;\n        }\n        iterationcount++;\n    }\n\n    // Mess with UVs rotationally using outcome of first tree with color of second.\n    root = root / root.z;\n    v = mat2(root.x, -root.y, root.xy) * v;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*sin(iTime+v.xyx);\n\n    // Output to screen\n    c = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}