{"ver":"0.1","info":{"id":"stVGWy","date":"1638284274","viewed":243,"name":"Rope function","username":"miczac","description":"This is a proof of concept demonstration of a rope function based on catmullrom spline interpolation, using stored values in a buffer.\nThere is a deformation that I am not sure how to avoid, when points move fast the rope gets skinnier...","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["animation","texturing","rope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DATA iChannel0\n#define TEXT iChannel1\n\n//keep track of transformed space for texturing\nvec3 p_transform = vec3(0);\n//h is the normalized index of\n//the point on the rope (0 -> head, 1 -> tail) \nfloat h = 0.;\n\nfloat map(vec3 p)\n{\n    // id is row index where position data is stored\n    int id = 1;\n    vec4 cap = getRope(p, id, DATA, ROPE_POINTS, ROPE_LENGTH,ROPE_THICK, h);\n    //save global variables p_tranform and h\n    p_transform = cap.yzw;\n    return cap.x*0.6;\n}\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float min_dist = 0.01;\n    float max_dist = 10.;\n    float d = min_dist;\n    for(int i = 0; i < 80; i++)\n    {\n        vec3 p = ro + rd*d;\n        float cap = map(p);\n        if(d > max_dist || abs(cap) < min_dist) break;\n        d += cap;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if 1 to check how the data is stored\n    #if 0 \n    fragColor = texelFetch(DATA,ivec2(fragCoord*0.05),0);\n    #else\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y*2.;\n    vec3 lookat = vec3(0 ,1.,0);\n    //vec3 ro = vec3(cos(iTime*0.5),0.5,sin(iTime*0.5));\n    vec3 ro = vec3(0,0.5,-2.);\n    mat3 cam = camera(ro, lookat, 0.);\n    vec3 rd = cam * normalize(vec3(uv, 1));\n    float hit = intersect(ro,rd);\n    vec3 col = vec3(0);\n    if(hit < 10.)\n    {\n        vec3 p = ro + rd * hit;\n        //to get texture uv use spherical coordinates\n        //of transformed space for the width and the segment\n        //point (from Rope) for length\n        vec2 pol = polar(p_transform);\n        col = texelFetch(TEXT, ivec2(vec2(pol.x,h)*7.),0).xxx;\n    }\n    fragColor = vec4(col,1.0);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ROPE_POINTS 60\n#define ROPE_LENGTH 1.8\n#define ROPE_THICK 0.1\n\n#define PI 3.14159265358\n\nvec3 slide(vec3 cur, vec3 tar, float sli)\n{\n    vec3 res = mix(cur, tar, sli);\n    return    res;\n}\n\nmat3 camera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 polar(vec3 p)\n{\n   return fract(vec2(atan(p.z, p.x) / 2., atan(p.y, length(p.xz))) / PI + .5);\n}\n\n//spline interpolations from : http://sol.gfxile.net/interpolation/\nvec3 catmullrom(float t, vec3 p0, vec3 p1, vec3 p2, vec3 p3)\n{\n\treturn 0.5 * (\n\t\t\t\t(2. * p1) +\n\t\t\t\t(-p0 + p2) * t +\n\t\t\t\t(2. * p0 - 5. * p1 + 4. * p2 - p3) * t * t +\n\t\t\t\t(-p0 + 3. * p1 - 3. * p2 + p3) * t * t * t\n\t\t\t\t);\n}\n\n\n\nvec3 Rope(vec3 p, int id, in sampler2D text, int num_points, inout float h)\n{\n    float fnum_points = float(num_points);\n    vec3  rope_head   = texelFetch(text, ivec2(0, id ), 0).xyz;\n    vec3  rope_tail   = texelFetch(text, ivec2(num_points, id ), 0).xyz;\n    vec3 pa = p - rope_head, ba = rope_tail - rope_head;\n    h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\n    //pick previous position based on how distant p is from the current position\n    int   point_coo    = int(floor(h*(fnum_points-3.)));\n    float interp_index = fract(h*(fnum_points-3.));\n    vec3  rope_point_0 = texelFetch(text, ivec2(point_coo+0, id ), 0).xyz;\n    vec3  rope_point_1 = texelFetch(text, ivec2(point_coo+1, id ), 0).xyz;\n    vec3  rope_point_2 = texelFetch(text, ivec2(point_coo+2, id ), 0).xyz;\n    vec3  rope_point_3 = texelFetch(text, ivec2(point_coo+3, id ), 0).xyz;\n    vec3  point  = catmullrom(interp_index, rope_point_0, rope_point_1, rope_point_2, rope_point_3);\n    return point;\n}\n\nvec4 getRope(vec3 p, int id, sampler2D text, int rope_points, float len, float thick, inout float h)\n{\n    vec3 point = Rope(p,id,text,rope_points, h);\n    vec3 pp = p;\n    pp -=  point;\n    float dist = length(pp)-ROPE_THICK;\n    //return transformed space for texturing\n    return vec4(dist, pp);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FEEDBACK iChannel0\n\nvec3 rope_anim()\n{\n    return vec3(cos(iTime*2.),0,sin(iTime*0.3))*0.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoo = ivec2(fragCoord);\n    if(any(greaterThan(iCoo, ivec2(ROPE_POINTS,1)))) discard;\n    //save position data in two rows: one for simple non-streteched\n    //values, one with position data plus some added stretch value\n    //given by the ROPE_LENGTH and added to each pixel depending on\n    // its x position: first pixel will be the rope head,\n    //last pixel is rope tail.\n\n    //generate and store position raw data \n    //without any stretch (rope of length 0)\n    if(iCoo.y == 0)\n    {\n        //first pixel in row is current position\n        if(iCoo.x == 0) fragColor.xyz = rope_anim();\n        //save previous positions in following pixels\n        else fragColor.xyz = texelFetch(FEEDBACK, iCoo - ivec2(1,0),0).xyz;\n    }\n    //retrieve stored data and add a stretch value equal to the \n    //rope length * texel.x/ROPE_POINTS. I need to separate these steps otherwise the rope\n    //will keep accumulating stretch values \n    else \n    {\n        vec3 target = texelFetch(FEEDBACK, iCoo - ivec2(0,1),0).xyz;\n        vec3 stretch = vec3(0,float(iCoo.x)/float(ROPE_POINTS)*ROPE_LENGTH, 0);\n        target += stretch;\n        vec3 current = texelFetch(FEEDBACK, iCoo,0).xyz;\n        vec3 res = slide(current, target, 0.8);\n        fragColor.xyz = res;\n    }\n\n\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}