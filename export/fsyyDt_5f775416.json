{"ver":"0.1","info":{"id":"fsyyDt","date":"1655783339","viewed":107,"name":"Lissawho?","username":"daeken","description":"Lissajous fun","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["playing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ntrue =>shadertoy\n\n{\n    @vec2 uniform =iResolution\n    @float uniform =iTime\n    @vec2 varying =fragCoord\n    \n    :m resolution iResolution ;\n    :m time iTime ;\n    fragCoord resolution .xy / 2 * 1 - [ resolution .xy \\/ 1 ] * =real-position\n    \n    :m ->fragColor =fragColor ;\n} {\n    @vec2 uniform =resolution\n    @float uniform =time\n    @vec2 varying =position\n    position 2 / 1 - [ resolution .xy \\/ 1 ] * =real-position\n\n    :m ->fragColor =$gl_FragColor ;\n} shadertoy cif\n\n{ + - * / } //{ (| operator |)\n    { = => } //{ (| assignment |)\n            `{ (| value variable |)\n                        *variable\n                        value\n                    ,operator\n                        &,assignment\n                        variable\n                    concat\n                call\n            }\n            operator assignment concat\n        def-prefix\n    }\n}\n:p min= (| variable |) *variable min &= variable concat call ;\n:p max= (| variable |) *variable max &= variable concat call ;\n\n:m when (| block cond |) block { } cond if ;\n:m cwhen (| block cond |) cond ~*block ;\n\n: smin (| a b k |)\n    k a b - abs - 0 max k / =h\n    a b min [ h h k 1 4 / ] \\* -\n;\n\n: sdif (| d1 d2 k |)\n    0.5 !d2 d1 + * k / - 0 1 clamp =h\n    d2 d1 neg h mix [ k h 1 h - ] \\* +\n;\n\n: sint (| d1 d2 k |)\n    0.5 !d2 d1 - * k / - 0 1 clamp =h\n    d2 d1 h mix [ k h 1 h - ] \\* +\n;\n\n:m union \\min ;\n:m mat-union \\{ (| $a $b |) a b a .x b .x < select } ;\n:m smooth-union (| list k |) list \\{ k smin } list union k 0 != select ;\n\n:m difference \\{ (| d1 d2 |) d2 neg d1 max } ;\n:m smooth-difference (| list k |) list \\{ swap k sdif } list difference k 0 != select ;\n\n:m intersection \\max ;\n:m smooth-intersection (| list k |) list \\{ k sint } list intersection k 0 != select ;\n\n:m scale (| block factor p |) p factor / *block factor * ;\n\n:m repeat (| block c p |) p .5 c * + c mod .5 c * - *block ;\n\n:m onion (| sdf thickness |) sdf abs thickness - ;\n\n:m store !drop ;\n\n:m apply (| funcs value |) funcs /{ value *_ } ;\n\n:m rotate (| $p angle |)\n        { cos sin }\n            &*angle\n            { angle store }\n            angle is-block?\n        cif\n    apply =[ c s ]\n    [\n        p .x c * p .y s * -\n        p .x s * p .y c * +\n    ]\n;\n\n:m scoped (| block p |) p *block ;\n\n:m round .5 + floor ;\n\n:m noise-permute (| x |)\n\tx 34 * 1 + x * 289 mod\n;\n\n:m pnoise-fade (| t |)\n\tt 6 * 15 - t * 10 + t * t * t *\n;\n\n: pnoise-2d (| v |)\n\tv .xyxy floor [ 0 0 1 1 ] + 289 mod =Pi\n\tv .xyxy fract [ 0 0 1 1 ] - =Pf\n\n\tPi .xzxz noise-permute Pi .yyww + noise-permute =>i\n\ti 41 / fract 2 * 1 - =gx\n\tgx abs .5 - =gy\n\tgx !round - =gx\n\n\t[ gx .x gy .x ] =>g00\n\t[ gx .y gy .y ] =>g10\n\t[ gx .z gy .z ] =>g01\n\t[ gx .w gy .w ] =>g11\n\n\tgx gx * gy gy * + sqrt inversesqrt =norm\n\tg00 norm .x * Pf .xy dot =>n00\n\tg10 norm .z * Pf .zy dot =>n10\n\tg01 norm .y * Pf .xw dot =>n01\n\tg11 norm .w * Pf .zw dot =>n11\n\n\tPf .xy pnoise-fade =fade_xy\n\t[ n00 n01 ] [ n10 n11 ] fade_xy .x mix =n_x\n\tn_x .x.y fade_xy .y mix 2.3 *\n;\n\n:m apply-contrast (| color value |)\n    color .5 - value 0 max * .5 + 0 1 clamp\n;\n\n:m apply-brightness (| color value |)\n    color value + 0 1 clamp\n;\n\n:m apply-vignette (| color distance intensity |)\n    real-position length distance - =>v\n    v intensity * 0 1 clamp =>v\n    1 v - =>v\n    color v *\n;\n\ntime 1 * =>time\n\n:m inv 1 _ - ;\n\n:m tau 6.14 ;\n\n: lissajous (| a b A B angle dt |)\n    [\n        a dt * angle + sin A *\n        b dt * sin B *\n    ]\n;\n\n: closest-point-line-ratio (| a b p |)\n    p a - =>pa\n    b a - =>ba\n    pa ba dot ba ba dot / 0 1 clamp\n;\n\n: curve (| p ot dt |)\n    ot dt 10 / + =t\n    tau 4 / t 1 / + =angle\n    t 23 / cos abs 2 / .5 + =>a\n    t 27 / cos abs 2 / 1 + =>b\n    1 =>A\n    1 =>B\n    a b A B angle t lissajous .5 *\n;\n\ntime 5 * =>time\n\nreal-position time 0 curve =last-point\n0 =value\n\n: intensity (| t |)\n    1 t 5 / / 0 1 clamp\n;\n\n{ #1 + float =dt\n    real-position time dt neg curve =p\n    last-point p real-position closest-point-line-ratio =h\n    p last-point - =>ba\n    ba h * last-point + =cp\n    p =last-point\n    \n    cp real-position - length =d\n    d 20 * .01 - 0 .15 smoothstep 1 swap - =cv\n        dt 1 - intensity\n        dt intensity\n        h\n    mix cv * max=value\n} #1000 times\n\nreal-position 10000 * pnoise-2d abs 1.3 * 0 1 clamp 1 swap - =pv\n\n[ 0 value pv * 0 ] =color\n\n        color\n        0\n    apply-brightness\n    .84\napply-contrast\n[ 0 1.7 0 ] * =color\n\ncolor 0 .5 apply-vignette =color\n\n[ color 1 ] ->fragColor\n*/\n\nvec2 lissajous_vec2_float_float_float_float_float_float(float arg_5, float arg_4, float arg_3, float arg_2, float arg_1, float arg_0);\nvec2 curve_vec2_float_float_vec2(vec2 arg_2, float arg_1, float arg_0);\nfloat closest_point_line_ratio_float_vec2_vec2_vec2(vec2 arg_2, vec2 arg_1, vec2 arg_0);\nfloat intensity_float_float(float arg_0);\nfloat pnoise_2d_float_vec2(vec2 arg_0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 real_position;\n\tvec2 last_point;\n\tfloat value;\n\tfloat dt;\n\tvec2 p;\n\tfloat h;\n\tvec2 cp;\n\tfloat d;\n\tfloat cv;\n\tfloat pv;\n\tvec3 color;\n\treal_position = ((((fragCoord) / ((iResolution).xy)) * (2.)) - (1.)) * (vec2((((iResolution).xy).x) / (((iResolution).xy).y), 1.));\n\tlast_point = curve_vec2_float_float_vec2(real_position, iTime, 0.);\n\tvalue = 0.;\n\tfor(int tmp_0 = 0; tmp_0 < int(1000); ++(tmp_0)) {\n\t\tdt = float((tmp_0) + (1));\n\t\tp = curve_vec2_float_float_vec2(real_position, iTime, -(dt));\n\t\th = closest_point_line_ratio_float_vec2_vec2_vec2(last_point, p, real_position);\n\t\tcp = (((p) - (last_point)) * (h)) + (last_point);\n\t\tlast_point = p;\n\t\td = length((cp) - (real_position));\n\t\tcv = (1.) - (smoothstep(((d) * (20.)) - (0.01), 0., 0.15));\n\t\tvalue = max((mix(intensity_float_float((dt) - (1.)), intensity_float_float(dt), h)) * (cv), value);\n\t}\n\tpv = (1.) - (clamp((abs(pnoise_2d_float_vec2((real_position) * (10000.)))) * (1.3), 0., 1.));\n\tcolor = vec3(0., (value) * (pv), 0.);\n\tcolor = (clamp((((clamp((color) + (0.), 0., 1.)) - (0.5)) * (max(0.84, 0.))) + (0.5), 0., 1.)) * (vec3(0., 1.7, 0.));\n\tcolor = (color) * ((1.) - (clamp(((length(real_position)) - (0.)) * (0.5), 0., 1.)));\n\tfragColor = vec4(color, 1.);\n}\n\nvec2 lissajous_vec2_float_float_float_float_float_float(float arg_5, float arg_4, float arg_3, float arg_2, float arg_1, float arg_0) {\n\treturn vec2((sin(((arg_5) * (arg_0)) + (arg_1))) * (arg_3), (sin((arg_4) * (arg_0))) * (arg_2));\n}\n\nvec2 curve_vec2_float_float_vec2(vec2 arg_2, float arg_1, float arg_0) {\n\tfloat t;\n\tfloat angle;\n\tt = (arg_1) + ((arg_0) / (10.));\n\tangle = (1.535) + ((t) / (1.));\n\treturn (lissajous_vec2_float_float_float_float_float_float(((abs(cos((t) / (23.)))) / (2.)) + (0.5), ((abs(cos((t) / (27.)))) / (2.)) + (1.), 1., 1., angle, t)) * (0.5);\n}\n\nfloat closest_point_line_ratio_float_vec2_vec2_vec2(vec2 arg_2, vec2 arg_1, vec2 arg_0) {\n\treturn clamp((dot((arg_0) - (arg_2), (arg_1) - (arg_2))) / (dot((arg_1) - (arg_2), (arg_1) - (arg_2))), 0., 1.);\n}\n\nfloat intensity_float_float(float arg_0) {\n\treturn clamp((1.) / ((arg_0) / (5.)), 0., 1.);\n}\n\nfloat pnoise_2d_float_vec2(vec2 arg_0) {\n\tvec4 Pi;\n\tvec4 Pf;\n\tvec4 gx;\n\tvec4 gy;\n\tvec4 norm;\n\tvec2 fade_xy;\n\tvec2 n_x;\n\tPi = mod((floor((arg_0).xyxy)) + (vec4(0., 0., 1., 1.)), 289.);\n\tPf = (fract((arg_0).xyxy)) - (vec4(0., 0., 1., 1.));\n\tgx = ((fract((mod(((((mod(((((Pi).xzxz) * (34.)) + (1.)) * ((Pi).xzxz), 289.)) + ((Pi).yyww)) * (34.)) + (1.)) * ((mod(((((Pi).xzxz) * (34.)) + (1.)) * ((Pi).xzxz), 289.)) + ((Pi).yyww)), 289.)) / (41.))) * (2.)) - (1.);\n\tgy = (abs(gx)) - (0.5);\n\tgx = (gx) - (floor((gx) + (0.5)));\n\tnorm = inversesqrt(sqrt(((gx) * (gx)) + ((gy) * (gy))));\n\tfade_xy = ((((((((Pf).xy) * (6.)) - (15.)) * ((Pf).xy)) + (10.)) * ((Pf).xy)) * ((Pf).xy)) * ((Pf).xy);\n\tn_x = mix(vec2(dot((vec2((gx).x, (gy).x)) * ((norm).x), (Pf).xy), dot((vec2((gx).z, (gy).z)) * ((norm).y), (Pf).xw)), vec2(dot((vec2((gx).y, (gy).y)) * ((norm).z), (Pf).zy), dot((vec2((gx).w, (gy).w)) * ((norm).w), (Pf).zw)), (fade_xy).x);\n\treturn (mix((n_x).x, (n_x).y, (fade_xy).y)) * (2.3);\n}\n","name":"Image","description":"","type":"image"}]}