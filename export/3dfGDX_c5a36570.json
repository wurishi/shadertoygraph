{"ver":"0.1","info":{"id":"3dfGDX","date":"1547592616","viewed":112,"name":"SDF raymarcher","username":"mxu","description":"Test shader for myself","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat EPSILON = 0.000001f;\nint MAX_MARCHING_STEPS = 100;\nfloat END = 100.f;\n\nfloat sphereSDF( vec3 p, float s )\n{\n\treturn length(p) - s;   \n}\n\nfloat boxSDF( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n \treturn length(max(d, 0.0));//+ min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat repSphereSDF( vec3 p, vec3 c, float s )\n{\n    vec3 q = mod(p, c) - 0.5*c;\n\treturn sphereSDF(q, s);  \n}\n\nfloat repBoxSDF( vec3 p, vec3 b, vec3 c)\n{\n    vec3 q = mod(p, c) - 0.5*c;\n    return boxSDF(q, b);\n}\n\nfloat sceneSDF( vec3 p )\n{\t\n    vec3 of1 = vec3(0.0, 0.0, 1.0);\n    vec3 of2 = vec3(0.0, 0.1, 1.0);\n    float s = 0.2;\n    \n    vec3 c = vec3(0.4, 0.4, 0.4);\n    \n    //return sphereSDF(p - of1, s);\n    return repSphereSDF( p, c, s);\n    \n    //vec3 b = vec3(0.5, 0.2, 0.2);\n    //return repBoxSDF(p, b, c);\n}\n\nvoid ConstructRay( in vec2 fragCoord, in vec3 camera_pos, out vec3 rs, out vec3 rv)\n{\n    vec2 st = fragCoord.xy - vec2(iResolution.y)/2.0;\n    rs = vec3(st/ iResolution.y, 0.0);\n    \n    rv = normalize(rs - camera_pos);\n}\n\nfloat RayMarch( in vec3 rs, in vec3 rv )\n{\n    float t = 0.0f;\n\tfor (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(rs + t*rv);\n        if (dist < EPSILON) {\n            // We're inside the scene surface!\n            return t;\n        }\n        // Move along the view ray\n        t += dist;\n\n        if (t >= END) {\n            // Gone too far; give up\n            return END;\n        }\n    }\n    return END;\n}\n\nvec3 estNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 camera_pos = vec3(cos(iTime), sin(iTime), -5.0+4.0*sin(iTime*0.3));\n    \n    vec3 rs, rv;\n    ConstructRay(fragCoord, camera_pos, rs, rv);\n    \n    float t = RayMarch(rs, rv);\n    \n    // Output to screen\n    // fragColor = vec4(col,1.0);\n    if (t >= 0.0 && t < END) {\n        // light position\n        vec3 P = vec3(1.0, 1.0, -0.3);\n        \n        // ray intersection position\n        vec3 Q = rs + t*rv;\n        \n        // surface of intersection normal\n        vec3 N = estNormal(Q);\n        \n        // light direction from surface of intersection\n        vec3 L = normalize(P-Q);\n        \n        // reflected direction of light\n        vec3 R = reflect(L, N);\n        \n        vec3 lightColor = vec3(1.0, 0.0, 0.0);\n        vec3 objColor = vec3(1.0, 1.0, 1.0);\n        \n        float ambientStr = 0.1f;\n        float diffStr = max(dot(N, L), 0.0);\n        float specStr = pow(max(dot(rv, R), 0.0), 16.0);\n        \n        \n        vec3 ambient = ambientStr * lightColor;\n\t\tvec3 diffuse = diffStr * lightColor;\n        vec3 specular = specStr * lightColor;\n        \n        vec3 result = (ambient + diffuse + specular) * objColor;\n        \n    \tfragColor = vec4(result , 1.0);\n    }\n    else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}