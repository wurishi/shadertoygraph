{"ver":"0.1","info":{"id":"4dSBzD","date":"1499658606","viewed":210,"name":"Tetris Shapes Fractal","username":"KilledByAPixel","description":"Fratal zoom into random tetrominos with random rotations & colors.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","tetris"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////\n// Tetris Shapes Fractal - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 0.6;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 0.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 4;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 28;// how many glyphs total\nconst float glyphMargin\t\t\t= 1.0;\t// how much to center the glyph in each pixel\nconst int glyph[glyphSize*glyphCount] = int[]\n(// glyph sheet\n 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0110, 0x0110, 0x0010, 0x0100, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0010, 0x0100, 0x0010, 0x0100,   \n 0x0000, 0x0110, 0x0010, 0x1000, 0x1100, 0x0110, 0x0100, 0x0110, 0x0010, 0x0100, 0x0110, 0x0110, 0x0100, 0x1100, 0x1110, 0x0110, 0x0000, 0x0110, 0x1110, 0x1110, 0x1100, 0x1100, 0x0100, 0x0110, 0x0010, 0x0100, 0x0110, 0x0110, \n 0x1111, 0x0110, 0x1110, 0x1110, 0x0110, 0x1100, 0x0100, 0x0110, 0x0010, 0x0100, 0x0100, 0x0010, 0x1110, 0x0100, 0x0100, 0x0100, 0x1111, 0x0110, 0x0010, 0x1000, 0x0110, 0x0110, 0x0100, 0x0110, 0x0110, 0x0110, 0x0100, 0x0010, \n 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000\n);//   \n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 10;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0), pow(gsfi,8.0), pow(gsfi,9.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    return 1.0;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    vec3 myColor = vec3\n    (\n    \tmix(0.0, 1.0, RandFloat(i + r + 419*glyphPosLast.x + 773*glyphPosLast.y)),\n    \tmix(0.0, 1.0, RandFloat(i + r + 929*glyphPosLast.x + 499*glyphPosLast.y)),\n        mix(0.0, 0.45, RandFloat(i + r + 929*glyphPosLast.x + 499*glyphPosLast.y))\n    );\n    \n    // vary light and dark colors\n    if ((i+r)%2 == 0)\n        myColor.z = 1.0 - myColor.z;\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    return mix(color, myColor, f);\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += (0.05*uv.y + 0.05*uv.x + 0.05*iTime);\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n    // rotate over time\n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(timePercent);\n\ttimePercent -= floor(timePercent);\n    \n    // generate random rotations that will never have the same number in a row\n    int r1i = 2*(RandInt(iterations-1+10) % 2);\n    if ((iterations-1) % 2 == 0)\n        r1i += 1;\n    int r2i = 2*(RandInt(iterations+10) % 2);\n    if ((iterations) % 2 == 0)\n        r2i += 1;\n    float r1 = (pi/2.0)*float(r1i);\n    float r2 = (pi/2.0)*float(r2i);\n    if (r2 - r1 > pi)\n        r2 -= 2.0*pi;\n    if (r1 - r2 > pi)\n        r1 -= 2.0*pi;\n    float turnRate = 0.25;\n    \n    float theta = mix(r1, r2, ((1.0 / turnRate)*max(timePercent-(1.0-turnRate), 0.0)));\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\tuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetFocusGlyph(int i) { return RandInt(i) % glyphCount; }\nint GetGlyphPixelRow(int y, int g) { return glyph[g + (glyphSize - 1 - y)*glyphCount]; }\nint GetGlyph(int i, ivec2 glyphPos, ivec2 glyphPosLast)\n{ \n    int seed = i + glyphPos.x * 313 + glyphPos.y * 411 + glyphPosLast.x * 557 + glyphPosLast.y * 121;\n    return RandInt(seed) % glyphCount; \n}\n\nint GetGlyphPixel(ivec2 pos, int g)\n{\n\tif (pos.x >= glyphSize || pos.y >= glyphSize)\n\t\treturn 0;\n\n    // pull glyph out of hex\n\tint glyphRow = GetGlyphPixelRow(pos.y, g);\n    return 1 & (glyphRow >> (glyphSize - 1 - pos.x) * 4);\n}\n\nivec2 GetFocus(int i)\n{\n    // find a random valid pixel in glyph\n    int g = GetFocusGlyph(i-1);\n    int c = 0;\n    for (int y = 0; y < glyphSize; ++y)\n    {\n\t\tint glyphRow = GetGlyphPixelRow(y, g);\n        for (int x = 0; x < glyphSize; ++x)\n            c += (1 & (glyphRow >> 4*x));\n    }\n\n    c -= RandInt(i) % c;\n    for (int y = 0; y < glyphSize; ++y)\n    {\n\t\tint glyphRow = GetGlyphPixelRow(y, g);\n        for (int x = 0; x < glyphSize; ++x)\n        {\n            c -= (1 & (glyphRow >> 4*x));\n            if (c == 0)\n                return ivec2(glyphSize - 1 - x,y);\n        }\n    }\n}\n        \n// get recursion depth of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n\tivec2 glyphPosLast = GetFocus(iterations-2);\n\tivec2 glyphPos =     GetFocus(iterations-1);\n    int g = GetFocusGlyph(iterations-1);\n\t\n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocus(iterations+r-1))\n\t    //    color.z = 1.0; // debug - show focus\n        \n        int glyphValue = 0;\n\t\tif (r <= recursionCount)\n        {\n            // offset and bounds check\n            pos -= vec2(glyphMargin/glyphSizeF);\n\n            // get glyph and pos within that glyph\n            glyphPosLast = glyphPos;\n            glyphPos = ivec2(pos * glyphSizeF);\n\n            // check depth\n            glyphValue = GetGlyphPixel(glyphPos, g);\n        }\n            \n\t\tif (glyphValue == 0 || pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // update pos\n\t\tpos *= glyphSizeF;\n\t\tpos -= vec2(floor(pos));\n        \n        if (glyphPos == GetFocus(iterations+r))\n            g = GetFocusGlyph(iterations+r); // inject correct glyph\n        else\n            g = GetGlyph(iterations + r, glyphPos, glyphPosLast);\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    vec2 uv2 = uv;\n    uv = InitUV(uv);\n\t\n\t// get time \n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(timePercent);\n\ttimePercent -= floor(timePercent);\n    \n    // rotate then zoom\n    //float turnRate = 0.75;//(abs(r1-r2) > pi - 0.1)? 0.5 : 0.75;\n    //timePercent = (min((timePercent)*(1.0/turnRate), 1.0));\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocus(iterations+i)) + vec2(glyphMargin)) / glyphSizeF) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv2);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}