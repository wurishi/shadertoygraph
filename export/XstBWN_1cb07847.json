{"ver":"0.1","info":{"id":"XstBWN","date":"1525260568","viewed":102,"name":"Test Blob intersection","username":"paulbaron","description":"Test blob intersection","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blobraymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float \tinfinity = 10000.0f;\n\nconst float \tsolidSurfThreshold = 0.5f;\nconst float \trayMarchDist = 0.05f;\n\n// Ray hit surface\nstruct  SRayHit\n{\n    float \tm_Distance;\n    vec3    m_Position;\n    vec3    m_Normal;\n};\n\n// Blob\nstruct \tSBlob\n{\n    vec3 \tm_Position;\n    float \tm_Radius;\n    float \tm_Intensity;\n};\n\n// Camera representation\nstruct  SCamera\n{\n    vec3    m_Position;\n    vec3    m_Side;\n    vec3    m_Forward;\n    vec3    m_Up;\n};\n\n// build look at\nSCamera buildLookAt(vec3 position, vec3 toLookAt, vec3 up)\n{\n    SCamera cam;\n        \n    cam.m_Position = position;\n    cam.m_Forward = normalize(toLookAt - position);\n    cam.m_Side = normalize(cross(up, cam.m_Forward));\n    cam.m_Up = cross(cam.m_Forward, cam.m_Side);\n    return cam;\n}\n\n// Projects a uv coordinate between -1 and 1 in world space\n// nearDist: near plane distance\n// aspectRatio: screenResolution.x / screenResolution.y\n// verticalOpening: vertical world size of the screen is 2 * verticalOpening, use it as FOV\nvec3    uvToWorldSpace(SCamera cam, vec2 uv, float nearDist, float aspectRatio, float verticalOpening)\n{\n    // Now we convert this in world space\n    vec3 nearPlaneCenter = cam.m_Position + (cam.m_Forward * nearDist);\n    vec3 worldSpaceUv = nearPlaneCenter +\n                        (uv.x * cam.m_Side * aspectRatio * verticalOpening) +\n                        (uv.y * cam.m_Up * verticalOpening);\n    return worldSpaceUv;\n}\n\nSRayHit \trayMarchBlobs(SBlob blob1, SBlob blob2, vec3 rayOrigin, vec3 rayDirection, float farDist)\n{\n    SRayHit\thit;\n    vec3 \tcurrentPos = rayOrigin;\n    float \tcurrentDist = 3.0f;\n\n    while (currentDist < farDist)\n    {\n        currentPos += rayDirection * rayMarchDist;\n        currentDist += rayMarchDist;\n        \n        float \tsumInfluence = 0.0f;\n        \n        vec3 \tcurToBlob1 = blob1.m_Position - currentPos;\n        float \tblobInfluence1 = blob1.m_Intensity / dot(curToBlob1, curToBlob1);\n\n\t\tsumInfluence += blobInfluence1;\n        \n    \tvec3 \tcurToBlob2 = blob2.m_Position - currentPos;\n        float \tblobInfluence2 = blob2.m_Intensity / dot(curToBlob2, curToBlob2);\n\n\t\tsumInfluence += blobInfluence2;\n\n        if (sumInfluence > solidSurfThreshold)\n        {\n            hit.m_Distance = currentDist;\n            hit.m_Position = currentPos;\n            return hit;\n        }\n\t}\n    hit.m_Distance = infinity;\n\thit.m_Position = vec3(infinity);\n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float camSpeed = 2.0f;\n    const float camDistance = 0.0f;\n    \n    float \t\tcamPosX = cos(iTime * camSpeed) * camDistance;\n    float \t\tcamPosY = sin(iTime * camSpeed) * camDistance;\n    \n    vec3 \t\tcamPos = vec3(camPosX, 10.0f, camPosY);\n    SCamera \tcamera = buildLookAt(camPos, vec3(0.0f), vec3(0.0, 0.0, 1.0));\n    \n    SBlob \t\tblob1;\n    SBlob \t\tblob2;\n\n    blob1.m_Position = vec3(0, 0, 0);\n    blob1.m_Radius = 1.0f;\n    blob1.m_Intensity = 1.0f;\n\n    float \t\tblobDist = cos(iTime * 3.0f) * 0.5f + 0.8f ;\n    \n    blobDist *= 5.0f;\n    \n    float \t\tblobPosX = cos(iTime * 2.0f) * blobDist;\n    float \t\tblobPosY = sin(iTime * 2.0f) * blobDist;\n\n    blob2.m_Position = vec3(blobPosX, 0, blobPosY);\n    blob2.m_Radius = 2.0f;\n    blob2.m_Intensity = 1.0f;\n    \n\t// Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0f - 1.0f;\n\n    float \taspectRatio = iResolution.x / iResolution.y;\n    float \tfov = 0.1f;\n    float \tnearDist = 0.2f;\n    \n    vec3 \trayOrigin = uvToWorldSpace(camera, uv, nearDist, aspectRatio, fov);\n\tvec3 \trayDirection = rayOrigin - camPos;\n                                       \n\tSRayHit hit = rayMarchBlobs(blob1, blob2, rayOrigin, rayDirection, 50.0f);\n\n    vec3 \txPos = dFdx(hit.m_Position);\n    vec3 \tyPos = dFdy(hit.m_Position);\n\n    fragColor = vec4(0.0f, 0.0f, 0.3f, 1.0f);\n\n    if (hit.m_Distance != infinity)\n    {\n\t    fragColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n    }\n}","name":"Image","description":"","type":"image"}]}