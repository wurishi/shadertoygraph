{"ver":"0.1","info":{"id":"ll3XRB","date":"1481062271","viewed":168,"name":"Sphere Tracing Primitives","username":"bfra","description":"Test for sphere tracing implicit primitives","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["primitives","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Blobs\n// Eric Galin\n\n// Completed by Basile Fraboni\n// For student purpose\n\n#define M_PI 3.1415926535897932384626433832795\n\nconst int Steps = 500;\nconst float Epsilon = 0.0005; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n////////////////////////////////////////////\n//\t\t\tDistance functions\t\t      //\n////////////////////////////////////////////\n\n// Distance to segment\n// p : point\n// a : segment extremity\n// b : segment extremity\nfloat d_segment(vec3 p, vec3 a, vec3 b)\n{    \n    vec3 pa = p - a;\n    vec3 ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Distance to circle\n// p : point\n// c : circle center\n// u : plane normal \n// r : circle radius\nfloat d_circle(vec3 p, vec3 c, vec3 u, float r)\n{\n  vec3 pc = p-c;\n  float pq = abs(dot(pc,normalize(u)));\n  float l = sqrt(length(pc)*length(pc)-pq*pq);\n  float e = l-r;\n  return sqrt(e*e+pq*pq);\n}\n\n// Distance to disk\n// p : point\n// c : disk center\n// u : plane normal \n// r : disk radius\nfloat d_disk(vec3 p, vec3 c, vec3 u, float r)\n{\n  vec3 pc = p-c;\n  float pq = abs(dot(pc,normalize(u)));\n  float l = sqrt(length(pc)*length(pc)-pq*pq);\n  float e = l-r;\n  \n  if(e > 0.0) \n    return sqrt(e*e+pq*pq);\n  else\n    return pq;\n}\n\n// Distance to sphere\n// p : point\n// c : sphere center\n// r : sphere radius\nfloat d_sphere(vec3 p, vec3 c, float r)\n{\n  vec3 pc = p-c;\n  return abs(length(pc)-r);\n}\n\n// Distance to box\n// p : point\n// pmin : box min\n// pmax : box max\nfloat d_box(vec3 p, vec3 pmin, vec3 pmax)\n{\n  vec3 ppmin = pmin-p;\n  vec3 pmaxp = p-pmax;\n    float dx = max(0.0, max(ppmin.x, pmaxp.x));\n    float dy = max(0.0, max(ppmin.y, pmaxp.y));\n    float dz = max(0.0, max(ppmin.z, pmaxp.z));\n    return sqrt(dx*dx + dy*dy + dz*dz);\n}\n\n////////////////////////////////////////////\n//\t\t\tSmooth function\t\t\t      //\n////////////////////////////////////////////\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n    float x = clamp(r/R,0.0,1.0);\n    float y = (1.0-x*x);\n    return y*y*y;\n}\n\n// Smooth falloff lambda calculation function\n// e : energy associated to skeleton\n// R : Large radius\nfloat lambda( float e, float R )\n{\n    // Sup of first derivative of function f:x->(1-x^2)^3\n    const float l = 96.0/(25.0*sqrt(5.0));\n    // lambda i = lambda / Ri\n    return e*l/R;\n}\n\n////////////////////////////////////////////\n//\t\t\tPrimitive functions\t\t      //\n////////////////////////////////////////////\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e, float R)\n{\n    return e*falloff(length(p-c),R);\n}\n\n// Box skeleton\n// p : point\n// pmin : box vertex min\n// pmax : box vertex max\n// e : energy associated to skeleton\n// R : large radius\nfloat box(vec3 p, vec3 pmin, vec3 pmax, float e, float R)\n{\n    return e*falloff(d_box(p,pmin,pmax),R);\n}\n\n// Segment skeleton\n// p : point\n// a : segment extremity\n// b : segment extremity\n// e : energy associated to skeleton\n// R : large radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n    return e*falloff(d_segment(p,a,b),R);\n}\n\n// Torus skeleton\n// p : point\n// c : circle center\n// u : plane normal\n// r : circle radius\n// e : energy associated to skeleton\n// R : large radius\nfloat torus(vec3 p, vec3 c, vec3 u, float r, float e, float R)\n{\n    return e*falloff(d_circle(p,c,u,r),R);\n}\n\n// Plate skeleton\n// p : point\n// c : circle center\n// u : plane normal\n// r : circle radius\n// e : energy associated to skeleton\n// R : large radius\nfloat plate(vec3 p, vec3 c, vec3 u, float r, float e, float R)\n{\n    return e*falloff(d_disk(p,c,u,r),R);\n}\n\n////////////////////////////////////////////\n//\t\t\t\tOperators\t\t\t      //\n////////////////////////////////////////////\n\n// Basic sets operations\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n// Lambda calculation for Blend\nfloat lBlend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n// Lambda calculation for Union\nfloat lUnion(float a,float b)\n{\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b)\n{\n    return min(a,b);\n}\n// Intersection with Blend\nfloat IntersectionBlend(float a,float b)\n{\n    return a-2.0*T+b;\n}\n// Lambda calculation for Intersection\nfloat lIntersection(float a,float b)\n{\n    return max(a,b);\n}\n\n// Difference\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Difference(float a,float b)\n{\n    return min(a,2.0*T-b);\n}\n// Difference with blend\nfloat DifferenceBlend(float a,float b)\n{\n    return a-b;\n}\n// Lambda calculation for Difference\nfloat lDifference(float a,float b)\n{\n    return max(a,b); // ??? ca ne marche pas je ne sais pas calculer lambda\n}\n\n////////////////////////////////////////////\n//\t\t\tTransformations\t\t\t      //\n////////////////////////////////////////////\n\n// Rotation around axis : RotationX(r.x)*RotationY(r.y)*RotationZ(r.z)\nvec3 Rotation( vec3 p, vec3 r )\n{\n    return rotateX(rotateY(rotateZ(p,r.z),r.y),r.x);\n}\n// Repetition of p with the translation c\nvec3 Repetition( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n// Scaling of p\nvec3 Scale( vec3 p, vec3 c )\n{\n    return vec3(p.x*c.x,p.y*c.y,p.z*c.z);\n}\n// Twist : function of y \nvec3 Twist(vec3 p, float v)\n{\n \tfloat c = cos(v*p.y);\n    float s = sin(v*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n////////////////////////////////////////////\n//\t\t\tTest functions\t\t\t      //\n////////////////////////////////////////////\n\nfloat test_diff(vec3 p, float time, float blend)\n{  \n    float v = box(rotateY(rotateX(p,time),time),vec3(-2.0,-2.0,-2.0),vec3(2.0,2.0,2.0),1.0,1.0);\n    if(blend == 1.0)\n        return DifferenceBlend(v, point(p,vec3(0.0,0.0,0.0),1.0,5.5));\n    else\n        return Difference(v, point(p,vec3(0.0,0.0,0.0),1.0,5.5));\n}\n\nfloat l_test_diff()\n{  \n  \treturn lDifference(lambda(1.0,1.0),lambda(1.0,5.5));\n}\n\nfloat test_inter(vec3 p, float time, float blend)\n{  \n    float v = box(rotateY(rotateX(p,time),time),vec3(-2.0,-2.0,-2.0),vec3(2.0,2.0,2.0),1.0,1.0);\n    if(blend == 1.0)\n    \treturn IntersectionBlend(v, point(p,vec3(0.0,0.0,0.0),1.0,5.5));\n    else\n        return Intersection(v, point(p,vec3(0.0,0.0,0.0),1.0,5.5));\n}\n\nfloat l_test_inter()\n{  \n  \treturn lIntersection(lambda(1.0,0.5),lambda(1.0,5.5));\n}\n\nfloat test_union(vec3 p, float time, float blend)\n{  \n    float v = box(rotateY(rotateX(p,time),time),vec3(-2.0,-2.0,-2.0),vec3(2.0,2.0,2.0),1.0,1.0);\n    if(blend == 1.0)\n    \treturn Blend(v, point(p,vec3(4.0,0.0,0.0),1.0,5.5));\n    else\n        return Union(v, point(p,vec3(4.0,0.0,0.0),1.0,5.5));\n}\n\nfloat l_test_union()\n{  \n  \treturn lIntersection(lambda(1.0,1.0),lambda(1.0,5.5));\n}\n\n////////////////////////////////////////////\n//\t\t\t\tMy objects\t\t\t      //\n////////////////////////////////////////////\n\nfloat cube(vec3 p,float side,float e, float R)\n{\n  float val = side/2.0;\n  vec3 pmin = vec3(-val,-val,-val);\n  vec3 p1 = vec3(-val,-val,val);\n  vec3 p2 = vec3(val,-val,val);\n  vec3 p3 = vec3(val,-val,-val);\n\n  vec3 pmax = vec3(val,val,val);\n  vec3 p4 = vec3(val,val,-val);\n  vec3 p5 = vec3(-val,val,-val);\n  vec3 p6 = vec3(-val,val,val);\n\n  float v = 0.0;\n\n  v = max(v,segment(p,pmin,p1,e,R));\n  v = max(v,segment(p,p1,p2,e,R));\n  v = max(v,segment(p,p2,p3,e,R));\n  v = max(v,segment(p,pmin,p3,e,R));\n  v = max(v,segment(p,pmax,p4,e,R));\n  v = max(v,segment(p,p4,p5,e,R));\n  v = max(v,segment(p,p5,p6,e,R));\n  v = max(v,segment(p,pmax,p6,e,R));\n  v = max(v,segment(p,pmax,p2,e,R));\n  v = max(v,segment(p,pmin,p5,e,R));\n  v = max(v,segment(p,p3,p4,e,R));\n  v = max(v,segment(p,p1,p6,e,R));\n\n  return v;\n}\n\nfloat lcube(float e, float R)\n{\n    return lambda(e,R);\n}\n\nfloat rot_rep_torus(vec3 p, float time)\n{  \n  \tfloat v = 0.0;\n  \t//vec3 newp = p;\n  \tvec3 newp = Repetition(p,vec3(8.0,8.0,8.0));\n \tv = Blend(v, torus(rotateX(newp,time),vec3(0.0,0.0,0.0),vec3(1.0,1.3,3.2),1.0,1.0,0.5));\n  \tv = Blend(v, torus(rotateZ(newp,2.0*time),vec3(0.0,0.0,0.0),vec3(2.0,-1.3,1.6),2.0,1.0,0.5));\n  \tv = Blend(v, torus(rotateY(newp,0.5*time),vec3(0.0,0.0,0.0),vec3(-2.0,3.2,0.1),1.5,1.0,0.5));\n    v = Blend(v, box(rotateY(rotateX(newp,time),time),vec3(-0.2,-0.2,-0.2),vec3(0.2,0.2,0.2),0.6,0.5));\n    return v;\n}\n\nfloat l_rot_rep_torus()\n{  \n  \treturn lambda(0.6,0.5);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  \tp.z=-p.z;\n\tfloat t = iTime*1.4;\n    \n    // DIFFERENTES TRANSFORMATIONS POUR P\n    \n    vec3 p_rot = \tRotation(p,vec3(0.3*t,0.3*t,0.0));\n    vec3 p_rep = \tRepetition(p,vec3(5.0,5.0,5.0));\n    vec3 p_scale = \tScale(p,vec3(0.5,1.0,0.5));\n    vec3 p_twist = \tTwist(p,5.0);\n    \n    // DIFFERENTES PRIMITIVES DE SQUELETTE\n    \n  \t//float v = point(p,vec3(-5.0,0.0,-1.0),1.0,1.0);\n  \t//float v = torus(p,vec3(4.0,0.0,0.0),vec3(0.0,2.0,1.0),2.0,1.0,1.0);\n  \t//float v = box(p,vec3(-1.0,-1.0,-1.0),vec3(1.0,1.0,1.0),1.0,1.0);\n    //float v = segment(p,vec3(3.0,3.0,0.0),vec3(-1.0,-1.0,0.0),1.0,1.0);\n    //float v = plate(p,vec3(0.0,0.0,0.0),vec3(0.0,2.0,1.0),2.0,1.0,1.0);\n    \n    // AVEC DES TRANSFORMATIONS\n    \n  \t// float v = point(p_rep,vec3(0.0,0.0,0.0),1.0,1.0);\n  \t// float v = point(p_rot,vec3(-5.0,0.0,-1.0),1.0,1.0);\n  \t// float v = point(p_scale,vec3(0.0,0.0,0.0),1.0,1.0);\n    \n    // OPERATEURS AVEC OU SANS BLEND\n    \n    // float v = test_union(p,t,1.0);\n    // float v = test_diff(p,t,0.0);\n    // float v = test_inter(p,t,1.0);\n    \n    // CUBE EN ROTATION\n  \t\n    float v = cube(p_rot,5.0,1.0,0.6);\n    \n    // REPETITION DE TORES EN ROTATION\n    \n    // float v = rot_rep_torus(p_rot,t); \n    \n    \n  \treturn v-T;\n}\n\nfloat lobject(vec3 p)\n{\n  p.z=-p.z;\n  \t\n    // LAMBDA CUBE A BASE DE SEGMENTS    \n   \n    //float l = lcube(1.0,0.6);\n    \n    // LAMBDA TORUS   \n   \n    float l = l_rot_rep_torus();\n    \n    // LAMBDA PRIMITIVES\n    \n    //float l = lambda(1.0,1.0);\n    \n    // LAMBDA OPERATEURS\n    \n    //float l = l_test_diff();\n    //float l = l_test_inter();\n    //float l = l_test_union();\n\n  \treturn l;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  const float eps = 0.0001;\n  vec3 dx = vec3(eps,0.0,0.0);\n  vec3 dy = vec3(0.0,eps,0.0);\n  vec3 dz = vec3(0.0,0.0,eps);\n  vec3 n;\n  float v = object(p);\n  n.x = object( p+dx ) - v;\n  n.y = object( p+dy ) - v;\n  n.z = object( p+dz ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using sphere marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    float l = lobject(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/l);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.3, 0.5, 0.8);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(p-lightPos);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n   //vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime*0.25;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}