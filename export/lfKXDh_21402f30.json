{"ver":"0.1","info":{"id":"lfKXDh","date":"1715132008","viewed":28,"name":"Metal Mandelbulb","username":"elifront","description":"metal Mandelbulb","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb","metal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.001;\nconst float PI = 3.14159265359;\n\nfloat DE(vec3 pos) { // FROM http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n    int Iterations = 4;\n    float Bailout = 2.;\n    float Power = sin(iTime)+ 6.;\n    \n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Estimate normal using gradient\nvec3 getNormalFromP(vec3 p) {\n    float x = DE(vec3(p.x + EPSILON, p.y, p.z)) - DE(vec3(p.x - EPSILON, p.y, p.z));\n    float y = DE(vec3(p.x, p.y + EPSILON, p.z)) - DE(vec3(p.x, p.y - EPSILON, p.z));\n    float z = DE(vec3(p.x, p.y, p.z + EPSILON)) - DE(vec3(p.x, p.y, p.z - EPSILON));\n    return normalize(vec3(x, y, z));\n}\n\n// Phong shading\nvec3 phongShading(vec3 normal, vec3 lightDir, vec3 viewDir,\n    vec3 lightAmbient, vec3 lightDiffuse, vec3 lightSpecular,\n    vec3 materialAmbient, vec3 materialDiffuse, vec3 materialSpecular) {\n    // Ambient component\n    vec3 ambient = lightAmbient * materialAmbient;\n\n    // Diffuse component\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = lightDiffuse * (diff * materialDiffuse);\n\n    // Specular component\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16.0); // More diffuse specular highlight\n\n    vec3 specular = lightSpecular * (spec * materialSpecular);\n\n    // Summing all components\n    vec3 result = ambient + diffuse + specular;\n    return result;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\n\tvec3 ro = vec3( uv, -3. );\n    vec3 col = vec3(0.0);\n\n\t\n\n\tvec3 rd = normalize( vec3( uv, 1000000. ) );\n\n\tfloat t = 0.0;\n\tfloat d = 200.0;\n    float i = 0.;\n    \n    float max_steps = 100.;\n\n\tfor( i = 0.; i < max_steps; i++ ){\t\n        vec3 p = ro + rd * t;\n\t\tfloat d = DE( p );\n        if (d < .0001 || t > 100.) break;\n\t\tt+=d;\t\n\t}\n    \n     if (t < 100.) {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormalFromP(p);\n\n        // Adjusted Surface properties for a galvanized steel look\n        vec3 materialAmbient = vec3(0.05, 0.05, 0.05); // Darker ambient for higher contrast\n        vec3 materialDiffuse = vec3(0.2, 0.2, 0.2); // Darker diffuse for higher contrast\n        vec3 materialSpecular = vec3(1.0, 1., 1.); // Brighter specular for more reflectivity\n\n        // Light positions updated to fit three-point lighting setup\n        vec3 positions[3];\n        positions[0] = vec3(2.0, 5.0, -5.0); // Key light position (brightest, primary source)\n        positions[1] = vec3(-2.0, -3.0, -5.0); // Fill light position (softer, opposite key light)\n        positions[2] = vec3(0.0, 0.0, 5.0); // Back light position (behind the object)\n\n        vec3 lightAmbients[3];\n        lightAmbients[0] = vec3(0.2, 0.2, 0.25); // Key light\n        lightAmbients[1] = vec3(0.1, 0.1, 0.15); // Fill light\n        lightAmbients[2] = vec3(0.15, 0.15, 0.2); // Back light\n\n        vec3 lightDiffuses[3];\n        lightDiffuses[0] = vec3(1.0, 1.0, 1.0); // Key light\n        lightDiffuses[1] = vec3(0.5, 0.5, 0.5); // Fill light\n        lightDiffuses[2] = vec3(0.6, 0.6, 0.6); // Back light\n\n        vec3 lightSpeculars[3];\n        lightSpeculars[0] = vec3(1.0, 1.0, 1.0); // Key light\n        lightSpeculars[1] = vec3(0.3, 0.3, 0.3); // Fill light\n        lightSpeculars[2] = vec3(0.5, 0.5, 0.5); // Back light\n\n        vec3 viewDir = normalize(-rd);\n        \n        \n        // Calculate reflection vector\n        vec3 reflectionVector = reflect(rd, normal);\n\n        // Get environment color from the cube map  \n        vec3 envColor = texture(iChannel0, reflectionVector).rgb;\n        \n        for (int i = 0; i < 3; i++) {\n            // three point lighting\n            vec3 lightDir = normalize(positions[i] - p);\n            col += phongShading(normal, lightDir, viewDir, lightAmbients[i], lightDiffuses[i], lightSpeculars[i], materialAmbient, materialDiffuse, materialSpecular);\n        }    \n        \n        float reflectivity = 0.2; // Adjust for more or less reflection\n        col = mix(col, envColor, reflectivity);\n    } else {\n        col = vec3(0.);\n\n    }\n\n    fragColor = vec4(col, 1);\n    \n}","name":"Image","description":"","type":"image"}]}