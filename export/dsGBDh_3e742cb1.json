{"ver":"0.1","info":{"id":"dsGBDh","date":"1698168873","viewed":77,"name":"Nebula105","username":"yukithm","description":"This GLSL Graphics for TokyoDemoFest 16ms #0.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","fbm","cloud","volumetric","domainwarping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\nuniform vec2 mouse;\nuniform int frame;\n\n#define DIST_MIN 0.001\n#define ITE_MAX 1\n#define DIST_MAX 1000.0\n#define MAX_STEPS 24\n#define SHADOW_STEPS 12\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 2.\n#define DIST_COEFF 0.25\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat fsnoise(vec2 c){\n    return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat fractal_noise(vec2 fragCoord, float time) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float split_size_x = 20.0;\n    float split_size_y = 100.0;\n\n    float x = floor(uv.x * split_size_x);\n    float y = floor(uv.y * split_size_y);\n    return fsnoise(vec2(x, y) + vec2(cos(iTime)));\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nvec3 repetition(vec3 p,float fre){\n    return mod(p,fre)-fre*0.5;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    p = repetition(p,2.);\n    return length(p)-s;\n}\n\nfloat map(vec3 p){\n    float size = 0.07;\n    return sdSphere(p+vec3(0.,0.,sin(p.z)+iTime*1.),size);\n}\n\nfloat volumeMap(vec3 p,float f){\n    p += vec3(10.);\n    p = repetition(p,20.0);\n    vec3 scale = vec3(0.8,0.7,0.8);\n    \n    float sph = length(p*scale) - 15.*f*f;\n    \n    return min(max(0.0,sph),1.0);\n}\n\nfloat damain_warping( in vec3 p , out vec3 q, out vec3 r ,float f){\n    q.x = f;\n    q.y = f;\n    q.x += cos(0.5) + sin(0.3+0.5);\n\n    float ff = fbm(p+4.*q);\n    r.x = ff;\n    r.y = ff;\n\n    return fbm( p + 4.0*r );\n}\n\nvec3 damain_warping_coloring( in vec3 p ,float f){\n    vec3 o = vec3(0.0,0.0,0.0);\n    vec3 n = vec3(0.0,0.0,0.0);\n    float luminance = 0.2;\n\n    float dw = damain_warping(p,o,n,f);\n\n    vec3 cloud_base_col = vec3(0.2,0.1,0.9);\n    vec3 cloud_blue = vec3(0.2,0.0,0.9);\n    vec3 cloud_black = vec3(0.1,0.1,0.1);\n    vec3 cloud_red = vec3(0.7,0.2,0.2);\n\n    vec3 col = cloud_base_col;\n    col = mix( col, cloud_blue, 1.5*dw );\n    col = mix( col, cloud_black, 1.3*dot(n,n) );\n    col = mix( col, cloud_red, 1.1*o.y*o.y );\n\n    return col * luminance;\n}\n\nfloat jitter;\n\nvec4 cloudMarch(vec3 camera, vec3 ray){\n    float density = 0.0;\n    float stepLen = VOLUME_LENGTH/float(MAX_STEPS);\n    \n    float cloudDensity = 6.0;\n  \tvec3 cloudColor = vec3(.0,.0,.0);\n    \n    vec4 sum = vec4(vec3(0.),1.);\n    \n    vec3 pos = camera+ray*jitter;\n    \n    for(int i=0;i<MAX_STEPS;i++){\n        if(sum.a<.01)break;\n        \n        float f = fbm(pos);\n        float fogD = volumeMap(pos,f);\n        \n        if(fogD<0.999){\n            density = clamp((fogD/float(MAX_STEPS))*cloudDensity,0.0,1.0);\n            \n            cloudColor = damain_warping_coloring(pos,f);\n        \n            sum.rgb += cloudColor*sum.a;\n            \n            sum.a*=1.-density;\n        }\n      for(int i=0; i<ITE_MAX; i++){\n          float d = map(pos);\n  \n          if(d<DIST_MIN){\n              sum.rgb += vec3(0.4,0.4,0.15);\n              break;\n          } \n      }\n\n        pos+=ray*stepLen;\n    }\n\n    return sum;\n    \n}\n\nvec3 rotate ( vec3 pos, vec3 axis,float theta )\n{\n    axis = normalize( axis );\n    \n    vec3 v = cross( pos, axis );\n    vec3 u = cross( axis, v );\n    \n    return u * cos( theta ) + v * sin( theta ) + axis * dot( pos, axis );   \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 col = vec3(0.);\n    \n    //start effect\n    if(3.5<iTime && iTime<7.5 && fsnoise(vec2(iTime))<0.3){      \n      col = vec3(0.);\n    }\n\n    else{\n      jitter = hash(uv.x+uv.y*57.0);\n\n      vec3 skybox = vec3(0.0,0.0,0.0);\n  \n      vec3 move = vec3(sin(iTime*0.5)*3.,cos(iTime)*1.,0.);\n      vec3 camera = vec3(iTime+20.,10.+iTime,iTime*2.)+move;\n      vec3 dir = normalize(vec3(uv,1.0));\n      dir = rotate(dir,vec3(0.,1.,0.),move.x*0.06);\n      dir = rotate(dir,vec3(0.,1.,0.),sin(iTime*4.)*0.01+cos(iTime*3.5)*0.01);\n      dir = rotate(dir,vec3(1.,0.,0.),move.y*0.06);\n      dir = rotate(dir,vec3(1.,0.,0.),sin(0.3+iTime*4.)*0.01+cos(0.3+iTime*3.5)*0.01);\n  \n  \t  vec4 res = cloudMarch(camera,dir);\n      res = pow(res,vec4(2.0/2.6));\n  \n      col = res.rgb+mix(vec3(0.),skybox,res.a); //背景と合成\n      \n      col = mix(vec3(0.),col,clamp(iTime*0.1,0.,1.));\n    }\n\n    \n    fragColor = vec4(col,1.);\n\n}","name":"Image","description":"","type":"image"}]}