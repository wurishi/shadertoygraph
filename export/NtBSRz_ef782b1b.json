{"ver":"0.1","info":{"id":"NtBSRz","date":"1627953179","viewed":254,"name":"voro-bluenoise testing ","username":"Carandiru","description":"voro-bluenoise applied\nset scale to a lower value for a wider fov, and to see more parallax layers.\n","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["voronoi","parallax","infinite","bluenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/stfXD8\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define SCALE 0.5\n#define SPEED 10.0\n\n#define bitset_size (128)\n#define bitset_row (bitset_size >> 2)\n#define bitset_row_half (bitset_row >> 1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 gap = iResolution.xy * SCALE;\n    \n    // testing and setting 128 bits depending on value <> 0.5\n    uvec4 bitset = uvec4(0u);\n    for (uint y = 0u ; y < 4u ; ++y) {\n        for (uint x = 0u ; x < uint(bitset_row) ; ++x) {\n            \n            // x*y defines \"layer\", scroll and offset\n            vec2 tile = (fragCoord.xy / vec2(x*y) + vec2(float(x) + iTime * SPEED,y));\n            // normalized\n            vec2 uv = (tile / gap);\n\n            tile.r = textureLod(iChannel0, uv, 0.0).r;\n\n            if (tile.r >= 0.5f) {\n                bitset[y] |= (1u << x);\n            }\n\n        }\n    }\n    \n    uvec4 row[4];\n    // unpack 128 bits\n    for (uint y = 0u ; y < 4u ; ++y) {\n    \n        row[y].r = (bitset[y]) & 0xFFu;\n        row[y].g = (bitset[y] >> 8u) & 0xFFu;\n        row[y].b = (bitset[y] >> 16u) & 0xFFu;\n        row[y].a = (bitset[y] >> 24u) & 0xFFu;\n    }\n    \n    vec4 color = vec4(0);\n    \n    // normalize and mix 4 colors\n    color = vec4(row[0]) / 255.0f;\n    color = mix(color, vec4(row[1]) / 255.0f, 0.5f);\n    color = mix(color, vec4(row[2]) / 255.0f, 0.5f);\n    color = mix(color, vec4(row[3]) / 255.0f, 0.5f);\n    \n    // pre-multiply alpha\n    color.rgb *= color.a;\n\n    fragColor = vec4(color.rgb, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/stfXD8\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define SCALE 64.0\n#define SPEED 1.0\n\nvec2 random2( vec2 p ) {\n    return textureLod(iChannel0, (p * iResolution.xy) / (1024.0f * SCALE), 0.0f).rg;\n    //return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv *= SCALE;\n    \n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    vec4 mDist = vec4(1.0f); // x least point distnace, y 2nd least point distance ....\n    \n    for(int j=-1; j<=1; ++j) {\n        for(int i=-1; i<=1; ++i) {\n            vec2 neighbour = vec2(float(i), float(j));\n            vec2 point = random2(iuv + neighbour);\n            \n            // animate\n            point = 0.5f + 0.5f*sin(SPEED*iTime + 6.2831f*point);\n            \n            vec2 diff = neighbour + point - fuv;\n                        \n            float dist = dot(diff, diff); // lenght^2\n            \n            if(dist < mDist.x) {\n                mDist.w = mDist.z;\n                mDist.z = mDist.y;\n                mDist.y = mDist.x;\n                mDist.x = dist;\n            } \n            else if(dist < mDist.y) {\n                mDist.w = mDist.z;\n                mDist.z = mDist.y;\n                mDist.y = dist;\n            }\n            else if(dist < mDist.z) {\n                mDist.w = mDist.z;\n                mDist.z = dist;\n            }\n            else if(dist < mDist.w) {\n                mDist.w = dist;\n            }\n        }\n    }\n    \n    mDist = sqrt(mDist);\n    \n    float d = mix(mix(mDist.x,mDist.y,0.5f),\n                  mix(mDist.z,mDist.w,0.5f),0.5f);\n       \n    vec4 col = vec4(0.0f);\n    \n    // dither / add high frequency details (optional)\n    col = vec4(d - textureLod(iChannel0, fragCoord/1024.0f, 0.0f).r * (1.0f/255.0f));\n    \n    fragColor = (1.0f - col) * 2.0f;\n}","name":"Buffer A","description":"","type":"buffer"}]}