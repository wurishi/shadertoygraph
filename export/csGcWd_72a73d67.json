{"ver":"0.1","info":{"id":"csGcWd","date":"1696717299","viewed":87,"name":"Julia set burning ship + blend","username":"Elyades","description":"Burning ship Julia","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Test julia set\" by Elyades. https://shadertoy.com/view/ddBczW\n// 2023-10-07 22:21:21\n\nvec2 function(vec2 uv, vec2 c)\n{    \n    vec2 result = vec2( uv.x*uv.x*uv.x - 3.0*uv.x*uv.y*uv.y, 3.0*uv.x*uv.x*uv.y - uv.y*uv.y*uv.y ) + c;\n    return result;\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\n\nvec2 functionPolar(vec2 uv)\n{\n    float n = 3.0;\n    vec2 c = vec2(0.1,-0.8);\n    vec2 result;\n    result.x = pow(uv.x,n);\n    result.y = n*uv.y;\n    return result;\n}\n\nvec2 cartesianToPolar(vec2 uv)\n{\n    float r = length(uv);\n    float theta = atan(uv.y,uv.x);\n    return vec2(r,theta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //Offset\n    uv = uv - 0.5;\n    uv.x += 0.0;\n    \n    //Scale\n    uv *= 2.4;\n    uv.x *= iResolution.x / iResolution.y;\n    \n     //Choosing the Zoom\n    vec2 zoomPoint = vec2(0.0);\n    \n    //Zoom\n    float zoomAmount = min(1.0,1.0/pow(max(iTime-3.0,1.0),3.0));\n    uv = uv*zoomAmount;\n    uv += zoomPoint;\n    \n    // Algorithm to color the pixel\n    float tol = pow(10.0,-6.0);\n    \n    \n    float DistanceToPrevious = 1.0;\n    float currentModulus = length(uv);\n    vec2 previousIteration;\n    int iterationAmount;\n    int testAmount = 1000;\n    \n    vec2 c = 5.0*(iMouse.xy/iResolution.xy - 0.5);\n    //vec2 c = uv;\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = uv;\n        uv = function(uv,c);\n        currentModulus = length(uv);\n        DistanceToPrevious = length(uv - previousIteration);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > 3.0){break;}\n    }\n    \n    \n    \n    if(currentModulus < 3.0)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    else\n    {\n            iterationAmount = int(sqrt(float(iterationAmount)));\n            iterationAmount *= 10;\n            int periodFast = 5;\n            int residueFast = iterationAmount%periodFast;\n            float indexFast = float(residueFast)/float(periodFast);\n            vec3 colorFast = palette2(indexFast);\n            \n            int periodMedium = 20;\n            int residueMedium = iterationAmount%periodMedium;\n            float indexMedium = float(residueMedium)/float(periodMedium);\n            vec3 colorMedium = palette2(indexMedium);\n            \n            int periodSlow = 50;\n            int residueSlow = iterationAmount%periodSlow;\n            float indexSlow = float(residueSlow)/float(periodSlow);\n            vec3 colorSlow = palette2(indexSlow);\n           \n            float finalIndex = (indexSlow + indexMedium + indexFast)*0.333333333;\n            vec3 finalColor = (colorSlow + colorMedium + colorFast)*0.3333333333;\n            fragColor = vec4(finalColor,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}