{"ver":"0.1","info":{"id":"7tlGRS","date":"1624689765","viewed":313,"name":"Gamut Clipping 2","username":"SimonYeung","description":"An updated interactive demo testing the gamut clipping technique for arbitrary color space used for my blog post:\nhttps://simonstechblog.blogspot.com/2021/06/implementing-gamut-mapping.html","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["oklab","gamutclipping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HUE_MODE                               2     // 0= use HUE defined below\n                                                     // 1= use mouse x position as HUE\n                                                     // 2= slowly changing HUE based of time\n#define HUE                                    108.74  // when HUE_MODE == 0, use this defined value for hue, in degree\n#define HUE_CHANGE_SPEED                       30.0  // when HUE_MODE == 2, the speed of HUE change\n#define DISPLAY_SATURATION_MODE                0     // set to 1 to display grey scale saturation\n#define IS_DISPLAY_GAMUT_CUSP_POINT            1\n#define IS_DISPLAY_GAMUT_CLIP_LINE             1\n#define IS_DISPLAY_RGB_COLOR_NEAR_ZERO_LINE    1\n#define IS_DISPLAY_RGB_COLOR_NEAR_ONE_LINE     1\n#define IS_DISPLAY_TEXT_HUE                    1\n#define IS_DISPLAY_TEXT_MOUSE_RGB_SAT          1\n#define IS_DISPLAY_TEXT_PROJECTED_RGB_SAT      1\n#define IS_DISPLAY_TEXT_CUSP_RGB_SAT           1\n#define IS_DISPLAY_OUT_OF_GAMUT_COLOR          0\n#define GAMUT_CLIP_L0                          0.5   // the lightness value projected to\n#define DRAW_SCALE_CL_MIN                      vec2(0.0, -0.05)\n#define DRAW_SCALE_CL_MAX                      vec2(0.5,  1.25)\n\nvec2 pxCoord_to_CL(vec2 pxPos)\n{\n    vec2 CL_range= DRAW_SCALE_CL_MAX - DRAW_SCALE_CL_MIN;\n    return (pxPos / iResolution.xy) * CL_range + DRAW_SCALE_CL_MIN;\n}\n\nvec2 CL_to_pxCoord(vec2 CL)\n{\n    vec2 CL_range= DRAW_SCALE_CL_MAX - DRAW_SCALE_CL_MIN;\n    return ((CL - DRAW_SCALE_CL_MIN)/CL_range)* iResolution.xy;\n}\n\nfloat drawCircleAtLC(vec2 pxCoord, LC circlePosLC, float circleRadius)\n{\n    return drawCircle(pxCoord, CL_to_pxCoord(circlePosLC.yx), circleRadius);\n}\n\nfloat OETF_rec709_f(float val)\n{\n\treturn val < 0.018 ? val * 4.5: 1.099 * pow(val, 0.45) - 0.099;\n}\n\nvec3 OETF_rec709(vec3 val)\n{\n\treturn vec3(OETF_rec709_f(val.r), OETF_rec709_f(val.g), OETF_rec709_f(val.b));\n}\n\n// h in radian\nvec3 oklab_LCh_to_Lab(float L, float C, float h) \n{\n    vec3 Lab;\n    Lab.x = L;\n    Lab.y = C * cos(h);\n    Lab.z = C * sin(h);\n    return Lab;\n}\n\n// h in radian\nvec3 oklab_pxCoord_to_Lab(vec2 pxPos, float h) \n{\n    vec2  CL= pxCoord_to_CL(pxPos);\n    return oklab_LCh_to_Lab(CL.y, CL.x, h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // draw gamut at specific hue\n#if HUE_MODE == 0\n    float hue = degree_to_radian(HUE);\n#elif HUE_MODE == 1\n    float hue = degree_to_radian(iMouse.x/iResolution.x * 360.);\n#else\n    float hue = degree_to_radian(mod(iTime * HUE_CHANGE_SPEED, 360.));\n#endif\n    float cos_h= cos(hue);\n    float sin_h= sin(hue);\n    \n    // convert pixel position to lightness and chroma\n    vec2  CL_px   = pxCoord_to_CL(fragCoord);\n    float sat_px  = CL_px.x / CL_px.y;\n    vec3  oklab_px= oklab_LCh_to_Lab(CL_px.y, CL_px.x, hue);\n    \n    // compute rgb_dir for a given color space\n    vec3 r_lab = rgb_to_oklab(vec3(1,0,0));\n    vec3 g_lab = rgb_to_oklab(vec3(0,1,0));\n    vec3 b_lab = rgb_to_oklab(vec3(0,0,1));\n\n    float r_h = atan(r_lab.z, r_lab.y);\n    float g_h = atan(g_lab.z, g_lab.y);\n    float b_h = atan(b_lab.z, b_lab.y);\n\n    vec2 r_dir = 0.5*vec2(cos(b_h)+cos(g_h), sin(b_h)+sin(g_h));\n    vec2 g_dir = 0.5*vec2(cos(b_h)+cos(r_h), sin(b_h)+sin(r_h));\n    vec2 b_dir = 0.5*vec2(cos(r_h)+cos(g_h), sin(r_h)+sin(g_h));\n    \n    r_dir /= dot(r_dir, r_dir);\n    g_dir /= dot(g_dir, g_dir);\n    b_dir /= dot(b_dir, b_dir);\n    \n    // find gamut cusp\n    LC    cusp    = find_cusp(cos_h, sin_h, r_dir, g_dir, b_dir);\n    \n    // project out of gamut point back to gamut boundary\n    LC    ProjectPtFrom= pxCoord_to_CL(iMouse.xy).yx;\n    LC    ProjectPtTo  = LC(GAMUT_CLIP_L0, 0);  // can also use cusp.x if want to project to lightness of cusp\n\tfloat t            = find_gamut_intersection(cos_h, sin_h, ProjectPtFrom.x, ProjectPtFrom.y, ProjectPtTo.x, r_dir, g_dir, b_dir);\n\tfloat L_clipped    = ProjectPtTo.x * (1. - t) + t * ProjectPtFrom.x;\n\tfloat C_clipped    = t * ProjectPtFrom.y;\n    LC    LC_clipped   = LC(L_clipped, C_clipped);\n    vec3  projectedRGB = oklab_to_rgb( vec3(L_clipped, C_clipped * cos_h, C_clipped * sin_h));\n    \n    // convert pixel color to RGB space\n    vec3 lin_RGB       = oklab_to_rgb(oklab_px);\n    vec3 clipped_RGB   = clamp(lin_RGB, 0., 1.);\n    \n    // compute output color\n    float epsilon0= 0.0025 * pow(clamp(CL_px.y, 0., 1.), 1.5);  // scale down epsilon when close to zero\n    bool isAnyChannelCloseToZeroR=abs(lin_RGB.r) < epsilon0;\n    bool isAnyChannelCloseToZeroG=abs(lin_RGB.g) < epsilon0;\n    bool isAnyChannelCloseToZeroB=abs(lin_RGB.b) < epsilon0;\n    \n    float epsilon1= 0.005;\n    bool isAnyChannelCloseToOneR= abs(lin_RGB.r-1.) < epsilon1;\n    bool isAnyChannelCloseToOneG= abs(lin_RGB.g-1.) < epsilon1;\n    bool isAnyChannelCloseToOneB= abs(lin_RGB.b-1.) < epsilon1;\n    \n    bool isOutOfGamut=  lin_RGB.r != clipped_RGB.r ||\n                        lin_RGB.g != clipped_RGB.g ||\n                        lin_RGB.b != clipped_RGB.b ;\n#if IS_DISPLAY_RGB_COLOR_NEAR_ZERO_LINE\n    if (isAnyChannelCloseToZeroR)\n        fragColor = vec4(.4,0.,0.,1.);\n    else if (isAnyChannelCloseToZeroG)\n        fragColor = vec4(0.,.35,0.,1.);\n    else if (isAnyChannelCloseToZeroB)\n        fragColor = vec4(0.,0.,.45,1.);\n    else\n#endif\n#if IS_DISPLAY_RGB_COLOR_NEAR_ONE_LINE\n    if (isAnyChannelCloseToOneR)\n        fragColor = vec4(1.,0.,0.,1.);\n    else if (isAnyChannelCloseToOneG)\n        fragColor = vec4(0.,1.,0.,1.);\n    else if (isAnyChannelCloseToOneB)\n        fragColor = vec4(0.,0.,1.,1.);\n    else\n#endif\n#if !IS_DISPLAY_OUT_OF_GAMUT_COLOR\n    if(isOutOfGamut)  // out of gamut\n        fragColor = vec4(0.5,0.5,0.5,1.);\n    else\n#endif\n    {\n        // within gamut\n#if DISPLAY_SATURATION_MODE\n        \n        fragColor = vec4(sat_px, sat_px, sat_px, 1.);\n#else\n        // as we are interested in gamut intersection, but not the display color, \n        // so just use the rec709 OETF and don't bother to use the actual display OETF\n        // for simplicity\n        fragColor = vec4(OETF_rec709(clipped_RGB), 1.);\n#endif\n    }\n\n    // draw current HUE in upper right corner\n#if IS_DISPLAY_TEXT_HUE\n    fragColor+=drawFloat(fragCoord-vec2(iResolution.x - 80., iResolution.y - 20.), radian_to_degree(hue), 3.0,2.0);\n#endif\n\n    // draw RGB + saturation at mouse position at the lowest line\n#if IS_DISPLAY_TEXT_MOUSE_RGB_SAT\n    vec2 oklab_mouse_CL= pxCoord_to_CL(iMouse.xy);\n    vec3 oklab_mouse   = oklab_LCh_to_Lab(oklab_mouse_CL.y, oklab_mouse_CL.x, hue);\n    vec3 lin_RGB_mouse= oklab_to_rgb(oklab_mouse);\n    float sat_mouse= oklab_mouse_CL.x / oklab_mouse_CL.y;\n    fragColor+=drawFloat(fragCoord-vec2(000.0, 0.0), lin_RGB_mouse.r, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(100.0, 0.0), lin_RGB_mouse.g, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(200.0, 0.0), lin_RGB_mouse.b, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(350.0, 0.0), sat_mouse, 1.0,4.0);\n#endif\n    \n    // draw RGB + saturation at projected gamut clipped position at the second lowest line\n#if IS_DISPLAY_TEXT_PROJECTED_RGB_SAT\n    float sat_project= C_clipped / L_clipped;\n    fragColor+=drawFloat(fragCoord-vec2(000.0, 20.0), projectedRGB.r, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(100.0, 20.0), projectedRGB.g, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(200.0, 20.0), projectedRGB.b, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(350.0, 20.0), sat_project, 1.0,4.0);\n#endif\n    \n    // draw RGB + saturation at cusp at the third lowest line\n#if IS_DISPLAY_TEXT_CUSP_RGB_SAT\n    vec3  lin_RGB_cusp= oklab_to_rgb(oklab_LCh_to_Lab(cusp.x, cusp.y, hue));\n    float sat_cusp     = cusp.y / cusp.x;\n    fragColor+=drawFloat(fragCoord-vec2(000.0, 40.0), lin_RGB_cusp.r, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(100.0, 40.0), lin_RGB_cusp.g, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(200.0, 40.0), lin_RGB_cusp.b, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(350.0, 40.0), sat_cusp, 1.0,4.0);\n#endif\n    \n    // draw gamut cusp\n#if IS_DISPLAY_GAMUT_CUSP_POINT\n    fragColor+= drawCircleAtLC(fragCoord, cusp, 3.0);\n#endif\n\n    // draw mouse position, gamut project to position and gamut clipped position\n#if IS_DISPLAY_GAMUT_CLIP_LINE\n    fragColor+= drawCircleAtLC(fragCoord, ProjectPtFrom, 3.0);\n    fragColor+= drawCircleAtLC(fragCoord, ProjectPtTo  , 3.0);\n    fragColor+= drawCircleAtLC(fragCoord, LC_clipped   , 3.0);\n    \n    // draw project line\n    fragColor+= sdLine(fragCoord, CL_to_pxCoord(LC_clipped.yx), CL_to_pxCoord(ProjectPtTo.yx))*0.2;\n    fragColor+= sdLine(fragCoord, CL_to_pxCoord(ProjectPtFrom.yx), CL_to_pxCoord(ProjectPtTo.yx));\n#endif\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define COLOR_SPACE    COLOR_SPACE_P3_D65    // choose color space from below macro\n\n#define COLOR_SPACE_sRGB      1\n#define COLOR_SPACE_P3_D65    2\n#define COLOR_SPACE_AdobeRGB  3\n#define COLOR_SPACE_Rec2020   4\n#define COLOR_SPACE_ACEScg    5\n\n#if COLOR_SPACE == COLOR_SPACE_sRGB\n// sRGB\n#define COLOR_PRIMARIES ColorPrimaries(vec2(0.64f, 0.33f), vec2(0.3f, 0.6f), vec2(0.15f, 0.06f), vec2(0.3127f, 0.329f))\n#define NEED_WHITE_POINT_CAT    0\n\n#elif COLOR_SPACE == COLOR_SPACE_P3_D65\n// P3 D65\n#define COLOR_PRIMARIES ColorPrimaries(vec2(0.68f\t, 0.32f\t\t), vec2(0.265f\t, 0.69f\t), vec2(0.15f\t, 0.06f\t\t), vec2(0.3127f\t, 0.329f\t))\n#define NEED_WHITE_POINT_CAT    0\n\n#elif COLOR_SPACE == COLOR_SPACE_AdobeRGB\n// AdobeRGB\n#define COLOR_PRIMARIES ColorPrimaries(vec2(0.64f\t, 0.33f\t\t), vec2(0.21f\t, 0.71f\t), vec2(0.15f\t, 0.06f\t\t), vec2(0.3127f\t, 0.329f\t))\n#define NEED_WHITE_POINT_CAT    0\n\n#elif COLOR_SPACE == COLOR_SPACE_Rec2020\n// Rec2020\n#define\t COLOR_PRIMARIES ColorPrimaries(vec2(0.708f\t, 0.292f\t), vec2(0.17f\t, 0.797f), vec2(0.131f\t, 0.046f\t), vec2(0.3127f\t, 0.329f\t))\n#define NEED_WHITE_POINT_CAT    0\n\n#elif COLOR_SPACE == COLOR_SPACE_ACEScg\n// ACEScg\n#define\t COLOR_PRIMARIES ColorPrimaries(vec2(0.713f\t, 0.293f\t), vec2(0.165f\t, 0.830f), vec2(0.128f\t, 0.044f\t), vec2(0.32168f, 0.33767f\t))\n#define NEED_WHITE_POINT_CAT    1  // ACES use a white point near D60, which is different from Oklab D65, so need chromatic adaptation\n\n#else\nUnknown COLOR_SPACE, please define the COLOR_PRIMARIES and NEED_WHITE_POINT_CAT\n#endif\n\n\n#define OKLAB_WHITE_POINT   vec2(0.3127f, 0.329f)\n\n#define mtx_XYZ_OklabLMS\ttranspose(mat3(\t0.8189330101, 0.3618667424, -0.1288597137,\\\n                                            0.0329845436, 0.9293118715,  0.0361456387,\\\n                                            0.0482003018, 0.264366269 ,  0.6338517070))\n#define mtx_OklabLMS_XYZ\ttranspose(mat3(\t1.227013851103521026    ,  -0.5577999806518222383 ,  0.28125614896646780758, \\\n                                            -0.040580178423280593977,   1.1122568696168301049 ,  -0.071676678665601200577, \\\n                                            -0.076381284505706892869,  -0.42148197841801273055,  1.5861632204407947575 ))\n                                    \n#define PI     3.14159265359\n\n// some of the function are borrowed from the following shader toy source code\n// https://www.shadertoy.com/view/wdXBDS\n// https://www.shadertoy.com/view/WlGyDG\n// https://www.shadertoy.com/view/4lGSzV\n\nfloat degree_to_radian(float deg)\n{\n    return deg * (PI /180.0);\n}\n\nfloat radian_to_degree(float rad)\n{\n    return rad * (180.0/PI);\n}\n\nfloat sdLine(in vec2 p,in vec2 a,in vec2 b)\n{\n    /// Project p onto the line ab, then return the distance from p` to p\n    \n\t// Use a as 'origin'\n    vec2 origin = a;    \n    vec2 p2 = p-origin;\n    vec2 b2 = b-origin;\n\n    // Compute the dot product of vectors and divide to get the ratio\n\tfloat lineRatio = dot(p2, b2)/dot(b2, b2);\n\n    // Clamp the ratio between 0.0 and 1.0\n    lineRatio = clamp(lineRatio, 0., 1.);\n\n    // Nearest point on AB\n    vec2 pointOnLine = b2*lineRatio;\n\n    // Return distance from line to point\n    return 1. - step(0.5, length(p2 - pointOnLine));\n}\n\n\n#define RESOLUTION .3\n\n// based on works of TimoKinnunen\n// draws float <value> at iDrawCoord-<charCoord>\n// works fine, but not for big decimals\nfloat drawFloat(in vec2 charCoord, float value,\n\t\tfloat digits, float decimals)\n{        \n    // round to closest dp\n    float dp_multiplier= pow(10., decimals);\n    value= round(value * dp_multiplier) / dp_multiplier;\n    \n\tcharCoord *= RESOLUTION*RESOLUTION;\n\tfloat bits = 0.;\n\tif(charCoord.y < 0. || charCoord.y >= 1.5 || charCoord.x < step(-value,0.)) return bits;\n\tfloat digitIndex = digits - floor(charCoord.x)+ 1.;\n\tif(- digitIndex <= decimals) {\n\t\tfloat pow1 = pow(10., digitIndex);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.;\n\t\tif(pivot < pow1) bits = 1792.*float(value < 0. && pivot >= pow1 * .1);\n\t\telse if(digitIndex == 0.) bits = 2.*float(decimals > 0.);\n\t\telse {\n        \tvalue = digitIndex < 0. ? fract(absValue) : absValue * 10.;\n            int x=int (mod(value / pow1, 10.));\n\t\t\tbits = x==0?480599.:x==1?139810.:x==2?476951.:x==3?476999.:x==4?350020.:x==5?464711.:x==6?464727.:x==7?476228.:x==8?481111.:x==9?481095.:0.;\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2., floor(fract(charCoord.x) * 4.) + floor(charCoord.y * 4.) * 4.), 2.));\n}\n\nfloat drawCircle(vec2 pxCoord, vec2 circlePos, float circleRadius)\n{\n    return float(length(pxCoord - circlePos) <= circleRadius);\n}\n\nstruct ColorPrimaries\n{\n\tvec2\tred;\n\tvec2\tgreen;\n\tvec2\tblue;\n\tvec2\twhite;\n};\n\nvec3\txyY_to_XYZ(vec3 color)\n{\n\tfloat x= color.x;\n\tfloat y= color.y;\n\tfloat Y= color.z;\n\treturn vec3(x*Y/y, Y, (1.0f - x - y)*Y/y);\n}\n\nvec3\txyY_to_XYZ(vec2 xy, float Y)\n{\n\treturn xyY_to_XYZ(vec3(xy, Y));\n}\n\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\nmat3\tcolorSpace_to_XYZ(ColorPrimaries colorPrimaries, float whitePointY)\n{\n\tvec3 XYZr= xyY_to_XYZ(colorPrimaries.red\t, 1.0f);\n\tvec3 XYZg= xyY_to_XYZ(colorPrimaries.green\t, 1.0f);\n\tvec3 XYZb= xyY_to_XYZ(colorPrimaries.blue\t, 1.0f);\n\tvec3 XYZw= xyY_to_XYZ(colorPrimaries.white\t, whitePointY);\n\n\tvec3 S= inverse(mat3(XYZr, XYZg, XYZb)) * XYZw;\n\treturn mat3(XYZr * S.x, XYZg * S.y, XYZb * S.z);\n}\n\nmat3\tXYZ_to_colorSpace(ColorPrimaries colorPrimaries, float whitePointY)\n{\n    return inverse(colorSpace_to_XYZ(colorPrimaries, whitePointY));\n}\n\n// Chromatic Adaptation transformation between differnt white point,\n// http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html\nmat3 mtx_CAT(vec2 chromaticityWhiteDest, vec2 chromaticityWhiteSrc)\n{\n\t// cone response matrix BardFord\n\tconst mat3 Ma= transpose(mat3(\t 0.89510f,  0.26640f, -0.16140f,\n                                    -0.75020f,  1.71350f,  0.03670f,\n                                     0.03890f, -0.06850f,  1.02960f));\n\tconst mat3 MaInv= inverse(Ma);\n  \n\tvec3 src_XYZ = xyY_to_XYZ( chromaticityWhiteSrc\t, 1.0f );\n\tvec3 des_XYZ = xyY_to_XYZ( chromaticityWhiteDest, 1.0f );\n\n\tvec3 src_coneResp = Ma * src_XYZ;\n\tvec3 des_coneResp = Ma * des_XYZ;\n\n\tmat3 vkMat= transpose(mat3( des_coneResp.x / src_coneResp.x , 0.0f\t\t\t\t\t\t\t\t, 0.0f,\n                                0.0f\t\t\t\t\t\t\t, des_coneResp.y / src_coneResp.y\t, 0.0 ,\n                                0.0f\t\t\t\t\t\t\t, 0.0\t\t\t\t\t\t\t\t, des_coneResp.z / src_coneResp.z ));\n\t\n\treturn MaInv * vkMat * Ma;\n}\n                                    \nmat3 mtx_rgb_to_oklabLMS()\n{\n    mat3 mtx_RGB_XYZ= colorSpace_to_XYZ(COLOR_PRIMARIES, 1.0);\n#if NEED_WHITE_POINT_CAT\n    mat3 CAT= mtx_CAT(OKLAB_WHITE_POINT, COLOR_PRIMARIES.white);\n    mat3 mtx_RGB_OklabLMS= mtx_XYZ_OklabLMS * CAT * mtx_RGB_XYZ;\n#else\n    mat3 mtx_RGB_OklabLMS= mtx_XYZ_OklabLMS * mtx_RGB_XYZ;\n#endif\n    return mtx_RGB_OklabLMS;\n}\n          \nmat3 mtx_oklabLMS_to_rgb()\n{\n    mat3 mtx_XYZ_RGB= XYZ_to_colorSpace(COLOR_PRIMARIES, 1.0);\n#if NEED_WHITE_POINT_CAT\n    mat3 CAT= mtx_CAT(COLOR_PRIMARIES.white, OKLAB_WHITE_POINT);\n    mat3 mtx_OklabLMS_RGB= mtx_XYZ_RGB * CAT * mtx_OklabLMS_XYZ;\n#else\n    mat3 mtx_OklabLMS_RGB= mtx_XYZ_RGB * mtx_OklabLMS_XYZ;\n#endif\n    return mtx_OklabLMS_RGB;\n}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    mat3 mtx_RGB_OklabLMS= mtx_rgb_to_oklabLMS();\n    \n    float l = mtx_RGB_OklabLMS[0][0] * c.r + mtx_RGB_OklabLMS[1][0] * c.g + mtx_RGB_OklabLMS[2][0] * c.b;\n    float m = mtx_RGB_OklabLMS[0][1] * c.r + mtx_RGB_OklabLMS[1][1] * c.g + mtx_RGB_OklabLMS[2][1] * c.b;\n    float s = mtx_RGB_OklabLMS[0][2] * c.r + mtx_RGB_OklabLMS[1][2] * c.g + mtx_RGB_OklabLMS[2][2] * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    mat3 mtx_OklabLMS_RGB= mtx_oklabLMS_to_rgb();\n    \n    vec3 rgbResult;\n    rgbResult.r = mtx_OklabLMS_RGB[0][0] *l + mtx_OklabLMS_RGB[1][0] *m + mtx_OklabLMS_RGB[2][0] *s;\n    rgbResult.g = mtx_OklabLMS_RGB[0][1] *l + mtx_OklabLMS_RGB[1][1] *m + mtx_OklabLMS_RGB[2][1] *s;\n    rgbResult.b = mtx_OklabLMS_RGB[0][2] *l + mtx_OklabLMS_RGB[1][2] *m + mtx_OklabLMS_RGB[2][2] *s;\n    \n    return rgbResult;\n}\n\n// asume cubic equation with a=1\nfloat solve_cubic_halley(float x, float b, float c, float d)\n{\n\tfloat f0 = x*x*x + b *x*x + c*x +d;\n\tfloat df1= 3.0f * x * x + 2.0f * b *x + c;\n\tfloat df2= 6.0f * x  + 2.0f * b;\n\tx= x - (f0 * df1)/(df1*df1 - 0.5f * f0*df2);\n    \n\treturn x;\n}\n\n// asume cubic equation with a=1\nfloat solve_cubic_newton(float x, float b, float c, float d)\n{\n\tfloat f0 = x*x*x + b *x*x + c*x +d;\n\tfloat df1= 3.0f * x * x + 2.0f * b *x + c;\n\tx= x - (f0/df1);\n\treturn x;\n}\n\nfloat solve_cubic_numerical(float a, float b, float c, float d)\n{\n    b/=a;\n    c/=a;\n    d/=a;\n    \n    // 1 step of Halley + 1 step of Newton may be enough for small gamut like sRGB, AdobeRGB, DCI P3\n    // larger gamut need more steps, especially at some blue hue\n    float x= 0.4;  // initial guess\n\tx= solve_cubic_halley(x, b, c, d);\n    x= solve_cubic_newton(x, b, c, d);\n    return x;\n}\n\n// solve cubic eqt and only pick the 3rd root https://stackoverflow.com/questions/13328676/c-solving-cubic-equations\n// and return only the minimum positive real root (which is our use case) \nfloat solve_cubic(float a, float b, float c, float d)\n{\n    b/=a;\n    c/=a;\n    d/=a;\n\n    float q = (3.0/9.0)*c - ( (1.0/9.0) *b*b);\n    float r = (-27.0/54.0)*d + b*((9.0/54.0)*c - (2.0/54.0)*(b*b));\n    float disc = q*q*q + r*r;\n\n    float term1 = b* (1.0/3.0);\n\n    float x1_re= 0.0;\n    float x2_re= 0.0;\n    float x3_re= 0.0;\n    float x;\n    if (disc > 0.0)\n    {\n        // one root real, two are complex\n        float s = r + sqrt(disc);\n        s = sign(s) * pow(abs(s), 1.0/3.0);\n        float t = r - sqrt(disc);\n        t = sign(t) * pow(abs(t), 1.0/3.0);\n        x1_re = -term1 + s + t;\n        term1 += (s + t)/2.0;\n        x2_re = -term1;\n        x3_re = -term1;\n        term1 = sqrt(3.0)*(-t + s)/2.0;\n        \n        x= x1_re; // only pick the real root for our use case\n    }\n    else\n    {\n        // The remaining options are all real\n        q= -q;\n        float dum1= q*q*q;\n        dum1= acos( clamp(r/sqrt(dum1) , -1.0, 1.0) );\n        float r13= 2.0 * sqrt(q);\n\n        x1_re= -term1 + r13 * cos(dum1 * (1.0/3.0));\n        x2_re= -term1 + r13 * cos(dum1 * (1.0/3.0) + (2.0*PI/3.0));\n        x3_re= -term1 + r13 * cos(dum1 * (1.0/3.0) + (4.0*PI/3.0));\n\n        x= 1.0f/max(1.0f/x1_re, max(1.0f/x2_re, 1.0f/x3_re)); // pick the minimum non negative for our use case\n    }\n\n    // perform Halley's method to fix floating point precision error at some hue (e.g. 232.59 degree)    \n    x= solve_cubic_halley(x, b, c, d);\n\treturn x;\n}\n\n// Finds the maximum saturation possible for a given hue that fits in given RGB space\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b, vec2 r_dir, vec2 g_dir, vec2 b_dir)\n{\n    // solve the max saturation value analytically\n    float A= 0.3963377774;\n    float B= 0.2158037573;\n    float C= -0.1055613458;\n    float D= -0.0638541728;\n    float E= -0.0894841775;\n    float F= -1.2914855480;\n\n    vec2 ab= vec2(a, b);\n    \n    float Aa_Bb  = A * a + B * b;\n    float Aa_Bb_2= Aa_Bb * Aa_Bb;\n    float Aa_Bb_3= Aa_Bb * Aa_Bb_2;\n\n    float Ca_Db= C * a + D * b;\n    float Ca_Db_2= Ca_Db * Ca_Db;\n    float Ca_Db_3= Ca_Db * Ca_Db_2;\n\n    float Ea_Fb= E * a + F * b;\n    float Ea_Fb_2= Ea_Fb * Ea_Fb;\n    float Ea_Fb_3= Ea_Fb * Ea_Fb_2;\n    \n    float kl, km, ks;\n    mat3 mtx_OklabLMS_RGB= mtx_oklabLMS_to_rgb();\n    if (dot(r_dir, ab)> 1.)\n    {\n        // Red component\n        kl= mtx_OklabLMS_RGB[0][0];\n        km= mtx_OklabLMS_RGB[1][0];\n        ks= mtx_OklabLMS_RGB[2][0];\n    }\n    else if (dot(g_dir, ab) > 1.)\n    {\n        // Green component\n        kl= mtx_OklabLMS_RGB[0][1];\n        km= mtx_OklabLMS_RGB[1][1];\n        ks= mtx_OklabLMS_RGB[2][1];\n    }\n    else\n    {\n        // Blue component\n        kl= mtx_OklabLMS_RGB[0][2];\n        km= mtx_OklabLMS_RGB[1][2];\n        ks= mtx_OklabLMS_RGB[2][2];\n    }\n\n    float coef3=        kl * Aa_Bb_3 + km * Ca_Db_3  + ks * Ea_Fb_3 ;\n    float coef2= 3.0 * (kl * Aa_Bb_2 + km * Ca_Db_2  + ks * Ea_Fb_2);\n    float coef1= 3.0 * (kl * Aa_Bb   + km * Ca_Db    + ks * Ea_Fb  );\n    float coef0=        kl           + km            + ks;\n    float S= solve_cubic(coef3, coef2, coef1, coef0);\n    //float S= solve_cubic_numerical(coef3, coef2, coef1, coef0);\n    \n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\n#define LC vec2\nLC find_cusp(float a, float b, vec2 r_dir, vec2 g_dir, vec2 b_dir)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b, r_dir, g_dir, b_dir);\n\n\t// Convert to linear RGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_rgb(vec3( 1., S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = pow(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b), 1./3.);\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn LC( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 r_dir, vec2 g_dir, vec2 b_dir)\n{   \n    float cosh= a;\n    float sinh= b; // save the value here as b is redefined when using Halley's method...\n    vec2 ab= vec2(a, b);\n\n\t// Find the cusp of the gamut triangle\n\tLC cusp = find_cusp(a, b, r_dir, g_dir, b_dir);\n\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\t\t\t\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3. * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3. * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3. * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6. * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6. * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6. * s_dt * s_dt * s_;\n\n                mat3 mtx_OklabLMS_RGB= mtx_oklabLMS_to_rgb();\n\n\t\t\t\tfloat r = mtx_OklabLMS_RGB[0][0] * l    + mtx_OklabLMS_RGB[1][0] * m    + mtx_OklabLMS_RGB[2][0] * s - 1.;\n\t\t\t\tfloat r1= mtx_OklabLMS_RGB[0][0] * ldt  + mtx_OklabLMS_RGB[1][0] * mdt  + mtx_OklabLMS_RGB[2][0] * sdt;\n\t\t\t\tfloat r2= mtx_OklabLMS_RGB[0][0] * ldt2 + mtx_OklabLMS_RGB[1][0] * mdt2 + mtx_OklabLMS_RGB[2][0] * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g  = mtx_OklabLMS_RGB[0][1] * l    + mtx_OklabLMS_RGB[1][1] * m    + mtx_OklabLMS_RGB[2][1] * s - 1.;\n\t\t\t\tfloat g1 = mtx_OklabLMS_RGB[0][1] * ldt  + mtx_OklabLMS_RGB[1][1] * mdt  + mtx_OklabLMS_RGB[2][1] * sdt;\n\t\t\t\tfloat g2 = mtx_OklabLMS_RGB[0][1] * ldt2 + mtx_OklabLMS_RGB[1][1] * mdt2 + mtx_OklabLMS_RGB[2][1] * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b  = mtx_OklabLMS_RGB[0][2] * l    + mtx_OklabLMS_RGB[1][2] * m    + mtx_OklabLMS_RGB[2][2] * s - 1.;\n\t\t\t\tfloat b1 = mtx_OklabLMS_RGB[0][2] * ldt  + mtx_OklabLMS_RGB[1][2] * mdt  + mtx_OklabLMS_RGB[2][2] * sdt;\n\t\t\t\tfloat b2 = mtx_OklabLMS_RGB[0][2] * ldt2 + mtx_OklabLMS_RGB[1][2] * mdt2 + mtx_OklabLMS_RGB[2][2] * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n                float FLT_MAX= 3.402823466e+38;\n#if 0 // check all 3 clipping lines\n\t\t\t\tt_r = u_r >= 0.f ? t_r : FLT_MAX;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : FLT_MAX;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : FLT_MAX;\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n#else // only check 2 upper clipping lines is enough\n                if (dot(r_dir, ab)> 1.)\n                {\n                    // Red component\n                    t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                    t_b = u_b >= 0.f ? t_b : FLT_MAX;\n                    t += min(t_g, t_b);\n                }\n                else if (dot(g_dir, ab) > 1.)\n                {\n                    // Green component\n                    t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                    t_b = u_b >= 0.f ? t_b : FLT_MAX;\n                    t += min(t_r, t_b);\n                }\n                else\n                {\n                    // Blue component\n                    t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                    t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                    t += min(t_r, t_g);\n                }\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}","name":"Common","description":"","type":"common"}]}