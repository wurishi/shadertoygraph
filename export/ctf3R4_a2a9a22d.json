{"ver":"0.1","info":{"id":"ctf3R4","date":"1671708688","viewed":143,"name":"Inverse Kinematics Tutorial","username":"EisernSchild","description":"Sample source code for the Tutorial by Alan Zucconi :\n    https://www.alanzucconi.com/2018/05/02/ik-2d-1/\n    https://www.alanzucconi.com/2020/09/14/inverse-kinematics-in-3d/\n","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","inversekinematics","skinning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inverse Kinematics Tutorial\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n    Inverse Kinematics Tutorial\n        \n    Here we have an excellent tutorial on the basis of inverse \n    kinematics written by Alan Zucconi.\n    \n    Read both pages (Part 1 and 3 on the site) to see what is\n    actually done in the following method.\n    \n    Tutorial by Alan Zucconi :\n    https://www.alanzucconi.com/2018/05/02/ik-2d-1/\n    https://www.alanzucconi.com/2020/09/14/inverse-kinematics-in-3d/\n*/\n\n// ################# TUTORIAL CODE\n\nvoid IK_EndEffectorToTargetAngles(\n    in vec3 vTar,     /* <= base to target local vector */\n    in float fA,      /* <= length of bone 1 */\n    in float fB,      /* <= length base->target (=length(vTar)) */\n    in float fC,      /* <= length of bone 0 */\n    out float fAlpha, /* <= local space rotation Z angle base joint */\n    out float fBeta,  /* <= local space rotation Z angle mid joint */\n    out float fGamma) /* <= local space rotation Y angle base joint */\n{\n    // triangle angles\n    \n    // arccos(b*b + c*c - a*a) / 2bc\n    fAlpha = acos((fB * fB + fC * fC - fA * fA) / (2.f * fB * fC) );\n    // arccos(a*a + c*c - b*b) / 2ac\n    fBeta = acos((fA * fA + fC * fC - fB * fB) / (2.f * fA * fC) );\n        \n    // triangle angles to local angles\n    \n    // arctan(cy-dy / length(ad))\n    fAlpha = fAlpha + atan(vTar.y/ length(vTar.xz));\n    // PI - beta\n    fBeta = abs(PI - fBeta);\n    \n    // Y rotation\n    \n    // -arctan(z / y)\n    fGamma = -atan(vTar.z / vTar.x);\n    fGamma = (vTar.x < 0.f) ? PI + fGamma: fGamma;    \n}\n\n// ################# IMPLEMENTATION\n\n// ray hit attribute\nstruct PosNorm\n{\n\tvec3 vPosition;\n\tvec3 vNormal;\n};\n\n// intersection\nstruct Intersection\n{\n    // hit entry, exit (T + position)\n    vec4 vTen, vTex;\n    // normal entry, exit\n    vec3 vNen, vNex;\n};\n\nIntersection iPlane(in vec3 vOri, in vec3 vDir)\n{\n    // ortho project up-origin/up-dir\n    float fT = -vOri.y/vDir.y;\n    vec3 vHPos = vOri + fT * vDir;\n    \n    return Intersection( vec4(fT, vHPos), \n                        vec4(-fT, vHPos),\n                        vec3(0.f, 1.f, 0.f),\n                        vec3(0.f, -1.f, 0.f));\n}\n\nIntersection iSphere(in vec3 vOri, in vec3 vDir, in vec3 vCen, float fRad)\n{\n    // get local origin\n    vec3 vOriL = vOri - vCen;\n    \n    // ortho project local origin->direction\n    float fOD = dot(vOriL, vDir);\n    \n    // square distance origin->center minus radius\n    float fOR = dot(vOriL, vOriL) - fRad*fRad;\n    \n    // square hit center (!)\n    float fTHitS = fOD*fOD - fOR;\n    \n    // no intersection\n    Intersection sRet = Intersection( vec4(-1.f), vec4(-1.f), vec3(0.f), vec3(0.f));\n    if( fTHitS < .0f ) return sRet;\n    \n    // hit distance to center disk\n    fTHitS = sqrt(fTHitS);\n    \n    // hit vector + position\n    sRet.vTen.x = -fOD - fTHitS;\n    sRet.vTex.x = -fOD + fTHitS;\n    sRet.vTen.yzw = vOri + vDir * sRet.vTen.x;\n    sRet.vTex.yzw = vOri + vDir * sRet.vTex.x;\n    \n    // normals\n    sRet.vNen = normalize(sRet.vTen.yzw - vCen);\n    sRet.vNex = normalize(sRet.vTex.yzw - vCen);\n\n    // return with normals\n    return sRet;\n}\n\n// infinite cylinder by iq : https://iquilezles.org/articles/intersectors/\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// simple checkers\nfloat checkers_001(vec2 vUv, float fDist)\n{\n    return mix(0.3, smoothstep(0.005, 0.005 + fDist * 0.005, min(fract(vUv.x), fract(vUv.y))) * (max(mod(floor(vUv.x), 2.), mod(floor(vUv.y), 2.)) * .25 + .75),\n        (1. - smoothstep(0.995 - fDist * 0.005, 0.995, max(fract(vUv.x), fract(vUv.y)))));\n}\n\n// simple hash float1<-float2\nfloat hash12(vec2 vP)\n{\n\tvec3 vP3  = fract(vec3(vP.xyx) * .1031);\n    vP3 += dot(vP3, vP3.yzx + 33.33);\n    return fract((vP3.x + vP3.y) * vP3.z);\n}\n\n// function from : https://www.shadertoy.com/view/4dsSzr\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\nvec3 hueGradient(float t) {\n    vec3 p = abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);\n\treturn (clamp(p - 1.0, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 cOut, in vec2 vXY )\n{\n    /// ------- CAMERA\n    \n    // get current camera position and lookat matrix\n    float fCamDist = 4.6f;\n    vec4 vCamPos = vec4(sin(iTime * .2f) * fCamDist, 4.5f + sin(iTime * .3f) * .5f, cos(iTime * .2f) * fCamDist, 0.f);\n    vec3 vCamLAt = vec3(0.f, 0.f, 0.f);\n    mat4x4 avLookAt = LookAtLH(vCamPos.xyz, vCamLAt, vec3(0.f, 1.f, 0.f));\n    \n    // get projection matrix\n    mat4x4 avProj = PerspectiveLH(vec2(radians(90.), radians(60.)), vec2(1., 1000.));\n    \n    /// ------- KINEMATICS\n    \n    // here we have 3 joints and 2 bones\n    #define JOINTS_N  3\n    // joint positions, rotations [INOUT]\n    vec3 avJPos[JOINTS_N], asJRot[JOINTS_N];\n    // joint sphere radii, bone lengths [IN]\n    const float afJRad[JOINTS_N] = float[JOINTS_N](0.12f, 0.12f, 0.12f), afBoneL[JOINTS_N - 1] = float[JOINTS_N - 1](1.6f, 1.2f);\n    // end effector joint index\n    // const int nEEIx = JOINTS_N - 1;\n    \n    // set base joint position \n    avJPos[0] = vec3(0.f, .12f, 0.f);\n    // set target position\n    vec3 vTarget = vec3(sin(iTime * .7f), .4f + sin(iTime * 1.2f) * .28f, cos(iTime * .7f)) * vec2(2.f + sin(iTime * .5f) * .5f, 1.f).xyx;\n    \n    // get triangle lengths\n    vec3 vTar = vTarget - avJPos[0];\n    float fA = afBoneL[1];\n    float fB = length(vTar);\n    float fC = afBoneL[0];\n    \n    // angles to local space rotations\n    float fAlpha, fBeta, fGamma;\n    \n    // calculate angles\n    IK_EndEffectorToTargetAngles(vTar, fA, fB, fC, fAlpha, fBeta, fGamma);\n\n    // get joint positions\n    avJPos[1] = avJPos[0] + RotateY(RotateZ(vec3(afBoneL[0], 0.f, 0.f), fAlpha), fGamma); \n    avJPos[2] = avJPos[1] + RotateY(RotateZ(vec3(afBoneL[1], 0.f, 0.f), fAlpha - fBeta), fGamma); \n    \n    /// ------- RAYTRACING\n    \n    // get ray\n    vec3 vOri, vDir;\n    TransformRay(uvec2(vXY), iResolution.xy, \n        vCamPos, inverse(avLookAt * avProj), vOri, vDir);\n    \n    // do raytracing\n    bool bLeftRight = ((vXY.x/iResolution.x) < .5f);\n    Intersection asI[JOINTS_N + 1];\n        \n    asI[0] = iPlane(vOri, vDir);\n    for (int nIx = 0; nIx < JOINTS_N; nIx++)\n        asI[nIx + 1] = iSphere(vOri, vDir, avJPos[nIx], afJRad[nIx]);\n    \n    // get lit primitive index\n    int nTI = 0;\n    float fTHit = asI[0].vTen.x;\n    for(int nI = 1; nI < JOINTS_N + 1; nI++)\n    {\n        if (asI[nI].vTen.x > 0.)\n        {\n            if (fTHit > 0.)\n            {\n                if (asI[nI].vTen.x < fTHit) nTI = nI;\n            }\n            else nTI = nI;\n            \n            fTHit = asI[nTI].vTen.x;           \n        }\n    }\n    \n    // hit attributes\n    PosNorm sAttr;\n    sAttr.vPosition = asI[nTI].vTen.yzw;\n    sAttr.vNormal = asI[nTI].vNen;\n    \n    /// ------- TEXTURE\n    \n    if (nTI == 0) // floor\n    {\n        // simple color triangles for now (hue gradient)\n        float fTile = hash12(HexTriangleF(sAttr.vPosition.xz));\n        cOut = vec4(mix(hueGradient(fTile), vec3(1.f), .7f), 1.f);\n        cOut.xyz *= checkers_001(sAttr.vPosition.xz * 2., fTHit);\n        \n        // draw a target marker\n        float fTarD = length(sAttr.vPosition.xz - vTarget.xz);\n        if (fTarD < .08f) cOut = mix(cOut, vec4(1.f, 1.f, .0f, 1.f), fTarD / .08f); \n    }\n    else\n        cOut = vec4(1.f, 1.f, 1.f, 1.f);\n    \n    /// ------- LIGHTING \n    \n    vec3 cLit = Phong_PointLight(sAttr.vPosition, vCamLAt + vec3(1.f, 3.f, .5f), vOri, cOut.xyz, vDir, sAttr.vNormal);\n\n    // occlusion (distance, ground)\n    float fOcc = (1. - fTHit * .01);\n    float fOccD = 0.f;\n    if (nTI == 0)\n        for(int nI = 0; nI < JOINTS_N; nI++)\n        {\n            float fDXZ = length(sAttr.vPosition.xz - avJPos[nI].xz);\n            if (fDXZ < afJRad[nI])\n                fOccD = (avJPos[nI].y < afJRad[nI] + .32f) ? max(fOccD, ((afJRad[nI] - fDXZ) / (afJRad[nI] * .5f)) * (afJRad[nI] + .32f - avJPos[nI].y)) : fOccD;\n        }\n    fOcc -= fOccD;\n    cLit *= fOcc;\n    \n    /// ------- BONE LASER BEAMS\n    \n    for(int nI = 0; nI < JOINTS_N - 1; nI++)\n    {\n        // get infinite cylinder\n        vec2 vTHitB = cylIntersect(vOri, vDir, avJPos[nI], normalize(avJPos[nI + 1] - avJPos[nI]), .01f);\n        if ((vTHitB.x > 0.f) && (vTHitB.x < fTHit))\n        {\n            // clamp cylinder between joints\n            float fTHitB = (vTHitB.x + vTHitB.y) * .5f;\n            vec3 vPB = vOri + vDir * fTHitB;\n            float fBA = length(avJPos[nI] - vPB);\n            float fBB = length(avJPos[nI + 1] - vPB);\n            float fAB = length(avJPos[nI] - avJPos[nI + 1]);\n            if ((fBA < fAB) && (fBB < fAB))\n                cLit = mix(cLit, vec3(.0f, 1.f, .0f), pow(abs(vTHitB.x - min(vTHitB.y, fTHit)) / .02f, 1.2f) * .1f);\n            else\n                cLit.r *= 1.2f;\n        }\n    }\n    \n\tcOut = vec4(clamp(cLit, 0.f, 1.f), 1.f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// EisernSchild 3D library\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n// uses code with following rights :\n// Copyright (c) Microsoft\n// \n// SPDX-License-Identifier: MIT\n\n#define PI 3.141592654f\n\n// Hex Grid Library #####################################################\n\n/// Cartesian to hex coordinates\nvec2 HexUV(vec2 vXy)\n{\n\t// hex coords       (u, v) = (          .5 * x + .5 * y,        y ) \n\t// hex coord scaled (u, v) = ((sqrt(3.f) * x + y) / 3.f, y / 1.5f )\n\treturn vec2( (sqrt(3.f) * vXy.x + vXy.y) / 3.f, vXy.y / 1.5f );\n}\n\n// cartesian to hex triangle index (float)\nvec2 HexTriangleF(vec2 vXy)\n{\n    // get hex uv global + local\n    vec2 vHUv = HexUV(vXy);\n    vec2 vHUvL = mod(vHUv, 1.);\n    float fIx = floor(vHUv.x) * 2.;\n    fIx += (vHUvL.x > vHUvL.y) ? 1. : 0.;\n    return vec2(fIx, floor(vHUv.y));\n}\n\n// Transform Library #####################################################\n\n// y rotation matrix\nmat3 Rotate3dY(float fAng) \n{\n  float fS = sin(fAng);\n  float fC = cos(fAng);\n\n  return mat3(\n    fC, 0.0, -fS,\n    0.0, 1.0, 0.0,\n    fS, 0.0, fC\n  );\n}\n\n// z rotation matrix\nmat3 Rotate3dZ(float fAng) \n{\n  float fS = sin(fAng);\n  float fC = cos(fAng);\n\n  return mat3(\n    fC, fS, 0.f,\n    -fS, fC, 0.f,\n    0.f, 0.f, 1.f\n  );\n}\n\n// rotate vector by y axis\nvec3 RotateY(vec3 v, float fAng) \n{\n  return Rotate3dY(fAng) * v;\n}\n\n// rotate vector by z axis\nvec3 RotateZ(vec3 v, float fAng) \n{\n  return Rotate3dZ(fAng) * v;\n}\n\n// provide a lookat matrix\nmat4x4 LookAtLH(vec3 vCam, vec3 vTar, vec3 vUp)\n{\n    mat4x4 avLookAt;\n    vec3 vZ = normalize(vTar - vCam);\n    vec3 vX = normalize(cross(vUp, vZ));\n    vec3 vY = cross(vZ, vX);\n       \n    avLookAt = \n    mat4x4(\n        vec4(1., 0., 0., -vCam.x),\n        vec4(0., 1., 0., -vCam.y),\n        vec4(0., 0., 1., -vCam.z),\n        vec4(0., 0., 0., 1.)\n    ) *\n    mat4x4(\n        vec4(vX.x, vX.y, vX.z, 0.),\n        vec4(vY.x, vY.y, vY.z, 0.),\n        vec4(vZ.x, vZ.y, vZ.z, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n    \n    return avLookAt;\n}\n\n// provide a perspective projection matrix\nmat4x4 PerspectiveLH(vec2 vFov, vec2 vZnf)\n{\n    float fW = tan(vFov.x*0.5),\n          fH = tan(vFov.y*0.5);\n    \n    mat4x4 avProj = mat4x4( 0.0 );\n    avProj[0][0] = 2. * vZnf.x / fW;\n    avProj[1][1] = 2. * vZnf.x / fH;\n    avProj[2][2] = vZnf.y / (vZnf.y - vZnf.x);\n    avProj[3][2] = 1.;\n    avProj[2][3] = vZnf.x*vZnf.y/(vZnf.x - vZnf.y);\n    \n    return avProj;  \n}\n\n// transform a ray based on screen position, camera position and inverse wvp matrix - Microsoft method\nvoid TransformRay(in uvec2 sIndex, in vec2 sScreenSz, in vec4 vCamPos, in mat4x4 sWVPrInv,\n\tout vec3 vOrigin, out vec3 vDirection)\n{\n\t// center in the middle of the pixel, get screen position\n\tvec2 vXy = vec2(sIndex.xy) + 0.5f;\n\tvec2 vUv = vXy / sScreenSz.xy * 2.0 - 1.0;\n\t\n\t// unproject by inverse wvp\n\tvec4 vWorld = vec4(vUv, 0, 1) * sWVPrInv;\n\n\tvWorld.xyz /= vWorld.w;\n\tvOrigin = vCamPos.xyz;\n\tvDirection = normalize(vWorld.xyz - vOrigin);\n}\n\n// Lighting Library #####################################################\n\n// phong pointlight.. in Position Texel, Light, Camera, Material Color, Ray Direction, Normal\n// inspired by Shane's lighting model\nvec3 Phong_PointLight(vec3 vPosTex, vec3 vPosLig, vec3 vPosCam, vec3 cMat, vec3 vDir, vec3 vNor)\n{\n    const float fAmbient = .2f;\n        \n    // light direction, distance\n\tvec3 vLDir = vPosTex - vPosLig;\n\tfloat fLDist = max(length(vLDir), .001f);\n\tvLDir /= fLDist;\n\n\t// ambient, diffuse, attenuation, specular\n\tfloat fDif = max(dot(-vLDir, vNor), 0.f);\n\tfDif = pow(fDif, 2.f) * .6f + pow(fDif, 4.f) * .2f + pow(fDif, 8.f) * .2f;\n\tfloat fAtt = 1. / (1. + fLDist * fLDist * .05f);\n\tvec3 vRef = reflect(vLDir, vNor);\n\tfloat fSpec = pow(max(dot(-vDir, vRef), 0.0), 32.f);\n\n\treturn clamp(((cMat * max(fDif, fAmbient)) + fSpec * .5f) * fAtt, 0.f, 1.f);\n}\n","name":"Common","description":"","type":"common"}]}