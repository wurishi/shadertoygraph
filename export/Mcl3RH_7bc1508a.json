{"ver":"0.1","info":{"id":"Mcl3RH","date":"1702795861","viewed":48,"name":"Reflections 2.0","username":"zmcbeth","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// RAY STRUCTURE                                                                       #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nstruct Ray {\n\n    vec3 position;\n    vec3 direction;\n    \n    vec3 color;\n    \n    float contribution;\n\n};\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// MATERIAL STRUCTURE                                                                  #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nstruct Material {\n    \n    vec3 color;\n    float reflectivity;\n    \n    bool isLight;\n\n};\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// SURFACE STRUCTURE                                                                   #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nstruct Surface {\n\n    vec3 position;\n    vec3 normal;\n    \n    Material material;\n\n};\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// SPHERE STRUCTURE                                                                    #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nstruct Sphere {\n    \n    vec3  center;\n    float radius;\n\n    Material material;\n\n};\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// PLANE STRUCTURE                                                                     #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nstruct Plane {\n    \n    float height;\n\n    Material material;\n\n};\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// SCENE OBJECTS                                                                       #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nSphere sphereOne;\nSphere sphereTwo;\n\nPlane  plane;\n\nSurface skybox;\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// SCENE BUILDER                                                                       #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nvoid buildScene() {\n\n    sphereOne.center = vec3(0.0, 0.0, 0.0);\n    sphereTwo.center = vec3(5.0 * cos(0.5 * iTime), -0.75, 5.0 * sin(0.5 * iTime));\n   \n    sphereOne.radius = 3.0 - 0.25;\n    sphereTwo.radius = 1.0 - 0.25;\n    \n    sphereOne.material.color = vec3(1.0, 0.0, 0.0);\n    sphereTwo.material.color = vec3(0.0, 0.0, 1.0);\n    \n    sphereOne.material.reflectivity = 0.98;\n    sphereTwo.material.reflectivity = 0.98;\n    \n    plane.height = -3.0;\n    \n    plane.material.color = vec3(1.0, 1.0, 1.0);\n    plane.material.reflectivity = 1.0;\n    \n    skybox.position = vec3(0.0, 0.0, 100000.0);\n\n}\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// INTERSECT SPHERE                                                                    #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\n Surface intersectSphere(Ray ray, Sphere sphere) {\n \n    Surface hit = skybox;\n\n    // CALCULATE SPHERE INTERSECTION\n\n    float contribution = dot(ray.direction, normalize(sphere.center - ray.position));\n    if (contribution < 0.0) return hit;\n    \n    float centerDistance = distance(ray.position, sphere.center);\n    \n    float closest = distance(sphere.center, ray.position + centerDistance * contribution * ray.direction);\n    if (closest > sphere.radius + 0.25) return hit;\n    \n    float depthToClosest = sqrt(pow(sphere.radius, 2.0) - pow(closest, 2.0));\n    \n    vec3 intersection = ray.position + (centerDistance * contribution - depthToClosest) * ray.direction;\n    \n    // RETURN SPHERE SURFACE DATA\n    \n    hit.position = intersection;\n    hit.normal   = normalize(hit.position - sphere.center);\n    \n    hit.material = sphere.material;\n    \n    return hit;\n    \n}\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// INTERSECT PLANE                                                                     #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nSurface intersectPlane(Ray ray, Plane plane) {\n\n    Surface hit = skybox;\n\n    // CALCULATE PLANE INTERSECTION\n\n    if (ray.direction.y > 0.0) return hit;\n\n    vec3 intersection = ray.position + ((ray.position.y - plane.height) / -ray.direction.y) * ray.direction;\n    \n    // RETURN PLANE SURFACE DATA\n    \n    hit.position = intersection;\n    hit.normal   = vec3(0.0, 1.0, 0.0);\n    \n    hit.material = plane.material;\n    \n    return hit;\n}\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// INTERSECT SCENE                                                                     #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nSurface intersectScene(Ray ray) {\n\n    Surface scene = skybox;\n\n    Surface sphereOne = intersectSphere(ray, sphereOne);\n    Surface sphereTwo = intersectSphere(ray, sphereTwo);\n    \n    Surface plane = intersectPlane(ray, plane);\n\n    \n    if (sphereOne != skybox && distance(ray.position, sphereOne.position) < distance(ray.position, scene.position)) {\n        scene = sphereOne;\n    }\n    \n    if (sphereTwo != skybox && distance(ray.position, sphereTwo.position) < distance(ray.position, scene.position)) {\n        scene = sphereTwo;\n    }\n    \n    if (plane != skybox && distance(ray.position, plane.position) < distance(ray.position, scene.position)) {\n        scene = plane;\n    }\n    \n    return scene;\n\n}\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// RAYTRACE                                                                            #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nvoid raytrace(inout Ray ray) {\n\n    Surface surface;\n        \n    while (ray.contribution > 0.01) {\n    \n        surface = intersectScene(ray);\n            \n        if (surface == skybox) {\n            \n            ray.color += ray.contribution * texture(iChannel0, ray.direction).xyz; //* vec3(0.7, 0.8, 1.2);\n             \n            return;\n                \n        }\n        \n        ray.position = surface.position;\n    \n        ray.color += ray.contribution * (1.0 - surface.material.reflectivity) * surface.material.color;\n        ray.contribution = ray.contribution * surface.material.reflectivity;\n    \n        ray.direction = reflect(ray.direction, surface.normal);\n    \n    \n    }\n\n}\n\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n// PIXEL SHADER                                                                        #\n//~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~#\n\nvoid mainImage(out vec4 pixelColor, vec2 pixelCoordinate) {\n\n    buildScene();\n    \n    // CALCULATE CENTERED UV COORDINATE\n    \n    float aspect = iResolution.x/iResolution.y;\n\n    vec2 uv = pixelCoordinate/iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n    uv *= vec2(aspect, 1.0);\n    \n    // DEFINE VIEW DIMENESIONS\n    \n    float viewHeight = 5.0;\n    float viewWidth  = viewHeight * aspect;\n    \n    float viewDepth  = 8.0;\n    \n    // CALCULATE SCREEN COORDINATE AND OBSERVER POSITION\n    \n    float pov = radians(30.0);\n    \n    float oberserverDepth = viewWidth / (2.0 * sin(pov/2.0));\n    \n    vec3 screenCoordinate = vec3(viewHeight * uv + vec2(0.0, 1.0), -viewDepth);\n    vec3 observerPosition = vec3(0.0, 1.0, -viewDepth - (viewWidth / 2.0*cos(pov)));\n    \n    // CREATE RAY AT OBSERVER POSITION POINTED TOWARD SCREEN COORDINATE\n    \n    Ray ray;\n    \n    ray.position = screenCoordinate;\n    ray.direction = normalize(screenCoordinate - observerPosition);\n    \n    ray.contribution = 1.0;\n    \n    // MARCH THE RAY TO A POINT IN THE SCENE\n    \n    raytrace(ray);\n    \n    // CALCULATE FINAL PIXEL COLOR\n    \n    pixelColor = vec4(ray.color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}