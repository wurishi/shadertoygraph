{"ver":"0.1","info":{"id":"mldfRr","date":"1700915293","viewed":39,"name":"Liquid simulation test ","username":"roey_shap","description":"Click to paint.\nPracticing using channels referencing each other to save data.\nTook way too long to realize that I just needed a larger paint radius.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["bleed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    /*\n    vec2 tt = iMouse.wz / iResolution.xy;\n    vec3 c = vec3(1.0); // + texture(iChannel0, tt).rgb;\n    if (any(notEqual(iMouse.wz, fragCoord.xy))) {\n        c = vec3(0);\n    }\n    */\n    vec3 c = texture(iChannel0, uv).rgb;\n    fragColor = vec4(c, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float map(float min1, float max1, float value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\nbool positionsEqual(vec2 p1, vec2 p2)\n{\n    return int(p1.x) == int(p2.x) && int(p1.y) == int(p2.y);\n}\n\nfloat average(vec3 v) {\n    return (v.x + v.y + v.z) / 3.0;\n}\n\n/// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 fillCol = vec3(1.0, 1.0, 1.0);\n    float rad = 50.0;\n    vec3 c = vec3(0);\n    vec2 offs[4] = vec2[4](\n        vec2(-1, 0),\n        vec2(0, -1),\n        vec2(1, 0),\n        vec2(0, 1)\n    );\n    \n    float leakFactor = 0.99;\n    float leakThreshold = 0.000001;\n    //float epsilon = 0.0001;\n    \n    for (int i = 0; i < 4; i++) {\n        vec3 neighborColor = texture(iChannel0, (fragCoord + offs[i]) / iResolution.xy).rgb;\n        if (average(neighborColor) >= leakThreshold) {\n            c += neighborColor * (leakFactor / 4.0);\n        }\n    }\n    \n    vec3 curCol = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    if (average(curCol) >= leakThreshold) { \n        c += curCol * (1.0 - leakFactor);\n    } else {\n        c += curCol;\n    }\n    \n    float disFromMouse = length(fragCoord.xy - iMouse.zw);\n    if (disFromMouse <= rad) {\n        c += vec3(1.0);\n        //c += hsv2rgb(vec3(map(-1.0, 1.0, sin(uv.x + uv.y + iTime), 0.0, 1.0), 1.0, 1.0)); // * (rad - disFromMouse) / rad;\n    }\n    \n    fragColor = vec4(c, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}