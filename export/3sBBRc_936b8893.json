{"ver":"0.1","info":{"id":"3sBBRc","date":"1590483830","viewed":68,"name":"accidental effect","username":"mailko","description":"processing shadow have some problem.but it is look not bad.keep it to record. can be some special effect?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["special"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEP 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.00001\n\n\n//矩阵相关\nmat4 rotateY_invert(float theta){\n\tfloat c = cos(-theta);\n    float s = sin(-theta);\n    return mat4(\n    \tvec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 0)\n    );\n}\n\nmat4 transform_invert(vec3 movement){\n\treturn mat4(\n    \tvec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(-movement, 0)\n    );\n}\n\nfloat sphereSDF(vec3 p){\n    return length(p) - 1.0;\n}\n\nfloat torusSDF(vec3 p){\n    vec2 t = vec2(1.0, 0.4);\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\nfloat planeSDF(vec3 p, vec4 n){\n\treturn dot(p, n.xyz) + n.w;\n}\nfloat boxSDF(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nfloat sceneSDF(vec3 p){\n    vec3 torusP = (rotateY_invert(1.0) * transform_invert(vec3(0.5, 0, 0)) * vec4(p, 1.0)).xyz;\n    return unionSDF(\n        differenceSDF(sphereSDF(p), torusSDF(torusP)),\n        planeSDF(p, vec4(0.0, 1.0, 0.0, 1.0))\n    );\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEP; i++){\n       \tfloat dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON){\n        \treturn depth;\n        }\n        depth += dist;\n        if(depth >= end){\n        \treturn end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up){\n\tvec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n    \tvec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n    \n\nvec3 estimateNormal(vec3 p){\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    float dotLN = clamp(dot(L, N), 0.0, 1.0);\n    float dotRV = clamp(dot(R, V), 0.0, 1.0);\n\treturn lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));    \n}\n\nfloat shadow(vec3 lightPos, vec3 p)\n{\n    vec3 dir = normalize(p - lightPos);\n    float maxDistance = length(p - lightPos);\n    for(float t = 0.0; t < maxDistance;)\n    {\n        float h = sceneSDF(lightPos + dir * t);\n        if(h < EPSILON)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye){\n\tconst vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                         2.0,\n                         4.0 * cos(iTime));\n    vec3 lightIntensity = vec3(0.4, 0.4, 0.4);\n    float shadow = shadow(lightPos, p);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye, lightPos, lightIntensity) * shadow;\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 5.0, 5.0);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    if(dist > MAX_DIST - EPSILON){\n    \tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    vec3 K_a = vec3(0.3, 0.3, 0.3);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}