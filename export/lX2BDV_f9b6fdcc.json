{"ver":"0.1","info":{"id":"lX2BDV","date":"1729962831","viewed":359,"name":"Classical Radiosity Test","username":"kaiavintr","description":"Challenge was to do it in one frame in Shadertoy. Computes 4 Jacobi iterations and then uses a linear combination. Artifacts are from Catmull-Rom interpolation in the final render.\n\nAlternative (multi-frame) version: https://www.shadertoy.com/view/lX2fDy","likes":32,"published":1,"flags":32,"usePreview":0,"tags":["cornellbox","globalillumination","radiosity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Copyright (C) 2024 Kaia Vintr\n    \n    Code is licensed only for personal, non-commercial use on the Shadertoy\n    website. You may not copy all or any part of the code into another Shadertoy\n    shader (whether by using Shadertoy's \"fork\" feature or by some other means).\n    You may not distribute or use all or any part of the code outside of\n    the Shadertoy website, even if the code is accessed via the Shadertoy API or\n    web server. You may not use the code or its output to train or fine-tune\n    machine learning models (e.g. \"AI\" models). You may not use the code to\n    create image or video content for publication or distribution, except\n    screenshots or brief video clips of the output of the unmodified code to be\n    used strictly in a manner that would be permitted as \"fair use\" under U.S.\n    copyright law (for example, you may not use the code to create NFTs or\n    YouTube videos). If any provision of these license terms is held to be\n    invalid or unenforceable, that provision shall be limited to the minimum\n    extent necessary, and the remaining provisions shall remain in full effect.\n    \n    Please contact Kaia Vintr with questions regarding this code\n    via direct message to @kaiavintr.bsky.social on BlueSky (preferred)\n    or @KaiaVintr on Twitter, or via a comment on this shader.\n    \n    URL of the Shadertoy website page where this code is intended to be used\n    (page for this \"shader\"):\n    https://www.shadertoy.com/view/lX2BDV\n    \n    Code is archived at:\n    https://github.com/kaiavintr/shadertoy_experiments/tree/main/ClassicalRadiosityTest\n    \n*/\n\n// Various things are configurable -- see Common\n\n// This shader performs simple ray-casting rendering of the box and sphere, using the\n//  radiosity data from the final pass.\n// Complication 1 is that it needs to interpolate the radiosity data.\n// Complication 2 is that it anti-aliases the edges.\n\n// iChannel0 is output of the final light gathering pass (i.e. BufferD) which also contains the sphere and light position data\n\n#define CUBIC(t, C0, C1, C2, C3) (C0 + (C1 + (C2 + C3*t)*t)*t)\n\nvec3 LINEAR_TO_SRGB(vec3 C) {\n    // Note: this is a direct translation of the sRGB definition into branch-less GLSL (other people's code likely looks similar)\n    return mix(12.92*C, 1.055*pow(C, vec3(1./2.4)) - 0.055, step(0.0031308, C));\n}\n\nfloat rgb_to_luminance(vec3 c) {\n    return dot(c, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// Shift energy from clipped color components into other components, but don't modify representable colors\n// Avoids unexpected cyan, yellow, and magenta pixels and tries to use correct luminance even if color is out of gamut\nvec3 gamut_clip(vec3 c) {\n    float maxcomp = max(max(c.r, c.g), c.b);\n    \n    if (maxcomp <= 1.005) {\n        return c;\n    } else {\n        float target_luminance = rgb_to_luminance(c);\n        \n        vec3 representable = c / maxcomp;\n        \n        float representable_luminance = rgb_to_luminance(representable);\n        \n        // Find a color that is a linear blend between brightest representable color with same chroma + saturation as c, and white,\n        //      and has same luminance as c (target_luminance).\n        // If target_luminance >= 1. white will be used.\n        // (1.00001 could probably be safely changed to 1. in GLSL) \n        return mix(c, vec3(1), clamp((target_luminance - representable_luminance) / (1.00001 - representable_luminance), 0., 1.));\n    }\n}\n\nmat3 make_camera_rotation_matrix(vec4 mouse4, vec3 resolution) {\n    vec2 mouse = mouse4.x == 0. && mouse4.y == 0. || mouse4.x > resolution.x || mouse4.y > resolution.y\n            ? 0.5*resolution.xy\n            : mouse4.xy;\n    \n    mouse = 2. * (mouse.xy / resolution.xy - 0.5);\n    \n    float xz = PI * 0.4*mouse.x;\n    float yz = 0.5*PI * 0.8*clamp(mouse.y, -0.999, 0.999);\n    \n    float cos_yz = cos(yz);\n    \n    vec3 dir_z = normalize(vec3(sin(xz)*cos_yz, sin(yz), cos(xz)*cos_yz)); // (normalize is for precision loss only)\n    vec3 dir_x = normalize(cross(vec3(0, 1, 0), dir_z));\n\n    return mat3(dir_x, normalize(cross(dir_z, dir_x)), dir_z); // (normalize is for precision loss only)\n}\n\nfloat intersect_sphere(vec3 C, float r, vec3 V, vec3 ray_O) {\n    ray_O -= C;\n\n    float a = dot(V, ray_O);\n\n    float d = a*a - dot(ray_O, ray_O) + r*r;\n\n    return d >= 0. ? -sqrt(d) - a : 1e20;\n}\n\n// Distance to axis-aligned plane\n// rV is (e.g.) 1./V.x, where V is the normalized view ray\nfloat plane_distance(float c, float rV, float origin) {\n    float d = (c - origin)  * rV;\n\n    return d > 0. ? d : 1e20;\n}\n\n#if INTERPOLATION == MITCHELL_NETRAVALI\nfloat mitchell_netravali(float x) {\n    // I hope I didn't mess this one up (anyway, it looks right)\n    \n    x = min(abs(x), 2.);\n\n    return x < 1. ? (\n            (7./6.*x - 2.)*x*x + 8./9.\n        ) : (\n            ((-7./18.*x + 2.)*x - 10./3.)*x + 16./9.\n        );\n}\n#endif\n\n#if INTERPOLATION == CUBIC_BSPLINE\n// Optimized functions for computing cubic B-spline smoothing coefficients (a bit unnecessary here)\n// I think these work for t in interval (-0.5, 1.5)\n\nfloat bspline_eval_low(float t) {\n    t = min(t, 1.);\n\n    return 1./6.*(t*(t*(t - 2.*abs(t) + 3.) - 3.) + 1.);\n}\n\nfloat bspline_eval_low2(float t) {\n    t = abs(t) - 1.;\n\n    return 1./6.*(t*(t*(t - 2.*abs(t) + 3.) - 3.) + 1.);\n}\n\nfloat bspline_eval_high(float t) {\n    t = abs(t - 1.) - 1.;\n\n    return 1./6.*(t*(t*(t - 2.*abs(t) + 3.) - 3.) + 1.);\n}\n\nfloat bspline_eval_high2(float t) {\n    t = min(1.-t, 1.);\n\n    return 1./6.*(t*(t*(t - 2.*abs(t) + 3.) - 3.) + 1.);\n}\n#endif\n\n// x is in interval (-0.5, 1.5)\n// returns coefficients for values at x=-1, x=0, x=1 and x=2\nvec4 get_interp_coefficients(float x) {\n#if INTERPOLATION == NO_INTERPOLATION // No interpolation\n    return vec4(\n        0.,\n        x < 0.5 ? 1. : 0.,\n        x >= 0.5 ? 1. : 0.,\n        0.\n    );\n#elif INTERPOLATION == BILINEAR_INTERPOLATION // Linear\n    return vec4(\n        0.,\n        1. - x,\n        x,\n        0.\n    );\n#elif INTERPOLATION == CATMULL_ROM // Catmull-Rom\n    return vec4(\n        0.5*x*((2. - x)*x - 1.),\n        (1.5*x - 2.5)*x*x + 1.,\n        ((-1.5*x + 2.)*x + 0.5)*x,\n        0.5*x*x*(x - 1.)\n    );\n#elif INTERPOLATION == CUBIC_BSPLINE\n    return vec4(\n        bspline_eval_low(x),\n        bspline_eval_low2(x),\n        bspline_eval_high(x),\n        bspline_eval_high2(x)\n    );\n#else // Mitchell-Netravali\n    return vec4(\n        mitchell_netravali(x+1.),\n        mitchell_netravali(x),\n        mitchell_netravali(x-1.),\n        mitchell_netravali(x-2.)\n    );\n#endif\n}\n\n// For anti-aliasing an edge, given two points on the edge, the coordinate of the pixel, and a distance\nfloat get_edge_antialias_alpha(vec2 fragCoord, vec2 P1, vec2 P2, float blur_dist) {\n    vec2 gap = fragCoord - P1.xy;\n    vec2 V = normalize(P2.xy-P1.xy);\n    \n    return smoothstep(0., blur_dist, length(gap - dot(gap, V)*V));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    fragCoord -= 0.5*iResolution.xy;\n\n    vec3 V;\n    float pix_scale; // used for anti-aliasing; computed while normalizing the view ray\n    \n    {\n        vec3 V0 = vec3(fragCoord, VIEW_ANGLE_FACTOR*iResolution.y);\n        \n        pix_scale = 1./length(V0);\n        \n        V = pix_scale * V0;\n    }\n    \n    vec3 ray_O = vec3(0.5, 0.5, 1.*CAMERA_Z); // view ray origin\n    mat3 rotation_matrix = make_camera_rotation_matrix(iMouse, iResolution);\n    \n    V = rotation_matrix * V;\n    ray_O = rotation_matrix * (ray_O-vec3(0.5,0.5,0.25)) + vec3(0.5,0.5,0.25);\n    \n    ray_O.z = min(ray_O.z, -0.01);\n    \n    vec3 rV = 1. / V; // used for axis-aligned plane intersection\n    \n    // Check if ray passes through the front of the box (nothing outside the box is rendered)\n    {\n        float t_front = plane_distance(0., rV.z, ray_O.z);\n        \n        vec3 p = ray_O + t_front*V;\n        \n        if (p.x < 0. || p.x > 1. || p.y < 0. || p.y > 1.) {\n            fragColor = vec4(0,0,0,1);\n            return;\n        }\n    }\n    \n    float t_left = ray_O.x < 0. ? 1e20 : plane_distance(0., rV.x, ray_O.x);\n    float t_right = ray_O.x > 1. ? 1e20 : plane_distance(1., rV.x, ray_O.x);\n    float t_bottom = ray_O.y < 0. ? 1e20 : plane_distance(0., rV.y, ray_O.y);\n    float t_top = ray_O.y > 1. ? 1e20 : plane_distance(1., rV.y, ray_O.y);\n    float t_back = plane_distance(1., rV.z, ray_O.z);\n    \n    float t_inter = min(min(min(t_left, t_bottom), min(t_right, t_top)), t_back);\n    \n    vec3 final_color = vec3(0);\n    \n    if (t_inter < 1e6) {\n        float back_antialias_alpha = 1.;\n        \n        if (t_inter != t_back) {\n            vec3 P1 = t_inter == t_left || t_inter == t_bottom ? vec3(0., 0., 1.) : vec3(1., 1., 1.);\n            vec3 P2 = t_inter == t_left || t_inter == t_top ? vec3(0., 1., 1.) : vec3(1., 0., 1.);\n            \n            P1 = (P1 - ray_O) * rotation_matrix;\n            P2 = (P2 - ray_O) * rotation_matrix;\n            \n            back_antialias_alpha = get_edge_antialias_alpha(fragCoord, P1.xy * (VIEW_ANGLE_FACTOR*iResolution.y / P1.z), \n                                               P2.xy * (VIEW_ANGLE_FACTOR*iResolution.y / P2.z), 2.);\n        }\n\n        vec3 p = ray_O + t_inter*V;\n    \n        float side_antialias_alpha = 1.;\n        \n        if (t_inter == t_left || t_inter == t_right) {\n            vec3 P1 = vec3(t_inter == t_left ? 0. : 1., p.y < 0.5 ? 0. : 1., 0.);\n            \n            vec3 P2 = P1 + vec3(0., 0., 1.);\n            \n            P1 = (P1 - ray_O) * rotation_matrix;\n            P2 = (P2 - ray_O) * rotation_matrix;\n            \n            side_antialias_alpha = get_edge_antialias_alpha(fragCoord, P1.xy * (VIEW_ANGLE_FACTOR*iResolution.y / P1.z), \n                                               P2.xy * (VIEW_ANGLE_FACTOR*iResolution.y / P2.z), 2.);\n        }\n    \n        // Choose which mesh to use\n        // Get coordinates of the point within the mesh where we need the radiosity value\n        float fi;\n        float fj;\n        int base_x;\n    \n        if (t_inter == t_left) {\n            fi = float(MESH_SQUARE_ROWS)*p.y;\n            fj = float(MESH_SQUARE_COLUMNS)*p.z;\n            base_x = MESH_X_OFFSET_LEFT;\n        } else if (t_inter == t_right) {\n            fi = float(MESH_SQUARE_ROWS)*p.y;\n            fj = float(MESH_SQUARE_COLUMNS)*p.z;\n            base_x = MESH_X_OFFSET_RIGHT;\n        } else if (t_inter == t_bottom) {\n            fi = float(MESH_SQUARE_ROWS)*p.z;\n            fj = float(MESH_SQUARE_COLUMNS)*p.x;\n            base_x = MESH_X_OFFSET_BOTTOM;\n        } else if (t_inter == t_top) {\n            fi = float(MESH_SQUARE_ROWS)*p.z;\n            fj = float(MESH_SQUARE_COLUMNS)*p.x;\n            base_x = MESH_X_OFFSET_TOP;\n        } else {\n            fi = float(MESH_SQUARE_ROWS)*p.y;\n            fj = float(MESH_SQUARE_COLUMNS)*p.x;\n            base_x = MESH_X_OFFSET_BACK;\n        }\n        \n        // Treating the patch radiosity values as values at the center of the patch,\n        //      so convert coordinates to that coordinate system\n        fi -= 0.5;\n        fj -= 0.5;\n        \n        // Get row and column index of the patch whose center is (e.g.) below and to the left\n        //      of the point we want, clamping it to valid mesh coordinates\n        int meshi0 = clamp(int(floor(fi)), 0, MESH_SQUARE_ROWS-1);\n        int meshj0 = clamp(int(floor(fj)), 0, MESH_SQUARE_COLUMNS-1);\n        \n        // Get row and column index of the patch whose center is (e.g.) above and to the right\n        int meshi1 = min(meshi0 + 1, MESH_SQUARE_ROWS-1);\n        int meshj1 = min(meshj0 + 1, MESH_SQUARE_COLUMNS-1);\n        \n        // If we are at the (e.g.) top or right edge we will be extrapolating, so make sure we\n        //      have pairs of distinct rows and columns\n        meshi0 = meshi1 - 1;\n        meshj0 = meshj1 - 1;\n        \n        // Get fractional coordinates relative to the (e.g.) below, left coordinate\n        // These will be in (0, 1) if we are interpolating, and in (-0.5, 1.5) if extrapolating.\n        fi -= float(meshi0);\n        fj -= float(meshj0);\n        \n        // Get interpolation or smoothing coefficients for both directions\n        vec4 C = get_interp_coefficients(fi);\n        vec4 C2 = get_interp_coefficients(fj);\n        \n        // Get coordinates of neighboring patches, for use with cubic interpolation or smoothing\n        int meshin1 = max(0, meshi0 - 1);\n        int meshi2 = min(MESH_SQUARE_ROWS-1, meshi1 + 1);\n\n        int meshjn1 = max(0, meshj0 - 1);\n        int meshj2 = min(MESH_SQUARE_COLUMNS-1, meshj1 + 1);\n        \n        // For Catmull-Rom only, if extrapolating switch to linear extrapolation\n        // (Catmull-Rom extrapolation doesn't seem to be usable - produces bright areas at most of the edges)\n        #if INTERPOLATION == CATMULL_ROM\n        if (meshi1 == meshi2 || meshin1 == meshi0) {\n            C = vec4(0., 1. - fi, fi, 0.);\n        }\n\n        if (meshj1 == meshj2 || meshjn1 == meshj0) {\n            C2 = vec4(0., 1. - fj, fj, 0.);\n        }\n        #endif\n        \n        final_color = (C.x*(\n                    C2.x*texelFetch(iChannel0, ivec2(base_x + meshjn1, meshin1), 0).rgb \n                        + C2.y*texelFetch(iChannel0, ivec2(base_x + meshj0, meshin1), 0).rgb\n                        + C2.z*texelFetch(iChannel0, ivec2(base_x + meshj1, meshin1), 0).rgb\n                        + C2.w*texelFetch(iChannel0, ivec2(base_x + meshj2, meshin1), 0).rgb\n                        )\n                \n                + C.y*(\n                    C2.x*texelFetch(iChannel0, ivec2(base_x + meshjn1, meshi0), 0).rgb \n                        + C2.y*texelFetch(iChannel0, ivec2(base_x + meshj0, meshi0), 0).rgb\n                        + C2.z*texelFetch(iChannel0, ivec2(base_x + meshj1, meshi0), 0).rgb\n                        + C2.w*texelFetch(iChannel0, ivec2(base_x + meshj2, meshi0), 0).rgb\n                        )\n                + C.z*(\n                    C2.x*texelFetch(iChannel0, ivec2(base_x + meshjn1, meshi1), 0).rgb \n                        + C2.y*texelFetch(iChannel0, ivec2(base_x + meshj0, meshi1), 0).rgb\n                        + C2.z*texelFetch(iChannel0, ivec2(base_x + meshj1, meshi1), 0).rgb\n                        + C2.w*texelFetch(iChannel0, ivec2(base_x + meshj2, meshi1), 0).rgb\n                        )\n                + C.w*(\n                    C2.x*texelFetch(iChannel0, ivec2(base_x + meshjn1, meshi2), 0).rgb \n                        + C2.y*texelFetch(iChannel0, ivec2(base_x + meshj0, meshi2), 0).rgb\n                        + C2.z*texelFetch(iChannel0, ivec2(base_x + meshj1, meshi2), 0).rgb\n                        + C2.w*texelFetch(iChannel0, ivec2(base_x + meshj2, meshi2), 0).rgb\n                        )\n                    );\n        \n        // If we are close to one of the sides of the cube face (other than the front) then we are\n        //      anti-aliasing, so we need to blend with a value from a neighboring face.\n        // Get the value to blend with\n        // Because we are using linear extrapolation by default at the edges, (in the Catmull-Rom case)\n        //      we should normally only need to fetch two values from the neighboring mesh.\n        \n        if (side_antialias_alpha < 0.995) {\n            // To make things simpler, we ONLY do this for the left and right faces \n            //      (this is sufficient for anti-aliasing)\n            \n            int index = (p.y < 0.5 ? MESH_X_OFFSET_BOTTOM + 0 : MESH_X_OFFSET_TOP + 0) + (t_inter == t_left ? 0 : MESH_SQUARE_COLUMNS-1);\n            int inc = t_inter == t_left ? 1 : -1;\n            \n            vec3 other_color0 = (C2.x*texelFetch(iChannel0, ivec2(index, meshjn1), 0).rgb\n                + C2.y*texelFetch(iChannel0, ivec2(index, meshj0), 0).rgb\n                + C2.z*texelFetch(iChannel0, ivec2(index, meshj1), 0).rgb\n                + C2.w*texelFetch(iChannel0, ivec2(index, meshj2), 0).rgb\n                    );\n            \n            #if INTERPOLATION == NO_INTERPOLATION\n            vec3 other_color = other_color0;\n            #else\n            index += inc;\n\n            vec3 other_color1 = (C2.x*texelFetch(iChannel0, ivec2(index, meshjn1), 0).rgb\n                + C2.y*texelFetch(iChannel0, ivec2(index, meshj0), 0).rgb\n                + C2.z*texelFetch(iChannel0, ivec2(index, meshj1), 0).rgb\n                + C2.w*texelFetch(iChannel0, ivec2(index, meshj2), 0).rgb\n                    );\n            \n            #if INTERPOLATION != CUBIC_BSPLINE && INTERPOLATION != MITCHELL_NETRAVALI\n            vec3 other_color = mix(other_color0, other_color1, -0.5);\n            #else\n            index += inc;\n\n            vec3 other_color2 = (C2.x*texelFetch(iChannel0, ivec2(index, meshjn1), 0).rgb\n                + C2.y*texelFetch(iChannel0, ivec2(index, meshj0), 0).rgb\n                + C2.z*texelFetch(iChannel0, ivec2(index, meshj1), 0).rgb\n                + C2.w*texelFetch(iChannel0, ivec2(index, meshj2), 0).rgb\n                    );\n            \n            vec4 C3 = get_interp_coefficients(-0.5);\n            \n            vec3 other_color = (C3.x + C3.y)*other_color0 + C3.z*other_color1 + C3.w*other_color2;\n            #endif\n            #endif\n            \n            final_color = mix(other_color, final_color, side_antialias_alpha);\n        }        \n        \n        if (back_antialias_alpha < 0.995) {\n            // This type of blending is done for all faces except the back face\n            \n            ivec2 idx_inc2;\n            ivec2 idx0, idx1, idx2, idx3;\n            \n            if (t_inter == t_left || t_inter == t_right) {\n                int idx_start = t_inter == t_left ? MESH_X_OFFSET_BACK + 0 : MESH_X_OFFSET_BACK + MESH_SQUARE_COLUMNS-1;\n                idx0 = ivec2(idx_start, meshin1);\n                idx1 = ivec2(idx_start, meshi0);\n                idx2 = ivec2(idx_start, meshi1);\n                idx3 = ivec2(idx_start, meshi2);\n                idx_inc2 = ivec2(t_inter == t_left ? 1 : -1, 0);\n            } else {\n                int idx_start = t_inter == t_bottom ? 0 : MESH_SQUARE_ROWS-1;\n                idx0 = ivec2(MESH_X_OFFSET_BACK + meshjn1, idx_start);\n                idx1 = ivec2(MESH_X_OFFSET_BACK + meshj0, idx_start);\n                idx2 = ivec2(MESH_X_OFFSET_BACK + meshj1, idx_start);\n                idx3 = ivec2(MESH_X_OFFSET_BACK + meshj2, idx_start);\n                idx_inc2 = ivec2(0, t_inter == t_bottom ? 1 : -1);\n                C = C2;\n            }\n        \n            vec3 other_color0 = (C.x*texelFetch(iChannel0, idx0, 0).rgb\n                + C.y*texelFetch(iChannel0, idx1, 0).rgb\n                + C.z*texelFetch(iChannel0, idx2, 0).rgb\n                + C.w*texelFetch(iChannel0, idx3, 0).rgb\n                    );\n            \n            #if INTERPOLATION == NO_INTERPOLATION\n            vec3 other_color = other_color0;\n            #else\n            vec3 other_color1 = (C.x*texelFetch(iChannel0, idx0 + idx_inc2, 0).rgb\n                + C.y*texelFetch(iChannel0, idx1 + idx_inc2, 0).rgb\n                + C.z*texelFetch(iChannel0, idx2 + idx_inc2, 0).rgb\n                + C.w*texelFetch(iChannel0, idx3 + idx_inc2, 0).rgb\n                    );\n\n            #if INTERPOLATION != CUBIC_BSPLINE && INTERPOLATION != MITCHELL_NETRAVALI\n            vec3 other_color = mix(other_color0, other_color1, -0.5);\n            #else\n            idx_inc2 *= 2;\n\n            vec3 other_color2 = (C.x*texelFetch(iChannel0, idx0 + idx_inc2, 0).rgb\n                + C.y*texelFetch(iChannel0, idx1 + idx_inc2, 0).rgb\n                + C.z*texelFetch(iChannel0, idx2 + idx_inc2, 0).rgb\n                + C.w*texelFetch(iChannel0, idx3 + idx_inc2, 0).rgb\n                    );\n            \n            vec4 C3 = get_interp_coefficients(-0.5);\n            \n            vec3 other_color = (C3.x + C3.y)*other_color0 + C3.z*other_color1 + C3.w*other_color2;\n            #endif\n            #endif\n            \n            final_color = mix(other_color, final_color, back_antialias_alpha);\n        }\n    }\n    \n    // Get the clamped (but otherwise still linear) final pixel color for the image behind the sphere\n    //      so we can blend with the light and sphere edge for anti-aliasing.\n    final_color = gamut_clip(final_color);\n    \n    #if SHOW_LIGHT_SOURCE\n    {\n        // using .zw instead of .xy, because we want the old value (in case the bufferD shader has just changed the light position)\n        ivec2 val = floatBitsToInt(texelFetch(iChannel0, ivec2(BUFFER_D_LIGHT_DATA, BUFFER_D_MISC_DATA_ROW), 0).zw);\n        \n        int light_side = unpack_light_side(val.x);\n        ivec2 light_i_minmax = unpack_light_i_minmax(val.x);\n        ivec2 light_j_minmax = unpack_light_j_minmax(val.y);\n        \n        // Get intersection of view ray with the plane containing the light\n        // (re-doing this to save the shader code from having to keep those\n        //          5 values in registers)\n        float light_t = 1e20;\n        \n        {\n            vec3 plane;\n    \n            if (light_side == SIDE_TOP) plane = vec3(1., ray_O.y, rV.y);\n            else if (light_side == SIDE_BOTTOM) plane = vec3(0., ray_O.y, rV.y);\n            else if (light_side == SIDE_LEFT) plane = vec3(0., ray_O.x, rV.x);\n            else if (light_side == SIDE_RIGHT) plane = vec3(1., ray_O.x, rV.x);\n            else plane = vec3(1., ray_O.z, rV.z);\n            \n            light_t = (plane.x - plane.y)  * plane.z;\n        }\n        \n        if (light_t > 0.) {\n            vec3 p = ray_O + light_t*V;\n            \n            vec2 coord;\n            \n            if (light_side == SIDE_TOP || light_side == SIDE_BOTTOM) coord = p.xz;\n            else if (light_side == SIDE_LEFT || light_side == SIDE_RIGHT) coord = p.zy;\n            else coord = p.xy;\n\n            float alpha = 1.; // blending factor for the light (1 = opaque)\n            \n            // increment because these values are inclusive, and need the edges\n            light_i_minmax.y++;\n            light_j_minmax.y++;\n            \n            vec2 minmax_i = 1./float(MESH_SQUARE_ROWS) * vec2(light_i_minmax);\n            vec2 minmax_j = 1./float(MESH_SQUARE_COLUMNS) * vec2(light_j_minmax);\n            \n            // anti-alias edges if we need to\n            if (coord.x < minmax_j.x || coord.x > minmax_j.y || coord.y < minmax_i.x || coord.y > minmax_i.y) {\n\n                // Get the 3D points for the corners of the light\n                vec3 P1, P2, P3, P4;\n                \n                if (light_side == SIDE_TOP || light_side == SIDE_BOTTOM) {\n                    float y = light_side == SIDE_BOTTOM ? 0. : 1.;\n                \n                    P1 = vec3(minmax_j.x, y, minmax_i.x);\n                    P2 = vec3(minmax_j.y, y, minmax_i.x);\n                    P3 = vec3(minmax_j.y, y, minmax_i.y);\n                    P4 = vec3(minmax_j.x, y, minmax_i.y);\n                } else if (light_side == SIDE_BACK) {\n                    P1 = vec3(minmax_j.x, minmax_i.x, 1.);\n                    P2 = vec3(minmax_j.y, minmax_i.x, 1.);\n                    P3 = vec3(minmax_j.y, minmax_i.y, 1.);\n                    P4 = vec3(minmax_j.x, minmax_i.y, 1.);\n                } else {\n                    float x = light_side == SIDE_LEFT ? 0. : 1.;\n                    \n                    P1 = vec3(x, minmax_i.x, minmax_j.x);\n                    P2 = vec3(x, minmax_i.x, minmax_j.y);\n                    P3 = vec3(x, minmax_i.y, minmax_j.y);\n                    P4 = vec3(x, minmax_i.y, minmax_j.x);\n                }\n                \n                P1 = (P1-ray_O)*rotation_matrix;\n                P2 = (P2-ray_O)*rotation_matrix;\n                P3 = (P3-ray_O)*rotation_matrix;\n                P4 = (P4-ray_O)*rotation_matrix;\n                \n                P1.xy *= VIEW_ANGLE_FACTOR*iResolution.y / P1.z;\n                P2.xy *= VIEW_ANGLE_FACTOR*iResolution.y / P2.z;\n                P3.xy *= VIEW_ANGLE_FACTOR*iResolution.y / P3.z;\n                P4.xy *= VIEW_ANGLE_FACTOR*iResolution.y / P4.z;\n                \n                const float edge_dist = 2.;\n                \n                // anti-alias the edges\n                if (coord.y < minmax_i.x) alpha *= 1. - get_edge_antialias_alpha(fragCoord, P1.xy, P2.xy, edge_dist);\n                if (coord.x > minmax_j.y) alpha *= 1. - get_edge_antialias_alpha(fragCoord, P2.xy, P3.xy, edge_dist);\n                if (coord.y > minmax_i.y) alpha *= 1. - get_edge_antialias_alpha(fragCoord, P3.xy, P4.xy, edge_dist);\n                if (coord.x < minmax_j.x) alpha *= 1. - get_edge_antialias_alpha(fragCoord, P4.xy, P1.xy, edge_dist);\n                \n                // prevent the anti-aliased corners from stretching too far\n                if (alpha != 0. && light_side != SIDE_BACK) {\n                    vec2 V1 = normalize(P1.xy - P2.xy);\n                    vec2 V4 = normalize(P4.xy - P1.xy);\n                    \n                    float d = dot(fragCoord - P1.xy, normalize(V1 - V4));\n\n                    vec2 V2 = normalize(P2.xy - P3.xy);\n                    \n                    d = max(d, dot(fragCoord - P2.xy, normalize(V2 - V1)));\n                    \n                    vec2 V3 = normalize(P3.xy - P4.xy);\n                    \n                    d = max(d, dot(fragCoord - P3.xy, normalize(V3 - V2)));\n                    d = max(d, dot(fragCoord - P4.xy, normalize(V4 - V3)));\n                    \n                    alpha *= 1. - smoothstep(edge_dist, 2.*edge_dist, d);\n                }\n            }\n            \n            // Fade the light out when seen from the side to avoid artifacts\n            if (alpha != 0. && light_side != SIDE_BACK) {\n                float t = 1.;\n                if (light_side == SIDE_TOP) t = V.y;\n                else if (light_side == SIDE_BOTTOM) t = -V.y;\n                else if (light_side == SIDE_LEFT) t = -V.x;\n                else if (light_side == SIDE_RIGHT) t = V.x;\n                \n                alpha *= smoothstep(0., 0.02, t);\n            }\n        \n            final_color = mix(final_color, vec3(1), alpha);\n        }\n    }\n    #endif\n    \n    {\n        vec3 sphere_c = texelFetch(iChannel0, ivec2(BUFFER_D_SPHERE_PREV_FRAME_POSITION, BUFFER_D_MISC_DATA_ROW), 0).rgb;\n        \n        vec3 C = sphere_c - ray_O;\n        \n        // Get vector from camera to sphere center in terms of V and a vector orthonormal to V\n        // Use this information for anti-aliasing\n\n        // (If this code seems like overkill, I figured it out for my bubbles shader and so\n        //  I happened to have it available)\n        \n        float proj = dot(V, C);\n        \n        vec3 U = C - proj*V;\n        \n        float dist_from_center = length(U);\n\n        U /= dist_from_center;\n        \n        float blur_scale = pix_scale * proj;\n\n        float pix_dist_blurred = (dist_from_center - SPHERE_RADIUS) / blur_scale;\n        \n        if (proj > 0. && pix_dist_blurred < 0.75) { // skip if pixel is too far from sphere\n            vec3 W = V;\n            \n            if (pix_dist_blurred > -0.75) {\n                // If pixel is close to edge of sphere, choose a good point on the sphere to use\n                // (like using centroid in typical graphics pipeline anti-aliasing)\n                \n                // Function that gets the amount to shift, so point is approximate centroid of the part of the sphere covered by the pixel\n                float shift = blur_scale * CUBIC(pix_dist_blurred, -0.27758603, -0.56839415, -0.1731804, 0.1215896);\n                \n                W = normalize(C - (dist_from_center + shift) * U);\n                \n                // W is now used as the view ray instead of V\n            }\n            \n            float t = intersect_sphere(sphere_c, SPHERE_RADIUS, W, ray_O);\n        \n            vec3 p = ray_O + t*W - sphere_c;\n            \n            p *= 1./SPHERE_RADIUS;\n            \n            // Get spherical coordinates\n            float theta = asin(max(-1., min(1., p.y)));\n            float phi = atan(p.z, p.x);\n            \n            // Get row coordinate for mesh\n            float fi = float(MESH_SPHERE_ROWS) * (0.5 + 1./PI * theta);\n            \n            fi -= 0.5;\n            \n            if (phi < 0.) {\n                phi += 2.*PI;\n            }\n\n            // Get column coordinate for mesh\n            float fj = float(MESH_SPHERE_COLUMNS) / (2.*PI) * phi;\n            \n            fj -= 0.5;\n            \n            int base_x = MESH_X_OFFSET_SPHERE;\n            int columns = MESH_SPHERE_COLUMNS;\n            int rows = MESH_SPHERE_ROWS;\n\n            int meshi0 = max(0, int(floor(fi)));\n            \n            meshi0 = min(MESH_SPHERE_ROWS-1, meshi0);\n            \n            int meshj = int(floor(fj));\n            \n            fj -= float(meshj);\n            \n            int meshj0 = meshj & (MESH_SPHERE_COLUMNS-1);\n            int meshj1 = (meshj + 1)  & (MESH_SPHERE_COLUMNS-1);\n\n            int meshi1 = meshi0 + 1;\n            \n            if (meshi1 >= MESH_SPHERE_ROWS) {\n                meshi0 -= 1;\n                meshi1 -= 1;\n            }\n            \n            fi -= float(meshi0);\n                \n            vec4 C = get_interp_coefficients(fi);\n            vec4 C2 = get_interp_coefficients(fj);\n            \n            int meshin1 = max(meshi0 - 1, 0);\n            int meshi2 = min(meshi1 + 1, MESH_SPHERE_ROWS-1);\n\n            int meshjn1 = (meshj0 - 1) & (MESH_SPHERE_COLUMNS-1);\n            int meshj2 = (meshj1 + 1) & (MESH_SPHERE_COLUMNS-1);\n            \n            // For Catmull-Rom, use linear interpolation at top and bottom of sphere\n            //      to avoid extrapolation (which can give weird values)\n            #if INTERPOLATION == CATMULL_ROM\n            if (meshi1 == meshi2 || meshin1 == meshi0) {\n                C = vec4(0., 1. - fi, fi, 0.);\n            }\n            #endif\n\n            vec3 v00, v01, v10, v11;\n            \n            vec3 c = (\n                C.x*(C2.x*texelFetch(iChannel0, ivec2(base_x + int(meshjn1), int(meshin1)), 0).rgb \n                    + C2.y*texelFetch(iChannel0, ivec2(base_x + int(meshj0), int(meshin1)), 0).rgb\n                    + C2.z*texelFetch(iChannel0, ivec2(base_x + int(meshj1), int(meshin1)), 0).rgb\n                    + C2.w*texelFetch(iChannel0, ivec2(base_x + int(meshj2), int(meshin1)), 0).rgb\n                    )\n                + C.y*(C2.x*texelFetch(iChannel0, ivec2(base_x + int(meshjn1), int(meshi0)), 0).rgb \n                    + C2.y*(v00 = texelFetch(iChannel0, ivec2(base_x + meshj0, meshi0), 0).rgb)\n                    + C2.z*(v01 = texelFetch(iChannel0, ivec2(base_x + meshj1, meshi0), 0).rgb)\n                    + C2.w*texelFetch(iChannel0, ivec2(base_x + int(meshj2), int(meshi0)), 0).rgb\n                    )\n                + C.z*(C2.x*texelFetch(iChannel0, ivec2(base_x + int(meshjn1), int(meshi1)), 0).rgb \n                    + C2.y*(v10 = texelFetch(iChannel0, ivec2(base_x + meshj0, meshi1), 0).rgb)\n                    + C2.z*(v11 = texelFetch(iChannel0, ivec2(base_x + meshj1, meshi1), 0).rgb)\n                    + C2.w*texelFetch(iChannel0, ivec2(base_x + int(meshj2), int(meshi1)), 0).rgb\n                    )\n                + C.w*(C2.x*texelFetch(iChannel0, ivec2(base_x + int(meshjn1), int(meshi2)), 0).rgb \n                    + C2.y*texelFetch(iChannel0, ivec2(base_x + int(meshj0), int(meshi2)), 0).rgb\n                    + C2.z*texelFetch(iChannel0, ivec2(base_x + int(meshj1), int(meshi2)), 0).rgb\n                    + C2.w*texelFetch(iChannel0, ivec2(base_x + int(meshj2), int(meshi2)), 0).rgb\n                    )\n                    );\n            \n            float alpha = smoothstep(-0.75, 0.75, -pix_dist_blurred);\n            \n            // Clamp color before blending so bright values don't mess up anti-aliasing\n            final_color = mix(final_color, gamut_clip(c), alpha);\n        }\n    }\n    \n    // Anti-alias the outer edges\n    {\n        vec3 P1 = (vec3(0., 0., 0.) - ray_O) * rotation_matrix;\n        vec3 P2 = (vec3(0., 1., 0.) - ray_O) * rotation_matrix;\n        vec3 P3 = (vec3(1., 1., 0.) - ray_O) * rotation_matrix;\n        vec3 P4 = (vec3(1., 0., 0.) - ray_O) * rotation_matrix;\n        \n        P1.xy *= VIEW_ANGLE_FACTOR*iResolution.y / P1.z;\n        P2.xy *= VIEW_ANGLE_FACTOR*iResolution.y / P2.z;\n        P3.xy *= VIEW_ANGLE_FACTOR*iResolution.y / P3.z;\n        P4.xy *= VIEW_ANGLE_FACTOR*iResolution.y / P4.z;\n        \n        float alpha = get_edge_antialias_alpha(fragCoord, P1.xy, P2.xy, 2.);\n        alpha *= get_edge_antialias_alpha(fragCoord, P2.xy, P3.xy, 2.);\n        alpha *= get_edge_antialias_alpha(fragCoord, P3.xy, P4.xy, 2.);\n        alpha *= get_edge_antialias_alpha(fragCoord, P4.xy, P1.xy, 2.);\n        \n        final_color *= alpha;\n    }\n    \n    fragColor = vec4(LINEAR_TO_SRGB(final_color), 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (C) 2024 Kaia Vintr\n    \n    Code is licensed only for personal, non-commercial use on the Shadertoy\n    website. You may not copy all or any part of the code into another Shadertoy\n    shader (whether by using Shadertoy's \"fork\" feature or by some other means).\n    You may not distribute or use all or any part of the code outside of\n    the Shadertoy website, even if the code is accessed via the Shadertoy API or\n    web server. You may not use the code or its output to train or fine-tune\n    machine learning models (e.g. \"AI\" models). You may not use the code to\n    create image or video content for publication or distribution, except\n    screenshots or brief video clips of the output of the unmodified code to be\n    used strictly in a manner that would be permitted as \"fair use\" under U.S.\n    copyright law (for example, you may not use the code to create NFTs or\n    YouTube videos). If any provision of these license terms is held to be\n    invalid or unenforceable, that provision shall be limited to the minimum\n    extent necessary, and the remaining provisions shall remain in full effect.\n    \n    Please contact Kaia Vintr with questions regarding this code\n    via direct message to @kaiavintr.bsky.social on BlueSky (preferred)\n    or @KaiaVintr on Twitter, or via a comment on this shader.\n    \n    URL of the Shadertoy website page where this code is intended to be used\n    (page for this \"shader\"):\n    https://www.shadertoy.com/view/lX2BDV\n    \n    Code is archived at:\n    https://github.com/kaiavintr/shadertoy_experiments/tree/main/ClassicalRadiosityTest\n    \n*/\n\n#define BOUNCY 0 // if 1, use some alternative parameters (less useful as a global illumination test)\n\n// NO_INTERPOLATION         = no interpolation (show patches)\n// BILINEAR_INTERPOLATION   = bilinear interpolation\n// CATMULL_ROM              = Catmull-Rom cubic spline with linear extrapolation at edges (Catmull-Rom extrapolation is too crazy)\n// CUBIC_BSPLINE            = Cubic B-spline\n// MITCHELL_NETRAVALI       = Mitchell-Netravali cubic spline\n// (B-spline avoids ringing artifacts but I think it blurs the shadows too much, and Mitchell-Netravali doesn't seem to help much)\n#define INTERPOLATION CATMULL_ROM\n\n// This must be 8, 16, 32, or 64\n//      16 is the default\n//      32 should be ok if you have a fast GPU (may freeze your phone or iGPU)\n//      64 will be slow even on a high-end GPU (will likely freeze your phone or iGPU, and won't work correctly for 16-bit float buffers)\n// Note: Doubling this number multiplies the work required by 16!\n#define MESH_SIZE 16\n\n#define SHOW_LIGHT_SOURCE 1\n\n// NOTE: series acceleration is disabled if these are not all set to 1\n#define SHOW_DIRECT_LIGHT 1\n#define SHOW_FIRST_BOUNCE 1\n#define SHOW_SECOND_BOUNCE 1\n#define SHOW_THIRD_BOUNCE 1\n\n// if 1, use a linear combination of values from pass 1, pass 3, and pass4 as an estimate for the converged value\n//  (will be missing light in places not reached by the first two or three bounces, but it will look much closer to the specified albedo)\n#define USE_SERIES_ACCELERATION 1\n\n// Bounds on the amount of extra light added (as multiple of difference between final two passes) so the series acceleration can't go too wildly off the rails\n// I looked at a scatter plot of the error divided by delta, and 1-4 appeared to be a reasonable range.\n#define USE_SERIES_ACCELERATION_SAFETY_BOUNDS_MIN 1.\n#define USE_SERIES_ACCELERATION_SAFETY_BOUNDS_MAX 4.\n\n\n// color and albedo of the surfaces\nconst vec3 ROOM_ALBEDO = vec3(0.85);\nconst vec3 LEFT_WALL_ALBEDO = vec3(0.85, 0.15, 0.15);\nconst vec3 RIGHT_WALL_ALBEDO = vec3(0.15, 0.65, 0.25);\n\n#if BOUNCY == 0\nconst vec3 SPHERE_ALBEDO = vec3(0.85);\n#else\nconst vec3 SPHERE_ALBEDO = vec3(0.95, 0.05, 0.1);\n#endif\n\n// This value will be divided by number of patches that cover the light\nconst vec3 LIGHT_AMOUNT = vec3(0.586 * float(MESH_SIZE*MESH_SIZE));\n\n// interval (seconds) between switching light position randomly\nconst float LIGHT_CHANGE_INTERVAL = 4.;\n\n// Initial light position (in case you want to test some specific position)\n// i and j ranges are inclusive (values should be in range 0...MESH_SIZE-1 or 0...MESH_SIZE-1)\nconst int LIGHT_SIDE_INITIAL = 3; // 0=left, 1=right, 2=bottom, 3=top, 4=back\nconst ivec2 LIGHT_I_MINMAX_INITIAL = ivec2((MESH_SIZE>>1) - (MESH_SIZE>>3), (MESH_SIZE>>1) + (MESH_SIZE>>3) - 1);\nconst ivec2 LIGHT_J_MINMAX_INITIAL = ivec2((MESH_SIZE>>1) - (MESH_SIZE>>3), (MESH_SIZE>>1) + (MESH_SIZE>>3) - 1);\n\n\n#if BOUNCY == 0 // using low velocity and low gravity for sphere (\"floaty\"?)\n\n// must be less than 0.5\n// if size is reduced, shadows may be inaccurate when the sphere is in a corner\nconst float SPHERE_RADIUS = 0.25;\n\nconst vec3 SPHERE_INITIAL_POSITION = vec3(1. - SPHERE_RADIUS, SPHERE_RADIUS, 0.5);\n\n// initial velocity of the sphere\n// NOTE: the y component of velocity is reset to this value's y component whenever the sphere collides with the floor\nconst vec3 SPHERE_INITIAL_VELOCITY = 0.25*vec3(-0.437, 0.8, 0.313);\n\n// Vertical acceleration. Positive values don't currently work, sorry (zero works because of the a-posteriori collision checks)\nconst float GRAVITY = -0.1;\n\n#else // BOUNCY\n\nconst float SPHERE_RADIUS = 0.05;\nconst vec3 SPHERE_INITIAL_POSITION = vec3(1. - SPHERE_RADIUS, SPHERE_RADIUS, 0.5);\nconst vec3 SPHERE_INITIAL_VELOCITY = vec3(-1.75, 2.384, 1.183);\nconst float GRAVITY = -2.7;\n\n#endif\n\n\n// if 1, use a hash of iDate.w so the light positions will be different in each run\n#define MORE_RANDOM_LIGHT_POSITIONS 1\n\n\nconst float VIEW_ANGLE_FACTOR = 2.; // Lower value means wider FOV\nconst float CAMERA_Z = -2.;         // Values >= 0. are not supported. Values > -0.5 may cause unexpected clipping\n\n\n// If 1, the numerical integration performed by pass 2 and 3 (in BufferB and BufferC) will be split into two parts.\n// Two values for each patch need to be added together when used in pass 3 and 4.\n// This means that for those two passes, more threads are doing the work, which may help GPU utilization.\n// Doesn't make a big difference to frame rate, but it makes the animation much smoother on my iGPU.\n// Not using this approach for pass4 because I didn't want to do twice as many texture fetches during the final render, and it\n//      might also prevent applying safety bounds to the series acceleration.\n// (Obviously the underlying problem is that this is all a really silly thing to be doing in pixel shaders, rather\n//      than a compute shader which could use standard reduction techniques.)\n#define SPLIT_PASSES 1\n\n\n// Changing this is probably only useful if MORE_RANDOM_LIGHT_POSITIONS == 0\nconst uint HASH_SEED = 0x85d59261u;\n\n\n\n// How to scale the light flux values so they are not too small to represent as 16-bit floats (in case the buffers are half-precision)\nconst float PATCH_FLUX_ENCODE_SCALE = 1024.;\nconst float PATCH_FLUX_DECODE_SCALE = 1./PATCH_FLUX_ENCODE_SCALE;\n\n#define FP16_BUFFER_COMPATIBLE (MESH_SIZE < 64)\n\n\n// Nothing below this point is configurable\n\n\n// Constants used to specify interpolation type\n#define NO_INTERPOLATION 0\n#define BILINEAR_INTERPOLATION 1\n#define CATMULL_ROM 2\n#define CUBIC_BSPLINE 3\n#define MITCHELL_NETRAVALI 4\n\n\nconst float PI = 3.141592653589793;\n\n\n/*\n    Mesh size restrictions in the code:\n        Sizes are powers of 2\n        For squares, number of rows and columns must be same\n        Spheres must have same number of rows as squares\n        Number of columns for spheres is twice the number of rows\n*/\n#if MESH_SIZE == 8\nconst int MESH_SQUARE_ROWS = 8;\nconst int MESH_SQUARE_COLUMNS = 8;\nconst int MESH_SQUARE_SHIFT = 3; // Always same for rows and columns, currently\nconst int MESH_SPHERE_ROWS = 8;\nconst int MESH_SPHERE_COLUMNS = 16;\n#elif MESH_SIZE == 32\nconst int MESH_SQUARE_ROWS = 32;\nconst int MESH_SQUARE_COLUMNS = 32;\nconst int MESH_SQUARE_SHIFT = 5; // Always same for rows and columns, currently\nconst int MESH_SPHERE_ROWS = 32;\nconst int MESH_SPHERE_COLUMNS = 64;\n#elif MESH_SIZE == 64\nconst int MESH_SQUARE_ROWS = 64;\nconst int MESH_SQUARE_COLUMNS = 64;\nconst int MESH_SQUARE_SHIFT = 6; // Always same for rows and columns, currently\nconst int MESH_SPHERE_ROWS = 64;\nconst int MESH_SPHERE_COLUMNS = 128;\n#else // default to 16\nconst int MESH_SQUARE_ROWS = 16;\nconst int MESH_SQUARE_COLUMNS = 16;\nconst int MESH_SQUARE_SHIFT = 4; // Always same for rows and columns, currently\nconst int MESH_SPHERE_ROWS = 16;\nconst int MESH_SPHERE_COLUMNS = 32;\n#endif\n\nconst int MESH_SPHERE_ROW_SHIFT = MESH_SQUARE_SHIFT + 1;\n\nconst int MESH_COUNT_SQUARE = MESH_SQUARE_ROWS*MESH_SQUARE_COLUMNS;\nconst int MESH_COUNT_SPHERE = MESH_SPHERE_ROWS*MESH_SPHERE_COLUMNS;\n\nconst float SQUARE_PATCH_RECIPROCAL_AREA = float(MESH_SQUARE_ROWS * MESH_SQUARE_COLUMNS);\nconst float SQUARE_PATCH_AREA = 1. / SQUARE_PATCH_RECIPROCAL_AREA;\n\n\n// Much of the code uses contiguous indexes for mesh patches (1D rather than 2D)\nconst int MESH_OFFSET_LEFT = 0;\nconst int MESH_OFFSET_RIGHT = MESH_OFFSET_LEFT + MESH_COUNT_SQUARE;\nconst int MESH_OFFSET_BOTTOM = MESH_OFFSET_RIGHT + MESH_COUNT_SQUARE;\nconst int MESH_OFFSET_TOP = MESH_OFFSET_BOTTOM + MESH_COUNT_SQUARE;\nconst int MESH_OFFSET_BACK = MESH_OFFSET_TOP + MESH_COUNT_SQUARE;\nconst int MESH_OFFSET_SPHERE = MESH_OFFSET_BACK + MESH_COUNT_SQUARE;\nconst int MESH_COUNT = MESH_OFFSET_SPHERE + MESH_COUNT_SPHERE;\n\n// Meshes are stored in the buffers as 2D blocks of values (to be more GPU-friendly)\n// They are all placed at the top of the buffer (all have same start y value)\n// The following constants give the starting x value for each mesh:\nconst int MESH_X_OFFSET_LEFT = 0;\nconst int MESH_X_OFFSET_RIGHT = MESH_X_OFFSET_LEFT + MESH_SQUARE_COLUMNS;\nconst int MESH_X_OFFSET_BOTTOM = MESH_X_OFFSET_RIGHT + MESH_SQUARE_COLUMNS;\nconst int MESH_X_OFFSET_TOP = MESH_X_OFFSET_BOTTOM + MESH_SQUARE_COLUMNS;\nconst int MESH_X_OFFSET_BACK = MESH_X_OFFSET_TOP + MESH_SQUARE_COLUMNS;\nconst int MESH_X_OFFSET_SPHERE = MESH_X_OFFSET_BACK + MESH_SQUARE_COLUMNS;\nconst int MESH_X_COUNT = MESH_X_OFFSET_SPHERE + MESH_SPHERE_COLUMNS;\n\n// These constants are only used for encoding the location of the light\n// (light can't be on the sphere, sorry!)\nconst int SIDE_LEFT = 0;\nconst int SIDE_RIGHT = 1;\nconst int SIDE_BOTTOM = 2;\nconst int SIDE_TOP = 3;\nconst int SIDE_BACK = 4;\n\n// y coordinate for misc. data in BufferD\nconst int BUFFER_D_MISC_DATA_ROW = 2*MESH_SQUARE_ROWS;\n\n// x coordinates for misc. data in BufferD\nconst int BUFFER_D_MAGIC_NUMBER = 0;\nconst int BUFFER_D_LIGHT_DATA = 1;\nconst int BUFFER_D_SPHERE_CURRENT_POSITION = 2;\nconst int BUFFER_D_SPHERE_PREV_FRAME_POSITION = 3;\nconst int BUFFER_D_SPHERE_P0 = 4;\nconst int BUFFER_D_SPHERE_V0 = 5;\nconst int BUFFER_D_SPHERE_DATA_MAX = 5; // largest of the above values\nconst int BUFFER_D_LIGHT_CURRENT_SEQNUM = 6;\n\nconst vec4 MAGIC_NUMBER = vec4(958,-293,-408,283);\n\n#if SPLIT_PASSES\nconst int BUFFER_B_AND_C_ROW_COUNT = 2*MESH_SQUARE_ROWS;\n#else\nconst int BUFFER_B_AND_C_ROW_COUNT = MESH_SQUARE_ROWS;\n#endif\n\n\n\nint get_mesh_base_index(int index) {\n    return min(index & ~(MESH_COUNT_SQUARE-1), MESH_OFFSET_SPHERE);\n}\n\nivec2 get_row_and_column(bool is_sphere, int offset) {\n    int columns_mask = is_sphere ? (MESH_SPHERE_COLUMNS-1) : (MESH_SQUARE_COLUMNS-1);\n    int row_shift = is_sphere ? MESH_SPHERE_ROW_SHIFT : MESH_SQUARE_SHIFT;\n\n    return ivec2(offset & columns_mask, offset >> row_shift);\n}\n\n// Although a contiguous range of indexes is used for all patches, most of the code is specialized to\n// work with either the squares or the sphere (for performance reasons) hence the specialized functions here.\n\nvec3 get_point_for_patch_on_sphere(vec3 sphere_c, int index, float f_row, float f_column, out vec3 N) {\n    vec2 row_and_col = vec2(get_row_and_column(true, index - MESH_OFFSET_SPHERE));\n    \n    #if 1 // this should be better (especially for patches in the circle at the top and bottom of the sphere)\n    \n    float t = PI/float(MESH_SPHERE_ROWS) * row_and_col.y;\n    float stheta0 = sin(t + PI*(-0.5));\n    float stheta1 = sin(t + PI*(-0.5 + 1./float(MESH_SPHERE_ROWS)));\n    float y = (1.-f_row)*stheta0 + f_row*stheta1;\n    \n    float cos_theta = sqrt(1. - y*y);\n    \n    #else // this might be faster but it doesn't seem to make much difference\n    \n    float theta = PI*(-0.5 + 1./float(MESH_SPHERE_ROWS) * (row_and_col.y + f_row));\n    float y = sin(theta);\n    float cos_theta = cos(theta);\n    \n    #endif\n\n    float phi = 2. / float(MESH_SPHERE_COLUMNS) * PI*(row_and_col.x + f_column);\n\n    float x = cos(phi)*cos_theta;\n    float z = sin(phi)*cos_theta;\n\n    N = vec3(x, y, z);\n    \n    return sphere_c + SPHERE_RADIUS * vec3(x, y, z);\n}\n\nvec3 get_normal_for_patch_not_sphere(int index) {\n    int base = get_mesh_base_index(index);\n    vec3 N;\n    \n    if (index < MESH_OFFSET_RIGHT) {\n        N = vec3(1, 0, 0);\n    } else if (index < MESH_OFFSET_BOTTOM) {\n        N = vec3(-1, 0, 0);\n    } else if (index < MESH_OFFSET_TOP) {\n        N = vec3(0, 1, 0);\n    } else if (index < MESH_OFFSET_BACK) {\n        N = vec3(0, -1, 0);\n    } else {\n        N = vec3(0, 0, -1);\n    }\n\n    return N;\n}\n\nvec3 get_point_for_patch_not_sphere(int index, int base, float f_row, float f_column) {\n    vec2 frow_and_col = vec2(get_row_and_column(false, index - base));\n\n    float s = 1. / float(MESH_SQUARE_COLUMNS) * (frow_and_col.x + f_column);\n    float t = 1. / float(MESH_SQUARE_ROWS) * (frow_and_col.y + f_row);\n    \n    vec3 P;\n\n    if (base == MESH_OFFSET_LEFT) {\n        P = vec3(0, t, s);\n    } else if (base == MESH_OFFSET_RIGHT) {\n        P = vec3(1, t, s);\n    } else if (base == MESH_OFFSET_BOTTOM) {\n        P = vec3(s, 0, t);\n    } else if (base == MESH_OFFSET_TOP) {\n        P = vec3(s, 1, t);\n    } else {\n        P = vec3(s, t, 1);\n    }\n\n    return P;\n}\n\n// This is one of the most performance-critical functions (used in the inner loops)\n// sphere_check_value is precomputed value of dot(P1_sphere_c_delta, P1_sphere_c_delta) - SPHERE_RADIUS*SPHERE_RADIUS\n// Returns -PI * form factor (final sum needs to be scaled)\nfloat form_factor(vec3 P1_sphere_c_delta, float sphere_check_value, vec3 P1, vec3 P2, vec3 N1, vec3 N2, bool need_shadow_check) {\n    vec3 V = P2 - P1;\n    \n    float d1 = dot(N1, V);\n    float d2 = dot(N2, V);\n    \n    float dist_sq = dot(V, V);\n\n    if (need_shadow_check) { // this is only done when neither P1 or P2 is on the sphere\n        // Test if the discriminant in the sphere intersection formula is positive.\n        // In this scene, if the line intersects the sphere, it's impossible for P1 and P2 to be on same side of sphere\n        \n        float b = dot(V, P1_sphere_c_delta);\n\n        if (b*b > dist_sq * sphere_check_value) {\n            return 0.;\n        }\n    } else {\n        // P1 or P2 is on the sphere\n        // Check if either normal is pointing away from the other point\n        // Also check if the points are very close together (can't happen if neither point is on the sphere)\n        // (if points are close together, assume they are simply in shadow to avoid precision issues)\n        if (dist_sq < 2e-4 || d1 <= 0. || d2 >= 0.) {\n            return 0.;\n        }\n    }\n    \n    return d1*d2 / (dist_sq*dist_sq);\n}\n\n// Simplified version of the above function, for case where one of the points is on the sphere.\n// This is one of the most performance-critical functions (used in the inner loops)\n// Returns -PI * form factor (final sum needs to be scaled)\nfloat form_factor_no_sphere_check(vec3 P1, vec3 P2, vec3 N1, vec3 N2) {\n    vec3 V = P2 - P1;\n\n    float dist_sq = dot(V, V);\n\n    // Also check if the points are very close together\n    // (if points are close together, assume they are simply in shadow to avoid precision issues)\n    if (dist_sq < 2e-4) {\n        return 0.;\n    }\n\n    float d1 = dot(N1, V);\n    float d2 = dot(N2, V);\n\n    // Check if either normal is pointing away from the other point\n    if (d1 <= 0. || d2 >= 0.) {\n        return 0.;\n    }\n    \n    return d1*d2 / (dist_sq*dist_sq);\n}\n\nfloat area_for_patch(int index) {\n    if (index >= MESH_OFFSET_SPHERE) {\n        float row = float((index - MESH_OFFSET_SPHERE) >> MESH_SPHERE_ROW_SHIFT);\n\n        float theta1 = PI*(-0.5 + 1./float(MESH_SPHERE_ROWS)*row);\n        float theta2 = PI*(-0.5 + 1./float(MESH_SPHERE_ROWS)*(row + 1.));\n\n        return SPHERE_RADIUS*SPHERE_RADIUS * 2.*PI * 1./float(MESH_SPHERE_COLUMNS) * abs(sin(theta1) - sin(theta2));\n    } else {\n        return SQUARE_PATCH_AREA;\n    }\n}\n\n// Functions for packing and unpacking the light data into integer bits that are safe to store as a 16-bit float\n// Need to make sure no data is stored in bits that will be lost during conversion to/from 16-bit float,\n//      also making sure that the bit pattern is not a NaN, or infinity, or denormal when converted to 16-bit\n\n#if FP16_BUFFER_COMPATIBLE\nivec2 pack_light_info(int side_num, ivec2 i_minmax, ivec2 j_minmax) {\n    return (ivec2(side_num | (i_minmax.x << 3) | (i_minmax.y << 8), (j_minmax.x << 3) | (j_minmax.y << 8)) << 13) | 0x40000000;\n}\n\nint unpack_light_side(int val) {\n    return (val >> 13) & 7;\n}\n\nivec2 unpack_light_i_minmax(int val) {\n    return ivec2((val >> 16) & (MESH_SQUARE_ROWS-1), (val >> 21) & (MESH_SQUARE_ROWS-1));\n}\n\nivec2 unpack_light_j_minmax(int val) {\n    return ivec2((val >> 16) & (MESH_SQUARE_COLUMNS-1), (val >> 21) & (MESH_SQUARE_COLUMNS-1));\n}\n#else\nivec2 pack_light_info(int side_num, ivec2 i_minmax, ivec2 j_minmax) {\n    return ivec2(side_num | (i_minmax.x << 3) | (i_minmax.y << 11), (j_minmax.x << 3) | (j_minmax.y << 11)) | 0x40000000;\n}\n\nint unpack_light_side(int val) {\n    return val & 7;\n}\n\nivec2 unpack_light_i_minmax(int val) {\n    return ivec2((val >> 3) & (MESH_SQUARE_ROWS-1), (val >> 11) & (MESH_SQUARE_ROWS-1));\n}\n\nivec2 unpack_light_j_minmax(int val) {\n    return ivec2((val >> 3) & (MESH_SQUARE_COLUMNS-1), (val >> 11) & (MESH_SQUARE_COLUMNS-1));\n}\n#endif\n\nfloat get_light_scale(ivec2 i_minmax, ivec2 j_minmax) { // i.e. divide by number of patches covered by light\n    return 1. / float((i_minmax.y - i_minmax.x + 1)*(j_minmax.y - j_minmax.x + 1));\n}\n\nvec3 get_albedo(int base_index) {\n    if (base_index==MESH_OFFSET_LEFT) {\n        return LEFT_WALL_ALBEDO;\n    } else if (base_index==MESH_OFFSET_RIGHT) {\n        return RIGHT_WALL_ALBEDO;\n    } else if (base_index==MESH_OFFSET_SPHERE) {\n        return SPHERE_ALBEDO;\n    } else {\n        return ROOM_ALBEDO;\n    }\n}\n\n// Form factors are precomputed for squares that are next to each other\n// This is not for performance, but rather because numeric integration with just four points\n//      on each patch is very inaccurate for those pairs.\n// (assumes there won't be any shadow, which is not safe if the sphere size is reduced)\n// To avoid performance impact, figure out what the mesh index would be for the other patch\n//      for each of these cases to apply.\nivec2 get_edge_form_factor_indexes(int base, int x, int y) {\n    ivec2 indexes = ivec2(-1);\n    \n    if (base==MESH_OFFSET_LEFT) {\n        if (x==MESH_SQUARE_COLUMNS-1) {\n            indexes.x = MESH_OFFSET_BACK + 0 + y*MESH_SQUARE_COLUMNS;\n        }\n        \n        if (y==0) {\n            indexes.y = MESH_OFFSET_BOTTOM + 0 + x*MESH_SQUARE_COLUMNS;\n        } else if (y==MESH_SQUARE_ROWS-1) {\n            indexes.y = MESH_OFFSET_TOP + 0 + x*MESH_SQUARE_COLUMNS;\n        }\n    } else if (base==MESH_OFFSET_RIGHT) {\n        if (x==MESH_SQUARE_COLUMNS-1) {\n            indexes.x = MESH_OFFSET_BACK + MESH_SQUARE_COLUMNS-1 + y*MESH_SQUARE_COLUMNS;\n        }\n        \n        if (y==0) {\n            indexes.y = MESH_OFFSET_BOTTOM + MESH_SQUARE_COLUMNS-1 + x*MESH_SQUARE_COLUMNS;\n        } else if (y==MESH_SQUARE_ROWS-1) {\n            indexes.y = MESH_OFFSET_TOP + MESH_SQUARE_COLUMNS-1 + x*MESH_SQUARE_COLUMNS;\n        }\n    } else if (base==MESH_OFFSET_BACK) {\n        if (x==0) {\n            indexes.x = MESH_OFFSET_LEFT + MESH_SQUARE_COLUMNS-1 + y*MESH_SQUARE_COLUMNS;\n        } else if (x==MESH_SQUARE_COLUMNS-1) {\n            indexes.x = MESH_OFFSET_RIGHT + MESH_SQUARE_COLUMNS-1 + y*MESH_SQUARE_COLUMNS;\n        }\n        \n        if (y==0) {\n            indexes.y = MESH_OFFSET_BOTTOM + (MESH_SQUARE_ROWS-1)*MESH_SQUARE_COLUMNS + x;\n        } else if (y==MESH_SQUARE_ROWS-1) {\n            indexes.y = MESH_OFFSET_TOP + (MESH_SQUARE_ROWS-1)*MESH_SQUARE_COLUMNS + x;\n        }\n    } else if (base==MESH_OFFSET_TOP) {\n        if (x==0) {\n            indexes.x = MESH_OFFSET_LEFT + (MESH_SQUARE_ROWS-1)*MESH_SQUARE_COLUMNS + y;\n        } else if (x==MESH_SQUARE_COLUMNS-1) {\n            indexes.x = MESH_OFFSET_RIGHT + (MESH_SQUARE_ROWS-1)*MESH_SQUARE_COLUMNS + y;\n        }\n        \n        if (y==MESH_SQUARE_ROWS-1) {\n            indexes.y = MESH_OFFSET_BACK + (MESH_SQUARE_ROWS-1)*MESH_SQUARE_COLUMNS + x;\n        }\n    } else if (base==MESH_OFFSET_BOTTOM) {\n        if (x==0) {\n            indexes.x = MESH_OFFSET_LEFT + 0*MESH_SQUARE_COLUMNS + y;\n        } else if (x==MESH_SQUARE_COLUMNS-1) {\n            indexes.x = MESH_OFFSET_RIGHT + 0*MESH_SQUARE_COLUMNS + y;\n        }\n        \n        if (y==MESH_SQUARE_ROWS-1) {\n            indexes.y = MESH_OFFSET_BACK + 0*MESH_SQUARE_COLUMNS + x;\n        }\n    }\n   \n    return indexes;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Copyright (C) 2024 Kaia Vintr\n    \n    Code is licensed only for personal, non-commercial use on the Shadertoy\n    website. You may not copy all or any part of the code into another Shadertoy\n    shader (whether by using Shadertoy's \"fork\" feature or by some other means).\n    You may not distribute or use all or any part of the code outside of\n    the Shadertoy website, even if the code is accessed via the Shadertoy API or\n    web server. You may not use the code or its output to train or fine-tune\n    machine learning models (e.g. \"AI\" models). You may not use the code to\n    create image or video content for publication or distribution, except\n    screenshots or brief video clips of the output of the unmodified code to be\n    used strictly in a manner that would be permitted as \"fair use\" under U.S.\n    copyright law (for example, you may not use the code to create NFTs or\n    YouTube videos). If any provision of these license terms is held to be\n    invalid or unenforceable, that provision shall be limited to the minimum\n    extent necessary, and the remaining provisions shall remain in full effect.\n    \n    Please contact Kaia Vintr with questions regarding this code\n    via direct message to @kaiavintr.bsky.social on BlueSky (preferred)\n    or @KaiaVintr on Twitter, or via a comment on this shader.\n    \n    URL of the Shadertoy website page where this code is intended to be used\n    (page for this \"shader\"):\n    https://www.shadertoy.com/view/lX2BDV\n    \n    Code is archived at:\n    https://github.com/kaiavintr/shadertoy_experiments/tree/main/ClassicalRadiosityTest\n    \n*/\n\n// Various things are configurable -- see Common\n\n// Since this is the first pass, it only needs to gathers light from the light source (not from all surfaces).\n\n// iChannel1 contains sphere and light locations (BufferD)\n\nvec3 get_point_for_patch(vec3 sphere_c, int index, float f_row, float f_column, out vec3 N) {\n    if (index < MESH_OFFSET_SPHERE) {\n        N = get_normal_for_patch_not_sphere(index);\n        \n        return get_point_for_patch_not_sphere(index, get_mesh_base_index(index), f_row, f_column);\n    } else {\n        return get_point_for_patch_on_sphere(sphere_c, index, f_row, f_column, N);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    if (y >= MESH_SQUARE_ROWS || x >= MESH_X_COUNT) {\n        return;\n    }\n    \n    vec3 sphere_c = texelFetch(iChannel1, ivec2(BUFFER_D_SPHERE_CURRENT_POSITION, BUFFER_D_MISC_DATA_ROW), 0).rgb;\n    \n    bool use_initial_data = iFrame == 0 || texelFetch(iChannel1, ivec2(BUFFER_D_MAGIC_NUMBER, BUFFER_D_MISC_DATA_ROW), 0) != MAGIC_NUMBER;\n    \n    if (use_initial_data) {\n        sphere_c = SPHERE_INITIAL_POSITION;\n    }\n    \n    bool is_sphere = x >= MESH_X_OFFSET_SPHERE;\n\n    int base = is_sphere ? MESH_X_OFFSET_SPHERE : (x & ~(MESH_SQUARE_COLUMNS-1));\n    int columns = is_sphere ? MESH_SPHERE_COLUMNS : MESH_SQUARE_COLUMNS;\n\n    x -= base;\n    base *= MESH_SQUARE_ROWS;\n\n    \n    float sum = 0.;\n\n    int light_side_base;\n    ivec2 light_i_minmax, light_j_minmax;\n    \n    if (use_initial_data) { \n        light_side_base = LIGHT_SIDE_INITIAL*MESH_COUNT_SQUARE;\n        light_i_minmax = LIGHT_I_MINMAX_INITIAL;\n        light_j_minmax = LIGHT_J_MINMAX_INITIAL;\n    } else {\n        int light_side;\n        ivec2 val = floatBitsToInt(texelFetch(iChannel1, ivec2(BUFFER_D_LIGHT_DATA, BUFFER_D_MISC_DATA_ROW), 0).xy);\n        \n        light_side = unpack_light_side(val.x);\n        light_i_minmax = unpack_light_i_minmax(val.x);\n        light_j_minmax = unpack_light_j_minmax(val.y);\n        \n        light_side_base = light_side*MESH_COUNT_SQUARE;\n    }\n    \n    float light_scale = get_light_scale(light_i_minmax, light_j_minmax);\n    \n    int receiving_patch_index = base + y*columns + x;\n    \n    #if SHOW_THIRD_BOUNCE\n    if (base != light_side_base) {\n        vec3 N1_a;\n        vec3 P1_a = get_point_for_patch(sphere_c, receiving_patch_index, 0.25, 0.25, N1_a);\n        vec3 N1_b;\n        vec3 P1_b = get_point_for_patch(sphere_c, receiving_patch_index, 0.25, 0.75, N1_b);\n        vec3 N1_c;\n        vec3 P1_c = get_point_for_patch(sphere_c, receiving_patch_index, 0.75, 0.25, N1_c);\n        vec3 N1_d;\n        vec3 P1_d = get_point_for_patch(sphere_c, receiving_patch_index, 0.75, 0.75, N1_d);\n        \n        // indexes of patches for which form factor is precomputed\n        ivec2 edge_ff = get_edge_form_factor_indexes(base, x, y);\n        \n        // precomputing some things to speed up the shadow checks in the inner loop (not used if is_sphere)\n        vec3 sph_delta_a = P1_a-sphere_c;\n        vec3 sph_delta_b = P1_b-sphere_c;\n        vec3 sph_delta_c = P1_c-sphere_c;\n        vec3 sph_delta_d = P1_d-sphere_c;\n        \n        float sph_val_a = dot(sph_delta_a,sph_delta_a) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_b = dot(sph_delta_b,sph_delta_b) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_c = dot(sph_delta_c,sph_delta_c) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_d = dot(sph_delta_d,sph_delta_d) - SPHERE_RADIUS*SPHERE_RADIUS;\n        \n        int light_row_inc = MESH_SQUARE_COLUMNS - 1 + light_j_minmax.x - light_j_minmax.y;\n        int light_cell_count = (light_i_minmax.y - light_i_minmax.x + 1) * (light_j_minmax.y - light_j_minmax.x + 1);\n        int light_index_start = light_side_base + light_i_minmax.x*MESH_SQUARE_COLUMNS + light_j_minmax.x;\n        \n        int j = light_j_minmax.x;\n        int index_src = light_index_start;\n        \n        for (int lcell=0; lcell < light_cell_count; lcell++) {\n            vec3 N2 = get_normal_for_patch_not_sphere(index_src);\n            \n            float ffsum = 0.0;\n\n            for (float sample_src_i = 0.25; sample_src_i < 1.; sample_src_i += 0.5) {\n                for (float sample_src_j = 0.25; sample_src_j < 1.; sample_src_j += 0.5) {\n                    vec3 P2 = get_point_for_patch_not_sphere(index_src, light_side_base, sample_src_i, sample_src_j);\n                    \n                    ffsum += form_factor(sph_delta_a, sph_val_a, P1_a, P2, N1_a, N2, ! is_sphere);\n                    ffsum += form_factor(sph_delta_b, sph_val_b, P1_b, P2, N1_b, N2, ! is_sphere);\n                    ffsum += form_factor(sph_delta_c, sph_val_c, P1_c, P2, N1_c, N2, ! is_sphere);\n                    ffsum += form_factor(sph_delta_d, sph_val_d, P1_d, P2, N1_d, N2, ! is_sphere);              \n                }\n            }\n            \n            // Form factor for pair of squares that are at right angles to one another, sharing an edge\n            // Value is expected to be multiplied by -PI * 16. (factor is divided out at the end of the loop)\n            // Value is also expected to be divided by receiving patch area (we multiply by area later to get flux)\n            //      hence the multiplication by SQUARE_PATCH_RECIPROCAL_AREA\n            // (difference is less noticeable in this pass though)\n            if (index_src==edge_ff.x || index_src==edge_ff.y) {\n                ffsum = -PI * 16. * 0.20004377607540316 * SQUARE_PATCH_RECIPROCAL_AREA;\n            }\n            \n            sum += ffsum;\n\n            index_src++;\n            \n            if (++j > light_j_minmax.y) {\n                j = light_j_minmax.x;\n                index_src += light_row_inc;\n            }\n        }\n    }\n    #endif\n    \n    // Computing the outbound flux for this patch\n\n    // (Currently there's only one light and these are scene-wide constants, but applying them here leaves open the possibility of adding more lights.)\n    vec3 flux_multiplier = light_scale * LIGHT_AMOUNT;\n    \n    // Getting irradiance from the integration performed by the above loops\n    // 1./16. is the divisor for the integration sampling (which wasn't multiplied in the integration loop)\n    // Area of each light source patch also wasn't multiplied in the integration loop, so do it now.\n    vec3 final_color = sum * (-1./PI * 1./16. * SQUARE_PATCH_AREA) * flux_multiplier;\n    \n    // Multiply irradiance by albedo to get reflected part of radiosity\n    final_color *= get_albedo(base);\n    \n    #if SHOW_SECOND_BOUNCE\n    // Add radiant exitance (emitted component of radioisity) if any, to get total radiosity\n    if (base == light_side_base && x >= light_j_minmax.x && x <= light_j_minmax.y && y >= light_i_minmax.x && y <= light_i_minmax.y) {\n        final_color += flux_multiplier;\n    }\n    #endif\n\n    // Compute outbound flux by multiplying by area (larger patches reflect more light and emit more light)\n    // (could do this above, but want to be consistent with the other shaders)\n    // Need to also multiply by some large number because otherwise the values are too small for 16-bit floating point\n    final_color *= PATCH_FLUX_ENCODE_SCALE*area_for_patch(receiving_patch_index);\n\n    fragColor = vec4(final_color, 1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    Copyright (C) 2024 Kaia Vintr\n    \n    Code is licensed only for personal, non-commercial use on the Shadertoy\n    website. You may not copy all or any part of the code into another Shadertoy\n    shader (whether by using Shadertoy's \"fork\" feature or by some other means).\n    You may not distribute or use all or any part of the code outside of\n    the Shadertoy website, even if the code is accessed via the Shadertoy API or\n    web server. You may not use the code or its output to train or fine-tune\n    machine learning models (e.g. \"AI\" models). You may not use the code to\n    create image or video content for publication or distribution, except\n    screenshots or brief video clips of the output of the unmodified code to be\n    used strictly in a manner that would be permitted as \"fair use\" under U.S.\n    copyright law (for example, you may not use the code to create NFTs or\n    YouTube videos). If any provision of these license terms is held to be\n    invalid or unenforceable, that provision shall be limited to the minimum\n    extent necessary, and the remaining provisions shall remain in full effect.\n    \n    Please contact Kaia Vintr with questions regarding this code\n    via direct message to @kaiavintr.bsky.social on BlueSky (preferred)\n    or @KaiaVintr on Twitter, or via a comment on this shader.\n    \n    URL of the Shadertoy website page where this code is intended to be used\n    (page for this \"shader\"):\n    https://www.shadertoy.com/view/lX2BDV\n    \n    Code is archived at:\n    https://github.com/kaiavintr/shadertoy_experiments/tree/main/ClassicalRadiosityTest\n    \n*/\n\n// Various things are configurable -- see Common\n\n// Second light gathering pass. It gathers light from all surfaces.\n// (could skip parts of the surface on same side as light, but that optimization is not implemented)\n\n// In order to get slightly better performance, it does it in two halves (so the next pass will need to add the halves together).\n// Otherwise there would be too few active threads and GPU utilization would be poor.\n// (disabled if SPLIT_PASSES == 0)\n\n// Messy because unfortunately I had to specialize parts of the loop to improve frame rate on an iGPU\n// Much of this code is identical to BufferC and BufferD shaders, sorry. \n// I'm wary of moving complex code into functions (especially passing textures as parameters, as Shadertoy forces you to do with Common\n//      functions) because of problems with WebGL shader compilation in Windows.\n\n// iChannel0 is output of previous pass (BufferA)\n// iChannel1 is previous content of BufferD (stores sphere and light locations)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    if (y >= BUFFER_B_AND_C_ROW_COUNT || x >= MESH_X_COUNT) {\n        return;\n    }\n    \n    vec3 sphere_c = texelFetch(iChannel1, ivec2(BUFFER_D_SPHERE_CURRENT_POSITION, BUFFER_D_MISC_DATA_ROW), 0).rgb;\n    \n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(BUFFER_D_MAGIC_NUMBER, BUFFER_D_MISC_DATA_ROW), 0) != MAGIC_NUMBER) {\n        sphere_c = SPHERE_INITIAL_POSITION;\n    }\n\n\n    #if SPLIT_PASSES\n    bool is_second_half = y >= MESH_SQUARE_ROWS;\n    \n    y &= MESH_SQUARE_ROWS - 1;\n    #endif\n\n    \n    bool is_sphere = x >= MESH_X_OFFSET_SPHERE;\n\n    int base = is_sphere ? MESH_X_OFFSET_SPHERE : (x & ~(MESH_SQUARE_COLUMNS-1));\n    int columns = is_sphere ? MESH_SPHERE_COLUMNS : MESH_SQUARE_COLUMNS;\n\n    x -= base;\n    base *= MESH_SQUARE_ROWS;\n\n\n    int receiving_patch_index = base + y*columns + x;\n    \n    vec3 sum = vec3(0);\n    \n    if (base != MESH_OFFSET_SPHERE) {\n        vec3 N1 = get_normal_for_patch_not_sphere(receiving_patch_index);\n        \n        vec3 P1_a = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.25, 0.25);\n        vec3 P1_b = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.25, 0.75);\n        vec3 P1_c = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.75, 0.25);\n        vec3 P1_d = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.75, 0.75);\n        \n        // indexes of patches for which form factor is precomputed\n        ivec2 edge_ff = get_edge_form_factor_indexes(base, x, y);\n        \n        // precomputing some things to speed up the shadow checks in the inner loop\n        vec3 sph_delta_a = P1_a-sphere_c;\n        vec3 sph_delta_b = P1_b-sphere_c;\n        vec3 sph_delta_c = P1_c-sphere_c;\n        vec3 sph_delta_d = P1_d-sphere_c;\n        \n        float sph_val_a = dot(sph_delta_a,sph_delta_a) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_b = dot(sph_delta_b,sph_delta_b) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_c = dot(sph_delta_c,sph_delta_c) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_d = dot(sph_delta_d,sph_delta_d) - SPHERE_RADIUS*SPHERE_RADIUS;\n\n        int index_src, end_index;\n        \n        #if SPLIT_PASSES\n        if ( ! is_second_half) {\n            index_src = 0;\n            end_index = base < MESH_OFFSET_TOP ? MESH_OFFSET_BACK : MESH_OFFSET_TOP;\n        } else {\n            index_src = base < MESH_OFFSET_TOP ? MESH_OFFSET_BACK : MESH_OFFSET_TOP;\n            end_index = base == MESH_OFFSET_BACK ? MESH_OFFSET_BACK : MESH_OFFSET_SPHERE;\n        }\n        #else\n        index_src = 0;\n        end_index = base == MESH_OFFSET_BACK ? MESH_OFFSET_BACK : MESH_OFFSET_SPHERE;\n        #endif\n        \n        for ( ; index_src < min(0, iFrame) + end_index; index_src++) {\n            if (index_src == base) index_src += MESH_COUNT_SQUARE;\n            \n            float ffsum = 0.0;\n            vec3 N2 = get_normal_for_patch_not_sphere(index_src);\n            int base_src = get_mesh_base_index(index_src);\n            \n            for (float sample_i = 0.25; sample_i < 1.; sample_i += 0.5) {\n                for (float sample_j = 0.25; sample_j < 1.; sample_j += 0.5) {\n                    vec3 P2 = get_point_for_patch_not_sphere(index_src, base_src, sample_i, sample_j);\n                    \n                    ffsum += form_factor(sph_delta_a, sph_val_a, P1_a, P2, N1, N2, true);\n                    ffsum += form_factor(sph_delta_b, sph_val_b, P1_b, P2, N1, N2, true);\n                    ffsum += form_factor(sph_delta_c, sph_val_c, P1_c, P2, N1, N2, true);\n                    ffsum += form_factor(sph_delta_d, sph_val_d, P1_d, P2, N1, N2, true);\n                }\n            }\n            \n            // Form factor for pair of squares that are at right angles to one another, sharing an edge\n            // Value is expected to be multiplied by -PI * 16. (factor is divided out at the end of the loop)\n            // Value is also expected to be divided by receiving patch area (we multiply by area later to get flux)\n            //      hence the multiplication by SQUARE_PATCH_RECIPROCAL_AREA\n            if (index_src==edge_ff.x || index_src==edge_ff.y) {\n                ffsum = -PI * 16. * 0.20004377607540316 * SQUARE_PATCH_RECIPROCAL_AREA;\n            }\n\n            ivec2 row_and_col = get_row_and_column(false, index_src - base_src);\n            \n            // Shifting right by MESH_SQUARE_SHIFT gives the y part of a patch index, which happens to be the texture x offset\n            //      here because number of rows and columns is the same in the square meshes\n            // (Code should be refactored to detect when index_src has moved to the next mesh, and call more expensive functions\n            //      to get both base_src and texture x offset, so they can be arbitrary.)\n            row_and_col.x += base_src >> MESH_SQUARE_SHIFT;\n            \n            // get outbound flux for patch (radiosity times patch area)\n            vec3 rad = texelFetch(iChannel0, row_and_col, 0).rgb;\n            \n            sum += rad * ffsum;\n        }\n        \n        #if SPLIT_PASSES\n        if (is_second_half)\n        #endif\n        \n        {\n            for (int index_src = MESH_OFFSET_SPHERE; index_src < min(0, iFrame) + MESH_COUNT; index_src++) {\n                float ffsum = 0.0;\n            \n                for (float sample_i = 0.25; sample_i < 1.; sample_i += 0.5) {\n                    for (float sample_j = 0.25; sample_j < 1.; sample_j += 0.5) {\n                        vec3 N2;\n                        vec3 P2 = get_point_for_patch_on_sphere(sphere_c, index_src, sample_i, sample_j, N2);\n                    \n                        ffsum += form_factor_no_sphere_check(P1_a, P2, N1, N2);\n                        ffsum += form_factor_no_sphere_check(P1_b, P2, N1, N2);\n                        ffsum += form_factor_no_sphere_check(P1_c, P2, N1, N2);\n                        ffsum += form_factor_no_sphere_check(P1_d, P2, N1, N2);\n                    }\n                }\n\n                ivec2 row_and_col = get_row_and_column(true, index_src - MESH_OFFSET_SPHERE);\n\n                // get outbound flux for patch (radiosity times patch area)\n                vec3 rad = texelFetch(iChannel0, ivec2(MESH_X_OFFSET_SPHERE + row_and_col.x, row_and_col.y), 0).rgb;\n            \n                sum += rad * ffsum;\n            }\n        }\n    } else {\n        vec3 N1_a;\n        vec3 P1_a = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.25, 0.25, N1_a);\n        \n        vec3 N1_b;\n        vec3 P1_b = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.25, 0.75, N1_b);\n\n        vec3 N1_c;\n        vec3 P1_c = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.75, 0.25, N1_c);\n\n        vec3 N1_d;\n        vec3 P1_d = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.75, 0.75, N1_d);\n        \n        int index_src, end_index;\n        \n        #if SPLIT_PASSES\n        if ( ! is_second_half) {\n            index_src = 0;\n            end_index = MESH_OFFSET_TOP;\n        } else {\n            index_src = MESH_OFFSET_TOP;\n            end_index = MESH_OFFSET_SPHERE;\n        }\n        #else\n        index_src = 0;\n        end_index = MESH_OFFSET_SPHERE;\n        #endif\n        \n        for ( ; index_src < min(0, iFrame) + end_index; index_src++) {\n            vec3 N2 = get_normal_for_patch_not_sphere(index_src);\n            int base_src = get_mesh_base_index(index_src);\n            \n            float ffsum = 0.0;\n            \n            for (float sample_i = 0.25; sample_i < 1.; sample_i += 0.5) {\n                for (float sample_j = 0.25; sample_j < 1.; sample_j += 0.5) {\n                    vec3 P2 = get_point_for_patch_not_sphere(index_src, base_src, sample_i, sample_j);\n                    \n                    ffsum += form_factor_no_sphere_check(P1_a, P2, N1_a, N2);\n                    ffsum += form_factor_no_sphere_check(P1_b, P2, N1_b, N2);\n                    ffsum += form_factor_no_sphere_check(P1_c, P2, N1_c, N2);\n                    ffsum += form_factor_no_sphere_check(P1_d, P2, N1_d, N2);\n                }\n            }\n\n            ivec2 row_and_col = get_row_and_column(false, index_src - base_src);\n            \n            // Shifting right by MESH_SQUARE_SHIFT gives the y part of a patch index, which happens to be the texture x offset\n            //      here because number of rows and columns is the same in the square meshes\n            // (Code should be refactored to detect when index_src has moved to the next mesh, and call more expensive functions\n            //      to get both base_src and texture x offset, so they can be arbitrary.)\n            row_and_col.x += base_src >> MESH_SQUARE_SHIFT;\n\n            // get outbound flux for patch (radiosity times patch area)\n            vec3 rad = texelFetch(iChannel0, row_and_col, 0).rgb;\n            \n            sum += rad * ffsum;\n        }\n    }\n    \n    // Get irradiance from the integration performed by the above loops\n    // 1./16. is the divisor for the integration sampling (which wasn't multiplied in the loop)\n    // -1./PI is another factor that was omitted for performance reasons\n    // PATCH_FLUX_DECODE_SCALE is a decoding factor that should have been applied to values fetched from the buffer\n    vec3 final_color = -1./PI * 1./16. * PATCH_FLUX_DECODE_SCALE * sum;\n    \n    // Multiply irradiance by albedo to get reflected part of radiosity\n    final_color *= get_albedo(base);\n    \n    #if SHOW_FIRST_BOUNCE\n\n    #if SPLIT_PASSES\n    if (is_second_half)\n    #endif\n    {\n        // Add radiant exitance (emitted component of radiosity) if any, to get total radiosity\n        int light_side;\n        ivec2 light_i_minmax, light_j_minmax;\n        \n        if (iFrame == 0 || texelFetch(iChannel1, ivec2(BUFFER_D_MAGIC_NUMBER, BUFFER_D_MISC_DATA_ROW), 0) != MAGIC_NUMBER) { \n            light_side = LIGHT_SIDE_INITIAL;\n            light_i_minmax = LIGHT_I_MINMAX_INITIAL;\n            light_j_minmax = LIGHT_J_MINMAX_INITIAL;\n        } else {\n            ivec2 val = floatBitsToInt(texelFetch(iChannel1, ivec2(BUFFER_D_LIGHT_DATA, BUFFER_D_MISC_DATA_ROW), 0).xy);\n            \n            light_side = unpack_light_side(val.x);\n            light_i_minmax = unpack_light_i_minmax(val.x);\n            light_j_minmax = unpack_light_j_minmax(val.y);\n        }\n        \n        if (base == light_side*MESH_COUNT_SQUARE && x >= light_j_minmax.x && x <= light_j_minmax.y && y >= light_i_minmax.x && y <= light_i_minmax.y) {\n            final_color += get_light_scale(light_i_minmax, light_j_minmax) * LIGHT_AMOUNT;\n        }\n    }\n    #endif\n    \n    // compute outbound flux by multiplying by area (larger patches reflect more light and emit more light)\n    // Need to also multiply by some large number because otherwise the values are too small for 16-bit floating point\n    final_color *= PATCH_FLUX_ENCODE_SCALE * area_for_patch(receiving_patch_index);\n\n    fragColor = vec4(final_color, 1.0);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    Copyright (C) 2024 Kaia Vintr\n    \n    Code is licensed only for personal, non-commercial use on the Shadertoy\n    website. You may not copy all or any part of the code into another Shadertoy\n    shader (whether by using Shadertoy's \"fork\" feature or by some other means).\n    You may not distribute or use all or any part of the code outside of\n    the Shadertoy website, even if the code is accessed via the Shadertoy API or\n    web server. You may not use the code or its output to train or fine-tune\n    machine learning models (e.g. \"AI\" models). You may not use the code to\n    create image or video content for publication or distribution, except\n    screenshots or brief video clips of the output of the unmodified code to be\n    used strictly in a manner that would be permitted as \"fair use\" under U.S.\n    copyright law (for example, you may not use the code to create NFTs or\n    YouTube videos). If any provision of these license terms is held to be\n    invalid or unenforceable, that provision shall be limited to the minimum\n    extent necessary, and the remaining provisions shall remain in full effect.\n    \n    Please contact Kaia Vintr with questions regarding this code\n    via direct message to @kaiavintr.bsky.social on BlueSky (preferred)\n    or @KaiaVintr on Twitter, or via a comment on this shader.\n    \n    URL of the Shadertoy website page where this code is intended to be used\n    (page for this \"shader\"):\n    https://www.shadertoy.com/view/lX2BDV\n    \n    Code is archived at:\n    https://github.com/kaiavintr/shadertoy_experiments/tree/main/ClassicalRadiosityTest\n    \n*/\n\n// Various things are configurable -- see Common\n\n// Third light gathering pass. It gathers light from all surfaces.\n\n// In order to get slightly better performance, it does it in two halves (so the next pass will need to add the halves together).\n// Otherwise there would be too few active threads and GPU utilization would be poor.\n// (disabled if SPLIT_PASSES == 0)\n\n// Messy because unfortunately I had to specialize parts of the loop to improve frame rate on an iGPU\n// Much of this code is identical to BufferB and BufferD shaders, sorry. \n// I'm wary of moving complex code into functions (especially passing textures as parameters, as Shadertoy forces you to do with Common\n//      functions) because of problems with WebGL shader compilation in Windows.\n\n\n// iChannel0 is output of previous pass (BufferB)\n// iChannel1 is previous content of BufferD (stores sphere and light locations)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    if (y >= BUFFER_B_AND_C_ROW_COUNT || x >= MESH_X_COUNT) {\n        return;\n    }\n    \n    vec3 sphere_c = texelFetch(iChannel1, ivec2(BUFFER_D_SPHERE_CURRENT_POSITION, BUFFER_D_MISC_DATA_ROW), 0).rgb;\n    \n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(BUFFER_D_MAGIC_NUMBER, BUFFER_D_MISC_DATA_ROW), 0) != MAGIC_NUMBER) {\n        sphere_c = SPHERE_INITIAL_POSITION;\n    }\n    \n    \n    #if SPLIT_PASSES\n    bool is_second_half = y >= MESH_SQUARE_ROWS;\n    \n    y &= MESH_SQUARE_ROWS - 1;\n    #endif\n\n\n    bool is_sphere = x >= MESH_X_OFFSET_SPHERE;\n\n    int base = is_sphere ? MESH_X_OFFSET_SPHERE : (x & ~(MESH_SQUARE_COLUMNS-1));\n    int columns = is_sphere ? MESH_SPHERE_COLUMNS : MESH_SQUARE_COLUMNS;\n\n    x -= base;\n    base *= MESH_SQUARE_ROWS;\n    \n\n    int receiving_patch_index = base + y*columns + x;\n    \n    vec3 sum = vec3(0);\n    \n    if (base != MESH_OFFSET_SPHERE) {\n        vec3 N1 = get_normal_for_patch_not_sphere(receiving_patch_index);\n        \n        vec3 P1_a = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.25, 0.25);\n        vec3 P1_b = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.25, 0.75);\n        vec3 P1_c = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.75, 0.25);\n        vec3 P1_d = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.75, 0.75);\n        \n        // indexes of patches for which form factor is precomputed\n        ivec2 edge_ff = get_edge_form_factor_indexes(base, x, y);\n        \n        // precomputing some things to speed up the shadow checks in the inner loop\n        vec3 sph_delta_a = P1_a-sphere_c;\n        vec3 sph_delta_b = P1_b-sphere_c;\n        vec3 sph_delta_c = P1_c-sphere_c;\n        vec3 sph_delta_d = P1_d-sphere_c;\n        \n        float sph_val_a = dot(sph_delta_a,sph_delta_a) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_b = dot(sph_delta_b,sph_delta_b) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_c = dot(sph_delta_c,sph_delta_c) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_d = dot(sph_delta_d,sph_delta_d) - SPHERE_RADIUS*SPHERE_RADIUS;\n        \n        int index_src, end_index;\n        \n        #if SPLIT_PASSES\n        if ( ! is_second_half) {\n            index_src = 0;\n            end_index = base < MESH_OFFSET_TOP ? MESH_OFFSET_BACK : MESH_OFFSET_TOP;\n        } else {\n            index_src = base < MESH_OFFSET_TOP ? MESH_OFFSET_BACK : MESH_OFFSET_TOP;\n            end_index = base == MESH_OFFSET_BACK ? MESH_OFFSET_BACK : MESH_OFFSET_SPHERE;\n        }\n        #else\n        index_src = 0;\n        end_index = base == MESH_OFFSET_BACK ? MESH_OFFSET_BACK : MESH_OFFSET_SPHERE;\n        #endif\n        \n        for ( ; index_src < min(0, iFrame) + end_index; index_src++) {\n            if (index_src == base) index_src += MESH_COUNT_SQUARE;\n            \n            float ffsum = 0.0;\n            vec3 N2 = get_normal_for_patch_not_sphere(index_src);\n            int base_src = get_mesh_base_index(index_src);\n            \n            for (float sample_i = 0.25; sample_i < 1.; sample_i += 0.5) {\n                for (float sample_j = 0.25; sample_j < 1.; sample_j += 0.5) {\n                    vec3 P2 = get_point_for_patch_not_sphere(index_src, base_src, sample_i, sample_j);\n                    \n                    ffsum += form_factor(sph_delta_a, sph_val_a, P1_a, P2, N1, N2, true);\n                    ffsum += form_factor(sph_delta_b, sph_val_b, P1_b, P2, N1, N2, true);\n                    ffsum += form_factor(sph_delta_c, sph_val_c, P1_c, P2, N1, N2, true);\n                    ffsum += form_factor(sph_delta_d, sph_val_d, P1_d, P2, N1, N2, true);\n                }\n            }\n            \n            // Form factor for pair of squares that are at right angles to one another, sharing an edge\n            // Value is expected to be multiplied by -PI * 16. (factor is divided out at the end of the loop)\n            // Value is also expected to be divided by receiving patch area (we multiply by area later to get flux)\n            //      hence the multiplication by SQUARE_PATCH_RECIPROCAL_AREA\n            if (index_src==edge_ff.x || index_src==edge_ff.y) {\n                ffsum = -PI * 16. * 0.20004377607540316 * SQUARE_PATCH_RECIPROCAL_AREA;\n            }\n\n            ivec2 row_and_col = get_row_and_column(false, index_src - base_src);\n            \n            // Shifting right by MESH_SQUARE_SHIFT gives the y part of a patch index, which happens to be the texture x offset\n            //      here because number of rows and columns is the same in the square meshes\n            // (Code should be refactored to detect when index_src has moved to the next mesh, and call more expensive functions\n            //      to get both base_src and texture x offset, so they can be arbitrary.)\n            row_and_col.x += base_src >> MESH_SQUARE_SHIFT;\n\n            // get outbound flux for patch (radiosity times patch area)\n            vec3 rad = texelFetch(iChannel0, row_and_col, 0).rgb;\n\n            #if SPLIT_PASSES\n            // add the second part of the flux for that patch\n            rad += texelFetch(iChannel0, row_and_col + ivec2(0, MESH_SQUARE_ROWS), 0).rgb;\n            #endif\n            \n            sum += rad * ffsum;\n        }\n        \n        #if SPLIT_PASSES\n        if (is_second_half)\n        #endif\n        \n        {\n            for (int index_src = MESH_OFFSET_SPHERE; index_src < min(0, iFrame) + MESH_COUNT; index_src++) {\n                float ffsum = 0.0;\n            \n                for (float sample_i = 0.25; sample_i < 1.; sample_i += 0.5) {\n                    for (float sample_j = 0.25; sample_j < 1.; sample_j += 0.5) {\n                        vec3 N2;\n                        vec3 P2 = get_point_for_patch_on_sphere(sphere_c, index_src, sample_i, sample_j, N2);\n                    \n                        ffsum += form_factor_no_sphere_check(P1_a, P2, N1, N2);\n                        ffsum += form_factor_no_sphere_check(P1_b, P2, N1, N2);\n                        ffsum += form_factor_no_sphere_check(P1_c, P2, N1, N2);\n                        ffsum += form_factor_no_sphere_check(P1_d, P2, N1, N2);\n                    }\n                }\n\n                ivec2 row_and_col = get_row_and_column(true, index_src - MESH_OFFSET_SPHERE);\n\n                row_and_col.x += MESH_X_OFFSET_SPHERE;\n\n                // get outbound flux for patch (radiosity times patch area)\n                vec3 rad = texelFetch(iChannel0, row_and_col, 0).rgb;\n\n                #if SPLIT_PASSES\n                // add the second part of the flux for that patch\n                rad += texelFetch(iChannel0, row_and_col + ivec2(0, MESH_SQUARE_ROWS), 0).rgb;\n                #endif\n\n                sum += rad * ffsum;\n            }\n        }\n    } else {\n        vec3 N1_a;\n        vec3 P1_a = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.25, 0.25, N1_a);\n        \n        vec3 N1_b;\n        vec3 P1_b = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.25, 0.75, N1_b);\n\n        vec3 N1_c;\n        vec3 P1_c = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.75, 0.25, N1_c);\n\n        vec3 N1_d;\n        vec3 P1_d = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.75, 0.75, N1_d);\n        \n        int index_src, end_index;\n        \n        #if SPLIT_PASSES\n        if ( ! is_second_half) {\n            index_src = 0;\n            end_index = MESH_OFFSET_TOP;\n        } else {\n            index_src = MESH_OFFSET_TOP;\n            end_index = MESH_OFFSET_SPHERE;\n        }\n        #else\n        index_src = 0;\n        end_index = MESH_OFFSET_SPHERE;\n        #endif\n        \n        for ( ; index_src < min(0, iFrame) + end_index; index_src++) {\n            vec3 N2 = get_normal_for_patch_not_sphere(index_src);\n            int base_src = get_mesh_base_index(index_src);\n            \n            float ffsum = 0.0;\n            \n            for (float sample_i = 0.25; sample_i < 1.; sample_i += 0.5) {\n                for (float sample_j = 0.25; sample_j < 1.; sample_j += 0.5) {\n                    vec3 P2 = get_point_for_patch_not_sphere(index_src, base_src, sample_i, sample_j);\n                    \n                    ffsum += form_factor_no_sphere_check(P1_a, P2, N1_a, N2);\n                    ffsum += form_factor_no_sphere_check(P1_b, P2, N1_b, N2);\n                    ffsum += form_factor_no_sphere_check(P1_c, P2, N1_c, N2);\n                    ffsum += form_factor_no_sphere_check(P1_d, P2, N1_d, N2);\n                }\n            }\n\n            ivec2 row_and_col = get_row_and_column(false, index_src - base_src);\n\n            // Shifting right by MESH_SQUARE_SHIFT gives the y part of a patch index, which happens to be the texture x offset\n            //      here because number of rows and columns is the same in the square meshes\n            // (Code should be refactored to detect when index_src has moved to the next mesh, and call more expensive functions\n            //      to get both base_src and texture x offset, so they can be arbitrary.)\n            row_and_col.x += base_src >> MESH_SQUARE_SHIFT;\n\n            // get outbound flux for patch (radiosity times patch area)\n            vec3 rad = texelFetch(iChannel0, row_and_col, 0).rgb;\n\n            #if SPLIT_PASSES\n            // add the second part of the flux for that patch\n            rad += texelFetch(iChannel0, row_and_col + ivec2(0, MESH_SQUARE_ROWS), 0).rgb;\n            #endif\n\n            sum += rad * ffsum;\n        }\n    }\n    \n    // Get irradiance from the integration performed by the above loops\n    // 1./16. is the divisor for the integration sampling (which wasn't multiplied in the loop)\n    // -1./PI is another factor that was omitted for performance reasons\n    // PATCH_FLUX_DECODE_SCALE is a decoding factor that should have been applied to values fetched from the buffer\n    vec3 final_color = -1./PI * 1./16. * PATCH_FLUX_DECODE_SCALE * sum;\n    \n    // Multiply irradiance by albedo to get reflected part of radiosity\n    final_color *= get_albedo(base);\n    \n    #if SHOW_DIRECT_LIGHT\n\n    #if SPLIT_PASSES\n    if (is_second_half)\n    #endif\n    {\n        // Add radiant exitance (emitted component of radiosity) if any, to get total radiosity\n        int light_side;\n        ivec2 light_i_minmax, light_j_minmax;\n        \n        if (iFrame == 0 || texelFetch(iChannel1, ivec2(BUFFER_D_MAGIC_NUMBER, BUFFER_D_MISC_DATA_ROW), 0) != MAGIC_NUMBER) { \n            light_side = LIGHT_SIDE_INITIAL;\n            light_i_minmax = LIGHT_I_MINMAX_INITIAL;\n            light_j_minmax = LIGHT_J_MINMAX_INITIAL;\n        } else {\n            ivec2 val = floatBitsToInt(texelFetch(iChannel1, ivec2(BUFFER_D_LIGHT_DATA, BUFFER_D_MISC_DATA_ROW), 0).xy);\n            \n            light_side = unpack_light_side(val.x);\n            light_i_minmax = unpack_light_i_minmax(val.x);\n            light_j_minmax = unpack_light_j_minmax(val.y);\n        }\n        \n        if (base == light_side*MESH_COUNT_SQUARE && x >= light_j_minmax.x && x <= light_j_minmax.y && y >= light_i_minmax.x && y <= light_i_minmax.y) {\n            final_color += get_light_scale(light_i_minmax, light_j_minmax) * LIGHT_AMOUNT;\n        }\n    }\n    #endif\n    \n    // compute outbound flux by multiplying by area (larger patches reflect more light and emit more light)\n    // Need to also multiply by some large number because otherwise the values are too small for 16-bit floating point\n    final_color *= PATCH_FLUX_ENCODE_SCALE * area_for_patch(receiving_patch_index);\n\n    fragColor = vec4(final_color, 1.0);\n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/*\n    Copyright (C) 2024 Kaia Vintr\n    \n    Code is licensed only for personal, non-commercial use on the Shadertoy\n    website. You may not copy all or any part of the code into another Shadertoy\n    shader (whether by using Shadertoy's \"fork\" feature or by some other means).\n    You may not distribute or use all or any part of the code outside of\n    the Shadertoy website, even if the code is accessed via the Shadertoy API or\n    web server. You may not use the code or its output to train or fine-tune\n    machine learning models (e.g. \"AI\" models). You may not use the code to\n    create image or video content for publication or distribution, except\n    screenshots or brief video clips of the output of the unmodified code to be\n    used strictly in a manner that would be permitted as \"fair use\" under U.S.\n    copyright law (for example, you may not use the code to create NFTs or\n    YouTube videos). If any provision of these license terms is held to be\n    invalid or unenforceable, that provision shall be limited to the minimum\n    extent necessary, and the remaining provisions shall remain in full effect.\n    \n    Please contact Kaia Vintr with questions regarding this code\n    via direct message to @kaiavintr.bsky.social on BlueSky (preferred)\n    or @KaiaVintr on Twitter, or via a comment on this shader.\n    \n    URL of the Shadertoy website page where this code is intended to be used\n    (page for this \"shader\"):\n    https://www.shadertoy.com/view/lX2BDV\n    \n    Code is archived at:\n    https://github.com/kaiavintr/shadertoy_experiments/tree/main/ClassicalRadiosityTest\n    \n*/\n\n// Various things are configurable -- see Common\n\n// Final light gathering pass. It gathers light from all surfaces.\n\n// BufferD also stores the sphere position and velocity, and the light position, so this shader updates those\n\n// Messy because unfortunately I had to specialize parts of the loop to improve frame rate on an iGPU\n// Much of this code is identical to BufferB and BufferC shaders, sorry. \n// I'm wary of moving complex code into functions (especially passing textures as parameters, as Shadertoy forces you to do with Common\n//      functions) because of problems with WebGL shader compilation in Windows.\n\n// iChannel0 is output of previous pass (BufferC)\n// iChannel1 is previous content of BufferD\n// iChannel2 is output of first pass, i.e. BufferA (not required if USE_SERIES_ACCELERATION is 0)\n// output of second pass is not used for series acceleration\n\nuint hash_fn1(uint h) { // fmix32 with added constant for seed\n    h ^= h >> 16;\n\n    h = h*0x85ebca6bu + HASH_SEED;\n\n    h ^= h >> 13;\n\n    h = h*0xc2b2ae35u;\n\n    return h ^ (h >> 16);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    if (y >= MESH_SQUARE_ROWS || x >= MESH_X_COUNT) {\n        if (y == BUFFER_D_MISC_DATA_ROW && x == BUFFER_D_MAGIC_NUMBER) {\n            fragColor = MAGIC_NUMBER;\n        } else if (y == BUFFER_D_MISC_DATA_ROW && x == BUFFER_D_LIGHT_DATA) {\n            bool use_initial_data = iFrame == 0 || texelFetch(iChannel1, ivec2(BUFFER_D_MAGIC_NUMBER, BUFFER_D_MISC_DATA_ROW), 0) != MAGIC_NUMBER;\n            \n            vec2 prev_val = texelFetch(iChannel1, ivec2(BUFFER_D_LIGHT_DATA, BUFFER_D_MISC_DATA_ROW), 0).xy;\n            \n            // Light position gets changed every LIGHT_CHANGE_INTERVAL seconds, so assign an integer sequence number to each interval and check if\n            //      current number is different from last number (which must be encoded in a way supported by 16-bit float buffers).\n            \n            int prev_seqnum = (floatBitsToInt(texelFetch(iChannel1, ivec2(BUFFER_D_LIGHT_CURRENT_SEQNUM, BUFFER_D_MISC_DATA_ROW), 0).x) >> 13) & 0x3fff;\n            \n            vec2 new_val = prev_val;\n            \n            int seqnum = int(1./LIGHT_CHANGE_INTERVAL * iTime);\n            \n            if (use_initial_data || (seqnum & 0x3fff) != prev_seqnum) {\n                ivec2 ival;\n                \n                if (use_initial_data) {\n                    ival = pack_light_info(LIGHT_SIDE_INITIAL, LIGHT_I_MINMAX_INITIAL, LIGHT_J_MINMAX_INITIAL);\n                } else {\n                    #if MORE_RANDOM_LIGHT_POSITIONS\n                    int h = int(hash_fn1(uint(iDate.w*1024.0)));\n                    #else\n                    int h = int(hash_fn1(uint(seqnum)));\n                    #endif\n                    \n                    int side = h & 63;\n                    \n                    // Getting value mod 5 (probably a silly way to do it)\n                    if (side >= 40) side -= 40;\n                    if (side >= 20) side -= 20;\n                    if (side >= 10) side -= 10;\n                    if (side >= 5) side -= 5;\n                    \n                    ivec2 ivals = ivec2((h>>6)&(MESH_SQUARE_ROWS-1), (h>>(6 + MESH_SQUARE_SHIFT))&(MESH_SQUARE_ROWS-1));\n                    ivec2 jvals = ivec2((h>>(6 + 2*MESH_SQUARE_SHIFT))&(MESH_SQUARE_COLUMNS-1), (h>>(6 + 3*MESH_SQUARE_SHIFT))&(MESH_SQUARE_COLUMNS-1));\n                    \n                    if (ivals.x > ivals.y) ivals = ivals.yx;\n                    if (jvals.x > jvals.y) jvals = jvals.yx;\n                    \n                    ival = pack_light_info(side, ivals, jvals);\n                }\n                \n                new_val = intBitsToFloat(ival);\n                \n                if (use_initial_data) prev_val = new_val;\n            }\n            \n            // Store previous value in .zw so Image shader can use it\n            fragColor = vec4(new_val, prev_val);\n        } else if (y == BUFFER_D_MISC_DATA_ROW && x == BUFFER_D_LIGHT_CURRENT_SEQNUM) {\n            // Store the current light position sequence number so we can test if it has changed in the next frame\n            fragColor = vec4(intBitsToFloat((int(1./LIGHT_CHANGE_INTERVAL * iTime)<<13) | 0x40000000), 0., 0., 0.);\n        } else if (y == BUFFER_D_MISC_DATA_ROW && x <= BUFFER_D_SPHERE_DATA_MAX) {\n            bool use_initial_data = iFrame == 0 || texelFetch(iChannel1, ivec2(BUFFER_D_MAGIC_NUMBER, BUFFER_D_MISC_DATA_ROW), 0) != MAGIC_NUMBER;\n            \n            // Simple frictionless motion, elastic collision, and gravity simulation\n            // Continuous collision detection, but with additional a-posteriori collision checks for robustness\n        \n            vec4 p = texelFetch(iChannel1, ivec2(BUFFER_D_SPHERE_P0, BUFFER_D_MISC_DATA_ROW), 0);\n            vec3 v = texelFetch(iChannel1, ivec2(BUFFER_D_SPHERE_V0, BUFFER_D_MISC_DATA_ROW), 0).xyz;\n            \n            // Not used here -- just copied to BUFFER_D_SPHERE_PREV_FRAME_POSITION so the Image shader can use it\n            vec3 p_old = texelFetch(iChannel1, ivec2(BUFFER_D_SPHERE_CURRENT_POSITION, BUFFER_D_MISC_DATA_ROW), 0).xyz;\n            \n            // \"time 0\" is stored in p.w (time at which position was p.xyz, and velocity was v.xyz)\n            // This value is being stored in a buffer that might use a 16-bit float format (e.g. on mobile), so it needs to be kept small.\n            // Probably the best solution would have been to encode the full 32-bit float value (or a fixed point value) across multiple texture values,\n            //      but I decided to try changing the code to work only with times in the interval (0,4) instead :)\n            \n            float use_time = mod(iTime, 4.);\n            \n            if (use_initial_data) {\n                p = vec4(SPHERE_INITIAL_POSITION.xyz, use_time);\n                v = SPHERE_INITIAL_VELOCITY;\n                p_old = p.xyz;\n            }\n            \n            if (use_time < p.w) {\n                p.w -= 4.;\n            }\n            \n            float t = use_time - p.w; // current time relative to \"time 0\"\n            \n            // Find any (or at most 4) collisions that occurred in time interval (0, t)\n            // If no collisions, jump ahead (updating p and v) to keep time values small\n            for (int itr = 0; itr < 4; itr++) {\n                // Get times of possible collisions relative to \"time 0\"\n                \n                // Walls are easy (the open side of the box is treated like a glass wall)\n                // Only checking for collision with side that the sphere is moving towards\n                //      so it shouldn't be possible to get trapped.\n                float t_inter_x = v.x < 0. ? (SPHERE_RADIUS-p.x) / v.x : (1. - SPHERE_RADIUS - p.x) / v.x;\n                float t_inter_z = v.z < 0. ? (SPHERE_RADIUS-p.z) / v.z : (1. - SPHERE_RADIUS - p.z) / v.z;\n                \n                float t_inter_floor, t_inter_ceil;\n                \n                vec3 p2 = p.xyz + t*v.xyz;\n                \n                p2.y += 0.5*GRAVITY*t*t;\n                    \n                vec3 v2 = v + t*GRAVITY;\n                \n                // First check if the sphere has already gotten too close to the ceiling or floor, in which case immediately bounce\n                if (p2.y > 1. - SPHERE_RADIUS - 1e-6) {\n                    t_inter_floor = 1e20;\n                    t_inter_ceil = t;\n                } else if (p2.y < SPHERE_RADIUS + 1e-6) {\n                    t_inter_floor = t;\n                    t_inter_ceil = 1e20;\n                } else {\n                    // Otherwise, get intersection with floor and/or ceiling by solving quadratic equations\n                    \n                    float disc1 = v.y*v.y - 2.*GRAVITY*(p.y - SPHERE_RADIUS);\n                    \n                    // Check for collision with floor regardless of current velocity because trajectory can curve down\n                    if (disc1 >= 0.) { // (There should always be two intersections unless the sphere fell through the floor somehow)\n                        disc1 = sqrt(disc1);\n                        \n                        // Always want the later intersection (GRAVITY is negative, so this is the one where we subtract disc1)\n                        t_inter_floor = (-v.y - disc1) / GRAVITY;\n                        \n                        // if t_inter_floor < 0, it means the sphere has fallen through the floor somehow\n                        // this situation will be caught by the a-posteriori collision check\n                    } else {\n                        t_inter_floor = 1e20;\n                    }\n                    \n                    float disc2 = v.y*v.y - 2.*GRAVITY*(p.y - 1. + SPHERE_RADIUS);\n                    \n                    // Check for collision with ceiling only if sphere is currently moving towards it\n                    if (v2.y > 0. && disc2 >= 0.) {\n                        disc2 = sqrt(disc2);\n                        \n                        // Always want the first intersection (GRAVITY is negative, so this is the one where we add disc2)\n                        t_inter_ceil = (-v.y + disc2) / GRAVITY;\n                        \n                        // (if t_inter_ceil <= 0, it means the sphere has already gone through the ceiling somehow)\n                    } else {\n                        t_inter_ceil = 1e20;\n                    }\n                }\n                \n                // Get time of first collision\n                float t_inter = min(min(t_inter_x, t_inter_z), min(t_inter_floor, t_inter_ceil));\n                \n                // If no collision before t, and t is large, advance \"time 0\" by some power of 2 value\n                if (t_inter > t) {\n                    if (t >= 4.) t_inter = 4.;\n                    else if (t >= 2.) t_inter = 2.;\n                    else if (t >= 1.) t_inter = 1.;\n                    else if (t >= 0.5) t_inter = 0.5;\n                    else if (t >= 0.25) t_inter = 0.25;\n                }\n                \n                if (t_inter > t) {\n                    break;\n                }\n                \n                p.xzw += vec3(t_inter*v.xz, t_inter);\n                p.y += t_inter*v.y + 0.5*GRAVITY*t_inter*t_inter;\n\n                v.y += GRAVITY*t_inter;\n\n                // Handle bounces by setting corresponding components of position and velocity, avoiding\n                //     precision loss (for v.y anyway) by using absolute value of initial velocity.\n            \n                if (t_inter==t_inter_floor || p.y < SPHERE_RADIUS + 1e-6) {\n                    v.y = abs(SPHERE_INITIAL_VELOCITY.y);\n                    p.y = SPHERE_RADIUS;\n                } else if (t_inter==t_inter_ceil || p.y > 1. - SPHERE_RADIUS - 1e-6) {\n                    v.y = -abs(v.y);\n                    p.y = 1. - SPHERE_RADIUS;\n                }\n\n                if ((t_inter==t_inter_x && v.x < 0.) || p.x < SPHERE_RADIUS + 1e-6) {\n                    v.x = abs(SPHERE_INITIAL_VELOCITY.x);\n                    p.x = SPHERE_RADIUS;\n                } else if ((t_inter==t_inter_x && v.x > 0.) || p.x > 1. - SPHERE_RADIUS - 1e-6) {\n                    v.x = -abs(SPHERE_INITIAL_VELOCITY.x);\n                    p.x = 1. - SPHERE_RADIUS;\n                }\n                \n                if ((t_inter==t_inter_z && v.z < 0.) || p.z < SPHERE_RADIUS + 1e-6) {\n                    v.z = abs(SPHERE_INITIAL_VELOCITY.z);\n                    p.z = SPHERE_RADIUS;\n                } else if ((t_inter==t_inter_z && v.z > 0.) || p.z > 1. - SPHERE_RADIUS - 1e-6) {\n                    v.z = -abs(SPHERE_INITIAL_VELOCITY.z);\n                    p.z = 1. - SPHERE_RADIUS;\n                }\n                \n                t = use_time - p.w;\n\n                // repeat to handle literal corner cases\n            }\n            \n            // Other shaders want the current sphere position\n            vec3 new_p = p.xyz + t*v;\n            \n            new_p.y += 0.5*GRAVITY*t*t;\n           \n            if (x==BUFFER_D_SPHERE_P0) fragColor = p;\n            else if (x==BUFFER_D_SPHERE_V0) fragColor = vec4(v, 0.);\n            else if (x==BUFFER_D_SPHERE_CURRENT_POSITION) fragColor = vec4(new_p, 0.);\n            else if (x==BUFFER_D_SPHERE_PREV_FRAME_POSITION) fragColor = vec4(p_old, 0.); // store old position because it's still needed by Image\n        }\n        \n        return;\n    }\n    \n    vec3 sphere_c = texelFetch(iChannel1, ivec2(BUFFER_D_SPHERE_CURRENT_POSITION, BUFFER_D_MISC_DATA_ROW), 0).rgb;\n    \n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(BUFFER_D_MAGIC_NUMBER, BUFFER_D_MISC_DATA_ROW), 0) != MAGIC_NUMBER) {\n        sphere_c = SPHERE_INITIAL_POSITION;\n    }\n    \n    bool is_sphere = x >= MESH_X_OFFSET_SPHERE;\n\n    int base = is_sphere ? MESH_X_OFFSET_SPHERE : (x & ~(MESH_SQUARE_COLUMNS-1));\n    int columns = is_sphere ? MESH_SPHERE_COLUMNS : MESH_SQUARE_COLUMNS;\n\n    x -= base;\n    base *= MESH_SQUARE_ROWS;\n    \n\n    int receiving_patch_index = base + y*columns + x;\n    \n    vec3 sum = vec3(0);\n    \n    if (base != MESH_OFFSET_SPHERE) {\n        vec3 N1 = get_normal_for_patch_not_sphere(receiving_patch_index);\n        \n        vec3 P1_a = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.25, 0.25);\n        vec3 P1_b = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.25, 0.75);\n        vec3 P1_c = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.75, 0.25);\n        vec3 P1_d = get_point_for_patch_not_sphere(receiving_patch_index, base, 0.75, 0.75);\n        \n        // indexes of patches for which form factor is precomputed\n        ivec2 edge_ff = get_edge_form_factor_indexes(base, x, y);\n        \n        // precomputing some things to speed up the shadow checks in the inner loop\n        vec3 sph_delta_a = P1_a-sphere_c;\n        vec3 sph_delta_b = P1_b-sphere_c;\n        vec3 sph_delta_c = P1_c-sphere_c;\n        vec3 sph_delta_d = P1_d-sphere_c;\n        \n        float sph_val_a = dot(sph_delta_a,sph_delta_a) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_b = dot(sph_delta_b,sph_delta_b) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_c = dot(sph_delta_c,sph_delta_c) - SPHERE_RADIUS*SPHERE_RADIUS;\n        float sph_val_d = dot(sph_delta_d,sph_delta_d) - SPHERE_RADIUS*SPHERE_RADIUS;\n        \n        int end_index = base == MESH_OFFSET_BACK ? MESH_OFFSET_BACK : MESH_OFFSET_SPHERE;\n        \n        for (int index_src = 0; index_src < min(0, iFrame) + end_index; index_src++) {\n            if (index_src == base) index_src += MESH_COUNT_SQUARE;\n            \n            float ffsum = 0.0;\n            vec3 N2 = get_normal_for_patch_not_sphere(index_src);\n            int base_src = get_mesh_base_index(index_src);\n            \n            for (float sample_i = 0.25; sample_i < 1.; sample_i += 0.5) {\n                for (float sample_j = 0.25; sample_j < 1.; sample_j += 0.5) {\n                    vec3 P2 = get_point_for_patch_not_sphere(index_src, base_src, sample_i, sample_j);\n                    \n                    ffsum += form_factor(sph_delta_a, sph_val_a, P1_a, P2, N1, N2, true);\n                    ffsum += form_factor(sph_delta_b, sph_val_b, P1_b, P2, N1, N2, true);\n                    ffsum += form_factor(sph_delta_c, sph_val_c, P1_c, P2, N1, N2, true);\n                    ffsum += form_factor(sph_delta_d, sph_val_d, P1_d, P2, N1, N2, true);\n                }\n            }\n            \n            // Form factor for pair of squares that are at right angles to one another, sharing an edge\n            // Value is expected to be multiplied by -PI * 16. (factor is divided out at the end of the loop)\n            // Value is also expected to be divided by receiving patch area (we multiply by area later to get flux)\n            //      hence the multiplication by SQUARE_PATCH_RECIPROCAL_AREA\n            if (index_src==edge_ff.x || index_src==edge_ff.y) {\n                ffsum = -PI * 16. * 0.20004377607540316 * SQUARE_PATCH_RECIPROCAL_AREA;\n            }\n\n            ivec2 row_and_col = get_row_and_column(false, index_src - base_src);\n\n            // Shifting right by MESH_SQUARE_SHIFT gives the y part of a patch index, which happens to be the texture x offset\n            //      here because number of rows and columns is the same in the square meshes\n            // (Code should be refactored to detect when index_src has moved to the next mesh, and call more expensive functions\n            //      to get both base_src and texture x offset, so they can be arbitrary.)\n            row_and_col.x += base_src >> MESH_SQUARE_SHIFT;\n\n            // get outbound flux for patch (radiosity times patch area)\n            vec3 rad = texelFetch(iChannel0, row_and_col, 0).rgb;\n\n            #if SPLIT_PASSES\n            // add the second part of the flux for that patch\n            rad += texelFetch(iChannel0, row_and_col + ivec2(0, MESH_SQUARE_ROWS), 0).rgb;\n            #endif\n            \n            sum += rad * ffsum;\n        }\n        \n        for (int index_src = MESH_OFFSET_SPHERE; index_src < min(0, iFrame) + MESH_COUNT; index_src++) {\n            float ffsum = 0.0;\n            \n            for (float sample_i = 0.25; sample_i < 1.; sample_i += 0.5) {\n                for (float sample_j = 0.25; sample_j < 1.; sample_j += 0.5) {\n                    vec3 N2;\n                    vec3 P2 = get_point_for_patch_on_sphere(sphere_c, index_src, sample_i, sample_j, N2);\n                    \n                    ffsum += form_factor_no_sphere_check(P1_a, P2, N1, N2);\n                    ffsum += form_factor_no_sphere_check(P1_b, P2, N1, N2);\n                    ffsum += form_factor_no_sphere_check(P1_c, P2, N1, N2);\n                    ffsum += form_factor_no_sphere_check(P1_d, P2, N1, N2);\n                }\n            }\n\n            ivec2 row_and_col = get_row_and_column(true, index_src - MESH_OFFSET_SPHERE);\n\n            row_and_col.x += MESH_X_OFFSET_SPHERE;\n\n            // get outbound flux for patch (radiosity times patch area)\n            vec3 rad = texelFetch(iChannel0, row_and_col, 0).rgb;\n\n            #if SPLIT_PASSES\n            // add the second part of the flux for that patch\n            rad += texelFetch(iChannel0, row_and_col + ivec2(0, MESH_SQUARE_ROWS), 0).rgb;\n            #endif\n            \n            sum += rad * ffsum;\n        }\n    } else {\n        vec3 N1_a;\n        vec3 P1_a = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.25, 0.25, N1_a);\n        \n        vec3 N1_b;\n        vec3 P1_b = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.25, 0.75, N1_b);\n\n        vec3 N1_c;\n        vec3 P1_c = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.75, 0.25, N1_c);\n\n        vec3 N1_d;\n        vec3 P1_d = get_point_for_patch_on_sphere(sphere_c, receiving_patch_index, 0.75, 0.75, N1_d);\n        \n        for (int index_src = 0; index_src < min(0, iFrame) + MESH_OFFSET_SPHERE; index_src++) {\n            vec3 N2 = get_normal_for_patch_not_sphere(index_src);\n            int base_src = get_mesh_base_index(index_src);\n            \n            float ffsum = 0.0;\n            \n            for (float sample_i = 0.25; sample_i < 1.; sample_i += 0.5) {\n                for (float sample_j = 0.25; sample_j < 1.; sample_j += 0.5) {\n                    vec3 P2 = get_point_for_patch_not_sphere(index_src, base_src, sample_i, sample_j);\n                    \n                    ffsum += form_factor_no_sphere_check(P1_a, P2, N1_a, N2);\n                    ffsum += form_factor_no_sphere_check(P1_b, P2, N1_b, N2);\n                    ffsum += form_factor_no_sphere_check(P1_c, P2, N1_c, N2);\n                    ffsum += form_factor_no_sphere_check(P1_d, P2, N1_d, N2);\n                }\n            }\n\n            ivec2 row_and_col = get_row_and_column(false, index_src - base_src);\n\n            // Shifting right by MESH_SQUARE_SHIFT gives the y part of a patch index, which happens to be the texture x offset\n            //      here because number of rows and columns is the same in the square meshes\n            // (Code should be refactored to detect when index_src has moved to the next mesh, and call more expensive functions\n            //      to get both base_src and texture x offset, so they can be arbitrary.)\n            row_and_col.x += base_src >> MESH_SQUARE_SHIFT;\n\n            // get outbound flux for patch (radiosity times patch area)\n            vec3 rad = texelFetch(iChannel0, row_and_col, 0).rgb;\n\n            #if SPLIT_PASSES\n            // add the second part of the flux for that patch\n            rad += texelFetch(iChannel0, row_and_col + ivec2(0, MESH_SQUARE_ROWS), 0).rgb;\n            #endif\n            \n            sum += rad * ffsum;\n        }\n    }\n    \n    // Get irradiance from the integration performed by the above loops\n    // 1./16. is the divisor for the integration sampling (which wasn't multiplied in the loop)\n    // -1./PI is another factor that was omitted for performance reasons\n    // PATCH_FLUX_DECODE_SCALE is a decoding factor that should have been applied to values fetched from the buffer\n    vec3 final_color = -1./PI * 1./16. * PATCH_FLUX_DECODE_SCALE * sum;\n    \n    // Multiply irradiance by albedo to get reflected part of radiosity\n    final_color *= get_albedo(base);\n    \n    // NOTE: the output of this shader does not include the emitted part of radiosity because that would mess up the smoothing interpolation used in the final render\n    \n    \n    #if USE_SERIES_ACCELERATION && SHOW_DIRECT_LIGHT && SHOW_FIRST_BOUNCE && SHOW_SECOND_BOUNCE && SHOW_THIRD_BOUNCE\n\n    // Get radiant exitance (emitted component of radiosity) if any\n    // This is not included in the output value, but needs to be subtracted from the previous passes' values for series acceleration\n    // (or could include it in this pass's value temporarily, but then would need to subtract it again)\n    vec3 emitted_radiosity = vec3(0.);\n    \n    {\n        int light_side;\n        ivec2 light_i_minmax, light_j_minmax;\n        \n        if (iFrame == 0 || texelFetch(iChannel1, ivec2(BUFFER_D_MAGIC_NUMBER, BUFFER_D_MISC_DATA_ROW), 0) != MAGIC_NUMBER) { \n            light_side = LIGHT_SIDE_INITIAL;\n            light_i_minmax = LIGHT_I_MINMAX_INITIAL;\n            light_j_minmax = LIGHT_J_MINMAX_INITIAL;\n        } else {\n            ivec2 val = floatBitsToInt(texelFetch(iChannel1, ivec2(BUFFER_D_LIGHT_DATA, BUFFER_D_MISC_DATA_ROW), 0).xy);\n            \n            light_side = unpack_light_side(val.x);\n            light_i_minmax = unpack_light_i_minmax(val.x);\n            light_j_minmax = unpack_light_j_minmax(val.y);\n        }\n        \n        if (base == light_side*MESH_COUNT_SQUARE && x >= light_j_minmax.x && x <= light_j_minmax.y && y >= light_i_minmax.x && y <= light_i_minmax.y) {\n            emitted_radiosity = get_light_scale(light_i_minmax, light_j_minmax) * LIGHT_AMOUNT;\n        }\n    }\n    \n    {\n        // Scale the values from previous passes and subtract emitted component of radiosity so they match the value we are using for this pass (pass4)\n        \n        float scale = PATCH_FLUX_DECODE_SCALE / area_for_patch(receiving_patch_index);\n        \n        vec3 pass1 = scale*texelFetch(iChannel2, ivec2(fragCoord), 0).rgb - emitted_radiosity;\n        \n        vec3 pass3 = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n        #if SPLIT_PASSES\n        // add second part of flux value for pass3\n        pass3 += texelFetch(iChannel0, ivec2(int(fragCoord.x), int(fragCoord.y) + MESH_SQUARE_ROWS), 0).rgb;\n        #endif\n\n        pass3 = scale*pass3 - emitted_radiosity;\n\n        vec3 pass4 = final_color;\n        \n        /*\n          I was trying to find an optimal factor for Successive Over-Relaxation, and I tried plugging multiple previous iteration\n              values into least squares optimization (linear regression), arriving at these factors for 4 Jacobi iterations.\n           Different factors may be needed for different scenes (or different parts of the scene) so I don't know how useful it is in production.\n           Least squares factor for pass2 was very small, so I left that term out (I wonder if there is an interesting explanation for this)\n           I chose to use factors that sum to 1 although this is not strictly necessary (otherwise the scene would be brightened or darkened\n              by a constant factor).\n        \n           \"Overrelaxation\" for Jacobi iterations similarly computes some linear combination of the output of plain Jacobi iterations\n                (but likely not the optimal one).\n\n           I haven't yet found a mention of this approach in the literature (but tricks like computing \"unshot radiosity\" and adding\n                it as an ambient term are used).\n           Radiosity usually uses (more efficient) Gauss-Seidel or Southwell iterations, where the trick probably wouldn't apply.\n           I'm only using Jacobi iterations because of Shadertoy limitations.\n\n           It might seem like cheating, or deviating from physically-based methods, but the justification is that the result is a better\n                approximation (in the least squares sense) of true radiosity than simply stopping after 4 iterations, and it's similar to\n                (but better than) overrelaxation, which is a standard technique (with caveat that this might be only true for certain scenes,\n                and different factors might be needed for different scenes). Likely it should be combined with heuristics.\n        \n           Optimal factors in my test scene (for reference, probably not useful):\n                1 iteration (i.e. just uniformly brightening the direct illumination): 1.55648131\n                2 iterations: -1.04410677   2.33088677\n                3 iterations: -0.3501546   -2.81371846   3.91354126\n                4 iterations:  0.50251172  -0.00687071  -4.60680061   5.14673214\n                5 iterations: -0.15431121   1.22304458   0.82183848  -8.54643738   7.68658215\n                6 iterations: -0.12238599  -0.23040211   2.29687337   0.39079672 -10.73858488   9.39628568\n                7 iterations:  0.0501386   -0.42917315  -0.57671934   4.85683415  -0.84644954 -13.93106196  11.86946711\n                8 iterations:  0.03361997   0.09671265  -0.98298705  -0.64599411   7.91240836  -3.29352597 -16.13602052  14.01715472\n           But it's probably more stable/robust to use only the last few passes.\n           \n           Using just the last two passes (with factors summing to 1) is equivalent to adding a multiple of the final delta (see below).\n           \n        */\n        \n        final_color = 0.5*pass1 + - 4.65*pass3 + 5.15*pass4;\n        \n        // Safety bounds\n        // Seems like a good idea since lighting is often going to be very different than the scene I optimized for.\n        // I looked at a scatter plot of the error divided by delta, and 1-4 appeared to be a reasonable range\n        vec3 delta = pass4 - pass3;\n        \n        final_color = clamp(final_color, pass4 + USE_SERIES_ACCELERATION_SAFETY_BOUNDS_MIN*delta,\n                                         pass4 + USE_SERIES_ACCELERATION_SAFETY_BOUNDS_MAX*delta);\n    }\n    #endif\n\n    fragColor = vec4(final_color, 1.0);\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}