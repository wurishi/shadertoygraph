{"ver":"0.1","info":{"id":"Xs2BRK","date":"1501446582","viewed":151,"name":"[SH17C] How...? - Value Noise","username":"theGiallo","description":"Value noise. Simplest version, 1D with linear interpolation, just to grasp the concept. You really should use at lease a smoothstep, or better a smootherstep, especially if you go 2D(surface in 3D space) with lighting. Continuity helps.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["noise","valuenoise","sh17c"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n// shared code                                                       shared code\n\nconst vec2 DATE = vec2(0.0,0.0);\n\nvec4\nload_value( in vec2 uv_code )\n{\n    return texture( iChannel0, (uv_code+0.5)/iChannelResolution[0].xy, -100.0 );\n}\n\nvec2\nrotate( in vec2 v, in float rad )\n{\n    return\n    mat2(\n\t   vec2(  cos(rad), sin(rad) ),\n\t   vec2( -sin(rad), cos(rad) ) ) * v;\n}\n\n// shared code                                                       shared code\n////////////////////////////////////////////////////////////////////////////////\n// constants                                                           constants\n\n#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n// constants                                                           constants\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nlineSD( vec2 pos, vec2 point1, vec2 point2, float width )\n{\n    if ( point1 == point2 )\n    {\n        return 1e37;\n    }\n    vec2 dir0 = point2 - point1;\n    vec2 dir1 = pos - point1;\n    float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n    float d = (length(dir1 - dir0 * h) - width * 0.5);\n    return d;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblendPMA( inout vec4 fragColor, vec4 layer )\n{\n    fragColor = fragColor * ( 1. - layer.a ) + layer;\n}\n\nstruct\nLine_Cfg\n{\n    float width;\n    float blend_width;\n    vec4  color;\n};\n\nvec4\nlinePMA( vec2 pos, vec2 start, vec2 end, Line_Cfg config )\n{\n    vec4 ret;\n    ret.a = lineSD( pos, start, end, config.width );\n    ret.a = 1. - smoothstep( 0., config.blend_width, ret.a );\n    \n    ret = config.color * ret.a;\n    return ret;\n}\n\n#define blend_line(start,end,cfg) blendPMA( fragColor, linePMA( p, start, end, cfg ) )\n\n\n////////////////////////////////////////////////////////////////////////////////\n// random generator                                             random generator\n\n#if 1\nuint lcg( inout uint seed )\n{\n    seed = seed * 1103515245u + 12345u;\n\treturn uint(seed/65536u) % 32768u;\n}\nfloat lcg01( inout uint seed )\n{\n    uint u = lcg( seed );\n    return float(u) / 32768.;\n\n}\n#else\nuint lcg( inout uint seed )\n{\n    seed = ( seed * 1103515245u + 12345u ) % 2147483648u;\n\treturn seed;//uint(seed/65536u) % 32768u;\n}\nfloat lcg01( inout uint seed )\n{\n    uint u = lcg( seed );\n    return float(u) / 2147483648.;//32768.;\n\n}\n#endif\n\n\n#define uint_to_01(u) (float((u)>>1) / float(0x7FFFFFFF));\n/* The state word must be initialized to non-zero */\nuint xorshift32( inout uint state )\n{\n\tuint x = state;\n\tx ^= x << 13;\n\tx ^= x >> 17;\n\tx ^= x << 5;\n\tstate = x;\n\treturn x;\n}\nfloat xorshift3201( inout uint state )\n{\n    uint u = xorshift32( state );\n    return uint_to_01( u );\n}\n\n// random generator                                             random generator\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    float px_s = 1. / min( iResolution.y, iResolution.x );\n\n    fragColor = vec4(254,250,245,255)/255.;\n    \n    Line_Cfg line_cfg;\n    line_cfg.width = .002;\n    line_cfg.blend_width = 2. * SQRT2 * px_s;\n    line_cfg.color = vec4(.5,.5,.5,1);\n    Line_Cfg h_line_cfg = line_cfg;\n    h_line_cfg.color.rgb = vec3(0,.5,1);\n    Line_Cfg li_line_cfg = line_cfg;\n    li_line_cfg.color.rgb = vec3(1,.5,0);\n    \n    // NOTE(theGiallo): colorblind proof palette from http://mkweb.bcgsc.ca/colorblind/\n    vec3 palette[4] = vec3[4](\n        vec3(.8,.474509804,.654901961), // reddish purple\n        vec3(.0,.619607843,.450980392), // bluish green\n        vec3(.835294118,.368627451,0),  // vermillon\n        vec3(.901960784,.623529412,0)   // orange\n    );\n    /*\n    vec4 l0 = linePMA( p, vec2(-.99), vec2(.99), line_cfg );\n    \n    blendPMA( fragColor, l0 );\n    \n    blend_line( vec2(-1,0), vec2(-1,0) + vec2(sin(iTime),cos(iTime))*.5, line_cfg );\n\t*/\n    \n    vec4 date = load_value( DATE );\n    uint base_seed = uint(\n      //    (date.x-2000.) * 60.*60.*24. * 31. * 13.\n        + date.y * 60.*60.*24. * 32.\n        + date.z * 60.*60.*24.\n        + date.w\n    );\n    uint seed = base_seed;\n    //float h  = 0.2;\n    #define H_COUNT 8\n    #define LOG2_H_COUNT 3\n    //float h_arr[H_COUNT+1];\n    float h_arr[2*H_COUNT+LOG2_H_COUNT];\n    int h_count = H_COUNT;\n    int id = 0;\n    #if 1\n    #define rng xorshift3201\n    #else\n    #define rng lcg01\n    #endif\n    float dt_pause = 0.25;\n    float dt_x  = 4.0;\n    float dt_h1 = 1.5;\n    float oct_dt = 2.0;\n    float time_oct = oct_dt;\n    float h1 = .8, H1 = h1;\n    for ( int h_count = 1; h_count <= H_COUNT; h_count *= 2 )\n    {\n        time_oct += dt_x;\n        for ( int i = 0; i != h_count + 1; ++i, ++id )\n        {\n            h_arr[id] = rng( seed );\n            time_oct += h_arr[id] * dt_h1 * h1 + dt_pause;\n        }\n        h1 *= .5;\n    }\n    float x_span = 2.;\n    float dy_after_oct = .5;\n    float a_oct = smoothstep( time_oct - oct_dt, time_oct, iTime );\n    H1 = h1 = mix( 0.8, 0.4, a_oct );\n    float dy = mix( 0.1, 0.05, a_oct );\n    vec2 start = vec2( -1.,-.9 + mix( 0.0, 0.5 + H1 + dy, a_oct ) ),\n         base_start = start,\n         BASE_START = base_start;\n    float t0 = 0.;\n    id = 0;\n    for ( int h_count = 1; h_count <= H_COUNT; h_count *= 2 )\n    {\n        blend_line( start, start + vec2(x_span,0), line_cfg );\n        blend_line( start + vec2(0,h1), start + vec2(x_span,h1), line_cfg );\n        for ( int i = 0; i != h_count + 1; ++i, ++id )\n        {\n            float dt = dt_h1 * h_arr[id] * h1;\n            blend_line( start,\n                        start + vec2(0, smoothstep( t0, t0 + dt, iTime ) * h_arr[id] * h1 ),\n                        h_line_cfg );\n            t0 += dt + dt_pause;\n            start.x += x_span / float(h_count);\n        }\n        base_start.y += dy + h1;\n        start = base_start;\n        h1 *= .5;\n    }\n    \n    id = 0;\n    h1 = H1;\n    start = base_start = BASE_START;\n    seed = base_seed;\n    int oct;\n    for ( int h_count = 1, oct = 0; h_count <= H_COUNT; h_count *= 2, ++oct )\n    {\n        li_line_cfg.color.rgb = palette[oct];\n        //blend_line( start, start + vec2(x_span,0), line_cfg );\n        //blend_line( start + vec2(0,h1), start + vec2(x_span,h1), line_cfg );\n        \n        //h_arr[0] = rng( seed );\n        ++id;\n        float dt = dt_x/float(h_count);\n        float t0_ = t0;\n        for ( int i = 1; i != h_count + 1; ++i, ++id )\n        {\n            //h_arr[i] = rng( seed );\n            vec2 s = start + vec2(0, h_arr[id-1] * h1 );\n            vec2 e = start + vec2( x_span / float(h_count), h_arr[id] * h1 );\n            blend_line( s,\n                        mix(s,e,smoothstep(t0,t0+dt,iTime)),\n                        li_line_cfg );\n            t0 += dt;\n            start.x += x_span / float(h_count);\n        }\n        t0 = t0_ + dt_x;\n        base_start.y += dy + h1;\n        start = base_start;\n        h1 *= .5;\n    }\n    \n    // NOTE(theGiallo): translation downward\n    float vnh[H_COUNT+1];\n    for ( int i = 0; i != H_COUNT + 1; ++i )\n    {\n        vnh[i] = 0.;\n    }\n    id = 0;\n    t0 += oct_dt;\n    t0 = time_oct;\n    if ( iTime >= t0 )\n    {\n        base_start = start = BASE_START;\n        h1 = H1;\n        float try = -H1-dy-dy_after_oct;\n        vec2 base = vec2(0,try);\n        blend_line( base + start, base + start + vec2(x_span,0), line_cfg );\n        for ( int h_count = 1, oct = 0; h_count <= H_COUNT; h_count *= 2, ++oct )\n        {\n            li_line_cfg.color.rgb = palette[oct];\n            float dt = 4.;\n            //float this_t0 = ( dt + dt_pause ) * float(h_count - 1);\n            \n            int di = H_COUNT / h_count;\n            for ( int i = 0; i != h_count + 1; ++i, ++id )\n            {\n            \tvec2 tr = vec2( 0, mix( 0., try + vnh[i * di], smoothstep( t0, t0 + dt, iTime ) ) );\n                blend_line( tr + start,\n                            tr + start + vec2(0, h_arr[id] * h1 ), h_line_cfg );\n                if ( i != 0 )\n                {\n                    vec2 e = tr + start + vec2( 0, h_arr[id] * h1 );\n            \t\ttr = vec2( 0, mix( 0., try + vnh[i * di -di], smoothstep( t0, t0 + dt, iTime ) ) );\n                    vec2 s = tr + start + vec2( -x_span / float(h_count), h_arr[id-1] * h1 );\n                    blend_line( s, e, li_line_cfg );\n                    /**/\n                    for ( int Js = ( i - 1 ) * di, j = Js, Je = i * di;\n                          j != Je;\n                          ++j )\n                    {\n                        vnh[j] += mix( h_arr[id-1], h_arr[id],\n                                       clamp( float( j - Js ) / float(di), 0., 1. ) ) * h1;\n                    }\n\t\t\t\t\t/**/\n                }\n                start.x += x_span / float(h_count);\n            }\n            vnh[h_count*di] += h_arr[id-1] * h1;\n            t0 += dt + dt_pause;\n            base_start.y += dy + h1;\n            start = base_start;\n            try += -h1-dy;\n            h1 *= .5;\n        }\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n// shared code                                                       shared code\n\nconst vec2 DATE = vec2(0.0,0.0);\n\nvec4\nload_value( in vec2 uv_code )\n{\n    return texture( iChannel0, (uv_code+0.5)/iChannelResolution[0].xy, -100.0 );\n}\n\nvec2\nrotate( in vec2 v, in float rad )\n{\n    return\n    mat2(\n\t   vec2(  cos(rad), sin(rad) ),\n\t   vec2( -sin(rad), cos(rad) ) ) * v;\n}\n\n// shared code                                                       shared code\n////////////////////////////////////////////////////////////////////////////////\n// input                                                                   input\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_0     = 48;\nconst int KEY_R     = 82;\nconst int KEY_M     = 77;\n\nfloat\nkey( in int K )\n{\n    return texelFetch( iChannel1, ivec2(K,0), 0 ).x;\n}\nfloat\nkey_pressed( in int K )\n{\n    return texelFetch( iChannel1, ivec2(K,2), 0 ).x;\n}\nfloat\nkey_toggle( in int K )\n{\n    return texelFetch( iChannel1, ivec2(K,1), 0 ).x;\n}\n\n// input                                                                   input\n////////////////////////////////////////////////////////////////////////////////\n// memory                                                                 memory\n\nfloat\nisInside( vec2 p, vec2 c )\n{\n    vec2 d = abs( p - 0.5 - c ) - 0.5;\n    return - max( d.x, d.y );\n}\nbool\nis_value( in vec2 frag_coord, in vec2 tx_code )\n{\n    return isInside( frag_coord, tx_code ) > 0.0;\n//    return (uv_code+0.5)/iChannelResolution[0].xy == uv;\n}\n\n// memory                                                                 memory\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( iFrame > 1 )\n    {\n    //    discard;\n    }\n    if ( iFrame == 0 )\n    {\n        fragColor -= fragColor;\n        if ( is_value( fragCoord, DATE ) )\n        {\n            fragColor = iDate;\n        }\n    } else\n    {\n        fragColor = texture( iChannel0, fragCoord/iResolution.xy );\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}