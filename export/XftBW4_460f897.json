{"ver":"0.1","info":{"id":"XftBW4","date":"1733257110","viewed":98,"name":"Floodfill Light 2D","username":"lowellcamp","description":"Press 'w' to toggle between drawing walls and light sources.\nPress 'p' to hide all the grid lines and wall overlays.\n\nA 2D proof of concept for flood fill light propagation and sampling. Extending this to 3D will be difficult, but hopefully doable.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["floodfill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelPos = fragCoord / float(SCALE);\n    ivec2 pixel = ivec2(pixelPos);\n    vec2 offset = fract(pixelPos) - 0.5;\n    \n    Cell o_cell = getCell(iChannel0, pixel);\n    Cell x_cell = getCell(iChannel0, pixel + ivec2(sign(offset.x), 0));\n    Cell y_cell = getCell(iChannel0, pixel + ivec2(0, sign(offset.y)));\n    Cell d_cell = getCell(iChannel0, pixel + ivec2(sign(offset)));\n    \n    bool wall_x  = offset.x > 0.0 ? o_cell.walls.r : o_cell.walls.l;\n    bool wall_yx = offset.x > 0.0 ? y_cell.walls.r : y_cell.walls.l;\n    \n    bool wall_y = offset.y > 0.0 ? o_cell.walls.u : o_cell.walls.d;\n    bool wall_xy = offset.y > 0.0 ? x_cell.walls.u : x_cell.walls.d;\n    \n    // We've no longer care about offset's sign\n    offset = abs(offset);\n    \n    float total_weight = (1.0 - offset.x) * (1.0 - offset.y);\n    vec3 lab = o_cell.lab * total_weight;\n    \n    vec3 d_lab = d_cell.lab;\n    float d_weight_mul = 1.0;\n    vec3 o_lab = o_cell.lab;\n    \n    if (!wall_x) {\n        float weight = offset.x * (1.0 - offset.y);\n        lab += x_cell.lab * weight;\n        total_weight += weight;\n    } else if (!wall_xy) { // Open to the diagonal\n        d_weight_mul += 1.0;\n        d_lab += x_cell.lab;\n    }\n    \n    if (!wall_y) {\n        float weight = (1.0 - offset.x) * offset.y;\n        lab += y_cell.lab * weight;\n        total_weight += weight;\n    } else if (!wall_yx) { // Open to the diagonal\n        d_weight_mul += 1.0;\n        d_lab += y_cell.lab;\n    }\n    \n    if (!((wall_x || wall_xy) && (wall_y || wall_yx))) {\n        float weight = offset.x * offset.y;\n        lab += d_lab * weight;\n        total_weight += weight * d_weight_mul;\n    }\n    /*\n    // Alternate styling, with more \"ao\"\n    else if (!wall_x && !wall_y) {\n        float weight = offset.x * offset.y;\n        vec3 x_atten = attenuate(x_cell.lab);\n        vec3 y_atten = attenuate(y_cell.lab);\n        d_lab = mix(x_atten, y_atten, y_atten.x / (x_atten.x + y_atten.x));\n        d_lab *= max(x_atten.x, y_atten.x) / d_lab.x;\n        lab += d_lab * weight;\n        total_weight += weight;\n    } else if (!wall_x) {\n        float weight = offset.x * offset.y;\n        lab += attenuate(x_cell.lab) * weight;\n        total_weight += weight;\n    } else if (!wall_y) {\n        float weight = offset.x * offset.y;\n        lab += attenuate(y_cell.lab) * weight;\n        total_weight += weight;\n    } else {\n        float weight = offset.x * offset.y;\n        lab += attenuate(attenuate(o_lab)) * weight;\n        total_weight += weight;\n    }\n    \n    lab += attenuate(o_lab) * max(0.0, 1.0 - total_weight);\n    total_weight = max(1.0, total_weight);\n    */\n    \n    lab /= total_weight;\n    lab.yz = clamp(lab.yz, -0.5 * lab.x, 0.5 * lab.x);\n    fragColor = vec4(linear_srgb_from_oklab(lab), 1.0);\n    \n    // Grid overlays\n    \n    if (!bool(texelFetch(iChannel1, ivec2(80, 2), 0).x)) {\n        ivec2 internal = ivec2(\n            int(fragCoord.x) % SCALE,\n            int(fragCoord.y) % SCALE\n        );\n        if (\n            internal.x == 0 ||\n            internal.y == 0\n        ) {\n            if (bool(texelFetch(iChannel1, ivec2(87, 2), 0).x)) {\n                fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.0, 0.0), 0.25);\n            } else {\n                fragColor.rgb = mix(fragColor.rgb, vec3(1.0), 0.2);\n            }\n        }\n\n        if (o_cell.walls.d && internal.y == 0) {\n            fragColor.rgb = vec3(1.0, 0.0, 0.0);\n        }\n        if (o_cell.walls.l && internal.x == 0) {\n            fragColor.rgb = vec3(1.0, 0.0, 0.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Flood fill emitter buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        fragColor = writeCell(Cell(\n            Walls(false, false, false, false),\n            vec3(0.0)\n        ));\n        return;\n    }\n    if (\n        (int(fragCoord.x) > BASE_RESOLUTION.x && int(fragCoord.y) > BASE_RESOLUTION.y)\n    ) {\n        discard;\n        return;\n    }\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.w > 0.0) {\n        Cell current = getCell(fragColor.rgb);\n        \n        vec2 mTex = iMouse.xy / float(SCALE);\n        \n        ivec2 pixel = ivec2(fragCoord);\n        if (bool(texelFetch(iChannel1, ivec2(87, 2), 0).x)) {\n            \n            Walls mWall = getCell(iChannel0, ivec2(mTex)).walls;\n            \n            vec2 offset = fract(mTex) - 0.5;\n            Walls mask = Walls(\n                offset.x < -abs(offset.y),\n                offset.x >  abs(offset.y),\n                offset.y < -abs(offset.x),\n                offset.y >  abs(offset.x)\n            );\n            // Toggle all 4 walls if clicking the center\n            if (max(abs(offset.x), abs(offset.y)) < 0.25) {\n                mask = Walls(true, true, true, true);\n            }\n            \n            \n            bool desired = (\n                (mask.d && !mWall.d) || \n                (mask.u && !mWall.u) || \n                (mask.l && !mWall.l) || \n                (mask.r && !mWall.r)\n            );\n            \n            if (pixel == ivec2(mTex)) {\n                current.walls.d = mask.d ? desired : current.walls.d;\n                current.walls.u = mask.u ? desired : current.walls.u;\n                current.walls.l = mask.l ? desired : current.walls.l;\n                current.walls.r = mask.r ? desired : current.walls.r;\n            }\n            \n            if (pixel == ivec2(mTex) - ivec2(0, 1)) {\n                // Below\n                current.walls.u = mask.d ? desired : current.walls.u;\n            } else if (pixel == ivec2(mTex) + ivec2(0, 1)) {\n                // Above\n                current.walls.d = mask.u ? desired : current.walls.d;\n            } else if (pixel == ivec2(mTex) - ivec2(1, 0)) {\n                // Left\n                current.walls.r = mask.l ? desired : current.walls.r;\n            } else if (pixel == ivec2(mTex) + ivec2(1, 0)) {\n                // Right\n                current.walls.l = mask.r ? desired : current.walls.l;\n            }\n            \n            fragColor = writeCell(current);\n        } else {\n            if (ivec2(fragCoord) == ivec2(mTex)) {\n                bool activate = current.lab.x == 0.0;\n                if (activate) {\n                    vec3 seed = texelFetch(iChannel2, ivec2(iFrame % 256, (iFrame / 256) % 256), 0).rgb;\n                    seed = oklab_from_linear_srgb(seed);\n                    seed *= mix(seed.x, 1.0, 0.5) / seed.x;\n                    current.lab = seed;\n                } else {\n                    current.lab = vec3(0.0);\n                }\n                fragColor = writeCell(current);\n            }\n        }\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const ivec2 BASE_RESOLUTION = ivec2(40, 24);\n\n#define SCALE int(ceil(max(iResolution.x / float(BASE_RESOLUTION.x), iResolution.y / float(BASE_RESOLUTION.y))))\n\n#define SLOWING 1\n\n\nstruct Walls {\n    bool l;\n    bool r;\n    bool d;\n    bool u;\n};\n\nstruct Cell {\n    Walls walls;\n    vec3 lab;\n};\n\nCell getCell(vec3 value) {\n    ivec3 val = ivec3(round(value * 255.0));\n    return Cell(\n        Walls(bool(val.x & 1), bool(val.x & 2), bool(val.x & 4), bool(val.x & 8)),\n        vec3(\n            float(val.x / 16) / 15.0,\n            value.y - 0.5,\n            value.z - 0.5\n        )\n    );\n}\n\nCell getCell(sampler2D iChannel, ivec2 pixel) {\n    pixel = (pixel % BASE_RESOLUTION + BASE_RESOLUTION) % BASE_RESOLUTION;\n    return getCell(texelFetch(iChannel, pixel, 0).xyz);\n\n}\n\nvec4 writeCell(Cell cell) {\n    cell.lab.x = clamp(cell.lab.x, 0.0, 1.0);\n    cell.lab.y = clamp(cell.lab.y + 0.5, 0.0, 1.0);\n    cell.lab.z = clamp(cell.lab.z + 0.5, 0.0, 1.0);\n    int val_x;\n    \n    val_x += cell.walls.l ? 1 : 0;\n    val_x += cell.walls.r ? 2 : 0;\n    val_x += cell.walls.d ? 4 : 0;\n    val_x += cell.walls.u ? 8 : 0;\n    val_x += 16 * int(round(cell.lab.x * 15.0));\n    return vec4(\n        float(val_x) / 255.0,\n        cell.lab.y,\n        cell.lab.z,\n        1.0\n    );\n}\n\nvec3 attenuate(vec3 lab) {\n    if (lab.x == 0.0) {\n        return vec3(0.0);\n    }\n    float desired = max(0.0, lab.x - 1.0 / 15.0);\n    float mul = desired / lab.x;\n    return lab * mul;\n}\n\nvec3 attenuate(vec3 lab, float dist) {\n    if (lab.x == 0.0) {\n        return vec3(0.0);\n    }\n    float desired = max(0.0, lab.x - dist / 15.0);\n    float mul = desired / lab.x;\n    return lab * mul;\n}\n\n//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Flood fill propagation buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixel = ivec2(fragCoord);\n    \n    if (iFrame % SLOWING != 0 || pixel.x > BASE_RESOLUTION.x || pixel.y > BASE_RESOLUTION.y) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    Cell emission = getCell(iChannel0, pixel);\n    \n    Cell down = getCell(iChannel1, pixel - ivec2(0, 1));\n    Cell up = getCell(iChannel1, pixel + ivec2(0, 1));\n    Cell left = getCell(iChannel1, pixel - ivec2(1, 0));\n    Cell right = getCell(iChannel1, pixel + ivec2(1, 0));\n    \n    down.lab = attenuate(down.lab);\n    up.lab = attenuate(up.lab);\n    left.lab = attenuate(left.lab);\n    right.lab = attenuate(right.lab);\n    \n    vec3 lab = vec3(0.0);\n    // Take the max emissive source, similar to Minecraft's vanilla lighting\n    \n    \n    float lab_x = max(\n        emission.lab.x,\n        max(\n            max(\n                !emission.walls.d ? down.lab.x : 0.0,\n                !emission.walls.u ? up.lab.x : 0.0\n            ), max(\n                !emission.walls.l ? left.lab.x : 0.0,\n                !emission.walls.r ? right.lab.x : 0.0\n            )\n        )\n    );\n    \n    if (lab_x > 0.0) {\n        // Lend additional weight to emissive sources\n        // This greatly speeds up the convergence of hue info\n        float spread = (lab_x - emission.lab.x);\n        if (emission.lab.x > 0.0) {\n            lab += emission.lab;\n        }\n        if (!emission.walls.d) {\n            lab += down.lab * spread;\n        }\n        if (!emission.walls.u) {\n            lab += up.lab * spread;\n        }\n        if (!emission.walls.l) {\n            lab += left.lab * spread;\n        }\n        if (!emission.walls.r) {\n            lab += right.lab * spread;\n        }\n        if (lab.x == 0.0) {\n            lab.yz = vec2(0.0);\n        } else {\n            lab *= lab_x / lab.x;\n        }\n    } else {\n        lab = vec3(0.0);\n    }\n    \n    Cell current = Cell(\n        emission.walls,\n        lab\n    );\n    \n    fragColor = writeCell(current);\n}","name":"Buffer B","description":"","type":"buffer"}]}