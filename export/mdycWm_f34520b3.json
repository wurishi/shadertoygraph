{"ver":"0.1","info":{"id":"mdycWm","date":"1696193921","viewed":33,"name":"Abobus 2","username":"loochek","description":"abebus 2 with some drugs","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lol"],"hasliked":0,"parentid":"cd3czl","parentname":"Abobus"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  light    = vec3  ( 0.0, 5.0, 0.0 );\nconst int   maxSteps = 100;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat dSphere( vec3 p, float r )\n{\n    return length( p ) - r;\n}\n\nfloat dRoundedBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.06;\n}\n\nfloat opUnion ( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat speeds[] = float[9]\n(\n    10.0, 8.0, 15.0,\n    13.0, 12.0, 11.0,\n    15.0, 9.0, 7.0\n);\n\nfloat verticalStrides[] = float[9]\n(\n    4.0, 1.0, 3.0,\n    3.0, 3.0,  1.0,\n    2.0, 4.0, 5.0\n);\n\nfloat dVerticalCapsulesStream ( vec3 p, float radius)\n{\n    const float stride = 2.0;\n\n    float result = 1000000.0;\n    for (int i = -1; i <= 1; i++)\n    {\n        for (int j = -1; j <= 1; j++)\n        {\n            float iF = float(i);\n            float jF = float(j);\n            vec3 p1 = p +vec3(iF * stride, -iTime / 10.0 * speeds[i * 3 + j], jF * stride);\n            float verticalStride = verticalStrides[i * 3 + j];\n            vec3 p2 = vec3(p1.x, p1.y - verticalStride * round(p1.y / verticalStride), p1.z);\n        \n            result = opUnion(result, dSphere(p2, radius));\n        }\n    }\n\n    return result;\n}\n\nfloat sdf ( in vec3 p )\n{\n    // float innerCapsules = dVerticalCapsulesStream(q, 0.2);\n    float outerCapsules = dVerticalCapsulesStream(p, 0.4);\n    float box = dRoundedBox(p, vec3(2.0, 0.1, 2.0));\n    return opSmoothSubtraction(outerCapsules, box, 0.2);\n    // return dSphere(p, 2.0);\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit)\n{\n    vec3\tp         = from;\n    float\ttotalDist = 0.0;\n    \n    hit = false;\n    \n    for ( int steps = 0; steps < maxSteps; steps++ )\n    {\n        float\tdist = sdf ( p );\n        \n        if ( dist < 0.001 )\n        {\n            hit = true;\n            break;\n        }\n        \n        totalDist += dist;\n        \n        if ( totalDist > 20.0 )\n            break;\n            \n        p += dist * dir;\n    }\n    \n    return p;\n}\n\nvec3 generateNormal ( vec3 z, float d)\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0));\n    float dx2 = sdf(z - vec3(e, 0, 0));\n    float dy1 = sdf(z + vec3(0, e, 0));\n    float dy2 = sdf(z - vec3(0, e, 0));\n    float dz1 = sdf(z + vec3(0, 0, e));\n    float dz2 = sdf(z - vec3(0, 0, e));\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nconst float PI = 3.14159265359;\n\nmat3 lookAtRotation(vec3 cameraPos, vec3 lookAtPoint, float roll) {\n    vec3 upLooking = vec3(sin(roll), cos(roll), 0.0);\n    vec3 forward = normalize(lookAtPoint - cameraPos);\n    vec3 right = normalize(cross(upLooking, forward));\n    vec3 up = normalize(cross(forward, right));\n\t\n\treturn mat3(-right, up, -forward);\n}\n\nvec3 getTriplanarWeights ( in vec3 n ) \n{\n\tvec3 triW = abs(n);\n    \n\treturn triW / (triW.x + triW.y + triW.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hit;\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    \n    vec2 mouseAdd = vec2(1.0, 0.8);\n\n    vec2 screenUV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n\n    vec3 rayOrigin = rotateX(mix(-PI / 2.0, PI / 2.0, 1.0 - mouseUV.y - mouseAdd.y)) * rotateY(mix(-PI, PI, mouseUV.x - mouseAdd.x)) * vec3 ( 0, 0, 6 );\n    vec3 target = vec3(0);\n  \n    vec3 rayDirection = lookAtRotation(rayOrigin, target, 0.0) * normalize(vec3(screenUV, -1.0));\n\n    vec3 p = trace ( rayOrigin, rayDirection, hit );\n    \n    if ( hit )\n    {\n        vec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( rayOrigin - p );\n        vec3  n  = generateNormal   ( p, 0.001 );\n        float nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 32.0 );\n        vec3  tx = getTriplanarWeights ( n );\n\n        vec4  cx = texture ( iChannel0, p.yz );\n        vec4  cy = texture ( iChannel0, p.zx );\n        vec4  cz = texture ( iChannel0, p.xy );\n\n        vec4 diffuseColor = tx.x * cx + tx.y * cy + tx.z * cz;\n        \n        color = 0.4 * diffuseColor + 0.6 * nl * diffuseColor + 0.5 * sp * vec4 ( 1, 1, 1, 1 );    \n        fragColor = color;\n    }\n    else\n        fragColor = texture(iChannel3, rayDirection);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    float xSquash = mix(0.7, 1.0, sin(iTime));\n    float ySquash = 1.0;\n    float zSquash = mix(0.8, 1.0, sin(iTime + 10.0));\n    vec3 squash = vec3(xSquash, ySquash, zSquash);\n\n    // Output to cubemap\n    fragColor = vec4(texture(iChannel0, rayDir * squash).rgb, 1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}