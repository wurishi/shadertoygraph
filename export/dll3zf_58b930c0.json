{"ver":"0.1","info":{"id":"dll3zf","date":"1672490023","viewed":116,"name":"Simple Raymarching Sample Code","username":"ii0244is","description":"For practice.\nInspiration was from [TDF2018]Time_machine, by EvilRyu\nhttps://www.shadertoy.com/view/XttBWX","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Inspiration was from [TDF2018]Time_machine, by EvilRyu\n// https://www.shadertoy.com/view/XttBWX\n//\n\n////////////////////////////////////////////////////////////////\n// Distance Function\n// https://iquilezles.org/articles/distfunctions/\n////////////////////////////////////////////////////////////////\n\nfloat plane(vec3 p, vec3 n, float h)\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n  return length(pos)-radius;\n}\n\nfloat ellipsoid(vec3 pos, vec3 radius)\n{\n  float k0 = length(pos/radius);\n  float k1 = length(pos/(radius*radius));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat roundCone(vec3 p, float r1, float r2, float h)\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat torus(vec3 pos, vec2 t)\n{\n  vec2 q = vec2(length(pos.xz)-t.x,pos.y);\n  return length(q)-t.y;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n  vec3 q = abs(pos) - size;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat verticalCapsule( vec3 pos, float height, float radius )\n{\n  vec3 p = pos;\n  p.y -= clamp( p.y, 0.0, height );\n  return length( p ) - radius;\n}\n\nfloat boxFrame(vec3 pos, vec3 size, float frameWidth)\n{\n  vec3 p = abs(pos)-size;\n  vec3 q = abs(p+frameWidth)-frameWidth;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat line(vec3 pos, vec3 start, vec3 stop, float width)\n{\n    vec3 pa=pos-start;\n    vec3 ba=stop-start;   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa-h*ba)-width;\n}\n\n////////////////////////////////////////////////////////////////\n// Distance Function (Material)\n////////////////////////////////////////////////////////////////\n\nfloat line(vec2 pos, vec2 a, vec2 b, float r)\n{\n    vec2 pa=pos-a;\n    vec2 ba=b-a;\n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa-h*ba)-r;\n}\n\n////////////////////////////////////////////////////////////////\n// Util\n////////////////////////////////////////////////////////////////\n\nfloat deg2rad(float deg){\n    return 3.141592 / 180.0 * deg;\n}\n\n/*\n * https://wgld.org/d/glsl/g017.html\n */\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n////////////////////////////////////////////////////////////////\n// Main\n////////////////////////////////////////////////////////////////\n\n// ObjId\n#define NONE     0.0\n#define HEAD     1.0\n#define BODY     2.0\n#define NOSE     3.0\n#define ARM      4.0\n#define HAND     5.0\n#define LEG      6.0\n#define FOOT     7.0\n#define BELL     8.0\n#define NECKLACE 9.0\n#define FRAME    10.0\n#define BILLDING 11.0\n#define GROUND   12.0\n\n// Doraemon\n#define SPEED     10.0\n#define DORA_ROT  50.0\n\n// TIME\n#define LOOP_TIME 60.0\n\n//////////////////// Parts /////////////////////////////////////\n\nfloat head(in vec3 pos, out vec3 localPos) {\n    pos = rotate(pos, deg2rad(DORA_ROT-10.), vec3(1.0, 0.0, 0.0));\n    localPos = pos - vec3(0.0, 0.7, 0.0);\n    return sphere(localPos, 1.5);\n}\n\nfloat nose(in vec3 pos, out vec3 localPos) {\n    pos = rotate(pos, deg2rad(DORA_ROT-10.), vec3(1.0, 0.0, 0.0));\n    localPos = pos - vec3(0.0, 0.8, 1.5);\n    return sphere(localPos, 0.18);\n}\n\nfloat body(in vec3 pos, out vec3 localPos) {\n    localPos = pos;\n    localPos.z *= 1.2;\n    localPos -= vec3(0.0, -1.5, 0.0);\n    return verticalCapsule(localPos, 0.7, 1.1);\n}\n\nfloat bell(in vec3 pos, out vec3 localPos) {\n    pos.x = abs(pos.x);\n    pos = pos - vec3(0, -0.65, 0.9);  \n    localPos = pos;\n    return sphere(localPos, 0.2);\n}\n\nfloat arm(in vec3 pos, out vec3 localPos) {\n    pos.x = abs(pos.x);\n    pos = pos - vec3(0.8, -0.7, 0.0);  \n    pos = rotate(pos, deg2rad(135.0), vec3(0.0, 0.0, 1.0));\n    localPos = pos;        \n    return roundCone(localPos, 0.35, 0.23, 1.2);\n}\n\nfloat hand(in vec3 pos, out vec3 localPos) {\n    pos.x = abs(pos.x);\n    pos = pos - vec3(1.8, -1.7, 0.0);  \n    localPos = pos;\n    return sphere(localPos, 0.3);\n}\n\nfloat leg(in vec3 pos, out vec3 localPos) {\n    pos.x = abs(pos.x);\n    pos = pos - vec3(0.6, -2.8, 0.0);  \n    pos = rotate(pos, deg2rad(-10.0), vec3(0.0, 0.0, 1.0));\n    localPos = pos;        \n    return roundCone(localPos, 0.4, 0.55, 1.0);\n}\n\nfloat foot(in vec3 pos, out vec3 localPos) {\n    pos.x = abs(pos.x);\n    pos = pos - vec3(0.68, -3.2, 0.0);\n    pos.y *= 1.7;    \n    localPos = pos;\n    return sphere(localPos, 0.5);\n}\n\nfloat necklace(in vec3 pos, out vec3 localPos) {\n    pos = pos - vec3(0.0, -0.45, 0.0);\n    pos.y *= 2.5;   \n    localPos = pos;\n    return torus(localPos, vec2(0.52));  \n}\n\nfloat billding(in vec3 pos, out vec3 localPos) {\n    vec2 c = vec2(60.0, 18.0);\n    vec3 q = pos - vec3(30.0, -5.0, 0.0);;\n    vec2 flp = floor((q.xz + 0.5 * c) / c);\n    q.xz = mod(q.xz + 0.5 * c, c) - 0.5 * c;    \n    localPos = q;\n    return box(vec3(q), vec3(8.0, 30.0, 6.0));\n}\n\nfloat ground(in vec3 pos, out vec3 localPos) {\n    localPos = pos;\n    return plane(pos, vec3(0.0, 1.0, 0.0), 8.0);\n}\n\n//////////////////// Map & Material & Bg ///////////////////////\n\nfloat map_draemon(\n    in vec3 pos, in vec3 offset, in float time, \n    out float objId, out vec3 localPos\n) {\n    float d_temp = 10000.0;   \n    vec3 localPos_temp = vec3(0.0);\n    \n    pos = rotate(pos-offset, deg2rad(-DORA_ROT), vec3(1.0, 0.0, 0.0));\n    pos += vec3(sin(time), 2.0*cos(time*1.4), cos(time/7.0));\n    \n    float d = head(pos, localPos);\n    objId = HEAD;\n    \n    d_temp = nose(pos, localPos_temp);\n    if(d_temp < d){\n        d = d_temp;\n        localPos = localPos_temp;\n        objId = NOSE;\n    }\n    \n    d_temp = body(pos, localPos_temp);\n    if(d_temp < d){\n        d = d_temp;\n        localPos = localPos_temp;\n        objId = BODY;\n    }\n    \n    d_temp = bell(pos, localPos_temp);\n    if(d_temp < d){\n        d = d_temp;\n        localPos = localPos_temp;\n        objId = BELL;\n    }\n    \n    d_temp = arm(pos, localPos_temp);\n    if(d_temp < d){\n        d = d_temp;\n        localPos = localPos_temp;\n        objId = ARM;\n    }\n\n    d_temp = hand(pos, localPos_temp);\n    if(d_temp < d){\n        d = d_temp;\n        localPos = localPos_temp;\n        objId = HAND;\n    }\n\n    d_temp = leg(pos, localPos_temp);\n    if(d_temp < d){\n        d = d_temp;\n        localPos = localPos_temp;\n        objId = LEG;\n    }\n\n    d_temp = foot(pos, localPos_temp);\n    if(d_temp < d){\n        d = d_temp;\n        localPos = localPos_temp;\n        objId = FOOT;\n    }\n\n    d_temp = necklace(pos, localPos_temp);\n    if(d_temp < d){\n        d = d_temp;\n        localPos = localPos_temp;\n        objId = NECKLACE;\n    }\n\n    return d;\n}\n\nfloat map_background(\n    in vec3 pos, in float time, \n    out float objId, out vec3 localPos\n) {\n    float d_temp = 10000.0;   \n    vec3 localPos_temp = vec3(0.0);\n    \n    float d = billding(pos, localPos);\n    objId = BILLDING;\n\n    d_temp = ground(pos, localPos_temp);\n    if(d_temp < d){\n        d = d_temp;\n        localPos = localPos_temp;\n        objId = GROUND;\n    }    \n\n    return d;\n}\n\nfloat map(\n    in vec3 pos, in vec3 offset, in float time, \n    out float objId, out vec3 localPos\n) {\n    float d_temp = 100000000.0;   \n    float objId_temp = NONE;\n    vec3 localPos_temp = vec3(0.0);\n    \n    // Doraemon\n    float d = map_draemon(pos, offset, time, objId, localPos);\n\n    // Background\n    d_temp = map_background(pos, time, objId_temp, localPos_temp);\n    if(d_temp < d){\n        d = d_temp;\n        localPos = localPos_temp;\n        objId = objId_temp;\n    }    \n\n    return d;\n}\n\nvec4 material(float id, vec3 pos) {\n    if (id == HEAD) {    \n        if(pos.z>0.0){\n            // eyeball\n            vec2 eyeballPos = vec2(0.2,0.57);  \n            float lx = abs(pos.x) - eyeballPos.x;\n            float ly = pos.y - eyeballPos.y;\n            float len = length(vec2(lx, ly*0.7));\n            if(0.03 < len && len < 0.1){ \n                return vec4(0.0, 0.0, 0.0, 1.0);\n            }else if(len < 0.1){ \n                return vec4(0.9, 0.9, 0.9, 1.0);            \n            }\n \n            // eye\n            vec2 eyePos = vec2(0.27,0.67);  \n            lx = abs(pos.x) - eyePos.x;\n            ly = pos.y - eyePos.y;\n            len = length(vec2(lx, ly*0.7));\n            if(0.23 < len && len < 0.25){ \n                return vec4(0.0, 0.0, 0.0, 1.0);\n            }else if(len < 0.25){ \n                return vec4(0.9, 0.9, 0.9, 1.0);            \n            }\n            \n            // beards \n            if(abs(pos.x) < 0.025 && -0.3 < pos.y && pos.y < 0.0) {\n                return vec4(0.0, 0.0, 0.0, 1.0);         \n            }\n            if(line(vec2(abs(pos.x), pos.y), vec2(0.7, 0.3), vec2(0.3, 0.2), 0.02) < 0.001) {\n                return vec4(0.0, 0.0, 0.0, 1.0);  \n            }\n            if(line(vec2(abs(pos.x), pos.y), vec2(0.8, 0.0), vec2(0.3, 0.05), 0.02) < 0.001) {\n                return vec4(0.0, 0.0, 0.0, 1.0);  \n            }\n            if(line(vec2(abs(pos.x), pos.y), vec2(0.7, -0.3), vec2(0.3, -0.1), 0.02) < 0.001) {\n                return vec4(0.0, 0.0, 0.0, 1.0);  \n            }\n            \n            // mouth\n            lx = pos.x;\n            ly = pos.y + 0.55;\n            len = length(vec2(lx*0.5, ly));\n            if(len < 0.32 && ly < 0.2) {\n                return vec4(0.8, 0.1, 0.1, 1.0);\n            }\n            \n            // face\n            vec3 faceCenterPos = vec3(0.0,-0.1,0.32);\n            if (length(faceCenterPos - pos) < 1.3) {\n                return vec4(0.9, 0.9, 0.9, 1.0);\n            }\n            \n            // head\n            return vec4(0.0, 0.5, 1.0, 1.0);\n        }else{        \n            // head\n            return vec4(0.0, 0.5, 1.0, 1.0); \n        }    \n    }else if(id == NOSE){\n        return vec4(1.0, 0.0, 0.0, 1.0); \n    }else if(id == BODY){\n        // pocket\n        float lx = pos.x;\n        float ly = pos.y - 0.25;\n        float len = length(vec2(lx*0.8, ly));\n        if(len < 0.45 && ly < 0.2 && pos.z > 0.0) {\n            return vec4(0.8, 0.8, 0.8, 1.0);\n        }\n        \n        // body\n        lx = pos.x;\n        ly = pos.y - 0.3;\n        len = length(vec2(lx, ly*0.9));\n        if (len < 0.74 && pos.z > 0.0) {\n            return vec4(0.9, 0.9, 0.9, 1.0); \n        }\n        return vec4(0.0, 0.5, 1.0, 1.0);\n    }else if(id == BELL){\n        return vec4(0.9, 0.9, 0.1, 1.0);\n    }else if(id == ARM){\n        return vec4(0.0, 0.5, 1.0, 1.0);\n    }else if(id == HAND){\n        return vec4(0.9, 0.9, 0.9, 1.0);\n    }else if(id == LEG){\n        return vec4(0.0, 0.5, 1.0, 1.0);\n    }else if(id == FOOT){\n        return vec4(0.9, 0.9, 0.9, 1.0);\n    }else if(id == NECKLACE){\n        return vec4(0.9, 0.3, 0.3, 1.0);        \n    }else if(id == FRAME){\n        return vec4(0.0, 1.0, 0.0, 1.0);\n    }else if(id == BILLDING){\n        if(mod(pos.z-0.5,1.0) < 0.5 && mod(pos.y, 2.0) < 1.0) {\n            return vec4(0.9, 0.9, 0.3, 1.0);\n        }\n        if(mod(pos.x-0.5,2.0) < 1.0 && mod(pos.y, 2.0) < 1.0) {\n            return vec4(0.9, 0.9, 0.3, 1.0);\n        }\n        return vec4(0.5, 0.5, 0.5, 1.0);\n    }else if(id == GROUND){\n        // road\n        if (abs(pos.x) < 0.3 && mod(pos.z,12.0) < 6.0) {\n            return vec4(0.9, 0.9, 0.9, 1.0);            \n        }\n        \n        // line\n        if (abs(pos.x) < 12.0) {\n            return vec4(0.5, 0.5, 0.5, 1.0);\n        }\n        \n        // sidewalk\n        return vec4(0.8, 0.8, 0.8, 1.0); \n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 bg(vec2 pos) {\n    return vec4(.15, .15, .15, 1.0);\n    // return vec4(.15, .75, .95, 1.0);\n}\n\nvec3 getNormal(vec3 p, vec3 o, float t)\n{\n    const float d = 0.0001;\n    float id = 0.0;\n    vec3 lp = vec3(0.0);\n    return normalize(\n        vec3( \n            map(p+vec3(d,0.0,0.0),o,t,id,lp) - map(p+vec3(-d,0.0,0.0),o,t,id,lp),\n            map(p+vec3(0.0,d,0.0),o,t,id,lp) - map(p+vec3(0.0,-d,0.0),o,t,id,lp),\n            map(p+vec3(0.0,0.0,d),o,t,id,lp) - map(p+vec3(0.0,0.0,-d),o,t,id,lp)\n        )\n    );\n}\n\n/*\n * sp : screen position\n * ro : ray origin\n * rd : ray direction\n */\nvec4 render(vec2 sp, vec3 ro, vec3 rd, float time) {\n\n    // in\n    vec3 pos = ro;\n    vec3 offset = vec3(0.0, 0.0, time*SPEED);\n    \n    // out\n    float distance = 0.0;\n    float objId = NONE;\n    vec3 localPos = vec3(0.0);\n    \n    // ray marching\n    for (int i=0; i<128; i++)\n    {\n        distance = map(pos, offset, time, objId, localPos);\n        if(abs(distance) < 0.01){\n            break;\n        }\n        pos = pos + rd * distance;\n    }\n\n    // lighting\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    if(abs(distance) < 0.01){\n        vec4 materialColor = material(objId, localPos);\n        vec3 lightPos = vec3(0.0, 0.0, 10.0) + offset;\n        vec3 lightDir = normalize(lightPos - pos);\n        vec3 normal = getNormal(pos, offset, time);\n        vec4 diffuseColor = vec4(0.5 * dot(lightDir, normal) * materialColor.xyz, 1.0);\n        vec4 ambientColor = 0.5 * materialColor;\n        color = diffuseColor + ambientColor;\n    }else{\n        color = bg(sp);\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenPos = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n    float time_msec = fract(iTime);\n    float time_sec = mod(floor(iTime), LOOP_TIME);\n    float time = time_sec + time_msec;\n    float offsetZ = time * SPEED;\n    \n    // Camera\n    vec3 cameraPos    = vec3(10.0*sin(time/8.0), -2.0, 10.0+5.0*cos(time/4.0) + offsetZ);\n    vec3 cameraTarget = vec3(0.0, 0.0, offsetZ);\n    vec3 cameraDir    = normalize(cameraTarget - cameraPos); \n    vec3 cameraSide   = normalize(cross(cameraDir, vec3(0.0, 1.0, 0.0)));\n    vec3 cameraUp     = normalize(cross(cameraSide, cameraDir));\n\n    // Calc Ray\n    float focusLength = 2.0;\n    vec3 rayDir = normalize(cameraSide*screenPos.x + cameraUp*screenPos.y + cameraDir*focusLength);\n\n    // Render\n    fragColor = render(screenPos, cameraPos, rayDir, time);\n}","name":"Image","description":"","type":"image"}]}