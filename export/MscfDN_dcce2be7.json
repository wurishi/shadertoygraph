{"ver":"0.1","info":{"id":"MscfDN","date":"1525215235","viewed":167,"name":"rainbow spiral","username":"lucastakejame","description":"pulsating spiral","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","spiral","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float oscillatingRadialMask(float curRadius)\n{\t\n\tfloat ratio = iResolution.x/iResolution.y;\n    float ringRadius = ratio*(.5 + .5*sin(iTime*.7));\n    return pow(clamp(1.-abs(curRadius - ringRadius)*2./ratio, -.5, 1.), 5.);\n}\n\nfloat differenceToSpiralRing(float ringN, float radius, float angle, float k)\n{\n\tfloat theta = angle + ringN*2.*M_PI;\n    \n    return abs(radius - (k*theta*(1. + .3*sin(2.*iTime + k*theta))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy*2. - iResolution.xy)/iResolution.y;\n    float ratio = iResolution.x/iResolution.y;\n    \n    // polar uv\n    vec2 puv = cartesianToPolar(uv);\n    float r = puv.x;\n    float ang = puv.y;    \n    float k = .03;\n    \n    ang -= 1.; \n\n    \n    // color for when in spiral and when near spiral\n    vec3 col1 = hsl2rgb(vec3(r/2.+ ang/(2.*M_PI), 1., .8));\n    vec3 col2 = hsl2rgb(vec3(r/2.+ ang/(2.*M_PI), .5, .3));\n \n    float check;\n    float thick = 0.03;\n    \n    // polar function : r = k*theta(1 + .3sin(2*iTime + k*theta))\n    // so pixel is painted if (r/(k(1+.3sin(2*Time+k*ang))) - ang)/2pi is an integer\n    // considering theta = ang + n*2pi\n    // since k*ang breaks the spiral, im using r, but there is that artifact in the larger rings\n    /*\n    check = fract( \n    ( \n        ( r/\n          ( k*(1. + .3*sin(2.*iTime + 2.2*r))))\n        - ang\n    ) / (2.*M_PI) );\n   \n    \n    fragColor = (check < thick)? vec4((col1 * (.5-(check-thick)/thick)), 1.) : mix(vec4(0.), vec4(col2, 1.),abs(check-.5)/2.);\n\t*/\n\t\n    float smallest = 100.;\n    \n    // brute force checking\n\tfor( int i = 0; i < 15; i++)\n    {\n        \n        check = differenceToSpiralRing(float(i), puv.x+.05, puv.y, k);\n        if(check <= thick)\n        {\n\t\t\tfragColor = vec4((col1 * .5 + .4*(1.- pow((check-thick)/thick,3.))), 1.);\n            break;\n        }\n        else\n        {\n            smallest = (check < smallest)? check: smallest;\n            fragColor = mix(vec4(0.), vec4(col2, 1.),1.8-abs(smallest-thick)/thick);\n        }\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float M_PI = 3.14159265359;\n\n\n// converts HSL (vec3(hue, saturation, lightness) ) to RGB\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n// get value in interval [a, b] (similar to mod, but works with negative) \nfloat modExpanded( float x, float a, float b)\n{       \n   \treturn a + mod(x-a, b-a);\n}\n\n\nvec2 cartesianToPolar(in vec2 coord)\n{\n    // (radius, angle)\n    return vec2(distance(coord, vec2(0.)), modExpanded(atan(coord.y, coord.x), 0., 2.*M_PI));\n}\n\nvec2 polarToCartesian(in vec2 coord)\n{\n    // (x, y)\n    return vec2(coord.x*cos(coord.y), coord.x*sin(coord.y));\n}","name":"Common","description":"","type":"common"}]}