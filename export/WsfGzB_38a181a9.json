{"ver":"0.1","info":{"id":"WsfGzB","date":"1546711671","viewed":429,"name":"Breakout inspired brick game","username":"bitblast","description":"A game inspired by Breakout.\nHold down the left mouse button and use your mouse to play.\nPress R to reset.","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 blockColor(vec2 fragCoord, sampler2D blockSampler)\n{\n    float blockStartY = (1.0 - BLOCK_SECTION_YREL) * iResolution.y;\n    if (fragCoord.y >= blockStartY)\n    {\n        vec2 blockSize = blockSize(iResolution.xy);\n        vec2 inBlocks = fragCoord;\n        inBlocks.y -= blockStartY;\n        vec2 blockPos = inBlocks / blockSize;\n        vec2 fromBorderXY = (0.5 - abs(0.5 - fract(blockPos))) * blockSize;\n        float fromBorder = min(fromBorderXY.x, fromBorderXY.y);\n        float borderSize = 0.002 * iResolution.x;\n        float alpha = saturate(fromBorder - borderSize + 0.5);\n        vec4 blockColor = texture(blockSampler, (floor(blockPos) + 0.5) / iResolution.xy);\n        if (blockColor.a < 1.0)\n        \tblockColor.rgb = mix(blockColor.rgb, vec3(1.0), saturate(5.0 * (blockColor.a - 0.8)));\n        blockColor.a *= alpha;\n        return blockColor;\n    }\n    else\n        return vec4(0.0);\n}\n\nvec4 ballColor(vec2 fragCoord, BallData ball)\n{\n    float radius = BALL_RADIUS_REL * iResolution.y;\n    float alpha = saturate(SQRT2HALF * (radius - length(fragCoord - ball.pos) + SQRT2HALF));\n    return vec4(1.0, 1.0, 1.0, alpha);\n}\n\nvec4 paddleColor(vec2 fragCoord, PaddleData dat)\n{\n    float paddleWidth = PADDLE_WIDTH_REL * iResolution.x;\n    float paddleRadius = PADDLE_RADIUS_REL * iResolution.y;\n    vec2 paddlePos = vec2(dat.posX, PADDLE_POS_REL * iResolution.y);\n    vec2 rel = abs(fragCoord - paddlePos);\n    rel.x = max(0.0, rel.x - 0.5 * paddleWidth + paddleRadius);\n    float alpha = saturate(SQRT2HALF * (paddleRadius - length(rel) + SQRT2HALF));\n    \n    float fromHighlight = abs(abs(fragCoord.x - dat.lastHitPos - dat.posX)\n        - dat.sinceLastHit * 2.5 * paddleWidth);\n    float highlight = 3.0 * fromHighlight / paddleWidth;\n    float val = mix(1.0, 0.5, saturate(highlight));\n    return vec2(val, alpha).xxxy;\n}\n\nvec4 livesColor(vec2 fragCoord, int lives)\n{\n    fragCoord.y = iResolution.y - fragCoord.y;\n    float liveSeparation = LIVE_SEPARATION_REL * iResolution.y;\n    vec2 inLiveSpace = (1.0 / liveSeparation) * fragCoord;\n    if (false&&checkersPattern(inLiveSpace))\n        return vec4(0.5);\n    if (int(inLiveSpace.y) == 0 && int(inLiveSpace.x) < lives)\n    {\n        float radius = LIVE_RADIUS_REL * iResolution.y;\n        float outlineRadius = radius + LIVE_OUTLINE_REL * iResolution.y;\n    \tvec2 center = ceil(inLiveSpace) * liveSeparation - outlineRadius - SQRT2HALF;\n    \tvec2 relAbs = abs(fragCoord - center);\n        float len = length(relAbs);\n        float centerAlpha = saturate(SQRT2HALF * (radius - len + SQRT2HALF));\n        float outlineAlpha = saturate(SQRT2HALF * (outlineRadius - len + SQRT2HALF));\n    \treturn blend(vec4(1.0, 1.0, 1.0, centerAlpha), vec4(0.0, 0.0, 0.0, outlineAlpha * 0.7));\n    }\n    else\n    \treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvec2 swirl(vec2 fragCoord, vec2 center, float strength)\n{\n    vec2 rel = fragCoord - center;\n    float len = max(0.0, strength - length(rel) / length(center));\n    float angle = 10.0 * len;\n    vec2 sc = vec2(sin(angle), cos(angle));\n    return center + vec2(sc.y * rel.x - sc.x * rel.y, sc.y * rel.y + sc.x * rel.x);\n}\n\nvec4 stateDebugColor(vec2 fragCoord, StateData dat)\n{\n    int x = int(fragCoord.x / 10.0);\n    float yf = fragCoord.y / 10.0;\n    int y = int(yf);\n    if (x == 0 && y == dat.state)\n        return vec4(1.0);\n    if (x == 1 && yf < dat.timeInState)\n        return vec4(1.0, 0.0, 1.0, 1.0);\n    if (x == 2 && y == dat.lives)\n        return vec4(1.0, 1.0, 0.0, 1.0);\n    return vec4(0.0);\n}\n\nvec4 confettiColor(vec2 fragCoord, vec4 confetti, float confettiRadius, int index)\n{\n    /*float amp = CONFETTI_AMPLITUDE_REL * iResolution.y;\n    vec2 pos = confetti.xy;\n    pos.x += sin(confetti.w * confetti.y) * amp*/\n    float len = length(fragCoord - confetti.xy);\n    float alpha = saturate(SQRT2HALF * (confettiRadius - len + SQRT2HALF));\n    vec3 col = hsv2rgb(vec3(float(index) / float(CONFETTI_COUNT), 1.0, 1.0));\n    return vec4(col, alpha);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    StateData state = loadState(iChannel0, iResolution.xy);\n    BallData ball = loadBall(iChannel0, iResolution.xy);\n    \n    if (state.state == STATE_LOSS)\n    \tfragCoord = swirl(fragCoord,\n                          0.5 * iResolution.xy,\n                          1.2 * state.timeInState / LOSS_ANIMATION_DURATION);\n    PaddleData paddle = loadPaddle(iChannel0, iResolution.xy);\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    col = blend(blockColor(fragCoord, iChannel0), col);\n    col = blend(paddleColor(fragCoord, paddle), col);\n    col = blend(ballColor(fragCoord, ball), col);\n    col = blend(livesColor(fragCoord, state.lives), col);\n    if (state.state == STATE_LOSS)\n        col.rgb *= saturate(1.0 - state.timeInState / (LOSS_ANIMATION_DURATION - 0.05));\n    else if (state.state == STATE_WON)\n    {\n        col.rgb *= saturate(1.0 - state.timeInState / (0.5 * WIN_ANIMATION_DURATION));\n        float confettiRadius = CONFETTI_RADIUS_REL * iResolution.y;\n        for (int i = 0; i < CONFETTI_COUNT; ++i)\n        {\n            vec4 confetti = texture(iChannel0, (vec2(BLOCKS_X + i, 1.0) + 0.5) / iResolution.xy);\n            //confetti = vec4(500.0, 500.0, 0.0, 0.0);\n            col = blend(confettiColor(fragCoord, confetti, confettiRadius, i), col);\n\t\t}\n    }\n#if DEBUG_STATE_DATA\n    col = blend(stateDebugColor(fragCoord, state), col);\n#endif\n        \n    fragColor = vec4(col.rgb * col.a, 1.0);\n    if (iMouse.x < 0.0)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    /*if (length(fragCoord - blockCenter(vec2(0.0, 0.0), iResolution.xy)) < 10.0)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);*/\n    //fragColor = texture(iChannel0, (floor(fragCoord * 0.1) + 0.5) / iResolution.xy);\n    //fragColor = vec4(fract(fragCoord), 0.0, 1.0);\n    //fragColor = blend(texture(iChannel0, 0.05 * fragCoord / iResolution.xy), fragColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define CHEAT_SOLID_FLOOR 0\n#define DEBUG_STATE_DATA 0\n#define CHEAT_INSTAWIN_HOTKEY 0\n\nconst int BLOCKS_X = 12;\nconst int BLOCKS_Y = 8;\nconst int START_LIVES = 2;\nconst float BLOCK_SECTION_YREL = 0.40;\nconst float BALL_RADIUS_REL = 0.018;\nconst float LIVE_RADIUS_REL = 0.017;\nconst float LIVE_OUTLINE_REL = 0.0075;\nconst float LIVE_SEPARATION_REL = 0.06;\nconst float BALL_SPEED_REL = 0.45;\nconst float PADDLE_WIDTH_REL = 0.17;\nconst float PADDLE_RADIUS_REL = 0.01;\nconst float PADDLE_POS_REL = 2.3 * PADDLE_RADIUS_REL;\nconst float START_VEL_REL = 0.45;\nconst float MIN_Y_VEL_REL = 0.2;\nconst float MAX_PADDLE_SPEED_REL = 2.0;\nconst float MAX_VEL_REL = 1.4;\nconst float BLOCK_DECAY = 2.0;\nconst float LOSS_ANIMATION_DURATION = 0.75;\nconst float WIN_ANIMATION_DURATION = 1.75;\nconst int CONFETTI_COUNT = 40;\nconst float CONFETTI_RADIUS_REL = 0.061;\nconst vec2 CONFETTI_SPEED_RANGE_REL = vec2(0.8, 1.2);\nconst float CONFETTI_AMPLITUDE_REL = 0.5;\nconst vec2 CONFETTI_FREQUENCY_RANGE_REL = vec2(1.2, 8.3);\n\nconst float PI = 3.14159265359;\nconst float SQRT2HALF = 0.70710678118;\nconst float SQRT2 = 1.41421356237;\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 blend(vec4 src, vec4 dest)\n{\n    return vec4(mix(dest.rgb, src.rgb, src.a), mix(dest.a, 1.0, src.a));\n}\n\nbool doReset(sampler2D keyboardTexture, int iFrame)\n{\n    return iFrame == 0 || texture(keyboardTexture, vec2(82.5 / 256.0, 0.166666)).x > 0.5;\n}\n\nbool checkKey(sampler2D keyboardTexture, float asciiUpperCase)\n{\n    return texture(keyboardTexture, vec2((asciiUpperCase + 0.5) / 256.0, 0.166666)).x > 0.5;\n}\n\nbool checkersPattern(vec2 pos)\n{\n    pos *= 2.0;\n    return (fract(pos.x) >= 1.0) == (fract(pos.y) >= 1.0);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nstruct BallData { vec2 pos; vec2 vel; };\nstruct PaddleData { float posX; float velX; float lastHitPos; float sinceLastHit; };\n\nconst int STATE_UNINITIALIZED = 0;\nconst int STATE_PLAYING = 1;\nconst int STATE_LOSS = 3;\nconst int STATE_WON = 4;\nstruct StateData { int state; float timeInState; int lives; };\n\nBallData loadBall(sampler2D dataSampler, vec2 iResolution)\n{\n    vec4 smpl = texture(dataSampler, (vec2(BLOCKS_X, 0.0) + 0.5) / iResolution);\n    return BallData(smpl.xy, smpl.zw);\n}\n\nvec4 encodeBall(BallData data)\n{\n    return vec4(data.pos, data.vel);\n}\n\nPaddleData loadPaddle(sampler2D dataSampler, vec2 iResolution)\n{\n    vec4 smpl = texture(dataSampler, (vec2(BLOCKS_X + 1, 0.0) + 0.5) / iResolution);\n    return PaddleData(smpl.x, smpl.y, smpl.z, smpl.w);\n}\n\nvec4 encodePaddle(PaddleData data)\n{\n    return vec4(data.posX, data.velX, data.lastHitPos, data.sinceLastHit);\n}\n\nStateData loadState(sampler2D dataSampler, vec2 iResolution)\n{\n    vec4 smpl = texture(dataSampler, (vec2(BLOCKS_X + 2, 0.0) + 0.5) / iResolution);\n    return StateData(int(smpl.x), smpl.y, int(smpl.z));\n}\n\nvec4 encodeState(StateData data)\n{\n    return vec4(float(data.state), data.timeInState, float(data.lives), 0.0);\n}\n\nfloat unitRandom(vec2 param, float seed)\n{\n    return fract(sin(dot(param.xy + seed,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec2 blockSize(vec2 iResolution)\n{\n    return vec2(iResolution.x / float(BLOCKS_X), BLOCK_SECTION_YREL * iResolution.y / float(BLOCKS_Y));\n}\n\nvec2 blockCenter(vec2 blockIndex, vec2 iResolution)\n{\n    vec2 ret = blockSize(iResolution) * (blockIndex + 0.5);\n    ret.y += (1.0 - BLOCK_SECTION_YREL) * iResolution.y;\n    return ret;\n}\n\nvec2 toBlockSpaceRelativeToCenters(vec2 fragCoord, vec2 iResolution)\n{\n    fragCoord.y -= (1.0 - BLOCK_SECTION_YREL) * iResolution.y;\n    return fragCoord / blockSize(iResolution) - 0.5;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Data:\n// Blocks: (color.rgb, active?)\n// Ball: (pos.xy, velocity.xy)\n// Paddle: (pos.x, velocity.x, lives, timeToReset)\n\n\nvec4 initBlock(vec2 fragCoord)\n{\n    float rnd = unitRandom(fragCoord, floor(iTime));\n    return vec4(hsv2rgb(vec3(rnd, 0.7, 1.0)), 1.0);\n}\n\nbool ballCollidesWith(BallData ball, float ballRadius, vec2 blockIndex, out bool isVertical)\n{\n    vec2 sizeHalf = 0.5 * blockSize(iResolution.xy);\n    vec2 center = blockCenter(blockIndex, iResolution.xy);\n    vec2 ballRelSigned = ball.pos - center;\n    vec2 ballRel = abs(ballRelSigned);\n    vec2 fromBorder = ballRel - sizeHalf - ballRadius;\n    if (abs(ball.vel.x) < 0.00001 || ball.vel.x * ballRelSigned.x > 0.0)\n        isVertical = true;\n    else if (abs(ball.vel.y) < 0.00001 || ball.vel.y * ballRelSigned.y > 0.0)\n        isVertical = false;\n    else\n        isVertical = abs(fromBorder.y / ball.vel.y) < abs(fromBorder.x / ball.vel.y);\n    return fromBorder.x <= 0.0 && fromBorder.y <= 0.0;\n}\n\nvec4 updateBlock(vec2 fragCoord, vec4 previousFrame, BallData ball, float ballRadius)\n{\n    bool isVertical;\n    bool doCheat = false;\n#if CHEAT_INSTAWIN_HOTKEY\n    doCheat = checkKey(iChannel3, 87.0);\n#endif\n    if (previousFrame.a < 1.0\n        || doCheat\n        || ballCollidesWith(ball, ballRadius, floor(fragCoord), isVertical))\n        return vec4(previousFrame.rgb, max(0.0, previousFrame.a - BLOCK_DECAY * iTimeDelta));\n    else\n        //return vec4(1.0);\n    \treturn previousFrame;    \n}\n\nBallData initBall()\n{\n    float dir = fract(iTime) >= 0.5 ? 1.0 : -1.0;\n    vec2 pos = 0.5 * vec2(iResolution.x, (1.0 - BLOCK_SECTION_YREL) * iResolution.y);\n    vec2 vel = SQRT2 * vec2(START_VEL_REL * iResolution.y);\n    vel.x *= dir;\n    return BallData(pos, vel);\n}\n\nBallData destroyBall()\n{\n    return BallData(vec2(0.0, -999999999.9), vec2(0.0));\n}\n\nBallData moveBall(BallData dat, float ballRadius)\n{\n    dat.pos += iTimeDelta * dat.vel;\n    vec2 limits = iResolution.xy - ballRadius;\n    if (dat.pos.x < ballRadius)\n    {\n        dat.pos.x = 2.0 * ballRadius - dat.pos.x;\n        dat.vel.x = -dat.vel.x;\n    }\n#if CHEAT_SOLID_FLOOR\n    if (dat.pos.y < ballRadius)\n    {\n        dat.pos.y = 2.0 * ballRadius - dat.pos.y;\n        dat.vel.y = -dat.vel.y;\n    }\n#endif\n    if (dat.pos.x > limits.x)\n    {\n        dat.pos.x = 2.0 * limits.x - dat.pos.x;\n        dat.vel.x = -dat.vel.x;\n\t}\n    if (dat.pos.y > limits.y)\n    {\n        dat.pos.y = 2.0 * limits.y - dat.pos.y;\n        dat.vel.y = -dat.vel.y;\n\t}\n    return dat;\n}\n\nvoid checkBlockCollision(BallData ball, float ballRadius, vec2 blockIndex,\n                         inout bool bounceH, inout bool bounceV)\n{\n    bool isVertical;\n    if (blockIndex.x >= 0.0 && blockIndex.x < float(BLOCKS_X)\n        && blockIndex.y >= 0.0 && blockIndex.y < float(BLOCKS_Y)\n        && ballCollidesWith(ball, ballRadius, blockIndex, isVertical)\n       \t&& texture(iChannel0, (blockIndex + 0.5) / iResolution.xy).a >= 1.0)\n    {\n        if (isVertical)\n        \tbounceV = true;\n        else\n            bounceH = true;\n    }\n}\n\nBallData updateBall(BallData dat, float ballRadius, inout PaddleData paddle)\n{\n    // Block collisions\n    {\n        bool bounceH = false;\n        bool bounceV = false;\n        vec2 blockPos = toBlockSpaceRelativeToCenters(dat.pos, iResolution.xy);\n        vec2 basePos = floor(blockPos);\n        checkBlockCollision(dat, ballRadius, basePos + vec2(0.0, 0.0), bounceH, bounceV);\n        checkBlockCollision(dat, ballRadius, basePos + vec2(0.0, 1.0), bounceH, bounceV);\n        checkBlockCollision(dat, ballRadius, basePos + vec2(1.0, 0.0), bounceH, bounceV);\n        checkBlockCollision(dat, ballRadius, basePos + vec2(1.0, 1.0), bounceH, bounceV);\n\n        if (bounceH)\n            dat.vel.x = -dat.vel.x;\n        if (bounceV)\n            dat.vel.y = -dat.vel.y;\n    }\n    \n    if (dat.vel.y < 0.0)\n    {\n        float paddleWidth = PADDLE_WIDTH_REL * iResolution.x;\n        float paddleRadius = PADDLE_RADIUS_REL * iResolution.y;\n        vec2 paddlePos = vec2(paddle.posX, PADDLE_POS_REL * iResolution.y);\n        vec2 relToPaddle = dat.pos - paddlePos;\n        if (relToPaddle.y > 0.0)\n        {\n            bool collision = false;\n            float capStart = 0.5 * paddleWidth - paddleRadius;\n            if (abs(relToPaddle.x) < capStart\n                && relToPaddle.y < paddleRadius + ballRadius)\n            {\n                dat.vel.y = -dat.vel.y;\n                dat.pos.y = paddlePos.y + paddleRadius + ballRadius;\n                collision = true;\n            }\n            else\n            {\n                float sgn = sign(relToPaddle.x);\n                vec2 relToCap = relToPaddle;\n                relToCap.x -= sgn * capStart;\n                float radiusSum = paddleRadius + ballRadius;\n                if (dot(relToCap, relToCap) <= radiusSum * radiusSum)\n                {\n                    vec2 dir = normalize(relToCap);\n                \tdat.vel = reflect(dat.vel, dir);\n                    dat.pos = paddlePos + vec2(sgn * capStart, 0.0) + dir * radiusSum;\n                    collision = true;\n                }\n            }\n            if (collision)\n            {\n                if ((paddle.velX > 0.0) == (relToPaddle.x > 0.0))\n                \tdat.vel.x += paddle.velX;\n                float velMag = length(dat.vel);\n                float maxVel = MAX_VEL_REL * iResolution.y;\n                if (velMag > maxVel)\n                    dat.vel *= maxVel / velMag;\n                dat.vel.y = max(MIN_Y_VEL_REL * iResolution.y, dat.vel.y);\n                paddle.sinceLastHit = 0.0;\n                paddle.lastHitPos = relToPaddle.x;\n            }\n        }\n    }\n    \n    return dat;\n}\n\nPaddleData initPaddle()\n{\n    return PaddleData(iMouse.x, 0.0, 0.0, 9999999.99);\n}\n\nPaddleData updatePaddle(PaddleData dat)\n{    \n    float maxMove = MAX_PADDLE_SPEED_REL * iResolution.x * iTimeDelta;\n    float paddleWidthHalf = 0.5 * PADDLE_WIDTH_REL * iResolution.x;\n    float prevPos = dat.posX;\n    float desiredPos = clamp(iMouse.x, paddleWidthHalf, iResolution.x - paddleWidthHalf);\n    dat.posX = clamp(desiredPos, prevPos - maxMove, prevPos + maxMove);\n    dat.velX = (dat.posX - prevPos) / iTimeDelta;\n    dat.sinceLastHit += iTimeDelta;\n    return dat;\n}\n\nStateData updateState(StateData state, BallData ball, out bool isReset)\n{\n    isReset = false;\n    int stateBefore = state.state;\n    if (doReset(iChannel3, iFrame))\n    {\n        stateBefore = STATE_UNINITIALIZED;\n        state.state = STATE_PLAYING;\n    }\n    else if (state.state == STATE_PLAYING)\n    {\n    \tif(ball.pos.y < -BALL_RADIUS_REL * iResolution.y)\n            --state.lives;\n        if (state.lives < 0)\n            state.state = STATE_LOSS;\n        else if (state.timeInState > 0.0)\n        {\n            bool hasWon = true;\n            for (int x = 0; x < BLOCKS_X; ++x)\n                for (int y = 0; y < BLOCKS_Y; ++y)\n                    hasWon = hasWon && texture(iChannel0, (vec2(x, y) + 0.5) / iResolution.xy).a < 1.0;\n            \n           \tif (hasWon)\n                state.state = STATE_WON;\n        }\n    }\n    else if (state.state == STATE_LOSS)\n    {\n        if (state.timeInState >= LOSS_ANIMATION_DURATION)\n            state.state = STATE_PLAYING;\n    }\n    else if (state.state == STATE_WON)\n    {\n        if (state.timeInState >= WIN_ANIMATION_DURATION)\n            state.state = STATE_PLAYING;\n    }\n        \n    \n    if (stateBefore != STATE_PLAYING && state.state == STATE_PLAYING)\n    {\n        isReset = true;\n        state.lives = START_LIVES;\n    }\n    \n    if (stateBefore == state.state)\n        state.timeInState += iTimeDelta;\n    else\n        state.timeInState = 0.0;\n    return state;\n}\n\n// Confetti format: (pos.xy, vertical speed, flutter frequency)\nvec4 initConfetti(vec2 fragCoord)\n{\n    float speedRand = unitRandom(fragCoord, iTime * 0.037);\n    float speedY = -mix(CONFETTI_SPEED_RANGE_REL.x, CONFETTI_SPEED_RANGE_REL.y, speedRand);\n    speedY *= iResolution.y;\n    float freqRandom = unitRandom(fragCoord, iTime * 0.073);\n    float frequency = mix(CONFETTI_FREQUENCY_RANGE_REL.x, CONFETTI_FREQUENCY_RANGE_REL.y, freqRandom);\n    //return vec4(500.0, 500.0, -0.1, 1.0);\n    return vec4(unitRandom(fragCoord, iTime * 0.013) * iResolution.x,\n                iResolution.y + CONFETTI_RADIUS_REL * iResolution.y,\n                speedY,\n                frequency);\n}\n\nvec4 updateConfetti(vec4 data)\n{\n    float amp = CONFETTI_AMPLITUDE_REL * iResolution.y;\n    data.xy += vec2(sin(data.w * data.y / iResolution.y) * amp, data.z) * iTimeDelta;\n    return data;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    bool isBlock = fragCoord.x < float(BLOCKS_X) && fragCoord.y < float(BLOCKS_Y);\n    int coordX = int(fragCoord.x);\n    int coordY = int(fragCoord.y);\n    bool isBall = coordX == BLOCKS_X && coordY == 0;\n    bool isPaddle = coordX == BLOCKS_X + 1 && coordY == 0;\n    bool isState = coordX == BLOCKS_X + 2 && coordY == 0;\n    bool isConfetti = coordX >= BLOCKS_X && coordX < BLOCKS_X + CONFETTI_COUNT && coordY == 1;\n    if (isBlock || isBall || isPaddle || isState || isConfetti)\n    {\n        PaddleData paddle = loadPaddle(iChannel0, iResolution.xy);\n        BallData prevBall = loadBall(iChannel0, iResolution.xy);\n        StateData prevState = loadState(iChannel0, iResolution.xy);\n        float ballRadius = BALL_RADIUS_REL * iResolution.y;\n\t\tBallData ball;\n        if(prevState.state == STATE_PLAYING)\n            ball = moveBall(prevBall, ballRadius);\n        else\n            ball = prevBall;\n        bool isReset;\n        StateData nextState = updateState(prevState, ball, isReset);\n\n        if (isState)\n            fragColor = encodeState(nextState);\n        else if (isConfetti)\n        {\n            if (nextState.state == STATE_WON && prevState.state != STATE_WON)\n            \tfragColor = initConfetti(fragCoord);\n            else\n                fragColor = updateConfetti(texture(iChannel0, fragCoord / iResolution.xy));\n\t\t}\n        else\n        {\n            if (isReset)\n            {\n                if (isBlock)\n                    fragColor = initBlock(fragCoord);\n                else if (isBall)\n                    fragColor = encodeBall(initBall());\n                else if (isPaddle)\n                    fragColor = encodePaddle(initPaddle());\n            }\n            else\n            {\n                if (isBlock)\n                {\n                    vec4 prev = texture(iChannel0, fragCoord / iResolution.xy);\n                    fragColor = updateBlock(fragCoord, prev, ball, ballRadius);\n                }\n                else if (isBall || isPaddle)\n                {\n                    ball = updateBall(ball, ballRadius, paddle);\n                    if (isBall)\n                    {\n                    \tif (nextState.lives < prevState.lives)\n                    \t{\n\t                        if (nextState.lives >= 0)\n    \t                        fragColor = encodeBall(initBall());\n        \t                else\n            \t                fragColor = encodeBall(prevBall);\n                \t    }\n                    \telse\n                        \tfragColor = encodeBall(ball);\n                    }\n                    else if (isPaddle)\n                        fragColor = encodePaddle(updatePaddle(paddle));\n                }\n            }\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}