{"ver":"0.1","info":{"id":"fsjGWD","date":"1617428392","viewed":87,"name":"Julia Tiling","username":"Symmetries","description":"Tiling the plane with Julia sets, and using a simple ray tracer to add a reflective sphere.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy; // from 0 to 1\n    st = 2. * st - 1.; // from -1 to 1\n    st.y *= iResolution.y / iResolution.x; // fix aspect ratio\n    st.y -= 0.1;\n    float theta = 2. * cos(3.14 + iTime / 2.);\n\n    mat3 rot = mat3(\n        cos(theta), -sin(theta), 0.,\n        sin(theta), cos(theta),  0.,\n        0.,          0.,           1.\n    );\n    \n    float dx = 1. / iResolution.x;\n    vec3[9] ws = vec3[9](\n        vec3(st.x - dx, 1., st.y - dx),\n        vec3(st.x - dx, 1., st.y     ),\n        vec3(st.x - dx, 1., st.y + dx),\n        vec3(st.x     , 1., st.y - dx),\n        vec3(st.x     , 1., st.y     ),\n        vec3(st.x     , 1., st.y + dx),\n        vec3(st.x + dx, 1., st.y - dx),\n        vec3(st.x + dx, 1., st.y     ),\n        vec3(st.x + dx, 1., st.y + dx)\n    );\n    \n    vec3 p = vec3(0., 3., 0.);\n    float r = 1.;\n    \n    fragColor = vec4(0., 0., 0., 0.);\n    for (int i = 0; i < ws.length(); i++) {\n        ws[i] = rot * normalize(ws[i]);\n     \n        float a = dot(ws[i], ws[i]);\n        float b = -2. * dot(ws[i], p);\n        float c = dot(p, p) - r * r;\n        float dis = b * b - 4. * a * c;    \n\n        float t = (-b - sqrt(abs(dis))) / (2. * a);\n        float cond = float(dis > 0. && t > 0.);\n        vec3 o = cond * t * ws[i];\n        ws[i] += cond * (normalize(reflect(ws[i], p - o)) - ws[i]);\n        vec3 col = vec3(0, 0, 0);\n\n        if (ws[i].z < 0.) {\n            vec2 c = vec2(-0.391, -0.587);\n            vec2 v = o.xy + (-1. - o.z) * ws[i].xy / ws[i].z + vec2(2., 0.5);\n            float zoom = 1.6;\n            vec2 z = 2. * zoom * fract(.2 * v) - zoom;\n            \n            float cond = 0.;\n            float n = 10.;\n            for (int iter = 0; iter < 100; iter++) {\n                cond = float(dot(z, z) > 4.);\n                z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n                col = cond * vec3(1. - exp(-float(iter / 2) / 4.), 0.1, 0.1) + (1. - cond) * col;\n            }\n        } else {\n            col = 1.1 * ws[i].zzz;\n        }\n        fragColor += vec4(col, 1.) / float(ws.length());\n    }\n}","name":"Image","description":"","type":"image"}]}