{"ver":"0.1","info":{"id":"NtSyzt","date":"1650098511","viewed":116,"name":"Cyclic Ordering","username":"smjty","description":"Experimenting...","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","lines","ordering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Twitter: @smjtyazdi\n\n#define PI 3.1416\n#define NN 8.\n#define D 0.15\nconst float scale = 0.05;\n\nvec2 rot(vec2 p, float t){\n    return vec2(p.x*cos(t) + p.y*sin(t), p.y*cos(t)-p.x*sin(t));\n}\n\nfloat draw(vec2 p, bool shadow){\n\n    float nt = round(mod(atan(p.y,p.x),2.*PI)/PI*NN)*PI/NN;\n    p = rot(p,nt);\n    float edge = 0.5;\n    if(!shadow) edge = 20.;\n    float res = 0.; \n    \n    if(abs(p.y)<D) res = 1.;\n    else res = exp(-pow(abs(p.y)/D - 1., 2.)*edge );\n    if(shadow) return 1. - res;\n    return res;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){ \n    vec2 p = (fragCoord.xy  - iResolution.xy/2.0)/(scale*iResolution.y);\n    float time = iTime*2.*PI/NN/4.;\n    vec3 res = vec3(0.);\n    float d = 5.;\n\n    float del = PI/NN/2.;\n    float b = 0.;\n    vec2 p1 = p + vec2(d,0);\n    vec2 p2 = p - vec2(d,0);\n    \n    b += draw(rot(p1,-time),false)     * draw(rot(p2,time+del),true);\n    b += draw(rot(p1,-time+del),true) * draw(rot(p2,time+del),false);\n    b += draw(rot(p1,-time+del),false) * draw(rot(p2,time),true);    \n    b += draw(rot(p1,-time),true)     * draw(rot(p2,time),false);    \n\n    fragColor = vec4(vec3(b),1.0);\n}","name":"Image","description":"","type":"image"}]}