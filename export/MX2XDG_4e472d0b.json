{"ver":"0.1","info":{"id":"MX2XDG","date":"1711034484","viewed":65,"name":"Ray Ray Closest Point","username":"bloxard","description":"This shader shows the closest point between two rays each defined by a start coordinate and a direction. \nThe large spheres are the closest points inside the each line segment and the smaller spheres are the closest points outside.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","closest","closestpoint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// With the exception of the RayRayClosestPoint method below most of this shader is borrowed from https://www.shadertoy.com/view/4XfSWl by natevm. Thanks! :)\n\nvec2 RayRayClosestPoint(vec3 aP, vec3 aD, vec3 bP, vec3 bD)\n{\n    vec3 abD = bP-aP;\n    float aDOTb = dot(aD,bD);\n    float adDOTabD = dot(aD,abD);\n    float bdDOTabD = dot(bD,abD);\n    float u = (adDOTabD-bdDOTabD*aDOTb)/(1.-aDOTb*aDOTb);\n    float v = u*aDOTb-bdDOTabD;\n    return vec2(v*aDOTb+adDOTabD,v);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\nconst vec3 pa = vec3(-0.7,-0.2,0.4);\nconst vec3 pb = vec3( 0.7,0.2,-0.1);\n\nvec2 minVec2(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 map(in vec3 pos, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    vec3 vLineDelta = sampleLineStop - sampleLineStart;\n    float fLenLineDelta = length(vLineDelta);\n    vec3 vLineDir = vLineDelta / fLenLineDelta;\n    \n    vec3 vABDelta = pb - pa;\n    float fLenAB = length(vABDelta);\n    vec3 vABDir = vABDelta / fLenAB;\n\n    vec2 result = RayRayClosestPoint(sampleLineStart, vLineDir, pa, vABDir);\n    vec3 closestPointOutsideSampleLine = sampleLineStart+vLineDir*result.x;\n    vec3 closestPointOutsideABLine = pa+vABDir*result.y;\n\t\n    vec2 clampedResult = vec2(clamp(result.x,0.,fLenLineDelta),clamp(result.y,0.,fLenAB));   \n    vec3 closestPointOnSampleLine = sampleLineStart+vLineDir*clampedResult.x;\n    vec3 closestPointOnABLine = pa+vABDir*clampedResult.y;\n   \n    vec2 res = vec2(sdCapsule( pos, sampleLineStart, sampleLineStop, .015 ),1.);\n    res = minVec2(res,vec2(sdSphere(pos,closestPointOnSampleLine,0.06),1.));\n    res = minVec2(res,vec2(sdSphere(pos,closestPointOutsideSampleLine,0.04),1.));\n    res = minVec2(res,vec2(sdCapsule(pos,pa,pb,.02),5.));\n    res = minVec2(res,vec2(sdSphere(pos,closestPointOnABLine,0.06),4.0));\n    res = minVec2(res,vec2(sdCapsule(pos,closestPointOnSampleLine,closestPointOnABLine,0.015),4.0));\n    res = minVec2(res,vec2(sdSphere(pos,closestPointOutsideABLine,0.04),4.0));\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, sampleLineStart, sampleLineStop ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, sampleLineStart, sampleLineStop).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate query line\n        vec3 sampleLineStart = -sin(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n        vec3 sampleLineStop  = -cos(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos, sampleLineStart, sampleLineStop);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos, sampleLineStart, sampleLineStop);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );   \n                       \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig, sampleLineStart, sampleLineStop);\n              col += 0.75*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.75*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}