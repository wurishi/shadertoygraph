{"ver":"0.1","info":{"id":"DsdBz8","date":"1697051256","viewed":58,"name":"Box Tunnel","username":"smlk0","description":"Learning ray marching.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TAU = 6.2831853;\n\nvec2 center_uv(vec2 original_uv) {\n\n    original_uv /= iResolution.y;\n\treturn vec2((original_uv.x * 2.0 - iResolution.x/iResolution.y), (original_uv.y * 2.0 - 1.0));\n}\n\nvec2 rotation_2d(vec2 point, float angle) {\n\t\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn point * mat2(vec2(c, -s),\n\t\t\t\t\t\tvec2(s, c));\n}\n\nconst vec3 box_half_dimensions = vec3(0.25, 0.25, 0.25);\nconst vec3 box_offset = vec3(0.0, -1.8, 0.0);\n\nfloat z_backup = 0.0;\n\nfloat sdf_box(vec3 point, float section) {\n\n    z_backup = point.z;\n    \n    point.z += iTime;\n    point.z -= round(point.z);\n    \n    point += box_offset;\n    \n    point.yz = rotation_2d(point.yz, z_backup + abs(section));\n    \n    return length(max(abs(point) - box_half_dimensions, 0.0));\n}\n\nfloat repeat_amount = 8.0;\n\nfloat box_radial_repeat(vec3 point) {\n\n    float section_angle = TAU / repeat_amount;\n    float point_angle = atan(point.x, point.y);\n    float point_section = floor(point_angle / section_angle);\n    float next_section = point_section + 1.0;\n    \n    point.xy = rotation_2d(point.xy, sin(round(point.z + iTime)) * 0.6);\n    \n    vec2 current_point = rotation_2d(point.xy, (section_angle * point_section));\n    float current_box = sdf_box(vec3(current_point, point.z), point_section);\n    vec2 next_point = rotation_2d(point.xy, (section_angle * (next_section)));\n    float next_box = sdf_box(vec3(next_point, point.z), next_section);\n    \n    return min(current_box, next_box);\n}\n\nfloat distance_to_hit(vec3 point) {\n\n    return box_radial_repeat(point)*0.1;\n}\n\nvec3 calculate_normal(vec3 point, float current_distance) {\n\n\tconst float epsilon = 0.001;\n\t\n\tfloat gradient_x =\n\tcurrent_distance - distance_to_hit(vec3(point.x - epsilon, point.y, point.z));\n\tfloat gradient_y =\n\tcurrent_distance - distance_to_hit(vec3(point.x, point.y - epsilon, point.z));\n\tfloat gradient_z =\n\tcurrent_distance - distance_to_hit(vec3(point.x, point.y, point.z - epsilon));\n\t\n\treturn normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\n\nconst vec3 light_position = vec3(0.0, 0.0, -1.0);\n\nint max_steps = 1000;\nfloat max_distance = 100.0;\nfloat tolerance = 0.0001;\nfloat fog_end = 10.0;\nfloat fog_start = 0.0;\n\nvec3 ray_march(vec3 origin, vec3 direction) {\n\t\n\tfloat total_distance = 0.0;\n\t\n\tfor (int i = 0; i < max_steps; ++i) {\n\t\t\n\t\tvec3 current_position = origin + total_distance * direction;\n\t\tfloat current_distance = distance_to_hit(current_position);\n\t\t\n\t\tif (current_distance < tolerance) {\n\t\t\t\n\t\t\tvec3 normal = calculate_normal(current_position, current_distance);\n\t\t\t\n            vec3 light_direction = normalize(light_position - current_position);\n\t\t\tvec3 color = RED * dot(normal, light_direction);\n            \n\t\t\tfloat fog_factor = (1.0 - (fog_end - z_backup)/(fog_end - fog_start));\n\t\t\tcolor = mix(color, BLACK, fog_factor);\n\t\t\t\n\t\t\treturn color;\n\t\t}\n\t\t\n\t\tif (total_distance > max_distance) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotal_distance += current_distance;\n\t}\n\t\n\treturn BLACK;\n}\n\nfloat uv_plane_distance = 0.7;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n\tvec3 camera_position = vec3(0.0, 0.0, -1.0);\n\tvec2 uv = center_uv(fragCoord);\n\tvec3 camera_ray_direction = vec3(uv, uv_plane_distance);\n\t\n\tfragColor = vec4(ray_march(camera_position, camera_ray_direction), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}