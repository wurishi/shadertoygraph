{"ver":"0.1","info":{"id":"mdySz3","date":"1681460172","viewed":173,"name":"Phased array visualizer","username":"Nemerix","description":"Visualizes the interference pattern of a phased array\nGo to Common:106 to change array element layout\nColorbar is -30 to 0db\nControls:\npress 2 or 3 to choose 2D/3D view\nA to toggle panel view\nClick and drag:\n-in 2D: steer beam\n-in 3D: rotate view","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["phasedarraygobrrrrrrrrr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define SHOW_PHASED_ARRAY\n\nfloat dbInDirection(vec2 query, vec2 target)\n{\n  vec2 accum = vec2(0,0);\n  for (uint i = 0u; i < kNumStencil; ++i)\n    {\n      vec3 pos = cellPos(i);\n      float targetPhase = -dot(target, pos.xy) / lam;\n      float queryPhase = -dot(query, pos.xy) / lam;\n      float phase = queryPhase - targetPhase;\n      accum += pos.z * vec2(cos(phase), sin(phase));\n    }\n    float mag = sqrt(dot(accum, accum)) / float(kNumCells);\n    mag = 10.0 * log2(mag) / log2(10.0);\n    return mag;\n}\n\nfloat dbToColorCoord(float db)\n{\n  return 1.0 + db / 30.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n  //return;\n  fragColor.a = 1.0;\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n  uv *= 2.0;\n  \n  vec4 state = STATE(1);\n    \n  // draw phased array instead of interference pattern\n  if (state.b == 1.0) {\n    uv *= 0.5;\n    uv += 0.5;\n    fragColor = vec4(0,0,0,1);\n    for (uint i = 0u; i < kNumStencil; ++i)\n    {\n      vec2 d = cellPos(i).xy - uv;\n      if (dot(d, d) < 0.0002)\n      {\n        fragColor.rgb = viridis(cellPos(i).z);\n      }\n    }\n    return;\n  }\n  \n  // draw colorbar on right edge\n  if (1.667 < uv.x && uv.x < 1.767 && -0.99 < uv.y && uv.y < 0.99)\n  {\n    fragColor.rgb = viridis(0.5 + uv.y / 1.98);\n    return;\n  }\n  \n  vec2 target = STATE(0).xy;\n  \n  // draw interference pattern in 2D, top-down projection\n  if (state.r == 0.0)\n  {\n    if (dot(uv, uv) > 1.0)\n    {\n      fragColor.rgb = viridis(0.0);\n      return;\n    }\n    \n    float db = dbInDirection(uv, target);\n    float s = dbToColorCoord(db);\n    fragColor.rgb = viridis(s);\n  }\n  else\n  {\n    fragColor.rgb = vec3(0,0,0);\n    INIT_CAMERA();\n    \n    vec3 trace = hemisphereTrace(cameraPos, rd);\n    if (trace != OUT_OF_BOUNDS)\n    {\n      float db = dbInDirection(trace.xy, target);\n      float s = dbToColorCoord(db);\n      fragColor.rgb = (trace.z > 0.02) ? viridis(s) : vec3(0.4, 0.2, 0.1);\n      //fragColor.rgb = vec3(1,1,1);\n    }\n  }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define OUT_OF_BOUNDS vec3(0.0, 0.0, 123456789.0)\n\nconst float PI = 3.14159265358979;\n\n// I'm not sure how pixels get assigned to warps,\n// but I know there's 32 threads per warp (on nvidia)\n// so I figure that splitting the processing over 32x32 blocks\n// will make sure that each warp takes at most 1 of the top-level\n// branches. Added bonus, it makes them way easier to see while debugging.\nconst int gap = 32;\n\n#define STATE(x) texelFetch(iChannel0, gap*ivec2(x, 0), 0)\n#define STATEI(i) texelFetch(iChannel0, gap*i, 0)\n#define MY_STATE() texelFetch(iChannel0, ivec2(fragCoord), 0)\n\n\n// Make the variables that describe the camera's position and orientation\n#define INIT_CAMERA()\\\nvec2 m = STATE(2).xy;\\\nm *= vec2(-2.0, -1.0) * PI;\\\nvec3 cameraPos = 2.5 * vec3(cos(m.x)*cos(m.y), sin(m.x)*cos(m.y), sin(m.y));\\\nvec3 cameraDirection = -normalize(cameraPos);\\\nfloat nearPlane = 2.0;\\\nvec3 cameraUp = vec3(0.0, 0.0, 1.0);\\\ncameraUp = cameraUp - dot(cameraUp, cameraDirection) * cameraDirection;\\\ncameraUp = normalize(cameraUp);\\\nvec3 cameraRight = cross(cameraDirection, cameraUp);\\\nvec3 rd = normalize(nearPlane*cameraDirection + uv.x*cameraRight + uv.y*cameraUp);\\\n\n// Trace a ray from ro, in the direction of rd, to a hemisphere with radius 1\nvec3 hemisphereTrace(vec3 ro, vec3 rd)\n{\n  vec3 ret = OUT_OF_BOUNDS;\n  float xd = dot(ro, rd);\n  float xx = dot(ro, ro);\n  float disc = xd*xd - xx + 1.0;\n  if (disc < 0.0) return OUT_OF_BOUNDS;\n  float t1 = -xd - sqrt(disc);\n  float t2 = -xd + sqrt(disc);\n  vec3 p1 = ro+t1*rd;\n  vec3 p2 = ro+t2*rd;\n  ret = (p2.z >= 0.0) ? p2 : ret;\n  ret = (p1.z >= 0.0) ? p1 : ret;\n  return ret;\n}\n\n\n\n// random variance in placement of each element,\n// as a fraction of the spacing between elements\nconst float noiseScale = 0.02;\n\nvec2 noise(vec2 p)\n{\n  float h = dot(p, vec2(127.1, 311.7));\n  return -1.0 + 2.0*fract(sin(h) * vec2(43758.5453123, 94033.12829));\n}\n\n// arranges phased array elements in a hexagon, with s elements on a side.\n#define HEXAGON(s)\\\nconst uint k = 2u * uint(s) - 1u;\\\nconst uint kNumStencil = k*k;\\\nconst uint kNumCells = kNumStencil - uint(s)*(uint(s)-1u);\\\nvec3 cellPos(uint cellIdx)\\\n{\\\n  float row = float(cellIdx % k);\\\n  float col = float(cellIdx / k);\\\n  vec2 pos = vec2(row * -0.5 + col, row * 0.866);\\\n  pos += noiseScale * noise(pos);\\\n  float weight = (abs(dot(pos, vec2(1.732, -1.0))) > 1.732 * (float(s)-0.5)) ? 0.0 : 1.0;\\\n  weight *= (dot(pos - vec2(0.5, 0.433), pos - vec2(0.5, 0.433)) < 0.1) ? 0.0 : 1.0;\\\n  return vec3(1.0 / (2.0*float(s)-2.0) * pos.xy + vec2(0.25, 0.067), weight);\\\n}\n\n// arranges phased array elements in a square, with s elements on a side.\n#define SQUARE(s)\\\nconst uint k = uint(s);\\\nconst uint kNumStencil = k*k;\\\nconst uint kNumCells = kNumStencil;\\\nvec3 cellPos(uint cellIdx)\\\n{\\\n  float row = float(cellIdx % k);\\\n  float col = float(cellIdx / k);\\\n  vec2 pos = vec2(col, row);\\\n  pos += noiseScale * noise(pos);\\\n  return vec3(1.0 / (float(k-1u)) * pos.xy, 1.0);\\\n}\n\n// arranges phased array elements in a spiral, with s elements total.\n// The transcendental functions make this MUCH slower than the other arrangements.\n#define SPIRAL(s)\\\nconst uint k = uint(s);\\\nconst uint kNumStencil = k;\\\nconst uint kNumCells = kNumStencil;\\\nconst float phi = 4.960957;\\\nvec3 cellPos(uint cellIdx)\\\n{\\\n  float theta = mod(phi*float(cellIdx), 2.0*PI);\\\n  vec2 pos = vec2(cos(theta), sin(theta));\\\n  pos *= sqrt(float(cellIdx) / float(k-1u));\\\n  pos *= 0.5;\\\n  pos += 0.5;\\\n  pos += noiseScale * noise(pos);\\\n  return vec3(pos, 1.0);\\\n}\n\nHEXAGON(15)\n//SQUARE(20)\n//SPIRAL(200)\n\nconst float c = 3.0e8;\nconst float nu = 30e9;\nconst float lam = c / nu;\n\n//////////////////////////////////////////////////\n// Viridis colormap <3\n// From https://www.shadertoy.com/view/WlfXRN\n//////////////////////////////////////////////////\n\nvec3 viridis(float t) {\n    t = clamp(t, 0.0, 1.0);\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_2 = 50;\nconst int KEY_3 = 51;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_A = 65;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  ivec2 f = ivec2(fragCoord) / gap;\n  if (iFrame == 0 && f.y == 0)\n  {\n    fragColor = vec4(0,0,0,1);\n    switch (f.x)\n    {\n      case 1:\n        fragColor.r = 1.0;\n        break;\n      case 2:\n        fragColor.rg = vec2(0.0, -0.35);\n        break;\n    }\n    return;\n  }\n  \n  // texel 0: beam steering uv\n  if (f.x == 0 && f.y == 0)\n  {\n    fragColor = MY_STATE();\n    vec4 state = STATE(1);\n    // 2D steering\n    if (iMouse.z > 0.0 && state.r == 0.0 && state.b == 0.0)\n    {\n      vec2 uv = (iMouse.xy - iResolution.xy/2.0)/iResolution.y;\n      uv *= 2.0;\n      float len = dot(uv, uv);\n      len = max(len, 1.0);\n      uv /= sqrt(len);\n      fragColor = vec4(uv, 0, 1);\n      return;\n    }\n    // 3D steering\n    if (iMouse.z > 0.0 && state.r == 1.0 && state.g == 1.0 && state.b == 0.0)\n    {\n      vec2 uv = (iMouse.xy - iResolution.xy/2.0)/iResolution.y;\n      uv *= 2.0;\n      INIT_CAMERA();\n      vec3 trace = hemisphereTrace(cameraPos, rd);\n      if (trace == OUT_OF_BOUNDS) return;\n      fragColor = vec4(trace.xy, 0, 1);\n      return;\n    }\n  }\n  \n  // texel 1: display state (2D/3D, rotate/steer, interference/array)\n  if (f.x == 1 && f.y == 0)\n  {\n    fragColor = MY_STATE();\n    if (texelFetch(iChannel1, ivec2(KEY_2,0), 0 ).x > 0.0)\n    {\n      fragColor.r = 0.0;\n    }\n    if (texelFetch(iChannel1, ivec2(KEY_3,0), 0 ).x > 0.0)\n    {\n      fragColor.r = 1.0;\n    }\n    if (texelFetch(iChannel1, ivec2(KEY_R,0), 0 ).x > 0.0)\n    {\n      fragColor.g = 0.0;\n    }\n    if (texelFetch(iChannel1, ivec2(KEY_S,0), 0 ).x > 0.0)\n    {\n      fragColor.g = 1.0;\n    }\n    if (texelFetch(iChannel1, ivec2(KEY_A,1), 0 ).x > 0.0)\n    {\n      fragColor.b = 1.0 - fragColor.b;\n    }\n  }\n  \n  // texel 2: 3D camera state\n  if (f.x == 2 && f.y == 0)\n  {\n        fragColor = MY_STATE();\n    if (iFrame == 1)\n      fragColor.b = 1.0;\n    \n    vec4 state = STATE(1);\n    if (iMouse.z == 0.0 || state.r == 0.0 || state.g == 1.0)\n      return;\n    vec4 baseCamera = STATE(3);\n    // on the first frame of a drag, the 3D camera base state hasn't\n    // been copied from this pixel yet.\n    if (baseCamera == vec4(0,0,0,1))\n      return;\n    vec4 basePixel = STATE(4);\n    fragColor.rg = baseCamera.rg + (iMouse.xy - abs(iMouse.zw)) / iResolution.xy;\n    fragColor.g = clamp(fragColor.g, -0.49, 0.49);\n  }\n  \n  // texel 3: 3D camera state at start of drag\n  if (f.x == 3 && f.y == 0)\n  {\n    vec4 state = STATE(1);\n    if (iMouse.z < 0.0 || state.r == 0.0 || state.g == 1.0)\n    {\n      fragColor = vec4(0,0,0,1);\n      return;\n    }\n    fragColor = MY_STATE();\n    if (fragColor == vec4(0,0,0,1))\n    {\n      fragColor = STATE(2);\n    }\n  }\n}","name":"Buffer A","description":"","type":"buffer"}]}