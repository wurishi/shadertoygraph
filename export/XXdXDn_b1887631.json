{"ver":"0.1","info":{"id":"XXdXDn","date":"1718880337","viewed":32,"name":"albedo everything","username":"servan","description":"have a go at generating all maps for a pbr material from just the colormap","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["colormap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Constants\nconst vec3 lightPos = vec3(0.0, 5.0, 5.0); // Position of the light source\nconst vec3 cameraPos = vec3(0.0, 0.0, 2.0); // Position of the camera\nconst float sphereRadius = 1.0;\nconst float pi = 3.14159265359;\n\n// Function to compute a value from intensity\nfloat computeValue(vec3 color, vec2 clip, bool invert) {\n    float intensity = dot(color, vec3(0.299, 0.587, 0.114)); // Standard grayscale conversion\n    float value = clamp(intensity, clip.x, clip.y);\n    value = (value - clip.x) / (clip.y - clip.x); // Normalize to [0, 1]\n    return invert ? 1.0 - value : value;\n}\n\n// Function to compute normal on a sphere\nvec3 sphereNormal(vec3 p) {\n    return normalize(p);\n}\n\n// Function to compute shading with PBR\nvec3 computeShading(vec3 pos, vec3 normal, vec3 albedo, float roughness, float metallic, float ao) {\n    vec3 N = normal;\n    vec3 V = normalize(cameraPos - pos);\n    vec3 L = normalize(lightPos - pos);\n    vec3 H = normalize(V + L);\n\n    // Ambient Occlusion\n    vec3 ambient = 0.1 * albedo * ao;\n\n    // Diffuse reflection (Lambertian)\n    float NdotL = max(dot(N, L), 0.0);\n    vec3 diffuse = albedo * NdotL;\n\n    // Specular reflection (Cook-Torrance)\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotV = max(dot(N, V), 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n\n    float alpha = roughness * roughness;\n    float alpha2 = alpha * alpha;\n\n    // Distribution function (GGX)\n    float D = alpha2 / (pi * pow((NdotH * NdotH * (alpha2 - 1.0) + 1.0), 2.0));\n\n    // Geometry function (Smith)\n    float k = alpha / 2.0;\n    float G1 = NdotL / (NdotL * (1.0 - k) + k);\n    float G2 = NdotV / (NdotV * (1.0 - k) + k);\n    float G = G1 * G2;\n\n    // Fresnel function (Schlick)\n    vec3 F0 = mix(vec3(0.04), albedo, metallic);\n    vec3 F = F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n\n    vec3 specular = (D * G * F) / (4.0 * NdotV * NdotL + 0.001);\n\n    return ambient + diffuse + specular;\n}\n\n// Ray-sphere intersection\nfloat intersectSphere(vec3 ro, vec3 rd, vec3 center, float radius) {\n    vec3 oc = ro - center;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Ray direction\n    vec3 ro = cameraPos;\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Ray-sphere intersection\n    float t = intersectSphere(ro, rd, vec3(0.0), sphereRadius);\n    if (t < 0.0) {\n        fragColor = vec4(0.0); // Background\n        return;\n    }\n\n    // Sphere hit point\n    vec3 pos = ro + t * rd;\n    vec3 normal = sphereNormal(pos);\n\n    // Texture coordinates\n    vec2 uvSphere = vec2(atan(pos.z, pos.x), acos(pos.y / sphereRadius)) / vec2(2.0 * pi, pi);\n\n    // Sample color from the albedo texture\n    vec3 albedo = texture(iChannel0, uvSphere).rgb;\n\n    // Determine which map to audition\n    int mapType = 1; // We have 6 states to audition\n\n    // Use iMouse to control parameters for demonstration purposes\n    float param1 = iMouse.x / iResolution.x;\n    float param2 = iMouse.y / iResolution.y;\n    bool invert = iMouse.z > 0.5;\n\n    vec2 clip;\n    float scale = 1.0;\n\n    // Define the parameters based on the map type\n    if (mapType == 0) {\n        // Original albedo\n        fragColor = vec4(albedo, 1.0);\n        return;\n    } else if (mapType == 1) {\n        // Albedo + everything\n        clip = vec2(0.0, 1.0); // Default clipping for height map\n        scale = param1; // Scale controlled by mouse x\n    } else if (mapType == 2) {\n        // Height map\n        clip = vec2(0.0, 1.0); // Default clipping for height map\n        scale = param1; // Scale controlled by mouse x\n    } else if (mapType == 3) {\n        // Roughness map\n        clip = vec2(param1, param2); // Clipping range controlled by mouse x and y\n        scale = 1.0;\n    } else if (mapType == 4) {\n        // Metallic map\n        clip = vec2(param1, param2); // Clipping range controlled by mouse x and y\n        scale = 1.0;\n    } else if (mapType == 5) {\n        // AO map\n        clip = vec2(param1, param2); // Clipping range controlled by mouse x and y\n        scale = 1.0;\n    }\n\n    // Compute height map value\n    float height = computeValue(albedo, clip, invert) * scale;\n\n    // Compute texel size for normal mapping\n    vec2 texelSize = 1.0 / iResolution.xy;\n\n    // Sample heights of neighboring texels for normal computation\n    float heightLeft = computeValue(texture(iChannel0, uvSphere - vec2(texelSize.x, 0.0)).rgb, vec2(0.0, 1.0), false) * param1;\n    float heightRight = computeValue(texture(iChannel0, uvSphere + vec2(texelSize.x, 0.0)).rgb, vec2(0.0, 1.0), false) * param1;\n    float heightUp = computeValue(texture(iChannel0, uvSphere + vec2(0.0, texelSize.y)).rgb, vec2(0.0, 1.0), false) * param1;\n    float heightDown = computeValue(texture(iChannel0, uvSphere - vec2(0.0, texelSize.y)).rgb, vec2(0.0, 1.0), false) * param1;\n\n    // Compute gradients\n    vec3 dx = vec3(texelSize.x, 0.0, heightRight - heightLeft);\n    vec3 dy = vec3(0.0, texelSize.y, heightUp - heightDown);\n\n    // Compute normal\n    normal = normalize(cross(dy, dx));\n\n    // Compute roughness, metallic, and AO from height\n    float roughness = computeValue(albedo, vec2(param1, param2), invert);\n    float metallic = computeValue(albedo, vec2(param1, param2), invert);\n    float ao = computeValue(albedo, vec2(param1, param2), invert);\n\n    // Compute shading\n    vec3 shading = computeShading(pos, normal, albedo, roughness, metallic, ao);\n\n    // Output the result based on the current map type\n    if (mapType == 1) {\n        fragColor = vec4(shading, 1.0);\n    } else if (mapType == 2) {\n        fragColor = vec4(vec3(height), 1.0);\n    } else if (mapType == 3) {\n        fragColor = vec4(vec3(roughness), 1.0);\n    } else if (mapType == 4) {\n        fragColor = vec4(vec3(metallic), 1.0);\n    } else if (mapType == 5) {\n        fragColor = vec4(vec3(ao), 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}