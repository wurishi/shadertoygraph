{"ver":"0.1","info":{"id":"lsyfzm","date":"1528080381","viewed":535,"name":"Liquid Glass","username":"kubamaruszczyk1604","description":"Experimenting with SDFs and Shlick's Fresnel factor approximation.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["reflection","raymarch","refraction","liquid","fresnel","snell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//SETTINGS\n\nconst float GLASS_CLARITY = 0.56;\nconst bool COLORS_ENABLED = true;\n\nconst float Ni1 = 1.0; //Air refractive factor\nconst float Ni2 = 1.42; // Glass refractive factor\n\nconst float EXCHANGE_SPEED = 0.2;\nconst float FOV_DEG = 80.0;\nconst vec3 LIGHT_POS =  vec3(-25.0,19.5,-20.0);\nconst float CAMERA_SPEED = 0.2;\n\n\n// Consts / Enumerations \nconst int MAX_STEPS = 200;\nconst float EPS = 0.0001;\nconst float TO_RAD = 0.0174533;\nconst float M_PI = 3.14159265;\nconst float HALF_M_PI = 1.57079635;\nconst int FLOOR_PLANE = 1;\nconst int OBJECT1 = 2;\nconst int OBJECT2 = 3;\nconst int NO_HIT = 0;\n\nstruct Ray\n{\n    vec3 Orgin;\n    vec3 Direction;\n};\n\n//Utils\nmat3 CreateRotationX(float rotation)\n{\n    mat3 rotateX =\n     mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n\n    );\n\n    return rotateX;\n}\n\nmat3 CreateRotationY(float rotation)\n{\n    mat3 rotateY = \n     mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 CreateRotationZ(float rotation)\n{\n    mat3 rotateZ =\n    mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec3 ApplyFog(in vec3 rgb, in float distance) \n{\n    float fogAmount = 1.0 - exp(-distance * 0.002);\n    vec3 fogColor =  vec3(0.7, 0.7, 0.7);\n    return mix(rgb, fogColor, fogAmount);\n}\n\n// SDFs\nfloat SphereSDF(vec3 p,float r)\n{\n    return length(p) - r;\n}\n\n\nfloat TorusSDF(vec3 p, float R, float r)\n{\n    \n    float xy = length(p.xy) - R;\n    float z = length(vec2(xy, p.z)) - r;\n    return z;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y+y;\n}\n\n\n\nvec3 CheckerBoard2(vec2 uv, vec3 col1, vec3 col2, float granularity)\n{\n   granularity *=0.5;\n   float uplusv = (floor(uv.x*granularity)+ floor(uv.y*granularity));\n   bool zz = mod(uplusv, 2.0) == 0.0;\n   return zz?col1:col2; \n   \n}\n//o.x = diffuse coefficient; o.y = specular coefficient\nvec2 PhongModel(vec3 L, vec3 V, vec3 N)\n{\n    vec2 o = vec2(0);\n    o.x = max(0.0, dot(N, L));\n    \n    vec3 R = reflect(L, N);\n    R = normalize(R);\n    o.y = pow(dot(R, V), 180.0);  \n    o.y = max(0.01, o.y);\n   return o;\n}\n\n\n\n\nfloat CombineSDF(vec3 p, inout int closest)\n{\n      vec3 ps = p;\n\n    \n      vec3 sph1Pos = ps + vec3(14.0, -8.0 + 6.0 * sin(iTime * 0.63), 0.0);\n                               \n      float sd = SphereSDF(sph1Pos, 5.0); \n    \n      vec3 sph2Pos = ps + vec3(-14.0, -8.0 + 6.0 * cos(iTime * 0.63), 0.0);\n      float sph2 = SphereSDF(sph2Pos, 5.0); \n      float interT = smoothstep(0.0, 1.0, abs(sin(iTime * EXCHANGE_SPEED)));\n      vec3 torPos = mix(sph1Pos, sph2Pos, interT);//interT * sph1Pos + (1.0 - interT) * sph2Pos;\n      float sph3 = TorusSDF(torPos, 7.0, 2.0);\n    \n      sd = smin(sd, sph2, 5.0); \n      sd = smin(sph3, sd, 5.0); \n      float pd =  PlaneSDF(p, 5.2);   \n    \n      float fin = min(sd, pd);\n      closest = OBJECT1;\n      if(fin == pd)\n      { \n          closest = FLOOR_PLANE;\n      }\n      return fin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    int dummy = 0;\n    return \n    normalize(vec3(\n\t\tCombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - CombineSDF(vec3(p.x - EPS, p.y, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - CombineSDF(vec3(p.x, p.y - EPS, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - CombineSDF(vec3(p.x, p.y, p.z - EPS), dummy)\n\t\t));\n}\n\nfloat Trace(Ray r,inout int hit)\n{\n    hit = 0;\n    float t = 0.0;\n    \n    for(int i =0; i < MAX_STEPS; ++i)\n    {\n        \n       vec3 p = r.Orgin + r.Direction * t;    \n       int closest = 0; \n        \n       float sd = CombineSDF(p, closest);\n        \n        \n       if(sd < EPS)\n       {\n          hit = closest;\n          return t;\n       }\n       t += sd;\n      \n    }\n    return 0.0;\n}\n\nint InShadow(vec3 p, vec3 L, out float t)\n{\n    int shadowHit = NO_HIT;\n    Ray sr;\n    sr.Direction = L;\n    sr.Orgin = p + vec3(0.05);     \n    t =  Trace(sr, shadowHit);\n    return shadowHit;\n}\n\nint Reflection(vec3 p, vec3 L,vec3 N, out float t)\n{\n    Ray reflR;\n    int reflHit = 0;\n    reflR.Direction = reflect(L,N);\n    reflR.Orgin = p + reflR.Direction * 0.1;\n    t = Trace(reflR, reflHit);\n    return reflHit;\n}\n\nvec3 GetPlaneColor(vec3 hitAt, vec3 L, vec3 N, vec3 V)\n{\n  \n    vec2 planeUV = vec2(80.0 + hitAt.x, hitAt.z) / 200.0;  \n    vec3 col = CheckerBoard2(planeUV, vec3(0.1), vec3(0.5), 20.0);\n    col =  0.5 * col + 0.5 * texture(iChannel0,V).xyz;\n    //Shadows\n    float shadowT = 0.0;\n    int shadowHit = InShadow(hitAt, L,shadowT);\n    if(shadowHit  > 1)\n    {\n      col *= 0.72;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = 2.0 * uv -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n     //FOV\n    float fovDist = tan(FOV_DEG * HALF_M_PI/ 180.0);\n    \n    uv *=fovDist;\n    float camRot = sin(iTime*CAMERA_SPEED)*0.3;\n    Ray r;\n    r.Direction = CreateRotationX(-0.0) * normalize(vec3(uv, 1.0));\n    r.Direction *= CreateRotationY(-camRot);\n    r.Orgin = CreateRotationY(camRot) * vec3(-0.0, 9.0, -20.0);\n    \n    vec3 col = vec3(0);  \n    int hit = NO_HIT;  \n    float t = Trace(r,hit);  \n    vec3 hitAt = r.Orgin + r.Direction *t; \n    vec3 lDir = LIGHT_POS - hitAt; \n    lDir = normalize(lDir);\n    \n\n    if(hit == OBJECT1) \n    {\n        vec3 N = GetNormal(hitAt);\n        vec2 dCoeff = PhongModel(lDir, r.Direction, N);\n        //col =  vec3(1.0,0.0,0.4)*dCoeff.x + vec3(1.0)*dCoeff.y;\n        \n        //Shlick's approximation\n        float rZero = pow(((Ni1 - Ni2) / (Ni1 + Ni2)), 2.0);\n        float cosTheta = dot(N, r.Direction);\n        float reflWeight  = rZero +(1.0 - rZero) * pow((1.0 - cosTheta), 10.0);\n        //col =  reflWeight* vec3(0.4)*dCoeff.y;\n        \n        //Reflections\n        Ray reflR;\n        int reflHit = 0;\n        reflR.Direction = reflect(r.Direction, N);\n        reflR.Orgin = hitAt + reflR.Direction * 0.1;\n        float rt = Trace(reflR, reflHit);\n        \n        vec3 reflCol;\n        if(reflHit == FLOOR_PLANE)\n        {\n           reflCol = GetPlaneColor(reflR.Direction * rt,lDir, N, reflR.Direction);\n            \n        }\n        else\n        {\n           reflCol = texture(iChannel0, reflR.Direction).xyz;\n        }\n        \n        \n        //Refraction\n        Ray refrR;\n        int refrHit = 0;\n        refrR.Direction = refract(r.Direction, N, Ni1 / Ni2);\n        refrR.Orgin = hitAt + r.Direction * 12.0;\n        float rft = Trace(refrR, refrHit);\n        \n        //reflCol *= reflWeight;\n        \n        \n \n        vec3 refrCol;\n        if(refrHit == FLOOR_PLANE)\n        {\n           refrCol = GetPlaneColor(refrR.Direction * rft,lDir, N, refrR.Direction);\n        }\n        else if(refrHit == 0)\n        {\n           refrCol = texture(iChannel0, normalize(refrR.Direction)).xyz * vec3(0.9,0.85,1.0);\n        }\n        else if(refrHit == OBJECT1)\n        {\n           refrCol = GetPlaneColor(refrR.Direction * rft, lDir, N, refrR.Direction);\n        }\n         \n        reflWeight = reflWeight *  dCoeff.y * 0.1;\n        col = reflCol * reflWeight + (refrCol) * 0.9;\n        col *= GLASS_CLARITY;\n        //col*=vec3(0.9,0.9,1.0);\n        if(COLORS_ENABLED)\n        {\n           col+=vec3(cos(hitAt.x + iTime * 2.0), 0.0, sin(hitAt.x + iTime * 2.0)) * 0.15 * reflWeight * abs(sin(iTime * 0.15));\n        }\n    }\n    else if (hit == FLOOR_PLANE)\n    {\n        vec3 N = GetNormal(hitAt);\n        col = GetPlaneColor(hitAt, lDir, N, r.Direction);\n        col = ApplyFog(col, length(r.Orgin - hitAt));\n\n    }\n    else\n    {\n      col = texture(iChannel0, normalize(r.Direction)).xyz;\n    }\n\n    // Output to screen\n     fragColor = vec4(pow(col, vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}