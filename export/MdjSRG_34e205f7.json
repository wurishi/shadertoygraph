{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\nprecision highp float;\n\n#define LACU 2.0\n#define MAXGRASSSTEEP 0.4\n#define MAXGRASSALTITUDE .8\n#define MAXSNOWSTEEP   0.35\n#define MAXSNOWALTITUDE 0.4\n#define NORMALEPSILON 0.02\n#define SEALEVEL 0.01 //std 0.3\n#define CAMERAALTITUDE 1.3 //std 1.0\n#define CAMERASCREENDISTANCE 0.5 //std 0.4\n#define LOWITER 5\n#define HIGHITER 8\n#define COLORITER 5\n#define PENUMBRAFACTOR 0.01\n\n\n\n\n/* ****************************************************************** */\nfloat conv(float f) {\n\tf*=f*f*f;  //sealevel 0.01 - flat landscape with few hills\n\t//f = f *(f *(f *(16.5333 - 6.4 * f )-13.6)+4.46667);\n\t//f = f* (f* (f* (f* (33.4169-13.3668 *f)-29.2398)+10.4428)-0.253133); // plains with holes\n\t//f = f* (f* (f* (f* (f* (119.616-40.3125 *f)-131.004)+63.0956)-11.5608)+1.16577);\n    if (f < SEALEVEL){f = SEALEVEL;}\n    return f;\n}\n\n\n// ***** noise code ***************************************************\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//iq hash\nfloat hash( float n )\n{\n    return fract(sin(n)*54321.98761234);  // value has no meaning that I could find\n}\n\n//iq derivative noise function\n// returns vec3(noise, dnoise/dx, dnoise/dy)\nvec3 noised(vec2 pos )\n{\n    vec2 p = floor(pos);\n    vec2 f = fract(pos);\n    \n    vec2 u = (10.0+(-15.0+6.0*f)*f)*f*f*f;  // f=6*x^5-15*x^4+10*x^3  df/dx=30*x^4-60*x^3+30*x^2; horner of df is 30.0*f*f*(f*(f-2.0)+1.0)\n    \n    float n = p.x + p.y*57.0;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+ 57.0); // do not know why 57 & 58\n    float d = hash(n+ 58.0);\n    \n    return vec3( a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n    30.0*f*f*(f*(f-2.0)+1.0) * (vec2(b-a,c-a)+(a-b-c+d)*u.yx) );\n    \n}\n\n//iq  noise function\nfloat noise(vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    f= (10.0+(-15.0+6.0*f)*f)*f*f*f; // smooth\n    \n    float n = p.x + p.y*57.0;\n    \n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    \n    return res;\n}\n\n\n/* ****************************************************************** */\n\n\n/* ****************************************************************** */\n\n\n// fractional brownian motion\n// iter is number of octaves\n\nvec3 fbmDerivative(vec2 p, int iter) {\n    \n    float f = 0.0;\n\tfloat dfx = 0.0;\n\tfloat dfy = 0.0;\n    float fLacunarity = LACU;\n    \n\tfloat amplitude = 0.5;\n\tfloat sumAmplitude = 0.0;\n\t\t\n\tfor (int i=0;i<20;i++) {\n\t\tvec3 value = noised( p ); \n\t\t\n\t\tf += amplitude * value.x;\n\t\tdfx +=  value.y;\n\t\tdfy +=  value.z;\n\t\tp = p * fLacunarity; \n\t\tsumAmplitude+=amplitude;\n\t\tamplitude/=2.0;\n\t\tif (i>iter) {break;}\n\t}\n\tf/=sumAmplitude;\n\t\n    return vec3( conv(f), dfx, dfy);\n}\n\n// same as above, without derivatives\nfloat fbm(vec2 p, int iter){\n\tint idx=0;\n    float f = 0.0;\n\tfloat amplitude = 0.5;\n\tfloat sumAmplitude = 0.0;\n\tfor (int i=0;i<20;i++) {\n\t\tfloat value = noise( p ); \n\t\tf += amplitude * value;\n\t\tp = p * LACU; \n\t\tsumAmplitude+=amplitude;\n\t\tamplitude/=2.0;\n\t\tif ( i>iter ) {break;}\n\t}\n\tf/=sumAmplitude;\n    return conv(f);\n}\n\nvec3 getNormal( vec3 p, int iter ) {\n\t//using noise derivative\n\t//not sure this code is correct\n    vec3 value;\n\tvalue = fbmDerivative( p.xz, iter);\n\tif (value.x <= SEALEVEL) { return vec3(.0,1.0,.0); } //sea is flat\n\tfloat dfx=value.y;\n\tfloat dfz=value.z;\n\t\n\treturn normalize(vec3( -value.y, 1.0, -value.z));\n}\n\n// #####################################################################\nvec3 GenerateTerrainColor(vec3 position, vec3 normal) {\n    float x = position.x;\n    float y = position.z;\n    float z = position.y;\n\tfloat n = getNormal(position,COLORITER).y;\n    float l = 1.0;\n    vec3 terrainColor;\n    vec3 cmin,cmax;\n    \n    // notes\n    \n//Surface de lac 0,02 Ã  0,04 \n//ForÃªt de conifÃ¨res 0,05 Ã  0,15 \n//Surface de la mer 0,05 Ã  0,15 \n//Sol sombre 0,05 Ã  0,15 \n//Cultures 0,15 Ã  0,25 \n//Sable lÃ©ger et sec 0,25 Ã  0,45 \n//Calcaire[1] environ 0,40 \n//Glace environ 0,60 \n//Neige tassÃ©e 0,40 Ã  0,70 \n//Neige fraÃ®che 0,75 Ã  0,90 \n//Miroir parfait 1 \n\n    \n    // *** palette ***\n    \n    // water\n    vec3 ocean      = vec3( 0.08, .12, .5);\n    vec3 shore      = vec3( 0.1, .2,.6);\n    \n    // base layer\n    vec3 beach      = vec3(224.0, 202.0, 181.0)/255.0; \n    vec3 earth      = vec3(239.0, 200.0, 143.0)/255.0; \n    vec3 calcaire   = vec3(132.0, 50.0, 50.0)/255.0;  // marron rouge\n    vec3 rocks      = vec3(105.0, 85.0, 110.0)/255.0; // gris\n    \n    // grass layer\n    vec3 grass1 = vec3 (8.0, 24.0, 4.0)/255.0;\n    vec3 grass2 = vec3 (16.0, 48.0, 4.0)/255.0;\n    \n    // snow layer\n    vec3 snow1 = vec3 ( .78,.78,.78);\n    vec3 snow2 = vec3 ( .9,.9,.9);\n    \n    if ( z <= SEALEVEL) {\n        //water\n        terrainColor = mix (ocean, shore , smoothstep( 0.0, 1.0,  noise( position.xz * 16.0)) );    \n\t\t//terrainColor=shore;\n        return terrainColor;\n    }\n    \n    \n\t// add some noise\n\t// input noise divisor define size of stains in transition areas\n    // multiplicator define the size of the range of altitude with mixed color\n    z += noise( position.xz * 32.0 )* 0.1;   \n    \n    // base color\n    terrainColor = mix (        beach,    earth, smoothstep(SEALEVEL    , SEALEVEL+0.1 , z) );\n    terrainColor = mix ( terrainColor, calcaire, smoothstep(SEALEVEL+0.1, SEALEVEL+0.3 , z) );\n    terrainColor = mix ( terrainColor,    rocks, smoothstep(SEALEVEL+0.3,          1.0  , z) );\n    \n    //add grass\n    if (( n > MAXGRASSSTEEP ) && ( z <  MAXGRASSALTITUDE )) {\n        terrainColor = mix( grass1, grass2, smoothstep(0.0 , 1.0, noise( position.xz * 32.0 )));\n    }\n    \n    // add snow\n    if (( n > MAXSNOWSTEEP) && ( z > MAXSNOWALTITUDE )) {\n        return mix( snow1, snow2, smoothstep(0.0 , 1.0, noise( position.xz * 1.0 )*0.1));\n\t}\n    return vec3(terrainColor);;\n}\n\n\n\n// ###################################################################\n\n\n\n// ###################################################################\nvec4 castRay( vec3 startPosition, vec3 lookatDirection )  {\n    // return vec4 = last worldPosition, 1 if terrain / 0 if sky\n    float step = 0.03;\n    float lastStep;\n    float altitude = 0.0;\n    float lastAltitude;\n    float lastY;\n    float walkStep = 0.0;\n    vec3 p;\n\tfloat delta;\n    lastStep=step;\n    for( int i = 0; i < 180; i++ ) { // GLSL limitation: loop on int only\n        p = startPosition + lookatDirection * walkStep;\n        altitude = fbm( vec2(p.x, p.z),LOWITER);\n\t\tdelta = p.y -  altitude;\n        if(delta<0.0 ){\n            // we are under floor: linear interpolate the intersect\n            walkStep = walkStep - lastStep + lastStep*(lastAltitude-lastY)/(p.y-lastY-altitude+lastAltitude);\n            p = startPosition + lookatDirection * walkStep;\n            altitude = fbm( vec2(p.x, p.z),HIGHITER ); //high definition altitude\n            return vec4(p.x,altitude,p.z,walkStep);\n        }\n        if( p.y <  0.001){\n\t\t\t// under the flow, exit\n            walkStep = walkStep - lastStep + lastStep*(lastAltitude-lastY)/(p.y-lastY-altitude+lastAltitude);\n            p = startPosition + lookatDirection * walkStep;\n            return vec4(p.x,0,p.z,walkStep);\n        }\n        if (p.y > 5.0) {break;} // far in the sky\n        lastAltitude = altitude;\n        lastStep=step;\n        lastY = p.y;\n        step = max(max(0.05,.5*delta) , float(i)/2000.0); // step is big when far from floor and far from camera\n\t\t//step+=0.0005;\n        walkStep += step;\n        \n    }\n    return  vec4(p.x,p.y,p.z,-walkStep);  \n}\n\n// ###################################################################\n\nvec3 calcLookAtDirection( vec3 cP, vec3 cD, float screenDistance, vec2 z ){\n    // cameraPosition\n    // cameraDirection\n    // camera-screen distance\n    // position of pixel on screen\n    \n    // normalize camera direction\n    vec3 cDnorm = normalize (cD);\n    \n    // we are looking for u & v, the unity vectors on screen, in world coordinates\n    // we know that u is // to surface (since we locked horizon at horizontal ):its Y is 0\n    // we know that cDnorm is perpendicular to u\n    // we project to surface to find u.x and u.y\n    vec3 u = vec3(cDnorm.z, 0.0,cDnorm.x);\n    \n    vec3 v = cross( cDnorm, u);\n    \n    //screen point 0,0 in world coordiante\n    vec3 screenPointOO = cP + cDnorm * screenDistance;\n    \n    //z in world coordiantes\n    vec3 screenPointInWorld= screenPointOO + u*z.x + v*z.y;\n    \n    return  (screenPointInWorld-cP);\n    \n}\n\n// #################################################################\n\nvec3 calcStartPosition( vec3 cP, vec3 cD, float screenDistance, vec2 z ){\n    // cameraPosition\n    // cameraDirection\n    // camera-screen distance\n    // position of pixel on screen\n    \n    // normalize camera direction\n    vec3 cDnorm = normalize (cD);\n    \n    // we are looking for u & v, the unity vectors on screen, in world coordinates\n    // we know that u is // to surface =&gt; its Y is 0\n    // we know that cDnorm is perpendicular to u\n    // we project to surface to find u.x and u.y\n    vec3 u = vec3(cDnorm.z, 0.0,cDnorm.x);\n    \n    vec3 v = cross( cDnorm, u);\n    \n    //screen point 0,0 in world coordiante\n    vec3 screenPointOO = cP + cDnorm * screenDistance;\n    \n    //z in world coordiantes\n    vec3 screenPointInWorld= screenPointOO + u*z.x + v*z.y;\n    \n    return  screenPointInWorld;\n    \n}\n\n// #################################################################\nvec3 getNormal( vec3 p ) {\n\t//noise derivative\n    vec3 value;\n\tvalue = fbmDerivative( p.xz, HIGHITER);\n\tif (value.x <= SEALEVEL) { return vec3(.0,1.0,.0); }\n\tfloat dfx=value.y;\n\tfloat dfz=value.z;\n\t//float vy = 1.0 ;\tvy -= dfx*dfx + dfz*dfz;vy=sqrt(vy);\n\t\n\treturn normalize(vec3( -value.y, 1.0, -value.z));\n}\n\n\n vec3 getNormalC( vec3 p ) {\n\t//central differences\n    float eps=NORMALEPSILON;\n    vec3  n = vec3( fbm( vec2(p.x-eps,p.z), HIGHITER ) - fbm( vec2(p.x+eps,p.z), HIGHITER ), \n\t\t\t\t  \t2.0*eps,\n    \t\t\t\tfbm(vec2(p.x,p.z-eps), HIGHITER ) - fbm(vec2(p.x,p.z+eps), HIGHITER ) );\n    return normalize( n );\n}\n\n\n// #################################################################\nfloat castRay2Sun( vec3 startPosition, vec3 lookatDirection )  {\n    float step = 0.03;\n    float lastStep;\n    float altitude = 0.0;\n    float lastAltitude;\n    float lastY;\n    float walkStep = 0.0;\n\tfloat delta;\n    float result = 1.0;\n    vec3 p;\n    lastStep=step;\n    for( int i = 0; i < 20; i++ ) { // GLSL limitation: loop on int only\n        walkStep += step;\n        p = startPosition + lookatDirection * walkStep;\n        altitude = fbm( vec2(p.x, p.z) , HIGHITER);\n\t\tdelta = p.y -  altitude;\n        \n        // if we are about to intersect (=> delta is small)\n        // and we are not too far from our starting point ( / walkStep)\n        // we are on the border of the penumbra\n        // so we can shade by penumbrafactor + constantThatDefineBorderSize * delta/walkstep\n        result = min( result, PENUMBRAFACTOR + 16.0 * delta / walkStep );\n\t\t\n        if( delta < .0){\n\t\t\treturn PENUMBRAFACTOR; //penombre \n        }        \n        \n        \n    }\n    return result;  \n    //return 1.0;\n}\n\nvec3 getShading( vec3 position , vec3 normal ) {\n    vec3 uAmbientColor = vec3 (0.18, 0.18, 0.2) / 2.0;         // ambiant light color\n    vec3 uLightingDirection = vec3(-0.9, 0.2, 0.1); // sunlight direction\n    vec3 uDirectionalColor = vec3( 1.47, 1.35, 1.25);  // sunlight color\n    \n    float penombre = 1.0;\n    vec3 color;\n    \n    // march to sun. if we intersect a moutain, we are in its shadow\n    penombre = castRay2Sun(  position ,uLightingDirection) ;\n    //if (castRay2Sun(  position ,uLightingDirection) < 1.0) {penombre=vec3(0.1);}\n    \n    \n    //directional lightning (sun)\n    float directionalLightWeighting = max(dot(normal, uLightingDirection), 0.0);\n    \n    //final lightning: ambiant, sun, penumbra\n    color = uAmbientColor;\n    color += uDirectionalColor * directionalLightWeighting * penombre;\n    \n\t//color = vec3(1.0, 1.0, 1.0) * penombre; // usefull to debug penumbra\n    \n    return color;\n    \n}\n\n// #################################################################\n\nvec4 applyFog ( vec3 color, float far) {\n\t//just to hide clipping\n    return vec4( mix( color ,vec3(0.5,0.5,0.6), smoothstep(0.0,1.0,far/25.0) ) ,1.0);\n}\n\n// #################################################################\n\nvec4 colorize(vec3 startPosition, vec3 lookatDirection, vec4 position) {\n    \n    vec3 p = position.xyz; //startPosition + lookatDirection * position.w;\n    vec3 n = getNormal( p );\n    vec3 s = getShading( p, n );\n    vec3 m = GenerateTerrainColor( position.xyz, n ); //getMaterial( p, n );\n    return applyFog( m * s, position.w );\n    \n    //return vec4(  m *s ,1.0);\n    \n}\n\n// ###################################################################\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 uCameraXYZ = vec3( 0.0, CAMERAALTITUDE, 0.0); // camera postion\n    vec3 uCameraDirXYZ = vec3(0, -0.40, .707160) ; // camera direction\n    vec4 color;\n    \n    uCameraXYZ.z = iTime/1.9;\n\t\n    \n    float uScreenDistance = CAMERASCREENDISTANCE;  // distance camera/screen\n    \n    \n    float sx=float(iResolution.x);\n    float sy=float(iResolution.y);\n    vec2 z,zn;\n    \n    z.x = fragCoord.x / sx - 0.5;\n    z.y = fragCoord.y / sy - 0.5;\n    \n    vec3 lookatDirection = calcLookAtDirection( uCameraXYZ,uCameraDirXYZ, uScreenDistance, z );\n    vec3 startPosition  = calcStartPosition( uCameraXYZ, uCameraDirXYZ, uScreenDistance, z );\n    \n    vec4 gotcha = castRay( startPosition, lookatDirection );\n    \n    if (gotcha.w > 0.0 ) {\n        color = colorize( startPosition, lookatDirection, gotcha);\n        } else {\n        // sky color;\n        color = vec4( mix ( vec3(0.7,0.9,1.0), vec3(0.5,0.5,0.6), smoothstep(0.0,1.0,-gotcha.w/30.0)), 1.0);\n        \n    }\n    \n    // gamma correction\n    fragColor = pow( color, vec4(1.0/2.2,1.0/2.2,1.0/2.2,1.0) );\n    \n}   // main","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdjSRG","date":"1413533033","viewed":426,"name":"terrain marching 7","username":"rmotfage","description":"v7\ncolors","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","terrain"],"hasliked":0,"parentid":"","parentname":""}}