{"ver":"0.1","info":{"id":"MsScWw","date":"1492637568","viewed":160,"name":"[WIP] Graphing v3","username":"mgrant8164","description":"Watch the zooming-out graph until floating point precision destroys the plot!\nThis shader simply plots a free-form equation/inequality.\nThe function (+more) is configurable in defines.\nCTRL+mouse drag up/down : zoom in/out\nmouse drag: pan","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal","graph","function","plot","equation","plotter","graphing","cartesian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//so far, this has not worked (well) on AMD gpus!\n//NVIDIA and Intel seem to have higher precision floats, therefore the effect looks good.\n//both, however, cap out at around 42.00 iTime.\n\n//Super Sampling Enabled?\n#define SS\n//Super Sampling Level [1-...] (applied if enabled)\n#define SSA 2\n//show background image. not really useful in any way right now.\n//#define bg\n//show grid (for now at resolution 1.)\n//#define grid\n//highlight lines of graph (when left=right)\n//#define lines\n//camera zoom out view\n#define cam_zoom_out\n//less than (left<right) color [rgba]\n#define cplr vec4(1.,0.,0.,1.)\n//greater than (left>right) color [rgba]\n#define cpgr vec4(0.,0.,1.,1.)\n\n//equation/inequality left side formula\n//#define equation_left_side\tsin(x*x+y*y)\n//equation/inequality right side formula\n//#define equation_right_side\tcos(x*y)\n\n/* //equation of a heart\n#define equation_left_side\tpow(x*x+y*y-1.,3.)-x*x*y*y*y\n#define equation_right_side\t0.\n// */\n\n//* //DEMO #1\n//equation/inequality left side formula\n#define equation_left_side\tsin(x*x+y*y)\n//equation/inequality right side formula\n#define equation_right_side\tcos(x*y)\n// */\n/* //DEMO #2 : no idea\n#define equation_left_side\tx*sin(x)\n#define equation_right_side\ty*sin(y)\n// */\n/* //DEMO #3 : floating point precision\n#define equation_left_side\tx-x*sin(x)\n#define equation_right_side\ty-y*sin(y)\n// */\n\n//length of buffer data array\n#define stor_len 256.\n//float:viewport scale (x)\n#define _vpscl_x 3\n//float:viewport scale (y)\n#define _vpscl_y 4\n//float:viewport position (x)\n#define _vppos_x 6\n//float:viewport position (y)\n#define _vppos_y 7\n\n/*** low-level retrieval and decoding methods ***/\n//retrieve value\nvec4 getval(int i) {\n    float pos = (float(i)+0.5)/stor_len * iChannelResolution[0].x;\n    return texelFetch(iChannel0, ivec2(int(pos),0),0);\n}\n//decode int\nint deci(vec4 c) {\n    c *= 255.;\n    return int(c.r) | int(c.g)<<8 | int(c.b)<<16 | int(c.a)<<24;\n}\n//int to fixed point\nfloat itfp(int i) {\n    return intBitsToFloat(i);\n    //return float(i)/FPPRECISION;\n}\n/*** high-level retrieval methods ***/\n//get int\nint geti(int i) { return deci(getval(i)); }\n//get fp\nfloat getfp(int i) { return itfp(geti(i)); }\n\n\nconst float DI = 3.141592653 / 2.;\nconst float PI = 3.141592653;\nconst float TOU = 3.141592653 * 2.;\n//returns angle of vector in radians\nfloat angle(vec2 v) {\n    return mod( atan(v.y/v.x)+DI*(5.-sign(sign(v.x)+.5)) ,TOU) + TOU*floor(length(v)/2.);\n}\n\n//left side of equation/inequality\nfloat lfunc(vec2 coord) {\n    float x = coord.x;\n    float y = coord.y;\n    float r = length(coord);\n    float t = angle(coord);\n    return equation_left_side;\n    //return exp(sin(x)+cos(y));\n    //return x*x + y*y;\n}\n//right side of equation/inequality\nfloat rfunc(vec2 coord) {\n    float x = coord.x;\n    float y = coord.y;\n    float r = length(coord);\n    float t = angle(coord);\n    return equation_right_side;\n    //return sin(exp(x+y));\n    //return sin(atan(abs(pow(x,3.)/y)));\n}\n\n//get function result; 0: lesser, 1: equal, 2: greater\n#define f_greater 4\n#define f_equal 2\n#define f_lesser 1\nint gfres(vec2 coord) {\n    //left side result\n    float lsr = lfunc(coord);\n    //right side result\n    float rsr = rfunc(coord);\n    \n    if(lsr>rsr) return f_greater;\n    if (lsr<rsr) return f_lesser;\n    return f_equal;\n}\n\nvec4 graphImage(vec4 color, vec2 coord) {\n    #ifdef bg\n    color = texture(iChannel1,mod(coord,vec2(1.)));\n    #endif\n    //draw grid\n    #define float_err 0.1\n    //color = vec4(1.);\n    \n    #ifdef grid\n    if(mod(coord.x+.1*float_err,1.)<.2*float_err) color = vec4(vec3(.75),1.);\n    if(mod(coord.y+.1*float_err,1.)<.2*float_err) color = vec4(vec3(.75),1.);\n    #endif\n    \n    vec4 c;\n    if(gfres(coord) == f_greater) c = cpgr;\n    else /*if (lsr<=rsr)*/ c = cplr;\n    color = vec4(mix(color.rgb,c.rgb,c.a),1.);\n    \n    return color;\n}\n\nvec4 mainimg(in vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //fragColor = texture(iChannel0,vec2(uv.x,uv.y));\n    \n    vec2 scale = vec2(getfp(_vpscl_x),getfp(_vpscl_y));\n    vec2 offset = vec2(getfp(_vppos_x),getfp(_vppos_y));\n    \n    #ifdef cam_zoom_out\n    scale *= exp(iTime);\n    #endif\n    vec2 tpos = scale*(fragCoord.xy-0.5*iResolution.xy) + offset;\n    \n    //pixel edge vectors\n    #ifdef lines\n    #define pxeslen 4\n    vec2[pxeslen] pxes = vec2[](vec2(0.5,0.5),vec2(0.5,-0.5),vec2(-0.5,0.5),vec2(-0.5,-0.5));\n    int[pxeslen] pxres = int[](1,1,1,1);\n    for(int i = 0; i < pxeslen; i++) {\n        pxes[i] = pxes[i]*scale+tpos;\n        pxres[i] = gfres(pxes[i]*0.01);\n    }\n    //bool line = (pxres[0] == pxres[1]) && (pxres[1] == pxres[2]) && (pxres[2] == pxres[3]);\n    bool line = 0 == (pxres[0] & pxres[1] & pxres[2] & pxres[3]);\n    if(line) fragColor = vec4(vec3(0.),1.);\n    else fragColor = graphImage(fragColor, tpos*.01);\n    #else\n    fragColor = graphImage(fragColor, tpos*.01);\n    #endif\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    #ifdef SS\n    fragColor = vec4(0.);\n    for(float x = 0.; x < 1.; x += 1./float(SSA)) {\n        for(float y = 0.; y < 1.; y += 1./float(SSA)) {\n        \tfragColor += mainimg(fragColor, fragCoord+vec2(x,y));\n    \t}\n    }\n    fragColor /= float(SSA*SSA);\n    #else\n    fragColor = mainimg(fragColor, fragCoord);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//bool:mouse down (prev. frame)\n#define _mdn 0\n//integer:mouse position (x)\n#define _mpos_x 1\n//integer:mouse position (y)\n#define _mpos_y 2\n//fixed point:viewport scale (x)\n#define _vpscl_x 3\n//fixed point:viewport scale (y)\n#define _vpscl_y 4\n//[reserved] fixed point:viewport scale (z)\n//[reserved] #define _vpscl_y 5\n//fixed point:viewport position (x)\n#define _vppos_x 6\n//fixed point:viewport position (y)\n#define _vppos_y 7\n//fixed point:viewport position (z)\n#define _vppos_z 8\n//angle:viewport rotation (x)\n//#define _vprot_x 9\n//angle:viewport rotation (y)\n//#define _vprot_y 10\n//angle:viewport rotation (z)\n//#define _vprot_z 11\n\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_R 82\n#define KEY_EQU 187\n#define KEY_DASH 189\n\n/*#define float_err 0.1\nbool equ(float a, float b) {\n    return abs(a-b)<float_err;\n}*/\n\n//length of buffer data array\n#define stor_len 256.\n//fixed point precision (1./min_value)\n//#define FPPRECISION 25565.\n\n\n//point from index\nvec2 pfi(int j) {\n    float i = float(j);\n    i -= 1.;\n    float m = floor(sqrt(i));\n    i -= m*m;\n    return vec2(m, m+i) - ((i+m>=0.)?0.:i);\n}\n//index from point\nint ifp(vec2 fc) {\n    int x = int(fc.x), y = int(fc.y);\n    int m = max(x,y);\n    return m*(m-1)+m-x+y;\n}\n\n\n\n//retrieve value\nvec4 getval(int i) {\n    float pos = (float(i)+0.5)/stor_len;\n    return texture(iChannel0, vec2(pos,0.));\n}\n//set value determine\nbool setval(vec2 uv, int i) {\n    float posl = float(i)/stor_len;\n    float posr = (float(i)+1.)/stor_len;\n    return uv.x > posl && uv.x < posr;\n} // int(uv.x*stor_len) == i\n\n\n\n//int to fixed point\nfloat itfp(int i) {\n    return intBitsToFloat(i);\n    //return float(i)/FPPRECISION;\n}\n//fixed point to int\nint fpti(float fp) {\n    return floatBitsToInt(fp);\n    //return int(fp*FPPRECISION);\n}\n\n\n\n//encode int\nvec4 enci(int n) {\n    //n = n & 0xFFFFFF;\n    return vec4(float(n & 0xFF),float((n>>8) & 0xFF),float((n>>16) & 0xFF),float((n>>24) & 0xFF))/255.;\n\t//return vec4(vec3(float(n & 0xFF),float((n>>8) & 0xFF),float((n>>16) & 0xFF))/255.,1.);\n}\n//encode fp\nvec4 encfp(float fp) {\n    return enci(fpti(fp));\n}\n//decode int\nint deci(vec4 c) {\n    c *= 255.;\n    return int(c.r) | int(c.g)<<8 | int(c.b)<<16 | int(c.a)<<24;\n}\n\n\n\n//get int\nint geti(int i) {\n    return deci(getval(i));\n}\n//get fp\nfloat getfp(int i) {\n    return itfp(geti(i));\n}\n\n//get key state\nbool isKeyDown(int keycode) {\n    return texture(iChannel1,vec2(float(keycode)/255.,0.)).r > 0.5;\n}\n\nvec4 onInit(vec4 color, vec2 fc, vec2 uv) {\n    switch(int(uv.x*stor_len)) {\n        case _vpscl_x: {\n            //vp scale x\n            color = encfp(1.);\n            break;\n        }\n        case _vpscl_y: {\n            //vp scale y\n            color = encfp(1.);\n            break;\n        }\n        case _vppos_x: {\n            //vp pos x\n            color = encfp(0.);\n            break;\n        }\n        case _vppos_y: {\n            //vp pos y\n            color = encfp(0.);\n            break;\n        }\n        default: break;\n    }\n    return color;\n}\n\nvec4 onMouseDrag(vec4 color, vec2 fc, vec2 uv) {\n    \n    vec2 vppos = vec2(getfp(6),getfp(7));\n    vec2 scale = vec2(getfp(3),getfp(4));\n    vec2 cmouse = iMouse.xy;\n    vec2 pmouse = vec2(float(geti(1)),float(geti(2)));\n    \n    \n    if(isKeyDown(KEY_CTRL)) {\n        //zoom with mouse\n        float zdelta = scale.y * (pmouse.y-cmouse.y);\n        scale += zdelta * iTimeDelta;// / 64.; //double pix size = 64 px\n    } else {\n        //pan with mouse\n        vec2 vpdelta = scale * (pmouse-cmouse);\n    \tvppos += vpdelta;\n    }\n    \n    switch(int(uv.x*stor_len)) {\n        case _vpscl_x: {\n            //vp scale x\n            color = encfp(scale.x);\n            break;\n        }\n        case _vpscl_y: {\n            //vp scale y\n            color = encfp(scale.y);\n            break;\n        }\n        case _vppos_x: {\n            //vp pos x\n            color = encfp(vppos.x);\n            break;\n        }\n        case _vppos_y: {\n            //vp pos y\n            color = encfp(vppos.y);\n            break;\n        }\n        default: break;\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 color, in vec2 fc ) {\n    vec2 uv = fc.xy / iResolution.xy;\n    if(fc.y < 0.5) {\n        discard;\n        return;\n    }\n    \n    color = texture(iChannel0,uv);\n    //if(equ(fc.x,1.)) {}\n    //if(fc.y > 0.5) { discard; return; }\n    vec2 mouseCoord = iMouse.xy;\n    \n    bool mousebtn = iMouse.z > 1.;\n    bool pmousebtn = getval(0).r > 0.;\n    \n    switch(int(uv.x*stor_len)) {\n        case 0: {\n            //mouse down\n            if(mousebtn) color = vec4(1.);\n            else color = vec4(0.,0.,1.,1.);\n            return;\n        }\n        case 1: {\n            //mouse x coord\n            color = enci(int(iMouse.x));\n            return;\n        }\n        case 2: {\n            //mouse y coord\n            color = enci(int(iMouse.y));\n            return;\n        }\n        default: break;\n    }\n    \n    if((getval(0).b < 0.5) || isKeyDown(KEY_R) || iTime < 1.) {\n        //buffer just created!\n        color = onInit(color, fc, uv);\n        return;\n    }\n    \n    //on mouse event, when dragging\n    if(mousebtn) {\n        //mouse hold\n        if(pmousebtn) {\n            color = onMouseDrag(color, fc, uv);\n            //color = vec4(1.,1.,0.,0.);\n        }\n        //mouse down\n        //else color = vec4(1.,0.,0.,1.);\n    } else {\n        //mouse up\n        //if(pmousebtn) color = vec4(0.,0.,1.,1.);\n        //no event\n        //else color = vec4(0.,0.,0.,1.);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}