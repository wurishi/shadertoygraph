{"ver":"0.1","info":{"id":"lc2BWd","date":"1725670795","viewed":16,"name":"REFLECTION INTENSITY","username":"ShadedSky","description":"kaleidescope ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["specularsymmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants to control the animation speed, frequency, scale, and kaleidoscope effect\n\nconst float PI = 3.14159265359;\nconst float SPEED = 0.02; // Slower speed for smooth transitions\nconst float FREQ = 84.0;  // Frequency for smoother shapes\nconst float SCALE = 2.0; // Scale for larger structures\nconst float REFLECTION_INTENSITY = 0.6; // Intensity of the reflective highlight\n\n// Dynamic mirror range control\nconst float MIN_MIRRORS = 18.0;  // Minimum number of mirror segments\nconst float MAX_MIRRORS = 24.0; // Maximum number of mirror segments\n\n// Function to generate a hue-based color\nvec3 hsv2rgb(float h, float s, float v) {\n    vec3 c = vec3(0.0);  // Initialize the RGB color vector to zero\n    float f = fract(h * 6.0);  // Calculate the fractional part of h * 6.0\n    float p = v * (1.0 - s);   // Calculate intermediary color value based on brightness and saturation\n    float q = v * (1.0 - f * s);   // Another intermediary value\n    float t = v * (1.0 - (1.0 - f) * s);  // Yet another intermediary value\n    int i = int(h * 6.0);  // Integer part of h * 6.0 (used to determine which sector of the RGB color wheel we are in)\n    \n    // Based on the sector, we assign RGB values by interpolating between v, p, q, and t\n    if (i == 0) c = vec3(v, t, p);\n    if (i == 1) c = vec3(q, v, p);\n    if (i == 2) c = vec3(p, v, t);\n    if (i == 3) c = vec3(p, q, v);\n    if (i == 4) c = vec3(t, p, v);\n    if (i == 5) c = vec3(v, p, q);\n    \n    return c;  // Return the RGB color\n}\n\n// Kaleidoscope function to reflect and rotate UV coordinates\n// This function modifies the UV coordinates to produce a kaleidoscopic effect by reflecting and rotating the image in segments.\n// Parameters: \n// uv - the normalized screen coordinates\n// segments - number of symmetrical segments (which we’ll dynamically control)\nvec2 kaleidoscope(vec2 uv, float segments) {\n    // Calculate the angle for each segment by dividing π (180 degrees) by the number of segments\n    float angle = PI / segments;\n    \n    // Calculate the radial distance (length) from the center of the screen to the current UV coordinate\n    float r = length(uv);\n    \n    // Calculate the angle (in radians) of the current UV coordinate relative to the center\n    float a = atan(uv.y, uv.x);\n    \n    // Apply the kaleidoscopic reflection by wrapping the angle 'a' within the range of one segment\n    a = mod(a, 2.0 * angle);\n    \n    // If the angle is greater than the segment's angle, reflect it back\n    if (a > angle) {\n        a = 2.0 * angle - a;\n    }\n    \n    // Return the new UV coordinate, reflected within the current segment and scaled by the radial distance\n    return vec2(cos(a), sin(a)) * r;\n}\n\n// Function to create a specular highlight (reflection-like effect)\nfloat specularHighlight(vec2 uv, vec2 lightDir, float gloss) {\n    // Reflect the UV coordinates relative to the light direction, simulating a mirror reflection\n    vec2 reflected = reflect(normalize(uv), lightDir);\n    \n    // Calculate the intensity of the reflection by taking the dot product with a reference vector (vec2(0.0, 1.0))\n    float intensity = max(dot(reflected, vec2(0.0, 1.0)), 0.0);\n    \n    // Return the reflection intensity, raised to the power of the gloss factor (for sharper highlights)\n    return pow(intensity, gloss);\n}\n\n// Function to create more complex sine wave patterns with additional layering\nfloat complexWavePattern(vec2 uv, float time) {\n    // Calculate a sine and cosine wave pattern based on the UV coordinates and time, creating a dynamic wave\n    float wave = sin(FREQ * (uv.x + sin(uv.y + time))) + cos(FREQ * (uv.y + cos(uv.x + time)));\n    \n    // Add a secondary sine wave layer with a phase shift (offset in time) for more complexity\n    wave += sin(FREQ * (uv.x + uv.y + time * 0.5)) * 0.5;\n    \n    // Add another layer of cosine waves for additional details\n    wave += cos(FREQ * (uv.y - uv.x + time * 0.7)) * 0.5;\n    \n    // Add a finer layer of sine waves to create small ripples or fine details\n    wave += sin(FREQ * 2.0 * (uv.x - uv.y + time * 1.0)) * 0.2;\n    \n    // Use the smoothstep function to smoothly clamp the wave values between -1.0 and 1.0, ensuring a smooth transition between high and low points\n    return smoothstep(-1.0, 1.0, wave);\n}\n\n// Function to create a serpentine texture with smoother, blended transitions\nvec3 complexSnakePattern(vec2 uv, float time) {\n    // Generate multiple wave layers with subtle phase shifts and blend them together for complexity\n    float wave1 = complexWavePattern(uv, time) * 0.5 + 0.5;  // First wave layer\n    float wave2 = complexWavePattern(uv + vec2(0.3, 0.2), time * 1.2) * 0.5 + 0.5;  // Second wave layer\n    float wave3 = complexWavePattern(uv + vec2(0.6, 0.4), time * 1.5) * 0.5 + 0.5;  // Third wave layer\n    \n    // Combine the wave layers to create a smooth hue value that will transition through the color spectrum\n    float hue = mod(time * 0.1 + wave1 + wave2 + wave3, 1.0);\n    \n    // Convert the hue, saturation, and brightness into an RGB color using the hsv2rgb function\n    vec3 color = hsv2rgb(hue, 0.8, 1.0);\n    \n    // Add specular highlights (simulating reflections) to the color\n    float specular = specularHighlight(uv, vec2(0.7, 0.7), 80.0);  // Simulate light reflection\n    color += vec3(1.0, 1.0, 1.0) * specular * REFLECTION_INTENSITY;  // Add white highlight based on reflection intensity\n    \n    // Smooth the color transitions by mixing the wave layers\n    vec3 smoothColor = mix(color, vec3(1.0, 0.7, 0.4) * wave2, 0.5);\n    \n    // Return the final color after all blending and reflection\n    return smoothColor;\n}\n\n// Main function for rendering the scene\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize the screen coordinates (fragCoord) to a range of [-1, 1]\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * SCALE - vec2(1.0);  // Scale the coordinates to control the size of the texture\n    \n    // Calculate the number of mirror segments dynamically by oscillating between MIN_MIRRORS and MAX_MIRRORS\n    float numMirrors = mix(MIN_MIRRORS, MAX_MIRRORS, 0.5 + 0.5 * sin(iTime * 0.5));\n    \n    // Apply the kaleidoscope effect by reflecting and rotating the UV coordinates based on dynamic numMirrors\n    uv = kaleidoscope(uv, numMirrors);\n    \n    // Calculate the current time for the animation\n    float time = iTime * SPEED;\n    \n    // Generate the final color for this pixel using the complex snake-like pattern with reflections and wave layers\n    vec3 color = complexSnakePattern(uv, time);\n    \n    // Output the final color to the screen (fragColor is the color of the current pixel)\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}