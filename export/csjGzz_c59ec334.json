{"ver":"0.1","info":{"id":"csjGzz","date":"1667153364","viewed":301,"name":"Quadratic Interpolation SDF","username":"kastorp","description":"Distance to a quadratic interpolation, using Iq [url=https://www.shadertoy.com/view/ws3GD7]parabola SDF[/url]\n\n[url=https://www.shadertoy.com/view/cdSGRh]here[/url] a raymarching use case","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","distance","parabola"],"hasliked":0,"parentid":"3lSczz","parentname":"Parabola Segment - distance 2D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Quadratic Interpolation SDF\n// see also https://www.shadertoy.com/view/wdjcz1 by Spalmer\n//-----------------\n\n//uncomment to use the appoximated algorithm\n//#define FAST \n\n//uncomment to use LINEAR interpolation\n//#define LINEAR\n\n//adaptation of  https://www.shadertoy.com/view/ws3GD7\nfloat sdParabola( in vec2 pos, in float wi1, float wi2,in float a,float b,float c )\n{\n    if(abs(a/(wi2-wi1))<0.001) { //almost linear\n       vec2 v1=vec2(wi1,c+b*wi1),v2=vec2(wi2,c+b*wi2);  \n       return length(pos- mix(v1, v2, clamp(dot(pos - v1, normalize(v2 - v1)) / length(v2 - v1), 0., 1.)));\n    }\n    float  e= -b/2./a,\n       he= c- a* e*e;\n       pos.x-=e;wi1-=e;wi2-=e;\n    float ik = -1./a;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = abs(pos.x)*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    float d=1e6;\n    float x;\n    if( h>0.0 ) // 1 root\n    {\n        float r = sqrt(h);\n        x = (pow(q+r,1.0/3.0) + pow(abs(q-r),1.0/3.0)*sign(p))*sign(pos.x); //always on same side of the point\n        x = clamp(x, wi1,wi2);\n        d =length(pos-vec2(x,he-x*x/ik));\n    }\n    else  // 3 roots\n    {\n        float r = sqrt(p);\n        x = 2.0*r*cos(acos(q/(p*r))/3.0); // see https://www.shadertoy.com/view/WltSD7 for an implementation of cos(acos(x)/3) without trigonometrics\n        \n        //two potential roots are symetric... try both, after clamping \n        float x2 = clamp(-x, wi1,wi2);\n               x = clamp(x, wi1,wi2);\n        \n        d=min(\n            length(pos-vec2(x,he-x*x/ik)),\n            length(pos-vec2(x2,he-x2*x2/ik))\n        );\n        //nb: the third solution is on the opposite side of the point\n        //it's the closest only if abs(a) is very small, which is excluded by the linear solution\n    }\n        \n    return d; \n}\n\n#define NMAX 10\n\n\n\n// interpolate an array of N heights, with x=[left, left+sz*(N-2)] \nfloat sdInterpolation(vec2 p,inout float[NMAX] y, float left,float sz,int N){\n    float  d=1e5, sg=1.;\n    float right=left+float(N-2)*sz;\n    for(int i=0;i<N-2;i++){   \n        float y0=y[i],y1=y[i+1],y2=y[i+2];\n        float c=(y0+y1)/2.,\n              b=(y1-y0)/sz,\n              a=(y0+y2-2.*y1)/2./sz/sz,\n              shift=float(i)*sz;\n#ifdef LINEAR        \n        a=0.; c=y0;\n#endif\n\n        vec2 pp=p-vec2(shift+left,0);\n        if(pp.x>0. && pp.x<sz && pp.y<c+pp.x*b+pp.x*pp.x*a) sg=-1.; //sign\n               \n#ifdef FAST       \n        float xx=clamp(p.x-shift-left,0.,sz),\n              yy=c+xx*b +xx*xx*a;            \n        d = min(d, length(p-vec2(xx+shift+left,yy)));\n#else        \n        d = min(d,sdParabola( pp,0., sz,a,b,c ));\n#endif        \n    }\n   \n    //vertical borders\n    d=min(d, length(p- vec2(right,y[N-1]) +vec2(0,1)*  clamp(vec2(right,y[N-1])-p.y  , 0., 1e6)));\n    d=min(d, length(p- vec2(left,y[0]) +vec2(0,1)*  clamp(vec2(left,y[0])-p.y, 0., 1e6)));\n    d*=sg;\n    return d;\n}\n\n#define st(x) sin(iTime*x)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = 3.*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = 3.*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    \n    float[10] y=float[NMAX]( st(0.),st(0.),st(1.)*2.,st(2.5),st(4.),st(5.),st(-3.),st(-1.)*2.,st(0.),st(0.));\n    \n    float d=sdInterpolation( p, y, -4.7,1.2,NMAX);\n    float dm= iMouse.z>0.001 ? sdInterpolation( m, y, -4.7,1.2,NMAX):1e5;\n     \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(1.0,1.1,1.2);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(50.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.03,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.01, abs(length(p-m)-abs(dm))-0.0075));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.01, length(p-m)-0.035));\n    }\n   \n\tfragColor = vec4(col,1.0);\n}\n ","name":"Image","description":"","type":"image"}]}