{"ver":"0.1","info":{"id":"3sjBDd","date":"1591150141","viewed":77,"name":"esferas test -v1","username":"jorge2017a1","description":"esferas test -v1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["esferastestv1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//por jorge2017a1-\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\tca, .0, -sa,\n\t\t.0, 1.0, .0,\n\t\tsa, .0, ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, ca, -sa,\n\t\t0.0, sa, ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\tca, -sa, 0.0,\n\t\tsa, ca, 0.0,\n\t\t0.0, 0.0, 1.0);\n}\n\n\n\n///-----------------------------------------\n\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n//-------------------------------------------------\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\nmat2 rotate(float a) \n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\n\n\n\nvec2 variasEsferasvec2(vec3 pp )\n{\n    #define num 20\n    vec2 distfin= vec2(1000.0,0);\n    vec3 mvz;\n    vec3 p;\n    \n    p=pp;\n    float t=mod( iTime,20.0);\n\n    p=rotate_y(p, t);\n    float ig;\n    \n    for(int i=0; i<num; i++) \n \t{   \n      \n      ig=float(i)*3.141516/180.0;\n      mvz.x= 2.0;\n      mvz.y= 4.0*sin(t *2.0*float( ig));  \n      mvz.z= 4.0*cos(t *1.0*float( ig))+2.0*cos(t*1.0);  \n        \n      float sdsp1= sdSphere(p-vec3(0.0+mvz.x, 5.0+mvz.y,mvz.z ), 0.75 );\n        \n      distfin=opU(distfin, vec2(sdsp1, i) );  \n\t}        \n    \n    return distfin;\n}\n\n\n\n//-----------------------------------------------------\n\nfloat GetDist(vec3 p  ) \n{\t\n\n    float d, dif1, dif2;\n    vec2 res;\n    vec3 pp, p2,p3;\n    \n   \n    pp=p;\n    p2=p;\n    p3=p;\n    \n \n    float planeDist1 = p.y+0.5;  //piso inf\n    float planeDist2 = 30.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared atras\n    float planeDist6 = p.z+40.0;  //pared atras\n   \n    \n    res = vec2(9999, 0);\n    \n    \n\tfloat n1= noise1(p.xz);\n    float n2= noise1(p.xy);\n    \n    \n    //res =opU(res, vec2(planeDist1+n1,140)); //inf\n    \n    if (iTime<5.0)\n        res =opU(res, vec2(planeDist1+n1,  6 )); //inf\n    else\n    \tres =opU(res, vec2(planeDist1+n1,  mod(iTime,140.0) )); //inf\n        \n    res =opU(res, vec2(planeDist2+n1,32)); \n    res =opU(res, vec2(planeDist3+n2,32)); \n    res =opU(res, vec2(planeDist4+n2,32)); \n    res =opU(res, vec2(planeDist5+n1,32)); \n    \n    \n    \n    vec2 ves2= variasEsferasvec2(p );\n    res =opU(res, ves2);\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n    \n    return d;\n}\n\n\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\t\n    // The extra distance might force a near-plane hit, so\n    // it's set back to zero.\n    float dO = 0.; \n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        \n        // The \"abs\" is a hack of sorts, but it forces the ray to hone in\n        // on the surface from either side. \"dS*dS<SURF_DIST*SURF_DIST\"\n        // would also work.\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n        \n        // This needs to be after the surface test. Otherwise, you could\n        // just the ray back out of range.\n        dO += dS;\n        // Ray shortening, for more accuracy, if you need it. It might be\n        // hacky, but it's necessary sometimes.\n        //dO += dS*.85; //  dS*.7, etc.\n    }\n    \n    return dO;\n}\n\n\n//---------------------------------------------------\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n\n// phong shading\nvec3 p_shadingv2( vec3 v, vec3 n, vec3 eye, vec3 plight_pos1,  vec3 plight_color1 )\n{\n\t\n\tfloat shininess = 16.0;\n    vec3 final = vec3( 0.0 );\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t\tvec3 vl = normalize( plight_pos1 - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\t\n        final += plight_color1 * ( diffuse + specular );\n\t\n    return (final);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    itime=iTime;\n    float t;\n    t=iTime*5.0;\n   \n    \n \n light_pos1   = vec3(-20.0, 10.0, -15.0 ); \n light_color1 = vec3( 1.0 );\n\n light_pos2   = vec3( 0.0, 15.0, 0.0 );\n light_color2 = vec3( 1.0, 1.0, 1.0 );\n //light_color2 = vec3( 0.65, 0.5, 1.0 );\n\n   \n    \n   \n    vec3 ro = vec3(10.0*cos(iTime),8.0,-20.0+10.0*sin(iTime));\n    //vec3 ro = vec3(0.0,5.0,-10.0);\n \t\n\tro = get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0));\n  \n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    mObj.p=p;\n    \n    float dif=0.8;\n  \n    \n    mObj.dist =d;\n    vec3 colobj;\n    \n    vec3 nor= GetNormal( p);\n    \n  \n    \n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n   float dif1=1.0;\n   \n    \n \t/*float dif1= GetLightPar(p,light_pos1);\n    dif1+= GetLightPar(p,light_pos2);\n     dif1= (dif1 )/2.0;\n    */\n    \n    \n    vec3 col2;\n\n   col2= p_shadingv2( p, nor, ro, light_pos1, light_color1 )*colobj;\n   col2+= p_shadingv2( p, nor, ro, light_pos2, light_color2 )*colobj;\n   col=col2/2.0*dif1;\n  \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n};\n\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n//-ooooooooooooooooooooooooooooooooooooooooooooooooooooo\n//https://www.shadertoy.com/view/XlBXWw\nvec2 hash22(vec2 p) { \n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n); \n    \n}\n\nfloat Voronoi(vec2 p)\n{\t\n    // Partitioning the 2D space into repeat cells.\n    vec2 ip = floor(p); // Analogous to the cell's unique ID.\n    p -= ip; // Fractional reference point within the cell (fract(p)).\n    float d = 1.;\n    \n    for (int i = -1; i <= 1; i++){\n\t    for (int j = -1; j <= 1; j++){\n\t    \n     \t    vec2 cellRef = vec2(i, j); // Base cell reference point.\n            \n            vec2 offset = hash22(ip + cellRef); // 2D offset.\n            \n            // Vector from the point in the cell to the offset point.\n            vec2 r = cellRef + offset - p; \n            float d2 = dot(r, r); // Squared length of the vector above.\n            \n            d = min(d, d2); // If it's less than the previous minimum, store it.\n        }\n    }\n    \n    // In this case, the distance is being returned, but the squared distance\n    // can be used too, if preferred.\n    return sqrt(d); \n}\n///oooooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n//----------------\n///https://www.shadertoy.com/view/wsjBD3\n\nfloat sdcirclevec2(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvec2 mod2(inout vec2 p, vec2 size) \n{\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 hashvec2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise1(vec2 p)\n{\n   const float cellWidth     = 1.0;\n  vec2 n = mod2(p, vec2(cellWidth));\n  vec2 hh = hashvec2(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n  \n  float r = 0.225*cellWidth;\n \n  float d = sdcirclevec2(p, 2.0*r);\n  \n  float h = hh.x*smoothstep(0.0, r, -d);\n\n  return h*0.25;\n}\n\n//--------------------------------\n    \n\n\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n\n\n//-------------------\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n\n\n\n\n///-----------------------------------------\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \nif (i==0 ) { return vec3( 128,0,0)/255.0; }\nif (i==1 ) { return vec3( 139,0,0)/255.0; }\nif (i==2 ) { return vec3( 165,42,42)/255.0; }\nif (i==3 ) { return vec3( 178,34,34)/255.0; }\nif (i==4 ) { return vec3( 220,20,60)/255.0; }\nif (i==5 ) { return vec3( 255,0,0)/255.0; }\nif (i==6 ) { return vec3( 255,99,71)/255.0; }\nif (i==7 ) { return vec3( 255,127,80)/255.0; }\nif (i==8 ) { return vec3( 205,92,92)/255.0; }\nif (i==9 ) { return vec3( 240,128,128)/255.0; }\nif (i==10 ) { return vec3( 233,150,122)/255.0; }\nif (i==11 ) { return vec3( 250,128,114)/255.0; }\nif (i==12 ) { return vec3( 255,160,122)/255.0; }\nif (i==13 ) { return vec3( 255,69,0)/255.0; }\nif (i==14 ) { return vec3( 255,140,0)/255.0; }\nif (i==15 ) { return vec3( 255,165,0)/255.0; }\nif (i==16 ) { return vec3( 255,215,0)/255.0; }\nif (i==17 ) { return vec3( 184,134,11)/255.0; }\nif (i==18 ) { return vec3( 218,165,32)/255.0; }\nif (i==19 ) { return vec3( 238,232,170)/255.0; }\nif (i==20 ) { return vec3( 189,183,107)/255.0; }\nif (i==21 ) { return vec3( 240,230,140)/255.0; }\nif (i==22 ) { return vec3( 128,128,0)/255.0; }\nif (i==23 ) { return vec3( 255,255,0)/255.0; }\nif (i==24 ) { return vec3( 154,205,50)/255.0; }\nif (i==25 ) { return vec3( 85,107,47)/255.0; }\nif (i==26 ) { return vec3( 107,142,35)/255.0; }\nif (i==27 ) { return vec3( 124,252,0)/255.0; }\nif (i==28 ) { return vec3( 127,255,0)/255.0; }\nif (i==29 ) { return vec3( 173,255,47)/255.0; }\nif (i==30 ) { return vec3( 0,100,0)/255.0; }\nif (i==31 ) { return vec3( 0,128,0)/255.0; }\nif (i==32 ) { return vec3( 34,139,34)/255.0; }\nif (i==33 ) { return vec3( 0,255,0)/255.0; }\nif (i==34 ) { return vec3( 50,205,50)/255.0; }\nif (i==35 ) { return vec3( 144,238,144)/255.0; }\nif (i==36 ) { return vec3( 152,251,152)/255.0; }\nif (i==37 ) { return vec3( 143,188,143)/255.0; }\nif (i==38 ) { return vec3( 0,250,154)/255.0; }\nif (i==39 ) { return vec3( 0,255,127)/255.0; }\nif (i==40 ) { return vec3( 46,139,87)/255.0; }\nif (i==41 ) { return vec3( 102,205,170)/255.0; }\nif (i==42 ) { return vec3( 60,179,113)/255.0; }\nif (i==43 ) { return vec3( 32,178,170)/255.0; }\nif (i==44 ) { return vec3( 47,79,79)/255.0; }\nif (i==45 ) { return vec3( 0,128,128)/255.0; }\nif (i==46 ) { return vec3( 0,139,139)/255.0; }\nif (i==47 ) { return vec3( 0,255,255)/255.0; }\nif (i==48 ) { return vec3( 0,255,255)/255.0; }\nif (i==49 ) { return vec3( 224,255,255)/255.0; }\nif (i==50 ) { return vec3( 0,206,209)/255.0; }\nif (i==51 ) { return vec3( 64,224,208)/255.0; }\nif (i==52 ) { return vec3( 72,209,204)/255.0; }\nif (i==53 ) { return vec3( 175,238,238)/255.0; }\nif (i==54 ) { return vec3( 127,255,212)/255.0; }\nif (i==55 ) { return vec3( 176,224,230)/255.0; }\nif (i==56 ) { return vec3( 95,158,160)/255.0; }\nif (i==57 ) { return vec3( 70,130,180)/255.0; }\nif (i==58 ) { return vec3( 100,149,237)/255.0; }\nif (i==59 ) { return vec3( 0,191,255)/255.0; }\nif (i==60 ) { return vec3( 30,144,255)/255.0; }\nif (i==61 ) { return vec3( 173,216,230)/255.0; }\nif (i==62 ) { return vec3( 135,206,235)/255.0; }\nif (i==63 ) { return vec3( 135,206,250)/255.0; }\nif (i==64 ) { return vec3( 25,25,112)/255.0; }\nif (i==65 ) { return vec3( 0,0,128)/255.0; }\nif (i==66 ) { return vec3( 0,0,139)/255.0; }\nif (i==67 ) { return vec3( 0,0,205)/255.0; }\nif (i==68 ) { return vec3( 0,0,255)/255.0; }\nif (i==69 ) { return vec3( 65,105,225)/255.0; }\nif (i==70 ) { return vec3( 138,43,226)/255.0; }\nif (i==71 ) { return vec3( 75,0,130)/255.0; }\nif (i==72 ) { return vec3( 72,61,139)/255.0; }\nif (i==73 ) { return vec3( 106,90,205)/255.0; }\nif (i==74 ) { return vec3( 123,104,238)/255.0; }\nif (i==75 ) { return vec3( 147,112,219)/255.0; }\nif (i==76 ) { return vec3( 139,0,139)/255.0; }\nif (i==77 ) { return vec3( 148,0,211)/255.0; }\nif (i==78 ) { return vec3( 153,50,204)/255.0; }\nif (i==79 ) { return vec3( 186,85,211)/255.0; }\nif (i==80 ) { return vec3( 128,0,128)/255.0; }\nif (i==81 ) { return vec3( 216,191,216)/255.0; }\nif (i==82 ) { return vec3( 221,160,221)/255.0; }\nif (i==83 ) { return vec3( 238,130,238)/255.0; }\nif (i==84 ) { return vec3( 255,0,255)/255.0; }\nif (i==85 ) { return vec3( 218,112,214)/255.0; }\nif (i==86 ) { return vec3( 199,21,133)/255.0; }\nif (i==87 ) { return vec3( 219,112,147)/255.0; }\nif (i==88 ) { return vec3( 255,20,147)/255.0; }\nif (i==89 ) { return vec3( 255,105,180)/255.0; }\nif (i==90 ) { return vec3( 255,182,193)/255.0; }\nif (i==91 ) { return vec3( 255,192,203)/255.0; }\nif (i==92 ) { return vec3( 250,235,215)/255.0; }\nif (i==93 ) { return vec3( 245,245,220)/255.0; }\nif (i==94 ) { return vec3( 255,228,196)/255.0; }\nif (i==95 ) { return vec3( 255,235,205)/255.0; }\nif (i==96 ) { return vec3( 245,222,179)/255.0; }\nif (i==97 ) { return vec3( 255,248,220)/255.0; }\nif (i==98 ) { return vec3( 255,250,205)/255.0; }\nif (i==99 ) { return vec3( 250,250,210)/255.0; }\nif (i==100 ) { return vec3( 255,255,224)/255.0; }\nif (i==101 ) { return vec3( 139,69,19)/255.0; }\nif (i==102 ) { return vec3( 160,82,45)/255.0; }\nif (i==103 ) { return vec3( 210,105,30)/255.0; }\nif (i==104 ) { return vec3( 205,133,63)/255.0; }\nif (i==105 ) { return vec3( 244,164,96)/255.0; }\nif (i==106 ) { return vec3( 222,184,135)/255.0; }\nif (i==107 ) { return vec3( 210,180,140)/255.0; }\nif (i==108 ) { return vec3( 188,143,143)/255.0; }\nif (i==109 ) { return vec3( 255,228,181)/255.0; }\nif (i==110 ) { return vec3( 255,222,173)/255.0; }\nif (i==111 ) { return vec3( 255,218,185)/255.0; }\nif (i==112 ) { return vec3( 255,228,225)/255.0; }\nif (i==113 ) { return vec3( 255,240,245)/255.0; }\nif (i==114 ) { return vec3( 250,240,230)/255.0; }\nif (i==115 ) { return vec3( 253,245,230)/255.0; }\nif (i==116 ) { return vec3( 255,239,213)/255.0; }\nif (i==117 ) { return vec3( 255,245,238)/255.0; }\nif (i==118 ) { return vec3( 245,255,250)/255.0; }\nif (i==119 ) { return vec3( 112,128,144)/255.0; }\nif (i==120 ) { return vec3( 119,136,153)/255.0; }\nif (i==121 ) { return vec3( 176,196,222)/255.0; }\nif (i==122 ) { return vec3( 230,230,250)/255.0; }\nif (i==123 ) { return vec3( 255,250,240)/255.0; }\nif (i==124 ) { return vec3( 240,248,255)/255.0; }\nif (i==125 ) { return vec3( 248,248,255)/255.0; }\nif (i==126 ) { return vec3( 240,255,240)/255.0; }\nif (i==127 ) { return vec3( 255,255,240)/255.0; }\nif (i==128 ) { return vec3( 240,255,255)/255.0; }\nif (i==129 ) { return vec3( 255,250,250)/255.0; }\nif (i==130 ) { return vec3( 0,0,0)/255.0; }\nif (i==131 ) { return vec3( 105,105,105)/255.0; }\nif (i==132 ) { return vec3( 128,128,128)/255.0; }\nif (i==133 ) { return vec3( 169,169,169)/255.0; }\nif (i==134 ) { return vec3( 192,192,192)/255.0; }\nif (i==135 ) { return vec3( 211,211,211)/255.0; }\nif (i==136 ) { return vec3( 220,220,220)/255.0; }\nif (i==137 ) { return vec3( 245,245,245)/255.0; }\nif (i==138 ) { return vec3( 255,255,255)/255.0; }\n\n    \n      \n    if(i== 139 )\n    {\n     \n           vec3 p = glpRoRd;\n           vec3 marbleP = p*2.0;\n    \n            marbleP.x += sin(p.y*0.5)*0.12;\n            marbleP.z += sin(p.y*2.0)*0.1;\n            marbleP.y += sin(p.x*5.0)*0.13;\n            marbleP.y += sin(p.z*3.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*10.0)*0.011;\n            marbleP.z += sin(p.y*12.0)*0.013;\n            marbleP.y += sin(p.x*15.0)*0.012;\n            marbleP.y += sin(p.z*13.0)*0.015;\n\n            marbleP.x *= 0.5;\n            marbleP.z *= 0.8;\n            marbleP.y *= 0.50;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 0.2;\n            marbleP.z *= 0.3;\n            marbleP.y *= 0.10;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if (i==140)\n    { \n        vec2 p=mObj.p.xz;\n        float vo= Voronoi(p);\n     \tvec3 col= mix( vec3(0.25, 0.25, 0.25)*vo, vec3(0.26,0.54,1.0),vo); \n        return col;\n    } \n    \n    \n    if (i==141)\n    { \n        vec2 p=mObj.p.xz;\n        float vo= Voronoi(p);\n        float no1= noise1(p);\n        vo=vo*no1*10.5;\n     \tvec3 col= mix( vec3(0.25, 0.25, 0.25)*vo, vec3(0.26,0.54,1.0),vo); \n        return col;\n    } \n\n\n}\n\n///--------------------------------------------\n\n","name":"Common","description":"","type":"common"}]}