{"ver":"0.1","info":{"id":"Xt2BDc","date":"1517424905","viewed":700,"name":"Understand noise","username":"marzinp","description":"Just a place to experiment some noise implementations... using Shane, IQ FabriceNeyret and other talented coders!","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash31( vec3 p ) {\n\tfloat h = dot(p,vec3(17, 1527, 113));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n//iq noise and derivatives\nvec4 noised( in vec3 p )\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    vec3 u = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);\n    vec3 du = 30.0*fp*fp*(fp*(fp-2.0)+1.0);\n\n    float a = hash31( ip+vec3(0,0,0) );\n    float b = hash31( ip+vec3(1,0,0) );\n    float c = hash31( ip+vec3(0,1,0) );\n    float d = hash31( ip+vec3(1,1,0) );\n    float e = hash31( ip+vec3(0,0,1) );\n    float f = hash31( ip+vec3(1,0,1) );\n    float g = hash31( ip+vec3(0,1,1) );\n    float h = hash31( ip+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( (k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tvec3 fp = p-ip; // Cell's fractional component.\n\t\n    // A bit of quintic smoothing, to give the noise that rounded look.\n\tfp = fp*fp*fp*(fp*(fp * 6. - 15.) + 10.);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), fp.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, fp.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, fp.z); // Range: [0, 1].\n\t\n}\nconst mat3 rot = mat3( 0.80,  0.60,0.0,-0.60,  0.80 ,0.0,0.0,0.0,1.0);\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\n// returns 3D fbm and its 3 derivatives\nvec4 fbm( in vec3 x, int octaves ) \n{\n    float f = 1.98;  // could be 2.0\n    float s = 0.49;  // could be 0.5\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i < octaves; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n    return vec4( a, d );\n}\nvec4 map(vec3 p){\n    \n    // One layer of noise at isolevel \"0.3\" - I have no idea whether that's the\n    // correct terminology. :)\n\n    return fbm(p*2.0,3) - .3;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n\t\n    // Unit direction ray. The last term is one of many ways to fish-lens the camera.\n    // For a regular view, set \"rd.z\" to something like \"0.5.\"\n    vec3 rd = normalize(vec3(uv,.5));//, (1.-dot(uv, uv)*.5)*.5)); // Fish lens, for that 1337, but tryhardish, demo look. :)\n    \n    // There are a few ways to hide artifacts and inconsistencies. Making things go fast is one of them. :)\n    // Ray origin, scene color, and surface postion vector.\n    vec3 ro = vec3(0., iTime*1.5, iTime*1.5), col=vec3(0), sp;\n\t\n    // Swivel the unit ray to look around the scene.\n    // Compact 2D rotation matrix, courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + iTime*0.375);\n    rd.xz = mat2(a, -a.y, a.x)*rd.xz;    \n    rd.xy = mat2(a, -a.y, a.x)*rd.xy;     \n    \n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    t = .2; \n    \n    // Surface distance threshold. Smaller numbers gives a thinner membrane, but lessens detail... \n    // hard to explain. It's easier to check it out for yourself.\n    float thD = .02; // + smoothstep(-0.2, 0.2, sin(iTime*0.75 - 3.14159*0.4))*0.025;\n \n\t\n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n\tfor(float i=0.; i<56.; i++)\t{\n        \n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers>20. || col.x > 1. || t>20.) break;\n        \n        // Current ray postion. Slightly redundant here, but sometimes you may wish to reuse\n        // it during the accumulation stage.\n        sp = ro+rd*t;\n        d = map(sp).x; // Distance to nearest point on the noise surface.\n        \n        // If we get within a certain distance of the surface, accumulate some surface values.\n        // Values further away have less influence on the total.\n        //\n        // aD - Accumulated distance. You could smoothly interpolate it, if you wanted.\n        //\n        // 1/.(1. + t*t*0.1) - Basic distance attenuation. Feel free to substitute your own.\n        \n         // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d)*23./24.)/thD;\n        \n        // If we're within the surface threshold, accumulate some color.\n        // Two \"if\" statements in a shader loop makes me nervous. I don't suspect there'll be any\n        // problems, but if there are, let us know.\n        if(aD>0.) { \n            \n            // Add the accumulated surface distance value, along with some basic falloff (fog, if \n            // you prefer) using the camera to surface distance, \"t.\" If you wanted, you could\n            // add a light, and use the light position to ray position distance instead.\n            // There's a bit of color jitter there, too.\n            \n            //col += aD*aD*(3.-2.*aD)/(1. + t*t*0.125)*.1 ;\n\n            col += vec3(aD/(1. + t*0.15)*.07,aD/(1. + t*t*0.1)*.07,aD/(1. + t*t*0.1)*.1);\n            \n            // The layer number is worth noting. Accumulating more layers gives a bit more glow.\n            // Lower layer numbers allow a quicker bailout. A lot of it is guess work.\n            layers++;  \n        }\n\n\t\t\n        // Kind of weird the way this works. I think not allowing the ray to hone in properly is\n        // the very thing that gives an even spread of values. The figures are based on a bit \n        // of knowledge versus trial and error. If you have a faster computer, feel free to tweak\n        // them a bit.\n        t += max(abs(d)*.7, thD*.7); \n        \n\t\t\t    \n\t}\n    \n    // Clamping \"col\" above zero, but just to be safe.\n    col = max(col, 0.);\n\n    \n\t// Presenting the color to the screen. Note that there's no gamma correction. It was a style\n    // choice - to give more contrast, but it's usually best to have it.\n\tfragColor = vec4( clamp(col, 0., 1.), 1.0 );\n    \n     \n }\n","name":"Image","description":"","type":"image"}]}