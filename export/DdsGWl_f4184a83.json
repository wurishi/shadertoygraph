{"ver":"0.1","info":{"id":"DdsGWl","date":"1666992885","viewed":181,"name":"AABB of Projected Spheres","username":"rnvannatta","description":"The analytically determined AABB of a sphere projected to screenspace. Spheres can project to ellipses, hyperbolas, or parabolas. This code solves for the aabb in the ellipse and hyperbola cases. For parabolas, the aabb is conservative.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","projection","aabb","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright Â© 2014-2022 Inigo Quilez & Richard Van Natta\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Based off of https://www.shadertoy.com/view/XdBGzd\n\n// Analytic axis-aligned bounding box of a sphere projected to the view plane.\n\n// Spheres in world space become conic sections when projected to the camera view plane. In fact, these\n// conics can be analytically determined from the camera parameters and the sphere geometry.\n// This means that, given a sphere and a camera and buffer resolution, we can derive the axis-aligned\n// bounding box of the projected sphere.\n\n// When the sphere is entirely in front of the z=0 plane, it projects into an ellipse or circle\n// When it is tangent to the z=0 plane, it projects into the worst conic: a parabola\n// When it crosses the z=0 plane, it projects into a hyperbola\n\n// Ellipses are very nice to work with, having simple bounding boxes, and a well behaved implicit function.\n\n// Hyperbolas are more annoying, as they have two lobes, of which we only care about one, and the bounding box\n// is infinite on some axes. Thier implicit function is still nice though.\n\n// Parabolas are awful, their implicit function is very ill behaved: specifically they don't have a 'center'\n// like ellipses and hyperbolas do on account of their discriminant being uninvertable. Luckily we can nudge a\n// parabola into a hyperbola by increasing the radius by an epsilon.\n\n// (yes you could consider the vertex or the focus a center, but it doesn't eliminate terms from the implicit,\n//  unless you're very lucky; it's possible that all parabolas constructed from projection are 'very lucky'. That would mean\n//  their [d e] coefficients of the implicit are linear combinations of the [a b/2] coefficents of the implicit. But it's almost\n//  surely more robust numerically to just bump things close to a parabola into a hyperbola; and I don't want to work\n//  with such yucky geometric objects. )\n\n// More info, here: https://iquilezles.org/articles/sphereproj\n\n// ---------------------------------------------------------------------------------------------\n#define LARGE 100000000.0\n\nstruct ProjectionResult\n{\n    vec2  center;    // x = u + center.x; y = v + center.y;\n    vec2  axisA;\n    vec2  axisB;\n    float discrim; // positive for ellipses, negative for hyperbolas\n    // au2 + buv + cv2 + w >= 0\n\tfloat a, b, c, w;\n    vec2 asymtote; // to exclude the superfluous lobe of the hyperbola\n    vec2 asymtote2; // only need 1, second is for debug visualization\n};\nstruct AABB\n{\n    vec2 mins;\n    vec2 maxs;\n};\nbool insideAABB(vec2 p, AABB aabb)\n{\n    return aabb.mins.x <= p.x && p.x <= aabb.maxs.x &&\n           aabb.mins.y <= p.y && p.y <= aabb.maxs.y;\n}\n\nAABB sphereAABB(in ProjectionResult sph)\n{\n    AABB ret = AABB(vec2(LARGE), vec2(-LARGE));\n    bool isEllipse = sph.discrim > 0.0;\n    {\n        {\n            // from setting the derivative in u = 0, we get u = -bv / 2a\n            // then we substitute into our implicit to solve for the extrema in v\n            float a = sph.b * sph.b / (4.0 * sph.a) - sph.b * sph.b / (2.0 * sph.a) + sph.c;\n            float b = 0.0;\n            float c = sph.w;\n            \n            float discrim = - 4.0 * a * c;\n            if(discrim >= 0.0)\n            {\n                float v = sqrt(discrim) / (2.0 * a);\n                \n                if(isEllipse)\n                {\n                    ret.mins.y = min(ret.mins.y, min(sph.center.y + v, sph.center.y - v));\n                    ret.maxs.y = max(ret.maxs.y, max(sph.center.y + v, sph.center.y - v));\n                }\n                else\n                {\n                    float u = - sph.b * v / (2.0 * sph.a);\n                    // make sure we have the correct lobe for the hyperbola, if not reverse the point\n                    if(dot(sph.asymtote, vec2(u, v)) < 0.0)\n                    {\n                        u *= -1.0;\n                        v *= -1.0;\n                    }\n                    float far = sign(v) * LARGE;\n                    \n                    ret.mins.y = min(ret.mins.y, min(sph.center.y + v, far));\n                    ret.maxs.y = max(ret.maxs.y, max(sph.center.y + v, far));\n                    \n                }\n            }\n            else\n            {\n                // a hyperbola which goes to positive & negative inf in this axis\n                ret.mins.y = -LARGE;\n                ret.maxs.y = LARGE;\n            }\n            // let v = -bu/2c and substitute in to get the extrema in u\n            a = sph.a - sph.b * sph.b / (2.0 * sph.c) + sph.b * sph.b / (4.0 * sph.c);\n            b = 0.0;\n            c = sph.w;\n            \n            discrim = - 4.0 * a * c;\n            if(discrim >= 0.0)\n            {\n                float u = sqrt(discrim) / (2.0 * a);\n                \n                if(isEllipse)\n                {\n                    ret.mins.x = min(ret.mins.x, min(sph.center.x + u, sph.center.x - u));\n                    ret.maxs.x = max(ret.maxs.x, max(sph.center.x + u, sph.center.x - u));\n                }\n                \n                else\n                {\n                    float v = - sph.b * u / (2.0 * sph.c);\n                    if(dot(sph.asymtote, vec2(u, v)) < 0.0)\n                    {\n                        u *= -1.0;\n                        v *= -1.0;\n                    }\n                    float far = sign(u) * LARGE;\n                    \n                    ret.mins.x = min(ret.mins.x, min(sph.center.x + u, far));\n                    ret.maxs.x = max(ret.maxs.x, max(sph.center.x + u, far));\n                    \n                }\n            }\n            else\n            {\n                // a hyperbola which goes to positive & negative inf in this axis\n                ret.mins.x = -LARGE;\n                ret.maxs.x = LARGE;\n            }\n        }\n        return ret;\n    }\n}\n\nProjectionResult projectSphere( /* sphere        */ in vec4 sph, \n\t\t\t\t                /* camera matrix */ in mat4 cam,\n\t\t\t\t\t\t\t    /* projection    */ in float fle )\n{\n    // transform to camera space\t\n\tvec3  o = (cam*vec4(sph.xyz,1.0)).xyz;\n\t\n    float r2 = sph.w*sph.w;\n\tfloat z2 = o.z*o.z;\t\n\tfloat l2 = dot(o,o);\n    \n    if(0.99 * z2 < r2 && r2 < 1.01 * z2)\n    {\n        // parabola detected: increase radius to force it to hyperbola\n        // parabolas have a zero discriminant, which is annoying\n        r2 = 1.01 * z2;\n    }\n    \n\t// center of the projected conic\n\tvec2  cen = fle*o.z*o.xy/(z2-r2);\n    \n    float a = r2 - o.y*o.y - z2;\n    float b = 2.0*o.x*o.y;\n    float c = r2 - o.x*o.x - z2;\n    float d = 2.0*o.x*o.z*fle;\n    float e = 2.0*o.y*o.z*fle;\n    float f = (r2-l2+z2)*fle*fle;\n    \n    float discrim = a*c - b*b/4.0;\n    \n    // shifting the conic by the center to eliminate the d & e terms\n    float w = a * cen.x * cen.x + b * cen.x * cen.y + c * cen.y * cen.y + d * cen.x + e * cen.y + f;\n    \n    vec2 asymtote;\n    vec2 asymtote2;\n    if(discrim < 0.0)\n    {\n       // substitute mx for y and look at limit as x->inf\n       // to get a + bm + cm^2 = 0\n       float discrim = b * b - 4.0 * a * c;\n       float slope = (-b + sqrt(discrim)) / (2.0 * c);\n       // the normal vector of the asymtote line\n       asymtote = vec2(-slope, 1);\n       \n       // the plane in worldspace the asymtote traces out\n       // the first is the ray the center goes from the eyepoint\n       // the second vector is the vector of the asymtote across the screen\n       vec3 asymtote3 = normalize(cross(vec3(cen.xy, fle), vec3(1, slope, 0)));\n       \n       if(dot(asymtote3, o) < 0.0f)\n         asymtote = -asymtote;\n           \n       slope = (-b - sqrt(discrim)) / (2.0 * c);\n       asymtote2 = vec2(-slope, 1);\n    }\n\t\n    //-- debug stuff ---\n\t\n\t// axis\n\tvec2 axa = fle*sqrt(-r2*(r2-l2)/((l2-z2)*(r2-z2)*(r2-z2)))*vec2( o.x,o.y);\n\tvec2 axb = fle*sqrt(-r2*(r2-l2)/((l2-z2)*(r2-z2)*(r2-l2)))*vec2(-o.y,o.x);\n\n\treturn ProjectionResult( cen, axa, axb, discrim, \n                     /* implicit ellipse f(x,y) = ax2 + bxy + cy2 + w = 0 */\n                     a,\n                     b,\n                     c,\n                     w,\n                     asymtote,\n                     asymtote2);\n\t\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat oSphere( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - max(0.0,dot(nor,di/l))*sph.w*sph.w/(l*l); \n}\n\nfloat ssSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 12.0*h/b );\n    }\n    return res;\n}\n\nfloat sdSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\nvec3 drawMaths( vec3 col, in ProjectionResult res, in vec2 p )\n{\n\n    float u = -res.center.x + p.x;\n    float v = -res.center.y + p.y;\n    float impl = res.a * u * u + res.b * u * v + res.c * v * v + res.w;\n    \n    AABB aabb = sphereAABB(res);\n    bool inside = insideAABB(p, aabb);\n    \n    if(inside) col = 0.8 * col + vec3(0.5, 0.5, 1.0);\n\t\n    float border = (1.0-smoothstep(0.00,0.10, abs(impl)));\n    // check for correct lobe on hyperbola\n    if(res.discrim < 0.0 && dot(vec2(u,v), res.asymtote) < 0.0) border = 0.0;\n\tcol = mix( col, vec3(1.0,0.0,0.0), border);\n    \n    if(res.discrim > 0.0)\n    {\n        col = mix( col, vec3(1.0,1.0,0.0), (1.0-smoothstep(0.00,0.01, sdSegment( res.center-res.axisA, res.center+res.axisA, p  )) ));\n        col = mix( col, vec3(1.0,1.0,0.0), (1.0-smoothstep(0.00,0.01, sdSegment( res.center-res.axisB, res.center+res.axisB, p  )) ));\n    }\n    \n    if(res.discrim < 0.0)\n    {\n        vec2 asymtote = normalize(res.asymtote);\n        col = mix( col, vec3(1.0, 1.0, 0.0), (1.0-smoothstep(0.00, 0.01, abs(dot(asymtote, vec2(u, v))))));\n        asymtote = normalize(res.asymtote2);\n        col = mix( col, vec3(1.0, 1.0, 0.0), (1.0-smoothstep(0.00, 0.01, abs(dot(asymtote, vec2(u, v))))));\n    }\n    \n\tcol = mix( col, vec3(1.0,0.0,0.0), (1.0-smoothstep(0.03,0.04, length(p-res.center))));\n\n\treturn col;\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    const float N = 10.0;\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return (1.0-i.x)*(1.0-i.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\t\n\tfloat fov = 1.0;\n\t\n\tfloat an = 12.0 + 0.5*iTime + 10.0*iMouse.x/iResolution.x;\n\tvec3 ro = vec3( 3.0*cos(an), 0.0, 3.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fov*ww );\n\tmat4 cam = mat4( uu.x, uu.y, uu.z, 0.0,\n\t\t\t\t\t vv.x, vv.y, vv.z, 0.0,\n\t\t\t\t\t ww.x, ww.y, ww.z, 0.0,\n\t\t\t\t\t -dot(uu,ro), -dot(vv,ro), -dot(ww,ro), 1.0 );\n\t\n\tvec4 sph1 = vec4(-2.0, 1.0,0.0,1.1);\n\tvec4 sph2 = vec4( 3.0, 1.5,1.0,1.2);\n\t//vec4 sph3 = vec4( 1.0,-1.0,1.0,1.3);\n\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\tvec3 sur = vec3(1.0);\n\tfloat h = iSphere( ro, rd, sph1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph1.xyz); \n\t\tocc = oSphere( pos, nor, sph2 ) /* oSphere( pos, nor, sph3 )*/;\n\t\tsur = vec3(1.0,0.7,0.2)*smoothstep(-0.6,-0.2,sin(20.0*(pos.x-sph1.x)));\n\t}\n\th = iSphere( ro, rd, sph2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph2.xyz); \n\t\tocc = oSphere( pos, nor, sph1 ) /* oSphere( pos, nor, sph3 )*/;\n\t\tsur = vec3(0.7,1.0,0.2)*smoothstep(-0.6,-0.2,sin(20.0*(pos.z-sph2.z)));\n\t}\n\t/*h = iSphere( ro, rd, sph3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph3.xyz); \n\t\tocc = oSphere( pos, nor, sph1 ) * oSphere( pos, nor, sph2 );\n\t\tsur = vec3(1.0,0.2,0.2)*smoothstep(-0.6,-0.2,sin(20.0*(pos.y-sph3.y)));\n\t}*/\n\th = (-2.0-ro.y)/rd.y;\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tocc = oSphere( pos, nor, sph1 ) * oSphere( pos, nor, sph2 ) /* oSphere( pos, nor, sph3 )*/;\n        sur = vec3(1.0)*gridTextureGradBox( pos.xz, dFdx(pos.xz), dFdy(pos.xz) );\n\t}\n\n\tvec3 col = vec3(0.0);\n\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n        col = vec3(1.0);\n\t\t\n\t\tvec3 lig = normalize( vec3(2.0,1.4,-1.0) );\n\t\tfloat sha = 1.0;\n\t\tsha *= ssSphere( pos, lig, sph1 );\n\t\tsha *= ssSphere( pos, lig, sph2 );\n\t\t//sha *= ssSphere( pos, lig, sph3 );\n\n\t\tfloat ndl = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\tcol = occ*(0.5+0.5*nor.y)*vec3(0.2,0.3,0.4) + sha*vec3(1.0,0.9,0.8)*ndl + sha*vec3(1.5)*ndl*pow( clamp(dot(normalize(-rd+lig),nor),0.0,1.0), 16.0 );\n\t\tcol *= sur;\n\t\t\n        col *= exp( -0.25*(max(0.0,tmin-3.0)) );\n\n\t}\n\n\tcol = pow( col, vec3(0.45) );\n\t\n\t//-------------------------------------------------------\n\t\n\tProjectionResult res = projectSphere( sph1, cam, fov );\n    col = drawMaths( col, res, p );\n\t\n\tres = projectSphere( sph2, cam, fov );\n    col = drawMaths( col, res, p );\n\t\n\t//res = projectSphere( sph3, cam, fov );\n    //col = drawMaths( col, res, p );\n\n\t//-------------------------------------------------------\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}