{"ver":"0.1","info":{"id":"lljcRw","date":"1508018612","viewed":160,"name":"Morphing Primitives","username":"Fading_Pixel","description":"A raymarcher that implements a function to morph the signed distance function between different primitives","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","primitives"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float EPSILON = 0.001;\nint MAX_STEPS = 100;\nfloat MAX_DIST = 100.0;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat boxSDF(vec3 p, vec3 size, float r) {\n    vec3 d = abs(p) - (size / 2.0) + r;\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance - r;\n}\n\nfloat cylSDF(vec3 p, float h, float r) {\n    float a = abs(p.y) - (h/2.0);\n    float b = length(p.xz)-r;\n    if (b > 0.0 && a > 0.0) {\n    \treturn length(vec2(a,b));\n    }\n    \n    return max(a,b);\n}\n\nfloat coneSDF(vec3 p, float h, float r) {\n    float r2 = ((h/2.0)-p.y)/h;\n    r2 *= r;\n    r2 = clamp(r2,0.0,r);\n    return cylSDF(p,h,r2);\n}\n\nfloat sphereSDF(vec3 p, float size) {\n    return length(p) - size;\n}\n\nfloat morph(float SDF1, float SDF2, float m) {\n    return SDF1 + ((SDF2-SDF1)*m);\n}\n\nfloat sceneSDF(vec3 p) {\n    float sdf = MAX_DIST;\n    float a = max(sphereSDF(p-vec3(2.0,0.0,0.0),1.0),boxSDF((p-vec3(2.0,0.0,0.0)),vec3(1.4,1.4,1.4),0.0));\n    float b = coneSDF(p-vec3(2.0,0.0,0.0),1.4,0.6);;\n    float c = morph(b,a,(1.0+sin(iTime))*0.5);\n    sdf = min(sdf,c);\n    a = min(sdf,boxSDF(rotateZ(p.y*cos(iTime))*(p+vec3(2.0,0.0,0.0)),vec3(1.4,1.4,1.4),0.2));\n    b = min(sdf,boxSDF(rotateY(p.y+sin(iTime*2.0))*(p+vec3(2.0,0.0,0.0)),vec3(1.4,1.4,1.4),0.2));\n    c = morph(a,b,(1.0+sin(iTime))*0.5);\n    sdf = min(sdf,c);\n    a = boxSDF(p,vec3(1.4,1.4,1.4),0.0);\n    b = cylSDF(p,1.4,0.6);\n    c = morph(a,b,(1.0+sin(iTime))*0.5);\n    sdf = min(sdf,c);\n    return sdf;\n}\n\nfloat March(vec3 Dir, vec3 eye) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sceneSDF(eye + (Dir*depth));\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 interp(vec3 a,vec3 b,float t) {\n    return a + ((b-a)*t);\n}\n\nvec3 Light(vec3 p, vec3 eye, vec3 Amb, vec3 Diff, vec3 Spec) {\n    float IntensitySpec = 0.4;\n    float IntensityDiff = 0.4;\n    float shine = 10.0;\n    vec3 source = vec3(sin(2.0*iTime)*3.0,cos(2.0*iTime)*3.0,sin(iTime)*cos(iTime)*4.0);\n    //source = vec3(0.0,0.0,0.0);\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(source - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    Amb = interp(N,Amb,(1.0+cos(iTime))/2.0);\n    vec3 col = Amb * 0.5;\n    if (dot(L,N) < 0.0) {\n        return col;\n    }\n    if (dot(R,V) < 0.0) {\n        col += (Diff * IntensityDiff * dot(L,N));\n        return col;\n    }\n    col += (Diff * IntensityDiff * dot(L,N));\n    col += (Spec * pow(dot(R,V),shine));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(sin(iTime)*5.0,cos(iTime)*5.0,6.5);\n    vec3 center = vec3(0.0,0.0,0.0);\n    vec3 up = vec3(0.0,1.0,0.0);\n    mat3 Matrix = viewMatrix(eye,center,up);\n    vec3 dir = rayDirection(45.0,iResolution.xy,fragCoord);\n    float mDist = March(Matrix * dir,eye);\n    vec3 point = eye + (mDist * (Matrix * dir));\n    vec3 light = Light(point, eye, vec3(0.5,0.0,0.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0));\n    if (mDist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    fragColor = vec4(light, 1.0);\n}","name":"Image","description":"","type":"image"}]}