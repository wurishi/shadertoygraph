{"ver":"0.1","info":{"id":"NsjXWt","date":"1621369212","viewed":358,"name":"Brownian Tree / Lichtenberg","username":"jolle","description":"Brownian Tree, but on hitting tree particle moves by most traveled path to seed, increasing intensity, giving an electric discharge / Lichtenberg figure look. New particles are continuously created randomly anywhere.\n\nCan click to add additional seed.","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["2d","random","tree","brownian","lightning","electric","walk","lichtenberg","discharge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Brownian Tree, but on hitting tree the particle moves by the most traveled path to seed,\n// increasing intensity along the way, giving an electric discharge / Lichtenberg figure look.\n//\n// New particles are continuously created randomly anywhere.\n//\n// You can click to add additional seed, or change starting seeds in function \"start\" (Buffer A)\n//\n// The result is slightly blurred, then rescaled and colorised.\n//\n// Some settings are available in Common.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / (iResolution.xy * displayScale);\n    fragColor = log(max(1.0, texture(iChannel0, uv).z * 0.2)) * vec4(1.0, 0.75, 2.0, 1.0) * 0.25;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uint hash(uint x)\n{\n    x = ((x >> 16u) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x) * 0x45d9f3bu;\n    x = (x >> 16u) ^ x;\n    return x;\n}\n\nuint hash(uvec3 u)\n{\n    return hash(u.z ^ hash(u.y ^ hash(u.x)));\n}\n\nuvec2 rngSeed;\n\nvoid initRng(vec2 p)\n{\n    rngSeed = uvec2(\n        hash(uvec3(iFrame, floatBitsToUint(p))),\n        hash(floatBitsToUint(vec3(p, iTime))));\n}\n\nuint rng()\n{\n    // Marsaglia's MWC\n    rngSeed = uvec2(36969u, 18000u) * (rngSeed & 65535u) + (rngSeed >> 16u);\n    return (rngSeed.x << 16u) + rngSeed.y;\n}\n\nfloat rngf()\n{\n\treturn uintBitsToFloat(rng() & 0x007FFFFFu | 0x3F800000u) - 1.0;\n}\n\nfloat lenSq(vec2 v)\n{\n    return dot(v, v);\n}\n\nbool inside(vec2 p)\n{\n    return p.x >= 0.0 && p.y >= 0.0 && p.x * displayScale < iResolution.x && p.y * displayScale < iResolution.y;\n}\n\nfloat start(vec2 p, int i)\n{\n    uint h = hash(uint(i + 2));\n    vec2 s = iResolution.xy / displayScale;\n    float w = 0.0;\n    if ((h & 0x00003u) == 0u) w += step(p.y, 1.0);\n    if ((h & 0x0000Cu) == 0u) w += step(abs(p.y - s.y), 1.0);\n    if ((h & 0x00030u) == 0u) w += step(p.x, 1.0);\n    if ((h & 0x000C0u) == 0u) w += step(abs(p.x - s.x), 1.0);\n    if ((h & 0x00100u) == 0u) w += step(lenSq(p - s * vec2(0.5, 1.0)), 4.0);\n    if ((h & 0x00200u) == 0u) w += step(lenSq(p - s * vec2(0.5, 0.0)), 4.0);\n    if ((h & 0x00400u) == 0u) w += step(lenSq(p - s * vec2(0.0, 0.0)), 4.0);\n    if ((h & 0x00800u) == 0u) w += step(lenSq(p - s * vec2(0.0, 1.0)), 4.0);\n    if ((h & 0x01000u) == 0u) w += step(lenSq(p - s * vec2(1.0, 0.0)), 4.0);\n    if ((h & 0x02000u) == 0u) w += step(lenSq(p - s * vec2(1.0, 1.0)), 4.0);\n    if ((h & 0x04000u) == 0u) w += step(lenSq(p - s * vec2(0.5, 0.5)), 1.0);\n    if ((h & 0x08000u) == 0u) w += step(lenSq(p - s * vec2(0.25, 0.5)), 1.0);\n    if ((h & 0x10000u) == 0u) w += step(lenSq(p - s * vec2(0.75, 0.5)), 1.0);\n    return w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (!inside(fragCoord))\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    if (iFrame % restartFrames == 0)\n    {\n        fragColor = vec4(vec3(0.0), start(fragCoord, iFrame / restartFrames));\n        return;\n    }\n\n    vec2 uvs = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * uvs;\n\n    vec4 s = texture(iChannel0, uv);\n\n    if (iFrame % restartFrames > restartFrames - fadeFrames)\n    {\n        fragColor = s * fadeMultiplier;\n        return;\n    }\n\n    if (iMouse.zw != vec2(0.0) && distance(iMouse.zw, fragCoord * displayScale) <= 1.0)\n        s.w = 1.0;\n\n    initRng(fragCoord);\n\n    vec2 flip = vec2(rngf() < 0.5 ? 1.0 : -1.0, rngf() < 0.5 ? 1.0 : -1.0);\n    vec2 dirs[] = vec2[](\n        vec2(-1.0, 1.0) * flip,\n        vec2( 1.0, 1.0) * flip,\n        vec2(-1.0,-1.0) * flip,\n        vec2( 1.0,-1.0) * flip,\n        vec2(-1.0, 0.0) * flip,\n        vec2( 1.0, 0.0) * flip,\n        vec2( 0.0, 1.0) * flip,\n        vec2( 0.0,-1.0) * flip);\n\n    vec4 ns[8];\n    for (int i = 0; i < dirs.length(); ++i)\n        ns[i] = texture(iChannel0, uv + dirs[i] * uvs);\n\n    vec4 n = vec4(0.0);\n    for (int i = 0; i < dirs.length(); ++i)\n        if (ns[i].xy == -dirs[i] && inside(fragCoord + dirs[i]))\n            n = ns[i];\n\n    if (n.xy == vec2(0.0) && rngf() > particleChance)\n    {\n        fragColor = vec4(0.0, 0.0, s.zw);\n        return;\n    }\n\n    if (s.w > 0.0)\n    {\n        fragColor = vec4(0.0, 0.0, s.z + 1.0, s.w);\n        return;\n    }\n\n    float mz = 0.0;\n    for (int i = 0; i < dirs.length(); ++i)\n        if (inside(fragCoord + dirs[i]))\n            mz = max(mz, ns[i].z);\n\n    if (mz == 0.0)\n    {\n        fragColor = vec4(dirs[min(int(rngf() * 9.0), 8)], s.zw);\n        return;\n    }\n\n    for (int i = 0; i < dirs.length(); ++i)\n        if (mz == ns[i].z && inside(fragCoord + dirs[i]))\n            fragColor = vec4(dirs[i], min(mz - 0.1, s.z + 1.0), s.w);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvs = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * uvs;\n\n    const float s0 = 0.075;\n    const float sd = s0 * 0.25;\n    fragColor = (\n        texture(iChannel0, uv) + \n        texture(iChannel0, uv + vec2(uvs.x, 0.0)) * s0 + \n        texture(iChannel0, uv + vec2(-uvs.x, 0.0)) * s0 + \n        texture(iChannel0, uv + vec2(0.0, uvs.y)) * s0 + \n        texture(iChannel0, uv + vec2(0.0, -uvs.y)) * s0 + \n        texture(iChannel0, uv + vec2(uvs.x, uvs.y)) * sd + \n        texture(iChannel0, uv + vec2(-uvs.x, uvs.y)) * sd + \n        texture(iChannel0, uv + vec2(uvs.x, -uvs.y)) * sd + \n        texture(iChannel0, uv + vec2(-uvs.x, -uvs.y)) * sd\n        ) / (1.0 + s0 * 4.0 + sd * 4.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float displayScale = 2.0;\nfloat particleChance = 0.015;\nint restartFrames = 800;\nint fadeFrames = 15;\nfloat fadeMultiplier = 0.8;\n","name":"Common","description":"","type":"common"}]}