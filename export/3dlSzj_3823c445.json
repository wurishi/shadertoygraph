{"ver":"0.1","info":{"id":"3dlSzj","date":"1551713634","viewed":508,"name":"Analytic Filtering of Bump Light","username":"fizzer","description":"Analytic filtering of wrap diffuse lighting from a bumpmap (directional light).\nBased on the observation that integrating the bumpmapped lighting is equivalent to integrating the gradient of the bumpmap, which is equivalent to sampling the bumpmap itself!","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["filter","light","bump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Here two samples of the bumpmap are made, to get the gradient in the direction\n// of the lightsource. This is equivalent to first getting the 2 partial derivatives and\n// taking the dot product of that vector with the light direction vector.\n//\n// This can also be thought of as an integration of the gradient (which is the dot product\n// and hence equivalent to diffuse wrap lighting term) over a line segment. The length of this\n// line segment is determined by the pixel footprint. It's a \"line sample\", so the filtering\n// ability is somewhere between a point sample and a box filter.\n//\n// This trick only works for wrapped diffuse thanks to the distributivity of the unclamped dot product.\n//\n// This example has been tweaked to make it look balanced. A specialy-prepared bumpmap texture\n// can produce an actual correct approximation of the integral.\n//\n\n// Ray-box intersection.\nvec2 box(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\nvec3 closestPointsOnLines(vec3 p0, vec3 v0, vec3 p1, vec3 v1)\n{\n    return inverse(mat3(v0, -v1, cross(v1, v0))) * (p1 - p0);\n}\n\nfloat lineMask(vec3 ro, vec3 rd, vec3 pa, vec3 pb, float r, float maxt)\n{\n    vec3 t = closestPointsOnLines(ro, rd, pa, pb - pa);\n\n    vec3 lp = mix(pa, pb, clamp(t.y, 0., 1.));\n\n    return step(distance(ro + rd * t.x, lp), r) * step(t.x, maxt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0., 0., 4.);\n\n    // Set up primary ray including differentials\n\n    vec3 rd = normalize(vec3(uv.xy, -2.));\n    vec3 rdx = rd + dFdx(rd);\n    vec3 rdy = rd - dFdy(rd);\n\n    bool hit = false;\n    vec3 closest_uvi = vec3(1e4), closest_s = vec3(0), closest_t = vec3(0);\n\n    int textureID = 0;\n    float shadow = 1.;\n\n    // Light direction\n    vec3 l = normalize(vec3(6., 7, 9.));\n\n    // Intersection with floor\n    float floor_i = (-2. - ro.y) / rd.y;\n\n    float crz = time / 2., crx = time / 5.;\n    \n    mat3 cube_o = mat3(cos(crz), sin(crz), 0.,\n                       -sin(crz), cos(crz), 0.,\n                       0., 0., 1.) *\n        \t\t\tmat3(1., 0., 0.,\n                         0., cos(crx), sin(crx),\n                       0., -sin(crx), cos(crx));\n    \n    vec3 lro = cube_o * ro;\n    vec3 lrd = cube_o * rd;\n    \n    vec3 ll = l;\n    \n    vec2 cube_i = box(lro, lrd, vec3(-1.), vec3(+1.));\n    \n    if(floor_i > 0.0 && (floor_i < cube_i.x || cube_i.x > cube_i.y))\n    {\n        // Ray hit the floor\n        vec3 rp = ro + rd * floor_i;\n\n        closest_s = vec3(1, 0, 0) * .1;\n        closest_t = vec3(0, 0, 1) * .1;\n\n        closest_uvi.x = dot(rp, closest_s) + time/10.;\n        closest_uvi.y = dot(rp, closest_t);\n        closest_uvi.z = floor_i;\n\n        textureID = 1;\n    }\n    \n    if(cube_i.x > 0. && (cube_i.x < floor_i || floor_i < 0.) && cube_i.x < cube_i.y)\n    {\n        // Ray hit the cube\n        vec3 rp = ro + rd * cube_i.x;\n\n\t\tvec3 lrp = lro + lrd * cube_i.x;\n        vec3 alrp = abs(lrp);\n        \n        vec3 n = step(alrp.yzx, alrp) * step(alrp.zxy, alrp) * sign(lrp);\n        \n        closest_s = transpose(cube_o) * n.yzx;\n        closest_t = transpose(cube_o) * n.zxy;\n\n        ll = transpose(mat3(closest_s, transpose(cube_o) * n, closest_t)) * l;\n        \n        closest_s = normalize(closest_s) * .8;\n        closest_t = normalize(closest_t) * .8;\n        \n        closest_uvi.x = dot(rp, closest_s);\n        closest_uvi.y = dot(rp, closest_t);\n        closest_uvi.z = cube_i.x;\n\n        textureID = 2;\n    }\n\n\n    if(textureID == 0)\n    {\n        // Background\n        fragColor.rgb = vec3(.1);\n    }\n    else\n    {\n        float u = closest_uvi.x;\n        float v = closest_uvi.y;\n        float i = closest_uvi.z;\n\n        vec3 closest_norm = normalize(cross(closest_s, closest_t));\n\n        // Ensure that the normal is forward-facing\n\n        if(dot(rd, closest_norm) > 0.)\n            closest_norm = -closest_norm;\n\n        // Use ray differentials to get intersection points for neighbouring pixels\n        // and transform them in to texture space for texture sampling.\n\n        vec3 rp = ro + rd * i;\n        vec3 rpx = ro + rdx * dot(rp - ro, closest_norm) / dot(rdx, closest_norm);\n        vec3 rpy = ro + rdy * dot(rp - ro, closest_norm) / dot(rdy, closest_norm);\n\n        vec2 duvx = vec2(dot(rpx - rp, closest_s), dot(rpx - rp, closest_t));\n        vec2 duvy = vec2(dot(rpy - rp, closest_s), dot(rpy - rp, closest_t));\n\n        // Texturing + Shading\n\n        vec3 c;\n        float e = uv.x < 0. ? 1. / 512. : max(max(abs(duvx.x), abs(duvy.y)), max(abs(duvy.x), abs(duvy.y)));\n\n        // Here two samples of the bumpmap are made as described at the top of this shader.\n\n        if(textureID == 1)\n        {            \n            float d = (textureLod(iChannel2, vec2(u, v) + ll.xz * e, 0.).r -\n                       textureLod(iChannel2, vec2(u, v) - ll.xz * e, 0.).r) / (e * 2.);\n            \n            c = clamp(vec3(.5 + .5 * (d / 50. + ll.y)), 0., 1.) * .75;\n        }\n        else if(textureID == 2)\n        {\n            float d = (textureLod(iChannel0, vec2(u, v) + ll.xz * e, 0.).r -\n                       textureLod(iChannel0, vec2(u, v) - ll.xz * e, 0.).r) / (e * 2.);\n            \n            c = clamp(vec3(.5 + .5 * (-d / 20. + ll.y)), 0., 1.);\n        }\n\n        vec3 diff = c;\n\n        fragColor.rgb = diff;\n    }\n\n    // Divider line\n    \n\tif(abs(uv.x) < 0.003)\n        fragColor.rgb = vec3(0);\n    \n    // Gamma correction\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"}]}