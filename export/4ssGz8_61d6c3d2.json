{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"music","id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// @eddbiddulph\n\n#define EPS vec3(0.001, 0.0, 0.0)\n\nfloat time;\nfloat freqs[4];\n\nvec3 rotateZ(vec3 v, float angle)\n{\n   return vec3(cos(angle) * v.x - sin(angle) * v.y,\n               cos(angle) * v.y + sin(angle) * v.x,\n               v.z);\n}\n\nvec3 rotateY(vec3 v, float angle)\n{\n   return vec3(cos(angle) * v.x - sin(angle) * v.z,\n               v.y,\n               cos(angle) * v.z + sin(angle) * v.x);\n}\n\nvec3 rotateX(vec3 v, float angle)\n{\n   return vec3(v.x,\n               cos(angle) * v.y - sin(angle) * v.z,\n               cos(angle) * v.z + sin(angle) * v.y);\n}\n\nfloat pulse(float e0, float e1, float x)\n{\n   return step(e0, x) - step(e1, x);\n}\n\nfloat square(vec2 v0, vec2 v1, vec2 p)\n{\n   vec2 o = (v0 + v1) * 0.5, s = abs(v1 - v0) * 0.5;\n   return length(max(vec2(0.0, 0.0), abs(p - o) - s)) - 0.001;\n}\n\nfloat circle(vec2 o, float r, vec2 p)\n{\n   return distance(p, o) - r;\n}\n\nfloat ellipse(vec2 o, vec2 r, vec2 p)\n{\n   vec2 e = (p - o) / r;\n   vec2 n = o + normalize(e) * r;\n   float d = distance(p, n);\n   \n   return mix(-d, +d, step(1.0, dot(e, e)));\n}\n\n// axis must be normalized\nfloat cylinder(vec3 o, vec3 axis, float r, float l, vec3 p)\n{\n   float d = dot(p - o, axis);\n   vec3 para = axis * d, perp = p - o - para;\n\n   return length(max(vec2(0.0), vec2(length(perp) - r, abs(d) - l * 0.5)));\n}\n\n// base of the slime is at (0.0, 0.0)\nfloat slimeProfile(vec2 p)\n{\n   float a = ellipse(vec2(0.0, 0.3), vec2(1.5, 1.0) * 0.3, p);\n   float b = square(vec2(0.0, 0.5), vec2(0.2, 0.94), p);\n   float c = ellipse(vec2(0.22, 0.9965), vec2(0.2, 0.43), p);\n   float d = ellipse(vec2(0.0, 0.94), vec2(0.02, 0.02), p);\n   return min(a, min(d, max(b, -c)));\n}\n\nvec2 union_(vec2 a, vec2 b)\n{\n   return mix(a, b, step(b.x, a.x));\n}\n\n// base of the slime is at (0.0, 0.0, 0.0)\n// stalk of slime points at +y\nfloat slimeBodyDistance(vec3 p)\n{\n\t// add some musical response!\n\t\n\tfloat g = (p.y - 0.7) * 5.0;\n\tfloat a = 0.0;\n\t\n\ta += max(0.0, 1.0 - abs(g - 0.5) * 2.0) * freqs[0];\n\ta += max(0.0, 1.0 - abs(g - 1.0) * 2.0) * freqs[1];\n\ta += max(0.0, 1.0 - abs(g - 1.5) * 2.0) * freqs[2];\n\ta += max(0.0, 1.0 - abs(g - 2.0) * 2.0) * freqs[3];\n\t\n\tp.y -= a * 0.6;\n\t\n\treturn slimeProfile(vec2(length(p.xz), p.y));\n}\n\nvec2 slimeEyesObjectBlack(vec3 p)\n{\n   // inner\n   float dist0 = min(cylinder(vec3(-0.1, 0.35, -0.38),\n                         normalize(vec3(0.23, -0.38, 1.0)),\n                         0.021, 0.11, p) - 0.01,\n                    cylinder(vec3(+0.1, 0.35, -0.38),\n                         normalize(vec3(-0.23, -0.38, 1.0)),\n                         0.021, 0.11, p) - 0.01);\n\n   // outer\n   float dist1 = min(cylinder(vec3(-0.1, 0.35, -0.38),\n                         normalize(vec3(0.23, -0.38, 1.0)),\n                         0.07, 0.09, p) - 0.01,\n                    cylinder(vec3(+0.1, 0.35, -0.38),\n                         normalize(vec3(-0.23, -0.38, 1.0)),\n                         0.07, 0.09, p) - 0.01);\n\n   return vec2(min(dist0, dist1), 3.0);\n}\n\nvec2 slimeEyesObjectWhite(vec3 p)\n{\n   float dist = min(cylinder(vec3(-0.1, 0.35, -0.38),\n                         normalize(vec3(0.23, -0.38, 1.0)),\n                         0.06, 0.1, p) - 0.01,\n                    cylinder(vec3(+0.1, 0.35, -0.38),\n                         normalize(vec3(-0.23, -0.38, 1.0)),\n                         0.06, 0.1, p) - 0.01);\n\n   return vec2(dist, 2.0);\n}\n\nvec2 slimeEyesObject(vec3 p)\n{\n   return union_(slimeEyesObjectBlack(p), slimeEyesObjectWhite(p));\n}\n\nvec2 slimeBodyObject(vec3 p)\n{\n   return vec2(slimeBodyDistance(p), 1.0);\n}\n\nfloat slimeMouth2DShapeDistance(vec2 p, float expansion)\n{\n   vec2 o = vec2(0.0, 0.47);\n\n   float a = max(0.0, max(-circle(o, 0.3, p),\n                 circle(o, 0.31, p)));\n   \n   // cutoff for first end\n   float cut0 = max(0.0, dot(p - o, normalize(vec2(2.0, 1.0))));\n\n   // cutoff for second end\n   float cut1 = max(0.0, dot(p - o, normalize(vec2(-2.0, 1.0))));\n\n   return max(0.0, length(vec3(a, cut0, cut1)) - expansion);\n}\n\nvec2 slimeMouthObjectRed(vec3 p)\n{\n   float plane_dist = -0.415;\n\n   vec3 rotcen = vec3(0.0, 0.2, plane_dist);\n   p = rotateX(p - rotcen, 0.4) + rotcen;\n\n   float a = abs(p.z - plane_dist);\n\n   float dist = length(vec2(a, slimeMouth2DShapeDistance(p.xy, 0.007))) - 0.0101;\n\n   return vec2(dist, 4.0);\n}\n\nvec2 slimeMouthObjectBlack(vec3 p)\n{\n   float plane_dist = -0.415;\n\n   vec3 rotcen = vec3(0.0, 0.2, plane_dist);\n   p = rotateX(p - rotcen, 0.4) + rotcen;\n\n   float a = abs(p.z - plane_dist);\n\n   float dist = length(vec2(a, slimeMouth2DShapeDistance(p.xy, 0.01))) - 0.01;\n\n   return vec2(dist, 3.0);\n}\n\nvec2 slimeMouthObject(vec3 p)\n{\n   return union_(slimeMouthObjectBlack(p), slimeMouthObjectRed(p));\n}\n\nvec3 slimeBodyNormal(vec3 p)\n{\n   float dist = slimeBodyDistance(p);\n   return normalize(vec3(slimeBodyDistance(p + EPS.xyz) - dist,\n                         slimeBodyDistance(p + EPS.zxy) - dist,\n                         slimeBodyDistance(p + EPS.yzx) - dist));\n}\n\nfloat toonDiffuse(vec3 n, vec3 l, vec3 v, float size, float interval)\n{\n\n   return clamp(1.0 - (acos(dot(n, l)) - size) / interval, 0.0, 1.0);\n}\n\n\nfloat toonSpecular(vec3 n, vec3 l, vec3 v, float size, float interval)\n{\n   vec3 h = normalize(l + v);\n\n   return clamp(1.0 - (acos(dot(n, h)) - size) / interval, 0.0, 1.0);\n}\n\nfloat traceSlimeBody(vec3 ro, vec3 rd)\n{\n   float t = 0.0;\n\n   for(int i = 0; i < 50; ++i)\n   {\n      float dist = slimeBodyDistance(ro + rd * t);\n\n      if(abs(dist) < 0.0001)\n         return t;\n\n      t += dist * 0.9;\n   }\n\n   return t;\n}\n\n\n\n// p must be within unit square centred at 0.5, 0.5\nvec3 slime(vec2 p, in vec3 incolor)\n{\n   p -= vec2(0.5);\n   p.y -= 0.18;\n\n   vec3 ro = vec3(0.0, 0.7, -1.5), rd = normalize(vec3(p.x, p.y, 1.0));\n\n   vec3 lp = vec3(1.0, 2.0, -2.0);\n\n   vec3 col = vec3(0.0);\n\n   vec2 rot = vec2(cos(time * 0.6 * 0.5) * 0.1 - 0.1, sin(time * 0.5) * 0.2);\n\n   ro = rotateX(rotateY(ro, rot.y), rot.x);\n   rd = rotateX(rotateY(rd, rot.y), rot.x);\n\n   lp = rotateX(rotateY(lp, rot.y), rot.x);\n\n   float t = 0.0;\n   vec2 hit;\n\n   for(int i = 0; i < 50; ++i)\n   {\n      vec3 p = ro + rd * t;\n\n      hit = union_(union_(slimeBodyObject(p), slimeMouthObject(p)), slimeEyesObject(p));\n\n      if(abs(hit.x) < 0.0001 || t > 4.0)\n         break;\n\n      t += hit.x * 0.9;\n   }\n\n\t// add a hacky shadow beneath the slime\n   col = mix(vec3(0.0, 0.0, 0.1), vec3(1.0), min(1.0, length((p - vec2(0.0, -0.5)) * vec2(1.0, 4.0))) * 1.5);\n\n   if(hit.y < 2.0)\n   {\n      float t0 = t;   \n      vec3 p0 = ro + rd * t0;\n   \n      if(t0 < 4.0)\n      {   \n         float t1 = traceSlimeBody(ro + rd * 5.0, -rd);\n         vec3 p1 = ro + rd * 5.0 - rd * t1;\n   \n         vec3 n0 = slimeBodyNormal(p0), l0 = normalize(lp - p0);\n         vec3 n1 = -slimeBodyNormal(p1), l1 = normalize(lp - p1);\n         vec3 v0 = ro - p0, v1 = ro - p1;\n   \n         float specfac0 = toonSpecular(n0, l0, v0, 0.1, 0.02);\n         float is0 = toonDiffuse(n0, l0, v0, 0.8, 0.02);\n   \n         float specfac1 = toonSpecular(n1, l1, v1, 0.1, 0.4);\n         float is1 = toonDiffuse(n1, l1, v1, 0.8, 0.4);\n         \n         vec3 diff = vec3(0.2, 0.2, 0.6) * 0.75, amb = diff * (0.8 + 0.2 * dot(l0, n0)),\n              spec = vec3(1.0, 1.0, 1.0);\n   \n         amb = mix(incolor * 0.3, amb, 1.3 * exp(-distance(p0, p1)));\n         diff = mix(incolor * 0.3, diff, 1.3 * exp(-distance(p0, p1)));\n   \n        vec3 scol = (amb + is0 * diff + specfac0 * spec) + 0.2 * (amb + is1 * diff + specfac1 * spec);\n\n         col = mix(col, scol, 0.8);\n   \n      }\n   }\n   else if(hit.y < 3.0)\n   {\n      col = vec3(1.0);\n   }\n   else if(hit.y < 4.0)\n   {\n      col = vec3(0.0);\n   }\n   else if(hit.y < 5.0)\n   {\n      col = vec3(0.5, 0.1, 0.1) * 0.6;\n   }\n\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfreqs[0] = texture( iChannel0, vec2( 0.1, 0.3 ).yx ).x * 0.2;\n\tfreqs[1] = texture( iChannel0, vec2( 0.2, 0.3 ).yx ).x * 0.2;\n\tfreqs[2] = texture( iChannel0, vec2( 0.3, 0.3 ).yx ).x * 0.5;\n\tfreqs[3] = texture( iChannel0, vec2( 0.4, 0.3 ).yx ).x * 0.7;\n\n\ttime = iTime;\n\tvec2 p = (fragCoord.xy / iResolution.xy - vec2(0.5)) * 2.0;\n\tp.x *= iResolution.x / iResolution.y;\n    fragColor = vec4(0.,0.,0.,1.);\n    fragColor.rgb = slime((p + vec2(1.0)) / 2.0, fragColor.xyz);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ssGz8","date":"1362517046","viewed":2246,"name":"Reactive Slime","username":"fizzer","description":"This is an old shader of mine which now uses the shadertoy FFT feature to make the slime 'react'.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","silly"],"hasliked":0,"parentid":"","parentname":""}}