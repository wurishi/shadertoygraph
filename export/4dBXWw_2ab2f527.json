{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n\nPorting the MIS path tracer to GLSL.\n\npart of ray marching code adpated from:\nhttps://www.shadertoy.com/view/4ssGzS\n\nJun 2014.10.4\n\n*/\n\n// some macros to make code compatible with CPP version\n#define IN_PARAM(_type) in _type\n#define OUT_PARAM(_type) out _type\n#define IN_OUT_PARAM(_type) inout _type\n#define SET_COL(_mat,_i,_col) (_mat)[_i]=(_col)\n#define make_float2 vec2\n#define make_float3 vec3\n#define make_float4 vec4\n#define INIT_MAT3 mat3\n\n///////////////////////////////////////////////////////////////////////////\n// main code\n\n#define GAMMA 2.2\n#define SPP 16\n#define INV_SPP 0.0625\n#define MAX_DEPTH 4\n    \n#define OBJ_COUNT 4\n#define OBJ_NONE -1.\n#define OBJ_VIRTUAL -2.\n#define OBJ_WALL 0\n#define OBJ_SBOX 1\n#define OBJ_TBOX 2\n#define OBJ_LIGHT 3\n\n#define EPS 5e-3\n#define RAY_MARCHING_MAX_ITER 128\n#define GRADIENT_DELTA 0.1\n    \n#define PI 3.14159\n#define INV_PI (1./PI)\n#define INV_2PI (0.5/PI)\n#define D2R(_d) ((_d)*PI/180.)\n\n// scene description\nconst float scene_scale=5500.;\nvec3 sbox_center=make_float3(175.,82.5,168.5);\nvec3 tbox_center=make_float3(368.5,165.,351.5);\nvec3 light_center=make_float3(556.*0.5,548.8,559.*0.5);\nvec3 sbox_halfsize=0.5*make_float3(165.);\nvec3 tbox_halfsize=0.5*make_float3(165.,330.,165.);\nvec3 light_halfsize=make_float3(65.,0.,52.5);\nmat3 sbox_w2o=INIT_MAT3(\n    0.953400, \t\t0,\t\t-0.285121,\n    0, \t\t\t\t1.,\t\t0,\n    0.301709,\t\t0.,\t\t0.958492);\nmat3 tbox_w2o=INIT_MAT3(\n    0.955649, \t\t0,\t\t0.301709,\n    0, \t\t\t\t1., \t0,\n    -0.294508, \t\t0, \t\t0.953400);\nvec3 box_mtl=make_float3(0.7,0.7,0.4);\n\n///////////////////////////////////////////////////////////////////////\n// helpers\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 dir;\n};\n    \nfloat seed;\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nfloat pdfA2W(float pdf_area,vec3 p,vec3 p_next,vec3 n_next)\n{\n\tvec3 w=p_next-p;\n\tfloat dist2=dot(w,w);\n\tw*=sqrt(dist2);\n\treturn pdf_area*dist2/(abs(dot(n_next,w)));\n}\n\nvec3 uniformHemisphere(float u1, float u2)\n{\n\tfloat r=sqrt(1.-u1*u1);\n\tfloat phi=2.*PI*u2;\n\treturn make_float3(r*cos(phi),r*sin(phi),u1);\n}\n\nvec3 l2w(vec3 l,vec3 normal)\n{\n\tvec3 binormal,tangent;\n\tif( abs(normal.x) > abs(normal.z) )\n\t{\n\t\tbinormal.x = -normal.y;binormal.y =  normal.x;binormal.z =  0.;\n\t}\n\telse\n\t{\n\t\tbinormal.x =  0.;binormal.y = -normal.z;binormal.z =  normal.y;\n\t}\n\tbinormal = normalize(binormal);\n\ttangent = cross( binormal, normal );\n\treturn l.x*tangent+l.y*binormal+l.z*normal;\n}\n\n///////////////////////////////////////////////////////////////////////\n// camera\n\nvec3 cam_origin=make_float3(272.691711, 277.386017, -760.679871);\nvec3 cam_target=make_float3(272.696594, 277.381134, -759.679871);\nvec3 cam_up=make_float3(0.,1.,0.);\nfloat cam_vfov=D2R(39.3077);\nmat3 cam_mat;// camera -> world\n\nvoid setupCamera()\n{\n\tvec3 n=normalize(cam_origin-cam_target);\n\tvec3 s=normalize(cross(cam_up,n));\n\tvec3 t=cross(n,s);\n\tSET_COL(cam_mat,0,s);\n\tSET_COL(cam_mat,1,t);\n\tSET_COL(cam_mat,2,n);\n}\n\nRay genRay(vec2 pixel)\n{\n\tvec2 iplane_size=2.*tan(0.5*cam_vfov)*make_float2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iplane_size;\n\tvec3 cam_dir=normalize(make_float3(ixy.x,ixy.y,-1.));\n\tvec3 world_dir=cam_mat*cam_dir;\n\tRay ray;\n\tray.dir=world_dir;\n\tray.origin=cam_origin;\t\n\treturn ray;\n}\n\n///////////////////////////////////////////////////////////////////////\n// intersection\n\nfloat udBox(vec3 p, vec3 b, vec3 ray_dir)\n{\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b, vec3 ray_dir)\n{\n    vec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 dist(int objId,vec3 p,vec3 ray_dir)\n{\n\tfloat d=scene_scale;\n\tfloat isvirtual=0.;\n\t\n\t// wall box\n\tif(objId==OBJ_WALL)\n\t{\n\t\tvec3 b=make_float3(550.*0.5);\n\t\tvec3 q=p-b;\n        if(q.z<-b.z-EPS) // get to -z face first\n\t\t{\n\t\t\td=-sdBox(q,b,ray_dir);\n\t\t\tisvirtual=1.;\n\t\t}\n\t\telse\n\t\t{\n\t\t\td=-sdBox(make_float3(q.xy,q.z+b.z),make_float3(b.xy,2.*b.z),ray_dir);\n\t\t}\n\t}\n\t// short box\n\telse if(objId==OBJ_SBOX)\n\t{\n\t\tvec3 q=sbox_w2o*(p-sbox_center);\t\t\n\t\td=udBox(q,sbox_halfsize,ray_dir);\n\t}\n\t// tall box\n\telse if(objId==OBJ_TBOX)\n\t{\n\t\tvec3 q=tbox_w2o*(p-tbox_center);\t\t\n\t\td=udBox(q,tbox_halfsize,ray_dir);\n\t}\t\t\n\t// light\n\telse if(objId==OBJ_LIGHT)\n\t{\n\t\tvec3 q=p-light_center;\n\t\td=-sign(q.y)*udBox(q,light_halfsize,ray_dir);\n\t}\n    \n\treturn make_float2(d,isvirtual);\n}\n\nfloat dist(int objId,vec3 p)\n{\n\treturn dist(objId,p,make_float3(0.)).x;\n}\n\nvec2 closestObj(vec3 p,vec3 ray_dir,float maxDist)\n{\n\tfloat dmin=maxDist;\n\tfloat hit_obj=OBJ_NONE;\n\tfor(int obji=0;obji<OBJ_COUNT;obji++)\n\t{\n\t\tvec2 hobj=dist(obji,p,ray_dir);\n\t\tfloat d=abs(hobj.x);\n\t\t\n\t\tif(d<dmin)\n\t\t{\n\t\t\tdmin=d;\n\t\t\thit_obj=(hobj.y==0.?float(obji):OBJ_VIRTUAL);\n\t\t}\n\t}\n\treturn make_float2(hit_obj,dmin);\n}\n\nvec2 closestObj(vec3 p)\n{\n\treturn closestObj(p,make_float3(0.),scene_scale);\n}\n\nvec3 gradNormal(int objId,vec3 p) {\n\tvec3 g=make_float3(\n\t\tdist(objId,p + make_float3(GRADIENT_DELTA, 0, 0)) - dist(objId,p - make_float3(GRADIENT_DELTA, 0, 0)),\n\t\tdist(objId,p + make_float3(0, GRADIENT_DELTA, 0)) - dist(objId,p - make_float3(0, GRADIENT_DELTA, 0)),\n\t\tdist(objId,p + make_float3(0, 0, GRADIENT_DELTA)) - dist(objId,p - make_float3(0, 0, GRADIENT_DELTA)));\n\n    return normalize(g);\n}\n\nbool ishit(vec2 cobj,float accum_dist,float eps,float maxDist)\n{\n\treturn (cobj.x!=OBJ_VIRTUAL&&\n\t\t(accum_dist>eps&&accum_dist<maxDist)\n\t\t&&cobj.y<eps);\n}\n\nfloat intersect(Ray ray,float minDist,float maxDist,OUT_PARAM(vec3) p)\n{\n\tp=ray.origin;\n\t\n\tfloat accum_dist=0.;\n\tvec2 cobj;\n\tbool ish=false;\n\n\tfor(int rmi=0;rmi<RAY_MARCHING_MAX_ITER;rmi++)\n\t{\n\t\tcobj=closestObj(p,ray.dir,maxDist-accum_dist);\n\t\t\n\t\taccum_dist+=cobj.y;\n\t\tp+=cobj.y*ray.dir;\n\n\t\tif(cobj.x==OBJ_NONE||(ish=ishit(cobj,accum_dist,minDist,maxDist)))\n\t\t\tbreak;\n\t}\n\t\n    return ish?cobj.x:OBJ_NONE;\n}\n\nfloat intersect(Ray ray,float minDist,float maxDist,OUT_PARAM(vec3) p,OUT_PARAM(vec3) normal)\n{\n\tfloat hit_obj=intersect(ray,minDist,maxDist,p);\n    if(hit_obj!=OBJ_NONE)\n        normal=gradNormal(int(hit_obj),p);\n\treturn hit_obj;\n}\n\nbool isShadowed(Ray ray,float minDist,float maxDist)\n{\n\tvec3 p;\n    return intersect(ray,minDist,maxDist,p)!=OBJ_NONE;\n}\n\n///////////////////////////////////////////////////////////////////////\n// light\n\nconst vec3 Lradiance=make_float3(28.4);\nconst float Lpdf=1./(130.*105.);\nvoid sampleLight(vec3 ref_p,OUT_PARAM(vec3) Lp,OUT_PARAM(vec3) Ln)\n{\n\tvec2 uv=make_float2(rnd(),rnd());\n\tLp=make_float3(213.,548.8,227.)+make_float3(uv.x*130.,0.,uv.y*105.);\n\tLn=make_float3(0.,-1.,0.);\n}\n\n///////////////////////////////////////////////////////////////////////\n// bsdf\n\nfloat bsdfPdf(vec3 w,vec3 n)\n{\n    return dot(w,n)>0.?INV_2PI:0.;\n}\n\nvec3 sampleBSDF(float objId,vec3 p,vec3 n)\n{\n\tvec3 dir=uniformHemisphere(rnd(),rnd());\n\treturn l2w(dir,n);\n}\n\nvec3 shade(int objId,vec3 p,vec3 n,Ray ray,int depth,IN_OUT_PARAM(vec3) alpha)\n{\n\tvec3 f=make_float3(0.);\n    if(objId==OBJ_WALL)\n    {\n        float x=0.5*(n.x+1.);\n        float y=abs(n.y)+abs(n.z);\n        f=make_float3(0.7*(1.-x+0.5*y),0.7*(x+0.5*y),0.4*y);\n    }\n    else if(objId==OBJ_SBOX||objId==OBJ_TBOX)\n    {\n        f=box_mtl;\n    }\n    else if(objId==OBJ_LIGHT)\n    {\n        f=make_float3(0.5);\n    }\n\t\n\tvec3 res=make_float3(0.);\n\tif(objId==OBJ_LIGHT)\n    {\n\t\tfloat wgt=1.;// if depth>=2&&not specular, do mis\n        if(depth>1)\n        {\n            float lgt_pdf=pdfA2W(Lpdf,ray.origin,p,n);\n            float bsdf_pdf=bsdfPdf(p-ray.origin,n);\n            wgt=(bsdf_pdf*bsdf_pdf)/(lgt_pdf*lgt_pdf+bsdf_pdf*bsdf_pdf);\n        }\n\t\tres=alpha*wgt*Lradiance;\n    }\n    else\n    {\n        vec3 Lp,Ln;\n        sampleLight(p,Lp,Ln);\n        Ray shadow_ray;        \n        shadow_ray.dir=normalize(p-Lp);\n        if(dot(shadow_ray.dir,Ln)>0.)\n        {\n            vec3 absp=abs(Lp);\n            shadow_ray.origin=Lp+EPS*max(max(absp.x,absp.y),absp.z)*shadow_ray.dir;\t// in case point is under the surface\n            float max_dist=(1.-EPS)*length(shadow_ray.origin-p);\n            bool shadowed=isShadowed(shadow_ray,EPS,max_dist);\n            if(!shadowed)\n            {\n                float g=abs(dot(shadow_ray.dir,n))*\n                        abs(dot(shadow_ray.dir,Ln))/(max_dist*max_dist);\n                float bsdf_pdf=bsdfPdf(Lp-p,Ln);\n                float lgt_pdf=pdfA2W(Lpdf,p,Lp,Ln);\n                float wgt=(lgt_pdf*lgt_pdf)/(lgt_pdf*lgt_pdf+bsdf_pdf*bsdf_pdf);\n                res=wgt*alpha*f*INV_PI*g*Lradiance/Lpdf;\n            }\n        }\n    }\n\talpha*=f; //!! actually *f should take place in sampleBSDF, but for diffuse, doesn't matter\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\t\n\tsetupCamera();\n\t\n\tvec3 res=make_float3(0.);\n\tfor(int si=1;si<=SPP;++si)\n    {\n\t\tvec3 alpha=make_float3(1.); // throughput\n\t\tRay ray=genRay(fragCoord.xy+make_float2(rnd(),rnd()));\n\t\t\n\t\tfor(int d=1;d<MAX_DEPTH;++d)\n\t\t{\n            vec3 p,n;\n\t\t\tfloat obj=intersect(ray,EPS,scene_scale,p,n);\n\t\t\tif(obj==OBJ_NONE)\n                break;\n\t\t\telse\n\t\t\t\tres+=shade(int(obj),p,n,ray,d,alpha);\n\n\t\t\tray.dir=sampleBSDF(obj,p,n);\n\t\t\talpha*=2.*abs(dot(ray.dir,n)); // correct the alpha, since we are uniform-sampling\n\t\t\tvec3 absp=abs(p);\n\t\t\tfloat eps=EPS*max(max(absp.x,absp.y),absp.z);\n\t\t\tray.origin=p+eps*ray.dir;\n\t\t}\n\t}\n    res = pow(res*INV_SPP, vec3(1. / GAMMA));\n\tfragColor=make_float4(res,1.); \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dBXWw","date":"1412435637","viewed":2217,"name":"YAPT","username":"jun","description":"Yet Another Path Tracer!!\nPath tracing the Cornell box, with multiple importance sampling.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pathtracing","mis"],"hasliked":0,"parentid":"","parentname":""}}