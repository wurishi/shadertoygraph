{"ver":"0.1","info":{"id":"4l3SWf","date":"1481736335","viewed":1271,"name":"Color Space and Tone Mapping","username":"acdimalev","description":"Reverse-engineering 2v_S's PBR_Test to learn how all the pieces fit together.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["tonemapping","colorspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* 2v_S's Physically Based Rendering Test\n* https://www.shadertoy.com/view/MlB3DV\n*\n* Modified to visually demonstrate color space conversion and tone mapping.\n*\n* Left: all rendering performed in sRGB space\n*\n* Middle: rendering performed in linear RGB space, converted to sRGB for display\n*\n* Right: tone mapping applied before conversion to sRGB for display\n*/\n\n\n#define NB_LIGHTS 3\n\n// Metals values in linear space\n#define GOLD vec3(1.0, 0.71, 0.29)\n#define COPPER vec3(0.95, 0.64, 0.54)\n#define IRON vec3(0.56, 0.57, 0.58)\n#define ALUMINIUM vec3(0.91, 0.92, 0.92)\n#define SILVER vec3(0.95, 0.93, 0.88)\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 srgb_to_linear(vec3 srgb) {\n    float a = 0.055;\n    float b = 0.04045;\n    vec3 linear_lo = srgb / 12.92;\n    vec3 linear_hi = pow((srgb + vec3(a)) / (1.0 + a), vec3(2.4));\n    return vec3(\n        srgb.r > b ? linear_hi.r : linear_lo.r,\n        srgb.g > b ? linear_hi.g : linear_lo.g,\n        srgb.b > b ? linear_hi.b : linear_lo.b);\n}\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 linear_to_srgb(vec3 linear) {\n    float a = 0.055;\n    float b = 0.0031308;\n    vec3 srgb_lo = 12.92 * linear;\n    vec3 srgb_hi = (1.0 + a) * pow(linear, vec3(1.0/2.4)) - vec3(a);\n    return vec3(\n        linear.r > b ? srgb_hi.r : srgb_lo.r,\n        linear.g > b ? srgb_hi.g : srgb_lo.g,\n        linear.b > b ? srgb_hi.b : srgb_lo.b);\n}\n\n// https://twitter.com/jimhejl/status/633777619998130176\nvec3 ToneMapFilmic_Hejl2015(vec3 hdr, float whitePt) {\n    vec4 vh = vec4(hdr, whitePt);\n    vec4 va = 1.425 * vh + 0.05;\n    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;\n    return vf.rgb / vf.www;\n}\n\nfloat splitFromFragCoord(vec2 fragCoord) {\n    return floor(3.0 * fragCoord.x / iResolution.x);\n}\n\nfloat fPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat fSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n// ---- Scene definition\nvec2 fScene(vec3 p) {\n    \n    vec3 pSphere = p/*opRep(p, vec3( 2.0, 0.0, 2.0))*/;\n    \n \tvec2 sphere0 = vec2(fSphere(p, 1.0), 0.5); \t\n    vec2 sphere1 = vec2(fSphere(p+vec3(2.1, 0.0, 2.0), 1.0), 2.5);\n\tvec2 sphere2 = vec2(fSphere(p+vec3(-2.1, 0.0, 2.0), 1.0), 3.5);\n    vec2 sphere3 = vec2(fSphere(p+vec3(2.1, 0.0, -2.0), 1.0), 4.5);\n    vec2 sphere4 = vec2(fSphere(p+vec3(-2.1, 0.0, -2.0), 1.0), 5.5);\n\t\n\n\n    vec2 plane = vec2(fPlane(p, vec4(0, 1, 0, 1.0)), 1.5);\n    \n    return opU(opU(opU(opU(opU(plane, sphere0), sphere1), sphere2), sphere3), sphere4);\n}\n// -----\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n    \n    \n\tfloat precis = 0.00001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = fScene( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = fScene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fScene(pos+eps.xyy).x - fScene(pos-eps.xyy).x,\n\t    fScene(pos+eps.yxy).x - fScene(pos-eps.yxy).x,\n\t    fScene(pos+eps.yyx).x - fScene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nstruct Light {\n \tvec3 pos;\n    vec3 color;\n};\nLight lights[NB_LIGHTS];\n\n\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\n\nvec3 computePBRLighting ( in Light light, in vec3 position, in vec3 N, in vec3 V, in vec3 albedo, in float roughness, in vec3 F0 ) {\n\n\tfloat alpha = roughness*roughness;\n\tvec3 L = normalize(light.pos.xyz - position);\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tvec3 F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\tvec3 specular = /*dotNL **/ D * F * vis;\n\n\tvec3 ambient = vec3(.01);\n\n\tfloat invPi = 0.31830988618;\n\tvec3 diffuse = (albedo * invPi);\n\n\n\treturn ambient + (diffuse + specular) * light.color.xyz * dotNL ;\n}\n\nvec3 addPBR( in vec3 position, in vec3 N, in vec3 V, in vec3 baseColor, in float metalMask, in float smoothness, in float reflectance, in float split) {\n\tvec3 color = vec3(0.0);\n\n    float roughness = 1.0 - smoothness*smoothness;\n    vec3 F0 = 0.16*reflectance*reflectance * (1.0-metalMask) + baseColor*metalMask;\n    vec3 albedo;\n    if (split == 0.0) {\n        albedo = linear_to_srgb(baseColor);\n    } else {\n        albedo = baseColor;\n    }\n    \n    float s = 0.0;\n    \n    \n\tfor ( int i = 0; i < NB_LIGHTS; ++i ) {\n\t\tvec3 col = computePBRLighting ( lights[i], position, N, V, albedo, roughness, F0);\n\t\tcolor += col;\t\n        s += softshadow( position, normalize(lights[i].pos.xyz - position), 0.02, 2.5 );\n\t}\n\n\treturn color*s;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float split )\n{\n    vec3 col = vec3(0.8, 0.9, 1.0)*8.0; // Sky color\n    \n    vec2 res = castRay( ro, rd );\n    float t = res.x;\n    float m = res.y;\n    vec3 p = ro + t*rd;\n    \n    if(m>-0.5) { // Intersection found\n        if( m < 1.0 ) {\n           // float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.6,sin(16.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        } \n        else if( m < 2.0 ) {\n            float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            col = addPBR(p, calcNormal( p ), -rd, vec3(0.5), 0.0, 0.3+0.6*f, 0.5, split );\n        }\n        else if( m < 3.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, COPPER*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n        else if( m < 4.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.0995,sin(106.0*p.x))*smoothstep(-1.0,-0.9,sin(47.0*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, vec3(0.2), 1.0-sur.x, 0.9*sur.x, 0.5, split );\n        }\n        else if( m < 5.0 ) {\n            vec3 sur = vec3(1.0)*smoothstep(-1.0,-0.765,sin(24.0*p.x))*smoothstep(-1.0,-0.4,sin(70.9*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*(1.0-sur), sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n        else if( m < 6.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, ALUMINIUM*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n    }\n    \n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 0.25*iTime;\n    \n    lights[0] = Light(vec3(0.0, 5.0, .0), vec3(1.0));   \n\tlights[1] = Light(vec3(12.0*sin(iTime), 8.0, 12.0*cos(iTime)), vec3(1.0));   \t\n    lights[2] = Light(vec3(-12.0*cos(-iTime), 8.0, 12.0*sin(-iTime)), vec3(.05));   \n\n   \n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\t\n\n\t// camera\t\n\tvec3 ro = vec3( 7.0*sin(time), 3.6 , -7.0*cos(time) );\n\tvec3 ta = vec3( 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n    \n    float split = splitFromFragCoord(fragCoord);\n    \n    // render\t\n    vec3 col = render( ro, rd, split );\n\n    #if 0\n        col = pow( col, vec3(0.4545) );\n        fragColor=vec4( col, 1.0 );\n    #else \n    \tfloat exposure = 0.06 + 0.02*sin(time-3.14);\n        if (split == 0.0) {\n            fragColor = vec4(col * exposure / 0.1, 1.0);\n        }\n        if (split == 1.0) {\n            fragColor = vec4(linear_to_srgb(col * exposure), 1.0);\n        }\n        if (split == 2.0) {\n            fragColor = vec4(linear_to_srgb(ToneMapFilmic_Hejl2015(col * exposure, 1.0)), 1.0);\n        }\n    #endif\n}","name":"Image","description":"","type":"image"}]}