{"ver":"0.1","info":{"id":"sst3Rn","date":"1629149399","viewed":312,"name":"Conway Ticket","username":"nr4","description":"This is the effect shown in \"Conway Ticket\" by NR4/Team210 and jeenio/Accession, shown (and second place) at Nevoke 2021 Tiny Demo Competition.\nPouet: https://www.pouet.net/prod.php?which=89607\n","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","game","intro","4k","demoscene","demo","life","conway"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy,\n        unit = 1./iResolution.xy;\n    \n    // SSAA\n    vec3 col = c.yyy;\n    float bound = sqrt(fsaa)-1.;\n    for(float i = -.5*bound; i<=.5*bound; i+=1.)\n        for(float j=-.5*bound; j<=.5*bound; j+=1.)\n            col += texture(iChannel1, uv+vec2(i,j)*3./max(bound, 1.)*unit).xyz;\n    col /= fsaa;\n\n    // edge glow\n    vec4 col11 = texture(iChannel1, uv - unit),\n        col13 = texture(iChannel1, uv + unit*c.xz),\n        col31 = texture(iChannel1, uv + unit*c.zx),\n        col33 = texture(iChannel1, uv + unit),\n        x = col33 -col11 -3.* texture(iChannel1, uv + unit*c.yz) -col13 + col31 + 3.*texture(iChannel1, uv + unit*c.yx),\n        y = col33 -col11 -3.* texture(iChannel1, uv + unit*c.zy) -col31 + col13 + 3.*texture(iChannel1, uv + unit*c.xy);\n    fragColor = vec4(mix(col, .5*(abs(y.rgb) + abs(x.rgb)).rgb, clamp(length(col)>.7?.2:0.,0.,1.)),1.);\n\n    // Vignette\n    uv *=  1. - uv.yx;\n    fragColor *= pow(uv.x*uv.y * 15., .2);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nfloat currentStateF(ivec2 index)\n{\n    return texelFetch(iChannel0, index, 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    stepTime = mod(iTime+.5*spb, spb)-.5*spb;\n    nbeats = (iTime-stepTime+.5*spb)/spb + smoothstep(-.2*spb, .2*spb, stepTime);\n    scale = smoothstep(-.3*spb, 0., stepTime)*smoothstep(.3*spb, 0., stepTime);\n    blockSize = 1.5/vec2(boardSize);\n    vec2 \n        uv = fragCoord/iResolution.xy,\n        unit = 1./iResolution.xy;\n    ivec2 index = ivec2(fragCoord);\n    vec2 x = 1.5*vec2(index-boardSize/2)/float(boardSize.y);\n    \n    float state = currentStateF(index),\n        hardBeats = round((iTime-stepTime)/spb),\n        d = 1.,\n        r = hash12(hardBeats*c.xx);;\n    \n    // Simulate\n    if(iTime >= currentStateF(boardSize*ci.yx) + stepTimeDelta)\n    {\n        int nNeighbours = 0,\n            colorSum = 0,\n            thisState = int(state);\n            \n        for(int i=-1; i<2; ++i)\n            for(int j=-1; j<2; ++j)\n            {\n                ivec2 otherIndex = index + ivec2(i,j);\n                \n                if(j==0 && i==0) continue;\n                \n                int otherState = int(currentStateF(otherIndex));\n                if(otherState != 0)\n                {\n                    ++nNeighbours;\n                    colorSum += otherState;\n                }\n            }\n        colorSum = int(round(float(colorSum)/float(nNeighbours)));\n        \n        if(thisState != 0 && (nNeighbours == 2 || nNeighbours == 3));\n        else if(thisState == 0 && nNeighbours == 3)\n            state = float(colorSum);\n        else state = 0.;\n        \n        // Serialize\n        state = setStateF(index, boardSize*ci.yx, state, iTime);\n    }\n    \n    // Spawn exploder if beat\n    if(scale >= .7)\n    {\n        if(int(round(mod(hardBeats,2.))) == 0)\n        {\n            int coordinates[20] = int[20](\n                        1, 0, \n                    0,-1,       2,-1,\n             -1,-2, 0,-2,       2,-2, 3,-2,\n                    0,-3,       2,-3,\n                        1,-4\n            );\n            \n            for(int i=0; i<20; i+=2)\n                state = setStateF(index + ivec2(coordinates[i], coordinates[i+1]), ivec2(.9*vec2(hash12(hardBeats*c.xx),hash12(hardBeats*c.xx+.1))*vec2(boardSize)), state, 2.);\n        }\n        else\n        {\n            ivec2 da = ivec2(mod(vec2(index), 2.));\n            if(da.x == 0)\n            {\n                if(r < .1)\n                    d = abs(dstar(x, 5., vec2(.2,.5)))-.05;\n                else if(r < .4)\n                    d = abs(length(x)-.4)-.09;\n                else if(r < .5)\n                    d = abs(dbox3(vec3(x+x.yx*c.xz,0), .4*c.xxx))-.09;\n                else if(r < .55)\n                    d = d210(x);\n                else if(r < .7)\n                    d = abs(dhexagonpattern(5.*x)/5.)-.05;\n                else if(r < .8)\n                    d = abs(mod(x.x, .2)-.1+abs(x.y)-.4)-.05;\n                else state = 0.;\n\n                if(d < 0.)\n                    state = 4.+round(4.*hash12(hardBeats*c.xx+.2));\n                if(abs(d)-.01 < 0.)\n                    state = 1.;\n            }\n        }\n    }\n\n    fragColor.r = state;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nfloat currentStateF(ivec2 index)\n{\n    return texelFetch(iChannel0, index, 0).r;\n}\n\nvec3 scene(vec3 x)\n{\n    vec2 y = mod(x.xy, blockSize)-.5*blockSize;\n    xij = (x.xy-y)/blockSize + vec2(1,.85)*vec2(boardSize / 2);\n    int state = int(currentStateF(ivec2(xij)));\n    \n    vec3 sdf = vec3(0, x.z+.5*blockSize.x-.001*smoothstep(1.5/iResolution.y, -1.5/iResolution.y, dbox3(y.xyx, .3*blockSize.xyx)-.15*blockSize.x), .3);\n\n    return int(xij.x) < boardSize.x && int(xij.y) < boardSize.y\n        && \n        state != 0 \n        ? add(sdf, vec3(state, dbox3(vec3(y,x.z), .3*blockSize.xyx)-.15*blockSize.x, .7))\n        : sdf;\n}\n\nbool ray(inout vec3 col, out vec3 x, float d, vec3 dir, out vec3 s, vec3 o, vec3 l, out vec3 n)\n{\n    for(int i=0; i<250; ++i)\n    {\n        x = o + d * dir;\n        s = scene(x);\n        \n        if(x.z > .51*blockSize.x) break;\n        \n        if(s.y < 1.e-4)\n        {\n            // Blinn-Phong Illumination\n            float dx = 5.e-5;\n            n = normalize(vec3(\n                scene(x+dx*c.xyy).y, \n                scene(x+dx*c.yxy).y, \n                scene(x+dx*c.yyx).y\n            )-s.y);\n\n            if(s.x == 0.)\n                col = .1*c.xxx;\n            else {\n                vec3 colors[8] = vec3[8](\n                    .7*c.xxx,\n                    vec3(.20,.23,.27),\n                    vec3(.35,.57,.97),\n                    vec3(.18,.18,.18),\n                    vec3(.83,.15,.17),\n                    vec3(.94,.65,.07),\n                    vec3(.85, 1, .20),\n                    vec3(.23, .46, .24)\n                );\n                float i = mod(floor(s.x), 8.),\n                    ip1 = mod(i + 1., 8.);\n                col = 1.5*mix(colors[int(i)], colors[int(ip1)], fract(s.x))-.1*hash12(xij);\n                col = mix(col, col+col*col+col*col*col, scale);\n            }\n\n            col = .2 * col\n                + col*max(dot(normalize(l-x),n),0.)\n                + .7 * col*pow(max(dot(reflect(normalize(l-x),n),dir),0.),2.);\n                \n            return true;\n        }\n        d += min(s.y,1.e-3);\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    stepTime = mod(iTime+.5*spb, spb)-.5*spb;\n    nbeats = (iTime-stepTime+.5*spb)/spb + smoothstep(-.2*spb, .2*spb, stepTime);\n    scale = smoothstep(-.3*spb, 0., stepTime)*smoothstep(.3*spb, 0., stepTime);\n    blockSize = 1.5/vec2(boardSize);\n    vec2 uv = fragCoord/iResolution.xy,\n        unit = 1./iResolution.xy;\n    ivec2 index = ivec2(fragCoord);\n    \n    vec2 uv1 = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 \n        o = c.yzx,\n        col,\n        c1,\n        x,\n        x1,\n        n,\n        dir = normalize(uv1.x * c.xyy + uv1.y * cross(c.xyy,normalize(-o))-o),\n        l = c.zzx-.5*c.yyx,\n        s,\n        s1;\n        \n    // Material ray\n    if(ray(col, x, -(o.z-.5*blockSize.x)/dir.z, dir, s, o, l, n))\n    {\n        // Reflections\n        if(ray(c1, x1, 2.e-3, reflect(dir,n), s1, x, l, n))\n            col = mix(col, c1, s.z);\n\n        // Hard Shadow\n        if(ray(c1, x1, 1.e-2, normalize(l-x), s1, x, l, n) && length(l-x1) < length(l-x))\n            col *= .5;\n    }\n\n    col *= 1.3;\n\n    // Color drift\n    if(s.x != 0.)\n        col = mix(col, hsv2rgb(vec3(pi*lfnoise(.1*nbeats/*c.xx*/), rgb2sv(col))),.5);\n\n    fragColor = mix(texture(iChannel1, uv), vec4(clamp(col,0.,1.),1.), .5);\n}","name":"Buffer B","description":"","type":"buffer"}]}