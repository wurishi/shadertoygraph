{"ver":"0.1","info":{"id":"XtGfDR","date":"1542818191","viewed":430,"name":"Dancing Chequerboard","username":"_polymath","description":"squares that do things, nothing fancy but i like it","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float cellSize = 0.1, sceneTime = 3.;\n\nvec2 rotate(vec2 p, float theta) {\n\tfloat s = sin(theta), c = cos(theta);\n    return vec2(\n    \tp.x * c + p.y * s,\n    \tp.y * c - p.x * s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / (iResolution.y + iResolution.x) / cellSize;\n\n    vec4 back = vec4(.8, 0., 0., 1.);\n    vec4 fore = vec4(.4, 0., 0., 1.);\n    \n    float bigTime = mod(iTime / sceneTime, 4.),\n        smallTime = fract(bigTime);\n    \n    // swap the cells\n    if (bigTime >= 2.) {\n        vec4 temp = back; back = fore; fore = temp;\n        uv.x -= .5;\n    }\n\n    // divide the world into diagonal squares for rotating\n    vec2 ab = fract(vec2(uv.x + uv.y, uv.x - uv.y)) * 2. - 1.;\n    // the squares are anywhere from 0..1 in x or y of ab\n        \n    if (mod(bigTime, 2.) >= 1.)\n        // rotate the squares\n        ab = rotate(ab, 3.1415927 / 2. * smoothstep(0., 1., smallTime));\n    \n    // the squares are anywhere from 0..1 in x or y of ab, remember!\n    if (ab.x + ab.y < 1. && ab.x + ab.y > -1. &&\n       ab.x - ab.y < 1. && ab.x - ab.y > -1.)\n        fragColor = fore;\n    else\n        fragColor = back;\n    \n    //fragColor = vec4(abs(ab), 0., .99);\n\n    // Output to screen\n    //fragColor = back;\n}","name":"Image","description":"","type":"image"}]}