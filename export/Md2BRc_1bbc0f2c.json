{"ver":"0.1","info":{"id":"Md2BRc","date":"1501559085","viewed":128,"name":"[SH17C] Basic Kolakoski","username":"Sheado","description":"Inspired by this Numberphile video: https://www.youtube.com/watch?v=co5sOgZ3XcM\nI ran out of time working on this. I really wanted to implement concentric Kolakoski sequences which would show interesting patterns. \n\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sequence","kolakoski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * The Kolakoski sequence: 1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, ... \n * \t\tIt's a self generating sequence.\n * Inspired by this Numberphile video: https://www.youtube.com/watch?v=co5sOgZ3XcM\n * References I used:\n *\t \tMore details: https://oeis.org/A000002\n * \t\tAnd a tutorial: https://www.easycalculation.com/learn-kolakoski-sequence.php \n */\n#define PI 3.14159265358979323846\n#define K 15\n\nvoid kolakoski(out int[K] v)\n{\n    v[0] = 1;\n    v[1] = 2;\n    v[2] = 2;\n    int s = 2;\n    int end = 3;\n    for( int i = 3; i < K; ++i )\n    {\n        int jj = v[i-1];\n        for( int j = 1; j <= jj; ++j )\n        {\n            s = 1 + ((i-1)%2);\n            if( end < K )\n            {\n                v[end] = s;\n                ++end;\n            }\n        }\n    }\n}\n\n\nvec2 rotate2d(in vec2 st, float _angle){\n    st -= .5;\n    mat2 m = mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n    st = m * st;\n    st += .5;\n    return st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= aspect;\n    float radius = .5;\n    vec2 center = vec2(.5*aspect,.5);\n    vec3 color = vec3(0);\n\n    // rotation hack\n    uv = rotate2d(uv,PI*.25);\n    center = rotate2d(center,PI*.25);\n\n    // TODO - implement multiple concentric layers\n    //for( int i = 4; i >= 0; --i )\t\t\n    {\n        float d = distance(uv,center);  \n        if( d < radius )\n        {\n            int v[K];\n            kolakoski(v);\n            float segments = float(K);\n            float circumferenceRatio = 1.5*PI;\n            float offsetAngle = 0.;\n            int z = 1+int(float(K-1)*abs(sin(iTime*.5)));\t// simple animation\n            for( int i = 0; i < z; ++i )\n            {\n                float angle = atan(uv.x-center.x,uv.y-center.y) + PI*0.5 + offsetAngle;\n                float currentSegmentAngle = (circumferenceRatio)/segments;\n                if( v[i] != 1 )\n                    currentSegmentAngle *= 2.;\n                offsetAngle -= currentSegmentAngle;\n\n                if( angle > 0.01 && angle < currentSegmentAngle-.01 )\n                {\n                    if( v[i] == 1 )\n                        color = vec3(0.,radius,1.) ;\n                    else\n                        color = vec3(1.,0.,radius) ;\n                    break;\n                }\n            }\n        }\n        radius -= .1;\n    }\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}