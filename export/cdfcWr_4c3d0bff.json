{"ver":"0.1","info":{"id":"cdfcWr","date":"1686693037","viewed":73,"name":"Metaballs RayMarching","username":"rgbGuy","description":"sdf metaballs raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://www.youtube.com/watch?v=PGtv-dBi2wE Followed this amazing tutorial and a few other blogs\nint MAX_STEPS = 100;\nfloat SURFACE_DIST = 0.01;\nfloat MAX_DIST = 100.;\n\nfloat smoothMax(float a, float b, float k)\n{\n    return log(exp(k*a) + exp(k*b))/k;\n}\n\n\nfloat smoothMin(float a, float b, float k)\n{\n    return -smoothMax(-a,-b,k);\n\n}\nvec4 boxSDF(vec3 p, vec3 R)\n{\n    vec3 boxpos = vec3(3, 0.04 + sin(iTime), 5);\n    vec3 boxCol = vec3(0, 2.0, 1.4);\n    float sdf = length(max(abs(p - boxpos) - R, 0.0));\n    return vec4(boxCol, sdf);\n}\n\nvec4 lineSDF(vec3 p, vec3 a, vec3 b, float R)\n{\n    float h = min(1.0, max(0.0, dot(p-a, b-a)/dot(b-a, b-a)));\n    vec3 col = vec3(2,1,2);\n    return vec4(col,h*h*h*sin(2.*iTime)/2. + length(p-a - (b-a)*h) - R);\n}\n\n\nvec4 sphereSDF(vec3 c, float r, vec3 p)\n{\n    float d = length(c-p);\n    vec3 col = vec3(0, 2, 0);\n    return vec4(col, d - r);\n}\n\nvec4 flatPlaneSDF(vec3 p)\n{ \n    //considering plane at y = -1\n    float grid = cos(5.*p.z)*sin(5.*p.x);\n    float col = smoothstep(0.,0.0001, grid)/3.;\n    return vec4(col, col, col, p.y + 1.0);\n}\n\nvec4 findMin(vec4 a, vec4 b)\n{\n    vec3 col;\n    if(a.a < b.a) col = a.xyz;\n    else col = b.xyz;\n    \n    float m = 5.0;\n    //col = vec3(smoothMin(a.x, b.x, m), smoothMin(a.x, b.x, m), smoothMin(a.x, b.x, m));\n    \n    return vec4(col, smoothMin(a.a, b.a, 5.0));\n}\n\nvec4 SceneSDFwithColor(vec3 p)\n{\n    vec4 sphere0 = sphereSDF(vec3(sin(2.*iTime), -1., 4.0), 1.0, p);\n    vec4 sphere1 = sphereSDF(vec3(3.0*cos(iTime), 0.1, 4.0), .7, p);\n\n    vec4 plane = flatPlaneSDF(p);\n    vec4 line = lineSDF(p, vec3(-4.0, -.7, 3.0), vec3(-1.0, 2.0, 5.0), .3);\n    vec4 box = boxSDF(p, vec3(1));\n    \n    vec4 a = findMin(sphere0, findMin(plane, findMin(line, findMin(box, sphere1))));\n    \n    return a;    \n}\n\nvec4 RayMarch(vec3 ro, vec3 rd)\n{\n    float D = 0.;\n    vec3 p = vec3(0);\n    vec3 color = vec3(0);\n\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        p = ro + rd*D;\n        float dS = SceneSDFwithColor(p).a;\n        D += dS;\n        color = SceneSDFwithColor(p).xyz;\n        if(dS < SURFACE_DIST || D > MAX_DIST) break;\n    }\n    return vec4(color, D);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = SceneSDFwithColor(p).a;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = vec3(d) - vec3(\n        SceneSDFwithColor(p-e.xyy).a,\n        SceneSDFwithColor(p-e.yxy).a,\n        SceneSDFwithColor(p-e.yyx).a);\n    //this is tricky to understand. \n    //the normal of the surface IS the tangent of the distance field.\n    //It is the direction in which the distance increases the most.\n    //to understand this, try drawing a 2D surface, and sample sdf around a point and check.\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    //shadows\n    float d = RayMarch(p+n*SURFACE_DIST*2., l).a;\n    if(d<length(lightPos-p)) dif *= 0.1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.y) - vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0.3+ sin(iTime), 4. + cos(iTime), -3.);\n    vec3 rd = normalize(vec3(uv.x, uv.y - .5, .8));\n    \n    vec4 RayMarched = RayMarch(ro, rd);\n\n    vec3 p = ro + rd * RayMarched.a;\n    float dif = GetLight(p);\n    \n    col = RayMarched.xyz*dif;\n\n    fragColor = vec4(col/2. + 0.1,1.0);\n}","name":"Image","description":"","type":"image"}]}