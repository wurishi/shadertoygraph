{"ver":"0.1","info":{"id":"l3SXWd","date":"1711217435","viewed":74,"name":"Cubic BÃ©zier by Darko","username":"omegasbk","description":"Use mouse to move the control points (green)\n\nEvolved the quadratic version into this cubic one and played a bit with the Bernstein form.\nThe deeper I go, the more I love this!","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["bernstein","cubicbezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Darko Supe (omegasbk) 2024-03-23\n// Follow me on twitter/X: @darkosupe\n// Feel free to re-use.\n\n#define MAX_DIST 9999999.\n\n#define FRAME_T 0.001\n#define POINTS_R 0.01\n\n#define BERNSTEIN_T 0.0015\n\nfloat sdfCircle(vec2 uv, vec2 c, float r)\n{\n    return distance(uv, c) - r;\n}\n\nfloat sdfLine(vec2 uv, vec2 a, vec2 b)\n{\n\tvec2 lineVec = b - a;\n    vec2 h = uv - a;\n    return length(h - lineVec * clamp(dot(lineVec, h) / \n           dot(lineVec, lineVec), 0.0, 1.0));\n}\n\nfloat plotFunction(vec2 uv, float x)\n{\n    return smoothstep(1.5/iResolution.y, 0., x - uv.y) -\n           smoothstep(1.5/iResolution.y, 0., x - uv.y + 0.01);\n}\n\nfloat circle(vec2 uv, vec2 c, float r, float d)\n{\n    return min(d, sdfCircle(uv, c, r));\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b, float d)\n{\n    return min(d, sdfLine(uv, a, b));\n}\n\nvec3 sdfBezierT(vec2 uv, vec2 c_pt1, vec2 c_pt2, vec2 c_pt3, vec2 c_pt4, float t)\n{\n    vec2 cc_pt1 = mix(c_pt1, c_pt2, t);\n    vec2 cc_pt2 = mix(c_pt2, c_pt3, t);\n    vec2 cc_pt3 = mix(c_pt3, c_pt4, t); \n    \n    vec2 b_pt1 = mix(cc_pt1, cc_pt2, t);\n    vec2 b_pt2 = mix(cc_pt2, cc_pt3, t);\n    \n    vec2 pt = mix(b_pt1, b_pt2, t);\n   \n    return vec3(distance(uv, pt), pt);\n}\n\nfloat sdfBezierCurve(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    float t = 0.;\n    float maxDist = 1000.;\n    vec3 dist = vec3(maxDist);\n    float minDist = 0.000005;\n    float stepDist = 0.02;\n\n    for (int i = 0; i < 50; i++)\n    {         \n        if (t > 1.0)\n            return maxDist;\n     \n        float t2 = min(1., t + stepDist);\n\n        dist = sdfBezierT(uv, a, b, c, d, t);\n        vec3 dist2 = sdfBezierT(uv, a, b, c, d, t2);\n        vec2 pt1_b = dist.yz;\n        vec2 pt2_b = sdfBezierT(dist2.yz, a, b, c, d, t2).yz;\n        \n        vec2 u = pt1_b - uv;\n        vec2 v = pt2_b - uv;\n        \n        vec2 q = pt2_b - pt1_b;\n        \n        float thickness = 0.003;\n        \n        // Play with this if you want to see cool patterns :) \n        if (dot(u, v) > thickness / 100.)\n        {\n            t+= stepDist;\n            continue;\n        }\n        \n        float b_dist = distance(-u, normalize(q) * dot(-u, normalize(q)));\n\n        if (b_dist < thickness)\n            return b_dist;\n\n        t += stepDist;\n    }\n    \n    return maxDist;\n}\n\nvoid drawLines(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d, float t, inout vec3 col)\n{\n    vec2 ab = mix(a, b, t);\n    vec2 bc = mix(b, c, t);\n    vec2 cd = mix(c, d, t);\n    \n    vec2 abbc = mix(ab, bc, t);\n    vec2 bccd = mix(bc, cd, t);\n    \n    float dist = MAX_DIST;\n    \n    dist = line(uv, a, b, dist);\n    dist = line(uv, b, c, dist);\n    dist = line(uv, c, d, dist);\n\n    dist = line(uv, ab, bc, dist);\n    dist = line(uv, bc, cd, dist);\n    \n    dist = line(uv, abbc, bccd, dist);\n    \n    col += smoothstep(1.5/iResolution.y, 0., dist - FRAME_T) / 2.5;\n}\n\nvoid drawPoints(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d, float t, inout vec3 col)\n{\n    // Draw control points\n    float dist = MAX_DIST;\n    dist = circle(uv, a, POINTS_R * 1.5, dist);\n    dist = circle(uv, b, POINTS_R * 1.5, dist);\n    dist = circle(uv, c, POINTS_R * 1.5, dist);\n    dist = circle(uv, d, POINTS_R * 1.5, dist);\n    \n    col.g += smoothstep(1.5/iResolution.y, 0., dist);\n    \n    // Draw interpolated points\n    vec2 ab = mix(a, b, t);\n    vec2 bc = mix(b, c, t);\n    vec2 cd = mix(c, d, t);\n    \n    dist = MAX_DIST;\n    dist = circle(uv, ab, POINTS_R, dist);\n    dist = circle(uv, bc, POINTS_R, dist);\n    dist = circle(uv, cd, POINTS_R, dist);\n    col.rg += smoothstep(1.5/iResolution.y, 0., dist);\n\n    // Draw Bezier top points\n    vec2 abbc = mix(ab, bc, t);\n    vec2 bccd = mix(bc, cd, t);\n\n    dist = MAX_DIST;\n    dist = circle(uv, abbc, POINTS_R / 2., dist) / 2.; \n    dist = circle(uv, bccd, POINTS_R / 2., dist) / 2.;\n    col.rg += smoothstep(1.5/iResolution.y, 0., dist);\n}\n\nvoid plotBernstein(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d, float t, inout vec3 col)\n{\n    vec2 center = vec2(0.);\n    \n    float b1 = (-t*t*t + 3.*t*t - 3.*t + 1.);\n    float b2 = (3.*t*t*t - 6.*t*t + 3.*t);\n    float b3 = (-3.*t*t*t + 3.*t*t);\n    float b4 = t*t*t;\n    \n    vec2 b1_pt = b1 * (a);\n    vec2 b2_pt = b1_pt + b2 * (b);\n    vec2 b3_pt = b2_pt + b3 * (c);\n    vec2 b4_pt = b3_pt + b4 * (d);\n\n    float b1_ld = sdfLine(uv, center, b1_pt);\n    col.r += smoothstep(1.5/iResolution.y, 0., b1_ld - BERNSTEIN_T) / 2.;     \n    float b2_ld = sdfLine(uv, b1_pt, b2_pt);\n    col.g += smoothstep(1.5/iResolution.y, 0., b2_ld - BERNSTEIN_T) / 2.;     \n    float b3_ld = sdfLine(uv, b2_pt, b3_pt);\n    col.rb += smoothstep(1.5/iResolution.y, 0., b3_ld - BERNSTEIN_T) / 2.;     \n    float b4_ld = sdfLine(uv, b3_pt, b4_pt);\n    col.gb += smoothstep(1.5/iResolution.y, 0., b4_ld - BERNSTEIN_T) / 2.;     \n    vec2 plotUv = ((uv + 0.5) * 3.) + vec2(0.9, -0.2);\n    float u = plotUv.x;\n    col.r += plotFunction(plotUv, -u*u*u+ 3.*u*u - 3.*u + 1.) *\n            step(plotUv.x, 1.) * \n            step(plotUv.y, 1.);\n            \n    col.g += plotFunction(plotUv, 3.*u*u*u - 6.*u*u + 3.*u) *\n            step(plotUv.x, 1.) * \n            step(0., plotUv.x);\n            \n    col.rb += plotFunction(plotUv, -3.*u*u*u + 3.*u*u) *\n            step(plotUv.x, 1.) *\n            step(0., plotUv.x);\n            \n    col.gb += plotFunction(plotUv, u*u*u) *\n            step(plotUv.x, 1.) * \n            step(0., plotUv.x);\n         \n    float dist = MAX_DIST;\n    dist = circle(plotUv, vec2(t, b1), POINTS_R * 3., dist);\n    dist = circle(plotUv, vec2(t, b2), POINTS_R * 3., dist); \n    dist = circle(plotUv, vec2(t, b3), POINTS_R * 3., dist); \n    dist = circle(plotUv, vec2(t, b4), POINTS_R * 3., dist);\n    col.rgb += smoothstep(1.5/iResolution.y, 0., dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5* iResolution.xy ) / iResolution.y;\n    \n    float t = abs(sin(iTime / 2.));\n\n    vec3 col = vec3(0.);\n             \n    vec2 c_pt1 = texelFetch(iChannel0, tx_pt1, 0).rg;\n    vec2 c_pt2 = texelFetch(iChannel0, tx_pt2, 0).rg;\n    vec2 c_pt3 = texelFetch(iChannel0, tx_pt3, 0).rg;\n    vec2 c_pt4 = texelFetch(iChannel0, tx_pt4, 0).rg;\n    \n    vec2 cc_pt1 = mix(c_pt1, c_pt2, t);\n    vec2 cc_pt2 = mix(c_pt2, c_pt3, t);\n    vec2 cc_pt3 = mix(c_pt3, c_pt4, t);\n    \n    vec2 b_pt1 = mix(cc_pt1, cc_pt2, t);\n    vec2 b_pt2 = mix(cc_pt2, cc_pt3, t);\n    \n    drawLines(uv, c_pt1, c_pt2, c_pt3, c_pt4, t, col);\n    drawPoints(uv, c_pt1, c_pt2, c_pt3, c_pt4, t, col);\n    plotBernstein(uv, c_pt1, c_pt2, c_pt3, c_pt4, t, col);\n    \n    float bezierBallR = 0.017;\n    float bezierBall = sdfBezierT(uv, c_pt1, c_pt2, c_pt3, c_pt4, t).x; \n    col.rb += smoothstep(1.5/iResolution.y, 0., bezierBall - bezierBallR);\n    \n    float bezier = sdfBezierCurve(uv, c_pt1, c_pt2, c_pt3, c_pt4); \n    col.gb += smoothstep(1.5/iResolution.y, 0., bezier - 0.001);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This is where I did magic to store the points states/positions.\n\nvec4 loadValue(in ivec2 key)\n{\n    return texelFetch(iChannel0, key, 0);\n}\n\nvoid storeValue(in ivec2 key, in vec4 value, inout vec4 fragColor, in ivec2 fragCoord)\n{\n    fragColor = (key.x==fragCoord.x && key.y==fragCoord.y) ? value : fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 ifragCoord = ivec2(fragCoord); \n\n    vec4 pt1_v = loadValue(tx_pt1);\n    if (pt1_v.xy == vec2(0.))\n        pt1_v = d_pt1;\n        \n    vec4 pt2_v = loadValue(tx_pt2);\n    if (pt2_v.xy == vec2(0.))\n        pt2_v = d_pt2;\n        \n    vec4 pt3_v = loadValue(tx_pt3);\n    if (pt3_v.xy == vec2(0.))\n        pt3_v = d_pt3;\n        \n    vec4 pt4_v = loadValue(tx_pt4);\n    if (pt4_v.xy == vec2(0.))\n        pt4_v = d_pt4;\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - 0.5;\n    mousePos.x *= iResolution.x / iResolution.y;\n\n    float dist_pt1 = distance(pt1_v.xy, mousePos);\n    float dist_pt2 = distance(pt2_v.xy, mousePos);\n    float dist_pt3 = distance(pt3_v.xy, mousePos);\n    float dist_pt4 = distance(pt4_v.xy, mousePos);\n    \n    float closest = min(\n                    min(\n                    min(dist_pt1, \n                        dist_pt2), \n                        dist_pt3), \n                        dist_pt4);\n    \n    if (mousePos.y != -0.5)\n    {\n        if (closest == dist_pt1)\n        {\n            pt1_v.xy = mousePos;\n        }\n        else if (closest == dist_pt2)\n        {\n            pt2_v.xy = mousePos;\n        }\n        else if (closest == dist_pt3)\n        {\n            pt3_v.xy = mousePos;\n        }\n        else\n        {\n            pt4_v.xy = mousePos;\n        }\n    }\n    \n    storeValue(tx_pt1, pt1_v, fragColor, ifragCoord);\n    storeValue(tx_pt2, pt2_v, fragColor, ifragCoord);\n    storeValue(tx_pt3, pt3_v, fragColor, ifragCoord);\n    storeValue(tx_pt4, pt4_v, fragColor, ifragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const ivec2 tx_pt1 = ivec2(0, 0);\nconst ivec2 tx_pt2 = ivec2(1, 0);\nconst ivec2 tx_pt3 = ivec2(2, 0);\nconst ivec2 tx_pt4 = ivec2(3, 0);\n\nvec4 d_pt1 = vec4(-0.3, -0.3, 0., 0.);\nvec4 d_pt2 = vec4(0.65, 0.42, 0., 0.);\nvec4 d_pt3 = vec4(-0.66, 0.4, 0., 0.);\nvec4 d_pt4 = vec4(0.4, -0.2, 0., 0.);","name":"Common","description":"","type":"common"}]}