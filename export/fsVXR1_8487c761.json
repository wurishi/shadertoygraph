{"ver":"0.1","info":{"id":"fsVXR1","date":"1635289958","viewed":129,"name":"Infinite Cylinder","username":"TheoWU","description":"Infinite length cylinder","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray{\n    vec3 origin;\n    vec3 direction;\n};\nstruct HitInfo{\n    bool hit;\n    float t;\n    vec3 hitposition;\n    vec3 normal;\n    vec3 color;\n};\nstruct Cylinder {\n\tvec3 position;\n\tvec3 direction;  \n\tfloat radius;\n\tvec3 color;\n};\nstruct Plane {\n\tvec3 normal;\n\tfloat d;\n\tvec3 color;\n};\nstruct Light{\n    vec3 position;\n};\nHitInfo getEmptyHit() {\n\treturn HitInfo(\n\t\tfalse, \n\t\t0., \n\t\tvec3(0.), \n\t\tvec3(0.), \n        vec3(0.,0.,0.));\n}\nvoid sortT(inout float t1, inout float t2) {\n\t// Make t1 the smaller t\n\tif(t2 < t1)  {\n\t\tfloat temp = t1;\n\t\tt1 = t2;\n\t\tt2 = temp;\n\t}\n}\nbool isTInInterval(const float t, const float tMin, const float tMax) {\n\treturn t > tMin && t < tMax;\n}\nbool getSmallestTInInterval(float t0, float t1, const float tMin, const float tMax, inout float smallestTInInterval) {\n\tsortT(t0, t1);\n\tif(isTInInterval(t0, tMin, tMax)) {\n\t\tsmallestTInInterval = t0;\n\t\treturn true;\n\t}\n\tif(isTInInterval(t1, tMin, tMax)) {\n\t\tsmallestTInInterval = t1;\n\t\treturn true;\n\t}  \n\treturn false;\n}\n\nHitInfo intersectPlane(const Ray ray,const Plane plane, const float tMin, const float tMax) {\n\tfloat t = (plane.d-ray.origin.y)/ray.direction.y;\n\tif(t > 0.0){\n\t\tvec3 hitPosition = ray.direction * t + ray.origin;\n\t\tvec3 normal = plane.normal;\n\t\tbool enteringPrimitive = true;\n\t\tfloat smallestTInInterval;\n      \tif(!getSmallestTInInterval(t, t, tMin, tMax, smallestTInInterval)) {\n          return getEmptyHit();\n        }\n\t\treturn HitInfo(\n\t\t\t\ttrue,\n\t\t\t\tsmallestTInInterval,\n\t\t\t\thitPosition,\n\t\t\t\tnormal,\n\t\t\t\tplane.color);\n\t}\n\t\treturn getEmptyHit();\n}\n\nHitInfo intersectCylinder(const Ray ray, const Cylinder cylinder, const float tMin, const float tMax) {\n\tvec3 A = ray.origin;\n\tvec3 B = ray.direction;\n\tvec3 n = cylinder.direction;\n\tvec3 O = cylinder.position;\n\tfloat a1 = dot(B,B);\n\tfloat a2 = dot(B,n)*dot(B,n);\n\tfloat b1 = dot(B,A-O);\n\tfloat b2 = dot(B,n)*dot(A-O,n);\n\tfloat c1 = dot(A-O,A-O);\n\tfloat c2 = dot(A-O,n)*dot(A-O,n);\n\tfloat a = a1 - a2;\n\tfloat b = 2.0*(b1-b2);\n\tfloat c = c1 - c2 - cylinder.radius*cylinder.radius;\n\tfloat D = b * b - 4.0 * a * c;\n    if (D > 0.0)\n    {\n\t\tfloat t0 = (-b - sqrt(D)) / (2. * a);\n\t\tfloat t1 = (-b + sqrt(D)) / (2. * a);\n      \n      \tfloat smallestTInInterval;\n      \tif(!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {\n          return getEmptyHit();\n        }\n\t\tvec3 hitPosition = ray.origin + smallestTInInterval * ray.direction; \n\t\tvec3 u = hitPosition - cylinder.position;\n\t\tvec3 toHitPosition = u-dot(u,cylinder.direction)*cylinder.direction;\n\t\tvec3 normal_root = cylinder.position + dot(u,cylinder.direction)*cylinder.direction;\n\t\tbool enteringPrimitive = length(normal_root-ray.origin)<length(normal_root-hitPosition)+0.001? false:true; \n\t\tvec3 normal = \n        enteringPrimitive? (u-dot(u,cylinder.direction)*cylinder.direction)/cylinder.radius: -(u-dot(u,cylinder.direction)*cylinder.direction)/cylinder.radius; \n\t\tvec3 color = cylinder.color;\n        return HitInfo(\n\t\t\ttrue,\n\t\t\tsmallestTInInterval,\n\t\t\thitPosition,\n\t\t\tnormal,\n\t\t\tcolor);\n\t}\n    return getEmptyHit();\n}\n\nvec3 getColor(vec3 rayori, vec3 raydir) {\n\n    Cylinder cylinder;\n    cylinder.position = vec3(8., 5., 50.);\n\tcylinder.direction = normalize(vec3(sin(iTime),1.,2.*cos(iTime)));\n\tcylinder.radius = .5;\n    cylinder.color = vec3(.8,.8,.6);\n    Plane plane;\n    plane.normal = vec3(0.,1.,0.);\n    plane.d = .00005;\n    plane.color = vec3(.2,.2,.2);\n    Ray ray;\n    ray.origin = rayori;\n    ray.direction = raydir;\n    Light light;\n    light.position = vec3(0.,3.,20.);\n  \tHitInfo hitInfo1 = intersectCylinder(ray, cylinder, 0.001, 10000.0); \n    HitInfo hitInfo = hitInfo1;\n    /*HitInfo hitInfo2 = intersectPlane(ray, plane, 0.001, 10000.0);\n    if(hitInfo1.t>hitInfo2.t){\n        hitInfo = hitInfo2;\n    }*/\n    vec3 color = vec3(0.,0.,0.);\n    if(!hitInfo.hit){\n        return vec3(0.5,0.5,0.5);\n    }\n    vec3 lightDirection = normalize(light.position - hitInfo.hitposition);\n    vec3 viewDirection = normalize(hitInfo.hitposition - ray.origin);\n    vec3 reflectedDirection = reflect(viewDirection, hitInfo.normal);\n    color += hitInfo.color*max(0.,dot(lightDirection,hitInfo.normal));\n    color += hitInfo.color*pow(max(0.0, dot(lightDirection, reflectedDirection)), 10.);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 rayori = vec3(0.,0.,0.);\n    float camDistance = 5.5;\n    vec3 raydir = normalize(vec3(uv,camDistance)-rayori);\n    vec3 col = getColor(rayori,raydir);\n    fragColor = vec4(col,1.);\n    \n}","name":"Image","description":"","type":"image"}]}