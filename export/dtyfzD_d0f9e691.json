{"ver":"0.1","info":{"id":"dtyfzD","date":"1701885259","viewed":35,"name":"Ethereal Pulsar Music Visualizer","username":"Forthro","description":"Volumetric music visualizer.","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["sound","sdf","music","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ldc3zf","filepath":"https://soundcloud.com/monstercat/haywyre-white-lie","previewfilepath":"https://soundcloud.com/monstercat/haywyre-white-lie","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphereSound( in vec3 checkedPoint )\n{\n    vec2 samplerSmall = vec2( 0.5 + abs(sin( atan( checkedPoint.y / ( checkedPoint.x )))) / 12.0, 0.25 );\n    vec2 samplerBig = vec2( cos( atan( checkedPoint.x / ( checkedPoint.z ))) / 12.0, 0.25 );\n    \n    return ( texture( iChannel0, samplerSmall ).r * texture( iChannel0, samplerBig ).r ) * 2.5;\n}\n\nfloat sphereDistance( in vec3 checkedPoint )\n{\n    const float radius = 3.0;\n    const float amplification = 5.0;\n    \n    return distance( checkedPoint, vec3( 0.0, 0.0, 0.0 ) ) - radius - sphereSound( checkedPoint ) * amplification;\n}\n\nvec3 sphereNormal( in vec3 checkedPoint )\n{\n    const float shift = 1.1;\n    return normalize(\n        vec3\n        (\n            sphereDistance(checkedPoint + vec3( shift, 0, 0 )) - sphereDistance(checkedPoint - vec3( shift, 0, 0 )),\n            sphereDistance(checkedPoint + vec3( 0, shift, 0 )) - sphereDistance(checkedPoint - vec3( 0, shift, 0 )),\n            sphereDistance(checkedPoint + vec3( 0, 0, shift )) - sphereDistance(checkedPoint - vec3( 0, 0, shift ))\n        )\n    );\n}\n\nstruct FragData{\n    vec2 screenCoord;\n    vec2 normalCoord;\n    float normalDistance;\n};\n\nvec3 background( in FragData fragData )\n{    \n    float sound = texture( iChannel0, vec2( cos( fragData.normalDistance ), 0.25 )).r \n                + texture( iChannel0, vec2( sin( fragData.normalDistance ), 0.25 )).r;\n    float fragAngle = cos( atan( fragData.normalCoord.x, fragData.normalCoord.y ) * 8.0 );\n    \n    float shiftedTime = iTime * 3.0 - ( fragData.normalDistance * 7.0 ) + fragAngle * sin( pow(( 1.3 - fragData.normalDistance ), ( 1.3 - fragData.normalDistance )) * 100.0 + iTime * 3.0 + sound * sound * 2.0);\n    \n    float waveModulator = 0.35 + sin(( fragData.normalDistance-shiftedTime /  5.0 ) * 20.0 ) / 2.0 * sound * 2.0;\n    \n    float red = ( 0.95 + sin( shiftedTime + sound * 4.0 ) / 7.0 ) * waveModulator;\n    float green = 0.1 * waveModulator;\n    float blue = ( 0.55 + cos( shiftedTime + sound * 4.0 ) / 3.0 ) * waveModulator;\n    \n    return vec3( red, green, blue );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float focalLength = 10.0;\n    const float camSurfaceRadius = 5.0;\n    \n    FragData fragData;\n    fragData.screenCoord = fragCoord;\n    fragData.normalCoord = ( fragCoord - iResolution.xy / 2.0 ) / min( iResolution.x, iResolution.y );\n    fragData.normalDistance = distance(fragData.normalCoord, vec2( 0.0, 0.0 ));\n    \n    float camRotation = iTime / 5.0;\n    float rotationRadius = 55.0 + 10.0 * cos( camRotation / 1.3 );\n    vec3 camPosition = vec3( rotationRadius * sin( camRotation ) + 3.0  * cos( camRotation * 3.0 ), 4.0 * sin( camRotation / 1.3 ), -rotationRadius * cos( camRotation ) + 3.0  * sin( camRotation * 2.3 ) );\n    float camYaw = camRotation;\n\n    vec3 camLocalSurfaceCoord = \n        vec3(\n            cos( camYaw ) * fragData.normalCoord.x * camSurfaceRadius, \n            fragData.normalCoord.y * camSurfaceRadius,\n            sin( camYaw ) * fragData.normalCoord.x * camSurfaceRadius\n        );\n    vec3 rayDirection = normalize( vec3( camLocalSurfaceCoord.x - sin( camYaw ) * focalLength, camLocalSurfaceCoord.y, camLocalSurfaceCoord.z + cos( camYaw ) * focalLength ) );\n    vec3 camSurfaceCoord = camPosition + camLocalSurfaceCoord;\n    \n    float sphereRaysShift = camPosition.y / ( distance( camPosition, vec3(0.0,0.0,0.0) ) / focalLength ) / camSurfaceRadius;\n    float sphereRaysStrength = pow( sphereSound( vec3( fragData.normalCoord  + vec2( 0.0, sphereRaysShift ), 0.0 )), 2.5 );\n    vec3 color = ( background( fragData ) / 25.0 + vec3( 0.12, 0.12, 0.24 ) * sphereRaysStrength ) * fragData.normalDistance;\n    \n    vec3 checkedSpherePoint = camSurfaceCoord;\n    float cumulativeDensity = 1.0;\n    \n    while( distance( checkedSpherePoint, camPosition ) < 75.0 ){\n        float currentDistance = sphereDistance( checkedSpherePoint );\n        checkedSpherePoint += max( 0.5, currentDistance + 0.01 ) * rayDirection;\n        \n        float density = pow( max( 0.0, 3.5 - currentDistance ), 2.5 );\n        \n        float sound = sphereSound( checkedSpherePoint );\n        float soundEffect = sound * sound / 50.0;\n        color += ( vec3( soundEffect, 0.025 - soundEffect / 2.0, 0.07 - soundEffect / 2.0 ) * density + vec3( 0.15, 0.05, 0.05 ) * max( 0.0, dot( sphereNormal( checkedSpherePoint ), -rayDirection ) - 0.5 ) * density ) \n               / cumulativeDensity;\n        cumulativeDensity += density;\n    }\n\n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}