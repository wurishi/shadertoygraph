{"ver":"0.1","info":{"id":"WtK3Ry","date":"1579568369","viewed":311,"name":"Untitled 0x0000000D","username":"harry7557558","description":"basically a copy of my c++ code [url]https://github.com/Harry7557558/Graphics/blob/light2d/light2d%20(no%20recursion).cpp[/url] (not gl)","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["light2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 c, in vec2 p) {\n\tc = texelFetch(iChannel0, ivec2(p), 0);\n    c /= float(iFrame+1);\n}\n\n\n// Bug fix history:\n// Buffer A line 70 originally uses 0.0*R!=0.0 to test NAN.\n// Shader optimizer foiled this trick.\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265358979\n\n// set SAMPLE to a smaller value if you have a slow machine\n#define SAMPLE 64\n#define EPSILON 1e-4\n#define MAX_STEP 64\n#define MAX_DIST 10.0\n#define MAX_RECU 50\n\nvec2 CENTER = vec2(0.0, 0.0);\nfloat SCALE = 100.0;\nfloat BULB = 2.0;\nfloat INDEX = 1.5;\n\n\nfloat hash(vec2 x){\n    return fract(sin(dot(x,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvec2 Refract(vec2 I, vec2 N, float n1, float n2, out float R) {\n\tfloat eta = n1 / n2;\n\tfloat ci = -dot(N, I);\n\tif (ci < 0.) ci = -ci, N = -N;\n\tfloat ct = sqrt(1.0 - eta * eta * (1.0 - ci * ci));\n\tvec2 r = I * eta + N * (eta * ci - ct);\n\tfloat Rs = (n1 * ci - n2 * ct) / (n1 * ci + n2 * ct);\n\tfloat Rp = (n1 * ct - n2 * ci) / (n1 * ct + n2 * ci);\n\tR = 0.5 * (Rs * Rs + Rp * Rp);\n\treturn r;\n}\n\n\nfloat sdBulb(vec2 p) {\n\t//return length(p - vec2(3.0)) - 1.0;\n\t//return length(vec2(abs(p.x) - 3.0, abs(p.y) - 3.0)) - 0.5;\n\treturn length(vec2(p.x, p.y - 3.0)) - 1.0;\n}\n\nfloat sdObj(vec2 p) {\n\t//return length(p)-1.0;\t// circle\n\t//return (abs(p.x)>0.8?length(vec2(abs(p.x)-0.8,p.y)):abs(p.y))-0.8;\t// capsule\n\t//return max(abs(p.x) - 1.2, abs(p.y) - 0.75);\t// rectangle\n\t//return max(length(vec2(p.x,p.y-0.4))-1.0,p.y-0.5);\t// semi-circle\n\treturn min(max(abs(p.x),abs(p.y)-1.2), max(abs(p.x)-0.7,abs(p.y-0.5)))-0.2;\t// cross\n\t//p=abs(p); return min((p.y>1.0?length(p-vec2(0.65,1.0)):abs(p.x-0.65))-0.2, max(p.x-0.65,p.y)-0.2);\t// letter H\n}\n\nvec2 gradient(vec2 p) {\n\tfloat k = 0.001;\n\tfloat u = sdObj(vec2(p.x + k, p.y)) - sdObj(vec2(p.x - k, p.y));\n\tfloat v = sdObj(vec2(p.x, p.y + k)) - sdObj(vec2(p.x, p.y - k));\n\treturn vec2(u, v) * (0.5 / k);\n}\n\nfloat traceRay(vec2 p, vec2 d) {\n\tint N = 0;\n\twhile (N++ < MAX_RECU) {\n\t\tfloat t = 10.0*EPSILON, dt, sdb, sdo, ot, it, R;\n\t\tvec2 q, n, r;\n\t\tint i; for (i = 0; i < MAX_STEP; i++) {\n\t\t\tq = p + d * t;\n\t\t\tsdb = sdBulb(q);\n\t\t\tif (sdb <= EPSILON) return BULB;\n\t\t\tsdo = sdObj(q);\n\t\t\tdt = sdb > sdo ? sdo : sdb;\n\t\t\tif (abs(dt) <= EPSILON) {\n\t\t\t\tn = normalize(gradient(q)), r;\n\t\t\t\tif (dt >= 0.0) r = Refract(d, n, 1.0, INDEX, R);\n\t\t\t\telse r = Refract(d, n, INDEX, 1.0, R);\n\t\t\t\tif (isnan(R)) R = 1.0;  // bug fixed: 0.0*R!=0.0 got optimized\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt += abs(dt);\n\t\t\tif (t > MAX_DIST) return 0.0;\n\t\t}\n\t\tif (i == MAX_STEP) return 0.0;\n\n\t\tt = hash(q + d * R + iTime);\n\t\tif (t < R) p = q, d = reflect(d, n);\n\t\telse p = q, d = r;\n\t}\n\treturn 0.0;\n}\n\nfloat Sample(vec2 p) {\n\tfloat c = 0.0;\n\tfloat s = 1.0 / SCALE, h = -0.5 / SCALE;\n\tfor (int i = 0; i < SAMPLE + min(iFrame, 0); i++) {\n\t\tfloat a = 2.0 * PI * (float(i) + hash(p + vec2(i) + iTime)) / float(SAMPLE);\n\t\tvec2 d = vec2(cos(a), sin(a));\n\t\tc += traceRay(p + vec2(hash(p + iTime - float(i))) * s, d);\n\t}\n\treturn c / float(SAMPLE);\n}\n\nvoid mainImage( out vec4 col, in vec2 coord ) {\n\tSCALE = 0.2*sqrt(iResolution.x*iResolution.y);\n\tvec2 p = (coord - iResolution.xy * 0.5) * (1.0 / SCALE) + CENTER * 0.5;\n\tfloat c = Sample(p);\n\tcol = vec4(vec3(c), 1.0);\n    col += texelFetch(iChannel0, ivec2(coord), 0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}