{"ver":"0.1","info":{"id":"4tfyWr","date":"1504240355","viewed":187,"name":"Parallel Transport","username":"sillsm","description":"Parallel Transport Study","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["geometry","manifold","connection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Parallel Transport Study\n// Copyright Max Sills 2016, licensed under the MIT license.\n/*\nThis is an attempt to write down what I'm learning about geometry to keep\nmyself honest. Feel free to correct anything I'm saying in the comments.\n\nThe sphere is a two dimensional topological manifold.\nMeaning it's a set of points M, together with a collection of subsets O,\ncalled the \"open\" sets. This can be denoted (M, O).\n\nWhen you embed the sphere in R3, it inherits the induced topology \nfrom R3 (base of open balls). The manifold structure is obtained \nby adding invertible charts from the sphere to R2. A manifold is a\nset M, its open sets O, and a collection of charts A, (M, O, A).\n\nConsider two charts which map the northern and southern \nhemispheres of the sphere into a unit disk on the plane.\n\nThe northern chart maps points (X,Y,Z) on the sphere\nto the points (x, y) on the unit disc. Points (x, y)\non the disc are mapped back to (x, y, sqrt(-x^2 + y^2 + 1)).\n\nEvery point in the northern hemisphere has a corresponding \npoint in the pictured unit disc. It also has a tangent plane\nwhich touches the sphere only at that point. Actually, there\nare an infinite amount of such planes, because you can rotate \na tangent plane by any amount around its normal vector\nand still get another tangent plane.\n\nAn immediate question is, what orientation should an arbitrary tangent plane\nhave? The answer is given by something called an \"affine connection\".\nRiemannian manifolds, which are pairs (M, O, A, metric), where a metric\nis a way to define the distance between two points, have a special \"default\" \norientation map, called the \"Levi-Civita connection\". That's pictured\non the left.\n\nParallel transport is a technique to determine per-unit surface area\ncurvature. You take a loop around an area on a manifold, and see how \ntangent plane orientations have changed with respect to the Levi-Civita connection.\n\nYou can interact with this study, and imagine different curves on the northern\nhemisphere of a sphere being projected down to the unit disc. The two arrows\nrepresent the orientation of a tangent plane on the sphere.\n*/\n#define PI 3.14159\nmat3 Rot (float angle)\n{\n    float c = cos(angle/360.*2.*PI);\n    float s = sin(angle/360.*2.*PI);\n    \nreturn  mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n); \n}\n\nmat3 Disp (vec2 displacement)\n{\nreturn  mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(displacement, 1)\n); \n}\n\nvec2 Apply(mat3 m, vec2 p)\n{\n    return (m*vec3(p,1.)).xy;\n}\n\n// Nead a repetition operator that respects\n// negatives and is centered at zero or\n// mirror symmetries flake out.\nfloat RepeatInterval(float x, float size)\n{\n    return mod(x-size/2., size) - size/2.;\n}\n\n// Smooth Clamp for distance functions\n// Return val until x exceeds cap, then\n// smoothly, quickly, go to infinitiy.\nfloat SmoothClamp(float x, float cap, float val)\n{\n    return val + exp(10000.*(x-cap));\n}\n\nfloat sdCappedCylinder( vec2 p, vec2 h )\n{\n  p -= vec2(0.,h.y);\n  vec2 d = abs(vec2(length(p.x),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat arrow(vec2 p, float len){\n    float body = sdCappedCylinder(p, vec2(.001, len));\n    \n    p.x = abs(p.x); // Mirror cap.\n    vec2 p_cap = Apply(Rot(145.) * Disp(vec2(0.,-2.*len)), p );\n    float cap = sdCappedCylinder(p_cap, vec2(.001, len/2.));\n    return min(body,cap);\n}\n\nfloat radii(vec2 p)\n{\n    float l = length(p);\n    float theta = atan(p.y,p.x);\n    theta = RepeatInterval(theta, 45./360.*2.*PI );\n    \n    p.x = l*cos(theta);\n    p.y = l*sin(theta);\n    \n    //Gridlines\n    vec2 pp=Apply(Rot(90.), p);\n    float grids = arrow(pp,15.);\n    \n    // Arrows\n    \n    p.x -= iTime/5.;\n    p.x = RepeatInterval(p.x,1.);\n    p = Apply(Rot(90.), p);\n    float a = arrow(p,l/4.*.2);\n\n    float d = min(a,grids);\n    return SmoothClamp(l,5.,d);\n}\n\nfloat circles(vec2 p)\n{\n    float l = length(p);\n    float theta = atan(p.y,p.x);\n    theta = RepeatInterval(theta - iTime/10., 15./360.*2.*PI );\n    \n    p.x = l*cos(theta);\n    p.y = l*sin(theta);\n    \n    p.x = RepeatInterval(p.x,1.) ;\n    \n    float a = arrow(p, l/5.*.2);\n    \n    // Coordinate circles\n    float x = RepeatInterval(l,1.);\n    float b = 50.*(x)*(x);\n    a = min(a, b);\n    \n    return SmoothClamp(l,5.5,a);\n}\n\nfloat mouse(vec2 uv)\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\t\t\n    mo = mo *2.0 - 1.0; \n    mo.x *= iResolution.x / iResolution.y;\n    mo *= 5.;\n    \n    float theta = atan(mo.y,mo.x);\n    vec2 p = uv - mo;\n    float l = length(mo);\n    p = Apply(Rot((theta+PI/2.)*-180./PI + 180.), p);\n    float radial_arrow = arrow(p, .5);\n    p = Apply(Rot(-90.), p);\n    float circ_arrow = arrow(p, .5);\n    \n    float d = min(circ_arrow,radial_arrow);\n    return SmoothClamp(l,5.1,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 5.;\n    \n    fragColor = vec4(0);\n    float d = min(mouse(uv), min(radii(uv), circles(uv)));\n    \n    float t = clamp(d, 0.0, .04) * 2.*12.5;\n    vec4 bg = vec4(0);\n    vec4 fg = vec4(.8);\n    fragColor = mix(bg, fg, 1.-t);  \n}","name":"Image","description":"","type":"image"}]}