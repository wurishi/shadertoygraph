{"ver":"0.1","info":{"id":"3sKSRV","date":"1574447708","viewed":411,"name":"Starry night","username":"FreddyDoll","description":"Trying to imitate the night sky here","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["starsmilkywayheaven"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n//Start with a temperature, in Kelvin, somewhere between 1000 and 40000.  (Other values may work,\n//but I can't make any promises about the quality of the algorithm's estimates above 40000 K.)\n//Note also that the temperature and color variables need to be declared as floating-point.\nvec3 ColFromTemp(float temp)\n{\n    temp /= 100.;\n    \n    vec3 col;\n\n    if(temp <= 66.)\n        col.r = 1.;\n    else\n    {\n        col.r = temp - 60.;\n        col.r = 329.698727446 * pow(col.r, -0.1332047592);\n        col.r/=255.;\n        col.r = clamp(col.r,0.,1.);\n    }\n    \n\n    if(temp <= 66.)\n    {\n        col.g = temp;\n        col.g = 99.4708025861 * log(col.g) - 161.1195681661;\n    }\n    else\n    {\n        col.g = temp - 60.;\n        col.g = 288.1221695283 * pow(col.g,-0.0755148492);\n    }\n    col.g/=255.;\n    col.g = clamp(col.g,0.,1.);\n   \n    \n    if(temp >= 66.)\n        col.b = 1.;\n    else\n    {\n\n        if(temp <= 19.)\n            col.b = 0.;\n        else\n        {\n            col.b = temp - 10.;\n            col.b = 138.5177312231 * log(col.b) - 305.0447927307;\n    \t\tcol.b/=255.;\n    \t\tcol.b = clamp(col.b,0.,1.);\n                \n         }\n     }\n    return col;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat starfield(vec2 uv, float density, float spacing)\n{\n    float base = (noise(uv*400.)+0.9)/2.;\n    return pow(base,15.*spacing)*200.*density;\n}\n\nfloat galaxyMask(vec2 uv)\n{\n    uv.x *=2.;\n    uv.y *=.8;\n    float base = (noise(uv*2.)+1.0)/2. + .3;\n    return pow(base,6.)*4.;\n}\n\nfloat tempMap(vec2 uv)\n{\n    float base = (noise(uv*200.)+1.0)/2.;\n    base = pow(base,6.)*10.;\n    return base*25000.+3000.;\n}\n\nvec3 doColor(vec2 uv)\n{\n    vec3 col = ColFromTemp(tempMap(uv))*vec3(starfield(uv*.8, galaxyMask(uv)*1.8,1.)); //stars\n    col += ColFromTemp(tempMap(uv*.2))*vec3(starfield(uv*.2, galaxyMask(uv*.2),1.3)); //galaxies\n\treturn col;\n}\n\n#define gauss_width 3    \nfloat gauss_fact[gauss_width]=float[](0.27901,0.44198,0.27901);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //fragColor = vec4(ColFromTemp(uv.x*8000. + 1000.),1.0);\n    uv.x+=iTime*0.05;\n\tuv.y+=sin(iTime)*.01;\n    \n    vec2 baseAA = vec2(1./iResolution.x/1.5,1./iResolution.y/1.5);\n    vec3 col = vec3(0.);\n    for(int x=-gauss_width/2;x<=gauss_width/2;x++)\n    \tfor(int y=-gauss_width/2;y<=gauss_width/2;y++)\n            col += doColor(uv + vec2(baseAA.x*float(x),baseAA.y*float(y)))*gauss_fact[x+gauss_width/2]*gauss_fact[y+gauss_width/2];\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}