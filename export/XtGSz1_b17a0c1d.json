{"ver":"0.1","info":{"id":"XtGSz1","date":"1512895257","viewed":698,"name":"Volumetric Clouds","username":"Crow","description":"references: https://www.shadertoy.com/view/XtcXRN\nhttps://zhuanlan.zhihu.com/p/31534769?group_id=921906891014819840\nhttps://www.shadertoy.com/view/XslGRr\nhttps://www.shadertoy.com/view/lssGRX","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["clouds","refraction","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1416\n\nfloat SdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    float dis = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n    return abs(dis);\n}\n\nvec2 Map( vec3 pos )\n{\n    vec2 res = vec2(SdBox(pos - vec3(0.0), vec3(1.0)), 1.0);    \n    return res;\n}\n\nvec2 CastRay( vec3 camPos, vec3 rayDir, float nearClip, float farClip )\n{\n    float dis = nearClip;\n    float mat = -1.0;\n    for(int i = 0; i < 50; i++)\n    {\n\t    vec2 res = Map(camPos + rayDir * dis);\n        if(res.x < 0.001) \n            break;\n        \n        dis += res.x;\n        mat = res.y;\n        if(dis >= farClip)\n        {\n            dis = farClip;\n            mat = -1.0;\n            break;\n        }\n    }\n    \n    return vec2(dis, mat);\n}\n\n//---material--------------------------------------------------\nstruct Mat\n{\n    vec4 basCol; \n    float spe;\n    float refr;\n};\n\nMat CreateMat( vec4 basCol, float spe, float refr)\n{\n    Mat mat;\n    mat.basCol = basCol;\n    mat.spe = spe;\n    mat.refr = refr;\n    return mat;\n}\n\nMat GetMat( float matNumber )\n{\n    if(matNumber < 1.5)\n    {\n        return CreateMat(vec4(0.5, 0.7, 0.8, 0.1), 0.9, 1.5);\n    }\n}\n\n//--clouds--------------------------------------------------\nfloat Noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n    \n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel1, (uv + 0.5) / 256.0).yx;  \n    \n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat Map_Clouds( vec3 p )\n{\n\tvec3 q = p * 0.5 - vec3(0.0, 0.05, 0.3) * iTime;\n    float f;\n    f  = 0.50000 * Noise( q ); q = q * 2.02;\n    f += 0.25000 * Noise( q ); q = q * 2.03;\n    f += 0.12500 * Noise( q ); q = q * 2.01;\n    f += 0.06250 * Noise( q ); q = q * 2.02;\n    f += 0.03125 * Noise( q );\n\n\treturn clamp(-1.5 - abs(p.y) * 0.5 + 5.0 * f, 0.0, 1.0);\n}\n\nvec4 GetClouds( vec3 ro, vec3 rd, float far, vec3 ld, vec3 lc )\n{\n    ro *= 7.0;\n    far *= 7.0;\n\tvec4 sum = vec4(0.0);\n\tfloat t = 0.0;\n    for(int i = 0; i < 60; i++)\n    {         \n        vec3 pos = ro + t * rd;\n        if((rd.y > 0.0 && pos.y > 5.0) || (rd.y < 0.0 && pos.y < -5.0) || t > far || sum.a > 0.999)\n            break;\n        float den = Map_Clouds(pos); \n        if(den > 0.001) \n        {\n            float dif =  Map_Clouds(pos + 0.5 * ld);                    \n            vec3 col = mix(vec3(1.0, 0.97, 0.93), vec3(0.4), mix(den, dif, 0.7));\n            col *= lc;\n            \n            sum.rgb = mix(col, sum.rgb, sum.a);\n            sum.a += (1.0 - sum.a) * den;\n        } \n        t += 0.3;\n    }\n\n    return clamp(sum, 0.0, 1.0);\n}\n\n//---render-------------------------------------------------\nvec3 GetNormal( vec3 pos )\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(Map(pos + eps.xyy).x - Map(pos - eps.xyy).x,\n                    Map(pos + eps.yxy).x - Map(pos - eps.yxy).x,\n                    Map(pos + eps.yyx).x - Map(pos - eps.yyx).x );\n\treturn normalize(nor); \n}\n\nfloat GetFresnel( float cosi, float cost, float etai, float etat )\n{\n    float rs = (etat * cosi - etai * cost) / (etat * cosi + etai * cost);\n    float rp = (etai * cosi - etat * cost) / (etai * cosi + etat * cost);\n    return (rs * rs + rp * rp) * 0.5;\n}\n\nvec3 Render( vec3 camPos, vec3 rayDir )\n{    \n    vec3 lightDir = normalize(vec3(-1.3, -1.0, -0.7));\n    vec3 lightCol = vec3(1.0, 1.0, 1.0);     \n    vec3 amb = vec3(0.2);\n    \n    vec3 col = vec3(0.0);\n    float lerp = 1.0;\n    vec3 pos = camPos;\n    vec3 vDir = rayDir;\n    float nearClip = 0.1;\n    float farClip = 7.0;\n    float isInside = 0.0;\n        \n    for(int i = 0; i < 5; i++)\n    {\n        vec3 stepCol = vec3(0.0);\n        vec2 res = CastRay(pos, vDir, nearClip, farClip);\n        float d = res.x;\n        float m = res.y;\n        if(m > 0.0)\n        {            \n            Mat mat = GetMat(m);\n            \n            vec3 lastPos = pos;\n            pos += vDir * d;\n            vec3 nor = GetNormal(pos);\n            vec3 ligDir = -lightDir;\n            vec3 viewDir = -vDir;\n            vec3 halfDir = normalize(ligDir + viewDir);\n            float nh = max(dot(nor, halfDir), 0.0);\n            float nl = max(dot(nor, ligDir), 0.0);\n            float nv = max(dot(nor, viewDir), 0.0);\n       \t\tvec3 reflDir = normalize(reflect(vDir, nor));\n            \n            float specular = pow(nh, mat.spe * 128.0);\n            \n            vec3 reflCol = texture(iChannel0, reflDir).rgb;\n            float refr = mix(1.0 / mat.refr, mat.refr, isInside);\n            vec3 refrDir = normalize(refract(vDir, nor, refr));\n            float nr = max(dot(-nor, refrDir), 0.0);\n            float fresnel = 0.0;\n            if(isInside > 0.5)\n                fresnel = GetFresnel(nv, nr, refr, 1.0);\n            else\n                fresnel = GetFresnel(nv, nr, 1.0, refr);\n            fresnel = max(fresnel, 0.001);\n                        \n            stepCol = (mat.basCol.rgb + specular) * lightCol * nl \n                + reflCol * fresnel\n                + mat.basCol.rgb * amb;\n            \n            float alpha = mat.basCol.a;\n            \n            if(isInside > 0.5)\n            {\n                //clouds\n                vec4 cloudCol = GetClouds(lastPos, vDir, d, ligDir, lightCol);\n                stepCol = mix(stepCol, cloudCol.rgb, cloudCol.a);\n                alpha = mix(alpha, 1.0, step(0.999, cloudCol.a));\n            }\n            \n            col = mix(col, stepCol, lerp);\n            \n            if(alpha < 1.0)\n            {                \n                if(1.0 - refr * refr * (1.0 - nv * nv) < 0.0)\n                {\n                    vDir = reflDir;                    \n                }\n                else\n                {                    \n                \tvDir = refrDir;\n                    isInside = mix(1.0, 0.0, step(0.5, isInside));\n                }\n                lerp *= 1.0 - mat.basCol.a;\n                nearClip = 0.05;\n                farClip = 4.0;                                \n            }\n            else\n            {\n                break;\n            }\n        }\n        else\n        {\n            stepCol = texture(iChannel0, vDir).rgb;\n            col = mix(col, stepCol, lerp);\n            break;\n        }\n    }\n    \n    return col;\n}\n//--------------------------------------------------------\n\nmat3 SetCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float mY = ((mouse.y - 0.5) * 0.6 + 0.5) * PI;\n    vec3 camPos = vec3(cos(mouse.x * 7.0) * sin(mY), cos(mY), sin(mouse.x * 7.0) * sin(mY)) * 2.8;\n    vec3 camLookAt = vec3(0.0);\n    \n    mat3 camMatrix = SetCamera(camPos, camLookAt, 0.0);\n    vec3 rayDir = normalize(camMatrix * vec3(p.xy, 1.5));\n    \n    vec3 col = Render(camPos, rayDir);\n\tcol = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}