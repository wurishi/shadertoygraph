{"ver":"0.1","info":{"id":"ttXXD7","date":"1563200209","viewed":438,"name":"Radial_Blur_Test","username":"hasenpfote","description":"A center of radial blur can be moved with the mouse.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["blur","radial","godrays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int num_samples = 128;\nconst float attenuation = 0.95;\n\nvec3 radial_blur_filter(in vec2 origin, in vec2 point)\n{\n    vec3 color = vec3(0.0);\n    vec2 delta = (origin - point) / float(num_samples);\n    vec2 p = point;\n    \n    for(int s = 0; s < num_samples; s++)\n    {\n        float weight = pow(attenuation, float(s));\n        color += weight * texture(iChannel0, p).rgb;\n    \tp += delta;\n    }\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n\n    vec2 mouse = compute_blur_position(iMouse.xy, iResolution.xy);\n\tvec3 blur = radial_blur_filter(mouse, p);\n\n    vec3 color = texture(iChannel1, p).rgb;\n\n    color *= blur;\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define USE_FBM\n\n#ifdef USE_FBM\n\n#define OCTAVES 4\nconst float lacunarity = 1.5;\nconst float gain = 0.5;\n\nfloat fbm(in vec2 st)\n{\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.5;\n\n    for(int i = 0; i < OCTAVES; i++)\n    {\n        value += amplitude * noise(st * frequency);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n#endif\n\nconst float noise_frequency = 25.0;\nconst float noise_scale = 0.5;\n\nfloat radial_noise(in vec2 origin, in vec2 point)\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n    vec2 v = point - origin;\n    float a = atan2(v.y, v.x * aspect);\n#ifdef USE_FBM\n    float r = dot(v, v);\n    float f = fbm(vec2(r, noise_frequency * a));\n    f *= sqrt(r);\n#else\n    float f = noise(a * noise_frequency) * noise_scale;\n#endif\n\treturn f;\n}\n\nconst float lum_threshold = 0.95;\n\nfloat luminance(in vec3 color)\n{\n\treturn dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\n/*\n * Determine the contribution factor of a color.\n *\n * ht: hard threshold [0, -]\n * st: soft threshold [0, 1]\n * \n * k = ht * hs\n * r = (L - ht + k)\n * s = max(0, min(r, 2k))^2 / 4k\n * c = max(s, L - Th) / L\n */\nfloat determine_contribution_factor(in vec3 color, in float ht, in float st)\n{\n    float l = luminance(color);\n    float knee = ht * st;\n    float soft = l - ht + knee;\n    soft = clamp(soft, 0.0, 2.0 * knee);\n    soft = soft * soft / max(4.0 * knee, 0.00001);\n\n    return max(soft, l - ht) / max(l, 0.00001);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n\n    vec3 color = texture(iChannel0, p).rgb;\n\tvec2 mouse = compute_blur_position(iMouse.xy, iResolution.xy);\n\n#if 1 // for rotation.\n    p = mouse + rotate(p - mouse, iTime * 0.1);\n#endif\n\n    float weight = 1.0 - radial_noise(mouse, p);\n\n#if 1\n    float s = 1.0 - step(determine_contribution_factor(color, lum_threshold, 0.02), 0.0);\n#else\n    float s = step(lum_threshold, luminance(color));\n#endif\n    color *= weight * vec3(s);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926535897932384626433832795;\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y) * PI / 2.0 : atan(y, x);\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 1e4);\n}\n\nfloat hash(in vec2 p)\n{\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise(float x)\n{\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(in vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners.\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Cubic Hermite Curve.\n    vec2 u = smoothstep(0.0, 1.0, f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nvec2 rotate(in vec2 v, in float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nconst vec2 initial_blur_position = vec2(0.25, 1.0);\n\nvec2 compute_blur_position(in vec2 mouse, in vec2 resolution)\n{\n    return all(lessThan(mouse, vec2(0.5)))? initial_blur_position : mouse / resolution;\n}","name":"Common","description":"","type":"common"}]}