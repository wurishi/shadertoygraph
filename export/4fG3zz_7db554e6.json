{"ver":"0.1","info":{"id":"4fG3zz","date":"1712306742","viewed":49,"name":"Neonchamber Hypercube Transit","username":"PG_TG","description":"Description","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["tag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*-------------------------------\n  NEONCHAMBER HYPERCUBE TRANSIT\n-------------------------------*/\n\n#define PI acos(-1.0)\n\n// RANDOM FUNCTION (VECTOR 2)\nfloat random(vec2 uv) {\n    return fract(\n        cos(dot(uv.xy, vec2(12.9898, 78.2337))) /\n        sin(dot(uv.yx, vec2(86.2361, 55.5983))) *\n        31839.41256\n    );\n}\n\n// NOISE FUNCTION\nfloat noise(vec2 uv) {\n    vec2 iuv = floor(uv - vec2(6.0, 9.0));\n    vec2 fuv = fract(uv);\n    \n    // Four corners in 2D of a tile\n    float c1 = random(iuv);\n    float c2 = random(iuv + vec2(1.0, 0.0));\n    float c3 = random(iuv + vec2(0.0, 1.0));\n    float c4 = random(iuv + vec2(1.0, 1.0));\n\n    // Smoothen noise edges\n    vec2 s = smoothstep(0.0, 1.0, fuv);\n\n    // Combine Output\n    return mix(c1, c2, s.x) +\n              (c3 - c1) * s.y * (1.0 - s.x) +\n              (c4 - c2) * s.x * s.y;\n}\n\n// LINE FUNCTION\nvec4 line(vec2 uv, vec2 A, vec2 B, vec3 col, float thic, float blur) {\n    \n    vec2 g = B - A;\n    vec2 h = uv - A;\n    float d;\n    \n    d = length(h - g * clamp(dot(g, h) / dot(g, g), 0.0, 1.0));\n    if(blur != 0.)\n        if((blur * thic) >= thic)\n            d = smoothstep(blur * thic, thic, d);\n        else\n            d = smoothstep(thic, blur * thic * length(0.05), d);\n    else\n        d = step(thic, d);\n    \n    return vec4(col, d);\n}\n\n// CUBE FUNCTION\nvec4 cube(vec2 uv, vec2 pos, float rot, float width, float height, float tilt, float thic, vec3 col) {\n    vec4 background, foreground;\n    background = vec4(0.);\n    \n    for (int i = 0; i <= 3; i++) {\n        float j = float(i);\n        \n        foreground = line(\n            uv, \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y + height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y - height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            col,\n            thic/10.,\n            1.01\n        );\n        background = mix(background, foreground, foreground.a);\n        foreground = line(\n            uv, \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y + height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            vec2(\n                pos.x + sin(rot + PI/2. * (j + 1.)) * width * 1.5,\n                pos.y + height - cos(rot + PI/2. * (j + 1.)) * tilt/45. * 100.\n            ), \n            col,\n            thic/10.,\n            1.01\n        );\n        background = mix(background, foreground, foreground.a);\n        foreground = line(\n            uv, \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y - height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            vec2(\n                pos.x + sin(rot + PI/2. * (j + 1.)) * width * 1.5,\n                pos.y - height - cos(rot + PI/2. * (j + 1.)) * tilt/45. * 100.\n            ), \n            col,\n            thic/10.,\n            1.01\n        );\n        background = mix(background, foreground, foreground.a);\n    }\n    return background;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Aspect Ratio Fix\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 2.0;\n    \n    uv.x -= cos(iTime);\n    \n    vec4 background, foreground;\n    background = vec4(0.);\n    for(float i = 0.; i <= 4.; i += 0.5) {\n        // PINK CUBE\n        foreground = cube(\n            uv,\n            vec2(-1.975 + i, -0.25 + sin(iTime + PI/4. * i)/10.) * 5.0 * noise(uv),\n            iTime * 2.,\n            0.5,\n            0.5 + cos(iTime + PI/4. * i)/10.,\n            0.05 + sin(iTime + PI/4. * i)/10.,\n            0.05,\n            vec3(0.5, 0.0, 0.5) - vec3(cos(iTime + PI/4. * i)/2.)\n        );\n        background = mix(background, foreground, foreground.a);\n        // CYAN CUBE\n        foreground = cube(\n            uv,\n            vec2(-2.025 + i, 0.25 - sin(iTime + PI/4. * i)/10.) * 5.0 * noise(-uv),\n            iTime * 2.,\n            0.5,\n            0.5 + cos(iTime + PI/4. * i)/10.,\n            0.05 + sin(iTime + PI/4. * i)/10.,\n            0.05,\n            vec3(0.0, 0.5, 0.5) - vec3(cos(iTime + PI/4. * i)/2.)\n        );\n        background = mix(background, foreground, foreground.a);\n        // BLACK CUBE OUTLINE\n        foreground = cube(\n            uv,\n            vec2(-2. + i, 0.),\n            iTime * 2.,\n            0.5,\n            0.5 + cos(iTime + PI/4. * i)/10.,\n            0.05 + sin(iTime + PI/4. * i)/10.,\n            0.75,\n            vec3(0.0)\n        );\n        background = mix(background, foreground, foreground.a);\n        // WHITE CUBE\n        foreground = cube(\n            uv,\n            vec2(-2. + i, 0.),\n            iTime * 2.,\n            0.5,\n            0.5 + cos(iTime + PI/4. * i)/10.,\n            0.05 + sin(iTime + PI/4. * i)/10.,\n            0.25,\n            vec3(0.5) + vec3(cos(iTime + PI/4. * i)/2.)\n        );\n        background = mix(background, foreground, foreground.a);\n    }\n\n    // Output to screen\n    fragColor = background;\n}","name":"Image","description":"","type":"image"}]}