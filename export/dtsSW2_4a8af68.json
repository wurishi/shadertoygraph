{"ver":"0.1","info":{"id":"dtsSW2","date":"1675387518","viewed":105,"name":"raytracing chat gpt 2.0","username":"DeDog","description":"raytracing chat gpt 2.0","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SPHERES 3\n#define AMBIENT 0.1\n#define DIFFUSE 0.7\n#define SPECULAR 0.2\n#define SHININESS 50.0\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\nSphere spheres[NUM_SPHERES] = Sphere[](\n    Sphere(vec3(-1.0, 0.0, -3.0), 1.0, vec3(1.0, 0.0, 0.0)),\n    Sphere(vec3(0.0, -1.0, -2.0), 1.0, vec3(0.0, 1.0, 0.0)),\n    Sphere(vec3(1.0, 0.0, -4.0), 1.0, vec3(0.0, 0.0, 1.0))\n);\n\nvec3 lightPos = vec3(0.0, 0.0, -2.0);\nvec3 viewPos = vec3(0.0, 0.0, 0.0);\n\nvec3 trace(vec3 rayOrigin, vec3 rayDirection, out int hitSphereIndex)\n{\n    float tMin = 9999999999999.;\n    vec3 pointOnSphere;\n    hitSphereIndex = -1;\n\n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        Sphere sphere = spheres[i];\n        vec3 oc = rayOrigin - sphere.center;\n        float a = dot(rayDirection, rayDirection);\n        float b = 2.0 * dot(oc, rayDirection);\n        float c = dot(oc, oc) - sphere.radius * sphere.radius;\n        float discriminant = b * b - 4.0 * a * c;\n\n        if (discriminant > 0.0)\n        {\n            float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n            float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n            if (t1 > 0.0 && t1 < tMin)\n            {\n                tMin = t1;\n                hitSphereIndex = i;\n                pointOnSphere = rayOrigin + rayDirection * t1;\n            }\n\n            if (t2 > 0.0 && t2 < tMin)\n            {\n                tMin = t2;\n                hitSphereIndex = i;\n                pointOnSphere = rayOrigin + rayDirection * t2;\n            }\n        }\n    }\n\n    return pointOnSphere;\n}\n\nvec3 getNormal(vec3 pointOnSphere, int hitSphereIndex)\n{\n    Sphere sphere = spheres[hitSphereIndex];\n    vec3 normal = pointOnSphere - sphere.center;\n    normal = normalize(normal);\n    return normal;\n}\n\nvec3 getReflectionDirection(vec3 incomingRay, vec3 normal)\n{\n    vec3 reflectionDirection = incomingRay - 2.0 * dot(incomingRay, normal) * normal;\n    reflectionDirection = normalize(reflectionDirection);\n    return reflectionDirection;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = iResolution.xy / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.;\n    vec2 uv = fragCoord.xy / iResolution.y - 0.5 * vec2(aspectRatio.x, 1.0);\n    uv.y *= -1.0;\n    vec3 rayOrigin = vec3(0.0, -2.0, 2.0) + mouse.x * vec3(2.0, 0.0, 0.0) + mouse.y * vec3(0.0, 2.0, 0.0);\n    vec3 rayDirection = normalize(vec3(uv, -1.0));\n    int hitSphereIndex;\n    vec3 pointOnSphere = trace(rayOrigin, rayDirection, hitSphereIndex);\n    if (hitSphereIndex == -1)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n    vec3 normal = getNormal(pointOnSphere, hitSphereIndex);\n    vec3 lightDirection = normalize(lightPos - pointOnSphere);\n    vec3 viewDirection = normalize(viewPos - pointOnSphere);\n    vec3 reflectionDirection = getReflectionDirection(lightDirection, normal);\n    vec3 diffuse = spheres[hitSphereIndex].color * DIFFUSE * max(0.0, dot(lightDirection, normal));\n    vec3 specular = vec3(1.0, 1.0, 1.0) * SPECULAR * pow(max(0.0, dot(reflectionDirection, viewDirection)), SHININESS);\n    vec3 ambient = spheres[hitSphereIndex].color * AMBIENT;\n    fragColor = vec4(diffuse + specular + ambient, 1.0);\n}\n\n\n   \n","name":"Image","description":"","type":"image"}]}