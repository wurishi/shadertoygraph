{"ver":"0.1","info":{"id":"tdGGzz","date":"1608108804","viewed":49,"name":"Raymarch testing ","username":"DarkKiwi","description":"I try raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCHING_MAX_ITER 200\n#define MARCHING_MIN_DISTANCE .01\n#define MARCHING_MAX_DISTANCE 1000.\n\nfloat SphereDistance(vec3 _point, vec3 _sphereOrigin, float _sphereRadius)\n{\n    return distance(_point, _sphereOrigin) - _sphereRadius;\n}\n\nfloat PlaneDistance(vec3 _point, float _yPositionPlane)\n{\n\treturn _point.y - _yPositionPlane;\n}\n\nfloat SceneMinimumDistance(vec3 _point)\n{\n    return min(PlaneDistance(_point, 0.), SphereDistance(_point, vec3(0., sin(iTime)+2.1, cos(iTime)+4.), 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.y - iResolution.xy/iResolution.y*.5)*2.;\n\n\tvec3 camPosition = vec3(0., 1., 0.);\n    vec3 camRay = normalize(vec3(uv, 1.));\n    \n    vec3 currentPosition = camPosition;\n    float distanceCounter = 0.;\n    vec3 color = vec3(1.);\n    for(int i = 0; i < MARCHING_MAX_ITER; i++)\n    {\n    \tfloat distanceRM = SceneMinimumDistance(currentPosition);\n        currentPosition = currentPosition + camRay * distanceRM;\n        if(distanceRM < MARCHING_MIN_DISTANCE || distanceCounter > MARCHING_MAX_DISTANCE)\n        {\n            color = vec3(distanceCounter/6.61);\n            \n            break;        \n        }\n        distanceCounter += distanceRM;\n        \n    }\n    \n    \n    fragColor = vec4(color ,1.0);\n}","name":"Image","description":"","type":"image"}]}