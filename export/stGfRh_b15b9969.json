{"ver":"0.1","info":{"id":"stGfRh","date":"1666530810","viewed":309,"name":"Space Colony","username":"kastorp","description":"Space colony orbiting on a distant solar system.\nexplore the internal tunnels!","likes":30,"published":1,"flags":48,"usePreview":0,"tags":["voxel","camera","space","controls"],"hasliked":0,"parentid":"7lKcDK","parentname":"3d Circuit"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Space Colony by Kastorp\n//----------------------------------\n// Controls:\n//    mouse change direction\n//    WSAD or arrows  move front/back/lef/right\n//    RF    move up/down \n//    SPACE stop\n//    QE    roll counterclockwise/clockwise \n//    \n//    ZX    zoom in/out\n//    C     PREF1 shield on/off\n//    V     PREF2 autoroll on/off\n//    B     PREF3 autostop on/off\n//    123   pixel size (1=quality, 3=framerate)\n//    TG    edit connections/face\n//\n// TODO:\n//    remove artifacts when perpendicular ray\n//    more blocks:   solar panels, turrets             \n//    3rd person view\n//    solar system planets\n//        \n//-------------------------------------------\n\nvoid mainImage( out vec4 O, in vec2 I)\n{\n    float pixelSize = get(Psize).x;\n    float zm =  get(CamP).w; \n    vec4 pref =  get(Pref); \n    vec2  renderResolution = ceil(iResolution.xy / pixelSize); \n    O = textureLod(iChannel3, I * renderResolution / iResolution.xy / iResolution.xy,0.);\n    vec2 C= vec2(iResolution.xy *.5), M=  iMouse.z>0.? iMouse.xy: C,AI=abs(I-C)*zm,FI=(I-C)/C*20.*iResolution.xy/iResolution.y;\n\n      \n   float dist=  get(ObjD).w;  \n                //texelFetch(iChannel3, ivec2(2, 0), 0).w ;// /length(get(CamV).xyz)*100.;\n   int\n       d2=int(clamp(floor(dist),0.,9.)),\n       d1=int(floor(fract(dist)*10.)),\n       d0=int(floor(fract(dist*10.)*10.));\n\n    vec2 cpos=vec2(-24,-18);\n    drawChars(O.xyz,FI,vec3(1,0,0),cpos,int[](chr_D,chr_I,chr_S,chr_T));cpos.x+=1.;\n    drawChars(O.xyz,FI,vec3(step(dist,.1),step(.01,dist),step(.1,dist)),cpos,int[](digit[d2],digit[d1],digit[d0]));\n    cpos=vec2(18,-18);\n    drawChars(O.xyz,FI,vec3(1,0,0),cpos,int[](chr_P,chr_R,chr_E,chr_F));\n    cpos.x+=1.;\n    for(int i=0;i<3;i++)\n    drawChar(O.xyz,FI,pref[i]>.5?vec3(0,1,0):vec3(1,1,0),cpos,pref[i]>.5 ? chr_Y:chr_N);\n    \n    vec3 v=  get(CamV).xyz;\n    float vel=length(v)*10.;\n     cpos=vec2(6,-18);\n    drawChars(O.xyz,FI,vec3(1,0,0),cpos,int[](chr_V,chr_E,chr_L));\n    cpos.x+=1.;\n    d2=int(clamp(floor(vel),0.,9.)),\n    d1=int(floor(fract(vel)*10.)),\n    d0=int(floor(fract(vel*10.)*10.));\n    drawChars(O.xyz,FI,vec3(step(vel,.1),step(.01,vel),step(.1,vel)),cpos,int[](digit[d2],digit[d1],digit[d0]));\n     \n   O+=vec4(1,0,0,0)*step(AI.x,C.x*.1)*step(AI.y,zm);\n   O+=vec4(1,0,0,0)*step(AI.y,C.y*.1)*step(AI.x,zm);\n     \n   \n   O+=vec4(1,0,0,0)*step(C.x*.8,AI.x)*step(AI.x,C.x*.9)*step(abs(AI.y-C.y*.9),zm);\n   O+=vec4(1,0,0,0)*step(C.y*.8,AI.y)*step(AI.y,C.y*.9)*step(abs(AI.x-C.x*.9),zm);\n\n     //mouse & keyboard\n     float tk =C.y*.05;\n   vec3 s=segment(I,M,C);\n   if(M!=C) DRAWSEGMENT\n\n    vec4 k=get(Keys);\n\n    if(k.xy!=vec2(0)){\n        vec2 a= C*(vec2(1)+k.xy*.2),b= C*(vec2(1)-k.xy*.2);\n        vec3 s=segment(I,a,b);\n        DRAWSEGMENT\n\n    }\n    if(k.z!=0.){\n        I= abs(I-C);\n        vec3 s=segment(I,C*(2.-k.z)/10.,C*(2.+k.z)/10.);\n        DRAWSEGMENT\n    }\n    if(k.w!=0.){\n        vec2 II= I.x>C.x?I-C:C-I,a= vec2(C*.2)*vec2(1,k.w);\n        vec3 s=segment(II,a,vec2(a.x,0.));\n        DRAWSEGMENT\n    }\n   \n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    mat3 cam = getCam(ca);\n    vec3 rd=cam[2], ra=abs(rd),\n    rm= step(ra.zxy,ra)*step(ra.yzx,ra);\n    cpos=vec2(-8,-18);      drawChars(O.xyz,FI,vec3(1,0,0),cpos,int[](chr_D,chr_I,chr_R));\n    cpos.x++;  drawChar(O.xyz,FI,vec3(1),cpos,rm.x>.5?( rd.x>0.?chr_R: chr_L):rm.y>.5?( rd.y>0.?chr_U: chr_D):(rd.z>0.?chr_F: chr_B)); \n    \n    vec3 rp=(cp-vec3(0,0,1.5))*cam;\n    cpos= rp.xy/rp.z/zm*40.;\n    if(rp.z<-.1 && length(FI-cpos) <.2) O=vec4(0,1,0,0);\n    cpos+=vec2(-2.5,.2);\n    if(rp.z<-.3 ) drawChars(O.xyz,FI,vec3(0,1,0),cpos,int[](chr_E,chr_N,chr_T,chr_R,chr_Y));\n\n#ifdef DEBUG\n    vec3 mp = floor( texelFetch(iChannel3, ivec2(0, 0), 0).xyz+.5);\n    if(all(lessThan(abs(mp),vec3(3.)))){\n        int id=int(mp.z*25.-mp.y*5.+mp.x+62.);\n        cpos=vec2(-24,18);\n        drawChars(O.xyz,FI,vec3(1,0,0),cpos,int[](chr_B,chr_L,chr_O,chr_C,chr_K));cpos.x++;\n\n        drawChars(O.xyz,FI,vec3(1,0,0),cpos,int[](digit[id/100],digit[(id%100)/10],digit[id%10]));\n                      \n        ivec2 bm=  floatBitsToInt(texelFetch(iChannel0,ivec2(id,1),0)).xy;\n        cpos.x+=1.;\n        for(int i=0;i<6;i++){\n            int cid=((bm.x & (15<<(20-i*4)))>>(20-i*4)); \n            drawChar(O.xyz,FI,vec3(0,1,0),cpos,digit[cid]);\n        }\n        cpos.x+=1.;\n        for(int i=0;i<6;i++){\n            int cid=((bm.y & (15<<(20-i*4)))>>(20-i*4)); \n            drawChar(O.xyz,FI,vec3(0,1,0),cpos,digit[cid]);\n        }\n     }\n#endif     \n     \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//CIRCUIT CONFIGURATION  & Editor\n\n//setup\nconst ivec2 bmm[125]= ivec2[125]( \n    // x= 0 off / 1 on, y= 0 in / 1 out, z=todo    \n    // mask=0xBFUDRL where each digit is the hexadecimal value for the face B=back/F=front/U=up/D=down/R=right/L=left \n    // mask for each face:\n    // Back = 8 right + 4 left + 2 down + 1 up\n    // Front= 8 right + 4 left + 2 up + 1 down\n    // Up   = 8 back + 4 front + 2 left + 1 right\n    // Down = 8 back + 4 front + 2 right + 1 left\n    // Right= 8 up + 4 down + 2 front + 1 back\n    // Left = 8 up + 4 down + 2 back + 1 front\n    //------SLICE1 0-24\n    ivec2(0x003008,0x040002),ivec2(0x023200,0x030100),ivec2(0x0BFF00,0x001000),ivec2(0x043100,0x010300),ivec2(0x003080,0x040020),\n    ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),\n    ivec2(0x33CC12,0x000011),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(0x10B08A,0x030010),\n    ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),\n    ivec2(0x00330C,0x005002),ivec2(0x003300,0x004000),ivec2(0x02F300,0x030000),ivec2(0x0033C0,0x000040),ivec2(0x0033C0,0x000020),\n    //------SLICE2 25-49\n    ivec2(-1),ivec2(-1),ivec2(0x00CC00,0x000400),ivec2(-1),ivec2(-1),\n    ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),\n    ivec2(0x00CC33,0x005003),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(0x00C907,0x002100),\n    ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),\n    ivec2(-1),ivec2(-1),ivec2(0x00C000,0x001000),ivec2(-1),ivec2(-1),\n\n    //------SLICE3 50-74\n    ivec2(0x80300C,0x100000),ivec2(0xE03B0C,0x000400),ivec2(0x007D00,0x003000),ivec2(0xC03000,0x401300),ivec2(0xC92070,0x003000),\n    ivec2(0x40000E,0x300002),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(0x2350C0,0x340000),\n    ivec2(0x00C03D,0x000044),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(0x000CC3,0x000040),\n    ivec2(0xCA003A,0x000030),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(0x2000C0,0x100000),\n    ivec2(0xCC0003,0x300000),ivec2(0xCC1000,0x001000),ivec2(0x0CF000,0x001000),ivec2(0xC67090,0x300000),ivec2(0xD03090,0x000020),\n    //------SLICE4 75-99\n    ivec2(-1),ivec2(-1),ivec2(0x003CB9,0x000400),ivec2(-1),ivec2(-1),\n    ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),\n    ivec2(0xC0600A,0x100000),ivec2(0x0C10B0,0x005000),ivec2(-1),ivec2(0x0C300B,0x001000),ivec2(0x10F6C0,0x500000),\n    ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),ivec2(-1),\n    ivec2(-1),ivec2(-1),ivec2(0x00C033,0x003000),ivec2(-1),ivec2(-1),\n    //------SLICE5 100-124\n    ivec2(-1),ivec2(-1),ivec2(0x0030EC,0x500000),ivec2(-1),ivec2(-1),\n    ivec2(-1),ivec2(-1),ivec2(0xCB00BA,0x000005),ivec2(-1),ivec2(-1),\n    ivec2(-1),ivec2(0xC0200B,0x105000),ivec2(0xEF0000,0x220000),ivec2(0x5093C0,0x100000),ivec2(-1),\n    ivec2(-1),ivec2(-1),ivec2(0xFF00B3,0x040000),ivec2(-1),ivec2(-1),\n    ivec2(-1),ivec2(-1),ivec2(0xD00033,0x000005),ivec2(-1),ivec2(-1)\n);\n  \n//LF,LB,LD,LU,RB,RF,RD,RU,DL,DR,DF,DB,UR,UL,UF,UB,FD,DU,FL,FR,BU,BD,BL,BR\n//id of the connector on the same edge\nint[24] corn = int[24] (18, 22,8 ,13,23,19,9 ,12,2 ,6 ,16,21,7 ,3 ,17,20,10,14,0 ,5 ,15,11,1 ,4 );\n\nivec2 getData(int id,vec3 d){\n    vec3 mp=vec3(id%5,(id%25)/5,id/25)-vec3(2.) +d*vec3(1,-1,1);\n    if(  max(max(abs(mp.x),abs(mp.y)),abs(mp.z))>2.) return ivec2(-1);\n    \n     id+=int(d.z)*25-int(d.y)*5+int(d.x);\n    \n    return bmm[id];\n}\n\n#define T(x,y) \n// y=1: isConn, isInDir\n// y=2: isCorner(+isNb), BallDir,isStraight,isIntCorner\n// y=2:\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    ivec2 c = ivec2(fc);\n    if(c.x>125 || c.y>2) discard;\n    if(c.y==1 && c.x<125 ) {\n        vec4 psize =  get(Psize);\n        if(iFrame<5 || iResolution.x!= psize.y){ O=intBitsToFloat(bmm[c.x].xyxx);return;}\n        O= texelFetch(iChannel0,c,0);\n          //texture(iChannel0, vec2((floor(fc) + 0.5) / iResolution.xy),0.); \n            \n        vec3 mpos = texelFetch(iChannel3, ivec2(0, 0), 0).xyz,\n             imp = floor(mpos+.5),\n             amp = abs(fract(mpos+.5)-.5),camp=get(CamP).xyz;\n        if(all(lessThan(abs(imp),vec3(3.)))){\n            int id=int(imp.z*25.-imp.y*5.+imp.x+62.);\n            if(id==c.x && length(imp-floor(camp.xyz+.5))>1.){\n                ivec2 bm=  floatBitsToInt(O).xy;\n                vec3 nm= step(amp.zxy,amp)*step(amp.yzx,amp)*sign(fract(mpos+.5)-.5);\n                 \n                bool editCon=keydown(keyT), editFace= keydown(keyG);\n                if(editCon || editFace)\n                for(int i=0;i<6;i++){\n                    vec3 n,dr;\n                    getDirs(i,0,n,dr);            \n                    if(dot(n,nm)>.9) {\n                        if(editCon){\n                             int fid=((bm.x & (15<<(i*4)))>>(i*4));\n                             bm.x-= ( fid<<(i*4));\n                             fid= ((fid+1)&15);\n                             bm.x+= ( fid<<(i*4));\n                         }\n                          if(editFace){\n                             int fid=((bm.y & (15<<(i*4)))>>(i*4));\n                             bm.y-= ( fid<<(i*4));\n                             fid= ((fid+1)&7);\n                             bm.y+= ( fid<<(i*4));\n                         }\n                    }\n                }\n                O= intBitsToFloat(bm.xyxy);\n            }\n        }\n\n                     \n\n    }\n    else if(c.y==2 && c.x<125 ){\n        ivec2 bm=bmm[c.x].xy;\n        ivec4 bma =ivec4(0);\n            vec3 n,dr;\n    \n        for(int i=0;i<6;i++){\n            getDirs(i,0,n,dr);\n            ivec2 bm3 =getData(c.x, n);\n            int m3=(1<<(i+24));\n            if(bm3.x!=-1)  bma.x+=m3; //bit 24-29= isNb\n            \n            for(int j=0;j<4;j++)\n            {                  \n                getDirs(i,j,n,dr);\n                int m=(1<<(i*4+j));\n                \n                ivec2 bm2 =getData(c.x, dr);\n                int m2=( 1<< ((i*4+(j&30) + (1- (j&1)))));\n                bool isConn=  (bm.x & m)>0 ;\n                bool isStraight = (bm2.x & m2)>0 && bm2.x!=-1;\n                bool isIntCorner = ( bm.x & m)==0 && isStraight;\n                bool BallDir = isConn? ( bm.y & m )>0 : ( bm2.y & m2 )>0 ;\n                bool isCorner =  (bm.x & ( 1<< corn[(i*4+j)]))>0; \n\n                if(isCorner) bma.x += m;\n                if(BallDir) bma.y += m;\n                if(isStraight) bma.z += m;\n                if(isIntCorner) bma.w += m;\n            }\n         }\n         O=intBitsToFloat(bma);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define STROBO\n#define SHIELD\n//#define AO\n#define SHADOW .2\n#define MAX_BOUNCE 8.\n//#define DEBUG\n\n//---------------------------------\n\n#define PI 3.14159265359\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            PrevMouse = 3.,//previous mouse pos\n            RayD = 4.,     //ray direction\n            Psize = 5.,\n            Keys=  7.,     //keyboard actions\n            ObjD=  8.,     //distance from objs\n            Pref=  9.,\n            NAddr = 10.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n//Keyboard constants\nconst int KeySpc=32, keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n#define  pressed( k)  (texelFetch(iChannel1, ivec2(k, 0), 0).x > 0.5)\n#define  toggled( k) (texelFetch(iChannel1, ivec2(k, 2), 0).x > 0.5)\n#define  keydown( k) (texelFetch(iChannel1, ivec2(k, 1), 0).x > 0.5)\n\n\n//ollj quaternionRotation math\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n// LCD font (inspired by FlyGuy)\n// \n// 20 BIT\n// __5_____6___\n//|\\   /|\\   /|\n//|15 19| \\ 16|\n//8  \\  10 \\  12\n//| / \\ | / 20|\n//|/_3_\\|/_4_\\|\n//|\\   /|\\   /|\n//| 17/ | \\ 18|\n//7  \\  9  \\  11\n//| 13\\ | / 14|\n//|/_1_\\|/_2_\\|\nconst int chr_A=0x0CFC,chr_B=0xC0F7,chr_C=0x00F3,chr_D=0x0F33,chr_E=0x00FF, \n    chr_F=0x00FC,chr_G=0x4FB,chr_H=0x0CCC,chr_I=0x0300,chr_J=0x0371, \n    chr_K=0xC0C4,chr_L=0x00C3,chr_M=0xACC0,chr_N=0x6CC0,chr_O=0xF0000, \n    chr_P=0x08FC,chr_Q=0x4CF3,chr_R=0x48FC,chr_S=0x6002D,chr_T=0x0330, \n    chr_U=0x0CC3,chr_V=0x30880,chr_W=0x5CC0,chr_X=0xF000,chr_Y=0xA100,chr_Z=0x9033; \n\nint[16] digit=int[16](  0x0CF3  ,0x40300,0x087F,0x0C3B,0x40C0C, \n    0x04BF,0x04FF,0x9030,0x0CFF,0x208BD,chr_A, chr_B,chr_C,chr_D,chr_E,chr_F);\n\nvec3 segment(vec2 p,vec2 a,vec2 b) {\n    float l= length(b - a);\n    vec2 n=normalize(b - a),\n         cp=mix(a, b, clamp(dot(p - a, n) / l, 0., 1.));\n    float x = dot(p-a,n), y = length(p-a-x*n);\n    return vec3(distance(p, cp),x,y);\n}\n#define DRAWSEGMENT O=mix(O, vec4(.5,.3,.3,0),smoothstep(tk+2.,tk, s.x)*(mod(s.y-s.z +iTime*25.,tk*2.)/tk/4.));\n\nvoid drawChar(inout vec3 O, vec2 uv,in vec3 col ,inout vec2 pos, int bm)\n{   \n    if(all(lessThan(abs(uv-pos)-.5,vec2(.5)) ))\n    for(int i=0;i<20;i++){\n        bool bt = (bm & (1<<i))>0;\n        if(bt) {           \n            vec2 a,b; \n            if(i<6) {a=.5* vec2(i%2,i/2); b=a+vec2(.5,0);}\n            else if(i<12) {a=.5* vec2(i/2-3,i%2); b=a+vec2(0,.5);}\n            else if(i<16) {a= vec2(i/2-6,i%2);b=vec2(.5);}\n            else {a= vec2(i/2-8,i%2 -1 ); b=.5*vec2(-a.x+a.y+2.,a.x+a.y+1.);  a=.5*vec2(a.x+a.y+1.,a.x-a.y); }\n            a=a*vec2(.8)+vec2(.1);b=b*vec2(.8)+vec2(.1);           \n            O=mix(O,col,smoothstep(0.01,.00,-.05+segment(uv-pos,a,b).x));\n        }\n    }\n    pos+=vec2(1,0);\n}\n\n#define  drawChars(O,  uv, col, pos,  ids) for(int i_=0;i_<ids.length();i_++) drawChar(O,uv,col, pos,ids[i_]);\n\n// get coordinates from indexes\nvoid getDirs(int i, int j, out vec3 n, out  vec3 dr){    \n     n=vec3(1,0,0)*((i%2)>0?1.:-1.);\n    if(i>3)n=n.yzx;\n    else if(i>1) n=n.zxy;\n     dr= n.yzx;\n    if(j>1) dr=cross(n,dr);\n    if((j%2)>0) dr*=-1.;\n}\n\n\n//Dave Hoskins\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//controller by  michael0884 https://www.shadertoy.com/view/7tjSDh\n\nconst float mouse_sens = 300.0;\nconst float roll_speed = 1.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr || p.y > 0.) discard;\n    \n    //get previous data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);    \n    float zoom = get(CamP).w;\n    vec4 psize =  get(Psize);\n    vec3 rd =  get(RayD).xyz;\n    vec4 pref=get(Pref);\n     \n    //initialization\n    if(iFrame < 10)\n    {\n        cp = vec3(.2,.2,-5.);\n        ca = aa2q( vec3(0,1,0), PI*2./4.0);\n        mat3 cam = getCam(ca);\n        ca = qq2q(ca, aa2q(cam[0], PI*2./4.0)); \n        vec3 ro = vec3( 0);\n        rd = normalize(cp-ro);\n        pref=vec4(1,1,1,0); //autoroll, shield, autostop, tbd\n        zoom=1.;        \n    }\n    if(iFrame <10 || iResolution.x!= psize.y) psize= vec4(iResolution.x>800. ?2.:1.,iResolution.xyz);\n    \n    vec4 oldca = ca;\n\n    \n    //cam[2]=camDir, cam[0]=cam horizontal axis, cam[1]=cam vertical axis\n    mat3 cam = getCam(ca);\n    rd = cam[2];\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    \n    \n    float force =25.0 ;\n    float dt = 1./max(20.,iFrameRate);\n    \n    vec4 dist = texelFetch(iChannel3, ivec2(1, 0), 0);\n    vec3 mp=floor(cp.xyz+.5);\n    ivec2 bm=ivec2(-1); //local cell\n    for(int id=0;id<125;id++){\n        ivec2 bm2=  floatBitsToInt(texelFetch(iChannel0,ivec2(id,1),0)).xy;\n        vec3 mp2=vec3(id%5,(id%25)/5,id/25)-vec3(2.);\n        vec3 v=abs(cp-mp2)-.5;\n        \n        if(bm2.x!=-1) {\n            if(mp2==mp) bm=bm2;\n            else dist.w=min(dist.w, max(v.x,max(v.y,v.z)));\n            //todo normal...\n        }\n    }\n    if(pref.z<.5) force*=.1;\n    if(dist.w<.1) force*=.1;\n    else if(dist.w<.25) force*=.2;\n    \n    vec4 k=vec4(0);\n    \n    vec4 hit = texelFetch(iChannel3, ivec2(2, 0), 0);\n   \n    if(length(cv)*dt +.001>=hit.w) {\n       cv*=0.;// hit.w/dt*.2;\n    }\n    else if(dist.w<0.){ //collision\n        cp-= dist.xyz * (dist.w*.7-0.001) ;\n        if(dot(cv,dist.xyz)<0.) cv+=  dot(dist.xyz,cv)*1.1;\n    }else{\n         cp += dt*cv; \n         if(pref.z>.5 || pressed(KeySpc)) cv += -cv*tanh(8.0*dt);\n        //update position \n        if(pressed(keyW) || pressed(keyUp)) {cv += force*dt*cam[2]; k.z+=1.;}\n        if(pressed(keyS) || pressed(keyDn)) {cv += force*dt*cam[2]*-1.; k.z-=1.;}\n        if(pressed(keyA) || pressed(keyLe)) {cv += force*dt*cam[0]*-.3; k.x-=1.;}\n        if(pressed(keyD) || pressed(keyRi)) {cv += force*dt*cam[0]*.3; k.x+=1.;}\n        if(pressed(keyF)) {cv += force*dt*cam[1]*-.3; k.y-=1.;}\n        if(pressed(keyR)) {cv += force*dt*cam[1]*.3;  k.y+=1.;}\n    }\n    if(pressed(keyZ)) zoom /= 1.05;    \n    if(pressed(keyX)) zoom *= 1.05; \n    if(pressed(49)) psize.x=1.; \n    if(pressed(50)) psize.x=2.; \n    if(pressed(51)) psize.x=3.; \n     \n    if(keydown(keyC)) pref.x=1.-pref.x;\n    if(keydown(keyV)) pref.y=1.-pref.y;\n    if(keydown(keyB)) pref.z=1.-pref.z;\n    \n    //update camera orientation\n    vec2 dmouse = iMouse.z>0.? dt*mouse_sens/100.*(iMouse.xy - .5*iResolution.xy)/iResolution.x:vec2(0.);\n    \n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam[1], -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) {ca = qq2q(ca, aa2q(cam[2], -roll_speed*dt)); k.w+=1.;}\n    if(pressed(keyE)) {ca = qq2q(ca, aa2q(cam[2], roll_speed*dt)); k.w-=1.;}\n    if(pref.y>.5) {\n        vec3 p=fract(cp.xyz+.5)-.5,\n             ap=abs(p),\n             m= step(ap.zxy,ap)*step(ap.yzx,ap)*sign(p); //local roll\n        float dm= abs(dot(max(ap.zxy-ap,ap.yzx-ap),m)); \n         if((dm)<.07) m*=0.; //disable on edges   \n                 \n        if(bm.x==-1){\n            if(dist.w<.2) m*=-1.; else m=vec3(0,.1,0); //surface roll\n           // if(dist.w<.2) m*=-1.; else m=vec3(0,1,0); //absolute roll\n            //m=(mix(m*-1.,vec3(0,1,0),clamp(dist.w*2.,0.,1.)));\n        }\n        \n        \n        float ar= 2.*dot(cam[0],m);\n        ca = qq2q(ca, aa2q(cam[2], roll_speed*dt *ar ));  \n        if(abs(ar)>.1) k.w-=ar;\n    }\n         \n          \n    if(p.x == CamP) o = vec4(cp, zoom);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n    if(p.x == RayD) o = vec4(rd, 0);\n    if(p.x == Psize) o =psize;\n    if(p.x == ObjD) o =vec4(dist);\n    if(p.x == Keys) o =k;\n    if(p.x == Pref) o =pref;\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Renderer\n\n// global variables\nivec2 bm; //current voxel data\nivec4 bma; //current voxel neighbors\nvec3 mp; //curent voxel pos\nfloat MAXD; //max render distance\nint mode=0; //0=render, 1=mouse hit, 2=distance,3=hit\nvec3 cpoint; //closest point \nbool shield=true; //1.= active\n\n#define EPSILON 5e-4\n//SDF\n\nvoid mmin(inout vec2 a,  float b,float o){if(a.x>b) a =vec2(b,o);}\nvoid mmin(inout vec2 a,  vec2 b){if(a.x>b.x) a =b;}\nfloat corner(vec3 v) {return length(max(vec3(v.x,v.y,v.z),0.0))+min(max(v.x,max(v.y,v.z)),0.0);}\nfloat capsule(vec3 p,vec3 a,vec3 b) { return distance(p, mix(a, b, clamp(dot(p - a, normalize(b - a)) / length(b - a), 0., 1.)));}\nfloat torus( vec3 p, vec2 t ) { return length(vec2(length(p.xz)-t.x,p.y))-t.y; }\n//float qtorus( vec3 p, vec2 t ) { return max(torus(p+vec3(t.x,0,t.x),t), corner(-p-vec3(t.x))); }\nfloat sdBox(vec3 p, vec3 s) {return corner(abs(p)-s);}\nfloat sdBoxFrame( vec3 p, float b, float e){ p = abs(p)-b; vec3 q = abs(p+e)-e; return min(min( corner(vec3(p.x,q.y,q.z)), corner(vec3(q.x,p.y,q.z))), corner(vec3(q.x,q.y,p.z)));}\n//jt\nfloat cylinder(vec3 p, float R, float r, float h) { vec2 d =abs(vec2(length(p.xy) - R, p.z)) -vec2(r, h); return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0); }\nfloat cone(vec3 pp,float R, float h) {vec2  p=vec2(length(pp.xy), pp.z), a=vec2(R,0),c=vec2(0,h); return min(length(p- mix(a, vec2(0), clamp((R - p.x) / R, 0., 1.))),length(p- mix(a, c, clamp(dot(p - a, normalize(c - a)) / length(c - a), 0., 1.))))* ( p.y<0.|| p.x/R+p.y/h>1.?1.:-1.);}\nstruct Hit{\n    float d;\n    float obj;\n    bool isInside;\n};\n\n#define  GetDist( pp, type)   GetDist_( pp, type,iChannel0)\n\nvec2 GetDist_(vec3 pp,int type,sampler2D modelChannel) {\n\n    //x=glass y=buildings z=solid w=path\n    vec2 dx=vec2(1000,1);\n    vec2 dy=vec2(1000,1);\n    vec2 dz=vec2(1000,1);\n    vec2 dw=vec2(1000,1);\n    \n    float obj=1.;\n    \n     vec3 n,dr;\n     \n     // optimization, calculate once per voxel\n     vec3 mp_=floor(pp.xyz+.5);\n     if(dot(mp_-mp,mp_-mp)>0.) {\n         mp=mp_;\n         \n        if(  max(max(abs(mp.x),abs(mp.y)),abs(mp.z))>=3.) {\n             bm =ivec2(-1);bma =ivec4(0);\n        }\n        else{\n            int id=int(mp.z)*25-int(mp.y)*5+int(mp.x)+62;\n            bm=  floatBitsToInt(texelFetch(modelChannel,ivec2(id,1),0)).xy;\n            bma= floatBitsToInt(texelFetch(modelChannel,ivec2(id,2),0));\n       }\n     }\n  \n    // voxel local sdf      \n     if(bm.x!=-1){\n         vec3 p=fract(pp.xyz+.5)-.5;\n         \n          \n           //external cube\n         mmin(dz, sdBox(p,vec3(.48))-.0199,1.);\n         vec3 ap=abs(p);\n         vec3 m= step(ap.zxy,ap)*step(ap.yzx,ap);//*sign(p);\n           \n         for(int i=0;i<6;i++){\n            getDirs(i,0,n,dr);            \n            // face culling           \n            if( dot(sign(p),n)<.5) continue;\n            \n            \n            int fid=((bm.y & (15<<(i*4)))>>(i*4));\n            // face hole\n            if(fid>0) {\n               // mmin(dx,sdBox(p-.41*n,vec3(.25)-abs(n)*.18),0.);\n                \n                //mmin(dy,sdBox(p,vec3(.35)),6.);\n                vec3 pc=p*mat3(n,dr,cross(n,dr));\n                if(fid!=4){\n                    mmin(dx,sdBox(pc-vec3(.41,0,0),vec3(.07,.25,.25)),0.);\n                    mmin(dy,sdBox(pc-vec3(.30,0,0),vec3(.05,.25,.25)),6.);\n                }\n                if(fid==1){//HOUSES\n                   pc.yz=abs(pc.yz)-.12;\n                   pc.yz= pc.yz -vec2(.07)*clamp(round(pc.yz/vec2(.07)),vec2(-1.),vec2(1));\n                   mmin(dy,sdBox(pc-vec3(.35,0,0),vec3(0.005,.03,.03)),1.);\n                   pc.x-=.408;\n                   pc.x= pc.x -.02*clamp(round(pc.x/.02),-3.,1.);\n                   mmin(dy,sdBox(pc,vec3(0.008,.015,.015)),2.);\n                   mmin(dy,sdBox(pc,vec3(0.01,.012,.012)),2.);\n                }\n                                 \n                else if(fid==2){ //ENTRY\n                      mmin(dx,sdBox(pc-vec3(.44,0,0),vec3(.07)),0.);\n                    // mmin(dy,sdBox(pc-vec3(.43,0,0),vec3(0.06,.03,.03)),2.);   \n                      mmin(dy, sdBoxFrame(pc-vec3(.43,0,0),.07,.02),1.);\n                      pc.yz=abs(pc.yz)-.14;\n                      // pc.yz= pc.yz -vec2(.07)*clamp(round(pc.yz/vec2(.07)),vec2(-1.),vec2(1));\n                      mmin(dy,sdBox(pc-vec3(.35,0,0),vec3(0.005,.05,.05)),-1.);\n\n                 }\n                else if(fid==3){ //ENGINES\n                     \n                     mmin(dy,sdBox(pc-vec3(.34,0,0),vec3(0.02,.22,.22)),4.);\n                     mmin(dy,sdBox(pc-vec3(.34,0,0),vec3(0.04,.20,.18)),-1.);\n                     pc.yz=abs(pc.yz)-.12; pc.y=pc.y-.03*clamp(round(pc.y/.03),-2.,2.);\n                     mmin(dy,torus(pc.xyz-vec3(.36,.0,0),vec2(.08,.01)),8.);\n                 }\n                else if(fid==4){ //WATER SOURCE\n                     \n                    //dz.x= max(dz.x,-sdBox(pc-vec3(.42,0,0),vec3(.09,.25,.25)));\n                    mmin(dx,length(pc-vec3(.25,0,0))-0.18,0.);\n                    mmin(dy,\n                    //max(abs(length(pc-vec3(.25,0,0))-0.2)-.02,\n                    sdBox(pc-vec3(.32,0,0),vec3(.028,.22,.22)//)\n                    ),length(pc.yz)>.16? 1.:9.);\n                \n                }\n                else if(fid==5){ //FARM\n                     pc.x-=.4;\n                     pc.yz=abs(pc.yz)-.115;\n                     vec3 c= vec3(.04)*clamp( round(pc/vec3(.04)),vec3(-1,-2,-2),vec3(1,2,2));\n                     //c += hash33(c)*.02 -vec3(.01);\n                     mmin(dy,length(pc-c)-.01,7.);\n                   \n                }\n            }\n            for(int j=0;j<4;j++)\n            {\n                int m=(1<<(i*4+j));\n                bool isEdge=  (bm.x & m)>0 ;                \n                bool isIntCorner = ( bma.w & m)>0;\n                if(isEdge || isIntCorner){\n                    getDirs(i,j,n,dr);\n                    \n                    bool isCorner = ( bma.x & m)>0;\n                    bool Balldir=  (bma.y & m)>0 ;\n                    bool isStraight = ( bma.z & m)>0;\n                    vec3 cro=cross(dr,n);\n                    float sz= (isCorner?0.:isIntCorner?0.17:0.07);\n                    float pos=(!isCorner && isIntCorner)? .43:0.;    \n  \n                    vec3 pc=p*mat3(n,dr,cro);                \n                    //connection hole\n                    mmin(dx,sdBox(pc- vec3(.43,.215+sz+pos,0),vec3(.05,.265+sz,.05)),0.);\n \n                    //connection path\n                     //pc.x= pc.x -.01*clamp(round((pc.x-.415)/.01),-2.,2.)-.415;\n                     pc.x-=.43;\n                     pc.xz= abs(pc.xz)-0.03;\n                     if(fid==1 || fid==5){pos+=.3;sz-=.0;}\n                     mmin(dw, capsule(pc,vec3(0,pos-.03,0) ,vec3(0,.46+sz-(isIntCorner?.05:0.),0))-.003,5.);                 \n \n                 }\n            }\n        }     \n       dz.x=max(dz.x,-dx.x+.05); //subtract circuit\n              \n     if(!shield){      \n       dx.x=1000.;\n     }else{\n       dx.x= abs(dx.x-.001)-.007; //glass surface\n       dx.x=max(dx.x,-sdBox(p,vec3(.35)));\n       if(type!=0 ) dx.x=1000.; \n      }\n\n        mmin(dx,dy);\n        mmin(dx,dz);\n        mmin(dx,dw);\n    } \n#ifdef AO    \n    else if(type==2|| mode==2) {\n    \n        //VOID BLOCK, distance from neighbours\n        vec3 p=fract(pp.xyz+.5)-.5;\n        for(int i=0;i<6;i++){\n           \n            if(\n                (bma.x & (1<<(i+24)))>0){\n                getDirs(i,0,n,dr);\n                mmin(dz,.501 - dot(p,n),1.);\n            }\n       }         \n       mmin(dx,dz);\n    }    \n#endif    \n    //if(isMouse!=2)mmin(dx,length(pp-cpoint)-.005,5.);;\n    return dx;\n}\n\nHit RayMarch(vec3 ro, vec3 rd,float direction,bool sh) {\n\tfloat dO=0.;\n    float obj=0.;\n    vec3 col;\n    \n    vec3 ird = 1.0/rd; \n    vec3 n = ird*ro;   \n    vec3 k = abs(ird)*2.6;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if(mode!=2 &&( tN>tF || tF<0.)) return Hit(1000.,obj,false); // no intersection            \n    else dO= max(tN,0.);\n    \n    vec2  h=vec2(1000,1);\n    for(int i=0; i<150; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec3 mp =floor(p+.5);\n             \n        h=GetDist(p,sh?1:0);\n               \n        if(mode==2 )return Hit(h.x,h.y,false);\n        \n        //voxel traversal as limit        \n        vec3 sd = -ird*(p-mp) + abs(ird)*.5;\n        float t=min( min( sd.x, sd.y ), sd.z )+EPSILON;\n        mmin(h,t,-1.);\n        \n       \n        float dS = h.x*(direction==0.? sign(h.x):direction);\n        dO += dS;\n        if(dO>MAXD || abs(dS)<EPSILON) break;\n    }    \n    return Hit(dO,h.y,h.x<0.);\n}\n\nvec3 GetNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    vec3 e =vec3(EPSILON,0,0);\n    for(int i=0;i<=2+min(iFrame,0);i++){       \n        for(float j=-1.;j<=1. ;j+=2. ) n+= j*e* GetDist(p + j* e,0).x ;\n        e=e.zxy; //TdHopper trick\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=min(iFrame,0); aoi<5; aoi++ ) {\n        hr = .001 + .05*float(aoi);\n        aopos = nor * hr + pos;\n        totao += -(GetDist(aopos,2).x-hr)*sca;\n        sca *= .6;\n    }\n    return clamp(1. - 4.*totao, 0.4, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\n    float pixelSize = get(Psize).x;\n    if(pixelSize>1. && (fragCoord.x*pixelSize >iResolution.x || fragCoord.y*pixelSize  >iResolution.y)) discard;\n    if(fragCoord.x<3. && fragCoord.y<1.) {mode=int(1.+fragCoord.x); fragCoord=iMouse.z>0.? iMouse.xy/pixelSize:.5*iResolution.xy/pixelSize;}\n    vec2 uv = (fragCoord*pixelSize-.5*iResolution.xy)/iResolution.y;    \n\tvec2 m = iMouse.xy/iResolution.xy;\n   \n    vec4 camp = get(CamP); \n    vec3 ro=camp.xyz;\n\n#ifdef STROBO\n    vec4 ca = get(CamA);\n    mat3 cam = getCam(ca);\n    ca = qq2q(ca, aa2q(cam[0],camp.w*uv.y*.4));\n    ca = qq2q(ca, aa2q(cam[1], -camp.w*uv.x*.4));        \n    vec3 rd= getCam(ca)[2];\n#else        \n    mat3 cam = getCam(get(CamA));\n    vec3 rd = normalize(cam*vec3(camp.w*uv, 1.0)) ;\n#endif    \n    if(mode==3) {\n         vec3 v=get(CamV).xyz;\n         if(v!=vec3(0.)) rd=normalize( v);\n    }\n\n    MAXD=max(12.,length(ro)+3.);\n    mp=vec3(1000.);\n    vec3 col = vec3(1.);\n    float fresnel=1.;\n    bool issecond=false;\n    bool isShadow=false;\n    bool isInside=false;\n    vec3 ld=normalize(vec3(1.1,1,.9));  \n    vec4 pref = get(Pref); \n    shield= (pref.x>.5);\n    int ii=0;\n    vec3 p;\n      \n    vec4 tmp = texelFetch(iChannel3, ivec2(1, 0), 0);\n    cpoint= ro - tmp.xyz *tmp.w;\n   \n    for(float i=0.;i<MAX_BOUNCE  || isShadow ;i++){\n    \n        float direction= i==0.? 0.:\n                         isInside?-1.:1.;\n        Hit h=RayMarch(ro, rd,  direction  ,isShadow);\n        if(i==0.) isInside=h.isInside;\n        if(h.d<MAXD){\n           \n            if(mode==1) {fragColor=vec4( ro + rd * (h.d+0.01),h.obj);return;} \n            else if(mode==2)   p=ro;\n            else p = ro + rd * h.d; \n                         \n            vec3 n = GetNormal(p);\n            if(mode==2 || mode==3) {fragColor=vec4(n,h.d);return;}\n            if(isShadow){                               \n                col*=SHADOW;\n                break;\n                \n            }\n            else if(h.obj==0.){ //TRANSPARENT                \n                 float IOR=1.2 +sin(iTime*3.)*.2;//35;  \n                vec3 nIn=isInside?-n:n;\n                               \n                vec3 rOut =refract(rd,nIn,isInside?IOR: 1./IOR); \n                //rOut=rd;\n                  \n                if(dot(rOut,rOut)==0. ) {\n                     col*=vec3(.3,.1,.1);\n                    rd=reflect(-rd,nIn);   \n                    ro=p+n*.001;\n                }\n                else {\n                    rd=rOut;\n                    ro=p- nIn*.003;\n                    if(isInside ) col*=pow( vec3(.8,.5,.5),vec3( abs(h.d)*60.));\n                    isInside=!isInside;                   \n                }   \n                ii++;\n            }\n            else if(h.obj>0.){ //OPAQUE\n                \n                float dif = dot(n, ld)*.5+.5;\n                vec3 rp=fract(p+.5)-.5, ap=abs(rp), ip=  floor(p+.5);\n                \n                int id=int(ip.z*25.-ip.y*5.+ip.x+62.);\n                float MS=.025, ST=.005; //3d version of maze by FabriceN: https://www.shadertoy.com/view/lt2cRR \n                vec3 alb = h.obj==1.? vec3(1.-.3*smoothstep(0.6,.9, mod( (p/MS) [ int( 1e4*length(ceil(p/8./MS)) ) % 3 ] ,8. ))):\n                           h.obj==5.? vec3(.8,.8,.2) *(.5+.5*step(0.,sin(p.x/ST+iTime)*sin(p.y/ST+iTime)*sin(p.z/ST+iTime))):\n                           h.obj==2.? mix(vec3(.4,.6,.8),vec3(.0,.1,.1),step(.015,mod(max(max(ap.x,ap.y),ap.z),.02))):\n                           h.obj==4.? vec3(0,.05,.05):\n                           h.obj==3.? vec3(.2,.4,.6):\n                           h.obj==6.? vec3(.2,.2,.2):\n                           h.obj==7.? vec3(0.05,0.8,0.16):\n                           h.obj==8.? vec3(0.80,0.17,0.69):\n                           h.obj==9.? vec3(0.1,0.1,0.8):\n                                      vec3(.0);\n                vec2 pos=vec2(-7.5);\n                \n                vec3 m= step(ap.zxy,ap)*step(ap.yzx,ap);\n                vec2 uv= m.x>0.?rp.yz *vec2(-sign(rp.x),1): m.y>0.? rp.zx*vec2(-sign(rp.y),1)  :rp.xy *vec2(-sign(rp.z),1) ; \n                \n                if(h.obj==1.)  drawChars(alb,uv*16.,vec3(0),pos,int[](digit[id/100],digit[(id%100)/10],digit[id%10]));\n                      \n                col *=alb * vec3(dif);\n                //highlight mouse selection:\n                vec3 mpos = texelFetch(iChannel3, ivec2(0, 0), 0).xyz,\n                      imp = floor(mpos+.5),\n                      amp = abs(fract(mpos+.5)-.5);\n                if(length(imp-ip)<.5 && length(imp-floor(camp.xyz+.5))>1.){\n                     \n                    vec3 mm= step(amp.zxy,amp)*step(amp.yzx,amp);\n                    if(mm==m) col*=vec3(0.8,1.2,0.8);\n                    //else col*=vec3(1,1,0);\n                }\n#ifdef AO\n                float  ao = calcAO(p, n);\n                col *= mix(ao,1.,.0);\n#endif\n                ro=p+n*.001;\n                rd=ld;\n                isShadow=(mode==0 );\n                isInside=false;\n                if(dot(n,ld)<0. ||h.d<0.) { col*=SHADOW; break;}\n            }\n            else if(h.obj==-1.){ //METAL         \n                ro=p+n*.001;\n                rd=reflect(rd,n);\n                if(!issecond) fresnel=pow(1.-dot(rd,n),2.); \n                col*=(1.- fresnel)*vec3(.3);\n                issecond=true;\n                isInside=false;\n                ii++;\n            }           \n        }\n        else{  //NO HIT \n            if(!isShadow ){\n               \n                vec3 a=  texture(iChannel1, rd*6.).xyz,\n                     l=max(dot(rd,ld)*vec3(1),(1.7 -pow(abs(rd.y),.1)*.63 )* (length(a)*.6+a*.1)),//hash13(rd*11.1));\n                     bcolor=vec3(0.3,0.2,.9)*(.01+.9*pow(l*.5+.51,vec3(150.))+.1*pow(l*.6+.41,vec3(10.)));\n                col*=clamp(bcolor,vec3(0),vec3(1));  \n                \n            }\n            break;\n        }\n        if(max(max(col.x,col.y),col.z)<.01) break;\n    }     \n    \n    if(ii>7) col*=0.;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    if(mode==2 || mode==3) {fragColor=vec4(0,0,0,MAXD);return;}\n    if(mode==1) fragColor=vec4(MAXD);\n   \n    else fragColor = vec4(col,1.0);\n}\n\n\n\n","name":"Buffer C","description":"","type":"buffer"}]}