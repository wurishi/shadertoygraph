{"ver":"0.1","info":{"id":"Ms2Bzz","date":"1499259908","viewed":266,"name":"Sand Icosahedron","username":"lsdlive","description":"My first raymarching code, Icosahedron is my favourite platonic solid.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lambert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float tmax = 20.;\nconst float distE = .01;\nconst int maxI = 64;\n\nconst vec3 bg_color = vec3(0.3, 0.1, 0.2);\n\n\n\n// From : https://www.pouet.net/topic.php?which=7931\nvec3 n4 = vec3(0.577, 0.577, 0.577);\nvec3 n5 = vec3(-0.577, 0.577, 0.577);\nvec3 n6 = vec3(0.577, -0.577, 0.577);\nvec3 n7 = vec3(0.577, 0.577, -0.577);\nvec3 n8 = vec3(0.000, 0.357, 0.934);\nvec3 n9 = vec3(0.000, -0.357, 0.934);\nvec3 n10 = vec3(0.934, 0.000, 0.357);\nvec3 n11 = vec3(-0.934, 0.000, 0.357);\nvec3 n12 = vec3(0.357, 0.934, 0.000);\nvec3 n13 = vec3(-0.357, 0.934, 0.000);\n\nfloat icosahedral(vec3 p, float e, float r) {\n\tfloat s = pow(abs(dot(p, n4)), e);\n\ts += pow(abs(dot(p, n5)), e);\n\ts += pow(abs(dot(p, n6)), e);\n\ts += pow(abs(dot(p, n7)), e);\n\ts += pow(abs(dot(p, n8)), e);\n\ts += pow(abs(dot(p, n9)), e);\n\ts += pow(abs(dot(p, n10)), e);\n\ts += pow(abs(dot(p, n11)), e);\n\ts += pow(abs(dot(p, n12)), e);\n\ts += pow(abs(dot(p, n13)), e);\n\ts = pow(s, 1. / e);\n\treturn s - r;\n}\n\nvec2 rotate(vec2 p, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat2(c, s, -s, c) * p;\n}\n\n// from: http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\nfloat wigglies(vec3 p) {\n\tfloat c1 = 20., c2 = 0.03;\n\treturn cos(p.y*c1)*c2;\n}\n\n\nfloat map(vec3 p) {\n\n\tp -= vec3(.0, .0, -1.);\n\tp.xz = rotate(p.xz, -iTime * .7);\n\n\n\tvec3 icoPos = vec3(.0, -0.2, .0);\n\tfloat ico = icosahedral(p - icoPos, 50., 1.2);\n\n\tfloat sand = p.y + 1.8 + .3 * cos(1.5 * p.z) * .4 * sin(4. * p.x);\n\n\treturn min(ico + wigglies(p * 0.5 * (sin(4. * iTime))), sand);\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n\n\tfor (int i = 0; i < maxI; i++) {\n\t\tvec3 p = ro + t * rd;\n\t\tfloat d = map(p);\n\t\tif (d < distE) break;\n\t\tif (t > tmax) {\n\t\t\tt = tmax;\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t}\n\n\treturn t;\n}\n\nfloat shadow(vec3 ro, vec3 rd) {\n\tfloat k = 4.0;\n\tfloat t = 0.1;// sligthly above the point to avoid intersection with the point\n\n\tfloat shadowI = 1.0;\n\n\tfor (int i = 0; i < maxI; i++) {\n\t\tvec3 p = ro + t * rd;\n\t\tfloat d = map(p);\n\t\tif (d < distE) {\n\t\t\treturn 0.;\n\t\t}\n\n\t\tif (t > tmax) {\n\t\t\tt = tmax;\n\t\t\tbreak;\n\t\t}\n\n\t\tshadowI = min(shadowI, k*d / t);\n\n\t\tt += d;\n\t}\n\n\treturn shadowI;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.001, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// from: http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\nvec3 applyFog(vec3 col, float dist) {\n\treturn mix(col, bg_color, 1.0 - exp(-0.01*dist*dist));\n}\n\n\nvec3 render(vec3 ro, vec3 rd, float t) {\n\tvec3 c = vec3(1.);\n\tvec3 p = ro + t * rd;\n\n\t//c = abs(normal(p));\n\tvec3 n = normal(p);\n\n\tvec3 lpos = vec3(1., 4., 0.);\n\tvec3 ldir = normalize(lpos - p);\n\t//vec3 ldir = -rd;\n\tfloat s = shadow(p, ldir);\n\n\tfloat lambert = max(0., dot(ldir, n));\n\n\tc = s * vec3(1.0, 0.9, 0.8) * lambert * 0.5 + 0.5;\n\tc = applyFog(c, t);\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(0., 0., 5.);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, -1.));\n\n\tfloat t = raymarch(ro, rd);\n\n\tvec3 c = bg_color;\n\n\tif (t < tmax) {\n\t\tc = render(ro, rd, t);\n\t}\n\n\tfragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}