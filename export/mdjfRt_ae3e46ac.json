{"ver":"0.1","info":{"id":"mdjfRt","date":"1690110899","viewed":110,"name":"2D Implicit Visualizer","username":"Seebone","description":"Draws implicit curves with even width and visualizes the drawing algorithm. Could use a better dropoff for larger widths.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["visualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WIDTH 4.\n#define CENTER_X 0.\n#define CENTER_Y 0.\n\n// Increase to remove inaccuracies\n#define MAX_ITERATIONS 50\n\n// Diff used for derivatives\n#define d 0.001\n\n// What counts as 0\n#define rootErr 1e-5\n\n//#define DRAW_COORDINATE_AXES\n\n#define DRAW_IMPLICIT\n#define Z_LEVEL 0.\n// Animating overrides Z_LEVEL\n#define ANIMATE_Z_LEVEL\n#define Z_LOW -.6\n#define Z_HIGH .1\n// in seconds:\n#define ANIM_PERIOD 8.\n\n// Width of implicit (in pixels)\n#define I_W 3.\n#define SHOW_GRAD\n// Increase for less red and more blue\n#define GRADIENT_MAX 4.\n\n#define DRAW_CONVERGENCE_PLOT\n\n#define ALLOW_OUTSIDE_VIEWPORT\n// 1, 2, 3 or 4\n#define COLOR_GRADIENT 1\n//#define SHOW_COLOR_DIFF\n//#define SHOW_COLOR_GRADIENT\n\n//#define DRAW_DISTANCE_FIELD\n// As fraction of screen:\n#define CURVE_SPACING .02\n// In pixels:\n#define D_W 3.\n// How many lines until max distance color is reached:\n#define DISTANCE_COLOR_MULTIPLIER 10.\n\n// Probably correct on most platforms\n#define FLT_MAX 3.402823466e+38\n#define M_PI 3.1415926535897932384626433832795\n\n// Change to any function\nfloat fBASE(float x, float y) {\n      //return x * y * (abs(x) + abs(y) - 1.);\n      //return abs(x+y) + abs(x-y);\n      return pow(3.*x*x - y*y, 2.)*y*y - pow(x*x + y*y, 4.);\n      //return pow(x*x + y*y, 2.) - 2.*(x*x - y*y);\n      //return tan(x*y*sin(y*x)*cos(x*x)) ;\n      //return cos(x*x) + sin(y*x);\n      //return cos(x * y) + y * sin(x);\n      //return x*x*y + y*y*x;\n      //return sin(y)+cos(x);\n}\n\n#ifdef ANIMATE_Z_LEVEL\nfloat f(float x, float y) {\n    //sine wave (not shifted to begin at 0):\n    return fBASE(x,y) - .5*((Z_HIGH - Z_LOW) * sin(2.*M_PI*iTime/ANIM_PERIOD) + Z_HIGH + Z_LOW);\n    \n    //triangle wave (linear motion):\n    //return fBASE(x,y) - ((2.*(Z_HIGH-Z_LOW)/ANIM_PERIOD) * abs(mod(iTime-ANIM_PERIOD/4., ANIM_PERIOD) - (ANIM_PERIOD/2.)) + Z_LOW);\n}\n#endif\n#ifndef ANIMATE_Z_LEVEL\nfloat f(float x, float y) {\n    return fBASE(x,y) - Z_LEVEL;\n}\n#endif\n\nbool isInViewport(vec2 v) {\n    float HEIGHT = WIDTH * iResolution.y/iResolution.x;\n    return v.x >= CENTER_X - WIDTH/2. && v.x <= CENTER_X + WIDTH/2. && v.y >= CENTER_Y - HEIGHT/2. && v.y <= CENTER_Y + HEIGHT/2.;\n}\n\n// Map a unique color to every point\n#if COLOR_GRADIENT == 1\nvec3 cGrad(vec2 p) {\n    // Undoing all the scaling and returning a fraction\n    float HEIGHT = WIDTH * iResolution.y/iResolution.x;\n    float r = (p.x-CENTER_X)/WIDTH+0.5; // fraction along x-axis\n    float g = (p.y-CENTER_Y)/HEIGHT + 0.5; // fraction along y-axis\n    //float b = 1.-((p.x-CENTER_X)/WIDTH+0.5); // inverse fraction along x-axis\n    // Distance from upper right corner\n    float b = distance(vec2(CENTER_X + WIDTH / 2., CENTER_Y + HEIGHT / 2.), p)*inversesqrt(WIDTH * WIDTH + HEIGHT * HEIGHT);\n    return vec3(r,g,b);\n}\n#endif\n#if COLOR_GRADIENT == 2\n// Grayscale\nvec3 cGrad(vec2 p) {\n    float o = (p.x-CENTER_X)/WIDTH+0.5; // fraction along x-axis\n    return vec3(o,o,o);\n}\n#endif\n#if COLOR_GRADIENT == 3\nvec3 cGrad(vec2 p) {\n    float HEIGHT = WIDTH * iResolution.y/iResolution.x;\n    float dDist = sqrt(WIDTH * WIDTH + HEIGHT * HEIGHT);\n    \n    float r = distance(vec2(CENTER_X-HEIGHT*1./sqrt(3.), CENTER_Y - HEIGHT / 2.), p)/(2.*HEIGHT/sqrt(3.));\n    float g = distance(vec2(CENTER_X, CENTER_Y + HEIGHT/2.), p)/(2.*HEIGHT/sqrt(3.));\n    // Distance from upper right corner\n    float b = distance(vec2(CENTER_X+HEIGHT*1./sqrt(3.), CENTER_Y - HEIGHT / 2.), p)/(2.*HEIGHT/sqrt(3.));\n    return vec3(r,g,b);\n}\n#endif\n#if COLOR_GRADIENT == 4\nvec3 cGrad(vec2 p) {\n    if (p.x <= CENTER_X && p.y <= CENTER_Y) {\n        return vec3(1.,0.,0.);\n    }\n    if (p.x > CENTER_X && p.y <= CENTER_Y) {\n        return vec3(0.,1.,0.);\n    }\n    if (p.x <= CENTER_X && p.y >  CENTER_Y) {\n        return vec3(0.,0.,1.);\n    }\n    if (p.x > CENTER_X && p.y > CENTER_Y) {\n        return vec3(1.,1.,1.);\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalizes x-distance to 1 while keeping aspect ratio and shifting so that (0,0) is at center of viewport.\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.x;\n    \n    uv *= WIDTH;\n    uv += vec2(CENTER_X, CENTER_Y);\n    \n    float HEIGHT = WIDTH * iResolution.y/iResolution.x;\n    \n    vec2 uv0 = uv;\n    vec3 bgCol = vec3(0., .0, .1);\n    vec3 curveCol = vec3(.2,.2,.2);\n    // need to learn hsv\n    vec3 lowCol = vec3(0.,0.,1.);\n    vec3 highCol = vec3(1.,0.,0.);\n    vec3 nearCol = vec3(1.,1.,1.);\n    vec3 farCol = vec3(1.,1.,0.);\n    vec3 col;    \n    \n    #ifndef DRAW_CONVERGENCE_PLOT\n    col = bgCol;\n    #endif\n    \n    // Algorithm\n    float fCurr;\n    vec2 fGradCurr;\n    int i = 0;\n    bool pointIsBounded = false;\n    for (; i < MAX_ITERATIONS; i++) {\n        \n        fCurr = f(uv.x, uv.y);\n        fGradCurr = vec2((f(uv.x+d, uv.y) - fCurr)/d, (f(uv.x, uv.y+d) - fCurr)/d);\n        \n  \n        // avoid division by 0\n        // Division by zero seems to do a lot more than just write infinity, it isn't caught by the bounded test\n        if ((abs(fGradCurr.x) < rootErr) && (abs(fGradCurr.y) < rootErr)) {\n            break;\n        }\n        \n        uv -= fCurr/dot(fGradCurr, fGradCurr)  * fGradCurr;\n        \n        // Checking if result is bounded\n        if (abs(uv.x) > FLT_MAX && abs(uv.y) > FLT_MAX) {\n            break;\n        }\n        \n        if (abs(fCurr) < rootErr) {\n            pointIsBounded = true;\n            break;\n        }\n    }\n    \n    // Black values represent diverging to infinity\n    #ifdef DRAW_CONVERGENCE_PLOT\n    if (pointIsBounded) {\n        #ifdef SHOW_COLOR_DIFF\n        col = cGrad(uv)-cGrad(uv0);\n        #endif\n        #ifndef SHOW_COLOR_DIFF\n        col = cGrad(uv);\n        #endif\n        }\n    \n    if (!pointIsBounded) {\n        // First is more informative, but second looks better\n        //col = bgCol;\n        col = cGrad(uv0);\n    }\n    #endif\n    \n    \n    // curve width in viewport coordinates\n    float W = WIDTH * I_W/iResolution.x;\n    #ifdef DRAW_COORDINATE_AXES\n    // Half implicit width\n    if (abs(uv0.x) <= W/4. || abs(uv0.y) <= W/4.) {\n        col = vec3(1.,1.,1.);\n    }\n    #endif\n\n    #ifdef DRAW_IMPLICIT\n    if (pointIsBounded) {\n        bool pointIsRoot = false;\n        float fDistSq = dot(uv0 - uv, uv0 - uv);\n        // this could ne optimized by only considering points inside the viewport (+the line width)\n        if (fDistSq <= W*W/4.) {\n                pointIsRoot = true;\n                #ifdef SHOW_GRAD\n                curveCol = mix(lowCol, highCol, clamp(length(fGradCurr)/GRADIENT_MAX,0.,1.));\n                #endif\n                // only calculate distance when it is needed for fading\n                float fDist = sqrt(fDistSq);\n                col = mix(curveCol, col, clamp(2.* fDist/W,0.,1.));\n            \n            //col = vec3(0.,1.,0.);\n        } \n        #ifdef DRAW_DISTANCE_FIELD\n        if (!pointIsRoot) {\n            float fDist = sqrt(fDistSq);\n            // actual spacing\n            float C = WIDTH * CURVE_SPACING;\n            // actual width\n            float D = WIDTH * D_W / iResolution.x;\n            \n            // distance to closest line\n            // https://www.desmos.com/calculator/vw99rpi455\n            float closestLineDist = abs(mod(fDist - C/2., C) - C/2.);\n            if (closestLineDist <= D/2.) {\n                //curveCol = mix(nearCol, farCol, clamp(fDist/(C*DISTANCE_COLOR_MULTIPLIER), 0., 1.));\n                if (abs(mod(fDist - C, 2.*C) - C) <= D/2.) {\n                    curveCol = nearCol;\n                } else {\n                    curveCol = farCol;\n                }\n                col = mix(curveCol, col, clamp(2.*closestLineDist/D,0., 1.));\n            }\n        }\n        #endif\n    }\n    #endif\n    \n    #ifdef SHOW_COLOR_GRADIENT\n    col = cGrad(uv0);\n    #endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}