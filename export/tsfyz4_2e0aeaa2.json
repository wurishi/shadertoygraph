{"ver":"0.1","info":{"id":"tsfyz4","date":"1584239558","viewed":927,"name":"COVID-19","username":"charstiles","description":"I am isolated & spent my day making the corona virus..\nI originally made this in shawnlawson.github.io/The_Force/ \nIt was too heavy for ST but I implemented a naive blur on the depth and posted a video of it here:instagram.com/p/B9wgtRzFjhs/","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","blob","spheretrace","virus","coronavirus","covid19"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat PI = 3.1415;\nfloat PHI = 1.61803398874989;\nconst int steps = 16;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// this function from https://www.shadertoy.com/view/wtSSWh\nfloat n(vec2 u){\n    vec4 d=vec4(.106,5.574,7.728,3.994),q=u.xyxy,p=floor(q);\n    ++p.zw;\n    q-=p;\n    p=fract(p*d.xyxy);\n    d=p+d.wzwz;\n\td=p.xxzz*d.ywyw+p.ywyw*d.xxzz;\n    p=fract((p.xxzz+d)*(p.ywyw+d));\n    p=cos(p*=iTime+d)*q.xxzz+sin(p)*q.ywyw;\n    q*=q*(3.-2.*q);\n    p=mix(p,p.zwzw,q.x);\n    return mix(p.x,p.y,q.y);\n}\n\n// these three functions are from http://mercury.sexy/\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n    return fOpIntersectionRound(a, -b, r);\n}\n\n\nfloat virusHead (float p){\n    \n    return cos(p);//+ noise(abs(p));\n}\n\nfloat modBlob(inout vec3  p){\n        float sz = 0.;\n    if (p.x < max(p.y, p.z)){ \n        p = p.yzx;\n        //sz+=.007;\n    }\n    if (p.x < max(p.y, p.z)){ \n       // sz-=0.05;\n        p = p.yzx;}\n\n    return sz;\n    \n}\n\nfloat bFunct(vec3 p, vec3 savedP){ // this function places nubs around sphere\n   return  max(max(max(\n        dot(p, normalize(vec3(1., 1, 1))),\n        dot(p.xz, normalize(vec2(PHI+1., 1.)))),\n        dot(p.yx, normalize(vec2(1., PHI )))),\n        dot(p.xz, normalize(vec2(1., PHI ))));\n    \n}\n\nfloat bloby(vec3 p) {\n    p = abs(p);\n    vec3 savedP = p;\n    float sz = 1.3;\n    sz += modBlob(p);\n    float b = bFunct(p,savedP);\n    float l = length(p);\n    \n    float nub =(1.01 - b / l)*(PI / .04) - n(savedP.xy*20.);\n        \n    float sploops = l - sz - 0.09 * cos(min(nub, (PI)));\n    \n    return fOpDifferenceRound (sploops,l-1.38, 0.15); // just ge tthe nubs\n}\n\n\nfloat virus(vec3 p) {\n    vec3 savedP = p;\n    p = abs(p);\nfloat sz = 1.2;\n sz += modBlob(p);\n    float b = bFunct(p,savedP);\n        \n    float l = length(p);\n    return l - sz - 0.3 * (3. / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.15), PI )) +( n(savedP.xy*20.) *0.01)+  n(savedP.zy*17.) *0.03;\n}\n//from http://mercury.sexy/\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 scene(vec3 ray ){\n    float time = iTime;\n    float floor = (ray.y + 1.2) - \n        cos(ray.x * 10.)* 0.2 - sin(ray.y* 10.);\n    float radius = 0.5;\n    \n    \n   // ray = mod(ray, modSpace) - 0.5*modSpace;\n    \n    ray = ray - vec3(0.,0.,2.0);\n    vec3 ray2 = ray;\n    vec3 ray3 = ray;\n        \n    pR(ray2.yz,time/3. + n((vec2(time/3. ) / 2.)) * 0.2);\n    pR(ray3.yz,time/3.);\n    \n    vec3 ray4 = mix(ray2,ray3,(sin(time)/5.) + 1.);\n    \n    pR(ray4.xz, n(vec2(time/4.) ) );\n    \n    pR(ray4.xy, 0.2*n(vec2(time) ) ); \n    float blob = bloby(ray4);\n    float virus = virus(ray4);\n\t\n    float ret = smin(blob,virus,.8  + (0.08* sin(time))) ;\n    \n    return vec2( ret,length(ray4)-0.5) ;//smin(smin(blob, sphere,0.6), sphere2,0.6) ;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    float smallNumber = 0.002;\n    vec3 n = vec3(\n    scene(vec3(p.x + smallNumber, p.yz)).x -\n    scene(vec3(p.x - smallNumber, p.yz)).x,\n    scene(vec3(p.x, p.y + smallNumber, p.z)).x -\n    scene(vec3(p.x, p.y - smallNumber, p.z)).x,\n    scene(vec3(p.xy, p.z + smallNumber)).x -\n    scene(vec3(p.xy, p.z - smallNumber)).x );\n\n\treturn normalize(n);\n}\n\nfloat lighting(vec3 origin, vec3 dir, vec3 normal) {\n    vec3 lightPos = vec3(12,12,1);//vec3(cos(time) +12., sin(time), 12.);\n    vec3 light = normalize(lightPos - origin);\n\n    float diffuse = max(0., dot(light, normal));\n    vec3 reflectedRay = 1.0 * dot(light, normal) * normal - light;\n\n    float specular = max(0., (pow(dot(reflectedRay, light),5.))) * sin(iTime* 3.)* 0.3;\n\n    float ambient = 0.03;\n\n    return ambient + diffuse + specular;\n\n}\n\n\nvec4 trace(vec3 rayOrigin, vec3 dir){\n    vec3 ray = rayOrigin;\n    float dist = 0.;\n        \n    float totalDist = 0.;\n    float maxDist = 3.;\n    vec2 holder;\n    float redCol;\n    \n    for (int i = 0; i < steps ; i++){\n        holder = scene(ray);\n        dist = holder.x;\n        redCol = holder.y;\n        \n        if(dist < 00.04){\n            vec4 distCol = vec4(1. - vec4(totalDist/maxDist));\n            vec4 lightingCol = vec4(lighting(rayOrigin,dir,estimateNormal(ray)));\n            vec4 col = lightingCol + vec4(pow(redCol,4.),0,0,0);//+ vec4(length(vec3(pow(length(ray),1.)))*0.3,0,0,0);//mix(lightingCol , vec4(distCol),distCol.x);\n           \n            return col;\n        } \n        totalDist += dist;\n        ray += dist * dir;\n        if (totalDist > maxDist){\n            break;\n            \n        }\n    } \n \n\n    return vec4(n(rayOrigin.xy*2.0) * (1.6-length(rayOrigin.xy)));\n}\nvec3 lookAt(vec2 uv, vec3 camOrigin, vec3 camTarget){\n\tvec3 zAxis = normalize(camTarget - camOrigin);\n\tvec3 up = vec3(0,1,0);\n\tvec3 xAxis = normalize(cross(up, zAxis));\n\tvec3 yAxis = normalize(cross(zAxis, xAxis));\n\n\tfloat fov = 2.;\n\n\tvec3 dir = (normalize(uv.x * xAxis + uv.y * yAxis + zAxis * fov));\n\n\treturn dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = (uv *2.)-1.;\n\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 rayOrigin = vec3(uv.x + n(vec2(time))*0.05,uv.y + n(vec2(time/3.))*0.03, 0.); // TODO make it so that the bg moves more than the foreground so it looks like the fbm is far away\n    vec3 camOrigin = vec3(0, 0., -1.);\n\n    vec3 camTarget = camOrigin+ vec3(sin(time/10.),cos(time/10.), 2);\n\n    vec3 direction = lookAt(uv, camOrigin, camTarget);\n\n\n    fragColor = (trace(rayOrigin, direction));\n}","name":"Image","description":"","type":"image"}]}