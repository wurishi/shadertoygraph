{"ver":"0.1","info":{"id":"NdfGDj","date":"1616533137","viewed":92,"name":"Stranded in the desert","username":"csgradle","description":"my second raymarching project. mouse to control zoom\n\ntried to take what i learned from blender shaders and apply it here. had to guess on a lot of things but it looks nice!\n\nfeedback is appreciated\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ray"],"hasliked":0,"parentid":"fdX3WB","parentname":"Raymarching 6234"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 700.\n#define MIN_HIT 0.01\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nvec3 rotation(vec3 point, vec3 axis, float angle){ // https://www.shadertoy.com/view/Wtl3zN\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n// https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdOctahedron( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec3 opRep( in vec3 p, in vec3 c) {\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n\n\nfloat getDist(vec3 p) {\n    float dist = MAX_DIST; \n    float flooring = p.y+noise(p.xz*0.1)*5. + noise(p.xz*10.)*0.03 +noise((p.xz+vec2(-10.))*0.02)*20.;\n    if(flooring < dist) {\n        dist = flooring;\n    } \n    float octa = sdOctahedron(p-vec3(0, -4., 0.), 0.5);\n    if(octa < dist) {\n        dist = octa;\n    }\n    \n    float subtractPlane = p.y-(100.3);\n    float cloudPlane = p.y-(100.)+noise(p.xz*0.01)*10.+noise(p.xz*0.4)*1.;\n    float cut = max(cloudPlane, -subtractPlane);\n    dist = min(dist, cut);\n    \n\n    return dist;\n}\nfloat getMat(vec3 p) {\n    float mat = 0.;\n    float dist = MAX_DIST; \n    float flooring = p.y+noise(p.xz*0.1)*5. + noise(p.xz*10.)*0.03 +noise((p.xz+vec2(-10.))*0.02)*20.;\n    if(flooring < dist) {\n        dist = flooring;\n        mat = 1.;\n    } \n    float octa = sdOctahedron(p-vec3(0, -4., 0.), 0.5);\n    if(octa < dist) {\n        dist = octa;\n        mat = 2.;\n    }\n    float subtractPlane = p.y-(100.3);\n    float cloudPlane = p.y-(100.);\n    float cut = max(cloudPlane, -subtractPlane);\n    if(cut < dist) {\n        dist = cut;\n        mat = 3.;\n    }\n    return mat;\n}\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = getDist(p);\n    vec3 n = d-vec3(getDist(p-e.xyy), getDist(p-e.yxy), getDist(p-e.yyx));\n    return normalize(n);\n}\nfloat rayMarch(vec3 ro, vec3 rd) { // x is distance\n\n    float rayDist = 0.;\n    float mat = 0.;\n    for(int step = 0; step < MAX_STEPS; step++) {\n        vec3 pos = ro + rd*rayDist;\n        float distanceHit = getDist(pos);\n        rayDist += distanceHit;\n        if(distanceHit < MIN_HIT || abs(rayDist) > MAX_DIST) break;   \n    }\n    return rayDist;\n}\nfloat shadow(vec3 ro, vec3 rd) { // x is distance, y is shadow value\n    float res = 1.0;\n    float k = 100.;\n    for( float t=MIN_HIT*1.1; t<MAX_DIST; )\n    {\n        float h = getDist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\nvec3 getLight(vec3 p, vec3 sun) {\n    vec3 col = vec3(1.);\n    vec3 n = getNormal(p);\n    float lighting = dot(n, normalize(sun-p));\n    lighting = clamp(lighting, 0., 1.)+0.;\n    \n    float shade = shadow(p+n*MIN_HIT*1.1, normalize(sun-p));\n    lighting = lighting * clamp((shade+0.8),0.,1.);\n    \n    float mat = getMat(p);\n    if(abs(mat-1.) < 0.1) {\n        vec3 sand = vec3(1.,1.,0.9);\n        //col = sand*step(fract(p.x), 0.5) + sand*step(fract(p.z), 0.5)*.3;\n        //col = sand* (p.y+3.)*0.2;\n        col = sand;\n    } else if(abs(mat-2.) < 0.1) {\n        col = vec3(1.,0,0);\n    } else if(abs(mat-3.) < 0.1) {\n        col = vec3(1.);\n        return col;\n        \n    }\n    return col*lighting;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = map(iMouse.y/iResolution.y,0.,1.,1.7, 30.);\n    vec2 uv =  ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    vec3 col = vec3(100., 100., 100);\n    \n    vec3 rayOrigin = vec3(sin(0.5*iTime+3.1415)*zoom,-5. + zoom*0.5, cos(0.5*iTime+3.1415)*zoom);\n    vec3 rayDir = normalize( \n                   rotation( \n                       vec3( uv.x, uv.y, 1.),\n                       vec3(0., 1., 0.),\n                       -0.5*iTime\n                       ) );\n    vec3 sun = vec3(0., 500., 100.);\n    \n    \n    float d = rayMarch(rayOrigin, rayDir);\n    vec3 p = rayOrigin+rayDir*d;    \n    vec3 l = mix(vec3(0.6, 0.6, 1.), vec3(1.), uv.y);\n    if(d<MAX_DIST) {\n        l = getLight(p, sun) + d/MAX_DIST*0.6;\n    }\n    col = l;\n    \n    // gamma correction\n    col = vec3(col.x*col.x, col.y*col.y, col.z*col.z);\n    fragColor = vec4(col,1.);\n} \n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}