{"ver":"0.1","info":{"id":"Ml2cDK","date":"1510273944","viewed":700,"name":"Radar Music Visualizer","username":"laserdog","description":"Radar that moves to the music.","likes":10,"published":1,"flags":64,"usePreview":0,"tags":["radar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MsBXRR","filepath":"https://soundcloud.com/binster/clockwork","previewfilepath":"https://soundcloud.com/binster/clockwork","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 points[15];\n    points[0] = vec2(.1, .1);\n    points[1] = vec2(.15, -.2);\n    points[2] = vec2(-.3, .05);\n    points[3] = vec2(-.25, -.1);\n    points[4] = vec2(-.12, .23);\n    points[5] = vec2(.3, .28);\n    points[6] = vec2(.11, .35);\n    points[7] = vec2(.4, -.4);\n    points[8] = vec2(-.223, .3);\n    points[9] = vec2(.4, -.18);\n    points[10] = vec2(.32, -.1);\n    points[11] = vec2(.2, -.32);\n    points[12] = vec2(-.13, .15);\n    points[13] = vec2(-.102, -.17);\n    points[14] = vec2(-.25, -.31);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    float dist = length(uv);\n    \n    float speed = .75;\n    float angle = mod(-iTime * speed, 2. * PI);\n    float clippedGreen = 0.;\n\n    // draw outer ring\n    float containerRadius = .475;\n    float clipToRadius = clamp(floor(containerRadius / dist), 0., 1.);\n    float containerThickness = max(.01, .75 * (pow(clamp(texture(iChannel0, abs(uv)).r, .1, 2.), 4.)\n                                   + pow(clamp(texture(iChannel0, abs(vec2(uv.y, uv.x))).r, .1, 2.), 4.)));\n    float container = smoothstep(containerRadius + containerThickness / 2., containerRadius, dist)\n        * smoothstep(containerRadius - containerThickness / 2., containerRadius, dist);\n    \n    // draw blips\n    float blipSpeed = .075;\n    float ringThickness = .01;\n    for (int x = 0; x < 15; x++) {\n    \tfloat blipDist = distance(uv, points[x]);\n        \n    \tfloat blipAngle = mod(atan(points[x].y, points[x].x) + PI * 2., PI * 2.) - PI / 3.;\n    \tfloat angleDiff = mod(angle - blipAngle, 2. * PI);\n        \n    \tfloat blipRadius = (1. - angleDiff) * blipSpeed;\n    \n    \tfloat addend = smoothstep(blipRadius, blipRadius - ringThickness / 2., blipDist)\n        \t* pow(smoothstep(0., blipRadius - ringThickness / 2., blipDist), 3.);\n        clippedGreen += max(0., mix(addend, 0., blipRadius / blipSpeed));\n    }\n    \n    // draw line from center\n    float lineThickness = .015;\n    vec2 line = normalize(vec2(cos(angle), sin(angle)));\n    float multiply = clamp(sign(dot(uv, line)), 0., 1.);\n    float distFromLine = sqrt(pow(dist, 2.) - pow(dot(uv, line), 2.));\n    clippedGreen += pow(smoothstep(lineThickness / 2., 0., distFromLine), 3.) * multiply;\n        \n    // draw grid\n    float gridIncrement = .1;\n    float gridLineThickness = 1. /iResolution.y;\n    float gridAddend = (1. - step(gridLineThickness, mod(uv.x, gridIncrement)))\n        + (1. - step(gridLineThickness, mod(uv.y, gridIncrement)));\n    clippedGreen += gridAddend;\n        \n    // draw gradient\n    float gradientAngleAmount = PI / 2.;\n    float uvAngle = mod(atan(uv.y, uv.x) + PI * 2., PI * 2.);\n    float angleDiff = mod(uvAngle - angle, 2. * PI);\n    clippedGreen += smoothstep(gradientAngleAmount, 0., angleDiff);\n                                \n    // why doesn't changing the alpha value do anything?\n    // color.a = 0.;\n    uv.x /= iResolution.x / iResolution.y;\n    uv += .5;\n    vec4 color = texture(iChannel1, uv);\n    color.g += clippedGreen * clipToRadius + container;\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}