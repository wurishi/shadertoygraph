{"ver":"0.1","info":{"id":"wlBXWD","date":"1565874717","viewed":183,"name":"Hinge","username":"gaz","description":"3d","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 A,B,C;\n\nvec2 rotate(vec2 p, float theta)\n{\n    return p * cos(theta) + vec2(-p.y, p.x) * sin(theta);\n}\n\nfloat deRoundBox(vec3 p, vec3 s, float r)\n{\n   return length(p-clamp(p,-s,s))-r;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 solve(inout vec3 p, vec3 forward, float l1, float l2)\n{\n    float len = min(length(p), l1+l2);\n    float y=(len+(l1*l1-l2*l2)/len)/2.0, x=sqrt(l1*l1-y*y);\n    p = normalize(p*vec3(1,1,-1))*len;\n    return normalize(cross(p,cross(p,forward)))*x+p/len*y;\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, float t){\n  return mix(mix(a,b,t),mix(b,c,t),t);\n}\n\nvec3 bezierHinge(vec3 a, vec3 b, vec3 c, float t)\n{\n  float k=0.7;\n  return mix(\n      mix(a,b,t*(1.0+k)),\n      mix(b,c,t*(1.0+k)-k),\n      clamp(t*(1.0+k*4.0)-k*2.0,0.0,1.0));\n}\n\nvec3 func(float t)\n{\n    return mix(bezier(A,B,C,t), bezierHinge(A,B,C,t),step(0.0,sin(iTime*0.3)));\n\t//return bezier(A,B,C,t);\n\t//return bezierHinge(A,B,C,t);\n}\n\nfloat closest(vec3 p)\n{\n    float ITR =25.0, pitch = 1.0, t = 0.5, de = 1e9;   \n    for(int j=0;j<2;j++)\n    {\n        float t0 = t-pitch*0.5;\n        pitch /= ITR;\n        for(float i=0.0; i<=ITR; i++) \n        {\n            t0 += pitch;\n            float de0=distance(p,func(t0));\n            if (de0<de)\n            {\n                de = de0;\n                t=t0;\n            }       \n        }\n    }\n    return t;\n}\n\nfloat de01(vec3 p)\n{\n    float l1=1.0,l2=1.0;\n\tA=vec3(0,0,0);\n    C= vec3(0,1.0,sin(iTime)*1.2);\n    vec3 forward = vec3(0,0,1);\n    B = solve(C,forward,l1,l2);\n    float t = closest(p);\n    vec3 u = normalize(cross(A-B,C-B));\n    vec3 w = normalize(func(t+0.01) -func(t-0.01));\n    vec3 v = cross(u,w);\n    p -= func(t);  \n    p = vec3(dot(p,u), dot(p,v),dot(p,w));\n    \n    return mix(sdTorus(p, vec2(0.2,0.1)),deRoundBox(p,vec3(0.1),0.05),step(0.0,sin(iTime*0.5)));\n    //return sdTorus(p, vec2(0.2,0.1));\n    //return deRoundBox(p,vec3(0.1),0.05);\n    //return length(p)-0.15;\n}\n\n\nfloat map(vec3 p)\n{\n    p.xz = rotate(p.xz,iTime*0.3);\n    return de01(p);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(1,-1)*0.01;\n    return normalize(\n        e.xyy*map(p+e.xyy)+e.yyx*map(p+e.yyx)+ \n        e.yxy*map(p+e.yxy)+e.xxx*map(p+e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n \tvec3 col = vec3(0.2);\n    col *= max(2.4 - length(uv), 0.0);\n    vec3 ro = vec3(0, 0.8, 3);\n    vec3 rd = normalize(vec3(uv, -2.0));\n    float ITR=80.0, t=0.0, d, a=1.0, maxd=10.0, st=1.0/ITR;\n    for(float i = 0.0; i < ITR; i++)\n    {\n        t += d = map(ro+rd*t);\n        if(d<0.001 || t>maxd) break;\n        a -= st;\n    }\n    if(d<0.001)\n    {\n        vec3 p = ro+t*rd;\n        vec3 li = normalize(vec3(1));\n        vec3 nor = calcNormal(p);\n\t    col = vec3(0.2, 0.8, 0.5);\n        col *= a*a*a; \n\t    col *= clamp(dot(nor,li),0.4,1.0);\n        col *= max(0.5+0.5*nor.y,0.0);\n        col += pow(clamp(dot(reflect(rd, nor),li),0.0,1.0),80.0);\n        col = pow(col,vec3(0.6));\n    }\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}