{"ver":"0.1","info":{"id":"l3GXzG","date":"1720094069","viewed":131,"name":"FractalFolding reccursion","username":"ozazl","description":"Idea I had. Code generated with Claude sonette-3.5","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 40 //higher number refines shapes (looses \"connectiveness\"\n#define MAX_DIST 500.0\n#define SURF_DIST 0.0001\n#define PI 3.14159265359\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nmat3 rotMat(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat3(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n    );\n}\n\nmat4 rotationMatrix4D(int axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    if (axis == 0) return mat4(c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1);\n    if (axis == 1) return mat4(c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1);\n    if (axis == 2) return mat4(c,0,0,-s, 0,1,0,0, 0,0,1,0, s,0,0,c);\n    if (axis == 3) return mat4(1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1);\n    if (axis == 4) return mat4(1,0,0,0, 0,c,0,-s, 0,0,1,0, 0,s,0,c);\n    return mat4(1,0,0,0, 0,1,0,0, 0,0,c,-s, 0,0,s,c);\n}\n\nvec4 fold4D(vec4 p, float time) {\n    for (int i = 0; i < 6; i++) {\n        float angle = time * (float(i) * 0.1 + 0.2);\n        p = rotationMatrix4D(i, angle) * p;\n        p = abs(p) - 0.5;\n        if (p.w > p.z) p.zw = p.wz;\n        if (p.z > p.y) p.yz = p.zy;\n        if (p.y > p.x) p.xy = p.yx;\n    }\n    return p;\n}\n\nfloat fractalShape(vec3 p, float scale, int iterations) {\n    vec4 p4 = vec4(p, 0.0);\n    float d = sdSphere(p, scale);\n    \n    for (int i = 0; i < iterations; i++) {\n        p4 = fold4D(p4, iTime * 0.1);\n        float newD = sdSphere(p4.xyz, scale * pow(0.5, float(i + 1)));\n        d = min(d, newD);\n    }\n    \n    return d;\n}\n\nfloat getDistance(vec3 p) {\n    float scale = 1.5;\n    p /= scale;\n    \n    float d = fractalShape(p, 1.0, 5);\n    \n    // Add surface details\n    vec4 p4 = vec4(p, 0.0);\n    for (int i = 0; i < 3; i++) {\n        p4 = fold4D(p4, iTime * 0.05);\n        float detail = fractalShape(p4.xyz, 0.2, 2);\n        d = mix(d, detail, 0.2);\n    }\n    \n    return d * scale;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDistance(p);\n        dO += dS;\n        if (dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDistance(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        getDistance(p - e.xyy),\n        getDistance(p - e.yxy),\n        getDistance(p - e.yyx));\n    return normalize(n);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n    \n    float time = iTime * 0.2;\n    float camDist = 4.0 + sin(time) * 1.5;\n    vec3 ro = vec3(camDist * sin(time), 2.0 + sin(time * 0.5), camDist * cos(time));\n    vec3 lookAt = vec3(0, 0, 0);\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f;\n    vec3 i = c + uv.x * r + uv.y * u;\n    vec3 rd = normalize(i - ro);\n    \n    float d = rayMarch(ro, rd);\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        vec3 lightPos = vec3(2.0 * sin(iTime), 5.0, 2.0 * cos(iTime));\n        vec3 l = normalize(lightPos - p);\n        float dif = clamp(dot(n, l), 0.1, 1.0);\n        float spec = pow(max(dot(r, l), 0.0), 32.0);\n        float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 5.0);\n        \n        vec3 objColor = palette(length(p) * 0.5 - iTime * 0.1);\n        col = objColor * dif + vec3(0.8) * spec + vec3(0.1, 0.3, 0.5) * fresnel;\n        \n        float ao = clamp(getDistance(p + n * 0.5) * 2.0, 0.0, 1.0);\n        col *= ao;\n    }\n    \n    vec3 bg = mix(vec3(0.0, 0.05, 0.1), vec3(0.1, 0.2, 0.3), smoothstep(-1.0, 1.0, uv.y));\n    col = mix(bg, col, smoothstep(0.0, 0.95, 1.0 - d / MAX_DIST));\n    \n    col = col / (1.0 + col);\n    col = pow(col, vec3(0.4545));\n    \n    col *= 1.0 - smoothstep(0.5, 1.5, length(uv));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}