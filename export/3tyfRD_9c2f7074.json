{"ver":"0.1","info":{"id":"3tyfRD","date":"1613934753","viewed":161,"name":"Cube Flow","username":"Patate1er","description":"I'll try to write better comments later","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sound","fft","visualization","reactive","music","audio","animation","isometric","geometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//I took some code here for raymarching renderer:\n//https://www.shadertoy.com/view/WtGcDd\n\n#define dt(speed,off) fract((iTime+off)*speed)\n#define PI acos(-1.)\n#define PI2 2.*acos(-1.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nconst float ITER = 64.;\n\nfloat hash(float seed){\n\treturn fract(sin(1.0*seed)*1000000.0);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n  p = abs(p);\n  p = max(p,p.yzx);\n  return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat wireCube (vec3 p)\n{\n    float spec = texelFetch( iChannel0, ivec2(iResolution.x-1.,iResolution.y-1.), 0 ).x;\n        \n    const float e = .03;\n    float w = .02+spec*.2;\n    float s = .5+spec*.7;\n\n    float d = max(box(p,vec3(s,s,s)), -sc(p,s-w));\n\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    //rotation\n    p.yz *= rot(-PI/6.);\n    p.xz *= rot(-PI/6.+cos(iTime*.5)*PI/24.);\n  \n    //scene\n    float d;\n  \n  if (-p.y - 2.<0.){\n      d = 99.;\n      int nb_cube = int(texelFetch( iChannel0, ivec2(0,0), 0 ).x);\n      float T = texelFetch( iChannel0, ivec2(0,0), 0 ).y;\n      vec2 spec = texelFetch( iChannel0, ivec2(iResolution.x-1.,iResolution.y-1.), 0 ).yw;\n      \n      vec4 chan;\n\n        for(int i=1;i<=nb_cube;++i){\n            ivec2 coord = ivec2(int(mod(float(i), iResolution.x)),int(floor(float(i)/iResolution.x)));\n            chan = texelFetch( iChannel0, coord, 0 );\n            \n            //déplacement cube\n            vec3 pp = p+vec3(14.-28.*float(i)/(float(nb_cube)+1.),\n                            -spec.x*2.5,\n                            16.-32.*(iTime-chan.r)/(chan.g-chan.r));\n            //rotation cube\n            if(spec.y != 0. && iTime-spec.y < T){\n                if(hash(spec.y+float(i))<.8){\n                    pp.xz*=rot((iTime-spec.y)/T*PI2);\n                }\n            }\n            d = min(d,wireCube(pp));\n        }\n    }\n    else{\n        d = -1.;\n    }\n  return d;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uu = fragCoord.xy/iResolution.xy;\n  vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n  vec3 ro = vec3(uv*5.,-20.), rd=vec3(0.,0.,1.), p=ro, col=vec3(0.,0.,.02);\n\n  bool hit = false; float O;\n\n  for (float i=0.; i<ITER; i++)\n  {\n    O = SDF(p);\n    if (O < .01)\n    {\n        if(O!=-1.){\n          hit=true;\n        }\n        break;\n    }\n    p += O*rd;\n  }\n\n  if (hit)\n  {\n    col = vec3(1.);\n  }\n\n  fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//ranges to split\nconst vec2[3] spec_split = vec2[3](vec2(0.2,0.8),\n                                vec2(0.0,0.01),\n                                vec2(0.4,0.6));\nconst vec3 f_range = vec3(1.8,0.475,1.2);\nconst vec3 a_range = vec3(.3,.03,.1);\nconst int steps = 1;//possibility to skip values for performance if steps > 1\n\nconst int n = 15; \nconst float T = 0.5;\n\n//random\nfloat hash(float seed){\n\treturn fract(sin(1.*seed)*1000000.);\n}\n\n// return 1 value at the time\nfloat spectrum(int value){\n    float ret = 0.0;\n    int splitStart = int(floor(spec_split[value].x*512.0));\n    int splitEnd = int(floor(spec_split[value].y*512.0));\n    for(int i = splitStart; i<=splitEnd;i+=steps){\n        // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n        float fft  = texelFetch( iChannel1, ivec2(i,0), 0 ).x;\n        ret+=fft;\n    }\n    if(splitStart!=splitEnd){\n        ret/=floor(float((splitEnd-splitStart)/steps));\n    }\n    return smoothstep(0.5-a_range[value],0.5+a_range[value],f_range[value]*ret);\n}\n\n//return 3 values\nvec3 spectrum(){\n    vec3 ret = vec3(0);\n    for(int i = 0; i<3; ++i){\n        ret[i] = spectrum(i);\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int i = int(floor(fragCoord.y) * iResolution.x + fragCoord.x);//!\\ FragCoord donne le milieu d'un pixel pas son index\n    \n    if(i == 0){\n        fragColor.r = float(n);\n        fragColor.g = T;\n    }\n    else if(i <= n){\n        vec4 c = texelFetch( iChannel0, ivec2(fragCoord.x,fragCoord.y), 0 );\n        //valeurs qui permettent de detecter le moment ou \n        //il faut supprimer l'objet et en créer un nouveau\n        float t = c.g;\n\n        //Si t > g, r prends la valeur de g et r est incrémenté aléatoirement\n        if(iTime > t){\n            float t2 = t+hash(iTime+float(i))*3.+2.;\n            c.xy = vec2(t,t2);\n            if(t==0.){\n                c.xy-=hash(iTime+1.+float(i))*t2;\n            }\n        }\n        fragColor = c;\n    }\n    else if(ceil(fragCoord.x) == iResolution.x && ceil(fragCoord.y) == iResolution.y){//only on last texel\n        vec4 c = texelFetch( iChannel0, ivec2(fragCoord.x,fragCoord.y), 0 );\n        c.xyz = spectrum();//music splited spectrum\n        //valeur pour faire tourner les cubes\n        if(c.w == 0. || iTime-c.w >= T){\n            if(c.z >= .5){\n                c.w = iTime;\n            }\n        }\n        fragColor = c;//music splited spectrum\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}