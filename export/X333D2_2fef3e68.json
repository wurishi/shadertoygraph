{"ver":"0.1","info":{"id":"X333D2","date":"1718219411","viewed":67,"name":"\"Josef Sans\" Font","username":"EisernSchild","description":" Font \"Josef Sans\"\n Made simple basically with lines and circles (full, half and quarter).\n Define \"ALL_GLYPHES\" to 1 to show full set.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sdf","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Josef Sans\" Font\n// Copyright (c) 2024 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n    Font \"Josef Sans\"\n    \n    Made simple basically with lines and circles (full, half and quarter).\n    \n    Define \"ALL_GLYPHES\" to 1 to show full set.\n    \n    WARNING : LONG COMPILE TIMES HERE DUE TO FULL BASIC ASCII GLYPH SET (0..127)\n*/\n\n#define ALL_GLYPHES 0\n\n#define ZOOM .23f\n#define LINE_SCROLL 1.8f\n\n#define STRING_LEN 0x20\n#define str int[STRING_LEN]\n#define PI 3.141592654f\n#define ONE_DIV(x) (1.f / x)\n#define FULL_LINE_Y (fAsc + abs(fDsc) + fLineSpc)\n\n// ascender height\nconst float fAsc = 1.f;\n// cap height\nconst float fCap = .8f;\n// mean height\nconst float fMea = .5f;\n// base height\nconst float fBse = .0f;\n// descender height\nconst float fDsc = -.35f;\n// font thickness (min .01f - max .1f)\nconst float fR = .03f;\n// constant smooth factor here for now, adjust by zoom factor\nconst float fSmooth = 0.018f;\n// helper lines ? font styles ?\nbool\n    bDrawLines = false,\n    bGlitch = false,\n    bRising = false,\n    bHollow = false,\n    bLcd = false,\n    bShowStyles = true,\n    bInvColor = true;\n// letter + line space\nconst float fLettSpc = fR, fLineSpc = 0.1f;\n\n// the width of each glyph (ASCII Idc x00-xff)\nconst float afGlyphW[256] = float[256](\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, // ASCII control chars (x00-x0f)\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, // ASCII control chars (x10-x1f)\n    .50f, .07f, .20f, .36f, .38f, .36f, .42f, .07f, .27f, .27f, .38f, .27f, .07f, .27f, .07f, .36f, //  !\"#$%&'()*+,-./    (x20-x2f)\n    .47f, .19f, .42f, .42f, .42f, .42f, .47f, .36f, .47f, .47f, .07f, .07f, .26f, .27f, .26f, .37f, // 0123456789:;<=>?    (x30-x3f)\n    .46f, .47f, .42f, .47f, .42f, .36f, .36f, .47f, .43f, .09f, .27f, .43f, .36f, .47f, .37f, .47f, // @ABCDEFGHIJKLMNO    (x40-x4f)\n    .36f, .47f, .38f, .47f, .36f, .47f, .47f, .47f, .47f, .47f, .36f, .17f, .36f, .17f, .26f, .43f, // PQRSTUVWXYZ[\\]^_    (x50-x5f)\n    .17f, .32f, .32f, .32f, .32f, .32f, .19f, .32f, .32f, .09f, .14f, .25f, .13f, .32f, .32f, .32f, // `abcdefghijklmno    (x60-x6f)\n    .32f, .32f, .19f, .32f, .18f, .32f, .32f, .44f, .32f, .32f, .32f, .22f, .06f, .22f, .32f, .00f, // pqrstuvwxyz{|}~     (x70-x7f)\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, // \n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, // TODO !! Idc x80 - xff\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, //\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, //\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, //\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, //\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, //\n    .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f, .00f  //\n    );\n\n#define ZERO 0.f\n#define CAP_Q1 (fCap * .25f)\n#define CAP_Q2 (fCap * .50f)\n#define CAP_Q3 (fCap * .75f)\n#define CAP_Q3_Q2 (CAP_Q3 * .50f)\n#define MEA_P(a) (fMea * a)\n#define MEA_Q1 (fMea * .25f)\n#define MEA_O1 MEA_P(.125f)\n#define DSC_Q2 (fDsc * .5f)\n\n#define OFFSET_X vec2(.05f, 0.f)\n#define OFFSET_Y vec2(0.f, .05f)\n#define OFFSET_X_2 vec2(.10f, 0.f)\n#define OFFSET_Y_2 vec2(0.f, .10f)\n#define OFFSET_XY_2 vec2(.1f, .1f)\n#define OFFSET_X_M vec2(MEA_P(.125f), 0.f)\n#define OFFSET_Y_M vec2(0.f, MEA_P(.125f))\n\n#define CAP_00 vec2(fRd, fCap)\n#define CAP_10 vec2(.1f + fRd, fCap)\n#define CAP_15 vec2(.15f + fRd, fCap)\n#define CAP_20 vec2(.2f + fRd, fCap)\n#define CAP_25 vec2(.25f + fRd, fCap)\n#define CAP_30 vec2(.3f + fRd, fCap)\n#define CAP_35 vec2(.35f + fRd, fCap)\n#define CAP_40 vec2(.4f + fRd, fCap)\n\n#define CQ3_00 vec2(fRd, CAP_Q3)\n#define CQ3_05 vec2(.05f + fRd, CAP_Q3)\n#define CQ3_10 vec2(.1f + fRd, CAP_Q3)\n#define CQ3_15 vec2(.15f + fRd, CAP_Q3)\n#define CQ3_20 vec2(.2f + fRd, CAP_Q3)\n#define CQ3_30 vec2(.3f + fRd, CAP_Q3)\n#define CQ3_35 vec2(.35f + fRd, CAP_Q3)\n#define CQ3_40 vec2(.4f + fRd, CAP_Q3)\n\n#define CQ2_00 vec2(fRd, CAP_Q2)\n#define CQ2_10 vec2(.1f + fRd, CAP_Q2)\n#define CQ2_15 vec2(.15f + fRd, CAP_Q2)\n#define CQ2_20 vec2(.2f + fRd, CAP_Q2)\n#define CQ2_25 vec2(.25f + fRd, CAP_Q2)\n#define CQ2_30 vec2(.3f + fRd, CAP_Q2)\n#define CQ2_35 vec2(.35f + fRd, CAP_Q2)\n#define CQ2_40 vec2(.4f + fRd, CAP_Q2)\n\n#define CQ1_00 vec2(fRd, fBse + CAP_Q1)\n#define CQ1_10 vec2(.1f + fRd, fBse + CAP_Q1)\n#define CQ1_15 vec2(.15f + fRd, fBse + CAP_Q1)\n#define CQ1_20 vec2(.2f + fRd, fBse + CAP_Q1)\n#define CQ1_25 vec2(.25f + fRd, fBse + CAP_Q1)\n#define CQ1_30 vec2(.3f + fRd, fBse + CAP_Q1)\n#define CQ1_35 vec2(.35f + fRd, fBse + CAP_Q1)\n#define CQ1_40 vec2(.4f + fRd, fBse + CAP_Q1)\n\n#define CUT_00 vec2(fRd, CAP_Q3_Q2)\n#define CUT_05 vec2(.05f + fRd, CAP_Q3_Q2)\n#define CUT_10 vec2(.1f + fRd, CAP_Q3_Q2)\n#define CUT_15 vec2(.15f + fRd, CAP_Q3_Q2)\n#define CUT_20 vec2(.2f + fRd, CAP_Q3_Q2)\n#define CUT_25 vec2(.25f + fRd, CAP_Q3_Q2)\n#define CUT_30 vec2(.3f + fRd, CAP_Q3_Q2)\n#define CUT_35 vec2(.35f + fRd, CAP_Q3_Q2)\n#define CUT_40 vec2(.4f + fRd, CAP_Q3_Q2)\n\n#define MQ0_00 vec2(fRd, fBse)\n#define MQ0_05 vec2(MEA_P(.125f) + fRd, fBse)\n#define MQ0_10 vec2(MEA_P(.25f) + fRd, fBse)\n#define MQ0_15 vec2(MEA_P(.375f) + fRd, fBse)\n#define MQ0_20 vec2(MEA_P(.50f) + fRd, fBse)\n#define MQ0_25 vec2(MEA_P(.625f) + fRd, fBse)\n#define MQ0_30 vec2(MEA_P(.75f) + fRd, fBse)\n#define MQ0_35 vec2(MEA_P(.875f)+ fRd, fBse)\n#define MQ0_40 vec2(fMea + fRd, fBse)\n\n#define MO1_00 vec2(fRd, MEA_O1)\n#define MO1_05 vec2(MEA_P(.125f) + fRd, MEA_O1)\n#define MO1_10 vec2(MEA_P(.25f) + fRd, MEA_O1)\n#define MO1_15 vec2(MEA_P(.375f) + fRd, MEA_O1)\n\n#define MO7_00 vec2(fRd, MEA_P(.875f))\n#define MO7_05 vec2(MEA_P(.125f) + fRd, MEA_P(.875f))\n#define MO7_10 vec2(MEA_P(.25f) + fRd, MEA_P(.875f))\n#define MO7_15 vec2(MEA_P(.375f) + fRd, MEA_P(.875f))\n#define MO7_20 vec2(MEA_P(.50f) + fRd, MEA_P(.875f))\n#define MO7_25 vec2(MEA_P(.625f) + fRd, MEA_P(.875f))\n#define MO7_30 vec2(MEA_P(.75f) + fRd, MEA_P(.875f))\n#define MO7_35 vec2(MEA_P(.875f) + fRd, MEA_P(.875f))\n#define MO7_40 vec2(fMea + fRd, MEA_P(.875f))\n\n#define MQ1_00 vec2(fRd, MEA_P(.25f))\n#define MQ1_10 vec2(MEA_P(.25f) + fRd, MEA_P(.25f))\n#define MQ1_15 vec2(MEA_P(.375f) + fRd, MEA_P(.25f))\n#define MQ1_20 vec2(MEA_P(.50f) + fRd, MEA_P(.25f))\n#define MQ1_25 vec2(MEA_P(.625f) + fRd, MEA_P(.25f))\n#define MQ1_30 vec2(MEA_P(.75f) + fRd, MEA_P(.25f))\n#define MQ1_35 vec2(MEA_P(.875f)+ fRd, MEA_P(.25f))\n#define MQ1_40 vec2(fMea + fRd, MEA_P(.25f))\n\n#define MQ2_00 vec2(fRd, MEA_P(.5f))\n#define MQ2_10 vec2(MEA_P(.25f) + fRd, MEA_P(.5f))\n#define MQ2_15 vec2(MEA_P(.375f) + fRd, MEA_P(.5f))\n#define MQ2_20 vec2(MEA_P(.50f) + fRd, MEA_P(.5f))\n#define MQ2_25 vec2(MEA_P(.625f) + fRd, MEA_P(.5f))\n#define MQ2_30 vec2(MEA_P(.75f) + fRd, MEA_P(.5f))\n#define MQ2_35 vec2(MEA_P(.875f)+ fRd, MEA_P(.5f))\n#define MQ2_40 vec2(fMea + fRd, MEA_P(.5f))\n\n#define MQ3_00 vec2(fRd, MEA_P(.75f))\n#define MQ3_05 vec2(MEA_P(.125f) + fRd, MEA_P(.75f))\n#define MQ3_10 vec2(MEA_P(.25f) + fRd, MEA_P(.75f))\n#define MQ3_15 vec2(MEA_P(.375f) + fRd, MEA_P(.75f))\n#define MQ3_20 vec2(MEA_P(.50f) + fRd, MEA_P(.75f))\n#define MQ3_25 vec2(MEA_P(.625f) + fRd, MEA_P(.75f))\n#define MQ3_30 vec2(MEA_P(.75f) + fRd, MEA_P(.75f))\n#define MQ3_35 vec2(MEA_P(.875f) + fRd, MEA_P(.75f))\n#define MQ3_40 vec2(fMea + fRd, MEA_P(.75f))\n\n#define MEA_00 vec2(fRd, fMea)\n#define MEA_05 vec2(MEA_P(.125f) + fRd, fMea)\n#define MEA_10 vec2(MEA_P(.25f) + fRd, fMea)\n#define MEA_15 vec2(MEA_P(.375f) + fRd, fMea)\n#define MEA_20 vec2(MEA_P(.50f) + fRd, fMea)\n#define MEA_25 vec2(MEA_P(.625f) + fRd, fMea)\n#define MEA_30 vec2(MEA_P(.75f) + fRd, fMea)\n#define MEA_35 vec2(MEA_P(.875f) + fRd, fMea)\n#define MEA_40 vec2(fMea + fRd, fMea)\n\n#define MQ5_00 vec2(fRd, MEA_P(1.25f))\n#define MQ5_05 vec2(MEA_P(.125f) + fRd, MEA_P(1.25f))\n#define MQ5_10 vec2(MEA_P(.25f) + fRd, MEA_P(1.25f))\n#define MQ5_15 vec2(MEA_P(.375f) + fRd, MEA_P(1.25f))\n#define MQ5_20 vec2(MEA_P(.50f) + fRd, MEA_P(1.25f))\n#define MQ5_25 vec2(MEA_P(.625f) + fRd, MEA_P(1.25f))\n#define MQ5_30 vec2(MEA_P(.75f) + fRd, MEA_P(1.25f))\n#define MQ5_35 vec2(MEA_P(.875f) + fRd, MEA_P(1.25f))\n#define MQ5_40 vec2(fMea + fRd, MEA_P(1.25f))\n\n#define MQ6_00 vec2(fRd, MEA_P(1.5f))\n#define MQ6_05 vec2(MEA_P(.125f) + fRd, MEA_P(1.5f))\n#define MQ6_10 vec2(MEA_P(.25f) + fRd, MEA_P(1.5f))\n#define MQ6_15 vec2(MEA_P(.375f) + fRd, MEA_P(1.5f))\n#define MQ6_20 vec2(MEA_P(.50f) + fRd, MEA_P(1.5f))\n#define MQ6_25 vec2(MEA_P(.625f) + fRd, MEA_P(1.5f))\n#define MQ6_30 vec2(MEA_P(.75f) + fRd, MEA_P(1.5f))\n#define MQ6_35 vec2(MEA_P(.875f) + fRd, MEA_P(1.5f))\n#define MQ6_40 vec2(fMea + fRd, MEA_P(1.5f))\n\n#define BASE_00 vec2(fRd, fBse)\n#define BASE_10 vec2(.1f + fRd, fBse)\n#define BASE_15 vec2(.15f + fRd, fBse)\n#define BASE_20 vec2(.2f + fRd, fBse)\n#define BASE_25 vec2(.25f + fRd, fBse)\n#define BASE_30 vec2(.3f + fRd, fBse)\n#define BASE_35 vec2(.35f + fRd, fBse)\n#define BASE_40 vec2(.4f + fRd, fBse)\n\n#define DQ2_00 vec2(fRd, DSC_Q2)\n#define DQ2_10 vec2(.1f + fRd, DSC_Q2)\n#define DQ2_15 vec2(.15f + fRd, DSC_Q2)\n#define DQ2_20 vec2(.2f + fRd, DSC_Q2)\n#define DQ2_25 vec2(.25f + fRd, DSC_Q2)\n#define DQ2_30 vec2(.3f + fRd, DSC_Q2)\n#define DQ2_35 vec2(.35f + fRd, DSC_Q2)\n#define DQ2_40 vec2(.4f + fRd, DSC_Q2)\n\n#define MDQ_00 vec2(fRd, fDsc + fRd + MEA_Q1)\n#define MDQ_10 vec2(MEA_P(.25f) + fRd, fDsc + fRd + MEA_Q1)\n#define MDQ_15 vec2(MEA_P(.375f) + fRd, fDsc + fRd + MEA_Q1)\n#define MDQ_20 vec2(MEA_P(.50f) + fRd, fDsc + fRd + MEA_Q1)\n#define MDQ_25 vec2(MEA_P(.625f) + fRd, fDsc + fRd + MEA_Q1)\n#define MDQ_30 vec2(MEA_P(.75f) + fRd, fDsc + fRd + MEA_Q1)\n#define MDQ_35 vec2(MEA_P(.875f) + fRd, fDsc + fRd + MEA_Q1)\n#define MDQ_40 vec2(fMea + fRd, fDsc + fRd + MEA_Q1)\n\n#define MDO_00 vec2(fRd, fDsc + fRd + MEA_O1)\n#define MDO_05 vec2(MEA_O1 + fRd, fDsc + fRd + MEA_O1)\n#define MDO_10 vec2(MEA_P(.25f) + fRd, fDsc + fRd + MEA_O1)\n\n#define DESC_00 vec2(fRd, fDsc + fRd)\n#define DESC_15 vec2(MEA_P(.375f) + fRd, fDsc + fRd)\n#define DESC_20 vec2(MEA_P(.50f) + fRd, fDsc + fRd)\n#define DESC_25 vec2(MEA_P(.625f) + fRd, fDsc + fRd)\n#define DESC_30 vec2(MEA_P(.75f) + fRd, fDsc + fRd)\n#define DESC_35 vec2(MEA_P(.875f) + fRd, fDsc + fRd)\n#define DESC_40 vec2(fMea + fRd, fDsc + fRd)\n\n#define BASE_05_20 vec2(.05f + fRd, .2f)\n#define BASE_35_20 vec2(.35f + fRd, .2f)\n\n#define DL(a, b) fD = min(fD, udSegment(vP, a, b))\n#define DC(a, r) fD = min(fD, udCircle(vP - (a), r))\n#define DCT(a, r) fD = min(fD, udCircleT(vP - (a), r))\n#define DCB(a, r) fD = min(fD, udCircleB(vP - (a), r))\n#define DCL(a, r) fD = min(fD, udCircleL(vP - (a), r))\n#define DCR(a, r) fD = min(fD, udCircleR(vP - (a), r))\n#define DCTL(a, r) fD = min(fD, udCircleTL(vP - (a), r))\n#define DCTR(a, r) fD = min(fD, udCircleTR(vP - (a), r))\n#define DCBL(a, r) fD = min(fD, udCircleBL(vP - (a), r))\n#define DCBR(a, r) fD = min(fD, udCircleBR(vP - (a), r))\n\n// by Inigo Quilez : https://www.shadertoy.com/view/3tdSDj\nfloat udSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - h * ba);\n}\n\n// by Inigo Quilez : https://www.shadertoy.com/view/3ltSW2 (unsigned)\nfloat udCircle(vec2 p, float r)\n{\n    return abs(length(p) - r);\n}\n\n// circle top, bottom, left, right, tl, tr, bl, br\nfloat udCircleT(vec2 p, float r)\n{\n    return (p.y < 0.) ? abs(length(vec2(abs(p.x) - r, p.y))) : udCircle(p, r);\n}\n\nfloat udCircleB(vec2 p, float r)\n{\n    return (p.y > 0.) ? abs(length(vec2(abs(p.x) - r, p.y))) : udCircle(p, r);\n}\n\nfloat udCircleL(vec2 p, float r)\n{\n    return (p.x > 0.) ? abs(length(vec2(p.x, abs(p.y) - r))) : udCircle(p, r);\n}\n\nfloat udCircleR(vec2 p, float r)\n{\n    return (p.x < 0.) ? abs(length(vec2(p.x, abs(p.y) - r))) : udCircle(p, r);\n}\n\nfloat udCircleTL(vec2 p, float r)\n{\n    return (p.x > 0.) ?\n        min(abs(length(vec2(p.x, p.y - r))),\n            abs(length(vec2(-p.x - r, p.y))))\n        : udCircleT(p, r);\n}\n\nfloat udCircleTR(vec2 p, float r)\n{\n    return (p.x < 0.) ?\n        min(abs(length(vec2(p.x, p.y - r))),\n            abs(length(vec2(p.x - r, p.y))))\n        : udCircleT(p, r);\n}\n\nfloat udCircleBL(vec2 p, float r)\n{\n    return (p.x > 0.) ?\n        min(abs(length(vec2(p.x, -p.y - r))),\n            abs(length(vec2(-p.x - r, p.y))))\n        : udCircleB(p, r);\n}\n\nfloat udCircleBR(vec2 p, float r)\n{\n    return (p.x < 0.) ?\n        min(abs(length(vec2(p.x, -p.y - r))),\n            abs(length(vec2(p.x - r, p.y))))\n        : udCircleB(p, r);\n}\n\n// dashed line sdf ... based on segment sdf https://www.shadertoy.com/view/3tdSDj by IQ\nfloat sdLineDashed(in vec2 vP, in vec2 vA, in vec2 vB, in float fR, in float fDashL)\n{\n    vec2 vPA = vP - vA, vBA = vB - vA;\n    float fH = clamp(dot(vPA, vBA) / dot(vBA, vBA), 0.f, 1.f);\n    return length(vPA - vBA * fH) - fR * step(.5f, fract(fH * length(vBA) * (1.f / fDashL)));\n}\n\n#define CURRENT 0x7e\n\n// draw a glyph (ascii 0..127)\nvoid Glyph(in vec2 vP, in uint uAscii, inout float fD, in float fRd)\n{\n    if (uAscii == uint(0x21)) // !\n    {\n        DL(BASE_00, BASE_00);\n        DL(CQ1_00, CAP_00);\n    }\n    else if (uAscii == uint(0x22)) // \"\n    {\n        DL(CAP_00, CAP_00 - OFFSET_Y);\n        DL(CAP_10, CAP_10 - OFFSET_Y);\n    }\n    else if (uAscii == uint(0x23)) // #\n    {\n        DL(CQ1_10, CQ3_10 - OFFSET_Y_2);\n        DL(CQ1_20, CQ3_20 - OFFSET_Y_2);\n        DL(CUT_00, CUT_30);\n        DL(CQ2_00, CQ2_30);\n    }\n    else if (uAscii == uint(0x24)) // $\n    {\n        DCT(CQ3_15, .15);\n        DCB(CQ1_15, .15);\n        DCBL(CQ3_15 - OFFSET_Y, .15);\n        DCTR(CQ1_15 + OFFSET_Y, .15);\n        DL(BASE_15, CAP_15);\n        DL(CQ1_30, CQ1_30 + OFFSET_Y); \n        DL(CQ3_00, CQ3_00 - OFFSET_Y); \n    }\n    else if (uAscii == uint(0x25)) // %\n    {\n        DL(BASE_00, CAP_30);\n        DC(CQ3_05 + OFFSET_Y, .05f);\n        DC(CQ1_25 - OFFSET_Y, .05f);\n    }\n    else if (uAscii == uint(0x26)) // &\n    {\n        DCT(CQ3_15, .15);\n        DCBL(CQ1_15 - OFFSET_Y, .15);\n        DCBR(CQ1_15, .2);\n        DCB(CQ3_15 - OFFSET_Y_2, .15);\n        DCTL(CQ1_15, .15);\n        DL(CQ1_00, CQ1_00 - OFFSET_Y); \n        DL(CQ3_00, CQ3_00 - OFFSET_Y_2);\n        DL(CQ3_30, CQ3_30 - OFFSET_Y_2);\n        DL(CQ2_15 - OFFSET_Y, BASE_35);\n    }\n    else if (uAscii == uint(0x27)) // ' Single quote\n    {\n        DL(CAP_00, MQ6_00);\n    }\n    else if (uAscii == uint(0x28)) // (\n    {\n        DL(BASE_00 - OFFSET_Y_2, CQ3_00);\n        DCTL(CQ3_20, CAP_Q1);\n        DCBL(BASE_20 - OFFSET_Y_2, CAP_Q1);\n    }\n    else if (uAscii == uint(0x29)) // )\n    {\n        DL(BASE_20 - OFFSET_Y_2, CQ3_20);\n        DCTR(CQ3_00, CAP_Q1);\n        DCBR(BASE_00 - OFFSET_Y_2, CAP_Q1);\n    }\n    else if (uAscii == uint(0x2a)) // *\n    {\n        DL(CQ3_00 - OFFSET_Y, CQ1_30 + OFFSET_Y);\n        DL(CQ1_00 + OFFSET_Y, CQ3_30 - OFFSET_Y);\n        DL(CQ1_15, CQ3_15);\n    }\n    else if (uAscii == uint(0x2b)) // +\n    {\n        DL(CUT_00, CUT_20);        \n        DL(CQ1_10, CQ2_10);\n    }\n    else if (uAscii == uint(0x2c)) // ,\n    {\n        DL(BASE_00 - OFFSET_Y_2, BASE_00);\n    }\n    else if (uAscii == uint(0x2d)) // -\n    {\n        DL(CUT_00, CUT_20);\n    }\n    else if (uAscii == uint(0x2e)) // .\n    {\n        DL(BASE_00, BASE_00);\n    }\n    else if (uAscii == uint(0x2f)) // /\n    {\n        DL(BASE_00, CAP_30);\n    }\n    else\n    if (uAscii == uint(0x30)) // 0\n    {\n        DL(CQ1_00, CQ3_00);\n        DL(CQ1_40, CQ3_40);\n        DCT(CQ3_20, CAP_Q1);\n        DCB(CQ1_20, CAP_Q1);\n        DL(CQ3_40, CQ1_00);\n    }\n    else if (uAscii == uint(0x31)) // 1\n    {\n        DL(BASE_10, CAP_10);\n        DL(MQ6_00, CAP_10);\n    }\n    else if (uAscii == uint(0x32)) // 2\n    {\n        DL(BASE_00, CQ1_00 + OFFSET_Y);\n        DL(BASE_00, BASE_35);\n        DCTR(CQ3_15, CAP_Q1);\n        DCBR(CQ3_15 - OFFSET_Y, CAP_Q1);\n        DCTL(CQ1_10 + OFFSET_Y, .10f);\n        DCTL(CQ3_15 + OFFSET_Y, .15f);\n        DL(CQ2_10 - OFFSET_Y, CQ2_15 - OFFSET_Y);\n        DL(CQ3_35, CQ3_35 - OFFSET_Y);\n    }\n    else if (uAscii == uint(0x33)) // 3\n    {        \n        DCR(CQ3_10, CAP_Q1);\n        DL(CQ2_10, CQ2_15);\n        DCR(CQ1_15, CAP_Q1);        \n        DCTL(CAP_10 - OFFSET_Y_2, .1f);        \n        DCBL(CQ1_15 - OFFSET_Y, .15f);\n    }\n    \n    else if (uAscii == uint(0x34)) // 4\n    {\n        DL(CUT_00, CUT_35);\n        DL(CUT_00, CAP_30);\n        DL(CAP_30, BASE_30);\n    }\n    else if (uAscii == uint(0x35)) // 5\n    {\n        DL(CQ2_00 + OFFSET_Y, CQ2_15 + OFFSET_Y);\n        DCBR(CQ1_15, CAP_Q1);\n        DCTR(CQ1_15 + OFFSET_Y, CAP_Q1);\n        DL(CQ2_00 + OFFSET_Y, CAP_00);\n        DL(CQ1_35, CQ1_35  + OFFSET_Y);\n        DL(CAP_00, CAP_35);\n        DCBL(CQ1_15 - OFFSET_Y, .15f);\n    }\n    else if (uAscii == uint(0x36)) // 6\n    {\n        DCB(CQ1_20, CAP_Q1);\n        DCT(CQ1_20 + OFFSET_Y, CAP_Q1);\n        DL(CQ1_40, CQ1_40 + OFFSET_Y);\n        DL(CQ1_00, CQ2_00);\n        DCTL(CQ2_40, .4f);\n    }\n    else if (uAscii == uint(0x37)) // 7\n    {\n        DL(BASE_00, CAP_30);\n        DL(CAP_00, CAP_30);\n        DL(CUT_05, CUT_20);\n    }\n    else if (uAscii == uint(0x38)) // 8\n    {\n        DC(CQ3_20, CAP_Q1);\n        DC(CQ1_20, CAP_Q1);\n    }\n    else if (uAscii == uint(0x39)) // 9\n    {\n        DCT(CQ3_20, CAP_Q1);\n        DCB(CQ3_20 - OFFSET_Y, CAP_Q1);\n        DL(CQ2_40, CQ3_40);\n        DL(CQ3_00, CQ3_00 - OFFSET_Y);\n        DCBR(CQ2_00, .4f);\n    }\n    else if (uAscii == uint(0x3a)) // :\n    {\n        DL(BASE_00, BASE_00);\n        DL(CQ1_00, CQ1_00);\n    }\n    else if (uAscii == uint(0x3b)) // ;\n    {\n        DL(BASE_00 - OFFSET_Y_2, BASE_00);\n        DL(CQ1_00, CQ1_00);\n    }\n    else if (uAscii == uint(0x3c)) // <\n    {\n        DL(MQ0_15, MQ2_00);\n        DL(MQ2_00, MEA_15);\n    }\n    else if (uAscii == uint(0x3d)) // =\n    {\n        DL(CUT_00 + OFFSET_Y, CUT_20 + OFFSET_Y);\n        DL(CQ1_00, CQ1_20);\n    }\n    else if (uAscii == uint(0x3e)) // >\n    {\n        DL(MQ0_00, MQ2_15);\n        DL(MQ2_15, MEA_00);\n    }\n    else if (uAscii == uint(0x3f)) // ?\n    {\n        DCR(CQ3_10, CAP_Q1);\n        DL(CQ2_10, CQ1_10);\n        DCTL(CAP_10 - OFFSET_Y_2, .1f);\n        DL(BASE_10, BASE_10);\n    }\n    else if (uAscii == uint(0x40)) // @\n    {\n        DC(CQ1_20, CAP_Q1 - OFFSET_Y_2.y);\n        DCL(CQ1_20, CAP_Q1);\n        DCTR(CQ1_20, CAP_Q1);\n        DCB(CQ1_35, OFFSET_Y.y);\n        DL(BASE_20, BASE_25);\n    }\n    else if (uAscii == uint(0x41)) // A\n    {\n        DL(BASE_00, CAP_20);\n        DL(BASE_40, CAP_20);\n        DL(BASE_05_20, BASE_35_20);\n    }\n    else if (uAscii == uint(0x42)) // B\n    {\n        DL(BASE_00, CAP_00);\n        DCR(CQ3_10, CAP_Q1);\n        DL(CAP_00, CAP_10);\n        DL(CQ2_00, CQ2_15);\n        DL(BASE_00, BASE_15);\n        DCR(CQ1_15, CAP_Q1);\n    }\n    else if (uAscii == uint(0x43)) // C\n    {\n        DL(CQ1_00, CQ3_00);\n        DCT(CQ3_20, CAP_Q1);\n        DCB(CQ1_20, CAP_Q1);\n    }\n    else if (uAscii == uint(0x44)) // D\n    {\n        DL(BASE_00, CAP_00);\n        DL(CAP_00, CAP_15);\n        DL(BASE_00, BASE_15);\n        DCTR(CQ3_15, CAP_Q1);\n        DCBR(CQ1_15, CAP_Q1);\n        DL(CQ1_35, CQ3_35);\n    }\n    else if (uAscii == uint(0x45)) // E\n    {\n        DL(BASE_00, CAP_00);\n        DL(CAP_00, CAP_30);\n        DL(CQ2_00, CQ2_25);\n        DL(BASE_00, BASE_30);\n    }\n    else if (uAscii == uint(0x46)) // F\n    {\n        DL(BASE_00, CAP_00);\n        DL(CAP_00, CAP_30);\n        DL(CQ2_00, CQ2_25);\n    }\n    else if (uAscii == uint(0x47)) // G\n    {\n        DL(CQ1_00, CQ3_00);\n        DL(CUT_20, CUT_40);\n        DL(CUT_40, CQ1_40);\n        DCT(CQ3_20, CAP_Q1);\n        DCB(CQ1_20, CAP_Q1);\n    }\n    else if (uAscii == uint(0x48)) // H\n    {\n        DL(BASE_00, CAP_00);\n        DL(BASE_35, CAP_35);\n        DL(CQ2_00, CQ2_35);\n    }\n    else if (uAscii == uint(0x49)) // I\n    {\n        DL(BASE_00, CAP_00);\n    }\n    else if (uAscii == uint(0x4a)) // J\n    {\n        DL(CQ1_20, CAP_20);\n        DCBR(CQ1_00, CAP_Q1);\n    }\n    else if (uAscii == uint(0x4b)) // K\n    {\n        DL(BASE_00, CAP_00);\n        DL(BASE_35, CQ2_00);\n        DL(CQ2_00, CAP_35);\n    }\n    else if (uAscii == uint(0x4c)) // L\n    {\n        DL(BASE_00, CAP_00);\n        DL(BASE_00, BASE_30);\n    }\n    else if (uAscii == uint(0x4d)) // M\n    {\n        DL(BASE_00, CAP_00);\n        DL(CAP_00, CQ1_20);\n        DL(BASE_40, CAP_40);\n        DL(CAP_40, CQ1_20);\n    }\n    else if (uAscii == uint(0x4e)) // N\n    {\n        DL(BASE_00, CAP_00);\n        DL(CAP_00, BASE_30);\n        DL(BASE_30, CAP_30);\n    }\n    else if (uAscii == uint(0x4f)) // O\n    {\n        DL(CQ1_00, CQ3_00);\n        DL(CQ1_40, CQ3_40);\n        DCT(CQ3_20, CAP_Q1);\n        DCB(CQ1_20, CAP_Q1);\n    }\n    else if (uAscii == uint(0x50)) // P\n    {\n        DL(BASE_00, CAP_00);\n        DCR(CQ3_10, CAP_Q1);\n        DL(CAP_00, CAP_10);\n        DL(CQ2_00, CQ2_10);\n    }\n    else if (uAscii == uint(0x51)) // Q\n    {\n        DL(CQ1_00, CQ3_00);\n        DL(CQ1_40, CQ3_40);\n        DCT(CQ3_20, CAP_Q1);\n        DCB(CQ1_20, CAP_Q1);\n        DL(CQ1_20, DQ2_35);\n    }\n    else if (uAscii == uint(0x52)) // R\n    {\n        DL(BASE_00, CAP_00);\n        DCR(CQ3_10, CAP_Q1);\n        DL(CAP_00, CAP_10);\n        DL(CQ2_00, CQ2_10);\n        DL(CQ2_10, BASE_30);\n    }\n    else if (uAscii == uint(0x53)) // S\n    {\n        DCT(CQ3_20, CAP_Q1);\n        DCB(CQ1_20, CAP_Q1);\n        DCBL(CQ3_15, .15f);\n        DCTR(CQ1_20 + OFFSET_Y, CAP_Q1);\n        DL(CQ2_15 + OFFSET_Y, CQ2_20 + OFFSET_Y);\n        DL(CQ1_40, CQ1_40 + OFFSET_Y);\n    }\n    else if (uAscii == uint(0x54)) // T\n    {\n        DL(BASE_15, CAP_15);\n        DL(CAP_00, CAP_30);\n    }\n    else if (uAscii == uint(0x55)) // U\n    {\n        DCB(CQ1_20, CAP_Q1);\n        DL(CQ1_00, CAP_00);\n        DL(CQ1_40, CAP_40);\n    }\n    else if (uAscii == uint(0x56)) // V\n    {\n        DL(BASE_20, CAP_00);\n        DL(BASE_20, CAP_40);\n    }\n    else if (uAscii == uint(0x57)) // W\n    {\n        DL(BASE_00, CAP_00);\n        DL(BASE_00, CQ3_20);\n        DL(BASE_40, CAP_40);\n        DL(BASE_40, CQ3_20);\n    }\n\n    else if (uAscii == uint(0x58)) // X\n    {\n        DL(BASE_40, CAP_00);\n        DL(BASE_00, CAP_40);\n    }\n    else if (uAscii == uint(0x59)) // Y\n    {\n        DL(CQ2_20, CAP_00);\n        DL(CQ2_20, CAP_40);\n        DL(BASE_20, CQ2_20);\n    }\n    else if (uAscii == uint(0x5a)) // Z\n    {\n        DL(BASE_00, CAP_30);\n        DL(CAP_00, CAP_30);\n        DL(BASE_00, BASE_30);\n    }\n    else if (uAscii == uint(0x5b)) // [\n    {\n        DL(CAP_00, CAP_00 + OFFSET_X_2);\n        DL(DESC_00, CAP_00);\n        DL(DESC_00, DESC_00  + OFFSET_X_2);\n    }\n    else if (uAscii == uint(0x5c)) // \\ backslash\n    {\n        DL(CQ3_00, BASE_30);\n    }\n    else if (uAscii == uint(0x5d)) // ]\n    {\n        DL(CAP_00, CAP_00 + OFFSET_X_2);\n        DL(DESC_00 + OFFSET_X_2, CAP_00 + OFFSET_X_2);\n        DL(DESC_00, DESC_00  + OFFSET_X_2);\n    }\n    else if (uAscii == uint(0x5e)) // ^\n    {\n        DL(CQ3_00, CAP_10);\n        DL(CQ3_20, CAP_10);\n    }\n    \n    else if (uAscii == uint(0x5f)) // _\n    {\n        DL(DESC_00, DESC_30);\n    }\n    else if (uAscii == uint(0x60)) // `\tGrave / accent\n    {\n        DL(CQ3_10, CAP_00);\n    }\n    else if (uAscii == uint(0x61)) // a\n    {\n        DL(MQ3_20, MQ0_20);\n        DCT(MQ3_10, MEA_Q1);\n        DCB(MQ1_10, MEA_Q1);\n        DCTL(MQ1_10, MEA_Q1);\n        DL(MQ2_10, MQ2_20);\n    }\n    else if (uAscii == uint(0x62)) // b\n    {\n        DL(BASE_00, MQ6_00);\n        DCT(MQ3_10, MEA_Q1);\n        DCB(MQ1_10, MEA_Q1);\n        DL(MQ3_20, MQ1_20);       \n    }\n    else if (uAscii == uint(0x63)) // c\n    {\n        DL(MQ3_00, MQ1_00);\n        DCT(MQ3_10, MEA_Q1);\n        DCB(MQ1_10, MEA_Q1);\n    }\n    else if (uAscii == uint(0x64)) // d\n    {\n        DL(MQ3_00, MQ1_00);\n        DL(MQ6_20, MQ0_20);\n        DCT(MQ3_10, MEA_Q1);\n        DCB(MQ1_10, MEA_Q1);\n    }\n    else if (uAscii == uint(0x65)) // e\n    {\n        DL(MQ3_00, MQ1_00);\n        DL(MQ2_00, MQ2_10);\n        DCT(MQ3_10, MEA_Q1);\n        DCB(MQ1_10, MEA_Q1);\n        DCBR(MQ3_10, MEA_Q1);        \n    }\n    else if (uAscii == uint(0x66)) // f\n    {\n        DL(MQ5_05 + OFFSET_Y_M, MQ0_05);\n        DL(MEA_00, MEA_10);\n        DCTL(MQ5_10 + OFFSET_Y_M, MEA_O1);\n    }\n    else if (uAscii == uint(0x67)) // g\n    {\n        DL(MQ3_00, MQ1_00);\n        DL(MEA_20, MDQ_20);\n        DCT(MQ3_10, MEA_Q1);\n        DCB(MQ1_10, MEA_Q1);\n        DCB(MDQ_10, MEA_Q1);\n    }\n    \n    else if (uAscii == uint(0x68)) // h\n    {\n        DL(BASE_00, MQ6_00);\n        DCT(MQ3_10, MEA_Q1);\n        DL(MQ3_20, MQ0_20); \n    }\n    else if (uAscii == uint(0x69)) // i\n    {\n        DL(MEA_00, MQ0_00);\n        DC(MQ6_00, ZERO);\n    }    \n    else if (uAscii == uint(0x6a)) // j\n    {\n        DL(MEA_05, MDO_05);\n        DC(MQ6_05, ZERO);\n        DCBR(MDO_00, MEA_O1);\n    }\n    else if (uAscii == uint(0x6b)) // k\n    {\n        DL(BASE_00, MQ6_00);\n        DL(MQ0_15, MQ3_00);\n        DL(MQ3_00, MEA_15);\n    }\n    else if (uAscii == uint(0x6c)) // l\n    {\n        DL(MQ6_00, MO1_00);\n        DCBL(MO1_05, MEA_O1);\n    }    \n    else if (uAscii == uint(0x6d)) // m\n    {\n        DL(MEA_00, MQ0_00);\n        DCT(MO7_05, MEA_O1);\n        DCT(MO7_15, MEA_O1);\n        DL(MO7_10, MQ2_10);\n        DL(MO7_20, MQ0_20);\n    }\n    else if (uAscii == uint(0x6e)) // n\n    {\n        DL(BASE_00, MEA_00);\n        DCT(MQ3_10, MEA_Q1);\n        DL(MQ3_20, MQ0_20); \n    }\n    else if (uAscii == uint(0x6f)) // o\n    {\n        DL(MQ3_00, MQ1_00);\n        DL(MQ3_20, MQ1_20);\n        DCT(MQ3_10, MEA_Q1);\n        DCB(MQ1_10, MEA_Q1);\n    }\n    else if (uAscii == uint(0x70)) // p\n    {\n        DL(DESC_00, MEA_00);\n        DL(MQ3_20, MQ1_20);\n        DCT(MQ3_10, MEA_Q1);\n        DCB(MQ1_10, MEA_Q1);\n    }\n    else if (uAscii == uint(0x71)) // q\n    {\n        DL(MQ3_00, MQ1_00);\n        DL(MEA_20, DESC_20);\n        DCT(MQ3_10, MEA_Q1);\n        DCB(MQ1_10, MEA_Q1);\n    }\n    else if (uAscii == uint(0x72)) // r\n    {\n        DL(MEA_00, MQ0_00);\n        DCT(MO7_05, MEA_O1);\n    }\n    else if (uAscii == uint(0x73)) // s\n    {    \n        DL(MQ2_10, MQ2_15);\n        DCT(MQ3_10, MEA_Q1);\n        DCB(MQ1_10, MEA_Q1);\n        DCBL(MQ3_10, MEA_Q1);\n        DCTR(MQ1_15 + OFFSET_Y_M, MEA_O1);\n        DL(MQ1_20, MQ1_20 + OFFSET_Y_M);\n    }\n    else if (uAscii == uint(0x74)) // t\n    {\n        DL(MQ6_05, MQ0_05+ OFFSET_Y_M);\n        DL(MEA_00, MEA_10);\n        DCBL(MQ0_10 + OFFSET_Y_M, MEA_O1);\n    }\n    else if (uAscii == uint(0x75)) // u\n    {\n        DL(MEA_00, MQ1_00);\n        DL(MEA_20, MQ1_20);\n        DCB(MQ1_10, MEA_Q1);\n    }    \n    else if (uAscii == uint(0x76)) // v\n    {\n        DL(MEA_00, MQ0_10);\n        DL(MEA_20, MQ0_10);\n    }\n    else if (uAscii == uint(0x77)) // w\n    {        \n        DL(MEA_00, MQ0_05);\n        DL(MQ2_15, MQ0_05);\n        DL(MQ2_15, MQ0_25);\n        DL(MEA_30, MQ0_25);\n    }    \n    else if (uAscii == uint(0x78)) // x\n    {\n        DL(MEA_00, MQ0_20);\n        DL(MEA_20, MQ0_00);\n    }\n    else if (uAscii == uint(0x79)) // y\n    {\n        DL(MEA_00, MQ0_10);\n        DL(MEA_20, MQ0_10);\n        DL(MDO_10, MQ0_10);\n        DCBR(MDO_05, MEA_O1);\n    }    \n    else if (uAscii == uint(0x7a)) // z\n    {\n        DL(MEA_00, MEA_20);\n        DL(MEA_20, MQ0_00);\n        DL(MQ0_00, MQ0_20);\n    }\n    else if (uAscii == uint(0x7b)) // {\n    {\n        DL(DESC_00 + OFFSET_Y_2 + OFFSET_X, MQ2_00 - OFFSET_Y + OFFSET_X);\n        DL(CAP_00 - OFFSET_Y_2 + OFFSET_X, MQ2_00 + OFFSET_Y + OFFSET_X);\n        DCTL(CQ3_15 + OFFSET_Y_2, .1f);\n        DCBL(DESC_00 + OFFSET_XY_2 + OFFSET_X, .1f);\n        DCTR(MQ2_00 - OFFSET_Y, OFFSET_X.x);\n        DCBR(MQ2_00 + OFFSET_Y, OFFSET_X.x);\n    }\n    else if (uAscii == uint(0x7c)) // |\n    {\n        DL(DESC_00, CAP_00);\n    }\n    else if (uAscii == uint(0x7d)) // }\n    {\n        DL(DESC_00 + OFFSET_Y_2 + OFFSET_X_2, MQ2_00 - OFFSET_Y + OFFSET_X_2);\n        DL(CAP_00 - OFFSET_Y_2 + OFFSET_X_2, MQ2_00 + OFFSET_Y + OFFSET_X_2);\n        DCTR(CQ3_00 + OFFSET_Y_2, .1f);\n        DCBR(DESC_00 + OFFSET_Y_2, .1f);\n        DCTL(MQ2_00 - OFFSET_Y + OFFSET_X_2 + OFFSET_X, OFFSET_X.x);\n        DCBL(MQ2_00 + OFFSET_Y + OFFSET_X_2 + OFFSET_X, OFFSET_X.x);\n    }\n    else if (uAscii == uint(0x7e)) // ~ (TILDE)\n    {\n        DCTL(MQ2_00 - OFFSET_Y * .5f + OFFSET_X, OFFSET_X.x);\n        DCBR(MQ2_00 + OFFSET_Y * .5f + OFFSET_X_2 * 2.f, OFFSET_X.x);\n        DL(MQ2_00 + OFFSET_Y * .5f + OFFSET_X, MQ2_00 - OFFSET_Y * .5f + OFFSET_X_2 * 2.f);\n    }\n}\n\n// print a string\nvoid PrintStr(in vec2 vP, in str auTxt, in float fCharSpc, inout float fD)\n{\n    float afGlyphX[STRING_LEN];\n\n    // out of bounds vertically or negative x ?\n    if ((vP.y < fDsc) || (vP.y > fAsc) || (vP.x < 0.f)) return;\n\n    // calculate line length and glyph x position... in your project you would precalculate that within your c++ code\n    float fLineL = afGlyphW[auTxt[0]] + fCharSpc;\n    afGlyphX[0] = 0.f;\n    for (int nI = 1; nI < STRING_LEN; nI++)\n    {\n        // set glyph x position\n        afGlyphX[nI] = fLineL;\n\n        // clamp index to byte\n        if (auTxt[nI] > 0xff) continue;\n\n        // get glyph index\n        uint uAscii = uint(auTxt[nI]);\n\n        // for (space) and (_) there is no character spacing\n        if ((uAscii != uint(0x20)) && (uAscii != uint(0x5b))) fLineL += fCharSpc;\n\n        // add glyph width\n        fLineL += afGlyphW[auTxt[nI]];\n    }\n\n    // out of bounds positive x ?\n    if (vP.x >= (fLineL - fCharSpc)) return;\n\n    // get glyph index\n    int nIx = 0;\n    for (; nIx < STRING_LEN; nIx++)\n        if (vP.x < (afGlyphX[nIx] + afGlyphW[auTxt[nIx]])) break;\n\n    // print glyph\n    uint uAscii = uint(auTxt[nIx]);\n    vec2 vGP = vP + vec2(-afGlyphX[nIx], 0.);\n    Glyph(vGP, uAscii, fD, fR);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// lcd effect...\nvec4 lcd(vec4 c, vec2 vU, float fN)\n{\n    // noise\n    c.rgb -= min(fN, hash12(vU + mod(iTime, 100.f)));\n\n    // shift, adjust\n    ivec2 vXy = ivec2(mod(vU, 3.f));\n    c.rgb = vec3((vXy.x == 1) ? c.g : c.r, (vXy.x == 2) ? c.b : c.g, (vXy.x == 3) ? c.r : c.b);\n    c.rgb = vec3((vXy.y == 1) ? pow(c.r, 2.f) : c.r,\n        (vXy.y == 2) ? pow(c.g, .5f) : c.g,\n        (vXy.y == 3) ? pow(c.b, .1f) : c.b);\n    return c;\n}\n\n// simple palette by Inigo Quilez : https://www.shadertoy.com/view/ll2GD3\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b * cos(6.28318f * (c * t + d));\n}\n\nvoid mainImage(out vec4 cO, in vec2 vU)\n{\n    // normalize, zoom, offset\n    vec2 vP = vU / iResolution.y;\n    float fXo = vP.x;\n    float fZoom = ONE_DIV(ZOOM);\n\n    // style demonstration ?\n    if (bShowStyles)\n    {\n        float fTimer = mod(iTime - vU.y / iResolution.y - sin((vU.x / iResolution.x) * 64.f) * .03f, 18.f);\n        bLcd = (vP.y < 0.5f);\n        bHollow = (vP.y < 0.5f);\n        bRising = (vP.y < 0.5f);\n    }\n    \n#if (ALL_GLYPHES == 1)\n    vP.x += 1.7f * fract(iTime * .4f) - .3f;\n#endif\n\n    vP *= fZoom;\n    vP.y -= FULL_LINE_Y * LINE_SCROLL;\n\n    if ((bGlitch) && (!bShowStyles))\n    {\n        // scanline glitch by gimbo : https://www.shadertoy.com/view/Xd2BWt\n        float fIv = 18.3f;\n        vec2 vGlitchOff = vec2(0.f,\n            clamp(sin(fIv * iTime), 0., 1.) *\n            clamp(sin(fIv * iTime * 3.), 0., 1.) *\n            clamp(sin(fIv * iTime * 17.), 0., 1.) *\n            clamp(sin(fIv * iTime * 13.), 0., 1.)\n            * sin(vP.x * 600. * sin(iTime) + iTime * 10.));\n        vP += vGlitchOff * .1f;\n    }\n\n    // print red helper lines ?\n    float fL = 1.f;\n    if (bDrawLines)\n    {\n        // ascender, mean, base, descender helper lines\n        fL = smoothstep(.0, .01, sdLineDashed(vP, vec2(-100.f, fCap), vec2(100.f, fCap), .01f, .05f) + .01f);\n        fL = min(fL, smoothstep(.0, .01, sdLineDashed(vP, vec2(-100.f, fMea), vec2(100.f, fMea), .01f, .05f) + .01f));\n        fL = min(fL, smoothstep(.0, .01, sdLineDashed(vP, vec2(-100.f, fBse), vec2(100.f, 0.f), .01f, .05f) + .01f));\n        fL = min(fL, smoothstep(.0, .01, sdLineDashed(vP, vec2(-100.f, fDsc), vec2(100.f, fDsc), .01f, .05f) + .01f));\n        fL = min(fL, smoothstep(.0, .01, sdLineDashed(vP, vec2(0.f, fCap), vec2(0.f, fDsc), .01f, .05f) + .01f));\n    }\n    fL = 1.f - fL;\n\n    // fields\n    float fD = 10000.f;\n    float fLineYN = abs(fDsc) + fLineSpc;\n    float fLineY = fAsc + fLineYN;\n\n#if (ALL_GLYPHES == 1)\n    // text data\n    const int auL00[STRING_LEN] = int[STRING_LEN](64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95);\n    const int auL01[STRING_LEN] = int[STRING_LEN](96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127);\n    const int auL02[STRING_LEN] = int[STRING_LEN](66, 108, 111, 119, 122, 121, 32, 110, 105, 103, 104, 116, 45, 102, 114, 117, 109, 112, 115, 32, 118, 101, 120, 39, 100, 32, 74, 97, 99, 107, 81, 46);\n    const int auL03[STRING_LEN] = int[STRING_LEN](32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63);\n    \n    // print strings\n    if (fract(iTime * .2f) < .5f)\n    {\n        PrintStr(vP, auL00, fLettSpc, fD); vP.y += fAsc + abs(fDsc) + fLineSpc;\n        PrintStr(vP, auL01, fLettSpc, fD); vP.y += fAsc + abs(fDsc) + fLineSpc;\n    }\n    else\n    {\n        PrintStr(vP, auL02, fLettSpc, fD); vP.y += fAsc + abs(fDsc) + fLineSpc;\n        PrintStr(vP, auL03, fLettSpc, fD); vP.y += fAsc + abs(fDsc) + fLineSpc;\n    }\n#else\n    // one string\n    const int auL00[STRING_LEN] = int[STRING_LEN](  32,  72, 101, 108, 108, 111,  32,  83, 104,  97, 100, 101, 114, 116, 111, 121,  32,  61,  41,  32,  33,  33,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32); \n    PrintStr(vP, auL00, fLettSpc, fD); vP.y += fAsc + abs(fDsc) + fLineSpc;\n    PrintStr(vP, auL00, fLettSpc, fD); vP.y += fAsc + abs(fDsc) + fLineSpc;\n#endif\n\n    // style ?\n    float fRr = bRising ? mod(vP.y + fLineYN, fLineY) * fR : fR;\n    float fA = bHollow ? fD < (fRr * .5f) ? (fRr * .5f - fD) / (fRr * .5f) : (fD - fRr * .5f) / (fRr * .5f) : fD / fRr;\n\n    // occlusion\n    fA = 1. - fA * fA;\n    fA = fA <= 0.f ? 0.f : clamp(sqrt(fA), 0.f, 1.f);\n\n    if (bLcd)\n    {\n        // lcd screen\n        vec4 cLcd = lcd(vec4(1.f) , vU, .3f);\n        cO = mix(vec4(.0f, .0f, .0f, 1.f), cLcd, fA);\n    }\n    else\n        cO = vec4(max(fA, fL), min(fA, 1.f), min(fA, 1.f), 1.f);\n\n    if (bLcd)\n        cO.rgb *= clamp(\n            pal(iTime * .6f + fXo * 10.f,\n                vec3(0.8, 0.5, 0.4), vec3(0.2, 0.4, 0.2), vec3(2.0, 1.0, 1.0), vec3(0.0, 0.25, 0.25)),\n            0.f, 1.f);\n\n    if (bInvColor)\n        cO.rgb = vec3(1.f) - clamp(cO.rgb, 0.f, 1.f);\n}","name":"Image","description":"","type":"image"}]}