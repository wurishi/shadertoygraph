{"ver":"0.1","info":{"id":"wldBDr","date":"1612566021","viewed":106,"name":"Ease animation demo R&B","username":"EDragon","description":"ease reader test_1","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["tween","ease"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4tXXRM","filepath":"https://soundcloud.com/silentrm-net/red-and-blue","previewfilepath":"https://soundcloud.com/silentrm-net/red-and-blue","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// HELLO !\n// This is a small little demo of my \"\"ease reader\"\"\n// a function that will tween a value from 0 to 1 at the desired ease.\n// Of course, I am not done adding in the rest of the ease\n// I just thought the current ones are enough for this demo.\n// (sorry if it's short, doing this shit is extremly time consuming lmao)\n//\n// Hope you will enjoy my work o>\n//\n//\n// A continuation is being worked on plus minor improvments to the functions.\n//\n// This has been slightly updated to include some of the newer stuff I added\n// so I guess you could call this a v1.1 or something\n// It has not been touched for over a year (oh no) but hopefully I'll get back to it\n\n#define s smoothstep\n#define res iResolution.xy\n#define t iTime\n// song BPM math - offset\n// (t * (60. / BPM) * what you think is right tbh) - offset\n#define bpm (iChannelTime[0]*60./ 150. )\n#define beat ((bpm*4.)-2.1)\nfloat rand1 (float st) {\n    return fract(sin(dot(st*123.9385, st*532.18239)));\n}\nmat2 rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat box(vec2 uv, vec2 p, vec2 size, float rotation){\n    uv -= p;\n    uv *= rot(rotation*pi);\n    float r = step(abs(uv.x), size.x);\n    float b = step(abs(uv.y), size.y);\n    return r*b;\n}\nfloat box2(vec2 uv, vec2 p, vec2 size, float rotation){\n    uv -= p;\n    uv *= rot(rotation*pi);\n    float r = s(size.x, size.x-.004, abs(uv.x));\n    float b = s(size.y, size.y-.004, abs(uv.y));\n    return r*b;\n}\n\nvec2 rotate(vec2 v, vec2 o, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * (v-o) + o;\n}\n\n// shamelessly yoinked from https://shadertoy.com/view/MlsfRj\n\nvec2 tilt(vec2 uv, vec2 center, float XRot, float YRot) {\n    // First Rotate around Y axis\n    vec2 RayDirection =  vec2(uv.x, 0.0);\n    vec2 A1 = vec2(0.0, -1.0);\n    vec2 B1 = RayDirection - A1;\n    vec2 C1 = rotate(vec2(-1.0, 0.0), vec2(center.x, 0.0), YRot);\n    vec2 D1 = rotate(vec2( 1.0, 0.0), vec2(center.x, 0.0), YRot) - C1;\n    // calculate intersection point\n    float u = ( (C1.y + 1.0) * D1.x - C1.x * D1.y ) / (D1.x*B1.y-D1.y*B1.x);\n    // position on the plane:\n    float sx = u * B1.x;\n \tfloat sy = u * uv.y;\n    // Now Rotate around X axis\n    RayDirection = vec2(sy, .0);\n    vec2 B2 = RayDirection - A1;\n    vec2 C2 = rotate(vec2(-1.0, 0.00), vec2(center.y, 0.0), XRot);\n    vec2 D2 = rotate(vec2( 1.0, 0.0), vec2(center.y, 0.0), XRot) - C2;\n    // calculate intersection point\n    float v = ( (C2.y + 1.0) * D2.x - C2.x * D2.y ) / (D2.x*B2.y-D2.y*B2.x);\n    // final position on the plane:\n    return vec2(v * sx, v * B2.x );\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n///////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////// Vars Initialization //////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n    float loop;\n    float loop2;\n    \n    vec2 rp;\n    vec2 rsize;\n    float rrotation;\n    vec2 bp;\n    vec2 bsize;\n    float brotation;\n    vec2 borigin;\n    vec2 rorigin;\n    \n    float floor_fade;\n    float floor_size = 1.;\n    float floor_red;\n    float floor_blue;\n    \n    float bg_fade;\n    \n    float grid_size = .2;\n    \n    float lightsout = 1.;\n    \n    vec2 btil;\n    vec2 rtil;\n    \n    \n    \n    vec2 uv = (fragCoord.xy-.5*res)/res.y;\n    vec2 til = tilt(uv, vec2(.0), .0, .0);\n    vec2 til2 = tilt(uv, vec2(.0), .0, .0);\n    vec2 st = tilt(uv-vec2(.0,.0), vec2(.0,.0),-.35*pi, .0);\n    st.y += t*.1;\n    st.x *= .5;\n    vec2 uv2 = uv;;\n    \n    \n    \n    float h = 1./8.;\n    \n    \n    \n    \n    rsize = vec2(.1);\n    rp = vec2(0., .75);\n    \n    bsize = vec2(.1);\n    bp = vec2(0., -.75);\n    \n    \n///////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////// Ease Changes //////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n    \n    \n    bp.y += outExpo(1., 2., .75, beat);\n    bp.x += inOutExpo(3., 3., .5, beat);\n    bsize += linear(3., .001, .025, beat);\n    bsize -= outExpo(3.01, 2., .025, beat);\n    brotation += inOutCirc(3., 3., 2., beat);\n    \n    rp.y -= outExpo(6., 2., .75, beat);\n    rp.x -= inOutExpo(8., 3., .5, beat);\n    rsize += linear(8., .001, .025, beat);\n    rsize -= outExpo(8.01, 2., .025, beat);\n    rrotation -= inOutCirc(8., 3., 2., beat);\n    \n    rp.x += inBack(10., 1., .5, beat, -1.);\n    bp.x -= inBack(10., 1., .5, beat, -1.);\n    rsize.y -= inCirc(10., 1., .05, beat);\n    bsize.y -= inCirc(10., 1., .05, beat);\n    \n    til *= rot(inExpo(11., 9., pi*10., beat));\n    til2 *= rot(inExpo(11., 9., pi*10., beat));\n    \n    // for loops have been replaced with mod() and if statements for preformance\n    if (beat >= 11. && beat <= 20.){\n        loop = mod(beat, .644*2.);\n        loop2 = mod(beat, .644);\n        rp.x -= outCubic(0., .322, .5, loop);\n        rp.x += inCubic(.322, .322, .5, loop);\n        rp.x += outCubic(.322*2., .322, .5, loop);\n        rp.x -= inCubic(.322*3., .322, .5, loop);\n        \n        bp.x += outCubic(0., .322, .5, loop);\n        bp.x -= inCubic(.322, .322, .5, loop);\n        bp.x -= outCubic(.322*2., .322, .5,loop);\n        bp.x += inCubic(.322*3., .322, .5, loop);\n        \n        rsize.y += outExpo(0., .322, .05, loop2);\n        rsize.y -= inExpo(.322, .322, .05, loop2);\n        bsize.y += outExpo(0., .322, .05, loop2);\n        bsize.y -= inExpo(.322, .322, .05, loop2);\n    }\n    \n    rsize.y += outExpo(20., .322, .05, beat);\n    bsize.y += outExpo(20., .322, .05, beat);\n    \n    rp.x += inExpo(20., .5, sin(t*100.)*1.8, beat);\n    rp.x -= outExpo(20.5, .5, sin(t*100.)*1.8, beat);\n    bp.x -= inExpo(20., .5, cos(t*100.)*1.8, beat);\n    bp.x += outExpo(20.5, .5, cos(t*100.)*1.8, beat);\n    til.x += inExpo(20., .5, sin(rand1(til.y)), beat);\n    til.x -= outExpo(20.5, .5, sin(rand1(til.y)), beat);\n    til2.x += inExpo(20., .5, sin(rand1(til.y)), beat);\n    til2.x -= outExpo(20.5, .5, sin(rand1(til.y)), beat);\n    \n    \n    bg_fade += outExpo(21., .5, 1., beat);\n    floor_red += inOutExpo(20.5, 2., 1., beat);\n    floor_fade += inOutExpo(20.5, 2., 1., beat);\n    floor_size -= inOutExpo(20.5, 2., .75, beat);\n   \n    bp.x += inQuart(21., .1, 1.5, beat);\n    bp.y += outQuart(21., .5, 1., beat);\n    bsize += outQuart(21., .5, .5, beat);\n    \n    rp.x -= inQuart(21.25, .1, 1.5, beat);\n    rp.y += outQuart(21.25, .5, 1., beat);\n    rsize += outQuart(21.25, .5, .5, beat);\n    \n    bsize -= linear(21.5, .1, .5, beat);\n    brotation += outBack(21.5, .1, 1., beat, -1.);\n    til2.x += outQuart(22., .25, .1*sin(rand1(til.y)), beat);\n    til2.x -= inQuart(22., .25, .1*sin(rand1(til.y)), beat);\n    \n    bp.x -= outBack(21.75, .5, 1.5, beat, -1.);\n    bp.y -= outBack(21.75, .5, 1., beat, -1.);\n    brotation -= outBack(21.75, .5, 1., beat, -1.);\n    til2.x -= outQuart(22.5, .25, .1*sin(rand1(til.y)), beat);\n    til2.x += inQuart(22.5, .25, .1*sin(rand1(til.y)), beat);\n    \n    bp.x += outBack(22.25, .5, .5, beat, -1.);\n    bp.y += outBack(22.25, .5, .25, beat, -1.);\n    brotation += outBack(22.25, .5, .25, beat, -1.);\n    til2.y += outQuart(23., .25, .1*sin(rand1(til.x*.25)), beat);\n    til2.y -= inQuart(23., .25, .1*sin(rand1(til.x*.25)), beat);\n    \n    bp.x += outBack(22.75, .5, .25, beat, -1.);\n    bp.y -= outBack(22.75, .5, .5, beat, -1.);\n    brotation -= outBack(22.75, .5, .35, beat, -1.);\n    \n    if (beat >= 23.32 && beat <= 24. \n    || beat >= 28.32 && beat <= 29.){\n        loop = mod(beat, .15);\n        lightsout -= linear(0.0, .01, 1., loop);\n        lightsout += linear(0.075, .01, 1., loop);\n    }\n    \n    bp.x -= linear(23.32, .01, .2, beat);\n    bp.y += linear(23.32, .01, .025, beat);\n    brotation += linear(23.32, .01, .12, beat);\n    bp.x -= linear(23.32+.075*2., .01, .2, beat);\n    bp.y += linear(23.32+.075*2., .01, .05, beat);\n    brotation += linear(23.32+.075*2., .01, .12, beat);\n    bp.x -= linear(23.32+.075*4., .01, .2, beat);\n    bp.y += linear(23.32+.075*4., .01, .075, beat);\n    brotation += linear(23.32+.075*4., .01, .12, beat);\n    bp.x -= linear(23.32+.075*6., .01, .2, beat);\n    bp.y += linear(23.32+.075*6., .01, .1, beat);\n    brotation += linear(23.32+.075*6., .01, .12, beat);\n    bp.x -= linear(23.32+.075*8., .01, .2, beat);\n    bp.y += linear(23.32+.075*8., .01, .1, beat);\n    brotation += linear(23.32+.075*8., .01, .12, beat);\n    \n    bp.x -= outCubic(24., .35, .25, beat);\n    bp.y += outCubic(24., .35, .25, beat);\n    brotation += outCubic(24., .25, .25, beat);\n    til2.y += outQuart(24., .25, .1*sin(rand1(til.x)), beat);\n    til2.y -= inQuart(24., .25, .1*sin(rand1(til.x)), beat);\n    til2.x += outQuart(24., .25, .1*cos(rand1(til.y)), beat);\n    til2.x -= inQuart(24., .25, .1*cos(rand1(til.y)), beat);\n    bp.x += inOutCubic(24.25, .5, .25, beat);\n    bp.y -= inOutCubic(24.25, .5, .25, beat);\n    brotation -= inOutCubic(24.15, .5, .25, beat);\n    \n    til2.y += outQuart(24.5, .25, .2*sin(rand1(til.x)), beat);\n    til2.y -= inQuart(24.5, .25, .2*sin(rand1(til.x)), beat);\n    bp.x += outElastic(24.5, .75, .25, beat);\n    bp.y -= outElastic(24.5, .75, .25, beat);\n    brotation -= outElastic(24.5, .75, .25, beat);\n    \n    bp.y -= inOutCubic(24.8, .5, .15, beat);\n    brotation += inOutCubic(24.8, .5, .3, beat);\n    bp.y += inOutCubic(25.3, .5, .25, beat);\n    brotation -= inOutCubic(25.3, .5, .55, beat);\n    if (beat >= 25.5 && beat <= 27.){\n        btil.y += linear(26.-.2, .01, 1.25, beat);\n        btil.y -= outExpo(26.-.1, 1., 1.25, beat);\n        bp.x += linear(26.-.2, .01, .1, beat);\n        bp.x -= outCubic(26.-.1, 1., .1, beat);\n        \n        // Why do I always have to use these cursed magic numbers UGHHHHH\n        \n        btil.y -= linear(26.233-.2, .01, 1.25, beat);\n        btil.y += outExpo(26.233-.1, 1., 1.25, beat);\n        bp.x -= linear(26.233-.2, .01, .1, beat);\n        bp.x += outCubic(26.233-.1, 1., .1, beat);\n        \n        btil.y += linear(26.466-.2, .01, 1.25, beat);\n        btil.y -= outExpo(26.466-.1, .5, 1.25, beat);\n        bp.x += linear(26.466-.2, .01, .1, beat);\n        bp.x -= outCubic(26.46-.16, .5, .1, beat);\n    }\n    \n    \n    floor_red -= inOutExpo(31.5, 1., 1., beat);\n    floor_blue += inOutExpo(31.5, 1., 1., beat);\n    \n    if (beat >= 41.25 && beat <= 52.2){ \n        loop = mod(beat, .644*1.975);\n        loop2 = mod(beat, .644);\n        floor_red += inOutExpo(0., 1., 1., loop);\n        floor_blue -= inOutExpo(0., 1., 1., loop);\n        floor_red -= inOutExpo(.644, 1., 1., loop);\n        floor_blue += inOutExpo(.644, 1., 1., loop);\n        grid_size -= outCirc(0., .225, .1, loop2);\n        grid_size += inCirc(.322, .225, .1, loop2);\n    }\n    \n    bsize -= outQuart(26.5, .5, .05, beat);\n    brotation -= outQuart(26.5, .5, .25, beat);\n    bp.x -= outQuart(26.5, .5, .5, beat);\n    bp.y -= inSine(26.5, .2, .25, beat);\n    \n    bsize += outBack(27., .75, .15, beat, 3.);\n    brotation += outBack(27., .75, .45, beat, 3.);\n    bp.x += outBack(27., .75, 1., beat, 3.);\n    bp.y += outBack(27., .5, .5, beat, 3.);\n    \n    floor_size += outCirc(41.75 , .7*.5, .3, beat);\n    floor_size -= inOutExpo(41.75 , .7*2., .3, beat);\n\n        \n///////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////// Updated Vars //////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n    \n    til = tilt(til, vec2(.0), rtil.x, rtil.y);\n    til2 = tilt(til2, vec2(.0), btil.x, btil.y);\n\tst = fract(st*floor_size*100.)-.5;\n\tfloat lr = 1.-smoothstep(.0, grid_size, .01/abs(st.x));\n\tfloat tb = 1.-smoothstep(.0, grid_size, .01/abs(st.y));\n\t//float lr = smoothstep(abs(st.x), .0, .05);\n\t//float tb = smoothstep(abs(st.y) , .0, .05);\n    \n    float rb = box2(til, rp, rsize, rrotation);\n    float bb = box2(til2, bp, bsize, brotation);\n    float f = 1.;\n    \n    float r1 = box(uv2, vec2(1.-h, .5-h*.8), vec2(outExpo(1., 2., 1.765, beat),h*.8), .0);\n    float r2 = box(uv2, vec2(-1.+h, .25-h*.4), vec2(outExpo(1.5, 2., 1.765, beat),h*.8), .0);\n    float r3 = box(uv2, vec2(1.-h, .0), vec2(outExpo(2., 2., 1.765, beat),h*.8), .0);\n    float r4 = box(uv2, vec2(-1.+h, -.25+h*.4), vec2(outExpo(2.5, 2., 1.765, beat),h*.8), .0);\n    float r5 = box(uv2, vec2(1.-h, -.5+h*.8), vec2(outExpo(3., 4., 1.765, beat),h*.8), .0);\n    \n    float b1 = box(uv2, vec2(.8,.5), vec2(h*1.6,outExpo(6., 2., 1., beat)),.0);\n    float b2 = box(uv2, vec2(.4,-.5), vec2(h*1.6,outExpo(6.5, 2., 1., beat)),.0);\n    float b3 = box(uv2, vec2(.0,.5), vec2(h*1.6,outExpo(7., 2., 1., beat)),.0);\n    float b4 = box(uv2, vec2(-.4,-.5), vec2(h*1.6,outExpo(7.5, 2., 1., beat)),.0);\n    float b5 = box(uv2, vec2(-.8,.5), vec2(h*1.6,outExpo(8., 4., 1., beat)),.0);\n    \n    // seems like I have yet to learn how to layer things properly\n    // pog\n    \n    float B = b1+b2+b3+b4+b5;\n    float R = r1+r2+r3+r4+r5;\n    \n    r1 *= 1.-(B);r1 *= 1.-(rb+bb);\n    r2 *= 1.-(B);r2 *= 1.-(rb+bb);\n    r3 *= 1.-(B);r3 *= 1.-(rb+bb);\n    r4 *= 1.-(B);r4 *= 1.-(rb+bb);\n    r5 *= 1.-(B);r5 *= 1.-(rb+bb);\n    \n    \n    b1 *= (R);b1 *= 1.-(rb+bb);\n    b2 *= (R);b2 *= 1.-(rb+bb);\n    b3 *= (R);b3 *= 1.-(rb+bb);\n    b4 *= (R);b4 *= 1.-(rb+bb);\n    b5 *= (R);b5 *= 1.-(rb+bb);\n    \n    \n    vec3 bg = (vec3(.0,.0,uv2.y*.2+.2)*1.25)*bg_fade;\n    bg += vec3(-(uv2.y-.5)*.5,.0,-uv2.y*.2)*bg_fade;\n   \n    f = min(rb,bb);\n    lr = max((rb+bb+f),lr);tb = max((rb+bb+f),tb);\n    bg = max(-vec3(rb+bb), bg);\n    \n    //bg = max(-vec3(lr*tb),bg);\n    \n    \n    \n    \n    vec3 col;\n    if (beat >= 21.){\n        col += (1.-lr*tb)* vec3(0.,1.,1.)*floor_fade*floor_blue;\n        col += (1.-lr*tb)* vec3(.5,0.,0.45)*floor_fade*floor_red;\n    }\n    \n    \n\tcol *= smoothstep(uv2.y, .5, .3);\n    col += bg;\n\tcol *= vec3(pow(col.x, .24545));\n    col *= 1.25;\n    \n    col += vec3(r1)*vec3(1.,0.,.5);\n    col += vec3(r2)*vec3(1.,0.,.5);\n    col += vec3(r3)*vec3(1.,0.,.5);\n    col += vec3(r4)*vec3(1.,0.,.5);\n    col += vec3(r5)*vec3(1.,0.,.5);\n   \n    col += vec3(b1)*(vec3(0.,.5,1.)*(1.-inOutQuad(10.5, 1., 1., beat)));\n    col += vec3(b2)*(vec3(0.,.5,1.)*(1.-inOutQuad(10.5, 1., 1., beat)));\n    col += vec3(b3)*(vec3(0.,.5,1.)*(1.-inOutQuad(10.5, 1., 1., beat)));\n    col += vec3(b4)*(vec3(0.,.5,1.)*(1.-inOutQuad(10.5, 1., 1., beat)));\n    col += vec3(b5)*(vec3(0.,.5,1.)*(1.-inOutQuad(10.5, 1., 1., beat)));\n    \n    col += vec3(rb)*vec3(1.,0.,.5);\n    col += vec3(bb)*vec3(0.,.5,1.);\n    col += vec3(f);\n    \n\n    fragColor = vec4(col*lightsout,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shoutout to easings.net\n\n#define pi 3.1415\n#define tr start,dur,x\n#define par float start, float dur, float p, float x\n\n// writing start,dur,x everywhere gets annoying\n\nfloat c(float x){\n    return max(0., min(1., (x - .0) / (1. - .0)));\n}\n\nfloat o(float x){\n    return clamp(x,-1., .0);\n}\n\nfloat ease(float easing, float start, float dur, float x){\n    start += 1.;\n    if (x >= start - 1. && x <= start){\n        return easing;\n    }else return o(x - start) + 1.;\n}\n\nfloat linear(par){\n    start /= dur; x /= dur;\n    return p*ease(x - start,tr);\n}\n\nfloat inSine(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - cos(((x - start) * pi) / 2.),tr);\n}\n\nfloat outSine(par){\n    start /= dur; x /= dur;\n    return p*ease(sin(((x - start) * pi) / 2.),tr);\n}\n\n// I am pretty sure doing inEase + outEase would give the same result\n// but whatev, I've already wrote everything out\n\nfloat inOutSine(par){\n    start /= dur; x /= dur;\n    return p*ease(-(cos(pi * (x - start)) - 1.) / 2., tr);\n}\n\nfloat outInSine(par){\n    start /= dur; x /= dur;\n    return p*outSine(start, .5, .5, x) + p*inSine(start + .5, .5, .5, x);\n}\n\nfloat inQuad(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(x - start, 2.),tr);\n}\n\nfloat outQuad(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - pow(1. - (x - start), 2.),tr);\n}\n\nfloat inOutQuad(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5 \n    ? p*ease(2. * ((x - (start * 1.)) * (x - (start * 1.))),tr)\n    : p*ease(1. - pow(-2. * (x - (start * 1.)) + 2., 2.) / 2.,tr);\n}\n\nfloat outInQuad(par){\n    start /= dur; x /= dur;\n    return p*outQuad(start, .5, .5, x) + p*inQuad(start + .5, .5, .5, x);\n}\n\n\nfloat inCubic(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(x - start, 3.),tr);\n}\n\nfloat outCubic(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - pow( 1. - (x - start), 3.),tr);\n}\n\nfloat inOutCubic(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5\n    ? p*ease(4. * (x - start) * (x - start) * (x - start), tr)\n    : p*ease(1. - pow(-2. * (x - start) + 2., 3.) / 2., tr);\n}\n\nfloat outInCubic(par){\n    start /= dur; x /= dur;\n    return p*outCubic(start, .5, .5, x) + p*inCubic(start+.5, .5, .5, x);\n}\n\nfloat inQuart(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(x - start, 4.),tr);\n}\n\nfloat outQuart(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - pow(1. - (x - start), 4.), tr);\n}\n\nfloat inOutQuart(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5 \n    ? p*ease(8. * pow(x - start, 4.), tr)\n    : p*ease(1. - pow(-2. * (x - start) + 2., 4.) / 2., tr);\n}\n\nfloat outInQuart(par){\n    start /= dur; x /= dur;\n    return p*outQuart(start, .5, .5, x) + p*inQuart(start + .5, .5, .5, x);\n}\n\nfloat inQuint(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(x - start, 5.),tr);\n}\n\nfloat outQuint(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - pow(1. - (x - start), 5.), tr);\n}\n\nfloat inOutQuint(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5 \n    ? p*ease(16. * pow(x - start, 5.), tr)\n    : p*ease(1. - pow(-2. * (x - start) + 2., 5.) / 2., tr);\n}\n\nfloat outInQuint(par){\n    start /= dur; x /= dur;\n    return p*outQuint(start, .5, .5, x) + p*inQuint(start + .5, .5, .5, x);\n}\n\nfloat inExpo(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(2., 10. * (x - start) - 10.),tr);\n}\n\nfloat outExpo(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - pow(2., -10. * (x - start)), tr);\n}\n\nfloat inOutExpo(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5\n    ? p*ease(pow(2., 20. * (x - start) - 10.) / 2., tr)\n    : p*ease((2. - pow(2., -20. * (x - start) + 10.)) / 2., tr);\n}\nfloat inOutExpo2(par){\n    start /= dur; x /= dur;\n    return p*inExpo(start, .5, .5, x) + p*outExpo(start + .5, .5, .5, x);\n}\n\nfloat outInExpo(par){\n    start /= dur; x /= dur;\n    return p*outExpo(start, .5, .5, x) + p*inExpo(start + .5, .5, .5, x);\n}\n\nfloat inCirc(par){\n    start /= dur; x /= dur;\n    return p*ease(c(1. - sqrt(1. - pow(x - start, 2.))), tr);\n}\n\nfloat outCirc(par){\n    start /= dur; x /= dur;\n    return p*ease(c(sqrt(1. - pow(x - start - 1., 2.))), tr);\n}\n\nfloat inOutCirc(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5\n    ? p*ease((1. - sqrt(1. - pow(2. * x - start * 2., 1.))) / 2., tr)\n    : p*ease((sqrt(1. - pow(-2. * x + start * 2. + 2., 2.)) + 1.) / 2., tr);\n}\n\nfloat outInCirc(par){\n    start /= dur; x /= dur;\n    return p*outCirc(start, .5, .5, x) + p*inCirc(start + .5, .5, .5, x);\n}\n\nfloat inBack(par, float c1){\n    start /= dur; x /= dur;\n    if (c1 < .0) {\n        c1 = 1.70158;\n    }\n    float c3 = c1 + 1.;\n    \n    return p*ease(c3 * pow((x - start), 3.) - c1 * pow((x - start), 2.), tr);\n}\n\nfloat outBack(par, float c1){\n    start /= dur; x /= dur;\n    if (c1 < .0) {\n        c1 = 1.70158;\n    }\n    float c3 = c1 + 1.;\n    \n    return p*ease(1. + c3 * pow((x - start) - 1., 3.) + c1 * pow((x - start) - 1., 2.), tr);\n}\n\nfloat inOutBack(par){\n    start /= dur; x /= dur;\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n    \n    return x - (start - 1.) < 1.5\n    ? p*ease((pow(2. * (x - start), 2.) * ((c2 + 1.) * 2. * (x - start) - c2)) / 2., tr)\n    : p*ease((pow(2. * (x - start) - 2., 2.) * ((c2 + 1.) * ((x - start) * 2. - 2.) + c2) + 2.) / 2., tr);\n}\n\nfloat outInBack(par, float c1){\n    start /= dur; x /= dur;\n    return p*outBack(start, .5, .5, x, c1) + p*inBack(start + .5, .5, .5, x, c1);\n}\n\nfloat inElastic(par){\n    start /= dur; x /= dur;\n    float c4 = (2. * pi) / 3.;\n    \n    return p*ease(-pow(2., 10. * (x - start) - 10.) * sin(((x - start) * 10. - 10.75) * c4), tr);\n}\n\nfloat outElastic(par){\n    start /= dur; x /= dur;\n    float c4 = (2. * pi) / 3.;\n    \n    return p*ease(pow(2., -10. * (x - start)) * sin(((x - start) * 10. - 0.75) * c4) + 1., tr);\n}\n\nfloat inOutElastic(par){\n    start /= dur; x /= dur;\n    float c5 = (2. * pi) / 4.5;\n    \n    return x - (start - 1.) < 1.5\n      ? p*ease(-(pow(2., 20. * (x - start) - 10.) * sin((20. * (x - start) - 11.125) * c5)) / 2., tr)\n      : p*ease((pow(2., -20. * (x - start) + 10.) * sin((20. * (x - start) - 11.125) * c5)) / 2. + 1., tr);\n}\n\nfloat outInElastic(par){\n    start /= dur; x /= dur;\n    return p*outElastic(start, .5, .5, x) + p*inElastic(start + .5, .5, .5, x);\n}\n\n","name":"Common","description":"","type":"common"}]}