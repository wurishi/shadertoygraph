{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float RAINBOW_SPLINE_SIZE = 6.0;\n\n\n/**\n * Lookup table for rainbox colors. Workaround as GLSL does not support arrays.\n * @param i: Array index; Should be integer.\n * @return The color at the given index.\n */\nvec3 GetRainbowColor(float i){\n\tif(i == 0.0){\n\t\treturn vec3(1.0, 0.0, 0.0); // Red\n\t}\n    else if(i == 1.0){\n\t\treturn vec3(1.0, 0.5, 0.0); // Orange\n\t}\n\telse if(i == 2.0){\n\t\treturn vec3(1.0, 1.0, 0.0); // Yellow\n\t}\n\telse if(i == 3.0){\n\t\treturn vec3(0.0, 1.0, 0.0); // Green\t\n    }\n\telse if(i == 4.0){\n\t\treturn vec3(0.0, 0.0, 1.0); // Blue\t\n\t}\n\telse if (i == 5.0){\n        return vec3(0.27, 0.0, 0.51); // Purple\n\t}\n\telse if (i == 6.0){\n\t\treturn vec3(0.57, 0.0, 1.0); // Violet\t\n\t}\n\n\treturn vec3(1.0, 1.0, 1.0); // should never get here.\n}\n\n/**\n * Perform Catmull-Rom spline interpolation between support points v1 and v2.\n * @param x: Interpolation factor between v1 and v2; Range[0.0,1.0]\n * @param v0: left most control point.\n * @param v1: left support point.\n * @param v2: right support point.\n * @param v3: right most control point.\n * @return The interpolated value.\n */\nvec3 CatmullRomSpline(float x, vec3 v0, vec3 v1, vec3 v2, vec3 v3) \n{\n    // Note: this spline will go through it's support points.\n\tvec3 c2 = -.5 * v0\t\t\t\t+ 0.5 *v2;\n\tvec3 c3 = \t\tv0\t+ -2.5*v1 \t+ 2.0 *v2 + -.5*v3;\n\tvec3 c4 = -.5 * v0\t+ 1.5 *v1 \t+ -1.5*v2 + 0.5*v3;\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\n}\n\n/**\n * Evaluates the rainbox texture in UV-space using a Catmull-Rom spline.\n */\nvec3 EvaluateRainbowSpline(float x){\n    // x must be in range [0.0,1.0]\n    float scaledX = clamp(x, 0.0, 1.0) * RAINBOW_SPLINE_SIZE;\n    \n    // Determine which 'rainbox segment' we are evluating:\n    float segmentIndex = floor(scaledX);\n    \n    // Note that you evaluate between v1 and v2, using v0 and v3 as control points:\n    vec3 v0 = GetRainbowColor(segmentIndex-1.0);\n    vec3 v1 = GetRainbowColor(segmentIndex+0.0);\n    vec3 v2 = GetRainbowColor(segmentIndex+1.0);\n    vec3 v3 = GetRainbowColor(segmentIndex+2.0);\n    \n    return CatmullRomSpline(fract(scaledX), v0,v1,v2,v3);\n}\n\n\n\n/**\n * Creates a hashkey based on a 2D variable.\n * Note: Using haskeys directly as noise function gives non-coherent noise.\n * @return: Haskey in range [0.0, 1.0)\n */\nfloat hash(in vec2 p){\n    // Transform 2D parameter into a 1D value:\n    // Note: higher value means 'higher frequency' when plugging uv coordinates.\n    float h = dot(p, vec2(12.34, 56.78));\n    \n    // Use a sinusoid function to create both positive and negative numbers.\n    // Multiply by a big enough number and then taking only the fractional part creates a pseudo-random value.\n    return fract(cos(h)*12345.6789);\n}\n\n/**\n * Create a coherent noise using the perline noise algorithm. Haskeys are\n * used to remove the need of an array of random values.\n * @return: noise value in the range[0.0, 1.0)\n */\nfloat perlinNoise( in vec2 p )\n{\n    // see: http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html#whatsnoise\n    vec2 i = floor(p); // Use hashing with this to fake a gridbased value noise.\n    vec2 f = fract(p);\n\t\n    // Using this 'ease curve' generates more visually pleasing noise then without.\n    // Function describes a function similar to a smoothstep.\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix(hash(i + vec2(0.0,0.0)), \n                    hash(i + vec2(1.0,0.0)), u.x),\n                mix(hash(i + vec2(0.0,1.0)), \n                    hash(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\n/**\n * Performs a fractal sum of the same noise function for different 'frequencies'.\n * @return: noise value in the range [0.0, ~1.94)\n */\nfloat fractalSumNoise(in vec2 p){\n    float value = 0.0;\n    \n    float f = 1.0;\n    \n    // Experimentation yielded 5 itterations gave optimal results. Less itterations gave too\n    // blotchy result, and more itterations did no longer have any significant visual impact.\n    for (int i = 0; i < 10; i++){\n        value += perlinNoise(p * f)/f;\n        f = f * 2.0;\n    }\n    \n    return value;\n}\n\n\n/**\n * Creates a hashkey based on a 3D variable.\n * Note: Using haskeys directly as noise function gives non-coherent noise.\n * @return: Haskey in range [0.0, 1.0)\n */\nfloat hash3(in vec3 p){\n    // Transform 3D parameter into a 1D value:\n    // Note: higher value means 'higher frequency' when plugging uv coordinates.\n    float h = dot(p, vec3(123.45, 678.91, 234.56));\n    \n    // Use a sinusoid function to create both positive and negative numbers.\n    // Multiply by a big enough number and then taking only the fractional part creates a pseudo-random value.\n    return fract(cos(h)*12345.6789);\n}\n\n/**\n * Create a coherent noise using the perline noise algorithm. Haskeys are\n * used to remove the need of an array of random values.\n * @return: noise value in the range[0.0, 1.0)\n */\nfloat perlinNoise3( in vec3 p )\n{\n    // see: http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html#whatsnoise\n    vec3 i = floor(p); // Use hashing with this to fake a gridbased value noise.\n    vec3 f = fract(p);\n\t\n    // Using this 'ease curve' generates more visually pleasing noise then without.\n    // Function describes a function similar to a smoothstep.\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    float dx1 = mix(hash3(i + vec3(0.0,0.0,0.0)), \n                    hash3(i + vec3(1.0,0.0,0.0)), u.x);\n    float dx2 = mix(hash3(i + vec3(0.0,1.0,0.0)), \n                    hash3(i + vec3(1.0,1.0,0.0)), u.x);\n    float dy1 = mix(dx1, dx2, u.y);\n    \n    float dx3 = mix(hash3(i + vec3(0.0,0.0,1.0)), \n                    hash3(i + vec3(1.0,0.0,1.0)), u.x);\n    float dx4 = mix(hash3(i + vec3(0.0,1.0,1.0)), \n                    hash3(i + vec3(1.0,1.0,1.0)), u.x);\n    float dy2 = mix(dx3, dx4, u.y);\n    \n    return mix(dy1, dy2, u.z);\n}\n\n/**\n * Performs a fractal sum of the same noise function for different 'frequencies'.\n * @return: noise value in the range [0.0, ~1.94/2)\n */\nfloat fractalSumNoise3(in vec3 p){\n    float value = 0.0;\n    \n    float f = 1.0;\n    \n    // Experimentation yielded 5 itterations gave optimal results. Less itterations gave too\n    // blotchy result, and more itterations did no longer have any significant visual impact.\n    for (int i = 0; i < 5; i++){\n        value += perlinNoise3(p * f)/f;\n        f = f * 2.0;\n    }\n    \n    return value/2.0;\n}\n\nfloat pattern( in vec3 p )\n  {\n      vec3 q = vec3( fractalSumNoise3( p + vec3(0.0,0.0,0.0)),\n                     fractalSumNoise3( p + vec3(5.2,1.3,0.7)),\n                     fractalSumNoise3( p + vec3(6.7,2.6,1.2)));\n\n      return fractalSumNoise3( p + 4.0*q );\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // TODO: Add code to create your texture based on perline noise.\n    // Some idea's:\n    // * Start with visualizing the fractal sum and play around with the number of iterations and factors.\n    // * Experiment with coloring the noise texture based on the noise value. (Use for example a spline: https://www.shadertoy.com/view/MdBXzG)\n    // * Experiment using different coordinates in the perlinNoise function.\n    // * Experiment with creating your own hash function.\n    // * Experiment with creating a 3D animated noise texture.\n    // * Experiment with using domain warping: https://iquilezles.org/articles/warp\n    // * Experiment with combining raymarching and 3D solid texturing like in the marble example: https://www.shadertoy.com/view/ldjSz3\n    \n\tfragColor = vec4(pattern(vec3(5.0*uv,0.5+0.5*sin(0.3*iTime))),\n                        pattern(vec3(5.0*uv,0.5+0.5*cos(0.3*iTime))),\n                        pattern(vec3(0.5+0.5*sin(0.3*iTime),5.0*uv)),\n                        1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llX3Rn","date":"1418036005","viewed":742,"name":"Ruined Waterpaint Painting","username":"Zartos","description":"Waterpaint, flowing.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise","waterpaint"],"hasliked":0,"parentid":"","parentname":""}}