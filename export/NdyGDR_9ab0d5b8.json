{"ver":"0.1","info":{"id":"NdyGDR","date":"1631297355","viewed":103,"name":"Naive Truchet","username":"104","description":"just having some fun","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2dsimple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// naive implementation of truchet pattern.\n// using smootherstep() reduces discontinuities interpolating attributes between cells\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat smootherstep01(float x) {\n  x = clamp(x, 0.0, 1.0);\n  return x * x * x * (x * (x * 6. - 15.) + 10.);\n}\n\n\nvoid mainImage(out vec4 o, vec2 C)\n{\n    vec2 uv = C/iResolution.x;\n    uv += 100. + iTime * vec2(.1,0);\n    uv *= 11.;\n    \n    vec2 cellOrig = floor(uv); // cell size 1 for efficiency.\n    \n    // positions of some points in the cell.\n    vec2 top = cellOrig + vec2(.5,0);\n    vec2 left = cellOrig + vec2(0,.5);\n    vec2 bottom = cellOrig + vec2(.5,1);\n    vec2 right = cellOrig + vec2(1,.5);\n    \n    // default cell configuration\n    vec2 o1 = cellOrig; // origin of circle 1\n    vec2 o2 = cellOrig+1.; // origin of circle 2\n    vec2 o1p1 = top; // clockwise circle points\n    vec2 o1p2 = left;\n    vec2 o2p1 = bottom;\n    vec2 o2p2 = right;\n    // for calculating position along circle we just calculate angle and offset quadrant into 0-1 window.\n    // you could theoretically just do fract(atan()) but it produces glitches.\n    float angleOffset1 = 0.,\n    angleOffset2 = 2.;\n    \n    vec4 hcell = hash42(cellOrig+.5);\n    \n    // alternate cell configuration\n    if (hcell.x < .5) {\n        o1 = cellOrig+vec2(1,0); \n        o2 = cellOrig+vec2(0,1);\n        o1p1 = right;\n        o1p2 = top;\n        o2p1 = left;\n        o2p2 = bottom;\n        angleOffset1 = 1.;\n        angleOffset2 = -1.;\n    }\n\n    // generate random params for points. adjascent cells share points so they will be continuous.\n    vec4 h11 = hash42(o1p1); // color of point 1 of circle 1\n    vec4 h12 = hash42(o1p2); // point 2 of circle 1\n    vec4 h21 = hash42(o2p1);\n    vec4 h22 = hash42(o2p2);\n\n    // calculate position along circle\n    vec2 rel1 = uv - o1; // uv relative to circle 1\n    vec2 rel2 = uv - o2;\n    float c1p = angleOffset1 + atan(rel1.x, rel1.y)/6.28*4.;\n    float c2p = angleOffset2 + atan(rel2.x, rel2.y)/6.28*4.;\n\n    const float maxW = .21;\n    float width11 = mix(h11.w, h11.z, sin(h11.x*100.+iTime*h11.y*3.)*.5+.5);\n    float width12 = mix(h12.w, h12.z, sin(h12.x*100.+iTime*h12.y*3.)*.5+.5);\n    float width21 = mix(h21.w, h21.z, sin(h21.x*100.+iTime*h21.y*3.)*.5+.5);\n    float width22 = mix(h22.w, h22.z, sin(h22.x*100.+iTime*h22.y*3.)*.5+.5);\n\n    float width1 = mix(width12, width11, smootherstep01(c1p))*maxW;\n    float width2 = mix(width22, width21, smootherstep01(c2p))*maxW;\n\n    // signed distance to donut1\n    float sd1 = length(rel1)-.5+width1;\n    sd1 = min(sd1, -(length(rel1)-.5-width1));\n    \n    float sd2 = length(rel2)-.5+width2;\n    sd2 = min(sd2, -(length(rel2)-.5-width2));\n    \n    // using colors, positions, and distance to donuts, color.\n    o = vec4(0);\n    h11.xy = (h11.xy * rot2D(h11.w * iTime + h11.x*100.)) * .5 + .5;\n    h12.xy = (h12.xy * rot2D(h12.w * iTime + h12.x*100.)) * .5 + .5;\n    h21.xy = (h21.xy * rot2D(h21.w * iTime + h21.x*100.)) * .5 + .5;\n    h22.xy = (h22.xy * rot2D(h22.w * iTime + h22.x*100.)) * .5 + .5;\n    \n    o += mix(h12, h11, smootherstep01(c1p)) * smoothstep(0.,.02, sd1);\n    o += mix(h22, h21, smootherstep01(c2p)) * smoothstep(0.,.02, sd2);\n    /* // for debugging, revealing key points and angles\n    if (length(uv - o1p1) < 0.1) {\n        o = h11;\n    }\n    if (length(uv - o1p2) < 0.1) {\n        o = h12;\n    }\n    if (length(uv - o2p1) < 0.1) {\n        o = h21;\n    }\n    if (length(uv - o2p2) < 0.1) {\n        o = h22;\n    }\n    if (C.y < 50.) {\n        o = vec4(c1p);\n    }\n    else if (C.y < 100.) {\n        o = vec4(c2p);\n    }//*/\n}\n\n\n","name":"Image","description":"","type":"image"}]}