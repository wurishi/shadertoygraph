{"ver":"0.1","info":{"id":"4XVGDD","date":"1725974817","viewed":22,"name":"cult of the vault","username":"0x177","description":"eden 5","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"l3XGRl","parentname":"raymarching startingpoint"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 250.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 0.8; // how strong is the diffuse lightning\nconst float globalSpecular = 0.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 32.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(1.0, 1.0, 1.5); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(0.0, 0.0, 0.0); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat displace(vec3 n) {\n    return sin(n.x * 1.0)*0.9 + sin(n.z * 3.0) * 0.3 + sin(n.z * 5.0) * 0.1;\n}\n\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 GetDist(vec3 p) {    \n    float d = 999.0;\n    float mat = 0.0;\n        \n    //float f = abs(dot(p,vec3(1.0,0.23,0.0)+0.1))-5.0;\n    \n    float s = length(p-vec3(0.0,0.0,-120.0))-60.0;\n    \n    //s = max(s,-f);\n    \n    vec3 n = (p-vec3(0.0,0.0,-120.0))/60.0;\n    float di = displace(2.0*p+n)*13.0;\n    \n    s += di * 0.01;\n    \n    d = min(d,s);\n    mat = (d==s) ? 0.0 : mat;\n    \n    float near = length(p.xy)-1.3;\n    \n    near = max(near,-(near+0.05));\n    \n    vec2 w = vec2( near, abs(p.z) - 0.1 );\n    near =  min(max(w.x,w.y),0.0) + length(max(w,0.0));\n\n    p.y += p.x * p.x * 2.7;\n    p.y -= 1.8;\n    float b = box(p-vec3(0.0,-1.0,0.0),vec3(0.79,0.15,0.1));\n    near = min(near,b);\n    \n    d = min(d,near);\n    mat = (d==near) ? 1.0 : mat;\n    \n    return vec2(d,mat);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n        \n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1. );\n}\n\n\nvec3 shade(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           vec3 normal,\n                           vec3 ray_direction\n)\n{\n      vec3 toLight = normalize(lightPosition - position);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n\n      float ao = ambientOcclusion(position+normal*0.1,normal);\n      float ss= softshadow(position,lightPos,0.1,10.0);\n       \n    diffuseFactor *= ss;\n    diffuseFactor *= ao;\n    return ambientFactor + diffuseFactor;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-2.6*PI+1.);\n    ro.xz *= Rot(-0.5*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 0.5);\n    vec3 bg = boxmap(iChannel0,rd,-rd,1.0).rgb;\n    vec3 col = bg;\n   \n    vec2 rm = RayMarch(ro, rd);\n    float d = rm.x;\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        if (rm.y == 0.0) {\n            vec3 tp = p;\n            tp.y += sin(p.x) + sin(p.x * 2.0) * 0.5;\n            \n            float minor = max(sin(tp.y*0.5),0.0)*0.8;\n            minor *= 0.5;\n            \n            col = mix(vec3(1.,1.,0.929)*0.6,vec3(0.6,0.3,0.0)*0.8,minor);\n            \n            float major = max(sin(tp.y*0.15),0.0);\n            \n            col = mix(col,vec3(0.941,0.592,0.694)*0.7,major);\n        } else {\n            col = vec3(0.529,0.61,0.9);\n        }\n        col *= shade(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,n,rd);\n        //col = mix(col,bg,1.0 - exp(-0.0004*d*d));\n    }\n    \n    float c = 1.4;\n    float b = 0.0;\n    col = c * (col-0.5) + 0.5 + b;\n    vec3 greyscale = vec3(dot(col,vec3(0.299,0.587,0.114)));\n    col = mix(greyscale,col,1.3);\n    col = clamp(col,vec3(0.0),vec3(1.0));\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//https://www.shadertoy.com/view/lsfGWH\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        float size = 30.0;\n        float prob = 0.95;\n\n        vec2 pos = floor(1.0 / size * fragCoord.xy);\n\n        float color = 0.0;\n        float starValue = rand(pos);\n\n        if (rand(fragCoord.xy / iResolution.xy) > 0.996)\n        {\n            float r = rand(fragCoord.xy);\n            color = r * (0.25 * sin(iTime * (r * 5.0) + 720.0 * r) + 0.75);\n        }\n\n        fragColor = vec4(vec3(color), 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}