{"ver":"0.1","info":{"id":"McVcRh","date":"1731506013","viewed":98,"name":"Rhombitrihexagonal waves","username":"Elsio","description":"agora faltam 6","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tiling","extrude","semiregular"],"hasliked":0,"parentid":"lctyWf","parentname":"Semiregular 3 4 6 4"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define H(p) fract(29. * sin(p + p) * sin(p).yx)\n#define h21(p) fract(sin(dot(p, vec2(117.619, 57.623))) * 43758.5453)\n#define rot(a) mat2(cos(a + vec4(0, 1, 3, 0) * pi / 2.))\n#define pi acos(-1.)\n#define t iTime\n#define tau (2.*pi)\n#define FAR 30.\n\nvec2 s = vec2(sqrt(3.), 1);\nvec2 ID;\n\nfloat opExtrusion(float sdf, float pz, float h) {\n    vec2 w = vec2(sdf, abs(pz) - h);\n    return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nfloat sdHex(vec2 p, float r) {\n    vec2 h = vec2(-sqrt(3.), 1);\n    p = abs(p);\n    p -= min(dot(h, p) / 2., 0.) * h;\n    vec2 k = vec2(clamp(p.x, - r / sqrt(3.), r / sqrt(3.)), r);\n\n    return length(p - k) * sign(p.y - r);\n}\n\nfloat sdTri(vec2 p, float r) {\n    const float k = sqrt(3.);\n    p.x = abs(p.x) - r;\n    p.y += r / k;\n    \n    if(p.x + k * p.y > 0.) \n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.;\n    p.x -= clamp(p.x, -2. * r, 0.);\n    return -length(p) * sign(p.y);\n}\n\nfloat box(vec2 p, float b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat hm(vec2 p) {\n    float t = iTime * .6;\n    float s = 6.;\n    return tanh(cos(\n               + p.x * .3 * cos(t * .2) \n               + p.y * .3 * sin(t * .08) \n           ) * 6. - 4.) * .25;\n}\n\nfloat polarRot(vec2 p, out int na, float n) {\n    float m = mod(\n                floor(atan(p.y, p.x) / tau * n), \n                n\n            );\n    \n    na = int(m);\n\n    return -tau * (m + .5) / n;\n}\n\nvoid hexGrid(vec2 P, out vec2 q, out vec2 id) {\n    vec4 ip = floor(vec4(P / s, P / s - .5)) + .5;\n    vec4 p = P.xyxy - vec4(ip.xy, ip.zw + .5) * s.xyxy;\n    \n    q = p.zw;\n    id = ip.zw + .5;\n    if (dot(p.xy, p.xy) < dot(p.zw, p.zw)){\n        q = p.xy;\n        id = ip.xy;\n    }\n}\n\nstruct piece{\n    float d;\n    vec2 p, id;\n};\n\nfloat Piece(float py, piece pc){\n    float h = hm(pc.id), d = pc.d;\n    \n    float dd = opExtrusion(d, py - h / 2., h / 2. + .13);\n    dd += d * .4;\n\n    return dd;\n}\n\n\nfloat map(vec3 p) {\n    vec2[] vID = \n            vec2[](\n                vec2(-4,  0), vec2(-2,  6), vec2( 2,  6),\n                vec2( 4,  0), vec2( 2, -6), vec2(-2, -6)\n            );\n\n    vec2[] eID = \n            vec2[](\n                vec2(-3, 3), vec2(0, 6), vec2(3, 3), \n                vec2(3, -3), vec2(0, -6), vec2(-3, -3)\n            );\n    \n    vec2 q0, id;\n    hexGrid(p.xz, q0, id);\n    id *= 12.;\n    \n    float r = 1. / sqrt(7.) / 2.;\n    float ew = .03;\n    int na;\n    \n    // hex\n    piece hex;\n    hex.p = q0;\n    hex.d = sdHex(hex.p, r * sqrt(3.) - ew);\n    hex.id = id;\n    \n    // tri\n    piece tri;\n    tri.p = q0 * rot(polarRot(q0 * rot(-pi / 6.), na, 6.)) - vec2(.5, sqrt(1. / 3.) / 2.); \n    tri.d = sdTri(tri.p, r - ew);\n    tri.id = id + vID[(8 - na) % 6 ];\n\n    // square a\n    piece sqrH1;\n    sqrH1.p = q0 * rot(pi / 6. + polarRot(q0, na, 3.)) - vec2(.5, 0);\n    sqrH1.d = box(sqrH1.p, r - ew);\n    sqrH1.id = id + eID[(8 - na * 2) % 6];\n    \n    // square b\n    piece sqrH2;\n    sqrH2.p = q0 * rot(-pi / 6. + polarRot(q0, na, 3.)) - vec2(.5, 0);\n    sqrH2.d = box(sqrH2.p, r - ew);\n    sqrH2.id = id + eID[(7 - na * 2) % 6];\n\n    piece[] pcs = piece[](hex, tri, sqrH1, sqrH2);\n\n    float d = 1e5;\n    for(int i; i < pcs.length(); i++){\n        float dd = Piece(p.y, pcs[i]);\n        if(dd < d) \n            d = dd, ID = pcs[i].id; \n    }\n    \n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float t, d;\n    for(int i; i < 196; i ++) {\n        d = map(ro + rd * t);\n        \n        if(abs(d) < .01 || t > FAR) break;\n        t += d * .7;\n    }\n    return t;\n}\n\n\nvec3 normal(vec3 p) {\n    vec3 e = vec3(.01, 0, 0);\n    vec3 v = vec3(\n                 map(p - e.xyy),\n                 map(p - e.yxy),\n                 map(p - e.yyx)\n             ) - map(p);\n    return normalize(-v);\n}\n\nfloat AO(vec3 p, vec3 n) {\n    float sca = 1., occ;\n    \n    for(int i = 0; i < 5; i ++) {\n        float hr = float(i + 1) * .15 / 6.;\n        \n        float d = map(p + n * hr);\n        occ += (hr - d) * sca;\n        sca *= .8;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\n\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n    u = (u - r / 2.) / r.y;\n    \n    vec3 p = vec3(cos(t*.3), 1, sin(t*.2)) * 4.,\n         D = normalize(vec3(u, 3));\n    \n    D.yz *= rot(pi / 2.- 1.);\n    \n    p.xz *= rot(t * .03);\n    D.xz *= rot(t * .05);\n    \n    float d = march(p, D);\n    \n    float a = iTime;\n    vec3 L = normalize(vec3(1, 1 , 0) - D);\n    \n    o = vec4(0);\n    if (d < FAR){\n        vec2 id = ID;\n        vec3 p = p + d * D,\n             N = normal(p);\n             \n        o = vec4(H(id), H(id + .5)) * .8\n             * AO(p, N)\n             * (max(0., dot(L, N)) * .5 + .7)\n             + pow(max(0., dot(L, N)), 180.) * .3;\n    }\n    \n    o = mix(o, vec4(o.x + o.y + o.z) / 3., .5);\n}","name":"Image","description":"","type":"image"}]}