{"ver":"0.1","info":{"id":"cdGyRK","date":"1696282136","viewed":54,"name":"TestProceduralTextureStickman","username":"Accelerator","description":"stickman with texture","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sdf","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 5 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat sdSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 1.0;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat smoothUnion ( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n  \n   float move =  sin(iTime*10.0f)/2.0f;\n   \n   float ball = sdSphere (q, vec3(0.0,-1.8,0.0));\n   \n   float firstLeg = sdCapsule (q,vec3(0.0,0.0,0.0),vec3(-0.3,-0.75,move),0.1);\n   float secondLeg = sdCapsule (q,vec3(0.0,0.0,0.0),vec3(0.3,-0.75,-move),0.1);\n   \n   float body = sdCapsule (q,vec3(0.0,0.0,0.0),vec3(0.0,0.8,0.0),0.1);\n   \n   float firstArm = sdCapsule (q,vec3(0.0,0.8,0.0),vec3(-0.5, 0.45,-move),0.1);\n   float secondArm = sdCapsule (q,vec3(0.0,0.8,0.0),vec3(0.5, 0.45,move),0.1);\n   \n   float head = sdCapsule (q,vec3(0.0,0.8,0.0),vec3(0.0, 1.1, 0.0),0.12);\n   \n   float stickman = smoothUnion (ball, firstLeg, 0.03f);\n   stickman = smoothUnion (stickman, secondLeg, 0.03f);\n   stickman = smoothUnion (stickman, body, 0.07f);\n   stickman = smoothUnion (stickman, firstArm, 0.07f);\n   stickman = smoothUnion (stickman, secondArm, 0.07f);\n   stickman = smoothUnion (stickman, head, 0.07f);\n   \n   return stickman;\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvec3 getTriplanarWeights ( in vec3 n ) \n{\n\tvec3 triW = abs(n);\n    \n\treturn triW / (triW.x + triW.y + triW.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     =  rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0.1, 0.1, 0.1, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n      \n\t\tcolor = vec4 ( nl );\n           \n        vec3 tx = getTriplanarWeights ( n );\n        vec3 q  = m * p;\n        vec4 cx = texture ( iChannel0, q.yz );\n        vec4 cy = texture ( iChannel0, q.zx );\n        vec4 cz = texture ( iChannel0, q.xy );\n        color *=  tx.x * cx + tx.y * cy + tx.z * cz;\n\t} \n\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat DiamondPattern(in vec2 uv)\n{\n  vec2 dp = abs (fract(uv* sin(iTime / 10.0) * 15.0) - 0.5);\n  \n  return 0.3 - cos (12. * max(dp.x, dp.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv   = 2.0 * fragCoord/iResolution.xy;\n    vec4 color1 = vec4 (sin(iTime), cos(iTime), 1.0, 1.0);\n    vec4 color2 = vec4 (1.0);\n    float p = DiamondPattern(uv);\n    fragColor = mix(color1, color2, p);\n}","name":"Buffer A","description":"","type":"buffer"}]}