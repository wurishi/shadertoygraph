{"ver":"0.1","info":{"id":"3lK3WW","date":"1578955156","viewed":465,"name":"una cosa","username":"bitnenfer","description":"A small experiment I did while I waited for UE4 to compile.","likes":28,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 uncharted2Tonemap(const vec3 x) {\n\tconst float A = 0.15;\n\tconst float B = 0.50;\n\tconst float C = 0.10;\n\tconst float D = 0.20;\n\tconst float E = 0.02;\n\tconst float F = 0.30;\n\treturn ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nvec3 tonemapUncharted2(const vec3 color) {\n\tconst float W = 11.2;\n\tconst float exposureBias = 2.0;\n\tvec3 curr = uncharted2Tonemap(exposureBias * color);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W));\n\treturn curr * whiteScale;\n}\n\n// Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemapFilmic(const vec3 color) {\n\tvec3 x = max(vec3(0.0), color - 0.004);\n\treturn (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvec3 tonemapReinhard(const vec3 color) {\n\treturn color / (color + vec3(1.0));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n    fragColor = vec4(acesFilm(c.rgb),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define MAX_DIST 101.0\n#define BOUNCE_COUNT 4\n#define SAMPLE_COUNT 5\n\nfloat gAnimate = 0.0;\n\nstruct HitResult\n{\n    vec3 color;\n    float isSkybox;\n    float dist;\n    float diffuse;\n    float specular;\n    int id;\n};\n\n\nfloat gSeed = 0.0;\nvec2 gUV;\n\nfloat hash( float n )\n{\n    return fract(sin(n + gSeed)*43758.5453);\n}\n\nfloat random() {\n\n    return hash(fract(sin(dot(gUV, vec2(12.9898, 78.233)) * (gSeed += 1.0)) * 43758.5453));\n}\n\nvec3 randomHemispherePoint(vec3 n)\n{\n    float theta = random() * (PI*2.0);\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float r)\n{\n    float cr = cos(r);\n    float sr = sin(r);\n    return mat2(cr, sr, -sr, cr);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 a = abs(p) - s;\n    return length(max(a, 0.0)) + min(max(a.x,max(a.y, a.z)),0.0);\n}\n\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\nvec3 GDFVectors[19];\n\nfloat fGDF(vec3 p, float r) {\n    float d = 0.0;\n    for (int i = 3; i <= 6; ++i)\n        d = max(d, abs(dot(p, GDFVectors[i])));\n    return d - r;\n}\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r) {\n    return fGDF(p, r);\n}\n\nHitResult opUnion(HitResult a, HitResult b)\n{\n    if (a.dist < b.dist)\n    {\n        return a;\n    }\n    return b;\n}\n\nHitResult opSmin(HitResult a, HitResult b, float f)\n{\n    if (a.dist < b.dist)\n    {\n        a.dist = smin(a.dist, b.dist, f);\n        return a;\n    }\n    b.dist = smin(b.dist, a.dist, f);\n    return b;\n}\n\nvec3 tpm(vec3 p, vec3 n)\n{\n    float sc = 0.5;\n    vec3 colX = texture(iChannel2, p.zy * sc).rgb;\n    vec3 colY = texture(iChannel2, p.xz * sc).rgb;\n    vec3 colZ = texture(iChannel2, p.xy * sc).rgb;\n    vec3 n2 = n;\n    vec3 bw = abs(n2);\n    bw = bw / (bw.x + bw.y + bw.z);\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\nfloat time = 0.0;\nHitResult map(vec3 p)\n{        \n  \tvec4 t = texture(iChannel1, p.xz * 0.08) * 1.5;\n  \tvec4 t1 = texture(iChannel1, abs(time * 0.001 + p.yz * 0.005));\n  \tvec4 t2 = texture(iChannel1, abs(time * 0.001 + p.xy * 0.05));\n  \tvec4 t3 = texture(iChannel1, abs(p.yz * 0.01));\n\n    HitResult result;\n\n    float scene = MAX_DIST;\n    float skyboxSize = 30.0;\n    float skybox = length(p) - skyboxSize;\n    skybox = max(skybox, -(length(p) - (skyboxSize-  0.5)));\n    float ss = smoothstep(-0.6, 2.0, 1.0 - (p.y / (MAX_DIST * 0.1)));\n    HitResult skyboxResult = HitResult(ss * mix(2.0*vec3(0.2, 0.5, 1.0), vec3(3.0), (1.0-ss)*(t1.r + t2.r + t3.r) / 3.0), 1.0, skybox, 0.0, 0.0, 0);\n\tfloat sun = length(p + vec3(0.0, -35.0, 15.0)) - 20.0;\n    HitResult sunResult = HitResult(vec3(55.0, 35.0, 20.0) * 0.2, 1.0, sun, 0.0, 0.0, 0);\n    \n    vec3 bp = p;\n    //bp.xz*=rot(time+1.0);\n    \n\tvec3 pp = p-vec3(0.0, 0.0, 0.0);\n    pp = abs(pp) - vec3(0.7);\n    float middle = min(fOctahedron(pp, 0.4), box(pp, vec3(0.35)));\n    HitResult middleResult = HitResult(vec3(0.8, 0.4, 0.5), 0.0, middle, 1.0, 0.0, 1);\n\n\t\n    float boxSize = 0.75;\n    float boxSDF = box(bp, vec3(boxSize));\n    float box1 = boxSDF;\n    float width = boxSize - 0.1;\n    boxSDF = max(boxSDF, -box(bp, vec3(width, 10.0, width)));\n    boxSDF = max(boxSDF, -box(bp, vec3(10.0, width, width)));\n    boxSDF = max(boxSDF, -box(bp, vec3(width, width, 10.0)));\n    \n    \n    float floorSDF = ((p.y + (1.0 - (t.r*0.9) * clamp(length(p) - 1.5, 0.0, 1.0))) * 0.7);\n    HitResult floorResult = HitResult(vec3(0.3, 1.0, 0.0), 0.0, floorSDF, 1.0, 0.8 - t.r * 0.1, 0);\n    HitResult boxResult = HitResult(vec3(0.0), 0.0, boxSDF, 0.5, 1.0, 0);\n    vec3 spherePos = p - vec3(sin(time * 1.4), 0.5-cos(time * 0.5), -sin(time * 2.0))*1.2;\n    spherePos.xz *= rot(time);\n    spherePos.yx *= rot(time);\n    float c = mod((floor(spherePos.x) + floor(spherePos.z) + floor(spherePos.y)), 2.0);\n    float sphereSDF = length(spherePos) - .4;\n\n    HitResult sphereResult = HitResult(c*vec3(80.0, .0, 50.0), 0.0, sphereSDF, 1.0, c, 0);\n    HitResult sceneResult = opUnion(boxResult, sphereResult);\n\n    result = opUnion(sceneResult, skyboxResult); \n    floorResult = opUnion(floorResult, middleResult);\n    result = opUnion(result, floorResult);\n    result = opUnion(result, middleResult);\n    result = opUnion(result, sunResult);\n        \n    return result;\n}\n\nvec3 getNormal(vec3 p)\n{\n    const vec2 e = vec2(0.0, 0.001);\n    return normalize(vec3(\n        map(p + e.yxx).dist - map(p - e.yxx).dist,\n        map(p + e.xyx).dist - map(p - e.xyx).dist,\n        map(p + e.xxy).dist - map(p - e.xxy).dist\n    ));\n}\n\nHitResult raymarch(vec3 ro, vec3 rd, out bool hit, out vec3 hitp)\n{\n    HitResult result = HitResult(vec3(0.0), 0.0, MAX_DIST, 0.0, 0.0, 0);\n    vec3 color = vec3(0.0);\n    float t = 0.0;\n    hit = false;\n    for (int i = 0; i < 200; ++i)\n    {\n        vec3 p = ro + rd * t;\n        HitResult result = map(p);\n        if (result.dist < 0.001)\n        {\n            hit = true;\n            hitp = p;\n            return result;\n        }\n        t += result.dist;\n        if (t > MAX_DIST)\n        {\n            break;\n        }\n    }\n    \n    return result;\n}\n\nvec3 trace(vec2 uv)\n{\n    vec3 color = vec3(mix(vec3(0.6), vec3(1.0), vec3(pow(uv.y, 2.0))));\n    vec2 pixelSize = 5.0 / iResolution.xy;\n    float st = 1.0;\n    for (int j = 0; j < SAMPLE_COUNT; ++j)\n    {\n        vec3 colorAccum = vec3(0.0);\n        vec2 rp = (vec2(random(), random()) * pixelSize);\n        vec3 ro = vec3(rp.x, rp.y + 2.0, -6.0);\n        vec3 rd = normalize(vec3(uv.x, uv.y - 1.0, 3.0));\n        float mx= 180.0 * PI / 180.0 + ((iMouse.x / iResolution.x) * 2.0 - 1.0) * PI;\n        float my= clamp(-((iMouse.y / iResolution.y) * 2.0 - 1.0) * PI, -0.35, PI / 2.0 - 1.6);\n        float atten = 1.0;\n        \n        ro.zy *= rot(my);\n        rd.zy *= rot(my);\n\n        ro.xz *= rot(mx);\n        rd.xz *= rot(mx);\n        \n        vec3 dro = ro;\n        vec3 drd = rd;\n        vec3 sro = ro;\n        vec3 srd = rd;\n        \n        for (int i = 0; i < BOUNCE_COUNT; ++i)\n        {\n            bool hit = false;\n            vec3 hitp;\n            HitResult c = raymarch(dro, drd, hit, hitp);\n            if (hit)\n            {\n                vec3 n = getNormal(hitp);                \n                drd = n + randomHemispherePoint(n) * c.diffuse;\n                dro = hitp + drd * 0.1;\n                st += 1.0;\n                if (c.id == 0)\n                {\n\t                colorAccum += c.color * atten;\n                }\n                else\n                {\n                    \n                    colorAccum += tpm(hitp, n) * atten;\n                }\n                \n                atten *= 0.5;\n            }\n            \n            if (c.isSkybox > 0.5)\n            {\n                colorAccum += c.color * clamp(hitp.y+0.5, 0.1, 1.0) * atten;\n                color += colorAccum;\n                break;\n            }\n        }\n\n        for (int i = 0; i < BOUNCE_COUNT; ++i)\n        {\n            bool hit = false;\n            vec3 hitp;\n            HitResult c = raymarch(sro, srd, hit, hitp);\n            if (hit)\n            {\n                vec3 n = getNormal(hitp);\n                srd = normalize(reflect(srd, n)) + randomHemispherePoint(n) *  clamp(1.0-c.specular, 0.0, 1.0);\n                sro = hitp + srd * 0.1;\n                st += 1.0;\n                \n                if (c.id == 0)\n                {\n\t                colorAccum += c.color * atten;\n                }\n                else\n                {\n                    colorAccum += tpm(hitp, n) * atten;\n                }\n                \n            }\n            \n            if (c.isSkybox > 0.5)\n            {\n                color += colorAccum;\n                break;\n            }\n        }\n\n\t\t\n    }\n    return color / st;\n}\n\nvoid initGFVectors()\n{\n    GDFVectors[0] = normalize(vec3(1, 0, 0));\n    GDFVectors[1] = normalize(vec3(0, 1, 0));\n    GDFVectors[2] = normalize(vec3(0, 0, 1));\n    GDFVectors[3] = normalize(vec3(1, 1, 1 ));\n    GDFVectors[4] = normalize(vec3(-1, 1, 1));\n    GDFVectors[5] = normalize(vec3(1, -1, 1));\n    GDFVectors[6] = normalize(vec3(1, 1, -1));\n    GDFVectors[7] = normalize(vec3(0, 1, PHI+1.0));\n    GDFVectors[8] = normalize(vec3(0, -1, PHI+1.0));\n    GDFVectors[9] = normalize(vec3(PHI+1.0, 0, 1));\n    GDFVectors[10] = normalize(vec3(-PHI-1.0, 0, 1));\n    GDFVectors[11] = normalize(vec3(1, PHI+1.0, 0));\n    GDFVectors[12] = normalize(vec3(-1, PHI+1.0, 0));\n    GDFVectors[13] = normalize(vec3(0, PHI, 1));\n    GDFVectors[14] = normalize(vec3(0, -PHI, 1));\n    GDFVectors[15] = normalize(vec3(1, 0, PHI));\n    GDFVectors[16] = normalize(vec3(-1, 0, PHI));\n    GDFVectors[17] = normalize(vec3(PHI, 1, 0));\n    GDFVectors[18] = normalize(vec3(-PHI, 1, 0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initGFVectors();\n\n    gAnimate = iMouse.z;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 last = texture(iChannel0, uv);\n    float s = 0.0;\n    \n    if (gAnimate > 0.5) \n    {\n     \ttime = iTime;   \n\t    s = 0.0;\n    }\n    else\n    {\n        time = last.a;\n        s = 0.99;\n    }\n\n\n    vec3 color = vec3(0.0);\n    gSeed = iTime;\n    gUV = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    color = trace(gUV);\n    color = mix(color, last.rgb, s);\n    fragColor = vec4(color, time);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}