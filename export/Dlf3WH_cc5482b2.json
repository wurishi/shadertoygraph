{"ver":"0.1","info":{"id":"Dlf3WH","date":"1671672399","viewed":123,"name":"Pixel PlasmaSpaceSnorpion üêçü¶Çüîä","username":"blurryroots","description":"A plasma snorpion (snake + scorpion) having a rave.\nThanks for the code snippets of finalman (srgb), loicvdb (aces), kishimisu (music sampling, Weaseltron (lens distortion) and FabriceNeyret2 (text).\nActivate WITH_CYCLE_MODES to animate pixel resolution.","likes":5,"published":1,"flags":96,"usePreview":0,"tags":["plasma","pixel","space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\nconst bool SOUND_IN = true;\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n// ===\n\n// ---\n// Lens/Film Chromatic Aberratio\n// by Weaseltron - https://www.shadertoy.com/view/llK3RR\n\n// Given a vec2 in [-1,+1], generate a texture coord in [0,+1]\nvec2 barrelDistortion (vec2 p, vec2 amt) {\n    p = 2.0 * p - 1.0;\n    float maxBarrelPower = sqrt(5.0);\n    float radius = dot(p,p); //faster but doesn't match above accurately\n    p *= pow(vec2(radius), maxBarrelPower * amt);\n\n    return p * 0.5 + 0.5;\n}\n//note: from https://www.shadertoy.com/view/MlSXR3\nvec2 brownConradyDistortion (vec2 uv, float scalar) {\n    uv = (uv - 0.5 ) * 2.0;\n    \n    // positive values of K1 give barrel distortion, negative give pincushion\n    float barrelDistortion1 = -0.02 * scalar; // K1 in text books\n    float barrelDistortion2 = 0.0 * scalar; // K2 in text books\n\n    float r2 = dot(uv,uv);\n    uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n    \n    // tangential distortion (due to off center lens elements)\n    // is not modeled in this function, but if it was, the terms would go here\n    return (uv / 2.0) + 0.5;\n}\n// ---\n\nfloat TT (float ft) {\n    return ft * SOUNDTRACK_TIME;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Wrap around track time.\n    float t = mod (iTime, SOUNDTRACK_TIME);\n    \n    // Intro and Outro.\n    const float MarginHeight = 0.16;\n    float Margins = 0.\n        + smoothmate (t, vec2 (.5, MarginHeight), TT (0.006), TT (0.04))\n        + smoothmate (t, vec2 (0., 0.5-MarginHeight), TT (0.96), TT (0.04))\n        ;\n    \n    if (SOUND_IN) {\n    // Overlay by FabriceNeyret2 https://www.shadertoy.com/view/MtyXRW\n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}  \n    }\n    \n    // --- margin check by loicvdb\n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        #if WITH_ACES_FILTER\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        #else\n        fragColor = vec4 (vec3 (0), 1.);\n        #endif\n        return;\n    }\n    // ---\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= mate (t, vec2 (0.5, 1.0), 10., 23.);    \n    float v1 = texture (iChannel1, vec2 (0.)).g;\n    float sc = mate (t, vec2 (0.0, 2.0), 10., 7.);\n    \n    // --- distorion by Weaseltron\n    // https://www.shadertoy.com/view/llK3RR\n    float maxDistort = mate (t, vec2 (0., 4.), 20., 7.) * (1.0-iMouse.x/iResolution.x);\n    float scalar = 1.0 * maxDistort;\n    vec4 colourScalar = vec4(700.0, 560.0, 490.0, 1.0);\t// Based on the true wavelengths of red, green, blue light.\n    colourScalar /= max(max(colourScalar.x, colourScalar.y), colourScalar.z);\n    colourScalar *= scalar * sc; // added fade in.\n    \n    fragColor = vec4( 0.0 );\n    vec4 sourceCol = texture(iChannel0, uv);\n    #if WITH_LENS_DIST\n    const float numTaps = 8.0;  \n    for (float tap = 0.0; tap < numTaps; tap += 1.0) {\n        fragColor.r += texture(iChannel0, brownConradyDistortion(uv, colourScalar.r)).r;\n        fragColor.g += texture(iChannel0, brownConradyDistortion(uv, colourScalar.g)).g;\n        fragColor.b += texture(iChannel0, brownConradyDistortion(uv, colourScalar.b)).b;\n        \n        colourScalar *= 0.99;\n    }\n    \n    fragColor /= numTaps;  \n    fragColor.a = 1.0;\n    #else\n    fragColor = sourceCol;\n    #endif\n    //---\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n// Pixel resolution mode enum.\n#define RES_BEG -1\n#define MIN_RES 0\n#define LOW_RES 1\n#define MID_RES 2\n#define HIG_RES 3\n#define ULT_RES 4\n#define RES_END 5\n\n// In beats per second.\n#define CYCLE_SPEED 0.25\n// Activate to cycle through all resolution modes.\n#define WITH_CYCLE_MODES 0\n// Default resolution, if cycle mode is inactive.\n#define DEFAULT_RESOLUTION_MODE LOW_RES\n// Activate to have background stars glow.\n#define WITH_GLOWING_STARS 1\n// Activate to apply ACES color filter.\n#define WITH_ACES_FILTER 1\n// Activate to apply chromatic abberation.\n#define WITH_LENS_DIST 1\n\n// Reference length of the soundtrack https://soundcloud.com/user-674180865/space-snake\n#define SOUNDTRACK_TIME_REF 166.6\n// Lenght of the currently used track\n#define SOUNDTRACK_TIME 166.6\n\n// --- common \n// by blurryrots - https://www.shadertoy.com/view/csSSzm\nconst float pi = 355. / 115.;\nconst float phi = (1. + sqrt (5.)) / 2.;\nconst float phi0 = phi - 1.;\nconst float phi0i = 1. - phi0;\n\nfloat psin (float t) { return (1. + sin (t-pi/2.)) / 2.; }\nvec3 pow3 (vec3 b, float e) { return pow (b, vec3 (e)); }\nvec3 desat (vec3 c) {\n    return vec3(0.299*c.r + 0.587*c.g + 0.114*c.b);\n}\nfloat map (float x, vec2 r) {\n    float b = r.x;\n    float e = r.y - b;\n    \n    float t = b + x * e;\n    return t;\n}\nfloat remap (float x, vec2 s, vec2 r) {\n    float b = s.x;\n    float e = s.y - b;\n    float t = (x - b) / e;\n    return map (t, r);\n}\nvec4 desat (vec4 c) {\n    vec4 d = vec4(0.299*c.r + 0.587*c.g + 0.114*c.b);\n    d.a = 1.0;\n    return d;\n}\nfloat sinramp (float t) {\n    float x = pi * clamp (t, 0.0, 1.0) - pi / 2.;\n    float s = sin (x) + 1.;\n    return (0.5 * s);\n}\nfloat animate (float t, float delay, float duration) {\n    return sinramp ((t - delay) / duration);\n}\n\nfloat mate (float t, vec2 range, float delay, float duration) {\n    float base = range.x;\n    float extend = range.y - base;\n    return base + extend * animate (t, delay, duration);\n}\nfloat smoothmate (float t, vec2 range, float delay, float duration) {\n    float x = smoothstep (delay, delay + duration, t);\n    float k = x * (range.y - range.x);\n    return range.x + k;\n}\n// ---\n\n\n// --- srgb encoding\n// by finalman https://www.shadertoy.com/view/lscSzl\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\nvec3 decodeSRGB(vec3 screenRGB)\n{\n    vec3 a = screenRGB / 12.92;\n    vec3 b = pow((screenRGB + 0.055) / 1.055, vec3(2.4));\n    vec3 c = step(vec3(0.04045), screenRGB);\n    return mix(a, b, c);\n}\n// --\n\n// --- film filter\n// by loicvdb - https://www.shadertoy.com/view/wl2SDt\nfloat NoiseSeed;\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n// ---\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n\n//\nvec3 lookup_color (int i, int c) {\n    vec3 anchor_a = vec3 (phi0, phi0, 0.);\n    vec3 anchor_b = vec3 (0., 0., phi0i);\n    vec3 anchor_c = vec3 (phi0, 0., phi0i);\n    \n    float k = float (i) / float (c);\n    return mix (mix (anchor_a, anchor_b, k), anchor_c, 1.-k);\n}\n\nvoid select_mode (int mode\n    , out float pixel_resolution\n    , out float orb_min\n    , out float orb_exp\n    , out float zoom) {\n    switch (mode) {\n        case ULT_RES: {\n            pixel_resolution = 256.;\n            orb_min = pi*pi*phi;\n            orb_exp = 33.;\n            zoom = 1.33;\n        } break;\n\n        case HIG_RES: {\n            pixel_resolution = 144.;\n            orb_min = pi*phi*phi;\n            orb_exp = 22.;\n            zoom = 1.3;\n        } break;\n\n        case MID_RES: {\n            pixel_resolution = 72.;\n            orb_min = pi*phi;\n            orb_exp = 11.;\n            zoom = 1.3;\n        } break;\n\n        case LOW_RES: {\n            pixel_resolution = 66.;\n            orb_min = pi;\n            orb_exp = 7.;\n            zoom = 1.25;\n        } break;\n\n        case MIN_RES: {\n            pixel_resolution = 33.;\n            orb_min = phi+phi0;\n            orb_exp = pi;\n            zoom = 1.2;\n        } break;\n    }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float t = mod (iTime, SOUNDTRACK_TIME);\n    \n    float pixel_resolution = 0.0;\n    float orb_min = 0.0;\n    float orb_exp = 0.0    ;\n    float zoom = 0.0;\n    \n    #if WITH_CYCLE_MODES\n    float mode_speed = CYCLE_SPEED;\n    float mode_min = float (RES_BEG + 1);\n    float mode_max = float (RES_END + 0);\n    int mode = int (mode_min + mod (mode_speed * t, mode_max));\n    select_mode (mode\n        , pixel_resolution\n        , orb_min\n        , orb_exp\n        , zoom\n    );\n    #else\n    select_mode (DEFAULT_RESOLUTION_MODE\n        , pixel_resolution\n        , orb_min\n        , orb_exp\n        , zoom\n    );\n    #endif\n\n    float tc = t;\n\n    vec2 frag = fragCoord.xy;\n    vec2 res = iResolution.xy;\n    \n    float scale = pixel_resolution / iResolution.y;\n    vec2 fc = floor (fragCoord.xy * scale);\n    vec2 rs = floor (iResolution.xy * scale);\n    \n    vec2 uv = (2. * fc - rs) / min (rs.x, rs.y);\n    float zoom_t = mod (t, 12.);    \n    uv *= 0.8 - (6. > zoom_t ? 0.07 : 0.11)*psin (tc/2.);\n    uv.x += 0.09*sin (tc/2. + 1.0*pi);\n    uv.y += 0.09*cos (tc/2. + 1.3*pi);\n    uv *= zoom;\n    \n    float angle = 5. * sin (tc/3.);\n    float radiants = (angle / 360.) * (2.*pi);\n    vec2 rotation = vec2 (cos (radiants), sin (radiants));\n    vec2 rotation_left = vec2(\n        -rotation.y, \n        rotation.x\n    );    \n    uv = vec2(\n        dot(uv, rotation), \n        dot(uv, rotation_left)\n    );\n    \n    vec3 c = vec3 (0.);    \n    float orb_r = .5;\n    float orb_v = mate (t, vec2 (0., 0.15), 6., 12.);\n    int orb_c = 72;\n    float mfad = animate (tc, 12., 8.);\n    float v2 = (0.2*mfad)*texture (iChannel3, vec2 (0.)).r; \n    float v1 = (0.3*mfad)*texture (iChannel3, vec2 (0.)).g;\n    float v3 = (0.1*mfad)*texture (iChannel3, vec2 (0.)).g;\n    float orb_step = (2.*pi) / float (orb_c) * (1.02 - (0.3)*psin (tc));\n    float orb_size = (orb_min+orb_exp*v2);\n    float s = 0.;\n    for (int i = 0; i < orb_c; ++i) {\n        float ii = float (i) / float (orb_c);\n        float off =  float (i) * orb_step;\n        float orb_tc = tc * orb_v * 2.*pi;\n        float xa = sin (-ii*sin (orb_tc) + off);\n        float xb = sin (-ii*sin (orb_tc + off));\n        vec2 orb_pos = orb_r * vec2 (\n            mix (xa+0.5, xb, psin (t + sin (t + randomFloat ()))),\n            -sin (+ii * cos (orb_tc - off))\n        );\n        float sl = orb_size / length (uv - orb_pos);\n        float ps = 1.5*pixel_resolution;\n        sl = (1.)*smoothstep (-0., ps, sl);\n        sl = pixel_resolution*pow (sl, 1. + (11.2+3.2*v2)*(1.-ii));\n        \n        float cim = mix (0., float(orb_c-1), v2);\n        int ci = int (mod (float (i) + cim, float (orb_c)));\n        vec3 light_color = lookup_color (ci, orb_c);\n        vec3 light = sl * light_color;\n        \n        c += sl * light_color;\n        s += sl;\n    }\n    c /= float (orb_c);\n    s /= float (orb_c);\n    float stx = texture (iChannel2, uv*s*.05).r;\n    c = mix (c, c * stx, 0.9);\n    \n    vec2 uvtx = uv * .9;\n    uvtx.x -= 0.;\n    vec3 tx = texture (iChannel0, uvtx).rgb;\n    tx = decodeSRGB (tx);\n    \n    #if WITH_GLOWING_STARS\n    vec3 tx_glow = pow (desat (tx), vec3 (3.3));\n    tx_glow *= texture (iChannel1, uvtx + tc/3.).r;\n    tx = mix (tx, (222. + 111.*psin(tc/2.) + 333.*v1) * tx_glow * vec3 (1.), 0.6);\n    tx = (0.08 + 0.02*psin (tc/pi))*pow (tx, vec3 (phi0));\n    #endif\n    \n    c = mix (c, tx, 0.1);\n    c = encodeSRGB (c);\n    \n    #if WITH_ACES_FILTER\n    float noise = .9 + randomFloat()*2.6;\n  \tc = ACESFilm(c*noise);\n    #endif\n    fragColor = vec4 (c, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xt2SRt","filepath":"https://soundcloud.com/user-674180865/space-snake","previewfilepath":"https://soundcloud.com/user-674180865/space-snake","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n// ---\n// by kishimisu - https://www.shadertoy.com/view/dtl3Dr\n#define audioChannel iChannel0\n#define audioChannelTime iChannelTime[0]\n#define st(t1, t2, v1, v2) mix(v1, v2, smoothstep(t1, t2, iTime))\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\n#define getLevel(x) (texelFetch(audioChannel, ivec2(int(x*512.), 0), 0).r)\nfloat logisticAmp(float amp){\n   float c = st(0., 10., .99, 1.);\n   float a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevel(freq));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n//---\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float v1 = getPitch (3000., 1.);\n    v1 = remap (v1, vec2 (0.3, 1.0), vec2 (0.0, 1.0));\n    \n    float v2 = getPitch (111., 1.);\n    v2 = remap (v1, vec2 (0.1, 1.0), vec2 (0.0, 1.0));\n    \n    \n    float v3 = getPitch (888., 1.);\n    v2 = remap (v1, vec2 (0.6, 1.0), vec2 (0.0, 1.0));\n    \n    fragColor = vec4(v1, v2, v3, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}