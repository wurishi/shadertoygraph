{"ver":"0.1","info":{"id":"MtfcWB","date":"1506852072","viewed":324,"name":"Simple Reaction Diffusion 3d","username":"tholzer","description":"Lighted version of 'Simple Reaction Diffusion' (https://www.shadertoy.com/view/XslyD2).\nPress F1 .. F4  or <spacebar> to restart reaction with different initialized dots.\nPress mouse button for drawing. \n\n","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["3d","simulation","diffusion","reaction","lighted"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nshader:  SimpleReactionDiffusion3d.glsl\n\nThe reaction-diffusion system is visualized with a slightly modified version of \nShane's Bumped Sinusoidal Warp shadertoy here:\thttps://www.shadertoy.com/view/4l2XWK\n    \nOriginal 'Simple Reaction Diffusion' see https://www.shadertoy.com/view/XslyD2\n\nPress F1 .. F4 or <spacebar> to restart reaction.\nPress mouse button for drawing. \n*/\n\n\n// Bump mapping function.\nfloat bumpFunc(vec2 pos)\n{ \n    return 0.5 * (texture(iChannel1, pos).x + 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    vec3 sp = vec3(uv, 0); // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv - 1.0, 1.)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime/2.0)*0.5, sin(iTime/2.0)*0.5, -1.); // Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n\n    vec2 eps = 2.0 / iResolution.xy;\n    float f  = bumpFunc(uv); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(uv - vec2(eps.x, 0.0)); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(uv - vec2(0.0, eps.y)); // Same for the nearby sample in the Y-direction.\n   \n \t// Controls how much the bump is accentuated.\n\tconst float bumpFactor = 0.02;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx-f) / eps.x;   // Change in X\n    fy = (fy-f) / eps.y;   // Change in Y.\n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor );           \n   \n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = min(1./(0.25 + lDist*0.5 + lDist*lDist*0.05), 1.);\n    \n    atten *= f*f*.5 + .5;\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 2.)*0.66 + pow(diff, 4.)*0.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 8.); \n\n    vec3 texCol = texture(iChannel0, sp.xy).xyz;\n    texCol *= (diff*vec3(1, .97, .92)*1.3 + 0.5);\n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol + vec3(1., 0.6, .2)*spec*1.3)*atten;\n\n    // Done. \n\tfragColor = vec4(min(col, 1.), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buf A/B/C/D are duplicated to get higher speed without killing accuracy too much\n\nconst vec2 DiffusionRate = vec2(1.0, 0.5);\nconst float KillRate = 0.062;\nconst float FeedRate = 0.0545;\nconst float Speed = 40.0;\n\nvec2 computeLaplacian(vec2 uv, vec2 current)\n{\n    vec2 pixelSize = vec2(1.) / iResolution.xy;\n    \n    // with diagonals.\n    return (texture(iChannel0, uv + vec2(pixelSize.x, 0.0)).xy +\n            texture(iChannel0, uv - vec2(pixelSize.x, 0.0)).xy +\n            texture(iChannel0, uv + vec2(0.0, pixelSize.y)).xy +\n            texture(iChannel0, uv - vec2(0.0, pixelSize.y)).xy) * 0.2\n            +\n           (texture(iChannel0, uv + pixelSize).xy +\n            texture(iChannel0, uv - pixelSize).xy +\n            texture(iChannel0, uv + vec2(pixelSize.x, -pixelSize.y)).xy +\n            texture(iChannel0, uv - vec2(pixelSize.x, -pixelSize.y)).xy) * 0.05\n    \t\t- current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 current = clamp(texture(iChannel0, uv).xy, vec2(0.), vec2(1.));\n    \n    // Compute diffusion.\n    vec2 laplacian = computeLaplacian(uv, current);\n   \tvec2 diffusion = DiffusionRate * laplacian;\n        \n    // Compute reaction.\n    float u = current.x;\n    float v = current.y;    \n    float reactionU = - u * v * v + FeedRate * (1. - u);\n    float reactionV = u * v * v - (FeedRate + KillRate) * v;\n    \n    // Apply using simple forward Euler.\n    vec2 newValues = current + (diffusion + vec2(reactionU, reactionV)) * Speed * iTimeDelta;\n    \n    fragColor = vec4(newValues, 0.0, 1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buf A/B/C/D are duplicated to get higher speed without killing accuracy too much\n\nconst vec2 DiffusionRate = vec2(1.0, 0.5);\nconst float KillRate = 0.062;\nconst float FeedRate = 0.0545;\nconst float Speed = 40.0;\n\nvec2 computeLaplacian(vec2 uv, vec2 current)\n{\n    vec2 pixelSize = vec2(1.) / iResolution.xy;\n    \n    // with diagonals.\n    return (texture(iChannel0, uv + vec2(pixelSize.x, 0.0)).xy +\n            texture(iChannel0, uv - vec2(pixelSize.x, 0.0)).xy +\n            texture(iChannel0, uv + vec2(0.0, pixelSize.y)).xy +\n            texture(iChannel0, uv - vec2(0.0, pixelSize.y)).xy) * 0.2\n            +\n           (texture(iChannel0, uv + pixelSize).xy +\n            texture(iChannel0, uv - pixelSize).xy +\n            texture(iChannel0, uv + vec2(pixelSize.x, -pixelSize.y)).xy +\n            texture(iChannel0, uv - vec2(pixelSize.x, -pixelSize.y)).xy) * 0.05\n    \t\t- current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 current = clamp(texture(iChannel0, uv).xy, vec2(0.), vec2(1.));\n    \n    // Compute diffusion.\n    vec2 laplacian = computeLaplacian(uv, current);\n   \tvec2 diffusion = DiffusionRate * laplacian;\n        \n    // Compute reaction.\n    float u = current.x;\n    float v = current.y;    \n    float reactionU = - u * v * v + FeedRate * (1. - u);\n    float reactionV = u * v * v - (FeedRate + KillRate) * v;\n    \n    // Apply using simple forward Euler.\n    vec2 newValues = current + (diffusion + vec2(reactionU, reactionV)) * Speed * iTimeDelta;\n   \n    fragColor = vec4(newValues, 0.0, 1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buf A/B/C/D are duplicated to get higher speed without killing accuracy too much\n\nconst vec2 DiffusionRate = vec2(1.0, 0.5);\nconst float KillRate = 0.062;\nconst float FeedRate = 0.0545;\nconst float Speed = 40.0;\n\nvec2 computeLaplacian(vec2 uv, vec2 current)\n{\n    vec2 pixelSize = vec2(1.) / iResolution.xy;\n    \n    // with diagonals.\n    return (texture(iChannel0, uv + vec2(pixelSize.x, 0.0)).xy +\n            texture(iChannel0, uv - vec2(pixelSize.x, 0.0)).xy +\n            texture(iChannel0, uv + vec2(0.0, pixelSize.y)).xy +\n            texture(iChannel0, uv - vec2(0.0, pixelSize.y)).xy) * 0.2\n            +\n           (texture(iChannel0, uv + pixelSize).xy +\n            texture(iChannel0, uv - pixelSize).xy +\n            texture(iChannel0, uv + vec2(pixelSize.x, -pixelSize.y)).xy +\n            texture(iChannel0, uv - vec2(pixelSize.x, -pixelSize.y)).xy) * 0.05\n    \t\t- current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 current = clamp(texture(iChannel0, uv).xy, vec2(0.), vec2(1.));\n    \n    // Compute diffusion.\n    vec2 laplacian = computeLaplacian(uv, current);\n   \tvec2 diffusion = DiffusionRate * laplacian;\n        \n    // Compute reaction.\n    float u = current.x;\n    float v = current.y;    \n    float reactionU = - u * v * v + FeedRate * (1. - u);\n    float reactionV = u * v * v - (FeedRate + KillRate) * v;\n    \n    // Apply using simple forward Euler.\n    vec2 newValues = current + (diffusion + vec2(reactionU, reactionV)) * Speed * iTimeDelta;   \n    \n    fragColor = vec4(newValues, 0.0, 1.0);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buf A/B/C/D are duplicated to get higher speed without killing accuracy too much\n// BufD additional handles key action\n\nconst vec2 DiffusionRate = vec2(1.0, 0.5);\nconst float KillRate = 0.062;\nconst float FeedRate = 0.0545;\nconst float Speed = 40.0;\n\n\nvec2 computeLaplacian(vec2 uv, vec2 current)\n{\n    vec2 pixelSize = vec2(1.) / iResolution.xy;\n    \n    // with diagonals.\n    return (texture(iChannel0, uv + vec2(pixelSize.x, 0.0)).xy +\n            texture(iChannel0, uv - vec2(pixelSize.x, 0.0)).xy +\n            texture(iChannel0, uv + vec2(0.0, pixelSize.y)).xy +\n            texture(iChannel0, uv - vec2(0.0, pixelSize.y)).xy) * 0.2\n            +\n           (texture(iChannel0, uv + pixelSize).xy +\n            texture(iChannel0, uv - pixelSize).xy +\n            texture(iChannel0, uv + vec2(pixelSize.x, -pixelSize.y)).xy +\n            texture(iChannel0, uv - vec2(pixelSize.x, -pixelSize.y)).xy) * 0.05\n    \t\t- current;\n}\n\n//==========================================================\n//  k e y    handling\n//==========================================================\nconst int KEY_SPACE = 32;\nconst int KEY_F1 = 112;\nconst int KEY_F2 = 113;\nconst int KEY_F3 = 114;\nconst int KEY_F4 = 115;\n//----------------------------------------------------------\n// return true if given key is pressed\n//----------------------------------------------------------\nbool KeyPressed(int key) \n{\n  return texture(iChannel3, vec2(key,0.25) / 256.0).x > 0.5;\n}\n//----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = abs(fragCoord.xy / iResolution.xy);\n    vec2 current = clamp(texture(iChannel0, uv).xy, vec2(0.), vec2(1.));\n\n    // initialize / draw\n    vec2 sp = (iResolution.xy * 0.5 - fragCoord) / iResolution.y;\n    if((iTime < 0.5) || KeyPressed(KEY_SPACE))\n    {                       // wobbled circles \n        sp += sin(atan(sp.x, sp.y)*20.0) * 0.01; \n        float distSqr = dot(sp, sp);\n        float initVal = pow(sin(distSqr * 40.0) * 0.5 + 0.5, 5.0);\n        fragColor = vec4(1.0, initVal, 0.0, 1.0);\n        return;\n    }\n    \n    if(KeyPressed(KEY_F1))  // circles\n    {\n        float distSqr = dot(sp, sp);\n        float initVal = pow(sin(distSqr * 40.0) * 0.5 + 0.5, 5.0);\n        fragColor = vec4(1.0, initVal, 0.0, 1.0);\n        return;\n    }\n    \n    if(KeyPressed(KEY_F2)) \n    {\n        float distSqr = sp.x*sp.y;\n        float initVal = pow(sin(distSqr * 40.0) * 0.5 + 0.5, 5.0);\n        fragColor = vec4(1.0, initVal, 0.0, 1.0);\n        return;\n    }\n    \n    if(KeyPressed(KEY_F3))    // random dots\n    {\n        fragColor = texture(iChannel1, uv*0.1+iTime*0.01);\n        return;\n    }\n    \n    if(KeyPressed(KEY_F4))    // clear all dots\n    {\n        fragColor = vec4(0.5);\n        return;\n    }\n    \n    // draw with mouse\n    vec2 mp = iMouse.xy / iResolution.xy;\n    if (iMouse.z > 0. && length(mp - uv) < 0.02) \n        fragColor = vec4(1);\n   \n    // compute diffusion\n    vec2 laplacian = computeLaplacian(uv, current);\n   \tvec2 diffusion = DiffusionRate * laplacian;\n        \n    // compute reaction\n    float u = current.x;\n    float v = current.y;    \n    float reactionU = - u * v * v + FeedRate * (1. - u);\n    float reactionV = u * v * v - (FeedRate + KillRate) * v;\n    \n    // apply using simple forward Euler\n    vec2 newValues = current + (diffusion + vec2(reactionU, reactionV)) * Speed * iTimeDelta;\n    \n    fragColor += vec4(newValues, 0.0, 1.0);\n}","name":"Buf D","description":"","type":"buffer"}]}