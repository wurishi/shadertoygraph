{"ver":"0.1","info":{"id":"NdyXzw","date":"1634388707","viewed":58,"name":"MPR Basic","username":"OSevenC","description":"see: https://www.shadertoy.com/view/NsGSzm","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mpr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LARGE_NUMBER 1e20\n#define MAX_VOLUME_MARCH_STEPS 240//在Volume中光线步进的最大次数\n#define MAX_SDF_DETECT_STEPS 15//最大探测次数，用于确定物体边界\n#define MARCH_STRIDE 0.15//固定的光线步长（在Volume中）\n#define ABSORPTION_COEFFICIENT 0.5\n#define ABSORPTION_CUTOFF 0.25\n\n#define GAMMA_CORRECT\n#define ANIMATION\n#define BOUNDARY 0.5\n//#define VOLUME_RENDERING\n\nvec3[] colors = vec3[](\n    vec3(1., 206. / 255., 1. / 255.),\n    vec3(1., 205. / 255., 51. / 255.),\n    vec3(1., 204. / 255., 102. / 255.),\n    vec3(1., 203. / 255., 153. / 255.),\n    vec3(1., 1., 1.),\n    vec3(204. / 255., 237. / 255., 1.),\n    vec3(153. / 255., 205. / 255., 1.),\n    vec3(101. / 255., 173. / 255., 1.),\n    vec3(50. / 255., 141. / 255., 1.)\n    );\nvec3 GetColor(float v)\n{\n    int iv = int(v  * 9.);\n    return colors[iv];\n}\n\nstruct Box {\n    vec3 Position;\n    vec3 Vertex;\n};\n\nBox mBox = Box(\n    vec3(0, 0, 0),\n    vec3(16.0)\n);\nstruct Plane{\n    vec3 Position;\n    vec3 Normal;\n};\nPlane mPlane = Plane(\n    vec3(.0, .0, .0),\n    vec3(1.0, .0, .0)\n);\nstruct Camera\n{\n    vec3 Position;//\n    vec3 LookAt;\n\n    float ImageHeight;//成像高度//根据屏幕长宽比可求宽度\n    float FocalDistance;//焦距\n};\nCamera mCamera = Camera(\n    vec3(120, 20, -165),\n    vec3(0, 0, 0),\n    2.0,\n    7.0\n);\n\nbool IntersectPlane(vec3 rayOrigin, vec3 rayDirection, \n    vec3 planePosition, vec3 planeNormal, out float t)\n{\n    float x = dot(rayDirection,planeNormal);\n    if(x==.0)\n    {\n        t=-1.0;\n        return false;\n    }\n    else\n    {\n        t = (dot(planePosition,planeNormal) - dot(rayOrigin,planeNormal))/dot(rayDirection,planeNormal);\n        return true;\n    }\n}\n\nvec3 CameraOrbit(float speedRatio)//相机在轨道上旋转\n{\n    float theta = iTime * speedRatio;\n    float radius = 165.0;\n\n    return vec3(radius * cos(theta), mCamera.Position.y + 50.0 /** sin(theta*4.0)*/, radius * sin(theta));\n}\n\nvoid SetCamera(in vec2 _uv, in float _aspectRatio, out vec3 _rayOrigin, out vec3 _rayDirection)\n{\n    float ImageWidth = mCamera.ImageHeight * _aspectRatio;\n\n#ifdef CAMERA_MOVE\nvec3 ImagePosition = CameraOrbit(0.3);\n#else\n    vec3 ImagePosition = mCamera.Position;\n#endif\n    \n    vec3 CameraView = mCamera.LookAt - ImagePosition;\n    float ViewLength = length(CameraView);\n    vec3 CameraViewDir = CameraView / ViewLength;\n\n    vec3 CameraRight = cross(CameraViewDir, vec3(0, 1, 0));\n    vec3 CameraUp = cross(CameraRight, CameraViewDir);\n\n    vec3 focalPoint = ImagePosition - mCamera.FocalDistance * CameraViewDir;//焦点位置\n\n    vec3 ImagePoint = ImagePosition;//用Image的中心点初始化成像点\n    //根据uv坐标偏移成像点\n    ImagePoint += CameraRight * (_uv.x * 2.0 - 1.0) * ImageWidth * .5;\n    ImagePoint += CameraUp * (_uv.y * 2.0 - 1.0) * mCamera.ImageHeight * .5;\n\n    _rayOrigin = focalPoint;\n    _rayDirection = normalize(ImagePoint - focalPoint);\n}\n\nvec3 GetAmbientLight()\n{\n    return vec3(0.4);\n}\n\n//https://www.shadertoy.com/view/wssBR8\nfloat BeerLambert(float absorption, float dist)\n{\n    return exp(-absorption * dist);\n}\n\nfloat GetVolumeValue(vec3 pos)\n{\n    float scale = 96.;//32.0*(2.0+sin(iTime));\n    vec3 conner = mBox.Position - mBox.Vertex;\n    float value = texture(iChannel0, (pos - conner) / scale).x;//选取3D纹理的一部分进行采样\n    return value;\n}\n\n//https://www.shadertoy.com/view/MlsGW8\nvec3 GetBoundaryNormal(vec3 ro, vec3 rd, vec3 sz) {\n    vec3 m = 1. / rd,\n        k = abs(m) * sz,\n        a = -m * ro - k * .5, b = a + k;\n    return -sign(rd) * step(a.yzx, a.xyz) * step(a.zxy, a.xyz);\n}\n\n//https://www.shadertoy.com/view/MlsGW8\nvec3 GetNormal(in vec3 p) {\n    vec2 e = vec2(0.5, -0.5);\n    return normalize(\n        e.xyy * GetVolumeValue(p + e.xyy)\n        + e.yyx * GetVolumeValue(p + e.yyx)\n        + e.yxy * GetVolumeValue(p + e.yxy)\n        + e.xxx * GetVolumeValue(p + e.xxx)\n    );\n}\n\n//https://www.shadertoy.com/view/wssBR8\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, inout vec3 color)\n{\n    vec3 lightDirection = vec3(-1.0, 1.0, -1.0);//方向光\n    float lightDistance = length(lightDirection);\n    lightDirection /= lightDistance;//normalize\n\n    vec3 lightColor = vec3(1.0, 1.0, 1.0)*0.5 ;\n    vec3 albedo = color;\n    color *= GetAmbientLight();\n    color += lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n    color += lightColor * Diffuse(normal, lightDirection, albedo);\n    //color += GetAmbientLight() * albedo;\n}\n\nvec3 Render(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    vec3 opaquePosition, opaqueNormal;\n    float opaqueDepth = -1.0;\n    float d = -1.0;\n\n    vec3 volumetricColor = vec3(0.0f);\n    vec3 opaqueColor = vec3(0.0f);\n    float opaqueVisiblity = 1.0f;\n    \n    float boundary = BOUNDARY;\n#ifdef ANIMATION\n    boundary +=0.1*sin(iTime);\n#endif\n    if(IntersectPlane(rayOrigin, rayDirection,mPlane.Position,mPlane.Normal,d))\n    {\n        vec3 position = rayOrigin + d * rayDirection;\n        vec3 leng = position-mBox.Position;\n        vec3 halfedge = mBox.Vertex-mBox.Position;\n        if(leng.x<halfedge.x && leng.x>-halfedge.x&&\n            leng.y<halfedge.y && leng.y>-halfedge.y&&\n            leng.z<halfedge.z && leng.z>-halfedge.z\n        )\n        {\n            float value = GetVolumeValue(position);\n            opaqueDepth = d;\n            opaquePosition = position;\n            opaqueColor = GetColor(value);\n        }\n        \n    }\n    return opaqueColor;\n}\n\n//https://www.shadertoy.com/view/wssBR8\nvec3 GammaCorrect(vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\nmPlane.Position = vec3(8.*sin(iTime),.0,.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 rayOrigin, rayDirection;\n\n    SetCamera(\n        uv, aspectRatio, //输入\n        rayOrigin, rayDirection//输出\n    );\n\n    vec3 color = Render(rayOrigin, rayDirection);\n    \n#ifdef GAMMA_CORRECT\n    fragColor = vec4(GammaCorrect(clamp(color, 0.0, 1.0)), 1.0);\n#else\n    fragColor=vec4( color, 1.0 );\n    \n#endif\n}","name":"Image","description":"","type":"image"}]}