{"ver":"0.1","info":{"id":"MclyRr","date":"1720754537","viewed":97,"name":" butterfly stained glass","username":"harsukh","description":"butterfly stained glass animation","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["2d","polar","transformation","butterfly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"[ #07 ] - Flourescent butterfly\" by Yrai. https://shadertoy.com/view/4sfyWB\n// 2024-07-11 19:30:48\n\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float PI = 3.1415926;\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(vec2(c, -s),vec2( s, c));\n}\n\nvec2 rand (vec2 x)\n{return fract(sin(vec2(dot(x, vec2(1.2,5.5)), dot(x, vec2(4.54,2.41))))*4.45);}\n\nvec3 voro(vec2 uv){\n    vec2 uv_id = floor(uv);\n    vec2 uv_st = fract(uv);\n    \n    vec2 m_diff;\n    vec2 m_point;\n    vec2 m_neighbor;\n    float m_dist = 10.0; //minimum distance\n    \n    for (int j= -1; j<=1; j++){\n        for (int i =-1; i<=1; i++){\n            \n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = rand(uv_id+neighbor);//find radom point in cell\n            vec2 diff = neighbor+ point- uv_st;//vector between pixel and point\n            \n            float dist = length(diff);\n            if (dist < m_dist){// if distance is smaller than min, set new vals\n                m_dist = dist;\n                m_point = point;\n                m_diff = diff;\n                m_neighbor = neighbor;\n             }\n          }\n     }\n     \n     //uniform border pass\n     m_dist = 10.0;\n     for(int j = -2; j<= 2; j++){\n         for(int i =-2; i<=2; i++){\n             if (i==0 && j==0) continue;\n             //find point in neighboring cells\n             vec2 neighbor = m_neighbor+ vec2(float(i), float(j));\n             vec2 point = rand(uv_id+neighbor);\n             //find distance between adjacent points\n             vec2 diff = neighbor+ point- uv_st;\n             float dist = dot(0.5*(m_diff+diff), normalize(diff-m_diff));\n             m_point= point;\n             m_dist = min(m_dist, dist);\n          }\n      }\n      \n      return vec3(m_point, m_dist);\n } \n \nvec3 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n    \n    vec3 U = Color-P;\n    \n    vec3 V = cross(vec3(0.55735),U);    \n\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    \n    return Color;\n}\n\n\nvec3 blue_grid (vec2 uv, float detail)\n{\n    uv *= detail;\n    vec3 v = voro(uv);\n    vec3 col= clamp(vec3(v.x*0.5, v.y*0.9,1.0)*smoothstep(0.01,0.06, v.z),0.,1.);\n    col= HueShift(col, (-uv.y)*0.01);\n    \n    col+=(0.15-0.1*(-0.2*uv.y))*smoothstep(0.01,0.06, v.z);\n    col= (((col-0.5)*0.85)+0.5)*smoothstep(0.01,0.06, v.z);\n    return col;\n}\n\nvec3 magenta_grid (vec2 uv, float detail)\n{\n    uv *= detail;\n    vec3 v = voro(uv);\n    vec3 col= clamp(vec3(1.0,0.9*v.x, v.y*.7)*smoothstep(0.01,0.06, v.z),0.,1.);\n    col= HueShift(col, (-uv.y)*0.03);\n    col+=0.2*smoothstep(0.01,0.06, v.z);\n    col.yz+=(-0.1*(-0.7*uv.y))*smoothstep(0.01,0.06, v.z);\n    col= (((col-0.5)*0.9)+0.5)*smoothstep(0.01,0.06, v.z);\n    return col;\n}\n\n\nfloat butterfly_mask(vec2 p, float offset) {\n    p*=33.;\n   \tfloat r = length(p);\n\tfloat t = atan(p.y, p.x);\n    \n    float butterfly = \n        7. - .5*sin(t) + 2.5*sin(3.*t) + 2.*sin(5.*t) - 1.7*sin(7.*t) +\n        3.*cos(2.*t) - 2.*cos(4.*t) - 0.4*cos(16.*t) - r;\n\treturn smoothstep(-1.,offset,butterfly);\n}\n\nfloat butterfly_mask2(vec2 p, float offset) {\n    p*=33.;\n   \tfloat r = length(p);\n\tfloat t = atan(p.y, p.x);\n    \n    float butterfly = \n        7. - .5*sin(t) + 2.5*sin(3.*t) + 2.*sin(5.*t) - 1.7*sin(7.*t) +\n        3.*cos(2.*t) - 2.*cos(4.*t) - 0.4*cos(16.*t) - r;\n\treturn smoothstep(offset,-2.0,butterfly);\n}\n\nvec3 sky (vec2 uv_mask, vec2 uv){\n    float m1 = clamp((1.0-butterfly_mask2(uv_mask,-2.3)),0.0,1.0);\n    return blue_grid(uv,30.)*m1;\n}\nvec3 butterfly(vec2 uv_mask, vec2 uv){\n    float m1 = clamp(butterfly_mask(uv_mask,-0.7),0.0,1.0);\n    return magenta_grid(uv,30.) * m1;\n    \n}\n// ----------------------------------------------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 uv0 = uv;\n    uv*=1.3;\n    uv*=rot(-PI/4.0);\n    \n    uv.x *= 1. - sin(iTime*6.)*.05;\n       \n\tvec3 c = vec3(0.110,0.051,0.008);\n    \n    c+=sky(uv,uv0 );\n   \n    c+= butterfly(uv,uv0);\n    \n    fragColor = vec4(c, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}