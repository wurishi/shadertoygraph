{"ver":"0.1","info":{"id":"mt3cDB","date":"1704128165","viewed":70,"name":"CRT effect expt. 3","username":"hasenpfote","description":"This shader creates a CRT-like output (tested at 1080p resolution).\nFor details, please refer to the comments in the Image tag.\nLeft side: Original image, Right side: Filtered image\nhttps://hasenpfote.netlify.app/posts/crt-shader/","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["crt","postprocess","pixelation","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * This shader creates a CRT-like output.\n *\n * You can switch masks in the \"Common\" tab under \"MASK_MODEL\".\n *\n * ===\n * User inputs\n *   - Common\n *     [space] Toggles the mode.\n *     [F1] Toggle debug display.\n *\n *   - Default mode\n *     [Mouse drag] Adjusts the filter's application range.\n *\n *   - Magnifying glass mode\n *     [Mouse drag] Changes the position of the magnifying glass.\n *     [,|.] Changes the magnification level of the magnifying glass (1x, 2x, 4x, 8x, 16x, 32x).\n *\n * ===\n * The following is a demo of the key features.\n *\n *   - Pixelation\n *       https://www.shadertoy.com/view/mtlfDs\n *       https://www.shadertoy.com/view/DldyzH\n *       https://www.shadertoy.com/view/DdcBzj\n *\n *   - Scanline\n *       https://www.shadertoy.com/view/DsGyzR\n *\n *   - Chromatic aberration\n *       https://www.shadertoy.com/view/ctsfz2\n *\n *   - Radial distortion\n *       https://www.shadertoy.com/view/Dd3cWs\n *\n *   - Vignette\n *       https://www.shadertoy.com/view/msdyDf\n *\n * ===\n * This is the result of various explorations, inspired by the following work.\n * I am grateful to the original creator for their outstanding work.\n * [FixingPixelArt - TimothyLottes] https://www.shadertoy.com/view/XsjSzR\n */\n\n/**\n * In this pass, only the user interface is displayed.\n */\n\nconst float MAG_GLASS_LENS_RADIUS = 100.; // (in pixels)\nconst float MAG_GLASS_BORDER_HALF_THICKNESS = 2.; // (in pixels)\nconst float MAG_GLASS_LENGTH_FROM_POINT = 100.; // (in pixels)\n\nvec4 load_state(in int id){\n    return load_state(iChannel3, int(iResolution.y), id);\n}\n\nvec3 fetch(in vec2 pos){\n    return texture(iChannel0, pos / iResolution.xy).rgb;\n}\n\n/**\n * Returns the screen color at the specified position through the magnifying glass.\n */\nvec4 mag_glass(in vec2 pos){\n    vec4 state_mg = load_state(SID_MAG_GLASS);\n    vec2 zoom_pos = floor(state_mg.xy * iResolution.xy) + 0.5;\n    vec2 dir = vec2(1.);\n    vec2 mg_pos = zoom_pos + MAG_GLASS_LENGTH_FROM_POINT * dir;\n    vec2 boundary_pos = mg_pos + MAG_GLASS_LENS_RADIUS + MAG_GLASS_BORDER_HALF_THICKNESS;\n\n    dir *= 2. * step(boundary_pos - iResolution.xy, vec2(0.)) - 1.;\n    mg_pos = zoom_pos + MAG_GLASS_LENGTH_FROM_POINT * dir;\n\n    vec2 offset_pos = pos - mg_pos;\n    float len = length(offset_pos);\n    vec4 color;\n\n    if(len < MAG_GLASS_LENS_RADIUS + MAG_GLASS_BORDER_HALF_THICKNESS){\n        if(abs(len - MAG_GLASS_LENS_RADIUS) < MAG_GLASS_BORDER_HALF_THICKNESS){\n            color = vec4(0.);\n        }else{\n            int shift = int(state_mg.z);\n            float magnification = float(1 << shift);\n            color.rgb = fetch(zoom_pos + floor(offset_pos / magnification));\n            color.a = 0.;\n        }\n    }else{\n        color.rgb = fetch(pos);\n        color.a = 1.;\n    }\n\n    return color;\n}\n\n/**\n * Returns the weight of a separator at the specified position.\n */\nfloat vert_separator(in float pos, in float sep){\n    pos -= sep;\n    return pos * pos < 4. ? 0. : 1.;\n}\n\n#ifdef DEBUG_DISPLAY\nint text(in vec2 pos){\n    const float scale = 5.;\n    vec2 uv = pos / iResolution.y;\n    vec2 char_size = scale * vec2(CELL_SIZE) / iResolution.y;\n    vec2 char_step = scale * vec2(CELL_SIZE+1) / iResolution.y;\n    vec2 base_pos = vec2(0.5, iResolution.y - 0.5 - scale * float(CELL_SIZE.y)) / iResolution.y;\n    vec2 char_pos = base_pos;\n    int res = 0;\n\n#define C(ascii) res |= draw_char(ascii, char_pos, char_size, uv); char_pos.x += char_step.x\n#define I(value) res |= draw_int(value, char_pos, char_size, uv, 1); char_pos.x += (floor(0.4342944819 * log(float(value))) + 1.) * char_step.x\n#define F(value) res |= draw_float(value, char_pos, char_size, uv, 4); char_pos.x += ((sign(value) < 0. ? 6. : 5.) + floor(0.4342944819 * log(floor(value)))) * char_step.x\n#define CRLF char_pos = vec2(base_pos.x, char_pos.y - char_step.y)\n\n    // fps:F\n    C(102); C(112); C(115); C(58); F(iFrameRate); CRLF;\n\n    // Mode:\n    C(77); C(111); C(100); C(101); C(58);\n\n    int op_mode = int(load_state(SID_OP_MODE).x);\n\n    if(op_mode == 0){\n        // Default\n        C(68); C(101); C(102); C(97); C(117); C(108); C(116); CRLF;\n    } else if(op_mode == 1){\n        // Mag-glass\n        C(77); C(97); C(103); C(45); C(103); C(108); C(97); C(115); C(115); CRLF;\n        // Mag:Nx\n        int shift = int(load_state(SID_MAG_GLASS).z);\n        int mag = 1 << shift;\n        C(77); C(97); C(103); C(58); I(mag); C(120); CRLF;\n    }\n\n    // Model:\n    C(77); C(111); C(100); C(101); C(108); C(58);\n#if (MASK_MODEL == 0)\n    C(65); C(112); C(101); C(114); C(116); C(117); C(114); C(101); C(103); C(114); C(105); C(108); C(108); C(101);\n#elif (MASK_MODEL == 1)\n    C(83); C(108); C(111); C(116); C(109); C(97); C(115); C(107);\n#elif (MASK_MODEL == 2)\n    C(83); C(104); C(97); C(100); C(111); C(119); C(109); C(97); C(115); C(107);\n#elif (MASK_MODEL == 3)\n    C(83); C(108); C(111); C(116); C(109); C(97); C(115); C(107); C(45); C(50);\n#elif (MASK_MODEL == 4)\n    C(83); C(104); C(97); C(100); C(111); C(119); C(109); C(97); C(115); C(107); C(45); C(50);\n#endif\n\n#undef CRLF\n#undef F\n#undef I\n#undef C\n\n    return res;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 color = vec3(0.);\n    vec2 uv = fragCoord / iResolution.xy;\n    float vsep_pos = load_state(SID_SEPARATOR).x * iResolution.x;\n    float vsep_weight = 1.;\n    int op_mode = int(load_state(SID_OP_MODE).x);\n\n    if(op_mode == 0){\n        color = texture(iChannel0, uv).rgb;\n    }else{\n        vec4 passed_color = mag_glass(fragCoord);\n        color = passed_color.rgb;\n        vsep_weight = passed_color.a;\n    }\n\n    color *= mix(1., vert_separator(fragCoord.x, vsep_pos), vsep_weight);\n#ifdef DEBUG_DISPLAY\n    vec4 state_debug = load_state(SID_DEBUG);\n    if(state_debug.x > 0.){\n        int txt = text(fragCoord);\n        color = mix(color, vec3(0., 1., 0.), float(txt));\n    }\n#endif\n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define DEBUG_DISPLAY\n\n/**\n *  Specifies the mask model.\n *  Currently, values from 0 to 4 are available.\n *\n *    0: Aperture grille\n *    1: Slot mask\n *    2: Shadow mask\n *    3: Slot mask (based on phosphor layout)\n *    4: Shadow mask (based on phosphor layout)\n */\n#define MASK_MODEL 4\n\n/**\n * Specifies the pixelation size.\n * This affects both the mask and the scanlines.\n * Note that when altering the size to a value other than 4,\n * manual adjustments for the mask may be required.\n */\n#define PIXELATION_SIZE 4\n\n#if (MASK_MODEL != 4)\n#define IS_VALID_PIXELATION_SIZE 1\n#else\n#define IS_VALID_PIXELATION_SIZE (PIXELATION_SIZE > 0 && (PIXELATION_SIZE % 4) == 0)\n#endif\n\n/**\n * Enables shape vertical flip.\n * This also affects the mask.\n */\n#define ENABLE_SHAPE_VFLIP\n\n#define SID_DEBUG     0\n#define SID_OP_MODE   1\n#define SID_SEPARATOR 2\n#define SID_MAG_GLASS 3\n\n//==============================================================================\n\n// https://www.shadertoy.com/view/XlGcRh\nuvec2 pcg2d(uvec2 v){\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec2 hash22(vec2 p){\n    uvec2 hash = pcg2d(uvec2(p));\n    return vec2(hash) * (1. / float(0xffffffffu));\n}\n\n//==============================================================================\n\nfloat srgb_to_linear(in float x){\n    return x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\n\nvec3 srgb_to_linear(in vec3 color){\n    return vec3(srgb_to_linear(color.r), srgb_to_linear(color.g), srgb_to_linear(color.b));\n}\n\nfloat linear_to_srgb(in float x){\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(x, 1./2.4) - 0.055;\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    return vec3(linear_to_srgb(color.r), linear_to_srgb(color.g), linear_to_srgb(color.b));\n}\n\n//==============================================================================\n// Oklab\n// https://bottosson.github.io/posts/oklab/\n//==============================================================================\n\nvec3 linear_srgb_to_lms_prime(in vec3 rgb){\n    const mat3 m = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005\n    );\n\n    vec3 lms = m * rgb;\n\n    return sign(lms) * pow(abs(lms), vec3(1./3.));\n}\n\nvec3 linear_srgb_to_oklab(in vec3 rgb){\n    const mat3 m = mat3(\n        0.2104542553,  0.7936177850, -0.0040720468,\n        1.9779984951, -2.4285922050,  0.4505937099,\n        0.0259040371,  0.7827717662, -0.8086757660\n    );\n\n    vec3 lms_prime = linear_srgb_to_lms_prime(rgb);\n\n    return m * lms_prime;\n}\n\nvec3 lms_prime_to_linear_srgb(in vec3 lms_prime){\n    const mat3 m = mat3(\n\t\t 4.0767416621, -3.3077115913,  0.2309699292,\n\t\t-1.2684380046,  2.6097574011, -0.3413193965,\n\t\t-0.0041960863, -0.7034186147,  1.7076147010\n    );\n\n    vec3 lms = lms_prime * lms_prime * lms_prime;\n\n    return m * lms;\n}\n\nvec3 oklab_to_linear_srgb(in vec3 lab){\n    const mat3 m = mat3(\n        1.,  0.3963377774,  0.2158037573,\n        1., -0.1055613458, -0.0638541728,\n        1., -0.0894841775, -1.2914855480\n    );\n\n    vec3 lms_prime = m * lab;\n\n    return lms_prime_to_linear_srgb(lms_prime);\n}\n\n//==============================================================================\n\nivec2 state_id_to_pos(in int num_rows, in int id){\n    return ivec2(id % num_rows, id / num_rows);\n}\n\nvec4 load_state(in sampler2D ch, in int num_rows, in int id){\n    return texelFetch(ch, state_id_to_pos(num_rows, id), 0);\n}\n\n//==============================================================================\n\n#ifdef DEBUG_DISPLAY\n//\n// This font is based on the following work:\n// [Simple Bitmap Text - integers - iq] https://www.shadertoy.com/view/4s3fzl\n//\n\n/**\n * The data is based on the following 4x6 font.\n * http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n */\nconst int[95] FONT = int[](\n    0x000000, // \n    0x222020, // !\n    0x550000, // \"\n    0x575750, // #\n    0x236362, // $\n    0x412410, // %\n    0x253570, // &\n    0x640000, // '\n    0x244420, // (\n    0x422240, // )\n    0x527250, // *\n    0x027200, // +\n    0x000064, // ,\n    0x007000, // -\n    0x000020, // .\n    0x112440, // /\n    0x355560, // 0\n    0x262270, // 1\n    0x612470, // 2\n    0x612160, // 3\n    0x157110, // 4\n    0x746160, // 5\n    0x246520, // 6\n    0x713220, // 7\n    0x252520, // 8\n    0x253120, // 9\n    0x002020, // :\n    0x002064, // ;\n    0x124210, // <\n    0x007070, // =\n    0x421240, // >\n    0x612020, // ?\n    0x755470, // @\n    0x257550, // A\n    0x656560, // B\n    0x344430, // C\n    0x655560, // D\n    0x746470, // E\n    0x746440, // F\n    0x345530, // G\n    0x557550, // H\n    0x722270, // I\n    0x111520, // J\n    0x556550, // K\n    0x444470, // L\n    0x577550, // M\n    0x575550, // N\n    0x255520, // O\n    0x656440, // P\n    0x255730, // Q\n    0x656550, // R\n    0x347160, // S\n    0x722220, // T\n    0x555570, // U\n    0x555520, // V\n    0x557750, // W\n    0x552550, // X\n    0x552220, // Y\n    0x712470, // Z\n    0x644460, // [\n    0x442110, // back slash\n    0x622260, // ]\n    0x250000, // ^\n    0x00000F, // _\n    0x620000, // `\n    0x003570, // a\n    0x446560, // b\n    0x003430, // c\n    0x113530, // d\n    0x007630, // e\n    0x127220, // f\n    0x007517, // g\n    0x446550, // h\n    0x202220, // i\n    0x202226, // j\n    0x445650, // k\n    0x222220, // l\n    0x007750, // m\n    0x006550, // n\n    0x002520, // o\n    0x006564, // p\n    0x003531, // q\n    0x006440, // r\n    0x003260, // s\n    0x027230, // t\n    0x005570, // u\n    0x005520, // v\n    0x005770, // w\n    0x005250, // x\n    0x005524, // y\n    0x006230, // z\n    0x326230, // {\n    0x222220, // |\n    0x623260, // }\n    0x5A0000  // ~\n);\n\nconst ivec2 CELL_SIZE = ivec2(4, 6);\n\nconst int MAX_INT_DIGITS = 4; // Configure the integer maximum digit count from 1 to 10.\nconst int INITIAL_DIVISOR = 1000; // 10^{MAX_INT_DIGITS-1}\n\nint draw_char(in int ascii, in vec2 pos, in vec2 size, in vec2 uv){\n    ascii -= 32;\n    if(ascii < 0 || ascii > 94)\n        return 0;\n\n    // Subtract our position from the current uv so that we can\n    // know if we're inside the bounding box or not.\n    uv -= pos;\n\n    // Divide the screen space by the size, so our bounding box is 1x1.\n    uv /= size;\n\n    // Multiply the UV by the bitmap size so we can work in\n    // bitmap space coordinates.\n    uv *= vec2(CELL_SIZE);\n\n    // Compute bitmap texel coordinates\n    ivec2 iuv = ivec2(round(uv));\n\n\t// Bounding box check. With branches, so we avoid the maths and lookups    \n    if(iuv.x < 0 || iuv.x >= CELL_SIZE.x || iuv.y < 0 || iuv.y >= CELL_SIZE.y)\n        return 0;\n\n    // Compute bit index\n    iuv.x = CELL_SIZE.x - 1 - iuv.x;\n    int index = CELL_SIZE.x * iuv.y + iuv.x;\n\n    // Get the appropriate bit and return it.\n    return (FONT[ascii] >> index) & 0x1;\n}\n\nint _draw_uint(in int val, inout vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n    int divisor = INITIAL_DIVISOR;\n    float step = 1.25 * size.x; // 1.25 = (MAP_SIZE.x+1) / MAP_SIZE.x\n\n    for(int i = MAX_INT_DIGITS - 1; i >= 0; i--){\n        if(val >= divisor || i < min_digits){\n            int digit = val / divisor;\n            res |= draw_char(48+digit, pos, size, uv);\n            pos.x += step;\n            val -= divisor * digit;\n        }\n        divisor /= 10;\n    }\n\n    return res;\n}\n\nint draw_uint(in int val, in vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    return _draw_uint(val, pos, size, uv, min_digits);\n}\n\nint draw_int(in int val, in vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n    float s = sign(float(val));\n\n    if(s < 0.){\n        res |= draw_char(45, pos, size, uv);\n        val *= int(s);\n        pos.x += 1.25 * size.x;\n    }\n\n    res |= _draw_uint(val, pos, size, uv, min_digits);\n\n    return res;\n}\n\nint draw_float(in float val, in vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n    float s = sign(val);\n    if(s < 0.){\n        res |= draw_char(45, pos, size, uv);\n        val *= s;\n        pos.x += 1.25 * size.x;\n    }\n\n    float fval, ival;\n    fval = modf(val, ival);\n\n    res |= _draw_uint(int(ival), pos, size, uv, 1);\n\n    res |= draw_char(46, pos, size, uv);\n    pos.x += 1.25 * size.x;\n\n    res |= _draw_uint(int(pow(10., float(min_digits)) * fval), pos, size, uv, min_digits);\n\n    return res;\n}\n#endif // DEBUG_DISPLAY\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * In this pass, various states are loaded and stored.\n */\n\n#define KEY_SPACE   32\n#define KEY_F1     112\n#define KEY_COMMA  188\n#define KEY_PERIOD 190\n\nconst float INITIALIZATION_DELAY = 0.05;\nconst float MOUSE_DOUBLE_CLICK_DELAY = 0.3;\n\nint state_pos_to_id(in ivec2 pos){\n    return int(iResolution.y) * pos.y + pos.x;\n}\n\nbool can_store_state(in int id, in ivec2 pos){\n    return state_id_to_pos(int(iResolution.y), id) == pos;\n}\n\nvec4 load_state(in int id){\n    return load_state(iChannel0, int(iResolution.y), id);\n}\n\nbool is_mouse_pressed(){\n    return iMouse.w > 0.;\n}\n\nbool is_mouse_down(){\n    return iMouse.z > 0.;\n}\n\nbool is_mouse_up(){\n    return iMouse.z < 0.;\n}\n\nbool is_key_pressed(int code){\n    return texelFetch(iChannel1, ivec2(code, 1), 0).x > 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 pos = ivec2(fragCoord);\n    vec4 state;\n\n    if(can_store_state(SID_DEBUG, pos)){\n        state = load_state(SID_DEBUG);\n        if(iTime > INITIALIZATION_DELAY){\n            if(is_key_pressed(KEY_F1)){\n                state.x = float(!bool(state.x));\n            }\n        }else{\n            state = vec4(1.);\n        }\n    }else if(can_store_state(SID_OP_MODE, pos)){\n        state = load_state(SID_OP_MODE);\n        if(is_key_pressed(KEY_SPACE)){\n            int op_mode = int(state.x);\n            op_mode = op_mode == 0 ? 1 : 0;\n            state.x = float(op_mode);\n        }\n    }else if(can_store_state(SID_SEPARATOR, pos)){\n        state = load_state(SID_SEPARATOR);\n        if(iTime > INITIALIZATION_DELAY){\n            int op_mode = int(load_state(SID_OP_MODE).x);\n            if(op_mode == 0){\n                if(is_mouse_down()){\n                    state.x = iMouse.x / iResolution.x;\n                }\n            }\n        }else{\n            state = vec4(0.5, 0., 0., 0.);\n        }\n    }else if(can_store_state(SID_MAG_GLASS, pos)){\n        state = load_state(SID_MAG_GLASS);\n        if(iTime > INITIALIZATION_DELAY){\n            int op_mode = int(load_state(SID_OP_MODE).x);\n            if(op_mode == 1){\n                if(is_mouse_down()){\n                    state.xy = iMouse.xy / iResolution.xy;\n                }\n \n                int magnification = int(state.z);\n                if(is_key_pressed(KEY_COMMA)){\n                    magnification++;\n                }\n                if(is_key_pressed(KEY_PERIOD)){\n                    magnification--;\n                }\n                state.z = float(clamp(magnification, 0, 5));\n            }\n        }else{\n            state = vec4(0.5, 0.5, 1., 0.);\n        }\n    }else{\n        discard;\n    }\n\n    fragColor = state;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n * In this pass, representative values for pixelation are determined.\n */\n\n/**\n * Adjusts the intensity of RGB colors.\n */\nconst float COLOR_GAIN = 100.;\n\nvec3 fetch(in vec2 pos){\n    return srgb_to_linear(textureLod(iChannel0, pos / iResolution.xy, 0.).rgb);\n}\n\n#define DEBUG_OKLAB\n\nvec3 sample_texture(in ivec2 size, in vec2 pos){\n    ivec2 num_divs = size / 2;\n    vec2 factor = vec2(2 - ((size % 2) ^ 1));\n\n    vec3 color = vec3(0.);\n\n    for(int i = 0; i < num_divs.y; i++){\n        for(int j = 0; j < num_divs.x; j++){\n            vec2 p = vec2(j, i);\n            vec2 s = 2. * p + factor * hash22(pos + p);\n#ifdef DEBUG_OKLAB\n            color += linear_srgb_to_lms_prime(fetch(pos + s));\n#else\n            color += fetch(pos + s);\n#endif\n        }\n    }\n#ifdef DEBUG_OKLAB\n    return lms_prime_to_linear_srgb(color / float(num_divs.x * num_divs.y));\n#else\n    return color / float(num_divs.x * num_divs.y);\n#endif\n}\n\nvec3 pixelation(in ivec2 size, in vec2 pos){\n#ifdef ENABLE_SHAPE_VFLIP\n    pos.y = iResolution.y - pos.y;\n#endif\n\n    pos -= mod(floor(pos), vec2(size));\n\n#ifdef ENABLE_SHAPE_VFLIP\n    pos.y = iResolution.y - pos.y;\n#endif\n    return sample_texture(size, pos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n#if (MASK_MODEL == 0 || MASK_MODEL == 1 || MASK_MODEL == 2 || MASK_MODEL == 3)\n    ivec2 size = ivec2(PIXELATION_SIZE);\n#elif (MASK_MODEL == 4)\n#if !IS_VALID_PIXELATION_SIZE\n#error \"Invalid PIXELATION_SIZE.\"\n#endif\n    ivec2 size = (PIXELATION_SIZE / 4) * ivec2(6, 2);\n#else\n#error \"Invalid MASK_MODEL.\"\n#endif\n\n    vec2 threshold = ceil(iResolution.xy / vec2(size)) + 1.;\n    if(any(greaterThanEqual(fragCoord, threshold))){\n        discard;\n    }\n\n    vec3 color = COLOR_GAIN * pixelation(size, vec2(size) * fragCoord);\n\n    fragColor = vec4(color, 1.);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/**\n * In this pass, the final screen color is computed.\n */\n\n/**\n * Enables the mask specified by MASK_MODEL.\n */\n#define ENABLE_MASK\n\n/**\n * Enables scanline effect.\n */\n#define ENABLE_SCANLINE\n\n/**\n * Enables anti-aliased scanline effect.\n * When ENABLE_SCANLINE and ENABLE_DISTORTION are both enabled, moiré patterns may occur.\n * To mitigate this, enable the following option.\n */\n#define ENABLE_AA_SCANLINE\n\n/**\n * Enables distortion effect.\n */\n#define ENABLE_DISTORTION\n\n/**\n * Enables vignette effect.\n */\n#define ENABLE_VIGNETTE\n\n/**\n * Enables chromatic aberration effect.\n */\n#define ENABLE_CA\n\n/**\n * Enables tone mapping.\n */\n#define ENABLE_TONE_MAPPING\n\n#ifdef ENABLE_MASK\nconst float PHOSPHOR_DARK = 0.5;\nconst float PHOSPHOR_LIGHT = 1.5;\n\nconst vec3 PHOSPHOR_R = vec3(PHOSPHOR_LIGHT, PHOSPHOR_DARK, PHOSPHOR_DARK);\nconst vec3 PHOSPHOR_G = vec3(PHOSPHOR_DARK, PHOSPHOR_LIGHT, PHOSPHOR_DARK);\nconst vec3 PHOSPHOR_B = vec3(PHOSPHOR_DARK, PHOSPHOR_DARK, PHOSPHOR_LIGHT);\nconst vec3 PHOSPHOR_C = vec3(PHOSPHOR_DARK, PHOSPHOR_LIGHT, PHOSPHOR_LIGHT);\nconst vec3 PHOSPHOR_M = vec3(PHOSPHOR_LIGHT, PHOSPHOR_DARK, PHOSPHOR_LIGHT);\nconst vec3 PHOSPHOR_Y = vec3(PHOSPHOR_LIGHT, PHOSPHOR_LIGHT, PHOSPHOR_DARK);\nconst vec3 PHOSPHOR_K = vec3(PHOSPHOR_DARK);\nconst vec3 PHOSPHOR_W = vec3(PHOSPHOR_LIGHT);\n\nconst vec3 PHOSPHOR_LAYOUT_0[4] = vec3[](\n    PHOSPHOR_R, PHOSPHOR_Y, PHOSPHOR_C, PHOSPHOR_B\n);\n\nconst vec3 PHOSPHOR_LAYOUT_1[32] = vec3[](\n    PHOSPHOR_R, PHOSPHOR_Y, PHOSPHOR_C, PHOSPHOR_B, PHOSPHOR_R, PHOSPHOR_Y, PHOSPHOR_C, PHOSPHOR_B,\n    PHOSPHOR_R, PHOSPHOR_Y, PHOSPHOR_C, PHOSPHOR_B, PHOSPHOR_K, PHOSPHOR_K, PHOSPHOR_K, PHOSPHOR_K,\n    PHOSPHOR_R, PHOSPHOR_Y, PHOSPHOR_C, PHOSPHOR_B, PHOSPHOR_R, PHOSPHOR_Y, PHOSPHOR_C, PHOSPHOR_B,\n    PHOSPHOR_K, PHOSPHOR_K, PHOSPHOR_K, PHOSPHOR_K, PHOSPHOR_R, PHOSPHOR_Y, PHOSPHOR_C, PHOSPHOR_B\n);\n\nconst vec3 PHOSPHOR_LAYOUT_2[16] = vec3[](\n    PHOSPHOR_R, PHOSPHOR_Y, PHOSPHOR_C, PHOSPHOR_B,\n    PHOSPHOR_R, PHOSPHOR_Y, PHOSPHOR_C, PHOSPHOR_B,\n    PHOSPHOR_C, PHOSPHOR_B, PHOSPHOR_R, PHOSPHOR_Y,\n    PHOSPHOR_C, PHOSPHOR_B, PHOSPHOR_R, PHOSPHOR_Y\n);\n\nconst vec3 PHOSPHOR_LAYOUT_3[24] = vec3[](\n    PHOSPHOR_R, PHOSPHOR_R, PHOSPHOR_G, PHOSPHOR_G, PHOSPHOR_B, PHOSPHOR_B,\n    PHOSPHOR_R, PHOSPHOR_R, PHOSPHOR_G, PHOSPHOR_G, PHOSPHOR_B, PHOSPHOR_B,\n    PHOSPHOR_G, PHOSPHOR_B, PHOSPHOR_B, PHOSPHOR_R, PHOSPHOR_R, PHOSPHOR_G,\n    PHOSPHOR_G, PHOSPHOR_B, PHOSPHOR_B, PHOSPHOR_R, PHOSPHOR_R, PHOSPHOR_G\n);\n#endif // ENABLE_MASK\n\n#ifdef ENABLE_SCANLINE\nconst float SCANLINE_SHARPNESS = 4.;\n#endif\n\n#ifdef ENABLE_VIGNETTE\nconst float VIGNETTE_INTENSITY = 0.25; // Amount of darkening (0 to 1)\n#endif\n\n//==============================================================================\n\nvec4 load_state(in int id){\n    return load_state(iChannel3, int(iResolution.y), id);\n}\n\n/**\n * Converts to pixelated coordinate.\n */\nvec2 to_pixelated_coord(in vec2 pos){\n#if (MASK_MODEL == 0 || MASK_MODEL == 1 || MASK_MODEL == 2)\n    vec2 res = pos - mod(floor(pos), float(PIXELATION_SIZE));\n#elif (MASK_MODEL == 3)\n    pos.y -= float(PIXELATION_SIZE / 2) * mod(floor(pos.x / float(PIXELATION_SIZE)), 2.);\n    vec2 res = pos - mod(floor(pos), float(PIXELATION_SIZE));\n#elif (MASK_MODEL == 4)\n#if !IS_VALID_PIXELATION_SIZE\n#error \"Invalid PIXELATION_SIZE.\"\n#endif\n    vec4 factor = float(PIXELATION_SIZE / 4) * vec4(4, 2, 6, 3);\n\n    // Determine the region for the specified position.\n    float region_y = mod(floor(pos.y / factor.y), 2.);\n    float region_x = mod(pos.x + factor.w * region_y, factor.z);\n    region_x = step(factor.x, region_x);\n    float region = abs(region_y - region_x);\n\n    // Determine the center coordinates of the T shape.\n    vec2 offset = region * vec2(-factor.w, -factor.y);\n    vec2 offset_pos = pos + offset;\n    vec2 res = vec2(0.5, 0.5 - offset.y);\n    res += floor(offset_pos / factor.zx) * factor.zx;\n#else\n#error \"Invalid MASK_MODEL.\"\n#endif\n    return res;\n}\n\nvec3 fetch(in vec2 pos){\n#ifdef ENABLE_SHAPE_VFLIP\n    pos.y = iResolution.y - pos.y;\n#endif\n\n    pos = to_pixelated_coord(pos);\n\n#ifdef ENABLE_SHAPE_VFLIP\n    pos.y = iResolution.y - pos.y;\n#endif\n\n#if (MASK_MODEL == 0 || MASK_MODEL == 1 || MASK_MODEL == 2 || MASK_MODEL == 3)\n    vec2 size = vec2(PIXELATION_SIZE);\n#elif (MASK_MODEL == 4)\n#if !IS_VALID_PIXELATION_SIZE\n#error \"Invalid PIXELATION_SIZE.\"\n#endif\n    vec2 size = float(PIXELATION_SIZE / 4) * vec2(6, 2);\n#else\n#error \"Invalid MASK_MODEL.\"\n#endif\n\n    pos = pos - floor(pos) + floor(pos / size);\n\n#ifdef ENABLE_DISTORTION\n    // When enabling distortion, a soft cap is required.\n    vec2 threshold = ceil(iResolution.xy / size) - 0.5;\n    pos = clamp(pos, vec2(0.5), threshold);\n#endif // ENABLE_DISTORTION\n\n#ifdef ENABLE_DISTORTION\n    pos = 0.5 + floor(pos); // Equivalent to GL_NEAREST.\n#endif // ENABLE_DISTORTION\n    return texture(iChannel0, pos / iResolution.xy).rgb;\n}\n\n//==============================================================================\n\n#ifdef ENABLE_MASK\n/**\n * Returns the weight of the shadow mask at the specified position.\n */\nvec3 mask(in vec2 pos){\n#ifdef ENABLE_SHAPE_VFLIP\n    pos.y = iResolution.y - pos.y;\n#endif\n\n#if (MASK_MODEL == 0 || MASK_MODEL == 3)\n    int i = int(floor(mod(pos.x, 4.)));\n    return PHOSPHOR_LAYOUT_0[i];\n#elif (MASK_MODEL == 1)\n    ivec2 i = ivec2(floor(mod(pos, vec2(8, 4))));\n    return PHOSPHOR_LAYOUT_1[i.y * 8 + i.x];\n#elif (MASK_MODEL == 2)\n    ivec2 i = ivec2(floor(mod(pos, 4.)));\n    return PHOSPHOR_LAYOUT_2[i.y * 4 + i.x];\n#elif (MASK_MODEL == 4)\n    ivec2 i = ivec2(floor(mod(pos, vec2(6, 4))));\n    return PHOSPHOR_LAYOUT_3[i.y * 6 + i.x];\n#else\n#error \"Invalid MASK_MODEL.\"\n#endif\n}\n#endif // ENABLE_MASK\n\n//==============================================================================\n\n#ifdef ENABLE_SCANLINE\nfloat gauss(in float x, in float scale){\n    return exp2(- scale * x * x);\n}\n\nvec2 map_to_zero(in vec2 pos){\n    return fract(pos) - 0.5;\n}\n\n/**\n * Returns the weight of the scanline at the specified position.\n */\nfloat scanline(in vec2 pos){\n    pos /= float(PIXELATION_SIZE);\n#ifdef ENABLE_AA_SCANLINE\n    float mapped_pos = fract(pos.y) - 0.5;\n    vec3 x = vec3(mapped_pos - 0.5, mapped_pos, mapped_pos + 0.5);\n    x = exp2(- SCANLINE_SHARPNESS * x * x);\n    return dot(x, vec3(0.25, 0.5, 0.25));\n#else\n    vec2 mapped_pos = map_to_zero(pos);\n    return gauss(mapped_pos.y, SCANLINE_SHARPNESS);\n#endif\n}\n#endif // ENABLE_SCANLINE\n\n//==============================================================================\n\n#ifdef ENABLE_DISTORTION\n/**\n * The radial distortion model is an approximate Brown-Conrady polynomial model of even order.\n */\nvec2 radial_distortion(in vec2 uv){\n    const float k1 = -0.0025;\n    const float k2 = -0.005;\n\n    vec2 ndc = 2. * uv - 1.;\n\n    float r2 = dot(ndc, ndc);\n    ndc = ndc / (1. + k1 * r2 + k2 * r2 * r2);\n\n    return (ndc + 1.) * 0.5;\n}\n#endif // ENABLE_DISTORTION\n\n//==============================================================================\n\n#ifdef ENABLE_VIGNETTE\n/**\n * Returns the weight of the vignette at the specified position.\n */\nfloat vignette(in vec2 pos){\n    vec2 uv = pos / iResolution.xy;\n    uv *= 1. - uv; // u(1-u), v(1-v)\n    return pow(uv.x * uv.y * 16., VIGNETTE_INTENSITY);\n}\n#endif // ENABLE_VIGNETTE\n\n//==============================================================================\n\n#ifdef ENABLE_CA\n/**\n * Returns the Chebyshev length of a vector.\n */\nfloat chebyshev_length(in vec2 p){\n    p = abs(p);\n    return max(p.x, p.y);\n}\n\n// https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-8-simulating-diffraction\nvec3 bump(vec3 x){\n    // |x| > 1 ? 0 : 1 - x^2 \n\tvec3 y = vec3(1.) - x * x;\n\ty = max(y, vec3(0.));\n\treturn y;\n}\n\nvec3 spectrum(float t){\n    // t := 0 <= (wl - 400) / 300 <= 1\n    return bump(4. * vec3(t - 0.75, t - 0.5, t - 0.25));\n}\n\nvec3 sample_spectrum(in vec2 start, in vec2 end, in int num_samples){\n    float dn = 1. / float(num_samples - 1);\n    vec2 delta = (end - start) * dn;\n    vec2 pos = start;\n    vec3 sum = vec3(0.);\n    vec3 weight_sum = vec3(0.);\n\n    for(int i = 0; i < num_samples; i++){\n        vec3 weight = spectrum(float(i) * dn);\n        sum += weight * fetch(pos);\n        weight_sum += weight;\n        pos += delta;\n    }\n\n    return sum / weight_sum;\n}\n\n/**\n * This function is based on the information from the following webpage.\n * Armored Warfare: Проект Армата. Хроматическая аберрация - lesha_lesovoy\n * https://habr.com/ru/companies/vk/articles/510330/\n */\nvec3 chromatic_aberration(in vec2 pos){\n    const float falloff = 3.;\n    const float blur_strength = 0.5;\n    const float scale_factor = 0.1 * float(PIXELATION_SIZE / 2);\n    vec2 offset_uv = pos / iResolution.xy - 0.5;\n    float distance_strength = pow(chebyshev_length(offset_uv), falloff);\n    vec2 velocity = blur_strength * distance_strength * normalize(offset_uv);\n    velocity *= scale_factor * iResolution.xy;\n\n    // If the maximum sampling distance doesn't extend beyond the current pixel,\n    // early termination is performed.\n    if(all(lessThan(abs(velocity), vec2(0.5)))){\n        return fetch(pos);\n    }\n\n    return sample_spectrum(pos, pos - velocity, 5);\n}\n#endif // ENABLE_CA\n\n//==============================================================================\n\n#ifdef ENABLE_TONE_MAPPING\nfloat EV100(float N, float t, float S){\n    return log2(N * N / t * 100. / S);\n}\n\nfloat exposure(float EV100){\n    float l_max = 1.2 * pow(2., EV100);\n    return 1. / l_max;\n}\n\n/**\n * ACES Filmic Tone Mapping Curve\n * https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n */\nvec3 ACESFilm(in vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0., 1.);\n}\n#endif // ENABLE_TONE_MAPPING\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 color = vec3(0.);\n    vec2 uv = fragCoord / iResolution.xy;\n    float vsep_pos = load_state(SID_SEPARATOR).x * iResolution.x;\n\n    if(fragCoord.x < vsep_pos){\n        color = srgb_to_linear(texture(iChannel1, uv).rgb);\n    }else{\n#ifdef ENABLE_DISTORTION\n        uv = radial_distortion(uv);\n        vec2 dist = abs(uv - 0.5);\n        if(max(dist.x, dist.y) > 0.5){\n            color = vec3(0.);\n        }else{\n#endif\n#ifdef ENABLE_CA\n            color = chromatic_aberration(uv * iResolution.xy);\n#else\n            color = fetch(uv * iResolution.xy);\n#endif\n#ifdef ENABLE_MASK\n            color *= mask(fragCoord);\n#endif\n#ifdef ENABLE_SCANLINE\n            color *= scanline(uv * iResolution.xy);\n#endif\n#ifdef ENABLE_VIGNETTE\n            color *= vignette(fragCoord);\n#endif\n#ifdef ENABLE_DISTORTION\n        }\n#endif\n#ifdef ENABLE_TONE_MAPPING\n        float exposure = exposure(EV100(1.4, 1./60., 100.));\n        color = 1.8 * ACESFilm(exposure * color);\n#endif\n    }\n\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}