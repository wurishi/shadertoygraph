{"ver":"0.1","info":{"id":"M3fBz7","date":"1728166481","viewed":88,"name":"How great it would be to know","username":"Elsio","description":"How great it would be to know how to texture","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","pistons"],"hasliked":0,"parentid":"lXScRW","parentname":"Blood Forminhas"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S smoothstep\n#define pi acos(-1.)\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define h21(v) fract(sin(dot(v, vec2(12.9898,78.233)))*43758.5453123)\n#define norm(p) normalize(vec3(map(p + e), map(p + e.yxy), map(p + e.yyx)) - map(p))\n#define t (iTime + 25.)\n\n// #3\n#define spring(x) (S(-.4, .4, x) + S(-.3, .3, x) - S(-.7, .7, x))\n#define smpl(p, dir, dist) S(-dist, dist, map(p + dir * dist))\n\nvec3 face(vec3 p) { // #1\n     vec3 a = abs(p);\n     return step(a.yzx, a) * step(a.zxy, a) * sign(p);\n}\n\n\nfloat debug;\nvec3 mcol = vec3(.5);\n\nvec3 conf(inout vec3 p, inout vec3 id){\n    vec3 m, a, b;\n\n    p.z = \n      dot(\n          cos(p.xy * 5.) * 2.5, \n          sin(p.xy * 2.)\n      ) * .1;\n\n    id = floor(p) + .5;\n    m = sign(mod(p, 2.) - 1.);\n    if(m.x * m.y * m.z < 0.)   // #5\n        id += face(p - id);\n        \n    p -= id;\n    \n    //closest edge of the cube to p\n    b = 1. - abs(face(p));\n    a = sign(p) * b.zxy; \n    b = sign(p) * b.yzx;\n    return length(p - a) < length(p - b) ? a : b;\n}\n\nfloat map(vec3 p) {\n    float s;\n    vec3 id, P = p,\n         nei = conf(p, id); \n\n    // #4\n    #define cyl(k, r, h)                                  \\\n                length(                                   \\\n                    max(                                  \\\n                        vec2(                             \\\n                            sign(r) * length(p - k) - r,  \\\n                            P.z - h                       \\\n                        ),                                \\\n                        0.                                \\\n                    )                                     \\\n                )\n    \n    float \n    z = spring(\n            sin(h21(id.xy) * t * 2.)) * 2. - .5,\n    \n    neigh = cyl(nei , .6,  2.   ), // #2\n    cell  = cyl(0., .6, .1 * z), \n    cell_ = cyl(0., .4, .5 * z), \n    gnd   = cyl(0., -.68,  .0 ),\n    \n    ret = min(gnd - .04, min(min(cell, cell_), neigh) - .09);\n\n    if(abs(ret - cell) < .2){\n        if((length(p - nei) - .5) < .6) mcol = vec3(1, 1, 0);\n        if((length(p) - cos(t)) < .5) mcol = vec3(0, 0, 1);\n        if((length(p - nei) - .2) < .6) mcol = vec3(0, .5, 0);\n    }\n    \n    if(iMouse.z > 0. || cos(t) > .75)\n        return ret;\n\n    // debug \n    {\n        vec3 g = vec3(\n                     fract(P.xy + .5) - .5,\n                     P.z - .75\n                 );\n\n        float grid = \n                  min( \n                      max(length(g.xy), g.z - .05),\n                      min(length(g.xz), length(g.yz))\n                  ) - .03;\n\n        debug = step(grid, ret);\n        return min(grid, ret);\n    }\n}\n\n\nvoid mainImage(out vec4 o, in vec2 u) {\n    vec2 R = iResolution.xy;\n    u = (u - R / 2.) / R.y;\n    \n    //camera\n    vec3 D = normalize(vec3(1.5, u)), \n         p = vec3(-5, 0, 0); \n         \n    vec2 M = iMouse.z > 0. \n                      ? pi/4. * (iMouse.xy - R / 2.) / R.y\n                      : vec2(0);\n    \n    float tt = t / 3.,\n          yrot = sin(tt * .3) * .2 + .7, \n          zrot = tt * .2;\n    \n    D.xz *= rot(yrot-M.y);\n    D.yx *= rot(zrot);\n    D.yx *= rot(M.x);\n    p.xz *= rot(yrot);\n    p.yx *= rot(zrot);\n    p += vec3(tt * vec2(.5, 2), cos(tt));\n    \n    float s = 1., i; \n    while(i++ < 140. && s * s > 1e-6 ) \n        s = map(p), \n        p += s * D;\n    \n    float ao, spec;\n    \n    \n    vec3 e = vec3(.01, 0, 0),           \n         n = norm(p), \n         r = reflect(D, n),\n         col;\n\n    bool deb;\n    if(debug == 1.) {\n        deb = true;\n    }\n    \n    ao = smpl(p, n, .01)\n            * sqrt(\n                  smpl(p, r, .9) \n                * smpl(p, r, .4) \n                * smpl(p, r, .5));\n    \n    if(deb) {\n        mcol = vec3(.5);\n        spec = length(sin(r * 3.) * .2 + .4);\n        o.rgb = sqrt((mcol * spec + pow(spec, 13.)) * ao);\n    }\n    else{\n        spec = length(sin(r * 2.) * .1 + .5);\n        o.rgb = (mcol * spec + pow(spec, .8)) * ao;\n    }\n}\n\n\n\n/*\n    // #1 \n    // closest face of the cube to p\n    // from @shane sugestion of @blackle function face()\n    // https://www.shadertoy.com/view/Wl3fD2\n    \n    vec3 face(vec3 p) {\n        vec3 ap = abs(p);\n\n        if(ap.x >= max(ap.z, ap.y)) return vec3(sign(p.x), 0., 0.);\n        if(ap.y >= max(ap.z, ap.x)) return vec3(0., sign(p.y), 0.);\n        if(ap.z >= max(ap.x, ap.y)) return vec3(0., 0., sign(p.z));\n\n        return vec3(0);\n    }\n    \n    \n    \n    // #2\n    // from @fabrice sugestion of reduction\n    \n    adj = cyl(k , -.6,  2.   ), // length( max( vec2( length(p - k) - .6, pz - 2.    ), 0.)),\n    cur = cyl(0., -.6, .1 * z), // length( max( vec2( length(p    ) - .6, pz - .1 * z), 0.)),        \n    cur2= cyl(0., -.4, .5 * z), // length( max( vec2( length(p    ) - .4, pz - .5 * z), 0.)),        \n    gnd = cyl(0., .68,  0.   ); // length( max( vec2(-length(p    ) +.68, pz         ), 0.));\n    \n    \n    \n    // #3\n    // quase todo este shader foi fortemente inspirado \n    // no shader da @blackle 'Whack-A-Mole Pistons'\n    // https://www.shadertoy.com/view/WtXcWB\n\n\n    // #4 \n    // cilindro de centro p - k, raio r e altura h\n    \n    \n    // #5 \n    \n\n*/\n","name":"Image","description":"","type":"image"}]}