{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// By: Brandon Fogerty\n// bfogerty at gmail dot com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float EPS = 0.01;\nconst int MAXI = 100;\n\nmat4 m_transpose( mat4 m )\n{\n\tmat4 t = mat4( vec4( m[0][0], m[1][0], m[2][0], m[3][0] ),\n\t\t\t\t   vec4( m[0][1], m[1][1], m[2][1], m[3][1] ),\n\t\t\t\t   vec4( m[0][2], m[1][2], m[2][2], m[3][2] ),\n\t\t\t\t   vec4( m[0][3], m[1][3], m[2][3], m[3][3] ) );\n\treturn t;\n}\n\nmat4 invert( mat4 mat )\n{\n\tvec3 right = \tvec3( mat[0][0], mat[0][1], mat[0][2] );  \n\tvec3 up = \t\tvec3( mat[1][0], mat[1][1], mat[1][2] );\n\tvec3 fwd = \t\tvec3( mat[2][0], mat[2][1], mat[2][2] );\n\tvec3 pos = \t\tvec3( mat[3][0], mat[3][1], mat[3][2] );\n\t\n\tmat4 t = m_transpose( mat );\n\t\n\tt[0][3] = -dot(right, pos);\n\tt[1][3] = -dot(right, pos);\n\tt[2][3] = -dot(right, pos);\n\t\n\treturn t;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat cube( vec3 ray, float r, mat4 transform )\n{\n\tvec3 rayPrime = vec3(m_transpose( transform ) * vec4(ray,1));\n\tfloat d = length(max(abs(rayPrime)-vec3(0.5,0.5,0.5),0.0))-r;\n\t\n\treturn d;\n}\n\nfloat sphere( vec3 ray, float r, mat4 transform )\n{\n\tvec3 rayPrime = vec3(invert( transform ) * vec4(ray,1));\n\tfloat d = length(rayPrime)-r;\n\t\n\treturn d;\n}\n\nfloat torus( vec3 ray, vec2 t, mat4 transform )\n{\n    vec3 rayPrime = vec3(invert( transform ) * vec4(ray,1));\n\tvec2 q = vec2(length(rayPrime.xz)-t.x,rayPrime.y);\n\treturn length(q)-t.y;\n}\n\nfloat SceneDist( vec3 ray )\n{\t\n\tfloat t = iTime;\n\tfloat c = cos( t );\n\tfloat s = sin( t );\n\t\n\tmat4 rotX = mat4(      vec4(1,0,0,0),\n\t\t\t\t\t\t   vec4(0,c,-s,0),\n\t\t\t\t\t\t   vec4(0,s,c,0),\n\t\t\t\t\t\t   vec4(0,0,0,1) );\n\t\n\tmat4 rotY = mat4(      vec4(c,0,-s,0),\n\t\t\t\t\t\t   vec4(0,1,0,0),\n\t\t\t\t\t\t   vec4(s,0,c,0),\n\t\t\t\t\t\t   vec4(0,0,0,1) );\n\t\n\tmat4 rotZ = mat4(      vec4(c,s,0,0),\n\t\t\t\t\t\t   vec4(-s,c,0,0),\n\t\t\t\t\t\t   vec4(0,0,1,0),\n\t\t\t\t\t\t   vec4(0,0,0,1) );\n\t\n\tmat4 pos = mat4(       vec4(1,0,0,s*1.0),\n\t\t\t\t\t\t   vec4(0,1,0,0),\n\t\t\t\t\t\t   vec4(0,0,1,c*1.0),\n\t\t\t\t\t\t   vec4(0,0,0,1) );\n\t\n\tmat4 transform = pos * rotZ * rotY * rotY;\n\n\tfloat d1 = cube( ray, 0.15, transform );\n\t//float d2 = sphere( ray, 0.5, transform );\n    float d2 = torus( ray, vec2(0.7, 0.1), transform);\n\tfloat tVal = sin(iTime)*0.5+0.5;\n\tfloat final = mix(d1,d2, tVal);\n\t\n\treturn final;\n}\n\nvec3 getNormal(vec3 pos){ // this gets the normal\n\t\t\t\t\t\t  // if you understand, good. if not, not much I can do.\n\tvec2 eps = vec2(0.0, EPS);\n\treturn normalize(vec3( // always normalise directions\n\t\t\tSceneDist(pos + eps.yxx) - SceneDist(pos - eps.yxx),\n\t\t\tSceneDist(pos + eps.xyx) - SceneDist(pos - eps.xyx),\n\t\t\tSceneDist(pos + eps.xxy) - SceneDist(pos - eps.xxy)));\n}\n\nvec3 hsv(float h,float s,float v) { // this is just a hue/saturation/luminance to RGB conversion\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 Lighting( vec3 camPos, vec3 pos, vec3 normal, vec3 diffuseColor )\n{\n\tvec3 lightPos = vec3(0,0,10);\n\tvec3 lightDir = normalize( lightPos - pos );\n\tvec3 viewDir = normalize( camPos - pos );\n\tvec3 lightAmbientColor = vec3(0.1,0.1,0.1);\n\tvec3 lightSpecularColor = vec3(1,1,1);\n\t\n\tvec3 halfDir = normalize(viewDir + lightDir);\n\t//float lightSpecularIntensity = pow( clamp(dot( normal, halfDir ), 0.0, 1.0), 2.0 );\n\tfloat lightSpecularIntensity = pow( clamp(dot( normal, reflect(lightDir, normal )), 0.0, 1.0), 80.0 );\n\t\n\tfloat lightDiffuseIntensity = clamp( dot( -normalize(pos), lightDir ), 0.00, 1.0);\n\t\n\t\n\treturn lightAmbientColor + (lightDiffuseIntensity * diffuseColor) + (lightSpecularIntensity * lightSpecularColor);\n\t\n}\n\nvec3 RenderScene( vec2 uv, vec2 fragCoord )\n{\n\tvec3 color = vec3(1,0,0);\n\t\n\t//vec3 camPos = vec3( sin(iTime) * 3.0, 0.0, cos(iTime) * 3.0);\n\tvec3 camPos = vec3(0,0,-3);\n\tvec3 camTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 camUp = vec3(0,1.0,0);\n\tvec3 camFwd = normalize( camTarget - camPos );\n\tvec3 camRight = normalize( cross( camUp, camFwd ) );\n\tcamUp = normalize( cross( camRight, camFwd ) );\n\t\n\tfloat dist = SceneDist( camPos );\n\tfloat total = dist;\n\tvec3 rayDir = vec3( normalize( camFwd + camRight * uv.x + camUp * uv.y ) );\n\t\n\tfor(int i=0; i < MAXI; ++i)\n\t{\n\t\tdist = SceneDist( camPos + rayDir * total );\n\t\ttotal += dist;\n\t\t\n\t\tif( dist <= EPS )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvec3 dest = camPos + rayDir * total;\n\tif( dist <= EPS )\n\t{\n        float t = sin(iTime)*0.5+0.5;\n        vec3 diffuse = mix( vec3(1.0,0.0,0.0), vec3(1.0,1.0,0.0), t);\n\t\tcolor = Lighting( camPos, dest, getNormal( dest ), diffuse );\n\t}\n\telse\t\n\t{\n        vec2 p = floor( iTime + fragCoord.xy/iResolution.x*10.0 );\n        float s = mod( p.x + p.y, 2.0 );\n        vec3 bg0 = vec3(s,s,s);\n        \n        vec3 bg1 = hsv(.55,smoothstep(-1.5,1.,uv.y),1.);\n        \n        float t = sin(iTime) * 0.5 + 0.5;\n        color = mix( bg0, bg1, t);\n\t}\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - 0.5) * vec2(2.0, 2.0 * iResolution.y / iResolution.x);\n\tvec3 color = RenderScene( uv,fragCoord );\n\t\n\t// Scan line\n\tcolor -= mod(fragCoord.y, 2.0) < 1.0 ? 0.5 : 0.0;\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls2SWW","date":"1412226990","viewed":1546,"name":"Morph Demo","username":"akaitora","description":"Morph Demo","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["morphing"],"hasliked":0,"parentid":"","parentname":""}}