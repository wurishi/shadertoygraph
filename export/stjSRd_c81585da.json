{"ver":"0.1","info":{"id":"stjSRd","date":"1628429293","viewed":457,"name":"Raymarching Max Norm Primitives","username":"TheTurk","description":"Maximum norm distance functions for some basic 3D shapes ([url]https://www.shadertoy.com/playlist/tX33Rr[/url]).","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","sdf","sphere","distance","box","plane","ellipsoid","cylinder","capsule","linfinity","maximumnorm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float plane(vec3 position, vec3 planeNormal, float planeDistance) {\n    float d = dot(position, planeNormal) + planeDistance;\n    return d / dot(planeNormal, sign(planeNormal));\n}\n\nfloat box(vec3 position, vec3 halfSize) {\n    position = abs(position) - halfSize;\n    return max(max(position.x, position.y), position.z);\n}\n\nfloat sphere(vec3 position, float radius) {\n    position = abs(position);\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    {\n        float b = dot(vec2(1.0), position.xy);\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    \n    return d;\n}\n\nfloat ellipsoid(vec3 position, vec3 radius) {\n    position = abs(position);\n    float d = max(max(abs(position.x - radius.x), position.y), position.z);\n    d = min(d, max(max(position.x, abs(position.y - radius.y)), position.z));\n    d = min(d, max(max(position.x, position.y), abs(position.z - radius.z)));\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.yz * radius.yz));\n        float b = dot(vec2(1.0), position.yz / (radius.yz * radius.yz));\n        float c = dot(vec2(1.0), (position.yz * position.yz) / (radius.yz * radius.yz)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.x));\n        }\n    }\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.xz * radius.xz));\n        float b = dot(vec2(1.0), position.xz / (radius.xz * radius.xz));\n        float c = dot(vec2(1.0), (position.xz * position.xz) / (radius.xz * radius.xz)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.y));\n       }\n    }\n    {\n        float a = dot(vec2(1.0), 1.0 / (radius.xy * radius.xy));\n        float b = dot(vec2(1.0), position.xy / (radius.xy * radius.xy));\n        float c = dot(vec2(1.0), (position.xy * position.xy) / (radius.xy * radius.xy)) - 1.0;\n        float discriminant = b * b - a * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / a;\n            d = min(d, max(t, position.z));\n        }\n    }\n    float a = dot(vec3(1.0), 1.0 / (radius * radius));\n    float b = dot(vec3(1.0), position / (radius * radius));\n    float c = dot(vec3(1.0), (position * position) / (radius * radius)) - 1.0;\n    float discriminant = b * b - a * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / a;\n        d = min(d, t);\n    }\n    return d;\n}\n\nfloat cylinder(vec3 position, float radius, float halfHeight) {\n    position = abs(position);\n    float d = max(position.x - radius, position.z);\n    d = min(d, max(position.x, position.z - radius));\n    float b = dot(vec2(1.0), position.xz);\n    float c = dot(position.xz, position.xz) - (radius * radius);\n    float discriminant = b * b - 2.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 2.0;\n        d = min(d, t);\n    }\n    d = max(d, position.y - halfHeight);\n    return d;\n}\n\nfloat capsule(vec3 position, float radius, float halfHeight) {\n    position = abs(position);\n    position.y -= halfHeight - radius;\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    {\n        float b = dot(vec2(1.0), position.xy);\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    return d;\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nvec4 sdf(vec3 position) {\n    float material = 0.0;\n    float d = plane(position, vec3(0.0, 1.0, 0.0), 0.0);\n    float d1 = box(position - vec3(-4.0, 0.5, 0.0), vec3(0.5, 0.5, 0.5));\n    if (d1 < d) {\n        material = 1.0;\n        d = d1;\n    }\n    float d2 = cylinder(position - vec3(-2.0, 0.5, 0.0), 0.5, 0.5);\n    if (d2 < d) {\n        material = 2.0;\n        d = d2;\n    }\n    float d3 = capsule(position - vec3(0.0, 0.6, 0.0), 0.3, 0.6);\n    if (d3 < d) {\n        material = 3.0;\n        d = d3;\n    }\n    float d4 = sphere(position - vec3(2.0, 0.5,  0.0), 0.5);\n    if (d4 < d) {\n        material = 4.0;\n        d = d4;\n    }\n    float d5 = ellipsoid(position - vec3(4.0, 0.5, 0.0), vec3(0.75, 0.5, 0.5));\n    if (d5 < d) {\n        material = 5.0;\n        d = d5;\n    }\n    return vec4(d, material, 0.0, 0.0);\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)).x - sdf(position + vec3(-epsilon, 0, 0)).x,\n        sdf(position + vec3(0, epsilon, 0)).x - sdf(position + vec3(0, -epsilon, 0)).x,\n        sdf(position + vec3(0, 0, epsilon)).x - sdf(position + vec3(0, 0, -epsilon).x)\n    );\n    return normalize(gradient);\n}\n\nfloat shadow(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 64;\n    float t = 0.03;\n    float maximumDistance = 10.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition).x;\n        if (d < 0.001) {\n            return 0.0;\n        }\n        t += d;\n    }\n    return 1.0;\n}\n\nvec4 raycast(vec3 rayOrigin, vec3 rayDirection) {\n    vec4 hitResult = vec4(0.0, 0.0, 0.0, 0.0);\n    int stepCount = 256;\n    float maximumDistance = 100.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        vec4 result = sdf(currentPosition);\n        if (result.x < 0.001 * max(t, 1.0) ) {\n            hitResult = vec4(t, result.y, 0.0, 0.0);\n            break;\n        }\n        t += result.x;\n    }\n   \n    return hitResult;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mousePosition = iMouse.xy / iResolution.xy;\n\n    vec3 targetPosition = vec3(0.0, 0.0, 0.0);\n    float angle = sin(iTime * 0.2) * 1.0;\n    vec3 rayOrigin = targetPosition + vec3(5.0 * sin(angle + 2.0 * -mousePosition.x), 2.0 - 2.0 * mousePosition.y, 5.0 * cos(angle + 2.0 * -mousePosition.x));\n    vec3 rayDirection = normalize(vec3(uv, 2.5));\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    rayDirection = cameraTransform * rayDirection;\n   \n    vec3 color = mix(vec3(1.0), vec3(0.25, 0.5, 1.0) * 1.2, (rayDirection.y + 0.3) * 2.0);\n\n    vec4 hitResult = raycast(rayOrigin, rayDirection);\n    float t = hitResult.x;\n    float material = hitResult.y;\n    if (t > 0.0) {\n        vec3 position = rayOrigin + rayDirection * t;\n        vec3 lightDirection = normalize(vec3(-0.5, 0.8, 0.2));\n        vec3 n = normal(position);\n        float shadowAttenuation = shadow(position, lightDirection);\n        \n        float diffuseAngle = max(dot(n, lightDirection), 0.0);\n        vec3 halfwayDirection = normalize(lightDirection + -rayDirection);\n        float specularAngle = pow(max(dot(n, halfwayDirection), 0.0), 16.0);\n        \n        vec3 baseColor = vec3(0.2);\n        if (material == 0.0) {\n            float checkerboard = mod(floor(2.0 * position.z) + floor(2.0 * position.x), 2.0);\n            baseColor += vec3(0.1) * checkerboard;\n        } else {\n            baseColor = 0.2 + 0.2 * cos(6.28318 * (vec3(1.0, 1.0, 1.0) * (material / 6.0) + vec3(0.0, 0.33, 0.67)));\n        }\n        \n        // diffuse\n        color = 2.0 * vec3(1.0, 0.85, 0.55) * diffuseAngle * shadowAttenuation * baseColor;\n        // specular\n\t\tcolor += 1.0 * vec3(1.0, 0.85, 0.55) * specularAngle * diffuseAngle * shadowAttenuation * baseColor;\n        // ambient\n        color += 0.5 * vec3(0.25, 0.5, 1.0) * ((n.y + 1.0) * 0.5) * baseColor; // sky\n        color += 0.5 * vec3(0.25, 0.25, 0.25) * clamp(dot(n, normalize(vec3(-lightDirection.x, 0.0, -lightDirection.z))), 0.0, 1.0) * clamp(1.0 - position.y, 0.0, 1.0) * baseColor; // back\n        // fog\n        color = mix(color,  mix(vec3(1.0), vec3(0.25, 0.5, 1.0) * 1.2, 0.55), 1.0 - exp(-0.0001 * t * t * t));\n    }\n    // gamma\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}