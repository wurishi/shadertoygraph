{"ver":"0.1","info":{"id":"mtBSWw","date":"1678576009","viewed":104,"name":"Penrose Triangle thingy","username":"ThaRemo","description":"Attempting to draw a cool penrose triangle. Any ideas for making it look crazy?","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["penrose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265359\n#define PI_2 6.2831\n\n// From https://www.shadertoy.com/view/wdtfWX\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n\n    // Barycentric triangle areas\n    float abc = ba.x * cb.y - ba.y * cb.x;\n    float abp = ba.x * pa.y - ba.y * pa.x;\n    float bcp = cb.x * pb.y - cb.y * pb.x;\n    float cap = ac.x * pc.y - ac.y * pc.x;\n\n    // Edge distances\n    vec2 ae = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 be = pb - cb * clamp(dot(pb, cb) / dot(cb, cb), 0.0, 1.0);\n    vec2 ce = pc - ac * clamp(dot(pc, ac) / dot(ac, ac), 0.0, 1.0);\n\n    // Combined edge distances\n    float tri = sqrt(min(dot(ae, ae), min(dot(be, be), dot(ce, ce))));\n\n    // Combine with the appropriate sign (-1 if inside +1 if outside)\n    return tri * sign(max(-abp, max(-bcp, -cap)) * max(abp, max(bcp, cap)));\n}\n\n// https://www.shadertoy.com/view/3lVGWt\nmat2 rot2d(in float angle) {\n\tfloat a = angle * PI / 180.0;\n    float s = sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdRectangle(in vec2 p, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4) {\n    return min(sdTriangle(p, p1, p2, p3), sdTriangle(p, p3, p4, p1));\n}\n\nfloat tan60 = tan(PI_2 * 60. / 360.);\n\nfloat sdPenroseSide(in vec2 p, in float r, in float t) {\n    // A side consists of two rectangles: An outer and inner bit\n    // This func draws one on the bottom around center 0,0.\n    // Rotate the input p by 120 degr to get the other ones\n    float hgap = t / tan60;\n    float x = r * cos(30. / 360. * PI_2);\n    float y = r * sin(30. / 360. * PI_2);\n    float gap = hgap * 2.;\n    \n    vec2 a = r * vec2(-x + gap,     -y);\n    vec2 b = r * vec2( x - gap,     -y);\n    vec2 c = r * vec2( x - hgap,    -y + t);\n    vec2 d = r * vec2(-x + 1.5*gap, -y + t);\n    vec2 e = r * vec2(-x + 2.5*gap, -y + t);\n    vec2 f = r * vec2( 0.,           r - 4.*t);\n    vec2 g = r * vec2(-hgap,         r - 3.*t);\n    \n    return min(sdRectangle(p, a, b, c, d), sdRectangle(p, d, e, f, g));\n    // return r * sdRectangle(p, a, b, c, d);\n    // return sdRectangle(p, d, e, f, g);\n}\n\nvec3 penroseTriangle(in vec2 uv, in float r, in float t) {\n    float d1 = sdPenroseSide(uv,               r, t);\n    float d2 = sdPenroseSide(uv * rot2d(120.), r, t);\n    float d3 = sdPenroseSide(uv * rot2d(240.), r, t);\n    \n    vec3 col =     (smoothstep(fwidth(d1), 0., d1)) * vec3(1.); // vec3(1., 0.5, 0.5);\n    col = max(col, (smoothstep(fwidth(d2), 0., d2)) * vec3(0.8)); // vec3(0.5, 1., 0.5));\n    col = max(col, (smoothstep(fwidth(d3), 0., d3)) * vec3(0.6)); // vec3(0.5, 0.5, 1.));\n    \n    return col;\n}\n\nfloat sdCircle(in vec2 p, in float r) {\n  return length(p) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv += vec2(cos(iTime), sin(iTime));\n    \n    uv = rot2d(iTime * 20.) * uv * (1. + sin(iTime * 1.5) * 0.5);\n    \n    uv = mod(uv + vec2(0.5), 1.);\n    uv -= vec2(0.5);\n    \n    float s = 2.5;\n    float squareD = sdRectangle(\n                uv * s,\n                vec2(-1, -1),\n                vec2( 1, -1),\n                vec2( 1,  1),\n                vec2(-1,  1)\n    );\n\n    vec3 col = vec3(0.); // 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // float t = s * 0.06; // 0.2 + 0.05 * sin(iTime * PI_2 * 0.5);\n    float t = 0.15 + 0.05 * sin(iTime * PI_2 * 0.5);\n    float grad = 1.0; // (1. - mod(sqrt(length(uv)), 1.));\n    col += penroseTriangle(uv * s, 1., t) * grad;\n    col += penroseTriangle(uv * s, 1. - 5. * t / tan60, t * 0.5) * grad;\n    col += penroseTriangle(uv * s, 1. - 7.5 * t / tan60, t * 0.25) * grad;\n\n    // Debug circle\n    //float cirD = sdCircle(uv * s, 1.);\n    //col += 1. - smoothstep(0., fwidth(cirD), abs(cirD));\n    // col = min(col, 10. * mod(cirD, 0.1));\n    \n    // Debug triangle helper\n    //float triD = sdTriangle(uv * s, vec2(0., 1.), vec2(0., 1.) * rot2d(120.), vec2(0., 1.) * rot2d(240.));\n    //float triD2 = sdTriangle(uv * (s + t), vec2(0., 1.), vec2(0., 1.) * rot2d(120.), vec2(0., 1.) * rot2d(240.));\n    // col += 1.0 - sign(d);\n    // Anti-aliasing with smoothstep + fwidth\n    // col += 1. - smoothstep(0., fwidth(squareD), abs(squareD)); // square border\n    // col += 1. - smoothstep(0., 0.006, abs(triD)); // tri border\n    // col += 1. - smoothstep(0., 0.006, abs(triD2)); // tri border\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}