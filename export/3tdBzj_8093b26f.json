{"ver":"0.1","info":{"id":"3tdBzj","date":"1680371174","viewed":790,"name":"Fresh Water Remaster","username":"Draedrus","description":"This is a remaster of https://www.shadertoy.com/view/MdKSDK which I was quite happy with at the time and I thought it deserved it\n\nPlay a bit with the mouse you'll have some fun","likes":21,"published":1,"flags":40,"usePreview":1,"tags":["mouse","sea","sun","cloud","water","ocean","sky","night","day","beach","boat"],"hasliked":0,"parentid":"MdKSDK","parentname":"Fresh Water"},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n#define CLOUD_ILLUM_INCREASE 0\n \nfloat mapBoatSail(vec3 p)\n{\n    float py = 2.5;\n    float v = .1*sin(iTime);\n    return udTriangle(p-BOAT_POS-vec3(.5, .0, .1), vec3(0., py-.2, 0.), vec3(0.+v, py+2.5, 0.), vec3(-1.5, py-.2, 0.));\n}\n\nfloat raymarchSail(vec3 ro, vec3 rd, in float tmin, in float tmax)\n{\n    float m = -1.0;\n    float res = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = mapBoatSail(ro + res*rd);\n\t\tif( m<tmin || res>tmax ) break;\n\t\tres += 0.5*m;\n\t}\n\treturn res;\n}\n\n// http://www.jcgt.org/published/0010/02/02/paper.pdf\nmat2 NonAxisAlignedNDFFiltering(vec2 halfvectorTS, vec2 roughness2)\n{\n    //Compute the derivatives of the halfvector in the projected space.\n    vec2 halfvector2D = halfvectorTS.xy;\n    vec2 deltaU = dFdx(halfvector2D);\n    vec2 deltaV = dFdy(halfvector2D);\n    //Compute 2 * covariance matrix for the filter kernel (Eq. (3)).\n    float SIGMA2 = 0.15915494;\n    mat2 delta = mat2(deltaU.x, deltaU.y, deltaV.x, deltaV.y);\n    mat2 kernelRoughnessMat = 2.0 * SIGMA2 * transpose(delta)*delta;\n    //Convert the roughness from slope space to the projected space (Eq. (4)).\n    vec2 projRoughness2 = roughness2 / (1.0 - roughness2);\n    mat2 projRoughnessMat = mat2(projRoughness2.x, 0.0, 0.0, projRoughness2.y);\n    //NDF filtering in the projected space (Eq. (6)).\n    mat2 filteredProjRoughnessMat = projRoughnessMat + kernelRoughnessMat;\n    //Convert the roughness from the projected space to slope space (Eq. (7)).\n    //This implementation is optimized based on Appendix D.\n    //For numerical stability, the determinant is clamped with the lower bound.\n    float detMin = projRoughness2.x * projRoughness2.y;\n    float det = max(determinant(filteredProjRoughnessMat), detMin);\n    mat2 m = filteredProjRoughnessMat / det + mat2(1.0, 0.0, 0.0, 1.0);\n    mat2 filteredRoughnessMat = m / max(determinant(m), 1.0);\n    return filteredRoughnessMat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy;\n    vec3 ro, rd;\n    mat3 ca;\n    SetupCamera(fragCoord, iResolution.xy, iResolution.xy, iMouse, uv, ro, rd, ca);\n    vec3 Lo, Los, Lom, Ld;\n    float Li;\n    vec2 mv = iMouse.xy/iResolution.xy;\n    float solarPhase = ComputeLightParams(iTime, mv, Lo, Los, Lom, Ld, Li);\n    \n    const float rough = 0.6;//0.60;\n    const float rough2 = rough*rough;\n    vec2 HTS = -1.+2.*CameraToScreen(ca, normalize(rd+Ld), iResolution.xy);//vec2(1.));//iResolution.xy);\n    float x = random(uv), cs = cos(x), ss = sin(x);\n    mat2 def = mat2(cs, -ss, ss, cs);\n    mat2 NDFKernel = NonAxisAlignedNDFFiltering(HTS, vec2(rough2, rough2));\n    \n    float minHW = 0.5*(-1.0+sin(.2*iTime));\n    float depthWater = max(0., dot(ro - vec3(0., minHW, 0.), vec3(0., 1., 0.)) / dot(vec3(0., 1., 0.), -rd));\n    vec2 eps = vec2(1./iResolution.y);//vec2(-1.+2.*random(fragCoord+iTime), -1.+2.*random(fragCoord-iTime))*(1.-exp(-0.05*depthWater))*4./iResolution.x;\n    float timeDe = .5*iTime;\n    vec2 vcs = vec2(cos(timeDe), sin(timeDe));\n    vec2 re = 1.0/iResolution.y*mat2(vcs.x, -vcs.y, vcs.y, vcs.x)*vec2(random(uv+timeDe)-.5, random(uv-timeDe)-.5);\n   \n    vec4 color = texture(iChannel2, uv).rgba;\n    \n    vec4 waterCol = texture(iChannel0, uv+NDFKernel*-eps).rgba;\n    vec4 waterCol2 = texture(iChannel0, uv+NDFKernel*vec2(-eps.x, eps.y)).rgba;\n    vec4 waterCol3 = texture(iChannel0, uv+NDFKernel*vec2(eps.x, -eps.y)).rgba;\n    vec4 waterCol4 = texture(iChannel0, uv+NDFKernel*eps).rgba;\n    waterCol.rgb = waterCol.rgb*waterCol.a+waterCol2.rgb*waterCol2.a+waterCol3.rgb*waterCol3.a+waterCol4.rgb*waterCol4.a;\n    waterCol.rgb /= max(1., waterCol.a+waterCol2.a+waterCol3.a+waterCol4.a);\n    waterCol.a = clamp(.25*(waterCol.a+waterCol2.a+waterCol3.a+waterCol4.a), 0., 1.);\n    \n    color.rgb *= 1.-waterCol.a;\n    color.rgb += waterCol.a*waterCol.rgb;\n    \n    //color.rgb = tonemapping(color.rgb);\n    \n    vec4 c = texture(iChannel1, CLOUD_RT_SCALE*(uv+NDFKernel*re));\n    vec4 c2 = texture(iChannel1, CLOUD_RT_SCALE*(uv+NDFKernel*re));\n    vec4 c3 = texture(iChannel1, CLOUD_RT_SCALE*(uv+NDFKernel*re));\n    vec4 c4 = texture(iChannel1, CLOUD_RT_SCALE*(uv+NDFKernel*re));\n    c.rgb = (c.rgb+c2.rgb+c3.rgb+c4.rgb)*.25;\n    #if CLOUD_PACKING\n    c.a = floatToVec2(c.a).x;\n    c2.a = floatToVec2(c2.a).x;\n    c3.a = floatToVec2(c3.a).x;\n    c4.a = floatToVec2(c4.a).x;\n    #endif\n    c.a = clamp((c.a+c2.a+c3.a+c4.a)*.25, 0., 1.);\n\n    //c.rgb = tonemapping(c.rgb);\n    \n    // improvised god rays\n    float sight = dot(Ld, rd);\n    {\n        vec2 uvLd = CameraToScreen(ca, Ld, iResolution.xy);\n        vec2 dir = (uv-uvLd)/32.;\n        vec2 uvpos = uvLd+dir*x;\n        float illumdecay = 1.;\n        float illumincr = 0.;\n        \n        float totalAbs = 1.;\n        float cosDir = min(1., max(0., dot(normalize(dir), -normalize(-1.+2.*uv))));\n        for(int i=0; i<32; i++)\n        {\n            float luvl = length(uv-uvLd)-length(uvpos-uvLd);\n            if(luvl>length(uv-uvLd))\n                break;\n            #if CLOUD_PACKING\n            vec2 s = floatToVec2(texture(iChannel1, CLOUD_RT_SCALE*uvpos).a);\n            \n            float sa = s.x;\n            #else\n            float sa = texture(iChannel1, CLOUD_RT_SCALE*uvpos).a;\n            #endif\n            float importance = exp(-32.*luvl);\n            totalAbs *= exp(-length(uv-uvLd)*sa);\n            illumincr += importance*clamp(1.-8.*sa, 0., 1.);\n            if(sa<.2)\n            {\n                illumdecay *= .95+mix(.0, .05, remap01(exp(-luvl), 0., 1.8));\n            }\n            uvpos += dir;\n        }\n        #if CLOUD_ILLUM_INCREASE\n        float grf = Li*illumincr/32.;\n        color.rgb += totalAbs * illumincr\n        *exp(-8.*length(uv-uvLd))\n        *color.rgb\n        *c.a\n        ;\n        color.rgb = clamp(color.rgb, 0., Li);\n        #endif\n        color.rgb *= mix(1., clamp(illumdecay, 0.0, 1.), remap01(sight, .1, 1.));\n    }\n    //\n\n    color.rgb *= c.a;\n    color.rgb += c.rgb*(1.-c.a);\n    \n    float sailt = raymarchSail(ro, rd, CAM_NEAR, CAM_FAR);\n    if(sailt<CAM_FAR && sailt<color.a)\n    {\n        vec3 N = normalize(ro-BOAT_POS);\n        float a = remap01(texture(iChannel3, 32.*uv).r, .4, .8);\n        color.rgb *= a;\n        color.rgb += max(0., dot(Ld, vec3(0., 1., 0.)))*(1.-a)*\n                    (\n                    .1+max(0.1, dot(Ld, N))*vec3(0.863,0.847,0.780)\n                    );\n    }\n    \n    color.rgb = tonemapping(color.rgb);\n\n    float timeFade = remap01(iTime, 0.4, 1.4);\n    \n    fragColor = timeFade*color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n/************************\n * RAYMARCHING PRIMITIVES\n ************************/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat heightMap(vec3 p)\n{\n    return .1*max(0., 1.-texture(iChannel0, p.xz*0.72).r);\n}\n\nfloat mapTerrain(vec3 p)\n{\n    float hm = heightMap(p);\n    return sdPlane(p)+0.5*fbm_hash(0.5*p.xz)+hm+p.z*.2+p.x*.05;\n}\n\nfloat mapBoat(vec3 p)\n{\n    float py = 2.5, ph = .2;\n    return \n            min(\n                udTriangle(p-BOAT_POS, vec3(-2., py, 0.), vec3(-1., py-ph, 0.), vec3(2., py, 0.) ),\n                udTriangle(p-BOAT_POS, vec3(-1., py-ph, 0.), vec3(1., py-ph, 0.), vec3(2., py, 0.) )\n            );\n}\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nfloat mapSand(vec3 p)\n{\n    p.y += 1.0;\n    return sdPlane(p)+p.z*0.01;\n}\n\nvec2 minv2(vec2 a, vec2 b) { return a.x<b.x?a:b; }\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0)), TYPE_FLOOR);\n    d = minv2(d, vec2(mapSand(p), TYPE_SAND));\n    d = minv2(d, vec2(mapBoat(p), TYPE_BOAT));\n    return d;\n}\n\nvec3 mapNormal(vec3 pt, float e)\n{\n    vec3 normal;\n    normal.y = map(pt).x;    \n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax)\n{\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    vec3 ro, rd;\n    mat3 ca;\n    SetupCamera(fragCoord, iResolution.xy, iResolution.xy, iMouse, uv, ro, rd, ca);\n    \n    vec2 rm = vec2(-1.0, -1.0);\n\n    rm = raymarch(ro, rd, CAM_NEAR, CAM_FAR);\n\n    vec2 Np = normal_pack(mapNormal(ro+rd*rm.x, 0.001));\n    \n    fragColor = vec4(rm.x, rm.y, Np.x, Np.y);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n/*******************\n * SCATTERING PARAMETERS\n *******************/\n#define EARTHPOS vec3(0.0, 0.0, 0.0)\n\n#define SKY_BETA_MIE vec3(21e-7)\n#define SKY_BETA_RAY vec3(5.5e-6, 13.0e-6, 22.4e-6)\n#define SKY_BETA_FACTOR_NIGHT .1\n#define SKY_MIE_HEIGHT 1200.\n\n#define ATMOSPHERE_RADIUS \t6420e3\n#define EARTH_RADIUS 6360e3\n#define SUN_RADIUS 696340e3\n#define MOONINTENSITY 5.\n#define SUNINTENSITY 20.\n#define SUNDIST 149597870700.0\n#define MOONDIST 384400000.0\n\n/******************\n * RAYMARCHING PARAMETERS\n ******************/\n#define CAM_FAR 80.0\n#define CAM_NEAR 0.1\n#define CAM_DEPTH 1.0\n#define NUM_STEPS 80\n\n#define CAMPOS vec3(-10.0, 2.0, -4.0)\n#define TARGETPOS vec3(10.0, 2.0, 10.0)\n\n#define BOAT_POS vec3(-8., -2.0, 15.)\n\n#define TO_EARTH_COORD(x) (EARTHPOS+(x+vec3(0., EARTH_RADIUS, 0.)))\n\n//#define LIGHTPOS normalize(vec3(1.0, 0.4, .5))*SUNDIST\n//#define LIGHTPOS normalize(vec3(1.0, 0.143, 1.0))*SUNDIST\n//#define LIGHTPOS normalize(vec3(1.0, 0.000, 1.0))*SUNDIST\n//#define LIGHTPOS normalize(vec3(1.0, -0.03, 1.0))*SUNDIST\n//#define LIGHTPOS normalize(vec3(1.0, 0.03, 1.0))*SUNDIST\n#define LIGHTPOS normalize(vec3(0.0, 1.0, 0.0))*SUNDIST\n//#define LIGHTPOS normalize(vec3(0.7, 1., 0.7))*SUNDIST\n//#define LIGHTPOS normalize(vec3(0.0, -1.0, 0.0))*SUNDIST\n\n#define TYPE_FLOOR 0.0\n#define TYPE_SAND 1.0\n#define TYPE_BOAT 2.0\n\n// x0.1\n// 0.01\n// 0.05\n#define TIMEC(t) (t+1.)*.05\n#define TIME(t) (t+1.)*.10\n\n/*******************\n * RENDERING\n *******************/\n//#define DAYANDNIGHT\n//#define SUNSET\n#define MOUSESUN\n\n#define WATER_REFR_INDEX 1.0/1.33\n\n#define COLORALGAE vec3(0.2, 0.6, 0.1)\n\n#define REFLREFR_FRESNEL_BIAS 0.18\n#define REFLREFR_FRESNEL_SCALE 1.0\n#define REFLREFR_FRESNEL_XPO 0.8\n\n#define CLOUD_ENERGY_ABSORBTION 0.5\n#define CLOUD_MAIN_STEPS 12\n#define CLOUD_LIGHT_STEPS 8\n#define CLOUD_START_HEIGHT 40.\n#define CLOUD_HEIGHT 80.0\n#define CLOUD_RT_SCALE 0.5\n//#define CLOUD_HD_LIGHTING\n\n#define CLOUD_PACKING 0\n\n#define ENABLE_UINT_HASH_CLOUD\n\n#define USE_RAYMARCHED_WATER\n#define USE_MIST\n// used to compute shadows based on reprojected cloudbuffer\n#define USE_SHADOWS\n\n/*******************\n * SAMPLING\n *******************/\n#define FLOOR_TEXTURE_FREQ 0.4\n#define FLOOR_TEXTURE_AMP 0.30\n#define FLOOR_LEVEL -0.80\n\n/*******************\n * MATH\n *******************/\n#define PI2 1.57\n#define PI 3.1415\n#define _2PI 6.2830\n\n#define LENGTH2(v) (v.x*v.x+v.y*v.y)\n\n// iqs methods\nfloat dot2(vec3 v) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n// end of iqs\n\n/*******************\n * TOOLS\n *******************/\n \nfloat remap01(float x, float m_, float _m)\n{\n    return clamp((x-m_)/(_m-m_), 0., 1.);\n}\n\nfloat remap(float x, float mo_, float _mo, float mn_, float _mn) \n{\n    return clamp(mn_+(_mn-mn_)*((x-mo_)/(_mo-mo_)), mn_, _mn);\n}\n\nfloat GetNormalizedDepth(float x)\n{\n\treturn (CAM_FAR-x)/(CAM_FAR-CAM_NEAR);   \n}\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\nvec3 RotXYZ(in vec3 P, vec3 xyz)\n{\n    P = RotXV3(P, xyz.x);\n    P = RotYV3(P, xyz.y);\n    P = RotZV3(P, xyz.z);\n    return P;\n}\n\nfloat GaussianFunc(float x)\n{\n    float g = exp(-x*x/2.0);\n    g = g*g*g*g;\n    return g*g*g*g;\n}\n\nvec2 normal_pack(vec3 n)\n{\n    return n.xy*0.5+0.5;\n}\n\nvec3 normal_unpack(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\n/********************\n * NOISES\n ********************/\n\nfloat hash1D(float x) {\n\treturn fract(sin(x*13.454)*12.3043);\n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n    x = vec3(hash2D(x.xy), hash2D(x.yz), hash2D(x.xz));\n\treturn fract(dot(x, vec3(12.4955, 49.4294, 42.40594))*13.4959451);    \n}\n\nuint hash( uint x )\n{\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n\n\nuvec2 hash2( uvec2 v ) { return uvec2(hash(v.x^hash(v.y)), hash(v.y^hash(v.x))); }\nfloat floatFromUint( uint m )\n{\n    return uintBitsToFloat( 0x3F800000u | ( m & 0x007FFFFFu) ) - 1.0;\n}\nfloat random( float  v ) { return floatFromUint(hash(floatBitsToUint(v))); }\nfloat random( vec2  v ) { return floatFromUint(hash(uvec2(floatBitsToUint(v.x), floatBitsToUint(v.y)))); }\nfloat random( vec3  v )\n{\n    return floatFromUint(hash(uvec3(floatBitsToUint(v.x), floatBitsToUint(v.y),floatBitsToUint(v.z))));\n}\n\nfloat vec2ToFloat(vec2 _v)\n{\n    uvec2 v = uvec2(uint(max(0., _v.x) * 65535.), uint(max(0., _v.y) * 65535.));\n    return uintBitsToFloat(((v.x&0x0000FFFFu) << 16) | (v.y&0x0000FFFFu));\n}\n\nvec2 floatToVec2(float _f)\n{\n    uint uf = floatBitsToUint(_f);\n    float x = float((uf&0xFFFF0000u) >> 16)/65535.;\n    float y = float(uf&0x0000FFFFu)/65535.;\n    return vec2(x, y);\n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = random(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = random(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\n\n/** HASH **/\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(random(lower+vec2(0.0, 0.0)), random(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(random(lower+vec2(0.0, 1.0)), random(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\n/**\n * Cloud Noise\n **/\n\nfloat gaussianNoise3D(vec3 uv)\n{\n\tvec3 p = floor(uv);\n    vec3 f = fract(uv);\n    f = f*f*(3.0-2.0*f);\n    \n    return\n        mix(\n        \tmix(\n                mix(random(p+vec3(0.0, 0.0, 0.0)), random(p+vec3(1.0, 0.0, 0.0)), f.x),\n                mix(random(p+vec3(0.0, 1.0, 0.0)), random(p+vec3(1.0, 1.0, 0.0)), f.x),\n            f.y),\n        \tmix(\n                mix(random(p+vec3(0.0, 0.0, 1.0)), random(p+vec3(1.0, 0.0, 1.0)), f.x),\n                mix(random(p+vec3(0.0, 1.0, 1.0)), random(p+vec3(1.0, 1.0, 1.0)), f.x),\n            f.y),\n        f.z);\n}\n\nfloat fbm3Dsimple(vec3 p) {\n    float total = 0.0;\n    total  = 0.5000* gaussianNoise3D(p); p = p*2.0;\n    total += 0.2500* gaussianNoise3D(p); p = p*2.0;\n    total += 0.1250* gaussianNoise3D(p); p = p*2.0;\n    total += 0.0625* gaussianNoise3D(p); p = p*2.0;\n    return total;\n}\nuint K = 1103515245U;\nvec2 randomhash2D(uvec2 x)\n{\n    x = ((x << 13)^x.yx)*K;\n    x = ((x >> 17)^x.yx)*K;\n    x = ((x << 5)^x.yx)*K;\n    return vec2(x)*(1./float(0xffffffffU));\n}\n\n\n/************************\n * HEIGHTMAPS\n ************************/\n\nvec3 sunDir;\nvec3 moonDir = normalize(vec3(0.0, 1.0, 0.0));\n\nvec2 MainWindDir = vec2(-0.5, 0.5);\n\n/*******************************\n * Atmosphere scattering\n *******************************/\n\nfloat raycast_sphere(vec3 ro, vec3 rd, vec3 sc, float sr)\n{\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>0.0)\n    {\n        return .5*(-B-sqrt(D));\n    }\n    return -1.;\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax)\n{\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0)\n    {\n        if(C==0.0)\n        {\n            tmax = -B/2.0;\n            d = 0.0;\n        }\n        else\n        {\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\nfloat IntersectPlane(vec3 o, vec3 n, vec3 v, vec3 ro)\n{\n    return dot(ro - o, n) / dot(n, -v);\n}\n\n// Huge sky approximation, it does not follow the correct end values but is nice and fast\nvec3 getCheapSkyScattering(vec3 ro, vec3 rd, vec3 L, float intensity, vec3 betaR, vec3 betaM, float _iHM)\n{\n    float tmin = -1.0;\n    float tmax = -1.0;\n    float d = IntersectSphere(ro, rd, vec3(0.), ATMOSPHERE_RADIUS, tmin, tmax);\n    if(d<0.)\n        return vec3(0., 1., 0.);\n    float dist = max(0., max(tmin, tmax));\n  \n    float RdotL = max(0., dot(rd, L));\n     \n    const float g = 0.76; // 0.76\n    const float g2 = g*g;\n    const float hr = 7994.0; // 7994\n    float hm = _iHM;//800.0; // 1200\n    \n    float phaseR = max(0., /*3.0/(16.0*3.14)*/0.05968310*(1.0+RdotL*RdotL));\n    float phaseM = max(0., /*(3./(2.*g2+2.)-.75)*/0.245810055866*exp(pow(RdotL+.38, 5.) -.85));// this ~works because g = 0.76\n    \n    vec3 pt = ro+rd*dist;\n    float dn = remap01(dot(L, vec3(0., 1., 0.)), 0.95, 1.0);\n    const float s = 0.02;\n    float _h = s*(length(pt)-EARTH_RADIUS);\n    if(_h<0.)\n        return vec3(0., 1., 0.);\n    float odr= exp(-_h/hr)*dist, odm = exp(-_h/hm)*dist;\n    float stepL = 300.;\n    \n    float itmin = -1.0;\n    float itmax = -1.0;\n    d = IntersectSphere(pt, L, vec3(0.), ATMOSPHERE_RADIUS, itmin, itmax);\n    if(d<0.)\n        return vec3(0., 1., 0.);\n    stepL = max(0., max(itmin, itmax))*0.25;\n    \n    for(int i = 0;i<4;++i)\n    {\n        pt += L*stepL;\n        float h = s*(length(pt)-EARTH_RADIUS);\n        odr += exp(-h/hr)*stepL;\n        odm += exp(-h/hm)*stepL;\n    }\n\n    vec3 attenuation = exp(-(betaR * odr + betaM * 1.1 * odm));\n    vec3 sumR = odr * attenuation;\n    vec3 sumM = odm * attenuation;\n    return intensity * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\n// From http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 getSkyLight(vec3 ro, vec3 rd, vec3 L, float Li, vec3 betaR, vec3 betaM, out vec3 miecolor)\n{\n    vec3 light = vec3(0.0);\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERE_RADIUS, tmin, tmax);\n    if(d<0.)\n        return vec3(1., 0., 1.);\n    vec3 Pa = ro+rd*tmax;\n    /*if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);*/\n    float RdotL = max(0., dot(rd, L));\n    float tCurrent = 0.0;\n    float segL = tmax/16.0;\n    /*if(d>0.0)\n        segL = (tmax-tmin)/16.0;*/\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 7994.0; // 7994\n    float hm = SKY_MIE_HEIGHT; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation has an error with the first terms in the equation\n    /*float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );*/\n    // investigate, from scratch a pixel, why does the one up's bad ?\n    float phaseM = 3.f / (8.f * 3.14) * ((1.f - g * g) * (1.f + RdotL * RdotL)) / ((2.f + g * g) * pow(1.f + g * g - 2.f * g * RdotL, 1.5f));\n\n    float opticalDepthM = 0.0;\n    float cloudScat = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        bool ended = true;\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTH_RADIUS;\n        //if(h<0.)\n        //    break;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERE_RADIUS, tlmin, tlmax);\n        if(dl>0.)\n        {\n            float segLLight = tlmax/8.0;\n            float tCurrentLight = 0.0;\n            float opticalDepthLightR = 0.0;\n            float opticalDepthLightM = 0.0;\n            for (int j = 0; j < 8 && ended; ++j)\n            {\n                vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n                float hLight = length(samplePositionLight) - EARTH_RADIUS;\n                if (hLight < 0.0)\n                {\n                    ended = false;\n                    break;\n                }\n                opticalDepthLightR += exp(-hLight / hr) * segLLight;\n                opticalDepthLightM += exp(-hLight / hm) * segLLight;\n                tCurrentLight += segLLight;\n            }\n            if (ended)\n            {\n                vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n                vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n                sumR += _hr * attenuation;\n                sumM += _hm * attenuation;\n            }\n        }\n        tCurrent += segL;\n    }\n    vec3 mie = sumM * phaseM * betaM;\n    miecolor = Li * mie;\n    return Li * (sumR * phaseR * betaR + mie);\n}\n\n/***************************\n * Scene rendering\n ***************************/\n\nvec3 getSkyCoord(vec3 ro, vec3 rd)\n{\n    float tmin = -1.0, tmax = -1.0;\n    float d = IntersectSphere(\n        ro+vec3(0.0, EARTH_RADIUS, 0.0), rd, EARTHPOS,\n        ATMOSPHERE_RADIUS,\n        tmin, tmax);\n    return ro+rd*tmin;\n}\n\nfloat getSourceLightColor(vec3 _ro, vec3 _rd, vec3 _Lo, float _Si, float _f)\n{\n    float RdotL = max(0., dot(_rd, normalize(_Lo)));\n    float sunGrad = remap01(pow(RdotL, 4096.), .0, .4);\n    sunGrad += .2*pow(RdotL, _f*256.0);\n    return clamp(sunGrad, 0., 1.);\n}\n\nfloat getSourceLightColor2(vec3 _Ln, vec3 _Ld, float _f)\n{\n    float RdotL = max(0., dot(_Ln, _Ld));\n    float sunGrad = remap01(pow(max(0., RdotL), 4096.), 0., .4);\n    sunGrad += .2*pow(RdotL, _f*256.0);\n    return clamp(sunGrad, 0., 1.);\n}\n\nvec3 getSkyColorForPhase(vec3 ro, vec3 rd, vec3 Los, vec3 Lom, vec3 L, float Li, float starsQuality, float solarPhase, float t, out vec3 mieColor)\n{\n    float daynight = solarPhase;\n    vec3 betaR = mix(\n        \t\t\tvec3(0.1e-6, 0.2e-6, 0.5e-6),\n        \t\t\tvec3(5.5e-6, 13.0e-6, 22.4e-6),// DAY\n        \t\t\tdaynight);\n    vec3 betaM = mix(\n                    vec3(5e-6),\n        \t\t\tvec3(21e-6),\n        daynight);\n    vec3 color = vec3(0.0);\n    \n    color = getSkyLight(ro+vec3(0.0, EARTH_RADIUS, 0.0), rd, L, mix(.01*Li, Li, daynight), betaR, betaM, mieColor);\n    // stars\n    vec3 Psky = getSkyCoord(ro, rd);\n    float sN = gaussianNoise3D(rd*120.0);\n    float sunTurn = dot(normalize(Los-vec3(0., EARTH_RADIUS, 0.)), vec3(0., 1., 0.));\n    float starFactor = 1.-remap01(sunTurn, -0.5, .1);\n    color += starFactor*starFactor*vec3(max(0.0, min(1.0,sN-0.95))*10.0);\n\n    float sunGrad = 0.0;\n    float moonGrad = 0.0;\n    {\n        vec3 skyLN = normalize(Psky-ro);\n        moonGrad = getSourceLightColor2(skyLN, -normalize(Lom-(ro+vec3(0.0, EARTH_RADIUS, 0.0))), 1.);\n        rd.x += pow(1.-abs(dot(L,vec3(0., 1., 0.))), 4.)*.1*exp(-length(rd.xy)*8.)*(sin(3.14*128.*rd.y+t));\n        sunGrad = getSourceLightColor2(skyLN, -L, 16.);\n        \n        moonGrad *= 1.-clamp(dot(normalize(Los), normalize(Lom)), 0., 1.);\n    }\n\n    color *= max(0., 1.-sunGrad);\n    color += mieColor*Li*sunGrad;\n    \n    color *= 1.-moonGrad;\n    color += vec3(mix(MOONINTENSITY, 1., daynight))*moonGrad;\n\n    return color;\n}\n\nvec3 getSkyColor(vec3 ro, vec3 rd, vec3 Los, vec3 Lom, vec3 L, float Li, float starsQuality, float solarPhase, float t, out vec3 mieColor)\n{\n    return getSkyColorForPhase(ro, rd, Los, Lom, L, Li, starsQuality, solarPhase, t, mieColor);\n}\n\nfloat CloudBaseDensityClassic(vec3 _p, float _bot, float _top, vec3 _wd)\n{\n    float py = remap01(_p.y, _bot, _top);\n    float fb = 1./abs(_top-_bot);\n    float base = remap01(fbm_hash((_p.xz)*fb+_wd.xz), .3, 1.0);\n        base -= .35*remap01(fbm_hash((4.5*_p.zx)*fb+_wd.xz), .0, 1.0);\n    \n    base = smoothstep(0., 1., base);\n    \n    return clamp(base, 0., 1.);\n}\n\nfloat CloudBaseDensitySimple(vec3 _p, float _bot, float _top, vec3 _wd)\n{\n    float py = remap01(_p.y, _bot, _top);\n    float fb = 1./abs(_top-_bot);\n    float base = remap01(fbm_hash((3.5*_p.zx)*fb+_wd.xz), .2, 1.0);\n    base = smoothstep(0., 1., pow(base, 2.5));\n    \n    return clamp(base, 0., 1.);\n}\n\n#define CloudBaseDensity CloudBaseDensitySimple\n\nfloat ComputeLightParams(float t, vec2 _mv, out vec3 Lo, out vec3 Los, out vec3 Lom, out vec3 Ld, out float Li)\n{\n    Lom = normalize(vec3(1.6, 0.4, 0.4)) *MOONDIST;\n    #ifdef DAYANDNIGHT\n    float time = -TIME(t);\n    float suny = sin(time);\n    float solarPhase = remap01(suny, -1., 1.);\n    \n    Los = normalize(vec3(cos(time), suny, cos(time)))*SUNDIST;\n\n    Lo = mix(Lom, Los, step(.4, solarPhase));\n    Ld = normalize(Lo-EARTHPOS);\n    Li = mix(MOONINTENSITY, SUNINTENSITY, step(.4, solarPhase));\n    #else\n        float blendLd = 0.;\n        #if defined(SUNSET)\n        float sTime = remap(fract(-0.5*TIME(t)), 0., 1., -0.2, 1.);\n        Lo = normalize(vec3(1., sTime, 1.))*SUNDIST;\n        blendLd = remap01(dot(Ld, vec3(0., 1., 0.)), -.8, .2);\n        #else\n            #if defined(MOUSESUN)\n            if(length(_mv.xy)<0.1)\n            {\n                float sTime = remap(fract(-0.5*TIME(t)), 0., 1., -0.2, 1.);\n                Lo = normalize(vec3(1., sTime, 1.))*SUNDIST;\n                blendLd = remap01(dot(Ld, vec3(0., 1., 0.)), -.8, .2);\n            }\n            else\n            {\n               float x = 3.14*(-1.+2.*_mv.x);\n                Lo = normalize(vec3(cos(x), 2.*(-1.+2.*_mv.y), sin(x)))*SUNDIST;\n                blendLd = remap01(_mv.y, -1., 1.);\n            }\n            #else\n            Lo = LIGHTPOS;\n            blendLd = remap01(dot(Ld, vec3(0., 1., 0.)), -.8, .2);\n            #endif\n        #endif\n        float solarPhase = step(.7, blendLd);\n        Los = Lo;\n        Ld = mix(\n            normalize(Lom-TO_EARTH_COORD(CAMPOS)),\n            normalize(Los-TO_EARTH_COORD(CAMPOS)),\n            solarPhase\n        );\n        Li = mix(MOONINTENSITY, SUNINTENSITY, solarPhase);\n    #endif\n    return solarPhase;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid SetupCamera(in vec2 _iFragCoord, in vec2 _iRes, in vec2 _iMouseRes, in vec4 _iMouse, out vec2 uv, out vec3 ro, out vec3 rd, out mat3 ca)\n{\n    uv = _iFragCoord.xy /_iRes.xy;\n    float irw = _iRes.x/_iRes.y;\n    vec2 pixel = -1.0 + 2.0*uv;\n    pixel.x *= irw;\n\n    vec2 mv = -1.0 + 2.0*_iMouse.xy/_iMouseRes.xy;\n    mv.x *= irw;\n\n    ro = CAMPOS;\n\n    vec3 target = ro+vec3(1., .1, 1.);\n\n    ca = setCamera(ro, target, normalize(vec3(.0, 1., .0)));\n    rd = normalize(ca*normalize(vec3(pixel.xy, CAM_DEPTH)));\n}\n\nvec2 CameraToScreen(in mat3 ca, in vec3 rd, in vec2 res)\n{\n    vec3 rep = inverse(ca)*rd;\n    vec2 pixel = (rep.xy/rep.z)*CAM_DEPTH;\n    return 0.5*(1.+pixel*vec2(res.y/res.x, 1.)); // scale uniform\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n/************************\n * RENDERING\n ************************/\n\nfloat fresnel(vec3 I, vec3 N, float B, float S, float E)\n{\n    return B+S*pow(max(0.0, 1.0+dot(I,N)),E);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / max(0.0001, 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.01);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.01);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.01);\n  float VdotH = max(dot(viewDirection, H), 0.0001);\n  float LdotH = max(dot(lightDirection, H), 0.0001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(roughness, NdotH);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)*max(0.0, dot(N, L))+Ks*specularColor*spec) * Oi;\n}\n\nvec4 materialColor(vec2 rm, sampler2D albedoTex, sampler2D aoTex, vec3 P, vec3 I, vec3 N, vec3 L, float K, vec3 atmosphericColor, float solarPhase)\n{\n    vec4 color = vec4(0., 0., 0., 1.);\n    if(rm.y==TYPE_BOAT)\n    {\n        vec3 Nb = normalize(BOAT_POS-P);\n        return max(0.01, dot(L, vec3(0., 1., 0.)))*vec4(mix(\n                vec3(pow(max(.2, dot(Nb.xz, L.xz)), 1.5), 0., 0.),\n                mix(vec3(1.), vec3(0.639,0.627,0.482), step(1.15, P.y-I.y)),\n                step(.5, P.y-I.y)\n                )*pow(max(0.2, dot(-Nb, L)), 1.5),\n                clamp(step(1.15, P.y-I.y), 0., 1.)\n        );\n    }\n    float ao = rm.y==TYPE_FLOOR?texture(aoTex, P.xz*FLOOR_TEXTURE_FREQ).r:1.;\n    vec3 diff = texture(albedoTex, P.xz*FLOOR_TEXTURE_FREQ).rgb;\n\n    float algae_mask = smoothstep(0., 1., max(0.0, texture(albedoTex, 0.01*P.xz).r)*(1.-remap01(P.y, -5., 3.)));\n\n    diff = mix(diff, COLORALGAE, algae_mask);\n    float roughness = mix(0.05, 0.8, algae_mask);\n    color.rgb = brdf(\n        .1*K, // Ks\n        K, // Kd\n        roughness, // roughness\n        1.0, // opacity\n        atmosphericColor,//vec3(1.0), // specular color\n        diff, // diffuse color\n        I, // I\n        N, // N\n        L // L\n    )*ao;\n    return color;\n}\n\nvec4 rendering(vec3 ro, vec3 rd, vec2 rm, vec3 n, vec3 Ld, vec3 Lo, vec3 Los, vec3 Lom, float Li, vec2 uv, float solarPhase) {\n    vec3 p = ro+rd*rm.x;\n    vec4 color = vec4(0., 0., 0., 1.);\n    vec3 mieColor;\n    color.rgb = getSkyColor(ro, rd, Los, Lom, Ld, Li, 1.0, solarPhase, iTime, mieColor);\n\n    if(rm.x>CAM_NEAR && rm.x<CAM_FAR)\n    {\n        float K = mix(0.4, 1.0, solarPhase);\n        float df = (CAM_FAR-rm.x)/(CAM_FAR-CAM_NEAR);\n        vec3 N = normalize(n);\n        vec3 ambientColor = mieColor;\n        vec4 mc = materialColor(rm, iChannel2, iChannel1, p, rd, N, Ld, K, ambientColor, solarPhase);\n        float blendFar = remap01(rm.x, CAM_NEAR, CAM_FAR);\n        color.rgb = mix(\n            mc.rgb,\n            color.rgb,\n            blendFar);\n        color.a = mc.a;\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    vec3 ro, rd;\n    mat3 ca;\n    SetupCamera(fragCoord, iResolution.xy, iResolution.xy, iMouse, uv, ro, rd, ca);\n    \n    vec4 gbuffer = texture(iChannel0, uv);\n    \n    // updating solar phase\n    vec3 Lo, Los, Lom, Ld;\n    float Li;\n    vec2 mv = iMouse.xy/iResolution.xy;\n    float solarPhase = ComputeLightParams(iTime, mv, Lo, Los, Lom, Ld, Li);\n    \n    // 0 full night, 1 full day\n    fragColor.rgb = rendering(ro, rd, gbuffer.xy, normal_unpack(gbuffer.zw), Ld, Lo, Los, Lom, Li, uv, solarPhase).rgb;\n    fragColor.a = gbuffer.x;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\nfloat phaseHG(float g, float cosTeta)\n{\n\treturn (1.-g*g)/(4.*3.14*pow(1.+g*g-2.*g*cosTeta, 1.5));\n}\n\nfloat heightSignal(float a, float x, float h)\n{\n    return (x-a)*(x-a-h)*(-4./(h*h));\n}\n\nfloat depthToEnergy(float _depth)\n{\n    return clamp(\n        /*Beer's Law*/ exp(-_depth * CLOUD_ENERGY_ABSORBTION)\n        * /* Powder's */(1.-exp(-2. * CLOUD_ENERGY_ABSORBTION * _depth))\n    , 0., 1.);\n}\n\nfloat cloudDensityClassic(vec3 _p, vec2 uv, float bot, float top, float t)\n{\n    float py = remap01(_p.y, bot, top);\n    float fb = 1./abs(top-bot);\n    vec3 wd = vec3(MainWindDir.x, 0., MainWindDir.y)*t;\n\n    float basea = remap01(texture(iChannel2, 0.1*fb*(_p+wd)).r, .2, 1.);\n    float baseb = remap01(CloudBaseDensity(_p, bot, top, wd), .0, 1.);\n    float base = basea * baseb;\n    \n    float hs = clamp(heightSignal(-0.0, max(0., py-pow(basea, 8.)), 0.4), 0., 1.);\n    \n    return exp(-.001*_p.z)*clamp(\n        (\n            base\n            -base*random(0.001*fb*_p)\n            -base*3.0*mix(0., max(0., voronoi2D(4.*_p.xz*fb)), hs)\n            -.01*fbm_hash(uv*40.1+1.*wd.xy)\n        )\n        *hs\n    , 0., 1.);\n}\n\nfloat cloudDensitySimple(vec3 _p, vec2 uv, float bot, float top, float t)\n{\n    float py = remap01(_p.y, bot, top);\n    float fb = 1./abs(top-bot);\n    vec3 wd = vec3(MainWindDir.x, 0., MainWindDir.y)*t;\n\n    float basea = remap01(texture(iChannel2, 0.1*fb*(_p+wd)).r, .2, 1.);\n    float baseb = remap01(CloudBaseDensity(_p, bot, top, wd), .0, 1.);\n    float base = basea * baseb;\n    \n    float hs = clamp(heightSignal(0.0-.1*baseb, max(0., py-pow(basea, 8.)), 0.2), 0., 1.);\n    \n    return exp(-.0001*_p.z)*clamp(\n        (\n            base\n            -base*0.8*voronoi2D(16.*fb*_p.xz)\n            -base*0.1*fbm_hash(4.*fb*_p.xz)\n        )\n        *hs\n        -.01*fbm_hash(uv*80.1+1.*wd.xy)\n    , 0., 1.);\n}\n\nfloat cloudDensitySimple2(vec3 _p, vec2 uv, float bot, float top, float t)\n{\n    float py = remap01(_p.y, bot, top);\n    float fb = 1./abs(top-bot);\n    vec3 wd = vec3(MainWindDir.x, 0., MainWindDir.y)*t;\n\n    float basea = remap01(texture(iChannel2, 0.1*fb*(_p+wd)).r, .4, 1.);\n    float baseb = remap01(CloudBaseDensity(_p, bot, top, wd), .0, 1.);\n    float base = basea * baseb;\n    float mapc = remap01(baseb, .05, .5);\n    float hs = clamp(heightSignal(0.0-.1*mapc, py, 0.2+.4*mapc), 0., 1.);\n    \n    return clamp(\n        (\n            base+.01*(1.-voronoi3D(0.01*fb*_p))\n        )\n        *hs\n        -.01*fbm_hash(uv*80.1+1.*wd.xy)\n    , 0., 1.);\n}\n\n#define cloudDensity cloudDensitySimple2\n\nvec4 clouds(vec3 ro, vec3 rd, mat3 camS, vec3 L, vec3 Lo, float Li, vec2 uv, float scenex, float bot, float top, float solarPhase, vec3 blueNoise, out float zOut)\n{\n    vec4 sl = vec4(vec3(0.), 1.);\n    float nearPlane = dot(ro - vec3(0., bot, 0.), vec3(0., 1., 0.)) / dot(vec3(0., 1., 0.), -rd);\n    float farPlane = dot(ro - vec3(0., top, 0.), vec3(0., 1., 0.)) / dot(vec3(0., 1., 0.), -rd);\n    float minPlane = min(nearPlane, farPlane);\n    farPlane = max(400., max(nearPlane, farPlane));\n    nearPlane = minPlane;\n    \n    zOut = nearPlane;\n    float Lim = Li*10.;\n    float time = TIMEC(iTime);\n    if(nearPlane>0. && farPlane>nearPlane)\n    {\n        float ambs = max(0.08, dot(L, vec3(0., 1., 0.)));\n        vec3 right = camS*vec3(1., 0., 0.);\n        float ambAmount = 1.;//max(0.1, dot(L, vec3(0., 1., 0.)));\n        \n        //float maxLength = abs(farPlane-nearPlane);\n        float st=10.;//maxLength/float(CLOUD_MAIN_STEPS); // 10.\n        // += st computing st does not seem reliable\n        // going with fixed st instead\n        // this is due to the larger values of st with this method\n        // with larger values, the dithering takes more importance\n        // and begins to be noticeable\n        \n        float bnl = 0.;\n        //bnl = random(uv+.001*time);\n        bnl += blueNoise.r;\n        float t = nearPlane+2.0*st*bnl;\n        \n        vec3 wd = vec3(MainWindDir.x, 0., MainWindDir.y)*time;\n        float fb = 1./(top-bot);\n        \n        vec3 betaR = mix(\n                        vec3(0.1e-6, 0.2e-6, 0.5e-6),\n                        vec3(5.5e-6, 13.0e-6, 22.4e-6),// DAY\n                        solarPhase);\n        vec3 betaM = mix(vec3(1e-7), vec3(21e-6), solarPhase);\n\n        vec3 dump;\n        #if !defined(CLOUD_HD_LIGHTING)\n        vec3 scat = getSkyLight(TO_EARTH_COORD(ro), normalize(rd+2.*L)/* grasping more light, simulating through cloud light scattering */, L, Lim, betaR, betaM, dump);\n        #endif\n                       \n        float cosTeta = dot(rd, L);\n\n        // https://www.desmos.com/calculator/tnwdjjxxtb\n        const float eccentricity = .6;\n        const float silver_spread = 1.1;\n        const float silver_intensity = 2.;\n        float hgf = max(phaseHG(eccentricity, cosTeta), silver_intensity * phaseHG(.99-silver_spread, cosTeta));\n                        \n        for(int i = 0;i<CLOUD_MAIN_STEPS;++i)\n        {\n            vec3 p = ro+rd*t;\n            vec3 Lx = normalize(Lo-TO_EARTH_COORD(p));\n            float den = cloudDensity(p, uv, bot, top, time);\n            if(den>0.01)\n            {\n                float stx = .5*st;\n                float d = stx;\n                float shadow = 1.;\n                for(int j = 0;j < CLOUD_LIGHT_STEPS; ++j)\n                {\n                    vec3 pm = p+Lx*d;\n                    vec2 uvm = uv+Lx.xy*d;\n\n                    float denm = cloudDensity(pm, uvm, bot, top, time);\n                    if(denm>0.01)\n                    {\n                        shadow *= depthToEnergy(denm*stx);\n                    }\n                    d+= stx;\n                }\n                float ext = depthToEnergy(st*den);\n                float heightAmbient = max(.01, remap01(p.y, bot+5., top));\n                #if defined(CLOUD_HD_LIGHTING)\n                vec3 Lfx = normalize(rd+2.*Lx);//normalize((1.-rd.y)*Lx+rd.y*rd);\n                vec3 scat2 = getSkyLight(TO_EARTH_COORD(p), Lfx/*normalize(rd+2.*Lx)/* grasping more light, simulating through cloud light scattering */, Lx, Lim, betaR, betaM, dump);\n                vec3 amb = Lim*ambs*scat2*heightAmbient;\n\n                vec3 lum = (scat2*shadow+amb)*den*ext*hgf;\n                #else\n                vec3 amb = Lim*ambs*scat*heightAmbient;\n                vec3 lum = (scat*shadow+amb)*den*ext*hgf;\n                #endif\n                sl.rgb += sl.a*(lum-ext*lum)/den;\n                sl.a *= ext;\n            }\n            t+=st;\n        }\n\n        // fake high clouds\n        vec3 pfc = .03*(ro+rd*farPlane);\n        pfc.xz /=pfc.y;\n        pfc.xz -= MainWindDir*.1*time;\n        \n        #if defined(CLOUD_HD_LIGHTING)\n            for(int i = 0;i < 4; ++i)\n            {\n                float fakeCloudsDen = remap01(fbm_hash(4.-pfc.xz), .2, 0.8)*remap01(fbm_hash(16.*pfc.xz), -1.0, 1.);\n                if(fakeCloudsDen>0.01)\n                {\n                    vec3 Lx = normalize(Lo-TO_EARTH_COORD(pfc));\n                    float fakeExt = depthToEnergy(0.2*fakeCloudsDen);\n                    vec3 Lfx = normalize((1.-rd.y)*Lx+rd.y*rd);\n                    vec3 scat2 = getSkyLight(TO_EARTH_COORD(pfc), Lfx/*normalize(rd+2.*Lx)/* grasping more light, simulating through cloud light scattering */, Lx, Lim, betaR, betaM, dump);\n                    vec3 fakeRad = (scat2+.2*Lim*ambs)*fakeCloudsDen*fakeExt*hgf;\n                    sl.rgb += sl.a*(fakeRad-fakeExt*fakeRad)/fakeCloudsDen;\n                    sl.a *= 1.-fakeExt;\n                    // end fake high clouds\n                }\n               pfc+=rd/rd.y*0.5;\n            }\n        #else\n            float fakeCloudsDen = remap01(fbm_hash(4.-pfc.xz), .2, 0.8)*remap01(fbm_hash(16.*pfc.xz), -1.0, 1.);\n            if(fakeCloudsDen>0.01)\n            {\n                float fakeExt = depthToEnergy(fakeCloudsDen);\n                vec3 fakeRad = (scat+.2*Lim*ambs)*fakeCloudsDen*fakeExt*hgf;\n                sl.rgb += sl.a*(fakeRad-fakeExt*fakeRad)/fakeCloudsDen;\n                sl.a *= 1.-fakeExt;\n                // end fake high clouds\n            }\n        #endif\n    \n        sl.a = smoothstep(0., 1., clamp(sl.a+remap01(nearPlane, 50., 800.), 0., 1.));\n        sl.a = smoothstep(0., 1., sl.a);\n        sl.a = pow(sl.a, 8.);\n    }\n    return sl;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = CLOUD_RT_SCALE*iResolution.xy;\n    if(fragCoord.x>res.x || fragCoord.y>res.y)\n        return;\n\n    vec2 uv;\n    vec3 ro, rd;\n    mat3 ca;\n    SetupCamera(fragCoord, res, iResolution.xy, iMouse, uv, ro, rd, ca);\n    \n    vec4 gbuffer = texture(iChannel0, uv);\n    \n    // updating solar phase\n    vec3 Lo, Los, Lom, Ld;\n    float Li;\n    vec2 mv = iMouse.xy/iResolution.xy;\n    float solarPhase = ComputeLightParams(iTime, mv, Lo, Los, Lom, Ld, Li);\n\n    vec2 cs = vec2(cos(iTime), sin(iTime));\n    mat2 rot = mat2(cs.x, -cs.y, cs.y, cs.x);\n    vec3 blueNoise = texture(iChannel3, rot*fragCoord.xy/iChannelResolution[3].xy).rgb;\n    const float minCloudLayerHeight = CLOUD_START_HEIGHT;\n    const float maxCloudLayerHeight = CLOUD_START_HEIGHT+CLOUD_HEIGHT;\n    float zOut = -1.;\n    fragColor = clouds(ro, rd, ca, Ld, Lo, Li, uv, gbuffer.x, minCloudLayerHeight, maxCloudLayerHeight, solarPhase, blueNoise, zOut);\n    if(zOut>0.)\n    {\n        float tn = 0.001*iTime;\n        float alphaBlend = mix(1., 0.02, min(1., iTime)); // 0.01\n        #if CLOUD_PACKING\n        vec4 lastFrame = textureLod(iChannel1, CLOUD_RT_SCALE*uv, 0.0);\n        vec2 lastFramePackedData = floatToVec2(lastFrame.a);\n        fragColor.rgb = mix(lastFrame.rgb, fragColor.rgb, alphaBlend);\n        lastFramePackedData.x = clamp(mix(lastFramePackedData.x, fragColor.a, alphaBlend), 0., 1.);\n        lastFramePackedData.y = zOut;\n        fragColor.a = vec2ToFloat(lastFramePackedData);\n        #else\n        fragColor = mix(textureLod(iChannel1, CLOUD_RT_SCALE*uv, 0.0), fragColor, alphaBlend);\n        #endif\n        \n        fragColor.rgb = clamp(fragColor.rgb, 0., Li);\n    }\n    #if CLOUD_PACKING\n    else\n    {\n        fragColor.a = vec2ToFloat(vec2(clamp(fragColor.a, 0., 1.), 0.));\n    }\n    #endif\n    fragColor.a = clamp(fragColor.a, 0., 1.);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n// GERSTNER FROM https://www.shadertoy.com/view/llyczd\n\n#define VERTICAL_OFFSET 10.0\n// apply rotations to the wind based on time\n#define WINDROLL\n#define WINDROLL_PER_WAVE\n#define NWAVES 4\n#define AMP_EXTINCTION_P 80.1\n#define NORMAL_EXTINCTION_P 80.1\n#define MIN_NORMAL_EXTINCTION 0.05\n\n#define EXTINCTION(E, d, mini) mini+(smoothstep(1.0, 0.0, min(1.0, d/E)))\n    \n#define DETAILS_SEED_SCALE 4.0\n\n// amp 0.1\n#define AMP_ATT 0.1\n#define CHOPINESS_ATT 0.8\n#define SPEED_ATT 0.8\n\nfloat MainAmp = 2.5;\n\n// 22\n\nfloat dfuncdetails(vec3 p, float t)\n{\n    float depth = 0.0;\n    vec2 seed = DETAILS_SEED_SCALE*p.xz+MainWindDir*t;\n    depth = clamp(fbm_hash(seed), 0.0, 1.0);\n    return depth;\n}\n\nfloat mapdetails(vec3 p, float t)\n{\n    return dfuncdetails(p, t)+dfuncdetails(p, 0.5*t);\n}\n\n#define DISTATTENUATE(x, E) (1.0-x/E)\n\n//#define USE_GERSTNER_WAVES\n\n#if defined(USE_GERSTNER_WAVES)\nstruct sGerstnerParams\n{\n    float freq;\n    float steepness;\n    float speed;\n    float waveDiv;\n    float amp;\n    vec2 wind;\n};\n\nsGerstnerParams BlendGParams(sGerstnerParams p1, sGerstnerParams p2, float a)\n{\n    p1.freq = mix(p1.freq, p2.freq, a);\n    p1.steepness = mix(p1.steepness, p2.steepness, a);\n    p1.speed = mix(p1.speed, p2.speed, a);\n    p1.waveDiv = mix(p1.waveDiv, p2.waveDiv, a);\n    p1.amp = mix(p1.amp, p2.amp, a);\n    p1.wind = mix(p1.wind, p2.wind, a);\n    return p1;\n}\n\n//  inspired from https://80.lv/articles/tutorial-ocean-shader-with-gerstner-waves/\nfloat gerstner(\n    vec3 p,\n    vec2 WindDir,\n    float wD,\n    float a,\n    float waveFreq,\n    float steepness,\n\tfloat speedfactor,\n\tfloat t)\n{\n    p = p - vec3(100., 0., 100.);\n    float depthz = 0.0, depthx = 0.0, depthy = 0.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        float WaveLength = PI2 / wD;\n        \n        float speed = WaveLength * speedfactor;\n        \n        float nWaves = waveFreq * PI2;\n        float Amplitude = a;\n        \n        float Time = t * speed;\n        a *= .8;\n        speed *= 1.1;\n        waveFreq *= 2.01;\n        \n        float Wave = dot(normalize(WindDir), (p.xz)) * WaveLength + Time;\n        vec2 csW = vec2(cos(Wave), sin(Wave));\n\n        float Qi = steepness/(nWaves * Amplitude * WaveLength);\n        float QiA = Qi*Amplitude;\n        \n        depthz = QiA*WindDir.y*csW.x;\n        depthx = QiA*WindDir.x*csW.x;\n        depthy = Amplitude*csW.y;\n    }\n    return length(vec3(depthx, depthy, depthz));\n}\n\nfloat dfunc(vec3 p, sGerstnerParams params, float t)\n{\n    float freq = params.freq;\n    float steepness = params.steepness;\n    float speed = params.speed;\n    float waveDiv = params.waveDiv;\n    float depth = p.y;\n    vec2 wind = params.wind;\n    float amp = params.amp;\n    float s = -1.0;\n\n    for(int i = 0; i < NWAVES; ++i)\n    {\n        depth += gerstner(p, wind, waveDiv, amp, freq, steepness, speed, t)/float(NWAVES);\n        speed *= SPEED_ATT;\n        steepness *= CHOPINESS_ATT;\n        amp *= AMP_ATT;\n        #ifdef WINDROLL_PER_WAVE\n        wind = mat2(0.4, 0.8, -0.7, 0.2)*wind;\n        #endif\n        //nWaves *= 2.0;\n    }\n    return depth;\n}\n\nfloat mapWater(vec3 p, float _nScreenDepth, float t)\n{\n    float tp = fract(t*0.8);\n    vec2 dirp = vec2(cos(tp), sin(tp));\n    vec2 windDir = MainWindDir;//*sign(t)*vec2(cos(t), sin(t));\n    sGerstnerParams paramsHuge1;\n    paramsHuge1.freq = 2.0;\n    paramsHuge1.steepness = 5.0; // 38.\n    paramsHuge1.speed = 0.8; // .8\n    paramsHuge1.waveDiv = 2.0;\n    paramsHuge1.wind = windDir;\n    paramsHuge1.amp = MainAmp;\n    \n    sGerstnerParams paramsHuge2;\n    paramsHuge2.freq = 2.0;\n    paramsHuge2.steepness = 5.0;\n    paramsHuge2.speed = 0.8;\n    paramsHuge2.waveDiv = 2.0;\n    paramsHuge2.wind =  windDir;\n    paramsHuge2.amp = MainAmp;\n    \n    sGerstnerParams params;\n    params.freq = 8.0;\n    params.steepness = 1.0; // 20.\n    params.speed = 1.8; // 1.8\n    params.waveDiv = 4.2;\n    params.wind = vec2(sin(1.57), cos(1.57));\n    params.amp = MainAmp;\n    \n    sGerstnerParams params2;\n    params2.freq = 8.0;\n    params2.steepness = 1.0;\n    params2.speed = 1.8;\n    params2.waveDiv = 4.0;\n    params2.wind = -vec2(sin(1.57), cos(1.57));\n    params2.amp = MainAmp;\n    \n    //return dfunc(p, BlendGParams(paramsAgitated2, params2, 0.5), t);\n    \n    params = BlendGParams(paramsHuge1, params, 0.2);\n    params2 = BlendGParams(paramsHuge2, params2, 0.2);\n    \n    float det = mapdetails(p, t);\n    p *= .5;\n    //t *= .4;\n    float ctide = clamp(sin(.2*(clamp(iTime, -3.14, 3.14)+1.57)), -1., 1.);\n    float t2 = t * ctide;\n    \n    return p.y //p.y-1.0+\n    #if defined(USE_RAYMARCHED_WATER)\n    +2.-mix(\n        dfunc(p, params, t),\n        dfunc(p, params2, t),\n    .5)\n    *(1.-remap01(/*dw*/2.*length(p.z), 10., 80.))\n    #endif\n    -.05*det;\n}\n// END GERSTNER FROM https://www.shadertoy.com/view/llyczd\n#endif\n\nfloat mapWaterSimple(vec3 _p, float _nScreenDepth, float _t)\n{\n    vec2 windDir = MainWindDir*sign(_t);\n    float steepness = 8.;\n    float fq = 0.5;\n    float depth = _p.y+0.8;\n    float amp = 4.*mix(0.01, .05, _nScreenDepth);\n    #define F depth += amp*(pow(sin(fq*_p.z+windDir.y*_t), steepness)+max(0., 1.*cos(.5*_p.x+windDir.x*_t)));\n    F\n    fq *= 1.2;\n    amp *= .9;\n    F\n    fq *= 1.2;\n    amp *= .9;\n    F\n    #undef F\n    \n    return depth+.5*mapdetails(_p, _t);\n}\n\nfloat mapWaterSin(vec3 _p, float _nScreenDepth, float _t)\n{\n    float det = mapdetails(_p, _t);\n    float z = _p.z;\n    _p.xz += MainWindDir*_t;\n    float bw = max(0., 3.-length(.2*z))*(1.5+sin(2.*(.8*_p.z+.3*_p.x)));\n    float distanceAttenuation = _nScreenDepth;\n    distanceAttenuation *= 1.-remap01(length(z), 10., 40.);\n    float alphaBlend = clamp(fbm_hash(0.15*(_p.xz+10.+_t)), 0., 1.);\n    alphaBlend = alphaBlend*alphaBlend*(3.-2.*alphaBlend);\n    alphaBlend *= alphaBlend*alphaBlend*(3.-2.*alphaBlend);\n    \n    return _p.y-mix(0., .8*bw*distanceAttenuation, alphaBlend)-.05*det;\n}\n\n#if defined(USE_GERSTNER_WAVES)\n#define MAPWATERFUNC mapWater\n#else\n#define MAPWATERFUNC mapWaterSin\n#endif\n\n\nvec4 normalWater(vec3 p, float _nScreenDepth, float t, float e)\n{\n    vec4 N;\n    N.w = MAPWATERFUNC(p, _nScreenDepth, t);\n    N.x = MAPWATERFUNC(p+vec3(e, 0.0, 0.0), _nScreenDepth, t)-N.w;\n    N.z = MAPWATERFUNC(p+vec3(0.0, 0.0, e), _nScreenDepth, t)-N.w;\n    N.y = e;\n    return vec4(normalize(N.xyz), N.w);\n}\n\nfloat phaseHG(float g, float cosTeta)\n{\n\treturn (1.-g*g)/(4.*3.14*pow(1.+g*g-2.*g*cosTeta, 1.5));\n}\n\nfloat pow2(float _x) { return _x*_x; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    vec3 ro, rd;\n    mat3 ca;\n    SetupCamera(fragCoord, iResolution.xy, iResolution.xy, iMouse, uv, ro, rd, ca);\n    \n    vec4 gbuffer = texture(iChannel0, uv);\n    vec4 cbuffer = texture(iChannel1, uv);\n    \n    // updating solar phase\n    vec3 Lo, Los, Lom, Ld;\n    float Li;\n    vec2 mv = iMouse.xy/iResolution.xy;\n    float solarPhase = ComputeLightParams(iTime, mv, Lo, Los, Lom, Ld, Li);\n\n    float Lt = max(0.01, dot(Ld, vec3(0., 1., 0.)));\n    \n    // 0 full night, 1 full day\n    vec3 color = cbuffer.rgb;\n    \n    // water pp\n    vec3 pscene = ro+rd*gbuffer.x;\n    vec3 nscene = normalize(normal_unpack(gbuffer.zw));\n    float stide = .5+sin(.2*iTime), ctide = .5+cos(.2*iTime);\n    #if defined(USE_RAYMARCHED_WATER)\n    float dw = CAM_NEAR;\n    for(int i = 0;i<60;++i)\n    {\n        vec3 pw = ro+rd*dw;\n        float dwi = MAPWATERFUNC(pw, (dw-CAM_NEAR)/(CAM_FAR-CAM_NEAR), iTime);\n        if(dwi<CAM_NEAR || dw>CAM_FAR)\n            break;\n        dw += .5*dwi;\n    }\n    float minHW = .5*(-1.0+stide);\n    #else\n    float dw = 100000.;\n    float minHW = 0.25*(-.5+stide);\n    #endif\n    float wPlaneDist = IntersectPlane(vec3(0., minHW, 0.), normalize(vec3(-.03, 1., -.03)), rd, ro);\n    dw = min(dw, wPlaneDist);\n    \n    vec3 mieColor = cbuffer.rgb;\n    float blendAlpha = 0.;\n   \n    if(dw<gbuffer.x)\n    {\n        vec3 pw = ro+rd*dw;\n        float depthDiff = max(0., gbuffer.x-dw);\n        float waterDepthDeep = remap01(depthDiff, 0.5, 4.5);\n        float waterDepthFoam = remap01(depthDiff, 0.1, 0.6);\n        float waterDepth = remap01(depthDiff, 0., 0.01);\n        float worldVertical = remap01(pw.y-pscene.y, 0., .5);\n        blendAlpha = remap01(waterDepth, 0., 1.);\n        \n        vec4 nwe = normalWater(pw, remap01(depthDiff, 1., 2.4), iTime, 0.001);\n        vec3 nw = nwe.xyz;\n        nw.z = -abs(nw.z);\n\n        float normAttFact = smoothstep(0., 1., 1.-remap01(wPlaneDist, 10., 50.));\n        nw = mix(vec3(0., 1., 0.), nw, normAttFact);\n \n        vec3 H = normalize(rd+Ld);\n\n        vec3 rdrf = mix(rd, refract(rd, nw, WATER_REFR_INDEX), waterDepth);\n        vec3 pu = pw+rdrf*waterDepth;\n\n        float F = clamp(0.06+0.94*pow(max(0., dot(-rd,nw)), 5.), 0.06, 1.);\n        vec2 rp = randomhash2D(uvec2(pw.xz));\n        vec3 reflcolor;\n \n        vec3 rNw = reflect(rd, nw);\n        vec2 yuvr = CameraToScreen(ca, rNw, iResolution.xy);\n        reflcolor.rgb = texture(iChannel1, yuvr).rgb;\n        vec3 algaeTint = vec3(0.0012,0.02,0.000);\n        if(dot(-rd, nw)>0.4)\n        {\n            vec3 dump;\n            vec3 betaR = mix(\n                            vec3(0.1e-6, 0.2e-6, 0.5e-6),\n                            vec3(5.5e-6, 13.0e-6, 22.4e-6),// DAY\n                            solarPhase);\n            vec3 betaM = mix(vec3(1e-7), vec3(21e-6), solarPhase);\n            reflcolor.rgb = algaeTint * getSkyLight(TO_EARTH_COORD(pw-rNw), rNw/* grasping more light, simulating through cloud light scattering */, Ld, Li, betaR, betaM, dump);\n        }\n\n        vec4 clouds = texture(iChannel3, CLOUD_RT_SCALE*yuvr);\n        clouds.a = max(0., mix(.7, 1., \n            #if CLOUD_PACKING\n            floatToVec2(clouds.a).x\n            #else\n            clouds.a\n            #endif\n        ));\n        clouds.a = clamp(clouds.a, 0., 1.);\n\n        reflcolor.rgb *= clouds.a;\n        reflcolor.rgb += (1.-clouds.a)*clouds.rgb;\n        // we force TYPE_FLOOR because when the depth is really close to the sea\n        // values get confusing near the shore.\n        vec4 backbuffer = texture(iChannel1, uv+0.05*(-1.+2.*fbm_hash(nw.xz)));\n      \n        float refrAlphaColor = remap01(depthDiff, 0.5, 20.5);\n        float refrAlphaBlend = remap01(depthDiff, 0.5, 5.5);\n        vec3 refrcolor = algaeTint*Li*backbuffer.rgb;\n        \n        vec3 wcolor = mix(refrcolor, reflcolor, F);\n        // Foam\n        vec2 w = -MainWindDir*0.001*iTime*(1.-waterDepthFoam);\n        float foam = pow(1.-texture(iChannel2, 0.5*(pw.xz+w+pw.y)).r, 4.);\n        foam *= (1.-waterDepthFoam)/*+abs(dot(nw.xz, MainWindDir))*/+(1.-pow(dot(nw, vec3(0., 1., 0.)), 2.));\n        foam = clamp(foam, 0., 1.)*exp(-1.5*waterDepthFoam);\n        float foamDetail = pow(1.-texture(iChannel2, 16.0*(pw.xz+w+pw.y)).r, 4.)*foam;\n        foam = clamp(foamDetail+foam, 0.0, 1.0);\n        wcolor = wcolor*(1.-foam)+2.*Lt*Li*foam;\n\n        float blendFar = clamp(pow(gbuffer.x/CAM_FAR, 1.), 0., 1.);\n        color = cbuffer.rgb * (1.- worldVertical);\n        color += reflcolor * blendFar * worldVertical;\n        color += wcolor * (1.-blendFar) * worldVertical;\n\n    }\n    #if defined(USE_SHADOWS)\n        const float minCloudLayerHeight = CLOUD_START_HEIGHT;\n        const float maxCloudLayerHeight = CLOUD_START_HEIGHT+CLOUD_HEIGHT;\n        float depthScene = max(gbuffer.x, dw);\n        vec3 pScene = ro+rd*depthScene;\n        vec3 Lsh = normalize(Lo-pScene);\n        float dLshN = dot(vec3(0., 1., 0.), Lsh);\n        float nearCloudPlane = 1.+dot(vec3(0., minCloudLayerHeight, 0.)- pScene, vec3(0., 1., 0.)) / dLshN;\n        if(depthScene<CAM_FAR)\n        {\n            vec3 pNearCloudLayer = pScene+Lsh*nearCloudPlane;\n\n            vec3 wd = vec3(MainWindDir.x, 0., MainWindDir.y)*TIMEC(iTime);\n            float sd = CloudBaseDensity(pNearCloudLayer, minCloudLayerHeight, maxCloudLayerHeight, wd);\n            float shadow = max(.25, exp(-4.*CLOUD_ENERGY_ABSORBTION*sd));\n            color *= shadow;\n        }\n    #endif\n\n    #if defined(USE_MIST)\n    // overly simplified same s\n    // unified density\n    // faked lum computing then no use of it ?\n    float fogDen = pow((1.-abs(rd.y)), 32.)*fbm_hash(rd.xy);\n    if(fogDen>0.01 && gbuffer.y!=TYPE_BOAT)\n    {\n        float fog = smoothstep(0., 1., exp(-6.0*fogDen));\n        \n        // https://www.desmos.com/calculator/tnwdjjxxtb\n        float cosTeta = dot(rd, Ld);\n        const float eccentricity = .6;\n        const float silver_spread = 0.7;\n        const float silver_intensity = 0.5;\n        float hgf = max(phaseHG(eccentricity, cosTeta), silver_intensity * phaseHG(.99-silver_spread, cosTeta));\n        //float hgf = mix(phaseHG(-0.3, 1.), phaseHG(0.51, 1.), .5);\n        vec3 lum = vec3(1.)*hgf*fogDen;\n        color.rgb += (1.-fog)*((lum-fog*lum)/fogDen)*Lt;\n    }\n    #endif\n    fragColor = vec4(color, blendAlpha);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float sin01(float x) { return 0.5*(1.+sin(x)); }\nfloat sinMinMax(float x, float m_, float _m) { return remap(sin(x), -1., 1., m_, _m); }\n\nvec2 mainSound( int samp, float time )\n{\n    return vec2(0., 0.);\n    float baseHz = 440.;\n    float base = sinMinMax(time, 430.5, 451.)+sinMinMax(2.*time, 405., 420.);\n    return vec2( base );\n}","name":"Sound","description":"","type":"sound"}]}