{"ver":"0.1","info":{"id":"dtjXzt","date":"1676495763","viewed":51,"name":"zitest","username":"zimazky","description":"test","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// RayMarching\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n\n// Camera\nstruct Camera {\n  vec3 pos;\n  float angle; // полный угол камеры по x\n  vec4 quat;   // кватернион, определяющий ориентацию\n};\n\n// Получение луча камеры\nvec3 rayCamera(Camera c, vec2 uv) {\n  float t = tan(0.5*c.angle);\n  return qRotate(c.quat,normalize(vec3(uv*t,-1.)));\n}\n\n\n// Для физически правильного рендеринга материалов достаточно следующих параметров:\n// diffuse color (kd) - цвет рассеяния для неметаллов, для металлов должен быть vec3(0)\n// opacity - прозрачность (не применяем)\n// specular color (ks) - интенсивность отражения при прямом угле луча к поверхности\n//     можно классифицировать материалы по этому параметру:\n//     - металлы 0.60-0.90\n//     - полупроводники 0.15-0.50 (кристаллические минералы, включая драгоценные камни)\n//     - диэлектрики 0.02-0.08 (включая воду 0.03, в целом пластики 0.05)\n//     для металлов зависит от длины волны, поэтому параметр может давать цвет\n//     для всех материалов интенсивность отражения стремится к 1.0 при касательном луче (Френель)\n//     особенно это важно учитывать для воды\n// glossiness (g) - параметр определяющий гладкость поверхности (значения 0.0-1.0)\n//     определяет степень specular power (n) через экспоненциальную функцию так, что\n//       для glossiness = 0.0 - n = 1.0\n//       для glossiness = 0.5 - n = 64.0\n//       для glossiness = 1.0 - n = 4096.0\n//     specular power n = exp2(12.*g)\n//\n//   I = Ia + Sum(Im)\n//   Im = im*(kd*dot(Lm,N) + 0.5*(n+1)*ks*pow(dot(Rm,V),n)\n//   n = exp2(12.*g)\n//   Rm = 2*dot(Lm,N)*N-L, отраженный от поверхности луч света от источника\n//     ia - интенсивность окружающего интегрального света\n//     im - интенсивность источника света m\n//\n// Окружающий свет представим как светящуюся полусферу\n//   Ia = ia*[0.5*kd*(1+dot(La,N)) + 0.5*(n+1)*ks*pow(cos(alfa),n)]\n//     cos(alfa) = sqrt[1.0-min(0.0,dot(La,Vr))^2], косинус угла отраженного луча к плоскости полусферы\n//     Vr = 2*dot(V,N)*N-V, отраженный от поверхности луч трассировки\n//     La - единичный вектор направления на середину светящейся полусферы\n//\n// Все расчеты должны вестись в линейном цветовом пространстве, что означает, что текстуры и цвета\n// должны быть подготовлены перед началом расчета - переведены из sRGB (гамма-цветовое пространство)\n// в линейное цветовое пространство.\n// После окончания вычисления перед выводом на экран необходимо перевести в гамма-цветовое представление\n\nstruct Material {\n  vec4 diff;  // rgb - diffuse color, a - opacity, a<0 для источника света\n  vec4 spec; // rgb - specular color, a - glossiness\n};\n\nstruct Sphere {\n  vec3 pos;\n  float r;\n  Material m;\n};\n\nstruct SdResult {\n  float d;  // distance\n  Material m;\n};\n\nSdResult sdSphere(Sphere s, vec3 p) {\n  return SdResult(length(p-s.pos)-s.r, s.m);\n}\n\n\nstruct Box {\n  vec3 pos;\n  vec3 size;\n  Material m;\n};\n\nSdResult sdBox(Box b, vec3 p)\n{\n  vec3 q = abs(p) - b.size;\n  return SdResult(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), b.m);\n}\n\nmat3 rotateX(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(vec3(1,0,0),vec3(0,c,-s),vec3(0,s,c));\n}\n\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(vec3(c,0,s),vec3(0,1,0),vec3(-s,0,c));\n}\n\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(vec3(c,-s,0),vec3(s,c,0),vec3(0,0,1));\n}\n\n\nSdResult sdNearest(SdResult d1, SdResult d2) {\n  if(d1.d < d2.d) return d1;\n  return d2;\n}\n\nconst vec3 BACKGROUND_COLOR = vec3(0.082,0.039,0.122);\nconst vec3 BOTTOM_AMBIENT = 0.03*vec3(0.145,0.894,0.569);\n\n//Sphere s1 = Sphere(vec3(0.,0.,-5.),1.,Material(vec4(0.722,0.318,0.318,1.),vec4(vec3(0.0),0.4)));\nSphere s1 = Sphere(vec3(0.,0.,-5.),1.,Material(vec4(vec3(0.714,0.196,0.027),1.),vec4(vec3(0.05),0.4)));\n//Sphere s2 = Sphere(vec3(-3.,0.,-3.),1.,Material(vec4(vec3(0),1),vec4(vec3(1.),0.5)));\nSphere s2 = Sphere(vec3(-3.,0.,-3.),1.,Material(vec4(3.*vec3(0.2,0.1,0.3),1.),vec4(vec3(0.1),0.5)));\nSphere l  = Sphere(vec3(0.),0.3,Material(vec4(vec3(20),-1),vec4(1)));\nBox b = Box(vec3(3,0.,-4),vec3(1),Material(vec4(vec3(0.),1),vec4(vec3(0.5),0.3)));\n\nSdResult sdFloor(vec3 p) {\n  vec3 c = 33.*BOTTOM_AMBIENT*(1.-0.2*mod(floor(p.x) + floor(p.z), 2.0));\n  Material m = Material(vec4(c,1),vec4(vec3(0.),0.5));\n  return SdResult(p.y + 2., m);\n}\n\nSdResult sdScene(vec3 p) {\n  SdResult res = sdSphere(s1,p);\n  res = sdNearest(sdSphere(s2,p),res);\n  res = sdNearest(sdFloor(p),res);\n  res = sdNearest(sdSphere(l,p),res);\n  mat3 t = rotateX(iTime)*rotateY(-SQRT2*iTime);\n  res = sdNearest(sdBox(b,t*(p - b.pos)),res);\n  return res;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).d +\n      e.yyx * sdScene(p + e.yyx).d +\n      e.yxy * sdScene(p + e.yxy).d +\n      e.xxx * sdScene(p + e.xxx).d);\n}\n\nSdResult rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  SdResult scres;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    scres = sdScene(p);\n    depth += scres.d;\n    if (scres.d < PRECISION || depth > MAX_DIST) break;\n  }\n  scres.d = depth;\n  return scres;\n}\n\nvec4 render(vec2 fragCoord) {\n\n  vec2 m = iMouse.xy/iResolution.xy - 0.5;\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec4 pa = memload(iChannel0,CAMERA_POSITION_ANGLE);\n  Camera c = Camera(pa.xyz,pa.w,memload(iChannel0,CAMERA_QUATERNION));\n  \n  float lRad = 3.;\n  vec3 lCenter = vec3(0,0,-5);\n  l.pos = lCenter + vec3(lRad*sin(iTime),1.5,lRad*cos(iTime));\n  \n  vec4 fragColor = vec4(BACKGROUND_COLOR,1);\n  //float omega = PI*m.x;//-SQRT2*iTime;\n  //c.pos = lCenter + vec3(10.*sin(omega),3.,7.*cos(omega));\n  \n  vec3 rd = rayCamera(c, uv);\n  \n  SdResult sr = rayMarch(c.pos, rd);\n  \n  if(sr.d > MAX_DIST) return fragColor;\n  \n  if(sr.m.diff.a<0.) return vec4(sr.m.diff.rgb,1);\n\n  vec3 p = c.pos + rd * sr.d; // point on sphere we discovered from ray marching\n  vec3 normal = calcNormal(p);\n  vec3 lp = l.pos - p;\n  float lDist2 = dot(lp,lp);\n  vec3 lDir = lp/sqrt(lDist2);\n\n  // top ambient diffuse\n  vec3 La = vec3(0,1,0); // Полусфера сверху\n  vec3 kd = sr.m.diff.rgb;\n  fragColor.rgb = BACKGROUND_COLOR*0.5*kd*(1.+dot(La, normal));\n\n  // top ambient specular\n  float n = exp2(12.*sr.m.spec.a);\n  vec3 ks = sr.m.spec.rgb; \n  //ks *= 0.5*(n+1.)/PI; // нормализация\n  float NdotV = dot(rd,normal); \n  vec3 Vr = (NdotV+NdotV)*normal-rd;\n  float LAdotVR = max(0.0,dot(La,Vr));\n  float cosA = sqrt(1.0-LAdotVR*LAdotVR);\n  fragColor.rgb += BACKGROUND_COLOR*ks*pow(cosA,n);\n\n  // bottom ambient diffuse\n  La = vec3(0,-1,0); // Полусфера сверху\n  fragColor.rgb += BOTTOM_AMBIENT*0.5*kd*(1.+dot(La, normal));\n\n  // bottom ambient specular\n  LAdotVR = max(0.0,dot(La,Vr));\n  cosA = sqrt(1.0-LAdotVR*LAdotVR);\n  fragColor.rgb += BOTTOM_AMBIENT*ks*pow(cosA,n);\n\n  \n  // shadow\n  vec3 newRayOrigin = p + 1.5*normal*PRECISION;\n  SdResult shadowRayLength = rayMarch(newRayOrigin, lDir);\n  if (shadowRayLength.m.diff.a<0.) {\n    // часть, связанная с источником света\n    // diffuse\n    float LdotN = clamp(dot(lDir, normal),0.,1.);\n    vec3 col = kd*LdotN;\n\n    // specular\n    ks *= 0.5*(n+1.)/PI;\n    float RdotV = clamp(dot(reflect(lDir, normal), rd), 0., 1.);\n    col += ks * pow(RdotV, n);\n\n    // fresnel\n    //  float r0 = .0;\n    //  float fresnel = r0 + (1.-r0)*pow(1. - LdotN, 5.);\n    //  float RdotN = dot(-rd,normal);\n    //  float fresnel = r0 + (1.-r0)*pow(clamp(1. - RdotN,0.,1.), 5.);\n    //  fresnel *= 0.5;\n\n    // final color\n    //float omega = 2.*PI*(1.-sqrt(lDist2)/sqrt(lDist2+l.r*l.r));//PI*l.r*l.r/lDist2\n    //float omega = 2.*PI*(1.-sqrt(1.-l.r*l.r/lDist2));\n    float omega = PI*l.r*l.r/lDist2;\n    col *= l.m.diff.rgb*omega;\n\n    fragColor.rgb += col;\n  }\n  // fog factor\n  float fog = 1.0 - exp(-0.00002 * sr.d*sr.d*sr.d);\n  fragColor.rgb = mix(fragColor.rgb, BACKGROUND_COLOR, fog);\n  return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = render(fragCoord);\n  fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2)); // Gamma correction\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Math\nconst float PI = 3.14159265358979;\nconst float SQRT2 = sqrt(2.);\nconst mat3  IDENTITY = mat3(vec3(1,0,0),vec3(0,1,0),vec3(0,0,1));\nconst float ANGLE_DELTA = PI/180.;\n\nconst ivec2 CAMERA_POSITION_ANGLE = ivec2(0,0);\nconst ivec2 CAMERA_VELOCITY = ivec2(1,0);\nconst ivec2 CAMERA_QUATERNION = ivec2(2,0);\nconst ivec2 CAMERA_ROTATION = ivec2(3,0);\n\nconst vec4 initCameraPosAndAngle = vec4(0,0,10,radians(80.));\nconst vec4 initCameraQuaternion = vec4(0,0,0,1);\n\n\nvec4 memload(sampler2D ch, ivec2 addr)\n{ return texelFetch( ch, addr, 0 ); }\n\nvec4 memload(sampler2D ch, ivec2 addr, bool init, vec4 value)\n{ return init ? value : texelFetch( ch, addr, 0 ); }\n\nvec3 memload(sampler2D ch, ivec2 addr, bool init, vec3 value)\n{ return init ? value : texelFetch( ch, addr, 0 ).xyz; }\n\nvec2 memload(sampler2D ch, ivec2 addr, bool init, vec2 value)\n{ return init ? value : texelFetch( ch, addr, 0 ).xy; }\n\nfloat memload(sampler2D ch, ivec2 addr, bool init, float value)\n{ return init ? value : texelFetch( ch, addr, 0 ).x; }\n\nvoid memstore(ivec2 addr, vec4 value, ivec2 sc, inout vec4 fc )\n{ if(sc.x == addr.x && sc.y == addr.y) fc = value; }\n\nvoid memstore(ivec2 addr, vec3 value, ivec2 sc, inout vec4 fc )\n{ if(sc.x == addr.x && sc.y == addr.y) fc = vec4(value,0); }\n\nvoid memstore(ivec2 addr, vec2 value, ivec2 sc, inout vec4 fc )\n{ if(sc.x == addr.x && sc.y == addr.y) fc = vec4(value,0,0); }\n\nvoid memstore(ivec2 addr, float value, ivec2 sc, inout vec4 fc )\n{ if(sc.x == addr.x && sc.y == addr.y) fc = vec4(value,0,0,0); }\n\n\n\n\nvec4 qInvert(vec4 q)\n{ return vec4(-q.xyz, q.w)/dot(q, q); }\n\nvec4 qMul(vec4 a, vec4 b) { \n  return vec4(\n    a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,\n    a.w*b.y + a.y*b.w + a.z*b.x - a.x*b.z,\n    a.w*b.z + a.z*b.w + a.x*b.y - a.y*b.x,\n    a.w*b.w - dot(a.xyz, b.xyz)\n  ); \n}\n\nvec3 qRotate(vec4 q, vec3 p)\n{ return qMul(qMul(q, vec4(p, 0.)), qInvert(q)).xyz; }\n\nmat3 qMat3(vec4 q)\n{ return mat3(qRotate(q, vec3(1,0,0)), qRotate(q, vec3(0,1,0)), qRotate(q, vec3(0,0,1))); }\n\nvec4 qAngle(vec3 axis, float angle)\n{ return vec4(normalize(axis)*sin(angle/2.), cos(angle/2.)); }\n\nvec4 qYyawPitchRoll(float yaw, float pitch, float roll)\n{ return qMul(qAngle(vec3(1,0,0), pitch), qMul(qAngle(vec3(0,1,0),yaw), qAngle(vec3(0,0,1),roll))); }\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_SHIFT = 16;\nconst int KEY_CTRL = 17;\nconst int KEY_ALT = 18;\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_PLUS = 107;\nconst int KEY_MINUS = 109;\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_COMMA = 188;\nconst int KEY_PERIOD = 190;\n\n\nfloat kstate(int key)\n{ return texelFetch(iChannel3, ivec2(key, 0), 0).x; }\n\nfloat kpress(int key)\n{ return texelFetch(iChannel3, ivec2(key, 1), 0).x; }\n\nfloat kstatepress(int key)\n{ return max(kstate(key), kpress(key)); }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 pos = memload(iChannel0, CAMERA_POSITION_ANGLE, iFrame<=1, initCameraPosAndAngle);\n  //pos.xz += 0.1*vec2(kstatepress(KEY_RIGHT)-kstatepress(KEY_LEFT), kstatepress(KEY_UP)-kstatepress(KEY_DOWN));\n  pos.w -= 0.01*(kstatepress(KEY_PLUS)-kstatepress(KEY_MINUS));\n\n  vec3 v = memload(iChannel0, CAMERA_VELOCITY, iFrame<=1, vec3(0));\n  vec2 acceleration = 0.01*vec2(\n    kstate(KEY_CTRL)==0. ? \n      kstatepress(KEY_W)-kstatepress(KEY_S) : \n      kstatepress(KEY_UP)-kstatepress(KEY_DOWN),\n    kstate(KEY_CTRL)==0. ? 0. : kstatepress(KEY_LEFT)-kstatepress(KEY_RIGHT)\n  );\n  \n  vec4 q = memload(iChannel0, CAMERA_QUATERNION, iFrame<=1, initCameraQuaternion);\n  v += acceleration.x*qRotate(q,vec3(0,0,-1));\n  v += acceleration.y*qRotate(q,vec3(-1,0,0));\n  v -= 0.01*v;\n  v += 0.0005*vec3(0,-1,0);\n\n  pos.xyz += v;\n  if(pos.y<0.) pos.y = 0.;\n\n  vec3 rot = memload(iChannel0, CAMERA_ROTATION, iFrame<=1, vec3(0));\n  rot += 0.1*ANGLE_DELTA*vec3(\n    kstate(KEY_CTRL)==0. ? kstatepress(KEY_LEFT)-kstatepress(KEY_RIGHT) : 0., \n    kstate(KEY_CTRL)==0. ? 0.5*(kstatepress(KEY_DOWN)-kstatepress(KEY_UP)) : 0., \n    0.5*(kstatepress(KEY_COMMA)-kstatepress(KEY_PERIOD))\n  );\n  rot -= 0.1*rot;\n  q = qMul(q,vec4(0,0,sin(rot.z),cos(rot.z)));\n  q = qMul(q,vec4(sin(rot.y),0,0,cos(rot.y)));\n  q = qMul(q,vec4(0,sin(rot.x),0,cos(rot.x)));\n  \n\n  ivec2 isc = ivec2(fragCoord - 0.5);\n  memstore(CAMERA_POSITION_ANGLE, pos, isc, fragColor);\n  memstore(CAMERA_VELOCITY, v, isc, fragColor);\n  memstore(CAMERA_QUATERNION, normalize(q), isc, fragColor);\n  memstore(CAMERA_ROTATION, rot, isc, fragColor);\n  \n  \n}","name":"Buffer A","description":"","type":"buffer"}]}