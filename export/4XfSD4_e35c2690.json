{"ver":"0.1","info":{"id":"4XfSD4","date":"1709583640","viewed":57,"name":"Glitchy metallic world","username":"inverse_transpose","description":"Some weird metallic world","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 get_camera_uvw(in vec3 start_pos, in vec3 focus_point, in float theta)\n{\n    vec3 k =  normalize(vec3(sin(theta), cos(theta), 0.0));\n    vec3 w = -normalize(focus_point - start_pos);\n    vec3 u =  normalize(cross(w, k));\n    vec3 v =  normalize(cross(u, w));\n    \n    return mat3(u, v, w);\n}\n\nfloat hash(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return (fract((p3.x + p3.y) * p3.z)-.5)*1.5;\n}\n\n\n#define iterations 1\n#define flowintensity 2.25\n#define numOctaves 5\n#define flowoffset 0.25\n\nvec4 noised( in vec3 x )\n{\n    vec3 i = vec3(floor(x));\n    vec3 w = fract(x);\n    \n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w); \n    \n    float a = hash(i+vec3(0,0,0));\n    float b = hash(i+vec3(1,0,0));\n    float c = hash(i+vec3(0,1,0));\n    float d = hash(i+vec3(1,1,0));\n    float e = hash(i+vec3(0,0,1));\n\tfloat f = hash(i+vec3(1,0,1));\n    float g = hash(i+vec3(0,1,1));\n    float h = hash(i+vec3(1,1,1));\n    \n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec4 fbm( vec3 x )\n{    \n    float G = exp2(-1.);\n    float f = 1.0;\n    float a = 1.0;\n    vec4 t;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(x * f);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\n//@CollinInMySternum function to make swirly noise using fbm\nfloat curl(vec3 p, vec3 n)\n{\n    for(int i=0; i<iterations; i++)\n    {\n        vec3 x = p + flowoffset;\n        vec3 g = cross(fbm(x).yzw, n);\n        p -= (flowintensity / float(iterations)) * g;\n    }\n    \n    return (fbm(p).x + 1.0) / 2.0;\n}\n\n// Assumes we are dealing with a linear subspace.\nfloat iPlane(in vec3 ro, in vec3 rd, in vec3 n)\n{\n    return dot(normalize(n), vec3(0.0) - ro) / dot(normalize(n), rd);\n}\n\n// Handles hyperplanes.\nfloat iPlaneQ(in vec3 ro, in vec3 rd, in vec3 n, in vec3 q)\n{\n    vec3 nn = normalize(n);\n    return -dot(nn, ro - q) / dot(nn, rd);\n}\n\n/**\n * Let OC - RO - SC.\n *\n * (OC + tRD)^2 - r^2 = 0\n * OC(OC + tRD) + tRD(OC + tRD) - r^2 = 0\n * OC^2 + 2*t*RD*OC + t^2 * RD^2 - r^2 = 0\n * t^2(RD^2) + t(2*RD*OC) + OC^2 - r^2 = 0\n * RD^2 = unity, therefore:\n * t^2 + t(2*RD*OC) + OC^2 - r^2 = 0\n * t = (-b +/- SQRT(b^2 - 4(1)(c)) / 2\n *   = (-(2*RD*OC) +/- SQRT(4*RD^2*OC^2 - 4*1*(OC^2 - r^2))) / 2\n *   = -(2*RD*OC)/2 +/- SQRT((4*RD^2*OC^2 - 4*1*(OC^2 - r^2))/4)\n *   = -(RD*OC) +/- SQRT(RD^2*OC^2 - (OC^2 - r^2))\n *\n * Therefore, a = 1\n *            b = (RD*OC)\n *            c = (OC^2 - r^2)\n *\n * Intersection exists if (b^2 - c) is >= 0, otherwise roots are complex,\n *\n * and,\n *            t = min(-b + sqrt(b*b - c), -b - sqrt(b*b - c))\n */\nfloat iSphere(in vec3 ro, in vec3 rd, in vec3 sc, in float r)\n{\n    vec3 oc = ro - sc;\n    float b = dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float t = b*b - c;\n    float g = sqrt(t);\n    \n    return 0.0 > t ? -1.0 : min(-b + g, -b - g);\n}\n\nfloat calculate_diffuse_shading(in vec3 normal, in vec3 to_light)\n{\n    return 0.625 * (dot(normal, to_light) * 0.5 + 0.5);\n}\n\n#define SPECULAR_POWER 31.0\n\nfloat calculate_specular_shading(in vec3 ro, in vec3 normal, in vec3 position, in vec3 to_light)\n{\n    // Calculate the reflection vector.\n    vec3 refl = normalize((2.0 * (dot(to_light, normal) * normal)) - to_light);\n    \n    // Calculate vector from point to eye.\n    vec3 to_camera = normalize(ro - position);\n    \n    return pow(0.5 + 0.5*dot(refl, to_camera), SPECULAR_POWER);\n}\n\nconst vec3 light = vec3(100.0, 10.0, -50.0);\n\nvec3 rotateX(in vec3 p, in float t)\n{\n    float c = cos(t);\n    float s = sin(t);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0,-s, c\n    ) * p;\n}\n\nvec3 rotateY(in vec3 p, in float t)\n{\n    float c = cos(t);\n    float s = sin(t);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n       -s, 0.0, c\n    ) * p;\n}\n\nvec3 rotateZ(in vec3 p, in float t)\n{\n    float c = cos(t);\n    float s = sin(t);\n    return mat3(\n        c, s, 0.0,\n       -s, c, 0.0,\n       0.0, 0.0, 1.0\n    ) * p;\n}\n\nvec3 opRot(in vec3 p, in float x, in float y, in float z)\n{\n    vec3 result = 0.0 < x ? rotateX(p, x) : p;\n    result = 0.0 < y ? rotateY(result, y) : result;\n    result = 0.0 < z ? rotateZ(result, z) : result;\n    return result;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 intersect(vec3 ro, vec3 rd)\n{\n    #define NR_SPHERES 3\n    float time = 0.5*iTime;\n    float t0 = -0.6+1.2*smoothstep(-1.0, 1.0, sin(time*1.0));\n    float t1 = -0.6+1.2*smoothstep(-1.0, 1.0, cos(time*2.0));\n    float t2 = -0.1+0.2*smoothstep(-1.0, 1.0, sin(time*2.0));\n    \n    vec3 centre_sphere = vec3(0.0, 0.42, -1.0);\n\n    vec4 spheres[NR_SPHERES] = vec4[](\n        vec4(vec3(1.25, -t0+0.5, -0.5), 0.35),\n        vec4(vec3(-1.25, t0+0.5, -0.5), 0.35),\n        vec4(vec3(0.0, 0.72, -1.0), 0.85)\n    );\n    \n    #define NR_PLANES 1\n    vec4 planes[NR_PLANES] = vec4[](\n        vec4(0.0, -1.0, 0.0, 0.0)\n    );\n    \n    float dist = 100000.0;\n    vec3 colour = vec3(1.0);\n    \n    int bounces = 3;\n    float modulation = 1.0;\n    vec3 addition = vec3(0.0);\n    float mix_factor = 1.0;\n    \n    for (int j = 0; j < bounces; ++j)\n    {\n        for (int i = 0; i < NR_SPHERES; ++i)\n        {\n            float t = iSphere(ro, rd, spheres[i].xyz, spheres[i].w);\n            if (0.0 > t || t > dist)\n                continue;\n            \n            if ((bounces-j)>=1)\n            {\n               // dist = t;\n                ro = ro + t*rd;\n                rd = reflect(rd, normalize(ro - spheres[i].xyz));\n                ro += 0.001*rd;\n                modulation *= 0.99;\n                mix_factor *= 0.95;\n                addition = vec3(0.0);\n                break;\n            }\n        }\n\n        for (int i = 0; i < NR_PLANES; ++i)\n        {\n            float t = iPlaneQ(ro, rd, planes[i].xyz, planes[i].xyz+planes[i].w);\n            if (0.0 > t || t > dist)\n                continue;\n\n            dist = t;\n            vec3 p = ro+t*rd;\n            float cf = curl(p+0.125*iTime, planes[i].xyz);\n            //colour = mix(vec3(0.2,1.0,0.85), vec3(0.0), cf);\n            colour = mix(vec3(1.0), vec3(0.0), cf);\n            float s = calculate_specular_shading(ro, normalize(vec3(cf, cf, cf)), p, normalize(light - p));\n            colour += s * vec3(0.15);\n            \n            float occ = 0.0;\n            for (int k = 0; k < NR_SPHERES; ++k)\n            {\n                vec3 vec = spheres[k].xyz - p;\n                float len = length(vec);\n                float coe = 0.5 + 0.5*dot(normalize(vec), vec3(0.0,1.0,0.0));\n                occ += coe / (len*len);\n            }\n            \n            colour *= max(1.0 - occ, 0.2);\n        }\n    }\n    \n    return mix(addition, colour * modulation, mix_factor);\n}\n\nvec2 rot2d(in vec2 uv, in float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    mat2 mat = mat2(\n        ct, st,\n       -st, ct\n    );\n    return mat * uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float s = 7.0*smoothstep(0.0, 15.0, mod(iTime,20.0))-smoothstep(15.0,20.0, mod(iTime,20.0));\n\n    float k = max(-0.15*abs(uv.y),\n         min(\n             smoothstep(\n                 texture(iChannel0, vec2(iTime)).r, \n                 texture(iChannel0, vec2(iTime)).g,\n                 rand(uv)*0.45\n             ),\n          0.02*abs(mod(uv.x+(uv.y*0.05)-s, 0.5))));\n\n\n    k += max(-0.05, min(step(rand(vec2(iTime))*rand(vec2(-iTime))*0.505, 0.5*rand(vec2(-iTime))), 0.05));\n    \n    uv += k;\n   \n    vec3 ro = vec3(0.0, 0.125, 0.85);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n\n    float j = 0.01;\n    vec3 c = intersect(ro, rd);\n   // c = pow(c, vec3(1.0/2.21818));\n    c = mix(c, vec3(0.0), k);\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}