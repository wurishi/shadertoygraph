{"ver":"0.1","info":{"id":"ssBBW1","date":"1647199446","viewed":538,"name":"Procedural Blue Noise Dithering","username":"Chrism","description":"Left to right: Bayer matrix, blue noise texture, screen-space blue noise diffusion, random noise\nImplements \"Screen-Space Blue-Noise Diffusion of Monte Carlo Sampling Error via Hierarchical Ordering of Pixels\"\n\nClick and hold to show image instead","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","dither","hilbert","bluenoise","bayer","scramble","owen","sobol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADES 8.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    float col = iMouse.z > 0.5 ? texture(iChannel2, vec2(mod(uv.x, 0.25) + 0.25, uv.y)).r : uv.y;\n    float mask = 0.0;\n    \n    if (uv.x > 0.75) { // random noise\n        uint seed = uint(fragCoord.x) + uint(fragCoord.y) * uint(iResolution.y);\n        mask = float(Rand(seed)) / 4294967296.0;\n    }\n    else if (uv.x > 0.5) { // screen-space blue-noise diffusion (arranged to remove unnescessary bit reversals)\n        uint m = HilbertIndex(uvec2(fragCoord));     // map pixel coords to hilbert curve index\n        m = OwenHash(ReverseBits(m), 0xe7843fbfu);   // owen-scramble hilbert index\n        m = OwenHash(ReverseBits(m), 0x8d8fb1e0u);   // map hilbert index to sobol sequence and owen-scramble\n        mask = float(ReverseBits(m)) / 4294967296.0; // convert to float\n    }\n    else if (uv.x > 0.25) { // blue noise texture\n        mask = texture(iChannel1, fragCoord / iChannelResolution[1].xy).r;\n    }\n    else { // bayer matrix\n        mask = texture(iChannel0, fragCoord / iChannelResolution[0].xy).r;\n    }\n    \n    mask = ReshapeUniformToTriangle(mask);\n    \n    col = floor((col + mask / SHADES) * SHADES) / SHADES; // quantise and apply dither mask    \n    col -= step(mod(uv.x, 1.0 / 4.0), 0.003); // black lines\n    fragColor = vec4(vec3(col), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"uint Rand(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuint HilbertIndex(uvec2 p) {\n    uint i = 0u;\n    for(uint l = 0x4000u; l > 0u; l >>= 1u) {\n        uvec2 r = min(p & l, 1u);\n        \n        i = (i << 2u) | ((r.x * 3u) ^ r.y);       \n        p = r.y == 0u ? (0x7FFFu * r.x) ^ p.yx : p;\n    }\n    return i;\n}\n\nuint ReverseBits(uint x) {\n    x = ((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1);\n    x = ((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2);\n    x = ((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4);\n    x = ((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8);\n    return (x >> 16) | (x << 16);\n}\n\n// from: https://psychopath.io/post/2021_01_30_building_a_better_lk_hash\nuint OwenHash(uint x, uint seed) { // seed is any random number\n    x ^= x * 0x3d20adeau;\n    x += seed;\n    x *= (seed >> 16) | 1u;\n    x ^= x * 0x05526c56u;\n    x ^= x * 0x53a22864u;\n    return x;\n}\n\n// adapted from: https://www.shadertoy.com/view/MslGR8\nfloat ReshapeUniformToTriangle(float v) {\n    v = v * 2.0 - 1.0;\n    v = sign(v) * (1.0 - sqrt(max(0.0, 1.0 - abs(v)))); // [-1, 1], max prevents NaNs\n    return v + 0.5; // [-0.5, 1.5]\n}","name":"Common","description":"","type":"common"}]}