{"ver":"0.1","info":{"id":"Xfy3Rz","date":"1712302334","viewed":41,"name":"environment shader","username":"Arheus","description":"Shader with global environment","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct global_world_data \n{\n\tmat4  View;\n\tmat4  Proj;\n\tvec4  LightPos;\n\tfloat Metalness;\n\tfloat Roughness;\n\tfloat Albedo;\n\tfloat LightSize;\n};\n\nconst float PI  = 3.14159265359;\nconst float PI2 = 2.0 * PI;\n\nfloat DistributionGGX(vec3 N, vec3 H, float Roughness)\n{\n    float a      = Roughness*Roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float Roughness)\n{\n    float r = (Roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float Roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, Roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, Roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 FresnelSchlick(float CosTheta, vec3 F0)\n{\n\treturn F0 + (1.0 - F0) * pow(clamp(1.0 - CosTheta, 0.0, 1.0), 5.0);\n}\n\nfloat GetBlockerDistance(vec3 CurrCoord, vec3 LightDir, float StepCount, float ShadowSamples, float SampleRadius)\n{\n\tfloat SumBlockerDistance = 0.0;\n\tfloat NumBlockerDistance = 0.0;\n    float StepSize = 1.0 / StepCount;\n        \n    for(int SampleIdx = 0; SampleIdx < int(ShadowSamples); ++SampleIdx)\n    {\n        float Angle  = float(SampleIdx) * PI2 / float(ShadowSamples);\n        vec3  Offset = vec3(cos(Angle) * SampleRadius, sin(Angle) * SampleRadius, 0.0);\n        vec3  RayO   = CurrCoord;\n        \n        float CurrentDepth = texelFetch(iChannel0, ivec2(RayO.xy * iResolution.xy), 0).r;\n        \n        RayO += Offset;\n        \n        for(int StepIdx = 0; StepIdx < int(StepCount); ++StepIdx)\n        {      \n            vec3 RayP = RayO + LightDir * StepSize * float(StepIdx);\n            \n            if(RayP.z < CurrentDepth)\n            {\n\t\t\t\tSumBlockerDistance += RayP.z;\n                NumBlockerDistance += 1.0;\n                break;\n            }\n            \n            CurrentDepth = texelFetch(iChannel0, ivec2(RayP.xy * iResolution.xy), 0).r;\n        }\n    }\n    \n\tif(NumBlockerDistance > 0.0) return SumBlockerDistance / NumBlockerDistance;\n    return -1.0;\n}\n\nfloat GetPenumbraSize(vec3 CurrCoord, vec3 LightDir, float ReceiverDepth, float StepCount, float ShadowSamples, float SampleRadius, float LightSize)\n{\n    float BlockerDistance = GetBlockerDistance(CurrCoord, LightDir, StepCount, ShadowSamples, SampleRadius);\n\n    if (BlockerDistance <= -1.0)\n    {\n        return 1.0;\n    }\n \n    float  PenumbraWidth = (ReceiverDepth - BlockerDistance) / BlockerDistance;\n    return PenumbraWidth * 0.01 * LightSize / ReceiverDepth;\n}\n\nfloat GetShadow(vec3 LightPos, vec3 CurrCoord, float Depth, float ShadowSamples, float StepCount, float SampleRadius, float PenumbraSampleRadius, float LightSize)\n{\n    float Shadowed = 0.0;\n    vec3  LightDir = normalize(LightPos - CurrCoord);\n    float StepSize = 1.0 / StepCount;\n    float SearchSize = GetPenumbraSize(CurrCoord, LightDir, Depth, StepCount, ShadowSamples, PenumbraSampleRadius, LightSize);\n    //if(SearchSize == 1.0) SearchSize = 3.402823466e-38;\n    for(int SampleIdx = 0; SampleIdx < int(ShadowSamples); ++SampleIdx)\n    {\n        float Angle  = float(SampleIdx) * PI2 / float(ShadowSamples);\n        vec3  Offset = vec3(cos(Angle) * SampleRadius, sin(Angle) * SampleRadius, 0.0);\n        vec3  RayO   = CurrCoord;\n        \n        float CurrentDepth = Depth;\n        \n        RayO += Offset;\n        \n        for(int StepIdx = 0; StepIdx < int(StepCount); ++StepIdx)\n        {      \n            vec3 RayP = RayO + LightDir * StepSize * float(StepIdx) * SearchSize * 1.125;\n            \n            if(RayP.z < CurrentDepth)\n            {\n                Shadowed += 1.0;\n                break;\n            }\n            \n            CurrentDepth = texelFetch(iChannel0, ivec2(RayP.xy * iResolution.xy), 0).r;\n        }\n    }\n    Shadowed /= ShadowSamples;\n    Shadowed = smoothstep(0.0, 1.0, Shadowed);\n    \n    return Shadowed;\n}\n\nfloat AmbientOcclusion(vec2 CurrCoord, float Height, float SampleRadius, int NumSamples) \n{\n    float Occlusion = 0.0;\n\n    for (int SampleIdx = 0; SampleIdx < NumSamples; ++SampleIdx) \n\t{\n        float Angle  = float(SampleIdx) * PI / float(NumSamples);\n        vec2  Offset = vec2(cos(Angle), sin(Angle)) * SampleRadius;\n        vec2  SampleCoord = CurrCoord + Offset;\n\n        float SampleHeight = texelFetch(iChannel0, ivec2(SampleCoord * iResolution.xy), 0).r;\n\n        if (SampleHeight < Height) \n\t\t{\n            Occlusion += 1.0;\n        }\n    }\n\n    Occlusion /= float(NumSamples);\n\n    return Occlusion;\n}\n\nvec3 FresnelSchlickRoughness(float HdotV, vec3 F0, float Roughness)\n{\n    return F0 + (max(vec3(1.0 - Roughness), F0) - F0) * pow(1.0 - HdotV, 5.0);\n}\n\nvoid mainImage(out vec4 FragColor, in vec2 TextCoord)\n{\n    global_world_data WorldUpdate;\n    WorldUpdate.LightPos  = vec4(iMouse.xy / iResolution.xy, 1.0, 0.001);\n\tWorldUpdate.Metalness = 0.2;\n\tWorldUpdate.Roughness = 0.6;\n\tWorldUpdate.Albedo    = 1.0;\n\tWorldUpdate.LightSize = 0.1;\n    \n\tfloat M = texelFetch(iChannel0, ivec2(TextCoord) - ivec2( 0,  0), 0).r;\n\tfloat R = texelFetch(iChannel0, ivec2(TextCoord) - ivec2( 1,  0), 0).r;\n\tfloat L = texelFetch(iChannel0, ivec2(TextCoord) - ivec2(-1,  0), 0).r;\n\tfloat U = texelFetch(iChannel0, ivec2(TextCoord) - ivec2( 0,  1), 0).r;\n\tfloat D = texelFetch(iChannel0, ivec2(TextCoord) - ivec2( 0, -1), 0).r;\n\n\tvec3 Normal    = vec3((R-L) / 2.0, (D-U) / 2.0, 1.0);\n\tvec3 LightPos  = WorldUpdate.LightPos.xyz;\n\tvec3 CurrCoord = vec3(TextCoord / iResolution.xy, M);\n\tvec3 CameraPos = vec3(0.5, 0.5,  1);\n\tvec3 CameraDir = vec3(0.0, 0.0, -1);\n\tvec3 ViewDir = normalize(CameraPos - CurrCoord);\n\n\tfloat Shadowed = GetShadow(LightPos, CurrCoord, M, 16.0, 128.0, 0.003, 0.00001, WorldUpdate.LightSize);\n\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, vec3(WorldUpdate.Albedo), WorldUpdate.Metalness);\n\n    vec3 Lo = vec3(0.0);\n    {\n        // calculate light radiance\n        vec3  L = normalize(LightPos - CurrCoord);\n        vec3  H = normalize(ViewDir + L);\n        float NdotL = max(dot(Normal, L), 0.0);\n        float Distance    = length(LightPos - CurrCoord);\n        float Attenuation = 1.0 / (1.0 + pow(WorldUpdate.LightSize / Distance, 2.0));\n        vec3  Radiance = Attenuation * vec3(0.5);\n\n        // cook-torrance brdf\n        float NDF = DistributionGGX(Normal, H, WorldUpdate.Roughness);\n        float G   = GeometrySmith(Normal, ViewDir, L, WorldUpdate.Roughness);\n        vec3  F   = FresnelSchlick(max(dot(H, ViewDir), 0.0), F0);\n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= (1.0 - WorldUpdate.Metalness);\n\n        vec3  Numerator   = NDF * G * F;\n        float Denominator = 4.0 * max(dot(Normal, ViewDir), 0.0) * NdotL + 0.0001;\n        vec3  Specular    = Numerator / Denominator;\n\n        Lo = (kD * WorldUpdate.Albedo / PI + Specular) * Radiance * NdotL;\n    }\n            \n    // IBL\n    vec3 F = FresnelSchlickRoughness(dot(Normal, CameraDir), F0, WorldUpdate.Roughness);\n    vec3 kDiff = (1.0 - F) * (1.0 - WorldUpdate.Metalness);\n    vec3 Refl  = 2.0 * dot(ViewDir, Normal) * Normal - ViewDir;\n    vec3 IndirectDiffuse  = texture(iChannel1, Normal).rgb * kDiff * GeometrySmith(Normal, Normal, normalize(LightPos - CurrCoord), WorldUpdate.Roughness);\n    vec3 IndirectSpecular = textureLod(iChannel1, Refl, WorldUpdate.Roughness * 4.0).rgb * F;\n\n    float Occlusion = AmbientOcclusion(CurrCoord.xy, M, 0.001, 16);\n    vec3  Color = ((IndirectDiffuse + IndirectSpecular) + Lo) * (1.0 - Occlusion) * (1.0 - Shadowed);\n\n    // gamma correction\n    Color = Color / (Color + vec3(1.0));\n    Color = pow(Color, vec3(1.0/2.2));\n\n    FragColor = vec4(Color, 1.0);\n}","name":"Image","description":"","type":"image"}]}