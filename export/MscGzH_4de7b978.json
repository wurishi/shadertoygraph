{"ver":"0.1","info":{"id":"MscGzH","date":"1448063745","viewed":340,"name":"2001","username":"sixstring982","description":"My god, it's full of stars!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["star","space","trippy","gate","2001","odyssey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/**  \"2001\" - Sixstring982/2015\n  *\n  *  Inspired by one of my favorite films. Some\n  *  raymarching primitive code was taken from\n  *  iq's distfunctions page:\n  *\n  *  https://iquilezles.org/articles/distfunctions\n  *\n  *  License: Attribution-NonCommercial-ShareAlike 4.0 International\n  */\n\n// Whelp, this thing is getting big. I'll need to refactor\n// later.\n\n#define MAX_RAY_DIST 100.0\n#define MAX_RAY_ITERS 10000\n#define FOG_START 20.0\n#define EPSILON 0.001\n#define SPEC_POW 32.0\n#define AUTOSPIN_SPEED 0.2\n#define CAM_DIST 10.0\n#define MOUSE_SPEED 0.01\n#define FOG_POW 0.5\n\n// sqrt(2) / 2\n#define STOT 0.7071\n\n// ================ SCENE SELECTION ====================\n\nint sceneSelect() {\n    // return 2;\n    return int(mod(iTime, 15.0) / 5.0);\n}\n\n// ================ COLORS =============================\nmat3 material() {\n    float c = floor(mod(iTime, 75.0) / 15.0);\n    \n    if (c < 1.0) {\n        return mat3(124.0, 36.0, 107.0,\n                    99.0, 100.0, 50.0,\n                    221.0, 95.0, 67.0) / 255.0;\n    } else if (c < 2.0) {\n        return mat3(205.0, 138.0, 111.0,\n                    0.0, 51., 94.0,\n                    13.0, 1.0, 45.0) / 255.0;\n    } else if (c < 3.0) {\n        return mat3(0.0, 19.0, 152.0,\n                    57.0, 5.0, 68.0,\n                    139.0, 5.0, 33.0) / 255.0;\n    } else if (c < 4.0) {\n        return mat3(25.0, 96.0, 142.0,\n                    65.0, 87.0, 23.0,\n                    192.0, 154.0, 0.0) / 255.0;\n    } else {\n        return mat3(167.0, 0.0, 169.0,\n                    41.0, 4.0, 67.0,\n                    17.0, 98.0, 167.0) / 255.0;\n    }\n}\n\n// ================ GEOMETRY ===========================\n\nfloat plane(in vec3 pos) {\n    float d = pos.y;\n    d += 1.0 * texture(iChannel1, pos.xz / vec2(100.0)).r;\n    d += 2.0 * cos(0.2 * pos.x + 0.00002 * sin(pos.z * 0.3) + cos(pos.z * 0.2)) +\n         4.0 * sin(cos(pos.z * 0.03) + pos.x * 0.02);\n    d += 8.0 * texture(iChannel1, pos.xz / vec2(250.0)).r;\n    return d;\n}\n\nfloat sphere(in vec3 pos, in float r) {\n    return length(pos) - r;\n}\n\nfloat texSphere(in vec3 pos, in float r) {\n    return length(pos) - r +\n           texture(iChannel0, pos.xy * vec2(0.01)).r;\n}\n\nfloat box(in vec3 pos, in vec3 dims) {\n    vec3 d = abs(pos) - dims;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n               length(max(d,0.0));\n}\n\nfloat cylinder(in vec3 p, in vec3 c) {\n    return length(p.xz - c.xz) - c.z;\n}\n\nfloat bentCylinder(in vec2 bp, in vec3 pos, in vec3 cyl) {\n    float c = cos(bp.x * pos.y);\n    float s = sin(bp.y * pos.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*pos.xy,pos.z);\n    return cylinder(q, cyl);\n}\n\nfloat opI(in float d1, in float d2) {\n    return max(d1, d2);\n}\n\nfloat opU(in float d1, in float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(in float d1, in float d2) {\n    return max(d1, -d2);\n}\n\nfloat terrainMap(in vec3 pos) {\n    float d = plane(pos + vec3(1.0));\n    return d;\n}\n\n// =================== TERRAIN SCENE =================\n\n// =====  LIGHTING =====\n\nvec3 terrainNormalAt(in vec3 ro) {\n    const vec2 ev = vec2(EPSILON, 0.0);\n    return normalize(vec3(terrainMap(ro + ev.xyy) - terrainMap(ro - ev.xyy),\n                          terrainMap(ro + ev.yxy) - terrainMap(ro - ev.yxy),\n                          terrainMap(ro + ev.yyx) - terrainMap(ro - ev.yyx)));\n}\n\n\nvec3 terrainLighting(in vec3 ro, in vec3 rd, in float dist) {\n    vec3 n = terrainNormalAt(ro);\n    mat3 mat = material();\n    float diffC = max(0.0, dot(n, -rd));\n    float specC = pow(diffC, SPEC_POW);\n    \n    float ambC = 0.25;\n    \n    vec3 light;\n    if (ambC > max(diffC, specC)) {\n        light = mix(mat[0], mat[1], ambC - diffC);\n    } else if (diffC > specC * 100.0) {\n        light = mix(mat[1], mat[2], diffC - specC);\n    } else {\n        light = mat[2];\n    }\n    \n    if (dist < FOG_START) {\n        return light;\n    } else {\n        return mix(light, \n                   mat[0], \n                   pow((dist - FOG_START) / (MAX_RAY_DIST - FOG_START), FOG_POW));\n    }\n}\n\n// =====  MARCHING =====\n\nvec3 marchTerrain(in vec3 ro, in vec3 rd) {\n    float dist = EPSILON;\n    float totalDist = 0.0;\n    \n    for (int i = 0; i < MAX_RAY_ITERS; i++) {\n        if (dist < EPSILON ||\n            totalDist > MAX_RAY_DIST) {\n            break;\n        }\n        \n        dist = terrainMap(ro);\n        totalDist += dist;\n        ro += dist * rd;\n    }\n    \n    if (dist < EPSILON) {\n        return terrainLighting(ro, rd, totalDist);\n    } else {\n        return material()[0];\n    }\n}\n\nvec4 terrainScene(in vec2 fragCoord) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5));\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float camTheta = iMouse.x * MOUSE_SPEED;\n    float camPhi   = iMouse.y * MOUSE_SPEED;\n    \n    \n    vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 cop = vec3(100.0 * sin(iTime * 0.03), 0.0, 100.0 * cos(iTime * 0.03));\n    \n    float height = (terrainMap(cop - vec3(0.1, 0.0, 0.0)) + \n                    terrainMap(cop) + \n                    terrainMap(cop + vec3(0.1, 0.0, 0.0))) / -3.0;\n    cop.y += height + 5.0;\n    \n    vec3 target = cop + normalize(cross(-cop, up)) +\n                  vec3(0.0, -0.3, 0.0);\n    \n    vec3 cdir = normalize(target - cop);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cright, cdir);\n    \n    vec3 rd = uv.x * cright + uv.y * cup + cdir;\n    \n    return vec4(marchTerrain(cop, rd), 1.0);\n}\n\n\n// =================== EYE SCENE =================\n\nfloat eyeMap(in vec3 pos) {\n    float d = sphere(pos, 3.0);\n    // 45 degrees around x axis\n    const mat3 xrot = mat3(1.0, 0.0, 0.0,\n                           0.0, STOT, -STOT,\n                           0.0, STOT, STOT);\n    \n    const mat3 zrot = mat3(0.0, -1.0, 0.0,\n                           1.0, 0.0, 0.0,\n                           0.0, 0.0, 1.0);\n    \n    const float maxEyelidDist = -4.8;\n    const float minEyelidDist = -6.0;\n    float eyelidDist = maxEyelidDist;\n    \n    const float maxLowerLid = 0.7;\n    const float maxLowerCurv = -0.3;\n    const float maxUpperLid = -0.45;\n\tconst float maxUpperCurv = 0.3;\n    const float minCurv = 0.0;\n    const float minLid = 0.0;\n    float lowerLid = maxLowerLid;\n    float lowerCurv = maxLowerCurv;\n    float upperLid = maxUpperLid;\n    float upperCurv = maxUpperCurv;\n    \n    const float EYELID_SPEED = 200.0;\n    float lidDisplacement = 0.003 * (sin(pos.x * 50.0) + cos(pos.y * 50.0));\n    \n    float eyeState = mod(iTime * EYELID_SPEED, 4.0 * EYELID_SPEED);\n    if (eyeState < 10.0) {\n        eyelidDist = mix(maxEyelidDist, minEyelidDist, eyeState / 10.0);\n        lowerLid   = mix(maxLowerLid,   minLid, eyeState / 10.0);\n        upperLid   = mix(maxUpperLid,   minLid, eyeState / 10.0);\n        lowerCurv  = mix(maxLowerCurv,  minCurv, eyeState / 10.0);\n        upperCurv  = mix(maxUpperCurv,  minCurv, eyeState / 10.0);\n    } else if (eyeState < 20.0) {\n        eyelidDist = mix(minEyelidDist, maxEyelidDist, (eyeState - 10.0) / 10.0);\n        lowerLid   = mix(minLid, maxLowerLid, (eyeState - 10.0) / 10.0);\n        upperLid   = mix(minLid, maxUpperLid, (eyeState - 10.0) / 10.0);\n        lowerCurv  = mix(minCurv, maxLowerCurv, (eyeState - 10.0) / 10.0);\n        upperCurv  = mix(minCurv, maxUpperCurv, (eyeState - 10.0) / 10.0);\n    }\n    \n    d = opI(d, box((xrot * (pos + vec3(0.0, 0.0, eyelidDist))) + \n                   vec3(0.0, 0.0, 0.0), vec3(2.0)));\n    \n    d = opU(d, bentCylinder(vec2(upperCurv),\n                            zrot * (pos + vec3(0.0, upperLid, 0.0)) + \n                            vec3(0.0, 0.0, -2.9), vec3(0.1)) +\n               lidDisplacement);\n    \n    d = opU(d, bentCylinder(vec2(lowerCurv),\n                            zrot * (pos + vec3(0.0, lowerLid, 0.0)) + \n                            vec3(0.0, 0.0, -2.9), vec3(0.1)) +\n               lidDisplacement);\n    return d;\n}\n\nvec3 eyeColoring(in vec3 pos) {\n    mat3 mat = material();\n    if (length(pos) < 3.02) {\n        // Eyeball\n\n        // Iris texture\n        float theta = atan(pos.x, pos.y);\n        float tc = texture(iChannel0,\n                             vec2(sin(theta * 4.0), \n                                  cos(theta * 0.25)) * \n                             1.0 / length(pos.xy)).g;\n        tc = tc * 2.0 + 0.5;\n        const float IRIS_VARIANCE = 0.004;\n        float irisDist = 0.5 + IRIS_VARIANCE * (cos(sin(theta * 1.0)) + \n                                                sin(theta * 10.0));\n\n        vec3 pupilCenter = mat[1];\n        vec3 innerIris = mat[1] * tc;\n        vec3 midIris = mat[2] * tc * 0.75;\n        vec3 outerIris = mat[2];\n        vec3 sclera = mix(mat[0], vec3(texture(iChannel0, pos.xy).r), 0.07);\n        if (length(pos.xy) < 0.25) {\n            return mix(pupilCenter, innerIris, pow(4.25 * length(pos.xy), 4.0));\n        } else if (length(pos.xy) < 0.4) {\n            return mix(innerIris, midIris, (length(pos.xy) - 0.25) / (0.4 - 0.25));\n        } else if (length(pos.xy) < irisDist) {\n            return mix(midIris, outerIris, pow((length(pos.xy) - 0.4) / (irisDist - 0.4), 0.5));\n        } else {\n            return mix(outerIris, sclera, pow((length(pos.xy) - irisDist), 0.2));\n        }\n    } else {\n        //Eyelid\n        return mix(vec3(0.0), mat[2], 1.0);\n    }\n}\n\nvec3 eyeNormalAt(in vec3 ro) {\n    vec2 ev = vec2(EPSILON, 0.0);\n    return normalize(vec3(eyeMap(ro + ev.xyy) - eyeMap(ro - ev.xyy),\n                          eyeMap(ro + ev.yxy) - eyeMap(ro - ev.yxy),\n                          eyeMap(ro + ev.yyx) - eyeMap(ro - ev.yyx)));\n}\n\nvec3 eyeLighting(in vec3 ro, in vec3 rd, in float dist) {\n    vec3 LIGHT_DIR = normalize(vec3(-0.1, 0.2, 6.0));\n    vec3 n = eyeNormalAt(ro);\n    vec3 colors = eyeColoring(ro + \n                              0.01 - 0.02 * \n                              texture(iChannel3, \n                                        vec2(0.5 * sin(iTime * 0.2),\n                                             0.5 * cos(iTime * 0.2))).rgb);\n    float diffC = max(0.0, dot(n, LIGHT_DIR));\n    float specC = pow(diffC, 10000.0);\n    vec3 fcolor = colors * (diffC + specC);\n    if (length(ro) > 3.001) {\n        mat3 mat = material();\n        fcolor = mix(mat[2], mat[1], diffC);\n        fcolor = mix(mat[0], fcolor, pow((length(ro) - 3.001) / (0.15), 0.1));\n    }\n    return fcolor;\n}\n\nvec3 skinLighting(in vec3 ro, in vec3 rd, in float dist) {\n    mat3 mat = material();\n\n    return mix(mat[1], texture(iChannel0, rd.xy).rrr, 0.1);\n}\n\n// =====  MARCHING =====\n\nvec3 marchEye(in vec3 ro, in vec3 rd) {\n    float dist = EPSILON;\n    float totalDist = 0.0;\n\n    for (int i = 0; i < MAX_RAY_ITERS; i++) {\n        if (dist < EPSILON ||\n            totalDist > MAX_RAY_DIST) {\n            break;\n        }\n\n        dist = eyeMap(ro);\n        totalDist += dist;\n        ro += dist * rd;\n    }\n\n    if (dist < EPSILON) {\n        return eyeLighting(ro, rd, totalDist);\n    } else {\n        // Eyelid\n        return skinLighting(ro, rd, totalDist);\n    }\n}\n\n\nvec4 eyeScene(in vec2 fragCoord) {\n    vec2 uv = ((fragCoord / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 tremor = 0.01 - 0.02 * \n                  texture(iChannel3, \n                            vec2(0.25 * sin(iTime * 0.1),\n                                 0.25 * cos(iTime * 0.1))).rgb;\n    vec3 cop = vec3(tremor.xy, 0.0) + vec3(0.0, 0.05, 3.35);\n    // vec3 cop = vec3(0.0, 0.0, 5.0);\n    vec3 target = vec3(0.0);\n    vec3 up = normalize(vec3(1.0, 13.0, 0.0));\n    \n    vec3 cDir = normalize(target - cop);\n    vec3 cRight = normalize(cross(cDir, up));\n    vec3 cUp = cross(cRight, cDir);\n    \n    vec3 rd = uv.x * cRight + uv.y * cUp + cDir;\n    \n    return vec4(marchEye(cop, rd), 1.0);\n}\n\n// =========================== SQUISH SCENE ========================\n\nvec3 squishColorRight(in vec2 pos) {\n    return vec3(pos.x * sin(iTime * 0.4) * 0.5 + 0.5,\n                pos.y * cos(iTime * 1.3) * 0.5 + 0.5,\n                length(pos) * sin(cos(iTime)) * 0.5 + 0.5);\n}\n\nvec3 squishColorLeft(in vec2 pos) {\n    return vec3(pos.y * sin(iTime * 0.2) * 0.5 + 0.5,\n                pos.x * cos(iTime * 0.9) * 0.5 + 0.5,\n                length(pos) * sin(cos(iTime)) * 0.5 + 0.5);\n}\n\nvec3 colorSampleLeft(in vec2 pos) {\n    float d = texture(iChannel2, vec2(pos.x + iTime * 0.5, pos.y)).r;\n    \n    if (d > 0.45) {\n        return squishColorLeft(pos);\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvec3 colorSampleRight(in vec2 pos) {\n    float d = texture(iChannel1, vec2(pos.x + iTime * 0.5, pos.y)).r;\n    \n    if (d < 0.3) {\n        return squishColorRight(pos);\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvec2 deform(in vec2 v) {\n    float r = length(v);\n    float a = atan(v.y, v.x);\n    return vec2(0.25 / abs(v.y), 0.2 * v.x / abs(v.y));\n}\n\nvec4 squishScene(in vec2 fragCoord) {\n    vec2 uv = ((fragCoord / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = uv.yx;\n    vec2 dv = deform(uv);\n    //vec2 dv = uv;\n    if (uv.y < 0.0) {\n        return vec4(colorSampleLeft(dv), 1.0);\n    } else {\n        return vec4(colorSampleRight(dv), 1.0);\n    }\n}\n\n// ================== PUT IT ALL TOGETHER =====================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if (sceneSelect() == 1) {\n       fragColor = terrainScene(fragCoord);\n    } else if (sceneSelect() == 2) {\n       fragColor = eyeScene(fragCoord);\n    } else {\n       fragColor = squishScene(fragCoord);\n    }\n}","name":"","description":"","type":"image"}]}