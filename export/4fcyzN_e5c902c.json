{"ver":"0.1","info":{"id":"4fcyzN","date":"1730302524","viewed":11,"name":"Fork Gingerbread custom","username":"vd03","description":"base code for ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","learning"],"hasliked":0,"parentid":"XftyR8","parentname":"Gingerbread Face Base"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PROCEDURAL GINGERBREAD FACE\n\nfloat faceSDF(vec3 queryPos)\n{\n    // Procedural Face Attributes\n    // These should all be values [0, 1]\n    float EYE_SEPARATION = 0.5;\n    float RIZZ = (sin(iTime)*0.5+0.5);\n    RIZZ = (RIZZ / ((((1.0/0.75) - 2.0)*(1.0 - RIZZ))+1.0));;\n    \n    float ball = sphereSDF(queryPos, vec3(0.0, 1.0, 0.0), 2.0);\n\n    float eyePosition = mix(0.5, 0.9, EYE_SEPARATION);\n    float eyeLeft = sphereSDF(bendPoint(queryPos,RIZZ), vec3(-eyePosition+0.9*RIZZ, 0.9+ 0.3*RIZZ, 2.0), 0.3);\n    float eyeRight = sphereSDF(queryPos, vec3(eyePosition, 0.9, 2.0), 0.3+0.05*RIZZ);\n    \n    float eyeBrowLeft = capsuleSDF(queryPos, vec3(-0.5, 1.5-0.3*RIZZ, 2.0), vec3(-0.9, 1.5-0.1*RIZZ, 2.0), 0.1);\n    float eyeBrowRight = capsuleSDF(queryPos, vec3(0.5, 1.5+0.15*RIZZ, 2.0), vec3(0.9, 1.5+0.1*RIZZ, 2.0), 0.1);\n\n    vec3 newPos = queryPos;\n    newPos.y = newPos.y*10.*RIZZ+newPos.y*(1.-RIZZ);\n    newPos.y = newPos.y-RIZZ*(newPos.x*newPos.x*10.);\n\n    float mouthBase = sphereSDF(bendPoint(newPos,-RIZZ*newPos.x*0.5), vec3(0.0, -0.2-0.5*RIZZ, 1.5), 0.5);\n\n    float creaseCapsule = capsuleSDF(queryPos, vec3(-0.7, -0.6, 0.4), vec3(-1.7, 0.5, 0.5), 0.6*RIZZ);\n    creaseCapsule = smoothUnion(creaseCapsule,capsuleSDF(queryPos, vec3(0.7, -0.6, 0.4), vec3(1.7, 0.5, 0.5), 0.6*RIZZ),0.1);\n    \n    float eyes = smoothUnion(eyeRight, eyeLeft, 0.1);\n    float eyebrows = smoothUnion(eyeBrowLeft, eyeBrowRight, 0.1);\n    float eyeStuff = smoothUnion(eyes, eyebrows, 0.0);\n    float faceBase = smoothSubtraction(mouthBase, ball, 0.05);\n    return smoothSubtraction(creaseCapsule,smoothUnion(faceBase, eyeStuff, 0.1),0.1);\n}\n\n\nfloat sceneSDF(vec3 queryPos) \n{\n    float model1 = faceSDF(queryPos);\n    \n    return model1;\n\n    float plane = planeSDF(queryPos, 0.0);\n        \n    //return smoothUnion(plane, smoothUnion(smoothUnion(model2, model1, 0.25), model3, 0.25), 0.25);\n}\n\n\nRay getRay(vec2 uv) {\n    Ray ray;\n    \n    float len = tan(3.14159 * 0.125) * distance(EYE, REF);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), REF - EYE));\n    vec3 V = normalize(cross(H, EYE - REF));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = REF + uv.x * H + uv.y * V;\n    vec3 dir = normalize(p - EYE);\n    \n    ray.origin = EYE;\n    ray.direction = dir;\n    return ray;\n}\n\nIntersection getRaymarchedIntersection(vec2 uv)\n{\n    Ray ray = getRay(uv);\n    Intersection intersection;\n    \n    vec3 queryPoint = ray.origin;\n    for (int i=0; i < MAX_RAY_STEPS; ++i)\n    {\n        float distanceToSurface = sceneSDF(queryPoint);\n        \n        if (distanceToSurface < EPSILON)\n        {\n            \n            intersection.position = queryPoint;\n            intersection.normal = vec3(0.0, 0.0, 1.0);\n            intersection.distance = length(queryPoint - ray.origin);\n            \n            return intersection;\n        }\n        \n        queryPoint = queryPoint + ray.direction * distanceToSurface;\n    }\n    \n    intersection.distance = -1.0;\n    return intersection;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 getSceneColor(vec2 uv)\n{\n    Intersection intersection = getRaymarchedIntersection(uv);\n    \n    DirectionalLight lights[3];\n    vec3 backgroundColor = vec3(0.);\n   \n    \n    lights[0] = DirectionalLight(normalize(vec3(10.0, 10.0, 15.0)),\n                                 SUN_KEY_LIGHT);\n    lights[1] = DirectionalLight(vec3(0., 1., 0.),\n                                 SKY_FILL_LIGHT);\n    lights[2] = DirectionalLight(normalize(-vec3(15.0, 0.0, 10.0)),\n                                 SUN_AMBIENT_LIGHT);\n    backgroundColor = SUN_KEY_LIGHT;\n    \n    vec3 albedo = vec3(0.5);\n    vec3 n = estimateNormal(intersection.position);\n        \n    vec3 color = albedo *\n                 lights[0].color *\n                 max(0.0, dot(n, lights[0].dir));\n    \n    if (intersection.distance > 0.0)\n    { \n        for(int i = 1; i < 3; ++i) {\n            color += albedo *\n                     lights[i].color *\n                     max(0.0, dot(n, lights[i].dir));\n        }\n    }\n    else\n    {\n        color = vec3(0.5, 0.7, 0.9);\n    }\n        color = pow(color, vec3(1. / 2.2));\n        return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Make symmetric [-1, 1]\n    uv = uv * 2.0 - 1.0;\n\n    // Time varying pixel color\n    vec3 col = getSceneColor(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Smooth combination and SDF geometry operators attributed to Inigo Quilez\n// https://iquilezles.org/ @iquilezles\n\nconst int MAX_RAY_STEPS = 128;\nconst float FOV = 45.0;\nconst float EPSILON = 1e-2;\n\nconst vec3 EYE = vec3(0.0, 0.0, 6.0);\nconst vec3 REF = vec3(0.0, 1.0, 0.0);\nconst vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);\nconst vec3 WORLD_RIGHT = vec3(-1.0, 0.0, 0.0);\nconst vec3 WORLD_FORWARD = vec3(0.0, 0.0, 1.0);\nconst vec3 LIGHT_DIR = vec3(0.6, 1.0, 1.0) * 1.5;\n\n// Want sunlight to be brighter than 100% to emulate\n// High Dynamic Range\n#define SUN_KEY_LIGHT vec3(1.0, 0.5, 0.1) * 1.5\n// Fill light is sky color, fills in shadows to not be black\n#define SKY_FILL_LIGHT vec3(0.7, 0.2, 0.7) * 0.2\n// Faking global illumination by having sunlight\n// bounce horizontally only, at a lower intensity\n#define SUN_AMBIENT_LIGHT vec3(0.6, 1.0, 0.4) * 0.2\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Intersection \n{\n    vec3 position;\n    vec3 normal;\n    float distance;\n    int material_id;\n};\n\nstruct DirectionalLight\n{\n    vec3 dir;\n    vec3 color;\n};\n\nfloat sphereSDF(vec3 query_position, vec3 position, float radius)\n{\n    return length(query_position - position) - radius;\n}\n\nfloat planeSDF(vec3 queryPos, float height)\n{\n    return queryPos.y - height;\n}\n\nfloat capsuleSDF( vec3 queryPos, vec3 a, vec3 b, float r )\n{\n  vec3 pa = queryPos - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat smoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\nvec3 bendPoint(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}","name":"Common","description":"","type":"common"}]}