{"ver":"0.1","info":{"id":"ddVXz3","date":"1681767298","viewed":114,"name":"capsulistica!","username":"valalalalala","description":"Variations on the capsule sdf\nmouse x controls parameters to the variations (power and bulgeAt)\nmouse y controls the larger radius","likes":11,"published":1,"flags":16,"usePreview":0,"tags":["raymarching","sdf","capsule"],"hasliked":0,"parentid":"ctBXzm","parentname":"Grundschattierer"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        ////////////////////////////////////////////////////////////////////\n       //                                                                 //\n      // \"capsulistica!\"                                                 ///\n     //                                                                 ////\n    // Variations on the capsule sdf                                   // //\n   // Creative Commons Attribution-NonCommercial-ShareAlike           //  //\n  // 3.0 Unported License                                            //   //\n //                                                                 //   //\n/////////////////////////////////////////////////////////////////////   //\n//                                                                 //  //\n//                                                                 // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2023                               ////\n//                                                                 ///\n/////////////////////////////////////////////////////////////////////\n\nfloat tTime;\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p) -r;\n}\n\nfloat peggy(vec3 p, vec3 a, vec3 b, float r1, float r2, float power ) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    float r = mix( r1, r2, pow( t, power ) );\n    return length((ab*t + a) - p) - r;\n}\n\nfloat bulge(vec3 p, vec3 a, vec3 b, float r1, float r2, float bulgeAt ) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    float d = pow( abs( t - bulgeAt ), 2. );\n    return length((ab*t + a) - p) - mix( r1, r2, d );\n}\n\nvec2 minnie() {\n    return mix(\n        abs( trig( tTime * 10. ) ),\n        iMouse.xy / iResolution.xy,\n        step( EPSILON, max( iMouse.z, iMouse.w ) )\n    );\n}\n\nMapped map( vec3 p ) {\n    vec2 m = minnie();\n    \n    const float f = .88, g = .66, i = f * g *.66;\n    float r1 = .022, r2 = r1 + .22 * m.y * .77;\n    \n    float power = m.x * 4.;\n    float bulgeAt = m.x;\n\n    vec3 a = f * vec3( -1.44, g, ZED );\n    vec3 b = a * V101.xzz;\n    \n    Mapped result = Mapped( 3e3, -EINS );\n    for ( int c = 0 ; c < 4 ; c++, a.y -= i, b.y -= i ) {\n        float id = float( c );\n        Mapped now;\n        switch( c ) {\n            case 0:  now = Mapped( capsule( p, a, b, r2 ), id ); break;\n            case 1:  now = Mapped( peggy( p, a, b, r1, r2, power ), id ); break;\n            case 2:  now = Mapped( bulge( p, a, b, r1, r2, bulgeAt ), id ); break;\n            default: now = Mapped( bulge( p, a, b, r2, r1, bulgeAt ), id ); break;\n        }\n        mino( result, now );\n    }  \n    \n    return result;\n}\n\nMAP_TIME\n\nvec3 matte( vec3 n, vec3 dir, float type ) {\n    return dot( n, -dir ) * colorF( type * .44 );\n}\n\nvec3 textme( vec3 dir ) {\n    return texture( iChannel0, dir + tTime *.066 ).rgb;\n}\n\nvec3 shiny( vec3 p, vec3 n, vec3 dir, float type ) {\n    n += 3.3 * noise_iq( 3.3 * order( abs( p + tTime ) ).xy );\n    float l = dot( n, -dir );\n    vec3 color = l * colorF( type * .44 );\n\n    vec3 rDir = reflect( dir, n );\n    float fresnel = clamp( ZED, 1.88, pow( EINS + l, 5. ) );\n\n    return mix( color, textme( rDir ), fresnel );\n}\n\nvec3 demo( in vec2 st ) {\n    INIT_SHADER_ENVIRONMENT(st)\n    \n    tTime = triangle( iTime * .2 );\n  \n    vec3 color;\n    Ray ray = rayToggle( env, makeRay( env ), iChannel1 );\n    Marched marched = march( ray );\n    \n    if ( marched.hit ) {\n        vec3 p = marched.p;\n        vec3 n = mapNormal( p, marched.depth );\n        \n        float type = marched.mapped.type;\n        \n        if ( keyToggle( 32, iChannel1 ) ) {\n            color = matte( n, ray.dir, type );\n        } else {            \n            color = shiny( p, n, ray.dir, type );\n        }\n    } else {\n        color = textme( ray.dir ) * .33;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 result, in vec2 st ){    \n    result = vec4( demo( st ), 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////\n\nconst float TAU = 99733. / 15873., ZED = .0, HALB = .5, EINS = 1., PI  = HALB * TAU;\n\nconst vec3 V101 = vec3( -EINS, ZED, +EINS );\nconst vec3 V000 = vec3( ZED );\n\nconst float EPSILON = .001, ZFAR = 199., VIEW_DISTANCE = 5.5;\n\nconst vec3 MAGIC = vec3( TAU * 3.3, 99.733, 15873. );\n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) / min( resolution.x, resolution.y );\n}\n\nfloat absMod( float f, float m ) {\n    return abs( mod( f, m ) - m *.5 );\n}\n\nfloat scalo( float f, float s ) {\n    return f * s - .5 * s;\n}\n\nfloat invert( float f ) {\n    return 1. - f;\n}\n\nfloat modScale( float f, float s ) {\n    return mod( f, s ) / s;\n}\n\nfloat triangle( float x ) {\n    return 4. * abs( modScale( x, TAU ) - .5 ) -1.;\n}\n\n#define saturate(x) clamp(x, ZED, EINS)\n#define SCALE_AND_OFFSET(v,o)   (o + v * o) \n\n/////////////////////////////////////////////////////////////////////\n\nfloat magicFloat( vec2 uv ) {\n    return dot( uv, MAGIC.xy );\n}\n\n// really a lot like just regular fract based hash :-P\nfloat triangleHash( float f ) {\n    return fract( triangle( f * MAGIC.x ) * f * MAGIC.z * .133 );\n}\n\nfloat triangleHash( vec2 uv ) { \n    return triangleHash( magicFloat( uv ) );\n}\n\n////////////////////////////////////////////////////////////////\n// IQ's https://www.shadertoy.com/view/XdXGW8, gradient - 2D \nvec2 hash( in vec2 p ) {\n    return vec2( triangleHash( p.xy ), triangleHash( p.yx ) );\n}\n\nfloat noise_iq( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n/////////////////////////////////////////////////////////////////////\n\n#define qcos( x ) triangle( x )\n#define qsin( x ) triangle( x + TAU * .25 )\n\nvec2 trig( float angle ) {\n    return vec2( cos( angle ), sin( angle ) );\n}\n\nvec3 colorF( float f ) {\n    return vec3( f, SCALE_AND_OFFSET( trig( TAU * f ), .5 ) );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec3 order( vec3 p )  {\n    vec3 q = vec3( min( p.x, min( p.y, p.z ) ), .0, max( p.x, max( p.y, p.z ) ) );\n    q.y = ( p.x + p.y + p.z ) - ( q.x + q.z );\n    return q;  \n}\n\n/////////////////////////////////////////////////////////////////////\n\nbool keyToggle( int key, sampler2D keyboardChannel ) {\n    return .0 < texelFetch( keyboardChannel, ivec2(key,2), 0 ).x;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nconst int MOUSE_UP = -1, MOUSE_DOWN = 1, MOUSE_CLICKED = 2;\n\nstruct ShadEnv {\n    vec3      iResolution;           // viewport resolution (in pixels) \n    float     iTime;                 // shader playback time (in seconds)\n    float     iTimeDelta;            // render time (in seconds)\n    float     iFrameRate;            // shader frame rate\n    int       iFrame;                // shader playback frame\n    float     iChannelTime[4];       // channel playback time (in seconds)\n    vec3      iChannelResolution[4]; // channel resolution (in pixels) \n    vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\n    vec4      iDate;                 // (year, month, day, time in seconds)\n    float     iSampleRate;           // sound sample rate (i.e., 44100)\n    vec2      st;                    // aka fragCoord\n    vec2      uv;\n    vec2      ms;\n    vec2      trigTime;\n    int       mouseStatus;\n    float     pixel1;\n};\n\n#define INIT_SHADER_ENVIRONMENT(st) ShadEnv env = ShadEnv( iResolution, iTime, iTimeDelta, iFrameRate, iFrame, iChannelTime, iChannelResolution, iMouse, iDate, iSampleRate, st, V101.xy, V101.xy, V101.xy, MOUSE_UP, EINS );     init( env ); \n\nvoid init( inout ShadEnv env ) {\n    env.uv = pixelToUv( env.st, env.iResolution.xy );\n    env.trigTime = trig( env.iTime );\n    env.mouseStatus = MOUSE_UP + int( 2. * step( 3e-3, env.iMouse.z ) + step( 3e-3, env.iMouse.w ) );\n    env.ms = pixelToUv( env.iMouse.xy, env.iResolution.xy ) * step( 3e-3, env.iMouse.z + env.iMouse.w );\n    env.pixel1 = max( EINS / env.iResolution.x, EINS / env.iResolution.y ); \n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Ray { \n    vec3 eye; \n    vec3 dir; \n};\n\nRay rayToggle( in ShadEnv env, in Ray ray, in sampler2D keyboardChannel ) {\n    if ( keyToggle( 49, keyboardChannel ) ) { // 1 = front\n        ray.eye = VIEW_DISTANCE * V101.yyz;\n        ray.dir = normalize( vec3( env.uv, -EINS ) - ray.eye );\n    } else \n    if ( keyToggle( 50, keyboardChannel ) ) { // 2 = left\n        ray.eye = VIEW_DISTANCE * V101.xyy;\n        ray.dir = normalize( vec3( EINS, env.uv.yx ) - ray.eye );\n    } else \n    if ( keyToggle( 51, keyboardChannel ) ) { // 3 = top\n        ray.eye = VIEW_DISTANCE * V101.yzy;\n        ray.dir = normalize( vec3( env.uv.x, -EINS, -env.uv.y ) - ray.eye );\n    }\n    return ray;\n}\n\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nRay makeRay( in ShadEnv env, float depth ) {\n    vec2 t = trig( env.ms.x * PI );\n    vec3 eye = depth * vec3( t.y, sin( env.ms.y * 1.88 ), t.x );    \n   \n    eye = depth * V101.yyz;\n    \n    vec3 dir = normalize( makeCamera( eye, V000, ZED ) * vec3( env.uv, EINS ) - eye );\n    \n    return Ray( eye, dir );\n}\n\nRay makeRay( inout ShadEnv env ) {\n    return makeRay( env, VIEW_DISTANCE );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Mapped {\n    float depth;\n    float type;\n};\n\nstruct Marched {\n    vec3 p;\n    float depth;\n    bool hit;\n    Mapped mapped;\n};\n\nconst int MARCH_CONTINUE = 0, MARCH_SUCCESS = 1, MARCH_FAILED = 2;\n\n///////////////////////////////////////\n\nMapped newMapped( float depth ) { return Mapped( depth, -EINS ); }\nMapped newMapped() { return newMapped( 3e11 ); }\n\nMarched newMarch( Ray ray ) {\n    return Marched( ray.eye, ZED, false, newMapped( ZED ) );\n}\n\n///////////////////////////////////////\n\nvoid mino( inout Mapped m, in Mapped q ) {\n    if ( q.depth < m.depth ) {\n        m = q;\n    }\n}\n\n///////////////////////////////////////\n\nint _marchStep( in Ray ray, in float side, inout Marched marched, Mapped mapped ) {\n    marched.mapped = mapped;\n    marched.mapped.depth *= side;\n    marched.depth += marched.mapped.depth;\n        \n    if ( abs( marched.mapped.depth ) < EPSILON ) {\n        marched.hit = true;\n        return MARCH_SUCCESS;\n    }\n        \n    if ( marched.depth > ZFAR ) return MARCH_FAILED;\n    \n    marched.p = ray.eye + marched.depth * ray.dir;\n    return MARCH_CONTINUE;\n}\nMarched _marchMissed( in Marched marched ) {\n    marched.depth = -abs( marched.depth );\n    return marched;\n}\n\n///////////////////////////////////////\n\nMapped map( vec3 p ); // implement this, then use this macro: MAP_TIME\n\n#define MAP_TIME \\\nfloat mapDepth( vec3 p ) { return map( p ).depth; } \\\nvec3 mapNormal(vec3 p,float d) {\\\n    mat3 k = mat3(p,p,p) - mat3( d * EPSILON ); \\\n    return normalize( mapDepth(p) - vec3( mapDepth(k[0]), mapDepth(k[1]), mapDepth(k[2])) ); \\\n} \\\nvec3 mapNormal(vec3 p) { return mapNormal(p,EPSILON); }\\\nMarched march( in Ray ray, in float side ) { \\\n    Marched marched = newMarch( ray ); \\\n    for( int i = 0 ; i < int( ZFAR ) ; i++ ) { \\\n        switch( _marchStep( ray, side, marched, map( marched.p ) ) ) { \\\n            case MARCH_SUCCESS: return marched; \\\n            case MARCH_FAILED: i = int(ZFAR); \\\n        } \\\n    } \\\n    return _marchMissed( marched ); \\\n} \\\nMarched march( Ray ray ) { return march( ray, EINS ); }\n\n/////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}