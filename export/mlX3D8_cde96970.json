{"ver":"0.1","info":{"id":"mlX3D8","date":"1671677553","viewed":287,"name":"Frozen Altar","username":"sjz1","description":"A simple frozen altar\nMy own pathtracer:https://www.shadertoy.com/view/ddjXRc\nyou can just put you sdf into it and render a perfect image","likes":15,"published":1,"flags":32,"usePreview":1,"tags":["3d","reflection","sdf","4k","refraction","water","landscape","pathtrace","ice","ggx","altar"],"hasliked":0,"parentid":"ddjXRc","parentname":"Universal Path Tracer"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float gamma=2.2;\n\nvec3 ACESFilm( vec3 x )\n{\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    return clamp((x*(tA*x+tB))/(x*(tC*x+tD)+tE),0.0,1.0);\n}\n\nvec2 uv00;\nvec4 Load(){\n    return texture(iChannel0,uv00);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv00=uv;\n    vec3 tc=Load().xyz;\n    tc=ACESFilm(tc);tc=pow(tc,vec3(gamma));\n    fragColor=vec4(tc,1);\n   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*layout (rgba32f,binding=0) uniform image2D input_;\nlayout (rgba32f,binding=1) uniform image2D output_;\nlayout (rgba32f,binding=2) uniform image2D data_;\nlayout (binding=0) uniform sampler2D iChannel0;\nuniform float iTime,scale;\nuniform int iFrame,iOffset,iW,iH;\nuniform vec4 Position2D;\nuniform vec3 Position;\nuniform mat4 Eye_Mat;\n*/\nconst float PI=3.1415926535;\n\nivec2 lp;\nvoid F(float x,float y);\n/*vec4 Load(ivec2 pos){\n    return imageLoad(input_,pos);\n}\nvoid Store(ivec2 pos,vec4 data0){\n    imageStore(output_,pos,data0);\n}\nvec4 Load(){\n    return imageLoad(input_,lp);\n}\nvoid Store(vec4 data0){\n    imageStore(output_,lp,data0);\n}\nvoid main(){\n    lp=ivec2(gl_GlobalInvocationID.xy);\n    Store(lp,Load(lp));\n    F(2.0*(lp.x/float(iW)-0.5),2.0*((lp.y+iOffset*iH)/float(iW)-0.5));\n}\n*/\n\n\n/*dvec4 Double(vec4 A){\ndvec4 temp;\ntemp.x=double(A.x);\ntemp.y=double(A.y);\ntemp.z=double(A.z);\ntemp.w=double(A.w);\nreturn temp;\n}\nvec4 Float(dvec4 A){\nvec4 temp;\ntemp.x=float(A.x);\ntemp.y=float(A.y);\ntemp.z=float(A.z);\ntemp.w=float(A.w);\nreturn temp;\n}\n*/\n\n/*vec3 ToRGB(float _A_,float _B_,vec3 _RGB_,vec3 _RGB2_){\n    float _co_=max(_A_+1.0- log(.5*log(_B_)),0.);\n    _co_ = sqrt(_co_/256.0);\n    return _RGB2_*vec3(.5+.5*cos(6.2831*_co_+_RGB_.x),.5+.5*cos(6.2831*_co_+_RGB_.y),.5+.5*cos(6.2831*_co_+_RGB_.z));\n}\nvec2 cMul(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvec2 cLog(vec2 a) {\n\tfloat b =  atan2(a.x,a.y);\n\tif (b<0.0) b+=2.0*3.1415926535;\n\treturn vec2(log(length(a)),b);\n}\nvec2 cExp(vec2 z) {\n\treturn exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\nvec2 cPow(vec2 z, vec2 a) {\n\treturn cExp(cMul(cLog(z), a));\n}\nvec2 cDiv(vec2 a, vec2 b){\n  float d = dot(b,b);\n  return vec2(dot(a,b),a.y*b.x-a.x*b.y)/d;\n}\n\nfloat hash( float n )\n{\n    return fract( n*17.5*fract( n*0.3183099 ) );\n}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*(3.0-2.0*w);\n    float n = 176.74*p.x + 317.0*p.y ;\n    return mix( mix(hash(n+  0.0),hash(n+  1.0),u.x),\n                     mix(hash(n+317.07),hash(n+318.07),u.x),u.y);   \n}\nmat3 randM(vec2 pos,float b){\n    pos=floor(pos);mat3 m0;\n    for(int i=0;i<=2;i++)\n        for(int j=0;j<=2;j++)\n            m0[i][j]=b==0.?floor(noise(pos+vec2(i,j))*2.):noise(pos+vec2(i,j))+max(b,0.)*float(i)+max(-b,0.)*float(j);\n    return m0;\n}\nvec2 CellNoise(vec2 pos,int smooth_){\n    vec2 p0;p0=floor(pos);vec2 p1;\n    mat3 m0x,m1x,m0y,m1y,m0,m1;\n    m0x=randM(p0,1.);m0y=randM(p0,-1.);m0=randM(p0,0.);\n    m0x+=p0.x-1.;m0y+=p0.y-1.;\n    int step=smooth_;\n    float d00=1e10;\n    for(int k=0;k<step;k++)\n    {\n        p1=floor(pos*pow(3.,float(k)+1.));\n        m1x=randM(p1+vec2(60.90,8.),1.);m1y=randM(p1,-1.);\n        float s0=pow(3.,-float(k)-1.);\n        m1x-=1.;m1x*=s0;m1x+=p1.x*s0;\n        m1y-=1.;m1y*=s0;m1y+=p1.y*s0;\n        for(int i=0;i<=2;i++){\n            for(int j=0;j<=2;j++){\n                vec2 a=vec2(m1x[i][j],m1y[i][j]);\n                float d=1000.;\n                for(int i0=0;i0<=2;i0++){\n                    for(int j0=0;j0<=2;j0++){\n                        vec2 b=vec2(m0x[i0][j0],m0y[i0][j0]);\n                        float d1=distance(a,b);float tmp=float(d<d1);\n                        d=min(d,d1);m1[i][j]=tmp*(m1[i][j]-m0[i0][j0])+m0[i0][j0];\n                    }}\n\n            }}\n        m0x=m1x;m0y=m1y;m0=m1;\n    }\n    float tmp0=0.;float d=1000.;\n    for(int i=0;i<=2;i++){\n        for(int j=0;j<=2;j++){\n            vec2 a=vec2(m1x[i][j],m1y[i][j]);\n            float d1=distance(a,pos);float tmp=float(d<d1);\n            d=min(d,d1);tmp0=tmp*(tmp0-m1[i][j])+m1[i][j];\n        }}\n    return vec2(tmp0,d);\n}*/\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 rgb2hsv(vec3 c){\n\n    const vec4 k=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);\n    vec4 p=mix(vec4(c.bg,k.wz),vec4(c.gb,k.xy),step(c.b,c.g));\n    vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));\n    float d=q.x-min(q.w,q.y);\n    return vec3(abs(q.z+(q.w-q.y)/(6.*d+0.001)),d/(q.x+0.001),q.x);\n\n}\nvec2 rot(vec2 a,float theata){\n    return a.xx*vec2(cos(theata),sin(theata))+a.yy*vec2(-sin(theata),cos(theata));\n}\nvec3 rot(vec3 a,vec3 range){\n    a.yz=rot(a.yz,range.x);\n    a.xz=rot(a.xz,range.y);\n    a.xy=rot(a.xy,range.z);\n    return a;\n}\nfloat mix2(float A,float B,float x){\n    return (B-A)*x+A;\n}\nvec4 near(vec4 A,vec3 B){\n    float tmp1=min(A.w,B.y);\n    float tmp=mix2(A.z,B.z,float(B.y<0.));\n    B.y=abs(B.y);\n    return vec4(mix(A.xy,B.xy,float(A.y>B.y)),tmp,tmp1);\n}\n\nvec2 rotClamp(vec2 pos,int n){\n    float alpha=-atan(pos.x,pos.y);\n    float tmp=PI/float(n);\n    return abs(rot(pos,-alpha+mod(alpha,2.*tmp)-tmp));\n}\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat mix(float A,float B,float x){\n    float s=0.5+0.5*cos(-x*3.1415926);\n    return B*(1.-s)+A*s;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdSphere(vec3 p,float r){\n    return length(p)-r;\n}\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n  p=abs(p)-b;\n  vec3 q=abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec3 F00(vec3 a,vec3 b,int k,float size_0,vec3 n){\n    vec3 p0=size_0*pow(2.8284,-float(k))*n;\n    vec3 p1=p0;float d0=distance(a+p0,b);\n    vec3 p2=p0;\n    const float s[3]=float[3](1.,1.7,1.);\n    const float PI_d_6=PI/6.;\n    for(int i=-1;i<2;i++){\n        p0.xzy=vec3(rot(p2.xz,float(i)*PI_d_6),p2.y)*s[i+1];\n        float d1=distance(a+p0,b);\n        bool t=d1<d0;\n        d0=t?d1:d0;p1=t?p0:p1;\n    }\n    return p1;\n}\nvec3 F01(vec3 a,vec3 b,int k,float size_0,vec3 n){\n    vec3 p0=size_0*pow(3.1383,-float(k))*n;\n    vec3 p1=p0;float d0=distance(a+p0,b);\n    vec3 p2=p0;\n    const float PI_d_1_5=PI/3.;\n    for(int i=0;i<6;i++){\n        p0.xz=rot(p2.xz,float(i)*PI_d_1_5);\n        float d1=distance(a+p0,b);\n        bool t=d1<d0;\n        d0=t?d1:d0;p1=t?p0:p1;\n    }\n    return p1;\n}\nfloat line(vec3 a,vec3 p,float R){\n\tfloat la=length(a);\n\tp.xz=rot(p.xz,-atan(a.z,a.x));\n\treturn sdRhombus(p-vec3(la*0.5,0,0),la,R*2.,R*0.5,0.)-R*0.1;\n\n}\nfloat FlakeDE(vec3 p,float size_0){\n    p=abs(p);\n    //p.xz=mix(p.xz,p.zx,float(p.x<p.z));\n    p.xz=rot(p.xz,PI/6.);\n    vec3 n=normalize(F01(vec3(0),p,0,size_0,vec3(1,0,0)));;\n    vec3 p0=vec3(0);float d0=10000.;vec3 p1=p0;\n    for(int i=0;i<4;i++){\n        p0+=F00(p0,p,i,size_0,n);\n        d0=min(line(p0-p1,p-p1,size_0*(pow(2.,float(-i-4)))),d0);\n        n=normalize(p0-p1);\n        p1=p0;\n    }\n    return d0;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#version 430 core\n//layout (local_size_x=####,local_size_y=####) in;//#### means default pixel(or workspace) size\n\n//#include \"common.nml\"\n\n\n\nconst float EPSILONS =0.00001;\nconst float EPSILONS_MIN = 0.001;\nconst int MaxReflect=6;\nconst int MaxRayStep=500;\nconst float Far=500.0;\nconst float FogS=0.125;\nconst float FogStart=400.0;\nconst float SSAA=16.;\nconst float ShadowOffset=0.;\nconst vec2 DOF_Pos=vec2(0);\nconst float DOF_R=0.05;\nconst float FOV=0.5;\nconst float Marching_S=1.;\nconst float cut=32.;\n\n#define Rayleigh 1.\n#define Mie 1.\n#define RayleighAtt 1.\n#define MieAtt 1.2\n\nfloat g = -0.99;\n\n#if 1\nvec3 _betaR = vec3(1.95e-2, 1.1e-1, 2.94e-1); \nvec3 _betaM = vec3(4e-2, 4e-2, 4e-2);\n#else\nvec3 _betaR = vec3(6.95e-2, 1.18e-1, 2.44e-1); \nvec3 _betaM = vec3(4e-2, 4e-2, 4e-2);\n#endif\n\nvec3 Position_00;\n\nvec4 colors[MaxReflect];\nvec3 LightColors[MaxReflect];\nfloat rs0[MaxReflect];\nvec3 rc0[MaxReflect];\nvec3 fog0[MaxReflect+1];\nfloat Gs0[MaxReflect+1];\nfloat iFrame_;\nstruct object{\n    float d;float d2;int id;int i_id;\n}obj;\nobject hit;\nvec3 pos_0;\n\nbool enablewater=true;\nvec4 ObjectLight(vec3 ro,vec3 rd,float R,vec3 n,vec3 center,float sR,float rs,float ra,int id);\n\nfloat rand(vec2 pos){\n    return fract(sin(dot(pos.xy*0.123 ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat randT2(vec2 pos){\n    pos+=float(iFrame);\n    return fract(sin(dot(pos.xy*0.123 ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand3(vec3 pos){\n    return fract(sin(dot(pos*0.123 ,vec3(12.9898,78.233,233.2342))) * 43758.5453);\n}\n\n//iq's noise\n//https://www.shadertoy.com/view/MdX3Rr\n//I simply use it to simulate waves\n#define SC (1.0)\n\n#define USE_SMOOTH_NOISE 0   // enable to prevent discontinuities\n\nconst mat2 m3 = mat2(0.8,-0.6,0.6,0.8);\n// value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    #if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #else\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #endif\n\n#if 0\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel1, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel1, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel1, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel1, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel1, fract((p+vec2(0.5,0.5))/256.0), 0.0 ).x;\n\tfloat b = textureLod( iChannel1, fract((p+vec2(1.5,0.5))/256.0), 0.0 ).x;\n\tfloat c = textureLod( iChannel1, fract((p+vec2(0.5,1.5))/256.0), 0.0 ).x;\n\tfloat d = textureLod( iChannel1, fract((p+vec2(1.5,1.5))/256.0), 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrainL( in vec2 x )\n{\n\tvec2  p = x*0.003/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<5; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m3*p*2.0+vec2(1,25);//a little different\n    }\n\n    #if USE_SMOOTH_NOISE==1\n    a *= 0.9;\n    #endif\n\treturn SC*120.0*a;\n}\n\n\n//#include \"World SDF.nml\"\nvec3 lightDir=normalize(vec3(0.175,-0.05,-.5));//Sun light direction\n\nobject DE(vec3 pos) {\n    vec4 hit0=vec4(-1,Far,-1,Far);\n\n    vec3 pos0=pos;object hit1;\n\n    hit0=near(hit0,vec3(6,pos0.y+terrainL(pos0.xz*80.)*0.002+10.,2));\n    pos0=rot(pos0,vec3(PI/2.,0,0));\n    pos0.z-=10.;\n    pos0=rot(pos0,vec3(0,PI/6.,0));\n    pos0.xz=rotClamp(pos0.xz,6);pos0.z-=5.;\n    hit0=near(hit0,vec3(4,sdRhombus(pos0,2.,5.,0.1,0.),1));\n    \n    pos0=pos;\n    pos0.xz=rotClamp(pos0.xz,6);pos0.z-=13.;pos0.y+=7.;\n    \n    \n    hit0=near(hit0,vec3(4,min(min(sdBox(pos0+vec3(0,0,1),vec3(12,5,12)),sdBox(rot(pos0+vec3(0,0,-9),vec3(-0.4,0,0)),vec3(9,3.,5)))\n        ,sdRhombus(rot(pos0+vec3(0,6,-5),vec3(PI/2.,0,0)),5.,15.,0.5,0.)),1));\n    pos0=pos;pos0.xz=rot(pos0.xz,0.);\n    pos0.xz=rotClamp(pos0.xz,6);pos0.z-=13.;pos0.y+=7.;\n    pos0.z-=25.;\n    hit0=near(hit0,vec3(2,min(sdBox(pos0,vec3(1,10,1)),max(sdBox(pos0,vec3(10)),sdTorus(pos0+vec3(0,0,20),vec2(20,1)))),1));\n    pos0.z-=15.;\n    hit0=near(hit0,vec3(2,sdRhombus(rot(pos0,vec3(PI/2.,0,0)),5.,20.,0.5,0.),1));\n    pos0=pos;\n    \n    \n    pos0.xz=abs(pos0.xz);\n    pos0.xz=rot(pos0.xz,PI/4.);\n    pos0.z-=5.;\n    pos0.y+=2.82;\n    hit0=near(hit0,vec3(3,sdRhombus(pos0,1.,4.,0.25,0.),1));\n\n    //pos0.xz=rotClamp(pos.xz,6)-vec2(0,20);//\n    pos0.xz=rotClamp(rotClamp(pos.xz,8)+vec2(0,-20),8)-vec2(0,0.25);\n    pos0.y=pos.y;\n    hit0=near(hit0,vec3(1,sdBox(pos0+vec3(0,0,0),vec3(1.,10,1.)),1));\n    pos0.z-=1.;\n    vec3 tmp=pos0;\n    pos0.y+=2.2;\n    pos0.yz=rot(pos0.yz,-0.025);\n    //pos0.xz=rotClamp(pos0.xz,8);\n    hit0=near(hit0,vec3(1,sdRhombus(pos0,0.75,3.,0.25,0.),1));\n    pos0.y-=0.1;\n    pos0.z-=3.;\n    pos0.xz=rotClamp(pos0.xz,6);\n    hit0=near(hit0,vec3(1,sdRhombus(pos0,0.25,1.75,0.125,0.),1));\n    pos0=tmp;\n    pos0.yz=rot(pos0.yz,PI/2.);\n    hit0=near(hit0,vec3(1,sdRhombus(pos0,0.5,4.,0.25,0.),1));\n    \n    hit1.id=int(hit0.x);hit1.d=hit0.y;\n    hit1.d2=hit0.w;hit1.i_id=int(hit0.z);\n    return hit1;\n}\nvec4 color(vec3 pos,vec3 nor,object o){\n    if(o.id==4) return vec4(0.5,0.7,0.9,0.1);\n    if(o.id==2) return vec4(0.95,0.95,0.95,0.1);\n    if(o.id==3) return clamp(vec4(sign(pos.x),sign(pos.z),0.5,0.1),0.,1.);\n    if(o.id==1) return vec4(0.9,0.95,0.95,0.025);\n    if(o.id==6) return vec4(0.95,0.95,0.95,0);\n    return vec4(0.5,0.5,0.5,1);\n}\nvec4 Material(vec3 pos,object o){\n    if(o.id==4)   return vec4(0.05*exp(-5.*FlakeDE(vec3(pos.x,0,pos.z),10.))+exp(-0.1*distance(pos,vec3(0,0,0))),1.301,0,0);\n    if(o.id==3)   return vec4(5,1.301,0,0);\n    if(o.id==2)   return vec4(0,1.301,0,0);\n    if(o.id==1)   return vec4(0,1.301,0,0);\n    if(o.id==6)   return vec4(0,1.301,0,0);\n    return vec4(0,3,2,0);\n}\nvec4 InsideMaterial(vec3 pos,object o){\n    if(o.i_id==1)   return vec4(1.301,0,0,0);\n    if(o.i_id==2)   return vec4(1.301,0.04,0.04,0.04);\n    return vec4(1,vec3(0));\n}\nvec3 RC(vec3 pos,object o){\n    if(o.id==2) return vec3(0,1,0.2);\n    if(o.id==1) return vec3(0,1,0.5);\n    return vec3(0,1,0.);\n}\nvec4 InsideFog(vec3 pos,object o){//medium fog(scattering)\n    //scattering arguments\n    return vec4(0);\n}\n\nvec4 centers[1]=vec4[1](vec4(0.));//vec4(pos,Sphere_R)\nint ids[1]=int[1](1);\n//#define EnableObjectLight\nvec4 getObjectLight(vec3 ro,vec3 rd,float R,vec3 n,float rs,float ra){\n#ifdef EnableObjectLight\n#else\n    return vec4(0);\n#endif\n    vec4 color=vec4(0);\n    int id=int(clamp(floor(rand3(ro+float(iFrame))*float(ids.length())),0.,float(ids.length())));\n    color+=ObjectLight(ro,rd,R,n,centers[id].xyz,centers[id].w,rs,ra,ids[id]);\n    color.w*=float(ids.length());\n    return max(color,0.);\n}\n\n\n\n\n\n\nvec3 Rcolor(vec3 light,vec3 color,vec3 s){\n    vec3 hsv=rgb2hsv(light);\n    vec3 hsv2=rgb2hsv(color);\n    hsv.xy=mix(hsv.xy,hsv2.xy,s.x);\n    hsv.z*=hsv2.z;\n    return mix(hsv2rgb(hsv),light*color,s.y);\n}\n\n\n\n\nvec4 background(in vec3 pos, in vec3 n,in vec3 lightDir ) {\n\n\n    float M = 1.0; //canvas.innerWidth/M //canvas.innerHeight/M --res\n\n    vec3 O =pos;\n\t vec3 D =n;\n\t vec3 color = vec3(0.);\n    \n    float t = max(0.001, D.y);\n\n      // optical depth -> zenithAngle\n    float divt=1./t;\n    float sR = RayleighAtt * divt ;\n    float sM = MieAtt * divt ;\n\n  \t float cosine = clamp(dot(D,lightDir),0.0,1.0);\n    vec3 extinction = exp(-(_betaR * sR + _betaM * sM));\n\n       // scattering phase\n    float g2 = g * g;\n    float fcos2 = cosine * cosine;\n    float miePhase = Mie * pow(1. + g2 + 2. * g * cosine, -1.5) * (1. - g2) / (2. + g2);\n        //g = 0;\n    float rayleighPhase = Rayleigh;\n\n    vec3 inScatter = (1. + fcos2) * vec3(rayleighPhase + _betaM / _betaR * miePhase);\n\n    color = inScatter*(1.0-extinction); // *vec3(1.6,1.4,1.0)\n\n        // sun\n    color += 0.47*vec3(1.6,1.4,1.0)*pow( cosine, 350.0 ) * extinction;\n      // sun haze\n    color += 0.4*vec3(0.8,0.9,1.0)*pow( cosine, 2.0 )* extinction;\n\n\t return vec4(clamp(color,0.,50.),1.);\n}\n\nvec3 estimateNormal(vec3 pos) {\n    float EPSILON=EPSILONS*distance(pos,pos_0);\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPSILON;\n    return normalize( e.xyy*DE( pos + e.xyy ).d2 + \n\t\t\t\t\t  e.yyx*DE( pos + e.yyx ).d2 + \n\t\t\t\t\t  e.yxy*DE( pos + e.yxy ).d2 + \n\t\t\t\t\t  e.xxx*DE( pos + e.xxx ).d2 );\n}\nfloat rand_i=0.;\nfloat rand(vec3 pos){\n    rand_i+=0.4;\n    pos+=rand_i+float(iFrame_);\n    return fract(sin(dot(pos.xyz*0.123 ,vec3(12.9898,78.233,475.2431))) * 43758.5453);\n}\nvec3 rndS(vec3 pos){\n    return normalize(tan(vec3(rand(pos.xy)-0.5,rand(pos.yz)-0.5,rand(pos.zx)-0.5)))*rand(pos);\n}\n\n\nvec3 raycast(vec3 ro,vec3 rd,out float distance_,float alpha){\n    float lastd0=0.;\n    bool hit00=false;\n    vec3 ro0=ro;\n    for(int i=0;i<MaxRayStep;i++){\n        float d0=DE(ro).d;\n        float EPSILON=max(EPSILONS*distance(ro,pos_0),EPSILONS_MIN);\n        if(d0<=EPSILON&&d0<lastd0){hit00=true; break;}\n        float t=distance(ro,pos_0);\n        if(t>Far) break;\n        float d_d=d0*Marching_S;\n        rd=mix(rndS(ro),rd,float(rand(ro)<exp(-d_d*alpha)));\n        lastd0=d0;ro+=d_d*rd;\n    }\n    distance_=mix2(-1.,distance(ro,ro0),float(hit00));\n    return ro;\n}\n\nvec3 GGXNormal(vec3 normal,float roughness,vec2 X,vec2 Y,vec3 pos){\n    vec3 randN0;randN0.y=-length(normal.xz);\n    if(length(normal.xz)<=0.)\n        randN0.xz=vec2(1,0);\n    else\n        randN0.xz=normalize(normal.xz)*normal.y;\n    vec3 randN1=cross(normal,randN0);\n    float alpha=mix2(X.x,X.y,rand(pos))*2.*PI;\n    float tmp=mix2(Y.x,Y.y,rand(pos+4.));\n    float beta=acos(clamp(sqrt(max(0.,(1.-tmp)/(1.+tmp*(roughness*roughness-1.)))),0.,1.));\n        \n    return (cos(beta))*normal+sin(beta)*(cos(alpha)*randN0+sin(alpha)*randN1);\n}\nvec3 GGXNormal(vec3 normal,float roughness,vec3 pos){\n    vec3 randN0;randN0.y=-length(normal.xz);\n    if(length(normal.xz)<=0.)\n        randN0.xz=vec2(1,0);\n    else\n        randN0.xz=normalize(normal.xz)*normal.y;\n    vec3 randN1=cross(normal,randN0);\n    float alpha=rand(pos)*2.*PI;\n    float tmp=rand(pos+4.);\n    float beta=acos(clamp(sqrt(max(0.,(1.-tmp)/(1.+tmp*(roughness*roughness-1.)))),0.,1.));\n        \n    return (cos(beta))*normal+sin(beta)*(cos(alpha)*randN0+sin(alpha)*randN1);\n}\nfloat GGXdf(float theta,float a){\n    float a2=a*a;\n    float cos2=cos(theta);cos2*=cos2;\n    float a2m1=a2-1.;\n    return (1.-cos2)/(1.+a2m1*cos2);\n}\n\nvec4 ObjectLight(vec3 ro,vec3 rd,float R,vec3 n,vec3 center,float sR,float rs,float ra,int id){\n    object thit=hit;\n    float d=distance(ro,center);\n    float CosAlpha;\n    vec3 tnor;\n    float tmp=rand(ro);\n    float cosD_S;\n\n    if(d<=sR){\n        CosAlpha=-1.;\n        tnor=reflect(rd,n);\n    }else{\n        float RDivd=R/d;\n        CosAlpha=1./sqrt(1.+RDivd*RDivd);\n        tnor=normalize(center-ro);\n    }\n    cosD_S=sqrt(0.5*(1.+CosAlpha));\n\n    float D_S=abs(acos(cosD_S));\n    rs=1./rs;\n    float cosa=dot(rd,n);\n    float cosb=sqrt(1.-(1.-cosa*cosa)/(rs*rs));\n    float k=0.5*(pow((cosa-rs*cosb)/(cosa+rs*cosb),2.)+pow((cosb-rs*cosa)/(cosb+rs*cosa),2.));\n    float S=0.;\n\n    vec3 A,rnd;\n    if(rand(ro)<ra+clamp(k,0.,1.)){\n        A=normalize(tnor-rd);\n    }else{\n        vec3 n0=refract(rd,n,1./rs);\n        if(n0!=vec3(0)){\n            float EPSILON=max(EPSILONS*distance(ro,pos_0),EPSILONS_MIN);\n            ro-=n*EPSILON*1.25;\n            A=normalize(tnor+rd*rs);\n            if(length(A)<0.5) A=vec3(0,1,0);\n        }else{\n            A=-normalize(tnor+rd);\n        }\n    }\n    float Ny=abs(dot(n,A));\n    float Nbeta=abs(acos(Ny));\n    vec3 N0;N0.y=-length(n.xz);\n    N0.xz=(float(length(n.xz)==0.)*vec2(1,0)+normalize(n.xz))*n.y;\n    vec3 N1=cross(n,N0);\n    float Nalpha=atan(dot(A,N1),dot(A,N0));\n\n    const float PIdiv2=PI/2.;\n    const float divPI=1./PI;\n    float Ny2=Ny*Ny;\n    float deta=cosD_S*cosD_S-Ny2;\n    vec2 X,Y;\n    if(deta<0.){\n        float a1=abs(acos(cosD_S/Ny));\n        float S0=0.5*GGXdf(a1,R);\n        float S1=0.5*GGXdf(Nbeta+D_S,R);S=(S0+S1);\n        if(rand(ro)<S0/(S0+S1)){\n            X=vec2(0,a1);Y=-Nalpha+vec2(-PIdiv2,PIdiv2);\n        }else{\n            X=vec2(0,Nbeta+D_S);Y=Nalpha+vec2(-PIdiv2,PIdiv2);\n        }\n    }else{\n        float cosF=sqrt(deta/(1.-Ny2));\n        float F=acos(cosF);\n        S=F*divPI*(GGXdf(min(Nbeta+D_S,PIdiv2),R)-GGXdf(Nbeta-D_S,R));\n        X=vec2(Nbeta-D_S,min(Nbeta+D_S,PIdiv2));Y=(Nalpha+vec2(-F,F));\n    }\n    X.x=GGXdf(X.x,R);X.y=GGXdf(X.y,R);Y=Y*divPI*0.5;\n    vec3 n0;\n    if(CosAlpha==-1.){\n        n0=GGXNormal(n,R,ro);S=1.;\n    }else{\n        n0=GGXNormal(n,R,Y,X,ro);\n    }\n    \n    if(length(n0)<0.5) n0=n;\n    rnd=reflect(rd,n0);\n    \n    S=abs(S);\n\n    float t;\n    object oA=DE(ro);\n    vec4 fog=InsideFog(ro,oA);\n    vec3 tp=raycast(ro+rnd*ShadowOffset,rnd,t,fog.x);\n    if(t<-0.5){\n        hit=thit;\n        return vec4(0);\n    }\n    oA=DE(tp);\n    vec3 pos=tp;\n    vec3 normal=estimateNormal(pos);\n    vec4 color=color(pos,normal,oA);\n    vec4 mt=Material(pos,oA);\n    hit=thit;\n    return vec4(100.*color.xyz*mt.x*clamp(dot(faceforward(n,rd,n),rnd),0.,1.),S);\n\n}\n\n\nvec4 SunLight(vec3 ro,vec3 rd,float R,vec3 n,float rs,float ra){\n    const float S_R=0.125;\n    float cosD_S=1./sqrt(1.+S_R*S_R);cosD_S=sqrt(0.5*(1.+cosD_S));\n    float D_S=abs(acos(cosD_S));\n    rs=1./rs;\n    float cosa=dot(rd,n);\n    float cosb=sqrt(1.-(1.-cosa*cosa)/(rs*rs));\n    float k=0.5*(pow((cosa-rs*cosb)/(cosa+rs*cosb),2.)+pow((cosb-rs*cosa)/(cosb+rs*cosa),2.));\n    float S=0.;\n\n    vec3 A,rnd;\n    if(rand(ro)<ra+clamp(k,0.,1.)){\n        A=-normalize(lightDir+rd);\n    }else{\n        vec3 n0=refract(rd,n,1./rs);\n        if(n0!=vec3(0)){\n            float EPSILON=max(EPSILONS*distance(ro,pos_0),EPSILONS_MIN);\n            ro-=n*EPSILON*1.25;\n            A=normalize(lightDir+rd*rs);\n            if(length(A)<0.5) A=vec3(0,1,0);\n        }else{\n            A=-normalize(lightDir+rd);\n        }\n    }\n    float Ny=abs(dot(n,A));\n    float Nbeta=abs(acos(Ny));\n    vec3 N0;N0.y=-length(n.xz);\n    N0.xz=(float(length(n.xz)==0.)*vec2(1,0)+normalize(n.xz))*n.y;\n    vec3 N1=cross(n,N0);\n    float Nalpha=atan(dot(A,N1),dot(A,N0));\n\n\n    const float PIdiv2=PI/2.;\n    const float divPI=1./PI;\n    float Ny2=Ny*Ny;\n    float deta=cosD_S*cosD_S-Ny2;\n    vec2 X,Y;\n    if(deta<0.){\n        float a1=abs(acos(cosD_S/Ny));\n        float S0=0.5*GGXdf(a1,R);\n        float S1=0.5*GGXdf(Nbeta+D_S,R);S=(S0+S1);\n        if(rand(ro)<S0/(S0+S1)){\n            X=vec2(0,a1);Y=-Nalpha+vec2(-PIdiv2,PIdiv2);\n        }else{\n            X=vec2(0,Nbeta+D_S);Y=Nalpha+vec2(-PIdiv2,PIdiv2);\n        }\n    }else{\n        float cosF=sqrt(deta/(1.-Ny2));\n        float F=acos(cosF);\n        S=F*divPI*(GGXdf(min(Nbeta+D_S,PIdiv2),R)-GGXdf(Nbeta-D_S,R));\n        X=vec2(Nbeta-D_S,min(Nbeta+D_S,PIdiv2));Y=(Nalpha+vec2(-F,F));\n    }\n    X.x=GGXdf(X.x,R);X.y=GGXdf(X.y,R);Y=Y*divPI*0.5;\n    vec3 n0=GGXNormal(n,R,Y,X,ro);\n    if(length(n0)<0.5) n0=n;\n    rnd=reflect(-rd,n0);\n    if(dot(rnd,lightDir)<0.) return vec4(0);\n    float t;\n    object oA=DE(ro);\n    vec4 fog=InsideFog(ro,oA);\n    vec3 tp=raycast(ro-rnd*ShadowOffset,-rnd,t,fog.x);\n    if(t>-0.5) return vec4(0);\n    vec4 tmp=background(ro,-rnd,-lightDir);\n\n    S=abs(S);\n    vec3 sampleColor=tmp.xyz*100.;\n    return max(vec4(0),vec4(sampleColor,S)*(dot(rnd,lightDir)-0.997>0.?1.:0.));\n}\nvec3 frag_0;\nvoid Store(vec4 c){\n    frag_0=c.xyz;\n}\nvec2 uv00;\nvec4 Load(){\n    return texture(iChannel0,uv00);\n}\nvec2 SphereProjection(vec2 p,float S){\n    return p*S;\n    return normalize(p)*tan(length(p)*S);\n}\nvoid F(float x,float y,vec3 Eye_Direction,vec3 Position){\n    if(abs(y)>9.0/16.) {Store(Load());return;}\n    iFrame_=floor(float(iFrame)/cut);\n    float divCut=1.0/cut;\n    float iFrame_offset=mod(float(iFrame),cut)*divCut;\n    if(0.5*y+0.5<iFrame_offset||0.5*y+0.5>=iFrame_offset+divCut||float(iFrame_)>SSAA*SSAA) {Store(Load());return;}\n    float x0=mod(float(iFrame_),SSAA)/SSAA;\n    float y0=floor(float(iFrame_)/SSAA)/SSAA;\n    float iW=iResolution.x;\n    x+=1.0/iW*x0;\n    y+=1.0/iW*y0;\n    \n    vec3 n=normalize((rot(vec3(SphereProjection(vec2(x,y),FOV),1),Eye_Direction)).xyz);\n    vec3 n_m=normalize((rot(vec3(SphereProjection(DOF_Pos,FOV),1),Eye_Direction)).xyz);\n    vec3 pos=Position+vec3(0,10,-140);\n    \n    float DOF=0.1;\n    if(DOF_R!=0.) raycast(pos,n_m,DOF,0.);\n    if(DOF<-0.5) DOF=Far;\n    vec3 Q=pos+n*DOF;\n    vec3 X;X.y=-length(n.xz);\n    vec3 Y;Y.xz=(float(length(n.xz)==0.)*vec2(1,0)+normalize(n.xz))*n.y;\n    Y=cross(n,X);float tmp_1=rand(pos+vec3(x,float(iFrame),y))*2.*PI;\n    float tmp_2=rand(pos+vec3(x,float(iFrame),y+5.));\n    n=normalize(n+tmp_2*DOF_R/DOF*(X*sin(tmp_1)+Y*cos(tmp_1)));\n    pos=Q-DOF*n;\n    \n    vec3 pos00=pos;\n    pos_0=pos00;\n    vec3 tcolor=vec3(0);\n    for(int i=0;i<=MaxReflect;i++) {fog0[i]=vec3(1.);Gs0[i]=1.;}\n    float distance0=0.;\n    int reflectstep=0;\n    bool hit0=false;float rand0=0.;\n    float depth=Far*10.;\n    vec3 back=background(pos,n,-lightDir).xyz;\n    float roughness=1.;\n\n    object oA0=DE(pos);\n    vec3 fogS_=InsideMaterial(pos,oA0).yzw;\n    vec4 fog=InsideFog(pos,oA0);\n    \n    float rs=1.;float ra=1.;\n    vec3 n_0=n;\n    for(reflectstep=0;reflectstep<MaxReflect;reflectstep++){\n        float t=0.;\n        vec3 nextpos=raycast(pos,n,t,fog.x);\n        if(t<-0.5) break;\n        pos=nextpos;\n        float EPSILON=max(EPSILONS*distance(pos,pos_0),EPSILONS_MIN);\n        object oA=DE(pos);\n        vec3 normal=estimateNormal(pos);\n        normal=faceforward(normal,normal,n);\n        \n        float NdotV=dot(-n,normal);\n        vec4 Color0=color(pos,normal,oA);\n        //randomize normal\n        vec3 randN=GGXNormal(normal,Color0.w,pos);\n        vec3 normal0=normal;\n        normal=randN;\n        roughness=Color0.w;\n\n        float cosa=dot(-n,normal);\n        vec4 material=Material(pos,oA);\n\n        ra=material.z;\n        float fr=material.w;\n        object oB=DE(pos-normal*EPSILON*1.25);\n        vec4 MaterialA=InsideMaterial(pos,oA);vec4 MaterialB=InsideMaterial(pos,oB);\n\n        rs=MaterialB.x/MaterialA.x;\n\n        float cosb=sqrt(1.-(1.-cosa*cosa)/(rs*rs));\n        float k=0.5*(pow((cosa-rs*cosb)/(cosa+rs*cosb),2.)+pow((cosb-rs*cosa)/(cosb+rs*cosa),2.));\n\n        float k1=0.5*(pow((cosa-fr*cosb)/(cosa+fr*cosb),2.)+pow((cosb-fr*cosa)/(cosb+fr*cosa),2.));\n        rc0[reflectstep]=RC(pos,oA);\n        colors[reflectstep].xyz=Color0.xyz;\n        fog0[reflectstep]=exp(-t*fogS_);\n        LightColors[reflectstep]=Color0.xyz;\n        n_0=n;\n        if(rand(pos)<ra+clamp(k,0.,1.)){\n            if(rand(pos)>rc0[reflectstep].z){\n                int i=0;\n                vec3 I=vec3(1);\n                do{\n                    i=i+1;\n       \n                    normal=GGXNormal(normal0,roughness,pos+vec3(0.6,0.5,0.9)*float(i));\n                    float cosa=dot(-n,normal);\n                    float cosb=sqrt(max(1.-(1.-cosa*cosa)/(rs*rs),0.));\n                    float k=0.5*(pow((cosa-rs*cosb)/max(cosa+rs*cosb,1e-4),2.)+pow((cosb-rs*cosa)/max(cosb+rs*cosa,1e-4),2.));\n                    I*=mix(Color0.xyz,vec3(1),clamp(k,0.,1.));\n                   n=reflect(n,normal);\n                }while(i<16&&dot(n,normal)<=0.);\n                colors[reflectstep].xyz=I;\n                rs0[reflectstep]=k*material.y;\n            }else{\n                n=reflect(n,normal0);\n                rs0[reflectstep]=k1;\n            }\n            fogS_=MaterialA.yzw;\n\n        }else{\n            vec3 n0=refract(n,normal,1./rs);\n            if(n0!=vec3(0)){n=n0;\n                pos-=normal*EPSILON*1.25;\n                fogS_=MaterialB.yzw;\n\n            }else{\n                n=reflect(n,normal);\n                fogS_=MaterialA.yzw;\n            }\n            rs0[reflectstep]=k;\n        }\n\n        colors[reflectstep].w=material.x;\n        Gs0[reflectstep]=1.;\n\n        if(!hit0) {depth=distance(pos,pos00);rand0=Color0.w;}\n        hit0=true;\n        oA=DE(pos);\n        fog=InsideFog(pos,oA);\n        \n        if(distance(pos,pos00)>Far) {break;}\n    }\n    fog0[reflectstep]=exp(-1e10*fogS_);\n    enablewater=false;\n    vec3 normal=estimateNormal(pos);\n    vec4 sunL=SunLight(pos,n_0,roughness,normal,rs,ra);\n    vec4 objL=getObjectLight(pos,n_0,roughness,normal,rs,ra);\n    sunL.w*=1.-rc0[reflectstep-1].z;\n    objL.w*=1.-rc0[reflectstep-1].z;\n    tcolor=(background(pos,n,-lightDir).xyz+sunL.xyz*sunL.w+objL.xyz*objL.w)/(1.+sunL.w+objL.w);\n\n    if(!hit0) tcolor*=fog0[reflectstep];\n    for(int i=reflectstep-1;i>=0;i--){\n        vec3 Rcolor=Gs0[i]*Rcolor(tcolor,colors[i].xyz,rc0[i]);\n        tcolor=fog0[i+1]*mix(Rcolor,tcolor,clamp(rs0[i],0.,1.))+LightColors[i].xyz*colors[i].w;\n    }\n    tcolor=mix(tcolor,back,clamp(1.-exp(min(0.,FogS*(FogStart-depth))),0.,1.)*float(hit0));\n    tcolor=!hit0?back:tcolor;\n    tcolor=clamp(tcolor,0.,4.);\n    \n    if(iFrame_<=1.){\n        Store(vec4(tcolor,0.));\n    }else{\n        vec4 temp0=Load();\n        Store((temp0*float(iFrame_)+vec4(tcolor,0))/(float(iFrame_)+1.));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv00=uv;\n    vec3 m=vec3(0);\n    vec3 p=vec3(0);\n    F(2.*uv.x-1.,(2.*uv.y-1.)/iResolution.x*iResolution.y,m,p);\n\n    fragColor = vec4(frag_0,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}