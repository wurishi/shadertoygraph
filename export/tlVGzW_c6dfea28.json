{"ver":"0.1","info":{"id":"tlVGzW","date":"1578451967","viewed":131,"name":"Ghostly Mandelbulb","username":"onlinerocker","description":"The mandelbulb!\nCheck the code's comments for more information...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbulb","ghost"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define ITERATIONS 2.0\n#define AA_SCALE 2.0\n\n//SETTINGS:\n#define VIEW_DIST 2.0\n\n//RESOURCES:\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n//https://iquilezles.org/articles/mandelbulb\n//https://iquilezles.org/articles/ftrapsgeometric\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float id;\n    \n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    float minDist;\n\n    vec3 curRay;\n    Object obj;\n};\n    \n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.specVal = 50.0;\n    o.specKs = 0.01;    \n    o.dist = 1000.0;\n    \n    float ang = iTime/8.0;\n    float dz = 1.0;\n    float r;\n    \n    pos.xz *= mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    vec3 z = pos;\n    float power = 10.0+4.0*cos(iTime/8.0);\n    float it;\n    float minDist = 1000.0;\n    float mdX, mdY, mdZ;\n    mdX = minDist; mdY = minDist; mdZ = minDist;\n    \n    for(float x=0.0; x < 4.0; x++)\n    {\n        vec3 cartPos;\n    \tr = length(z);\n        float ang = acos(z.y / r);\n        float ang1 = atan(z.x, z.z);\n        \n        dz = power*pow(r, power-1.0)*dz + 1.0;     \n        r = pow(r, power);      \n        ang *= power;\n        ang1 *= power;\n        \n        cartPos.x = sin(ang)*sin(ang1);\n        cartPos.y = cos(ang);\n        cartPos.z = sin(ang)*cos(ang1);\n        \n        z = pos + (r * cartPos);    \n        minDist = min(minDist, length(z - pos)); //store minimum distance from starting point\n        mdX = min(mdX, abs(z.x));\n\t\tmdY = min(mdY, abs(z.y));\n\t\tmdZ = min(mdZ, abs(z.z));\n\n        if(length(z) > 2.0) { it = x; break; }\n    }\n\n    //Coloring based off orbits: https://iquilezles.org/articles/ftrapsgeometric\n    o.color = vec3(0) + vec3(0.55, 0.9, 1.0)*sqrt(minDist);\n    o.color += vec3(0.3,0.3,0)*sqrt(mdX);\n    o.color += vec3(0.0,0.2,0)*sqrt(mdY);\n    o.color += vec3(0.0,0.1,0.2)*sqrt(mdZ);\n    \n    o.dist = 0.5*length(z)*log(length(z)) / length(dz);\n    \n    return o;\n}\n  \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n    res.minDist = 1000.0;\n\n    for(int x=0; x<100; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        if(abs(o.dist) < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n           \n        \n        if(o.dist < res.minDist) res.minDist = o.dist;\n        res.totalDist += o.dist*speed; \n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {   \n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float done;\n    vec3 col;\n    \n    //AA based off IQ's implementation in many different shaders\n    for(float x=0.0; x<AA_SCALE; x++){\n    for(float y=0.0; y<AA_SCALE; y++){\n        \n    vec2 aaOffset = vec2(x,y);\n    vec2 uv = (2.0*(fragCoord+aaOffset/AA_SCALE) - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(0,0.0,1.2);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float rate = 8.0;\n    float camAng = PI/3.5;\n    float camAngPos = camAng;\n\n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamPos = mat2( vec2(cos(camAngPos), -sin(camAngPos)), vec2(sin(camAngPos), cos(camAngPos)) );\n\n    camEye.xz = rotCamPos * camEye.xz;\n    dir.xz = rotCam * dir.xz;\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    vec3 tempCol = vec3(0);\n    if(res.totalDist < VIEW_DIST)\n    {\n        tempCol = res.obj.color;\n    }else{\n        //no object, no need to run AA\n        done = 1.0;\n     \tbreak;   \n    }\n    col += tempCol;\n\n    }\n        if(done > 0.0)\n            break;\n    }\n    \n    fragColor = vec4(col/(AA_SCALE*AA_SCALE),1.0);\n}","name":"Image","description":"","type":"image"}]}