{"ver":"0.1","info":{"id":"dlBGDV","date":"1673930078","viewed":144,"name":"Smoke and light","username":"ianertson","description":"Another ray marcher,\nWalk around with WASD while dragging with the mouse","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarch","light","marching","smoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(g) smoothstep(0.0, 1.0, g)\nvec3 rand3(vec3 p, float freq) {\n   \n   vec3 a = textureLod(iChannel0, p*0.05, 0.).xyz;\n   a += (a*(0.5+(0.5*vec3(sin(iTime+p.x), sin(iTime+p.y), cos(iTime+p.z)))))*0.3;\n   vec3 b = textureLod(iChannel0, (a*p)*0.05, 0.).xyz;\n\n\n   \n    return (a*b);\n}\n\nfloat signlerp(float v) { return mix(-1.0, 1.0, (v)); }\n\nvec3 rand3Signed(vec3 p, float freq) {\n   // p += vec3(0.0, 0.003, -0.012);\n\n    vec3 a = rand3(p, freq);\n \n    vec3 b = rand3(p + vec3(0.1, -0.01, 0.01), freq);\n    float sx = signlerp(b.x);\n    float sy = signlerp(b.y);\n    float sz = signlerp(b.z);\n    return a * vec3(sx, sy, sz);\n}\n\nvec3 getPoint(vec3 p) {\n    \n    vec3 point = rand3Signed(p*0.5, 1.0)*8.0;\n    vec3 point2 = rand3Signed(0.1*(point*p), 1.0)*8.0;\n    \n    return (point2*point)*0.05;\n}\n\nfloat getDist(vec3 p) {\n \n    vec3 point = getPoint(p);\n    return abs(distance(point, p));\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = getDist(p) - \n        vec3(getDist(p-e.xyy), getDist(p-e.yxy),getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nbool getSample(inout Ray ray, vec3 p) {\n    vec3 point = getPoint(p);\n    float dist = abs(distance(p, ray.result.point));\n    if (dist <= ray.near || dist >= ray.far) return false;\n    \n\n\n    \n    vec3 normal = getNormal(normalize(ray.result.point));\n\n    \n    ray.result.normal = normalize(normal);\n    ray.result.point = point;\n    ray.result.dist = dist;\n    \n    return true;\n    \n}\n\nvec3 shade(\ninout Ray ray,\nin Light light,\nvec3 p\n) {\n    vec3 normal = ray.result.normal;\n    float dist = abs(distance(p, light.pos));\n    vec3 L = normalize(light.pos - p);\n    float NdotL = max(0.0001, dot(normal, L));\n    float att = NdotL*  ((pow(light.strength, 2.0) / max(0.00001, pow(dist, 2.0))));\n    att /= M_PI;\n    vec3 col = light.color * att;\n    \n    return mix(col, S(col), 0.7);\n}\n\nvec3 march(inout Ray ray, in Light light) {\n    vec3 col = vec3(0.0);\n\n    float minDist = ray.far;\n    vec3 p = ray.origin;\n    int count = 0;\n\n    float steps = 16.0;\n\n    float stepSize = 0.33;\n\n    for (float i = 0.; i < steps; i+= stepSize) {\n        \n        \n        if (ray.result.dist > ray.near && ray.result.dist < minDist && ray.result.dist > ray.near) {\n            col += shade(ray, light, p);\n            count += 1;\n\n        }\n        \n        if (!getSample(ray, p) || ray.result.dist >= ray.far || ray.result.dist <= ray.near) break;\n        p += ray.dir*stepSize;\n    \n    }\n\n // return col;\n    \n   if (count <= 0) return vec3(0.0);\n    return col / float(count);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fc/iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    vec3 control = controller(vec3(0.0, 0.0, 1.0), iMouse, iResolution.xy);\n    \n    vec3 walk = texture(iChannel1, vec2(0.)).xyz;\n    vec3 origin = vec3(0.0, 0.0, -16.0);\n\n    \n    \n    Light light = Light(vec3(0., 0., 0.), 16.5, vec3(0.5, 0.7, 0.9));\n    \n    if (iMouse.z <= 0.1 || iFrame < 16) {\n        float zoom = iFrame < 16 ? 12. : (8.0+(4.0*(0.5+(0.5*cos(iTime*0.25)))));\n        origin = vec3(cos(iTime*0.5), sin(iTime*0.3)*0.33, sin(iTime*0.5))*zoom;\n        control = normalize(origin - light.pos);\n        vec3(0.0, 0.0, -16.0);\n    } else {\n        origin += walk;\n    }\n    \n    \n    \n    Ray ray = getPrimaryRay(origin, fc, iResolution.xy, control, 45.,\n                  0.1, 400.);\n                  \n    col = march(ray, light);\n    \n    col = aces(col);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float M_PI = 3.14159265359;\n\n\nstruct Light {\n    vec3 pos;\n    float strength;\n    vec3 color;\n};\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = lookAtPoint;\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\nvec2 rot2D(vec2 p, float angle) {\n  angle = radians(angle);\n  float s = sin(angle);\n  float c = cos(angle);\n  return p * mat2(c, s, -s, c);\n}\n\n\nvec3 controller(vec3 dir, vec4 c, vec2 res) {\n    vec2 m = ((c.xy == vec2(0.) ? vec2(.5) : (c.xy / res.xy)) * 2. - 1.) * vec2(360.,90.);\n    dir.yz = rot2D(dir.yz, m.y);\n    dir.xz = rot2D(dir.xz, m.x);\n    return dir;\n}\n\nmat4 proj(float fovy, float aspect, float nearZ, float farZ) {\n\n  mat4 dest = mat4(0.0);\n  float f = 1.0f / tan(fovy * 0.5f);\n  float fn = 1.0f / (nearZ - farZ);\n\n  dest[0][0] = f / aspect;\n  dest[1][1] = f;\n  dest[2][2] = -farZ * fn;\n  dest[2][3] = 1.0f;\n  dest[3][2] = nearZ * farZ * fn;\n  return dest;\n}\n\nmat4 look(vec3 eye, vec3 center, vec3 up) {\n  mat4 dest = mat4(0.0);\n  vec3 f = vec3(0.0);\n  vec3 u = vec3(0.0);\n  vec3 s = vec3(0.0);\n\n  f = normalize(center - eye);\n\n  s = cross(up, f);\n  u = cross(f, s);\n\n  dest[0][0] = s[0];\n  dest[0][1] = u[0];\n  dest[0][2] = f[0];\n  dest[1][0] = s[1];\n  dest[1][1] = u[1];\n  dest[1][2] = f[1];\n  dest[2][0] = s[2];\n  dest[2][1] = u[2];\n  dest[2][2] = f[2];\n  dest[3][0] = -dot(s, eye);\n  dest[3][1] = -dot(u, eye);\n  dest[3][2] = -dot(f, eye);\n  dest[0][3] = dest[1][3] = dest[2][3] = 0.0f;\n  dest[3][3] = 1.0f;\n\n  return dest;\n}\n\nstruct RayResult {\n  vec3 normal;\n  vec3 point;\n  vec2 uv;\n  float dist;\n  vec3 color;\n  vec4 rot;\n  float id;\n  int iid;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 dir;\n  float near;\n  float far;\n  int skip_id;\n  bool is_any;\n  RayResult result;\n};\n\nRay getPrimaryRay(vec3 origin, vec2 coord, vec2 res, vec3 lookDir, float fov,\n                  float near, float far) {\n  Ray ray;\n  ray.near = near;\n  ray.far = far;\n  ray.skip_id = -1;\n  ray.origin = origin;\n  ray.dir = normalize((inverse(proj(radians(fov), res.x / res.y, near, far) *\n                               look(lookDir, vec3(0.0), vec3(0, 1, 0))) *\n                       vec4(vec2(((coord.x - res.x / 2.0)) / res.x,\n                                 ((coord.y - res.y / 2.0)) / res.y) /\n                                0.5,\n                            1.0, 1.0))\n                          .xyz);\n  return ray;\n}\n\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\nvec3 reinhard2(vec3 x) {\n  const float L_white = 4.0;\n  return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat notzero(float v) {\n  return (abs(v) <= 0.0 ? 0.001 : v);\n}\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / notzero(max( denom, 0.000001 ));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat microfacetDistribution(float roughness, float NdotH)\n{\n    float roughnessSq = roughness * roughness;\n    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n    return roughnessSq / notzero((M_PI * f * f) + 0.00001);\n}\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / notzero(denom);\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\nvec3 fromLinear(vec3 linearRGB)\n{\n    bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n    vec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n    vec3 lower = linearRGB * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec3 toLinear(vec3 sRGB)\n{\n    bvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n    vec3 higher = pow((sRGB + vec3(0.055))/vec3(1.055), vec3(2.4));\n    vec3 lower = sRGB/vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.5 / 256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,-3.);\n    \n    float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n    float speed = MOVE_SPEED * iTimeDelta;\n    \n    speed *= 1. + 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n    \n   speed *= -1.0;\n    \n    float forwardBackward =\n\ttexture(iChannel0, vec2(KEY_W, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_S, 0.)).r;\n\n\tfloat leftRight =\n\ttexture(iChannel0, vec2(KEY_A, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_D, 0.)).r;\n\n\tfloat s = sin(radians(mx));\n\tfloat c = cos(radians(mx));\n\n\tpos.x += speed * (forwardBackward * s - leftRight * c);\n\tpos.z += speed * (forwardBackward * c + leftRight * s);\n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}