{"ver":"0.1","info":{"id":"NdtSR4","date":"1633806802","viewed":142,"name":"Walking Puppets","username":"kastorp","description":"Some experiments on how to render my footbal players.\n\n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching"],"hasliked":0,"parentid":"NddGR2","parentname":"mixed Intersector+SDF Shapes"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Walking puppets by Kastorp\n//-----------------------------------------------------\n// set this parameter to 1 to enable Parallel rendering with raymarching (not optimized) \n#define MODE 0 //0=ONLY TRACING 1=BOTH, 2=ONLY MARCHING \n//------------------------------------------------------\n#define NOHIT 1e5\n#define ZERO min(iFrame, 0)\n#define time iTime*2.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n\n//-----------Interscetion functions--------------------\nvec3 oFuv; \nvec3 oNor;\nvec2 iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n#if (MODE<2)\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return vec2(NOHIT); // no intersection\n    h = sqrt( h );\n    oNor =normalize(ro-(b+h)*rd); oFuv=vec3(0.,atan(oNor.y,length(oNor.xz)),atan(oNor.z,oNor.x))*ra*1.5708  ;\n    return h-b < 0. ? vec2(NOHIT) : -b-h>=0. ?  vec2(-b-h,+b-h): vec2(0.);\n#else\n    return vec2(NOHIT);\n#endif\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n#if (MODE<2)\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return vec2(NOHIT); // no intersection\n    oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); \n    oFuv=vec3( dot(abs(oNor),vec3(1,5,9)+ oNor)/2.,dot(ro+rd*tN,oNor.zxy),dot(ro+rd*tN,oNor.yzx));   \n    return tN<0.? vec2(0.): vec2(tN,tF);\n#else\n    return vec2(NOHIT);\n#endif\n}\n\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n#if (MODE<2)\n    float d= -(dot(ro,n)+h)/dot(rd,n);\n    oFuv.yz=(ro+d*rd).xz;\n    oNor=n;\n    return d>0.?vec2(d,NOHIT):vec2(NOHIT);\n#else\n    return vec2(NOHIT);\n#endif\n}\n\n//------SDF Functions--------------------------------\n\nfloat sPlane( vec3 p, vec3 n, float h )\n{\n#if (MODE>0)\n  return dot(p,n) + h;\n#else\n    return NOHIT;\n#endif  \n}\n\nfloat sBox( vec3 p, vec3 b )\n{\n#if (MODE>0)\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n#else\n    return NOHIT;\n#endif\n}\nfloat sSphere( in vec3 p,  float ra )\n{\n#if (MODE>0)\n    return length(p)-ra;\n#else\n    return NOHIT;\n#endif\n}\n\n//---------mixed functions--------------------------\nstruct RayIn{\n    vec3 rd;\n    float t; \n};\n\nstruct RayOut{   \n    float tN;\n    float tF;\n    vec3 n;\n    vec3 fuv;\n    float id;\n};\n\nRayOut sRayOut(float d,float id) {return RayOut(d,0.,vec3(0),vec3(0),id);}\nRayOut tRayOut(vec2 d,float id) {return RayOut(d.x,d.y,oNor,oFuv,id);}\n\nconst RayIn rSDF=RayIn(vec3(0),-1.);\n\nRayOut RotSphere( in RayIn m,vec3 p, float ra ,float a, float id)\n{\n    if(m.t<0.) return  sRayOut(sSphere(  p,  ra ),id);\n    else{\n        vec2 v = iSphere(p,m.rd,ra);\n        oFuv.z-=a*ra*1.57;\n        return  tRayOut(v,id);\n    }\n}\n\nRayOut Box(  in RayIn m,vec3 p, in vec3 b,float id)\n{\n    if(m.t<0.) return  sRayOut(sBox(  p,b ),id);\n    else return  tRayOut(iBox(p,m.rd,b),id);\n}\n\nRayOut RotBox(  in RayIn m, vec3 p, in vec3 b, vec3 ax, vec3 c, float a,float id)\n{\n    vec3 pr=  c+ erot( p-c , ax, a); \n    m.rd=  erot( m.rd , ax, a); \n    if(m.t<0.) return  sRayOut(sBox(pr ,b ),id);\n    else {\n          vec2 d=iBox(pr,m.rd,b);\n          return RayOut(d.x,d.y, erot( oNor , ax, a),oFuv,id);\n    }\n}\nRayOut Plane(  in RayIn m, vec3 p, in vec3 n ,float h,float id)\n{\n    if(m.t<0.) return  sRayOut(sPlane(  p,n,h ),id);\n    else return  tRayOut(iPlane(p,m.rd,n,h),id);\n}\n\n\nRayOut Union( RayOut a, RayOut b)\n{\n   if(a.tN<b.tN) return a;\n   else return b;\n}\n#define Add(_ro,_func) _ro = Union(_ro,_func);\n\n#define  RotView( p, _ri,_ro, _ax,  _c ,  _a,  _body) \\\n    p=  _c+ erot( p-_c , _ax, _a); \\\n    _ri.rd=  erot( _ri.rd , _ax, _a); \\\n    _body \\\n    _ro.n=erot( _ro.n , _ax, -_a); \n\n\n//------------------------------------\n\nRayOut oRay;\nfloat map(in RayIn m0,vec3 p0 ) { \n    RayOut r =  Plane(m0,p0,vec3(0,1.0,0),0.,1.);\n    \n   //rotate(p0,m0, vec3(1,0,0),vec3(0,1,0), iTime*1.2);\n   float s=2.5,n=2.;\n   RayOut r0=Box(m0,p0,vec3(1.8+s*n,2.2,1.8+s*n),2.); //bounding box:  group\n   if(( m0.t<0.  && r0.tN <.5) || (m0.t>=0. && r0.tN>=0. && r0.tN<NOHIT)){\n    \n    for(float x=-s*n;x<=s*n;x+=s) for(float y=-s*n;y<=s*n;y+=s){ //iterate over players\n    float a = -time*.3 -x*.45+y*.55;\n        vec3 p=p0-vec3(x,0,y)-vec3(cos(a),0,sin(a))*1.2; \n        r0=Box(m0,p,vec3(.6,2.2,.6),2.);//bounding box:  player\n        if((m0.t<0. && r0.tN <.5) || (m0.t>=0. && r0.tN>=0. && r0.tN<NOHIT)){\n            RayIn ri_player=m0;\n            Add(r,RotSphere(ri_player,p-vec3(0,2.,0),.18,a,3.)); //todo fix head rotation\n           \n            RayOut ro_player;\n            RotView(p,ri_player,ro_player, vec3(0,1,0),vec3(0.,0,0), a, //player rotation\n                \n                ro_player=  Box(ri_player,p-vec3(0,1.43,0),vec3(.28,.35,.1),4.);\n                float mrot=.8; float rot= abs(mod(time*.5,mrot*2.)-mrot);\n                Add(ro_player,RotBox(ri_player,p-vec3(+.4,1.47,0),vec3(.08,.3,.08),vec3(1,0,0),vec3(0,0.25,0),rot-mrot*.5,5.));\n                Add(ro_player,RotBox(ri_player,p-vec3(-.4,1.47,0),vec3(.08,.3,.08),vec3(1,0,0),vec3(0,0.25,0),mrot*.5 -rot,5.));    \n                Add(ro_player,RotBox(ri_player,p-vec3(+.17,.5,0),vec3(.08,.5,.08),vec3(1,0,0),vec3(0,0.35,0),mrot*.5 -rot,6.));\n                Add(ro_player,RotBox(ri_player,p-vec3(-.17,.5,0),vec3(.08,.5,.08),vec3(1,0,0),vec3(0,0.35,0),rot-mrot*.5,6.));\n            );\n           \n            r= Union(r,ro_player);\n        } else if( r0.tN >=.5) r=Union(r,r0); //outside player BB\n    }\n    }else if( r0.tN >=.5) r=Union(r,r0);//outside group BB\n    oRay=r;\n    return r.tN;\n}\nvec3[6] mat = vec3[6](vec3(0.184,0.380,0.082),vec3(0.859,0.420,0.420),vec3(0.769,0.471,0.471),vec3(0.141,0.310,0.439),vec3(0.851,0.408,0.408),vec3(0.824,0.416,0.416));\n\n//------------------------------------\nfloat trace(vec3 ro, vec3 rd) {\n    return map( RayIn(rd,0.), ro);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\tfloat d = .01;\n\tfor (float i = 0.; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(rSDF,p);\n\t\tif (abs(h) < .0015)\n\t\t\tbreak;\n\t\td += h;\n        if(d>500.) break;\n\t}\n    return d;\n}\n\nfloat ray(vec3 ro, vec3 rd,bool tracing){\n return  tracing? trace(ro,rd): march(ro,rd); \n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .002 * t;\n\tvec3 n = vec3(0);\n    \n\tfor (int i = ZERO; i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(rSDF,p + e * h);\n\t}\n\n\treturn normalize(n);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n  \n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = map(rSDF, ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n    \n}\n\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(rSDF,p + h * n) / h;\n}\n\n\n#define MM (iMouse.x>0.?iMouse.x/iResolution.y -.5*iResolution.x/iResolution.y:-.5*iResolution.x/iResolution.y)\n\nvec3 lights(vec3 p, vec3 rd, float d,bool tracing) {\n    vec3 lightDir = normalize( vec3(8.,19.,18.) );\n\tvec3 ld = normalize(lightDir*16.5 - p), \n    n = tracing? oRay.n:calcN(p, d) ;\n\n\tfloat ao =tracing? 1.: .1 + .9 * dot(vec3(ao(p, n, .05), ao(p, n, .3), ao(p, n, .5)), vec3(.2, .3, .5)),\n\tl1 = max(0., .5 + .5 * dot(ld, n)),\n\t\n\tspe = max(0., dot(rd, reflect(ld, n))) * .1,\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n   \n    vec3 pp=p+.001*n;    \n\tif(tracing) l1 *=    smoothstep(.001,500., ray(pp,ld,tracing));\n     else  l1*=calcSoftshadow(pp, ld,.01,13.,17.5);\n     \n\tvec3 lig = ((l1 *.9+.1)* ao + spe) * vec3(1.) *2.5;\n\treturn mix(.3, .4, fre) * lig;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\t\n    float t= .4;//-iTime*.5;\n\tvec3 ro =2.*vec3(3.*cos(t), 1.+6.*iMouse.y/iResolution.y, 3.*sin(t));\n\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n    vec3 rd =  getRayDir(ro, vec3(0,1,0), uv);\n        \n    //left:raymarching with SDF, right:ray tracing with intersectors\n#if (MODE==1)\n    bool tracing=(uv.x>MM || uv.x<MM-.3) ;  \n#else\n    bool tracing= MODE<1;\n#endif \n   float d=ray(ro,rd,tracing);\n      \n    vec3 p=ro+rd*d; \n    vec3 alb=mat[int(oRay.id)-1];\n    vec2 uvt= fract(oRay.fuv.yz)-.5;\n    if(uvt.x*uvt.y<0.)alb*=.75;\n    //if(oRay.id>=4. && oRay.fuv.x==5.) alb*=0.;\n    \n    vec3 col=lights(p, rd, d,tracing) * exp(-d * .085)*alb;\n    if(MODE==1) col=mix(col,vec3(1,0,0),smoothstep(.005,0.,abs(abs(uv.x-MM+.15)-.15)));\n\tfragColor = vec4(pow(col, vec3(.45)), 0);\n}","name":"Image","description":"","type":"image"}]}