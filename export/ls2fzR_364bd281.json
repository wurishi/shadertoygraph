{"ver":"0.1","info":{"id":"ls2fzR","date":"1499232214","viewed":270,"name":"Homotopy of the circle S1","username":"etale_cohomology","description":"Fork of https://www.shadertoy.com/view/ltBXRc","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["deform","circle","smooth","topology","homotopy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/ltBXRc\n\n// A homotopy is a function between functions on a topological space\n// A homotopy is a function that maps a function to another function, in a nice fashion\n// A homeomorphism is a function between topological spaces\n// A homeomorphism preserves all the topological structure between its source and its target\n// A homeomorphism is precisely a bijection of topologies, or, equivalently, a bicontinuous bijection of topological spaces\n// Homotopies and homeomorphisms are very closely related, but I'm not sure how/why\n// A homotopy can shrink a (curved) line-segment to a single point, but a homeomorphism can't (I think)\n\n#define CIRCLE_CENTER    vec2(.0)\n#define CIRCLE_RADIUS    .7\n#define CIRCLE_THICKNESS .01\n\n#define DEFORM_FREQUENCY 4.\n#define DEFORM_AMPLITUDE .1\n#define DEFORM_SPEED1    .5\n#define DEFORM_SPEED2    .9\n\n#define BASIS_VECTOR_e1 vec2(1., 0.)\n#define BASIS_VECTOR_e2 vec2(0., 1.)\n\n#define RGB_DARK vec3(.1, .1, .1)\n#define RGB_BLUE vec3(.0, .5, 1.)\n\nfloat deform(vec2 v0, vec2 v1, float speed, float frequency, float amplitude){\n    float dot01 = dot(normalize(v0), normalize(v1));\n\treturn amplitude * sin(dot01*frequency + iTime*speed);\n}\n\nvec3 draw_circle(vec2 uv, vec2 center, float radius, float thickness, vec3 bg_rgb, vec3 fg_rgb) {\n    vec2  displacement_vector   = center - uv;           // From current pixel to circle's center!\n    float displacement_distance = distance(uv, center);  // Norm of the displacement vector!\n\n    displacement_distance += deform(displacement_vector, BASIS_VECTOR_e1, DEFORM_SPEED1, DEFORM_FREQUENCY, DEFORM_AMPLITUDE);\n    //displacement_distance += deform(displacement_vector, BASIS_VECTOR_e2, DEFORM_SPEED2, DEFORM_FREQUENCY, DEFORM_AMPLITUDE);\n\n    float disk_exterior = smoothstep(radius-thickness, radius, displacement_distance);\n    float disk_interior = smoothstep(radius, radius+thickness, displacement_distance);\n    float circle        = disk_exterior - disk_interior;\n    return mix(bg_rgb, fg_rgb, circle);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = 2.*fragCoord.xy/iResolution.xy - 1.;  // Map pixel coordinates to [-1;1] x [-1;1]\n    uv.x *= iResolution.x / iResolution.y;  // Adjust for aspect the window's ratio!\n\n    vec3 rgb = draw_circle(uv, CIRCLE_CENTER, CIRCLE_RADIUS, CIRCLE_THICKNESS, RGB_DARK, RGB_BLUE);  // Draw circle!\n    fragColor.xyz = rgb;\n}\n","name":"Image","description":"","type":"image"}]}