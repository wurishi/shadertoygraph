{"ver":"0.1","info":{"id":"Mtd3z7","date":"1504041580","viewed":96,"name":"Ray Trace Test First Try","username":"joe234321","description":"Playing with ray tracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracesphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TODO: \n// Triangle\n// Cube\n// Plane Aliasing\n// Control Rotation\n// Negative\n\nstruct Mat\n{\n    int MatType;\n    vec4 Color;\n};\n\nstruct HitDesc\n{\n    int Mat;\n    vec3 MatParam1;\n    vec3 Normal;\n    vec3 Contact;\n    vec3 RayDir;\n};\n    \nMat gMatRedOpaque = Mat(0, vec4(1.0,0.0,0.0,1.0));\n\nbool CheckHitData( vec3 ro, HitDesc local, out HitDesc hitData )\n{\n    if( hitData.Mat == -1 )\n    {\n        hitData = local;\n        return true;\n    }\n    float distLocal = dot( ro - local.Contact, ro - local.Contact);\n    float distPrev = dot( ro - hitData.Contact, ro - hitData.Contact);\n    if( distLocal < distPrev ) \n    {\n        hitData = local;\n        return true;\n    }\n    return false;\n}\n\nvoid DebugHitData( out HitDesc hitData )\n{\n    hitData.Normal = vec3( 0.0, 1.0, 0.0);\n    hitData.RayDir = vec3( 0.0, -1.0, 0.0);\n    hitData.Mat = 0;\n    hitData.Contact = vec3( 0.0, 0.0, 0.0);\n}\n\nbool Sphere( vec3 ro, vec3 rd, vec3 pos, float radius, int mat, out HitDesc hitData )\n{\n    float a = 1.0;\n    float b = 2.0 * dot( (ro - pos), rd );\n    float c = dot( (ro - pos), (ro - pos)) - radius * radius;\n    float determinent = b * b - 4.0 * a * c;\n    \n    if( determinent < 0.0 )\n    {\n        \n        return false;\n    }\n    \n    \n    float determinentSqrt = sqrt(determinent);\n    \n    float t1 = (-b + determinentSqrt)/ 2.0;\n    float t2 = (-b - determinentSqrt)/ 2.0;\n    vec3 t1c = ro + rd * t1;\n    vec3 t2c = ro + rd * t2;\n    vec3 t1cV = t1c - ro;\n    vec3 t2cV = t2c - ro;\n    float t1c_dist2 = dot( t1cV, t1cV );\n    float t2c_dist2 = dot( t2cV, t2cV );\n    \n    vec3 outPOC;\n    HitDesc local;\n    if( t1 >= 0.0 && t2 < 0.0 )\n    {\n        local.Contact = t1c;\n    }\n    else if ( t2 >= 0.0 && t1 < 0.0 )\n    {\n        local.Contact = t2c;\n    }\n    else if (t1 < 0.0 && t2 < 0.0 )\n    {\n        \t\n        return false;\n    }\n    else\n    {\n    \tlocal.Contact = (t1c_dist2 < t2c_dist2) ? t1c : t2c;\n    }\n    \n    local.Normal = normalize( (local.Contact - pos) );\n    local.RayDir = rd;\n    local.Mat = mat;\n    \n    return CheckHitData( ro, local, hitData ); \n}\n\nbool Plane( vec3 ro, vec3 rd, vec3 P, vec3 N, int mat, out HitDesc hitData )\n{\n    \n    const float epsilon = 0.000001;\n    float bottom = dot( rd, N );\n    if( bottom < epsilon && bottom > -epsilon)\n    {\n        \n        return false;\n    }\n    \n    float t = dot(P - ro, N) / bottom;\n    if ( t < 0.0 )\n    {\n        return false;\n    }\n    \n    HitDesc local;\n    local.Contact = ro + rd * t;\n    local.Normal = N;\n    local.RayDir = rd;\n    local.Mat = mat;\n    \n    return CheckHitData( ro, local, hitData ); \n}\n\nvoid Trace( vec3 ro, vec3 rd, out HitDesc hitData )\n{\n    Plane( ro, rd, vec3 (0.0,0.0,0.0), vec3(0.0, 1.0, 0.0), 2, hitData );\n    \n    vec3 pos = vec3( 0.0, 3.0, 0.0  );\n    Sphere (ro, rd, pos, 3.0, 1, hitData );\n    //Sphere (ro, rd, vec3( 4.0,0.0,0.0), 2.0, 0, hitData );\n    return;\n}\n\nstruct PointLight\n{\n\tvec3 Position;\n    vec3 Color;\n    float A0; // Constant\n    float A1; // Linear\n    float A2; // Exp\n};\n    \nbool CheckOcclusion( vec3 p1, vec3 p2 )\n{\n    HitDesc shadowCheckData;\n    shadowCheckData.Mat = -100;\n    vec3 dir = normalize( p2 - p1 );\n    vec3 _p1 = p1 + dir * .0001;\n    vec3 _p2 = p1 - dir * .0001;\n    Trace( _p1, dir, shadowCheckData );\n    if( shadowCheckData.Mat == -100 )\n        return false;\n    float dist2 = dot( shadowCheckData.Contact - _p1, shadowCheckData.Contact - _p1 );\n    return dist2 < dot( p2 - p1, p2 - p1 );\n}\n    \nvec3 CalcPointLight( PointLight light, vec3 normal, vec3 position )\n{\n    if( CheckOcclusion( position, light.Position ))\n       return vec3 (0.0, 0.0, 0.0);\n    vec3 v = light.Position - position;\n    float d2 = dot( v, v );\n    float d = sqrt( d2 );\n    float i = 1.0 / (light.A0 + light.A1 * d + light.A2 * d2 );\n    i = clamp( i * dot( normalize(v), normal ), 0.0, 1.0);\n    return light.Color * i;\n}\n\nvoid RotatePoint( float x, float y, out float outX, out float outY, float angle )\n{\n    outX = x * cos( angle ) - y * sin( angle );\n    outY = y * cos( angle ) + x * sin( angle );\n}\n\nvec3 ApplyLightingModel( vec3 diffuseColor, vec3 normal, vec3 position )\n{\n    vec3 ambientColor = vec3( 0.2, 0.2, 0.2 );\n    vec3 dirLightColor = vec3( 0.2, 0.2, 0.2 );\n    vec3 lightDir = normalize(vec3( 1.0, -1.0, 0.0 ));\n    \n    vec3 diffuseAmount = vec3( 0.0, 0.0, 0.0 );\n    \n    // Add ambient light\n    diffuseAmount += ambientColor;\n    \n    // Add directional light\n    //diffuseAmount += dirLightColor * clamp( dot( normal, -lightDir ), 0.0, 1.0);\n    \n    // Add point light\n    PointLight pointLight;\n    float angle = iTime;\n    pointLight.Position = vec3( 5.0 , 10.0, 0.0 );\n    RotatePoint( pointLight.Position.x, pointLight.Position.z, pointLight.Position.x, pointLight.Position.z, iTime );\n    pointLight.Color = vec3 ( 1.0, 1.0, 1.0 );\n    pointLight.A0 = 0.5; // Constant\n    pointLight.A1 = 0.05; // Linear\n    pointLight.A2 = 0.01; // Exp\n    diffuseAmount += CalcPointLight( pointLight, normal, position );\n    \n    return diffuseAmount * diffuseColor;\n}\n\nvec4 Resolve( HitDesc hitData )\n{\n    if( hitData.Mat == -1 )\n    {\n        return vec4(0.0,0.0,0.0,0.0);\n    }\n    if( hitData.Mat == -2 )\n    {\n        return vec4(1.0,1.0,0.0,1.0);\n    }\n    Mat mat = gMatRedOpaque;\n    if( hitData.Mat == 0)\n    {\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    else if( hitData.Mat == 1 )\n    {\n        vec3 col = ApplyLightingModel( mat.Color.rgb, hitData.Normal, hitData.Contact );\n        return vec4(col, 1.0);\n    }\n    else if (hitData.Mat == 2)\n    {\n        vec3 col1 = vec3(1.0, 1.0, 0.0);\n        vec3 col2 = vec3(1.0, 0.0, 1.0);\n        float indexSum = floor(hitData.Contact.x) + floor(hitData.Contact.z);\n        vec3 col = (( mod(indexSum, 2.0) ) < 1.0) ? col1 : col2;\n        return vec4(ApplyLightingModel( col, hitData.Normal, hitData.Contact ), 1.0);\n    }\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0.0,3.0, -5);\n    vec3 cameraTarget = vec3( 0.0, 3.0, 0.0);\n    vec3 cameraLook = normalize( cameraTarget - cameraPos);\n    vec3 cameraRight = cross( cameraLook, vec3(0.0,1.0,0.0));\n    vec3 cameraUp = cross( cameraRight, cameraLook ); \n    \n    if( cameraUp.y < 0.0 )\n    {\n        fragColor = vec4(0.0,0.0,0.0, 1.0);\n        return;\n    }\n    \n    float fov = 90.0;\n    \n    float windowWidth = tan( fov / 2.0 );\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = uv.x * 2.0 - 1.0;\n    uv.y = (uv.y * 2.0 - 1.0) * (iResolution.y/iResolution.x);\n    \n    vec3 rayTarget = cameraPos + cameraLook + \n        cameraRight * windowWidth * uv.x + cameraUp * windowWidth * uv.y;\n    vec3 ro = cameraPos;\n    vec3 rd = normalize( rayTarget - cameraPos );\n    \n    HitDesc hitData;\n    hitData.Mat = -1;\n\tTrace( ro, rd, hitData ); \n    fragColor = Resolve(hitData);\n    //vec4(uv,0.5+0.5*sin(iTime),1.0);\n}","name":"Image","description":"","type":"image"}]}