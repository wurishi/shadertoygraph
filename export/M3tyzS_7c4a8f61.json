{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n    Circular Analytical Motion Blur by chronos\n    ------------------------------------------\n    \n    Analytical motion blur for a disc on a circular trajectory.\n    \n    Note how the blur correctly follows the circular arc \n    instead of along a tangential line!\n    \n    This works by using a function for the 1D analytical solution to\n    a box-filter applied to an interval indicator function (box/rect function),\n    combined with computing the arc-length of the curve that \n    is traced by the pixels at a given radius intersecting the circle.\n    \n    The blur width is found by computing the distance traveled in the duration\n    of a frame (arclength swept by a pixel), which only depends on the \n    angular speed and the radius from the center of rotation.\n\n    ------------------------------------------\n    self link: https://www.shadertoy.com/view/M3tyzS\n*/\n    \nvec2 intersect_circles(vec2 c0, float r0, vec2 c1, float r1)\n{\n    float d = length(c1 - c0);\n    float d0 = (d*d + r0 * r0 - r1 * r1) / (2.*d);\n    float t = d0/d;\n    vec2 p = mix(c0, c1, t);\n    float h = sqrt(r0 * r0 - d0 * d0);\n    vec2 q = p + h * vec2(-1, 1) * normalize(c1-c0).yx;\n    return q;\n}\n\nfloat get_arclength(vec2 c0, float r0, vec2 c1, float r1)\n{\n    if(r0 < length(c1 - c0) - r1 || r0 > length(c1 - c0) + r1) return 0.;\n    vec2 q0 = intersect_circles(c0, r0, c1, r1);\n    vec2 ax0 = normalize(c1 - c0);\n    vec2 projected = dot(q0-c0, ax0) * ax0 + c0;\n    vec2 q1 = 2. * projected - q0;\n    float angle = acos(dot(normalize(q0-c0), normalize(q1 - c0)));\n    return angle * r0;    \n}\n\nfloat box_filter_interval(vec2 a, float width, float x)\n{\n    float end = width/2.-x;\n    float cx = clamp(a.x, end-width, end);\n    return max(clamp(end, cx, a.y) - cx, 0.) / width;\n}\n\nfloat get_trajectory_radius(float t)\n{\n    return 0.65 + cos(iTime/20.)*.2 - sin(iTime/10.)*.075;\n}\n\nfloat get_disc_radius(float t)\n{\n    return 0.224 + sin(iTime/10.)*.15;\n}\n\nfloat get_angular_speed(vec2 mouse, float time)\n{\n    if(length(iMouse.xy) > 10.)\n        return speed_multiplier * (mouse.y * .5 +.5);\n    return speed_multiplier * (sin(time) * .4 +.6);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    #if USE_FIXED_TIME_DELTA\n    float TimeDelta = fixed_time_delta;\n    #else\n    float TimeDelta = iTimeDelta;\n    #endif\n\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec2 mouse0 = (2. * abs(iMouse.zw) - iResolution.xy)/iResolution.y;\n    vec2 mouse1 = (2. *     iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    float ps = 2. / iResolution.y;\n    vec3 color = vec3(0.2-uv.y*.075, 0.3+uv.y*.075, 0.5);\n\n    float r0 = get_trajectory_radius(iTime);\n    vec2 c0 = vec2(0,0);\n    \n    float r1 = get_disc_radius(iTime);\n    vec2 c1 = vec2(cos(iTime), sin(iTime)) * r0;\n    \n    float sdf0 = length(uv - c0) - r0;\n    \n    // Draw trajectory\n    #if 1\n    color = mix(color, vec3(1), .05*smoothstep(ps, -ps, abs(sdf0) - 2. * ps));\n    color = mix(color, vec3(1), .05*smoothstep(ps, -ps, length(uv - c0) - 4. * ps));\n    #endif\n    \n    // Animation\n    float angular_speed = get_angular_speed(mouse1, iTime);\n    float movement_angle = texelFetch(iChannel0, ivec2(0), 0).r;\n    float c = cos(movement_angle), s = sin(movement_angle);\n    mat2 R = mat2(c, s, -s, c);\n    \n    // More animation\n    vec2 p = uv - c0;\n    p = R * p;\n    float angle_deviation = (atan(p.y, p.x));\n    float perimeter_deviation = angle_deviation * length(p);\n    \n    // Draw speed / blur visualization dots, angular distance between dots\n    // should match blur width\n    #if 0\n    float dc = cos(TimeDelta/2. * angular_speed);\n    float ds = sin(TimeDelta/2. * angular_speed);\n    mat2 dR = mat2(dc, ds, -ds, dc);\n    color = mix(color, vec3(0, 1,0 ), 0.25*smoothstep(ps, -ps, length(p - transpose(dR)*(vec2(-r0, 0))) - 4. * ps));\n    color = mix(color, vec3(0, 1,0 ), 0.25*smoothstep(ps, -ps, length(p - dR*(vec2(-r0, 0))) - 4. * ps));\n    #endif\n    \n    // Calculate blur amount based on speed and frametime\n    float frame_time = TimeDelta;\n    float speed = angular_speed * length(p);\n    float frame_dist = frame_time * speed;\n    \n    float arclength = get_arclength(c0, length(uv-c0), c1+c0, r1);\n    \n    float blur_alpha = box_filter_interval(vec2(-arclength/2., arclength/2.), frame_dist, perimeter_deviation);\n    \n    vec3 disc_color = vec3(0.9, 0.6, 0.3);\n    color = mix(color, disc_color, blur_alpha); // Draw blurred disc\n    \n    color *= 1.-dot(uv,uv)*.1; // vignette\n    color = pow(color, vec3(1./2.2));  // sRGB 2.2\n    color += texelFetch(iChannel3, ivec2(fragCoord)%1024, 0).rgb/128.; // Dither a bit :)\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Must match same function in Image tab\n// Could make a macro in common tab, but meh... ^_^\nfloat get_angular_speed(vec2 mouse, float time)\n{\n    if(length(iMouse.xy) > 10.)\n        return speed_multiplier * (mouse.y * .5 +.5);\n    return speed_multiplier * (sin(time) * .4 +.6);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if(ivec2(fragCoord) != ivec2(0)) return;\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    vec2 mouse0 = (2. * abs(iMouse.zw) - iResolution.xy)/iResolution.y;\n    vec2 mouse1 = (2. *     iMouse.xy - iResolution.xy)/iResolution.y;\n    float angular_speed = get_angular_speed(mouse1, iTime);\n    float prev_angle = texelFetch(iChannel0, ivec2(0), 0).r;\n    \n    #if USE_FIXED_TIME_DELTA\n    float TimeDelta = fixed_time_delta;\n    #else\n    float TimeDelta = iTimeDelta;\n    #endif\n    \n    float angle = prev_angle + angular_speed * TimeDelta;\n    fragColor = vec4(angle,0,0,0);\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"const float PI = 3.14159265;\nconst float TwoPI = 2. * PI;\n\nfloat speed_multiplier = 50.;\n\nconst float fixed_time_delta = 1./60.;\n\n#define USE_FIXED_TIME_DELTA 0","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"M3tyzS","date":"1735304129","viewed":150,"name":"Circular Analytical Motion Blur","username":"chronos","description":"Analytical motion blur for a disc on a circular trajectory. Note how the blur correctly follows the circular arc instead of along a tangential line.","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["blur","motion","analytical","angular"],"hasliked":0,"parentid":"","parentname":""}}