{"ver":"0.1","info":{"id":"lXyXWV","date":"1720511638","viewed":24,"name":"shAAder (ASCII Art Shader)","username":"trafficone","description":"ShAAder employs dithering (not yet) and edge detection to maximize the legibility of images rendered in text. The shader uses the full set of ASCII characters to maximize legibility.\n\nCurrently it's not looking great. Feel free to comment.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ascii","console","aalib"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\nconst vec2 sourcesize = vec2(1.0/16.0);\n\nvoid make_kernel(inout vec4 kern[9], sampler2D tex, vec2 uv)\n{\n// Sobel Edge Detection Filter\n// GLSL Fragment Shader\n// Implementation by Patrick Hebron\n// https://gist.githubusercontent.com/Hebali/6ebfc66106459aacee6a9fac029d0115/raw/1cd360aae1c6d81eed1585edeece31b21822b3aa/GlslSobel.frag\n// modified by Trafficone for Shadertoy\n    float width = charsize.x;\n    float height = charsize.y;\n\t//float w = 1.0 / (KERNEL_SIZE*iResolution.x);\n\t//float h = 1.0 / (KERNEL_SIZE*iResolution.y);\n    vec4 sw = texture(tex, uv + vec2( -width, -height));\n    vec4 s  = texture(tex, uv + vec2(0.0, -height));\n    vec4 se = texture(tex, uv + vec2(  width, -height));\n    vec4 w  = texture(tex, uv + vec2( -width, 0.0));\n    vec4 c  = texture(tex, uv);\n    vec4 e  = texture(tex, uv + vec2(  width, 0.0));\n    vec4 nw = texture(tex, uv + vec2( -width, height));\n    vec4 n  = texture(tex, uv + vec2(0.0, height));\n    vec4 ne = texture(tex, uv + vec2(  width, height));\n    // postprocessing step?\n\tkern[0] = luminance(sw);\n\tkern[1] = luminance(s); \n\tkern[2] = luminance(se);\n\tkern[3] = luminance(w);\n\tkern[4] = luminance(c);\n\tkern[5] = luminance(e);\n\tkern[6] = luminance(nw);\n\tkern[7] = luminance(n);\n\tkern[8] = luminance(ne);\n}\n\nvec4 sobel_vector(vec4 n[9]) {\n    // get the gradiant vector from a 3x3 matrix of pixel values\n\tvec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  \tvec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n\tvec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n    float sobel_angle = abs(atan(sobel_edge_h.r,sobel_edge_v.r));\n    return vec4(sobel_angle,sobel_edge_h.x,sobel_edge_v.x,sobel.x);\n}\n\nvec2 char_coords(int ascii_value) {\n    // Get the X,Y coordinate of the ASCII value input\n    // to pull from the font texture\n    // No extended ASCII\n    if (ascii_value < 32 || ascii_value > 128) {\n        ascii_value = 32;\n    }\n    int x = ascii_value % 16;\n    int y = 15-(ascii_value-x) / 16;\n    return vec2(float(x),float(y));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int char = 0x00; // selected character to draw\n    vec2 coords;\n    vec2 source_uv;\n    \n    vec2 uv = fragCoord/iResolution.xy; // between 0 and 1\n    int col = int(uv.x * COLS*MULTISAMPLE); // int between 0 and COLS\n    int row = int(uv.y * ROWS*MULTISAMPLE); // int between 0 and ROWS\n    vec2 uv_d = vec2(float(col)/(COLS*MULTISAMPLE),float(row)/(ROWS*MULTISAMPLE))+charsize/2.0; // back to between 0 and 1\n    //vec2 target_size = 1.0/vec2(COLS,ROWS);\n    vec2 target_uv = fract(uv/charsize);\n    \n    int block[17];\n    block[0] = 0x4d; // M\n    block[1] = 0x48; // H\n    block[2] = 0x57; // W\n    block[3] = 0x38; // 8\n    block[4] = 0x58; // X\n    block[5] = 0x24; // $\n    block[6] = 0x40; // @\n    block[7] = 0x23; // #\n    block[8] = 0x53; // S\n    block[9] = 0x2a; // *\n    block[10] = 0x2b; // +\n    block[11] = 0x22; // \"\n    block[12] = 0x3a; // :\n    block[13] = 0x27; // '\n    block[14] = 0x2e; // .\n    block[15] = 0x60; // `\n    block[16] = 0x20; // (space)\n\n    int edge[10];\n    edge[0] = 0x50; // P\n    edge[1] = 0x71; // q\n    edge[2] = 0x62; // b\n    edge[3] = 0x64; // d\n    edge[4] = 0x2f; // /\n    edge[5] = 0x5c; // \\\n    edge[6] = 0x7c; // |\n    edge[7] = 0x3d; // =\n    edge[8] = 0x2d; // -\n    edge[9] = 0x5f; // _\n\n    int side[10];\n    side[0] = 0x54; // T\n    side[1] = 0x59; // Y\n    side[2] = 0x56; // V\n    side[3] = 0x41; // A\n    side[4] = 0x78; // x\n    side[5] = 0x6f; // o\n    side[6] = 0x5b; // [\n    side[7] = 0x5d; // ]\n    side[8] = 0x3c; // <\n    side[9] = 0x3e; // >\n\n    // Example of mapping character to screen\n    //char = int(iFrame/20)%96+32;\n    /*char = 73;\n    coords = char_coords(char)*sourcesize;\n    source_uv = vec2(mix(coords.x,coords.x+sourcesize.x,uv.x),\n                        mix(coords.y,coords.y+sourcesize.y,uv.y));\n    \n    fragColor = vec4(vec3(texture(iChannel0,source_uv).r),1.0);\n    return;\n    /**/\n    // Step 1 Find which sector the associated pixel is in\n    vec2 character_pos = vec2(int(uv.x*COLS),int(uv.y*ROWS))/\n        vec2(COLS,ROWS);\n    // Step 2 get the values in that sector\n    vec4 samps[9];\n    make_kernel(samps, iChannel1, character_pos);\n    vec4 sobel = sobel_vector(samps);\n    vec4 avg_lum = (samps[0]+\n                    samps[1]+\n                    samps[2]+\n                    samps[3]+\n                    samps[4]+\n                    samps[5]+\n                    samps[6]+\n                    samps[7]+\n                    samps[8])/9.0;\n    //fragColor = sobel+avg_lum;\n    //return;\n    // Step 3 Pick a character based on samples\n    // (it's annoying that every pixel needs to pick, but, meh)\n    int lum_char = 16-int(16.0*avg_lum.r);\n    char = block[lum_char];\n\n    // Sobel vector: angle, horiz, vert, magnitude\n    if (sobel.a > 0.90) {\n#ifdef DEBUG\n        fragColor = vec4((1.0-sobel.g/2.0)/2.0,(1.0-sobel.b/2.0)/2.0,0.0,1.0);\n        return;\n#endif\n        char = 0x6f; // o\n        \n        if (abs(sobel.b) <= 0.40 && abs(sobel.g) > 0.40) \n        {\n            char = 0x7c; // -\n        } \n        else if (abs(sobel.b) > .40 && abs(sobel.g) <= .40) \n        {\n            char = 0x2d; // -\n        }\n        else \n        {\n        \n            if (sobel.r < (PI/2.0) || (sobel.r > PI && sobel.r < (3.0*PI/2.0)))\n            {\n                char = 0x2f; // /\n            }\n            else \n            {\n                char = 0x5c; // \\ \n            }\n        }\n    }\n\n    // Step 4 actually draw the chosen character to screen\n    coords = char_coords(char)*sourcesize;\n    \n    source_uv = vec2(mix(coords.x+sourcesize.x*.2,\n                        coords.x+sourcesize.x*0.8,target_uv.x),\n                        mix(coords.y+sourcesize.y*.2,\n                        coords.y+sourcesize.y*.8,target_uv.y));\n    fragColor = vec4(vec3(texture(iChannel0,source_uv).r),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define COLS 120.0\n#define ROWS 32.0\n\n#define KERNEL_SIZE 1.0\n\n#define MULTISAMPLE 1.0\n\nconst vec2 charsize = vec2(1.0)/vec2(COLS,ROWS);\n\n\n\nvec4 luminance( vec4 color )\n{\n    // linear luminance \n    float lum = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n    return vec4(vec3(lum),1.0);\n}","name":"Common","description":"","type":"common"}]}