{"ver":"0.1","info":{"id":"WsG3Rd","date":"1570982243","viewed":102,"name":"Geometry party","username":"henrybergstrom","description":"https://www.youtube.com/watch?v=u2g3sWqfibg&feature=youtu.be&t=66 for reference","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sphere","box","pyramid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 20\n#define MAX_DIST  20.0\n#define SURF_DIST    .001\n\n// Colors\n#define COL_ORANGE vec3(1.0, 0.5, 0.0)\n#define COL_PINK   vec3(1.00,0.5,1.00)\n#define COL_WHITE  vec3(1.0, 1.0, 1.0)\n#define LIGHT_DIF  0.3\n#define LIGHT_SPEC  1.8\n#define S_BOX     4.0\n#define S_OCTA    3.0\n#define S_PYRAMID 2.0\n#define S_SPHERE  1.0\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Hopefully I can use smin to smooth pyramid edges \nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Shapes\nvec2 sdBox(vec3 p, vec3 s) { \n    vec3 q = abs(p) - s;\n  \treturn vec2(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.05, S_BOX);\n}\n\n\nvec2 sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return vec2((p.x+p.y+p.z-s)*0.57735027, S_OCTA);\n}\n\nvec2 sdPyramid(in vec3 p, in float s) {\n    vec3 bd = p + vec3(0.0, -s/1.0, 0.0);\n\treturn vec2(max(sdOctahedron(p, s).x, sdBox(bd, vec3(s)).x), S_PYRAMID);\n}\n\nvec2 sdSphere(in vec3 p, in float r) {\n\treturn vec2(length(p) - r, S_SPHERE);\n}\n\n// 1D Random\nfloat rand(float x) {\n\treturn 0.5 * fract(sin(x) * 10.)/2.0;\n}\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n\nvec2 GetDist(vec3 p) {\n    \n    float t = iTime;\n    \n    vec2 res = vec2(100.0, 100.0);\n    \n    // pyramids\n    vec4[5] pys = vec4[5](\n        vec4( 3.0,  -3.5,  1.0, 0.5),\n        vec4(-2.5,  -3.0,  0.8, 1.0),\n        vec4(-0.5,  -3.0,  2.5, 0.6),\n        vec4( 2.0,  -2.5,  3.0, 0.8),\n    \tvec4( 3.0,  -2.0, -1.0, 1.0));\n    \n    float d = res.x;\n    vec3 p_ = p;\n    \n    for (int i = 0; i < 5; i++) {\n        //p_.xz *= Rot(0.05 * t);\n        // abs(sin(0.25*t));\n        pys[i].xy += 2.0 * sin(t) * noise(vec2(sin(0.01*t*pys[i].x), cos(0.01*t*pys[i].y)));\n        vec3 pp = p_+ pys[i].xyz;\n        //pp -= vec3(0.0, 0.0, 0.0);\n        //pp.xz += sin(t);\n        pp.xz *= Rot(t * pys[i].w);\n        pp.zy *= Rot(t * fract(pys[i].w));\n        d = sdPyramid( pp, pys[i].w).x;\n        if (res.x > d) {\n        \tres.x = d;\n            res.y = S_PYRAMID;\n        }\n        \n    }\n    \n    // Octahedron\n    vec4[5] octs = vec4[5](\n            vec4( 2.0,  -2.0,  3.0, 1.1), \n            vec4( 0.0,  -1.0, -3.5, 0.9), \n            vec4( -2.0, -2.0,  3.0, 0.4),\n            vec4( -1.0,   5.0,  -4.0, 0.8),\n            vec4( -2.0,   5.0,  2.0, 0.8));\n\n    d = res.x;\n    p_ = p;\n    for (int i = 0; i < 5; i++) {\n        //p_.xz *= Rot(0.05 * t);\n        // abs(sin(0.25*t));\n        octs[i].xy += sin(t) * noise(vec2(sin(0.01*t*octs[i].x), \n                                          cos(0.01*t*octs[i].y)));\n        vec3 pp = p_+ octs[i].xyz;\n        pp.xz *= Rot(t * octs[i].w);\n        d = sdOctahedron( pp, octs[i].w).x;\n        if (res.x > d) {\n        \tres.x = d;\n            res.y = S_OCTA;\n        }\n        \n    }\n    \n    // Boxes\n    vec4[5] boxs = vec4[5](\n            vec4( -2.0, -3.0,  2.5, 0.3),\n            vec4( 2.0,  -2.0,  1.0, 0.1), \n            vec4( 0.0,  -1.0, -1.5, 0.3), \n            vec4( -2.0, -2.0,  1.0, 0.2),\n            vec4( 1.0,   0.0,  1.0, 0.1));\n    \n   \td = res.x;\n    p_ = p;\n    for (int i = 0; i < 5; i++) {\n        p_.xz *= Rot(0.05 * t);\n        vec3 pp = p_+ boxs[i].xyz;\n        pp.xz *= Rot(t * boxs[i].w);\n        d = sdBox( pp, vec3(boxs[i].w)).x;\n        if (res.x > d) {\n        \tres.x = d;\n            res.y = S_BOX;\n        }\n        \n    }\n    \n    // sphere\n    vec4[5] sphs = vec4[5] (\n    \tvec4(-3.0, -1.0, 3.0, 0.3),\n        vec4(-1.0, -1.0, 3.0, 0.3),\n        vec4( 0.0, -1.0, 3.0, 0.3),\n        vec4( 1.0, -1.0, 3.2, 0.3),\n        vec4( 3.0, -1.0, 3.0, 0.3)\n    );\n    \n    \n    p_ = p;\n    for (int i = 0; i < 5; i++) {\n     \tp_.yz *= Rot(0.2*t);\n        vec3 pp = p_ + sphs[i].xyz;\n        d = sdSphere( pp, sphs[i].w).x;\n        if (res.x > d) {\n        \tres.x = d;\n            res.y = S_SPHERE;\n        }\n    }\n    \n    \n    return res;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n    vec2 tres = vec2(0.0);\n    vec2 temp = vec2(0.0);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*tres.x;\n        temp = abs( GetDist(p) );\n        tres.x += temp.x;\n        if(tres.x > MAX_DIST || temp.x < 0.01) {\n            tres.y = temp.y;\n        \tbreak;\n        }\n    }\n    return tres;\n     \n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2, 5, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    vec2 light = RayMarch(p+n*SURF_DIST*2., l);\n    light.x = LIGHT_DIF * clamp(dot(n, l)*0.5+.5, 0., 1.);\n    \n    // specular\n    vec3 hv = normalize(l + p); \n    light.x += LIGHT_SPEC * dot(n, hv);\n    \n    \n    if(p.y < .001 && light.x < length(lightPos-p)) light.x *= 0.8;\n    \n    return light;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nfloat d2Sphere(vec2 uv, vec2 p, float r) {\n    vec2 d = p - uv;\n    float factor = sqrt( length(d) - r + 1.0);\n    return smoothstep(r, r-0.03, length(d));\n}\n\nvec3 h2rgb( vec3 c){\n  vec3 col = vec3(0.0);  \n  col += c.x * COL_PINK;\n  col += c.y * COL_ORANGE;\n  col += c.z * COL_WHITE;\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime;\n    \n    vec3 col = vec3(0);\n    \n    // 2D drawing\n    vec2[5] d2sphs = vec2[5] (\n    \t\tvec2(-0.4, -0.0),\n        \tvec2(-0.5, -0.5),\n        \tvec2(0.0, 0.2),\n        \tvec2(-.4, 0.1),\n        \tvec2(0.3, -0.4)\n    );\n    \n    vec2 sp = vec2(0.0);\n    for (int i = 0; i < 5; i++) {\n        sp.x = d2sphs[i].x - 0.05 * sin(iTime * float(i));\n        sp.y = d2sphs[i].y - 0.25 * cos(iTime);\n        col += h2rgb(vec3(abs(sin(t*0.02)))) * d2Sphere(uv, sp, 0.5 * rand(float(i)));\n    }\n    \n    \n    // Camera\n    vec3 ro = vec3(0, 4, -5);\n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    \n    // Ray marching\n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n    vec2 res = RayMarch(ro, rd);\n    if(res.x < MAX_DIST) {\n    \tvec3 p = ro + rd * res.x;\n    \n    \tvec2 light = GetLight(p);\n      \t\n        if (light.y < S_SPHERE+.5) {\n        \tcol += COL_ORANGE  * light.x;\n        } else if (light.y < S_PYRAMID+0.5) {\n            vec3 comp = vec3(0.0, noise(uv), noise(uv*2.0));\n        \tcol += h2rgb(comp) * light.x;\n        } else if (light.y < S_OCTA+0.5) {\n            vec3 comp = vec3(0.1*noise(uv*2.0), noise(uv), 0.0);\n        \tcol += h2rgb(comp) * light.x;\n        } else if (light.y < S_BOX+0.5) {\n            vec3 comp = vec3(1.0, 0.0, 0.0);\n        \tcol += h2rgb(comp) * light.x;\n        }\n\t\t\n\n\t\t\n    }\n    \n    // 2D Drawing\n    for (int i = 0; i < 5; i++) {\n        sp.x = d2sphs[i].x + 0.25 * cos(iTime * float(i));\n        sp.y = d2sphs[i].y + 0.4 * sin(-iTime);\n       \tvec3 comp = vec3(noise(uv), 0.8, noise(uv*2.0));\n        col += h2rgb(comp) * d2Sphere(uv, sp, 0.025 * float(i));\n    }\n\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}