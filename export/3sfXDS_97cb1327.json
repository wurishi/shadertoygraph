{"ver":"0.1","info":{"id":"3sfXDS","date":"1552175463","viewed":85,"name":"Mashgraf_2019_1","username":"Polina","description":"Sport","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 30.\n#define SURF_DIST .01\n\nvec4 Sphere = vec4(1.0, 2., 9, 2);\nvec3 Torus_s = vec3(2.5, 2.5, 8.0);\nvec2 Torus_r = vec2(1.2, 0.35);\nvec3 Torus_s_1 = vec3(3, 1.5, 8.0);\nvec2 Torus_r_1 = vec2(1.0, 0.4);\n\nvec4 Sphere_1 = vec4(-2.0, 0.7, 4.0, 0.82);\nvec4 Box_d = vec4(-2.0, 0.7, 4.0, 0.65);\nfloat Box_k = .0;\nvec3 Cylinder_s_1 = vec3(-2.0, 0.7, 4.0);\nvec2 Cylinder_h_1 = vec2(0.3, 0.8);\nvec3 Cylinder_s_2 = vec3(-2.0, 0.7, 4.0);\nvec2 Cylinder_h_2 = vec2(0.3, 0.8);\nvec3 Cylinder_s_3 = vec3(-2.0, 0.7, 4.0);\nvec2 Cylinder_h_3 = vec2(0.3, 0.8);\n\nvec3 Capsule_a = vec3(-2, 2, 4);\nvec3 Capsule_b = vec3(0.0,0.2,4);\nfloat Capsule_r = 0.2; \nvec3 Cylinder_s = vec3(1.4,0.4,3.0);\nvec2 Cylinder_h = vec2(0.2, 0.4);\nvec3 Ellipsoid_s = vec3(1.0,0.4,3.0);\nvec3 Ellipsoid_r = vec3(0.2, 0.4, 0.4);\nvec3 Ellipsoid_s_1 = vec3(1.8,0.4,3.0);\nvec3 Ellipsoid_r_1 = vec3(0.2, 0.4, 0.4);\n\n\nfloat sdSphere(vec3 p, vec4 s)\n{\n\treturn length(p-s.xyz)-s.w;\n}\n\nfloat sdTorus(vec3 p, vec3 c, vec2 r)\n{\n\tp -=c;\n    vec2 q = vec2(length(p.xy)-r.x,p.z);\n\treturn length(q)-r.y;\n}\n\nfloat udBox(vec3 p, vec4 d, float k)\n{\n    return length(max(abs(p-d.xyz)-d.w,0.0))- k;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h )- 0.2;\n}\n\nfloat sdCylinder1(vec3 p, vec3 s, vec2 h)\n{\n    p -= s;\n    vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder2(vec3 p, vec3 s, vec2 h)\n{\n    p -= s;\n    vec2 d = abs(vec2(length(p.yx),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder3(vec3 p, vec3 s, vec2 h)\n{\n    p -= s;\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid(vec3 p, vec3 s, vec3 r)\n{\n    p -= s;\n    return (length(p/r) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat opBlend(vec3 p, float d1, float d2, float k)\n{\n    float res = exp(-k*d1) + exp(-k*d2);\n    return -log(res)/k;\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat opS(float d1, float d2)\n{\n    return max(d1,-d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat GetDist(vec3 p)\n{\n    float pd = p.y + 0.02;\n\n    float d = min(min(min(min(\n        opBlend(p, sdEllipsoid(p, Ellipsoid_s, Ellipsoid_r),\n        \topBlend(p, sdEllipsoid(p, Ellipsoid_s_1, Ellipsoid_r_1),\n        \t\tsdCylinder1(p, Cylinder_s , Cylinder_h), 40.), 40.),\n        sdCapsule(p, Capsule_a, Capsule_b, Capsule_r)),\n\t\topS(opI(udBox(p,  Box_d,  Box_k), sdSphere(p, Sphere_1)),\n\t\t\topU(sdCylinder1(p, Cylinder_s_1, Cylinder_h_1),\n\t\t\t\topU(sdCylinder2(p, Cylinder_s_2, Cylinder_h_2),\n\t\t\t\t\tsdCylinder3(p, Cylinder_s_3, Cylinder_h_3))\t\n\t\t))),\n\t\topBlend(p, sdSphere(p, Sphere), sdTorus(p, Torus_s, Torus_r), 30.)),\n        pd);\n    \n//    vec4 Sp = vec4(0, 2. + abs(0.3*sin(iTime+5.0)),9,2);\n// \tfloat k = min(sdSphere(p, Sp), pd);\n    return d;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 a = vec2(.01, 0);\n    float d = GetDist(p);\n    vec3 n = d - vec3(GetDist(p-a.xyy),GetDist(p-a.yxy),GetDist(p-a.yyx));\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n\tfor(int i=0; i<MAX_STEPS; i++)\n    {\n\t\tvec3 p = ro + dO * rd;\n\t\tfloat dS = GetDist(p);\n\t\tdO += dS;\n\t\tif(dS<SURF_DIST || dO>MAX_DIST) break;\n\t}\n\treturn dO;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n    float a = 0.0;\n    float b = 1.0;\n    for( int i=0; i < 5; i++ )\n    {\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 c =  n * h + p;\n        float d = GetDist(c);\n        a += -(d - h) * b;\n        b *= 0.95;\n    }\n    return clamp(1.0-3.0*a, 0.0, 1.0) * 0.40 * clamp(0.5+0.5*n.y, 0.0, 1.0);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lp = vec3(2, 6, 2);\n    lp.xz += vec2(sin(iTime), cos(iTime)) * 2.;    \n    vec3 l = normalize(lp - p);\n    vec3 n = GetNormal(p);\n    vec3 np = p;\n    \n    float d = 0.05;\n    float rl = 1.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        if (d > length(lp - p)) break;\n        np = p + l * d;\n    \tfloat k = GetDist(np);\n        if (k < SURF_DIST * 0.1)\n        {\n            rl = 0.0;\n            break;\n        }\n        d += k;\n        rl = min(rl, 20. * k / d);\n    }\n    \n\tfloat dif = clamp(dot(n, l) / (length(lp - p) * length(lp - p)), 0., 1.);\n\tdif *= 20. * rl;\n    \n  //  float s = RayMarch(p + n * SURF_DIST * 2., l);\n  //  if (s < length(lp - p)) dif *= rl;\n    \n    float ao = calcAO(p, n);\n\n    return dif + ao;\n}\n\nvec3 Color(vec3 p)\n{\n    if(sdCapsule(p, Capsule_a, Capsule_b, Capsule_r) <= 0.02)\n    {\n        return vec3(1,1,0.6);\n    }\n    if(opBlend(p, sdSphere(p, Sphere), sdTorus(p, Torus_s, Torus_r), 30.) <= 0.02)\n    {\n        return vec3(0.1,0.2,0.3);\n    }\n    if(opBlend(p, sdEllipsoid(p, Ellipsoid_s, Ellipsoid_r),\n        \topBlend(p, sdEllipsoid(p, Ellipsoid_s_1, Ellipsoid_r_1),\n        \t\tsdCylinder1(p, Cylinder_s , Cylinder_h), 40.), 40.) <= 0.02)\n    {\n        return vec3(0.4,0.5,0.6);\n    }\n    if(udBox(p,  Box_d,  Box_k) <= 0.02)\n    {\n        return vec3(1,0.7,0);\n\t}\n    if(p.y <= 0.2)\n    {\n        if(sin(p.x * 20.) <= 0.) return vec3(0, 1, 0.5); \n        if(sin(p.z * 20.) <= 0.) return vec3(0, 1, 0);\n        return vec3(1, 1, 0);\n    }\n    return vec3(1,1,1);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord -.5*iResolution.xy)/iResolution.y;    \n    vec3 col = vec3(0, 1.0, 3.0 * xy.y);\n\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize (vec3(xy.x, xy.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    if (d <= MAX_DIST)  \n    {\n        vec3 p = ro + rd * d;\n\t\tfloat dif = GetLight(p);\n\t\tcol = Color(p) * dif;\n    }\n    \n    fragColor = vec4 (col, 1.);\n}","name":"Image","description":"","type":"image"}]}