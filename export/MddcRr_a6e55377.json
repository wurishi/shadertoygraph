{"ver":"0.1","info":{"id":"MddcRr","date":"1517839084","viewed":3244,"name":"deadly_halftones","username":"duvengar","description":"Testing multipass to make a halftone/glitch post processing effect over the skull sdf rendering (note the sound interaction on the glitch). To see the skull without the halftones simply change from buffer B to A in the image buffer. ","likes":112,"published":1,"flags":96,"usePreview":0,"tags":["3d","sound","postprocessing","sdf","skull","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldSXDz","filepath":"https://soundcloud.com/alex-jedi/space-effect-5","previewfilepath":"https://soundcloud.com/alex-jedi/space-effect-5","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"deadly_halftones\"\n// by Julien Vergnaud @duvengar-2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 C, in vec2 U)\n{\n    \n    // sound amplitude\n    float amp = .0;\n    amp += .5 - texelFetch(iChannel1,ivec2(20,0),0).x + .5\n       *texelFetch(iChannel1,ivec2(400,0),0).x;\n     \n    \n   \t// glitch offset \n    vec2 V  = 1. - 2. * U / R;  \n    vec2 off = vec2(S(.0, amp * CEL * .5, cos(T + U.y / R.y  *5.0 )), .0) - vec2(.5, .0);\n\t\n    // colorize\n    float r = texture(iChannel0, .03 * off + U/ R).x;\n    float g = texture(iChannel0, .04 * off + U/ R).x;\n    float b = texture(iChannel0, .05 * off + U/ R).x;\n    C = vec4(.0,.1,.2,1.);\n    \n    C += .06 * hash2(T + V * vec2(1462.439, 297.185));  // animated grain (hash2 function in common tab)\n    C += vec4(r, g, b, 1.);\n    C *= 1.25 *vec4(1. - S(.1, 1.8, length(V * V))); // vigneting\n    \n    U = mod(U,  CEL);\n    C *= .4+sign(S(.99, 1., U.y));\n    C += .14 * vec4(pow(1. - length(V*vec2(.5, .35)), 3.), .0,.0,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////////////////////////\n//     raymarch scene\n/////////////////////////////////////////////////////////////////////\n// more infos about modeling with distance functions:\n// https://iquilezles.org/articles/distfunctions\n/////////////////////////////////////////////////////////////////////\n\n\n#define IT   64    // raycasting iterations\n#define PR   .0005 // raycasting precision\n\n//==========================================================\n//            signed DISTANCE FIELD PRIMITIVES \n//==========================================================\n//\n// distance field primitives by Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\n//\n//==========================================================\n\n//-----------------------------------------------------------\n//                       SPHERE            \n//\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\n//-----------------------------------------------------------\n//                     RECTANGLE\n//\nfloat sdBox( vec3 p, vec3 b )\n{   \n  vec3 d = abs(p) - b ;   \n  return max(min(d.x, min(d.y, d.z)), .0) + length(max(d, .0));\n}\n\n//==========================================================\n//                     OPERATIONS\n//==========================================================\n//\n// distance field primitives by Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\n//\n//==========================================================\n\n// polynomial smooth min\n// add shapes smoother.\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\n\n// polynomial smooth min to add shapes smoother.\n// sustract shapes smoother.\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\n\n//==========================================================\n//          SKULL SIGNED DISTANCE FIELD \n//==========================================================\n\n\nfloat sdSkull( vec3 p, float s )\n{\n    \n    \n  // --------------------------------------------------------\n  // domain deformation on radius (s) brings some interesting\n  // results this deformation sould be applied to big shapes \n  // in order to preserve details. \n    \n  float ss = noise(p * 9.);\n  ss = mix(s,ss *.5,.1);\n  \n  \n  // sp is using symetry on z axis\n  vec3 sp = vec3(p.x, p.y, abs(p.z));\n    \n      \n  // kind of morphing effect \n  //s = clamp(cos(iTime*.5), .20,.35);\n\n  float shape = sdSphere(p - vec3(.0,.05,.0), s * .95 * cos(cos(p.y*11.)* p.z * 2.3) );\n  //---------------------------------------------------------  \n  // first part external skull top\n  // --------------------------------------------------------\n    \n  // globe front \n  shape = smin(shape,  sdSphere (p - vec3(.10, 0.23, 0.00), s * .82), .09);\n    \n  // globe back \n  shape = smin(shape,  sdSphere (p - vec3(-.1, 0.24, 0.00), s * .82), .09);\n    \n  // eye brow\n  shape = smin(shape,  sdSphere (sp - vec3(.25, 0.07, 0.10), s * .36 * cos(p.y * 7.0)), .02);\n    \n  // lateral holes - symmetry\n  shape = smax(shape, -sdSphere (sp - vec3(.15, -.01, 0.31), s * .28 * cos(p.x * .59)), .02);  \n    \n  //checkbones - symmetry\n  shape = smin(shape, sdSphere(sp-vec3(.22,-.13,.18), s*.11),.09);\n  \n  // empty the skull\n  shape = max(shape, -sdSphere(p - vec3(.0,.05,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ));  \n  shape = smax(shape,  -sdSphere (p - vec3(.10, 0.23, 0.00), s * .74),.02);\n  shape = smax(shape,  -sdSphere (p - vec3(-.1, 0.24, 0.00), s * .74),.02);\n  shape = smax(shape,  -sdSphere (p - vec3(.0, 0.24, 0.00), s * .74),.02);\n  \n  // eye balls - symmetry\n  shape = smax(shape, -sdSphere(sp-vec3(.32,-.04,.140), s  * .28 * cos(p.y*10.)),.03);\n  \n  // nose\n  //-----------------------------------------------------------\n    \n  // base nose shape\n  float temp = sdSphere(p- vec3(cos(.0)*.220,-.05, sin(.0)*.3), s * .35 * cos(sin(p.y*22.)*p.z*24.));\n    \n  // substract the eyes balls ( symetrix) & skukl globe\n  temp = smax(temp, -sdSphere(sp-vec3(.32,-.04,.140), s * .35 * cos(p.y*10.)), .02); \n  temp = smax(temp, -sdSphere(p - vec3(.0,.05,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ),.02);\n  \n  // add nose shape to skull \n  shape = smin(shape,temp,.015);  \n  \n  // empty the nose\n  shape = smax(shape, - sdSphere(p- vec3(cos(.0)*.238,-.09, sin(.0)*.3), s * .3 * cos(sin(p.y*18.)*p.z*29.)),.002);\n  \n  // substract bottom\n  shape = smax(shape, -sdSphere(p- vec3(-.15,-0.97, .0), s * 2.5 ),.01);\n    \n  // I like the noise deformation on this edge with ss for the sphere radius.\n  // It give a more natural look to the skull.\n  shape = smax(shape, -sdSphere(p- vec3(-.23,-0.57, .0), abs(ss) * 1.6 ),.01);\n    \n  //--------------------------------------------------------- \n  // skull part2: UP jaws\n  // --------------------------------------------------------\n    \n  temp = smax(sdSphere(p - vec3(.13,-.26,.0), .45 * s), -sdSphere(p - vec3(.125,-.3,.0), .40 * s), .01);\n  \n  // substract back\n  temp = smax(temp,-sdSphere(p - vec3(-.2,-.1,.0), .9 * s), .03);\n  \n  // substract bottom  \n  temp = smax(temp,-sdSphere(p - vec3(.13,-.543,.0), .9 * s), .03);\n  \n  // substract up  \n  temp = max(temp, -sdSphere(p - vec3(.0,.02,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ));  \n  shape = smin(shape, temp, .07);\n    \n   \n  // Teeths - symmetry\n  //-----------------------------------------------------------\n \n  temp = sdSphere(p - vec3(.26, -.29, .018), .053 * s );\n  temp = min(temp, sdSphere(p - vec3(.26, -.29, -.018), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.25, -.29, .05), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.235, -.29, .08), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.215, -.28, .1), .05 * s ));\n  temp = max(temp, -sdSphere(p - vec3(.16, -.35, .0), .33 * s ));   \n  temp = min(temp, sdSphere(sp - vec3(.18, -.28, .115), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.14, -.28, .115), .06 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.11, -.28, .115), .06 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.08, -.28, .115), .06 * s ));\n\n   \n  shape = smin(shape, temp, .03); \n   \n  // DOWN Jaws\n  //-----------------------------------------------------------\n  \n  temp = sdSphere(p - vec3(.1,-.32,.0), .43 * s);  \n  temp = smax (temp, - sdSphere(p - vec3(.1,-.32,.0), .37 * s ),.02);  \n  temp = smax(temp, - sdSphere(p - vec3(.1,-.034,.0), 1.03 * s),.02) ;  \n  temp = smax(temp, - sdSphere(p - vec3(.0,-.4,.0), .35 * s),.02);   \n  // symmetry\n  temp = smin(temp, sdBox(sp - vec3(.04 -.03 * cos(p.y * 20.2),-.23, .27 + sin(p.y)*.27), vec3(cos(p.y*4.)*.03,.12,.014)), .13);\n  temp = max(temp, - sdSphere(sp - vec3(.0,.153,.2), .85 * s)); \n  temp = smin (temp, sdSphere(sp - vec3(.2, -.45, 0.05), .05 * s ),.07);  \n \n  shape = smin(shape, temp, .02);  \n    \n    \n  // Teeths -  symmetry\n  //--------------------------------------------------------\n \n  temp = sdSphere(p - vec3(.23, -.34, .018), .053 * s );\n  temp = min(temp, sdSphere(p - vec3(.23, -.34, -.018), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.22, -.34, .048), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.20, -.34, .078), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.17, -.35, .098), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.14, -.35, .11), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.11, -.35, .11), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.08, -.35, .11), .053 * s));\n      \n \n  shape = 1.5 * smin(shape, temp, .025);  \n    \n  return shape ;  \n    \n}\t\n\n\n\n//==========================================================\n//                     SCENE MANAGER  \n//\n// here pull in all the objects into the scene no worry the order \n// \n//==========================================================\n\nvec2 map(vec3 pos)\n{\n \n  vec2 scene = vec2(.5 * sdSkull(pos, .35), 39.);\n  \n  return scene;     \n}\n\n//==========================================================//\n//                     RAY CASTER  \n//\n// note : iteration IT and precision PR are defined on top\n// ro and rd are ray origin and direction;\n//\n//==========================================================//\n\nvec2 castRay( vec3 ro, vec3 rd )    \n{\n    int   i     = 0;                           // raycaster iteration loop factor\n    float close = 1.0;                         // raycaster min distance\n    float far   = 3.0;                         // raycaster max distance\n   \tfloat p     = PR * close;                  // raycaster precision\n    float id    = .0;                          // casted object id\n       \n    while( i ++< IT)\n    {    \n\t  vec2 res = map(ro + rd * close);         // map() > response vec2(depth, id)\n        \n      if(abs(res.x) < p || close > far) break; // break when object something is encountred or when outside of bounds\n     \n      \tclose += res.x;\t\t\t\t           // add depth to caster \n\t  \tid  = res.y;\t\t\t\t\t\t   // write object'id\n    }\n\n    //if( close > far ) id = .0;\t\t\t\t   // when there no response we return the background id\n   \n    return vec2( close, id );\t\t\t\t   // return depth value and id\n}\n\n\n//==========================================================//\n//                       NORMALS \n//\n//==========================================================//\n\n\nvec3 calcNormal( vec3 pos )\n{\n    vec2 e = vec2(1., -1.) * PR;\n    return normalize(e.xyy * map(pos + e.xyy).x + \n\t\t\t\t\t e.yyx * map(pos + e.yyx).x + \n\t\t\t\t\t e.yxy * map(pos + e.yxy).x + \n\t\t\t\t\t e.xxx * map(pos + e.xxx).x );\n}\n\n//==========================================================//\n//                       RENDERER \n//\n//==========================================================//\n\n\nvec3 render (vec2 p, vec3 ro, vec3 rd )\n{ \n  \n  vec2  res = castRay(ro,rd);        \n  float t   = res.x;\t   \t\t\t\t\t\t \n  float m   = res.y;\n  vec3  col = vec3(.0,.0,.0);\n  vec3 pos = ro + t * rd;\n  vec3 nor = calcNormal(pos);\n        \n  // material color \n      \n  col = .45 + .55 * sin(vec3(.05, .08, .1) *  m - 1.);\n      \n  // depth fog \n\n  col = mix(col, vec3(.0,.0,.0), 1. - exp(-0.02 * pow(t, 9.5)));\n\n  return vec3( clamp(col,.0,1.0));\n}\n\n\n//==========================================================//\n//                       CAMERA \n//\n//==========================================================//\n\nmat3 setCamera(vec3 ro)\n{\n  vec3 cw = normalize(- ro);\n  vec3 cp = vec3(sin(.0), cos(.0), .0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  \n  return mat3(cu, cv, cw);\n}\n\n//==========================================================//\n//                       MAIN \n//\n//==========================================================//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec3 tot = vec3(.0,.0,.0);\n  vec2 p = (-R.xy + 2.0 * fragCoord)/R.y;\n  vec2 mo = iMouse.xy/iResolution.xy;\n\n  // camera\t\n  //---------------------------\n \n  vec3 ro = vec3(1.6*cos(iTime*.6),.0,1.6*sin(iTime*.6));\n  mat3 ca = setCamera(ro);    \n    \n  // ray direction\n\n  vec3 rd = ca * normalize(vec3(p.xy, 2.));\n\n  // render\t\n\n  vec3 col = render(p, ro, rd);\n\n  // gamma\n\n  col = pow( col, vec3(0.25) );\n\n    \n  tot += col; \n  fragColor = vec4( tot, 1.0 );\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//////////////////////////////////////\n//     HALPHTONES POSTPROCESING\n//////////////////////////////////////\n\n\nfloat make_dot (vec2 uv, float r, float c)\n{  \n   return smoothstep( r - .1, r, min( length((uv - vec2(c/2.))*2.), r));   \n}\n\nfloat get_tex(vec2 U)\n{\n    vec3 tex_col = texture(iChannel0,U / R).xyz;\n    return  .45 * (tex_col.x + tex_col.y + tex_col.z);\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\t\n   // float cel = rem(R);                                                 // float CEL = floor(R.y/70.);\n     \n    float  pixel_color = get_tex(ceil(U / CEL) * CEL);                  // calculate cel color\n   \n    float dot_radius = pixel_color ;                                    // dot radius\n    \n    U = mod(U , CEL);                                                   // cell grid\n    \n    vec4 dot_color  = vec4(make_dot(U, ceil(dot_radius * CEL ), CEL )); // make dots\n \n    C = 1. - dot_color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define T iTime\n#define R iResolution.xy\n#define S(a, b, c) smoothstep(a, b, c)\n#define PI acos(-1.)\n#define CEL rem(R)\n#define LOWRES 320.\n\n\n\nfloat rem(vec2 iR)\n{\n    float slices = floor(iR.y / LOWRES);\n    if(slices < 1.){\n        return 4.;  \n    }\n    else if(slices == 1.){\n        return 6.;\n    }\n    else if(slices == 2.){\n        return 8.;\n    }\n    else if(slices >= 3.){\n        return 10.;\n    }\n    else if(slices >= 4.){\n        return 12.;\n    }\n}\n\n/////////////////////////////////////////////\n// hash2 taken from Dave Hoskins \n// https://www.shadertoy.com/view/4djSRW\n/////////////////////////////////////////////\n\nfloat hash2(vec2 p)\n{  \n\tvec3 p3  = fract(vec3(p.xyx) * .2831);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/////////////////////////////////////////////\n//                 NOISE 3D\n// 3D noise and fbm function by Inigo Quilez\n/////////////////////////////////////////////\n\nmat3 m = mat3( .00,  .80,  .60,\n              -.80,  .36, -.48,\n              -.60, -.48,  .64 );\n\nfloat hash( float n )\n{\n    float h =  fract(sin(n) * 4121.15393);\n\n    return  h + .444;   \n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f );\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix( hash(n + 00.00), hash(n + 1.000), f.x),\n                   mix( hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n               mix(mix( hash(n + 113.0), hash(n + 114.0), f.x),\n                   mix( hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n","name":"Common","description":"","type":"common"}]}