{"ver":"0.1","info":{"id":"MtjXDw","date":"1444313526","viewed":182,"name":"Simple Bezier Path For Test","username":"Sleicreider","description":"I am a noob\nTest code\nFor test only","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","bezier","noob","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define YELLOW vec3(1.,1.,0.)\n#define BLUE vec3(0.,0.,1.)\n\nstruct Rect\n{\n    float width;\n    float height;\n    float x;\n    float y;\n    vec3  color;\n    float rotation;\n    \n    vec2 csys; //it's own coordinate system\n};\n    \nstruct BezierPath\n{\n    vec2 v1;\n    vec2 v2;\n    vec2 v3;\n    vec2 v4;\n    vec2 v5;\n};\n    \nRect CreateRect(float width, float height, float x, float y, vec3 color)\n{\n    Rect rect;\n    \n    rect.width = width;\n    rect.height = height;\n    rect.x = x;\n    rect.y = y;\n    rect.color = color;\n    \n    return rect;\n}\n\nvoid DrawRect(inout Rect rect,vec2 p, inout vec3 pix)\n{\n   \tfloat dx = p.x - rect.x;\n    float dy = p.y - rect.y;\n    \n    dx = cos(rect.rotation)*(p.x - rect.x) + sin(rect.rotation)*(p.y - rect.y);\n    dy = -sin(rect.rotation)*(p.x - rect.x) + cos(rect.rotation)*(p.y - rect.y);\n    \n    float fL = - rect.width/2.;  //far left\n    float fR = + rect.width/2.;  //far right\n    float fT = + rect.height/2.; //far top\n    float fB = - rect.height/2.; //far bottom\n\n    //anti-aliasing\n    float del;\n    del =  smoothstep(fL - 0.005, fL + 0.005,dx);\n    del *= 1. - smoothstep(fR - 0.005, fR + 0.005,dx);\n    del *=  smoothstep(fB - 0.005, fB + 0.005,dy);\n    del *= 1. - smoothstep(fT - 0.005, fT + 0.005,dy);\n    \n    float d = 0.005;\n    \n    if(dx > fL-d && dx < fR+d \n    && dy < fT+d && dy > fB-d)\n    {\n        pix = mix(pix,rect.color,del);\n    }\n    \n    rect.csys = vec2(dx,dy);\n}\n\nfloat GetPathCoord(float p1, float p2, float percent)\n{\n   return p1 + ((p2 - p1) * percent);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.* vec2(fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    \n    vec3 pixel = vec3(0.);\n    \n\n    \n    \n    BezierPath bp;\n    \n    bp.v1 = vec2(0.,1.);\n    bp.v2 = vec2(0.,0.);\n    bp.v3 = vec2(0.,0.);\n    bp.v4 = vec2(0.,0.);\n    bp.v5 = vec2(1.,0.);\n    \n    Rect r1 = CreateRect(0.05,0.05,bp.v1.x,bp.v1.y,YELLOW);\n    Rect r2 = CreateRect(0.05,0.05,bp.v2.x,bp.v2.y,YELLOW);\n    Rect r3 = CreateRect(0.05,0.05,bp.v3.x,bp.v3.y,YELLOW);\n    Rect r4 = CreateRect(0.05,0.05,bp.v4.x,bp.v4.y,YELLOW);\n    Rect r5 = CreateRect(0.05,0.05,bp.v5.x,bp.v5.y,YELLOW);\n\n    \n    DrawRect(r1,r,pixel);\n    DrawRect(r2,r,pixel);\n    DrawRect(r3,r,pixel);\n    DrawRect(r4,r,pixel);\n    DrawRect(r5,r,pixel);\n\n    \n    float percent = (mod(iTime,4.0))/ 4.0;\n    \n    float ax = GetPathCoord(bp.v1.x,bp.v2.x,percent);\n    float ay = GetPathCoord(bp.v1.y,bp.v2.y,percent);\n    float bx = GetPathCoord(bp.v2.x,bp.v3.x,percent);\n    float by = GetPathCoord(bp.v2.y,bp.v3.y,percent);\n    float cx = GetPathCoord(bp.v3.x,bp.v4.x,percent);\n    float cy = GetPathCoord(bp.v3.y,bp.v4.y,percent);\n    float dx = GetPathCoord(bp.v4.x,bp.v5.x,percent);\n    float dy = GetPathCoord(bp.v4.y,bp.v5.y,percent);\n\n   \n    float nx = GetPathCoord(ax,bx,percent);\n    float ny = GetPathCoord(ay,by,percent);\n    nx = GetPathCoord(nx,cx,percent);\n    ny = GetPathCoord(ny,cy,percent);\n    nx = GetPathCoord(nx,dx,percent);\n    ny = GetPathCoord(ny,dy,percent);\n    \n   \n    Rect rp = CreateRect(0.05,0.05,nx,ny,BLUE);\n\tDrawRect(rp,r,pixel);\n\n\n    \n\n    \n    fragColor = vec4(pixel,1.);\n}","name":"","description":"","type":"image"}]}