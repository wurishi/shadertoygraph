{"ver":"0.1","info":{"id":"mdjSRd","date":"1670759875","viewed":133,"name":"ChatGPT Raytracer","username":"NTO256","description":"This shader was made using ChatGPT, apart from small corrections this has entirely been generated by OpenAIs Language Model ChatGPT","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","ai","chatgpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Funktion zur Rotierung eines Vektors um einen gegebenen Winkel\nvec2 rotate(vec2 v, float angle)\n{\n    // Berechnung der rotierten Koordinaten\n    vec2 rotated = vec2(0.0);\n    rotated.x = v.x * cos(angle) - v.y * sin(angle);\n    rotated.y = v.x * sin(angle) + v.y * cos(angle);\n\n    // Rückgabe der rotierten Koordinaten\n    return rotated;\n}\n\n// Funktion zur Berechnung der UV-Koordinaten eines Punkts auf der Sphäre\nvec2 getUVCoords(vec3 point, vec3 center, float radius)\n{\n    // Berechnung der UV-Koordinaten\n    vec2 uv = vec2(0.0);\n\n    // Berechnung des Einheitsvektors, der von der Sphärenmitte zum Punkt zeigt\n    vec3 vec = normalize(point - center);\n\n    // Berechnung der UV-Koordinaten aus dem Einheitsvektor\n    uv.x = 0.5 + atan(vec.z, vec.x) / (2.0 * 3.14159265);\n    uv.y = 0.5 - asin(vec.y) / 3.14159265;\n\n    // Rückgabe der UV-Koordinaten\n    return uv;\n}\n\n// Funktion zur Berechnung der HDRI-Farbe aus iChannel0, wobei die Textur basierend auf der Zeit rotiert wird\nvec3 calcHDRI(vec3 point, vec3 center, float radius)\n{\n    float time = iTime;\n    // Berechnung der Bildschirmkoordinaten des Punkts\n    vec2 screenCoords = (point.xy + vec2(1.0, 1.0)) / 2.0;\n\n    // Berechnung des Winkels, um den die Textur rotiert werden soll\n    float angle = time * 0.5;\n\n    // Rotierung der Bildschirmkoordinaten um den berechneten Winkel\n    screenCoords = rotate(screenCoords, angle);\n\n    // Berechnung der HDRI-Farbe aus iChannel0 an den rotierten Bildschirmkoordinaten\n    vec3 hdriColor = texture(iChannel0, screenCoords).rgb;\n\n    // Rückgabe der HDRI-Farbe\n    return hdriColor;\n}\n\n// Funktion zur Berechnung der Lichtintensität an einem Punkt\n// auf der Sphäre mithilfe des Phong-Shading-Modells\nfloat calcLightIntensity(vec3 point, vec3 normal, vec3 lightPos, float specularExponent)\n{\n    // Berechnung der Lichtintensität\n\n    // Berechnung des Vektors von der Lichtquelle zum Punkt\n    vec3 lightVec = normalize(lightPos - point);\n\n    // Berechnung des Vektors von der Kamera zum Punkt\n    vec3 viewVec = normalize(-point);\n\n    // Berechnung des reflektierten Vektors\n    vec3 reflectVec = reflect(-lightVec, normal);\n\n    // Berechnung des Diffus- und Spekularanteils\n    float diffuseFactor = max(dot(lightVec, normal), 0.0);\n    float specularFactor = pow(max(dot(reflectVec, viewVec), 0.0), specularExponent);\n\n    // Rückgabe der Lichtintensität\n    return diffuseFactor + specularFactor;\n}\n\n// Funktion zur Berechnung der Kollision von Strahlen mit der Sphäre\nfloat collideSphere(vec3 ro, vec3 rd, vec3 sp, float spRadius)\n{\n    vec3 oc = ro - sp;\n\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - spRadius * spRadius;\n\n    float delta = b * b - 4.0 * a * c;\n\n    if(delta < 0.0) return -1.0;\n\n    float t1 = (-b - sqrt(delta)) / (2.0 * a);\n    float t2 = (-b + sqrt(delta)) / (2.0 * a);\n\n    if(t1 > 0.0 && t2 > 0.0) return min(t1, t2);\n    else if(t1 > 0.0) return t1;\n    else if(t2 > 0.0) return t2;\n    else return -1.0;\n}\n\n// Funktion zur Berechnung der Farbe einer leicht reflektierenden und leicht transparenten roten Sphäre\nvec3 calcSphereColor(vec3 ray, vec3 point, vec3 center, float radius, vec3 norm)\n{\n    // Berechnung des Normalenvektors an der Stelle des Ray-Sphäre-Schnittpunkts\n    vec3 normal = norm;\n\n    // Berechnung des reflektierten Strahls\n    vec3 reflectedRay = reflect(ray, normal);\n\n    // Berechnung der Farbe des reflektierten Strahls\n    vec3 origin = point;\n    vec3 pos = origin + collideSphere(origin, reflectedRay, vec3(0.0, 0.0, 0.0), 4.0)*reflectedRay;\n    vec3 reflectedColor = calcHDRI(pos, vec3(0.0, 0.0, 0.0), 4.0);\n\n    // Berechnung der Farbe der roten Sphäre\n    vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n\n    // Mischung der Farben des reflektierten Strahls und der roten Sphäre\n    vec3 finalColor = mix(reflectedColor, sphereColor, 0.5);\n\n    // Anwendung eines leichten Transparenzeffekts auf die Farbe der Sphäre\n    finalColor *= vec3(1.0, 1.0, 1.0) * 0.8;\n\n    // Rückgabe der Farbe der Sphäre\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Koordinaten auf der Einheitskugel berechnen\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 uv3 = vec3(uv * 2.0 - 1.0, 1.0 - dot(uv, uv) * 0.5);\n    uv3.xy *= vec2(1.0, -1.0);\n\n    // Raytracing\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv3.xy, uv3.z));\n\n    // Sphäre\n    vec3 sp = vec3(0.0, 0.0, 0.0);\n    float spRadius = 0.5;\n\n    // Kollision der Strahlen mit der Sphäre\n    float t = collideSphere(ro, rd, sp, spRadius);\n\n    // Wenn es eine Kollision gibt, Farbe auf Rot setzen\n    if(t > 0.0)\n    {\n        vec3 pos = t*rd + ro;\n        vec3 norm = normalize(pos - sp);;\n        fragColor = vec4(calcSphereColor(rd, pos, sp, spRadius, norm), 0.0)*calcLightIntensity(pos, norm, vec3(1.0, 1.0, -1.0), 3.0);\n    }\n    else\n    {\n        float t_hdri = collideSphere(ro, rd, vec3(0.0, 0.0, 0.0), 5.0);\n        fragColor = vec4(calcHDRI(ro + rd*t_hdri, vec3(0.0, 0.0, 0.0), 5.0), 0.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}