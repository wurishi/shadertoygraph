{"ver":"0.1","info":{"id":"M3VXWG","date":"1720556005","viewed":52,"name":"Complex interval inverse","username":"unhyperbolic","description":"Left: complex interval. Drag corner/edge to change.\nRight: image under z |-> 1/z, hit c to conjugate.\nRight, yellow: result of naive method (hit n to hide), that is a/(a^2+b^2) - i * b/(a^2+b^2) using real interval arithmetic\nRight, green: tight interval","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// To compute the green complex interval, we use the\n// code from\n// https://github.com/sagemath/sage/blob/32568caef0e486eea6e16c50c00263afd0f63265/src/sage/rings/complex_interval.pyx#L1125\n\n// That code is cython and is using mpfr.\n\n// Do some #define's and definitions to emulate cython\n// and mpfr:\n\n#define cdef\n#define bint bool\n#define False false\n#define True true\n#define mpfr_rnd_t int\n#define MPFR_RNDD 0\n#define MPFR_RNDU 1\n#define mpfr_t float\n#define mpfr_srcptr float\n#define mpfr_ptr inout float\n#define mpfr_prec_t int\n\n#define and &&\n#define not !\n\nfloat myNaN = sqrt(-1.0);\n\nbool mpfi_has_zero(vec2 x)\n{\n    return x.x <= 0.0 && x.y >= 0.0;\n}\n\nvoid mpfr_init2(mpfr_ptr a, mpfr_prec_t prec)\n{\n}\n\nvoid mpfr_clear(mpfr_ptr a)\n{\n}\n\nvoid mpfr_swap(mpfr_ptr a, mpfr_ptr b)\n{\n    mpfr_t tmp = a;\n    a = b;\n    b = tmp;\n}\n\nvoid mpfr_neg(mpfr_ptr a, mpfr_srcptr b, mpfr_rnd_t rnd)\n{\n    a = -b;\n}\n\nvoid mpfr_add(mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd)\n{\n    a = b + c;\n}\n\nvoid mpfr_div(mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd)\n{\n    a = b / c;\n}\n\nvoid mpfr_ui_div(mpfr_ptr a, int b, mpfr_srcptr c, mpfr_rnd_t rnd)\n{\n    a = float(b) / c;\n}\n\nvoid mpfr_div_2ui(mpfr_ptr a, mpfr_ptr b, int c, mpfr_rnd_t rnd)\n{\n    a = b / pow(2.0, float(c));\n}\n\nvoid mpfr_min(mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd)\n{\n    a = min(b,c);\n}\n\nvoid mpfr_sqr(mpfr_ptr a, mpfr_srcptr b, mpfr_rnd_t rnd)\n{\n    a = b * b;\n}\n\nint mpfr_sgn(mpfr_srcptr a)\n{\n    return int(sign(a));\n}\n\n\nint mpfr_cmp(mpfr_srcptr a, mpfr_srcptr b)\n{\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return +1;\n    }\n    return 0;\n}\n\nint mpfr_cmpabs(mpfr_srcptr a, mpfr_srcptr b)\n{\n    return mpfr_cmp(abs(a), abs(b));\n}\n\n//////////////////////////////////////////////////\n//\n// The code from the above pyx file translated to glsl.\n\nvoid _negate_interval(mpfr_ptr xmin, mpfr_ptr xmax)\n{\n    mpfr_swap(xmin, xmax);\n    mpfr_neg(xmin, xmin, MPFR_RNDD);\n    mpfr_neg(xmax, xmax, MPFR_RNDU);\n}\n\nvoid _inversion_coordinate(\n    mpfr_ptr result, mpfr_ptr tmp,\n    mpfr_srcptr x, mpfr_srcptr y, mpfr_rnd_t rnd_denom, mpfr_rnd_t rnd)\n{\n    mpfr_sqr(tmp,    x, rnd_denom);\n    mpfr_sqr(result, y, rnd_denom);\n    mpfr_add(tmp, tmp, result, rnd_denom);\n    mpfr_div(result, x, tmp, rnd);\n}\n\nvoid _inversion_coordinate_pos_down(\n    mpfr_ptr result, mpfr_ptr tmp,\n    mpfr_srcptr x, mpfr_srcptr y)\n{\n    _inversion_coordinate(\n        result, tmp, x, y,\n        MPFR_RNDU,\n        MPFR_RNDD);    \n}\n\nvoid _inversion_coordinate_pos_up(\n    mpfr_ptr result, mpfr_ptr tmp,\n    mpfr_srcptr x, mpfr_srcptr y)\n{\n    _inversion_coordinate(\n        result, tmp, x, y,\n        MPFR_RNDD,\n        MPFR_RNDU);\n}\n\nvoid _inversion_coordinate_neg_down(\n    mpfr_ptr result, mpfr_ptr tmp,\n    mpfr_srcptr x, mpfr_srcptr y)\n{\n    _inversion_coordinate(\n        result, tmp, x, y,\n        MPFR_RNDD,\n        MPFR_RNDD);\n}\n\nvoid _circle_invert_standard(\n    mpfr_ptr amin, mpfr_ptr amax, mpfr_ptr bmin, mpfr_ptr bmax,\n    mpfr_srcptr xmin, mpfr_srcptr xmax, mpfr_srcptr ymin, mpfr_srcptr ymax,\n    bint crosses_x_axis, mpfr_prec_t prec)\n{\n    cdef bint crosses_NE_diagonal = mpfr_cmp(ymax, xmin) > 0;\n    cdef bint crosses_both_diagonals = False;\n    if (crosses_x_axis and crosses_NE_diagonal) {\n        crosses_both_diagonals = mpfr_cmpabs(ymin, xmin) > 0;\n    }\n    \n    cdef mpfr_t tmp, min2;\n    \n    mpfr_init2(tmp, prec);\n    if (crosses_NE_diagonal) {\n        mpfr_init2(min2, prec);\n    }\n    \n    _inversion_coordinate_pos_down(amin, tmp, xmax, ymax);\n    if (crosses_NE_diagonal) {\n        _inversion_coordinate_pos_down(min2, tmp, xmin, ymax);\n        mpfr_min(amin, amin, min2, MPFR_RNDD);\n    }\n    \n    if (crosses_x_axis) {\n        mpfr_ui_div(amax, 1, xmin, MPFR_RNDU);\n    } else {\n        _inversion_coordinate_pos_up(amax, tmp, xmin, ymin);\n    }\n    \n    if (crosses_NE_diagonal) {\n        if (crosses_x_axis) {\n            mpfr_div_2ui(bmax, amax, 1, MPFR_RNDU);\n        } else {\n            mpfr_ui_div(bmax, 1, xmin, MPFR_RNDU);\n            mpfr_div_2ui(bmax, bmax, 1, MPFR_RNDU);\n        }\n    } else {\n        _inversion_coordinate_pos_up(bmax, tmp, ymax, xmin);\n    }  \n    \n    cdef bint right_edge_crosses_NE_diagonal;\n\n    if (crosses_x_axis) {\n        if (crosses_both_diagonals) {\n            mpfr_neg(bmin, bmax, MPFR_RNDD);\n        } else {\n            _inversion_coordinate_neg_down(bmin, tmp, ymin, xmin);\n        }\n    } else {\n        _inversion_coordinate_pos_down(bmin, tmp, ymin, xmax);\n        if (crosses_NE_diagonal) {\n            right_edge_crosses_NE_diagonal = mpfr_cmp(ymax, xmax) > 0;\n            if (right_edge_crosses_NE_diagonal) {\n                _inversion_coordinate_pos_down(min2, tmp, ymax, xmax);\n                mpfr_min(bmin, bmin, min2, MPFR_RNDD);\n            }\n        }\n    }\n\n    mpfr_clear(tmp);\n    if (crosses_NE_diagonal) {\n        mpfr_clear(min2);\n    }\n}\n\nvec4 ComplexIntervalFieldElement_invert_(vec4 self)\n{\n   mpfr_prec_t self_prec = 53;\n\n   vec2 self_re = self.xy;\n   vec2 self_im = self.zw;\n   \n   // Checking for NaN doesn't make sense here...\n   \n   if (mpfi_has_zero(self_re) && mpfi_has_zero(self_im))\n   {\n       return vec4(myNaN, myNaN, myNaN, myNaN);\n   }\n\n   mpfr_t xmin = self_re.x;\n   mpfr_t xmax = self_re.y;\n   mpfr_t ymin = self_im.x;\n   mpfr_t ymax = self_im.y;\n\n   cdef bint negated_x = False;\n   cdef bint negated_y = False;\n   cdef bint swapped_xy = False;\n\n   cdef bint crosses_x_axis = False;\n\n   if (mpfr_sgn(ymax) <= 0) {\n       _negate_interval(ymin, ymax);\n       negated_y = True;\n   } else if (mpfr_sgn(ymin) < 0) {\n       crosses_x_axis = True;\n   }\n   \n   if (mpfr_sgn(xmax) <= 0) {\n       _negate_interval(xmin, xmax);\n       negated_x = True;\n   } else if (mpfr_sgn(xmin) < 0) {\n       mpfr_swap(xmin, ymin);\n       mpfr_swap(xmax, ymax);\n       swapped_xy = True;\n       crosses_x_axis = True;\n   }\n\n   if (crosses_x_axis) {\n       if (mpfr_cmpabs(ymin, ymax) > 0) {\n           _negate_interval(ymin, ymax);\n           if (swapped_xy) {\n               negated_x = True;\n           } else {\n               negated_y = True;\n           }\n       }\n   } else {\n       if (mpfr_cmp(xmin, ymin) < 0) {\n           mpfr_swap(xmin, ymin);\n           mpfr_swap(xmax, ymax);\n           swapped_xy = True;\n       }\n   }\n\n   cdef mpfr_t amin, amax, bmin, bmax;\n\n   mpfr_init2(amin, self_prec);\n   mpfr_init2(amax, self_prec);\n   mpfr_init2(bmin, self_prec);\n   mpfr_init2(bmax, self_prec);\n\n   _circle_invert_standard(\n            amin, amax, bmin, bmax,\n            xmin, xmax, ymin, ymax,\n            crosses_x_axis, self_prec);\n\n   if (swapped_xy) {\n       mpfr_swap(amin, bmin);\n       mpfr_swap(amax, bmax);\n   }\n\n   if (negated_x) {\n       _negate_interval(amin, amax);\n   }\n   if (not negated_y) {\n       _negate_interval(bmin, bmax);\n   }\n \n   return vec4(amin, amax, bmin, bmax);\n}\n\n//////////////////////////////////////////////////\n// Naive division algorithm\n\nfloat minSqr(float a, float b)\n{\n    if (a * b < 0.0) {\n        return 0.0;\n    }\n    return min(a * a, b * b);\n}\n\nfloat maxSqr(float a, float b)\n{\n    return max(a * a, b * b);\n}\n\nfloat minQuot(float a, float b, float c, float d)\n{\n    return min(a/c, min(a/d, min(b/c, b/d)));\n}\n\nfloat maxQuot(float a, float b, float c, float d)\n{\n    return max(a/c, max(a/d, max(b/c, b/d)));\n}\n\nvec4 naiveDivision(vec4 complexInterval)\n{\n    float minDenom = \n        minSqr(complexInterval.x, complexInterval.y) + \n        minSqr(complexInterval.z, complexInterval.w);\n    float maxDenom =\n        maxSqr(complexInterval.x, complexInterval.y) +\n        maxSqr(complexInterval.z, complexInterval.w);\n\n    return vec4(\n         minQuot(complexInterval.x, complexInterval.y, minDenom, maxDenom),\n         maxQuot(complexInterval.x, complexInterval.y, minDenom, maxDenom),\n        -maxQuot(complexInterval.z, complexInterval.w, minDenom, maxDenom),\n        -minQuot(complexInterval.z, complexInterval.w, minDenom, maxDenom));\n}\n\nbool isIn(vec2 z, vec4 complexInterval)\n{\n    return\n        complexInterval.x <= z.x &&\n        complexInterval.y >= z.x &&\n        complexInterval.z <= z.y &&\n        complexInterval.w >= z.y;        \n}\n\nvec4 colorForInputRect(vec4 state1, vec2 z)\n{\n    if (state1.x < z.x && z.x < state1.y &&\n        state1.z < z.y && z.y < state1.w) {\n        return vec4(\n            (z.x - state1.x) / (state1.y - state1.x),\n            (z.y - state1.z) / (state1.w - state1.z),\n            0.5,\n            1.0);    \n    } else {\n        return vec4(0.0, 0.0, 0.0, 0.0);        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 state1 = texture(\n            iChannel0,\n            vec2(150.0 / iChannelResolution[0].x, 0.5));\n\n    vec4 state2 = texture(\n            iChannel0,\n            vec2(250.0 / iChannelResolution[0].x, 0.5));\n\n    bool conjugate = (state2.y > 0.5);\n\n    if (state1.x > state1.y) {\n        state1.xy = state1.yx;\n    }\n\n    if (state1.z > state1.w) {\n        state1.zw = state1.wz;\n    }\n\n    vec2 z = scale * (fragCoord - zCenter * iResolution.xy) / iResolution.x;\n\n    fragColor = colorForInputRect(state1, z);\n\n    if (abs(z.x) < 1.5 && abs(z.y) < 1.5) {\n        if (abs(z.x) < 0.01 || abs(z.y) < 0.01 || abs(abs(z.x) - abs(z.y)) < 0.01) {\n            fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n        }\n    }\n    \n    vec2 w = scale * (fragCoord - wCenter * iResolution.xy) / iResolution.x;\n    \n    if (abs(w.x) < 1.5 && abs(w.y) < 1.5) {\n    \n        if (conjugate) {\n            w.y = -w.y;\n        }\n    \n        vec2 zinv = vec2(w.x, -w.y) / (w.x * w.x + w.y * w.y);\n    \n        fragColor = colorForInputRect(state1, zinv);\n        \n        if (state2.w < 0.5) {\n            if (fragColor.w < 0.5) {\n                if (isIn(w, naiveDivision(state1))) {\n                    fragColor.rgb = vec3(0.5, 0.5, 0.0);\n                }\n                if (isIn(w, ComplexIntervalFieldElement_invert_(state1))) {\n                    fragColor.rgb = vec3(0.0, 0.5, 0.0);\n                }\n            }\n        }\n    \n        if (abs(w.x) < 0.01 || abs(w.y) < 0.01 || abs(abs(w.x) - abs(w.y)) < 0.01) {\n            fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n        }\n    }    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;    \n\n    // Output to screen\n//    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // state0.x == -1 drag left edge, +1 drag right edge, 0 drag no vertical edge\n    // state0.y == -1 drag bottom edge, +1 top edge, 0 drag no horizontal edge\n    // state0.w ==  1 initialized\n    vec4 state0 = texture(\n            iChannel0,\n            vec2(50.0 / iChannelResolution[0].x, 0.5));\n    // Complex interval given by\n    // [state1.x, state1.y] + [state1.z, state1.w] * i\n    vec4 state1 = texture(\n            iChannel0,\n            vec2(150.0 / iChannelResolution[0].x, 0.5));\n    // state2.x c key pressed\n    // state2.y c key toggled\n    // state2.z n key pressed\n    // state2.w n key toggled\n    vec4 state2 = texture(\n            iChannel0,\n            vec2(250.0 / iChannelResolution[0].x, 0.5));\n\n    if (abs(state0.w) < 0.5) {\n        state1 = vec4(0.8, 1.2, 0.1, 0.5);\n        state0.w = 1.0;\n    }\n\n    vec2 z = scale * (iMouse.xy - zCenter * iResolution.xy) / iResolution.x;\n\n    if (iMouse.z > 0.0) {\n        if (abs(state0.x) < 0.5 && abs(state0.y) < 0.5) {\n            float dx0 = abs(z.x - state1.x);\n            float dx1 = abs(z.x - state1.y);\n            \n            if (dx0 < dx1) {\n                if (dx0 < 0.05) {\n                   state0.x =  1.0;\n                }\n            } else {\n                if (dx1 < 0.05) {\n                   state0.x = -1.0;\n                }\n            }\n            \n            float dy0 = abs(z.y - state1.z);\n            float dy1 = abs(z.y - state1.w);\n            \n            if (dy0 < dy1) {\n                if (dy0 < 0.05) {\n                    state0.y =  1.0;\n                }\n            } else {\n                if (dy1 < 0.05) {\n                    state0.y = -1.0;\n                }\n            }\n        }\n        if (state0.x > 0.0) {\n            state1.x = z.x;\n        }\n        if (state0.x < 0.0) {\n            state1.y = z.x;\n        }\n        if (state0.y > 0.0) {\n            state1.z = z.y;\n        }\n        if (state0.y < 0.0) {\n            state1.w = z.y;\n        }\n    } else {\n        state0.xy = vec2(0.0);\n    }\n    \n    if (texelFetch(iChannel1, ivec2(67, 0), 0).x > 0.5) {\n        if (state2.x < 0.5) {\n            state2.x = 1.0;\n            state2.y = 1.0 - state2.y;\n        }\n    } else {\n        state2.x = 0.0;\n    }\n    if (texelFetch(iChannel1, ivec2(78, 0), 0).x > 0.5) {\n        if (state2.z < 0.5) {\n            state2.z = 1.0;\n            state2.w = 1.0 - state2.w;\n        }\n    } else {\n        state2.z = 0.0;\n    }\n\n    if (fragCoord.x < 100.0) {\n        fragColor = state0;\n    } else if (fragCoord.x < 200.0) {\n        fragColor = state1;\n    } else if (fragCoord.x < 300.0) {\n        fragColor = state2;    \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float scale = 6.5;\n\nvec2 zCenter = vec2(0.25, 0.5);\n\nvec2 wCenter = vec2(0.75, 0.5);","name":"Common","description":"","type":"common"}]}