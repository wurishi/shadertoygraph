{"ver":"0.1","info":{"id":"ddVBzm","date":"1698088338","viewed":231,"name":"Galaxy, StarField, Universe","username":"nayk","description":"stars,galaxy, universe","likes":10,"published":1,"flags":1,"usePreview":0,"tags":["galaxy","stars","universe","compile","copypast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*original https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/wly3Dy https://www.shadertoy.com/view/tllfRX */\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define NUM_LAYERS 8.\n#define TAU 6.28318\n#define PI 3.141592\n#define Velocity .025 //modified value to increse or decrease speed, negative value travel backwards\n#define StarGlow 0.025\n#define StarSize 02.\n#define CanvasView 20.\n\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);\n  \tfloat m = sin(StarGlow*1.2)/d;  \n    float rays = max(0., .5-abs(uv.x*uv.y*1000.)); \n    m += (rays*flare)*2.;\n    m *= smoothstep(1., .1, d);\n    return m;\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n#define LAYERS 6.0\n\nfloat hash21( vec2 id ){\n   id = fract( id * vec2( 123.34 , 456.21 ) );\n   id += dot( id , id + 425.321);\n   return fract( id.x * id.y );\n}\n \nmat2 rotate( float a ){\n    // Takes an angle in Radians\n    float s = sin(a);\n    float c = cos(a);\n    \n    // Returns a 2d Rotation Matrix\n    return mat2(c, -s , s , c);\n}\nfloat star( vec2 uv , float flare , float rand ){\n    // Simulating a light like shape\n    float d = length(uv);\n    float starLight = 0.52/d;\n \n    vec2 rotUv = uv * rotate( 3.1415 / 4.0 );\n    float rotRays = max( 1.0 , 1.0 - abs( rotUv.x * rotUv.y * 1000.0 ) ) * 1.05 * flare;\n    \n    float allLight =  starLight + rotRays;\n    \n    allLight *= smoothstep( 0.3 , 0.2 , d );\n    return max( allLight , 0.0 );\n}\nvec3 StarLayer(vec2 uv){\n     vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    vec3 col = vec3( 0 );\n    \n    for( int y=-1; y<=1; y++ ) {\n        for( int x=-1; x<=1; x++ ) {\n            vec2 offset = vec2(x , y);\n            vec2 thisId = offset + id;\n            \n            float starRand = Hash21( thisId );\n            float size = fract(starRand *405.32 );\n            vec2 starPos = gv - offset - vec2( sin(starRand * 0.3423) * 0.5 + 0.5 , fract( starRand * 1.123 ) ) + 0.5;\n            \n            float thisStar = star( starPos , smoothstep( .9 , 1.0, 1.0 ) , starRand  );\n            \n            vec3 color = sin( vec3(0.02 , 0.01 , 0.09) * fract( starRand * 10.2 ) * 123.2 ) * 0.5 + 0.5;\n            color = max( color, vec3( 0.04 , 1.0 , 0.4 ) );\n            \n            color *= vec3(0.1 , 0.6 , 1.0 + size );\n            \n            col += thisStar *0.01 * color;\n        }\n    }\n    \n    return col;\n}\n\n\n#define BURST\n#define NUM_LAYERS2 10.\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Star2(vec2 uv, float a, float sparkle) {\n    vec2 av1 = abs(uv);\n \tvec2 av2 = abs(uv*Rot(a));\n    vec2 av = min(av1, av2);\n    \n    vec3 col = vec3(0);\n    float d = length(uv);\n    float star = av1.x*av1.y;\n    star = max(av1.x*av1.y, av2.x*av2.y);\n    star = max(0., 1.-star*1e3);\n    \n    float m = min(5., 1e-2/d);\n    \n    return m+pow(star, 4.)*sparkle;\n}\n\nfloat Hash212(vec2 p) {\n    p = fract(p*vec2(123.34,145.54));\n    p += dot(p, p+45.23);\n    return fract(p.x*p.y);\n}\n\nvec3 StarLayer2(vec2 uv, float t, float sparkle) {\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\tvec3 col = vec3(0);\n    \n    #ifndef BURST\n    t = 0.;\n    #endif\n    \n    for(int y=-1; y<=1; y++) {\n        for(int x=-1; x<=1; x++) {\n            vec2 offs = vec2(x, y);\n            float n = Hash21(id-offs);\n\t\t\tvec3 N = fract(n*vec3(10,100,1000));\n            vec2 p = (N.xy-.5)*.7;\n            \n            float brightness2 = Star2(gv-p+offs, n*6.2831+t, sparkle);\n            vec3 star = brightness2*vec3(.6+p.x, .4, .6+p.y)*N.z*N.z;\n            \n            \n            \n            star *= 1.+sin((t+n)*20.)*smoothstep(sin(t)*.5+.5, 1., fract(10.*n));\n            \n            float d = length(gv+offs);\n            \n            col += star*smoothstep(1.5, .8, d);\n        }\n    }\n    return col;\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n            p.xy*=mat2(cos(iTime*0.1),sin(iTime*0.1),-sin(iTime*0.1),cos(iTime*0.1));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n    \tvec2 uv2=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n    \n\n    \n\tfloat t = iTime*.3;\n\t\n    float twirl = sin(t*.1);\n    twirl *= twirl*twirl*sin(dot(uv,uv));\n    uv2 *= Rot(-t*.2);\n    \n    uv2 *= 20.+sin(t*.05);\n    \n    vec3 col = vec3(0);\n    float speed2 = -.2;\n   \n    speed2 = .1;\n    float bla = sin(t+sin(t+sin(t)*.5))*.5+.5;\n    float d = dot(uv2,uv2);\n    \n    float a = atan(uv2.x, uv2.y);\n   \n    float burst = sin(-iTime*.05);\n   \n    \n    float stp = 1./NUM_LAYERS;\n        \n    for(float i=0.; i<1.; i+=stp) {\n    \tfloat lt = fract(t*speed+i);\n        float scale = mix(10., .25, lt);\n        float fade = smoothstep(0., .4, lt)*smoothstep(1., .95, lt); \n        vec2 sv = uv2*scale+i*134.53+iTime;\n        \n        col += StarLayer2(sv, t, fade)*fade;\n    }\n    \n   \n   \n    float burstFade = smoothstep(0., .02, abs(burst));\n    float size = .9*sin(t)+1.;\n    size = max(size, sqrt(size));\n    float fade = size/d;\n    col *= mix(1., fade, burstFade);\n    col += fade*.2*vec3(1., .5, .1)*bla*burstFade;\n    \n    t*=1.5;\n    \n    a -= -iTime*.1;\n    float rays = sin(a*5.+t*3.)-cos(a*7.-t);\n    rays *= sin(a+t+sin(a*4.)*10.)*.5+.5;\n    col += rays*bla*.1*burstFade;\n    col += 1.-burstFade;\n  \n    col *= 4.;\n   \n\t\n  \n    float t2 = iTime*Velocity; \n    vec3 col2 = vec3(0);  \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS){\n        float depth = fract(i*t);\n        float scale = mix(CanvasView, .5, depth);\n        \n        col += StarLayer(uv*scale+i*453.2-iTime*.05);}   \n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n    fragColor+=vec4(col,1.);\n}\n","name":"Image","description":"","type":"image"}]}