{"ver":"0.1","info":{"id":"ldcGWH","date":"1449266031","viewed":1820,"name":"Berry","username":"kuvkar","description":"trying to do something like http://viscorbel.com/wp-content/uploads/The-basics_html_m6c308b3d.jpg. Mouse to view the model.","likes":66,"published":1,"flags":0,"usePreview":0,"tags":["subsurface","fresnel","berry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\nfloat sdBerry( vec3 p, float s )\n{\n  p.x += min(p.y, 0.0) * 0.5;\n  return length(p)-s;\n}\n\n////////\n////////\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nmat3 rotation;\n\n/**\n* trying to do something like http://viscorbel.com/wp-content/uploads/The-basics_html_m6c308b3d.jpg \n* also, http://http.developer.nvidia.com/GPUGems/gpugems_ch16.html\n*/\nfloat map(in vec3 rp)\n{\n    rp *= rotation;\n    \n    // thanks Shane!\n\tfloat d = sdBerry(rp, 0.055) - dot(abs(sin(rp*140.0)), vec3(0.0035));\n    d = min(d, sdBerry(rp, 0.055) - dot(abs(sin(rp*160.0)), vec3(0.0025)));\n    d -= dot(abs(sin(rp*1000.0)), vec3(0.0001));\n\treturn d;\n}\n\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.0001, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\nfloat trace(inout vec3 rp, in vec3 rd, inout vec3 closestPoint)\n{\n    float closest = 99.0;\n    bool hit = false;\n    for (int i = 0; i < 250; ++i)\n    {\n        float dist = map(rp);\n        if (dist < closest)\n        {\n        \tclosest = dist;\n            closestPoint = rp;\n        }\n        \n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist * 0.5, 0.00001);\n        \n        if(rp.z > 1.0) \n        {\n            rp += (1.0 - rp.z) * rd;\n            break;\n        }\n        \n    }\n    return closest;\n}\n\n// (too much) tweakable parameters.\n// falloff control\nconst float density = 8.;\nconst float ss_pow = 3.; \nconst float ss_scatter = 0.4;\nconst float ss_offset = .5;\n\n// color controls\nconst float ss_intensity = 1.;\nconst float ss_mix = 1.;\nconst vec4 ss_color = vec4(.85, .05, .2, 0.0);\n\n// determines how deep from surface to start scattering tracing, not something to tweak really.\nconst float surfaceThickness = 0.008;\n\n// Fresnel\nvec4 rimCol = vec4(1.0, 1.0, 1.0, 1.0);\nfloat rimPow = 2.5;\nfloat rimAmount = 1.;\nfloat F = 2.2;\n\n\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/**\n* Gets thickness for subsurface scattering calculation. \n* I first offset the ray hit position a bit along opposite of the surface normal \n* to get a starting position inside the volume.\n* From there I step towards the light and calculate distance travelled inside the negative volume of\n* the distance function.\n* \n* Outer loop is for approximating scattering of the light that travels in the volume,\n* I just offset the light direction by some scatter value for each sample.\n*/\nfloat ssThickness(in vec3 raypos, in vec3 lightdir, in vec3 g, in vec3 rd)\n{\n    vec3 startFrom = raypos + (-g * surfaceThickness);\n    vec3 ro = raypos;\n\t\n    float len = 0.0;\n    const float samples = 12.;\n    const float sqs = sqrt(samples);\n    \n    for (float s = -samples / 2.; s < samples / 2.; s+= 1.0)\n    {\n        vec3 rp = startFrom;\n        vec3 ld = lightdir;\n        \n        ld.x += mod(abs(s), sqs) * ss_scatter * sign(s);\n        ld.y += (s / sqs) * ss_scatter;\n        \n        ld.x += rand(rp.xy * s) * ss_scatter;\n        ld.y += rand(rp.yx * s) * ss_scatter;\n        ld.z += rand(rp.zx * s) * ss_scatter;\n\t\t\n        ld = normalize(ld);\n        vec3 dir = ld;\n\t\t\n        for (int i = 0; i < 50; ++i)\n        {\n            float dist = map(rp);\n            if(dist < 0.0) dist  = min(dist, -0.0001);\n            if(dist >= 0.0) break;\n\n            dir = normalize(ld);\n            rp += abs(dist * 0.5) * dir;  \n        }\n        len += length(ro - rp);\n    }\n    \n    return len / samples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    \n    vec2 m = (iMouse.xy / iResolution.xy) - vec2(0.5);\n    \n    \n    rotation = roty(m.x * 10.0);\n    rotation *= rotx(-m.y * 10.0);\n    \n    if(iMouse.z <= 0.0)\n    {\n    \trotation = roty(sin(iTime * 0.5) * 2.0);\n    \trotation *= rotz(.8);\n    \trotation *= rotx(sin(iTime) * 0.2);\n        \n    }\n\n    \n    \n    fragColor = vec4(0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 rp = vec3(0.0, -0.01, -.3);\n\n    // closest point is used for antialising outline of object\n    vec3 closestPoint = vec3(0.0);\n    float hit = trace(rp, rd, closestPoint);\n    vec4 color = vec4(.0);\n    rp = closestPoint;\n\n    vec3 ld = normalize( vec3(14.0, 1.0, 20.0) - rp);\n    vec3 g = grad(rp);\n    float d = dot(g, ld);\n    d = clamp(d, 0.0, 1.0);\n\n    //fresnel\n    vec3 r = reflect(-ld, g);\n    float rimd = 1.0 - dot(r, -rd);\n    rimd = clamp(rimd, 0.0, 1.0);\n    rimd = pow(rimd, rimPow);\n\n    float frn = rimd + F * (1.0 - rimd);\n    color += frn * rimCol * rimAmount * d;\n\n    // subsurface        \n    float t = ssThickness(rp, ld, g, rd);\n    t = exp(ss_offset -t * density);\n    t = pow(t, ss_pow);\n \n    vec4 sscol = t * ss_color * ss_intensity;\n    sscol = mix(sscol, ss_color, 1.0 - ss_mix);\n    color += sscol;\n\t\n    fragColor = vec4(.9, .9, 1.0, 1.0);\n    // color + AA\n    fragColor = mix(color, fragColor, mix(0.0, 1.0, clamp(hit / surfaceThickness * 16.0, 0.0, 1.0)));\n    \n    // vignette\n    fragColor *= smoothstep(0.55, 0.48, abs(uv.x));\n    fragColor *= smoothstep(0.31, 0.27, abs(uv.y));\n    \n}","name":"","description":"","type":"image"}]}