{"ver":"0.1","info":{"id":"7sKyWV","date":"1655772968","viewed":134,"name":"inner torus space","username":"pb","description":"drag the mouse around to get more of the 3d effect","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","torus","fbm","colors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// philip.bertani@gmail.com\n\n#define oct 5   //number of fbm octaves\n#define pi  3.14159265\n\nfloat random(vec3 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec3(12., 90., -.180)))* 1e5 );\n}\n\nfloat torus(vec3 p, vec2 axis) {\n    vec2 q = vec2( length(p.xy) - axis.x, p.y);\n    return length(q) - axis.y;\n}\n\nfloat all_sdfs(vec3 p, vec3 ro) {\n\n        vec3 pp =  mod(p-1.,2.)-1.;\n        //float dist = length(pp) - 1.1;\n        float dist = torus(pp, vec2( 1.3, .2) );\n        float dist2 = length(p-ro) - 1.1; \n        dist = max( dist, -dist2 ); \n        return dist;\n\n}\n\n\n//gradient (normal vector)\nvec3 gradient(vec3 p, vec3 ro) {\n\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = .1 * dpn; \n\n    vec3 df = dpn.xxx * all_sdfs(p+dp.xxx, ro) +\n              dpn.yyx * all_sdfs(p+dp.yyx, ro ) +\n              dpn.xyy * all_sdfs(p+dp.xyy, ro)  +\n              dpn.yxy * all_sdfs(p+dp.yxy, ro) ;\n\n    return normalize(df); \n\n}\n\n\n//this is taken from Visions of Chaos shader \"Sample Noise 2D 4.glsl\"\n//and mangled to use a vec3\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float a = random(i + vec3(1.,1.,1.));\n    float b = random(i + vec3(1.,-1.,-1.));\n    float c = random(i + vec3(-1.,1.,1.));\n    float d = random(i + vec3(-1.,1.,-1.));\n    vec2 u = f.xz; \n    return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;\n}\n\nfloat fbm3d(vec3 p) {\n    float v = 0.;\n    float a = .5;\n  \n    for (int i=0; i<oct; i++) {\n        v += a * noise(p);\n        p = p * 4.;\n        a *= .8;  //changed from the usual .5\n    }\n    return v;\n}\n\nmat3 rxz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(cc,0.,-ss,\n                0.,1.,0.,\n                ss,0.,cc);                \n}\nmat3 ryz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(1.,0.,0.,\n                0.,cc,-ss,\n                0.,ss,cc);\n}   \n\nvec3 get_color(vec3 p) {\n\n    vec3 q;\n    q.x = fbm3d(p);\n    q.y = fbm3d(p.xzy);\n    q.z = fbm3d(p.zyx);\n\n    //float f = fbm3d(p + q);\n    \n    return q;\n}\n\nvec3 ct(vec3 p, vec3 rd)  {\n\n    vec3 cc = vec3(0.);\n\n    float stepsize = .006;\n    float totdist = stepsize;\n    \n    for (int i=0; i<18; i++) {\n       vec3 cx = get_color(p);\n       p += stepsize*rd;\n       float fi = float(i);\n       cc += exp(-totdist*totdist)* cx;\n       totdist += stepsize;\n       //rd = ryz(.12)*rd;   \n    }\n    \n    return cc;\n\n}\n\n\nvec3 march(vec3 ro, vec3 rd) {\n\n    float dist = 1., totdist=0.;\n    float eps = .001;\n    vec3 p=ro;\n    for (int i=0; i<12; i++ ) {\n\n        dist  = all_sdfs(p,ro);\n        totdist += dist;\n        p += dist*rd;\n        if (dist < eps) {\n            vec3 nn = gradient(p, ro);\n            float dd = max(0.,dot( -rd, nn));\n            return exp(-totdist*totdist/5.)*ct(p,rd)/11. - dd*vec3(0.,.1,0.);\n            break;\n        }\n        eps *= (1.+dist*80.);\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mm = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec3 rd = normalize( vec3(uv, 1.3) );  \n    vec3 ro = vec3(0.,0.,0.);\n    \n    float delta = 2.*pi/40.;\n    mat3 rot = rxz(-mm.x*delta+iTime/5.) * ryz(-mm.y*delta);\n\n    rd = rot*rd;\n    ro += rot[2]*iTime/3.;\n    \n    vec3 cc = march(ro, rd);\n        \n    cc = pow( cc , vec3(1.5+max(0.,1.*sin(iTime/3.))));    //play with this\n\n    fragColor = vec4(cc,1.0);\n    \n    \n}\n","name":"Image","description":"","type":"image"}]}