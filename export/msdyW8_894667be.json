{"ver":"0.1","info":{"id":"msdyW8","date":"1695066867","viewed":159,"name":"Interval Music Test","username":"TambakoJaguar","description":"I tried to reproduce this video, for fun:\nhttps://www.youtube.com/watch?v=AGYaAQV27wM\nI just didn't get the \"xylophone\" sound right, but I think it's difficult to create it just mathematically.","likes":9,"published":1,"flags":8,"usePreview":0,"tags":["2d","test","sound","music","mathematics","animation","rainbow","harmonics","notes","xylophone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Let's define a few constants\nconst float wfw = 0.005;        // Absolute thickness of the frame\nconst vec3 fcol = vec3(1.);     // Color of the frame\nconst float nlw = 0.33;         // Relative thickness of the colored lines\nconst float ncw = 0.47;         // Relative thickness of the circles\nconst float nclw = 0.07;        // Relative thickness of the outline of the circles\nconst vec3 bgcol = vec3(0.0);   // Background color\nconst vec3 lcol2 = vec3(0.2);   // Dark color of the lines\nconst vec3 ccol2 = vec3(1.0);   // Bright color of the circles\nconst vec3 cocol = vec3(1.0);   // Outline color of the circles\nconst float aawidth = 0.0017;\n\n// Just to make a nicer rainbox\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col;\n    vec3 rbcol;\n    vec3 ccol;\n    vec3 lcol;\n\n    // Now we define a few useful values\n    vec2 uv = fragCoord/iResolution.xx;\n    float sr = iResolution.y/iResolution.x;\n    //float uvy= uv.y*1.02+0.002;\n    float uvy = uv.y*(0.975+wfw*2./sr)+0.007-wfw;\n    \n\n    float pos = 1.-uvy/sr;\n    float linenb = floor(pos*float(nblines)+0.5);\n    float posy = linenb/float(nblines);\n    \n    float speedfac = speedfac0 + linesfac*linenb;\n    float time = (iTime+time0)*speedfac;\n    \n    float owx = wfw+0.6*ncw/float(nblines);\n    float posx = (1.-owx)-abs(mod(time, 2.)-1.)*(1.-2.*owx);\n    \n    // The rainbox colors\n    float sat = 1.-clamp(1.7*mod(time, 1.), 0., 1.);\n    rbcol = hsv2rgb(vec3(posy, 1., 1.));\n    lcol = mix(rbcol, lcol2, 1.-sat);\n    ccol = mix(rbcol, ccol2, sat);\n    \n    // The lines\n    float ss = smoothstep(nlw*0.5+aawidth*float(nblines), nlw*0.5-aawidth*float(nblines), abs(mod(uvy*float(nblines)/sr+nlw, 1.)-nlw));\n    col = mix(bgcol, lcol, ss);\n\n    // The circles\n    col = mix(cocol, col, smoothstep(-aawidth*float(nblines), aawidth*float(nblines), length(vec2((uv.x-posx)*float(nblines)/sr, mod(uvy*float(nblines)/sr+0.5, 1.)-0.5))-ncw));\n    col = mix(ccol, col, smoothstep(-aawidth*float(nblines), aawidth*float(nblines), length(vec2((uv.x-posx)*float(nblines)/sr, mod(uvy*float(nblines)/sr+0.5, 1.)-0.5))-ncw+nclw));\n    \n    // White frame\n    col = mix(fcol,col, smoothstep(wfw, wfw+aawidth, uv.x));\n    col = mix(fcol,col, smoothstep(wfw, wfw+aawidth, uv.y));\n    col = mix(fcol,col, smoothstep(wfw, wfw+aawidth, 1.-uv.x));\n    col = mix(fcol,col, smoothstep(wfw, wfw+aawidth, sr-uv.y));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n\"Interval Music Test\" by Emmanuel Keller aka Tambako - September 2023\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\n// Let's define a few constants\nconst int nblines = 36;                 // Number of lines/notes\n\nconst float speedfac0 = 0.30333333;     // Speed factor\nconst float linesfac = 0.003333333;     // Difference factor between each consecutive line/note\nconst float time0 = 0.;                 // Time origin","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"const float decay0 = 3.;     // Basic note decay\nconst float volfact = 0.3;   // Volume factor\nconst float freq0 = 110.;    // Basic frequency\nconst float stwidth = 0.9;    // Stereo width\n\nvec3 harmonics[13];\n\nvec2 mainSound( int samp, float time )\n{\n    // Definition of the note harmonics. It's supposed to be a xylophone/marimba like in the YT video, but it sounds more like a plucked nylon sound (thanks Dave_Hoskins)\n    // (relative frequency, relative amplitude, relative decay)\n    harmonics[0] = vec3(1.0, 1.0, 1.0);    // Fundamental (1st)\n    harmonics[1] = vec3(2.06, 0.12, 0.5);  // 2nd Harmonic\n    harmonics[2] = vec3(2.94, 0.23, 0.3);  // 3rd Harmonic\n    harmonics[3] = vec3(4.02, 0.24, 0.2);  // 4th Harmonic\n    harmonics[4] = vec3(5.04, 0.42, 0.1);  // 5th Harmonic\n    harmonics[5] = vec3(5.95, 0.03, 0.15); // 6th Harmonic\n    harmonics[6] = vec3(6.97, 0.22, 0.20); // 7th Harmonic\n    harmonics[7] = vec3(8.04, 0.05, 0.15); // 8th Harmonic\n    harmonics[8] = vec3(9.02, 0.03, 0.12); // 9th Harmonic\n    harmonics[9] = vec3(10.07, 0.01, 0.10);// 10th Harmonic\n    harmonics[10] = vec3(11.0, 0.08, 0.08);// 11th Harmonic\n    harmonics[11] = vec3(12.0, 0.03, 0.06);// 12th Harmonic\n\n    vec2 totn = vec2(0.);\n    for (int n=0; n<nblines; n++)\n    {\n        for (int h=0; h<13; h++)\n        {\n            float freq = freq0*harmonics[h].x*(pow(2., float(n)/12.));\n            float speedfac = speedfac0 + linesfac*float(nblines-n);\n            float time2 = mod(time+time0, 1./speedfac);\n            float side =  mod(floor((time+time0)*speedfac), 2.);\n            float note  = sin(pi*2.*freq*time2)*exp(-decay0*time2/harmonics[h].z)*harmonics[h].y;\n        \n            float soundl = volfact*note*(1.-side);\n            float soundr = volfact*note*side;\n            \n            totn.x+= volfact*(soundl+soundr*(1.-stwidth));\n            totn.y+= volfact*(soundl*(1.-stwidth)+soundr);           \n         }\n    }\n    return totn;\n}","name":"Sound","description":"","type":"sound"}]}