{"ver":"0.1","info":{"id":"MlBfDw","date":"1515978357","viewed":167,"name":"Spinning triangle pattern","username":"Scoo","description":"Triangles spin as you drag your mouse over them.\n\nDebug visualizations are at the bottom of mainImage (just uncomment)\n\nTODO:\n* better physics\n* shading","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["triangle","pattern","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Triangle pattern\n\nconst float GRID_LINE_SIZE =  2.0;  // Should be a multiple of 2.\nconst vec3 GRID_LINE_COLOR = vec3(1.0, 0.0, 0.0);\n\nconst vec3 TRIANGLE_COLOR = vec3(0.3, 0.3, 0.6);\nconst vec3 BACKGROUND_COLOR = vec3(0.1, 0.1, 0.1);\n\n// Outputs GRID_LINE_COLOR grid lines on a transparent background.\nvec4 drawGridLines(vec2 fragCoord) {\n    vec2 totalCells = iResolution.xy / GRID_CELL_SIZE;\n    vec2 gridCell = floor(fragCoord.xy / GRID_CELL_SIZE);\n    vec2 gridPos = fragCoord.xy - gridCell * GRID_CELL_SIZE;\n    \n    // Neighboring cells contribute half of the line size.\n    if (gridPos.x < GRID_LINE_SIZE / 2.0 ||\n        gridPos.y < GRID_LINE_SIZE / 2.0 ||\n        gridPos.x > GRID_CELL_SIZE - GRID_LINE_SIZE / 2.0 ||\n        gridPos.y > GRID_CELL_SIZE - GRID_LINE_SIZE / 2.0) {\n        return vec4(GRID_LINE_COLOR, 1.0);\n    } else {\n        return vec4(1.0, 1.0, 1.0, 0.0);\n    }\n}\n\n// Draws the grid cell that the mouse is located within.\nvec4 drawMouseGridCell(vec2 fragCoord) {\n    vec2 gridCell = floor(fragCoord.xy / GRID_CELL_SIZE);\n    vec2 mouseGridCell = floor(iMouse.xy / GRID_CELL_SIZE);\n    return mouseGridCell == gridCell ? vec4(1.0, 0.5, 0.0, 0.5) : vec4(0.0);\n}\n\n// Draws a dot around the mouse location.\nvec4 drawMouseDot(vec2 fragCoord) {\n    return distance(fragCoord, iMouse.xy) < 3.0 ? vec4(1.0) : vec4(0.0);\n}\n\n// Computes the unique, ascending index for the triangle at the provided coords.\nivec2 computeTriangleIndex(vec2 fragCoord) {\n    float x = fragCoord.x / GRID_CELL_SIZE;\n    \n    // Flip sign every other row and every other half-column.\n    vec2 gridCell = floor(fragCoord.xy / GRID_CELL_SIZE);\n    vec2 gridFrac = fract(fragCoord.xy / GRID_CELL_SIZE);\n    float ySign = sign((mod(gridCell.y, 2.0) - 0.5) * (gridFrac.x - 0.5));\n    float y = (gridFrac.y - 0.5) * ySign;\n    \n    float xIndex = 2.0 * x + y;\n    \n    return ivec2(round(xIndex), gridCell.y);\n}\n\nvec4 drawGridTriangles(vec2 fragCoord) {    \n    ivec2 fragmentTriangleIndex = computeTriangleIndex(fragCoord);\n    ivec2 mouseTriangleIndex = computeTriangleIndex(iMouse.xy);\n    \n    vec2 totalCells = iResolution.xy / GRID_CELL_SIZE;\n    vec2 gridCell = floor(fragCoord.xy / GRID_CELL_SIZE);\n    vec2 gridFrac = fract(fragCoord.xy / GRID_CELL_SIZE);\n    \n    // texelFetch() instead of texture() to fetch state without sampling influence\n    float rotation = texelFetch(iChannel0, fragmentTriangleIndex, 0).x;\n    float rotationScale = abs(sin(rotation));\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float alpha = 0.0;\n    \n    if (mod(gridCell.y, 2.0) == 0.0) {\n        // Rotate by changing the height cutoff.\n        float y = mix(gridFrac.y, 1.0, rotationScale);\n        \n        // TODO: allow for background between triangles as they rotate\n        color = abs(gridFrac.x - 0.5) * 2.0 < y ? BACKGROUND_COLOR : TRIANGLE_COLOR;\n        alpha = 1.0;\n        \n        // TODO: shade based on a light source and current rotation\n    } else {\n        float y = mix(gridFrac.y, 1.0, rotationScale);\n        color = abs(gridFrac.x - 0.5) * 2.0 > 1.0 - y ? BACKGROUND_COLOR : TRIANGLE_COLOR;\n        alpha = 1.0;\n    }\n    \n    return vec4(color, alpha);\n}\n\n// Draws the triangle under the mouse cursor.\nvec4 drawMouseTriangle(vec2 fragCoord) {\n    ivec2 fragmentTriangleIndex = computeTriangleIndex(fragCoord);\n    ivec2 mouseTriangleIndex = computeTriangleIndex(iMouse.xy);    \n    \n    if (mouseTriangleIndex == fragmentTriangleIndex) {\n        return (mouseTriangleIndex.x + mouseTriangleIndex.y) % 2 == 0 ?\n            vec4(0.0, 0.8, 0.5, 0.5) : vec4(0.8, 0.4, 0.4, 0.5);\n    }\n    \n    return vec4(0.0);    \n}\n\n// Blends `source` color into `dest` color, using `source` alpha.\n// `dest` alpha is ignored and the output alpha is 1.0.\nvec4 alphaBlend(vec4 dest, vec4 source) {\n    vec3 blended = (source.rgb * source.a) + (dest.rgb * (1.0 - source.a));\n    return vec4(blended, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    // Background color, drawing alpha-blends on top of this.\n    fragColor = vec4(0.5, 0.9, 0.3, 1.0);\n    \n    fragColor = alphaBlend(fragColor, drawGridTriangles(fragCoord));\n    \n    // DEBUG visualizations, blended on top of the normal rendering\n    // fragColor = alphaBlend(fragColor, drawGridLines(fragCoord));\n    // fragColor = alphaBlend(fragColor, drawMouseGridCell(fragCoord));\n    // fragColor = alphaBlend(fragColor, drawMouseTriangle(fragCoord));\n    fragColor = alphaBlend(fragColor, drawMouseDot(fragCoord));\n    \n    // DEBUG: Show iChannel0 (the output of Buf A)\n    // fragColor += texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // TODO: antialias?\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Track and update state.\n\n#define PI 3.141592653589793238462643383279502884\n\n// Computes the unique, ascending index for the triangle at the provided coords.\nivec2 computeTriangleIndex(vec2 fragCoord) {\n    float x = fragCoord.x / GRID_CELL_SIZE;\n    \n    // Flip sign every other row and every other half-column.\n    vec2 gridCell = floor(fragCoord.xy / GRID_CELL_SIZE);\n    vec2 gridFrac = fract(fragCoord.xy / GRID_CELL_SIZE);\n    float ySign = sign((mod(gridCell.y, 2.0) - 0.5) * (gridFrac.x - 0.5));\n    float y = (gridFrac.y - 0.5) * ySign;\n    \n    float xIndex = 2.0 * x + y;\n    \n    return ivec2(round(xIndex), gridCell.y);\n}\n\nvec4 updateTriangleStateAtIndex(vec2 fragCoord) {\n    vec4 fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec4 previousState = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    ivec2 mouseTriangleIndex = computeTriangleIndex(iMouse.xy);\n    \n    // x = rotation\n    // y = rotation speed\n    \n    if (iMouse.z > 0.0 && ivec2(fragCoord.xy) == mouseTriangleIndex) {\n        fragColor.y = 5.0 * PI;\n    } else {     \n        // Spring force to pull rotation back to 0.0.\n        // F = kx, F = ma, m = 1\n        // a = k\n        // v1 = v0 + a dt\n        \n        // TODO: equilibrium at any multiple of PI radians (normalize angle?)\n        // float displacement = -min(abs(PI - mod(previousState.x, PI)), mod(previousState.x, PI));\n        \n        float displacement = 0.0 - previousState.x;\n        float k = 2.9;\n        float force = k * displacement;\n        float a = force; // mass = 1.0\n        float damping = 0.98;\n        fragColor.y = damping * (previousState.y + a * iTimeDelta);\n        \n        // Alternate physics, not spring-based.\n        /*\n        if (previousState.y > 0.5) {\n            // Ease towards 0 velocity.\n            float a = previousState.y * 1.2;\n            fragColor.y = previousState.y - a * iTimeDelta;\n        } else if (previousState.y > 0.0) {\n            fragColor.y = previousState.y;\n            \n            // Velocity is low, ease position towards 0.\n            // float x = PI - mod(previousState.x, PI);\n            // fragColor.y = max(x, previousState.y) / iTimeDelta;\n            \n            float nextX = previousState.x + fragColor.y * iTimeDelta;\n            float nearValue = min(abs(PI - mod(nextX, PI)), mod(nextX, PI));\n            // float nearValue = mod(nextX, PI);\n            // float nearValue = abs(PI - mod(nextX, PI));\n            if (nearValue < 0.1) {\n                return vec4(0.0, 0.0, 0.0, 1.0);\n            }\n        }\n\t\t*/\n    }\n    \n    fragColor.x = previousState.x + fragColor.y * iTimeDelta;\n    \n    return fragColor;\n}\n\n// State is stored in the output texture as rgba colors.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    // One texel per triangle in [0, totalTriangles] using triangle indices as coords.\n    vec2 totalTriangles = iResolution.xy / GRID_CELL_SIZE * 2.0 + 1.0;\n    if (fragCoord.x <= totalTriangles.x && fragCoord.y <= totalTriangles.y) {\n        fragColor = updateTriangleStateAtIndex(fragCoord);\n    }\n    \n    // The rest of the texture is currently unused.\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float GRID_CELL_SIZE = 60.0;  // Should be a multiple of 2.","name":"Common","description":"","type":"common"}]}