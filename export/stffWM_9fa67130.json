{"ver":"0.1","info":{"id":"stffWM","date":"1653762997","viewed":67,"name":"@CodeBoy124 ray tracer test","username":"CodeBoy124","description":"This is a basic test to see how a ray tracer works.\nI also learned how to add anti-aliasing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test","raytracer","math","testing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec3 sampleAntiAliasing( in vec2 fragCoord, in float seed )\n{\n    vec2 newFragCoord = fragCoord + vec2(rand(iTime-seed+fragCoord.x), rand(iTime+seed-fragCoord.y));\n    vec2 uv = (newFragCoord - iResolution.xy / 2.)/iResolution.y;\n    \n    float bgMix = clamp(uv.y*3., 0.5, 1.);\n    vec3 col = vec3(43. / 255., 209. / 255., 247. / 255.) * bgMix + vec3(50. / 255., 159. / 255., 237. / 255.) * (1. - bgMix);\n    \n    // ray\n    \n    vec3 ro = vec3(-0.5+(iMouse.x / iResolution.x), 0.8 + 0.4 * (iMouse.y / iResolution.y), -4.);\n    vec3 rd = normalize(vec3(uv.xy, 1.));\n    \n    // ground plane\n    \n    float h = 0.;\n    \n    // check for hit\n   \n    float hitD = max(((ro.y - h) / -rd.y), 0.);\n    \n    if((ro + rd * hitD).y <= h+0.01){\n         vec3 hitPoint = ro + rd * hitD;\n         vec3 normal = normalize(vec3(0., 1., 0.));\n         float tileSize = 3.;\n         if((mod(round(hitPoint.x / tileSize), 2.) == 0. && mod(round(hitPoint.z / tileSize), 2.) != 0.) || (mod(round(hitPoint.x / tileSize), 2.) != 0. && mod(round(hitPoint.z / tileSize), 2.) == 0.)){\n             col = vec3(50. / 255., 194. / 255., 43. / 255.);\n         }else{\n             col = vec3(1.);\n         }\n         col *= clamp(dot(normal, normalize(vec3(1., 2., -1.))), 0.25, 1.);\n         \n         // sphere\n         vec3 so = vec3(0., 0.5, 0.);\n         float sr = 0.5;\n         vec3 sunDir = normalize(vec3(1., 2., -2.));\n         \n         // detect hit\n         float t = dot(so - hitPoint, sunDir);\n    \n         vec3 hitPoint2 = hitPoint + sunDir * t;\n\n         float y = distance(so, hitPoint2);\n\n         if(y <= sr){\n           col *= 0.25;\n         }\n    }\n    \n    // sphere\n    \n    vec3 so = vec3(0., 0.5, 0.);\n    float sr = 0.5;\n    \n    // check for hit\n    \n    float t = dot(so - ro, rd);\n    \n    vec3 hitPoint = ro + rd * t;\n    \n    float y = distance(so, hitPoint);\n    \n    if(y <= sr){\n        float x = sqrt(sr*sr - y*y);\n        hitPoint = ro + rd * (t-x);\n        vec3 normal = normalize(hitPoint - so);\n        col = vec3(1.);\n        \n        // reflection\n        \n        vec3 col2 = vec3(43. / 255., 209. / 255., 247. / 255.);\n        \n        // ray\n    \n        vec3 ro = hitPoint;\n        vec3 rd = normal + rd * dot(rd, normal);\n\n        // ground plane\n\n        float h = 0.;\n\n        // check for hit\n\n        float hitD = max(((ro.y - h) / -rd.y), 0.);\n\n        if((ro + rd * hitD).y <= h+0.01){\n             vec3 hitPoint = ro + rd * hitD;\n             vec3 normal = normalize(vec3(0., 1., 0.));\n             float tileSize = 3.;\n             if((mod(round(hitPoint.x / tileSize), 2.) == 0. && mod(round(hitPoint.z / tileSize), 2.) != 0.) || (mod(round(hitPoint.x / tileSize), 2.) != 0. && mod(round(hitPoint.z / tileSize), 2.) == 0.)){\n                 col2 = vec3(50. / 255., 194. / 255., 43. / 255.);\n             }else{\n                 col2 = vec3(1.);\n             }\n             col2 *= clamp(dot(normal, normalize(vec3(1., 2., -1.))), 0.25, 1.);\n\n             // sphere\n             vec3 so = vec3(0., 0.5, 0.);\n             float sr = 0.5;\n             vec3 sunDir = normalize(vec3(1., 2., -2.));\n\n             // detect hit\n             float t = dot(so - hitPoint, sunDir);\n\n             vec3 hitPoint2 = hitPoint + sunDir * t;\n\n             float y = distance(so, hitPoint2);\n\n             if(y <= sr){\n               col2 *= 0.25;\n             }\n        }\n        \n        col = col * 0.5 + col2 * 0.5;\n        col *= 0.25 + 0.75 * clamp(dot(normal, normalize(vec3(1., 2., -2.))), 0.25, 1.);\n    }\n\n    return col;\n}\n\nvec3 render( in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.)/iResolution.y;\n    \n    float bgMix = clamp(uv.y*3., 0.5, 1.);\n    vec3 col = vec3(43. / 255., 209. / 255., 247. / 255.) * bgMix + vec3(50. / 255., 159. / 255., 237. / 255.) * (1. - bgMix);\n    \n    // ray\n    \n    vec3 ro = vec3(-0.5+(iMouse.x / iResolution.x), 0.8 + 0.4 * (iMouse.y / iResolution.y), -4.);\n    vec3 rd = normalize(vec3(uv.xy, 1.));\n    \n    // ground plane\n    \n    float h = 0.;\n    \n    // check for hit\n   \n    float hitD = max(((ro.y - h) / -rd.y), 0.);\n    \n    if((ro + rd * hitD).y <= h+0.01){\n         vec3 hitPoint = ro + rd * hitD;\n         vec3 normal = normalize(vec3(0., 1., 0.));\n         float tileSize = 3.;\n         if((mod(round(hitPoint.x / tileSize), 2.) == 0. && mod(round(hitPoint.z / tileSize), 2.) != 0.) || (mod(round(hitPoint.x / tileSize), 2.) != 0. && mod(round(hitPoint.z / tileSize), 2.) == 0.)){\n             col = vec3(50. / 255., 194. / 255., 43. / 255.);\n         }else{\n             col = vec3(1.);\n         }\n         col *= clamp(dot(normal, normalize(vec3(1., 2., -1.))), 0.25, 1.);\n         \n         // sphere\n         vec3 so = vec3(0., 0.5, 0.);\n         float sr = 0.5;\n         vec3 sunDir = normalize(vec3(1., 2., -2.));\n         \n         // detect hit\n         float t = dot(so - hitPoint, sunDir);\n    \n         vec3 hitPoint2 = hitPoint + sunDir * t;\n\n         float y = distance(so, hitPoint2);\n\n         if(y <= sr){\n           col *= 0.25;\n         }\n    }\n    \n    // sphere\n    \n    vec3 so = vec3(0., 0.5, 0.);\n    float sr = 0.5;\n    \n    // check for hit\n    \n    float t = dot(so - ro, rd);\n    \n    vec3 hitPoint = ro + rd * t;\n    \n    float y = distance(so, hitPoint);\n    \n    if(y <= sr){\n        float x = sqrt(sr*sr - y*y);\n        hitPoint = ro + rd * (t-x);\n        vec3 normal = normalize(hitPoint - so);\n        col = vec3(1.);\n        \n        // reflection\n        \n        vec3 col2 = vec3(43. / 255., 209. / 255., 247. / 255.);\n        \n        // ray\n    \n        vec3 ro = hitPoint;\n        vec3 rd = normal + rd * dot(rd, normal);\n\n        // ground plane\n\n        float h = 0.;\n\n        // check for hit\n\n        float hitD = max(((ro.y - h) / -rd.y), 0.);\n\n        if((ro + rd * hitD).y <= h+0.01){\n             vec3 hitPoint = ro + rd * hitD;\n             vec3 normal = normalize(vec3(0., 1., 0.));\n             float tileSize = 3.;\n             if((mod(round(hitPoint.x / tileSize), 2.) == 0. && mod(round(hitPoint.z / tileSize), 2.) != 0.) || (mod(round(hitPoint.x / tileSize), 2.) != 0. && mod(round(hitPoint.z / tileSize), 2.) == 0.)){\n                 col2 = vec3(50. / 255., 194. / 255., 43. / 255.);\n             }else{\n                 col2 = vec3(1.);\n             }\n             col2 *= clamp(dot(normal, normalize(vec3(1., 2., -1.))), 0.25, 1.);\n\n             // sphere\n             vec3 so = vec3(0., 0.5, 0.);\n             float sr = 0.5;\n             vec3 sunDir = normalize(vec3(1., 2., -2.));\n\n             // detect hit\n             float t = dot(so - hitPoint, sunDir);\n\n             vec3 hitPoint2 = hitPoint + sunDir * t;\n\n             float y = distance(so, hitPoint2);\n\n             if(y <= sr){\n               col2 *= 0.25;\n             }\n        }\n        \n        col = col * 0.5 + col2 * 0.5;\n        col *= 0.25 + 0.75 * clamp(dot(normal, normalize(vec3(1., 2., -2.))), 0.25, 1.);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c = vec3(0.);\n    float samples = 10.;\n    for(float i = 0.; i < samples; i += 1.){\n        c += sampleAntiAliasing(fragCoord, i * 383.);\n    }\n    c = c / samples;\n    \n    //c = render(fragCoord);\n    \n    fragColor = vec4(c, 1.);//vec4(sampleAntiAliasing(fragCoord, 1.) + sampleAntiAliasing(fragCoord, 2827.), 1.);\n}","name":"Image","description":"","type":"image"}]}