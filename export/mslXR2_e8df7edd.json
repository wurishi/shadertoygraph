{"ver":"0.1","info":{"id":"mslXR2","date":"1669482023","viewed":179,"name":"Conveyor System pt.2","username":"kastorp","description":"WIP... see comments for instructions ","likes":26,"published":1,"flags":48,"usePreview":0,"tags":["game","simulation","conveyors"],"hasliked":0,"parentid":"mdsSDH","parentname":"Conveyor System"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Conveyor System pt.2 by Kastorp\n//-----------------------------------------------\n// BLACK circles are target\n// WHITE circles are source  \n// \n// ACTIONS:\n//   space: hold pressed for max speed\n//   mouse on target/source gauge:  change its power (red=full, green=stopped)\n//   A: show node numbers\n//\n//------------------------------------------------\n// TODO\n//  X item types  \n//  X statistics\n//  - adjustable semaphores\n//  X variable conveyor size (8 to 32 slots)\n//  - junction types (splitter, trasnformer, assembler, stack)\n//  - edit mode with dedicated buffer\n//  - package routing based on color\n//  - better rendering \n//-----------------------------------------------\n//FabriceNeyret\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) \n    char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0  ? vec4(0,0,0,1e5) : textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\n}\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.)  v += char(p - vec2(-.5,0), 45 ), n = -n;\n    for (float i = 3.; i>=0.; i--)  n /=  9.999999, v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n//----------------------\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   \n    vec2 u =pos(I,R);\n    vec2 M =pos(iMouse.xy,R);\n     \n    vec3 bgcol=mix(vec3(.55,.4,.4),vec3(.5,.4,.6),step(0.,sign(sin(u.x*PI)*sin(u.y*PI)))),\n        col=bgcol; \n    \n    for(float j=0.;j<float(NC);j++){\n        \n        int jj=int(j);\n        int cIn=CONNS[jj].x,cOut=CONNS[jj].y;\n        uvec4 data = floatBitsToUint(texelFetch(iChannel0,ivec2(0,jj),0));\n        vec2 s1=NODES[CONNS[jj].y],s2=NODES[CONNS[jj].x];\n\n        if(cIn >=0 && cOut>=0)\n        {           \n            if(pressed(65)) {\n                pInt((u-s1+vec2(.1,.05)) *10., float(cOut));\n                pInt((u-s2+vec2(.1,.05)) *10., float(cIn));\n            }\n            vec3 s =segment(u,s1,s2);\n            if(s.x>.6) continue;\n            if((data.z&1u)>0u) {\n                s1=s2+(s1-s2)*(1.- .06/length(s2-s1));\n                if(col==bgcol  &&  length(s.yz-vec2(.07))<.03) col=vec3(.8,0,0);\n                s =segment(u,s1,s2);\n            }\n            if((data.z&2u)>0u) { \n                s2=s1+(s2-s1)*(1.- .04/length(s2-s1));\n                if(col==bgcol  &&  length(s.yz-vec2(.93,.07))<.03) col=vec3(0,.4,0);\n                s =segment(u,s1,s2);\n            }\n\n            if(s.x<.06){\n                float shh=float(iFrame%FR)/float(FR);\n                if(col==bgcol) col=vec3(.25)*(1.-0.*step(.01,s.x))*(.95+.05*sign(sin((s.y*32.+float(iFrame)/float(FR)))));                \n\n                int x=int(s.y*32./SHBITF)*SHBIT;               \n                for(int i=x-SHBIT*2;i<x+SHBIT*2;i+=SHBIT){\n                    if(i<0||i>31)continue;\n                    float type= float((data.x &(MINBIT<<i))>>i)/float(MINBIT);\n                    bool a=  ((data.x &(MINBIT<<i))>0u);  //item in current slot?\n                    bool b=  ((data.y &(MINBIT<<i))>0u);  //item is moving\n                    float sh=  !b? shh*SHBITF:SHBITF; //horizontal shift if moving\n                    float bc=float(i)+SHBITF-sh; //item center\n                    float item=max(abs(s.y*32.-bc)-.3*SHBITF,s.z-.03); //item sdf\n                    if(a &&item<0.) col= .5+.5*cos(type*6.+vec3(0,2,4));            \n                }\n\n            }\n            if((data.z&12u)>0u)\n            {\n                float an=float(data.w)*PI/MAXW-PI*.5; \n                vec3 gcol= .6 + .6 * cos( float(data.w)/MAXW*2.  + vec3(4,0,2) ) ;\n                bool isTarget=(data.z&4u)>0u;\n                vec2 c=NODES[isTarget?cOut:cIn];\n                if( length(c-u-vec2(cos(an),sin(an))*.16)<.05) col=gcol;\n                if(col==bgcol && length(c-u)<.15) col=isTarget?vec3(0):vec3(1);               \n                if(iMouse.z>0. &&max(length(c-u),length(c-M))<.2 ) col+=vec3(0,0,.5);\n            }\n\n        } \n        else {\n            bool isTarget=cOut<0;\n            vec2 c=NODES[isTarget?cIn:cOut];\n            \n            uvec4 td = floatBitsToUint(texelFetch(iChannel0,ivec2(1, cOut<0?-cOut:-cIn),0));\n            pInt((u-c+vec2(.25,.35)) *5., float(isTarget?td.x:td.y));        \n        }    \n    }\n    uvec4 td = floatBitsToUint(texelFetch(iChannel0,ivec2(1,0),0));    \n    pInt((u-vec2(-3.5,1.6)) *5., float(td.x)); //not arrived\n    pInt((u-vec2(-3.5,1.4)) *5., float(td.y)); //arrived\n    pInt((u-vec2(-3.5,1.8)) *5., float(td.z)); //created\n    O = vec4(col,1.0);\n    O += draw_char().xxxx;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define L(i) floatBitsToUint(texelFetch(iChannel0,ivec2(0,i),0)).x\n\nuint tra(int c,uint pw){\n       //source/target power \n       vec3 rnd=hash(uvec3(iFrame,c,1.));\n       return rnd.x< float(pw)/MAXW ?uint(rnd.y*float(MINBIT)+1.):0u; \n}\nuint count(uint x){\n    uint t=0u;\n    for(int i=ZERO;i<32;i++) t+=((x>>i)&1u);\n    return t;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   if(I.x>1. && I.y>float(NC)) discard;\n    \n   int id= int (I.y);\n   uvec4 d=floatBitsToUint(texelFetch(iChannel0,ivec2(0,id),0));\n   if(iFrame<5 ) {\n       d= uvec4(0u,0u,0u,uint(MAXW)/4u);\n   }else if(I.x<1.){\n       \n       int cIn=CONNS[id].x,cOut=CONNS[id].y;\n       if(cIn<0 || cOut<0) return; //unused yet\n       \n       //each pixel is a lane with 32 slots\n       d=floatBitsToUint(texelFetch(iChannel0,ivec2(0,id),0));\n       \n       vec2 s1=NODES[CONNS[id].y],s2=NODES[CONNS[id].x];\n      \n\n       uint last= MINBIT,first=0u,secIn=0u,secOut=0u;\n       int ,sec=0,secV=0,type=0;\n       \n       bool rr=true, //todo user defined\n            pr= rr?hash(uvec3(iFrame)).x<.5:false; \n\n       for(int i=ZERO;i<NC;i++){\n           if(i==id)continue;\n           int nIn=CONNS[i].x,nOut=CONNS[i].y;\n            \n           if(nOut==cIn) { //entering \n               uint f2=(L(i) & MINBIT);\n               if(nIn<0) {f2=tra(nIn,d.w); type|=2;}\n               \n               if(first==0u)  first= f2;\n               else if((i<id ^^ pr) && f2!=0u) first= f2;\n           }\n           if(nIn==cOut) { //exiting                           \n               if(nOut<0) {last= (tra(nOut,d.w)!=0u?MINBIT:0u); type|=1;}\n               else if(last!=0u) last =  (L(i) & MAXBIT)>>(32-SHBIT);\n          }\n           if(nOut==cOut &&(i<id ^^ pr) ){ //junction Out               \n               sec|=1;\n               if(nIn<0) secOut|=(MINBIT-tra(nIn,d.w));\n               else secOut|=(L(i) & MINBIT );    \n           } \n           if(nIn==cIn &&(i<id ^^ pr)){ //junction in\n               sec|=2;\n               if(nOut<0) secIn|=tra(nOut,d.w);\n               else secIn|= (L(i) & MAXBIT)>>(32-SHBIT);    \n           }\n           if(rr && nOut==cOut)secV|=1;\n           if(rr && nIn==cIn)secV|=2;\n        }\n        if((sec&2)>0  && (secIn==0u)) first=0u;\n        if(secOut>0u ) last=MINBIT;  \n        sec=sec|secV;\n\n       uint next= ((d.x& (FULLBIT-MAXBIT))<<SHBIT) | (last), \n            prev= ((d.x& (FULLBIT-MINBIT))>>SHBIT) | (first<<(32-SHBIT)),\n            free= FULLBIT-mask(d.x), \n            move=free & prev, //move the item in current pos if previous has item and current is free\n            stay=d.x & mask(next); //don't move if there is item in the current and next pos\n\n       //power gauge\n       vec2 m=pos(iMouse.xy,R);\n       vec2 c = (type&1)>0?s1:s2;\n       float w=(atan(-m.y+c.y,-m.x+c.x)+PI*.5);\n\n\n       //update every FR frames\n       if(iFrame%FR==0|| pressed(32)){\n           d.x=move|stay; //x=update item  in the position\n           d.y=stay;      //y=item is stopped  \n           d.z= uint(sec + type*4);\n       }\n       if(type>0 && length(m-c)<.2) d.w=uint(w*MAXW/PI); \n       if((d.z&31u)==0u) d.w=uint(MAXW)/4u; //hack for resolution change\n   \n   }else if(id>0){\n       d=floatBitsToUint(texelFetch(iChannel0,ivec2(1,id),0));\n       \n       for(int j=ZERO;j<NC;j++){\n           int uIn=CONNS[j].x,uOut=CONNS[j].y;\n           if(uOut==-id) { //target \n              \n              for(int i=ZERO;i<NC;i++){\n                  int nIn=CONNS[i].x,nOut=CONNS[i].y;\n                  if(uIn==nOut)\n                   if(iFrame%FR==0|| pressed(32)){\n                      uvec4 cd=floatBitsToUint(texelFetch(iChannel0,ivec2(0,i),0));\n                      uint first =  (cd.x & MINBIT);\n                      if(tra(-id,cd.w)==0u && first!=0u) d.x++;\n                      // \n                   }\n               }\n          }\n          if(uIn==-id) { //source \n              for(int i=ZERO;i<NC;i++){\n                  int nIn=CONNS[i].x,nOut=CONNS[i].y;\n                  if(uOut==nIn)\n                   if(iFrame%FR==0|| pressed(32)){\n                      uvec4 cd=floatBitsToUint(texelFetch(iChannel0,ivec2(0,i),0));\n                      uint last =  (cd.x & MAXBIT);\n                      if(tra(-id,cd.w)!=0u && last==0u) d.y++;                      \n                   }\n               }\n          }\n       }\n   }else{\n      d=uvec4(0u);\n       for(int i=ZERO;i<NC;i++){\n           int nIn=CONNS[i].x,nOut=CONNS[i].y;\n           \n           if(nIn>=0 && nOut>=0) {\n               uint cd = floatBitsToUint(texelFetch(iChannel0,ivec2(0,i),0)).x;\n               d.x+=count(mask(cd))/uint(SHBIT);\n           }\n           if(nIn<0){\n               d.z+=floatBitsToUint(texelFetch(iChannel0,ivec2(1,-nIn),0)).y;\n           }\n           else if(nOut<0){\n               d.y+=floatBitsToUint(texelFetch(iChannel0,ivec2(1,-nOut),0)).x;\n           }\n       }\n       \n       \n   }\n    O=uintBitsToFloat(d);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//CONFIGURTION SETTINGS:\n#define FR 6 //number of frames between updates (1==max speed)\n#define SHBIT 4  // number of bits per slot (4: 15 item types, 2: 3 item types,1:no types)\n\n\n//--------------------------\n//bit logic\nconst float SHBITF=float(SHBIT),\n            MAXW=32.;\nconst uint FULLBIT=0xFFFFFFFFu,\n           MINBIT=(1u<<(SHBIT))-1u,\n           MAXBIT=(MINBIT<<(32-SHBIT)); \n\nuint mask(uint x){\n#if (SHBIT==4)\n    uint t =((x&0x88888888u) >>3)\n           |((x&0x44444444u) >>2)\n           |((x&0x22222222u) >>1)\n           | (x&0x11111111u);\n    return (t<<3)|(t<<2)|(t<<1)|t; \n#else\n#if (SHBIT==2) \n    uint t =((x&0xAAAAAAAAu) >>1)|(x&0x55555555u);\n    return (t<<1)|t; \n#else \n    return x;\n#endif\n#endif\n}\n\n// circuit configuration:\n//----------------------------\n// endpoint positions\nvec2[] NODES=vec2[](\n    vec2(-3.,-1.5),vec2(-2,-1.5),vec2(-1,-1),vec2(-1,0),vec2(-1,1), //0-4\n    vec2(-.5,2),vec2(.5,2),vec2(1.5,2),vec2(0,0),vec2(.5,1),        //5-9\n    vec2(-2,1),vec2(-1.5,2), vec2(1.5,.5),vec2(1.,-.5),vec2(2.,-1), //10-14\n    vec2(.5,-1.5),vec2(-.5,-2),vec2(0,-1),vec2(-1.5,-1.5),vec2(-2,-.5)\n    );\n// connections  x=from y=to\n\n#define NC 27 \nivec2[] CONNS=ivec2[](\n    ivec2(0,1),ivec2(1,2),ivec2(2,3),ivec2(4,5),ivec2(5,6),\n    ivec2(6,7),ivec2(7,-4),ivec2(-1,0),ivec2(3,4),ivec2(10,4),\n    ivec2(-2,10),ivec2(14,-6),ivec2(11,5),ivec2(-3,11),ivec2(8,17),\n    ivec2(8,13),ivec2(13,14),ivec2(12,-5),ivec2(6,9),ivec2(9,8),\n    ivec2(9,12),ivec2(13,15),ivec2(15,16),ivec2(16,18),ivec2(18,19),\n    ivec2(17,2),ivec2(19,3)                             \n    );\n//--------------------------------\n\n//Iq https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 pos(vec2 I,vec2 r) {return (I/r.y *2.- r/r.y)*2.2 ;}\n\nvec3 segment(vec2 p,vec2 a,vec2 b) {\n    float l= length(b - a);\n    vec2 n=normalize(b - a),\n         cp=mix(a, b, clamp(dot(p - a, n) / l, 0., 1.));\n    float x = dot(p-a,n), y = length(p-a-x*n);\n    return vec3(distance(p, cp),x/l,y);\n}\n\n#define  pressed( k)  (texelFetch(iChannel1, ivec2(k, 0), 0).x > 0.5)\n#define PI 6.2830\n#define R iResolution.xy\n#define ZERO min(iFrame,0)","name":"Common","description":"","type":"common"}]}