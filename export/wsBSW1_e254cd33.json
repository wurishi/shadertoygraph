{"ver":"0.1","info":{"id":"wsBSW1","date":"1608585903","viewed":197,"name":"2.5D FPS Map Renderer","username":"kubamaruszczyk1604","description":"2.5D Maze: Wall segment ray casting.\n2D ray-casting technique similar to Wolfrenstein3D engine.  \n\nInteraction: Doom-like\n\nArrow keys:  Up - forward,  Down - back,  Left - rotate left, Right - rotate right\nCtrl key: run","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raycasting","25d","wolfenstein"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n2.5D Maze: Wall segment ray casting.\n2D ray-casting technique similar to that used by Wolfenstein3D engine. \n\nInteraction:\n\nArrow keys: up - forward, down - back, left - rotate left, right - rotate right\n\nctrl key: run\n\n*/\n\n\n//#define AA\n#define RED_SCREEN_BORDERS\n\nconst vec3 FLOOR_COL = vec3(0.250,0.25,0.3);\nconst vec3 CEILING_COL = vec3(0.05);\nconst float GAMMA = 0.98;\n\nconst int cMap[100] = int[]\n    (\n        2,2,2,2,0,0,2,2,2,2,\n        2,0,0,0,0,0,0,0,0,1,\n        2,0,0,0,0,0,0,0,0,1,\n        2,0,2,0,2,0,2,0,0,1,\n        2,0,0,0,0,0,0,0,0,1,\n        2,0,2,0,0,2,0,2,0,1,\n        2,0,0,0,0,0,0,2,0,1,\n        2,0,2,0,0,0,2,0,0,1,\n        2,0,0,0,2,0,0,0,0,1,\n        2,1,1,1,1,1,1,1,1,1\n    );\n\nconst vec2 cMapSize = vec2(10.0,10.0); \nconst float cDepth = 10.0;\n\n\n\nint GetCoord(int x, int y)\n{\n   return (int(cMapSize.y)*y)+x;\n}\n\nint GetCell(vec2 p)\n{\n    int x = int(p.x);\n    int y = int(p.y);\n    if(x > int(cMapSize.x-1.0)) return 0;\n    if(y > int(cMapSize.y-1.0)) return 0;\n    \n    return cMap[GetCoord(x,y)];\n}\n\n\nvoid Map(vec2 uv, vec2 playerPos, inout vec3 col)\n{\n    //remap uv to local map uv\n   uv.x = clamp(0.0, 1.0, 1.0 * uv.x - 0.7);\n   uv.y = clamp(0.0, 1.0, 1.3 * uv.y - 0.2);\n   if(uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0)\n   {\n     col= 0.3*col + 0.7*vec3(vec3(0.1,0.1,0.14));\n     uv*=10.0;\n     uv.x = 10.0 - uv.x;\n     int cell = GetCell(uv);\n     if(cell > 0)\n     {\n        col += vec3(0.4,0.0,0.0);\n     }\n     \n     if(length(playerPos - uv)<0.25)\n     {\n        col = vec3(0.0,0.4,1.0);\n     }\n   } \n   \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratioX = iResolution.x/iResolution.y;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv -1.0;\n    float ra =uv.x;\n    uv.x *= ratioX;\n    \n\n   \n    float yRotation = 0.0;\n    \n    Player player;\n    player.Pos = vec2(5.5,0.5);\n    vec4 persistentState = texture(iChannel1, vec2(0.5,0.5));\n    yRotation = -persistentState.z;\n    player.Dir = normalize(Rotate(vec2(0.0,1.0),yRotation));\n    \n   \n    player.Pos += persistentState.xy;\n    vec2 rayDir = normalize(Rotate(player.Dir, 0.3*ra));\n    \n    vec2 ray = vec2(0);\n    float t = 0.0;\n    const float stp = 0.01;\n    bool hit = false;\n    int cell = 0;\n    while(t < cDepth && !hit)\n    {\n      ray = player.Pos + rayDir*t;\n      cell =  GetCell(ray); \n      t +=stp; \n      if(cell > 0) hit = true; \n    }\n    \n    t *= cos(0.3*ra);\n    float ceiling = 1.0/t;\n    float floorp = -1.0/t;\n    float normInvDist = 0.9-t/cDepth;\n    vec3 col = vec3(normInvDist);\n    vec2 txc = vec2(fract(ray.x+ray.y),  uv.y/(ceiling-floorp)+ 0.5);\n    if(cell == 2)\n    col *= texture(iChannel0,txc).rgb*vec3(0.98,0.98,0.99);\n    if (cell == 1) \n    col *= vec3(0.4,0.5,1.0);\n    \n    col *= clamp(0.0,1.0,pow(1.4-abs(0.5-txc.x),2.5));\n    col *= clamp(0.0,1.0,pow(1.2-abs(0.45-txc.y),2.5));\n    \n    #ifdef AA \n    float sp = smoothstep(ceiling - 0.01, ceiling +0.01,uv.y); \n    col = mix(col,CEILING_COL,sp);\n    sp = smoothstep(floorp + 0.01, floorp -0.01,uv.y); \n    col = mix(col,FLOOR_COL*abs(uv.y),sp);\n    #else\n    if(uv.y > ceiling) col = CEILING_COL;\n    \n    //vec2 uvtmp = vec2(uv.x ,  uv.y );\n    //vec2 uvFloor = vec2(uvtmp.x/uvtmp.y, (1.0/uvtmp.y))\n    //- Rotate(player.Pos,-yRotation);\n    //uvFloor = Rotate(uvFloor+player.Pos,-yRotation);\n    vec3 flCol = FLOOR_COL;\n    //texture(iChannel2,uvFloor).xyz;\n    if(uv.y < floorp)  col = flCol*abs(uv.y);\n    #endif\n    \n    \n    #ifdef RED_SCREEN_BORDERS\n    col = mix(col,vec3(0.4,0.0,0.0),abs(pow(uv.y*0.93,9.0)));\n    #endif\n    Map(uv, player.Pos, col);\n    fragColor = vec4(pow(col,vec3(GAMMA)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// BUFFER A - KEYBOARD INUT + POSITION & DIRECTION UPDATE\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_CTRL = 17;\n\nconst float MOVEMENT_STEP = 1.2;\nconst float ROTATION_STEP = 1.2;\n\nbool IsPressed(int key)\n{\n   return bool(texelFetch( iChannel0, ivec2(key,0),0 ).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    float ratioX = iResolution.x/iResolution.y;\n    \n    vec4 col = texture(iChannel1, uv);\n    Player player;\n    player.Pos = col.xy;\n    player.Dir = Rotate(vec2(0.0,1.0),-col.z);\n    \n    float rotation = 0.0;\n    float displacement = 0.0;\n   if(IsPressed(KEY_LEFT))\n    { \n       rotation = ROTATION_STEP * iTimeDelta;\n    }\n    if(IsPressed(KEY_RIGHT))\n    { \n       rotation = -ROTATION_STEP * iTimeDelta;\n    }\n    if(IsPressed(KEY_UP))\n    { \n       displacement = MOVEMENT_STEP * iTimeDelta;\n    }\n    if(IsPressed(KEY_DOWN))\n    { \n      displacement = -MOVEMENT_STEP * iTimeDelta;\n    }\n    if(IsPressed(KEY_CTRL))\n    {\n      displacement *=2.0;\n      rotation *= 1.5;\n    }\n    \n    col.z += rotation;\n    col.xy += player.Dir*displacement;\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//PERSISTENCE BUFFER \"SWAP\"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Player\n{\n    vec2 Pos;\n    vec2 Dir;\n};\n\nvec2 Rotate(vec2 v, float theta)\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}","name":"Common","description":"","type":"common"}]}