{"ver":"0.1","info":{"id":"MtV3Dy","date":"1478087022","viewed":882,"name":"Platonic Solids","username":"decrooks","description":"The five Platonic solids orbiting a sphere.","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","cube","sphere","tetrahedron","icosahedron","dodecahedron","octahedron","platonic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// An exercise in platonic geometry with signed distance funcions.\n// https://en.wikipedia.org/wiki/Platonic_solid\n// SDF\n// https://iquilezles.org/articles/distfunctions\n// http://www.alanzucconi.com/2016/07/01/signed-distance-functions/\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n//Golden mean and inverse -  for the icosohedron and dodecadron\n#define PHI 1.6180339887\n#define INV_PHI 0.6180339887\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct LightColor {\n\tvec3 diffuse;\n\tvec3 specular;\n};\n    \n    \nstruct Material {\n    LightColor  color;\n    float shininess;\n    float mirror;\n    float refractiveIndex;\n    float opacity;  \n};\n    \n    \nstruct MapValue {\n    float \t  signedDistance;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    vec3 normal;\n    Ray \t ray;\n    Ray reflection;\n    Material material;\n    bool hit;\n};\n    \n\nstruct PointLight {\n    vec3 position;\n    LightColor color;\n};\n    \nstruct DirectionalLight {\n    vec3 direction;\n    LightColor color;\n};\n    \nPointLight  light1,light2;\n\n\nMaterial blackMat,whiteMat,blueMat,yellowMat;\n\nvec3 rayPoint(Ray r,float t) {\n \treturn r.origin +  t*r.direction;\n}\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }\n}\n\nMapValue addObjects(MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance<d2.signedDistance) {\n    \treturn    d1 ;\n    }\n    else {\n    \treturn d2;\n    }\n}\n\n\nMapValue subtractObjects( MapValue A, MapValue B )\n{\n    //A-B\n    if (-B.signedDistance>A.signedDistance){\n        B.signedDistance *= -1.0;\n        B.material = A.material;\n    \treturn    B ;\n    }\n    else {\n       \n    \treturn A;\n    }\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    //http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n   return dot(p - origin,normal);   \n}\n\nfloat  doubleplane(vec3 p, vec3 origin, vec3 normal){ \n   return max(dot(p - origin,normal),dot(-p - origin,normal));   \n}\n\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n \n  MapValue mv;\n  mv.material = m;\n   \n  mv.signedDistance = plane(p,origin,normal);\n  return mv;\n}\n\nMapValue sphere(vec3 p, float radius, Material m) {\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance =length(p) - radius;\n  return mv;\n}\n\nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = p.y - y;\n  return mv;\n}\n\n//////////////////////////////////////////////////////////\n//---------------Platonic solids -----------------------//\n//////////////////////////////////////////////////////////\n\n//cube by iq\nMapValue cube( vec3 p, float d , Material m)\n{\n  MapValue mv;\n  mv.material = m;\n \n  mv.signedDistance = length(max(abs(p) -d,0.0));\n  return mv; \n}\n\n\n\nMapValue tetrahedron(vec3 p, float d, Material m) {\n    \n  MapValue mv;\n  mv.material = m;\n \n  float dn =1.0/sqrt(3.0);\n  \n   //The tetrahedran is the intersection of four planes:\n    float sd1 = plane(p,vec3(d,d,d) ,vec3(-dn,dn,dn)) ; \n    float sd2 = plane(p,vec3(d,-d,-d) ,vec3(dn,-dn,dn)) ;\n \tfloat sd3 = plane(p,vec3(-d,d,-d) ,vec3(dn,dn,-dn)) ;\n \tfloat sd4 = plane(p,vec3(-d,-d,d) ,vec3(-dn,-dn,-dn)) ;\n  \n    //max intersects shapes\n    mv.signedDistance = max(max(sd1,sd2),max(sd3,sd4));\n  return mv; \n}\n\n\nMapValue octahedron(vec3 p,  float d, Material m) {\n \n  //The octahedron is the intersection of two dual tetrahedra.  \n  MapValue mv = tetrahedron(p,d,m);\n  MapValue mv2 = tetrahedron(-p,d,m);\n  \n  mv = intersectObjects(mv,mv2);\n    \n  return mv; \n}   \n\nMapValue alternativeOctahedron(vec3 p,  float d, Material m) {\n   //Alternative construction of octahedran.\n   //The same as for a terahedron, except intersecting double planes (the volume between two paralell planes). \n    \n    MapValue mv;\n    mv.material = m;\n \n    float dn =1.0/sqrt(3.0);\n    float sd1 = doubleplane(p,vec3(d,d,d) ,vec3(-dn,dn,dn)) ; \n    float sd2 = doubleplane(p,vec3(d,-d,-d) ,vec3(dn,-dn,dn)) ;\n \tfloat sd3 = doubleplane(p,vec3(-d,d,-d) ,vec3(dn,dn,-dn)) ;\n \tfloat sd4 = doubleplane(p,vec3(-d,-d,d) ,vec3(-dn,-dn,-dn)) ;\n    \n    mv.signedDistance = max(max(sd1,sd2),max(sd3,sd4));\n  return mv; \n}   \n\n\n\nMapValue dodecahedron(vec3 p,  float d, Material m) {\n  \n    MapValue mv;\n    mv.material = m;\n\n    //Some vertices of the icosahedron.\n    //The other vertices are cyclic permutations of these, plus the opposite signs.\n    //We don't need the opposite sign because we are using double planes - two faces for the price of one. \n    vec3 v = normalize(vec3(0.0,1.0,PHI));\n    vec3 w = normalize(vec3(0.0,1.0,-PHI));\n       \n    //The dodecahedron is dual to the icosahedron. The faces of one corespond to the vertices of the oyther.\n    //So we can construct the dodecahedron by intersecting planes passing through the vertices of the icosohedran.\n    float ds = doubleplane(p,d*v,v);\n    //max == intesect objects\n    ds = max(doubleplane(p,d*w,w),ds); \n\n    ds = max(doubleplane(p,d*v.zxy,v.zxy),ds);\n    ds = max(doubleplane(p,d*v.yzx,v.yzx),ds);\n\n\n    ds = max(doubleplane(p,d*w.zxy,w.zxy),ds);\n    ds = max(doubleplane(p,d*w.yzx,w.yzx),ds);\n    \n    mv.signedDistance = ds;\n  \n       \n    return mv; \n}   \n\n\nMapValue icosahedron(vec3 p,  float d, Material m) {\n  \n  \tMapValue mv;\n  \tmv.material = m;\n  \tfloat h=1.0/sqrt(3.0);\n    \n    \n    //Same idea as above, using the vertices of the dodecahedron\n    vec3 v1 = h* vec3(1.0,1.0,1.0);\n    vec3 v2 = h* vec3(-1.0,1.0,1.0);\n    vec3 v3 = h* vec3(-1.0,1.0,-1.0);\n    vec3 v4 = h* vec3(1.0,1.0,-1.0);\n   \n    vec3 v5 = h* vec3(0.0,INV_PHI,PHI);\n    vec3 v6 = h* vec3(0.0,INV_PHI,-PHI);\n    \n    float ds = doubleplane(p,d*v1,v1);\n    //max == intesect objects\n \tds = max(doubleplane(p,d*v2,v2),ds);\n    ds = max(doubleplane(p,d*v3,v3),ds); \n    ds = max(doubleplane(p,d*v4,v4),ds);\n    ds = max(doubleplane(p,d*v5,v5),ds); \n    ds = max(doubleplane(p,d*v6,v6),ds);\n    \n    //plus cyclic permutaions of v5 and v6:\n    ds = max(doubleplane(p,d*v5.zxy,v5.zxy),ds); \n    ds = max(doubleplane(p,d*v5.yzx,v5.yzx),ds);\n    ds = max(doubleplane(p,d*v6.zxy,v6.zxy),ds);\n    ds = max(doubleplane(p,d*v6.yzx,v6.yzx),ds);\n    \n    mv.signedDistance = ds;\n    \n  \treturn mv;\n}   \n\n//////////////////////////////////////////////////////////////\n\n\nvoid setMaterials() {\n    float t  = iTime;\n    float s = 0.4*(1.0+sin(t));\n    vec3 specular = vec3(0.3); \n    float shininess = 16.0;\n    blackMat = Material(LightColor(vec3(0.0,0.0,0.01),vec3(0.1,0.1,0.1)) ,35.0,0.75,1.0,1.0);\n    whiteMat = Material(LightColor(vec3(1.0),vec3(1.0)) ,shininess ,0.75,1.0,1.0);\n    blueMat = Material(LightColor(vec3(0.3,0.3,0.75),vec3(0.3,0.3,1.0)) ,shininess ,0.75,1.0,1.0);\n    yellowMat = Material(LightColor(vec3(0.8,0.8,0.4),vec3(0.9,0.9,0.2)) ,shininess ,0.75,1.0,1.0);\n}\n\n\nvec3 orbit(float t){\n    return vec3(sin(t),0.0,cos(t));\n}\n\n/////////////////////Map the sceane/////////////////////////////////////////////\n\n\nMapValue map(vec3 p){\n   float t  = iTime;\n   mat3 R = rotationMatrix(orbit(0.2*t),0.67*t);\n   float r = 0.8; \n    \n   MapValue objects = sphere(p,0.3,blackMat);\n   \n   // Add the five platonic solids\n   objects = addObjects(objects,cube( R*(p + r*orbit(t)),0.25,whiteMat));\n   objects = addObjects(objects,tetrahedron(R*(p + r*orbit(t+ TWO_PI*0.2)),0.25,whiteMat));\n   objects = addObjects(objects,octahedron(R*(p + r*orbit(t+ TWO_PI*0.4)),0.35,whiteMat));\n   objects = addObjects(objects,dodecahedron(R*(p + r*orbit(t+ TWO_PI*0.6)),0.25,whiteMat));\n   objects = addObjects(objects,icosahedron(R*(p + r*orbit(t+ TWO_PI*0.8)),0.25,whiteMat));\n   \n   //add a floor and a cieling\n   objects = addObjects(objects,xzPlane(p,-0.75,blueMat));\n   objects = addObjects(objects,xzPlane(-p,-2.0,yellowMat));\n    \n   return objects;\n}\n\n\n///////////////////////////Raytracing////////////////////////////////////////\n\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    vec3 normal = vec3(\n                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,\n                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,\n                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\nTrace castRay(in Ray ray, float maxDistance){\n    float dist = 0.01;\n    float presicion = 0.001;\n\tvec3 p;\n    MapValue mv;\n    bool hit = false;\n    for(int i=0; i<64; i++){\n    \tp = rayPoint(ray,dist);\n       \tmv = map(p);\n         dist += 0.5*mv.signedDistance;\n        if(mv.signedDistance < presicion)\n        {\n          hit = true; \n            break;\n        } \n         if(dist>maxDistance) break;\n       \n    }\n    return Trace(dist,p,p,ray,ray,mv.material,hit);\n}\n\nTrace traceRay(in Ray ray, float maxDistance) {\n    Trace trace = castRay(ray,maxDistance);\n    trace.normal = calculateNormal(trace.p);\n    trace.reflection = Ray(trace.p,reflect(ray.direction, trace.normal));\n\n    return trace;\n}\n\nfloat castShadow(in Ray ray, float dist){\n    Trace trace = castRay(ray,dist);\n    float maxDist = min(1.0,dist);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ \n\tvec3 v = normalize(lookAtCenter -viewPoint);\n    \n    vec3 n1 = cross(v,vec3(0.0,1.0,0.0));\n    vec3 n2 = cross(n1,v);  \n        \n    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);\n                                    \n    Ray ray;\n                    \n    ray.origin = viewPoint;\n   \tray.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return ray;\n}\n\nvec3 diffuseLighting(in Trace trace, vec3 lightColor,vec3 lightDir){\n    float lambertian = max(dot(lightDir,trace.normal), 0.0);\n  \treturn  lambertian * trace.material.color.diffuse * lightColor; \n}\n\n\n\nvec3 cookTorranceSpecularLighting(in Trace trace, vec3 lightColor,vec3 L){\n    //https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\n    //https://renderman.pixar.com/view/cook-torrance-shader\n    \n    \n    vec3 V = -trace.ray.direction;\n\n    vec3 H = normalize(L + V);\n    \n    float NdotH = dot(trace.normal, H);\n    float NdotV = dot(trace.normal, V);\n    float VdotH = dot(V ,H );\n    float NdotL = dot(trace.normal , L);\n    \n    float lambda  = 0.25;\n    float F = pow(1.0 + NdotV, lambda);\n    \n    float G = min(1.0,min((2.0*NdotH*NdotV/VdotH), (2.0*NdotH*NdotL/VdotH)));\n    \n    \n   // Beckmann distribution D\n    float alpha = 5.0*acos(NdotH);\n    float gaussConstant = 1.0;\n\tfloat D = gaussConstant*exp(-(alpha*alpha));\n    \n    \n    float c = 1.0;\n    float specular = c *(F*D*G)/(PI*NdotL*NdotV);\n    \n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\n\n\n\nvec3 pointLighting(in Trace trace, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n   \n  \tvec3 color =  diffuseLighting(trace, light.color.diffuse, lightDir);\n\n    color += cookTorranceSpecularLighting(trace, light.color.specular, lightDir);\n\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n    color *= attenuation*shadow;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, DirectionalLight light){\n\n    vec3 color =  diffuseLighting(trace, light.color.diffuse, light.direction);\n    \n    color += cookTorranceSpecularLighting(trace, light.color.specular, light.direction);\n    \n    float shadow = castShadow(Ray(trace.p,light.direction),3.0);\n    color *= shadow;\n    return  color;\n}\n\n\nvoid setLights(){\n  \tfloat  time = iTime;\n    vec3 specular = vec3(1.0);\n  \tlight1 = PointLight(vec3(cos(1.3*time),1.0,sin(1.3*time)),LightColor( vec3(1.0),specular));\n  \tlight2 = PointLight(vec3(0.7*cos(1.6*time),1.1+ 0.35*sin(0.8*time),0.7*sin(1.6*time)),LightColor(vec3(1.0),specular)); \n} \n\n\nvec3 lighting(in Trace trace){\n    vec3 color = vec3(0.01,0.01,0.2);//ambient color     \n\tcolor += pointLighting(trace, light1);\n\tcolor += pointLighting(trace, light2) ;\n\n    return color;\n}\n\nfloat rayDistance(Ray r,vec3 p){\n    vec3 v = r.origin - p;\n    return length(v - dot(v,r.direction)*r.direction);\n}\n\nvec3 render(vec2 p){\n    vec3 viewpoint = vec3(-1.0,1.9,-2.3);\n    \n    vec3 lookAt = vec3(0.0,-0.15,0.0);\n    \n  \tRay ray = cameraRay(viewpoint,lookAt,p,2.4);\n    vec3 color = vec3(0.0);\n    float frac = 1.0;\n   \n    float d = 0.0;\n    float maxDistance = 7.0;\n    for(int i = 0; i<2; i++) {\n        Trace trace = traceRay(ray,maxDistance);\n        \n \t\tif(i==0) d = trace.dist;\n        maxDistance -= trace.dist;\n    \tcolor += lighting(trace)*(1.0 - trace.material.mirror)*frac;\n        if(!trace.hit) break;\n        \n        frac *= trace.material.mirror;\n        if(frac < 0.1 || maxDistance<0.0) break;\n        ray = trace.reflection;\n    }\n   \t\n    \n   \n   \treturn color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \tsetLights();\n    setMaterials();\n    \n   \tvec3 colorLinear =  render(p);\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}","name":"Image","description":"","type":"image"}]}