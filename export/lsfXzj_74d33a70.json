{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//Affine arithmetic raytracing\n//by nimitz (stormoid.com) (twitter: @stormoid)\n\n/*\n\tA different (and pretty fast/accurate) way of drawing\n\t3d surfaces. This is (for most cases) an improvement on\n\tinterval arithmetic raytracing, in which tracing steps\n\tare defined by intervals, here's screenshot for interval arithmetic\n\traytracing in 2d (thanks to paniq): http://i.imgur.com/D0WEdCl.png\n\tthe \"affine\" version allows for skewed bounding boxes (parallelograms)\n\twhich allows for more efficient bounding.\n\n\tdrawing arbitrary stuff is not as \"intuitive\" as with standard\n\traymarching, but for implicit surfaces like the ones shown here\n\tthe results are pretty convincing.\n\n\tThis is an implementation of: http://www.cs.utah.edu/~knolla/cgrtia.pdf\n\tStill looking for ways to improve both the speed and quality.\n\tsome form of back recursion would definitely be a good thing.\n\n\tthanks to paniq for the inspiration (https://www.shadertoy.com/view/lssSWH)\n*/\n\n//max number of steps (much shorter loop on average)\n#define STEPS 50\n\n//the initial step size (lower is generally better, but will be slower)\n//you can go as low as 0.01 (you may need to increase STEPS though)\n#define BASE_STEP 0.5\n\n//keep precision to a minimum given your surfaces\n//very high precision induces noise, to be expected.\n#define PRECISION 6\n\n//1 = \"Mitchell\" | 2 = \"Tangle\" (requires lower base step) | 3 = Spheres\n#define SURFACE_TYPE 1\n\n#define time iTime\n\nmat2 makem2(const in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nmat3 rotXY(const in vec2 angle ) \n{\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\t\n\treturn mat3(c.y      ,  0.0, -s.y,\n\t\t\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\t\t\ts.y * c.x, -s.x,  c.y * c.x\t);\n}\n\n//////////////////////////////////////////////////////////\n//___________________AFFINE ARITHMETIC____________________\n\n//\twould be great if we could have trig functions\n//\tmaybe using taylor series? let me know if you have ideas.\n//\trinv() (1/x), rsqrt(), rmin() and rmax() would also be useful.\n//////////////////////////////////////////////////////////\nvec3 rvec3(const in vec2 p){vec3 r;\n\tr.x = (p.y + p.x);\n\tr.y = (p.y - p.x);\n\tr.xy *= .5;r.z = 0.;\n\treturn r;}\n\nfloat rradius(const in vec3 a){return abs(a.y) + a.z;}\n\nvec3 radd(in vec3 a, in vec3 b){return (a + b);}\nvec3 radd(in float x, in vec3 a){vec3 r = a;r.x += x;return r;}\nvec3 radd(in vec3 a, in float x){vec3 r = a;r.x += x;return r;}\n\nvec3 rmul(in vec3 a, in vec3 b){\n\tvec3 r;\n\tr.x = a.x * b.x;\n\tr.y = a.x*b.y + b.x*a.y;\n\tr.z = abs(a.x*b.z) + abs(b.x*a.z) +\n\t\t  rradius(a)*rradius(b);\n\treturn r;}\n\nvec3 rmul(const in float x, const in vec3 a){\n\tvec3 r = a;\n\tr.x *= x;\n\tr.y *= x;\n\tr.z = abs(r.z*x);\n\treturn r;}\n\nvec3 rsqr(const in vec3 a){\n\tvec3 r;\n\tr.x = a.x*a.x;\n\tr.y = a.x*a.y + a.x*a.y;\n\tr.z = abs(a.x*a.z) + abs(a.x*a.z) +\n\t\t  rradius(a)*rradius(a);\n\treturn r;}\n\nbool rcontains(in vec3 a, in float t){\n\treturn (abs(t-a.x)<rradius(a));}\n\n//////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////\n\n//Implemented a few of the functions in the paper\n//look at appendix page 14 for more functions.\nvec3 sphere(in vec3 X, in vec3 Y, in vec3 Z, in float r)\n{\n\treturn radd(radd(radd(rmul(X,X), rmul(Y,Y)), rmul(Z,Z)), -r);\n}\n\nvec3 mitchell(in vec3 X, in vec3 Y, in vec3 Z, in float r)\n{\n\tvec3 x2 = rsqr(X);\n\tvec3 y2 = rsqr(Y);\n\tvec3 z2 = rsqr(Z);\n\t\n\tvec3 x4 = rsqr(x2);\n\t\n\tvec3 t1 = rmul(4.,x4+rsqr(y2+z2));\n\tvec3 t2 = rmul(100.+sin(time*1.)*106.,rmul(x2,y2+z2));\n\tvec3 t3 = rmul(1.,(x2+y2+z2));\n\t\n\treturn radd(t1+t2+t3,-r*5.);\n}\n\nvec3 tangle(in vec3 X, in vec3 Y, in vec3 Z, in float r)\n{\n\tvec3 x2 = rsqr(X);\n\tvec3 x4 = rsqr(x2);\n\tvec3 y2 = rsqr(Y);\n\tvec3 y4 = rsqr(y2);\n\tvec3 z2 = rsqr(Z);\n\tvec3 z4 = rsqr(z2);\n\t\n\treturn radd(x4-rmul(r,x2)+y4-rmul(5.,y2)+z4-rmul(5.,z2),11.8);\n}\n\nvec3 map(in vec3 X, in vec3 Y, in vec3 Z)\n{\n\t#if SURFACE_TYPE == 1\n\treturn mitchell(X,Y,Z,10.);\n\t#elif SURFACE_TYPE == 2\n\treturn tangle(X,Y,Z,5.);\n\t#else\n\tvec3 sph1 = sphere(X,radd(sin(time*0.4)*3.,Y),Z,1.);\n\tvec3 sph2 = sphere(radd(sin(time*0.5),X),Y,Z,1.6);\n\treturn rmul(sph1,sph2);\n\t#endif\n}\n\n// not a very efficient way of getting the normal.\n// but the alternative is to define the whole map twice\n// (once for affine once for \"regular\")\nvec3 norm(in vec3 X, in vec3 Y, in vec3 Z, in vec3 ro, in vec3 rd)//(in vec3 p)\n{\n\tfloat ep = .0001;\n\tvec3 f1 = map(radd(ep,X),Y,Z)-map(radd(-ep,X),Y,Z);\n\tvec3 f2 = map(X,radd(ep,Y),Z)-map(X,radd(-ep,Y),Z);\n\tvec3 f3 = map(X,Y,radd(ep,Z))-map(X,Y,radd(-ep,Z));\n\treturn normalize(vec3(f1.x,f2.x,f3.x));\n}\n\t\n\nvec4 trace(in vec3 ro, in vec3 rd)\n{\t\n\tvec2 t = vec2(4., 10.);\n\tfloat tincr = BASE_STEP;\n\tint d = 0;\n\t\n\tvec3 t0 = rvec3(vec2(ro.x+rd.x*t.x,ro.x+rd.x*t.y));\n\tvec3 t1 = rvec3(vec2(ro.y+rd.y*t.x,ro.y+rd.y*t.y));\n\tvec3 t2 = rvec3(vec2(ro.z+rd.z*t.x,ro.z+rd.z*t.y));\n\tvec3 f = map(t0,t1,t2);\n\t\n\tif (rcontains(f, 0.))\n\t{\n\tfor (int i = 0; i < STEPS; ++i)\n\t{\n\t\tt.y = t.x + tincr;\n\t\t\n\t\tt0 = rvec3(ro.x+rd.x*t);\n\t\tt1 = rvec3(ro.y+rd.y*t);\n\t\tt2 = rvec3(ro.z+rd.z*t);\n\t\tf = map(t0,t1,t2);\n\t\t\n\t\tif (rcontains(f, 0.))\n\t\t{\n\t\t\tif (d>PRECISION)\n\t\t\t{\n\t\t\t\tvec3 nrm = norm(t0,t1,t2, ro, rd);\n\t\t\t\treturn vec4(t.x,nrm);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttincr *= .5;\n\t\t\t\td++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt.x = t.y;\n\t\t\t\n\t\t\t//back recursion should help in theory, but I have found that\n\t\t\t//it only increase computational cost and doesnt improve quality\n\t\t\t//for most funcions.\n\t\t\t#if 0\n\t\t\tfloat fp = fract(.5*t.x/tincr);\n\t\t\tif (fp < 1e-8)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<=PRECISION; j++)\n\t\t\t\t{\n\t\t\t\t\ttincr *= 1.5;\n\t\t\t\t\td--;\n\t\t\t\t\tfp = fract(.5*t.x/tincr);\n\t\t\t\t\tif (d==-1 || fp > 1e-8) break;\n\t\t\t\t}\n\t\t\t\tif (d==-1) break;\n\t\t\t}\n\t\t\t#endif\n\t\t\t}\n\t}\n\t\t}\n\treturn vec4(-1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tfloat asp = iResolution.x/iResolution.y;\n\tp.x *= asp;\n\t\n\tvec2 mo = iMouse.yx/iResolution.xy-0.5;\n\tmo.x *= asp;\n\t\n\t//camera\n\tvec3 ro = vec3(8.,.0,0.);\n\tro.zx *= makem2(time*.3-0.5);\n\tro.xy *= makem2(sin(time*0.1)*0.2);\n\tro *= rotXY(vec2(-mo.x,-mo.y*1.5));\n\tvec3 ta = vec3(0.);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\t\n\t//x = distance from eye || yzw = normal\n\tvec4 n = trace(ro,rd);\n\t\n\t//lighting from iq\n\tvec3 col = vec3(0);\t\n\tif (n.x >= 0.)\n\t{\n\t\tvec3 nor = n.yzw;\n\t\tvec3 pos = (ro+rd*n.x);\n\t\tvec3 mate = sin(vec3(.2+sin(time)*1.5,pos.x,pos.x)*.2)*0.5+0.5;\n\t\tvec3 ref = reflect( rd, nor );\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += mix( vec3(0.), 1.2*vec3(0.75,0.9,1.0), 0.5 + 0.5*nor.y );\n\t\tlin *= vec3(0.7,0.5,0.3)*pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 )*1.5+1.;\n\t\tlin += 1.5*clamp(0.33+1.5*nor.y,0.0,1.0)*pow(texture( iChannel0, ref ).xyz,vec3(2.2))\n\t\t\t*(0.04+0.96*pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 4.0 ));\n\t\tcol = lin * mate;\n\t}\n\telse col = texture(iChannel0,rd).rgb;\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsfXzj","date":"1403926825","viewed":1441,"name":"Affine arithmetic 3d","username":"nimitz","description":"Click and drag to change rotation.\nraytracing using reduced affine arithmetic (http://www.cs.utah.edu/~knolla/cgrtia.pdf)\nInterval arithmetic version: https://www.shadertoy.com/view/ldXSz2","likes":41,"published":1,"flags":0,"usePreview":0,"tags":["3d","implicit","raa","affinearithmetic"],"hasliked":0,"parentid":"","parentname":""}}