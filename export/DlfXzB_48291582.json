{"ver":"0.1","info":{"id":"DlfXzB","date":"1674947982","viewed":205,"name":"Barth Sextic (+ Halley's Method)","username":"fizzer","description":"The [url=https://mathworld.wolfram.com/BarthSextic.html]Barth Sextic[/url], raytraced with 2nd-order root-finding algorithm [url=https://en.wikipedia.org/wiki/Halley%27s_method]Halley's method[/url].","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["geometry","surface","dual","real","algebraic","sextic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://mathworld.wolfram.com/BarthSextic.html\n\n// The rendered image has far fewer artifacts with Halley's method than Newton's,\n// but is still not completely perfect.\n\n// Related: https://www.shadertoy.com/view/dtlXzB\n\n#define AA         2\n#define USE_NEWTON 0\n\nconst float outerDodecahedronCircumradius = sqrt(3.);\n\n// Sphere intersection function from IQ\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    vec3 qc = oc - b*rd;\n    float h = ra*ra - dot( qc, qc );\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Extended dual number\nstruct Dual\n{\n   float  f; // f\n   vec2   d; // df/dt, d²f/dt²\n};\n\nconst Dual w = Dual(1., vec2(0));\nconst Dual phi = Dual((1. + sqrt(5.)) / 2., vec2(0));\n\nDual dMul(Dual a, Dual b)\n{\n    Dual res;\n    res.f = a.f * b.f;\n    res.d = vec2(a.d.x * b.f + a.f * b.d.x, a.f * b.d.y + a.d.y * b.f + 2. * a.d.x * b.d.x);\n    return res;\n}\n\nDual dSqr(Dual a)\n{\n    return dMul(a, a);\n}\n\nDual dAdd(Dual a, Dual b)\n{\n   return Dual(a.f + b.f, a.d + b.d);\n}\n\nDual dSub(Dual a, Dual b)\n{\n   return Dual(a.f - b.f, a.d - b.d);\n}\n\nDual dConst(float x)\n{\n    return Dual(x, vec2(0));\n}\n\nDual dLinear(float x)\n{\n    return Dual(0., vec2(x, 0.));\n}\n\nDual dPow(Dual a, int n)\n{\n    Dual r = Dual(0., vec2(0));\n    Dual b = a;\n    for(int i = 0; i < 4; ++i)\n    {\n        if((n & (1 << i)) != 0)\n            r = dAdd(r, b);\n        b = dMul(b, a);\n    }\n    return r;\n}\n\nDual dBarthSextic(Dual r_x, Dual r_y, Dual r_z)\n{\n    // 4(φ²x²-y²)(φ²y²-z²)(φ²z²-x²)-(1+2φ)(x²+y²+z²-w²)²w²\n    return dSub(\n        dMul(dConst(4.), dMul(dMul(dSub(dMul(dSqr(phi), dSqr(r_x)), dSqr(r_y)),\n                              dSub(dMul(dSqr(phi), dSqr(r_y)), dSqr(r_z))),\n                              dSub(dMul(dSqr(phi), dSqr(r_z)), dSqr(r_x)))),\n        dMul(dAdd(dConst(1.), dMul(dConst(2.), phi)),\n               dMul(dSqr(dSub(dAdd(dAdd(dSqr(r_x), dSqr(r_y)), dSqr(r_z)), dSqr(w))), dSqr(w)))\n        );\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a),  0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nvec3 traceRay(vec2 fragCoord)\n{\n    // Set up ray.\n    vec3 ro = vec3(0., 0., outerDodecahedronCircumradius * 2.);\n    vec3 rd = normalize(vec3((fragCoord.xy - iResolution.xy / 2.) / iResolution.y, -1.));\n\n    mat3 m = mat3(1.);        \n            \n    if(iMouse.z > 0.)\n        m = rotY((iMouse.x / iResolution.x * 2. - 1.) * 2.) *\n            rotX((iMouse.y / iResolution.y * 2. - 1.) * 2.);\n    else\n        m = rotY(-sin(iTime / 2.)) * rotX(-sin(iTime / 3.));\n\n    ro = m * ro;\n    rd = m * rd;\n\n    float t = 1e5;\n\n    // Use ray-bounding-sphere intersection test to find initial estimate for root-finding.\n    vec2 s = sphIntersect(ro, rd, vec3(0), outerDodecahedronCircumradius);\n\n    bool hit = false;\n    \n    if(s.x > 0. && s.x < s.y)\n    {\n        t = s.x;\n        \n        for(int i = 0; i < 60; ++i)\n        {\n            vec3 rp = ro + rd * t;\n            // Instead of the usual \"divide by length of gradient\", here the gradient along\n            // the ray is computed directly.\n            Dual res = dBarthSextic(dAdd(dConst(rp.x), dLinear(rd.x)),\n                                    dAdd(dConst(rp.y), dLinear(rd.y)),\n                                    dAdd(dConst(rp.z), dLinear(rd.z)));\n            if(t >= s.y)\n                break;\n                \n            if(res.f > -2e-6)\n            {\n                hit = true;\n                break;\n            }\n#if USE_NEWTON\n            // Newton: x = x - f(x) / f'(x)\n            t += min(.25, abs((res.f) / (res.d.x)));\n#else\n            // Halley: x = x - 2f(x)f'(x) / (2(f'(x)²) - f(x)f''(x))\n            t += min(.25, abs(2. * res.f * res.d.x / (2. * res.d.x * res.d.x - res.f * res.d.y)));\n#endif\n        }\n    }\n    \n    vec3 col = vec3(.06);\n\n    if(hit)\n    {\n        vec3 rp = ro + rd * t;\n        \n        // Surface normal from gradient of scalar field.\n        Dual res_x = dBarthSextic(dAdd(dConst(rp.x), dLinear(1.)),\n                                  dAdd(dConst(rp.y), dLinear(0.)),\n                                  dAdd(dConst(rp.z), dLinear(0.)));\n        Dual res_y = dBarthSextic(dAdd(dConst(rp.x), dLinear(0.)),\n                                  dAdd(dConst(rp.y), dLinear(1.)),\n                                  dAdd(dConst(rp.z), dLinear(0.)));\n        Dual res_z = dBarthSextic(dAdd(dConst(rp.x), dLinear(0.)),\n                                  dAdd(dConst(rp.y), dLinear(0.)),\n                                  dAdd(dConst(rp.z), dLinear(1.)));\n        vec3 n = normalize(vec3(res_x.d.x, res_y.d.x, res_z.d.x));\n\n        // Base surface colour\n        vec3 diff = vec3(.4, 1., .7);\n        diff = mix(diff, diff * .75, mod(floor(rp.x * 4.) + floor(rp.y * 4.) + floor(rp.z * 4.), 2.));\n        \n        \n        // Basic lighting\n        \n        float fr = mix(.01, 1., pow(1. - clamp(dot(rd, n), 0., 1.), 2.));\n        vec3 r = reflect(-rd, n);\n\n        vec3 l = normalize(vec3(1));\n        col = diff * (dot(l, -n) * .5 + .5) * (1. - fr) * vec3(1., 1., .9);\n        col += diff * mix(.25, 1., (dot(vec3(0,-1,0), -n) * .5 + .5) * (1. - fr)) * vec3(.2,.2,.4);\n        col += smoothstep(.5, 1., max(0., dot(-r, l))) * fr * 1.1;\n    }\n    \n    return clamp(col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n        {\n            col += traceRay(fragCoord + vec2(x, y) / float(AA));\n        }\n\n    col /= float(AA) * float(AA);\n\n    fragColor = vec4(sqrt(col), 1.);\n}","name":"Image","description":"","type":"image"}]}