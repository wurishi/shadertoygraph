{"ver":"0.1","info":{"id":"Mc2fzy","date":"1725148635","viewed":14,"name":"Inverted 'Brot","username":"c0rymcg","description":"Pretty straightforward, but I thought it was fun. Mandelbrot set inverted around a circle whose center can shift.\nUse the mouse to control where that circle is.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["template"],"hasliked":0,"parentid":"fdXBzr","parentname":"fractal code template"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TAU 6.28318\n#define maxIterations 100\n#define AA 2\n\n\nvec2 cMult(vec2 c1, vec2 c2){\n   //complex mult\n    float newR = c1.x*c2.x - c1.y*c2.y;\n\tfloat newI = c1.y*c2.x + c1.x*c2.y;\n\treturn vec2(newR,newI);\n}\nvec2 cDivide(vec2 c1, vec2 c2){\n\t//conjugate = a - bi;\n\t//to divide, multiply both sides by complex conjugate of denom\n\n\tfloat divisor = dot(c2,c2);\n\t\n\treturn vec2((c1.x*c2.x + c1.y*c2.y)/divisor, (c1.y*c2.x - c1.x*c2.y)/divisor);\n}\nvec2 cPow(vec2 z, float p){\n    if (p==1.) return z;\n\tfloat radius = sqrt(z.x*z.x + z.y*z.y);\n\tfloat theta = atan(z.y,z.x);\n\tfloat newR = pow(radius, p);\n\treturn vec2(newR * cos(theta*p), newR * sin(theta*p));\n}\nvec2 cPow(vec2 c1, vec2 c2){\n    return vec2(0);\n}\n\nvec2 f1(vec2 z, vec2 c) {\n    return cMult(z,z) + c;///mandelbrot\n    \n}\n\nvec3 palette(float loc, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( TAU*(c*loc+d) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 aacol=vec3(0.);\n    float time = iTime;\n    \n    //aa code\n    for (int aax=0; aax<AA; aax++){\n    for (int aay=0; aay<AA; aay++){\n        \n        vec2 z = vec2(0.);\n    \n        vec2 uv = (fragCoord + vec2(aax,aay)/float(AA))/iResolution.xx;\n        uv -= 0.5;uv *= 2.3;uv += 0.5;\n        \n        float zoom = 3.;\n        \n        \n        vec2 c = vec2(zoom * (uv.x - 0.5), zoom * (uv.y - 0.22));\n        vec2 offset=vec2(sin(iTime/4.),cos(0.2*iTime/7.));\n        \n        if(iMouse.z>0.){\n            vec2 mPos = iMouse.xy/iResolution.xx;\n            mPos -= 0.5; mPos *= 1.3; mPos += 0.5;\n            mPos=zoom*(mPos-vec2(0.5,0.22));\n            offset=mPos;\n            \n        }\n        c+=offset;\n        float tao = atan(c.y, c.x);\n        float rho = length(c);\n         rho=1./rho;//circle invert\n        c = vec2(cos(tao)*rho,sin(tao)*rho) - offset;\n\n\n        \n        z = c;\n/*\n//julia mode\n        if(iMouse.z>0.){\n            vec2 mPos = iMouse.xy/iResolution.xx;\n            mPos -= 0.5; mPos *= 1.3; mPos += 0.5;\n            mPos=zoom*(mPos-vec2(0.5,0.22));\n            offset=mPos;\n        }\n*/       \n        \n        bool escaped = false;\n            \n        int i = 0;\n        float sum = 0.;\n        \n        //iterate\n        \n        for (i = 0; i < maxIterations; i++) {\n          z = f1(z,c);\n          sum+=max(0.,5.-length(z));\n          if (length(z)>50.) {\n              escaped=true;\n              \n          }\n        }\n\t\t\n    \n        vec3 iterationCol = vec3(palette(sum/20., vec3(0.5),vec3(0.5),vec3(1.0, 1.0, 0.0),vec3(0.3, 0.2, 0.2)));\n\t\tif (!escaped)iterationCol=iterationCol*0.8 -0.3;\n        aacol+= iterationCol;\n    }\n    }\n    fragColor=vec4(aacol.xyz/4.,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}