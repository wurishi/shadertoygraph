{"ver":"0.1","info":{"id":"4dVcD1","date":"1521973327","viewed":1096,"name":"Game HP UI","username":"FishMan","description":"a game HP (health point) ui effect","likes":44,"published":1,"flags":0,"usePreview":0,"tags":["2d","game","wave","bubble","ui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a sunny day of sea - by JiepengTan - 2018\n// jiepengtan@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define  SIZE  0.5\n#define WATER_DEEP 0.6\n#define PI 3.1415927\n#define Deg2Radius PI/180.\n\nfloat Rand(float x)\n{\n    return fract(sin(x*866353.13)*613.73);\n}\n\nmat2 Rotate2D(float deg){\n    deg = deg * Deg2Radius;\n\treturn mat2(cos(deg),sin(deg),-sin(deg),cos(deg));\n}\nvec2 Within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/(rect.zw-rect.xy);\n}\nfloat Remap(float a,float b,float c,float d,float val){\n\treturn (val-a)/(b-a) * (d-c) + c;\n}\n\nfloat Circle(vec2 uv,vec2 center,float size,float blur){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat len = length(uv);\n\treturn smoothstep(1.,1.-blur,len);\n}\n\nfloat PureCircle(vec2 uv,vec2 center,float size,float blur,float powVal){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat len = 1.-length(uv);\n    float val = clamp(Remap(0.,blur,0.,1.,len),0.,1.);\n    return pow(val,powVal);//* pow(1.+len * 3.,0.1);\n}\nfloat Ellipse(vec2 uv,vec2 center,vec2 size,float blur){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat len = length(uv);\n\treturn smoothstep(1.,1.-blur,len);\n}\n\n\nvec3 Draw3DFrame(vec2 uv){\n    //cameraPos  \n    vec3 camPos = vec3(0.,0.,-3);\n    //Torus \n\tvec3 frameCol = vec3(0.9,0.75,0.6);\n    float frameMask = Circle(uv,vec2(0.,0.),SIZE*1.1,0.01) - \n        Circle(uv,vec2(0.,0.),SIZE,0.01);\n    return vec3(0.);\n    \n}\nfloat Torus2D(vec2 uv,vec2 center,vec2 size,float blur){\n\tuv = uv - center;\n\tfloat len = length(uv);\n    if(len<size.y || len >size.x)\n        return 0.;\n    float radio = (len-size.y)/(size.x-size.y);\n    float val = 1.-abs((radio-0.5)*2.);\n\treturn pow(val,blur);\n}\n\nvec3 DrawFrame(vec2 uv){\n    vec3 frameCol = vec3(0.9,0.75,0.6);\n    float frameMask = Circle(uv,vec2(0.,0.),SIZE*1.1,0.01) - \n        Circle(uv,vec2(0.,0.),SIZE,0.01);\n    //return frameCol * frameMask;\n    return Torus2D(uv,vec2(0.,0.),vec2(SIZE * 1.1,SIZE),0.2) *frameCol;\n}\nvec3 DrawHightLight(vec2 uv){\n    //up\n    vec3 hlCol = vec3(0.95,0.95,0.95);\n    float upMask = Ellipse(uv,vec2(0.,0.8)*SIZE,vec2(0.9,0.7)*SIZE,0.6)*0.9;\n    upMask = upMask * Circle(uv,vec2(0.,0.)*SIZE,SIZE*0.95,0.02) ;\n    upMask = upMask * Circle(uv,vec2(0.,-0.9)*SIZE,SIZE*1.1,-0.8) ;\n    //bottom\n    uv *= Rotate2D(30.);\n    float btMask =1.;\n    btMask *=  Circle(uv,vec2(0.,0.)*SIZE,SIZE*0.95,0.02);\n    float scale = 0.9;\n    btMask *= 1.- Circle(uv,vec2(0.,-0.17+scale)*SIZE,SIZE*(1.+scale),0.2) ;\n    return  (upMask + btMask) * hlCol;\n    \n}\n\n\nfloat GetWaveHeight(vec2 uv){\n    uv = Rotate2D(-30.)*uv;\n\tfloat wave =  0.12*sin(-2.*uv.x+iTime*4.); \n\tuv = Rotate2D(-50.)*uv;\n\twave +=  0.05*sin(-2.*uv.x+iTime*4.); \n\treturn wave;\n}\n\nfloat RayMarchWater(vec3 camera, vec3 dir,float startT,float maxT){\n    vec3 pos = camera + dir * startT;\n    float t = startT;\n    for(int i=0;i<200;i++){\n        if(t > maxT){\n        \treturn -1.;\n        }\n        float h = GetWaveHeight(pos.xz) * WATER_DEEP;\n        if(h + 0.01 > pos.y ) {//+ 0.01 acc intersect speed\n            // get the intersect point\n            return t;\n        }\n        t += pos.y - h; \n        pos = camera + dir * t;\n    }\n    return -1.0;\n}\n\nvec4 SimpleWave3D(vec2 uv,vec3 col){\n\tvec3 camPos =vec3(0.23,0.115,-2.28);\n    vec3 targetPos = vec3(0.);\n    \n    vec3 f = normalize(targetPos-camPos);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 ray = normalize(uv.x*r+uv.y*u+1.0*f);\n    \n\tfloat startT = 0.1;\n    float maxT = 20.;\n\tfloat dist = RayMarchWater(camPos, ray,startT,maxT);\n    vec3 pos = camPos + ray * dist;\n\t//only need a small circle\n    float circleSize = 2.;\n    if(dist < 0.){\n    \treturn vec4(0.,0.,0.,0.);\n    }\n    vec2 offsetPos = pos.xz;\n    if(length(offsetPos)>circleSize){\n    \treturn vec4(0.,0.,0.,0.);\n    }\n    float colVal = 1.-((pos.z+0.)/circleSize +1.0) *.5;//0~1\n\treturn vec4(col*smoothstep(0.,1.4,colVal),1.);\n}\nfloat SmoothCircle(vec2 uv,vec2 offset,float size){\n    uv -= offset;\n    uv/=size;\n    float temp = clamp(1.-length(uv),0.,1.);\n    return smoothstep(0.,1.,temp);\n}\nfloat DrawBubble(vec2 uv,vec2 offset,float size){\n    uv = (uv - offset)/size;\n    float val = 0.;\n    val = length(uv);\n    val = smoothstep(0.5,2.,val)*step(val,1.);\n    \n    val +=SmoothCircle(uv,vec2(-0.2,0.3),0.6)*0.4;\n    val +=SmoothCircle(uv,vec2(0.4,-0.5),0.2)*0.2;\n\treturn val; \n}\nfloat DrawBubbles(vec2 uv){\n\tuv = Within(uv, vec4(-SIZE,-SIZE,SIZE,SIZE));\n    uv.x-=0.5;\n    float val = 0.;\n    const float count = 2.;// bubble num per second\n    const float maxVY = 0.1;\n    const float ay = -.3;\n    const  float ax = -.5;\n    const  float maxDeg = 80.;\n    const float loopT = maxVY/ay + (1.- 0.5*maxVY*maxVY/ay)/maxVY;\n    const  float num = loopT*count;\n    for(float i=1.;i<num;i++){\n    \tfloat size = 0.02*Rand(i*451.31)+0.02;\n        float t = mod(iTime + Rand(i)*loopT,loopT);\n        float deg = (Rand(i*1354.54)*maxDeg +(90.-maxDeg*0.5))*Deg2Radius;\n        vec2 vel = vec2(cos(deg),sin(deg));\n        float ty = max((vel.y*0.3 - maxVY),0.)/ay;\n        float yt = clamp(t,0.,ty);\n\t\tfloat y = max(0.,abs(vel.y)*yt + 0.5*ay*yt*yt) + max(0.,t-ty)*maxVY;\n        \n        float tx = abs(vel.x/ax);\n        t = min(tx,t);\n        float xOffset = abs(vel.x)*t+0.5*ax*t*t + sin(iTime*(0.5+Rand(i)*2.)+Rand(i)*2.*PI)*0.03;\n        float x = sign(vel.x)*xOffset;\n        vec2 offset = vec2(x,y);\n    \tval += DrawBubble(uv,offset,size*0.5);\n    }\n\treturn val;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float hpPer = sin(iTime*0.2)*0.2+0.5;\n    vec3 waterCol = vec3(0.5)+vec3(0.5)*cos(2.*PI*(vec3(1.)*iTime*0.1+vec3(0.,0.33,0.67)));\n    \n\tvec2 uv = (fragCoord/iResolution.xy - 0.5)*iResolution.xy/iResolution.y*2.;\n    vec3 col = vec3(0.,0.,0.);//final color \n\t//draw 3D frame\n    col += DrawFrame(uv);\n    \n    //draw base water\n    float hpPerMask = step(0.,(hpPer *2. -1.)*SIZE - uv.y);\n  \tfloat bgMask = 0.;\n    bgMask += PureCircle(uv,vec2(0.,0.),SIZE*1.1,.9,0.9);\n \tbgMask += Circle(uv,vec2(0.,0.),SIZE,.6)*0.2;\n    col += bgMask * waterCol *hpPerMask ;\n    \n    //draw wave\n    float waterMask = step(length(uv),SIZE);\n    float offset = hpPer -0.5+0.01;\n    float wavePicSize = 0.8*SIZE;\n    vec2 remapUV = Within(uv,vec4(0.,offset,wavePicSize,offset+wavePicSize-0.2));\n    vec4 wave = SimpleWave3D(remapUV,waterCol);\n    col = mix(col,wave.xyz*bgMask,wave.w*waterMask);\n\t\n    //draw bubbles\n    float bubbleMask = smoothstep(0.,0.1,(hpPer *2. -1.2)*SIZE - uv.y);\n    col+= DrawBubbles(uv)*vec3(1.)* bubbleMask*waterMask;\n    //draw hight light\n    col += DrawHightLight(uv*1.);\n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}