{"ver":"0.1","info":{"id":"dl33DS","date":"1683114720","viewed":22,"name":"HW Assignment Tarlan Ahadli","username":"tarlanahad","description":"Pyramid with the eye. Moving planet around","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = 2.0 * texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Define the number of materials in the scene\nconst int materialNo = 5;\n// Create an array of materials\nMaterial materials[materialNo];\n\n// Define the number of planes in the scene\nconst int planeNo = 1;\n// Create an array of planes\nPlane planes[planeNo];\n\n// Define the number of spheres in the scene\nconst int spheresNo = 3;\n// Create an array of spheres\nSphere spheres[spheresNo];\n\n// Define the number of triangles in the scene\nconst int triangleNo = 4;\n// Create an array of triangles\nTriangle triangles[triangleNo];\n\n// Define the number of lights in the scene\nconst int lightsNo = 2;\n// Create an array of lights\nLight lights[lightsNo];\n\n// Define the maximum size of the reflection and refraction stack\nconst int stackSize = 16;\n// Define the maximum distance a ray can travel in the scene\nconst float Tmax = 500.0;\n\n// ---- CAMERA and EVENTS ----\n\n// Define common key codes for user input (WASD keys for movement)\nconst int KeyLeft = 65;\nconst int KeyRight = 68;\nconst int KeyUp = 87;\nconst int KeyDown = 83;\n\n// Define a function to check if a key is held down\n#define isKeyHeld(k)(texelFetch(iChannel1, ivec2(k, 0), 0).x > 0.)\n\n// Set the initial camera position\nconst vec3 EyeStartPosition = vec3(-50.0, 1.0, 20.0);\n\n// Function for handling camera movement and generating rays from the camera\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2) {\n    // Get the camera position from a texture and add the starting position\n    eye = texelFetch(iChannel0, ivec2(0, 0), 0).yzw + EyeStartPosition;\n    // Get the spherical coordinates of the camera direction from a texture\n    data2 = texelFetch(iChannel0, ivec2(1, 0), 0).zw;\n    vec2 uv = abs(data2);\n\n    // If the mouse button is held down or was held down last frame\n    if (iMouse.z > 0.0 || data2.x >= 0.0)\n        // Update the camera direction based on mouse movement\n        uv += (abs(iMouse.zw) - abs(iMouse.xy)) * 0.01;\n\n    // Calculate the camera's forward, right, and up vectors\n    vec3 w = vec3(cos(uv.x) * cos(-uv.y), sin(-uv.y), sin(uv.x) * cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n\n    // Normalize the screen coordinates and scale by the aspect ratio\n    vec2 px = (fragCoord / iResolution.xy * 2.0 - 1.0) * 1.0 * normalize(iResolution.xy);\n\n    // Handle keyboard input for camera movement\n    float speed = 0.2;\n    if (isKeyHeld(KeyLeft)) eye -= u * speed;\n    if (isKeyHeld(KeyRight)) eye += u * speed;\n    if (isKeyHeld(KeyUp)) eye += w * speed;\n    if (isKeyHeld(KeyDown)) eye -= w * speed;\n\n    // Update the camera direction based on mouse input\n    if (iMouse.z >= 0.0) // Mouse held\n        data2 = abs(data2.xy);\n    else if (data2.x >= 0.0) // Mouse released\n        data2 = -mod(uv, 2.0 * 3.14159);\n\n    // Generate a ray from the camera position in the direction of the pixel being shaded\n    return Ray(eye, 0.5, normalize(w + px.x * u + px.y * v), 500.0);\n}\n\n// ---- MAIN ----\n\n// Define the maximum distance a ray can travel before being considered a miss\nconst float maxT = 1000.0;\n\n// Function for checking ray-triangle intersections\n// Möller–Trumbore intersection algorithm\nTraceResult intersectTriangle(Ray ray, Triangle t) {\n    // Calculate edge vectors of the triangle\n    vec3 ab = t.b - t.a;\n    vec3 ac = t.c - t.a;\n    vec3 ap = ray.p0 - t.a;\n\n    // Calculate auxiliary vectors for intersection calculation\n    vec3 f = cross(ray.v, ac);\n    vec3 g = cross(ap, ab);\n\n    // Calculate the coefficients for the barycentric coordinates\n    float coeff = 1.0 / dot(f, ab);\n\n    // Calculate the barycentric coordinates\n    float t0 = coeff * dot(g, ac);\n    float u0 = coeff * dot(f, ap);\n    float v0 = coeff * dot(g, ray.v);\n\n    // Calculate the normal of the triangle\n    vec3 n = -normalize(cross(ab, ac));\n\n    // Check if the intersection point lies within the triangle\n    if (t0 >= 0.0 && u0 >= 0.0 && v0 >= 0.0 && 1.0 - u0 - v0 >= 0.0)\n        return TraceResult(t.id, n, t0);\n    else\n        return TraceResult(t.id, vec3(0), ray.tmax); // No intersection\n\n}\n\n// Function for checking ray-sphere intersections\nTraceResult intersectSphere(Ray ray, Sphere s) {\n    // Calculate the vector from the ray origin to the sphere center\n    vec3 p0c = ray.p0 - s.c;\n    // Calculate the quadratic coefficients for the intersection calculation\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c, p0c) - s.r * s.r;\n    // Calculate the discriminant of the quadratic equation\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n        return TraceResult(s.id, vec3(0), ray.tmax); // No intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if (numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(s.id, normal, t);\n}\n\n// Function for checking ray-plane intersections\nTraceResult intersectPlane(Ray ray, Plane p) {\n    float t = dot(p.q0 - ray.p0, p.n) / dot(ray.v, p.n);\n    return TraceResult(p.id, p.n, t);\n}\n\n// Function for casting rays and finding the nearest intersection with objects in the scene\nTraceResult raycast(Ray ray) {\n    TraceResult res = TraceResult(-1, vec3(0), ray.tmax);\n\n    for (int i = 0; i < planeNo; ++i) {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if (res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t) {\n            res = res2;\n        }\n    }\n    // Check for intersections with spheres\n    for (int i = 0; i < spheresNo; ++i) {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if (res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t) {\n            res = res2;\n        }\n    }\n\n    // Check for intersections with triangles\n    for (int i = 0; i < triangleNo; ++i) {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if (res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t) {\n            res = res2;\n        }\n    }\n\n    return res;\n}\n\n// Function for determining the color of a ray that misses all objects in the scene\nvec4 missColor(Ray ray) {\n    // Sample the environment texture based on the ray direction\n    return vec4(texture(iChannel2, ray.v).xyz, 1.0);\n}\n\nvec4 hitColorHelper(Ray ray, TraceResult traceResult, Light light) {\n    vec3 intersectionPoint = ray.p0 + ray.v * traceResult.t;\n    vec3 viewDirection = -ray.v;\n    vec3 lightDirection = light.position - intersectionPoint;\n    float lightDistance = length(lightDirection);\n    lightDirection /= lightDistance;\n\n    Ray shadowRay = Ray(intersectionPoint + 0.001 * traceResult.n, 0.01, lightDirection, lightDistance - 0.01);\n    TraceResult shadowTraceResult = raycast(shadowRay);\n    if (shadowTraceResult.t < shadowRay.tmax) {\n        return vec4(0.0); // Return black color for shadowed areas\n    }\n\n    Material material = materials[traceResult.id];\n    vec3 radiance = vec3(1.0);\n    float specular = 0.0;\n    float diffuse = 0.0;\n    vec3 surfaceNormal = traceResult.n;\n    vec3 reflectedRay = -reflect(ray.v, traceResult.n);\n    vec3 halfVector = normalize(viewDirection + lightDirection);\n    float normalHalfVectorDot = max(dot(surfaceNormal, halfVector), 0.0);\n    float halfVectorViewDot = max(dot(halfVector, viewDirection), 0.0);\n    float normalDistribution = NormalDistribution(normalHalfVectorDot, material.roughness);\n    float smithGeometry = SmithGeometry(surfaceNormal, viewDirection, lightDirection, material.roughness);\n    float fresnel = pow(1.0 - halfVectorViewDot, 5.0) * (1.0 - material.reflectivness) + material.reflectivness;\n    \n    specular = min(normalDistribution * smithGeometry * fresnel / 4.0, 1.0);\n    diffuse = (1.0 - fresnel) * max(dot(-reflectedRay, lightDirection), 0.0);\n    \n    vec3 color = (specular * material.metalness + diffuse * (1.0 - material.metalness)) * radiance;\n    \n    return vec4(color * radiance + material.emission, 1.0);\n}\n\nvec4 hitColor(Ray ray, TraceResult tr) {\n    // Initialize remaining distance for ray tracing\n    float remainDist = Tmax;\n\n    // Initialize the stack for handling reflection and refraction\n    \n    ReflRefrStackElement stack[stackSize];\n\n    // Push the initial intersection and ray onto the stack\n    stack[0] = ReflRefrStackElement(tr, ray, vec3(1.0), false);\n  \n    int head = 0;\n    // Initialize the result color and number of lights\n    vec4 result = vec4(0.0);\n    float numberOfLights = 1.0;\n\n    // Perform ray tracing iterations using a stack-based approach\n    do {\n        // Pop the top element from the stack\n        ReflRefrStackElement el = stack[head--];\n        // Update the intersection and ray information\n        tr = el.tr;\n        ray = el.ray;\n        bool inside = el.inside;\n\n        // Retrieve the factor (accumulated material color) from the stack element\n        vec3 factor = el.factor;\n        if (length(factor) == 0.0)\n            continue;\n\n        // Retrieve the material of the intersected object\n        Material mat = materials[tr.id];\n\n        // Compute the intersection point\n        vec3 pp = ray.p0 + ray.v * tr.t;\n\n        // Update the remaining distance for ray tracing\n        remainDist -= tr.t;\n        if (remainDist <= 0.0) {\n            // If remaining distance is exhausted, add the miss color to the result\n            result += missColor(ray);\n            numberOfLights++;\n            break;\n        }\n\n        // Add emission color of the material to the result\n        result += vec4(mat.emission * factor, 1.0);\n\n        // Iterate over all light sources\n        for (int l = 0; l < lightsNo; l++) {\n            Light light = lights[l];\n            // Compute the contribution of the current light source\n            numberOfLights += light.intensity * mat.opacity * (1.0 - mat.reflectivness);\n            result += hitColorHelper(ray, tr, light) * mat.opacity * (1.0 - mat.reflectivness) * vec4(factor, 1.0) * light.intensity * vec4(light.color * mat.color, 1.0);\n        }\n\n        // Compute the reflected ray\n        if (mat.reflectivness != 0.0 && !inside) {\n            Ray reflectedRay = Ray(pp + 0.01 * normalize(tr.n), 0.01, reflect(ray.v, tr.n), remainDist);\n            TraceResult reflectedTr = raycast(reflectedRay);\n            if (reflectedTr.t < remainDist)\n                // Push the reflected intersection and ray onto the stack with modified factor\n                stack[++head] = ReflRefrStackElement(reflectedTr, reflectedRay, mat.opacity * mat.reflectivness * factor * mat.color, inside);\n            else {\n                // If reflected ray misses, add the miss color multiplied by reflectiveness and factor to the result\n                result += missColor(reflectedRay) * vec4(mat.color, 1.0) * mat.reflectivness * vec4(factor, 1.0);\n            }\n        }\n\n        // Compute the refracted ray\n        // Check whether the stack is full\n        if (stackSize <= head)\n            continue;\n\n        if (mat.opacity != 1.0) {\n            vec3 n = -normalize(tr.n * dot(tr.n, ray.v));\n\n            float eta = 1.0 / mat.indice;\n            if (inside)\n                eta = 1.0 / eta;\n\n            Ray refractedRay = Ray(pp - n * 0.001, 0.01, refract(normalize(ray.v), n, eta), remainDist);\n            TraceResult refractedTr = raycast(refractedRay);\n\n            if (refractedTr.t < remainDist)\n                // Push the refracted intersection and ray onto the stack with modified factor\n                stack[++head] = ReflRefrStackElement(refractedTr, refractedRay, (1.0 - mat.opacity) * factor * mat.color, !inside);\n            else {\n                // If refracted ray misses, add the miss color multiplied by (1-opacity) and factor to the result\n                result += missColor(refractedRay) * vec4(mat.color, 1.0) * (1.0 - mat.opacity) * vec4(factor, 1.0);\n            }\n        }\n\n    } while (head >= 0);\n\n    // Calculate the final result by dividing the accumulated color by the number of lights\n    return  result / numberOfLights;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Define the light sources in the scene\n    lights[0] = Light(vec3(0.0, 100.0, -200.0), vec3(1.0, 1.0, 1.0), 10000.0);\n    lights[1] = Light(vec3(0.0, 200.0, 200.0), vec3(1.0, 1.0, 1.0), 10000.0);\n\n    // Define the materials of the objects in the scene\n    materials[0] = Material(vec3(0.9, 0.8, 0.6), 7.0, vec3(0.0), 0.02, 0.0, 1.0, 1.5); // Sand Color\n    materials[1] = Material(vec3(1.0, 1.0, 1.0), 0.2, vec3(0.0), 0.5, 1.0, 1.0, 1.5); // Shiny white\n    materials[2] = Material(vec3(0.7, 0.4, 0.2), 7.0, vec3(0.0), 0.02, 0.0, 1.0, 1.5); // Pyramid color\n    materials[3] = Material(vec3(0.2, 0.4, 0.8), 0.3, vec3(0.0, 0.0, 0.0), 0.5, 1.0, 1.0, 1.0); // Shiny blue\n    materials[4] = Material(vec3(0.9, 0.9, 0.9), 0.1, vec3(0), 0.0, 0.2, 0.5, 1.0);\n\n    // Define the moving planet in the scene\n    vec3 rotationCenter = vec3(0.0, 10.0, 15.0);\n    float rotationRadius = 2.0;\n    float rotationSpeed = 1.0;\n    float rotationAngle = iTime * rotationSpeed;\n    vec3 spherePosition = rotationCenter + rotationRadius * vec3(cos(rotationAngle), cos(rotationAngle*2.0), sin(rotationAngle));\n\n    // Set up the objects in the scene\n    spheres[2] = Sphere(4, spherePosition, 0.5);\n    planes[0] = Plane(0, vec3(0), normalize(vec3(0, 1, 0))); // Sand\n\n    Pyramid pyr = createPyramid(2, vec3(0.0, 0.0, 15.0), 10.0, 10.0);\n    for (int i = 0; i < 4; ++i) {\n        triangles[i] = pyr.triangles[i];\n    }\n\n    // Set up the other objects in the scene\n    spheres[0] = Sphere(1, vec3(-0.8, 8, 15), 0.5); // White Ball\n    spheres[1] = Sphere(3, vec3(-1.2, 8.0, 15), 0.2); // Blue Eye\n\n    // Define variables for the eye position and additional data\n    vec3 eye;\n    vec2 data;\n\n    // Generate a ray from the current pixel coordinate and update the eye position and data\n    Ray ray = Camera(fragCoord, eye, data);\n\n    // Perform ray tracing to find the intersection of the ray with objects in the scene\n    TraceResult result = raycast(ray);\n\n    // If the ray does not hit any objects, set the fragment color to the miss color\n    if (ray.tmax <= result.t)\n        fragColor = missColor(ray);\n    else\n        // If the ray hits an object, compute the final color using the hitColor function\n        fragColor = hitColor(ray, result);\n\n    // Apply motion blur by blending the previous fragment color with the current color\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3 * prev + 0.7 * fragColor;\n    fragColor.w = result.t;\n\n    // The first two pixels are reserved for special purposes\n    if (fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye - EyeStartPosition;\n\n    if (fragCoord.x == 1.5 && fragCoord.y == 0.5) // pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Define a constant for pi\nconst float pi = 3.1415926535897932384626433832795;\n\n// Define a Material structure containing properties for shading\nstruct Material {\n    vec3 color; // Base color of the material, with values between [0,1/pi]\n    float roughness; // Surface roughness, with values between [0,~7]\n    vec3 emission; // Ambient color for emission, with values between [0, inf]\n    float metalness; // Metalness factor, 0.02-0.05 for non-metals, 0.6-0.9 for metals\n    \n    float reflectivness; // Reflectivity of the material\n    float opacity; // Opacity of the material\n    float indice; // Refractive index of the material\n};\n\n// Define a Sphere structure for representing spheres in the scene\nstruct Sphere\n{\n    int id;   // ID of the material for this sphere\n    vec3 c;   // Center of the sphere\n    float r;  // Radius of the sphere\n};\n\n// Define a Plane structure for representing planes in the scene\nstruct Plane\n{\n    int id;  // ID of the material for this plane\n    vec3 q0; // Any point on the plane\n    vec3 n;  // Normal of the plane\n};\n\n// Define a Triangle structure for representing triangles in the scene\nstruct Triangle\n{\n    int id; // ID of the material for this triangle\n    vec3 a; // Vertex A of the triangle\n    vec3 b; // Vertex B of the triangle\n    vec3 c; // Vertex C of the triangle\n};\n\n// Define a Pyramid structure containing an array of triangles\nstruct Pyramid {\n    Triangle[4] triangles;\n};\n\n// Function to create a pyramid using an ID, base center, base size, and height\nPyramid createPyramid(int id, vec3 baseCenter, float baseSize, float height)\n{\n    // Calculate the base corner points\n    vec3 baseA = baseCenter + vec3(-baseSize / 2.0, 0.0, -baseSize / 2.0);\n    vec3 baseB = baseCenter + vec3(baseSize / 2.0, 0.0, -baseSize / 2.0);\n    vec3 baseC = baseCenter + vec3(baseSize / 2.0, 0.0, baseSize / 2.0);\n    vec3 baseD = baseCenter + vec3(-baseSize / 2.0, 0.0, baseSize / 2.0);\n\n    // Calculate the top position using height\n    vec3 top = baseCenter + vec3(0.0, height, 0.0);\n\n    // Create the four triangles that make up the pyramid\n    Triangle faceA = Triangle(id, top, baseA, baseB);\n    Triangle faceB = Triangle(id, top, baseB, baseC);\n    Triangle faceC = Triangle(id, top, baseC, baseD);\n    Triangle faceD = Triangle(id, top, baseD, baseA);\n\n    Triangle[4] tris = Triangle[] (faceA,faceB,faceC,faceD);\n    return Pyramid(tris);\n}\n\n// Define a Ray structure for representing rays in the scene\nstruct Ray\n{\n    vec3 p0;    // Ray origin if tmin=0\n    float tmin; // Omit solutions t<tmin\n    vec3 v;     // Direction of the ray\n    float tmax; // Omit solutions t>tmax\n};\n\n// Define a TraceResult structure for storing the results of ray-object intersections\nstruct TraceResult\n{\n    int id; // ID of the intersected object's material\n    vec3 n; // Normal vector on the surface at the intersection point\n    float t; // Distance traveled along the ray to reach the intersection\n};\n\n// Define a Light structure for representing light sources in the scene\nstruct Light {\n    vec3 position; // Position of the light source\n    vec3 color; // Color of the light\n    float intensity; // Intensity of the light\n};\n\n// Define a ReflRefrStackElement structure for storing reflection and refraction information\nstruct ReflRefrStackElement {\n    TraceResult tr; // TraceResult of the ray-object intersection\n    Ray ray; // Ray that caused the intersection\n    vec3 factor; // Accumulated color factor\n    bool inside; // Whether the ray is inside an object or not\n};\n\n// Common shading functions\n\n// Normal distribution function used in PBR (Physically-Based Rendering) calculations\n// See: https://learnopengl.com/PBR/Theory\n\n// specularity based on roughness\nfloat NormalDistribution(float NH, float roughness) {\n    float alpha = roughness * roughness;\n    float sqAlpha = alpha * alpha;\n    float denominator = NH * NH * (sqAlpha - 1.f) + 1.f;\n    float sqDenominator = denominator * denominator;\n    return sqAlpha / max(pi * sqDenominator, 0.00000001);\n}\n\n// Schlick Geometry function used in PBR calculations\n// See: https://learnopengl.com/PBR/Theory\nfloat SchlickGeometryGGX(float NV, float k) {\n    return NV / min(NV * (1. - k) + k, .00000001);\n}\n\n// Smith Geometry function used in PBR calculations\n// See: https://learnopengl.com/PBR/Theory\nfloat SmithGeometry(vec3 N, vec3 V, vec3 L, float k) {\n    \n    float NV = max(dot(N, V), 0.f);\n    float NL = max(dot(N, L), 0.f);\n    \n    float schlick1 = SchlickGeometryGGX(NV, k);\n    float schlick2 = SchlickGeometryGGX(NL, k);\n\n    return schlick1 * schlick2;\n}","name":"Common","description":"","type":"common"}]}