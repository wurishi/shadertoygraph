{"ver":"0.1","info":{"id":"MdcSzr","date":"1457410230","viewed":157,"name":"sphere raytrace tut by cabbibo","username":"amdbcg","description":"Sphere from cabbibo tutorial here :https://www.shadertoy.com/view/Xl2XWt <br/>","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["draftshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\n// tutorial from  https://www.shadertoy.com/view/Xl2XWt Thanks @Cabbibo! \n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 100;\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition){\n\tvec3 balloonPosition = vec3( .6, sin(t)*1.0, cos(t)*-0.8);\n    float balloonRadius = 1.1; \n    // get distance to surface of balloon \n    float distanceToBalloon = length (currentRayPosition- balloonPosition);\n\n    // finally we get the distance to the balloon surface\n  // by substacting the balloon radius. This means that if\n  // the distance to the balloon is less than the balloon radius\n  // the value we get will be negative! giving us the 'Signed' in\n  // Signed Distance Field!\n    \tfloat distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    // Robert :now we are on surface - picture a number line, radius in middle .\n    // |eye| ---------|r ---------/r |center|  eye - (center + r) will give us surface at r. \n    // give it an ID ? WTF? why? this goes in X? Does it need to be unique for every object? \n    // would it be best to create a hash or something to make object unique? \n    float balloonID = 1.0; \n    vec2 balloon = vec2(distanceToBalloonSurface, balloonID);\n    return balloon;\n    \n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\nvec2 sdfBox(vec3 currentRayPosition)\n{\n\tvec3 boxPosition= vec3 (-0.8,-0.4,0.28);\n    vec3 boxSize = vec3(abs(sin(0.3*t)), .2, 0.2);\n    \n     // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n    vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n      // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n    vec3 distanceVec = abs( adjustedRayPosition) - boxSize; // this returns a vec.xyz\n    // this gets the largest magnitude (distance) of the vectors\n    float maxDistance = max(distanceVec.x, max(distanceVec.y, distanceVec.z)) ;\n     //--->  IQ should explain this one , I will attempt below.  \n     // it looks like if maxDistance is > 0,\n     //. take 0.0, add to sqrt( max distanceVec.x^2 +distanceVec.y^2 + distanceVec.z^2)\n     // if maxDistance < 0.0 , take maxDistance (a negative , say -4)\n     // -4.0 + length( 0.0)  = -4, so the length is off, and the min distance is returned. \n     // That max and min stuff turns on and off parts of the function! \n     // it equates to a smooth if slightly obfuscated boolean (true/false) logic. \n     // distance To Surface  maxDistance , if negative, we are in the box, the unitsto get out of box in any direction \n     // is maxDistance,\n\t//  if maxDistance is >0.0 , positive, we are outside box,\n     //calculate the magnitude of the distance vector to get length needed until we hit the box. \n                            \n    float distanceToBoxSurface = sdTorus(distanceVec, vec2(0.6, 0.2));//min(maxDistance , 0.0 ) + length(max (distanceVec, 0.0) );\n    \n    float boxID = 2.;\n    vec2 box = vec2 ( distanceToBoxSurface, boxID); \n    return box;\n}\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 )\n{\n  vec2 closestThing = vec2(0.0,0.0); // I dispise null values ! \n    // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n    if(thing1.x <= thing2.x){\n    \n    \tclosestThing = thing1; \n    } else if (thing2.x <thing1.x){\n    \n    \tclosestThing = thing2;\n    }\n    return closestThing;\n    \n}\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld ( vec3 currentRayPosition)\n{\n\tvec2 result;\n    vec2 balloon = sdfBalloon( currentRayPosition);\n    vec2 box = sdfBox(currentRayPosition);\n    result = whichThingAmICloserTo(balloon, box);\n    return result; \n\n}\nvec2 checkRayHit( in vec3 eyePosition, in vec3 rayDirection)\n{\n\t//First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n    float distanceToSurface  \t= HOW_CLOSE_IS_CLOSE_ENOUGH *2.0;\n    float totalDistanceTraveledByRay = 0. ;\n    \n    // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n    float finalDistanceTraveledByRay = -1.0; \n    \n     // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n    float finalID = -1.;\n    \n     //here is the loop where the magic happens\n    for ( int i = 0 ; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE ; i++)\n    {\n        // First off, stop the iteration, if we are close enough to the surface!\n    \tif( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n        \n        // Second off, stop the iteration, if we have reached the end of our scene! \n    \tif( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n        \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n        vec3 currentPositionOfRay = eyePosition + rayDirection*totalDistanceTraveledByRay;\n    \n        // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n        vec2 distanceAndIDofThingsInTheWorld = mapTheWorld ( currentPositionOfRay);\n   \n    // reassign for clarity \n    float distanceToThingsInTheWorld = distanceAndIDofThingsInTheWorld.x;\n    float idOfClosestThingsInTheWorld = distanceAndIDofThingsInTheWorld.y;\n    \n    // we save out distance to the surface so that next iteration we can check to see if we\n    // are close enough to stop all this silly iteration. \n    distanceToSurface \t\t\t\t= distanceToThingsInTheWorld;\n    \n    finalID = idOfClosestThingsInTheWorld;\n    \n     // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += distanceToThingsInTheWorld;\n        \n    }\n// if we hit something set the finalDirastnce traveled by\n// ray to that distance!\n    if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH)\n    {\n      finalDistanceTraveledByRay = totalDistanceTraveledByRay;\n    }\n    // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n    if(totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH){\n    \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n        finalID= -1.; \n    }\n    \n    return vec2(finalDistanceTraveledByRay, finalID) ;\n    \n}\n\n\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll)\n{\n\tvec3 ww = normalize(ta- ro);\n    vec3 uu = normalize( cross(ww,vec3(sin(roll), cos(roll), 0.0 )));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3 (uu, vv, ww);\n}\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface.\nvec3 getNormalOfSurface ( in vec3 positionOfHit)\n{\n\tvec3 tinyChangeX = vec3(0.001,0.0,0.0);\n    vec3 tinyChangeY = vec3(0.0 , 0.001, 0.0);\n    vec3 tinyChangeZ  = vec3(0.0,0.0,0.001);\n    float upTinyChangeInX = mapTheWorld(positionOfHit +tinyChangeX).x;\n    float downTinyChangeInX = mapTheWorld(positionOfHit -tinyChangeX).x;\n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    float upTinyChangeInY = mapTheWorld(positionOfHit +tinyChangeY).x;\n    float downTinyChangeInY = mapTheWorld(positionOfHit -tinyChangeY).x;\n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    float upTinyChangeInZ = mapTheWorld(positionOfHit +tinyChangeZ).x;\n    float downTinyChangeInZ= mapTheWorld(positionOfHit -tinyChangeZ).x;\n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    vec3 normal = vec3(tinyChangeInX,\n                       tinyChangeInY,\n                       tinyChangeInZ\n                       );\n    return normalize(normal);\n    \n}\nvec3 doBackgroundColor(){\n\tvec3 color = vec3(0.0);;\n\treturn color;\n}\n\nvec3 doBalloonColor(vec3 positionOfHit, vec3 normalOfSurface ) \n{\n\tvec3 sunPosition = vec3(1. ,.4, 3.);\n    // direction light goes from sun to position of the hit:\n    vec3 lightDirection = sunPosition - positionOfHit; \n    \n    // Here we are normalizing the light direction\n    // because we don't care how long it is, we only care what direction it is. \n    lightDirection = normalize(lightDirection) ;\n    \n    // get the value of how much teh surface faces the light direction\n    float faceValue = dot( lightDirection, normalOfSurface) ; \n    \n    // if face value is negative just make it 0\n    // so it doesn't give back negative light values - in other words\n    // what happens if this is abs(faceValue) ? \n    faceValue = max(0. , faceValue);\n    \n    vec3 balloonColor = vec3(1., 0., 0.); // red\n    vec3 color = balloonColor * faceValue;\n    // balloon color multiplied by how much the surface faces the light.\n    //add ambient color so we don't get pure black\n     color += vec3 (.3, .1, .2);\n    \n    return color;\n}\n// maps a color to normal of surface\nvec3 doBoxColor( vec3 positionOfHit, vec3 normalOfSurface)\n{\n    \n\tvec3 color = vec3( normalOfSurface.x, normalOfSurface.y, normalOfSurface.z);\n         // could aslo just write color = normalOfSource , but being explicit here;\n    //color = ;\n    return color; \n}\n\n\n\nvec3 colorTheWorld( vec2 rayHitInfo, vec3 eyePosition, vec3 rayDirection)\n{\n\t// remember for color\n    // x = red, y = green, z = blue \n    vec3 color; \n    \n    // IF THE RAY WENT ALL THE WAY TO THE EDGE\n    // OF THE WORLD AND DID NOT HIT ANYTHING\n    if (rayHitInfo.y < 0.0){\n    \n    \tcolor = doBackgroundColor();\n        // THE RAY HIT SOMETHING!\n    } else{\n    \t// if we hit something, we know how far the ray had to travel. \n        vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n        // we can then use this info to tell what direction to surface faces in. \n        vec3 normalOfSurface = getNormalOfSurface (positionOfHit);\n        \n        // 1.0 is the balloon ID \n        if(rayHitInfo.y == 1.0){\n        \n        \tcolor = doBalloonColor( positionOfHit, normalOfSurface);\n            color *= textureProj(iChannel0, normalOfSurface.xyz).xyz;\n           \n            // this is the box 2.0 \n        }else if (rayHitInfo.y == 2.0){\n        \n        \t//color = doBoxColor(positionOfHit, normalOfSurface);\n            color = vec3( textureProj(iChannel1, vec3(sin(positionOfHit.x)*.1*sin(t) , cos(positionOfHit.y)*.1*cos(t) ,positionOfHit.z)));\n        }\n        \n        \n    }\n    return color;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy)/iResolution.y;\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    // use this to tell where the viewer is\n    vec3 eyePosition = vec3(0.,0.,2.);\n    vec3 pointWeAreLookingAt = vec3( 0. , 0., 0. );\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix(\n        eyePosition, pointWeAreLookingAt, 0.);\n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    \n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3(p.xy, 2.) );\n    \n     //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition, rayComingOutOfEyeDirection ); \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n   \tvec3 color = colorTheWorld( rayHitInfo, eyePosition, rayComingOutOfEyeDirection );  \n    \n    fragColor = vec4(color, 1.0);\n   \n}\n    \n","name":"Image","description":"","type":"image"}]}