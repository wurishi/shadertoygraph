{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"vec2 uv;\n\n// value Noise by iq\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat hash( vec2 n ) { return fract(sin(n.x) * 43758.5453123 - cos(n.y) * 63436.6509853); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\nfloat TraceSphere(vec3 pos, vec3 ray, vec3 c, float r)\n{\n\tc -= pos;\n\t\n\tfloat t = dot(c,ray);\n\t\n\tfloat p = length(c-t*ray);\n\tif ( p > r )\n\t\treturn 0.0;\n\t\n\treturn t-sqrt(r*r-p*p);\n}\n\n\nfloat sdSphere(vec3 pos)\n{\n\treturn length(pos) - 1.0;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat PlanetDistanceField(vec3 pos)\n{\n    //return mix(sdSphere(pos), sdBox(pos, vec3(1.0, 1.0, 1.0)), sin(iTime) * 0.5 + 0.5);\n    \n\tfloat m = sin(-0.5 * pos.y + 0.5 * iTime) + 1.0;\n    \n    if (m > 1.0)\n    {\n        m -= 1.0;\n        m = mix(sdTorus(pos, vec2(1.0, 0.5)), sdTriPrism(pos, vec2(1.0, 1.0)), m);\n    }\n    else\n    {\n        m = mix(sdBox(pos, vec3(1.0, 1.0, 1.0)), sdTorus(pos, vec2(1.0, 0.5)), m);\n    }\n    \n    return m + 0.1 * clamp(-pos.y, 0.0, 1.0) * noise(pos.y * pos * 10.0 + iTime);\n}\n\n\nvec3 ShadePlanet(vec3 pos, vec3 ray)\n{\n\tvec3 norm;\n\tvec2 d = vec2(0.0008 * length(pos),0);\n\t\n\tnorm.x = PlanetDistanceField(pos + d.xyy) - PlanetDistanceField(pos - d.xyy);\n\tnorm.y = PlanetDistanceField(pos + d.yxy) - PlanetDistanceField(pos - d.yxy);\n\tnorm.z = PlanetDistanceField(pos + d.yyx) - PlanetDistanceField(pos - d.yyx);\n\n\tnorm = normalize(norm);\n    \n    return texture(iChannel1, reflect(ray, norm)).rgb;//norm * 0.5 + 0.5;//\n}\n\n\nfloat TracePlanet(vec3 pos, vec3 ray)\n{\n    float h = 1.0;\n\tfloat t = hash(gl_FragCoord.xy) * 0.1;\n\n\tfor (int i = 0; i < 32; ++i)\n\t{\n\t\tif (h < .01 || t > 10.0)\n\t\t\tbreak;\n\n\t\th = 1.0 * PlanetDistanceField(pos + t * ray);\n\t\tt += h;\n\t}\n\n\tif ( h > .1 )\n\t\treturn 0.0;\n\n\treturn t;\n}\n\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x), cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x), sin(rotation.y));\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = uv;\n    ray.xy *= atan(iResolution.y, iResolution.x);\n    ray.x *= iResolution.x / iResolution.y;\n    ray.z = zoom;\n\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz * c.xx + ray.zy * s.zx;\n\tray.xz = ray.xz * c.yy + ray.zx * s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy / iResolution.xy * vec2(2.0) - vec2(1.0);\n    \n    vec2 camRot = iMouse.yx / iResolution.yx * vec2(-2.0, 2.0) + 1.0;\n\n\tvec3 pos, ray;\n\tCamPolar(pos, ray, vec3(0), camRot, 4.0, 1.5);\n    \n    float ts0 = TracePlanet(pos, ray);\n\n    vec3 linear;\n\n    if (ts0 > 0.0)\n    {\n        linear = ShadePlanet(pos + ray * ts0, ray);\n    }\n    else\n        linear = texture(iChannel0, ray).rgb;//normalize(ray) * 0.5 + 0.5;//\n\n    fragColor = vec4(linear, 0.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsBXz1","date":"1408890280","viewed":268,"name":"Geometry fading","username":"xernobyl","description":"From donut to toblerone and back.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fade","tracing"],"hasliked":0,"parentid":"","parentname":""}}