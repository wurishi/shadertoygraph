{"ver":"0.1","info":{"id":"NdSfWG","date":"1649242727","viewed":59,"name":"chareylo-spaceship","username":"chareylo","description":"spaceship","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["spaceship"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 30.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n\n// ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n};\n\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\n// Inigo Quilez\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Inigo Quilez\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\n//-----------------------------------------------------------------\n\nSurface scene(in vec3 p) {\n    \n    // Fusée = Sphere + cylindre\n    float fusee = min(sdSphere(p, 0.7), sdVerticalCapsule(p, 2., 0.1));\n    \n    // Antenne = Sphere sur le bout du cylindre de la fusée\n    float antenne = sdSphere(p+vec3(0.,-2.,0.), 0.2);\n    \n    // Anneaux = 3 Torus de différentes tailles autour du cercle\n    float anneaux = sdTorus(p+vec3(0.,-0.5,0.), vec2(0.5,0.05)) * sdTorus(p+vec3(0.,-0.6,0.), vec2(0.4,0.02)) * sdTorus(p+vec3(0.,-0.7,0.), vec2(0.3,0.02)) / sdTorus(p+vec3(0.,-0.5,0.), vec2(0.5,0.01));\n    \n    // Reacteurs = 3 Cones décallés sous la fusée via le vecteur vec3 reacteur\n    vec3 reacteur = p + vec3(0.5,1.,0.5);\n    float reacteurs = min(sdRoundCone(reacteur, 0.4, 0.2, 0.8), sdRoundCone(reacteur+vec3(-1.2,0.0,-0.3), 0.4, 0.2, 0.8) * sdRoundCone(reacteur+vec3(-0.5,0.0,-1.2), 0.4, 0.2, 0.8));\n    \n    // Feu = Sphere sous chacun des réacteurs\n    float feu = sdSphere(p+vec3(0.4,1.5,0.5), 0.2) * sdSphere(p+vec3(-0.8,1.4,0.1), 0.2) * sdSphere(p+vec3(-0.1,1.4,-0.9), 0.2);\n    \n    // Boucliers = Spheres éloignés de l'origine\n    float bouclier_rose = sdSphere(p+vec3(-4.*cos(iTime*5.),-2.*sin(iTime*5.),-2.*sin(iTime*2.5)), 0.4);\n    float bouclier_vert = sdSphere(p+vec3(4.*cos(iTime*5.),3.*sin(iTime*5.),3.*sin(iTime*2.5)), 0.4);\n    \n    // Tous les objets sont affichés devant la fusée\n    // Sauf le feu qui doit être devant les réacteurs\n    if(anneaux < fusee) {\n        return Surface(anneaux,vec3(1.,1.,0.)*cos(iTime*5.)); // Anneaux sur la fusée clignotte de la même facon que l'antenne mais plus lentement\n    } else if(bouclier_rose < fusee) {\n        return Surface(bouclier_rose,vec3(1.,0.7,0.8)); // Bouclier sphére rose\n    } else if(bouclier_vert < fusee) {\n        return Surface(bouclier_vert,vec3(0.,1.,0.)); // Bouclier sphére verte\n    } else if(antenne < fusee) {\n        return Surface(antenne,vec3(1.,1.,0.)*cos(iTime*10.)); // Antenne clignotte rapidement entre noir et jaune avec sin() en fonction du temps\n    } else if(feu < reacteurs) {\n        return Surface(feu,vec3(1.,0.,0.)*tan(iTime*2.)); // Feu tend très vite vers les extremes entre rouge et noir avec tan() en fonction du temps\n    } else if(reacteurs < fusee) {\n        return Surface(reacteurs,vec3(0.8,0.8,0.8)); // Réacteurs Gris\n    } else {\n        return Surface(fusee,vec3(0.5,0.1,0.8)); // Fusée violette\n    }\n}\n\n//-----------------------------------------------------------------\n\n\nSurface march(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(0)); // vec3(0) = fond noir\n}\n\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position\n    vec2 m = iMouse.xy/R.y;\n    \n    // camera position\n    float DP = 20.;\n    float d = DP/2.;\n    // Rotation de la camera en fonction du temps\n    vec3 ro = vec3( d*cos(6.0*m.x*cos(iTime*0.8)),DP/5.0,d*sin(6.0*m.x*cos(iTime*0.8)) );\n    //vec3 ro = vec3(d*cos(6.0*m.x),(DP/2.0)*(m.y*4.),d*sin(6.0*m.x) );\n\n    //vec3 ro = vec3(10.,0.,-9.);\n\n    // target point\n    //vec3 ta = vec3(0.0,DP/10.0,0.0);\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,0.5);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + 2.*cw);\n\n    return Ray(ro,rd);\n}\n\nvec3 shade(in Surface surf, in Ray ray) {\n    // tous les vecteurs nécessaires au shading\n    vec3 n = normalAt(surf,ray);\n    vec3 l = normalize(vec3(1.));\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(0.8);\n    float s = 20.;\n    \n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l),0.);\n    float spec = pow(max(dot(r,v),0.),s);\n    \n    return kd*diff + ks*spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    \n    Ray r = camRay(uv);\n    Surface s = march(r);\n    vec3 c = s.c;\n    \n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }\n    \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}