{"ver":"0.1","info":{"id":"dlGfWd","date":"1702631896","viewed":35,"name":"Worely Noise (Test 1 RS)","username":"roey_shap","description":"Worely Noise in 3D with a smoothing factor between neighbor values. Also tried normalizing brightness relative to furthest distance found.\nMouse horizontally: different crystalizations.\nMouse vertically: change distance calculation.\nDot size ~ z value.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_POINTS 10\n#define SCREEN_BOUND vec2(0.3, 0.225)\n#define POINTS_ON 1\n\nvec3 points[NUM_POINTS];\nfloat pointDistances[NUM_POINTS];\nfloat LP_DISTANCE_FACTOR = 2.0;\n\nfloat dist(vec3 p1, vec3 p2)\n{\n    vec3 delta = abs(p2 - p1);\n    vec3 raised = pow(delta, vec3(LP_DISTANCE_FACTOR));\n    return pow(dot(raised, vec3(1.0)), 1.0 / LP_DISTANCE_FACTOR);\n}\n\nfloat map(float min1, float max1, float value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\nvoid bubbleSort()\n{\n    bool swappedThisRound = true;\n    int j = 0;\n    float tmp;\n    for (int i = 0; i < NUM_POINTS; i++)\n    {\n        if (!swappedThisRound) \n        {\n            break;\n        }\n        \n        swappedThisRound = false;\n        for (j = 0; j < NUM_POINTS - 1; j++)\n        {\n            if (pointDistances[j] > pointDistances[j + 1])\n            {\n                tmp = pointDistances[j];\n                pointDistances[j] = pointDistances[j + 1];\n                pointDistances[j + 1] = tmp;\n                swappedThisRound = true;\n            }\n        }\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float smallerAxis = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - 0.5 *iResolution.xy) / smallerAxis;\n    float zMin = -0.2;\n    float zMax = 0.2;\n    float z = map(-1.0, 1.0, sin(iTime * 0.2), zMin, zMax);\n    float zPercent = map(zMin, zMax, z, 0.0, 1.0);\n    vec2 mousePercent = iMouse.xy / iResolution.xy;\n    float mouseMin = 0.1;\n    float mouseMax = 0.9;\n    float mouseSelection = clamp(map(mouseMin, mouseMax, mousePercent.x, 1.0, float(NUM_POINTS)), 1.0, float(NUM_POINTS));\n    float brightness = 1.0;\n    float pointRadius = 0.03;\n    \n    LP_DISTANCE_FACTOR = clamp(map(mouseMin, mouseMax, mousePercent.y, 1.0, 8.0), 1.0, 8.0);\n    \n    vec3 uv3 = vec3(uv, z);\n    \n    for (int i = 0; i < NUM_POINTS; i++)\n    {\n        float fi = float(i);\n        float percentage = fi / float(NUM_POINTS);\n        float v1 = map(-1.0, 1.0, sin(float(8 + 2 * i) * percentage + 0.85 * iTime), -SCREEN_BOUND.x, SCREEN_BOUND.x);\n        float v2 = map(-1.0, 1.0, 0.5 * sin(cos(float(4 + 3 * i)) * (1.0 - percentage) + (0.4 * iTime)) + 0.5 * cos(10.0 + 5.0 * float(i) / (map(-1.0, 1.0, sin(iTime), 10.0, 25.0) + 1.0)), -SCREEN_BOUND.y, SCREEN_BOUND.y);\n        float v3 = sin(cos(iTime)) * mix(v1, v2, map(-1.0, 1.0, sin(iTime), 0.0, 1.0));\n        points[i] = vec3(v1, v2, v3);\n        pointDistances[i] = dist(uv3, points[i]);\n        \n        if (bool(POINTS_ON) && length(points[i].xy - uv) <= pointRadius * map(0.0, 1.0, zPercent, 0.2, 0.7))\n        {\n            fragColor = vec4(mix(vec3(brightness), vec3(0.0, 1.0, 1.0), 1.0 - zPercent), 1.0);\n            return;\n        }\n    }\n    \n    bubbleSort();\n    \n    float fracBetweenN = fract(mouseSelection);\n    int n = int(mouseSelection);\n    float d1 = pointDistances[n-1];\n    float d2 = pointDistances[n];\n    float chosenDis = mix(d1, d2, fracBetweenN);\n    vec3 col = brightness * vec3(1.0 - (chosenDis / pointDistances[NUM_POINTS-1]));\n    float s = map(0.0, 1.0, zPercent, 0.001, 0.05);\n    col = round(col / s) * s;\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}