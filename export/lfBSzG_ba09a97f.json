{"ver":"0.1","info":{"id":"lfBSzG","date":"1706472197","viewed":76,"name":"Mike Wuerth's Pentagon Fractal","username":"DjinnKahn","description":"Original: [url]https://www.facebook.com/groups/391950357895182/permalink/1763333360756868[/url]\n\nThis was a challenge to filter/anti-alias well! Buffer A iteratively \"solves\" what the pentagon looks at a certain scale (takes ~16 iterations). ","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["fractal","perfectloop","pentagon","infinitezoom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 bufA( vec2 p )\n{\n    return texture( iChannel0, p*iResolution.y/iResolution.xy*.5 + .5 );\n}\n\nconst float zoom_exactly_1_iteration = (( 2. - PHI ) / G);\nconst float zoom_exactly_2_iterations = zoom_exactly_1_iteration * zoom_exactly_1_iteration;\n\nfloat go( in vec2 fragCoord, float zoom_power )\n{\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    p = p.yx;  \n    p *= .4 * pow( zoom_exactly_1_iteration, zoom_power );    \n    \n    float col = 0.;\n    for ( int i = 0; i < int( zoom_power + 2.2 ); i++ )\n    {\n        if ( !inPentagon( p ) )\n            break;\n    \n        p = map( p );\n        col = (i&1)==0 ? 1. - bufA( p ).r : bufA( p ).r;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n    float zoom_power = mod( iTime * .6, 2. );    \n        \n    // anti-aliasing\n    int N = 4;\n    float sum = 0.;\n    ivec2 aa;\n    for ( aa.y = 0; aa.y < N; aa.y++ )\n    for ( aa.x = 0; aa.x < N; aa.x++ )\n    {\n        sum += go( fragCoord + vec2(aa)/float(N) - (.5-.5/float(N)), zoom_power );\n    }\n    float avg = sum / (float(N)*float(N));\n    \n    fragColor = vec4( vec3( avg ), 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 bufA( vec2 p )\n{\n    return texture( iChannel0, p*iResolution.y/iResolution.xy*.5 + .5 );\n}\n\nvec4 go( vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y;\n            \n    float col = inPentagon( p ) ? 1. - bufA( map( p ) ).r : 0.;\n        \n    return vec4( vec3( col ), 1. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //// uncomment to slowly perform the iterations\n    //if ( iFrame % 30 != 0 )\n    //{    \n    //    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    //    fragColor = bufA( p );\n    //    return;\n    //}   \n\n    // anti-aliasing\n    int N = 4;\n    vec4 sum = vec4( 0. );\n    ivec2 aa;\n    for ( aa.y = 0; aa.y < N; aa.y++ )\n    for ( aa.x = 0; aa.x < N; aa.x++ )\n    {\n        sum += go( fragCoord + vec2(aa)/float(N) - (.5-.5/float(N)) );\n    }\n    \n    fragColor = sum / (float(N)*float(N));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = acos(0.)*2.;\nconst float PHI = (1. + sqrt(5.)) / 2.;\nconst float ANGLE_72 = 2.*PI/5.;\nconst float ANGLE_36 = 2.*PI/10.;\nconst float G = 1.1; // controls \"line\" thickness. Values in the range [1.02, 1.3] work well.\n\n// 2-d rotation matrix\nmat2 rot( float a )\n{\n    return mat2( cos(a), sin(a), -sin(a), cos(a) );\n}\n\n// 10-fold radial symmetry\nvec2 fold_pentagon( vec2 p )\n{    \n    p.x = -p.x;\n    float a = atan( p.y, p.x );\n    float section = round( a / ANGLE_72 );\n    p = rot( -section * ANGLE_72 ) * p;\n    return vec2( -p.x, abs(p.y) );\n}\n\n// given a point `p` in the \"unit pentagon\", find which of the 6 sub-pentagons\n// `p` is in, and return where `p` maps to if that sub-pentagon is homographically \n// warped to the \"unit pentagon\"\nvec2 map( vec2 p )\n{\n    p.x = -p.x;\n    p = fold_pentagon( p );\n    \n    if ( -p.x < (PHI - 1.) / 2. )\n        return p / ( 2. - PHI ) * G;\n    \n    // homographical warp\n    return vec2( -3. * PHI * p.x - (PHI+1.), (PHI+2.) * p.y ) / (-2./PHI * p.x + 1.) * G;\n}\n\nbool inPentagon( vec2 p )\n{\n    return fold_pentagon( p ).x > -PHI/2.;\n}\n","name":"Common","description":"","type":"common"}]}