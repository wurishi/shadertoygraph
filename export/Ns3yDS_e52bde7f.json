{"ver":"0.1","info":{"id":"Ns3yDS","date":"1674122312","viewed":88,"name":"maison toit souple","username":"lucimotte","description":"panoramas maisons\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"maison avec lumière\" by lucimotte. https://shadertoy.com/view/Nd3czl\n// 2022-05-30 13:42:43\n\n#define pi 3.14159265359\n#define white vec3(1.,1.,1.)\n#define grey1 vec3(0.98, 0.98, 1.)\n#define grey2 vec3(0.90, 0.90, 0.95)\n#define grey3 vec3(0.7, 0.7, 0.80)\n#define brown1 vec3(0.67,0.32,0.)\n#define brown2 vec3(0.64,0.29,0.)\n#define brown3 vec3(0.56,0.25,0.)\n\n//*******************************************************//\n#define W 0.5\n#define L 0.4\n#define H 0.2\n#define R 0.2\n#define oriUD pi/3.\n#define oriL pi/8.\n#define neige 0.055\n#define reverse 0.\n#define rightLight 1.\n#define depassement 0.1\n#define arrondi neige*1.3\n\n//oriUD (orientation Up/Down)                              between    pi/4. and pi/2.\n//oriL (orientation Left -> implies orientation right)     between  pi/9999. and oriUD\n\n\n//option la plus commune : oriUD = pi/3. et oriL = pi/6.\n//*******************************************************//\n\nstruct Surface {\n     float d;\n     vec3 col;\n};\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n     vec2 d = abs(p)-b;\n     return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{   p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat opRound( in vec2 p,  in vec2 p0, in vec2 p1, in vec2 p2, in float r )\n{\n  return sdTriangle(p, p0, p1, p2) - r;\n}\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opUnion(float d1, float d2){ return min(d1,d2); }\n\nfloat opIntersection(float d1, float d2){ return max(d1,d2); }\n\nvec2  rotate(in vec2 uv, float angle){\n    return vec2(cos(angle)* uv.x - sin(angle)* uv.y, sin(angle) * uv.x + cos(angle) * uv.y);\n}\n\nvec2 scale(in vec2 uv, float scale){\n    return vec2(uv) * scale;\n}\n\nvec2 translate(in vec2 uv, in vec2 trans){\n    return vec2(uv.x + trans.x, uv.y + trans.y) ;\n}\n\n\nSurface Walls(in vec2 uv){\n    float oriR = oriUD - oriL;\n    float IncliL = (W) * sin(oriL);\n    float IncliR = (L) * sin(oriR) ;\n\n    float Wleft = IncliL / tan(oriL);\n    float Wright ;\n    if (oriR == 0.)\n        Wright = L;\n    else \n        Wright = IncliR /tan(oriR);\n    \n    \n    //Coordonnées points maison : \n    vec2 a = vec2(-Wleft*2., H+2.*IncliL);\n    vec2 b = vec2(0., H);\n    vec2 h = vec2(-Wleft, IncliL+H+R);\n    vec2 f = vec2(Wright*2., H+2.*IncliR); \n    vec2 i = vec2((f.x + h.x), f.y + (h.y-b.y));\n    vec2 c = vec2(0., -H);\n    vec2 d = vec2(-Wleft*2., -H+2.*IncliL);\n    vec2 e = vec2(f.x+a.x, i.y - (h.y - a.y));\n    vec2 g = vec2(Wright*2., -H+2.*IncliR);\n    \n    vec2 abis = vec2(-Wleft*2., H+2.*IncliL + neige);\n    vec2 bbis = vec2(0., H + neige);\n    vec2 hbis = vec2(-Wleft, IncliL+H+R + neige);\n    vec2 fbis = vec2(Wright*2., H+2.*IncliR + neige); \n    vec2 ibis = vec2((f.x + h.x), f.y + (h.y-b.y + neige));\n    vec2 ebis = vec2(f.x+a.x, i.y - (h.y - a.y) + neige);\n\n\n    //front\n    vec2 coordFront = uv;\n    coordFront = rotate(coordFront, pi/2.); \n    coordFront = translate(coordFront, vec2(IncliL, Wleft ));\n    float front = sdParallelogram(coordFront,H , Wleft, IncliL);\n    \n    \n    //right\n    vec2 coordRight = uv;\n    coordRight = rotate(coordRight, pi/2.); \n    coordRight = translate(coordRight, vec2(IncliR, -Wright ));\n    float right = sdParallelogram(coordRight,H , Wright, -IncliR);\n    \n    //roof triangle \n    vec2 coordRoof = uv; \n    float roof = sdTriangle(coordRoof, a, b , h);\n    \n \n    Surface s = Surface(999., vec3(0.));\n\n\n    if ((rightLight == 1. && reverse == 0.) || (rightLight == 0. && reverse == 1.)){\n        if (front <= s.d){\n            s.d = front; \n            s.col = brown2;\n        }\n        if (right <= s.d){\n            s.d = right; \n            s.col = brown1;\n        }  \n        if (roof <= s.d){\n            s.d = roof; \n            s.col = brown3;\n        }\n    }\n    \n    else{\n        if (front <= s.d){\n            s.d = front; \n            s.col = brown1;\n        }\n        if (right <= s.d){\n            s.d = right; \n            s.col = brown2;\n        }  \n        if (roof <= s.d){\n            s.d = roof; \n            s.col = brown2;\n        } \n    }\n\n    return s;\n    \n}\n\n\nSurface Roof(in vec2 uv){\n    float oriR = oriUD - oriL;\n    float IncliL = (W) * sin(oriL);\n    float IncliR = (L) * sin(oriR) ;\n\n    float Wleft = IncliL / tan(oriL);\n    float Wright ;\n    if (oriR == 0.)\n        Wright = L;\n    else \n        Wright = IncliR /tan(oriR);\n    \n    \n    //Coordonnées points maison : \n    vec2 a = vec2(-Wleft*2., H+2.*IncliL);\n    vec2 b = vec2(0., H);\n    vec2 h = vec2(-Wleft, IncliL+H+R);\n    vec2 f = vec2(Wright*2., H+2.*IncliR); \n    vec2 i = vec2((f.x + h.x), f.y + (h.y-b.y));\n    vec2 c = vec2(0., -H);\n    vec2 d = vec2(-Wleft*2., -H+2.*IncliL);\n    vec2 e = vec2(f.x+a.x, i.y - (h.y - a.y));\n    vec2 g = vec2(Wright*2., -H+2.*IncliR);\n    \n    vec2 abis = vec2(-Wleft*2., H+2.*IncliL + neige);\n    vec2 bbis = vec2(0., H + neige);\n    vec2 hbis = vec2(-Wleft, IncliL+H+R + neige);\n    vec2 fbis = vec2(Wright*2., H+2.*IncliR + neige); \n    vec2 ibis = vec2((f.x + h.x), f.y + (h.y-b.y + neige));\n    vec2 ebis = vec2(f.x+a.x, i.y - (h.y - a.y) + neige);\n    \n    //dépassement toit / neige\n    float roofRightDistX = h.x - b.x; \n    float roofRightDistY = h.y - b.y;\n    float roofLeftDistX = h.x - a.x;\n    float roofLeftDistY = h.y - a.y;\n    vec2 atoit = vec2(a.x - roofLeftDistX*depassement, a.y - roofLeftDistY*depassement);  \n    vec2 atoitBis = vec2(abis.x - roofLeftDistX*depassement, abis.y - roofLeftDistY*depassement); \n    vec2 etoit = vec2(e.x - roofLeftDistX*depassement, e.y - roofLeftDistY*depassement);  \n    vec2 etoitBis = vec2(ebis.x - roofLeftDistX*depassement, ebis.y - roofLeftDistY*depassement); \n    vec2 btoit = vec2(b.x - roofRightDistX*depassement, b.y - roofRightDistY*depassement);  \n    vec2 btoitBis = vec2(bbis.x - roofRightDistX*depassement, bbis.y - roofRightDistY*depassement);     \n    vec2 ftoit = vec2(f.x - roofRightDistX*depassement, f.y - roofRightDistY*depassement);  \n    vec2 ftoitBis = vec2(fbis.x - roofRightDistX*depassement, fbis.y - roofRightDistY*depassement); \n\n    //roof\n    vec2 coordRoof = uv; \n    float roofLeft1 = opRound(coordRoof, atoitBis, hbis, ibis, arrondi);\n    float roofLeft2 = opRound(coordRoof, atoitBis, ibis, etoitBis, arrondi);\n    float roofRight1 = opRound(coordRoof, btoitBis, hbis ,ftoitBis, arrondi);\n    float roofRight2 = opRound(coordRoof, hbis, ftoitBis, ibis, arrondi);\n\n    \n    //neige \n    vec2 coordNeige = uv ;\n    float neigeLeft1 = opRound(coordNeige, atoit , atoitBis, hbis, arrondi);\n    float neigeLeft2 = opRound(coordNeige, atoit , h, hbis, arrondi);\n    float neigeLeft3 = opRound(coordNeige, h , hbis, btoit, arrondi);\n    float neigeLeft4 = opRound(coordNeige, hbis , btoitBis, btoit, arrondi);\n    float neigeRight1 = opRound(coordNeige, btoit , btoitBis, ftoitBis, arrondi);\n    float neigeRight2 = opRound(coordNeige, btoit , ftoitBis, ftoit, arrondi);\n\n    Surface s = Surface(999., vec3(0.));\n\n\n\n    if ((rightLight == 1. && reverse == 0.) || (rightLight == 0. && reverse == 1.)){\n        if (neigeLeft1 <= s.d){\n            s.d = neigeLeft1; \n            s.col = grey2;\n        }    \n        if (neigeLeft2 <= s.d){\n            s.d = neigeLeft2; \n            s.col = grey2;\n        }\n        if (neigeLeft3 <= s.d){\n            s.d = neigeLeft3; \n            s.col = grey2;\n        }\n        if (neigeLeft4 <= s.d){\n            s.d = neigeLeft4; \n            s.col = grey2;\n        }\n        if (roofRight1 <= s.d){\n            s.d = roofRight1; \n            s.col = grey1;\n        }\n        if (roofRight2 <= s.d){\n            s.d = roofRight2; \n            s.col = grey1;\n        }\n        if (roofLeft1 <= s.d){\n            s.d = roofLeft1; \n            s.col = grey3;\n        }\n        if (roofLeft2 <= s.d){\n            s.d = roofLeft2; \n            s.col = grey3;\n        }\n        if (neigeRight1 <= s.d){\n            s.d = neigeRight1; \n            s.col = grey1;\n        }\n        if (neigeRight2 <= s.d){\n            s.d = neigeRight2; \n            s.col = grey1;\n        }\n    }\n    else{\n        if (neigeLeft1 <= s.d){\n            s.d = neigeLeft1; \n            s.col = grey2;\n        }    \n        if (neigeLeft2 <= s.d){\n            s.d = neigeLeft2; \n            s.col = grey2;\n        }\n        if (neigeLeft3 <= s.d){\n            s.d = neigeLeft3; \n            s.col = grey2;\n        }\n        if (neigeLeft4 <= s.d){\n            s.d = neigeLeft4; \n            s.col = grey2;\n        }\n        if (roofRight1 <= s.d){\n            s.d = roofRight1; \n            s.col = grey3;\n        }\n        if (roofRight2 <= s.d){\n            s.d = roofRight2; \n            s.col = grey3;\n        }\n        if (roofLeft1 <= s.d){\n            s.d = roofLeft1; \n            s.col = grey1;\n        }\n        if (roofLeft2 <= s.d){\n            s.d = roofLeft2; \n            s.col = grey1;\n        }\n        if (neigeRight1 <= s.d){\n            s.d = neigeRight1; \n            s.col = grey3;\n        }\n        if (neigeRight2 <= s.d){\n            s.d = neigeRight2; \n            s.col = grey3;\n        }\n    }\n    return s;\n    \n}\n\n// set up constants, effects ripple behaviour\nfloat violence = 0.02;\nfloat levelOfExtreme = 5.;\n\n// function warp x or y coordinate based on time and sin that shit\nfloat warp( float a , float timescale)\n{\n    return sin( (timescale * iTime + a) * levelOfExtreme ) * violence;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord-iResolution.xy/2.)/iResolution.y)*2.;\n    \n    //uv = uv*10.;\n    //uv = mod(uv+1., 2.)-1.;\n    \n    \n    uv.y = uv.y + 0.5;\n    \n    uv = uv;\n    if (reverse == 1.)\n        uv.x = -uv.x; \n \n    uv = uv ;\n    //house separated in two parts -> roof and walls\n    Surface walls = Walls(uv);\n\n    uv += vec2(warp(uv.y, 1.),warp(uv.x, 1.5));\n    \n    Surface roof = Roof(uv);\n    \n \n    vec3 col = vec3(0.80, 0.80, 0.9);\n    \n    // Output to screen\n    if (walls.d < 0.)\n        col = walls.col;\n    if (roof.d < 0.)\n        col = roof.col;\n        \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}