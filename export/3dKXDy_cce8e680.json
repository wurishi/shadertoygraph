{"ver":"0.1","info":{"id":"3dKXDy","date":"1574885750","viewed":228,"name":"Starship SDF","username":"edubart","description":"Starship model","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","rocket","spacex","starship"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 256.0\n#define MAX_STEPS 128\n#define SURF_DIST 0.0001\n#define PI 3.1415926535897932384626433832795\n#define AA 2\n\n#define MATERIAL_BODY 1\n\nstruct Hit {\n    float d;\n    int material;\n    vec3 material_pos;\n};\n\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Capped cylynder in the Y axis with its center at the origin\nfloat sd_capped_cylinder(vec3 p, float half_height, float radius) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(radius, half_height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Capped cylynder in the Y axis with its base at the origin\nfloat sd_capped_cylinder_up(vec3 p, float height, float radius) {\n    return sd_capped_cylinder(p - vec3(0.0, height*0.5, 0.0), height*0.5, radius);\n}\n\n// Torus in the Y axis with center at the origin\nfloat sd_torus(vec3 p, float outer_radius, float inner_radius) {\n    vec2 q = vec2(length(p.xz)-outer_radius,p.y);\n    return length(q)-inner_radius;\n}\n\n// Box with center at the origin\nfloat sd_box(vec3 p, vec3 half_size) {\n    vec3 q = abs(p) - half_size;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 rotate2d(vec2 p, float angle) {\n    float cost = cos(angle);\n    float sint = sin(angle);\n    mat2 a = mat2(cost,-sint, sint, cost);\n    return a * p;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*k*(1.0/4.0);\n}\n\n#define check_hit(m) if(dist < mindist) { material = m; mindist = dist; }\n\n// Return the closest surface distance to point p\nHit map(vec3 p) {\n    float mindist = MAX_DIST;\n    float dist = MAX_DIST;\n    float d = MAX_DIST;\n    vec3 material_pos;\n    int material = 0;\n\n    p.xz = rotate2d(p.xz, -PI*2.0/4.0);\n    material_pos = p;\n\n    float rocket_height = 50.0;\n    float rocket_radius = 4.5;\n    float nose_height = 12.0;\n    float topnose_radius = 1.0;\n    float base_height = (rocket_height - nose_height);\n\n    { // base\n        float d = sd_capped_cylinder_up(p, base_height, rocket_radius); // cylynder\n        dist = min(dist,d);\n    }\n    \n    { // nose\n        vec3 q = p;\n        q.y -= base_height;\n        float r = topnose_radius;\n        float h = nose_height - r;\n        float Rl = rocket_radius;\n        float R = (Rl*Rl + h*h - r*r) / (2.0*(Rl-r));\n        float hl = (h*r)/(R-r);\n        float oR = R - Rl;\n        float d = sd_torus(q, -oR, R);\n        d = max(d, -q.y);\n        d = max(d,  q.y-(h+hl));\n        dist = min(dist, d);\n        d = sd_sphere(q - vec3(0.0,h,0.0), r);\n        dist = min(dist ,d);\n    }\n\n    { // nose fin\n        float fin_roundness = 0.15;\n        float fin_height = 50.2;\n        float fin_halfwidth = 0.2  - fin_roundness;\n        float fin_angle = PI*(8.0/36.0);\n        float fin_halfsize = 5.5 - fin_roundness;\n        float fin_topcut = 0.4;\n        float fin_smoothness = 0.3;\n        float fin_baseheight = 1.2;\n        vec2 fin_offs = vec2(sin(fin_angle), cos(fin_angle)) * fin_halfsize*2.0;\n        vec2 finbase_halfsize = vec2(fin_offs.x, fin_baseheight);\n        float fin_baseoffset = -fin_offs.y - fin_baseheight;\n        vec3 q = p;\n        q.x = abs(q.x);\n        q.y -= fin_height;\n        vec3 qr = q;\n        qr.xy = rotate2d(qr.xy, fin_angle);\n        qr.xy += fin_halfsize;\n        d = sd_box(qr, vec3(fin_halfsize, fin_halfsize, fin_halfwidth));\n        d = max(d, q.y + fin_topcut);\n        d = max(d,-q.y - fin_offs.y);\n        float dbox = sd_box(q - vec3(0.0,fin_baseoffset,0.0), vec3(finbase_halfsize, fin_halfwidth));\n        d = min(d, dbox);\n        dist = smin(dist, d, fin_smoothness) - fin_roundness;\n    }\n\n    { // tail fin\n        float fin_roundness = 0.25;\n        float fin_height = 29.3;\n        float fin_halfwidth = 0.3  - fin_roundness;\n        float fin_angle = PI*(5.0/36.0);\n        float fin_halfsize = 13.0 - fin_roundness;\n        float fin_topcut = 0.4;\n        float fin_smoothness = 0.3;\n        float fin_baseheight = 3.0;\n        vec2 fin_offs = vec2(sin(fin_angle), cos(fin_angle)) * fin_halfsize*2.0;\n        vec2 finbase_halfsize = vec2(fin_offs.x, fin_baseheight);\n        float fin_baseoffset = -fin_offs.y - fin_baseheight;\n        vec3 q = p;\n        q.x = abs(q.x);\n        q.y -= fin_height;\n        vec3 qr = q;\n        qr.xy = rotate2d(qr.xy, fin_angle);\n        qr.xy += fin_halfsize;\n        d = sd_box(qr, vec3(fin_halfsize, fin_halfsize, fin_halfwidth));\n        d = max(d, q.y + fin_topcut);\n        d = max(d,-q.y - fin_offs.y);\n        float dbox = sd_box(q - vec3(0.0,fin_baseoffset,0.0), vec3(finbase_halfsize, fin_halfwidth));\n        d = min(d, dbox);\n        dist = smin(dist, d, fin_smoothness) - fin_roundness;\n    }\n\n    { // tail columns\n        float size = 4.5;\n        float roundness = 0.5;\n        float width = 0.0;\n        float height = 6.0;\n        float angle = PI*(1.0/12.0);\n        vec3 q = p;\n\n        q.xz = abs(q.xz);\n        q.y = q.y - clamp(q.y - (size - size*(1.0-tan(angle))*cos(angle)), -height, height);\n        q.y -= size;\n        q.xz = rotate2d(q.xz, PI/4.0);\n        q.xy = rotate2d(q.xy, angle);\n        d = sd_box(q, vec3(size, size, width)) - roundness;\n        dist = smin(dist, d, 2.0);\n        dist = max(dist, -p.y);\n    }\n\n    // back distortion\n    {\n        float level = 1.0-smoothstep(0.35, 0.3, p.z);\n        dist += sin(p.x*15.0)*sin(p.y*15.0)*sin(p.z*15.0)*0.01*level;\n    }\n\n    \n    check_hit(MATERIAL_BODY);\n\n\n    return Hit(mindist, material, material_pos);\n}\n\n// Get normal at point `p` using the tetrahedron technique for computing the gradient\nvec3 get_normal(vec3 p) {\n    const float eps = 0.0001;\n    vec2 e = vec2(1.0,-1.0);\n    return normalize(e.xyy*map(p + e.xyy*eps).d + \n                     e.yyx*map(p + e.yyx*eps).d + \n                     e.yxy*map(p + e.yxy*eps).d + \n                     e.xxx*map(p + e.xxx*eps).d);\n}\n\n// March a ray from `rayfrom` along the `raydir` direction and return the closet surface distance\nHit ray_march(vec3 rayfrom, vec3 raydir) {\n    // begin at ray origin\n    float t = 0.0;\n    Hit hit;\n    // ray march loop\n    for(int i=0; i<MAX_STEPS; ++i) {\n        // compute next march point\n        vec3 p = rayfrom+t*raydir;\n        // get the distance to the closest surface\n        hit = map(p);\n        // hit a surface\n        if(abs(hit.d) < (SURF_DIST*t))\n            break;\n        // increase the distance to the closest surface\n        t += hit.d;\n        if(t > MAX_DIST) {\n            hit.material = 0;\n            break;\n        }\n    }\n    // return the distance to `rayfrom`\n    hit.d = t;\n    return hit;\n}\n\n// Hard shadows\nfloat hard_shadow(vec3 rayfrom, vec3 raydir, float tmin, float tmax) {\n    float t = tmin;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayfrom + raydir*t;\n        float h = map(p).d;\n        if(h < SURF_DIST)\n            return 0.0;\n        t += h;\n        if(t > tmax)\n            break;\n    }\n    return 1.0;\n}\n\n// Get occlusion along `normal` from point of view `rayfrom`\nfloat get_occlusion(vec3 rayfrom, vec3 normal) {\n    const int AO_ITERATIONS = 5;\n    const float AO_START = 0.01;\n    const float AO_DELTA = 0.03;\n    const float AO_DECAY = 0.95;\n    const float AO_INTENSITY = 3.0;\n\n    float occ = 0.0;\n    float decay = 1.0;\n    for(int i=0; i<AO_ITERATIONS; ++i) {\n        float h = AO_START + float(i) * AO_DELTA;\n        float d = map(rayfrom + h*normal).d;\n        occ += (h-d) * decay;\n        decay *= AO_DECAY;\n    }\n    return clamp(1.0 - occ * AO_INTENSITY, 0.0, 1.0);\n}\n\n// Return diffuse albedo color for material\nvec3 get_material_diffuse(vec3 p, Hit hit) {\n    switch(hit.material) {\n        case MATERIAL_BODY: {\n            vec3 col = vec3(0.9,0.95,1.0)*0.010;\n            { // nose top window\n                vec3 q = hit.material_pos;\n                q -= vec3(0.0,46.5,-4.0);\n                vec3 qr = q;\n                qr.xy = rotate2d(qr.xy, PI/4.0);\n                float d = sd_box(qr, vec3(1.5))- 1.0;\n                d = max(d, -q.y-1.0);\n                if(d < 0.0) {\n                    vec3 pc = hit.material_pos * 4.4;\n                    pc.xy = rotate2d(pc.xy, PI/4.0);\n                    float s = smoothstep(0.0, 0.1, pow(abs(sin(pc.x)*sin(pc.y)), 0.7));\n                    col *= (1.2-s);\n                }\n            }\n\n            { // nose bottom window\n                vec3 q = hit.material_pos;\n                float d = sd_box(q - vec3(0.0,44.5,-4.0), vec3(4.0,0.05,2.0)) - 0.2;\n                d = min(d, sd_box(q - vec3(0.0,43.5,-4.0), vec3(4.0,0.05,2.0)) - 0.2);\n                d = min(d, sd_box(q - vec3(0.0,42.5,-4.0), vec3(4.0,0.05,2.0)) - 0.2);\n                d = min(d, sd_box(q - vec3(0.0,41.5,-4.0), vec3(4.0,0.05,2.0)) - 0.2);\n                d = min(d, sd_box(q - vec3(0.0,40.5,-4.0), vec3(4.0,0.05,2.0)) - 0.2);\n                if(d < 0.0) {\n                    vec3 pc = hit.material_pos * 3.0;\n                    float s = smoothstep(0.0, 0.1, pow(abs(sin(pc.x)), 0.9));\n                    col *= (1.2-s);\n                }\n            }\n\n            return col;\n        }\n        default:\n            return vec3(1.0, 1.0, 1.0);\n    }\n}\n\n// Return specular color for material\nvec3 get_material_specular(vec3 p, Hit hit) {\n    switch(hit.material) {\n        case MATERIAL_BODY:\n            float level = smoothstep(0.4, 0.3, hit.material_pos.z);\n            return vec3(0.9,0.95,1.0) * (level*0.5 + 0.02);\n        default:\n            return vec3(0.0);\n    }\n}\n\n// Compute the scene light at a point\nvec3 get_light(vec3 raydir, vec3 p, Hit hit) {\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 normal = get_normal(p);\n    float occlusion = get_occlusion(p, normal);\n\n    // sun light\n    const float SUN_INTENSITY = 1.0;\n    const float SUN_SHINESS = 10.0;\n    const vec3 SUN_DIRECTION = normalize(vec3(-1.0,0.1,0.1));\n    const vec3 SUN_COLOR = vec3(0.60,0.70,1.00);\n\n    float sun_diffuse = clamp(dot(normal, SUN_DIRECTION), 0.0, 1.0);\n    float sun_shadow = hard_shadow(p, SUN_DIRECTION, 0.01, 20.0);\n    float sun_specular = pow(clamp(dot(reflect(SUN_DIRECTION, normal), raydir), 0.0, 1.0), SUN_SHINESS);\n\n    diffuse += SUN_COLOR * (sun_diffuse * sun_shadow * SUN_INTENSITY);\n    specular += SUN_COLOR * sun_specular;\n\n    // sky light\n    const float SKY_INTENSITY = 1.0;\n    const float SKY_SHINESS = 30.0;\n    const float SKY_BIAS = 0.0;\n    const vec3 SKY_COLOR = vec3(0.60,0.70,1.00);\n    const vec3 SKY_DIRECTION = normalize(vec3(-1.0,0.1,0.5));\n\n    float sky_diffuse = SKY_BIAS + (1.0 - SKY_BIAS)*clamp(dot(normal, SKY_DIRECTION), 0.0, 1.0);\n    float sky_specular = pow(clamp(dot(reflect(SKY_DIRECTION, normal), raydir), 0.0, 1.0), SKY_SHINESS);\n    diffuse += SKY_COLOR * (SKY_INTENSITY * sky_diffuse * occlusion);\n    specular += SKY_COLOR * (sky_specular * occlusion);\n\n    // apply material\n    vec3 col = diffuse * get_material_diffuse(p, hit) +\n               specular * get_material_specular(p, hit);\n\n    // gamma correction\n    col = pow(col, vec3(0.4545));\n    return col;\n}\n\nvec3 get_sky_background(vec3 raydir) {\n    return vec3(0.0);\n}\n\n// Return camera transform matrix looking from `lookfrom` towards `lookat`, with tilt rotation `tilt`,\n// vertical field of view `vfov` (in degrees), at coords `uv` (in the range [-1,1])\nvec3 get_ray(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n    // camera up vector\n    vec3 vup = vec3(sin(tilt), cos(tilt), 0.0);\n    // camera look direction\n    vec3 lookdir = normalize(lookat - lookfrom);\n    // unit vector in camera x axis\n    vec3 u = cross(lookdir, vup);\n    // unit vector in camera y axis\n    vec3 v = cross(u, lookdir);\n    // vector in camera z axis normalized by the fov\n    vec3 w = lookdir * (1.0 / tan(vfov*PI/360.0));\n    // camera transformation matrix\n    mat3 t = mat3(u, v, w);\n    // camera direction\n    return normalize(t * vec3(uv, 1.0));\n}\n\nvec3 render(vec2 uv) {\n    float theta = PI/4.0 + iTime*0.3;\n    const vec3 lookat = vec3(0.0, 25.0, 0.0);\n    const float lookradius = 55.0;\n    const float lookheight = lookat.y + 10.0;\n    vec3 lookfrom = vec3(lookradius*sin(theta), lookheight, lookradius*cos(theta));\n    vec3 raydir = get_ray(lookfrom, lookat, 0.0, 59.0, uv);\n    Hit hit = ray_march(lookfrom, raydir);\n    vec3 p = lookfrom + raydir * hit.d;\n    if(hit.material > 0)\n        return get_light(raydir, p, hit);\n    else\n        return get_sky_background(raydir);\n}\n\nvec3 render_aa(vec2 uv) {\n#if AA > 1\n    float w = 1.0/iResolution.y;\n    vec3 col = vec3(0.0);\n    for(int n=0; n<AA*AA; ++n) {\n        vec2 o = 2.0*(vec2(float(int(n / AA)),float(int(n % AA))) / float(AA) - 0.5);\n        col += render(uv + o*w);\n    }\n    col /= float(AA*AA);\n    return col;\n#else\n    return render(uv);\n#endif\n}\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragcoord) {\n    // uv coords in range from [-1,1] for y and [-aspect_ratio,aspect_ratio] for x\n    vec2 uv = 2.0 * ((fragcoord-0.5*iResolution.xy) / iResolution.y);\n    // render the entire scene\n    vec3 col = render_aa(uv);\n    // cheap dither\n    col += sin(fragcoord.x*114.0)*sin(fragcoord.y*211.1)/512.0;\n    // set the finished color\n    fragcolor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}