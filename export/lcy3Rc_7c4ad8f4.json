{"ver":"0.1","info":{"id":"lcy3Rc","date":"1713055552","viewed":56,"name":"something with music i guess","username":"Bestenfalls","description":"i ask myseft the same question every morning","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","sound","newbee"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 paletteSecond( float t ) {\n    vec3 a = vec3(0.996,0.741,0.043); // Adjust these color values as desired\n    vec3 b = vec3(0.000,0.671,0.961); // Adjust these color values as desired\n    vec3 c = vec3(1.000,0.969,0.000); // Adjust these color values as desired\n\n    return b + a*sin( 6.28318*(c*t) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Modifiers based on iMouse inputs for the first shader\n    float modifierX1 = iMouse.x / iResolution.x * 0.1;\n    float modifierY1 = iMouse.y / iResolution.y * 0.1;\n    float modifierZ1 = iMouse.z / iResolution.x * 8.0;\n    float modifierW1 = (iMouse.w / iResolution.y) * 2.0 * 3.14159; \n\n    // Sample FFT values from the input texture\n    float fft1 = texture(iChannel0, vec2(0.0/11025.0, 0.8)).r;    \n    float fft2 = texture(iChannel0, vec2(0.0/11025.0, 0.25)).r;   \n    float fft3 = texture(iChannel0, vec2(0.0/11025.0, 0.5)).r;  \n\n    // Modify modifiers based on FFT values\n    float scale1 = 1.0; // Adjust the scale factor for fft1\n    float scale2 = 1.0; // Adjust the scale factor for fft2\n    float scale3 = 8.0; // Adjust the scale factor for fft3\n\n    modifierX1 *= scale1 * fft1; // Adjust modifierX1 based on fft1\n    modifierY1 *= scale2 * fft2; // Adjust modifierY1 based on fft2\n    modifierW1 *= scale3 * fft3; // Adjust modifierZ1 based on fft3\n\n   // modifierX1 *= scale1 * fft1; // Adjust modifierX1 based on fft1\n   // modifierY1 *= scale2 * fft2; // Adjust modifierY1 based on fft2\n   // modifierW1 *= scale3 * fft3; // Adjust modifierZ1 based on fft3\n\n    // Convert to radians for full rotation\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Apply rotation to UV coordinates for the first shader\n    float rotatedX1 = uv.x * cos(modifierW1) - uv.y * sin(modifierW1);\n    float rotatedY1 = uv.x * sin(modifierW1) + uv.y * cos(modifierW1);\n    \n    // Apply rotation to UV coordinates for the second shader\n    float modifierX2 = ((iResolution.x - iMouse.x) / iResolution.x) * 0.1;\n    float modifierY2 = ((iResolution.y - iMouse.y) / iResolution.y) * 0.1;\n    float modifierZ2 = ((iResolution.x - iMouse.z) / iResolution.x) * 4.0;\n    float modifierW2 = (((iResolution.y - iMouse.w) / iResolution.y) * 2.0 * 3.14159);\n\n    float rotatedX2 = uv.x * cos(modifierW2) - uv.y * sin(modifierW2);\n    float rotatedY2 = uv.x * sin(modifierW2) + uv.y * cos(modifierW2);\n    \n    // Create patterns for the first shader\n    float patternX1 = sin(rotatedX1 * modifierZ1 + iTime * modifierX1);\n    float patternY1 = cos(rotatedY1 * modifierZ1 + iTime * modifierX1);\n    float patternZ1 = sin(uv.y + iTime * modifierX1);\n    float patternW1 = cos(uv.x + iTime * modifierX1);\n    \n    // Create patterns for the second shader\n    float patternX2 = sin(rotatedX2 * modifierZ2 + iTime * modifierX2);\n    float patternY2 = cos(rotatedY2 * modifierZ2 + iTime * modifierX2);\n    float patternZ2 = sin(uv.y + iTime * modifierX2);\n    float patternW2 = cos(uv.x + iTime * modifierX2);\n    \n    // Combine the patterns for the first shader\n    float combinedPattern1 = (patternX1 + patternY1 + patternZ1 + patternW1) / 4.0;\n    \n    // Combine the patterns for the second shader\n    float combinedPattern2 = (patternX2 + patternY2 + patternZ2 + patternW2) / 4.0;\n    \n    // Use the combined patterns to modulate color for each shader\n    vec3 col1 = palette(combinedPattern1); // Color for the first shader\n    vec3 col2 = paletteSecond(combinedPattern2); // Color for the second shader using the second palette\n    \n    // Transition fader using iMouse.y\n    float transition = iMouse.y / iResolution.y;\n    \n    // Interpolate between the colors of the two shaders based on the transition\n    vec3 finalColor = mix(col1, col2, transition);\n    \n    // Output final color\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}