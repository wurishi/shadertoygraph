{"ver":"0.1","info":{"id":"stjXRm","date":"1627449006","viewed":92,"name":"Texturing triangle meshes","username":"Envy24","description":"Texturing triangle meshes.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","triangle","uv","barycentric","texturing","mesh","affine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define MX iMouse.x / R.x \n#define MY iMouse.y / R.y \n#define BACKGROUND (vec4(normalize(1.0 - rayDir), 1.0))\n#define TO_RAD 0.017453292519943295\n#define FAR 99999.0\n\nfloat signedTriangleArea(vec3 A, vec3 B, vec3 C) \n{ \n    float determinant = (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y);\n\n    return 0.5 * determinant; \n}\n\n/**/\nvec4 rayTriangleIntersection( \n    vec3 ray,\n    vec3 rayDir, \n    vec3 A,\n    vec3 B,\n    vec3 C) \n{ \n    vec3 normal = normalize(cross(B-A, C-A));\n\n    float denominator = dot(normal, rayDir);\n    float t = dot(A - ray, normal) / denominator;\n    vec3 Q = ray + rayDir*t; // hit point\n\n    vec3 BARY = inverse(mat3(\n                    A.x, A.y, 1.0,\n                    B.x, B.y, 1.0,\n                    C.x, C.y, 1.0)) * vec3(Q.x, Q.y, 1.0);\n\n    return \n        BARY.x >= 0.0 &&    // inside triangle?\n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 &&\n        denominator < 0.0 ? // frontface?\n            vec4(BARY, t) :\n            vec4(0.0, 0.0, 0.0, FAR);\n}\n/**\nvec4 rayTriangleIntersection( \n    vec3 ray,\n    vec3 rayDir, \n    vec3 A,\n    vec3 B,\n    vec3 C) \n{ \n    vec3 normal = normalize(cross(B-A, C-A));\n\n    float denominator = dot(normal, rayDir);\n    float t = dot(A - ray, normal) / denominator;\n    vec3 Q = ray + rayDir*t; // hit point\n\n    float invAreaABC = 1.0 / signedTriangleArea(A,B,C);\n    \n    vec3 BARY;\n    BARY.x = signedTriangleArea(Q, B, C) * invAreaABC;\n    BARY.y = signedTriangleArea(A, Q, C) * invAreaABC;\n    BARY.z = signedTriangleArea(A, B, Q) * invAreaABC;\n\n    return \n        BARY.x >= 0.0 &&    // inside triangle?\n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 &&\n        denominator < 0.0 ? // frontface?\n            vec4(BARY, t) :\n            vec4(0.0, 0.0, 0.0, FAR);\n}\n/**\nvec4 rayTriangleIntersection( \n    vec3 ray,\n    vec3 rayDir, \n    vec3 A,\n    vec3 B,\n    vec3 C) \n{ \n    vec3 normal = normalize(cross(B-A, C-A));\n\n    float denominator = dot(normal, rayDir);\n    float t = dot(A - ray, normal) / denominator;\n    vec3 Q = ray + rayDir*t; // hit point\n\n    if (dot(cross(B-A, Q-A), normal) >= 0.0 && // inside triangle?\n        dot(cross(C-B, Q-B), normal) >= 0.0 && \n        dot(cross(A-C, Q-C), normal) >= 0.0 &&\n        denominator < 0.0)\n        {     \n            float invAreaABC = 1.0 / signedTriangleArea(A,B,C);          \n            float areaQBC = signedTriangleArea(Q, B, C);\n            float areaAQC = signedTriangleArea(A, Q, C);\n            float areaABQ = signedTriangleArea(A, B, Q);\n            \n            vec3 BARYCENTRIC = vec3(areaQBC, areaAQC, areaABQ) * invAreaABC;          \n            return vec4(BARYCENTRIC, t);\n        }\n                            \n    return vec4(0.0, 0.0, 0.0, FAR);\n}\n/**/\n\nvec4 texturedTriangles(vec3 ray, vec3 rayDir)\n{\n    /* VERTICIES */\n    vec3 A = vec3(-1.0, -1.0, 0.1);\n    vec3 B = vec3(1.0, -1.0, -1.0);\n    vec3 C = vec3(1.0, 1.0,  0.1);\n    vec3 D = vec3(-1.0, 1.0, -1.0);\n    /* VERTICIES */\n       \n    /* TEXTURE UV COORDS */\n    vec2 BL = vec2(0.0, 0.0);\n    vec2 BR = vec2(1.0, 0.0);\n    vec2 TL = vec2(0.0, 1.0);\n    vec2 TR = vec2(1.0, 1.0);\n    /* TEXTURE UV COORDS */\n      \n    /* ROTATION */\n    //float rad = 90.0 * TO_RAD; //iTime * 0.3;\n    float rad = iTime * 1.3;\n    A = rotateAroundY(A, rad);\n    B = rotateAroundY(B, rad);\n    C = rotateAroundY(C, rad);\n    D = rotateAroundY(D, rad);\n\n    rad *= 0.3;\n    A = rotateAroundZ(A, rad);\n    B = rotateAroundZ(B, rad);\n    C = rotateAroundZ(C, rad);\n    D = rotateAroundZ(D, rad);\n    /* ROTATION */\n    \n    /* TRIANGLES */\n    vec3 coords[6];\n    // Counterclockwise order\n    coords[0] = A; coords[1] = B; coords[2] = C; // ABC\n    coords[3] = C; coords[4] = D; coords[5] = A; // CDA\n    //coords[0] = C; coords[1] = B; coords[2] = A; // CBA\n    //coords[3] = A; coords[4] = D; coords[5] = C; // ADC\n    \n    vec2 uv[6];\n    uv[0] = BL; uv[1] = BR; uv[2] = TR;\n    uv[3] = TR; uv[4] = TL; uv[5] = BL; \n    /* TRIANGLES */\n    \n    vec4 tc = vec4(0.0);      // (BARYCENTRIC.xyz, distance_to_point)\n    float tMin = FAR;\n    bool hitAnything = false;\n    vec2 st;                  // texture coords\n    \n    for (int n = 0; n < 2; ++n)\n    {\n        int offset = n * 3; // base offset for reading triangle data\n    \n        tc = rayTriangleIntersection(\n            ray,\n            rayDir,\n            coords[offset],\n            coords[offset + 1],\n            coords[offset + 2]);\n        \n        if (tc.w < tMin) // hit?\n        {     \n            tMin = tc.w;\n\n            // Calculate texture coordinates.\n            st = \n                uv[offset] * tc.x +\n                uv[offset + 1] * tc.y +\n                uv[offset + 2] * tc.z;\n\n            hitAnything = true; // True only for frontfaces.\n        }\n    }\n    \n    return hitAnything == true ? texture(iChannel1, st) : BACKGROUND;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n        \n    /* Perspective camera with lookat (Blender). */\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = vec3(0.0, 0.0, 7.0);\n    //camera = rotateAroundY(camera, iTime);\n\n    vec3 f = normalize(lookAt - camera);               // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up     \n    \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = R.x / R.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n               \n    vec3 ray = camera;\n    vec3 rayDir = normalize(uv.x * r + uv.y * u + f * zFocalLength);\n    /* Perspective camera */\n    \n      \n    \n    /* Ortographic camera (Blender). *\n    vec3 lookAt = vec3(0.0, 0.0, 0.0); //(A+B+C) / 9.0;\n    vec3 camera = vec3(0.0, 0.0, 1.0);\n    //camera = rotateAroundY(camera, iTime);\n    \n    vec3 f = normalize(lookAt - camera);                   // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up\n    \n    float aspectRatio = R.x / R.y;\n    float orthographicScale = 5.0;\n    float vpWidth = orthographicScale;\n    float vpHeight = vpWidth / aspectRatio;\n   \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n         \n    vec3 ray = camera + uv.x * r + uv.y * u;\n    vec3 rayDir = f;\n    /* Ortographic camera. */\n    \n    \n    \n    vec4 color = texturedTriangles(ray, rayDir);\n    \n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec3(\n        p.x,\n        p.y * c - p.z * s,\n        p.z * c + p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec3(\n        p.x * c - p.z * s,\n        p.y,\n        p.z * c + p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec3(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s,\n        p.z);\n}","name":"Common","description":"","type":"common"}]}