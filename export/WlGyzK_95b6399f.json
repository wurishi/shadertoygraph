{"ver":"0.1","info":{"id":"WlGyzK","date":"1611293018","viewed":80,"name":"Cow plaque","username":"astronozem","description":"A soothing cow pattern on a round edged plaque. On a green matrix. On a sunday.\nNo wait, it is friday.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["multisampling","cow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// took code from all the shaders, copied and pasted, changed and mangled\n// credits were lost. all is not mine, maybe a little. it is just a toy!\n\nvec2 curve(vec2 uv, float scale)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= scale;\n    uv *= 1.1;\n\tuv.x *= 1.0 + pow((abs(uv.y) / 16.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 9.0), 2.0);\n\tuv /= scale;\n\tuv  = (uv / 2.0) + 0.5;\n\treturn uv;\n}\n\nfloat corner( vec2 pos, const float radius ) \n{\n    pos = (pos - 0.5) * 2.0;\n    pos = abs(pos);\n\tpos.x = pos.x * 2.0 - 1.0;\n    if (min(pos.x, pos.y) < 1.0-radius) \n\t\treturn 1.0;\t\t\n    return \n        float(distance( pos, vec2(1.0-radius) ) < radius);\n}\n\nfloat edges( vec2 pos, const float dist ) \n{\n    pos = (pos - 0.5) * 2.0;\n    pos = abs(pos);\n\tpos.x = pos.x * 2.0 - 1.0;\n    if (min(pos.x, pos.y) > 1.0-dist) \n        return float(distance( pos, vec2(1.0-dist) ) < dist);\n    if ((1.0-pos.y)< 0.0) return 0.;\n    if ((1.0-pos.x)< 0.0) return 0.;\n\treturn 1.0;\n    \n}\n\nvec3 colorGrade(vec3 col, float desat, vec3 colMul, vec3 colAdd)\n{\n\tcol = mix( col, vec3(col.x*0.2126 + col.y*0.7152 + col.z*0.0722), desat);\n    col *= colMul;\n\tcol += colAdd;\n\treturn col;\n}\n\nvec2 rotate(vec2 v, float a, vec2 o)\n{\n  float s = sin(a);\n  float c = cos(a);\n  vec2 p = v - o;\n  p = vec2(p.x * c - p.y * s,  p.x * s + p.y * c);\n  return p + o;\n}\n\nvec3 background(vec2 uv)\n{\n    float g = sin(iTime + uv.x * 241.0);\n    float h = cos(iTime + uv.y * 222.0);\n    g = clamp(g * g * h, -0.2, 1.0);\n    return vec3(0.1,0.3,0.19) * g;\n}\n\nfloat vignette(vec2 u)\n{\n    float x = clamp(u.x, 0., 1.); \n    float y = clamp(u.y, 0., 1.);\n    return x * y * (1.0 - x) * (1.0 - y);\n}\n\n\nvec3 scene(vec2 uv, float scale)\n{\n    if (edges(uv, 0.4)<0.01) return background(uv);\n    float vig = 100.0 * vignette((uv+0.0)-0.0);\n\tfloat vig_pow = clamp(pow(vig, 0.3),0.1,1.0);\n    uv.x /= iResolution.y/iResolution.x;\n    vec2 t = rotate(uv, iTime/66.1, vec2(0.5) + sin(iTime/44.1)*0.2);\n    \n    float s = cos(iTime/ 1.0) + sin(t.x * scale * 2.);\n    float c = sin(iTime/ 9.0) + cos(t.y * scale * 2.);\n    float e = cos(iTime/ 5.0) + sin(3.0 * t.x * scale + iTime * 0.25);\n    float r = sin(iTime/ 7.0) + cos(3.0 * t.y * scale + iTime * 0.25);\n    float g = cos(iTime/ 9.0) + sin(4.0 * t.x * scale + iTime * 0.33);\n    float h = sin(iTime/11.0) + cos(4.0 * t.y * scale + iTime * 0.33);\n    \n    vec3 col = vec3(uv.y*(g*h)+(r*e)+((s*c))>0.5);\n    return col * vig_pow;\n}\n\nvec3 multisampling(vec2 uv, int dim, float scale)\n{\n\tvec3 tex = vec3(0);\n\tfloat s = 1.0 / float(dim);\n\tfloat sx = s / iResolution.x;\n\tfloat sy = s / iResolution.y;\n\tfor (int y = 0; y < dim; y++)\n\t{\n\t\tfloat fy = float(y) * sy;\n\t\tfor (int x = 0; x<dim; x++)\n\t\t{\n\t\t\tfloat fx = float(x) * sx;\n\t\t\ttex += scene( uv + vec2(fx, fy), scale);\n\t\t}\n\t}\n\treturn tex * s * s;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = curve(uv, 1.0);\n    uv = rotate(uv, -0.005, vec2(0.5, 0.5));\n    float scale = 0.2 + (1.0+cos(iTime/10.0))* 3.0;\n    vec3 col = multisampling(uv, 4, scale);\n    col = colorGrade(col, 0.0, vec3(0.9,0.9,0.8), vec3(-0.01,0.0,0.01));\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}