{"ver":"0.1","info":{"id":"7sXSWs","date":"1619584961","viewed":105,"name":"A Room Made for Cats","username":"donnaliu","description":"A room for cats. Inspired by KC Design Studio (Kuan-huan, Liu, Chun-ta, Tsao).\n\nhttp://www.kcstudio.com.tw/work_inside.php?wid=1&w_id=80","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["cis461"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // -------------------- IMPLEMENTION: DEPTH OF FIELD -------------------- \n    const int mSize = 3;\n    const int kSize = (mSize-1) / 2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n\n    float sigma = 1000.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    \n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_color += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, \n                           (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 unblurredColor = texture(iChannel0, uv);\n \n    fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// AO and FIVETAP\nconst int AO_SAMPLES = 256;\nconst int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\n// DEPTH OF FIELD CONSTANTS\nconst float FOCAL_LENGTH = 25.0;\nconst float FOCAL_RANGE = 50.0;\n\n// PENUMBRA SHADOWS CONSTANTS\nconst float SHADOW_HARDNESS = 12.0;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\n// -------------------- ROTATION --------------------\nvec3 rotateX(vec3 p, float d) {\n    float a = d * 3.1415 / 180.;\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);   \n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float d) {\n    float a = d * 3.1415 / 180.;\n    return vec3(cos(a) * p.x - sin(a)* p.y, sin(a) * p.x + cos(a) * p.y, p.z);    \n}\n  \n// -------------------- RAYCAST --------------------\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = rotateY(vec3(0.0, 0, 25.0), 0.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 / 180.0 * 25.0) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n    dir.x = -dir.x;\n}\n\n// -------------------- IMPLEMENTION: SMOOTH BLENDING OF SDFS --------------------\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n \nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n// -------------------- SHAPES --------------------\nfloat cylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat plane(vec3 p, vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// -------------------- IMPLEMENTATION: CSG OPERATIONS ON SDFS --------------------\nfloat opUnion(float d1, float d2) { \n    return min(d1,d2); \n}\n\nfloat opSubtraction(float d1, float d2) { \n    return max(-d1,d2); \n}\n\nvec3 opTwist(in vec3 p)\n{\n    const float k = 10.0;\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\nvec3 opCheapBend(in vec3 p)\n{\n   const float k = 0.1;\n   float c = cos(k * p.x);\n   float s = sin(k * p.x);\n   mat2  m = mat2(c, -s , s, c);\n   vec3  q = vec3(m * p.xy, p.z);\n   return q;\n}\n\n// -------------------- SCENE (1) --------------------\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{        \n    // BEAN BAGS\n    float d1 = sdEllipsoid(pos - vec3(-9.634, -5.621, 6.82), vec3(2.0, 0.8, 2.0));\n    float d2 = sdEllipsoid(pos - vec3(-9.755, -5.6, 6.775), vec3(1.6, 1.0, 1.6));\n    float temp = opSmoothUnion(d1, d2, 0.4);\n    float d3 = sdEllipsoid(pos - vec3(-9.842, -3.871, 6.684), vec3(1.439, 1.0, 1.439));\n    float t = opSmoothSubtraction(d3, temp, 0.6);\n    \n    d1 = sdEllipsoid(pos - vec3(0.415, -5.714, 2.325), vec3(2.1, 0.8, 2.1));\n    d2 = sdEllipsoid(pos - vec3(0.594, -5.6, 2.177), vec3(1.6, 1.0, 1.6));\n    temp = opSmoothUnion(d1, d2, 0.4);\n    d3 = sdEllipsoid(pos - vec3(0.618, -3.987, 2.035), vec3(1.726, 1.0, 1.726));\n    t = min(t, opSmoothSubtraction(d3, temp, 0.4));\n    \n    d1 = sdEllipsoid(pos - vec3(7.796, -5.756, 11.543), vec3(2.0, 1.0, 2.0));\n    d2 = sdEllipsoid(pos - vec3(8.212, -5.6, 11.81), vec3(1.8, 1.0, 1.6));\n    temp = opSmoothUnion(d1, d2, 0.4);\n    d3 = sdEllipsoid(pos - vec3(8.17, -4.066, 12.08), vec3(1.628, 1.0, 1.628));\n    t = min(t, opSmoothSubtraction(d3, temp, 0.6));\n\n    // WALLS\n    d1 = sdRoundBox(pos - vec3(0.0, 0.0, -6.0), vec3(30.0, 30.0, 1.0), 0.01);\n    \n    // WINDOWS\n    d2 = sdRoundBox(pos - vec3(6.844, 3.0, -6.0), vec3(9.0, 10.0, 2.0) / 2.0, 0.01);\n    d3 = opSmoothSubtraction(d2, d1, 0.3);\n    float d4 = sdRoundBox(pos - vec3(-7.407, 6.3, -6.0), vec3(3.862, 3.5, 2.0) / 2.0, 0.01);\n    t = min(t, opSmoothSubtraction(d4, d3, 0.3));\n    \n    // SKY\n    t = min(t, plane(pos - vec3(0, 0.0, -7), vec4(0.0, 0.0, 1.0, 1.0)));\n    \n    // WALLS\n    t = min(t, plane(pos - vec3(-14.0, 0.0, 0.0), vec4(1.0, 0.0, 0.0, 1.0)));\n    t = min(t, plane(pos - vec3(14.0, 0.0, 0.0), vec4(-1.0, 0.0, 0.0, 1.0)));\n    t = min(t, plane(pos - vec3(0.0, 8.0, 0.0), vec4(0.0, -1.0, 0.0, 1.0)));\n    t = min(t, plane(pos - vec3(0.0, -5.0, 0.0), vec4(0.0, 1.0, 0.0, 1.0)));\n    \n    // SEATING PADS\n    t = min(t, sdCappedCylinder(pos - vec3(3.832, -2.479, -4.785), 1.0, 0.1));\n    t = min(t, sdCappedCylinder(pos - vec3(7.341, -2.483, -4.743), 1.0, 0.1));\n    \n    // SWING SET\n    float a = min(t, box(opCheapBend(rotateZ(pos - vec3(6.291, 4.5, 0.9), 0.5 * sin(iTime * 2.0))), \n                    vec3(0.1, 13.0, 0.1) / 2.0));\n    float b = min(t, box(opCheapBend(rotateZ(pos - vec3(6.291, 4.5, 0.9), 0.5 * sin(iTime * 2.0))), \n                    vec3(0.1, 13.0, 0.1) / 2.0));\n    float c = opUnion(a, b);\n    float d = min(t, sdRoundBox(opCheapBend(rotateY(rotateZ(pos - vec3(7.641, -2.1, 2.289), \n                    1.0 * sin(iTime * 2.0)), \n                    -0.785398)), vec3(2.5, 0.2, 5.0) / 2.0, 0.1));\n    t = min(t, opUnion(c, d));\n    \n    // BACK TOP STAIRCASE\n    a = sdRoundBox(pos - vec3(7.603, -4.268, -4.788), vec3(12.831, 3.4, 2.5) / 2.0, 0.01);\n    b = sdRoundBox(pos - vec3(0.385, -3.643, -4.788), vec3(1.6, 4.7, 2.5) / 2.0, 0.01);\n    c = opSmoothUnion(a, b, 0.01);\n    d = sdRoundBox(pos - vec3(-1.209, -2.977, -4.788), vec3(1.6, 6.0, 2.5) / 2.0, 0.01);\n    float e = sdRoundBox(pos - vec3(-2.806, -2.347, -4.788), vec3(1.6, 7.3, 2.5) / 2.0, 0.01);\n    float f = opSmoothUnion(d, e, 0.01);\n    float g = sdRoundBox(pos - vec3(-4.596, -1.8, -4.788), vec3(2.05, 8.65, 2.5) / 2.0, 0.01);\n    float h = sdRoundBox(pos - vec3(-9.44, 3.137, -4.788), vec3(10.0, 1.221, 2.5) / 2.0, 0.01);\n    float i = opSmoothUnion(g, h, 0.01);\n    float j = opSmoothUnion(c, f, 0.01);\n    t = min(t, opSmoothUnion(j, i, 0.01));\n    \n    // BACK BOTTOM STAIRCASE \n    t = min(t, box(pos - vec3(0.0, -4.148, -2.841), vec3(28.0, 1.5, 1.5) / 2.0));\n    t = min(t, box(pos - vec3(0.0, -5.339, -1.444), vec3(28.0, 1.3, 1.6) / 2.0));\n    \n    // LEFT PIECES\n    t = min(t, sdRoundBox(pos - vec3(-14.0, -0.083, 2.281), vec3(2.096, 11.846, 2.554) / 2.0, 0.1));\n    t = min(t, sdRoundBox(pos - vec3(-14.0, 6.026, -1.591), vec3(2.096, 1.232, 8.857) / 2.0, 0.1));\n    \n    // RIGHT PIECES\n    t = min(t, sdRoundBox(pos - vec3(14.2, -1.824, 0.0), vec3(3.5, 8.434, 30.0) / 2.0, 0.1));\n    t = min(t, box(pos - vec3(11.643, -5.339, 7.137), vec3(1.6, 1.3, 15.674) / 2.0));\n    \n    // TOP STAIRCASE\n    a = sdRoundBox(pos - vec3(-7.588, 4.122, 9.517), vec3(0.1, 1.6, 2.0) / 2.0, 0.001);\n    b = sdEllipsoid(pos - vec3(-7.572, 3.912, 9.511), vec3(0.5, 1.3, 1.0) / 2.0);\n    t = min(t, opSubtraction(b, a));\n    t = min(t, box(pos - vec3(-8.348, 4.869, 9.522), vec3(1.6, 0.1, 2.0) / 2.0));\n    t = min(t, box(pos - vec3(-9.108, 5.624, 9.523), vec3(0.1, 1.6, 2.0) / 2.0));\n    t = min(t, box(pos - vec3(-11.521, 6.37, 9.524), vec3(4.915, 0.1, 2.0) / 2.0));\n    t = min(t, box(pos - vec3(-13.5, 6.37, 6.112), vec3(3.0, 0.1, 4.836) / 2.0));\n    \n    // MIDDLE STAIRCASE\n    t = min(t, box(pos - vec3(-13.0, 0.002, 7.056), vec3(4.0, 0.1, 7.04) / 2.0));\n    t = min(t, box(pos - vec3(-10.966, 0.804, 8.578), vec3(0.1, 1.7, 4.0) / 2.0));\n    t = min(t, box(pos - vec3(-10.172, 1.641, 8.564), vec3(1.7, 0.1, 4.0) / 2.0));\n    t = min(t, box(pos - vec3(-9.369, 2.45, 8.559), vec3(0.1, 1.7, 4.0) / 2.0));\n    t = min(t, box(pos - vec3(2.8, 3.305, 8.563), vec3(24.5, 0.1, 4.0) / 2.0));\n    \n    // BOTTOM STAIRCASE\n    t = min(t, box(pos - vec3(-10.962, -0.757, 5.047), vec3(0.1, 1.599, 3.0) / 2.0));\n    t = min(t, box(pos - vec3(-10.13, -1.512, 5.047), vec3(1.6, 0.1, 3.0) / 2.0));\n    t = min(t, box(pos - vec3(-9.3, -2.255, 5.047), vec3(0.1, 1.6, 3.0) / 2.0));\n    t = min(t, box(pos - vec3(-8.55, -3.004, 5.047), vec3(1.6, 0.1, 3.0) / 2.0));\n    t = min(t, box(pos - vec3(-7.799, -3.755, 5.047), vec3(0.1, 1.6, 3.0) / 2.0));\n    t = min(t, box(pos - vec3(-6.973, -4.499, 5.047), vec3(1.6, 0.1, 3.0) / 2.0));\n    t = min(t, box(pos - vec3(-6.227, -5.257, 5.047), vec3(0.1, 1.6, 3.0) / 2.0));\n    \n    return t;\n}\n\n// -------------------- SCENE (2) --------------------\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n    // WALLS\n    float w1 = sdRoundBox(pos - vec3(0.0, 0.0, -6.0), vec3(30.0, 30.0, 1.0), 0.01);\n    \n    // WINDOWS\n    float w2 = sdRoundBox(pos - vec3(6.844, 3.0, -6.0), vec3(9.0, 10.0, 2.0) / 2.0, 0.01);\n    float w3 = opSmoothSubtraction(w2, w1, 0.3);\n    float w4 = sdRoundBox(pos - vec3(-7.407, 6.3, -6.0), vec3(3.862, 3.5, 2.0) / 2.0, 0.01);\n    t = opSmoothSubtraction(w4, w3, 0.3);\n    float t2;\n    obj = 4;\n    \n    // SKY\n    if((t2 = plane(pos - vec3(0, 0.0, -7), vec4(0.0, 0.0, 1.0, 1.0))) < t) {\n        t = t2;\n        obj = 14;\n    }\n    \n    // WALLS\n    if((t2 = plane(pos - vec3(-14.0, 0.0, 0.0), vec4(1.0, 0.0, 0.0, 1.0))) < t) {\n        t = t2;\n        obj = 4;\n    }\n    if((t2 = plane(pos - vec3(14.0, 0.0, 0.0), vec4(-1.0, 0.0, 0.0, 1.0))) < t) {\n        t = t2;\n        obj = 4;\n    }\n    if((t2 = plane(pos - vec3(0.0, 8.0, 0.0), vec4(0.0, -1.0, 0.0, 1.0))) < t) {\n        t = t2;\n        obj = 10;\n    }\n    if((t2 = plane(pos - vec3(0.0, -5.0, 0.0), vec4(0.0, 1.0, 0.0, 1.0))) < t) {\n        t = t2;\n        obj = 5;\n    }\n        \n    // BEAN BAGS\n    float d1 = sdEllipsoid(pos - vec3(-9.634, -5.621, 6.82), vec3(2.0, 0.8, 2.0));\n    float d2 = sdEllipsoid(pos - vec3(-9.755, -5.6, 6.775), vec3(1.6, 1.0, 1.6));\n    float tem = opSmoothUnion(d1, d2, 0.4);\n    float d3 = sdEllipsoid(pos - vec3(-9.842, -3.871, 6.684), vec3(1.439, 1.0, 1.439));\n    float temp = opSmoothSubtraction(d3, tem, 0.6);\n    \n    if((t2 = temp) < t) {\n        t = t2;\n        obj = 1;\n    }\n    \n    d1 = sdEllipsoid(pos - vec3(0.415, -5.714, 2.325), vec3(2.1, 0.8, 2.1));\n    d2 = sdEllipsoid(pos - vec3(0.594, -5.6, 2.177), vec3(1.6, 1.0, 1.6));\n    tem = opSmoothUnion(d1, d2, 0.4);\n    d3 = sdEllipsoid(pos - vec3(0.618, -3.987, 2.035), vec3(1.726, 1.0, 1.726));\n    temp = opSmoothSubtraction(d3, tem, 0.4);\n    \n    if((t2 = temp) < t) {\n        t = t2;\n        obj = 2;\n    }\n    \n    d1 = sdEllipsoid(pos - vec3(7.796, -5.756, 11.543), vec3(2.0, 1.0, 2.0));\n    d2 = sdEllipsoid(pos - vec3(8.212, -5.6, 11.81), vec3(1.6, 1.0, 1.6));\n    tem = opSmoothUnion(d1, d2, 0.4);\n    d3 = sdEllipsoid(pos - vec3(8.17, -4.066, 12.08), vec3(1.628, 1.0, 1.628));\n    temp = opSmoothSubtraction(d3, tem, 0.6);\n    \n    if((t2 = temp) < t) {\n        t = t2;\n        obj = 3;\n    }\n    \n    // SEATING PADS\n    if((t2 = sdCappedCylinder(pos - vec3(3.832, -2.479, -4.785), 1.0, 0.1)) < t) {\n        t = t2;\n        obj = 8;\n    }\n    if((t2 = sdCappedCylinder(pos - vec3(7.341, -2.483, -4.743), 1.0, 0.1)) < t) {\n        t = t2;\n        obj = 9;\n    }\n    \n    // SWING SET\n    float a = min(t, box(opCheapBend(rotateZ(pos - vec3(6.291, 4.5, 0.9), 0.5 * sin(iTime * 2.0))), \n                    vec3(0.1, 13.0, 0.1) / 2.0));\n    float b = min(t, box(opCheapBend(rotateZ(pos - vec3(9.027, 4.5, 3.681), 0.5 * sin(iTime * 2.0))), \n                    vec3(0.1, 13.0, 0.1) / 2.0));\n    float c = opUnion(a, b);\n    float d = min(t, sdRoundBox(opCheapBend(rotateY(rotateZ(pos - vec3(7.641, -2.1, 2.289), \n                    1.0 * sin(iTime * 2.0)), -0.785398)), vec3(2.5, 0.2, 5.0) / 2.0, 0.1));\n    temp = min(t, opUnion(c, d));\n    if((t2 = temp) < t) {\n        t = t2;\n        obj = 7;\n    }\n    \n    // BACK TOP STAIRCASE\n    a = sdRoundBox(pos - vec3(7.603, -4.268, -4.788), vec3(12.831, 3.4, 2.5) / 2.0, 0.01);\n    b = sdRoundBox(pos - vec3(0.385, -3.643, -4.788), vec3(1.6, 4.7, 2.5) / 2.0, 0.01);\n    c = opSmoothUnion(a, b, 0.01);\n    d = sdRoundBox(pos - vec3(-1.209, -2.977, -4.788), vec3(1.6, 6.0, 2.5) / 2.0, 0.01);\n    float e = sdRoundBox(pos - vec3(-2.806, -2.347, -4.788), vec3(1.6, 7.3, 2.5) / 2.0, 0.01);\n    float f = opSmoothUnion(d, e, 0.01);\n    float g = sdRoundBox(pos - vec3(-4.596, -1.8, -4.788), vec3(2.05, 8.65, 2.5) / 2.0, 0.01);\n    float h = sdRoundBox(pos - vec3(-9.44, 3.137, -4.788), vec3(10.0, 1.221, 2.5) / 2.0, 0.01);\n    float i = opSmoothUnion(g, h, 0.01);\n    float j = opSmoothUnion(c, f, 0.01);\n    float k = opSmoothUnion(j, i, 0.01);\n    if((t2 = k) < t) {\n        t = t2;\n        obj = 6;\n    }\n    \n    // BACK BOTTOM STAIRCASE\n    if((t2 = box(pos - vec3(0.0, -4.148, -2.841), vec3(28.0, 1.5, 1.5) / 2.0)) < t) {\n        t = t2;\n        obj = 12;\n    }\n    if((t2 = box(pos - vec3(0.0, -5.339, -1.444), vec3(28.0, 1.3, 1.6) / 2.0)) < t) {\n        t = t2;\n        obj = 12;\n    }\n    \n    // LEFT PIECES\n    if((t2 = sdRoundBox(pos - vec3(-14.0, -0.083, 2.281), vec3(2.096, 11.846, 2.554) / 2.0, 0.1)) < t) {\n        t = t2;\n        obj = 6;\n    }\n    if((t2 = sdRoundBox(pos - vec3(-14.0, 6.026, -1.591), vec3(2.096, 1.232, 8.857) / 2.0, 0.1)) < t) {\n        t = t2;\n        obj = 6;\n    }\n    \n    // RIGHT PIECES\n    if((t2 = sdRoundBox(pos - vec3(14.2, -1.824, 0.0), vec3(3.5, 8.434, 30.0) / 2.0, 0.1)) < t) {\n        t = t2;\n        obj = 11;\n    }\n    if((t2 = box(pos - vec3(11.643, -5.339, 7.137), vec3(1.6, 1.3, 15.674) / 2.0)) < t) {\n        t = t2;\n        obj = 13;\n    }\n    \n    // TOP STAIRCASE\n    a = sdRoundBox(pos - vec3(-7.588, 4.122, 9.517), vec3(0.1, 1.6, 2.0) / 2.0, 0.001);\n    b = sdEllipsoid(pos - vec3(-7.572, 3.912, 9.511), vec3(0.5, 1.3, 1.0) / 2.0);\n    c = min(t, opSubtraction(b, a));\n    if((t2 = c) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-8.348, 4.869, 9.522), vec3(1.6, 0.1, 2.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-9.108, 5.624, 9.523), vec3(0.1, 1.6, 2.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-11.521, 6.37, 9.524), vec3(4.915, 0.1, 2.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-13.5, 6.37, 6.112), vec3(3.0, 0.1, 4.836) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    \n    // MIDDLE STAIRCASE\n    if((t2 = box(pos - vec3(-13.0, 0.002, 7.056), vec3(4.0, 0.1, 7.04) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-10.966, 0.804, 8.578), vec3(0.1, 1.7, 4.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-10.172, 1.641, 8.564), vec3(1.7, 0.1, 4.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-9.369, 2.45, 8.559), vec3(0.1, 1.7, 4.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(2.8, 3.305, 8.563), vec3(24.5, 0.1, 4.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    \n    // BOTTOM STAIRCASE\n    if((t2 = box(pos - vec3(-10.962, -0.757, 5.047), vec3(0.1, 1.599, 3.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-10.13, -1.512, 5.047), vec3(1.6, 0.1, 3.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-9.3, -2.255, 5.047), vec3(0.1, 1.6, 3.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-8.55, -3.004, 5.047), vec3(1.6, 0.1, 3.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-7.799, -3.755, 5.047), vec3(0.1, 1.6, 3.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-6.973, -4.499, 5.047), vec3(1.6, 0.1, 3.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n    if((t2 = box(pos - vec3(-6.227, -5.257, 5.047), vec3(0.1, 1.6, 3.0) / 2.0)) < t) {\n        t = t2;\n        obj = 0;\n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\n// -------------------- NOISE FUNCTIONS --------------------\nfloat random1(float p) {\n    return fract(sin(p * 127.1) * 43758.5453);\n}\n\nfloat random1(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n    vec2 v = fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5,183.3))))\n                                 * 43758.5453f);\n    return v;\n}\n\nfloat surflet(vec2 p, vec2 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec2 t2 = abs(p - gridPoint);\n    vec2 t = vec2(1.f)\n            - 6.f * vec2(pow(t2.x, 5.f), pow(t2.y, 5.f))\n            + 15.f * vec2(pow(t2.x, 4.f), pow(t2.y, 4.f))\n            - 10.f * vec2(pow(t2.x, 3.f), pow(t2.y, 3.f));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a glm::vec2 in the range [0, 1])\n    vec2 gradient = random2(gridPoint) * 2.f - vec2(1,1);\n    // Get the vector from the grid point to P\n    vec2 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y;\n}\n\nfloat perlinNoise(vec2 uv) {\n    vec2 uvXLYL = vec2(floor(uv.x), floor(uv.y));\n    vec2 uvXHYL = uvXLYL + vec2(1, 0);\n    vec2 uvXHYH = uvXLYL + vec2(1, 1);\n    vec2 uvXLYH = uvXLYL + vec2(0, 1);\n\n    float surflet1 = surflet(uv, uvXLYL);\n    float surflet2 = surflet(uv, uvXHYL);\n    float surflet3 = surflet(uv, uvXHYH);\n    float surflet4 = surflet(uv, uvXLYH);\n    float surfletSum = surflet1 + surflet2 + surflet3 + surflet4;\n    return surfletSum;\n}\n\nfloat mySmoothStep(float a, float b, float t) {\n    t = smoothstep(0.f, 1.f, t);\n    return mix(a, b, t);\n}\n\nfloat bilerpNoise(vec2 uv) {\n    vec2 uvFract = fract(uv);\n    float ll = random1(floor(uv));\n    float lr = random1(floor(uv) + vec2(1, 0));\n    float ul = random1(floor(uv) + vec2(0, 1));\n    float ur = random1(floor(uv) + vec2(1, 1));\n\n    float lerpXL = mySmoothStep(ll, lr, uvFract.x);\n    float lerpXU = mySmoothStep(ul, ur, uvFract.x);\n\n    return mySmoothStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.5;\n    float freq = 8.0;\n    float sum = 0.f;\n    for (int i = 0; i < 4; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\n\nfloat worleyNoise1(vec2 uv) {\n    uv *= 1.5; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    uv += fbm(uv / 4.f) * 0.25; // warps mounds\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 0.1; // Minimum distance initialized to max.\n    float minDistSecond = 1.0;\n    for(int y = -1; y <= 4; ++y) {\n        for(int x = -1; x <= 4; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            dist = dist * dist;\n//            minDist = min(minDist, dist);\n            if (dist < minDist) {\n                minDistSecond = minDist;\n                minDist = dist;\n            } else if (dist < minDistSecond) {\n                minDistSecond = dist;\n            }\n        }\n    }\n//    return minDist;\n    float c1 = -1.f;\n    float c2 = 1.f;\n    float height = c1 * minDist + c2 * minDistSecond;\n    float spread = 0.175f;\n    height = max(0.f, height - spread) / (1.0 - spread);\n    float scalar = 0.75;\n    float offset = (1.f - scalar) * fbm(uv); // adds noise in between mounds\n    return height * scalar + offset;\n}\n\nfloat worleyNoise2(vec2 uv) {\n    uv *= 1.5; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    uv += fbm(uv / 4.f) * 0.25; // warps mounds\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 10.0; // Minimum distance initialized to max.\n    float minDistSecond = 1.0;\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            dist = dist * dist;\n//            minDist = min(minDist, dist);\n            if (dist < minDist) {\n                minDistSecond = minDist;\n                minDist = dist;\n            } else if (dist < minDistSecond) {\n                minDistSecond = dist;\n            }\n        }\n    }\n//    return minDist;\n    float c1 = -1.f;\n    float c2 = 1.f;\n    float height = c1 * minDist + c2 * minDistSecond;\n    float spread = 0.175f;\n    height = max(0.f, height - spread) / (1.0 - spread);\n    float scalar = 0.75;\n    float offset = (1.f - scalar) * fbm(uv); // adds noise in between mounds\n    return height * scalar + offset;\n}\n\n// -------------------- MATERIAL --------------------\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view) {\n    float t;\n    switch(hitObj) {\n        case 0:\n        // PINK FRONT\n        t = perlinNoise(vec2(n * p));\n        return vec3(235, 178, 178) / 255.0 + 0.6 * vec3(t);\n        break;\n        case 1:\n        // BEAN BAG 1\n        t = worleyNoise1(vec2(p.z, p.x));\n        return vec3(228, 125, 125) / 255.0 +  vec3(t) * 0.2;\n        break;\n        case 2:\n        // BEAN BAG 2\n        t = worleyNoise1(vec2(p.z, p.x));\n        return vec3(228, 194, 197) / 255.0 +  vec3(t) * 0.2;\n        break;\n        case 3:\n        // BEAN BAG 3\n        t = worleyNoise1(vec2(p.z, p.x));\n        return vec3(228, 150, 150) / 255.0 +  vec3(t) * 0.2;\n        break;\n        case 4:\n        // WALLS \n        t = fbm(vec2(p.x * p.y * p.z, p.z * p.y * p.x));\n        return vec3(252, 232, 225) / 255.0 +  vec3(t) * 0.1;\n        break;\n        case 5:\n        // FLOOR\n        t = worleyNoise1(vec2(p.x * p.y, p.x * p.y));\n        return vec3(228, 171, 144) / 255.0 - vec3(t) * 0.3;\n        break;\n        case 6:\n        // PINK BACK \n        t = fbm(vec2(p.x, p.y * p.z));\n        return vec3(250, 170, 170) / 255.0 - vec3(t) * 0.1;\n        break;\n        case 7:\n        // SWINGS\n        t = worleyNoise1(vec2(p.x * p.z, p.x * p.y * p.z));\n        return vec3(252, 214, 177) / 255.0 * max(0.0, dot(n, light));\n        break;\n        case 8:\n        // SEATING PAD 1\n        return vec3(1.5, 1.2, 1.2) * max(0.0, dot(n, light));\n        break;\n        case 9:\n        // SEATING PAD 2\n        return vec3(1.5, 1.3, 1.3) * max(0.0, dot(n, light));\n        break;\n        case 10:\n        // CEILING\n        t = perlinNoise(vec2(p.x * p.y * p.z, p.z * p.y * p.x));\n        return vec3(252, 232, 225) / 255.0 - vec3(t) * 0.03;\n        break;\n        case 11:\n        // POLKA DOT RIGHT LARGE\n        t = worleyNoise2(vec2(p.y, p.z));\n        if (t > 0.7) {\n            return vec3(0.99, 0.99, 0.99) - 1.5 * t * vec3(170, 190, 200) / 255.0;\n        } else if (t > 0.3) {\n            return vec3(0.9, 0.8, 0.8) - 0.6 * t * vec3(5, 50, 30) / 255.0;\n        } else if (t > 0.1) {\n            return vec3(1.0, 1.0, 1.0) - 0.5 * t * vec3(181, 181, 181) / 255.0;\n        }\n        break;\n        case 12:\n        // POLKA DOT BACK\n        t = worleyNoise2(vec2(p.x, p.y));\n        if (t > 0.7) {\n            return vec3(0.99, 0.99, 0.99) - 1.5 * t * vec3(170, 190, 200) / 255.0;\n        } else if (t > 0.3) {\n            return vec3(0.9, 0.8, 0.8) - 0.6 * t * vec3(5, 50, 30) / 255.0;\n        } else if (t > 0.1) {\n            return vec3(1.0, 1.0, 1.0) - 0.5 * t * vec3(181, 181, 181) / 255.0;\n        }\n        break;\n        case 13:\n        // POLKA DOT RIGHT SMALLER\n        t = worleyNoise2(vec2(p.y, p.z));\n        if (t > 0.7) {\n            return vec3(0.99, 0.99, 0.99) - 1.5 * t * vec3(170, 190, 200) / 255.0;\n        } else if (t > 0.3) {\n            return vec3(0.9, 0.8, 0.8) - 0.6 * t * vec3(5, 50, 30) / 255.0;\n        } else if (t > 0.1) {\n            return vec3(1.0, 1.0, 1.0) - 0.5 * t * vec3(181, 181, 181) / 255.0;\n        }\n        case 14:\n        // SKY\n        t = fbm(vec2(p.x, p.y));\n        return vec3(159, 184, 224.0) * 2.4 / 255.0 - sin(iTime * 0.5) * t * (vec3(255.0) - vec3(91, 107, 133)) / 255.0;\n        break;\n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\n// -------------------- IMPLEMENTATION: PENUMBRA SHADOWS --------------------\nfloat hardShadow(vec3 dir, vec3 origin, float min_t, vec3 lightPos) {\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir, lightPos);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        t += m;\n    }\n    return 1.0;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float max_t, float k, vec3 lightPos) {\n    float res = 1.0;\n    for(float t = min_t; t < max_t;) {\n        float m = sceneMap3D(origin + t * dir, lightPos);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k, vec3 lightPos) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST, lightPos));\n    }\n    return 1.0 - k * aoSum;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;        \n    vec3 normal = computeNormal(isect, lightPos);\n        \n    vec3 color = computeMaterial(hitObj, isect, normal, normalize(lightPos - isect), normalize(eye - isect));\n    if (hitObj == -1) {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    \n    return Intersection(t, color, isect, hitObj);\n}\n\n// -------------------- IMPLEMENTATION: AMBIENT OCCLUSION --------------------\nfloat ambientOcclusion(vec3 p, vec3 n, float delta, vec3 lightPos) {\n    float sum = 0.;\n    int i = 1;\n    \n    while (i <= 5) {\n        vec3 pos = p + n * float(i) * delta;\n        float denom = pow(2., float(i));\n        sum += (float(i) * delta - sceneMap3D(pos, lightPos)) / denom; \n        i++;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 lightPos1 = vec3(-5, 3, 15);\n    vec3 lightPos2 = vec3(-5, -3.0, 0.0);\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            idx++;\n            aaIsects[idx] = sdf3D(dir, eye, lightPos1);\n        }\n    }\n    \n    float distCamZ = abs(dot(normalize(ref - eye), (aaIsects[0].p - eye)));\n    float dof = min(1., abs(distCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n    \n    vec3 sumColor = vec3(0);\n    for (int i = 0; i < 2; i++) {    \n        vec3 lightVec = lightPos1 - aaIsects[i].p;\n        float shadow = softShadow(normalize(lightVec), aaIsects[i].p, .01, length(lightVec), 100.0, lightPos1);\n        float sum = ambientOcclusion(aaIsects[i].p, computeNormal(aaIsects[i].p, lightPos1), .15, lightPos1);\n        float ao = 1. - 2. * sum;\n\t\tsumColor += 0.8 * ao * shadow * aaIsects[i].color;\n    }\n    for (int i = 0; i < 2; i++) {    \n        vec3 lightVec = lightPos2 - aaIsects[i].p;\n        float shadow = softShadow(normalize(lightVec), aaIsects[i].p, .01, length(lightVec), 50.0, lightPos2);\n        float sum = ambientOcclusion(aaIsects[i].p, computeNormal(aaIsects[i].p, lightPos2), .15, lightPos2);\n        float ao = 1. - 2. * sum;\n\t\tsumColor += 0.8 * ao * aaIsects[i].color;\n    }\n    fragColor = vec4(sumColor / 2.0, dof);\n}","name":"Buffer A","description":"","type":"buffer"}]}