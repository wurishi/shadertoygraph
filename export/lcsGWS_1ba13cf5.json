{"ver":"0.1","info":{"id":"lcsGWS","date":"1703482500","viewed":42,"name":"Sparse Voxel Octree 00","username":"dannyHallo","description":"forked from https://www.shadertoy.com/view/3d2XRd\nSimple Octree Builder: https://github.com/dannyHallo/SvoShaderLab","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voxel","octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/3d2XRd\n\nconst float root_size = 1.0;\nconst int MAX_ITER    = 100;\nconst uint kMaxLevels = 10u;\n\nconst uint voxel_buffer[] = uint[](0x00010100u,\n                                   0x00020100u,\n                                   0x0003FF00u,\n                                   0x000B0100u,\n                                   0x000C0200u,\n                                   0x000D0400u,\n                                   0x000E0800u,\n                                   0x000F1000u,\n                                   0x00102000u,\n                                   0x00114000u,\n                                   0x00128000u,\n                                   0x00130100u,\n                                   0x00140200u,\n                                   0x00150400u,\n                                   0x00160800u,\n                                   0x00171000u,\n                                   0x00182000u,\n                                   0x00194000u,\n                                   0x001A8000u,\n                                   0x001BFFFFu,\n                                   0x0023FFFFu,\n                                   0x002BFFFFu,\n                                   0x0033FFFFu,\n                                   0x003BFFFFu,\n                                   0x0043FFFFu,\n                                   0x004BFFFFu,\n                                   0x0053FFFFu);\n\nconst float[] scale_lookup = float[](1., .5, .25, .125, .0625, .03125, .15625, 0.078125);\n\n// returns t0 and t1, also fills tmid and tmax\nbool isect(out float tcmin,\n           out float tcmax,\n           out vec3 tmid,\n           out vec3 tmax,\n           vec3 pos,\n           float size,\n           vec3 rayPos,\n           vec3 rayDir) {\n  vec3 halfSize  = vec3(0.5 * size);\n  vec3 minCorner = pos - halfSize;\n  vec3 maxCorner = pos + halfSize;\n\n  // xyz components of t for the ray to get to the 3 planes of minCorner\n  vec3 t1 = (minCorner - rayPos) / rayDir;\n  // xyz ...\n  vec3 t2   = (maxCorner - rayPos) / rayDir;\n  vec3 tmin = min(t1, t2);\n  tmax      = max(t1, t2);\n  tmid      = (tmin + tmax) * 0.5;\n\n  tcmin = max(tmin.x, max(tmin.y, tmin.z));\n  tcmax = min(tmax.x, min(tmax.y, tmax.z));\n\n  return tcmin <= tcmax && tcmax > 0.0;\n}\n\n// the best method for counting digit 1s in a 32 bit uint in parallel\n// https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\nuint bitCount(uint v) {\n  const uint S[] = uint[](1u, 2u, 4u, 8u, 16u); // Magic Binary Numbers\n  const uint B[] = uint[](0x55555555u, 0x33333333u, 0x0F0F0F0Fu, 0x00FF00FFu, 0x0000FFFFu);\n\n  uint c = v - ((v >> 1) & B[0]);\n  c      = ((c >> S[1]) & B[1]) + (c & B[1]);\n  c      = ((c >> S[2]) + c) & B[2];\n  c      = ((c >> S[3]) + c) & B[3];\n  c      = ((c >> S[4]) + c) & B[4];\n  return c;\n}\n\nuint countOnesInLastN(uint value, uint n) {\n  uint mask         = 0xFFu >> (8u - n);\n  uint relevantBits = value & mask;\n  return bitCount(relevantBits);\n}\n\nvoid fetch_voxel_buffer(out uint next_byte_offset,\n                        out bool has_voxel,\n                        out bool is_leaf,\n                        uint byte_offset,\n                        uint bit_offset) {\n  uint voxel_node = voxel_buffer[byte_offset];\n  // 16: group offset\n  next_byte_offset = voxel_node >> 16;\n  // 8: child mask\n  uint voxel_child_mask = (voxel_node & 0x0000FF00u) >> 8;\n  // 8: leaf mask\n  uint voxel_leaf_mask = voxel_node & 0x000000FFu;\n\n  has_voxel = (voxel_child_mask & (1u << bit_offset)) != 0u;\n  is_leaf   = (voxel_leaf_mask & (1u << bit_offset)) != 0u;\n\n  if (has_voxel) {\n    // bit_offset range: 0-7, so the last n range is 1-8, so we need to +1\n    // the first bit '1' indicates a delta of 0, so we need to -1\n    next_byte_offset += countOnesInLastN(voxel_child_mask, bit_offset + 1u) - 1u;\n  }\n}\n\n// returns true if hit, false if miss\nvec4 trace(out bool hit,\n           out float tcmin,\n           out float tcmax,\n           out vec3 pos,\n           out int iter_used,\n           out float size,\n           in vec3 rayPos,\n           in vec3 rayDir) {\n  const vec4 kBlack   = vec4(0.0, 0.0, 0.0, 1.0);\n  const vec4 kRed     = vec4(1.0, 0.0, 0.0, 1.0);\n  const vec4 kGreen   = vec4(0.0, 1.0, 0.0, 1.0);\n  const vec4 kBlue    = vec4(0.0, 0.0, 1.0, 1.0);\n  const vec4 kMagenta = vec4(0.5, 0.2, 0.5, 1.0);\n\n  struct ST\n  {\n    vec3 pos;\n    int scale; // size = root_size * exp2(float(-scale)), we used a loopup table\n               // to get the size\n    vec3 idx;\n    uint ptr;\n    float h;\n  } stack[kMaxLevels];\n\n  int stack_ptr = 0;\n  hit           = false;\n\n  // STEP 1: initialize\n\n  size          = root_size;\n  vec3 root_pos = vec3(0);\n  pos           = root_pos;\n  vec3 tmid, tmax;\n  bool can_push               = true;\n  bool is_intersect_with_root = isect(tcmin, tcmax, tmid, tmax, pos, size, rayPos, rayDir);\n  if (!is_intersect_with_root) {\n    return kBlack;\n  }\n\n  float h = tcmax;\n\n  // initial [PUSH], determine the first hited child (direct child of root node)\n  // for x component, if tcmin < tmid.x, idx.x reverts the ray dir in x axis,\n  // same for y and z\n  vec3 idx = mix(-sign(rayDir), sign(rayDir), step(tmid, vec3(tcmin)));\n\n  uint byte_offset = 0u;\n  int scale        = 1;\n  size *= 0.5;\n\n  // move to first hitted sub-cell center\n  pos += 0.5 * size * idx;\n\n  iter_used = 0;\n  while (iter_used++ < MAX_ITER) {\n    // transform idx from [-1, 1] to [0, 1]\n    vec3 idx01      = idx * .5 + .5;\n    uint bit_offset = uint(dot(idx01, vec3(1., 2., 4.))); // 0-7\n\n    uint next_byte_offset;\n    bool has_voxel, is_leaf;\n    fetch_voxel_buffer(next_byte_offset, has_voxel, is_leaf, byte_offset, bit_offset);\n\n    isect(tcmin, tcmax, tmid, tmax, pos, size, rayPos, rayDir);\n\n    // [PUSH] repeatedly, until empty voxel is found\n    // when pushed layer reached the same level as the smallest voxel, stop\n    // and return (this is temporary solution for finding the leaf)\n    if (can_push && has_voxel) {\n      // hits the leaf\n      if (is_leaf) {\n        hit = true;\n        // return vec4(vec3(exp(-tcmin)), 1.0);\n        return kGreen;\n      }\n\n      // tcmax is current voxel's exist time, h is parent voxel exist time\n      if (tcmax < h) {\n        stack[stack_ptr++] = ST(pos, scale, idx, byte_offset, h);\n      }\n\n      h = tcmax;\n      scale++;\n      size *= 0.5;\n\n      // step: for element i of the return value, 0.0 is returned if x[i] <\n      // edge[i], and 1.0 is returned otherwise.\n      idx = mix(-sign(rayDir), sign(rayDir), step(tmid, vec3(tcmin)));\n\n      byte_offset = next_byte_offset;\n\n      pos += 0.5 * size * idx;\n      continue;\n    }\n\n    // save the previous idx\n    vec3 old = idx;\n\n    // this is genius, for the hitted direction, if hit point is in the\n    // middle, we advance to the other side, because this uses the direction\n    // directly (not increment / bit flipping), if the next bit is outside of\n    // the parent voxel, old will be equal to idx\n    idx = mix(idx, sign(rayDir), equal(tmax, vec3(tcmax)));\n\n    // idx has not changed -> [POP]\n    if (idx == old) {\n      // if poped all the way to the root\n      // if (stack_ptr == 0 || scale == 0)\n      if (stack_ptr == 0)\n        return kMagenta;\n\n      ST s        = stack[--stack_ptr]; // restore to parent Stack\n      pos         = s.pos;\n      scale       = s.scale;\n      size        = root_size * scale_lookup[scale];\n      idx         = s.idx;\n      byte_offset = s.ptr;\n      h           = s.h;\n\n      // once stack pop out,get rid out pushing in again\n      can_push = false;\n    }\n    // idx has changed -> [ADVANCE]\n    else {\n      // if old = idx → stay,else → move forward in this stack\n      pos += mix(vec3(0.), sign(rayDir), notEqual(old, idx)) * size;\n      can_push = true;\n    }\n  }\n  return kBlack;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n  float sinA = sin(a);\n  float cosA = cos(a);\n  return vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\n}\n\nvoid rayGen(out vec3 rayPos, out vec3 rayDir, vec2 uv) {\n  // [-1, 1] in both axis\n  vec2 screenPos = uv * 2.0 - 1.0;\n\n  vec3 cameraDir    = vec3(0.0, 0.0, 1.0);\n  vec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n  vec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\n  rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\n  const float kFloatingFreq = 2.0;\n  const float kFloatingAmp  = 0.15;\n  const float kOrbitingDist = 2.2;\n  rayPos                    = vec3(0.0, kFloatingAmp * sin(iTime * kFloatingFreq), -kOrbitingDist);\n\n  // rotate camera to orbit the object with time\n  const float kMouseSensitivity = 1e-2 * 2.0;\n  float mouseVal                = -iMouse.x * kMouseSensitivity;\n  rayPos.xz                     = rotate2d(rayPos.xz, mouseVal);\n  rayDir.xz                     = rotate2d(rayDir.xz, mouseVal);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // step 1: ray gen\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec3 rayPos, rayDir;\n  rayGen(rayPos, rayDir, uv);\n\n  // step 2: ray march\n  float tcmin, tcmax;\n  bool hit;\n  vec3 pos;\n  float size;\n  int iter_used;\n  fragColor = trace(hit, tcmin, tcmax, pos, iter_used, size, rayPos, rayDir);\n\n  // customized shading\n  if (hit) {\n    fragColor = vec4(vec3(float(iter_used) / 10.0), 1.0);\n    // fragColor = vec4(vec3(exp(-tcmin)), 1.0);\n  }\n}","name":"Image","description":"","type":"image"}]}