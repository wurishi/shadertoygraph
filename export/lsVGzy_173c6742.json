{"ver":"0.1","info":{"id":"lsVGzy","date":"1455221548","viewed":459,"name":"First attempt at making snow","username":"twbmsp","description":"It isn't pretty but it's fast (at least on my old 40$ GPU where it runs at 60fps)...maybe I should try to add some layers at some point. :/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fast","random","snow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159;\n\nconst float FALL_SPEED = 0.27;\n\nconst float W = 21.0;\n\nconst float H = 9.0;\n\nconst vec3 SNOW = vec3(255.0, 255.0,255.0) / 255.0;\nconst vec3 BACK = vec3(21.0, 21.0, 35.0) / 255.0;\n\nfloat static_rand(vec2 seed)\n{\n    return fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(const float timeShift, const float index, const float timeStep)\n{\n    float f = floor((iTime + timeShift) / timeStep);\n    \n    vec2 v = vec2(mod(f + index, iResolution.y),\n                  mod(f - index, iResolution.x));\n    \n    return static_rand(v);\n}\n\nfloat continuousRand(const float index, const float timeStep)\n{\n    float c00 = 0.5 *       rand(0.0     , index, timeStep);\n    float c10 = 0.5 *       rand(timeStep, index, timeStep);\n    float c01 = 2.0 * PI  * rand(0.0     , index + 0.5, timeStep);\n    float c11 = 2.0 * PI  * rand(timeStep, index + 0.5, timeStep);\n    \n    float t = 0.5 + 0.5 * sin(PI * (fract(iTime / timeStep) - 0.5));\n    \n    return (1.0 - t) * c00 * sin(iTime / timeStep + c01) +\n                  t  * c10 * sin(iTime / timeStep + c11);\n    \n}\n\nvec2 plot(float i, float j)\n{\n    float x = (i + 0.5) / W;\n    float y = (j + 0.5) / H;\n    \n    y -= iTime * FALL_SPEED;\n    \n    float dx = 0.65 * continuousRand(j * W + i, 5.0);\n    float dy = 0.65 * continuousRand(i * H + j, 5.0);\n    \n    dx = sin(dx * 0.5 * PI);\n    dy = sin(dy * 0.5 * PI);\n    dx = sin(dx * 0.5 * PI);\n    dy = sin(dy * 0.5 * PI);\n    dx = sin(dx * 0.5 * PI);\n    dy = sin(dy * 0.5 * PI);\n    \n    float fx = max(0.0, 0.7 - abs(dx));\n    float fy = max(0.0, 0.7 - abs(dy));\n    \n    dx += 3.0 * fx * continuousRand(i * W + j * H, 1.5);\n    dy += 3.0 * fy * continuousRand(i * H + j * W, 2.0);\n    \n    x += dx * 0.5 / W;\n    y += dy * 0.5 / H;\n\n    return vec2(x, fract(y));\n}\n\nvec2 distanceField(vec2 p)\n{\n    float rj = (p.y + iTime * FALL_SPEED) * H;\n    \n    float i = p.x * W;\n    float j = mod(rj, H);\n    \n    float fi = floor(i);\n    float fj = floor(j);\n    \n    float rd = static_rand(vec2(fi * W + floor(rj), 0.0));    \n    float sr = 1.0 + sign(rd - 0.65); \n    \n    float theta = 4.0 * PI * continuousRand(fi * W + fj, 1.0);\n    float s1 = continuousRand(fi * W + fj * H, 1.1);\n    float s2 = continuousRand(fj * H + fi, 0.2);\n    \n    mat2 rot2 = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    \n    vec2 d = p - plot(fi,fj);\n    \n    d *= rot2;\n    \n    d.x /= pow((1.0 - abs(s1)), 0.3);\n    d.y /= 2.0 * pow(abs(s1), 0.3);\n    \n    float fieldx = sr + length(d) * (1.1 + pow(rd, 0.3));\n     \n    float fieldy = pow(abs(s2), 0.4);\n    \n    return vec2(fieldx, fieldy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    vec2 df = distanceField(p);\n    \n    float o = smoothstep(0.0, 0.009, df.x);\n    \n\tfragColor = vec4(o * BACK + (1.0 - o) * (BACK * df.y + SNOW * (1.0 - df.y)), 1.0);\n}","name":"Image","description":"","type":"image"}]}