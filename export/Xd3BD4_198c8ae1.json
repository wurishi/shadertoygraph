{"ver":"0.1","info":{"id":"Xd3BD4","date":"1525045105","viewed":133,"name":"Red Spot","username":"oalpha","description":"A red circle on top of a regular grid distorted by fractal perlin noise.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","domain","distortion","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 warp(\n    in vec3 p,\n    out vec3 q,\n    int warpsteps,\n    float warpfactor,\n    int fractalsteps,\n    float res,\n    float scale,\n    float scaleStep,\n    vec3 feedback,\n    mat4 ds,\n    vec4 ss\n);\nfloat grid(vec2 p, float size, float width) {\n    p = fract(p * size);\n    float gx = smoothstep(0.0, width, p.x) -\n        smoothstep(1.0 - width, 1.0, p.x);\n    float gy = smoothstep(0.0, width, p.y) -\n        smoothstep(1.0 - width, 1.0, p.y);\n    return gx * gy;\n}\nfloat inside(vec2 st, float target, float tolerance){\n  return 1.0 - smoothstep( target, target+tolerance / 2.0, st.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 dotseed = mat4(\n        84.4239141, 72.1623789, 54.2539214, 94.8233014,\n        45.8097063, 19.6603408, 41.9881591, 17.7513314,\n        70.6492482, 72.8228071, 31.9941736, 29.7793959,\n        68.9614210, 33.3000043, 38.8602285, 67.0907920\n    );\n    mat4 sineseed = mat4(\n        8442.39141, 7216.23789, 5425.39214, 9482.33014,\n        4580.97063, 1966.03408, 4198.81591, 1775.13314,\n        7064.92482, 7282.28071, 3199.41736, 2977.93959,\n        6896.14210, 3330.00043, 3886.02285, 6709.07920\n    );\n    vec2 st = 2.0 * gl_FragCoord.xy/iResolution.xy - 1.0;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 st3 = vec3(st, iTime * 0.05);\n    vec3 q = vec3(0.0);\n    vec3 st3p = st3 + warp(\n        st3, // vec3 p\n        q, // vec3 q\n        0, // int warpsteps\n        //1.0, // float warpfactor\n        0.2, // float warpfactor\n        7, // int fractalsteps\n        0.5, // float res\n        1.0, // float scale\n        2.0, // float scaleStep\n        vec3(0.0), // vec3 feedback\n        dotseed, // mat4 ds\n        sineseed[0] // vec4 ss\n    );\n    vec2 tr = vec2(atan(st3p.y, st3p.x), length(st3p.xy));\n    float target = cos(12.0 * tr.x + iTime) * 0.01 + 0.4;\n    float line = inside(tr,target, 0.05);\n    fragColor = vec4(vec3(grid(st3p.xy, 10.0, 0.1) * (1.0 - vec3(line)) + vec3(line, vec2(0.0))), 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}\nfloat rand(float f, float o, float r, vec4 ss) {\n  return o + r * fract(sin(f * ss.x + ss.y) * ss.z + ss.z);\n}\nvec4 rand4(vec4 v, float o, float r, mat4 d, vec4 s) {\n    return vec4(\n        rand(dot(v, d[0]), o, r, s),\n        rand(dot(v, d[1]), o, r, s),\n        rand(dot(v, d[2]), o, r, s),\n        rand(dot(v, d[3]), o, r, s)\n    );\n}\nvec3 rand3Rot(vec3 v, mat4 ds, vec4 ss) {\n  float x = rand(dot(v, ds[1].xyz), 0.0, 2.0 * 3.14159265358, ss);\n  float y = rand(dot(v, ds[2].xyz), 0.0, 2.0 * 3.14159265358, ss);\n  float z = rand(dot(v, ds[3].xyz), 0.0, 2.0 * 3.14159265358, ss);\n    //*\n  return mat3(\n      1.0, 0.0, 0.0,\n      0.0, cos(x), -sin(x),\n      0.0, sin(x), cos(x)\n  ) * mat3(\n      cos(y), 0.0, sin(y),\n      0.0, 1.0, 0.0,\n      -sin(y), 0.0, cos(y)\n  ) * mat3(\n      cos(z), -sin(z), 0.0,\n      sin(z), cos(z), 0.0,\n      0.0, 0.0, 1.0\n  ) * vec3(1.0, 0.0, 0.0);\n}\nfloat mix1(float x, float y, float a) {\n  return (1.0 - a) * x + a * y;\n}\nfloat curve3(float a) {\n  return a * a * (3.0 - 2.0 * a);\n}\nfloat mix3(float x, float y, float a) {\n  return mix1(x, y, curve3(a));\n}\nfloat perlinGradient(vec3 pos, mat4 ds, vec4 ss) {\n  vec3 F = fract(pos);\n    vec3 a = floor(pos)\n        , h = ceil(pos)\n        , b = vec3(a.xy, h.z)\n        , c = vec3(a.x, h.y, a.z)\n        , d = vec3(a.x, h.yz)\n        , e = vec3(h.x, a.yz)\n        , f = vec3(h.x, a.y, h.z)\n        , g = vec3(h.xy, a.z);\n  float nnn = dot(rand3Rot(a, ds, ss), pos - a), nnp = dot(rand3Rot(b, ds, ss), pos - b);\n  float npn = dot(rand3Rot(c, ds, ss), pos - c), npp = dot(rand3Rot(d, ds, ss), pos - d);\n  float pnn = dot(rand3Rot(e, ds, ss), pos - e), pnp = dot(rand3Rot(f, ds, ss), pos - f);\n  float ppn = dot(rand3Rot(g, ds, ss), pos - g), ppp = dot(rand3Rot(h, ds, ss), pos - h);\n  float nn = mix3(nnn, nnp, F.z), np = mix3(npn, npp, F.z);\n  float pn = mix3(pnn, pnp, F.z), pp = mix3(ppn, ppp, F.z);\n  float n = mix3(nn, np, F.y), p = mix3(pn, pp, F.y);\n  return mix3(n, p, F.x);\n}\nfloat fractalNoise(vec3 p, int steps, float res, float scale, float scaleStep, vec3 feedback, mat4 dotseed,  vec4 sineseed) {\n    float value = 0.0;\n    vec4 f = sineseed;\n    for(int i = 0; i < 10; i++) {\n        if(i < steps) {\n            f = rand4(f, 12345.6789012, 32109.8765432, dotseed, sineseed);\n            value += 3.0 * perlinGradient(feedback * value + vec3(p.xy / res, p.z), dotseed, f) / scale;\n            scale = scale * scaleStep;\n            res = res / scaleStep;\n        }\n    }\n    return value * 0.5 + 0.5;\n}\nvec3 warp(\n    in vec3 p,\n    out vec3 q,\n    int warpsteps,\n    float warpfactor,\n    int fractalsteps,\n    float res,\n    float scale,\n    float scaleStep,\n    vec3 feedback,\n    mat4 ds,\n    vec4 ss\n) {\n    q.x = -1.0 + 2.0 * fractalNoise( p + vec3(0.0), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n    q.y = -1.0 + 2.0 * fractalNoise( p + vec3(5.2,1.3,2.4), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n    q.z = -1.0 + 2.0 * fractalNoise( p + vec3(1.2,6.5,3.7), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n\n    vec3 r = vec3(0.0);\n      r.x = -1.0 + 2.0 * fractalNoise( p + warpfactor*q + vec3(1.7,9.2,3.1), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n      r.y = -1.0 + 2.0 * fractalNoise( p + warpfactor*q + vec3(8.3,2.8,5.7), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n      r.z = -1.0 + 2.0 * fractalNoise( p + warpfactor*q + vec3(6.1,3.2,9.1), fractalsteps, res, scale, scaleStep, feedback, ds, ss );\n\n    return warpfactor*r;\n  }","name":"Image","description":"","type":"image"}]}