{"ver":"0.1","info":{"id":"3lKSWz","date":"1582572639","viewed":81,"name":"another truchet","username":"NivBehar","description":"truchet","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//to do:\n\n// mode = 0. for a convenient environment to develop\n// mode = 1. for a regular environment\n# define mode 1.\n\n# define MaxSteps 200\n# define MaxDist 40.\n# define time iTime\n# define PI 3.141592654\n\nfloat camSpeed() {return mode*.3*time;}\nfloat pipeSpeed() {return 0.*15.*time;}\nfloat Hash21(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(a.y*a.z*a.x);\n}\n// ---------------------------------------------------------------------------\nfloat torusFlag(vec3 p, vec2 r, bool rot, float checker)\n{\n    float x = atan(p.x, p.z)/(PI*0.5);\n    float y = atan(length(p.xz)-r.x, p.y)/PI*0.5 + 0.5;\n    if(rot == true)\n        y += 0.5;\n    vec2 torUV = vec2(x,y);\n    float a = torUV.x*5.*PI + + PI* 0.5 + PI*(rot == true? 0.5: 1.5);\n    float flag = sin(a + 0.*time*5.*checker);\n    flag *= 0.02;\n    return flag;    \n}\n// ---------------------------------------------------------------------------\nvec2 GetTorusUV(vec3 p, vec2 r, bool rot, float checker)\n{\n\tfloat flag = torusFlag(p, r, rot, checker);\n    float x = atan(p.x, p.z)/(PI*0.5);\n    float y = atan(length(p.xz)-r.x - flag, p.y)/PI*0.5 + 0.5;\n    if(rot == true)\n        y += 0.5;\n    return vec2(x,y);    \n}\n// ---------------------------------------------------------------------------\nfloat sdTorus(vec3 p, vec2 r, bool rot, float checker)\n{\n    float flag = torusFlag(p, r, rot, checker);\n    return length(vec2(length(p.xz) - r.x - flag, p.y) ) - r.y;\n}\n// ---------------------------------------------------------------------------\nvec3 spherePos() {\n    return vec3(0.,1.2 + 0.3*sin(time),0.);\n}\n// ---------------------------------------------------------------------------\nfloat Hash31(vec3 p)\n{\n    vec3 a = fract(p*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return (a.x*a.y*a.z);\n}\n// ---------------------------------------------------------------------------\nfloat sdBox2(vec3 p, vec3 s, float speed) \n{\n  vec3 a = vec3(0.05*sin(p.y*p.z*3. + speed), 0.,0.);\n  vec3 q = abs(p + a.xyy) - s - s*0.5*a.xyx;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n// ---------------------------------------------------------------------------\nfloat GetWaves(vec3 p)\n{\n    float waves =  0.05*sin(p.z*1.76+ 2.12*p.x)*cos(p.z + p.x*3.321) \n        \t\t   + 0.1*sin(p.x*2.571 + p.z*2.512)\n                   + (0.5 + 0.5*sin(p.x*1. + p.z*4.))*0.1*cos(cos(p.z*2. + p.x*4.142)*sin(p.z*1.123 + p.x*3.13))\n        \t\t   + 0.1*sin(sin(0.*p.x*4. + p.z)*cos(p.x*2.22 + p.z*4.193) + p.x*2.)\n        \t\t   + 0.2*sin(p.z*0.385 + p.x*0.941 + 0.2*cos(p.x*5.));\n    return waves;\n}\nvec4 GetDist(vec3 p, float calcCol) // return vec4(Object color, min Distance)\n{    \n    vec3 p_temp = p;\n    vec2 ID = floor(p.xz);\n    float hash = Hash21(ID);\n    float checker = mod(ID.x + ID.y, 2.)*2. -1.;\n    vec2 torusRad = vec2(0.5, 0.08);\n    bool rot = false;\n    if(hash < 0.5)\n    {\n        p = RotZ(p, PI);\n        rot = true;\n    }\n\tvec3 truchetBoxPos = p - vec3(0.5, 0., 0.5);\n    truchetBoxPos.x = fract(truchetBoxPos.x + 0.5) - 0.5;\n    truchetBoxPos.z = fract(truchetBoxPos.z + 0.5) - 0.5;\n    \n    vec3 torus1Pos = truchetBoxPos - vec3(0.5, 0., 0.5);\n    float torusUVScale = 1.;\n    vec2 torus1UV = GetTorusUV(torus1Pos, torusRad, rot, checker)*torusUVScale;\n    torus1UV *= checker;\n    vec3 torus1Col = vec3(1.,0.,0.) * smoothstep(0.3, 0.4, 0.5 + 0.5*sin(checker*torus1UV.x*40. + time*5.));\n    torus1Col = texture(iChannel0, torus1UV*3.*vec2(1., 2.) + vec2(time*0.5,0.5)).xyz;\n    //torus1Col = vec3(1.,0.,0.) * fract(torus1UV.y);\n    vec4 torus1Dist = vec4(torus1Col, sdTorus(torus1Pos, torusRad, rot, checker));\n    \n    vec3 torus2Pos = truchetBoxPos + vec3(0.5, 0., 0.5);\n    vec2 torus2UV = GetTorusUV(torus2Pos, torusRad, rot, checker)*torusUVScale;\n    torus2UV *= checker;\n    vec3 torus2Col = vec3(1.,0.,0.) * smoothstep(0.3, 0.4, 0.5 + 0.5*sin(checker*torus2UV.x*40. + time*5.));\n    \n    torus2Col = texture(iChannel0, torus2UV*3.*vec2(1., 2.) + vec2(time*0.5,0.5)).xyz;\n    //torus2Col = vec3(0.,1.,0.) * fract(torus2UV.y);\n    vec4 torus2Dist = vec4(torus2Col, sdTorus(torus2Pos, torusRad, rot, checker));\n    \n    vec4 torusDist = min2(torus1Dist, torus2Dist);\n    //torusDist = torusDist1;\n\n    //float box = sdBox(truchetBoxPos, vec3(0.51)); \n    //torusDist.w = max(box, torusDist.w);\n    \n    p = p_temp;\n    \n    //ground\n    vec3 groundCol = vec3(0.3);//*fract(p.x)*fract(p.z);\n    vec4 groundDist = vec4(groundCol, p.y); \n    \n    float stepsDecrease = 0.8;\n    vec4 torus1Dist_temp = torus1Dist;\n    vec4 torus2Dist_temp = torus2Dist;\n    torus1Dist.w = (abs(torus1Dist.w*1.)-0.01) * stepsDecrease;\n    torus2Dist.w = (abs(torus2Dist.w*1.)-0.01) * stepsDecrease;\n    vec4 tor1 = vec4(torus1Dist.xyz ,max(groundDist.w, torus1Dist.w));\n    vec4 tor2 = vec4(torus2Dist.xyz ,max(groundDist.w, torus2Dist.w));\n    vec4 res = min2(tor1, tor2);\n    //res = tor1;\n    torus1Dist = torus1Dist_temp;\n    torus2Dist = torus2Dist_temp;\n    \n    float waves1 = GetWaves(p);\n    vec3 p2 = p;\n    p2.xz *= Rot(1.8);\n    float waves2 = GetWaves(p2);//GetWaves(RotY(p, 0.5));\n    float waves =  waves1 + opSI(0., waves2,0.3);//opUS(waves1 , waves2, 0.);\n    float wavesOff = GetWaves(p + 0.01); \n    float slope = abs(wavesOff - waves)/0.01;\n    vec4 groundWithoutTruchet;\n    groundWithoutTruchet.xyz = texture(iChannel3, p.xz*2.).xyz;//vec3(0.3);\n    \n    groundWithoutTruchet.w = max(-min(torus1Dist.w, torus2Dist.w), p.y); \n    \n    vec4 waveGround = vec4(texture(iChannel2, p.xz ).xyz, p.y - waves);\n    waveGround.w = opSI(waveGround.w, -torusDist.w, 0.2 + 0.2*sin(p.z*5.52)*cos(p.x*10.12));\n    waveGround.xyz += mix(0., 1.5, clamp(waves, 0., 2.)); // add white color to the top of the mountains\n\t//waveGround.y += mix(0., 1., waves*0.4);\n    \n    groundWithoutTruchet.y += 0.2;\n    res = min2(groundWithoutTruchet, res);\n    res = 0.9*opUS(waveGround, res, 0.03);\n//res = waveGround;\n    //res = torusDist*stepsDecrease;\n    //res = torusDist;\n    \n    //vec4 res = min2(truchetBoxDist,spheresDist);\n    //if(skyDist < truchetBoxDist.w)\n    //    res = vec4(vec3(0.), skyDist);\n\n    return res;\n}\n// ---------------------------------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p, 0.).w;\n    vec2 e = vec2(.01, 0.);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy, 0.).w, \n                        GetDist(p-e.yxy, 0.).w, \n                        GetDist(p-e.yyx, 0.).w);\n    return normalize(n);\n}\n// ---------------------------------------------------------------------------\n// fog by iq\nvec3 applyFog( vec3  rgb, float distance, float strength, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*strength );\n    return mix( rgb, fogColor, fogAmount );\n}\n// ---------------------------------------------------------------------------\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir,   // sun light direction\n               in float strength,\n               in vec2 mou)  \n{\n    float fogAmount = 1.0 - exp( -distance*strength );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( mix(vec3(1.2,0.7,0.4)*1., vec3(0.3,0.7,1.), sunDir.y),\n                           vec3(1.,0.9,0.7)*1.5, // yellowish\n                           pow(sunAmount,20.) );\n    return mix( rgb, fogColor, fogAmount );\n}\n// ---------------------------------------------------------------------------\nvec4 RayMarch(vec3 ro, vec3 rd, int steps) \n{\n    vec3 result= vec3(1.,1.,0.)*0.;\n    vec4 dS;\n    float dO;;\n    vec3 p;  \n    for(int i = 0; i<steps; i++)\n    {\n        p = ro + rd * dO;\n        if(dO > MaxDist) {\n            result = vec3(0.);\n            break;\n        }\n        dS = GetDist(p, 1.);\n        if(abs(dS.w) < 0.0001) {\n            result = dS.xyz;\n            break; \n        }\n        dO += dS.w;\n    }     \n    return vec4(result.xyz,dO);\n}\n// ---------------------------------------------------------------------------\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float s = 1.0;\n    float t = mint;\n    for( float i=0.; i<maxt; i++ )\n    {\n        float h = GetDist(ro + rd*t, 0.).w;\n        s = min( s, 0.5+0.5*h/(w*t) );\n        if( s<0.0 ) break;\n        t += h;\n    }\n    s = max(s,0.0);\n    return s*s*(3.0-2.0*s); // smoothstep\n}\n// ---------------------------------------------------------------------------\nfloat GetLight(vec3 p, vec3 lightPos, float lightPower, float shadowStrength, int steps)\n{\n    vec3 l = normalize(lightPos - 0.*p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l*lightPower), 0., 1.);\n    //float d = RayMarch(p + n*0.001, l, steps).w;\n    //if(d < length(lightpos-p*0.)) {dif *= shadowStrength;}\n    float sunShadow = softShadow(p + n*0.001, lightPos, 0., 100., 0.1);\n    return clamp(0.5 + 0.5*dif, 0., 1.)*clamp((0.2 + 0.8*sunShadow), 0., 1.);\n}\n// ---------------------------------------------------------------------------\nfloat specularReflection(vec3 p, vec3 rd, vec3 lightPos, float intensity, float shininessVal)\n{\n    vec3 N = GetNormal(p);\n    vec3 L = normalize(lightPos - 0.*p);\n    float lambertian = max(dot(L, N), 0.0);\n    float specular = 0.;\n  \tif(lambertian > 0.0) {\n        vec3 R = reflect(-L, N);      // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n  \t}\n    return specular * intensity;\n}\n// ---------------------------------------------------------------------------\n// calcOcclusion by iq\nfloat calcOcclusion(vec3 p)\n{\n    vec3 n = GetNormal(p);\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = p + h*n;\n        float d = GetDist(opos, 0.).w;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n// ---------------------------------------------------------------------------\nvec3 cam(vec2 mou)\n{\n    vec3 ro = vec3(0.7, 1., 0.7);\n    if(time < 10.)\n        ro.y = 13. + 12.*sin(time/20.*PI + PI);\n    ro.z -= time*0.5;\n\n    return ro;\n}\n// ---------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.,0.,0.);\n \n    vec3 lookat = vec3(0.);\n\n    float zoom = 1.;\n    \n    vec2 mou = 5.*(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n\n\tvec3 ro = cam(mou);\n    \n    lookat = ro + vec3(sin(time*0.1287),  -0.8 - 0.5*sin(time*0.4752), -1.);\n\n    if(mode == 0.) {\n    ro = vec3(0.01, 3., -1.);\n    ro.xz *= Rot(mou.x);\n    ro.y += mou.y*5.;\n    lookat = vec3(0.01, 1., 0.1);\n    }\n\n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, R); //Up\n\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    vec3 rd = normalize(I-ro);\n\n    vec4 d = RayMarch(ro,rd, MaxSteps); \n    vec3 p = ro + rd*d.w;\n    \n    vec3 lightPos = normalize(vec3(0.,max(0.2,1. - 0.02*time) + 0.*mou.y,-1.));// + ro;//vec3(1.) + ro;//ro + 0.1*normalize(lookat);\n\t//lightPos = vec3(0.,0.5 + 0.5*sin(time),-1.);\n    //if(mode == 0.)\n    //    lightPos = ro;\n    \n    float dif = GetLight(p, lightPos, 1., 0.5, MaxSteps);\n    vec3 n = GetNormal(p);\n    //float sunShadow = softShadow(p + n*0.001, lightPos, 0., 100., 0.1);\n    float occ = calcOcclusion(p);\n    float spRef = specularReflection(p, rd, lightPos, 0.2, 3.);\n    float skyDif = clamp(dot(vec3(0.,1.,0), GetNormal(p)), 0., 1.);\n    float groundDif = clamp(dot(vec3(0.,-1.,0.), GetNormal(p)), 0., 1.);\n    \n\tcol = d.xyz * (dif) * occ\n          + spRef * vec3(1.,1., 0.5)*0.\n          //+ sunShadow * vec3(1.,1., 0.5)*0.\n          + skyDif * vec3(0., 0.05, 0.1)\n    \t  + groundDif * vec3(0.3,0.3,0.3)*0.2;\n    //col = sunShadow * vec3(1.,1., 0.5)*0.1;\n    //col = spRef * vec3(1.,1., 0.5);\n    //col = vec3(dif);\n    //col = applyFog(col, d.w, 0.15, vec3(0.6,0.5,0.4));\n    col = applyFog(col, d.w, rd, normalize(lightPos - vec3(0., 0.3, 0.)), 0.1, mou);\n    col = pow3(col,1.3);\n\n    fragColor = vec4(col,0.1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//# define time iTime\n# define PI 3.141592654\nvec3 pow3(vec3 a, float b)\n{\n    return vec3(pow(a.x,b), pow(a.y,b), pow(a.z,b));\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 RotX (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x, p.y*cc + p.z*-ss,  p.y*ss + p.z*cc);\n}\nvec3 RotY (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x*cc + p.z*ss, p.y, p.x*-ss + p.z*cc);\n}\nvec3 RotZ (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x*cc  + p.y*-ss, p.x*ss + p.y*cc, p.z);\n}\nfloat opUS( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    float dist = mix( d2, d1, h ) - k*h*(1.0-h); \n \treturn dist;\n}\nvec4 opUS( vec4 d1, vec4 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    vec3 color = mix(d2.xyz, d1.xyz, h);\n    float dist = mix( d2.w, d1.w, h ) - k*h*(1.0-h); \n \treturn vec4(color, dist);\n}\nfloat opSS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat opSI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\nvec4 min2(vec4 d1, vec4 d2)\n{\n    return min(d1.w,d2.w) == d1.w ? d1 : d2;\n}\nfloat sdBox(vec3 p, vec3 s) \n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 s, float r )\n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nvec2 GetSphereUV(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    float x = atan(n.x, n.z);///(2.*PI) + 0.5;\n    float y = n.y;//0.5 + 0.5*n.y;\n    return vec2(x,y);\n}\nfloat sdSphere( vec3 p, float r) {\n    float d =  length(p) - r;\n    return d;\n}\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    \tvec2 r = vec2(1., 1.73);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}","name":"Common","description":"","type":"common"}]}