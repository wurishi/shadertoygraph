{"ver":"0.1","info":{"id":"Mf2yDt","date":"1723194473","viewed":33,"name":"2nd Raymarching study","username":"WilliamWang","description":"This is my 2nd Raymarching study","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxStep 100\n#define maxDist 100.\n#define minDist 0.01\n#define mouseSen 2.0\n\n// Palette function\nvec3 palette (float t) {\n    vec3 a = vec3(0.8, 0.8, 0.8);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(-3.142, -3.142, -3.142);\n    vec3 d = vec3(-1.0, 0.333, 0.667);\n    \n    return a + b*cos(6.29318*(c*t+d));\n}\n\n// 2D Rotation matrix\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// smoothMin function\nfloat smoothMin( float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0) / k;\n    return min( a, b) - h*h*h*k*(1.0/6.0);\n}\n\n// torus SDF\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\n// Solid angle shape SDF\nfloat sdSolidAngle( vec3 p, vec2 c, float size )\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - size;\n  float m = length(q - c*clamp(dot(q,c),0.0,size) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\n// Box frame SDF\nfloat sdBoxFrame( vec3 p, vec3 half_Dim, float thickness )\n{\n       p = abs(p)- half_Dim;\n  vec3 q = abs(p+thickness)-thickness;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Capsule / Line SDF\nfloat sdCapsule( vec3 p, vec3 endP_a, vec3 endP_b, float size )\n{\n  vec3 pa = p - endP_a, ba = endP_b - endP_a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - size;\n}\n\n// getDist Funtion\nfloat getDist(vec3 p) { \n    vec3 boxOrginalP = p;       // copy original p\n    boxOrginalP.xy *= rot2D(iTime);\n    boxOrginalP.yz *= rot2D(iTime);\n    \n    vec3 solidOriginalP = p;    // copy original p\n    solidOriginalP.xy *= rot2D(iTime);\n    solidOriginalP.yz *= rot2D(iTime);\n    \n    vec3 CapsuleOriginalP = p;    // copy original p\n    CapsuleOriginalP.xz *= rot2D(iTime * 2.0);\n    \n    vec3 torusOriginalP = p;    // copy original p\n    \n    // box frame\n    vec3 boxframePos =vec3 (1.9, 1, 6);\n    // Apply the  rotation around the center\n    vec3 rotatedboxframePos = boxframePos.xyz;\n    rotatedboxframePos.xy *= rot2D(iTime); \n    rotatedboxframePos.yz *= rot2D(iTime); \n    \n    vec3 boxframeDim = vec3(1.0, 0.5, 0.5);\n    float boxframeThickness = 0.06;\n    float boxframeDist = sdBoxFrame(boxOrginalP - rotatedboxframePos, boxframeDim, boxframeThickness);\n    \n    // solid angle\n    vec3 solidPos = vec3(-1.9, 1, 6);\n    // Apply the  rotation around the center\n    vec3 rotatedsolidPos = solidPos;\n    rotatedsolidPos.xy *= rot2D(iTime);\n    rotatedsolidPos.yz *= rot2D(iTime);\n    \n    vec2 solidAngle = vec2(cos(radians(45.0)), sin(radians(45.0)));\n    float solideSize = 1.5;\n    float solidDist = sdSolidAngle(solidOriginalP - rotatedsolidPos, solidAngle, solideSize);\n    \n    // Capsule\n    vec3 capsulePos = vec3(0.0, 1, 6);\n    // Apply the  rotation around the center\n    vec3 rotatedcapsulePos = capsulePos;\n    rotatedcapsulePos.xz *= rot2D(iTime * 2.0);\n    \n    vec3 endP_a = vec3(0.0, 0.0, 0.0);\n    vec3 endP_b = vec3(0.0, 0.0, 3.0);\n    float capsuleSize = 0.5;\n    float capsuleDist = sdCapsule(CapsuleOriginalP - rotatedcapsulePos, endP_a, endP_b, capsuleSize);\n    \n    // jumping torus\n    vec3 torusPos = vec3(0, 0.9, 3);    // Torus position\n    float y = -fract(iTime* 2.0)*(fract(iTime* 2.0)-1.);\t\t\t// repeating parabola\n    \n    // Horizontal movement\n    float xOffset = sin(iTime * 1.5) * 2.0; // controls the range and speed of the movement\n\n    torusPos = vec3(xOffset, 0.9, 3); // torus position with horizontal movement\n\n    torusOriginalP -= torusPos;\t\t\t\t\t// translate\n    \n    // Add rotation around the y-axis\n    torusOriginalP.xz *= rot2D(iTime * 2.0); \n    \n    // squash\n    float squash = 1.+smoothstep(.15, .0, y)*.5;     // squash scale\n    torusOriginalP.y *= squash;\n    torusOriginalP = torusOriginalP.xzy;\t\t\t\t// flip torus on its side\n    \n    float torusDist = sdTorus(torusOriginalP, vec2(0.8 , 0.1))/squash;\n    \n    // plane\n    float planeDist = p.y;\n   \n    float d = smoothMin(min(solidDist, boxframeDist),capsuleDist, 1.0);\n    d = smoothMin(d,planeDist, 1.0);\n    return min(d, torusDist);\n}\n\n// Ray Marching\nfloat rayMarching(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i=0; i<maxStep; i++) {\n        vec3 p = ro + t* rd;\n        float ds = getDist(p);\n        t += ds;\n        if(t > maxDist || ds < minDist) break;\n    }\n    return t;\n}\n\n// Calculate normal function\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n        \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec2 m) {\n    vec3 lightPos = vec3(0, 5, 6);\n    \n    if (iMouse.z < 0.0) lightPos.xz += vec2(sin(iTime* 2.0), cos(iTime* 2.0))*3.0;  // Default light position\n    else lightPos.xz += m.xy * mouseSen;                                  // when mouse is pressed\n     \n    vec3 l = normalize (lightPos - p);\n    vec3 n = getNormal(p);\n    \n    // diffuse color\n    float diff = clamp(dot(n,l), 0.0, 1.0);\n    \n    // calculate shadow\n    float d = rayMarching(p+n*minDist*2.0,l);\n    if(d < length(lightPos-p)) diff *= 0.2;\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord- 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y * mouseSen;\n   \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1,0);                     // camera origin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));  // camera direction\n    \n   \n    float d = rayMarching(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float diff = getLight(p, m);\n    col = vec3(diff * 1.1);\n    \n    // Apply gamma correction\n    col = pow(col, vec3(1.0/2.2));\n\n    //col = getNormal(p);  // show normal\n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}