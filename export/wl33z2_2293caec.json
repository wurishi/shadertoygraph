{"ver":"0.1","info":{"id":"wl33z2","date":"1576859927","viewed":177,"name":"Adaptive Numbered Grid","username":"DannnYXZ","description":"Grid with numbers matching projection frustum window w_a at position w_p","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["grid","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int chr[12]=int[12](0xe9d72e, 0xe210c4, 0x1f0ba0f, 0xf8320f, 0x1087a31, 0x1f87c3f, 0xe8bc3e, 0x84221f, 0xe8ba2e, 0xe87a2e, 0x007c00, 0xc60000);\n\nfloat font(vec2 p, float code) { // p in [0, 1]\n    if(p.x > 1. || p.y > 1. || p.x < 0. || p.y < 0.) return 0.;\n    p = ((p - vec2(0., 1.)) * vec2(1., -1.)) * 5.;\n    float pos = floor(p.x) + 5.0 * floor(p.y);\n    return float((chr[int(code)]>>int(pos))&1);\n}\n\nfloat number(vec2 uv, float x) {\n    float a, mask = 0., d = 1.1;\n    if(x < 0.) {\n        mask += font(uv, 10.);\n        uv.x -= d;\n        x = abs(x);\n    }\n    float b = modf(x, a);\n    float la = ceil(log(a + 1.) / log(10.)), lb = 4.;\n    vec2 uva = uv - vec2((la - 1.) * d, 0.);\n    vec2 uvb = uv - vec2((la + 1.) * d, 0.);\n    mask += font(uv - vec2(la * d, 0.), 11.); // dot\n    while(la > 0.) {\n        mask += font(uva, mod(a, 10.));\n        a /= 10.;\n        uva.x += 1.1;\n        la -= 1.;\n    }\n    while(lb > 0.) {\n        b *= 10.;\n        mask += font(uvb, mod(b, 10.));\n        b = fract(b);\n        uvb.x -= 1.1;\n        lb -= 1.;\n    }\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 w_p = vec2(0, 0);\n    vec2 w_a = vec2(1, 1);\n    w_a += ((iMouse.x - vec2(0., 1.))*vec2(1., -1.)- .5) * 20.;\n    w_a = max(vec2(1e-5), w_a);\n    vec2 uvw = (2. * uv - 1.) * w_a + w_p;\n    uv = uvw;\n    vec3 col = vec3(75.,0.,156.)/255.;\n    vec3 gcol = vec3(0.,198.,245.)/255.;\n    vec2 m = pow(vec2(2.), floor(log(w_a)/log(2.)))/2.; // granularity\n    vec2 id = floor(uv/m);\n    vec2 n_id = id * m;\n    vec2 uv1 = mod(uv, m);\n    vec2 uv2 = fract(uv1 / m * 4.);\n    uv1 = uv1 / w_a * 7. * vec2(iResolution.x / iResolution.y, 1.);\n    float gw = .045;\n    (uv1.x <= gw * .2 || uv1.y <= gw *2.) ? col += gcol * 2. : col += 0.;\n    (uv2.x <= gw || uv2.y <= gw) ? col += gcol : col += .0;\n    col += number((uv1 * 1.5-vec2(0.2, .1)) * 3., n_id.x);\n    col += number((uv1 * 1.5-vec2(0.2, .6)) * 3., n_id.y);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}