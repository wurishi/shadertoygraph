{"ver":"0.1","info":{"id":"XtScRG","date":"1508927532","viewed":157,"name":"Quaternionic Weirdness","username":"dust","description":"A heavily modified version of the Julia escape-time algorithm, thrown into a ray-marcher and written with quaternions instead of two-dimensional complex numbers.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","quaternions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Compute the product of two quaternions\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scaling function inspired by the one in iq's Mandelbrot DE\n    // https://www.shadertoy.com/view/lsX3W4\n    float sTime = sin(iTime);\n    float scale = 5.8;// * sTime; // Adjust this for zoom\n\tvec2 z = vec2(-1.0 * scale, -1.0 * scale) + 2.0 * (fragCoord.xy / iResolution.xy) * scale;\n   \tz.x *= iResolution.x / iResolution.y;\n    vec2 c = vec2(0.8, 0.15) * sTime;\n    \n    uint iter = 0U;\n    uint maxIter = uint(1024.0 * (((1.0 - sTime) / 10.0) + 0.1));\n    \n    // Ray-marching here\n    // Very difficult to evaluate a proper hull check without some\n    // fancier maths, so create colors from the average proportionate \n    // iteration count in each z-channel instead\n    float maxDist = 200.0;\n    float maxDepth = 100.0;//maxDist;\n    vec3 rgb = vec3(0.0, 0.0, 0.0);\n    for (float i = 0.0; i < maxDepth; i += 1.0)\n    {\n        vec4 zQtn = vec4(z, 0.8 * i / maxDepth * scale, asin(sTime));\n        vec4 cQtn = vec4(c, 0.5 * scale, 0.01 * i);\n\n        while (iter < maxIter &&\n               length(zQtn) < maxDist)\n        {\n        \tzQtn = QtnProduct(zQtn, zQtn) + (zQtn * sin(QtnProduct(cQtn + zQtn, zQtn)));\n            iter += 1U;\n        }\n\n        rgb += vec3((float(iter) / float(maxIter) * length(zQtn) / maxDist),\n                    (float(iter) / float(maxIter) * length(zQtn) / maxDist),\n                    (float(iter) / float(maxIter) * length(zQtn) / maxDist) * 100.0) / maxDepth;// * length(zQtn * cQtn) * 0.1)) / maxDepth;        \n        iter = 0U;\n    }\n    \n    // Apply Hejl & Burgess-Dawson HDR with unit exposure\n    vec3 hdr = max(vec3(0.0), rgb - vec3(0.004));\n    fragColor = vec4(1.0, 1.0, 1.0, 2.0) - vec4((hdr * (vec3(6.2) * hdr + vec3(0.5))) / (hdr * (vec3(6.2f) * hdr + vec3(1.7)) + vec3(0.06)), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}