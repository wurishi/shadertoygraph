{"ver":"0.1","info":{"id":"4fXGDM","date":"1703106045","viewed":25,"name":"Outer World","username":"brunorealities","description":"A basic artistic experiment with ray marching to create some kind of geometric animation in and out of world ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","interactive","geometry","immersive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Inspired and based on my learnings of Kishimisu tutorials about shader art coding\n\n\n//Rotation\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n//from Inigo Quilez 3D SDF Functions\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\n//Distance to the scene\nfloat map(vec3 p)\n{\n   vec3 spherePos = vec3(sin(iTime)*3.,0.,0.);  //Sphere position\n   float sphere = sdSphere(p - spherePos, 1.);  //Sphere SDF\n   \n  vec3 q = p;\n   \n  q = fract(p) - .49;\n\n   float box = sdBox(q, vec3(.1));\n   \n   float ground = p.y + .75 + sin(iTime);\n    \n  return .55 -abs(min(ground,smin(box, min(sphere,ground), 2.)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord *2. - iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy)/iResolution.y;\n    //initialization    \n    vec3 ro = vec3(0.0,0.,-3.);   //ray origin\n    vec3 rd = normalize(vec3(uv,1.));      //ray direction\n    vec3 col = vec3(0.);\n    float t = 0.; //distance travelled\n    \n    \n     //Vertical camera rotation\n    ro.yz *= rot2D(-m.y);\n    rd.yz *= rot2D(-m.y);\n\n    //Horizontal camera rotation\n    ro.xz *= rot2D(-m.x);\n    rd.xz *= rot2D(-m.x);\n\n\n    //ray marching \n    for(int i = 0; i < 80; i++)\n    {\n    \n       vec3 p = ro + rd * t; //position along the ray\n     float d = map(p); //current distance to the scene\n     t += d; //\"march\" the ray\n     \n     //col = vec3(i)/80.;\n     \n     if(d < 0.001 || t > 100.)break; //early stop\n    \n    }\n      \n      col = vec3(t * .2);\n\n    //col = vec3(t * .1);  //color based on distance\n\n   fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}