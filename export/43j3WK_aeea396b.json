{"ver":"0.1","info":{"id":"43j3WK","date":"1708906556","viewed":67,"name":"3 points circle c3p0(dotperp())","username":"ollj","description":"Circle defined by 3 points\n\nis mostly a crunched version of parent shader  \nhttps://www.shadertoy.com/view/flBXzG\n\nwith minor cleanups","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","distance","sdfsdf","arc","3point"],"hasliked":0,"parentid":"flBXzG","parentname":"3 point circle"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//---start: matrix determinant and perpendicular_dot() stuff\n//#define dd(a) dot(a,a)\n//squared-lenght of a\n\n//below functions are intended for vec2 inputs only, saves a lot of chars.\n\n#define perp(a) ((a).yx*vec2(-1.,1.))\n//perpendicular vector, signs are non-arbitrary for being a basis on matrix logic regarding matrix-determinants\n\n#define dotp(a,b) (dot(perp(a),b))\n//http://mathworld.wolfram.com/PerpDotProduct.html\n//==determinant(mat2(a,b)),aka cross2(),for also being the cross-product() of a mat2.\n\n//float dotn(v1 a,v1 b){return -a.x*b.x+a.y*b.y;}//only a.x is negated,no swivel\n//above is source, below is changed, adjusted to using dotp() instearf of xdot()\n#define dotn(a,b) (-dotp((a).yx,b))\n//only a.x is negated,no swivel\n\n//commented out code that bridges from source-version to my-version\n//vec4 extension is relevant in the context of getting circle(center) from 3 points\n//vec2 perp2(vec2 a,vec2  b){return vec2(a.x*b.y,-a.y*b.x);} //rarely needed\n//vec2 perp3(vec2 b,vec2 a){//from circle-center-from-3-points-on-circle\n// return (b-a).yx*vec2(-1,1);\n //return vec2(-(b-a).y,(b-a).x);\n //return vec2(-b.y+a.y,b.x-a.x);\n// ;}\n//#define v1 vec2\n//#define v3 vec4\n//v3 perp2(v1 a,v1 b,v1 c){return v3((b-a).yx,(c-b).yx)*v3(-1,1,-1,1);}\n//used only once, not yet worth a subroutine.\n\n//---end__: matrix determinant and dot() stuff\n\n\n\n//return circleCenter from 3 point on circle\n//if (colinear) return vec2(1./0.)\n//if (3 points are identical) , flickering (n valid solutions swap wandomly each frame\n//if (a==b) fails             ,            returns distance to 2 points\n//if (a==c) fails             , flickering (2 valid solutions swap wandomly each frame\n//if (b==c) fails             ,            returns distance to 2 points\nvec2 c3p0(vec2 a, vec2 b, vec2 c){\n  //[a] is needed till the end of this function.\n    vec4 h=vec4(.5*(a+b),.5*(b+c));//needed till much later\n    vec4 v=vec4((b-a).yx,(c-b).yx)*vec4(-1,1,-1,1);//ubnholy crunching swivels\n    b=h.xy-v.xy; c=h.zw-v.zw;//repurposing some vars, unholy offsets\n    a.x=dotp(v.xy,v.zw);//all this for a mat2-determinant\n    //determnant of 2x2 matrix, that solves 2 quadratatics\n    //, that gets equidistant-point-to-3-points (3 gradradic-circle-functions substract to 2 quadratics)\n    if (a.x==0.){return vec2(1.);} //3 points abc are colinear.\n    b=vec2(dotp(h.xy,b),dotp(h.zw,c));//b now precalcs circle center\n    return vec2(dotn(v.zx,b),dotn(v.wy,b))/a.x;}\n\n\n//return distance of [u] to a circle, set by 3 points on circle\nfloat SDF_circle_by_three_points(vec2 u, vec2 a, vec2 b, vec2 c) {\n    c=c3p0(a,b,c);\n    return  length(u-c)//distance to circle center\n           -length(a-c)//circle radius\n           ;}//2 sqrt() above can not be deferred \n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    p*=1.3;\n\n    // driver code sets 3 Ã¼oints over time\n    float r = 1.;\n    vec2 A = vec2(sin(iTime / 3.), cos(iTime / 7.));\n    vec2 B = vec2(sin(iTime / 7.), cos(iTime / 3.));\n    vec2 C = vec2(sin(iTime / -3.), cos(iTime));\n    \n    //testing corner cases (rarely occur here cuecause trig primes+rounds above)\n    //C=B;\n    //C=A;\n\n    // distance\n    float d = SDF_circle_by_three_points(p, A, B, C);\n   \n    // show  A, B and C\n    d = min(d, abs(length(p - A) - .103) * 2.);\n    d = min(d, abs(length(p - B) - .102) * 2.);\n    d = min(d, abs(length(p - C) - .103) * 2.);\n    // coloring\n    vec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n    col *= 1.0 - exp(-2.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(22.0 * abs(d));\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}