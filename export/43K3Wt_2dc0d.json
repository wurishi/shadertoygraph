{"ver":"0.1","info":{"id":"43K3Wt","date":"1718421557","viewed":67,"name":"MovingStars","username":"altrashouse","description":"Stars in space","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Parameters\n    \n    float numRays = 20.0;\n    float starLen = 0.05;\n    float speed = 0.2;\n    float starWidth = 0.01;\n    float rotAngle = 0.5;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    //length of longest diagonal, over two\n    float maxDiag = 0.5*sqrt(1.0+iResolution.x/iResolution.y*iResolution.x/iResolution.y);\n    #define M_PI 3.1415926535897932384626433832795\n    \n    //Get angle of point\n    //no idea why have to input negative signs lmao\n    //but seems necessary\n    float angle = -atan(uv.y,-uv.x);\n    if(uv.y==0.0){\n        angle = 0.0;\n    }\n    angle += M_PI;\n    \n    //Calculate if point should be illuminated\n    float colorR = 0.0;\n    float colorG = 0.0;\n    float colorB = 0.0;\n    \n    float time = iTime*speed;\n    \n    \n    \n    //(numRays-i-1.0)/numRays+slide) How far along path\n    //normDist-(numRays-i-1.0)/numRays-slide) How far along star\n    float normDist = sqrt(uv.x*uv.x+uv.y*uv.y)/maxDiag;\n    for(float i = 0.0; i<numRays; i++){\n        //Rays are 137.5 degrees from each other\n        //Check if point within 0.01 from ray\n        float slide = (numRays*time-floor(numRays*time))/numRays;\n  \n        float valid_ray = mod(floor(numRays*(time)+i)*137.5/180.0*M_PI,2.0*M_PI);\n        \n        float width = starWidth;\n        \n        float currentPos = (numRays-i-1.0)/numRays+slide;\n        currentPos = pow(currentPos,3.0);\n        if(abs(angle + normDist*rotAngle - valid_ray)< width){\n            \n            if(0.0<(normDist-currentPos) && (normDist-currentPos)<starLen){\n                colorR = pow(1.0/starLen*(normDist-currentPos),0.6);\n                colorG = 1.0/starLen*(normDist-currentPos);\n                colorB = 1.0/starLen*(normDist-currentPos);\n                \n                //screwing with colors\n                colorG = colorG*colorG;\n                colorB = colorB*colorB*colorB;\n            }\n\n        }\n    }\n    \n    //check if point should be lit\n    \n    fragColor = vec4(colorR,colorG,colorB,1.0);\n}","name":"Image","description":"","type":"image"}]}