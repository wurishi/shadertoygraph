{"ver":"0.1","info":{"id":"4XVSDm","date":"1720043007","viewed":36,"name":"Pre-Computed Irradiance & BRDF","username":"guhcalm","description":"- Precomputed Irradiance (Buffer A, rgb Channels)\n- Precomputed BRDF (Buffer A, brdf encoded as a float on alpha Channel)","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["brdf","ibl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PrecomputedIrradiance(uv) (texture(iChannel0, uv).rgb)\n#define PrecomputedBRDF(NdotV, roughness) DecodeVec2(texelFetch(iChannel0, ivec2(vec2(NdotV, roughness) * iResolution.xy), 0).a)\n  \nvoid mainImage(out vec4 Pixel, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  if (uv.x < .5) Pixel = vec4(PrecomputedBRDF(uv.x, uv.y), 0, 1);\n  else Pixel = vec4(PrecomputedIrradiance(uv), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EncodeVec2(xy) uintBitsToFloat(packHalf2x16(xy))\n#define DecodeVec2(packedFloat) unpackHalf2x16(floatBitsToUint(packedFloat))\n\nconst float PI = 3.14159265359;\n\nfloat seed;\nfloat random() { return fract(sin(seed += .1) * 4568.7564); }\nfloat random(vec2 uv) { return fract(sin(dot(uv, vec2(127.1, 311.7))) * 4568.7564); }\nvec3 RandomVectorOnHemisphere(vec3 normal) {\n  float u = random();\n  float v = random();\n  float a = 6.283185 * v;\n  float b = u * 2. - 1.;\n  vec3 random = vec3(sqrt(1. - b * b) * vec2(cos(a), sin(a)), b);\n  return normalize(random * sign(dot(normal, random)));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Prefiltered BRDF Texture && Irradiance Map*/\n\nfloat RadicalInverse_VdC(uint bits)  {\n  bits = (bits << 16u) | (bits >> 16u);\n  bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n  bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n  bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n  bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n  return float(bits) * 2.3283064365386963e-10;\n}\nvec2 Hammersley(uint i, uint N) { return vec2(float(i) / float(N), RadicalInverse_VdC(i)); }\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\n  float a = roughness*roughness;\n\n  float phi = 2.0 * PI * Xi.x;\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n  float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n  \n  vec3 H;\n  H.x = cos(phi) * sinTheta;\n  H.y = sin(phi) * sinTheta;\n  H.z = cosTheta;\n\n  vec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent   = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\t\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n  return normalize(sampleVec);\n}\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float a = roughness;\n  float k = (a * a) / 2.0;\n  float nom   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n  return nom / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n  return ggx1 * ggx2;\n}\n\n/* BRDF Map */\nvec2 BRDF(vec2 uv) {\n  float NdotV = uv.x;\n  float roughness = uv.y;\n  vec3 V;\n  V.x = sqrt(1.0 - NdotV*NdotV);\n  V.y = 0.0;\n  V.z = NdotV;\n\n  float A = 0.0;\n  float B = 0.0; \n\n  vec3 N = vec3(0.0, 0.0, 1.0);\n    \n  const uint SAMPLE_COUNT = 1024u;\n  for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\n    vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n    vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n    vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(L.z, 0.0);\n    float NdotH = max(H.z, 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n\n    if(NdotL > 0.) {\n      float G = GeometrySmith(N, V, L, roughness);\n      float G_Vis = (G * VdotH) / (NdotH * NdotV);\n      float Fc = pow(1.0 - VdotH, 5.0);\n\n      A += (1. - Fc) * G_Vis;\n      B += Fc * G_Vis;\n    }\n  }\n  return vec2(A, B) / float(SAMPLE_COUNT);\n}\n\nvec3 uvToSphere(vec2 uv) {\n  float phi = (uv.x * 2.0 * PI) - PI;\n  float theta = PI * (1.0 - uv.y);\n  float x = sin(theta) * cos(phi);\n  float y = cos(theta);\n  float z = sin(theta) * sin(phi);\n  return vec3(x, y, z);\n}\n\n/* Irradiance Map */\nvec3 Irradiance(vec2 uv) {\n  vec3 normal = uvToSphere(uv);\n  const int STEPS = 600;\n  vec3 color;\n  for (int i; i < STEPS; i++) color += texture(iChannel0, RandomVectorOnHemisphere(normal)).rgb;\n  return color / float(STEPS);\n}\n\n\nvoid mainImage(out vec4 PrecomputedIrradianceAndBRDF, in vec2 fragCoord) {\n  if (iFrame > 1) discard;\n  vec2 uv = fragCoord/iResolution.xy;\n  vec3 irradiance = Irradiance(uv);\n  vec2 brdf = BRDF(uv);\n  PrecomputedIrradianceAndBRDF = vec4(irradiance, EncodeVec2(brdf));\n}","name":"Buffer A","description":"","type":"buffer"}]}