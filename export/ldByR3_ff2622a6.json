{"ver":"0.1","info":{"id":"ldByR3","date":"1493059128","viewed":353,"name":"Smooth Ising Model","username":"chronos","description":"A smoothened and tweaked version of my previous Ising Model / Majority vote simulation.\nFeel free to play with the tunable parameters in Buffer A -> mainImage\nSuggestions for improvements are very welcome  :)","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["2d","cellular","model","smooth","stochastic","automaton","ising","majority","vote","toom","annealing","simulated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PPSTYLE 0\n\nvec3 remap(vec3 x) { return (x + 1.) / 2.; }\nfloat remap(float x) { return (x + 1.) / 2.; }\n\n// Not part of 'continuous' simulation, just for visuals ;)\nvec3 postprocess(vec2 pos){\n    vec4 u = texture(iChannel0, (pos + vec2( 0.0,  1.0))/iResolution.xy);\n    vec4 d = texture(iChannel0, (pos + vec2( 0.0, -1.0))/iResolution.xy);\n    vec4 l = texture(iChannel0, (pos + vec2(-1.0,  0.0))/iResolution.xy);\n    vec4 r = texture(iChannel0, (pos + vec2( 1.0,  0.0))/iResolution.xy);\n    vec4 c = texture(iChannel0, pos/iResolution.xy);\n    \n    vec2 grad = vec2((r.x-l.x), (u.x-d.x)) / 2.;\n    float div = ((r.x+u.x) - (u.y-d.y))/2.;\n    float curl = r.x*d.y - l.y*u.x;\n    vec4 avg = (0.5*(u+d+l+r)+c)/3.;\n    vec3 color = vec3(avg.r)*0.6 + 0.4*vec3(sin(avg.g), sin(avg.r), sin(avg.g * 3.14));\n    float dirlight = dot(grad, normalize(vec2(1., 1.)));\n    color = color\n        #if PPSTYLE == 0\n        \t+ 1.0 * curl *(vec3(0.8, 0.2, 0.8))\n    \t\t+ 2.0 * abs(dirlight)*dirlight\n        #elif PPSTYLE  == 1\n        \t+ 3.0 * abs(dirlight)*dirlight\n        #endif\n        ;\n    return remap(color);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = postprocess(fragCoord);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MouseTemperature 1\n#define Annealing 1\n\n// From https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat initial(vec2 fragCoord) {\n    return texture(iChannel1, fragCoord/iResolution.xy).r;\n}\n\nvec4 lookUp(vec2 fragCoord, vec2 offset) {\n    return texture(iChannel0, fract((fragCoord + offset)/iResolution.xy));\n}\n\nvec2 transition(vec2 fragCoord, float windowsize, float bias, float noise, float rnd, float eps) {\n\n    float votes  = 0.0;\n    float totalweight = 0.0;\n    vec2 d;\n    for(d.x = -windowsize; d.x <= windowsize; d.x+=1.)\n    {\n    \tfor(d.y = -windowsize; d.y <= windowsize; d.y+=1.)\n    \t{\n            float radius  = length(d);\n            float weight  = 1.-smoothstep(1., windowsize, radius); // Further out voters are weighted less\n        \tvotes += weight * lookUp(fragCoord, d).r;\n            totalweight += weight;\n    \t}    \n    }\n\n    float sum = votes / totalweight; // Normalize weighting\n    \n    float vote = smoothstep(0.0-eps, 0.0+eps,sum);\n    \n    //noise=p+q and bias=(p-q)/(p+q)\n    float p = noise * (1.+bias) / 2.; // spin down to spin up probability\n    float q = noise - p;              // spin up to spin down probability\n\n    // apply random noise:\n    // Smoothened version of:\n    // if((state > 0.0) && (rnd < q)) state = -1.;\n    // else if(rnd < p) state = 1.;\n    float state = \n        vote * (1. - 2.*smoothstep(rnd-eps, rnd+eps, q)) + \n        (1.-vote) * (2.*smoothstep(rnd-eps, rnd+eps, p) - 1.);\n \treturn vec2(state, vote);           \n}\n\nbool key(vec2 keycode) {\n\treturn texture( iChannel2, keycode).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Tunable parameters /////////////////////\n    const float bias  \t\t\t= 0.00;\t\t\t // [0, 1], Affects probability ratio\n          float noise \t\t\t= 0.45;\t\t\t // [0, 1], Thermal noise inducing variation and counteracting diffusion\n    const float smoothness \t\t= 0.1;\t\t\t // Smooth transition width (epsilon), should usually be small\n    const float windowsize \t\t= 2.;\t\t\t // radius of vote neighborhood\n    const float substeps \t\t= 2.;\t\t\t // Simulation substeps per frame (increases smoothness and stability)\n    const float speed\t\t\t= 1.5;\t\t\t // How fast the simulation progresses(decreases smoothness and stability)\n    const float dt \t\t\t\t= speed/substeps;// Simulation step size\n    ///////////////////////////////////////////\n    \n  \n    \n    vec3 state = lookUp(fragCoord, vec2(0.0)).rgb;\n    \n    // TODO: speed should not affect smoothness\n    // use\n    float time = state.b; // Currently Unused\n    // + iTime, iTimeDelta to progress simulation in steps of dt\n    // to make framerate independent and decouple simulation speed and smoothness ( hopefully )\n    \n    #if Annealing\n    \tnoise = 1./(1.+iTime/10.);\n    #endif\n    \n    #if MouseTemperature\n    \tif (iMouse.xy != vec2(0.0,0.0)) noise = iMouse.y/iResolution.y;\n  \t#endif\n    \n    for(float i = 0.; i < substeps; i+=1.){\n        float rnd = hash13(vec3(fragCoord.xy, iTime));\n    \tstate += dt*(vec3(transition(fragCoord, windowsize, bias, noise, rnd, smoothness),time) - state);\n    }\n    \n    // Initialize\n    const vec2 spacebar = vec2(32.5/256.0,0.5);\n    if(iFrame < 10 || key(spacebar) ) {\n        state.r = 1.-2.*step(.5, initial(fragCoord));\n    }\n    \n    fragColor = vec4(state, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Apply post process blur\n// Not part of 'continuous' simulation, just for visuals ;)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 u = texture(iChannel0, (fragCoord + vec2( 0.0,  1.0))/iResolution.xy);\n    vec4 d = texture(iChannel0, (fragCoord + vec2( 0.0, -1.0))/iResolution.xy);\n    vec4 l = texture(iChannel0, (fragCoord + vec2(-1.0,  0.0))/iResolution.xy);\n    vec4 r = texture(iChannel0, (fragCoord + vec2( 1.0,  0.0))/iResolution.xy);\n    vec4 c = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = (u+d+l+r+c)/5.;\n}","name":"Buffer B","description":"","type":"buffer"}]}