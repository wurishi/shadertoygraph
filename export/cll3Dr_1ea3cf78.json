{"ver":"0.1","info":{"id":"cll3Dr","date":"1671626727","viewed":149,"name":"truchet snake","username":"VL","description":".","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define int2 vec2\n#define float2 vec2\n#define int3 vec3\n#define float3 vec3\n#define int4 vec4\n#define float4 vec4\n#define frac fract\n#define sincos(x,s,c) s = sin(x),c = cos(x)\n#define mul(x,y) (x*y)\n#define atan2 atan\n#define fmod mod\n\nconst float InvPI = 0.318309886f;\nconst float PId2 = 1.57079632f;\nconst float PI = 3.141592653f;\nconst float PI2 = 6.2831853f;\nconst float MaxDist = 100.f;\nconst float SurfaceDist = 0.0001f;\nconst float FloatMax = 3.402823466e+38F;\n\nfloat2 hash(float2 p)\n{\n    float3 p3 = frac(float3(p.xyx) * float3(145.1031, 161.1030, 158.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return frac((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat3 hash(float3 p3)\n{\n    p3 = frac(p3 * float3(155.1031, 132.1030, 144.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return frac((p3.xxy + p3.yxx) * p3.zyx);\n}\nfloat truchet(float2 p, float thickness)\n{\n    int2 idx = floor(p);\n    float2 rand = hash(idx);\n    \n    p -= 0.5f + idx;\n    p.x = rand.x > 0.5f ? p.x : -p.x;    \n    p.y = rand.y > 0.5f ? p.y : -p.y;    \n    p = p.y > -p.x ? p : -p;\n    \n    float dist = abs(length(p-0.5)-0.5) - thickness * 0.5;    \n    return smoothstep(0.01f, 0.f, dist);\n}\n\nfloat2 truchetUVsym(float2 p, float thickness, float flow)\n{\n    int2 idx = floor(p);\n    float2 rand = hash(idx);\n    \n    p -= 0.5f + idx;    \n    p.x = rand.x > 0.5f ? p.x : -p.x;\n    p.y = rand.y > 0.5f ? p.y : -p.y;    \n    p = p.y > -p.x ? p : -p;\n    \n    p -= 0.5;    \n    float hT = thickness*0.5;\n    float v = clamp(length(p) - 0.5, -hT, hT) + hT;\n    v /= thickness;\n    v = abs(2.f*v-1.f);\n\n    bool flip = bool((int(idx.x) + int(idx.y)) & 1); \n    float u = atan2(p.y, p.x) + (flip ? flow : -flow);\n    u = flip ? -u : u;    \n\n    return float2(frac(u/PI),v);\n}\n\nfloat2 truchetUV(float2 p, float thickness, float flow)\n{\n    int2 idx = floor(p);\n    float2 rand = hash(idx);\n    \n    p -= 0.5f + idx;    \n    bool flipX = rand.x > 0.5f, flipY  = rand.y > 0.5f;   \n    p.x = flipX ? p.x : -p.x;\n    p.y = flipY ? p.y : -p.y;    \n    p = p.y > -p.x ? p : -p;\n    \n    p -= 0.5;   \n    bool flip = bool((int(idx.x) + int(idx.y)) & 1); \n    float u = atan2(p.y, p.x) + (flip ? flow : -flow);\n    u = flip ? -u : u;    \n    \n    float hT = thickness*0.5;\n    float v = clamp(length(p) - 0.5, -hT, hT) + hT;\n    v /= thickness;\n    v = flip ^^ flipX ^^ flipY ? v : 1.f - v;\n\n    return float2(frac(u/PI),v);\n}\n\nfloat minkowskiLength(float2 v, float p)\n{\n    v = abs(v);\n    return pow(pow(v.x,p)+pow(v.y,p), 1.f / p);\n}\n\nfloat minkowskiTruchet(float2 p, float thickness, float k)\n{\n    int2 idx = floor(p);\n    float2 rand = hash(idx);\n    \n    p -= 0.5f + idx;\n    p.x = rand.x > 0.5f ? p.x : -p.x;    \n    p.y = rand.y > 0.5f ? p.y : -p.y;    \n    p = p.y > -p.x ? p : -p;\n    \n    float dist = abs(minkowskiLength(p-0.5,k)-0.5) - thickness * 0.5;    \n    return smoothstep(0.01f, 0.f, dist);\n}\n\nfloat3 weaveTruchet(float2 p, float thickness, float flow)\n{\n    int2 idx = floor(p);\n    float2 rand = hash(idx);\n    \n    p -= 0.5f + idx;\n    bool flipX = rand.x > 0.5f, flipY  = rand.y > 0.5f;   \n    p.x = flipX ? p.x : -p.x;\n    p.y = flipY ? p.y : -p.y;    \n    p = p.y > -p.x ? p : -p;\n    \n    p -= 0.5;   \n    bool flip = bool((int(idx.x) + int(idx.y)) & 1); \n    float at = atan2(p.y, p.x);\n    float u = at + (flip ? flow : -flow);\n    at = flip ? -at : at;    \n    u = flip ? -u : u;    \n    \n    float hT = thickness*0.5;\n    float l = length(p) - 0.5;\n    float v = clamp(l, -hT, hT) + hT;\n    v /= thickness;\n    v = flip ^^ flipX ^^ flipY ? v : 1.f - v;\n    \n    return float3(pow(smoothstep(thickness * 0.5,thickness * 0.1, abs(l)),0.45)*pow(cos(at)*0.5 + 0.5,0.78f),frac(u/PI),v);\n}\n\n\nfloat sdScale(vec2 fuv, vec2 off)\n{\n    fuv = fuv + off;\n    \n    fuv.x = (fuv.x - 0.3f)* 0.5 + 0.5f;\n    fuv.y *= 0.5;\n    fuv.y += 0.4;\n    \n    return max(length(fuv - vec2(0.5f,0.5f)), length(fuv - vec2(0.85f,0.5f)));\n}\n\nfloat texScales(vec2 uv)\n{    \n    vec2 fuv = fract(uv);    \n    vec2 idx = floor(uv - fuv);\n    \n    fuv.x = bool(int(idx.y) & 1) ? fract(fuv.x + 0.5) : fuv.x;\n\n    float dist = min(sdScale(fuv, vec2(0.f, 0.f)), sdScale(fuv, vec2(-0.5f,-1.f)));    \n    dist = min(dist,sdScale(fuv, vec2(0.5f,-1.f)) );\n    dist = min(dist,sdScale(fuv, vec2(1.f,0.f)));\n    \n    return smoothstep(0.6f,0.f,dist);    \n}\n\nfloat3 tex(float2 uv)\n{\n    return float3(texScales(uv.yx*float2(4.f,12.f)));\n    //return texture(iChannel0, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y *5.+ iTime;    \n\n    vec3 col = vec3(0.f);\n    float3 wt = weaveTruchet(uv, 0.4, iTime);\n    float3 wto = weaveTruchet(uv+0.5, 0.4, iTime);\n    col = tex(wt.yz)*wt.x + tex(wto.yz)*wto.x;\n\n    fragColor = vec4(col*2.,1.0);\n}","name":"Image","description":"","type":"image"}]}