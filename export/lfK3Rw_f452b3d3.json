{"ver":"0.1","info":{"id":"lfK3Rw","date":"1712589341","viewed":187,"name":"Smooth Booleans","username":"dema","description":"Implementation of all the Smooth Boolean operations with Material Blending as explained in https://iquilezles.org/articles/smin/\nUse the keyboard to switch operation: U for union, D for difference, I for intersection, S to toggle smooth vs non smooth ","likes":6,"published":1,"flags":48,"usePreview":1,"tags":["blending","material","smooth","boolean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implementation of all the Smooth Boolean operations with Material Blending as explained in https://iquilezles.org/articles/smin/\n// Use the keyboard to switch operation: U for union, D for difference, I for intersection, S to toggle smooth vs non smooth \n// SDF primitives from https://iquilezles.org/articles/distfunctions/\n// Smooth Booleans adapted from https://iquilezles.org/articles/smin/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DIST 100.\n#define MAX_ITER 70\n#define MIN_DIST 0.001\n\n#define LIGHT_DIR vec3(0.,1.,0.)\n#define METALLIC_COLOR vec3(0.95,0.37,0.09)\n#define DIFFUSE_COLOR  vec3(0.36,0.70,0.66)\n\n#define SMOOTHNESS 0.5\n\nconst int KEY_U  = 85;\nconst int KEY_D  = 68;\nconst int KEY_I  = 73;\nconst int KEY_S  = 83;\n\n//-------------------------------------------------\n//               SDF FUNCTIONS\n//-------------------------------------------------\nstruct Object{\n    float sdf;\n    float blend; // used to interpolate between the two\n};               // materials (metallic vs diffuse)               \n\n\nObject sdSphere(vec3 p, vec3 center, float radius){\n    return Object(\n        length(p-center) - radius,\n        1.0);\n}\n\nObject sdBox( vec3 p, vec3 center,vec3 b )\n{\n  p = p-center;\n  vec3 q = abs(p) - b;\n  return Object(\n      length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),\n      0.0);\n}\n\n//-------------------------------------------------\n//                 BOOLEANS\n//-------------------------------------------------\n\nObject opUnion(Object o1,Object o2){\n    if(o1.sdf <= o2.sdf)\n        return o1;\n    else\n        return o2;\n}\n\nObject opIntersection(Object o1, Object o2){\n    if (o1.sdf >= o2.sdf)\n        return o1;\n    else\n        return o2;\n}\n\nObject opDifference(Object o1, Object o2){\n    o2.sdf = - o2.sdf;\n    if (o2.sdf >= o1.sdf)\n        return o2;\n    else\n        return o1;\n}\n\n//-------------------------------------------------\n//               SMOOTH BOOLEANS\n//-------------------------------------------------\n\n// smooth function in [-1,1] to\n// implement smooth min and \n// smooth max\nfloat quadraticFunction(float x){\n    if (x<-1.0) return 0.0;\n    if (x >1.0) return x;\n    return 0.25*(x * (2.0 + x) + 1.0); \n}\n\nObject opSmoothUnion(Object o1, Object o2){\n    float blend = SMOOTHNESS * quadraticFunction( (o2.sdf - o1.sdf) / SMOOTHNESS);\n    float sdf = o2.sdf - blend;\n    return Object(sdf,1.0 - blend);\n}\n\nObject opSmoothIntersection(Object o1, Object o2){\n    float blend = SMOOTHNESS * quadraticFunction( (o2.sdf - o1.sdf) / SMOOTHNESS);\n    float sdf = o1.sdf + blend;\n    return Object(sdf,blend);\n}\n\nObject opSmoothDifference(Object o1, Object o2){\n    float blend = SMOOTHNESS * quadraticFunction( (o1.sdf + o2.sdf) / SMOOTHNESS);\n    float sdf = -o2.sdf + blend;\n    return Object(sdf,1.0 - blend);\n}\n\n//-------------------------------------------------\n//               MAP FUNCTION\n//-------------------------------------------------\n\n// Instantiate the scene, combining the \n// two primitives (box and sphere). The op_code\n// controls how the primitives are combined:\n// -> op_code = 3.0  => smooth union\n// -> op_code = 2.0  => smooth difference\n// -> op_code = 1.0  => smooth intersection\n// -> op_code = -3.0 => union\n// -> op_code = -2.0 => difference\n// -> op_code = -1.0 => intersection\nObject map(vec3 p, float op_code){\n    Object sphere =  sdSphere(p,vec3(.0,sin(0.8*iTime)-0.4,0.),1.0);\n    Object box = sdBox(p,vec3(0.,-1.,0.),vec3(1.5,0.2,1.5));\n    // smooth booleans\n    if(op_code >= 0.0){\n        if(op_code > 2.5) return opSmoothUnion(box,sphere);\n        if(op_code > 1.5) return opSmoothDifference(box,sphere);\n        return opSmoothIntersection(box,sphere);\n    }\n    // non smooth booleans\n    else{\n        if(op_code < -2.5) return opUnion(box,sphere);\n        if(op_code < -1.5) return opDifference(box,sphere);\n        return opIntersection(box,sphere);\n    }\n}\n\n//-------------------------------------------------\n//             SHADING FUNCTIONS\n//-------------------------------------------------\n\n// an helper function that analytically computes \n// the normal of the scene at a given point p\nvec3 calcNormal(vec3 p,float op_code){\n    vec3 dx = vec3(.001,0.,0.);\n    vec3 dy = vec3(0.,.001,0.);\n    vec3 dz = vec3(0.,0.,.001);\n    float fp = map(p,op_code).sdf;\n    return normalize(\n        dx * (map(p+dx,op_code).sdf - fp) + \n        dy * (map(p+dy,op_code).sdf - fp) +\n        dz * (map(p+dz,op_code).sdf - fp)\n    );\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, float op_code){\n    float t = 0.;\n    float currentDist = map(ro + t*rd, op_code).sdf;\n    \n    for(int i = 0; i < MAX_ITER; i++){\n        if (currentDist < MIN_DIST)\n            return t;\n        if (currentDist > MAX_DIST)\n            return -1.0;\n        t += currentDist;\n        currentDist = map(ro + t*rd, op_code).sdf;\n    }\n    return -1.0;\n}\n\n// shade the two materials according to \n// the blend parameter\nvec3 shade(vec3 ro, vec3 rd, float op_code){\n    vec3 color;\n    vec3 metallic;\n    vec3 diffuse;\n    \n    float t = rayMarch(ro,rd, op_code);\n    if(t>0.){\n        vec3 p = ro + t*rd;\n        Object o = map(p,op_code);\n        //return vec3(o.blend);\n        vec3 n = calcNormal(p,op_code);\n        vec3 r = reflect(rd,n);\n        float cos_theta = clamp(dot(n,LIGHT_DIR),0.,1.);\n        metallic = texture(iChannel0,r).rgb * METALLIC_COLOR;\n        diffuse = cos_theta * DIFFUSE_COLOR;\n        color = o.blend * metallic + (1.0 - o.blend) * diffuse;\n        \n    }\n    else{\n        color = texture(iChannel0,rd).rgb;\n    }\n    return color;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 z = normalize(ta-ro);\n\tvec3 up = vec3(0.0,1.0,0.0);\n\tvec3 x = -normalize( cross(z,up) );\n\tvec3 y =          ( cross(z,x) );\n    return mat3( x, y, z );\n}\n\n//-------------------------------------------------\n//                    MAIN\n//-------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (y from -1 to 1, x from -ar to ar)\n    vec2 uv = (2.* fragCoord - iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.* iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    float op_code;\n    if (iFrame == 0)\n        op_code = 3.0;\n    else\n        op_code = texture(iChannel1,fragCoord/iResolution.xy).w;\n\n    vec3 ta = vec3( 0.,0.,0.);\n    vec3 ro = ta + vec3(0.,.5,3.);\n    mat3 ca = setCamera( ro, ta);\n    const float fl = 1.5;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = ca * normalize( vec3(p,fl) );\n    \n    // Keyboard Event Handler:\n    // U -> union\n    // D -> difference\n    // I -> intersection\n    // S -> toggle smooth vs non smooth\n    if(texelFetch(iChannel2, ivec2(KEY_U, 0), 0).r >= 0.5)op_code = 3.0;\n    if(texelFetch(iChannel2, ivec2(KEY_D, 0), 0).r >= 0.5)op_code = 2.0;\n    if(texelFetch(iChannel2, ivec2(KEY_I, 0), 0).r >= 0.5)op_code = 1.0;\n    if(texelFetch(iChannel2, ivec2(KEY_S, 0), 0).r >= 0.5)op_code *= -1.0;\n\n    vec3 color = shade(ro,rd,op_code);\n    fragColor = vec4(color,op_code);\n\n}","name":"Buffer A","description":"","type":"buffer"}]}