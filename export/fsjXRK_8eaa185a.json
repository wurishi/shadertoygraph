{"ver":"0.1","info":{"id":"fsjXRK","date":"1620579860","viewed":97,"name":"Spirale logarithmique tournante","username":"19elamraou","description":"Spirale logarithmique telle que r = a*b^theta \nAnti-aliasing :\n- smoothstep sur les deux bords \n- Moyennage sur tous les pixels","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["spiralelogarithmique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define PI 3.14159265359\n\nfloat theta(vec2 map){ //angle entre 0 et 2PI\n    float angle = mod(atan(map.y, map.x), 2.*PI);\n    return angle;\n} \n\nvec2 spiral_lower_upper(float a, float b, float angle, float r){ //On calcule la spirale initiale entre 0 et 2PI puis on fait des homotéthies de b^2PI à chaque tour, on renvoie les deux bouts de spirale entre lesquels se trouve r pour le plot final\n    float r0=a*pow(b,2.*PI); \n    float N = floor(1.+log(r/r0)/(2.*PI*log(b))); //nb tours\n    //N = 0;\n    return vec2(r0*pow(b,angle+2.*PI*(N-1.)),r0*pow(b,angle+2.*PI*(N)));\n}\n\nvec3 spiral(vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y; //reshape with aspect ratio\n    uv *=5.;\n    \n    // Defining the spiral parameters, r = a*b^angle\n    float a=.4;\n    float b=1.2;\n    float r = length(uv);\n    float angle = mod(theta(uv)+3.*iTime, 2.*PI); //modulo 2PI\n    \n    vec2 spiral = spiral_lower_upper(a, b, angle, r);\n    \n    //Plot parameters\n    float width = .1*r;\n    vec3 lineColor = vec3(1); //0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); //color of the spiral\n    vec3 col = (fract(smoothstep(spiral[0]-width, spiral[0], r))+smoothstep(spiral[1]-width,spiral[1],r))*lineColor;\n    col *= 4.*(1. - (fract(smoothstep(spiral[0]-width, spiral[0], r))+smoothstep(spiral[1]-width,spiral[1],r)));\n    //vec3 col = (smoothstep(spiral[0]-width, spiral[0], r))*lineColor; //Il manque un bout de la spirale à chaque tour à cause du smoothstep qui recouvre tout jusqu'au bout de spirale suivant, d'où la nécessité de garder en mémoire les deux bouts de spirale pour récupérer le bout manquant au début de chaque tour\n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0 //test avec ou sans anti-aliasing\n    vec3 col = spiral(fragCoord);\n#else\n    float m = .25;\n    vec3 col = vec3(0);\n    col += spiral(fragCoord + vec2(m, m));\n    col += spiral(fragCoord + vec2(-m, m));\n    col += spiral(fragCoord + vec2(m, -m));\n    col += spiral(fragCoord + vec2(-m, -m));\n    col /= 4.;\n#endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}