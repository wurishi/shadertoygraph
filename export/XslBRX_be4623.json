{"ver":"0.1","info":{"id":"XslBRX","date":"1497250982","viewed":195,"name":"Swamp Drain","username":"Passion","description":"A swamp drain :) ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","raymarch","cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_STEPS 64\n#define EPS 0.001\n#define FAR_CLIP 100.0\n#define time iTime\n\nmat2 r2D(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 amod(vec2 p, float m){\n    float a = mod(atan(p.x,p.y),m)-m*.5;\n    return vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat sc(vec3 p){\n    vec3 a = abs(p);\n    return min(min(max(a.x, a.y), max(a.y, a.z)), max(a.z, a.x));\n}\n\nvec2 path(in float z){ \n    float s = sin(z/24.)*cos(z/12.); \n    return vec2(s*12., -s*2.); \n}\n\nfloat water(vec3 p){\n    return 4.-(p.y*-1.) + (sin(sin(p.z*0.1253-time*3.) - p.x*0.311+time*1.6)*0.31 + \n                           cos(2.6*time-p.z*0.53 + sin(2.2*time+p.x*0.127))*0.12)*1.7 + 0.2;\n}\n// https://www.youtube.com/watch?v=Oa_zCThLXRw\nfloat map(vec3 p){    \n    vec3 o = p;\n    vec2 ms = iMouse.xy;\n    p.xy = abs(amod(p.xy, 1.9168*1.));\n    p.z = mod(p.z,4.)-2.;\n    \n    for(int i = 0; i <3; i++)\n        p = abs(refract(p, normalize(vec3(.173, -.41, .512)), 1.0));\n    \n    p.y = abs(p.y+.05)-.81;\n   \n    vec2 tun = abs(o.xy - path(o.z))*vec2(0.7, 0.9071);\n    float n = 1.- length(tun.xy);// + (0.5-surfFunc(p)); //max(tun.x, tun.y)\n\n    float fr = sc(abs(p-.1) - (sin(o.z*-1.)*.5+.5)-1.0) - .35 - max(length(o.xy)*.05,2.); \n    return max(min(fr, -n), -water(o));\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for(int i = 0; i<NUM_STEPS; i++){\n        vec3 p = o+r*t;\n        float d = map(p);\n        \n        if(abs(d) < EPS || abs(t) > FAR_CLIP) \n            break;\n        \n        t += d;// *0.75;\n    }\n    return t;\n}\n//(rand()%8000 - 1000.0f)/25.0f\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.0, EPS);\n    return (vec3(map(p + e.yxx), map(p + e.xyx), map(p + e.xxy)) - map(p)) / e.y;\n}\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(EPS, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tvec3 lookAt = vec3(0.0, 0.0, time*8.);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\n    \n\tcamPos.xy += path(camPos.z);\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)*.33));\n    vec3 o = camPos;//vec3(0., 0.,-time*10.);\n    \n    r.xy*=r2D(3.2-path(-camPos.z).x/19.);\n    r.zx*=r2D(3.2-path(-camPos.z).x/8.);\n    r.zy*=r2D(path(-camPos.z).y/7.);\n    vec4 bg = vec4(.25);//pow(vec4(.1, .75, .8, 1), vec4(4.*(r.y+1.0)));\n    \n    float hit = trace(o, r);\n    \n    vec3 sp = o+r*hit;\n    float d = map(sp);\n    vec3 l = normalize(vec3(0., -.05, -0.4));\n    vec3 n = getNormal(sp);\n    vec3 n2 = n;\n    vec3 tx = tex3D(iChannel1, sp*(1.0/5.0), n)*1.5;\n    n = doBumpMap(iChannel1, (sp)*(1.0/5.0), n, 0.05);\n    \n    float dif = clamp(dot(n, l), 0.33, 1.0);\n    \n    //tx.b*=1.5;\n    // this is blinn phong\n    vec3 halfDir = normalize(l - r);\n    float specAngle = max(dot(halfDir, n), 0.0);\n    float spec = pow(specAngle, 60.0);\n    \n    float fog = smoothstep(0.0, 1.2, -hit*.03);\n    vec3 rf = refract(r, n, 1.0/1.33);\n    vec4 txc = texture(iChannel0, rf);//*1.5;\n    float w = water(sp);\n    if(abs(d) < 0.05){\n        fragColor = mix(vec4(txc.rgb*tx.rgb*dif, 1.0), bg, fog);\n        if(abs(w) < 0.05){\n            n = getNormal(sp);\n            float dif2 = clamp(dot(n2,vec3(0.0,-.8,-0.40)),0.2,1.0);\n            vec3 rf = reflect(r,n2);\n            vec4 cm = texture(iChannel2, rf);\n            vec4 water = mix(vec4(0.1,0.5,0.65,1.0),vec4(0.1,0.4,0.7,1.0),4.+sp.y);\n        \tfragColor = mix(dif2*water*cm+spec,bg,fog);\n        }\n    }\n    else\n        fragColor = bg;\n}","name":"Image","description":"","type":"image"}]}