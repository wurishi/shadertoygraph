{"ver":"0.1","info":{"id":"Ndfyzf","date":"1644668415","viewed":87,"name":"telecom_shadertoy_project_S_D","username":"lumen","description":"Project at Telecom Nancy","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["project"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FARAWAY=1e30;\nconst float EPSILON=1e-3;\n\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n // TODO\n    C.Obs = Obs;\n    C.View = normalize(LookAt-Obs);\n    C.Horiz = normalize(cross(vec3(0,0,1),C.View));\n    C.Up = cross(C.View, C.Horiz);\n    C.H = float(iResolution.y);\n    C.W = float(iResolution.x);\n    C.z = C.H / 2.0*tan((aperture * 3.1415 / 180.0)/2.0);\n    return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   // TODO\n   r.Origin = C.Obs;\n   r.Dir = C.z*C.View + (XY.x - C.W/2.0)*C.Horiz + (XY.y - C.H/2.0)*C.Up;\n   return r;\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nstruct Box {\n    vec3 min;\n    vec3 max;\n};\n// Creates a Box with a given center, hafh_width, half_height, and half_depth\nBox BoxWHD(in vec3 center, in float half_w, in float half_h, in float half_d){\n    vec3 offset = vec3(half_d, half_w, half_h);\n    vec3 min = center - offset;\n    vec3 max = center + offset;\n    return Box(min, max);\n}\n// Creates a Box with a given radius\nBox Cube(in vec3 center, in float radius){\n    vec3 offset = vec3(radius, radius, radius);\n    vec3 min = center - offset;\n    vec3 max = center + offset;\n    return Box(min, max);\n}\n\n\nstruct Material {\n    vec3 Kd; // diffuse color (object textures)\n    vec3 Ke; // emissive color (lights)\n};\n\nMaterial diffuse(in vec3 Kd) {\n   return Material(Kd, vec3(0.0, 0.0, 0.0));\n}\n\nMaterial light(in vec3 Ke) {\n   return Material(vec3(0.0, 0.0, 0.0), Ke);\n}\n\nstruct SphereObject {\n   Sphere sphere;\n   Material material;\n};\nstruct BoxObject {\n   Box box;\n   Material material;\n};\n\n\n// Returns the box center\nvec3 boxCenter(in BoxObject boxObj){\n    return (boxObj.box.min + boxObj.box.max) / 2.0;\n}\n\nSphereObject spheres[7];\nBoxObject boxes[5];\nint sphereIndex;\nint boxIndex;\n\n\n//COULEURS\nconst vec3 white = vec3(1, 1, 1);\nconst vec3 black = vec3(0, 0, 0);\nconst vec3 red = vec3(0.9, 0.08, 0.08);\nconst vec3 blue = vec3(0.1, 0.2, 0.9);\nconst vec3 yellow = vec3(1, 1, 0);\nconst vec3 orange = vec3(1, 0.5, 0);\nconst vec3 grey = vec3(0.1, 0.1, 0.1);\nconst vec3 green = vec3(0.1, 0.7, 0.3);\nconst vec3 purple = vec3(0.8, 0.2, 0.8);\n\n\nvoid init_scene(in vec2 uv) {\n   float beta = float(iFrame)/60.0;\n   float alpha = float(iFrame)/30.0;\n   float sb = sin(beta);\n   float cb = cos(beta);\n   float sa = sin(alpha);\n   float ca = cos(alpha);\n   \n   //Texture rotation\n   float gamma = sin(float(iFrame) / 100.0);\n   float sg = sin(gamma);\n   float cg = cos(gamma);\n   mat2 rotationMatrix = mat2( cg, -sg, sg,  cg);\n   vec2 pivot = vec2(0.5, 0.5);\n   uv = rotationMatrix * (uv - pivot) + pivot;\n   vec3 colTexture = texture(iChannel0, 2.0*uv).xyz;\n   \n\n   spheres[sphereIndex++] = SphereObject(\n      Sphere(vec3(0.0, 0.0, 0.0), 0.5), \n      diffuse(white)\n   );\n   spheres[sphereIndex++] = SphereObject(\n      Sphere(vec3(0.8*sa, 0.8*ca, 0.0), 0.15), \n      diffuse(blue)\n   );\n   spheres[sphereIndex++] = SphereObject(\n      Sphere(vec3(1.0*sb, 1.0*cb, 0.2), 0.1),\n      diffuse(red) \n   );\n   \n   //lights\n   spheres[sphereIndex++] = SphereObject(\n      Sphere(vec3(1.5, 0.0, 1.5),0.02),\n      light(blue) \n    );\n   spheres[sphereIndex++] = SphereObject(\n      Sphere(vec3(3.0, 0.0, 0.0), 0.02),\n      light(white) \n   );\n   spheres[sphereIndex++] = SphereObject(\n      Sphere(vec3(0.0, -4.0, 3.0), 0.02),\n      light(yellow) \n   );\n   spheres[sphereIndex++] = SphereObject(\n      Sphere(vec3(0.0, 4.0, 3.0), 0.02),\n      light(grey) \n   );\n    \n    // Boxes\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0, 1.5, -0.7), 0.3, 0.4, 0.4),\n        diffuse(orange));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0, 1.5, 0.3), 0.3, 0.3, 0.4),\n        diffuse(yellow));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0, 1.7, -0.15), 0.1, 0.15, 0.4),\n        diffuse(purple));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0, 1.3, -0.15), 0.1, 0.15, 0.4),\n        diffuse(purple));\n        \n     // Floor\n    boxes[boxIndex++] = BoxObject(\n        Box(vec3(-5, 5, -1), vec3(5, -5, -10)),\n        diffuse(colTexture)\n    );\n\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    vec3 CO = R.Origin - S.Center;\n    float a = dot(R.Dir, R.Dir);\n    float b = 2.0*dot(R.Dir, CO);\n    float c = dot(CO, CO) - S.R*S.R;\n    float delta = b*b - 4.0*a*c;\n    if (delta < 0.0){\n        return false;\n    }\n    t = (-b-sqrt(delta)) / (2.0*a);\n    return true;\n}\n\n\nvoid swap(inout float a, inout float b)\n{\n    float temp = a;\n    a = b;\n    b = temp;\n}\nbool intersect_box(in Ray R, in Box C, out float t){\n    // Based on https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\n    float tmin = (C.min.x - R.Origin.x) / R.Dir.x;\n    float tmax = (C.max.x - R.Origin.x) / R.Dir.x;\n    if (tmin > tmax)\n        swap(tmin, tmax);\n    float tymin = (C.min.y - R.Origin.y) / R.Dir.y;\n    float tymax = (C.max.y - R.Origin.y) / R.Dir.y;\n    if (tymin > tymax)\n        swap(tymin, tymax);\n    if ((tmin > tymax) || (tymin > tmax))\n        return false;\n    if (tymin > tmin)\n        tmin = tymin;\n    if (tymax < tmax)\n        tmax = tymax;\n    float tzmin = (C.min.z - R.Origin.z) / R.Dir.z;\n    float tzmax = (C.max.z - R.Origin.z) / R.Dir.z;\n    if (tzmin > tzmax)\n        swap(tzmin, tzmax);\n    if ((tmin > tzmax) || (tzmin > tmax))\n        return false;\n    if (tzmin > tmin)\n        tmin = tzmin;\n    if (tzmax < tmax)\n        tmax = tzmax;\n    t = tmin;\n    return true;\n}\n\n\n\nbool shadow(in Ray R) {\n   for(int i=0; i < spheres.length(); ++i) {\n        float t;\n        if(\n          spheres[i].material.Ke == vec3(0.0, 0.0, 0.0) &&\n          intersect_sphere(R, spheres[i].sphere, t) &&\n          t > EPSILON && t < 1.0 && t > 0.0\n        ) {\n          return true;\n        }\n    }\n    for (int i = 0; i < boxes.length(); ++i)\n    {\n        float t;\n        if (\n            boxes[i].material.Ke == vec3(0, 0, 0) &&\n            intersect_box(R, boxes[i].box, t) &&\n            t > EPSILON && t < 1.0 && t > 0.0\n            ){\n            return true;\n        }\n    }\n    return false;\n}\n\nconst vec3 shadowVec3 = vec3(0.1, 0.1, 0.1);\n\nvec3 lighting(in vec3 P, in vec3 N, in Material material) {\n   if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n      return material.Ke;\n   }  \n\n   vec3 result = vec3(0.0, 0.0, 0.0);\n\n   for(int i=0; i<spheres.length(); ++i) {\n      if(spheres[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, spheres[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 light = spheres[i].sphere.Center - P;\n           float lamb = max(0.0, dot(N, light) / length(light)*length(N));\n           result += lamb * material.Kd * spheres[i].material.Ke;\n         }\n      }\n   }\n   for (int i = 0; i < boxes.length(); ++i){\n        if (boxes[i].material.Ke != vec3(0.0, 0.0, 0.0)){\n            vec3 center = boxCenter(boxes[i]);\n            Ray R2 = Ray(P, center);\n\n            vec3 E = center - P;\n            float lamb = max(0.0, dot(E, N) / length(E));\n            result += lamb * material.Kd * boxes[i].material.Ke;\n\n            if (shadow(R2))\n            {\n                result -= shadowVec3;\n            }\n        }\n    }\n\n   return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    init_scene(uv);\n\n    /*Camera C = camera(\n        vec3(2.0, 2.0, 1.5),\n        vec3(0.5, 0.5, 0.5),\n        100.0       \n    );*/\n    \n    float beta = sin(float(iFrame) / 100.0);\n    float s = (sin(beta));\n    float c = (cos(beta));\n\n    Camera C = camera(\n        vec3(2.0*c, 2.0*s, 0.5*c),       // Obs\n        vec3(0.0, 0.0, -0.3),            // LookAt\n        120.0);                          // Aperture\n\n\n    Ray R = launch(C, fragCoord);\n\n    //fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n    fragColor = vec4(0.7, 0.4, 0.2, 1.0);\n\n    const float FARAWAY=1e30; \n    float t = FARAWAY;\n\n    vec3 P;  // Point courant\n    vec3 N;  // Normale\n    Material material; // Couleur\n\n    for(int i=0; i<spheres.length(); ++i) {\n        float cur_t;\n        if(\n           intersect_sphere(R, spheres[i].sphere, cur_t) \n           && cur_t < t\n        ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - spheres[i].sphere.Center);\n           material = spheres[i].material;\n        } \n    }\n    for (int i = 0; i < boxes.length(); ++i)\n    {\n        float cur_t;\n        if (intersect_box(R, boxes[i].box, cur_t) && cur_t < t)\n        {\n            t = cur_t;\n            P = R.Origin + t * R.Dir;\n            N = normalize(P - boxCenter(boxes[i]));\n            material = boxes[i].material;\n        }\n    }\n    \n\n\n    if(t != FARAWAY) {\n        fragColor.rgb = lighting(P,N,material);\n    }\n\n}","name":"Image","description":"","type":"image"}]}