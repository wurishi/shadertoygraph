{"ver":"0.1","info":{"id":"XdKyDt","date":"1523845788","viewed":1039,"name":"2D Adventures #2 - Hex Grid","username":"bombshell93","description":"The purpose of this was to understand hexagonal coordinate systems in the context of a shader, I'd expected this to take a bit more fiddling, but I also don't want to over develop it, so I put in some mouse interaction for the fun of it.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","mouse","grid","interactive","hex","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//// ABSTRACT\n//\n//\tThe purpose of this was to understand hexagonal coordinate systems in the\n//\tcontext of a shader, the ease of understanding is thanks in no small part\n//\tto the redblobgames blog on the subject:\n//\t\thttps://www.redblobgames.com/grids/hexagons/#distances\n//\n//\tI'd expected this to take a bit more fiddling, but I also don't want to over\n//\tdevelop this shader, as its fulfilling its purpose, so I put in some mouse\n//\tinteraction (click to see what I mean) for the fun of it.\n//\t\n//\n//// AUTHOR\n//\n//\tScott R Howell (bombshell93)\n\n#define PI 3.14\n#define PI2 6.28\n\n#define HX vec2(1., 0.)\n#define HY vec2(.5, 0.866)\n#define HMAT mat2(HX, HY)\n#define HSCALE 0.05\n\n//// pixelToCubial\n//\n//\tconverts a pixel coordinate to a hex grid cubial coordinates\n\nvoid pixelToCubial(vec2 uv, out vec3 cubial, out vec3 grid) {\n    \n    vec2 axial = inverse(HMAT) * uv;\n    cubial = vec3(axial, -axial.x - axial.y) / HSCALE;\n    grid = round(cubial);\n    vec3 dist = abs(cubial - grid);\n    if (dist.x > dist.y && dist.x > dist.z) {\n    \t\n        grid.x = -grid.y - grid.z;\n    }\n    else if (dist.y > dist.z) {\n        \n        grid.y = -grid.x - grid.z;\n    }\n    else {\n        \n        grid.z = -grid.x - grid.y;\n    }\n}\n\n//// cubialDistance\n//\n//\tfinds the distance between 2 hex cell positions\n\nfloat cubialDistance(vec3 a, vec3 b) {\n    \n    vec3 c = abs(a - b);\n    return max(c.x, max(c.y, c.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    // find cubial coordinates\n    \n    vec3 cubial;\n    vec3 grid;\n    vec3 mouse;\n    pixelToCubial((iMouse.xy - iResolution.xy * .5) / iResolution.y, cubial, mouse);\n    pixelToCubial(uv, cubial, grid);\n    \n    \n    // get per tile coordinates\n    \n    vec3 coord = cubial - grid;\n    vec3 dist = abs(coord.xyz - coord.zxy);\n    \n    vec3 col = cos(grid + iTime) * .5 + .5;\n    \n    // outline\n    \n    col *= smoothstep(.2, .2 + (2.0 / iResolution.y) / HSCALE, 1.0 - max(dist.x, max(dist.y, dist.z)));\n    \n    // react to mouse input\n    \n    float mouseDist;\n    if (iMouse.z > .0 && iMouse.w > .0 && (mouseDist = cubialDistance(grid, mouse)) < 4.) {\n        \n        float mouseDist = cubialDistance(grid, mouse);\n    \tcol = mix(col, vec3(1.), max(.0, sin(mouseDist - iTime * 4.) * .5 + .5));\n    }\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}