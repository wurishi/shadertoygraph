{"ver":"0.1","info":{"id":"3l3fWn","date":"1612476139","viewed":126,"name":"Bouncing balls","username":"niels747","description":"simple particle physics","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["particlephysics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe main problem with this way of visualizing particles is that the visualization\ntakes way more processing power than the simulation. \nEspecially at high render resolution, because every pixelshader has to loop through every particle.\nVisualization should normally be done with polygons, but that is ofcourse not possible here.\n\n*/\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    // replace \"numPart\" in the for loop with a low numer to see less particles rendered and the fps increase. \n     for(int x = 0; x < numPart; x++)\n     for(int y = 0; y < numPart; y++){\n\n vec4 particle = texelFetch(iChannel0, ivec2(x,y), 0);\n    \n\n    \n    \n    if(length(particle.xy - fragCoord) < radius){\n    col = hsv2rgb(vec3(min(length(particle.zw),1.9)* -0.3+0.6,1.,1.)); // color indicates velocity\n    //col = vec3(1); // simple white particle\n    }\n    }\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nPhisics engine:\n\n\n[0] / x = x\n[1] / y = y\n[2] / z = Vx\n[3] / w = Vy\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nivec2 iCoord = ivec2(fragCoord);\n\n// Normalized pixel coordinates (from 0 to 1)\nvec2 uv = fragCoord/iResolution.xy;\n\nif(iCoord.x < numPart && iCoord.y < numPart){\n\n ivec2 iRes = ivec2(iResolution);\n \n vec4 This = texelFetch(iChannel0, iCoord, 0);\n \n if(iTime < 1.) // setup\n This = vec4(1.+fragCoord.x*radius*2. + fragCoord.y*radius,fragCoord.y*radius*1.7,0.,0.);\n else{\n \n vec2 force = vec2(0);\n \n for(int x = 0; x < numPart; x++)\n for(int y = 0; y < numPart; y++){\n vec4 other = texelFetch(iChannel0, ivec2(x,y), 0);\n \n vec2 relPos = other.xy - This.xy;\n float centerDist = length(relPos);\n \n float surfDis = centerDist - radius*2.;\n \n if(surfDis < 0.){ // collision\n force += relPos * 0.04 * surfDis;\n force += (other.zw - This.zw)*colFric; // collision friction\n }\n \n } // for\n \n force.y += max(radius - This.y,0.)*0.1; // ground collision\n force.x += max(radius - This.x,0.)*0.1; // left side collision\n force.x -= max(radius + This.x - iResolution.x,0.)*0.1; // right side collision\n \n force.y += gravity;\n \n This.zw += force; // apply force\n This.xy += This.zw; // move\n \n }\n fragColor = This;\n\n}else{ // not active particle\n    fragColor = vec4(0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define numPart 20 // actual number of particles is this^2\n#define radius 5.\n#define gravity -0.05\n#define colFric 0.05 // collision friction, behaves 0.0 like gas, 0.002 like liquid 0.05 like solid, unstable above 0.05","name":"Common","description":"","type":"common"}]}