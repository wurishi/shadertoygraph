{"ver":"0.1","info":{"id":"dsXczM","date":"1686661973","viewed":42,"name":"straight line kaborkian","username":"kaborkian","description":"drawing a straight line with even thickness between 2 points","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["vector","portfolio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = makeClipSpace(fragCoord, iResolution);\n    vec2 mpos = makeClipSpace(iMouse.xy, iResolution);\n    vec3 col = vec3(0.0); // background color\n    col = mix(col, vec3(1.0), drawAxis(uv)); // drawing axes\n    \n    vec2 p1 = vec2(cos(iTime), sin(iTime)); // rotates along the unit circle\n    vec2 p2 = mpos; // mouse position\n    vec2 p3 = uv;\n    float sm1 = 0.5; // segment brightness multipliers\n    float sm2 = 1.0;\n    float sm3 = 0.5;\n    \n    vec2 p12 = p2 - p1; // displacement vector from p1 to p2\n    vec2 p13 = p3 - p1; // displacement vector from p1 to p3\n    p12 = normalize(p12);\n    float projection = dot(p13, p12);\n    float l = distance(p1, p2);\n    float rl = projection / l; // relative length\n    vec2 p4 = mix(p1, p2, rl); // lerping to get the vector to the intersection point\n    float d = distance(p3, p4); // distance from line\n    const float thickness = 0.013;\n    float mask = step(distance(p3, p4), thickness); // boolean hard edged mask b/w\n    float seg1 = step(rl, 0.0) * sm1; // brightness of segment connected only to p1, segments are unaffected by distance\n    float seg2 = step(rl, 1.0) * step(0.0, rl) * sm2; // brightness of segment connecting both points\n    float seg3 = step(1.0, rl) * sm3; // brightness of segment connected only to p2\n    mask *= (seg1 + seg2 + seg3);\n    \n    vec3 layer = vec3(mask) * vec3(1.0, 1.0, 0.0); // multiplying by yellow\n    col = mix(col, layer, mask); // mixing background layers with the new one\n    \n    const float r = 0.025; // radius for points\n    col = mix(col, vec3(1.0, 0.0, 0.0), step(sdfCircle(p1, r, uv), r)); // p1 red\n    col = mix(col, vec3(0.0, 0.0, 1.0), step(sdfCircle(p2, r, uv), r)); // p2 blue\n\tfragColor = vec4(col, 1.0); // applying the final color to the pixel\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// library of custom made functions that i find usefull, feel free to use - made by kaborkian\n// an exclamation mark '[!]' means the input is necessary\n// and a question mark '[?]' means its optional and if unprovided will be given default values\n//_____________________________________________________________________________________________\n// input: current fragment coordiantes in absolute values\n// output: remapped fragment coordinates where the origin (0,0) is centered on the canvas.\n// short axis coordiantes will get remapped to -1 <> 1 and long axis values will exceed.\n\nvec2 makeClipSpace(vec2 fragCoord, vec3 iResolution){\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec2 uv = vec2(fragCoord.xy / iResolution.xy); // range 0 <-> 1\n    uv = uv * 2.0 - 1.0; // center origin and remap to range -1 <-> 1\n    uv.x *= aspect_ratio; // fix stretching of the long axis making its values exceed -1 <-> 1\n    return uv;\n}\n//_____________________________________________________________________________________________\n// input1: the circle's position as a 2d coordinate of its center,\n// added as an offset after calcualtions are done from the origin (0,0)\n// input2: circle radius, if radius is 0 then its a filled circle and not a ring,\n// because all distances will be measured from the same point 'p'\n// input3: point from which wew are measuring the distance\n// output: distance from point 'p' to a circle with radius 'r' that its center is located at 'pos'\n\nfloat sdfCircle(vec2 pos, float r, vec2 p) {\n        return length(vec2(p.x - pos.x, p.y - pos.y)) - r;\n}\n//_____________________________________________________________________________________________\nvec3 invertColor(vec3 col) {\n    return vec3(1.0 - col.x, 1.0 - col.y, 1.0 - col.z);\n}\n//_____________________________________________________________________________________________\n// input1[!] [uv]: 2d vector of uv\n// input2[?] [pois]: array of length 5 containing specific points of interest, to be highlited with an opposite color\n// output: easily readable uv fragment color values for debugging\nvec4 viewUV(vec2 uv, vec2[5] pois) {\n    vec3 col = vec3(uv, 0.0);\n    // adding blue value to indicate being out of clip space bounds\n    if (uv.x < -1.0 || uv.x > 1.0) {\n        col.z += 0.5;\n    }\n    if (uv.y < -1.0 || uv.y > 1.0) {\n        col.z += 0.5;\n    }\n    vec2 poi;\n    vec3 stamp_color = invertColor(col); // highlighting with inverted colors of uv\n    float mask; // used for combining the layer of uv and the layer of poi\n    float radius = 0.05;\n    float d;\n    for (int i = 0; i < 5; i++) { // looping points of interest\n        poi = pois[i];\n        d = sdfCircle(poi, 0.0, uv); // radius 0.0 for a filled circle\n        mask = step(d, radius); // making the mask boolean ie interpolation = constant\n        col = mix(col, stamp_color, mask);\n    }\n    return vec4(col, 1.0);\n}\nvec4 viewUV(vec2 uv) {\n    return viewUV(uv, vec2[5](\n        vec2(0.0, 0.0),\n        vec2(-1.0, -1.0),\n        vec2(-1.0, 1.0),\n        vec2(1.0, -1.0),\n        vec2(1.0, 1.0)));\n}   \n//_____________________________________________________________________________________________\n// input1[!] [uv]: uv\n// input2[!] [radius]: size of glowing area\n// input3[!] [intensity]: strength of the glow\n// output: glowing amount of fragment, values in the center of glowing parts approach infinite value\n// because of the ifinite value, which will appear first, if there is any amount of glow,\n// some of is assured to be completly white\n\nfloat infiniteGlow(float uv, float radius, float intensity) {\n    return intensity * (radius / uv - radius); // substract radius so the min value is 0 and not radius\n}\n//_____________________________________________________________________________________________\n// input1[!] [uv]: uv\n// input2[!] [radius]: size of glowing area\n// input3[!] [glow]:  strength of the glow\n\nfloat glow(float uv, float radius, float glow) {\n    return pow(uv, radius) * glow;\n}\n//_____________________________________________________________________________________________\n// input1[!] [a]: first value\n// input2[!] [b]: second value\n// input3[!] [t]: mixing factor between the two values, in range 0 <> 1 \n// output: mixing result, linearly interpolated. if t=0.5 then identical to doing an average.\n// identical to using the built-in function mix(a, b, t)\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n//_____________________________________________________________________________________________\nfloat mapRange(float oldMin, float oldMax, float newMin, float newMax, float value) {\n    float relative_position = (value - oldMin) / (oldMax - oldMin); // deducted from the lerp function\n    return mix(newMin, newMax, relative_position);\n}\n//_____________________________________________________________________________________________\n// input1[!] [uv]: uv coordinate space to draw xy axes in\n// input2[?] [thickness]: thickness of the lines drawn for axes.\n// input3[?] [r]: radius of the filled circle that will be drawn at the origin (0,0)\n// output: black or white boolean value representing if current fragment is a part of axes drawing\nfloat drawAxis(vec2 uv, float thickness, float r) {\n    float v = 0.0;\n    if (uv.x >= 0.0 - thickness && uv.x <= 0.0 + thickness || uv.y >= 0.0 - thickness && uv.y <= 0.0 + thickness) {\n        v = 1.0;\n    }\n    v = mix(v, 1.0, step(sdfCircle(vec2(0.0, 0.0), r, uv), r)); // (0,0) white\n    return v;\n}\n// function overload with default values for optional parameters\nfloat drawAxis(vec2 uv) {\n    return drawAxis(uv, 0.005, 0.0);\n}\n//____________________________________________________________________________________________","name":"Common","description":"","type":"common"}]}