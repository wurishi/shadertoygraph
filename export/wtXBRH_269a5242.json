{"ver":"0.1","info":{"id":"wtXBRH","date":"1595971048","viewed":1539,"name":"Living on Surface of 4D Sphere","username":"Gijs","description":"Move camera with 'wasd+space+shift+qe+mouse'. If the universe where to be spherical this would be what one would experience when traveling/seeing VERY far.","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["3d","sphere","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// First Oddity:\n// Walk forward long enough\n// you will end up back where you started!\n\n// Second Oddity\n// Try to walk a small sqaure over the orthonogal axis\n// you can't; they actually form a triangle!?\n\n// Third Oddity\n// Walk any loop\n// You camera will be panned/rolled/pitched even though you didn't!\n\n// Fourth Oddity\n// Diverging rays from the camera convergence again at your own antipodal point\n// This means that things perfectly accros the universe appear as if they where closeby\n\n// The shading is totally fake and hacked together, \n// it has nothing to do with how light actually works in S^3\n\n// S^3 is defined as all the points in R^4 with unit length.\n\n// for two points 'x,y' in 'S^3' their distance is the angle between their respective vectors:\n// d(x,y) := arccos( dot(x,y) )\n\n// a ray 'p(t)' starting at 'o' going towards to 'd', where (o,d) = 0, is:\n// p(t) = cos(t)*o + sin(t)*d,\n\n//constants\nconst float PI = 3.1415;\n\n//some shading parameters\nconst float FOG_DISTANCE = PI*2.;\nconst vec3  FOG_COLOR    = vec3(0.5,0.6,0.7);\nconst vec3  LIGHT_COLOR  = vec3(1.,.7,.1);\nconst vec4  LIGHT_VECTOR = normalize(vec4(1,1,1,1));\n\n// their are six ''axis''\n// red, green, blue, yellow, magenta, yellow\nconst vec3 axisColors[6] = vec3[6](\n\tvec3(1,0,0),\n    vec3(0,1,0),\n    vec3(0,0,1),\n    vec3(1,1,0),\n    vec3(0,1,1),\n    vec3(1,0,1)\n);\n\n// their are eight ''poles''\n// red, green, blue, yellow, dark red, dark green, dark blue, dark yellow\n// the dark variant is the antipodal point of the normal variant\nconst vec3 poleColors[8] = vec3[8](\n    vec3(1,0,0),\n    vec3(0,1,0),\n    vec3(0,0,1),\n    vec3(1,1,0),\n    vec3(.5,0,0),\n    vec3(0,.5,0),\n    vec3(0,0,.5),\n    vec3(.5,.5,0)\n);\n\n\n// solves a*cos(x) + b*sin(x) = c\n// define\n// R^2 = a^2 + b^2\n// A := a/R, B := b/R, C := c/R\n// rewrite\n// A*cos(x) + B*sin(x) = C\n// now (A,B) is on the unit circle so there exists an angle alpha s.t.\n// sin(alpha) = A, cos(alpha) = B\n// so alpha = atan(A, B)\n// filling in\n// sin(alpha)*cos(x) + cos(alpha)*sin(x) = C\n// applying sum identity\n// sin(alpha+x) = C\n// we see that it is unsolvable if |C| > 1, or in other words if c^2 > a^2 + b^2\n// otherwise\n// x = asin(C) - alpha AND x = pi - asin(C) - alpha\nfloat solveThing(float a, float b, float c){\n    float R = sqrt(a*a + b*b);\n    float alpha = atan(a, b);\n    float x = asin(c/R) - alpha;\n    x = mod(x, 2.*PI);\n    return x;\n}\n\n// stores information of a hit\nstruct hit{\n    float t; //hit t\n    vec4  p; //hit pos\n    vec4  n; //hit \"normal\" for the shading\n};\n\n// ball intersections can be done analytically\n// this function solves the system\n// d(p(t), b) = r\n// where 'b' is the position of the ball and 'r' its radius,\n// this all reduces to solving:\n// cos(t)dot(o,b) + sin(t)dot(d,b) = cos(r)\n// which can be done analytically as seen above\nhit ball(vec4 o, vec4 d, vec4 b, float r){\n    \n    float t = solveThing(dot(o,b), dot(d,b), cos(r));\n\n    //hit pos\n    vec4 p = o*cos(t)+d*sin(t);\n    \n    return hit(t, p, normalize(p-b));\n}\n\n\n\n// let a,b in S^3\n// L = { x in S^3 such that x is the span of a and b}\n// d(p(t), L) = r\n// the above equation expands to\n// cos^2(t)dot(ot,ot) + 2*cos(t)*sin(t)*dot(ot,dt) + sin^2(t)*dot(dt,dt) = cos^2(r)\n// where ot = (dot(o, a), dot(o, b))\n// where dt = (dot(d, a), dot(d, b))\n// luckily these are all double frequency formulations so can be reduced to an equation\n// that is like solveThing\nhit axis(vec4 _o, vec4 _d, vec4 a, vec4 b, float r){\n    //reduce to 2d\n    vec2 o = vec2(dot(_o,a),dot(_o,b));\n    vec2 d = vec2(dot(_d,a),dot(_d,b));\n    float cr = cos(r);\n    float cr2 = cr*cr;\n    \n    //some variables\n    float A = dot(o, o);\n    float B = dot(o, d);\n    float C = dot(d, d);\n    float E = cr2;\n\n    //solve, the returned thing is 2 times t\n    float t = solveThing(A-C, 2.*B, 2.*E - A - C);\n    //so half it\n    t *= .5;\n      \n\t//hitpos\n    vec4 p = _o*cos(t)+_d*sin(t);\n    \n    //closest pos on the axis\n    vec4 k = dot(p,a)*a + dot(p,b)*b;\n    k = normalize(k);\n    \n    return hit(t, p, normalize(p-k));\n} \n\n\nhit scene(vec4 o, vec4 d, inout vec3 col){\n    // initialize hit\n    hit h = hit(1e20, vec4(0), vec4(0));\n    \n    // balls\n    for(int i=0; i<4; i++){\n        vec4 b = vec4(0);\n        b[i] = 1.;\n        hit nh = ball(o, d, b, 0.1);\n        if(nh.t<h.t){\n            h = nh;\n            col = poleColors[i];\n        }\n    }\n    \n    // antipodal balls\n    for(int i=0; i<4; i++){\n        vec4 b = vec4(0);\n        b[i] = -1.;\n        hit nh = ball(o, d, b, 0.1);\n        if(nh.t<h.t){\n            h = nh;\n            col = poleColors[i+4];\n        }\n    }\n    \n    // \"axis\"\n    int c = 0;\n    for(int i=0; i<4; i++){\n    \tfor(int j=i+1; j<4; j++){\n            vec4 a = vec4(0);\n            vec4 b = vec4(0);\n            a[i] = 1.;\n            b[j] = 1.;\n            hit nh = axis(o, d, a, b, 0.05);\n            if(nh.t<h.t){\n                h = nh;\n                col = axisColors[c];                \n            }\n            c++;\n        }\n    }\n    \n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y*1.;\n    \n    // get camera\n    vec4 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0);\n  \tvec4 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0);\n    vec4 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0);\n    vec4 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0);\n    \n    // create ray\n    vec4 ori = cameraPosition;\n    vec4 dir = normalize(cameraForward+p.x*cameraRight+p.y*cameraUpward);\n    \n    // enforce that it is orthonormal\n    GramSchmidt42(ori,dir);\n    \n    // initialize color\n    vec3 col = vec3(0);\n    \n    // acquire hit with scene\n    hit h = scene(ori, dir, col);\n\n    // diffuse\n    float d = max(dot(LIGHT_VECTOR, h.n),0.);\n    col *= (.25 + d*.75);\n    \n    // fog\n    float m = max(dot(dir, LIGHT_VECTOR),0.)*.5;\n    vec3 skyColor = FOG_COLOR + m*LIGHT_COLOR;\n    col = mix(col, skyColor, smoothstep(0., FOG_DISTANCE, h.t));\n    \n    // gamma correction\n    col = pow(col,vec3(1./2.2)); \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This buffer handles the Camera\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x>4 || p.y > 0) return;\n    \n    vec4 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0);\n  \tvec4 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0);\n    vec4 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0);\n    vec4 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0);\n    vec4 mouseOld       = texelFetch(iChannel0,ivec2(4,0),0);\n    \n    if(iFrame==0){\n        cameraPosition = vec4( .1, .1,  .1, 1);\n        cameraForward  = vec4( 0, 0,  1, 0);\n    \tcameraRight    = vec4( 1, 0,  0, 0);\n    \tcameraUpward   = vec4( 0, 1,  0, 0);\n        mouseOld       = vec4(iMouse.xy, 0, 0);\n        \n        //enforce that it is orthonormal\n    \tGramSchmidt44(cameraPosition, cameraForward, cameraRight, cameraUpward);\n    } \t\n    \n    bool forward     = texelFetch(iChannel1,ivec2(87,0),0).x + texelFetch(iChannel1,ivec2(38,0),0).x >0.;\n    bool left        = texelFetch(iChannel1,ivec2(65,0),0).x + texelFetch(iChannel1,ivec2(37,0),0).x >0.;\n    bool backward    = texelFetch(iChannel1,ivec2(83,0),0).x + texelFetch(iChannel1,ivec2(40,0),0).x >0.;\n    bool right       = texelFetch(iChannel1,ivec2(68,0),0).x + texelFetch(iChannel1,ivec2(39,0),0).x >0.;\n    bool rollleft    = texelFetch(iChannel1,ivec2(81,0),0).x > 0.;\n    bool rollright   = texelFetch(iChannel1,ivec2(69,0),0).x > 0.;\n    bool down        = texelFetch(iChannel1,ivec2(16,0),0).x + texelFetch(iChannel1,ivec2(34,0),0).x > 0.;\n    bool up          = texelFetch(iChannel1,ivec2(32,0),0).x + texelFetch(iChannel1,ivec2(33,0),0).x > 0.;\n    bool mouseLeft   = iMouse.z>0.;\n    bool interaction = forward||left||backward||right||rollleft||rollright||down||up||mouseLeft;\n    \n    float stepSize = iTimeDelta;\n    \n    //Translation\n    cameraPosition += (cameraForward*(float(forward) - float(backward)) +\n        \t\t       cameraRight  *(float(right)   - float(left)    ) +\n        \t           cameraUpward *(float(up)      - float(down)    )\n                      )*stepSize;\n    \n    //Roll\n    float r = (float(rollleft)-float(rollright))*iTimeDelta;\n    rotate(cameraRight, cameraUpward , r);\n    \n    //Pitch & Yaw\n    if(mouseLeft){\n        if(mouseOld.z==0.){\n            mouseOld.xy = iMouse.xy;\n            mouseOld.z = 1.;\n        }\n\t\tvec2 s = iMouse.xy-mouseOld.xy;\n        rotate(cameraForward, cameraUpward, s.y*0.01);\n        rotate(cameraForward, cameraRight , s.x*0.01);\n    }else{\n    \tmouseOld.z = 0.;   \n    }\n    \n    //Make sure this triple is orthonormal\n    GramSchmidt44(cameraPosition, cameraForward, cameraUpward, cameraRight);\n    \n    if(p.x==0){\n    \tfragColor = cameraPosition;\n    }else if(p.x==1){\n        fragColor = cameraForward;\n    }else if(p.x==2){\n        fragColor = cameraRight;\n    }else if(p.x==3){\n        fragColor = cameraUpward;\n    }else if(p.x==4){\n        fragColor = vec4(iMouse.xy, mouseOld.z, 0);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"void GramSchmidt42(inout vec4 a, inout vec4 b){\n    a = normalize(a);\n    b = b - dot(b,a)*a;\n    b = normalize(b);\n}\n\n\nvoid GramSchmidt44(inout vec4 a, inout vec4 b, inout vec4 c, inout vec4 d){\n    a = normalize(a);\n    b = b - dot(b,a)*a;\n    b = normalize(b);\n    c = c - dot(c,a)*a - dot(c,b)*b;\n    c = normalize(c);\n    d = d - dot(d,a)*a - dot(d,b)*b - dot(d,c)*c;\n    d = normalize(d);\n}\n\n\n//rotates a towards b\n//maintains angle between them\n//if angle=90 degrees than a becomes b and b becomes -a\nvoid rotate(inout vec4 a, inout vec4 b, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    vec4 na =  c*a + s*b;\n    vec4 nb = -s*a + c*b;\n    a = na;\n    b = nb;\n}","name":"Common","description":"","type":"common"}]}