{"ver":"0.1","info":{"id":"md3cWX","date":"1695565182","viewed":73,"name":"space warping black hole (2)","username":"Borusse29","description":"improvement on https://www.shadertoy.com/view/DdcyWj\nreference: https://kelvinvanhoorn.com/2021/04/20/supermassive-black-hole-tutorial/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blackhole","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define stepsize 0.01\n#define maxsteps 1000\n#define focalDist 0.5\n\nfloat disk(vec3 ro, vec3 rd, vec3 center, float r0, float r1, vec3 normal) {\n    float t = dot(center - ro, normal) / dot(rd, normal);\n    vec3 p = ro + t * rd;\n    if (abs(t) < stepsize && distance(center, p) <= r1 && r0 <= distance(center, p)) \n        return -2.0 * (length(p.xyz - center.xyz) - r0) / r1 + 1.0;\n    return 0.0;\n}\n\nvec3 bgColor(vec3 d) {\n    return 0.5 * clamp(vec3(d.zz, d.z + 0.1), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n\n    vec3 col = vec3(0.0);\n    \n    vec3 camPos = vec3(-2.5, 0.0, 0.0);\n    vec3 center = vec3(0.0);\n    float gConst = 0.75 * (0.4 * cos(0.75 * iTime + 0.5) + 0.55);\n    \n    float schwarzschildRadius = 2.0 * 0.361 * gConst;\n    \n    float diskRadiusInner = 1.6 * schwarzschildRadius;\n    float diskRadiusOuter = 5.0 * schwarzschildRadius;\n    \n    //vec3 diskNormal = normalize(vec3(-0.2, 0.5, 1.0)); // static orientation\n    vec3 diskNormal = normalize(vec3(-0.2 * cos(1.25 * iTime + 0.8), 0.5 * sin(1.25 * iTime + 0.8), 1.0)); // make it spin!\n\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(focalDist, uv));\n    \n    bool collision = false;\n    \n    for (int i = 0; i < maxsteps; i++) {\n        float d = disk(ro, rd, center, diskRadiusInner, diskRadiusOuter, diskNormal);\n        if (d > 0.0) { \n            col += d * vec3(0.85, 0.45, 0.1);\n        }\n        float distToCenter = distance(center, ro);\n        if (distToCenter < schwarzschildRadius){\n            collision = true;\n            break;\n        }\n        \n        ro += stepsize * rd;\n        rd = normalize(rd + (center - ro) * stepsize * gConst / (distToCenter * distToCenter));\n        \n        // performance optimization\n        if (dot(rd, center - ro) < -0.9 && distance(center, ro) > 2.5) {\n            break;\n        }\n    }\n    \n    if (!collision)\n        col += bgColor(rd);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}