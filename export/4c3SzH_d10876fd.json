{"ver":"0.1","info":{"id":"4c3SzH","date":"1724957902","viewed":42,"name":"4 cylinder engine sound","username":"peremoya2000","description":"Simple synthesis of the sound of a four cylinder engine","likes":1,"published":1,"flags":8,"usePreview":0,"tags":["sound","audio","car","engine","inline4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 randColor = 0.5 + 0.5*cos(1.57*iTime+uv.xyx+vec3(0,2,4));\n\n    float rpmState = (.5+.5*sin(iTime*.5-PI*.5));\n    \n    vec3 rpmColor = mix(vec3(0.05,.4,.6), vec3(1.,.2,.1), rpmState);\n    vec3 finalColor = mix(rpmColor, randColor, mix(.2,.05, rpmState));\n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//RPS means Revolutions Per Second (Hz)\n#define BASE_RPS 1100./60.\n#define TOP_RPS 8000./60.\n\nfloat getAmplitudeForHarmonic(float partial, float rpm)\n{\n    //Initial guess based on proximity to H2, curve is a mix of 1/x & 1-x.\n    float amplitude = min(1., .25/(abs(2.-partial))) + (.75-abs(.25-partial/8.));\n    amplitude *=.5;    \n    \n    //Amplify Primary Harmonics specially at low RPM & Secondary Harmonics at high RPM.\n    if(partial > 1. && mod(partial, 2.) == 0.)\n    {\n        amplitude *= mix(1.15,1.05,rpm);\n    }\n    else\n    {\n        amplitude *= mix(.9,1.05,rpm); \n    }\n    \n    //Louder at high RPM\n    return amplitude*(rpm*.5+.75);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    time = mod(time, TAU*4.);\n    \n    float signal = 0.;\n    float rpmState = (.5+.5*sin(time*.5-PI*.5));\n    for (float i = 0.5; i <= 8.; i+=.5)\n    {\n        //original frequency variation is (0.5+0.5*sin(time/2-PI/2))*(upperBound-lowerBound)+lowerBound\n        //integrates to 0.5*lowerBound*time + 0.5*upperBound*time + (lowerBound - upperBound)*sin(.5*time)\n        float lowerBound = BASE_RPS * 2. * i;\n        float upperBound = TOP_RPS * 2. * i;\n        float phase = TAU * (.5*lowerBound*time+.5*upperBound*time+(lowerBound-upperBound)*sin(time*.5));\n        float amplitude = getAmplitudeForHarmonic(i, rpmState);\n\n        signal += sin(phase)*amplitude;\n    }\n    \n    return vec2(signal);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530718\n#define PI 3.14159265359","name":"Common","description":"","type":"common"}]}