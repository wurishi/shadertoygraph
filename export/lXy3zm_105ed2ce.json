{"ver":"0.1","info":{"id":"lXy3zm","date":"1717429063","viewed":83,"name":"Forest Prism","username":"thedarkbunny","description":"Playing with cubemaps as input to lighting calculations.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cubemap","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.\n#define MAX_DIST 100.\n#define EPSILON .0001\n\n#define TWO_PI 6.28319\n\n\n#define CYCLE_TIME 30.\n\n//vertical fov constant FVC = 1 / tan( vertical_fov_in_radians / 2 )\n//conveniently, that's 1.0 for a 90-degree FOV.\n#define FVC 1.\n\nfloat sdRoundCube( vec3 p, float s, float r )\n{\n  vec3 q = abs(p) - vec3(s,s,s) + r; \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 sdScene( in vec3 p){\n    return vec2(sdRoundCube(p,0.5,0.05),1.);\n}\n\t\nvec2 toSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = sdScene(eye + depth * marchingDirection);\n        if (dist.x < EPSILON) {\n\t\t\treturn vec2(depth,dist.y);\n        }\n        depth += dist.x;\n        if (depth >= end) {\n            return vec2(end,0.);\n        }\n    }\n    return vec2(end,0.);\n}\n\n//assumes poaition normalized as -1 <= Y <= 1\n//with aspect ratio preserved.\nvec3 rayDirection(vec2 pos) {\n    return normalize(vec3(pos, -FVC));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        ( sdScene(vec3(p.x + EPSILON, p.y, p.z)) - sdScene(vec3(p.x - EPSILON, p.y, p.z)) ).x ,\n        ( sdScene(vec3(p.x, p.y + EPSILON, p.z)) - sdScene(vec3(p.x, p.y - EPSILON, p.z)) ).x ,\n        ( sdScene(vec3(p.x, p.y, p.z  + EPSILON)) - sdScene(vec3(p.x, p.y, p.z - EPSILON) ).x )\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongPerLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 n, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, n));\n    \n    float dotLN = dot(L, n);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    vec3 n = estimateNormal(p);\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    \n    vec3 lightPos = vec3(0.0, 3.0, -0.5);\n    vec3 lightIntensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongPerLight(k_d, k_s, alpha, p, n, eye,\n                                  lightPos,\n                                  lightIntensity);\n    \n    lightPos = vec3(sin(2. * iTime),\n                    0.5 * sin(0.37 * iTime)+ 1.5,\n                    2.0);\n    lightIntensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongPerLight(k_d, k_s, alpha, p, n, eye,\n                                  lightPos,\n                                  lightIntensity);\n    /*\n    float cycle_pos = iTime*float(NODES)/CYCLE_TIME;\n    int cycle_step = int(cycle_pos+float(NODES-1))%NODES;\n    float cycle_frac = smoothstep(0.,1.,fract(cycle_pos));\n    if(cycle_step%6 < 3){\n        lightPos = mix(pos_a[cycle_step],pos_a[cycle_step+1],cycle_frac) + vec3(0.,-0.025,0.);\n        lightIntensity = vec3(0.1, 0.5, 0.9);\n\n        color += phongPerLight(k_d, k_s, alpha, p, eye,\n                                      lightPos,\n                                      lightIntensity);\n    }\n    */\n    \n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 U ) {\n    vec2 uv = (U - iResolution.xy/2.)/min(iResolution.x,iResolution.y);\n    float cyclePoint = iTime/CYCLE_TIME*TWO_PI;\n    float cpVert = sin(cyclePoint)*0.8026475;\n    \n    float xzMult = cos(cpVert);\n    float cycleXZ = cyclePoint*3.;\n    float cd = 2.;\n    \n    vec3 viewDir = rayDirection(uv);\n    vec3 eye = vec3(cd*xzMult*sin(cycleXZ), cd*sin(cpVert), cd*xzMult*cos(cycleXZ));\n    mat4 viewToWorld = viewMatrix(eye, vec3(0., 0., 0.), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    vec2 dist = toSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist.x > MAX_DIST - EPSILON) {\n        fragColor = vec4(texture(iChannel0,vec3(uv,-1.)).rgb/5., 0.);\n\t\treturn;\n    }\n    \n    \n    \n    vec3 p = eye + dist.x * worldDir;\n    //default color\n    vec3 K_a = vec3(0., 0., 0.);\n    vec3 K_d = vec3(0., 0., 0.);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n\n    \n    //Overrides for materials.\n    if(dist.y == 1.){\n        //vec3 rf = refract(worldDir,normalize(p),1.);\n        //K_a = texture(iChannel0,rf).rgb;\n        //K_d = texture(iChannel0,rf).rgb;\n        K_a = texture(iChannel0,p+worldDir).rgb;\n        K_d = texture(iChannel0,p+worldDir).rgb;\n    }\n    \n    \n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n\n\n}\n\n\n//And yet, somehow, it doesn't do squat for the halo on the underside.\n\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .005 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n","name":"Image","description":"","type":"image"}]}