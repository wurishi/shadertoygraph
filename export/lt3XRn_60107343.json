{"ver":"0.1","info":{"id":"lt3XRn","date":"1477665638","viewed":215,"name":"Generalized Mandelbrot Set","username":"Patapom","description":"A variation on modulo multiplications showing similarity with the amount of lobes of the generalized Mandelbrot set.\nYet again inspired by the same Mathologer episode: https://www.youtube.com/watch?v=qhbuKbxJsk8","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","modulo","generalized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shows the multiplication table modulo 200 represented as lines connecting points\n//\ton the unit circle, as explained in the Mathologer video https://www.youtube.com/watch?v=qhbuKbxJsk8\n//\n// In the background is the generalized Mandelbrot set with an arbitrary power that shows the connection\n//\tof the shapes obtained with the \"modulo multiplication\" and the amount of lobes in the Mandelbrot set.\n//  (this was also suggested by the same Mathologer video)\n//\nconst float\tTWOPI = 6.283185307179586476925286766559;\n\n// You can remove this line for the \"regular\" multiplication but this mirroring\n//  makes the fitting to the Mandelbrot lobes better...\n#define MIRROR\n\n// Comment this to obtain the regular Mandelbrot set, otherwise coordinates outside the unit circle are reciprocated inside (love it!)\n#define RECIPROCAL_MANDELBROT\n\nconst float\tMAX_LOBES = 10.0;\t// Maximum amount of Mandelbrot lobes\nconst float\tMODULO = 200.0;\t\t// Amount of subdivisions of the circle\n\n// Computes the generalized mandelbrot set Zn+1 = Zn^p + C with an arbitrary p\n// We can notice that p is directly driving Z's argument, hence the apparent multiple rotations of the set's main lobes\n//\nvec3 ComputeMandelbrot( vec2 _uv, float _mul ) {\n    float\tstepsCount = 0.0;\n    vec2\tz = vec2( 0.0 );\n    for ( float i=0.0; i < 64.0; i++ ) {\n        z += _uv;\n        \n        float\tf = pow( dot( z, z ), 0.5 * _mul );\n        float\ta = _mul * atan( z.y, z.x );\n        z = f * vec2( cos( a ), sin( a ) );\n        if ( dot( z, z ) > 10.0 )\n            break;\n        stepsCount++;\n    }\n    return vec3( stepsCount / 64.0 );\n}\n\nvec3 ComputeInnerColor( vec2 _uv, float _mul ) {\n\n    float\tisOnLine = 0.0;\n    \n\tvec2\tscStart, scEnd;\n    \n    #ifdef MIRROR\n\t\t_uv.y = abs( _uv.y );\t// Better matching\n    #endif\n    \n\t// Compute start and end anglse based on multiplier\n\tfloat\tdStartAngle = TWOPI / MODULO;\n\tfloat\tdEndAngle = _mul * dStartAngle;\n    float\toffset = -0.5 * TWOPI / (_mul - 1.0);\t// This angular offset is used to make troughs co√Øncide with the Mandelbrot set\n\tfloat\tstartAngle = dStartAngle + offset;\n\tfloat\tendAngle = dEndAngle + offset;\n\n    for ( float i=1.0; i < MODULO; i++ ) {\n        // Compute start and end position on the unit circle, forming a line\n        scStart.y = sin( startAngle );\n        scStart.x = cos( startAngle );\n        scEnd.y = sin( endAngle );\n        scEnd.x = cos( endAngle );\n        \n        // Compute line normal\n        vec2\tnormal = normalize( vec2( scEnd.y - scStart.y, scStart.x - scEnd.x ) );\n        \n        // Compute distance to line\n        vec2\tdelta = _uv - scStart;\n        float\torthoDistance = abs( dot( delta, normal ) );\n        \n        // Check if the current position is on the line or not\n        isOnLine += smoothstep( 0.005, 0.0, orthoDistance );\n        \n        startAngle += dStartAngle;\n        endAngle += dEndAngle;\n    }\n\n    return vec3( 1.0 - clamp( isOnLine, 0.0, 1.0 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2\tR = iResolution.xy;\n    vec2\tuv = ( 2. * fragCoord - R ) / R.y;\n    \nuv *= 1.5 + 0.5 * sin( iTime );\t// Fun with flags\n    \n\tfloat\tmul = 1.0 + 0.5 * MAX_LOBES * (1.0 - cos( 0.2 * iTime ));\n    \n    float\tradius = length( uv );\n\tfloat\tD = mix( 1.0, 1.0 / (radius*radius), smoothstep( 0.95, 1.05, radius ) );\n    #ifdef RECIPROCAL_MANDELBROT\n\t\tvec3\tC = 0.5 * (ComputeInnerColor( D*uv, mul ) + ComputeMandelbrot( D*uv, mul ));\n    #else\n\t\tvec3\tC = 0.5 * (ComputeInnerColor( D*uv, mul ) + ComputeMandelbrot( uv, mul ));\n    #endif\n\tfragColor = vec4( C, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}