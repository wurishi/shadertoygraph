{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const float fieldOfView = 60.0f; // The length of the arc of the longest field of view in degrees\nconst vec3 originStart = vec3(0.0f, 0.0f, 0.0f); // Where the camera origin starts\nconst vec3 angleStartRaw = vec3(1.0f, -0.5f, 0.25f); // What angle the camera begins at\nconst float cameraDist = 35.0f;\n\nvec3 spheroidOrigin = vec3(0.0f, 0.0f, 0.0f);\nvec3 spheroidDistortion = vec3 (4.0f, 1.0f, 4.0f);\nfloat spheroidRadius = 2.5f;\nvec3 spheroidOrigin2 = vec3(0.0f, 0.0f, 0.0f);\nvec3 spheroidDistortion2 = vec3 (1.0f, 0.75f, 1.0f);\nfloat spheroidRadius2 = 9.0f;\nvec3 sphereOrigin = vec3(0.0f, 0.0f, 0.0f);\nfloat sphereRadius = 3.5f;\nvec3 sphereOrigin2 = vec3(0.0f, 0.0f, 0.0f);\nfloat sphereRadius2 = 2.5f;\nvec3 cubeOrigin = vec3(0.0f, 0.0f, 0.0f);\nvec3 groundOrigin = vec3(0.0f, -1005.0f, 0.00f);\nfloat cubeWidth = 3.0f;\nfloat groundWidth = 1000.0f;\n\nvec3 ringColor = vec3(0.3f, 0.3f, 0.4f);\nvec3 sphere2Color = vec3(1.0f, 0.65f, 0.7f);\nvec3 boxColor = vec3(0.39f, 0.8f, 1.0f);\nvec3 groundColor = vec3(1.0f,1.0f,1.0f);\n\nint freeSteps = 20; //steps you can take without loss of brightness\nfloat minBrightness = 0.01f;\nvec3 lightRayDir = vec3(-0.35f, 1.0f, 1.3f);\nconst float startLength = 0.1f; // How far from the origin the rays start from\nconst float degToRad = 0.0174533f;\nconst int maxSteps = 1000;\nconst float minDist = 0.0001f;\nconst float maxDist = 1000.0f;\nconst float brightnessStep = 0.01f;\nfloat longFirstRay;\nint lastFrameUpdate = -1;\nvec3 firstPerp;\nvec3 secondPerp;\nvec3 angleStart;\nvec3 origin;\n\nfloat distToScene(vec3 pos);\n\nvec3 posYperp(vec3 source);\nfloat cubeDist(vec3 p, vec3 o, float w);\nfloat sphereDist(vec3 p, vec3 o, float r);\nfloat spheroidDist(vec3 p, vec3 o, vec3 d, float r);\nfloat vectorMagnitude(vec3 v);\nvec3 standardizeVector(vec3 init);\nvec3 zeroYperp(vec3 source);\nvoid frameSetup();\nfloat reverse(float s);\nfloat alter(float s, float x);\nfloat calculate(float a, float r, float s, float x);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (lastFrameUpdate != iFrame) {\n        lastFrameUpdate = iFrame;\n        frameSetup();\n    }\n    vec2 uv;\n    uv.x = fragCoord.x/iResolution.x-0.5f;\n    uv.y = fragCoord.y/iResolution.x-((iResolution.y/iResolution.x)/2.0f);\n    vec2 rotation = vec2(uv.x*sin(fieldOfView*degToRad), uv.y*sin(fieldOfView*degToRad));\n    vec3 rayVector = standardizeVector(vec3(angleStart.x+(firstPerp.x*rotation.x)+(secondPerp.x*rotation.y), angleStart.y+(firstPerp.y*rotation.x)+(secondPerp.y*rotation.y), angleStart.z+(firstPerp.z*rotation.x)+(secondPerp.z*rotation.y)));\n    vec3 position = origin + rayVector*startLength;\n    float dist;\n    int steps=0;\n    do {\n        dist = distToScene(position);\n        position = position + (rayVector * dist);\n        steps=steps+1;\n    } while((dist>minDist)&&(steps<=maxSteps)&&(dist<maxDist));\n    if(steps>=maxSteps) {\n        fragColor = vec4(abs(rayVector.x), abs(rayVector.y), abs(rayVector.z), 1.0f);\n    }\n    else {\n        if(dist<=minDist) {\n            vec3 color = vec3(0.0f, 1.0f, 0.0f);\n            // ground color\n            if (cubeDist(position, groundOrigin, groundWidth) <= minDist) color = groundColor;\n            // ring color\n            if (spheroidDist(position, spheroidOrigin, spheroidDistortion, spheroidRadius) <= minDist) color = ringColor;\n            // cube color\n            if (cubeDist(position, cubeOrigin, cubeWidth) <= minDist) color = boxColor;\n            // inner ball color\n            if (sphereDist(position, sphereOrigin2, sphereRadius2) <= minDist) color = sphere2Color;\n            steps = 0;\n            float smallRay = 100000.0f;\n            vec3 lightVector = standardizeVector(lightRayDir);\n            dist = minDist*5.0f;\n            position = position + (lightVector * dist);\n            dist = distToScene(position);\n            if (dist >= longFirstRay) longFirstRay = dist;\n            do {\n                if (abs(dist) < smallRay) smallRay = abs(dist);\n                position = position + (lightVector * dist);\n                steps=steps+1;\n                dist = distToScene(position);\n            } while((dist>minDist/2.0f)&&(steps<=maxSteps)&&(dist<maxDist));\n            float b;\n            if ((steps>=maxSteps)||(dist>=maxDist)) {\n                steps = steps - freeSteps;\n                b = 1.0f - (brightnessStep * float(steps));\n                if (dist>=maxDist) {\n                    b = b + (brightnessStep * ((dist - maxDist) / maxDist));\n                }\n                if (b <= minBrightness) b = minBrightness;\n                fragColor = vec4(color*b, 1.0f);\n            }\n            else {\n                steps = steps - freeSteps;\n                b = float(steps)*(brightnessStep/10.0f);\n                if (b >= minBrightness) b = minBrightness;\n                fragColor = vec4(color*b, 1.0f);\n            }\n        }\n        else {\n            fragColor = vec4(0.5f,0.65f,0.9f,1.0f);\n        }\n    }\n}\n\nvec3 standardizeVector(vec3 init) {\n    float mag = sqrt((init.x*init.x)+(init.y*init.y)+(init.z*init.z));\n    float ratio = 1.0f/mag;\n    return vec3(init.x*ratio, init.y*ratio, init.z*ratio);\n}\n\n\nvec3 zeroYperp(vec3 source) {\n    if ((source.x == 0.0f) && (source.z == 0.0f)) return vec3(1.0f, 0.0f, 0.0f);\n    if (source.z == 0.0f) {\n        if(source.x > 0.0f) return vec3(0.0f, 0.0f, 1.0f);\n        else return vec3(0.0f, 0.0f, -1.0f);\n    }\n    if (source.x == 0.0f) {\n        if(source.z > 0.0f) return vec3(-1.0f, 0.0f, 0.0f);\n        else return vec3(1.0f, 0.0f, 0.0f);\n    }\n    //if (abs(source.x*source.z)==(source.x * source.z)) {\n        return vec3(source.z*-1.0f, 0.0f, source.x);\n    //}\n    //else {\n    //    return vec3(source.z, 0.0f, source.x*-1.0f);\n    //}\n}\n\nvec3 posYperp(vec3 source) {\n    if(source.y == 0.0f) return vec3(0.0f, 1.0f, 0.0f);\n    float targetDot = source.y * -1.0f;\n    float divisor = (source.x * source.x) + (source.z * source.z);\n    if (divisor == 0.0f) return vec3(0.0f, 0.0f, 1.0f);\n    float ratio = targetDot/divisor;\n    return vec3(source.x*ratio, 1.0f, source.z*ratio);\n}\n\nfloat reverse(float s) {\n    return (s*-1.0f);\n}\n\nfloat alter(float s, float x) {\n    return (s+x);\n}\n\nfloat calculate(float a, float r, float s, float x) {\n    return ((((a*alter(a, x)) + (r*reverse(a)))*-1.0f)/s);\n}\n\n\nfloat distToScene(vec3 pos) {\n    float distToSphere = vectorMagnitude(sphereOrigin - pos) - sphereRadius;\n    float distToSphere2 = vectorMagnitude(sphereOrigin2-pos) - sphereRadius2;\n    float distToBox = cubeDist(pos, cubeOrigin, cubeWidth);\n    float distToComplexShape = max(distToBox, distToSphere*-1.0f);\n    float distToSphrd = spheroidDist(pos, spheroidOrigin, spheroidDistortion, spheroidRadius);\n    float distToSphrd2 = spheroidDist(pos, spheroidOrigin2, spheroidDistortion2, spheroidRadius2);\n    float distToRing = max(distToSphrd, distToSphrd2*-1.0f);\n    float distToGround = cubeDist(pos, groundOrigin, groundWidth);\n    return(min(distToRing, min(distToGround, min(distToComplexShape, distToSphere2))));\n}\n\nfloat cubeDist(vec3 p, vec3 o, float w) {\n    vec3 dif = o - p;\n    vec3 absDif = vec3(abs(dif.x) - w, abs(dif.y) - w, abs(dif.z) - w);\n    if (absDif.x <= 0.0f) absDif.x = 0.0f;\n    if (absDif.y <= 0.0f) absDif.y = 0.0f;\n    if (absDif.z <= 0.0f) absDif.z = 0.0f;\n    return vectorMagnitude(absDif);\n}\n\nfloat sphereDist(vec3 p, vec3 o, float r) {\n    return (vectorMagnitude(o - p) - r);\n}\n\nfloat spheroidDist(vec3 p, vec3 o, vec3 d, float r) {\n    /*vec3 dif = o - p;\n    vec3 absDif = vec3(abs(dif.x), abs(dif.y), abs(dif.z));\n    vec3 radius = standardizeVector(absDif)*r;\n    vec3 distRad = vec3(radius.x*d.x, radius.y*d.y, radius.z*d.z);\n    vec3 finDif = absDif-distRad;\n    float result = vectorMagnitude(finDif);\n    if((finDif.x<=0.0f)&&(finDif.y<=0.0f)&&(finDif.z<=0.0f)) result = result * -1.0f;\n    return(result);*/\n    vec3 dis = o - p;\n    vec3 rad = d * r;\n    float k0 = length(dis/rad);\n    float k1 = length(dis/(rad*rad));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat vectorMagnitude(vec3 v) {\n    return sqrt((v.x*v.x) + (v.y*v.y) + (v.z*v.z));\n}\n\nvoid frameSetup() {\n    longFirstRay=0.0f;\n    origin = standardizeVector(vec3(sin(iTime*0.25f), 0.7f, cos(iTime*0.25f)))*cameraDist;\n    if(mod(((iTime)*0.25), 12.5663706144f)>6.283185307179586f) {\n        lightRayDir = standardizeVector(vec3(sin((iTime+2.0f)*0.25f), 0.9f, cos((iTime+2.0f)*0.25f)));\n    }\n    else {\n        lightRayDir = standardizeVector(vec3(sin(0.5f), 0.9f, cos(0.5f)));\n    }\n    angleStart = standardizeVector(vec3(0.0f, 0.0f, 0.0f) - origin);\n    firstPerp = standardizeVector(zeroYperp(angleStart));\n    secondPerp = standardizeVector(posYperp(angleStart));\n    // object updates\n    vec3 sphodPos = vec3 (sin(iTime*0.9f)*1.5f, 2.0f*sin(iTime)+2.0f, sin(iTime*0.96666f)*1.5f);\n    spheroidOrigin = sphodPos;\n    spheroidOrigin2 = sphodPos;\n    float cycle = sin(iTime*1.1415926f);\n    if (cycle < 0.0f) cycle = 0.0f;\n    sphereOrigin2 = vec3(0.0f, cycle*cycle*8.0f, 0.0f);\n    sphereRadius = 3.5f+(sin(iTime*1.1415926f)*2.0f);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ctfW2","date":"1733802661","viewed":20,"name":"Aurnyx raymarch","username":"Aurnyx","description":"First attempt at a 3d renderer. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarch","raymarch","primitives"],"hasliked":0,"parentid":"","parentname":""}}