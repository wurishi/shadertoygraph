{"ver":"0.1","info":{"id":"tlBGRG","date":"1580184626","viewed":194,"name":"Path tracing testing","username":"gsitcia","description":"I can pretend to have random floats... it focuses on wherever your mouse is","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 C )\n{\n    vec2 R = iResolution.xy;\n    fragColor = texture(iChannel0,C/R);\n    //fragColor *= log(log(fragColor.w));\n}\n\n// Common is a bunch of random stuff\n// Buffer A figures out the number of frames that have passed since releasing the mouse\n// Buffer B does the raymarching stuff\n// Buffer C averages the B buffers\n// The image just copies Buffer C","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define hash21(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float r ) {\n    return length(p) - r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdLens( vec3 p, vec2 l, vec3 d ) {\n    d = normalize(d);\n    float r = (l.y*l.y-l.x*l.x)*0.5/l.x;\n    float d1 = sdSphere(p+d*r,r+l.x);\n    float d2 = sdSphere(p-d*r,r+l.x);\n    return opSmoothIntersection(d1,d2,0.05);\n}\n\nstruct object {\n    int n;\n    //vec3 color;\n    float dist;\n};// n = -1 is reserved for the sky\n\nfloat sd = 0.5;\n\nfloat rand() {\n    //sd = hash21(vec2(sd,sd)+0.5);\n   \tsd = mod(mod(sd*25.398635864258,1.0)+0.23606797284447,1.0);\n    //sd = mod(sd*12345.67890+0.1234567,1.0);\n    return sd;\n}\n\nvoid seed(float n) {\n    sd = n;\n}\n\nvec3 srand() {\n    float u = rand()*2.0-1.0;\n    float v = rand()*6.283;\n    float d = sqrt(1.-u*u);\n    return vec3(d*cos(v),d*sin(v),u);\n}\n\nvec3 brand(vec3 n) {\n    vec3 s = vec3(-normalize(n.xz)*n.y,length(n.xz)).xzy;\n    if (dot(n.xz,n.xz) < 0.01) {\n        s = vec3(-normalize(n.xy)*n.z,length(n.xy));\n    }\n    vec3 r = cross(n,s);\n    float u = rand()*6.283;\n    float v = rand();\n    vec3 d = s*cos(u)+r*sin(u);\n    d *= sqrt(1.0-v);\n    return n*sqrt(v)+d;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvec2 uvfd(mat3 camera, vec3 d) {\n    vec3 z = transpose(camera)*d;\n    return z.xy/z.z;\n}\n\nvec3 refr(vec3 d, vec3 n, object o) {\n    // this one assumes a lot of things, and is set to glass, i'll fix this later\n    if (dot(d,n) > 0.0) {\n        n = -n;\n    }\n    float eta = 1.52;\n    if (o.dist > 0.0) {\n        // outside the object\n        eta = 1.0/eta;\n    }// eta=pow(1.52,sign(o.dist)) ??? \n    vec3 r = refract(d,n,eta);\n    if (r == vec3(0)) {\n        return reflect(d,n);//that's what happens right?\n    }\n    return r;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 bob = texture(iChannel0,vec2(0.5)).xyz;\n    vec4 mo = iMouse;\n    if (mo == vec4(0)) {\n        mo = vec4(0.5);\n    }\n    vec2 m = bob.xy;\n    //if (all(greaterThanEqual(iMouse.zw,vec2(-0.01)))) {\n    if (mo.xy != m || all(greaterThan(iMouse.zw,vec2(0)))) {\n        fragColor = vec4(mo.xy,1,0);\n        return;\n    }\n    float n = bob.z;\n    fragColor = vec4(mo.xy,1.0/(1.0+1.0/n),0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAXITER 100\n#define MAXDIST 30.0\n#define MINDIST 0.0005\n#define RAYDEPTH 42\n#define intersect(n1,n2) ds[n1]=max(-ds[n2],ds[n1])\n\nfloat ll(float a, float b) {\n    return round(fract(atan(a/b)*3.0));\n}\n\nvec3 cmap(object o, vec3 p) {\n    vec3[] colors = vec3[](\n        vec3(0.7,0.7,0.9),\n        //texture(iChannel2,p.xz).xyz,\n        vec3(0.8,0.1,0.8),\n        vec3(0.8,0.8,(ll(p.y,length(p.xz))+ll(p.x,p.z))*0.4+0.1),\n        //texture(iChannel0,atan(vec2(p.y/length(p.xz),p.z/p.x))*2.0).xyz,\n        //vec3(0.9,0.8,0.7),\n        vec3(0.4,0.9,0.4),\n        vec3(0.95,1,1),//vec3(round(fract(p.z))*0.7,1,1),\n        //texture(iChannel0,p.zy/2.0).xyz,\n        vec3(1),vec3(1)\n    );\n    return colors[o.n];\n}\n\nbool lmap(object o) {\n    return o.n == 2;\n}\n\nbool rmap(object o) {\n    return false;//o.n == 4;\n}\n\nbool dmap(object o) {\n    return o.n == 4;\n}\n\nobject map(vec3 p) {\n    float[] ds = float[](\n        sdSphere(p+vec3(0,42,0),42.0),//floor\n        sdSphere(p-vec3(0,0.5,0),0.4),//small ball\n        -sdSphere(p,8.0),//outside\n        sdSphere(p-vec3(1,0.25,-0.5),0.9),//big ball\n        abs(length(p.xz)-1.0)-0.1,//abs(p.x+0.2)-0.1,//wall,\n        //sdLens(p-vec3(-0.5,0.7,-1),vec2(0.05,0.3),vec3(0.81,-0.28,0.85)),\n        -sdSphere(p+vec3(0,1,0),2.0),1.0\n\t\t/* for reasons */\n    );\n    //ds[4] = max(-ds[1],ds[4]);\n    //intersect(4,1);\n    //intersect(4,0);\n    intersect(4,5);\n    intersect(3,4);\n    //ds[3] = max(-ds[1],ds[3]);\n    //intersect(3,1);\n    //ds[1] = 100.0;\n    ds[5] = 100.0;\n    int n = 0;\n    float d = ds[0];\n    for (int i = 1; i < ds.length(); i++) {\n        if (abs(ds[i]) < d) {\n            d = abs(ds[i]);\n            n = i;\n        }\n    }\n    return object(n,ds[n]);\n}\n\nvec3 norm( vec3 p ) {\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 fr = vec3(0.0, 0.0, 1.0);\n    vec3 rt = vec3(1.0, 0.0, 0.0);\n    \n    float mp = map(p).dist;\n    float mu = map(p + mp * up).dist;\n    float md = map(p - mp * up).dist;\n    float mr = map(p + mp * rt).dist;\n    float ml = map(p - mp * rt).dist;\n    float mf = map(p + mp * fr).dist;\n    float mb = map(p - mp * fr).dist;\n    \n    //return normalize(vec3((mr-ml)/(mr+ml),(mu-md)/(mu+md),(mf-mb)/(mf+mb)));\n    return normalize(vec3(mr-ml,mu-md,mf-mb));\n}\n\nobject iterate(inout vec3 p, in vec3 d, out int iters) {\n    float ad = 0.0;\n    object m;\n    bool ss = true;\n    iters = MAXITER;\n    for (int i = 0; i < MAXITER; i++) {\n        m = map(p);\n        float md = abs(m.dist);\n        if (ad > MAXDIST) {\n            iters = i;\n            return object(-1,md); // hit the sky\n        }\n        if (md < MINDIST) {\n            iters = i;\n            return m;\n        }\n        ad += md;\n        p += md*d;\n        //d = normalize(d+brand(d)*0.01);\n        //if (rand() < 0.0001) return object(-2,0.0);//hit a dust\n    }\n    return m; // hit ?\n}\n\nfloat focusl(vec3 eye, mat3 c) {\n    float minres = min(iResolution.x,iResolution.y);\n    vec2 im = iMouse.xy;\n    if (im == vec2(0)) {\n        im = vec2(.47,.49)*iResolution.xy;\n    }\n    vec2 uv = (im-0.5*iResolution.xy)/minres;\n    vec3 d = c*normalize(vec3(uv,1));\n    vec3 p = eye;\n    int bob;\n    object o = iterate(p,d,bob);\n    return dot(p-eye,d);\n}\n\nvec3 drect(vec3 p, vec3 l, int on, vec3 n) {\n    vec3 d = normalize(l-p);\n    int bob;\n    object o = iterate(p,d,bob);\n    if (o.n == on) {\n        return cmap(o,p)*dot(n,d);\n    }\n    return vec3(0);\n}\n\nvec4 trace(inout vec3 p, in vec3 d) {//, in mat3 cam) {\n    vec3 c = vec3(1);\n    vec3 direct = vec3(0);\n    vec3 op = p;\n   \t//float fd = -1.0;\n    //vec2 bob = iResolution.xy*0.5/min(iResolution.x,iResolution.y);\n    //float n = texture(iChannel0,vec2(0.5)).z;\n    //n = n/(1.0-n);\n    float iters = 0.0;\n    for (int i = 0; i < RAYDEPTH; i++) {\n        int bob;\n        op = p;\n        object o = iterate(p,d,bob);\n        vec3 cc = cmap(o,p);\n        //if (o.dist < 0.0) {\n        //    c *= exp(distance(p,op)*8.0*log(cc));\n        //}\n        //if (fd < 0.0) {\n            //fd = distance(p,op);\n            //iters = float(bob);\n        //}\n        if (lmap(o)) {\n            return vec4(direct+c*cc,iters);\n        }\n        vec3 n = norm(p);\n        if (dot(n,d) > 0.0)  {\n            n = -n;\n        }\n        if (rmap(o)) {\n            d = reflect(d,n);\n        } else if (dmap(o)) {\n            d = refr(d,n,o);\n            if (dot(d,n) < 0.0) {//refracted\n                n *= -1.0;\n                p += MINDIST*2.0*n;//get to the other side\n            }\n        } else {\n            d = brand(n);\n            // if we can see a point, we can bootstrap off of what we see\n            // (this does not work)\n            //vec4 z = texture(iChannel1,uvfd(cam,p-op)+bob);\n            //float dis = distance(p,op);\n            //if (abs(dis-z.w) < 0.01) {\n            //    cc = z.xyz*(1.0-n)+cc*n;\n            //    //direct += c*z.xyz;\n            //}\n        }\n        c *= cc;\n        p += MINDIST*2.0*n;\n        //direct += c*drect(p,vec3(0,0.5,0),1,n);\n    }\n    return vec4(direct,iters);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n = texture(iChannel0,vec2(0.5)).z;\n    //seed(sin(fragCoord.x-fragCoord.y)); // lines, slower\n    seed(fragCoord.x/fragCoord.y); // noise, slowest (on my computer)\n    seed(sin(0.01/n+rand()));\n    fragCoord.x += rand(); fragCoord.y += rand();\n    float minres = min(iResolution.x,iResolution.y);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/minres;\n    vec2 im = iMouse.xy/iResolution.xy;\n    if (im == vec2(0)) {\n        im = vec2(.47,.49);\n    }\n    im.x *= -6.283;\n    im.x += 0.2;\n    im.y = im.y*1.5+0.8;\n    vec3 eye = vec3(3.0*vec2(sin(im.x),cos(im.x)),im.y).xzy;\n    eye = normalize(eye)*2.5;\n    //vec3 eye = vec3(3,0,0);\n    vec3 fdir = normalize(vec3(0,0.5,0)-eye);\n    vec3 udir = vec3(-normalize(fdir.xz)*fdir.y,length(fdir.xz)).xzy;\n    vec3 rdir = cross(fdir,udir);\n    mat3 cam = mat3(rdir,udir,fdir);\n    vec3 d = eye + focusl(eye,cam)*(fdir*1.0+udir*uv.y+rdir*uv.x);\n    float rrr = rand()*2.0*3.1416;\n    //eye += 0.0225*(sin(rrr)*rdir+cos(rrr)*udir)*sqrt(rand());\n    eye += 0.05*(rand()*rdir+rand()*udir);\n    d = normalize(d-eye);\n    //d = cam*normalize(vec3(uv,1));\n    /*\n\tvec3 z = vec3(0);\n    int n = 10;\n    for (int i = 0; i < n; i++) {\n        z += trace(eye,d);\n    }\n    z /= float(n);\n    fragColor = vec4(z,0);/*/\n    //vec3 e = eye;\n    fragColor = trace(eye,d);\n  \t//fragColor = texture(iChannel1,uvfd(cam,eye-e)+iResolution.xy*0.5/minres);\n    /* bob */\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float n = texture(iChannel2,vec2(0.5)).z;//.0/float(iFrame+1);\n    //float r = 0.001;\n    /*fragColor = texture(iChannel1,(fragCoord+vec2(r,r))/iResolution.xy);\n    fragColor += texture(iChannel1,(fragCoord+vec2(-r,r))/iResolution.xy);\n    fragColor += texture(iChannel1,(fragCoord+vec2(r,-r))/iResolution.xy);\n    fragColor += texture(iChannel1,(fragCoord+vec2(-r,-r))/iResolution.xy);\n    fragColor *= (1.0-n)/4.0;*/\n    fragColor = texture(iChannel1,uv)*(1.0-n);\n    fragColor += sqrt(texture(iChannel0,uv))*n;\n    //fragColor = max(texture(iChannel1,uv),sqrt(texture(iChannel0,uv)));\n    //fragColor = sqrt(texture(iChannel0,uv));\n}","name":"Buffer C","description":"","type":"buffer"}]}