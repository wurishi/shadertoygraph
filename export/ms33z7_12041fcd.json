{"ver":"0.1","info":{"id":"ms33z7","date":"1677232636","viewed":132,"name":"Quad Bezier chain - SDF.2 2D","username":"MatheoMoinet","description":"Chaining together multiple quadratic bezier curves\nRadius is a function of arc length","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","bezier","spline","distance","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Quad Bezier chain - distance 2D\" by MatheoMoinet. https://www.shadertoy.com/view/dsdGR8\n\n\n\n\n\n// =========== Bezier Curves Definitions ===========================================================================================================================================================\n\nvoid createAllBezierCurves(){\n    // Curve 1\n    vec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,0.0) );\n    \n    vec2[3] bezier_1_init_pts = vec2[](\n            v0,\n            v1,\n            v2\n    );\n    vec2[BEZIER_MAX_NBR_ADDI_SEGMENTS] bezier_1_addi_pts;\n    bezier_1_addi_pts[0] = vec2(-1., -0.5);\n    bezier_1_addi_pts[1] = vec2(-1., -1.);\n    bezier_1_addi_pts[2] = vec2(0.2, 0.7);\n    float[BEZIER_MAX_NBR_ADDI_SEGMENTS] bezier_1_Bs_dist_coef;\n    bezier_1_Bs_dist_coef[0] = 1.0;\n    bezier_1_Bs_dist_coef[1] = 0.5;\n    bezier_1_Bs_dist_coef[2] = 1.;\n    BezierCurve bezier1 = createBezierCurve(bezier_1_init_pts, bezier_1_addi_pts, bezier_1_Bs_dist_coef, 4);\n    \n    // Curve 2\n    vec2[3] bezier_2_init_pts = vec2[](\n        vec2(0.0,0.0),\n        vec2(1.2,0.),\n        vec2(1., -0.5)\n    );\n    vec2[BEZIER_MAX_NBR_ADDI_SEGMENTS] bezier_2_addi_pts;\n    //bezier_2_addi_pts[0] = vec3(-10., -1., 0.);\n    float[BEZIER_MAX_NBR_ADDI_SEGMENTS] bezier_2_Bs_dist_coef;\n    //bezier_2_Bs_dist_coef[0]=1.;\n    BezierCurve bezier2 = createBezierCurve(bezier_2_init_pts, bezier_2_addi_pts, bezier_2_Bs_dist_coef, 1);\n}\n\n// ======================================================================================================================================================================\n\n\n\nfloat GetDist(vec2 p) {\n    return sdBezierSurf(p);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mousePosition = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    createAllBezierCurves();\n    initBezierCurves();\n    \n    float d = GetDist(position);\n    \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7); // base color\n    color *= 1.0 - exp(-4.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(120.0 * d); // ripples\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.003) * iResolution.y));\n    \n    if (iMouse.z > 0.0) {\n        float dm = GetDist(mousePosition);\n        color = mix(color, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(position-mousePosition)-abs(dm))-0.0025));\n        color = mix(color, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(position-mousePosition)-0.015));\n    }\n    fragColor = vec4(color, 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BEZIER_LENGTH_DISTORTION_MODE 1    //0: length= t,    1: length= real length\n#define BEZIER_LENGTH_REZOLUTION 3 //At least 2\n\n//From FabriceNeyret2 https://www.shadertoy.com/view/llySRh\n// --- key toggles -----------------------------------------------------\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel3,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel3,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n// --- events ----------------------------------------------------------\n\n// --- mouse side events https://www.shadertoy.com/view/3dcBRS\n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame)\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.w < 0. )                  // mouse clicked:   mouse button currently clicked\n// ------------------\n\n#define rotDir2(V) mat2(V.x,V.y,-V.y,V.x)\n#define rot90_vec2(A) vec2(-A.y, A.x)\n#define rotCCW90_vec2(A) vec2(A.y, -A.x)\n\n\n// ========= Bezier Struct and Globals =======================================================================================================================\n\nconst int bezier_nbr_curves = 2;\nconst int bezier_nbr_segments = 5; //Total nbr of segments of all curves\n#define BEZIER_MAX_NBR_ADDI_SEGMENTS 4 //Max nbr of segments for one curve\n\nstruct BezierSegment {\n    vec2 A,B,C;  //Control points\n    float acc_length_offset;\n    float seg_length;\n};\n\nstruct BezierCurve {\n    vec2[3] init_ctrl_points;\n    vec2[BEZIER_MAX_NBR_ADDI_SEGMENTS] addi_ctrl_points;\n    float[BEZIER_MAX_NBR_ADDI_SEGMENTS] Bs_dist_coef;\n    int curve_id;\n    int nbr_segments;\n    int segment_arr_offset;\n};\nBezierCurve[bezier_nbr_curves] bezier_curves;\nint new_curve_arr_offset=0;\nint new_curve_id = 0;\nBezierSegment[bezier_nbr_segments] bezier_all_segments;\n\n\n// ============= Bezier Basic Functions =========================================================================================================================================================\n\nvec2 bezierFunc( vec2 A, vec2 B, vec2 C, float t ){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    return (1.0-t)*(1.0-t)*A + 2.0*(1.0-t)*t*B + t*t*C; // b(t) = (1-t)^2*A + 2(1-t)t*B + t^2*C\n}\n\nvec2 bezier_dx( vec2 A, vec2 B, vec2 C, float t ){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    return 2.0*(t-1.0)*A + 2.0*(1.0-2.0*t)*B + 2.0*t*C; // b'(t) = 2(t-1)*A + 2(1-2t)*B + 2t*C\n}\n\nvec2 bezier_dx_dx( vec2 A, vec2 B, vec2 C, float t ){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    return 2.0*A - 4.0*B + 2.0*C; // b\"(t) = 2*A - 4*B + 2*C\n}\n\n\n// ============= Bezier Setup Functions =========================================================================================================================================================\n\n\n\nBezierSegment bezierGetSegment(BezierCurve bezier_curve, int segment_i){\n    return bezier_all_segments[bezier_curve.segment_arr_offset+segment_i];\n}\n\nvoid bezierSetSegment(BezierCurve bezier_curve, int segment_i, BezierSegment segment){\n    bezier_all_segments[bezier_curve.segment_arr_offset+segment_i] = segment;\n}\n\nfloat bezierLength(BezierSegment seg, float t){\n    int nbr_parts = BEZIER_LENGTH_REZOLUTION;\n    vec2 pos_on_curve = bezierFunc(seg.A, seg.B, seg.C, t);\n    vec2 last_point = seg.A;\n    vec2 next_point;// = bezierFunc(seg.A, seg.B, seg.C, 1./nbr_parts);\n    float total_len = 0.;//= length(last_point-next_point);\n    for (float i=1.; (1./float(nbr_parts))*i < t ; i++){\n        next_point = bezierFunc(seg.A, seg.B, seg.C, (1./float(nbr_parts))*i);\n        total_len += length(last_point-next_point);\n        last_point = next_point;\n    }\n    total_len += length(last_point-pos_on_curve);\n    return total_len;\n}\n\n\nfloat bezierLength(BezierCurve b_curve, float t){\n    BezierSegment seg = bezierGetSegment(b_curve, int(t));;\n    float local_len;\n    if (float(b_curve.nbr_segments) == t){ //Last segment, and t = 1. for this segment\n        local_len = bezierLength(seg, 1.);\n        seg = bezierGetSegment(b_curve, int(t-1.));\n    } else {\n        local_len = bezierLength(seg, fract(t));\n    }\n    float total_len = local_len + seg.acc_length_offset;\n    return total_len;\n}\n\nfloat bezierCurvilinearAbscissa(BezierCurve b_curve, float t){\n    #if BEZIER_LENGTH_DISTORTION_MODE == 0\n        return t;\n    #else\n        return bezierLength(b_curve, t);\n    #endif\n}\n\nfloat bezierGetRadius(BezierCurve bezier_curve, float t){\n    //return 0.1;\n    if (t<0. || t> float(bezier_curve.nbr_segments)){\n        return 0.;\n    }\n    switch (bezier_curve.curve_id){\n        case 0:\n            t = bezierLength(bezier_curve, t)*0.1;\n            return 0.2*min(t,0.3);//0.4*2.*abs(cos(iTime));//*t;\n            break;\n        case 1:\n            t = bezierLength(bezier_curve, t);\n            return 0.1+cos(t*5.)*0.1;\n            break;\n    }\n}\n\nvoid bezierCreateSegments(BezierCurve bezier_curve){\n    int seg_idx = bezier_curve.segment_arr_offset;\n    bezier_all_segments[seg_idx].A = bezier_curve.init_ctrl_points[0];\n    bezier_all_segments[seg_idx].B = bezier_curve.init_ctrl_points[1];\n    bezier_all_segments[seg_idx].C = bezier_curve.init_ctrl_points[2];\n    for (int i=0; i<bezier_curve.nbr_segments-1; i++){\n        int seg_idx = bezier_curve.segment_arr_offset+i+1;\n        vec2 A = bezier_all_segments[seg_idx-1].C;\n        vec2 C = bezier_curve.addi_ctrl_points[i];\n        vec2 prevB = bezier_all_segments[seg_idx-1].B;\n        vec2 B = A + (A-prevB)*bezier_curve.Bs_dist_coef[i];\n        bezier_all_segments[seg_idx].A = A;\n        bezier_all_segments[seg_idx].B = B;\n        bezier_all_segments[seg_idx].C = C;\n    }\n}\n\nvoid bezierInitSegmentLength(BezierCurve b_curve){\n    float acc_length_offset = 0.;\n    for (int i=0; i<b_curve.nbr_segments; i++){\n        BezierSegment seg = bezierGetSegment(b_curve, i);\n        seg.acc_length_offset = acc_length_offset;\n        float seg_len = bezierLength(seg, 1.);\n        acc_length_offset += seg_len;\n        seg.seg_length = seg_len;\n        bezierSetSegment(b_curve, i, seg);\n    }\n}\n\n\nvoid initBezierSegments(BezierCurve bezier_curve){\n    bezierCreateSegments(bezier_curve);\n    bezierInitSegmentLength(bezier_curve);\n}\n\nvoid initBezierCurves(){\n    for (int i=0; i<bezier_curves.length(); i++){\n        initBezierSegments(bezier_curves[i]);\n    }\n}\n\nBezierCurve createBezierCurve(\n    vec2[3] init_ctrl_points, \n    vec2[BEZIER_MAX_NBR_ADDI_SEGMENTS] addi_ctrl_points, \n    float[BEZIER_MAX_NBR_ADDI_SEGMENTS] Bs_dist_coef, \n    int nbr_of_segments\n){\n    int curve_id = new_curve_id++;\n    int segment_arr_offset = new_curve_arr_offset;\n    new_curve_arr_offset += nbr_of_segments;\n    BezierCurve bezier_curve = BezierCurve(init_ctrl_points, addi_ctrl_points, Bs_dist_coef, curve_id, \n                                    nbr_of_segments, segment_arr_offset);\n    bezier_curves[curve_id] = bezier_curve;\n    return bezier_curve;\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); } //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n        // 1 root\n        res = vec2(dot2(d+(c+b*t)*t),t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        \n        // 3 roots, but only need two\n        float dis = dot2(d+(c+b*t.x)*t.x);\n        res = vec2(dis,t.x);\n        dis = dot2(d+(c+b*t.y)*t.y);\n        if( dis<res.x ) res = vec2(dis,t.y );\n    }\n    res.x = sqrt(res.x);\n    return res;\n}\n\nvec2 sdBezier(vec2 pos, BezierCurve bezier_curve, BezierSegment segment, int i){\n    vec2 A = segment.A, B = segment.B, C = segment.C;\n    vec2 res = sdBezier(pos, A,B,C);\n    if (res.y<=0. || res.y>=1.){\n        res.x += 1e8;\n    }\n    return res;\n}\n\nvec2 sdBezier(vec2 pos, BezierCurve bezier_curve){ // sd for multy segment bezier curve\n    vec2 best_res = vec2(1e10);\n    for (int i=0; i<bezier_curve.nbr_segments; i++){   \n        BezierSegment currentSegment = bezierGetSegment(bezier_curve,i);\n        vec2 res = sdBezier(pos, bezier_curve, currentSegment, i);\n        if (res.x < best_res.x ){ //&& res.y>=0. && res.y<=1.\n            best_res = res;\n            best_res.y += float(i); \n        }\n    }\n    return best_res;\n}\n\nvec2 sdBezierSurf(vec2 pos, BezierCurve bezier_curve, BezierSegment segment, int i){\n    vec2 A = segment.A, B = segment.B, C = segment.C;\n    vec2 res = sdBezier(pos, A,B,C);\n    float curr_radius = bezierGetRadius(bezier_curve, res.y + float(i));\n    res.x -= curr_radius;\n    return res;\n}\n\nvec2 sdBezierSurf(vec2 pos, BezierCurve bezier_curve){ // sd for multy segment bezier curve\n    vec2 best_res = vec2(1e10);\n    for (int i=0; i<bezier_curve.nbr_segments; i++){   \n        BezierSegment currentSegment = bezierGetSegment(bezier_curve,i);\n        vec2 res = sdBezierSurf(pos, bezier_curve, currentSegment, i);\n        if (res.x < best_res.x ){ //&& res.y>=0. && res.y<=1.\n            best_res = res;\n            best_res.y += float(i); \n        }\n    }\n    return best_res;\n}\n\nfloat sdBezierSurf(vec2 p) {\n    float d=1e8;\n    for (int i=0; i<bezier_nbr_curves; i++){\n        BezierCurve bezier_curve = bezier_curves[i];\n        d = min(d,sdBezierSurf(p, bezier_curve).x);\n    }\n    return d;\n}\n","name":"Common","description":"","type":"common"}]}