{"ver":"0.1","info":{"id":"lXtXWX","date":"1719781102","viewed":76,"name":"Procedural Jupiter","username":"ArchaicVirus","description":"Raymarched Jupiter-like gas giant. Uses multiple noise layering techniques to mimic advection and the 'great red spot'","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","space","planet","ring","gas","jupiter","giant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DITHER_STRENGTH 0.02\n#define PIXEL_SIZE 0.5\n\n//toggle camera animation \n#define ROTATE_VIEW false\n\n//toggle light animation\n#define ROTATE_LIGHT false\n\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n#define RETURN_WORLEY m_dist;\n\nvec3 planetParamsA = vec3(1.435, 1.0, 0.2);\nvec3 planetParamsB = vec3(1.2, 1.0, 1.5);\nvec3 planetParamsC = vec3(1.0, 1.0, 1.0);\nvec3 planetParamsD = vec3(0.00, 0.10, 0.20);\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(4.28318 * (c * t + d));\n}\n\nvec3 rotateY(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\n//Start of VitaleMarco's \"Worley Noise Functions\"\n//https://www.shadertoy.com/view/fscSzr\nfloat rand3dTo1d(vec3 value, vec3 dotDir){\n    vec3 smallValue = sin(value);\n    float random = dot(smallValue, dotDir);\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nvec3 rand3dTo3d(vec3 value){\n    return vec3(\n        rand3dTo1d(value, vec3(12.989, 78.233, 37.719)),\n        rand3dTo1d(value, vec3(39.346, 11.135, 83.155)),\n        rand3dTo1d(value, vec3(73.156, 52.235, 09.151))\n    );\n}\n\nfloat rand2dTo1d(vec2 value, vec2 dotDir){\n    vec2 smallValue = sin(value);\n    float random = dot(smallValue, dotDir);\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nvec2 rand2dTo2d(vec2 value){\n    return vec2(\n        rand2dTo1d(value, vec2(12.989, 78.233)),\n        rand2dTo1d(value, vec2(39.346, 11.135))\n    );\n}\n\nfloat worleyNoise2D(vec2 uv, vec2 scale, vec2 offset){\n    //APPLY SCALE\n    uv *= scale;\n    \n    //APPLY OFFSET\n    uv += offset;\n\n    //TILE THE SPACE INTO CELLS\n    vec2 floor_uv = floor(uv);\n    vec2 fract_uv = fract(uv);\n\n    //INITIAL DISTANCE\n    float m_dist = 1.0;\n\n    //LOOP THROUGH ALL THE NEIGHBOUR CELLS\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            //GET THE NEIGHBOUR CELL IN THE GRID\n            vec2 neighbor = vec2(x, y);\n\n            //GET THE POSITION OF THE CURRENT CELL AND THE NEIGHBOUR\n            vec2 point = rand2dTo2d(floor_uv + neighbor);\n\n\t\t\t//GET THE VECTOR BETWEEN THE CELLS\n            vec2 diff = neighbor + point - fract_uv;\n\n            //CALCULATE THE DISTANCE BETWEEN THE NEIGHBOUR AND THE CURRENT POINT\n            float dist = length(diff);\n\n            //KEEP THE CLOSER DISTANCE\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    //RETURN THE MINIMUM DISTANCE\n    return RETURN_WORLEY\n}\n\nfloat worleyNoise3D(vec3 pos, vec3 scale, vec3 offset){\n    //APPLY SCALE\n    pos *= scale;\n    \n    //APPLY OFFSET\n    pos += offset;\n\n    //TILE THE SPACE INTO CELLS\n    vec3 floor_pos = floor(pos);\n    vec3 fract_pos = fract(pos);\n\n    //INITIAL DISTANCE\n    float m_dist = 1.0;\n\n    //LOOP THROUGH ALL THE NEIGHBOUR CELLS\n    for (int z = -1; z <= 1; z++) {\n        for (int y= -1; y <= 1; y++) {\n            for (int x= -1; x <= 1; x++) {\n                //GET THE NEIGHBOUR CELL IN THE GRID\n                vec3 neighbor = vec3(x, y, z);\n\n                //GET THE POSITION OF THE CURRENT CELL AND THE NEIGHBOUR\n                vec3 point = rand3dTo3d(floor_pos + neighbor);\n\n                //GET THE VECTOR BETWEEN THE CELLS\n                vec3 diff = neighbor + point - fract_pos;\n\n                //CALCULATE THE DISTANCE BETWEEN THE NEIGHBOUR AND THE CURRENT POINT\n                float dist = length(diff);\n\n                //KEEP THE CLOSER DISTANCE\n                m_dist = min(m_dist, dist);\n            }\n        }\n    }\n    //RETURN THE MINIMUM DISTANCE\n    return RETURN_WORLEY\n}\n\nfloat fBmWorleyNoise2D(vec2 uv, vec2 scale, vec2 offset, int octaves, float lacunarity, float gain) {\n    //INITIAL VALUES\n    float value = 0.0;\n    float amplitude = .5;\n    \n    //LOOP OF OCTAVES\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * worleyNoise2D(uv, scale, offset);\n        uv*= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nfloat fBmWorleyNoise3D(vec3 pos, vec3 scale, vec3 offset, int octaves, float lacunarity, float gain) {\n    //INITIAL VALUES\n    float value = 0.0;\n    float amplitude = .5;\n\n    //LOOP OF OCTAVES\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * worleyNoise3D(pos, scale, offset);\n        pos*= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n////End of VitaleMarco's \"Worley Noise Functions\"\n\nvec3 getProcColor(float n) {\n    return palette(n, planetParamsA, planetParamsB, planetParamsC, planetParamsD);\n}\n\nvec3 colorBandingPlanet(float n) {\n    if (n > 0.9) return getProcColor(0.0) + (0.1 - (((n - 0.9) / 0.1) * 0.25) * 3.75);\n    if (n > 0.8) return getProcColor(0.0) + (0.1 - (((n - 0.8) / 0.1) * 0.25) * 3.75);\n    if (n > 0.7) return getProcColor(0.0) + (0.1 - (((n - 0.7) / 0.1) * 0.25) * 3.75);\n    if (n > 0.6) return getProcColor(0.0) + (0.1 - (((n - 0.6) / 0.1) * 0.25) * 3.75);\n    if (n > 0.5) return getProcColor(0.0) + (0.1 - (((n - 0.5) / 0.1) * 0.25) * 3.75);\n    if (n > 0.4) return getProcColor(0.0) + (0.1 - (((n - 0.4) / 0.1) * 0.25) * 3.75);\n    if (n > 0.3) return getProcColor(0.0) + (0.1 - (((n - 0.3) / 0.1) * 0.25) * 3.75);\n    if (n > 0.2) return getProcColor(0.0) + (0.1 - (((n - 0.2) / 0.1) * 0.25) * 3.75);\n                 return getProcColor(0.0) + (0.1 - (((n - 0.1) / 0.1) * 0.25) * 3.75);\n}\n\nconst mat4 bayerMatrix = mat4(\n    0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,\n    12.0/16.0, 4.0/16.0, 14.0/16.0,  6.0/16.0,\n    3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,\n    15.0/16.0, 7.0/16.0, 13.0/16.0,  5.0/16.0\n);\n\nvec3 applyDithering(vec3 color, vec2 uv) {\n    int x = int(mod(uv.x, 4.0));\n    int y = int(mod(uv.y, 4.0));\n    float threshold = bayerMatrix[x][y];\n    return color + threshold * DITHER_STRENGTH;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.25;\n}\n\nfloat ringSDF(vec3 p, float innerRadius, float outerRadius) {\n    vec2 d = vec2(length(p.xz) - outerRadius, abs(p.y) - 0.001);\n    float outer = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    vec2 innerD = vec2(innerRadius - length(p.xz), abs(p.y) - 0.001);\n    float inner = length(max(innerD, 0.0)) + min(max(innerD.x, innerD.y), 0.0);\n    return max(max(inner, -outer), outer);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sphereSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sphereSDF(vec3(p.x + EPSILON, p.y, p.z)) - sphereSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sphereSDF(vec3(p.x, p.y + EPSILON, p.z)) - sphereSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sphereSDF(vec3(p.x, p.y, p.z + EPSILON)) - sphereSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //set up camera\n    vec3 eye = vec3(0.0, 1.0, 6.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    //animate camera\n    if (ROTATE_VIEW) {\n        float angle = iTime * 0.15;\n        eye = vec3(6.0 * cos(angle), 1.0 + (2.0 * (sin(angle) * 2.0)), 6.0 + (12.0 * sin(angle)));\n    }\n    mat4 viewToWorld = viewMatrix(eye, target, up);\n    //apply pixel size\n    vec2 quantizedFragCoord = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, quantizedFragCoord);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    //no hit, return background color\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    vec3 p = eye + dist * worldDir;\n    //rotate the scene\n    vec3 rotatedP = rotateY(p, iTime * 0.05);\n    vec3 col;\n    float noiseValue;\n    vec3 lightPos;\n    //animate light source?\n    if (ROTATE_LIGHT) {\n        float anglel = iTime * 0.2;\n        lightPos = vec3(6.0 * cos(anglel), 1.0 + (2.0 * (sin(anglel) * 2.0)), 6.0 + (12.0 * sin(anglel)));\n    } else {\n        lightPos = vec3(10.0, 20.0, 20.0);\n    }\n    vec3 lightIntensity = vec3(0.12);\n    vec3 lightDir = normalize(lightPos - rotatedP);\n    vec3 normal = estimateNormal(p) * 2.0;\n    \n    float ratio = iResolution.y / iResolution.x;\n    float offset = iTime * 0.1;\n    vec3 scale = vec3(3.65, 10.0 + sin(iTime * 0.1), 3.65);\n    vec3 scaleRed = vec3(1.5 + sin(iTime * 0.2) * 0.05, 2.0, 1.5 + cos(iTime * 0.2) * 0.05) * 1.15;\n    float wNoise  = fBmWorleyNoise3D(rotatedP, scale, vec3(offset), 3, 2.75, 0.8);\n    float wNoise2 = fBmWorleyNoise3D(rotatedP, scale, vec3(offset), 6, 2.0, 0.6);\n    float wNoise3 = fBmWorleyNoise3D(rotatedP * vec3(2.0, 2.75, 2.0), vec3(0.175, 2.0, 0.165), vec3(0.0, iTime * 0.1, 20.0), 6, 1.75, 0.6);\n    float wNoise4 = fBmWorleyNoise3D(rotatedP*0.5, scaleRed, vec3(100.0, 0.0, 200.0), 5, 0.75, 0.6);\n    if (wNoise4 < 0.26 + sin(wNoise2 * 0.035)) {\n        //great red spot\n        col = colorBandingPlanet(mix(mix(wNoise, wNoise4, 1.75), wNoise4, 1.75)) * wNoise + vec3(3.0, 0.5, 0.0);\n    }else if (wNoise3 > 0.58 + sin(wNoise * 0.135)) {\n        //brownish bands\n        col = colorBandingPlanet(mix(mix(wNoise4, wNoise3, 1.25), wNoise, 2.75)) * wNoise * 0.72 + vec3(0.55, 0.15, 0.10) * 1.0;\n    }else{\n        //lighter cloudy area\n        float n = mix(wNoise, mix(wNoise4, wNoise3, 3.5), 3.5) * 0.5;\n        col = colorBandingPlanet(applyDithering(vec3(n * 0.115), quantizedFragCoord / PIXEL_SIZE).x);\n    }\n\n    //add lighting\n    float diffuse = max(dot(normal, lightDir), 0.15);\n    vec3 color = col * diffuse * lightIntensity;\n    fragColor = vec4((color), 1.0);\n}","name":"Image","description":"","type":"image"}]}