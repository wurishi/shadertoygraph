{"ver":"0.1","info":{"id":"Wsc3D4","date":"1568509847","viewed":162,"name":"2D Dual Vector Distance Estimate","username":"skye_adaire","description":"This uses a vector2 of dual real numbers to compute the distance estimate of an implicit function.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["distance","implicit","dual","real","estimate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n#define Real float\n#define Nat uint\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_inverse(Real r)\n{\n \treturn 1.0 / r;   \n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_power(Real x, Real e)\n{\n    return pow(x, e);\n}\n\nReal H_power(Real x, Nat e)\n{\n    return pow(abs(x), float(e)) * ((e % 2u) == 0u ? 1.0 : sign(x));\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\nReal H_sin(Real r)\n{\n    return sin(r);\n}\n\nReal H_cos(Real r)\n{\n    return cos(r);\n}\n\n#define DualReal vec2\n\nDualReal D_add(DualReal lhs, DualReal rhs)\n{\n    return lhs + rhs;\n}\n\nDualReal D_subtract(DualReal lhs, DualReal rhs)\n{\n    return lhs - rhs;\n}\n\nDualReal D_multiply(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualReal D_divide(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualReal D_power(DualReal d, Real exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\nDualReal D_power(DualReal d, Nat exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(float(exponent) * H_power(d[0], exponent - 1u), d[1]));\n}\n\nDualReal D_sq(DualReal d)\n{\n \treturn D_multiply(d, d);   \n}\n\nDualReal D_inverse(DualReal d)\n{\n    return DualReal(\n        H_inverse(d[0]),\n        H_multiply(H_negate(H_inverse(H_sq(d[0]))), d[1]));\n}\n\nDualReal D_sin(DualReal d)\n{\n \treturn DualReal(\n        H_sin(d[0]), \n        H_multiply(d[1], H_cos(d[0])));   \n}\n                          \nDualReal D_cos(DualReal d)\n{\n \treturn DualReal(\n        H_cos(d[0]),\n        H_multiply(H_negate(d[1]), H_sin(d[0])));   \n}\n\n#define DualVector2 mat2x2\n\n//end Hypercomplex\n\nDualReal f(DualVector2 d)\n{\n    DualReal a = DualReal(cos(iTime) * 4.0, 0);\n    DualReal s = DualReal(sin(iTime * pi32 * 0.2)*0.4 + 0.6, 0);\n    \n    return d[1] - D_multiply(D_cos(D_multiply(d[0], s)), a);\n    \n    \n    \n    return D_multiply(D_sq(d[0]), a) + D_sq(d[1]) - DualReal(1, 0);\n}\t\n\nfloat getDE(vec2 p, out vec2 gradient)\n{\n \tDualReal dx = f(DualVector2(p.x, 1, p.y, 0)); \n    DualReal dy = f(DualVector2(p.x, 0, p.y, 1));\n    \n    float fp = dx[0];//level, same for both partials\n    gradient = vec2(dx[1], dy[1]);\n   \n    return fp / length(gradient);\n}\n\nvec3 getColor(vec2 p)\n{\n    vec2 gradient;\n    float de = getDE(p, gradient);\n    \n    vec3 normal = normalize(vec3(gradient, 0));\n    float curve = 1.0 - smoothstep(0.19, 0.2, abs(de));\n    \n    vec3 color = vec3(0);  \n    vec3 colorNegative = vec3(1,0.8,0.8);\n    vec3 colorPositive = vec3(0.8,1,0.8);\n    vec3 background = vec3(fract(de));\n    if (de < 0.0) background = 1.0 - background;\n    background *= 0.7;\n    \n    color = mix(background, normal, curve);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n   \tclip.x *= iResolution.x / iResolution.y;\n    vec2 p = clip * 6.0;\n\n    // Output to screen\n    fragColor = vec4(getColor(p),1.0);\n}","name":"Image","description":"","type":"image"}]}