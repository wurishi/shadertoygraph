{"ver":"0.1","info":{"id":"wldSRN","date":"1580555439","viewed":132,"name":"Practise | The Drive Home","username":"Tilmut","description":"learning from the tutorial: https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg/videos","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(x, y, t) smoothstep(x, y, t)\nfloat N(float t) {\n\treturn fract(sin(t*3456.)*6547.);//fract取小数部分,N函数取随机数\n}\nvec4 N14(float t){\n    return fract(sin(t*vec4(123.,1024.,3456.,9576.))*vec4(6547.,345.,7585.,3212.));\n}\n\nstruct ray {\n\tvec3 o, d;   \n};\n    \nray GetRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom) {\n\tray cam;\n    cam.o = camPos;\n    \n    vec3 f = normalize(lookAt-cam.o);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = cam.o + f * zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    cam.d = normalize(i-cam.o);\n    \n    return cam;\n} \n\nvec3 ClosestPoint(ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\nfloat DistRay(ray r, vec3 p) {\n\treturn length(p-ClosestPoint(r, p));\n}\n\nfloat Bokeh(ray r, vec3 p, float size, float blur) {//散焦模糊\n\tfloat d = DistRay(r, p);\n    \n    size *= length(p);\n    float c = S(size, size*(1.-blur), d);\n    c *= mix(.7, 1., S(size*.8, size, d));\n    return c;\n}\n\nvec3 Streetlights(ray r, float t) {\n    float side = step(r.d.x, 0.);//step返回1或0，比较两值大小\n    r.d.x = abs(r.d.x);//镜像\n    float s = 1./10.; // 0.1\n    float m = 0.;\n    for(float i=0.; i<1.; i+=s) {\n        float ti = fract(t+i+side*s*.5);//镜像两边进程各差一半\n    \tvec3 p = vec3(2.,2.,100.-ti*100.);\n    \tm += Bokeh(r, p, .05, .1)*ti*ti*ti;\n    }\n    \n    return vec3(1., .7, .3)*m;\n}\nvec3 Envlights(ray r, float t) {\n    float side = step(r.d.x, 0.);\n    r.d.x = abs(r.d.x);\n    float s = 1./10.; // 0.1\n    vec3 c=vec3(0.);\n    \n    for(float i=0.; i<1.; i+=s) {\n        float ti = fract(t+i+side*s*.5);\n        vec4 n=N14(i+side*100.);\n        \n        float fade=ti*ti*ti;\n        float occlusion=sin(ti*6.28*10.*n.x)*.5+.5;//遮挡\n        fade=occlusion;\n        \n        float x=mix(2.5,10.,n.x);\n        float y=mix(.1,1.5,n.y);\n    \tvec3 p = vec3(x,y,50.-ti*50.);\n        vec3 col=n.wzy;\n    \tc += Bokeh(r, p, .05, .1)*fade*col*.5;;\n    }\n    \n    return c;\n}\n\n\n\nvec3 Headlights(ray r, float t) {\n    \n    t *= 2.;\n    \n    float w1 = .25;\n    float w2 = w1*1.2;\n    \n    float s = 1./30.; // 0.1\n    float m = 0.;\n    for(float i=0.; i<1.; i+=s) {\n        \n        float n = N(i);\n        \n        if(n>.1) continue;\n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n\t\tfloat focus = S(.9, 1., ti);\n        \n        float size = mix(.05, .03, focus);\n        \n    \tm += Bokeh(r, vec3(-1.-w1,.15, z), size, .1)*fade;\n        m += Bokeh(r, vec3(-1.+w1,.15, z), size, .1)*fade;\n        \n        m += Bokeh(r, vec3(-1.-w2,.15, z), size, .1)*fade;\n        m += Bokeh(r, vec3(-1.+w2,.15, z), size, .1)*fade;\n        \n        float ref = 0.;\n        ref += Bokeh(r, vec3(-1.-w2, -.15, z), size*3., 1.)*fade;\n        ref += Bokeh(r, vec3(-1.+w2, -.15, z), size*3., 1.)*fade;\n        \n        m += ref*focus;\n    }\n    \n    return vec3(.9, .9, 1.)*m;\n}\n\nvec3 Taillights(ray r, float t) {\n    \n    t *= .25;\n    \n    float w1 = .25;\n    float w2 = w1*1.2;\n    \n    float s = 1./15.; \n    float m = 0.;\n    for(float i=0.; i<1.; i+=s) {\n        \n        float n = N(i); // 0 - 1\n        \n        if(n>.5) continue;\n        \n        // n = 0 - 0.5\n        \n        float lane = step(.25, n); // 0 1\n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n\t\tfloat focus = S(.9, 1., ti);\n        \n        float size = mix(.05, .03, focus);\n        \n        float laneShift = S(1., .96, ti);\n        float x = 1.5 - lane * laneShift;\n        \n        float blink = step(0., sin(t*1000.))*7.*lane*step(.96, ti);\n        \n    \tm += Bokeh(r, vec3(x-w1,.15, z), size, .1)*fade;\n        m += Bokeh(r, vec3(x+w1,.15, z), size, .1)*fade;\n        \n        m += Bokeh(r, vec3(x-w2,.15, z), size, .1)*fade;\n        m += Bokeh(r, vec3(x+w2,.15, z), size, .1)*fade*(1.+blink);\n        \n        float ref = 0.;\n        ref += Bokeh(r, vec3(x-w2, -.15, z), size*3., 1.)*fade;\n        ref += Bokeh(r, vec3(x+w2, -.15, z), size*3., 1.)*fade*(1.+blink*.1);\n        \n        m += ref*focus;\n    }\n    \n    return vec3(1., .1, .03)*m;\n}\nvec2 Rain(vec2 uv, float t){\n    t*=40.;\n    //uv*=3.;\n    vec2 a=vec2(3.,1.);\n    vec2 st=uv*a;//另一组uv\n    vec2 id=floor(st);\n    st.y+=t*.22;//网格排列下降，使看不出雨滴上升\n    \n    float n=fract(sin(id.x*716.34)*768.34);\n    st.y+=n;//列随机上下排布，让雨滴不平行落下\n    uv.y+=n;//使随机数不会抵消，雨滴不会在同一高度\n    id=floor(st);\n    st=fract(st)-0.5;\n    \n    t+=fract(sin(id.x*76.34+id.y*1457.3)*768.63)*6.283;//使各个雨滴不同时落下;\n    float y=-sin(t+sin(t+sin(t)*0.5))*.43;//缓慢落下又快速上升，0.43使其不离开边缘\n    vec2 p1=vec2(0.,y);//只做y轴运动\n    vec2 o1=(st-p1)/a;//st/a恢复圆形，-p1为运动\n    float d=length(o1);\n    \n    float m1=S(.07,.0,d);//遮罩，即雨滴形状\n    \n    vec2 o2=(fract(uv*a.x*vec2(1.,2.))-.5)/vec2(1.,2.);//从三个小雨滴变成六个再恢复圆形\n    d=length(o2);\n    \n    float m2=S(.3*(.5-st.y),.0,d)*S(-.1,.1,st.y-p1.y);//拖尾的雨滴，第一个s雨滴越往下越大，第二个s跟随大雨滴后面 \n    return vec2(m1*o1*30.+m2*o2*10.);//乘以偏移量\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float t = iTime*.05+m.x;\n    \n    vec3 camPos = vec3(.5, 0.2, 0.);\n    vec3 lookAt = vec3(.5, 0.2, 1.);\n    \n    vec2 rainDistort=Rain(uv*5.,t)*.5;\n    rainDistort+=Rain(uv*7.,t)*.5;\n    \n    uv.x+=sin(uv.y*70.)*.003;\n    uv.y+=sin(uv.x*170.)*.001;\n    \n    ray r = GetRay(uv-rainDistort*.5, camPos, lookAt, 2.);\n \n    \n    \n    vec3 col = Streetlights(r, t);\n    col += Headlights(r, t);\n    col += Taillights(r, t);\n    col += Envlights(r,t);\n    \n    col += (r.d.y+.25)*vec3(.2,.1,.5);//天空渐变\n    \n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}