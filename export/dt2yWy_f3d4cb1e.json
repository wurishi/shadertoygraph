{"ver":"0.1","info":{"id":"dt2yWy","date":"1692249408","viewed":31,"name":"colored lights","username":"AntonJeva","description":"a sphere lit by three light sources with one color each.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100.\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n#define ORANGE vec3(.7,.25,.1)\n#define CYAN vec3(.1,.3,.75)\n#define GREEN vec3(.12,.7,.25)\n\n//Camera defined by ray origin and ray direction\nstruct Camera {\n    vec3 ro;\n    vec3 rd;\n};\n\nCamera GetCamera(vec3 ro, vec3 lookat, vec2 uv) {\n\n    //forward, right, up vector\n    vec3 f = normalize(lookat - ro);\n    vec3 r = cross(vec3(0,1,0), f);\n    vec3 u = cross(f, r);\n    \n    //center and intersection with camera plane\n    vec3 c = ro + f;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    //return value\n    Camera o;\n    o.ro = ro;\n    o.rd = i - ro;\n    \n    return o;\n}\n\n//distance to sphere at 0,0,0 with size 1\nfloat GetDist(vec3 p) {\n    return length(p)-1.;\n}\n\n//standard ray march\nfloat RayMarch(Camera c) {\n    float d0 = 0.;\n    for(float i = 0.; i < MAX_STEPS; i++) {\n        float dS = GetDist(c.ro + c.rd * d0);\n        if (dS < SURF_DIST || d0 > MAX_DIST) break;\n        d0 += dS;\n    }\n    return d0;\n}\n\n//standard normal\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0, .01);\n    \n    vec3 n = normalize(GetDist(p)-vec3(\n                GetDist(p-e.yxx),\n                GetDist(p-e.xyx),\n                GetDist(p-e.xxy)\n                ));\n\n    return n;\n}\n\nvec3 GetLight(vec3 p) {\n    //light positions and vectors\n    vec3 orangePos = vec3(2, 4, 1);\n    vec3 ol = normalize(orangePos-p);\n    vec3 cyanPos = vec3(-1, 4, 2);\n    vec3 cl = normalize(cyanPos-p);\n    vec3 greenPos = vec3(-2, 4, -1);\n    vec3 gl = normalize(greenPos-p);\n    \n    vec3 n = GetNormal(p);\n    \n    //gray if ray march missed\n    if (GetDist(p) > SURF_DIST) return vec3(.1);\n    \n    //dots products, squared to reduce brightness\n    float cyan = max(dot(n, cl),0.);\n    float orange = max(dot(n, ol),0.);\n    float green = max(dot(n, gl),0.);\n    cyan *= cyan;\n    orange *= orange;\n    green *= green;\n    return cyan*CYAN + orange*ORANGE + green*GREEN;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //camera\n    vec3 ro = vec3(sin(iTime), 1.5, cos(iTime))*3.;\n    vec3 lookat = vec3(0, 0, 0);\n    Camera c = GetCamera(ro, lookat, uv);\n    \n    //color\n    vec3 col = GetLight(ro+c.rd*RayMarch(c));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}