{"ver":"0.1","info":{"id":"4ttXDr","date":"1479458519","viewed":246,"name":"raymarch_bulb_plasma","username":"balkhan","description":"mandelbulb distance estimator taken from syntopia (tweaked a bit) : http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define I_MAX\t250\n#define E_BULB\t0.001\n#define E_SPHI\t0.01\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat\tbulb(vec3 pos);\nfloat\tde(vec3 pos);\nmat4\tlookat(vec3 eye, vec3 target, vec3 up);\nvec2 \tcmult(vec2 a, vec2 b);\nvec4\tmarch(vec3 pos, vec3 dir);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4\tcol = vec4(0.0);\n\tvec3\tdir = normalize(vec3(fragCoord.xy - iResolution.xy/2.0, -iResolution.y));\n    vec3\tpos = vec3(-2.0, 0.0, 2.0);\n    mat4\tlook = lookat(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    dir = vec3(dot(dir, look[0].xyz), dot(dir, look[1].xyz), dot(dir, look[2].xyz));\n   \tvec4 inter = (march(pos, dir));\n    if (inter.w >= float(I_MAX))\n\t    col.xyz = inter.xyz;\n    else\n        col.xyz = vec3(1.0-inter.w/float(I_MAX));\n   \tfragColor = col;\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\tstep = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = bulb(p);\n        //dist.x = de(p);\n        dist.y += dist.x;\n        if (dist.x < E_BULB)\n           break;\n        step.x += exp(-abs(dist.y + 30.0 * (dist.x-(p.x*p.z/1.0)) ));\n        step.y += exp(-abs(dist.y + 30.0 * (dist.x-(p.x*p.z/2.0)) ));\n        step.z += exp(-abs(dist.y + 30.0 * (dist.x-(p.x*p.z/1.5)) ));\n        step.w++;\n    }\n    return (step);\n}\n\nfloat\tbulb(vec3 pos) // brot3D de\n{\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10 ; i++)\n    {\n\t\tr = length(z);\n\t\tif (r > 15.0)\n            break;\n\t\tfloat theta = atan(sin(z.z + iTime/5.0) * z.z/r, z.z*r);\n\t\tfloat phi = atan(z.y, z.x);\n\t\tdr =  pow(r, 8.0 - 1.0) * 8.0 * dr + 1.50;\n\t\tfloat zr = pow(r, 8.0);\n\t\ttheta = theta * 8.0;\n\t\tphi = phi * 8.0 + 30.0 * cos(iTime/3.0);\n        //theta = cmult(vec2(theta), vec2(r,1.0/r)).y;\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos + r/dr;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat de(vec3 pos) // sphere de\n{\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10 ; i++)\n    {\n\t\tr = length(z);\n\t\tif (r > 15.0)\n            break;\n\t\tfloat theta = atan(z.z/r, z.z*r);\n\t\tfloat phi = atan(z.x - z.z, z.y - z.z);\n\t\tdr =  pow(r, 5.0-1.0)*7.0*dr + 1.0;\n\t\tfloat zr = pow(r, 5.0);\n\t\ttheta = theta*5.0;\n\t\tphi = phi*5.0+5.0*cos(iTime/3.0);\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z.xy = cmult(vec2(z.xy),vec2(z.y/dr, z.y/dr)); // inversion try\n\t\tz += pos;\n\t}\n\treturn 0.4*log(r)*r/dr;\n}\n\nmat4\tlookat(vec3 e, vec3 ta, vec3 up)\n{\n    vec3 z = normalize(e - ta);    \n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);     \n\n    mat4 orientation = mat4(\n       \t\t\t\t\t\tx.x, y.x, z.x, 0.0,\n       \t\t\t\t\t\tx.y, y.y, z.y, 0.0,\n       \t\t\t\t\t\tx.z, y.z, z.z, 0.0,\n       \t\t\t\t\t\t0.0, 0.0, 0.0, 1.0);\n\n    mat4 translation = mat4(\n         \t\t\t\t\t1.0, 0.0, 0.0, 0.0,\n         \t\t\t\t\t0.0, 1.0, 0.0, 0.0, \n         \t\t\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t\t\t\t\t-e.x,-e.y,-e.z, 1.0);\n\n    return (orientation * translation);\n}\n\nvec2 \tcmult(vec2 a, vec2 b)\n{\n    return (vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x));\n}\n","name":"Image","description":"","type":"image"}]}