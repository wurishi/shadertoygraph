{"ver":"0.1","info":{"id":"stlyW8","date":"1647949263","viewed":222,"name":"The Arrival","username":"_pwd_","description":"...it only appears at night","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","metaballs","stars","moon","lensflare","artifacts","abstractwater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\n//\n// The Arrival\n//\n// The initial idea was a composition of an nightly scenery - mixing abstract water, moonlight, stars\n// horizon and lensflares together with even more abstract moving forms...\n// Well - seeing what it all turned out - it looks more like my tribute to late 80s airbrush culture\n// but still I like it a lot...\n//\n//\n// This shader shall exist in its/this form on shadertoy.com only \n// You shall not use this shader in any commercial or non-commercial product, website or project. \n// This shader is not for sale nor can´t be minted (ecofriendly or not) as NFT.\n//\n//\n// Related examples\n//\n// distance function(s):\n// https://iquilezles.org/articles/distfunctions\n// xTr1m / BluFlame´s lunaquatic:\n// https://github.com/joric/pyshadertoy/blob/master/lunaquatic.glsl\n// Yusef28´s lensflares:\n// https://www.shadertoy.com/view/Xlc3D2 \n// \n//\n//\n\n\n#define pi 3.14159265359\n\nvec4 Y;\nvec3 circColor  = vec3(0.9, 0.2, 0.1);\nvec3 circColor2 = vec3(0.3, 0.1, 0.9);\nvec4 arrivalPos;\nvec3 lightPos, lightDir, ro, rd;\nfloat FAR, eps=0.0001;\n\nfloat saturate(float x) { return clamp(x,0.0,1.0); }\nfloat ftime(float t, float s, float e) { return (t-s)/(e-s); }\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// x,y,z rotation(s)\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 rotateY(vec3 v, float x)\n{\n    return vec3(\n        cos(x)*v.x - sin(x)*v.z,\n        v.y,\n        sin(x)*v.x + cos(x)*v.z\n    );\n}\n\nvec3 rotateX(vec3 v, float x)\n{\n    return vec3(\n        v.x,\n        v.y*cos(x) - v.z*sin(x),\n        v.y*sin(x) + v.z*cos(x)\n    );\n}\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0,+1.0);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// randomness and hash´ing like a pro\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat rnd(vec2 x) {\n    int n = int(x.x * 40.0 + x.y * 6400.0);\n    n = (n << 13) ^ n;\n    return 1.0 - float( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0;\n}\n\nfloat rnd(float w) {\n    float f = fract(sin(w)*1000.);\n    return f;   \n}\n\nfloat smoothrnd(vec2 x) {\n    x = mod(x,1000.0);\n    vec2 a = fract(x);\n    x -= a;\n    vec2 u = a*a*(3.0-2.0*a);\n    return mix(\n    mix(rnd(x+vec2(0.0)),rnd(x+vec2(1.0,0.0)), u.x),\n    mix(rnd(x+vec2(0.0,1.0)),rnd(x+vec2(1.0)), u.x), u.y);\n}\n\nfloat noise(vec2 uv){\n    vec3 p3  = fract(vec3(uv.xyx) * .1831);\n    p3 += dot(p3, p3.yzx + 339.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Converting from [-1,1] to [0,1]\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat norm(float x)\n{\n    return x * 0.5 + 0.5;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// generate animated caustics and calculate water \"waves\"\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat caustic(float u, float v, float t)\n{\n    return pow((\n    norm(sin(pi * 2.0 * (u + v + Y.z*t))) +\n    norm(sin(pi       * (v - u - Y.z*t))) +\n    norm(sin(pi       * (v     + Y.z*t))) +\n    norm(sin(pi * 3.0 * (u     - Y.z*t)))) * 0.3, 2.0);\n}\n\nfloat height(vec2 x) {\n    float maxV = Y.z;\n    float l = mix(1., max(0., arrivalPos.w - arrivalPos.y), 1.0 - ((maxV > 0.0 && length(x - arrivalPos.xz) < maxV) ? 1.0 : 0.0)) /\n            pow(1./max(0., 1.0-length(arrivalPos.xz-x)*0.8), 2.0);\n    x += length(x-ro.xy);\n    x *= min(length(x-ro.xy)*5.0, 4.0);\n\n    return    caustic(x.x+Y.z*0.75, x.y*0.5, 0.3) * 0.006 +\n            caustic(x.x*0.1+Y.z*0.2, x.y*0.1, 0.02) * 0.125 -\n            0.15;\n}\n\nvec3 getWaterNormal(vec3 p) {\n    return normalize(vec3(\n        caustic(p.x * 160.0 - 12.0 * cos(10.0 * p.z), p.z * 140.0, 4.0),\n        8.0,\n        caustic(p.z * 160.0 - 12.0 * sin(10.0 * p.x), p.x * 140.0, 4.0)) * 2.0 - 1.0);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// raymarch the terrain function, returns the distance from the ray origin to the \n// terrain voxel. This function was originally adopted from an implementation by IQ\n//////////////////////////////////////////////////////////////////////////////////////\n\nint traceTerrain( vec3 ro, vec3 rd, float maxt, out float depth ) {\n    float lh, ly, delt=0.0;\n    for ( float t = 0.1; t < maxt; t += delt ) {\n          \n          ro += rd * delt;\n          depth = height(ro.xz);\n\n          if ( ro.y <= depth ) {\n               depth = t - delt + delt*(lh-ly)/(ro.y-depth+lh-ly);\n               return 1;\n          }\n          \n          lh = depth;\n          ly = ro.y;\n\n          delt = 0.002 + (t/(40.0 * clamp(rd.y+1.0,0.0,1.0))); //detail level\n    }\n    return 0;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Converting from [-1,1] to [0,1]\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 calculateSkySub(vec3 rd) {\n    return  norm(smoothrnd(abs(rd.xy*rd.z+rd.y*2.0))) * vec3(0.15) +\n            norm(smoothrnd(1.5*abs(rd.xy*rd.z+rd.y+10.0)))* vec3(0.15) +\n            norm(smoothrnd(2.5*abs(rd.xy*rd.z+rd.y+20.0)))* vec3(0.15);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// lensflare(s) circles and shapes\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat regShape(vec2 p, int N) {\n    float f;\n    float a=atan(p.x,p.y)+.2;\n    float b=6.28319/float(N);\n    f=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));\n    return f;\n}\n\nvec3 circle(vec2 p, float size, float decay, vec3 color,vec3 color2, float dist, vec2 pos) {\n    float l = length(p + pos*(dist*4.))+size/2.;\n    float l2 = length(p + pos*(dist*4.))+size/3.;\n    \n    float c = max(00.01-pow(length(p + pos*dist), size*1.4), 0.0)*50.;\n    float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*30.), 0.0)*3.;\n    float c2 =  max(0.04/pow(length(p-pos*dist/2. + 0.09)*1., 1.), 0.0)/20.;\n    float s = max(00.01-pow(regShape(p*5. + pos*dist*5. + 0.9, 6) , 1.), 0.0)*5.;\n    \n    color = 0.5+0.5*sin(color);\n    color = cos(vec3(0.44, .24, .2)*8. + dist*4.)*0.5+.5;\n    vec3 f = c*color ;\n    f += c1*color;\n    \n    f += c2*color;  \n    f +=  s*color;\n    return f-0.01;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// calculate sky: horizon´s color, moon, stars, lensflares\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 calculateSky(vec3 ro, vec3 rd) {\n    \n    vec3 col = vec3(0.);\n    vec3 sundir = normalize( vec3(0.15, .225, 1.) );\n    \n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n  \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.15, .0) * exp(-rd.y*9.); // Red / Green \n    col += vec3(.3, .5, .9) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; // Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n    \n    col += vec3(1.0, .8, .55) * pow( max(dot(rd,sundir),0.), 15. ) * .6; // Sun\n    col += pow(max(dot(rd, sundir),0.), 150.0) *.15;\n\n    for( float i=0.;i<10.;i++ ) {\n        \n         col += circle(Y.xy, pow(rnd(i*2000.)*1.8, 2.)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, vec2(0.5,0.5));\n    }\n\n\n    vec3 sky = vec3(0.);\n\n   \n    float moonValue = max(0.,dot(sundir,rd));\n    float moonCircle = pow(moonValue,2000.)*5.;\n    moonCircle = clamp(moonCircle,0.,1.);\n    sky = mix(sky, vec3(0.95,0.95,1.),moonCircle); \n    //light\n    sky = mix(sky, vec3(0.2,0.95,1.), pow(moonValue,100.)*0.1);\n    //less light\n    sky = mix(sky, vec3(0.5,0.5,1.), pow(moonValue,20.)*0.1);\n\n    if( Y.y > 0.65 ) {\n\t\tvec3 rds = rd;\n\t\t\n\t\tfloat v = 1.0/( 2. * ( 1. + rds.z ) );\n\t\tvec2 xy = vec2(rds.y * v, rds.x * v);\n\t\tfloat s = noise(rds.xz*134.);\n\t\ts += noise(rds.xz*370.);\n\t\ts += noise(rds.xz*870.);\n\t\ts = pow(s,19.0) * 0.00000001 * max(rd.y, 0.0 );\n\t\tif (s > 0.1) {\n\t\t\tvec3 backStars = vec3((1.0-sin(xy.x*20.0+Y.z*13.0*rds.x+xy.y*30.0))*.5*s,s, s); \n\t\t\tcol += backStars;\n\t\t}\n    }\n    col = mix( col, sky, 0.45 );\n\n    rd.xy += ro.xy*eps;\n    col += (calculateSkySub(normalize(rd + vec3(sin(Y.z*0.1),0.0,cos(Y.z*0.1)) * 0.1)*3.0) +\n              calculateSkySub(normalize(rd + vec3(sin(Y.z*0.1),0.0,cos(Y.z*0.1)) * 0.2)*5.0)*0.6 +\n              calculateSkySub(normalize(rd + vec3(sin(Y.z*0.1),0.0,cos(Y.z*0.1)) * 0.4)*7.0)*0.1 -\n              calculateSkySub(normalize(rd + vec3(sin(Y.z*0.2),0.0,0) * 0.5))*1.5) * saturate(rd.y+0.1);\n\n\n    return col;\n\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Smooth min by IQ -> https://iquilezles.org/articles/smin\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat smin( float a, float b ) {\n    float k = 0.95;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Displacement\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat displace(vec3 p) {\n    return ((cos(1.1*p.x)*sin(1.4*p.x)*sin(1.2*p.y))+cos(0.1))* sin(Y.z);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Tori\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat torus1(vec3 p) {\n\t\t\n\treturn length(vec2(length(p.xy) -14.24, p.z)) -1.19;\n\t\t\n}\n\nfloat torus(vec3 p) {\n\t\t\n\treturn length(vec2(length(p.xz) -14.24, p.y)) -1.19;\n\t\t\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// sdLink\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdLink( vec3 p, float le, float r1, float r2 ) {\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// sdOctahedron\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdOctahedron( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// sdSphere\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdSphere (in vec3 p, in float r) {\n    return length (p) - r;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// combine\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat opCombine (in float d1, in float d2, in float r) {\n    float h = saturate (.5 + .5 * (d2 - d1) / r);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// metaballs\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat metaballs (in vec3 p, in float factor) {\n    float r1 = factor * .1 + .3 * (.5 + .5 * sin (2. * iTime));\n    float r2 = factor * .15 + .2 * (.5 + .5 * sin (3. * iTime));\n    float r3 = factor * .2 + .2 * (.5 + .5 * sin (4. * iTime));\n    float r4 = factor * .25 + .1 * (.5 + .5 * sin (5. * iTime));\n\n    float t = 2. * iTime;\n    vec3 offset1 = vec3 (-.1*cos(t), .1, -.2*sin(t));\n    vec3 offset2 = vec3 (.2, .2*cos(t), .3*sin(t));\n    vec3 offset3 = vec3 (-.2*cos(t), -.2*sin(t), .3);\n    vec3 offset4 = vec3 (.1, -.4*cos(t), .4*sin(t));\n    vec3 offset5 = vec3 (.4*cos(t), -.2, .3*sin(t));\n    vec3 offset6 = vec3 (-.2*cos(t), -.4, -.4*sin(t));\n    vec3 offset7 = vec3 (.3*sin(t), -.6*cos(t), .6);\n    vec3 offset8 = vec3 (-.3, .5*sin(t), -.4*cos(t));\n\n    float ball1 = sdSphere (p + offset1, r4);\n    float ball2 = sdSphere (p + offset2, r2);\n\tfloat metaBalls = opCombine (ball1, ball2, r1);\n\n    ball1 = sdSphere (p + offset3, r1);\n    ball2 = sdSphere (p + offset4, r3);\n\tmetaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r2);\n\n    ball1 = sdSphere (p + offset5, r3);\n    ball2 = sdSphere (p + offset6, r2);\n\tmetaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r3);\n\n    ball1 = sdSphere (p + offset7, r3);\n    ball2 = sdSphere (p + offset8, r4);\n\tmetaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r4);\n\n    return metaBalls;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// distance field\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat isoSurface(vec3 p) {\n    \n    float b = 0.4;\n    p = rotateX(rotateY(rotateX(rotateY(p - arrivalPos.xyz, 2.0*Y.z), 2.0*Y.z), b*sin(2.0*2.0+2.0*p.y)), b*sin(2.0*Y.z+2.0*p.x));\n    \n    vec3 q  = p;\n    vec3 mb = p;\n    \n    q  *= 8.0;\n    p  *= 20.0;\n    mb *= 1.9;\n    \n    float dsp  = displace(q);\n    float d    = torus(p);\n    float d1   = torus1(p);\n    float octa = sdOctahedron( p, 10.0 );\n    float sd   = sdLink(p.zyx, 12.5, 12.0, 0.9 );\n    \n    return min( smin (sd, sd + dsp * 1.2), smin( d, min(d1, mix( octa + dsp, metaballs(mb, 1.0 ) + dsp * 0.05, sin(1.0+cos(Y.z)*0.5)*0.5+0.55))));\n}\n\nfloat traceIso(vec3 ro, vec3 rd, float mint, float maxt, float s)\n{\n    float lt, liso, exact, delt = (maxt-mint)/s;\n\n    for (float t = mint; t < maxt; t += delt)\n    {\n        vec3 p = ro + t * rd;\n        float iso = isoSurface(p);\n        if (iso <= 0.0)\n        {\n            for(int i = 0; i < 9; i++)\n            {\n                exact = (lt + t) / 2.0;\n                if (isoSurface(ro + exact * rd) < 0.0) t = exact;\n                else lt = exact;\n            }\n            return exact;\n        }\n\n        lt = t;\n        liso = iso;\n    }\n\n    return FAR;\n}\n\n\nvec3 trace(vec3 ro, vec3 rd) {\n    float upperPlane = (0.1-ro.y) / rd.y;\n    float finalDepth = 200.0;\n    vec3 color = calculateSky(ro, rd);\n    if (rd.y < -0.01 && traceTerrain(ro+rd*upperPlane, rd, finalDepth, finalDepth)>0) // prevent endless stuff and other funny shit\n    {\n        finalDepth += upperPlane;\n        vec3 pos = ro+rd*finalDepth;\n        vec3 normal = normalize(normalize(\n                                        vec3(\n                                            height(pos.xz - vec2(eps, 0.0)) - height(pos.xz + vec2(eps, 0.0)),\n                                            eps*2.0,\n                                            height(pos.xz - vec2(0.0, eps)) - height(pos.xz + vec2(0.0, eps))\n                                            )\n                                        ) +\n                                        (getWaterNormal(pos*0.2)*1.5+getWaterNormal(pos*0.1)) * max(0., 1.0-finalDepth/FAR*7.0)\n                            );\n\n        color = max(0., dot(normal, lightDir)    // diffuse\n                + pow(max(0., dot(normal,  normalize(lightDir-rd))), 1.5) // specular\n                ) *\n                calculateSky(pos, reflect(rd, normal) );\n\n\n        // depth fog\n        color = mix(    color,\n                        calculateSky(ro, rd),\n                        saturate(finalDepth/FAR*1.6 + saturate(dot(normalize(normal+rd*.2), rd)))\n                    ); // sky refl and fog\n    }\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    FAR = 9.0;\n    \n    Y.xy = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    Y.z = iTime;\n\n    rd = normalize(vec3(Y.xy - 0.5, 1.0));\n\n\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy,iMouse.z);\n\t\n \trd = rotate_x(rd,mouse.y / pi * 0.5 );\n\trd = rotate_y(rd,mouse.x / pi );\n\n\n    arrivalPos = vec4( -0.85, 0.0, 2.1, 0.0);\n    \n    ro = vec3(.0, .25, 0.);\n    float t = Y.z;\n\n    lightPos = vec3(-400.0, 250.0, 1000.0);\n    ro.y -= 0.1;\n    arrivalPos.w = 0.0;\n\n    lightDir = normalize(lightPos-ro);\n\n    float dist = length(ro-arrivalPos.xyz)-1.0;\n    float isoDistance = traceIso(ro, rd, dist, dist+2.0, 99.0);\n    if (isoDistance < FAR)\n    {\n        ro += isoDistance * rd;\n        vec3 n = normalize(vec3(\n                isoSurface(vec3(ro.x-eps, ro.y, ro.z))-isoSurface(vec3(ro.x+eps, ro.y, ro.z)),\n                isoSurface(vec3(ro.x, ro.y-eps, ro.z))-isoSurface(vec3(ro.x, ro.y+eps, ro.z)),\n                isoSurface(vec3(ro.x, ro.y, ro.z-eps))-isoSurface(vec3(ro.x, ro.y, ro.z+eps))));\n        rd = reflect(rd, n);\n    }\n\n    fragColor = vec4(trace(ro, rd) * 1.65,1.0);\n}","name":"Image","description":"","type":"image"}]}