{"ver":"0.1","info":{"id":"Xl2BRR","date":"1515080362","viewed":3235,"name":"The red hiker","username":"iapafoto","description":"the red walker","likes":79,"published":1,"flags":0,"usePreview":0,"tags":["walk","human","walkman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------\n// Created by sebastien durand - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n\n// Change this to improve quality (3 is good)\n#define ANTIALIASING 1\n\n//#define WITH_SHADOW\n#define WITH_AO\n\n// Isosurface Renderer\n#define g_traceLimit 64\n#define g_traceSize .004\n\n#define STAR_VOXEL_STEPS 20\n#define STAR_VOXEL_STEP_SIZE 3.\n#define STAR_RADIUS .02\n#define ZERO (min(0, iFrame))\n\nfloat gTime;\n\n//---------------------------------------------------------------------\n//    Animation\n//---------------------------------------------------------------------\n\n//                       Contact           Down               Pass               Up      \n\n\nvec3[9] HEAD = vec3[9](  vec3(50,24,0),    vec3(73,30,0),     vec3(94,20,0),     vec3(117,15,0),  \n                         vec3(85+50,24,0), vec3(85+73,30,0),  vec3(85+94,20,0),  vec3(85+117,15,0), vec3(168+50,24,0));\n\nvec3[9] SHOULDER = vec3[9](vec3(44,47,16),   vec3(66,53,16),    vec3(91,43,16),    vec3(115,38,16), \n                         vec3(85+51,50,16),vec3(85+73,55,16), vec3(85+91,43,16), vec3(85+111,37,16), vec3(168+44,47,16));\n\nvec3[9] ELBOW = vec3[9]( vec3(25,64,25),   vec3(46,67,25),    vec3(88,70,25),    vec3(120,65,25),\n                         vec3(85+54,62,25),vec3(85+87,67,25), vec3(85+91,71,25), vec3(85+92,61,25), vec3(168+25,64,25));\n\nvec3[9] WRIST = vec3[9](vec3(20,85,15),   vec3(35,76,20),    vec3(88,100,25),   vec3(128,89,25), \n                         vec3(164,85,15),  vec3(85+102,81,20),vec3(85+88,98,25),vec3(85+82,81,20), vec3(168+20,85,15));\n\nvec3[9] HIP = vec3[9](vec3(42,90,10),  vec3(62,95,10.),   vec3(83,88,10),   vec3(107,83,10),  \n                         vec3(127,92,10), vec3(147,94,10.),  vec3(168,91,10),  vec3(192,85,10), vec3(42+168,90,10));\n\nvec3[9] KNEE = vec3[9]( vec3(29,118,7),  vec3(48,120,8),   vec3(97,117,10),  vec3(130,107,10), \n                         vec3(144,120,7), vec3(167,118,7),  vec3(167,118,7),  vec3(181,111,7), vec3(168+29,118,7));\n\nvec3[9] ANKLE=vec3[9](vec3(5,134,5),   vec3(22,132,6),   vec3(71,122,10),  vec3(113,127,10), \n                         vec3(162,146,5), vec3(164,146,5),  vec3(164,146,5),  vec3(168,137,5), vec3(168+5,134,5));\n\nvec3[9] FOOT = vec3[9](  vec3(14,150,10), vec3(16,150,10),  vec3(63,139,10),  vec3(119,143,10), \n                         vec3(178,139,10),vec3(182,150,10), vec3(182,150,10), vec3(182,150,10), vec3(168+14,150,10));\n\n\nvec3 shoulder1, elbow1, wrist1, head,\n     shoulder2, elbow2, wrist2;\nvec3 foot1, ankle1, knee1, hip1,\n     foot2, ankle2, knee2, hip2;\n\nmat2 rot, rot2;\n\n// Interpolate pos of articulations\nvec3 getPos(vec3 arr[9], int it, float kt, float z) {\n    it = it%8;\n    vec3 p = mix(arr[it], arr[it+1], kt);\n\treturn .02*vec3(p.x+floor(gTime/8.)*168., 150.-p.y, p.z*z);\n}\n\n\n//---------------------------------------------------------------------\n//    HASH functions (iq)\n//---------------------------------------------------------------------\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nvec3 hash33( const in vec3 p) {\n    return fract(vec3(\n        sin( dot(p,    vec3(127.1, 311.7, 758.5453123))),\n        sin( dot(p.zyx,vec3(127.1, 311.7, 758.5453123))),\n        sin( dot(p.yxz,vec3(127.1, 311.7, 758.5453123))))*43758.5453123);\n}\n\n\n//---------------------------------------------------------------------\n//    Palette\n// https://www.shadertoy.com/view/4dsSzr\n//---------------------------------------------------------------------\nvec3 heatmapGradient(float t) {\n\treturn clamp((pow(t, 1.5) * .8 + .2) * vec3(smoothstep(0., .35, t) + t * .5, smoothstep(.5, 1., t), max(1. - t * 1.7, t * 7. - 6.)), 0., 1.);\n}\n\n\n//---------------------------------------------------------------------\n//    Geometry\n//---------------------------------------------------------------------\n\n// Distance from ray to point\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n    //return length(cross(p-ro,rd));\n}\n\n// Distance line / line (must exist simplest way to do this)\nfloat distanceLineLine(vec3 ro1, vec3 u, vec3 ro2, vec3 v) {\n    vec3 w = ro1 - ro2;\n    float a = dot(u,u), b = dot(u,v), c = dot(v,v),\n          d = dot(u,w), e = dot(v,w),\n          D = a*c - b*b,\n     \t  sc = (b*e - c*d) / D,\n     \t  tc = (a*e - b*d) / D;\n    // get the difference of the two closest points\n    vec3 dP = w + (sc * u) - (tc * v);\n    return sc>0. ? length(dP) : 1e3;   // return the closest distance\n}\n\n\n//---------------------------------------------------------------------\n//      Start field (iterate in a 3d grid)\n//---------------------------------------------------------------------\n\nvec4 renderStarField(in vec3 ro, in vec3 rd, in float tmax) { \n    vec3 ros = ro;\n    ros /= STAR_VOXEL_STEP_SIZE;\n\tvec3 offset, id,\n         pos = floor(ros),\n\t     mm, ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ros + .5 + rs*.5) * ri;\n    float dint, d = 0.;\n    vec4 col = vec4(0),\n         sum = vec4(0);\n    \n\tfor( int i=ZERO; i<STAR_VOXEL_STEPS; i++ ) {\n        id = hash33(pos);\n        offset = clamp(id+.1*cos(id+(id.x)*iTime),STAR_RADIUS, 1.-STAR_RADIUS);\n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if (dint>0.&& dint*STAR_VOXEL_STEP_SIZE<tmax) {\n            col.rgb = heatmapGradient(.4+id.x*.6);\n            col = vec4(.6+.4*col.rgb, 1.)*(1.-smoothstep(STAR_RADIUS*.5,STAR_RADIUS,d));\n            col.a *= smoothstep(float(STAR_VOXEL_STEPS),0.,dint);\n            col.rgb *= col.a/dint;\t\t\t\t                                \n            sum += (1.-sum.a)*col;\n            if (sum.a>.99) break;\n        }\n\t\tmm = step(dis, dis.yxy) * step(dis, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\treturn sum;\n}\n\n\n//---------------------------------------------------------------------\n//   Modeling Primitives\n//   [Inigo Quilez] https://iquilezles.org/articles/distfunctions\n//---------------------------------------------------------------------\n\nbool cube(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf) { //, out vec3 n) {\n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n//\tn = -sign(rd)*step(a.yzx,a)*step(b.zxy,b);\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z);\n\treturn tn>0. && tn<tf;\n}\n\nfloat sdCap(vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCap2(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.))-r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat sdPlane(vec3 p, vec3 n) {\n  // n must be normalized\n  return dot(p,n);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\n\n//---------------------------------------------------------------------\n//    Man + Ground distance field \n//---------------------------------------------------------------------\nfloat mapGround(vec3 pos){\n    vec3 te = textureLod(iChannel0, pos.xz*.1,1.).rgb;\n    return pos.y+.3*length(te);\n}\n\nfloat map(in vec3 pos){\n    \n    const float r1= .15, r2 = .1, r3= .1;\n    float d = 100.;\n    \n    // Leg 1\n    d = min(d, sdCap2(pos, foot1, ankle1, r2,r1));\n    d = min(d, sdCap(pos, ankle1, knee1, r1));\n    d = min(d, sdCap2(pos, knee1, hip1, r1,r2));\n \n    // Foot1 flat part - vector base linked to leg 1\n    vec3 v2 = normalize(knee1 - ankle1);\n    vec3 v1 = normalize(ankle1 - foot1-v2*.1);\n    vec3 v3 = cross(v1,v2);\n    d = max(d, -sdPlane(pos-ankle1+v2*.1, -cross(v1,v3))); \n    \n    // Leg 2\n    float d2 = sdCap2(pos, foot2, ankle2, r2,r1);\n    d2 = min(d2, sdCap(pos, ankle2, knee2, r1));\n    d2 = min(d2, sdCap2(pos, knee2, hip2, r1,r2));\n\n    // Foot2 flat part - vector base linked to leg 2\n    v2 = normalize(knee2 - ankle2);\n    v1 = normalize(ankle2 - foot2-v2*.1);\n    v3 = cross(v1,v2);\n    d2 = max(d2, -sdPlane(pos-ankle2+v2*.1, -cross(v1,v3))); \n\n    d = min(d, d2);\n    \n    vec3 ep0 = mix(shoulder1,shoulder2,.5),\n         ha0 = mix(hip1,hip2,.5);\n\n    // Head\n    d = min(d, sdCap2(pos, head - vec3(0,.17,0), head + vec3(-.02,.11,0),.13,.16));\n    \n    // Arm 1\n    v1 = normalize(wrist1-elbow1);\n    d = min(d, sdCap(pos, shoulder1, elbow1, r2));\n    d = min(d, sdCap2(pos, elbow1, wrist1-.05*v1, r2,r3));\n\n    // Hand1 - fix vector base to harm 1\n    v3 = -normalize(cross(v1,normalize(wrist1-shoulder1)));\n    v2 = -cross(v1,v3);\n    vec3 c = wrist1-v3*.06-v1*.12;\n    \n\t// Finders 1\n    d2 = sdCap2(pos, c, wrist1+.1*(v2+v1+v3), .013,.033);\n    d2 = min(d2, sdCap2(pos, c, wrist1+.18*(v1+v2*.2), .01,.03));\n    d2 = min(d2, sdCap2(pos, c, wrist1+.2*(v1-v2*.2), .01,.03));\n    d2 = min(d2, sdCap2(pos, c, wrist1+.15*(v1-v2*.6), .01,.026));\n    \n    // Arm 2\n    v1 = normalize(wrist2-elbow2);\n    d = min(d, sdCap(pos, shoulder2, elbow2, r2));\n    d = min(d, sdCap2(pos, elbow2, wrist2-.05*v1, r2,r3));\n    \n    // Hand2 - fix vector base to harm 2\n    v3 = normalize(cross(v1,normalize(wrist2-shoulder2)));\n    v2 = cross(v1,v3);\n    c = wrist2-v3*.06-v1*.12;\n    \n\t// Finders 2     \n    d2 = min(d2, sdCap2(pos, c, wrist2+.1*(v2+v1+v3), .013, .033));\n    d2 = min(d2, sdCap2(pos, c, wrist2+.18*(v1+v2*.2), .01, .03));\n    d2 = min(d2, sdCap2(pos, c, wrist2+.2*(v1-v2*.2), .01, .03));\n    d2 = min(d2, sdCap2(pos, c, wrist2+.15*(v1-v2*.6), .01, .026));\n\n    d = min(d, sdCap(pos, shoulder1, shoulder2, r2));\n   \td = smin(d2, d, .08);\n    \n    // Torso\n    vec3 a = mix(ha0,ep0,.15), b = mix(ha0,ep0,.78);\n    \n    // Neck\n    d = smin(d, sdCap(pos, mix(shoulder1,shoulder2,.5)-vec3(.1,0,0), head-vec3(.08,.1,0), r2*.5),.06);\n    d = smin(d, sdCap2(pos, a, b, .2,.26),.18);\n\n    // Ground\n    vec3 te = textureLod(iChannel0, pos.xz*.1,1.).rgb;\n    d = min(d, pos.y+.3*length(te));\n    \n    // Belt\n    vec3 pos2 = pos-ha0+vec3(0,-.13,.02);\n    pos2.yz *= rot2;\n    d = min(d,mix(d,sdCappedCylinder(pos2, vec2(.28,.08)),.4)); \n \n    // Backpack\n    pos -= ep0;\n    d2 = udRoundBox(pos+vec3(.33,.2,0), vec3(.1,.3,.2), .15); \n    d2 += .005*(smoothstep(.1,.6,cos(51.*(.2*pos.z+.4*pos.x*pos.x+pos.y)))+smoothstep(.4,.9,sin(51.*(.8*cos(1.+pos.z)+.4*pos.x+.2*pos.y))));\n    pos.yz *= rot;\n    d2 = smin(d2,mix(d,sdCappedCylinder(pos.yzx+vec3(.13,.04,.1), vec2(.37,.05)),.75),.05); \n    \n    return min(d2,d);\n}\n\n\n//---------------------------------------------------------------------\n//   Ray marching scene if ray intersect bbox\n//---------------------------------------------------------------------\n\nfloat Trace(in vec3 pos, in vec3 ray, in float start, in float end ) {\n    // Trace if in bbox (TODO: return intersection with ground otherwise)\n    float t, h, tn, tf, dx = gTime*168.*.02/8.+.85;\n    if (cube(pos-vec3(dx,1.35,0), ray, vec3(1.1, 1.7,.7)*2.,  tn, tf)) {\n        end = min(tf, end);\n        t = max(tn, start);\n        for( int i=ZERO; i < g_traceLimit; i++) {\n            h = map( pos+t*ray );\n            if (h < g_traceSize || t > end)\n                return t > end?100. : t;\n            t += h + .002;\n        }\n    }\n\treturn 100.;\n}\n\n\n//---------------------------------------------------------------------\n//   Soft shadows\n//---------------------------------------------------------------------\n\n#ifdef WITH_SHADOW\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat h, res = 1., t = mint;\n    for(int i=ZERO; i<24; i++) {\n\t\th = map( ro + rd*t );\n        res = min( res, 8.*h/t );\n        t += clamp( h, .05, .20 );\n        if( h<.01 || t>tmax ) break;\n    }\n    return clamp( res, .0, 1.);\n}\n#endif\n\n\n//---------------------------------------------------------------------\n//   Ambiant occlusion\n//---------------------------------------------------------------------\n\n#ifdef WITH_AO\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=ZERO; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos =  nor * hr + pos;\n        totao += -(map( aopos )-hr)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\n#endif\n\n\n//---------------------------------------------------------------------\n//   Shading\n//   Adapted from Shane / Iq\n//---------------------------------------------------------------------\n\nvec3 doColor( in vec3 pos, in vec3 rd, in vec3 nor, in vec3 col){\n    vec3 ref = reflect( rd, nor );\n\n    // lighitng   \n#ifdef WITH_AO\n    float occ = calcAO( pos, nor );\n#else\n    float occ = 1.;\n#endif\n    vec3  lig = normalize( vec3(.4, .7, .6) ),\n          hal = normalize( lig-rd );\n    float amb = .4,//clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n          dif = clamp( dot( nor, lig ), 0., 1. ),\n          bac = clamp( dot( nor, normalize(vec3(-lig.x,0.,-lig.z))), 0., 1. )*clamp( 1.-pos.y,0.,1.),\n          dom = smoothstep( -.1, .1, ref.y ),\n          fre = pow( clamp(1.+dot(nor,rd),0.,1.), 2.);\n\n#ifdef WITH_SHADOW\n    dif *= calcSoftshadow( pos, lig, .2, 2.5 );\n#endif\n    float spe = pow( clamp( dot( nor, hal ), 0., 1. ),106.)*\n        dif *\n        (.04 + .96*pow( clamp(1. + dot(hal,rd), 0., 1.), 50. ));\n\n    vec3 lin = .80*dif*vec3(1,.8,.55)*(.3+.7*occ) + \n    \t(.4*amb*vec3(.4,.6,1.) +\n    \t .5*dom*vec3(.4,.6,1.) +\n    \t .5*bac*vec3(.25,.25,.25) +\n    \t .25*fre*vec3(1)) * occ;\n    return col*lin + 10.*spe*vec3(1,.9,.7);\n}\n\n\n//---------------------------------------------------------------------\n//   Calculate normal\n//   From TekF \n//---------------------------------------------------------------------\nvec3 Normal( vec3 ro, vec3 rd, float t) {\n\tfloat pitch = .2 * t / iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = ro+d.xxx, // tetrahedral offsets\n\t     p1 = ro+d.xyy,\n\t     p2 = ro+d.yxy,\n\t     p3 = ro+d.yyx;\n\n\tfloat f0 = map(p0), f1 = map(p1), f2 = map(p2),\tf3 = map(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - ro*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(0., dot(grad,rd ))*rd);\n}\n\nvec3 NormalGround(vec3 ro, vec3 rd, float t) {\n\tfloat pitch = .2 * t / iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = ro+d.xxx, // tetrahedral offsets\n\t     p1 = ro+d.xyy,\n\t     p2 = ro+d.yxy,\n\t     p3 = ro+d.yyx;\n\n\tfloat f0 = mapGround(p0), f1 = mapGround(p1), f2 = mapGround(p2),\tf3 = mapGround(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - ro*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,rd ))*rd);\n}\n\n\n//---------------------------------------------------------------------\n//   Camera\n//---------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr) {\n\tvec3 cw = normalize(ta-ro),\n         cp = vec3(sin(cr), cos(cr),0.),\n         cu = normalize( cross(cw,cp) ),\n         cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n//---------------------------------------------------------------------\n//   Entry point\n//---------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = iTime*6.;\n   \n    // Animation\n    int it = int(floor(gTime));\n    float kt = fract(gTime);\n    \n    float dz = 1.;\n   \n    head = getPos(HEAD, it, kt, dz);\n\n    shoulder1 = getPos(SHOULDER, it, kt, -dz);\n    elbow1 = getPos(ELBOW, it, kt, -dz);\n    wrist1 = getPos(WRIST, it, kt, -dz);\n    \n    foot1 = getPos(FOOT, it, kt, dz);\n    ankle1 = getPos(ANKLE, it, kt, dz);\n    knee1 = getPos(KNEE, it, kt, dz);\n    hip1 = getPos(HIP, it, kt, dz);\n    \n    shoulder2 = getPos(SHOULDER, it+4, kt, dz);\n    elbow2 = getPos(ELBOW, it+4, kt, dz);\n    wrist2 = getPos(WRIST, it+4, kt, dz);\n\n    foot2 = getPos(FOOT, it+4, kt, -dz);\n    ankle2 = getPos(ANKLE, it+4, kt, -dz);\n    knee2 = getPos(KNEE, it+4, kt, -dz);\n    hip2 = getPos(HIP, it+4, kt, -dz);\n\n    \n    float a = -1.5708*.4;\n    rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    a = -.15708;\n    rot2 = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    float dx = it%8 < 4 ? -85.*.02 : +85.*.02; \n    foot2.x += dx;\n    ankle2.x += dx;\n    knee2.x += dx;\n    hip2.x += dx;\n\n    shoulder2.x += dx;\n    elbow2.x += dx;\n    wrist2.x += dx;\n    \n// ------------------------------------\n \n    vec2 q, m = iMouse.xy/iResolution.y - .5;\n     \n\tfloat t, s1, s2, traceStart = .2;\n    \n    vec3 pos, ro, rd, col = vec3(0), colorSum = vec3(0);\n     \n#if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n        float randPix = hash(iTime);\n        vec2 subPix = .4*vec2(cos(randPix+6.28*float(i)/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)/float(ANTIALIASING)));        \n    \t// camera\t\n        q = (fragCoord.xy+subPix)/iResolution.xy;\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n\n        ro = vec3(hip1.x+12.*cos(3.14*(.01*iTime+m.x+.3)),3.+3.*abs(sin(.01314*iTime))+10.*(m.y+.3),hip1.z+12.*sin(3.14*(.01*iTime+m.x+.3)));// .9*cos(0.1*time), .45, .9*sin(0.1*time) );\n        vec3 ta = hip1;\n\n        ta.x +=1.2;\n        ta.y = 1.2;\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera(ro, ta, 0.);\n\n        // ray direction\n        rd = ca * normalize( vec3(p.xy,4.5) );\n\n        float tGround = -ro.y / rd.y;\n        float traceEnd = 100.;//min(tGround,100.);\n        traceStart = 10.;\n        col = vec3(0);\n        vec3 n;\n        t = Trace(ro, rd, traceStart, traceEnd);\n        \n        if (tGround < 0.) \n            tGround = 100.;\n        \n        t = min(t, tGround);\n        \n        if (t<100.) {\n            pos = ro + rd*t;\n            n = pos.y<.02 ? NormalGround(pos, rd, t) : Normal(pos, rd, t);\n            col = doColor(pos, rd, n, pos.y<.02 ? .02*vec3(.8,.8,.9) : vec3(.5,.0,.0));\n            \n        } else {\n            // mysterious line in sky            \n            float time = iTime*.5;\n            float kt = fract(time);\n            vec3 k = -.5+hash33(floor(time)+vec3(0, 2, 112));\n            if (k.y>.25) {\n                float t0 = distanceLineLine(ro,rd, k*200.+vec3(-100,0,0), normalize(k));\n                col = vec3(1,.8,.7) * (1.-smoothstep(0.,.8,t0)) * smoothstep(.53,.01,rd.y+.2*kt);\n                col *= (.5+.5*hash(time))*smoothstep(0.,1., kt);\n            }\n        }\n        \n#if (ANTIALIASING > 1)\t\n        colorSum += col;\n\t}\n    \n    col = colorSum/float(ANTIALIASING);\n#endif\n    \n    // Render star dusts ------------------------\n    vec4 star = renderStarField(ro, rd, t);\n    \t star.rgb += col.rgb * (1. - star.a);\n    \t col = star.rgb;\n         \n    // Post processing stuff --------------------\n    // Fog\n    float f = 50.;\n    col = mix( vec3(.18), col, exp2(-t*vec3(.4,.6,1)/f) );\n\t// Gamma\n    col = pow( col, vec3(.4545) );\n    // Vigneting\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .1); \n    \n\tfragColor =  vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}