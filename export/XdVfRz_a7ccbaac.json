{"ver":"0.1","info":{"id":"XdVfRz","date":"1527482756","viewed":1745,"name":"Ride the Wave","username":"lejeunerenard","description":"Playing with Cosine distortion & perlin noise modulated vertical bars.","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["psychedelic","abstract","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926536\n#define TWO_PI 6.2831853072\n\n#define edge 0.001\n#define totalT 8.0\n#define cosT TWO_PI * mod(iTime, totalT) / totalT\n\nfloat cnoise2 (in vec2);\n\nfloat linez (in vec2 uv) {\n  vec2 q = uv;\n\n  q += 0.1000 * cos( 7.0 * q.yx + 2.0 * cosT);\n  q += 0.0500 * cos(13.0 * q.yx + 3.0 * cosT);\n\n  const float baseHeight = 0.5;\n  const float size = 0.06;\n  const float halfsize = 0.5 * size;\n\n  float c = floor((q.x + halfsize) / size);\n  q.x = mod(q.x + halfsize, size) - halfsize;\n  q.y -= 0.3 * cnoise2(vec2(c, sin(cosT + c)));\n  q.y -= 0.2 * sin(3.0 * cosT + 0.1 * c);\n\n  const float border = 0.2 * size;\n  float v = smoothstep(halfsize - border, halfsize - border - edge, abs(q.x));\n  v *= smoothstep(baseHeight + edge, baseHeight, abs(q.y));\n  return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize to [-1, -1] -> [1, 1]\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(0);\n    \n  \tcolor.r = linez(uv);\n  \tcolor.g = linez(uv + 0.0125);\n  \tcolor.b = linez(uv + 0.0250);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise2(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}","name":"Image","description":"","type":"image"}]}