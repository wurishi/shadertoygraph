{"ver":"0.1","info":{"id":"ltSXWw","date":"1444057670","viewed":161,"name":"RayTraceKlems","username":"Klems","description":"test","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 rgb = texture(iChannel0, uv).rgb / float(iFrame);\n    rgb.r = pow(rgb.r, 1.0/2.3);\n    rgb.g = pow(rgb.g, 1.0/2.3);\n    rgb.b = pow(rgb.b, 1.0/2.3);\n    \n    fragColor.rgb = rgb;\n\tfragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define PI 3.141592654\n#define PHI 1.618033988\n#define FACES 15\n\n// noise functions\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// rotation\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// return true if there is an intersection, false otherwise\n// dist store the distance to get to the plane, negative when're below it\nbool tracePlane( vec3 planePos, vec3 planeNormal, vec3 position, vec3 direction,\n                inout float dist ) {\n    \n    float t = -dot(planeNormal,position-planePos)/dot(planeNormal, direction);\n    \n    if (t > 0.0) {\n        dist = t;\n        return true;\n    }\n    \n    return false;\n    \n}\n\n// trace to the floor\nbool traceFloor( vec3 position, vec3 direction,\n                inout float dist, inout vec3 normal, inout vec3 color ) {\n    float retDist;\n    if ( tracePlane(vec3(0, 0, -2), vec3(0, 0, 1), position, direction, retDist) ) {\n        \n        dist = retDist;\n        normal = vec3(0, 0, 1);\n        vec3 fin = position+direction*retDist;\n        fin.xy *= 0.3;\n        float damier = mod(floor(fin.x)+floor(fin.y), 2.0);\n        color = vec3(0.7) - damier*0.35;\n        return true;\n    }\n    return false;\n}\n\nbool traceSphere(in vec3 solidOrigin, in float radius, in vec3 origin, in vec3 direction,\n                 out float dist, out vec3 normal) { \n    vec3 d = origin - solidOrigin;\n    float b = dot(direction, d);\n    float c = dot(d, d)-radius*radius;\n    float t = b*b-c;\n    if (t > 0.0) {\n        dist = -b-sqrt(t);\n        normal = origin+direction*dist;\n        normal /= radius;\n        return true;\n    }\n    return false;\n}\n\n// polyedre\nbool traceSolid( vec3 position, vec3 direction,\n                inout float dist, inout vec3 normal ) {\n    \n    //return traceSphere( vec3(0,0,0), 1.0, position, direction, dist, normal);\n    \n    float minDist = 99999.9;\n    float maxDist = 0.0;\n    \n    float div = 1.0 / sqrt(float(FACES));\n    \n    bool distSet = false;\n        \n    for (int i = 0 ; i < FACES ; i++) {\n        \n        float angle = 0.0;\n        float xyangle = 0.0;\n        bool first = i == FACES-1;\n\n        if (first) {\n            angle = PI*0.5;\n            xyangle = 0.0;\n        } else {\n            float ii = float(i);\n            float div = float((FACES-1)/2);\n            xyangle = mod(ii, div) / div * PI * 2.0;\n            angle = PI*0.22;\n            if ( ii < div ) {\n                xyangle += PI / div; \n                angle = -angle;\n            }\n        }\n\n        vec3 currNormal = vec3(cos(angle), 0.0, sin(angle));\n        currNormal.xy *= rot( xyangle );\n        currNormal = normalize(currNormal);\n\n        float currDist = 0.0;\n        vec3 currPos = vec3(0)+currNormal;\n        if (first) currPos -= currNormal*0.3;\n\n        tracePlane( currPos, currNormal, position, direction, currDist );\n        if (dot(direction, currNormal) < 0.0) {\n            if (currDist > maxDist) {\n                maxDist = currDist;\n                dist = currDist;\n                distSet = true;\n                normal = currNormal;\n            }\n        } else {\n            if (currDist < minDist) {\n                minDist = currDist;\n                if (!distSet) {\n                    dist = currDist;\n                    normal = currNormal;\n                }\n            }\n        }\n    }\n    \n\treturn minDist > maxDist;\n    \n}\n\n// traverse function\nvoid traverse( inout vec3 position, inout vec3 direction ) {\n    float dist;\n    vec3 normal;\n    \n    if (traceSolid(position, direction, dist, normal)) {\n        \n        vec3 prevDir = direction;\n        \n        // we found a solid, go through\n        direction = refract(direction, normal, 1.2);\n        \n        if ( length(direction) < 0.5 ) {\n            // the ray was reflected, no need to go through the solid\n            direction = reflect(prevDir, normal);\n            position = position+prevDir*dist+normal*0.001;\n           \treturn;\n        } else {\n            \n            // the ray was refracted, go inside the solid\n            position = position+prevDir*dist-normal*0.001;\n            \n            // trace to the surface\n            traceSolid(position, direction, dist, normal);\n            prevDir = direction;\n            direction = refract(direction, -normal, 1.0 / 1.2);\n            if ( length(direction) < 0.5 ) {\n                position = vec3(0);\n                direction = vec3(0);\n            } else {\n                position = position+prevDir*dist+normal*0.001;\n            }\n            \n        }\n        \n    }\n}\n\n// background function\nvec3 getBackground(vec3 v) {\n    if ( dot(v, normalize(vec3(-1, -1, 2))) > 0.99 ) {\n        return vec3(120.0, 110.0, 115.0);\n    } else {\n        return texture(iChannel1, v.xzy).rgb*4.0;\n    }\n    return vec3(0);\n}\n\n// easy random function\nvec2 seed = vec2(0);\nint i = 0;\nfloat rand() {\n    i++;\n    return noise(vec3(float(i)*seed, float(iFrame)));\n}\n\n// random direction on an hemisphere\nvec3 randDir(vec3 normal) {\n    vec3 a = cross(normal, vec3(1, 0, 0));\n    vec3 b = cross(normal, a);\n    float alpha = acos(rand());\n    float theta = rand()*2.0*PI;\n    float rad = sin(alpha);\n    return normal*cos(alpha) + a*cos(theta)*rad + b*sin(theta)*rad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // starting frame\n    if (iFrame == 0) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    \n    // init seed\n    seed = fragCoord;\n    \n    // add a random vector between 0 and 1 to fragCoord, for antialiasing\n    //vec2 noiseV = vec2(\n    //    noise(vec3(fragCoord*23.335, float(iFrame*iFrame))),\n    //    noise(vec3(float(iFrame), fragCoord*112.347)));\n    \n    vec2 noiseV = vec2(rand(), rand());\n    \n\tvec2 uv = (fragCoord.xy+noiseV) / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution .y;\n    \n    vec3 from = vec3(1.0, -8.0, -0.5);\n    vec3 dir = normalize(vec3(uv.x*0.25, 1.0, uv.y*0.25));\n    \n    dir.zy *= rot(0.1);\n    from.zy *= rot(0.1);\n    dir.xy *= rot(0.4);\n    from.xy *= rot(0.4);\n    \n    float dist = 0.0;\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    // go through the solid once\n    traverse(from, dir);\n    \n    if (traceFloor(from, dir, dist, normal, color)) {\n        \n        // we found the floor, now we can compute the light with 1 sample\n        vec3 lightDir = randDir(normal);\n        vec3 lightPos = from+dir*dist+normal*0.001;\n        traverse(lightPos, lightDir);\n        \n        // find the light value\n        vec3 lightValue = getBackground(lightDir)*dot(normal, lightDir);\n        \n        fragColor.rgb = color*lightValue;\n        \n    } else {\n        // or trace to the sky\n        fragColor.rgb = getBackground(dir);\n    }\n\t\n\n    fragColor.a = 1.0;\n    \n    // increment the frame buffer\n    fragColor.rgb += texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    \n}","name":"Buf A","description":"","type":"buffer"}]}