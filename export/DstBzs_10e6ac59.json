{"ver":"0.1","info":{"id":"DstBzs","date":"1697709043","viewed":113,"name":"T-shaped pixelation","username":"hasenpfote","description":"å‡¸\n\n[T-shaped pixelation 2](https://www.shadertoy.com/view/DldyzH)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["pixelation","mosaic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Enables shape vertical flip.\n#define ENABLE_SHAPE_VFLIP\n\n// Allow negative coordinates within the pixelation function.\n//#define ALLOW_NEGATIVE_COORDS\n\n// Enables debugging with negative coordinates.\n//#define DEBUG_NEGATIVE_COORDS\n\n/**\n * Returns the pixelated position for the specified position.\n *\n * ===\n * The following is an overview diagram at a scale of 1.\n *\n * 1. Determine the region for the specified position.\n *\n *         +---+-------+---+       +---+-------+---+\n *   7.5 -   1 | 0   0 | 1   1   1   1 | 0   0 | 1\n *             |       |               |       |\n *   6.5 -   1 | 0   0 | 1   1   1   1 | 0   0 | 1\n *         +---+       +---+-------+---+       +---+\n *   5.5 - | 0   0   0   0 | 1   1 | 0   0   0   0 |\n *         |               |       |               |\n *   4.5 - | 0   0   0   0 | 1   1 | 0   0   0   0 |\n *         +---+-------+---+       +---+-------+---+\n *   3.5 -   1 | 0   0 | 1   1   1   1 | 0   0 | 1\n *             |       |               |       |\n *   2.5 -   1 | 0   0 | 1   1   1   1 | 0   0 | 1\n *         +---+       +---+-------+---+       +---+\n *   1.5 - | 0   0   0   0 | 1   1 | 0   0   0   0 |\n *         |               |       |               |\n *   0.5 - | 0   0   0   0 | 1   1 | 0   0   0   0 |\n *         +---------------+       +---------------+\n *\n *           |   |   |   |   |   |   |   |   |   |\n *          0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5\n *\n * 2. Determine the center coordinates of the T shape.\n *\n *         +---+-------+---+   @   +---+-------+---+\n *   7.5 -     |       |               |       |\n *             |       |               |       |\n *   6.5 -     |       |               |       |\n *         +---+   @   +---+-------+---+   @   +---+\n *   5.5 - |               |       |               |\n *         |               |       |               |\n *   4.5 - |               |       |               |\n *         +---+-------+---+   @   +---+-------+---+\n *   3.5 -     |       |               |       |\n *             |       |               |       |\n *   2.5 -     |       |               |       |\n *         +---+   @   +---+-------+---+   @   +---+\n *   1.5 - |               |       |               |\n *         |               |       |               |\n *   0.5 - |               |       |               |\n *         +---------------+   @   +---------------+\n *\n *           |   |   |   |   |   |   |   |   |   |\n *          0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5\n */\nvec2 to_pixelated_coord(in int scale, in vec2 pos){\n#ifdef ENABLE_SHAPE_VFLIP\n    pos.y = iResolution.y - pos.y;\n#endif\n\n#ifdef ALLOW_NEGATIVE_COORDS\n    // n1=4*scale, n2=n1/2, n3=n1+n2, n4=n3/2\n    vec4 factor = float(scale) * vec4(4, 2, 6, 3);\n\n    // Determine the region for the specified position.\n    float region_y = mod(floor(pos.y / factor.y), 2.);\n    float region_x = mod(pos.x + factor.w * region_y, factor.z);\n    region_x = step(factor.x, region_x);\n    float region = abs(region_y - region_x);\n\n    // Determine the center coordinates of the T shape.\n    vec2 offset = region * vec2(-factor.w, factor.y);\n    vec2 offset_pos = pos + offset;\n    vec2 res = vec2(factor.y, factor.y - offset.y);\n    res.x += pos.x - mod(offset_pos.x, factor.z);\n    res.y += floor(offset_pos.y / factor.x) * factor.x;\n#else\n    // n1=4*scale, n2=n1/2, n3=n1+n2, n4=n3/2\n    ivec4 factor = scale * ivec4(4, 2, 6, 3);\n\n    // Determine the region for the specified position.\n    ivec2 ipos = ivec2(pos);\n    int region_y = (ipos.y / factor.y) % 2;\n    int region_x = (ipos.x + factor.w * region_y) % factor.z;\n    region_x = region_x < factor.x ? 0 : 1;\n    int region = region_y ^ region_x;\n\n    // Determine the center coordinates of the T shape.\n    ivec2 offset = region * ivec2(-factor.w, factor.y);\n    ivec2 offset_pos = ipos + offset;\n    vec2 res = vec2(\n        ipos.x + factor.y,\n        (offset_pos.y / factor.x) * factor.x + factor.y - offset.y\n    );\n    res.x -= mod(float(offset_pos.x), float(factor.z));\n#endif\n\n#ifdef ENABLE_SHAPE_VFLIP\n    res.y = iResolution.y - res.y;\n#endif\n    return res;\n}\n\nvec3 fetch(in vec2 pos){\n    return srgb_to_linear(texture(iChannel0, pos / iResolution.xy).rgb);\n}\n\nvec3 sample_texture(in int scale, in vec2 pos){\n#if 0\n    return fetch(pos);\n#else\n// Calculates the arithmetic mean of the T region.\n\n    int n1 = 4 * scale;\n    int n2 = n1 / 2;\n    int num_divs = n2 / 2;\n    float factor = float(2 - ((n2 % 2) ^ 1));\n\n    vec2 origins[3] = vec2[](\n        pos + 0.5 - vec2(n2),\n        pos + 0.5 - vec2(0, n2),\n        pos + 0.5 - vec2(n2 / 2, 0)\n    );\n    vec3 color = vec3(0.);\n\n    for(int i = 0; i < num_divs; i++){\n        for(int j = 0; j < num_divs; j++){\n            vec2 p = vec2(j, i);\n            vec2 s = 2. * p + factor * hash22(pos + p);\n            color += fetch(origins[0] + s);\n            color += fetch(origins[1] + s);\n            color += fetch(origins[2] + s);\n        }\n    }\n\n    return color / float(3 * num_divs * num_divs);\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n#ifdef DEBUG_NEGATIVE_COORDS\n    fragCoord -= 0.5 * iResolution.xy;\n#endif\n\n#if 0\n    int scale = 5;\n#else\n    float c = cos(0.5 * iTime);\n    int scale = int(ceil(0.5 + 9. * c * c));\n#endif\n\n    vec2 pos = to_pixelated_coord(scale, fragCoord);\n    vec3 color = sample_texture(scale, pos);\n\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//==============================================================================\n\n// https://www.shadertoy.com/view/XlGcRh\nuvec2 pcg2d(uvec2 v){\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec2 hash22(vec2 p){\n    uvec2 hash = pcg2d(uvec2(p));\n    return vec2(hash) * (1. / float(0xffffffffu));\n}\n\n//==============================================================================\n\nfloat srgb_to_linear(in float x){\n    return x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\n\nvec3 srgb_to_linear(in vec3 color){\n    return vec3(srgb_to_linear(color.r), srgb_to_linear(color.g), srgb_to_linear(color.b));\n}\n\nfloat linear_to_srgb(in float x){\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(x, 1./2.4) - 0.055;\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    return vec3(linear_to_srgb(color.r), linear_to_srgb(color.g), linear_to_srgb(color.b));\n}\n","name":"Common","description":"","type":"common"}]}