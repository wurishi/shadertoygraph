{"ver":"0.1","info":{"id":"XtsfR7","date":"1511492718","viewed":96,"name":"Raysome","username":"LaceySnr","description":"Trying some raytracing techniques... no reflections or anything pretty yet\n\nMouse X controls rotation, Mouse Y rotates light source around the spheres.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Equation for a sphere is:\n// P^2 - RT2 = 0\n// where P is a point on the surface, and R is the Radius\n\n// A Ray can be thouht be a parametric equation:\n// O(rigin) + t * D(irection)\n\n// Substituting that in for P gives:\n// |O+tD|^2 âˆ’ R^2 = 0\n\n// rewritten in a(x^x) + bx + c:\n// D^2 = a\n// 2OD = b\n// O^2 - R^2 = c\n\n// Factoring in the centre, C of the spehere:\n// |O+tD-C|^2 - R^2 = 0\n// |(O-C) + tD|^2 = R^2\n// a = D^2\n// b = 2D(O-C)\n// c = (O-C)^2 - R^2\n\n\n#define GRID_N\t5.\n#define GRID_S\t3.\t// spacing\n\n#define GRID_N_1\t- ((GRID_N - 1.) * .5)\n#define GRID_N_2\t(GRID_N_1 + GRID_N)\n\n#define CAM_DIST 10.\n\n\n// TODO:\n\n// [ ] Ground plane\n// [x] Depth checks - find nearest sphere\n// [x] Shadow Rays\n// [ ] Reflections\n// [ ] Scene structure\n// [ ] Coarse detection\n\nstruct ray\n{\n    vec3 o;\n    vec3 d;\n    int life;\n    vec4 col;\n};\n\nray makeRay(vec3 cam, vec3 target, vec2 uv)\n{\n    ray r;\n\n    vec3 cz = normalize(target - cam);\n   \tvec3 cx = cross(cam, vec3(0., 1., 0.));\n    vec3 cy = cross(cz, cx);\n    \n    r.o = cam;\n    r.d = normalize(cz * 4. + (uv.x * cx) + (uv.y * cy));\n   \n    r.life = 3;\n    r.col = vec4(0., 0., 0., 1.);\n    \n    return r;\n}\n\nfloat discriminant(float b, float c)\n{\n    return b * b - 4. * c;\n}\n\nfloat solveQuad(float a, float b, float c, float disc)\n{\n    // q = - .5 * (b + sign(b) sqrt(discriminant))\n    // root1 = q / a\n    // root2 = c / q\n    float s = sqrt(disc);\n\n    float q;\n    if(b > 0.)\n        q = -.5 * (b + s);\n    else\n        q = -.5 * (b - s);\n\n    float r1 = q / a;\n    float r2 = c / q;\n\n    return (r1 > r2 ? r2 : r1);\n}\n\nfloat checkSphere(ray r, vec3 p)\n{\n\tfloat a = dot(r.d, r.d);\n    \n    vec3 co = r.o - p;\n    \n    float b = 2. * dot(r.d, co);\n    float c = dot(co, \tco) - 2.;\n    \n    float f = discriminant(b, c);\n    \n    // f > 0 ? two roots (passing through sphere),\n    // f = 0 one root (on the surface)\n    // f < 0, no roots (we missed)\n    \n    // intersect, solve the quadratic\n    if(f > 0.)\n    { \n        return solveQuad(a, b, c, f);\n    }\n\n    return 0.;\n}\n\nvec3 getPoint(float x, float z)\n{\n\treturn vec3(sin(iTime * 0.) * float(x * GRID_S),\n                z * GRID_S,\n               cos(iTime * 0.) * float(x * GRID_S));\n}\n\nray iterateRay(ray r)\n{\n    // a = D^2\n\t// b = 2D(O-C)\n\t// c = (O-C)^2 - R^2\n    \n    vec3 point;\n    float root = 0.;\n    int index = 0;\n    \n    for(float x = GRID_N_1; x < GRID_N_2; x += 1.)\n    {\n        for(float z = GRID_N_1; z < GRID_N_2; z += 1.)\n        {\n\t\t\tvec3 testPoint = getPoint(x, z);\n            float nextRoot = checkSphere(r, testPoint);\n        \t\n            if(nextRoot == 0.)\n                continue;\n       \n            if(root == 0. || (nextRoot < root))\n            {\n                point = testPoint;\n                root = nextRoot;\n                index = int(x * GRID_N + z);\n            }\n        }\n    }\n    \n    if(root <= 0.)\n    {\n\t\tr.col = vec4(.5, .5, .5, 1.);\n        return r;\n    }\n    \n    // collision point = cam + dirn * root;\n    vec3 cp = r.o + r.d * root;        \n    vec3 normal = normalize(cp - point);\n    float scale = 2.2;\n    vec3 light = vec3(3., cos(iTime) * 5., sin(iTime) * 5.);\n    \n    // basic lighting \n    float bright = clamp(dot(normalize(light - cp), normal), .2, 1.);\n    \n    // shadow rays\n    bool inShadow = false;\n    vec3 toLight = (light - cp);\n    ray shadow;\n\tshadow.o = cp  + normal * .1;\n    shadow.d = normalize(toLight);\n\n    // only check for shadows if we're actually lit\n    //if(bright > 0.)\n    {\n    \tfor(float x = GRID_N_1; x < GRID_N_2; x += 1.)\n    \t{\n        \tfor(float z = GRID_N_1; z < GRID_N_2; z += 1.)\n        \t{\n                //if(int(x * GRID_N + z) == index)\n                //\tcontinue;\n                \n\t\t\t\tvec3 testPoint = getPoint(x, z);                 \n\t            float root = checkSphere(shadow, testPoint);\n\n                // ensure that the new collision we've found isn't\n                // a) behind the current collection point\n                // b) not beyond the light source\n                if(root > 0. && dot(toLight, (shadow.o + shadow.d * root)) < 1.)\n                {\n                    bright = .2;\n                    break;\n                }\n            }\n        }\n    }\n\n    // texturing\n    vec2 uv = vec2(atan(normal.z, normal.x), acos(normal.y));\n    uv.x *= 1. * 0.31830988618379067153776752674503; // 0.15915494309189533576888376337251;\n    uv.y *= - 0.31830988618379067153776752674503;\n\n    vec4 tex = texture(iChannel0, uv);\n    \n    r.col = tex * bright;\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float camHeight = 0.;// (iMouse.y - (iResolution.y * .5)) * .01;\n    float camRot = iMouse.x * .01;\n    \n    vec3 cam = vec3(sin(camRot) * CAM_DIST, camHeight, cos(camRot) * CAM_DIST);\n    ray r = makeRay(cam, vec3(0., 0., 0.), uv);\n    \n    r = iterateRay(r);\n    \n\tfragColor = r.col;\n}","name":"Image","description":"","type":"image"}]}