{"ver":"0.1","info":{"id":"tt3SW7","date":"1581051615","viewed":424,"name":"Crystal City","username":"omgadev","description":"This is a giant city of modulo!","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","reflection","city","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightColor = normalize(vec3(0.8, 1.0, 1.0));\nvec3 skyColor1 = normalize(vec3(0.2, 0.6, 1.0));\nvec3 skyColor2 = normalize(vec3(0.8, 0.9, 1.0));\nvec3 buildingColor = vec3(0., 0., 0.);\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n\treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n\t\toc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n\t\toc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat GetDist(vec3 p)\n{\n\tfloat dist = 99999999.;\n\n\tfor (int i = -5; i < 3; i++)\n\t{\n\t\tfloat s = pow(2., float(-i));\n\t\tvec3 p = vec3(mod(p.x, s), p.y, mod(p.z, s));\n\t\tvec3 c = vec3(0.5 * s, -2., 0.5 * s);\n\t\tvec3 b = vec3(0.1, 0.4, 0.1) * s;\n\t\tvec3 q = abs(p - c) - b;\n\t\tfloat d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n\t\tdist = min(dist, d);\n\t}\n\tdist = min(dist, p.y + 2.);\n\n\treturn dist;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n\tfloat rayLength = 0.;\n\n\tfor (int marches = 0; marches < 500; marches++)\n\t{\n\t\tfloat dist = GetDist(rayOrigin + rayDir * rayLength);\n\t\trayLength += dist;\n\n\t\tif (rayLength > 100.)\n\t\t\treturn -1.;\n\t\telse if (dist < 0.01)\n\t\t\treturn rayLength;\n\t}\n\n\treturn -1.;\n}\n\nvec3 GetNormal(vec3 point)\n{\n\tfloat d = GetDist(point);\n\tvec2 e = vec2(0, 0.01);\n\treturn normalize(vec3(\n\t\td - GetDist(point - e.yxx),\n\t\td - GetDist(point - e.xyx),\n\t\td - GetDist(point - e.xxy)\n\t));\n}\n\nvec3 GetColor(vec3 camPos, vec3 lightDir, vec3 rayDir)\n{\n\tvec3 totalColor = vec3(0);\n\tfloat r = 1.;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\t//calculate raymarch\n\t\tfloat rayMarch = RayMarch(camPos + rayDir * 0.02, rayDir);\n\t\tvec3 point = camPos + rayMarch * rayDir;\n\n\t\t//calculate lights\n\t\tvec3 color = buildingColor;\n\t\tvec3 normal = GetNormal(point);\n\t\tcolor *= lightColor * clamp(dot(-lightDir, normal), 0., 1.);\n\t\tcolor += lightColor * pow(max(dot(reflect(-lightDir, normal), rayDir), 0.), 32.);\n\t\tif (rayMarch == -1.)\n\t\t{\n\t\t\tcolor = mix(skyColor1, skyColor2, 1. - rayDir.y);\n\t\t\ttotalColor += color * r;\n\t\t\tr /= 5.;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolor = mix(color, mix(skyColor1, skyColor2, 1. - rayDir.y), clamp(rayMarch / 100., 0., 1.));\n\t\t\ttotalColor += color * r;\n\t\t\tr /= 5.;\n\t\t}\n\t\tcamPos = point;\n\t\trayDir = reflect(rayDir, normal);\n\t}\n\n\treturn totalColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 rayDir = normalize(vec3(uv, 0.5));\n\tvec3 camPos = vec3(3., 0., iTime * 5.);\n\tvec3 lightDir = normalize(vec3(-5, -3, -1));\n\trayDir = rotate(rayDir, vec3(0., 1., 0.), sin(iTime) * 0.1 + 1.);\n    \n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 20.0;\n    vig = pow(vig, 0.25);\n\n    // Output to screen\n    fragColor = vec4(pow(GetColor(camPos, lightDir, rayDir) * vig, vec3(1.0/1.5)), 1.0);\n}","name":"Image","description":"","type":"image"}]}