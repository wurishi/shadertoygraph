{"ver":"0.1","info":{"id":"ctlXDf","date":"1675436960","viewed":83,"name":"bonhomme_Bbbourrré","username":"Baptiste_labat","description":"bonhomme_bourré","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["chara"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c, c) - 0.5 * c;\n}\n\nvec2 rot(vec2 st, float a)\n{\n    return st * mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat map(vec3 pos) {\n    float v = 0.0;\n   \n    pos.z += (sin(pos.y+iTime*10.)*.1)*max(pos.y+sin(iTime*2.0)*1.0, 0.0);\n    \n    vec3 cubePos = pos;\n    //cubePos.x += sin(pos.y+iTime);\n    \n    \n    \n    float cube = sdBox(cubePos, vec3(1.0, 0.6, 0.4));\n    float body = sdSphere(pos+vec3(0.0, -0.8, 0.0), 1.35);\n    float jambeR = sdCapsule(pos, vec3(0.9,0.0,-0.1), vec3(1.5,-5.0,0.0), 0.5);\n    float jambeL = sdCapsule(pos, vec3(-0.9,0.0,0.1), vec3(-1.5,-5.0,0.0), 0.5);\n    float armR = sdCapsule(pos, vec3(-0.2,2.0,0.5), vec3(4.0,0.0,0.0), 0.4);\n    float armL = sdCapsule(pos, vec3(0.2,2.0,0.5), vec3(-4.0,0.0,0.0), 0.4);\n    float head = sdCapsule(pos, vec3(0.0,3.0,0.0), vec3(0,2.5,0.1), 0.7);\n    v = opSmoothUnion(body,cube, 0.8);\n    v = opSmoothUnion(v,jambeR, 0.5);\n    \n    v = opSmoothUnion(v,jambeL, 0.5);\n    v = opSmoothUnion(v,armR, 0.5);\n    v = opSmoothUnion(v,armL, 0.5);\n    v = opSmoothUnion(v,head, 0.001);\n    \n    \n    return v;\n    \n    \n}\n\n\nfloat CastRay(vec3 ro, vec3 rd)  \n{\n    float contact = 0.0;\n    \n    for(int i=0; i<64; i++)\n    {\n        float ray = map(ro + rd * contact); // TODO\n        \n        if(ray < (0.0001*contact))\n        {\n            //return contact;\n            return float(i)/32.;\n        }\n        \n        contact += ray;\n    }\n    \n    return -1.0;\n}\n\nvec3 render(vec3 ro, vec3 rd) \n{\n    float contact = CastRay(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if(contact == -1.0)\n    {\n        col = vec3(0.2,0.5,0.8);\n    }\n    else\n    {\n       col = vec3(0.8,0.5,0.0)-contact;\n       //col = vec3(1.0-contact);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraPos = vec3(0.0, 4.0, -8.0);\n    vec3 cameraTar = vec3(0.0, 0.0, 0.0);\n    \n    cameraPos.xz = rot(cameraPos.xz, iTime);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n    \n\n    vec3 col = render(cameraPos, viewDir);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}