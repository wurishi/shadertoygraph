{"ver":"0.1","info":{"id":"X3s3RB","date":"1707615808","viewed":178,"name":"Simple SDF antialiasing","username":"Cellulose","description":"By comparing a signed distance function with a per-pixel differential we can get an alpha value for smooth 1-pixel edge blending.  Manhattan norms may be better though.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","antialiasing","aa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    // Change UV coords to be centered at 0,0\n    uv = 2.0 * fragCoord / iResolution.y - vec2(iResolution.x/iResolution.y,1);\n    \n    \n    float dist = length(uv) - .5;\n    \n    float alpha = 0.0;\n    \n    if (min(abs(uv.x), abs(uv.y)) < .002)\n    {\n        col = vec3(1);\n    }\n    else\n    {\n        if (uv.y > 0.0)\n        {\n            // Magic formula.\n            // Divide our signed distance by the norm of its gradient per pixel.\n            // This yields a value in \"pixel distances from the edge\".\n            float edge = -dist / max(abs(dFdx(dist)), abs(dFdy(dist)));\n\n            // Map the alpha gradient to distances  -.5 .. +.5.\n            // There is room for improvement in the denominator as well as the gradient (pixels aren't circular).\n            alpha = clamp(edge + .5, 0.0, 1.0);\n        }\n        else\n        {\n            // This code is just to better illustrate the alpha blending by magnifying it.\n            // pixelate for a zoom-in effect on the antialiasing\n            vec2 pxFragCoord = round(fragCoord/9.0), pxResolution = round(iResolution.xy/9.0);\n            uv = 2.0 * pxFragCoord / pxResolution.y - vec2(pxResolution.x/pxResolution.y,1);\n            float duv = 2.0 / pxResolution.y;\n\n            float dist = length(uv) - .5;\n            float dfdx = (length(uv + vec2(duv,0)) - length(uv - vec2(duv,0))) / 2.0;\n            float dfdy = (length(uv + vec2(0,duv)) - length(uv - vec2(0,duv))) / 2.0;\n            float edge = -dist / max(abs(dfdx), abs(dfdy));\n            alpha = clamp(edge + .5, 0.0, 1.0);\n        }\n\n        if (uv.x < 0.0)\n        {\n            col = mix(vec3(.2,0,0), vec3(.7,.9,.9), alpha);\n        }\n        else\n        {\n            if (alpha * (1.0-alpha) == 0.0)\n            {\n                col = vec3(.1 * alpha);\n            }\n            else\n            {\n                col = mix(vec3(1,0,0), vec3(0,1,1), alpha);\n            }\n        }\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}