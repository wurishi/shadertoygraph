{"ver":"0.1","info":{"id":"lsccDl","date":"1520539564","viewed":427,"name":"Simple heat haze shader","username":"theclaw37","description":"A simple heat haze shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["heat","hot","haze","temperature","london"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nfloat map(float value, float min1, float max1, float min2, float max2)\n{\n    float perc = (value - min1) / (max1 - min1);\n    return perc * (max2 - min2) + min2;\n}\n\nfloat standardDeviation(vec3 colour)\n{\n    float mean = (colour.r + colour.g + colour.b) / 3.0;\n    float sum = (colour.r - mean) * (colour.r - mean) +\n        \t\t(colour.g - mean) * (colour.g - mean) +\n        \t\t(colour.b - mean) * (colour.b - mean);\n    \n    float mean_sum = sum / 3.0;\n    \n    return sqrt(mean_sum);\n}\n\nfloat grayPercentage(vec3 colour)\n{\n    return 1.0-standardDeviation(colour.rgb);  \n}\n\nfloat colourDistance(vec4 compare, vec4 to)\n{\n    return sqrt((to.r - compare.r) * (to.r - compare.r) +\n        \t(to.g - compare.g) * (to.g - compare.g) +\n        \t(to.b - compare.b) * (to.b - compare.b));\n}\n\nfloat heatDistortionIntensity(vec2 uvCoord)\n{\n    vec4 textureSample = texture(iChannel0, uvCoord);\n    \n    // Uncomment for a colour based haze (black = more haze, not perfect)\n    //float result = float(1.0 - colourDistance(textureSample, vec4(1.0))) / 2.0;\n    \n    // Uncomment for a standard-deviation based colour analysis, based on how \"gray\" is a colour\n    // Needs a very high resolution pic\n    //float result = grayPercentage(textureSample.rgb);\n    \n    // Best result, a cubic function that restricts the haze to the \"ground\"\n    float result = (1.0-uvCoord.y) * (1.0-uvCoord.y) * (1.0-uvCoord.y);\n    \n    return map(result, 0.0, 1.0, 0.0, 0.5);\n}\n\nfloat rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float waves = 15.0;\n    float frequency = uv.y * 2.0 * M_PI * waves;\n    float amplitude = 0.004 * heatDistortionIntensity(uv);\n    float speed = 40.0;\n    float phase = M_PI/4.0 + iTime * speed;\n    float sine_range = sin(-phase + frequency) * amplitude;\n    \n    vec2 distort = vec2(sine_range,0.0);\n    \n    // Simple blur based on rand function\n    // Fast, but not the prettiest\n    vec2 blur = vec2(rand(uv + vec2(iTime)) / 30.0 * heatDistortionIntensity(uv));\n    \n    // Output to screen\n    fragColor = texture(iChannel0, uv + distort + blur);\n}","name":"Image","description":"","type":"image"}]}