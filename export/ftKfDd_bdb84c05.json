{"ver":"0.1","info":{"id":"ftKfDd","date":"1665567434","viewed":121,"name":"Box Frame with Rounded Bars","username":"gPlatl","description":"Function sdRoundedBoxFrame(...) creates a 'Box Frame' with rounded bars.\nIt's an improvement of IQs  \n  float sdBoxFrame(vec3 p, vec3 b, float e)   // https://iquilezles.org/articles/distfunctions/\nwith variable box bar radius.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","box","rounded","bar","frame","radius"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------------------------------------------\n//\n// file: BoxFrameWithRoundedBars.glsl     \n// \n//   v1.0  2022-10-12  initial version\n//   v1.1  2022-10-14  added sdRoundedBoxCross()\n//   v1.2  2022-10-26  added sdPipeBoxFrame()\n//   v1.3  2023-09-08  added ReuleauxTetrahedron\n//\n// based on https://shadertoy.com/view/styBWd by jt. \n//\n// MIT license, from https://www.shadertoy.com/terms\n//\n// tags: bar, box, frame, rounded, radius, raymarching\n//\n// note: use mouse to rotate shape\n//   move mouse to the left to restore auto rotation\n// \n// todo: add antialiasing of shape edges\n//\n//----------------------------------------------------------\n\n#define Texture3D\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define pi 3.1415926\n\nconst vec3 skyColor = vec3(0.4, 0.7, 1.0);\nconst vec3 groundColor = vec3(0.4, 1.0, 0.5);\n\nfloat sq(float x)   { return x*x; }   // square a value\n\n//----------------------------------------------------------\n// https://iquilezles.org/articles/distfunctions/\n//----------------------------------------------------------\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{      p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n    length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n    length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n    length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n//----------------------------------------------------------\n// An improvement of IQs sdBoxFrame(...) \n//----------------------------------------------------------\nfloat sdRoundedBoxFrame(vec3 p,   // position\n                        vec3 b,   // box size\n                        float e,  // bar size\n                        float r)  // bar round radius\n{      e = e - r;\n       p = abs(p)-b;\n  vec3 q = abs(p)-e;\n  return min(min(\n    length(max(vec3(p.x-e, q.y, q.z), 0.0)),\n    length(max(vec3(q.x, p.y-e, q.z), 0.0))),\n    length(max(vec3(q.x, q.y, p.z-e), 0.0)))-r;\n}\n\n//----------------------------------------------------------\nfloat sdPipeBoxFrame(vec3 p,   // position\n                     vec3 b,   // box size\n                     float r)  // bar round radius\n{      p = abs(p)-b;\n  vec3 q = abs(p);\n  return min(min(\n    length(max(vec3(p.x, q.y, q.z), 0.0)),\n    length(max(vec3(q.x, p.y, q.z), 0.0))),\n    length(max(vec3(q.x, q.y, p.z), 0.0)))-r;\n}\n//----------------------------------------------------------\nfloat sdRoundedBoxCross(vec3 p,   // position\n                        vec3 b,   // box size\n                        float e,  // bar size\n                        float r)  // bar round radius\n{      e = e - r;\n       p = abs(p)-b-e;\n  vec3 q = p+b;\n  return min(min(\n    length(max(vec3(p.x, q.y, q.z), 0.0))-r,\n    length(max(vec3(q.x, p.y, q.z), 0.0))-r),\n    length(max(vec3(q.x, q.y, p.z), 0.0))-r);\n}\n//----------------------------------------------------------\n// https://en.wikipedia.org/wiki/Reuleaux_tetrahedron\n// https://www.shadertoy.com/view/dlSfWw\n//----------------------------------------------------------\nfloat sdReuleauxTetrahedron (vec3 pos,   // position\n                             float s)    // size\n{\n  float a = 0.5,  r = .0;\n  float x1 = sq(pos.x-a), x2 = sq(pos.x+a);\n  float y1 = sq(pos.y-a), y2 = sq(pos.y+a);\n  float z1 = sq(pos.z-a), z2 = sq(pos.z+a);\n   \n  return sqrt(max(max(x1+y1+z1-r, x2+y2+z1-r)\n                , max(x1+y2+z2-r, x2+y1+z2-r))) -s;\n}\n//----------------------------------------------------------\nfloat halfspace(vec3 p)\n{\n  return p.z + 1.22;\n}\n\nvec3 color = skyColor;\n\nvoid colorize(float d, vec3 newColor)\n{\n  if (d < 0.0) color = newColor;\n}\n//----------------------------------------------------------\nfloat map(vec3 pos)\n{\n  vec3 boxSize = vec3(1.4, 0.9, 1.1);\n  float barSize = 0.2;\n  float roundRadius = 0.08 +0.07*sin(iTime);\n  float d = DIST_MAX;\n  colorize(d = min(d, halfspace(pos)), groundColor);\n//d = min(d, sdBoxFrame(pos, boxSize, barSize));\n  d = min(d, sdRoundedBoxFrame(pos, boxSize, barSize, roundRadius));\n//d = min(d, sdRoundedBoxCross(pos, boxSize, barSize, roundRadius));\n//d = min(d, sdPipeBoxFrame   (pos, boxSize,          roundRadius));\n//d = min(d, sdReuleauxTetrahedron (pos, 2.2));\n  return d;\n}\n\n//----------------------------------------------------------\n// get surface normal with tetrahedron technique\n// https://iquilezles.org/articles/normalsSDF\n//----------------------------------------------------------\nvec3 normal(vec3 pos) \n{\n  const float h = EPSILON;\n  const vec2 k = vec2(1,-1);\n  return normalize( k.xyy*map(pos + k.xyy*h) + \n                    k.yyx*map(pos + k.yyx*h) + \n                    k.yxy*map(pos + k.yxy*h) + \n                    k.xxx*map(pos + k.xxx*h));\n}\n\n//----------------------------------------------------------\n// raymarching scenery\n//----------------------------------------------------------\nfloat trace(vec3 ro, vec3 rd, float t0, float t1)\n{\n  for(float t = t0; t < t1;)\n  {\n    float h = map(ro + rd * t);\n    if(h < EPSILON)\n      return t;\n    t += h;\n  }\n  return t1;\n}\n//----------------------------------------------------------\n// https://iquilezles.org/articles/rmshadows\n//----------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n  for( float t=mint; t<maxt; )\n  {\n    float h = map(ro + rd*t);\n    if( h<EPSILON )\n      return 0.0;\n    t += h;\n  }\n  return 1.0;\n}\n\n//----------------------------------------------------------\n// https://iquilezles.org/articles/rmshadows\n//----------------------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n  float res = 1.0;\n  float ph = 1e20;\n  for( float t=mint; t<maxt; )\n  {\n    float h = map(ro + rd*t);\n    if( h < EPSILON )\n      return 0.0;\n    float y = h*h/(2.0*ph);\n    float d = sqrt(h*h-y*y);\n    res = min( res, k*d/max(0.0,t-y) );\n    ph = h;\n    t += h;\n  }\n  return res;\n}\n\n//----------------------------------------------------------\n// calculate Ambient Occlusion\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf \n//----------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for( int i=0; i<5; i++ )\n  {\n    float h = 0.01 + 0.12*float(i)/4.0;\n    float d = map( pos + h*nor );\n    occ += (h-d)*sca;\n    sca *= 0.95;\n    if( occ>0.35 ) break;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\n//----------------------------------------------------------\n// return 3d texture color (Triplanar Texture Mapping) \n//----------------------------------------------------------\nvec4 texture3d(sampler2D tex, in vec3 pos, in vec3 n)\n{\n  vec4 x = texture(tex, pos.yz);\n  vec4 y = texture(tex, pos.zx);\n  vec4 z = texture(tex, pos.xy);\n  return x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec3 ro = vec3(0.0, 0.0, -5.0);  // camera position\nvec3 rd = vec3(0);               // camera direction   \n\n//----------------------------------------------------------\n// set ray.origin ro and ray.direction rd\n//----------------------------------------------------------\nvoid camera (in vec2 fragCoord )\n{\n  vec2 pos = 2.0 * (fragCoord.xy) / iResolution.xy - 1.0;\n  pos.x *= float(iResolution.x) / float(iResolution.y);\n  float mx = 2.0 * pi * float(iMouse.x) / float(iResolution.x);\n  float my = pi / 2.1 + pi / 2.0 * float(iMouse.y) / float(iResolution.y);\n  mx = (iMouse.x > 20.0) ? mx : 2.0 * pi * fract(iTime * 0.01);\n\n  mat2 Yaw = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n  mat2 Pitch = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n  ro.yz = Pitch * ro.yz;\n  ro.xy = Yaw * ro.xy;\n\n  rd = normalize(vec3(0.5 * pos.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n  rd.yz = Pitch * rd.yz;\n  rd.xy = Yaw * rd.xy;\n}\n//----------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  camera (fragCoord);\n    \n  float dist = trace(ro, rd, 1.0, DIST_MAX);  // get distance\n    \n  vec3 dst = ro + rd * dist;\n  vec3 nn = normal(dst);\n  vec3 lightdir = normalize(vec3(1.0));\n  vec3 ambient = vec3(0.1);\n  float brightness = max(dot(lightdir, nn), 0.0);\n//brightness *=     shadow(ro+rd*dist,lightdir, 0.01, DIST_MAX);\n  brightness *= softshadow(ro+rd*dist,lightdir, 0.01, DIST_MAX, 50.);\n  vec3 boxColor = (nn * 0.5 + 0.5);\n  #ifdef Texture3D\n    vec3 t3d = texture3d(iChannel0, dst, nn).rgb;\n    boxColor = mix(boxColor, t3d, 0.7);   // add 3d texture   \n  #endif    \n  boxColor = (ambient * calcAO(dst, nn) + brightness) * boxColor;\n\n  if (color != groundColor)\n    color = mix(boxColor, color, step(DIST_MAX, dist));  // add shape \n  else\n  {\n    vec3 t3d = texture3d(iChannel1, dst*0.1, nn).rgb;\n    t3d = (ambient * calcAO(dst, nn) + brightness) * t3d;\n    color = mix(t3d, color, step(DIST_MAX, dist));  // add ground\n  }\n  fragColor = vec4(sqrt(color), 1.0);  // approximate gamma\n}\n","name":"Image","description":"","type":"image"}]}