{"ver":"0.1","info":{"id":"Wtf3zB","date":"1556646028","viewed":248,"name":"Webcam Rippler","username":"chaz303","description":"Makes video ripple. I created this to play with using different oscillator shapes to modulate parameters of a video.","likes":2,"published":1,"flags":2,"usePreview":0,"tags":["webcamlfo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// UNIFIED RIPPLE\n\n// HORIZONTAL\n#define h_speed 2.0\n#define h_freq 13.0\n\n#define h_sin_amp 0.02\n#define h_sin_speed 0.0\n#define h_sin_freq 0.0\n\n#define h_tri_amp 0.0\n#define h_tri_speed 0.0  // -10 to 10\n#define h_tri_freq 0.0\n\n#define h_saw_amp 0.0\n#define h_saw_speed 0.0\n#define h_saw_freq 0.0\n\n#define h_negsaw_amp 0.0\n#define h_negsaw_speed 0.0\n#define h_negsaw_freq 10.0\n\n#define h_pwm_amp 0.0\n#define h_pwm_speed 0.0\n#define h_pwm_freq 10.0\n#define h_pwm_mod_amp 1.0\n\n// VERTICAL\n#define v_speed 4.0\n#define v_freq 4.0\n\n#define v_sin_amp 0.001\n#define v_sin_speed 0.0\n#define v_sin_freq 0.0\n\n#define v_tri_amp 0.0\n#define v_tri_speed 0.0\n#define v_tri_freq 0.0\n\n#define v_saw_amp 0.0\n#define v_saw_speed 0.0\n#define v_saw_freq 0.0\n\n#define v_negsaw_amp 0.0\n#define v_negsaw_speed 0.0\n#define v_negsaw_freq 0.50\n\n#define v_pwm_amp 0.0\n#define v_pwm_speed 0.0\n#define v_pwm_freq 0.0\n#define v_pwm_mod_amp 1.0\n\nfloat sinOsc(float uv, float freq, float speed, float amp){\n     return sin(uv*(freq)*6.28-iTime*(speed))*amp;   \n}\nfloat triOsc(float uv, float freq, float speed, float amp){\n     return (asin(sin(uv*freq*6.28-iTime*speed)))*amp;   \n}\nfloat sawOsc(float uv, float freq, float speed, float amp){\n     return (fract(uv*-freq+iTime*speed/2.0)*2.0-1.0)*amp;   \n}\nfloat negSawOsc(float uv, float freq, float speed, float amp){\n     return (fract(uv*freq-iTime*speed/2.0)*2.0-1.0)*amp;   \n}\nfloat pwmOsc(float uv, float pwm, float freq, float speed, float amp){\n     return ((step(pwm*2.0-1.0,sin(uv*freq*6.28-iTime*speed))*2.0-1.0))*amp;\n}\nfloat sqrOsc(float uv, float freq, float speed, float amp){\n     return ((step(0.0,sin(uv*freq*6.28-iTime*speed))*2.0-1.0))*amp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n// SINE\n    uv.x += sinOsc((uv.y+(-uv.x*0.4))*(-uv.y+(uv.x*0.4))*(uv.y+(uv.x*0.4)),h_freq+h_sin_freq,h_speed+h_sin_speed,h_sin_amp);        \n// TRIANGLE\n\tuv.x += triOsc(uv.y,h_freq+h_tri_freq,h_speed+h_tri_speed,h_tri_amp);        \n// SAWTOOTH\n\tuv.x += sawOsc(uv.y,h_freq+h_saw_freq,(h_speed+h_saw_speed)*5.0,h_saw_amp);        \n\tuv.x += sawOsc(uv.y,(h_freq+h_saw_freq)*20.0,(h_speed+h_saw_speed)*0.0,h_saw_amp);        \n\t//uv.x += sawOsc(uv.y,h_freq+h_saw_freq,h_speed+h_saw_speed,h_saw_amp);        \n    // NEGATIVE SAWTOOTH\n\tuv.x += negSawOsc(uv.y,h_freq+h_negsaw_freq,h_speed+h_negsaw_speed,h_negsaw_amp);      \n// SQUARE\n    float h_pwm = ((sinOsc(1.0,1.0,h_speed*2.0,1.0)+1.0)*0.5*h_pwm_mod_amp);\n    uv.x += pwmOsc(uv.y, h_pwm,(h_freq+h_pwm_freq),(h_speed+h_pwm_speed),h_pwm_amp);\n    \n// EXPERIMENTAL\n    float h_saw_amp2 = (pwmOsc(0.0,h_pwm,0.0,(h_speed*10.0),0.1)*0.05);\n//    uv.x += sawOsc(uv.y,(h_freq*8.0),(h_speed*1.0),h_saw_amp2);        \n\n// SINE\n    uv.y += sinOsc(uv.x,v_freq+v_sin_freq,v_speed+v_sin_speed,v_sin_amp);        \n// TRIANGLE\n\tuv.y += triOsc(uv.x,v_freq+v_tri_freq,v_speed+v_tri_speed,v_tri_amp);        \n// SAWTOOTH\n\tuv.y += sawOsc(uv.x,v_freq+v_saw_freq,v_speed+v_saw_speed,v_saw_amp);\n    uv.y += sawOsc(uv.x,v_freq+v_saw_freq*0.7,v_speed+v_saw_speed,v_saw_amp*0.5);\n\tuv.y += sawOsc(uv.x,v_freq+v_saw_freq*0.3,v_speed+v_saw_speed,v_saw_amp*0.25);\n\n// NEGATIVE SAWTOOTH\n\tuv.y += negSawOsc(uv.x,v_freq+v_negsaw_freq,v_speed+v_negsaw_speed,v_negsaw_amp);      \n// SQUARE\n    float v_pwm = ((sqrOsc(1.0,1.0,h_speed,1.0)+1.0)*0.5*v_pwm_mod_amp);\n    uv.y += pwmOsc(uv.x, v_pwm,(v_freq+v_pwm_freq),(v_speed+v_pwm_speed),v_pwm_amp);\n    \n    vec4 pixel = texture(iChannel0,uv);\n    //pixel.r *= sqrOsc((uv.y+(uv.x*0.9))*(uv.y+(uv.x*0.9))*(uv.y+(uv.x*0.9)),h_freq+h_sin_freq,h_speed+h_sin_speed,0.5)+1.0;        \n\tpixel.r *= sinOsc((-uv.y+(uv.x*0.9))*(uv.y+(-uv.x*0.9))*(uv.y+(-uv.x*0.9)),h_freq*5.5+h_sin_freq,h_speed*2.0+h_sin_speed,0.5)+1.0;\n    pixel.g -= 0.01;\n    //pixel.b *= (sinOsc(uv.y+(uv.x*0.5),h_freq+h_sin_freq,h_speed+h_sin_speed,0.-0.0)+1.0)/2.0;        \n\n\tfragColor = pixel;\n}","name":"Image","description":"","type":"image"}]}