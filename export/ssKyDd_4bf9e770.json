{"ver":"0.1","info":{"id":"ssKyDd","date":"1655873659","viewed":104,"name":"Lissawho? v2","username":"daeken","description":"More lissajous experimentation. This time with a semi-implicit version instead of the parameterized version we know and love.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["playing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ntrue =>shadertoy\n\n{\n    @vec2 uniform =iResolution\n    @float uniform =iTime\n    @vec2 varying =fragCoord\n    \n    :m resolution iResolution ;\n    :m time iTime ;\n    fragCoord resolution .xy / 2 * 1 - [ resolution .xy \\/ 1 ] * =real-position\n    \n    :m ->fragColor =fragColor ;\n} {\n    @vec2 uniform =resolution\n    @float uniform =time\n    @vec2 varying =position\n    position 2 / 1 - [ resolution .xy \\/ 1 ] * =real-position\n\n    :m ->fragColor =$gl_FragColor ;\n} shadertoy cif\n\n{ + - * / } //{ (| operator |)\n    { = => } //{ (| assignment |)\n            `{ (| value variable |)\n                        *variable\n                        value\n                    ,operator\n                        &,assignment\n                        variable\n                    concat\n                call\n            }\n            operator assignment concat\n        def-prefix\n    }\n}\n:p min= (| variable |) *variable min &= variable concat call ;\n:p max= (| variable |) *variable max &= variable concat call ;\n\n:m when (| block cond |) block { } cond if ;\n:m cwhen (| block cond |) cond ~*block ;\n\n: smin (| a b k |)\n    k a b - abs - 0 max k / =h\n    a b min [ h h k 1 4 / ] \\* -\n;\n\n: sdif (| d1 d2 k |)\n    0.5 !d2 d1 + * k / - 0 1 clamp =h\n    d2 d1 neg h mix [ k h 1 h - ] \\* +\n;\n\n: sint (| d1 d2 k |)\n    0.5 !d2 d1 - * k / - 0 1 clamp =h\n    d2 d1 h mix [ k h 1 h - ] \\* +\n;\n\n:m union \\min ;\n:m mat-union \\{ (| $a $b |) a b a .x b .x < select } ;\n:m smooth-union (| list k |) list \\{ k smin } list union k 0 != select ;\n\n:m difference \\{ (| d1 d2 |) d2 neg d1 max } ;\n:m smooth-difference (| list k |) list \\{ swap k sdif } list difference k 0 != select ;\n\n:m intersection \\max ;\n:m smooth-intersection (| list k |) list \\{ k sint } list intersection k 0 != select ;\n\n:m scale (| block factor p |) p factor / *block factor * ;\n\n:m repeat (| block c p |) p .5 c * + c mod .5 c * - *block ;\n\n:m onion (| sdf thickness |) sdf abs thickness - ;\n\n:m store !drop ;\n\n:m apply (| funcs value |) funcs /{ value *_ } ;\n\n:m rotate (| $p angle |)\n        { cos sin }\n            &*angle\n            { angle store }\n            angle is-block?\n        cif\n    apply =[ c s ]\n    [\n        p .x c * p .y s * -\n        p .x s * p .y c * +\n    ]\n;\n\n:m scoped (| block p |) p *block ;\n\n:m round .5 + floor ;\n\n:m noise-permute (| x |)\n\tx 34 * 1 + x * 289 mod\n;\n\n:m pnoise-fade (| t |)\n\tt 6 * 15 - t * 10 + t * t * t *\n;\n\n: pnoise-2d (| v |)\n\tv .xyxy floor [ 0 0 1 1 ] + 289 mod =Pi\n\tv .xyxy fract [ 0 0 1 1 ] - =Pf\n\n\tPi .xzxz noise-permute Pi .yyww + noise-permute =>i\n\ti 41 / fract 2 * 1 - =gx\n\tgx abs .5 - =gy\n\tgx !round - =gx\n\n\t[ gx .x gy .x ] =>g00\n\t[ gx .y gy .y ] =>g10\n\t[ gx .z gy .z ] =>g01\n\t[ gx .w gy .w ] =>g11\n\n\tgx gx * gy gy * + sqrt inversesqrt =norm\n\tg00 norm .x * Pf .xy dot =>n00\n\tg10 norm .z * Pf .zy dot =>n10\n\tg01 norm .y * Pf .xw dot =>n01\n\tg11 norm .w * Pf .zw dot =>n11\n\n\tPf .xy pnoise-fade =fade_xy\n\t[ n00 n01 ] [ n10 n11 ] fade_xy .x mix =n_x\n\tn_x .x.y fade_xy .y mix 2.3 *\n;\n\n:m apply-contrast (| color value |)\n    color .5 - value 0 max * .5 + 0 1 clamp\n;\n\n:m apply-brightness (| color value |)\n    color value + 0 1 clamp\n;\n\n:m apply-vignette (| color distance intensity |)\n    real-position length distance - =>v\n    v intensity * 0 1 clamp =>v\n    1 v - =>v\n    color v *\n;\n\n:m inv 1 _ - ;\n\n:m tau 6.14318 ;\n:m pi 3.14159 ;\n\n: closest-point-line-ratio (| a b p |)\n    p a - =>pa\n    b a - =>ba\n    pa ba dot ba ba dot / 0 1 clamp\n;\n\n0 =value\n\n: intensity (| t |)\n    1 t 7 * / 0 1 clamp\n;\n\n{ float =frame\n    time 60 * floor 60 / frame 5 / - =>time\n    tau 4 / time 10 / + =angle\n    time 23 / cos abs 2 / .5 + =>a\n    time 27 / cos abs 2 / 1 + =>b\n    \n    frame intensity =i\n    \n    { #5 - float =n\n        angle tau n * - real-position .x 1.5 * -1 1 clamp asin + pi - a / =t\n        b t * angle + sin real-position .y 1.5 * - abs =d\n        d 0 0.01 smoothstep 1 swap - i * max=value\n    } #11 times\n} #10 times\n\n[ 0 value 0 ] =color\n\n    color\n    .8\napply-contrast\n[ 0 1.2 0 ] * =color\n\ncolor 0 .5 apply-vignette =color\n\n[ color 1 ] ->fragColor\n*/\n\nfloat intensity_float_float(float arg_0);\nfloat pnoise_2d_float_vec2(vec2 arg_0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 real_position;\n\tfloat value;\n\tfloat frame;\n\tfloat angle;\n\tfloat i;\n\tfloat n;\n\tfloat t;\n\tfloat d;\n\tfloat pv;\n\tvec3 color;\n\treal_position = ((((fragCoord) / ((iResolution).xy)) * (2.)) - (1.)) * (vec2((((iResolution).xy).x) / (((iResolution).xy).y), 1.));\n\tvalue = 0.;\n\tfor(int tmp_0 = 0; tmp_0 < int(10); ++(tmp_0)) {\n\t\tframe = float(tmp_0);\n\t\tangle = (1.535795) + ((iTime) / (10.));\n\t\ti = intensity_float_float(frame);\n\t\tfor(int tmp_1 = 0; tmp_1 < int(11); ++(tmp_1)) {\n\t\t\tn = float((tmp_1) - (5));\n\t\t\tt = ((((angle) - ((6.14318) * (n))) + (asin(clamp(((real_position).x) * (1.5), -1., 1.)))) - (3.14159)) / (((abs(cos((iTime) / (23.)))) / (2.)) + (0.5));\n\t\t\td = abs((sin(((((abs(cos((iTime) / (27.)))) / (2.)) + (1.)) * (t)) + (angle))) - (((real_position).y) * (1.5)));\n\t\t\tvalue = max(((1.) - (smoothstep(d, 0., 0.01))) * (i), value);\n\t\t}\n\t}\n\tpv = 1.;\n\tcolor = vec3(0., (value) * (pv), 0.);\n\tcolor = (clamp((((clamp((color) + (0.), 0., 1.)) - (0.5)) * (max(0.8, 0.))) + (0.5), 0., 1.)) * (vec3(0., 1.2, 0.));\n\tcolor = (color) * ((1.) - (clamp(((length(real_position)) - (0.)) * (0.5), 0., 1.)));\n\tfragColor = vec4(color, 1.);\n}\n\nfloat intensity_float_float(float arg_0) {\n\treturn clamp((1.) / ((arg_0) * (7.)), 0., 1.);\n}\n\nfloat pnoise_2d_float_vec2(vec2 arg_0) {\n\tvec4 Pi;\n\tvec4 Pf;\n\tvec4 gx;\n\tvec4 gy;\n\tvec4 norm;\n\tvec2 fade_xy;\n\tvec2 n_x;\n\tPi = mod((floor((arg_0).xyxy)) + (vec4(0., 0., 1., 1.)), 289.);\n\tPf = (fract((arg_0).xyxy)) - (vec4(0., 0., 1., 1.));\n\tgx = ((fract((mod(((((mod(((((Pi).xzxz) * (34.)) + (1.)) * ((Pi).xzxz), 289.)) + ((Pi).yyww)) * (34.)) + (1.)) * ((mod(((((Pi).xzxz) * (34.)) + (1.)) * ((Pi).xzxz), 289.)) + ((Pi).yyww)), 289.)) / (41.))) * (2.)) - (1.);\n\tgy = (abs(gx)) - (0.5);\n\tgx = (gx) - (floor((gx) + (0.5)));\n\tnorm = inversesqrt(sqrt(((gx) * (gx)) + ((gy) * (gy))));\n\tfade_xy = ((((((((Pf).xy) * (6.)) - (15.)) * ((Pf).xy)) + (10.)) * ((Pf).xy)) * ((Pf).xy)) * ((Pf).xy);\n\tn_x = mix(vec2(dot((vec2((gx).x, (gy).x)) * ((norm).x), (Pf).xy), dot((vec2((gx).z, (gy).z)) * ((norm).y), (Pf).xw)), vec2(dot((vec2((gx).y, (gy).y)) * ((norm).z), (Pf).zy), dot((vec2((gx).w, (gy).w)) * ((norm).w), (Pf).zw)), (fade_xy).x);\n\treturn (mix((n_x).x, (n_x).y, (fade_xy).y)) * (2.3);\n}\n","name":"Image","description":"","type":"image"}]}