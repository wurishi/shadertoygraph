{"ver":"0.1","info":{"id":"4dBcDG","date":"1494514941","viewed":212,"name":"Tiny RT","username":"TinyTexel","description":"wavelength dependent absorption per octant","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tiny RT\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\na tiny volume path tracing setup\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n*/\n\nconst float Pi = 3.14159265359;\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = floor(fragCoord.xy);\n\tvec2 tex = fragCoord.xy / PixelCount;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    //if(false)\n    {\n    \tcol = 1.0 - exp2(-col * 3.0);\n        col = mix(col, col*col, 0.8);\n    }\n    \n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Tiny RT + Absorption\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\na tiny volume path tracing setup\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n\nThe particle model used here is a bit unusual in that it (implicitly) assumes some particles to \nbehave either non-absorptive + scattering or completely absorptive depending on the color channel.\nThis makes free-flight path sampling and direct light sampling very easy because the particle\ndensity is homogeneous everywhere inside the cube for all color channels.\nOn the downside, directly transmitted light is not receiving any coloring because it doesnt\ninteract with any of the particles (otherwise it would be getting scattered). \nThis becomes more apparent when the extincting coefficient is set to a smaller value like \nsigma_e = 2.0;\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define lerp mix\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\nvec2 If(bvec2 cond, vec2 resT, vec2 resF)\n{\n    vec2 res;\n    res.x = cond.x ? resT.x : resF.x;\n    res.y = cond.y ? resT.y : resF.y;\n\n    return res;\n}\n\nvec3 If(bvec3 cond, vec3 resT, vec3 resF)\n{\n    vec3 res;\n    res.x = cond.x ? resT.x : resF.x;\n    res.y = cond.y ? resT.y : resF.y;\n    res.z = cond.z ? resT.z : resF.z;    \n\n    return res;\n}\n\nvec4 If(bvec4 cond, vec4 resT, vec4 resF)\n{\n    vec4 res;\n    res.x = cond.x ? resT.x : resF.x;\n    res.y = cond.y ? resT.y : resF.y;\n    res.z = cond.z ? resT.z : resF.z;    \n    res.w = cond.w ? resT.w : resF.w;    \n\n    return res;\n}\n\n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggestes by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggestes by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggestes by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc, vec2 llp, float S1, out vec3 glp)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front + (cam.Right * tc.x + cam.Up * tc.y) / cam.AxisLen;\n    \n    glp = cam.Right * llp.x + cam.Up * llp.y;\n    \n    vec3 dir = normalize(imgPos * S1 - glp);\n\n    return dir;\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n\tt = min(ub.x, min(ub.y, ub.z));\t\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t, out vec3 N)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n\tvec3 o = -cth * os;\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n    if(ub.x < ub.y) {t = ub.x; N = vec3(os.x, 0.0, 0.0);} else \n                    {t = ub.y; N = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t   ) {t = ub.z; N = vec3(0.0, 0.0, os.z);}\n    \n\t//t = min(ub.x, min(ub.y, ub.z));\t\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nvoid Intersect_Ray_SphereBackside(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout float t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = min(dot(rp, rp) - sr2, 0.0);\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\t//if(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(max(0.0, D));\n\n\tt = (-b + sqrtD) / a * 0.5;\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(clamp01(1.0 - s1*s1));\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n\n// s [0..1]\nfloat Sample_HenyeyGreensteinPhF(float s, float g)\n{\t\n    if(abs(g) < 0.0001) return s * 2.0 - 1.0;\n\n    float g2 = g * g;\n\n    float t0 = (1.0 - g2) / (1.0 - g + 2.0 * g * s);\n\n    float cosAng = (1.0 + g2 - t0*t0) / (2.0 * g);\n\n    return cosAng;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_HenyeyGreensteinPDF(float s0, float s1, float g, vec3 forward)\n{\t\n    float cosTheta = Sample_HenyeyGreensteinPhF(s1, g);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\n// s [0..1]\nfloat Sample_SchlickPhF(float s, float k)\n{\t\n    float t0 = 1.0 + k - 2.0 * s;\n    float t1 = 1.0 + k - 2.0 * s * k;\n\n    float cosAng = t0 / t1;\n\n    return cosAng;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_SchlickPDF(float s0, float s1, float k, vec3 forward)\n{\t\n    float cosTheta = Sample_SchlickPhF(s1, k);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nfloat HenyeyGreensteinPhF(float cosTheta, float g)\n{\n\tfloat g2 = g * g;\n\t\n\tfloat t0 = 1.0 - g2;\n\tfloat t1 = 1.0 + g2 - 2.0 * g * cosTheta;\n\t\n\t return t0 * rsqrt(max(0.0, t1*t1*t1));\n\t//return t0 * rsqrt(max(1.0e-32, t1*t1*t1));\n}\n\nfloat HenyeyGreensteinPDF(float cosTheta, float g)\n{\n    return HenyeyGreensteinPhF(cosTheta, g) * RcpPi4;\n}\n\n\nfloat FresnelDielectricsP(float ci, float ct, float ni, float nt)\n{\n\tfloat t0 = nt * ci;\n\tfloat t1 = ni * ct;\n\t\n\treturn (t0 - t1) / (t0 + t1);\n}\n\nfloat FresnelDielectricsS(float ci, float ct, float ni, float nt)\n{\n\tfloat t0 = ni * ci;\n\tfloat t1 = nt * ct;\n\t\n\treturn (t0 - t1) / (t0 + t1);\n}\n\nfloat FresnelDielectrics(float ci, float ct, float ni, float nt)\n{\n\tfloat p = FresnelDielectricsP(ci, ct, ni, nt);\n\tfloat s = FresnelDielectricsS(ci, ct, ni, nt);\n\t\n\treturn (p*p + s*s) * 0.5;\n}\n\nvec3 ReflectRay(vec3 ray, vec3 N)\n{\n\tfloat ct = dot(-ray, N);\n\t\n\treturn ray + N * (2.0 * ct);\n}\n\n\n//cos2t (discriminant) < 0 -> total internal reflection\nvec3 RefractRay(vec3 ray, vec3 N, float n1, float n2, out float cos2t)\n{\n\tfloat n = n1 / n2;\n\tfloat NdL = dot(-ray, N);\n\n\tfloat sin2t = n*n * (1.0 - NdL*NdL);\n\tcos2t = 1.0 - sin2t;\n\t\n\tif(cos2t > 0.0)\n\tray = n * ray + (n * NdL - sqrt(cos2t)) * N;\n\t// else\n\t// ray = float3(1.0, 0.0, 0.0);\n\t\n\treturn ray;\n}\n\nvoid ReflRefrDielectrics(vec3 ray, vec3 N, float n1, float n2, \nout vec3 refl, out vec3 refr, out float re)\n{\n\tfloat cos2t;\n\n\trefl = ReflectRay(ray, N);\n\trefr = RefractRay(ray, N, n1, n2, cos2t);\n\t\n\tif(cos2t > 0.0)\n\tre = FresnelDielectrics(dot(-ray, N), sqrt(cos2t), n1, n2);\n\telse\n\tre = 1.0;\n}\n\n//s [0..1]\n// return(passed through boundary)\nbool ReflRefrDielectrics(vec3 ray, vec3 N, float n1, float n2, float s, \nout vec3 rayO)\n{\n\tvec3 refl, refr;\n\tfloat re;\n\tReflRefrDielectrics(ray, N, n1, n2, refl, refr, re);\n\t\n\tif(s < re)\n\t{\n\t\trayO = refl;\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\trayO = refr;\n\t\treturn true;\n\t}\n}\n\n\nconst vec3 PseudoSpectralRGBWeights_Box_W = 1.0 / vec3(0.25, 0.5, 0.25);\nvec3 Sample_PseudoSpectralRGBWeights_Box(float s)\n{\n\tvec3 fw = vec3(0.0);\n\t\n\tif(s < 0.25) fw.x = 1.0;\n\telse \n\tif(s < 0.75) fw.y = 1.0;\n\telse\t\t fw.z = 1.0;\n\t\n\treturn fw;\n}\n\nconst vec3 PseudoSpectralRGBWeights_Tri_W = vec3(3.0);\nvec3 Sample_PseudoSpectralRGBWeights_Tri(float s)\n{\n\tvec3 fw;\n\t\n    s = s * 3.0;\n    \n    if(s < 1.0)\n    {\n        s *= 2.0;\n\n        float u = sqrt(s < 1.0 ? s : 2.0 - s);\n\n        if(s < 1.0) \n        {\n            fw.x = 2.0 - u;\n            fw.y = 1.0 - fw.x;\n            fw.z = 0.0;\n        }\n        else\n        {\n            fw.z = 2.0 - u;\n            fw.y = 1.0 - fw.z;\n            fw.x = 0.0;\n        }\n    }\n    else\n    {\n        s -= 1.0;\n        s *= 0.5;\n        \n        if(s < 0.5)\n        {\n            fw.z = 0.0;\n            fw.y = s * 2.0;\n            fw.x = 1.0 - fw.y;\n        }\n        else\n        {\n            fw.x = 0.0;\n            fw.z = s * 2.0 - 1.0;\n            fw.y = 1.0 - fw.z;\n        }\n    }\n    \n\treturn fw;\n}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n    vec2 ang = vec2(Pi * 0.25, Pi * 0.2);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    \n    float cdist = exp2(1.8 + mouseAccu.w * 0.02);\n    vec3 cpos = -cam.Front * cdist;\n   // cpos.y -= 1.0;\n\n    float fId = frameAccu * 1.64683 + 0.84377;\n    \n    vec3 pxId  = vec3(frameAccu, uv); \n         pxId *= vec3( 0.76032, 1.47035, 0.92526); \n         pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    uint hh = HashUInt(pxId, uvec3(0xB8D3E97Cu, 0x736D370Fu, 0xA7D00135u));\n    \n    {\n        vec2 off;\n        {\n        \tfloat h0 = Hash(fId, 0xAF609A13u);\n        \tfloat h1 = Hash(fId, 0xE0ABC868u);\n        \n        \t//off = vec2(h0, h1) * 0.5;\n        \toff = vec2(Sample_Triangle(h0), Sample_Triangle(h1));\n        }\n                      \n        tex21 = (uv0.xy + off) / PixelCount * 2.0 - vec2(1.0);\n    }\n    \n    vec2 llp = vec2(0.0);// local sample pos on lens\n    if(false)\n    {\n        float h0 = HashFlt(hh, 0x27BB116Bu);\n        float h1 = HashFlt(hh, 0x11A95B42u);\n\t\th1 = clamp01(h1 * 0.5 + 0.5);\n\n        llp = Sample_Disk(h0, h1);\n        llp *= 0.005;\n    }\n    \n    vec3 glp;// global sample pos on lens\n    float S1 = cdist - 0.0;// set cube ~sharp\n    vec3 rdir = NewRay(cam, tex21, llp, S1, OUT glp);\n \n    \n    vec2 lightAng = vec2(Pi * 0.3, 0.2 * Pi);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    vec3 lightp;\n    {\n        float h0 = HashFlt(hh, 0x9E2355B4u);\n        float h1 = HashFlt(hh, 0xDC305E12u);\n        h1 = clamp01(h1 * 0.5 + 0.5);\n        \n        h1 = mix(0.999, 1.0, h1);\n        \n        lightp = Sample_Sphere(h0, h1, light);\n    }\n    \n    vec3 colW0, colW;\n    {\n        //float h0 = Hash(fId, 0x7F1489B8u);\n        float h0 = HashFlt(hh, 0x7F1489B8u);\n              h0 = clamp01(h0 * 0.5 + 0.5);\n        \n        //float ivals = 4.0;\n        //h0 = (mod(frameAccu, ivals) + h0) / ivals;\n        \n        colW0 = Sample_PseudoSpectralRGBWeights_Tri(h0);\n        colW = clamp01(colW0);\n    }\n    \n    //light = vec3(0.0, 1.0, 0.0);\n    float pot = 1.0;\n    float val = 0.0;\n    \n    float t = -1.0; vec2 tt;\n    vec3 pos = cpos + glp;\n    vec3 dir = rdir;\n\n    vec3 sigma_a_min = vec3(0.01);            \n    vec3 sigma_a_max = vec3(4.0);\n    \n\tfloat n2 = 1.01;\n\n    n2 = max(1.0, dot(vec3(1.15, 1.13, 1.11), colW0));\n    //n2 = dot(vec3(1.3083, 1.3111, 1.3163), colW);// ice\n    \n    \n    bool exit = false;\n    bool scattered = false;\n    \n    vec3 N0, N1;\n    bool hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(1.0), OUT tt, N0, N1) > 0.0;\n    \n    //vec3 N0, N1;\n    //bool hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), Pow2(1.0), OUT tt) > 0.0;\n    //N0 = normalize(pos + dir * tt.x);\n    \n\tif(hit)\n    {\n        pos += dir * tt.x;\n        \n        vec3 refl, refr;\n        float re;\n        ReflRefrDielectrics(dir, N0, 1.0, n2, refl, refr, re);\n\n        \n\t\tval += dot(texture(iChannel2, refl).rgb, colW) * re;     \n        if(dot(refl, light) > 0.999) val += dot(vec3(3.0 * Pi), colW) * re;\n        \n        pot *= 1.0 - re;\n        dir = refr;\n        \n        \n        for(float i = 0.0; i < 32.0; ++i)\n        {\n            hh = Hash(hh);\n            \n            Intersect_Ray_CubeBackside(pos, dir, vec3(0.0), vec3(1.0), OUT t, N0);\n\n            //Intersect_Ray_SphereBackside(pos, dir, vec3(0.0), Pow2(1.0), OUT t);\n    \t\t//N0 = -normalize(pos + dir * t);\n            \n            vec3 pos0 = pos + dir * t;\n            \n            \n            bvec3 cond0 = greaterThan(pos0, vec3(0.0));\n            bvec3 cond1 = greaterThan(pos , vec3(0.0));\n            \n            vec3 sigma_a0 = If(cond0, sigma_a_max, sigma_a_min);\n            vec3 sigma_a1 = If(cond1, sigma_a_max, sigma_a_min);\n            \n            vec3 sigma_a = If(equal(cond0, cond1), \n                              sigma_a0, \n                              mix(sigma_a0, sigma_a1, abs(pos) / (abs(pos) + abs(pos0))));\n                              \n            pot *= exp(-dot(sigma_a, colW) * t);\n            \n            \n            pos = pos0;\n\n            float h0 = HashFlt(hh, 0x2C2E74DAu);\n            h0 = clamp01(h0 * 0.5 + 0.5);\n\n            if(ReflRefrDielectrics(dir, N0, n2, 1.0, h0, OUT dir))\n            {\n                exit = true;\n\n                break;\n            }\n            else\n            {\n                continue;\n            }\n  \n        }\n    }\n\n    \n   // if(false)\n    if(!hit || exit)\n    {\n        val += pot * dot(texture(iChannel2, dir).rgb, colW);\n        \n        if(!scattered)\n        {\n            if(dot(dir, light) > 0.999) val += pot * dot(vec3(3.0 * Pi), colW);\n        }\n            \n        //col += 1.0;\n    }\n    \n    //if(false)\n    //if(hit && !exit)\n    //{\n    //    col = vec3(1.0, 0.0, 0.0);\n    //}\n    \n    vec3 col = colW * val * PseudoSpectralRGBWeights_Tri_W;\n    \n    \n    vec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n    \n    outCol = vec4(col, 0.0);\n    \n    \n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}