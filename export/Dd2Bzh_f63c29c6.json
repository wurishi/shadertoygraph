{"ver":"0.1","info":{"id":"Dd2Bzh","date":"1690252683","viewed":93,"name":"simple genrative art","username":"chenxianming","description":"the backgriund wasted more than 1000chars\nclip of animation loop download for free\nhttp://benchart.cn/prismcolor_1440x2560@x2_60fps.mp4","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["generativeart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define TAU 6.2831852\n#define T(s) fract(iTime *s) * PI * 4.\n#define T2(s ,b) fract(iTime * s) * b\n#define prisma 0\n#define merge prisma == 1 ? 0.01 : .1\n\n// texture base on\n// https://www.shadertoy.com/view/DsBBR1\n\nfloat h(in vec2 a) { return dot(a, a); }\nfloat i(in vec2 c, in vec2 a, in vec2 d) {\n  vec2 e = c - a, b = d - a;\n  return h(e - b * clamp(dot(e, b) / dot(b, b), 0., 1.));\n}\nmat2 f(float a) {\n  float b = sin(a), c = cos(a);\n  return mat2(c, b, -b, c);\n}\nmat2 rotation(float a) {\n  float b = sin(a), c = cos(a);\n  return mat2(c, b, -b, c);\n}\n\nfloat j(vec2 d) {\n  float c = .1;\n  for (float a = 0.; a < 35.; a++) {\n    float b = a + 1.;\n    if (a > 34.)\n      break;\n    float e = cos(a / 35. * 10.5 * 6.28) * .1 * (a / 5.),\n          k = sin(a / 35. * 10.5 * 6.28) * .1 * (a / 5.),\n          l = cos(b / 35. * 10.5 * 6.28) * .1 * (b / 5.),\n          m = sin(b / 35. * 10.5 * 6.28) * .1 * (b / 5.);\n    c = min(c, i(d, vec2(e, k), vec2(l, m)));\n  }\n  return c;\n}\nvec2 g(inout vec2 b, vec2 a) {\n  vec2 c = a * .5, d = floor((b + c) / a);\n  b = mod(b + c, a) - c;\n  return d;\n}\nfloat n(vec2 a) {\n  float b = .1;\n  a.y += T2( .125, .5 );\n  vec2 c = g(a, vec2(.3, .25));\n  \n\n  a.xy *= mod(c.x, 2.) == 0. ? f(PI * .125) : f(PI * .5), \n  a.xy *= mod(c.x, 2.) == 0. ? 1.1 : 1.5, b = min(b, j(a * 3.5));\n  return b;\n}\nvec3 texMap2( vec2 a ){\n  a = (a - .5) * 2., a.x *= iResolution.x / iResolution.y;\n  vec3 c = vec3(0);\n  float b = .1;\n  a *= f(.785398), b = n(a), b = smoothstep(0., b, 1e-4), c += b;\n  return c;\n}\n\n// textureEND\n\nint hit = 0;\n\nfloat smin(float a, float b, float r) {\n  float h = clamp(.5 + .5 * (b - a) / r, 0., 1.);\n  return mix(b, a, h) - r * h * (1. - h);\n}\n\nfloat smax(float a, float b, float c) { return -smin(-a, -b, c); }\n\nvec4 oCol = vec4(0.);\nvec4 iCol = vec4(0.);\n\nfloat calcGeometry( vec3 p, float s ){\n    float d = .1;\n    float py = 1.;\n    #if prisma == 1\n    \n    py = p.y;\n\n    py = abs( py ) - .5; // equal to each side\n    py = abs( py );\n    \n    #endif\n    \n    d = smax(\n      smax( abs( p.x ) - .5 * py, abs( p.z ) - .5 * py, s ),\n      abs( p.y ) - .5,\n      s\n    );\n    \n    return d;\n}\n\nfloat map(vec3 p)\n{\n  float d = 5.0;\n  \n\n  p.xz *= rotation( T(.025) );\n  p.zy *= -rotation( T(.05) );\n  \n  d = smin(\n      d,\n      calcGeometry( p, merge * .5 ),\n      merge\n  );\n\n  p.xz *= -rotation( T(.05) );\n  p.zy *= rotation( T(.075) );\n\n  d = smin(\n      d,\n      calcGeometry( p, merge * .5 ),\n      merge\n  );\n\n  p.zy *= rotation( T(.075) );\n  p.xy *= -rotation( T(.025) );\n  d = smin(\n      d,\n      calcGeometry( p, merge * .5 ),\n      merge\n  );\n\n  if( hit == 1 ){\n      oCol.a = d;\n\n  }else{\n      iCol.a = d;\n  }\n\n  return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos) {\n  vec2 e = vec2(1.0, -1.0) * 0.5773;\n  const float eps = 0.0005;\n  return normalize(\n      e.xyy * map(pos + e.xyy * eps) + e.yyx * map(pos + e.yyx * eps) +\n      e.yxy * map(pos + e.yxy * eps) + e.xxx * map(pos + e.xxx * eps));\n}\n\nvec3 texMap(vec2 uv) {\n\n  float p = 0.0;\n  \n  for (float i = 0.; i < 7.; i++) {\n\n    uv.x += cos(uv.y * (i + 3.)) * .06;\n    uv.y += cos(uv.y * (5. - i)) * .06;\n\n    p = mix(p, 1., smoothstep(0.1, length(uv) - i * .3, 0.));\n  }\n\n  return vec3(sin(uv.y - p * 1.8), abs(uv.y - .5), abs(uv.y - .5));\n}\n\nfloat trace(inout vec3 pos, inout float dist, inout float t, vec3 ro, vec3 rd,\n            int count) {\n\n  for (int i = 0; i < 64; i++) {\n    pos = ro + rd * t;\n    dist = map(pos);\n\n    if (t > 1e3) {\n      break;\n    }\n\n    t += dist;\n  }\n\n  return 1.;\n}\n\nvoid raymarching(vec3 ro, vec3 rd) {\n  hit++;\n\n  float t = 0., tr = 0., dist = 0.;\n\n  vec3 pos = vec3(0.);\n\n  vec3 lig = normalize(vec3(.57703));\n  lig.xy *= rotation(-T(.5));\n  vec3 hal = normalize(lig - rd);\n\n  tr = trace(pos, dist, t, ro, rd, 1);\n\n  if (dist < 1e-3) {\n    vec3 nor = calcNormal(pos);\n\n    float amb = dot(nor, vec3(0., -0.3, 0.));\n    \n    vec3 vd = vec3(.5, .5, -.3);\n    vd.xz *= rotation( T( 1. ) );\n    \n    vec3 vd2 = vec3(.0, -.5, .3);\n    vd2.xz *= rotation( T( 1. ) );\n    \n    float dif = clamp(dot(nor, vd), 0.0, 1.0);\n    float dif2 = clamp(dot(nor, vd2), 0.0, 1.0);\n    float dif3 = clamp(dot(nor, vec3(.5, -1.1, -5.1)), 0.0, 1.0);\n\n    float spe = pow(clamp(dot(nor, hal), 0.52, 2.0), 10.);\n    spe *= dif + dif2;\n\n    vec3 g = reflect(nor, rd * .6);\n\n    iCol.rgb =\n        dif * texMap(g.xy) + dif2 * texMap(g.xy) + dif3 * texMap(g.xy) * .15;\n    iCol.rgb += sign(iCol.rgb) * .5;\n    iCol.rgb += vec3(spe * vec3(.5)) +\n                (0.5 + 0.35 * cos((dif) + rd.xyx * 2.0 + vec3(0, 2, 4))) * .7;       \n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 vv2 = fragCoord / iResolution.xy;\n  uv = (uv - .5) * 2.;\n\n  uv.x *= iResolution.x / iResolution.y;\n\n  // Time varying pixel color\n  vec3 col = vec3(0.);\n\n  vec3 ro = vec3(0., 0., prisma == 0 ? -1.5 : -2.);\n  vec3 rd = vec3(uv, 1.);\n  #if prisma == 1\n  rd.xy *= .4;\n  #endif\n  \n  raymarching(ro, rd);\n  rd.xy *= 1.06;\n  raymarching(ro, rd);\n\n  oCol.a = mix(oCol.a, 1., iCol.a);\n\n  oCol.a = clamp(oCol.a, 0., 1.);\n  iCol.a = clamp(iCol.a, 0., 1.);\n\n  col = vec3(0.35, 0.63, 0.81);\n\n  col = mix(col, vec3(0.15, 0.50, 0.73), 1. - texMap2(vv2));\n\n  col *= mix(vec3(0.37, 0.40, 0.42), vec3(1.5), vv2.y) * .8;\n\n  col = mix(col, vec3(0.38, 0.46, 0.51), .6);\n\n  col = mix(\n      col, vec3(2.) * col,\n      1. - smoothstep(0., .17, length(uv * vec2(.1, 1.) + vec2(0., .1)) - .01));\n\n  col = mix(col, vec3(0.66, 0.80, 0.89) * 1.3, oCol.a * .1);\n\n  col = mix(col, iCol.rgb, 1. - iCol.a);\n\n  // col = vec3( 0. );\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}