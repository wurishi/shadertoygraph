{"ver":"0.1","info":{"id":"lsXfW2","date":"1503352366","viewed":353,"name":"Menger Sponger Cross Section","username":"Polygon","description":"I found a way to modify my voxel raytracer to render the Menger Sponge with relatively few iterations, even for high order Menger Sponges!\nI then sliced it, making the cross-sections visible.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","voxels","mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ORDER 4\n#define FOV 100.\n\n//Don't mess with these.\n#define pi 3.14159265\n#define d2r 0.0174533\n#define WIDTH int(pow(3., float(ORDER)))\n#define TIME iTime * 0.75\n\nvec4 render(vec2 coord);\nint modint(int a, int b) {return a - a/b*b;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = render(fragCoord.xy);\n}\n\n\n\nvec4 render(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv -= .5;\n    \n    float maxRes = max(iResolution.x, iResolution.y);\n    vec2 s = coord.xy / maxRes - vec2(0.5 * iResolution.x / maxRes, 0.5 * iResolution.y / maxRes);\n    \n    vec2 uvM = iMouse.xy / iResolution.xy - .5;\n    \n    \n    vec2 rot = 5.*vec2(-uvM.x,-uvM.y);\n    vec3 pos = -1.75 * float(WIDTH) * vec3(sin(rot.x) * cos(rot.y), sin(rot.y), cos(rot.x) * cos(rot.y)) + float(WIDTH) / 2.;\n    \n    vec3 d = vec3(2.0 * s.x * tan(d2r * FOV / 2.0), 2.0 * s.y * tan(d2r * FOV / 2.0), 1.0);\n    d = normalize(d);\n    \n    //Rotations\n    d = vec3(d.x, d.y * cos(rot.y) + d.z * sin(rot.y), d.z * cos(rot.y) - d.y * sin(rot.y));\n    d = vec3(d.x * cos(rot.x) + d.z * sin(rot.x), d.y, d.z * cos(rot.x) - d.x * sin(rot.x));\n    \n    \n    vec4 sky = vec4(0.5 - 0.5 * sin(d.y), 0.7 - 0.3 * sin(d.y),1.0,0.0);\n    vec4 o = sky;\n    \n    \n    vec3 bounderies = vec3(WIDTH) * (0.5 - 0.5 * sign(d));\n    vec3 t = (bounderies - pos) / d;\n    \n    vec3 mask = vec3(greaterThanEqual(t.xyz, max(t.yzx, t.zxy)));\n    \n    if (dot(t, mask) < 0.)\n        return sky;\n    \n    vec3 endPos = (1. - mask) * (pos + d * dot(t, mask))   +   mask * bounderies;\n    \n    //MAIN LOOP\n    for (int j = 0; j < 10; j++) {\n        \n        bool plane = false;\n        \n        if ((endPos.x - float(WIDTH) / 2.)*sin(TIME) + (endPos.z - float(WIDTH) / 2.)*cos(TIME) + (endPos.y - float(WIDTH) / 2.)*sin(TIME/3.14) > (.25 + sin(TIME * 1.4) / 4.) * float(WIDTH)) {\n            plane = true;\n            float T = -(sin(TIME)*(pos.x - float(WIDTH) / 2.) + cos(TIME)*(pos.z - float(WIDTH) / 2.) + (pos.y - float(WIDTH) / 2.)*sin(TIME/3.14) - (.25 + sin(TIME * 1.4) / 4.) * float(WIDTH)) / (sin(TIME)*d.x + cos(TIME)*d.z + sin(TIME/3.14)*d.y);\n            endPos = (pos + d*T);\n        }\n        \n        if (max(endPos.x, max(endPos.y, endPos.z)) > float(WIDTH) || min(endPos.x, min(endPos.y, endPos.z)) < 0.)\n            break;\n        \n        vec3 lastEntered = vec3(equal(endPos, floor(endPos)));\n        ivec3 enter = ivec3(floor(endPos) - (.5 + .5 * -sign(d)) * lastEntered);\n        \n        bvec3 inf;\n        int num = WIDTH / 3;\n        for (int i = 0; i < ORDER; i++) {\n            \n            bvec3 thing = bvec3(!(bool(modint(enter.y / num - 1, 3)) || bool(modint(enter.z / num - 1, 3))), !(bool(modint(enter.x / num - 1, 3)) || bool(modint(enter.z / num - 1, 3))), !(bool(modint(enter.x / num - 1, 3)) || bool(modint(enter.y / num - 1, 3))));\n            \n            if (thing.x || thing.y || thing.z) {\n                \n                if (thing.x && thing.y && thing.z)\n                    inf = bvec3(0);\n                else\n                    inf = thing;\n                \n                break;\n            }\n            \n            num /= 3;\n        }\n        \n        if (num == 0) {\n            o = vec4(1);\n            float dist = distance(endPos, pos);\n            \n            vec3 normal = sign(d) * (lastEntered);\n            if (plane) normal = vec3(sin(iTime), 0, cos(iTime));\n            \n            vec3 lightPos = pos;\n            \n            o = vec4(0);\n            o.xy = vec2(dot(normalize(-lightPos + float(WIDTH) / 2.), normal));\n            o.xy = o.xy / 2. + .5;\n            if (plane) o.xyz = vec3(1,0,0);\n            \n            o /= (dist * dist / float(WIDTH * WIDTH) / 4. + 1.);\n            break;\n        }\n        \n        ivec3 nextPlane = num * (enter / num) + num * ivec3(.5 + .5 * sign(d));\n        //ivec3 nextPlane = enter + (ivec3(sign(d)) + 1) / 2;\n        \n        nextPlane += 10000 * ivec3(inf) * ivec3(floor(sign(d)));\n        \n        vec3 distToNext = (vec3(nextPlane) - endPos) / d;\n        bvec3 mask = lessThanEqual(distToNext.xyz, min(distToNext.yzx, distToNext.zxy));\n        float time = dot(distToNext, vec3(mask));\n        \n        endPos = vec3(mask) * vec3(nextPlane) + (endPos + d * time) * (1. - vec3(mask));\n        \n    }\n    \n    \n    return o;\n}\n\n\n/*\nbool check(vec3 pos) {\n    ivec3 uv = ivec3(pos);\n    \n    int num = WIDTH;\n    for (int i = 0; i < ORDER; i++) {\n        num /= 3;\n        if (!((bool(modint(uv.x / num - 1, 3)) || bool(modint(uv.y / num - 1, 3)) && bool(modint(uv.z / num - 1, 3))) && (bool(modint(uv.y / num - 1, 3)) || bool(modint(uv.z / num - 1, 3)))))\n            return false;\n    }\n    \n    return true;\n}\n*/","name":"Image","description":"","type":"image"}]}