{"ver":"0.1","info":{"id":"lctfW7","date":"1733230471","viewed":56,"name":"Cold and Alone","username":"archon","description":"a simple lonely landscape....","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-------------------------------------------------------SDF FUNCTIONS by Inigo Quilez--------------------------------------------------------------------------------------------------------------\n\n#define FOG_START 10.0   // Distancia a la que empieza la niebla\n#define FOG_END   15.0   // Distancia a la que se mezcla completamente la niebla\n#define GOD_RAYS_STRENGTH 0.3\n#define GOD_RAYS_INTENSITY 2.5\n#define GOD_RAYS_NUM_SAMPLES 10\n\nvec3 applyFog(vec3 color, float dist) {\n    float fogFactor = clamp((dist - FOG_START) / (FOG_END - FOG_START), 0.0, 1.0);\n    return mix(color, vec3(0.141,0.102,0.196), fogFactor);\n}\nfloat roughness = 0.1;              \nvec3 specularReflection(vec3 normal, vec3 lightDir, vec3 viewDir) {\n    vec3 halfVec = normalize(lightDir + viewDir); \n    float spec = pow(max(dot(normal, halfVec), 0.0), 1.0 / roughness);\n    return vec3(1.0) * spec;  \n}\nfloat camYaw = 0.0;  \nfloat camPitch = 0.0; \n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat sdTrunk(vec3 p, float h, float r) {\n    float dist = length(p.xz) - r;  \n    return max(dist, p.y - h);\n}\n\nfloat sdCone(vec3 p, vec2 c, float h) {\n    vec2 q = h * vec2(c.x / c.y, -1.0);\n    vec2 w = vec2(length(p.xz), p.y);\n    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(b, b));\n    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n    return sqrt(d) * sign(s);\n}\n\nfloat sdPlane(vec3 p, float h) {\n    return p.y - h; \n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim )\n{\n    return p-s*clamp(round(p/s),-lim,lim);\n}\nfloat sdWaterDistortion(vec3 p, float radius) {\n    float timeFactor = sin(iTime * 0.1) * 0.1;\n    p.xz += vec2(sin(p.y + timeFactor), cos(p.y - timeFactor)) * 0.05;\n    float dist = length(p.xz) - radius;\n    return max(dist, p.y + 0.05);\n}\n\n\nfloat mapDistance(in vec3 p) {\n    float plane = sdPlane(p, -0.3); \n    if (p.y > plane) {\n        return plane; \n    }\n    p.xz = opRepLim(p.xz, 5.0, vec2(4.0, 2.0));\n    float waterDist = sdWaterDistortion(p, 1.0);\n    float trunk = sdTrunk(p - vec3(0., -0.2, 0.15), 1.0, 0.04); \n    float cone1 = sdCone(p - vec3(0, 0.2 + 0.09, 0.14), vec2(0.1, 0.05), 0.2);  \n    float cone2 = sdCone(p - vec3(0, 0.48 + 0.09, 0.14), vec2(0.2, 0.20), 0.3);  \n    float cone3 = sdCone(p - vec3(0, 0.85 + 0.09, 0.14), vec2(0.3, 0.5), 0.4);    \n    return min(min(min(min(trunk, cone1), min(cone2, cone3)), plane),waterDist);\n}\n\nvec3 cellShade(vec3 normal, vec3 lightDir, bool isTrunk) {\n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 trunkColor = vec3(0.6, 0.3, 0.1);  \n    vec3 coneColor = vec3(0.1, 0.8, 0.1); \n    float dayNightCycle = (sin(iTime * 0.1) + 1.0) * 0.5; \n    vec3 dayColor = vec3(0.737,0.498,0.220);\n    vec3 nightColor = vec3(0.106,0.098,0.420);\n    vec3 foliageColor = mix(dayColor, nightColor, dayNightCycle);\n    vec3 baseColor = isTrunk ? trunkColor : vec3(0.090,0.027,0.314);\n    float level = floor(diff * 4.0) / 4.0;  \n    if (level == 0.0) {\n        return baseColor * 0.2; \n    } else if (level == 0.25) {\n        return baseColor * 0.4;  \n    } else if (level == 0.5) {\n        return baseColor * 0.6;  \n    } else if (level == 0.75) {\n        return baseColor * 0.8;  \n    } else {\n        return baseColor;  \n    }\n}\n\n\nvec3 CalcNormal(in vec3 p) {\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize(vec3(mapDistance(p + e.xyy) - mapDistance(p - e.xyy),\n                          mapDistance(p + e.yxy) - mapDistance(p - e.yxy),\n                          mapDistance(p + e.yyx) - mapDistance(p - e.yyx)));\n}\n\nfloat CastRay(in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + t * rd;\n        float h = mapDistance(p);\n        t += h;\n        if (h < 0.001) break;\n        if (t > 20.0) break;\n    }\n    if (t > 20.0) t = -1.0;\n    return t;\n}\n\nvec3 reflectRay(vec3 normal, vec3 viewDir) {\n    return reflect(viewDir, normal);\n}\n\nvec3 perturbReflection(vec3 reflectionDir, float roughness, vec3 normal, vec3 viewDir) {\n    vec2 randomSeed = vec2(dot(normal, viewDir), dot(normal, reflectionDir));\n    vec3 perturbation = texture(iChannel0,randomSeed).rgb;\n    perturbation *= roughness;\n    return normalize(reflectionDir + perturbation);\n}\n\nvec3 calculateReflection(vec3 p, vec3 normal, vec3 ro, vec3 rd, float roughness) {\n    vec3 reflectedDir = reflectRay(normal, rd);\n    reflectedDir = perturbReflection(reflectedDir, roughness, normal, rd);\n    float tReflect = CastRay(p + normal * 0.001, reflectedDir);\n    if (tReflect > 0.0) {\n        vec3 reflectionPoint = p + reflectedDir * tReflect;\n        vec3 reflectionNormal = CalcNormal(reflectionPoint);\n        vec3 reflectionColor = vec3(0.0);\n        reflectionColor = cellShade(reflectionNormal, normalize(ro - reflectionPoint), true);\n        return reflectionColor * 0.15;\n    }\n    return vec3(0.0);\n}\nfloat shadow(vec3 ro, vec3 rd) {\n    float t = CastRay(ro, rd);\n    return t > 0.0 ? 0.5 : 1.0;\n}\nvec3 godRays(vec3 ro, vec3 rd, vec3 sunDir) {\n    vec3 godRaysColor = vec3(0.0);\n    float t = 0.0;\n    float totalLength = 0.0;\n\n    for (int i = 0; i < GOD_RAYS_NUM_SAMPLES; i++) {\n        t += 0.1;\n        vec3 p = ro + t * rd;\n\n        float sunDist = length(p - sunDir);\n        float intensity = exp(-sunDist * GOD_RAYS_INTENSITY);\n        godRaysColor += intensity * vec3(1.0, 0.9, 0.7); \n        totalLength += t;\n    }\n    godRaysColor *= GOD_RAYS_STRENGTH / totalLength;\n    return godRaysColor;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float mouseX = iMouse.x / iResolution.x;\n    float mouseY = iMouse.y / iResolution.y;\n    float angleX = mouseX * 2.0 * 3.14159265;\n    float angleY = mouseY * 3.14159265;\n    mat3 rotationMatrixX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(angleY), -sin(angleY),\n        0.0, sin(angleY), cos(angleY)\n    );\n    mat3 rotationMatrixY = mat3(\n        cos(angleX), 0.0, sin(angleX),\n        0.0, 1.0, 0.0,\n        -sin(angleX), 0.0, cos(angleX)\n    );\n    mat3 rotationMatrix = rotationMatrixY * rotationMatrixX;\n    vec3 sunPosition = rotationMatrix * vec3(0.0, 2.0, 5.0);\n    vec3 lightDir = normalize(sunPosition - vec3(0.0, 0.0, 0.0));\n    vec3 ta = vec3(2.0, 0.0, 0.0);\n    vec3 ro = vec3(1.0 * sin(iTime*0.2), 0.0, 1.0 * cos(iTime*0.2));\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n    float t = CastRay(ro, rd);\n    vec3 p = ro + t * rd;\n    vec3 col = vec3(0.306,0.145,0.455);\n    if (t > 0.0) {\n    vec3 normal = CalcNormal(p);\n    bool isTrunk = (mapDistance(p) == sdTrunk(p - vec3(0.0, -0.2, 0.0), 1.0, 0.04));\n    col = cellShade(normal, lightDir, isTrunk);\n    vec3 spec = specularReflection(normal, lightDir, ro - p);\n    col += spec * 0.3;\n    vec3 reflection = calculateReflection(p, normal, ro, rd,0.5);\n    col += reflection;\n    float shadowFactor = shadow(p + normal * 0.001, lightDir);\n    col *= shadowFactor;\n    vec3 godRayColor = godRays(p, rd, vec3(0.357,0.333,0.447)); \n    col += godRayColor;    \n    }\n    col = applyFog(col, t);\n    col=pow(col,vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}\n//yokoso watashi no soul society\n","name":"Image","description":"","type":"image"}]}