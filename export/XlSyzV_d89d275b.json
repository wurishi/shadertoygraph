{"ver":"0.1","info":{"id":"XlSyzV","date":"1509142961","viewed":572,"name":"mouth opens when approaching","username":"mds2","description":"attempts to use optical flow to make a mouth that opens wider as one approaches.","likes":3,"published":1,"flags":34,"usePreview":0,"tags":["optical","flow","halloween","vision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Uses optical flow to detect when something near the center of the video\n * frame is moving towards the camera.\n *\n * https://en.wikipedia.org/wiki/Optical_flow\n *\n * Optical flow computed with a technique like that in\n * https://www.shadertoy.com/view/XlBcRV\n * which tries to use this method for optical flow\n * https://en.wikipedia.org/wiki/Lucas%E2%80%93Kanade_method\n *\n * The intent was to try to get this running on a smartphone with a camera\n * that could be, then, inserted into the mouth of a halloween pumpkin\n * (see https://en.wikipedia.org/wiki/Jack-o%27-lantern )\n * to make a pumpkin with a glowy toothy mouth that opens whenever anyone\n * moves towards it.\n */\n\n// set PASSTHROUGH to 1 to see the underlying motion data.\n#define PASSTHROUGH 0\n\n#if PASSTHROUGH\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = 0.5 * texture(iChannel0, vec2(0.5)) +\n        0.5 * textureLod(iChannel2, uv, 3.0);\n}\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float open = texture(iChannel0, vec2(0.5)).r;\n    \n    vec2 ellipse_coord = (uv - vec2(0.5)) * vec2(1.0, 2.0 - 1.5 * open);\n\tfloat rad_squared = dot(ellipse_coord, ellipse_coord);\n    float mouthness = smoothstep(0.21, 0.18, rad_squared);\n    float lipness = mouthness + smoothstep(0.28, 0.29, rad_squared);\n    vec2 lipcoord = uv - vec2(0.5);\n    lipcoord = lipcoord * vec2(0.8 + smoothstep(0.0, 1.0, rad_squared));\n    float lipcolor = (1.0 - lipness) * \n        texture(iChannel1, \n               vec2(0.5) + lipcoord ).r;\n    \n    float jaggie1 = uv.y - mod(open + uv.x * 20.0, 1.0);\n    \n    float jaggie2 = uv.y - mod(-1.2 * open + uv.x * 20.0 - 8.0, 1.0);\n    float jaggie =\n        smoothstep(0.4, 0.5, jaggie1) + smoothstep(-0.4, -0.5, jaggie2);\n    float teeth = jaggie * mouthness;\n\tfragColor = vec4(lipcolor + teeth, teeth, teeth, 1.0);\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * Calculates \"optical flow\" using a technique based on\n * https://en.wikipedia.org/wiki/Lucas%E2%80%93Kanade_method\n *\n * Deconstructs the matrix operations in that method into a summation\n * of small, local, 2x2 and 2x1 matrices, in order to allow the math\n * to be computed using glsl.\n */\n\nconst float lod = 3.0;\nconst float lodscale = 8.0; // 2 ^ lod\n\n\nfloat intensity(vec2 loc, float time) {\n\tfloat i0 = dot(textureLod(iChannel0, loc, lod).rgb, vec3(1.0));\n    float i1 = dot(textureLod(iChannel1, loc, lod).rgb, vec3(1.0));\n    return mix(i0, i1, time);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // lucas-kanade optical flow \n    // https://en.wikipedia.org/wiki/Lucas%E2%80%93Kanade_method\n    mat2 AtA = mat2(0.0, 0.0, 0.0, 0.0);\n    vec2 Atb = vec2(0.0, 0.0);\n    vec2 p = (fragCoord.xy - vec2(5.0)) /iResolution.xy;\n    float xstart = p.x;\n    vec2 px_step = lodscale / iResolution.xy;\n    for (int i = 0; i < 11; ++i) {\n        p.x = xstart;\n        for (int j = 0; j < 11; ++j) {\n            float I = intensity(p, 0.0);\n            float It = I - intensity(p, 1.0);\n            float Ix = intensity(p + vec2(1.0, 0.0) * px_step, 0.0) - I;\n            float Iy = intensity(p + vec2(0.0, 1.0) * px_step, 0.0) - I;\n            \n            AtA += mat2(Ix * Ix, Ix * Iy, Ix * Iy, Iy * Iy);\n            Atb -= vec2(It * Ix, It * Iy);\n            p.x += px_step.x;\n        }\n        p.y += px_step.y;\n    }\n    mat2 AtAinv = mat2(AtA[0][0], -AtA[0][1], -AtA[1][0], AtA[1][1]) /\n        (AtA[0][0] * AtA[1][1] - AtA[1][0] * AtA[0][1]);\n    \n    vec2 flow = AtAinv * Atb;\n    \n    fragColor = vec4(0.5 + 0.1 * flow,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n * Passthrough for webcam -- lets Buffer A have access to a copy of the\n * video frame from one frame ago.\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/**\n * Takes the integral, around a closed loop, of the dot product of optical\n * flow with a vector pointing outward (or is it inward?) from the loop.\n *\n * Rough approximation of whether stuff at the current pixel is moving towards\n * or away from the camera.\n */ \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ringsize = 50.0 / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    mat2 rotstep = mat2(0.9980267284282716, 0.06279051952931337,\n                        -0.06279051952931337, 0.9980267284282716);\n    vec2 sin_cos = vec2(1.0, 0.0);\n    float integral = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        \n        vec2 flowval = texture(iChannel0, uv + ringsize * sin_cos).rg -\n            vec2(0.5);\n        \n        integral += dot(sin_cos, flowval);\n        sin_cos = rotstep * sin_cos;\n    }\n    fragColor = vec4(0.0,0.0,0.5 + 0.1 * integral,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/**\n * Smooths the signal from buffer C\n * Buffer C contains the integral around a closed loop at each pixel\n * of the dot product of the local optical flow with a vector pointing\n * outward from the loop.\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float open = smoothstep(0.0, 0.4, textureLod(iChannel1, vec2(0.5), 3.0).b - 0.5);\n\t\n\tfragColor = 0.5 * texture(iChannel0, uv) + 0.6 * vec4(open, 0.0, 0.0, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}