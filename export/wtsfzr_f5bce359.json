{"ver":"0.1","info":{"id":"wtsfzr","date":"1595900395","viewed":76,"name":"Pattern Practice Variation","username":"reatured","description":"Don't know what happened.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nfloat drawTriangle(vec2 uv, float _angle){\n    int N = 3; //number of angles\n    //Get Angle\n\n    uv *= mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n    \n    float angle = atan(uv.y, uv.x)+PI;\n    float r = TWO_PI /float(N);\n    \n    float d = cos(floor(.5+angle/r)*r-angle)*length(uv);\n    // Time varying pixel color\n    return d;\n}\n\nfloat phase(float scale){// return 0 or 1; small scale >>lower speed\n    float phase = step(0.,cos(iTime * scale));\n    \n\treturn phase;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.y *= iResolution.y/iResolution.x;\n    vec3 col = vec3(0.);\n    float timeScale = (sin(iTime) + 1.)/2.; // from 0 to 1;\n    //tile\n    float zoom = 10.;\n    uv *= zoom;\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n\tf_uv = f_uv*2. - 1.;\n\tuv/= zoom;\n    //f_uv = uv;\n    \n    //rotate\n    float rotateAngle = PI/4.;\n\n    float directionPhase = step(0.,cos(iTime * 0.5 - PI/4.));//give me 0 or 1;\n    float switchPhase = max(phase(1.), timeScale); //giev me 0 or 1;\n    float currentAngle = rotateAngle   *switchPhase *(directionPhase*2. -1.) + PI/4. *(1.-directionPhase);  \n    \n    //offset\n    //f_uv -=  timeScale *2. * vec2(1.,tan(currentAngle)/1.) * phase(1.);\n\n    \n    for(int ai = -1; ai<=1; ai++){\n        for(int aj = -1; aj<=1; aj++){\n            vec2 grid = vec2(float(ai), float(aj));\n            \n            \n            float rotateCheck = step(1., mod(i_uv.x + i_uv.y, 2.)); // should mid turn?1 to turn;\n            float group = 1.- step(1., mod(float(ai+aj),2.)); //return 0 or 1; the middle is 1\n            if(rotateCheck ==1.){\n             \tgroup = 1.-group;   \n            }\n            //float totalCheck = rotateCheck * group; //1 to move, 0 don't move\n            \n            if(directionPhase != 1. && switchPhase == 1.){\n            \tgroup = 1.;   \n            }\n            grid -=  group *(timeScale *2. * vec2(1.,tan(currentAngle)/1.) * phase(1.))/2.;\n            col += 0.22 *vec3(.2, 5.*(1.0-smoothstep(.4 - uv.x*0.3,0.410,drawTriangle(f_uv +  2. * grid,  -currentAngle * group))), .5);\n            col -= smoothstep(0., .1, abs(sin(5.0*drawTriangle(f_uv +  2. * grid,  -currentAngle * group))) - .8)*.5;\n        }\n    }\n\n    //col = color;\n    // Output to screen\n    col.r -= sqrt(uv.x);\n    col += vec3(0.1, 1.-uv.y*3.5 * (1.-sqrt(uv.x/2.)), 1.4* uv.x);\n    col = sqrt(col) - vec3(0.2, 0.2, 0.1);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}