{"ver":"0.1","info":{"id":"lcSBRG","date":"1725065079","viewed":108,"name":"Please Do Not Mess Up The Color","username":"luckyballa","description":"yet another mess","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","collision","simulation","particles","specular","edges","jelly","corners","voronoitracking","xpbd","selfcollision"],"hasliked":0,"parentid":"Xf2fDm","parentname":"Destructible SDF"},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 sminN( float a, float b, float k ) {\n    const float n = 3.; //3.\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = pow(h, n)*0.5;\n    float s = m*k/n; \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\nfloat hash(vec2 p) {\n return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);   \n}\n\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(hash(b), hash(b + d.yx), f.x), mix(hash(b + d.xy), hash(b + d.yy), f.x), f.y);\n}\n\n\nfloat layer(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 2; i++) {\n        total += noise(n) * amplitude;\n        n += n;\n        amplitude *= 0.33;\n    }\n    return total;\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n vec3 noise3(vec2 n) {\n    return vec3(layer(n + 1234.0), layer(n + 234.0), layer(n + 345.0));\n}\n\nVoronoiCell computeVoronoiCell(vec2 site, uint siteIndex, uvec4 candidates) {\n    VoronoiCell cell;\n    cell.vertexCount = 0;\n    \n    Line bisectors[4];\n    for (int i = 1; i < 4; i++) {\n        vec2 neighbor = decodeEntity(iChannel0, candidates[i]).position;\n        bisectors[i - 1] = computeBisector(site, neighbor);\n    }\n    \n    bisectors[3] = Line(vec2(0), vec2(0, 1));\n    \n    \n    for (int i = 0; i < 3; i++) {\n        for (int j = i + 1; j < 4; j++) {\n            vec2 intersection = intersectLines(bisectors[i], bisectors[j]);\n            if (intersection.x != -1.0) {\n                cell.vertices[cell.vertexCount++] = intersection;\n                if (cell.vertexCount >= MAX_VORONOI_VERTICES) break;\n                \n                uvec4 corenerIndices = floatBitsToUint(texelFetch(iChannel1, ivec2(intersection), 0));\n                uvec3 triangeCandidates = uvec3(candidates[i + 1], candidates[((j + 1) % 4)], siteIndex);\n                if (\n                any(equal(uvec3(corenerIndices[0]),triangeCandidates)) &&\n                any(equal(uvec3(corenerIndices[1]), triangeCandidates)) &&\n                any(equal(uvec3(corenerIndices[2]), triangeCandidates))\n                ) {\n                    cell.triangle[0] = decodeEntity(iChannel0, triangeCandidates.x).oldPosition;\n                    cell.triangle[1] = decodeEntity(iChannel0, triangeCandidates.y).oldPosition;\n                    cell.triangle[2] = site;\n\n                } \n            }\n        }\n   \n        \n        if (cell.vertexCount >= MAX_VORONOI_VERTICES) break;\n    }\n    \n    return cell;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y); p *= 2.0;\n    uvec4 closestIndices = floatBitsToUint(texelFetch(iChannel1, ivec2(fragCoord), 0));\n    uint seedId = closestIndices[0];\n    vec2 closestPos = decodeEntity(iChannel0, seedId).position;\n    \n    VoronoiCell cell = computeVoronoiCell(closestPos, seedId, closestIndices);\n    float mdist = 99999.0;\n    for (int i = 0; i < cell.vertexCount; i++) {\n        vec2 current = cell.vertices[i];\n        vec2 next = cell.vertices[(i + 1) % cell.vertexCount];\n    }\n    \n    if (length(cell.triangle[0] - cell.triangle[1]) < RADIUS * 3.0) {\n        mdist = min(mdist, sdSegment(fragCoord, cell.triangle[0], cell.triangle[1]) - 0.5);\n    }\n        \n    if (length(cell.triangle[1] - cell.triangle[2]) < RADIUS * 3.0) {\n        mdist = min(mdist, sdSegment(fragCoord, cell.triangle[1], cell.triangle[2]) - 0.5);\n    }\n\n    if (length(cell.triangle[2] - cell.triangle[0]) < RADIUS * 3.0) {\n        mdist = min(mdist, sdSegment(fragCoord, cell.triangle[2], cell.triangle[0]) - 0.5);\n    }\n    \n\n\n    vec3 col = vec3(0.8);\n    vec2 sdist = sminN(length(fragCoord - closestPos), length(fragCoord - decodeEntity(iChannel0, closestIndices[1]).position), 16.0);\n\n    if (sdist.x < RADIUS * 2.0) {\n        vec2 restSeedPos = decodeEntity(iChannel0, seedId + PARTICLE_COUNT).oldPosition;\n        vec2 restSeedPosB = decodeEntity(iChannel0, closestIndices[1] + PARTICLE_COUNT).oldPosition;\n\n        vec3 colA = noise3((restSeedPos / iResolution.xy) * 8.0 + 4.5).xyz;\n        vec3 colB = noise3((restSeedPosB / iResolution.xy) * 8.0 + 4.5).xyz;\n\n        col = mix(colA, colB, sdist.y);\n    }\n    \n    col = mix(col, mix(col, vec3(1.0), 0.25), smoothstep(0.01, 0.0, mdist));\n    \n    float crss = sdCross(p) - 0.015;\n   \n    col = mix(mix(vec3(0.775), col, 0.25), col, smoothstep(0.0, 0.001, abs(crss) - 0.01));\n   col = mix(mix(vec3(0.7), col, 0.25), col, smoothstep(0.0, 0.001, abs(abs(crss) - 0.015) - 0.001));\n\n    fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const uint PARTICLE_COUNT = 20000u;\nconst float MAX_VEL = 30.0;\nconst float DAMPING = 1.0;\nconst int MAX_VORONOI_VERTICES = 3; \n\nconst int ASSEMBLE_FRAMES = 150; \n\n#define MAX_VELOCITY (MAX_VEL + MAX_VEL * (iMouse.z > 0.0 ?  0.1 : 0.0))\n#define RADIUS ((iResolution.x / 1280.0) * 1.5)\n\n#define pi 3.14159265359\n#define pi2 2.0 * pi\n\nuint hash(inout uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    \n    return x;\n}\n\nfloat randomFloat(inout uint state) {\n    return float(hash(state)) / 4294967296.0;\n} \n\nvec2 randomDir(inout uint state) {\n    float z = randomFloat(state) * 2.0 - 1.0;\n    float a = randomFloat(state) * pi2;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec2(x, y);\n}\n\n#define FLOAT_INF uintBitsToFloat(0x7f800000u)\n#define PI 3.14159265\n\nstruct Entity {\n    vec2 position;\n    vec2 oldPosition;\n};\n\nconst Entity INVALID_ENTITY = Entity(vec2(-FLOAT_INF), vec2(0));\n\n\nuint wrap1d(uint flatId) {\n    return flatId % PARTICLE_COUNT;\n}\n\nvec2 wrap2d(vec2 id, vec2 resolution) {\n    return fract(id / resolution) * resolution;\n}\n\nuint to1d(vec2 id, vec2 resolution) {\n    return uint(id.x + id.y * resolution.x);\n}\n\nivec2 to2d(uint flatId, ivec2 resolution) {\n    return ivec2(flatId, flatId / uint(resolution.x)) % resolution;\n}\n\nEntity decodeEntity(sampler2D sampler, ivec2 id) {\n    vec4 raw = texelFetch(sampler, id, 0);\n    Entity entity;\n    entity.position = raw.rg;\n    entity.oldPosition = raw.ba;\n    return entity;\n}\n\nEntity decodeEntity(sampler2D sampler, uint flatId) {\n    return decodeEntity(sampler, to2d(flatId, textureSize(sampler, 0)));\n}\n\nvec4 encodeEntity(Entity entity) {\n    return vec4(entity.position, entity.oldPosition);\n}\n\nuvec4 fetchClosest(vec2 position, sampler2D voroBuffer) {\n    return floatBitsToUint(texelFetch(voroBuffer, ivec2(wrap2d(position, vec2(textureSize(voroBuffer, 0)))), 0));\n}\n\nuint murmur3( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\nuint rngSeed = 314159265u;\n\nuint xorshift(in uint value) {\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nfloat xorshiftFloat(uint state) {\n    return float(xorshift(state)) / float(0xffffffffU);\n}\n\nuint nextUint() {\n    rngSeed = xorshift(rngSeed);\n    return rngSeed;\n}\n\nfloat nextFloat() {\n    return float(nextUint()) / float(uint(-1));\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat  dot2(vec2 v) { return dot(v, v); }\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nvec2 rot(vec2 p, float an ) {\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2x2(cc,-ss,ss,cc)*p;\n}\n\nfloat sdCross( in vec2 p) {\n    vec2 b = vec2(0.625, 0.1);\n    float r = 0.1;\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return (sign(k)*length(max(w,0.0)) + r) - 0.15;\n}\n\nvec2 gsdCross(vec2 p) {\n    const float h = 0.0001;\n    return vec2(\n        sdCross(vec2(p.x + h, p.y)) - sdCross(vec2(p.x - h, p.y)),\n        sdCross(vec2(p.x, p.y + h)) - sdCross(vec2(p.x, p.y - h))\n    ) / (2.0 * h);\n}\n\nstruct Line {\n    vec2 midpoint;\n    vec2 normal;\n};\n\nstruct VoronoiCell {\n    vec2 vertices[MAX_VORONOI_VERTICES];\n    int vertexCount;\n    vec2 triangle[3];\n};\n\n\nvec2 intersectLines(Line l1, Line l2) {\n    vec2 p1 = l1.midpoint;\n    vec2 p2 = l2.midpoint;\n    vec2 d1 = l1.normal;\n    vec2 d2 = l2.normal;\n    \n    float det = d1.x * d2.y - d1.y * d2.x;\n    if (abs(det) < 1e-6) {\n        return vec2(-1);\n    }\n    \n    float t = ((p2.x - p1.x) * d2.y - (p2.y - p1.y) * d2.x) / det;\n    return p1 + d1 * t;\n}\n\nLine computeBisector(vec2 p1, vec2 p2) {\n    vec2 midpoint = (p1 + p2) * 0.5;\n    vec2 dir = normalize(p2 - p1);\n    vec2 normal = vec2(-dir.y, dir.x);\n    return Line(midpoint, normal);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 handleParticleInteraction(Entity current, Entity other, vec2 restPosition, Entity otherRest, bool assembling, float rad, float weight) {\n    float rest = assembling ? rad * 2.0 : length(restPosition - otherRest.position);\n    vec2 delta = current.position - other.position;\n    float dist = length(delta);\n\n    if (assembling ? dist < rest : (dist > rad * 4.0 ? false : dist != rest)) {\n        float cost = (rest - dist);\n        vec2 grad = delta / max(dist, 0.0001);\n        vec2 correction = grad * -cost;\n\n        return correction * weight;\n    }\n    return vec2(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint flatID = to1d(floor(fragCoord), vec2(textureSize(iChannel0, 0)));\n        bool assembling = iFrame < ASSEMBLE_FRAMES;\n\n    if (flatID >= PARTICLE_COUNT) {\n        if (flatID >= PARTICLE_COUNT * 2u) return;\n            Entity current = decodeEntity(iChannel0, flatID - PARTICLE_COUNT);\n\n        if (!assembling) {\n            // the idea with the rest state didn't work good, so let's ignore it  \n            vec2 rest = decodeEntity(iChannel0, flatID).oldPosition;\n            fragColor = vec4(current.position, rest);\n        } else {\n            Entity current = decodeEntity(iChannel0, flatID - PARTICLE_COUNT);\n            fragColor = vec4(current.position, current.oldPosition);\n        }\n    } else {\n        uint flatSeed = murmur3(flatID); \n        rngSeed = flatSeed;\n\n        Entity current;\n        if (iFrame <= 8) {\n            float angle = nextFloat() * 2.0 * PI;\n            float radius = sqrt(nextFloat()) * iResolution.x * 0.25;\n            current.position = vec2(cos(angle), sin(angle)) * radius + iResolution.xy * 0.5;\n            current.oldPosition = current.position;\n        } else {\n            current = decodeEntity(iChannel0, flatID);\n        }\n\n        vec2 p = (current.position - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n        p *= 2.0;\n\n        vec2 delta = gsdCross(p);\n        float dist = sdCross(p);\n\n        if (dist > 0.0) {\n            float cost = dist;\n            float lambda = -cost;\n            vec2 grad = delta / dist;\n            vec2 correction = grad * lambda;\n\n            current.position += correction * 2.0 * (!assembling ? 0.05 : 1.0);\n        }\n\n        vec2 restPosition = decodeEntity(iChannel0, flatID + PARTICLE_COUNT).position;\n        uvec4 restClosest = fetchClosest(restPosition.xy, iChannel1);\n        uvec4 restClosest2 = fetchClosest(current.position, iChannel3);\n        uvec4 closest3 = fetchClosest(current.position, iChannel2);\n\n        for (int i = 0; i < 4; i++) {\n            if (restClosest[i] != flatID && restClosest[i] != -1u) {\n                Entity other = decodeEntity(iChannel0, restClosest[i]);\n                Entity otherRest = decodeEntity(iChannel0, restClosest[i] + PARTICLE_COUNT);\n                current.position -= handleParticleInteraction(current, other, restPosition, otherRest, assembling, RADIUS, 0.1);\n            }\n        }\n\n        for (int i = 0; i < 4; i++) {\n            if (restClosest2[i] != flatID && restClosest2[i] != -1u) {\n                Entity other = decodeEntity(iChannel0, restClosest2[i]);\n                Entity otherRest = decodeEntity(iChannel0, restClosest2[i] + PARTICLE_COUNT);\n                current.position -= handleParticleInteraction(current, other, restPosition, otherRest, assembling, RADIUS, 0.1);\n            }\n        }\n\n        for (int i = 0; i < 4; i++) {\n            if (closest3[i] != flatID && closest3[i] != -1u) {\n                Entity other = decodeEntity(iChannel0, closest3[i]);\n                current.position -= handleParticleInteraction(current, other, restPosition, other, true, RADIUS, 0.15);\n            }\n        }\n\n        float md = length(current.position - iMouse.xy);\n        if (md < 50.0 && iMouse.z > 0.0) {\n            current.position += normalize(current.position - iMouse.xy) * (1.0 / md) * 20.0;\n        }\n\n        vec2 velocity = current.position - current.oldPosition;\n        float v = length(velocity);\n        vec2 normalizedVelocity = velocity / max(v, 0.00001);\n        float dv = -v * DAMPING * iTimeDelta;\n        velocity += normalizedVelocity * dv;\n        velocity = clamp(velocity, -MAX_VELOCITY, MAX_VELOCITY);\n        velocity *= (assembling ? 0.98 : 1.0);\n\n        vec2 oldPosition = current.position;\n        current.position = clamp(current.position, vec2(RADIUS), iResolution.xy - vec2(RADIUS));\n        current.position += velocity + iTimeDelta * vec2(0.0, -9.8) * (assembling ? 0.0 : 0.0);\n\n        current.oldPosition = oldPosition;\n\n        fragColor = encodeEntity(current);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void sortClosest(\n        inout vec4 distances,\n        inout uvec4 indices, \n        uint index,\n        vec2 center\n        ) {\n    if (index == uint(-1) || any(equal(indices, uvec4(index)))) {\n        return;\n    } \n\n    Entity e = decodeEntity(iChannel0, index);\n    float dist = length(center - e.position);\n    \n    if (dist < distances[0]) {\n        distances = vec4(dist, distances.xyz);\n        indices = uvec4(index, indices.xyz);\n    } else if (dist < distances[1]) {\n        distances = vec4(distances.x, dist, distances.yz); \n        indices = uvec4(indices.x, index, indices.yz);\n    } else if (dist < distances[2]) {\n        distances = vec4(distances.xy, dist, distances.z); \n        indices = uvec4(indices.xy, index, indices.z);\n    } else if (dist < distances[3]) {\n        distances = vec4(distances.xyz, dist);             \n        indices = uvec4(indices.xyz, index);\n    }\n}\n\nvoid fetchAndSortClosest( inout vec4 distances, inout uvec4 idList, in vec2 samplePoint, in vec2 cellCenter ) {\n    uvec4 ids = fetchClosest(samplePoint, iChannel1);\n    \n    for (int i = 0; i < 4; i++) {\n        sortClosest(distances, idList, ids[i], cellCenter);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec4 closestIndices = uvec4(-1);\n    vec4 bestDistances = vec4(FLOAT_INF);\n    \n    uint seed = uint(iFrame) + uint(fragCoord.x) + uint(fragCoord.y);\n    float rad = 8.0;\n\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    \n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    fetchAndSortClosest(bestDistances, closestIndices, fragCoord + randomDir(seed) * rad, fragCoord);\n    \n    rngSeed = murmur3(uint(fragCoord.x)) ^ murmur3(floatBitsToUint(fragCoord.y)) ^ murmur3(floatBitsToUint(iTime));\n\n    for (int i = 0; i < 4; i++) {\n        sortClosest(bestDistances, closestIndices, wrap1d(nextUint()), fragCoord);\n    }\n\n    fragColor = uintBitsToFloat(closestIndices);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void sortClosest(\n        inout vec4 distances,\n        inout uvec4 indices, \n        uvec4 indices0,\n        uint index,\n        vec2 center\n        ) {\n    if (\n    index == uint(-1) \n    || any(equal(indices, uvec4(index))) \n    || any(equal(indices0, uvec4(index)))\n    ) {\n        return;\n    } \n\n    Entity e = decodeEntity(iChannel0, index);\n    float dist = length(center - e.position);\n    \n    if (dist < distances[0]) {\n        distances = vec4(dist, distances.xyz);\n        indices = uvec4(index, indices.xyz);\n    } else if (dist < distances[1]) {\n        distances = vec4(distances.x, dist, distances.yz); \n        indices = uvec4(indices.x, index, indices.yz);\n    } else if (dist < distances[2]) {\n        distances = vec4(distances.xy, dist, distances.z); \n        indices = uvec4(indices.xy, index, indices.z);\n    } else if (dist < distances[3]) {\n        distances = vec4(distances.xyz, dist);             \n        indices = uvec4(indices.xyz, index);\n    }\n}\n\nvoid fetchAndSortClosest( inout vec4 distances, inout uvec4 idList, uvec4 idList0, in vec2 samplePoint, in vec2 cellCenter) {\n    uvec4 ids = fetchClosest(samplePoint, iChannel1);\n    \n    for (int i = 0; i < 4; i++) {\n        sortClosest(distances, idList, idList0, ids[i], cellCenter);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame > ASSEMBLE_FRAMES) { \n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return; \n    }\n    \n    \n    uvec4 closestIndices = uvec4(-1);\n    vec4 bestDistances = vec4(FLOAT_INF);\n    \n    uint seed = uint(iFrame) + uint(fragCoord.x) + uint(fragCoord.y);\n    \n    uvec4 closestSeedIndices = fetchClosest(fragCoord, iChannel2);\n    uint closestSeedIndex = closestSeedIndices[0];\n   \n    vec2 closestSeedPosition = fragCoord;\n    \n    float rad =- 4.0;\n    fetchAndSortClosest(bestDistances, closestIndices, closestSeedIndices, closestSeedPosition, closestSeedPosition);\n    fetchAndSortClosest(bestDistances, closestIndices, closestSeedIndices, closestSeedPosition + randomDir(seed) * rad, closestSeedPosition);\n    fetchAndSortClosest(bestDistances, closestIndices, closestSeedIndices, closestSeedPosition + randomDir(seed) * rad, closestSeedPosition);\n    fetchAndSortClosest(bestDistances, closestIndices, closestSeedIndices, closestSeedPosition + randomDir(seed) * rad, closestSeedPosition);\n    fetchAndSortClosest(bestDistances, closestIndices, closestSeedIndices, closestSeedPosition + randomDir(seed) * rad, closestSeedPosition);\n    \n\n    rngSeed = murmur3(uint(fragCoord.x)) ^ murmur3(floatBitsToUint(fragCoord.y)) ^ murmur3(floatBitsToUint(iTime));\n\n    for (int i = 0; i < 16; i++) {\n        sortClosest(bestDistances, closestIndices, closestSeedIndices, wrap1d(nextUint()), fragCoord);\n    }\n    \n\n\n    fragColor = uintBitsToFloat(closestIndices);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iFrame > ASSEMBLE_FRAMES) { \n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return; \n    }\n\n\n    fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n}","name":"Buffer D","description":"","type":"buffer"}]}