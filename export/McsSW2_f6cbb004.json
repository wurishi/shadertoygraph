{"ver":"0.1","info":{"id":"McsSW2","date":"1706261541","viewed":308,"name":"Gravity Experiment ","username":"kastorp","description":"8K particles with variable mass in 3D space, where every particle interacts with each other\npress spacebar  to reset after full screen, see Image for all keys","likes":32,"published":1,"flags":48,"usePreview":0,"tags":["3d","physics","gravity"],"hasliked":0,"parentid":"7tjyzh","parentname":"Chaos & Order"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gravity Experiment by kastorp\n// \n// keys:\n//  spacebar: reset on full screen\n//  A: debug escaped particles\n//  B: fake galaxy rotation\n//  C: toggle zoom x3\n//  R: toggle slow mode (/10)\n//  1: decrease energy\n//  2: increase energy\n//  Q: toggle particle aggregation (WIP)\n//  W: toggle center lock \n//-------------------------------------\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    Init\n    \n    //debug spheres going in deeper space\n    if(texelFetch(iChannel3,ivec2(65,0),0).x>.5){\n        int i= (int(U.y)*NX + int(U.x))%N; \n        vec4 p =texelFetch(iChannel0,ivec2(i%NX,i/NX),0);\n        O=step(length(p.xyz),100.)*vec4(1);\n        return;\n    }\n    vec2 p = (U/R.y -R/R.y*.5),mp = (iMouse.xy/R.y -R/R.y*.5),\n        c = (p*R.y/R.xy +.5)*float(M) ;    \n    int j = int(c.x) +int(c.y)*M, //current region id\n        jj= int(step(.5,fract(c.x))+2.*step(.5,fract(c.y)));\n    \n    O=vec4(0,0,0,100);\n    vec3 p0= key(87,2)? texelFetch(iChannel0,ivec2(0),0).xyz:vec3(0);\n    \n    \n    for(int i=0,k=0;k<N && i<SCAN;i++){ // scan points in current region (max 500)\n        \n        //get point at pointer\n        vec4 ps=texelFetch(iChannel0,ivec2(max(0,k-1)%NX,max(0,k-1)/NX ),0);\n        vec4 c=spos(ps,angle,p0);\n        \n        //draw the point\n        float r= TL*DIST/(DIST+c.w)*c.z*angle.z;\n        float d =length(p-c.xy); \n            \n        //r/=sqrt(1. + (d/r)*(d/r));\n        if(d<r) {\n            c.w-=sqrt(r*r-d*d);\n            if(c.w<O.w ) {\n                float sh= (1.5- length(p-c.xy-vec2(0,r*.5))/r)*1.5 -.5;sh=.5+sh*sh;\n                O=vec4((0.5 + 0.5*cos(c.z*6.+vec3(0,2,4)))*sh,c.w);\n                vec4 v=texelFetch(iChannel2,ivec2(max(0,k-1)%NX,max(0,k-1)/NX ),0);\n                if(v.w!=0.)O=vec4(1);\n            }\n        }\n        //get pointer to next point in region\n        k =int(texelFetch(iChannel1,ivec2(k%NX,k/NX +j*NY),0)[jj]);\n       \n    }\n    \n   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//velocity  + acceleration\n//  particles are subdivided in groups\n//  the buffers stores the acceleration by each group on every particle\n//  then all the accelerations are summed to the previous velocity \n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    Init\n    int i= (int(U.y))*NX + int(U.x); \n    if(i>N *(NP+1)) return ;\n   \n    int PSIZE=(N/NP), \n        cp= i/N; //current pool (if cp>0), otherwise velocity\n        i = i%N; //current sphere\n    vec4 p =texelFetch(iChannel1,ivec2(i%NX,i/NX),0);\n    \n   \n    if(iFrame<10 || key(32,0) || key(66,0) ){\n        ////https://en.wikipedia.org/wiki/Galaxy_rotation_curve\n        if(cp==0) O= vec4(normalize(vec3(p.y,-p.x,0))/(dot(p.xyz,p.xyz)*.2+1.)*.003*float(N),0);\n        else O=vec4(0);\n        //O.xyz=hash32(-U*1.1)*.02-.01; \n        if(i==0) O=vec4(0);\n        \n        \n    \n    }else if(cp==0){\n        //update velocity with previous accelerations\n        vec4 v= texelFetch(iChannel0,ivec2(i%NX,i/NX),0);v.w=0.;\n        for(int j=1;j<=NP;j++){\n             int k=i + j*N;\n             v +=texelFetch(iChannel0,ivec2(k%NX,k/NX),0)*vec4(vec3(DT),1);\n        }\n        if( key(49,0))v.xyz*=1.005;\n        else  if( key(50,0))v.xyz/=1.005;\n        \n        O= v;\n    }\n    else{\n        //calculate acceleration from current pool \n        bool aggr= key(81,2);\n        vec4 ac=vec4(0);\n        for (int j=0;j<PSIZE;j++){\n            int k=j+ (cp-1)*PSIZE;\n            if(i==k  || k>=N) continue;\n            if(p.w<=0.) break;\n            \n            vec4 pn=texelFetch(iChannel1,ivec2(k%NX,k/NX),0);\n            pn.xyz-=p.xyz;\n            if(pn.w<=0.) continue;\n         \n            float di = length(pn.xyz);  \n            if(di<TL*(p.w+pn.w) && p.w>0. &&pn.w>0. && aggr){\n                if(p.w>pn.w || (p.w==pn.w && i<k)) {\n                    float m=pn.w*pn.w*pn.w,\n                          mn=p.w*p.w*p.w,\n                          m1=m+mn;\n                    vec3 vn=texelFetch(iChannel0,ivec2(k%NX,k/NX),0).xyz;\n                    vec3 v=texelFetch(iChannel0,ivec2(i%NX,i/NX),0).xyz;\n                    float dr=pow(m1,1./3.)-p.w;\n                    ac.w+=dr;\n                    \n                    vec3 dv= (vn-v)*mn/m1;\n                    ac.xyz+=dv;\n                    \n                }\n                else if(p.w<pn.w)  ac.w -= p.w;\n            } else{\n                vec3  ai=  normalize(pn.xyz);\n                float m=abs(pn.w*pn.w*pn.w);\n                ac.xyz+=  ai*G*m/(di*di +EPS*EPS);   \n            }\n        }\n        \n        O=ac; \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define N 12000   //number of particles (<=10000) \n#define TL .005 //particles size \n#define DIST 1. //POV distance from origin\n#define TS .0001\n#define G 15. //gravity force\n#define MP 100 //njumber of mega particles\n#define SCAN 800 // max number of particles in each screen region\n#define EPS .1 //gravity smooth distance (to avoid division by zero)\n#define H 20  //number of scanned particles in buffer C\n//-----------------------------------------------\n#define key(k,t) (texelFetch(iChannel3,ivec2(k,t),0).x>.5)\n#define Init vec2 R =iResolution.xy;\\\n    int NX =int(iResolution.x);\\\n    int NY= (N/NX+1);\\\n    float DT= TS * (key(82,2)? .1:1.);\\\n    int M= min(100,int(sqrt(iResolution.y/float(NY))));\\\n    int L= int(pow(float(N),1./3.));\\\n    int NP= min(N,int(iResolution.x*iResolution.y)/N);\\\n    vec3 angle=vec3(iMouse.x<=0.?vec2(0,1.5):(iMouse.xy - R*.5)/R.y*3.14,key(67,2)?3.:1.);\n\n\nvec4 spos(vec4 p,vec3 a,vec3 p0){\n    p.xyz-=p0,\n    p.zy*=mat2(cos(a.y),sin(a.y),-sin(a.y),cos(a.y));\n    p.xz*=mat2(cos(a.x),-sin(a.x),sin(a.x),cos(a.x));  \n    p.xy*=a.z;\n    return vec4(p.xy *.7 *DIST / (DIST+p.z),p.w,p.z);\n}\n\n//// Hash without Sine (c)2014 David Hoskins\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particle positions\n// simulation is the simplest one\n// https://en.wikipedia.org/wiki/Numerical_model_of_the_Solar_System\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    Init\n    O=vec4(0);\n    int i= int(U.y)*NX + int(U.x); \n    \n    if(i==N+1) {O=vec4(iResolution.x);return;}\n    else if(i>N) return ;\n   \n\n    if(iFrame==0 || key(32,0) ){\n      \n       O.xyz=hash32(U +floor(iTime))*2.-1.;   O.z*=.4; \n       O.w=  .2 +float(i)/float(N)*.2;   \n       if(i<MP) O.w=1.;\n       if(i==0) O=vec4(0,0,0,5.);\n       \n    }\n    else{\n        vec4 p =texelFetch(iChannel1,ivec2(i%NX,i/NX),0);\n        if(p.w<=0.) return;\n        //update velocity\n        vec4 v= texelFetch(iChannel0,ivec2(i%NX,i/NX),0);v.w=0.;\n        for(int j=1;j<=NP;j++){\n             int k=i + j* N;\n             v +=texelFetch(iChannel0,ivec2(k%NX,k/NX),0)*vec4(vec3(DT),1);\n        }\n        p+=v*vec4(vec3(DT),1);\n        O=p;\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//points in each region\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    Init\n    O= vec4(H);\n    if(int(U.y)>(NY*M*M) || int(U.x)>NX) return ;\n       \n    int j=int(U.y)/NY, //current region\n        i= (int(U.y)%NY)*NX + int(U.x); //current point\n\n    bvec4 f=bvec4(false);\n    vec3 p0= key(87,2)? texelFetch(iChannel0,ivec2(0),0).xyz:vec3(0);\n        \n    for( int k = i; k<min(N,i+H);k++){ //iterate on max H points in region\n        \n        \n        vec4 p= spos(texelFetch(iChannel0,ivec2(k%NX,k/NX),0),angle,p0); //point position\n        float r= TL*p.z*DIST/(DIST+p.w)*angle.z;\n        float sz=1./float(M);\n        vec2 s =(vec2((j%M),j/M)+.25);\n        vec2 s1=s+.25; s1=s1*sz-.5 ; s1*=R.xy/R.y ; //region center\n        if(p.w<=-DIST || p.z<=0.) continue;\n        if(max(abs(p.x-s1.x)-.5*sz*R.x/R.y,abs(p.y-s1.y)-.5*sz)>r) continue; //outside region\n          \n        for(int jj=0;jj<4;jj++){\n          if(f[jj])continue; //already found next point for subregion\n               \n          vec2 ss=s +vec2((jj==1|| jj==3) ?.5:0.,(jj==2|| jj==3) ?.5:0.); ss=ss*sz-.5 ; ss*=R.xy/R.y ; //subregion center\n      \n            if(max(abs(p.x-ss.x)-.25*sz*R.x/R.y,abs(p.y-ss.y)-.25*sz)<r )\n            {\n                //this point is inside subergion\n                O[jj]= float(k-i); \n                f[jj]=true;\n            }\n       } \n       if(all(f)) return; \n    }\n    \n       \n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//pointer joiner (from relative to absolute)\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    Init\n    \n    if(int(U.y)>(NY*M*M) || int(U.x)>NX) return ;        \n     \n    int j=int(U.y)/NY, //current region\n        i= (int(U.y)%NY)*NX + int(U.x); //current point\n    \n    O=  texelFetch(iChannel1,ivec2(U),0);\n    for(int jj=0;jj<4;jj++){\n        if(i>0 &&   int(texelFetch(iChannel1,ivec2((i-1)%NX,(i-1)/NX +j*NY),0)[jj]) !=0) {\n            O[jj]=float(N+1);\n            continue;\n        }\n        \n         //TODO: order by ascending distance\n        for(int ii=0,k=int(O[jj])+i;k<N && ii<N/H+5;ii++){ // scan next points in current region \n\n            int sk=int(texelFetch(iChannel1,ivec2(k%NX,k/NX +j*NY),0)[jj]);\n            if(sk==0) { //the point is in\n                O[jj]=float(k+1); //update pointer\n                break;\n            }\n            else k+=int(sk); //skip till first point in region\n        }\n\n   }  \n\n}","name":"Buffer D","description":"","type":"buffer"}]}