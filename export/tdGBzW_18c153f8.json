{"ver":"0.1","info":{"id":"tdGBzW","date":"1606663390","viewed":141,"name":"Tetrahedron Primitive","username":"morgan3d","description":"I couldn't find a simple SDF for a tetrahedron online, so I created this one for my next Google search!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tetrahedron","platonic","primitive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdTetrahedron(vec3 p) {\n    p *= 0.5;\n    return max(\n        // Vertical bound\n        abs(p.y) - 0.5, \n\n        // Horizontal bound\n        max(abs(p.x) * 0.866025 + p.z * 0.5, -p.z) - 0.25 * abs(0.5 - p.y)\n    ) * 1.9;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\n\nconst float pi          = 3.1415926535;\nconst float degrees     = pi / 180.0;\n\nfloat square(float x) { return x * x; }\nvec3 square(vec3 v) { return v * v; }\nfloat max3(float a, float b, float c) { return max(a, max(b, c)); }\nfloat min3(float a, float b, float c) { return min(a, min(b, c)); }\nfloat maxComponent(vec2 v) { return max(v.x, v.y); }\nfloat maxComponent(vec3 v) { return max3(v.x, v.y, v.z); }\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nstruct Ray {\n\tvec3        origin;\n\tvec3        direction;\n};\n\t\nstruct Material {\n    vec3        lambertian;\n\tfloat       glossy;\n\tfloat       glossyExponent;\n};\n\nstruct Surfel {\n\tvec3\t\tposition;\n\tvec3\t\tnormal;\n\tMaterial    material;\n};\n\t\n\nconst float \tverticalFieldOfView = 40.0 * degrees;\nconst float \trayBumpEpsilon \t\t= 0.01;\nconst int \t\tMAX_STEPS \t\t\t= 200;\nconst float \tSURFACE_DISTANCE \t= 0.0005;\n#define radianceMap iChannel0\n#define irradianceMap iChannel1\n#define ENABLE_TILES 1\nconst float TILE = 4.0;\n\t\n\nfloat distanceEstimate(vec3 p) {\n    return sdTetrahedron(p);\n}\n\n\nbool intersectScene(Ray eyeRay, inout float maxDist, inout Surfel surfel) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < MAX_STEPS; ++i) {\n\t\tvec3 P = eyeRay.direction * t + eyeRay.origin;\n\t\tfloat d = distanceEstimate(P);\n\t\t#if ENABLE_TILES\n\t\t// Never jump between tiles\n\t\td = min(d, TILE / 4.0);\n\t\t#endif\n\t\t\n\t\tif (d < SURFACE_DISTANCE) {\n\t\t\tsurfel.position = P;\n\t\t\t// Back up before computing the normal\n\t\t\tP -= eyeRay.direction * SURFACE_DISTANCE;\n\t\t\tconst float eps = 0.0005;\n\t\t\tsurfel.normal = normalize(\n\t\t\t\tvec3(distanceEstimate(P + vec3(eps, 0.0, 0.0)),\n\t\t\t\t\t\tdistanceEstimate(P + vec3(0.0, eps, 0.0)),\n\t\t\t\t\t\tdistanceEstimate(P + vec3(0.0, 0.0, eps))) -\n\t\t\t\tvec3(distanceEstimate(P)));\n\t\t\treturn true;\n\t\t} else if (t > maxDist) {\n\t\t\treturn false;\n\t\t}\n\t\tt += d;\n\t}\n\treturn false;\n}\n\n\nmat3 lookAt(vec3 target, vec3 translation) {\n    vec3 z = normalize(translation - target);\n    vec3 up = normalize(vec3(0.0, 1.0, 0.0) + z * z.y);\n    vec3 x = normalize(cross(up, z));\n    return mat3(x, cross(z, x), z);\n}\n\n\nvec3 trace(Ray eyeRay) {\n\t// Directional light source\n    vec3     w_i     = normalize(vec3(1, 1, 1));\n\tvec3\t B_i     = vec3(2.0); \n\t\n\t// Outgoing light\n\tvec3 L_o;\n\t\n\tSurfel surfel;\t\n\tsurfel.material.glossy         = 0.3;\n\tsurfel.material.glossyExponent = 100.0;\n\t\n\tfloat maxDist = 1e30;\t\n\t\t\n\tif (intersectScene(eyeRay, maxDist, surfel)) {\n\t\tvec3 vox = floor((surfel.position - TILE / 2.0) / TILE);\n\t\tsurfel.material.lambertian = vec3(0.0, 0.1, 0.2);\n            \n\t\t// Mirror reflection vector\n\t\tvec3 w_m = -reflect(-eyeRay.direction, surfel.normal);\n\t\t\n\t\t// Integrate over the hemisphere, so there is no factor of 1/pi\n\t\tL_o = texture(irradianceMap, surfel.normal).rgb * surfel.material.lambertian;\n\n\t\t// Glossy environment reflection\n\t\tL_o += texture(irradianceMap, w_m).rgb * surfel.material.glossy;\n\t\t\t\t\t\n\t\t// Cast a shadow ray\n\t\tSurfel shadowSurfel;\n\t\tRay shadowRay;\n\t\tshadowRay.direction = w_i;\n\t\tshadowRay.origin = surfel.position + surfel.normal * rayBumpEpsilon;\n\t\tfloat shadowDist = TILE / 2.0;\n\t\tif ((dot(surfel.normal, w_i) > 0.0) && ! intersectScene(shadowRay, shadowDist, shadowSurfel)) {\n\t\t\tvec3 w_o = -eyeRay.direction;\n\t\t\tvec3 w_h = normalize(w_i + w_o);\n\t\t\t\n\t\t\t// Compute the light contribution from the directional source\n\t\t\tL_o += max(0.0, dot(surfel.normal, w_i)) * B_i * \n\t\t\t\t(surfel.material.lambertian / pi + \n\t\t\t\t pow(max(0.0, dot(surfel.normal, w_h)), surfel.material.glossyExponent) * surfel.material.glossy * (surfel.material.glossyExponent + 8.0) / (8.0 * pi));\n\t\t}\n\t} else {\n\t\t// Hit the skybox\n\t\tL_o = texture(radianceMap, eyeRay.direction).rgb;\n\t}\n\t\n\treturn L_o;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tRay eyeRay;\n\teyeRay.origin = vec3((iMouse.xy - iResolution.xy / 2.0 + vec2(sin(iTime * 0.7), cos(iTime * 0.25)) * 150.0) * 10.0 / max(iResolution.x, iResolution.y) + vec2(0.0, 4.0), 1.0);\n\tmat3 M = lookAt(vec3(0.0), eyeRay.origin);\n\teyeRay.direction = M * normalize(vec3(fragCoord.xy - iResolution.xy / 2.0, iResolution.y / ( -2.0 * tan(verticalFieldOfView / 2.0))));\n\t\n\tfragColor.xyz = sqrt(trace(eyeRay));\n}","name":"Image","description":"","type":"image"}]}