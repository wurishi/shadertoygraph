{"ver":"0.1","info":{"id":"MlsyDj","date":"1506517181","viewed":656,"name":"RetroxSynth","username":"Marrrk","description":"Replication of backgrounds found on YT videos about retro synth stuff.\n\nIdea: https://www.youtube.com/watch?v=0obpScUz_VE","likes":16,"published":1,"flags":0,"usePreview":1,"tags":["retro","synth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define K 0.37\n#define PI 3.141\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\n//#define LOWRES\n#define MIDRES\n//#define HIRES\n\n#ifdef LOWRES\n\t#define epsilon 0.01\n\t#define max_distance 20.0\n\t#define max_steps 50\n\t#define detailStepLength 0.1\n\t#define fuzzynessSteps 3\n#endif \n\n#ifdef MIDRES\n\t#define epsilon 0.01\n\t#define max_distance 20.0\n\t#define max_steps 100\n\t#define detailStepLength 0.1\n\t#define fuzzynessSteps 5\n#endif\n\n#ifdef HIRES\n\t#define epsilon 0.001\n\t#define max_distance 20.0\n\t#define max_steps 100\n\t#define detailStepLength 0.01\n\t#define fuzzynessSteps 10\n#endif\n\nvec3 ambientLightColor = vec3(0.5, 0.5, 0.5);\nvec3 lightPos = vec3(0.0, 0.0, -3.0);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\nvec3 black = vec3(0.0, 0.0, 0.0);\nvec3 orange = vec3(0.8, 0.4, 0.0);\nvec3 teal = vec3(0.0, 0.55, 0.4);\nvec3 blue = vec3(0.0, 0.6, 0.7);\n\nstruct traceInfo\n{\n    vec3 color;\n\tvec3 pos;\n\tvec3 dir;\n    int steps;\n    int level;\n    float objIndex;\n};\n    \nstruct objectInfo\n{\n    vec3 albedo;\n    vec4 emission;\n    float reflectivity;\n    float fuzzyness;\n    float fresnelBias;\n};\n\n/*\nTerrain Ground\nRed\nGreen\nBlue\nso 4 objects\n*/\n#define sceneObjects 4\n#define sceneObjectsF 4.0\n\nobjectInfo objects[sceneObjects];\n\nmat3 rotAxis(vec3 axis, float a) {\n    float s=sin(a);\n    float c=cos(a);\n    float oc=1.0-c;\n    vec3 as=axis*s;\n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis);\n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c);\n    return p*oc+q;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nconst vec3 GDFVectors[19] = vec3[](\n\tnormalize(vec3(1.0, 0.0, 0.0)),\n\tnormalize(vec3(0.0, 1.0, 0.0)),\n\tnormalize(vec3(0.0, 0.0, 1.0)),\n\n\tnormalize(vec3(1.0, 1.0, 1.0 )),\n\tnormalize(vec3(-1.0, 1.0, 1.0)),\n\tnormalize(vec3(1.0, -1.0, 1.0)),\n\tnormalize(vec3(1.0, 1.0, -1.0)),\n\n\tnormalize(vec3(0.0, 1.0, PHI+1.0)),\n\tnormalize(vec3(0.0, -1.0, PHI+1.0)),\n\tnormalize(vec3(PHI+1.0, 0.0, 1.0)),\n\tnormalize(vec3(-PHI-1.0, 0.0, 1.0)),\n\tnormalize(vec3(1.0, PHI+1.0, 0.0)),\n\tnormalize(vec3(-1.0, PHI+1.0, 0.0)),\n\n\tnormalize(vec3(0.0, PHI, 1.0)),\n\tnormalize(vec3(0.0, -PHI, 1.0)),\n\tnormalize(vec3(1.0, 0.0, PHI)),\n\tnormalize(vec3(-1.0, 0.0, PHI)),\n\tnormalize(vec3(PHI, 1.0, 0.0)),\n\tnormalize(vec3(-PHI, 1.0, 0.0))\n);\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\nfloat fGDF(vec3 p, float r, float e, int begin, int end) {\n\tfloat d = 0.0;\n\tfor (int i = begin; i <= end; ++i)\n\t\td += pow(abs(dot(p, GDFVectors[i])), e);\n\treturn pow(d, 1.0/e) - r;\n}\n\n// Version with without exponent, creates objects with sharp edges and flat faces\nfloat fGDF(vec3 p, float r, int begin, int end) {\n\tfloat d = 0.0;\n\tfor (int i = begin; i <= end; ++i)\n\t\td = max(d, abs(dot(p, GDFVectors[i])));\n\treturn d - r;\n}\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 3, 6);\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 6);\n}\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat cylinder( vec3 p, float s )\n{\n  return length(p.xz)-s;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat pyramide(vec3 pos, vec3 offset, float size, float rotation, float flatness)\n{\n    mat3 rotMat = rotAxis(vec3(0.0, 1.0, 0.0), rotation);        \n    vec3 q = inverse(rotMat) * ((pos + offset) * vec3(1.0, flatness, 1.0));\n    return fOctahedron(q, size);\n}\n\nfloat getObject0Distance(vec3 pos)\n{\n    float baseDist = pos.y + 1.0;\n\tfloat dist1 = smin(baseDist, pyramide(pos, vec3(4.0, 1.0, -2.0), 1.0, 0.8, 3.0), 0.25);\n\tfloat dist2 = smin(baseDist, pyramide(pos, vec3(3.5, 1.0, -5.0), 1.0, 0.8, 2.0), 0.25);\n\tfloat dist3 = smin(baseDist, pyramide(pos, vec3(9.0, 1.0, -5.0), 1.0, 0.6, 1.0), 0.25);\n\t\n\tfloat dist4 = smin(baseDist, pyramide(pos, vec3(1.5, 1.0, -4.0), 1.0, 0.8, 3.5), 0.25);\n\tfloat dist5 = smin(baseDist, pyramide(pos, vec3(-0.5, 1.0, -4.0), 1.0, 0.8, 3.7), 0.25);\n\t\n\tfloat dist6 = smin(baseDist, pyramide(pos, vec3(-2.5, 1.0, -4.0), 1.0, 1.0, 1.0), 0.25);\n\tfloat dist7 = smin(baseDist, pyramide(pos, vec3(-5.0, 1.0, -6.0), 1.2, 1.0, 0.5), 0.25);\n\t\n\tfloat dist8 = smin(baseDist, pyramide(pos, vec3(-2.0, 1.0, -1.5), 0.5, -0.0, 3.0), 0.25);\n\t\n\tfloat dist9 = smin(baseDist, pyramide(pos, vec3(-4.0, 1.0, -2.0), 0.5, 2.5, 1.0), 0.25);\n\t\n    float f = 0.1;\n\tfloat dist = smin(dist1, dist2, f);\n\tdist = smin(dist, dist3, f);\n\tdist = smin(dist, dist4, f);\n\tdist = smin(dist, dist5, f);\n\tdist = smin(dist, dist6, f);\n\tdist = smin(dist, dist7, f);\n\tdist = smin(dist, dist8, f);\n\tdist = smin(dist, dist9, f);\n\t\n\treturn dist;\n}\n\nfloat getObject1Distance(vec3 pos)\n{\n    float dist = cylinder(pos + vec3(-2.6, 0.0, -10.0), 1.0);\n\treturn dist;\n}\n\nfloat getObject2Distance(vec3 pos)\n{\n    float dist = cylinder(pos + vec3(0.0, 0.0, -10.0), 1.0);\n\treturn dist;\n}\n\nfloat getObject3Distance(vec3 pos)\n{\n    float dist = cylinder(pos + vec3(2.6, 0.0, -10.0), 1.0);\n\treturn dist;\n}\n\n\nfloat getObjectDistance(vec3 pos, float index)\n{\n    if (index == 1.0)\n\t\treturn getObject1Distance(pos);\n    else if (index == 2.0)\n\t\treturn getObject2Distance(pos);\n    else if (index == 3.0)\n\t\treturn getObject3Distance(pos);\n    else\n    \treturn getObject0Distance(pos);\n}\n\n\nvec2 getNearestObjectDistanceData(vec3 pos)\n{\n    vec2 nearest = vec2(getObject0Distance(pos), 0);\n\tfloat nearest1 = getObject1Distance(pos);\n\tfloat nearest2 = getObject2Distance(pos);\n\tfloat nearest3 = getObject3Distance(pos);\n\t\n\tif (nearest1 < nearest.x)\n\t\tnearest = vec2(nearest1, 1.0);\n\tif (nearest2 < nearest.x)\n\t\tnearest = vec2(nearest2, 2.0);\n\tif (nearest3 < nearest.x)\n\t\tnearest = vec2(nearest3, 3.0);\n   \n    return nearest;\n}\n\nvec3 getNormal(vec3 point, float index)\n{\n\tfloat d0 = getObjectDistance(point, index);\n\tfloat dX = getObjectDistance(point - vec3(epsilon, 0.0, 0.0), index);\n\tfloat dY = getObjectDistance(point - vec3(0.0, epsilon, 0.0), index);\n\tfloat dZ = getObjectDistance(point - vec3(0.0, 0.0, epsilon), index);\n\tvec3 baseNormal = normalize(vec3(dX-d0, dY-d0, dZ-d0));\n    if (index == 0.0)\n    {\n        float factor = -point.y < 0.8 ? 0.0 : (-point.y - 0.8);\n        vec3 alpha = texture(iChannel3, 2.0 * point.xz).rgb * 2.0 - 1.0;\n        vec3 beta = texture(iChannel1, point.xz).rgb * 2.0 - 1.0;\n        vec3 gamma = mix(alpha, beta, 0.6);\n        baseNormal = normalize(baseNormal + factor * gamma * 2.0);\n    }\n    return baseNormal;\n}\n\nobjectInfo getObjectInfo(float index)\n{\n    if (index == 1.0)\n        return objects[1];\n    else if (index == 2.0)\n        return objects[2];\n    else if (index == 3.0)\n        return objects[3];\n    return objects[0];\n}\n\nvec3 getLight(traceInfo info)\n{\n    vec3 point_normal = getNormal(info.pos, info.objIndex);\n    vec3 light_dir = -normalize(lightPos - info.pos);\n    \n    float attenuation = 1.0 / (1.0 + K*pow( length(lightPos - info.pos), 2.0));\n    vec3 reflected_light_dir = reflect(-light_dir, point_normal);\n\n    float dotp_diffuse = attenuation * max(0.25, dot(light_dir, point_normal));\n    vec3 color = vec3(dotp_diffuse);\n    color = smoothstep(vec3(0.0), vec3(1.0), color);\n    color = pow(color, vec3(1.0/2.2));\n    color *= lightColor;\n    return color + ambientLightColor;\n\n}\n\nvec3 getColor(traceInfo info)\n{\n    objectInfo object = getObjectInfo(info.objIndex);\n    \n    return object.albedo * getLight(info) * (1.0 - object.emission.a) + object.emission.rgb;\n}\n\ntraceInfo nextTraceInfo(traceInfo info)\n{\n    traceInfo next = info;\n    next.level ++;\n    next.pos -= info.dir * epsilon;\n    next.color = vec3(0.0, 0.0, 0.0);\n    return next;\n}\n\nbool trace(inout traceInfo info)\n{   \n    float backFactor = 0.5;\n    info.color += backFactor * orange * max(0.0, info.dir.x);\n    info.color += backFactor * blue * max(0.0, -info.dir.x);\n    \n\tfloat d = 0.0;\n\tbool success = false;\n\tfor (int i = 0; i < max_steps; i++) {\n\t\t\n        vec2 objData = getNearestObjectDistanceData(info.pos);\n\t\tif(objData.x < epsilon && info.objIndex != objData.y)\n        {\n            info.objIndex = objData.y;\n\t\t\tsuccess = true;\n            break;\n        }\n\t\tinfo.pos += info.dir * objData.x;\n        info.steps++;\n\t\td += objData.x;\n\t\tif (d > max_distance)\n        {\n\t\t\tbreak;\n        }\n\t}\n\tif (!success)\n\t\tinfo.objIndex = -1.0;\n\telse\n\t\tinfo.color = getColor(info);\n\n\treturn success;\n}\n\ntraceInfo init(vec2 fragCoord)\n{  \n    /*\n\t*********************************\n\t** EDIT OBJECT PROPERTIES HERE **\n\t*********************************\n\t*/\n    // Terrain\n    objects[0] = objectInfo(black, vec4(0.0), 1.5 /*reflectivity*/, 0.5 /*fuzziness*/, -0.3 /*fresnelBias*/);\n    \n    objects[3] = objectInfo(orange, vec4(orange, 1.0), 0.0 /*reflectivity*/, 0.0 /*fuzziness*/, 0.0 /*fresnelBias*/);\n    objects[2] = objectInfo(teal, vec4(teal, 1.0), 0.0 /*reflectivity*/, 0.0 /*fuzziness*/, 0.0 /*fresnelBias*/);\n    objects[1] = objectInfo(blue, vec4(blue, 1.0), 0.0 /*reflectivity*/, 0.0 /*fuzziness*/, 0.0 /*fresnelBias*/);\n    \n\ttraceInfo info;\n    info.objIndex = -1.0;\n    \n    //vec2 mouse = vec2(iTime * 0.1, 3.0);\n    //info.pos = vec3(sin(mouse.x), 0, cos(mouse.x)) * 1.0 * (mouse.y);\n    info.pos = vec3(0.0, 0.0, -1);\n    vec3 forward = normalize(vec3(0, 0, 1.0));\n    \n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 right = cross(up, forward);\n    up = cross(forward, right);\n    \n    vec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy) / min(iResolution.x, iResolution.y);\n    info.dir = normalize(up * uv.y + right *uv.x + forward);\n\n\treturn info;\n}\n\nvec3 rotateAround(vec3 v, vec3 k, float theta)\n{\n  return v * cos(theta) + cross(k, v) * sin(theta) + k * dot(k, v) * (1.0 - cos(theta));\n}\n\ntraceInfo marchScene(traceInfo info, vec2 fragCoord)\n{    \n    // Scan scene\n    vec3 startPos = info.pos;\n    vec3 eyeForward = info.dir;\n    \n    if (trace(info))\n    {\n        objectInfo object = getObjectInfo(info.objIndex);\n        if (object.reflectivity > 0.0)\n        {\n            float distanceToOrigin = distance(startPos, info.pos);\n            \n            vec3 normal = getNormal(info.pos, info.objIndex);\n            float fresnelTerm = clamp(0.0, 1.0, object.fresnelBias + 1.0 - dot(eyeForward, normal));\n            \n            vec3 reflectionColor;\n            float rayInfluence = 1.0 / float(fuzzynessSteps);\n            \n            float fuzzyness = object.fuzzyness / (pow(distanceToOrigin, 4.0));\n            vec3 baseRayDir = reflect(info.dir, normal);\n            for (int i = 0; i < fuzzynessSteps; ++i)\n            {\n                float percentage = float(i) / float(fuzzynessSteps);\n\n                traceInfo subRay = nextTraceInfo(info);\n                \n                vec3 delta = rotateAround(vec3(0.0, 1.0, 0), baseRayDir, PI * 2.0 * percentage);\n                subRay.dir = normalize(delta * fuzzyness + baseRayDir);\n\t\t\t\t\n                trace(subRay);\n\n                reflectionColor += subRay.color * rayInfluence;\n            }\n           \n            float reflectivity = mix(0.0, object.reflectivity, fresnelTerm);\n            info.color = mix(info.color, reflectionColor, reflectivity);\n        }\n    }\n    return info;\n}\n\nfloat getIsGrid(in vec2 uv, float gridSize, float scale)\n{\n    vec2 isGrid = 1.0 - mod(uv.xy, gridSize);\n    return max(0.0, max(isGrid.x, isGrid.y)) > 0.0 ? scale : 0.0;\n}\n\nvec3 gridColor(in vec2 uv)\n{\n    const float gridSize = 50.0;\n    float rightMostGridLimit = float(int(iResolution.x / gridSize)) * gridSize + 1.0 - gridSize;\n    float upperGridLimit = float(int(iResolution.y / gridSize)) * gridSize + 1.0 - gridSize;\n\n    // grid as background\n    if (uv.x > gridSize && uv.x <= rightMostGridLimit &&\n        uv.y > gridSize && uv.y <= upperGridLimit) \n    {\n    \tfloat isGrid = getIsGrid(uv.xy, gridSize, 0.5);\n        isGrid += getIsGrid(uv.xy, gridSize / 4.0, 0.1);\n    \treturn vec3(isGrid * 0.5 * max(0.0, (uv.y - gridSize * 5.0) / iResolution.y));\n    }\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    traceInfo info = marchScene(init(fragCoord), fragCoord);   \n    fragColor.rgb = info.color;\n    \n    // grid\n    if (info.objIndex != 0.0)\n    \tfragColor.rgb += gridColor(fragCoord.xy);\n    \n    if (info.objIndex == -1.0) {\n        vec2 starMapUv = fragCoord.xy / iResolution.xy;\n        vec3 star = texture(iChannel0, starMapUv).rgb;\n        fragColor.rgb += vec3(pow(star.x * star.z, 10.0));\n    }\n    \n    // center glow\n    float center = ((fragCoord.x / iResolution.x) - 0.5) * 2.0;\n    float right = 1.0 - clamp(0.0, 1.0, pow(center, 0.5));\n    float left = 1.0 - clamp(0.0, 1.0, pow(-center, 0.5));\n    center = clamp(0.0, 1.0, pow(1.0 - abs(center), 4.0));\n    \n    vec3 glowColor = mix(max(0.0, left) * orange + max(0.0, right) * blue, teal, center);\n    fragColor.rgb += pow(float(info.steps) / float(max_steps), 2.0) * glowColor * 10.0;\n    fragColor.rgb += glowColor * 0.4;\n}\n","name":"Image","description":"","type":"image"}]}