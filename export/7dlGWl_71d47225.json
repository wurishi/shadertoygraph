{"ver":"0.1","info":{"id":"7dlGWl","date":"1617244920","viewed":91,"name":"PoolTable, XmasTree, ChromeGift","username":"mkis98","description":"A small room built using the unions, intersections and differences of primitives found on https://iquilezles.org/articles/distfunctions/distfunctions.htm.\n\nThe scene has two light sources (see buffer A).","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["reflection","shadows","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This file contains the \n// ---- SPHERE TRACING ----\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int matId;      // The material in the intersection (if there's an intersection)\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct ColorResult \n{\n    vec4 color;\n    \n    Ray reflectedRay;\n};\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\n\n\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, -1, 0);\n    Volume volume;\n    \n    int i = 0; do\n    {\n        volume = sdf(ray.P+ret.T*ray.V);\n        ret.T += volume.sdf;\n        ret.matId = volume.matId;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\tvolume.sdf\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(volume.sdf <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)).sdf,sdf(p+vec3(0,eps,0)).sdf,sdf(p+vec3(0,0,eps)).sdf);\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)).sdf,sdf(p-vec3(0,eps,0)).sdf,sdf(p-vec3(0,0,eps)).sdf);\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n    //return vec4(0, 0, 0, 1);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nColorResult hitColor(Ray ray, float t, int matId)\n{\n    /* materials[matId]:\n           vec3 color;\n           vec3 emission;\n           float roughness;\n           float metalness;\n    */\n\n\n    vec3 p = ray.P + ray.V*t;\n    vec3 n = normal(p);\n    \n    vec3 lightPos1 = vec3(00.,20.,00.);\n    vec3 lightPos2 = vec3(30, 20, 10);\n    \n    vec3 v = -ray.V;\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 l2 = normalize(lightPos2-p);\n    \n    //ambient ~ emission\n    vec3 k_a = materials[matId].emission;\n    \n    //diffuse\n    float costheta1 = max(dot(n,l1),0.);\n    float costheta2 = max(dot(n,l2),0.);\n    vec3 k_d = materials[matId].color;\n    \n    //specular\n    vec3 k_s = vec3(0.4);\n    \n    vec3 h1 = normalize(l1+v);\n    float si1 = pow(clamp(dot(h1,n),0.,1.), materials[matId].roughness);\n    vec3 h2 = normalize(l2+v);\n    float si2 = pow(clamp(dot(h2,n),0.,1.), materials[matId].roughness);\n    \n    //sum\n    float m = materials[matId].metalness;\n    vec3 col = k_a + 0.5*((1.0 - m) * k_d + m * si1*k_s)*costheta1 \n                   + 0.5*((1.0 - m) * k_d + m * si2*k_s)*costheta2;\n   \n    SphereTraceDesc params = SphereTraceDesc(0.01, 32);\n    Ray lightRay1 = Ray(p + eps * l1 + eps * n, 0.5, l1, distance(p, lightPos1));\n    Ray lightRay2 = Ray(p + eps * l2 + eps * n, 0.5, l2, distance(p, lightPos2));\n    \n    TraceResult r1 = sphere_trace(lightRay1, params);\n    TraceResult r2 = sphere_trace(lightRay2, params);\n    \n    if (bool(r1.flags & 2))\n        col = 0.66 * col;\n    if (bool(r2.flags & 2))\n        col = 0.66 * col;\n        \n    vec3 rray = reflect(ray.V, n); // reflected ray\n    return ColorResult(vec4(col, 1.0), Ray(p, 0.5, rray, 30.0));\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw+StartLookAtAngles;\t    // spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)  //mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P (point)\n               0.5,\t\t\t\t\t\t\t//minimum distance\n               normalize(w+px.x*u+px.y*v),\t//V (direction)\n               100.);\t\t\t\t\t\t//maximum distance\n}\n\n// ---- MAIN ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    // Set epsilon and maximum iteration\n    \n    SphereTraceDesc params = SphereTraceDesc(0.001, 128);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n    \n    bool calculatingReflections = false;\n    int reflectionsCalculated = 0;\n    float reflectiveness = 1.0;\n    do {\n        if(bool(result.flags & 1)) {\n            fragColor += reflectiveness * missColor(ray); // background\n            calculatingReflections = false;\n        }       \n        else if(bool(result.flags&2)) {\n            ColorResult cr = hitColor(ray, result.T, result.matId);\n                \n            fragColor += reflectiveness * cr.color; // object color    \n            reflectiveness = materials[result.matId].reflectiveness;\n            \n            ray = cr.reflectedRay;\n            result = sphere_trace(ray, params);\n            \n            calculatingReflections = true;\n            reflectionsCalculated++;            \n        }      \n        else {\n            fragColor += errorColor(ray, result.T);  // # of iterations weren't enough to get eps-close to the object\n            calculatingReflections = false;\n        }\n    }\n    // sadly, no recursion is allowed in glsl\n    while (calculatingReflections && reflectionsCalculated < maxNumberOfReflections);\n    \n    \n\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);   // previous frame in texture\n    fragColor = 0.0*prev + 1.0*fragColor;                     // adjustable motion blur (currently: none)\n    fragColor.w = result.T;\n\n    // Data saving trick (2 specially reserved pixels)\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data-StartLookAtAngles;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1416;\nconst float eps = 0.00001;\nconst int maxNumberOfReflections = 2;\n\nconst vec3 EyeStartPosition = vec3(-6.5,8.1,31.5);\nconst vec2 StartLookAtAngles = vec2(0.0, 0.1);\n\n\nstruct Material {\n    vec3 color;    \n    vec3 emission;\n    float roughness;  // shininess\n    float metalness;  // m * kd + (1 - m) * ks * shinefactor \n    float reflectiveness; // [0-1]\n};\n\nstruct Volume {\n    float sdf;\n    int matId;\n};\n\n\n// available materials\nMaterial materials[11] = Material[11] (\n    Material(vec3(0.0), vec3(0.1), 7.0, 0.8, 0.2),                   // 0 black tile\n    Material(vec3(1.0), vec3(0.0), 7.0, 0.3, 0.2),                   // 1 light gray tile\n    Material(vec3(1.0/pi), vec3(0.39, 0.26, 0.13), 1.0, 0.1, 0.0),   // 2 light wood\n    Material(vec3(1.0/pi), vec3(0,0.7,0), 1.0, 0.0, 0.0),            // 3 green fabric\n    Material(vec3(1.0/pi), vec3(0.7,0,0), 7.0, 0.8, 0.3),            // 4 red ball\n    Material(vec3(1.0/pi), vec3(0.7,0.7,0), 7.0, 0.8, 0.3),          // 5 yellow ball\n    Material(vec3(1.0/pi), vec3(0.8), 15.0, 0.8, 0.3),               // 6 white ball\n    Material(vec3(0.5/pi), vec3(0.15,0.1,0.08), 7.0, 0.01, 0.0),     // 7 dark wood\n    Material(vec3(1.0/pi), vec3(0,0.4,0), 7.0, 0.01, 0.0),           // 8 evergreen\n    Material(vec3(0), vec3(0), 1.0, 0.0, 1.0),                       // 9 chrome box\n    Material(vec3(1.0/pi), vec3(0.6, 0.0, 0.0), 7.0, 0.0, 0.0)       // 10 red ribbon\n);\n\n\n// Union implementations\nfloat Union(float sdf1, float sdf2) {\n    return min(sdf1, sdf2);\n}\n\nVolume Union(Volume v1, Volume v2) {\n    if (v1.sdf > v2.sdf)\n       return v2;\n    \n    return v1;    \n}\n\nVolume Union(Volume v1, float sdf, int matId) {  \n    return Union(v1, Volume (sdf, matId));\n}\n\nVolume Union(float sdf, Volume v1, int matId) {\n    return Union(v1, sdf, matId);\n}\n\n// Intersection implementations\nfloat Intersection(float sdf1, float sdf2) {\n    return max(sdf1, sdf2);\n}\n\nVolume Intersection(Volume v1, Volume v2) {\n    if (v1.sdf > v2.sdf)\n       return v1;\n    \n    return v2;    \n}\n\nVolume Intersection(Volume v1, float sdf, int matId) {  \n    return Intersection(v1, Volume (sdf, matId));\n}\n\nVolume Intersection(float sdf, Volume v1, int matId) {\n    return Intersection(v1, sdf, matId);\n}\n\n// Difference implementations\nfloat Difference(float sdf1, float sdf2) {\n    return max(sdf1, -sdf2);\n}\n\nVolume Difference(Volume v1, Volume v2) {\n    if (v1.sdf > -v2.sdf) {\n        return Volume (v1.sdf, v1.matId);\n    }\n   \n    return Volume (-v2.sdf, v2.matId);    \n}\n\nVolume Difference(Volume v1, float sdf, int matId) {  \n    return Difference(v1, Volume (sdf, matId));\n}\n\nVolume Difference(float sdf, Volume v1, int matId) {\n    return Difference(v1, sdf, matId);\n}\n\n\n// helper functions from \"iquilezles.org\"\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// primitives from \"iquilezles.org\"\n\nfloat sdXZPlan(vec3 p, float hOffset)\n{\n    return p.y + hOffset;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCylinder(vec3 p, vec3 c)\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone(in vec3 p, in vec2 c, float h)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n///SDF\n\nVolume sdf(in vec3 p)\n{\n    Volume tiledFloor = Volume(1000.0, -1);    \n    for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 10; ++j) {\n            float tileSdf = sdBox(p - vec3(4*i, -2, 4*j), vec3(2.0, 0.01, 2.0));                     \n            int tileMatId = (i+j) % 2;\n\n            Volume tile = Volume(tileSdf, tileMatId);\n            tiledFloor = Union(tiledFloor, tile);\n        }\n    }\n    \n    float tableFrameSdf = sdBox(p - vec3(10, 3, 30), vec3(10, 0.3, 4));\n    Volume tableFrame = Volume(tableFrameSdf, 2);\n    float tableFabricSdf = sdBox(p - vec3(10, 3.1, 30), vec3(9.3, 0.3, 3.3));\n    Volume tableFabric = Volume(tableFabricSdf, 3);\n    \n    Volume billiardsTable = Difference(tableFrame, tableFabric);\n    for (float i = 0.0; i < 2.0; ++i)\n    {\n        for (float j = 0.0; j < 3.0; ++j)\n        {\n            float holeSdf = sdCylinder(p - vec3(0.4 + j * 9.25, 0, 26.75 + i * 6.6), vec3(0.3,0,0.3));\n            Volume hole = Volume(holeSdf, 2);\n            billiardsTable = Difference(billiardsTable, hole);\n        }\n    }\n    \n    for (float i = 0.0; i < 2.0; ++i) {\n        for (float j = 0.0; j < 2.0; ++j) {\n            float legSdf = sdBox(p - vec3(2.4 + j * 14.5, 0, 26.4 + i * 7.3), vec3(0.3,3,0.3));\n            Volume leg = Volume(legSdf, 2);\n            billiardsTable = Union(billiardsTable, leg);\n        }\n    }\n    \n    vec3 packPos = vec3(5, 3, 30);\n    float ballRadius = 0.2;\n    for (float i = 0.0; i < 5.0; ++i) {\n        // we'd like to achieve a triangle shaped pack of the balls\n        // z0 will be the first placed ball's z position in the given line\n        float z0 = packPos.z - (float((int(i) % 2)) / 2.0) * 2.0 * ballRadius;\n        \n        for (float j = 0.0; j <= i; ++j) {\n            vec3 ballPos = packPos;\n            float m = (int(j) % 2) == 0 ? -1.0 : 1.0;\n            ballPos.z = z0 + m * j * 2.0 * ballRadius;\n            ballPos.x -= i * 2.0 * ballRadius;\n            z0 = ballPos.z;\n        \n            float ballSdf = sdSphere(p - ballPos, ballRadius);\n            Volume ball = Volume(ballSdf, int(i + j) % 2 + 4);\n            billiardsTable = Union(billiardsTable, ball);\n        }\n    }\n\n    float whiteBallSdf = sdSphere(p - vec3(15, 3, 30), ballRadius);\n    Volume whiteBall = Volume(whiteBallSdf, 6);\n    billiardsTable = Union(billiardsTable, whiteBall);\n\n\n    vec3 xmasTreePos = vec3(30, 0, 5);\n    float trunkSdf = sdCylinder(p - xmasTreePos, vec3(1));     // infinite cylinder\n    float trunkBBSdf = sdBox(p - xmasTreePos, vec3(3, 4, 3));  // bound this cylinder with a box (by taking the intersection later)\n    Volume xmasTree = Volume(trunkSdf, 7);\n    Volume trunkBB = Volume(trunkBBSdf, 0);\n    xmasTree = Intersection(xmasTree, trunkBB);\n    \n    for (float i = 0.0; i < 5.0; ++i) {\n        float greenerySdf = sdCone(p - xmasTreePos - vec3(1, 10.0 + i * 2.0, 1), vec2(0.5, 1), 8.0 - i);\n        Volume greenery = Volume(greenerySdf, 8);\n        xmasTree = Union(xmasTree, greenery);\n    }  \n    \n    vec3 giftPos = vec3(10, 2, 10);\n    float giftSdf = sdRoundBox(p - giftPos, vec3(4,4,4), 1.0);\n    Volume gift = Volume(giftSdf, 9);\n    float ribbonWrap1Sdf = sdRoundBox(p - giftPos, vec3(4.1, 4.1, 0.3), 1.0);\n    Volume ribbonWrap1 = Volume(ribbonWrap1Sdf, 10);\n    float ribbonWrap2Sdf = sdRoundBox(p - giftPos, vec3(0.3, 4.1, 4.1), 1.0);\n    Volume ribbonWrap2 = Volume(ribbonWrap2Sdf, 10);\n    gift = Union(Union(gift, ribbonWrap1), ribbonWrap2);\n    \n    float ribbonKnot1Sdf = sdCappedCylinder(p - vec3(9.0, 7.8, 10), 1.2, 0.6);\n    float ribbonKnot1InnerSdf = sdCappedCylinder(p - vec3(9.0, 7.8, 10), 1.15, 0.7);\n    Volume ribbonKnot1 = Volume(ribbonKnot1Sdf, 10);\n    Volume ribbonKnot1Inner = Volume(ribbonKnot1InnerSdf, 10);\n    gift = Union(gift, Difference(ribbonKnot1, ribbonKnot1Inner));\n\n    float ribbonKnot2Sdf = sdCappedCylinder(p - vec3(11.0, 7.8, 10), 1.2, 0.6);\n    float ribbonKnot2InnerSdf = sdCappedCylinder(p - vec3(11.0, 7.8, 10), 1.15, 0.7);\n    Volume ribbonKnot2 = Volume(ribbonKnot2Sdf, 10);\n    Volume ribbonKnot2Inner = Volume(ribbonKnot2InnerSdf, 10);\n    gift = Union(gift, Difference(ribbonKnot2, ribbonKnot2Inner));\n\n    return Union(Union(Union(tiledFloor, billiardsTable), xmasTree), gift);\n}","name":"Common","description":"","type":"common"}]}