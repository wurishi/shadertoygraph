{"ver":"0.1","info":{"id":"Nttyzs","date":"1673109091","viewed":54,"name":"aaaaaaaa01","username":"MatthewBanyas","description":"lots of learning","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GLSL: OpenGL Shading Language\n// A shader is a program that assigns a color to a pixel.\n// Basically, your GPU runs the shader for every little pixel in the image to the left\n// every single frame. If you're thinking, \"Wow, that's a lot of executions of this\n// program\"... you're right. It's a lot.\n//\n// GPUs are very very stupid. They can't really branch (every if statement and loop is\n// actually faked cleverly...), they can't manipulate I/O or memory that isn't\n// explicitly bound to them through a texture or whatever, they're really simple.\n// But! They can do MATH!!!!\n//\n// So that gives us RAW!!! POWER!!!!!\n\n// In Shadertoy, you get some special inputs that are accessible EVERYWHERE.\n//   - iTime is a float (1-dimensional) that is the # of seconds since start.\n//   - iResolution.xy is the # of pixels in the image (width, height)\n//   - fragCoord is the pixel you are currently drawing\n\nfloat PI = 3.14159;\n\n// This function colors a pixel.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // Bottom-left is (0, 0);  top-right is (1, 1);  center is (0.5, 0.5)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    //fragColor = vec4(vec3(0.5 + 0.5 * sin(iTime)), 1.0);\n    //fragColor = vec4(uv.yyy, 1.0);\n    \n    float scale = 5.0 + 5.0*sin(iTime);\n    \n    vec2 p = fragCoord - vec2(iResolution.x/2.0, iResolution.y/2.0);\n    p *= 2.0/iResolution.y;\n    p *= scale;\n    \n    float dist = length(p);\n    float ang = atan(p.y, p.x); // -pi to pi\n    float wobble = sin(ang*10.0+10.0*iTime); // -1 to 1, 10 cycles around circle\n    float a = floor(dist*(1.0+0.2*wobble))/scale;\n    float b = 0.5 + 0.5 * wobble;\n    \n    vec3 u = vec3(0.05, 0.07, 0.11);   // as a goes up, we move in the u direction\n    vec3 v = vec3(-0.2, 0.1, 0.4);    // as b goes up, we move in the v direction\n    vec3 c = vec3(0.3, 0.6, 0.1);\n    fragColor = vec4(c + a * u + b * v, 1.0);\n    fragColor.xyz = pow(fragColor.xyz, vec3(2.2));\n    \n    \n    \n    //p += 0.05 * vec2(sin(p.y * 10.0 + iTime), cos(p.x * 7.0 + iTime * 1.2));\n    \n    //float angle = iTime * 0.2;\n    //p = vec2(\n    //    sin(angle) * p.x + cos(angle) * p.y,\n    //    cos(angle) * p.x - sin(angle) * p.y\n    //);\n    \n    //fragColor = vec4(p - floor(p), 0.5, 1.0);\n}","name":"Image","description":"","type":"image"}]}