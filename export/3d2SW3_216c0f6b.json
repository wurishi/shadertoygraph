{"ver":"0.1","info":{"id":"3d2SW3","date":"1555105999","viewed":61,"name":"RayMarch_Demo","username":"zlanto2024","description":"RayMarch_demo, public","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define CAMERA_X 0.\n#define CAMERA_Y 3\n#define CAMERA_Z 0.\n#define LIGHT_Z 5.\n#define OBJ_Z 7.\n#define LIGHT_MOVE_SPEED 3.\n#define OBJ_MOVE_SPEED 3.\n\nfloat dBox(vec3 curMarchPoint, vec3 s)\n{\n    return length(max(abs(curMarchPoint) - s, 0.));\n}\n\nfloat sdTorus(vec3 curMarchPoint, vec2 r)\n{\n   float x = length(curMarchPoint.xz) - r.x;\n   return length(vec2(x, curMarchPoint.y)) - r.y;\n}\n\nfloat sdCapsule(vec3 curMarchPoint, vec3 sphereA, vec3 sphereB, float r)\n{\n    vec3 vAtoB = sphereB - sphereA;\n    vec3 vAtoP = curMarchPoint - sphereA;\n    \n    float dotAPonAB = dot(vAtoB, vAtoP) / dot(vAtoB, vAtoB);\n    dotAPonAB = clamp(dotAPonAB, 0., 1.);\n    \n    vec3 closestPointOnCapsule = sphereA + vAtoB * dotAPonAB;\n    \n    return length(curMarchPoint - closestPointOnCapsule) - r;\n}\n\nfloat sdSphereDist(vec3 curMarchPoint, vec3 pos, float r)\n{\n    return length(curMarchPoint - pos) - r;\n}\n\nfloat GetDist(vec3 curMarchPoint)\n{\n    vec2 iTimeInterp1 = vec2(sin(iTime * OBJ_MOVE_SPEED), cos(iTime * OBJ_MOVE_SPEED));\n    \n    //Sphere\n    vec4 sphereDef = vec4( 0, 2.5, OBJ_Z, 0.5f);\n    sphereDef.y += iTimeInterp1.y;\n    sphereDef.x += iTimeInterp1.x * .5;\n    float sphereDist = sdSphereDist(curMarchPoint, sphereDef.xyz, sphereDef.w);\n    \n    //Capsule\n    vec3 sphere1 = vec3( -2., 1., OBJ_Z);\n    vec3 sphere2 = vec3( -2., 1., OBJ_Z);\n    sphere1.xz += iTimeInterp1;\n    sphere2.xz -= iTimeInterp1;\n    float capsuleRad =  0.2;\n    float capsuleDist = sdCapsule(curMarchPoint, sphere1, sphere2, capsuleRad);\n    \n    //Torus\n    vec3 torusPos = vec3(0.f, 1., OBJ_Z);\n    torusPos.xz += iTimeInterp1;\n    vec2 torusSize = vec2(1., .2);\n    float torusDist = sdTorus(curMarchPoint - torusPos, torusSize);\n    \n    vec3 boxPos = vec3(0., 1., OBJ_Z);\n    boxPos.xz += iTimeInterp1;\n    vec3 boxSize = vec3(.5);\n    float boxDist = dBox(curMarchPoint - boxPos, boxSize);\n    \n    //Plane\n    float planeDist = curMarchPoint.y;\n    \n    float retDist = min(planeDist, sphereDist);\n    retDist = min(retDist, capsuleDist);\n    retDist = min(retDist, torusDist);\n    retDist = min(retDist, boxDist);\n    \n    return retDist;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float distFromOrigin = 0.f;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 currMarchPoint = rayOrigin + rayDir * distFromOrigin;\n        \n        //gets the min radius from currMarchPoint to the scene\n        float distToScene = GetDist(currMarchPoint); \n        distFromOrigin += distToScene;\n        \n   \t\tif (distFromOrigin > MAX_DIST || distToScene < SURF_DIST) break;\n    }\n    \n    return distFromOrigin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float distP = GetDist(p);\n    vec2 e = vec2(0.01, 0); //epsilon vec\n    \n    vec3 normal = distP - vec3 (GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n    \n    return normalize(normal);\n}\n\nfloat GetLight(vec3 p)\n{\n    //Simple diffuse light model\n    vec3 lightPos = vec3 (0, 10, LIGHT_Z);\n    lightPos.xz += vec2(sin(iTime * LIGHT_MOVE_SPEED), cos(iTime * LIGHT_MOVE_SPEED));\n    \n    vec3 dirToLight = normalize(lightPos - p);\n    vec3 normalPointP = GetNormal(p);\n    \n    float diffuseLight = clamp(dot(normalPointP, dirToLight), 0., 1.);\n    \n    //shadow\n    float shadowDist = RayMarch(p + normalPointP * SURF_DIST * 2.f, dirToLight);\n    if (shadowDist < length(lightPos - p) && true)\n    {\n        diffuseLight *= 0.1f;\n    }\n    \n    return diffuseLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\t\n    //Ray fire from center and direction of each pixel\n    vec3 rayOrigin = vec3(CAMERA_X, CAMERA_Y, CAMERA_Z);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y-0.4, 1));\n    \n    float intersectionDist = RayMarch(rayOrigin, rayDir);\n    \n    vec3 shadePoint = rayOrigin + rayDir * intersectionDist;\n    float diffuseColor = GetLight(shadePoint);\n    \n    vec3 col = vec3(diffuseColor);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}