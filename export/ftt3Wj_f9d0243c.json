{"ver":"0.1","info":{"id":"ftt3Wj","date":"1636737047","viewed":188,"name":"Buffer Experiment","username":"SnoopethDuckDuck","description":"Code is forked from something else so 99% of it is unused, very messy","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"NsGSDV","parentname":"CryptoRoyale Trails Test"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord.xy)/iResolution.xy;\n       \n    // blob color\n    vec3 col = vec3(0.);//texture(iChannel1, uv).xyz;\n \n    // squiggle (distort uv)\n    // uv.x += 0.005 * cos(40. * uv.y + 1. * time);\n    // uv.y += 0.005 * sin(40. * uv.x + 1. * time);\n    \n    // trail value\n    float l = texture(iChannel0, uv).x;\n    l = clamp(l, 0., 1.);\n\n    // trail color\n    vec3 c = vec3(l);\n    c *= getDarkCol(iTime);\n    \n    float k = step(length(col), 0.);\n    c = mix(col, c, k);\n    \n    // background (not actually sure what the step is doing lol)\n    c = max(c, vec3(36,26,91)/255.);\n   \n   \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define time 3.5 * iTime\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 getDarkCol(float t) {\n    float colTime = fract(0.15 * t);\n    vec3 col;\n    if (colTime < 1./3.)\n        col = vec3(0., 220., 244.) / 255.;\n    else if (colTime < 2./3.)\n        col = vec3(245., 208., 0.) / 255.;\n    else\n        col = vec3(219., 0., 255.) / 255.;\n    return col;\n}\n\nvec3 getLightCol(float t) {\n    float colTime = fract(0.15 * t);\n    vec3 col;\n    if (colTime < 1./3.)\n        col = vec3(0., 255., 195.) / 255.;\n    else if (colTime < 2./3.)\n        col = vec3(238., 243., 0.) / 255.;\n    else\n        col = vec3(255., 59., 235.) / 255.;\n    return col;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nfloat Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 ).x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5 * iResolution.xy)/iResolution.y;\n    vec2 tuv = fragCoord.xy/iResolution.xy;\n    \n    ivec2 px = ivec2( fragCoord );\n    \n    // center cell\n    float e = Cell(px); \n\n    // neighbour cells\n    float t = Cell(px + ivec2(0, int(-1. / iResolution.y)));\n    float b = Cell(px + ivec2(0,int(1. / iResolution.y)));\n    float l = Cell(px + ivec2(int(-1. / iResolution.y),0));\n    float r = Cell(px + ivec2(int(1. / iResolution.y),0));   \n\n    float fb = texture(iChannel0, tuv).x;\n\n\n    float str = 1. ;//+ 16. * fb * fb * (1.-fb) * (1.-fb);//0.5 + 0.5 * cos(100. * fb);\n    //str *= 2.;\n    float a = atan(uv.y, uv.x);\n    float d = length(uv);\n    //vec2 p = 0.4 * vec2(thc(str,str + time), ths(str, str + 0.813149  * time));\n    vec2 p = (.5 + .5 * cos(a + 50. * d + iTime)) * 0.4 * \n    vec2(cos(str + 50. * d + 3. * a + str * time), \n         sin(str - 0. * d + 10. * a + 200. * str * time));\n    \n    //vec2 p = 0.4 * vec2(cos(str * time), sin(0.813149 * str * time));\n\n    //vec2 p2 = uv - 0.4 * vec2(cos(time - 0.001), sin(0.8 * (time - 0.001)));\n    //vec2 dir = normalize(p - p2); // idk if this works\n   \n    float val = 3. * smoothstep(-0.05,0.05,0.02 - length(uv - p));\n    float k = 1.;\n  \n   \n   // fb += 0.1 * step(1., fb); // increment fb by 0.1 every frame if it's >=1. \n    fb *= 0.99;\n\n\n    //fb *= step(fb, 5.);\n\n    // applies a fade\n    //val = mix(val, fb, 0.9);\n    \n    // constant value but end is buggy :(\n    val = max(val, fb);\n    \n    vec3 c = vec3(val);\n\n    fragColor = vec4(c,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 blob(vec2 uv, float scale) {    \n    // dark outer circle\n    float c0 = 0.5 * step(length(uv), scale);\n   \n    // outline (fudged)\n    float oc = 0.5 * step(length(uv), 1.12 * scale);\n    oc -= c0;\n     \n    // light inner circle\n    float c1 = step(length(uv + (sqrt(2.)/9.) * scale * vec2(1,-1)), 7./9. * scale);\n    c0 = max(c0, c1);\n    \n    // 2 dark inner dots\n    float c2 = 2. * step(length(uv - 0.3 * scale * vec2(-0.5 , 1.5)), 0.2 * scale);\n    float c3 = 2. * step(length(uv + 0.3 * scale * vec2(1.6, 0.)), 0.15 * scale);\n    c0 = max(c0, max(c2, c3));\n    \n    vec3 col;\n    if (c0 == 0.5 || c0 == 2.)\n        col = getDarkCol(iTime);\n    else if (c0 == 1.)\n        col = getLightCol(iTime);\n    if (oc == 0.5)\n        col = vec3(0.01); // looks black but isn't\n\n    return col;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5 * iResolution.xy)/iResolution.y;\n\n    vec2 p = uv - 0.4 * vec2(cos(time), sin(0.8 * time));\n    // vec2 p2 = uv - 0.4 * vec2(cos(time - 0.01), sin(0.8 * (time - 0.01)));\n    // p.x += .01 * cos(3. * atan(p.y,p.x) + 4. * iTime); \n\n    float scale = 0.05;\n    vec3 col = blob(p, scale);\n    \n    // still looks buggy: (draws circle on end of trail)\n    /*\n    // guessed the value but looks correct\n    float delay = 1.5;\n    vec2 p3 = uv - 0.4 * vec2(cos(time - delay), sin(0.8 * (time - delay)));\n    col += step(length(p3), scale) * getDarkCol(iTime);\n    */\n    \n    // col *= step(length(p), scale) * length(p) / (length(p2));\n    fragColor = vec4(col, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}