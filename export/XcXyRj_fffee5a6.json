{"ver":"0.1","info":{"id":"XcXyRj","date":"1721285013","viewed":16,"name":"7.18 pipi123","username":"1455076726","description":"??","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// scene copied from Nathan https://www.shadertoy.com/view/fdlGWX\n\nconst int MAX_MARCHING_STEPS = 255;\n\nconst float PRECISION = 1e-4;\nconst float MAX_DIST = 100.0;\nvoid rot2d(inout vec2 p, float t)\n{\n\tfloat ct = cos(t), st = sin(t);\n\tvec2 q = p;\n\tp.x = ct *q.x + st *q.y;\n\tp.y = -st *q.x + ct *q.y;\n}\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.6;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\nMaterial sphere1() {\n  vec3 aCol = 0.5 * vec3(1.000,0.584,0.000);\n  vec3 dCol = 0.6 * vec3(0.702,0.408,0.000);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 4.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial sphere2() {\n  vec3 aCol = 0.4 * vec3(1.000,0.000,0.000);\n  vec3 dCol = 0.5 * vec3(1.000,0.098,0.000);\n  vec3 sCol = 0.6 * vec3(1.000,1.000,1.000);\n  float a = 64.;\n\n  return Material(aCol, dCol, sCol, a);\n}\nMaterial sphere3() {\n  vec3 aCol = 0.6 * vec3(1.000,0.867,0.000);\n  vec3 dCol = 0.5 * vec3(0.788,0.557,0.051);\n  vec3 sCol = 0.6 * vec3(1.000,1.000,1.000);\n  float a = 4.;\n\n  return Material(aCol, dCol, sCol, a);\n}\nMaterial sphere4() {\n  vec3 aCol = 0.6 * vec3(0.600,1.000,0.000);\n  vec3 dCol = 0.5 * vec3(0.310,0.788,0.051);\n  vec3 sCol = 0.6 * vec3(1.000,1.000,1.000);\n  float a = 4.;\n\n  return Material(aCol, dCol, sCol, a);\n}\nMaterial sphere5() {\n  vec3 aCol = 0.6 * vec3(0.000,1.000,0.835);\n  vec3 dCol = 0.5 * vec3(0.051,0.788,0.643);\n  vec3 sCol = 0.6 * vec3(1.000,1.000,1.000);\n  float a = 4.;\n\n  return Material(aCol, dCol, sCol, a);\n}\nMaterial sphere6() {\n  vec3 aCol = 0.6 * vec3(0.000,0.333,1.000);\n  vec3 dCol = 0.5 * vec3(0.051,0.604,0.788);\n  vec3 sCol = 0.6 * vec3(1.000,1.000,1.000);\n  float a = 4.;\n\n  return Material(aCol, dCol, sCol, a);\n}\nMaterial sphere7() {\n  vec3 aCol = 0.6 * vec3(0.635,0.024,0.859);\n  vec3 dCol = 0.5 * vec3(0.667,0.051,0.788);\n  vec3 sCol = 0.6 * vec3(1.000,1.000,1.000);\n  float a = 4.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\n\n\n\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = 0.5 + 0.5 * vec3(-1. + mod(floor(p.x) + floor(p.z), 2.0));\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n//  Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n  Surface sSphere1 = Surface(2, sdOctahedron(p - vec3(0, 0, 0), 1.5), sphere2());\n  //Surface sSphere2 = Surface(3, sdPyramid(-p + vec3(0, 0, 0), 0.1), sphere1());\n  vec3 pos1 = p-vec3( 0.0,0.0, 0.0);\n  vec3 pos2 = p-vec3( 0.0,0.0, 0.0);\n     rot2d(pos1.yz,10.0+iTime);\n     rot2d(pos1.xy,10.0+iTime);\n      rot2d(pos2.yz,5.0+iTime*0.25);\n     rot2d(pos2.xz,7.0+iTime*0.35);\n   vec3 pos3 = p-vec3( 0.0,0.0, 0.0);\n  vec3 pos4 = p-vec3( 0.0,0.0, 0.0);\n     rot2d(pos3.yz,8.0+iTime);\n     rot2d(pos3.xy,10.0+iTime*0.2);\n      rot2d(pos4.yz,5.8+iTime*0.3);\n     rot2d(pos4.xz,7.0+iTime*0.4);\n   vec3 pos5 = p-vec3( 0.0,0.0, 0.0);\n  vec3 pos6 = p-vec3( 0.0,0.0, 0.0);\n     rot2d(pos5.xz,3.0+iTime*0.3);\n     rot2d(pos5.xy,7.0+iTime*0.2);\n      rot2d(pos6.yz,7.2+iTime*0.4);\n     rot2d(pos6.xz,10.0+iTime*0.4);\n  \n  \n  \n  \n  \n  Surface sSphere2 = Surface(3, sdBoxFrame( pos1, vec3(1.1,1.1,1.1), 0.06 ), sphere1());\n Surface sSphere3 = Surface(4, sdBoxFrame( pos2, vec3(1.4), 0.06 ), sphere3());\n Surface sSphere4 = Surface(5, sdBoxFrame( pos3, vec3(1.7), 0.06 ), sphere4());\n Surface sSphere5 = Surface(6, sdBoxFrame( pos4, vec3(2.0), 0.06 ), sphere5());\n Surface sSphere6 = Surface(7, sdBoxFrame( pos5, vec3(2.4), 0.06 ), sphere6());\n Surface sSphere7 = Surface(8, sdBoxFrame( pos6, vec3(2.8), 0.06 ), sphere7());\n\n  Surface co = opUnion(sSphere1, sSphere2); // closest object\n  co = opUnion(co, sSphere3);\n  co = opUnion(co, sSphere4);\n  co = opUnion(co, sSphere5);\n  co = opUnion(co, sSphere6);\n  co = opUnion(co, sSphere7);\n  \n  \n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = 0.0;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += abs(co.sd);\n    if (abs(co.sd) < PRECISION || depth > MAX_DIST) break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 normal, vec3 rd, Surface co) {\n  if (co.sd > MAX_DIST) return texture(iChannel0, rd).rgb;\n  \n  // ambient\n  vec3 ambient = co.mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(-lightDir, normal), 0., 1.);\n  vec3 diffuse = co.mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = co.mat.specularColor * pow(dotRV, co.mat.alpha);\n\n  vec3 col = lightIntensity * (ambient + diffuse + specular);\n  \n  // fog\n  //col = mix(col, bgColor, 1.0 - exp(-0.0002 * co.sd * co.sd * co.sd));\n  return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0);\n   float time = iTime *0.5;\n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(5. * cos(-time), 0., 5. * sin(-time));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n  \n  vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n  vec3 normal = calcNormal(p); // surface normal\n\n  // light\n  vec3 lightPosition = 4. * vec3(cos(iTime), 1., sin(iTime));\n  vec3 lightDirection = normalize(p - lightPosition);\n  float lightIntensity = 0.9;\n      \n  // phone light model\n  col = phong(lightDirection, lightIntensity, normal, rd, co); \n      \n/*  // soft shaddow from iq\n  if (co.id == 1 && co.sd < .2 * MAX_DIST) {\n    float softShadow = clamp(softShadow(p, -lightDirection, 100.*PRECISION, length(p-lightPosition)), 0.2, 1.0);\n    col *= softShadow;\n  }\n//*/\n\n//*  // reflection;\n  if (co.id == 2 && scene(p).sd < 10. * PRECISION) {\n    vec3 reflRD = reflect(rd, normal);\n    vec3 reflRO = p + 1.1 * PRECISION * normal; // move origin a little bit away\n    Surface reflCO = rayMarch(reflRO, reflRD);\n    vec3 reflP = reflRO + reflRD * reflCO.sd;\n    vec3 reflNormal = calcNormal(reflP);\n    vec3 reflCol = phong(lightDirection, lightIntensity, reflNormal, reflRD, reflCO);\n    col = mix(col, reflCol, 0.5);\n  }\n//*/\n\n//*  // refraction\n  if (co.id >= 3 && scene(p).sd < 10. * PRECISION) {\n    const float ETA = 1.69; // glass 1.69, water 1.33ï¼Œ1.0 air\n    vec3 refrRD1 = refract(rd, normal, 1./ETA);\n    vec3 refrRO1 = p - 2.1 * PRECISION * normal; // move origin into the sphere\n    Surface refrCO1 = rayMarch(refrRO1, refrRD1);\n    vec3 refrP1 = refrRO1 + refrRD1 * refrCO1.sd;\n    vec3 refrN1 = calcNormal(refrP1);\n    \n    vec3 refrRD2 = refract(refrRD1, -refrN1, ETA);\n    vec3 refrRO2 = refrP1 + 2.1 * PRECISION * refrN1; // move origin outside the sphere\n    Surface refrCO2 = rayMarch(refrRO2, refrRD2);\n    vec3 refrP2 = refrRO2 + refrRD2 * refrCO2.sd;\n    vec3 refrN2 = calcNormal(refrP2);\n    vec3 refrCol = phong(lightDirection, lightIntensity, refrN2, refrRD2, refrCO2);\n    col = mix(col, refrCol, 0.5);\n  }\n//*/\n  col = pow(col, vec3(1.0/2.2)); // Gamma correction\n  fragColor = vec4(col, 1.0); // Output to screen\n}","name":"Image","description":"","type":"image"}]}