{"ver":"0.1","info":{"id":"3lGGz3","date":"1579433699","viewed":143,"name":"Trig-free  gradient noise","username":"mdv","description":"Gradient noise,  without trig functions.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// MDV -  \n//\n//    Noise function (2D to a 1D value) for a single frequency gradient noise.\n//\n//    - NOT using any trig. \n//      Math was based on BhaskariI's sine approximation and code optimized.\n//\n//    ToDo:\n//       Further optimization,  get rid of the division operation in Xnoise\n\n\n// NOISE_FREQUENCY =  some frequency to test,  change as required\n\nconst float NOISE_FREQUENCY =  60.0;\n\n//  'BigFloat' is a value large enough so that  we can replace tests like  (a > 0)  \n//   with:    clamp( a * BigFloat, 0,1 ) ... ;  \n//   which enables further optimisations with surrounding code.\n \n\nconst float BigFloat = 99999.0;  \nconst float PI = 3.14159265359;\nconst float TWOPI = 2.0  * PI;\nconst float rTWOPI = 1.0 / TWOPI;\nconst float M = PI * 4.0 * 45671.23; \nconst float RecipPIM = 1.0 / ( PI * M); \nconst float PIsqrDivM = PI * PI / M;\nconst float PIb = -PI * BigFloat; \n\t\n\n\t// IMPORTANT:   Use constants that are precisely representable in 32-bit fpt format!,  \n\t//              otherwise small errors can occur periodically (at integral boundaries) - shows up on things like noise texturing as thin flickering boundary lines.\n\t//              - This seems to be caused by the function either side of the boundary producing non-convergent results due to fpt inaccuracy.  So we eliminate that inaccuracy\n\t//              by ensuring that fpt uses values that are precisely represented, ie. have fractions that are precisely represented by a sum of negative powers of 2  (0.5, 0.25, 0.125, ..... )\n\n\nconst float K0 = (1271.0 / 4096.0)  ;  \nconst float K1 = (3117.0 / 4096.0)  ;  \nconst float K2 = (2695.0 / 4096.0)  ;  \nconst float K3 = (1833.0 / 4096.0)  ;   \n\nvec2 Xnoise(vec2 angle, vec4 p)\n{ \n\tvec4 rangedAngle = vec4(angle, angle + vec2(K0, K2));\n\t \n\trangedAngle = fract(rangedAngle) * TWOPI;       // fmod(rangedAngle, TWOPI) = frac(rangedAngle * (1/TWOPI)) * TWOPI   and the 1/TWOPI is optimized out \n\tvec4 rb = rangedAngle * BigFloat;\n\tvec4 m = clamp( rb + PIb, 0.0, 1.0);\n\tvec4 r = rangedAngle + PI * (2.0 - clamp(rb, 0.0, 1.0) - m);\n\tr =  r * (PI - r);\n\tvec4 d = (PIsqrDivM - r * RecipPIM );\n\tvec2 divisor = 1.0 / vec2(d.x*d.y, d.z*d.w);    // would be nice to get rid of this division..\n\tvec4 q = -1.0 + 2.0 * fract(((1.0 - m * 2.0) * r) *  d.yxwz * divisor.xxyy);   // [-1, 1) \n\treturn vec2(q.x*p.x + q.y*p.y, q.z*p.z + q.w*p.w);\n}\n\nfloat noise2(vec2 st)\n{  \n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\t \n\tvec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);     // blend as per smoothernoise \n\t \n\tfloat d0 = i.x * K0 + i.y * K1;\n\tfloat d1 = i.x * K2 + i.y * K3; \n\n\tvec2 g = f - 1.0;  \n\n\tvec4 d = vec4(   Xnoise(vec2(d0,      d1 ),  vec4(f.xy, g.x, f.y)),\n\t                 Xnoise(vec2(d0 + K1, d1 + K3 ), vec4(f.x, g.yx, g.y)) );  \n    \n\tvec2 dx = mix(d.xz, d.yw, u.x);\n\treturn mix(dx.x, dx.y, u.y);\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord/iResolution.y;\n  \n    float intensity  = (1.0+ noise2(uv*NOISE_FREQUENCY)) * 0.5 ; \n     \n    fragColor = vec4(intensity,intensity,intensity,1.0);\n}","name":"Image","description":"","type":"image"}]}