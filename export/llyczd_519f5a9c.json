{"ver":"0.1","info":{"id":"llyczd","date":"1537779622","viewed":499,"name":"Gerstner experiments","username":"Draedrus","description":"Gerstner experiments and a bit of lighting stuff :)","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["waves","water","ocean","scattering","mie","gerstner","reyleigh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sum(a) (a.r+a.g+a.b)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float e = 0.5/iResolution.x;\n    fragColor.rgba += texture(iChannel0, uv+vec2(-e, -e)).rgba;\n    fragColor.rgba += texture(iChannel0, uv+vec2(e, -e)).rgba;\n    fragColor.rgba += texture(iChannel0, uv+vec2(-e, e)).rgba;\n    fragColor.rgba += texture(iChannel0, uv+vec2(e, e)).rgba;\n    fragColor.rgba *= 0.25;\n    #ifdef BLOOM\n        float dobloom = texture(iChannel0, uv).a;\n        vec3 blurr = texture(iChannel1, uv).rgb;\n        fragColor.rgb += dobloom*blurr;\n    #endif\n    fragColor = vec4(tonemapping(fragColor.rgb), fragColor.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415\n#define PI2 6.2830\n\n#define BLOOM\n\n#define FAR 1000.0\n#define NEAR 0.01\n\n#define BLOOM_I_MIN -4\n#define BLOOM_I_MAX 8\n#define BLOOM_DIV 1.0/(float(BLOOM_I_MAX)-float(BLOOM_I_MIN))\n\n#define BLOOM_RAMP(col) 0.2*smoothstep(vec3(0.0), col, normalize(col))\n//#define BLOOM_RAMP(col) col\n\n#define DAYTIME(t) 2.0*PI*fract(0.02*(t+5.0))\n\n// will use a procedural cubemap instead of computing it directly in Buffer A\n// build the cubemap is slower, we could back it but I need a dynamic cube map :)\n// but nice experiment\n//#define USE_CUBEMAP\n//#define USE_CUBEMAP_DEBUG\n\n//#define USE_CLOUDS_EXP\n//#define USE_CLOUDS2D_EXP\n\n// Hash + fbm\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\n// Hash3D\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n    x = vec3(hash(x.xy), hash(x.yz), hash(x.xz));\n\treturn fract(dot(x, vec3(12.4955, 49.4294, 42.40594))*13.4959451);    \n}\n\nfloat gaussianNoise3D(vec3 uv)\n{\n\tvec3 p = floor(uv);\n    vec3 f = fract(uv);\n    \n    f = f*f*(3.0-2.0*f);\n    /*float c = cos(uv.x);\n    float s = sin(uv.y);\n    mat2 R = mat2(c, s, -s, c);*/\n    \n    return\n        mix(\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, 0.0)), hash3D(p+vec3(1.0, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, 1.0, 0.0)), hash3D(p+vec3(1.0, 1.0, 0.0)), f.x),\n            f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, 1.0)), hash3D(p+vec3(1.0, 0.0, 1.0)), f.x),\n                mix(hash3D(p+vec3(0.0, 1.0, 1.0)), hash3D(p+vec3(1.0, 1.0, 1.0)), f.x),\n            f.y),\n        f.z);\n}\n\nfloat fbm3Dsimple(vec3 p) {\n    float total = 0.0;\n    total  = 0.5000* gaussianNoise3D(p); p = p*2.0;\n    total += 0.2500* gaussianNoise3D(p); p = p*2.0;\n    total += 0.1250* gaussianNoise3D(p); p = p*2.0;\n    total += 0.0625* gaussianNoise3D(p); p = p*2.0;\n    return total;\n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n\n// Gertsner\n\nstruct sGerstnerParams\n{\n    float nWaves;\n    float steepness;\n    float speed;\n    float waveDiv;\n    float amp;\n    vec2 wind;\n};\n\nsGerstnerParams BlendGParams(sGerstnerParams p1, sGerstnerParams p2, float a)\n{\n    p1.nWaves = mix(p1.nWaves, p2.nWaves, a);\n    p1.steepness = mix(p1.steepness, p2.steepness, a);\n    p1.speed = mix(p1.speed, p2.speed, a);\n    p1.waveDiv = mix(p1.waveDiv, p2.waveDiv, a);\n    p1.amp = mix(p1.amp, p2.amp, a);\n    p1.wind = mix(p1.wind, p2.wind, a);\n    return p1;\n}\n\n//  inspired from https://80.lv/articles/tutorial-ocean-shader-with-gerstner-waves/\nfloat gerstner(\n    vec3 p,\n    vec2 WindDir,\n    float wD,\n    float a,\n    float waveFreq,\n    float steepness,\n\tfloat speedfactor,\n\tfloat t)\n{\n    float depthz = 0.0, depthx = 0.0, depthy = 0.0;\n    //for(int i = 0; i < 4; ++i)\n    {\n        float WaveLength = PI2 / wD;\n        \n        float speed = WaveLength * speedfactor;\n        \n        float nWaves = waveFreq * PI2;\n        float Amplitude = a;\n        \n        float Time = t * speed;\n        \n        float Wave = dot(normalize(WindDir), (p.xz)) * WaveLength + Time;\n\n        float Qi = steepness/(nWaves * Amplitude * WaveLength);\n        float QiA = Qi*Amplitude;\n        \n        depthz = QiA*WindDir.y*cos(Wave);\n        depthx = QiA*WindDir.x*cos(Wave);\n        depthy = Amplitude*sin(Wave);\n    }\n    return length(vec3(depthx, depthy, depthz));//min( depthy, min(depthz, depthx));\n}\n\n// BRDF Disney\n// Copyright Disney Enterprises, Inc.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License\n// and the following modification to it: Section 6 Trademarks.\n// deleted and replaced with:\n//\n// 6. Trademarks. This License does not grant permission to use the\n// trade names, trademarks, service marks, or product names of the\n// Licensor and its affiliates, except as required for reproducing\n// the content of the NOTICE file.\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n\n\nstruct BRDFParams\n{\n\tvec3 baseColor;\n    float metallic;\n    float subsurface;\n    float specular;\n    float roughness;\n    float specularTint;\n    float anisotropic;\n    float sheen;\n    float sheenTint;\n    float clearcoat;\n    float clearcoatGloss;\n};\n    \n//const float PI = 3.14159265358979323846;\n\nfloat sqr(float x) { return x*x; }\n\nfloat SchlickFresnel(float u)\n{\n    float m = clamp(1.0-u, 0.0, 1.0);\n    float m2 = m*m;\n    return m2*m2*m; // pow(m,5)\n}\n\nfloat GTR1(float NdotH, float a)\n{\n    if (a >= 1.0) return 1.0/PI;\n    float a2 = a*a;\n    float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n    return (a2-1.0) / (PI*log(a2)*t);\n}\n\nfloat GTR2(float NdotH, float a)\n{\n    float a2 = a*a;\n    float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n    return a2 / (PI * t*t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay)\n{\n    return 1.0 / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));\n}\n\nfloat smithG_GGX(float NdotV, float alphaG)\n{\n    float a = alphaG*alphaG;\n    float b = NdotV*NdotV;\n    return 1.0 / (NdotV + sqrt(a + b - a*b));\n}\n\nfloat smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay)\n{\n    return 1.0 / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));\n}\n\nvec3 mon2lin(vec3 x)\n{\n    return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\n\nvec3 BRDF(BRDFParams P, vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y )\n{\n    float NdotL = dot(N,L);\n    float NdotV = dot(N,V);\n    if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.0);\n\n    vec3 H = normalize(L+V);\n    float NdotH = dot(N,H);\n    float LdotH = dot(L,H);\n\n    vec3 Cdlin = mon2lin(P.baseColor);\n    float Cdlum = .3*Cdlin[0] + .6*Cdlin[1]  + .1*Cdlin[2]; // luminance approx.\n\n    vec3 Ctint = Cdlum > 0.0 ? Cdlin/Cdlum : vec3(1.0); // normalize lum. to isolate hue+sat\n    vec3 Cspec0 = mix(P.specular*.08*mix(vec3(1.0), Ctint, P.specularTint), Cdlin, P.metallic);\n    vec3 Csheen = mix(vec3(1), Ctint, P.sheenTint);\n\n    // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n    // and mix in diffuse retro-reflection based on roughness\n    float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n    float Fd90 = 0.5 + 2.0 * LdotH*LdotH * P.roughness;\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n    // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n    // 1.25 scale is used to (roughly) preserve albedo\n    // Fss90 used to \"flatten\" retroreflection based on roughness\n    float Fss90 = LdotH*LdotH*P.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - .5) + .5);\n\n    // specular\n    float aspect = sqrt(1.0-P.anisotropic*.9);\n    float ax = max(.001, sqr(P.roughness)/aspect);\n    float ay = max(.001, sqr(P.roughness)*aspect);\n    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);\n    float FH = SchlickFresnel(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs;\n    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);\n    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);\n\n    // sheen\n    vec3 Fsheen = FH * P.sheen * Csheen;\n\n    // clearcoat (ior = 1.5 -> F0 = 0.04)\n    float Dr = GTR1(NdotH, mix(.1,.001,P.clearcoatGloss));\n    float Fr = mix(.04, 1.0, FH);\n    float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);\n\n    return ((1.0/PI) * mix(Fd, ss, P.subsurface)*Cdlin + Fsheen)\n        * (1.0-P.metallic)\n        + Gs*Fs*Ds + .25*P.clearcoat*Gr*Fr*Dr;\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    float f = 1.5;\n    //Tonemapping and color grading\n    color = pow(color, vec3(f));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / f));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    //color = pow(color, vec3(2.0, 1.70, 1.5));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(1.0 / 2.2)); // 0.7/2.2\n    return color;\n}\n\n// Gaussian blurr\n\n// Adapted: http://callumhay.blogspot.com/2010/09/gaussian-blur-shader-glsl.html\nvec4 GaussianBlur(int blurKernelSize, vec2 blurDir, vec2 blurRadius, float sigma, sampler2D tex, vec2 texCoord)\n{\n    int blurKernelHalfSize = blurKernelSize / 2;\n\n    // Incremental Gaussian Coefficent Calculation (See GPU Gems 3 pp. 877 - 889)\n    vec3 gaussCoeff;\n    gaussCoeff.x = 1.0 / (sqrt(2.0 * PI) * sigma);\n    gaussCoeff.y = exp(-0.5 / (sigma * sigma));\n    gaussCoeff.z = gaussCoeff.y * gaussCoeff.y;\n\n    vec2 blurVec = blurRadius * blurDir;\n    vec4 avgValue = vec4(0.0, 0.0, 0.0, 0.0);\n    float gaussCoeffSum = 0.0;\n\n    avgValue += texture(tex, texCoord) * gaussCoeff.x;\n\n    gaussCoeffSum += gaussCoeff.x;\n    gaussCoeff.xy *= gaussCoeff.yz;\n\n    for (int i = 1; i <= blurKernelHalfSize; i++)\n    {\n        avgValue += texture(tex, texCoord - float(i) * blurVec) * gaussCoeff.x;\n        avgValue += texture(tex, texCoord + float(i) * blurVec) * gaussCoeff.x;\n\n        gaussCoeffSum += 2.0 * gaussCoeff.x;\n        gaussCoeff.xy *= gaussCoeff.yz;\n    }\n\n    return avgValue / gaussCoeffSum;\n}\n\n// HDR sky parameters\n#define SCALE_HEIGHT\t\t 8000.0\n#define SUNDIST \t149597870700.0\n#define EARTHRADIUS\t\t\t 6360e3\n#define ATMOSPHERERADIUS \t6420e3\n#define SUNINTENSITY\t\t 20.0\n#define SUNRADIUS \t  695700000.0\n#define MOONRADIUS \t\t1737400.0\n#define EARTHPOS vec3(0.0, 0.0, 0.0)\n\n#define SUNPOS normalize(vec3(0.0, 1.0, 0.0))*149597870700.0\n#define MOONPOS normalize(vec3(1.0, 0.5, 0.7))*384467700.0\n\n#define TIME iTime*0.03\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = -B/2.0;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\nvec3 getSkyCoord(vec3 ro, vec3 rd)\n{\n    float tmin = -1.0, tmax = -1.0;\n    float d = IntersectSphere(\n        ro+vec3(0.0, EARTHRADIUS, 0.0), rd, vec3(0.0, 0.0, 0.0),\n        ATMOSPHERERADIUS,\n        tmin, tmax);\n    return ro+rd*tmax;\n}\n\n// From http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 getSkyLight(vec3 ro, vec3 rd, vec3 L, vec3 betaR, vec3 betaM, out vec3 miecolor, float _hm)\n{\n    vec3 light = vec3(0.0);\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n    vec3 Pa = ro+rd*tmax;\n    /*if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);*/\n    float RdotL = dot(rd, L);\n    float tCurrent = 0.0;\n    float segL = tmax/16.0;\n    /*if(d>0.0)\n        segL = (tmax-tmin)/16.0;*/\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 7994.0; // 7994\n    float hm = _hm;//800.0; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation has an error with the first terms in the equation\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    //vec3 betaM = vec3(21e-6);\n    float opticalDepthM = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTHRADIUS;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = L;//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);\n        float segLLight = tlmax/8.0;\n        float tCurrentLight = 0.0;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < 8; ++j)\n        {\n            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n            float hLight = length(samplePositionLight) - EARTHRADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(-hLight / hr) * segLLight;\n            opticalDepthLightM += exp(-hLight / hm) * segLLight;\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    miecolor = SUNINTENSITY * sumM * phaseM;\n    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\nfloat noise(vec3 x, sampler2D stex) // iq's 3D noise\n{\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(stex, (uv + 0.5)/256.0, -100.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\n\nvec3 getSkyColorForPhase(vec3 ro, vec3 rd, float solarPhase, vec3 sunDir, vec3 moonDir, float t)\n{\n    float daynight = solarPhase;//sin(TIME)>=0.0?1.0:0.0;//max(0.0, dot(vec3(0.0, 1.0, 0.0), -_light.d));\n    vec3 betaR = mix(\n        \t\t\tvec3(0.1e-8, 0.2e-8, 0.5e-8),\n        \t\t\tvec3(5.5e-6, 13.0e-6, 22.4e-6),// DAY\n        \t\t\tdaynight);\n    vec3 betaM = mix(\n        \t\t\tvec3(2e-12),\n        \t\t\tvec3(21e-7),\n        daynight);\n    vec3 color = vec3(0.0);\n    vec3 miecolor = vec3(0.0);\n    \n    vec3 L = mix(moonDir, sunDir, daynight);\n    \n    color = getSkyLight(ro, rd, L, betaR, betaM, miecolor, mix(400.0, 800.0, daynight));//mix(COLORSKYB, COLORSKYT, clamp(rd.y+0.5, 0.0, 1.0));\n    \n    // stars\n    float sN = gaussianNoise3D(rd*120.0);\n    color += (1.0-daynight)*vec3(max(0.0, min(1.0,sN-0.95))*10.0);\n  \n    \n    // solar disc\n    float tmin, tmax;\n    //IntersectSphere(ro, rd, ro+L*100.0, 10.0, tmin, tmax);\n    float moonMask = 1.0;//gaussianNoise3D(1000.0*(ro+L*10000.0));\n    color += 0.001\n        *moonMask\n        *miecolor\n        *clamp(\n            -0.000\n            +pow(\n                0.000\n                +max(0.0, dot(rd, L)),\n                mix(8128.0, 4096.0, daynight)\n            )\n            , 0.0, 1.0);\n    \n    #ifdef USE_CLOUDS_EXP\n    float d = 0.01, den = 0.0;\n    for(int i = 0; i < 4;++i)\n    {\n        vec3 Psky = rd*d;\n        Psky.y = 10.0;\n        //float v = max(0.0, 1.0-voronoi3D(Psky*0.5));\n        //float f = clamp(fbm3Dsimple(Psky*1.0), 0.0, 1.0);\n        float fmask = fbm3Dsimple(Psky*5.51+t)-0.25;\n        float dt = clamp(fmask, 0.0, 1.0);//fmask*(v+f);\n        if(dt<0.01 || den>1.0) break;\n        d += dt;\n        float v = mix(0.8, 1.0, min(1.0, 1.0-(voronoi2D(Psky.xz*50.0)-0.8)*5.0));\n        den += dt*v;\n    }\n    color += den*den;\n    #endif\n    \n    #ifdef USE_CLOUDS2D_EXP\n    float d = 0.01, den = 0.0;\n    for(int i = 0; i < 16;++i)\n    {\n        vec3 Psky = rd*d;\n        //float v = max(0.0, 1.0-voronoi3D(Psky*0.5));\n        //float f = clamp(fbm3Dsimple(Psky*1.0), 0.0, 1.0);\n        float fmask = clamp(fbm_hash(Psky.xz*5.51+t), 0.0, 1.0);\n        float dt = Psky.y+fmask;\n        if(dt<0.01 || d>=1.0) break;\n        d += 0.5*dt;\n    }\n    d = d;\n    color += d*d;\n    #endif\n    \n    //color = vec3(noise(Psky*1000.0));\n    //color = vec3(length(Psky));\n    /*color += (1.0-daynight)*vec3(max(0.0, min(1.0,sN-0.95))*10.0);\n  \n    float sunGrad = 0.0;\n    float RdotL = dot(rd, -L);\n    if(rd.y>(0.033) && RdotL>0.0/* && tmin>0.0*//*)\n    {\n        sunGrad = daynight*pow(max(0.0, pow(RdotL, 2.0)-0.35), mix(1.0, 1.0, daynight));\n        sunGrad += pow((pow(RdotL, mix(2056.0, 256.0, daynight))), mix(1.0, 1.0, daynight));\n    }\n    \n    float mT = mix(0.001, 1.0, daynight);\n    color += miecolor*sunGrad*mT;*/\n    \n    return color;\n}\n\nvec3 getSkyColor(vec3 ro, vec3 rd, float solarPhase, vec3 sunDir, vec3 moonDir, float t)\n{\n    t = DAYTIME(t);\n    return mix(getSkyColorForPhase(ro, rd, 0.0, sunDir, moonDir, t),\n               getSkyColorForPhase(ro, rd, 1.0, sunDir, moonDir, t),\n               solarPhase);\n}\n\nvoid computeCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    #ifdef USE_CUBEMAP\n    const float tmin = NEAR, tmax = FAR;\n    // Time varying pixel color\n    vec2 dayYZ = vec2(sin(DAYTIME(-iTime)), cos(DAYTIME(-iTime)+PI));\n    \n    vec3 sunDir = normalize(vec3(0.0, dayYZ.x, dayYZ.y));\n    vec3 moonDir = -sunDir;\n    // Ray direction as color\n    vec3 earthoffset = vec3(0.0, EARTHRADIUS+0.0, 0.0);\n    float daynight = 0.5*(1.0+sin(DAYTIME(-iTime)));\n    vec3 col = getSkyColor(rayOri+earthoffset, rayDir,daynight, sunDir, moonDir, iTime);\n    #ifdef USE_CUBEMAP_DEBUG\n\tcol = vec3(1.0);\n    #endif\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n    #else\n    fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    #endif\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define VERTICAL_OFFSET 10.0\n// apply rotations to the wind based on time\n#define WINDROLL\n#define WINDROLL_PER_WAVE\n#define NWAVES 4\n#define AMP_EXTINCTION_P 80.1\n#define NORMAL_EXTINCTION_P 80.1\n#define MIN_NORMAL_EXTINCTION 0.05\n/*#define EXTINCTION_I(E, d, mini) \\\nclamp(\\\n    mini+max(0.0, E-d-mini)*max(0.0, E-d-mini) \\\n      /(E*E) \\\n      , 0.0, 1.0)\n#define EXTINCTION(E, d, mini) \\\n    EXTINCTION_I(E, d, mini)*EXTINCTION_I(E, d, mini)*/\n#define EXTINCTION(E, d, mini) mini+(smoothstep(1.0, 0.0, min(1.0, d/E)))\n    \n#define DETAILS_SEED_SCALE 2.0\n\n#define WATER_KS 1.0\n#define WATER_KD 0.1\n#define WATER_ROUGHNESS 0.8\n\n#define AMP_ATT 0.2\n#define CHOPINESS_ATT 0.8\n#define SPEED_ATT 0.8\n\n// 22\n\n#define DISTATTENUATE(x, E) (1.0-x/E)\n\nvec3 sunDir;\nvec3 moonDir = normalize(vec3(0.0, 1.0, 0.0));\n\nvec2 MainWindDir = vec2(0.5, 0.5);\nfloat MainAmp = 0.1;\n\nfloat dfuncdetails(vec3 p, float t)\n{\n    float depth = 0.0;\n    //vec2 seed = rot(4.6*p.xz-vec2(50.0, 50.0), iTime*0.01)*vec2(0.3, 1.0)+MainWindDir*iTime;\n    vec2 seed = DETAILS_SEED_SCALE*p.xz*vec2(0.5, 0.6)+MainWindDir*(2.0*t);\n    depth = clamp(fbm_hash(seed), 0.0, 1.0);\n    //depth = abs(sin(20.0*p.x))+abs(cos(20.0*p.z))+abs(sin(20.0*p.y));\n    //return dfunc(0.6*p+iTime*0.1);\n    return 0.05*depth;\n}\n\nfloat mapdetails(vec3 p)\n{\n    return dfuncdetails(p, iTime)+dfuncdetails(p, -iTime);\n}\n\nfloat dfunc(vec3 p, sGerstnerParams params, float t)\n{\n    float nWaves = params.nWaves;\n    float steepness = params.steepness;\n    float speed = params.speed;\n    float waveDiv = params.waveDiv;\n    float depth = p.y;\n    vec2 wind = params.wind;\n    float amp = params.amp;\n    float s = -1.0;\n    for(int i = 0; i < NWAVES; ++i)\n    {\n        depth +=\n        gerstner(p, wind, waveDiv, amp, nWaves, steepness, speed, t);\n        speed *= SPEED_ATT;\n        steepness *= CHOPINESS_ATT;\n        amp *= AMP_ATT;\n        #ifdef WINDROLL_PER_WAVE\n        wind = mat2(0.4, 0.8, -0.7, 0.2)*wind;\n        #endif\n        //nWaves *= 2.0;\n    }\n    return depth;\n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat map(vec3 p)\n{\n    float ext = EXTINCTION(AMP_EXTINCTION_P, length(p), 0.01);\n    sGerstnerParams paramsAgitated1;\n    paramsAgitated1.nWaves = 8.0;\n    paramsAgitated1.steepness = 20.0;//60.0;\n    paramsAgitated1.speed = 1.4;\n    paramsAgitated1.waveDiv = 25.0;\n    #ifdef WINDROLL\n    paramsAgitated1.wind = rot(MainWindDir, fbm_hash(MainWindDir*0.16*p.xz));\n    #else\n    paramsAgitated1.wind = MainWindDir;//+fbm_hash(MainWindDir*0.16*p.xz);\n    #endif\n    paramsAgitated1.amp = MainAmp * ext;\n    \n    sGerstnerParams paramsAgitated2;\n    paramsAgitated2.nWaves = 20.0;\n    paramsAgitated2.steepness = 20.0;//25.0;\n    paramsAgitated2.speed = 1.0;\n    paramsAgitated2.waveDiv = 40.0;\n    #ifdef WINDROLL\n    paramsAgitated2.wind = rot(MainWindDir, 1.5*PI+fbm_hash(MainWindDir*0.16*p.xz));\n    #else\n    paramsAgitated2.wind = -MainWindDir*0.3;//+fbm_hash(MainWindDir*0.16*p.xz);\n    #endif\n    paramsAgitated2.amp = MainAmp * ext;\n    \n    \n    sGerstnerParams params;\n    params.nWaves = 4.0;\n    params.steepness = 10.0;\n    params.speed = 1.8;\n    params.waveDiv = 20.0;\n    #ifdef WINDROLL\n    params.wind = rot(MainWindDir, fbm_hash(MainWindDir*0.16*p.xz));\n    #else\n    params.wind = MainWindDir;//+fbm_hash(MainWindDir*0.16*p.xz);\n    #endif\n    params.amp = MainAmp * ext;\n    \n    sGerstnerParams params2;\n    params2.nWaves = 20.0;\n    params2.steepness = 60.0;\n    params2.speed = 1.0;\n    params2.waveDiv = 33.0;\n    #ifdef WINDROLL\n    params2.wind = rot(MainWindDir, 1.5*PI+fbm_hash(MainWindDir*0.16*p.xz));\n    #else\n    params2.wind = -MainWindDir*0.4;//+fbm_hash(MainWindDir*0.16*p.xz);\n    #endif\n    params2.amp = MainAmp * ext;\n    \n    \n    params = BlendGParams(paramsAgitated1, params, 0.5);\n    params2 = BlendGParams(paramsAgitated2, params2, 0.5);\n        \n    return smin(\n        dfunc(p, params, iTime),\n        dfunc(p, params2, iTime),\n    0.5)+mapdetails(p);\n}\n\nvec3 normal(vec3 p, float e)\n{\n    vec3 N;\n    N.y = map(p);\n    N.x = map(p+vec3(e, 0.0, 0.0))-N.y;\n    N.z = map(p+vec3(0.0, 0.0, e))-N.y;\n    N.y = e;\n    return normalize(N);\n}\n\nvec3 normaldetails(vec3 p, float e)\n{\n    vec3 N;\n    N.y = mapdetails(p);\n    N.x = mapdetails(p+vec3(e, 0.0, 0.0))-N.y;\n    N.z = mapdetails(p+vec3(0.0, 0.0, e))-N.y;\n    N.y = e;\n    return normalize(N);\n}\n\nfloat rm(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float ret = 0.0;\n    \n    for(int i = 0;i<400;++i)\n    {\n        vec3 p = ro+rd*ret;\n        float d = map(p-vec3(0.0, VERTICAL_OFFSET, 0.0));\n        if(d<tmin || ret>tmax) break;\n        ret += 0.5*d;\n    }\n    \n    return ret;\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / max(0.0001, 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\nfloat GGX(float a, float NoV, float NoL)\n{\n    float a2 = a*a;\n    float G_V = NoV + sqrt( (NoV - NoV * a2) * NoV + a2 );\n    float G_L = NoL + sqrt( (NoL - NoL * a2) * NoL + a2 );\n\treturn 1.0/( G_V * G_L );\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.01);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.01);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.01);\n  float VdotH = max(dot(viewDirection, H), 0.0001);\n  float LdotH = max(dot(lightDirection, H), 0.0001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = max(0.00001, min(1.0, min(G1, G2)));\n  \n  //Distribution term\n  float D = GGX(roughness, VdotN, LdotN);\n  //float D = beckmannDistribution(roughness, NdotH);\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\t//return D;\n  //Multiply terms and done\n  return  G *F * D;\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    float depth,\n    vec3 specularColor,\n    vec3 refractiveColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L)\n{\n    vec3 Vn = -I;\n    float NdotV = max(0.0, dot(Vn, N));\n    float NdotL = max(0.0, dot(N, L));\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    \n    float F = Fresnel_Schlick(1.0, 1.3, NdotV);\n    spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    //return vec3(F);\n    //return vec3(spec);\n    return (refractiveColor*F+Kd*diffuseColor\n            +Ks*specularColor*spec\n    ) * Oi;\n}\n\nmat3 cam(vec3 ro, vec3 target, vec3 up)\n{\n    vec3 z = normalize(target-ro);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 pixel = -1.0+2.0*uv;\n    vec2 mv = -1.0+2.0*(iMouse.xy/iResolution.xy);\n\n    const float tmin = NEAR, tmax = FAR;\n    vec3 ro = vec3(0.0, 5.0+VERTICAL_OFFSET, 0.0);\n    vec3 target = vec3(3.0, 0.0, -1000.0);\n    target.y = rot(target.zy, mv.y*PI).y;\n    target.xz = rot(target.xz, -mv.x*PI);//-PI*mv.x+PI*1.07);\n    \n    vec3 rd = normalize(cam(ro, target, vec3(0.0, 1.0, 0.0))*normalize(vec3(pixel, 4.0)));\n    \n    float depth = rm(ro, rd, tmin, tmax);\n    \n    // Time varying pixel color\n    vec2 dayYZ = vec2(sin(DAYTIME(-iTime)), cos(DAYTIME(-iTime)+PI));\n    float ND = (tmax-depth)/(tmax-tmin);\n    sunDir = normalize(vec3(0.0, dayYZ.x, dayYZ.y));\n    moonDir = -sunDir;\n    //sunDir = normalize(vec3(0.0, 1.0, 0.0));\n    float daynight = 0.5*(1.0+sin(DAYTIME(-iTime)));\n    vec3 L = mix(moonDir, sunDir, pow(daynight, 0.2));\n    //L = moonDir;\n    //daynight = 0.0;\n    \n    vec3 col = vec3(ND);\n    // sky\n    vec3 earthoffset = vec3(0.0, EARTHRADIUS+0.0, 0.0);\n    #ifdef USE_CUBEMAP\n    vec3 skycol = texture(iChannel2, rd).rgb;\n    #else\n    vec3 skycol = getSkyColor(ro+earthoffset, rd,daynight, sunDir, moonDir, iTime);\n    #endif\n\n    // stars\n    #if defined FALLING_STARS\n    float oldFS = texture(iChannel0, uv).a;\n    vec3 ssP = rd;//getSkyCoord(ro, rd);\n    //float sFSN = gaussianNoise3D(vec3(ssP.x, rot(ssP.yz,iTime))*120.0);\n    float sFSN = fbm_hash(vec2(ssP.xy*120.0+iTime*10.0)*1.0);\n    float fallinStars =(1.0-daynight)*max(0.0, min(1.0,sFSN-0.86))*20.0+oldFS*0.99;\n    skycol += vec3(fallinStars);\n    #endif\n    \n    col = skycol;\n    \n    if(depth>tmin && depth<tmax)\n    {\n        vec3 p = ro+rd*depth;\n        vec3 deepdiffuse = vec3(0.019, 0.022, 0.022);\n        vec3 surfacediffuse = vec3(0.059, 0.064, 0.07);//vec3(0.08, 0.085, 0.1);\n        \n        vec3 N = normalize(\n            2.5*normal(p, 0.01)\n            +normaldetails(p, 0.01)\n            );\n        \n        N.xz *= EXTINCTION(NORMAL_EXTINCTION_P, depth, MIN_NORMAL_EXTINCTION);//clamp(AMP_EXTINCTION/depth, 0.1, 1.0);\n        //N.xz *= EXTINCTION(800.0, depth, 0.001);\n        N = normalize(N);\n        \n        vec3 RRD = reflect(rd, N);// RRD.y = abs(RRD.y); // ugly but ok\n        vec3 skyRefl=surfacediffuse;\n        //if(RRD.y>0.0)\n        #ifdef USE_CUBEMAP\n        skyRefl = texture(iChannel2, RRD).rgb;\n        #else\n       \tskyRefl= getSkyColor(p+earthoffset, RRD,daynight, sunDir, moonDir, iTime);\n        #endif\n        //skyRefl = mix(surfacediffuse, skyRefl, min(1.0, length(skyRefl)));\n\n        float fresnel = Fresnel_Schlick(1.0, 1.03, dot(N, -rd));\n        \n        float Ld = max(0.0, dot(N, L));\n        //Ld = mix(0.0, Ld, ND);\n        vec3 LR = reflect(-L, N);\n        float Ls = max(0.0, dot(LR, -rd));\n        //Ls = mix(0.0, Ls, ND);\n        vec3 surfaceWaterCol = skyRefl;\n        \n        col = mix(\n            \tdeepdiffuse*Ld+skyRefl*Ls,\n            \tsurfaceWaterCol*Ld+skyRefl*Ls,\n            fresnel\n            );\n        \n        float waveHeight = clamp(p.y-0.85*VERTICAL_OFFSET, 0.0, 1.0);\n        vec3 diffuse = mix(deepdiffuse, surfacediffuse, waveHeight);\n        \n        // detail\n        float detailgreyscale = texture(iChannel1, 0.01*p.xz).r;\n        detailgreyscale = max(0.0, detailgreyscale);\n        vec3 detail = vec3(detailgreyscale);\n        \n\t\t/*float oldDepth = texture(iChannel0, uv).a;\n        float temporal = clamp(abs(depth-oldDepth), 0.0, 1.0);\n    \tcol += detail*20.0*vec3(temporal)*pow(ND, 128.0);\n        col = vec3(min(0.1, temporal));*/\n        \n        float NoW = max(0.0, dot(N, normalize(vec3(MainWindDir.x, 0.0, MainWindDir.y))));\n        NoW = min(1.0, 1.0*pow(NoW, 2.0));\n        \n        /*col = brdf(\n            WATER_KS, // ks\n            WATER_KD, // kd\n            WATER_ROUGHNESS, // rougness\n            1.0, // opacity\n            ND, // depth\n            skyRefl, // specular color\n            deepdiffuse, // refract color\n            diffuse+20.0*NoW*detail, // diffuse col\n            rd,\n            N,\n            L);*/\n        vec3 V = -rd;\n        vec3 H = normalize(V+L);\n        float NdotV = max(0.0, dot(N, V));\n        float NdotL = max(0.0, dot(N, L));\n        float NdotH = max(0.0, dot(N, H));\n        float VdotH = max(0.0, dot(rd, H));\n        float LdotH = max(0.0, dot(L, H));\n    \tfloat F = Fresnel_Schlick(1.0, 1.3, NdotV);\n        \n  float G1 = (2.0 * NdotH * NdotV) / VdotH;\n  float G2 = (2.0 * NdotH * NdotL) / LdotH;\n  float G = max(0.00001, min(1.0, min(G1, G2)));\n  float DF = pow(1.0 - NdotV, F);\n        \n        float specDistribution = G*DF*GGX(0.6, NdotV, NdotL);\n        //specDistribution = 1.0/pow(max(0.01, 1.0-NdotV*NdotV), F);\n        //specDistribution = exp(NdotH*NdotL/(NdotV*F));\n        // custom specular distribution term\n        //specDistribution = exp((NdotH*NdotH*NdotH*F-NdotL*NdotL-0.5)/(NdotV));\n        specDistribution = min(1e10, NdotH*F*exp((-NdotL-0.5)/(PI*NdotV)));\n        \n        col = (1.0-F)*deepdiffuse\n            +F*diffuse*NdotL\n            +skyRefl*specDistribution\n            +NoW*detail;\n        col = mix(skyRefl, col, pow(ND, 0.5)); // 0.03\n        depth = 1.0;// bloom coeff\n    }\n    else\n    {\n      depth = 0.0;// bloom coeff\n    }\n    \n    float horizon = pow(1.0-abs(rd.y), 512.0);\n    smoothstep(0.0, 1.0, horizon);\n    //if(uv.x<0.5)\n    col = mix(col, skycol, horizon);\n    /*else\n    col = vec3(horizon);*/\n    #ifdef USE_CUBEMAP_DEBUG\n    col = texture(iChannel2, rd).rgb;\n    #endif\n    fragColor.rgba = vec4(col, depth);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    /*float e = 1.0/iResolution.x;\n    vec3 blurrh = vec3(0.0);\n    vec4 ref=texture(iChannel0, uv).rgba;\n    for(int i = BLOOM_I_MIN; i <=BLOOM_I_MAX;++i)\n    {\n        vec2 off = vec2(e*float(i), 0.0);\n        vec4 col = texture(iChannel0, uv+off).rgba;\n        blurrh += col.rgb*BLOOM_DIV;//col.a*BLOOM_RAMP(col.rgb);//*BLOOM_DIV/max(1.0, float(abs(i)));\n    }\n    //blurrh *= BLOOM_DIV;\n    fragColor.rgba = vec4(blurrh, ref.a);\n    fragColor.rgba = ref;*/\n    vec2 cBlurDir = vec2(1.0, 0.0);\n    vec2 cBlurRadius = vec2(1.0/iResolution.x);\n    float cBlurSigma = 1.2;\n    fragColor = GaussianBlur(BLOOM_I_MAX, cBlurDir, cBlurRadius, cBlurSigma, iChannel0, uv);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    /*float e = 1.0/iResolution.x;\n    vec3 blurrv = vec3(0.0);\n    vec4 ref=texture(iChannel0, uv).rgba;\n    for(int i = BLOOM_I_MIN; i <=BLOOM_I_MAX;++i)\n    {\n        vec2 off = vec2(0.0, e*float(i));\n        vec4 col = texture(iChannel0, uv+off).rgba;\n        blurrv += col.rgb*BLOOM_DIV;//col.a*BLOOM_RAMP(col.rgb);//*BLOOM_DIV/max(1.0, float(abs(i)));\n    }\n    //blurrv *= BLOOM_DIV;\n    fragColor.rgba = vec4(blurrv, ref.a);\n    //fragColor.rgba = ref;*/\n    vec2 cBlurDir = vec2(0.0, 1.0);\n    vec2 cBlurRadius = vec2(1.0/iResolution.y);\n    float cBlurSigma = 1.2;\n    fragColor = GaussianBlur(BLOOM_I_MAX, cBlurDir, cBlurRadius, cBlurSigma, iChannel0, uv);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    computeCubemap(fragColor, fragCoord, rayOri, rayDir);\n}","name":"Cube A","description":"","type":"cubemap"}]}