{"ver":"0.1","info":{"id":"Mf3yWn","date":"1730476311","viewed":78,"name":"Menger Sponge Explorer","username":"aerowave","description":"WASD + arrows\n\nThe number in the corner indicates how many fractal iterations there are where the camera is located. It's possible to get it up to 32 (in theory)","likes":0,"published":3,"flags":48,"usePreview":0,"tags":["raymarching","fractal","menger","sponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* UI / ITERATION LAYER DISPLAY */\n\nint log10i(int x) {\n    int n = 0;\n    while (x != 0) {\n        x /= 10;\n        n++;\n    }\n    return n;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rbg;\n    \n    int X = int(-log(texelFetch(iChannel2, ivec2(0,0), 0).w * 6.0) / log(3.0));\n    \n    X = max(0, X);\n    \n    int i = log10i(X) - 1 - int(fragCoord.x / 32.0);\n    \n    if (i >= 0 && fragCoord.y < 64.0) {\n        int place = 1;\n        for (int j = 0; j < i; j++) place *= 10; \n\n        int digit = (X / place) % 10;\n\n        vec4 text = texelFetch(iChannel1, ivec2(mod(fragCoord, vec2(32,64)) + vec2(digit % 10, 12) * 64.0 + vec2(16,0)), 0);\n\n        col = mix(col, 1.0-col, text.x);\n    }\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// options\n\n#define MAX_ITERATIONS 32\n#define RENDER_DISTANCE 100.0\n#define RAYMARCHING_STEPS 80\n\n//#define WORLD_WRAPPING\n\nconst float PI = asin(1.0) * 2.0;\n\nvoid rotate(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat crossSDF(vec3 p) {\n    const float i3 = 1.0 / 6.0;\n    return min(min(max(abs(p.x - 0.5) - i3, abs(p.y - 0.5) - i3), max(abs(p.x - 0.5) - i3, abs(p.z - 0.5) - i3)), max(abs(p.y - 0.5) - i3, abs(p.z - 0.5) - i3));\n}\n\nfloat map(vec3 p, int iter) {\n    float dist = 0.0;\n    for (float i = 0.0; i < float(iter); i++) {\n        float scale = pow(3.0, i);\n        //dist = max(dist, -crossSDF(fract(p * scale)) / scale);\n        dist = -min(-dist, crossSDF(fract(p * scale)) / scale);\n    }\n    \n    dist = max(dist, -length(p - 0.5) + 0.1);\n    \n    #ifdef WORLD_WRAPPING\n    return dist;\n    #else\n    return max(dist, max(abs(p.x - 0.5) - 0.5, max(abs(p.y - 0.5) - 0.5, abs(p.z - 0.5) - 0.5)));\n    #endif\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* CAMERA CONTROLLER */\n\n// key codes\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\n\nconst int KEY_E = 69;\nconst int KEY_Q = 81;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nconst int KEY_SPACE = 32;\nconst int KEY_SHIFT = 16;\n\nint isPressed(int key) {\n    return int(texelFetch(iChannel1, ivec2(key, 0), 0).x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n    \n    // ignore unused pixels\n    if (fragCoord.y > 1.0) return;\n    \n    // get data from previous frame\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    /* POSITION */\n    if (fragCoord.x == 0.5) {\n    \n        // initial data\n        if (iFrame == 0) fragColor = vec4(0.5,0.5,0.5,0) / pow(3.0, 16.0);\n        \n        // speed is calculated using the distance from the camera to the fractal\n        float speed = (map(fragColor.xyz, int(min(1.0 / fragColor.w, float(MAX_ITERATIONS)))));\n        \n        vec3 rotation = texelFetch(iChannel0, ivec2(1,0), 0).xyz;\n        vec3 velocity = vec3(\n            sin(rotation.z) * float(isPressed(KEY_W) - isPressed(KEY_S)) - cos(-rotation.z) * float(isPressed(KEY_A) - isPressed(KEY_D)),\n            float((isPressed(KEY_E) | isPressed(KEY_SPACE)) - (isPressed(KEY_Q) | isPressed(KEY_SHIFT))),\n            cos(rotation.z) * float(isPressed(KEY_W) - isPressed(KEY_S)) - sin(-rotation.z) * float(isPressed(KEY_A) - isPressed(KEY_D))\n        ) * 2.0;\n        \n        // displace\n        fragColor.xyz += velocity * speed * iTimeDelta;\n        \n        // wrap\n        #ifdef WORLD_WRAPPING\n        fragColor.xyz = fract(fragColor.xyz);\n        #endif\n        \n        // camera speed is also needed in other passes\n        fragColor.w = speed;\n        return;\n    }\n    \n    /* DIRECTION */\n    if (fragCoord.x == 1.5) {\n    \n        // initial data\n        if (iFrame == 0) fragColor = vec4(0,0,0,0);\n        \n        // arrow keys\n        fragColor.x += float(isPressed(KEY_UP) - isPressed(KEY_DOWN)) * PI * iTimeDelta;\n        fragColor.z += float(isPressed(KEY_RIGHT) - isPressed(KEY_LEFT)) * PI * iTimeDelta;\n        \n        // clamp\n        if (fragColor.x > 0.5 * PI) fragColor.x = 0.5 * PI;\n        if (fragColor.x < -0.5 * PI) fragColor.x = -0.5 * PI;\n        \n        return;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* RAYMARCHER */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 rayOrigin = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n    \n    vec3 cameraRotation = texelFetch(iChannel0, ivec2(1,0), 0).xyz;\n\n    rotate(rayDirection.yz, cameraRotation.x);\n    rotate(rayDirection.xz, cameraRotation.z);\n    \n    float cameraScale = texelFetch(iChannel0, ivec2(0,0), 0).w;\n\n    float rayLength = 0.0;\n\n    int fractalIter = clamp(6 + int(-log(texelFetch(iChannel0, ivec2(0,0), 0).w * 6.0) / log(3.0)), 0, MAX_ITERATIONS);\n\n    // raymarch\n    int steps = 0;\n    while (steps < RAYMARCHING_STEPS) {\n        float dist = map(rayOrigin + rayDirection * rayLength, fractalIter);\n        \n        if (dist < 0.0) dist *= -1.0;\n        \n        rayLength += dist;\n    \n        steps++;\n        if (rayLength > cameraScale * RENDER_DISTANCE) break;\n        if (dist < 0.001 * cameraScale) break;\n    }\n    \n    vec3 hitPos = rayOrigin + rayDirection * rayLength;\n    #ifdef WORLD_WRAPPING\n    hitPos = fract(hitPos);\n    #endif\n\n    // solid color\n    vec3 col = 1.0 - vec3(hitPos);\n\n    // sky/fog color\n    vec3 sky = vec3(1);\n    \n    // ambient occlusion\n    col *= 1.0 - sqrt(float(steps) / float(RAYMARCHING_STEPS) / 1.5);\n\n    // fog\n    col = mix(col, sky, sqrt(clamp(rayLength / (cameraScale * RENDER_DISTANCE), 0.0, 1.0)));\n\n    // Output to screen\n    fragColor = vec4(col, cameraScale);\n    \n    //fragColor.bg -= vec2(fractalIter == 14);\n}","name":"Buffer B","description":"","type":"buffer"}]}