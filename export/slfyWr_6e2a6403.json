{"ver":"0.1","info":{"id":"slfyWr","date":"1647802183","viewed":101,"name":"Temple3","username":"lea_02010","description":"Ce shader contient un assemblage de boite et de colonnes. ","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["lifgraphique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Cosine direction \n// seed : Random seed\n//    n : Normal\nvec3 Cosine( float seed, vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m, vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.5;\n    \n    // Origin\n    ro=vec3(37.0,0.0,15.0);\n    ro*=Rz(a); \n\n    // Target\n    vec3 ta = vec3(0.0,0.0,1.0);\n    \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n\n\n//-----------------------------------------------\n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Primitives \n\n// Sphere \n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p, vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n//Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nfloat Plane(vec3 p, vec3 n, vec3 o)\n{\n    return dot((p-o),n);\n}\n\n//sqr\n// returns the square of a \nfloat sqr (float a){\n    return a*a;\n}\n\n//Disque \n//c : Center\n//n : Normal\n//p : Point\n//r : Radius\nfloat Disque (vec3 c, vec3 n, vec3 p, float r){\n    vec3 cp = p-c; //Calcul le vecteur CP.\n    float dpc = length (cp); // Calcul la longueur du vecteur CP \n    float dpq = dot (cp, n); // Calcul la longueur PQ ou Q est le projeté orthogonal de P sur le plan du disque\n    float dqc = sqrt(sqr (dpc) - sqr(dpq)); // Calcul la longueur QC par Pythagore\n    return sqrt (sqr(dpq) + sqr(dqc -r )); // Calcul la distance entre p et le disque par Pythagore\n}\n\n//Droite \n//a,b : Points characterising the line \n//p : Point\nfloat Droite (vec3 a, vec3 b, vec3 p){\n    vec3 u = (b-a)/length (b-a); // u est le vecteur unitaire de AB \n    float l = dot (p-a, u); // Calcul la longueur entre le point A et le projeté orthogonal de P sur la droite\n    return sqrt (sqr(length (p-a))-sqr(l)); // Calcul la distance entre p et la droite par Pythagore\n}\n\n//Cylindre\n//a,b : Extremum\n//p : Point\n//r : Radius\nfloat Cylindre (vec3 a, vec3 b, vec3 p, float r){\n    vec3 u = (b-a)/length (b-a); // u est le vecteur unitaire de AB\n    vec3 bp = p-b; // Calcul le vecteur BP\n    vec3 ap = p-a; // Calcul le vecteur AP\n    //On regarde ou est p par rapport à notre cylindre et on calcul notre distance par rapport à ça\n    if ( dot (ap, u) < 0.0)\n    {\n        return Disque (a,u,p,r); // Calcul de la distance entre p et le disque caractérisé par le point A\n    }\n    \n    if (dot (bp,u) > 0.0)\n    {\n        return Disque (b,u,p,r); // Calcul de la distance entre p et le disque caractérisé par le point B\n    }\n    \n    else { return Droite (a,b,p)-r; } // Calcul de la distance entre p et le segment AB - le rayon du cylindre\n}\n\n\n//Capsule\n//a,b : Extremum\n//p : Point\n//r : Radius\nfloat Capsule (vec3 a, vec3 b, vec3 p, float r)\n{\n    vec3 u = (b-a)/length (b-a); // u est le vecteur unitaire de AB\n    vec3 bp = p-b; // Calcul le vecteur BP\n    vec3 ap = p-a; // Calcul le vecteur AP\n    float dap = length (ap); // Calcul la longueur du vecteur AP\n    float dbp = length (bp); // Calcul la longueur du vecteur BP\n     //On regarde ou est p par rapport à notre cylindre et on calcul notre distance par rapport à ça\n    if (dot (ap, u) < 0.0)\n    {\n        return dap-r; // Calcul de la distance entre p et le sommet A de la capsule\n    }\n    \n    if (dot (bp,u) > 0.0)\n    {\n        return dbp-r; // Calcul de la distance entre p et le sommet B de la capsule\n    }\n    \n    else {return Droite (a,b,p)-r;} // Calcul de la distance entre p et le segment AB - le rayon de la capsule\n}\n\n\n//Cercle \n//c : Center\n//p : Point\n//n : Normal\n//r : Radius\nfloat Cercle (vec3 c, vec3 p,vec3 n, float r){\n    float pq = dot(p-c,n); // Calcul de la longueur PQ ou Q est le projeté orthogonal de P sur le plan du cercle\n    float cp = length (p-c); // Calcul de la longueur du vecteur CP\n    float qc = sqrt( sqr(cp)- sqr (pq)); // Calcul de la longueur QC par Pythagore\n    float l = qc -r; // Calcul de la distance entre Q et le cercle \n    return sqrt(sqr(pq)+sqr(l)); // Calcul de la distance entre p et le cercle\n}\n\n//Tore\n//c : Center\n//p : Point\n//n : Normal\n//r : Radius of the circle characterising the torus\n//R : Radius of the torus\nfloat Tore (vec3 c, vec3 p,vec3 n, float r, float R){\n    return Cercle(c,p,n,r)-R ; \n}\n\n// Cube\n// c : Center of box \n// o : Size of box in relation to the center\n// p : Point\nfloat Cube(vec3 p, vec3 c, vec3 o){\n    // Calcul des vecteurs unitaires de l'espace 3d\n    vec3 nx = vec3(1, 0, 0);\n    vec3 ny = vec3(0, 1, 0);\n    vec3 nz = vec3(0, 0, 1);\n    \n    vec3 a = p + c + o/2.0; // Calcul du point A qui sera un de coin du cube\n    vec3 b = p + c - o/2.0; // Calcul du point B qui sera le coin opposé de A du cube\n    \n    // Calcul de la distance entre entre les différents plan du cube et p\n    float p1x = Plane(a, nx, o);\n    float p2x = Plane(b, -nx, -o);\n    float p1y = Plane(a, ny, o);\n    float p2y = Plane(b, -ny, -o);\n    float p1z = Plane(a, nz, o);\n    float p2z = Plane(b, -nz,- o);\n\n    // Retourne la distance entre le point P et le cube en faisant l'intersection des différnents plans \n    return max(max(max(p1x, p2x), max(p1y, p2y)), max(p1z, p2z));\n}\n\n// Operators\n\n// Union\n// a,b : Field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n    return min(a,b);\n}\n\n// Intersection\n// a,b : Field function of left and right sub-trees\nfloat Intersection(float a,float b)\n{\n    return max(a,b);\n}\n\n// Différence\n// a,b : Field function of left and right sub-trees\nfloat Difference( float a, float b ) \n{ \n    return max(a,-b); \n}\n\n// Translation \n// a : Vector going through a translation\n// t : Translation vector\nvec3 Translation (vec3 a, vec3 t)\n{\n    return vec3(a-t);\n}\n\n// RotationX \n// r : Rotation angle\nmat3 RotationX ( float r)\n{\n    mat3 rot = mat3(1.0,  0.0,    0.0,\n                    0.0, cos(r), -sin(r),\n                    0.0, sin(r), cos(r));\n    return rot;\n}\n\n// RotationY \n// r : Rotation angle\nmat3 RotationY ( float r)\n{\n    mat3 rot = mat3(0.0, cos(r), -sin(r),\n                    1.0,  0.0,    0.0,\n                    0.0, sin(r), cos(r));\n    return rot;\n}\n\n// RotationZ \n// r : Rotation angle\nmat3 RotationZ ( float r)\n{\n    mat3 rot = mat3(0.0, cos(r),-sin(r),\n                    0.0, sin(r), cos(r),\n                    1.0,  0.0,   0.0);\n    return rot;\n}\n\n// Homotéthie\n// p : Vector undergoing homothety\n// s : Ratio of homothety\nvec3 Homothetie (vec3 p, vec3 s)\n{\n    // Calcul le changement de coordonnées si et seulement si la coordonnée de S\n    // n'est pas égale à 0 auquel cas on n'effectueras pas de changement\n    if (s.x !=0.0) p.x= p.x/s.x; \n    if (s.y !=0.0) p.y= p.y/s.y; \n    if (s.z != 0.0) p.z = p.z/s.z;\n    return p;\n}\n\n// Escalier\n// p : Point \n// r : center of the first step\nfloat escalier (vec3 p, vec3 r){\n \n    float escalier [4]; // On crée un tableau pour l'ensemble de nos marches d'escalier \n    \n    for (int i =0; i<4; i++)\n    {\n        escalier[i]= Cube (p,r, vec3(3.0, 15.0, 0.5)); // Pour chaque marche on crée un cube d'une \n                                                       // certaine taille\n        r = Translation (r, vec3(3.0,0.0,2.0)); // On effectue une translation sur l'origine de la \n                                                // prochaine marche\n    }\n    \n    float m = escalier[0]; // On crée une variable qui contiendra l'ensemble de nos marches \n    \n    // A chaque nouvelle marche on fait l'union de l'escalier déjà construit et la nouvelle marche \n    for (int j=1;j<4; j++)\n    {\n        m = Union (m, escalier [j]);\n    }\n    \n    return m; // On retourne m la variable qui contient l'ensemble de notre escalier \n}\n\n// Escalier 2\n// p : Point\n// or_esc : center of the first step\nfloat escalier2 (vec3 p, vec3 or_esc){\n    //vec3 or_esc = vec3 (0.0,0.0,3.0);\n    vec3 taille = vec3 (35.0, 30.0, 1.0); // On crée la taille de notre première marche\n    \n    float esc [4]; // On crée un tableau pour l'ensemble de nos marches d'escalier\n    \n    // Pour chaque nouvelle marche, on créeé un cube puis on effectue une translation sur l'origine de la\n    // prochaine marche et on diminue la taille de cette nouvelle marche à l'aide d'une homothétie\n    for (int i = 0; i<4; i++)\n    {\n        esc [i]=Cube (p, or_esc, taille); \n        taille = Homothetie (taille, vec3(1.1,1.1,0.0)); \n        or_esc = Translation (or_esc, vec3(0.0,0.0,1.0)); \n    }\n    \n    float escalier = esc [0];  // On crée une variable qui contiendra l'ensemble de nos marches\n    \n    // A chaque nouvelle marche on fait l'union de l'escalier déjà construit et la nouvelle marche \n    for (int j =1; j<4; j++)\n    {\n        escalier = Union (escalier, esc[j]);\n    }\n    \n    return escalier; // On retourne escalier la variable qui contient l'ensemble de notre escalier\n}\n\n// Colonne\n// p : Point\n// origin : Point of origin of the column \nfloat Colonne (vec3 p, vec3 origin){\n\n    // Vecteur b, le deuxième extremum pour créer notre cylindre \n    vec3 b = origin; \n    b.z=origin.z+8.0; // La taille du cylindre sera donc de 8.0\n    \n    float rayon =0.75; // Rayon du cylindre\n    \n    vec3 normale = vec3(0.0,0.0,1.0); // Normale de la colonne qu'on aura besoin pour le tore\n    \n    // Vecteur d'origine pour la base de notre colonne \n    vec3 y = -origin;\n    y.z=-origin.z+0.5;\n    \n    vec3 taille = vec3(2.5,2.5, 1.0); // Taille de la base et du chapiteau de la colonne \n    //Le chapiteau est le cube en haut de la colonne\n    \n    // Vecteur d'origine pour le chapiteau de notre colonne\n    vec3 chap = -origin; \n    chap.z=-origin.z-8.0;\n   \n    //Création des différentes formes nécéssaires \n    float fut = Cylindre(origin,b,p, rayon); \n    float tore = Tore (origin, p, normale, rayon, 0.5);\n    float tore2 = Tore (Translation (origin, vec3 (0.0,0.0,-0.5)), p, normale, rayon, 0.25);\n    float base = Cube (p,y,taille);\n    float chapiteau = Cube (p,chap,taille);\n    \n     //On retourne l'union de toutes nos formes \n    return Union (fut, Union(tore, Union (base, Union (tore2, chapiteau))));\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n    // COLONNES \n    \n    vec3 or_colonne = vec3(10.0,7.5,1.5); //Origine de la première colonne\n    \n    float Col [15]; //tableau d'un ensemble de colonne\n    \n    // Création de la première ligne de colonne\n    for (int i =0; i<5; i++)\n    {\n        Col[i] = Colonne (p,or_colonne);\n        or_colonne = Translation (or_colonne, vec3(5.0, 0.0,0.0));\n    }\n    \n    // Car la boucle précédente a effectuer une translation de trop donc on revient en arrière \n    or_colonne = Translation (or_colonne, vec3(-5.0, 0.0,0.0)); \n    \n    // Création de la deuxième ligne de colonne\n    for (int i=5;i<8;i++)\n    {\n        or_colonne =Translation (or_colonne, vec3 (0.0, 5.0, 0.0));\n        Col[i]=Colonne (p,or_colonne);\n    }\n    \n    // Création de la troisième ligne de colonne\n    for (int i=8; i<13; i++)\n    {\n        Col[i]= Colonne (p, or_colonne); \n        or_colonne = Translation (or_colonne, vec3(-5.0, 0.0,0.0));\n    }\n    \n    // Car la boucle précédente a effectuer une translation de trop donc on revient en arrière \n    or_colonne = Translation (or_colonne, vec3(5.0, 0.0,0.0));\n    \n    // Création de la quatrième ligne de colonne\n    for (int i=13;i<15;i++)\n    {\n        or_colonne = Translation (or_colonne, vec3 (0.0, -5.0, 0.0));\n        Col[i]=Colonne (p,or_colonne);\n    }\n    \n    //Création de col_temple qui va contenir l'ensemble des colonnes nécéssaire pour la construction du temple\n    float col_temple = Col[0]; \n    for (int j =1; j<15; j++)\n    {\n        col_temple = Union (col_temple, Col[j]);\n    }\n    \n    // ESCALIER\n    \n    vec3 or_esc = vec3 (0.0,0.0,3.0); //Création de l'origine de l'escalier\n    float escalier = escalier2(p, or_esc); //Création de l'escalier \n    \n    // TOIT\n    \n    //Création du toit à l'aide d'un cube \n    float toit = Cube (p,vec3 ( 0.0,0.0,-10.0),vec3(23.0, 18.0,0.5));\n    \n    // ASSEMBLAGE \n    \n    //Assemble de l'escalier, des colonnes, du toit et de la plateforme\n    float assemblage = Union (col_temple, Union (toit,escalier));\n    assemblage = Union (assemblage,\n                      Intersection( Plane(p,vec3(0.0,0.0,1.0),vec3(0.0,0.0,-4.0)),\n                                    Sphere(p,vec3(0.0,0.0,-4.0),30.0))\n     );\n     \n     return assemblage; \n}\n\n// Analysis of the scalar field \n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n  // Start at the origin\n  float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v < 0.0)\n      {\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Lighting \n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// r : Radius for ambient occlusion\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n, float r, int a)\n{\n    if (a==0) { return 1.0; }\n    \n\tfloat ao=0.0; \n    \n    for (int i=0;i<a;i++)\n    {\n \t\tvec3 d = Cosine(581.123*float(i) , n);\n\n        int s;\n        bool h;\n        float t=SphereTrace(p,d,r,h,s);\n        if (!h) {ao+=1.0;}\n    }\n    \n    ao/=float(a);\n\treturn ao;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.45,0.55,0.99),vec3(0.65,0.69,0.99), d.z*0.5+0.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p+0.1*n,l,100.0,h,s);\n    if (!h)\n    {\n      return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    // Ambient color\n    vec3 ambient = 0.25+0.25*background(n);\n    \n    // Ambient occlusion\n    ambient += 0.15 * AmbientOcclusion(p+0.1*n,n,5.0,0) * vec3(1.0,1.0,1.0);\n    \n    // Shadow computation\n    float shadow = Shadow(p,n,l);\n    \n    // Phong diffuse\n    vec3 diffuse = 0.35  * clamp(dot(n, l),0.0,1.0) * vec3(1.0,1.0,1.0);\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = 0.15 * pow(clamp(dot(r,l),0.0,1.0),30.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + shadow * (diffuse + specular);\n    return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t = float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p = (-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip = true;\n    }\n       else\n       {\n           pip = false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}