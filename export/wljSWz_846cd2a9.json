{"ver":"0.1","info":{"id":"wljSWz","date":"1565947138","viewed":203,"name":"#Evoke 2019 - Sine Wave 2D","username":"VJSpackOMat","description":"This example uses Mouse-Click and Mouse-X/Y for frequencies, lower left is 0/0\n\nIt demonstrates a 1 dimensional sine-line that is controlled by 2 frequencies, by introducing a second wave more interesting patterns occur,\nfor the fun of it 3 params\n\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\nSine Wave 2D\n\nc.Kleinhuis evoke 2019 - talk 'hybrid fractals'\n\nControls:\n\n- use mouse x/yo change frequencies of 2 waves\n \nhere a second dimension is added to create a place on the plane\n\n2 hybrid sine waves form the position of each dot\n\nthis is the way how common demo programming sprite/endless bobs/dotflag\neffects created their output and serves as example how hybridisation has\nbeen always used in computer/demo scene programming\n\n*/\n#define NUM_POINTS 1000000.0f\n#define POINT_SIZE 0.005f\n\nvec2 increment1=vec2(1.7f,1.1f);\nvec2 increment2=vec2(1.7f,1.2f);\nvec2 increment3=vec2(1.4f,1.1f);\nvec2 amplitude=vec2(1,1); \n\nfloat sineDist(vec2 p){\n    \t\n  float time=iTime*100.0f;\nvec2 frequency1=iMouse.xy/iResolution.xy;\nvec2 frequency2=iMouse.zw/iResolution.xy;\nvec2 frequency3=vec2(1.,2.);\n    float mini=NUM_POINTS;\n    for(float i=0.;i<800.f;i++){\n           // current point\n           vec2 curr=vec2(         \n               // x\n               sin(radians(time*frequency1.x+i*frequency1.x*increment1.x))*amplitude.x/6.0+amplitude.x/6.0+ \n               sin(radians(time*frequency2.x+i*frequency2.x*increment2.x))*amplitude.x/6.0+amplitude.x/6.0+                  \n               sin(radians(time*frequency3.x+i*frequency3.x*increment3.x))*amplitude.x/6.0+amplitude.x/6.0,                   \n               // y\n               sin(radians(time*frequency1.y+i*frequency1.y*increment1.y))*amplitude.y/6.0+amplitude.y/6.0+\n               sin(radians(time*frequency2.y+i*frequency2.y*increment2.y))*amplitude.y/6.0+amplitude.x/6.0+ \n               sin(radians(time*frequency3.y+i*frequency3.y*increment3.y))*amplitude.y/6.0+amplitude.y/6.0\n        );\n        \n        if(length(p-curr)<POINT_SIZE){\n        \tmini=min(mini,length(p-curr));\n        }\n        \n    }\n    \n    return 1.-mini;\n\n    \n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col =       vec3(0.,0.,0.);\n\n    col.r=sineDist(uv);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n\n}","name":"Image","description":"","type":"image"}]}