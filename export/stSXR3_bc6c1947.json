{"ver":"0.1","info":{"id":"stSXR3","date":"1628359030","viewed":239,"name":"MetalText - RoS","username":"LilBensson","description":"Animated Rings of Saturn logo from their album \"Ultu Ulla\". The overall look is far from perfect, but the animation ended up being pretty cool! ","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["text","logo","metal","fonts","ringsofsaturn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2x2 rotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2x2(c, s, -s, c);\n}\n\nvoid getBlurredOutline(inout vec4 col, vec2 uv)\n{\n    int blurSize = 10;\n    float blurMask = 0.0;\n    \n    // Blur with a small distance falloff for the weight\n    for(int xo = -blurSize; xo <= blurSize; ++xo)\n    {\n        for(int yo = -blurSize; yo <= blurSize; ++yo)\n        {\n            vec2 offset = vec2(xo, yo);\n        \n            blurMask += texture(iChannel0, uv + offset / iResolution.xy).r / \n                max(1.0, pow(dot(offset, offset), 1.25));\n        }\n    }\n    blurMask = clamp(blurMask, 0.0, 1.0);\n    \n    col = mix(col, vec4(0.33, 0.45, 0.22, 1.0), blurMask * getLOM(iTime));\n}\n\nvoid getGreenOutline(inout vec4 col, vec2 uv)\n{\n    int outlineSize = 2;\n    float outlineMask = 0.0;\n    \n    // Find samples within box\n    for(int xo = -outlineSize; xo <= outlineSize; ++xo)\n    {\n        for(int yo = -outlineSize; yo <= outlineSize; ++yo)\n        {\n            outlineMask += texture(iChannel0, uv + vec2(xo, yo) / iResolution.xy).r;\n        }\n    }\n    outlineMask = clamp(outlineMask, 0.0, 1.0);\n    \n    col = mix(col, vec4(0.3, 0.65, 0.2, 1.0), outlineMask * getLOM(iTime));\n}\n\nvoid getPurpleText(inout vec4 col, vec2 uv)\n{\n    float mask = texture(iChannel0, uv).r;\n    \n    // Gradient\n    vec4 purpleGradient = mix(vec4(0.224, 0.016, 0.40, 1.0), vec4(0.03, 0.01, 0.10, 1.0), clamp(abs((0.7 - uv.y) * 3.5), 0.0, 1.0));\n    purpleGradient = mix(vec4(1.0), purpleGradient, getLOM(iTime));\n    \n    // Texture \n    float textureEffect = 0.7;\n    vec2 texUV = uv * 40.0 * rotate(0.3);\n    vec4 textTextureCol = vec4(vec3(texture(iChannel1, texUV).r * textureEffect + 1.0 - textureEffect), 1.0);\n    textTextureCol = mix(vec4(1.0), textTextureCol, getLOM(iTime));\n    \n    col = mix(col, purpleGradient * textTextureCol * mask, mask);\n}\n\nvoid getDisk(inout vec4 col, vec2 fragCoord)\n{\n    float extendedLOM = pow(getExtendedLOM(iTime), 2.0);\n    \n    // Disk mask\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv += vec2(-0.012, 0.0);\n    uv *= rotate(-0.07);\n    uv.y *= 7.0;\n    float diskMask = smoothstep(0.615, 0.6, length(uv));\n    uv.y *= 1.2;\n    diskMask -= smoothstep(0.375, 0.36, length(uv));\n    \n    // Disk outline\n    uv.y /= 1.2;\n    float diskMaskOutline = smoothstep(0.65 + uv.y * uv.y * 0.2, 0.58, length(uv));\n    uv.y *= 1.2;\n    diskMaskOutline -= smoothstep(0.37, 0.3, length(uv));\n    \n    // Disk blending masks\n    float diskBlendMask = diskMask * (1.0 - col.a * (1.0 - step(uv.y, 0.0)));\n    float diskBlendOutline = diskMaskOutline * (1.0 - col.a * (1.0 - step(uv.y, 0.0)));\n    \n    // Animation cutoff\n    uv *= rotate(PI * 0.5);\n    float timeCutoff = smoothstep(\n        0.04 * extendedLOM, \n        -0.04 * (1.0 - extendedLOM), \n        abs(atan(uv.y, uv.x) / PI) - extendedLOM\n    );\n    diskBlendMask *= timeCutoff;\n    diskBlendOutline *= timeCutoff;\n    \n    // Disk blending\n    float originalColA = col.a;\n    col = mix(col, vec4(1.0), diskBlendOutline * 0.7 * (1.0 - diskBlendMask));\n    \n    float bands = sin(length(uv) * 70.0) * 0.05 + 0.5;\n    col = mix(col, vec4(0.15, 0.02, 0.5, 1.0) * bands, clamp(diskBlendMask * 1.0 - originalColA * 0.3, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // \"Layers\"\n    vec4 col = vec4(0.0);\n    getBlurredOutline(col, uv);\n    getGreenOutline(col, uv);\n    getPurpleText(col, uv);\n    getDisk(col, fragCoord);\n    \n    // Gamma correction\n    col = pow(col, vec4(0.45));\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// ---------- Semi-random functions ----------\n\nuint wang_hash(uint seed)\n{\n\tseed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    \n    return seed;\n}\n\nfloat randomFloat(float state)\n{\n\treturn float(wang_hash(uint(state))) / 4294967296.0;\n}\n\nfloat randomFloat(vec2 state)\n{\n    uint newState = uint(abs(state.x + state.y * 1024.0));\n\n\treturn float(wang_hash(newState)) / 4294967296.0;\n}\n\n\nvec2 distortDir(vec2 p)\n{\n    float a = texture(iChannel1, (p + vec2(10.0)) * 0.1).r * PI * 2.0;\n    \n    return vec2(cos(a), sin(a));\n}\n\n// ---------- Character functions ----------\n// Starting point from: https://www.shadertoy.com/view/4sBfRd\n\nfloat CHAR_HORIZONTAL_SPACING = 0.37;\nfloat CHAR_VERTICAL_SPACING = 0.55;\n\n//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n#define C(c) mask += char(U, 64 + c); U.x -= CHAR_HORIZONTAL_SPACING; \n\n#define C_A 1\n#define C_B 2\n#define C_C 3\n#define C_D 4\n#define C_E 5\n#define C_F 6\n#define C_G 7\n#define C_H 8\n#define C_I 9\n#define C_J 10\n#define C_K 11\n#define C_L 12\n#define C_M 13\n#define C_N 14\n#define C_O 15\n#define C_P 16\n#define C_Q 17\n#define C_R 18\n#define C_S 19\n#define C_T 20\n#define C_U 21\n#define C_V 22\n#define C_W 23\n#define C_X 24\n#define C_Y 25\n#define C_Z 26\n\nvec2 char(vec2 p, int c) \n{\n    // Bounds check\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) \n        return vec2(0.0);\n    \n    // Gives cool results :)\n    for(int i = 0; i < 8; ++i)\n    {\n        p += distortDir(p + vec2(randomFloat(vec2(c, c + 99)))) * 0.009 * getLOM(iTime);\n    }\n    \n    vec4 charCol = texture(\n        iChannel0, \n        p/16. + fract(vec2(c, 15 - c / 16) / 16.0)\n    ); \n    vec2 mask = vec2(charCol.r);\n    \n    // Spikes\n    vec2 perpVec = vec2(charCol.y, charCol.z) * 2.0 - 1.0;\n    perpVec = vec2(-perpVec.y, perpVec.x);\n    float t = dot(perpVec, p);\n    mask.y += max(0.0, abs(sin(t * 16.0) * 1.1)) * (1.07 - charCol.a) * 0.9 * getLOM(iTime);\n    \n    // Binary check if the masks are visible\n    return 1.0 - vec2(step(mask, vec2(0.5)));\n}\n\nvec2 getDistortedUV(vec2 uv)\n{\n    float t = 0.3;\n    uv *= length(uv) * t + 1.0 - t;\n    uv.x *= (5.0 * uv.y * uv.y) + 1.0;\n    uv.x *= 1.1;\n    \n    return uv;\n}\n\nfloat getLetterMask(vec2 uv)\n{\n    // x: letter mask, y: spike mask\n    vec2 mask = vec2(0.0);\n    vec2 position = vec2(0.0, 0.0);\n    vec2 originalUV = uv;\n    float originalFontSize = 15.0;\n    float fontSize = 18.5;\n    \n    // Further distort the UVs\n    uv.y += pow(abs(uv.x), 2.0) * getLOM(iTime);\n    \n    // Draw upper text\n    vec2 U = (uv - position) * 64.0 / fontSize + \n            vec2(CHAR_HORIZONTAL_SPACING * 5.0 * 0.5, 0.0) + \n            vec2(CHAR_HORIZONTAL_SPACING * -0.5 + 0.5, 0.15);\n    C(C_R);C(C_I);C(C_N);C(C_G);C(C_S);\n\n    // Reset\n    fontSize = originalFontSize;\n    uv = originalUV;\n    \n    // Draw middle text\n    U = (uv - position) * 64.0 / fontSize + \n        vec2(CHAR_HORIZONTAL_SPACING * 2.0 * 0.5, 0.0) + \n        vec2(CHAR_HORIZONTAL_SPACING * -0.5 + 0.5, 0.15);\n    U.y += CHAR_VERTICAL_SPACING;\n    C(C_O);C(C_F);\n    \n    // Reset and distort\n    fontSize = originalFontSize;\n    uv = originalUV;\n    uv.y -= pow(abs(uv.x), 2.0) * getLOM(iTime);\n    \n    // Draw lower text\n    U = (uv - position) * 64.0 / fontSize + \n        vec2(CHAR_HORIZONTAL_SPACING * 6.0 * 0.5, 0.0) + \n        vec2(CHAR_HORIZONTAL_SPACING * -0.5 + 0.5, 0.15);\n    U.y += CHAR_VERTICAL_SPACING * 2.0;\n    C(C_S);C(C_A);C(C_T);C(C_U);C(C_R);C(C_N);\n    \n    // Keep spikes where there is no overlap\n    mask.x = mask.y * step(mask.x, 1.0);\n    \n    return mask.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Animate spacing\n    CHAR_HORIZONTAL_SPACING += (1.0 - getLOM(iTime)) * 0.05;\n    CHAR_VERTICAL_SPACING += (1.0 - getLOM(iTime)) * 0.06;\n\n    // Render mask\n    vec3 col = vec3(0.0);\n    for(int xo = 0; xo < AA; ++xo)\n    {\n        for(int yo = 0; yo < AA; ++yo)\n        {\n            // Coordinates\n            vec2 currFragCoord = fragCoord + vec2(xo, yo) / vec2(AA);\n            vec2 uv = (currFragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n            // Distort UVs to make the letters more round\n            uv = mix(uv, getDistortedUV(uv), getLOM(iTime));\n\n            // Letters\n            col += vec3(clamp(getLetterMask(uv), 0.0, 1.0));\n        }\n    }\n    col /= float(AA * AA);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define AA 4\n\n#define PI 3.14159265359\n\n// Get \"Level of Metal\" (for animation)\nfloat getLOM(float t)\n{\n    float x = cos(t) * 0.5 + 0.5;\n\n    return clamp(x, 0.0, 1.0);\n}\n\n// Stay at 0 and 1 longer\nfloat getExtendedLOM(float t)\n{\n    float x = cos(t) * 0.6 + 0.5;\n\n    return clamp(x, 0.0, 1.0);\n}","name":"Common","description":"","type":"common"}]}