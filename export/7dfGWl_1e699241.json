{"ver":"0.1","info":{"id":"7dfGWl","date":"1616803441","viewed":659,"name":"Volumetric clouds attempt","username":"Krafpy","description":"An attempt to render volumetric clouds with 3D noise.\nHighly inspired from this video : https://www.youtube.com/watch?v=4QOcCGI6xOU","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","clouds","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nVolumetric clouds rendering.\nUse the mouse to rotate around.\n*/\n\n#define PI 3.141592\n#define TWO_PI 6.28319\n\nvec3 sunDir = normalize(vec3(0., 0.2, 1.));\nvec3 sunCol;\n\nconst float sphRad = 4.;\n\n// 2D roation matrix\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\n// Rodrigues' rotation formula : rotates v around u of an angle a\nvec3 rot(vec3 v, vec3 u, float a){\n    float c = cos(a);\n    float s = sin(a);\n    return v * c + cross(u, v) * s + u * dot(u, v) * (1. - c);\n}\n\n/*float remap(float x, float a, float b, float c, float d){\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}*/\n\nfloat saturate(float x){\n    return clamp(x, 0., 1.);\n}\n\n// 3D random texture based noise\nfloat noise(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    //f = f * f * (3. - 2. * f); // f = smoothstep(0., 1., f);\n    f = f * f * f * (6. * f * f - 15. * f + 10.); // quintic smoothstep\n    p = i + f;\n    return textureLod(iChannel0, (p+0.5)/32., 0.).r;\n}\n\nfloat fbm(vec3 p){\n    float f;\n    f = 0.5 * noise(p * 1.);\n    f += 0.25 * noise(p * 2.);\n    f += 0.125 * noise(p * 4.);\n    f += 0.0625 * noise(p * 8.);\n    return f;\n}\n\n// ray-box intersection from : https://www.shadertoy.com/view/MtcXRf\n/*vec2 boxIntersect(vec3 ro, vec3 rd){\n    const vec3 boxCenter = vec3(0.);\n    const vec3 boxRadius = vec3(4.);\n    \n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-boxCenter);\n    vec3 k = abs(m)*boxRadius;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}*/\n\n// sphere intersection : returns the distance to the two intersection points with a ray\nvec2 sphIntersect(vec3 ro, vec3 rd){\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float d = b * b - a * (dot(ro, ro) - sphRad * sphRad);\n    \n    if(d < 0.) return vec2(-1.);\n    \n    d = sqrt(d);\n    float tn = (-b - d) / a;\n    float tf = (-b + d) / a;\n    \n    return vec2(tn, tf);\n}\n\n\n// sun and sky background in a ray direction\nvec3 background(vec3 ro, vec3 rd){\n    vec3 sky = vec3(0.06, 0.08, 0.1) * 5.;\n    vec3 col = sky;\n    \n    // sun\n    float d = clamp(dot(rd, sunDir), 0., 1.);\n    \n    col += sunCol * smoothstep(0.998, 1., d) * vec3(1., 0.6, 0.4) + smoothstep(0.9985, 1., d);\n    col += sunCol * smoothstep(0.9, 1., d) * 0.2 * (1.-col);\n    \n    col = mix(col, sunCol, 0.2);\n    \n    return col;\n}\n\n// sample cloud density for a point in space\nfloat getDensity(vec3 p){\n    const float densMult = 12.;\n    const float scale = 0.7;\n    const float densThresh = 0.55;\n    const float offsetSpeed = 0.2;\n    \n    float f = fbm(p * scale + iTime * offsetSpeed);\n    f = max(0., f - densThresh) * densMult;\n    \n    f *= smoothstep(1., 0.8, dot(p, p) / (sphRad * sphRad));\n    \n    return f;\n}\n\n// raymarches inside the cloud towards light : returns transmittance\nfloat lightmarch(vec3 p){\n    const float numSteps = 20.;\n    const float absorption = 0.9;\n    const float darkness = 0.5;\n    \n    vec2 itsc = sphIntersect(p, sunDir);\n    float stepSize = itsc.y / numSteps;\n    \n    float density = 0.;\n    \n    for(float i = 0.; i < numSteps; ++i){\n        p += sunDir * stepSize;\n        density += getDensity(p) * stepSize;\n    }\n    \n    float transmittance = exp(-density * absorption);\n    return darkness + transmittance * (1. - darkness);\n}\n\n// raymarches total cloud density : returns the (transmittance, energy) at that point\nvec2 raymarch(vec2 itsc, vec3 ro, vec3 rd){\n    const float numSteps = 64.;\n    const float absorption = 1.2;\n    const float phase = 1.;\n    \n    float stepSize = (itsc.y - itsc.x) / numSteps;\n    vec3 p = ro + max(0., itsc.x) * rd + 0.001 * rd;\n    \n    float transmittance = 1.;\n    float energy = 0.;\n    \n    for(float i = 0.; i < numSteps; ++i){\n        float density = getDensity(p);\n        if(density > 0.){\n            float sunTransmittance = lightmarch(p);\n            energy += density * stepSize * transmittance * sunTransmittance * phase;\n            transmittance *= exp(-density * stepSize * absorption);\n        }\n        p += rd * stepSize;\n    }\n    \n    return vec2(transmittance, energy);\n}\n\n// renders the color for a given direction\nvec3 render(vec3 ro, vec3 rd){\n    vec3 col = background(ro, rd);\n    \n    vec2 itsc = sphIntersect(ro, rd);\n    \n    if(itsc.y < 0.){\n        return col;\n    }\n    \n    vec2 light = raymarch(itsc, ro, rd);\n    return col * light.x + sunCol * light.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // pixel ray    \n    vec3 ro = vec3(0., 0., -10.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    // control camera\n    vec2 mouseAngle = iMouse.xy/iResolution.xy;\n    mouseAngle -= 0.5;\n    mouseAngle.x *= iResolution.x / iResolution.y;\n    mouseAngle *= -PI;\n\n    ro.yz *= rot(mouseAngle.y);\n    rd.yz *= rot(mouseAngle.y);\n    ro.xz *= rot(mouseAngle.x);\n    rd.xz *= rot(mouseAngle.x);\n    \n    // animate sun\n    const float sunSpeed = 0.2;\n    vec3 rotAxis = normalize(vec3(1., 1., 0.));\n    float sunAngle = mod(iTime * sunSpeed, TWO_PI);\n    \n    const vec3 brightSunCol = vec3(1.,0.97,0.95);\n    const vec3 darkSunCol = vec3(1., 0.5, 0.3);\n    \n    float f = sunAngle / TWO_PI;\n    f = 1. - smoothstep(0., 1., abs(f-0.5)*2.);\n    sunCol = mix(brightSunCol, darkSunCol, f);\n    \n    sunDir = rot(sunDir, rotAxis, sunAngle);\n    \n    // color\n    vec3 col = vec3(0.);\n    \n    col = render(ro, rd);\n    // simple post processing\n    //col = mix(col, sunCol, pow(1. - uv.y, 2.) * 0.15);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}