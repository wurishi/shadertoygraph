{"ver":"0.1","info":{"id":"sltBRM","date":"1662846480","viewed":143,"name":"Julia land","username":"Alpaga","description":"A 3D view of a Julia set.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D view of a Julia set. The depth at a point grows with the\n// number of iterations of the quadratic map.\n// Height map and color map are computed in Buffer A.\n// It is then rendered using ray marching. \n\nconst float fov = 35.0;\nconst float cameraSpeed = 0.5;\n\nconst float reflectivity = 0.2;\n\nconst vec3 ambient = vec3(0.1);\nconst vec3 lightPosition = vec3(0.0,3.0,3.0);\n\nconst vec2 delta = vec2(0.0,0.01);\n\n// Signed distance estimate to height map\nfloat sd(vec3 p) {\n    vec2 q = 0.3*vec2(iResolution.y/iResolution.x,-1.0)*p.xz;\n    return 0.1*(p.y + texture(iChannel0, q+0.5).a);\n}\n\n// Color\nvec3 color(vec3 p) {\n    vec2 q = 0.3*vec2(iResolution.y/iResolution.x,-1.0)*p.xz;\n    return texture(iChannel0, q+0.5).rgb;   \n}\n\nvec3 normal(vec3 p) {\n    float d = sd(p);\n    return normalize(vec3(\n        sd(p+delta.yxx),\n        sd(p+delta.xyx),\n        sd(p+delta.xxy))-d);\n}\n\n// Ray marching: returns ray intersection with the surface\nfloat march(vec3 start, vec3 dir) {\n\tfloat total = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    int i=0;\n    for(; i<200; i++) {\n        if(d<epsilon) break;\n        d = sd(start + total * dir);\n        total += d;\n    }\n    return total;\n}\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    vec3 coef = vec3(1.0);\n\n    int id;\n    float d = march(start, dir);\n\n    vec3 p = start + d * dir;\n\n    // Shading\n    vec3 normal = normal(p);\n    vec3 toEye = normalize(start - p);\n    vec3 toLight = normalize(lightPosition-p);\n\n    // Diffuse\n    vec3 albedo = color(p);\n    vec3 diff = 0.8 * albedo * (ambient + max(dot(toLight, normal), 0.0));\n\n    // Specular\n    vec3 h = normalize(toEye + toLight);\n    float spec = pow(max(dot(h,normal),0.0), 100.0);\n\n    // Reflection of environment\n    vec3 r = reflect(-toEye, normal);\n    vec3 env = texture(iChannel1, r).rgb;\n\n    return diff + reflectivity * (spec + env);\n}\n\nmat3 viewMatrix(vec3 cam, vec3 center, vec3 up) {\n \tvec3 w = normalize(cam-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float elevation = 0.6+0.4*cos(iTime);\n    vec3 cam = vec3(0.3*sin(iTime),sin(elevation),cos(elevation));\n    mat3 m = viewMatrix(cam, vec3(0.0,-0.5,0.0), vec3(0.0,1.0,0.0));\n    \n    vec2 uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    vec3 color = rayColor(cam, dir);\n    \n    // Gamma correction\n    color = pow(color, vec3(0.45));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Computes the depth and color at each point.\n\n// Parameter c of the map z->z^2+c\nconst vec2 c = vec2(0.28,0.603);\n\n// Scaling occurs around focus point\nconst vec2 focus = vec2(-0.00009,-0.10461);\n// Scale parameters\nconst float scalingSpeed = 1.0;\nconst float scalingDepth = 13.0;\n\n// Parameters of the conversion from number of iterations to height\nconst float a = 10.0;\nconst float b = 0.1;\n\n// Coloring parameters\nconst vec3 param1 = vec3(16.0,34.0,52.0);\nconst vec3 param2 = vec3(6.0,10.0,21.0);\nconst vec3 param3 = 0.3*vec3(1.2,1.0,0.95);\n\nconst float PI = 3.141592653589;\n\n// Color depends on the number of iterations\nvec3 color(float n) {\n    vec3 v = cos((n-9.0)*PI/(param1+param2*sin(param3*iTime)));\n    return v*v;\n}\n\n// The map z->z^2+c\nvec2 poly(vec2 p, vec2 c) {\n    return vec2(p.x*p.x-p.y*p.y+c.x, 2.0*p.x*p.y+c.y);\n}\n\n// Returns the continuous number of iterations\n// at point p, for the Julia set with parameter c\nfloat julia(vec2 p, vec2 c) {\n    float i=0.0;\n    float d = length(p);\n    float n = 0.0;\n    for(; i<100.0; i++) {\n        if(d>100.0) break;\n        p = poly(p,c);\n        d = length(p);\n        n += exp(-d);\n    }\n    return n;\n}\n\n// Scaling factor at given time (oscillation)\nfloat scale(float iTime) {\n    float t = scalingSpeed*iTime;\n    t = scalingDepth * 0.5 * (1.0-cos(PI*t/scalingDepth));\n    return 5.0*exp(-t);\n}\n\n// Converts the number of iterations into a depth\nfloat depth(float n) {\n    return 0.6/(1.0+exp(b*(a-n)));\n}\n\n// Computes the heightmap of the 3D Julia set\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float scale = scale(iTime);\n    p = focus + scale * p;\n\n    float n = julia(p,c);\n    \n    float d = depth(n);\n    \n    fragColor = vec4(color(n),d);\n}","name":"Buffer A","description":"","type":"buffer"}]}