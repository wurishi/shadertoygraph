{"ver":"0.1","info":{"id":"Wtl3R8","date":"1557418235","viewed":116,"name":"Beto produit scalaire 3D boule","username":"msafadi","description":"beto https://www.shadertoy.com/view/3tXGRr","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["beto"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GLASS = 1.5;\nconst float WATER = 1.33;\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nvec4 getDecor(in vec3 ray) {\n    float \tanim = iTime * 0.1;\n\tmat3 \trotY = mat3(vec3(cos(anim), 0.0, sin(anim)), vec3(0.0,1.0,0.0), vec3(-sin(anim), 0.0, cos(anim)));\n    return texture(iChannel1, ray * rotY);\n}\n\n//////////////////////////////////////////////////////////////////////\n// EXERCICE : CALCULER LE RENDU D'UNE BOULE DE VERRE PLEINE !\n//////////////////////////////////////////////////////////////////////\n\n\nvec4 render(in vec3 ray, in vec3 m, in Sphere sphere, in vec3 normal, in vec3 light) {\n    vec3 i1 = refract(ray, normal, 1./GLASS);\n    float l = 2. * abs(dot(i1, sphere.center - m));\n    vec3 m2 = m + i1 * l;\n    vec3 i2 = refract(i1, -normalize(m2 - sphere.center), GLASS);\n\treturn getDecor(i2);\n}\n\n//////////////////////////////////////////////////////////////////////\n// PRIVATE\n//////////////////////////////////////////////////////////////////////\n\nconst float zNear = 1.0;\nconst float zFar  = 400.0;\n\nfloat map(in vec3 m, in Sphere sphere) {\n    return length(m - sphere.center) - sphere.radius;\n}\n\nbool rayMarching(in vec3 ray, out vec3 m, in Sphere sphere) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<50; i++) {\n        \n        m = ray * marchingDist;    \n        \n    \tfloat dist = map(m, sphere);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\nvec3 computeNormal(in vec3 m, in Sphere sphere) {\n\treturn normalize(m - sphere.center);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec2 \tviewportCoord \t= vec2(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5));\n\n\n    vec3\tray\t\t\t\t= normalize(vec3(viewportCoord, zNear));    \n    \n    vec3\tlight\t\t\t= vec3(5.0*cos(iTime*0.5), 3.0, 0.0);\n    vec3\tm;\n\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 8.0), 2.0);\n    \n    vec4 test = getDecor(ray);\n    \n    if(rayMarching(ray, m, sphere)) {\n        vec3 normal = computeNormal(m, sphere);\n\t\tfragColor = render(ray, m, sphere, normal, light);\n    }\n    else {\n        \n        float videoRatio = 352.0/288.0;\n        \n        if(abs(viewportCoord.x)<videoRatio*0.5) {\n            vec2 uv = (viewportCoord * vec2(1.0/videoRatio, 1.0)) + 0.5;\n            fragColor = texture(iChannel0, uv);\n        }\n        else {\n            fragColor = vec4(0.0, 0.6, 0.0, 1.0);\n        }\n        \n        fragColor = test;\n    }\n}\n    \n\n","name":"Image","description":"","type":"image"}]}