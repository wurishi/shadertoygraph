{"ver":"0.1","info":{"id":"wdjyWy","date":"1588420289","viewed":269,"name":"Atomic Donut","username":"shau","description":"Music Doodle","likes":14,"published":1,"flags":96,"usePreview":0,"tags":["3d","soundcloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n * inspired by video for Defection by Current (sort of)\n * https://youtu.be/F4Y46_QVmC8?t=63\n * Thanks to Jeyko for pointing me to this video\n */\n\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define EPS .005\n#define FAR 20.\n#define T iTime\n#define PI 3.141592\n#define S(a, b, v) smoothstep(a, b, v)\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins - improved hash without sin\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//Shane IQ\nfloat n3D(vec3 p) \n{    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0.,s.yz,s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h)*43758.5453),fract(sin(h + s.x)*43758.5453),p.x);\n    h.xy = mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796,0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr,0.,1.);\n}\n\n//SDFs IQ\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) \n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) \n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc,rd),\n          c = dot(oc,oc) - sph.w*sph.w,\n          h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    float tN = -b - h,\n          tF = -b + h;\n    return vec2(tN, tF);\n}\n\n// see mercury sdf functions\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n    float angle = 2.0 * PI / repetitions,\n          a = atan(p.y, p.x) + angle / 2.0,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nvec4 dfArm(vec3 p)\n{\n    vec4 snd = texture(iChannel1,vec2(0.5)/R);\n    p.x -= 1.6;\n    float t = length(p) - 0.7;\n    p.xy *= rot(sin(T*.3)*0.6);\n    p.xz *= rot(T*0.4);\n    float la = 0.9 + sin((T+PI)*0.4)*0.4,\n          l = pModPolar(p.xz,5.0);\n    p.xy *= rot(l*0.4);\n    t = min(t, sdRoundBox(p - vec3(0.5,0.0,0.0), vec3(0.5,0.2,0.2), 0.1));\n    float t2 = sdCappedCylinder(p - vec3(la+0.2,0.0,0.0), 0.1, la),\n          cx = S(0.04,0.0,abs(p.y)) + S(0.04,0.0,abs(p.x)) + S(0.04,0.0,abs(p.z));\n    t += cx*0.01;\n    return vec4(min(t,t2),1.0+step(t2,t),l,cx);\n}\n\nvec4 map(vec3 p) \n{\n    vec4 s = vec4(FAR,0.0,0.0,0.0);\n    p.xy *= rot(T*0.2 + S(0.2,0.4,sin(T*0.2))*2.0);\n    p.yz *= rot(T*0.4 + S(-0.2,0.1,sin(T*0.09))*4.0);\n    for (int i=ZERO; i<16; i++)\n    {\n        p.xy *= rot(PI/8.0);\n        vec4 ns = dfArm(p);\n        s = ns.x<s.x ? ns : s;\n    }\n    return s;\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 8.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\nvec3 background(vec3 rd, vec3 colA, vec3 colB)\n{\n    float a = (atan(rd.x, rd.y)/6.2831853) + 0.5,\n          l = floor(a * 24.0) / 24.0;   \n    vec3 pc = colB * 2.0 *\n              S(0.46, 0.5, fract(a*24.0)) * S(0.54, 0.5, fract(a*24.0));\n    float dY = pow(abs(rd.y), 0.8),\n          cY = fract(dY*6.0-T*0.4),\n          cYID = floor(dY*6.0-T*0.4),\n          cYH = hash11(cYID) - 0.6,    \n          tt = mod(T*cYH*4.0*sign(rd.y), 3.0) - 1.5,\n          dX = length(tt - rd.x);\n    pc += colB * 1.6 * S(0.02, 0.0, length(cY - 0.5));\n    pc *= (2.0 +n3D(rd*3.6+T)) * n3D(rd*5.0+T*0.3);\n    pc += (cYH*sign(-rd.y)>0.0 ? step(tt, rd.x) : step(rd.x, tt)) *\n          colA * 6.0 * S(0.05, 0.0, length(cY - 0.5)) / \n          (1.0 + dX*dX*60.); \n    pc *= max(abs(rd.y*0.4), 0.);\n    return pc + colB / ((1.0 + abs(rd.x)*abs(rd.x)*8.0) * (1.0 + dY*dY*100.0));\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec4 s = vec4(0),\n         snd = texture(iChannel1,vec2(0.5)/R);\n    vec3 la = vec3(0),\n         lp = vec3(5,8,-3),\n         ro = vec3(0,sin(T*0.1)*3.0,-5.0 - sin(T*0.31)*1.4 - S(-0.7,-0.4,cos(T*0.05-2.0))*2.0),\n         c1 = rotHue(vec3(0.9,0.2,0.1), T*0.3+pow(snd.y*1.2,6.0)),\n         c2 = rotHue(vec3(0.9,0.5,0.1), T*0.3+pow(snd.z*1.2,6.0));\n    //camera\n    float fl = 1.8 - S(0.5,0.7,sin((T-2.0)*0.07)),\n          t = 0.0;\n    ro.xz *= rot(T*0.5 + 2.0*S(0.4,0.7,cos(T*0.13)));\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x)),\n         rd = normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt)),    \n         pc = background(rd,c2,c1);    \n    //ray marching\n    vec2 b = sphIntersect(ro,rd,vec4(0.0,0.0,0.0,4.4));\n    if (b.x>0. || b.y>0.0)\n    {\n        t += max(0.0,b.x);\n        for (int i=ZERO; i<100; i++) \n        {\n            s = map(ro + rd*t);\n            if (abs(s.x)<EPS) break;\n            t += s.x;\n            if (t>FAR)\n            {\n                t = -1.0;\n                break;\n            }\n        }\n    }\n    //shade\n    if (t>0.0) {\n        vec3 p = ro + rd*t,\n             n = normal(p),\n             rrd = reflect(rd,n),\n             bc = background(rrd,c2,c1),\n             ld = normalize(lp - p);\n        float spec = pow(max(dot(reflect(-ld,n),-rd),0.0),16.0),\n              frs = 1.0 - pow(clamp(dot(n, rd) + 1.,0.,1.),2.),\n              ao = AO(p,n);\n        if (s.y==1.0) \n        {\n            pc = s.w*3.0 * ((mod(s.z,2.0)>0.0) ? c1*snd.y : c2*snd.z);\n            pc += bc*frs*0.4;\n            pc += vec3(1)*spec;\n        }\n        if (s.y==2.0) \n        {\n            pc = vec3(0.2)*max(0.05,dot(ld,n));\n            pc += texture(iChannel0,rrd).xyz*frs;\n            pc += bc*frs;\n            pc += vec3(0.7,0.7,1)*spec;\n\n        }   \n        pc += vec3(0.0,0.1,0.2)*0.4*max(0.0,n.y);\n        pc *= ao;\n    }\n    pc /= (1.0 + length(uv)*length(uv)*3.);\n    C = vec4(pc,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XljGWw","filepath":"https://soundcloud.com/countzerointerupt/oh-yeah-house-remix","previewfilepath":"https://soundcloud.com/countzerointerupt/oh-yeah-house-remix","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 currentSound = texture(iChannel0, uv / iResolution.xy);\n    \n    float level = currentSound.x;\n    float bass = currentSound.y;\n    float mid = currentSound.z;\n    float treble = currentSound.w;\n    \n    for (int x = 0; x < 512; x++) {\n        vec4 newSound = texelFetch(iChannel1, ivec2(x , 0), 0);\n        level += newSound.x;\n        if (x < 140) bass += newSound.x;\n        if (x > 139 && x < 300) mid += newSound.x;\n        if (x > 299) treble += newSound.x;\n    }\n    \n    level /= 60.0;\n    bass /= 60.0;\n    mid /= 20.0;\n    treble /= 36.0;\n    \n    fragColor = vec4(level, bass, mid, treble);    \n}","name":"Buffer A","description":"","type":"buffer"}]}