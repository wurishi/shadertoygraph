{"ver":"0.1","info":{"id":"WtccDn","date":"1608761505","viewed":70,"name":"masking effects (vlllll)","username":"valalalalala","description":"Playing around with some different filters to mask color in different ways. \n\n","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["raymarching","filters","masks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////\n//\n// \"Marching with Camera\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// starting from https://www.shadertoy.com/view/tsyfDw\n//\n// Largely inspired by https://iquilezles.org/articles/checkerfiltering\n//\n/////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////////////\n// shader specific controls\n\n// When true, the filter is picked based on mouse.x and the orientation by mouse.y\nbool DEMO_MODE = true; // toggled with space key\n\nbool CAMERA_MOUSE = false;\n\n/////////////////////////////////////////////////////////////////////////////\n// ray marching values\n\n#define RAY_MARCH_STEPS    99\n#define RAY_MARCH_TOO_FAR  float( RAY_MARCH_STEPS )\n#define RAY_MARCH_CLOSE    0.004\n#define RAY_EPSILON        vec2( RAY_MARCH_CLOSE, .0 )\n\n/////////////////////////////////////////////////////////////////////////////\n// anti-aliasing\n\n#define ANTI_ALIAS_STEPS    3\n#define ANTI_ALIAS_DISTANCE 2.\n\n/////////////////////////////////////////////////////////////////////////////\n// useful constants and macros\n\n#define PI2             6.283185307179586\n#define TRIG(d, a)      ( d * vec2( cos( a ), sin( a ) ) )\n#define RGB(r,g,b)      vec3( float(r)/255., float(g)/255., float(b)/255. )\n#define MAX3(v)         max( v.x, max( v.y, v.z ) ) \n#define EQUALS(a,b)     step( a-1e-11, b ) * step( b-1e-11, a )\n\n/////////////////////////////////////////////////////////////////////////////\n// fun with masking\n\n#define SCALE 1.\n\nfloat mesh( vec2 p ) {\n    p = fract( SCALE * p );\n    return smoothstep( .0, .1,  p.x * p.y );\n}\n\nfloat tooth( vec2 p ) {\n    p = fract( SCALE * p );\n    return smoothstep( .9, .4, min(p.x,p.y) / max(p.x,p.y) );\n}\n\nfloat check( in vec2 p ) {\n    vec2 s = sign(fract(p*.5)-.5);\n    return .5 - .5*s.x*s.y;\n}\n\nfloat triangle( in vec2 p ) {\n    p = fract( SCALE * p );\n    return p.x + p.y;\n}\n\nfloat seed( in vec2 p ) {\n    p = fract( SCALE * p );\n    return abs( p.y - p.x );\n}\n\nfloat dark( in vec2 p ) {\n    p = fract( SCALE * p );\n    return p.y - p.x;\n}\n\nfloat emboss( in vec2 p ) {\n    p = fract( SCALE * p );\n    return ( cos( p.x ) + sin( p.y ) +2. ) / 4.;\n}\n\nfloat sechs( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = abs( cos( p.x - p.y ) );\n    return smoothstep( .88, .89, f );\n}\n\nfloat linx( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = ( cos( p.x - p.y ) ) * .91;\n    return smoothstep( .79, .80, f ) - smoothstep( .82, .83, f );\n}\n\nfloat dashes( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = ( cos( p.x - p.y ) );\n    return smoothstep( .95, .96, f ) - smoothstep( .97, .98,  f );\n}\n\nfloat ells( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = ( cos( max(p.x,p.y) ) );\n    return smoothstep( .5, .61, f ) - smoothstep( .7, .71, f );\n}\n\nfloat grid( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = abs( max(p.x,p.y ) );\n    return smoothstep( .92, .93, f );\n}\n\nfloat idk( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = ( cos( max(p.x,p.y) ) );\n    return smoothstep( .5, .71, f ) - smoothstep( .96, .951, f );\n    return smoothstep( .5, .66, f );\n}\n//\n\nfloat mask( in vec3 point, in vec2 control ) {\n    //return idk( point.xz );\n    \n    float orientation = floor( control.y * 8. );\n    \n    vec2 oz = point.xz;\n    oz += point.xx * EQUALS( 0., orientation );\n    oz += point.xy * EQUALS( 1., orientation );\n    oz += point.xz * EQUALS( 2., orientation );\n    \n    oz += point.yy * EQUALS( 3., orientation );\n    oz += point.yx * EQUALS( 4., orientation );\n    oz += point.yz * EQUALS( 5., orientation );   \n    \n    oz += point.zz * EQUALS( 6., orientation );\n    oz += point.zx * EQUALS( 7., orientation );\n    oz += point.zy * EQUALS( 8., orientation );   \n    \n    float which = floor( control.x * 11. );\n\n    float masked = .0;\n    \n#if 1\n    masked += mesh( oz )     * EQUALS( 0., which );\n    masked += tooth( oz )    * EQUALS( 1., which );\n    masked += check( oz )    * EQUALS( 2., which );\n    masked += triangle( oz ) * EQUALS( 3., which );\n    masked += seed( oz )     * EQUALS( 4., which );\n    masked += dark( oz )     * EQUALS( 5., which );\n    masked += emboss( oz )   * EQUALS( 6., which );\n    masked += linx( oz )     * EQUALS( 7., which );\n    masked += dashes( oz )   * EQUALS( 8., which );\n    masked += ells( oz )     * EQUALS( 9., which );\n    masked += sechs( oz )    * EQUALS( 10., which );\n    masked += grid( oz )     * EQUALS( 11., which );\n#else\n    switch( int( which ) ) {\n        case 0:    masked = mesh( oz )     ; break;\n        case 1:    masked = tooth( oz )    ; break;\n        case 2:    masked = check( oz )    ; break;\n        case 3:    masked = triangle( oz ) ; break;\n        case 4:    masked = seed( oz )     ; break;\n        case 5:    masked = dark( oz )     ; break;\n        case 6:    masked = emboss( oz )   ; break;\n        case 7:    masked = linx( oz )     ; break;\n        case 8:    masked = dashes( oz )   ; break;\n        case 9:    masked = ells( oz )     ; break;\n        case 10:   masked = sechs( oz )    ; break;\n        case 11:   masked = grid( oz )     ; break;\n     }\n#endif\n    \n    return clamp( masked, .0, 1. ) + .1; // avoid total darkness\n}\n\nfloat mask( in vec3 point ) {\n    return DEMO_MODE \n    ? mask( point, .5 + TRIG( .5, iTime * .05 ) )\n    : mask( point, iMouse.xy / iResolution.xy );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// signed distance functions for types\n\nfloat sdSphere( in vec3 point, in float radius ) {\n    return length( point ) - radius;\n}\n\nfloat sdBox( in vec3 point, in vec3 size ) {\n    return MAX3( ( abs( point ) - size ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// create the scene\n\n#define BALL   1.\n#define BOX    2.\n#define BACK   3.\n#define FRONT  4.\n\n#define TOP    5.\n#define FLOOR  6.\n#define LEFT   7.\n#define RIGHT  8.\n\nvec2 which( in vec2 current, in float test, in float what ) {\n    current.y = mix( current.y, what, step( test, current.x ) );\n    current.x = min( current.x, test );\n    return current;\n}\n\nfloat box( in vec3 point ) {\n    return sdBox( point - vec3( 3., .1, 3.) , vec3( 1. ) );\n}\n\nfloat boxm( in vec3 point, float m ) {\n    return sdBox( point - vec3( 3., .1, -3. ), vec3( 1. ) ) - m;\n}\n\nfloat ball( in vec3 point ) {\n    return sdSphere( point + vec3( 3., -.5, 3. ), 1.33 );\n}\n\nfloat ballm( in vec3 point, float m ) {\n    return sdSphere( point + vec3( 3., -.5, -3. ), 1.33 ) - m;\n}\n\nvec2 sceneDistance( in vec3 point ) {\n    float w = 8.;\n    float h = w * 2. / 3.;\n    \n    float m = mask( point ) * .33; \n    \n    vec2 closest = vec2( RAY_MARCH_TOO_FAR );\n    \n    closest = which( closest, box( point ),  BOX );\n    closest = which( closest, ball( point ), BALL );\n\n    closest = which( closest, boxm( point, m ),  BOX );\n    closest = which( closest, ballm( point, m ), BALL );\n    \n    closest = which( closest, point.z + w,   BACK );\n    closest = which( closest, w - point.z,   FRONT );\n\n    closest = which( closest, h - point.y,   TOP );\n    closest = which( closest, point.y +1.,  FLOOR );\n    \n    closest = which( closest, point.x + w,   LEFT );\n    closest = which( closest, w - point.x,   RIGHT );\n    \n    return closest;\n}\n\n\nvec3 colorAt( in vec3 point, vec2 d ) {\n    vec3 color = vec3( .0 );\n  \n    color += RGB( 255,  33,  33 ) * EQUALS( d.y, BALL   );\n    color += RGB(  33, 255,  33 ) * EQUALS( d.y, BOX    );\n    color += RGB(  33,  33, 255 ) * EQUALS( d.y, BACK   );\n    \n    color += RGB( 255, 255,  33 ) * EQUALS( d.y, FRONT  );\n    color += RGB(  33, 255, 255 ) * EQUALS( d.y, TOP    );\n    color += RGB( 255,  33, 255 ) * EQUALS( d.y, FLOOR  );\n    \n    color += RGB( 255, 210, 120 ) * EQUALS( d.y, LEFT   );\n    color += RGB( 120, 210, 255 ) * EQUALS( d.y, RIGHT  );\n    \n    color *= mask( point );\n\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// the ray marching bits\n\n#define THANKS_SHANE_FOR_THE_RAY_SHORTENING_SUGGESTION\nvec2 rayMarch( in vec3 origin, in vec3 direction ) {\n    vec2 total = vec2(.0);\n    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {\n        vec3 point = origin + direction * total.x;        \n\n        vec2 current = sceneDistance( point );\n\n#ifdef THANKS_SHANE_FOR_THE_RAY_SHORTENING_SUGGESTION\n        if ( total.x > RAY_MARCH_TOO_FAR || current.x < RAY_MARCH_CLOSE ) {\n            break;\n        }\n        // Note: Ray advancement occurs after checking for a surface hit.\n        //\n        // Ray shortening: Shorter for the first few iterations.\n        total.x += i<32? current.x*.35 : current.x*.85; \n        total.y = current.y;\n#else\n        total.x += current.x;\n        total.y = current.y;\n\n        if ( total.x > RAY_MARCH_TOO_FAR || current.x < RAY_MARCH_CLOSE ) {\n            break;\n        }     \n#endif\n    }\n    return total;\n}\n\nvec3 sceneNormal( in vec3 point ) {\n    return normalize( sceneDistance( point ).x - vec3(\n        sceneDistance( point - RAY_EPSILON.xyy ).x,\n        sceneDistance( point - RAY_EPSILON.yxy ).x,\n        sceneDistance( point - RAY_EPSILON.yyx ).x\n    ));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// lighting\n\nfloat pointLight( vec3 point, vec4 light ) {\n    vec3 normal = sceneNormal( point );\n    \n    vec3 towardLight = light.xyz - point;\n    float toLight = length( towardLight );\n    towardLight = normalize( light.xyz - point );\n\n    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );\n    \n    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    float d = rayMarch( lightStart, towardLight ).x;\n    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );\n\n    float lightStrength = .7 + .3 * light.w / dot( toLight, toLight );  \n    return diffuse * lightStrength;\n}\n\nvec3 colorPoint( vec3 point, vec2 d ) {\n    vec2 T = TRIG(2.,iTime);\n    vec4 light    = vec4( T.x, 3., T.y, 3. );\n    float ambient = 0.307;\n    float gamma   = 1.33;\n    \n    float lighting = pointLight( point, light );\n    lighting = ( 1. -  ambient ) * gamma * lighting;\n\n    vec3 color = colorAt( point, d );\n\treturn vec3( color * ambient + color * lighting );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// simple camera\n\nstruct Ray {\n    vec3 eye;\n    vec3 direction;\n};\n\n// from https://github.com/glslify/glsl-look-at\nmat3 makeCamera( vec3 origin, vec3 target, float roll ) {\n\tvec3 up = vec3( sin( roll ), cos( roll ), .0 );\n\tvec3 zz = normalize( target - origin );\n\tvec3 xx = normalize( cross( zz, up ) );\n\tvec3 yy = normalize( cross( xx, zz ) );\n\treturn mat3( xx, yy, zz );\n}\n\nRay cameraRay( in vec2 uv ) {\n    vec3 eye, look;\n    float zoom, roll;\n    if ( CAMERA_MOUSE ) {\n        vec2 mx = ( iMouse.xy / iResolution.xy ) -.5;\n        vec2 T = TRIG( 4., mx.x * PI2 );\n        \n        eye  = vec3( T.x, mx.y * 6. + 1. , T.y );\n        look = vec3( 0. );\n    \n        zoom = 1.;\n        roll = .0;\n    } else {\n        vec2 T = TRIG( 1., iTime * .1 );\n    \n        eye  = vec3( 6. * T.x, 2., 6. * T.y );\n        look = vec3( .0, 0, .0 );\n    \n        roll = 0.2 * T.x;\n        zoom = 1. + .25 * abs( sin( iTime * .66 ) );\n    }\n    \n\tmat3 camera = makeCamera( eye, look, roll );\n    vec3 direction = normalize( camera * vec3( uv.xy, zoom ) );\n \n    return Ray( eye, direction );\n}\n\n// from https://www.shadertoy.com/view/4dsGRl\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = textureLod( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// main function\n\nvec3 mainly( in vec2 fragCoord ) {\n\t//vec2 uv = ( 2. * gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n\n    \n    Ray ray = cameraRay( uv );\n    vec2 d = rayMarch( ray.eye, ray.direction );\n    float missed = step( RAY_MARCH_TOO_FAR, d.x );\n    \n    vec3 point = ray.eye + ray.direction * d.x;\n        \n    vec3 background = vec3( 3.6 );\n    vec3 color = colorPoint( point, d );\n    \n    return mix( color, background, missed );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tDEMO_MODE = ReadKey( 32, true );\n    CAMERA_MOUSE = ReadKey( 13, true );\n\n    \n#if ANTI_ALIAS_STEPS == 1\n    fragColor = vec4( mainly( fragCoord ) , 1. );\n#else\n    vec3 color = vec3( .0 );\n    float a = ANTI_ALIAS_DISTANCE / float( ANTI_ALIAS_STEPS );\n    \n    for ( int y = 0 ; y < ANTI_ALIAS_STEPS ; y++ ) {\n        float ya = float( y ) * a; \n        for ( int x = 0 ; x < ANTI_ALIAS_STEPS ; x++ ) {\n            vec2 aa = vec2( float( x ) * a, ya );          \n            color += mainly( fragCoord + aa );\n        }\n    }\n    fragColor = vec4( color / float( ANTI_ALIAS_STEPS * ANTI_ALIAS_STEPS ), 1. );\n       \n#endif\n}\n\n// EOF\n/////////////////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"}]}