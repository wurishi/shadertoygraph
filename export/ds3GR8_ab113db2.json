{"ver":"0.1","info":{"id":"ds3GR8","date":"1676951141","viewed":133,"name":"Skateboard fun","username":"ianertson","description":"Look around with the mouse :)","likes":16,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","ray","raymarch","sdf","rays","raytrace","lights","skateboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\nvec3 getSmooth(vec2 uv, float f) {    \n    vec2 dx = dFdx(uv)*(4.+f);\n    vec2 dy = dFdy(uv)*(4.+f);\n    vec2 dir1x = vec2(1, 0) * dx;\n    vec2 dir1y = vec2(1, 1) * dy;\n    \n    vec2 dir2x = vec2(1, 1) * dx;\n    vec2 dir2y = vec2(0, 1) * dy;\n\n    vec3 a = textureGrad(iChannel0, uv, dir1x, dir1y).rgb;\n    vec3 b = textureGrad(iChannel0, uv, dir2x, dir2y).rgb;\n    \n    return mix(a, b, 0.5);\n}\n\nfloat estimateNoise(vec3 col, vec2 uv) {\n    vec2 e = vec2(1.0) / R.xy;\n    vec3 a = vec3(\n        luma(getColor(uv + vec2(e.x, 0))),\n        luma(getColor(uv + vec2(0, e.y))),\n        luma(getColor(uv + vec2(e.x, e.y)))\n    );\n    \n    float l = luma(col);\n    float n1 = abs(l - ((a.x+a.y+a.z)/3.));\n    float n2 = abs(a.x - a.y);\n    float n3 = abs(a.x - a.z);\n    float n4 = abs(a.y - a.z);\n    float n5 = fwidth(l);\n    \n    float n = (n1+n2+n3+n4+n5)/5.0;\n    return clamp(n*M_PI, 0.0, 1.0);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n    float noiseEst = estimateNoise(col, uv);\n    \n    vec3 smoothCol = getSmooth(uv, depth*2.);\n    \n    float bright = luma(col);\n    \n    col = mix(col, smoothCol, clamp(noiseEst+(bright*0.5), 0.0, 0.6));\n    col = mix(col, smoothCol, clamp((depth*(0.06+depth))*10., 0.0, 0.79));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T ((iFrame <= 1 || iTime <= 0.00001) ? 105.44 : iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define IDQ vec4(0, 0, 0, 1)\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (var < dist) { data.id = id_; dist = var; data.o = o; } else { data.o.m = mat4(1.0); data.o.pos = vec3(0.0); data.o.q = IDQ; }\n#define TEXTURE_SIGNATURE in vec2 uv, inout Material m\n\n#define EST_NORM_FOR(TEXFUNC, UV, N, M, COMPFUNC, CLR, MIX, VAR)\\\n{\\\n    float a = COMPFUNC(CLR);\\\n    float e = fwidth(a);\\\n    VAR = fixNormal(N, normalize(a - vec3(\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, 0), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(0, e), M)),\\\n        COMPFUNC(TEXFUNC(UV + vec2(e, e), M))\\\n    )), MIX);\\\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(0.01, dot(wn, n))));\n}\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nstruct Material {\n    float rough;\n    float spec;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0)\n\nstruct Object {\n    vec3 pos;\n    mat4 m;\n    vec4 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), mat4(1.0), IDQ)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    Material m;\n    Object o;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, NEW_MATERIAL, NEW_OBJECT)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = cdot(n, L);\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: {\n            float d = distance(light.p, p);\n            return light.c * NdotL * (pow(light.s, 2.0) / max(0.001, pow(d, 2.0)));\n        }; break;\n        case LIGHT_DIR: {\n            vec3 ld = normalize(light.d);\n            vec3 sd = normalize(light.p - p);\n            float cone = dot(sd, ld);\n            const float cutoff = 0.7;\n            return light.c * NdotL  * light.s * smoothstep(cutoff, 1.0, cone);\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(vec3 p, vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n    uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n    uv = mix(uv, p.yz, adot(n, vec3(1, 0, 0)));\n    return uv;\n}\n\nvec2 uvSphere(vec3 p) {\n    p = normalize(p);\n    vec2 uv = vec2(acos(p.x), atan(p.y, p.z));// * 2.0 - 1.0;\n    uv = vec2(0.5 + uv.x / TAU, 0.5 - uv.y / TAU);\n    return uv;\n}\n\n\nmat4 quatMat(vec4 q)\n{\n    float xx = q.x * q.x;\n    float xy = q.x * q.y;\n    float xz = q.x * q.z;\n    float xw = q.x * q.w;\n\n    float yy = q.y * q.y;\n    float yz = q.y * q.z;\n    float yw = q.y * q.w;\n\n    float zz = q.z * q.z;\n    float zw = q.z * q.w;\n\n    mat4 result = mat4(1.0);\n    result[0][0] = 1.0 - 2.0 * (yy + zz);\n    result[1][0] = 2.0 * (xy - zw);\n    result[2][0] = 2.0 * (xz + yw);\n    result[3][0] = 0.0;\n\n    result[0][1] = 2.0 * (xy + zw);\n    result[1][1] = 1.0 - 2.0 * (xx + zz);\n    result[2][1] = 2.0 * (yz - xw);\n    result[3][1] = 0.0;\n\n    result[0][2] = 2.0 * (xz - yw);\n    result[1][2] = 2.0 * (yz + xw);\n    result[2][2] = 1.0 - 2.0 * (xx + yy);\n    result[3][2] = 0.0;\n\n    result[0][3] = 0.0;\n    result[1][3] = 0.0;\n    result[2][3] = 0.0;\n    result[3][3] = 1.0;\n\n    return result;\n}\n\nvec3 pointQuat(vec3 v, vec4 q){ \n\treturn v + 2.0*cross(cross(v, q.xyz ) + q.w*v, q.xyz);\n}\n\n\nvec4 quatFor(vec3 dir, vec3 up)\n{\n    if (abs(length(dir)) <= 0.0000001) return IDQ;\n    vec3 axis = normalize(cross(up, dir));\n    float angle = acos(dot(dir, up));\n    float halfAngle = angle * 0.5;\n    float s = sin(halfAngle);\n    vec4 q = vec4(axis * s, cos(halfAngle));\n    return normalize(q);\n}\n\nvec4 quatMul(vec4 q1, vec4 q2) {\n    vec4 q = IDQ;\n    q.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    q.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    q.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    q.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return q;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 pointMat(vec3 p, mat4 m) {\n    return (vec4(p, 1.0) * m).xyz;\n}\n\nfloat onCycle(float from, float to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n\nvec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n\nvec4 onCycle(vec4 from, vec4 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return normalize(mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle)));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\n\nvec3 texHash33(sampler2D ch, vec3 p, float div, float seed, vec2 lod) {\n    return textureLod(ch, (vec2(p.x, p.y) +\n        div*(textureLod(ch, (vec2((p.y*p.z), p.z)+seed)/div, lod.x).xy*2.0-1.0))/div, lod.y).xyz;\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float seed, vec2 lod) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n\n    float div = vec2(textureSize(tex, 0).xy).y;\n\n    return mix(\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 0), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 0), div, seed, lod), lv.x),\n          lv.y),\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 1), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 1), div, seed, lod), lv.x),\n          lv.y),\n        lv.z\n    );\n}\n\nvec3 uniformSampleHemisphere(float r1, float r2)\n{\n    float theta = sqrt(1. - r1 * r1);\n    float phi = 2. * M_PI * r2;\n    return vec3(cos(phi) * theta, r1, sin(phi) * theta);\n}\n\nvec3 createCoordinateSystem(vec3 N, inout vec3 Nt)\n{\n    if (abs(N.x) > abs(N.y)) {\n        Nt = vec3(N.z, 0, -N.x) / sqrt(N.x * N.x + N.z * N.z);\n    } else {\n        Nt = vec3(0, -N.z, N.y) / sqrt(N.y * N.y + N.z * N.z);\n    }\n    return cross(N, Nt);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 fc )\n{\n    vec4 col = vec4(0.0);\n    vec2 uv = fc/R.xy;\n    \n    ivec2 C = ivec2(fc);\n    \n    switch (int(fc.x)) {\n        case 0: {\n            vec4 oldMouse = texelFetch(iChannel0, ivec2(0), 0);\n            vec4 nextMouse = iMouse;\n            col = mix(oldMouse, nextMouse, 0.33);\n        }; break;\n\n    }\n    \n    O = col;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_SKATE_BOARD 3\n#define ID_SKATE_WHEEL 4\n#define ID_SKATE_TRUCK 5\n#define ID_LAMP_POLE 6\n#define ID_LAMP_CONTAINER 7\n#define ID_LAMP_BULB 8\n\n#define BULB_POS vec3(0.45, 2.52, 0.0)\n\nvec4 getMouse() { return texelFetch(iChannel0, ivec2(0), 0); }\n\nObject getSkateBoard() {\n    Object o;\n    o.m = mat4(1.0);\n    vec3 origin = vec3(0., 0.22, 0.);\n    vec3 pos = origin;\n    vec4 q = IDQ;\n    vec4 q2 = IDQ;\n\n    vec3 originalVel = vec3(cos(T), 0, sin(T));\n    \n    vec3 vel = originalVel;\n    \n    float time = T;\n    float nrSteps = 4.0;\n    float transTime = 0.9;\n    float frame = 1.0;\n    \n\n    vel = onCycle(vel, originalVel, time, nrSteps, transTime, frame);\n    q2 = onCycle(q2, IDQ, time, nrSteps, transTime, frame);\n    frame += 1.0;\n\n    vel = onCycle(vel, vel + vec3(0, 1., 0), time, nrSteps, transTime, frame);\n    q2 = onCycle(q2, vec4(radians(180.), 0, 0, -radians(180.0)), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    vel = onCycle(vel, originalVel, time, nrSteps, transTime, frame);\n    q2 = onCycle(q2, vec4(radians(0.), 0, 0, q2.w), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    vel = onCycle(vel, originalVel, time, nrSteps, transTime, frame);\n    q2 = onCycle(q2, IDQ, time, nrSteps, transTime, frame);\n    frame += 1.0;\n\n    \n    \n    q2 = normalize(q2);\n    q = quatFor(vec3(originalVel.x, 0.0, originalVel.z), vec3(0, 0, 1));\n\n    pos += vel * M_PI;\n    pos.y = max(0.22, pos.y);\n   \n\n    q = quatMul(q, q2);\n    q = normalize(q);\n    \n    o.pos = pos;\n    o.m = quatMat(q);\n    o.q = q;\n    return o;\n}\n\nvec3 noise(in vec2 p, in float seed) {\n    p = ((p+seed)/256.0);\n    return textureLod(iChannel3, p, 0.0).xyz;\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV; \n    #undef ADV\n    return n / div;\n}\n\nvec3 noise6(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV; ADV; ADV;\n    #undef ADV\n    return n / div;\n}\n\nvec3 randDir(in vec3 n, in vec3 p, in float seed, in float freq) {\n    p *= freq;\n    vec3 a = texNoise(iChannel3, p, seed, vec2(0.0));\n\n    \n    float j = fract(10.238912*dot(p, vec3(3.281283, a.x, 43.29315)));\n    float k = fract(10.118231*dot(p, vec3(j*10.238154, a.y, 3.2823156)));\n\n    vec3 samp = uniformSampleHemisphere(a.x, a.y);\n    \n    vec3 Nt = vec3(0);\n    vec3 Nb = createCoordinateSystem(n, Nt);\n\n\n\n    vec3 dir = vec3(\n      samp.x * Nb.x + samp.y * n.x + samp.z * Nt.x,\n      samp.x * Nb.y + samp.y * n.y + samp.z * Nt.y,\n      samp.x * Nb.z + samp.y * n.z + samp.z * Nt.z\n    );\n\n    return normalize(dir);\n    //return normalize(cross(a, b));\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat groundSDF(in vec3 p) {\n    vec3 n = noise6(p.xz, 3.2815, 0.2);\n    vec3 n2 = noise6(p.zx, 7.7754, 1.);\n    float m = pow(n.y, 2.0)*2.0;\n    \n    float h = n.x + m;\n    \n    h *= 2.0*clamp(smoothstep(3.0, 16.0, distance(p.xz, vec2(0, 0))), 0.0, 1.0);\n    h -= (n2.y*0.09*n2.x) * clamp(distance(p.xz, vec2(0.0)), 0.0, 2.0);\n    \n    return p.y - h;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float t) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h)-t;\n}\n\nfloat sdist(vec3 a, vec3 b) {\n    vec3 di = ((a) - (b));\n    \n    return (dot(di, di));\n}\n\nfloat cylFlatSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    \n    return e + i;\n}\n\nfloat skateSDF(in vec3 p, inout int part, inout Object o, Object skateBoard) {\n   \n    p -= skateBoard.pos;\n    p = pointQuat(p, skateBoard.q);//pointMat(p, skateBoard.m);\n    o.m = skateBoard.m;\n    o.q = skateBoard.q;\n    o.pos = skateBoard.pos;\n\n    part = ID_SKATE_BOARD;\n    \n  //  p.yz *= rot(radians(60.));\n\n    float len = 1.0;\n    vec3 size = vec3(len, 0.05, len*0.39);\n    float ax = abs(p.x);\n    float pz = p.z;\n    float scaleZ = max(0.1, 1.0 - smoothstep(size.x/2., size.x*1.6, ax));\n    float scaleY = max(0.3, smoothstep((size.x/2.0)-0.16, (size.x/2.0)+0.2, abs(p.x)));\n    \n    float truckLen = size.z*1.9;\n    float truck = cylSDF(vec3(abs(p.x), p.y, p.z) - vec3(abs(-size.x/2.), -size.y*3.3, 0), vec3(0.0, 0.0, -truckLen/2.0), vec3(0.0, 0.0, truckLen/2.0), size.y*0.9);\n    \n    float wheelR = size.y*1.2;\n    float wheelLen = 0.1;\n    float wheel = cylFlatSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-size.x/2.), -size.y*3.3, abs(-size.z)), vec3(0.0, 0.0, -wheelLen/2.0), vec3(0.0, 0.0, wheelLen/2.0), wheelR);\n    float wheelHole = cylSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-size.x/2.), -size.y*3.3, abs(-size.z)), vec3(0.0, 0.0, -wheelLen/2.0), vec3(0.0, 0.0, wheelLen/2.0), wheelR*0.7);\n    wheel = max(wheel-0.002, -wheelHole);\n    \n    p.y += 0.09*max(0.0, 1.0 - smoothstep(size.x/2.0, size.x, abs(p.x)));\n    scaleY -= 0.9*max(0.0, 1.0 - smoothstep(size.x/2.0, size.x+0.9, abs(p.x)));\n    float board = boxSDF(p, size * vec3(1, clamp(1.0 * scaleY, 0.5, 1.0), 1.0 * scaleZ));\n    board -= (0.9*max(0.0, smoothstep(size.x/2., size.x*2., abs(p.x)))) * clamp(p.y, 0.0, 1.0);\n    \n    float dist = board;\n    \n    if (truck < dist) { part = ID_SKATE_TRUCK; dist = truck; }\n    if (wheel < dist) { part = ID_SKATE_WHEEL; dist = wheel; }\n    \n    return dist;\n}\n\nfloat lampSDF(in vec3 p, inout int part) {\n    part = ID_LAMP_POLE;\n    float dist = FAR;\n    \n    float h = 2.6;\n    float t = 0.1;\n    \n    float pole = cylSDF(p, vec3(0, 0, 0), vec3(0, h, 0), t);\n    float container = boxSDF(p - vec3(t*2.5, h, 0), vec3(0.3, 0.06, 0.1)) - 0.06;\n    \n    float bulb = sphereSDF(p - BULB_POS, 0.11);\n    \n    dist = pole;\n    \n    if (container < dist) { dist = container; part = ID_LAMP_CONTAINER; }\n    if (bulb < dist) { dist = bulb; part = ID_LAMP_BULB; }\n    \n    return dist;\n}\n\nfloat getDist(inout Data data, in vec3 p) {\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n    int lampPart = ID_LAMP_POLE;\n    float lamp =lampSDF(p, lampPart);\n    //float box = boxSDF(p - vec3(0.0, 0.5, 0.0), vec3(0.5));\n    int skatePart = ID_SKATE_BOARD;\n    Object skateBoard = getSkateBoard();\n    float skate = skateSDF(p, skatePart, o, skateBoard);\n    \n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(lamp, lampPart);\n    //SAMPLE(box, ID_BOX);\n    SAMPLE(skate, skatePart);\n    \n    return dist;\n}\n\nbool march(inout Data data, vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if ((next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    if (dist < 0.0) return false;\n    \n    vec3 p = ro+rd*dist;\n    data.d = dist;\n    data.p = p;\n    \n    float f = data.id == ID_GROUND ? mix(0.001, 0.1, clamp(smoothstep(2.0, 4.0, distance(data.p.xz, vec2(0, 0))), 0.0, 1.0)) : 0.001;\n    vec2 e = vec2(f, 0.0);\n    data.n = normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n    data.uv = boxUv(pointQuat(data.p - data.o.pos, data.o.q), pointQuat(data.n, data.o.q));\n    \n    return true;\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float near, float far) {\n    float dist = 0.0;\n    Data data = NEW_DATA;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= min(near, NEAR)) break;\n        if (abs(dist) >= min(far, FAR)) return 1.0;\n    }\n    \n    if (dist < 0.0) return 1.0;\n    \n    dist = abs(dist);\n    near = abs(near);\n    \n    return clamp(dist / (0.1+near), 0.0, 0.77);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = vec3(0.0);\n    vec2 uv = rd.xz / rd.y;\n    vec2 uvSp = uvSphere(rd);\n    \n    vec3 c1 = rgb(88, 171, 217);\n    vec3 c2 = rgb(13, 69, 153);\n    \n    col = c1;\n    col = mix(col, c2, clamp(dotup*1.2, 0.0, 1.0));\n    \n    vec2 shift = vec2(cos(T*0.2), sin(T*0.2));\n  \n    vec3 lf = noise(uv + shift, 3.33321, 1.5);\n    \n    \n    float time = T;\n    float nrSteps = 3.0;\n    float transTime = 0.9;\n    float frame = 1.0;\n    \n    float low = lf.x;\n    \n    low = onCycle(low, lf.y, time, nrSteps, transTime, frame); frame += 1.0;\n    low = onCycle(low, lf.z, time, nrSteps, transTime, frame); frame += 1.0;\n    low = onCycle(low, lf.x, time, nrSteps, transTime, frame); frame += 1.0;\n    \n    low = pow(low, 2.2);\n    \n    vec3 hf = noise(uv - shift, 3.33321, 10.5);\n    float high = hf.x;\n    \n    frame = 1.0;\n    \n    high = onCycle(high, hf.y, time, nrSteps, transTime, frame); frame += 1.0;\n    high = onCycle(high, hf.z, time, nrSteps, transTime, frame); frame += 1.0;\n    high = onCycle(high, hf.x, time, nrSteps, transTime, frame); frame += 1.0;\n    \n    high = pow(high, 2.2);\n    \n    float clouds = low + high;\n    \n    col = mix(col, vec3(1.0), clouds);\n    \n    return col;\n}\n\nvec3 grassTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf = noise(uv, 1.3815, 100.2);\n    \n    vec3 c1 = rgb(43, 61, 4);\n    vec3 c2 = rgb(101, 109, 55);\n    vec3 c3 = rgb(88, 81, 11);\n    \n    col = mix(col, c1, hf.x);\n    col = mix(col, c2, hf.y);\n    col = mix(col, c3, hf.z);\n    \n    vec3 c4 = rgb(142, 126, 0);\n    vec3 c5 = rgb(135, 135, 71);\n    vec3 c6 = rgb(100, 89, 0);\n    \n    vec3 lf = noise6(uv, 6.4213, 3.2);\n    \n    float low = abs(lf.x - lf.y);\n    low = smoothstep(0.01, 0.5, low);\n    \n    col = mix(col, c4*c4, low);\n    col = mix(col, c5*c5, lf.y);\n    col = mix(col, c6*c6, lf.z);\n    \n    col *= max(0.34, hf.x);\n    \n    vec3 j = abs(normalize(cross(hf, lf)));\n    col *=  max(0.5, abs(j.x-j.y));\n    \n    col += col;\n    \n    m.spec = max(hf.y, 1.0 - (low+hf.x)) / M_PI;\n    m.rough = clamp((hf.x+hf.y+hf.z)/2., 0.8, 1.0);\n    \n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 woodTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(176, 142, 115);\n    vec3 c2 = rgb(74, 48, 42);\n    vec3 c3 = rgb(195, 135, 90);\n    vec3 c4 = rgb(86, 51, 29);\n    \n    vec3 alt = noise(uv, 8.83159, 128.);\n    \n    col = mix(col, c1, alt.x);\n    col = mix(col, c2, alt.y);\n    col = mix(col, c3, alt.z);\n    \n    float lines = ((alt.z+alt.x+alt.y)/3.)*cos((uv.x-sin(uv.y*TAU))*TAU+cos((uv.x-uv.y)*TAU));\n    lines = pow(max(0.0, 0.7*(1.0-abs(lines))), 3.0);\n    \n    col = mix(col, c2*c2*c2, lines*alt.y);\n    col = mix(col, c4, clamp(0.1*fract(10.38921*(tan(lines*6.831)+cos(alt.x+alt.y+alt.z))), 0.0, 1.0));\n    col += luma(col);\n    col = col*col*col*col;\n    return col;\n}\n\nvec3 gripTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf = textureLod(iChannel3, uv*2., 0.).rgb;\n    \n    float tiny = pow(hf.x, 8.0);\n    tiny = max(0.0, hf.x - (hf.y*3.));\n    \n    vec3 c1 = rgb(99, 98, 104);\n    vec3 c2 = rgb(75, 76, 81);\n    vec3 c3 = rgb(126, 127, 129);\n    \n    col = mix(col, c1*c1*c1, hf.x);\n    col = mix(col, c2*c2*c2, hf.y);\n    col = mix(col, c3*c3*c3, hf.z);\n    col *= max(0.3, tiny);\n    \n    m.spec = clamp(tiny+(hf.y*0.6), 0.1, 1.0);\n    \n    return col;\n}\n\nvec3 lightRubberTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 alt = noise(uv, 3.33321, 20.2);\n    \n    vec3 c1 = rgb(167, 157, 127);\n    vec3 c2 = rgb(150, 126, 82);\n    col = c1;\n    \n    col = mix(col, c2*c2, alt.x);\n    \n    return col;\n}\n\n\nvec3 metalTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    \n    vec3 alt = noise(uv, 5.4591, 9.4);\n    vec3 grain = textureLod(iChannel3, uv*2., 0.0).rgb;\n    \n    vec3 c1 = rgb(77, 103, 132);\n    vec3 c2 = rgb(117, 115, 116);\n    vec3 c3 = rgb(149, 144, 150);\n    \n    col = mix(col, c1, pow(alt.x, 2.0));\n    col = mix(col, c2, pow(alt.y, 2.0));\n    col = mix(col, c3, pow(alt.z, 2.0));\n    \n    col = mix(col, max(c1, max(c2, c3)), pow(grain.x, 3.0));\n    \n    m.spec = alt.x;\n    m.rough = alt.y;\n    \n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv*0.5;\n    \n    col = metalTexture(uv, data.m);\n    return col;\n}\n\nvec3 getAlbedoLampPole(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;//*0.5;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uvSp = vec2(p.x*p.z, p.y/TAU);\n    \n    col = metalTexture(uvSp, data.m);\n    return col;\n}\n\nvec3 getAlbedoLampContainer(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv*0.5;\n    \n    col = metalTexture(uv, data.m);\n    return col;\n}\n\nvec3 getAlbedoLampBulb(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    col += vec3(0.97, 0.79, 0.22);\n   \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv*0.5;\n    \n    col += grassTexture(uv, data.m);\n    \n    vec3 n = vec3(0.0);\n    EST_NORM_FOR(grassTexture, uv, data.n, data.m, luma, col, 0.5, n);\n    \n    data.n = n;\n    \n    return col;\n}\n\nvec3 getAlbedoSkateBoard(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    vec3 on = pointMat(data.n, data.o.m);\n   \n    Material mwood = NEW_MATERIAL;\n    Material mgrip = NEW_MATERIAL;\n    col = woodTexture(uv, mwood);\n   \n    vec3 grip = gripTexture(uv, mgrip);\n    \n    float up = clamp(20.0*cdot(on, vec3(0, 1, 0)), 0.0, 1.0);\n    col = mix(col, grip, up);\n    \n    vec3 n = vec3(0.0);\n    EST_NORM_FOR(woodTexture, uv, data.n, data.m, luma, col, 0.5, n);\n    data.n = n;\n    \n\n    data.m.spec = mix(max(mwood.spec, 0.8), mgrip.spec, up);\n    data.m.rough = mix(mwood.rough, mgrip.rough, up);\n    \n    \n    return col;\n}\n\nvec3 getAlbedoSkateWheel(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    col = lightRubberTexture(uv*6., data.m);\n\n    \n    return col;\n}\n\nvec3 getAlbedoSkateTruck(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    vec3 p = data.p;\n    vec2 uvSp = vec2(acos(p.x), atan(p.y, p.z));\n    \n    col = metalTexture(uvSp, data.m);\n\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_SKATE_BOARD: return getAlbedoSkateBoard(data); break;\n        case ID_SKATE_WHEEL: return getAlbedoSkateWheel(data); break;\n        case ID_SKATE_TRUCK: return getAlbedoSkateTruck(data); break;\n        \n        case ID_LAMP_POLE: return getAlbedoLampPole(data); break;\n        case ID_LAMP_CONTAINER: return getAlbedoLampContainer(data); break;\n        case ID_LAMP_BULB: return getAlbedoLampBulb(data); break;\n    }\n    return vec3(0.77);\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    vec3 att = getLightAtt(light, p, n);\n    \n    float shadow = getShadow(p+(n*NEAR*2.0), L, data.d, (\n        light.type == LIGHT_AMBIENT ? FAR : distance(light.p, p)\n    ));\n    \n    return (diffuse + spec) * att * shadow;\n}\n\nvec3 lightEffect(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 L = normalize(light.p - ro);\n    float VdotL = cdot(rd, L);\n    \n    float distLight = distance(ro, light.p);\n    float k = smoothstep(2.3, 3.0, data.d);\n    float diff = abs(distLight - data.d);\n    \n    if (light.type == LIGHT_DIR) {\n        col += ((light.c*light.c) *  pow(VdotL, 64.0) * clamp(max(smoothstep(0.45, 0.7, diff), (data.d-FAR+1.)), 0.0, 1.0)) / M_PI;\n    }\n    \n    return col;\n}\n\n#define NUM_LIGHTS 2\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float primDist) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.86, 0.76), 1.9, LIGHT_AMBIENT);\n    lights[1] = Light(BULB_POS - vec3(0, 0.17, 0), vec3(-0.25, 1., 0), vec3(0.97, 0.86, 0.76), 8.0, LIGHT_DIR);\n    \n    vec3 mixf = vec3(1.0);\n    float rough = 0.0;\n    vec3 lastNormal = vec3(0.0);\n    primDist = FAR;\n    \n    for (int j = ZERO; j < 2; j++) {\n    \n         if (j > 0) {\n            mixf = vec3(1.0) * max(0.0, 1.0 - rough);\n            \n            vec3 f0 = vec3(0.04);\n            vec3 hitN = data.n;//pointQuat(data.n, data.o.q);\n            \n            vec3 rN = randDir(hitN, data.p, 1.2315, 100.0);\n            \n            hitN = normalize(mix(hitN, rN, clamp(rough, 0.0, 0.99)));\n            \n            float NdotV = abs(dot(hitN, rd));\n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough);\n            vec3 E = EnvBRDFApprox(vec3(0.2), rough*rough, NdotV);\n            mixf = mixf * (F * E.x + E.y);\n            \n           // mixf *= F;\n        }\n        if (march(data, ro, rd)) {\n            if (j <= 0) {\n                primDist = data.d;\n            }\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n                col += forEachLight(data, light, ro, rd) * mixf;\n                col += lightEffect(data, light, ro, rd) * mixf;\n            }\n            rough = data.m.rough;\n            lastNormal = data.n;\n            if (data.m.rough > 0.999) break;\n            \n            rd = reflect(rd, data.n);\n            ro = data.p+(data.n*NEAR*2.);\n        } else {\n            col += getSky(ro, rd) * mixf;\n            col += lightEffect(data, lights[1], ro, rd) * mixf;\n            break;\n        }\n    }\n    \n    float depth = primDist / FAR;\n    \n    col += (depth * max(0.0, 1.0 - dotup))/2.;\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    \n    \n    ro = vec3(0, 1.5, -4.5);\n    rd = normalize(vec3(uv.xy, 1.0));\n   // ro.z += 1.5;\n\n   Object board = getSkateBoard();\n    \n    if ((abs(m.x) > 0.0 || abs(m.y) > 0.0) && m.z > 0.0001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n       vec3 lookp = board.pos;\n       \n       vec3 oRo = ro;\n       \n       \n       float time = T*0.5;\n       float nrSteps = 3.0;\n       float transTime = 1.0;\n       float frame = 1.0;\n       vec3 p = ro;\n      \n       vec3 lookBoard = lookp + vec3(0, 1., 0);\n       \n       ro = onCycle(ro, \n           (vec3(board.pos.x, 0.0, board.pos.z) - pointMat(vec3(-4., 0, 0.0), inverse(board.m))) + vec3(0, 3, 0)\n       , time, nrSteps, transTime, frame);\n       lookp = onCycle(lookp, lookBoard, time, nrSteps, transTime, frame);\n       frame += 1.0;\n       \n       ro = onCycle(ro, \n           (vec3(board.pos.x, 0.0, board.pos.z) - pointMat(vec3(-3.3, 0, 0.0), inverse(board.m))) + vec3(0, 2, 0)\n       , time, nrSteps, transTime, frame);\n       lookp = onCycle(lookp, lookBoard, time, nrSteps, transTime, frame);\n       frame += 1.0;\n       \n       ro = onCycle(ro, oRo, time, nrSteps, transTime, frame);\n       lookp = onCycle(lookp, board.pos, time, nrSteps, transTime, frame);\n       frame += 1.0;\n       \n      \n       \n       rd = look(uv, lookp, ro);\n    }\n    \n    ro.y = max(0.5, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = getMouse();\n    m.xy = (m.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    \n    float dist = FAR;\n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ma);\n    #else\n    col += render(data, ro, rd, dist);\n    #endif\n    \n    col += (luma(col)*col);\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    \n    O = vec4(clamp(col, 0.0, 1.0), dist / FAR);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}