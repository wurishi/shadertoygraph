{"ver":"0.1","info":{"id":"3ttBD8","date":"1612855556","viewed":165,"name":"Tennis game","username":"linlin64","description":"How to play : Use mouse left click to serve and to tap the ball during the rally","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["math","projection","perspective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool sdLine( in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    if(length( pa - ba*h ) <= 0.01) {\n    \treturn true;\n    }\n    return false;\n}\n\nconst vec4 pts[] = vec4[] (\n    vec4(-23.77*0.5, 0, 10.97*0.5,  1),    // 0\n    vec4(23.77*0.5,  0, 10.97*0.5,  1),    // 1\n    vec4(-23.77*0.5, 0, 8.23*0.5,   1),    // 2\n    vec4(23.77*0.5,  0, 8.23*0.5,   1),    // 3\n    vec4(-6.4,       0, 4.1,        1),    // 4\n    vec4(6.4,        0, 4.1,        1),    // 5\n    vec4(-6.4,       0, -4.1,       1),    // 6\n    vec4(6.4,        0, -4.1,       1),    // 7\n    vec4(-6.4,       0, 0.0,        1),    // 8\n    vec4(6.4,        0, 0.0,        1),    // 9 \n    vec4(0.0,        0, 10.97*0.5,  1),    // 10\n    vec4(0.0,        0, -10.97*0.5, 1),    // 11\n    vec4(-23.77*0.5, 0, -10.97*0.5, 1),    // 12\n    vec4(23.77*0.5,  0, -10.97*0.5, 1),    // 13\n    vec4(-23.77*0.5, 0, -8.23*0.5,  1),    // 14\n    vec4(23.77*0.5,  0, -8.23*0.5,  1),     // 15\n    vec4(0.0,        1, 10.97*0.5,  1),    // 16\n    vec4(0.0,        1, -10.97*0.5,  1)    // 17\n);\n\nconst vec2 lines[] = vec2[](\n    vec2(0,1),\n    vec2(2,3),\n    vec2(8,9),\n    vec2(12,13),\n    vec2(14,15),\n    vec2(4,6),\n    vec2(5,7),\n    vec2(10,11),\n    vec2(0,12),\n    vec2(1,13),\n    vec2(16,17),\n    vec2(10,16),\n    vec2(11,17)\n);\n\nvec2 toScreen(vec4 pt) {\n    vec4 screen = pointToScreen * pt;\n    return vec2(screen.x/screen.w, screen.y/screen.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.y *= iResolution.y / iResolution.x;\n\n    fragColor = vec4(211.0/255.0,82.0/255.0,32.0/255.0,1);\n\n    // Tennis\n    vec2 screenPts[18];\n    for (int i = 0; i < 18; ++i) {\n        vec2 screenPt = toScreen(pts[i]);\n        screenPts[i] = screenPt;\n    }\n    \n    // Tennis net\n    for (int i = 0; i < 10; ++i) {\n        vec2 index = lines[i];\n        vec2 pt1 = screenPts[int(index.x)];\n        vec2 pt2 = screenPts[int(index.y)];\n        if(sdLine(uv, pt1, pt2)) {\n            fragColor = vec4(1,1,1,1);\n        }\n    }\n\n    // ball shadow\n    vec4 ball = texelFetch(iChannel0, ivec2(0,0),0);\n    float size = 0.001;\n    vec2 screenPt = toScreen(vec4(ball.x, 0.0, ball.z,1.0));\n    vec2 vec = screenPt-uv;\n    float squaredist = vec.x*vec.x + vec.y*vec.y;\n    if(squaredist < size) {\n        fragColor = vec4(0.2,0.2,0.2,1);\n    }\n        \n    // Net\n    for (int i = 10; i < 13; ++i) {\n        vec2 index = lines[i];\n        vec2 pt1 = screenPts[int(index.x)];\n        vec2 pt2 = screenPts[int(index.y)];\n        if(sdLine(uv, pt1, pt2)) {\n            fragColor = vec4(1,1,1,1);\n        }\n    }\n        \n    // Ball\n    screenPt = toScreen(ball);\n    vec = screenPt-uv;\n    squaredist = vec.x*vec.x + vec.y*vec.y;\n    if(squaredist < size) {\n        fragColor = vec4(1,1,0,1);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float f = 1000.0;\nconst float n = 0.1;\n\nconst float fov = 3.14f*2.0/8.0f;\nconst float scale = n * tan(fov * 0.5);\nconst float aspectratio = 1024.0/576.0;//iResolution.x/iResolution.y;\nconst float r = aspectratio * scale;\nconst float l = -r;\nconst float t = scale;\nconst float b = -t;\n\nconst mat4 proj = mat4 (\n    vec4(2.0*n/(r-l),  0,               0,                 0),\n    vec4(0,            2.0*n/(t-b),     0,                 0),\n    vec4((r+l)/(r-l),  (t+b)/(t-b),    -(f+n)/(f-n),      -1),\n    vec4(0,            0,               -2.0*(f*n)/(f-n),  0)\n);\n\nconst vec3 eye = vec3(20.0,5.0,0.0);\nconst vec3 target = vec3(0,0,0);\nconst vec3 up = vec3(0,1,0);\n\nconst vec3 zaxis = normalize(eye-target);\nconst vec3 xaxis = normalize(cross(up, zaxis));\nconst vec3 yaxis = cross(zaxis, xaxis);\n \nconst mat4 orientation = mat4 (\n       vec4( xaxis.x, yaxis.x, zaxis.x, 0 ),\n       vec4( xaxis.y, yaxis.y, zaxis.y, 0 ),\n       vec4( xaxis.z, yaxis.z, zaxis.z, 0 ),\n       vec4(   0,       0,       0,     1 )\n    );\n     \nconst mat4 translation = mat4 (\n        vec4(   1,      0,      0,   0 ),\n        vec4(   0,      1,      0,   0 ), \n        vec4(   0,      0,      1,   0 ),\n        vec4(-eye.x, -eye.y, -eye.z, 1 )\n    );\n\nconst mat4 lookat = orientation * translation;\n\nconst mat4 pointToScreen = proj * lookat;\nconst mat4 screenToPoint = inverse(pointToScreen);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 getIntersectionPointBetweenLineAndPlane(vec3 lineFirstPoint, vec3 lineSecondPoint, vec3 planeNormal, vec3 pointOnPlane) {\n    vec3 lineDir = lineSecondPoint - lineFirstPoint;\n    vec3 dir = pointOnPlane - lineFirstPoint;\n    float u = dot(planeNormal, dir) / dot(planeNormal, lineDir); \n\tvec3 intersectionPoint = lineFirstPoint + lineDir * u;\n\treturn intersectionPoint;\n}\n\nfloat getDistanceBetweenLineAndPoint(vec3 lineFirstPoint, vec3 lineSecondPoint, vec3 point) {\n    vec3 lineDir = normalize(lineSecondPoint - lineFirstPoint);\n    vec3 dir = point - lineFirstPoint;\n    float t = dot(lineDir, dir);\n    vec3 pt = lineFirstPoint + t * lineDir;\n    return length(pt - point);\n}\n\nvec3 mouseToPoint() {\n    vec2 uv = iMouse.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec4 pt3 = screenToPoint * vec4(uv,1, 1);\n    return vec3(pt3.x/pt3.w, pt3.y/pt3.w, pt3.z/pt3.w);\n}\n\nvec3 tapBall(vec3 ballPosition, vec3 ballVelocity) {\n    float inv = 1.0;\n    if (ballPosition.z > 3.0 || ballPosition.z < -3.0) {\n        inv = -1.0;\n    }\n    vec3 vel = vec3(-ballVelocity.x, 0.11, inv * ballVelocity.z);\n    float norm = length(vel);\n    return 0.5 * vel / norm;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (fragCoord.x > 2.0 || fragCoord.y > 1.0) {\n        return;\n    }\n\n    vec3 ballPosition = texelFetch(iChannel0, ivec2(0, 0),0).xyz;\n    vec3 ballVelocity = texelFetch(iChannel0, ivec2(1, 0),0).xyz;\n\n    // Initialization => we don't want to see the ball\n    if (ballPosition.x == 0.0 && ballPosition.y == 0.0 && ballPosition.z == 0.0) {\n        ballPosition = vec3(15,0,0);\n        ballVelocity = vec3(0);\n    }\n\n    // Ball is stopped or outside the field => wait the service\n    if((length(ballVelocity) < 0.01 || ballPosition.x < -10.0 || ballPosition.x > 10.0) && iMouse.w > 0.0) {\n        vec3 mousePoint = mouseToPoint();\n\n        vec3 intersectionPoint = getIntersectionPointBetweenLineAndPlane(vec3(eye.x, eye.y, eye.z), mousePoint, vec3(0.0, 1.0, 0.0), vec3(0,0,0));\n        vec3 dir = normalize(eye - intersectionPoint);\n        ballPosition = intersectionPoint + dir * 10.0;\n        ballVelocity = -dir * 0.5;\n    \n    // Ball is in game => try to return the ball\n    } else if (iMouse.w > 0.0) {\n        vec3 mousePoint = mouseToPoint();\n        \n        float dist = getDistanceBetweenLineAndPoint(mousePoint, eye, ballPosition);\n        if (dist <= 1.0) {\n            ballVelocity = tapBall(ballPosition, ballVelocity);\n        }\n    }\n\n    // Net Collision\n    vec3 nextBallPosition = ballPosition + ballVelocity;\n    if (ballPosition.y < 1.0\n        && ((nextBallPosition.x > 0.0 && ballPosition.x < 0.0)\n        || (nextBallPosition.x < 0.0 && ballPosition.x > 0.0))\n        && ballPosition.z < 10.97\n        && ballPosition.z > -10.97) {\n        ballVelocity = vec3(0);\n    }\n\n    // Fake gravity\n    ballVelocity.y -= 0.01;\n\n    ballPosition += ballVelocity;\n    \n    // Computer return\n    if(ballPosition.x < -10.0) {\n        ballVelocity = tapBall(ballPosition, ballVelocity);\n    }\n    \n    // Rebound\n    if (ballPosition.y < 0.0) {\n        ballPosition.y = 0.0;\n        ballVelocity.y = -ballVelocity.y;\n        ballVelocity = 0.7*ballVelocity;\n    }\n\n    // Save for next frame\n    if (fragCoord.x >= 0.0 && fragCoord.x < 1.0\n        && fragCoord.y >= 0.0 && fragCoord.y < 1.0) {\n        fragColor = vec4(ballPosition, 1.0);\n        return;\n    }\n    \n    if (fragCoord.x >= 1.0 && fragCoord.x < 2.0\n        && fragCoord.y >= 0.0 && fragCoord.y < 1.0) {\n        fragColor = vec4(ballVelocity, 0.0);\n        return;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}