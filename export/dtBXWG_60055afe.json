{"ver":"0.1","info":{"id":"dtBXWG","date":"1676958470","viewed":65,"name":"PBR: Isotropic Material","username":"enuyeel","description":"PBR: Isotropic Material by Yune '23 (twitter: @yuneismyname / website: https://yuneismyname.com)\n\nGo check out the article I've written on PBR if you're interested! [https://yuneismyname.com/blog/2022/10/12/pbr]","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["triplanar","brdf","orthographic","pbr","isotropic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PBR: Isotropic Material\n// by Yune 2023 (twitter: @yuneismyname / website: https://yuneismyname.com)\n// https://www.shadertoy.com/view/dtBXWG\n\n/*\n    This PBR implementation is heavily based on Google Filament. Use LaTeX \n    editor for viewing any formulas you come across. A theory of PBR and the\n    implementation detail is discussed in the article I've been working on\n    for a while. Go check it out if you're interested!\n    [https://yuneismyname.com/blog/2022/10/12/pbr]\n    \n    1st to 3rd rows (top-down)\n     ---> (roughness)\n    |      \n    v (metallic)\n    \n    4th to 6th rows (top-down)\n     ---> (reflectance & roughness)\n    |\n    v (metallic)\n\n    TODO:\n        - (Better) Energy conservation.\n        - Roughness map, and metallic map.\n        \n    Updated:\n*/\n\n//* Comment this line to display spheres without texture.\n#define ALBEDO\n\n#ifdef ALBEDO\n//triplanar mapping\nvec3 tpm( vec3 p, vec3 n )\n{\n    p = p * 0.25 + 0.5;\n\n    //right handed system!\n    vec3 x = texture(iChannel0, p.yz).rgb;\n    vec3 y = texture(iChannel0, p.zx).rgb;\n    vec3 z = texture(iChannel0, p.xy).rgb;\n\n    vec3 bF = pow(abs(n), vec3(4.0));\n    bF /= dot(bF, vec3(1.0));\n\n    return x * bF.x + y * bF.y + z * bF.z; \n}\n#endif\n\n//Lambertian BRDF\nfloat Fd_Lambert()\n{\n    //uniform diffuse response over the microfacets hemisphere\n    return 1.0 / PI;\n}\n\n//Trowbridge-Reitz GGX NDF Isotropic\nfloat D_GGX(float NoH, float a)\n{\n    //D(h,\\alpha)=\\frac{\\alpha^2}{\\pi((n\\cdot h)^2(\\alpha^2-1)+1)^2}\n    \n    return \n    \n    a * a\n    / //-------------------------------------------------------------------\n    ( PI * pow( ( (NoH * NoH) * (a * a - 1.0) + 1.0 ), 2.0 ) );\n}\n\n//Smith Geometric Shadowing Function GGX NDF Isotropic Counterpart\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float a)\n{  \n    /*\n    V(v,l,\\alpha)=\\frac{G(v,l,\\alpha)}{4(n\\cdot v)(n\\cdot l)}\\\\\n    =\\frac{0.5}\n    {(n\\cdot l)\\sqrt{\\alpha^2+(1-\\alpha^2)(n\\cdot v)^2}+\n    (n\\cdot v)\\sqrt{\\alpha^2+(1-\\alpha^2)(n\\cdot l)^2}}\n    */\n    \n    return\n    \n    0.5\n    / //-------------------------------------------------------------------\n    ( NoL * sqrt( a * a + ( 1.0 - a * a ) * NoV * NoV ) +\n      NoV * sqrt( a * a + ( 1.0 - a * a ) * NoL * NoL ) );\n}\n\n//Fresnel\nvec3 F_Schlick(float VoH, vec3 f0)\n{\n    //All materials have a Fresnel reflectance of 100% at grazing angles; f90 = 1.0\n    \n    //F(v,h,f_0)=f_0+(1-f_0)(1-v\\cdot h)^5\n    return f0 + (1.0 - f0) * pow(1.0 - VoH, 5.0);\n}\n\nvec3 lighting( \n    in vec3 p\n   ,in vec3 rd \n)\n{\n    vec3 N = nn(p);\n    vec3 V = -rd;\n    //(remotely located) light source; directional light\n    //vec3 L = vec3(0.5773502691896258); //normalize(vec3(1.0))\n    vec3 L = normalize(vec3(cos(iTime), sin(iTime), 1.0));\n    vec3 H = normalize(V + L);\n    \n    float NoH = clamp(dot(N, H), 0.0, 1.0); //Filament\n    float NoV = clamp(dot(N, V), 0.0, 1.0);\n    //float NoV = abs(dot(N, V)) + 1e-5;    //Filament\n    float NoL = clamp(dot(N, L), 0.0, 1.0); //Filament\n    float VoH = clamp(dot(V, H), 0.0, 1.0);\n\n    //[https://google.github.io/filament/Filament.html#table_standardparameters]\n    //Standard Parameters\n    \n    //\"Whether a surface appears to be dielectric (0.0) or conductor (1.0).\n    //Often used as a binary value (0 or 1)\"\n    float metallic = (mod(rowID, 3.0) + 1.0) / 3.0; //* 3.0 is hard-coded to replace ROW / 2.0; 6.0 / 2.0\n    \n    /*\n      Roughness Remapping and Clamping\n      \"(...) we have reached the conclusion that this simple square remapping delivers\n      visually pleasing and intuitive results while being cheap for real-time apps.\n      (...) mediump precision floats are often implemented as half-floats(fp16) on\n      mobile GPUs. (...) The smallest value that can be represented as a half-float is\n      6.1 * 10^-5. (...) 1/(perceivedRoughness)^4 must therefore not be lower than\n      6.1 * 10^-5.\"\n    */\n    //0.089 (~ 6.274 * 10^-5) to the power of 4 is approximately 6.1 * 10^-5.\n    float perceivedRoughness = clamp((columnID + 1.0) / COLUMN, 0.089, 1.0);\n    float a = perceivedRoughness * perceivedRoughness;\n    \n    /*\n      Base Color Remapping\n      \"The base color of a material is affected by the “metallicness” of said material.\n      Dielectrics have achromatic specular reflectance but retain their base color as\n      the diffuse color. Conductors on the other hand use their base color as the spe-\n      cular color and do not have a diffuse component.\"\n    */\n    vec3 baseColor = vec3(1.0, 0.0, 0.0);\n#ifdef ALBEDO\n    //needs every spheres to have exact same texture mapping\n    vec3 sp = spherePosition(columnID, rowID).xyz;\n    baseColor = tpm(p - sp, N);\n#endif\n    vec3 diffuse = (1.0 - metallic) * baseColor;\n    \n    //Fresnel reflectance at normal incidence for dielectric surfaces.\n    //This replaces an explicit index of refraction\n    float reflectance = 0.0 + ( step(3.0, rowID) * (columnID + 1.0) / COLUMN );\n    vec3 f0 = 0.16 * reflectance * reflectance * (1.0 - metallic) + baseColor * metallic;\n    \n    //vec3 emissive = vec3(0.0);\n    //float ao = 0.0;\n    \n    float D = D_GGX(NoH, a);\n    float Vi = V_SmithGGXCorrelated(NoV, NoL, a);\n    vec3 F = F_Schlick(VoH, f0);\n    \n    vec3 Fr = D * Vi * F;\n    //TODO: replace with better energy conservation model\n    vec3 Fd = Fd_Lambert() * diffuse * (vec3(1.0) - F)/* * (1.0 - metallic)*/;\n    \n    return max(NoL, 0.0) * (Fr + Fd);\n}\n\nvec3 render( vec3 ro, vec3 rd )\n{\n    vec3 color = vec3(0.0);\n    \n    //travelled\n    float t = 0.;\n    vec3 re = ro + t * rd;\n    \n    for (int i = 0; i < 256; ++i)\n    {\n        float th = t * 0.001;\n\n        float h = sdf(re);\n\n        if (h < th) break;\n\n        t += h * 0.25;\n        if (t > MAX_DISTANCE)\n        {\n            t = -1.0;\n            break;\n        }\n        \n        re = ro + t * rd;\n    }\n    \n    if (t > 0.0)\n    {\n        color = lighting(re, rd);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //[-1, 1]\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n\n    //orthographic camera scaling up to display every spheres\n    vec3 ro = vec3(uv * vec2(COLUMN * XOFFSET, 6.0 * YOFFSET) / 2.0, ZPOS + RADIUS);\n    vec3 rd = vec3(0.0, 0.0, -1.0);\n\n    vec3 px = render(ro, rd);\n    px = px / (px + vec3(1.0)); //Reinhard Tonemapping\n    px = pow(px, vec3(INV2P2)); //Gamma Correction\n        \n    fragColor = vec4(px, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EPS 0.0001\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n#define INV2P2 0.4545454545454545\n#define MAX_DISTANCE 1000.0\n\n#define COLUMN 7.0\n//* ROW is hard-coded to 6.0\n\n#define XOFFSET 1.\n#define YOFFSET 1.\n#define RADIUS 0.5\n#define ZPOS 0.0\n\nfloat columnID, rowID;\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 spherePosition( float columnIdx, float rowIdx )\n{\n    return vec3(XOFFSET * (-floor(COLUMN / 2.0) + columnIdx), \n                //* (rowIdx + .5) for centering spheres; quick-fix for even number ROW\n                YOFFSET * (/*floor(6.0 / 2.0)*/ 3.0 - (rowIdx + .5)), ZPOS);\n}\n\nfloat sdf( vec3 re/*, out float row, out float column*/ )\n{\n    float d = MAX_DISTANCE;\n    for (float i = 0.0; i < 6.0; ++i)\n        for (float j = 0.0; j < COLUMN; ++j)\n        {\n            float s = sdSphere(re - spherePosition(j, i), RADIUS);\n            if (s <= d)\n            {\n                rowID = i;\n                columnID = j;\n                d = s;\n            }\n        }\n\n    return d;\n}\n\n//numerical normal\nvec3 nn( vec3 p )\n{\n    const vec2 k = vec2(1,-1)*EPS;\n    return normalize( k.xyy*sdf( p + k.xyy ) + \n                      k.yyx*sdf( p + k.yyx ) + \n                      k.yxy*sdf( p + k.yxy ) + \n                      k.xxx*sdf( p + k.xxx ) );\n}","name":"Common","description":"","type":"common"}]}