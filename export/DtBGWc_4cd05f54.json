{"ver":"0.1","info":{"id":"DtBGWc","date":"1673987688","viewed":110,"name":"Ocean simulator","username":"ianertson","description":"Control the simulation by dragging with the mouse and walk around using WASD","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","ray","water","ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 48\n#define THRESHOLD 0.02\n#define FAR 360.0\n#define AA_ENABLED 1\n#define AA_FILTER_SIZE 2\n#define WAVE_FREQ 0.022\n#define WAVE_MOVE_FREQ 2.6\n#define WAVE_HEIGHT 9.0\n#define WATER_Y 50.0\n#define BUMP_SCALE 0.5\n#define BUMP_FREQ 0.5\n#define BUMP_MOVE_FREQ 0.9\n#define NORMAL_SOFTNESS 0.45\n#define TIME_SPEED 0.4\n\n\n#define BUMP_OFFSET  (noise((p+vec3(-0.01, 0.05, -0.43))*WAVE_FREQ)*WAVE_MOVE_FREQ*BUMP_MOVE_FREQ) * vec3(cos(T), sin(T), sin(T-0.231))\n#define POINT_OFFSET (noise((p+vec3(0.01, -0.02, 0.23))*WAVE_FREQ) * WAVE_MOVE_FREQ * vec3(sin(T), cos(T), cos(T+0.231)))\n\n#define RGB(g) (g / 255.0)\n#define\tBLUE0 RGB(vec3(15,94,156))\n#define\tBLUE1 RGB(vec3(35,137,218))\n#define\tBLUE2 RGB(vec3(28,163,236))\n#define\tBLUE3 RGB(vec3(90,188,216))\n#define\tBLUE4 RGB(vec3(116,204,244))\n\n#define S(g) smoothstep(0.0, 1.0, g)\n\n#define T (27.9 + (iTime * TIME_SPEED))\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec2 rot2D(vec2 p, float angle) {\n  angle = radians(angle);\n  float s = sin(angle);\n  float c = cos(angle);\n  return p * mat2(c, s, -s, c);\n}\n\nvec3 controller(vec3 dir, vec4 c, vec2 res) {\n    vec2 m = ((c.xy == vec2(0.) ? vec2(.5) : (c.xy / res.xy)) * 2. - 1.) * vec2(360.,90.);\n    dir.yz = rot2D(dir.yz, m.y);\n    dir.xz = rot2D(dir.xz, m.x);\n    return dir;\n}\n\nvec3 noise(vec3 p) { return textureLod(iChannel0, p, 0.0).xyz; }\nvec3 waveNoise(vec3 p) { return textureLod(iChannel2, (p.xy+p.z)/512.0, 0.0).xyz; }\nvec3 noiseK(vec3 p) {\n    p += (T*0.01)*(0.33+(0.5+(0.5*cos(T*0.001))));\n    vec3 a = noise(p);\n    vec3 b = noise(p*0.5);\n    vec3 c = noise(p*2.9);\n    vec3 d = noise(p*3.9);\n    \n    float shiftT = T*0.9;\n    vec3 shift = vec3(shiftT+(a.x*0.1), shiftT+(b.y*0.1), shiftT+(c.z*0.1))*0.1;\n    vec3 e = pow(noise((p+shift)*0.2), vec3(2.6)) * 5.0;\n    \n    return ((a + b + c + d + e) / 5.0) * (0.5+e);\n}\n\nfloat getDistWater(vec3 p) {\n    vec3 plane = vec3(0.0, WATER_Y, 0.0);\n    float d = plane.y - -p.y;\n    vec3 height = noiseK(((p*0.7)+POINT_OFFSET)*(WAVE_FREQ/WAVE_HEIGHT))*WAVE_HEIGHT;\n    return d - height.y;\n}\n\n\n\nfloat getDist(vec3 p) {\n   float water = getDistWater(p);\n   return min(water, FAR);\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_SOFTNESS, 0.0);\n    vec3 n = normalize(getDist(p) - vec3(getDist(p-e.xyy), getDist(p-e.yxy), getDist(p-e.yyx)));\n    \n   \n    vec3 bump = waveNoise((p+BUMP_OFFSET*0.9)*BUMP_FREQ);\n    \n    n += cross(n,bump)*BUMP_SCALE;\n    \n    return normalize(n);\n}\n\n\nvec3 getColor(vec3 p, float dist) {\n    vec3 pn = p*0.9;\n    pn += vec3(pn.x*(1.0+(-T*0.001)), pn.y*(1.0+(T*0.001)), pn.z*(1.0+(-T*0.001)));\n    vec3 pattern = waveNoise(pn*0.09);\n    pn += pattern;\n    float D = dist / FAR;\n    vec3 n = noiseK(pn*0.001);\n    vec3 ratio = S(n);\n\n    vec3 col = vec3(0.0);\n    col = mix(col, BLUE0, ratio.x);\n    col = mix(col, BLUE1, ratio.y);\n    col = mix(col, BLUE2, ratio.z);\n    \n    col = col*(0.5+pattern*(0.2+D));\n    \n    col += (col*BLUE4)/3.14;\n    \n    return col*col;\n    \n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float distro = 0.0;\n    \n    float far = FAR;\n    \n    // optimization, decrease the render distance\n    // when camera is looking upwards, there's no water there anyways.\n    far *= (1.0 - (max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)))*0.5));\n    \n    int count = 0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec3 p = ro+(rd*distro);\n        float dist = getDist(p);\n        \n        distro += dist;\n        \n        if (dist > far || dist < THRESHOLD) break;\n        count++;\n    }\n    \n    return count <= 0 ? (FAR+(THRESHOLD*3.0)): distro;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n\n    float dist = march(ro, rd);\n    \n    vec3 lightPos = vec3(0.0, 10.0, 2.0);\n    vec3 lightColor = waveNoise(vec3(0.1, 0.4, 1.0))*2.0;\n    vec3 L = normalize(vec3(1.0, 0.2, -1.0));\n    float lightStrength = 0.6;\n    vec3 p = ro+(rd*dist);\n    float dotUp = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    \n    if (dist < FAR && dist > THRESHOLD) {\n        \n        \n        float lightDist = distance(p, lightPos);\n        vec3 norm = getNormal(p);\n    //    vec3 L = normalize(lightPos - p);\n        float NdotL = max(0.0, dot(norm, L));\n        float att = NdotL*lightStrength;//NdotL*(lightStrength / max(0.001, lightDist));\n        \n        vec3 viewdir = normalize(p - ro);\n        vec3 reflectDir = normalize(reflect(-L, norm));\n        float VdotR = max(dot(viewdir, reflectDir), 0.0);\n        \n        col += vec3(2.0) * pow(VdotR, 16.0);\n        \n        vec3 albedo = getColor(p, dist);\n        \n        col += albedo*lightColor*att;\n    } else {\n        col += clamp(BLUE1*3.6, 0.0, 1.0)*dotUp;\n    }\n    \n    float depth = (abs(dist)/FAR);\n    float fog = max(0.0, depth);\n\n   col +=  (fog * mix(BLUE1, BLUE0, clamp((depth*depth), 0.0, 1.0)));\n\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 res = iResolution.xy;\n    vec2 uv = (fc-0.5*iResolution.xy)/res.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 0.1);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n   \n    ro.y += 8.0;\n    \n    \n    //ro.y += 50.0;\n    if (iMouse.z > 0.01 && iFrame > 16) {\n        rd = controller(rd, iMouse, res);\n        rd = normalize(rd);\n        \n        vec3 walk = texture(iChannel1, vec2(0.0)).xyz;\n        ro += walk;\n    } else  {\n        ro.z = T*100.2;\n        float fly = (0.5+(0.5*cos(T)))*33.0;\n        ro.y += fly;\n        \n        \n        \n        float leftright = sin(T)*20.0;\n        vec4 look = vec4(leftright, max(10.0, 180.0-fly), 0.0, 0.0);\n        rd = controller(rd, look, res);\n        \n    }\n    \n    \n    \n    #if AA_ENABLED\n    const int filterSize = AA_FILTER_SIZE;\n    const int halfFilterSize = filterSize / 2;\n\n    const int start = -halfFilterSize;\n    const int end = -halfFilterSize + filterSize;\n\n    vec3 avg = vec3(0.0);\n    float texelSize = 1.0 / res.x;\n    for(int x = start; x < end; ++x)\n    {\n        for(int y = start; y <= end; ++y)\n        {\n          avg += render(ro, rd+(texelSize*vec3(x, y, 0.0)));\n        }\n    }\n\n    avg /= float(pow(float(filterSize), 2.));\n    col = avg;\n    #else\n    col += render(ro, rd);\n    #endif\n\n    col = aces(col);\n    col = mix(col, col*col, 0.8);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.5 / 256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,-3.);\n    \n    float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n    float speed = MOVE_SPEED * iTimeDelta;\n    \n    speed *= 1. + 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n\n    speed *= 3.0;\n    \n    float forwardBackward =\n\ttexture(iChannel0, vec2(KEY_W, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_S, 0.)).r;\n\n\tfloat leftRight =\n\ttexture(iChannel0, vec2(KEY_A, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_D, 0.)).r;\n\n\tfloat s = sin(radians(mx));\n\tfloat c = cos(radians(mx));\n\n\tpos.x += speed * (forwardBackward * s - leftRight * c);\n\tpos.z += speed * (forwardBackward * c + leftRight * s);\n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}