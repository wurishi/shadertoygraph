{"ver":"0.1","info":{"id":"Wld3RN","date":"1575789864","viewed":91,"name":"Reflactor EX","username":"0X800007D0","description":"Can you tell when it starts to loop?","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","refraction","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Modified by 0X800007D0 \n//Original Copyright holder khlorghaal all rights reserved\n\n#define PANORAMIC\n//#define LOCKNT\n\nconst float TRANSMITTANCE= 0.88;\nconst int   MIN_I= 1<<5;\nconst int   MAX_I= 1<<9;\nconst int   MIN_BOUNCE= 6;\nconst int   MAX_BOUNCE= 10;\nconst float IOR= 1.0;\nconst vec4  FOGCOLOR= vec4(.2,.65,.99, 2.);\nconst float FASTNESS= 16.00;\n\nstruct material{\n\tvec3 alba;\n    vec3 emis;\n    float spec;\n    float ior;\n};\n\nbool stagger(ivec3 p){\n\tint n= 1;\n\treturn \n\t((p.x&n)==0)&&\n\t((p.y&n)==0)&&\n\t((p.z&n)==0);\n}\nbool samp(vec3 p, out material mat){\n\t//you shouldnt apply distortion here or itll donk the exact march distance\n\t//but itll probably still look cool\n    \n    ivec3 g= ivec3(p);\n \n    mat= material(\n        WHITE,\n        WHITE,//*float(v)*.5*float(v),\n        TRANSMITTANCE,\n        IOR\n    );\n\n    return \n        stagger(g)\n        //&&!(g.x==g.z&&g.z==0)\n        //&&stagger(g/2)\n        ;\n}\nvec3 img(vec2 uv){\n    vec2 uvn= nmaps(uv);\n    uvn.x*= asp;\n    float modulatedTimeValue = mod(time, (PI * 1000.));\n    \n    vec2 camangle= \n    #ifdef LOCKNT\n    vec2(mouse*TAU/4.);\n    #else\n    vec2((PI*10./71.*sin(modulatedTimeValue)+modulatedTimeValue/2.)*FASTNESS/16.,\n         (PI*1./7.*sin(modulatedTimeValue*1.05)+modulatedTimeValue/2.)*FASTNESS/16.);\n    #endif\n    \n    \n    #ifdef PANORAMIC\n    #define LOOK look_pano\n    #else\n    #define LOOK look_persp\n    #endif\n    ray r= LOOK(uvn, camangle);\n    vec3 ra= r.a;\n    vec3 rc= r.c;\n    //rc.xz-= 1.5;\n    rc.y-= time*FASTNESS*3./7. + PI*FASTNESS*25./710.*sin(modulatedTimeValue);\n    rc.x-= time*FASTNESS*10./47. + PI*FASTNESS*50./1130.*sin(modulatedTimeValue*0.83);\n    rc.z-= time*FASTNESS*8./27. + PI*FASTNESS*20./970.*sin(modulatedTimeValue*1.11);\n    \n\tvec3 p= rc+signv(ra)*1.0;//position\n\tvec3 v= norm(ra);//march velocity\n\tvec3 a= BLACK;//accumulator\n\tvec3 N= vec3(ETA);//normal\n\tint b= 0;//bounce number\t\n\tvec4 trns;//transmittance, refraction multiplier\n\tfloat loss= 1.;\n\tbool s= false;\n    int i=0;\n    float qual= tex(iChannel0,vec2(0.)).x;\n    int itarg= int(lerp(float(MIN_I),     float(MAX_I),      qual));\n    int maxb=  int(lerp(float(MIN_BOUNCE),float(MAX_BOUNCE), qual));\n    for(; i<itarg; i++){  \n\t\tif(b>maxb)\n\t\t\tbreak;\n\n\t\t//march\n\t\tvec3 sv= sign(v+ETA);\n\t\tvec3 ef= floor(p) - (1. + sin(modulatedTimeValue*1.23))/4.;\n\t\tvec3 ec= ceil(p) + (1. + sin(modulatedTimeValue*1.77))/4.;\n\t\tvec3 e= lerp(ef, ec, nmapu(sv));//next edges\n\t\t\n\t\tvec3 dp= e-p;//delta position to each next-edge\n\t\tvec3 edt= dp/(v+ETA);//time to each edge\n\t\tedt= max(edt,ETA);//no negative time\n\t\tfloat dt= minv(edt);//time to soonest edge\n\t\tdp= v*dt + sv*ETA;//pad over the edge slightly\n\t\tp+= dp;\n\n\t\tN= ef-floor(p);//normal\n\t\tif(len(N)<ETA)//this shouldnt happen, but it does, a lot\n\t\t\tN= BLACK+ETA;\n\t\tN= norm(N);\n\t\t\n\t\tbool ps= s;//previous\n\t\tmaterial mat;\n        s= samp(p,mat);//entering\n\t\tif(s^^ps){//transmission\n\t\t\tass(len(v)>ETA, WHITE);\n\t\t\tvec3 r;\n\t\t\tfloat eta= mat.ior+mouse.x*2.5;\n\t\t\tif(!s)\n\t\t\t\teta= 1./eta;\n\t\t\tr= refract(v,N, eta);\n\t\t\tif(eqf(maxv(r),0.)){//total internal reflection\n\t\t\t\tr= reflect(v,N);\n\t\t\t\tv= norm(r);\n\t\t\t\tb++;\n                float positionValue = mod(float(b),100000.)*PI/50000.;\n    \t\t\ta.x += 0.4*(abs(sin(modulatedTimeValue/10.*3. + positionValue + PI/7.))+1.);\n    \t\t\ta.y += 0.4*(abs(sin(modulatedTimeValue/10.*3.23 + positionValue + PI * 8./7.))+1.);\n    \t\t\ta.z += 0.4*(abs(sin(modulatedTimeValue/10.*4.47 + positionValue))+1.);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv= norm(r);\n\t\t}\n\t\tif(s){//hit\n\t\t\t//brdf\n\t\t\tvec3 c= nmapu(N);\n            \n\t\t\ta+= c*loss;\n\t\t\tloss*= TRANSMITTANCE;\n\n\t\t\tb++;\n\t\t}\n\t\t\n    }\n    vec3 col= a*.18;\n            \n    col= srgb(col);\n    return col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//BSD license\n\n//vec3 img(vec2 uv){INIT; }\n\n//Define-Switches\n#define SHADERTOY\n#define GLES\n\n//hack from https://www.shadertoy.com/view/3ll3RH by ttg\n//violently jams uniforms into scope\nfloat _iTime= 1.;\nvec3 _iResolution= vec3(1.);\n#define INIT {_iTime=iTime; _iResolution=iResolution;}\n#define iTime _iTime\n#define iResolution _iResolution\n\n//Consts\n#define PI  3.14159265359\n#define TAU (PI*2.)\n#define PHI 1.61803399\n#define deg2rad 0.01745329251\n#define SQRT2 (sqrt(2.))\n#define SQRT3 (sqrt(3.))\n#define BIG 1e8\n#define ETA 1e-3\n#define eqf(a,b) ( abs((a)-(b))<ETA )\n\n//Aliases\n#define fc (gl_FragCoord.xy)\n#define res (iResolution.xy)\n#define ires ivec2(iResolution.xy)\n#define aspect (res.x/res.y)\n#define asp aspect\n#define aspinv (1./aspect)\n#define vec1 float\n#define ivec1 int\n#define uvec1 uint\n#define len length\n#define lerp mix\n#define norm normalize\n#define sat saturate\n#define sats saturate_signed\n#define smooth(x) smoothstep(0.,1.,x)\n#define time float(iTime)\n#define mouse ((iMouse.xy-res/2.)/(res*2.))\n#define mouse_ang (mouse*TAU)\n#define tex texture\n\n#ifdef SHADERTOY\n#define mainImage(col,__) col= \\\nvec4(img(fc/res),1.)\n//vec4 img(vec2 uv){}\n#endif\n\n#define ass(pred,ret) if(!(pred)) return (ret);\n\n//vectorization macros\n//I dont use these since I don't trust the optimizer to inline the lambda\n//also multiline edit is easy\n#define VECTORIZE_UNARY_FLOAT(f) \\\nvec2 f(vec2 a){ return vec2(f(a.x),f(a.y)); } \\\nvec3 f(vec3 a){ return vec3(f(a.x),f(a.y),f(a.z)); } \\\nvec4 f(vec4 a){ return vec4(f(a.x),f(a.y),f(a.z),f(a.w)); }\n#define VECTORIZE_BINARY_FLOAT(f) \\\nvec2 f(vec2 a, vec2 b){ return vec2(f(a.x,b.x),f(a.y,b.y)); } \\\nvec3 f(vec3 a, vec3 b){ return vec3(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z)); } \\\nvec4 f(vec4 a, vec4 b){ return vec4(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z),f(a.w,b.w)); }\n#define VECTORIZE_UNARY_INT(f) \\\nivec2 f(ivec2 a){ return ivec2(f(a.x),f(a.y)); } \\\nivec3 f(ivec3 a){ return ivec3(f(a.x),f(a.y),f(a.z)); } \\\nivec4 f(ivec4 a){ return ivec4(f(a.x),f(a.y),f(a.z),f(a.w)); }\n#define VECTORIZE_BINARY_INT(f) \\\nivec2 f(ivec2 a, ivec2 b){ return ivec2(f(a.x,b.x),f(a.y,b.y)); } \\\nivec3 f(ivec3 a, ivec3 b){ return ivec3(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z)); } \\\nivec4 f(ivec4 a, ivec4 b){ return ivec4(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z),f(a.w,b.w)); }\n/* example\nfloat accumulate(float x){ return acc+= x; }\nVECTORIZE_UNARY_FLOAT(accumulate);\nAn impure function is a weird but valid example\n*/\n#define VECTORIZE_SCALAR_ARG(f) \\\nvec2 f(vec2 x, vec1 y){ return _f(x,vec2(y));} \\\nvec3 f(vec3 x, vec1 y){ return _f(x,vec3(y));} \\\nvec4 f(vec4 x, vec1 y){ return _f(x,vec4(y));}\n\n\nvec3   srgb(vec3 c){ return pow(c,vec3(   2.2)); }\nvec3 unsrgb(vec3 c){ return pow(c,vec3(1./2.2)); }\nvec3 texsrgb(sampler2D s,   vec2 uv){ return unsrgb(texture(s,uv).rgb); }\nvec3 texsrgb(samplerCube s, vec3  r){ return unsrgb(texture(s, r).rgb); }\n\n\nvec2 mods(vec2 x, vec1 y){ return mod(x,vec2(y));}\nvec3 mods(vec3 x, vec1 y){ return mod(x,vec3(y));}\nvec4 mods(vec4 x, vec1 y){ return mod(x,vec4(y));}\n\nvec2 pows(vec2 x, vec1 y){ return pow(x,vec2(y));}\nvec3 pows(vec3 x, vec1 y){ return pow(x,vec3(y));}\nvec4 pows(vec4 x, vec1 y){ return pow(x,vec4(y));}\n\n\n vec2 clamps( vec2 x,  vec1 min,  vec1 max){ return clamp(x,  vec2(min), vec2(max));}\n vec3 clamps( vec3 x,  vec1 min,  vec1 max){ return clamp(x,  vec3(min), vec3(max));}\n vec4 clamps( vec4 x,  vec1 min,  vec1 max){ return clamp(x,  vec4(min), vec4(max));}\nivec2 clamps(ivec2 x, ivec1 min, ivec1 max){ return clamp(x, ivec2(min),ivec2(max));}\nivec3 clamps(ivec3 x, ivec1 min, ivec1 max){ return clamp(x, ivec3(min),ivec3(max));}\nivec4 clamps(ivec4 x, ivec1 min, ivec1 max){ return clamp(x, ivec4(min),ivec4(max));}\n\n vec2 mins( vec2 v,  vec1 s){ return min(v,  vec2(s));}\n vec3 mins( vec3 v,  vec1 s){ return min(v,  vec3(s));}\n vec4 mins( vec4 v,  vec1 s){ return min(v,  vec4(s));}\n vec2 maxs( vec2 v,  vec1 s){ return max(v,  vec2(s));}\n vec3 maxs( vec3 v,  vec1 s){ return max(v,  vec3(s));}\n vec4 maxs( vec4 v,  vec1 s){ return max(v,  vec4(s));}\n vec2 mins( vec1 s,  vec2 v){ return min(v,  vec2(s));}\n vec3 mins( vec1 s,  vec3 v){ return min(v,  vec3(s));}\n vec4 mins( vec1 s,  vec4 v){ return min(v,  vec4(s));}\n vec2 maxs( vec1 s,  vec2 v){ return max(v,  vec2(s));}\n vec3 maxs( vec1 s,  vec3 v){ return max(v,  vec3(s));}\n vec4 maxs( vec1 s,  vec4 v){ return max(v,  vec4(s));}\nivec2 mins(ivec2 v, ivec1 s){ return min(v, ivec2(s));}\nivec3 mins(ivec3 v, ivec1 s){ return min(v, ivec3(s));}\nivec4 mins(ivec4 v, ivec1 s){ return min(v, ivec4(s));}\nivec2 maxs(ivec2 v, ivec1 s){ return max(v, ivec2(s));}\nivec3 maxs(ivec3 v, ivec1 s){ return max(v, ivec3(s));}\nivec4 maxs(ivec4 v, ivec1 s){ return max(v, ivec4(s));}\nivec2 mins(ivec1 s, ivec2 v){ return min(v, ivec2(s));}\nivec3 mins(ivec1 s, ivec3 v){ return min(v, ivec3(s));}\nivec4 mins(ivec1 s, ivec4 v){ return min(v, ivec4(s));}\nivec2 maxs(ivec1 s, ivec2 v){ return max(v, ivec2(s));}\nivec3 maxs(ivec1 s, ivec3 v){ return max(v, ivec3(s));}\nivec4 maxs(ivec1 s, ivec4 v){ return max(v, ivec4(s));}\n\nfloat maxv( vec2 a){ return                 max(a.x,a.y)  ;}\nfloat maxv( vec3 a){ return         max(a.z,max(a.x,a.y)) ;}\nfloat maxv( vec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\nfloat minv( vec2 a){ return                 min(a.x,a.y)  ;}\nfloat minv( vec3 a){ return         min(a.z,min(a.x,a.y)) ;}\nfloat minv( vec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n  int maxv(ivec2 a){ return                 max(a.x,a.y)  ;}\n  int maxv(ivec3 a){ return         max(a.z,max(a.x,a.y)) ;}\n  int maxv(ivec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\n  int minv(ivec2 a){ return                 min(a.x,a.y)  ;}\n  int minv(ivec3 a){ return         min(a.z,min(a.x,a.y)) ;}\n  int minv(ivec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n\nvec3 signv(vec3 v){ return vec3(sign(v.x),sign(v.y),sign(v.z));}\n\n//normalized map to signed\n//[ 0,1]->[-1,1]\nvec1 nmaps(vec1 x){ return x*2.-1.; }\nvec2 nmaps(vec2 x){ return x*2.-1.; }\nvec3 nmaps(vec3 x){ return x*2.-1.; }\nvec4 nmaps(vec4 x){ return x*2.-1.; }\n//normalized map to unsigned\n//[-1,1]->[ 0,1]\nvec1 nmapu(vec1 x){ return x*.5+.5; }\nvec2 nmapu(vec2 x){ return x*.5+.5; }\nvec3 nmapu(vec3 x){ return x*.5+.5; }\nvec4 nmapu(vec4 x){ return x*.5+.5; }\n\n//[0,1]\nfloat saw(float x){ return mod(x,1.); }\nfloat tri(float x){ return abs( mod(x,2.) -1.); }\n  int tri(int x, int a){ return abs( abs(x%(a*2))-a ); }\n\nfloat sum ( vec2 v){ return dot(v,vec2(1));}\nfloat sum ( vec3 v){ return dot(v,vec3(1));}\nfloat sum ( vec4 v){ return dot(v,vec4(1));}\n  int sum (ivec2 v){ return v.x+v.y;}\n  int sum (ivec3 v){ return v.x+v.y+v.z;}\n  int sum (ivec4 v){ return v.x+v.y+v.z+v.w;}\nfloat prod( vec2 v){ return v.x*v.y;}\nfloat prod( vec3 v){ return v.x*v.y*v.z;}\nfloat prod( vec4 v){ return v.x*v.y*v.z*v.w;}\n  int prod(ivec2 v){ return v.x*v.y;}\n  int prod(ivec3 v){ return v.x*v.y*v.z;}\n  int prod(ivec4 v){ return v.x*v.y*v.z*v.w;}\n\n#define sqrtabs(x) sqrt(abs(x))\n#define powabs(x,p) pow(abs(x),p)\n\nvec1 saturate(vec1 x){ return clamp (x, 0.,1.);}\nvec2 saturate(vec2 x){ return clamps(x, 0.,1.);}\nvec3 saturate(vec3 x){ return clamps(x, 0.,1.);}\nvec4 saturate(vec4 x){ return clamps(x, 0.,1.);}\n#define lerpsat(a,b,x) lerp(a,b,saturate(x))\n\nvec1 saturate_signed(vec1 x){ return clamp (x, -1.,1.);}\nvec2 saturate_signed(vec2 x){ return clamps(x, -1.,1.);}\nvec3 saturate_signed(vec3 x){ return clamps(x, -1.,1.);}\nvec4 saturate_signed(vec4 x){ return clamps(x, -1.,1.);}\n\n#define smoother(x) (x*x*x * (x*(x*6.-15.)+10.) )\n\n\nfloat pow2i(int x){ return float(1<<x); }\n\n//nearest power of\nint npo2(float x){ return int(log2(x)); }\nint npo3(float x){ return int(log(x)/log(3.)); }\n\nfloat angle(vec2 v){ return atan(v.y,v.x); }\nvec1 angn(vec1 t){ return t-ceil(t/TAU-.5)*TAU; }\nvec2 angn(vec2 t){ return t-ceil(t/TAU-.5)*TAU; }\n\nbool real(vec1 x){ return !( isnan(x)||isinf(x) ); }\nbool real(vec2 x){ return real(prod(x)); }\nbool real(vec3 x){ return real(prod(x)); }\nbool real(vec4 x){ return real(prod(x)); }\n\nvec1 rationalize(vec1 x){ return real(x)? x:vec1(0.); }\nvec2 rationalize(vec2 x){ return real(x)? x:vec2(0.); }\nvec3 rationalize(vec3 x){ return real(x)? x:vec3(0.); }\nvec4 rationalize(vec4 x){ return real(x)? x:vec4(0.); }\n\n#define count(_n) for(int n=0; n!=_n; n++)\n\n//im not sure if this is linear or srgb, or if that even matters much\n#define LUMVEC vec3(0.2126, 0.7152, 0.0722)\nfloat lum(vec3 c){ return dot(c,vec3(LUMVEC)); }\n\n#define BLACK  vec3(0.,0.,0.)\n#define RED    vec3(1.,0.,0.)\n#define GREEN  vec3(0.,1.,0.)\n#define BLUE   vec3(0.,0.,1.)\n#define YELLOW vec3(1.,1.,0.)\n#define CYAN   vec3(0.,1.,1.)\n#define PURPLE vec3(1.,0.,1.)\n#define WHITE  vec3(1.,1.,1.)\n\n#define INT_MAX     0x7FFFFFFF\n#define INT_HALFMAX 0x00010000\n#define INT_MAXF     float(INT_MAX)\n#define INT_HALFMAXF float(INT_HALFMAX)\nvec1 unfix16(vec1 x){ return vec1(x)/INT_HALFMAXF; }\nvec2 unfix16(vec2 x){ return vec2(x)/INT_HALFMAXF; }\nvec3 unfix16(vec3 x){ return vec3(x)/INT_HALFMAXF; }\nvec4 unfix16(vec4 x){ return vec4(x)/INT_HALFMAXF; }\nivec1 fixed16(vec1 x){ return ivec1(INT_HALFMAXF*x); }\nivec2 fixed16(vec2 x){ return ivec2(INT_HALFMAXF*x); }\nivec3 fixed16(vec3 x){ return ivec3(INT_HALFMAXF*x); }\nivec4 fixed16(vec4 x){ return ivec4(INT_HALFMAXF*x); }\n\nivec4 hash(ivec4 x){\n\tx= ((x>>16)^x)*0x45d9f3b;\n\tx= ((x>>16)^x)*0x45d9f3b;\n\t//x=  (x>>16)^x;\n    return x;\n}\n//[-max,+max]->[0,1]\nvec1 hashf(vec1 x){ return abs(vec1(hash(ivec4(fixed16(x),0.,0.,0.)).x  ))/INT_MAXF; }\nvec2 hashf(vec2 x){ return abs(vec2(hash(ivec4(fixed16(x),0.,0.   )).xy ))/INT_MAXF; }\nvec3 hashf(vec3 x){ return abs(vec3(hash(ivec4(fixed16(x),0.      )).xyz))/INT_MAXF; }\nvec4 hashf(vec4 x){ return abs(vec4(hash(ivec4(fixed16(x)         ))    ))/INT_MAXF; }\n\n#define R2A vec2(.99231, .9933)\n#define R2B vec2(.99111, .9945)\n#define R3A vec3(.99312, .98313, .9846)\n#define R3B vec3(.99111, .98414, .9935)\n#define R4A vec4(.99412, .99343, .99565, .99473)\n#define R4B vec4(.99612, .99836, .99387, .99376)\nvec1 rand (vec1 x){ return hashf(x);   }\nvec2 rand (vec2 x){ return hashf(x*hashf(x+x.yx)); }\nvec3 rand (vec3 x){ return hashf(x*1.e2*hashf(R3A+x+x.yzx+x.zxy)); }\nvec4 rand (vec4 x){ return hashf(x*hashf(x+x.yzwx+x.zwxy+x.wxyz)); }\nvec1 rand1(vec2 x){ return hashf(dot(x*R2A-R2B,-x*R2B+R2A)/x.x);  }\nvec1 rand1(vec3 x){ return hashf(dot(x+R3A-R3B,-x+R3B+R3A));  }\nvec1 rand1(vec4 x){ return hashf(dot(x+R4A-R4B,-x+R4B+R4A));  }\nvec2 rand2(vec1 x){ return hashf(x+R2A);   }\nvec3 rand3(vec1 x){ return hashf(x+R3A);   }\n\nfloat bilerp(\n\tfloat nn, float np,\n\tfloat pn, float pp,\n\tvec2 l\n){\n\tvec2 lx= lerp(\n\t\tvec2(nn,np),\n\t\tvec2(pp,pp),\n\t\tl.x\n\t\t);\n\treturn lerp(lx.x,lx.y,l.y);\n}\nvec2 bilerp(\n\tvec2 nn, vec2 np,\n\tvec2 pn, vec2 pp,\n\tvec2 l\n){\n\tvec4 lx= lerp(\n\t\tvec4(nn,np),\n\t\tvec4(pp,pp),\n\t\tl.xxxx\n\t\t);\n\treturn lerp(lx.xy,lx.zw,l.yy);\n}\n\nfloat trilerp(float nnn,float nnp,float npn,float npp,float pnn,float pnp,float ppn,float ppp,  vec3 l){\n\tfloat lnn= lerp(nnn, pnn, l.x);\n\tfloat lnp= lerp(nnp, pnp, l.x);\n\tfloat lpn= lerp(npn, ppn, l.x);\n\tfloat lpp= lerp(npp, ppp, l.x);\n\n\tfloat lln= lerp(lnn,lpn, l.y);\n\tfloat llp= lerp(lnp,lpp, l.y);\n\n\treturn lerp(lln,llp, l.z);\n}\nvec3 trilerp(vec3 nnn,vec3 nnp,vec3 npn,vec3 npp,vec3 pnn,vec3 pnp,vec3 ppn,vec3 ppp,  vec3 l){\n\tvec3 lnn= lerp(nnn, pnn, l.x);\n\tvec3 lnp= lerp(nnp, pnp, l.x);\n\tvec3 lpn= lerp(npn, ppn, l.x);\n\tvec3 lpp= lerp(npp, ppp, l.x);\n\n\tvec3 lln= lerp(lnn,lpn, l.y);\n\tvec3 llp= lerp(lnp,lpp, l.y);\n\n\treturn lerp(lln,llp, l.z);\n}\n\n\nfloat vnse(vec1 x){ return lerp(rand(floor(x)),rand(ceil(x)),fract(x)); }\nfloat vnse(vec2 p){\n\tvec2 fr= fract(p);\n\tvec2 f= floor(p);\n\tvec2 c= ceil(p);\n\tfloat nn= rand1(vec2(f.x,f.y));\n\tfloat np= rand1(vec2(f.x,c.y));\n\tfloat pn= rand1(vec2(c.x,f.y));\n\tfloat pp= rand1(vec2(c.x,c.y));\n\tvec4 v= vec4(nn,np,pn,pp);\n\tvec2 lx= lerp(v.xy,v.zw, fr.xx);\n\treturn lerp( lx.x,lx.y, fr.y );\n}\nfloat vnse(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tfloat nnn= rand1(vec3(f.x,f.y,f.z));\n\tfloat nnp= rand1(vec3(f.x,f.y,c.z));\n\tfloat npn= rand1(vec3(f.x,c.y,f.z));\n\tfloat npp= rand1(vec3(f.x,c.y,c.z));\n\tfloat pnn= rand1(vec3(c.x,f.y,f.z));\n\tfloat pnp= rand1(vec3(c.x,f.y,c.z));\n\tfloat ppn= rand1(vec3(c.x,c.y,f.z));\n\tfloat ppp= rand1(vec3(c.x,c.y,c.z));\n\tvec4 zn= vec4(\n\t\tnnn,\n\t\tnpn,\n\t\tpnn,\n\t\tppn\n\t);\n\tvec4 zp= vec4(\n\t\tnnp,\n\t\tnpp,\n\t\tpnp,\n\t\tppp\n\t);\n\tvec4 lx= lerp(zn,zp, fr.zzzz);\n\tvec2 ly= lerp(lx.xz, lx.yw, fr.yy);\n\treturn lerp(ly.x,ly.y, fr.x);\n}\n\nfloat perlin(float p){\n\tfloat fr= fract(p);\n\tfloat frn= fr-1.;\n\tfloat f= floor(p);\n\tfloat c= ceil(p);\n\tfloat a= nmaps(rand(f));\n\tfloat b= nmaps(rand(c));\n\treturn lerp(a,b,smooth(fr));\n}\nfloat perlin(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 frn= fr-1.;\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tvec3 nnn= nmaps(rand(vec3(f.x,f.y,f.z)));\n\tvec3 nnp= nmaps(rand(vec3(f.x,f.y,c.z)));\n\tvec3 npn= nmaps(rand(vec3(f.x,c.y,f.z)));\n\tvec3 npp= nmaps(rand(vec3(f.x,c.y,c.z)));\n\tvec3 pnn= nmaps(rand(vec3(c.x,f.y,f.z)));\n\tvec3 pnp= nmaps(rand(vec3(c.x,f.y,c.z)));\n\tvec3 ppn= nmaps(rand(vec3(c.x,c.y,f.z)));\n\tvec3 ppp= nmaps(rand(vec3(c.x,c.y,c.z)));\n\tfloat d_nnn= dot(nnn, vec3(fr .x, fr .y, fr .z));\n\tfloat d_nnp= dot(nnp, vec3(fr .x, fr .y, frn.z));\n\tfloat d_npn= dot(npn, vec3(fr .x, frn.y, fr .z));\n\tfloat d_npp= dot(npp, vec3(fr .x, frn.y, frn.z));\n\tfloat d_pnn= dot(pnn, vec3(frn.x, fr .y, fr .z));\n\tfloat d_pnp= dot(pnp, vec3(frn.x, fr .y, frn.z));\n\tfloat d_ppn= dot(ppn, vec3(frn.x, frn.y, fr .z));\n\tfloat d_ppp= dot(ppp, vec3(frn.x, frn.y, frn.z));\n\tvec4 zn= vec4(\n\t\td_nnn,\n\t\td_npn,\n\t\td_pnn,\n\t\td_ppn\n\t);\n\tvec4 zp= vec4(\n\t\td_nnp,\n\t\td_npp,\n\t\td_pnp,\n\t\td_ppp\n\t);\n\tvec4 lx= lerp(zn,zp, smooth(fr.zzzz));\n\tvec2 ly= lerp(lx.xz, lx.yw, smooth(fr.yy));\n\treturn nmapu(lerp(ly.x,ly.y, smooth(fr.x)));\n}\n\n\n//value noise smooth vector\nvec2 vnsesv(vec2 p){\n\tvec2 fr= fract(p);\n\tvec2 frn= fr-1.;\n\tvec2 f= floor(p);\n\tvec2 c= ceil(p);\n\tvec2 nn= rand(vec2(f.x,f.y));\n\tvec2 np= rand(vec2(f.x,f.y));\n\tvec2 pn= rand(vec2(f.x,c.y));\n\tvec2 pp= rand(vec2(f.x,c.y));\n\n\treturn bilerp(nn,np,pn,pp, smooth(fr));\n}\nvec3 vnsesv(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 frn= fr-1.;\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tvec3 nnn= rand(vec3(f.x,f.y,f.z));\n\tvec3 nnp= rand(vec3(f.x,f.y,c.z));\n\tvec3 npn= rand(vec3(f.x,c.y,f.z));\n\tvec3 npp= rand(vec3(f.x,c.y,c.z));\n\tvec3 pnn= rand(vec3(c.x,f.y,f.z));\n\tvec3 pnp= rand(vec3(c.x,f.y,c.z));\n\tvec3 ppn= rand(vec3(c.x,c.y,f.z));\n\tvec3 ppp= rand(vec3(c.x,c.y,c.z));\n\n\treturn trilerp(nnn,nnp,npn,npp,pnn,pnp,ppn,ppp, smooth(fr));\n}\n\n\nfloat worley(vec3 c){\n    float acc= 1.;\n    vec3 cfl= floor(c);\n    vec3 cfr= fract(c);\n    for(int i=-1; i<=1; i++){\n    for(int j=-1; j<=1; j++){\n    for(int k=-1; k<=1; k++){\n        vec3 g= vec3(i,j,k)+cfl;\n        vec3 p= rand(g)+g;\n        float l= len(p-c);\n        acc= min(acc,l);\n    }}}\n\treturn acc;\n}\n\n#define dFdxy(x) (vec2(dFdx(x),dFdy(x)))\n#define grad2(f,x) \\\n\t((vec2( \\\n    \tf(x+vec2(ETA,0)), \\\n\t\tf(x+vec2(0,ETA)) \\\n\t  )-f(x))/ETA)\n#define grad3(f,x) \\\n\t((vec3( \\\n    \tf(x+vec3(ETA,0,0)), \\\n\t\tf(x+vec3(0,ETA,0)), \\\n\t\tf(x+vec3(0,0,ETA)) \\\n\t  )-f(x))/ETA)\n\n#define gradnorm2(f,x)  \\\n\tnorm(vec3(grad2(f,x),1.))\n#define gradnorm3(f,x)  \\\n\tnorm(grad3(f,x))\n\nmat2 rot2d(float t){\n    float c= cos(t);\n    float s= sin(t);\n    return mat2(\n        c,-s,\n        s, c\n    );\n    \n}\nmat3 rotx(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c\n    );\n}\nmat3 roty(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n         c,0,s,\n         0,1,0,\n    \t-s,0,c\n    );\n}\nmat3 rotz(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        c,-s,0,\n        s, c,0,\n    \t0, 0,1\n    );\n}\n\n//azimuth, inclination\nvec3 azincl(vec2 a){\n    a.x+= PI/2.;\n    vec2 s= sin(a);//sin theta, sin phi\n    vec2 c= cos(a);//cos theta, cos phi\n    vec3 ret= vec3(c.x,s);\n    ret.xy*= c.y;\n    return ret;\n}\n\n//i am able to use quats, with barely any understanding of them\n//versor from axis-angle\nvec4 vrsr(vec3 w){\n    w.z*= -1.;\n\tvec3 wn= norm(w);\n    float th2= len(w)/2.;\n    return vec4(sin(th2)*wn,cos(th2));\n}\nvec3 rot(vec3 v, vec3 w){\n\tvec4 q= vrsr(w);\n    //copypasta\n\treturn v + 2.*cross(cross(v, q.xyz) + q.w*v, q.xyz);\n}\n\nstruct ray{\n\tvec3 a;\n    vec3 c;\n};\n\n#define FOV 120.\n#define FOV_S tan(deg2rad*.5*FOV)\n#define NEAR .0\n\nray look_persp(vec2 uvn, vec2 a){\n\tray o;\n    o.a= norm( roty(a.x) * rotx(-a.y) * vec3(uvn*FOV_S,1.));\n    o.c= o.a*NEAR;\n    return o;\n}\nray look_orbit(vec2 uvn, vec2 a, float d){\n    ray o;\n    mat3x3 mat= roty(a.x) * rotx(-a.y);\n    o.a= norm( mat * vec3(uvn*FOV_S,1.));\n    o.c= mat[2]*-d + o.a*NEAR;\n\treturn o;\n}\nray look_pano(vec2 uvn, vec2 a){\n    ray o;\n    mat3x3 mat= roty(a.x) * rotx(-a.y);\n    o.a= mat * vec3(uvn,1.);\n    o.a= o.a-len(uvn)*mat*BLUE.xyz*2.;\n    o.a= norm(o.a);\n    o.c= o.a*4.;\n\treturn o;\n}\n\nint doti(ivec2 a, ivec2 b){ return a.x*b.x + a.y*b.y; }\nint doti(ivec3 a, ivec3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\nint doti(ivec4 a, ivec4 b){ return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }\n\n//hacky\nint sqrti(int x){return int(sqrt(float(x)));}\nint cbrti(int x){return int( pow(float(x),1./3.));}\n\n\n\n#ifdef SHADERTOY\n//rip from https://www.shadertoy.com/view/llySRh\n#define KEY_LEFT   37\n#define KEY_UP     38\n#define KEY_RIGHT  39  \n#define KEY_DOWN   40   \n#define KEY_PGUP   33  \n#define KEY_PGDOWN 34  \n#define KEY_END    35  \n#define KEY_HOME   36\n#define KEY_SPACE  32\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#endif\n\n\n\n/*3d texture hacks\nconvert spatial position into index, then index into N-spatial position\nthis artocity is for evading inconvenient storage dimensions\n\ncompletely trashes cache spatial coherence, as the price of no proper compute.\nif someone wanted to be hardcore they could attempt mapping 3d proximity into 2d.*/\n\n//the biggest cube that w*h texels fits\nint cubetex_width(){\n    return int(pow(res.x*res.y, 1./3.));\n}\n\n//cubecoord->texcoord; use for reading\nivec2 cubetex_unpack(ivec3 e){\n\tint cw= cubetex_width();\n\te= clamp(e, ivec3(0), ivec3(cw-1));//assert\n\tint xw= ires.x;\n\tint i= e.x+(e.y+e.z*cw)*cw;//1d position\n    return ivec2(i%xw, i/xw);\n}\n//texcoordd->cubecoord; use for writing\n//assert(cube_pack(cube_unpack(p))==p);\nivec3 cubetex_pack(ivec2 e){\n\tint cw= cubetex_width();\n\te= clamp(e, ivec2(0), ires-1);//assert\n\tint xw= ires.x;\n\tint i= e.x+e.y*xw;\n    return ivec3(i%cw, (i/cw)%cw, i/(cw*cw));\n}\nvec4 cubetex_sample(sampler2D ch, ivec3 p){\n    int w= cubetex_width();\n    if(minv(p)<=0 || maxv(p)>=w)\n        return vec4(0.);\n    //no interpolation unless you want to stare into the glitchvoid\n\treturn texelFetch(ch, cubetex_unpack(p), 0);\n}\n//given no cache coherence, this operation is quite expensive\nvec4 cubetex_sample_trilerp(sampler2D ch, vec3 p){\n    int w= cubetex_width();\n    //pixel center integer\n    //p+= .5;\n    //p= floor(p);//!!\n    ivec3 ip= ivec3(p);\n    vec3 f1= fract(p);\n    vec3 f0= 1.-f1;\n    float fx0= f0.x;\n    float fy0= f0.y;\n    float fz0= f0.z;\n    float fx1= f1.x;\n    float fy1= f1.y;\n    float fz1= f1.z;\n\tvec4 g000= cubetex_sample(ch, ip+ivec3(0,0,0));\n\tvec4 g001= cubetex_sample(ch, ip+ivec3(0,0,1));\n\tvec4 g010= cubetex_sample(ch, ip+ivec3(0,1,0));\n\tvec4 g011= cubetex_sample(ch, ip+ivec3(0,1,1));\n\tvec4 g100= cubetex_sample(ch, ip+ivec3(1,0,0));\n\tvec4 g101= cubetex_sample(ch, ip+ivec3(1,0,1));\n\tvec4 g110= cubetex_sample(ch, ip+ivec3(1,1,0));\n\tvec4 g111= cubetex_sample(ch, ip+ivec3(1,1,1));\n\n\tg000*= fx0*fy0*fz0;\n\tg001*= fx0*fy0*fz1;\n\tg010*= fx0*fy1*fz0;\n\tg011*= fx0*fy1*fz1;\n\tg100*= fx1*fy0*fz0;\n\tg101*= fx1*fy0*fz1;\n\tg110*= fx1*fy1*fz0;\n\tg111*= fx1*fy1*fz1;\n    \n    return g000+g001+g010+g011+g100+g101+g110+g111;\n}\n\n\n#undef iTime\n#undef iResolution","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//dynamic quality hack\n//this should be done on cpu\nvec3 img(vec2 uv){\n    if(!eqf(fc.x,0.5)||!eqf(fc.y,0.5))\n        discard;//i dunno if this increases perf lol\n    \n    float dt= iTimeDelta*1.;\n    float targ= 1./20.;\n    vec3 s= tex(iChannel0,vec2(0.)).rgb;\n    float v= s.x;\n    float pdp= s.y;\n    float dp= targ-dt;\n    float damp= sat(abs(dp-pdp)*1000.)*.01;\n    v+= sign(dp)*damp;\n                \n    return vec3(sat(v),dp,0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}