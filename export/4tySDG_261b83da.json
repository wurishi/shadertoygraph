{"ver":"0.1","info":{"id":"4tySDG","date":"1485559064","viewed":182,"name":"warped Raymarch Kaleidoscope","username":"ShaderLyf","description":"ray marching spheres, did it wrong looks cool, modulating the sphere function and lerping through warped planes.\nNew to shaders, not sure sine waves are the best way to control everything in the mix function, want it to sustain for a bit. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","kaleidoscope","warped"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float eps = 0.01;\nconst vec3 floorColor = vec3(0.5,0.0,1.0);\nconst vec3 otherColor = vec3(1.0,0.0,0.0);\nconst float PI = 3.141592658;\nconst float TAU = 2.0 * PI;\nconst float sections = 6.0;\n\nfloat sphere(vec3 p)\n{\n// p.x = mod(p.x+1.0,-2.);\n\n vec3 q = fract(p) * 1.0-0.5;\n    \n //q.z = (0.01*sin(iTime/20.0));\n  //vec3 q;   \n    \n q.x = cos(p.y+0.2*iTime);\n    \n q.y = sin(p.x+0.2*iTime);  \n //vec3 q = mod(p, 3.1);   \n //return length(q) - (q.x * sin(iTime/10.1)+1.9);\n return length(q) - (1.5);\n}\n\nfloat udBox( vec3 p )\n{\n  \n  vec3 q = fract(p)*0.1-0.05;\n    \n  q.x = cos(p.y+0.4*iTime);\n    \n  q.y = sin(p.x+0.4*iTime); \n  vec3 b = vec3(0.1,0.1,0.1);\n  return length(max(abs(q)-b,0.0));\n}\n\nfloat scene (vec3 p)\n{\n   //return udBox(cos(p)*0.1);\n   return sphere(cos(p)*1.0);\n   //return sphere(p);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n   \n    vec3 q = abs(p);\n    //q.x = mod(q.x+10.0,20.0)-10.0;\n    q.y = fract(q.y) * 2.0-1.0;\n    \n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i)\n    {\n    \tvec3 p = o + r *t;\n        float d = scene(p);\n       // vec3 norml = getNormal(p); \n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 normal;\n    vec3 ep = vec3(eps,0.0,0.0);\n    normal.x = scene(p+ep.xyz) - scene(p-ep.xyz);\n    normal.y = scene(p+ep.yxz) - scene(p-ep.yxz);\n    normal.z = scene(p+ep.yzx) - scene(p-ep.yzx);\n    return normalize(normal);\n}\n\nfloat calcShadowFactor(vec3 p, vec3 norm, vec3 lightDir)\n{\n    float t = .0;\n    vec3 rayStart = p + norm + eps*2.0;\n        for (int i =0; i<16;i++)\n        {\n            vec3 sP = rayStart - lightDir * t;\n            float dist = scene(sP);\n            if(dist < eps)\n            {\n                return 1.0;\n            }\n            t+=dist;\n        }\n    return 0.0;\n}\n\nvec2 pattern1(vec2 uv)\n{\n\tfloat s = sin(3.1416*iTime/16.0);\n    float c = sin(3.1416*iTime/16.0);\n    //float c = 1.0;\n    uv = uv*iResolution.xy - vec2(0.5);\n    vec2 point = vec2(c*uv.x - s*uv.y, s*uv.x + c*uv.y)*0.01;\n   // return vec2 (sin(point.x)+sin(point.y);\n    return vec2(sin(point.x),sin(point.y));\n}\n\nvec2 pattern2(vec2 uv)\n{\n    float time = iTime;\n    float r = sqrt(dot(uv,uv)); // These are equivalent I think\n    \n    float a = atan( uv.x, uv.y);\n    \n    float u = r*cos(a+r); // omg this is trppy\n    float v = r*sin(a+r);\n    return vec2(u,v);\n}\n\nvec2 pattern3(vec2 uv)\n{\n    float time = iTime;\n    float r = sqrt(dot(uv,uv)); // These are equivalent I think\n    \n    float a = atan( uv.y,uv.x );\n    \n    float u = cos(a+cos(r)/10.0)/r; // This is horribly mind manifesting!\n    float v = (sin(a+r)/r); \n    return vec2(u,v);\n}\n\nvec2 pattern4(vec2 uv)\n{\n    float time = iTime;\n    float r = sqrt(dot(uv,uv)); // These are equivalent I think\n    \n    float a = atan( uv.x, uv.y);\n    \n    float u = (uv.x * time *cos(1.0*r) - uv.y*sin(1.0*time*r)) * 0.01; //Yay it looks like a spiral\n    float v = (uv.y*time*cos(1.0*r) + uv.x*sin(1.0*time*r)) * 0.01;\n    return vec2(u,v);\n}\n\nvec2 pattern5(vec2 uv)\n{\n      float time = iTime;\n      float r = sqrt(dot(uv,uv));\n      float u = 0.1*uv.x/(0.11+r*0.5); // The r's here just make it look four quads\n      float v = 0.1*uv.y/(0.11+r*0.5);\n      return vec2(u,v);\n}\n\nvec2 pattern6(vec2 uv)\n{\n    float time = iTime;\n    float a = atan( uv.x, uv.y);\n    float r = sqrt(dot(uv,uv));\n    float u = 0.01*uv.y+0.01*cos(a*5.0)/r; // Looks cool, but a bit smashed, i'm doing it wrong!\n    float v = 0.01*uv.x+0.01*sin(a*5.0)/r;\n\treturn vec2(u,v);\n}\n\nvec2 pattern7(vec2 uv)\n{\n    float time = iTime;\n    float a = atan( uv.x, uv.y);\n    float r = sqrt(dot(uv.x,uv.x));\n    float u = 0.9/(r+0.5*uv.x); // Looks cool, but a bit smashed, i'm doing it wrong!\n    float v = 0.9/(r+0.5*uv.x);\n\treturn vec2(u,v);\n}\n\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat checker(vec2 uv)\n{\n    //float Size = abs(2.1+cos(iTime/50.0));\n    float Size = 15.0;\n    vec2 Pos = floor(uv * Size);\n    //float PatternMask = mod(Pos.x + mod(Pos.y, abs(1.1+sin(iTime/40.0))), abs(1.1+cos(iTime/40.0)));\n    //float PatternMask = mod(Pos.x + mod(Pos.y, abs(2.1*sin(iTime/40.0))),2.0);\n\tfloat PatternMask = mod(Pos.y + mod(Pos.x,1.0),9.0);\n    //return PatternMask * vec4(0.2, 0.2, 0.9, 1.0);\n    return PatternMask;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec4 finalColor = vec4(0.0,0.0,0.0,1.);\n    \n    uv = uv * 2.0 -1.0;\n    \n    //vec2 uv1 = vec2(pattern(uv),pattern(uv));\n    \n    vec2 uv1 = vec2(pattern2(uv));\n    vec2 uv2 = vec2(pattern5(uv));\n    //vec2 uv3 = vec2(pattern5(uv));\n    vec2 uv4 = vec2(pattern5(uv));\n    \n    float rad = length(uv);\n  \tfloat angle = atan(uv.y, uv.x);\n\n  \tfloat ma = mod(angle, TAU/sections);\n  \tma = abs(ma - PI/sections);\n   \tfloat time = iTime/10.0;\n  \tfloat x = cos(ma-time) * rad;\n  \tfloat y = sin(ma) * (rad);\n    \n    vec2 uv3 = vec2(x,y);\n    \n    uv.x *= iResolution.x / iResolution.y;\n    vec2 omix1 = mix(uv,uv2, 1.0*cos(iTime*0.4));\n    vec2 omix2 = mix(uv4,uv2, 1.0*sin(iTime*0.2));\n    vec2 omix = mix(omix1,uv1, cos(iTime*0.1));\n    \n   // vec2 mxer = mix(uv2, omix, 1.0*cos(iTime*0.5));\n    vec2 mxer = mix(uv2, uv3, impulse(2.0,(iTime*0.06)));\n    //vec2 mxr = cubicPulse(uv,uv1,1.0*sin(iTime));\n    \n    vec3 r = normalize(vec3(omix,1.0));\n    \n    vec3 o = vec3(0.0,0.0,-5.0);\n     //vec3 o = vec3(0.0,0.0,-3.0);\n    //float t = trace(o,r);\n    float t = 0.0;\n    float sq = sqrt(dot(uv,uv));\n    \n    for (int i = 0; i < 32; ++i)\n    {\n    \tvec3 p = o + r *t;\n        float d = scene(p);\n        \n        if (d < eps)\n        {\n        \tvec3 norml = getNormal(p);\n        \tvec3 ldir = vec3(1.0,-1.5,1.0);\n        //\tfloat diffuseFactor = max(dot(norml,-ldir),0.0);\n            float diffuseFactor = max(dot(norml,-ldir),0.0);\n\n        \tfloat shadow = calcShadowFactor(p,norml,ldir);   \n        \t//vec3 diffuseColor = vec3(abs (sin(iTime/10.0)),0.7,0.2);\n            float chk = checker(omix);\n            //vec3 diffuseColor = chk*vec3(texture(iChannel0,vec2(omix))).xyz;\n           \n            vec3 diffuseColor = chk*vec3(0.1,0.2,0.2+cos(iTime));\n        \t//finalColor = vec3(1,0,1)*max(dot(norml,vec3(sin(iTime),cos(iTime),0.33)),0.0);\n        \tfinalColor = vec4((1.5-shadow)*diffuseFactor*diffuseColor,1); \n        }\n        t += d;\n    }\n    \n    float fog = 0.2 / (1.1 +t*t*0.9);\n    \n   // vec4 fc *= vec4(finalColor+fog);\n    finalColor += fog;\n    \n    \n\tfragColor = vec4(finalColor);\n}","name":"Image","description":"","type":"image"}]}