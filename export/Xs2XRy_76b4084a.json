{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"music","id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"mat4 cam;\nmat3 rot;\nvec3 lookFrom;\nvec3 lookAt;\n\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    vec4 color;\n    \n};\n    \nstruct Ray\n{\n    vec3 from;\n    vec3 direction;\n};\n\nconst int SPHERES_COUNT = 9;\n    \nSphere spheres[SPHERES_COUNT];\n\n\nconst float distort = 1.0;\nfloat d = 4.0 / distort;\nvec3 lightPos = vec3(1000, 1000, 2000.0);\nvec4 ambient = vec4(0.15, 0.15, 0.15, 0.15);\n\nvec4 ColorCircle(in Sphere sp, Ray ray, float t, vec3 temp, out vec3 norm, out vec3 hit)\n{\n    vec3 hitp = ray.from + t * ray.direction;\n    vec3 normal = hitp - sp.position;\n    normal = normalize(normal);\n    \n    vec3 lightDir = normalize(lightPos - sp.position );\n    vec3 ldiff = lightPos - sp.position;\n    \n    float d = dot(normal, normalize(lightDir));  \n    d = max(d, 0.0);\n    \n    vec3 ldiff2 = lightPos - hitp;\n    vec3 R = reflect(normalize(-ldiff2), normal);    \n    R = normalize(R);\n    \n    float spec = dot(R, normalize(-ray.direction));    \n    \n    spec = max(0.0, spec);\n    spec = pow(spec, 10.0);\n    \n    vec4 specColor = vec4(spec, spec, spec, spec);\n    norm = normal;\n    hit = hitp;\n    return vec4(d, d, d, d) * sp.color + ambient + spec;\n}\n\n\n\nvec4 traceSphere(in Sphere sp, Ray ray, out vec3 hitp, out vec3 normal, out float hitdistance)\n{\n    \n    float d;\n    vec3 temp = ray.from - sp.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(temp, ray.direction);\n    float c = dot(temp, temp) - sp.radius * sp.radius;\n    float disc = b * b - 4.0 * a * c;\n    \n    if (disc >= 0.0)\n    {\n        float e = sqrt(disc);\n        float denom = 2.0 * a;\n        float t = (-b - e) / denom;\n        \n        if ( t > 0.0)\n        {\n\t        hitdistance = t;\n            return ColorCircle(sp, ray, t, temp, normal, hitp);\n        }\n        \n        t = (-b + e) / denom;\n        \n        if (t > 0.0)\n        {\n\t        hitdistance = t;\n            return ColorCircle(sp, ray, t, temp, normal, hitp);\n        }       \n    }\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\n\nvec4 traceSpheres(Ray ray, int bounceIndex, out vec3 hitp, out vec3 normal)\n{\n    \n    \n    float closestHit = 99999.0;\n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i = 0; i < SPHERES_COUNT; ++i)\n    {\n\t    float hitDistance = 0.0;\n        vec4 result = traceSphere(spheres[i], ray, hitp, normal, hitDistance);\n       \t\n        if (hitDistance > 0.0)\n        {\n            if (hitDistance < closestHit)\n            {\n                closestHit = hitDistance;\n                col = result;\n            }\n            \n        }\n    }\n    \n    \n    return col;\n}\n\n\nvec2 getNormalizedPosition(vec2 screenCoord)\n{\n    float midx = iResolution.x * 0.5;\n    float midy = iResolution.y * 0.5;\n    \n    float mx = screenCoord.x - midx;\n    float my = screenCoord.y - midy;\n    return vec2(mx / midx, my / midx);\n}\n\n\nRay getRay(vec2 screenCoord)\n{\n    vec3 p = vec3(getNormalizedPosition(screenCoord), 0.0);\n    \n    Ray r;\n    r.from = lookFrom;\n    \n    vec3 look = lookAt - lookFrom;\n    \n    p.z = look.z;\n    p.z /= length(look);\n    p.z *= d;\n    p = normalize(p);\n    r.direction = p;\n    r.direction *= rot;\n    \n    return r;\n}\n\n\nvoid lookat(vec3 to)\n{\n    lookAt = to;\n    vec3 fwd = normalize(lookFrom - to);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 v = normalize(cross(up, fwd));\n    vec3 w = normalize(cross(fwd, v));\n    \n    rot[0] = v;\n    rot[1] = w;\n    rot[2] = fwd;\n\n\n}\n\nvec4 draw(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 totalCol = vec4(3.0, 1.0 + sin(iTime * 0.25), uv.y * 4.0 + 1.0 - sin(iTime * 0.5), 0.0);    \n\tconst int kernel = 3;\n    const float filterOffset = 1.0 / float(kernel);\n     \n    \n    for (int x = -kernel; x < kernel; x+=2)\n    {\n        for (int y= -kernel; y < kernel; y+=2)\n        {\n            vec3 hitp = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec2 offset = vec2(x, y) * filterOffset;\n            \n            vec2 pos = fragCoord.xy + offset;\n\t\t    Ray r = getRay(pos);\n\t\t    totalCol += traceSpheres(r, 0, hitp, normal);\n            \n            if (hitp != vec3(0.0, 0.0, 0.0))\n            {\n\t            vec3 ref = reflect(r.direction, normal);\n                Ray r2;\n                r2.from = hitp;\n                r2.direction = normalize(ref);\n                r2.from += r2.direction * 1.0;\n                \n                vec4 reflectCol = traceSpheres(r2, 0, hitp, normal);\n                totalCol += reflectCol * 0.95;\n                \n            }\n        }\n    }\n    \n    return totalCol / float (kernel * kernel);\n}\n\nvec3 rotatey(float angle, vec3 point)\n{\n    mat3 mat;\n    mat[0] = vec3(cos(angle), 0.0, sin(angle));\n    mat[1] = vec3(0.0, 1.0, 0.0);\n    mat[2] = vec3(-sin(angle), 0.0, cos(angle));\n    return mat * point;\n}\n\nvec3 rotatez(float angle, vec3 point)\n{\n    mat3 mat;\n    mat[0] = vec3(cos(angle), -sin(angle), 0.0);\n    mat[1] = vec3(sin(angle), cos(angle), 0.0);\n    mat[2] = vec3(0.0, 0.0, 1.0);\n    return mat * point;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = mod(iTime, 4.0);\n    \n    d = 4.0 / distort;\n    \n    \n    lookFrom = vec3(0.0, -0.0, 800.0);\n    \n    vec3 at = vec3(0.0, 0.0, -1.0);\n    \n    lookat(lookFrom + at);\n    float yp = -1.0;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float w = texture( iChannel0, vec2(uv.y,1.0) ).x;\n    float wave2 = texture( iChannel0, vec2(uv.x,1.0) ).x;\n    \n    \n    float radius = 30.0 * (1.0 + w * 0.05);\n\tfloat toRotate = iTime;\n    \n    for (int i = 0; i < SPHERES_COUNT; ++i)\n    {\n        \n        Sphere s;\n        float fi = float(i);\n        float xp = fi;\n        \n        xp = mod(xp, 3.0);\n        yp += mod(fi, 3.0) == 0.0 ? 1.0 : 0.0;\n        xp -= 1.0;\n        float y = yp - 1.0;\n        \n        vec3 spos = vec3(xp * radius * 2.5, y * radius * 2.5, 0.0);\n        spos = rotatez(toRotate, spos);    \n        spos = rotatey(sin(toRotate), spos);    \n        s.position = spos;\n        s.radius = radius;\n        \n        float r = (sin(iTime + 2.0) + 1.0) * 0.5;\n        float g = (cos(iTime) + 1.0) * 0.5;\n        g *= wave2;\n        float b = mod(fi, 2.0);\n        vec4 color = vec4(r, g, b, 0.0);\n        s.color = color;\n        spheres[i] = s;\n    }\n    \n    fragColor = draw(fragCoord);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xs2XRy","date":"1413316888","viewed":259,"name":"Spheregrid","username":"kuvkar","description":"raytraced, reflecting and rotating spheres in a grid dancing with music","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","reflections"],"hasliked":0,"parentid":"","parentname":""}}