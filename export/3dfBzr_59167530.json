{"ver":"0.1","info":{"id":"3dfBzr","date":"1587613989","viewed":107,"name":"cis 561 hw09 Penumbra Shadows ","username":"sireesha98","description":"Hard and soft shadows with various primitives ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///---------------///\n/// All Constants ///\n///---------------///\nconst vec3 lightPos = vec3(0., 7.1, 0.);\n\nconst float FOVY = 3.141569 * 0.25;\nconst int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\nconst float FOCAL_LENGTH = 20.;\nconst float FOCAL_RANGE = 16.0;\nconst int AO_SAMPLES = 256;\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\n\n\n#define ANTIALIASING 1\n#define DOF; //No DOF in this project \n//#define NO_DOF; //Don't forget to comment BLUR in Image \n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 6.0;\n\n// 0 for penumbra shadows, 1 for hard shadows\n#define HARD_SHADOW 0\n\n\n#define PI 3.14159265359\n\n//Set Color palatte :\n//https://iquilezles.org/articles/palettes\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPalette(float t) \n{\n    return a + b * cos(6.28 * (t * c + d));\n}\n\n///------------///\n/// Structures ///\n///------------///\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // Assign every object in our scene a unique ID int\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir; \n    \n};\n  \n///--------------------///\n/// Local Space Matrix ///\n///--------------------///\n    \n// Returns the inverse trasnformation matrix for the given t,r and s components \nmat4 inverseTransform(vec3 scale, vec3 rDeg, vec3 trans) {\n    \n    // convert from degrees to radians\n    vec3 rotate = vec3(radians(rDeg.x), radians(rDeg.y), radians(rDeg.z));\n    \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r = r_x * r_y * r_z;\n    \n    // creating worldTransform matrix\n    mat4 t;\n    t[0] = vec4(1., 0., 0., 0.);\n    t[1] = vec4(0., 1., 0., 0.);\n    t[2] = vec4(0., 0., 1., 0.);\n    t[3] = vec4(trans.x, trans.y, trans.z, 1.);\n    \n    mat4 s;\n    s[0] = vec4(scale.x, 0., 0., 0.);\n    s[1] = vec4(0., scale.y, 0., 0.);\n    s[2] = vec4(0., 0., scale.z, 0.);\n    s[3] = vec4(0., 0., 0., 1.);\n\n    mat4 worldTrans = t * r * s;\n    \n    return inverse(worldTrans);\n}\n\n///--------------------///\n/// Rotation Functions ///\n///--------------------///\n\nvec3 rotateX(in vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\n///-----------------///\n/// Noise Functions /// \n///-----------------///\n\nfloat random1( vec3 p ) {\n    return fract(sin((dot(p, vec3(127.1,\n                                  311.7,\n                                  191.999)))) *         \n                 43758.5453);\n}\n\nvec2 random2(vec3 p) {\n    return fract(sin(vec2(p.x, p.x + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\n\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n//3D Worley Noise \nfloat WorleyNoise3D(vec3 p) {\n    // Tile the space\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int z = -1; z <= 1; z++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n\n                // Random point inside current neighboring cell\n                vec3 point = random3(pointInt + neighbor);\n\n                // Animate the point\n                point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n                // Compute the distance b/t the point and the fragment\n                // Store the min dist thus far\n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\n///---------------------///\n/// Coordinate Systems  ///\n///---------------------///\n\n// Returns a Coorinate system given one of the vectors \nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n            v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n        else\n            v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n        v3 = cross(v1, v2);\n}\n\nvec3 WorleyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( WorleyNoise3D(pos + epsilon.yxx) - WorleyNoise3D(pos - epsilon.yxx),\n                            WorleyNoise3D(pos + epsilon.xyx) - WorleyNoise3D(pos - epsilon.xyx),\n                            WorleyNoise3D(pos + epsilon.xxy) - WorleyNoise3D(pos - epsilon.xxy)));\n\n}\n\nmat3 TangentToWorld(vec3 nor) {\n\tvec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n///----------///\n/// ALL SDFs ///\n///----------///\n    \n// SDF of a sphere - done\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\t\n\n//SDF of a Cube - done\nfloat cube(vec3 p, vec3 s, vec3 r, vec3 t) \n{\n    //Local space of the cube \n    mat4 inverseTrans = inverseTransform(s, r, t);\n    vec4 tempP = inverseTrans * vec4(p, 1.f);\n    p = vec3(tempP.x, tempP.y, tempP.z);\n    \n    vec3 q = abs(p) - vec3(0.5, 0.5, 0.5);\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n//done \n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n//to do\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n///--------------------------///\n/// Scene SDFs and their IDs ///\n///--------------------------///\n\nfloat opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1.x : d2.x;\n}\n\n#define SPHERE_SDF sphere(pos, 2.0, vec3(0.0, 0.0, 6.0))\n#define CUBE_SDF cube(pos, vec3(3., 4., 3.), vec3(0., 0., 0.), vec3(-5., 0., 8.))\n#define TRI_PRISM_SDF sdTriPrism( pos-vec3(-5.0, 3., 8.0), vec2(2.25,2.05) )\n#define TORUS_SDF sdTorus(pos-vec3( 4.5,0.25, 4.0), vec2(1.60, .5))\n#define OCTA_SDF sdOctahedron( pos-vec3(8., 0., 2.), 2.35 )\n\n///-----------------///\n/// Scene Functions ///\n///-----------------///\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = SPHERE_SDF;\n    vec2 res = vec2( 1e10, 0.0 );\n    float t2;\n    obj = 0; // 0 is center sphere\n    if((t2 = TRI_PRISM_SDF ) < t) {\n        t = t2;\n        obj = 1;\n    }\n    if((t2 = CUBE_SDF) < t) {\n        t = t2;\n        obj = 2;\n    }\n    if((t2 = TORUS_SDF) < t) {\n        t = t2;\n        obj = 4;\n    }\n   if((t2 = OCTA_SDF) < t) {\n        t = t2;\n        obj = 5;\n    }\n    if((t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0))) < t) {\n        t = t2;\n        obj = 3;\n    }\n}\n\n\nfloat sceneMap3D(vec3 pos) {\n    float t = SPHERE_SDF;\n    t = min(t, TRI_PRISM_SDF);\n    t = min(t, CUBE_SDF);\n    t = min(t, TORUS_SDF);\n    t = min(t, OCTA_SDF);\n    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));\n    return t;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid rayMarch(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightDir, vec3 viewVec) \n{\n    float t;\n    switch(hitObj) {\n        case 0:\n        // Sphere\n        return vec3(1.0, 0.67, 0.67);\n        break;\n        case 1:\n        // TriPrism\n        return vec3(0.67, 1.0, 0.67);\n        break;\n        case 2:\n        // Cube\n        return vec3(0.67, 0.67, 1.0);\n        break;\n        case 3:\n        // Floor\n        t = floor(mod(0.5 * (sin(p.x) + sin(p.z)), 3.0));\n        return mix(vec3(0.1), vec3(0.5), t);\n        break;\n        //Torus \n        case 4: \n        return vec3(0.37, 0.67, 0.5);\n        //Octa \n        case 5: \n        return vec3(0.7, 0.07, 0.2);\n        case -1:\n        // Background\n        return vec3(0.99, 0.88, 0.69);\n        break;\n    }\n    return vec3(0.99, 0.88, 0.69);\n}\n\n///------------------SHADOWS----------------------///\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t) {\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        t += m;\n    }\n    return 1.0;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) {\n    #if HARD_SHADOW\n    return hardShadow(dir, origin, min_t);\n    #else\n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n    #endif\n}\n\n//Takes a ray in the scene and returns an intersection \nIntersection sceneIntersection(Ray ray) \n{\n    //To be set \n    float t;\n    int hitObj;\n    \n    //RayMarch will set t and object hit by raymarching using SDFs \n    rayMarch(ray.origin, ray.dir, t, hitObj);\n\n    //Intersection point in our scene \n    vec3 isect_point = ray.origin + t * ray.dir;\n    \n    //Normal at POI  \n    vec3 nor = computeNormal(isect_point);\n    vec3 lightDir = normalize(lightPos - isect_point);\n    \n    //Compute Material returns color at the POI \n    vec3 material = computeMaterial(hitObj, isect_point, nor, lightDir, \n                                        normalize(ray.origin - isect_point));\n    \n    vec3 warmDir = rotateY(normalize(vec3(1.0, 1.0, 1.0)), sin(iTime * 0.5));\n    vec3 coolDir = rotateY(normalize(vec3(-1.0, 0.0, -1.0)), sin(iTime * 0.5));\n\n    float warmDot = max(0.0, dot(nor, warmDir));\n    float coolDot = max(0.0, dot(nor, coolDir));\n\n    vec3 overallColor = warmDot * vec3(1.0, 0.88, 0.7) * shadow(warmDir, isect_point, 0.1);\n    overallColor += coolDot * vec3(0.05, 0.2, 0.5);\n    overallColor *= material;\n    overallColor = clamp(overallColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);\n    \n    vec3 sdfColor = overallColor;\n \n    return Intersection(t, sdfColor, isect_point, hitObj);\n}\n\n// Returns direction of ray\nRay rayCast(vec3 eye, vec3 ref, vec2 ndc) \n{\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return Ray(eye, normalize(p - eye));\n}\n\n///---------------///\n/// Main Function ///\n///---------------///\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //Anti aliasing    \n    if(ANTIALIASING == 1)\n    {  \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    //Camera's eye and reference points \n\n    vec3 eye = vec3(-4, 9., -15.);\n    vec3 ref = vec3(0, 3.5, 0);\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            vec2 ndc = uv2 + vec2(i, j) / iResolution.xy;\n            Ray ray = rayCast(eye, ref, ndc);\n            aaIsects[idx++] = sceneIntersection(ray);\n        }\n    }\n        \n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n        \n    avgColor *= 0.25;\n    \n    #ifdef DOF\n    float distAlongCamZ = abs(dot(normalize(ref - eye), (aaIsects[0].p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.5);\n\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), dofZ);\n    float fogT = smoothstep(50.0, 100.0, distance(aaIsects[0].p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n    #endif \n    \n   #ifdef NO_DOF \n        fragColor = vec4(avgColor.rgb, 1.);\n    #endif\n    \n    }\n    else //No Anti aliasing\n    {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord / iResolution.xy;\n        // Convert to range [-1, 1]\n        uv = uv * 2.0 - vec2(1.0, 1.0);\n\n        //Camera's eye and reference points \n        vec3 eye = vec3(0, 3.5, -15.);\n        vec3 ref = vec3(0, 2.5, 0);\n        \n\n        //Ray cast returns a ray in the camera's direction to the reference point \n        Ray ray = rayCast(eye, ref, uv);\n\n        //Scene Intersection \n        Intersection isect = sceneIntersection(ray);\n        vec3 avgColor = isect.color;\n    \n        #ifdef DOF\n            float distAlongCamZ = abs(dot(normalize(ref - eye), (isect.p - eye)));\n            float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n            dofZ = pow(dofZ, 0.5);\n            fragColor = vec4(avgColor * step(0.0, isect.t), dofZ);\n            float fogT = smoothstep(50.0, 100.0, distance(isect.p , eye));\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n        #endif \n\n       #ifdef NO_DOF \n            fragColor = vec4(avgColor.rgb, 1.);\n        #endif\n    }\n}","name":"Image","description":"","type":"image"}]}