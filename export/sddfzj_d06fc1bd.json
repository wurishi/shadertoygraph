{"ver":"0.1","info":{"id":"sddfzj","date":"1656836900","viewed":174,"name":"Square roots from circles","username":"ChunderFPV","description":"Green circle radius = square.\nRed circle radius = root.\nClick and move the mouse in a circular pattern to change the value.\nsqrt(n) = cos(asin((n-1.)/(n+1.)))*((n+1.)/2.)","likes":5,"published":1,"flags":16,"usePreview":0,"tags":["circles","math","square","trig","roots"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define M iMouse\n#define L(v,w) smoothstep(w*fwidth(v), 0., abs(v))        // line\n#define CL(r) step(max(0., r), min(r, 1.))                // clamp line\n#define RND(n) ((abs(n) > 1.) ? round(n): 1./round(1./n)) // round to int or 1/int\n#define KT(i) texelFetch(iChannel1, ivec2(i, 2), 0).x     // key toggle\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    float s = 2.2,   // scale\n          lw = 1.5,  // line width\n          sec = 10., // num seconds for animation\n          t = (iTime*6.283)/sec;\n    \n    bool km = KT(77) > 0. || M.z > 0.;   // m key (save mouse pos)\n    vec2 m = (M.xy-.5*R.xy)/R.y*2.;      // mouse to cartesian\n    float ma = atan(m.y, m.x),           // arc from mouse\n          msin = (km) ? sin(ma): sin(t), // sine from mouse or time\n          icr = 1./(1.-msin),            // intersecting circle radius\n          n = (icr*2.)-1.;               // square to be rooted\n    \n    if (km) // on click\n        n = RND(n),      // round n or 1/n\n        icr = (n+1.)/2.; // update after rounding\n    \n    float root = sqrt(n), // cos(asin((n-1.)/(n+1.)))*((n+1.)/2.),\n          ry = icr-1.,    // icr y offset\n          xp = (km) ? sign(m.x): sign(cos(t)), // x polarity\n          yp = sign(msin);                     // y polarity\n    \n    vec2 uv = (XY-.5*R)/R.y, // screen coords\n         u = uv*max(n*s, s), // screen coords with zoom\n         fw = fwidth(u);     // pixel size\n    \n    float x = u.x, \n          y = u.y, \n          x2 = x*x, \n          r = length(u); // radius (distance from 0)\n    \n    vec3 c = vec3(0); // background color\n    vec2 g = abs(fract(u+.5)-.5)/fw; // grid\n    c += max(0., 1.-min(g.x, g.y))*.3;\n    \n    float rb = min(n, 1.); // radius of blue circles\n    vec2 row = vec2(x*.5/rb, fract(.5+y*.5/rb)-.5)*2.; // row of circles\n    if (r < max(n, 1.)) c.b += L(1.-length(row), lw);  // draw inside square or unit\n    \n    // vesica piscis\n    c.rb += L(1.-length(u-vec2(0, ry))/icr, lw); // 1\n    c.rb += L(1.-length(u+vec2(0, ry))/icr, lw); // 2\n    \n    float b = .75; // brightness\n    c += L(1.-r, lw); // unit circle\n    c = mix(c, vec3(0,1,0), L(1.-r/n, lw)); // square (green circle)\n    c.g += L(x, lw)*CL(y/n)*b;              // square radius\n    c.r += L(1.-r/root, lw);                // root (red circle)\n    c.r += L(y, lw)*CL(x/root*xp)*b;        // root radius\n    c += L(x*xp*(ry/root)-y, lw)*CL(x*xp/root)*b; // slope\n    c.rb += L(y-ry, lw)*CL(x*xp/icr)*b;           // icr\n    c.rg += L(x*xp-root, lw)*CL(y/ry)*b;          // y offset\n    c += max(0., 1.-length((u-vec2(root*xp, ry))/fw/5.)); // point at slope & graph\n    \n    c.gb += L(y-(x2-1.)/2., lw)*.5; // graph similar to x^2\n    vec2 rp = vec2(abs(x), y) - vec2(sqrt(RND(x2)), (RND(x2)-1.)/2.); // sqrt points on graph\n    c.gb += max(0., 1.-length(rp/fw/3.));\n    \n    // digits\n    if (!isinf(root)) root *= xp;\n    vec3 nd = digit(iChannel0, uv-vec2(.66, -.4), n, .1, 7., 4.),     // square\n         rd = digit(iChannel0, uv-vec2(.66, -.48), root, .1, 7., 4.); // root\n    c += nd*vec3(0,1,0)+rd*vec3(1,0,0);\n    \n    RGBA = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// font code from https://www.shadertoy.com/view/7tV3zK\nvec4 char(sampler2D ic, vec2 p, int c)\n{\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad(ic, p/16. + fract( vec2(c, 15-c/16)/16.), dFdx, dFdy );\n}\nvec4 pInt(sampler2D ic, vec2 p, float n, float d)\n{\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(ic, p - vec2(-.5,0), 45 ),\n        n = -n;\n    for (float i = d; i>0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(ic, p - .5*vec2(i-1.,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// texture, screen coords, value, size, num left digits, num right digits\nvec3 digit(sampler2D ic, vec2 uv, float v, float s, float l, float r)\n{\n    float numleft = min(log2(abs(v))/log2(10.), l-1.);\n    l = max(floor(numleft), 0.)+1.;\n    uv /= s; // size\n    if (isinf(abs(v))) return vec3(char(ic, uv*.7+vec2(.5, .3), 153).x); // infinity symbol\n    uv += vec2((l+1.)/2., .28); // center on decimal\n    vec3 d = vec3(0);\n    d += pInt(ic, uv, v, l).x; // left of decimal\n    uv.x -= l/2.;\n    d += char(ic, uv, 46).x; // decimal point\n    uv.x -= .5;\n    d += pInt(ic, uv, floor(abs(v)*pow(10., r)), r).x; // right of decimal\n    return d;\n}\n","name":"Common","description":"","type":"common"}]}