{"ver":"0.1","info":{"id":"wdfSDH","date":"1551171557","viewed":181,"name":"SherfeyFractal Zoom, slow start","username":"JohnShadow","description":"An absolute based fractal with repeating geometry that is flexible and is reminiscent of the MandleBrot fractal\nI have never tried ray marching before... here goes nothing.  goes to 230 seconds","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","fractal","fun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XlX3DN","filepath":"https://soundcloud.com/minecraftwizards/11-c418-warmth","previewfilepath":"https://soundcloud.com/minecraftwizards/11-c418-warmth","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxsteps 20\n#define maxDist 20.0\n#define surfaceScalar 1.75\nfloat sdf(vec3 x)\n{\n    //sphereical sdf zooming in over time.\n\t//this can use any sdf fuction, even other fractals.\n    float part = abs((iTime+20000.0)/20000.0);\n    float time = 620.0*sin(iTime*0.000025) * part;\n    return distance(x, vec3(0,0,time)) - 2.0;\n}\nvec3 normalSphere (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( sdf(p + vec3(eps, 0, 0) ) - sdf(p - vec3(eps, 0, 0)),\n \t  sdf(p + vec3(0, eps, 0) ) - sdf(p - vec3(0, eps, 0)),\n\t  sdf(p + vec3(0, 0, eps) ) - sdf(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat fractal(vec3 pos)\n{\n    //sample sphere find normal for later casting onto sphere\n    float sl = sdf(pos);\n    vec3 samp = pos;\n    float l = 0.;\n    for(int i = 0; i < 25; ++i) //fractal iterations\n    {\n        samp = abs(samp) - 1.0;\n        samp /= dot(samp,samp);\n    }\n    //do length calcs\n    l = (distance(samp, vec3(0,0,0)) - 1.0) + sl;\n\treturn l;\n}\nvec3 normal (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( fractal(p + vec3(eps, 0, 0) ) - fractal(p - vec3(eps, 0, 0)),\n \t  fractal(p + vec3(0, eps, 0) ) - fractal(p - vec3(0, eps, 0)),\n\t  fractal(p + vec3(0, 0, eps) ) - fractal(p - vec3(0, 0, eps))\n \t)\n );\n}\nvec4 map(vec2 uv)\n{\n    vec3 marchpos = vec3(0, 0, 0), dir = vec3(uv, 1), n = vec3(0,0,0);\n    float totaldist = 0.0;\n    float steps = 0.0;\n    for(int i = 0; i < maxsteps; ++i)\n    {\n        float dist = fractal(marchpos);\n        totaldist += dist;\n        marchpos += dir * dist;\n        if(dist < 0.01)\n        {\n\t\t\tn = normal(marchpos);\n\t\t\tbreak;\n        }\n        ++steps;\n    }\n    //lighting n dot l\n    vec3 light = vec3(sin(iTime), cos(iTime), cos(0.1*iTime + 1.232));\n\tfloat dist = 1.0/distance(light, marchpos);\n    float l = max(dot(n, light)*0.5,0.1) * dist;\n    return vec4(vec3(l) + vec3(n)*0.1, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0)*2.;\n    // Output to screen\n    fragColor = map(uv);\n}","name":"Image","description":"","type":"image"}]}