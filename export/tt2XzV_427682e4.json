{"ver":"0.1","info":{"id":"tt2XzV","date":"1566497015","viewed":151,"name":"Inside The Evil Mandelbox","username":"96logda","description":"This is my first shader to use a mandelbox fractal.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","fractal","mandelbox","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright (c) 2019-08-21 - 2019-08-22 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n\n#define PI\t\t\t\t\t\t3.14\n\n#define saturate(x) \t\t\tclamp(x, 0.0, 1.0)\n#define dot2(x) \t\t\t\tdot(x, x)\n\n#define MANDELBOX_ITERATIONS \t15\n#define SOFT_SHADOW_STEPS \t \t16\n\n#define INTERSECT_STEPS\t\t \t300\n#define INTERSECT_MIN_DIST\t\t0.0001\n#define INTERSECT_MAX_DIST\t \t100.0\n\nconst float FixedRadius2 \t\t= 2.0;\nconst float MinRadius2 \t\t\t= 0.1;\nconst float FoldingLimit \t\t= 1.0;\nconst float Scale \t\t\t\t= -2.8;\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdPlane(vec3 p, float height)\n{\n   \treturn p.y - height;\n}\n\nvoid sphereFold(inout vec3 z, inout float dz) \n{\n    float r2 = dot2(z);\n    if(r2 < MinRadius2) \n    {\n        float temp = FixedRadius2 / MinRadius2;\n        z *= temp;\n        dz *= temp;\n    }\n    else if(r2 < FixedRadius2) \n    {\n        float temp = FixedRadius2 / r2;\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid boxFold(inout vec3 z, inout float dz) \n{\n    z = clamp(z, -FoldingLimit, FoldingLimit) * 2.0 - z;\n}\n\nfloat mandelbox(vec3 z) \n{\n    vec3 offset = z;\n    float dr = 1.0;\n    for(int i = 0; i < MANDELBOX_ITERATIONS; ++i) \n    {\n        boxFold(z, dr);\n        sphereFold(z, dr);\n        z = Scale * z + offset;\n        dr = dr * abs(Scale) + 1.0;\n    }\n    float r = length(z);\n    return r / abs(dr);\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n     return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 map(in vec3 p)\n{\t\n    float ground = sdPlane(p, 1.8);\n    \n    p.xz = mod(p.xz + 2.0, 2.0) - 1.0;\n    p.y  = mod(p.y  + 1.0, 2.0) - 1.0;\n\t\n    float d = mandelbox(p + vec3(0.0, 0.25, 0.0));\n    vec4 res = vec4(d, 1.0, 0.0, 2.0);\n    \n    return opU(res, vec4(ground, 1.0, 0.0, 1.0));\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; i++ )\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.0001)\n\t\t{\n\t    \tbreak;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).y;\n        res = min(res, k * h / t);\n        if(res < 0.0001)\n\t\t{\n\t    \tbreak;\n    \t}\n        t += clamp(h, 0.0, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 GetMaterialColor(in vec3 p, float materialID)\n{\n    if (materialID < 1.5)\n    {\n         vec2 uv = p.xz;        \n         vec3 texRGB = texture(iChannel0, uv * 5.0, 0.0).rgb;\n         return texRGB + vec3(0.0, 0.0, 0.25);\n    }\n    else if (materialID < 2.5)\n    {\n         vec2 uv = p.xy;\n         vec3 texRGB = texture(iChannel1, uv, 0.0).rgb;\n         return texRGB * 0.8;\n    }\n    return vec3(0.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light = vec3(0.0, -0.025, -0.1);\n        \n        vec3 pos = ro + res.x * rd;     \n        vec3 normal = calcNormal(pos);\n        \n        float occ = res.y;\n        float shadow = softshadow(pos + 0.01 * normal, light);\n        \n        vec3 baseColor = GetMaterialColor(pos, res.w);\n        vec3 ambient = vec3(0.2) * baseColor;      \n\n        vec3 diffuse = baseColor * shadow * occ;\n        color = diffuse + (ambient * occ);\n    }\n\n    return pow(color * vec3(0.7), vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t \n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = vec3(15.0, 2.9, -2.0);\n    vec3 ww = normalize(vec3(0.0, mouseXY.y * 5.0 * PI, 0.0) - ro); \n    ww.xz = rotate2D(ww.xz, iMouse.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    rd.xz = rotate2D(rd.xz, PI * 2.55);\n\n    ro.z -= iTime * 0.2; //Camera movement\n\t\n    vec3 color = vec3(0.2);\n    color -= vec3(0.3, 1.0, 1.0);\n \tcolor += render(ro + vec3(0.0, -1.0, 0.0), rd);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}