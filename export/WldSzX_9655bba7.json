{"ver":"0.1","info":{"id":"WldSzX","date":"1581450597","viewed":590,"name":"Wireframe Trails","username":"fizzer","description":"Using bilinear patches to create trails of wireframe edges through piecewise-linear motions.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["blur","wireframe","bilinear","trails"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray intersection test with bilinear surface defined by 4 points\nbool traceBilinearPatch(vec3 ro, vec3 rd, vec3 pa, vec3 pb, vec3 pc, vec3 pd,\n                        inout vec3 outs, inout vec3 outt, inout vec3 outuvi)\n{\n    vec3 va = pc - pa;\n    vec3 vb = (pd - pc) - (pb - pa);\n    vec3 vd = ro - pa;\n    vec3 vc = pa - pb;\n\n    // Note that the coefficients are in reverse order here. Solving this\n    // equation gives 1 / x and avoids a divide-by-zero case for coplanar controlpoints\n    // by switching that case to c = 0 instead of a = 0, thus putting the denominator\n    // in the solution as -b instead of 0.\n    // Thanks to IQ for this trick!\n    \n    float c = dot(cross(vb, vc), rd);\n    float b = dot(cross(va, vc) + cross(vb, vd), rd);\n    float a = dot(cross(va, vd), rd);\n\n    float desc = b * b - 4. * a * c;\n\n    if(desc < 0.0)\n        return false;\n\n    // Put PA at the origin of the coordinate system\n\n    ro -=pa;\n\n    pc = va;\n\n    pd -= pa;\n    pb -= pa;\n    pa -= pa;\n\n    float i;\n    float u, v;\n\n    // Solve for U at each intersection point, which are two quadratics\n\n    float u0 = (2. * a) / (-b - sqrt(desc));\n    float u1 = (2. * a) / (-b + sqrt(desc));\n\n    vec3 pu0 = pb * u0;\n    vec3 pu1 = pb * u1;\n\n    // Solve for V at each intersection point, geometrically\n\n    vec3 vv0 = mix(pc, pd, u0) - pu0;\n    vec3 m20 = ro - pu0 - vv0 * dot(vv0, ro - pu0) / dot(vv0, vv0);\n\n    vec3 vv1 = mix(pc, pd, u1) - pu1;\n    vec3 m21 = ro - pu1 - vv1 * dot(vv1, ro - pu1) / dot(vv1, vv1);\n\n\n    float v0, v1;\n\n    {\n        vec3 n = cross(va + vb * u0, vd + vc * u0);\n        vec3 m = cross(n, rd);\n\n        float da = dot(pu0 - ro, m);\n        float db = dot(pc + (pd - pc) * u0 - ro, m);\n\n        v0 = da / (da - db);\n    }\n\n    {\n        vec3 n = cross(va + vb * u1, vd + vc * u1);\n        vec3 m = cross(n, rd);\n\n        float da = dot(pu1 - ro, m);\n        float db = dot(pc + (pd - pc) * u1 - ro, m);\n\n        v1 = da / (da - db);\n    }\n\n    // Solve for the ray intersection distance at each intersection point\n\n    float da20 = dot(ro - pu0, m20);\n    float db20 = dot((ro + rd) - pu0, m20);\n    float i0 = da20 / (da20 - db20);\n\n    float da21 = dot(ro - pu1, m21);\n    float db21 = dot((ro + rd) - pu1, m21);\n    float i1 = da21 / (da21 - db21);\n\n    // Resolve which valid intersection point is nearest to ray origin\n\n    if(u0 < 0. || u0 > 1. || i0 < 0. || v0 < 0. || v0 > 1.)\n    {\n        u = u1;\n        v = v1;\n        i = i1;\n    }\n    else if(u1 < 0. || u1 > 1. || i1 < 0. || v1 < 0. || v1 > 1.)\n    {\n        u = u0;\n        v = v0;\n        i = i0;\n    }\n    else\n    {\n        u = mix(u0, u1, step(i1, i0));\n        v = mix(v0, v1, step(i1, i0));\n        i = min(i0, i1);\n    }\n\n    if(u < 0. || u > 1. || i < 0. || v < 0. || v > 1.)\n        return false;\n\n    outuvi = vec3(u, v, i);\n\n    // Surface differentials in worldspace\n    outs = pb * u - mix(pc, pd, u);\n    outt = pc * v - mix(pb, pd, v);\n\n    return true;\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\nvec3 transformPoint(vec3 p, float t)\n{\n    mat3 m = rotX(cos(t) * 3.) * rotY(sin(t / 2.) * 3.) * rotZ(sin(t / 3.) * 3.);\n    return m * p * (1. + cos(t * .7) * .2);\n}\n\nvec3 colourRamp(float x)\n{\n    return clamp(1. - sin((1. - x) * vec3(.5,9.5,3.5).brg * .7), 0., 1.5) * x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Set up primary ray\n\n    vec3 ro = vec3(0., 0., 4.);\n    vec3 rd = normalize(vec3(uv.xy, -2.));\n\n    vec3 col = vec3(0.01);\n        \n    float dt = 1. / 6.;\n    \n    float t0 = iTime - dt * 2.;\n    float t1 = iTime - dt;\n    float t2 = iTime;\n        \n    // 12 edges of the cube\n    \n\tfor(int axis = 0; axis < 3; ++axis)\n    {\n        for(int i = 0; i < 4; ++i)\n        {\n            vec3 p0, p1;\n            \n            p0[(axis + 1) % 3] = float(i & 1) * 2. - 1.;\n            p0[(axis + 2) % 3] = float((i / 2) & 1) * 2. - 1.;\n            \n            p1 = p0;\n\n            p0[axis] = -1.;\n            p1[axis] = +1.;\n\n\t\t    vec3 s, t, uvi;\n            vec3 pa, pb, pc, pd;\n\n            pa = transformPoint(p0, t0);\n            pb = transformPoint(p0, t1);\n            pc = transformPoint(p1, t0);\n            pd = transformPoint(p1, t1);\n\n            if(traceBilinearPatch(ro, rd, pa, pb, pc, pd, s, t, uvi))\n                col += colourRamp(uvi.x * .5);\n            \n            pa = transformPoint(p0, t1);\n            pb = transformPoint(p0, t2);\n            pc = transformPoint(p1, t1);\n            pd = transformPoint(p1, t2);\n\n            if(traceBilinearPatch(ro, rd, pa, pb, pc, pd, s, t, uvi))\n                col += colourRamp(.5 + uvi.x * .5);\n        }\n    }\n\n    //col=vec3(0);\n\tvec3 s, t, uvi;\n    //if(traceBilinearPatch(ro, rd, vec3(-1,-1,0),vec3(+1,-1,0),vec3(-1,+1,0),vec3(+1,+1,0), s, t, uvi))\n      //  col=vec3(1);\n\n    fragColor.rgb = col * .9;\n\n    // Gamma correction\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}]}