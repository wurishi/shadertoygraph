{"ver":"0.1","info":{"id":"4l3cRM","date":"1531931829","viewed":176,"name":"shapeshift void","username":"Abvadabra","description":"Wanted to create the feeling of something dynamic, unstable.\nProbably need some kind of AA","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4djSzd","filepath":"https://soundcloud.com/danil-tube/013a","previewfilepath":"https://soundcloud.com/danil-tube/013a","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define D 2.069\n#define L 0.15\n#define PI atan(1.) * 4.\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nvec3 opTranslate(vec3 p, vec3 t){\n\treturn p - t;\n}\n\nvec3 opRotate(vec3 p, vec3 axis, float angle){\n\tmat4 mat = rotationMatrix(axis, angle);\n    return (mat * vec4(p, 1.)).xyz;\n}\n\nvec3 opTwist( vec3 p )\n{\n    \n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//https://www.desmos.com/calculator/c2skeqxgv2\nfloat progress(float x){\n    float p = mod(x, D);\n\tfloat m = (p >= L) ? 1. : smoothstep(0., L, p);\n    int k = int(floor(x / D));\n    return (k % 2 == 0) ? m : 1. - m;\n   \n}\n\nfloat choosePrim(int i, vec3 p){\n    switch(i){\n    case 1: return sdBox(p, vec3(0.5));\n\tcase 2: return sdEllipsoid(p, vec3(0.2, 0.8, 0.8));\n    case 3: return udRoundBox(p, vec3(0.5), 0.1);\n    case 4: return sdTorus(p, vec2(.6, 0.2));\n    case 5: return sdHexPrism(p, vec2(0.4, 0.8));\n    case 6: return sdCapsule(p, vec3(0.6), vec3(0.1), 0.2);\n    }\n    return 100.;\n}\n\nvec2 scene(vec3 p){\n    float distance = 0.;\n    \n    p = opTranslate(p, vec3(0., 0., 5.) + cos(iTime * 40.) * 0.01);\n    p *= sin(iTime * 60.) * 0.005 + 1.;\n    \n    \n    vec3 boxP = opRotate(p, vec3(1., 1., 0.), iTime);\n    int i = int(floor(iTime / D));\n    if((i % 2) == 0) i = i - 1;\n    float prim = choosePrim(i % 5 + 1, boxP);\n    float sphere = sdSphere(p, 0.5);\n    \n    distance = mix(prim, sphere, progress(iTime));\n    \n\treturn vec2(sdHexPrism(p, vec2(0.5)), 1.);\n}\n    \nvec2 raymarch(vec3 position, vec3 direction){\n    float totalDistance = 0.1;\n    \n    for(int i = 0; i < 40; i++){\n    \tvec2 result = scene(position + direction * totalDistance);\n        \n        if(result.x < 0.01)\n            return vec2(totalDistance, result.y);\n        \n        totalDistance += result.x * .7;\n        \n        if(totalDistance > 100.)\n            break;\n    }\n    \n    return vec2(100., 0.);\n}\n\n\nvec3 normal(vec3 ray_hit_position, float smoothness){\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n}\n\n#define PI atan(1.) * 4.\n\n//taken from https://github.com/wsmind/js-pride/blob/master/shaders/rainbow.glsl\nvec3 rainbow(float x)\n{\n\t/*\n\t\tTarget colors\n\t\t=============\n\t\t\n\t\tL  x   color\n\t\t0  0.0 vec4(1.0, 0.0, 0.0, 1.0);\n\t\t1  0.2 vec4(1.0, 0.5, 0.0, 1.0);\n\t\t2  0.4 vec4(1.0, 1.0, 0.0, 1.0);\n\t\t3  0.6 vec4(0.0, 0.5, 0.0, 1.0);\n\t\t4  0.8 vec4(0.0, 0.0, 1.0, 1.0);\n\t\t5  1.0 vec4(0.5, 0.0, 0.5, 1.0);\n\t*/\n\t\n\tfloat level = floor(x * 6.0);\n\tfloat r = float(level <= 2.0) + float(level > 4.0) * 0.5;\n\tfloat g = max(1.0 - abs(level - 2.0) * 0.5, 0.0);\n\tfloat b = (1.0 - (level - 4.0) * 0.5) * float(level >= 4.0);\n\treturn vec3(r, g, b);\n}\n\n\nvec3 background(vec2 p){\n   \t\n    p *= 1. + abs(sin(iTime * 40.)) * 0.005;\n\tfloat angle = atan(p.y, p.x) + iTime;\n\tif(angle < 0.) angle += PI * 2.;\n\t\n\tangle -= PI * sin(length(p) * 20.);\n\n\tvec3 color = 1. - rainbow(mod(angle, PI * 2.) / (PI * 2.));\n\tcolor *= (length(p) - .3);\n\tfloat gray = dot(color, vec3(0.299, 0.587, 0.114));\n\tcolor = mix(color, vec3(gray), 1.);\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2. - 1.;\n    vec2 pos = uv;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float z = -9.;\n    vec3 direction = normalize(vec3(uv, -z));\n    vec3 origin = vec3(0., 0., z);\n    \n    vec2 result = raymarch(origin, direction); \n    float fog = pow(1.0 / (1.0 + result.x), 0.45);\n    \n    vec3 color = (int(round(result.y)) == 0) ? vec3(0.) : vec3(1.);\n    \n    vec3 intersection = origin + direction * result.x;\n\tvec3 norm = normal(intersection, 0.01);\n    \n    vec3 lightDir = normalize(vec3(0., 1., 0.));\n\t\n    float diffuse = dot(lightDir, norm);\n\tdiffuse = diffuse * .5 + .5;\n    \n    vec3 lightColor = vec3(2.);\n    vec3 ambientColor = vec3(.4);\n    vec3 diffuseLit = color * (diffuse * lightColor + ambientColor);\n    \n    vec2 l = pow(pos, vec2(3.));\n    vec3 bg = background(uv) - 0.8 * (dot(l, l));\n    vec3 scene = vec3(diffuseLit) * fog;\n    vec3 c = (result.x < 100.) ? scene : bg;\n    fragColor = vec4(c, 1.);\n    \n}","name":"Image","description":"","type":"image"}]}