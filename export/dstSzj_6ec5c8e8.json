{"ver":"0.1","info":{"id":"dstSzj","date":"1680120009","viewed":68,"name":"strobe field","username":"lainga2","description":"it's like those stroboscopes they used to calibrate Zeiss cameras","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["chromaticaberration","abstract","bands","field","stripes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float freq = 10.;\nconst float sharp = .04;\n\nconst vec3 aber = vec3(-.04, 0., .04);\n\n//#define SHOW_RAMP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 ofs = aber + iTime * .5;\n    \n    // generate field between two poles\n    float pos = length(uv - vec2(.5, 0.));\n    float neg = length(uv - vec2(-.5, 0));\n    float v = pos - neg;\n    \n    // this is a triangular wave, but it could also be a sine, it just has to be periodic\n    vec3 ramp_v = 2. * abs(mod((v * freq + ofs), 1.) - .5);\n    \n    ramp_v -= (sin(iTime * .25)) * v;\n\n#ifdef SHOW_RAMP\n    fragColor = vec4(ramp_v, 1.);\n#else\n    float disc = 1. - length(uv);\n    float grille = 1. + length(uv) * .01 * sin(2048. * uv.y);\n    vec3 band_v = smoothstep(.5 - sharp, .5 + sharp, ramp_v * disc * grille);\n    fragColor = vec4(band_v, 1.);\n#endif\n}","name":"Image","description":"","type":"image"}]}