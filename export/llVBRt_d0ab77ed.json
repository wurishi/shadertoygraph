{"ver":"0.1","info":{"id":"llVBRt","date":"1543666536","viewed":619,"name":"dart throwing / space filling 2c","username":"FabriceNeyret2","description":"A very naive dart-throwing  algorithm to make space-filling triangles.\nref: [url]http://paulbourke.net/fractals/randomtile/[/url]\n\nultimate MIPmap is used to detect intersections. \n( Using CubeMap to avoid the MIPmap horrible bugs on non-pow2 textures )","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["short","filling","gpmipmap","gpcubemaps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// triangle variant of https://shadertoy.com/view/ltVBRt\n// cubeMap variant of https://shadertoy.com/view/ltlfRl\n// See motivations in Common. Spoiler: MIPmap on non-pow2 texture is totally bugged.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = (U-.5*R)*R/R.y + .5*R;         // compensates window aspect ratio\n    O = texture(iChannel0, F0(U/R));\n\n    O = O.g > 0. ? vec4(1) : O.b == 0. ? vec4(0) : .6 + .6 * cos( 6.3*O.b + vec4(0,23,21,0));\n                                       // fillmeter\n    U /= R; if ( abs(U.x+.2)<.05 && U.y < textureLod(iChannel0, vec3(1,0,0), 99.).r ) O++;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Why using cubeMaps ?\n// - 6 textures in 1\n// - 1024 x 1024. Meaning:  MIPmap no longer bugged !\n//   ( MIPmap on non-pow2 is bugged on linux, and horribly bugged on Windows ).\n// All the G.P.MIPmap algo are now at hand ! https://www.shadertoy.com/results?query=gpmipmap\n//\n// Still, attention: - only half-floats are stored. \n//                   - 6Mpix whatever windowsize.\n\n// access to faces 0,1,2. Use -F0,-F1,-F2 for the 3 others.\n#define F0(U) vec3( 1 , 1.-2.*(U).yx )           // to index the 6 faces\n#define F1(U) vec3( 2.*(U).x-1. , 1 , 2.*(U).y -1. )\n#define F2(U) vec3( 2.*(U).x-1. , 1. -2.*(U).y , 1 )\n\nint faceID(vec3 D) {\n    vec3 A = abs(D); // seek for max direction: i = invmax(abs(D[i]))\n    int i = 0; \n    float      M = A.x; \n    if (A.y>M) M = A.y, i = 1;\n    if (A.z>M) M = A.z, i = 2;\n    return i + 3* int(D[i]<0.); // faceID\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// principle : O.a stores intersection = previous * tested disk.\n//             Ultimate MIPmap = 0 => no intersection => state += tested disk.\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 C, vec3 D )\n{\n    if (faceID(D)>0) return; // using only face 0\n    O -= O;\n       \n//#define rad(t) pow(t,-0.2)                  // radius(time)\n#define rad(t) pow(max(1.,t-10.),-0.2)        // radius(time)\n         \nfloat a,b,l;                                  // shape \n#define shape(P,U,r) ( a = 6.28*rand(P).x, P=(P-U)/R,      \\\n                       a += atan(P.x,P.y), l = length(P),  \\\n                       b = 3.14159/3.,                     \\\n                       a = mod(a,2.*b)-b,                  \\\n                       step( 0., r/R.y - l * cos(a) ) )\n  \n#define rand(p)  fract( 43758.5453123 * sin( p* vec2(12.9898, 78.233)) )\n \n    int i = iFrame;\n    if (i == 0 ) { O-=O; return; } \n    vec2 R = iResolution.xy, P;               // 1024\n    \n    O = texture(iChannel0, F0(U/R));          // previous state\n    float v = textureLod(iChannel0, vec3(1,0,0), 99.).a, // result of .g collision test\n         r0 = .2*R.y,\n          r = r0 * rad(float(i));             // radius time-decrease law\n    if (v==0.) O.r += O.g,                    // no collision between .r and .g: accept .g\n               O.b += r/r0* min(O.g,1.);      // drawable version (we could antialias there).\n            // O.b += (16./r)*float(0.<O.g);  // variant (to use with rainbow in Image)\n    O.g = 0.;                                 // erase .g, reset test buffer .a\n    O.a = O.r;\n    P = rand(vec2(i))*R;                      // try new disk\n    O.g += shape(P,U,r);                      // temptative shape stored in .g\n    O.a *= float(O.g>0.);                     // intersection in .a. MIPmap cumulates on whole image\n}\n","name":"Cube A","description":"","type":"cubemap"}]}