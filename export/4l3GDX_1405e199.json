{"ver":"0.1","info":{"id":"4l3GDX","date":"1471916876","viewed":335,"name":"Frozen Moon","username":"xwize","description":"Use the mouse to look around.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","planets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat octaves6(vec3 q)\n{\n    float f = 0.0;\n    const int n = 6;\n    float ti = 1.0;\n    for(int i = 0; i < n; ++i)\n    {\n        f += noise(q * ti ) / ti;\n        ti *= 2.0;\n    }\n    return f;\n}\n\n\nmat4 lookAtInv(vec3 eyePos, vec3 targetPos, vec3 upVector)\n{\n    vec3 forward = normalize(targetPos - eyePos);\n    vec3 right = normalize(cross(forward,upVector));\n    vec3 newUp = normalize(cross(right,forward));\n    \n    highp mat4 r;\n    r[0] = vec4(right,0.0);\n    r[1] = vec4(newUp,0.0);\n    r[2] = vec4(-forward,0.0);\n    r[3] = vec4(eyePos,1.0);\n    return r;\n}\n\nfloat starFunc(vec3 p)\n{\n\tfloat a = 0.0;\n\tfloat fp = 0.75;\n\tconst int n = 17;\n\tfloat pa = 0.0;\n\t\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tp=abs(p)/dot(p,p)-fp;\n\t\ta+=abs(length(p)-pa);\n\t\tpa=length(p);\n\t}\n\t\n\ta /= float(n);\n\treturn a*a*a*0.625;\n}\n\nvec3 galaxy(vec3 start, vec3 dir)\n{\n    vec3 p = start+dir*100.0;\n    p += vec3(0.0,150.0,0.0);\n   \n    vec3 c = vec3(starFunc(p)) * vec3(1.2,1.0,2.0);\n    p += vec3(10.1,15.2,10.4);\n\tc += vec3(starFunc(p)) * vec3(1.2,1.2,3.0);\n    p += vec3(10.1,15.2,10.5);\n\tc += vec3(starFunc(p)) * vec3(1.2,1.2,1.4);\n    \n\treturn c*0.03;\n}\n\nfloat snowFunc(vec3 p)\n{\n\tfloat a = 0.0;\n\tfloat fp = 0.75;\n\tconst int n = 32;\n\tfloat pa = 0.0;\n\t\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tp=abs(p)/dot(p,p)-fp;\n\t\ta+=abs(length(p)-pa);\n\t\tpa=length(p);\n\t}\n\t\n\ta /= float(n);\n    a *= 0.625;\n\treturn max(max(a,0.5)-0.5,0.0);\n}\n\nvec3 snowfall(vec3 start, vec3 dir)\n{\n    vec3 p = (start+dir*10.0);\n \tp += vec3(80.0,150.0,10.0);\n    \n    //float n = 0.5*noise(0.4*vec3(iTime));\n    p.x += iTime*13.0;//(iTime + n);\n    p.y += iTime*6.0;\n    p = mod(p,200.0);\n    vec3 c = vec3(snowFunc(p));\n    \n    p += vec3(10.1,15.2,10.4);\n\tc += vec3(snowFunc(p));\n   \n\tc *= 0.1;\n    \n\n\treturn min(c,0.3);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat cloudForm(vec3 q)\n{\n    q.x += sin(q.y*2.0);\n    q.z += cos(q.x*2.0)*0.3;\n   \n    \n    float f = -0.15 +\n       noise(q) +\n       noise(q*2.0) * 0.5 + \n       noise(q*4.0) * 0.25 +\n       noise(q*8.0) * 0.125 +\n       noise(q*16.0)* 0.05 + \n       noise(q*32.0)* 0.025 +\n       noise(q*64.0)* 0.0125;\n           \n    f = min(pow(abs(f),10.0)*0.5,0.5);\n    return f;\n}\n\nvec3 planet(vec2 fragCoord, float angleX )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.4;\n\tvec3 ro = vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.4*ww );\n\n    vec3 rdn = rd;\n    rdn.x = rd.x * cos(angleX) + rd.z*sin(angleX);\n    rdn.z = rd.x * -sin(angleX) + rd.z*cos(angleX);\n    rd = rdn;\n    \n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\tfloat h = 0.0;\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n    \n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n\t\t\n        float lightIntensity = 4.0;\n        float sunNDL = max(0.0,0.05+0.95*(nor.z));\n        \n        \n\t\t{\n            vec3 oceanBlue = vec3(0.0,0.031,0.11);\n            \n            vec3 q = pos;\n            \n            // Ocean\n            col = oceanBlue;\n            col = col * (0.5 + 0.5*noise(q*4.0));\n\t\t\tcol = col * (0.9 + 0.2*noise(q*8.0));\n            col = col * (0.9 + 0.2*noise(q*16.0));\n            col = col * (0.9 + 0.1*noise(q*32.0));\n            col = col * (0.9 + 0.1*noise(q*64.0));\n            \n            // Land\n            q = m * q * 2.01;\n            \n            float hm = octaves6(q+vec3(137.0)) / 1.5;\n            hm *= hm;\n            \n            f = hm;\n            float landBlend = min(4.0*max(f-0.3,0.0),1.0);\n            \n            float nG = exp(-abs(f-0.4)*20.0);//max(f - 0.4,0.0);\n            float nD = exp(-abs(f-0.6)*20.0);//3.0*max(f - 0.75,0.0);\n            float snowLevel = 0.8+ noise(q*64.0)*0.1;\n            float nS = exp(-abs(f-snowLevel)*20.0);\n            \n            vec3 snow = vec3(0.85,0.85,0.85)/1.85;\n            vec3 desert = vec3(1.5,1.3,1.0)/13.0;\n            vec3 grass = vec3(1.0,1.3,0.5)/12.0;\n            \n\t\t\tfloat normn = nG + nD + nS;\n            \n            float grassD = 1.0 + \n                (noise(q*128.0) + noise(q*64.0) + noise(q*32.0))*0.5;\n            \n            float snowD = 1.0 + (noise(q*vec3(5.0,1.0,1.0)*3.0)\n                + noise(q*16.0)*0.5 + noise(q*64.0)*0.5)*0.25;\n            \n            float desertD = 1.0 + noise(q*vec3(1.0,7.0,1.0)*3.0)\n                + noise(q*32.0)*0.5 + noise(q*64.0)*0.5;\n            \n            vec3 land = (desertD*desert*nD + grassD*grass*nG + snowD*snow*nS)/normn;\n            col = mix(col,land,landBlend);\n            \n            float shore = clamp(1.42*pow(1.0-abs(landBlend-0.4),1.0)-1.2,0.0,1.0);\n            col = mix(col, col + vec3(0.0,0.1,0.05),shore);\n        \n            \n            // Cloud shadows\n            q = m * q * 2.01 + iTime*0.03;\n            vec3 off = vec3(0.1);\n\t\t\tf = cloudForm(q+off);\n            f = 0.2 + 0.8*pow(1.0 - f*0.75,2.0);\n            col = col * f;\n            \n            // Clouds  \n\t\t\tf = cloudForm(q);\n            vec3 cloudCol =\n                vec3(0.2)+\n                0.7*noise(q*2.0) +\n                0.4*noise(q*6.0) +\n                0.2*noise(q*16.0) +\n                0.05*noise(q*32.0) + \n                0.04*noise(q*64.0);\n            cloudCol = (cloudCol + f*0.05)*0.55;\n            float opacityGain = 1.4;\n            float brightnessGain = 0.7;\n            col = mix(col,cloudCol*brightnessGain,min(f*opacityGain,1.0));\n            \n\t\t}\n\t\t\n        // Depth\n        float depth = tmin * 2.7 / 2.0;\n        \n        // Surface Diffuse Lighting\n\t\tcol *= (0.005 + sunNDL * lightIntensity);\n        \n        // Surface Specular\n        vec3 ref = reflect(nor,-vec3(0.0,0.0,-1.0));\n        float sunRDE = max(dot(ref,rd),0.0);\n        float spec = 0.125*pow(sunRDE,512.0);\n        col += spec*mix(col,vec3(1.0),0.05)*sunNDL;\n        \n        // Inner Atmosphere\n        float atm = -max(-1.0,1.1 - depth);\n        vec3 baseAtmCol = vec3(0.0,0.041,0.11)*2.0;//vec3(0.0,0.5,1.0);//vec3(0.0,0.041,0.11)*1.5;\n        col = mix(col,baseAtmCol*sunNDL*lightIntensity,pow(atm,2.0));\n        \n        // Atmosphere glow\n        float glow = 0.0;\n        const int steps = 8;\n        const float di = (128.0/50.0)/float(steps);\n        for(int i = 0; i < steps; ++i)\n        {\n            vec3 px = ro + rd * float(i)*di;\n            vec3 tosc = sc - px;\n            float d = length(tosc);\n            float x = abs(d - 1.0);\n            float n = 0.01+max((-tosc/d).z,0.0);\n            glow += 5.5 * exp(-x*16.0) * n * di;\n        }\n        vec3 glowCol = glow * baseAtmCol;\n        \n\t\t// Background\n        float sd = 2.0 + sin(iTime*0.1)*0.1;\n        vec3 bckg = galaxy(ro,rd*sd) + glowCol;\n        \n        float frontFace =  dot(rd,ce) < -0.0 ? 1.0 : 0.0;\n        float isBckg = 1.0-exp( -0.00001*tmin*tmin ) * frontFace;\n\t\tcol = mix( col, vec3(bckg), isBckg );\n\t}\n\t\n    return col;\n}\n\nhighp float terrain(highp vec2 p)\n{\n    /*vec3 q = 0.5*vec3(p.x,0.2,p.y);\n    \n    float f = 0.0;\n    f += noise(q);\n    f += noise(q*2.0)*0.65;\n    f += noise(4.0*q)*0.35;\n    //f += noise(8.0*q)*0.05;\n    \n    //f += noise(16.0*q)*0.02;\n \t//f += noise(32.0*q)*0.01;\n    //f += noise(64.0*q)*0.005;\n    //f += noise(128.0*q)*0.0025;\n    \n    f *= f;\n    f *= f;\n    \n    float l = dot(p,p);\n    f *= (0.6 + 0.025*l);*/\n    \n    highp float f = 0.0;\n    \n    // Coarse\n    highp float l = dot(p,p);\n    //vec3 s = texture(iChannel1,p.xy*0.02).rgb;\n   // f += (s.x+s.y+s.z)*0.5;\n    f += texture(iChannel1,p.xy*0.020,2.0).r;\n    f += texture(iChannel1,p.xy*0.02,1.0).r;\n    //f = sin(p.x)*sin(p.y);\n    f *= f;\n    f *= (0.6 + 0.01*l*exp(-max(l-120.0,0.0)*0.01));\n    //f *= 0.43;\n    //f *= 0.65;\n    //f *= 2.0;\n    //f *= pow(1.0 - 0.24*cos(p.x/2.0),2.0);\n    //f *= 0.75;\n   // f *= min(l*0.005,2.0);\n    // Detail\n    //f += 0.2*texture(iChannel1,p.xy*0.2,0.0).g;\n    \n    \n    return f;\n}\n\nhighp float terrainDetailed(vec2 p)\n{\n    return terrain(p) + 0.2*texture(iChannel1,p.xy*0.2,0.0).g;\n}\n\nvec3 terrainNormal(vec2 p)\n{\n    float eps = 1.0/1024.0;\n    \n\thighp vec2 dx = vec2(eps,0.0);\n    highp vec2 dy = vec2(0.0,eps);\n    \n    highp vec2 px = p + dx;\n    highp vec2 py = p + dy;\n    \n    highp float h = terrainDetailed(p.xy);\n    highp vec3 t = vec3(px.x,terrainDetailed(px),px.y) - vec3(p.x,h,p.y);\n    highp vec3 b = vec3(py.x,terrainDetailed(py),py.y) - vec3(p.x,h,p.y);\n    \n    t = normalize(t);\n    b = normalize(b);\n    \n    return normalize(cross(b,t));        \t\t\n}\n\nfloat terrainShadow(vec3 p, vec3 dir)\n{\n    vec3 s = p;\n    const int n = 128;\n    float di = 0.01;\n    float dii = 0.001;\n    float light = 1.0;\n    for(int i = 0; i < n; ++i)\n    {\n        s += dir * di;\n        float h = terrain(s.xz);\n        float depth = max(h - s.y + 0.1,0.0);\n        light -= 0.001*exp(depth*16.0);\n        di += dii;\n    }\n    \n    return max(light,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = 1.4;//iResolution.y / iResolution.x;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float cz = 0.0;//-iTime*8.0;\n    float cx = 0.0;;//sin(iTime)*1.5;\n    float cy = 0.0;//sin(iTime*0.9)*1.5;\n    \n    float mx = (iMouse.x / iResolution.x) - 0.5;\n    \n    float angleX = 0.0;//1.5;// + mx * 6.28;\n  \n    vec3 co = vec3(cx,4.0+cy,cz);\n    vec3 ct = co + vec3(-50.0*sin(angleX),1.0,-50.0*cos(angleX));\n    vec3 cu = vec3(0.0,1.0,0.0);\n    \n\tmat4 cm = lookAtInv(co,ct,cu);\n    \n\tvec3 ro = vec3((uv.x-0.5)*aspect,uv.y-0.5,0.0);\n\tvec3 rd = vec3(aspect*(uv.x-0.5),uv.y-0.5,-0.75);\n\trd = normalize(rd);\n    \n    ro = ( cm * vec4(ro,1.0) ).xyz;\n    rd = ( cm * vec4(rd,0.0) ).xyz;\n    \n    vec3 nor = vec3(0.0);\n    vec3 rad = vec3(0.0);\n    \n    vec3 orange = vec3(1.0,0.4,0.0);\n    vec3 purple = vec3(0.4,0.1,1.0);\n    \n    float sunIntensity = 5.0;\n    \n    vec3 atmosTop = purple * 4.0 * 0.7;\n    vec3 atmosBot = vec3(1.0,1.0,0.7) * 4.0 * 0.2;\n    vec3 atmos = mix(atmosTop,atmosBot,-(rd.y+0.1)*0.5+0.5);\n    \n    //rad = mix(planet(fragCoord,angleX*1.25),atmos,0.2);\n\n\trad = mix(5.0*planet(fragCoord,angleX*1.25),atmos,0.7);\n    \n    const int n = 256;\n    float di = 0.1;\n    float dii = 0.001;\n    float hit = -1.0;\n    float lh = 0.0;\n    float ly = 0.0;\n    highp vec3 p = ro;\n    float shad  = 0.0;\n    \n    vec3 top = normalize(vec3(0.0,0.3,-1.0));\n    vec3 toa = normalize(vec3(0.0,1.0,0.0));\n    vec3 tos = normalize(vec3(-1.0,0.1,1.0));\n    vec3 tob = normalize(-tos);\n    \n    for(int i = 0; i < n; ++i) {\n\n        float h = terrain(p.xz);\n\n        if(p.y < h) {\n            float t = (lh-ly)/(p.y-ly-h+lh);\n            p -= rd * di * (1.0 - t);\n            nor = terrainNormal(p.xz);\n            hit = 1.0;\n\n            break;\n        }\n\n        lh = h;\n        ly = p.y;\n       \n        p += rd * di;\n        di += dii;\n    }\n    \n    if(hit > 0.0) {\n         \n        vec3 sp = vec3(p.x,p.y+0.01,p.z);\n        shad = terrainShadow(sp,tos);\n        \n        nor.y += noise(p*24.0)*0.25;\n        nor = normalize(nor);\n\n        vec3 dlp = max(0.0,dot(nor,top)) * vec3(0.8,0.8,1.0)*0.2;// * 3.5;\n        vec3 dla = max(0.0,dot(nor,toa)) * 0.1 * atmos;\n        vec3 dls = max(0.0,dot(nor,tos)) * sunIntensity * vec3(1.0) * shad ;\n        vec3 dlb = max(0.0,dot(nor,tob)) * sunIntensity * vec3(0.3,0.3,0.25);\n\n        vec3 rock = vec3(0.5,0.4,0.3)/2.0;\n        vec3 frost = vec3(1.0);\n\n        float fra = clamp(pow(nor.y+noise(p)*0.6,8.0),0.0,1.0);\n        vec3 diffuse = mix(rock,frost,fra);\n\n        rad = (dlp + dlb + dls + dla) * diffuse;\n        \n        float atmosThickness = 8.0/max(1.0,p.y);\n        float fg = 1.0 - exp(-atmosThickness*0.07*length(p - ro));\n        rad = mix(rad,atmos,clamp(fg,0.0,0.7));\n    }\n    \n  \tfloat snowIntensity = 3.0;\n    rad += snowIntensity * snowfall(rd+vec3(0.0,fract(iTime),0.0),ro);\n    \n    //float vgn = 1.0 - 0.75*length(vec2((uv.x-0.5)*aspect,uv.y-0.5));\n    float vgnX = 1.0 - abs(uv.y-0.5)*1.75;\n    float vgnY = 1.0 - abs(uv.x-0.5);\n    //rad *= vgn * 1.15;\n    rad *= vgnX * 0.9 * vgnY;\n    rad = sqrt(rad);\n\tfragColor = vec4(rad,1.0);\n}","name":"Image","description":"","type":"image"}]}