{"ver":"0.1","info":{"id":"dt33Ds","date":"1683552611","viewed":111,"name":"y=k/x - Intersection","username":"Poisson","description":"Just y = k/x intersection using a quadratic equation.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","raytracing","raytracer","ray","math","raycasting","intersection","graph","quadratic","raycaster","maths","intersector","1x"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// circle sdf\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// segment sdf\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h);\n}\n\n// ray sdf\n// o is the origin\n// d is the direction\nfloat sdRay(vec2 p, vec2 o, vec2 d) {\n    vec2 po = p-o;\n    float h = dot(po,d);\n    return length(po - d*h);\n}\n\n// sdf antialiasing function\nfloat antialias(float d) {\n    #if 1\n    float idf = iResolution.y;\n    #else\n    float dx = dFdx(d);\n    float dy = dFdy(d);\n    float idf = 1./length(vec2(dx,dy));\n    #endif\n    return clamp(.5-d*idf, 0., 1.);\n}\n\n// y=k/x sdf approximation\n// it's a hyperbola rotated at 45 degrees\n\nfloat sdOOX(vec2 p, float k) {\n    p = p.x + vec2(-1,1)*p.y; // rotation\n    float x2 = p.x*p.x/2.;\n    float h = 1. + x2/(x2+2.*k);\n    \n    return sqrt((x2+2.*k)/h) - abs(p.y)/sqrt(2.*h);\n}\n\n// ray vs y=k/x intersection function\n\n/* \nWrite the equation:\n\ny = k/x\nxy = k\n(ro.x + rd.x*t)*(ro.y + rd.y*t) - k = 0\n(rd.x*rd.y)*t^2 + (ro.x*rd.y + rd.x*ro.y)*t + ro.x*ro.y - k = 0\n\n*/\n\n/*\nSolve quadratic equation:\n\na = rd.x*rd.y;\nb = ro.x*rd.y + rd.x*ro.y\nc = ro.x*ro.y - k\n\nΔ = b^2 - 4ac\nt1 = -b - sqrt(Δ) / (2a)\nt2 = -b + sqrt(Δ) / (2a)\n\n*/\n\nvec2 iOOX(vec2 ro, vec2 rd, float k) {\n    // solve quadratic equation    \n    float a = rd.x*rd.y;\n    float b = ro.x*rd.y + rd.x*ro.y;\n    float c = ro.x*ro.y - k;\n    float h = b*b - 4.*a*c; // discriminant\n    \n    if (h<0.) return vec2(-1); // no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/(2.*a);\n    \n    /* \n    // another method\n    float u = rd.y/rd.x;\n    float v = ro.x;\n    float w = ro.y;\n    \n    float b = w - u*v;\n    float h = b*b + 4.*u*k;\n    if (h<0.) return vec2(-1);\n    h = sqrt(h);\n    \n    float p = (-b - h)/(2.*u) - v;\n    float q = (-b + h)/(2.*u) - v;\n    \n    return sqrt(1.+u*u)*vec2(p,q);\n    */\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p =  (fragCoord - .5*iResolution.xy) / iResolution.y;\n    // normalized mouse coordinates\n    vec2 mo = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n      \n    // constant of y=k/x\n    float k = .06*(.5+.5*sin(1.7*iTime));\n      \n    vec3 col;\n      \n    { // draw background\n    col = vec3(.45+.55*p.y)*.03;\n    col *= 1.+.35*smoothstep(.5,-.5,cos(p.x*64.)*cos(p.y*64.)); // grid\n\n    float d = min(sdSegment(vec2(p.x,abs(p.y)), vec2(.85,0), vec2(.81,.015)),\n                  sdSegment(vec2(abs(p.x),p.y), vec2(0,.47), vec2(.015,.43)));\n    \n    d = min(d, min(sdSegment(p, vec2(-10,0), vec2(.85,0)), \n                   sdSegment(p, vec2(0,-10), vec2(0,.47))));\n    \n    col = mix(col, vec3(.75), antialias(d-.0025));\n    }\n    \n    { // draw curve\n    float d = sdOOX(p, k); // distance\n    col = mix(col, vec3(1), .02*step(d,0.)); // fill\n    col = mix(col, vec3(1), antialias(abs(d)-.004)); // outline\n    }\n    \n    // create ray\n    vec2 ro = vec2(-.65,-.25); // ray origin\n    // ray direction\n    vec2 rd = iMouse.z>0. ? mo : vec2(.1);\n         rd = normalize(rd - ro);\n    \n    { // draw ray\n    col = mix(col, vec3(.5), antialias(sdRay(p, ro, rd)-.002)); // ray\n    \n    vec2 tp = ro + rd*.16;\n    vec2 rdn = vec2(-rd.y,rd.x);\n      \n    // draw arrow\n     float d = min(min(sdSegment(p, ro, tp),\n                       sdSegment(p, tp, tp+.035*normalize(rdn-2.*rd))),\n                       sdSegment(p, tp, tp-.035*normalize(rdn+2.*rd)));\n      \n    col = mix(col, vec3(.75), antialias(d-.0035));\n    col = mix(col, vec3(1,.7,.06), antialias(sdCircle(p-ro, .02))); // origin\n    }\n    \n    { // draw intersection points\n    vec2 t = iOOX(ro, rd, k); // intersection distances\n    // intersection points\n    vec2 p1 = ro + rd*(t.x<0. ? 1e10 : t.x);\n    vec2 p2 = ro + rd*(t.y<0. ? 1e10 : t.y);\n    \n    // intersection points sdf\n    float d = min(sdCircle(p-p1, .02),\n                  sdCircle(p-p2, .02));\n    \n    col = mix(col, vec3(.05,.2,1), antialias(d));\n    }\n        \n    col = pow(col, vec3(.4545)); // gamma correction\n        \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    col *= .4+.6*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n            \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}