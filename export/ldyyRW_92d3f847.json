{"ver":"0.1","info":{"id":"ldyyRW","date":"1521147760","viewed":413,"name":"Borderlands-like edge detection","username":"andunai","description":"A very simple borderlands-like edge detection shader. Good for contrast images.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["edgedetection","edge","borderlands"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define THRESHOLD 0.25 // Should be somewhere in range [0;1)\n#define DEBUG \t// apply effect to right part of the screen only\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    #ifdef DEBUG\n    if (fragCoord.x/iResolution.x > 0.5) {\n    #endif\n    float dist = 0.0;\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            // distance() here will be in range 0.0 to pow(2, 1/3)\n            // which is a distance between opposite cube vertices (0,0,0 and 1,1,1),\n            // so let's normalize it by dividing it by pow(2, 1/3) ~= 1.2599\n            dist += distance(\n                fragColor.xyz,\n                texture(iChannel0, (fragCoord + vec2(x, y)) / iResolution.xy).xyz\n            ) / 1.2599;\n        }\n    }\n    if (dist > THRESHOLD) {\n\t    fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), dist);\n    }\n    #ifdef DEBUG\n    }\n    #endif\n/*    if (dist > THRESHOLD) {\n        fragColor.rgb = vec3(0.0, 0.0, 0.0);\n        // fragColor.rgb = (fragColor.rgb + vec3(0.0, 0.0, 0.0) * 4.0) / 5.0;\n    }\n*/\n}\n","name":"Image","description":"","type":"image"}]}