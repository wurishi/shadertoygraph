{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Copyright (c) 2013 Andrew Baldwin (baldand)\n// License = Attribution-NonCommercial-ShareAlike (http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\n\n// Comment these next two lines out in case\n// it is too slow or doesn't work (e.g. Chrome/Windows)\n#define SHADOW\n//#define AO\n\nfloat rnd(vec2 n)\n{\n  return fract(sin(dot(n.xy, vec2(12.345,67.891)))*12345.6789);\n}\n\nfloat rnd2(vec3 n)\n{\n  return fract(sin(dot(n.xyz, vec3(12.345,67.891,40.123)))*12345.6789);\n}\n\nvec3 rnd3(vec3 n)\n{\n\tvec3 m = floor(n)*.00001 + fract(n);\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec3 mp = (31415.9+m)/fract(p*m);\n\treturn fract(mp);\n}\n\nvec3 rotateZ( vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nvec3 rotateZ0p2( vec3 p )\n{\n    mat2  m = mat2(0.9800665778412416,-0.19866933079506122,0.19866933079506122,0.9800665778412416);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nvec3 rotateY( vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    mat2  m = mat2(c,-s,s,c);\n\tvec2 xz = m*p.xz;\n    vec3  q = vec3(xz.x,p.y,xz.y);\n    return q;\n}\n\nfloat tube( vec3 p, vec3 c, float l, float taper )\n{\n  float tube = length(p.xy-c.xy);\n  float outer = tube - c.z - taper;\n  float inner = tube - c.z*.8 - taper;\n  return max(max(max(outer,-inner),-p.z),-l+p.z);\n}\n\nfloat barY( vec3 p, vec3 c, float l, float taper )\n{\n  float tube = length(p.xz-c.xy);\n  float outer = tube - c.z - taper;\n  return max(max(outer,-p.y),-l+p.y);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdTorusXY( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdTorusYZ( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\nfloat valve( vec3 p, vec3 c, float x)\n{\n    float d = length(p.xz-c.xy);\n\tfloat d2 = max(max(d - c.z*.35,p.y-6.-x),-p.y+3.5+x);\n\tfloat d3 = max(max(d - c.z*1.,-p.y+6.+x),p.y-6.2-x);\n\td -= c.z;\n\td = max(max(d,-p.y),p.y-5.5);\n\treturn min(min(d,d2),d3);\n}\n\nfloat saw(float t)\n{\n\treturn abs(fract(t*.5)*2.-1.)*2.-1.;\n}\n\nvec2 trumpet(vec3 pos, float time)\n{\n\tif (pos.x<-4.) return vec2(-(pos.x+3.),0.);\n\tif (pos.x>4.) return vec2(pos.x-3.,0.);\n\tif (pos.y<-5.) return vec2(-pos.y-4.,0.);\n\tif (pos.y>4.) return vec2(pos.y-3.,0.);\n\t\n\tfloat zo = 10.0;\n\tfloat bz = -pos.z+zo;\n\tfloat bellTaper = mix(.0,1.0/(1.+.5*bz),smoothstep(-8.,0.,-bz));\n\tfloat tube1 = tube(pos-vec3(0.,0.,-5.), vec3(0.,0.,.4), 16., bellTaper);\n\t\n\tfloat torus = max(sdTorusYZ(rotateZ0p2(pos-vec3(.4,-2.,-5.)), vec2(2.0406776898823855,.4)),pos.z+4.9);\n\tfloat v1 = valve(pos-vec3(0.8,-4.8,0.),vec3(0.,0.,.4),clamp(saw(time*3.5),-.4,0.));\n\tfloat v2 = valve(pos-vec3(0.8,-4.8,1.1),vec3(0.,0.,.4),clamp(saw(time*2.5),-.4,0.));\n\tfloat v3 = valve(pos-vec3(0.8,-4.8,2.2),vec3(0.,0.,.4),clamp(saw(time*5.5),-.4,0.));\n\tfloat bottomfront = tube(pos-vec3(1.6,-3.2,2.8),vec3(0.,0.,.4), 4.1, 0.);\t\n\tfloat bottomfrontjoin = max(max(sdTorus(pos-vec3(1.0,-3.2,2.8),vec2(.6,.4)),pos.z-2.8),-pos.x+1.);\n\tfloat frontbottomend = max(max(sdTorusYZ(pos-vec3(1.6,-1.8,6.9),vec2(1.4,.4)),pos.y),-pos.z+6.9);\n\tfloat toptube = tube(pos-vec3(1.6,-.4,-8.),vec3(0.,0.,.4), 14.9, 0.);\n\tfloat valves = min(min(v1,v2),min(min(toptube,v3),min(frontbottomend,bottomfrontjoin)));\n\tfloat bottomback = tube(pos-vec3(.8,-4.,-5.), vec3(0.,0.,.4), 11.,0.);\n\tfloat loop1 = max(sdTorusYZ(pos-vec3(.8,-3.4,6.),vec2(.6,.4)),6.-pos.z);\n\tfloat looptop1 = tube(pos-vec3(.8,-2.8,2.3),vec3(0.,0.,.4), 3.7, 0.);\n\t\n\tfloat loop2end = max(sdTorusYZ(pos-vec3(1.6,-3.6,-3.),vec2(.6,.4)),3.+pos.z);\n\tfloat loop2top = tube(pos-vec3(1.6,-3.0,-3.),vec3(0.,0.,.4), 2.4, 0.);\n\tfloat loop2topjoin =max(max(sdTorus(pos-vec3(1.,-3.0,-.6),vec2(.6,.4)),-pos.z-.6),-pos.x+1.);\n\tfloat loop2bot = tube(pos-vec3(1.6,-4.2,-3.),vec3(0.,0.,.4), 2.4, 0.);\n\tfloat loop2botjoin =max(max(sdTorus(pos-vec3(1.,-4.2,-.6),vec2(.6,.4)),-pos.z-.6),-pos.x+1.);\n\tfloat loop2 = min(min(loop2end,min(loop2bot,loop2botjoin)),min(loop2topjoin,loop2top));\n\tfloat loop3 = max(sdTorusXY(pos-vec3(1.2,-3.6,1.1),vec2(.6,.4)),1.-pos.x);\n\t\n\tfloat rim = sdTorusXY(pos-vec3(0.,0.,0.95+zo), vec2(2.45,.08));\n\tfloat tubes = min(min(min(min(valves,loop3),looptop1),min(bottomback,loop1)),min(min(tube1,bottomfront),min(torus,loop2)));\n\n\tfloat connect = barY(pos-vec3(1.7,-3.,6.),vec3(0.,0.,.05),2.5,.05*smoothstep(-2.4,-2.5,pos.y)+.05*smoothstep(-1.2,-1.1,pos.y));\n\t\n\tvec2 body = vec2(min(min(rim,connect),tubes),1.);\n\t\n\tfloat mouthpiece = tube(pos-vec3(1.6,-.4,-10.),vec3(0.,0.,.4), 16.9, smoothstep(-8.7,-9.5,pos.z)*.35-.1*smoothstep(-7.8,-8.,pos.z));\n\n\tvec2 res = body;\n\tif (mouthpiece<body.x) {\n\t\tres.x = mouthpiece;\n\t\tres.y = 2.;\n\t}\n\treturn res;\n}\n\nfloat note(vec3 pos)\n{\n\tfloat notebottom = length(pos)-1.;\n\tfloat notestem = max(max(length(pos.xz-vec2(0.,.8))-.2,-pos.y),pos.y-5.);\n\treturn min(notebottom,notestem);\n}\n\nvec2 music(vec3 pos, float time) \n{\n\tvec3 ptz = vec3(pos.x,pos.y+(2.+.1*pos.z)*saw(.5+pos.z*.1)-.1*pos.z+1.,pos.z);\n\tvec3 p = vec3(ptz.xy,mod(min(max(ptz.z-2.*fract(3.*time),10.),100.),2.)-1.);\n\treturn vec2(.3333*note(3.*p),3.);\n}\n\nvec2 map(vec3 pos, float time)\n{\n\t//return max(2.*sin(pos.x*.5)-pos.y+40.,-length(pos-vec3(50.,50.,0))-10.);\n\t// Does pos + ray intersect with the sphere area?\n\tvec2 res = vec2(pos.y+4.85,0.);\n\tvec2 t = trumpet(pos, time);\n\t\n\tvec2 n = music(pos,time);\n\t\n\tif (t.x<res.x) res = t;\n\tif (n.x<res.x) res = n;\n\treturn res;\n}\n\nvec3 normal(vec3 pos, float time)\n{\n\tvec3 eps = vec3(0.001,0.,0.);\n\tfloat dx = map(pos+eps.xyy,time).x;\n\tfloat dy = map(pos+eps.yxy,time).x;\n\tfloat dz = map(pos+eps.yyx,time).x;\n\tfloat mdx = map(pos-eps.xyy,time).x;\n\tfloat mdy = map(pos-eps.yxy,time).x;\n\tfloat mdz = map(pos-eps.yyx,time).x;\n\treturn normalize(vec3(dx-mdx,dy-mdy,dz-mdz));\n}\n\nvec3 model(vec3 rayOrigin, vec3 rayDirection,float time)\n{\n\tfloat t = 0.;\n\tvec3 p;\n\tfloat d = 0.;\n\tbool nothit = true;\n\tvec2 r;\n\tfor (int i=0;i<200;i++) {\n\t\tif (nothit) {\n\t\t\tt += d*.5;\n\t\t\tp = rayOrigin + t * rayDirection;\n\t\t\tr = map(p,time);\n\t\t\td = r.x;\n\t\t\tnothit = d>t*.001 && t<10000.;\n\t\t}\n\t}\n\tt += d*.5;\n\tp = rayOrigin + t * rayDirection;\n\tvec3 n = normal(p,time);\n\tfloat lh = abs(fract(iTime*.1)*2.-1.);\n\tlh = 79.*lh*lh*(3.-2.*lh);\n\tvec3 lightpos = vec3(25.,25.,25.);\n\tvec3 lightdist = lightpos - p;\n\tfloat light = 2.+dot(lightdist,n)*1./length(lightdist);\n#ifdef AO\n\t// AO\n\tfloat at = 0.4;\n\tfloat dsum = d;\n\tvec3 ap;\n\tfor (int j=0;j<4;j++) {\n\t\tap = p + at * n;\n\t\tfloat m = map(ap,time).x;\n\t\tdsum += m/(at*at);\n\t\tat += 0.1;\n\t}\n\tfloat ao = clamp(dsum*.1,0.,1.);\n\tlight = light*ao;\n#endif\n#ifdef SHADOW\n\t// March for shadow\n\tvec3 s;\n\tfloat st;\n\tfloat sd=0.;\n\tfloat sh=1.;\n\tst=.5;//+.5*rnd2(p+.0123+fract(iTime*.11298923));\n\tvec3 shadowRay = normalize(lightpos-p);\n\tnothit = true;\n\tfor (int i=0;i<40;i++) {\n\t\tif (nothit) {\n\t\t\tst += sd*.5;\n\t\t\ts = p + st * shadowRay;\n\t\t\tsd = map(s,time).x;\n\t\t\tsh = min(sh,sd);\n\t\t\tnothit = sd>0.00001;\n\t\t}\n\t}\n\tlight = 5.0*light * clamp(sh,0.1,1.);\n#endif\n\tvec3 m;\n\tm=.5+.2*abs(fract(p)*2.-1.);\n\tm=vec3(1.,.9,.4)*texture(iChannel0,reflect(n,rayDirection)).rgb;\n\tif (r.y==0.) {\n\t\tm=vec3(.9);\n\t} else if (r.y==2.) {\n\t\tm=.3+vec3(m.x+m.y+m.z)*.333;\n\t} else if (r.y==3.) {\n\t\tm=vec3(0.1);\n\t}\n\tvec3 c = vec3(clamp(1.*light,0.,10.))*vec3(m);\n\treturn c; \n}\n\nvec3 camera(in vec2 sensorCoordinate, in vec3 cameraPosition, in vec3 cameraLookingAt, in vec3 cameraUp)\n{\n\tvec2 uv = 1.-sensorCoordinate;\n\tvec3 sensorPosition = cameraPosition;\n\tvec3 direction = normalize(cameraLookingAt - sensorPosition);\n\tvec3 lensPosition = sensorPosition + 2.*direction;\n\tconst vec2 lensSize = vec2(1.);\n    vec2 sensorSize = vec2(iResolution.x/iResolution.y,1.0);\n\tvec2 offset = sensorSize * (uv - 0.5);\n\tvec3 right = cross(cameraUp,direction);\n\tvec3 rayOrigin = sensorPosition + offset.y*cameraUp + offset.x*right;\n\tvec3 rayDirection = normalize(lensPosition - rayOrigin);\n\t// Render the scene for this camera pixel\n\tfloat rt = 0.;//fract(iTime);\n\tvec3 colour = vec3(0.);\n\tfor (int m = 0;m<1;m++) {\n\t\tcolour += 1.*max(model(rayOrigin, rayDirection,iTime),vec3(0.));\n\t}\n\t// Post-process for display\n\tvec3 toneMapped = colour/(1.+colour);\n\t// Random RGB dither noise to avoid any gradient lines\n\tvec3 dither = vec3(rnd3(vec3(uv.xy,iTime)))/255.;\n\t// Return final colour\n\treturn toneMapped + dither;\n}\n\nvec3 world(vec2 fragCoord)\n{\n\t// Position camera with interaction\n\tfloat anim = .5+.5*sin(iTime*.1-.5);\n\tfloat rotspeed = 10.*(anim+iMouse.x/iResolution.x);\n\tfloat radius = (anim+iMouse.y/iResolution.y)*40.;//10.+5.*sin(iTime*.2);\n\t//vec3 cameraPos = vec3(iTime*(10.+iTime*.1),100.*iMouse.y/iResolution.y,100.0*iMouse.x/iResolution.x);\n\t//vec3 cameraTarge = cameraPos + vec3(10.,0.,0.);\n\t//vec3 cameraTarget = vec3(radius*sin(rotspeed),0.+100.*iMouse.y/iResolution.y-50.,radius*cos(rotspeed));\n\t//vec3 cameraPos = vec3(iTime,0.,0.);\n\tvec3 cameraTarget = vec3(0.,-2.5,0.);\n\tvec3 cameraPos = vec3(radius*sin(rotspeed),-2.5,radius*cos(rotspeed));\n\tvec3 cameraUp = vec3(0.,1.,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\treturn camera(uv,cameraPos,cameraTarget,cameraUp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(world(fragCoord),1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfGz7","date":"1365526153","viewed":1252,"name":"Trumpet","username":"baldand","description":"An experiment in distance field modelling. Mostly made up from segments of tori and distorted cylinders.\nUse mouse to look around and zoom in/out","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefield"],"hasliked":0,"parentid":"","parentname":""}}