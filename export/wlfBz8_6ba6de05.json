{"ver":"0.1","info":{"id":"wlfBz8","date":"1595970979","viewed":105,"name":"Living on Surface of 3D Sphere","username":"Gijs","description":"Move camera with 'wasd+space+shift+qe+mouse'. Move player (white dot) with 'ijkl'","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["3d","sphere","geometry","spherical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void draw(inout vec3 col, vec3 p){\n    vec3 playerPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 playerForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 playerRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    \n    col = mix(col, vec3(1,0,0), smoothstep(0.02, 0.01, abs(p.x)));\n    col = mix(col, vec3(0,1,0), smoothstep(0.02, 0.01, abs(p.y)));\n    col = mix(col, vec3(0,0,1), smoothstep(0.02, 0.01, abs(p.z)));\n    col = mix(col, vec3(1), smoothstep(0.05, 0.03, distance(playerPosition, p)));\n    //col = mix(col, vec3(1), smoothstep(0.05, 0.03, distance(playerForward, p)));\n    //col = mix(col, vec3(1), smoothstep(0.05, 0.03, distance(playerRight, p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y*.5;\n    \n    vec3 cameraPosition = texelFetch(iChannel1,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel1,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel1,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel1,ivec2(3,0),0).rgb;\n    \n    vec3 playerPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 playerForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 playerRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    \n    vec3 ori = cameraPosition;\n    vec3 dir = normalize(cameraForward+p.x*cameraRight+p.y*cameraUpward);\n \n    vec3 col = vec3(0);\n \n    //solving ray unit sphere intersection\n    float b = 2.*dot(ori,dir);\n    float c =    dot(ori,ori) - 1.;\n    float d = b*b - 4.*c;\n    \n    if(d>0.){\n        float t1 = (-b + sqrt(d))/2.;\n    \tfloat t2 = (-b - sqrt(d))/2.;\n        \n        float tmin = min(t1,t2);\n        float tmax = max(t1,t2);\n        \n        vec3 hitmin = ori + dir*tmin;\n        vec3 hitmax = ori + dir*tmax;\n        \n        draw(col, hitmax);\n        col *= .5;\n        if(tmin>0.)\n        \tdraw(col, hitmin);\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This buffer handles the player\n//if ANY movement is done fragColor.w becomes 1 for ALL pixels\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x>3 || p.y > 0) return;\n    \n    //should at all times be orthonormal\n    vec3 playerPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 playerForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 playerRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    \n    if(iFrame==0){\n        playerPosition  = vec3(0,0,-1);\n        playerForward   = vec3(0,1,0);\n        playerRight     = vec3(1,0,0);\n        \n        //enforce that it is orthonormal\n        GramSchmidt33(playerPosition, playerForward, playerRight);\n    } \t\t\n    \n    bool forward     = texelFetch(iChannel1,ivec2(73,0),0).x > 0.;\n    bool left        = texelFetch(iChannel1,ivec2(74,0),0).x > 0.;\n    bool backward    = texelFetch(iChannel1,ivec2(75,0),0).x > 0.;\n    bool right       = texelFetch(iChannel1,ivec2(76,0),0).x > 0.;\n    bool interaction = forward||left||backward||right;\n    \n\tfloat stepSize = 0.01;\n    if(forward)  rotate(playerPosition, playerForward,  stepSize);\n\tif(backward) rotate(playerPosition, playerForward, -stepSize);\n    if(right)    rotate(playerPosition, playerRight  ,  stepSize);\n\tif(left)     rotate(playerPosition, playerRight  , -stepSize);\n\n    if(p.x==0){\n    \tfragColor.rgb = playerPosition;\n    }else if(p.x==1){\n        fragColor.rgb = playerForward;\n    }else if(p.x==2){\n        fragColor.rgb = playerRight;\n    }\n    \n    fragColor.w = float(interaction);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This buffer handles the Camera\n//if ANY movement is done fragColor.w becomes 1 for ALL pixels\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x>3 || p.y > 0) return;\n    \n    vec3 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    \n    if(iFrame==0){\n        cameraPosition = vec3( 0, 0, -2);\n        cameraForward  = vec3( 0, 0, 1);\n    \tcameraRight    = vec3( 1, 0, 0);\n    \tcameraUpward   = vec3( 0, 1, 0);\n    } \t\t\n    \n    bool forward     = texelFetch(iChannel1,ivec2(87,0),0).x > 0.;\n    bool left        = texelFetch(iChannel1,ivec2(65,0),0).x > 0.;\n    bool backward    = texelFetch(iChannel1,ivec2(83,0),0).x > 0.;\n    bool right       = texelFetch(iChannel1,ivec2(68,0),0).x > 0.;\n    bool rollleft    = texelFetch(iChannel1,ivec2(81,0),0).x > 0.;\n    bool rollright   = texelFetch(iChannel1,ivec2(69,0),0).x > 0.;\n    bool down        = texelFetch(iChannel1,ivec2(16,0),0).x > 0.;\n    bool up          = texelFetch(iChannel1,ivec2(32,0),0).x > 0.;\n    bool mouseLeft   = iMouse.z>0.;\n    bool interaction = forward||left||backward||right||rollleft||rollright||down||up||mouseLeft;\n    \n    float stepSize = 0.01;\n    \n    cameraPosition += (cameraForward*(float(forward) - float(backward)) +\n        \t\t       cameraRight  *(float(right)   - float(left)    ) +\n        \t           cameraUpward *(float(up)      - float(down)    )\n                      )*stepSize;\n    \n    float r = (float(rollleft)-float(rollright))*0.01;\n    rotate(cameraRight, cameraUpward, r);\n    \n    if(mouseLeft){\n\t\tvec2 s = (iMouse.xy*2. - iResolution.xy)/iResolution.y;\n\t\t\t\n        rotate(cameraForward, cameraRight , s.x*0.02);\n\t\trotate(cameraForward, cameraUpward, s.y*0.02);\n    }\n    \n    if(p.x==0){\n    \tfragColor.rgb = cameraPosition;\n    }else if(p.x==1){\n        fragColor.rgb = cameraForward;\n    }else if(p.x==2){\n        fragColor.rgb = cameraRight;\n    }else if(p.x==3){\n        fragColor.rgb = cameraUpward;\n    }\n    \n    fragColor.w = float(interaction);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"void GramSchmidt33(inout vec3 a, inout vec3 b, inout vec3 c){\n    a = normalize(a);\n    b = b - dot(b,a)*a;\n    b = normalize(b);\n    c = c - dot(c,a)*a - dot(c,b)*b;\n    c = normalize(c);\n}\n\n//inputs should be such that (a,b)=0 \n//rotates a towards b\n//b in the some direction such that (a,b)=0 is uphold\n//if angle=90 degrees than a -> b and b -> -a\nvoid rotate(inout vec3 a, inout vec3 b, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    a =  c*a + s*b;\n    b = -s*a + c*b;\n}","name":"Common","description":"","type":"common"}]}