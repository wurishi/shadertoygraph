{"ver":"0.1","info":{"id":"4c2Gzt","date":"1704527203","viewed":45,"name":"storm before high_flys","username":"chenxianming","description":"coded this scene for screen demo, and this is a showcase benchmark.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["clouds","sky","storm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define I iResolution\n#define v( a ) clamp( a, 0., 1. )\n#define PI 3.1415\n#define rot( r ) mat2(cos(r), sin(r), -sin(r), cos(r) )\n#define rot2( r ) vec2( cos( r ) * 1.2, cos( r * .8 ) * 1.1 )\n#define T( s ) fract( iTime * s ) * PI * 4.\n#define S smoothstep\n// bird rotated\n#define sl( a ) S( .0, 1., sin( a * .1 ) / .3 )\n// pos projection\n#define P vec3 c, p, cp = vec3( 0., 0., -1. ), lk, r; float t, d, i, dp; cp.z += Tl; lk = cp + vec3(0.0, 0.0, 1.); lk.xy += rot2( lk.z ); cp.xy += rot2( cp.z ); vec3 fo = normalize(lk-cp); vec3 rt = normalize(vec3(fo.z, 0., -fo.x ));  vec3 up = cross(fo, rt); r = normalize(fo + u.x*rt + u.y*up)\n#define Tl iTime + 150.\n\n// XT95's cloud fbm\n// https://www.shadertoy.com/view/lss3zr\n//-----------------------------------------------------------------------------\n// Maths utils\n//-----------------------------------------------------------------------------\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\n// wing beats\nbool sw( float t, float a ){\n    return mod( round( t + 5. ), 14. ) == a;\n}\n\nfloat ww( float t ){\n    \n    float r = T( .25 );\n    \n    if( \n        sw( t, 0. ) ||\n        sw( t, 1. ) ||\n        sw( t, 2. )\n    ){\n        r = fract( ( 1.5 + cos( Tl * 5. ) * .04 ) * .25 ) * PI * 4.;\n    }\n\n    return cos( r );\n}\n\n\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n// bird\n\nfloat wings( vec3 p ){\n    // p.xy *= 1.7;\n    \n    p.x -= .1;\n    p.y -= .1;\n    \n    p.z -= pow( p.x, 3. ) * ww(Tl) / 1.4;\n    \n    float d = .5;\n    \n    float g = smax(\n        abs( p.x ) - .35,\n        abs( p.y ) - .15,\n        .05\n    );\n    \n    vec2 p2 = p.xy;\n    \n    p2.y += abs( cos( p2.x ) * .4 );\n    p2.x = abs( p2.x ) - .3;\n    p2.y -= .4;\n    p2.x = abs( p2.x ) - .1;\n    \n    g = smin(\n        g,\n        length( p2 ) - .1,\n        .1\n    );\n    \n    return max(\n        g,\n        abs( p.z ) - .01\n    );\n}\n\nfloat body( vec3 p ){\n    \n    float py = p.y;\n    \n    py *= p.y > 0. ? 2. : 4.;\n    \n    py = clamp( py, -1., 1. );\n    py = pow( py, 2. );\n    \n    py = abs( py );\n    py = abs( py - 1. );\n    \n    py = abs( py ) - .1;\n    \n    return smax(\n        smax( \n            abs( p.x ) - .1 * py,\n            abs( p.y ) - .3 * py,\n            .05\n        ),\n        abs( p.z ) - .1,\n        .1\n    );\n    \n}\n\nfloat tail( vec3 p ){\n    \n    p.y += .2;\n    \n    p.yz *= rot( PI * -.025 + cos( T( .25 ) ) * .05 );\n    p.y -= .2;\n    \n    return max(\n        max(\n            abs( p.x ) - .3 * abs( p.y - .5 ),\n            abs( p.y ) - .15\n        ),\n        abs( p.z ) - .005\n    );\n}\n\nfloat beak( vec3 p ){\n\n    float py = 1. - ( p.y / 2. + .5 );\n    \n    py -= .5;\n    py *= 2.;\n    py = clamp( py, 0., 1. );\n    \n    return max(\n        length( p.xz ) - .3 * py,\n        abs( p.y ) - .1\n    );\n}\n\nfloat paw( vec3 p ){\n    \n    p.x = abs( p.x ) - .1;\n    \n    p.xz *= rot( PI * .25 );\n    p.yz *= rot( PI * .5 );\n    \n    \n    for( float i = 0.; i < 2.; i++ ){\n        p.xz = abs( p.xz );\n        p.xz *= rot( i / 3. * PI );\n    }\n    \n\n    float a = max(\n        length( p.xy ) - .09,\n        -( length( p.xy + vec2( .0, .02 ) ) - .09 )\n    );\n    \n    return max(\n        a,\n        abs( p.z ) - .01\n    );\n}\n\nfloat head( vec3 p ){\n    return length( p ) - .08;\n}\n\nfloat b( vec3 p ){\n    \n    // p.yz *= rot( PI * .2 );\n    p.xy *= rot( cos( Tl * 2. ) * .2 );\n    vec2 r2 = rot2( p.z );\n    p.yz *= rot( atan( r2.x, r2.y ) * .5 );\n    \n    p *= -1.;\n    p.yz *= rot( PI * -.5 );\n    p.z *= -1.;\n    \n    p.xz *= rot( -2. * PI * (1. - sl( ( Tl + 4. ) * 1.5 ) ) );\n    \n    float py = p.z / 2. + .5;\n    \n    float d = .1;\n    \n    vec3 pwing = p;\n    \n    pwing.xz *= rot( ww(Tl) * .3 );\n    \n    if( pwing.x < 0. ){\n        pwing.x *= -1.;\n        pwing.xz *= rot( ww(Tl) * .3 );\n        pwing.xz *= rot( ww(Tl) * .3 );\n    }\n\n    d = smin( \n        wings( pwing + vec3( -.05, .1, 0. ) ),\n        body( p ),\n        .05\n    );\n    \n    d = smin( d, tail( p + vec3( 0., .2, 0. ) ), .02 );\n    \n    d = smin( d, head( p - vec3( 0.0, 0.25, .05 ) ), .02 );\n    \n    d = min( d, beak( p - vec3( .0, .4, .06 ) ) );\n    \n    d = min( d, paw( p - vec3( 0., .0, -.15 ) ) );\n    \n    return d;\n}\n\n// clounds tunnel\nfloat f( vec3 p ){\n    \n    vec2 q = p.xy - rot2( p.z );\n    \n    return 1. - length( q );\n}\n\nfloat cl( vec3 p ){\n    p += fbm( p * 10. ) / 10.;\n    return f( p )*.3+fbm(p* 1.5 - Tl * .05 );\n}\n\nfloat df( vec3 p ){\n    /*\n        or rendering clouds with segments (><) around\n        can maybe sdf target smoothly using this FBM\n        \n        >         <\n           tunnel\n        >         <\n             V\n            fog\n    */\n    \n    return cl( p );\n}\n\nvec3 renderClouds( vec2 u ){\n\n    P;\n    \n    float it = 15., l;\n    \n    for( ; i < it; i++ )\n        p = cp + r * t,\n        p.xy *= rot( i / it * .6 * ( 1. - (p.z / 2. + .5) ) ), // whirl clouds\n        p.y += cos( i / it ) * .1, // noise\n        d = df( p ) * .8889,\n        l = v( d*0.55 )*1.5,\n        // sd clouds\n        // c *= pow( ( d - .3 ) * .9, 3. ), // smoothing dist and add iteration / color when clouds intergrate.\n        c += ( i / it ) * (1.-d) * .1, \n        c += pow( l, 4. ) * ( i / it ), // textured clouds lighting\n        t += d;\n    \n    c *= normalize( p.z / 2. + .5 ); // perspective opacity\n    \n    return c;\n}\n\n// lig utils\n\nfloat gr2( vec2 u, int a ){\n    \n    u = normalize( u );\n    \n    float g = a == 0 ? .4 : .7;\n    \n    u = mod( u, g + cos( Tl ) ) - g * .5;\n    \n    return ( 1. - S( 0., .1, length( u ) - .01 ) ) * .5;\n}\n\nvec4 renderBird( vec2 u ){\n    \n\n    P;\n    \n    for( ; i < 32.; i++ )\n        p = cp + r * t,\n        p.z -= Tl,\n        d = b( p + fbm( p * .2 ) * .3 ),\n        t += d;\n\n    if( d < 1e-3 )\n        c -= dot( vec3( 0., .6, -.4 ), p * .3  ) + v( dot( p, p ) );\n    \n    // after light\n    c += gr2( ( cp.xy * .1 ), 0 ) * .6;\n    \n    // vecs parm 4 = bird flying target\n    return vec4( c, pow( clamp( gr2( 1.-(p.xy * rot( Tl * .1 ) ), 1 ) , 0., .2), 2. ) );\n}\n\n\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    \n    vec2 u = ( V * 2. - I.xy ) / min( I.x, I.y );\n\n    vec4 b = renderBird( u );\n    vec3 c = b.rgb;\n    \n    c += renderClouds( u );\n    c += b.w * .2;\n\n    U = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}