{"ver":"0.1","info":{"id":"3ttyWM","date":"1609239316","viewed":157,"name":"Haru86_RaymarchModeling1","username":"Haru86_","description":"RaymarchModeling","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarchmodeling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(angle) mat2(cos(angle),sin(angle),-sin(angle),cos(angle))\n#define PI 3.14159265\n\nfloat SmoothMin(float d1,float d2,float k)\n{\n    float e1=exp(-k*d1);\n    float e2=exp(-k*d2);\n    return -log(e1+e2)/k;\n}\n\nfloat Cylinder(vec2 p,float size)\n{\n    return length(p)-size;\n}\n\nfloat Torus(vec3 p,vec2 size)\n{\n    return length(vec2(length(p.xy)-size.x,p.z))-size.y;\n}\n\nfloat Box(vec3 p,vec3 size)\n{\n    return length(max(abs(p)-size,0.0));\n}\n\nfloat map(vec3 p)\n{\n\n    p.xy*=rot(iTime);\n    p.xz*=rot(iTime);\n    p.yz*=rot(iTime);\n    \n    float radius=1.0;\n    \n    vec3 pos=p;\n   \n    \n    for(int i=0;i<3;i++)\n    {\n        pos=abs(pos)-radius;\n        if(pos.x<pos.y)pos.xy=pos.yx;\n        if(pos.x<pos.z)pos.xz=pos.zx;\n        if(pos.y<pos.z)pos.yz=pos.zy;\n        pos.xy-=.25;\n        \n        pos.xy*=rot(PI/3.);\n        pos.xz*=rot(PI/3.);\n        pos.y-=0.5;\n    }\n    \n    float h=2.0;\n    pos.x-=clamp(pos.x,-h,h);\n    \n    float d4=Torus(pos,vec2(0.5,0.15));\n    float d5=Box(pos,vec3(0.1,0.1,4.0));\n    return d4;\n    \n}\n\nvec3 gn(vec3 p)\n{\n    vec2 e=vec2(0.0001,0.0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 ta=vec3(0.);\n    vec3 ro=vec3(cos(iTime*0.25)*10.,0.0,sin(iTime*0.25)*10.);\n    \n    vec3 cDir=normalize(ta-ro);\n    vec3 cSide=cross(cDir,vec3(0.,-1.,0.));\n    vec3 cUp=cross(cDir,cSide);\n    float depth=1.;\n    vec3 rd=vec3(uv.x*cSide+uv.y*cUp+cDir*depth);\n    \n    vec3 cubeRO=ro;\n    vec3 cubeRD=rd;\n    float cubeT=0.0;\n    \n    vec3 col=vec3(0.0);\n   float d,t=0.0;\n    float acc1=0.0;\n    float minD=1000.0;\n    for(int i=0;i<64;i++)\n    {\n        d=map(ro+rd*t);\n        minD=min(d,minD);\n        if(d<0.001)break;\n        acc1+=exp(-3.0*d);\n        t+=d*0.75;\n    }\n    cubeT=t;\n    \n    vec3 refP=ro+rd*t;\n    ro=refP;\n    rd=refract(rd,gn(ro),1.5);\n    t=0.1;\n    float acc2=0.0;\n    float minD2=1000.0;\n    \n    for(int i=0;i<33;i++)\n    {\n        d=map(ro+rd*t);\n        minD2=min(minD2,d);\n        if(d<0.001)break;\n        t+=d*0.75;\n        acc2+=exp(-3.0*d);\n    }\n    \n    col+=vec3(1.0,0.0,0.0)*acc1*0.06+vec3(0.0,0.0,1.0)*acc2*0.06;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}