{"ver":"0.1","info":{"id":"MlBSWy","date":"1446137007","viewed":125,"name":"Simple Space","username":"t91","description":"space","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VOID_SPACE -1\n#define SUN 0\n#define NUM_PLANETS 20\n\n#define M_INFINITY 9999999.0\n\nfloat g_AspectRatio;\nvec2 g_InvResolution;\n\nvoid InitMath()\n{\n\tg_AspectRatio = iResolution.x / iResolution.y;\n\tg_InvResolution = vec2(1.0) / iResolution.xy;\n}\n\n#define v_id(p) \t\tp.int_0.x\n#define v_owner(p)\t\tp.int_0.y\n\n#define v_position(p) \tp.float_0.xyz\n#define v_orbit(p)\t\tp.float_0.w\n\n#define v_radius(p)\t\tp.float_1.x\n#define v_radius2(p)\tp.float_1.y\n#define v_speed(p)\t\tp.float_1.z\n\n#define v_color(p)\t\tp.float_2.xyz\n\nstruct Planet\n{\n\tivec4 \tint_0;\n\tvec4\tfloat_0;\n\tvec4\tfloat_1;\n\tvec4\tfloat_2;\n};\n\nstruct RaytracerResults\n{\n\tint planet_id;\n\tvec3 nrm;\n\tfloat light;\n\n\tPlanet planet;\n};\n   \nPlanet planets[NUM_PLANETS];\n\nvec3 FragCoord2Ray(in vec2 fragCoord)\n{\n\tvec2 ndc = (fragCoord.xy * g_InvResolution) * 2.0 - 1.0; \n\tvec3 ray = vec3(g_AspectRatio*ndc.x, ndc.y, 5.0);\n\treturn ray;\n}\n\nvoid Raytracer(in vec3 ray, in bool ignoreSun, out RaytracerResults results)\n{    \n    results.planet_id = VOID_SPACE;\n    float closestIntersection = M_INFINITY;\n    \n    for (int p = 0; p < NUM_PLANETS; ++p)\n    {\n        if (ignoreSun && p == SUN)\n            continue;\n        \n        // http://stackoverflow.com/questions/6533856/ray-sphere-intersection\n        //a = ray, b = 2ray\n        vec3 rayMpos = ray - v_position(planets[p]);\n        float c = dot(rayMpos, rayMpos) - v_radius2(planets[p]);\n\n        float a = dot(ray, ray);\n        float b = 2.0 * dot(ray, rayMpos);\n        float Delta = b * b - 4.0 * a * c;\n\n        if (Delta > 0.0)\n        {\n            float d1 = (-b - sqrt(Delta)) / (2.0 * a);\n            vec3 intersection_tmp = ray + d1*ray;\n            float dist = length(intersection_tmp);\n            \n            if (d1 < 0.0)\n                dist = M_INFINITY;\n            \n            if (closestIntersection > dist)\n            {\n            \tresults.nrm = normalize(intersection_tmp - v_position(planets[p]));\n \t\t\t\tresults.light = dot( normalize(v_position(planets[SUN]) - v_position(planets[p])), results.nrm);\n                \n                v_color(planets[p]) = abs(vec3(sin(v_radius(planets[p]) * 0.8), cos(v_radius(planets[p]) * 0.2), sin(v_radius(planets[p]) * 0.1)));\n                \n\t\t\t\tresults.planet = planets[p];\t\t\t\t\n\t\t\t\tresults.planet_id = p;\n\t\t\t\t\n                closestIntersection = dist;\n            }\n        }\n    }\n}\n\nvec4 CalcBackground(vec2 fragCoord, in RaytracerResults rayInfo)\n{\n    vec4 color = vec4(0.0);\n    vec2 coord = fragCoord * g_InvResolution;\n    \n    coord += (iMouse.xy * g_InvResolution) * vec2(0.2, 1.35);\n    \n    vec2 coord_ndc = coord * 2.0 - 1.0;\n    float ring = clamp(cos(coord_ndc.y * coord_ndc.x * 5.0), 0.0, 1.0) * clamp(cos(coord_ndc.y * 2.0), 0.0, 1.0);\n    \n    vec3 noise = texture(iChannel1, coord * 2.0 + 0.5).rgb;\n    noise *= noise * noise;\n\n    vec4 cloud = ring * texture(iChannel1, noise.xy * ring );\n\n\tvec4 res = \tcloud.rrrr * vec4(2.0, 0.0, 0.0, 0.0);\n    res += \t\tcloud.bbbb * ring * vec4(0.0, 2.0, 0.0, 0.0);\n    res += \t\tcloud.gggg * ring * ring * vec4(0.0, 0.0, 2.0, 0.0);\n    \n    float magic_factor = 1.0 - length(coord_ndc.xy);\n    vec4 nebula = res + magic_factor * 0.5;\n\n    float stars = noise.r * noise.g;\n    stars -= 0.8;\n    stars = clamp(stars, 0.0, 1.0);\n    stars = stars * 30.0;\n    \n    return 0.5 * magic_factor * nebula * nebula + vec4(stars * 2.0);\n}\n\nvec4 CalcSun(vec2 fragCoord, in RaytracerResults rayInfo)\n{\n    vec2 dcoord = vec2(rayInfo.nrm.zy) * sin(iTime) * 0.9;\n    dcoord += vec2(rayInfo.nrm.xy) * cos(iTime) * 0.7;\n    dcoord += vec2(rayInfo.nrm.xz) * cos(iTime) * 0.8;\n    dcoord += fragCoord.xy * g_InvResolution;\n    \n    vec4 tex = texture(iChannel1, (rayInfo.nrm.xy) * normalize(dcoord));\n    \n\tvec4 color = vec4(1.0, 1.0, 0.9, 1.0);\n    float factor = 1.2; // abs(s_gt) * 0.01 + 1.05;\n    \n    color.a = clamp(-rayInfo.nrm.z * 1.1, 0.0, 1.0);\n    color.a *= color.a * color.a * color.a;\n    \n    color.rgb = mix(vec3(1.0, 1.0, 0.5), color.rgb, color.a);\n    return color + vec4(1.0, 0.5, 0.0, 0.0) * length(tex);\n}\n\nvec4 CalcSurface(vec2 fragCoord, in RaytracerResults rayInfo)\n{\n    vec2 coord = rayInfo.nrm.xy * 0.5 * 30.0 / v_radius(rayInfo.planet) + vec2(0.5);\n\n    vec3 fin = vec3(0.0);\n    \n    if (rayInfo.planet_id > 3)\n    {\n        vec3 tex = texture(iChannel1, coord.xy).rgb;\n      \n       /* if (tex.r * tex.r > 0.55)\n            tex = vec4(0.0, 0.0, 1.0, 1.0);\n        else*/\n            tex *= v_color(rayInfo.planet);\n        \n        if (abs(rayInfo.nrm.y * tex.r) > 0.2)\n            tex.rgb = vec3(1.0) - rayInfo.nrm.bbb;\n        \n    \tfin = tex * rayInfo.light;\n    }\n    else if (rayInfo.planet_id > 1)\n    {\n        vec3 tex = texture(iChannel1, coord.xy).rgb;\n      \n        /*if (tex.b > 0.55)\n            tex = vec4(0.0, 0.0, 1.0, 1.0);\n        else*/\n            tex *= v_color(rayInfo.planet);\n\n    \tfin = tex * rayInfo.light;\n    }\n    else if (rayInfo.planet_id > 0)\n    {\n        vec3 tex = texture(iChannel1, coord.xy).rgb;\n    \tfin = tex * v_color(rayInfo.planet) * rayInfo.light; //color * light;\n    }\n    else\n    {\n    \tfin = v_color(rayInfo.planet);\n    }\n    \n    fin += vec3(0.05, 0.05, 0.15);\n    \n \treturn vec4(fin, 1.0);   \n}\n\nvoid InitBodies()\n{\n\tv_id(planets[SUN]) = 0;\n    v_orbit(planets[SUN]) = 0.0;\n    v_radius(planets[SUN]) = 60.0;\n\tv_radius2(planets[SUN]) = v_radius(planets[SUN]) * v_radius(planets[SUN]);\n    v_speed(planets[SUN]) = 0.0;\n    v_color(planets[SUN]) = vec3(1.0, 0.0, 1.0);\n    v_owner(planets[SUN]) = 0;\n    \n    float orbit = 60.0;\n    float orbit_offset = 80.0;\n\t\n    for (int i = 1; i < NUM_PLANETS; ++i)\n    {\n        orbit *= 1.8;\n\t\tv_id(planets[i]) = i;\n    \tv_orbit(planets[i]) = orbit + orbit_offset;\n       \n        v_radius(planets[i]) = (2.0 + sin(orbit * 0.05)) * 5.0;\n        v_radius(planets[i]) = min(v_radius(planets[i]), v_orbit(planets[i]) * 0.1);\n        \n\t\tv_radius2(planets[i]) = v_radius(planets[i]) * v_radius(planets[i]);\n        v_speed(planets[i]) = 32.0 / orbit;\n        \n        v_owner(planets[i]) = 0;\n    }\n\n\n    #define OWNER 10\n    \n    for (int i = 11; i < NUM_PLANETS; ++i)\n    {\n    \tv_orbit(planets[i]) = v_radius(planets[i-OWNER]) * 2.0;\n       \n        v_radius(planets[i]) = v_radius(planets[i-OWNER]) * 0.5;\n        v_radius(planets[i]) = min(v_radius(planets[i-OWNER]) * 0.5, v_orbit(planets[i-OWNER]) * 0.1);\n        \n\t\tv_radius2(planets[i]) = v_radius(planets[i]) * v_radius(planets[i]);\n        v_speed(planets[i]) = v_radius(planets[i-OWNER]) * 0.1;// / orbit;\n        \n        v_owner(planets[i]) = i - OWNER;\n    }\n    \n    v_position(planets[SUN]) = vec3(0.0);\n    \n    {\n        v_position(planets[SUN]).z += iMouse.x * g_InvResolution.x * 8000.0;\n        v_position(planets[SUN]).y -= 50.0;\n    }\n    \n    for (int i = 1; i < NUM_PLANETS; ++i)\n    {\n\t\tfloat factor = v_speed(planets[i]) * iTime + v_orbit(planets[i]);\n\n        if (v_owner(planets[i]) != SUN)\n        {\n            for (int j = 0; j < NUM_PLANETS; ++j)\n                if (j == v_owner(planets[i]))\n                {\n                    v_position(planets[i]) = v_position(planets[j]) + v_orbit(planets[i]) * vec3(sin(factor), cos(factor + 0.5), cos(factor));\n                }   \n            \n            v_position(planets[i]).y += cos(factor) * 10.0;\n        }\n\t\telse\n        {\n        \tv_position(planets[i]) = v_position(planets[SUN]) + v_orbit(planets[i]) * vec3(sin(factor), cos(factor + 0.5) * 0.2 , cos(factor));\n        }\n        \n        //\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tInitMath();\n    InitBodies();\n\t\n\tvec3 ray = FragCoord2Ray(fragCoord);\n\t\n\tRaytracerResults firstRay;\n    Raytracer(ray, false, firstRay);\n    \n    if (firstRay.planet_id == VOID_SPACE)\n    {\n    \tfragColor = CalcBackground(fragCoord, firstRay);\n    }\n    else if (firstRay.planet_id == SUN)\n    {\n        vec4 sun = CalcSun(fragCoord, firstRay);\n        vec4 behind_sun = vec4(0.0);\n\n        RaytracerResults secondRay;\n\n        Raytracer(ray, true, secondRay);\n\n        if (secondRay.planet_id == VOID_SPACE)\n        {\n            behind_sun = CalcBackground(fragCoord, secondRay);\n        }\n        else\n        {\n            behind_sun = CalcSurface(fragCoord, secondRay);\n        }\n\n        fragColor.xyz = mix(behind_sun.xyz, sun.xyz, sun.w);\n        fragColor.w = 1.0;\n    }\n    else\n    {\n        fragColor = CalcSurface(fragCoord, firstRay);\n    }\n}","name":"Image","description":"","type":"image"}]}