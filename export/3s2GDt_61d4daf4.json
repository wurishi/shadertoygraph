{"ver":"0.1","info":{"id":"3s2GDt","date":"1550285170","viewed":115,"name":"Unexpected","username":"AdrianPi","description":"Simple animation - Will disable AA on full-screen","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","antialias","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThis is public domain. Do what you please with it :)\n\n*/\n\n\nstruct ray_t\n{\n    vec3 pos;\n    vec3 dir;\n    vec3 dirInv;\n    int level;\n    vec4 contrib;\n};\n    \nstruct hit_t\n{\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int mat;\n};\n    \nconst int STANDARD_MATERIAL = 1;\nconst int CHECKER_MATERIAL = 2;\n    \nstruct material_t\n{\n    int type;\n    int flags;\n    int attrib0;\n    int attrib1;\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    vec4 reflection;\n    vec4 transparent;\n};\n    \nconst int SPHERE_PRIMITIVE = 1;\nconst int PLANE_PRIMITIVE = 2;\nconst int RING_PRIMITIVE = 3;\nconst int BOX_PRIMITIVE = 4;\n\nstruct primitive_t\n{\n    int type;\n    int mat;\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n    \nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITE = 1e6;\nconst float EPSILON = 1e-6;\nconst float EPSILON4 = 1e-4;\n\nvec3 viewFrom = vec3(0,-8,4);\nvec3 viewAt = vec3(-1,0,0);\nvec3 viewUp = vec3(0,0,1);\nfloat viewFov = 45.0;\n\nvec3 viewDir;\nvec3 viewRight;\nfloat viewTan;\nfloat aspect = 1.33;\nint oversample = 3;\n\nvec4 skyColor = vec4(0.5,0.5,1,1);\nvec4 horizonColor = vec4(0.8,0.8,1,1);\n\nconst material_t material0 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(1,1,1,1), \n                                   vec4(1,1,1,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material1 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(0.2,0.2,0.2,1), \n                                   vec4(0.2,0.2,0.2,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material2 = material_t(\n    \t\t\t\t\t\t\t   CHECKER_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,1, \n                                   vec4(0.5,0.5,0.5,0), \n                                   vec4(0.001,0.001,0.001,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material3 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.2,0.2,0.2,0), \n                                   vec4(0.6,0.6,0.6,1.54));\n\nconst material_t material4 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.6,0.6,0.6,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material5 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(1.0,0.3,0.3,1), \n                                   vec4(1.0,0.3,0.3,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material6 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.3,0.3,1,1), \n                                   vec4(0.3,0.3,1,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.1,0.1,0.1,0), \n                                   vec4(0,0,0,0));\n\nmaterial_t materials[7] = material_t[7](material0, material1, material2, \n                                        material3, material4, material5, material6);\n\nconst primitive_t _floor = primitive_t(PLANE_PRIMITIVE, 2, vec3(0, 0, -3), vec3(0, 0, 1), vec3(0,0,0));\nconst primitive_t _sphere = primitive_t(SPHERE_PRIMITIVE, 3, vec3(3, 3, 1), vec3(1, 0, 0), vec3(0,0,0));\nconst primitive_t _ring = primitive_t(RING_PRIMITIVE, 4, vec3(0,0,0), normalize(vec3(-0.5, 0, 1)), vec3(2, 1.5, 0));\nconst primitive_t _box = primitive_t(BOX_PRIMITIVE, 5, vec3(2, 2, -3), vec3(4, 4, 0), vec3(0,0,0));\n//const primitive_t _box2 = primitive_t(BOX_PRIMITIVE, 6, vec3(5, 5, -3), vec3(9, 9, 1), vec3(0,0,0));\n\nconst int NUM_PRIMS = 3;\n\nprimitive_t prims[NUM_PRIMS] = primitive_t[NUM_PRIMS](_floor, _sphere, _box);\n\nray_t primary_ray(float fx, float fy)\n{\n    ray_t ray;\n    ray.pos = viewFrom;\n    ray.dir = normalize(viewDir + viewRight * fx  * aspect + viewUp * fy);\n    ray.dirInv = vec3(1) / ray.dir;\n    ray.contrib = vec4(1,1,1,1);\n    return ray;\n}\n\nvec4 background(ray_t ray)\n{\n\tfloat t = 1.0 - ray.dir.z * ray.dir.z;\n    t = pow(t, 5.0);\n    return skyColor * (1.0-t) + horizonColor * t;\n}\n\nbool hit_sphere(vec3 center, float radius, int mat, ray_t ray, inout hit_t hit)\n{\n    vec3 q = ray.pos - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(q, ray.dir);\n    float c = dot(q,q) - radius * radius;\n    float d = b * b - 4.0 * a * c;\n    if(d > EPSILON)\n    {\n        float t0 = (-b - sqrt(d)) / (2.0 * a);\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n\n        float t = INFINITE;\n        \n        if(t1 > EPSILON && t1 < t0)\n        {\n            t = t1;\n        }\n        else            \n        {\n            t = t0;\n        }\n        \n        if(t < EPSILON)\n        {\n            t = INFINITE;\n        }\n        \n        if(t != INFINITE)\n        {\n            hit.t = t;\n            hit.pos = ray.pos + ray.dir * hit.t;\n            hit.normal = normalize(hit.pos - center);\n            hit.mat = mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_plane(vec3 p0, vec3 normal, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            hit.t = t;\n        \thit.pos = ray.pos + ray.dir * t;\n        \thit.normal = normal;\n        \thit.mat = mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\n\nbool hit_ring(vec3 p0, vec3 normal, float r1, float r2, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            vec3 p = ray.pos + ray.dir * t;\n            vec3 r = p - p0;\n            float e = dot(r, r);\n            if(e < r1*r1 && e > r2*r2)\n            {\n                hit.t = t;\n                hit.pos = p;\n                hit.normal = normal;\n                hit.mat = mat;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool hit_box(vec3 p0, vec3 p1, int mat, ray_t ray, inout hit_t hit)\n{\n    float txmin = (p0.x - ray.pos.x) * ray.dirInv.x;\n    float txmax = (p1.x - ray.pos.x) * ray.dirInv.x;\n    float tymin = (p0.y - ray.pos.y) * ray.dirInv.y;\n    float tymax = (p1.y - ray.pos.y) * ray.dirInv.y;\n    float tzmin = (p0.z - ray.pos.z) * ray.dirInv.z;\n    float tzmax = (p1.z - ray.pos.z) * ray.dirInv.z;\n    \n    float tmin = max(max(min(txmin, txmax), min(tymin, tymax)), min(tzmin, tzmax));\n    float tmax = min(min(max(txmin, txmax), max(tymin, tymax)), max(tzmin, tzmax));\n    \n    if(tmax < EPSILON || tmin > tmax)\n    {\n        return false;\n    }\n    \n    if(tmin < EPSILON)\n    {\n        tmin = tmax; // inside the box\n    }\n    \n    \n    if(tmin > EPSILON)\n    {\n        hit.t = tmin;\n        hit.pos = ray.pos + ray.dir * hit.t;\n        \n        if(hit.pos.x < p0.x+EPSILON4)\n            hit.normal = vec3(-1, 0, 0);\n        else if(hit.pos.x > p1.x-EPSILON4)\n            hit.normal = vec3(1,0,0);\n        else if(hit.pos.y < p0.y+EPSILON4)\n            hit.normal = vec3(0, -1, 0);\n        else if(hit.pos.y > p1.y-EPSILON4)\n            hit.normal = vec3(0, 1, 0);\n        else if(hit.pos.z < p0.z+EPSILON4)\n            hit.normal = vec3(0, 0, -1);\n        else if(hit.pos.z > p1.z-EPSILON4)\n            hit.normal = vec3(0, 0, 1);\n        \n        hit.mat = mat;\n        return true;\n    }\n    \n    return false;\n}\n\n\nvec4 ambientLight = vec4(0.2, 0.2, 0.2, 1);\nvec3 lightDirection = normalize(vec3(0.666,0.333,-1));\n\nray_t rayQueue[16];\nint rayHead = 0;\nint rayTail = 0;\n\nvoid enqueueRay(ray_t ray)\n{\n    if((rayTail+1) % 16 != rayHead)\n    {\n        rayQueue[rayTail] = ray;\n        rayTail++;\n        rayTail %= 16;\n    }\n}\n\nbool dequeueRay(inout ray_t ray)\n{\n    if(rayHead != rayTail)\n    {\n        ray = rayQueue[rayHead];\n        rayHead++;\n        rayHead %= 16;\n        return true;\n    }\n    return false;\n}\n\nvoid resetRayQueue()\n{\n    rayHead = rayTail = 0;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit);\n\n\nvec4 shade_standard(ray_t ray, hit_t hit)\n{\n    if(ray.level >= 4)\n        return vec4(0,0,0,0);\n    \n    vec4 color = materials[hit.mat].ambient * ambientLight;\n    \n    ray_t sray;\n    sray.pos = hit.pos - lightDirection * EPSILON4;\n    sray.dir = -lightDirection;\n    sray.dirInv = vec3(1) / sray.dir;\n    hit_t h;\n    intersect(sray, h);\n    if(h.t == INFINITE)\n    {    \n        float d = dot(-lightDirection, hit.normal);\n        d = clamp(d, 0.0, 1.0);\n        color += materials[hit.mat].diffuse * d;\n        vec3 r = reflect(ray.dir, hit.normal);\n        float s = dot(-lightDirection, r);\n        s = clamp(s, 0.0, 1.0);\n        s = pow(s, materials[hit.mat].specular.a);\n        color.rgb += materials[hit.mat].specular.rgb * s;\n    }\n    \n    color.rgb += materials[hit.mat].emission.rgb;\n    \n    vec3 refl = materials[hit.mat].reflection.rgb;\n    if(dot(refl, refl) > 0.0)\n    {\n        ray_t rray;\n        vec3 r = reflect(ray.dir, hit.normal);\n        rray.pos = hit.pos + r * 0.001;\n        rray.dir = r;\n        rray.dirInv = vec3(1) / rray.dir;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(refl, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    vec3 trans = materials[hit.mat].transparent.rgb;\n    if(dot(trans, trans) > 0.0)\n    {\n        float ior = materials[hit.mat].transparent.a;\n        if(dot(ray.dir, hit.normal) < 0.0)\n            ior = 1.0 / ior;\n        \n        ray_t rray;\n        rray.pos = hit.pos + ray.dir * 0.001;\n        rray.dir = refract(ray.dir, hit.normal, ior);\n        rray.dirInv = vec3(1) / rray.dir;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(trans, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    return color;\n}\n\nvec4 shade_checker(ray_t ray, hit_t hit)\n{\n    float t = mod(iTime, 6.0);\n    if(t > 2.65)\n    {\n        vec3 center = vec3(-4,3,-3);\n        vec3 q = hit.pos - center;\n        vec3 dir = normalize(q);\n        float d = sqrt(dot(q,q));\n        float amp = clamp(4. / d, 0., 1.);  \n        amp *= (2.65/(t*6.));\n        float l = cos(d-t*2.0*4.0);\n        hit.normal += dir * l * 9.0 * amp;\n        hit.normal = normalize(hit.normal);\n        hit.pos += dir * l * 1.6 * amp;\n    }\n    \n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int ix = int(floor(p.x)) & 0x01;\n    int iy = int(floor(p.y)) & 0x01;\n    int iz = int(floor(p.z)) & 0x01;\n\n    hit.mat = ((ix ^ iy ^ iz) == 0) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n    \n    \n    return shade_standard(ray, hit);\n}\n\nvec4 shade(ray_t ray, hit_t hit)\n{\n    vec4 color;\n    \n    if(hit.t != INFINITE)\n    {    \n        int type = materials[hit.mat].type;\n\n        if(type == STANDARD_MATERIAL)\n        {\n            color = shade_standard(ray, hit);\n        }\n        else if(type == CHECKER_MATERIAL) \n        {\n            color = shade_checker(ray, hit);\n        }\n        \n        // fog\n\n        float f = (hit.t - 10.0) / (50.0-10.0);\n        f = clamp(f, 0.0, 1.0);\n        color = mix(color, horizonColor, f);\n    }\n    else\n    {\n        color = background(ray);\n    }\n    \n    return color * ray.contrib;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit)\n{\n\thit.t = INFINITE;\n    \n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            break;\n        case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;\n        case BOX_PRIMITIVE:\n            result = hit_box(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            break;\n        }\n        \n        if(result && h.t < hit.t)\n        {\n            hit = h;\n        }\n    }    \n}\n\nvec4 raytrace(ray_t ray)\n{\n    hit_t hit;\n    \n    intersect(ray, hit);\n    \n    return shade(ray, hit);\n}\n\nfloat easeIn(float t)\n{\n    t = t * t;\n    return t;\n}\n\nfloat animZ(float t)\n{\n    if(t < 1.0)\n    {\n        return 1.0;\n    }\n    else\n    {\n    \treturn -2.0 + abs(cos(t-1.0)) * 3.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aspect = iResolution.x / iResolution.y;\n    viewTan = tan(((viewFov/180.0)*PI)/2.0);    \n    vec2 uv = fragCoord/iResolution.xy * vec2(2,2) - vec2(1,1);\n    uv *= viewTan;\n    viewDir = normalize(viewAt-viewFrom);\n\tviewRight = cross(viewDir, viewUp);\n    viewUp = cross(viewRight, viewDir);\n    \n    if(iResolution.x > 640.0)\n        oversample = 1;\n    \n    float t = mod(iTime, 6.0);\n    \n    prims[1].v0.x = 3.0-easeIn(t);\n    prims[1].v0.z = animZ(t);\n    \n    vec4 color = vec4(0,0,0,0);\n    float sx = (1.0 / float(oversample)) / iResolution.x;\n    float sy = (1.0 / float(oversample)) / iResolution.y;\n    \n    for(int i = 0; i < oversample; i++)\n    {\n        for(int j = 0; j < oversample; j++)\n        {\n    \t\tray_t ray = primary_ray(uv.x + float(i) * sx, uv.y + float(j) * sy);\n            resetRayQueue();\n            enqueueRay(ray);\n            \n            while(dequeueRay(ray))\n\t    \t\tcolor += raytrace(ray);\n        }\n    }\n    \n    color /= float(oversample*oversample);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}