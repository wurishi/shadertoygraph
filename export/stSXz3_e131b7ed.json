{"ver":"0.1","info":{"id":"stSXz3","date":"1628238586","viewed":167,"name":"Terrain island1","username":"treize","description":"On the way, additional planned caustics, clouds, lighting","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATION_NUM 99\nconst float MAT_A=1.0;\nconst float MAT_B=2.0;\nvec2 map(vec3 p) \n{\n    vec2 d;\n    float fbm=FBM34_2(p,1.0,1.0);\n    fbm+=1.;\n\tfbm*=0.5;\n\tfloat floor_height\t= p.y-fbm;\n\td=\tvec2(float(max(d,floor_height)),MAT_A); \n\treturn d;\n}\nvec3 getnormal(vec3 p)\n{\n    vec2 d =vec2(0.0001,0.0);\n    return normalize(vec3(map(p +d.xyy).x -map(p -d.xyy).x,map(p +d.yxy).x -map(p -d.yxy).x,map(p +d.yyx).x -map(p -d.yyx).x));\n}\nvec3 lighting(vec3 lp,vec3 n)\n{\n     return vec3(Lambert(lp,n));\n}\nvec3 materialize(vec3 p, float depth,vec2 mat)\n{\n    vec3 col=vec3(1.0);\n    if (depth > 10.0)\n    {\n    }\n    else\n    {\n         //col=vec3(Lambert(vec3(cos(iTime),0.0,sin(iTime)), getnormal(p)));\n         if(mat.y== MAT_A)\n         {\n            float col2 =FBM34_2(p,1.0,1.0);\n            //col2=mix(0.0,1.0,col2);\n            vec3 tcol;\n            if(col2<0.0)\n            {\n                //vec2 v;\n                //SimpleVoronoi(p.xz, vec2(3.0),vec2(10.0),v.x,v.y);\n                tcol=vec3(0.01,0.4,0.7);//* (1.4 +v.x) + vec3(1.7, 0.01, 0.01) *v.x;\n            }\n            else if(col2<0.1)\n            {\n                tcol =vec3(0.01,0.4*((col2+0.1) *13.),0.7*((col2+0.12)*15.));\n            }\n            else if(col2<0.13)\n            {\n                tcol = vec3(0.87, 0.72, 0.5);\n            }\n            else\n            {\n                tcol = vec3(0.13, 0.4+(p.y*1.1), 0.13)*col2*1.5;\n            }\n\n            col*=tcol;\n         }\n\n     }\n     return col;\n}\nvec3 raymarch(vec3 ro, vec3 rd) \n{\n\tvec3 p;\n    vec2 d;\n\tfloat depth;\n\tfor(int i=0; i<ITERATION_NUM; i++) \n\t{\n        p=ro+rd*depth;\n\t\td = map(p);\n\t\tif(d.x<0.00001)\n\t\t{\n\t\t    break;\n\t\t}\n\t\tdepth += d.x;\n\t}\n\treturn  materialize(p,depth,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 origin =vec3(cos(iTime)*5.,3.0,sin(iTime)*5.);\n    //vec3 origin = vec3(0.0, 3.0, -5.0);\n    vec3 target = vec3(0.0);\n    mat3 camera = SetCamera(origin, target, 0.0);\n    vec3 rd = camera * normalize(vec3(p,3.5));\n\tvec3 col=raymarch(origin , rd);    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Noise\nfloat hash13(vec3 p)\n{\n\tvec3 p3 = fract(p * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat ValueNoise31(vec3 p) \n{\n    vec3 i = floor(p);\n    float v000 = hash13(i);\n    float v100 = hash13(i + vec3(1.0,0.0,0.0));\n    float v010 = hash13(i + vec3(0.0,1.0,0.0));\n    float v110 = hash13(i + vec3(1.0,1.0,0.0));\n    float v001 = hash13(i + vec3(0.0,0.0,1.0));\n    float v101 = hash13(i + vec3(1.0,0.0,1.0));\n    float v011 = hash13(i + vec3(0.0,1.0,1.0));\n    float v111 = hash13(i + vec3(1.0,1.0,1.0));\n    vec3 f = fract(p);\n    f = f * f * (3.0 -2.0 * f); \n    return mix(mix(mix( v000,v100,f.x),mix( v010,v110,f.x),f.y),                        \n               mix(mix(v001, v101,f.x),mix(v011, v111,f.x),f.y),f.z)-0.5;\n}\nfloat FBM34_2(vec3 p, float amplitude, float frequency)\n{\n\tfloat result = 0.;\n\tfloat amplitude2 = amplitude;\n\tfloat frequency2 = frequency;\n\tfor (int i = 0; i < 4; i++)\n\t{\n        result += ValueNoise31(p * frequency2) * amplitude2;\n\t\tamplitude2 *= 0.5;\n\t\tfrequency2 *= 2.0;\n\t}\n\treturn result;\n}\nvec2 voronoi_noise_randomVector(vec2 UV, vec2 offset)\n{\n\tmat2 m = mat2(15.27, 47.63, 99.41, 89.98);\n\tUV = fract(sin(UV* m) * 46839.32);\n\treturn vec2(sin(UV.y * +offset.x) * 0.5 + 0.5, cos(UV.x * offset.y) * 0.5 + 0.5);\n}\n\nvoid SimpleVoronoi(vec2 UV, vec2 AngleOffset, vec2 CellDensity, out float Out, out float Cells)\n{\n\tvec2 g = floor(UV * CellDensity);\n\tvec2 f = fract(UV * CellDensity);\n\t\n\tfloat res = 8.0;\n\tfloat md=8.0;\n\tfor (int y = -1; y <= 1; y++)\n \t{\n\t    for (int x = -1; x <= 1; x++)\n\t\t{\n\t\t    vec2 lattice = vec2(x, y);\n            vec2 offset = voronoi_noise_randomVector(lattice + g, AngleOffset);\n            vec2 r = lattice +offset -f;\n\t\t    float d = dot(r,r);\n\n\t\t\tif (d < res)\n\t\t\t{\n                res = d;\n\t\t\t \tOut = res;\n\t\t\t    Cells = offset.x;\n\t\t\t}\n\t\t}\n\t}\n}\n//SDF\n\nvec2 opUnion(vec2 d1,vec2 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sphere(vec3 rayPos, float r) \n{\n    float d=length(rayPos)-r;\n\treturn d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Lighting\nfloat Lambert(vec3 l,vec3 n)\n{\n    return max(0.0,dot(n,l));\n}\n\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}","name":"Common","description":"","type":"common"}]}