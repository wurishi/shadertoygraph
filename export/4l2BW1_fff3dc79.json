{"ver":"0.1","info":{"id":"4l2BW1","date":"1517320442","viewed":1793,"name":"Ａ　Ｎ　Ｅ　Ｓ　Ｔ　Ｈ　Ｅ　Ｔ　Ｉ　Ｃ","username":"Lolmarty","description":"...and bandages for this sore monstrocity. Taken from numerous other shaders, some of which are referenced. Sorry if it runs like it sounds, I had two machines to test this on ranging between \"potato\" and \"monster truck\".","likes":39,"published":1,"flags":32,"usePreview":0,"tags":["terrain","blur","sky","scanline","glow","vapordave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLUR_ON true\n#define POSTPROCESS true\n\nconst float range = 0.0150;\nconst float offsetIntensity = 0.0075;\n\n//scratch section taked from shader by Vladimir Storm \n//https://twitter.com/vladstorm_\n\n#define t iTime\n\n//random hash\nvec4 hash42(vec2 p){\n    \n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(443.8975,397.2973, 491.1871, 470.7827));\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\n\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function (iq's)\nfloat n( in vec3 x ){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n//tape noise\nfloat nn(vec2 p){\n\n\n    float y = p.y;\n    float s = t*2.;\n    \n    float v = (n( vec3(y*.1 +s, \t\t\t2., 2.) ) + .0)\n          \t //*(n( vec3(y*.011+1000.0+s, \t2., 2.) ) + .0) \n          \t *(n( vec3(y*.51+421.0+s, \t\t2., 2.) ) + .0)   \n        ;\n    //v*= n( vec3( (fragCoord.xy + vec2(s,0.))*100.,1.0) );\n   \tv*= hash42(   vec2(p.x +t*0.01, p.y) ).x +.3 ;\n\n    \n    v = pow(v+.3, 1.);\n\tif(v<.7) v = 0.;  //threshold\n    return v;\n}\n\nfloat rand(vec2 co){ \n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); \n} \n\nfloat brightness (vec3 color) \n{ \n\treturn ( 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b ); \n} \n\nfloat verticalBar(float pos, float uvY, float offset) {\n    float edge0 = (pos - range);\n    float edge1 = (pos + range);\n\n    float x = smoothstep(edge0, pos, uvY) * offset;\n    x -= smoothstep(pos, edge1, uvY) * offset;\n    return x;\n}\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec3 scanline(vec2 coord, vec3 screen){\n    const float scale = .0036;\n    const float amt = 0.02;// intensity of effect\n    const float spd = 1.0;//speed of scrolling rows transposed per second\n    \n\tscreen.rgb += sin((coord.y / scale - (iTime * spd * 6.28))) * amt;\n\treturn screen;\n}\n\nvec2 fisheye(vec2 uv, float str )\n{\n    vec2 neg1to1 = uv;\n    neg1to1 = (neg1to1 - 0.5) * 2.0;\t\t\n\t\t\n    vec2 offset;\n    offset.x = ( pow(neg1to1.y,2.0)) * str * (neg1to1.x);\n    offset.y = ( pow(neg1to1.x,2.0)) * str * (neg1to1.y);\n\t\n    return uv + offset;\t     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    if ( !POSTPROCESS ) \n    {\n        fragColor = texture( iChannel0, p );\n        return;\n    }\n    \n    vec2 uv = (fragCoord.xy - iMouse.xy) / iResolution.xy;\n    p = fisheye(p, 0.03);\n    float barOffset;\n    for (float i = 0.0; i < 0.71; i += 0.1313) {\n        float d = mod(iTime * i, 1.7);\n        float o = sin(1.0 - tan(iTime * 0.24 * i));\n    \to *= offsetIntensity;\n        p.x += verticalBar(d, p.y, o);\n    }\n    \n    float scale = rand( p + iTime );\n    vec2 rOffset = vec2( 0.0, -0.005 ) * scale;\n    vec2 gOffset = vec2( 0.0, 0.005 ) * scale; \n    vec2 bOffset = vec2( 0.005, 0. ) * scale;\n    vec4 rValue = texture( iChannel0, p - rOffset ); \n    vec4 gValue = texture( iChannel0, p - gOffset ); \n    vec4 bValue = texture( iChannel0, p - bOffset );\n    vec3 abber = ( vec3( rValue.r, gValue.g, bValue.b ) + texture( iChannel0, p ).xyz ) / 2.;\n \n       \n    vec3 col;\n    float rim = .020;\n    if( p.x < rim )\n        col = vec3( mix( 0., abber.r, min(1., 3. * p.x / rim - 1.) ),\n                    mix( 0., abber.g, min(1., 3. * p.x / rim ) ),\n                    mix( 0., abber.b, min(1., 3. * p.x / rim - 2. ) ) );\n    else if ( p.x > 1. - rim )\n        col = vec3( mix( 0., abber.r, min(1., 3. * ( 1. - p.x ) / rim - 1.) ),\n                    mix( 0., abber.g, min(1., 3. * ( 1. - p.x ) / rim - 2.) ),\n                    mix( 0., abber.b, min(1., 3. * ( 1. - p.x ) / rim ) ) );\n\telse\n        col = abber;\n    \n    if(BLUR_ON)\n    {\n        //declare stuff\n        const int mSize = 9;\n        const int kSize = (mSize-1)/2;\n        float kernel[mSize];\n        mat3 sobelX = mat3(-1.,0.,1.,\n                       -2.,0.,2.,\n                       -1.,0.,1);\n    \tmat3 sobelY = mat3(-1.,-2.,-1.,\n                       0.,0.,0.,\n                       1.,2.,1);\n    \tfloat gx = 0.;\n        float gy = 0.;\n\n        vec3 final_colour = vec3(0.0);\n\n        //create the 1-D kernel\n        float sigma = 2.0;\n        float Z = 0.0;\n        for (int j = 0; j <= kSize; ++j)\n        {\n            kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n        }\n\n        //get the normalization factor (as the gaussian has been clamped)\n        for (int j = 0; j < mSize; ++j)\n        {\n            Z += kernel[j];\n        }\n\n        //read out the texels\n        for (int i=-kSize; i <= kSize; ++i)\n        {\n            for (int j=-kSize; j <= kSize; ++j)\n            {\n                vec3 texcol = texture(iChannel0, p + vec2(float(i),float(j)) / iResolution.xy).rgb;\n                if(i<=1 && i>=-1 && j>=-1 && j<=1)\n                {\n                    gx += sobelX[i+1][j+1] * brightness(texcol);\n                    gy += sobelY[i+1][j+1] * brightness(texcol);\n                }\n                final_colour += kernel[kSize+j]*kernel[kSize+i]*texcol;\n            }\n        }\n\n        col = 0.5 * col + 0.5 * final_colour / ( Z * Z ) + 0.025 * ( gx*gx + gy*gy );\n    }\n    \n    float scratchWidth = .1;\n    if ( uv.y < scratchWidth && uv.y > -scratchWidth && iMouse.z > 0. ) \n    {\n        float linesN = 240.; //fields per seconds\n        float one_y = iResolution.y / linesN; //field line\n        uv = floor(uv*iResolution.xy/one_y)*one_y;\n\t\tcol += vec3( nn(uv) );\n    }    \n        \n    fragColor = vec4( scanline( p, col ), 1.0 ); \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define circleX 0.5 * iResolution.x\n#define circleY 0.7 * iResolution.y\n#define R min( iResolution.x, iResolution.y )*0.20\n\n#define innerStripe \t\tcircleY - 0.35 * R\n#define upperStripeBottom \tcircleY - 0.40 * R\n#define upperStripeTop \t\tcircleY - 0.55 * R\n#define lowerStripeBottom \tcircleY - 0.60 * R\n#define lowerStripeTop \t\tcircleY - 0.75 * R\n#define outerStripe \t\tcircleY - 0.80 * R\n\n#define STEPS 4.0\n#define CLOUD_DETAIL 1.3\n\n#define XPIXELS 320.0\n#define YPIXELS 200.0\n\n#define HASHSCALE1 .1031\n\n//heavily edited https://www.shadertoy.com/view/4sd3zf https://www.shadertoy.com/view/XsSXz3 and a bunch of others\n\nfloat rand(vec2 co){ \n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); \n} \n\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453123);\n}\n\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n       dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z)-0.4;\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404;\n    const float K2 = 0.211324865;\n\n    vec2 i = floor( p + (p.x+p.y)*K1 );\n\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat clouds(vec3 p) {\n\tvec3 q = p+vec3(-0.1,0.37,1.0)*2.0*iTime+vec3(0.0, sin(p.y)*100.0, 0.0);\n\tfloat v = 0.0;\n\tv += 0.550 * noise(q*0.051);\n\tv += 0.250 * noise(q*0.111);\n\tv += 0.125 * noise(q*0.211);\n    \n\treturn v;\n}\n\n// From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = hash12( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( in vec2 p )\n{\n   float f = 0.0;\n   f += 0.5000*noise( p ); p = m*p*2.02;\n   f += 0.2500*noise( p ); //p = m*p*2.03;\n//    f += 0.1250*noise( p ); p = m*p*2.01;\n//    f += 0.0625*noise( p );\n   return f;\n}\n\nfloat triangleF(float arg, float period, float threshold)\n{\n    return (clamp(abs(mod(arg,2.*period)-period)/period,threshold,1.)-threshold)/(1.-threshold);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec3 bgcolor = vec3( 0.035, 0.05, 0.15 );\n\tvec3 lineColor = vec3(p,0.5+0.5*sin(iTime));\n    fragColor = vec4( bgcolor, 1.0 );\n    \n    float thickness = .006;\n    float threshold = 0.41;\n    \n    float highestBound = 0.9;\n    float lowestBound = -0.1;\n    float openingWidth = 0.2;\n    float openingHeight = threshold;\n    \n    float lowerBoundL = lowestBound + ( openingHeight - lowestBound ) * p.x / ( 0.5 - 0.5 * openingWidth );\n    float upperBoundL = highestBound + ( openingHeight - highestBound ) * p.x / ( 0.5 - 0.5 * openingWidth );\n    float leftmostX = ( p.y - lowestBound ) * ( 0.5 - 0.5 * openingWidth ) / ( openingHeight - lowestBound );\n    \n    float lowerBoundR = lowestBound + ( openingHeight - lowestBound ) * ( 1. - p.x ) / ( 0.5 - 0.5 * openingWidth );\n    float upperBoundR = highestBound + ( openingHeight - highestBound ) * ( 1. - p.x ) / ( 0.5 - 0.5 * openingWidth );\n    float rightmostX = 1. - leftmostX;\n    \n   float off = 0.05 * iTime;\n    \n    if( ( p.y < 1.5 * upperBoundL && p.y > lowerBoundL ) || ( p.y < 1.5 * upperBoundR && p.y > lowerBoundR ) )\n    {\n        float lowerEdge;\n        float lowerBound;\n        float upperBound;\n        float shiftDirection;\n        if( p.y > lowerBoundL )\n        {\n    \t\tlowerEdge = p.x - leftmostX;\n            lowerBound = lowerBoundL;\n            upperBound = upperBoundL;\n            shiftDirection = 1.;\n        }\n        else\n        {\n\t\t\tlowerEdge = rightmostX - p.x;\n\t\t\tlowerBound = lowerBoundR;\n\t\t\tupperBound = upperBoundR;\n\t\t\tshiftDirection = -1.;\n        }\n\n        for ( int i = 0; i < 32; ++i )\n        {\n            float shift = ( float( 31 - i ) ) / 16.;\n           float mahnster = mix( lowerBound, upperBound, \n                                mix( clamp(fbm4( vec2( p.x + shiftDirection * shift , lowerBound + off  ) ) + .8 - .125 * shift,0.517,2.), 1., \n                                    smoothstep(-.08, .0, lowerEdge ) ) );\n           mahnster -= shift * openingHeight ;\n\n           if( abs( p.y - mahnster ) < 0.0031 ) \n           {\n               fragColor += vec4( shift * lineColor , 1.0 );\n               return;\n           }\n           if( p.y < mahnster ) \n               return;\n        }\n    \n    }\n    if( p.y < threshold + thickness )\n    {\n        float horizon = 0.550 ;\n        float fov = 0.75 ;\n        float scaling = 0.2;\n    \n        vec3 fp = vec3( p.x - 0.5, fov, p.y - horizon );      \n        vec2 s = vec2( fp.x / fp.z, fp.y / fp.z - 0.2 * iTime ) * scaling;\n\n        float color = max(triangleF(s.y,.02,.7),\n            max(triangleF(s.x,.02,.7),\n            clamp(0., 1., 1.2 - (0.8 * rand( p + hash( iTime ) ) +  abs( p.x - 0.5 ) + 6. * abs( p.y - threshold ) ) ) )\n        );\n\n        if ( color >= 0.01)\n\t        fragColor += vec4( color * lineColor , 1.0 );\n        return;\n    }\n    else\n    {\n        if( pow( fragCoord.x - circleX, 2. ) + pow( fragCoord.y - circleY, 2. ) < pow( R, 2. ) &&\n             ( fragCoord.y < outerStripe || \n             ( fragCoord.y < lowerStripeBottom && fragCoord.y > lowerStripeTop ) ||\n             ( fragCoord.y < upperStripeBottom && fragCoord.y > upperStripeTop ) ||\n              fragCoord.y > innerStripe ) )\n    \t{\n    \t\tvec3 sunColor = mix( vec3( 1.0, 0.9, 0.3 ), vec3( 1.0, 0.4, .7 ), pow( ( circleY + R - fragCoord.y ) / ( 2. * R ), 2.2 ) );\n        \tfragColor = vec4( sunColor , 1.0 );\n    \t}\n        else\n        {\n\t        vec3 skyColor = mix( vec3( 0.9, 0.4, 0.3 ), vec3( 0.4, 0.5, 0.9 ), ( p.y - 0.5 ) / ( 1. - 0.5 ) );//mix( vec3( 0.8, 0.3, 0.6 ), vec3( 0., 0., 0.1 ), ( p.y - threshold - thickness ) / ( 1. - threshold - thickness ) );\n            fragColor = vec4( skyColor, 1. );\n            float StarFieldThreshhold = 0.985;\n\n            // Stars with a slow spin.\n            float fSpinRate = -0.0125;\n            vec2 vInputPos = ( 2.0 * fragCoord.xy/iResolution.y ) - 1.;\n            float fSampleAngle = fSpinRate * float( iTime ) + atan( vInputPos.y, vInputPos.x );\n            vec2 vSamplePos = ( 0.5 * length( vInputPos ) * vec2( cos( fSampleAngle ), sin( fSampleAngle ) ) + 0.5 ) * iResolution.y;\n            float StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n            fragColor.rgb += StarVal *1.1;\n        }\n        \n        vec2 uv = p;\n        uv.x = floor( uv.x * XPIXELS ) / XPIXELS;\n        uv.y = floor( uv.y * YPIXELS ) / YPIXELS + threshold / 4.;\n        vec2 pos = -1.0 + 2.0 * uv;\n\n        vec3 rayPos = normalize( vec3( pos.x, pos.y, 1. ) );\n        float t = ( 20.0 - rayPos.y ) / rayPos.y;\t\t\n\n        float colv = 0.0;\n        if (t >= 0.0 ) {\t\t\t\t\n            // clouds\n            float cloudA = 1.0;\n            cloudA *= pow(smoothstep(0.0, 1.0, 90.0/t), 1.5);\t// lower dim\n            colv += cloudA * smoothstep(0.0, 0.8, 0.2 + clouds( t * CLOUD_DETAIL * rayPos ) );\n        }\t\t\n\n        colv *= 1.2;\n        colv *= min(1.0, colv);\n\n        //colv = colv - mod( colv * STEPS, 1.0)/STEPS;\n        \n        fragColor *= 1. - colv;\n\t\tfragColor.rb += 0.3 * colv;\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}