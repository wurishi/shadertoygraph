{"ver":"0.1","info":{"id":"tstyzl","date":"1601583188","viewed":300,"name":"Ghost Spinners","username":"savegor","description":"Use mouse to change particle source position.","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["2d","mouse","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec4 apply_world(vec4 next_state, vec2 crd) {\n    \n    vec4 world = texture(iChannel1, crd/iResolution.xy);\n    float free = 1.0 - world.x;\n    next_state.zw = mix(next_state.zw, world.yz, free);\n    \n    float rf = 0.002 *(crd.x - iResolution.x * 0.5) / (0.5 * iResolution.x);\n    \n    vec2 gravity = vec2(0.0, sign(-rf));\n    \n    next_state.zw = mix(next_state.zw, gravity, abs(rf));\n    return next_state;\n}\n\nfloat noise(vec2 st) {\n    return fract(sin(st.x + iTime) * st.y * iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    vec4 next_state = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    for(float shifti = -1.0; shifti < 1.01; shifti += 0.6) {\n        for(float shiftj = -1.0; shiftj < 1.01; shiftj += 0.6) {\n            vec2 crd = fragCoord + vec2(shifti, shiftj);\n            crd = vec2(mod(crd.x, iResolution.x), mod(crd.y, iResolution.y));\n\n            vec2 uv = crd / iResolution.xy;\n            \n            vec4 ng = texture(iChannel0, uv);\n            \n            vec2 cur_move = ng.xy + ng.zw;\n            \n            cur_move = vec2(mod(cur_move.x, iResolution.x), mod(cur_move.y, iResolution.y));\n            \n            vec2 diff = abs(fragCoord - cur_move);\n            \n            if(diff.x <= 1.0 && diff.y <= 1.0) {\n                next_state.xy = cur_move; // coord\n                next_state.zw = ng.zw;    // velocity\n            }\n        };\n    }\n    \n\n    \n    if(distance(fragCoord, iMouse.xy) < 10.0) {\n        vec2 dir = vec2(noise(fragCoord.yy) - 0.5, noise(fragCoord.xx) - 0.5);\n        dir = normalize(dir);\n    \tnext_state = vec4(fragCoord.x, fragCoord.y, dir);   \n    }\n    \n    next_state = apply_world(next_state, fragCoord);\n\tnext_state.zw *= 0.996;\n\n    fragColor = next_state;\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevValue = texture(iChannel1, fragCoord / iResolution.xy);\n    \n    float lightness = 0.0;\n    \n    float vel = 0.0;\n    for(float shifti = -1.0; shifti < 1.01; shifti += 1.0) {\n        for(float shiftj = -1.0; shiftj < 1.01; shiftj += 1.0) {\n            vec2 uv = (fragCoord + vec2(shifti, shiftj)) / iResolution.xy;\n            vec4 photon = texture(iChannel0, uv);\n            float cur_vel = length(photon.zw);\n            lightness += cur_vel * 0.1 / distance(fragCoord, photon.xy);\n            \n            vel = max(vel, cur_vel);\n        }\n    }\n\t\n    vel = min(vel, 1.0);\n    float no_ball = texture(iChannel2, fragCoord / iResolution.xy).r;\n    fragColor = prevValue + lightness *  vec4(vel, 0.5 * vel, (1.0 - vel), 1.0);\n    \n    fragColor -= vec4(0.04);\n    fragColor = max(vec4(0.0), fragColor);\n    fragColor = min(vec4(1.0), fragColor);\n    \n    fragColor = mix(vec4(0.3, 0.5, 0.6, 1.0), fragColor, 1.0);\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// based on : https://www.youtube.com/watch?v=l-07BXzNdPw\n\nfloat N(vec2 st) {\n    float t = iTime * 0.0001;\n    return fract(sin(st.x * st.x + t*t));\n}\n\nvec2 noise(vec2 st) {\n    vec3 a = fract(vec3(st.xyx * vec3(123.3, 234.32, 343.21)));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float t = iTime * 0.93;\n    \n    uv *= 0.6;\n        \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    float minDist = 1.0e6;\n    vec2 cellIndex;\n    \n    vec2 direction = vec2(0.0);\n    \n    for(float y = -1.0; y <= 1.0; y++) {\n        for(float x = -1.0; x <= 1.0; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 n = noise(id + offset);\n            vec2 p = offset + sin(n * t) * 0.5;\n            \n            vec2 diff = gv - p;\n            float d = length(diff);\n            if(d < minDist) {\n                minDist = d;\n                cellIndex = id;\n                direction = vec2(diff.y, -diff.x);\n                \n            }\n        }\n    }\n    direction = normalize(direction);\n    float free_space = float(minDist >= 0.1);\n    \n    fragColor.rgba = vec4(free_space, direction * sin(0.1 * iTime), 1.0);\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}