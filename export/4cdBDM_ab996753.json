{"ver":"0.1","info":{"id":"4cdBDM","date":"1733167527","viewed":62,"name":"Rotating mirrors","username":"SarahGoudy","description":"Rotating bullets each showing different levels of reflectiveness","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["spheres","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Camera setup\n    vec3 cameraPos = vec3(0.0, 0.0, -3.0);\n    float centerSphereRadius = 1.0;    \n    float orbitSphereRadius = 0.5;     \n\n    vec3 centerSphere = vec3(0.0, 0.0, 0.0);\n\n    //Mouse click and drag\n    if (iMouse.z > 0.0) { \n        vec2 mouseNorm = iMouse.xy / iResolution.xy;        \n        centerSphere.x = (mouseNorm.x - 0.5) * 6.0;\n        centerSphere.y = (0.5 - mouseNorm.y) * 6.0;\n    }\n\n    float orbitRadius = 2.5; \n    int numSpheres = 5;      \n\n    \n    vec3 spheres[6];\n    vec3 velocities[6]; \n    float reflectiveness[6]; \n    spheres[0] = centerSphere;\n\n    for (int i = 0; i < numSpheres; i++) {\n        float angle = iTime + (float(i) / float(numSpheres)) * 2.0 * 3.14159265;\n        spheres[i + 1] = centerSphere + vec3(orbitRadius * cos(angle), orbitRadius * sin(angle), 0.0);\n        \n        velocities[i + 1] = normalize(vec3(-spheres[i + 1].y, spheres[i + 1].x, 0.0)) * 0.5;\n\n        reflectiveness[i + 1] = 0.3 + 0.7 * sin(float(i) * 2.0 * 3.14159265 / float(numSpheres));  // Varies from 0.3 to 1.0\n    }\n\n    for (int i = 1; i <= numSpheres; i++) {\n        spheres[i] += velocities[i] * 0.1;\n\n        if (abs(spheres[i].x) > 3.0) {\n            velocities[i].x = -velocities[i].x; \n        }\n        if (abs(spheres[i].y) > 3.0) {\n            velocities[i].y = -velocities[i].y; \n        }\n\n        float angle = iTime + (float(i) / float(numSpheres)) * 2.0 * 3.14159265;\n        spheres[i] = centerSphere + vec3(orbitRadius * cos(angle), orbitRadius * sin(angle), 0.0);\n    }\n\n    //Light setup\n    vec3 lightPos = vec3(0.0, 1.0, -2.0); \n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    //Ray direction\n    vec3 rayDir = normalize(vec3(p, 1.0));\n    \n    float t = 0.0;\n    bool hit = false;\n    vec3 hitPoint = vec3(0.0);\n    vec3 hitNormal = vec3(0.0);\n    vec3 hitSphereCenter = vec3(0.0);\n    float dist;\n    float hitSphereRadius = 0.0;\n    float hitReflectiveness = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        vec3 pos = cameraPos + rayDir * t;\n\n        float closestDist = 10000.0; \n        for (int j = 0; j <= numSpheres; j++) {\n            \n            float radius = (j == 0) ? centerSphereRadius : orbitSphereRadius;\n            float d = length(pos - spheres[j]) - radius;\n\n            if (d < closestDist) {\n                closestDist = d;\n                hitSphereCenter = spheres[j];\n                hitSphereRadius = radius;\n                hitReflectiveness = reflectiveness[j]; \n            }\n        }\n\n        if (closestDist < 0.01) {\n            hit = true;\n            hitPoint = pos;\n            hitNormal = normalize(hitPoint - hitSphereCenter);\n            break;\n        }\n\n        t += closestDist;\n    }\n\n    //Lighting and shading calculation\n    if (hit) {\n        vec3 lightDir = normalize(lightPos - hitPoint);\n        vec3 viewDir = normalize(cameraPos - hitPoint);\n\n        //Diffuse lighting\n        float diff = max(dot(hitNormal, lightDir), 0.0);\n\n        //Specular lighting\n        vec3 reflectDir = reflect(-lightDir, hitNormal);\n        float spec = pow(max(dot(reflectDir, viewDir), 0.0), 32.0);\n\n        //Reflection vector for environment mapping\n        vec3 reflectionVec = reflect(-rayDir, hitNormal);\n        vec2 sphereUV = 0.5 + 0.5 * reflectionVec.xy / length(reflectionVec);\n\n        sphereUV.y = 1.0 - sphereUV.y;\n\n        vec4 envColor = texture(iChannel0, sphereUV);\n\n        vec3 color = mix(envColor.rgb, lightColor * (diff + spec), hitReflectiveness);\n\n        fragColor = vec4(color, 1.0);\n    } else {\n        //Set background image\n        vec2 uv = fragCoord / iResolution.xy;\n        fragColor = texture(iChannel0, uv);\n    }\n}\n","name":"Image","description":"","type":"image"}]}