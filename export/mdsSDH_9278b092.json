{"ver":"0.1","info":{"id":"mdsSDH","date":"1668953971","viewed":146,"name":"Conveyor System","username":"kastorp","description":"work in progress... many things still to add\nsee comments for instructions ","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["game","simulation","conveyors"],"hasliked":0,"parentid":"mdBGWd","parentname":"Highway queues"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Conveyor System by Kastorp\n//-----------------------------------------------\n// BLACK circles are target\n// WHITE circles are source  \n// \n// use gauge selector on a target/source \n// to change its power (red=full, green=stopped) \n//------------------------------------------------\n// TODO\n//  - item types \n//  - statistics\n//  - adjustable semaphores\n//  - variable conveyor speed\n//  - variable conveyor size (8 to 32 slots)\n//  - junction types (splitter, trasnformer, assembler, stack)\n//  - edit mode with dedicated buffer \n//  - better rendering \n//-----------------------------------------------\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   \n    vec2 u =pos(I,R);\n    vec2 M =pos(iMouse.xy,R);\n     \n    vec3 bgcol=mix(vec3(.55,.4,.4),vec3(.5,.4,.6),step(0.,sign(sin(u.x*PI)*sin(u.y*PI)))),\n        col=bgcol; \n\n    for(float j=0.;j<float(NC);j++){\n        \n        int jj=int(j);\n        int cIn=CONNS[jj].x,cOut=CONNS[jj].y;\n        uvec4 data = floatBitsToUint(texelFetch(iChannel0,ivec2(0,jj),0));\n        vec2 s1=NODES[CONNS[jj].y],s2=NODES[CONNS[jj].x];\n\n        if(cIn >=0 && cOut>=0)\n        {\n            vec3 s =segment(u,s1,s2); \n            if((data.z&1u)>0u) {\n                s1=s2+(s1-s2)*(1.- .05/length(s2-s1));\n                if(col==bgcol  &&  length(s.yz-vec2(.07))<.03) col=vec3(.8,0,0);\n                s =segment(u,s1,s2);\n            }\n            if((data.z&2u)>0u) { \n                s2=s1+(s2-s1)*(1.- .03/length(s2-s1));\n                if(col==bgcol  &&  length(s.yz-vec2(.93,.07))<.03) col=vec3(0,.4,0);\n                s =segment(u,s1,s2);\n            }\n\n            if(s.x<.06){\n                float shh=float(iFrame%FR)/float(FR);\n                if(col==bgcol) col=vec3(.25)*(1.-0.*step(.01,s.x))*(.95+.05*sign(sin((s.y*32.+float(iFrame)/float(FR)))));                \n\n                int x=int(s.y*32.);               \n                for(int i=x-2;i<x+2;i++){\n                    if(i<0||i>31)continue;\n                    bool a=  ((data.x &(1u<<i))>0u);  //item in current slot?\n                    bool b=  ((data.y &(1u<<i))>0u);  //item is moving\n                    float sh=  !b? shh*1.:1.; //horizontal shift if moving\n                    float bc=float(i)+1.-sh; //item center\n                    float item=max(abs(s.y*32.-bc)-.4,s.z-.03); //item sdf\n                    if(a &&item<0.) col=b ?vec3(1,.8,0):vec3(1,1,.2);                  \n                }\n\n            }\n            if((data.z&12u)>0u)\n            {\n                float an=float(data.w)*PI/MAXW-PI*.5; \n                vec3 gcol= .6 + .6 * cos( float(data.w)/MAXW*2.  + vec3(4,0,2) ) ;\n                bool isTarget=(data.z&4u)>0u;\n                vec2 c=NODES[isTarget?cOut:cIn];\n                if( length(c-u-vec2(cos(an),sin(an))*.16)<.05) col=gcol;\n                if(col==bgcol && length(c-u)<.15) col=isTarget?vec3(0):vec3(1);    \n\n                if(iMouse.z>0. &&max(length(c-u),length(c-M))<.2 ) col+=vec3(0,0,.5);\n            }\n        }        \n\n    }\n    O = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst uint FULLBIT=0xFFFFFFFFu, MAXBIT=0x80000000U,MINBIT=1u;\n\n#define L(i) floatBitsToUint(texelFetch(iChannel0,ivec2(0,i),0)).x\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   if(I.x>1. && I.y>float(NC)) discard;\n    \n   int id= int (I.y);\n   uvec4 d=floatBitsToUint(texelFetch(iChannel0,ivec2(0,id),0));\n   if(iFrame<5 ) {\n       d= uvec4(0u,0u,0u,uint(MAXW)/4u);\n   }else{\n       \n       int cIn=CONNS[id].x,cOut=CONNS[id].y;\n       if(cIn<0 || cOut<0) return; //unused yet\n       \n       //each pixel is a lane with 32 slots\n       d=floatBitsToUint(texelFetch(iChannel0,ivec2(0,id),0));\n       \n       vec2 s1=NODES[CONNS[id].y],s2=NODES[CONNS[id].x];\n      \n       //source/target power\n       \n       int tra = hash(uvec3(iFrame,I.xy)).x< float(d.w)/MAXW ?1:0; \n\n       int last= 1,first=0,secIn=0,secOut=0,sec=0,type=0;\n       \n       bool rr=true, //todo user defined\n            pr= rr?hash(uvec3(iFrame)).x<.5:false; \n\n       for(int i=0;i<NC;i++){\n           if(i==id)continue;\n           int nIn=CONNS[i].x,nOut=CONNS[i].y;\n            \n           if(CONNS[i].y==cIn) { //entering              \n               if(nIn<0) { first+=tra; type|=2;}\n               else first+= (L(i) & MINBIT)>0u?1:0;\n           }\n           if(nIn==cOut) { //exiting\n                            \n               if(nOut<0) {last*=tra; type|=1;}\n               else last*=  (L(i) & MAXBIT)>0u?1:0;\n          }\n           if(nOut==cOut &&(i<id ^^ pr) ){ //junction Out               \n               sec=1;\n               if(nIn<0) secOut+=(1-tra);\n               else secOut+=(L(i) &MINBIT )>0u?1:0;    \n           } \n           if(nIn==cIn &&(i<id ^^ pr)){ //junction in\n               sec=2;\n               if(nOut<0) secIn+=tra;\n               else secIn+= (L(i) &MAXBIT)>0u?0:1;    \n           }\n           if(rr && nOut==cOut)sec=1;\n           if(rr && nIn==cIn)sec=2;\n        }\n        if(secIn>0 ) first=0;\n        if(secOut>0 ) last=1;        \n\n       uint next= ((d.x& (FULLBIT-MAXBIT))<<1u) + (last>0?MINBIT:0u), \n            prev= ((d.x& (FULLBIT-MINBIT))>>1u) + (first>0?MAXBIT:0u),\n            free=(FULLBIT-d.x), \n            move=free & prev, //move the item in current pos if previous has item and current is free\n            stay=d.x & next; //don't move if there is item in the current and next pos\n\n       //power gauge\n       vec2 m=pos(iMouse.xy,R);\n       vec2 c = (type&1)>0?s1:s2;\n       float w=(atan(-m.y+c.y,-m.x+c.x)+PI*.5);\n\n\n       //update every FR frames\n       if(iFrame%FR==0|| pressed(32)){\n           d.x=move+stay; //x=update item  in the position\n           d.y=stay;      //y=item is stopped  \n           d.z= uint(sec + type*4);\n       }\n       if(type>0 && length(m-c)<.2) d.w=uint(w*MAXW/PI); \n       if((d.z&31u)==0u) d.w=uint(MAXW)/4u; //hack for resolution change\n   \n   }\n    O=uintBitsToFloat(d);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define FR 6 //number of frames between updates (1==max speed)\n#define NC 18  \n#define PI 6.2830\n#define R iResolution.xy\n#define MAXW 32. \n\n// circuit configuration:\n//----------------------------\n// endpoint positions\nvec2[] NODES=vec2[](vec2(-2,-2),vec2(-1,-2),vec2(-1,-1),vec2(-1,0),\n                     vec2(-1,1),vec2(-.5,2),vec2(.5,2),vec2(1.5,2),\n                     \n                     vec2(0,0), vec2(.5,1),vec2(-2,1),vec2(-1.5,2),\n                     vec2(1.5,.5));\n\n// connections  x=from y=to\nivec2[] CONNS=ivec2[](\n                        ivec2(0,1),ivec2(1,2),ivec2(2,3),ivec2(3,4),\n                        ivec2(4,5),ivec2(5,6),ivec2(6,7),\n                        ivec2(7,-1),ivec2(-1,0),\n                        ivec2(10,4),ivec2(-1,10),\n                        ivec2(11,5),ivec2(-1,11),\n                        \n                        ivec2(6,9),ivec2(9,8),ivec2(8,3),         \n                        ivec2(9,12),ivec2(12,-1)\n                        );\n//--------------------------------\n\n//Iq https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 pos(vec2 I,vec2 r) {return (I/r.y *2.- r/r.y)*2.2 ;}\n\nvec3 segment(vec2 p,vec2 a,vec2 b) {\n    float l= length(b - a);\n    vec2 n=normalize(b - a),\n         cp=mix(a, b, clamp(dot(p - a, n) / l, 0., 1.));\n    float x = dot(p-a,n), y = length(p-a-x*n);\n    return vec3(distance(p, cp),x/l,y);\n}\n\n#define  pressed( k)  (texelFetch(iChannel1, ivec2(k, 0), 0).x > 0.5)","name":"Common","description":"","type":"common"}]}