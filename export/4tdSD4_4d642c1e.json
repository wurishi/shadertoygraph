{"ver":"0.1","info":{"id":"4tdSD4","date":"1479633791","viewed":410,"name":"Poincare Disk","username":"soma_arc","description":"Poincare Disk","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 hsv2rgb(vec3 c){\n\tconst vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  \tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  \treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float PI = 3.14159265359;\nconst float PI_2 = PI/2.;\nconst float PI_4 = PI/4.;\n\nconst float fourPI = 12.566368;\nconst float EPSILON = 0.001;\n\nconst vec3 BLACK = vec3(0);\nconst vec3 WHITE = vec3(1.);\nconst vec3 LIGHT_GRAY = vec3(0.78);\nconst vec3 RED = vec3(1, 0, 0);\nconst vec3 GREEN = vec3(0, .78, 0);\nconst vec3 BLUE = vec3(0, 0, 1);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst float NO_HIT = 9999999.;\n\nconst int MTL_PLANE = 0;\nconst int MTL_SPHERE = 1;\nconst int MTL_CYLINDER = 2;\nconst int MTL_RECT = 3;\nint g_mtl = -1;\nconst vec3 ambientFactor = vec3(0.1);\n\n// Represent a sphere which have infinite radius\n// default plane is aligned the z-axis\n// Rotation center is plane's center\nvec4 intersectRect(vec3 center, float size, mat3 rotation,\n                    vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    vec3 n = rotation * vec3(0, 0, 1);\n    vec3 xAxis = rotation * vec3(1, 0, 0);\n    vec3 yAxis = rotation * vec3(0, 1, 0);\n    float d = -dot(center, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n        vec3 p = rayOrigin + t * rayDir;\n        float hSize = size * .5;\n        float x = dot(p - center, xAxis);\n        float y = dot(p - center, yAxis);\n        if(distance(p, center) < 1.5){\n            g_mtl = MTL_RECT;\n            return vec4(t, n);\n        }\n    }\n    return isect;\n}\n\nvec4 intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n        g_mtl = MTL_PLANE;\n    \treturn vec4(t, n);\n    }\n    return isect;\n}\n\nvec4 intersectSphere(vec3 sphereCenter, float radius, \n                      vec3 rayOrigin, vec3 rayDir, vec4 isect){\n  vec3 v = rayOrigin - sphereCenter;\n  float b = dot(rayDir, v);\n  float c = dot(v, v) - radius * radius;\n  float d = b * b - c;\n  if(d >= 0.){\n    float s = sqrt(d);\n    float t = -b - s;\n    if(t <= EPSILON) t = -b + s;\n    if(EPSILON < t && t < isect.x){\n      g_mtl = MTL_SPHERE;\n      vec3 p = (rayOrigin + t * rayDir);\n      return vec4(t, normalize(p - sphereCenter));\n    }\n  }\n  return isect;\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nbool revCircle = false;\nbool revCircle2 = false;\nvec2 cPos1 = vec2(1.2631, 0);\nvec2 cPos2 = vec2(0, 1.2631);\nfloat cr1 = 0.771643;\nfloat cr2 = 0.771643;\nconst int ITERATIONS = 50;\nfloat colCount = 0.;\nbool outer = false;\nint IIS(vec2 pos){\n    colCount = 0.;\n    //if(length(pos) > 1.) return 0;\n\n    bool fund = true;\n    int invCount = 1;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n        fund = true;\n        if (pos.x < 0.){\n            pos *= vec2(-1, 1);\n            invCount++;\n\t       \tfund = false;\n        }\n        if(pos.y < 0.){\n            pos *= vec2(1, -1);\n            invCount++;\n            fund = false;\n        }\n        if(revCircle){\n            if(distance(pos, cPos1) > cr1 ){\n                pos = circleInverse(pos, cPos1, cr1);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }else{\n        \tif(distance(pos, cPos1) < cr1 ){\n                pos = circleInverse(pos, cPos1, cr1);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }\n        \n        if(revCircle2){\n            if(distance(pos, cPos2) > cr2 ){\n                pos = circleInverse(pos, cPos2, cr2);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }else{\n        \tif(distance(pos, cPos2) < cr2 ){\n                pos = circleInverse(pos, cPos2, cr2);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }\n        \n        if(fund){\n            if(length(pos) > 1.5){\n                outer = true;\n            \treturn invCount;\n            }\n        \treturn invCount;\n        }\n    }\n\n\treturn invCount;\n}\n\nfloat g_y;\nmat3 g_rotation;\nconst vec3 SPHERE_CENTER = vec3(0, 0, 0);\nconst float SPHERE_RADIUS = 1.;\nconst float CYLINDER_RADIUS = 0.01;\nvec4 getIntersection(vec3 eye, vec3 ray){\n\tvec4 isect = vec4(NO_HIT);\n    isect = intersectPlane(vec3(0, 0., 0.), vec3(0, 1, 0),\n                            eye, ray, isect);\n    isect = intersectSphere(SPHERE_CENTER, SPHERE_RADIUS,\n                            eye, ray, isect);\n\n    // isect = intersectRect(vec3(0, 0, g_y), 2.5, g_rotation,\n    //               \t   eye, ray, isect);\n    return isect;\n}\n\nbool visible(vec3 eye, vec3 target){\n    vec3 v = normalize(target - eye);\n\treturn getIntersection(eye, v).x == NO_HIT;\n}\n\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  \tvec3 v = lightPos - p;\n  \tfloat d = dot(n, normalize(v));\n  \tfloat r = length(v);\n  \treturn (d > 0. && visible(p + EPSILON * n, lightPos)) ?\n    \t(lightPower * (d / (fourPI * r * r))) * diffuseColor\n    \t: BLACK;\n}\n\nconst vec3 LIGHT_POS = vec3(0, 5, 1);\nconst vec3 LIGHT_POWER = vec3(150.);\nconst float transparency = 0.6;\nconst int MAX_TRACE_DEPTH = 7;\nconst vec3 LIGHT_DIR = normalize(vec3(0.0, 1., 0.5));\nvec3 calcColor(vec3 eye, vec3 ray){\n    vec3 l = BLACK;\n    float coeff = 1.0;\n   \tfor (int depth = 0 ; depth < MAX_TRACE_DEPTH ; depth++){\n        vec4 isect = getIntersection(eye, ray);\n        if(isect.x != NO_HIT){\n            vec3 matColor = WHITE;\n            vec3 intersection = eye + ray * isect.x;\n            vec3 normal = isect.yzw;\n            if(g_mtl == MTL_PLANE){\n                matColor = vec3(0.7);\n         \t\tint d = IIS(intersection.xz);\n       \t\t    if(d == 0){\n\t\t\t\t\tmatColor += vec3(0.,0.,0.);\n\t\t\t\t}else{\n\t\t\t\t\tif(mod(float(d), 2.) == 0.){\n    \t\t            if(outer){\n\t                \t\tmatColor = hsv2rgb(vec3(0.25 , 1., 1.));\n           \t\t\t    }else{\n                    \t\tmatColor = hsv2rgb(vec3(0. , 1., 1.));\n            \t\t\t}\n            \t\t}else{\n                        if(outer){\n                            matColor = hsv2rgb(vec3(0.75 , 1., 1.));\n                        }else{\n                            matColor = hsv2rgb(vec3(0.5 + 0. , 1., 1.));\n                        }\n          \t\t\t}\n                }\n            }else if(g_mtl == MTL_SPHERE){\n                matColor = vec3(0.7, 0.4, 0.4);\n            }else if(g_mtl == MTL_CYLINDER){\n                matColor = GREEN;\n            }else if(g_mtl == MTL_RECT){\n            \tmatColor = GREEN;\n            }\n            // diffuse lighting by directionalLight\n            vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n            //vec3 diffuse = diffuseLighting(intersection, normal, matColor,\n            //                                LIGHT_POS, LIGHT_POWER);\n            vec3 ambient = matColor * ambientFactor;\n            if(g_mtl == MTL_SPHERE || g_mtl == MTL_RECT){\n                coeff *= transparency;\n                l += (diffuse + ambient) * coeff;\n\t\t        eye = intersection + ray * 0.01;\n                continue;\n            }else{\n            \tl += (diffuse + ambient) * coeff;\n            }\n        }\n        break;\n    }\n\treturn l;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n      \t        (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target,\n              const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(radians(fov) * .5);\n  vec3 v = normalize(target - eye);\n  vec3 focalXAxis = normalize(cross(v, up));\n  vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n  return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n}\n\nvec2 reverseStereoProject(vec3 pos){\n\treturn vec2(pos.x / (1. - pos.z), pos.y / (1. - pos.z));\n}\n\nvec3 getCircleFromSphere(vec3 upper, vec3 lower){\n\tvec2 p1 = reverseStereoProject(upper);\n    vec2 p2 = reverseStereoProject(lower);\n   \treturn vec3((p1 + p2) / 2., distance(p1, p2)/ 2.); \n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    float t = mod(iTime, 8.);\n    t = abs(t - 4.) / 5.5;\n    \n    float x = 0.57735;\n    float bendX = 0.;\n    mat3 xRotate = mat3(1, 0, 0,\n                        0, cos(bendX), -sin(bendX),\n                        0, sin(bendX), cos(bendX));\n    float bendY = 0.;\n    mat3 yRotate = mat3(cos(bendY), 0, sin(bendY),\n                         0, 1, 0,\n                         -sin(bendY), 0, cos(bendY));\n\tfloat y = .57735;\n    g_y = y;\n    vec3 c1 = getCircleFromSphere(vec3(0, y, sqrt(1. - y * y))* xRotate,\n                                  vec3(0, y, -sqrt(1. - y * y))* xRotate);\n    vec3 c2 = getCircleFromSphere(vec3(x, 0, sqrt(1. - x * x)) * yRotate,\n                                  vec3(x, 0, -sqrt(1. - x * x)) * yRotate);\n    g_rotation = xRotate;\n\tcr1 = c1.z;\n    cr2 = c2.z;\n    cPos1 = c1.xy;\n    cPos2 = c2.xy;\n    if(y > cPos1.y){\n    \trevCircle = true;\n    }\n\tif(x > cPos2.x){\n    \trevCircle2 = true;\n    }\n    float dist = 2.;\n\t//vec3 eye = vec3(0, .5, 2);\n    vec3 eye = vec3(dist * sin(iTime), 1.5, dist * cos(iTime));\n\n    vec3 target = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    float fov = 60.;\n    \n  \tvec3 sum = vec3(0);\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(eye, ray);\n  \t}\n \t vec3 col = (sum/SAMPLE_NUM);\n          \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}","name":"Image","description":"","type":"image"}]}