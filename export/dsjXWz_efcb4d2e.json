{"ver":"0.1","info":{"id":"dsjXWz","date":"1670178741","viewed":111,"name":"\"planet terrain glsl shader\"","username":"ChatGPTGeneratedGems","description":"see https://www.shadertoy.com/view/dsjSDR","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test","fun","ai","gpt"],"hasliked":0,"parentid":"ds2SWz","parentname":"fancy Shadertoy shader"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// one of the first valid shaders generated by prompt: \"planet terrain glsl shader in shadertoy\" on chat.openai.com/chat\n//\n// just for testing purposes and/or inspiration\n//\n\n\n\n// ### noise function was not generated so I took it from https://www.shadertoy.com/view/Ms2SD1\n\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// #####################################################################################################################\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate the noise texture\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    uv.x+=iTime*0.1;\n    uv.y+=iTime*0.1;\n    \n    \n    float n = noise( uv * 10.0 );\n    \n    // Apply tiling to the noise texture\n    n = mod( n, 0.5 );\n    \n    // Create smooth transitions between height levels\n    n = smoothstep( 0.25, 0.3, n );\n    n = smoothstep( 0.45, 0.5, n );\n    \n    // Generate the coordinates of the sphere mesh using spherical coordinates\n    float u = uv.x * 2.0 * 3.14159;\n    float v = uv.y * 3.14159;\n    vec3 p = vec3(\n        cos( u ) * sin( v ),\n        cos( v ),\n        sin( u ) * sin( v )\n    );\n    \n    // Displace the vertices of the sphere using the heightmap values\n    p += normalize( p ) * n * 0.1;\n    \n    // Calculate the partial derivatives of the displaced sphere with respect to the uv coordinates\n    vec3 dpdu = vec3(\n        -sin( u ) * sin( v ),\n        0.0,\n        cos( u ) * sin( v )\n    );\n    vec3 dpdv = vec3(\n        cos( u ) * cos( v ),\n        -sin( v ),\n        sin( u ) * cos( v )\n    );\n    \n    // Calculate the surface normals of the displaced sphere\n    vec3 nrm = cross( dpdu, dpdv );\n    \n    // Use the surface normals to determine the lighting of the terrain\n    float lighting = dot( nrm, normalize( vec3( 1, 1, 1 ) ) );\n    lighting = mix( 0.2, 0.8, lighting );\n    \n    // Generate the final color of the fragment\n    fragColor = vec4( n * lighting );\n}\n\n","name":"Image","description":"","type":"image"}]}