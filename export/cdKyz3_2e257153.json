{"ver":"0.1","info":{"id":"cdKyz3","date":"1696404290","viewed":185,"name":"Hex tiling with integer indices","username":"Suslik","description":"This is my implementation of hex tiling that in addition to floating point coordinates of the nearest tile, also returns an ivec2 index associated with it. Indices come in increments of 3, so that 3 such grids span the entire ivec2 space with no gaps.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["tiling","hex","minimal","ivec2","adorable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//This demo follows the same basic scheme used here https://www.shadertoy.com/view/MlXyDl by lomateron, but in addition to returning\n//each hex tile's center in world space, it also returns its ivec2 index in index space. The indices are specifically constructed in a way\n//where coordinates are incremented with a stride of 3 horizontally, so that 3 such grids cover the entire space of ivec2 coordinates with no \"gaps\", which is what's\n//it's intended to be used for.\n\n#define pi 3.141582f\n\n//Hexagon grid is constructed from two rectilinear grids offset from each other by half a cell:\n\n//<grid_step.x>                                     \n//0 -   -   - 0 -   -   - 0 -   -   - 0 -   -   - 0\n//|           |           |           |           |\n//      1           1           1           1      \n//|           |           |           |           |\n//0 -   -   - 0 -   -   - 0 -   -   - 0 -   -   - 0\n//|           |           |           |           |\n//      1           1           1           1      \n//|           |           |           |           |\n//0 -   -   - 0 -   -   - 0 -   -   - 0 -   -   - 0\n//|           |           |           |           |\n//      1           1           1           1      \n//|           |           |           |           |\n//0 -   -   - 0 -   -   - 0 -   -   - 0 -   -   - 0\n//|           |           |           |           |\n//      1           1           1           1      \n//|           |           |           |           |\n//0 -   -   - 0 -   -   - 0 -   -   - 0 -   -   - 0 ^\n//|           |           |           |           |\n//      1           1           1           1       grid_step.y\n//|           |           |           |           |\n//0 -   -   - 0 -   -   - 0 -   -   - 0 -   -   - 0 v\n\n//For a given sample point, first the nearest point in each grid is found (in grid0 and grid1)\n//And then the closest one of these two points corresponds to the center of the nearest hex:\n//0   . - .   0   . - .   0   . - .   0   . - .   0\n//   /     \\     /     \\     /     \\     /     \\   \n//- .   1   . - .   1   . - .   1   . - .   1   . -  \n//   \\     /     \\     /     \\     /     \\     /  \n//0   . - .   0   . - .   0   . - .   0   . - .   0\n//   /     \\     /     \\     /     \\     /     \\   \n//- .   1   . - .   1   . - .   1   . - .   1   . -  \n//   \\     /     \\     /     \\     /     \\     /  \n//0   . - .   0   . - .   0   . - .   0   . - .   0\n//   /     \\     /     \\     /     \\     /     \\   \n//- .   1   . - .   1   . - .   1   . - .   1   . -  \n//   \\     /     \\     /     \\     /     \\     /  \n//0   . - .   0   . - .   0   . - .   0   . - .   0\n//   /     \\     /     \\     /     \\     /     \\   \n//- .   1   . - .   1   . - .   1   . - .   1   . -  \n//   \\     /     \\     /     \\     /     \\     /  \n//0   . - .   0   . - .   0   . - .   0   . - .   0\n//   /     \\     /     \\     /     \\     /     \\   \n//- .   1   . - .   1   . - .   1   . - .   1   . -  \n//   \\     /     \\     /     \\     /     \\     /  \n//0   . - .   0   . - .   0   . - .   0   . - .   0\n\n\n//However, the goal of this demo is to assign an ivec2 index/ID to each hex. This is accomplished by constructing\n//the following skewed basis:\n//0 - . - . - 0 - . - . - 0 - . - . - 0 - . - . - 0\n//   /   /   /   /   /   /   /   /   /   /   /   / \n//- . - 1 - . - . - 1 - . - . - 1 - . - . - 1 - . -  \n// /   /   /   /   /   /   /   /   /   /   /   /  \n//0 - . - . - 0 - . - . - 0 - . - . - 0 - . - . - 0\n//   /   /   /   /   /   /   /   /   /   /   /   / \n//- . - 1 - . - . - 1 - . - . - 1 - . - . - 1 - . -  \n// /   /   /   /   /   /   /   /   /   /   /   /  \n//0 - . - . - 0 - . - . - 0 - . - . - 0 - . - . - 0\n//   /   /   /   /   /   /   /   /   /   /   /   / \n//- . - 1 - . - . - 1 - . - . - 1 - . - . - 1 - . -  \n// /   /   /   /   /   /   /   /   /   /   /   /  \n//0 - . - . - 0 - . - . - 0 - . - . - 0 - . - . - 0\n//   /   /   /   /   /   /   /   /   /   /   /   / \n//- . - 1 - . - . - 1 - . - . - 1 - . - . - 1 - . -  \n// /   /   /   /   /   /   /   /   /   /   /   /  \n//0 - . - . - 0 - . - . - 0 - . - . - 0 - . - . - 0\n//   /   /   /   /   /   /   /   /   /   /   /   / \n//- . - 1 - . - . - 1 - . - . - 1 - . - . - 1 - . -  \n// /   /   /   /   /   /   /   /   /   /   /   /  \n//0 - . - . - 0 - . - . - 0 - . - . - 0 - . - . - 0\n//The diagram above demonstrates how 3 such grids (offset by (0, 0), (1, 0) and (2, 0)) cover all \".\" nodes.\n\n//In this diagram each \"-\" corresponds to x_vec in world space, each \"/\" corresponds to y_vec\n//x_vec and y_vec are chosen such that the distance between two adjacent hexes is exactly 1.0f\nconst float scale = 1.0f / sqrt(3.0f);\nconst vec2 x_vec = vec2(1.0f, 0.0f) * scale;\nconst vec2 y_vec = vec2(cos(pi / 3.0f), sin(pi / 3.0f)) * scale;\n\n//Trivial vector artithmetics shows that:\n//\"\\\" = -\"-\" + \"/\" = -x_vec + y_vec\n\n//2 * | = -\"-\" + 2 * \"/\" = -x_vec + 2 * y_vec\n//Or in other words:\n//(grid_step.x, 0) = 3 * \"-\" = 3 * x_vec\n//(0, grid_step.y) = 2 * \"|\" = -\"-\" + 2 * \"/\" = -x_vec + 2 * y_vec\nconst vec2 grid_step = vec2(3.0f * x_vec.x, 2.0f * y_vec.y);\n\n\n//As for indices, each \"-\" corresponds to (1, 0) index offset, each \"/\" corresponds to (0, 1) index offset\n//hence grid stepping in index space is (3, 1) horizontally and (-1, 2) vertically\n\n//Two grids are offset from each other by (0.5, 0.5) in grid index space, by (1, 1) in hex index space and by (x_vec+y_vec) in world space\n\nvec2 GetHexCenter(vec2 grid_indexf)\n{\n    //return mat2(3.0f * x_vec, -x_vec + 2.0f * y_vec) * grid_indexf;\n    return grid_step * grid_indexf; //shorter form of the above\n}\nivec2 GetHexIndex(ivec2 grid_indexi)\n{\n    return ivec2(3, 0) * grid_indexi.x + ivec2(-1, 2) * grid_indexi.y;\n}\n\nfloat sqrlen(vec2 v){return dot(v, v);}\n\nstruct HexNode\n{\n    ivec2 index;\n    vec2 pos;\n};\nHexNode GetClosestHexNode(vec2 pos)\n{\n    vec2 base_index = pos / grid_step;\n    vec4 grid_indices = floor(base_index.xyxy + vec4(vec2(0.5f), vec2(0.0f)));\n    \n    vec4 hex_centers = vec4(GetHexCenter(grid_indices.xy), GetHexCenter(grid_indices.zw) + x_vec + y_vec);\n    ivec4 hex_indices = ivec4(GetHexIndex(ivec2(grid_indices.xy)), GetHexIndex(ivec2(grid_indices.zw)) + ivec2(1, 1));\n    \n    bool b = sqrlen(pos - hex_centers.xy) < sqrlen(pos - hex_centers.zw);\n    HexNode node;\n    node.pos = b ? hex_centers.xy : hex_centers.zw;\n    node.index = b ? hex_indices.xy : hex_indices.zw;\n    return node;\n}\n\nivec2 SignedMod(ivec2 a, ivec2 b)\n{\n  return ((a % b) + b) % b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / 40.0f;\n    HexNode node = GetClosestHexNode(pos);\n\n    // Output to screen\n    fragColor = vec4(vec2(length(node.pos - pos)) * 1.8f * vec2(SignedMod(node.index, ivec2(12))) / 12.0f, 0.0f, 1.0f);\n}","name":"Image","description":"","type":"image"}]}