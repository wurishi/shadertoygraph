{"ver":"0.1","info":{"id":"wlKBzt","date":"1614952531","viewed":98,"name":"pathtracing test-3","username":"matlabman","description":"Press space to reset.\nReference: https://blog.demofox.org/2020/06/14/casual-shadertoy-path-tracing-3-fresnel-rough-refraction-absorption-orbit-camera/\nhttps://www.shadertoy.com/view/ttfyzN","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color = LinearToSRGB(color);\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// camera\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{\n    // if the mouse is at (0,0) it hasn't been moved yet, so use a default camera setup\n    vec2 mouse = iMouse.xy;\n    //mouse = vec2(0.0, 0.0);\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n    {\n        cameraPos = vec3(0.0f, 0.0f, -c_cameraDistance + c_cameraAt.z);\n        cameraFwd = vec3(0.0f, 0.0f, 1.0f);\n        cameraUp = vec3(0.0f, 1.0f, 0.0f);\n        cameraRight = vec3(1.0f, 0.0f, 0.0f);\n        return;\n    }\n     \n    // otherwise use the mouse position to calculate camera position and orientation\n    //bool Dpressed = (texture(iChannel2, vec2(37.5 / 256.0,0.25)).x > 0.1);\n    //bool Dpressed = (texelFetch( iChannel2, ivec2(KEY_UP,1),0 ).x > 0.1);\n    float angleX = -mouse.x * 5.0f / float(iResolution.x);\n    //float angleX = c_pi;\n    //if (Dpressed)\n        //angleX += c_pi * 5.0 / 180.0;\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n     \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n     \n    cameraPos += c_cameraAt;\n     \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(vec3(0.0f, 1.0f, 0.0f), cameraFwd));\n    cameraUp = normalize(cross(cameraFwd, cameraRight));   \n}  \n \nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\n// fresnel effect\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return f90;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        return mix(f0, f90, ret);\n}\n// intersect with rect\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;\n        info.normal = normal;\n        info.fromInside = false;\n        return true;\n    }    \n    \n    return false;\n}\n// set material properties to 0\nSMaterialInfo GetZeroedMaterial()\n{\n    SMaterialInfo ret;\n    ret.albedo = vec3(0.0f, 0.0f, 0.0f);\n    ret.emissive = vec3(0.0f, 0.0f, 0.0f);\n    ret.specularChance = 0.0f;\n    ret.specularRoughness = 0.0f;\n    ret.specularColor = vec3(0.0f, 0.0f, 0.0f);\n    ret.IOR = 1.0f;\n    ret.refractionChance = 0.0f;\n    ret.refractionRoughness = 0.0f;\n    ret.refractionColor = vec3(0.0f, 0.0f, 0.0f);\n    return ret;\n}\n// intersect with sphere\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n    // vector from rays to sphere centre.\n\tvec3 m = rayPos - sphere.xyz;\n\n    // signed distance from rays to sphere centre project on rayDir\n\tfloat b = dot(m, rayDir);\n    \n    // tangent distance^2 from rays to sphere, bigger than 0-> outside the sphere, smaller than 0, means inside\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant, tangent is the critical\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t// cal intersection point coord\n    // b ^ 2 - 4 * a * c \n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    // dist within constrain, true\n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;\n        info.fromInside = fromInside;\n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n\n    // floor\n    {\n        vec3 A = vec3(-35.6f, -12.52f, 55.0f) + sceneTranslation;\n        vec3 B = vec3( 35.6f, -12.52f, 55.0f) + sceneTranslation;\n        vec3 C = vec3( 35.6f, -12.52f, -15.0f) + sceneTranslation;\n        vec3 D = vec3(-35.6f, -12.52f, -15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n            //hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.specularChance = 0.0;\n            hitInfo.material.specularRoughness = 0.0;\n            hitInfo.material.specularColor = vec3(0.7, 0.7, 0.7);\n            hitInfo.material.refractionChance = 0.0f;\n            hitInfo.material.refractionRoughness = 0.0;\n            hitInfo.material.refractionColor = vec3(0.0f, 0.0f, 0.0f);\n            //float shade = floor(mod(hitPos.x, 2.0f) * 1.0f);\n            float shade = 0.1;\n            float shadeX = floor(mod(hitPos.x, 5.0f) * 0.4);\n            float shadeZ = floor(mod(hitPos.z, 5.0f) * 0.4);\n            if (shadeX == 0.0 && shadeZ == 0.0)\n                shade = 1.0;\n            else if (shadeX == 1.0 && shadeZ == 1.0)\n                shade = 1.0;\n            hitInfo.material.albedo = vec3(shade, shade, shade);\n        }        \n    }   \n    \n     // light\n     {\n         vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n         vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n         vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n         vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n         if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n         {\n             hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n             hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 15.0f;\n         }        \n     }\n    \n    // 1\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.8f, 0.1f, 0.1f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.specularChance = 0.1;\n        hitInfo.material.specularRoughness = 0.8;\n        hitInfo.material.specularColor = vec3(0.7, 0.7, 0.7);\n        hitInfo.material.IOR = 1.5;\n        //hitInfo.material.IOR = 1.1f;\n        hitInfo.material.refractionChance = 0.1f;\n        hitInfo.material.refractionRoughness = 0.8;\n        hitInfo.material.refractionColor = vec3(0.0f, 0.1f, 0.0f);\n    } \n    // 2\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.3f, 0.3f, 0.9f);\n        hitInfo.material.emissive = vec3(0.1f, 0.1f, 0.8f) * 6.0;\n        hitInfo.material.specularChance = 0.2;\n        hitInfo.material.specularRoughness = 0.8;\n        hitInfo.material.specularColor = vec3(0.7, 0.7, 0.7);\n        hitInfo.material.IOR = 1.5;\n        hitInfo.material.refractionChance = 0.0f;\n        hitInfo.material.refractionRoughness = 0.0;\n        hitInfo.material.refractionColor = vec3(0.0f, 0.0f, 0.0f);\n    }    \n    // 3\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.1f, 0.9f, 0.1f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.specularChance = 0.8;\n        hitInfo.material.specularRoughness = 0.05;\n        hitInfo.material.specularColor = vec3(0.7, 0.7, 0.7);\n        hitInfo.material.IOR = 1.5;\n        hitInfo.material.refractionChance = 0.0f;\n        hitInfo.material.refractionRoughness = 0.0;\n        hitInfo.material.refractionColor = vec3(0.0f, 0.0f, 0.0f);\n    }\n    // 4\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, -0.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.1f, 0.1f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.specularChance = 0.01;\n        hitInfo.material.specularRoughness = 0.1;\n        hitInfo.material.specularColor = vec3(0.7, 0.7, 0.7);\n        hitInfo.material.IOR = 1.3;\n        hitInfo.material.refractionChance = 0.9f;\n        hitInfo.material.refractionRoughness = 0.1;\n        hitInfo.material.refractionColor = vec3(0.1f, 0.9f, 0.9f);\n    }\n    // 5\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(3.0f, -9.5f, 10.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.5f, 0.9f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.specularChance = 0.01;\n        hitInfo.material.specularRoughness = 0.6;\n        hitInfo.material.specularColor = vec3(0.7, 0.7, 0.7);\n        hitInfo.material.IOR = 1.2;\n        hitInfo.material.refractionChance = 0.9f;\n        hitInfo.material.refractionRoughness = 0.1;\n        hitInfo.material.refractionColor = vec3(0.1f, 0.8f, 0.8f) * 0.1;\n    }\n}\n \nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    // initialize\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n    // tracing\n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        // shoot a ray out into the world\n        SRayHitInfo hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = c_superFar;\n        hitInfo.fromInside = false;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n\n        // if the ray missed, ret += skybox\n        if (hitInfo.dist == c_superFar)\n        {\n            ret += SRGBToLinear(texture(iChannel1, rayDir).rgb) * throughput;\n            break;\n        }\n\n        // absorption if we are hitting from inside the object\n        if (hitInfo.fromInside)\n            throughput *= exp(-hitInfo.material.refractionColor * hitInfo.dist);\n\n        // get the pre-fresnel chances\n        float specularChance = hitInfo.material.specularChance;\n        float refractionChance = hitInfo.material.refractionChance;\n        //float diffuseChance = max(0.0f, 1.0f - (refractionChance + specularChance));\n\n        // take fresnel into account for specularChance and adjust other chances.\n        // specular takes priority.\n        // chanceMultiplier makes sure we keep diffuse / refraction ratio the same.\n        float rayProbability = 1.0f;\n        if (specularChance > 0.0f)\n        {\n            specularChance = FresnelReflectAmount(\n            hitInfo.fromInside ? hitInfo.material.IOR : 1.0,\n            !hitInfo.fromInside ? hitInfo.material.IOR : 1.0,\n            rayDir, hitInfo.normal, hitInfo.material.specularChance, 1.0f);\n\n            float chanceMultiplier = (1.0f - specularChance) / (1.0f - hitInfo.material.specularChance);\n            refractionChance *= chanceMultiplier;\n            //diffuseChance *= chanceMultiplier;\n        }\n\n        // calculate whether we are going to do a diffuse, specular, or refractive ray\n        float doSpecular = 0.0f;\n        float doRefraction = 0.0f;\n        float raySelectRoll = RandomFloat01(rngState);\n        if (specularChance > 0.0f && raySelectRoll < specularChance)\n        {\n            doSpecular = 1.0f;\n            rayProbability = specularChance;\n        }\n        else if (refractionChance > 0.0f && raySelectRoll < specularChance + refractionChance)\n        {\n            doRefraction = 1.0f;\n            rayProbability = refractionChance;\n        }\n        else\n        {\n            rayProbability = 1.0f - (specularChance + refractionChance);\n        }\n\n        // numerical problems can cause rayProbability to become small enough to cause a divide by zero.\n        rayProbability = max(rayProbability, 0.001f);\n\n        // update the ray position\n        if (doRefraction == 1.0f)\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;\n        }\n        else\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        }\n\n        // Calculate a new ray direction.\n        // Diffuse uses a normal oriented cosine weighted hemisphere sample.\n        // Perfectly smooth specular uses the reflection ray.\n        // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n        // Squaring the roughness is just a convention to make roughness feel more linear perceptually.\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        // mix specular with roughness\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness*hitInfo.material.specularRoughness));\n        // mix refraction with roughness\n        vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? hitInfo.material.IOR : 1.0f / hitInfo.material.IOR);\n        refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + RandomUnitVector(rngState)), hitInfo.material.refractionRoughness*hitInfo.material.refractionRoughness));\n        // final rayDir, specular priority\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        rayDir = mix(rayDir, refractionRayDir, doRefraction);\n\n        // add in emissive lighting\n        ret += hitInfo.material.emissive * throughput;\n\n        // update the colorMultiplier. refraction doesn't alter the color until we hit the next thing, so we can do light absorption over distance.\n        if (doRefraction == 0.0f)\n            throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);\n\n        // since we chose randomly between diffuse, specular, refract,\n        // we need to account for the times we didn't do one or the other.\n        throughput /= rayProbability;\n\n        // Russian Roulette\n        // As the throughput gets smaller, the ray is more likely to get terminated early.\n        // Survivors have their value boosted to make up for fewer samples being in the average.\n        {\n            float p = max(throughput.r, max(throughput.g, throughput.b));\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            // Add the energy we 'lose' by randomly terminating paths\n            throughput *= 1.0f / p;            \n        }\n    }\n  \n    // return pixel color\n    return ret;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n     \n    // The ray starts at the camera position (the origin)\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n\n    // TAA frame average\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);\n    \n    vec3 rayDir;\n    {   \n        // calculate a screen position from -1 to +1 on each axis\n        vec2 uvJittered = (fragCoord+jitter)/iResolution.xy;\n        vec2 screen = uvJittered * 2.0f - 1.0f;\n         \n        // adjust for aspect ratio\n        float aspectRatio = iResolution.x / iResolution.y;\n        screen.y /= aspectRatio;\n                 \n        // make a ray direction based on camera orientation and field of view angle\n        float cameraDistance = tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    // raytrace for this pixel\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    for (int index = 0; index < c_numRendersPerFrame; ++index)\n    \tcolor += GetColorForRay(cameraPos, rayDir, rngState) / float(c_numRendersPerFrame);\n    \n     \n    bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n\n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (iFrame < 2 || iMouse.z > 0.0 || lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n    \n    \n    // show the result\n    fragColor = vec4(color, blend);\n \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.01f;\n\n// the farthest we look for ray hits\nconst float c_superFar = 10000.0f;\n// FOV C_pi \nconst float c_FOVDegrees = 90.0;\n\n// number of ray bounces allowed\nconst int c_numBounces = 8;\n\n// how many renders per frame - to get around the vsync limitation.\nconst int c_numRendersPerFrame = 20;\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\n// Average weight\nconst float MAX_WEIGHT = 1.0;\n\n// mouse camera control parameters\nconst float c_minCameraAngle = 0.01f;\nconst float c_maxCameraAngle = (c_pi - 0.01f);\nconst vec3 c_cameraAt = vec3(0.0f, -6.0f, 20.0f);\nconst float c_cameraDistance = 20.0f;\n\n// material info\nstruct SMaterialInfo\n{\n    vec3 albedo;               // the color used for diffuse lighting\n    vec3 emissive;             // how much the surface glows\n    float specularChance;      // percentage chance of doing specular instead of diffuse lighting\n    float specularRoughness;           // how rough the specular reflections are\n    vec3 specularColor;        // the color tint of specular reflections\n    float IOR;                 // Index of refraction\n    float refractionChance;    // percent chance of doing a refractive transmission; sum of diffuse, relection and refraction should be 1\n    float refractionRoughness; // how rough the refractive transmissions are\n    vec3  refractionColor;     // absorption for beer's law  \n};\n\nstruct SRayHitInfo\n{\n    bool fromInside;\n    float dist;\n    vec3 normal;\n    SMaterialInfo material;\n};\n\n// RGB to linear, liner to RGB\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n// random number generate\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n// Keyboard input\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;","name":"Common","description":"","type":"common"}]}