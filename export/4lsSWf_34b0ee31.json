{"ver":"0.1","info":{"id":"4lsSWf","date":"1440550986","viewed":176,"name":"tri-tex-test","username":"ap","description":"triangle texture test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["test","triangle","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n\n// -------------------------------\n//   Global parameters\n// -------------------------------\nconst float shear = 0.0; // <--- set this to 0.5 for better triangular mode\n\nconst vec4 v4red = vec4(1.0, 0.0, 0.0, 1.0);\n\nvec3 fetchTexelHW(in vec2 uv)\n{\n    return texture( iChannel0, uv, 0.0 ).xyz;\n}\n\nvoid fetchTexels(in vec2 uv, out vec3 colA0, out vec3 colA1, out vec3 colA2, out vec3 colA3, out vec2 uvpx_f)\n{\n    vec2 uvpx = uv * vec2(iChannelResolution[0].xy) - vec2(0.5);\n    uvpx_f = fract( uvpx );\n    vec2 uvpx_i = floor( uvpx ) + vec2(0.5);\n\n    vec2 uv_i = (uvpx_i / iChannelResolution[0].xy);\n    vec2 uv0 = uv_i;\n    vec2 uv1 = uv_i + (vec2(1,0) / iChannelResolution[0].xy);\n    vec2 uv2 = uv_i + (vec2(0,1) / iChannelResolution[0].xy);\n    vec2 uv3 = uv_i + (vec2(1,1) / iChannelResolution[0].xy);\n\n    colA0 = fetchTexelHW(uv0);\n    colA1 = fetchTexelHW(uv1);\n    colA2 = fetchTexelHW(uv2);\n    colA3 = fetchTexelHW(uv3);\n}\n\nvec3 rectFilter(in vec3 colA0, in vec3 colA1, in vec3 colA2, in vec3 colA3, in vec2 uvpx_f)\n{\n    return mix ( mix( colA0, colA1, uvpx_f.x ), mix( colA2, colA3, uvpx_f.x ), uvpx_f.y );\n}\n\nvec3 triFilter(in vec3 colA0, in vec3 colA1, in vec3 colA2, in vec3 colA3, in vec2 uvpx_f)\n{\n    float u = uvpx_f.x;\n    float v = uvpx_f.y;\n    if((u+v) <= 1.0) { return ((1.0 - u - v) * colA0 + (u)       * colA1 + (v)       * colA2); }\n    else {             return ((u + v - 1.0) * colA3 + (1.0 - u) * colA2 + (1.0 - v) * colA1); }\n}\n\nvec3 getTextureRectHW(vec2 uv)\n{\n    return texture(iChannel0, uv, 0.0).xyz;\n}\n\n\nvec3 getTextureRectSW(vec2 uv)\n{\n    vec3 colA0, colA1, colA2, colA3;\n    vec2 uvpx_f;\n    fetchTexels(uv, colA0, colA1, colA2, colA3, uvpx_f);\n    vec3 colA = mix ( mix( colA0, colA1, uvpx_f.x ),\n       mix( colA2, colA3, uvpx_f.x ),\n       uvpx_f.y );\n    return colA;\n}\n\nvec3 getTextureTriSW(vec2 uv)\n{\n    vec3 colA0, colA1, colA2, colA3;\n    vec2 uvpx_f;\n    fetchTexels(uv, colA0, colA1, colA2, colA3, uvpx_f);\n    vec3 colA = triFilter(colA0, colA1, colA2, colA3, uvpx_f);\n    return colA;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy + 7.*vec2(5.,2.) * vec2(float(iTime))) / float(iResolution.y);\n      \n    float linewidth = 3.0 / iResolution.y;\n\n    \n    vec2 uvpos = vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y);\n    \n    float diagonalpos = uvpos.x + uvpos.y;\n    \n    float texScale = 100.0 / iResolution.x;\n    \n    if(uvpos.x < 0.33) texScale = texScale * 9.0;\n    else if (uvpos.x < 0.66) texScale = texScale * 3.0;\n    \n    uv.x = uv.x - uv.y * shear;\n    \n    uv /= texScale;\n    \n    if(uvpos.y < 0.5) {\n        fragColor = vec4(getTextureRectSW(uv), 1.0);\n    }\n    else {\n        fragColor = vec4(getTextureTriSW(uv), 1.0);\n    }\n\n    fragColor = mix(fragColor, \n        v4red, \n        clamp(1.0 - abs(uvpos.y - 0.5)/linewidth, 0.0, 1.0));\n\n}","name":"Image","description":"","type":"image"}]}