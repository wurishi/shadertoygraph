{"ver":"0.1","info":{"id":"fsccDl","date":"1654205384","viewed":270,"name":"Ingress","username":"KrissLaCross","description":"Pseudo volumetric lighting technique derived from the fantastic work of Anders Hoff.\nCode is a mess.\nhttps://inconvergent.net/2021/volumetric-light/","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nfloat TIME = 0.0;\nvec2 RUV = vec2(0.0);\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat n1rand( vec2 n )\n{\n    TIME *= 1.01;\n\tfloat t = fract( TIME );\n\tfloat nrnd0 = nrand( RUV + vec2(0.07*t, -0.07*t) );\n\treturn nrnd0;\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat sdPlane(in vec3 p, in vec3 n, in float o) {\n    return dot(p, n)-o;\n}\n\nfloat opU(in float d1, in float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(in float d1, in float d2) {\n    return max(-d1, d2);\n}\n\nfloat map(in vec3 p) {\n    vec3 q = p;\n    float res = sdPlane(q, vec3(0., 1., 0.), -2.);\n\n\n    vec3 size = vec3(1., 2., 0.2);\n    vec3 offset = vec3(0., 0.0, 0.8);\n    res = opU(res, sdBox(q + offset * -2., size));\n    res = opU(res, sdBox(q + offset * -1., size));\n    res = opU(res, sdBox(q + offset * 0. , size));\n    res = opU(res, sdBox(q + offset * 1. , size));\n    res = opU(res, sdBox(q + offset * 2. , size));\n    \n    res = opS(sdBox(q + vec3(0., 0.3, 0.), vec3(0.6, 1.7, 10)), res);\n    \n    return res;\n}\n\nvec3 march(in vec3 ro, in vec3 rd, in float maxD) {\n    float minD=0.;\n    float threshold = 0.0001;\n    \n    float d=minD;\n    for(int i=0;i<32;i++){\n        vec3 pos = ro + rd*d;\n        float tmp = map(pos);\n        if(tmp <threshold || maxD<tmp) break;\n        d += tmp;\n    }\n    \n    if (maxD < d) return vec3(maxD);\n    return ro + rd * clamp(d, 0., maxD);\n}\n\nvec3 calcNormal(in vec3 p) {\n\tvec2 e = vec2(1.0, -1.0)*0.00001;\n    return normalize(vec3(\n    \te.xyy*map(p+e.xyy) +\n    \te.yxy*map(p+e.yxy) +\n    \te.yyx*map(p+e.yyx) +\n    \te.xxx*map(p+e.xxx)\n    ));\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 p = ro;\n    vec3 hit = march(ro, rd, 100.0);\n    float d = distance(hit, p);\n\n    float pix = 0.;\n\n    int n = 8;\n\n    for (int i = 0; i < n; ++i) {\n\n        vec3 smaple = mix(p, hit, n1rand(ro.xy * 0.01));\n        \n        vec3 light = vec3(0., .1, sin(-iTime * 0.5) * 1.7);\n        float maxD = distance(smaple, light);\n\n        if (march(smaple, normalize(light - smaple), maxD).x == maxD) {\n            pix += d / pow(1. + maxD, 2.);\n        }\n\n    }\n    \n    pix *= 1.0 / float(n);\n    \n    return vec3(pix);\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r) {\n    vec3 cw = normalize(tar - eye);// camera w\n    vec3 cp = vec3(0, 1.0, 0.);// camera up\n    vec3 cu = normalize(cross(cw, cp));// camera u\n    vec3 cv = normalize(cross(cu, cw));// camera v\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    TIME = iTime;\n    \n    vec2 p = (fragCoord.xy-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    RUV = p;\n    \n    float ang = 0.6;\n    vec3 ro = vec3(cos(ang), 0.0, sin(ang)) * 10.; // camera pos\n    ro.y = 15.;\n    \n    vec3 tar = vec3(0.); // eye target\n    \n    vec3 rd_orth = normalize(tar - ro);// ray direction via orthographic projection\n    \n    mat3 cam = lookAt(rd_orth, tar, 0.0);\n    vec3 ro_orth = ro + cam * vec3(p * 10., 0.);// ray origin \n\n    // rendering\n    vec3 col = render(ro_orth, rd_orth);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}