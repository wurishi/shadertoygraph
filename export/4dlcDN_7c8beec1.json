{"ver":"0.1","info":{"id":"4dlcDN","date":"1488290324","viewed":461,"name":"Party Box","username":"wyatt","description":"This is my first ShaderToy; ray traced tori and spheres in a mirrored cube.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["reflection","raytracer","torus","sphere","quartic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\t#define REF 1./3.3\n\t#define PI 3.14159265359\n\t\n\tvec3 ref (vec3 a, vec3 n) {\n\t\tn = normalize (n);\n\t\treturn a - 2.*n*dot(n,a);\n\t}\n\tmat3 rot (vec3 s) {\n\t\tfloat \tsa = sin(s.x),\n\t\t\t\tca = cos(s.x),\n\t\t\t\tsb = sin(s.y),\n\t\t\t\tcb = cos(s.y),\n\t\t\t\tsc = sin(s.z),\n\t\t\t\tcc = cos(s.z);\n\t\treturn mat3 (\n\t\t\tvec3(cb*cc, -cb*sc, sb),\n\t\t\tvec3(sa*sb*cc+ca*sc, -sa*sb*sc+ca*cc, -sa*cb),\n\t\t\tvec3(-ca*sb*cc+sa*sc, ca*sb*sc+sa*cc, ca*cb)\n\t\t);\n\t}\n\tvec3 initDir (vec2 v_v, vec3 u_s) {\n\t\tvec2 v =(v_v*2.-1.);\n\t\tmat3 r = rot(u_s);\n\t\tvec3 up = vec3(0.,1.,0.)*r;\n\t\tvec3 ri = vec3(1.,0.,0.)*r;\n\t\tvec3 to = cross(up, ri) * 2.;\n\t\treturn normalize (to+ri*v.x+up*v.y);\n\t}\n\tfloat w;\n\tbool rank (float x) {\n\t\tif (0.001 < x && x < w) {\n\t\t\tw = x;\n\t\t\treturn true;\n\t\t} else return false;\n\t}\n\tmat3 plane (mat3 a, mat3 p, vec3 c, vec3 n, vec3 color) {\n\t\tfloat x = -dot(p[0] - c, n)/dot(p[1], n);\n\t\tvec3 v = p[0]+p[1]*x;\n\t\tif (rank(x)) return mat3 (v, ref(p[1], n), color);\n\t\telse return a; \n\t}\n\tmat3 sphere (mat3 a, mat3 p, vec3 c, float r, vec3 color, bool re) {\n\t\tvec3 q = p[0] - c;\n\t\tfloat B = 2.*dot(p[1], q);\n\t\tfloat C = dot(q,q) - r*r;\n\t\tfloat del = B*B - 4.*C;\n\t\tif (del < 0.) return a;\n\t\tfloat i = (-B-sqrt(del))*0.5;\n\t\tfloat j = (-B+sqrt(del))*0.5;\n\t\tvec3 vi = p[0]+p[1]*i;\n\t\tvec3 vj = p[0]+p[1]*j;\n\t\tvec3 nd;\n\t\tif (re) {\n\t\t\tnd = refract(p[1], normalize(vi - c), 1./REF);\n\t\t} else {\n\t\t\tnd = ref(p[1], normalize(vi - c));\n\t\t}\n\t\tif (rank(i)) return mat3 (vi, nd, color);\n\t\telse if (rank(j)) return mat3 (vj, refract(p[1],-normalize(vj - c), REF), color);\n\t\telse return a;\n\t}\n\tfloat better (float a, float b, bool i) {\n\t\tif (0.001 < b && b < abs(a)) a = b*(i?-1.:1.);\n\t\treturn a;\n\t}\n\tfloat cbrt (float a) {\n\t\treturn sign(a)*exp(log(abs(a))/3.);\n\t}\n\tvec2 cbrti (vec2 v) {\n\t\tfloat a = length(v);\n\t\ta = exp(log(a)/3.);\n\t\tfloat theta = atan(v.y/v.x)/3.;\n\t\treturn a*vec2(cos(theta), sin(theta));\n\t}\n \tfloat cubic (float b, float c, float d) {\n\t\tfloat p = -b/3.;\n\t\tfloat q = p*p*p + b*c/6. - 0.5*d;\n\t\tfloat r = c/3.;\n\t\tfloat s = r-p*p;\n\t\tfloat u = q*q + s*s*s;\n\t\tif (u < 0.) {\n\t\t\tvec2 t = vec2(0., sqrt(-u));\n\t\t\tvec2 Q = vec2(q, 0.);\n\t\t\treturn (cbrti(Q + t) + cbrti(Q - t)).x + p; \n\t\t} else {\n\t\t\tfloat t = sqrt(u);\n\t\t\treturn cbrt(q + t) + cbrt(q - t) + p; \n\t\t}\n\t}\n\tfloat quartic (float b, float c, float d, float e) {\n\t\t//https://en.wikipedia.org/wiki/Quartic_function#Ferrari.27s_solution\n\t\tfloat p = c - 3.*b*b/8.;\n\t\tfloat q = 0.125*b*b*b - 0.5*b*c + d;\n\t\tfloat r = (-3.*b*b*b*b + 256.*e - 64.*b*d + 16.*b*b*c)/256.;\n\t\tfloat m = cubic(p, 0.25*p*p - r, -0.125*q*q);\n\t\tfloat A = -0.25*b;\n\t\tfloat B = 0.5*sqrt(2.*m);\n\t\tfloat C = -2.*p - 2.*m;\n\t\tfloat D = -sqrt(2.)*q/sqrt(m);\n\t\tfloat x = 10.;\n\t\tfloat i = 1.;\n\t\tx = better (x, A + B + 0.5*sqrt(C + D),true);\n\t\tx = better (x, A + B - 0.5*sqrt(C + D),false);\n\t\tx = better (x, A - B + 0.5*sqrt(C - D),true);\n\t\tx = better (x, A - B - 0.5*sqrt(C - D),false);\n\t\treturn x;\n\t}\n\tmat3 torus (mat3 alt, mat3 p, vec3 c, vec3 n, float r1, float r2, vec3 color) {\n\t\tvec3 v = p[0] - c;\n\t\tvec3 d = p[1];\n\t\tfloat vn = dot(v,n);\n\t\tfloat dn = dot(d,n);\n\t\tvec3 g = v - n*vn;\n\t\tvec3 h = d - n*dn;\n\t\tfloat i = r2*r2 - vn*vn;\n\t\tfloat j = -2.*vn*dn;\n\t\tfloat k = -dn*dn;\n\t\tfloat hh = dot(h,h);\n\t\tfloat hg = dot(h,g);\n\t\tfloat gg = dot(g,g);\n\t\tfloat u = -2.*r1;\n\t\tfloat A = (k-hh)/u;\n\t\tfloat B = (j-2.*hg)/u;\n\t\tfloat C = (i-r1*r1-gg)/u;\n\t\tfloat x = quartic (2.*B/A, (2.*A*C + B*B - hh)/(A*A), (2.*C*B-2.*hg)/(A*A), (C*C-gg)/(A*A));\n\t\tfloat sgn = sign(x);\n\t\tx = abs(x);\n\t\tvec3 z = v + d*x;\n\t\tvec3 norm = z - r1*normalize(z-n*dot(z,n));\n\t\tif (rank(x)) return mat3(z + c, (sgn<0.)?refract(d, -norm,1./REF):ref(d, norm), color);\n\t\telse return alt;\n\t}\n\tmat3 bounce (mat3 p, float i, vec3 u_sphere) {\n\t\tw = 10.;\n\t\tmat3 b = mat3(0.);\n\t\tb = torus (b, p, u_sphere, normalize(u_sphere), 0.4, 0.1, vec3(0., 0., 0.1));\n\t\tb = torus (b, p, u_sphere.zxy, normalize(u_sphere.zxy), 0.2, 0.1, vec3(0.8, 0.5, 0.));\n\t\tb = sphere (b, p, u_sphere.xzy, 0.2, vec3(0.5, 0., 0.), false);\n\t\tb = sphere (b, p, vec3(-0.5, 0.75, -0.75), 0.5, vec3(0.,0.5,0.9), false);\n\t\tb = plane (b, p, vec3(1.,0.,0.), vec3(-1.,0.,0.), vec3(0.7));\n\t\tb = plane (b, p, vec3(-1.,0.,0.), vec3(1.,0.,0.), vec3(0.5,0.7,0.5));\n\t\tb = plane (b, p, vec3(0.,1.,0.), vec3(0.,-1.,0.), vec3(0.5));\n\t\tb = plane (b, p, vec3(0.,-1.,0.), vec3(0.,1.,0.), vec3(0.));\n\t\tb = plane (b, p, vec3(0.,0.,1.), vec3(0.,0.,-1.), vec3(0.5, 0.9, 0.5));\n\t\tb = plane (b, p, vec3(0.,0.,-1.), vec3(0.,0.,1.), vec3(1.));\n\n\t\tb[2] = p[2] - 0.4*b[2]*pow(i, -1.1);\n\t\treturn b;\n\t}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\t\tvec3 u_v = 0.7*cos(0.1*vec3(iTime, iTime*2., iTime*3.));\n   \t\tvec2 v_v = fragCoord.xy / iResolution.xx;\n\t\tvec3 u_sphere = 0.7*sin(0.1*vec3(iTime*0.5, iTime*2., iTime*3.));\n\t\tvec3 u_s = vec3(0.1*(iTime));  \n\t    \n\t\tvec3 c = vec3(1.);\n\t\tvec3 v = u_v;\n\t\tvec3 d = initDir(v_v, u_s);\n\t\tmat3 b = mat3(v, d, c);\n\t\tfor (int i = 1; i <= 15; i ++) {\n\t\t\tb = bounce (b, float(i), u_sphere);\n\t\t}\n\t\tfragColor = vec4(b[2], 1.);\n\t}\n\n","name":"Image","description":"","type":"image"}]}