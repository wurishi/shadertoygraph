{"ver":"0.1","info":{"id":"XfccDs","date":"1733146634","viewed":45,"name":"Tanchiki","username":"vovaant","description":"opana\n","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["dz2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Параметры камеры\nvec3 cameraPosition = vec3(0.0, 3.0, -10.0);\nvec3 lookAt = vec3(0.0, 1.5, 0.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\n\n// Позиции танков\nvec3 greenTankPosition = vec3(-7.5, 0.0, 1.0);\nvec3 redTankPosition = vec3(4.0, 0.0, -2.0);\n\n// Функция для земли\nfloat mapSDF(vec3 p) {\n    return p.y; // Земля на уровне y = 0\n}\n\n// Генерация травы\nvec3 generateGrass(vec3 baseColor, vec2 position) {\n    vec2 fixedPos = floor(position * 10.0) / 10.0;\n    float n = fract(sin(dot(fixedPos, vec2(12.9898, 78.233))) * 43758.5453) * 0.3;\n    return baseColor + vec3(0.0, n, 0.0);\n}\n\n// Функция для параллелепипеда\nfloat boxSDF(vec3 p, vec3 a, vec3 b) {\n    vec3 boxSize = abs(b - a) * 0.5;\n    vec3 center = (a + b) * 0.5;\n    vec3 d = abs(p - center) - boxSize;\n    return max(d.x, max(d.y, d.z));\n}\n\n// Функция для цилиндра\nfloat cylinderSDF(vec3 p, vec3 c, float r, float h) {\n    vec2 d = vec2(length(p.xz - c.xz) - r, abs(p.y - c.y) - h * 0.5);\n    return max(d.x, d.y);\n}\n\n// Функция для сферы (снаряд)\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\n// Функция для дула танка\nfloat gunCylinderSDF(vec3 p, vec3 gunBase, vec3 gunEnd, float radius) {\n    vec3 center = (gunBase + gunEnd) * 0.5;\n    vec3 dir = normalize(gunEnd - gunBase);\n    float cylinderLength = length(gunEnd - gunBase);\n    vec3 localP = p - center;\n    vec3 proj = localP - dir * dot(localP, dir);\n    float distToAxis = length(proj);\n    float axialDist = abs(dot(localP, dir)) - cylinderLength * 0.5;\n    return max(distToAxis - radius, axialDist);\n}\n\n// Функция для танка\nfloat tankSDF(vec3 p, vec3 tankPos, float turretAngle, float gunElevation) {\n    vec3 localP = p - tankPos;\n\n    // Корпус\n    float body = boxSDF(localP, vec3(-1.8, 0.0, -0.8), vec3(1.8, 0.6, 0.8));\n\n    // Башня\n    float turret = length(localP.xz) - 0.6;\n    turret = max(turret, abs(localP.y - 0.8) - 0.5);\n\n    // Дуло\n    vec3 gunBase = vec3(0.0, 0.8, 0.0) + vec3(cos(turretAngle), 0.0, sin(turretAngle)) * 0.6;\n    vec3 gunEnd = gunBase + vec3(cos(turretAngle), tan(gunElevation), sin(turretAngle)) * 2.0;\n    float gun = gunCylinderSDF(localP, gunBase, gunEnd, 0.15);\n\n    return min(min(body, turret), gun);\n}\n\n// Трассировка земли\nfloat rayMarchMap(vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + dist * rd;\n        float d = mapSDF(p);\n        if (d < 0.01) return dist;\n        dist += d;\n        if (dist > 30.0) break;\n    }\n    return -1.0;\n}\n\n// Трассировка объектов (танки)\nbool traceTank(vec3 ro, vec3 rd, vec3 tankPos, float turretAngle, float gunElevation, out vec3 hitColor) {\n    float dist = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + dist * rd;\n\n        vec3 localP = p - tankPos;\n\n        // Корпус\n        float body = boxSDF(localP, vec3(-1.8, 0.0, -0.8), vec3(1.8, 0.6, 0.8));\n\n        // Башня\n        float turret = length(localP.xz) - 0.6;\n        turret = max(turret, abs(localP.y - 0.8) - 0.5);\n\n        // Дуло\n        vec3 gunBase = vec3(0.0, 0.8, 0.0) + vec3(cos(turretAngle), 0.0, sin(turretAngle)) * 0.6;\n        vec3 gunEnd = gunBase + vec3(cos(turretAngle), tan(gunElevation), sin(turretAngle)) * 2.0;\n        float gun = gunCylinderSDF(localP, gunBase, gunEnd, 0.15);\n\n        float d = min(min(body, turret), gun);\n        if (d < 0.01) {\n            if (d == body) hitColor = vec3(0.1, 0.4, 0.1); // Цвет корпуса (тёмно-зелёный)\n            else if (d == turret) hitColor = vec3(0.0, 0.5, 0.0); // Цвет башни (зелёный)\n            else if (d == gun) hitColor = vec3(0.0, 0.5, 0.0); // Цвет дула (чёрный)\n            return true;\n        }\n        dist += d;\n        if (dist > 30.0) break;\n    }\n    return false;\n}\n\n\n// Трассировка снаряда\nbool traceProjectile(vec3 ro, vec3 rd, vec3 projectilePos, float radius, out vec3 hitColor) {\n    float t = dot(projectilePos - ro, rd);\n    vec3 closestPoint = ro + t * rd;\n    if (length(closestPoint - projectilePos) < radius) {\n        hitColor = vec3(0.8, 0.1, 0.1); // Тёмно-красный цвет снаряда\n        return true;\n    }\n    return false;\n}\n\n// Главная функция рендеринга\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 forward = normalize(lookAt - cameraPosition);\n    vec3 right = normalize(cross(forward, up));\n    vec3 camUp = cross(right, forward);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * camUp);\n\n    vec3 color = vec3(0.0);\n\n ivec2 texelCoords = ivec2(iResolution.xy * vec2(0.5, 0.5));\nvec4 state = texelFetch(iChannel0, texelCoords, 0);\n\nfloat turretAngle = state.r;\nfloat gunElevation = state.g;\nvec3 projectilePos = vec3(state.b, state.w, state.a); // Чтение x, y, z\n\n    // Рендеринг земли\n    float tMap = rayMarchMap(cameraPosition, rd);\n    if (tMap > 0.0) {\n        vec3 p = cameraPosition + tMap * rd;\n        vec2 grassUV = p.xz;\n        color = generateGrass(vec3(0.3, 0.6, 0.3), grassUV);\n    }\n\n    // Рендеринг зелёного танка\n    vec3 hitColor;\n    if (traceTank(cameraPosition, rd, greenTankPosition, turretAngle, gunElevation, hitColor)) {\n        color = hitColor;\n    }\n\n    // Рендеринг красного танка\n    if (traceTank(cameraPosition, rd, redTankPosition, 0.0, 0.0, hitColor)) {\n        color = vec3(0.8, 0.2, 0.2); // Красный цвет\n    }\n\n        // Рендеринг снаряда\n    if (traceProjectile(cameraPosition, rd, projectilePos, 0.2, hitColor)) {\n        color = hitColor;\n    }\n\n\n    // Небо\n    if (length(color) == 0.0) {\n        color = mix(vec3(0.5, 0.8, 1.0), vec3(0.2, 0.6, 0.9), uv.y + 0.5);\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Коды клавиш\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\nconst int KEY_SPACE = 32;\n\n// Обновление угла поворота башни\nfloat handleTurretRotation(float turretAngle) {\n    float rotationSpeed = 0.05;\n\n    bool leftPressed = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x > 0.5;\n    bool rightPressed = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x > 0.5;\n\n    if (leftPressed) turretAngle -= rotationSpeed;\n    if (rightPressed) turretAngle += rotationSpeed;\n\n    return mod(turretAngle, 6.283185); // Ограничение угла от 0 до 2π\n}\n\n// Обновление угла наклона дула\nfloat handleGunElevation(float gunElevation) {\n    float elevationSpeed = 0.02;\n\n    bool upPressed = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x > 0.5;\n    bool downPressed = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x > 0.5;\n\n    if (upPressed) gunElevation += elevationSpeed;\n    if (downPressed) gunElevation -= elevationSpeed;\n\n    return clamp(gunElevation, -0.5, 0.5); // Ограничение угла наклона\n}\n\n// Управление снарядом\nvec3 handleProjectile(vec3 projectilePos, float turretAngle, float gunElevation, vec3 redTankPos) {\n    bool firePressed = texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x > 0.5;\n\n    // Позиция основания дула (центр танка)\n    vec3 gunBase = vec3(-7.5, 0.8, 1.0);\n\n    // Расчёт направления дула\n    vec3 gunDirection = vec3(\n        cos(turretAngle) * cos(gunElevation), // X-компонента: горизонтальное вращение * наклон\n        sin(gunElevation),                   // Y-компонента: вертикальный наклон\n        sin(turretAngle) * cos(gunElevation) // Z-компонента: горизонтальное вращение * наклон\n    );\n\n    // Нормализация направления дула\n    gunDirection = normalize(gunDirection);\n\n    // Конец дула — точка, где появляется снаряд\n    vec3 gunEnd = gunBase + gunDirection * 2.0;\n\n    // Если нажата клавиша SPACE и снаряд отсутствует на сцене\n    if (firePressed && projectilePos.y < -10.0) {\n        return gunEnd; // Устанавливаем стартовую позицию снаряда\n    }\n\n    // Движение снаряда\n    if (projectilePos.y > -10.0) {\n        float projectileSpeed = 0.5;\n\n        // Снаряд движется вдоль направления дула\n        projectilePos += gunDirection * projectileSpeed;\n\n        // Проверка на столкновение с красным танком\n        if (length(projectilePos - redTankPos) < 2.25) {\n            projectilePos = vec3(-20.0, -20.0, -20.0); // Убираем снаряд\n        }\n\n        // Проверка выхода за границы сцены\n        if (abs(projectilePos.x) > 15.0 || abs(projectilePos.y) > 10.0 || abs(projectilePos.z) > 15.0) {\n            projectilePos = vec3(-20.0, -20.0, -20.0); // Убираем снаряд\n        }\n    }\n\n    return projectilePos;\n}\n\n\n// Главная функция обновления состояния\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Получаем предыдущее состояние\n    vec4 state = texture(iChannel0, uv);\n    float turretAngle = state.r;\n    float gunElevation = state.g;\n    vec3 projectilePos = vec3(state.b, state.a, state.w);\n\n    // Позиция красного танка\n    vec3 redTankPos = vec3(4.0, 0.0, -2.0);\n\n    // Обновляем состояние\n    turretAngle = handleTurretRotation(turretAngle);\n    gunElevation = handleGunElevation(gunElevation);\n    projectilePos = handleProjectile(projectilePos, turretAngle, gunElevation, redTankPos);\n\n    // Сохраняем состояние: turretAngle (R), gunElevation (G), projectilePos.x (B), projectilePos.y (A), projectilePos.z (W)\n    fragColor = vec4(turretAngle, gunElevation, projectilePos.x, projectilePos.y);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}