{"ver":"0.1","info":{"id":"XccyDj","date":"1731130321","viewed":85,"name":"Procedural lightning gone wrong.","username":"Cotterzz","description":"First attempt at this.\nTrying to emulate the way lightning finds the path of least resistance, rather than faking it with curves.\nThough possibly a hybrid might be best.","likes":10,"published":1,"flags":32,"usePreview":1,"tags":["lightning","automata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define black vec3(0.,0.,0.)\n#define white vec3(1.,1.,1.)\n#define px(xx,yy) texelFetch(iChannel0, ivec2(coord.x+xx, coord.y+yy), 0).rgb\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    if(col!=black){col = white;} else {\n        vec2 coord = fragCoord;\n        col = px(1.,0.) + px(1.,1.) + px(0.,1.) + px(-1.,0.) + px(-1.,1.)+ px(-1.,-1.)+ px(0.,-1.)+ px(1.,-1.);\n        col = col/4.;\n        col += (px(2.,0.) + px(2.,2.) + px(0.,2.) + px(-2.,0.) + px(-2.,2.)+ px(-2.,-2.)+ px(0.,-2.)+ px(2.,-2.))/8.;\n    }\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define limit 20\n#define newc vec3(0.5+sin(iTime*7.),0.5+sin(iTime*17.),0.5+sin(iTime*3.))\n#define black vec3(0.,0.,0.)\n#define white vec3(1.,1.,1.)\nvec3 get(in vec2 pix){ return texelFetch(iChannel0, ivec2(pix), 0).rgb;}\nvec3 getn(in vec2 pix){ return texelFetch(iChannel1,(ivec2(pix)+iFrame*ivec2(17,113))&1023, 0).rgb;}\nfloat tot(in vec3 c){ return c.r+c.g+c.b;}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    vec2 uv = coord/iResolution.xy;\n    vec3 col = black;\n    vec2 centre = vec2(0.5, 0.5);\n    vec2 point = centre; //iMouse.xy/iResolution.xy;\n    float adist = distance(centre, point);\n    float pdist = distance(uv, point);\n    float cdist = distance(uv, centre);\n    float tdist = pdist+cdist;\n    float ddist = tdist-adist;\n    if(ddist<=0.0001){ddist=0.0001;}\n\n    ivec2 cursor = ivec2(0, 0);\n    vec3 noise = getn(coord);\n    vec3 old = get(coord);\n    bool vertical = true;\n    if(abs(uv.x-point.x)>abs(uv.y-point.y)){vertical = false;}\n    bool up = true;\n    if(uv.y>point.x){up=false;}\n    bool right = true;\n    if(uv.x>point.x){ right = false;}\n    ivec2 dirA = cursor;\n    ivec2 dirB = cursor;\n    ivec2 dirC = cursor;\n    ivec2 dirD = cursor;\n    if(vertical&&up&&right){\n        dirA = ivec2(0, 1);\n        dirB = ivec2(1, 0);\n        dirC = ivec2(-1, 0);\n        dirD = ivec2(0, -1);\n    } else if (vertical&&right){\n        dirA = ivec2(0, -1);\n        dirB = ivec2(1, 0);\n        dirC = ivec2(-1, 0);\n        dirD = ivec2(0, 1);\n    } else if (vertical&&up){\n        dirA = ivec2(0, 1);\n        dirB = ivec2(-1, 0);\n        dirC = ivec2(1, 0);\n        dirD = ivec2(0, -1);\n    } else if (vertical){\n        dirA = ivec2(0, -1);\n        dirB = ivec2(-1, 0);\n        dirC = ivec2(1, 0);\n        dirD = ivec2(0, 1);\n    } else if(up&&right){\n        dirA = ivec2(1, 0);\n        dirB = ivec2(0, 1);\n        dirC = ivec2(0, -1);\n        dirD = ivec2(-1, 0);\n    } else if (right){\n        dirA = ivec2(1, 0);\n        dirB = ivec2(0, -1);\n        dirC = ivec2(0, 1);\n        dirD = ivec2(-1, 0);\n    } else if (up){\n        dirA = ivec2(-1, 0);\n        dirB = ivec2(0, 1);\n        dirC = ivec2(0, -1);\n        dirD = ivec2(1, 0);\n    } else {\n        dirA = ivec2(-1, 0);\n        dirB = ivec2(0, -1);\n        dirC = ivec2(0, 1);\n        dirD = ivec2(1, 0);\n    }\n    \n    float thresh = 1.51;\n    \n    if(pdist<0.005){ col = newc;\n    } else if(tot(noise)>thresh){\n        for(int i=0;i<limit;i++){\n            if(tot(getn(coord+vec2(cursor)+vec2(dirA)))>thresh){\n                cursor+=dirA; } else if (tot(getn(coord+vec2(cursor)+vec2(dirB)))>thresh){\n                cursor+=dirB; } else if (tot(getn(coord+vec2(cursor)+vec2(dirC)))>thresh){\n                cursor+=dirC; } else if (tot(getn(coord+vec2(cursor)+vec2(dirD)))>thresh){\n                cursor+=dirD; }\n            vec3 newcol = get(coord+vec2(cursor));\n            if(newcol!=black){\n                col = newcol;\n                break;\n            }\n        }\n    }\n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}