{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// pixel bender kernel name: sphereSection\n// languageVersion : 1.0\n// vendor : omino.com\n// version : 2\n// namespace : AIF\n// description : spheresection\n\n    \n// kind : color\n// type : vec3\n// defaultValue : vec3(1,.3,.4)\n// name : xAxisColor\nvec3 xAxisColor = vec3(1,.3,.4);\n\n// kind : color\n// type : vec3\n// defaultValue : vec3(.3, .8,.4)\n// name : yAxisColor\nvec3 yAxisColor = vec3(.3, .8,.4);\n\n// kind : color\n// type : vec3\n// defaultValue : vec3(.1,.3,1)\n// name : zAxisColor\nvec3 zAxisColor = vec3(.1,.3,1);\n\n// kind : color\n// type : vec3\n// defaultValue : vec3(.1,.3,1)\n// name : edgeColor\nvec3 edgeColor = vec3(.1,.3,1);\n\n// defaultValue : .1\n// type : float\n// maxValue : 1.0\n// name : edgeThickness\n// minValue : 0.0\nfloat edgeThickness = .1;\n\n// kind : checkbox\n// type : float\n// defaultValue : 0.0\n// name : invert\nfloat invert = 0.0;\n\n// kind : dstsize\n// name : dstsize\n// defaultValue : vec2(300,300)\n// maxValue : vec2(800,800)\n// minValue : vec2(0,0)\n// type : vec2\nvec2 dstsize = vec2(300,300);\n\n// defaultValue : vec3(.1,.02,.3)\n// type : vec3\n// maxValue : vec3(10,10,10)\n// name : spin\n// minValue : vec3(-10,-10,-10)\nvec3 spin = vec3(.1,.02,.3);\n\n// defaultValue : 0.0\n// type : float\n// maxValue : 20.0\n// name : plunge\n// minValue : 0.0\nfloat plunge = 0.0;\n\n// defaultValue : 3.0\n// type : float\n// maxValue : 50.0\n// name : cellDensity\n// minValue : 1.0\nfloat cellDensity = 3.0;\n\n// defaultValue : 0.8\n// type : float\n// maxValue : 2.0\n// name : radius\n// minValue : 0.25\nfloat radius = 0.8;\n// only to establish the input size\n    \n\n    // main(): The function of the filter that actually does the \n    //                  processing of the image.  This function is called once \n    //                  for each pixel of the output image.\n    \nfloat sinRangeF(float low, float high, float rate)\n{\n  float amt = (high - low) / 2.0;\n  float mid = (high + low) / 2.0;\n  return mid + amt * sin(iTime * rate);\n}\nint sinRangeI(int low, int high, float rate)\n{\n  float amt = 0.5 + float(high - low) / 2.0;\n  float mid = float(high + low) / 2.0;\n  return int(mid + amt * sin(iTime * rate));\n}\nvoid animateParameters()\n{\n  plunge = sinRangeF(0.1,20.0,0.200000);\n  cellDensity = sinRangeF(1.0,100.0,0.111675);\n  invert = sinRangeF(-1.0,1.0,0.224032);\n  radius = sinRangeF(0.25,5.0,0.237110);\n  edgeThickness = sinRangeF(0.2,0.3,0.250952);\n\t\n  edgeColor.r = sinRangeF(0.1,0.8,.2381);\n  edgeColor.g = sinRangeF(0.1,0.8,.2301);\n  edgeColor.b = sinRangeF(0.1,0.8,.2488);\n\n  zAxisColor.r = sinRangeF(0.0,1.0,.381);\n  zAxisColor.g = sinRangeF(0.0,1.0,.301);\n  zAxisColor.b = sinRangeF(0.0,1.0,.488);\n  yAxisColor.r = sinRangeF(0.0,1.0,.881);\n  yAxisColor.g = sinRangeF(0.0,1.0,.701);\n  yAxisColor.b = sinRangeF(0.0,1.0,.681);\n  xAxisColor.r = sinRangeF(0.0,1.0,.1881);\n  xAxisColor.g = sinRangeF(0.0,1.0,.1701);\n  xAxisColor.b = sinRangeF(0.0,1.0,.1681);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\nanimateParameters();\n        vec3 axis1 = vec3(1.0,0.0,0.0);\n        vec3 axis2 = vec3(0.0,1.0,0.0);\n\n        mat3 elevR = mat3(1,0,0,0,cos(spin.x),sin(spin.x),0,-sin(spin.x),cos(spin.x));\n        mat3 bearR = mat3(cos(spin.y), sin(spin.y), 0,-sin(spin.y), cos(spin.y), 0, 0, 0, 1 );\n        mat3 yamR = mat3(cos(spin.z),0,sin(spin.z),0,1,0,-sin(spin.z),0,cos(spin.z));\n        \n        axis1 *= elevR * bearR * yamR;\n        axis2 *= elevR * bearR * yamR;\n        \n        float cellDensity2 = cellDensity / 2000.0;\n        vec2 oc = (fragCoord.xy - dstsize / 2.0) * cellDensity2;\n        \n        //oc -= outSize/2.0;\n        vec3 p = oc.x * axis1 + oc.y * axis2;\n        \n        \n        vec3 perp = cross(axis1,axis2);\n        \n        float radiusInPixels = radius *  dstsize.x;\n        float plungeMore = radiusInPixels * radiusInPixels * cellDensity2 * cellDensity2 - oc.x * oc.x - oc.y * oc.y;\n        if(plungeMore < 0.0)\n            plungeMore = 0.0;\n        plungeMore = sqrt(plungeMore);\n        \n        // Strangely, PBT and Flash have opposite senses here.\n        // Some sort of arithmetic bug, probably, making them\n        // behave differently.\n        if(invert > 0.0)\n            plungeMore = -plungeMore;\n        \n        p += (plunge - plungeMore) * perp;\n        \n\n        vec3 pCell = floor(p);\n        \n        \n        p = mod(p,1.0);\n        \n        /*\n        Our cell size, here, is 1x1x1. Perp is a unit vector representing\n        the direction we're now looking, the ray cast if you will. We like\n        to cast to the planes x=0, y=0, z=0, because it's easy. So first\n        we'll see if each element of perp is negative, and, if so, flip\n        it and reposition our starting point, like p.x := 1-p.x.\n        */\n\n        /* this is the cleanest way, but Flash doesn't allow bools,\n           and ?: doesn't seem to work in this mixed-dimension way\n           either\n\n        bool3 perpNeg = lessThan(perp,vec3(0,0,0));\n        p = perpNeg ? 1.0 - p : p;\n        perp = abs(perp);\n        */\n        \n        /* We can be clever with step and abs, though. */\n        vec3 perpStep = 1.0 - step(0.0,perp);\n        p = perpStep - p;\n        p = abs(p);\n        perp = abs(perp);\n        \n        \n        vec3 t = p / perp; // casts from p, in direction of perp, to zero. T is how far to each plane (x,y, or z)\n        vec3 co = vec3(0,0,0);\n        float z;\n        \n        if(t.x >= 0.0)\n        {\n            co = xAxisColor;\n            z = t.x;\n        }\n        if(t.y >= 0.0 && t.y < t.x)\n        {\n            co = yAxisColor;\n            z = t.y;\n        }\n        if(t.z >= 0.0 && t.z < t.x && t.z < t.y)\n        {\n            co = zAxisColor;\n            z = t.z;\n        }\n        \n        fragColor.rgb = co * (1.0 - z/1.2);\n        fragColor.a = 1.0;\n        \n        if(t.x < edgeThickness || t.y < edgeThickness || t.z < edgeThickness)\n            fragColor.rgb = edgeColor;\n        \n        if(plungeMore == 0.0)\n            fragColor.xyz *= 0.0;\n    }\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsfGDf","date":"1380594693","viewed":203,"name":"omino_cubes","username":"polycube","description":"Adapted from an After Effects Pixel Bender shader.\nHilariously lightweight, we get a sort of faux-ambient occlusion shading effect by darkening according to depth into the cube.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3dpixelbender"],"hasliked":0,"parentid":"","parentname":""}}