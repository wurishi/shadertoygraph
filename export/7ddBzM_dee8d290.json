{"ver":"0.1","info":{"id":"7ddBzM","date":"1656269593","viewed":160,"name":"Vintage bitwise XOR fractal ","username":"ronwnor","description":"A neat pattern I found in the desmos discord server and decided to recreate.\ndesmos is a bit limited with gradients, so I wanted to see what can shadertoy do with it.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265359;\nconst float max_iteration = 20.;\n\n//disclaimer: it doesn't really do bitwise XORing - I just found a way to mimic the pattern.\n//idea imported from desmos: check out my graph here! https://www.desmos.com/calculator/zy7ngl1da4\n\n//sin(πx)sin(πy)<0 creates a grid with square length 1.\n//similarly, sin(2πx)sin(2πy)<0 generates a grid with length 1/2, and so on.\n//essentially it's a boolean value. we can assign the points who satifsy the statement 1, and the rest - 0.\n//we keep dividing the board into smaller grids, each time adding the points values based on the grid check.\n//to make sure we can only have one combination of statements which will give us a specific value,\n//we multiply each layer by a power of 2.\n//actually, we need the values to be between 1 and 0! (not 0! == 1, 0. ugh, you get it.)\n//so instead of dividing the final product by 2**(max_iteration),\n//we can just divide by powers of 2 from the beginning. that way the values are kept between 0 and 0+1+1/2+1/4...=2.\n//2? divide it by 2 (or just add a +1 there, that will do it).\n//finally, we have our map with values between 1 and 0, which we will then pass through a colormap.\n\nfloat f(vec2 z){\n    z *= pi;\n    float sum = 0.;\n    \n   for(float i = 0.; i < max_iteration; i++){\n    sum += smoothstep(.45,.55, .5 + .5*sin(z.x)*sin(z.y))/pow(2.,i + 1.);\n    z *= 2.;\n    }\n\n    return(sum);\n}\n\n//cosine gradient from iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d){\n    return a + b*cos(2.*pi*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 col = palette(\n           f(uv)    ,\n    vec3(    .5    ),\n    vec3(    .5    ),\n    vec3(1., 1., .5),\n    vec3(.8, .9 ,.3)\n    );\n    \n    //this makes the black background\n    col -= step(1.,max(abs(uv.x),abs(uv.y)));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}