{"ver":"0.1","info":{"id":"3sXcz7","date":"1590709560","viewed":178,"name":"Maze Noisy","username":"spalmer","description":"a noisy randomly generated maze, trying different styles; may make caves or some kind of 2D game out of it at some point","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["noise","turbulence","maze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// just stb's maze display (see Buffer A for generation) \n// from https://shadertoy.com/view/XdKGWK\n// but with fbm turbulence on lookup coordinate\n\n#define BufferA    iChannel0\n//#define BufferARes iChannelResolution[0].xy\n#define Noise      iChannel3\n\n// could also try inverting the maze and having the round caps be inverted/elsewhere\n// or have there be little rooms randomly at the gridpoints, or something.\n\n// can easily invert the maze by negating resulting wall distance\n// but then would want to change the endcap shapes and corridor widths\n\n// TODO try splines / perlin worms, etc connecting cells\n\nfloat fbm(vec2 q)\n{\n    // TODO store random seed in BufferA somewhere\n    //q += floor(iDate.w / 4.); //iTime / 128.; //\n\tconst mat2x2 M = mat2x2(.866,-.5,.5,.866);\n    return (8. * texture(Noise, q     ).x\n          + 4. * texture(Noise, q*2.*M).x\n          + 2. * texture(Noise, q*-3. ).x\n          + 1. * texture(Noise, M*q*5.).x\n        ) / (8.+4.+2.+1.);\n}\n\n//const vec2 rescale = vec2(MazeSmall) / vec2(MazeSize);\n\n#if 1\n// maze renderer with turbulence\n\n// turbulence on q coordinate, for the most part does not block off the corridors\n\nfloat maze_stb_nz(vec2 q)\n{\n    float seed = T(BufferA, ivec2(0)).z; // + iDate.z; //\n    vec2 q1 = q * .01 + seed; // * .25;  * float(MazeSmall.y) / R.y;\n    vec2 q2 = .5 - q1.yx;\n    vec2 mn = (vec2(\n          fbm(q1)\n    \t, fbm(q2)\n        ) * 2. - 1.) * 1.25;\n    //float dorig = dWall4(q * rescale, BufferA);\n    q += mn;\n    vec2 p = q; // * rescale;\n    float d = dWall4(p, BufferA);\n//    d += pow(texture(Noise, q1 * 1.5).x, 16.) * 4.95; // 'rooms' but made of noise and haphazardly placed\n//    d -= .7; // thicken uniformly\n//    return .5 + .5 * cos(6.*2.*3.14159 * max(0.,d)); //min(0., d)); //\n    float drescale = R.y/64.;\n    // trying to unblur the blurry areas where the distance doesn't change as rapidly as it should\n    float daa = 4./(1.0+2.*fwidth(d)); // idk, might be inverted, can't dial it in so it's probably wrong, but seems to help a little\n    return clamp(.5 - daa * drescale * d, 0., 1.);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    float f = clamp(maze_stb_nz(p * vec2(MazeSmall) / R), 0., 1.);\n    c = vec4(vec3(pow(f, 1./2.2)), 1);\n}\n\n#elif 0\n//  maze renderer with fbm noise - just blocks hallways, doesn't work well\n\n// futzing with distances directly is interesting but\n// not quite as controllable as I'd like, a bit funky\n// if you're not careful, it's easy to chew holes in the walls\n// or block the corridors completely.\n\nfloat maze_stb_nz(vec2 q)\n{\n    vec2 p = q * rescale;\n    float d = dWall4(p, BufferA);\n    float mnz = (fbm(q * .01)) - .5; //  * float(MazeSmall.y) / R.y) /* * 2. - 1.*/) * .1; //2.;\n    // trying to fade out noise far away from base wall,\n    // without preventing large noise offsets, not working well yet\n    //d = mix(d - .0, d - mnz, exp2(-0.05*max(0., d))); //\n    d -= mnz; //\n    //return .5 + .5 * cos(6.*2.*3.14159*min(0., d)); //max(0.,d)); //\n    return clamp(.5 - R.y/64.*d, 0., 1.);\n    //return 1. - step(.0, d); // raw maze walls without antialiasing\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    float f = clamp(maze_stb_nz(p * vec2(MazeSize) / R), 0., 1.);\n    c = vec4(vec3(pow(f, 1./2.2)), 1);\n}\n\n#elif 1\n// pretty much same thing, no noise\n\nfloat maze_stb_io(vec2 q)\n{\n    vec2 fMazeSize = vec2(MazeSmall);\n    vec2 p = q * fMazeSize / R; //vec2(MazeSize); // account for mazespacing\n    float d = dWall4(p, BufferA);\n    d = step(.0, d);\n    /* // entrance&exit\n    if (d == 1.) {\n    \tif (all(lessThan(p, vec2(1.5,.7))))\n            return 2.;\n    \tif (all(lessThan(vec2(MazeSmall) - vec2(1.5,.7), p)))\n            return 3.;\n    }\n\t*/\n    return 1.-d;\n}\n\nvoid mainImage(out vec4 c, vec2 q)\n{\n    float wall = maze_stb_io(q);\n    c = vec4(vec3(wall), 1.);\n}\n\n#endif\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define T(ch, _) texelFetch(ch, ivec2(_), 0) //.xy\n\nconst ivec2 MazeSmall = ivec2(16, 9) * 1;\n\nvec2 rotateTo(vec2 p, vec2 a) \n{\n    float s = a.x, c = a.y;\n    return mat2(c,s,-s,c) * p;\n}\n\n// original maze by stb from https://shadertoy.com/view/XdKGWK\nconst float WThk = .7; // wall thickness\n\n// returns signed distance\nfloat dWall(vec2 p, vec2 dir) \n{\n    p = fract(rotateTo(p, dir)) - .5;\n    \n    // square ends\n    //return 2. * max(-p.y, abs(p.x)) - WThk;\n    \n    // round ends\n    p.y = max(0., -p.y);\n    return 2. * length(p) - WThk;\n}\n\n// converted to function, was in mainImage / maze_stb\nfloat dWall4(vec2 p, sampler2D ch)\n{\n    // hide the mess outside the maze\n    p = clamp(p, vec2(.5), vec2(MazeSmall)-.5);\n    // initial wall 'distance'\n    float d = dWall(p, T(ch, p).xy);\n    const vec3 o = vec3(1, -1, 0); // save chars    \n    const vec2 D[4] = vec2[] (o.xz, o.yz, o.zx, o.zy);\n    // kern neighbors to fill in wall gaps\n    for (int i = 0; i < D.length(); ++i) {\n        vec2 w = D[i], t = T(ch, p-w).xy;\n        if (w == t) //all(equal(w, t)))\n            d = min(d, dWall(p, -t));\n    }\n    return d;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// based on stb's basic maze generator https://shadertoy.com/view/XdKGWK\n\n// only the xy components mean anything;\n// it's the direction to the neighbor wall,\n// or zero if maze still being built.\n// oh and seed is stored in z of pixel 0,0\n\n#define BufferA    iChannel0\n//#define BufferARes iChannelResolution[0].xy\n#define Keyboard   iChannel2\n\n// hash without sine - https://shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 v = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));\n    v += dot(v, v.yzx + 19.19);\n    return fract((v.x + v.y) * v.z);\n}\n\n// cardinal direction based on q direction index\nvec2 qspin(int q)\n{\n    float a = (q & 2) != 0 ? 1. : -1.;\n    return (q & 1) != 0 ? vec2(0,a) : vec2(a,0);\n}\n\nfloat seed;\n\n// create maze walls incrementally\nvec2 mazeWallDir(ivec2 i)\n{\n    vec2 d = T(BufferA, i).xy; // cell's stored wall direction, if any        \n    if (dot(d, d) < 1e-2) { // is this cell empty?\n\t\tint a = int(floor(4. * hash12(vec2(i) + seed))); // a random integer\n        vec2 r = qspin(a); // choose cardinal direction\n        if (T(BufferA, i+ivec2(r)).xy != vec2(0)) // if wall exists in direction r,\n            d = r; // become a new wall connecting that direction\n    }\n    return d;\n}\n\n// init wall boundaries\nvec2 mazeWallDirInit(ivec2 i, ivec2 s)\n{\n    const vec3 o = vec3(1, -1, 0); // save a few chars\n    vec2 d;\n    if (i.y == 0)\n        d = o.xz;\n    else if (i.y == s.y-1)\n        d = o.yz;\n    if (i.x == 0)\n        d = o.zx;\n    else if(i.x == s.x-1)\n        d = o.zy;\n    return d;\n}\n\n// output to Buffer A\nvoid mainImage(out vec4 c, vec2 p)\n{\n \tseed = mod(iDate.w, 128.);\n    ivec2 i = ivec2(p);\n    bool init = iFrame < 3 //iFrame == 0 // thumbnail issues\n        || T(Keyboard, ivec2(32, 1)).x > .5;\n    vec2 d = init\n      ? mazeWallDirInit(i, MazeSmall)\n      : mazeWallDir(i);\n    c = vec4(d,0,0); // store wall direction\n\t// must store stable yet random seed value \n\t// because, though not required for\n\t// maze generation, it would be super useful\n\t// to have a stable yet \"random\" number\n\t// such as iDate.w stored somewhere so\n\t// Image tab could use it for the turbulence!\n    // so just record\n    if (i == ivec2(0))\n        if (init) c.z = seed;\n    \telse c.z = T(BufferA, ivec2(0)).z; // copy from old buffer\n}\n\n\n    // store maze size (old, for window resizing/fullscreen)\n//    if (fg == ivec2(0,1))\n//       c.zw = vec2(MazeSize);\n\n","name":"Buffer A","description":"","type":"buffer"}]}