{"ver":"0.1","info":{"id":"lXlfzn","date":"1728213992","viewed":48,"name":"Non-Linear Sphere Tracing","username":"w450468524","description":"Test non-linear sphere tracing algorithm\nhttps://cs.dartmouth.edu/~wjarosz/publications/seyb19nonlinear.html\n\nMove mouse to change ray start.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spheretracing","nonlinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float EPSILON = 0.0001;\nconst vec3 SPHERE = vec3(1.0, 0.5, 0.2);\n\n#define PI 3.1415926535897\n#define MARCH_COUNT 500\n#define NLST\n\nfloat SDFSphere(vec2 pos, vec3 sphereDesc)\n{\n    return length(pos - sphereDesc.xy) - sphereDesc.z;\n}\n\nfloat SDFLine(vec2 p,vec2 p1,vec2 p2,float r){\n  vec2 a1 = p - p1; vec2 a2 = p2 - p1;\n  // the project point on line segment clamped to 0~1\n  float h = clamp(dot(a1,a2)/dot(a2,a2),0.0,1.0);\n  // line segment start from p, the end point is lerp between p1 and p2\n  return length(a1 - a2*h) - r;\n}\n\nfloat CalcDeformValue(vec2 dir)\n{\n    float val = dir.y;\n    float integer;\n    float progress = modf(iTime * 0.5, integer);\n    return mix(abs(val), 1.0, sin(progress * PI));\n}\n\nfloat SDFSphereDeformed(vec2 pos, vec3 sphereDesc)\n{\n    vec2 dir = pos - sphereDesc.xy;\n    float len = length(dir);\n    dir = normalize(dir);\n    \n    \n    return len - sphereDesc.z * CalcDeformValue(dir);\n}\n\n\nvec2 DeformedPosition(vec2 pos, vec3 sphereDesc)\n{\n    vec2 dir = pos - sphereDesc.xy;\n    float len = length(dir);\n    dir = normalize(dir);\n    \n    float deformValue = CalcDeformValue(dir);\n    \n    return sphereDesc.xy + dir * (len -sphereDesc.z + sphereDesc.z * deformValue);\n}\n\nmat2 estimateJacobian(vec2 pos)\n{\n    vec2 diff_x = vec2(EPSILON, 0);\n    vec2 diff_y = vec2(0, EPSILON);\n\n    vec2 grad_x = (DeformedPosition(pos + diff_x, SPHERE) - DeformedPosition(pos - diff_x, SPHERE)) / (2.0 * EPSILON);\n    vec2 grad_y = (DeformedPosition(pos + diff_y, SPHERE) - DeformedPosition(pos - diff_y, SPHERE)) / (2.0 * EPSILON);\n\n    return mat2(grad_x, grad_y);\n}\n\nfloat scene(vec2 pos)\n{\n    #ifdef NLST\n    return SDFSphereDeformed(pos, SPHERE);\n    #else\n    return SDFSphere(pos, SPHERE);\n    #endif\n}\n\n#define S(v) smoothstep( 1.5/iResolution.y, 0.,v )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // draw SDF and background\n    vec3 col = mix(vec3(0.0), vec3(1.0, 0.0, 0.0), S(abs(scene(uv))));\n    col += sin(200.0*scene(uv))*0.2;\n    \n    vec2 rayDir = normalize(vec2(sin(iTime * 0.5), cos(iTime * 0.5)));\n\n    vec2 lastPos = vec2(iMouse / iResolution.y);\n    vec2 rayPos = lastPos;\n    \n    for (int i = 0; i < MARCH_COUNT; ++i)\n    {\n        #ifdef NLST\n        float dist = SDFSphere(rayPos, SPHERE);\n        #else\n        float dist = scene(rayPos);\n        #endif\n        if (dist <= EPSILON || any(greaterThan(rayPos,vec2(aspect))) || any(lessThan(rayPos, vec2(0.0))))\n        {\n            break;\n        }\n        \n        // draw tracing spheres\n        col = mix(col, vec3(0.0, 1.0, 0.0), S(abs(SDFSphere(uv, vec3(rayPos, dist)))));\n        // draw sphere centers\n        col = mix(col, vec3(0.0, 1.0, 1.0), S(clamp(SDFSphere(uv, vec3(rayPos, 0.008)), 0.0, 1.0)));\n        // draw ray\n        col = mix(col, vec3(1.0, 1.0, 1.0), S(abs(SDFLine(uv, lastPos, rayPos, 0.0))));\n        lastPos = rayPos;\n        #ifdef NLST\n        mat2 inv_jacobian = inverse(estimateJacobian(rayPos));\n        float s_undeformed = abs(dist);\n\n        vec2 w_undeformed = normalize(inv_jacobian * rayDir);\n        rayPos = rayPos + s_undeformed * w_undeformed * 0.2;\n        \n        #else\n        rayPos += rayDir * dist;\n        #endif\n    }\n    \n    // undeformed sphere\n    col = mix(col, vec3(1.0, 1.0, 0.0), S(abs(SDFSphere(uv, SPHERE))));\n    \n    // visualize deform point\n    vec2 deformed = DeformedPosition(vec2(0.5, 0.5), SPHERE);\n    col = mix(col, vec3(1.0, 0.0, 1.0), S(clamp(SDFSphere(uv, vec3(deformed, 0.008)), 0.0, 1.0)));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}