{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define THRESHOLD 0.03\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 200\n#define MAX_SAMPLES (max(4.0, 8.0*maxDiffuseSum))\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat scene(vec3 p)\n{\n\tfloat cube = length(max(abs(p) - vec3(0.95), 0.0)) - 0.05;\n\tfloat s1 = length(p+vec3(-1.0, -0.5, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(1.15, 1.15, 1.15)) - 0.75;\n\tfloat s3 = length(max(abs(p+vec3(-2.5, 0.0, 0.2)) - vec3(0.05, 2.95, 2.25), 0.0));\n\tfloat s4 = length(max(abs(p+vec3(0.0, 0.0, 2.5)) - vec3(2.5, 2.95, 0.05), 0.0));\n\ts4 = min(s4, length(max(abs(p+vec3(-2.0, 2.0, 0.5)) - vec3(1.75, 0.05, 1.05), 0.0)));\n\treturn min( min( min( min(cube, s1), s2 ), s3 ), s4);\n}\n\nmat material(vec3 p)\n{\n\t//float cube = length(max(abs(p) - vec3(0.95), 0.0)) - 0.05;\n\tfloat s1 = length(p+vec3(-1.0, -0.5, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(1.15, 1.15, 1.15)) - 0.75;\n\tfloat s5 = length(max(abs(p+vec3(-1.0, 1.5, 1.2)) - vec3(1.0, 0.05, 1.65), 0.0));\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\n\tm.diffuse = 0.0;\n/*\tif (cube < s1 && cube < s2 && cube < s5) {\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.6;\n\t} else */\n\t\tif (s1 < s2 && s1 < s5) {\n\t\tm.transmit = vec3(0.9, 0.9, 0.9);\n\t\tm.diffuse = 0.15;\n\t} else if (s2 < s5) {\n\t\tm.transmit = vec3(0.1);\n\t\tm.diffuse = 0.8;\n\t} else {\n\t\tm.transmit = vec3(0.1, 0.9, 0.5);\n\t\tm.diffuse = 0.8;\n\t\tm.emit = vec3(0.2);\n\t}\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml)\n{\n    vec3 lightPos_ = vec3(\n        -cos(iTime)*-8.5, \n        sin(iTime)*3.0 - 4.0, \n        -(sin(iTime)*4.0)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\n\tvec3 bgCol = vec3(0.2, 0.15, 0.1);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);\n\tbgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), 2.0);\n\tbgCol += bgDiff*vec3(0.25, 0.5, 0.5);\n\tbgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*256.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*128.0);\n\treturn max(vec3(0.0), bgCol);\n}\n\nfloat shade(inout ray r, vec3 nml, float d)\n{\n\tmat m = material(r.p);\n\tr.light += m.emit * r.transmit;\n\tr.transmit *= m.transmit;\n\treturn m.diffuse;\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\nvoid offset(inout vec3 nml, float k, float count, float diffuse) {\n\tvec3  uu  = normalize( cross( nml, vec3(0.01,1.0,1.0) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n\tvec2  aa = hash2( count );\n\tfloat ra = sqrt(aa.y);\n\tfloat rx = ra*cos(6.2831*aa.x); \n\tfloat ry = ra*sin(6.2831*aa.x);\n\tfloat rz = sqrt( sqrt(k)*(1.0-aa.y) );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n\tnml = normalize(mix(nml, rr, diffuse));\n}\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nray setupRay(vec2 uv, float k) {\n\tmat3 rot = rotationXY( vec2( iTime*0.503, iTime*0.602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n\tr.p = rot * vec3(uv*-1.0, -7.0);\n\tr.d = rot * normalize(vec3(uv, 1.0));\n\n\treturn r;\n}\n\nvec3 trace(vec2 uv, vec2 uvD)\n{\t\n\tfloat minDist = 9999999.0;\n\tfloat count = 0.0;\n\tfloat diffuseSum = 0.0, maxDiffuseSum = 0.0;\n\t\n\tvec3 accum = vec3(0.0);\n\n\tray r = setupRay(uv, 1.0);\n\tfloat k = 1.0;\n\t\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\n    for (int i=0; i<RAY_STEPS; i++) {\n\t\tif (k > MAX_SAMPLES) break;\n\t\tfloat dist = scene(r.p);\n\t\tminDist = min(minDist, dist);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n\t\t\tfloat diffuse = shade(r, nml, dist);\n\t\t\tdiffuseSum += diffuse;\n\t\t\toffset(r.d, k, k+10.0*dot(nml, r.d), diffuse*0.5);\n\t\t\tr.d = reflect(r.d, nml);\n\t\t\tr.p += 4.0*THRESHOLD * r.d;\n\t\t\tcount++;\n\t\t\t\n\t\t\tif (dot(r.transmit, sun) < 1.0) {\n\t\t\t\t// if even the brightest light in the scene can't\n\t\t\t\t// make the ray brighter, let's bail.\n\t\t\t\taccum += r.light;\n\t\t\t\tk++;\n\t\t\t\tr = setupRay(uv+(uvD*mod(xy(k, 4.0), 4.0)/4.0), k);\n\t\t\t\tmaxDiffuseSum = max(diffuseSum, maxDiffuseSum);\n\t\t\t\tdiffuseSum = 0.0;\n\t\t\t}\t\t\t\n\t\t} else if (dist > MAX_DISTANCE) {\n\t\t\tvec3 bg = shadeBg(-r.d);\n\t\t\tif (minDist > THRESHOLD*1.5) {\n\t\t\t\tr.light = bg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taccum += r.light + r.transmit * bg;\n\t\t\tk++;\n\t\t\tr = setupRay(uv+(uvD*mod(xy(k, 4.0), 4.0)/4.0), k);\t\t\t\n\t\t\tmaxDiffuseSum = max(diffuseSum, maxDiffuseSum);\n\t\t\tdiffuseSum = 0.0;\n\t\t}\n\t}\n\t\n\taccum += r.light;\n\treturn accum / k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (2.0 * uv - 1.0) * aspect;\n\n\tvec2 uvD = ((2.0 * ((fragCoord.xy+vec2(1.0, 1.0)) / iResolution.xy) - 1.0) * aspect) - uv;\n\t\n\tvec3 light = trace(uv, uvD);\n\t\n\tfragColor = vec4( 1.0 - exp(-1.3 * light), 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sBGzt","date":"1392030490","viewed":1319,"name":"Emissive material","username":"kig","description":"Naive path tracing in a simple raymarched distance field.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","pathtracing"],"hasliked":0,"parentid":"","parentname":""}}