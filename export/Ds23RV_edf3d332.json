{"ver":"0.1","info":{"id":"Ds23RV","date":"1667911589","viewed":122,"name":"Transformation Plotter","username":"Envy24","description":"See Image tab header.","likes":5,"published":1,"flags":16,"usePreview":0,"tags":["linear","matrix","plotter","homogeneous","affine","nonlinear","trasformation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    For linear or affine matrix transforms, undefine NON_MATRIX token, redefine composed matrix,\n    \n    for non-linear, non-affine or just non-matrix (mean you don't know matrix form)\n    define NON_MATRIX token, and redefine:\n        non_matrix_inverse_transform\n        non_matrix_transform\n        \n    Controls:\n        Drag point with mouse:\n            purple - before transformation,\n            black - after transformation.\n        Key T - toggle texture.\n      \n    Other implementations:\n        https://www.shadertoy.com/view/mssSWM  \n    \n    Some links:\n        https://en.wikipedia.org/wiki/Transformation_matrix \n*/\n\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define SCENE_SCALE               ( 5. )\n#define UNIT                      ( 3.0*SCENE_SCALE / R.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define ORIGIN                    ( vec2(0) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\n//#define NON_MATRIX // non-linear, non-affine\nvec2 non_matrix_inverse_transform(vec2 P)\n{\n    float t = 0.5+0.5*sin(iTime*0.5); // for mixing transforms.\n    //vec2 T = CartesianToPolar(P); t = 0.;\n    //vec2 T = CirclesSquares(P); t = 0.75;\n    //vec2 T = archimedeanSpirals(P); t = 0.;\n    //vec2 T = circleInverse(0.25*P); t = 0.;\n    vec2 T = mobiusTransform(0.25*P);// t = 0.;\n    \n    return mix(T, P, t);\n}\nvec2 non_matrix_transform(vec2 P)\n{\n    float t = 0.5+0.5*sin(iTime*0.5); // for mixing transforms.\n    //vec2 T = PolarToCartesian(P); t = 0.;\n    vec2 T = unknownTransform(P); t = 0.;\n    \n    return mix(T, P, t);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false);\n\n\n    /* Reminder: if you want to apply transforms in order A,B,C,\n       then use T = [ABC], P = T*P. */\n    \n    /* Control transform (applied in order: translate, rotate, scale). \n       Applied to point vec2(0, 0) produses vec2(0, 2) (only if variant 1 is off).  */\n    //mat3 composed = scale(vec2(2)) * rotz(90. * TO_RAD) * translate(vec2(1,0));\n    /* Control transform (applied in order: scale, rotate, translate). \n       Applied to point vec2(1, 0) produses vec2(1, 2) (only if variant 1 is off).  */\n    //mat3 composed = translate(vec2(1,0)) * rotz(90. * TO_RAD) * scale(vec2(2)); // row order\n    \n    //mat3 composed = shear(vec2(0, sin(iTime)))*shear(vec2(cos(iTime), 0));\n    //mat3 composed = scale(vec2(1, 1.)) * rotz(NDC.x*NDC.y * TO_RAD) * translate(vec2(1,0));\n    mat3 composed = rotz(5.*sin(PI*iTime) * NDC.x * TO_RAD)*translate(vec2(sin(NDC.y), 0))*shear(vec2(sin(iTime),0))*shear(vec2(0,cos(iTime)));\n    //mat3 composed = scale(vec2(2./NDC.y, 2./NDC.x))*translate(vec2(0,0));\n    //mat3 composed = rotz(5.*sin(PI) * NDC.x * TO_RAD)*translate(vec2(sin(NDC.y), 0));\n    \n    /*\n        Applying transform.\n    */\n    vec3 P; vec2 ndc = NDC, M = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false); \n    /* Variant 1 (inverse): if you want to apply transform to system (more informative). \n       For control transform:\n           Translates arrows by 1 to right,\n           Rotates arrows around Z axis by 90 degrees counter clockwise,\n           Scales arrow by 2 (so they grow bigger).\n       Cells and arrows distort by transform.\n    */\n#ifndef NON_MATRIX\n    P = vec3(ndc.xy, 1);            // convert to homogeneous coordinates.\n    P = inverse(composed) * P;\n    ndc = P.xy;                     // convert from homogeneous coordinates if h == 1 (see variant 2).\n#else\n    ndc = non_matrix_inverse_transform(ndc);\n#endif\n    \n    vec3 color = \n            TEXTURE == true ?\n                //                    before transform               after transform\n                iMouse.z > 0. ? texture(iChannel0, NDC).xyz : texture(iChannel0, ndc).xyz :\n                vec3(1);\n         color = mix( color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, ORIGIN, 2.*UNIT)) ); // Old origin.\n         \n    // Arrows (new origin is where arrows crosses).\n    // Always shows 2 unit square centered at new origin.\n    // Red shows right direction, green shows up direction.\n    color = mix( color, vec3(1,0,0), SMAA(arrowSDF_L2(ndc, vec2(-1, 0), vec2(1, 0), 0.01)) );\n    color = mix( color, vec3(0,1,0), SMAA(arrowSDF_L2(ndc, vec2(0, -1), vec2(0, 1), 0.01)) );   \n    /* Variant 2 (forward): if you want to apply transform to points.\n       For control transform:\n           Translates point by 1 to right,\n           Rotates point around Z axis by 90 degrees counter clockwise, \n           Scales point position vector by 2 (so point moves away from origin).\n       Cells doesn't distort and arrows doesn't moves (red - right, green - up).\n    */\n#ifndef NON_MATRIX\n    float h = 2.;                        // for forward/inverse convertion between normal and homogeneous coordinates.\n                                         // h can be any number not equal to 0.\n    P = vec3(M*h, h);                    // convert to homogeneous coordinates.\n    P = composed * P;\n    P = vec3(P.x/P.z, P.y/P.z, P.z/P.z); // convert from homogeneous coordinates if h != 1.\n#else\n    P.xy = non_matrix_transform(M);\n#endif\n    \n    color = mix( color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, M, 2.*UNIT)) );    // point before transform\n    color = mix( color, vec3(0,0,0), SMAA(diskSDF_L2(NDC, P.xy, 2.*UNIT)) ); // point after transform\n    color = mix( color, vec3(0,1,0), SMAA(arrowSDF_L2(NDC, M, P.xy, 0.01)) );\n    /* */\n\n\n    vec3 c = vec3(.4, 0.4, .4);\n    /* Cells before transform. */\n    if (iMouse.z > 0.) {\n        /* For control */\n        color = mix( color, vec3(1,0,1), SMAA(arrowSDF_L2(NDC, vec2(-1, 0), vec2(1, 0), 0.01)) );\n        color = mix( color, vec3(0,1,1), SMAA(arrowSDF_L2(NDC, vec2(0, -1), vec2(0, 1), 0.01)) );\n        /**/\n\n        NDC = fract(NDC); \n        color = mix( color, c, vertical_line(NDC, 0.));  color = mix( color, c, horizontal_line(NDC, 0.)); // comment this line if you not use mod\n        color = mix( color, c, vertical_line(NDC, -1.)); color = mix( color, c, horizontal_line(NDC, -1.));         \n        color = mix( color, c, vertical_line(NDC, 1.));  color = mix( color, c, horizontal_line(NDC, 1.));\n    }\n    /* Cells after transform. */\n    c = vec3(0.9, .8, .9);\n    ndc = fract(ndc); \n    color = mix( color, c, vertical_line(ndc, 0.));  color = mix( color, c, horizontal_line(ndc, 0.)); // comment this line if you not use mod\n    color = mix( color, c, vertical_line(ndc, -1.)); color = mix( color, c, horizontal_line(ndc, -1.));         \n    color = mix( color, c, vertical_line(ndc, 1.));  color = mix( color, c, horizontal_line(ndc, 1.));\n    /* */\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n#define TO_DEG                      57.295779513082323          // Convert radians to degrees\n#define KEY_T                     ( 84 )\n#define TEXTURE                   ( texelFetch(iChannel3,ivec2(KEY_T,2),0).x == 0.)\n\n/*\n    All matricies written in row odred (i think it's more common in books), \n    for more readability, then transposed, because GLSL uses column order.\n    \n    Linear transform:\n        V = Ax\n        \n    Affine transform:\n        V = Ax + T\n        V = Hx       // in homogeneous coordinates\n*/\n\n/* Scale */\nmat3 scale(vec2 s) // homogeneous for 2d points\n{\n    mat3 M = mat3(\n        s.x,   0, 0,\n          0, s.y, 0,\n          0,   0, 1);\n    return transpose(M);\n}\nmat4 scale(vec3 s) // homogeneous for 3d points\n{\n    mat4 M = mat4(\n        s.x,   0,   0, 0,\n          0, s.y,   0, 0,\n          0,   0, s.z, 0,\n          0,   0,   0, 1);\n    return transpose(M);\n}\n/* Rotation */\nmat3 rotx(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat3 M = mat3(\n         1, 0,  0,\n         0, c, -s,\n         0, s,  c);\n    return transpose(M);\n}\nmat3 roty(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat3 M = mat3(\n         c, 0, s,\n         0, 1, 0,\n        -s, 0, c);\n    return transpose(M);\n}\nmat3 rotz(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat3 M = mat3(\n         c, -s, 0,\n         s,  c, 0,\n         0,  0, 1);\n    return transpose(M);\n}\nmat4 rotX(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         1, 0,  0, 0,\n         0, c, -s, 0,\n         0, s,  c, 0,\n         0, 0,  0, 1);\n    return transpose(M);\n}\nmat4 rotY(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         c, 0, s, 0,\n         0, 1, 0, 0,\n        -s, 0, c, 0,\n         0, 0, 0, 1);\n    return transpose(M);\n}\nmat4 rotZ(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat4 M = mat4(\n         c, -s, 0, 0,\n         s,  c, 0, 0,\n         0,  0, 1, 0,\n         0,  0, 0, 1);\n    return transpose(M);\n}\nmat4 rotation(float rad, vec3 v)\n{\n    float s = sin(rad), c = cos(rad), ic = 1. - c;\n    mat4 M = mat4(\n        v.x*v.x*ic+c,     v.y*v.x*ic-v.z*s, v.z*v.x*ic+v.y*s, 0,\n        v.x*v.y*ic+v.z*s, v.y*v.y*ic+c,     v.z*v.y*ic-v.x*s, 0,\n        v.x*v.z*ic-v.y*s, v.y*v.z*ic+v.x*s, v.z*v.z*ic+c,     0,\n        0,                0,                0,                1\n    );\n    return transpose(M);\n}\n/*Translation*/\nmat3 translate(vec2 t)\n{\n    mat3 M = mat3(\n        1, 0, t.x,\n        0, 1, t.y,\n        0, 0,   1);\n    return transpose(M);\n}\nmat4 translate(vec3 t)\n{\n    mat4 M = mat4(\n        1, 0, 0, t.x,\n        0, 1, 0, t.y,\n        0, 0, 1, t.z,\n        0, 0, 0,   1);\n    return transpose(M);\n}\n/*Shear*/\nmat3 shear(vec2 s)\n{\n    mat3 M = mat3(\n        1. + s.x*s.y, s.x, 0,\n        s.y,          1,   0,\n        0,            0,   1);\n    return transpose(M);\n}\nmat4 shear(vec3 s, vec3 h)\n{\n    // s.x = xy, s.y = xz, s.z = yx,\n    // h.x = yz, h.y = zx, h.z = zy\n    mat4 M = mat4(\n        1,   s.x, s.y, 0,\n        s.z,   1, h.x, 0,\n        h.y, h.z,   1, 0,\n        0,     0,   0, 1);\n    return transpose(M);\n}\n\n/* Non-matrix transforms */\nvec2 CartesianToPolar(vec2 P)\n{\n    // 0.5065*TAU just used for visualisation.\n    return vec2(length(P), atan(P.y, P.x)*0.5065*TAU);\n}\nvec2 PolarToCartesian(vec2 P)\n{\n    P.y /= 0.5065*TAU;\n    return P.x * vec2(cos(P.y), sin(P.y));\n}\n\nvec2 CirclesSquares(vec2 P)\n{\n    vec2 v = vec2( sin(P*PI) );\n    return vec2( v.x+v.y, v.x-v.y );\n}\n\nvec2 archimedeanSpirals(vec2 P)\n{\n    float v = atan(P.y, P.x)/TAU;\n    return length(P)+vec2( v*3.0, -v*12.0 );\n}\n\nvec2 circleInverse(vec2 P)\n{\n    return P / dot(P,P);\n}\n\nvec2 mobiusTransform(vec2 P)\n{\n    vec2 u = P-vec2(1.0, 0);\n    vec2 v = u/dot(u, u);\n    v.x += 0.5;\n    return log(length(v)) * vec2(1.445, -1.445) + atan(v.y, v.x)/TAU * vec2(4.0, 12.0);\n}\n\nvec2 unknownTransform(vec2 P)\n{\n    return vec2(P); // bypass\n}\n// https://www.shadertoy.com/view/Ds2BW3\nvec2 unknownTransform2(vec2 P, float T)\n{\n    float tempX = P.x;\n    P.x += sin(P.y * (T / 10.));\n    P.y += sin(tempX * (T / 10.));\n\n    return P;\n}\n/**/\n\n\n/*SDF stuff*/\nfloat diskSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    return length(C - NDC)-r;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\nfloat arrowSDF_L2(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         C = E - dir * 0.275, //      U--\n         U = C + up  * 0.10,  // B----C----E\n         D = C - up  * 0.10;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.275 ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}","name":"Common","description":"","type":"common"}]}