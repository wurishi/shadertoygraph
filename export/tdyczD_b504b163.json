{"ver":"0.1","info":{"id":"tdyczD","date":"1602562781","viewed":205,"name":"Mosaic_5","username":"bigt","description":"马赛克","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mosaic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float sqrt3 = 1.7320508076;\nconst float pi_3 = 1.047197552;// pi / 3\n\n// 思路沿用上一个六边形马赛克shader的思路\n// https://www.shadertoy.com/view/WdVcz1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float hexagonRadius = 16.0;// 三角形边长(单位:像素)\n    float threshold = hexagonRadius * 0.008;// 三角形之间抗锯齿\n    float threshold2 = hexagonRadius * 0.2;// 六边形之间抗锯齿\n\n    vec2 mosaicSize = vec2(hexagonRadius * (1.0+0.5), hexagonRadius * sqrt3*0.5);\n    vec2 gridCoord = floor(fragCoord/mosaicSize);\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    float bRow = 1.0 - step(0.99999, mod(gridCoord.y, 2.0));\n    float bCol = 1.0 - step(0.99999, mod(gridCoord.x, 2.0));\n    float bResult = 1.0 - step(0.00001, abs(bRow - bCol));\n    \n    // 每个格子中两个六边形中心点的坐标\n    vec2 hC1 = mix(gridCoord + vec2(0.0), gridCoord + vec2(0.0,1.0), 1.0 - bResult);\n    vec2 hC2 = mix(gridCoord + vec2(1.0), gridCoord + vec2(1.0,0.0), 1.0 - bResult);\n\t\n    float fL1 = length(fragCoord-hC1*mosaicSize);\n    float fL2 = length(fragCoord-hC2*mosaicSize);\n    // 得到距离最近的六边形中心点坐标(uv坐标)\n    vec2 cResult = mix(hC1, hC2, step(0.00001, fL1 - fL2))*mosaicSize/iResolution.xy;\n    // 计算出六个三角形的中心坐标(1~6逆时针),并采样\n    float tmpX = (hexagonRadius*0.5)/iResolution.x;\n    float tmpX2 = hexagonRadius/iResolution.x;\n    float tmpY = (tan(radians(30.0)) * hexagonRadius*0.5)/iResolution.y;\n    float tmpY2 = mosaicSize.y/iResolution.y-tmpY;\n    \n    float mmm = smoothstep(-threshold2,threshold2,fL1 - fL2);\n    vec3 col1 = texture(iChannel0, cResult + vec2(tmpX, tmpY)).rgb;\n    //vec3 col1 = vec3(1.0,0.0,0.0);\n    vec3 col1_1 = texture(iChannel0, cResult + vec2(tmpX2, tmpY2)).rgb;\n    col1 = mix(col1, col1_1, mmm);\n    \n    vec3 col2 = texture(iChannel0, cResult + vec2(0.0, tmpY2)).rgb;\n    vec3 col3 = texture(iChannel0, cResult + vec2(-tmpX, tmpY)).rgb;\n    vec3 col3_1 = texture(iChannel0, cResult + vec2(-tmpX2, tmpY2)).rgb;\n    col3 = mix(col3_1, col3, mmm);\n    \n    vec3 col4 = texture(iChannel0, cResult + vec2(-tmpX, -tmpY)).rgb;\n    vec3 col4_1 = texture(iChannel0, cResult + vec2(-tmpX2, -tmpY2)).rgb;\n    col4 = mix(col4_1, col4, mmm);\n    \n    vec3 col5 = texture(iChannel0, cResult + vec2(0.0, -tmpY2)).rgb;\n    vec3 col6 = texture(iChannel0, cResult + vec2(tmpX, -tmpY)).rgb;\n    vec3 col6_1 = texture(iChannel0, cResult + vec2(tmpX2, -tmpY2)).rgb;\n    col6 = mix(col6, col6_1, mmm);\n    \n    // 根据op与x的夹角,判断属于哪个三角形,求出三角形重心坐标采样\n    vec2 v = fragCoord - cResult*iResolution.xy;\n    float deg = atan(v.y, v.x);\n    float f1 = step(0.0, deg);//smoothstep(0.0+threshold,0.0-threshold,deg);// 1三角形值为1,6三角形值为0,1 6三角形之间为0~1\n    float f2 = smoothstep(pi_3+threshold,pi_3-threshold,deg);\n    col += mix(vec3(0.0), col1, f1*f2);\n    \n    float f3 = 1.0 - smoothstep(pi_3+threshold,pi_3-threshold,deg);\n    float f4 = smoothstep(pi_3*2.0+threshold,pi_3*2.0-threshold,deg);\n    col += mix(vec3(0.0), col2, f3*f4);\n    \n    float f5 = 1.0 - smoothstep(pi_3*2.0+threshold,pi_3*2.0-threshold,deg);\n    float f6 = 1.0 - step(pi_3*3.0, deg);//smoothstep(pi_3*3.0+threshold,pi_3*3.0-threshold,deg);\n    col += mix(vec3(0.0), col3, f5*f6);\n    \n    float f7 = step(-pi_3*3.0, deg);//1.0 - smoothstep(-pi_3*3.0+threshold,-pi_3*3.0-threshold,deg);\n    float f8 = smoothstep(-pi_3*2.0+threshold,-pi_3*2.0-threshold,deg);\n    col += mix(vec3(0.0), col4, f7*f8);\n    \n    float f9 = 1.0 - smoothstep(-pi_3*2.0+threshold,-pi_3*2.0-threshold,deg);\n    float f10 = smoothstep(-pi_3*1.0+threshold,-pi_3*1.0-threshold,deg);\n    col += mix(vec3(0.0), col5, f9*f10);\n    \n    float f11 = 1.0 - smoothstep(-pi_3*1.0+threshold,-pi_3*1.0-threshold,deg);\n    float f12 = 1.0 - step(0.0, deg);//smoothstep(-pi_3*0.0+threshold,-pi_3*0.0-threshold,deg);\n    col += mix(vec3(0.0), col6, f11*f12);\n    //if(deg < pi_3 && deg > 0.0)\n    //{\n    //    col = col1;//vec3(1.0,0.0,0.0);\n    //}\n    //if(deg < pi_3*2.0 && deg > pi_3)\n    //{\n    //    //col = vec3(0.0,1.0,0.0);\n    //    col = col2;\n    //}\n    //else if(deg < pi_3*3.0 && deg > pi_3*2.0)\n    //{\n    //    //col = vec3(0.0,0.0,1.0);\n    //    col = col3;\n    //}\n    //else if(deg < -pi_3*2.0 && deg > -pi_3*3.0)\n    //{\n    //    //col = vec3(1.0,1.0,0.0);\n    //    col = col4;\n    //}\n    //else if(deg < -pi_3 && deg > -pi_3*2.0)\n    //{\n    //    //col = vec3(0.0,1.0,1.0);\n    //    col = col5;\n    //}\n    //else if(deg < 0.0 && deg > -pi_3)\n    //{\n    //    //col = vec3(1.0,0.0,1.0);\n    //    col = col6;\n    //}\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}