{"ver":"0.1","info":{"id":"XsyXzW","date":"1463035527","viewed":203,"name":"Marble Cake","username":"yvtjp","description":"Attempt to reproduce this: http://tinyurl.com/hg2gvhx Algorithm: https://www.shadertoy.com/view/XsdSR7","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Final composition\n\nconst float BloomUndersample = 20.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel1, uv);\n    \n    vec2 offs = vec2(50. / BloomUndersample) / iResolution.xy;\n    \n    vec2 uv0 = uv / BloomUndersample;\n    for (float x = -0.5; x <= 0.5; x += 0.2) {\n        for (float y = -0.5; y <= 0.5; y += 0.2) {\n\t\t\tfragColor += texture(iChannel0, uv0 + vec2(x, y) * offs)\n                 * (max(0.7 - length(vec2(x, y)), 0.) * .0002);\n        }\n    }\n    \n    // vignette\n    vec2 vigPos = ((uv.xy - 0.5) * iResolution.xy) / max(iResolution.x, iResolution.y);\n    float vig = 1. - dot(vigPos, vigPos);\n    fragColor.xyz *= vig * vig;\n    \n    fragColor.xyz = sqrt(fragColor.xyz); // gamma correction\n    fragColor.xyz *= 0.7; // exposure\n    fragColor.xyz = mix(fragColor.xyz, smoothstep(0., 1., fragColor.xyz), 0.9); // tone mapping\n    fragColor.w = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float FarDistance = 12.;\nconst float NearDistance = 4.;\nconst int NumSteps = 32;\t\t// Number of samples per pixel (per frame)\nconst float DerivStep = 0.001;\t// For shading\nconst bool disableProgressiveRefinement = false;\n\nfloat torusFunc(vec3 pos)\n{\n    vec2 torus = vec2(length(pos.xy), pos.z);\n    float p = fract(atan(pos.y / pos.x) * 4. / 3.141592654) * 2. - 1.;\n    float rad = sqrt(1. - p * p);\n    rad = mix(rad, 0., pow(abs(p), 3.));\n    torus.x += rad * -0.1;\n    rad = .2 * rad + .55;\n    return rad - length(torus - vec2(1.2, 0.));;\n}\n\nfloat plateFunc(vec3 pos)\n{\n    vec2 torus = vec2(length(pos.xy), pos.z);\n    float d2;\n    if (torus.x < 2.2) {\n\t\td2 = .05 - abs(torus.y + .8);   \n    } else {\n        d2 = .05 - length(torus * vec2(4., 1.) - vec2(2.2 * 4., -.8));   \n    }\n    return d2;\n}\n\nfloat implicitFunc(vec3 pos)\n{\n    float torus = torusFunc(pos);\n    float plate = plateFunc(pos);\n    return max(torus, plate);\n}\n\nfloat ditherPattern(vec2 coord)\n{\n \tcoord = fract(coord * 0.5);\n    return dot(coord, vec2(0.25, 0.5));\n}\n\nvec3 computeNormalAt(vec3 pos)\n{\n    vec3 v = vec3(\n    \timplicitFunc(pos - vec3(DerivStep, 0., 0.)),\n    \timplicitFunc(pos - vec3(0., DerivStep, 0.)),\n    \timplicitFunc(pos - vec3(0., 0., DerivStep))\n    );\n    vec3 v2 = vec3(\n    \timplicitFunc(pos + vec3(DerivStep, 0., 0.)),\n    \timplicitFunc(pos + vec3(0., DerivStep, 0.)),\n    \timplicitFunc(pos + vec3(0., 0., DerivStep))\n    );\n    return normalize(v - v2);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// from https://github.com/Hyper3D/hyper3d/blob/master/src/renderer/shaders/common/ShadingModel.glsl \nfloat evaluateGGXSpecularDistribution(float nhDot, highp float roughness)\n{\n    // Walter et al. 2007, \"Microfacet models for refraction through rough surfaces\"\n    // http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n    highp float a = roughness * roughness;\n    highp float aa = a * a;\n    highp float t = nhDot * nhDot * (aa - 1.) + 1.;\n    return aa /\n        (t * t + 1.e-20);\n}\nfloat evaluateSchlickFresnel(float hlDot)\n{\n    float t = 1. - hlDot;\n    float tt = t * t;\n    return tt * tt * t;\n}\nfloat evaluateBeckmannGeometryShadowing(float nlDot, float nvDot, float roughness)\n{\n    // http://graphicrants.blogspot.jp/2013/08/specular-brdf-reference.html\n    float lct = .5 / (roughness * sqrt(1. - nlDot * nlDot) + 0.00001);\n    float vct = .5 / (roughness * sqrt(1. - nvDot * nvDot) + 0.00001);\n    float lc = lct * nlDot, vc = vct * nvDot;\n    float a = 3.353 * lc + 2.181 * lc * lc; // not typo\n    a *= 3.353 * vct + 2.181 * vct * vc;\n    float b = 1. + 2.276 * lc + 2.577 * lc * lc;\n    b *= 1. + 2.276 * vc + 2.577 * vc * vc;\n    return a / b;\n}\nfloat evaluateBeckmannGeometryShadowingSingleSide(float nlDot, float roughness)\n{\n    // http://graphicrants.blogspot.jp/2013/08/specular-brdf-reference.html\n    float lct = .5 / (roughness * sqrt(1. - nlDot * nlDot) + 0.00001);\n    float lc = lct * nlDot;\n    float a = 3.353 * lc + 2.181 * lc * lc; // not typo\n    float b = 1. + 2.276 * lc + 2.577 * lc * lc;\n    return a / b;\n}\n\nvec3 cameraPos;\n\nfloat evaluateAmbient(vec3 pos, vec3 normal)\n{\n    vec3 viewDir = normalize(cameraPos - pos);\n    float nvDot = dot(normal, viewDir);\n    float fresnel = evaluateSchlickFresnel(nvDot);\n    float refl = mix(0.03, 1., fresnel);\n    return 1. - refl;\n}\n\nvec3 evaluatePointLight(vec3 pos, vec3 normal, vec3 lightDir, vec3 diffuse, vec3 spcolor, float metal)\n{\n    vec3 viewDir = normalize(cameraPos - pos);\n \tvec3 halfVec = normalize(viewDir + lightDir);\n    float nlDot = dot(normal, lightDir);\n    if (nlDot <= 0.) return vec3(0.);\n    float hlDot = dot(halfVec, lightDir);\n    float nhDot = dot(normal, halfVec);\n    float nvDot = dot(normal, viewDir);\n    \n   \t// FIXME: correct the computation\n    float fresnel = evaluateSchlickFresnel(nvDot);\n    float refl = mix(mix(0.02, 1., metal), 1., fresnel);\n    float roughness = 0.2;\n    float spec = evaluateGGXSpecularDistribution(nhDot, roughness)\n        * evaluateBeckmannGeometryShadowing(nlDot, nvDot, roughness);\n    return mix(diffuse, spcolor * spec, refl) * nlDot;\n}\n\n\nvec3 sampleBackground(vec3 v)\n{\n    v = vec3(v.x, -v.z, v.y);\n    vec3 rgb = texture(iChannel1, v).xyz;\n    return rgb * rgb * 4.; // linearize\n}\t\n\nvec3 evaluateReflection(vec3 pos, vec3 normal, out float fresnel)\n{\n    vec3 viewDir = normalize(cameraPos - pos);\n    float nvDot = dot(normal, viewDir);\n    vec3 lightDir = reflect(-viewDir, normal);\n    \n    fresnel = evaluateSchlickFresnel(nvDot);\n    float refl = mix(0.02, 1., fresnel);\n    float roughness = 0.2;\n    \n    refl *= evaluateBeckmannGeometryShadowingSingleSide(nvDot, roughness);\n    \n    return refl * sampleBackground(lightDir).xyz;\n}\n\nvoid shade(vec3 pos, out vec3 color)\n{\n    vec3 surfNormal = computeNormalAt(pos);\n    vec3 origNormal = surfNormal;\n    \n    float h = pos.x * 0.25;\n    vec3 albedo;\n    float metal = 0.;\n    if (pos.z < -.69) {\n     \talbedo = vec3(.01, .01, .02);\n        \n        // bump mapping\n        vec2 tc = pos.xy * 0.1;\n        float h1 = texture(iChannel2, tc).x;\n        float h2 = texture(iChannel2, tc + vec2(1., 0.) * 1.e-3).x;\n        float h3 = texture(iChannel2, tc + vec2(0., 1.) * 1.e-3).x;\n        surfNormal.xy += vec2(h2 - h1, h3 - h1) * .5;\n        surfNormal = normalize(surfNormal);\n    } else {\n     \talbedo = vec3(.15, .03, .01);\n        float blend = smoothstep(1.2, 1.4, length(pos.xy));\n        albedo = mix(vec3(.5, .8, .1), albedo, blend);\n        metal = 1. - blend;\n        \n        // bump mapping\n        vec2 tc = normalize(pos + vec3(0., 0., 1.5)).xy * 2.;\n        float h1 = texture(iChannel3, tc).x;\n        float h2 = texture(iChannel3, tc + vec2(1., 0.) * 1.e-1).x;\n        float h3 = texture(iChannel3, tc + vec2(0., 1.) * 1.e-1).x;\n        surfNormal.xy += vec2(h2 - h1, h3 - h1) * .2 * (1. - blend);\n        surfNormal = normalize(surfNormal);\n    }\n    \n    vec3 diffuse = albedo * (1. - metal);\n    vec3 specular = mix(vec3(1.), albedo, metal);\n\n   \tfloat fresnel;\n    \n    // semisphere lighting\n    float dtSky = dot(surfNormal, vec3(0., 0., 1.));\n    vec3 diff = (dtSky * 0.5 + 0.5) * evaluateAmbient(pos, surfNormal)\n        * vec3(0.45, 0.42, 0.4);\n    color.xyz = albedo * diff;\n    \n    // directional lighting\n    color.xyz += evaluatePointLight(pos, surfNormal,\n        normalize(vec3(0.5, 1., 1.)), diffuse, specular, metal);\n    \n    // environemntal mapping\n    color.xyz += evaluateReflection(pos, surfNormal, fresnel) * specular;\n    \n    // clear coat\n    vec3 ccrefl = evaluateReflection(pos, origNormal, fresnel);\n    color.xyz = color.xyz * (1. - fresnel) + ccrefl;\n}\n\nbool trace(inout vec4 fragColor, vec3 cameraPos, vec3 rayDir, float farDist, float dither)\n{\n    fragColor.w = FarDistance; // reset upper bound\n    \n    // Start sampling\n    float interval = (farDist - NearDistance) / float(NumSteps + 1);\n    float d = interval * dither + NearDistance;\n    vec3 rayPos = vec3(0.);\n    float fval = implicitFunc(cameraPos + rayDir * d);\n    \n    for (int i = 0; i < NumSteps; ++i) {\n        float lastD = d;\n        // vec3 lastRayPos = rayPos;\n        float lastfval = fval;\n        \n       \td += interval;\n        if (i == NumSteps - 1) {\n         \td = farDist;   \n        }\n     \trayPos = cameraPos + rayDir * d;\n        fval = implicitFunc(rayPos);\n        \n        if (fval > 0.) {\n            // refine\n            for (int k = 0; k < 12; ++k) {\n                float midD = mix(lastD, d, 0.5);\n                vec3 midRayPos = cameraPos + rayDir * midD;\n                float midfval = implicitFunc(midRayPos);\n                if (midfval > 0.) {\n                 \td = midD;   \n                } else {\n                 \tlastD = midD;   \n                }\n                rayPos = midRayPos;\n            }\n         \tfragColor.w = lastD;\n            shade(rayPos, fragColor.xyz);\n            return true;\n        }\n        \n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 lastValue = iFrame == 0 ? vec4(0.) : texture(iChannel0, uv);\n    \n    \n    float yaw = iTime * 0.04;\n    float pitch = 0.3 * sin(iTime * 0.01) + .5;\n    if (iMouse.z > 0.) {\n        vec2 mousePos = iMouse.xy / iResolution.xy - 0.5;\n     \tyaw = mousePos.x * 6.;\n        pitch = mousePos.y * -4.;\n    }\n    cameraPos = vec3(cos(yaw)*cos(pitch),sin(yaw)*cos(pitch),sin(pitch)) * 8.;\n    vec3 cameraDir = normalize(-cameraPos);\n    vec3 cameraUp = vec3(0., 0., 1.);\n    vec3 cameraU = normalize(cross(cameraUp, cameraDir));\n    vec3 cameraV = cross(cameraDir, cameraU);\n    vec2 cameraUV = (uv - 0.5) * 0.5 * vec2(16./9.,1.);\n    vec3 rayDir = cameraDir + cameraU * cameraUV.x + cameraV * cameraUV.y;\n    \n    vec3 background = sampleBackground(rayDir);\n    fragColor = vec4(mix(lastValue.xyz, background, 0.8), 1.0);\n    \n    float farDist = clamp(lastValue.w * 1.003, 0.01, FarDistance);\n    \n    float dither = ditherPattern(fragCoord);\n    dither = fract(dither + 10. * cos(10. * cos(iTime + dot(fragCoord, vec2(11.4, 51.4)))));\n    \n    if (disableProgressiveRefinement || !trace(fragColor, cameraPos, rayDir, farDist, dither)) {\n        // Fail; reset the upper bound\n        trace(fragColor, cameraPos, rayDir, FarDistance, dither);\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Undersampling for bloom effect\n\nconst float BloomUndersample = 20.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= BloomUndersample;\n    if (uv.x > 1. || uv.y > 1.) {\n     \tfragColor = vec4(0.);\n        return;\n    }\n    \n    vec2 offs = vec2(20.) / iResolution.xy;\n    \n    fragColor = vec4(0.);\n    for (float x = -0.5; x <= 0.5; x += 0.1) {\n        for (float y = -0.5; y <= 0.5; y += 0.1) {\n\t\t\tfragColor.xyz += texture(iChannel0, uv +\n                  vec2(x, y) * offs).xyz;\n        }\n    }\t\n    \n    fragColor.w = 1.;\n}","name":"Buf B","description":"","type":"buffer"}]}