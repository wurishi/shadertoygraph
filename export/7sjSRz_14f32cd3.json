{"ver":"0.1","info":{"id":"7sjSRz","date":"1619584580","viewed":35,"name":"TorusKnotSurface-Test","username":"antoinefortin","description":"Antoine","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["antoine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\n/* SDF */\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nfloat sdPlane(vec3 pos)\n{\n\treturn pos.y;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec2 opu(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n  \n}\n\n\nfloat h(vec2 p)\n{\n    \n\tfloat ba = texture(iChannel1, (p * 0.005) + (iTime * .005)).x;  \n    float ba2 = texture(iChannel1, (p * 1.0025) + (iTime * .005)).x;  \n   \n    return ba + ba2;\n}\n\n\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\n\nvec2 map(vec3 pos)\n{\n    \n    /*\n    \n    */\n    float r1 = 3.7, r2 = .22;\n    vec2 cp = vec2(length(pos.xz)-r1, pos.y);\n    float a = atan(pos.x, pos.z);\n    \n    float a2 = atan(pos.z * 2., pos.x);\n    \n    \n    cp *= Rot(a * 3.5);\n    cp *= Rot(a2 * (cos(iTime * .25) * 12.5)) + .25;\n    \n    cp.y = abs(cp.y) - .1;\n    \n    float d = length(cp) - (r2);\n    \n\n    \n    float theFloor = sdPlane(pos);\n    float box = sdBox(pos, vec3(1.));\n\t\n    vec2 res =     vec2(d,       1.0 /*Object ID*/);\n  \t\n//    res = opu(res, vec2(arms, 3.));\n    \n    res.x *= .025;\n    return res;\n}\n\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n\n    float t = 0.0;\n    float id = -20.;\n\tfloat farClippingPlane = 60.0;\n    \n    for(int i = 0; i < 256; i++)\n    {\n        \n    \tvec3 pos = ro + t * rd;\n        float h = map(pos).x;\n        id = map(pos).y;\n        \n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        if(t > farClippingPlane) break;\n        \n    }\n    \n    if(t > farClippingPlane) t = -1.0;\n    \n    return vec2(t, id);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.01, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy).x - map(pos-e.xyy).x,\n        \t\t\t\t\tmap(pos+e.yxy).x - map(pos-e.yxy).x,\n        \t\t\t\t\tmap(pos+e.yyx).x - map(pos-e.yyx).x\n    \t\t\t\t));\n}\n\nvoid resetToZero(inout vec3 r)\n{\n\tr = vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n \n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n\tvec3 ro = vec3(0., 2.55 ,-9.5);\n\t//vec3 rd = normalize(vec7(uv.x, uv.y - .2,1.)); \n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(m.x * 12.);\n\tvec3 rd = R(uv, ro, vec3(0,0.0,0), .7);\n\tvec3 col = vec3(.22);\n\t\n\t\n\tfloat hitDistance = castRay(ro, rd).x;\n    float objectId = castRay(ro, rd).y;\n    \n    vec3 unfinishedSky;\n    \n    // No hit color\n    if(hitDistance < 0.01)\n    {\n        \n        /* Sky properties*/\n        vec3 skyColor = vec3(.4, 0.75, 18.0);\n        float skyMovement = .5;\n\t\tcol = skyColor - abs( .5 + sin(iTime * skyMovement)) * rd.y * rd.x;\n        \n        \n        \n    }\n    \n    \n    if(hitDistance > 0.)\n    {\n       \tvec3 debugColor = vec3(1.);\n        vec3 pos = ro + hitDistance * rd;\n        vec3 normalWS = calcNormal(pos);\n\n        /* Global Lighting section */\n        \n        // Sky\n        vec3 skyColor = vec3(.4, 0.75, 1.0);\n\t\tfloat skyMovement = .5;\n        vec3 skyColFactor = skyColor - abs( .5 + sin(iTime * skyMovement)) * rd.y * rd.x;\n\t\t\n        // Basic lighting\n        vec3 sunPos = normalize(vec3(.5, 1.4, -.52));\n \t\tfloat fSunDiffuse = clamp(dot(normalWS, sunPos), 0., 1.);\n        float sunShadow = smoothstep(castRay(pos + normalWS * 0.001, sunPos).x, 0., 1.);\n\t\tfloat skyDif = dot(normalWS,vec3(0.,1.0,0.));\n        vec3 basicColor = vec3(.5, 0.75, 0.8) * (fSunDiffuse + (skyDif * .5)) * sunShadow;\n        col = basicColor * (skyColFactor * 1.75);\n\n        \n        \n        //col = skyColFactor;\n        /*End of Global Lighting section */\n        \n        \n        bool materialSystem = true;\n        \n        if(materialSystem)\n        {\n            float blendingFactor = .5;\n\t\t\t// Sphere\n        \tif(objectId == 1.0) \n        \t{\n        \t\tvec3 sphereMat = vec3(3.2, .5, .6);\n                col = col * sphereMat;\n                col += (sphereMat * .5);\n        \t}\n        \n        \t// Floor\n        \tif(objectId == 2.0)\n       \t\t{\n                /* Floor settings*/\n               \tfloat gridXF = 25.0f;\n\t\t\t\tfloat gridYF = 25.0f;\n                float changeFactor = iTime * .5;\n        \t\tvec3 floorColor = vec3(.25, .45, .3);\n\t\t\t\t// displace the floor\n                pos.x += sin(iTime * .2);\n                pos.z += cos(iTime * .2);\n                float f = .5 + abs(sin( sin(changeFactor) * (sin(pos.x * gridXF) * cos(pos.z * gridYF))));\n               \tvec3 pattern = vec3(f / 5.);\n                col = pattern * col + vec3(0., .22, 0.);\n                \n                {\n                 //resetToZero(col);\n                }\n        \t}\n            // trunk\n            if(objectId == 3.0)\n            {\n                vec3 trunk = vec3(255) / vec3(210,105,30);\n            \tcol = vec3(.8, .5, .2) * vec3(dot(normalWS, sunPos));\n            }\n            \n            // leaves\n            if(objectId == 4.)\n            {\n\t\t\t\t\n            \tcol = vec3(.4, .95, .2) * vec3(dot(normalWS, sunPos));\n            }\n            \n            /*Sapin*/\n            \n            if(objectId == 5.)\n            {\n                \n                // Get the position of the hit.\n                // Well it is pos...\n                // SO \n                float shadingAmoutOnClouds = dot(normalWS, sunPos);\n                vec3 bloop = texture(iChannel0, uv * 2.).xxx;\n            \tcol = vec3(shadingAmoutOnClouds) * bloop * 5.;\n            }\n            \n          // water\n\t\t\tif(objectId == 6.)\n            {\n                \n                // Get the position of the hit.\n                // Well it is pos...\n                // SO \n                \n\t\t\t\tvec3 waterC = vec3(dot(normalWS,sunPos + pos * .5));\n\t\t\t\tfloat hitDistance = castRay(ro, rd).x;\n    \t\t\tfloat objectId = castRay(ro, rd).y;\n                vec3 wcF =  (sin(uv.y * 120.) * uv.y * sin(uv.x * 120.)) * waterC * vec3(cos(hitDistance * pos.x), sin(objectId * 120.), cos(sin(waterC * hitDistance)));\n\t\t\t\tcol = waterC.xxx * (abs(wcF.xxx) + .5)  * vec3(.1, .15, .75);\n                col += vec3(0., 0., .4);\n                \n            }\n            \n            \n            \n            \n        }\n\n        \n        col = col;\n       \n        /*\n       \tvec3 sundir = normalize(vec3(0.2, 0.4, 0.2));\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir).x,0., 1.);\n        float sky_dif = clamp(dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n        col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha;\n        col += vec3(0.0, 0.2, 0.4) * sky_dif;\n\t\tcastRay(ro, rd).x */    \n\t}\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}