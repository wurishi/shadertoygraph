{"ver":"0.1","info":{"id":"tlsXz2","date":"1563690985","viewed":145,"name":"IFS Cube","username":"takumifukasawa","description":"IFS Cube","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//------------------------------------------------------------------------\n// refs\n// https://qiita.com/kaneta1992/items/21149c78159bd27e0860#ifs%E3%81%AB%E3%82%88%E3%82%8B%E8%A4%87%E9%9B%91%E3%81%AA%E5%BD%A2%E7%8A%B6\n// https://qiita.com/edo_m18/items/8c20c9c80d44e8b1dfe4#_reference-7c25132332209c2cd12e\n// https://www.shadertoy.com/view/ll2GD3\n//------------------------------------------------------------------------\n\n#define EPS .0001\n#define PI 3.1415\n#define repeat(p, o) mod(p, o) - o * .5\n\nconst float stopThreshold = .0001;\n\nstruct Light {\n  vec3 position;\n  float intensity;\n  vec3 color;\n  vec3 diffuse;\n  vec3 specular;\n  float attenuation;\n};\n    \nLight pointLight;\n    \nstruct Surface {\n  float dist;\n  vec3 position;\n  vec3 baseColor;\n  vec3 normal;\n  vec3 emissiveColor;\n};  \n\n    \n// t: 0-1, a: contrast, b: brightness, c: times, d: offset\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n    \nfloat random(in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}    \n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat scene(vec3 p) {\n    p.xy *= rot(.2);\n    p.yz *= rot(.5);\n    for(int i = 0; i < 4; i++) {\n    \tp = abs(p) - 1.18;\n        p = abs(p) - 1.2;\n        p.xz *= rot(float(i) + .3 + iTime * .9);\n        p.xy *= rot(float(i) + .8 + sin(iTime) * .8);\n    }\n    return sdBox(p, vec3(.48));\n}\n\nmat3 camera(vec3 o, vec3 t) {\n\tvec3 forward = normalize(t - o);\n    vec3 u = vec3(0., 1., 0.);\n    vec3 right = cross(forward, u);\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nvec3 getNormal(vec3 p, float eps) {\n    vec2 e = vec2(eps, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy) - scene(p - e.xyy),\n            scene(p + e.yxy) - scene(p - e.yxy),\n            scene(p + e.yyx) - scene(p - e.yyx)\n        )\n    );\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  vec3 lightDir = light.position - position;\n  vec3 ref = reflect(-normalize(lightDir), normal);\n  float specular = 0.;\n  if(diffuse > 0.) {\n    specular = max(0., dot(ref, normalize(cameraPos - normal)));\n    float specularPower = 64.;\n    specular = pow(specular, specularPower);\n  }\n  return specular;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n  // diffuse\n  float diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));\n  vec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;\n  // specular\n  float specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  vec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  \n\n  light.diffuse = diffuse;\n  light.specular = specular;\n}\n\nvoid calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {\n  float d = distance(light.position, surface.position);\n  vec3 k = vec3(.06, .08, .09);\n  light.attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n\n  // point light\n  vec3 lightDir = light.position - surface.position;\n  // diffuse\n  float diffuseCoef = max(0., dot(surface.normal, normalize(lightDir)));\n  vec3 diffuse = diffuseCoef * light.color * light.intensity * light.attenuation;\n  // specular\n  float specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  vec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity); \n    \n  light.diffuse = diffuse;\n  light.specular = specular;\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos) {\n  vec3 position = surface.position;\n\n  vec3 color = vec3(0.);\n  vec3 sceneColor = vec3(0.);\n  vec3 normal = surface.normal;\n\n  vec3 objColor = vec3(.3);\n  vec3 specularColor = vec3(.95);\n\n  Light directionalLight;\n  directionalLight.position = vec3(0., 1., 0.);\n  directionalLight.intensity = .7;\n  directionalLight.color = vec3(1., 1., 1.);\n  directionalLight.attenuation = 1.;\n  calcDirectionalLight(directionalLight, surface, cameraPos);\n\n  // update lights\n  float m = .4;\n  pointLight.color = vec3(1.);\n  pointLight.intensity = .8;\n  pointLight.position = vec3(cos(iTime) * m, 1.8, sin(iTime) * m);\n  calcPointLight(pointLight, surface, cameraPos);\n\n  vec3 diffuse = \n    directionalLight.diffuse\n    + pointLight.diffuse;\n      \n  vec3 specular =\n    directionalLight.specular\n    + pointLight.specular;\n    \n  color += objColor * diffuse + specularColor * specular;\n  \n  return color;\n}\n\n\nvec3 fog(vec3 color, float distance, vec3 fogColor, float b) {\n  float fogAmount = 1. - exp(-distance * b);\n  return mix(color, fogColor, fogAmount);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    vec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    float r = 1.4;\n    vec3 ro = vec3(sin(iTime * .2) * r, .8, cos(iTime * .2) * r);\n    vec3 target = vec3(0.);\n    float fov = .4;\n    \n    vec3 rd = camera(ro, target) * normalize(vec3(uv, fov));\n    \n    // raymarching\n    float depth = 0.;\n    float dist = 0.;\n    for(int i = 0; i < 99; i++) {\n    \tdist = scene(ro + rd * depth);\n        if(dist < stopThreshold) {\n            break;\n        }\n        depth += dist;\n    }   \n    \n    // no hit\n    if(dist >= stopThreshold) {\n    \tfragColor = vec4(vec3(0.), 1.);\n        return;\n    }\n    \n    vec3 color = vec3(0.);\n   \n    vec3 position = ro + rd * depth;\n    vec3 normal = getNormal(position, .001);\n    \n    Surface surface;\n    surface.position = position;\n    surface.normal = normal;\n    \n    float d = 1. - depth / 20.;\n    \n\tvec3 sceneColor = lighting(surface, ro);   \n\n    sceneColor *= palette(\n    \td,\n        vec3(1.),\n        vec3(1.),\n        vec3(1.),\n        vec3(.1, .2, .8)    \n    );\n    \n  \tsceneColor = fog(sceneColor, depth, vec3(0.), .18);\n    \n    \n    fragColor = vec4(sceneColor, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"","name":"Common","description":"","type":"common"}]}