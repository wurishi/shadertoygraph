{"ver":"0.1","info":{"id":"tdlBWH","date":"1588190095","viewed":305,"name":"Elders looking at the sky","username":"maz","description":"This is an experiment in creating a scene using layers of 2D distance functions. The code follows the design from here: https://www.shadertoy.com/view/Xds3zN. This was harder than I thought it would be :)","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","characters"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// maz 2020\n// Experiment in creating a scene using layers of 2D distance functions\n\nfloat noise1(vec2 p)\n{\n   return fract(sin(p.x*p.y)*1175.5453123);\n}\n\nfloat noise2(vec2 p)\n{\n   return fract(sin(p.x*p.y+5209.)*1175.5453123);\n}\n\nfloat noise3(vec2 p)\n{\n   return fract(sin(p.x*p.y+1103.)*1175.5453123);\n}\n\n// smooth \"noise\", not that noisy...\nfloat noise(float t)\n{\n    return sin(t)*cos(t*4.0);\n}\n\n// rotate pos (x,y) by theta radians around the Z axis\nvec2 rot(float theta, vec2 pos)\n{\n    vec2 R1 = vec2(cos(theta), -sin(theta));\n    vec2 R2 = vec2(sin(theta),  cos(theta));\n    return vec2(dot(R1, pos), dot(R2, pos));\n}\n\n// mirrors pos (x,y) around the Y axis\nvec2 mirror(vec2 pos)\n{\n    return vec2(abs(pos.x), pos.y);\n}\n\n// operation \"union\"\n// v1 and v2 are (distance, color index) pairs\n// the union is determined by the pair with the smaller distance\nvec2 opU(in vec2 v1, in vec2 v2)\n{\n    return v1.x < v2.x? v1 : v2;\n}\n\n// operation \"front\"\n// v1 and v2 are (distance, color index) pairs\n// v2 replaces the color of v1 if v1.x is a distance outside the shape\nvec2 opF(in vec2 v1, in vec2 v2)\n{\n    return v1.x > 0.0? v2 : v1;\n}\n\n// returns negative distance to edge if inside; positive distance if outside\nfloat sdCircle(in vec2 p, in vec2 center, in float radius)\n{\n    return length(p - center) - radius; \n}\n\n// boundary test for super-ellipse\n// returns -1.0 if inside the ellipse and 1.0 if outside\nfloat bSuperEllipse(vec2 p, vec2 c, float a, float b, float n, float r)\n{\n    vec2 localp = p - c;\n    float v = pow(abs(localp.x/a), n) + pow(abs(localp.y/b), n);\n    float d = v - pow(r,n);\n    return mix(1.0, -1.0, step(0.0, -d));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEllipse(vec2 p, vec2 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdArc(in vec2 pos, in float rOuter, in float rInner, in float arcAngleRad)\n{\n    pos.x = abs(pos.x); // mirror about y-axis\n    float theta = 0.5*(3.14 - arcAngleRad);\n    vec2 sc = vec2(cos(theta),sin(theta)); \n    float k = pos.x * sc.y - sc.x * pos.y; // cross product\n    float len = length(pos.xy); \n    float d = k < 0.? max(len - rOuter, -len + rInner) : 1e0;\n    return d;\n}\n\nfloat stemFn(float x, float p)\n{\n    return (p*x*x);\n}\n\nvec2 elder(in float id, in vec2 pos)\n{\n    float w = 0.1;\n    float wstems[5] = float[](0.4, 1.5, 0.05, -1.1, -0.2);\n    float ystems[5] = float[](1.5, 0.9, 2.0, 1.0, 1.6); \n\n    float blossom = 1e10;\n    float stem = 1e10;\n    for (int i = 0; i < 5; i++)\n    {\n        float ws = wstems[i]+0.1*sin(iTime);\n        float w1 = stemFn(pos.y, ws);\n        float l1 = pos.y > 0.0 && pos.y < ystems[i]? max(w1-pos.x, pos.x - w1 - w) : 1e10; \n\n        vec2 center = vec2(stemFn(ystems[i], ws), ystems[i]);\n        float s1 = sdCircle(pos, center, 0.3);\n        float noise = 0.01*(sin(10.0*pos.y)+cos(10.0*pos.x));\n        blossom = min(blossom, s1+noise);\n        stem = min(l1, stem);\n    }\n\n    float e3 = sdEllipse(pos-vec2(0.0, 0.05), vec2(0.6, 0.3));\n\n    float yoffset = 0.0;//0.05 * sin(iTime);\n    vec2 result = vec2(1e10);\n    result = opU(vec2(sdCircle(pos, vec2( 0.6 + yoffset,  0.6), 0.2),  2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2(-0.6 + yoffset,  0.8), 0.15), 2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2(-1.3 + yoffset,  0.4), 0.1),  2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2(-0.1 + yoffset,  1.4), 0.1),  2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2( 0.35 + yoffset, 1.2), 0.08), 2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2(-0.35 + yoffset, 0.4), 0.08), 2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2( 1.35 + yoffset, 0.4), 0.1),  2.0), result);\n    result = opF(result, vec2(blossom, 2.0));\n    result = opF(result, vec2(stem, 2.0));\n    result = opF(result, vec2(e3, 2.0));\n\n    float eye = sdCircle(mirror(pos), vec2(0.3, 0.1), 0.06);\n    result = opF(vec2(eye, 0.0), result);\n    \n    float lid = sdArc(rot(3.14, mirror(pos)- vec2(0.3, 0.17)), 0.2, 0.17, 1.0);\n    result = opF(vec2(lid, 0.0), result);\n\n    float mouth = sdEllipse(pos, vec2(0.13, 0.05));\n    result = opF(vec2(mouth, 0.0), result);\n\n    return result;\n}\n\n// Returns a color based on an index\nvec3 pallet(float id)\n{\n    vec3 colors[] = vec3[](\n        vec3(0.0, 0.0, 0.0), // 0\n        vec3(1.0, 1.0, 1.0), // 1\n        vec3(0.8, 0.8, 0.4), // 2\n        vec3(0.8, 0.6, 0.6), // 3\n        vec3(0.6, 0.2, 0.2), // 4\n        vec3(214.0, 228.0, 232.0)/255.0, // 5\n        vec3(0x13, 0x24, 0x34)/255.0, // 6\n        vec3(40.0, 75.0, 90.0)/255.0, // 7\n        vec3(21.0, 50.0, 70.0)/255.0 // 8\n    );\n\n    return colors[int(id)];\n}\n\nvec4 layerElders( in vec2 pos )\n{\n    vec2 p[] = vec2[](\n        pos + vec2( 0.0, -0.5),\n        pos + vec2(-2.2, 1.5),\n        pos + vec2(2.8, 3.0) \n        );\n\n    float r[] = float[](0.1, 0.1, -0.05);\n\n    vec2 res = vec2(1e10);\n    for (int i = 0; i < 3; i++)\n    {\n        float id = float(i);\n        float offset = 0.1*sin(id+iTime);\n        vec2 p = rot(r[i]+offset, p[i]);\n        res = opU(elder(id, p), res);\n    }\n \n    float base = 1e10;\n    for (int i = 0; i < 3; i++)\n    {\n        float noise = 0.05*(sin(6.0*pos.y) + cos(6.0*pos.x));\n        float val = p[i].y + p[i].x * p[i].x - 1.0;\n        base = min(base, val+noise);\n    }\n    vec2 body = abs(mod(res.x, 0.35)) > 0.05? vec2(base, 4.0) : vec2(base, 3.0);\n    res = opF(res, body);\n    return vec4(pallet(res.y), 1.0-step(0.0, res.x)); \n}\n\nvec4 layerMoon( in vec2 pos )\n{\n    vec2 moon = vec2(1e10,0.0);\n    for (float i = 0.0; i < 10.0; i++)\n    {\n        float noise = 0.01*sin(6.0*pos.y) + 0.01*cos(6.0*pos.x);\n        float d = sdCircle(pos, vec2(-3.5, 3.5), 0.6 + i + 0.5*sin(i)) + noise;\n        float c = mix(5.0, mod(i,3.0)+6.0, step(1.0, i));\n        moon = opF(moon, vec2(d, c));\n    }\n    return vec4(pallet(moon.y), 1.0);\n}\n\nvec4 motes(in vec2 pos)\n{\n    float cs = 0.9;\n    vec2 cell = floor(pos/cs)*cs;\n    float d = 1e10;\n    float size = 1e10;\n    for (float r = -1.0; r <= 1.0; r += 1.0 )\n    {\n      for (float c = -1.0; c <= 1.0; c += 1.0 )\n      {\n        vec2 offset = cs * vec2(r,c);\n        vec2 bl = cell + offset;\n        vec2 tr = cell + offset + vec2(cs,cs);\n        vec2 vel = noise(bl.x) * vec2(0.05*sin(iTime), 0.15*sin(iTime*noise(bl.y)));\n        vec2 center = mix(bl, tr, vec2(noise2(bl)+vel));\n        float size = clamp(noise(bl.y), 0.3, 1.0)+sin(2.0*noise(bl.y)*iTime+noise(bl.x)*10.0)*0.15;\n        \n        float se = bSuperEllipse(pos, center, 1.0, 0.75, 0.3, size);\n        d = min(d, se);\n      }\n    }\n    return d < 0.0? vec4(pallet(5.0), 0.5) : vec4(0.0);\n}\n\nvec3 scene( in vec2 pos )\n{\n    vec4 background = vec4(0.0);\n    vec4 l1 = layerMoon(pos); \n    vec4 l2 = motes(pos);\n    vec4 l3 = layerElders(pos);\n\n    vec3 color = mix(background.xyz, l1.xyz, l1.w);\n    color = mix(color, l2.xyz, l2.w); \n    color = mix(color, l3.xyz, l3.w); \n    return color;\n}\n\n#define ZERO min(0, iFrame)\n#define AA 4\n// anti-aliasing+gamma correction from: \n// https://www.shadertoy.com/view/Xds3zN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates to 2D world coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        float zPlane = 2.0;\n        vec3 rd = normalize( vec3(p,0.5) );\n        vec3 pos = rd*(zPlane/rd.z);\n        vec3 col = scene(pos.xy);\n\n\t\t// gamma\n        col = pow( clamp(col, 0.0, 1.0), vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4( tot, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]}