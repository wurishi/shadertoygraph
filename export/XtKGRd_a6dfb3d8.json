{"ver":"0.1","info":{"id":"XtKGRd","date":"1477911513","viewed":365,"name":"Checkered Cube ","username":"decrooks","description":"A slice through a 3d checkered cube reveals interesting patterns of triangles and hexagons.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct Material {\n\n    vec3  color;\n};\n    \nstruct MapValue {\n    float \t  signedDistance;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    Material material;\n};\n    \nstruct PointLight {\n    vec3 position;\n    vec3 color;\n};\n    \nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n};\n    \nPointLight  light1;\nPointLight  light2;\nDirectionalLight light3;\n    \nvec3 rayPoint(Ray r,float t) {\n \treturn r.origin +  t*r.direction;\n}\n\nbool checker3D(vec3 p)\n{\n   p = fract(0.5*p);\n   return (p.x>.5==p.y>.5==p.z>.5);\n}\n\n\n//signed differance functions\n//https://iquilezles.org/articles/distfunctions\n\nMapValue cube( vec3 p, float d , Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = length(max(abs(p) -d,0.0));\n  return mv; \n}\n\nMapValue checkerdCube( vec3 p, float d , Material m1,Material m2)\n{\n  Material  m;\n    if(checker3D(6.0*p)){\n        m = m1;\n    }\n    else {\n       m = m2 ;\n    }\n  return cube(p,d, m); \n}\n \nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = p.y - y;\n  return mv;\n}\n\nMapValue tableTop( vec3 p ,float y, Material m1,Material m2)\n{\n \tMaterial  m;\n    //using the slice through a 3d checkerboard to draw a pattern on the table top.\n    float a = sqrt(3.0)/2.0;\n   \tvec3 u = vec3(1.0,-0.5,-0.5);\n   \tvec3 v = vec3(0,a,-a);\n    \n    vec3 n = vec3(0.5);\n   \tfloat scaleFactor = 3.0;\n    vec2 q = p.xz*scaleFactor;\n    vec3 plane = n + q.x*u +q.y*v;\n    \n    \n    if(checker3D(plane)){\n        m = m1;\n    }\n    else {\n       m = m2 ;\n    }\n    \n  return xzPlane( p ,y, m);\n}\n\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n  vec3 a = p - origin;\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = dot(a,normal);\n  return mv;\n}\n\nMapValue sphere(vec3 p, vec3 center, float radius, Material m) {\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = distance(p, center) - radius;\n  return mv;\n}\n\nMapValue addObjects(MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance<d2.signedDistance) {\n    \treturn    d1 ;\n    }\n    else {\n    \treturn d2;\n    }\n}\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }\n}\n//raymarching see e.g:\n//https://www.shadertoy.com/view/Xds3zN\nMapValue map(vec3 p){\n    float t  = 0.25+0.25* sin( 0.5*iTime);\n    vec3 origin = vec3(-t,t,-t);\n    vec3 n = normalize(vec3(-1.0,1.0,-1.0));\n    \n    Material black = Material(vec3(0.0,0.0,0.01));\n    Material white = Material(vec3(1.0,1.0,0.9));\n    Material tableColor = Material(vec3(0.33,0.33,0.31));\n    Material tableColorDark = Material(vec3(0.3,0.3,0.32));\n\n   return addObjects(intersectObjects(checkerdCube(p,0.49,black,white),  plane(p, origin,n,black))  ,tableTop(p,-0.5,tableColor,tableColorDark)  );\n}\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    vec3 normal = vec3(\n                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,\n                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,\n                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\nTrace traceRay(in Ray ray, float maxDistance) {\n    float dist = 0.01;\n    float presicion = 0.002;\n\tvec3 p;\n    MapValue mv;\n    \n    for(int i=0; i<64; i++){\n    \tp = rayPoint(ray,dist);\n       \tmv = map(p);\n         dist += 0.5*mv.signedDistance;\n        if(mv.signedDistance < presicion || dist>maxDistance) break;\n       \n    }\n    \n    return Trace(dist,p,mv.material);\n}\n\nfloat castShadow(in Ray ray, float dist){\n    Trace trace = traceRay(ray,dist);\n    float maxDist = min(1.0,dist);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ \n\tvec3 v = normalize(lookAtCenter -viewPoint);\n    \n    vec3 n1 = cross(v,vec3(0.0,1.0,0.0));\n    vec3 n2 = cross(n1,v);  \n        \n    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);\n                                    \n    Ray r;\n                    \n    r.origin = viewPoint;\n   \tr.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return r;\n}\n\nvoid animateLights(){\n  \tfloat  time = iTime;\n  \tlight1 = PointLight(vec3(-1.2+0.25*cos(time),2.0,-1.0+0.0*sin(time)), vec3(0.7));\n  \tlight2 = PointLight(vec3(-0.8 + 0.23*cos(1.25*time),1.0+0.25*sin(1.25*time),-1.7),vec3(0.6)); \n    light3 = DirectionalLight(normalize(vec3(-1.0,1.0,-1.0)),vec3(0.3));\n} \n\nvec3 pointLighting(in Trace trace, vec3 normal, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n    \n  \tfloat lambertian = max(dot(lightDir,normal), 0.0);\n  \t\n\t\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n\tvec3 color = shadow*attenuation* lambertian * trace.material.color * light.color;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, vec3 normal, DirectionalLight light){\n\n  \tfloat lambertian = max(dot(light.direction,normal), 0.0);\n\n\n    float shadow = castShadow(Ray(trace.p,light.direction),1.0);\n  \n    vec3 color = shadow * lambertian * trace.material.color * light.color ;\n    return  color;\n}\n\nvec3 lighting(in Trace trace, vec3 normal){\n    vec3 color = vec3(0.01,0.01,0.1);//ambient color\n        \n\tcolor += pointLighting(trace, normal,light1);\n\tcolor += pointLighting(trace, normal,light2) ;\n\tcolor += directionalLighting(trace, normal,light3);\n    \n    return color;\n}\n\nfloat rayDistance(Ray r,vec3 p){\n    vec3 v = r.origin - p;\n    return length(v - dot(v,r.direction)*r.direction);\n}\n\nvec3 render(vec2 p){\n    vec3 viewpoint = vec3(-1.0,1.3,-2.0);\n    \n    vec3 lookAt = vec3(0.0,-0.1,0.0);\n    \n  \tRay ray = cameraRay(viewpoint,lookAt,p,2.5);\n   \tTrace trace = traceRay(ray,7.0);\n    \n\tvec3 normal = calculateNormal(trace.p);\n    \n   \treturn lighting(trace,normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \tanimateLights();\n    \n   \tvec3 colorLinear =  render(p);\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}","name":"Image","description":"","type":"image"}]}