{"ver":"0.1","info":{"id":"ft33WB","date":"1636639407","viewed":112,"name":"Erratic eye","username":"Krafpy","description":"A moving eye.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","sdf","fbm","eye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAY_STEPS 32.\n#define PI 3.14159265\n#define TWO_PI 6.2831853\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat noise(vec2 p){\n    return texture(iChannel0, p).x;\n}\n\nfloat fbm(vec2 p){\n    float f = 0.5 * noise(p); p *= 2.;\n    f += 0.25 * noise(p); p *= 2.;\n    f += 0.125 * noise(p);\n    return f;\n}\n\nfloat rand(float x) {\n    return fract(sin(x)*326807.6);\n}\n\nfloat smootherstep(float a, float b, float x){\n    float t = clamp((x - a) / (b - a), 0.0, 1.0);\n    return t*t*t*(t*(6.*t-15.)+10.);\n}\n\nfloat sdfSphere(vec3 p, vec3 c, float r){\n    return length(p - c) - r;\n}\n\n\n\nconst vec3 eyePos = vec3(0.5, 0., 0.);\n\n\nvec2 map(vec3 p){\n    float d = sdfSphere(p, eyePos, 1.);\n    return vec2(d, 1.);\n}\n\n\n\nfloat smoothTimeStep(float v, float offset, float start){\n    float t = v*(iTime+offset);\n    float r1 = rand(floor(t));\n    float r2 = rand(floor(t+1.));\n    float f = smootherstep(start, 1., fract(t));\n    float a = 2.*mix(r1, r2, f) - 1.;\n    return a;\n}\n\nvec3 eyeColor(vec3 p){\n    p.xz *= rot(0.5*smoothTimeStep(1., 0., 0.8));\n    p.yz *= rot(0.5*smoothTimeStep(1., 10., 0.8));\n\n    float a = acos(-p.z);\n    float b = atan(p.y, p.x);\n    \n    float f = 0.;\n    \n    vec3 icol = vec3(1., 1., 0.92);\n    \n    f = smoothstep(0.08, 0.5, 0.52*a/PI);\n    vec3 bcol = mix(icol, vec3(1.,0.,0.), f);\n    \n    f = fbm(0.07*vec2(a, b));\n    f = step(0.5, f)*(1.-smoothstep(0.5, 0.51, f)) + step(f, 0.5)*(1.-smoothstep(0.5, 0.49, f));\n    f = smoothstep(0.05, 0.5, 0.5*a/PI) * f;\n    bcol = mix(bcol, vec3(1.,0.,0.), f);\n    \n    f = fbm(vec2(0.1*a, 0.1*b));\n    bcol = mix(bcol, icol, 0.6*f);\n    \n    vec3 col = bcol;\n    \n    if(a <= 0.5){\n        col = vec3(0.3, 0.4, 0.4);\n        \n        // background color\n        f = fbm(0.15*p.xy);\n        col = mix(col, vec3(0.7, 0.4, 0.3), f*f);\n        \n        // pupil radius variations\n        float dr = 0.07*smoothTimeStep(0.15, 55., 0.5);\n        \n        // center highlight\n        f = 1. - smoothstep(0.1+dr, 0.35+dr, a);\n        col = mix(col, 0.8*vec3(0.8, 0.55, 0.3), f);\n        \n        // add shuffle to lines\n        float tb = b;\n        tb = b + 0.5*fbm(0.05*p.xy);\n        \n        // background stripes\n        f = fbm(vec2(0.2*a, 1.1*tb));\n        col = mix(col, vec3(0.55), f*sqrt(f));\n        \n        // more shuffle\n        tb = b + (0.5+dr)*fbm(0.05*p.xy);\n          \n        // bright stripes\n        f = fbm(vec2(0.2*(a-dr), 0.3*tb));\n        col = mix(col, vec3(0.9), f*f);\n        \n        // darker spots\n        f = fbm(vec2(0.12*(a-dr), 0.1*tb));\n        f = smoothstep(0.45, 0.85, f);\n        col = mix(col, vec3(0.3, 0.1, 0.), 0.5*f);\n        //col *= 1.-0.5*f;\n        \n        // darker outline\n        f = smoothstep(0.3, 0.5, a);\n        col *= 1.-0.5*f;\n        \n        // pupil\n        f = smoothstep(0.1+dr, 0.17+dr, a);\n        col *= f;\n        \n        // smooth outline blending\n        //col = mix(col, bcol, smoothstep(0.45, 0.5, a));\n    }\n    f = smoothstep(0.48, 0.5, a) * (1. - smoothstep(0.5, 0.6, a));\n    col = mix(col, 0.45*vec3(0.61, 0.6, 0.58), f);\n    \n    return col;\n}\n\nvec3 getColor(vec3 p, float i, float id){\n    if(id == 1.){\n        p = normalize(p-eyePos);\n        return eyeColor(p);\n    }\n    \n    return vec3(0.);\n}\n\nvec3 getNormal(vec3 p){\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0.);\n    return normalize( vec3(map(p+h.xyy).x - map(p-h.xyy).x,\n                           map(p+h.yxy).x - map(p-h.yxy).x,\n                           map(p+h.yyx).x - map(p-h.yyx).x ) );\n}\n\nvoid applyLighting(out vec3 col, float id, vec3 rd, vec3 n){\n    vec3 sunDir = normalize(vec3(1., 0.5, -1));\n    \n    if(id == 1.){\n        float ks = 2.;\n        float a = 50.;\n        vec3 ref = reflect(sunDir, n);\n        col *= 1. + ks*pow(max(0., dot(ref, rd)), a);\n        col = clamp(col, 0., 1.);\n    }\n}\n\n\nvec3 raymarch(vec3 ro, vec3 rd){\n    float eps = 0.001;\n    \n    float t = 0.;\n    float i = 0.;\n    for(; i < RAY_STEPS; ++i){\n        vec2 it = map(ro + rd * t);\n        if(it.x < eps){\n            return vec3(t, i, it.y);\n        }\n        t += it.x;\n    }\n    return vec3(-1., i, 0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 ro = vec3(0., 0., -3.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float rv = 0.;\n    ro.xz *= rot(rv*iTime);\n    rd.xz *= rot(rv*iTime);\n    \n    \n    vec3 col = vec3(0.);\n    \n    \n    vec3 itsc = raymarch(ro, rd);\n    float t = itsc.x, i = itsc.y, id = itsc.z;\n    if(t > 0.){\n        vec3 p = ro + rd * t;\n        col = getColor(p, i, id);\n        vec3 n = getNormal(p);\n        applyLighting(col, id, rd, n);\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}