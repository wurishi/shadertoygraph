{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define MAX_STEPS 256\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n#define PI 3.14159265359\n\n// Light bending parameters\n#define SCHWARZSCHILD_RADIUS 1.0\n#define LIGHT_BEND_STRENGTH 2.0\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nvec3 spaceDistortion(vec3 p) {\n    float r = length(p);\n    float distortionVar = 1.0 + 0.2 * sin(iTime * 2.0);\n    float bendFactor = SCHWARZSCHILD_RADIUS / (r * r) * distortionVar;\n    vec3 distortion = normalize(p) * bendFactor;\n    return p + distortion * LIGHT_BEND_STRENGTH;\n}\n\nfloat diskDensity(vec3 p) {\n    float r = length(p.xz);\n    if (r < 2.0 || r > 10.0) return 0.0;\n    \n    //height oscillation\n    float heightWave = sin(r * 2.0 - iTime * 3.0) * 0.2;\n    float heightFalloff = exp(-abs(p.y - heightWave) * 20.0);\n    \n    // Radial density with time variation\n    float radialDensity = exp(-(r - 4.0 - sin(iTime) * 0.5) * 0.2);\n    \n    // Multiple animated spiral arms\n    float angle = atan(p.z, p.x);\n    float spiral1 = sin(3.0 * angle + r * 0.5 - iTime * 2.0);\n    float spiral2 = sin(2.0 * angle - r * 0.3 - iTime * 1.5);\n    float spiral = 0.5 + 0.25 * (spiral1 + spiral2);\n    \n    //turbulence\n    float turb = sin(r * 4.0 + angle * 8.0 - iTime * 4.0) * 0.2;\n    \n    return heightFalloff * radialDensity * (spiral + turb + 0.5);\n}\n\nvec3 diskColor(vec3 p) {\n    float r = length(p.xz);\n    \n    //temperature fluctuations\n    float tempVar = sin(r * 2.0 - iTime * 3.0) * 0.2;\n    float temp = mix(1.8, 0.5, smoothstep(2.0, 10.0, r)) + tempVar;\n    \n    // Pulsing color intensity\n    float pulse = 1.0 + 0.2 * sin(iTime * 5.0 + r);\n    \n    vec3 color = vec3(1.0);\n    color.r = pow(temp, 0.5) * pulse;\n    color.g = pow(temp, 2.0) * pulse;\n    color.b = pow(temp, 4.0) * pulse;\n    \n    return color;\n}\n\nvec4 rayMarchVolume(vec3 ro, vec3 rd) {\n    vec4 accum = vec4(0.0);\n    float t = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; i++) {\n        vec3 p = ro + rd * t;\n        \n        // Apply space distortion\n        p = spaceDistortion(p);\n        \n        float density = diskDensity(p);\n        if(density > 0.0) {\n            vec3 color = diskColor(p);\n            \n            // Doppler shift based on orbital velocity\n            float orbitalSpeed = sqrt(1.0 / length(p.xz));\n            vec3 orbitalVel = normalize(vec3(-p.z, 0.0, p.x)) * orbitalSpeed;\n            float doppler = 1.0 - dot(rd, orbitalVel) * 0.3;\n            color *= vec3(doppler);\n            \n            // Accumulate color and density\n            vec4 voxel = vec4(color * density, density);\n            voxel.rgb *= voxel.a;\n            accum += voxel * (1.0 - accum.a);\n            \n            if(accum.a > 0.99) break;\n        }\n        \n        t += max(0.1, t * 0.02);\n    }\n    \n    return accum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //camera\n    float time = iTime * 0.2;\n    float camRadius = 20.0 + sin(time * 0.5) * 2.0; // Varying radius\n    vec3 ro = vec3(\n        camRadius * sin(time),\n        12.0 * sin(time * 0.5),\n        camRadius * cos(time)\n    );\n    \n    //look-at point\n    vec3 target = vec3(\n        sin(time * 0.7) * 0.5,\n        sin(time * 0.4) * 0.5,\n        cos(time * 0.7) * 0.5\n    );\n    \n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    //FOV\n    float fov = (60.0 + sin(time) * 5.0) * PI / 180.0;\n    vec3 rd = normalize(forward + right * uv.x * tan(fov/2.0) + up * uv.y * tan(fov/2.0));\n    \n    // Ray march through the scene\n    vec4 volume = rayMarchVolume(ro, rd);\n    \n    //stars twinkle\n    float starTime = iTime * 0.5;\n    float stars = pow(fract(sin(dot(rd.xy * 100.0 + sin(starTime), vec2(12.9898, 78.233))) * 43758.5453), 20.0);\n    vec3 background = vec3(stars) * (0.3 + 0.1 * sin(starTime));\n    \n    //photon ring\n    float dist = length(uv);\n    float blackHole = smoothstep(0.15, 0.1, dist);\n    float ringPulse = 1.0 + 0.2 * sin(iTime * 10.0);\n    float ring = smoothstep(0.02 * ringPulse, 0.0, abs(dist - 0.12));\n    \n    // Combine everything\n    vec3 color = background * (1.0 - volume.a) + volume.rgb;\n    color = mix(color, vec3(0.0), blackHole);\n    color += vec3(0.3, 0.6, 1.0) * ring * ringPulse;\n    \n    //tone mapping intensity\n    float exposure = 1.0 + 0.2 * sin(iTime);\n    color = color / (exposure + color);\n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XXdyRM","date":"1734878719","viewed":439,"name":"A Simple Singularity ","username":"singularity23","description":"Since my handle/artist name is Singularity23. May as well make some light bend.\n\nhttps://cineshader.com/view/XXdyRM","likes":15,"published":3,"flags":0,"usePreview":0,"tags":["astrophysics","cineshader"],"hasliked":0,"parentid":"","parentname":""}}