{"ver":"0.1","info":{"id":"sldSzr","date":"1638657915","viewed":345,"name":"Zen Garden Maker","username":"coposuke","description":"Jump Flooding Algorithm\n\nMouse Click : Draw land.\nR Key : Reset land.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["jump","zen","japanese","flooding","jfa","garden","karesansui"],"hasliked":0,"parentid":"7ttSzr","parentname":"Jump Flooding in 2Frame"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Zen Garden Maker\n//\n\nmat2x2 rotation(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\n\nfloat getGardenDistance(vec2 uv)\n{\n    vec2 seed = texture(iChannel0, uv).zw;\n    float dist = distance(uv, seed);\n    dist = step(1e-3, dist) * dist;\n    dist += step(seed.x + seed.y, 1e-3);\n    return dist;\n}\n\nfloat getHeight(vec2 uv, float stripe, float texDist)\n{\n    vec2 range = smoothstep(0.0, 0.15, uv) * smoothstep(1.0, 0.85, uv);\n    float height = (floor(texture(iChannel1, uv).r) * 1e-4) * (range.x * range.y);\n    \n    float radius = smoothstep(0.15, 0.14, texDist);\n    float wave = sin(texDist * TAU * 50.0) + 1.0;\n    float bg = sin(stripe * TAU * 50.0) + 1.0;\n    wave = mix(bg, wave, radius) * 0.003;\n    height = mix(wave, height + 0.005, step(1e-4, height));\n    \n    return height;\n}\n\n// iq's Rounded Box - exact\nfloat sdBox(vec3 pos, vec3 size)\n{\n    vec3 posAbs = abs(pos) - size;\n    return length(max(posAbs, 0.0)) + min(0.0, max(posAbs.x, max(posAbs.y, posAbs.z)));\n}\n\nvec4 map(in vec3 rayPos) // return vec4(type, dist, height, jfa_dist)\n{\n    float d = 0.0;\n    vec2 dist = vec2(0.0);\n\n    // plane\n    dist.x = 1.0;\n    dist.y = dot(rayPos, vec3(0,1,0));\n    dist.y = max(dist.y, sdBox(rayPos - vec3(0, 0.59, 0), vec3(0.6)));\n    \n    // wave & lock\n    vec2 uv = rayPos.xz + 0.5;\n    float texDist = getGardenDistance(uv);\n    float height = getHeight(uv, rayPos.z, texDist); // land\n    dist.y -= height;\n    \n    // fuchi\n    vec3 boxPos = rayPos;\n    boxPos.xz = abs(boxPos.xz);\n    d = sdBox(boxPos - vec3(0, 0.03, 0), vec3(0.55, 0.005, 0.55));\n    d = max(d, -sdBox(boxPos, vec3(0.5)));\n    dist = d < dist.y ? vec2(2.0, d) : dist;\n\n    // water\n    d = abs(dot(rayPos - vec3(0, 0.03, 0), vec3(0,1,0)));\n    d = max(d, -sdBox(boxPos, vec3(0.54)));\n    dist = d < dist.y ? vec2(3.0, d) : dist;\n    \n    return vec4(dist, height, texDist);\n}\n\nfloat map_water(in vec3 rayPos, float angle)\n{\n    float d = 0.0;\n    d = sdBox(vec3(rayPos.xz, 0.0), vec3(0.55));\n    d -= (sin(angle * TAU * 5.0) * 0.5 + 0.5) * 0.01;\n    \n    float wave = 0.0;\n    wave = sin(d * TAU * 100.0 - iTime * 10.0) * 3e-4 - 1e-3;\n    wave *= smoothstep(0.05, 0.0, d);\n    wave += fbm(rayPos.xz * -5.0 + iTime * 0.1) * 0.01;\n    wave += fbm(rayPos.xz *  5.0 + iTime * 0.1) * 0.01;\n    \n    d = abs(dot(rayPos, vec3(0,1,0)));\n    return d + wave;\n}\n\nstruct Result\n{\n    float type;\n    float dist;\n    float angle;\n    vec3 position;\n    vec3 normal;\n    vec3 dir;\n};\n\nResult raymarch(in vec3 cameraPos, in vec3 cameraDir, int iteration)\n{\n    float dist = 1e-3;\n    vec3 rayPos = cameraPos;\n    Result result = Result(0.0, 0.0, 0.0, vec3(0), vec3(0), cameraDir);\n    \n    vec3 prevPos = cameraPos;\n    float prevDist = dist;\n    \n    for(int i = 0; i < iteration; ++i)\n    {\n        vec4 m = map(rayPos);\n        float d = min(m.y, m.w + 1e-3);\n\n        // slow area\n        if(m.w < 1e-2)\n            d = min(m.y * 3e-2, rayPos.y);\n        \n        // terrain height\n        if(rayPos.y - m.z < 0.0)\n        {\n            vec2 uv0 = prevPos.xz + 0.5;\n            vec2 uv1 = rayPos.xz + 0.5;\n            float prevHeight = floor(texture(iChannel1, uv0).r) * 1e-4 - rayPos.y;\n            float nextHeight = floor(texture(iChannel1, uv1).r) * 1e-4;\n            float weight = nextHeight / (nextHeight + abs(prevHeight));\n            rayPos = mix(prevPos, rayPos, weight);\n            m.y = 0.0;\n        }\n        else\n        {\n            rayPos += cameraDir * d;\n            dist += d;\n        }\n        \n        if(m.y < 1e-3)\n        {\n            result.type = m.x;\n            result.dist = dist;\n            result.position = rayPos;\n            result.angle = (atan(rayPos.z, rayPos.x) + PI) / TAU;\n\n            vec2 epsilon = vec2(0.0, 3e-3);\n            if(result.type == 3.0) // if water\n            {\n                result.normal = normalize(vec3(\n                    map_water(rayPos + epsilon.yxx, result.angle) - map_water(rayPos - epsilon.yxx, result.angle),\n                    map_water(rayPos + epsilon.xyx, result.angle) - map_water(rayPos - epsilon.xyx, result.angle),\n                    map_water(rayPos + epsilon.xxy, result.angle) - map_water(rayPos - epsilon.xxy, result.angle)\n                ));\n            }\n            else\n            {\n                result.normal = normalize(vec3(\n                    map(rayPos + epsilon.yxx).y - map(rayPos - epsilon.yxx).y,\n                    map(rayPos + epsilon.xyx).y - map(rayPos - epsilon.xyx).y,\n                    map(rayPos + epsilon.xxy).y - map(rayPos - epsilon.xxy).y\n                ));\n            }\n            return result;\n        }\n        \n        if((dist - prevDist) > 1.0)\n            return result;\n        \n        prevPos = rayPos;\n        prevDist = dist;\n    }\n    \n    return result;\n}\n\nResult raymarch_underwater(in vec3 cameraPos, in vec3 cameraDir)\n{\n    float dist = 1e-3;\n    vec3 rayPos = cameraPos;\n    Result result = Result(0.0, 0.0, 0.0, vec3(0), vec3(0), cameraDir);\n    \n    float prevDist = dist;\n    vec3 boxSize = vec3(0.551);\n    \n    for(int i = 0; i < 100; ++i)\n    {\n        float d = sdBox(rayPos - vec3(0, 0.5, 0), boxSize);\n\n        rayPos += cameraDir * d;\n        dist += d;\n            \n        if(d < 1e-3)\n        {\n            result.type = 2.0;\n            result.dist = dist;\n            result.position = rayPos;\n            vec2 epsilon = vec2(0.0, 1e-3);\n            result.normal = normalize(vec3(\n                sdBox(rayPos + epsilon.yxx, boxSize) - sdBox(rayPos - epsilon.yxx, boxSize),\n                sdBox(rayPos + epsilon.xyx, boxSize) - sdBox(rayPos - epsilon.xyx, boxSize),\n                sdBox(rayPos + epsilon.xxy, boxSize) - sdBox(rayPos - epsilon.xxy, boxSize)\n            ));\n            return result;\n        }\n        \n        if((dist - prevDist) > 1.0)\n            return result;\n        \n        prevDist = dist;\n    }\n    \n    return result;\n}\n\nfloat raymarch_ao(in vec3 rayPos)\n{\n    float attenutation = 1.0;\n    float dist = 0.0;\n    vec3 pos = rayPos;\n    \n    // distance map\n    for(int i = 0; i < 3; ++i)\n    {\n        dist += 1e-2;\n        pos.y += dist;\n        attenutation -= min(1.0 - min(map(pos).y / dist, 1.0), 1.0) * 0.5;\n    }\n    \n    // terrain map\n    pos.y = rayPos.y;\n    float angle = 0.0;\n    float attenutation2 = 1.0;\n    \n    vec2 uv = rayPos.xz + 0.5;\n    float texDist = getGardenDistance(uv);\n    float base = getHeight(uv, rayPos.z, texDist);\n\n    for(int i = 0; i < 6; ++i)\n    {\n        angle += TAU / 6.0;\n        pos.xz = rayPos.xz + vec2(0, 1e-2) * rotate(angle);\n        \n        uv = pos.xz + 0.5;\n        texDist = getGardenDistance(uv);\n        float h = getHeight(uv, pos.z, texDist);\n        \n        attenutation2 -= min((h - base) * 20.0, 1.0);\n    }\n    \n    return clamp(min(attenutation, attenutation2), 0.0, 1.0);\n}\n\nvec3 fresnel(vec3 f0, float u)\n{\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - u, 5.0);\n}\n\nvec3 materialize(in Result result, in Result reflection, in Result shadow, in Result underwater, in vec3 lightDir)\n{\n    vec3 color = vec3(0.0);\n    vec3 refColor = texture(iChannel3, reflection.dir).rgb;\n    \n    vec2 uv = result.position.xz + 0.5;\n    vec2 seed = texture(iChannel0, uv).zw;\n    vec2 value = texture(iChannel1, uv).xy;\n    float n = noise(uv * 1000.0);\n    \n    float dist = distance(uv, fract(seed));\n    dist = step(1e-3, dist) * dist;\n    dist += step(seed.x + seed.y, 1e-3); // for start\n\n    // karesansui\n    float range = smoothstep(0.15, 0.14, dist);\n    float bg = mix(n, n, range);\n    color = float(result.type == 1.0) * vec3(float(0.0 < result.type) * bg);\n    \n    // koke & lock\n    vec3 grass = (n * 0.5 + 0.5) * vec3(0.5, 0.75, 0.4);\n    vec3 soil = (n * 0.5 + 0.5) * vec3(0.37, 0.3, 0.25);\n    vec3 lock = vec3(0.0);\n    lock += texture(iChannel2, result.position.zy * sign(result.normal.x) * 3.0).rgb * pow(abs(dot(result.normal, vec3(1,0,0))), 2.0);\n    lock += texture(iChannel2, result.position.xz * sign(result.normal.y) * 3.0).rgb * pow(abs(dot(result.normal, vec3(0,1,0))), 2.0);\n    lock += texture(iChannel2, result.position.xy * sign(result.normal.z) * 3.0).rgb * pow(abs(dot(result.normal, vec3(0,0,1))), 2.0);\n    \n    float landRatio = value.r * 0.01;\n    vec3 land = mix(soil, mix(grass, lock, smoothstep(1.0, 2.0, landRatio)), smoothstep(0.0, 0.2, landRatio));\n    color = float(result.type == 1.0) * mix(color, land, step(dist, 0.0));\n\n    // fuchi\n    color += float(result.type == 2.0) * (pow(texture(iChannel2, result.position.xz).rgb, vec3(3.0)));\n\n    // water\n    vec3 f = vec3(1) - fresnel(vec3(0.2), dot(vec3(0,1,0), -result.dir));\n    vec3 waterBgPos = underwater.dir * (-0.07 / underwater.dir.y);\n    vec3 waterBg = texture(iChannel2, result.position.xz + waterBgPos.xz).rgb;\n    vec2 waterBg2UV = vec2(underwater.position.x + underwater.position.z, underwater.position.y);\n    vec3 waterBg2 = pow(texture(iChannel2, waterBg2UV).rgb, vec3(3.0));\n    waterBg = mix(waterBg, waterBg2, float(underwater.type == 2.0));\n    color += float(result.type == 3.0) * ((1.0 - f) * refColor + f * waterBg);\n\n    // shade\n    color *= dot(result.normal, lightDir) * 0.4 + 0.6;\n    \n    // shadow\n    float attenutation = 0.0;\n    attenutation = max(float(shadow.type == 0.0), 0.6);\n    attenutation = min(attenutation, mix(raymarch_ao(result.position) * 0.4 + 0.6, 1.0, float(result.type == 3.0)));\n    color *= attenutation;\n    \n    // ambient\n    color += float(result.type == 2.0) * refColor * 0.2;\n    color += float(result.type == 1.0) * refColor * 0.1;\n    color += min(1.0, float(result.type == 0.0) + smoothstep(1.0, 4.0, result.dist)) * (refColor * 0.9 + 0.1);\n    \n    // debug\n    //float grad = dist * TAU * 10.0 - iTime * 10.0;\n    //color = mix(vec3(0), cos(vec3(0,2,4) + grad) * 0.15 + 0.8, step(0.001, dist));\n    //color = mix(color, vec3(landRatio * 0.1), step(dist, 0.0));\n    //color = result.normal;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    Camera camera = getCamera(uv, iTime);\n    vec3 lightDir = normalize(vec3(1.0, 0.5, 0.5));\n\n    Result result = raymarch(camera.pos, camera.dir, 2000);\n    Result reflection = raymarch(result.position - camera.dir * 1e-3, reflect(camera.dir, result.normal), 100);\n    Result shadow = raymarch(result.position - camera.dir * 1e-2, lightDir, 2000);\n    Result underwater = Result(0.0, 0.0, 0.0, vec3(0), vec3(0), camera.dir);\n    \n    if(result.type == 3.0)\n        underwater = raymarch_underwater(result.position, refract(camera.dir, result.normal, 1.0 / 1.33));\n    \n    fragColor.rgb = materialize(result, reflection, shadow, underwater, lightDir);\n    \n    // debug\n    //fragColor.rgb += vec3(texture(iChannel1, fragCoord / iResolution.xy).rg, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define saturate(x) clamp(0.0, 1.0, x)\nconst float PI = 3.14159256358979;\nconst float TAU = PI * 2.0;\n\n\nfloat hash(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nconst int NUM_NOISE_OCTAVES = 5;\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//-----------------------------------\n\nmat2x2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2x2(c, -s, s, c);\n}\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nCamera getCamera(in vec2 uv, in float iTime)\n{\n    Camera camera;\n    camera.pos = vec3(0.0, 0.3, -1.0);\n    camera.dir = normalize(vec3(uv, 2.0));\n\n    camera.pos.xz *= rotate(iTime * 0.2);\n    camera.dir.yz *= rotate(0.5 + sin(iTime * 0.5) * 0.025);\n    camera.dir.xz *= rotate(iTime * 0.2);\n    \n    return camera;\n}\n\n//-----------------------------------\n\nconst float STEP = 7.0 + 2.0;\nconst float ITER = 3.0;\n\nvec3 jumpFlooding_Compare(vec2 seed, vec2 self, vec2 currentSeed, float currentDist)\n{\n    float dist = distance(seed, self);\n\n    bool isEmpty = 0.0 == seed.x + seed.y;\n    bool isFarther = currentDist < dist;\n    \n    if(isEmpty || isFarther)\n        return vec3(currentSeed, currentDist);\n    else\n        return vec3(seed, dist);\n}\n\nvec4 jumpFlooding(in vec2 fragCoord, sampler2D channel, vec2 resolution, float stepLength)\n{\n    vec2 self = fragCoord;\n    float dist = 1e+5;\n    vec4 color = vec4(0);\n\n    for(float x = -ITER; x <= ITER ; x++)\n    {\n        for(float y = -ITER; y <= ITER ; y++)\n        {\n            vec2 neighbor = self + vec2(x, y) * stepLength;\n            vec4 pointPosition = texture(channel, (neighbor + 0.0) / resolution.xy);\n            float pointDist = distance(pointPosition.xy, fragCoord / resolution.xy);\n            bool isEmpty = 0.0 == pointPosition.x + pointPosition.y;\n\n            if (isEmpty)\n                continue;\n\n            if(pointDist < dist)\n            {\n                dist = pointDist;\n                color = pointPosition;\n            }\n        }\n    }\n    \n    color.b = dist;\n    return color;\n}\n\nvec3 jumpFlooding_XY(in vec2 fragCoord, sampler2D channel, vec2 resolution, float stepLength)\n{\n    vec3 data = vec3(0.0, 0.0, 1e+5);\n    vec2 self = fragCoord / resolution.xy;\n\n    for(float x = -ITER; x <= ITER; x++)\n    {\n        for(float y = -ITER; y <= ITER; y++)\n        {\n            vec2 neighbor = fragCoord + vec2(x, y) * stepLength;\n            vec4 pointPosition = fract(texture(channel, (neighbor + 0.0) / resolution.xy));\n            data = jumpFlooding_Compare(pointPosition.xy, self, data.xy, data.z); // XY(x,y)\n        }\n    }\n\n    return data;\n}\n\nvec3 jumpFlooding_ZW(in vec2 fragCoord, sampler2D channel, vec2 resolution, float stepLength)\n{\n    vec3 data = vec3(0.0, 0.0, 1e+5);\n    vec2 self = fragCoord / resolution.xy;\n\n    for(float x = -ITER; x <= ITER; x++)\n    {\n        for(float y = -ITER; y <= ITER; y++)\n        {\n            vec2 neighbor = fragCoord + vec2(x, y) * stepLength;\n            vec4 pointPosition = texture(channel, (neighbor + 0.0) / resolution.xy);\n            data = jumpFlooding_Compare(pointPosition.zw, self, data.xy, data.z); // ZW(x,y)\n        }\n    }\n\n    return data;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Jump Flooding : init A.xy\n//                 D.xy -> A.zw\n\nvec4 initialize_neko(in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv = uv * 0.5 + 0.5;\n    uv.x = clamp(uv.x / 6.0, 0.0, 1.0 / 6.0 - 1e-2);\n    \n    const float NEKO_FRAME = 6.0;\n    float neko = 40.0/ 256.0;\n    uv.x += mod(floor(float(iFrame) / NEKO_FRAME), 6.0) * neko;\n    \n    vec4 color = texture(iChannel3, uv);\n    color = vec4(step(dot(color, vec4(0,0,1,0)), 0.4));\n    color.xy = color.xy * vec2(fragCoord / iResolution.xy) + color.xy * vec2(1.0);\n    return color;\n}\n\nvec4 initialize(in vec2 fragCoord)\n{\n    vec4 color = vec4(0);\n    color = texture(iChannel1, fragCoord / iResolution.xy);\n    \n    // Input Keyboard\n    float RKey = texelFetch(iChannel2, ivec2(82, 0), 0).x; // R key\n    if(0.0 < RKey)\n    {\n        color = vec4(0.0);\n    }\n    \n    // Input Mouse\n    if(0.0 < iMouse.z)\n    {\n        vec2 uv = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n        Camera camera = getCamera(uv, iTime);\n        float height = camera.pos.y;\n        vec2 pos = camera.pos.xz + camera.dir.xz * (height / abs(camera.dir.y));\n        \n        uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y * 0.5;\n        uv.x *= iResolution.y / iResolution.x;\n    \n        float mouseDist = distance(iMouse.xy, fragCoord + fbm(fragCoord * 0.01) * 100.0 - 50.0);\n        mouseDist = smoothstep(0.0, 0.1, distance(pos, uv + fbm(fragCoord * 0.01) * 0.1 - 0.05)) * 100.0;\n        color.rg += vec2(step(mouseDist, 40.0) * clamp(38.0 - mouseDist, 1e-5, 10.0));\n    }\n\n    vec2 mask = vec2(step(1e-5, color.r + color.g));\n    color.xy = mask * vec2(fragCoord / iResolution.xy) + floor(color.xy);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0);\n\n    if(iFrame <= 20)\n        color.xy = initialize_neko(fragCoord).xy;\n    else\n        color.xy = initialize(fragCoord).xy;\n\n    float stepLength = pow(2.0, STEP - 4.0);\n    color.zw = jumpFlooding_XY(fragCoord, iChannel0, iResolution.xy, stepLength).xy;\n    \n    fragColor = color;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Jump Flooding : A.xy -> B.xy\n//                 A.zw -> B.zw\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0);\n    float stepLength = 0.0;\n    \n    stepLength = pow(2.0, STEP - 1.0);\n    color.xy = jumpFlooding_XY(fragCoord, iChannel0, iResolution.xy, stepLength).xy;\n\n    stepLength = pow(2.0, STEP - 5.0);\n    color.zw = jumpFlooding_ZW(fragCoord, iChannel0, iResolution.xy, stepLength).xy;\n    \n    fragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Jump Flooding : B.xy -> C.xy\n//                 B.zw -> C.zw\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0);\n    float stepLength = 0.0;\n    \n    stepLength = pow(2.0, STEP - 2.0);\n    color.xy = jumpFlooding_XY(fragCoord, iChannel0, iResolution.xy, stepLength).xy;\n\n    stepLength = pow(2.0, STEP - 6.0);\n    color.zw = jumpFlooding_ZW(fragCoord, iChannel0, iResolution.xy, stepLength).xy;\n    \n    fragColor = color;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Jump Flooding : C.xy -> D.xy\n//                 C.zw -> D.zw\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0);\n    float stepLength = 0.0;\n    \n    stepLength = pow(2.0, STEP - 3.0);\n    color.xy = jumpFlooding_XY(fragCoord, iChannel0, iResolution.xy, stepLength).xy;\n\n    stepLength = pow(2.0, STEP - 7.0);\n    color.zw = jumpFlooding_ZW(fragCoord, iChannel0, iResolution.xy, stepLength).xy;\n    \n    fragColor = color;\n}\n","name":"Buffer D","description":"","type":"buffer"}]}