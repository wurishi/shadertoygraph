{"ver":"0.1","info":{"id":"XXjyRc","date":"1727512716","viewed":22,"name":"240928_path_tracing","username":"okdalto","description":"240928_path_tracing\nit's normal to see nothing before 3 seconds","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    // convert unbounded HDR color range to SDR color range\n    col = ACESFilm(col);\n\n    // convert from linear to sRGB for display\n    col = LinearToSRGB(col);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return step(f, vec3(value));\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define lightPos vec3(cos(0.2), -2., sin(0.2)) * 0.9\n#define lightRadius 1.0\n\nfloat sdfSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n\nfloat sdf(vec3 p){\n    float d1 = sdfSphere(p + vec3(0.5, 0.2, 0.3), 0.3);\n    float d2 = sdfSphere(p, 0.3);\n    float d3 = sdfSphere(p + lightPos, lightRadius);\n    float d4 = sdPlane(p, vec3(0, 1, 0), 0.2);\n    float d = min(d1, d2);\n    d = min(d, d3);\n    d = min(d, d4);\n    return d;\n}\n\nvec3 getNorm(vec3 p){\n    vec2 ep = vec2(0.0001, 0.0);\n    return normalize(vec3(\n        sdf(p + ep.xyy) - sdf(p - ep.xyy),\n        sdf(p + ep.yxy) - sdf(p - ep.yxy),\n        sdf(p + ep.yyx) - sdf(p - ep.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    // Normalized pixel coordinates (from 0 to 1)\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    \n    \n    vec3 camPos = vec3(0.0, 0.0, 1.0);\n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(vec3(uv, 0.0) - camPos);\n    vec3 col = vec3(0.0);\n    vec3 tp = vec3(1.0);\n    \n    \n    for(int r = 0; r < 3; r++){\n        bool hit = false;\n        vec3 n = vec3(0.0);\n        for(int i = 0; i < 120; i++){\n            float dist = sdf(rayPos);\n            rayPos += rayDir * dist;\n            if(dist < 0.00001){\n                hit = true;\n                n = getNorm(rayPos);\n                tp *= vec3(0.8, 0.5, 0.2);\n                if(distance(-lightPos, rayPos) < lightRadius + 0.1){\n                    col += tp * 3.0;\n                }else{\n                    col += tp * 0.0;\n                }\n                break;\n            }\n        }\n        if(hit == false){\n            //col += tp * texture(iChannel0, rayDir).xyz;\n            break;\n        }else{\n            //rayDir = reflect(rayDir, n);\n            rayDir = normalize(mix(RandomUnitVector(rngState), reflect(rayDir, n), 0.1));\n            rayPos += rayDir * 0.0002;\n        }\n        \n    }\n    \n    col = pow(col, vec3(1.0/2.2));\n    \n    vec3 prevCol = texture(iChannel1, fragCoord/iResolution.xy).xyz;\n    col = mix(col, prevCol, 0.999);\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}