{"ver":"0.1","info":{"id":"ltGfRD","date":"1541968404","viewed":75,"name":"First assignment","username":"eszilew","description":"Elte msc project","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float a = texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y), 0).a;\n     vec4 col = vec4(0.);\n    int width = 3;\n    if( a<2. ){ \n    \twidth = 0;\n    }\n    else if (a> 5.){\n    \twidth = (2*int(clamp(a,0.,1.))+1)*(2*int(clamp(a,0.,1.))+1);\n    }\n    \n    for (int i=-width/2; i<=width/2; i++) {\n        for (int j=-width/2; j<=width/2; j++) {\n            col = col + texelFetch(iChannel0, ivec2(int(fragCoord.x)+i, int(fragCoord.y)+j), 0);\n        }\n    }\n    col = col / pow((float(width)+1.),2.);\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct sphere_t {\n    vec3 center;\n    float radius;\n};\n\nstruct ray_t {\n    vec3 start;\n    vec3 direction;\n};\n    \n    \n    \nvec2 cplxmult(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\n\nfloat f(float x, float y)\n{\n    return x*x+y*y+x*x*y-cos(x+1.0)-0.25;\n}\n\nfloat koch(vec2 p)\n{\n    float ft = mod(floor(10.),6.)+1.;\n    p = abs(fract(p)-0.5);\n    for(int i=0;i<12;++i)\n    {\n        p = -vec2(-p.y + p.x*1.735, abs(p.x + p.y*1.735) - 0.58)*.865; //One loc version\n    }\n    \n    return mod(floor(10.*2.),2.)>0. ? abs(p.x)/(ft*ft)*14. : p.x/(ft*ft)*16.;\n}\n\n\nfloat fractaltexture(vec2 position){\n    vec2 q = position.xy / iResolution.xy;\n    vec2 p = q-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n    p = clamp(p,-.55,.55);\n    \n\treturn koch(position.yx*.9+vec2(0.5,0));\n\n}\n\nfloat eps = 0.005;\n\nconst float pi = 3.1415926535897932384626433832795;\n\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat tube(vec3 p, float h, float w){\n    //UNION of infinite cylinder + box\n\tfloat tubeIn = max(sdCylinder(p,vec3(0.,0.,w-.1)),sdBox(p,vec3(1,h+0.1,0.5)));\n    float tubeOut =  max(sdCylinder(p,vec3(0.,0.,w)),sdBox(p,vec3(1,h,0.5)));\n    return max(tubeOut,-tubeIn);\n}\n\nfloat plane(in vec3 p, in vec3 q, in vec3 n)\n{\n    return dot(p-q,n);\n}\nfloat planeSdf(in vec3 p){\n\treturn plane(p, vec3(0,-12,0), vec3(0,1,0));\n}\n\nfloat frameSdf(in vec3 p)\n{\n    float plane = planeSdf(p);\n    p = p*rotateY(pi/2.)+vec3(-18.,-4,6);\n    float topTube = tube(p*rotateX(pi/2.),10.,.5);\n    float headTube = tube(p+vec3(0.,2.,10.),2.5,.5);\n    float seatTube = tube(p+vec3(0.,7.,-10.),7.75,.5);\n    float downTube = tube(p*rotateX(-pi/3.)+vec3(0.,4.5,8.),11.5,.5);\n    float bottomBracketShell = tube(p*rotateZ(pi/2.)+vec3(15.,0.,-10.),1.,.5);\n  \tfloat seatStayRight = tube(p*rotateX(pi/1.35)*rotateZ(pi/18.)+vec3(-1.2,-16.5,7.),10.,.3);\n    float seatStayLeft = tube(p*rotateX(pi/1.35)*rotateZ(-pi/18.)+vec3(1.2,-16.5,7.),10.,.3);\n    float chainScayRight = tube(p*rotateX(pi/2.2)*rotateZ(pi/15.)+vec3(-1.2,-15.,-16.25),7.,.3);\n    float chainScayLeft = tube(p*rotateX(pi/2.2)*rotateZ(-pi/15.)+vec3(1.2,-15.,-16.25),7.,.3);\n    float frame = min(topTube,headTube);\n    frame = min(frame,downTube);\n    frame = min(frame,bottomBracketShell);\n    frame = min(frame,seatStayRight);\n    frame = min(frame,seatStayLeft);\n    frame = min(frame,chainScayRight);\n    frame = min(frame,chainScayLeft);\n    frame = min(frame,seatTube);\n    // plane \n    \n    return frame;\n}\n\n\n\nvec3 frameNormal(const in vec3 p)\n{\n    vec3 plus = vec3(frameSdf(p+vec3(eps,0,0)),frameSdf(p+vec3(0,eps,0)),frameSdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(frameSdf(p-vec3(eps,0,0)),frameSdf(p-vec3(0,eps,0)),frameSdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\nvec3 planeNormal(const in vec3 p){\n    vec3 plus = vec3(planeSdf(p+vec3(eps,0,0)),planeSdf(p+vec3(0,eps,0)),planeSdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(planeSdf(p-vec3(eps,0,0)),planeSdf(p-vec3(0,eps,0)),planeSdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    int technique = 1;\n    for( int i=0; i<10; i++ )\n    {\n\t\tfloat h = frameSdf( ro + rd*t );\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n   \n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nconst vec3 lightColor = vec3(1.,1.,1.);\nconst float lightPower = 25.;\nconst vec3 ambientColor = vec3(0.1, 0.0, 0.0);\nconst vec3 diffuseColor = vec3(0.6);\nconst vec3 specColor = vec3(1.0);\nfloat dt = 1./0.;\nvec3 sphereTrace(const in ray_t ray)\n{\n    vec3 lightpos= vec3(20.,101.,-50.);\n\tfloat t = 0.;\n    float lastdFrame;\n    float lastPlane;\n    const int maxIter = 100;\n    float textureColor = 0.5;\n    vec3 nor;\n    vec3 pos;\n    \n    for (int i=0; i<maxIter; i++) {\n        pos = ray.start + t*ray.direction;\n        lastdFrame = frameSdf(pos);\n        lastPlane = planeSdf(pos);\n        t += min(lastdFrame,lastPlane) ;\n        if (lastdFrame < eps)\n        {\n            nor=frameNormal(pos);\n            textureColor = fractaltexture(pos.xy);\n            break;\n        }\n        else if(lastPlane < eps){\n            nor = planeNormal(pos);\n        \tbreak;\n        }\n    }\n\n    vec3 col = vec3(0.0);\n    \n    //light direction\n    vec3 tolight = normalize(lightpos-pos);\n    \n    dt = distance(pos,vec3(getCameraX(),getCameraY(),getCameraZ()));\n    //lambertian\n    float di = max(dot(tolight,nor),0.0) * \n                    calcSoftshadow( pos, vec3(clamp(lightpos.x,0.,1.),clamp(lightpos.y,0.,1.),clamp(lightpos.z,0.,1.)), 0.01, 3.0 );\n \tfloat specular = 0.0;\n    \n    if(di>0.0)\n    {\n        vec3 toeye = normalize(-pos);\n        vec3 halfangle = normalize(toeye + tolight);\n    \t\n        specular = pow(dot(halfangle, nor),100.0);\n    }\n\n    if (lastdFrame < eps){\n        vec2 point = vec2(ray.start + t*ray.direction).xy;\n        \n        //vec3 textureColor = texture (iChannel3, point).xyz;\n        //textureColor = fractaltexture(point);\n        col = diffuseColor *clamp(textureColor,0.,1.)* di * lightColor  + specular* specColor;\n    }\n    else if (lastPlane<eps){\n\n    \tcol = diffuseColor *1.* di * lightColor + specular* specColor;\n    }\n\n    else {\n      \n        col = texture (iChannel2, ray.direction).xyz;\n    }\n    \n    return  col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Load the pixels(texels) in which we store camera information\n    loadPx0();\n    loadPx1();\n    \n\t// Description of 2 spheres\n    //spheres[1] = sphere_t(vec3(9,4,10), 1.f);\n\n    vec3 cameraPos = vec3(getCameraX(), getCameraY(), getCameraZ());\n    vec2 cameraRot = vec2(getU(), getV());\n    mat3 cameraRotMat = rotateY(cameraRot.y)*rotateX(cameraRot.x);\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2. + vec2(-1.,-1.);\n\n    float angleX = pi/2.;\n    float angleY = angleX * iResolution.y / iResolution.x;\n    float x = (uv.x) * angleX;\n    float y = (uv.y) * angleY;\n\n\n    ray_t ray;\n    ray.direction = normalize(cameraRotMat*vec3(x, y, 1));\n    ray.start = cameraPos;// + ray.direction * 5.;\n\n    fragColor = vec4( sphereTrace(ray), dt );\n    \n    \n    \n    // Keyboard and mouse handling:  \n    const float v = 0.3;\n    vec3 rightDir = cameraRotMat*vec3(v, 0, 0);\n    vec3 zoomDir  = cameraRotMat*vec3(0, 0, v);\n    if (isKeyHeld(KeyLeft )) cameraPos -= rightDir;\n    if (isKeyHeld(KeyRight)) cameraPos += rightDir;\n    if (isKeyHeld(KeyUp   )) cameraPos += zoomDir;\n    if (isKeyHeld(KeyDown )) cameraPos -= zoomDir;\n    \n    setCameraX(cameraPos.x);\n    setCameraY(cameraPos.y);\n    setCameraZ(cameraPos.z);\n        \n    vec2 mouseInit = mouseInitPos();\n    if (mouseInit.x > 0.) {\n        const float camV = 0.03;\n        setU(cameraRot.x + sign(mouseInit.y-iMouse.y)*camV);\n        setV(cameraRot.y + sign(mouseInit.x-iMouse.x)*camV);\n        setMouseInit(iMouse.xy);\n    }\n    else {\n    \tsetU(cameraRot.x);\n        setV(cameraRot.y);\n    \tsetMouseInit(iMouse.zw);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n/*\n\tA set of #define-s for camera and mouse handling\n\t\n\tWe will use the first 2 pixels of the buffer to store the information we need.\n\tEvery pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n\t\n\t\tpixel0 = (cameraX, cameraY, cameraZ)\n\t\tpixel1 = (U, V, mouseX, mouseY)\n\n\twhere \n\t\tcameraX, cameraY and cameraZ describe the position of the camera respectively\n\t\tU,V give the current rotation of the camera in spherical coordinates\n\t\t(mouseX, mouseY) is the position of the mouse while the left button is held\n*/\n\nvec4 px0, px1;\n\n#define loadPx0() px0 = texelFetch(iChannel0, ivec2(0,0), 0);\n#define loadPx1() px1 = texelFetch(iChannel0, ivec2(1,0), 0);\n\n#define pixel0 (fragCoord.x <1. && fragCoord.y <1.)\n#define pixel1 (fragCoord.x >=1.&& fragCoord.x <2. && fragCoord.y <1.)\n\n#define getCameraX() (px0.x)\n#define getCameraY() (px0.y)\n#define getCameraZ() (px0.z)\n\n#define setCameraX(p) if (pixel0) fragColor.x = p;\n#define setCameraY(p) if (pixel0) fragColor.y = p;\n#define setCameraZ(p) if (pixel0) fragColor.z = p;\n                   \n#define getU() (px1.x)\n#define getV() (px1.y)\n\n#define setU(p)       if (pixel1) fragColor.x = p;\n#define setV(p)       if (pixel1) fragColor.y = p;\n\n#define setMouseInit(p) if (pixel1) fragColor.zw = p;\n#define mouseInitPos()  (px1.zw)\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\n\n// Rotation matrices\nmat3 rotateX(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n    \t1, 0, 0,\n        0, c, s,\n        0, -s, c\n    );\n}\n\nmat3 rotateY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n    \tc, 0, s,\n        0, 1, 0,\n        -s, 0, c\n    );\n}\n\nmat3 rotateZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        c, s, 0,\n        -s, c, 0,\n        0, 0, 1\n    );\n}\n\n","name":"Common","description":"","type":"common"}]}