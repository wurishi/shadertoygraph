{"ver":"0.1","info":{"id":"sdBfDw","date":"1646392466","viewed":845,"name":"Solid angle sampling line light","username":"matte","description":"Testing a technique for importance sampling a position on a line light, based on Kulla's equiangular sampling\nLeft side: Importance sampled\nRight side: Random area sampling","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","line","light","sampling","angle","solid","importance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2022 Matt Ebb\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PIXEL_SAMPLES 8\n\n/*\nEquiangular sampling (Kulla, Sony Picures Imageworks)\nis used in volume rendering to importance sample the \n1/r^2 'falloff' term between a single point (light) \nand a line segment (view ray), in order to sample more \ndensely where the light is closest to the ray and \ncontributing more energy.\n\nThis is a form of solid angle sampling, relating the \nsolid angle of the line as seen by the point, since\n'inverse square falloff' is really just another way of\ntalking about change in solid angle with distance.\n\nThe same idea and technique can be flipped around and \napplied to sampling a line light acording to solid angle,\nas seen by a single shading point on a surface.\n*/\n\nvec3 s_curve(vec3 x)\n{\n    const float a = 2.51f;\n    const float b = 0.03f;\n    const float c = 2.43f;\n    const float d = 0.59f;\n    const float e = 0.14f;\n    x = max(x, 0.0);\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n\nfloat hash( ivec2 c )\n{\n    int x = 0x3504f333*c.x*c.x + c.y;\n    int y = 0xf1bbcdcb*c.y*c.y + c.x;\n    \n    return float(x*y)*(2.0/8589934592.0)+0.5;\n}\n\n// from iq: Capsule - intersection - MIT License\n// https://www.shadertoy.com/view/Xt3SzX\n// intersect capsule : https://iquilezles.org/articles/intersectors\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\nvec3 sample_line_light_area(vec3 la, vec3 lb, float u, out float pdf) {\n\tpdf = 1.0;\n\treturn mix(la, lb, u);\n}\n\n\n// derived from 'equiangular sampling' (Kulla)\n// from Volume Rendering Techniques at Imageworks\n// https://fpsunflower.github.io/ckulla/data/volume-rendering-techniques.pdf\n\nvec3 sample_line_light_point_solidangle(vec3 la, vec3 lb, vec3 P, vec3 N, float u, out float pdf) {\n\tpdf = 1.0;\n\n\tvec3 a = la;\n\tvec3 b = lb;\n\tvec3 L = lb - la;\n\tvec3 nL = normalize(L);\n\n#if 1\n    // clipping is not necessary but sometimes helps when light is below surface\n\n\t// clip line light endpoints to above plane defined by normal\n\tfloat da = dot(a-P, N);\n\tfloat db = dot(b-P, N);\n\n\t// update clipped L and nL\n\tL = b - a;\n\tnL = normalize(L);\n#endif\n\n    // closest point to shading point P along line segment\n    vec3 dorigin = P-a;\n    float delta = dot(nL, dorigin);\n    vec3 projp = a + nL*delta;\n    \n    // get distance from shading point to line\n    float D = length(a + L*delta - P);\n    \n    // get angle of endpoints\n    float theta_a = atan(-delta, D);\n    float theta_b\t = atan(length(L) - delta, D);\n\n    // take sample\n    float t = D * tan(mix(theta_a, theta_b, u));\n\n    vec3 sampleP = nL*(delta+t) + a;\n\n    pdf = D/((theta_b - theta_a)*(D*D + t*t));\n    pdf *= length(L);\n    \n    return sampleP;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // camera matrix\n    vec3 ro = vec3( 0.0, 0.4, 2.0 );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    // pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    // light endpoints\n    const float pi = 3.1415;\n    float time = abs(mod(iTime*0.25, 4.0) - 2.0) - 1.0;\n    vec3 la = vec3(sin(time), 0.0, cos(time));\n    vec3 lb = vec3(sin(time+pi), 1.0, cos(time+pi));\n    \n    // light colour\n    vec3 lc = 1.0 + 0.5*cos(iTime*0.5+vec3(0,1,2));\n    \n    vec3 col = vec3(0.0);\n    int samples = PIXEL_SAMPLES;\n    \n    for (int p=1; p<=samples; p++) {\n        \n        float u0 = hash(ivec2(fragCoord) * ivec2(p) );\n        \n        float t = 1e10;\n        // test intersect ground plane\n        float gt = (0.0-ro.y)/rd.y;\n        if (gt > 0.0) t = gt;\n           \n        // test intersect light\n        float capt = capIntersect(ro, rd, la, lb, 0.01);\n        if (capt > 0.0 && capt < t) {\n            col += lc;\n            continue;\n        }\n        if (t < 0.0) continue;\n        \n        vec3 P = ro + rd*t;\n        vec3 N = vec3(0.0,1.0,0.0);\n        \n        vec3 lightP;\n        float light_pdf;\n        \n        if (fragCoord.x < iResolution.x*0.5)\n            lightP = sample_line_light_point_solidangle(la, lb, P, N, u0, light_pdf);\n        else\n            lightP = sample_line_light_area(la, lb, u0, light_pdf);\n\n        vec3 L = lightP - P;\n        float geoterm = max(dot(N, normalize(L)), 0.0);\n        float falloff = 1.0 / dot(L,L);\n        float brdf_pdf = 2.0*3.1415;\n                \n        col += lc * falloff * geoterm / (brdf_pdf * light_pdf);\n    }\n    col /= float(samples);\n\n    col = s_curve(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}