{"ver":"0.1","info":{"id":"stScRW","date":"1649250552","viewed":100,"name":"Mocap X Screen Replacement","username":"LoganOracio","description":"Some shader to put on a screen to track /replace a unfortunate object that would happen to peak in front of the screen","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["screen","utility","pattern","replacement","mocap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 4\n#define SUB_SAMPLE 8\n#define SPACING 0.02\n#define SIZE 2.0\n#define EDGE_PIXELS 60.0\n#define EDGE_COLOR vec3(0.0,1.0,0.0)\nbool tri(vec2 v, float edge)\n{\n    v.y*=1.1547;\n    v.x-=v.y*.5;\n    vec2 c = fract(v);\n    return c.x+c.y<(1.0-edge)&&c.x>edge&&c.y>edge;\n}\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat lerp(float x, float y, float v)\n{\n    if(v<=0.0) return x;\n    else if(v>=1.0) return y;\n    else\n    { \n        return (y - x) * (((v * 6.0 - 15.0) * v + 10.0) * v * v * v) + x;\n    }\n}\nvec2 random_gradient(vec2 uv)\n{\n    float angle = hash12(uv)*2.0*3.14159265358979;\n    return vec2(cos(angle),sin(angle));\n}\nfloat dot_gradient(vec2 i, vec2 uv)\n{\n    vec2 d = uv - i;\n    vec2 grad = random_gradient(vec2(i.x,i.y));\n    return d.x*grad.x + d.y*grad.y;\n}\nfloat pnoise(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    \n    float n0 = dot_gradient(fl,uv);\n    float n1 = dot_gradient(fl+vec2(1.0,0.0),uv);\n    float o0 = lerp(n0,n1,uv.x-fl.x);\n    \n    n0 = dot_gradient(fl+vec2(0.0,1.0),uv);\n    n1 = dot_gradient(fl+vec2(1.0,1.0),uv);\n    float o1 = lerp(n0,n1,uv.x-fl.x);\n    \n    return lerp(o0,o1,uv.y-fl.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pix_l = 1.0/iResolution.xy;\n    vec2 uv = fragCoord.xy * pix_l;\n    \n    if(uv.x<pix_l.x*EDGE_PIXELS || uv.x>1.0-pix_l.x*EDGE_PIXELS || uv.y<pix_l.y*EDGE_PIXELS || uv.y>1.0-pix_l.y*EDGE_PIXELS)\n    {\n        fragColor = vec4(EDGE_COLOR,1.0);\n    }\n    else\n    {\n        uv.x *= iResolution.x/iResolution.y;\n        pix_l.x *= iResolution.x/iResolution.y;\n\n        uv *= SIZE;\n        pix_l *= SIZE;\n\n        float fstep = 1.0/float(SUB_SAMPLE);\n        float offset = fstep*(float(SUB_SAMPLE)/2.0-0.5);\n\n        float ex = 0.0;\n\n        for(int i = 0; i < 16; i++)\n        {\n            if(i>=SUB_SAMPLE) {break;}\n            for(int j = 0; j < 16; j++)\n            {\n                if(j>=SUB_SAMPLE) {break;}\n\n                bool outp = false;\n                bool mask = false;\n                vec2 texco = uv+pix_l*vec2(float(i)*fstep-offset,float(j)*fstep-offset);\n                for(int i = 0; i < ITERATIONS; i++)\n                {\n                    float fi = float(i+1);\n                    outp = outp||(!mask&&tri(texco*pow(2.0,fi),SPACING*fi));\n                    mask = mask||tri(texco*pow(2.0,fi),0.0);\n                }\n                ex += float(outp);\n            }\n        }\n        ex /= float(SUB_SAMPLE*SUB_SAMPLE);\n\n        ex = max(ex,0.5*float(pnoise(uv*200.0)>0.0));\n\n        fragColor = vec4(vec3(ex),1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}