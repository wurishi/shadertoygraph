{"ver":"0.1","info":{"id":"sl2GzD","date":"1623487034","viewed":83,"name":"simplex noise crease","username":"RiceFields","description":"simplex noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["simplexnoise","crease"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate2d(vec2 uv, float angle) {\n    mat2 mat = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); \n    return (mat*(uv));\n}\n\nvec2 hash(vec2 uv){\n    uv = vec2( dot(uv,vec2(127.1,311.7)), dot(uv,vec2(269.5,183.3)) );\n    vec2 v = -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);  \n    v = rotate2d(v, iTime); // rotated random direction\n    return v;\n}\n\n// noise range [-1, 1]\nfloat snoise2D(vec2 v) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2\n    const float K2 = 0.211324865; // (3-sqrt(3))/6\n    \n    // skew each unit square gird into two equilateral triangle (simplex cell)\n    vec2 i = floor(v + (v.x+v.y)*K1); \n    \n    // unskew the cell origin i(x,y) back to original space\n    vec2 pa = i - (i.x+i.y)*K2;\n    // distance from cell origin to current point(v)\n    vec2 da = v - pa;\n    \n    // calculate point b of the simplex\n    vec2 o = vec2(0.0f);\n    if(da.x > da.y) {\n        o = vec2(1.0f, 0.0f); //  lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    } else {\n        o = vec2(0.0f, 1.0f); // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    }\n    \n    vec2 db = da - o + K2; // offset for point b of simplex\n    vec2 dc = da - 1.0 + 2.0 * K2; // offset for point c of simplex\n\n    \n    // calculate contribution of each point, with distance of simplex vertices from current point   \n    float ca = max(0.5f - dot(da, da), 0.0f); \n    float cb = max(0.5f - dot(db, db), 0.0f);\n    float cc = max(0.5f - dot(dc, dc), 0.0f); \n\n    // calculate gradient with the contribution\n    float n1 = ca*ca*ca*ca*dot(da, hash(i + vec2(0.0f)));\n    float n2 = cb*cb*cb*cb*dot(db, hash(i + o));\n    float n3 = cc*cc*cc*cc*dot(dc, hash(i + vec2(1.0f)));\n    \n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70.0f * (n1+n2+n3);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // res\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 16.0f;\n    float x_max = (iResolution.x/iResolution.y)*16.0f; // max uv.x\n    \n    // tile\n    vec2 fuv = fract(uv);\n    vec2 iuv = floor(uv);\n    \n    // noise with creases \n    float len = length(snoise2D(uv+iTime*0.2f));\n    \n    // sliding window, between len and inverted len\n    float a = mod(iTime*2.5f, 2.0f*x_max); \n    if(a > x_max)\n      len = abs(step(uv.x, 2.0f*x_max-a)- len);\n    else\n      len = abs(step(uv.x, a)- len);\n    \n    fragColor = vec4(vec3(len), 1.0f);\n}","name":"Image","description":"","type":"image"}]}