{"ver":"0.1","info":{"id":"NlfczN","date":"1647627946","viewed":151,"name":"Lorentz Gallery","username":"freemeson","description":"Raytracing with regards to the speed of light.\nYou can see a few cubes standing or moving with 0.5, 0.9 and 0.99 times the speed of light, and a few rolling or flying spheres. The doppler effect outside the visible spectrum is shown as noise.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","relativity","lorentz","boost"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis shader is ray tracer that takes into account the speed of light.\nYou can see the effects of \nLorentz contraction, time dilation, doppler effects and relativistic light aberration\n\nSome ideas, structure are from:\nhttps://www.shadertoy.com/view/fd2yD3\nhttps://www.shadertoy.com/view/tl23Rm\nhttps://www.shadertoy.com/view/ll2cDc\nhttps://www.shadertoy.com/view/ltB3zD\n*/\n\n#define MAX_DIST -1e5\n//to turn off the movement of the objects, set this to 1\n//does not disable time completely, the arrival time of light from\n//the objects varies, so their apparent position is not frozen\n#define FROZENTIME 0\n#define TIME_DEFINITION mod(10.0*iTime, 100.0)+camDist-50.0\n//to turn off camera's lorentz boost and doppler, change this to 0.0\n//Should be between 0.0 and 1.0. \n#define CAM_BETA 0.25\n\nstruct distanceAndColor{\n\tvec2 dLim; // distance limits\n\tvec3 color;\n};\n\n\n\ndistanceAndColor opU(distanceAndColor oldDistLim, float t, vec3 color) {\n    //float a =   (1 < 2) ? (1.0) : (2.0);\n    \n    if (-t < oldDistLim.dLim.y) {\n        return distanceAndColor(vec2(oldDistLim.dLim.x, -t), color);\n    } else\n    {\n        return oldDistLim;\n    }\n    \n\t//return (-t < oldDistLim.dLim.y) ? distanceAndColor(vec2(oldDistLim.dLim.x, -t), color) : oldDistLim;\n}\n\n\nvec3 waveLengthToRGB(float hue)\n{\n    // https://www.shadertoy.com/view/ll2cDc\n\n\treturn vec3(.5 + .5 * clamp( 1.3*cos(-0.3 + 6.28 * hue + vec3(0,0.66666*6.28, 0.3333*6.28)), -1.0, 1.0));\n//approximate colors\n//red is hue = 0.05\n//green is 0.38\n//blue is 0.71\n}\n\nfloat PHI = 1.61803398874989484820459;\n\nfloat gold_noise(in vec3 randSeed){\n       return fract(tan(distance(randSeed.xy*PHI, randSeed.xy)*randSeed.z*2323.0)*randSeed.x);\n}\n\n\nvec3 wideSpectrum(float hue, in vec3 randSeed) {\n\tif (hue<0.0) {\n\t\tvec3 red = waveLengthToRGB(0.0);\n\t    float noise = (-hue)*gold_noise(randSeed);\n\n\t\treturn red-noise*red;\n    }\n\tif (hue>0.8) {\n\t\tvec3 violet =  waveLengthToRGB(0.8)*exp(-(hue-0.8));\n\t\tvec3 antiViolet = 1.0 - violet;\n\t\tfloat noise = (1.0-exp(0.16*0.8-0.16*hue))*gold_noise(vec3(randSeed.xy,randSeed.z*10.0)); //larger seed means less correlations\n\t\treturn violet+noise*antiViolet;\n    }\n\treturn waveLengthToRGB(hue);\n}\n\n\nmat4 LorentzBoost(in vec3 v, in float beta) {\n     float gamma = 1.0/sqrt(1.0-beta*beta);\n     vec3 gv = gamma * v;\n     float gm1 = gamma-1.0;\n     return mat4( 1.0+gm1*v.x*v.x,gm1*v.x*v.y ,gm1*v.x*v.z , -gv.x ,\n     \t       \t    gm1*v.x*v.y ,1.0+gm1*v.y*v.y ,gm1*v.y*v.z , -gv.y ,\n\t\t     gm1*v.x*v.z,gm1*v.y*v.z ,1.0+gm1*v.z*v.z , -gv.z ,\n\t\t     -gv.x,-gv.y ,-gv.z , gamma );\n}\n\nfloat dopplerShift(float hue, float factor){\n\tfloat freq = 1.0/(hue+1.0);\n\t//hue=1/freq-1\n\tfloat freqDoppl = freq*factor;\n\tfloat hueDoppl = 1.0/freqDoppl - 1.0;\n\treturn hueDoppl;\n}\n\nvec4 plane4(in vec4 ro, in vec4 rd, in vec4 origin, in mat4 invLor,in mat4 Einv, in vec2 distLim, vec3 randSeed ){\n\tvec4 rayorig = invLor*(ro - origin);\n\tvec4 raydir = invLor*rd;\n\n\tvec4 uvwt_o = Einv * rayorig;\n\tvec4 uvwt_d = Einv * raydir;\n\n\tfloat t = -uvwt_o.z / uvwt_d.z;\n\tvec4 uvwt = uvwt_o + uvwt_d*t;\n\n\n\tif (t>0.0 || t>-distLim[0] || t<-distLim[1] ) {return vec4(MAX_DIST, 0.0, 0.0, 0.0);}\n\n\tfloat shade = mod(floor(uvwt.x/2.0) + floor(uvwt.y/2.0), 2.);\n        vec3 red = wideSpectrum(dopplerShift(0.05, abs(uvwt_d.w)),randSeed);\n\tvec3 green = wideSpectrum(dopplerShift(0.38, abs(uvwt_d.w)),randSeed);\n\tvec3 blue = wideSpectrum(dopplerShift(0.71, abs(uvwt_d.w)),randSeed);\n\t//vec3 yellow = wideSpectrum(dopplerShift(0.22, abs(uvwt_d.w)),randSeed);\n\t//vec3 white = red+green+blue;\n        vec3 greenish = green + 0.3*red + 0.3*blue;\n\n\treturn vec4(t,shade*vec3(0.0, 0.0 , 0.0) + (1.0-shade)*greenish);\n}\n\nvec4 box4(in vec4 ro, in vec4 rd, in vec4 origin, in mat4 invLor, in mat4 Einv, in vec3 halfSizes, in vec2 distLim , in vec3 randSeed ) {\n\n       \tvec4 rayorig = invLor*(ro - origin);\n\tvec4 raydir = invLor*rd;\n\n\tvec4 sptq_o = Einv * (rayorig);\n\tvec4 sptq_d = Einv * raydir;\n\n\tvec3 m = 1.0/sptq_d.xyz;\n\tvec3 n = m*sptq_o.xyz;\n\tvec3 k = abs(m)*halfSizes;\n\tvec3 t1 = -n -k;\n\tvec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n\tif( tN>tF || tF>0.0 || -tF<distLim[0] || -tF>distLim[1]) {\n\t\treturn \t  vec4(MAX_DIST, 0,0,0);} // no intersection\n\n\t//return vec2(tF, 1.0 );\n\tvec4 sptq = sptq_o + sptq_d*tF;\n\tfloat shade = 1.0;//mod(floor(sptq.s) +floor(sptq.q) , 2.);\n\t//return vec4(tF,1.0, 1.0, 1.0);\n\tvec3 red = wideSpectrum(dopplerShift(0.05, abs(sptq_d.w)), randSeed);\n\tvec3 green = wideSpectrum(dopplerShift(0.38, abs(sptq_d.w)), randSeed);\n\tvec3 blue = wideSpectrum(dopplerShift(0.71, abs(sptq_d.w)), randSeed);\n\n\tvec3 white = red+green+blue;\n\tif (abs(sptq.x) + 3e-5 > halfSizes.x) {\n\n\tshade = mod(floor(sptq.y) +floor(sptq.z) , 2.);\n\tvec3 color = shade*white + (1.0-shade)*red;\n\treturn vec4(tF,color);\n\t}\n\n\tif (abs(sptq.y) + 3e-5 > halfSizes.y) {shade = mod(floor(sptq.x) +floor(sptq.z) , 2.);\n   vec3 color = shade*white + (1.0-shade)*green;\n\n\treturn vec4(tF,color);}\n\n\tif (abs(sptq.z)+3e-5 > halfSizes.z) {\n            shade = mod(floor(sptq.x) +floor(sptq.y) , 2.);\n\t//shade = 1.0;\n\tvec3 color = shade*white + (1.0-shade)*blue;\n\n\n\n\treturn vec4(tF,color);}\n\n\treturn vec4(tF, 0.4,0.4,0.4);\n\n\n\n}\n\nvec4 rollingSphere4(in vec4 ro, in vec4 rd, in vec4 origin, in mat4 invLor, in mat4 Einv, float radius, in float equatorSpeed, in vec2 distLim, in vec3 randSeed) {\n\t//origin = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 rayorig = invLor*(ro - origin);\n\tvec4 raydir = invLor*rd;\n\n\tvec4 sptq_o = Einv * rayorig;\n\tvec4 sptq_d = Einv * raydir;\n\n\t//float b = dot(rayorig.xyz , normalize(raydir.xyz));\n\n\tvec3 ray_o = sptq_o.xyz;\n\tfloat len = sqrt(dot(sptq_d.xyz,sptq_d.xyz));\n\tvec3 ray_d = sptq_d.xyz/len;\n\tfloat b = dot(ray_o, ray_d);\n\t//radius = 9.0;\n\tfloat c = dot(ray_o, ray_o)- radius*radius;\n   float discr = b*b - c;\n\n\n\n   if (discr < 0.0) {return vec4(MAX_DIST, 1.0, 0.0, 0.0); }\n\n\n   float t = -b+sqrt(discr);\n   float ti = t/len; //assuming that the 4-vector lenght is rd*rd is zero, ligth-like\n   //the real time is t_Real = t*sptq_d.w, usually just a negative sign\n\n   if (-ti < distLim[0] || -ti > distLim[1]) {return vec4(MAX_DIST, 0.0, 1.0, 0.0);}\n\n//\treturn vec4(0,1.0/t, 1.0, 1.0 );\n\t//return vec4(-t, 1.0, 1.0, 1.0);\n\n   float myTime = sptq_o.w+sptq_d.w*t;\n\n\n   vec3 ri = ray_o + t*ray_d;\n   float phi=atan(ri.z, ri.x);\n   float theta = acos((ri.y)/radius);\n\n   vec2 rotArrow = vec2(ri.x, ri.z);\n   float rotRadius = sqrt(dot(rotArrow, rotArrow));\n   vec2 rotVel = equatorSpeed*vec2(-ri.z, ri.x)/radius;\n\n\n   phi += myTime*equatorSpeed/radius;\n\n   // ***** lorentz boost in 2+1 dimensions\n\n   float beta = equatorSpeed*rotRadius/radius;\n   float gamma = 1.0/sqrt(1.0-beta*beta);\n   vec2 gv = gamma*rotVel;\n   float gm1 = gamma - 1.0;\n   /*mat3 lorentzBoostXZW = mat3( 1.0+gm1*rotVel.x*rotVel.x, gm1*rotVel.x*rotVel.y , -gv.x,\n                                gm1*rotVel.x*rotVel.y,1.0+gm1*rotVel.y*rotVel.y , -gv.y,\n                                -gv.x ,-gv.y , gamma);\n   vec3 light2D = vec3(sptq_d.x, sptq_d.z, sptq_d.w);\n   vec3 incidentLight2d = lorentzBoostXZW*light2D;\n   float extraDoppler = incidentLight.w; */\n   vec4 lorentzLastColumn = vec4( -gv.x, 0.0, -gv.y, gamma );\n   float extraDoppler = sptq_d.w/dot(lorentzLastColumn, sptq_d);\n\n   //extraDoppler = 1.0;\n\n   float shade = mod(floor(4.0*radius*phi/6.283) + floor(2.0*radius*theta/3.1415), 2.);\n\n\tvec3 red = wideSpectrum(dopplerShift(0.05, abs(extraDoppler)),randSeed);\n\n\tvec3 green = wideSpectrum(dopplerShift(0.38, abs(extraDoppler)),randSeed);\n\tvec3 blue = wideSpectrum(dopplerShift(0.71, abs(extraDoppler)),randSeed);\n\tvec3 yellow = wideSpectrum(dopplerShift(0.22, abs(extraDoppler)),randSeed);\n\n   vec3 color = shade*vec3(0.0, 0.0, 0.0) + (1.0-shade)*yellow;\n   return vec4(ti, color);\n}\n\nvec4 sphere4(in vec4 ro, in vec4 rd, in vec4 origin, in mat4 invLor, in mat4 Einv, float radius, in vec2 distLim ,in vec3 randSeed) {\n    vec4 rayorig = invLor*(ro - origin);\n\tvec4 raydir = invLor*rd;\n\n\tvec4 sptq_o = Einv * rayorig;\n\tvec4 sptq_d = Einv * raydir;\n\n\n\tvec3 ray_o = sptq_o.xyz;\n\tfloat len = sqrt(dot(sptq_d.xyz,sptq_d.xyz));\n\tvec3 ray_d = sptq_d.xyz/len;\n\tfloat b = dot(ray_o, ray_d);\n\tfloat c = dot(ray_o, ray_o)- radius*radius;\n   float discr = b*b - c;\n\n\n\n   if (discr < 0.0) {return vec4(MAX_DIST, 1.0, 0.0, 0.0); }\n\n\n   float t = -b+sqrt(discr);\n   float ti = t/len; //assuming that the 4-vector lenght is rd*rd is zero, ligth-like\n\n   if (-ti < distLim[0] || -ti > distLim[1]) {return vec4(MAX_DIST, 0.0, 1.0, 0.0);}\n\n//\treturn vec4(0,1.0/t, 1.0, 1.0 );\n\t//return vec4(-t, 1.0, 1.0, 1.0);\n   //the real time is t_Real = t*sptq_d.w, usually just a negative sign\n   vec3 ri = ray_o + t*ray_d;\n   float phi=atan(ri.z, ri.x);\n   float theta = acos((ri.y)/radius);\n\n   float shade = mod(floor(4.0*radius*phi/6.283) + floor(2.0*radius*theta/3.1415), 2.);\n\n\tvec3 red = wideSpectrum(dopplerShift(0.05, abs(sptq_d.w)),randSeed);\n\n\tvec3 green = wideSpectrum(dopplerShift(0.38, abs(sptq_d.w)),randSeed);\n\tvec3 blue = wideSpectrum(dopplerShift(0.71, abs(sptq_d.w)),randSeed);\n\tvec3 yellow = wideSpectrum(dopplerShift(0.22, abs(sptq_d.w)),randSeed);\n\n   vec3 color = shade*vec3(0.0, 0.0, 0.0) + (1.0-shade)*yellow;\n   return vec4(ti, color);\n}\n\ndistanceAndColor worldHit(in vec4 ro, in vec4 rd, in vec2 distLim, in float showTime, in vec3 randSeed){\n\tdistanceAndColor dlc=distanceAndColor(distLim, vec3(0.0, 0.0, 0.0));\n\n\tmat4 invBoost = mat4(5.26315789, 0.0, 0.0, 4.73684211,\n\t0.0, 1.0, 0.0, 0.0,\n\t0.0, 0.0, 1.0, 0.0,\n\t4.73684211, 0.0, 0.0, 4.69904779); //x-direction with 0.9c\n\n\tmat4 invBoost2 = mat4(2.29415734, 0.0, 0.0, -2.0647416, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,-2.0647416, 0.0, 0.0, 2.29415734 ); //this is also the inverse of invBoost\n\n\tmat4 invBoost05 = mat4(1.3333333, 0.0, 0.0, 0.666666,\n\t\t0.0, 1.0, 0.0, 0.0,\n\t\t0.0, 0.0, 1.0, 0.0,\n\t\t0.666666, 0.0, 0.0, 1.19935874); //half the speed of ligth\n\tmat4 noBoost = mat4(1.0, 0.0, 0.0,0.0,\n\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t 0.0, 0.0, 1.0, 0.0,\n             0.0, 0.0, 0.0, 1.0);\n\n        mat4 invBoost099 = mat4(50.25125628,  0.        ,  0.        , 49.74874372,\n          0.        ,  1.        ,  0.        ,  0.        ,\n          0.        ,  0.        ,  1.        ,  0.        ,\n          49.74874372,  0.        ,  0.        , 49.39232364);\n\n        mat4 invBoost01 = mat4(1.010101 , 0.       , 0.       , 0.1010101,\n       0.       , 1.       , 0.       , 0.       ,\n       0.       , 0.       , 1.       , 0.       ,\n       0.1010101, 0.       , 0.       , 1.0050884   );\n\n        mat4 orientation = mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t    0.0, 1.0, 0.0, 0.0,\n\t\t    0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0 );\n\n        mat4 tiltedOrientation = mat4( 1.0, 0.0, 0.0, 0.0,    0.0, 0.0, 1.0, 0.0,    0.0, 1.0, 0.0, 0.0,    0.0, 0.0, 0.0, 1.0 );\n        mat4 tiltedOrientationRoll = mat4( 1.0, 0.0, 0.0, 0.0,\n                                           0.0, 0.0, -1.0, 0.0,\n                                           0.0, -1.0, 0.0, 0.0,\n                                           0.0, 0.0, 0.0, 1.0 );\n\n\n\n\tvec4 dc = box4( ro, rd, vec4(0.0, 0.0, 0.0, showTime), invBoost, orientation , vec3(2.0, 2.0, 2.0), dlc.dLim , randSeed);\n\tdlc = opU(dlc, dc.x, dc.yzw);\n\n\tdc = box4( ro, rd, vec4(0.0, 0.0, 5.0, showTime), invBoost05, orientation, vec3(2.0, 2.0, 2.0), dlc.dLim , randSeed);\n\tdlc = opU(dlc, dc.x, dc.yzw);\n\n\tdc = box4( ro, rd, vec4(0.0, 0.0, -5.0, showTime), invBoost099, orientation, vec3(2.0, 2.0, 2.0), dlc.dLim , randSeed );\n\tdlc = opU(dlc, dc.x, dc.yzw);\n\n\n    dc = box4( ro, rd, vec4(0.0, -6.0, 0.0, showTime), noBoost, orientation, vec3(2.0, 2.0, 2.0), dlc.dLim , randSeed);\n\tdlc = opU(dlc, dc.x, dc.yzw);\n\n\tdc = plane4(ro, rd, vec4(0.0, -8.0, 0.0, 0.0), noBoost, tiltedOrientation, dlc.dLim, randSeed );\n\tdlc = opU(dlc, dc.x, dc.yzw);\n\n    dc = sphere4(ro, rd, vec4(0.0, 0.0, -9.0, showTime), invBoost, orientation, 2.0, dlc.dLim, randSeed);\n    dlc = opU(dlc, dc.x, dc.yzw);\n\n    dc = sphere4(ro, rd,vec4(0.0, 0.0, 9.0, showTime), invBoost2, orientation, 2.0, dlc.dLim , randSeed);\n    dlc = opU(dlc, dc.x, dc.yzw);\n\n    dc = sphere4(ro, rd, vec4(0.0, -6.0, -5.0, showTime), noBoost, orientation, 2.0, dlc.dLim , randSeed);\n    dlc = opU(dlc, dc.x, dc.yzw);\n\n    dc = rollingSphere4(ro, rd, vec4(0.0, -6.0, -10.0, showTime), noBoost, orientation, 2.0, 0.1, dlc.dLim, randSeed);\n    dlc = opU(dlc, dc.x, dc.yzw);\n    dc = rollingSphere4(ro, rd, vec4(0.0, -6.0, 10.0, showTime), invBoost05, tiltedOrientationRoll, 2.0, 0.5, dlc.dLim, randSeed);\n    dlc = opU(dlc, dc.x, dc.yzw);\n\n\n\t\t//dlc = distanceAndColor( vec2(0.0001, -dc.x), dc.yzw );\n\treturn dlc;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float screen_ratio = iResolution.y/iResolution.x;\n    vec3 randSeed = vec3(uv, iTime);\n\n    //float phi = 0.0;\n    float psy = 0.4;\n\n    // Time varying pixel color\n    /*vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float boost = mod(iTime/5.0, 5.0)+0.1;\n    vec3 red = wideSpectrum(dopplerShift(0.05, abs(boost)), randSeed);\n\n\tvec3 green = wideSpectrum(dopplerShift(0.38, abs(boost)), randSeed);\n\tvec3 blue = wideSpectrum(dopplerShift(0.71, abs(boost)), randSeed);\n\n    vec3 dopplCol = red*col.r + green*col.g + blue*col.b;\n\n    // Output to screen\n    fragColor = vec4(dopplCol,1.0);*/\n    \n    \n    distanceAndColor dlc=distanceAndColor(vec2(0.0001, 500.0), vec3(0.0, 0.0, 0.0));\n\n\n\tfloat camDist = 20.0;\n        float invFOV = 0.5;\n\tvec4 ro = vec4(0.0, 0.0, camDist, 0.0);\n\tvec3 rd3=normalize(vec3(uv.x - 0.5 - ro.x, screen_ratio*(0.5-uv.y -ro.y),camDist+invFOV-ro.z)); //z is funny, I know\n   vec4 rd = vec4(rd3,-1.0);\n\n   float phi = iTime/2.0;\n   float beta = CAM_BETA;\n   vec3 camSpeed = beta*vec3( cos(phi), 0.0, -sin(phi) ) ;\n   mat4 camLorentz = LorentzBoost(camSpeed, beta);\n   mat4 rotationXZ = mat4( cos(phi),0.0, -sin(phi), 0.0, 0.0, 1.0, 0.0, 0.0, sin(phi), 0.0, cos(phi), 0.0, 0.0, 0.0, 0.0, 1.0  );\n\n\t//float psy = 0.3;\n\n\tmat4 rotationYZ = mat4( 1.0, 0.0, 0.0, 0.0, 0.0, cos(psy), -sin(psy), 0.0, 0.0, sin(psy), cos(psy), 0.0, 0.0, 0.0, 0.0, 1.0 );\n    mat4 noBoost = mat4(1.0, 0.0, 0.0,0.0,\n\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t 0.0, 0.0, 1.0, 0.0,\n             0.0, 0.0, 0.0, 1.0);\n\n    //mat4 camLorentz = noBoost;\n\n\tro = camLorentz*rotationXZ * rotationYZ* ro;\n\trd = camLorentz *rotationXZ * rotationYZ*rd;\n\n        \n    float showTime = camDist;\n    if (FROZENTIME!=1) {\n        showTime= TIME_DEFINITION;\n    }\n    dlc = worldHit(ro, rd, dlc.dLim,showTime, randSeed);\n    fragColor = vec4(dlc.color*exp(-0.032*(dlc.dLim.y-camDist)),1.0);//*frag_color;\n}","name":"Image","description":"","type":"image"}]}