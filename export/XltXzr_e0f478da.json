{"ver":"0.1","info":{"id":"XltXzr","date":"1477947168","viewed":2757,"name":"pumpkin carving 2016","username":"public_int_i","description":"Use mouse to carve pumpkin, reset time to reset. Brush options are in Buf A. \nHappy halloween!","likes":28,"published":1,"flags":48,"usePreview":0,"tags":["pumpkin","2016","carving"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n//Use mouse to carve pumpkin, reset time to reset. Brush options are in Buf A. \n//Happy halloween!\n\n//Image - renders carved pumpkin\n\n\n\n\n#define viewFar 6.\n#define pi 3.14\n#define epsilon 1e-1\n\n#define pumpkinColor (vec3(246, 116, 1)/255.)\n\n\n\n//2d point rotation\nvec2 rot(vec2 p, float a) {\n    return p*mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n\n\n\n//returns distance to sphere or viewFar if no hit\n//from inigo's site https://iquilezles.org/articles/simplegpurt\nfloat raySphere( in vec3 ro, in vec3 rd, in vec3 sp, in float rad )\n{\n    vec3  d = ro - sp.xyz;\n    float b = dot(rd,d);\n    float c = dot(d,d) - rad*rad;\n    float t = b*b-c;\n    if( t > 0.0 )\n    {\n        t = -b-sqrt(t);\n        if (t > 0.0) {\n            return t;\n        }\n    }\n\n    return viewFar;\n}\n\n\n//sample pumpkin cut texture in world space\nvec2 sampleCut(vec3 ro) {\n    return texture(iChannel0, vec2(-.5,.5)*ro.xy*iResolution.x/iResolution.xy+vec2(0.5,0.14)).xy;\n}\n//pumpkin density function\nfloat pdensity(vec3 ro) {\n    float ang = atan(ro.x,ro.z);\n    vec2 cut = sampleCut(ro);\n    return 0.1+cut.x*0.1+abs(cos(ang*12.+cos(ang*92.)*.14))*0.007;\n}\n//pumpkin distance function\nfloat pumpkin(vec3 ro) {\n    float baseSphere = length((ro-vec3(0.,0.5,0.))*vec3(0.75,1.,0.75))-.5;\n    if (baseSphere > epsilon*10.) return baseSphere;\n    return baseSphere+pdensity(ro);\n}\n\n\n//pumpkin normal\nvec3 pnormal(vec3 ro) {\n    vec2 NE = vec2(epsilon,0.);\n    return normalize(vec3(pumpkin(ro+NE.xyy)-pumpkin(ro-NE.xyy),\n                          pumpkin(ro+NE.yxy)-pumpkin(ro-NE.yxy),\n                          pumpkin(ro+NE.yyx)-pumpkin(ro-NE.yyx)));\n}\n//pumpkin normal large\nvec3 pnormalLarge(vec3 ro) {\n    vec2 NE = vec2(1.,0.);\n    return normalize(vec3(pumpkin(ro+NE.xyy)-pumpkin(ro-NE.xyy),\n                          pumpkin(ro+NE.yxy)-pumpkin(ro-NE.yxy),\n                          pumpkin(ro+NE.yyx)-pumpkin(ro-NE.yyx)));\n}\n\nvec3 background(vec3 rd) {\n    return vec3(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //setup camera\n    //initial screen ray and position\n    vec3 rd = normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.x, 1.)),\n         rp = vec3(0.,.4,-1.6);\n    rd.y *= -1.;\n            \n    //rotate direction and position around pumpkin\n    vec2 cameraRot = vec2(pi/-2.,pi/-2.);\n    mat2 rxmat = mat2(sin(cameraRot.x),cos(cameraRot.x),-cos(cameraRot.x),sin(cameraRot.x)),\n         rymat = mat2(sin(cameraRot.y),cos(cameraRot.y),-cos(cameraRot.y),sin(cameraRot.y));\n\t\n    rd.zy = rd.zy*rymat;\n    rd.xz = rd.xz*rxmat;\n    \n    \n    //render scene using ray tracing and marching\n    float groundDst = rp.y/-rd.y;\n    groundDst = mix(groundDst,viewFar,step(groundDst,0.));\n    \n    float pumpkinDst = raySphere(rp,rd,vec3(0.,0.4,0.),.8);\n    if (pumpkinDst < groundDst) {\n        //ray march pumpkin\n       \tvec3 ro = rp+rd*pumpkinDst;\n        float pdst;\n        for (int i = 0; i < 32; i++) {\n            pdst = pumpkin(ro);\n            if (pdst < epsilon) break;\n            ro += pdst*rd*.15;\n        }\n        if (pdst < epsilon) {\n            pumpkinDst = length(ro-rp);\n        } else {\n            pumpkinDst = viewFar;\n        }\n    }\n    \n    float mdst = min(pumpkinDst,groundDst);\n    rp += rd*mdst;\n    //shade hit\n    vec3 ocol;\n    if (groundDst < pumpkinDst) {\n        //ground with pumpkin lighting\n        float pdst = pumpkin(rp);\n        vec3 reflPos = rp+normalize(reflect(rd,vec3(0.,1.,0.)+vec3(0.,.1,0.)))*pdst*2.;\n        ocol = (pumpkinColor*texture(iChannel2, rp.xz).xyz)*(1./(pdst*pdst)*.008+(pow(.5-reflPos.y*.5,2.2)*max(0.,pdensity(reflPos*vec3(.5,1.2,1.))-0.1)*30.)*.25);\n    } else {\n        //pumpkin with internal lighting, diffuse bounce off ground and specular bounce off ground\n        \n        rp += rd*((1.+cos(rp))*0.02);//push sample position to hide banding and give a little lighting effect\n        \n        vec3 pnormlarge = pnormalLarge(rp);\n        float odp = max(0.,dot(rd,-pnormlarge));\n        float pdens = pdensity(rp);\n        ocol = pumpkinColor*((.1+odp*1.9)/2.*((pow(pdens*20.,2.2)*.5+max(0.,pdens-0.1)*40.)*pow(.5-rd.y*.5,2.2))*.5+.25*pumpkinColor*max(0.,1.5-rp.y*3.*(1.25-odp*.25))*vec3(146, 82, 44)/255.)*2.;\n    }\n    //background mix and output final color\n    fragColor =vec4(mix(ocol, background(rd), mdst/viewFar), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n//Buf A - carve depth/distance map\n//x = carve depth(inverse y-axis distance)\n\n\n#define brushSizee 2.\n#define brushOpacity 1.\n\n#define brushSize (brushSizee*length(iResolution.xy)/256.)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //initialize blank for first 60 frames to give people time to go fullscreen\n    if (iFrame < 60) {\n        fragColor = vec4(0.,0.,1.,0.);\n        return;\n    }\n    if (fragCoord.x+fragCoord.y < 2.) {\n        //store old mouse position in top left pixel for smoothed line drawing\n        fragColor = vec4(iMouse.xy,clamp(iMouse.z*1e4,0.,1.),0.);\n        return;\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float outerLen = length((uv-0.5+vec2(0.,-.07))*vec2(1.2,.9))-0.3;\n    if (outerLen > 0.) return;\n    \n    vec4 v = texture(iChannel0, uv);\n   \t\n    \n    //smooth line paint\n    vec2 currDelta = iMouse.xy-fragCoord;\n    float len = length(currDelta)-brushSize;\n    if (iMouse.z > 0.) {\n        \n        vec3 old = texture(iChannel0, vec2(.5/iResolution.xy)).xyz;\n        old.xy = mix(iMouse.xy,old.xy,old.z);\n        vec2 oldDelta = fragCoord-old.xy,\n             newDelta = iMouse.xy-old.xy;\n        \n        //line from last mouse pos to new pos      \n        len = length(oldDelta-newDelta*\n                     clamp(dot(oldDelta,newDelta)/dot(newDelta,newDelta),0.,1.))-brushSize;\n        \n        //paint line with last area cutout and fade\n        float subLen = mix(0.,length(oldDelta)-brushSize,old.z);\n        v.x += brushOpacity*clamp(-(len-min(0.,subLen))/brushSize,0.,1.);//*clamp(-len/10.,0.,1.);\n       \tv.x = min(1.,v.x);\n    }\n    \n    fragColor = v;\n}","name":"Buffer A","description":"","type":"buffer"}]}