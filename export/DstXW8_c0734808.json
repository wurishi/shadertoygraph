{"ver":"0.1","info":{"id":"DstXW8","date":"1679721269","viewed":140,"name":"Sheep and rocks","username":"ianertson","description":"Use the mouse to look around :)","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raymarching","raymarch","sdf","sheep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// <image>\n\n\n\nvoid hflf2(in vec2 uv, in float seed, inout vec3 hf1, inout vec3 hf2, inout vec3 lf1, inout vec3 lf2) {\n    hf1 = snoise(uv, seed, 0.5, 120.0, 6);\n    hf2 = snoise(uv, seed+5.5923125, 0.5, 96.0, 6);\n    lf1 = snoise(uv, seed+9.8848356, 0.25, 8., 6);\n    lf2 = snoise(uv, seed+16.773884, 0.25, 6., 6);\n}\n\n\n//#define DEBUG_TEXTURE furTexture\n\nvec3 furTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    \n    \n\n    vec3 hf1 = snoise(uv, 2.29238124, 0.4, 64.0, 6);\n    vec3 lf1 = snoise(uv, 6.589383, 0.2, 8.0, 6);\n    \n    vec3 warp = snoiseWarp(uv+0.5*lf1.xz, 0.0328214, 1.0, 16.0, 6, 0.5);\n    vec3 warp2 = snoiseWarp(uv-0.5*lf1.zy, 0.0328214, 1.9, 32.0, 6, 0.8);\n    \n    float pat = smoothstep(0.0, 0.2, abs(warp.x*2.0-1.0));\n    float pat2 = smoothstep(0.0, 0.2, abs(warp.y*2.0-1.0));\n    float pat3 = smoothstep(0.0, 0.2, abs(warp2.x*2.0-1.0));\n    \n    vec3 warp3 = abs((cross(vec3(0.0082123+pat*2.0-1.0, 0.222+pat2*2.0-1.0, 0.000289312+pat3*2.0-1.0), lf1*2.0-1.0)));\n    warp3 += 0.0029838124;\n    warp3 = abs(normalize(warp3));\n    \n    float pat4 = smoothstep(0.0, 0.2, warp3.z);\n    float pat5 = smoothstep(0.04, 0.1, abs(warp.y-warp2.y));\n\n    vec3 c1 = rgb(200, 159, 96);\n    vec3 c2 = rgb(209, 180, 86);\n    vec3 c3 = rgb(186, 168, 162);\n    vec3 c4 = rgb(198, 197, 204);\n    \n    vec3 col1 = mix4_uniform(c1, c2, c3, c4, hf1);\n    vec3 col2 = mix4(c1, c2, c3, c4, smoothstep(0.02, 0.8, hf1));\n    vec3 col3 = mix4_uniform(c4, c2, c3, c1, smoothstep(0.4, 0.7, warp3));\n    \n    col = mix(col1, col2, pat2);\n    \n    col = mix(col, col*pat, lf1.x);\n    col = mix(col, clamp(col+(col*pat2), 0.0, 1.0), lf1.y);\n    col = mix(col, mix(c2, c4, smoothstep(0.0, 0.4, hf1.z*warp.z)), pat3);\n    col = mix(col, col*col3, pat4*0.8*pat4);\n    col = mix(col, (col+col*col)*0.48, pat5);\n    \n    col = clamp(col, 0.0, 1.0);\n    \n    m.spec = clamp(pat*pat2*pat3*pat4*pat5, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1, hf2, lf1, lf2 = vec3(0.0);\n    hflf2(uv, 1.92389815, hf1, hf2, lf1, lf2);\n    \n    vec3 lf3 = snoise(uv, 6.69498194, 0.25, 0.9, 3);\n    \n    vec3 green = vec3(mix(0.29, 0.9, hf1.x*lf1.x), mix(0.4, 0.8, hf1.y), mix(0.15, 0.5, hf1.z*lf1.z));\n    green = mix(green, vec3(0.33, 0.31, 0.29), 0.5);\n    col += green;\n    \n    vec3 green2 = mix4_uniform(\n        vec3(0.29, 0.8, 0.15),\n        vec3(0.9, 0.5, 0.1),\n        vec3(0.49, 0.49, 0.29),\n        vec3(0.33, 0.69, 0.33),\n        smoothstep(0.4, 0.7, lf1)\n    );\n    \n    col = mix(col, mix(green2, vec3(1, 0, 0), 0.12), lf2.x);\n    \n    vec3 grain = abs(normalize(cross(hf1*2.0-1.0, hf2*2.0-1.0)));\n    vec3 grain2 = abs(normalize(reflect(grain*2.0-1.0, lf2*2.0-1.0)));\n    \n    col = mix(col, col*col*0.8, grain2.y*grain.x);\n    \n    vec3 brown = vec3(0.33, 0.31, 0.29)*0.5;\n    float mudReg = smoothstep(0.4, 0.7, 1.05*(lf2.y+lf1.x)/2.);\n    mudReg = mix(mudReg, mudReg*smoothstep(0.4, 0.7, lf3.x), smoothstep(0.19, 0.7, lf3.y));\n    \n    col = mix(col, brown, mudReg);\n    \n    vec2 wid = vec2(0.0);\n    float w = voronoi(uv*16., 0.298214, wid);\n    \n    float cracks = clamp((w*0.29)+smoothstep(w*mudReg*2., 0.0, 0.6), 0.0, 1.0);\n    col = mix(col, brown, cracks);\n    \n    \n    m.z = clamp(0.5-mudReg*0.9, 0.0, 1.0);\n    m.spec = clamp(((mudReg+cracks)/2.)*hf1.x*lf1.z, 0.0, 0.6);\n    \n    return col;\n}\n\nvec3 rockTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = vec3(0.77, 0.69, 0.71)*0.5;\n    vec3 c2 = vec3(0.69, 0.77, 0.61)*0.6;\n    vec3 c3 = vec3(0.71, 0.89, 0.79)*0.7;\n    vec3 c4 = vec3(0.48);\n    \n    vec3 hf1, hf2, lf1, lf2 = vec3(0.0);\n    hflf2(uv, 0.02389815, hf1, hf2, lf1, lf2);\n    col = mix4_uniform(c1, c2, c3, c4, smoothstep(0.4, 0.7, hf1));\n    vec3 col2 = mix4_uniform(c1, c2, c3, c4, smoothstep(0.4, 0.7, lf1));\n    col = mix(col, col2, lf2.z);\n    \n    float cracks = (1.0-smoothstep(0.02, 0.1, abs(lf2.x*2.0-1.0))) *\n        smoothstep(0.4, 0.7, lf1.y);\n    \n    \n    col = mix(col, col+col*col, cracks);\n    \n    float spec = pow(cracks, 6.0)*6.;\n    m.spec = spec;\n    m.z = clamp((0.6-lf1.z)+(0.5-(cracks*cracks)), 0.0, 1.0);\n    \n    return col;\n}\n\nfloat checkerTexture(in vec2 uv, in float s) {\n    vec2 d = max(abs(dFdx(uv)), abs(dFdy(uv))) + s;\n    vec2 t1 = vec2(1.-2.0*abs(fract((uv.x+.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y+.5*d.y)*.5)-0.5));\n    vec2 t2 = vec2(1.-2.0*abs(fract((uv.x-.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y-.5*d.y)*.5)-0.5));\n    return 0.5 - 0.5*((t1.x-t2.x)/d.x)*(t1.y-t2.y)/d.y;\n}\n\n#define ID_GROUND 1\n#define ID_ROCK 2\n#define ID_SHEEP 3\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat rockSDF(in vec3 p, in float seed) {\n    float r = 1.;\n    float ra = fract(seed*20.9984872815);\n    float ra2 = fract((ra*10.2838125)+cos(seed*6.3981235));\n    r = mix(r, r*(0.25+(ra*0.5)), ra2);\n    vec3 n = vec3(cos((p.x*2.)-seed*ra), sin((p.y*2.)+seed*ra), sin((p.z*2.)-seed*ra));\n    n += vec3(cos(ra*6.), sin(ra*6.), sin((ra*6.)+seed));\n    p += n.zxy*0.2;\n    p += cos(seed+(length(n-0.4*dot(p*ra, n-0.9))*6.))*0.05;\n    float rock = sphereSDF(p - vec3(0, r, 0), r);///boxSDF(p - vec3(0, 1, 0), vec3(1.0))-0.25;\n    rock /= 1.6;\n    return rock-0.05;\n}\n\nfloat sheepSDF(in vec3 p, in float seed) {\n\n    \n    float len = 0.9;\n    float height = 0.9;\n    float thick = 0.15;\n    float body = lineSDF(p - vec3(0, thick + height, 0), vec3(0, 0, -len/2.), vec3(0., 0, len/2.), thick);\n    body -= smoothstep(0.02, 1.6, max(0.0, height-p.y/2.5))*max(0.0, height-p.y/9.5);\n    body += smoothstep(0.0, 1.0, abs(p.x))*0.3;\n    body -= smoothstep(0.1, 1.2, clamp(-p.y+1.9, 0.0, 0.4)) *\n        smoothstep(0.0, 0.25, abs(p.x)*max(0.0, -p.y+1.3));//*abs(p.x));\n    \n    {\n        vec3 p = p;\n        p.yz *= rot(sin(((T*3.)+(2.0*sign(p.z))+2.0*sign(p.x))*2.)*0.25);\n        float legHeight = height-thick;\n        float legThick = 0.05;\n        float leg = lineSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(thick, 0, len/2.), vec3(0, 0, 0), vec3(0, legHeight, 0), legThick);\n        body = min(body, leg);\n    }\n    \n    float tailLen = 0.3;\n    vec3 tailDir = normalize(vec3(sin(T*3.)*0.5, -0.5, -1.));\n    float tail = lineSDF(p - vec3(0, height+0.15, -((len/2.)+tailLen/2.)), vec3(0, 0, 0), tailDir*tailLen, 0.02);\n    body = min(body, tail);\n    \n    p.yz *= rot(sin(T*3.)*0.05);\n    \n    float headR = 0.23;\n    vec3 headPos = vec3(0, height+headR+thick+0.02, (len/2.)+headR);\n    float head = sphereSDF(p - headPos, headR);\n    head += smoothstep(0.0, 1.4, abs(p.x))*1.6;\n    head += smoothstep(0.05, 1.2, max(0.0, -p.y+1.4));\n    head -= smoothstep(0.5, 1.09, max(0.0, dot(normalize(p), vec3(0, 0, 1))))*0.89;\n    \n    \n    float eyeHoleR = 0.03;\n    vec3 eyeHolePos = abs(headPos + vec3((headR/2.)-eyeHoleR*1.1, 0.1, 0.2));\n    float eyeHole = sphereSDF(vec3(abs(p.x), p.y, p.z) - eyeHolePos, eyeHoleR);\n    \n    head = smax(head, -eyeHole, 0.02);\n    \n    float eyeR = eyeHoleR*0.5;\n    float eye = sphereSDF(vec3(abs(p.x), p.y, p.z) - (eyeHolePos + vec3(-0.005, -0.01, -0.02)), eyeR);\n    head = min(head, eye);\n    \n    {\n        vec3 p = p;\n        float shape = 0.0;\n        shape -= smoothstep(0.01, 1.35, sclamp(abs(p.x), 0.0, 0.6, 0.2))*0.99;\n        shape += abs(p.z-headPos.z)*0.5;\n        shape += max(0.0, p.y-headPos.y-0.13)*max(0.0, abs(p.x));\n        shape -= 0.003;\n        \n        vec3 earPos = headPos + vec3(0.15, 0.15, 0);\n        \n        p = vec3(abs(p.x), p.y, p.z) - earPos;\n        \n       \n        float earThick = 0.002;\n        float earR = 0.025;\n        float ear = cylSDF(p, vec3(0, 0, 0), vec3(0, 0.0, earThick), earR);\n        ear += shape;\n        \n        head = min(head, ear);\n    }\n    \n    \n\n    \n    body = smin(body, head, 0.06);\n    \n    \n    return body/1.5;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, o, ID_GROUND);\n    \n\n    \n    {\n        vec3 p = p;\n        vec2 rockId = floor((p.xz/6.));\n        p.x = mod(p.x, 6.)-3.;\n        p.z = mod(p.z, 6.)-3.;\n        float ra = fract(10.9823871218*cos(16.292321*fract((rockId.x+rockId.y))+5.391831*fract(rockId.x*10.231825123+rockId.y*10.92921952)));\n        float ra2 = fract(ra*16.9298321*sin(18.82381*fract(10.2381283*(rockId.x-rockId.y))));\n\n        if (floor(ra2+(ra*0.25))> 0.) {\n            float rock = rockSDF(p, ra+rockId.x+rockId.y);\n            SAMPLE(rock, o, ID_ROCK);\n        }\n    }\n    \n    {\n        vec3 p = p;\n        \n        vec2 sheepId = floor(p.xz/8.)-4.;\n        float uid = fract((10.82382182*(sheepId.x-sheepId.y))+10.29923182*cos(sheepId.x*10.2388124+sheepId.y*4.4928123));\n        float ra = fract(sin(uid*10.238218412)*(sheepId.x+sheepId.y)*10.777723);\n        float ra2 = fract(ra*44.492998388*dot(sheepId, vec2(4.428831, 6.398312)));\n        \n        if (floor(ra2+ra) > 0.) {\n            float time = T;\n            time += (ra+ra2+uid);\n            float ra3 = fract(10.283238138*(sin(ra*6.)+cos(ra2*6.)));\n            float ra4 = fract(16.938812*dot(vec2(uid, ra), vec2(ra2, ra3)));\n            float ra5 = fract(13.8238123*cos(uid*6.383812+ra)*dot(vec3(uid, ra, ra2), vec3(ra3, ra4, sheepId.x+sheepId.y)));\n            float ra6 = fract(ra*15.581283125+uid*cos(sheepId.x-sheepId.y));\n            time *= mix(1.0, 0.25, ra3);\n            time *= mix(1.0, 1.25, ra4);\n            time += ra4+ra3;\n            \n            vec3 dir = vec3(cos(time+uid*6.), 0, sin(time+uid*6.));\n            dir.xz *= rot(ra*TAU+ra3);\n            \n            // jumping sheep\n            if (floor(ra6+ra3+(ra5*0.09)) > 0.) {\n                dir.y = mix(0.0, 1.0 + mix(0.0, 0.25, ra5*ra3*ra), ra*ra5*(0.5+sin(time*(5.5+2.*ra2))*0.5));\n            }\n\n            p.x = mod(p.x, 8.)-4.;\n            p.z = mod(p.z, 8.)-4.;\n\n            Object oSheep = Object(dir, vec3(0, atan(dir.z, dir.x), 0));\n\n            p = pointRot(p-oSheep.p, oSheep.q);\n\n\n            float sheep = sheepSDF(p, 0.2932914);\n\n\n            oSheep.p.xz -= 4.;\n\n\n            SAMPLE(sheep, oSheep, ID_SHEEP);\n        }\n    }\n    data.id = id;\n    data.o = o;\n    return dist;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    uv *= 0.5;\n    vec3 col = grassTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.3, 0.009);\n    return col;\n}\n\nvec3 getAlbedoRock(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = rockTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.4, 0.03);\n    return col;\n}\n\nvec3 getAlbedoSheep(inout Data data) {\n    // ... this was difficult to figure out.\n    vec3 op = data.o.p;\n    op.x = mod(op.x, 8.);\n    op.z = mod(op.z, 8.);\n    vec3 p = data.p;\n    p.x = mod(p.x, 8.);\n    p.z = mod(p.z, 8.);\n    p -= op;\n    ///////////////////////////////\n\n    p = pointRot(p, data.o.q);\n    vec3 n = pointRot(data.n, data.o.q);\n    vec2 uv = boxUv(p, n);\n    vec3 col = furTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.4, 0.03);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_ROCK: return getAlbedoRock(data); break;\n        case ID_SHEEP: return getAlbedoSheep(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup*2.));\n    if (rd.y <= 0.0) return col;\n    \n    vec2 uv = rd.xz/rd.y;\n    uv += T*0.09;\n    \n    float time = T*0.05;\n    \n    vec2 shift = vec2(cos(time), sin(time));\n    \n    vec3 lf1 = snoiseWarp(uv + shift, 0.09283214, 0.9, 2.0, 6, 0.5);\n    vec3 lf2 = snoise(uv - shift, 4.49298231, 0.2, 4.0, 6);\n    vec3 hf1 = snoise(uv + shift, 2.20832154, 0.5, 16.0, 6);\n    vec3 hf2 = snoise(uv - shift, 16.8382315, 0.1, 32.0, 6);\n   \n    \n    float clouds1 = mix(lf1.x, lf1.y, smoothstep(0.4, 0.7, lf1.z));\n    float clouds2 = mix(hf1.x, hf1.y, smoothstep(0.4, 0.7, hf1.z));\n    float clouds3 = mix(hf2.x, hf2.y, smoothstep(0.4, 0.7, hf2.z));\n    \n    float clouds = mix(clouds1, clouds2, smoothstep(0.4, 0.7, lf2.x));\n    clouds = mix(clouds, clouds3, lf2.y);\n    clouds -= smoothstep(0.4, 0.7,mix(lf2.z, lf1.z,  clouds2));\n    clouds = pow(clouds, 2.0);\n    \n    col = mix(col+clouds, mix(col, vec3(1.0), clouds), smoothstep(0.0, 0.9, lf2.y)); \n    col += clouds;\n    return col;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    depth = 1.0;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = LIGHT_SUN; \n    \n    raycast(data, lights, true, col, ro, rd);\n    \n    depth = data.d / FAR;\n    \n    col += lights[0].c * smoothstep(0.09, 1.0, depth) * max(0.0, 1.0 - smoothstep(0.0, 0.25, dotup));\n    \n    return col;\n}\n\nRay getRay(in vec2 uv, in vec4 m) {\n    vec3 ro = vec3(0, 0, -6.);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (m.z > 0.001 && length(m.xy) > 0.0001 && iFrame > 1 && iTime > 0.0001) {\n      //  ro.yz *= rot(m.y*TAU);\n        //ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    }\n    \n    ro.z += T*6.;\n    float y = 4.;\n    ro.y += y;\n    ro.y = max(y, ro.y);\n\n    return Ray(ro, rd);\n}\n\nvec4 blit(in vec2 fc) {\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    Ray ray = getRay(uv, m);\n    vec3 ro = ray.ro;\n    vec3 rd = ray.rd;\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    return vec4(col, depth);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    O = blit(fc);\n}\n// </image>\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// <common>\n#define R (iResolution.xy)\n#ifndef HW_PERFORMANCE\n#define iTime (0.0)\n#define iFrame (0)\nuniform sampler2D iChannel3;\n#define iResolution vec2(0.0)\n#define iMouse vec4(0.0)\n#endif\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n\n\n#define FORWARD_DECL\\\n    float sdf(inout Data data, in vec3 p) { return FAR; }\\\n    vec3 getAlbedo(inout Data data) { return vec3(0.0); }\\\n    vec3 getSky(in vec3 rd) { return vec3(0.0); }\n\n#define SAMPLE(var, OBJ, id_) if (id_ != skip && var < dist) { id = id_; dist = var; o = OBJ; }\n// Ray marcher constants\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n#define SHADOW_STEPS 33\n#define FAR_LOD 1.0\n#define NORMAL_RANGE 0.001\n#define AMBIENT 0.05\n#define NUM_LIGHTS 1\n#define ID_NONE -1\n\n// Colors\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n// Render constants\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n// Default sun light\n\n#define LIGHT_SUN Light(vec3(1, 2, 3), vec3(0.0), COLOR_SUN, 2.0, LIGHT_AMBIENT)\n\nstruct Object {\n    vec3 p;\n    vec3 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 q;\n    vec3 ro;\n    vec3 rd;\n    vec3 p;\n    vec3 n;\n    float d;\n    int skip;\n    int id;\n    float uid;\n    float sig;\n    Material m;\n    Object o;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0),vec3(0.0), vec3(0.0), vec3(0.0), FAR, ID_NONE, ID_NONE, 0., 1., NEW_MATERIAL, NEW_OBJECT)\n\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n#ifndef HW_PERFORMANCE\nfloat sdf(inout Data data, in vec3 p) { return FAR; }\nvec3 getAlbedo(inout Data data) { return vec3(0.0); }\nvec3 getSky(in vec3 rd) { return vec3(0.0); }\n#else\nfloat sdf(inout Data data, in vec3 p);\nvec3 getAlbedo(inout Data data);\nvec3 getSky(in vec3 rd);\n#endif\n\n\n// Utilities\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nvec3 mix4_uniform(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    vec3 mix1 = mix(c1, c2, m.x);\n    vec3 mix2 = mix(c3, c4, m.x);\n    vec3 mix3 = mix(mix1, mix2, m.y);\n    return mix(mix3, (c1 + c2 + c3 + c4) / 4.0, m.z);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nfloat sclamp(in float v, in float mi, in float ma, in float k) {\n    return smin(smax(v, mi, k), ma, k);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.0003) return wn;\n    cp = normalize(cp);   \n    vec3 next = normalize(mix(wn, normalize(wn+cp), mx));\n    if (length(next) <= 0.0003) return wn;\n    return next;\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    return p;\n}\n\n// UV functions\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nvec2 sphereUv(in vec3 p) {\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);\n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    return vec2(u, v);\n}\n\n// Distance functions\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    return length(pa - ba * (clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0))) - r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\n// Noise functions\n\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) { return float(hash21u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n.xy*n.z)*warp;\n    }\n    return n / div;\n}\n\nfloat voronoi(in vec2 p, in float seed, out vec2 id){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n    \n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    float r = 1.0;\n    \n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21(Pi+lattice, 0.9231234), hash21(Pi+lattice, 78.38381));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            r = min(r, dist/0.56);\n            if(r<dmin){\n                id = offset;\n                dmin = r;\n                res = lattice + offset;\n            }\n        }\n    }\n\n    return clamp(sqrt(dmin), 0.0, 1.0);\n}\n\n// Shading & Colors\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nvec3 fresnelSchlickRoughness(float NdotV, vec3 F0, float rough) {\n  return F0 + (max(vec3(1.0 - rough), F0) - F0) * pow(max(1.0 - NdotV, 0.0), 5.0);\n}\n\n// Marching\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NORMAL_RANGE, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float far, in int skip) {\n    float NdotL = cdot(n, rd);\n    if (NdotL <= SHADOW_NDOTL_EPSILON) return 1.0;\n    \n    Data data = NEW_DATA;\n    data.skip = skip;\n    \n    float d = 0.0;\n    float r = 1.0;\n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/0.44);\n        d += next*0.13;\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) break;\n    }\n    \n    return clamp(r + 0.77*(d / (1.0 + d)), AMBIENT, 1.0);\n}\n\n// Lighting\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n           light.type == LIGHT_POINT ? normalize(light.p - p) :\n           normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.0), L, n, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    return (diffuse + spec) * att * shadow; \n}\n\nbool raycast(inout Data data, in Light lights[NUM_LIGHTS],\n    in bool with_sky, inout vec3 col, in vec3 ro, in vec3 rd) {\n    if (!march(data, ro, rd)) {\n        if (with_sky) {\n            col += getSky(rd);\n        }\n        return false;\n    }\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n        Light light = lights[i];\n        col += forEachLight(light, data, ro, rd, diffuse);\n    }\n    return true;\n}\n// </common>\n","name":"Common","description":"","type":"common"}]}