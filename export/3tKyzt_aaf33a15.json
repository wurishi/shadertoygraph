{"ver":"0.1","info":{"id":"3tKyzt","date":"1611619007","viewed":675,"name":"Surface nets ","username":"kastorp","description":"proof of concept... very slow because mesh is not precalculated is it would be in a real scenario.\n\n\n","likes":24,"published":1,"flags":0,"usePreview":1,"tags":["voxel","mesh","tesselate","surfacenets"],"hasliked":0,"parentid":"ttVyWR","parentname":"Marching Cubes algorithm"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------------------\n// SURFACE NETS  by Kastorp\n//            proof of concept for the popular tesselation algorithm, which is an alternative to Marching cubes\n//            inspired by these articles: \n//            https://bonsairobo.medium.com/smooth-voxel-mapping-a-technical-deep-dive-on-real-time-surface-nets-and-texturing-ef06d0f8ca14\n//            https://0fps.net/2012/07/12/smooth-voxel-terrain-part-2/\n//--------------------------------------------------------------------------------------\n\n\nconst float TK=.1; //edge thickness \nconst float csz = .5 ;//+ 0.1 * sin(iTime); // Cell size\nconst bool snet=true; //true=smoothed, false=cubes\n bool cover=true;\n\n struct GRIDCELL{     //calculated for each cube in the following sequence:\n   vec3 p[8];         //  1. cube vertex positions\n   float val[8];      //  2. isosurface value at each cube vertex\n   float nVertex;     //  3. number of vertex where val[]>0; if 0<nVertex<8  => surface cube\n   float nEdge;       //  4. number of cube edges with crossing \n   vec3 m;            //  5. surface vertex, as an average of all crossing edge positions\n   int dirs;          //  6. 6bit bitmask of surface edges from  each cube; \n                      //  7. quads (not calculated here)   \n} ;\n\n\n\n// the shape to be tesselated\nfloat sdShape(in vec3 p) {\n    p = p/ 4.;\n    vec3 q = abs(p) - 1.35;\n    float cube = max(q.x, max(q.y, q.z));\n    float sphere = length(p) - 1.6875;\n    float cylinder1 = length(p.yz) - 0.6;\n    float cylinder2 = length(p.xz) - 0.6;\n    float cylinder3 = length(p.xy) - 0.6;\n    return max(max(cube, sphere), -min(cylinder1, min(cylinder2, cylinder3))) * 1.5;\n}\n\n\n\nconst vec3 v[8] =vec3[8]\n(\n   vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n   vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\nconst int  e[24] =int[24](\n   0,1,   1,2,  2,3,   3,0, \n   4,5,   5,6,  6,7,   7,4,   \n   0,4,   1,5,  2,6,   3,7);\n\nconst vec3 dir[6] =vec3[6]\n(\n   vec3(1,0,0), vec3(0,1,0),vec3(0,0,1),\n   vec3(-1,0,0), vec3(0,-1,0),vec3(0,0,-1)\n);\n\nconst ivec2 quads[12]=ivec2[12]\n( \n    ivec2(0,1),ivec2(0,2),ivec2(0,4),ivec2(0,5),\n    ivec2(1,2),ivec2(1,3),ivec2(1,5),ivec2(2,3),\n    ivec2(2,4),ivec2(3,4),ivec2(3,5),ivec2(4,5)\n);\n\nvec2 mmin(vec2 a, vec2 b) {return (a.x<b.x?a:b);}\nint gFrame=0; \n\nvec3 pc=vec3(-1000.);\n\n\nvoid  getSurface(vec3 c, inout GRIDCELL g)\n{\n\n    g.m=vec3(0.);\n    g.nVertex=0.;\n    g.nEdge=0.;\n    g.dirs=0;\n\n    //gFrame unrolling fails here...\n    for(int i=0;i<8;i++)\n    {\n\n        //1. cube vertex positions\n        vec3 vp=c+ csz* v[i];\n        g.p[i]=vp;\n\n        //  2. isosurface value at each cube vertex\n        float val =sdShape(vp);\n         g.val[i]=val;\n        \n        //3. number of vertex where val[]>0;\n        g.nVertex+= (val<=0.?1.:0.);\n\n    }\n\n     if(g.nVertex>0. && g.nVertex<8.)\n     {\n\n\n          for(int i=gFrame;i<24;i+=2)\n          {\n              //  isosurface weights at each cube edge vertexes\n              float d1 = g.val[e[i]],\n                  d2 = g.val[e[i+1]],\n                  d= d1/(d1-d2);\n\n            //  4. number of cube edges with crossing \n             if(d1*d2<0.){\n                 g.nEdge++;\n                 g.m+= g.p[e[i+1]]*d + g.p[e[i]]*(1.-d);\n                 \n                 for(int k =gFrame;k<6;k++) {\n                     \n                     //  6. 6bit bitmask of surface edges from  each cube\n                     if(dot((g.p[e[i+1]] +g.p[e[i]])/2.- c -csz/2. , dir[k] )<0. )  g.dirs=g.dirs | (1<<k); \n                     \n                 }\n             }\n          }\n         if(snet){\n            //  5. surface vertex, as an average of all crossing edge positions\n             g.m/= g.nEdge;\n             g.m = min(max(g.m,c),c+csz); //must be inside the cube\n         }\n         else g.m = c+csz/2.;\n         \n\n\n    }    \n}\n\n//--------------------------\n//SDF functions by Iq\n#define dot2(x) dot(x,x)\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) ;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//------------------\n\nGRIDCELL g;\nGRIDCELL[6] ng;\n\nvec4 mapScene(in vec3 p) {\n    \n    \n    float s0= sdShape(p);\n    if(s0>2.*csz) return vec4(s0-2.*csz, vec3(0.)); //too far from any cube, skip all logic\n    else{\n    \n        vec2 shape = vec2(100.,0.);\n         \n        vec3 c = floor(p / csz) * csz;\n        if(c!=pc)\n        {\n            //this should be precalculated in a buffer\n            getSurface(c,g);\n \n           for(int k =gFrame;k<6;k++) {\n                     \n              if((g.dirs & (1<<k))>0) {\n              \n                  //get neighbour surface vertex along each direction\n                  getSurface(c-dir[k]*csz,ng[k]);  \n                  \n                  ng[k].m=g.m +(ng[k].m-g.m)*3.; //enphasize neightbour distance so surface triangles always fills the cube\n                  \n               } \n           }\n           pc=c;\n        }\n        \n        if(g.nVertex==0.) {\n            // void cube\n            return vec4(s0, vec3(0.)); \n        }\n       else if( g.nVertex<8. ) \n       {\n          //surface cube\n          \n          for(int k =gFrame;k<6;k++) {\n              //show  surface edges      \n              if((g.dirs & (1<<k))>0) shape=mmin(shape, vec2( sdCapsule(p,g.m,ng[k].m )-csz*TK/2. ,2.));\n\n\n           } \n          if(cover){\n               for(int k =gFrame;k<12;k++) {\n                    ivec2  v=quads[k];\n                  //show  surface       \n                  if((g.dirs & (1<<v.x))>0 && (g.dirs & (1<<v.y))>0 ) shape=mmin(shape, vec2( udTriangle(p,g.m,ng[v.x].m,ng[v.y].m )-csz*TK/10. ,1.));\n\n\n               }\n           }\n           else{\n              //show surface vertex \n              shape=mmin(shape,vec2( length(p- g.m)- csz*TK ,3.)); \n\n \n           }\n\n       }\n       else if(g.nVertex>=8.) \n       {\n           // internal cube\n          shape=mmin(shape,vec2( length(p- c-csz/2.)-csz*.5 ,1.)); \n       }\n       \n       //simple coloring\n       return vec4(shape.x,shape.y>0.?shape.y==3.? vec3(0,1,1):shape.y==2.?vec3(1,1,0):sdBox(c,vec3(10.))<0.? .5+ normalize(p):vec3(.2):vec3(0.));\n        \n   }\n  \n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    for(int i=gFrame;i<=2;i++){\n        vec3 e=  0.001* ((i==0)?vec3(1,0,0):(i==1)?vec3(0,1,0):vec3(0,0,1));\n        for(float j=-1.;j<=1.;j+=2.) n+= j*e* mapScene(p + j* e).x ;\n    }\n    return normalize(n);\n \n}\n\n\nvec3 rot(vec3 p,float tt)\n{\n    float c1 = cos(tt), s1 = sin(tt);\n    float c2 = c1, s2 = s1;\n    p.xz *= mat2(c1, s1, -s1, c1);\n    p.yz *= mat2(c2, s2, -s2, c2);\n    return p;\n}\nvec3 rotinv(vec3 n,float tt)\n{\n    float c1 = cos(tt), s1 = sin(tt);\n    float c2 = c1, s2 = s1;\n    n.yz *= mat2(c2, -s2, s2, c2);\n    n.xz *= mat2(c1, -s1, s1, c1);\n    return n;\n}\n\n\n\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5*csz - csz*0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\n//RAY TRACING WITH VOXEL TRAVERSAL\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t   \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2  mouse =  iMouse.x<=0. ? vec2(0.): (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    cover=(mouse.x>uv.x);\n    fragColor = vec4(0.4,0.4,0.7,1.0);\n    gFrame=min(iFrame,0);\n\n    vec3 ro = rot(vec3(0.0, 0.0, 16.0),iTime/3.);\n    vec3 rd = rot(normalize(vec3(uv, -1.0)),iTime/3.);\n\n\n    vec3 rs= sign(rd);\n    vec3 ri = 1./rd;\n\tvec3 rp=ro;  \n    vec3 mp=floor(rp/csz)*csz;\n    vec3 sd = (mp-rp + 0.5*csz + sign(rd)*0.5*csz) *ri;\n    vec3 mask=vec3(0.); \n\n    \n    for (int i = 0; i < 100; i++) {\n    \n         mask = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n\t\tsd += mask *  rs *ri*csz;\n        mp += mask *  rs*csz;\n            \n        float d = sdShape(mp+.5*csz);\n        \n        if( d<.5*csz ){\n        \n            //SDF RAYTRACING INSIDE CUBE\n            rp = VoxelHitPos(mp,rp,rd).xyz+rd*.0001;\n            float t = 0.0;          \n            for (int iters=gFrame; iters < 40; iters++) {\n                vec3 p = rp + rd * t;\n\n                if(sdBox(p-mp-.5*csz,vec3(.5*csz))>0.) break;\n\n                vec4 d = mapScene(p);\n                if (d.x < 0.001) {\n                    vec3 n = getNormal(p);\n                    vec3 l = rot(vec3(-0.58, 0.58, 0.58),iTime/3.);\n\n                    fragColor.rgb += d.yzw;\n                    fragColor.rgb *= max(0.2, dot(n, l));\n                    \n                    return;\n                }\n\n\n                t += d.x;\n                //if(iters>38.) fragColor.rgb=vec3(1,0,0);\n            }\n            //fragColor.rgb+=abs(mask)*.2;\n        }   \n\t}\n    \n    \n}\n","name":"Image","description":"","type":"image"}]}