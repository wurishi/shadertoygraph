{"ver":"0.1","info":{"id":"Xd3BDH","date":"1526907691","viewed":145,"name":"voronoiNormalImpl","username":"nyu","description":"voronoiNormalImpl","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Using a sobel filter to create a normal map and then applying simple lighting.\n\n// This makes the darker areas less bumpy but I like it\n#define USE_LINEAR_FOR_BUMPMAP\n\n#define PLANEMODE\n//#define SHOW_NORMAL_MAP\n//#define SHOW_ALBEDO\n\nstruct C_Sample\n{\n\tvec3 vAlbedo;\n\tvec3 vNormal;\n};\n\n#define ANIMATE\n#define FLATMODE\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    vec3 normal = vec3( md, mr );\n    //normal = (normal / 2.0) + 0.5;\n    normal.z = -normal.z;\n    normal = normal.yzx;\n    normal = mix( vec3(0.0,0.0,1.0), normal, smoothstep(-0.02, 0.07, normal.z ));\n    return normal;\n}\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// return distance, and cell id\nvec3 voronoiFLAT( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        #ifdef ANIMATE\n        float animate = iTime;\n        #else\n        float animate = 0.0;\n        #endif\n\t    vec2  r = g - f + (0.5 + 0.5 * sin(animate + 6.2831 * o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    vec2 c = vec2( sqrt(m.x), m.y+m.z );\n\n        #ifdef ANIMATE\n        float animate = iTime / 50.0;\n        #else\n        float animate = 1.0;\n        #endif\n    // colorize\n    return normalize(0.5 + 0.5*cos(c.y * 10.2831 + vec3(0.0,4.0 * animate ,8.0 * animate)));\n}\n\n\n\n\n/************ raytraced plane *******************/\n#define Pi 3.14159265359\n\nvec3 planeInt(vec3 normal, vec3 rayorg, vec3 raydir) {\n\treturn rayorg + (raydir * (dot(-rayorg, normal) / dot(normal, raydir)));\n}\n\nvec4 eulerToQuat(vec3 a) {\n    float c1 = cos(a.x/2.);\n    float s1 = sin(a.x/2.);\n    float c2 = cos(a.y/2.);\n    float s2 = sin(a.y/2.);\n    float c3 = cos(a.z/2.);\n    float s3 = sin(a.z/2.);\n    float c1c2 = c1*c2;\n    float s1s2 = s1*s2;\n    return vec4(c1c2*s3 + s1s2*c3,\n                s1*c2*c3 + c1*s2*s3,\n                c1*s2*c3 - s1*c2*s3,\n                c1c2*c3 - s1s2*s3);\n}\n\nvec3 rotateEuler(vec3 position, vec3 a) {\n    mat4 rx = mat4(1., 0., 0., 0.,\n                  0., cos(a.x), -sin(a.x), 0.,\n                  0., sin(a.x), cos(a.x), 0.,\n                  0., 0., 0., 1.);\n    mat4 ry = mat4(cos(a.y), 0., sin(a.y), 0.,\n                  0.,        1., 0., \t  0.,\n                  -sin(a.y), 0., cos(a.y),0.,\n                  0.,\t\t 0., 0.,\t  1.);\n    mat4 rz = mat4(cos(a.z), -sin(a.z), 0., 0.,\n                  sin(a.z),  cos(a.z),  0., 0.,\n                  0.,\t\t 0.,\t\t1., 0.,\n                  0.,\t\t 0.,\t\t0., 1.);\n    mat4 r = rx * ry * rz;\n    return (vec4(position, 1.) * r).xyz;\n}\n\nvec4 quat_mult(vec4 q1, vec4 q2)\n{ \n  vec4 qr;\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n  return qr;\n}\n\nvec3 rotateQuat(vec3 p, vec4 q) {\n  vec4 qr_conj = vec4(-q.x, -q.y, -q.z, q.w);\n  vec4 q_pos = vec4(p.x, p.y, p.z, 0);\n  \n  vec4 q_tmp = quat_mult(q, q_pos);\n  q = quat_mult(q_tmp, qr_conj);\n  \n  return vec3(q.x, q.y, q.z);\n}\n\nvec2 uvPlane(vec2 fragCoord, out vec3 normal){\n    vec3 eye = vec3(0.,0.,15.);\n    vec3 dir = normalize(vec3(-1.0 + 2.0 * fragCoord.xy / iResolution.xy, 5.));\n\n    float v = sin(iTime) / 10.0;\n    float x = -Pi/4.0;//v * Pi;\n    float y = v * Pi / 2.0 + Pi / 2.0;\n    vec3 r = vec3(0., x, y);\n#ifdef USE_QUATERNION\n    vec4 q = eulerToQuat(r);\n    vec3 pNormal = rotateQuat(vec3(0.,0.,1.), q);\n    vec3 pTangent = rotateQuat(vec3(0.,1.,0.), q);\n#else\n    vec3 pNormal = rotateEuler(vec3(0.,0.,1.), r);\n    vec3 pTangent = rotateEuler(vec3(0.,1.,0.), r);\n#endif\n    normal = pNormal;\n    vec3 pBitangent = cross(pTangent, pNormal);\n    vec3 i = planeInt(pNormal, eye, dir);\n    float sideT = dot(i, pTangent) - (Pi / 2.);\n    float sideBiT = dot(i, pBitangent) - (Pi / 2.);\n\tvec2 uv = (- 0.33) * (vec2(sideT, sideBiT));\n    return uv;\n}\n/**********************************************/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    #ifdef PLANEMODE\n    vec3 planeNormal;\n    vec2 vUV = uvPlane(fragCoord, planeNormal);\n    #else\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n    #endif\n\t\n\tC_Sample materialSample;\n\t\t\n\tfloat fNormalScale = 10.0;\n    \n    vec2 p = fragCoord / iResolution.xx;\n    \n    #ifdef ANIMATE\n    float animate = sin(iTime) / 10.0;\n    #else\n    float animate = 0.0;\n    #endif\n    \n    float selectNorm = smoothstep(0.3 + animate, 0.4 + animate, length(vec2(0.5, 0.5) - vUV));\n    \n    #ifdef FLATMODE\n    materialSample.vNormal = mix(normalize(voronoiFLAT(8.0 * p)), vec3(0.0, 0.0, 1.0), selectNorm);\n    #else\n    materialSample.vNormal = mix(normalize(voronoi(8.0 * p)), vec3(0.0, 0.0, 1.0), selectNorm);\n    #endif\n    \n    if (vUV.x < 1. && vUV.y < 1. && vUV.x > 0. && vUV.y > 0.) {\n        materialSample.vAlbedo = texture(iChannel0, normalize(planeNormal + materialSample.vNormal + vec3(vUV, 0.0))).xyz;\n        fragColor = vec4(materialSample.vAlbedo, 1.0);\n    } else {\n        fragColor =  texture(iChannel0, vec3(0.0, 0.0, 1.0) + vec3(fragCoord.xy / iResolution.xy, 0.0)); //fragColor = vec4(materialSample.vAlbedo, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}