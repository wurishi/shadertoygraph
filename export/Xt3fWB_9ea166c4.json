{"ver":"0.1","info":{"id":"Xt3fWB","date":"1540777460","viewed":1418,"name":"Gravitational Lensing Shader","username":"Yoshimaster96","description":"This shader creates a gravitational lens phenomenon that can be used for black hole rendering. It can also be modified to work with other massive bodies, though for most things the phenomena is not apparent.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["lens","approximation","einstein","gravity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GRAVITATIONAL LENSING SHADER\n// ============================\n// See the approximation for alpha on Wikipedia\n// https://en.wikipedia.org/wiki/Gravitational_lensing_formalism\n\n// Mass in geometrized units (c=G=1)\nfloat M = 0.2;\n\nvec3 rotate(vec3 a)\n{\n    vec3 b = a;\n    float sinT = sin(iTime);\n    float cosT = cos(iTime);\n    b.x = (cosT*a.x)-(sinT*a.z);\n    b.z = (sinT*a.x)+(cosT*a.z);\n    return b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Find our screen coordinates, correct for aspect\n    vec2 uv = ((fragCoord/iResolution.xy)*2.0)-vec2(1.0);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // We can form two right triangles like this:\n    //\n\t//     |\\   |\\     \n    //     | -\\ | \\    \n    // luv |   -\\  \\   \n    //     |    |-\\ \\  \n    //     ++   ++ -\\\\ \n    //     ++---++-----\n    //              | |\n    //          theta |\n    //             beta\n    //          \\--+--/\n    //             1   \n    //     \\----+-----/\n    //        into     \n    //\n    // alpha = theta-beta (the bending amount)\n    float theta = atan(length(uv));\n    // We are using geometrized units (c=G=1)\n    float alpha = (4.0*M)/length(uv);\n    float beta = theta-alpha;\n    float into = length(uv)/tan(beta);\t//tan(beta) == length(uv)/into\n    vec3 uvCube = vec3(uv,abs(into));\n    // Uncomment this for rotation\n   \t//uvCube = rotate(uvCube);\n    \n    // Test for event horizon (Schwarzschild radius)\n    float rS = step(2.0*M,length(uv));\n    // Sample our cubemap\n    fragColor = rS*vec4(texture(iChannel0,uvCube));\n}","name":"Image","description":"","type":"image"}]}