{"ver":"0.1","info":{"id":"NlscR2","date":"1649009192","viewed":81,"name":"TP 3 lifgraphique","username":"lea_02010","description":"Ce shader contient différentes textures ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lifgraphique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Texturing and noise \n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\nvec3 Noise3D (vec3 p)\n{\n    return vec3(Noise (p+vec3(1., 17., 36.)),\n                Noise (p+vec3(78., -4., -26.)),\n                Noise (p+vec3(-0.5, 8., -15.)));\n}\n\n \nvec3 turbulance3D (vec3 p, int octet, float e, float l) \n{\n    vec3 t = p; \n    for (int i = 0; i<octet;i++){\n        t += e*(1.0/pow (2.0,float (i)))*Noise3D (p / (l/pow(2.0,float(i))));\n    }\n    return t; \n}\n\n\nfloat turbulance (vec3 p, int octet, float e, float l) \n{\n    float t;\n    for (int i = 0; i<octet;i++){\n        t += e*(1.0/pow (2.0,float (i)))*Noise (p / (l/pow(2.0,float(i))));\n    }\n    return t; \n}\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// Camera -----------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    ro=vec3(35.0,0.0,15.0);\n    ro*=Rz(3.0*3.14*m.x); \n\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n//-------------------------------------------------------------------------------------------------------\n\n\n\n\n// Texturing\n// Eric Galin\n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct T {\nvec3 c; //couleur speculaire\nvec3 ca; //couleur ambiente \nvec3 cd; //couleur diffuse\nfloat s; //coef de pondération speculaire\nfloat a; //coef de pondération ambiant\nfloat d; //coed de pondération diffu \nfloat sigma; \n};\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n\n//Part_entiere\n//\nint part_e (float x)\n{\n    if (x>0.0) return int (x); \n    else return int (x)-1; \n}\n\nvec3 part_e (vec3 c)\n{\n    vec3 d; \n    d.x = float (part_e (c.x));\n    d.y = float (part_e (c.y));\n    d.z = float (part_e (c.z));\n    return d; \n}\n\n//Partie fractionnaire\n//\nfloat frac (float x)\n{\n    return x-float(part_e(x)); \n}\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nV Sphere(vec3 p, vec3 c,float r,int index)\n{\n  //float e = 0.2; //l'amplitude\n  //float l = 0.7; //longueur d'onde\n  //p+=e*Noise3D(p/l); //fbm\n  //p = turbulence (p, 2,e, l); \n  return V(length(p-c)-r,index);\n}\n\n// Cube \n// p : point\n// c : center \n// r : radius\nV Cube(vec3 p,vec3 c,float r,int index)\n{\n   vec3 q = abs(p-c) - vec3(r);\n  return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),index);\n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nV Plane(vec3 p, vec3 n, vec3 o,int index)\n{\n    p = turbulance3D (p, 3, 0.2, 0.7); \n    return V(dot((p-o),n),index);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,a.i);\n    }\n}\n\n// Dice \n// p : point\n// c : center \n// r : radius\nV Dice(vec3 p,vec3 c,float r,int index)\n{\n  return Intersection(Cube(p,c,r*0.75,index),Sphere(p,c,r,index));\n}\n\n// Potential field of the object\n// p : point\nV object(vec3 p)\n{\n  V u = Plane(p,normalize(vec3(0.0,0.0,1.0)),vec3(0.0,0.0,-4.0),0);\n  \n  u=Union(u,Dice(p,vec3( 0.0, 0.0, 2.0),4.0,1));\n  u=Union(u,Sphere(p,vec3( -10.0, 0.0, 2.0),4.0,2));\n  u=Union(u,Dice(p,vec3( 10.0, 0.0, 2.0),4.0,3));\n \n  return u;\n}\n\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  V vp = object(p);\n    float v = vp.v;\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.65,0.75,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n\n// Direct lighting\nfloat Light(vec3 p,vec3 n)\n{\n   // point light\n  const vec3 lp = vec3(5.0, 10.0, 25.0);\n\n  vec3 l = normalize(lp - p);\n\n  // Phong shading\n  float diff = clamp(dot(n, l),0.0,1.0);\n\n    bool h;\n    int s;\n    float t=SphereTrace(p+0.1*n,l,100.0,h,s);\n    if (!h)\n    {\n         return diff;\n    }\n    return 0.0; \n}\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\n// Texture de couleur grise \n// p : Point\nT Texture0(in vec3 p)\n{\n  return T(vec3(1., 0.75, 0.31), \n           vec3(0.80,0.80,0.80),\n           vec3(0.7, 0.63, 0.52),\n           0.25, 0.5, 0.5, 28.);   \n}\n\n\n// Texture de couleur rose pastel\n// p : Point \nT Texture1(in vec3 p)\n{\n  return T(vec3(1., 0.75, 0.31), \n           vec3(0.82,0.81,0.90),\n           vec3(0.7, 0.63, 0.52),\n           0.25, 0.5, 0.5, 28.); \n}\n\n\n// Texture de couleur vert pastel\n// p : Point\nT Texture2(in vec3 p)\n{\n  return T(vec3(1., 0.75, 0.31), \n           vec3(0.82,0.91,0.80), \n           vec3(0.7, 0.63, 0.52),\n           0., 0.5, 0.5, 28.);   \n}\n\n\n// Texture de couleur bleu pastel\n// p : Point \nT Texture3(in vec3 p)\n{\n  return T(vec3(1., 0.75, 0.31), \n           vec3(0.82,0.91,0.90),\n           vec3(0.7, 0.63, 0.52),\n           0., 0.5, 0.5, 28.);   \n}\n\n\n// Création de la texture Damier\n// p : Point \nT Damier(in vec3 p)\n{\n  //Définition des textures du damier \n  T color1 = T(vec3(1., 0.75, 0.31), \n               vec3(0.80,0.80,0.80),\n               vec3(0.7, 0.63, 0.52),\n               0.25, 0.5, 0.5, 28.);\n  T color2 = T(vec3(1., 0.75, 0.31), \n               vec3(0.),\n               vec3(0.7, 0.63, 0.52),\n               0.25, 0.5, 0.5, 28.);\n  // Calcul la partie entière des coordonnées de p \n  int x = part_e(p.x);\n  int y = part_e (p.y);\n  int z = part_e (p.z);\n  \n  // Sépare l'espace en 2 puis donne une texture différente à chaque espace\n  // On peut faire un damier avec plus de deux couleurs en séparant l'espace \n  // plus que deux fois donc en modifiant le modulo\n  if ((x+y+z) % 2 == 0) \n    return color1;  \n             \n  else return color2; \n}\n\n// Création de la texture Damier décalé \n// p : Point\nT DamierD (in vec3 p)\n{\n    // Créer un bruit sur p d'amplitude e et de longueur d'onde l \n    float e = 0.3;\n    float l = 0.1;\n    p += e * Noise3D(p/l); \n    \n    // Retourne le damier avec le bruit sur le p, les séparations \n    // entre les cases ne seront donc plus droite mais un peu ondulé \n    // ou totalement déformé en fonction de l'amplitude et de la longueur \n    // d'onde \n    return Damier (p);\n}\n\n\n// Création de la texture de Bois \n// p : Point\nT Bois(in vec3 p)\n{\n  // Définition des deux couleurs du bois \n  vec3 c1 = vec3(0.7, 0.55, 0.3);\n  vec3 c2 = vec3(0.4, 0.3, 0.1);\n  \n  // Créer un bruit sur p d'amplitude e et de longueur d'onde L\n  float e = 0.2; \n  float L = 0.7; \n  p+=e*Noise3D(p/L);\n  \n  float d = length (p.xy); // Calcul la distance de p à l'axe des z \n  float l = 0.2;\n  float v = (cos (d/l) + 1.)/2.0; // Renvoie une valeur entre 0 et 1\n  \n  // Permet de faire les cercles de couleurs, en faisant l'interpolation des \n  // deux couleurs avec une valeur qui change en fonction de d \n  // l correspond à la longueur d'onde des rayures, plus on l'augmente, moins\n  // il y aura de rayure\n  vec3 c = mix (c1, c2, v); //(c1.c * v + c2.c * (1.0-v))\n  \n  return T (vec3(1., 0.75, 0.31),\n            c, \n            vec3(0.7, 0.63, 0.52),\n            0., 0.5, 0.5, 28.);\n}\n\n// Création de la texture Marbre avec plusieurs veines raides\n// p : Point\nT Marbreraide (vec3 p)\n{\n    // Définition des textures de la base du marbre ainsi que les textures \n    // des différentes veines\n    T fond = T(vec3(1., 0.75, 0.31), \n               vec3 (0.982, 0.92, 0.82),\n               vec3(0.7, 0.63, 0.52),\n               1., 0.5, 0.5, 28.); \n               \n    T ray1 = T(vec3(1., 0.75, 0.31), \n               vec3 (0.65),\n               vec3(0.7, 0.63, 0.52),\n               1., 0.5, 0.5, 28.);\n               \n    T ray2 = T(vec3(1., 0.75, 0.31), \n               vec3 (0.32),\n               vec3(0.7, 0.63, 0.52),\n               1., 0.5, 0.5, 28.);\n    \n    // On fait une turbulance sur p pour que les rayures \n    // soit déformé et ne soit pas toute droite \n    p = turbulance3D (p, 2, 2., 1.);\n    \n    // On va créer les veines de texture ray1 sur l'axe des z\n    float z = p.z; \n    z = fract (z); // on prend la partie fractionnaire de z \n    \n    // La rayure aura 0.1 d'épaisseur \n    // Comme on prend la partie fractionnaire, les rayures \n    // seront espacé de 1 \n    if (z<0.1) \n    {\n        return ray1;\n    }\n    \n    // On procède de la même pour les veines de textures ray2 \n    // sur l'axe des y\n    float y = p.y; \n    y = fract (y); \n    \n    if (y<0.1)\n    {\n        return ray2;\n    }\n    \n    // Avec cette technique on peut créer un marbre de maximum \n    // trois veines différentes, une sur l'axe des x, une sur \n    // l'axe des y et une sur l'axe des z\n    return fond; \n}\n\n// Création de la texture Marbre à veines lisses\n// p : Point\nT Marbrelisse (vec3 p)\n{\n    // Définition de la couleur de la base du marbre et des veines\n    vec3 fond = vec3 (0.982, 0.93, 0.92); \n    vec3 ray1 = vec3 (0.65);\n    \n    // On fait une turbulance sur p pour que les rayures \n    // soit déformé et ne soit pas toute droite \n    p = turbulance3D (p, 3, 4., 2.);\n    \n    // On va créer les veines à partir de l'axe des z \n    float z = p.z; \n    z = fract (z); // On prend la partie fractionnaire de z\n    \n    // smoothstep : fonction qui permet de renvoyer 0 si z est \n    // inférieur à 0, de renvoyer 1 si z est supérieur à 0.4 et\n    // de renvoyer une valeur entre 0 et 1 si z se trouve entre 0.\n    // et 0.4 \n    float u = smoothstep (0., 0.4, z);\n   \n    // mix : Permet de faire l'interpolation linéaire entre les \n    // deux vecteurs (les deux premiers paramètres) à partir de  \n    // la valeur d'interpolation (ici u) \n    vec3 color = mix (ray1, fond, u); \n    \n    return T(vec3(1., 0.75, 0.31), \n             color, \n             vec3(0.7, 0.63, 0.52),\n             1., 0.5, 0.5, 28.); \n}\n\n// Création de la texture sable\n// p : Point \nT Sable (vec3 p)\n{\n    // Définition des deux couleurs qui composeront le sable \n    vec3 jaune = vec3 (0.88,0.8, 0.66);\n    vec3 gris = vec3 (0.9); \n    \n    // On fait une interpolation linéaire entre les deux couleurs \n    // avec comme valeur d'interpolation Noise(p/0.05) on choisit \n    // cette valeur qui va renvoyer une valeur au hasard\n    // Plus on divise p plus on obtiendra un grain de sable fins\n    vec3 c = mix (jaune, gris, Noise(p/0.05));\n    \n    return T(vec3(1., 0.75, 0.31), \n             c,\n             vec3(0.7, 0.63, 0.52),\n             0., 0.5, 0.5, 28.);  \n}\n\n// Création de la texture d'une tâche de rouille \n// p : Point \nT tache (vec3 p) \n{\n    // Définition des couleurs de la tâche de rouille \n    vec3 rouge = vec3 (0.34, 0.14, 0.14);\n    vec3 rouille = vec3 (0.65, 0.18, 0.); \n    \n    // On procède de la même manière que le sable \n    vec3 c = mix (rouille, rouge, Noise(p/0.05));\n    \n    return T(vec3(1., 0.75, 0.31), \n             c,\n             vec3(0.7, 0.63, 0.52),\n             0., 0.5, 0.5, 28.); \n}\n\n// Création de la texture d'un métal rouillé \n// p : Point \nT Metalrouille (vec3 p)\n{\n    // Définition des textures du métal et de la rouille \n    T metal = T(vec3(1., 0.75, 0.31),\n                vec3(0.3), \n                vec3(0.7, 0.63, 0.52),\n                1., 0.5, 0.5, 28.);\n    T rouille = tache (p);\n    \n    // On créé une nouvelle variable, n, ou on met une turbulance \n    // de p dedans c'est ce qui nous aidera à définir nos tâches \n    // de rouille \n    float n = turbulance (p/5., 3, 0.6, 0.1 );\n    \n    // On met un seuil sur n, pour définir notre tâche\n    // Ici, si n est inférieur à 0.6 on place la texture rouille, \n    // sinon on place la texture de métal \n    if (n<0.6)\n    {\n        return rouille;\n    }\n    return metal;\n}\n\n// Création de la texture de bois avec noeuds \n// p : Point \nT BoisNoeud (vec3 p)\n{\n    // Définition de la texture du bois et de la couleur des noeuds \n    T bois = Bois (p); \n    vec3 noeud = vec3(0.3, 0.2, 0.05);\n    \n    // On cherche le centre du cube unité d'ou se trouve p\n    vec3 c = part_e (p) + vec3 (0.5); \n    \n    // On initialise un booléen e qui va nous permettre de \n    // savoir si on affiche ou pas les noeuds \n    bool e = true ;\n    \n    // On choisit si on affiche ou pas notre noeud, si la \n    // fonction renvoie une valeur inférieur à 0.8 on n'affiche\n    // pas le noeud donc on met à faux notre booléen \n    if (Noise (c*50.) <(0.6)) \n      e = false ; \n    \n    // Si on est sur un noeud on va placer notre texture noeud \n    // une fois qu'on aura définis le cercle du noeud \n    if (e == true )\n    {\n        // Calcul la distance entre p et c (le centre de note cube)\n        float d = length (p-c); \n        \n        // Définition du rayon d'un noeud \n        const float rayon = 0.5; \n        \n        // On regarde si p est dans le noeud ou pas\n        if (d <= rayon) \n        {\n            // On fait une interpolation entre la couleur du bois et \n            // du noeud pour que la différence de couleur soit \n            // progressive \n            float u = 1. - smoothstep (0., rayon, d); \n            vec3 noeud2 = mix (bois.ca, noeud, u);\n           \n            return T(vec3(1., 0.75, 0.31),\n                     noeud2, \n                     vec3(0.7, 0.63, 0.52),\n                     0., 0.5, 0.5, 28.);\n        }\n    }\n    \n    // Si p n'appartient pas à un noeud on place la texture de bois \n    return bois; \n}\n\nvec4 deg (vec3 p, vec3 c, float r){\n\n    if (p==c){\n        return vec4( 0.5,0.5,0.,1.); \n    }\n    \n    if (length(p-c)==r){\n        float alpha = smoothstep (0.,1., p.x); \n        return vec4(1., 0.,0., alpha); \n    }else{\n        vec3 s = smoothstep(c, c+r, p); \n        vec3 m = mix( vec3(0.5, 0.5, 0.), vec3(1., 0., 0.), s); \n        return vec4(m, 1.); \n    }\n}\n\nvec3 degrade (vec3 p, vec3 c, float r){\n\n    if (length (p-c) < 5.){\n        return vec3( 1.,1.,0.); \n    }\n    \n    if (length(p-c)>r){\n    //length (p-c.xy)\n        float u = smoothstep (0., r, length(p-c)); \n        return mix (vec3( 0.), vec3(1.,0.,0.),vec3(length(p-c)));\n    }else{\n        vec3 s = smoothstep(c, c+r, p); \n        vec3 m = mix( vec3(0.5, 0.5, 0.), vec3(1., 0., 0.), s); \n        return m; \n    }\n}\n\nT degrad (vec3 p, vec3 c, float r){\n\n    return T(vec3(1., 0.75, 0.31),\n                degrade (p, c, r), \n                vec3(0.7, 0.63, 0.52),\n                1., 0.5, 0.5, 28.);\n}\n\n\n// Compute texture \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= object(p);\n    if (vp.i==0){\n        \n        return degrad(p, vec3(0.), 10.);\n    }\n    else if (vp.i==1)\n    {\n        return Damier(p);\n    }\n    else if (vp.i==2)\n    {\n        return Damier(p);\n    }\n    else if (vp.i==3)\n    {\n        return Metalrouille(p);\n    }\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p,l,100.0,h,s);\n    if (!h)\n    {\n     return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    T tex=Color(p,n);\n\n//c = a x ma x white + d x md x white x (n.l) + c x ms x white x(r.v) ^sigma\n\n    // Ambient color\n    vec3 ambient = tex.a*tex.ca; // 0.5 = a\n        \n    // Shadow computation\n    float s = Shadow(p+0.01*n,n,l);\n\n    // Phong diffuse\n    vec3 diffuse = tex.d  * clamp(dot(n, l),0.0,1.0) * tex.cd; // 0.5 = d\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = tex.c * tex.s * pow(clamp(dot(r,l),0.0,1.0),tex.sigma); // vec3 (1.) = white \n    vec3 c = ambient + s * (diffuse + specular);\n    return c;\n}\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}