{"ver":"0.1","info":{"id":"cts3Rj","date":"1672049539","viewed":153,"name":"Tricubic texture sampling","username":"JuanDeager","description":"Tricubic filtering vs trilinear filtering with cubic interpolation vs regular trilinear filtering.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["spline","bicubic","interpolation","rand","tricubic","hermit","samplingrnd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"tricubic 3Dtexture interpolation\" by FabriceNeyret2. https://shadertoy.com/view/MtjBWz\n// 2022-12-26 09:41:43\n\n// volumetric variant of  https://shadertoy.com/view/XlBBRR\n\n// Ported from here: https://gist.github.com/Fewes/59d2c831672040452aa77da6eaab2234\nvec4 textureCubic(sampler3D volume, vec3 coord)\n{\n    vec3 texSize = iChannelResolution[0].xyz;\n    \n\t// Shift the coordinate from [0,1] to [-0.5, textureSize-0.5]\n\tvec3 coord_grid = coord * texSize - 0.5;\n\tvec3 index = floor(coord_grid);\n\tvec3 fraction = coord_grid - index;\n\tvec3 one_frac = 1.0 - fraction;\n\n\tvec3 w0 = 1.0/6.0 * one_frac*one_frac*one_frac;\n\tvec3 w1 = 2.0/3.0 - 0.5 * fraction*fraction*(2.0-fraction);\n\tvec3 w2 = 2.0/3.0 - 0.5 * one_frac*one_frac*(2.0-one_frac);\n\tvec3 w3 = 1.0/6.0 * fraction*fraction*fraction;\n\n\tvec3 g0 = w0 + w1;\n\tvec3 g1 = w2 + w3;\n\tvec3 mult = 1.0 / texSize;\n\tvec3 h0 = mult * ((w1 / g0) - 0.5 + index); //h0 = w1/g0 - 1, move from [-0.5, textureSize-0.5] to [0,1]\n\tvec3 h1 = mult * ((w3 / g1) + 1.5 + index); //h1 = w3/g1 + 1, move from [-0.5, textureSize-0.5] to [0,1]\n\n\t// Fetch the eight linear interpolations\n\t// Weighting and fetching is interleaved for performance and stability reasons\n\tvec4 tex000 = textureLod(iChannel0, h0, 0.);\n\tvec4 tex100 = textureLod(iChannel0, vec3(h1.x, h0.y, h0.z), 0.0);\n\ttex000 = mix(tex100, tex000, g0.x); // Weigh along the x-direction\n\n\tvec4 tex010 = textureLod(iChannel0, vec3(h0.x, h1.y, h0.z), 0.0);\n\tvec4 tex110 = textureLod(iChannel0, vec3(h1.x, h1.y, h0.z), 0.0);\n\ttex010 = mix(tex110, tex010, g0.x); // Weigh along the x-direction\n\ttex000 = mix(tex010, tex000, g0.y); // Weigh along the y-direction\n\n\tvec4 tex001 = textureLod(iChannel0, vec3(h0.x, h0.y, h1.z), 0.0);\n\tvec4 tex101 = textureLod(iChannel0, vec3(h1.x, h0.y, h1.z), 0.0);\n\ttex001 = mix(tex101, tex001, g0.x); // Weigh along the x-direction\n\n\tvec4 tex011 = textureLod(iChannel0, vec3(h0.x, h1.y, h1.z), 0.0);\n\tvec4 tex111 = textureLod(iChannel0, h1, 0.0);\n\ttex011 = mix(tex111, tex011, g0.x); // Weigh along the x-direction\n\ttex001 = mix(tex011, tex001, g0.y); // Weigh along the y-direction\n\n\treturn mix(tex001, tex000, g0.z); // Weigh along the z-direction\n}\n\nvec4 rndC(vec3 u) {                       // tricubic interpolation ( 1 single fetch: thanks iq :-) )\n    vec3 R = iChannelResolution[0].xyz,\n         U = u*R + .5,\n         F = fract(U);\n    U = floor(U) + F*F*(3.-2.*F); \n // U = floor(U) + F*F*F*(F*(F*6.-15.)+10.);   // use if you want smooth gradients\n    return texture( iChannel0, (U-.5) / R );\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv2 = uv;\n    uv2.x *= aspect;\n    \n    vec3 V = 0.5 * vec3(uv2, 0.05 * iTime);\n    \n    if (uv.y >= 2./3.)\n    {\n        fragColor = textureCubic(iChannel0, V);\n    }\n    else if (uv.y >= 1./3.)\n    {\n        fragColor = rndC(V);\n    }\n    else\n    {\n        fragColor = texture(iChannel0, V);\n    }\n    \n    if (uv.x>0.5) fragColor = sin(10.*fragColor);\n}\n","name":"Image","description":"","type":"image"}]}