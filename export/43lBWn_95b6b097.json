{"ver":"0.1","info":{"id":"43lBWn","date":"1728265896","viewed":243,"name":"Codecrafted Sentinel [Kali/LIA]","username":"Kali","description":"Shadertoy version of my entry for Flashparty 2024 freestyle graphics compo. Won 1st place. ","likes":36,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","bloom","robot","scifi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float max_rad=.01;\nconst float it=100.;\n\nuniform float force ;\n\n#define time min(2.,float(iFrame)/60.)\n\n#define tx iChannel0\n#define texture2D texture\n\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat hash(vec2 p)\n{\n    p*=1342.;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd(float p)\n{\n    p*=123.;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2=floor(uv*200.)/200.;\n    //uv=uv2;\n\tmat2 spin=rot(2.39996);\n    vec2 p=vec2(0.,1.);\n    vec3 res=vec3(0.);\n    float ti=mod(time*.5,10.);\n    float rad_step=max_rad/it+hash(uv+ti)*.0003;\n\tfloat rad=0.;\n    float vhs=step(.98,hash(uv2.yy+ti))*(1.+sin(uv2.y*5.+ti))*step(.5,hash(uv2.xy+ti))*smoothstep(0.,1.,uv2.y);\n    //vec4 col=texture2D(tx,uv+.05*step(.98,hash(uv2.yy+floor(time*10.)))*step(.5,hash(uv2.xx+time))*.7);\n    //if(fxrand>.8) \n    //uv.y+=vhs*.1;\n    vec4 col=texture2D(tx,uv);\n    //uv=floor(uv*50.)/50.;\n    for (float i=0.;i<it; i++) {\n        rad+=rad_step;\n        p*=spin;\n        vec4 col=texture2D(tx,uv+p*rad);\n        res+=smoothstep(.5,1.3,max(col.r,max(col.g,col.b)))*col.rgb;\n    }; \n    res/=it;\n    //if(fxrand>.8)\n    //col+=vhs*.5;\n    //\n    vec4 ff = vec4(col.rgb*.5+res,1.0)*1.4;//*mod(gl_FragCoord.y,2.)*.87; \n    ff.rgb=mix(vec3(length(ff.rgb*.5)),ff.rgb,.7);\n    //ff.rgb=max(vec3(.12),ff.rgb);\n  //  ff.rgb=pow(abs(col.rgb),vec3(1.3));\n    //ff.g=min(ff.r*1.5,ff.g);\n    //ff.g=min(ff.b*1.5,ff.g);\n//    ff.rgb=vec3(step(hash(vTexCoord+time),.5*length(ff.rgb)));\n //   ff.rgb*=vec3(1.2,1.,.8);\n    //ff.a=max(.1,exp(-time));\n    //if (rnd(fxrand)>.85) ff.rgb=length(ff.rgb)*vec3(.4,.5,.6);\n    //ff*=step(1.3-vTexCoord.y-length(col.rgb)*.3+.2-hash(vTexCoord.xx)*.1,time*.5);\n   \n    fragColor = ff;\n    //gl_FragColor = vec4(col.rgb,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define resolution iResolution.xy\n#define vTexCoord (gl_FragCoord.xy/iResolution.xy)\n#define PI 3.1416\n#define time min(2.,float(iFrame)/60.)\n\nfloat det=.001;\n\nfloat hash(vec2 p)\n{\n    p*=1342.;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Función de ruido 1D\nfloat noise1d(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    \n    // Interpolación cúbica suave\n    float u = f * f * (3.0 - 2.0 * f);\n    \n    // Mezcla de valores aleatorios\n    return mix(hash(vec2(i, 0.0)), hash(vec2(i + 1.0, 0.0)), u);\n}\n\n\nfloat kset(vec3 p)\n{\n    for(int i=0; i<12; i++) {\n        p=abs(p)/dot(p,p)-.8;\n    }\n    return clamp(0.,1.,length(p));\n}\n\nfloat rnd(float p)\n{\n    p*=1234.;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n// Función smax de Inigo Quilez (iq)\nfloat smax(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + h * h * 0.25 / k;\n}\n\n// Función smin de Inigo Quilez (iq)\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\n\nfloat segment(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat torus(vec3 p, float r1, float r2)\n{\n    vec2 q = vec2(length(p.xz) - r1, p.y);\n    return length(q) - r2;\n}\n\n\nvec3 circuits1(vec3 p) {\n    float c1=1000.;\n    float c2=1000.;\n    for(int i=0; i<6; i++) {\n        p=abs(p)/clamp(abs(p.x*p.y),0.3,2.)-1.;\n        c1=min(c1,abs(p.x));\n        if (i<3) c2=min(c2,abs(p.y));\n    };\n    float m=step(c1,.05);\n    return vec3(c1,c2,m);\n}\n\nfloat legs(vec3 p) {\n    float z=p.z;\n    p.y+=4.3;\n    p.z-=2.2;\n    vec2 s=sign(p.xz)*.5;\n    p.xz=abs(p.xz)-.8;\n    float d=segment(p,vec3(0.,0.,.5),vec3(1.,1.-s.x*.3,2.),.5);\n    d=min(d,segment(p,vec3(1.,1.-s.x*.3,2.),vec3(1.5,-2.7,1.+s.x),.6));\n    float c=circuits1(p).y;\n    d-=c*.15;\n    d=max(d,z-2.5);\n    return d;\n}\n\nfloat body(vec3 p) {\n    p.z*=1.;\n    p.y+=2.7;\n    p.z+=.0;\n    //p.x+=1.5;\n    float d=length(p)-1.5-smoothstep(1.,.5,p.y)*1.3+abs(p.x)*.2+abs(p.z)*.2+smoothstep(-.3,-.1,p.y)*.8;\n    float c=circuits1(p+vec3(.0,-1.,0.)).y;\n    p.y-=1.;\n    d-=c*.2;\n    return d;\n}\n\n\nfloat ray;\nfloat gun;\nfloat armcyl;\nfloat pinzas;\nvec3 gunpos=vec3(4.,-1.,-2.);\nvec3 posi;\nfloat arms(vec3 p) {\n    float x=p.x;\n    if (x<0.) p.yz*=rot(-.5);\n    p.x=abs(p.x);\n    p.y+=.7+smoothstep(3.,4.,abs(p.x))*.2;\n    p.xz*=rot(-.2);\n    float dif=step(x,0.)*.5;\n    float s1=segment(p*(1.+vec3(p.z*p.z*.2,0.,.0)),vec3(3.5,1.,1.+dif*1.5),vec3(4.5,-dif,dif-1.),.35)+length(sin(p*40.))*.03;\n    float s2=segment(p,vec3(3.9+dif*.7,-dif,dif-1.),gunpos,.3-p.z*.2);\n    s2-=circuits1(p.xzy).x*.1;\n    gun=min(s1,s2);\n    armcyl=s1;\n    float d=smin(s1,s2,.05);\n    p-=gunpos;\n    vec3 p2=p;\n    p2.xy*=rot(-.5);\n    p2.xz*=rot(-.0);\n    p2.yz*=rot(-.3);\n    p2.xy=abs(p2.xy)-.13;\n    ray=length(p2.xy)-.12;\n    ray=max(ray,abs(p2.z)-2.);\n    ray=max(ray,-length(p2.xy)+.1)+length(sin(p2*50.))*.0;\n    posi=p2;\n    pinzas=1000.;\n    if (x>0.) d=smax(d,-ray+.1,.1);\n    else {\n        p.xy*=rot(-.4);\n        p.x=abs(p.x);\n        p.xy*=rot(.4);\n        p.z+=.7;\n        p.xy=abs(p.xy)-.4+p.z*.5+smoothstep(-0.5,-1.1,p.z)*.7;\n        pinzas=segment(p,vec3(0.,0.,.5),vec3(0.,0.,-1.),.1)*.9;\n        d=min(d,pinzas);\n    }\n    if (x>0.) d=min(ray,d);\n    return d*.7;\n}\n\nfloat eye;\nfloat ot;\nfloat cup;\nvec3 hpos;\nfloat head(vec3 p) {\n    vec3 p2=p;\n    vec3 p3=p;\n    p.y+=abs(p.x)*.1;\n    hpos=p;\n    p.z-=p.y*.3;\n    float d=length(p)-3.+smoothstep(1.,.0,p.y)*.8-smoothstep(1.,.0,abs(p.x))*.2;\n    vec3 f=circuits1(p*.5+vec3(0.,.6,0.))*smoothstep(0.,1.,p.y+1.5);\n    ot=f.z;\n    d-=f.x*.1-f.y*.2;\n    d=min(d,torus(p.zxy,1.39,1.));\n    float x=p.x;\n    p.x=abs(p.x)-2.5;\n    d=min(d,min(torus(p.zxy+vec3(-.3,0.,-.7),1.,.2),torus(p.zxy+vec3(-.3,-.3,-.6),.5,.2))-f.x*.05);\n    p.x=abs(x)-1.;\n    vec2 q = abs(p.xy-p.y*.2) - vec2(.3,.1);\n    eye = max(length(max(q, 0.0)) + min(max(q.x, q.y), 0.0)-.15,-p.x-.4);\n    d=smax(d,-eye,.2);\n    d=min(d,max(eye,abs(p.z+2.6-abs(x)*.7+p.y*.5)-.1)+f.x*.01);\n//    d=max(d,abs(p.x)-1.3);\n    d-=step(abs(x),.5)*.2;\n    p2.x=abs(p2.x)-1.3;\n    d=smax(d,-length(p2.xy-vec2(.0,2.3))+.5,.2);\n    p3.y-=1.5;\n    p3.z-=1.;\n    cup=abs(length(p3)-1.6-sin(time*10.)*.01)-.0;\n    cup=max(.05,abs(cup));\n    d=smin(d,cup,.5);\n    return d*.3;    \n} \n\n// Función de smooth clamp\nfloat sclamp(float x, float a, float b, float suavidad) {\n    float t = clamp((x - a) / (b - a), 0.0, 1.0);\n    float s = t * t * (3.0 - 2.0 * t);\n    float mezcla = mix(a, b, s);\n    return mezcla + (b - a) * 0.5 * (1.0 - cos(3.14159265359 * pow(abs(x - mezcla), suavidad)));\n}\n\n\n\nfloat tr;\nfloat asurf(vec3 pos) {\n    float y=pos.y;\n    tr=1000.;\n    pos.yz*=rot(.2);\n    pos.xz*=rot(.61);\n    float zoo=.01;\n    pos*=zoo;\n    pos.x+=0.6;\n\tpos.y+=.57;\n    pos.z+=2.1;\n    float z=pos.z;\n    //pos.z+=iTime*2.;\n    float fold=2.5;\n\tpos.z=abs(5.-mod(pos.z,10.));\n\tpos.x-=fold;\n    vec4 p=vec4(pos,1.);\n    vec3 m=vec3(1000.);\n    float sm=0.;\n    float l2;\n\tfor (int i=0; i<12; i++) {\n\t\tp.xz=clamp(p.xz,-vec2(fold,2.),vec2(fold,1.985))*2.0-p.xz;\n\t\tp.xyz-=vec3(0.5,.793,1.);\n        p=p*2./clamp(dot(p.xyz,p.xyz),.2,1.)-vec4(2.0,.51,-1.,-1.);\n        p.xz*=rot(.965);\n\t\tp.xy*=rot(.448);\n        m=min(m,abs(p.xyz));\n        tr=min(tr,abs(p.x));\n        float l=length(p.xy);\n        sm+=exp(-2.*abs(l2-l));\n        l2=l;\n\t}\n    tr=sm*.5;\n    float d=(max(p.y-60.,max(p.x,p.x))-7.)/p.w/zoo-length(noise1d(pos.y*1000.+1.)*0.3)*.02+step(vTexCoord.y+abs(vTexCoord.x-.5)*.5,.11)*.0;\n    d=max(d,y-25.)+.01;\n    return d*1.5;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n\nfloat building(vec3 p) {\n    p.xz*=rot(.15);\n    float z=p.z-10.;\n    float x=p.x;\n    p.x+=50.;\n    vec3 f=circuits1(fract(p*.2)+vec3(0.,-7.,0.));\n    vec2 id=floor(p.xz/6.);\n    p.xz=mod(p.xz,6.)-3.;\n    float an=hash(id+.1)+1.;\n    float d=box(p+vec3(hash(id.yy+1.)*3.,0.,0.), vec3(an,5.+hash(id+.2)*10.,an));\n    d=max(d,-z+32.);\n    d=max(d,x+27.);\n    d-=f.x*.3-f.z*.2;\n    return d;\n}\n\n\n\nvec3 bodypos;\nfloat he;\nfloat bo;\nfloat as;\nfloat frhead=0.;\nfloat de(vec3 p) {\n    float d=1000.;\n    as=asurf(p);\n    vec3 p2=p;\n    he=head(p2);\n    float ar=arms(p2);   \n    float bu=building(p);\n    p2.xz*=rot(.2);\n    bodypos=p2;\n    bo=body(p2);\n    float le=legs(p2);\n    d=min(d,as);\n    d=min(d,bu);\n    d=min(d,bo);\n    d=smax(d,-le,1.6);\n    d=min(d,he);\n    d=min(d,ar);\n    d=min(d,le);\n    frhead=0.;\n    if (d==he) frhead=ot;\n    return d;\n}\n\nvec3 normal2(vec3 p)\n{\n    vec2 e=vec2(0.,det);\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\nvec3 normal(vec3 pos) {\n    vec2 e=vec2(0.,det);\n    vec3 ev[4];\n\tev[0]=e.yxx;\n\tev[1]=e.xyx;\n\tev[2]=e.xxy;\n\tev[3]=e.xxx-.000001;\n\t//vec3[4](e.yxx, e.xyx, e.xxy, e.xxx-.000001);\n    vec3 nn = vec3(0);\n    for(int i = 0; i<4; i++){\n        nn += sign(ev[i])*de(pos + ev[i]);\n        if(nn.x<-1e8) break; // Fake break.\n    } \n    return normalize(nn);\n}\n\nfloat shadow(vec3 ro, vec3 rd) {\n    float res = 1.0;\n    float t = 0.01;\n    for (int i = 0; i < 150; i++) {\n        float h = de(ro + rd * t);\n        if (h>10000.) break;\n        res = min(res, 50.0 * h / t);\n        t += clamp(h, 0.02, 0.05);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n#define eyecolor vec3(.35,.75,.25)\n#define basecolor vec3(1.2,.8,.5)\nvec3 march(vec3 from, vec3 dir) \n{\n    float td=0.,d=0.,maxdist=100.,g=0.,g2=0.;\n    vec3 p=from,col=vec3(.0);\n    float h=hash(dir.xy+mod(time,10.))-.5;\n    float ref=0.;\n    for (int i=0; i<300; i++)\n    {\n        p+=dir*d*(1.+h*.2);\n        d=de(p);\n        if ((d<det) || td>maxdist) break;\n        if (cup<.5) g=.7;\n        g2+=.1/(.1+cup);\n        td+=d;\n    }\n    if (d<.1) \n    {   \n        vec3 bpos=bodypos;\n        float ra=ray;\n        float ey=eye;\n        float gu=gun;\n        float ar=armcyl;\n        float frh=frhead*step(abs(p.x),2.)*step(g,.01);\n        float hea=he;\n        float bod=bo;\n        float asu=as;\n        float o=ot;\n        float tra=tr;\n        float pin=pinzas;\n        vec3 pos=posi;\n        vec3 hp=hpos;\n        vec3 ldir=vec3(-1.2,.3,-1.5);\n        ldir=normalize(ldir);\n        vec3 n=normal(p);\n        float sh=shadow(p,ldir);\n        sh=max(sh,step(bo,.01));\n        vec3 rf=reflect(dir,n)*sh;\n        col=(basecolor+rf*.2)+step(min(pin,ra),.01)*vec3(0.,.5,.3)+g*eyecolor;\n        vec3 id=floor(p/15.);\n        col+=step(.01,g)*step(length(fract(p*15.)-.5),hash(id.xz)*1.5)*vec3(1.,5.,1.)*2.;\n        if (asu<.01) col=vec3(.5,.65,.5)+tr*vec3(.5,1.,0.)*smoothstep(1.5,0.,vTexCoord.x);\n        col*=.7+frh*.2;\n        col*=1.+(kset(fract(p)*.25)-.5)*.5;\n        if (ar<.02) col*=.6;\n        col*=max(max(0.,dot(dir,-n))*.5*vec3(.0,.5+frh*.5,1.5+frh*.5)*1.5,max(0.,dot(ldir,n))*(sh*.5+.5)*.7*(.5+step(g,.1)*.5))*vec3(1.7,.8,.7);\n        col+=pow(max(0.,max(0.,dot(rf,ldir))*sh),10.)*.3;\n        vec3 cir=circuits1(bpos*.5+vec3(0.,-1.5,0.));\n        col+=cir.z*step(bod,.01)*vec3(.2,1.,.3)*exp(abs(bpos.x)*-.8)*cir.y*.7;\n //       col*=exp(-ey)*1.5;\n //       col*=mix(vec3(1.),vec3(10.,1.0,1.0),smoothstep(1.,2.,length(gunpos-p))*exp(-.8*length(gunpos-p)));\n        col+=eyecolor*exp(-ey*7.)*.5;\n        float pun=step(length(fract(p*20.)-.5),.35);\n        vec3 puncol=eyecolor*1.5;\n        puncol.gb*=rot(p.y*.7+1.);\n        col+=pun*smoothstep(0.,-3.,p.y+abs(p.x)*.2)*puncol*1.5*step(.5,abs(p.x))*step(hea,.01);\n        if (ey<-.05) col=eyecolor+step(circuits1(hp).x,.1)*.2;\n        vec3 p2=pos;\n        if (ra<.1 && p.x>0.) {\n            col+=smoothstep(.0,1.,abs(.5-fract(atan(p2.x,p2.y)*.5+.4)))*.4;\n//            col=mix(col,eyecolor*1.5,step(p.z,-4.6));\n        }\n    }\n    else\n    {\n        col=mix(vec3(2.5,.8,.7),vec3(0.3,0.3,.4),smoothstep(.0,.5,dir.x*.5+.3)+.5)*.5;\n        //col+=step(length(fract(dir*10.)-.5),.3)*.5;\n    }\n    vec2 v=vTexCoord;\n    v*=rot(.6);\n    col=mix(col,mix(vec3(.4,.57,.65),vec3(1.,.5,.3),min(1.,v.x)),min(1.2,smoothstep(30.,100.,td)+smoothstep(-1.,-8.,p.y)));\n//    col=mix(col,eyecolor*1.7,g*.5);\n    col+=g*eyecolor*.5*vec3(.8,1.,.7)*(.5+smoothstep(1.,.5,length(col))*.5);\n    //col+=g2*.02*eyecolor*step(g,.01);\n    col+=g2*.005*eyecolor;\n    col+=step(abs(p.x),.03)*step(p.y,.7)*step(-p.y,-0.45)*eyecolor*vec3(.5,1.,.5);\n    col+=(hash(vTexCoord+time*4.123)-.5)*.3;\n    return col;\n}\n\nvec2 rand2(vec2 co){\n\treturn\n\tvec2(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(co.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 uniformDisc(vec2 co) {\n\tvec2 r = rand2(co);\n\treturn sqrt(r.y)*vec2(cos(r.x*6.28),sin(r.x*6.28));\n}\n\nmat3 lookat(vec3 dir) {\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,vec3(0.,1.,0.)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iTime > 2.) discard;\n    vec2 uv = vTexCoord-.5;\n    uv.x*=resolution.x/resolution.y;\n    uv.y-=.12;\n    uv.x+=.05;\n    vec2 pix=1./resolution.xy;\n    vec3 from=vec3(-0.5,0.,-10.);\n//    from.yz*=rot(-mouse.y*3.14-.1);\n//    from.xz*=rot(-mouse.x*3.14-.4);\n    from.yz*=rot(.07);\n    from.xz*=rot(-.25);\n    vec3 target=vec3(0.,0.,0.);\n    float fov=.8;\n    vec3 camdir=normalize(target-from);\n    mat3 look=lookat(camdir);\n    vec3 dir=look*vec3(0.,0.,fov);\n    vec3 up=look*vec3(0.,1.,0.);\n    vec3 right=look*vec3(1.,0.,0.);\n    float aper=.0;\n    float focalplane=6.;\n    vec2 r=aper*uniformDisc(uv+time);\n    vec2 disc=uniformDisc(uv+time);\n    vec2 jittered=uv+pix*disc;\n    vec3 offset=r.x*right+r.y*up;\n    vec3 raydir=normalize((dir+jittered.x*right+jittered.y*up)*focalplane-offset);\n    vec3 col=march(from+offset,raydir);\n    if (time<1.99) {\n        col=mix(texture(iChannel0,vTexCoord).rgb,col,exp(-time*10.));\n    } else{\n        col=texture(iChannel0,vTexCoord).rgb;\n    }\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}