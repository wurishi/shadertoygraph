{"ver":"0.1","info":{"id":"XXSBz3","date":"1729731270","viewed":108,"name":"Camera experiments","username":"Elsio","description":"this is the same code with other skin.\nlembrando que esse efeito de encaixamento gostozinho é do @shane e material metálico é baseado na @blackle","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","grid","rubber","geometry","toy","shane","traversal","plastic","forminha"],"hasliked":0,"parentid":"lXjfDm","parentname":"Jump metal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// shaders lindos ♥ https://www.shadertoy.com/playlist/cXBGzV\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define cor(p) fract(29. * cos(vec4(p.xy, p.x * p.y, 0) + 15.))\n#define T iTime \n#define FAR 260.\n#define PI acos(-1.)\n#define TAU (2.*PI)\n#define debug false\n\nvec2 ID = vec2(1e5);\n\nfloat h21(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 43.123);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat smax(float a, float b) {\n    float k = .04;\n    float f = max(0., 1. - abs(b - a) / k);\n    return max(a, b) + k * .25 * f * f;\n}\n\nfloat porca(vec3 p, float f){\n    float d, k = 10.;\n    vec3 q = pow(abs(p), vec3(k));\n    d = pow(q.x + q.y + q.z, 1. / k) - f;\n    d = smax(d, length(p) - f * 1.45);\n    d = smax(d, .2 - length(p.xy));\n    return d;\n}\n\n   \nfloat clock(vec2 p) {\n    float tm = mod(\n                   h21(p + .13) * 8. \n                                + T * 4. / TAU, \n                   8.\n               );\n         \n    return tm < 1. ? tm : 0.;\n}\n\n\nfloat hight(vec2 id, float tm){\n    float wave = dot(sin(id * 1.4), cos(id.yx * 1.6 + T * 2.));\n    \n    return \n           // wave\n           (3. - cos(tm * TAU)) * wave / 16.\n           \n           // jump\n           + .52 - cos(tm * TAU);\n}\n\nvoid rotObj(inout vec3 p, vec2 id){\n    float tm = clock(id);\n\n    p = vec3(\n            p.xy - id, \n            p.z + hight(id, tm)\n        );\n\n    float dir = floor(h21(id + .07) * 7.) - 3.,\n          delay = .175;\n          \n    if(abs(tm - .5) < .5 - delay){\n        p.zy *= rot(  (tm - delay) * dir * PI\n                      / (1. - delay * 2.)\n                );\n    }\n}\n\n\nvec3 block(vec3 p, int i) {\n    // neighborhood\n    mat4x2 V = mat4x2(-1, 1, 1, 1, 1, -1, -1, -1);\n    vec2 id = floor(p.xy / 2. - V[i] / 4.) * 2.  \n                +  V[i] / 2.  +  1.;\n    \n    rotObj(p, id);\n    return vec3(id, porca(p, .4));\n}\n\n\nfloat blocks(vec3 p) {\n    float d = 1e5;\n    for(int i; i < 4; i ++) {\n        vec3 q = block(p, i);\n        if(q.z < d)\n            d = q.z,\n            ID = q.xy;\n    }\n    return d;\n}\n\n\nfloat table(vec3 p){\n    vec3 q = vec3(\n                 fract(p.xy) - .5,\n                 p.z - .45\n             );\n    \n    return smax(-p.z + .3, -porca(q, .45));\n}\n\nfloat map(vec3 p) {\n        \n    float\n    bl = blocks(p),\n    tb = table(p);\n    \n    ID *= step(bl, tb);\n    return min(tb, bl);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float d, s, i;\n    \n    while(i++ < 164.) {\n        s = map(ro + d * rd);\n        if(abs(s) < .01 || d > FAR) break;\n        d += i < 32. ? s * .4 : s * .9;\n    }\n    \n    return min(d, FAR);\n}\n\n\nvec3 normal(vec3 p) {\n    vec3 e = vec3(.001, 0, 0);\n    vec3 v = vec3(\n                 map(p - e.xyy),\n                 map(p - e.yxy),\n                 map(p - e.yyx)\n             ) - map(p);\n    return normalize(-v);\n}\n\nfloat AO(vec3 p, vec3 n) {\n    float sca = 2., occ;\n    \n    for(int i; i < 3; i ++) {\n        float hr = float(i + 1) * .15 / 3.;\n        float d = map(p + n * hr);\n        occ +=(hr - d) * sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\n\nvoid rotCam(inout vec3 ro, inout vec3 D, float t){\n    ro.y += cos(t * .2) * 5.;\n    D.yz *= rot(1.2);\n    \n    ro.yx *= rot(tanh(cos(t * .3) * 4.));\n    D.yx *= rot(tanh(cos(t * .3) * 4.));\n    \n    ro.zx *= rot(tanh(sin(t * .5) * 4.) * .1);\n    D.zx *= rot(tanh(sin(t * .5) * 3.) * .1);\n}\n\nvec4 render(vec2 u, float t) {\n    vec4 o;\n    vec3 ro = vec3(0, -12, -2),\n         D = normalize(vec3(u, 1));\n\n    rotCam(ro, D, t);\n\n    float d = march(ro, D);\n    \n    o = vec4(-D.x * .4);\n    \n    if(d < FAR) {\n        vec3 p = ro + d * D,\n             N = normal(p),\n             ref = reflect(D, N);\n        \n             \n        float diff = length(sin(ref * 1.) * .5 - .52);\n        float spec = pow(diff * .8, 25.) * .03;\n        vec4 alb = cor(ID);\n        o = (alb * diff * .8 + spec) * AO(p, N);\n        o = pow(o, vec4(.5)) * (1. - 9. * d / FAR);\n    }\n    \n    return o;\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float t = iTime;\n    vec2 r = iResolution.xy;\n    u = (u - r / 2.) / r.y;\n    \n    o = mix(\n            render(u, t),\n            render(u, t + .01),\n            .5\n        );\n}","name":"Image","description":"","type":"image"}]}