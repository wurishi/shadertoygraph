{"ver":"0.1","info":{"id":"msjBR3","date":"1689966244","viewed":94,"name":"Whitted-Style Ray Marching","username":"pacman000","description":"Our first ray marching practice. Thanks to @iq, his tutorial really did us a lot of favour! Noises around the edges are annoying, but we didn't know how to alleviate that. Remove refraction could help, as our implementation of refraction is a total mess.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","sdf","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst float DMAX = 10000.0;\nconst float PI = 3.14159265358979;\nconst float DMIN = 0.009;\nconst float EPS = 0.01;\nconst int MAX_STEPS = 512; // for ray marching\nconst int NUM_MATERIALS = 10;\nconst int NUM_LIGHTS = 2;\nconst int MAX_DEPTH = 2; // height of the ray tree\nconst int NUM_RECORDS = 2 * 2 * 2 * 2 - 1; // 2 ^ (MAX_DEPTH + 1) - 1\n\n// Options(todo)\nbool MSAA = false;\nbool SMAA = false;\nbool AO = false;\n\n// Ray\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\n// Material\nstruct Material\n{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float smoothness;\n    float rg; // reflection coeffcient\n    float tg; // transmission coeffcient\n    float eta; // refraction index\n\n} materials[NUM_MATERIALS];\nconst int MAT_BRASS = 0;\nconst int MAT_BRONZE = 1;\nconst int MAT_SILVER = 2;\nconst int MAT_RED = 3;\nconst int MAT_GREEN = 4;\nconst int MAT_BLUE = 5;\nconst int MAT_GLASS = 6;\nconst int MAT_MIRROR = 7;\nconst int MAT_GREY = 8;\n\n// For recursive ray marching\n// A FIFO queue which simulates the ray tree\nstruct HitRecord\n{\n    Ray ray;\n    float g; // a series of rg and tg multiplied\n    int depth;\n} hitRecords[NUM_RECORDS];\n\n// Geometry\n// Sphere\nstruct Sphere\n{\n    vec3 c;\n    float radius;\n    int matID;\n};\n\nfloat sdSphere(vec3 p, Sphere sph, bool bumpy)\n{\n    float freq = 10.0;\n    vec3 r = p - sph.c;\n    float bump = bumpy ? sin(freq * r.x) * sin(freq * r.y) * sin(freq * r.z) * (1.0 / freq) : 0.0;\n    return length(r) - sph.radius + bump;\n}\n\nstruct Plane\n{\n    // n must be normalized\n    vec3 n;\n    float h;\n    int matID;\n};\n\nfloat sdPlane(vec3 p, Plane plane)\n{\n    return dot(p, plane.n) + plane.h;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Light\nstruct Light\n{\n    vec3 p;\n    vec3 I_ambient;\n    vec3 I_diffuse;\n    vec3 I_specular;\n} lights[NUM_LIGHTS];\n\n// Construct the scene\nSphere sph1;\nSphere sph2;\nSphere sph3;\nPlane plane1;\nPlane plane2;\nPlane plane3;\nPlane plane4;\nPlane plane5;\n// End\n\n// Set the camera\n// Camera frames is left handed\nfloat FOV = 45.0; // Vertical field of view\nfloat aspect;\nvec3 camera_pos = vec3(0.0, 0.0, 80.0);\nvec3 camera_up = normalize(vec3(0.0, 1.0, 0.0));\nvec3 camera_lookat = vec3(0.0, 0.0, 0.0);\nvec3 camera_z;\nvec3 camera_x;\nvec3 camera_y;\n\n// Record the material at the hit point\nMaterial hitMat;\n\nvoid mixMaterial(Material material1, Material material2, out Material matOut, float p)\n{\n    matOut.ambient = mix(material1.ambient, material2.ambient, p);\n    matOut.diffuse = mix(material1.diffuse, material2.diffuse, p);\n    matOut.specular = mix(material1.specular, material2.specular, p);\n    matOut.smoothness = mix(material1.smoothness, material2.smoothness, p);\n    matOut.rg = mix(material1.rg, material2.rg, p);\n    matOut.tg = mix(material1.tg, material2.tg, p);\n    matOut.eta = mix(material1.eta, material2.eta, p);\n}\n\n// Signed distance function operations\nfloat opUnion(float d1, float d2, Material material1, Material material2, out Material matOut)\n{\n    if (d1 <= d2)\n    {\n        matOut = material1;\n        return d1;\n    }\n    else\n    {\n        matOut = material2;\n        return d2;\n    }\n}\n// d1 - d2\nfloat opSubtraction(float d1, float d2, Material material1, Material material2, out Material matOut)\n{\n    if (-d2 >= d1)\n    {\n        matOut = material2;\n        return -d2;\n    }\n    else\n    {\n        matOut = material1;\n        return d1;\n    }\n}\n\nfloat opIntersection(float d1, float d2, Material material1, Material material2, out Material matOut)\n{\n    if (d1 >= d2)\n    {\n        matOut = material1;\n        return d1;\n    }\n    else\n    {\n        matOut = material2;\n        return d2;\n    }\n}\n\n\nfloat opSmoothUnion(float d1, float d2, float k, Material material1, Material material2, out Material matOut)\n{\n    float h = clamp(0.5 + 0.5 * (d1 - d2) / k, 0.0, 1.0);\n    mixMaterial(material1, material2, matOut, h);\n    return mix(d1, d2, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k, Material material1, Material material2, out Material matOut)\n{\n    float h = clamp(0.5 - 0.5 * (d1 + d2) / k, 0.0, 1.0);\n    mixMaterial(material1, material2, matOut, h);\n    return mix(d1, -d2, h) + k * h * (1.0 - h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k, Material material1, Material material2, out Material matOut)\n{\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    mixMaterial(material2, material1, matOut, h);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\n// Calculate sdf of the whole scene\nfloat sdf(vec3 p)\n{\n    float d = DMAX;\n    // Traverse all the objects\n    Material mat;\n    d = opUnion(d, sdSphere(p, sph1, false), materials[sph1.matID], materials[sph1.matID], mat);\n    d = opUnion(d, sdSphere(p, sph2, false), mat, materials[sph2.matID], mat);\n    d = opSmoothUnion(d, sdSphere(p, sph3, false), 0.6, mat, materials[sph3.matID], mat);\n    d = opUnion(d, sdPlane(p, plane1), mat, materials[plane1.matID], mat);\n    d = opUnion(d, sdPlane(p, plane2), mat, materials[plane2.matID], mat);\n    d = opUnion(d, sdPlane(p, plane3), mat, materials[plane3.matID], mat);\n    d = opUnion(d, sdPlane(p, plane4), mat, materials[plane4.matID], mat);\n    d = opUnion(d, sdPlane(p, plane5), mat, materials[plane5.matID], mat);\n    // End traversing\n    hitMat = mat;\n    return d;\n}\n\n// Initializers\nvoid initCamera()\n{\n    aspect = iResolution.x / iResolution.y;\n    camera_z = normalize(camera_pos - camera_lookat);\n    camera_x = cross(camera_up, camera_z);\n    camera_y = cross(camera_z, camera_x);\n}\n\nvoid initScene()\n{\n    sph1 = Sphere(vec3(3.0, -3.0, 30.0), 10.0, MAT_GLASS);\n    sph2 = Sphere(vec3(-5.0, cos(iTime) * 9.0, -5.0), 6.0, MAT_BLUE);\n    sph3 = Sphere(vec3(cos(iTime) * 9.0, -14.0, 40.0), 7.0, MAT_GLASS);\n    plane1 = Plane(vec3(-1.0, 0.0, 0.0), 25.0, MAT_GREEN);\n    plane2 = Plane(vec3(1.0, 0.0, 0.0), 25.0, MAT_RED);\n    plane3 = Plane(vec3(0.0, -1.0, 0.0), 50.0, MAT_GREY);\n    plane4 = Plane(vec3(0.0, 1.0, 0.0), 50.0, MAT_GREY);\n    plane5 = Plane(vec3(0.0, 0.0, 1.0), 25.0, MAT_GREY);\n}\n\nvoid initMaterials()\n{\n    // BRASS\n    materials[MAT_BRASS].ambient = vec3(0.329412, 0.223529, 0.027451);\n    materials[MAT_BRASS].diffuse = vec3(0.780392, 0.568627, 0.113725);\n    materials[MAT_BRASS].specular = vec3(0.992157, 0.941176, 0.807843);\n    materials[MAT_BRASS].smoothness = 27.8974;\n    materials[MAT_BRASS].rg = 0.6;\n    materials[MAT_BRASS].tg = 0.0;\n\n    // SILVER\n    materials[MAT_SILVER].ambient = vec3(0.19225, 0.19225, 0.19225);\n    materials[MAT_SILVER].diffuse = vec3(0.50754, 0.50754, 0.50754);\n    materials[MAT_SILVER].specular = vec3(0.50827, 0.50827, 0.50827);\n    materials[MAT_SILVER].smoothness = 51.2;\n    materials[MAT_SILVER].rg = 0.88;\n    materials[MAT_SILVER].tg = 0.0;\n\n    // GLASS\n    materials[MAT_GLASS].ambient = vec3(0.0);\n    materials[MAT_GLASS].diffuse = vec3(0.0);\n    materials[MAT_GLASS].specular = vec3(1.0);\n    materials[MAT_GLASS].smoothness = 150.0;\n    materials[MAT_GLASS].rg = 0.8;\n    materials[MAT_GLASS].tg = 0.6;\n    materials[MAT_GLASS].eta = 1.5;\n\n\n    // MIRROR\n    materials[MAT_MIRROR].ambient = vec3(0.1);\n    materials[MAT_MIRROR].diffuse = vec3(0.0);\n    materials[MAT_MIRROR].specular = vec3(0.0);\n    materials[MAT_MIRROR].smoothness = 100.0;\n    materials[MAT_MIRROR].rg = 1.0;\n    materials[MAT_MIRROR].tg = 0.0;\n    materials[MAT_MIRROR].eta = 0.0;\n\n    // GREY\n    materials[MAT_GREY].ambient = vec3(0.1);\n    materials[MAT_GREY].diffuse = vec3(1.0);\n    materials[MAT_GREY].specular = vec3(0.0);\n    materials[MAT_GREY].smoothness = 100.0;\n    materials[MAT_GREY].rg = 0.0;\n    materials[MAT_GREY].tg = 0.0;\n    materials[MAT_GREY].eta = 0.0;\n\n    // RED\n    materials[MAT_RED].ambient = vec3(0.1);\n    materials[MAT_RED].diffuse = vec3(1.0, 0.0, 0.0);\n    materials[MAT_RED].specular = vec3(0.0);\n    materials[MAT_RED].smoothness = 100.0;\n    materials[MAT_RED].rg = 0.0;\n    materials[MAT_RED].tg = 0.0;\n    materials[MAT_RED].eta = 0.0;\n\n    // GREEN\n    materials[MAT_GREEN].diffuse = vec3(0.1);\n    materials[MAT_GREEN].diffuse = vec3(0.0, 1.0, 0.0);\n    materials[MAT_GREEN].specular = vec3(0.0);\n    materials[MAT_GREEN].smoothness = 100.0;\n    materials[MAT_GREEN].rg = 0.0;\n    materials[MAT_GREEN].tg = 0.0;\n    materials[MAT_GREEN].eta = 0.0;\n\n    // BLUE\n    materials[MAT_BLUE].ambient = vec3(0.1);\n    materials[MAT_BLUE].diffuse = vec3(0.0, 0.0, 1.0);\n    materials[MAT_BLUE].specular = vec3(0.0);\n    materials[MAT_BLUE].smoothness = 100.0;\n    materials[MAT_BLUE].rg = 0.0;\n    materials[MAT_BLUE].tg = 0.0;\n    materials[MAT_BLUE].eta = 0.0;\n}\n\nvoid initLights()\n{\n    // LIGHT0\n    lights[0].p = vec3(0.0, 20.0, 0.0);\n    lights[0].I_ambient = vec3(0.2);\n    lights[0].I_diffuse = vec3(1.0);\n    lights[0].I_specular = vec3(1.0);\n\n    // LIGHT1\n    lights[1].p = vec3(4.0, 15.0, 8.0);\n    lights[1].I_ambient = vec3(0.2);\n    lights[1].I_diffuse = vec3(1.0);\n    lights[1].I_specular = vec3(1.0);\n}\n// End\n\n// derive corresponding ray direction for this fragment\nvec3 rayDirection(vec2 fragCoord)\n{\n    vec2 sXY = fragCoord - iResolution.xy / 2.0;\n    float z = -iResolution.y / 2.0 / tan(FOV / 2.0);\n    vec3 unit = normalize(vec3(sXY, z));\n    return normalize(unit.x * camera_x + \n                     unit.y * camera_y + \n                     unit.z * camera_z);\n}\n\n// derive normal vector for a point\nvec3 normal(vec3 p)\n{\n    vec3 det = vec3(EPS, 0.0, 0.0);\n    return normalize(vec3(sdf(p + det.xyz) - sdf(p - det.xyz),\n                          sdf(p + det.zxy) - sdf(p - det.zxy),\n                          sdf(p + det.yzx) - sdf(p - det.yzx)));\n}\n\nvec3 bgColor(Ray ray)\n{\n    if (ray.d.y >= 0.0)\n        return vec3(0.1, 0.9, 1.0); // blue?\n    else\n    {\n        float h = ray.o.y / ray.d.y;\n        vec2 pxz = (ray.o - h * ray.d).xz;\n        ivec2 uv = ivec2(floor(pxz));\n        if (((uv.x + uv.y) & 1) == 1)\n            return vec3(0.7);\n        else\n            return vec3(0.9);\n    }\n}\n\n// Soft shadow from iq\nfloat softShadow(vec3 p0, Light light, float w)\n{\n    float res = 1.0;\n    float t = 2.0 * DMIN;\n    vec3 rd = light.p - p0;\n    float tmax = length(rd);\n    rd /= tmax;\n    for (int i = 0; i < MAX_STEPS && t < tmax; i++)\n    {\n        vec3 p = p0 + rd * t;\n        Material mat = hitMat;\n        float h = sdf(p);\n        hitMat = mat;\n        res = min(res, h / (w * t));\n        t += clamp(h, 0.005, 0.50);\n        if (res < -1.0 || t > tmax)\n            break;\n    }\n    res = max(res, -1.0);\n    return 0.25 * (1.0 + res) * (1.0 + res) * (2.0 - res);\n    return res;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting(in vec3 p, in vec3 N, in vec3 V, in Light light)\n{\n    float noShadow = softShadow(p, light, 0.05);\n\n    Material mat = hitMat;\n    vec3 L = normalize(light.p - p);\n    vec3 R = reflect(-L, N);\n    float N_dot_L = max(0.0, dot(N, L));\n    float R_dot_V = max(0.0, dot(R, V));\n    float R_dot_V_pow_n = (R_dot_V == 0.0)? 0.0 : pow(R_dot_V, mat.smoothness);\n\n    return light.I_ambient * mat.ambient + noShadow * \n           (light.I_diffuse * mat.diffuse * N_dot_L + \n           light.I_specular * mat.specular * R_dot_V_pow_n);\n}\n\n\n// Cast a imaginary view ray\n// and use ray marching to intersect the scene\n// return the calculated color\nvec3 castRay(Ray ray0)\n{\n    vec3 color = vec3(0.0);\n    int top = 0;\n    int end = 1;\n    hitRecords[top] = HitRecord(ray0, 0.5, 0);\n    while (top < end)\n    {\n        Ray ray = hitRecords[top].ray;\n        float total_distance = 2.0 * DMIN;\n        bool hit = false;\n        float sign_d = sign(sdf(ray.o));\n        for (int i = 0; i < MAX_STEPS; i++)\n        {\n            vec3 p = ray.o + total_distance * ray.d;\n            float d = sdf(p);\n            if (abs(d) < DMIN) // intersection\n            {\n                hit = true;\n                vec3 normalP = normal(p) * sign(d); // note that normal(p) always points outwards\n                for (int l = 0; l < NUM_LIGHTS; l++)\n                    color += hitRecords[top].g * PhongLighting(p, normalP / sign(d), -ray.d, lights[l]); // restore normalP to distinguish front and back\n                if (hitMat.rg >= EPS && hitRecords[top].depth < MAX_DEPTH)\n                    hitRecords[end++] = HitRecord(Ray(p + 2.0 * EPS * normalP, reflect(ray.d, normalP)), hitRecords[top].g * hitMat.rg, hitRecords[top].depth + 1);\n                if (hitMat.tg >= EPS && hitRecords[top].depth < MAX_DEPTH)\n                {\n                    vec3 d_refraction = refract(ray.d, normalP, sign_d > 0.0 ? 1.0 / hitMat.eta : hitMat.eta);\n                    hitRecords[end++] = HitRecord(Ray(p - 3.0 * EPS * normalP, d_refraction), \n                                                  hitRecords[top].g * hitMat.tg, hitRecords[top].depth + 1);\n                }\n                break;\n            }\n            total_distance += (1.0 - 0.2) * abs(d);\n            sign_d = sign(d);\n            if (total_distance > DMAX)\n                break;\n        }\n        if (!hit)\n            color += hitRecords[top].g * bgColor(ray);\n        top++;\n    }\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initCamera();\n    initScene();\n    initMaterials();\n    initLights();\n    Ray ray = Ray(camera_pos, rayDirection(fragCoord));\n    vec3 color = castRay(ray);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}