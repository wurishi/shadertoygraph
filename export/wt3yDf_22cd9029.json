{"ver":"0.1","info":{"id":"wt3yDf","date":"1610361043","viewed":121,"name":"Terrain example","username":"AlbertoCejas","description":"Terrain","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------\n// Noise Functions\n//--------------------------------------------------------------------\n\n// Modified hash33 by Dave_Hoskins (original does not play well with simplex)\n// Original Source: https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n// Raw simplex implementation by candycat\n// Source: https://www.shadertoy.com/view/4sc3z2\nfloat SimplexNoise(vec3 pos)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(pos + (pos.x + pos.y + pos.z) * K1);\n    vec3 d0 = pos - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\n//--------------------------------------------------------------------\n// Parameters & Constants\n//--------------------------------------------------------------------\n\nint   Octaves     = 3;    // number of layers that geometry has: main outline, boulders, small rocks...\nfloat Lacunarity  = 3.2;  // controls increase in frequency of octaves -> [1 - 10]. Detail level\nfloat Persistence = 0.45; // controls decrease in amplitude of octaves -> [0 - 1]. How much influence/amplitude is each octave allowed to reach\nfloat Scale       = 0.01; // kind of zoom - [1 - 0.0001] where \"0.0001\" means max zoom\nfloat ChangeSpeed = 10.0; // controls how fast noise changes and, therefore, terrain\n\nvec3 DeepWaterColor    = vec3(0.10980, 0.31764, 0.79215);\nvec3 ShallowWaterColor = vec3(0.29803, 0.61568, 0.92156);\nvec3 SandColor         = vec3(0.992157, 1.0, 0.541176);\nvec3 GrassColor        = vec3(0.37647, 0.90980, 0.34509);\nvec3 ForestsColor      = vec3(0.37647, 0.78431, 0.34509);\nvec3 MountainsColor    = vec3(0.61256, 0.41667, 0.21114);\nvec3 PeaksColor        = vec3(1.00000, 1.00000, 1.00000);\n\nfloat ShallowWaterThreshold  = 0.3;\nfloat SandThreshold          = 0.4;\nfloat GrassThreshold         = 0.45;\nfloat ForestsThreshold       = 0.6;\nfloat MountainsThreshold     = 0.7;\nfloat PeaksThreshold         = 0.9;\n\nfloat maxHeightEstimationFactor = 0.7;\n\n\n//--------------------------------------------------------------------\n// Helper Functions\n//--------------------------------------------------------------------\n\nfloat GenerateNoise(\n    vec3  pos,\n    int octaves,\n    float scale,\n    float lacunarity,\n    float persistence)\n{\n    float amplitude          = 1.0;\n    float frequency          = 1.0;\n    float noiseHeight        = 0.0;\n    float maxPossibleHeight  = float(octaves) * amplitude * persistence;\n    \n    for(int i = 0; i < octaves; i++)\n    {\n        vec3 samplePos = pos * scale * frequency;\n        float noiseValue = SimplexNoise(samplePos); // noise in range [-1,1]\n        noiseHeight += (noiseValue * amplitude);\n        \n        amplitude *= persistence; // amplitude decreases per octave, so each octave has less influence\n        frequency *= lacunarity; // frequency increases per octave, so each octave has more detail\n    }\n    \n    // return to range [0-1] and normalize with max possible value with the given parameters. \n    // Also, multiply by a factor so it takes into account that it might not reach max possible value.\n    // This factor could be replaced by a global maximum if noise is generated from CPU.\n    return (noiseHeight + 1.0) / (2.0 * maxPossibleHeight * maxHeightEstimationFactor);\n}\n\nvec3 TerrainColor(float height)\n{\n    vec3 color = DeepWaterColor;\n    \n    color = mix(ShallowWaterColor, color, step(height, ShallowWaterThreshold));\n    color = mix(SandColor, color, step(height, SandThreshold));\n    color = mix(GrassColor, color, step(height, GrassThreshold));\n    color = mix(ForestsColor, color, step(height, ForestsThreshold));\n    color = mix(MountainsColor, color, step(height, MountainsThreshold));\n    color = mix(PeaksColor, color, step(height, PeaksThreshold));\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float noise = GenerateNoise(\n        vec3(fragCoord.x, fragCoord.y, iTime * ChangeSpeed), \n        Octaves,\n        max(Scale, 0.0001f), \n        Lacunarity,\n        Persistence);\n        \n    if(uv.x < 0.5)\n    {\n        fragColor.rgb = vec3(noise);\n    }\n    else\n    {\n        fragColor.rgb = TerrainColor(noise);\n    }\n}","name":"Image","description":"","type":"image"}]}