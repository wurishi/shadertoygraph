{"ver":"0.1","info":{"id":"MfV3Dd","date":"1714953240","viewed":112,"name":"<3 Garden","username":"incre_ment","description":"Technique learned from Big WIngs, \"The Universe Within\".  I did try to implement the technique from memory (having watched the tutorial about a year ago!).  Unfortunately, that means this implementation is probably very un-optimized.  \n\nAnyways.. <3 !!!! ","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","nodegarden"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Heart Garden\n// General technique learned from Big WIngs, \"The Universe Within\".  I did\n// try to implement the technique from memory (having watched the tutorial \n// about a year ago!).  Unfortunately, that means this implementation is \n// probably very unoptimized.\n\n// \"The Universe Within\"\n// https://www.shadertoy.com/view/lscczl\n\n\nfloat PI = 3.14159256;\nfloat TAU = 2.0*3.14159256;\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n// Heart SDF from IQ\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat lineSeg( in vec2 p, in vec2 a, in vec2 b )\n{\n    b -= a; p -= a;\n    return length(p - b* clamp( dot(p,b)/dot(b,b), 0., 1.) );\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   vec3 col = vec3(0.);   \n   float tt = fract(.5*iTime);\n \n   // Scaling and translation for the heart\n   uv *= 1.2;\n   uv += vec2(.01,0.60);\n   \n   // Domain repetition\n   float scale = 22.;\n   uv *= scale;\n   \n   // Cell IDs\n   vec2 cellID = floor(uv);\n   \n   // Cells go from -.5 to .5\n   uv = fract(uv) - .5;\n     \n   vec2 points[9]; \n   float minLine = 1E20;\n   \n   // radius of motion within each cell\n   float rr = .35;\n\n   // Calculate motion of current and neighboring cells.\n   int count = 0;\n   for(float i = 1.; i >= -1.; i--)\n   for(float j = -1.; j <= 1.; j++){ \n     float offset = TAU*fract(sin(dot(cellID + vec2(j,i), vec2(1.0,12.0)))*15745.7342); \n     vec2 motion = vec2(rr*cos(TAU*tt+offset),rr*sin(TAU*tt+offset));\n     points[count] = motion;\n     count++;       \n   }\n   \n   // Draw the circles\n   float circ = length(uv - points[4]) - .19;\n   if(sdHeart(cellID/scale) < 0.)\n     col += smoothstep(.01,-.01,circ);\n\n   float dVal = 0.; \n   \n   // Calculate connection from motion of current cellID to neighbors.\n   float thisOffset = TAU*fract(sin(dot(cellID, vec2(1.0,12.0)))*15745.7342);\n   vec2 thisMotion = vec2(rr*cos(TAU*tt+thisOffset),rr*sin(TAU*tt+thisOffset));\n   \n   int count2 = 0;\n   for(float i = 1.; i >= -1.; i--)\n     for(float j = -1.; j <= 1.; j++){\n       if(sdHeart((cellID + vec2(j,i))/scale) < 0. && sdHeart(cellID/scale) < 0.){\n         float currLine = lineSeg(uv, thisMotion, vec2(j,i) + points[count2]);\n         minLine = min(minLine, currLine);\n         if(minLine == currLine){\n           dVal = distance(thisMotion, vec2(j,i) + points[count2]);\n         }\n       }\n     count2++;\n     }\n    \n   // Calculate the diagnoal components \n   // This part I'm sure could be optimized...\n   if( sdHeart((cellID + vec2(0,1.))/scale) < 0. && sdHeart((cellID + vec2(-1.,0.))/scale) < 0.){\n       float currLine = lineSeg(uv, vec2(0,1.) + points[1], vec2(-1.,0.) + points[3]);\n       minLine = min(minLine, currLine);\n       if(minLine == currLine){\n         dVal = distance(vec2(0,1.) + points[1], vec2(-1.,0.) + points[3]);\n       }\n   }\n   if( sdHeart((cellID + vec2(0,1.))/scale) < 0. && sdHeart((cellID + vec2(1.,0.))/scale) < 0.){   \n        float currLine = lineSeg(uv, vec2(0,1.) + points[1], vec2(1.,0.) + points[5]);\n        minLine = min(minLine, currLine);\n        if(minLine == currLine){\n          dVal = distance(vec2(0,1.) + points[1], vec2(1.,0.) + points[5]);\n        }\n   }\n   if( sdHeart((cellID + vec2(-1.,0.))/scale) < 0. && sdHeart((cellID + vec2(0.,-1.))/scale) < 0.){ \n        float currLine = lineSeg(uv, vec2(-1.,0.) + points[3], vec2(0.,-1.) + points[7]);\n        minLine = min(minLine, currLine);\n        if(minLine == currLine){\n          dVal = distance(vec2(-1.,0.) + points[3], vec2(0.,-1.) + points[7]);\n        }\n   }\n   if( sdHeart((cellID + vec2(1.,0.))/scale) < 0. && sdHeart((cellID + vec2(0.,-1.))/scale) < 0.){\n        float currLine = lineSeg(uv, vec2(1.,0.) + points[5], vec2(0.,-1.) + points[7]);\n        minLine = min(minLine, currLine);\n        if(minLine == currLine){\n          dVal = distance(vec2(1.,0.) + points[5], vec2(0.,-1.) + points[7]);\n        }\n   }\n   float dd = .3*(1.2-clamp(dVal,1.,1.2));\n   col += pow(dd/minLine,4.); \n   \n\n   // Output to screen\n   fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}