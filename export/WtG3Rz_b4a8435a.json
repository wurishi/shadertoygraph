{"ver":"0.1","info":{"id":"WtG3Rz","date":"1578063025","viewed":149,"name":"Joey's Thanksgiving Pants","username":"tb","description":"I saw this pattern and wanted to recreate it.\n[url]https://google.co.uk/search?q=joey's+thanksgiving+pants&tbm=isch[/url]\n\nThe tricky part was getting a random sequence without any repeated neighbours.\n\nEdit: applied antialiasing from FabriceNeyret2","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["circle","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// for each 8 rows, randomly select one of the two greyscales\n// the values for odd rows are equal and guaranteed to not be\n// the same as whichever colour is chosen for the even row,\n// therefore there is never a repeated colour\nconst float greyscales[16] = float[16]\n    (1./3., 2./3.,\n     0./3., 0./3.,\n     2./3., 3./3.,\n     1./3., 1./3.,\n     3./3., 0./3.,\n     2./3., 2./3.,\n     0./3., 1./3.,\n     3./3., 3./3.);\n\nconst float scale = 4.0;\nconst float red_chance = 0.3;\n\nvec4 get_row_colour(float row)\n{\n    // assign a random value to the row\n    vec2 rand = hash21(row);\n    // select a greyscale for the row\n    row = mod(row, 8.0);\n    float grey = greyscales[int((row * 2.0) + step(rand.x, 0.5))];\n    // randomly replace odd rows with red\n    float is_red = mod(row, 2.0) * step(rand.y, red_chance);\n    // return row colour\n    return vec4(max(is_red, grey), vec2(min(1.0 - is_red, grey)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalise coordinates\n    vec2 R = iResolution.xy, U = ((scale * fragCoord.xy) - R) / min(R.x, R.y) - 0.5;\n    // get the pixel width\n    float pix = scale / min(R.x, R.y);\n\n    // scroll vertically\n    U.y += iTime;\n\n    // get local coordinates [-0.5, 0.5] and select the top left quadrent\n    vec2 UF = abs(fract(U) - 0.5);\n\n    // add 1.0 if outside the circle\n    float c = smoothstep(-pix, pix, length(UF) - 0.5);\n    // reflect the quadrent along the diagonal from top left to bottom right\n    UF = 0.5 - UF;\n    // add 1.0 if inside the circle\n    c += 1.0 - smoothstep(-pix, pix, length(UF) - 0.5);\n    // negate c in the bottom half\n    c *= sign(fract(U.y) - 0.5);\n    // offset c by 4 for each neighbouring circle\n    c += floor(U.y) * 4.0;\n    // c now indicates which row of 'stars' or 'lenses' we are in\n\n    fragColor = mix(get_row_colour(floor(c)), get_row_colour(ceil(c)), fract(c));\n}","name":"Image","description":"","type":"image"}]}