{"ver":"0.1","info":{"id":"Dljyzy","date":"1691968178","viewed":73,"name":"Walk on Spheres Winding Numbers","username":"chronos","description":"Computing winding numbers using the walk on spheres algorithm\nIt's not perfect, but it is quite close. Use mouse to compare.\nSee comments in code!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["spheres","numbers","on","walk","winding","wos","walkonspheres","windingnumber"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_sRGB 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec4 bufA = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    int segment_count = get_segment_count(iFrame);\n\n    // comment/uncomment to compare in different ways.\n    //if(iMouse.z < .5) // press to flip between\n    if(uv.x > mouse.x) // slide with mouse\n    //if(uv.x > 0.) // split vertically down middle\n    {\n        // Note that we have to divide by the alpha channel here, to average the results.\n        // This can lose precisions after a while, so a better method of accumulation\n        // that is more numerically stable for large accumulation times could be used instead.\n        float walk_on_spheres_result = bufA.r / bufA.a;        \n        color = winding_number_to_color(walk_on_spheres_result);\n    }\n    else\n    {\n        float winding_number = 0.;\n\n        for(int i = 0; i < segment_count; i++)\n        {\n            winding_number += winding_number_segment(uv, segments[i]);\n        }\n        \n        color = winding_number_to_color(winding_number);\n    }\n    \n    // This is just for visualizing error:\n    if(false)\n    {\n        float walk_on_spheres_result = bufA.r / bufA.a;\n        float winding_number = 0.;\n\n        for(int i = 0; i < num_segments; i++)\n        {\n            winding_number += winding_number_segment(uv, segments[i]);\n        }\n                \n        color = vec3(winding_number >= .9999 ? 1. : 0.);\n        \n        color = vec3(walk_on_spheres_result >= .9999 ? 1. : 0.);\n        \n        color = clamp(vec3(\n                    walk_on_spheres_result - winding_number,\n                    0.,\n                    winding_number - walk_on_spheres_result\n                ), 0., 1.);\n    }\n\n#if USE_sRGB\n    fragColor = vec4(linearToSRGB(color), 1.0);\n#else\n    fragColor = vec4(color, 1.0);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Walk on spheres algorithm\n// Accumulate average over time\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    fragColor = vec4(0);\n    \n    if(iFrame < 1 || restart_signal(iFrame)) return;\n        \n    int segment_count = get_segment_count(iFrame);\n        \n    vec4 buffer = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    for(int it = 0; it < 1; it++)\n    {\n        for(int seg_idx = 0; seg_idx < segment_count; seg_idx++)\n        {\n            vec2 march_pos = uv;\n            vec2 march_pos_prev = march_pos;\n            for(float i = 0.; i < 128.; i++)\n            {\n                vec4 border_sample = border(march_pos, seg_idx);\n                vec4 border_sample_prev = border(march_pos_prev, seg_idx);\n                \n                // If we either are close enough or crossed the segment from one side to the other\n                // we halt and add the value of the side we approached/crossed from,\n                // Which should be the same side of the previous step.\n                // Note to self: this may not hold in the case of walking multiple segments at once,\n                // So should perhaps do an actual segment/segment intersection routine to be sure.\n                if(border_sample.a < eps || sign(border_sample_prev.a) != sign(border_sample.a))\n                {                    \n                    buffer += vec4(border_sample_prev.rgb, 1./float(segment_count));\n                    break;\n                }\n                \n                march_pos_prev = march_pos;\n                march_pos += random_point_on_sphere(border_sample.a, hash(vec3(fragCoord.xy, 10.*(float(it*128) + i) + iTime)));\n            }\n        }\n    }\n    \n    fragColor = buffer;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\nconst float eps = 0.001;\n\nconst float GAMMA = 2.4;\nfloat linearToSRGB(float channel)\n{\n    const float a = 12.92;\n    const float b = 1.055;\n    const float c = 0.055;\n    const float threshold = 0.0031308;\n    \n    return channel <= threshold ? a * channel : (b * pow(channel, 1./GAMMA) - c);\n}\nvec3 linearToSRGB(vec3 color)\n{\n    color = clamp(color, 0., 1.);\n    return vec3(linearToSRGB(color.r), linearToSRGB(color.g), linearToSRGB(color.b));\n}\n\nvec2 random_point_on_sphere(float radius, float rnd_01)\n{\n    float random_angle = 2. * PI * rnd_01;\n    return radius * vec2(cos(random_angle), sin(random_angle));\n}\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\n\n// Line segment\nstruct segment\n{\n    vec2 from, to;\n};\n\nstruct intersect_result\n{\n    bool bIntersects;\n    float intersection_direction; // positive, negative or zero\n    vec2 position;\n};\n\n// exterior product\nfloat wedge(vec2 a, vec2 b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\nfloat segment_side(vec2 p, segment s)\n{\n    vec2 a = p - s.from;\n    vec2 b = p - s.to;\n    return wedge(a, b);\n}\n\n// was intended to be used when WoS iterations cross from one side of a segment to another,\n// due to numberical imprecision, but i dropped it, as it seems it is not necessary\n// not completed!\n/*\nintersect_result line_segment_intersection(segment a, segment b)\n{\n    float from_side = segment_side(b.from, a);\n    float to_side = segment_side(b.to, a);\n    \n    // positive: crosses from positive to negative\n    // negative: crosses from negative to positive\n    float intersection_direction = from_side;\n    \n    return intersect_result(false, intersection_direction, vec2(0));\n}\n*/\nfloat scalar_project_to_vector(vec2 point, vec2 v)\n{\n    return dot(point, v) / dot(v,v);\n}\n\nfloat scalar_project_to_line(vec2 from, vec2 to, vec2 point)\n{\n    vec2 dir = to - from;\n    return scalar_project_to_vector(point-from, dir);\n}\n\nvec2 project_point_to_segment(vec2 point, segment s)\n{\n    float t = scalar_project_to_line(s.from, s.to, point);\n    t = clamp(t, 0., 1.);\n    \n    return s.from + t * (s.to - s.from);\n}\n\nfloat distance_to_segment(vec2 point, segment s)\n{\n    return distance(project_point_to_segment(point, s), point);\n}\n\nfloat winding_number_segment(vec2 p, segment s)\n{\n    vec2 a = normalize(s.from-p);\n    vec2 b = normalize(s.to-p);\n    float d = dot(a,b);\n    float angle = acos(d);\n    angle = min(angle, 2.*PI - angle);\n    return sign(determinant(mat2(a,b))) * angle / (2. * PI);\n}\n\nvec3 winding_number_to_color(float winding_number)\n{\n    //return mix(vec3(1,0,0), vec3(0,0,1), 0.5*(1.+tanh(1.*winding_number))); // smooth, nonlinear, asymptotically towards 0 and 1\n    return mix(vec3(1,0,0), vec3(0,0,1), 0.5*(1.+winding_number));\n}\n\nconst int num_segments = 4;\nsegment segments[num_segments] = segment[num_segments]\n(\n    segment(vec2(-.5, -.5), vec2(  .5, -.5)),\n    segment(vec2(-.5,  .5), vec2( -.5, -.5)),\n    segment(vec2( .5, -.5), vec2(  .5,  .5)),\n    segment(vec2( .5,  .5), vec2( -.5,  .5))\n    \n);\n\nvec4 border(vec2 p, int seg_idx)\n{        \n    float dist = distance_to_segment(p, segments[seg_idx]);\n\n    vec3 col = sign( vec3(segment_side(p, segments[seg_idx])) ) / 2.;\n    \n    return vec4(col, dist);\n}\n\nconst int frames_per_scene = 300;\n\nbool restart_signal(int frame)\n{\n    return frame % frames_per_scene == 0;\n}\n\nint get_segment_count(int frame)\n{\n    return 1 + ((frame / frames_per_scene) % 4); // [1, 4] inclusive\n}\n\n// From earlier attempt. this is for when each iteration is a single walk on spheres on *all* segments at once.\n// It would be much better if this could be used, similar to how it would be done for SDF ray marching\n/*\nvec4 border(vec2 p)\n{        \n    vec3 col = vec3(0);\n    float dist = 9e9;\n\n    for(int i = 0; i < num_segments; i++)\n    {        \n        float d = distance_to_segment(p, segments[seg_idx]);\n        \n        if(d < dist)\n        {\n            dist = d;\n            \n            float seg_side = segment_side(p, segments[i]);\n            \n            col = sign( vec3(seg_side) ) / 2.;\n        }\n    }\n    \n    return vec4(col, dist);\n}\n*/","name":"Common","description":"","type":"common"}]}