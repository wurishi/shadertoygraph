{"ver":"0.1","info":{"id":"4fdBRS","date":"1733232480","viewed":91,"name":"Nonbinary - Neither red or blue.","username":"Nekodigi","description":"- The most unique aspect of this artwork is the addition of green in the transition between red and blue, which expresses an additional option beyond the conventional gender perspective.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["sdf","rgb","nonbinary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Nonbinary\n// Neither red or blue.\n\n\n\n\n\n#define FAR 50.0\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec3 opSmoothUnionUniq( float d1, float d2, vec3 c1, vec3 c2, vec3 c3, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    float h1 = smoothstep(0., 1., clamp(h*2., 0.0, 1.0));\n    float h2 = smoothstep(0., 1., clamp(h*2.-1., 0.0, 1.0));\n    return min(h < 0.5 ? mix( c1, c2, h1) : mix(c2, c3, h2), 1.);\n}\nvec3 opSmoothSubtractionUniq( float d1, float d2, vec3 c1, vec3 c2, vec3 c3, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    float h1 = smoothstep(0., 1., clamp(h*2., 0.0, 1.0));\n    float h2 = smoothstep(0., 1., clamp(h*2.-1., 0.0, 1.0));\n    return min(h < 0.5 ? mix( c1, c2, h1 ) : mix(c2, c3, h2), 1.);\n}\nvec3 opSmoothIntersectionUniq( float d1, float d2, vec3 c1, vec3 c2, vec3 c3, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    float h1 = smoothstep(0., 1., clamp(h*2., 0.0, 1.0));\n    float h2 = smoothstep(0., 1., clamp(h*2.-1., 0.0, 1.0));\n    return min(h < 0.5 ? mix( c1, c2, h1 ) : mix(c2, c3, h2), 1.);\n}\n\n#define RED vec3(0.937,0.267,0.267)\n#define GREEN vec3(0.133,0.773,0.369)\n#define BLUE vec3(0.231,0.51,0.965)\nvec2 mouse = vec2(0.);\nfloat k1 = 1.;\nfloat k2 = 1.;\nfloat k3 = 1.;\nfloat k4 = 1.;\nfloat ks1 = 0.;\n\n#define shape sdBox(pt, vec3(1., 1., 1.))*ks1 + sdSphere(pt, 1.0)*(1.-ks1)\nfloat map(vec3 p){\n  //float s = abs(sin(length(p.xz)*20.));\n  vec3 pt = p - vec3(2.0*cos(iTime*0.9), 0.0, 0.0);\n  float d1 = shape;\n  pt = p - vec3(0., 2.0*sin(iTime), 0.0);\n  float d2 = shape;\n  float v1 = opSmoothUnion(d1, d2, 0.9);\n  float v2 = opSmoothSubtraction(d1, d2, 0.9);\n  float v3 = opSmoothSubtraction(d2, d1, 0.9);\n  float v4 = opSmoothIntersection(d1, d2, 0.9);\n  float d = k1+v1;\n  d = min(k2+v2, d);\n  d = min(k3+v3, d);\n  d = min(k4+v4, d);\n  return d;\n}\nvec3 colorMap(vec3 p){\n  vec3 pt = p - vec3(2.0*cos(iTime*0.9), 0.0, 0.0);\n  float d1 = shape;\n  pt = p - vec3(0., 2.0*sin(iTime), 0.0);\n  float d2 = shape;\n  vec3 v1 = opSmoothUnionUniq(d1, d2, RED, GREEN, BLUE, 0.9);\n  vec3 v2 = opSmoothSubtractionUniq(d1, d2, RED, GREEN, BLUE, 0.9);\n  vec3 v3 = opSmoothSubtractionUniq(d2, d1, RED, GREEN, BLUE, 0.9);\n  vec3 v4 = opSmoothIntersectionUniq(d1, d2, RED, GREEN, BLUE, 0.9);\n  vec3 d = -k1+v1;\n  d = max(-k2+v2,d);\n  d = max(-k3+v3, d);\n  d = max(-k4+v4, d);\n  return d;\n}\nfloat trace (vec3 ro, vec3 rd){\n  float t = 0.0;\n  for (int i = 0; i < 64; i++){\n    vec3 p = ro + t * rd;\n    float d = map(p);\n    t += d;\n    if (d < 0.001 || t > FAR) break;\n  }\n  return t;\n}\nvec3 calcNormal (vec3 p){\n  vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3(\n    map(p + e.xyy) - map(p - e.xyy),\n    map(p + e.yxy) - map(p - e.yxy),\n    map(p + e.yyx) - map(p - e.yyx)\n  ));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord){\n  vec2 canvas, uv;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  mouse = iMouse.xy / iResolution.xy;\n  ks1 = 0.5 + 0.5*sin(iTime*0.07);\n  float phase = mod((iTime * 0.1111), 4.);\n  float phaseFract = fract(phase);\n  if (phase < 1.){\n    k1 = phaseFract;\n    k2 = 1.-phaseFract;\n    k3 = 1.;\n    k4 = 1.;\n  } else if (phase < 2.){\n    k1 = 1.;\n    k2 = phaseFract;\n    k3 = 1.-phaseFract;\n    k4 = 1.;\n  } else if (phase < 3.){\n    k1 = 1.;\n    k2 = 1.;\n    k3 = phaseFract;\n    k4 = 1.-phaseFract;\n  } else {\n    k1 = 1.-phaseFract;\n    k2 = 1.;\n    k3 = 1.;\n    k4 = phaseFract;\n  }\n\n  vec3 sunDir = normalize (vec3 (1., 1.5, -1.));\n\n  vec3 ro = vec3(4.*cos(iTime*0.2), 2.*sin(iTime*0.01), -4.0*sin(iTime*0.19));\n  //vec3 ro = vec3(0., 2., -4.0);\n  vec3 lookAt = vec3(0.0, 0.0, 0.0);\n  vec3 forward = normalize(lookAt - ro);\n  vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n  vec3 up = cross(forward, right);\n  vec3 rd = normalize(forward + uv.x*right + uv.y*up);\n  float t = trace(ro, rd); \n  vec3 col = mix(vec3(0.906,0.898,0.894), vec3(0.471,0.443,0.424), length(uv)*0.5);\n  if (t < FAR){\n    vec3 sp = ro + t * rd;\n    vec3 n = calcNormal(sp);\n    float dif = max(0.0, dot(n, sunDir));\n    col = colorMap(sp);\n    //col = vec3(0.5) + 0.5 * dif;\n\n\n  }\n\n  col = pow( col, vec3(0.4545) );//Gamma correction\n  fragColor = vec4(col, 1.0);\n}\n\n\n\n//*Feedback\n//! Background?\n//* Outline but want to keep it soft. Not sure making realistic make this better\n//* SSR. Lighting?\n\n//! Try out operation.\n//? Union, Intersection, Subtraction, (Interpolation)\n//? Cube <> Sphere\n//! Vignette","name":"Image","description":"","type":"image"}]}