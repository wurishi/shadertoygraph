{"ver":"0.1","info":{"id":"WlcyDS","date":"1609779858","viewed":150,"name":"Kaleidoscopic IFS RayMarching ","username":"Pretentious","description":"A raymarcher for exploring 3D fractals as described in http://www.fractalforums.com/sierpinski-gasket/kaleidoscopic-(escape-time-ifs)/\n","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","lighting","fractals","kaleidoscopic","kifs","sponge","mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.0001\n#define EPSILON 0x00000008\n\nconst float PI = 3.14159265358979323846264338327950288;\nconst float PI2 = 1.57079632679489661923132169163975144;\n\n//Based on the distance estimation formula from http://www.fractalforums.com/sierpinski-gasket/kaleidoscopic-(escape-time-ifs)/\n//The RayMarch(), GetNormal(), and GetLight() methods from  https://www.shadertoy.com/view/XlGBW3\n//Soft Shadows based on https://iquilezles.org/articles/rmshadows\n\n//Mess around with the Scale, centerStrechMult, firstRotationRadians, and secondRotationRadians\n//variables to change the shape of the sponge\n\n\n//Currently having some artefacting, most likely due to normal calculations (and rounding errors?)\n\n               \nint softShadow=0; //0 for off\n\n\nfloat\nScale =3.0,\nobjectRotation=0.05,\nspongeTimeMult=0.0,\nshadowSoftness =15.;\n\nvec3 \nCenterStrechMult = vec3(1.,1.,1.),\nFirstRotationRadians = vec3(0,0,0),\nSecondRotationRadians = vec3(0,0,0),\n\nlightPos = vec3(1.,4.,-5.45),\ncameraPosition,\ncameraRotation = vec3(-0.6,0,0);\n\n\nvec4\nobjectColourOutside = vec4(0.29,0.55,0.58,1),\nobjectColourInside = vec4(0.29,0.55,0.58,1);\n//objectColourInside = vec4(1.,0.41,0.30,1);\n\n\n// rotation matrix\nmat2 rotate( in float a ) {   \n   float c = cos(a);\n   float s = sin(a);\n   // | cos sin|\n   // |-sin cos|\n   return mat2(c,s,-s,c);   \n}\n\n//http://www.fractalforums.com/sierpinski-gasket/kaleidoscopic-(escape-time-ifs)/\n// Gives a MengerSponge with the values C=(1,1,1) scale =3 and no rotations\nfloat MengerSponge(vec3 point, float scale,\n                   vec3 centerStrech,\n                   vec3 firstRot,\n                   vec3 secondRot){\n   point.xz *= rotate(iTime*objectRotation);\n\n   int i;\n   for(i=0;i<10;i++){\n      //first Rotation\n      point.xz *= rotate(firstRot.y+sin(iTime*spongeTimeMult)*0.1);\n      point.xy *= rotate(firstRot.z+sin(iTime*spongeTimeMult)*0.1);\n      point.yz *= rotate(firstRot.x+sin(iTime*spongeTimeMult)*0.1);\n\n      point = abs(point);\n      if(point.x-point.y<0.){float x1=point.y; point.y=point.x; point.x=x1;}\n      if(point.x-point.z<0.){float x1=point.z; point.z=point.x; point.x=x1;}\n      if(point.y-point.z<0.){float y1=point.z; point.z=point.y; point.y=y1;}\n\n      point.z-=0.5*centerStrech.z*(scale-1.)/scale;\n      point.z=-abs(-point.z);\n      point.z+=0.5*centerStrech.z*(scale-1.)/scale;\n     \n      //second Rotation\n      point.xz *= rotate(secondRot.y+sin(iTime*spongeTimeMult)*0.1);\n      point.xy *= rotate(secondRot.z+sin(iTime*spongeTimeMult)*0.1);\n      point.yz *= rotate(secondRot.x+sin(iTime*spongeTimeMult)*0.1);\n\n      point.x= scale*point.x-centerStrech.x*(scale-1.);\n      point.y= scale*point.y-centerStrech.y*(scale-1.);\n      point.z= scale*point.z;\n      if(point.z>0.5*centerStrech.z*(scale-1.)) point.z -=centerStrech.z*(scale-1.);\n   }\n   return (sqrt(dot(point,point))-2.)*pow(scale,float(-i));\n}\n\n//\n//Create Scene here\n//\nfloat GetDist(vec3 point){\n   float planeDistance = point.y+5.;\n   //Mengersponge with static values\n   //float sponge =MengerSponge(point, 3., vec3(1,1,1), vec3(0,0,0), vec3(0,0,0));\n   //Mengersponge with variables\n   float mess =MengerSponge(point, Scale,\n                       CenterStrechMult,\n                       FirstRotationRadians+ vec3(0,iTime*0.05,0),\n                       SecondRotationRadians\n                       );\n   //only pick the distances which\n   // are closest to the camera\n   //float dist = max(sponge, mess);\n   //Seperate foreground from background\n   float dist = min (mess, planeDistance);\n   return dist;\n}\n\n//Source A -https://www.shadertoy.com/view/XlGBW3\nvec3 GetNormal(vec3 point){\n   float dist = GetDist(point);\n   vec3 n = dist - vec3(\n      GetDist(point-vec3(EPSILON, 0.0,  0.0)),\n      GetDist(point-vec3(0.0,  EPSILON, 0.0)),\n      GetDist(point-vec3(0.0,  0.0,  EPSILON)));\n    \n   return normalize(n);\n}\n\n\n//Source A -https://www.shadertoy.com/view/XlGBW3\nfloat RayMarch (in vec3 origin, in vec3 direction) {\n   float currentDist =0.0;\n   int i;\n   for  (i=0; i< MAX_STEPS; i++ ){\n      vec3 point = origin +direction*currentDist;\n      float nextDistance = GetDist(point);\n      \n      currentDist += nextDistance;\n      if (currentDist >MAX_DIST || nextDistance < SURF_DIST) break;\n   }\n   return currentDist;\n}\n\n//Based on descriptions in http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-ii-lighting-and-coloring/\nfloat calcSoftshadow(vec3 origin,vec3 direction)\n{\n    float minimumDist = 1.0;\n    float currentDist = SURF_DIST*1.;\n    int i;\n    for(i=0; i<25; i++ )\n    {\n      vec3 point = origin +direction*currentDist;\n      float nextDistance = GetDist(point);\n      \n      //Compare shortest distance and current distance\n      minimumDist = min( minimumDist, nextDistance*shadowSoftness/currentDist);\n      \n      currentDist += nextDistance;\n      if (currentDist >MAX_DIST || nextDistance < SURF_DIST) break; \n    }\n    return clamp( minimumDist, 0.0, 1.0 );\n}\n\n\n//https://www.shadertoy.com/view/XlGBW3\n// (xyz=(Normals), w=Brightness)\nvec4 GetLight(vec3 point){\n      \n   vec3 lightDirection = normalize(lightPos - point);\n   vec3 N = GetNormal(point);\n   float diffuse = dot(N, lightDirection);\n   //Hard shadows\n   if (softShadow ==0){\n      float shadow = RayMarch(point+N*SURF_DIST*5., lightDirection);\n      if (shadow < distance(point, lightPos)) diffuse =0.;\n   }\n   //soft shadows\n   if (softShadow ==1) diffuse *= calcSoftshadow(point+N*SURF_DIST, lightDirection);\n   \n   \n   return vec4(N,clamp(diffuse,0.,1.));\n}\n\n            //https://www.shadertoy.com/view/llt3R4\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n      //center coordinates\n    vec2 xy =(fragCoord - 0.5)*2.;\n    float z = 1. / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    cameraPosition = vec3(0, 1.2, -1.8);\n    //cameraPosition = vec3(0, 2.5, -4.8);       \n    vec3 rayDirection = rayDirection(95., uv);\n       //rotate on x-axis in radians\n    rayDirection.yz *= rotate(cameraRotation.x);\n    rayDirection.xz *= rotate(cameraRotation.y);\n    \n    //Distance Estimating Ray\n    float dist = RayMarch(cameraPosition, rayDirection);\n    //Locate endpoint of ray\n    vec3 point = cameraPosition +rayDirection* dist;\n    \n    vec4 diffuse = GetLight(point);\n    \n    //Mask scene\n    float cubeMask= 1.-step(3.2,dist);\n    float floorMask= 1.-clamp(dist/MAX_DIST, 0.,1.)-cubeMask;\n    \n    //colour based on distance from center of scene, with offset.\n    vec3 colour = mix(objectColourInside.xyz, objectColourOutside.xyz, (length(point)-0.6));\n    vec3 background = (1.-clamp(cubeMask+floorMask, 0.,1.))*vec3(0.75,0.7,0.65);\n    \n    vec3 flooorCol =floorMask*vec3(0.5, 0.75, 1.);\n    \n    fragColor = vec4((colour*cubeMask+flooorCol)*diffuse.w+background,1.); \n    //fragColor = vec4(vec3(cubeMask),1);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 get_vec_val(float index) {\n\tvec2 uv = vec2(index / iResolution.x, 0.5/iResolution.y);\n    return texture(iChannel0, uv).xyz;\n}\n\nbool set_vec_val(float index, vec2 fragCoord, vec3 val, out vec4 col) {\n    if(fragCoord == vec2(index, 0.5)) {\n        col = vec4(val, 1.0);\n    \treturn true;\n    } \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n}","name":"Buffer A","description":"","type":"buffer"}]}