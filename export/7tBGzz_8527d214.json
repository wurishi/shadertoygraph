{"ver":"0.1","info":{"id":"7tBGzz","date":"1623222570","viewed":201,"name":"Sink","username":"tono","description":"Sink\n\nWhen I am lost in thought, my eyeballs are free under my closed eyelids.\nIt swims in the sea of thoughts while retaining its connection to itself, capturing various spaces in its eyes.\nIf there are eyeballs that swim in the sea of thoughts, I though","likes":23,"published":1,"flags":64,"usePreview":0,"tags":["sea"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MtlXzf","filepath":"https://soundcloud.com/tonoshake/period-space","previewfilepath":"https://soundcloud.com/tonoshake/period-space","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat pi = acos(-1.);\nfloat frame( vec3 p, vec3 b, float e )\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 min2(vec2 a , vec2 b)\n{\n    if(b.x < a.x)\n    {\n        a = b;\n    }\n    return a;\n}\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define PACKIN 1.\n#define WALLS  2.\n#define LIGHT  3.\n#define BODY   4.\n\nvec2 aquarium(vec3 p)\n{\n    vec2 o = vec2(1.);\n    p += vec3(0.,1.,0.);\n    o.x = frame(p , vec3(2.5,1.5,2.),0.001 ) - .03;\n    vec3 p2 = abs(p) - vec3(0.,2.5,0.);\n    vec3 p3 = abs(p) - vec3(3.5,0.,0.);\n    float walls = box(p2 , vec3(2.5,1.,2.));\n    walls = min(box(p3 , vec3(1.,2.,2.)),walls);\n    walls = min(box(p + vec3(0.,0.,3.),vec3(2.5,1.5,1.)),walls);\n    if(walls < .01)\n    {\n        walls -= simplex3d(p * 40.)/200.;\n    }\n    o = min2(o,vec2(walls,2.));\n    return o;\n}\n\nvec2 light(vec3 p)\n{\n    vec2 o = vec2(0.,LIGHT);\n    p -= vec3(0.,.5,.0);\n    o.x = length(p)-.1;\n    return o;\n}\n\nvec3 eyePos;\nvec2 fish(vec3 p)\n{\n    vec2 o = vec2(0.,BODY);\n    p -= vec3(0.,-1.3,5.);\n\tfloat tim = iTime / 3.;\n    float t = floor(tim) + pow(fract(tim),1.3);\n    float tt = noise(vec2(t/2.));\n    float ttt = noise(vec2(-iTime,iTime));\n    p.xz *= rot(sin(tt * pi * 2.)/2.);\n    p.yz *= rot(sin(tt/2. * pi * 2. + .1)/3.);\n    o.x = length(p) - 2.;\n    \n    vec3 p2 = p;\n    vec3 p3 = p;\n    //p.xz *= rot(.5);    \n    p.z += 1.3;\n    eyePos = p;\n    o.x = min(o.x , length(p) - 1.);\n    p2.y -= 1.;\n    p2.x = abs(p2.x) - 2.5;\n    p2.z += 0.5;\n    p2.y += sin(p2.x + iTime * 2.)/7.;\n    p2.yz *= rot(p2.x * 3.);\n    p2.xz *= rot(.0);\n    p2.yz *= rot(.7);\n    o.x = smoothMin(o.x , frame(p2,vec3(30,.1,.3),.1),3. );\n    \n    //float sp = length(p) - simplex3d(p/3. + iTime) * 1.;\n    //o.x = smoothMin(o.x , sp,4.);\n    return o;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 o = vec2(1.);\n    o = min2(o,aquarium(p));\n\to = min2(o,light(p));\n    o = min2(o,fish(p));\n    return o;\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n\tfloat depth = 0.;\n    for(int i = 0; i < 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n\t\tif(abs(d.x) < 0.001)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 10.)break;\n        depth += d.x;\n    }\n    return vec2(-1.);\n}\n\nvec2 mPolar(vec2 p){\n  float a = atan(p.y,p.x);\n  float r = 0.;\n  r = length(p);\n  return vec2(a/pi, r);\n}\n\nvec3 eye(vec3 p)\n{\n    vec3 col = vec3(1.);\n    if(p.z < 0.)\n    {\n        vec2 mpol = mPolar(p.xy);\n        vec3 blackCol = vec3(1.,1.,1.) * smoothstep( (sin(mpol.x * pi * 18. )+.5 )/2.,1.,.3);\n        blackCol = smoothstep(vec3(0.9,.8,.4),blackCol,vec3(min( .44 - length(p.xy)/2. ,1.)));\n        col = mix(blackCol *(1.3 -  mpol.y * 1.5),vec3(1.) , step(0.,length(p.xy) - .9) );\n        float t = floor(iTime/2.) + pow(fract(iTime/2.),2.);\n        float shrink = max(abs(sin(sin(t))),.5);\n    \tcol *= step(0.,length(p.xy) - .4 * shrink);\n        col += 1. - step(0.,length(p.xy) - .2 * shrink);\n        \n    }\n    col *= .8;\n    col += vec3(0.,0.,0.) * floor(simplex3d(p * vec3(30.,30.,1.)));\n    return col;\n}\n\nvec3 getColor(vec2 d, vec3 cp,vec3 rd)\n{\n     vec3 col = vec3(0.);\n    vec3 bcol = col;\n    vec3 mat = vec3(1.);\n    vec3 pos = cp + rd * d.x;\n    vec2 e = vec2(0.,0.01);\n    vec3 N = normalize(map(pos).x - vec3(map(pos + e.xyy).x,map(pos + e.yxy).x,map(pos + e.yyx).x) );\n    vec3 sun = normalize(vec3(2.,4.,8.));\n    sun.xz *= rot(iTime);\n\n    vec3 lightPos = vec3(0.,0.5,0.);\n\n    //vec3 lightDir = normalize(vec3(0.,pos.yz - lightPos.yz));\n    vec3 lightDir = normalize(pos - lightPos);\n    float lightDist = length(pos - lightPos);\n    float attenuation = (1. / pow(lightDist,2.) );\n    float diff = max(0.,dot(N , lightDir)) * attenuation;\n    vec3 halfvector = normalize(lightDir + rd);\n    float sp = max( 0.,dot(N,halfvector) );\n    //fromWater\n\n    float wattenuation = 1. / pow((3. - pos.z),1.3);\n    vec3 wlight = normalize(vec3(5.,-1.,-2.));\n    float wdiff = max(0.,dot(wlight,N)) * wattenuation ;\n    vec3 whalfvector = normalize(wlight + rd);\n    float wsp = max(0.,dot(whalfvector , N)) * wattenuation;\n\n\n    float up = max(0.,dot(vec3(0.,-1.,0.),rd));\n    float down = max(0.,dot(vec3(0.,1.,0.),rd));\n\n    // col = vec3(0.,1.,1.)/2.;\n    // col += up * vec3(.1);\n    // col -= down * vec3(3.);\n    // bcol = col;\n\n    if(d.y == PACKIN)\n    {\n        mat = vec3(0.1);\n        diff = mix(1.,diff,1.);\n        sp = pow(sp , 10.);\n\n\n        col = mat * diff + sp;\n        col += bcol * wdiff + bcol * wsp; \n    }\n    else if(d.y == WALLS)\n    {\n        mat = vec3(0.8)/10.;\n        diff = mix(1.,diff,1.);\n        sp = pow(sp , 60.);\n\n\n        col = mat * diff + sp * vec3(0.2,.8,.9);\n\n        col += (bcol * wdiff + bcol * wsp)/2.; \n    }\n    else if(d.y == LIGHT)\n    {\n        mat = vec3(1.) * 1.;\n        diff = .8;\n\n\n        col = mat * diff + sp;\n    }\n\n    return col;\n}\n\nvec3 setColor(vec2 d , vec3 cp ,vec3 rd)\n{\n    vec3 col = vec3(0.);\n    vec3 bcol = col;\n    vec3 mat = vec3(1.);\n    vec3 pos = cp + rd * d.x;\n    vec2 e = vec2(0.,0.01);\n    vec3 N = normalize(map(pos).x - vec3(map(pos + e.xyy).x,map(pos + e.yxy).x,map(pos + e.yyx).x) );\n    vec3 sun = normalize(vec3(2.,4.,8.));\n    sun.xz *= rot(iTime);\n\n    vec3 lightPos = vec3(0.,0.5,0.);\n\n    //vec3 lightDir = normalize(vec3(0.,pos.yz - lightPos.yz));\n    vec3 lightDir = normalize(pos - lightPos);\n    float lightDist = length(pos - lightPos);\n    float attenuation = (1. / pow(lightDist,2.) );\n    float diff = max(0.,dot(N , lightDir)) * attenuation;\n    vec3 halfvector = normalize(lightDir + rd);\n    float sp = max( 0.,dot(N,halfvector) );\n    //fromWater\n\n    float wattenuation = 1. / pow((3. - pos.z),1.3);\n    vec3 wlight = normalize(vec3(5.,-1.,-2.));\n    float wdiff = max(0.,dot(wlight,N)) * wattenuation ;\n    vec3 whalfvector = normalize(wlight + rd);\n    float wsp = max(0.,dot(whalfvector , N)) * wattenuation;\n\n\n    float up = max(0.,dot(vec3(0.,-1.,0.),rd));\n    float down = max(0.,dot(vec3(0.,1.,0.),rd));\n\n    col = vec3(0.,1.,1.)/2.;\n    col += up * vec3(.1);\n    col -= down * vec3(3.);\n    bcol = col;\n\n    if(d.y == PACKIN)\n    {\n        mat = vec3(0.1);\n        diff = mix(1.,diff,1.);\n        sp = pow(sp , 10.);\n\n\n        col = mat * diff + sp;\n        col += bcol * wdiff + bcol * wsp; \n    }\n    else if(d.y == WALLS)\n    {\n        mat = vec3(0.8)/10.;\n        diff = mix(1.,diff,1.);\n        sp = pow(sp , 60.);\n\n\n        col = mat * diff + sp * vec3(0.2,.8,.9);\n\n        col += (bcol * wdiff + bcol * wsp ); \n    }\n    else if(d.y == LIGHT)\n    {\n        mat = vec3(1.) * 1.;\n        diff = .8;\n\n\n        col = mat * diff + sp;\n    }\n\n    //col = N * .5 + .5;\n\n    if(d.y == BODY)\n    {\n        mat = eye(eyePos);\n        vec2 d2 = march(pos + N * 0.1 ,N);\n        vec3 ambCol = getColor(d2,cp,rd);\n        mat = mix(mat,ambCol,.5);\n        diff = mix(1.,diff,1.);\n        sp = pow(sp , 3.) * 10.;\n        col = mat * diff + sp;\n        col += up * vec3(2.) * mat;\n        //col += -down * vec3(3.3);\n        float tt = 1.- exp(-0.001 * d.x * d.x * d.x * d.x);\n        col = mix(col,bcol , tt);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = vec3(0.,0.,1.);\n    vec3 bcol = col;\n    vec3 mat = col;\n    \n    vec3 cp  = vec3(0.,0.,-1.5);\n    vec3 target = vec3(0.,-.3,.0);\n    vec3 cd = normalize(target - cp);\n    \n    vec3 cs = normalize( cross(cd , vec3(0.,1.,0.)) );\n    vec3 cu = normalize( cross(cd , cs) );\n    \n    float fov = 2.;\n    vec3 rd = normalize(fov * cd + cs * p.x + cu * p.y);\n    \n    vec2 d  = march(cp,rd);\n    \n    //if(d.x > 0.)\n    {\n        col = setColor(d,cp,rd);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}