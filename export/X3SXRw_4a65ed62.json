{"ver":"0.1","info":{"id":"X3SXRw","date":"1710347662","viewed":78,"name":"Software 3D Lerp Benchmark","username":"ThibaultB","description":"Benchmark a custom software trilinear interpolation algorithm.\nChoose the builtin sampling or the software lerp by playing with the comments in the loop.\nThe software lerp has undefined behaviors at the edges.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["volume","benchmark"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// The behavior at the bounds is undefined\n// uvImageCoord = uv * textureSize\nvec4 softwareLerp(sampler3D tex, vec3 uvImageCoord) {\n  ivec3 baseUv = ivec3(uvImageCoord - 0.5);\n  vec4 texVal000 = texelFetch(tex, baseUv + ivec3(0, 0, 0), 0);\n  vec4 texVal001 = texelFetch(tex, baseUv + ivec3(0, 0, 1), 0);\n  vec4 texVal010 = texelFetch(tex, baseUv + ivec3(0, 1, 0), 0);\n  vec4 texVal011 = texelFetch(tex, baseUv + ivec3(0, 1, 1), 0);\n  vec4 texVal100 = texelFetch(tex, baseUv + ivec3(1, 0, 0), 0);\n  vec4 texVal101 = texelFetch(tex, baseUv + ivec3(1, 0, 1), 0);\n  vec4 texVal110 = texelFetch(tex, baseUv + ivec3(1, 1, 0), 0);\n  vec4 texVal111 = texelFetch(tex, baseUv + ivec3(1, 1, 1), 0);\n\n  vec3 weights1 = uvImageCoord - vec3(baseUv) - 0.5;\n  vec3 weights0 = 1.0 - weights1;\n  return\n    texVal000 * weights0.x * weights0.y * weights0.z +\n    texVal010 * weights0.x * weights1.y * weights0.z +\n    texVal100 * weights1.x * weights0.y * weights0.z +\n    texVal110 * weights1.x * weights1.y * weights0.z +\n    texVal001 * weights0.x * weights0.y * weights1.z +\n    texVal011 * weights0.x * weights1.y * weights1.z +\n    texVal101 * weights1.x * weights0.y * weights1.z +\n    texVal111 * weights1.x * weights1.y * weights1.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float w = 0.5 + 0.55*cos(iTime);    \n    vec3 coords = vec3(uv, w);\n\n    float intensity = 0.0;\n    const int nStep = 100;\n    for (int i = 0; i < nStep; ++i) {\n        coords = fract(coords + vec3(0.0, 0.0, 0.1));\n\n        intensity += softwareLerp(iChannel0, vec3(32.0) * coords).r;\n        // intensity += texture(iChannel0, coords).r;\n    }\n    fragColor = vec4(vec3(intensity/float(nStep)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}