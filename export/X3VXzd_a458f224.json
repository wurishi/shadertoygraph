{"ver":"0.1","info":{"id":"X3VXzd","date":"1720403926","viewed":27,"name":"Gravity field contours","username":"Modramoucha","description":"not constantly thick contour lines","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["contour"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sigmoid(float x, float inc, float a, float b)\n{\n    // width: lower values return higher values for same x\n    // b : higher value gives steeper function\n    return ((1.0/(1.0+a*exp(x*b*28.0-7.0))));\n}\n\nvec3 colPicker(float gPotAbs)\n{\n    float maxGPot = 4000.0;\n    \n    // wack\n    float cappedGPot = sigmoid(min(maxGPot, gPotAbs)/(maxGPot)-1.4,1.0,0.2,-0.3);\n    \n    vec3[5] colPalette = vec3[](vec3(0.0,0.0,0.0),vec3(0.47, 0.125, 0.086),vec3(0.831, 0.557, 0.149),vec3(0.831, 0.831, 0.149),vec3(0.376, 0.831, 0.149));\n\n    float[5] xVals = float[](-0.2,0.05,0.2,0.96,1.0);\n\n    for(int i = 1; i < 5; i++)\n    {\n        if(cappedGPot < xVals[i])\n        {\n            return colPalette[i-1]*(1.0-(cappedGPot-xVals[i-1])/(xVals[i]-xVals[i-1])) \n                            + colPalette[i]*(cappedGPot-xVals[i-1])/(xVals[i]-xVals[i-1]);\n        }\n    }\n    return colPalette[4];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // color params\n    \n    float increment = 250.0;\n    \n    // g calc parameter\n    float softeningFactor = 1E-6;\n    float gConst = 1.0;\n    \n    // Objects\n    vec2[4] pos = vec2[](vec2(0.5 + 0.05*sin(iTime),0.5+ 0.05*cos(iTime/2.0)),\n                        vec2(0.5 - 0.1*sin(iTime),0.5 + 0.2*cos(iTime)), \n                        vec2(0.6 - 0.3*cos(iTime/4.0),0.5 + 0.4*sin(iTime/4.0)),\n                        vec2(0.5 + 0.5*cos(iTime/10.0), 0.5 - 0.5*sin(iTime/10.0)));\n                    \n    float[4] mass = float[](8.0, 5.27, 2.0, 10.0);\n    int N = 4;\n    \n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nearestMass = vec2(10.0,10.0);\n    \n    // Gravity potential at uv point\n    vec2 gPot = vec2(0.0,0.0);\n    for (int j = 0; j < N; j++)\n    {\n        nearestMass = length(nearestMass-uv) > length(pos[j]-uv) ? pos[j] : nearestMass;\n        float distance = length(uv - pos[j]);\n        gPot+= mass[j] * (gConst *(uv - pos[j]) / (distance * distance * distance + softeningFactor));\n    }\n    \n    \n    //gradient of potential field;\n    vec2 uvShift = uv + (gPot/length(gPot))/iResolution.xy;\n    \n    // Gravity potential at uv point\n    vec2 gPot2 = vec2(0.0,0.0);\n    for (int j = 0; j < N; j++)\n    {\n        float distance = length(uvShift - pos[j]);\n        gPot+= mass[j] * (gConst *(uvShift - pos[j]) / (distance * distance * distance + softeningFactor));\n    }\n    \n    // Abs value of g potential\n    float gPotAbs = length(gPot);\n    float gPot2Abs = length(gPot2);\n    // Change in g pot to next pixel ( in direction of gradient).\n    float deltaPot = abs(gPotAbs-gPot2Abs);\n    \n    // Distance from nearest increment point\n    // Positive is higher potential, negative is lower.\n    float distToInc = mod(gPotAbs,increment)/increment-0.5;\n    \n    float alphaVal = sigmoid(abs(distToInc), increment,pow(increment,2.0)/deltaPot,increment/deltaPot);\n    \n\n    // Output to scree\n    fragColor = vec4(colPicker(gPotAbs),1)*alphaVal;\n    //fragColor = vec4(1.0,1.0,1.0,1.0)*alphaVal;\n}","name":"Image","description":"","type":"image"}]}