{"ver":"0.1","info":{"id":"MXlfWX","date":"1729014966","viewed":162,"name":"cosmic combination of","username":"nayk","description":"originals https://www.shadertoy.com/view/4XXfDX https://www.shadertoy.com/view/lXfBWX https://www.shadertoy.com/view/lslyRn","likes":9,"published":3,"flags":0,"usePreview":0,"tags":["planet","stars","cosmos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define iterations 11\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define SHOW_NOISE 0\n\nconst mat2 m2 = mat2(  0.80,  0.60,\n          -0.60,  0.80 );\nfloat reamap(float In, float InMin,float InMax, float OutMin,float OutMax){\n    float Out = OutMin + (In - InMin) * (OutMax - OutMin) / (InMax - InMin);    \n    return Out;\n}\nvec3 palette(float t)\n{\n    vec3 a = vec3(0.5,0.5,1.0);\n    vec3 b = vec3(0.5,0.5,1.0);\n    vec3 c = vec3(0.5,0.5,1.);\n    vec3 d = vec3(0.2,0.4,0.6);\n    \n    return a + b*cos(6.28318*(c*t + d));\n\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nfloat hash(in vec2 co)\n{\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\tfloat res = mix(\n\t\tmix(hash(ip),hash(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(hash(ip+vec2(0.0,1.0)),hash(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nfloat fbm_2d( in vec2 x )\n{   \t\n\tfloat f = 2.0;\n\tfloat a = 1.1;\n\tfloat t = 0.0;\n\tfor( int i=0; i<10; i++ )\n\t{\n\t\tt += a*noise(x);\n\t\t\n\t\ta *= 0.1;\n\n        x = f*m2*x;\n\t}\n\t\n\treturn smoothstep(0.,1.8,t);\n}\n\nfloat pattern(in vec2 p, out vec2 q, out vec2 r)\n{\n    q = vec2(fbm_2d(p), fbm_2d(p+vec2(1.5, 4.0)));\n\n\n    r = vec2(fbm_2d(p+iTime + 4.0*q + vec2(1.7, 3.0)), fbm_2d(p+iTime+5.0*q + vec2(10.5, 7.8)));\n    r = vec2(fbm_2d(p + 4.0*q + vec2(1.7, 3.0)), fbm_2d(p+5.0*q + vec2(10.5, 7.8)));\n\n    return fbm_2d(p+4.*r);\n}\n\nfloat DistanceFromSphere(vec3 point, vec3 sphere_center, float sphere_radius)\n{\n    return distance(point, sphere_center) - sphere_radius;    \n}\n\nfloat MapWorld(vec3 point)\n{   \n    float map_result = DistanceFromSphere(point, vec3(-.0), 1.0);\n    //float displacement = sin(5.0 * point.x) * cos(5.0 * point.y) * sin(5.0 * point.z - iTime) * 0.05;// * abs(cos(iTime));\n    // return map_result + displacement;\n    return map_result;\n}\n\nvec3 CalculateNormal(vec3 point)\n{\n    vec3 SMALL_STEP = vec3(1e-3, 0.0, 0.0);\n\n    float gradient_x = MapWorld(point + SMALL_STEP) - MapWorld(point - SMALL_STEP);\n    float gradient_y = MapWorld(point + SMALL_STEP.yxy) - MapWorld(point - SMALL_STEP.yxy);\n    float gradient_z = MapWorld(point + SMALL_STEP.yyx) - MapWorld(point - SMALL_STEP.yyx);\n\n\n    return normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nvec3 getDomainWrapColor(vec2 uv)\n{\n    vec2 q, r;\n    float density = pattern(uv*10.0, q, r);\n\n    vec3 color = mix(vec3(0), vec3(0.451, 1.0, 0.0), density);\n    // color = mix(color, vec3(1.0, 0.4353, 0.4353), q.y);\n    // color = mix(color, vec3(0.1098, 0.3922, 1.0), q.x);\n    color = mix(color, vec3(1.0, 1.0, 1.0), r.y);\n    return color;\n}\n\nvec3 light_position = vec3(20.0, -50.0, 50.0);\nvec3 RayMarch(vec3 ro, vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int STEPS = 32;\n    const float MINIMUM_HIT_DISTANCE = 1e-3;\n    const float MAXIMUM_TRACE_DISTANCE = 1e3;\n\n    for(int i = 0; i <STEPS; ++i)\n    {\n        vec3 current_position = ro + total_distance_traveled*rd;\n        //float distance_to_closest = MapWorld(current_position);\n        float distance_to_closest = MapWorld(current_position);\n        // close enough, hit the object\n        if(distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            vec3 normal = CalculateNormal(current_position);\n            vec2 color_coord = normal.xy + vec2(iTime/10.0, 0.0);\n            \n            vec3 diffuse_color = getDomainWrapColor(color_coord);\n            \n            vec3 direction_to_light = normalize(current_position - light_position);\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n            vec3 ambient = vec3(0.05);\n            return diffuse_intensity*diffuse_color+ ambient;\n        }\n\n        // traveled long enough and hit nothing, return black color\n        if(total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec3(0.2);\n}\n\nvoid GetPixelColor(vec3 ro, vec3 rd, out vec4 pixel_color)\n{    \n    pixel_color = vec4(RayMarch(ro, rd), 1.0);\n}\nconst float tau = 2. * acos(-1.);\n#define R(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define sqr(x) ((x)*(x))\n\nfloat ray(vec2 x)\n{\n    return length(vec2(min(0., x.x), x.y));\n}\n\nfloat rose(vec2 uv, float K, float r1, float r2)\n{\n    float y = length(uv);\n    float p = (sqr(r1) - sqr(r2) + sqr(y)) / (2. * y);\n    float i = floor(2.*K/tau * acos(clamp(p / r1, -1., 1.)));\n    float j = floor(2.*K/tau * atan(uv.y, uv.x));\n    i = (mod(i + j, 2.) == 0. ? i - j : -(1. + i + j)) / 2.;\n    return abs(length(uv - R(tau/K * i) * vec2(r1, 0)) - r2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n    vec2 uv3 = fragCoord / iResolution.xy;\n    uv3 = uv3 * 2.0 - 1.0;\n    \n    uv3.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -2.0);    \n    vec3 rd = normalize(vec3(uv3, 1));\n\t\n     vec2 uv0 =fragCoord/iResolution.xy;\n    \n    float f = 200. / iResolution.y;\n\n\n    float t = 3.11 + (iTime - 10.) / 6.;\n    float r1 = sin(tau * t);\n    float r2 = abs(cos(tau * t));\n    float K = 2. + floor(mod(7. * floor(2. * t), 11.));\n    uv *= R(cos(t) * 5.);\n\n    if (false) // polar slice\n  \n    f = length(fwidth(uv)) * .7;\n\n    float r = 1e9;\n    if (false)\n    for (float i=0. ; i<K ; i++) // loopy\n        r = min(r, abs(length(uv - R(tau/K * i) * vec2(r1, 0)) - r2));\n\n   //if (false)\n        r = min(r, rose(uv, K, r1, r2)); // loopless\n\n    float g = 1.;\n    g = .5;\n    if (false)\n    for (float i=g ; i*2.<K ; i+=g) // grid\n        r = min(r, abs(length(uv) - (cos(tau/K * i) * r1 + sqrt(sqr(r2) - sqr(sin(tau/K * i) * r1)))));\n\n    if (false)\n    r = min(r, ray(uv)), // grid\n    r = min(r, ray(R(tau/K * g) * uv));\n\n    if (false)\n    r = min(r, abs(length(uv) - (r2 - r1))),\n    r = min(r, abs(length(uv) - (r2 + r1)));\n    r = smoothstep(0., f, r-.5 * f);\n    vec3 col = palette(length(uv0) + iTime*2.);\n    \n    float circle = length(uv3*0.75)-0.5*sin(tau * t*5.);\n    float smoothCircle = smoothstep(10./iResolution.y,0.,circle);\n    float outedge =clamp ( 0.03/clamp(circle,0.,1.),0.,1.) - smoothCircle;\n    \n    float noise1 = texture(iChannel0,uv*2./iResolution.y -iTime*0.005).x;\n    float noise2 = texture(iChannel0,uv*2./iResolution.y + iTime*0.005).x;\n    float noise = noise1 + noise2;\n    \n    float reamapUV = reamap(uv.y,0.,1.,-0.5,1.);\n    float wave = reamapUV + noise;\n    float edge = smoothstep(0.,50./iResolution.y,wave) ;\n    \n    vec4 rColor = smoothCircle *edge* vec4(1.5,0.5,0.,1.);\n    vec4 lColor = smoothCircle *(1.-edge)* vec4(0.,0.5,1.5,1.);\n  \n    vec4 s1 = rColor + lColor+cos(iTime) ;\n    vec4 s2 = outedge * vec4(col,1.);\n \n    \n    \n    \n   fragColor= vec4(getDomainWrapColor(uv3), 1.0);\n\tvec3 from=vec3(1.,.5,0.5)+RayMarch(ro, rd)*r;\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n            p.xy*=mat2(cos(iTime*0.03),sin(iTime*0.03),-sin(iTime*0.03), cos(iTime*0.03));\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\n\n\n    \n     \n\t\n\t\n\t\n\t\n      \n        \n          fragColor=vec4(v*.03+s2.xyz,1.);\n           uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv3, anim) * vec3(0.5,0.5,0.5)*1.5, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}