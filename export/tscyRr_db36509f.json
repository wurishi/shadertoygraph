{"ver":"0.1","info":{"id":"tscyRr","date":"1600262486","viewed":198,"name":"Basic : Fourier Transform","username":"Gijs","description":"Performs a naÃ¯ve continuous Fourier transform using simple numerical integration on an image (left), from which the image is then reconstructed (right).","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["fndaklfasd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float divider = iResolution.x*(sin(iTime*.5)*.5 + .5);\n    if(iMouse.z>0.) divider = iMouse.x;\n\n    if(fragCoord.x<divider){\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    }else{\n        fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//red channel frequency\nvec2 f(vec2 x){\n    return vec2(texture(iChannel0, x).r, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 s = vec2(0);\n\n    vec2 k = (fragCoord*2. - iResolution.xy)/iResolution.xy*R;\n    for(float i=0.; i<N; i++){\n        for(float j=0.; j<N; j++){\n            vec2 n = vec2(i,j);\n            vec2 x = n/N;\n            vec2 fx = f(x);\n            vec2 e = complexExp(-dot(k,x));\n            s += complexMult(fx,e);\n        }\n    }\n    float dx = 1./N;\n    s *= dx*dx;\n    s /= 2.*PI;\n    \n    fragColor = vec4(s, 0., 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//green channel frequency\nvec2 f(vec2 x){\n    return vec2(texture(iChannel0, x).g, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 s = vec2(0);\n\n    vec2 k = (fragCoord*2. - iResolution.xy)/iResolution.xy*R;\n    for(float i=0.; i<N; i++){\n        for(float j=0.; j<N; j++){\n            vec2 n = vec2(i,j);\n            vec2 x = n/N;\n            vec2 fx = f(x);\n            vec2 e = complexExp(-dot(k,x));\n            s += complexMult(fx,e);\n        }\n    }\n    float dx = 1./N;\n    s *= dx*dx;\n    s /= 2.*PI;\n    \n    fragColor = vec4(s, 0., 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//blue channel frequency\nvec2 f(vec2 x){\n    return vec2(texture(iChannel0, x).b, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 s = vec2(0);\n\n    vec2 k = (fragCoord*2. - iResolution.xy)/iResolution.xy*R;\n    for(float i=0.; i<N; i++){\n        for(float j=0.; j<N; j++){\n            vec2 n = vec2(i,j);\n            vec2 x = n/N;\n            vec2 fx = f(x);\n            vec2 e = complexExp(-dot(k,x));\n            s += complexMult(fx,e);\n        }\n    }\n    float dx = 1./N;\n    s *= dx*dx;\n    s /= 2.*PI;\n    \n    fragColor = vec4(s, 0., 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//this does NOT show the discrete Fourier transformation\n\n//integration samples\n//it needs to be pretty large to succesfully reconstruct the image (>200)\n//to see this PAUSE THE SHADER FIRST and then up the N and recompile.\nconst float N = 20.;\n\n//frequency range that is considerd, this formula makes sort of sense?\n//because of this frequency cutoff the image is effectivily smoothed\nconst float R = 2.*N;\n\n//pi and tau\nconst float PI = 3.1415;\nconst float TAU = 6.28318530718;\n\n//multiplication of two complex numbers\nvec2 complexMult(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n//calculates exp(it)\nvec2 complexExp(float t){\n    float c = cos(t);\n    float s = sin(t);\n    return vec2(c, s);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//reconstruction\n\nvec2 fr(vec2 k){\n    return texture(iChannel0, (k/R + 1.)*.5).rg;\n}\n\nvec2 fg(vec2 k){\n    return texture(iChannel1, (k/R + 1.)*.5).rg;\n}\n\nvec2 fb(vec2 k){\n    return texture(iChannel2, (k/R + 1.)*.5).rg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rs = vec2(0);\n    vec2 gs = vec2(0);\n    vec2 bs = vec2(0);\n\n    vec2 x = fragCoord/iResolution.xy;\n    for(float i=0.; i<N; i++){\n        for(float j=0.; j<N; j++){\n            vec2 n = vec2(i,j);\n            vec2 k = (n*2.-N)/N*R;\n            vec2 frk = fr(k);\n            vec2 fgk = fg(k);\n            vec2 fbk = fb(k);\n            vec2 e = complexExp(dot(k,x));\n            rs += complexMult(frk,e);\n            gs += complexMult(fgk,e);\n            bs += complexMult(fbk,e);\n        }\n    }\n    float dk = 2.*R/N;\n    rs *= dk*dk;\n    gs *= dk*dk;\n    bs *= dk*dk;\n    \n    rs /= 2.*PI;\n    gs /= 2.*PI;\n    bs /= 2.*PI;\n    \n    fragColor = vec4(rs.x, gs.x, bs.x, 1.0);\n}","name":"Buf D","description":"","type":"buffer"}]}