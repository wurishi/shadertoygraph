{"ver":"0.1","info":{"id":"wtSfW3","date":"1599975904","viewed":177,"name":"playing rabbit","username":"danhel95","description":"ported one of my python program to glsl, to test state persistence. rotation after collision dint wanna work ...! \nadded rabbit , the rabbit was made by fizzer https://www.shadertoy.com/view/XlccWH","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["collision","tutorial","physics","state","verlet","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//lerning tutorial 7\n// collision with persistant state.\n// problem with rotation after impact didnt wanna work!?\n\n// rabbit was made by fizzer https://www.shadertoy.com/view/XlccWH\n\nobj_geo get_obj(int i) {\n    vec4 c = texelFetch(iChannel0, ivec2(i,C), 0);\n    vec4 oc = texelFetch(iChannel0, ivec2(i,OC), 0);\n    return   obj_geo(c.xyz, oc.xyz,  vec3(0.),  vec3(.25,.1,FAR),\n                    vec3(.0),vec3(.0),vec3(.5));\n}\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.;\n    r.zoom = 1.;\n    r.o = vec3(0., 6., -10.);\n    r.t = vec3(.5);\n\n    // float ang = .3 * iTime;\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\n\nvoid update() {\n\n    for(int i = 0; i < N; i++) {\n        obj_geo geo = get_obj(i);\n        obs[i].geo.c = geo.c;\n        obs[i].geo.oc = geo.oc;\n\n    }\n}\n\nvoid spheres(vec3 p ) {\n\n    float ds1 = sphere(p,obs[0].geo.c , .3);\n    //float ds1 = rabbit(p,obs[0].geo.c, vec3(1.));\n    //float ds2 = abox(p,obs[1].geo.c, vec3(.35));\n    float ds2 = rabbit(p,obs[1].geo.c, vec3(.5) , iResolution.x,iTime);\n    obs[0].d = ds1;\n    obs[1].d = ds2;\n\n}\n\nobj scene(vec3 p) {\n\n    float dp = box(p, vec3(3, .1, 3)) ;\n    float db2 = bassin(p);\n\n    spheres(p);\n    obj_geo sp1_geo= obj_geo(vec3(0., 1.  , 0.),vec3(0.),vec3(0.),vec3(1.,.5,FAR),vec3(.0),vec3(.0,.0,.0) ,vec3(.4));\n    obj pln = obj(dp ,vec3(.1,.5,.2),vec3(0.), .5, 1., 3., 100.,1., 1.,sp1_geo);\n    obj bx2 = obj(db2,vec3(0.,1.,1.),vec3(0.),  .5, 1., 3., 100.,.1, 2.,sp1_geo);\n    obj sp1 = obs[0];\n    obj sp2 = obs[1];\n\n    obj r = uop(pln,bx2);\n    r = uop(r,sp1);\n    r = uop(r,sp2);\n\n    return r;\n}\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<8; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        t += s.d;\n    }\n\n    s.d = t;\n    s.geo.m_mi.z = t;\n    return s;\n}\n     \n   \nfloat checkerboard(in vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.z,2.);\n}\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n    if(ob.id == 1.) {\n        float f = checkerboard(p);\n        ob.material +=  .5 * vec3(f);\n    }\n\n    //ob.col = vec3(.0);\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.material * Kd * l.col* ob.diffuse;\n    vec3 spec = ob.material * Ks * l.col*  ob.specular;\n    vec3 ambi = ob.material *  ob.amb;\n\n    ob.col += dif + spec + ambi ;\n\n\n}\n\nvec3 refract2(vec3 i, vec3 n, float eta) {\n    if(dot(i, n) < 0.) eta = 1. / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\n\n\nvec3 render() {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 2.  ,theta= iTime*.5;\n    vec3 spos = vec3(radius * cos(theta), 2.0 + sin(theta ) * .5, radius * sin(theta));\n    star blue = star(spos, vec3(.9,.6,.1), 1. );\n\n    for(float i = 0.; i < 1.; i += 1./1.) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tvec3 normal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n\n        ob.col *= pow(smoothstep(FAR, 10., 2.*ob.d), 2.);\n        if(ob.id < 2. ) {\n            resCol += ob.col * alpha  ;\n       \t\talpha *= 0.1;\n            r.d = reflect(r.d, normal);\n        }\n        else {\n            resCol += ob.col * alpha *ob.transparency;\n            alpha *= (1. - ob.transparency);\n            r.d = refract2(r.d, normal,1.03);\n        }\n\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n    }\n\treturn resCol;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy ;\n    time = iTime;\n    r = raydir(uv,m);\n    update();\n\tvec3 color = render();\n    color = pow(color,vec3(0.75));\n    fragColor = vec4( color, 1.0);\n\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 80.\n#define SURF 1e-3\n#define FAR 60.\n#define ZERO min(iFrame,0)\n#define pow(a,b) pow(abs(a),(b))\n#define N 2\n#define dt iTimeDelta*4.\n#define C 10\n#define OC 20\n\n\nfloat rand(vec2 co){\n    float realRandom = iDate.w;\n    return fract(sin(realRandom+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) -0.5;\n}\nfloat time;\nfloat pupdist=1e6;\n\n// Polynomial smooth min (k = 0.1) (from IQ)\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 R3(vec3 p , vec3 n, float theta){\n   return   (   p*cos(theta) +\n                n*dot(p,n) * (1.-cos(theta) ) +\n                (cross(n,p))*sin(-theta) ) ;\n}\n\nvec3 RR3(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\nstruct gl{\n    vec4 col;\n    vec4 f;\n};\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\nray r ;\n\nstruct obj_geo\n{\n    vec3 c;\n    vec3 oc;\n    vec3 acc;\n    vec3 m_mi;\n    vec3 ax;\n    vec3 ang;\n    vec3 sz;\n\n};\n\nstruct obj\n{\n\n    float d;\n    vec3 material;\n    vec3 col; //final\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n    float id;\n    obj_geo geo;\n\n};\n\nobj obs[2] = obj[2](\n    obj(FAR ,vec3(.2) ,vec3(.5,.4,.1),\n        .5, 1., 3., 100.,1.,2. ,\n        obj_geo(vec3(0., 1.  , 1.),vec3(0.),\n        vec3(0.),vec3(1.,5.,FAR),vec3(.0),vec3(.0 ),\n        vec3(.3))),\n    obj(FAR ,vec3(.5),vec3(.5,.7,.6),\n        .5, 1., 3., 100.,1.,3. ,\n        obj_geo(vec3(0., 1.  , 0.),vec3(0.),\n        vec3(0.),vec3(1.,5.,FAR),vec3(.0),vec3(.0) ,\n        vec3(.5)))\n);\n\n\n\nfloat cylinder(vec3 p,vec3 dir,float h,float r)\n{\n    float t=dot(p,dir);\n    float d=distance(p,dir*t);\n    return length(max(abs(vec2(d,t))-vec2(r,h),vec2(0)));\n    d=max(d,-t);\n    d=max(d,t-h);\n    return d;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b) {\n    vec3 d = abs(p-pos) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat rabbit(vec3 fk,vec3 pos,vec3 sz,float Rx,float time )\n{\n    float H = 5.;\n    vec3 p = fk - pos ;\n    p *= H;\n\n    float an=.5*.5*2.*6. +1./Rx*6.;\n    p.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*p.xz;\n\n    float time2=time*12.4;\n\n    p.y-=.3;\n    p.xy*=R2(cos(time2+1.)*.04);\n    p.y+=.3;\n\n    vec3 op=p;\n\n    vec3 p2=p;\n    p2.xy*=R2(cos(time2)*.4);\n\n    vec3 p3=p;\n    p3.xy*=R2(cos(time2-.0-length(p)/2.)*.13);\n\n    float d=1e4;\n    p.x=abs(p.x);\n    p2.x=abs(p2.x);\n    p3.x=abs(p3.x);\n\n    d=smin(length(p2-vec3(-.75,0.,-.1))-.4,length(p2-vec3(.75,0.,-.1))-.5,2.);\n    d=smin(d,length(p2-vec3(0,0.4,-.1))-.9,1.6);\n    d+=.1;\n\n    // Ears 1\n    d=smin(d,distance(vec3(.7,clamp(p3.y,0.,2.2),0.),p3.xyz)-.4,.14);\n    d=smax(d,-(length(p3-vec3(.7,1.7,-0.5))-.5),.2);\n\n    // Neck\n    d=smin(d,distance(vec3(0.,clamp(p.y,-1.6,-1.1),0.),p.xyz)-.6,.04);\n\n    // Legs\n    vec3 p4=op;\n    float ld=-.75;\n    p4.y-=ld;\n    p4.yz*=R2(cos(time*6.+3.1415926/1.)*.1);\n    p4.y+=ld;\n    p4.y-=max(0.,cos(time*6.+3.1415926/2.))*.1;\n    d=smin(d,distance(vec3(.3,clamp(p4.y,-2.6,-2.),0.),p4.xyz)-.3,.1);\n    p4=op;\n    p4.y-=ld;\n    p4.yz*=R2(cos(time*6.+3.1415926/1.*1.)*.1);\n    p4.y+=ld;\n    p4.y-=max(0.,cos(time*6.+3.1415926/2.+3.1415926/1.*1.))*.1;\n    d=smin(d,distance(vec3(.3,clamp(p4.y,-2.6,-2.),0.),p4.xyz*vec3(-1,1,1))-.3,.1);\n\n    // Belly\n    d=smin(d,distance(vec3(0.,-1.5,-.2),p)-.5+cos(time*3.)*.03,.4);\n\n    // Ears 2\n    d=smin(d,distance(vec3(1.1,2.3,-.1),p3)-.2,.8);\n\n    // Tail\n    d=smin(d,distance(vec3(0,-1.7,.6),p)-.3,.1);\n\n    vec3 q=vec3(0.35,.4,-1);\n\n    if(mod(time-1.,4.)>.04)\n    {\n        d=smax(d,-(cylinder(p2-q,normalize(q-p2),.3,.1)-.0001),.05);\n        d=smin(d,(length(p2-q*.9)-.2),.24);\n\n        // Eye pupils\n        if(op.x>0.)\n            pupdist=(length(p2-vec3(.39,.32,-1.))-.2);\n        else\n            pupdist=(length(p2-vec3(.28,.32,-1.02))-.2);\n\n        d=smin(d,pupdist,.005);\n    }\n\n    // Nose\n    d=smin(d,(length(p2-vec3(0,.1,-1.02))-.2),.02);\n\n    // Mouth (two states)\n    float d3=smax(-(length(p-vec3(-.05,-.29,-1.02))-.1),-(length(p-vec3(.05,-.29,-1.02))-.1),.1);\n\n    float d2=max(p2.z,distance(p2,vec3(clamp(p2.x,0.,.3),-.2,clamp(p2.z,-2.,2.)))+.01);\n\n    float time4=time/8.;\n    float gg=smoothstep(0.,1.,clamp((min(fract(time4),1.-fract(time4))-.25)*64.,0.,1.));\n    d=smax(d,mix(-d2,d3,gg),.1);\n\n    // Tooth\n    d=min(d,(length(p-vec3(.0,-.2,-1.02))-.08));\n\n    p.y+=.2;\n    p.xy*=R2(.4+cos(time2*2.)*.02);\n    // Arms\n    float armd=smin(distance(vec3(.2,clamp(p.y,-1.8,-0.),0.),p.xyz)-.2,\n                    distance(p,vec3(0.2,-1.7,0))-.2,.2);\n\n    d=smin(d,armd,.05);\n\n    return d/H;\n}\n\n\n\nfloat abox(vec3 p,vec3 pos, vec3 b) {\n    vec3 q = p-pos;\n    vec3 d = abs(q) - b ;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.) ;\n}\n\n\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    vec3 q = p-pos;\n    return length(q) - r ;\n\n}\nfloat cylinder( vec3 q, vec3 pos, vec2 h )\n{\n    vec3 p = q -pos;\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) ;\n}\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\nfloat bassin(vec3 p) {\n    vec3 p1 = p  - vec3(0, 3., 0);\n    float db2 = box(p1, vec3(3., .5, 3.));\n    float dp2 = plane(p1,vec4(0, 1., 0 ,1.));\n    db2 = abs(db2);\n    db2 = max(dp2,db2);\n    return db2;\n\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 wind = vec3(1.,.05 ,1. );\nvec3 gravity = vec3(.0, -.1 ,.0 );\nvec3 PC;\n\nobj_geo get_obj(int i) {\n    vec4 c = texelFetch(iChannel0, ivec2(i,C), 0);\n    vec4 oc = texelFetch(iChannel0, ivec2(i,OC), 0);\n    return   obj_geo(c.xyz, oc.xyz,  vec3(0.),  vec3(.25,.1,FAR),\n                    vec3(.0),vec3(.0),vec3(.5));\n}\n\n\nvoid correct_position(inout obj_geo o, vec3 n,float depth){\n        o.c +=   n * abs(depth + .01) ;\n}\n\n\nvoid apply_force(inout obj_geo o, vec3 force) {\n    vec3 gamma =  force * (1./o.m_mi.x);\n    o.acc += gamma;\n}\n\nvoid applyTorque(inout obj_geo o , vec3 P , vec3 impulse ){\n\n    vec3 torque = cross(P,impulse) ;\n    vec3 torque_axis = normalize(torque);\n    float torque_mag = length(torque);\n    o.ax = torque_axis;\n    o.ang.z +=   torque_mag/o.m_mi.y  ;\n}\n\nvoid applyImpulse(inout obj_geo o , vec3 impulse){\n    o.acc +=   impulse * (1./o.m_mi.x);\n}\n\nvoid apply_torque_and_impulse(inout obj_geo o,vec3 P,vec3 impulse){\n    applyImpulse(o, impulse);\n    applyTorque(o, P,impulse);\n}\n\n\nvec3 impact_normal(inout obj_geo s, inout obj_geo o){\n    vec3 n = (s.c - o.c);\n    return normalize(n);\n}\n\nvec3 impact_point(inout obj_geo s, inout obj_geo o){\n    float r1 = s.sz.x, r2 = o.sz.x;\n    if (dot(s.c,o.c) < length(o.c))\n        return s.c + (r1 / (r1 + r2)) * (o.c - s.c);\n    else\n        return o.c + (r2 / (r1 + r2)) * (s.c - o.c);\n}\n\nvec3 impact_impulse(inout obj_geo s, inout obj_geo o, vec3 pc, vec3 n){\n\n    float e = .6,\n        m1 = s.m_mi.x,\n        m2 = o.m_mi.x,\n        si = s.m_mi.y,\n        oi = o.m_mi.y;\n\n    float ism = 1./m1;\n    float iom = 1./m2;\n    vec3 vs = s.c - s.oc;\n    vec3 vo = o.c - o.oc;\n    vec3 rap = pc - s.c;\n    vec3 rbp = pc - o.c;\n    float deno = ism + iom + length(cross(rap,n))/si + length(cross(rbp,n))/oi;\n    float numer = -(1.+e) * dot( vs - vo , n);\n    float j = numer / deno;\n    vec3  f_impulse = n * j;\n    return f_impulse ;\n}\n\nvoid after_mate(inout obj_geo s, obj_geo o,vec3 pc, vec3 n) {\n    vec3 f_impulse = impact_impulse(s, o, pc, n);\n    apply_torque_and_impulse(o, pc, f_impulse);\n    apply_torque_and_impulse(s, pc, -f_impulse);\n}\n\n\n\n\nvoid process_impact(inout obj_geo s, inout obj_geo o){\n\n    float depth = s.sz.x + o.sz.x - length(s.c - o.c);\n    vec3 n = impact_normal(s, o);\n    vec3 pc = impact_point(s, o);\n    PC = pc;\n    correct_position(s, n, depth);\n    after_mate(s, o, pc, n);\n\n}\nvoid check_collision(inout obj_geo o , inout obj_geo s){\n    if (length(o.c - s.c) <= o.sz.x + s.sz.x - .3){\n        process_impact(s, o);\n    }\n}\n\nvoid check_borders(inout obj_geo o) {\n\n    float r0 = o.sz.y;\n    float up = 5.;\n    float   w = 3.,\n            down= .1,\n            bounce = .9,\n            offset = .01;\n\n    vec3 vt = o.c - o.oc;\n\n    vt *= dt*exp(-.01*dt) ;\n    if (o.c.y + r0   > up)\n            o.oc.y = o.c.y,\n            o.c.y = up - r0,\n            o.c.y +=  vt.y*bounce + offset ;\n\n    if (o.c.y - r0 < down)\n            o.oc.y = o.c.y,\n            o.c.y = down + r0,\n            o.c.y +=  vt.y*bounce - offset;\n\n    if (o.c.x + r0   > w)\n            o.oc.x = o.c.x,\n            o.c.x = w - r0,\n            o.c.x += vt.x*bounce + offset;\n\n    if (o.c.x - r0 < -w)\n            o.oc.x = o.c.x,\n            o.c.x = -w + r0,\n            o.c.x +=  vt.x*bounce - offset;\n\n    if (o.c.z + r0   > w)\n            o.oc.z = o.c.z,\n            o.c.z = w - r0,\n            o.c.z +=  vt.z*bounce + offset;\n\n    if (o.c.z - r0 < -w)\n            o.oc.z = o.c.z,\n            o.c.z = -w + r0,\n            o.c.z +=  vt.z*bounce - offset;\n}\n\n\nvoid rotate(inout obj_geo o){\n    o.ang.y += o.ang.z*dt ;\n    o.ang.x += o.ang.y*dt ;\n    o.ang *= TWO_PI;\n    //vec3 p = r.o + o.m_mi.z * r.d ;\n    //o.c = R3(o.c , o.ax,o.ang.x) ;\n\n}\nvoid translate(inout obj_geo o){\n\n\n    vec3 v = (o.c - o.oc );\n    v *= exp(-.01 * dt);\n    o.c += v  *.9 * dt ;\n    o.c += o.acc * dt *dt  ;\n\n}\n\n\n\n\nvec3 update_oc(inout obj_geo o, int idx) {\n    return o.c;\n}\n\nvec3 update_c(obj_geo o, int idx) {\n\n    vec3 npos;\n    wind.xz *= .5*sin(cos(.01*o.c.xz) + .4*iTime*(.5 + (float(idx))));\n\n    for(int i = 0; i < N; i++) {\n        obj_geo si = get_obj(i);\n        if (i != idx)\n            check_collision(si,o);\n    }\n    apply_force(o,gravity);\n    apply_force(o,wind);\n    translate(o);\n    rotate(o);\n    check_borders(o);\n    npos = o.c;\n    return npos;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n\n    int index = int(uv.x);\n    int row = int(uv.y);\n    bool isPos = row == C;\n    bool isOpos = row == OC;\n\n    if (iFrame<15) {\n        if (index < N ) {\n            if (isPos) // position\n    \t\t\tfragColor = vec4(obs[index].geo.c,0.);\n            else if (isOpos) // old pos\n            \tfragColor = vec4(obs[index].geo.oc,.0);\n            else discard;\n        }  else {\n            fragColor = vec4(-1.0);\n        }\n    } else if (index >= 0 && index < N ) {\n        obj_geo this_p = get_obj(index);\n        if (isPos) {\n            // update pos\n            vec3 npos = update_c(this_p,index);\n      \t\tfragColor = vec4(npos, .0);\n        } else if (isOpos) {\n            // update opos\n            vec3 nOpos = update_oc(this_p,index) ;\n            fragColor = vec4(nOpos, 0.0);\n    \t} else {\n            discard;\n        }\n    } else {\n        discard;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}