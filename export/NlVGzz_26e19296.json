{"ver":"0.1","info":{"id":"NlVGzz","date":"1642786044","viewed":109,"name":"Teh Beach","username":"Catarina","description":"Should be lowres to immitate pixelart... I'll have this as a TODO.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["artbeach"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define MAX_ITER 80\n\nfloat hash12(vec2 p)\n{\n vec3 p3  = fract(vec3(p.xyx) * 23.1031);\n    p3 += dot(p3, p3.yzx + 110.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash22(vec2 p){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat whiteNoise(vec2 uv){\n vec2 iuv = floor(uv);\n return hash12(iuv);\n}\n\nfloat perlinNoise(vec2 uv){\n vec2 iuv = floor(uv);\n vec2 fuv = fract(uv);\n\n vec2 suv = fuv * fuv * (3. - 2.*fuv);\n\n float bl = dot(hash22(iuv + vec2(0., 0.)), fuv - vec2(0., 0.));\n float br = dot(hash22(iuv + vec2(1., 0.)), fuv - vec2(1., 0.));\n float tl = dot(hash22(iuv + vec2(0., 1.)), fuv - vec2(0., 1.));\n float tr = dot(hash22(iuv + vec2(1., 1.)), fuv - vec2(1., 1.));\n\n float b = mix(bl, br, suv.x);\n float t = mix(tl, tr, suv.x);\n\n return mix(b, t, suv.y)+0.5;\n}\n\nfloat layeredPerlinNoise(vec2 uv){\n  float c = 0.;\n  c += perlinNoise(uv);\n  c += perlinNoise(uv*2. )*0.5;\n  c += perlinNoise(uv*4. )*0.25;\n  c += perlinNoise(uv*8. )*0.125;\n  c += perlinNoise(uv*16.)*0.0625;\n\n  return c*0.5;\n}\n\nmat2 rotation(float a){\n  return mat2(\n    cos(a), sin(a),\n    -sin(a), cos(a)\n   );\n }\n\nvec2 pixelize(in vec2 uv, in vec2 res){\n    return vec2(\n        floor(uv.x*res.x)*1./res.x+1./res.x/2.,\n        floor(uv.y*res.y)*1./res.y+1./res.y/2.\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord.xy*2. / iResolution.xy)-1.;\n uv.x *= iResolution.x / iResolution.y;\n\n float n = layeredPerlinNoise(uv);\n float l = 20.;\n float below = step(uv.y, 0.);\n below = (sin(uv.x*l) + (uv.y+0.2)*l+2.5+n*3.);\n below = step(below, 0.9);\n //float n = texture2D(perlin, uv).x;\n //float l = 20. * n;\n float d = uv.y*6.+(n/2.);\n d *= (uv.y+2.5);\n //d = sin(uv.x*l) + uv.y*l + time*0.1 ;\n //d = length(uv);\n\n // move wave stripes\n float speed = (iTime*0.5);\n float c = fract(d+speed); // make stripes from distance field that move\n c = step(c, 0.3*n*n); // take stripes with thickness\n\n float bg = step(uv.y, 0.);\n vec3 darkblue = vec3(2., 44., 121.)/255.;\n vec3 lightblue = vec3(109., 188., 248.)/255.;\n float sp = smoothstep(0., -0.5, uv.y);\n sp = -uv.y;\n\n vec3 bgcol = bg*((1.-sp)*darkblue+sp*lightblue);\n\n // glow specular\n float g = 1.-length(vec2(0., 0.1) - uv/vec2(2.5, 1.))*2.;\n g = uv.y < 0. ? g : 0.;\n vec2 ruv= rotation(0.)*(uv*40.*n*0.1*(1.+sin(iTime*5.)*.01));\n n = whiteNoise(vec2(50.5, 50.9)*ruv);\n //n = texture2D(noise, uv).x*0.8 + sin(time)*0.01;\n g = g*n*(abs(sin(iTime*2.))/16. + 0.75) > 0.25? g : 0.;\n vec3 glow = vec3(g *1.2);\n\n // sky background\n bg = 1.-step(uv.y, 0.);\n sp = -uv.y*2.+2.;\n vec3 skyblue1 = vec3(6., 74., 142.)/255.;\n vec3 skyblue2 = vec3(54., 176., 202.)/255.;\n vec3 sky = bg*((1.-sp)*skyblue1+sp*skyblue2);\n sp = -uv.y+0.4;\n sky += bg*sp;\n float t = 0.6;\n sky = uv.y > t ? sp+(1.-(-t*2.+2.))*skyblue1+(-t*2.+2.)*skyblue2 : sky;\n\n\n // cloud\n vec3 cn = bg* vec3(layeredPerlinNoise(uv))*0.1;\n n = layeredPerlinNoise(uv*(0.5, 1.0)+iTime*vec2(-0.01, 0.));\n vec3 cloud = vec3(bg*step(n, (-uv.y*2.)+0.75))*0.5;\n n = layeredPerlinNoise(uv*(1., 1.0)+iTime*vec2(-0.02, 0.));\n cloud += vec3(bg*step(n, 0.45));\n sp = -uv.y*1.+0.5;\n cloud*=clamp(sp, 0., 1.);\n\n cloud = cloud + cn;\n\n vec3 col = vec3(0.);\n\n col += sky;\n col += bgcol;\n col += c * below;\n col += vec3(glow);\n col += cloud;\n\n //col = vec3(sp);\n\n // quantizing color\n vec3 qcol = floor(col*30.+0.5)/30.;\n\n fragColor = vec4(qcol, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define MAX_ITER 80\n\nfloat hash12(vec2 p)\n{\n vec3 p3  = fract(vec3(p.xyx) * 23.1031);\n    p3 += dot(p3, p3.yzx + 110.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash22(vec2 p){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat whiteNoise(vec2 uv){\n vec2 iuv = floor(uv);\n return hash12(iuv);\n}\n\nfloat perlinNoise(vec2 uv){\n vec2 iuv = floor(uv);\n vec2 fuv = fract(uv);\n\n vec2 suv = fuv * fuv * (3. - 2.*fuv);\n\n float bl = dot(hash22(iuv + vec2(0., 0.)), fuv - vec2(0., 0.));\n float br = dot(hash22(iuv + vec2(1., 0.)), fuv - vec2(1., 0.));\n float tl = dot(hash22(iuv + vec2(0., 1.)), fuv - vec2(0., 1.));\n float tr = dot(hash22(iuv + vec2(1., 1.)), fuv - vec2(1., 1.));\n\n float b = mix(bl, br, suv.x);\n float t = mix(tl, tr, suv.x);\n\n return mix(b, t, suv.y)+0.5;\n}\n\nfloat layeredPerlinNoise(vec2 uv){\n  float c = 0.;\n  c += perlinNoise(uv);\n  c += perlinNoise(uv*2. )*0.5;\n  c += perlinNoise(uv*4. )*0.25;\n  c += perlinNoise(uv*8. )*0.125;\n  c += perlinNoise(uv*16.)*0.0625;\n\n  return c*0.5;\n}\n\nmat2 rotation(float a){\n  return mat2(\n    cos(a), sin(a),\n    -sin(a), cos(a)\n   );\n }\n\nvec2 pixelize(in vec2 uv, in vec2 res){\n    return vec2(\n        floor(uv.x*res.x)*1./res.x+1./res.x/2.,\n        floor(uv.y*res.y)*1./res.y+1./res.y/2.\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord.xy*2. / iResolution.xy)-1.;\n uv.x *= iResolution.x / iResolution.y;\n\n float n = layeredPerlinNoise(uv);\n float l = 20.;\n float below = step(uv.y, 0.);\n below = (sin(uv.x*l) + (uv.y+0.2)*l+2.5+n*3.);\n below = step(below, 0.9);\n //float n = texture2D(perlin, uv).x;\n //float l = 20. * n;\n float d = uv.y*6.+(n/2.);\n d *= (uv.y+2.5);\n //d = sin(uv.x*l) + uv.y*l + time*0.1 ;\n //d = length(uv);\n\n // move wave stripes\n float speed = (iTime*0.5);\n float c = fract(d+speed); // make stripes from distance field that move\n c = step(c, 0.3*n*n); // take stripes with thickness\n\n float bg = step(uv.y, 0.);\n vec3 darkblue = vec3(2., 44., 121.)/255.;\n vec3 lightblue = vec3(109., 188., 248.)/255.;\n float sp = smoothstep(0., -0.5, uv.y);\n sp = -uv.y;\n\n vec3 bgcol = bg*((1.-sp)*darkblue+sp*lightblue);\n\n // glow specular\n float g = 1.-length(vec2(0., 0.1) - uv/vec2(2.5, 1.))*2.;\n g = uv.y < 0. ? g : 0.;\n vec2 ruv= rotation(0.)*(uv*40.*n*0.1*(1.+sin(iTime*5.)*.01));\n n = whiteNoise(vec2(50.5, 50.9)*ruv);\n //n = texture2D(noise, uv).x*0.8 + sin(time)*0.01;\n g = g*n*(abs(sin(iTime*2.))/16. + 0.75) > 0.25? g : 0.;\n vec3 glow = vec3(g *1.2);\n\n // sky background\n bg = 1.-step(uv.y, 0.);\n sp = -uv.y*2.+2.;\n vec3 skyblue1 = vec3(6., 74., 142.)/255.;\n vec3 skyblue2 = vec3(54., 176., 202.)/255.;\n vec3 sky = bg*((1.-sp)*skyblue1+sp*skyblue2);\n sp = -uv.y+0.4;\n sky += bg*sp;\n float t = 0.6;\n sky = uv.y > t ? sp+(1.-(-t*2.+2.))*skyblue1+(-t*2.+2.)*skyblue2 : sky;\n\n\n // cloud\n vec3 cn = bg* vec3(layeredPerlinNoise(uv))*0.1;\n n = layeredPerlinNoise(uv*(0.5, 1.0)+iTime*vec2(-0.01, 0.));\n vec3 cloud = vec3(bg*step(n, (-uv.y*2.)+0.75))*0.5;\n n = layeredPerlinNoise(uv*(1., 1.0)+iTime*vec2(-0.02, 0.));\n cloud += vec3(bg*step(n, 0.45));\n sp = -uv.y*1.+0.5;\n cloud*=clamp(sp, 0., 1.);\n\n cloud = cloud + cn;\n\n vec3 col = vec3(0.);\n\n col += sky;\n col += bgcol;\n col += c * below;\n col += vec3(glow);\n col += cloud;\n\n //col = vec3(sp);\n\n // quantizing color\n vec3 qcol = floor(col*30.+0.5)/30.;\n\n fragColor = vec4(qcol, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}