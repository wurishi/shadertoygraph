{"ver":"0.1","info":{"id":"tsKSzR","date":"1573285192","viewed":3930,"name":"sin_wave","username":"skaplun","description":"https://i.pinimg.com/originals/93/c2/e7/93c2e7c5337c0623b8d3626bdbe82bdf.jpg","likes":144,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 128\n#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n#define EPSILON 0.0001\n\nconst float PI = acos(-1.);\n\nfloat heightAtPos(vec3 p){\n\tfloat val = cos(clamp(p.x + sin(p.z*.5+iTime) * 3., -PI, PI)) * .5 + .5;\n    return pow(abs(val), 4.) * sin(p.z*.5+iTime) * 3.;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat world(vec3 p){\n    vec3 mp = p;\n    float spacing = .2;// + smoothstep(-5., 5., p.z)*.4;\n    float v = mod(mp.z, spacing) - spacing * .5;\n    return opSubtraction(-p.y + heightAtPos(p), opSubtraction(v + .001, v - .001));\n}\n\nfloat march(vec3 eye, vec3 marchingDirection){\n    const float precis = .001;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\n\t    vec3 p = eye + marchingDirection * t;\n        float hit = world(p);\n        if(hit < precis) return t;\n        t += hit * .25;\n    }\n    return -1.;\n}\n\nvec3 color(vec3 camPos, vec3 rayDir){\n    vec3 col = vec3(0.);\n    vec3 pos = camPos;\n    \n    float dis = march(pos, rayDir);\n    if(dis >= 0.){\n        pos += rayDir * dis;\n\t\tfloat h = heightAtPos(pos);\n        col = vec3(smoothstep(.05, 0., distance(pos.y, h - .05)));\n    }\n    \n    return col;\n}\n\nvec3 makeClr(vec2 fragCoord){\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 origin = vec3(0., vec2(10.));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    return color(origin, dir);\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(makeClr(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Box{ vec3 origin; vec3 bounds;};\nstruct Ray{ vec3 origin, dir;};\nstruct HitRecord{vec2 dist;vec3 ptnt[2];};\nstruct Plane{ vec3 origin; vec3 normal;};\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}","name":"Common","description":"","type":"common"}]}