{"ver":"0.1","info":{"id":"7sXyRn","date":"1641573399","viewed":83,"name":"Noise Sampler Test 1","username":"Nickid2018","description":"Minecraft Terrain Builder noise sampler test -\nUsing \"net.minecraft.world.level.levelgen.synth.ImprovedNoise\" (Perlin Noise)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Random Data generated by MC 1.18.1 ImprovedNoise and LCG RNG with seed 514\nfloat xo = 175.4320107951048;\nfloat yo = 181.29370179970425;\nfloat zo = 125.21020955393291;\nint p[256] = int[256](-125, 116, -60, 13, 67, -37, 89, 54, -53, 35, -70, 57, -82, -77, -16, 30, 81, 111, 94, 25, -55, -40, 59, -32, -95, 85, 74, -3, -49, 56, -98, -7, 62, -124, 16, -24, -15, -107, 19, -128, 97, -67, 0, -31, 68, 22, 98, 10, 86, 9, 28, -51, -2, -102, -111, -73, -106, 66, 51, 107, 1, 61, 87, 115, 32, 42, 75, -126, 15, 45, -97, 104, 27, 63, 33, -84, -13, 2, 79, -72, 41, -33, 14, -112, -65, 105, 29, 123, 100, 40, -80, 125, -68, 90, -38, 117, -61, -43, -20, -110, 52, 12, 84, 6, 88, -22, 55, 119, -99, -42, -50, -87, -89, -105, -109, 53, 48, 77, 34, -46, -113, 83, -14, -120, -54, -36, -63, -9, -19, -94, 71, -12, 31, -118, 21, 93, -91, -117, 69, 24, -81, -4, -100, 65, -85, 96, 36, 92, -18, 95, -6, 64, -44, 114, -93, -123, -10, 113, 60, 20, 7, -56, 11, 17, 118, 72, 110, -122, 70, 44, -39, -57, 38, 3, -69, -8, 8, -71, 5, -103, 121, -21, 103, 109, 102, 49, 126, 58, -1, -11, 124, -88, -108, 78, -121, 108, -119, -116, 4, 112, 91, -86, 106, 120, 82, -58, -35, -127, -75, -17, 43, -25, -90, 99, -45, -83, -5, -28, 101, -114, -47, 23, -79, 37, 18, -26, -23, -59, 46, -101, 76, -30, 50, -27, -76, -74, 122, 127, -41, -64, -96, -29, 80, -92, -115, -104, 39, -52, -34, 73, -48, -66, 47, -78, 26, -62);\n// Random Constant End --\n\n// Utility Functions\nint GRADIENT_1[16] = int[16](1, -1, 1, -1, 1, -1, 1, -1, 0, 0, 0, 0, 1, 0, -1, 0);\nint GRADIENT_2[16] = int[16](1, 1, -1, -1, 0, 0, 0, 0, 1, -1, 1, -1, 1, -1, 1, -1);\nint GRADIENT_3[16] = int[16](0, 0, 0, 0, 1, 1, -1, -1, 1, 1, -1, -1, 0, 1, 0, -1);\n\nint getGradient(int hash) {\n    return p[hash & 0xFF] & 0xFF;\n}\n\nfloat lerp(float delta, float start, float end) {\n    return start + delta * (end - start);\n}\n\nfloat lerp2(float deltaX, float deltaY, float x0y0, float x1y0, float x0y1, float x1y1) {\n    return lerp(deltaY, lerp(deltaX, x0y0, x1y0), lerp(deltaX, x0y1, x1y1));\n}\n\nfloat lerp3(float deltaX, float deltaY, float deltaZ, float x0y0z0, float x1y0z0, float x0y1z0, float x1y1z0, float x0y0z1, float x1y0z1, float x0y1z1, float x1y1z1) {\n    return lerp(deltaZ, lerp2(deltaX, deltaY, x0y0z0, x1y0z0, x0y1z0, x1y1z0), lerp2(deltaX, deltaY, x0y0z1, x1y0z1, x0y1z1, x1y1z1));\n}\n\nfloat perlinFade(float value) {\n    return value * value * value * (value * (value * 6.0 - 15.0) + 10.0);\n}\n\nfloat dotImpl(int hash, float x, float y, float z) {\n    return float(GRADIENT_1[hash & 0xF]) * x + float(GRADIENT_2[hash & 0xF]) * y + float(GRADIENT_3[hash & 0xF]) * z;\n}\n\nfloat grad(int hash, float x, float y, float z) {\n    return dotImpl(hash, x, y, z);\n}\n// Utility Functions End\n\nfloat sampleAndLerp(int sectionX, int sectionY, int sectionZ,\n            float localX, float localY, float localZ, float fadeLocalX) {\n    int i = getGradient(sectionX);\n    int j = getGradient(sectionX + 1);\n    int k = getGradient(i + sectionY);\n    int l = getGradient(i + sectionY + 1);\n    int m = getGradient(j + sectionY);\n    int n = getGradient(j + sectionY + 1);\n    float d = grad(getGradient(k + sectionZ), localX, localY, localZ);\n    float e = grad(getGradient(m + sectionZ), localX - 1.0, localY, localZ);\n    float f = grad(getGradient(l + sectionZ), localX, localY - 1.0, localZ);\n    float g = grad(getGradient(n + sectionZ), localX - 1.0, localY - 1.0, localZ);\n    float h = grad(getGradient(k + sectionZ + 1), localX, localY, localZ - 1.0);\n    float o = grad(getGradient(m + sectionZ + 1), localX - 1.0, localY, localZ - 1.0);\n    float p = grad(getGradient(l + sectionZ + 1), localX, localY - 1.0, localZ - 1.0);\n    float q = grad(getGradient(n + sectionZ + 1), localX - 1.0, localY - 1.0, localZ - 1.0);\n    float r = perlinFade(localX);\n    float s = perlinFade(fadeLocalX);\n    float t = perlinFade(localZ);\n    return lerp3(r, s, t, d, e, f, g, h, o, p, q);\n}\n    \nfloat noiseImpl(float x, float y, float z, float yScale, float yMax) {\n    float n;\n    float d = x + xo;\n    float e = y + yo;\n    float f = z + zo;\n    int i = int(floor(d));\n    int j = int(floor(e));\n    int k = int(floor(f));\n    float g = d - float(i);\n    float h = e - float(j);\n    float l = f - float(k);\n    if (yScale != 0.0) {\n        float m = yMax >= 0.0 && yMax < h ? yMax : h;\n        n = floor(m / yScale + 1.0E-7) * yScale;\n    } else {\n        n = 0.0;\n    }\n    return sampleAndLerp(i, j, k, g, h - n, l, h);\n}\n\nfloat noise(float x, float y, float z) {\n    return noiseImpl(x, y, z, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float data = noise(uv.x * 8.0, uv.y * 8.0, iTime - 8.0 * floor(iTime / 8.0));\n    \n    // Output to screen\n    fragColor = vec4(data, data, data, 1.0);\n}","name":"Image","description":"","type":"image"}]}