{"ver":"0.1","info":{"id":"Xcl3WM","date":"1703131835","viewed":28,"name":"perlinnoisetest3D","username":"hppz","description":"test for 3D fbm","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//random vector\nvec3 hash33(vec3 p)\n{\n    // p乘以一个固定矩阵\n    p = p * mat3(1111, 222.2, 333.3, \n                 444.4, 555.5, 666.6, \n                 777.7, 888.8, 999.9);\n    p = -1.0 + 2.0 * fract(sin(p) * 43758.5453);\n    // 随time变化，返回3维向量\n    return sin(p * 3.141 + iTime);\n}\n\nfloat perlinNoiseLerp(float l, float r, float t)\n{\n    t = ((6.0 * t - 15.0) * t + 10.0) * t * t * t;\n    return mix(l, r, t);\n}\n\nfloat perlin_noise(vec3 p)\n{\n    // pi和pf（像素坐标和相对于格子的偏移）\n    vec3 pi = floor(p);\n    vec3 pf = fract(p);\n\n    // 计算uvw\n    vec3 uvw = pf * pf * (3.0 - 2.0 * pf);\n\n    // 八个点ABCDEFGH=0,0,0\\0,0,1\\0,1,0\\0,1,1\\1,0,0\\1,0,1\\1,1,0\\1,1,1\n    float f000 = dot(hash33(pi + vec3(0.0, 0.0, 0.0)), pf - vec3(0.0, 0.0, 0.0));\n    float f001 = dot(hash33(pi + vec3(0.0, 0.0, 1.0)), pf - vec3(0.0, 0.0, 1.0));\n    float f010 = dot(hash33(pi + vec3(0.0, 1.0, 0.0)), pf - vec3(0.0, 1.0, 0.0));\n    float f011 = dot(hash33(pi + vec3(0.0, 1.0, 1.0)), pf - vec3(0.0, 1.0, 1.0));\n    float f100 = dot(hash33(pi + vec3(1.0, 0.0, 0.0)), pf - vec3(1.0, 0.0, 0.0));\n    float f101 = dot(hash33(pi + vec3(1.0, 0.0, 1.0)), pf - vec3(1.0, 0.0, 1.0));\n    float f110 = dot(hash33(pi + vec3(1.0, 1.0, 0.0)), pf - vec3(1.0, 1.0, 0.0));\n    float f111 = dot(hash33(pi + vec3(1.0, 1.0, 1.0)), pf - vec3(1.0, 1.0, 1.0));\n\n    float temp00 = perlinNoiseLerp(f000, f100, uvw.x);\n    float temp01 = perlinNoiseLerp(f001, f101, uvw.x);\n    float temp10 = perlinNoiseLerp(f010, f110, uvw.x);\n    float temp11 = perlinNoiseLerp(f011, f111, uvw.x);\n\n    float temp0 = perlinNoiseLerp(temp00, temp10, uvw.y);\n    float temp1 = perlinNoiseLerp(temp01, temp11, uvw.y);\n\n    float noiseValue = perlinNoiseLerp(temp0, temp1, uvw.z);\n\n    // 去除黑边\n    return noiseValue = (noiseValue + 0.5) / 2.0;\n}\n\n\nfloat fbm( vec3 p )\n{\n   p *= 4.;\n   float a = 1., r = 0., s=0.;\n    \n   for (int i=0; i<4; i++) {\n     //每次频率翻倍，强度减半\n     r += a*abs(perlin_noise(p)); s+= a; p *= 2.; a*=.5;\n   }\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x,\niResolution.y);\n    vec3 p = vec3(uv.x,uv.y,1.0);\n  \n    float f = fbm(p);\n    //float f = noise_one_octave(uv);\n    \n    vec3 lightColor = vec3(1.0);\n\t\n    vec3 color = vec3(lightColor * f);\n   \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}