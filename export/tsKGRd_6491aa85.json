{"ver":"0.1","info":{"id":"tsKGRd","date":"1570805751","viewed":99,"name":"Pythagorean tiling","username":"thereallex","description":"Use the mouse to change the angle and size of the small square.\n\nImplementation of the pythagorean tiling (https://en.wikipedia.org/wiki/Pythagorean_tiling). Would love to hear ways that this can be optimized.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tiling","pythagorean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// show indices of the different parts with solid colors\n//#define SHOW_INDICES\n// show the (2D) id of the cells\n//#define SHOW_IDS\n//#define SHOW_DISTANCE\n#define SHOW_EDGES\n\nconst float SCALE = 5.;\n\nconst float PI = 3.14159265359;\n\n// math\nmat2 rot2( float angle ) {\n\tfloat c = cos( angle );\n\tfloat s = sin( angle );\n\t\n\treturn mat2(\n\t\t c, s,\n\t\t-s, c\n\t);\n}\n\nfloat corner(vec2 p, vec2 s) {\n    return step(0., s.y * step(s.x, p.x) + p.y - s.y * .5);\n}\n\n/**\n  * returns a vec4 representing:\n  *  - ret.xy - the id of the element\n  *  - ret.z - the index / type of the element (0.: middle, 1.-4. corners)\n  *  - ret.w - the distance to the edge\n  * @param p - the coordinate in 2d space to transform\n  * @param angle - the angle of the pattern\n  * @TODO: return the distance to the edges\n  * \n**/\nvec4 pPythagorean(inout vec2 p, float angle) {\n    \n    // make the tiling repeat\n    vec2 id = floor(p);\n    p = fract(p);\n    \n    // move to center\n    p = p - .5;\n    \n    // rotate space to the specified angle\n    p = rot2(angle) * p;\n    // small square size\n    float sss = -sin(angle);\n    // large square size\n    float lss = cos(angle);\n    \n    // corner helper\n    vec2 ch = vec2(sss * .5, sss); \n    vec2 ch2 = vec2(ch.x, -ch.x);\n    \n    float st = corner(p, ch);\n    float sb = corner(-p, ch);\n    float sr = corner(vec2(-p.y, p.x), ch);\n    float sl = corner(vec2(p.y, -p.x), ch);\n    \n    float tl = st * sl; // top left\n    float br = sb * sr; // bottom right\n    float bl = sb * sl; // bottom left\n    float tr = st * sr; // top right\n    float cen = (1. - sl) * (1. - sr); // center\n    \n    // scale down\n    p /= lss;\n    ch /= lss;\n    ch2 /= lss;\n    \n    p = mix(p, p - vec2(-1. + ch.x, ch.x), tl); // top left\n    p = mix(p, p + ch2.yx, tr); // top right\n    p = mix(p, p - vec2(-ch.x, -1. - ch.x), br); // bottom right\n    p = mix(p, p - ch2.yx + 1., bl); // bottom left\n    p = mix(p, (p / ch.y) + .5, cen); // center part, scale and move to bottom left corner\n    \n    // create a triangular signal\n    vec2 dEdge = .5 - abs(fract(p) - .5);\n    // scale distance for the big and small squares\n    dEdge *= mix(lss, sss, cen);\n    dEdge = abs(dEdge);\n    // distance to edge\n    float d = min(dEdge.x, dEdge.y);\n    \n    // distance to center\n    //float d = length(p - vec2(.5));\n    \n    // index of element (counter-clockwise)\n    // center: 0,\n    // bottom left: 1\n    // bottom right: 2,\n   \t// top right: 3,\n    // top left: 4,\n    float index = bl * 1. + br * 2. + tr * 3. + 4. * tl;\n    \n    // calculate the real id\n    id += vec2(sr, st);\n    \n    return vec4(id, index, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // NDC pixel coordinates (from -1 to 1)\n    vec2 ndc = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n\n    // make square rect\n    #if 0\n    if(abs(ndc.x) > .5) {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    #endif\n    \n    // create normalized coordinates [0-1]\n   \tvec2 uv = ndc + .5;\n    \n    // scale down the tiling\n    uv *= SCALE;\n    \n    float angle = -(2. * (iMouse.x / iResolution.x) - 1.) * PI * .25;\n    \n    // starting animation\n    if (iMouse.xy==vec2(0)) {\n        angle = PI * .25 * sin(iTime * .2);\n    }\n    \n    vec2 p = rot2(-angle) * (uv - SCALE * .5);\n    \n    \n    vec4 ret = pPythagorean(p, angle);\n    vec2 id = ret.xy;\n    float index = ret.z;\n    float d = ret.w;\n    \n    float lod = log2( (iChannelResolution[0].y*5.) / iResolution.y / cos(angle));\n    // do some texture sampling\n    vec4 texCol = textureLod(iChannel0, p, lod);\n    \n   \tvec3 col = texCol.rgb;\n    \n    #ifdef SHOW_INDICES\n    if(index == 0.) col = vec3(1., 0., 0.); // red\n    if(index == 1.) col = vec3(1., 1., 0.); // yellow\n    if(index == 2.) col = vec3(0., 1., 0.); // green\n    if(index == 3.) col = vec3(0., 0., 1.); // blue\n    if(index == 4.) col = vec3(1., 1., 1.); // white\n    #endif\n    \n    #ifdef SHOW_IDS\n    col = vec3(id * .2, 0.);\n    #endif\n    \n    #ifdef SHOW_DISTANCE\n    col = vec3(d);\n    #endif\n    \n    #ifdef SHOW_EDGES\n    col *= vec3(smoothstep(0.01, 0.03, d));\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}