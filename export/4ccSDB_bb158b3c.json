{"ver":"0.1","info":{"id":"4ccSDB","date":"1714378264","viewed":64,"name":"8-digit LED","username":"miguel000","description":"Draw the time.","likes":4,"published":1,"flags":32,"usePreview":1,"tags":["7segment","8digit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define KERNEL 5\n#define SIZE 3\n\n#define DISPERSION 50.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 pixel = vec2( 1.0 ) / iResolution.xy;\n    \n    vec3 light = texture( iChannel0, uv ).xyz;\n    \n    \n    vec3 color = vec3( 0.0 );\n    \n    float weight_total = 0.0;\n    for( int x = -KERNEL * SIZE; x <= KERNEL * SIZE; x += SIZE )\n    {\n        for( int y = -KERNEL * SIZE; y <= KERNEL * SIZE; y += SIZE )\n        {\n            float dist = length( vec2( x, y ) );\n            float weight = exp( - dist * dist / ( 2. * DISPERSION ) );\n            \n            color += texture( iChannel0, uv + pixel * vec2( x, y ) ).xyz * weight;\n            weight_total += weight;\n        }\n    }\n    color /= weight_total;\n    \n    fragColor = vec4( max( light, color ), 1.0 );\n    //fragColor = light;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define LINE_WIDTH  0.01\n#define LINE_OFFSET 0.001\n\nint extractDigit( int num, int index )\n{\n    for( int i = 0; i < index; ++i )\n    {\n        num /= 10;\n    }\n    \n    return num % 10;\n}\n\n// n = number\n// s = section_index\n// \n//  0\n// 1 2\n//  3\n// 4 5\n//  6\nbool is_on_8digit_section( int n, int s )\n{\n    switch( n )\n    {\n        case 0:\n            return s != 3;\n            break;\n        case 1:\n            return s == 2 || s == 5;\n            break;\n        case 2:\n            return s != 1 && s != 5;\n            break;\n        case 3:\n            return s != 1 && s != 4;\n            break;\n        case 4:\n            return s != 0 && s != 4 && s != 6;\n            break;\n        case 5:\n            return s != 2 && s != 4;\n            break;\n        case 6:\n            return s != 2;\n            break;\n        case 7:\n            return s == 0 || s == 2 || s == 5;\n            break;\n        case 8:\n            return true;\n            break;\n        case 9:\n            return s != 4;\n            break;\n    }\n    \n    return false;\n}\n\nfloat draw_dia( vec2 dia_pos, vec2 pos )\n{\n    vec2 diff = abs( dia_pos - pos );\n    float dist = diff.x + diff.y;\n    \n    if( dist < LINE_WIDTH / 2.0 )\n    {\n        return 1.0;\n    }\n    \n    return 0.0;\n}\n\nfloat draw_line_x( float x_0, float x_1, float y, vec2 pos )\n{\n    if( x_0 < pos.x && pos.x < x_1\n       && y - LINE_WIDTH / 2. < pos.y && pos.y < y + LINE_WIDTH / 2. )\n    {\n        return 1.0;\n    }\n    \n    return max( draw_dia( vec2( x_0, y ), pos ), draw_dia( vec2( x_1, y ), pos ) );\n}\n\nfloat draw_line_y( float y_0, float y_1, float x, vec2 pos )\n{\n    if( y_0 < pos.y && pos.y < y_1\n       && x - LINE_WIDTH / 2. < pos.x && pos.x < x + LINE_WIDTH / 2. )\n    {\n        return 1.0;\n    }\n    \n    return max( draw_dia( vec2( x, y_0 ), pos ), draw_dia( vec2( x, y_1 ), pos ) );\n}\n\nvec4 draw8digit( int num, vec4 light_color, vec4 background_color, vec2 size, vec2 center_pos, vec2 pos )\n{\n    vec2 local_pos = pos - center_pos;\n\n    float light = 0.;\n    if( is_on_8digit_section( num, 0 ) )\n    {\n        float x_0 = -size.x * 0.5 + LINE_WIDTH * 1. + LINE_OFFSET;\n        float x_1 = size.x * 0.5 - LINE_WIDTH * 1. - LINE_OFFSET;\n        \n        float y = size.y * 0.5 - LINE_WIDTH * 0.5;\n\n        light = max( light, draw_line_x( x_0, x_1, y, local_pos ) );\n    }\n    if( is_on_8digit_section( num, 1 ) )\n    {\n        float y_0 = LINE_WIDTH * 0.5 + LINE_OFFSET;\n        float y_1 = size.y * 0.5 - LINE_WIDTH * 1. - LINE_OFFSET;\n        \n        float x = -size.x * 0.5 + LINE_WIDTH * 0.5;\n\n        light = max( light, draw_line_y( y_0, y_1, x, local_pos ) );\n    }\n    if( is_on_8digit_section( num, 2 ) )\n    {\n        float y_0 = LINE_WIDTH / 2. + LINE_OFFSET;\n        float y_1 = size.y / 2. - LINE_WIDTH * 1. - LINE_OFFSET;\n        \n        float x = size.x / 2. - LINE_WIDTH / 2.;\n\n        light = max( light, draw_line_y( y_0, y_1, x, local_pos ) );\n    }\n    if( is_on_8digit_section( num, 3 ) )\n    {\n        float x_0 = -size.x / 2. + LINE_WIDTH * 1. + LINE_OFFSET;\n        float x_1 = size.x / 2. - LINE_WIDTH * 1. - LINE_OFFSET;\n        \n        float y = 0.;\n\n        light = max( light, draw_line_x( x_0, x_1, y, local_pos ) );\n    }\n    if( is_on_8digit_section( num, 4 ) )\n    {\n        float y_0 = -size.y / 2. + LINE_WIDTH * 1. + LINE_OFFSET;\n        float y_1 = -LINE_WIDTH / 2. - LINE_OFFSET;\n        \n        float x = -size.x / 2. + LINE_WIDTH / 2.;\n\n        light = max( light, draw_line_y( y_0, y_1, x, local_pos ) );\n    }\n    if( is_on_8digit_section( num, 5 ) )\n    {\n        float y_0 = -size.y / 2. + LINE_WIDTH * 1. + LINE_OFFSET;\n        float y_1 = -LINE_WIDTH / 2. - LINE_OFFSET;\n        \n        float x = size.x / 2. - LINE_WIDTH / 2.;\n\n        light = max( light, draw_line_y( y_0, y_1, x, local_pos ) );\n    }\n    if( is_on_8digit_section( num, 6 ) )\n    {\n        float x_0 = -size.x / 2. + LINE_WIDTH * 1. + LINE_OFFSET;\n        float x_1 = size.x / 2. - LINE_WIDTH * 1. - LINE_OFFSET;\n        \n        float y = -size.y / 2. + LINE_WIDTH * 0.5;\n\n        light = max( light, draw_line_x( x_0, x_1, y, local_pos ) );\n    }\n    \n    return mix( background_color, light_color, light );\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NUMBER_SIZE vec2(0.055, 0.11)\n#define IS_INSIDE_RECT( CENTER_POS_X ) ( CENTER_POS_X - NUMBER_SIZE.x / 2.0 < pos.x && pos.x < CENTER_POS_X + NUMBER_SIZE.x / 2.0 && yCenter - NUMBER_SIZE.y / 2.0 < pos.y && pos.y < yCenter + NUMBER_SIZE.y / 2.0 )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y / iResolution.x;\n    vec2 pos = fragCoord / iResolution.xy;\n    pos.y *= aspect;\n    \n    float yCenter = 0.5 * aspect;\n    \n    \n    int year = int(iDate.x);\n    int month = int(iDate.y) + 1;\n    int day = int(iDate.z);\n    \n    int time_in_second = int(iDate.w);\n    \n    int hour = time_in_second / ( 60 * 60 );\n    int minute = ( time_in_second / 60 ) % 60;\n    int second = time_in_second % 60;\n\n    float init_pos_x = 0.035;\n    float pos_offset = 0.005;\n    float section_offset = 0.029;\n    \n    float year_init_pos   = init_pos_x;\n    float month_init_pos  = year_init_pos   + NUMBER_SIZE.x * 4. + pos_offset * 3. + section_offset;\n    float day_init_pos    = month_init_pos  + NUMBER_SIZE.x * 2. + pos_offset * 1. + section_offset;\n    float hour_init_pos   = day_init_pos    + NUMBER_SIZE.x * 2. + pos_offset * 1. + section_offset * 2.0;\n    float minute_init_pos = hour_init_pos   + NUMBER_SIZE.x * 2. + pos_offset * 1. + section_offset;\n    float second_init_pos = minute_init_pos + NUMBER_SIZE.x * 2. + pos_offset * 1. + section_offset;\n\n\n    float pos_year_0 = year_init_pos;\n    float pos_year_1 = year_init_pos + NUMBER_SIZE.x + pos_offset;\n    float pos_year_2 = year_init_pos + NUMBER_SIZE.x * 2. + pos_offset * 2.;\n    float pos_year_3 = year_init_pos + NUMBER_SIZE.x * 3. + pos_offset * 3.;\n    \n    float pos_month_0 = month_init_pos;\n    float pos_month_1 = month_init_pos + NUMBER_SIZE.x + pos_offset;\n    \n    float pos_day_0 = day_init_pos;\n    float pos_day_1 = day_init_pos + NUMBER_SIZE.x + pos_offset;\n    \n    float pos_hour_0 = hour_init_pos;\n    float pos_hour_1 = hour_init_pos + NUMBER_SIZE.x + pos_offset;\n    \n    float pos_minute_0 = minute_init_pos;\n    float pos_minute_1 = minute_init_pos + NUMBER_SIZE.x + pos_offset;\n    \n    float pos_second_0 = second_init_pos;\n    float pos_second_1 = second_init_pos + NUMBER_SIZE.x + pos_offset;\n    \n\n    vec4 background_color = vec4( vec3( 0.1 ), 1.0 );\n    vec4 light_color = vec4( 1.0, 0.0, 0.0, 1.0 );\n    \n    vec4 color = background_color;\n\n\n    if( IS_INSIDE_RECT( pos_year_0 ) )\n    {\n        color = draw8digit( extractDigit( year, 3 ), light_color, background_color, NUMBER_SIZE, vec2( pos_year_0, yCenter ), pos );\n    }\n    else if( IS_INSIDE_RECT( pos_year_1 ) )\n    {\n        color = draw8digit( extractDigit( year, 2 ), light_color, background_color, NUMBER_SIZE, vec2( pos_year_1, yCenter ), pos );\n    }\n    else if( IS_INSIDE_RECT( pos_year_2 ) )\n    {\n        color = draw8digit( extractDigit( year, 1 ), light_color, background_color, NUMBER_SIZE, vec2( pos_year_2, yCenter ), pos );\n    }\n    else if( IS_INSIDE_RECT( pos_year_3 ) )\n    {\n        color = draw8digit( extractDigit( year, 0 ), light_color, background_color, NUMBER_SIZE, vec2( pos_year_3, yCenter ), pos );\n    }\n    \n    else if( IS_INSIDE_RECT( pos_month_0 ) )\n    {\n        color = draw8digit( extractDigit( month, 1 ), light_color, background_color, NUMBER_SIZE, vec2( pos_month_0, yCenter ), pos );\n    }\n    else if( IS_INSIDE_RECT( pos_month_1 ) )\n    {\n        color = draw8digit( extractDigit( month, 0 ), light_color, background_color, NUMBER_SIZE, vec2( pos_month_1, yCenter ), pos );\n    }\n    \n    else if( IS_INSIDE_RECT( pos_day_0 ) )\n    {\n        color = draw8digit( extractDigit( day, 1 ), light_color, background_color, NUMBER_SIZE, vec2( pos_day_0, yCenter ), pos );\n    }\n    else if( IS_INSIDE_RECT( pos_day_1 ) )\n    {\n        color = draw8digit( extractDigit( day, 0 ), light_color, background_color, NUMBER_SIZE, vec2( pos_day_1, yCenter ), pos );\n    }\n    \n    else if( IS_INSIDE_RECT( pos_hour_0 ) )\n    {\n        color = draw8digit( extractDigit( hour, 1 ), light_color, background_color, NUMBER_SIZE, vec2( pos_hour_0, yCenter ), pos );\n    }\n    else if( IS_INSIDE_RECT( pos_hour_1 ) )\n    {\n        color = draw8digit( extractDigit( hour, 0 ), light_color, background_color, NUMBER_SIZE, vec2( pos_hour_1, yCenter ), pos );\n    }\n    \n    else if( IS_INSIDE_RECT( pos_minute_0 ) )\n    {\n        color = draw8digit( extractDigit( minute, 1 ), light_color, background_color, NUMBER_SIZE, vec2( pos_minute_0, yCenter ), pos );\n    }\n    else if( IS_INSIDE_RECT( pos_minute_1 ) )\n    {\n        color = draw8digit( extractDigit( minute, 0 ), light_color, background_color, NUMBER_SIZE, vec2( pos_minute_1, yCenter ), pos );\n    }\n    \n    else if( IS_INSIDE_RECT( pos_second_0 ) )\n    {\n        color = draw8digit( extractDigit( second, 1 ), light_color, background_color, NUMBER_SIZE, vec2( pos_second_0, yCenter ), pos );\n    }\n    else if( IS_INSIDE_RECT( pos_second_1 ) )\n    {\n        color = draw8digit( extractDigit( second, 0 ), light_color, background_color, NUMBER_SIZE, vec2( pos_second_1, yCenter ), pos );\n    }\n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"}]}