{"ver":"0.1","info":{"id":"wls3RX","date":"1557245449","viewed":725,"name":"Transparent Slime","username":"fizzer","description":"After [url=https://www.shadertoy.com/view/4ssGz8]6 years[/url] this slime has a few scratches, but he's clearly still got some 'bounce' in him!","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","sdf","refraction","transparent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    fragColor /= fragColor.w;\n\n    // Tonemap and \"colourgrade\"\n\n    fragColor /= (fragColor + .4) / 2.;\n    fragColor.rgb = pow(fragColor.rgb, mix(vec3(1), vec3(1, 1.4, 1.8), .1));\n\n    // Gamma correction\n\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2)) +\n        texelFetch(iChannel1, ivec2(fragCoord) & 1023, 0).rgb / 30.;\n    \n    fragColor.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Polynomial smooth min from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a,float b,float k){return -smin(-a,-b,k);}\n\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\n// Smooth 3D texture interpolation\nvec4 smoothSample(sampler3D tex, vec3 p, int level)\n{\n    vec3 sz = vec3(textureSize(tex, 0));\n    \n    ivec3 ip = ivec3(floor(p * sz));\n    \n    vec4 s0 = texelFetch(tex, (ip + ivec3(0, 0, 0)) & ivec3(sz - 1.), level);\n    vec4 s1 = texelFetch(tex, (ip + ivec3(1, 0, 0)) & ivec3(sz - 1.), level);\n    vec4 s2 = texelFetch(tex, (ip + ivec3(0, 1, 0)) & ivec3(sz - 1.), level);\n    vec4 s3 = texelFetch(tex, (ip + ivec3(1, 1, 0)) & ivec3(sz - 1.), level);\n    vec4 s4 = texelFetch(tex, (ip + ivec3(0, 0, 1)) & ivec3(sz - 1.), level);\n    vec4 s5 = texelFetch(tex, (ip + ivec3(1, 0, 1)) & ivec3(sz - 1.), level);\n    vec4 s6 = texelFetch(tex, (ip + ivec3(0, 1, 1)) & ivec3(sz - 1.), level);\n    vec4 s7 = texelFetch(tex, (ip + ivec3(1, 1, 1)) & ivec3(sz - 1.), level);\n    vec3 f = smoothstep(0., 1., fract(p * sz));\n\n    return mix(\n        mix(mix(s0, s1, f.x),\n            mix(s2, s3, f.x), f.y),\n        mix(mix(s4, s5, f.x),\n            mix(s6, s7, f.x), f.y),\n        f.z);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi = acos(-1.);\n\nfloat square(vec2 v0, vec2 v1, vec2 p)\n{\n    vec2 o = (v0 + v1) * 0.5, s = abs(v1 - v0) * 0.5;\n    return max(abs(p.x - o.x) - s.x, abs(p.y - o.y) - s.y);\n}\n\nfloat circle(vec2 o, float r, vec2 p)\n{\n    return distance(p, o) - r;\n}\n\nfloat ellipse(vec2 o, vec2 r, vec2 p)\n{\n    vec2 e = (p - o) / r;\n    vec2 n = o + normalize(e) * r;\n    float d = distance(p, n);\n\n    return mix(-d, +d, step(1.0, dot(e, e)));\n}\n\n// axis must be normalized\nfloat cylinder(vec3 o, vec3 axis, float r, float l, vec3 p)\n{\n    float d = dot(p - o, axis);\n    vec3 para = axis * d, perp = p - o - para;\n\n    return length(max(vec2(0.0), vec2(length(perp) - r, abs(d) - l * 0.5)));\n}\n\n// base of the slime is at (0.0, 0.0)\nfloat slimeProfile(vec2 p)\n{\n    float a = ellipse(vec2(0.0, 0.3), vec2(1.5, 1.) * 0.3, p);\n    float b = square(vec2(0.0, 0.5), vec2(0.2, 0.94), p);\n    float c = ellipse(vec2(0.22, 0.9965), vec2(0.2, 0.43), p);\n    float d = ellipse(vec2(0.0, 0.94), vec2(0.02, 0.02), p);\n    float k = .01;\n    return min(a, min(d, max(b, -c)));\n}\n\n// Signed distance field\nfloat map(vec3 p)\n{   \n    float d = 0.;\n\n    p += (smoothSample(iChannel2, p * 2., 0).rgb - .5) * .0005;\n    p += (smoothSample(iChannel2, p * 20., 0).rgb - .5) * .0001;\n    p += (smoothSample(iChannel2, p * 80., 0).rgb - .5) * .0001;\n\n    d = slimeProfile(vec2(length(p.xz), p.y + .5));\n\n    vec3 p2 = p;\n\n    p2.x = abs(p2.x);\n    d = smax(d, -(length(p2 - vec3(.08, -.15, .4)) - .055), .01);\n    d = smin(d, (length(p2 - vec3(.07, -.16, .4)) - .03), .02);\n    d = smax(d, -(length(p2 - vec3(.065, -.16, .415)) - .012), .01);\n\n    d = smax(d, -(distance(p2, vec3(min(p2.x, .2), -.245, .41)) - .04), .01);\n\n    p += (smoothSample(iChannel2, p / 5. - 10. / 205. * vec3(0, 0, 1), 0).rgb - .5) * .07;\n\n    d = max(d, -(length(mod(p, .08) - .0125) - -.02 + (smoothSample(iChannel2, p * 1.5, 0).r - .5) * .1));\n\n    d += pow(abs(smoothSample(iChannel2, p * 2., 0).g - .4), 8.) * .08;\n\n    return d;\n}\n\nvec3 mapNormal(vec3 p)\n{\n    vec3 e = vec3(1e-3, 0., 0.);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\nvec3 sampleEnvironment(vec3 v, float level)\n{\n    v = normalize(v);\n    float th = .3;\n    v.xz *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    vec3 c = textureLod(iChannel1, v, level).rgb;\n    c *= mix(vec3(0,0,.1),vec3(1), smoothstep(-.2, .2, v.y + .4));\n    c += smoothstep(-.2, .2, v.y - .8) * 2.;\n    return clamp(c, 0., 10.);\n}\n\nvec4 render(vec2 fragCoord)\n{    \n    // Set up primary ray\n\n    vec2 p = fragCoord / iResolution.xy * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    if(abs(p.x) > 1.1)\n        return vec4(0, 0, 0, 1);\n\n    vec3 ro = vec3(0, -.08, 1.05);\n    vec3 rd = normalize(vec3(p, -1.8));\n\n    // Camera rotation\n\n    mat3 m = rotX(-.1);\n\n    ro = m * ro;\n    rd = m * rd;\n\n    vec4 fragColor = vec4(0);\n\n    // When flip is positive, the march is outside of the glass.\n    // When it's negative, the march is inside of the glass.\n    float flip = +1.;\n\n    vec3 transfer = vec3(1);\n\n    vec3 rp = ro + rd * .2, prevhitrp = rp;\n\n    for(int i = 0; i < 400; ++i)\n    {\n        float d = map(rp) * flip;\n\n        // Test for surface hit\n        if(abs(d) < 1e-4)\n        {\n            // Get the surface normal here\n            vec3 n = mapNormal(rp), on = n;\n\n            // Put the normal and ray direction on the same side of the plane\n            n *= -sign(dot(rd, n));\n\n            // Fresnel term\n            float fr = mix(.05, .2, pow(clamp(1. - dot(-rd, n), 0., 1.), 5.));\n\n            // Refract ray direction, or reflect if there is no solution (as per Snell's law).\n            // This accounts for total internal reflection.\n            float ior = 1.3;\n            vec3 refr = normalize(refract(normalize(rd), normalize(n), flip < 0. ? ior : 1. / ior));\n            rd = dot(refr, refr) > 0. ? refr : reflect(rd, n);\n\n            float dist = distance(rp, prevhitrp);\n\n            // If the ray is just leaving a solid volume then aborb some energy\n            if(flip < 0.)\n                transfer *= exp(-abs(dist) * vec3(.7, .5, .2) * 3.2);\n\n            transfer *= vec3(.9, .9, .99);\n\n            // Just directly add a reflection here, to avoid the need for a branch path.\n            // This isn't correct, but a reflection is needed somehow to get any kind of\n            // convincing material appearance.\n            fragColor.rgb += sampleEnvironment(reflect(rd, n), 2.) * transfer * fr;\n\n            prevhitrp = rp;\n\n            flip = -flip;\n            d = 2e-4;\n\n            // Push the ray position through the surface along the normal.\n            // This is more robust than pushing it along the ray's direction.\n            rp += -n * 1e-3;\n\n            transfer *= (1. - fr);\n        }\n\n        rp += rd * d * .3;\n\n        // Test for far plane escape\n        if(distance(rp, ro) > 5.)\n            break;\n    }\n\n    vec3 refc = vec3(0);\n\n    float wsum = 0.;\n\n    // Filtered environment map lookup\n    for(int z = -2; z < 2; ++z)\n        for(int y = -2; y < 2; ++y)\n            for(int x = -2; x < 2; ++x)\n            {\n                float w = 1. - float(max(abs(x), max(abs(y), abs(z)))) / 3.;\n                vec3 v = normalize(rd + vec3(x, y, z) * .02);\n                refc.rgb += sampleEnvironment(v, 2.) * w;\n                wsum += w;\n            }\n\n    fragColor.rgb += refc * transfer / wsum;\n\n    // Vignet\n    fragColor.rgb *= 1. - (pow(abs(p.x) / 1.2, 4.) + pow(abs(p.y) / 1.4, 4.)) * .7;\n\n    fragColor.a = 1.;\n\n    return clamp(fragColor,0.,.5);\n}\n\n// Halton sequence (radical inverse)\nfloat halton(const uint b, uint j)\n{\n    float h = 0.0, f = 1.0 / float(b), fct = f;\n\n    while(j > 0U)\n    {\n        h += float(j % b) * fct;\n        j /= b;\n        fct *= f;\n    }\n\n    return h;\n}\n\n// Sample unit disc\nvec2 disc(vec2 uv)\n{\n    float a = uv.x * pi * 2.;\n    float r = sqrt(uv.y);\n    return vec2(cos(a), sin(a)) * r;\n}\n\n// Sample cone PDF (for tent filtering)\nvec2 cone(vec2 v)\n{\n    return disc(vec2(v.x, 1. - sqrt(1. - v.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    vec4 oldColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n    float subrectCount = 8.;\n    float subrectIndex = mod(float(max(iFrame, 7)), subrectCount);\n    float subrect0 = (subrectIndex + 0.) / subrectCount * iResolution.y - .5;\n    float subrect1 = (subrectIndex + 1.) / subrectCount * iResolution.y + .5;\n    \n    if(fragCoord.y < subrect0 || fragCoord.y > subrect1)\n    {\n        fragColor = oldColor;\n    \treturn;\n    }\n    \n\t// Make a delay of N frames here, to allow time for the textures etc. to load...\n    if(iMouse.z > .5 || iFrame < 7)\n        oldColor = vec4(0);\n\n    vec2 uv = vec2(halton(2U, uint(oldColor.w) & 2047U), halton(3U, uint(oldColor.w) & 2047U));\n\n    vec2 aaOffset = cone(uv) * .9;\n\n    fragColor = oldColor + vec4(clamp(render(fragCoord + aaOffset).rgb, 0., 1.), 1.);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}