{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"const float N = 3.0;//5.3;\n\nvec3 vec3Mod(in vec3 v, in float n)\n{\n    //return v - n * floor(v / n);\n    return vec3(mod(v.x, n), mod(v.y, n), mod(v.z, n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 color = vec3(0.0);\n    vec2 uv = fragCoord / iResolution.xy;\n\n    color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    float grayScale = dot(color, vec3(1.0));\n    //float mask = sign(grayScale); // if vec is (0, 0, 0) return 0 else 1\n    \n    float inverseN = 1.0 / N;\n    float difference = mod(grayScale, inverseN);//vec3Mod(color, inverseN);\n    grayScale -= difference - inverseN;\n    //grayScale *= mask;\n    color *= grayScale;\n    //color *= mask;\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"struct Torus\n{\n    vec3 dir;\n    vec3 pos;\n    float r;\n    float s;\n\n    vec3 color;\n};\n\nstruct Light\n{\n    vec3 pos;\n    vec3 color;\n    float ambientIntensity;\n};\n\nTorus t1 = Torus(normalize(vec3(1.0, 0.5, 0.0)), vec3(0.0), 2.0, 1.0, vec3(0.80, 0.45, 0.38));\nLight l1 = Light(vec3(2.0, -5.0, 3.0), vec3(1.0), 0.05);\n\n\nfloat torusSDF(in vec3 p)\n{\n    vec3 relativePos = p - t1.pos;\n    vec3 relPosProj = t1.r * normalize(relativePos - t1.dir * dot(relativePos, t1.dir));\n    return length(relPosProj - relativePos) - t1.s;\n}\n\nvec3 calculateNormal(in vec3 pos)\n{\n    const vec3 smallStep = vec3(0.001, 0.0, 0.0);\n\n    float gradientX = torusSDF(pos + smallStep.xyy) - torusSDF(pos - smallStep.xyy);\n    float gradientY = torusSDF(pos + smallStep.yxy) - torusSDF(pos - smallStep.yxy);\n    float gradientZ = torusSDF(pos + smallStep.yyx) - torusSDF(pos - smallStep.yyx);\n\n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n\n    return normalize(normal);\n}\n\nvec3 rayMarch(in vec3 rayOrigin, in vec3 rayDir)\n{\n    float totalDistTraveled = 0.0;\n    const int NUMBER_OF_STEPS = 32;\n    const float MINIMUM_HIT_DIST = 0.001;\n    const float MAXIMUM_TRACE_DIST = 1000.0;\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 currentPos = rayOrigin + totalDistTraveled * rayDir;\n        float smallestDist = torusSDF(currentPos);\n        \n        if (smallestDist <= MINIMUM_HIT_DIST)\n        {\n            vec3 normal = calculateNormal(currentPos);\n            vec3 lightDir = normalize(currentPos - l1.pos);\n            \n            float diffuseIntensity = max(l1.ambientIntensity, dot(normal, lightDir));\n            \n            return t1.color * l1.color * diffuseIntensity;\n        }\n            \n        if (totalDistTraveled >= MAXIMUM_TRACE_DIST)\n            break;\n            \n        totalDistTraveled += smallestDist;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 rotY(vec3 v, float a) {\n\ta *= 3.141592 / 180.0;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x * c + v.z * s,\n\t\tv.y,\n\t\tv.z * c - v.x * s\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // convert from (0 to 1) to (-1 to 1)\n    uv = uv * 2.0 - 1.0;\n    // rescale\n    uv.x *= iResolution.x / iResolution.y;\n    \n    t1.dir = rotY(t1.dir,iTime*23.0);\n\n    vec3 rOrigin = vec3(0.0, 0.0, -5.0);\n    vec3 rDir = vec3(uv, 1.0);\n    vec3 col = rayMarch(rOrigin, rDir);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"clG3zD","date":"1683617999","viewed":52,"name":"Cel shade donut","username":"Sumsar86","description":"Cel shading shader applied to a rotating donut rendered using ray marching. Not finished yet.","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["raymarching","celshading","donut","doughnut"],"hasliked":0,"parentid":"","parentname":""}}