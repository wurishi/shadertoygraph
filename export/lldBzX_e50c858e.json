{"ver":"0.1","info":{"id":"lldBzX","date":"1540514448","viewed":140,"name":"Environment- Fantasy Highway","username":"rlarp","description":"Environment. A highway that has been heavily tampered with. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["color","distance","environment","functions","broken","signed","highway"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Shape{\n  float dist;\n  vec4 color;\n};\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.* s)) - s)));\n}\n\n// Shapes --------\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n//=======================\n\nShape environment(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  vec3 g = c; // Ground\n  vec3 ph = c; // Placeholder\n  vec3 w = c; // Blob Walls\n  vec3 s = c; // Lamp Stand\n  vec3 a = c; // Lamp\n  vec3 h = c; // Holes\n  vec3 as = c; // Arch Stand\n  vec3 ar = c; // Arch\n  vec3 sig = c; // Sign\n  vec3 ab = c; // Arrow Base \n  vec3 ah = c; // Arrow Head \n  \n\n  // Ground\n  vec4 gColor = vec4(0.8, 1.0, 0.4, 1.0); \n  pMod1(g.z, 1.); \n  float ground = fBox(g+vec3(0.,1.8,0.4), vec3(4.5, 0.5, 3.)); \n  \n  // PlaceHolder\n  vec4 pColor = vec4(0.,0.,0.,0.); \n  float placeHolder = fBox(ph+vec3(2.,2. ,4.), vec3(3., 0., 3.)); \n   \n     \n  // Blob Walls \n  vec4 wColor = vec4(1., 0.1, 0.2, 1.0); \n  w.x = abs(w.x) - 7.;\n  pMod1(w.y, -1.); \n  pMod1(w.z, 4.); \n  float wall = fSphere(w+vec3(2.5,0.5,-0.5), 0.4); \n  wall = fOpPipe(ground, wall, 2.); \n    \n  // Lamp Stand\n  vec4 sColor = vec4(1., 1., 1., 1.); \n  s.x = abs(s.x) - 2.3; \n  //s.z = abs(s.z) - 4.; \n  pMod1(s.z, 16.); \n  float stand = fBox(s+vec3(0., 0., -1.), vec3(0.2, 1.5, 0.2)); \n    \n  // Lamp\n  vec4 aColor = vec4(1., 1., 0., 1.); \n  pMod1(a.z, 16.); \n  float lamp = fBox(a+vec3(0., -1.3, -1.), vec3(2., 0.2, 0.2)); \n  lamp = fOpPipe(stand, lamp, .3); \n    \n  // Arch Stand\n  vec4 asColor = vec4(0., sin(iTime), 1., 1.); \n  as.x = abs(as.x) - 2.3; \n  pMod1(as.z, 16.); \n  float aStand = fBox(as+vec3(0.,0., -7.5), vec3(0.2, 1.5, 0.2)); \n    \n  // Arch\n  vec4 arColor = vec4(0., sin(iTime), 1., 1.); \n  pMod1(ar.z, 16.); \n  float arch = fBox(ar+vec3(-0.2, -1.3, -7.5), vec3(2.3, 0.2, 0.2)); \n    \n  // Holes\n  vec4 hColor = vec4(1.0, 0., 1., 1.); \n  pMod1(h.z, 4.); \n  float hole = fSphere(h+vec3(0.,1.8, 0.), 0.5); \n    \n  // Sign \n  pMod1(sig.z, 16.); \n  float signn = fBox(sig+vec3(0., -1.3, -7.4), vec3(1.25, 0.75, 0.2)); \n\n  // Arrow \n  vec4 abColor = vec4(1., 0.5, 0.5, 1.); \n  vec4 ahColor = vec4(1., 0.5, 0.5, 1.); \n  pMod1(ab.z, 16.);\n  pMod1(ah.z, 16.); \n  float arrowBase = fBox(ab+vec3(0., -1., -7.3), vec3(0.2, 0.3, 0.2));\n  float arrowHead = sdTriPrism(ah+vec3(0., -1.3, -7.2), vec2(0.4, .1));\n    \n  ground = fOpUnionColumns(ground, wall, 1.3, 4.);    \n  ground = fOpEngrave(ground, hole, 0.5); \n                          \n  shape.dist = max(ground, -placeHolder); \n  shape.dist = min(shape.dist, wall); \n  shape.dist = min(shape.dist, stand); \n  shape.dist = min(shape.dist, lamp); \n  shape.dist = min(shape.dist, hole); \n  shape.dist = min(shape.dist, aStand); \n  shape.dist = min(shape.dist, arch); \n  shape.dist = min(shape.dist, signn);\n  shape.dist = min(shape.dist, arrowBase); \n  shape.dist = min(shape.dist, arrowHead);\n    \n  shape.color = mix(gColor, pColor, mixColors(placeHolder, ground, 0.0));  \n  shape.color = mix(shape.color, wColor, mixColors(wall, shape.dist, 1.0));\n  shape.color = mix(shape.color, sColor, mixColors(stand, shape.dist, 0.0));\n  shape.color = mix(shape.color, aColor, mixColors(lamp, shape.dist, 0.1)); \n  shape.color = mix(shape.color, hColor, mixColors(hole, shape.dist, 0.1)); \n  shape.color = mix(shape.color, arColor, mixColors(arch, shape.dist, 0.1)); \n  shape.color = mix(shape.color, asColor, mixColors(aStand, shape.dist, 0.1)); \n  shape.color = mix(shape.color, abColor, mixColors(arrowBase, shape.dist, 0.1));\n  shape.color = mix(shape.color, ahColor, mixColors(arrowHead, shape.dist, 0.1)); \n    \n  return shape; \n}\n\n\nShape map(vec3 c){\n  Shape enviro = environment(c);\n  return enviro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n \n  vec3 cam = vec3(0., 0., iTime*3.);\n  cam.xy *= rot(radians(90.));\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  //  scene.yx *= rot(iTime);\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}