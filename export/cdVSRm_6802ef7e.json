{"ver":"0.1","info":{"id":"cdVSRm","date":"1681055552","viewed":60,"name":"Optics (phisics project)","username":"___HackerMann___","description":".","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795028841971693993751058209749445923078164062;\nconst float EPS = 1e-4;\nconst float FOV = 1.0;\nconst float MAX_DIST = 1000.0;\nconst vec3 BG_COLOR = vec3(0.15, 0.05, 0.0);\nconst float REFRACTION_INDEX = 1.39;\nconst float FRESNEL_POWER = 2.9;\nconst float FRESNEL_MULTIPLIER = 1.5;\nconst uint N_REFRACTIONS = uint(6);\nconst uint N_SAMPLES = uint(6);\nconst float AA_DIST = 0.001;\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle `angle`.\n// Read like this: `R(p.xz, a)` rotates \"`x` towards `z`\".\n// This is fast if `a` is a compile-time constant and slower (but still practical) if not.\nvoid rotate(inout vec2 pos, float angle) {\n\tpos = cos(angle) * pos + sin(angle) * vec2(pos.y, -pos.x);\n}\n\nmat3 get_cam_transform(vec3 ray_origin, vec3 look_at) {\n    vec3 cam_front = normalize(vec3(look_at - ray_origin));\n    vec3 cam_right = normalize(cross(vec3(0, 1, 0), cam_front));\n    vec3 cam_up = cross(cam_front, cam_right);\n\n    return mat3(cam_right, cam_up, cam_front);\n}\n\nfloat capped_cylinder_sdf(vec3 p, vec3 a, vec3 b, float r) {\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sphere_sdf(vec3 pos, vec3 centre, float radius) {\n    return length(pos - centre) - radius;\n}\n\nfloat torus_sdf(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat box_sdf(vec3 pos, vec3 b) {\n    vec3 q = abs(pos) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene_sdf(vec3 pos) {\n    // TODO:\n    //return sphere_sdf(pos, vec3(0), 3.8);\n    //return torus_sdf(pos, vec2(3.5, 1.1));\n    //return box_sdf(pos, vec3(2));\n    //return max(capped_cylinder_sdf(pos, vec3(2, 0, 0), vec3(0, 0, 0), 3.0), -sphere_sdf(pos, vec3(8.1, 0, 0), 8.0));\n    //return min(sphere_sdf(pos, vec3(0), 3.8), torus_sdf(pos, vec2(3.5, 1.1)));\n    return max(sphere_sdf(pos, vec3(-8.8, 0, 0), 9.8), sphere_sdf(pos, vec3(8.8, 0, 0), 9.8));\n}\n\nvec2 get_uv(vec2 offset, vec2 frag_coord) {\n    // Normalized pixel coordinates (from -1 to 1) + offset\n    return (2.0 * (frag_coord + offset) - iResolution.xy) / iResolution.y;\n}\n\nvoid mouse_control(inout vec3 ray_origin) {\n    vec2 mouse_pos = iMouse.xy / iResolution.xy;\n    mouse_pos.y = mouse_pos.y * 2.0 - 2.0;\n    rotate(ray_origin.yz, mouse_pos.y * PI);\n    rotate(ray_origin.xz, mouse_pos.x * PI);\n}\n\nfloat ray_march(vec3 ray_origin, vec3 ray_direction, float max_dist, uint max_steps, float dist_multiple) {\n    float dist = 0.0;\n    for (uint i = uint(0); i < max_steps; ++i) {\n        float signed_dist = dist_multiple * scene_sdf(ray_origin + dist * ray_direction);\n        if (signed_dist <= EPS) {\n            dist += signed_dist;\n            return dist;\n        }\n\n        dist += signed_dist;\n        if (max_dist < dist)\n            return max_dist;\n    }\n\n    return dist;\n}\n\nvec3 calculate_normal(vec3 pos) {\n    vec2 eps = vec2(EPS, 0);\n    return normalize(vec3(\n        scene_sdf(pos + eps.xyy) - scene_sdf(pos - eps.xyy),\n        scene_sdf(pos + eps.yxy) - scene_sdf(pos - eps.yxy),\n        scene_sdf(pos + eps.yyx) - scene_sdf(pos - eps.yyx)\n    ));\n}\n\nvec4 main_image_part(in vec2 frag_coord, in vec2 uv_offset) {\n    vec2 uv = get_uv(vec2(0.0), frag_coord) + uv_offset;\n    vec3 look_at = vec3(0);\n\n    vec3 ray_origin = vec3(5.0, 5.0, 5.0);\n    mouse_control(ray_origin);\n\n    vec3 ray_direction = get_cam_transform(ray_origin, look_at)\n                       * normalize(vec3(uv, 1.0));\n\n    vec3 bg_color = texture(iChannel0, ray_direction).xyz;\n    float dist = ray_march(ray_origin, ray_direction, MAX_DIST, uint(100), 1.0);\n\n    if (MAX_DIST <= dist)\n        return vec4(bg_color, 1.0);\n\n    vec3 hit_pos = ray_origin + dist * ray_direction;\n    vec3 normal = calculate_normal(hit_pos);\n    \n    float fresnel = pow(clamp(1.0 - dot(-ray_direction, normal), 0.0, 1.0), FRESNEL_POWER)\n                  * FRESNEL_MULTIPLIER;\n    vec3 reflect_dir = reflect(-ray_direction, normal);\n\n    vec3 refract_dir = refract(ray_direction, normal, 1.0 / REFRACTION_INDEX);\n    float last_refraction_index = REFRACTION_INDEX;\n    uint n_branches = uint(0);\n    uint n_refractions = uint(0);\n    float multiple_sum = 0.0;\n    vec3 light_sum = vec3(0);\n    \n    for (uint i = uint(0); i < N_REFRACTIONS; ++i) {\n        float in_dist = ray_march(hit_pos - 40.0 * EPS * normal, refract_dir, MAX_DIST, uint(100), -1.0);\n        vec3 in_hit_pos = hit_pos + in_dist * refract_dir;\n        vec3 in_normal = calculate_normal(in_hit_pos);\n\n        vec3 double_refr_dir = refract(refract_dir, -in_normal, last_refraction_index);\n        float multiple;\n        if (dot(double_refr_dir, double_refr_dir) == 0.0) {\n            double_refr_dir = reflect(refract_dir, in_normal);\n            \n            multiple = pow(0.5, float(n_branches));\n            multiple_sum += multiple;\n        } else {\n            last_refraction_index = 1.0 / last_refraction_index;\n            \n            multiple = pow(0.1, float(n_refractions));\n            multiple_sum += multiple;\n            n_refractions++;\n        }\n\n        vec3 refracted_light = texture(iChannel0, refract_dir).rgb;\n        light_sum += refracted_light * multiple;\n        n_branches++;\n        \n        refract_dir = double_refr_dir;\n        hit_pos = in_hit_pos;\n        normal = in_normal;\n    }\n\n    vec3 refracted_light = light_sum / multiple_sum;\n    vec3 reflected_light = texture(iChannel0, reflect_dir).rgb;\n\n    vec3 color = mix(refracted_light, reflected_light, fresnel);\n\n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = main_image_part(fragCoord, vec2(0));\n    for (uint i = uint(0); i < N_SAMPLES - uint(1); ++i) {\n        float frac = float(i) / float(N_SAMPLES) * 2.0 * PI;\n        vec2 offset = AA_DIST * vec2(cos(frac), sin(frac));\n        fragColor += main_image_part(fragCoord, offset);\n    }\n\n    fragColor /= float(N_SAMPLES);\n}","name":"Image","description":"","type":"image"}]}