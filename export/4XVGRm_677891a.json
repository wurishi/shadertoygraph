{"ver":"0.1","info":{"id":"4XVGRm","date":"1717439531","viewed":117,"name":"Minkowski Sum SDF","username":"Iceman2022","description":"This shows how to use the Minkowski Sum (Zonogon) and SDFs to find the collision between two rectangles. It can also be used for extrusion. For more info check out the notes.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["collision","sdf","detection","physics","minkowski","sum","zonogon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License\n\n// ********* Notes *********\n// The shape to the left is called a Zonogon SDF which is generated by using the \n// Minkowski Sum (a bunch of planes). The shapes on the right are the actual graphics \n// you would see in game. The red dot on the left can be used with the SDF Zonogon to find \n// the penetration (distance field) and normal (getNormal()) for a physics engine. \n// I have not implemented the penetration and normal here but I know it works. \n// Also, I have not been able to convert the red dot from the physics (left) to a contact point \n// for the graphics (right). Finding a contact point is useful because you can combine it \n// with an inertial tensor to find the angular velocity. \n// If any one knows how to find the contact point in a SDF collision please let me know.\n// ********* Notes *********\n\n// Zonogon\n#define EXTRUDE 0\n// Turns the Zonogon into an extruded rectangle\n//#define EXTRUDE 1\n\n// Rotates a point theta radians around the z-axis\nvec2 opRotate(vec2 p, float theta)\n{\n\tfloat cost = cos(theta); \n\tfloat sint = sin(theta);\n\t\n\treturn vec2(p.x * cost - p.y * sint, p.x * sint + p.y * cost);\n}\n\nfloat opUnion(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opIntersect(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\n// ***************** Toolbox *****************\n\nfloat sdCircle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdRectangle(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// This is just really a 2D cross product (I think)\nfloat sdPlane(vec2 p, vec2 point1, vec2 point2)\n{\n    return (point2.x - point1.x) * (p.y - point1.y) - (point2.y - point1.y) * (p.x - point1.x);\n}\n\n// IQs\nfloat sdLineSegment(vec2 p, vec2 point1, vec2 point2)\n{\n    vec2 pa = p - point1, ba = point2 - point1;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// ***************** Toolbox *****************\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Perspective setup\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    // ** box 1 is the center box with box 2 placed around box 1 **\n    // Positive rotation is counterclockwise (like OpenGL)\n    float angle1 = radians(0.0);\n    float angle2 = radians(iTime * 20.0);\n\n    // width and height of the rectangles\n    vec2 extents1 = vec2(0.05,0.1);\n    \n    #if EXTRUDE == 0\n        vec2 extents2 = vec2(0.05,0.05);\n    #else\n        vec2 extents2 = vec2(0.0,0.05);\n    #endif\n\n    vec2 position1 = vec2(0.2, 0.0);\n    vec2 position2 = vec2(0.2, (sin(iTime - (3.14 * 0.5)) * 0.25 + 0.2) - 0.2);\n    // This is the offset for the Minkowski Sum shape aka Zonogon\n    vec2 positionZonogon = vec2(-0.2,0.0);\n\n    vec2 edges[4];\n    // Size of the edges before scaling\n    edges[0] = vec2(-1,-1);\n    edges[1] = vec2( 1,-1);\n    edges[2] = vec2( 1, 1);\n    edges[3] = vec2(-1, 1);\n\n    float pointDistance = 10000.0;\n    vec2 pointArray[16];\n\tvec3 col = vec3(0);\n\n    for (int i = 0; i < 4; i++)\n    {\n        vec2 point1 = edges[i] * extents1;\n\n        for (int j = 0; j < 4; j++)\n        {\n            vec2 point2 = opRotate(edges[j] * extents2, angle2) + point1;\n\n            pointArray[(i * 4) + j] = point2;\n        }\n    }\n\n    // ***************** Create the points for the lines here *****************\n    vec2 pointLineArray[8];\n\n    for (int i = 0; i < 8; i++)\n    {\n        pointLineArray[i] = vec2(0,0);\n    }\n\n    for (int i = 0; i < 16; i++)\n    {\n        vec2 point = pointArray[i];\n\n        // Top Right\n        // Top Left\n        if (point.y > pointLineArray[0].y)\n        {\n            pointLineArray[0].y = point.y;\n            pointLineArray[1].y = point.y;\n        }\n        // Left Top\n        // Left Bottom\n        if (point.x < pointLineArray[2].x)\n        {\n            pointLineArray[2].x = point.x;\n            pointLineArray[3].x = point.x;\n        }\n        // Bottom Left\n        // Bottom Right\n        if (point.y < pointLineArray[4].y)\n        {\n            pointLineArray[4].y = point.y;\n            pointLineArray[5].y = point.y;\n        }\n        // Right Bottom\n        // Right Top\n        if (point.x > pointLineArray[6].x)\n        {\n            pointLineArray[6].x = point.x;\n            pointLineArray[7].x = point.x;\n        }\n    }\n    \n    // Find the value to the other element of the point\n    for (int i = 0; i < 16; i++)\n    {\n        vec2 point = pointArray[i];\n\n        // Top Right\n        if (point.y == pointLineArray[0].y && point.x > pointLineArray[0].x)\n        {\n            pointLineArray[0] = point;\n        }\n        // Top Left\n        if (point.y == pointLineArray[1].y && point.x < pointLineArray[1].x)\n        {\n            pointLineArray[1] = point;\n        }\n        // Left Top\n        if (point.x == pointLineArray[2].x && point.y > pointLineArray[2].y)\n        {\n            pointLineArray[2] = point;\n        }\n        // Left Bottom\n        if (point.x == pointLineArray[3].x && point.y < pointLineArray[3].y)\n        {\n            pointLineArray[3] = point;\n        }\n        // Bottom Left\n        if (point.y == pointLineArray[4].y && point.x < pointLineArray[4].x)\n        {\n            pointLineArray[4] = point;\n        }\n        // Bottom Right\n        if (point.y == pointLineArray[5].y && point.x > pointLineArray[5].x)\n        {\n            pointLineArray[5] = point;\n        }\n        // Right Bottom\n        if (point.x == pointLineArray[6].x && point.y < pointLineArray[6].y)\n        {\n            pointLineArray[6] = point;\n        }\n        // Right Top\n        if (point.x == pointLineArray[7].x && point.y > pointLineArray[7].y)\n        {\n            pointLineArray[7] = point;\n        }\n    }\n\n    // Rotate the points around the inner rectangle\n    for (int i = 0; i < 8; i++)\n    {\n        pointLineArray[i] = opRotate(pointLineArray[i] + positionZonogon, angle1);\n    }\n    // ***************** Finish the points for the lines here *****************\n\n    // ********** Create the planes and lines aka the Zonogon **********\n    // Start checking the distances for the planes\n    float planeDistance = 10000.0;\n    planeDistance = opUnion(planeDistance, sdPlane(uv, pointLineArray[0], pointLineArray[7]));\n    \n    // Start checking the distances for the lines\n    float lineDistance = 10000.0;\n    lineDistance = opUnion(lineDistance, sdLineSegment(uv, pointLineArray[0], pointLineArray[7]));\n\n    for (int i = 0; i < 7; i++)\n    {\n        lineDistance = opUnion(lineDistance, sdLineSegment(uv, pointLineArray[i + 1], pointLineArray[i]));\n        planeDistance = opIntersect(planeDistance, sdPlane(uv, pointLineArray[i + 1], pointLineArray[i]));\n    }\n\n    // Zonogon Line color\n    col.rgb += smoothstep(0.002, 0.0, lineDistance) * vec3(1,1,0);\n\n    // Inrazy color for a hit and \n    // -1 is inside (Red), 0 on the line, and 1 outside (Dark Green)\n    vec3 zonogonColor = vec3(0.5,0,0);\n\n    // -1 is inside (Crazy Colors), 0 on the line, and 1 outside (Green)\n    vec3 rectangleColor = mix(vec3(1,0,1), vec3(0,1,0), sin(iTime * 10.0) * 0.5 + 0.5);\n    rectangleColor = mix(vec3(1,1,0), rectangleColor, sin(iTime * 15.0) * 0.5 + 0.5);\n\n    // -1 is inside, 0 on the line, and 1 outside\n    if (sdPlane(positionZonogon + (position2 - position1), pointLineArray[0], pointLineArray[7]) > 0.0)\n    {\n        zonogonColor = vec3(0,0.5,0.5); // Dark Green\n        rectangleColor = vec3(0,1,0); // Green\n    }\n\n    for (int i = 0; i < 7; i++)\n    {\n        if (sdPlane(positionZonogon + (position2 - position1), pointLineArray[i + 1], pointLineArray[i]) > 0.0)\n        {\n            zonogonColor = vec3(0,0.5,0.5); // Dark Green\n            rectangleColor = vec3(0,1,0); // Green\n        }\n    }\n\n    col.rgb += smoothstep(0.0005, 0.0, planeDistance) * zonogonColor;\n\n    // ********** Finish the planes and lines aka the Zonogon **********\n\n    // ***************** Add the contact circle and rectangles here *****************\n    float r1 = sdRectangle(opRotate(uv - position1,-angle1), extents1);\n    col.rgb += smoothstep(0.002, 0.0, r1) * vec3(0,0,1);\n   \n    float r2 = sdRectangle(opRotate(uv - position2,-angle2), extents2);\n    col.rgb += smoothstep(0.002, 0.0, r2) * rectangleColor;\n\n    float contact = sdCircle(uv - (positionZonogon + (position2 - position1)), 0.009);\n    col.rgb += smoothstep(0.002, 0.0, contact) * vec3(1,0,0);\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}