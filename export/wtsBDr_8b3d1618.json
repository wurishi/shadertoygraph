{"ver":"0.1","info":{"id":"wtsBDr","date":"1596775379","viewed":219,"name":"Hue Expansion","username":"JackKalish","description":"Exercise from Book of Shaders by Patricio Gonzalez Vivo\nChapter 6 - Colors: https://thebookofshaders.com/06/\n\n\"Use a shaping function together with the conversion function from HSB to RGB to expand a particular hue value and shrink the rest.\"","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["color","rgb","wheel","hue","hsb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define SPEED -.1\n\nvec3 rgb2hsb( in vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c, in float hueOffset){\n    vec3 rgb = clamp(abs(mod((c.x+hueOffset)*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//  Function from Iñigo Quiles\n//  iquilezles.org/articles/functions\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st.x -= .4;\n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.y,toCenter.x)-iTime*SPEED*TWO_PI;\n     //   float angle = atan(toCenter.y*(sin(iTime+PI)+2.),toCenter.x*(sin(iTime)+2.));\n   // angle = smoothstep(-PI,PI,angle);\n    \n    float radius = length(toCenter)*2.0;\n    \n    //angle = cubicPulse(1.,0.984,angle);\n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    float hue = fract((angle/TWO_PI)+0.5);\n        \n    //apply shaping function to hue\n    hue = mix(smoothstep(0.,1.,hue),hue, .2);\n    \n    color = hsb2rgb(vec3(hue,radius,1.0), iTime*SPEED);\n\n    fragColor = vec4(color,1.0);\n}\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}*/","name":"Image","description":"","type":"image"}]}