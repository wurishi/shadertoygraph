{"ver":"0.1","info":{"id":"l3Xyz4","date":"1725898411","viewed":845,"name":"LEGO Voxel Cone Tracing","username":"Mathis","description":"Reset timer if the SDF volume does not render correctly!","likes":48,"published":1,"flags":48,"usePreview":1,"tags":["gi","global","illumination","voxel","cone","tracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nVoxel Cone Tracing with LEGO\n\nVCT\n    Uses 2 volumes, one for LEGO and one for the floor\n        LOD 0 (LEGO) is isotropic and the mipmaps are anisotropic\n            Temporally computed so lighting/geometry is static here\n        Floor uses hardware mipmaps, works since light is assumed to only travel \"upwards\"\n    Diffuse cones do not interpolate between mipmaps to save performance -> fixed cone ratio\n        Glossy cone uses normal voxel cone tracing\n    Light injection\n        Shadow map computed in Buffer D to avoid RT in cubemap\n\nSDF\n    Represented inside a volume, one textureFetch is needed for trilinear interpolation\n\nTAA\n    Glues it together\n\nPerformance\n    Many interpolations must be done manually, forcing more texture-fetches\n    Some code can also be \"simplified\" (leads to more code and better performance) which I have not done\n\n\n\nControls:\n    Mouse to rotate the camera\n*/\n\nvec3 acesFilm(vec3 x) {\n    //Aces film curve\n    return clamp((x*(2.51*x + 0.03))/(x*(2.43*x + 0.59) + 0.14), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 Color = texture(iChannel0, fragCoord*IRES).xyz;\n    fragColor = vec4(pow(acesFilm(max(vec3(0.), Color)), vec3(0.45)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Constants\nconst float FOV = radians((47.5)/2.);\nconst float LightCoeff = 8.;\nconst float ILightCoeff = 1./LightCoeff;\nconst vec3 SUN_TARGET = vec3(4., 1.5, 2.);\nconst vec3 SUN_DIR = normalize(vec3(1.4, 0.6, 0.8));\nconst vec3 SUN_TAN = normalize(cross(SUN_DIR, vec3(0., 1., 0.)));\nconst vec3 SUN_BIT = cross(SUN_TAN, SUN_DIR);\nconst float SUN_SM_SIZE = 4.;\nconst float PI = 3.141592653;\nconst float HPI = 3.141592653*0.5;\nconst float IPI = 1./PI;\nconst float I3 = 1./3.;\nconst float I15 = 1./15.;\nconst float I16 = 1./16.;\nconst float I32 = 1./32.;\nconst float I35 = 1./35.;\nconst float I64 = 1./64.;\nconst float I128 = 1./128.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\nconst vec2 eps = vec2(1./31., 0.);\nconst vec2 epsv = vec2(0.2, 0.);\nconst float CFOV = tan(FOV);\nconst vec3 LEGOOSlope = normalize(vec3(3.5/6.,1.,0.));\nconst vec3 LEGOISlope = normalize(vec3(1.,-1.,0.));\nconst vec2 SSOffsets8[8] = vec2[8](vec2(0.,0.2),vec2(0.,-0.2),vec2(0.2,0.),vec2(-0.2,0.),\n                                  vec2(0.4),vec2(-0.4),vec2(-0.4,0.4),vec2(0.4,-0.4));\n//Defines\n#define RES iChannelResolution[0].xy\n#define IRES 1./iChannelResolution[0].xy\n#define ASPECT vec2(iChannelResolution[0].x/iChannelResolution[0].y,1.)\n\nstruct HIT { float D; vec3 C; vec3 N; int M; };\nstruct DF { float D; vec3 C; int M; };\nstruct BRICKTYPE { float UVOffset; vec2 UVDim; vec3 BrickDim; };\nstruct BRICK { vec3 P; vec4 Q; vec3 C; int I; int M; };\n\nvec3 SampleSky(vec3 d) {\n    vec3 L = vec3(0.2)*(d.y*0.5+0.5);\n    vec3 InitialDir = vec3(sin(-0.78),0.3,cos(-0.78));\n    if (dot(d,InitialDir)>0.75) L += vec3(2.5);\n    else if (dot(d,vec3(-InitialDir.x,InitialDir.yz))>0.85) L += vec3(2.7,0.4,0.075);\n    //Return\n    return L;\n}\n\n//SDF\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBox(vec2 p, vec2 b) {\n    vec2 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC2(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFExtrude(vec3 p, float sdf, float h) {\n    //By IQ: https://www.shadertoy.com/view/4lyfzw\n    vec2 w = vec2(sdf,abs(p.z)-h);\n  \treturn min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFDisk(vec3 p) {\n    float d = length(p.xz-0.5)-0.35;\n    vec2 w = vec2(d,abs(p.y));\n    return min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang = 2.*3.14159/n;\n    float sector = floor(atan(p.x,p.y)/ang+0.5);\n    p = Rotate(p,sector*ang);\n    return p;\n}\n\nfloat smin(float a, float b, float k) {\n    //https://iquilezles.org/articles/smin\n    float h = max(k-abs(a-b),0.)/k;\n    return min(a,b)-h*h*h*k*(1.0/6.0);\n}\n\nvec3 ARand23(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*vec3(403.125,486.125,513.432)+cos(dot(uv,vec2(13.18273,51.2134)))*vec3(173.137,261.23,203.127));\n}\n\nfloat ARand21(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2(13.18273,51.2134)))*173.137);\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb = vec3(1.,0.,0.);\n        Nt = vec3(0.,0.,1.);\n    } else {\n    \tNb = normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt = normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O = ((abs(N.y)>0.999)?vec3(1.,0.,0.):normalize(cross(N,vec3(0.,1.,0.))));\n    return normalize(cross(O,N));\n}\n\nvec2 ABox(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t1 = min(tMin,tMax);\n    vec2 t2 = max(tMin,tMax);\n    return vec2(max(t1.x,t1.y),min(t2.x,t2.y));\n}\n\nvec2 ABox(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nfloat ABoxfar(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t2 = max(tMin,tMax);\n    return min(t2.z,min(t2.x,t2.y));\n}\n\nfloat ABoxfar(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t2 = max(tMin,tMax);\n    return min(t2.x,t2.y);\n}\n\nvec2 ABoxfarNormal(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax, out float dist) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t2 = max(tMin,tMax);\n    dist = min(t2.x,t2.y);\n    vec2 signdir = (max(vec2(0.),sign(dir))*2.-1.);\n    if (t2.x<t2.y) return vec2(signdir.x,0.);\n    else return vec2(0.,signdir.y);\n}\n\nvec3 ABoxfarNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = (max(vec3(0.),sign(dir))*2.-1.);\n    if (t2.x<min(t2.y,t2.z)) return vec3(signdir.x,0.,0.);\n    else if (t2.y<t2.z) return vec3(0.,signdir.y,0.);\n    else return vec3(0.,0.,signdir.z);\n}\n\nvec2 ABoxNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax, out vec3 N) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(dir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) N = vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) N = vec3(0.,signdir.y,0.);\n    else N = vec3(0.,0.,signdir.z);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nvec3 ABoxNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(dir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) return vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) return vec3(0.,signdir.y,0.);\n    else return vec3(0.,0.,signdir.z);\n}\n\nvec3 RandSample(vec2 v) {\n    float r=sqrt(1.-v.x*v.x);\n    float phi=2.*3.14159*v.y;\n    return vec3(cos(phi)*r,sin(phi)*r,v.x);\n}\n\nvec3 RandSampleCos(vec2 v) {\n    float theta = sqrt(v.x);\n    float phi = 2.*3.14159*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nvec3 RandSampleCosXYer(vec2 v) {\n    float theta = sqrt(v.x);\n    float phi = 2.*3.14159*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x,z,0.);\n}\n\n//Float-Vec conversion\nvec3 FloatToVec3(float v) {\n    int VPInt = floatBitsToInt(v);\n    int VPInt1024 = VPInt%1024;\n    int VPInt10241024 = ((VPInt-VPInt1024)/1024)%1024;\n    return vec3(VPInt1024,VPInt10241024,((VPInt-VPInt1024-VPInt10241024)/1048576))*I1024;\n}\n\nfloat Vec3ToFloat(vec3 v) {\n    ivec3 intv = min(ivec3(floor(v*1024.)),ivec3(1023));\n    return intBitsToFloat(intv.x+intv.y*1024+intv.z*1048576);\n}\n\nvec2 FloatToVec2(float v) {\n    int VPInt = floatBitsToInt(v);\n    int VPInt1 = VPInt%32768;\n    return vec2(VPInt1,((VPInt-VPInt1)/32768))/32768.;\n}\n\nfloat Vec2ToFloat(vec2 v) {\n    ivec2 intv = min(ivec2(floor(v*32768.)),ivec2(32767));\n    return intBitsToFloat(intv.x+intv.y*32768);\n}\n//GGX\nvec3 SchlickFresnel(vec3 r0, float angle) {\n    //Schlick Fresnel approximation\n    return r0+(1.-r0)*pow(1.-angle,5.);\n}\n\nfloat SmithGGXMasking(vec3 wi, vec3 wo, float a2) {\n    //Smith masking function\n    float dotNL = wi.z;\n    float dotNV = wo.z;\n    float denomC = sqrt(a2+(1.-a2)*dotNV*dotNV)+dotNV;\n    return 2.*dotNV/denomC;\n}\n\nfloat SmithGGXMaskingShadowing(vec3 wi, vec3 wo, float alpha) {\n    //Smith masking shadowing function\n    float dotNL = wi.z;\n    float dotNV = wo.z;\n    float denomA = dotNV*sqrt(alpha+(1.-alpha)*dotNL*dotNL);\n    float denomB = dotNL*sqrt(alpha+(1.-alpha)*dotNV*dotNV);\n    return 2.*dotNL*dotNV/(denomA+denomB);\n}\n\nvec3 GgxVndf(vec3 wo, float roughness, float u1, float u2) {\n    //Returns the mini normal\n    vec3 v = normalize(vec3(wo.x*roughness,wo.y*roughness,wo.z));\n    vec3 t1 = (v.z<0.999)?normalize(cross(v,vec3(0.,0.,1.))):vec3(1.,0.,0.);\n    vec3 t2 = cross(t1, v);\n    float a = 1./(1.+v.z);\n    float r = sqrt(u1);\n    float phi = (u2<a)?(u2/a)*PI:PI+(u2-a)/(1.-a)*PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((u2<a)?1.:v.z);\n    vec3 n = p1*t1+p2*t2+sqrt(max(0.,1.-p1*p1-p2*p2))*v;\n    return normalize(vec3(roughness*n.x,roughness*n.y,max(0.,n.z)));\n}\n\nvoid ImportanceSampleGGX(vec2 uRand, vec3 wo, float Roughness, vec3 SpecularColor, out vec3 wi, out vec3 reflectance) {\n    //Importance sampling\n    float a2 = Roughness*Roughness;\n    vec3 wm = GgxVndf(wo,Roughness,uRand.x,uRand.y);\n    wi = reflect(-wo,wm);\n    if (wi.z>0.) {\n        vec3 F = SchlickFresnel(SpecularColor,dot(wi, wm));\n        float G1 = SmithGGXMasking(wi,wo,a2);\n        float G2 = SmithGGXMaskingShadowing(wi,wo,a2);\n        reflectance = F*(G2/G1);\n    } else {\n        reflectance = vec3(0.);\n    }\n}\n\n\n//SDF\nfloat DFStud(vec3 p) {\n    float d = -smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))+0.3,-p.y+0.2,0.075);\n    d = max(-p.y,smin(d,DFDisk(p),0.05));\n    return d;\n}\n\nfloat DFBrick(vec3 p, vec3 BSize) {\n    float d = DFBox(p-vec3(0.04),BSize-vec3(0.08,0.48,0.08))-0.04;\n    d = -smin(-d,DFBox(p-vec3(0.25,-0.95,0.25),BSize-vec3(0.5,-0.3,0.5))-0.05,0.05);\n    if (min(BSize.x,BSize.z)>1.5) {\n        float LineDF = DFLine(vec3(fract(clamp(p.x,0.5,BSize.x-0.5)-0.5),p.yz),vec3(0.5,-1.,1.),vec3(0.5,1.,1.));\n        d = smin(d,-smin(-max(max(LineDF-0.407,-LineDF+0.3),p.y-(BSize.y-0.45)),p.y,0.05),0.05);\n    } else {\n        float tmpLine = DFLine(vec3(fract(clamp(p.x,0.5,BSize.x-0.5)-0.5),p.yz),vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5));\n        d = min(d,max(max(max(tmpLine-0.2,-tmpLine+0.1),p.y-(BSize.y-0.45)),-p.y));\n    }\n    vec3 StudPos = vec3(clamp(floor(p.x),0.,BSize.x-1.),BSize.y-0.4,clamp(floor(p.z),0.,BSize.z-1.));\n    d = -smin(-d,-smin(-DFLine(p-StudPos,vec3(0.5,-1.,0.5),vec3(0.5,-0.05,0.5))+0.15,-p.y+BSize.y-0.45,0.05),0.05); //Hole under stud\n    d = min(d,DFStud(p-StudPos)); //Studs\n    return d;\n}\n\nfloat DFRound131(vec3 p) {\n    float LineDF = DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5));\n    float d = max(max(LineDF-0.397,p.y-0.35),-p.y);\n    d = min(d,max(-smin(-LineDF+0.48,-p.y+1.2,0.05),-p.y+0.2));\n    //Stud\n    d = smin(d,max(-smin(-LineDF+0.3,-p.y+1.4,0.07),-p.y+1.2),0.07);\n    d = -smin(-d,LineDF-0.2,0.07);\n    return d;\n}\n\nfloat DFISlope(vec3 p, float Z) {\n    float d = -smin(-DFBox(p-vec3(0.02),vec3(1.96,1.16,Z-0.04))+0.017,-dot(LEGOISlope,p-vec3(1.,0.,0.)),0.03);\n    d = -smin(-d,max(DFBox(p-vec3(1.15,0.2,0.15),vec3(0.75,2.,Z-0.3)),dot(LEGOISlope,p-vec3(1.,0.2,0.))),0.05);\n    //Stud\n    float StudZ = clamp(floor(p.z),0.,Z-1.)+0.5;\n    d = smin(d,-smin(-max(-smin(-DFLine(p,vec3(1.5,-1.,StudZ),vec3(1.5,2.,StudZ))+0.3,-p.y+1.4,0.07),-p.y+0.85),\n    DFLine(p,vec3(1.5,-1.,StudZ),vec3(1.5,2.,StudZ))-0.2,0.07),0.07);\n    d = min(d,DFStud(p-vec3(0.,1.2,StudZ-0.5))); //Studs\n    return d;\n}\n\nfloat DFOnlySlope(vec3 p) {\n    float d = -smin(-DFBox(p-vec3(0.1,0.1,0.1),vec3(0.8,0.8,0.8))+0.1,-dot(LEGOOSlope,p-vec3(0.,0.8,0.)),0.06);\n    return d;\n}\n\nfloat DFHose(vec3 p) {\n    vec3 rp = p-vec3(0.5,0.,0.5);\n    float lrp = length(rp);\n    float d = -smin(rp.y,-max(lrp-0.45,-lrp+0.35),0.02);\n    d = smin(d,DFLine(p,vec3(0.5,0.45,0.5),vec3(0.5,1.15,0.5))-0.2,0.07);\n    //Stud\n    d = smin(d,-smin(smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+0.3,-p.y+1.4,0.07),p.y-1.2,0.07),0.07);\n    //Arm\n    d = smin(d,DFLine(p,vec3(0.7,0.95,0.5),vec3(1.2,0.95,0.5))-0.2+(p.x-0.7)*0.1,0.1);\n    d = smin(d,max(max(DFLine(p,vec3(0.,0.95,0.5),vec3(3.,0.95,0.5))-0.2,-p.x+1.2),p.x-1.4),0.04);\n    return d;\n}\n\nfloat DFPanel(vec3 p) {\n    float d = DFBox(p-vec3(0.04),vec3(1.92,0.32,0.92))-0.04;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(1.6,1.2,0.6)));\n    d = min(d,DFBox(p-vec3(0.05,0.05,0.05),vec3(1.9,1.1,0.))-0.05);\n    return d;\n}\n\nfloat DFHandle(vec3 p, float type) {\n    //Symmetric through the x-axis\n    vec3 syp = vec3(p.xy,abs(p.z-1.));\n    float d = DFBrick(p.zyx,vec3(2.,0.8,1.));\n    //Handle\n    float Z = type*0.4;\n    float tmpCyl = length(p.xy-vec2(1.5,0.3));\n    d = min(d,DFBox(syp-vec3(0.04,0.04,0.74-Z),vec3(1.46,0.32,0.22))-0.04);\n    d = min(d,-smin(smin(-tmpCyl+0.3,1.-Z-syp.z,0.04),syp.z-0.7+Z,0.04));\n    d = min(d,max(max(tmpCyl-0.2,0.05-p.z),p.z-1.95));\n    return d;\n}\n\nfloat DFGrip(vec3 p) {\n    float d = DFBox(p-vec3(0.04,0.44,0.04),vec3(0.92,0.32,0.92))-0.04;\n    //Grip\n    d = min(d,DFBox(p-vec3(0.04,0.44,0.39),vec3(1.36,0.32,0.22))-0.04);\n    d = min(d,-smin(smin(-length(p.xy-vec2(1.45,0.68))+0.37,-p.z+0.65,0.04),-0.35+p.z,0.04));\n    d = max(d,-length(p.xy-vec2(1.5,0.7))+0.2);\n    d = -smin(-d,1.62-p.x,0.08);\n    //Stud\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(0.6,1.6,0.6)));\n    vec3 StudPos = vec3(0.,0.8,0.);\n    d = max(d,-max(DFLine(p-StudPos,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))-0.15,p.y-0.75)); //Hole under stud\n    d = min(d,DFStud(p-StudPos)); //Studs\n    return d;\n}\n\nfloat DFGrate(vec3 p) {\n    float d = DFBox(p-vec3(0.02),vec3(1.96,0.36,0.96))-0.02;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(1.6,1.25,0.6)));\n    d = max(d,-DFBox(vec3(p.x+2.,p.y-0.2,fract(p.z*2.5)*0.4-0.2),vec3(8.,1.,0.2)));\n    return d;\n}\n\nfloat DFRound111(vec3 p) {\n    float LineDF = DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5));\n    float d = -smin(smin(-LineDF+0.499,-p.y+0.4,0.04),p.y-0.3,0.05);\n    d = smin(d,-smin(smin(-max(LineDF-0.397,-LineDF+0.305),-p.y+0.35,0.05),p.y-0.01,0.05),0.05);\n    d = -smin(-d,-smin(-LineDF+0.15,-p.y+0.38,0.05),0.05);\n    d = min(d,DFStud(vec3(p.x,p.y-0.4,p.z))); //Stud\n    return d;\n}\n\nfloat DFHeadLight(vec3 p) {\n    float d = -smin(-DFBox(p-vec3(0.04),vec3(0.92,1.12,0.92))+0.04,DFBox(p-vec3(-1.,0.25,-1.),vec3(1.2,2.,3.)),0.05);\n    //Stud\n    d = smin(d,-smin(-DFLine(p,vec3(0.5,0.7,0.5),vec3(-2.,0.7,0.5))+0.3,p.x,0.07),0.05);\n    d = -smin(-d,min(DFBox(p-vec3(0.35,0.25,0.25),vec3(2.9,0.7,0.5)),DFBox(p-vec3(0.35,-1.,0.25),vec3(0.4,1.95,0.5)))-0.05,0.05);\n    d = -smin(-d,DFLine(p,vec3(0.5,0.7,0.5),vec3(-2.,0.7,0.5))-0.2,0.05);\n    d = smin(d,max(-smin(-DFLine(p-vec3(0.,1.2,0.),vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))+0.3,-p.y+1.2+0.2,0.075),-p.y+1.2),0.03); //Stud\n    return d;\n}\n\nDF MIN(DF OUT, DF IN) {\n    if (OUT.D>IN.D) return IN;\n    return OUT;\n}\n\nDF SDF(vec3 p) {\n    DF OUT = DF(100000.,vec3(1.),1);\n    \n    //Return\n    return OUT;\n}\n\nvec3 StudInfo[22] = vec3[22](\n    vec3(0.,10.,0.), //0\n    vec3(1.,0.599,1.), //1\n    vec3(1.,10.,1.), //2\n    vec3(1.,0.599,1.), //3, Brick111\n    vec3(1.,10.,1.), //4\n    vec3(4.,0.599,1.), //5\n    vec3(4.,0.599,2.), //6\n    vec3(1.,1.399,1.), //7\n    vec3(1.,1.399,1.), //8\n    vec3(1.,0.999,1.), //9, Grip\n    vec3(1.,0.599,2.), //10\n    vec3(2.,0.599,1.), //11\n    vec3(1.,10.,1.), //12\n    vec3(1.,10.,1.), //13\n    vec3(1.,10.,1.), //14\n    vec3(1.,10.,1.), //15\n    vec3(1.,10.,1.), //16, Lever\n    vec3(1.,10.,1.), //17\n    vec3(1.,10.,1.), //18\n    vec3(2.,0.599,1.), //19\n    vec3(1.,10.999,1.), //20\n    vec3(1.,10.,1.) //21\n);\n\nconst vec3 L_SteeringY = normalize(vec3(-sin(radians(40.)),cos(radians(40.)),0.));\nconst vec3 L_SteeringX = normalize(cross(L_SteeringY,vec3(0.,0.,1.)));\nconst vec3 L_SteeringP = vec3(9.15,1.7,2.);\nconst float L_RoofAngle = radians(10.);\nconst vec3 L_RoofY = normalize(vec3(sin(L_RoofAngle),cos(L_RoofAngle),0.));\nconst vec3 L_RoofX = normalize(cross(L_RoofY,vec3(0.,0.,1.)));\nconst vec3 L_RoofP = vec3(5.85,4.55,4.);\nconst float L_ScreenAngle = radians(32.5);\nconst vec3 L_ScreenY = normalize(vec3(-sin(L_ScreenAngle),cos(L_ScreenAngle),0.));\nconst vec3 L_ScreenX = normalize(cross(L_ScreenY,vec3(0.,0.,1.)));\nconst vec3 L_ScreenP = vec3(8.5,3.1,1.); //Rotation point\nconst vec3 L_RedEmissive = vec3(1.,0.1,0.025)*3.;\nconst vec3 L_CarColor = vec3(0.2,0.4,0.8);\nBRICK Bricks[99] = BRICK[99](\n    //Tires\n    BRICK(vec3(3.,-0.05,1.),vec4(1.,0.,0.,0.),vec3(0.2),12,2),\n        BRICK(vec3(3.,-0.05,4.),vec4(1.,0.,0.,0.),vec3(0.2),12,2),\n    BRICK(vec3(9.,-0.05,1.),vec4(1.,0.,0.,0.),vec3(0.2),12,2),\n        BRICK(vec3(9.,-0.05,4.),vec4(1.,0.,0.,0.),vec3(0.2),12,2),\n        //Tire rim\n        BRICK(vec3(3.,-0.05,1.),vec4(1.,0.,0.,0.),vec3(0.9),13,1),\n            BRICK(vec3(5.,-0.05,5.),vec4(-1.,0.,0.,0.),vec3(0.9),13,1),\n        BRICK(vec3(9.,-0.05,1.),vec4(1.,0.,0.,0.),vec3(0.9),13,1),\n            BRICK(vec3(11.,-0.05,5.),vec4(-1.,0.,0.,0.),vec3(0.9),13,1),\n        //Tire rim connector (but actually not)\n        BRICK(vec3(3.,0.8,2.),vec4(1.,0.,0.,0.),vec3(0.6),11,1),\n            BRICK(vec3(3.,0.8,3.),vec4(1.,0.,0.,0.),vec3(0.6),11,1),\n        BRICK(vec3(9.,0.8,2.),vec4(1.,0.,0.,0.),vec3(0.6),11,1),\n            BRICK(vec3(9.,0.8,3.),vec4(1.,0.,0.,0.),vec3(0.6),11,1),\n    \n    //Base 412\n    BRICK(vec3(2.,0.4,2.),vec4(1.,0.,0.,0.),vec3(0.3),6,1),\n    BRICK(vec3(8.,0.4,2.),vec4(1.,0.,0.,0.),vec3(0.3),6,1),\n    BRICK(vec3(8.,0.4,1.),vec4(0.,0.,1.,0.),vec3(0.3),6,1),\n        BRICK(vec3(5.,0.8,1.),vec4(1.,0.,0.,0.),vec3(0.6),6,1),\n        BRICK(vec3(5.,0.8,3.),vec4(1.,0.,0.,0.),vec3(0.6),6,1),\n    \n    //Back headlights low\n    BRICK(vec3(2.,0.8,1.),vec4(1.,0.,0.,0.),L_CarColor,7,1),\n        BRICK(vec3(2.,0.8,2.),vec4(1.,0.,0.,0.),L_CarColor,7,1),\n        BRICK(vec3(2.,0.8,3.),vec4(1.,0.,0.,0.),L_CarColor,7,1),\n        BRICK(vec3(2.,0.8,4.),vec4(1.,0.,0.,0.),L_CarColor,7,1),\n    BRICK(vec3(2.2,2.,1.),vec4(0.,0.,1.,HPI),L_CarColor*0.5,5,1), //411\n        BRICK(vec3(1.8,2.,2.),vec4(-0.04471,-0.999,0.,0.),L_CarColor,0,1),\n        BRICK(vec3(1.8,2.,3.),vec4(-0.04471,-0.999,0.,0.),L_CarColor,0,1),\n        BRICK(vec3(1.8,2.,4.),vec4(-0.04471,-0.999,0.,0.),L_CarColor,0,1),\n        BRICK(vec3(1.8,2.,5.),vec4(-0.04471,-0.999,0.,0.),L_CarColor,0,1),\n    \n    //Back headlights above\n    BRICK(vec3(2.,2.,2.),vec4(1.,0.,0.,0.),vec3(0.3),7,1),\n        BRICK(vec3(2.,2.,3.),vec4(1.,0.,0.,0.),vec3(0.3),7,1),\n    BRICK(vec3(2.2,3.2,2.),vec4(0.,0.,1.,HPI),vec3(0.3),11,1), //211\n        BRICK(vec3(1.8,3.2,1.),vec4(0.,0.,1.,HPI),vec3(0.1),5,1), //411\n    BRICK(vec3(1.4,3.2,1.),vec4(0.,0.,1.,HPI),L_RedEmissive,4,0), //Grate\n        BRICK(vec3(1.4,3.2,3.),vec4(0.,0.,1.,HPI),L_RedEmissive,4,0),\n    \n    //Back headlights side\n    BRICK(vec3(4.,2.,2.),vec4(0.,0.,1.,0.),vec3(0.3),7,1), //To origin\n        BRICK(vec3(4.,3.2,2.2),vec4(-1.,0.,0.,HPI),vec3(1.,1.,0.3),1,0),\n        BRICK(vec3(4.,3.2,1.8),vec4(-1.,0.,0.,HPI),vec3(0.1),11,1),\n        BRICK(vec3(4.,3.2,1.4),vec4(-1.,0.,0.,HPI),L_RedEmissive,4,0),\n    BRICK(vec3(3.,2.,4.),vec4(0.,0.,-1.,0.),vec3(0.3),7,1), //From origin\n        BRICK(vec3(3.,3.2,3.8),vec4(1.,0.,0.,HPI),vec3(1.,1.,0.3),1,0),\n        BRICK(vec3(2.,3.2,4.2),vec4(1.,0.,0.,HPI),vec3(0.3),11,1),\n        BRICK(vec3(2.,3.2,4.6),vec4(1.,0.,0.,HPI),L_RedEmissive,4,0),\n    \n    //Under headlights side\n    BRICK(vec3(4.,1.2,2.),vec4(0.,0.,1.,0.),vec3(0.6),11,1),\n        BRICK(vec3(4.,1.6,2.),vec4(0.,0.,1.,0.),vec3(0.6),11,1),\n    \n    //Seat\n    BRICK(vec3(4.,1.2,2.),vec4(1.,0.,0.,0.),vec3(0.7,0.3,0.2),4,1),\n        BRICK(vec3(4.,1.2,3.),vec4(1.,0.,0.,0.),vec3(0.7,0.3,0.2),4,1),\n    BRICK(vec3(7.,1.2,2.),vec4(0.,0.,1.,0.),vec3(0.7,0.3,0.2),4,1),\n    \n    //Over tires (inverse slope and onlyslope)\n    BRICK(vec3(6.,1.2,2.),vec4(-1.,0.,0.,0.),L_CarColor,8,1),\n        BRICK(vec3(6.,1.2,5.),vec4(-1.,0.,0.,0.),L_CarColor,8,1),\n    BRICK(vec3(4.,2.4,1.),vec4(1.,0.,0.,0.),L_CarColor,0,1),\n        BRICK(vec3(4.,2.4,4.),vec4(1.,0.,0.,0.),L_CarColor,0,1),\n    \n    //On top of back + pipe\n    BRICK(vec3(3.,3.2,1.),vec4(0.,0.,1.,0.),L_CarColor,6,1), //412\n        BRICK(vec3(4.,3.2,1.),vec4(0.,0.,1.,0.),L_CarColor,5,1), //411\n    BRICK(vec3(2.,3.6,3.),vec4(1.,0.,0.,0.),vec3(0.3),7,1),\n        BRICK(vec3(2.2,4.8,3.),vec4(0.,0.,1.,HPI),vec3(0.9),2,1), //Pipe\n    BRICK(vec3(2.,3.6,3.),vec4(0.,0.,-1.,0.),L_CarColor,0,1),\n        BRICK(vec3(3.,4.8,4.),vec4(-1.,0.,0.,0.),L_CarColor,0,1),\n    \n    //Base of roof\n    BRICK(vec3(3.,3.6,4.),vec4(1.,0.,0.,0.),vec3(0.9),2,1),\n        BRICK(vec3(3.,3.6,1.),vec4(1.,0.,0.,0.),vec3(0.9),2,1),\n    BRICK(vec3(4.,4.8,1.),vec4(0.,0.,1.,0.),vec3(0.6),5,1), //411\n        BRICK(vec3(3.,5.2,2.),vec4(1.,0.,0.,0.),vec3(0.6),10,1),\n    \n    //Front\n    BRICK(vec3(12.,0.8,1.),vec4(0.,0.,1.,0.),vec3(0.6),5,1), //411\n        BRICK(vec3(12.,1.2,2.),vec4(-1.,0.,0.,0.),L_CarColor,7,1), //Headlight\n        BRICK(vec3(12.,1.2,5.),vec4(-1.,0.,0.,0.),L_CarColor,7,1),\n    BRICK(vec3(11.8,2.4,2.),vec4(0.,0.,-1.,HPI),vec3(2.),1,0),\n        BRICK(vec3(11.8,2.4,5.),vec4(0.,0.,-1.,HPI),vec3(2.),1,0),\n    \n    //Doors with base and mirrors\n    BRICK(vec3(9.,1.2,1.),vec4(0.,0.,1.,0.),L_CarColor,7,1),\n        BRICK(vec3(9.,2.4,1.2),vec4(-1.,0.,0.,HPI),L_CarColor,21,1), //Vertical Grip\n        BRICK(vec3(6.,1.4,0.8),vec4(1.,0.,0.,-HPI),L_CarColor,19,1), //Door (Long Handle)\n            BRICK(vec3(8.,1.35,1.2),vec4(0.,0.999,0.04471,0.),vec3(0.6),20,1), //Studgrip\n            BRICK(vec3(7.22,3.5,0.41),vec4(0.,0.,1.,HPI),vec3(0.9),0,1), //Mirror\n    BRICK(vec3(8.,1.2,5.),vec4(0.,0.,-1.,0.),L_CarColor,7,1),\n        BRICK(vec3(9.,1.4,4.8),vec4(-1.,0.,0.,-HPI),L_CarColor,21,1), //Vertical Grip\n        BRICK(vec3(6.,2.4,5.2),vec4(1.,0.,0.,HPI),L_CarColor,19,1), //Door (Long Handle)\n            BRICK(vec3(7.,1.35,4.8),vec4(0.,0.999,-0.04471,0.),vec3(0.6),20,1), //Studgrip\n            BRICK(vec3(7.22,2.5,5.6),vec4(0.,0.,-1.,-HPI),vec3(0.9),0,1), //Mirror\n    \n    //Over wheels forward (211+411)\n    BRICK(vec3(8.,2.4,1.),vec4(1.,0.,0.,0.),L_CarColor,5,1),\n        BRICK(vec3(9.,2.,1.),vec4(1.,0.,0.,0.),L_CarColor,11,1),\n    BRICK(vec3(8.,2.4,4.),vec4(1.,0.,0.,0.),L_CarColor,5,1),\n        BRICK(vec3(9.,2.,4.),vec4(1.,0.,0.,0.),L_CarColor,11,1),\n    \n    //Steering wheel and base\n    BRICK(vec3(9.,1.2,2.),vec4(0.,0.,1.,0.),vec3(0.3),17,1),\n    BRICK(L_SteeringP,vec4(0.,0.,1.,0.69813170079),vec3(0.6),18,1),\n        BRICK(L_SteeringP+L_SteeringY*1.2,vec4(0.,0.,1.,0.69813170079),L_CarColor,1,1),\n        BRICK(L_SteeringP+L_SteeringY*1.2+vec3(0.,0.,1.),vec4(0.,0.,1.,0.69813170079),vec3(3.),1,0),\n        BRICK(L_SteeringP+L_SteeringY*1.6+L_SteeringX*0.5+vec3(0.,0.,-0.5),vec4(0.,0.,1.,0.69813170079),vec3(0.8),14,1),\n    \n    //Hatch and under the hatch\n    BRICK(vec3(11.,1.2,4.),vec4(0.,0.,-1.,0.),vec3(0.3),17,1), //Rotating brick\n        BRICK(vec3(11.,1.2,4.),vec4(0.,0.,-1.,0.),vec3(0.6),18,1),\n        BRICK(vec3(12.,2.4,4.),vec4(-1.,0.,0.,0.),vec3(0.6),10,1),\n    BRICK(vec3(9.,1.2,2.),vec4(1.,0.,0.,0.),vec3(0.3),2,1), //Under\n        BRICK(vec3(9.,1.2,3.),vec4(1.,0.,0.,0.),vec3(0.3),2,1),\n        BRICK(vec3(11.,1.2,2.),vec4(0.,0.,1.,0.),vec3(0.3),0,1),\n        BRICK(vec3(10.,1.2,4.),vec4(0.,0.,-1.,0.),vec3(1.,0.5,0.3)*2.5,0,0),\n    \n    //Roof\n    BRICK(L_RoofP,vec4(-L_RoofX,0.),vec3(0.6),9,1),\n        BRICK(L_RoofP-vec3(0.,0.,1.),vec4(-L_RoofX,0.),vec3(0.6),9,1),\n    BRICK(L_RoofP+L_RoofY*0.8+L_RoofX-vec3(0.,0.,3.),vec4(0.,0.,1.,-L_RoofAngle),L_CarColor,6,1),\n        BRICK(L_RoofP+L_RoofY*0.4+L_RoofX*2.-vec3(0.,0.,3.),vec4(0.,0.,1.,-L_RoofAngle),L_CarColor,6,1),\n        BRICK(L_RoofP+L_RoofY*0.8+L_RoofX*1.-vec3(0.,0.,2.),vec4(L_RoofX,0.),vec3(0.6),10,1),\n    \n    //Levers\n    BRICK(vec3(8.,2.8,1.),vec4(1.,0.,0.,0.),vec3(0.8),15,1), //Lever base\n        BRICK(vec3(8.,2.8,4.),vec4(1.,0.,0.,0.),vec3(0.8),15,1),\n    BRICK(L_ScreenP-L_ScreenY*0.5-L_ScreenX*0.5+vec3(0.,0.,1.),vec4(L_ScreenY,0.),vec3(0.1),16,1), //Lever\n        BRICK(L_ScreenP-L_ScreenY*0.5-L_ScreenX*0.5+vec3(0.,0.,4.),vec4(L_ScreenY,0.),vec3(0.1),16,1)\n);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Storage and primary rays\n\nvec4 textureCube(vec2 uv) {\n    //Samples the cubemap\n    float tcSign = -mod(floor(uv.y*I1024), 2.)*2. + 1.;\n    vec3 tcD = vec3(vec2(uv.x, mod(uv.y, 1024.))*I512 - 1., tcSign);\n    if (uv.y > 4096.) tcD = tcD.xzy;\n    else if (uv.y > 2048.) tcD = tcD.zxy;\n    return textureLod(iChannel3, tcD, 0.);\n}\n\nfloat vSDF(vec3 sp) {\n    //Samples a volume SDF\n    float SVal = sp.x*20.;\n    vec2 UVmod = 0.5 + sp.zy*20.;\n    vec2 UVSlice0 = vec2(floor(mod(SVal, 8.))*120., floor(SVal/8.)*128.);\n    vec4 TexC = textureCube(UVmod + UVSlice0);\n    return mix(TexC.x, TexC.y, fract(SVal));\n}\n\nHIT traceRay(vec3 P, vec3 D, float Time) {\n    HIT OUT = HIT(1000000000., vec3(-1.), vec3(-1.), -1);\n    vec3 ID = 1./D;\n    \n    //Ground\n    if (D.y<0.) {\n        float planet = -(P.y - 0.05)/D.y;\n        vec3 planep = P + D*planet - vec3(-5., 0., 3.);\n        if (DFBox(vec2(planep.x + planep.z, planep.x - planep.z)*0.707, vec2(16.)) < 0.) {\n            OUT.D = planet;\n            OUT.C = vec3(1.);\n            OUT.N = vec3(0., 1., 0.);\n            OUT.M = 1;\n        }\n    }\n    \n    //Car\n    vec2 Carbb = ABox(P, ID, vec3(0., 0., 0.), vec3(13.95, 0.4*16. - 0.05, 5.95));\n    float CarDF = DFBox(P - vec3(0., 0., 0.), vec3(13.95, 0.4*16. - 0.05, 5.95));\n    if (CarDF < 0. || (Carbb.x > 0. && Carbb.y > Carbb.x && Carbb.x < OUT.D)) {\n        float CarFAR = min(Carbb.y, OUT.D);\n        float Cart = ((CarDF < 0.)?0.:Carbb.x + 0.05);\n        vec3 sp;\n        float dfs;\n        for (int i = 0; i < 256; i++) {\n            sp = P + D*Cart;\n            float SVal = sp.x*20.;\n            vec2 UVmod = 0.5 + sp.zy*20.;\n            vec2 UVSlice0 = vec2(floor(mod(SVal, 8.))*120., floor(SVal/8.)*128.);\n            vec4 TexC = textureCube(UVmod + UVSlice0);\n            dfs = mix(TexC.x, TexC.y, fract(SVal));\n            Cart += dfs;\n            if (min(dfs - 0.002, CarFAR - Cart) < 0.) break;\n        }\n        if (dfs < 0.002) {\n            //Hit\n            OUT.D = Cart;\n            sp = P + D*Cart;\n            OUT.N = normalize(vec3(vSDF(sp + eps.xyy) - vSDF(sp - eps.xyy),\n                                   vSDF(sp + eps.yxy) - vSDF(sp - eps.yxy),\n                                   vSDF(sp + eps.yyx) - vSDF(sp - eps.yyx)));\n            OUT.M = 1;\n            return OUT;\n        }\n    }\n    //Return\n    return OUT;\n}\n\nvoid UpdateMouse(inout vec4 Output, vec4 Mouse) {\n    //Updates the mouse\n    if (Mouse.z > 0.) {\n        if (Output.w == 0.) {\n            Output.w = 1.;\n            Output.z = iTime;\n            Output.xy = Mouse.zw;\n        }\n    } else {\n        Output.w = 0.;\n    }\n}\n\nvoid UpdateEye(inout vec4 Output, vec4 CMouse, vec4 Mouse) {\n    //Updates the eye vector\n    if (CMouse.w == 0.)  {\n        //Animation\n        float angVel = texture(iChannel0, vec2(3.5, 0.5)*IRES).x;\n        Output.y = mod(Output.y + angVel*iTimeDelta, 3.141592653*2.);\n        Output.x = mix(Output.x, -0.3, angVel*iTimeDelta);\n        //Copy\n        Output.zw = Output.xy;\n    }\n    if (CMouse.w == 1.) {\n        //Y led\n        Output.x = Output.z + (Mouse.y - CMouse.y)*IRES.y*5.;\n        Output.x = clamp(Output.x, -1.4, 0.1);\n        //X led\n        Output.y = Output.w - (Mouse.x - CMouse.x)*IRES.x*10.;\n        Output.y = mod(Output.y, 3.141592653*2.);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = texture(iChannel0, fragCoord.xy*IRES);\n    if (iFrame == 0) {\n        //Initialization\n        if (fragCoord.x < 10. && fragCoord.y < 1.) { //Store vars\n            if (fragCoord.x < 1.) Output = vec4(0., 0., 0., 0.); //Mouse\n            else if (fragCoord.x < 2.) Output = vec4(-0.3, -2.45, 0., 0.); //Player Eye (Angles)\n            else if (fragCoord.x < 3.) Output = vec4(0., 0., 0., 1.); //Player Eye (Vector)\n            else if (fragCoord.x < 4.) Output = vec4(0., 0., 0., 1.); //Camera animated movement angvel\n        }\n    } else {\n        //Update\n\t\tif (fragCoord.x < 8. && fragCoord.y < 1.) {\n            //Update vars\n            if (fragCoord.x < 1.) { //Mouse\n                UpdateMouse(Output, iMouse);\n            } else if (fragCoord.x < 2.) {\n                //Player Eye (Angles)\n                vec4 CMouse = texture(iChannel0, vec2(0.5, 0.5)*IRES);\n                UpdateMouse(CMouse, iMouse);\n                UpdateEye(Output, CMouse, iMouse);\n            } else if (fragCoord.x < 3.) {\n                //Player Eye (Vector)\n                vec4 A4 = texture(iChannel0, vec2(1.5, 0.5)*IRES);\n                vec4 CMouse = texture(iChannel0, vec2(0.5, 0.5)*IRES);\n                UpdateMouse(CMouse, iMouse);\n                UpdateEye(A4, CMouse, iMouse);\n                Output.xyz = normalize(vec3(cos(A4.x)*sin(A4.y), sin(A4.x), cos(A4.x)*cos(A4.y)));\n            } else if (fragCoord.x < 4.) {\n                //Player Eye animation angvel\n                vec4 CMouse = texture(iChannel0, vec2(0.5, 0.5)*IRES);\n                UpdateMouse(CMouse, iMouse);\n                if (CMouse.w == 0.) {\n                    //No input -> accelerate angvel\n                    Output.x = 0.5*(1. - exp(-(iTime - CMouse.z)));\n                } else {\n                    //Input -> no angvel\n                    Output.x = 0.;\n                } \n            } else if (fragCoord.x < 5.) {\n                //Player Eye last frame\n                Output = texture(iChannel0, vec2(2.5, 0.5)*IRES);\n            }\n        }\n    }\n    if (DFBox(fragCoord - 1., RES - 2.) < 0.) {\n        Output = vec4(0.);\n        if (iFrame > 8) {\n            //G-Buffer\n            vec2 SSOffset = fract(vec2(0.61803398875, 0.38196601125)*float(iFrame % 16))*0.8 - 0.5;\n            vec3 SunDir = texture(iChannel0, vec2(5.5, 0.5)*IRES).xyz;\n            //Compensate for 1 frame lag\n            vec4 CMouse = texture(iChannel0, vec2(0.5, 0.5)*IRES);\n            UpdateMouse(CMouse, iMouse);\n            vec4 Eye4 = texture(iChannel0, vec2(1.5, 0.5)*IRES);\n            vec3 PriorEye = normalize(vec3(cos(Eye4.x)*sin(Eye4.y), sin(Eye4.x), cos(Eye4.x)*cos(Eye4.y)));\n            UpdateEye(Eye4, CMouse, iMouse);\n            vec3 Eye = normalize(vec3(cos(Eye4.x)*sin(Eye4.y), sin(Eye4.x), cos(Eye4.x)*cos(Eye4.y)));\n            vec3 Pos = vec3(7. - Eye.x*2., 2., 3.) - Eye*13.;\n            mat3 EyeMat = TBN(Eye);\n            vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2. - 1.)*(ASPECT*CFOV), 1.)*EyeMat);\n            //Render scene\n            HIT Pixel = traceRay(Pos, Dir, iTime);\n            if (Pixel.M == 0) {\n                //Emissive\n                Output = vec4(Vec3ToFloat(Pixel.C*ILightCoeff), 0., texture(iChannel0,fragCoord*IRES).w, -2.);\n            } else if (Pixel.M > 0) {\n                //Geometry\n                Output = vec4(Vec3ToFloat(Pixel.C),\n                              Vec3ToFloat(Pixel.N*0.49 + 0.5),\n                              texture(iChannel0, fragCoord*IRES).w,\n                              Pixel.D);\n            } else {\n                //Sky\n                Output = vec4(0., 0., texture(iChannel0, fragCoord*IRES).w, -1.);\n            }\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Voxel cone tracing\n\nvec4 textureCube(vec2 uv, float lod) {\n    //Samples the cubemap\n    float tcSign = -mod(floor(uv.y*I1024), 2.)*2. + 1.;\n    vec3 tcD = vec3(vec2(uv.x, mod(uv.y, 1024.))*I512 - 1., tcSign);\n    if (uv.y > 4096.) tcD = tcD.xzy;\n    else if (uv.y > 2048.) tcD = tcD.zxy;\n    return textureLod(iChannel3, tcD, lod);\n}\n\nvec4 vct_sample0(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd) {\n    //Samples VCT volume - LOD 0\n    vec3 vp5c = clamp(vp5, vec3(0.5), vec3(79.5, 31.5, 31.5));\n    vec2 vUV0 = vec2(vp5c.x + floor(mod(vp5c.y - 0.5, 12.))*80., vp5c.z + floor((vp5c.y - 0.5)/12.)*32.);\n    vec2 vUV1 = vec2(vp5c.x + floor(mod(vp5c.y + 0.5, 12.))*80., vp5c.z + floor((vp5c.y + 0.5)/12.)*32.);\n    float offsetX = max(0., -sign(dir.x)*96.);\n    vec4 vSampleX = mix(textureCube(vUV0 + vec2(0., 4480. + offsetX), 0.),\n                        textureCube(vUV1 + vec2(0., 4480. + offsetX), 0.), fract(vp5c.y + 0.5));\n    float offsetY = max(0., -sign(dir.y)*96.);\n    vec4 vSampleY = mix(textureCube(vUV0 + vec2(0., 4672. + offsetY), 0.),\n                        textureCube(vUV1 + vec2(0., 4672. + offsetY), 0.), fract(vp5c.y + 0.5));\n    float offsetZ = max(0., -sign(dir.z)*96.);\n    vec4 vSampleZ = mix(textureCube(vUV0 + vec2(0., 4864. + offsetZ), 0.),\n                        textureCube(vUV1 + vec2(0., 4864. + offsetZ), 0.), fract(vp5c.y + 0.5));\n    vec4 vSample = (dirSqr.x*vSampleX + dirSqr.y*vSampleY + dirSqr.z*vSampleZ)*\n                   clamp(1. - DFBox(vp5 - 0.5, vec3(79., 31., 31.)), 0., 1.);\n    return vSample + textureCube(clamp(vp5.xz + vec2(29., 49.), vec2(0.5), vec2(127.5)) + vec2(512., 5120.), 0.)*\n           clamp(1. - DFBox(vp5 - vec3(-29., 0.05, -49.), vec3(128., 0., 128.)), 0., 1.)*fwd*(1. - vSample.w);\n}\n\nvec4 vct_sample1(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd) {\n    //Samples VCT volume - LOD 1\n    vec3 vp5c = clamp(vp5*0.5, vec3(0.5), vec3(39.5, 15.5, 15.5));\n    vec2 vUV0 = vec2(vp5c.x + floor(mod(vp5c.y - 0.5, 6.))*40., vp5c.z + floor((vp5c.y - 0.5)/6.)*16.);\n    vec2 vUV1 = vec2(vp5c.x + floor(mod(vp5c.y + 0.5, 6.))*40., vp5c.z + floor((vp5c.y + 0.5)/6.)*16.);\n    float offsetX = max(0., -sign(dir.x)*96.);\n    vec4 vSampleX = mix(textureCube(vUV0 + vec2(0., 5120. + offsetX), 0.),\n                        textureCube(vUV1 + vec2(0., 5120. + offsetX), 0.), fract(vp5c.y + 0.5));\n    float offsetY = max(0., -sign(dir.y)*96.);\n    vec4 vSampleY = mix(textureCube(vUV0 + vec2(0., 5120. + offsetY), 0.),\n                        textureCube(vUV1 + vec2(0., 5120. + offsetY), 0.), fract(vp5c.y + 0.5));\n    float offsetZ = max(0., -sign(dir.z)*96.);\n    vec4 vSampleZ = mix(textureCube(vUV0 + vec2(0., 5120. + offsetZ), 0.),\n                        textureCube(vUV1 + vec2(0., 5120. + offsetZ), 0.), fract(vp5c.y + 0.5));\n    vec4 vSample = (dirSqr.x*vSampleX + dirSqr.y*vSampleY + dirSqr.z*vSampleZ)*\n                   clamp(1. - DFBox(vp5*0.5 - 0.5, vec3(39., 15., 15.)), 0., 1.);\n    return vSample + textureCube(clamp(vp5.xz + vec2(29., 49.), vec2(1.), vec2(127.)) + vec2(512., 5120.), 1.)*\n           clamp(1. - DFBox(vp5 - vec3(-29., 0.05, -49.), vec3(128., 0., 128.))*0.5, 0., 1.)*fwd*(1. - vSample.w);\n}\n\nvec4 vct_sample2(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd) {\n    //Samples VCT volume - LOD 2\n    vec3 vp5c = clamp(vp5*0.25, vec3(0.5), vec3(19.5, 7.5, 7.5));\n    vec2 vUV0 = vec2(vp5c.x + floor(vp5c.y - 0.5)*20., vp5c.z);\n    vec2 vUV1 = vec2(vp5c.x + floor(vp5c.y + 0.5)*20., vp5c.z);\n    float offsetX = max(0., -sign(dir.x)*96.);\n    vec4 vSampleX = mix(textureCube(vUV0 + vec2(0., 5168. + offsetX), 0.),\n                        textureCube(vUV1 + vec2(0., 5168. + offsetX), 0.), fract(vp5c.y + 0.5));\n    float offsetY = max(0., -sign(dir.y)*96.);\n    vec4 vSampleY = mix(textureCube(vUV0 + vec2(0., 5168. + offsetY), 0.),\n                        textureCube(vUV1 + vec2(0., 5168. + offsetY), 0.), fract(vp5c.y + 0.5));\n    float offsetZ = max(0., -sign(dir.z)*96.);\n    vec4 vSampleZ = mix(textureCube(vUV0 + vec2(0., 5168. + offsetZ), 0.),\n                        textureCube(vUV1 + vec2(0., 5168. + offsetZ), 0.), fract(vp5c.y + 0.5));\n    vec4 vSample = (dirSqr.x*vSampleX + dirSqr.y*vSampleY + dirSqr.z*vSampleZ)*\n                   clamp(1. - DFBox(vp5*0.25 - 0.5, vec3(19., 7., 7.)), 0., 1.);\n    return vSample + textureCube(clamp(vp5.xz + vec2(29., 49.), vec2(2.), vec2(126.)) + vec2(512., 5120.), 2.)*\n           clamp(1. - DFBox(vp5 - vec3(-29., 0.05, -49.), vec3(128., 0., 128.))*0.25, 0., 1.)*fwd*(1. - vSample.w);\n}\n\nvec4 vct_sample3(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd) {\n    //Samples VCT volume - LOD 3\n    vec3 vp5c = clamp(vp5*0.125, vec3(0.5), vec3(9.5, 3.5, 3.5));\n    vec2 vUV0 = vec2(vp5c.x + floor(vp5c.y - 0.5)*10., vp5c.z);\n    vec2 vUV1 = vec2(vp5c.x + floor(vp5c.y + 0.5)*10., vp5c.z);\n    float offsetX = max(0., -sign(dir.x)*96.);\n    vec4 vSampleX = mix(textureCube(vUV0 + vec2(0., 5176. + offsetX), 0.),\n                        textureCube(vUV1 + vec2(0., 5176. + offsetX), 0.), fract(vp5c.y + 0.5));\n    float offsetY = max(0., -sign(dir.y)*96.);\n    vec4 vSampleY = mix(textureCube(vUV0 + vec2(0., 5176. + offsetY), 0.),\n                        textureCube(vUV1 + vec2(0., 5176. + offsetY), 0.), fract(vp5c.y + 0.5));\n    float offsetZ = max(0., -sign(dir.z)*96.);\n    vec4 vSampleZ = mix(textureCube(vUV0 + vec2(0., 5176. + offsetZ), 0.),\n                        textureCube(vUV1 + vec2(0., 5176. + offsetZ), 0.), fract(vp5c.y + 0.5));\n    vec4 vSample = (dirSqr.x*vSampleX + dirSqr.y*vSampleY + dirSqr.z*vSampleZ)*\n                   clamp(1. - DFBox(vp5*0.125 - 0.5, vec3(9., 3., 3.)), 0., 1.);\n    return vSample + textureCube(clamp(vp5.xz + vec2(29., 49.), vec2(4.), vec2(124.)) + vec2(512., 5120.), 3.)*\n           clamp(1. - DFBox(vp5 - vec3(-29., 0.05, -49.), vec3(128., 0., 128.))*0.125, 0., 1.)*fwd*(1. - vSample.w);\n}\n\nvec4 vct_sample4(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd) {\n    //Samples VCT volume - LOD 4\n    vec3 vp5c = clamp(vp5*I16, vec3(0.5), vec3(4.5, 1.5, 1.5));\n    vec2 vUV0 = vec2(vp5c.x + floor(vp5c.y - 0.5)*5., vp5c.z);\n    vec2 vUV1 = vec2(vp5c.x + floor(vp5c.y + 0.5)*5., vp5c.z);\n    float offsetX = max(0., -sign(dir.x)*96.);\n    vec4 vSampleX = mix(textureCube(vUV0 + vec2(0., 5180. + offsetX), 0.),\n                        textureCube(vUV1 + vec2(0., 5180. + offsetX), 0.), fract(vp5c.y + 0.5));\n    float offsetY = max(0., -sign(dir.y)*96.);\n    vec4 vSampleY = mix(textureCube(vUV0 + vec2(0., 5180. + offsetY), 0.),\n                        textureCube(vUV1 + vec2(0., 5180. + offsetY), 0.), fract(vp5c.y + 0.5));\n    float offsetZ = max(0., -sign(dir.z)*96.);\n    vec4 vSampleZ = mix(textureCube(vUV0 + vec2(0., 5180. + offsetZ), 0.),\n                        textureCube(vUV1 + vec2(0., 5180. + offsetZ), 0.), fract(vp5c.y + 0.5));\n    vec4 vSample = (dirSqr.x*vSampleX + dirSqr.y*vSampleY + dirSqr.z*vSampleZ)*\n                   clamp(1. - DFBox(vp5*I16 - 0.5, vec3(4., 1., 1.)), 0., 1.);\n    return vSample + textureCube(clamp(vp5.xz + vec2(29., 49.), vec2(8.), vec2(120.)) + vec2(512., 5120.), 4.)*\n           clamp(1. - DFBox(vp5 - vec3(-29., 0.05, -49.), vec3(128., 0., 128.))*I16, 0., 1.)*fwd*(1. - vSample.w);\n}\n\nvec4 vct_sample(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd, float lod) {\n    //Sample VCT volume with manual LOD interpolation\n    if (lod < 1.) return mix(vct_sample0(vp5, dir, dirSqr, fwd), vct_sample1(vp5, dir, dirSqr, fwd), lod);\n    else if (lod < 2.) return mix(vct_sample1(vp5, dir, dirSqr, fwd), vct_sample2(vp5, dir, dirSqr, fwd), lod - 1.);\n    else if (lod < 3.) return mix(vct_sample2(vp5, dir, dirSqr, fwd), vct_sample3(vp5, dir, dirSqr, fwd), lod - 2.);\n    else if (lod < 4.) return mix(vct_sample3(vp5, dir, dirSqr, fwd), vct_sample4(vp5, dir, dirSqr, fwd), lod - 3.);\n    return vct_sample4(vp5, dir, dirSqr, fwd);\n}\n\nvec3 traceCone45(vec3 pos, vec3 dir) {\n    //Traces a cone with const CR -> no LOD interpolation\n    vec4 vOUT = vec4(0.);\n    vec3 vp5, vp5c;\n    vec4 vSample = vec4(0.);\n    float floorWeightDir = -max(0., -dir.y)*dir.y;\n    vec3 dirSqr = dir*dir;\n    vp5 = pos*5. + dir*0.5;\n    vOUT = vct_sample0(vp5, dir, dirSqr, floorWeightDir);\n    vp5 += dir;\n    vOUT += vct_sample1(vp5, dir, dirSqr, floorWeightDir)*(1. - vOUT.w);\n    vp5 += dir*2.;\n    vOUT += vct_sample2(vp5, dir, dirSqr, floorWeightDir)*(1. - vOUT.w);\n    vp5 += dir*4.;\n    vOUT += vct_sample3(vp5, dir, dirSqr, floorWeightDir)*(1. - vOUT.w);\n    vp5 += dir*8.;\n    vOUT += vct_sample4(vp5, dir, dirSqr, floorWeightDir)*(1. - vOUT.w);\n    return vOUT.xyz + mix(vec3(0.1, 0.13, 0.16), vec3(0.16, 0.08, 0.02), dir.x*0. + 0.)*((dir.y*0.5 + 0.5)*(1. - vOUT.w));\n}\n\nvec3 traceCone(vec3 pos, vec3 dir, float cr) {\n    //Traces a cone with LOD interpolation\n    vec4 vOUT = vec4(0.);\n    float floorWeightDir = -max(0., -dir.y)*dir.y;\n    vec3 dirSqr = dir*dir;\n    float vt = 0.;\n    vec3 vp;\n    for (int i = 0; i < 24; i++) {\n        vp = pos + dir*vt;\n        vec3 vp5 = vp*5.;\n        float vRadius = max(1., cr*vt*5.);\n        float vLod = log2(vRadius);\n        vOUT += vct_sample(vp5, dir, dirSqr, floorWeightDir, vLod)*(1. - vOUT.w);\n        vt += vRadius*0.2;\n    }\n    return vOUT.xyz + vec3(0.13, 0.18, 0.24)*((dir.y*0.5 + 0.5)*(1. - vOUT.w));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    vec2 SSOffset = fract(vec2(0.61803398875, 0.38196601125)*float(iFrame % 16))*0.8 - 0.5;\n    vec3 Eye = texture(iChannel0, vec2(2.5, 0.5)*IRES).xyz;\n    vec3 Pos = vec3(7. - Eye.x*2., 2., 3.) - Eye*13.;\n    mat3 EyeMat = TBN(Eye);\n    vec3 PriorPos = texture(iChannel0, vec2(7.5, 0.5)*IRES).xyz;\n    vec3 PriorEye = texture(iChannel0, vec2(6.5, 0.5)*IRES).xyz;\n    vec3 PriorTan; vec3 PriorBit = TBN(PriorEye, PriorTan);\n    mat3 PriorEyeMat = TBN(PriorEye);\n    vec3 Dir = normalize(vec3(((fragCoord + SSOffset)*IRES*2. - 1.)*CFOV*ASPECT, 1.)*EyeMat);\n    vec4 cAttr = texture(iChannel0, fragCoord*IRES);\n    if (cAttr.w > -0.5) {\n        //Geometry\n        vec3 pPos = Pos + Dir*cAttr.w;\n        vec3 pNor = normalize(FloatToVec3(cAttr.y)*2. - 1.);\n        \n        //Direct diffuse light\n        vec3 diffuseLight = vec3(0.);\n        vec3 smPos = pPos - SUN_TARGET;\n        float spotWeight = pow(max(0., (dot(normalize(smPos - SUN_DIR*32.), -SUN_DIR) - 1. + 0.01)/0.01), 2.);\n        vec2 smUV = vec2(dot(smPos, SUN_TAN)/(SUN_SM_SIZE*ASPECT.x)*0.5 + 0.5, dot(smPos, SUN_BIT)/SUN_SM_SIZE*0.5 + 0.5);\n        if (DFBox(smUV, vec2(1.)) < 0.) {\n            //Inside shadow map\n            float smDepth = texture(iChannel2, smUV).x;\n            if (smDepth + 0.03 > dot(pPos - SUN_TARGET - SUN_DIR*32., -SUN_DIR)) {\n                diffuseLight = vec3(max(0., dot(pNor, SUN_DIR))*2.*spotWeight);\n            }\n        } else {\n            //Outside\n            diffuseLight = vec3(max(0., dot(pNor, SUN_DIR))*2.*spotWeight);\n        }\n        \n        //Indirect diffuse light\n        mat3 nMat = TBN(pNor);\n        diffuseLight += (traceCone45(pPos + pNor*0.1, pNor).xyz + (\n                       traceCone45(pPos + pNor*0.1, vec3(0.707, 0., 0.707)*nMat).xyz +\n                       traceCone45(pPos + pNor*0.1, vec3(-0.707, 0., 0.707)*nMat).xyz +\n                       traceCone45(pPos + pNor*0.1, vec3(0., 0.707, 0.707)*nMat).xyz +\n                       traceCone45(pPos + pNor*0.1, vec3(0., -0.707, 0.707)*nMat).xyz)*0.707)*0.2;\n        \n        //Hardcoded materials\n        if (pPos.y < 0.051) {\n            //Floor\n            vec3 refDir = normalize(reflect(Dir, pNor));\n            float checker_cr = ((mod(floor((pPos.z + pPos.x)*0.707*0.4) +\n                                     floor((pPos.z - pPos.x)*0.707*0.4) + 0.5, 2.) < 1.)?0.1:0.3);\n            Output.xyz += mix(diffuseLight, traceCone(pPos + pNor*0.1, refDir, checker_cr).xyz,\n                              SchlickFresnel(vec3(0.5), max(0., dot(pNor, -Dir))));\n        } else {\n            //Car\n            Output.xyz = diffuseLight;\n        }\n        \n        //Emissive\n        vec3 symPos = vec3(pPos.xy, 3. + abs(pPos.z - 3.));\n        if (DFBox(symPos - vec3(11.81, 1.5, 4.), vec3(1., 0.95, 1.)) < 0.) {\n            Output.xyz = vec3(3., 1.5, 0.5);\n        }\n        if (min(DFBox(symPos - vec3(2., 2.2, 4.81), vec3(2., 0.95, 0.2)),\n                DFBox(symPos - vec3(0.99, 2.2, 3.05), vec3(0.2, 0.95, 3.))) < 0.) {\n            Output.xyz = vec3(3., 0.25, 0.25);\n        }\n    } else {\n        //Sky\n        Output.xyz = vec3(0.13, 0.18, 0.24)*(Dir.y*0.5 + 0.5);\n    }\n    fragColor = Output;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//TAA\n\nvec4 sampleLevel0(vec2 PriorUV) {\n    return texture(iChannel2, PriorUV*IRES);\n}\n\nvec4 SampleTextureCatmullRom(vec2 uv) {\n    vec2 samplePos = uv;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n    vec2 f = samplePos - texPos1;\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f));\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n    vec2 texPos0 = texPos1 - vec2(1.);\n    vec2 texPos3 = texPos1 + vec2(2.);\n    vec2 texPos12 = texPos1 + offset12;\n    vec4 result = vec4(0.);\n    result += sampleLevel0( vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n    return max(vec4(0., 0., 0., 1.),result);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0., 0., 0., 1.);\n    if (iFrame > 1 && DFBox(fragCoord - 1., RES - 2.) < 0.) {\n        //Inside the screen\n        vec3 BCRef = texture(iChannel1, fragCoord*IRES).xyz;\n        vec3 FinalColor = vec3(BCRef.xyz);\n        //Reprojection\n        vec3 Eye = texture(iChannel0, vec2(2.5, 0.5)*IRES).xyz;\n        vec3 Pos = vec3(7. - Eye.x*2., 2., 3.) - Eye*13.;\n        mat3 EyeMat = TBN(Eye);\n        vec3 PriorEye = texture(iChannel0, vec2(4.5, 0.5)*IRES).xyz;\n        vec3 PriorPos = vec3(7. - PriorEye.x*2., 2., 3.) - PriorEye*13.;\n        vec3 PriorTan; vec3 PriorBit = TBN(PriorEye, PriorTan);\n        mat3 PriorEyeMat = TBN(PriorEye);\n        vec3 Dir = normalize(vec3((fragCoord*IRES*2. - 1.)*CFOV*ASPECT, 1.)*EyeMat);\n        vec4 CAttr = texture(iChannel0, fragCoord*IRES);\n        float Distance = CAttr.w;\n        if (Distance < -0.5) Distance = 100000.; //Sky pixel\n        vec3 PPos = Pos + Dir*Distance;\n        //Prior position\n        vec3 PriorVPos = vec3(dot(PPos - PriorPos, PriorTan), dot(PPos - PriorPos, PriorBit), dot(PPos - PriorPos, PriorEye));\n        vec2 PriorUV = ((PriorVPos.xy/PriorVPos.z)*0.5/(ASPECT*CFOV) + 0.5)*RES;\n        if (DFBox(PriorUV - 1., RES - 2.) < 0.) {\n            //Geometric validation\n            vec4 LFinalColor;\n            if (length(PriorUV - fragCoord) > 0.02) {\n                //Catmull-rom sampling\n                LFinalColor = SampleTextureCatmullRom(PriorUV);\n            } else {\n                //Nearest neighbour sampling\n                PriorUV = floor(PriorUV) + 0.5;\n                LFinalColor = texture(iChannel2, PriorUV*IRES);\n            }\n            //Clamping\n            vec3 FMIN = vec3(1000.);\n            vec3 FMAX = vec3(0.);\n            for (float x = -1.; x < 1.5; x += 1.) {\n                for (float y = -1.; y < 1.5; y += 1.) {\n                    vec3 Sample = texture(iChannel1, (fragCoord + vec2(x, y))*IRES).xyz;\n                    //Clamp\n                    FMIN = min(FMIN, Sample);\n                    FMAX = max(FMAX, Sample);\n                }\n            }\n            LFinalColor.xyz = clamp(LFinalColor.xyz, FMIN, FMAX);\n            //Output\n            Output = vec4((FinalColor + LFinalColor.xyz*LFinalColor.w)/(LFinalColor.w + 1.), min(31., LFinalColor.w + 1.));\n        } else {\n            //Invalid geometry\n            Output = vec4(FinalColor, 1.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Shadow map\n\nvec4 textureCube(vec2 uv) {\n    //Samples the cubemap\n    float tcSign = -mod(floor(uv.y*I1024), 2.)*2. + 1.;\n    vec3 tcD = vec3(vec2(uv.x, mod(uv.y, 1024.))*I512 - 1., tcSign);\n    if (uv.y > 4096.) tcD = tcD.xzy;\n    else if (uv.y > 2048.) tcD = tcD.zxy;\n    return texture(iChannel3, tcD, 0.);\n}\n\nfloat vSDF(vec3 sp) {\n    //Samples a volume SDF\n    float SVal = sp.x*20.;\n    vec2 UVmod = 0.5 + sp.zy*20.;\n    vec2 UVSlice0 = vec2(floor(mod(SVal, 8.))*120., floor(SVal/8.)*128.);\n    vec4 TexC = textureCube(UVmod + UVSlice0);\n    return mix(TexC.x, TexC.y, fract(SVal));\n}\n\nfloat traceRay(vec3 P, vec3 D) {\n    vec3 ID = 1./D;\n    //Car\n    vec2 Carbb = ABox(P, ID, vec3(0., 0., 0.), vec3(13.95, 0.4*16. - 0.05, 5.95));\n    float CarDF = DFBox(P - vec3(0., 0., 0.), vec3(13.95, 0.4*16. - 0.05, 5.95));\n    if (CarDF < 0. || (Carbb.x > 0. && Carbb.y > Carbb.x)) {\n        float CarFAR = Carbb.y;\n        float Cart = ((CarDF < 0.)?0.:Carbb.x + 0.05);\n        vec3 sp;\n        float dfs;\n        for (int i = 0; i < 256; i++) {\n            sp = P + D*Cart;\n            float SVal = sp.x*20.;\n            vec2 UVmod = 0.5 + sp.zy*20.;\n            vec2 UVSlice0 = vec2(floor(mod(SVal, 8.))*120., floor(SVal/8.)*128.);\n            vec4 TexC = textureCube(UVmod + UVSlice0);\n            dfs = mix(TexC.x, TexC.y, fract(SVal));\n            Cart += dfs;\n            if (min(dfs - 0.002, CarFAR - Cart) < 0.) break;\n        }\n        if (dfs < 0.002) {\n            //Hit\n            return Cart;\n        }\n    }\n    //Return\n    return 10000.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 sunStartPos = SUN_TARGET + SUN_DIR*32. +\n                       ((fragCoord.x*IRES.x*2. - 1.)*SUN_SM_SIZE*ASPECT.x)*SUN_TAN +\n                       ((fragCoord.y*IRES.y*2. - 1.)*SUN_SM_SIZE)*SUN_BIT;\n    fragColor = vec4(traceRay(sunStartPos, -SUN_DIR));\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//LEGO model and voxels\n\nvec4 textureCube(vec2 uv) {\n    //Samples the cubemap\n    float tcSign = -mod(floor(uv.y*I1024), 2.)*2. + 1.;\n    vec3 tcD = vec3(vec2(uv.x, mod(uv.y, 1024.))*I512 - 1., tcSign);\n    if (uv.y > 4096.) tcD = tcD.xzy;\n    else if (uv.y > 2048.) tcD = tcD.zxy;\n    return textureLod(iChannel3, tcD, 0.);\n}\n\nvec4 textureCube(vec2 uv, float lod) {\n    //Samples the cubemap\n    float tcSign = -mod(floor(uv.y*I1024), 2.)*2. + 1.;\n    vec3 tcD = vec3(vec2(uv.x, mod(uv.y, 1024.))*I512 - 1., tcSign);\n    if (uv.y > 4096.) tcD = tcD.xzy;\n    else if (uv.y > 2048.) tcD = tcD.zxy;\n    return textureLod(iChannel3, tcD, lod);\n}\n\nvec4 vct_sample0(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd) {\n    //Samples VCT volume - LOD 0\n    vec3 vp5c = clamp(vp5, vec3(0.5), vec3(79.5, 31.5, 31.5));\n    vec2 vUV0 = vec2(vp5c.x + floor(mod(vp5c.y - 0.5, 12.))*80., vp5c.z + floor((vp5c.y - 0.5)/12.)*32.);\n    vec2 vUV1 = vec2(vp5c.x + floor(mod(vp5c.y + 0.5, 12.))*80., vp5c.z + floor((vp5c.y + 0.5)/12.)*32.);\n    float offsetX = max(0., -sign(dir.x)*96.);\n    vec4 vSampleX = mix(textureCube(vUV0 + vec2(0., 4480. + offsetX), 0.),\n                        textureCube(vUV1 + vec2(0., 4480. + offsetX), 0.), fract(vp5c.y + 0.5));\n    float offsetY = max(0., -sign(dir.y)*96.);\n    vec4 vSampleY = mix(textureCube(vUV0 + vec2(0., 4672. + offsetY), 0.),\n                        textureCube(vUV1 + vec2(0., 4672. + offsetY), 0.), fract(vp5c.y + 0.5));\n    float offsetZ = max(0., -sign(dir.z)*96.);\n    vec4 vSampleZ = mix(textureCube(vUV0 + vec2(0., 4864. + offsetZ), 0.),\n                        textureCube(vUV1 + vec2(0., 4864. + offsetZ), 0.), fract(vp5c.y + 0.5));\n    vec4 vSample = (dirSqr.x*vSampleX + dirSqr.y*vSampleY + dirSqr.z*vSampleZ)*\n                   clamp(1. - DFBox(vp5 - 0.5, vec3(79., 31., 31.)), 0., 1.);\n    return vSample + textureCube(clamp(vp5.xz + vec2(29., 49.), vec2(0.5), vec2(127.5)) + vec2(512., 5120.), 0.)*\n           clamp(1. - DFBox(vp5 - vec3(-29., 0.05, -49.), vec3(128., 0., 128.)), 0., 1.)*fwd*(1. - vSample.w);\n}\n\nvec4 vct_sample1(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd) {\n    //Samples VCT volume - LOD 1\n    vec3 vp5c = clamp(vp5*0.5, vec3(0.5), vec3(39.5, 15.5, 15.5));\n    vec2 vUV0 = vec2(vp5c.x + floor(mod(vp5c.y - 0.5, 6.))*40., vp5c.z + floor((vp5c.y - 0.5)/6.)*16.);\n    vec2 vUV1 = vec2(vp5c.x + floor(mod(vp5c.y + 0.5, 6.))*40., vp5c.z + floor((vp5c.y + 0.5)/6.)*16.);\n    float offsetX = max(0., -sign(dir.x)*96.);\n    vec4 vSampleX = mix(textureCube(vUV0 + vec2(0., 5120. + offsetX), 0.),\n                        textureCube(vUV1 + vec2(0., 5120. + offsetX), 0.), fract(vp5c.y + 0.5));\n    float offsetY = max(0., -sign(dir.y)*96.);\n    vec4 vSampleY = mix(textureCube(vUV0 + vec2(0., 5120. + offsetY), 0.),\n                        textureCube(vUV1 + vec2(0., 5120. + offsetY), 0.), fract(vp5c.y + 0.5));\n    float offsetZ = max(0., -sign(dir.z)*96.);\n    vec4 vSampleZ = mix(textureCube(vUV0 + vec2(0., 5120. + offsetZ), 0.),\n                        textureCube(vUV1 + vec2(0., 5120. + offsetZ), 0.), fract(vp5c.y + 0.5));\n    vec4 vSample = (dirSqr.x*vSampleX + dirSqr.y*vSampleY + dirSqr.z*vSampleZ)*\n                   clamp(1. - DFBox(vp5*0.5 - 0.5, vec3(39., 15., 15.)), 0., 1.);\n    return vSample + textureCube(clamp(vp5.xz + vec2(29., 49.), vec2(1.), vec2(127.)) + vec2(512., 5120.), 1.)*\n           clamp(1. - DFBox(vp5 - vec3(-29., 0.05, -49.), vec3(128., 0., 128.))*0.5, 0., 1.)*fwd*(1. - vSample.w);\n}\n\nvec4 vct_sample2(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd) {\n    //Samples VCT volume - LOD 2\n    vec3 vp5c = clamp(vp5*0.25, vec3(0.5), vec3(19.5, 7.5, 7.5));\n    vec2 vUV0 = vec2(vp5c.x + floor(vp5c.y - 0.5)*20., vp5c.z);\n    vec2 vUV1 = vec2(vp5c.x + floor(vp5c.y + 0.5)*20., vp5c.z);\n    float offsetX = max(0., -sign(dir.x)*96.);\n    vec4 vSampleX = mix(textureCube(vUV0 + vec2(0., 5168. + offsetX), 0.),\n                        textureCube(vUV1 + vec2(0., 5168. + offsetX), 0.), fract(vp5c.y + 0.5));\n    float offsetY = max(0., -sign(dir.y)*96.);\n    vec4 vSampleY = mix(textureCube(vUV0 + vec2(0., 5168. + offsetY), 0.),\n                        textureCube(vUV1 + vec2(0., 5168. + offsetY), 0.), fract(vp5c.y + 0.5));\n    float offsetZ = max(0., -sign(dir.z)*96.);\n    vec4 vSampleZ = mix(textureCube(vUV0 + vec2(0., 5168. + offsetZ), 0.),\n                        textureCube(vUV1 + vec2(0., 5168. + offsetZ), 0.), fract(vp5c.y + 0.5));\n    vec4 vSample = (dirSqr.x*vSampleX + dirSqr.y*vSampleY + dirSqr.z*vSampleZ)*\n                   clamp(1. - DFBox(vp5*0.25 - 0.5, vec3(19., 7., 7.)), 0., 1.);\n    return vSample + textureCube(clamp(vp5.xz + vec2(29., 49.), vec2(2.), vec2(126.)) + vec2(512., 5120.), 2.)*\n           clamp(1. - DFBox(vp5 - vec3(-29., 0.05, -49.), vec3(128., 0., 128.))*0.25, 0., 1.)*fwd*(1. - vSample.w);\n}\n\nvec4 vct_sample3(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd) {\n    //Samples VCT volume - LOD 3\n    vec3 vp5c = clamp(vp5*0.125, vec3(0.5), vec3(9.5, 3.5, 3.5));\n    vec2 vUV0 = vec2(vp5c.x + floor(vp5c.y - 0.5)*10., vp5c.z);\n    vec2 vUV1 = vec2(vp5c.x + floor(vp5c.y + 0.5)*10., vp5c.z);\n    float offsetX = max(0., -sign(dir.x)*96.);\n    vec4 vSampleX = mix(textureCube(vUV0 + vec2(0., 5176. + offsetX), 0.),\n                        textureCube(vUV1 + vec2(0., 5176. + offsetX), 0.), fract(vp5c.y + 0.5));\n    float offsetY = max(0., -sign(dir.y)*96.);\n    vec4 vSampleY = mix(textureCube(vUV0 + vec2(0., 5176. + offsetY), 0.),\n                        textureCube(vUV1 + vec2(0., 5176. + offsetY), 0.), fract(vp5c.y + 0.5));\n    float offsetZ = max(0., -sign(dir.z)*96.);\n    vec4 vSampleZ = mix(textureCube(vUV0 + vec2(0., 5176. + offsetZ), 0.),\n                        textureCube(vUV1 + vec2(0., 5176. + offsetZ), 0.), fract(vp5c.y + 0.5));\n    vec4 vSample = (dirSqr.x*vSampleX + dirSqr.y*vSampleY + dirSqr.z*vSampleZ)*\n                   clamp(1. - DFBox(vp5*0.125 - 0.5, vec3(9., 3., 3.)), 0., 1.);\n    return vSample + textureCube(clamp(vp5.xz + vec2(29., 49.), vec2(4.), vec2(124.)) + vec2(512., 5120.), 3.)*\n           clamp(1. - DFBox(vp5 - vec3(-29., 0.05, -49.), vec3(128., 0., 128.))*0.125, 0., 1.)*fwd*(1. - vSample.w);\n}\n\nvec4 vct_sample4(vec3 vp5, vec3 dir, vec3 dirSqr, float fwd) {\n    //Samples VCT volume - LOD 4\n    vec3 vp5c = clamp(vp5*I16, vec3(0.5), vec3(4.5, 1.5, 1.5));\n    vec2 vUV0 = vec2(vp5c.x + floor(vp5c.y - 0.5)*5., vp5c.z);\n    vec2 vUV1 = vec2(vp5c.x + floor(vp5c.y + 0.5)*5., vp5c.z);\n    float offsetX = max(0., -sign(dir.x)*96.);\n    vec4 vSampleX = mix(textureCube(vUV0 + vec2(0., 5180. + offsetX), 0.),\n                        textureCube(vUV1 + vec2(0., 5180. + offsetX), 0.), fract(vp5c.y + 0.5));\n    float offsetY = max(0., -sign(dir.y)*96.);\n    vec4 vSampleY = mix(textureCube(vUV0 + vec2(0., 5180. + offsetY), 0.),\n                        textureCube(vUV1 + vec2(0., 5180. + offsetY), 0.), fract(vp5c.y + 0.5));\n    float offsetZ = max(0., -sign(dir.z)*96.);\n    vec4 vSampleZ = mix(textureCube(vUV0 + vec2(0., 5180. + offsetZ), 0.),\n                        textureCube(vUV1 + vec2(0., 5180. + offsetZ), 0.), fract(vp5c.y + 0.5));\n    vec4 vSample = (dirSqr.x*vSampleX + dirSqr.y*vSampleY + dirSqr.z*vSampleZ)*\n                   clamp(1. - DFBox(vp5*I16 - 0.5, vec3(4., 1., 1.)), 0., 1.);\n    return vSample + textureCube(clamp(vp5.xz + vec2(29., 49.), vec2(8.), vec2(120.)) + vec2(512., 5120.), 4.)*\n           clamp(1. - DFBox(vp5 - vec3(-29., 0.05, -49.), vec3(128., 0., 128.))*I16, 0., 1.)*fwd*(1. - vSample.w);\n}\n\nvec3 traceCone45(vec3 pos, vec3 dir) {\n    //Traces a cone with const CR -> no LOD interpolation\n    vec4 vOUT = vec4(0.);\n    vec3 vp5, vp5c;\n    vec4 vSample = vec4(0.);\n    float floorWeightDir = -max(0., -dir.y)*dir.y;\n    vec3 dirSqr = dir*dir;\n    vp5 = pos*5. + dir*0.5;\n    vOUT = vct_sample0(vp5, dir, dirSqr, floorWeightDir);\n    vp5 += dir;\n    vOUT += vct_sample1(vp5, dir, dirSqr, floorWeightDir)*(1. - vOUT.w);\n    vp5 += dir*2.;\n    vOUT += vct_sample2(vp5, dir, dirSqr, floorWeightDir)*(1. - vOUT.w);\n    vp5 += dir*4.;\n    vOUT += vct_sample3(vp5, dir, dirSqr, floorWeightDir)*(1. - vOUT.w);\n    vp5 += dir*8.;\n    vOUT += vct_sample4(vp5, dir, dirSqr, floorWeightDir)*(1. - vOUT.w);\n    return vOUT.xyz + vec3(0.1, 0.13, 0.16)*((dir.y*0.5 + 0.5)*(1. - vOUT.w));\n}\n\nfloat vSDF(vec3 sp) {\n    //Samples a volume SDF\n    float sVal = sp.x*20.;\n    vec2 uvMod = 0.5 + sp.zy*20.;\n    vec2 uvSlice0 = vec2(floor(mod(sVal, 8.))*120., floor(sVal/8.)*128.);\n    vec4 texC = textureCube(uvMod + uvSlice0);\n    return mix(texC.x, texC.y, fract(sVal));\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = texture(iChannel3, rayDir);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    if (aDir.z > max(aDir.x, aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5 + 0.5)*1024.) + 0.5;\n        if (rayDir.z < 0.) UV.y += 1024.;\n    } else if (aDir.x > aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5 + 0.5)*1024.) + 0.5;\n        if (rayDir.x > 0.) UV.y += 2048.;\n        else UV.y += 3072.;\n    } else {\n        //Y-side\n        UV = floor(((rayDir.xz/aDir.y)*0.5 + 0.5)*1024.) + 0.5;\n        if (rayDir.y > 0.) UV.y += 4096.;\n        else UV.y += 5120.;\n    }\n    if (DFBox(UV - vec2(512., 5120.), vec2(128.)) < 0.) {\n        //VCT - floor voxels\n        vec2 vUV = vec2(UV.x - 512., UV.y - 5120.);\n        Output = vec4(0., 0., 0., 1.);\n        vec3 vPos = vec3(vUV.x - 29., 0., vUV.y - 49.)*0.2;\n        vec3 planep = vPos - vec3(-5., 0., 3.);\n        if (DFBox(vec2(planep.x + planep.z, planep.x - planep.z)*0.707, vec2(16.)) < 0.) {\n            //Inside -> sample shadow map\n            vec3 smPos = vPos - SUN_TARGET;\n            float spotWeight = pow(max(0., (dot(normalize(smPos - SUN_DIR*32.), -SUN_DIR) - 1. + 0.01)/0.01), 2.);\n            vec2 smUV = vec2(dot(smPos, SUN_TAN)/(SUN_SM_SIZE*ASPECT.x)*0.5 + 0.5, dot(smPos, SUN_BIT)/SUN_SM_SIZE*0.5 + 0.5);\n            if (DFBox(smUV, vec2(1.)) < 0.) {\n                //Inside shadow map\n                float smDepth = texture(iChannel2, smUV).x;\n                if (smDepth > dot(vPos - SUN_TARGET - SUN_DIR*32., -SUN_DIR)) {\n                    Output.xyz += vec3(2.*spotWeight);\n                }\n            } else {\n                //Outside\n                Output.xyz += vec3(2.*spotWeight);\n            }\n            \n            //Emissive\n            //Output.xyz += clamp((0.6 - length(vPos.xz - vec2(7., 3.)))*5., 0., 1.)\n            //              *vec3(1.2, 3.5, 0.7);\n        }\n    } else if (UV.y > 4480. && UV.y < 4480. + 96.*6. && UV.x < 960.) {\n        //VCT - isotropic LOD 0\n        vec2 vUV = vec2(UV.x, UV.y - 4480.);\n        vec2 modUV = vec2(vUV.x, mod(vUV.y, 96.));\n        vec3 vPos = vec3(mod(vUV.x, 80.), floor(modUV.x/80.) + floor(modUV.y/32.)*12. + 0.5, mod(modUV.y, 32.))*0.2;\n        float vWeight = clamp(-vSDF(vPos)*10. + 0.5, 0., 1.)*float(DFBox(vPos, vec3(13., 0.4*16., 6.)) < 0.);\n        if (iFrame < 4) Output = vec4(0.);\n        vec3 vLight = vec3(0.);\n        if (vWeight > 0.) {\n            //Shadow map\n            vec3 smPos = vPos - SUN_TARGET;\n            float spotWeight = pow(max(0., (dot(normalize(smPos - SUN_DIR*32.), -SUN_DIR) - 1. + 0.01)/0.01), 2.);\n            vec2 smUV = vec2(dot(smPos, SUN_TAN)/(SUN_SM_SIZE*ASPECT.x)*0.5 + 0.5, dot(smPos, SUN_BIT)/SUN_SM_SIZE*0.5 + 0.5);\n            if (DFBox(smUV, vec2(1.)) < 0.) {\n                //Inside shadow map\n                float smDepth = texture(iChannel2, smUV).x;\n                if (smDepth + 0.3 > dot(vPos - SUN_TARGET - SUN_DIR*32., -SUN_DIR)) {\n                    vLight += vec3(2.*spotWeight);\n                }\n            }\n            \n            //Diffuse indirect (just bruteforce 5 cones)\n            vec3 vNor = normalize(vec3(vSDF(vPos + epsv.xyy) - vSDF(vPos - epsv.xyy),\n                                       vSDF(vPos + epsv.yxy) - vSDF(vPos - epsv.yxy),\n                                       vSDF(vPos + epsv.yyx) - vSDF(vPos - epsv.yyx)));\n            mat3 vMat = TBN(vNor);\n            vLight += (max(vec3(0.), traceCone45(vPos + vNor*0.2, vNor).xyz) + (\n                       max(vec3(0.), traceCone45(vPos + vNor*0.2, vec3(0.707, 0., 0.707)*vMat).xyz) +\n                       max(vec3(0.), traceCone45(vPos + vNor*0.2, vec3(-0.707, 0., 0.707)*vMat).xyz) +\n                       max(vec3(0.), traceCone45(vPos + vNor*0.2, vec3(0., 0.707, 0.707)*vMat).xyz) +\n                       max(vec3(0.), traceCone45(vPos + vNor*0.2, vec3(0., -0.707, 0.707)*vMat).xyz))*0.707)*0.2;\n        }\n        \n        //Emissive\n        vec3 symPos = vec3(vPos.xy, 3. + abs(vPos.z - 3.));\n        if (DFBox(symPos - vec3(11.81, 1.5, 4.), vec3(1., 0.95, 1.)) < 0.) {\n            vLight = vec3(3., 1.5, 0.5);\n        }\n        if (min(DFBox(symPos - vec3(2., 2.2, 4.81), vec3(2., 0.95, 0.2)),\n                DFBox(symPos - vec3(0.99, 2.2, 3.05), vec3(0.2, 0.95, 3.))) < 0.) {\n            vLight = vec3(3., 0.25, 0.25);\n        }\n        \n        //Weight\n        Output = vec4(vLight*vWeight, vWeight);\n    } else if (DFBox(UV - vec2(0., 5120.), vec2(245., 96.*6.)) < 0.) {\n        //VCT - anisotropic LOD\n        Output = vec4(0.);\n        vec2 vUV = vec2(UV.x, UV.y - 5120.);\n        vec2 mUV = vec2(vUV.x, mod(vUV.y, 96.));\n        float uvWidth, uvYSize;\n        vec2 lastUV;\n        vec2 uvTan, uvBit, uvNor;\n        if (vUV.y < 192.) {\n            //X\n            uvTan = vec2(80., 0.);\n            uvBit = vec2(0., 1.);\n            uvNor = vec2(1., 0.);\n        } else if (vUV.y < 384.) {\n            //Y\n            uvTan = vec2(1., 0.);\n            uvBit = vec2(0., 1.);\n            uvNor = vec2(80., 0.);\n        } else {\n            //Z\n            uvTan = vec2(1., 0.);\n            uvBit = vec2(80., 0.);\n            uvNor = vec2(0., 1.);\n        }\n        float uvYOffset = floor(vUV.y/96.)*96.;\n        if (mod(vUV.y, 192.) > 96.) {\n            //Integrating in negative direction\n            uvNor *= -1.;\n        }\n        //LOD attributes\n        if (DFBox(mUV, vec2(240., 48.)) < 0.) {\n            //LOD 1\n            lastUV = floor(mUV)*2. + vec2(0.5 + floor(mUV.x/40.)*80. + max(0., -uvNor.x), 0.5);\n            lastUV = vec2(mod(lastUV.x, 960.), lastUV.y + floor(lastUV.x/960.)*32. + 4480. + uvYOffset);\n            uvWidth = 960.;\n            uvYSize = 32.;\n        } else if (DFBox(vec2(mUV.x, mUV.y - 48.), vec2(160., 8.)) < 0.) {\n            //LOD 2\n            uvNor.x = sign(uvNor.x)*min(abs(uvNor.x), 40.);\n            uvTan.x = min(uvTan.x, 40.);\n            uvBit.x = min(uvBit.x, 40.);\n            mUV.y -= 48.;\n            lastUV = floor(mUV)*2. + vec2(0.5 + floor(mUV.x/20.)*40. + max(0., -uvNor.x), 0.5);\n            lastUV = vec2(mod(lastUV.x, 240.), lastUV.y + floor(lastUV.x/240.)*16. + 5120. + uvYOffset);\n            uvWidth = 240.;\n            uvYSize = 16.;\n        } else if (DFBox(vec2(mUV.x, mUV.y - 56.), vec2(40., 4.)) < 0.) {\n            //LOD 3\n            uvNor.x = sign(uvNor.x)*min(abs(uvNor.x), 20.);\n            uvTan.x = min(uvTan.x, 20.);\n            uvBit.x = min(uvBit.x, 20.);\n            mUV.y -= 56.;\n            lastUV = floor(mUV)*2. + vec2(0.5 + floor(mUV.x/10.)*20. + max(0., -uvNor.x), 5168.5 + uvYOffset);\n            uvWidth = 10000.; //IGNORE -> No x-modulus\n            uvYSize = 0.; //IGNORE -> No y-layers\n        } else if (DFBox(vec2(mUV.x, mUV.y - 60.), vec2(10., 2.)) < 0.) {\n            //LOD 4\n            uvNor.x = sign(uvNor.x)*min(abs(uvNor.x), 10.);\n            uvTan.x = min(uvTan.x, 10.);\n            uvBit.x = min(uvBit.x, 10.);\n            mUV.y -= 60.;\n            lastUV = floor(mUV)*2. + vec2(0.5 + floor(mUV.x/5.)*10. + max(0., -uvNor.x), 5176.5 + uvYOffset);\n        }\n        //Integrate\n        vec2 suv = lastUV;\n        vec4 firstVoxel = textureCube(suv);\n        Output += firstVoxel + textureCube(suv + uvNor)*(1. - firstVoxel.w);\n        suv += uvTan;\n        firstVoxel = textureCube(suv);\n        Output += firstVoxel + textureCube(suv + uvNor)*(1. - firstVoxel.w);\n        suv += uvBit;\n        firstVoxel = textureCube(suv);\n        Output += firstVoxel + textureCube(suv + uvNor)*(1. - firstVoxel.w);\n        suv = lastUV + uvBit;\n        firstVoxel = textureCube(suv);\n        Output += firstVoxel + textureCube(suv + uvNor)*(1. - firstVoxel.w);\n        Output *= 0.25;\n    } else if (UV.x < 960. && UV.y < 4480.) {\n        //SDF volume\n        vec3 WPos = vec3(floor(UV.x/120.)*0.05 + floor(UV.y*I128)*0.4,\n                         floor(mod(UV.y, 128.))*0.05,\n                         floor(mod(UV.x, 120.))*0.05);\n        if (iFrame <= 1) {\n            //Initial frame\n            Output = vec4(1000.);\n        } else if (iFrame <= 8) {\n            //Building frames\n            for (int brick_index = (iFrame - 2)*16; brick_index < min((iFrame - 1)*16, 99); brick_index++) {\n                //For each new index\n                BRICK CBrick = Bricks[brick_index];\n                vec4 CBrick0 = vec4(CBrick.P, 0.);\n                vec4 CBrick1 = CBrick.Q;\n                vec3 CX = CBrick1.xyz;\n                vec2 sincos = vec2(sin(CBrick1.w), cos(CBrick1.w));\n                vec3 RefCZ = normalize(cross(CX, vec3(0., 1., 0.)));\n                vec3 RefCY = cross(RefCZ, CX);\n                vec3 CY = sincos.y*RefCY + sincos.x*RefCZ;\n                vec3 CZ = -sincos.x*RefCY + sincos.y*RefCZ;\n                vec3 CXT = vec3(CX.x, CY.x, CZ.x);\n                vec3 CYT = vec3(CX.y, CY.y, CZ.y);\n                vec3 CZT = vec3(CX.z, CY.z, CZ.z);\n                //New sample position\n                vec3 VPos = (WPos.x - CBrick.P.x)*CXT + (WPos.y - CBrick.P.y)*CYT + (WPos.z - CBrick.P.z)*CZT;\n                if (CBrick.I == 0) {\n                    //OnlySlope\n                    Output.x = min(Output.x, DFOnlySlope(VPos));\n                } else if (CBrick.I == 1) {\n                    //Round111\n                    Output.x = min(Output.x, DFRound111(VPos));\n                } else if (CBrick.I == 2) {\n                    //Round131\n                    Output.x = min(Output.x, DFRound131(VPos));\n                } else if (CBrick.I == 3) {\n                    //Brick111\n                    Output.x = min(Output.x, DFBrick(VPos, vec3(1., 0.8, 1.)));\n                } else if (CBrick.I == 4) {\n                    //Grate\n                    Output.x = min(Output.x, DFGrate(VPos));\n                } else if (CBrick.I == 5) {\n                    //Brick411\n                    Output.x = min(Output.x, DFBrick(VPos, vec3(4., 0.8, 1.))); //Brick skapar weird lines\n                } else if (CBrick.I == 6) {\n                    //Brick412\n                    Output.x = min(Output.x, DFBrick(VPos, vec3(4., 0.8, 2.)));\n                } else if (CBrick.I == 7) {\n                    //HeadLight\n                    Output.x = min(Output.x, DFHeadLight(VPos));\n                } else if (CBrick.I == 8) {\n                    //Inverse Slope\n                    Output.x = min(Output.x, DFISlope(VPos, 1.));\n                } else if (CBrick.I == 9) {\n                    //Grip\n                    Output.x = min(Output.x, DFGrip(VPos));\n                } else if (CBrick.I == 10) {\n                    //Handle\n                    Output.x = min(Output.x, DFHandle(VPos, 0.));\n                } else if (CBrick.I == 11) {\n                    //Brick211\n                    Output.x = min(Output.x, DFBrick(VPos, vec3(2., 0.8, 1.)));\n                } else if (CBrick.I == 12) {\n                    //Tire\n                    float tmpCylDF = length(VPos.xy - vec2(1.));\n                    float DF = max(VPos.z - 0.88461538461, max(0.11538461539 - VPos.z, tmpCylDF - 0.9));\n                    vec3 rp = VPos-vec3(1., 1., 0.); rp.xy = Repeat(rp.xy, 16.);\n                    DF = -smin(-DF, DFBox(rp - vec3(-0.1282, 0.771795, -2.), vec3(0.1282, 2., 2.46)) - 0.02, 0.05);\n                    rp = VPos - vec3(1., 1., 0.); rp.xy = Rotate(rp.xy, 0.19634954); rp.xy = Repeat(rp.xy, 16.);\n                    DF = -smin(-DF, DFBox(rp - vec3(-0.1282, 0.771795, 0.54), vec3(0.1282, 2., 5.)) - 0.02, 0.05);\n                    DF = -smin(-DF, tmpCylDF - 0.51282, 0.1);\n                    //Output\n                    Output.x = min(Output.x, DF);\n                } else if (CBrick.I == 13) {\n                    //Tire Center\n                    float tmpCylDF = length(VPos.xy-vec2(1.));\n                    float DF = max(VPos.z-0.88461538461,max(0.11538461539-VPos.z,tmpCylDF-0.51282));\n                        DF = -smin(-DF,length(VPos-vec3(1.,1.,-0.1))-0.45,0.05);\n                        DF = -smin(-DF,tmpCylDF-0.26,0.05);\n                    DF = smin(DF,max(VPos.z-0.3,max(0.11538461539-VPos.z,tmpCylDF-0.192)),0.05);\n                        DF = smin(DF,DFBox(VPos-vec3(0.9359,0.5,0.13),vec3(0.1282,0.87,0.1282)),0.05);\n                        DF = smin(DF,DFBox(VPos-vec3(0.5,0.9359,0.13),vec3(0.87,0.1282,0.1282)),0.05);\n                    //Output\n                    Output.x = min(Output.x, DF);\n                } else if (CBrick.I == 14) {\n                    //Steering Wheel\n                    float tmpCylDF = max(length(VPos.xz-vec2(1.)), -VPos.y);\n                    float DF = max(VPos.y-0.6,max(0.001-VPos.z,tmpCylDF-0.38461538461));\n                    DF = min(DF,length(vec2(length(VPos.xz-vec2(1.))-0.87179,VPos.y-0.6))-0.141);\n                    vec3 rp = VPos-vec3(1.,0.6,1.); rp.xz = Repeat(rp.xz,3.);\n                    DF = min(DF,DFBox(rp-vec3(-0.16,-0.1,0.),vec3(0.32,0.1,0.87179)));\n                    rp = VPos-vec3(1.,0.6,1.); rp.xz = Rotate(rp.xz,1.0471975512); rp.xz = Repeat(rp.xz,3.);\n                    DF = max(DF,-DFBox(rp-vec3(-0.2,-0.3,0.3),vec3(0.4,1.,0.3)));\n                    DF = max(DF,-tmpCylDF+0.1923);\n                    //Output\n                    Output.x = min(Output.x, DF);\n                } else if (CBrick.I == 15) {\n                    //Lever Base (no interior)\n                    float tmpCylDF = length(VPos.xz-vec2(0.5));\n                    float DF = min(max(max(tmpCylDF-0.397, VPos.y-0.25), -VPos.y),length(VPos-vec3(0.5,0.25,0.5))-0.397);\n                    DF = max(DF,-DFBox(VPos-vec3(-1.,0.3,0.4),vec3(4.,4.,0.2)));\n                    //Output\n                    Output.x = min(Output.x, DF);\n                } else if (CBrick.I == 16) {\n                    //Lever\n                    float DF = DFLine(VPos,vec3(0.5,0.5,0.5),vec3(2.423,0.5,0.5))-0.096;\n                    DF = min(DF,max(max(length(VPos.xy-0.5)-0.2564,0.4-VPos.z),VPos.z-0.6));\n                    DF = min(DF,length(VPos-vec3(2.423,0.5,0.5))-0.16);\n                    //Output\n                    Output.x = min(Output.x, DF);\n                } else if (CBrick.I == 17) {\n                    //Rotating Brick Base\n                    float DF = DFBox(VPos-vec3(0.04),vec3(1.92,1.12,0.92))-0.04;\n                    DF = -smin(-DF,DFBox(VPos-vec3(0.1,0.2,0.1),vec3(1.8,2.,2.)),0.05);\n                        DF = -smin(-DF,DFBox(VPos-vec3(-1.,0.6,0.2),vec3(5.,2.,2.)),0.05);\n                    DF = smin(DF,DFBox(VPos-vec3(0.1,0.2,0.1),vec3(1.8,0.2,0.8)),0.05);\n                    DF = smin(DF,DFBox(VPos-vec3(0.9,0.4,0.1),vec3(0.2,0.3,0.8)),0.05);\n                    Output.x = min(Output.x, DF);\n                } else if (CBrick.I == 18) {\n                    //Rotating Brick Piece\n                    float DF = DFBox(VPos-vec3(0.04,1.04,0.04),vec3(1.92,0.12,0.92))-0.04;\n                    DF = min(DF,DFBox(VPos-vec3(0.1,0.4,0.55),vec3(1.8,0.7,0.1)));\n                    DF = min(DF,DFBox(VPos-vec3(0.1,0.4,0.1),vec3(0.1,0.7,0.75)));\n                        DF = min(DF,DFBox(VPos-vec3(1.8,0.4,0.1),vec3(0.1,0.7,0.75)));\n                    Output.x = min(Output.x, DF);\n                } else if (CBrick.I == 19) {\n                    //Long Handle\n                    float DF = DFBrick(VPos,vec3(2.,0.8,1.));\n                    vec3 syp = vec3(VPos.xy,abs(VPos.z-0.5));\n                    float tmpCyl = length(VPos.xy-vec2(2.5,0.3));\n                    DF = min(DF,DFBox(syp-vec3(0.04,0.04,0.24),vec3(2.46,0.32,0.22))-0.04);\n                    DF = min(DF,-smin(smin(-tmpCyl+0.3,0.5-syp.z,0.04),syp.z-0.2,0.04));\n                    DF = min(DF,max(max(tmpCyl-0.2,0.05-VPos.z),VPos.z-0.95));\n                    //Output\n                    Output.x = min(Output.x, DF);\n                } else if (CBrick.I == 20) {\n                    //Studgrip\n                    float DF = DFBrick(VPos,vec3(1.,0.8,1.));\n                    DF = smin(DF,DFBox(VPos-vec3(1.,0.,0.244),vec3(0.5,0.4,0.512)),0.05);\n                    float tmpCyl = length(VPos.xy-vec2(1.5,0.35));\n                    DF = min(DF,max(max(tmpCyl-0.4,0.244-VPos.z),VPos.z-0.756));\n                    DF = min(DF,max(max(tmpCyl-0.3,0.01-VPos.z),VPos.z-0.99));\n                    DF = -smin(-DF,tmpCyl-0.2,0.05);\n                    Output.x = min(Output.x, DF);\n                } else if (CBrick.I == 21) {\n                    //Vertical Grip\n                    float DF = DFBox(VPos-vec3(0.04),vec3(0.92,0.32,0.92))-0.04;\n                    DF = min(DF,max(max(DFLine(VPos,vec3(0.5,-1.,0.5),vec3(0.5,0.6,0.5))-0.5,0.307-VPos.z),VPos.z-0.692));\n                    DF = max(DF,-length(VPos.xy-vec2(0.5,0.6923))+0.1923);\n                    DF = -smin(-DF,-VPos.y+0.9,0.2);\n                    DF = max(DF,-DFBox(VPos-vec3(0.35,0.6,-1.),vec3(0.3,5.,4.)));\n                    Output.x = min(Output.x, DF);\n                }\n            }\n        }\n        vec2 NextUV = 0.5 + WPos.zy*20. + vec2(floor(mod(WPos.x*20. + 1.5, 8.))*120., floor((WPos.x*20. + 1.5)/8.)*128.);\n        Output.y = textureCube(NextUV).x;\n    }\n    //Output\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"}]}