{"ver":"0.1","info":{"id":"MtSyRt","date":"1509709764","viewed":345,"name":"Star polygon SDF","username":"BasmanovDaniil","description":"Star polygon SDF","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","sdf","star","distance","polygon","regular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat StarPolygon(vec2 p, float vertices, float radius, float offset)\n{\n    float segmentAngle = TWO_PI/vertices;\n    float halfSegmentAngle = segmentAngle*0.5;\n\n    float angleRadians = atan(p.x, p.y);\n    float repeat = abs(fract(angleRadians/segmentAngle - 0.5) - 0.5)*segmentAngle;\n    float circle = length(p);\n    float x = sin(repeat)*circle;\n    float y = cos(repeat)*circle - radius;\n    float uvRotation = halfSegmentAngle + offset;\n    vec2 uv = cos(uvRotation)*vec2(x, y) + sin(uvRotation)*vec2(-y, x);\n    \n    float corner = radius*sin(halfSegmentAngle)/cos(offset);\n    float inside = -length(vec2(max(uv.x - corner, 0.0), uv.y))*step(0.0, -uv.y);\n    float outside = length(vec2(min(uv.x, 0.0), uv.y))*step(0.0, uv.y);\n    \n    return inside + outside;\n}\n\nfloat StarPolygonCheap(vec2 p, float vertices, float radius, float offset)\n{\n    float segmentAngle = TWO_PI/vertices;\n    float halfSegmentAngle = segmentAngle*0.5;\n\n    float angleRadians = atan(p.x, p.y);\n    float repeat = abs(fract(angleRadians/segmentAngle - 0.5) - 0.5)*segmentAngle;\n    float circle = length(p);\n    float x = sin(repeat)*circle;\n    float y = cos(repeat)*circle - radius;\n    float uvRotation = halfSegmentAngle + offset;\n    y = cos(uvRotation)*y + sin(uvRotation)*x;\n    return y;\n}\n\nfloat TriangularWave(float x)\n{\n    return 2.0*abs(fract(x + 0.5) - 0.5);\n}\n\nfloat EaseInOutExpo(float t)\n{\n    if (t < 0.5)\n    {\n        return 0.5*pow(2.0, 20.0*t - 10.0);\n    }\n    return -0.5*pow(2.0, -20.0*t + 10.0) + 1.0;\n}\n\nvec2 RotateCW(vec2 v, float radians)\n{\n    return cos(radians)*v + sin(radians)*vec2(-v.y, v.x);\n}\n\nfloat DebugValuePattern(float value, float offset, float aa)\n{\n    value = fract(value);\n    return smoothstep(offset, offset + aa, value)*smoothstep(1.0 - offset, 1.0 - offset - aa, value);\n}\n\nfloat DebugValuePattern(float value)\n{\n    float aa = 0.005;\n    float pattern1 = DebugValuePattern(value, aa, aa);\n    float pattern2 = DebugValuePattern(value*2.0, aa*0.5, aa*2.0);\n    float pattern10 = DebugValuePattern(value*10.0, -aa*10.0, aa*20.0);\n    float pattern50 = DebugValuePattern(value*50.0, -aa*50.0, aa*100.0);\n    return pattern1*pattern2*pattern10*pattern50;\n}\n\nvec4 DebugValueColor(float value)\n{\n    float offset = sign(value)*0.3;\n    vec4 nearColor = vec4(0.4 + offset, 0.35, 0.4 - offset, 1.0);\n    vec4 farColor = vec4(0.55 + offset, 0.65, 0.55 - offset, 1.0);\n    return mix(nearColor, farColor, clamp(abs(value*10.0), 0.0, 1.0));\n}\n\nvec4 DebugValue(float value)\n{\n    return DebugValuePattern(value)*DebugValueColor(value);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy - vec2(0.5, 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime*0.2;\n    uv = RotateCW(uv, EaseInOutExpo(TriangularWave(time*0.5))*TWO_PI);\n    \n    float vertices = mix(5.0, 10.0, EaseInOutExpo(TriangularWave(time)));\n    float radius = 0.4;\n    float offset = PI/vertices;\n    float d = StarPolygon(uv, vertices, radius, offset);\n    \n\tfragColor = DebugValue(d);\n}","name":"Image","description":"","type":"image"}]}