{"ver":"0.1","info":{"id":"fldcR2","date":"1660380748","viewed":94,"name":"Mandelbrot Set (Vynokris)","username":"Vynokris","description":"The fractal created from the mandelbrot set.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Click on the image to be able to send inputs to the program.\n// Use WASD to move and QE to scale the fractal.\n// Use the left and right arrows to change the background color.\n// Use the up and down arrows to change the edge color.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // The point at which a pixel becomes black.\n    float escapeRadius = 2.0;\n    float escapeRadSq  = escapeRadius * escapeRadius;\n\n    // World coordinates (c).\n    vec3  offset = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    float scale  = pow(2.0, offset.z);\n    vec2  c      = (fragCoord - iResolution.xy / 2.0) / (0.5 * scale * iResolution.y) + offset.xy / scale + vec2(-0.125, 0.0);\n\n    // z = 0; z2 = z * z\n    vec2 z  = vec2(0.0, 0.0);\n    vec2 z2 = z;\n    float zPower = texelFetch(iChannel0, ivec2(1, 0), 0).z;\n\n    // Chose the rotation at which to render the mandelbrot set.\n    vec2 rot = vec2(pi / 4.0, 0.0);\n\n    // Compute the mandelbrot equation.\n    int i, iMax = 500;\n    for (i = 0; i < iMax && (z2.x + z2.y < escapeRadSq); i++)\n    {\n        z  = complexSum(complexProd(z2, rot), c);\n        z2 = complexSquare(z);\n    };\n\n    // Define gradient colors.\n    vec2 customHue = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec4 startHSV  = vec4(0.0,         0.0, 1.0, 1.0); // Black.\n    vec4 middleHSV = vec4(customHue.x, 1.0, 1.0, 1.0); // Custom color.\n    vec4 endHSV    = vec4(customHue.y, 1.0, 0.0, 1.0); // White with custom hue.\n    vec4 centerRGB = vec4(0.0,         0.0, 0.0, 0.0); // Black.\n\n    // Color the pixel in function of the number of iterations.\n    if (i >= iMax)\n    {\n        fragColor = centerRGB;                       \n    }\n    else\n    {\n        float lerpVal = 1.0 - float(i) / float(iMax);\n        if (lerpVal < 0.5)\n            fragColor = HSVtoRGB(mix(startHSV, middleHSV, lerpVal * 2.0));\n        else\n            fragColor = HSVtoRGB(mix(middleHSV, endHSV, lerpVal * 2.0 - 1.0));\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_W    = 87, KEY_S  = 83, KEY_A     = 65, KEY_D    = 68, KEY_Q = 81, KEY_E = 69;\nconst int KEY_LEFT = 37, KEY_UP = 38, KEY_RIGHT = 39, KEY_DOWN = 40;\n\nvoid updateOffset(inout vec2 offset) \n{\n    // Define the movement speed.\n    float moveSpeed = 0.01;\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x returns 1 if key is pressed, 0 if not pressed.\n    vec2 up    = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x * vec2( 0,  1);\n    vec2 down  = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec2( 0, -1);\n    vec2 left  = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec2(-1,  0);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec2( 1,  0);\n    offset += (up + down + left + right) * moveSpeed;\n}\n\nvoid updateScale(inout float scale, inout vec2 offset)\n{\n    // Define the scaling speed.\n    float scaleSpeed = 0.01;\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x returns 1 if key is pressed, 0 if not pressed.\n    float up    = texelFetch(iChannel1, ivec2(KEY_E, 0), 0).x;\n    float down  = texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).x * -1.0;\n    \n    float prevScale = scale;\n    scale  += (up + down) * scaleSpeed;\n    offset *= pow(2.0, scale) / pow(2.0, prevScale);\n}\n\nvoid updateHue(inout vec2 hue)\n{\n    // Define the modification speed.\n    float modifSpeed = 0.01;\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x returns 1 if key is pressed, 0 if not pressed.\n    vec2 up1   = texelFetch(iChannel1, ivec2(KEY_UP,    0), 0).x * vec2( 1,  0);\n    vec2 down1 = texelFetch(iChannel1, ivec2(KEY_DOWN,  0), 0).x * vec2(-1,  0);\n    vec2 up2   = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2( 0,  1);\n    vec2 down2 = texelFetch(iChannel1, ivec2(KEY_LEFT,  0), 0).x * vec2( 0, -1);\n    hue += (up1 + down1 + up2 + down2) * modifSpeed;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the values from the previous frame (zero if it's first frame).\n    bool  start  = texelFetch(iChannel0, ivec2(0, 0), 0).w < 1.0;\n    vec2  offset = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float scale  = texelFetch(iChannel0, ivec2(0, 0), 0).z;\n    vec2  hue    = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    \n    // Listen to keyboard input and update the values accordingly.\n    updateOffset(offset       );\n    updateScale (scale, offset);\n    updateHue   (hue          );\n    \n    // Modify values if this is the first frame.\n    if (start) {\n        hue    = vec2(2.26893, 3.14159);\n        offset = vec2(-0.4, 0.0);\n        scale  = -0.1;\n    }\n\n    // Store offset in (0, 0).xy, scale in (0, 0).z, and hue in (1, 0).xy.\n    fragColor = (ivec2(fragCoord) == ivec2(0, 0)) ? vec4(offset, scale, 1.0) : fragColor;\n    fragColor = (ivec2(fragCoord) == ivec2(1, 0)) ? vec4(hue,    0.0,   0.0) : fragColor;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"precision highp float;\n#define pi 3.14159265358979323846264\n\n// Returns the sum of the two given complex numbers.\nvec2 complexSum(const vec2 c1, const vec2 c2) {\n    return vec2(c1.x + c2.x, c1.y + c2.y);\n}\n\n// Returns the substraction of the first given complex number by the second.\nvec2 complexSub(const vec2 c1, const vec2 c2) {\n    return vec2(c1.x + c2.x, c1.y + c2.y);\n}\n\n// Returns the product of the two given complex numbers.\nvec2 complexProd(const vec2 c1, const vec2 c2) {\n    return vec2(c1.x*c2.x - c1.y*c2.y, c1.x*c2.y + c1.y*c2.x);\n}\n\n// Returns the division of the first given complex number by the second.\nvec2 complexDiv(const vec2 c1, const vec2 c2) {\n    float c2x2 = c2.x * c2.x, c2y2 = c2.y * c2.y;\n    return vec2((c1.x*c2.x + c1.y*c2.y) / (c2x2 + c2y2), (c1.y*c2.x - c1.x*c2.y) / (c2x2 + c2y2));\n}\n\n// Returns the square of the given complex number.\nvec2 complexSquare(const vec2 c) {\n    return vec2(c.x * c.x - c.y * c.y, 2.0 * c.x * c.y);\n}\n\n// Returns the absolute value of the given complex number.\nfloat complexAbs(const vec2 c) {\n    return sqrt(c.x * c.x + c.y * c.y);\n}\n\n// Returns the argument (theta) of the given complex number.\nfloat complexArg(const vec2 c) {\n    return atan(c.y / c.x);\n}\n\n// Returns the nth power of the given complex.\nvec2 complexPow(const vec2 c, const float n) {\n    float rn = pow(complexAbs(c), n);\n    float on = complexArg(c) * n;\n    return vec2(cos(on), sin(on)) * rn;\n}\n\n// Returns the square root of the given complex number.\nvec2 complexSqrt(const vec2 c) {\n    float tmp = sqrt((complexAbs(c) + c.x) / 2.0);\n    return vec2(tmp, (c.y / abs(c.y)) * tmp);\n}\n\n// Returns the exponential of the given complex number.\nvec2 complexExp(const vec2 c) {\n    return exp(c.x) * vec2(cos(c.y), sin(c.y));\n}\n\n// Returns the natural logarithm of the given complex number.\nvec2 complexLn(const vec2 c) {\n    return vec2(log(complexAbs(c)), complexArg(c));\n}\n\n// Returns the cosine of the given complex number.\nvec2 complexCos(const vec2 c) {\n    return vec2(cos(c.x) + sinh(c.y), sin(c.x) + cosh(c.y));\n}\n\n// Returns the sine of the given complex number.\nvec2 complexSin(const vec2 c) {\n    return vec2(sin(c.x) + cosh(c.y), cos(c.x) + sinh(c.y));\n}\n\n// Returns the tangent of the given complex number.\nvec2 complexTan(const vec2 c) {\n    float tanX  = tan (c.x),   tanY   = tan (c.y);\n    float tanhX = tanh(c.x),   tanhY  = tanh(c.y);\n    float tanX2 = tanX * tanX, tanhY2 = tanhY * tanhY;\n    return vec2((tanX-tanX*tanhY2) / (1.0+tanX2*tanhY2), (tanhY+tanX2*tanhY) / (1.0+tanX2*tanhY2));\n}\n\n// Function used only in HSVtoRGB to convert from hsv to rgb.\nfloat ColorConversion(const vec4 hsv, float k)\n{\n    float t = 4.0 - k;\n    k = (t < k)? t : k;\n    k = (k < 1.0)? k : 1.0;\n    k = (k > 0.0)? k : 0.0;\n    return hsv.z - hsv.z * hsv.y * k;\n}\n\n// Convert hsva color to rgba.\nvec4 HSVtoRGB(const vec4 hsv)\n{\n    vec4 color = vec4(0, 0, 0, hsv.a);\n    color.r = ColorConversion(hsv, mod((5.0 + hsv.x), 6.0));\n    color.g = ColorConversion(hsv, mod((3.0 + hsv.r), 6.0));\n    color.b = ColorConversion(hsv, mod((1.0 + hsv.r), 6.0));\n\n    return color;\n}","name":"Common","description":"","type":"common"}]}