{"ver":"0.1","info":{"id":"dlByRy","date":"1692042512","viewed":59,"name":"minutiae","username":"iyo","description":"built with IQ SDF's + BigWIngs Raymarch starting point","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nconst int MAT_OBJ = 1;\nconst int MAT_BACK = 2;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness,float bias)\n{\n    p *= scale;\n    return abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec2 GetDist(vec3 p) {\n    float a =  sin(iTime);\n    float a1 = cos(iTime);\n    float pl = p.y+.5;\n    vec3 pMod = vec3(p.x + a, p.y + a1, p.z + a1);\n    vec3 pMod1 = vec3(p.x * (a*.2), p.y + a1, p.z * (a1*.2));\n    vec3 pSin = cos(pMod);\n    float sph = sdSphere(pSin, .8);\n    float frame = sdBoxFrame(pSin, vec3(1.), .001);\n    float g1 = sdGyroid(pMod, 1.357, .03785 ,1.357);\n    float g2 = sdGyroid(pMod, 7.53, .0553 ,1.6);\n    float g = min(g1, g2);\n    float d = min(sph, cos(g));\n    d = max(d, tan(g));\n    d = min(d, frame);\n    int mat = 0;\n    if(d==frame)\n        mat = MAT_BACK;\n    \n    else if(d==tan(g) || d==cos(g) || d==sph)\n        mat = MAT_OBJ;\n        \n    \n    return vec2(d, mat);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p).x;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    //ro.yz *= Rot(-m.y*PI+1.);\n    //ro.xz *= Rot(-m.x*TAU);\n    \n    ro.yz *= Rot(2.);\n    ro.xz *= Rot(-iTime*.3);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        int mat = int(GetDist(p).y);\n        if (mat==MAT_BACK)\n            {col = vec3(n.x*.7, n.y*(iTime*4.), n. z*(12.55205*iTime));\n            col += sin(abs(dif*dif)+1.5);\n            col = sin(min(sin(dif*col), cos(dif*col))/-1.+1.);\n            col -= dif*dif*dif *r;\n            }\n        else if(mat==MAT_OBJ)\n        {\n        col = vec3(n.x+mod(iTime, .3), n.y+.3, n.z+.2);\n        col += dif*dif;\n        col = min(dif*col, col)/-1.;\n        col += dif*dif*dif*dif;\n        col = vec3(dif);\n        col = abs(vec3(n.x+(mod(iTime*6., .12)), n.y*1.1, n. z*12.55205));\n        col += abs(dif*dif)/(iTime*.4);\n        }\n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}