{"ver":"0.1","info":{"id":"7d23Ry","date":"1617612408","viewed":878,"name":"PBR Tutorial","username":"JosueFCONO","description":"This is a tutorial. I'm making it because i have my first ever graphics programmer interview in a couple of days.\nSo i'm practicing, remembering stuff and learning new things.\nI hope it helps somebody. Please correct me on anything i need it.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tutorial","shading","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///PBR Shading Tutorial (I guess)\n///This is my first time doing raymarching, i wanted to learn so i followed this: https://www.shadertoy.com/view/XlBGDW\n///It's really well explained and helped me a lot. Thanks to Daedelus and the god of shaders Inigo.\n\n///This is a tutorial. I'm making it because i have my first ever graphics programmer interview in a couple of days.\n///So i'm practicing, remembering stuff and learning new things.\n///I hope it helps somebody, if it doesn't and it's the worse ever and the community rallies against me, \n///at least i'll have brought you closer.\n\n///some useful PBR links:\n///https://www.fxguide.com/fxfeatured/game-environments-parta-remember-me-rendering/\n///https://marmoset.co/posts/basic-theory-of-physically-based-rendering/\n///https://learnopengl.com/PBR/Theory\n\n///////////\n/// RAYMARCHING FUNCTIONS (refer to: https://www.shadertoy.com/view/XlBGDW)\n///////////\n\n#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 40.0\n#define NUMBER_OF_MARCH_STEPS 100\n#define EPSILON 0.0001\n#define DISTANCE_BIAS 0.7\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n///Scene with two shapes. One returns blue color and the other one chartreuse (I love the colour and the name)\nvec4 scene(vec3 position)\n{\n    vec3 translate = vec3(-2.0, 0.0, 11.0);\n    vec3 sphere_pos = position - translate;\n    float dist = sdSphere(sphere_pos, 1.5f);\n    \n    vec3 translate2 = vec3(2.0, 0.0, 11.0);\n    vec3 sphere_pos2 = position - translate2;\n    float dist2 = sdSphere(sphere_pos2, 1.5f);\n\t\n    vec4 result = vec4(dist, 1.0f, 1.0f, 0.0f);\n    \n    if (dist2 < dist)\n    {\n        result.x = dist2;\n        result.yzw = vec3(0.0f, 0.5f, 1.0f);\n    }\n    \n    return result;\n}\n\n///Got it from the reference, he says he steals it everytime so i must follow my master's teachings.\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n}\n\n///The actual raymarch.\nvec4 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    vec4 result;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS; ++i)\n    {\n        result = scene(position + direction * total_distance);\n        \n        if(result.x < EPSILON)\n        \tbreak;\n        \n        total_distance += result.x * DISTANCE_BIAS;\n        \n        // Stop if we are headed for infinity.\n        // I changed this bit to return nothing on the color if we went to infinity.\n        if(total_distance > FAR_CLIPPING_PLANE)\n        {\n            result.yzw = vec3(0.0, 0.0, 0.0);\n            break;\n        }\n    }\n    return vec4(total_distance, result.yzw);\n}\n\n////////////////////////\n/// PBR Shading Part\n////////////////////////\n\n///I'll explain the best i can but for deeper and better explanation please refer to the links.\n///Correcting me in the comments is left as an exercise to the reader.\n\n///Get pi\n#define PI 3.14159265359\n\n///Lambertian diffuse, explanation here: https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n///By another of my deities, sebastian lagarde.\nvec3 Diffuse(vec3 pAlbedo)\n{\n\treturn pAlbedo / PI;\n}\n\n//////////////////////\n///BRDF\n//////////////////////\n\n///The BRDF is the Cook Torrance BRDF.\n///BDRF means bidirectional reflectance distribution function\n///Or simply put \"how light works with hitting a surface and how it looks to someone looking at it\"\n\n///PBR is energy conserving, which means that the outgoing light is never more than the incoming light.\n\n///There's a DIFFUSE part which is the light that gets spread around inside the surface (scattered), \n///unable to \"escape\" in a singular direction.\n\n///Then there's the SPECULAR part which is the light that is reflected on the surface and \n///changes in accordance to the surface's properties. \n\n///PBR Inputs (Metallic workflow)\n\n///ROUGHNESS\n///PBR works by modelling the microsurfaces or microfaces on the objects. \n///The \"normal\" we use for shading is the \"visible\" and \"practical\" normal, what we can see with our plain eyes. \n///But it's not the only one. There are tiny tiny cavities in every surface where light can get trapped. \n///These have a normal of their own and this is simulated using the roughness input.\n\n///METALNESS / METALLIC\n///A metallic object in real life does not have a refraction or diffuse color. \n///Look at a mirror, it takes all its color from the environment. It's all reflection.\n///It can modify the reflected color like it does on a bronze or golden surface. \n\n///The diffuse part only requires the above Diffuse function which is later\n///-multiplied by the eternal normal dot light to calculate the incidence of the light on the surface.\n\n///The Specular part is the fancy part of PBR. We need three functions.\n\n///The normal distribution function. Which is how the specular highlight distributes on the surface when viewed.\nfloat NormalDistribution_GGX(float a, float NdH)\n{\n\t//Isotropic ggx\n\tfloat a2 = a * a;\n\tfloat NdH2 = NdH * NdH;\n\n\tfloat denominator = NdH2 * (a2 - 1.0f) + 1.0f;\n\tdenominator *= denominator;\n\tdenominator *= PI;\n\treturn a2 / denominator;\n}\n\n///The geometry function which simulates the tiny cavities' shadowing depending on the light's direction.\n///Imagine a tiny cavity being shadowed because the light does not hit it on the opening.\nfloat Geometric_Smith_Schlick_GGX(float a, float NdV, float NdL)\n{\n\t//smith schlick-GGX\n\tfloat k = a * 0.5f;\n\tfloat GV = NdV / (NdV * (1.0f - k) + k);\n\tfloat GL = NdL / (NdL * (1.0f - k) + k);\n\n\treturn GV * GL;\n}\n\n///Fresnel. Everything is shiny and everything has fresnel. So we need this.\n///http://filmicworlds.com/blog/everything-is-shiny/\n///http://filmicworlds.com/blog/everything-has-fresnel/\nfloat Fresnel_Schlick(float u)\n{\n\tfloat m = clamp(1.0f - u, 0.0f, 1.0f);\n\tfloat m2 = m * m;\n\treturn m2 * m2 * m;\n}\n\n///This one is used for calculating the specular contribution, we'll come back to this one later.\nvec3 Fresnel_Schlick(vec3 specularColor, vec3 h, vec3 v)\n{\n\treturn (specularColor + (1.0f - specularColor) * pow((1.0f - clamp(dot(v, h), 0.0f, 1.0f)), 5.0f));\n}\n\n///Calculate the specular.\n///Send it a million parameters to calculate them all. \n///I know some are unused but i used to have other functions set up here. Don't worry about it.\nvec3 Specular(vec3 specularColor, vec3 h, vec3 v, vec3 l, float a, float NdL, float NdV, float NdH, float VdH, float LdV)\n{\n    ///Get the three results.\n\tvec3 TotalSpecular = NormalDistribution_GGX(a, NdH) *\n\t\tFresnel_Schlick(specularColor, v, h) *\n\t\tGeometric_Smith_Schlick_GGX(a, NdV, NdL);\n\n    ///Divide them by 4 * Normal dot View and Normal dot Light.\n\treturn TotalSpecular / (4.0f * NdV * NdL + 0.001f);\n}\n\n///This is used for the specular contribution on the environment, we'll also use this later.\nvec3 Specular_F_Roughness(vec3 specularColor, float a, vec3 h, vec3 v)\n{\n    vec3 c = vec3(1.0f - a,1.0f - a,1.0f - a);\n\treturn specularColor + (max(c, specularColor) - specularColor) * pow((1.0f - clamp(dot(v, h), 0.0f, 1.0f)), 5.0f);\n}\n\n///Compute the result of one light.\nvec3 ComputeLight(vec3 albedoColor, vec3 specularColor, vec3 normal, float roughness, vec3 lightPosition, vec3 lightColor, vec3 lightDir, vec3 viewDir, float met)\n{\n    ///Calculate everything.\n\tfloat NdL = clamp(dot(normal, lightDir), 0.0f, 1.0f);\n\tfloat NdV = clamp(dot(normal, viewDir), 0.0f, 1.0f);\n\tvec3 h = normalize(lightDir + viewDir);\n\tfloat NdH = clamp(dot(normal, h), 0.0f, 1.0f);\n\tfloat VdH = clamp(dot(viewDir, h), 0.0f, 1.0f);\n\tfloat LdV = clamp(dot(lightDir, viewDir), 0.0f, 1.0f);\n\tfloat a = max(0.001f, roughness * roughness);\n\n    ///Get the diffuse result and the specular result.\n\tvec3 ColorDiffuse = Diffuse(albedoColor);\n\tvec3 ColorSpecular = Specular(specularColor, h, viewDir, lightDir, a, NdL, NdV, NdH, VdH, LdV);\n\n    ///Diffuse and Specular are mutually exclusive, if light goes into diffuse it is because it was not reflected and\n    ///If light goes into specular it's because it was not refracted and was reflected.\n\n    ///Now we get the fresnel of our half and view. This gives us our Specular contribution depending on the angle of viewing.\n\tvec3 F = Fresnel_Schlick(specularColor, h, viewDir);\n\tvec3 kS = F;\n\tvec3 kD = vec3(1.0f, 1.0f, 1.0f) - kS; ///To get our diffuse contribution we substract the specular contribution from a white color.\n\n    kD *= 1.0f - met;\n\n    ///Now we just multiply the NdL by the lightcolor and by the colorDiffuse and ColorSpecular\n\treturn lightColor * NdL * (kD * ColorDiffuse + ColorSpecular);\n}\n\nvec3 ToLinear(vec3 c)\n{    \n    c.x = pow(c.x, 2.2f);\n    c.y = pow(c.y, 2.2f);\n    c.z = pow(c.z, 2.2f);\n    \n    return c;\n}\n\nvec3 TosRGB(vec3 c)\n{    \n    c.x = pow(c.x, 1.0f/2.2f);\n    c.y = pow(c.y, 1.0f/2.2f);\n    c.z = pow(c.z, 1.0f/2.2f);\n    \n    return c;\n}\n\n#define CAMERA_MOVING 1.0f\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ///Prepare everything for raymarching.\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Get the positions for the ray.\n    vec2 pos = uv * 2.0f - 1.0f;\n    pos.x *= iResolution.x / iResolution.y;\n    \n    ///Build the direction of the ray.\n    vec3 direction = normalize(vec3(pos, 2.5));\n    \n    ///////////////// \n    ///Used to move the camera around.\n    float posYZ = sin(iTime) * 2.0f * CAMERA_MOVING;\n    float posY = cos(iTime) * 2.0f * CAMERA_MOVING;\n    /////////////////\n    \n    ///The camara origin.\n    vec3 camera_origin = vec3(posY, posYZ, posYZ); \n    \n    \n    ///Do the raymarch.\n    vec4 result = raymarch(camera_origin, direction); \n    \n    ///get the intersection or the world position of the pixel.\n    vec3 pixelWorldPos = camera_origin + direction * result.x;\n    \n    ///Use that to get the normal of the surface.\n    vec3 n = normal(pixelWorldPos, 0.01);\n    \n    ///Get the viewDir which is the direction from the camera to the pixel world position.\n    ///This is the same as the direction, but here's how to calculate it anyway.\n    vec3 viewDir = normalize(pixelWorldPos - camera_origin);\n    \n    ///This variable is used so the background does not react to roughness.\n    float envRoughness = 1.0f;\n    \n    ///If we didn't hit anything.\n    if (result.x > FAR_CLIPPING_PLANE)\n    {\n        ///Set the normal to nothing.\n        n = vec3(0.0f, 0.0f, 0.0f);\n        ///Make it so that we don't sample the background by roughness.\n        envRoughness = 0.0f;\n    }\n    \n    /////////////////////////////////////////\n    ///EXPERIMENTS / CHANGEABLE VALUES \n    /////////////////////////////////////////\n    \n    ///Set the light Dir\n    vec3 lightDir = vec3(3.0f, 0.0f, 5.0f);\n    ///Every direction is always normalized, always.\n    lightDir = normalize(lightDir);\n    \n    ///The light color.\n    vec3 lightColor = vec3(5.0f, 5.0f, 5.0f);\n    \n    ///The roughness. It is currently changing according to a sin. you can change it here.\n    float roughness = clamp((sin(iTime) + 1.0f) / 2.0f, 0.0f, 1.0f);\n    \n    ///The metallic value. Change this to see how it works.\n    float met = 0.0f;\n    \n    ////This one just makes it so the sphere on the left is fully metallic, to show the difference.\n    if (pixelWorldPos.x < 0.0f) met = 1.0f;\n    \n    /////////////////////////////////////////\n    /// Calculations\n    /////////////////////////////////////////\n    \n    ///Now we get the color from the hit surface. This is the material color.\n    ///Known as Albedo.\n    vec3 col = result.yzw;\n    \n    ///We need to transform the color from sRGB (display values) to linear (Math correct pro values).\n    ///https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear\n    col = ToLinear(col);\n    \n    ///Get the specular color by lerping from a blackish color to the albedo color using the metallic as alpha.\n    ///If something is 100% metallic, then its specular color will be the full albedo. \n    ///If it is 0% metallic, there will barely be any specular color.\n    vec3 specColor = mix(vec3(0.06f, 0.06f, 0.06f), col, met);\n    \n    ///Compute the actual DIRECT light contribution.\n    ///Direct lighting is the contribution of real lights directly hitting a surface. \n    ///Indirect lighting is light that comes from other surfaces and the light that bounces off of them.\n    ///We send the lightdir negated and the view dir negated because they have to follow the same direction as the normal.\n    ///So the dot products work.\n    vec3 pbr = ComputeLight(col, specColor, n, roughness, -lightDir * 1000.0f, lightColor, -lightDir, -viewDir, met);\n    \n    ///Now for the INDIRECT light contribution. This is the light that bounces off of other objects.\n    ///This is IBL or Image based Lighting. Which means we use a texture or cubemap's data as light contribution\n    ///from the environment. \n    \n    ///Now we calculate the fresnel for the environment.\n    vec3 envFresnel = Specular_F_Roughness(specColor.xyz, roughness * roughness, n, -viewDir).xyz;\n    \n    ///We calculate again the specular and diffuse contributions because there are two parts \n    ///There's two parts the environment and the irradiance. \n    ///One affects the diffuse and the other one affects the specular.\n\tvec3 Kd = 1.0f - envFresnel;\n\tKd *= 1.0f - met;\n    \n    ///Get the reflection vector using the view dir on the normal.\n    vec3 reflection = reflect(viewDir, n);\n    \n    ///We are gonna sample the cubemap with a sample level depending of the roughness of the surface.\n    ///The mip maps help us simulate the environment reflections becoming diffused depending of thr surface's roughness.\n    ///We have 9.0f mipmaps so we multiply roughness which goes from 0.0f to 1.0f by 9.\n    ///This means that when roughness is 0.0f, we'll get the \"clearest\" reflection.\n    ///And when it is 1.0f, we'll get a diffuse reflection.\n    float sampleLevel = roughness*9.0f*envRoughness;\n    \n    ///Sample using the reflection vector and sampleLevel\n    vec4 env = textureLod(iChannel3, reflection, sampleLevel);\n    ///Make it linear.\n    env.xyz = ToLinear(env.xyz);\n    \n    ///Now we will sample the same cubemap, but with the largest mip. \n    ///We use the normal this time, because we want to get a value for irradiance.\n    ///This is just light that \"bleeds\" into other things which are nearby.\n    ///This is not a reflection. Think about it like this. You're standing next to a red wall.\n    ///The wall is hit by the sunlight and your body looks red from standing near to it.\n    ///It is not a reflection, it does not change if you move or look at your skin from a different angle.\n    ///It's just the wall irradiating red light and coloring your skin.\n    vec4 irr = textureLod(iChannel3, n, 9.0f);\n    irr.xyz = ToLinear(irr.xyz);\n    \n    ///Finally, let's output to screen.\n    if (result.x > FAR_CLIPPING_PLANE)\n    {\n        ///IF we hit nothing, just print the environment color.\n        fragColor = vec4(env.xyz, 1.0f);\n    } else\n    {\n        ///If we did hit something. Do the final calculation.\n        vec3 directLight = pbr;\n        \n        ///Multiply the surface color by the irradiance and by the diffuse contribution.\n        vec3 ambientLight = col * irr.xyz * Kd; \n        \n        ///Multiply the environment by the fresnel.\n        ///The environment should be more reflective on grazing angles.\n        vec3 specularIndirectLight = env.xyz * envFresnel; \n        \n        fragColor = vec4(directLight + ambientLight + specularIndirectLight, 1.0f);\n    }\n    \n    ///We are done with calculations so just go back to sRGB for our screens to display.\n    fragColor.xyz = TosRGB(fragColor.xyz);\n} ","name":"Image","description":"","type":"image"}]}