{"ver":"0.1","info":{"id":"NdscWf","date":"1653778460","viewed":95,"name":"1a1008b8-6ee8-4f25-a205-5","username":"Azorlogh","description":"light particles spreading through an evolving noise texture","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["alienhieroglyphs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv).gggg;\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord*0.3), 0).rgba*vec4(0,0.1,0,1);\n    \n    fragColor.rgb += hash13(vec3(fragCoord*0.3, iTime))*0.0;\n    \n    //fragColor.g += permeability(vec3(floor(fragCoord*0.3), iTime), iResolution.xy)*0.2;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 posToUv(vec2 pos) {\n    return (pos * (iResolution.y/2.0) + iResolution.xy/2.0)/iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord - iResolution.xy/2.0) / (iResolution.y/2.0);\n\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    float permeability = permeability(vec3(fragCoord, iTime), iResolution.xy);\n\n    float sum = 0.0;\n    //float above = texture(iChannel0, posToUv(pos + vec2(0, 0.00005))).r;\n    //float below = texture(iChannel0, posToUv(pos + vec2(0, -0.00005))).b;\n    float above = texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,1), 0).r;\n    float below = texelFetch(iChannel0, ivec2(fragCoord)-ivec2(0,1), 0).b;\n    for (int y=-1; y<=1; y++) {\n        for (int x=-1; x<=1; x++) {\n            if ((x!=0 || y!=0)) {\n                vec4 data = texelFetch(iChannel0, ivec2(fragCoord)+ivec2(x,y), 0);\n                float force = data.r*1000.0 + data.g + data.b*1000.0;\n                sum += force;\n                if (y == 0) sum += force*4.0;\n            }\n        }\n    }\n    \n    float force = pow(permeability, 2.0) * sum / 8.0*0.6;\n    \n    float n = hash13(uvec3(fragCoord.x, fragCoord.y, iTime)+uvec3(10));\n    \n    if (n < 0.0003) {\n        fragColor = vec4(1, 1, 1, 1);\n    } else {\n        \n        fragColor = vec4(vec3(n < 0.95 ? vec2(above, below) : vec2(0), clamp(force+data.g*0.33, 0.0, 1000.0)).rbg, 1);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nconst float TAU = 6.283185307179586;\n\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n\n\n\n\n\n\n\n\n\nfloat permeability(vec3 coord, vec2 resolution) {\n    float n = hash13(vec3(coord.xyz));\n    \n    vec2 rot_coord = mat2(cos(TAU/8.0), sin(TAU/8.0), -sin(TAU/8.0), cos(TAU/8.0))*coord.xy / sqrt(2.0)*4.0;\n    \n    int xor = int(rot_coord.x) ^ int(rot_coord.y) ^ int(coord.z*2.0);\n    \n    float x = hash13(vec2(coord.x, 10000.0).xyy);\n    \n    float y = hash13(vec2(coord.y, 10000.0).xyy);\n    \n    float xcenter = (snoise(vec3(coord.y, 20000, coord.z))*4.0*0.5+0.5)*resolution.x;\n    float xspread = snoise(vec3(coord.y, 30000, coord.z))*resolution.x;\n    \n    float xmin = xcenter - xspread;\n    float xmax = xcenter + xspread;\n    \n    float xcontrib = snoise(vec3(coord.x*0.01, coord.y, coord.z*0.1));\n    \n    //return float(xor%7 < 3);\n    \n    return clamp(\n        pow(n, 0.2)\n        //* pow(float(xor%7+1)/7.0, 3.0)\n        * (0.1+0.9*float(xor%7 < 4))\n        * (0.8+0.2*pow(x, 0.1))\n        * (0.2+0.8 * pow(y, 0.2)* float(xcontrib<0.0))\n        ,\n        0.0,\n        2.0\n    );\n}","name":"Common","description":"","type":"common"}]}