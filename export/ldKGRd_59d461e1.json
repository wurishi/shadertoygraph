{"ver":"0.1","info":{"id":"ldKGRd","date":"1456012554","viewed":136,"name":"Raytrace Collab v1","username":"polkm","description":"First version of a collaborative project","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["distancefields","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ro, rd is ray origin and ray direction\n\nconst vec3 sunDir = normalize(vec3(0.5, 0.5, 0.5));\nconst float waterHeight = 50.0;\n\nconst float tmin = 0.1;\nconst float tmax = 10000.0;\n\n// Colors\nconst vec4 skyColor = vec4(0.3, .55, 0.76, 1.0);\n\nconst vec4 dirtColor = vec4(0.55, .5, 0.3, 1.0);\n\n// Height map\nfloat terrain(vec2 x)\n{\n    vec2 uv = vec2(0.5, 0.5) + (x / iResolution.xy / 20.0);\n    if (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0)\n        return 0.0;\n    vec4 d = texture(iChannel0, uv);\n    float size = 256.0;\n    return (d.r * size + d.g * size * size) / 50.0;\n    //return 0.0;\n}\n\n\n// Ray tracing\nbool hit(float dist, float t)\n{\n  return dist < (0.0002 * t) || t > tmax;\n}\n\nfloat distTerrain(vec3 pos)\n{\n    return pos.y - terrain(pos.xz);\t\n}\n\nfloat traceTerrain(vec3 ro, vec3 rd)\n{\n    float t = tmin;\n    for (int i = 0; i < 256; i++) {\n        vec3 pos = ro + t * rd;\n\n        float dist = distTerrain(pos);\n\n        if (hit(dist, t))\n            break;\n\n        t += 0.5 * dist;\n    }\n    return t;\n}\n\n// Rendering\nvec3 renderSky(vec3 ro, vec3 rd)\n{\n \treturn skyColor.rgb;   \n}\n\nvec3 terrainNormal(vec3 pos, float t) // (thanks iq again)\n{\n    vec2 eps = vec2(0.003 * t, 0.0);\n    return normalize(vec3(\n        terrain(pos.xz - eps.xy) - terrain(pos.xz + eps.xy),\n        2.0 * eps.x,\n        terrain(pos.xz - eps.yx) - terrain(pos.xz + eps.yx)\n    ));\n}\n\nvec3 renderTerrain(vec3 ro, vec3 rd, float t)\n{\n    vec3 pos = ro + rd * t;\n    vec3 col = dirtColor.rgb;\n    \n    vec3 norm = terrainNormal(pos, t);\n    \n    float dp = dot(norm, sunDir);\n    \n    return col * dp;\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(1, 1, 1);\n\n    float terrainT = traceTerrain(ro, rd);\n\n    if (terrainT > tmax)\n    {\n        col = renderSky(ro, rd);  \n    }\n    else\n    {\n        col = renderTerrain(ro, rd, terrainT);\n    }\n\n    return vec4(col, terrainT);\n}\n\n// Camera\nvec3 cameraPos()\n{\n    float time = iTime;\n\treturn vec3(cos(time) * 3.0, 2.0, sin(time) * 3.0);   \n}\n\nvec3 cameraDir()\n{\n \treturn normalize(vec3(0.0, 0.0, 0.0) - cameraPos());   \n}\n\nmat3 buildViewMatrix(vec3 ro, vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 buildRayDirection(vec2 xy, mat3 view)\n{\n    vec2 s = xy * vec2(iResolution.x / iResolution.y, 1.0);\n    return view * normalize(vec3(s.xy, 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 ro = 1100.0 * cameraPos();\n    vec3 ta = ro + 1100.0 * cameraDir();\n    //ro.y = max(ro.y, max(terrain(ro.xz), waterHeight + 10.0) + 1.0);\n    float cr = 0.01;\n\n    mat3 view = buildViewMatrix(ro, ta, cr);\n\n    vec2 xy = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n    // Camera ray\n    vec3 rd = buildRayDirection(xy, view);\n\n    vec4 col = render(ro, rd);\n\n    // Gamma correction\n    col.rgb = pow(col.rgb, vec3(0.4545));\n    \n\tfragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// value noise, and its analytical derivatives (thanks iq :D)\nvec3 noised(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    float a = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n    float b = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n    float c = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n    float d = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n    return vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n                6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat terrain( in vec2 x )\n{\n    vec2  p = x * 0.03;\n    float a = 0.0;\n    float b = 1.0;\n    vec2  d = vec2(0.0);\n    for( int i = 0; i < 8; i++ ) {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x / (1.0 + dot(d,d));\n        b *= 0.5;\n        p = m2*p*2.0;\n    }\n\n    return a * 25000.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 1) {\n        float h = terrain(fragCoord);\n        float size = 10.0;\n        fragColor = vec4(mod(h / 255.0, 1.0), mod(floor(h / 255.0) / 255.0, 1.0), 0.0, 1.0);\n    } else {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        fragColor = texture(iChannel1, uv);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}