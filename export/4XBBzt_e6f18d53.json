{"ver":"0.1","info":{"id":"4XBBzt","date":"1729808398","viewed":23,"name":"scene2 = pattern 16","username":"sjoerd","description":"test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define period (2.0 * PI)\n\n\n//----------------------\n// shape manipulations\n//----------------------\n\nfloat smin(in float a, in float b, float k)\n{\n    float h = max(k - abs(a-b), 0.0);\n    return min(a,b) - h*h/(k*4.0);\n}\n\nfloat smax( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nmat2 rotateY(float angle) // m x n matrix, m vertical, n horizontal\n{\n    float s = sin(angle); // c at 1-1, -s at 2-1 (left bottom), s at 1-2 (top right), c at 2-2\n    float c = cos(angle); // ortho view with y up and z left, makes rotation counter clockwise\n    return mat2(c, -s, s, c); // angle = 0.25 * period makes a quarter of a rotation\n}\n\n\n//----------------------\n// shapes\n//----------------------\n\n\nfloat hash(float n, float seed) {\n    return fract(sin(n) * seed);\n}\n\nfloat noise(vec2 p, float seed) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = hash(i.x + hash(i.y, seed) * 57.0, seed);\n    float b = hash(i.x + 1.0 + hash(i.y, seed) * 57.0, seed);\n    float c = hash(i.x + hash(i.y + 1.0, seed) * 57.0, seed);\n    float d = hash(i.x + 1.0 + hash(i.y + 1.0, seed) * 57.0, seed);\n    \n    vec2 u = f * f * (3.0 - 2.0 * f); // smoothstep\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat fbm(vec2 p, float seed)\n{\n    float total = 0.0;\n    float amplitude = 1.8;\n    p *= 0.2;\n    for(int i = 0; i < 5; i++)\n    {\n        total += noise(p, seed) * amplitude;\n        p *= 2.0; //increase frequency\n        amplitude *= 0.4; //decrease amplitude\n    }\n    return total;\n}\n\nfloat sdTerrain(vec3 p)\n{\n    float d = p.y - (0.0);\n    d += fbm(p.xz, 43758.5453);\n    d *= 0.6;\n    return d;\n}\n\n\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdElipsoid(vec3 p, vec3 rad)\n{\n    float k0 = length(p/rad);\n    float k1 = length(p/rad/rad);\n    return k0*(k0-1.0)/k1;\n}\n\n\nvec2 sdCreature(vec3 p)\n{\n    float x = 1.1;\n    \n    vec3 q = p;\n    q.xz = rotateY(0.27 * period) * q.xz;\n    q -= vec3(0.12, 0.03, -0.1);\n    if(iTime > 2.5) q.xz = rotateY(0.27 * period) * q.xz;\n    if(iTime > 3.0) q += vec3(0.0, 0.0, -(iTime - 3.0) / 2.0);\n    else if(iTime > 3.7) q += vec3(0.0, 0.0, -(iTime - 3.7) / 6.0);\n    \n    vec3 cheJP = q - vec3(0.0, 0.0, 0.1);\n    vec3 cheJS = vec3(abs(cheJP.x), cheJP.yz);\n    \n        vec3 necJP = cheJP - vec3(0.0, 0.005, 0.02);\n        if(iTime > 0.5 && iTime < 1.5) necJP.xz = rotateY(-0.1 * period) * necJP.xz;\n        else if(iTime > 1.8 && iTime < 2.5) necJP.xz = rotateY(0.13 * period) * necJP.xz;\n                        \n            vec3 heaJP = necJP - vec3(0.0, 0.08, 0.01);\n            \n            vec3 heaJS = vec3(abs(heaJP.x), heaJP.yz);\n            \n                                vec3 necP = 0.5 * necJP + 0.5 * heaJP - vec3(0.0, 0.0, -0.02);\n                                necP.yz = rotateY(-0.14 * period) * necP.yz;\n                                \n                                vec3 snoP = heaJP - vec3(0.0, 0.0, 0.07) * x;\n                                vec3 sn_P = snoP - vec3(0.0, 0.0, 0.033);\n                                sn_P.yz = rotateY(0.1 * period) * sn_P.yz;\n                                vec3 nosP = snoP - vec3(0.0, 0.01, 0.014);\n                                \n                                vec3 earP = heaJS - vec3(0.025, 0.045, 0.0) * x;\n                                earP.xz = rotateY(-0.1 * period) * earP.xz;\n                                \n                                vec3 heaP = heaJS - vec3(0.0, 0.01, 0.02) * x;\n                                \n                                vec3 ey_P = heaP - vec3(0.035, 0.007, 0.025) * x;\n                                ey_P.xz = rotateY(0.15 * period) * ey_P.xz;\n                                vec3 eyeP = heaP - vec3(0.022, 0.002, 0.022) * x;\n    \n        vec3 shoJP = cheJS - vec3(0.03, -0.01, 0.01);\n            \n            vec3 fL1JP = shoJP - vec3(0.0, -0.02, -0.03);\n            \n                vec3 fL2JP = fL1JP - vec3(0.0, -0.14, 0.03);\n                \n                                vec3 fL1P = 0.5 * shoJP + 0.5 * fL1JP;\n                                fL1P.yz = rotateY(0.03 * period) * fL1P.yz;\n                                vec3 fL2P = 0.5 * fL1JP + 0.5 * fL2JP;\n                                fL2P.yz = rotateY(-0.03 * period) * fL2P.yz;\n                                vec3 fPaP = fL2JP - vec3(0.0, -0.01, 0.02);\n    \n    vec3 hipJP = q - vec3(0.0, 0.0, -0.08);\n    vec3 hipJS = vec3(abs(hipJP.x), hipJP.yz);\n    \n                                vec3 to1P = 0.68 * cheJP + 0.32 * hipJP;\n                                to1P.yz = rotateY(0.01 * period) * to1P.yz;\n                                vec3 to2P = 0.18 * cheJP + 0.82 * hipJP - vec3(0.0, 0.012, 0.0);\n                                to2P.yz = rotateY(-0.04 * period) * to2P.yz;\n    \n        vec3 ta1JP = hipJP - vec3(0.0, 0.02, -0.02);\n            \n            vec3 ta2JP = ta1JP - vec3(0.0, 0.00, -0.1);\n            \n                                vec3 ta1P = 0.5 * ta1JP + 0.5 * ta2JP;\n                                vec3 ta2P = ta2JP - vec3(0.0, 0.0, -0.03);\n    \n        vec3 pelJP = hipJS - vec3(0.035, -0.01, -0.01);\n            \n            vec3 hL1JP = pelJP - vec3(0.0, -0.05, 0.04);\n            \n                vec3 hL2JP = hL1JP - vec3(0.0, -0.06, -0.06);\n                \n                    vec3 hL3JP = hL2JP - vec3(0.0, -0.05, 0.02);\n                \n                                vec3 hL1P = 0.6 * pelJP + 0.4 * hL1JP;\n                                hL1P.yz = rotateY(-0.06 * period) * hL1P.yz;\n                                vec3 hL2P = 0.5 * hL1JP + 0.5 * hL2JP;\n                                hL2P.yz = rotateY(0.1 * period) * hL2P.yz;\n                                vec3 hL3P = 0.5 * hL2JP + 0.5 * hL3JP;\n                                hL3P.yz = rotateY(-0.03 * period) * hL3P.yz;\n                                vec3 hPaP = hL3JP - vec3(0.0, -0.01, 0.018);\n                \n    \n    float r = 0.01;\n    float cheJ = sdSphere(cheJP, r);\n    float d = cheJ;\n    \n    //torso\n    vec3 rad = vec3(0.05, 0.05, 0.085);\n    float to1 = sdElipsoid(to1P, rad);\n    d = smin(d, to1, 0.01);\n    \n    rad = vec3(0.035, 0.038, 0.07);\n    float to2 = sdElipsoid(to2P, rad);\n    d = smin(d, to2, 0.02);\n    \n    //head\n    rad = vec3(0.037, 0.037, 0.065) * x;\n    float nec = sdElipsoid(necP, rad);\n    d = smin(d, nec, 0.025);\n    \n    rad = vec3(0.035, 0.035, 0.045) * x;\n    float hea = sdElipsoid(heaP, rad);\n    d = smin(d, hea, 0.014);\n    \n    \n    rad = vec3(0.005, 0.02, 0.02) * x;\n    float ey_ = sdElipsoid(ey_P, rad);\n    d = smax(ey_, d, 0.01);\n    \n    \n    rad = vec3(0.018, 0.018, 0.03) * x;\n    float sno = sdElipsoid(snoP, rad);\n    d = smin(d, sno, 0.007);\n    \n    rad = vec3(0.03, 0.03, 0.01) * x;\n    float sn_ = sdElipsoid(sn_P, rad);\n    d = smax(sn_, d, 0.02);\n    \n    \n    rad = vec3(0.015, 0.03, 0.01) * x;\n    float ear = sdElipsoid(earP, rad);\n    d = smin(d, ear, 0.01);\n    \n\n    //tail\n    rad = vec3(0.015, 0.015, 0.06);\n    float ta1 = sdElipsoid(ta1P, rad);\n    d = smin(d, ta1, 0.01);\n    \n    rad = vec3(0.01, 0.01, 0.03);\n    float ta2 = sdElipsoid(ta2P, rad);\n    d = smin(d, ta2, 0.02);\n    \n    //legs\n    \n        //fL\n        rad = vec3(0.02, 0.04, 0.02);\n        float fL1 = sdElipsoid(fL1P, rad);\n        d = smin(d, fL1, 0.01);\n    \n        rad = vec3(0.018, 0.08, 0.018);\n        float fL2 = sdElipsoid(fL2P, rad);\n        d = smin(d, fL2, 0.01);\n    \n        //hL\n        rad = vec3(0.022, 0.05, 0.026);\n        float hL1 = sdElipsoid(hL1P, rad);\n        d = smin(d, hL1, 0.03);\n\n        rad = vec3(0.018, 0.04, 0.018);\n        float hL2 = sdElipsoid(hL2P, rad);\n        d = smin(d, hL2, 0.02);\n        \n        rad = vec3(0.02, 0.042, 0.02);\n        float hL3 = sdElipsoid(hL3P, rad);\n        d = smin(d, hL3, 0.02);\n    \n        //pa\n        rad = vec3(0.016, 0.012, 0.018);\n        float fPa = sdElipsoid(fPaP, rad);\n        d = smin(d, fPa, 0.014);\n        float hPa = sdElipsoid(hPaP, rad);\n        d = smin(d, hPa, 0.012);\n    \n    \n    vec2 res = vec2(d, 2.0); // everything above is mat 2\n    \n    \n    rad = vec3(0.007, 0.004, 0.005) * x;\n    float nos = sdElipsoid(nosP, rad);\n    d = smin(d, nos, 0.01);\n    \n    rad = vec3(0.01, 0.01, 0.01) * x;\n    float eye = sdElipsoid(eyeP, rad);\n    d = smin(d, eye, 0.001);\n    \n    if(d < res.x) res = vec2(d, 3.0); // everything above is mat 3\n    \n\n    return res;\n}\n\n\nfloat sdCylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 sdTree(vec3 p)\n{\n    float trunk = sdCylinder(p, 1.4, 0.05);\n    vec2 res = vec2(trunk, 4.0); // everything above is mat 4\n    \n    vec3 cen = vec3(0.0, 3.0, 0.0);\n    vec3 rad = vec3(0.6, 2.0, 0.6);\n    float canopy = sdElipsoid(p - cen, rad);\n    if(canopy < res.x) res = vec2(canopy, 5.0); // everything above is mat 5\n    \n    return res;\n}\n\nfloat sdBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdFence(vec3 p) {\n    float poleRadius = 0.03; \n    float poleHeight = 1.1;  \n    float poleSpacing = 4.996; \n    float barThickness = 0.32; \n    float barHeight1 = 1.1;       \n    float barLength = 20.0;\n\n    vec3 spot = vec3(802.0, 0.6, 1.6);\n    vec3 polePos = spot - vec3(802.0 + mod(p.x + poleSpacing * 0.5, poleSpacing) - poleSpacing * 0.5, p.y + 1.0, p.z);\n    float pole = sdCylinder(polePos, poleHeight * 2.0, poleRadius * 4.0);\n\n    vec3 bar1Pos = spot - vec3(p.x, p.y - barHeight1 + 0.8, p.z); \n    float bar1 = sdBox(bar1Pos, vec3(barLength, barThickness, poleRadius), 0.01);\n\n    vec3 bar2Pos = bar1Pos - vec3(0.0, 0.8, 0.0);\n    float bar2 = sdBox(bar2Pos, vec3(barLength, barThickness, poleRadius), 0.01);\n    \n    vec3 bar3Pos = bar2Pos - vec3(0.0, 0.8, 0.0);\n    float bar3 = sdBox(bar3Pos, vec3(barLength, barThickness, poleRadius), 0.01);\n\n    return min(pole, min(bar1, min(bar2, bar3)));\n}\n\nvec2 map(vec3 p)\n{\n    float terrain = sdTerrain(p);\n    vec2 res = vec2(terrain, 1.0);\n    \n    if(p.y < -2.2) res.y = 6.0;\n    \n    float fence = sdFence(p);\n    if(fence < res.x) res = vec2(fence, 7.0);\n    \n\n    vec3 cen2 = vec3(799.5, -0.8, 2.5);\n    \n    vec2 creature = sdCreature(p - cen2);\n    if(creature.x < res.x) res = creature;\n    \n    vec3 cen = vec3(-2.0, -0.5, 800.0);\n    cen.y -= -0.2 + sdTerrain(cen) * 1.67;\n    for (float x = -20.0; x <= 20.0; x += 10.0) {\n        for (float z = -20.0; z <= 20.0; z += 8.0) {\n            vec3 pos = vec3(cen.xy, 800.0) + vec3(x, 0.0, z);\n            pos.xz = rotateY(0.251 * period) * pos.xz;\n            pos.y -= sdTerrain(pos) / 0.6;\n            vec2 tree = sdTree(p - pos); \n            if (tree.x < res.x) res = tree; \n        }\n    }\n    \n    return res;    \n}\n\n\n\n\n//----------------------\n// light calculations\n//----------------------\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n    float m = -1.0;\n    float t = 0.0;\n    \n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 d = map(p);\n        m = d.y;\n        \n        if(d.x < 0.001) break;\n        t += d.x;\n        if(t > 30.0) break;\n    }\n    if(t > 30.0) m = -1.0;\n    \n    return vec2(t, m);\n}\n\nfloat castShadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.001;\n    \n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        float h = map(p).x;\n        res = min(res, 16.0 * h / t);\n        if(res < 0.0001) break;\n        //t += h;\n        //if(t > 20.0) break;/////////\n        t += clamp(h, 0.5 + t * 0.05, 25.0); // iq in 'terrainShadow' function\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(0.1, 0.0); // error\n    vec3 nor = normalize(vec3( map(p + e.xyy).x - map(p - e.xyy).x, \n                               map(p + e.yxy).x - map(p - e.yxy).x, \n                               map(p + e.yyx).x - map(p - e.yyx).x  ));\n    return nor;\n}\n\nvec3 applyFog( in vec3  col,   // color of pixel\n               in float t,     // distance to point\n               in vec3  rd,    // camera to point\n               in vec3  sun_dir )  // sun direction\n{\n    float fogStrength = 0.04;\n    float fogAmount = 1.0 - exp(-t * fogStrength);\n    float sunAmount = max( dot(rd, sun_dir), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5, 0.6, 0.7), // blue\n                           vec3(1.0, 0.9, 0.7), // yellow\n                           pow(sunAmount, 8.0)  );\n    return mix(col, fogColor, fogAmount);\n}\n\n\n//----------------------\n// main\n//----------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    \n    //----------------------\n    // camera\n    //----------------------\n    \n    \n    vec3 ta = vec3(-2.0, -0.5, 800.0);\n    if(iTime > 5.5) ta += vec3((iTime - 5.5) * 1.2, 0.0, 0.0);\n    ta.xz = rotateY(0.25 * period) * ta.xz;\n    float dCamTa = 1.0;\n    vec3 ro = ta + vec3(dCamTa * sin(-0.125 * period), -0.2, dCamTa * cos(-0.125 * period));\n\n    // cam navigation\n    //dCamTa = 3.0;\n    //float an = 10.0 * iMouse.x / iResolution.x;\n    //ro = ta + vec3(dCamTa * sin(an), 0.0, dCamTa * cos(an));\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    float fov = 1.8;\n    vec3 rd = normalize(vec3(p.x * uu + p.y * vv + fov * ww));\n    \n    \n    //----------------------\n    // background\n    //----------------------\n    \n    vec3 col = vec3(0.56,0.54,0.85) - 0.5 * (rd.y + 0.4);\n    col = mix(col, vec3(0.93,0.84,0.84), exp(-10.0 * rd.y) / 5.0) * (0.4 + (1.0 - rd.y));\n    \n    //----------------------\n    // raymarching\n    //----------------------\n    \n    vec2 tm = castRay(ro, rd);\n    if(tm.y > 0.0)\n    {\n        vec3 p = ro + rd * tm.x;\n        vec3 nor = calcNormal(p);\n        \n        //----------------------\n        // material\n        //----------------------\n        \n        vec3 mat = vec3(0.2, 0.2, 0.2);\n        if(tm.y < 1.5)\n        {\n            mat = vec3(0.4, 0.45, 0.1);\n            mat *= 0.5 + 0.5 * vec3(fbm(p.xz, 93242.7114), fbm(p.xz, 34791.486), fbm(p.xz, 2462.6304));\n        }\n        else if(tm.y < 2.5)\n        {\n            mat = vec3(0.7, 0.6, 0.6);\n        }\n        else if(tm.y < 3.5) mat = vec3(0.2, 0.1, 0.1);\n        else if(tm.y < 4.5) mat = vec3(0.2, 0.1, 0.1);\n        else if(tm.y < 5.5) mat = vec3(0.2,0.4,0.3);\n        \n        else if(tm.y < 6.5) mat = vec3(0.043,0.114,0.176);\n        \n        \n        \n        //----------------------\n        // lighting\n        //----------------------\n\n        vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2));\n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);\n        float sun_sha = castShadow(p + nor * 0.001, sun_dir);\n        float sky_dif = clamp(0.5 + 0.5 * dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bou_dif = clamp(0.5 * dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n\n        col = mat * vec3(1.0, 0.7, 0.4) * sun_dif * sun_sha;\n        col += mat * vec3(0.0, 0.1, 0.3) * sky_dif;\n        col += mat * vec3(0.8, 0.2, 0.2) * bou_dif;\n        \n        col = applyFog(col, tm.x, rd, sun_dir);\n    }\n    \n    //----------------------\n    // final\n    //----------------------\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}