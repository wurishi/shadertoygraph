{"ver":"0.1","info":{"id":"McjczW","date":"1722004308","viewed":18,"name":"Iterated Screen Slicer","username":"nextrix","description":"skibidi slicers","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["screen","slice","iteration","cut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 O, in vec2 I) {\n    vec2 uv = I / iR.xy;\n    \n    \n    // zoom-in slices\n    uv -= 0.5;\n    uv /= 2.;\n    uv += 0.5;\n    \n    // rotate\n    uv -= 0.5;\n    uv.x *= aspect;\n    uv *= r2d(radians(iTime*speed));\n    uv.x /= aspect;\n    uv += 0.5;\n    \n    // make slice\n    vec2 slice = vec2(cutSlice(uv.x), cutSlice(uv.y));\n    slice.xy = (-1.0 + 2.0 * slice.xy) * .1 * (amnt * 10.);\n\n    // add slice\n    uv.x += slice.y; \n    //uv.y += slice.x;\n    \n    // zoom-out screen\n    uv -= 0.5;\n    uv *= zoom;\n    uv += 0.5;\n    \n    // antirotate\n    uv -= 0.5;\n    uv.x *= aspect;\n    uv *= r2d(-radians(iTime*speed));\n    uv.x /= aspect;\n    uv += 0.5;\n    \n    // border mode\n    uv = (bordered==0) ? fract(uv) : uv;\n    \n    // border check\n    float borderr = border(uv);\n\n    vec4 col = mix(vec4(0.,0.,0.,1.), texture(iChannel0, uv), borderr);\n    \n    O = col;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iM iMouse\n#define iR iResolution\n#define aspect iR.x / iR.y\n\n#define iter 12.\n#define amnt iM.x / iR.x / 8.\n#define zoom 3.\n#define speed 12.\n#define bordered 1\n\nmat2 r2d (float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat border(in vec2 uv) {\n    return (floor(uv) != vec2(0.)) ? 0. : 1.;\n}\n\nfloat getSlice(float slice, float thresh, bool isOpposite) {\n    if (slice > thresh - iter && slice <= thresh) {\n        return isOpposite ? ceil(slice) : floor(slice);\n    }\n    return slice;\n}\n\nfloat cutSlice(float slice) {\n    for ( float i = 0.; i <= ceil(iter*2.); i++) {\n        float threshold = float(i) / ceil(iter*2.);\n        bool isOpposite = (mod(i, 2.) == 0.);\n        slice = getSlice(slice, threshold, isOpposite);\n    }\n    return slice;\n}\n\n","name":"Common","description":"","type":"common"}]}