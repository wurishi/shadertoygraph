{"ver":"0.1","info":{"id":"ltcGDr","date":"1468788773","viewed":581,"name":"[SH16C] Infinite Nyan Cat Runner","username":"huwb","description":"Maximum nyan cat action. Can you make it to the drop? Edit: This was actually a days worth of hacking for SH16B but i mis-converted the deadline time and missed it lol - probably for the best!","likes":8,"published":1,"flags":112,"usePreview":0,"tags":["nyancat","infiniterunner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// There are a number of games in a similar format.\n\n// For the reference I'm choosing DEATH VALLEY. This was not a released game\n// but an example in a game programming magazine. I found a page that mentions it here:\n\n// http://www.asciimation.co.nz/bb/2014/05/11/review-usborne-computer-spacegames\n\n// One of the first steps I took in programming was converting this example to run\n// in qbasic. I remember playing the result for hours <3 <3 <3.\n\n// While the execution and theme of this shader is obviously quite different from the original,\n// the gameplay is the same - navigating an increasingly narrow and windy valley for as\n// long as possible.\n\n\n// RENDER\n\nvec3 background(vec2 p);\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords );\nvec3 WallColour( float err, float maxerror );\nvec2 ScreenToWorld( vec2 screenPos, vec2 camPos ) { return screenPos - iResolution.xy/2. + camPos; }\nfloat InTrack( vec2 p );\n\nstruct SpriteData\n{\n    vec2 c; // center\n    vec2 r; // radius x and y\n    vec2 camPos; // camera pos\n    vec2 sheetDim; // sprite sheet cols and rows\n    vec2 sheetIdx; // sprite row, col\n};\nvec4 sprite( sampler2D channel, SpriteData spr, vec2 px );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec4 cat = texture(iChannel0,0.5/iResolution.xy);\n    vec2 p = cat.xy, v = cat.zw;\n    vec2 camPos = vec2( p.x+iResolution.x/4., iResolution.y/2. );\n    vec2 pixWorldPos = ScreenToWorld( fragCoord, camPos );\n    \n    // background\n\tfragColor = vec4(0.3,0.5,1.,1.);\n    fragColor.xyz += .6*background(pixWorldPos/200.);\n    // start line\n    if( abs(pixWorldPos.x)<50. )\n    {\n        float ss = 40.;\n        float sx = pixWorldPos.x+50.;\n        float v = fract(sx/ss) < .5 ? 1. : 0.;\n        if( fract(pixWorldPos.y/ss) < .5 )\n            v = 1. - v;\n        fragColor = vec4(mix(0.7,1.,v));\n    }\n    \n    // mix in fx\n    vec4 fx = texture( iChannel2, fragCoord/iResolution.xy );\n    fragColor.xyz = mix(fragColor.xyz, fx.xyz, fx.a );\n    \n    // cat\n    SpriteData spr;\n    spr.c = p;\n    spr.r = vec2(75.);\n    spr.camPos = camPos;\n    spr.sheetDim = vec2(256./40.,1.);\n    spr.sheetIdx = vec2(mod(floor(20.*iTime),6.),0.);\n    vec4 sprit = sprite(iChannel1, spr, fragCoord );\n    fragColor.xyz = mix( fragColor.xyz, sprit.xyz, sprit.a );\n\t//fragColor = mix( fragColor, vec4(1.), smoothstep(5.,3.,length(pixWorldPos-p)));\n\n    float inTrack = InTrack( pixWorldPos );\n    if( inTrack < 0. )\n    {\n        float val = -inTrack;\n        float lvls = 40.;\n        val = floor(val*lvls)/lvls;\n        fragColor.xyz = WallColour( val, .1 );\n    }\n    \n    // time\n    vec3 gameState = texture(iChannel0,vec2(1.5,.5)/iResolution.xy).xyz;\n    float gameTime = gameState.x;\n    vec3 tc = vec3(1.);\n    bool dead = gameState.y > 0.;\n    if( dead && fract(4.*iTime)<.5 ) tc.gb *= 0.;\n    bool won = gameState.z > 0.;\n    if( won && fract(4.*iTime)<.5 ) tc.rb *= 0.;\n    vec2 pws = pixWorldPos;\n    vec2 tp = p-vec2(30.,45.);\n    pws = tp + (pws-tp)*.3;\n\tfragColor.xyz += tc * drawNumber(floor(p.x/10.), tp/iResolution.xy, pws/iResolution.xy );\n}\n\n\nfloat InTrack( vec2 p )\n{\n    p.y /= iResolution.y;\n    \n    float trackR = max( .7-.00002*p.x, .3 );\n    \n    float trackY = 0.5 + .25*sin(.002*p.x);\n    // second octave\n    trackY += clamp((p.x-10000.)/1000.,0.,1.) * 0.1*sin(0.007*p.x);\n    // third octave\n    trackY += clamp((p.x-15000.)/1000.,0.,1.) * 0.06*sin(0.012*p.x);\n    // third octave\n    trackY += clamp((p.x-20000.)/1000.,0.,1.) * 0.03*sin(0.02*p.x);\n   \t\n    if( p.y < trackY )\n    {\n        return p.y - (trackY - trackR);\n    }\n    else\n    {\n        return trackY + trackR - p.y;\n    }\n    //return abs(p.y-trackY)<trackR;\n}\n\n// borrowed from mu6k's fabulous shader: https://www.shadertoy.com/view/4dXGWH\nfloat hash(float x) { return fract(sin(x*.0127863)*17143.321); }\nfloat hash(vec2 x) { return fract(sin(dot(x,vec2(1.4,52.14)))*17143.321); }\nfloat hashmix(float x0, float x1, float interp) { x0 = hash(x0); x1 = hash(x1); return mix(x0,x1,interp); }\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp) {\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\treturn mix(v0,v1,interp[1]);\n}\nfloat noise(vec2 p) { vec2 pm = mod(p,1.0); vec2 pd = p-pm; return hashmix(pd,(pd+vec2(1.0,1.0)), pm); }\nvec3 background(vec2 p)\n{\n\tvec2 pm = mod(p,vec2(0.5));\n\tfloat q = pm.x+pm.y;\n\tvec3 color = 0.*vec3(13,66,121)/255.0;\n\t\n    float t = iTime/8.;\n\tvec2 p2;\n\tfloat stars;\n\tfor (int i=0; i<5; i++)\n\t{\n\t\tfloat s = float(i)*0.2+1.0;\n\t\t//float ts\n\t\tp2=p*s+vec2(t/s,s*16.0)-mod(p*s+vec2(t/s,s*16.0),vec2(0.05));\n\t\tstars=noise(p2*16.0);\n\t\tif (stars>0.98) color=vec3(1.0,1.0,1.0);\n\t}\n\t\n\treturn color;\n}\n\nvec4 sprite( sampler2D channel, SpriteData spr, vec2 px )\n{\n    vec2 wrld = ScreenToWorld( px, spr.camPos );\n    \n    vec2 uv = (wrld - spr.c)/spr.r + 0.5;\n    \n    if( uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1. )\n        return vec4(0.);\n    \n    uv = (uv + spr.sheetIdx) / spr.sheetDim;\n    //uv.x += spr.sheetIdx.x / spr.sheetDim.x;\n    return texture(channel, uv);\n}\n\n\n// digits based on the nice ascii shader by movAX13h\nfloat drawDig( vec2 pos, vec2 pixel_coords, float bitfield )\n{\n\t// offset relative to \n\tvec2 ic = pixel_coords - pos ;\n\tic = floor(ic*iResolution.xy);\n\t// test if overlap letter\n\tif( clamp(ic.x, 0., 2.) == ic.x && clamp(ic.y, 0., 4.) == ic.y )\n\t{\n\t\t// compute 1d bitindex from 2d pos\n\t\tfloat bitIndex = ic.y*3.+ic.x;\n\t\t// isolate the bit\n\t\treturn floor( mod( bitfield / exp2( floor(bitIndex) ), 2. ) );\n\t}\n\treturn 0.;\n}\n// decimal point\nfloat drawDecPt( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 1. );\n}\n// minus sign\nfloat drawMinus( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 448. );\n}\n// digits 0 to 9\nfloat drawDigit( float dig, vec2 pos, vec2 pixel_coords )\n{\n\tif( dig == 1. )\n\t\treturn drawDig( pos, pixel_coords, 18724. );\n\tif( dig == 2. )\n\t\treturn drawDig( pos, pixel_coords, 31183. );\n\tif( dig == 3. )\n\t\treturn drawDig( pos, pixel_coords, 31207. );\n\tif( dig == 4. )\n\t\treturn drawDig( pos, pixel_coords, 23524. );\n\tif( dig == 5. )\n\t\treturn drawDig( pos, pixel_coords, 29671. );\n\tif( dig == 6. )\n\t\treturn drawDig( pos, pixel_coords, 29679. );\n\tif( dig == 7. )\n\t\treturn drawDig( pos, pixel_coords, 31012. );\n\tif( dig == 8. )\n\t\treturn drawDig( pos, pixel_coords, 31727. );\n\tif( dig == 9. )\n\t\treturn drawDig( pos, pixel_coords, 31719. );\n\t// 0\n\treturn drawDig( pos, pixel_coords, 31599. );\n}\n// max num width is 26px (minus, 3 nums, dec pt, 2 nums)\n// max height is 6px\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords )\n{\n\tfloat result = 0.;\n\tbool on = false;\n\tfloat d;\n\t/*\n\t// minus sign\n\tif( num < 0. )\n\t{\n\t\tresult += drawMinus( pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\tnum = -num;\n\t}*/\n\t// tens of thousands\n\td = floor(mod(num/10000.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// thousands\n\td = floor(mod(num/1000.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// hundreds\n\td = floor(mod(num/100.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// tens\n\td = floor(mod(num/10.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// ones\n\td = floor(mod(num,10.));\n\tresult += drawDigit( d, pos, pixel_coords );\n\tpos.x += 4. / iResolution.x;\n\t/*\n    // dec pt\n\tresult += drawDecPt( pos, pixel_coords );\n\tpos.x += 2. / iResolution.x;\n\t// tenths\n\td = floor(mod(num/.1,10.));\n\tif( true )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// hundredths\n\td = floor(.5+mod(num/.01,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t*/\n\treturn clamp(result,0.,1.);\n}\n\n\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 WallColour( float err, float maxerror )\n{\n    float period = .4;\n    float seed = floor(iTime/period);\n    float h = hash(seed);\n    vec3 col = hsv2rgb(vec3(h,.2,1.)) * (fract(err*10.)<.5 ? 1. : .8);\n    return col;\n    //return 1.1*vec3(.9,.9,.8) *( fract(err*10.)<.5 ? vec3(1.) : vec3(.8));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsS3RR","filepath":"https://soundcloud.com/c-m-b-3/my-nyan-cat-dubstep-remix","previewfilepath":"https://soundcloud.com/c-m-b-3/my-nyan-cat-dubstep-remix","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// GAME LOGIC\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\n#define FINISH_LINE_DIST 30000.\n\nbool ClampInDomain( inout vec2 p, inout vec2 v, vec2 lastp );\nbool InTrack( vec2 p );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.y > 0.5 || fragCoord.x > 1.5 )\n        return;\n    \n    vec4 data = texture(iChannel0,vec2(0.5)/iResolution.xy);\n    \n    vec2 p = data.xy;\n    vec2 v = data.zw;\n    vec2 lastp = p;\n    \n    if( iFrame == 0 )\n    {\n        p = vec2(0.,iResolution.y/2.);\n        v = vec2(200.,0.);\n    }\n    \n    bool dead = !InTrack( p );\n    if( dead )\n    {\n        // freeze data\n        fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n        \n        // signal death\n        if( fragCoord.x == 1.5 )\n\t        fragColor.y = 1.;\n        \n        return;\n    }\n    \n    // NOPE\n    /*bool won = p.x >= FINISH_LINE_DIST;\n    if( won )\n    {\n        // freeze data\n        fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n        \n        // signal win\n        if( fragCoord.x == 1.5 )\n\t        fragColor.z = 1.;\n        \n        return;\n    }*/\n    \n    // pixel (1,0) stores game state (time, dead, won)\n    if( fragCoord.x > .5 )\n    {\n        fragColor = vec4(iTime,vec3(0.));\n        return;\n    }\n    \n    p += v * iTimeDelta;\n    //v += vec2(0.,-200.) * iTimeDelta; // gravity\n    v *= (1. - 0.01*iTimeDelta*60.);\n    \n    \n    // controls\n    \n    vec2 f = vec2(400.,1300.);\n    float brake_mul = 2.;\n    if( texture( iChannel1, vec2(KEY_LEFT,0.5/3.0) ).x > 0. )\n    {\n        float mul = v.x > 0. ? brake_mul : 1.;\n\t    v.x -= f.x*iTimeDelta*mul;\n    }\n    if( texture( iChannel1, vec2(KEY_RIGHT,0.5/3.0) ).x > 0. )\n        v.x += f.x*iTimeDelta;\n    if( texture( iChannel1, vec2(KEY_DOWN,0.5/3.0) ).x > 0. )\n        v.y -= f.y*iTimeDelta;\n    if( texture( iChannel1, vec2(KEY_UP,0.5/3.0) ).x > 0. )\n        v.y += f.y*iTimeDelta;\n    \n    \n    // gameplay extents\n    \n    if( p.y < 0. )\n    {\n        p.y = 0.;\n        if( v.y < 0. )\n            v.y *= -.6;\n    }\n    if( p.y > iResolution.y )\n    {\n        p.y = iResolution.y;\n        if( v.y > 0. )\n            v.y *= -.6;\n    }\n    if( p.x < 0. )\n    {\n        p.x = 0.;\n        if( v.x < 0. ) v.x *= -.6;\n    }\n    \n    v.x = 400. + iTime*8.;\n    fragColor = vec4( p, v );\n}\n\nbool InTrack( vec2 p )\n{\n    p.y /= iResolution.y;\n    \n    float trackR = max( .7-.00002*p.x, .3 );\n    \n    float trackY = 0.5 + .25*sin(.002*p.x);\n    // second octave\n    trackY += clamp((p.x-10000.)/1000.,0.,1.) * 0.1*sin(0.007*p.x);\n    // third octave\n    trackY += clamp((p.x-15000.)/1000.,0.,1.) * 0.06*sin(0.012*p.x);\n    // third octave\n    trackY += clamp((p.x-20000.)/1000.,0.,1.) * 0.03*sin(0.02*p.x);\n   \n    return abs(p.y-trackY)<trackR;\n}\n\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// FX\n\nvec2 ScreenToWorld( vec2 screenPos, vec2 camPos )\n{\n    return screenPos - iResolution.xy/2. + camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = texture(iChannel0,0.5/iResolution.xy).xy;\n    \n    // first pixel stores position of cat\n    if( fragCoord == vec2(0.5) )\n    {\n        fragColor = vec4(p,0.,0.);\n        return;\n    }\n\t\n    vec2 p_last = texture(iChannel1,0.5/iResolution.xy).xy;\n    \n    vec2 mv = vec2(p.x-p_last.x,0.);\n    \n    // advect\n    \n    fragColor = vec4(0.);\n    \n    vec2 advectuv = fragCoord/iResolution.xy + mv/iResolution.xy;\n    if( advectuv.x >= 0. && advectuv.x <= 1. )\n\t    fragColor = texture( iChannel1, advectuv );\n    \n    \n    vec2 camPos = vec2( p.x+iResolution.x/4., iResolution.y/2. );\n    vec2 pixWorldPos = ScreenToWorld( fragCoord, camPos );\n    \n    float wt;\n    float r1 = 6., r0 = 5.;\n    float y;\n    vec3 c;\n    float off = 2.*sin(20.*iTime);\n    float xd = mix( 1., .3, clamp(.1*abs(p.x-p_last.x), 0., 1. ) );\n    \n    if( iFrame == 0 )\n    {\n        xd = 1.;\n    }\n    \n    // cols from iq's https://www.shadertoy.com/view/lsX3Rr\n    \n    y = 15.;\n    c = vec3(1.,0.,0.);\n    wt = smoothstep( r1, r0, length(vec2(xd,1.)*vec2(pixWorldPos.x-p.x,pixWorldPos.y-(p.y + y+off))) );\n    fragColor = vec4( mix( fragColor.xyz, c, wt ), fragColor.a + wt );\n    \n    y = 9.;\n    c = vec3(1.,.6,0.);\n    wt = smoothstep( r1, r0, length(vec2(xd,1.)*vec2(pixWorldPos.x-p.x,pixWorldPos.y-(p.y + y+off))) );\n    fragColor = vec4( mix( fragColor.xyz, c, wt ), fragColor.a + wt );\n    \n    y = 3.;\n    c = vec3(1.,1.,0.);\n    wt = smoothstep( r1, r0, length(vec2(xd,1.)*vec2(pixWorldPos.x-p.x,pixWorldPos.y-(p.y + y+off))) );\n    fragColor = vec4( mix( fragColor.xyz, c, wt ), fragColor.a + wt );\n    \n    y = -3.;\n    c = vec3(0.2,1.0,0.0);\n    wt = smoothstep( r1, r0, length(vec2(xd,1.)*vec2(pixWorldPos.x-p.x,pixWorldPos.y-(p.y + y+off))) );\n    fragColor = vec4( mix( fragColor.xyz, c, wt ), fragColor.a + wt );\n    \n    y = -9.;\n    c = vec3(0.0,0.6,1.0);\n    wt = smoothstep( r1, r0, length(vec2(xd,1.)*vec2(pixWorldPos.x-p.x,pixWorldPos.y-(p.y + y+off))) );\n    fragColor = vec4( mix( fragColor.xyz, c, wt ), fragColor.a + wt );\n    \n    y = -15.;\n    c = vec3(0.4,0.2,1.0);\n    wt = smoothstep( r1, r0, length(vec2(xd,1.)*vec2(pixWorldPos.x-p.x,pixWorldPos.y-(p.y + y+off))) );\n    fragColor = vec4( mix( fragColor.xyz, c, wt ), fragColor.a + wt );\n    \n    fragColor.a = clamp(fragColor.a,0.,1.);\n    \n    // fade\n    fragColor.a *= 1.;\n}\n\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// LEVEL DATA\n\n// this actually doesnt do anything anymore but im too tired to rip it out.\n// \n\n#define BC 13\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // only needs to compute on first frame\n    if( iFrame > 0 && false )\n    {\n        fragColor = texture( iChannel0, fragCoord/iResolution.xy );\n        return;\n    }\n    \n    // only store in one row\n    if( fragCoord.y > 0.5 )\n        return;\n    \n    int thisIdx = int(fragCoord.x);\n    \n    // check if within block count\n    if( thisIdx > BC )\n        return;\n    \n    // optional anchor\n    float X0 = iResolution.x;\n    float sh = iResolution.y;\n    vec2 br = vec2(50.,25.) * sh/360.;\n    \n         if( thisIdx == 0 ) fragColor = vec4( 500.+X0, sh/2., br ); // left wall\n    else if( thisIdx == 1 ) fragColor = vec4( 1500.+X0, sh/3., br ); // floor\n    else if( thisIdx == 2 ) fragColor = vec4( 1500.+X0, 2.*sh/3., br );\n    /*\n    else if( thisIdx == 4 ) fragColor = vec4( 1200.+X0, 25., 320., 25. );\n    else if( thisIdx == 5 ) fragColor = vec4( 1500.+X0, 25., 320., 25. );\n    else if( thisIdx == 5 ) fragColor = vec4( 1800.+X0, 25., 320., 25. );\n    else if( thisIdx == 6 ) fragColor = vec4( 220., 150., 50., 25. );\n    else if( thisIdx == 7 ) fragColor = vec4( 220., 150., 50., 25. );\n    else if( thisIdx == 8 ) fragColor = vec4( 220., 150., 50., 25. );\n    else if( thisIdx == 9 ) fragColor = vec4( 220., 150., 50., 25. );\n    else if( thisIdx == 10 ) fragColor = vec4( 220., 150., 50., 25. );\n    else if( thisIdx == 11 ) fragColor = vec4( 220., 150., 50., 25. );\n    else if( thisIdx == 12 ) fragColor = vec4( 220., 150., 50., 25. );\n\t*/\n}\n","name":"Buf C","description":"","type":"buffer"}]}