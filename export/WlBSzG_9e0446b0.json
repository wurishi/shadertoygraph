{"ver":"0.1","info":{"id":"WlBSzG","date":"1566240381","viewed":1555,"name":"Basic Path Tracer","username":"baldand","description":"Pan with mouse\nIncrease the sample count if you have a better GPU\nBased on http://www.realtimerendering.com/raytracing/Ray%20Tracing%20in%20a%20Weekend.pdf\n\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nSimple path tracer\n\nBased on http://www.realtimerendering.com/raytracing/Ray%20Tracing%20in%20a%20Weekend.pdf\n\nbaldand/2019\n*/\n\n// Some settings you can tweak\n\n//#define SAMPLES 50 // Bigger GPUs\n#define SAMPLES 3 // Smaller GPUs, noisier\n\n#define APERTURE 0.08 // A little out of focus in background\n//#define APERTURE 0.0 // All in focus\n\nconst float M_PI = 3.141592653589793;\n\nstruct random_state {\n    uint z0;\n    uint z1;\n    uint z2;\n    uint z3;\n};\n\n    \nuint tst(in uint z, int S1, int S2, int S3, uint M) {\n    uint b = (((z << S1) ^ z) >> S2);\n    return (((z & M) << S3) ^ b);\n}\n\nuint lcg(in uint z, uint A, uint C) {\n    return (A*z+C);\n}\n\nvoid update_random(inout random_state rs) {\n    rs.z0 = tst(rs.z0, 13, 19, 12, 4294967294u);\n    rs.z1 = tst(rs.z1,  2, 25, 4,  4294967288u);\n    rs.z2 = tst(rs.z2, 3, 11, 17, 4294967280u);\n    rs.z3 = lcg(rs.z3, 1664525u, 1013904223u);\n    uint zt = rs.z3;\n    rs.z3 ^= rs.z2;\n    rs.z2 ^= rs.z1;\n    rs.z1 ^= rs.z0;\n    rs.z0 ^= zt;\n}\n\nvoid init_random(vec2 fragCoord, float time, inout random_state rs) {\n    rs.z0 = floatBitsToUint(fragCoord.y*0.1234567);\n    rs.z1 = floatBitsToUint(fragCoord.x*0.1234567);\n    rs.z2 = floatBitsToUint(time*0.1234567);\n    rs.z3 = floatBitsToUint(0.1234567);\n    // Mix up a bit\n    update_random(rs);\n    update_random(rs);\n    update_random(rs);\n    update_random(rs);\n}\n\nfloat random0(in random_state rs) {\n    return fract(0.00002328 * float(rs.z0));\n}\nfloat random1(in random_state rs) {\n    return fract(0.00002328 * float(rs.z1));\n}\nfloat random2(in random_state rs) {\n    return fract(0.00002328 * float(rs.z2));\n}\n\nvec3 random_in_unit_disk(inout random_state rs) {\n    update_random(rs);\n    vec3 r,p;\n    r.x = random0(rs);\n    r.y = random1(rs);\n    r.z = 0.0;\n    p =2.0 * r - vec3(1.0,1.0,0.0);\n    while (dot(p,p)>1.0) p *= 0.7;\n    return p;\n}\n\nconst uint Lambertian = 0u;\nconst uint Metal = 1u;\nconst uint Dielectric = 2u;\nconst uint DiffuseLight = 3u;\n\nstruct sphere {\n    vec3 center;\n    float radius2;\n    float radiusi;\n    uint mat_type;\n    vec3 albedo;\n    vec3 albedo2;\n    float fuzz;\n    float ref_idx;\n};\n    \nconst sphere world[] = sphere[]( \n    sphere(vec3(0.0,-1001.0,0.0), 1000.0*1000.0, 1.0/1000.0, Metal, vec3(0.2,0.2,0.2),vec3(0.2,0.4,0.2),0.05,0.0),\n    sphere(vec3(0.0,-0.5,0.0), 0.5*0.5, 1.0/0.5, Dielectric, vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),0.0,1.7),\n    sphere(vec3(0.0,-0.5,0.0), 0.4*0.4, -1.0/0.4, Dielectric, vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),0.0,1.7),\n\n    sphere(vec3(2.0,0.0,0), 1.0*1.0, 1.0/1.0, Lambertian, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),0.0,0.0),\n    sphere(vec3(-2.0,0.0,0), 1.0*1.0, 1.0/1.0, Metal, vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),0.1,0.0),\n    sphere(vec3(0.0,0.0,2.0), 1.0*1.0, 1.0/1.0, Dielectric, vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),0.0,1.5),\n    sphere(vec3(0.0,0.0,-2.0), 1.0*1.0, 1.0/1.0, Metal, vec3(1.0,0.25,0.25),vec3(1.0,0.25,0.25),0.01,0.0),\n\n    sphere(vec3(4.0,-0.5,2.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0),0.0,0.0),\n    sphere(vec3(2.0,-0.5,-4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.0,1.0,0.0),vec3(0.0,1.0,0.0),0.0,0.0),\n    sphere(vec3(4.0,-0.5,4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.0,0.0,1.0),vec3(0.0,0.0,1.0),0.0,0.0),\n    sphere(vec3(-4.0,-0.5,-2.0), 0.5*0.5, 1.0/0.5, Metal, vec3(1.0,1.0,0.0),vec3(1.0,1.0,0.0),0.0,0.0),\n    sphere(vec3(-2.0,-0.5,4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.0,1.0,1.0),vec3(0.0,1.0,1.0),0.0,0.0),\n    sphere(vec3(-4.0,-0.5,-4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(1.0,0.0,1.0),vec3(1.0,0.0,1.0),0.0,0.0),\n    sphere(vec3(-4.0,-0.5,2.0), 0.5*0.5, 1.0/0.5, Metal, vec3(1.0,0.5,0.5),vec3(1.0,0.5,0.5),0.0,0.0),\n    sphere(vec3(-2.0,-0.5,-4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.5,1.0,0.5),vec3(0.5,1.0,0.5),0.0,0.0),\n    sphere(vec3(-4.0,-0.5,4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.5,0.5,1.0),vec3(0.5,0.5,1.0),0.0,0.0),\n    sphere(vec3(4.0,-0.5,-2.0), 0.5*0.5, 1.0/0.5, Metal, vec3(1.0,1.0,0.5),vec3(1.0,1.0,0.5),0.0,0.0),\n    sphere(vec3(2.0,-0.5,4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.5,1.0,1.0),vec3(0.5,1.0,1.0),0.0,0.0),\n    sphere(vec3(4.0,-0.5,-4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(1.0,0.5,1.0),vec3(1.0,0.5,1.0),0.0,0.0)\n\n);\n\nvoid get_sphere_uv(vec3 p, inout float u, inout float v) {\n    u = p.x;\n    v = p.z;\n}\n  \nstruct hit_record {\n    float t;\n    vec3 p;\n    vec3 normal;\n    vec3 objcent;\n    float u;\n    float v;\n    int objidx;\n};\n\n\nbool sphere_hit(int i, vec3 ro, vec3 rd, float a, float ooa, float t_min, float t_max, inout hit_record rec) {\n    vec3 cen = world[i].center;\n    if (i==6) cen.y = 1.5*abs(sin(iTime*3.5));\n    vec3 oc = ro - cen; \n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - world[i].radius2;\n    float disc = b*b - a*c;\n    if (disc > 0.0) {\n        float sqdisc = sqrt(disc);\n        float temp = (-b -sqdisc)*ooa;\n        if (temp < t_max && temp > t_min) {\n            rec.t = temp;\n            rec.p = ro + rd*temp;\n            rec.objcent = cen;\n            rec.normal = (rec.p - rec.objcent) * world[i].radiusi;\n            rec.objidx = i;\n            get_sphere_uv(rec.p, rec.u, rec.v);\n            return true;\n        }\n        temp = (-b +sqdisc)*ooa;\n        if (temp < t_max && temp > t_min) {\n            rec.t = temp;\n            rec.p = ro + rd*temp;\n            rec.objcent = cen;\n            rec.normal = (rec.p - rec.objcent) * world[i].radiusi;\n            rec.objidx = i;\n            get_sphere_uv(rec.p, rec.u, rec.v);\n            return true;\n        }\n    }\n    return false;\n}\n   \n\nvec3 emitted(hit_record rec) {\n    if (world[rec.objidx].mat_type == DiffuseLight) {\n        return world[rec.objidx].albedo;\n    } else {\n        return vec3(0.0);\n    }\n}\n\nbool list_hit(vec3 ro, vec3 rd, float t_min, float t_max, inout hit_record rec) {\n    bool hit_anything = false;\n    rec.t = t_max;\n    float a = dot(rd, rd);\n    float ooa = 1.0/a;\n    for (int i = 0; i < world.length(); i++) {\n        if (sphere_hit(i, ro, rd, a, ooa, t_min, rec.t, rec)) {\n            hit_anything = true;\n        }\n    }\n    return hit_anything;\n}\n\nvec3 shade(hit_record rec) {\n    bool wu = fract(rec.u*0.5)>0.5;\n    bool wv = fract(rec.v*0.5)>0.5;\n    if (wu^^wv) {\n        return world[rec.objidx].albedo;\n    } else {\n        return world[rec.objidx].albedo2;\n    }\n}\n\nvec3 random_in_unit_sphere(vec3 r) {\n    vec3 p;\n    p = 2.0 * r - vec3(1.0);\n    while (dot(p,p) > 1.0) p *= 0.7;\n    return p;\n}\n\n\nbool refract2(vec3 v, vec3 n, float ni_over_nt, inout vec3 refracted) {\n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float disc = 1.0 - ni_over_nt * ni_over_nt * (1.0-dt*dt);\n    if (disc > 0.0) {\n        refracted = ni_over_nt * (uv - n*dt) - n*sqrt(disc);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfloat schlick(float csn, float idx) {\n    float r0 = (1.0-idx) / (1.0+idx);\n    r0 = r0*r0;\n    return r0 + (1.0-r0)*pow(1.0-csn,5.0);\n}\n\nbool scatter(hit_record rec, vec3 ro, vec3 rd, inout vec3 attenuation, inout vec3 scro, inout vec3 scrd, inout random_state rs) {\n   vec3 r;\n   update_random(rs);\n   r.x = random0(rs);\n   r.y = random1(rs);\n   r.z = random2(rs);\n   vec3 reflected = reflect(normalize(rd), rec.normal);\n   attenuation = shade(rec);\n   uint mt = world[rec.objidx].mat_type;\n   if (mt == Lambertian) {\n       vec3 target = normalize(rec.normal + random_in_unit_sphere(r));\n       scro = rec.p;\n       scrd = target;\n       return true;\n   } else if (mt == Metal) {\n       vec3 rius = random_in_unit_sphere(r);\n       scro = rec.p;\n       float fuzz = world[rec.objidx].fuzz;\n       scrd = ((1.0-fuzz)*reflected + fuzz*rius) + fuzz*(rec.normal + rius);\n       return dot(scrd,rec.normal) > 0.0; \n   } else if (mt == Dielectric) {\n       vec3 outward_normal;\n       float ni_over_nt;\n       vec3 refracted;\n       float reflect_prob = 1.0;\n       float csn;\n       float il = 1.0/length(rd);\n       float drdnor = dot(rd, rec.normal);\n       float idx = world[rec.objidx].ref_idx;\n       if (drdnor > 0.0) {\n           outward_normal = -rec.normal;\n           ni_over_nt = idx;\n           csn = ni_over_nt * drdnor * il;\n       } else {\n           outward_normal = rec.normal;\n           ni_over_nt = 1.0/idx;\n           csn = -drdnor * il;\n       }\n       if (refract2(rd, outward_normal, ni_over_nt, refracted)) {\n           reflect_prob = schlick(csn, idx);\n       }\n       if (r.x < reflect_prob) {\n           scro = rec.p;\n           scrd = reflected;\n       } else {\n           scro = rec.p;\n           scrd = refracted;\n       }\n       return true;\n   } else if (mt == DiffuseLight) {\n       return false;\n   }\n}\n\nvec3 color(vec3 ro, vec3 rd, inout random_state rs) {   \n    vec3 emit_accum = vec3(0.0);\n    vec3 attenuation_accum = vec3(1.0);\n    vec3 albedo = vec3(0.0);\n    int depth = 0;\n    bool done = false;\n    while (!done) {\n        hit_record rec;\n        if (list_hit(ro, rd, 0.001, 1E9, rec)) {\n            vec3 scro, scrd;\n            vec3 attenuation;\n            vec3 emitcol = emitted(rec);\n            emit_accum += emitcol * attenuation_accum;\n            if (depth < 50 && scatter(rec, ro, rd, attenuation, scro, scrd, rs)) {\n                attenuation_accum *= attenuation;\n                ro = scro;\n                rd = scrd;\n                depth += 1;\n            } else {\n                done = true;\n            }\n        } else {\n            vec3 unit_direction = normalize(rd);\n            float t = 0.5 * (unit_direction.y + 1.0);\n            albedo = ((1.0-t)*vec3(1.0) + t*vec3(0.25,0.5,1.0));\n            emit_accum += attenuation_accum * albedo * 0.7;\n            done = true;\n        }    \n    }\n    \n    return emit_accum; //vec3(random0(rs), random1(rs), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize pseudo random number gen \n    random_state rs;\n    float time = iTime + 25.0*iMouse.x/iResolution.x;\n    init_random(fragCoord, time+iMouse.y, rs);\n    \n    vec3 col = vec3(0.0);\n    \n    // Sample\n    int ns = SAMPLES;\n    for (int s=0; s<ns; s++) {\n        //world[6].center.y = 1.0+sin(time);\n        // Camera init\n        float orbit_radius = 6.0;\n        vec3 look_from = vec3(orbit_radius * sin(0.1*time), 1.5+cos(time*0.1)+5.0*iMouse.y/iResolution.y, orbit_radius*cos(0.1*time));\n        vec3 look_at = vec3(0.0);\n        float focus_dist = length(look_from - look_at) - 2.0;\n        float aspect = iResolution.x/iResolution.y;\n        vec3 vup = vec3(0.0,1.0,0.0);\n        float aperture = APERTURE; \n        float lens_radius = aperture * 0.5;\n        float vfov = 35.0;\n        float theta = vfov*M_PI/180.0;\n        float half_height = tan(theta*0.5);\n        float half_width = aspect * half_height;\n        vec3 origin = look_from;\n        vec3 w = normalize(look_from - look_at);\n        vec3 u = normalize(cross(vup, w));\n        vec3 v = cross(w, u);\n        vec3 lower_left_corner = origin - half_width * focus_dist * u - half_height*focus_dist*v - focus_dist*w;\n        vec3 horizontal = 2.0 * half_width * focus_dist* u;\n        vec3 vertical = 2.0 * half_height * focus_dist *v;\n        \n        // Generate a ray\n        vec2 st = vec2(fragCoord.x/iResolution.x + 1.0*random0(rs)/iResolution.x,\n                      fragCoord.y/iResolution.y + 1.0*random1(rs)/iResolution.y);\n        vec3 rd = lens_radius * random_in_unit_disk(rs);\n        vec3 offset = u*rd.x + v*rd.y;\n        vec3 ro = origin + offset;\n        rd = lower_left_corner + st.x*horizontal + st.y*vertical - origin - offset;\n        \n        // Sample from the scene along that ray\n        col += color(ro, rd, rs);\n        \n        time += 1.0/(30.0*float(ns)); // Motion blur        \n    }\n    col *= (1.0/float(ns));\n    col = pow(col, vec3(1.0/2.4)); // Gamma\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}