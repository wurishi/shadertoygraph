{"ver":"0.1","info":{"id":"4lVfzW","date":"1542026378","viewed":113,"name":"TestColor RayTracing Sphere","username":"defaultUser0","description":"Testing spheres and color","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracingspherecolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEP_SIZE .1\n#define NUMBER_OF_STEPS 32\n#define MINIMUM_HIT_DISTANCE .001\n#define MAXIMUM_TRACE_DISTANCE 1000.\n#define SMALL_STEP vec3(.001, 0., 0.)\n#define SQRT2 1.41421356237\n#define SQRT13 3.60555127546\n#define NB_THRESHOLDS 100.\n#define PI 3.14159265359\n#define AA_SAMPLES_X 4.\n\n#define sph(p, c, r) length(p-c)-r\n\n\n// params:\n// p: arbitrary point in 3D space\n// c: the center of our sphere\n// r: the radius of our sphere\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h/(6.0*k*k);\n}\n\nfloat SDF(in vec3 p){\n    //float displacement = 0.;//sin(5. * p.x) * sin(5. * p.y) * sin(5. * p.z) * 0.25;\n        \n \tfloat sphere_0 = sph(p, vec3(0.), 1.);\n    \n    float sphere_1 = sph(p, vec3(1.5*sin(iTime),1.5*sin(iTime),-1.), 0.5);\n    \n    //Later we might have sphere_1, sphere_2, cube_3, etc...\n    \n    return sminCubic(sphere_0, sphere_1, 1.5);\n}\n\nvec3 calculate_normal(in vec3 p){\n    return normalize(vec3(\n    SDF(p + SMALL_STEP.xyy) - SDF(p - SMALL_STEP.xyy),\n    SDF(p + SMALL_STEP.yxy) - SDF(p - SMALL_STEP.yxy),\n    SDF(p + SMALL_STEP.yyx) - SDF(p - SMALL_STEP.yyx)));\n}\n    \nvec3 ray_march(in vec3 ro, in vec3 rd){\n\tfloat total_distance_traveled = 0.;\n    // Ray Marching\n    for (int i = 0; i < NUMBER_OF_STEPS ; ++i){\n        // Calculate our current posiiton along the ray\n        vec3 current_position = ro + total_distance_traveled * rd;\n        \n        // Sphere centered at the origin and has unit radius\n        float distance_to_closest = SDF(current_position);\n        \n        if (distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            vec3 normal = calculate_normal(current_position);\n            \n            // for now hard-code the ligth's position in our scene\n            vec3 light_position = vec3(SQRT13*cos(2.*iTime), -5.0, SQRT13*sin(2.*iTime));\n            vec3 light_color = vec3(1., 0., 0.);\n            \n            //Calculate the unit direction vector that point from\n            // the point of intersection to the light source\n            vec3 direction_to_light = normalize(current_position - light_position);\n            \n            float diffuse_intensity = max(0., floor(dot(normal, direction_to_light)*NB_THRESHOLDS)/NB_THRESHOLDS);\n            \n            // for now hard-code the ligth's position in our scene\n            vec3 light_position2 = vec3(SQRT13*cos(2.*iTime + 2.*PI/3.), -5.0, SQRT13*sin(2.*iTime + 2.*PI/3.));\n            vec3 light_color2 = vec3(0., 0., 1.);\n            \n            //Calculate the unit direction vector that point from\n            // the point of intersection to the light source\n            vec3 direction_to_light2 = normalize(current_position - light_position2);\n            \n            float diffuse_intensity2 = max(0., floor(dot(normal, direction_to_light2)*NB_THRESHOLDS)/NB_THRESHOLDS);\n            \n            // for now hard-code the ligth's position in our scene\n            vec3 light_position3 = vec3(SQRT13*cos(2.*iTime + 4.*PI/3.), -5.0, SQRT13*sin(2.*iTime+ 4.*PI/3.));\n            vec3 light_color3 = vec3(0., 1., 0.);\n            \n            //Calculate the unit direction vector that point from\n            // the point of intersection to the light source\n            vec3 direction_to_light3 = normalize(current_position - light_position3);\n            \n            float diffuse_intensity3 = max(0., floor(dot(normal, direction_to_light3)*NB_THRESHOLDS)/NB_THRESHOLDS);\n            \n         \t// we hit something ! Return red for now\n            return clamp(vec3(1.,1.,1.)*(diffuse_intensity * light_color + diffuse_intensity2 * light_color2 + diffuse_intensity3 * light_color3), vec3(0.), vec3(1.));\n        }\n        \n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE) //miss\n        {\n         \tbreak;   \n        }\n        \n        // accumulate the distance traveled thus far\n        total_distance_traveled += distance_to_closest;\n    }\n    \n    // If we get here, we didn't hit anything so just\n    // rerturn a background color (black)\n    return vec3(0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    // Normalized pixel coordinates (from -1 to 1) and normalize\n    vec2 uv = 2.*fragCoord.xy/iResolution.x - vec2(1., iResolution.y/iResolution.x);\n    float delta = 2./iResolution.x;\n    \n    vec3 camera_position  = vec3(0., 0., -5. - 0.*sin(iTime));\n    vec3 ro = camera_position;\n    vec3 rd;\n    \n\n\t// ANTI ALIASING ALGORITHM\n    vec3 shaded_color = vec3(0);\n    for (float i=0. ; i < AA_SAMPLES_X * AA_SAMPLES_X ; i++){\n        //rd = vec3(uv, 1.0);\n        rd = vec3(uv.x + delta/2. * (floor(i/AA_SAMPLES_X) - 0.5), uv.y + delta/2. * (mod(i,AA_SAMPLES_X) - 0.5),1.0);\n        shaded_color += ray_march(ro, rd);\n    }\n    shaded_color /= AA_SAMPLES_X * AA_SAMPLES_X;\n    \n\n    // Output to screen\n    fragColor = vec4(shaded_color,1.0);\n}","name":"Image","description":"","type":"image"}]}