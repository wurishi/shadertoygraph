{"ver":"0.1","info":{"id":"stXcz8","date":"1648451667","viewed":248,"name":"nyan cat visualizer","username":"MrHAX00","description":"Something i've been working on for a while and trying out different things on.\n\nThe blur effect isnt perfect and could definitely be optimized so next time i'll see what can be done about it.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["blur","space","visualizer","stars","rainbow","nyancat","song","songvisualiser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Smooth HSV to RGB conversion from shadertoy.com/view/MsS3Wc\nvec3 hsv(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n\n\trgb = rgb*rgb*(3. - 2. * rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.), rgb, c.y);\n}\n\n/*/Calculate the circle\nvec4 DrawCircle(vec2 uv, float Rotate) {\n    mat2 m = mat2(cos(Rotate), -sin(Rotate), sin(Rotate), cos(Rotate));\n   \tuv = m * uv;\n    float Length = length(uv);\n    float Angle = .5 - (acos(dot(vec2(1., 0.), uv / Length)) / pi) * .5;\n    if (uv.y <= 0.) {\n        Angle = .5 - Angle + .5;\n    }\n    \n    float Freq = texelFetch(iChannel0, ivec2(floor(Angle * 20.) * 25.6, 0.), 0).x;\n    \n    Length = floor(Length * Length * 10.) * .1;\n    \n    if (Length > 1.) {\n        Length = Length - 1.;\n    } else {\n        Length = 1. - Length;\n    }\n    if (Length < Freq) {\n        Length = clamp(1. - Length, 0., 1.) * Freq; \n    } else {\n        Length = 0.;\n    }\n    \n    return vec4(hsv(vec3(iTime + Angle * (mod(floor(Angle * 20.), Freq) + 1.), 1., 1.)), Length);\n}*/\n\nvec3 GetStarGrid(vec2 Coord) {\n    Coord.x *= Coord.y * .05;\n    return vec3(\n        mod(Coord.r, mod(Coord.r / Coord.g, mod(Coord.r, .9))), //Radius\n        cos(Coord.r * Coord.g * pi) * .3, //x offset\n        -cos(Coord.r * Coord.g * Coord.r * Coord.g) * .3 //y offset\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    float Ratio = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord/iResolution.xy - vec2(.5));\n    uv.x *= Ratio;\n    uv *= 3.;\n    \n    //Rotation\n    float Rotate = 0.;\n    \n    for (int Type = 0; Type <= 1; Type++) {\n        for (int i = 0; i <= 20; i++) {\n            float Loudness = texelFetch(iChannel0, ivec2(i, Type), 0).x;\n            if (Loudness > Rotate) {\n                Rotate = Loudness;\n            }\n        }\n    }\n    \n    uv *= Rotate; //Zoom depending on rotation amount\n    \n    //Rotation is from https://www.shadertoy.com/view/XlsGWf (i cant just change the angle because i need to have a degree between 0 and 360 not 0 and 180)\n    float RadialRotate = mod(Rotate * .5 - .5, 2.) * pi;\n    mat2 m = mat2(cos(RadialRotate), -sin(RadialRotate), sin(RadialRotate), cos(RadialRotate));\n   \tuv = m * uv;\n    \n    float Wave = texelFetch(iChannel0, ivec2(mod(floor(uv.x * 12.8 + 25.6) * 10., 512.), 0.), 0).x;\n    \n    //Stars\n    vec2 ExactPos = mod(vec2(uv.x / Ratio, uv.y) * iResolution.xy * .00625 + vec2(iTime * 3., 0.), iResolution.xy);\n    vec2 StarPos = round(ExactPos);\n    \n    vec3 StarData = GetStarGrid(StarPos);\n    vec4 Stars = vec4(smoothstep(StarData.r + .01, StarData.r - .01, length(StarPos + StarData.yz - ExactPos) * (cos(iTime) * 2. + 8.)));\n    \n    //Bars\n    float Length = floor(uv.y * uv.y * 10.) * .1;\n    if (Length > Wave) {\n        Length = clamp(1. - Length, 0., 1.) * Wave;\n    } else {\n        Length = 0.;\n    }\n    \n    vec3 Apply = hsv(vec3(iTime + uv.x * Wave, Length - 2., Rotate - Length));\n    \n    vec4 Bars = vec4(Apply, Length);\n    \n    \n    vec4 Got = texelFetch(iChannel2, ivec2(vec2(mod(uv.x - iTime, .6666666), uv.y +.25) * 64.), 0);\n    Bars = mix(mix(Bars, Got , Got.w * Rotate * .875), Stars, Stars.w);\n    \n    //Blur\n    vec4 Blur = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    for (int X = -1; X <= 1; X += 2) {\n        for (int Y = -1; Y <= 1; Y += 2) {\n            Blur += texelFetch(iChannel1, ivec2(fragCoord) + ivec2(X, Y), 0);\n        }\n    }\n    Blur /= 5.15;\n    // Output to screen\n    fragColor = mix(Blur, Bars, Bars.w);\n}","name":"Buffer A","description":"","type":"buffer"}]}