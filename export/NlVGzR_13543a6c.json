{"ver":"0.1","info":{"id":"NlVGzR","date":"1637161265","viewed":372,"name":"hexagon_wave","username":"skaplun","description":"simple grayscale animation\nlighting by @iq","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO (min(iFrame,0))\n\nfloat wave(vec2 xy) {\n    return smoothstep(1., 3., distance(length(xy), fract(iTime * .75) * 20.));\n}\n\nfloat map(vec3 p){\n    vec4 hexx = hexCoord(p.xz * 5.);\n    float h = hexx.y - .01;\n    h = max(-h, p.y - wave(hexx.zw) * .2 + pow(smoothstep(.075, 0., hexx.y), 2.) * .01);\n    h = min(p.y + .2, h);\n    return h;\n}\n\nconst float epsilon = 0.0001;\nvec3 calculateNormals(vec3 pos){\n    vec2 eps = vec2(0.0, epsilon);\n    vec3 n = normalize(vec3(\n    map(pos + eps.yxx) - map(pos - eps.yxx),\n    map(pos + eps.xyx) - map(pos - eps.xyx),\n    map(pos + eps.xxy) - map(pos - eps.xxy)));\n    return n;\n}\n\nconst int stepsCnt = 128;\nfloat marchRay(in Ray r){\n    float t = (.2 - r.origin.y)/r.dir.y;\n    for(int i = 0; i <= stepsCnt; i++){\n        vec3 p = r.origin + r.dir * t;\n        float dst = map(p);\n        \n        if(dst < .001)\n            return t;\n        \n        t += dst * .5;\n    }\n    return -1.;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12 * float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.01, 0.011 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 makeClr(vec2 fragCoord){\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    float ang = (iResolution.y - iMouse.y) * .01 / 3.1415;\n    vec3 origin = vec3(0., max(3. * cos(ang), 2.5), -3. * sin(ang));\n    //vec3 origin = vec3(0., 3., 0.);\n    mat4 viewToWorld = viewMatrix(origin, vec3(0.), vec3(0., 0., 1.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    Ray camRay = Ray(origin, dir);\n    float hit = marchRay(camRay);\n\n    vec3 col;\n    {\n        vec3 pos = origin + dir * hit;\n        vec3 nor = calculateNormals(pos);\n        vec3 ref = reflect( dir, nor );\n        col = vec3(1.);\n        \n        \n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n        float ks = 1.0;\n        \n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.1, 0.5) );\n            vec3  hal = normalize( lig - dir );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.0,1.00,1.0);\n            lin +=     5.00*spe*vec3(1.0,1.00,1.0) * ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor, dir),0.0,1.0), 5.0 );\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.60,0.60,1.);\n            lin +=     2.00*spe*vec3(0.60,0.60,1.)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor, dir),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*hit*hit*hit ) );\n        \n    }\n    return col;\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(makeClr(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_FLOAT 1e5\n#define MIN_FLOAT 1e-5\nconst float PI = acos(-1.);\n\nstruct Ray{ vec3 origin, dir;};\nstruct Hit{ float dst; int id; vec3 nrm;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nfloat hexDistance(in vec2 p){\n\tp = abs(p);\n    float h = dot(p, normalize(vec2(1., 1.73)));\n    return max(h, p.x);\n}\n\nvec4 hexCoord(in vec2 uv){\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * .5;\n    \n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv-h, r) - h;\n    \n    vec2 gv;\n    if(length(a) < length(b))\n        gv = a;\n    else\n        gv = b;\n    \n    float x = atan(-gv.y, gv.x) + PI;\n    float y = .5 - hexDistance(gv);\n    return vec4(x, y, uv - gv);\n}","name":"Common","description":"","type":"common"}]}