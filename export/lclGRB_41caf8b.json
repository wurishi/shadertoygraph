{"ver":"0.1","info":{"id":"lclGRB","date":"1703307199","viewed":64,"name":"Double-slit experiment classical","username":"zenzicubic","description":"A redo of my old wave equation sim, with damping and a double slit. You might want to use the extension to speed this up 4x.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["wave","physics","pde"],"hasliked":0,"parentid":"dsjSzR","parentname":"The 2D wave equation"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nSolving the (damped) wave equation in a rectangular region with a capsule emitter and\na double slit. This models the double-slit experiment, and one can see the distribution \npretty well. We use Dirichlet boundary conditions and Verlet integration.\n*/\n\nbool inEmitter(vec2 p) {\n    vec2 prj = vec2(-.5, clamp(p.y, -.5, .5));\n    return (distance(p, prj) < .025);\n}\n\nbool onBoundary(vec2 p) {\n    return (p.x > -.025 && p.x < .025) && !(abs(p.y) > .2 && abs(p.y) < .3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = (texelFetch(iChannel0, ivec2(fragCoord), 0).x + 1.);\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    if (onBoundary(p)) {\n        fragColor = vec4(.3);\n        return;\n    } else if (inEmitter(p)) {\n        fragColor = vec4(1.);\n        return;\n    }\n    \n    // The Viridis color map\n    vec3 c = mix(vec3(.3, .3, 1.), vec3(.1), clamp(t, 0., 1.));\n    c = mix(c, vec3(1., .3, .3), clamp(t - 1., 0., 1.));\n    fragColor = vec4(c, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DT 0.25\n#define C 1.\n#define D 7.5e-3\n\nbool inEmitter(vec2 p) {\n    p = (2. * p - iResolution.xy) / iResolution.y;\n    vec2 prj = vec2(-.5, clamp(p.y, -.5, .5));\n    return (distance(p, prj) < .025);\n}\n\nbool onBoundary(vec2 p) {\n    p = (2. * p - iResolution.xy) / iResolution.y;\n    return (p.x > -.025 && p.x < .025) && !(abs(p.y) > .2 && abs(p.y) < .3);\n}\n\nbool onEdge(vec2 p) {\n    return (p.x < 0. || p.x > iResolution.x || p.y < 0. || p.y > iResolution.y);\n}\n\nfloat samp(vec2 p) {\n    if (onBoundary(p) || onEdge(p)) return 0.;\n    return texelFetch(iChannel0, ivec2(p), 0).x;\n}\n\nfloat laplace(vec2 p)\n{\n    float s = -samp(p);\n    \n    s += 0.2 * samp(p + vec2(0., -1.));\n    s += 0.2 * samp(p + vec2(0., 1.));\n    s += 0.2 * samp(p + vec2(-1., 0.));\n    s += 0.2 * samp(p + vec2(1., 0.));\n    s += 0.05 * samp(p + vec2(1., -1.));\n    s += 0.05 * samp(p + vec2(1., 1.));\n    s += 0.05 * samp(p + vec2(-1., 1.));\n    s += 0.05 * samp(p + vec2(-1., -1.));\n    \n    return s;\n}\n\nvoid mainImage( out vec4 v, in vec2 p )\n{\n    v = vec4(0.);\n    \n    if (inEmitter(p))\n    {\n        v.x = v.y = 2. * sin(10. * iTime);\n    }\n    else if (onEdge(p)) {\n        v = vec4(0.);\n    }\n    else \n    {\n        vec2 s = texelFetch(iChannel0, ivec2(p), 0).xy;\n        float vel = (s.x - s.y) / DT;\n        float a = C * C * laplace(p) - D * vel;\n  \n        v.x = 2. * s.x - s.y + DT * DT * a;\n        v.y = s.x;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}