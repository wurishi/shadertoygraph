{"ver":"0.1","info":{"id":"XtdSDB","date":"1624170844","viewed":265,"name":"Simple Skybox with Spheres","username":"gPlatl","description":"Basic frame for a simple interactive skybox view.\nChange view by moving around with your mouse.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","simple","interactive","cubemap","skybox","view"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//---------------------------------------------------------\n// SimpleSkyboxWithSpheres.glsl   by Gerd Platl\n//\n// Basic frame for a simple interactive skybox view\n// with antialiased spheres.\n// Change view by moving around with your mouse.\n//\n//   v1.0  2016-12-11  initial version\n//   v1.1  2021-06-20  sphere antialiasing added\n//\n// tags: 3d, simple, interactive, skybox, view, cubemap, raymarcher\n//---------------------------------------------------------\n\n// spheres\n\nconst vec4  skyboxColor  = vec4(0.80, 0.96, 1.00, 1.0);\nconst vec4  sphere1Color = vec4(0.80, 0.70, 0.70, 1.0);\nconst vec4  sphere2Color = vec4(0.70, 0.90, 0.80, 1.0);\nconst vec4  sphere3Color = vec4(0.90, 0.60, 0.60, 1.0);\nconst vec4  sphere4Color = vec4(0.80, 0.90, 0.40, 1.0);\nconst vec4  sphere5Color = vec4(0.60, 0.70, 0.90, 1.0);\n\nstruct sSphere { vec3 position; float radius; vec4 color; };\nsSphere sphere1 = sSphere(vec3( 0.0, 0.0, 0.0), 2.22, sphere1Color);\nsSphere sphere2 = sSphere(vec3( 0.0, 3.5, 0.0), 0.60, sphere2Color);\nsSphere sphere3 = sSphere(vec3( 0.0,-3.5, 0.0), 0.60, sphere3Color);\nsSphere sphere4 = sSphere(vec3(-3.5, 0.0, 0.0), 0.60, sphere4Color);\nsSphere sphere5 = sSphere(vec3( 3.5, 0.0, 0.0), 0.60, sphere5Color);\n\n// get sphere distance\nfloat Sphere(vec3 p, sSphere sph)\n{ \n  return length(p) - sph.radius; \n}\n\n//---------------------------------------------------------\n// rotations\n//---------------------------------------------------------\nvec3 rotateX(vec3 p, float angle)\n{ float sa = sin(angle);\n  float ca = cos(angle);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n\nvec3 rotateY(vec3 p, float angle)\n{ float sa = sin(angle);\n  float ca = cos(angle);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{ float sa = sin(angle);\n  float ca = cos(angle);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n//---------------------------------------------------------\nstruct sHit     // ray hit \n{ float dist;   // distance\n  vec4 color;   \n};\nsHit hit = sHit (99999., vec4(1.0));            \n//---------------------------------------------------------\nvoid minDistance (vec3 pos, sSphere sphere)\n{ \n  vec3 rp = rotateZ (pos+sphere.position, iTime);\n  float sd = Sphere(rp, sphere);\n  if (sd > hit.dist) return;     // if no hit -> return \n  hit.color = sphere.color;      // save color\n  hit.dist  = sd;                // save distance\n}  \n//---------------------------------------------------------\nfloat map(vec3 pos)\n{\n  hit.dist = 9999.;\n  minDistance(pos, sphere1);\n  minDistance(pos, sphere2);\n  minDistance(pos, sphere3);\n  minDistance(pos, sphere4);\n  minDistance(pos, sphere5);\n  return hit.dist;\n}\n//---------------------------------------------------------\n// trace ray from rayOrigin in rayDirection\n// return minimal distance\n//---------------------------------------------------------\nfloat trace(vec3 ro, vec3 rd) \n{\n  float d = 0.0, t = 0.0;\n  for(int i = 0; i < 32; ++i) \n  {\n    vec3 pos = ro + t * rd;\n    float d = map(pos);\n\n    if(abs(d) < 0.01) return t;\n    if(t > 100.0) return -1.0;\n    t += d;\n  }\n  return -1.0;\n}\n//---------------------------------------------------------\n// get surface normal vector\n//---------------------------------------------------------\nvec3 getNormal( in vec3 pos )\n{\n  float d = map(pos);\n  vec3 eps = vec3( 0.001, 0.0, 0.0 );\n  return normalize(vec3(d - map(pos-eps.xyy), \n                        d - map(pos-eps.yxy), \n                        d - map(pos-eps.yyx) ));\n}\n//---------------------------------------------------------\n// get camera transformation matrix\n//---------------------------------------------------------\nmat3 getCamera(vec3 ro) \n{\n  vec3 z = normalize(ro);\n  vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n  return mat3(x, cross(z, x), z);\n}\n//---------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n  vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.y * 4.5;\n  vec3 ro = 5.5 * vec3(sin(mo.x), 2.0-mo.y, cos(mo.x));\n  vec3 rd = getCamera(ro) * vec3(uv, -0.94);\n  \n  fragColor = texture(iChannel0, rd) * skyboxColor;  // get skybox color\n  float t = trace(ro, rd);  // trace scenery\n  if(t > 0.0)               // sphere hit ?\n  { \n    // handle sphere intersection\n    vec3 p = ro + t * rd;   // get intersection point\n    vec3 n = getNormal(p);  // surface normal\n    rd = reflect(rd, n);    // reflection vector\n\n    vec4 refColor = texture(iChannel0, rd) * hit.color;\n    float d = 3.2 * dot(rd, n);   // antialiasing with skybox\n    fragColor = mix(fragColor, refColor, smoothstep(0.,1.,d));\n  }\n  // fragColor = vec4(sin(rd*22.), 1.0);  // funny colors 1\n  // fragColor = vec4(mod(rd,1.0) ,1.0);  // funny colors 2\n}\n","name":"Image","description":"","type":"image"}]}