{"ver":"0.1","info":{"id":"43l3D7","date":"1707732531","viewed":32,"name":"[inspirnathan] 13 - SDF op","username":"hrst4","description":"[inspirnathan] 13 - SDF op","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/60-shadertoy-tutorial-part-14/\n#define PART 14\n\n/*\nSalutations, mes amis ! Bienvenue dans la 14ème partie de ma série de tutoriels Shadertoy ! \nVous êtes-vous déjà demandé comment les gens dessinent des formes et des scènes complexes dans Shadertoy ?\nNous avons appris à créer des sphères et des cubes, mais qu'en est-il des objets plus compliqués ?\n\nDans ce tutoriel, nous allons apprendre à utiliser les opérations SDF popularisées\npar le talentueux Inigo Quilez, l'un des co-créateurs de Shadertoy !\n\n# Setup initial\nCi-dessous, j'ai créé un modèle de ray marching qui peut s'avérer utile pour vous si vous envisagez de développer des modèles 3D\nen utilisant Shadertoy et le ray marching. Nous commencerons par ce code pour ce tutoriel.\n\nLorsque vous exécutez ce code, vous devez voir une sphère apparaître au centre de l'écran.\n*/\n\n#if PART == 0\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat scene(vec3 p) {\n  return sdSphere(p, 1., vec3(0, 0, 0));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nAnalysons le code pour nous assurer que nous comprenons bien le fonctionnement de ce modèle de ray marchings.\nAu début du code, nous définissons des constantes que nous avons apprises dans la partie 6 de cette série de tutoriels.\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nNous définissons la couleur de l'arrière-plan et la couleur de la lumière ambiante à l'aide de variables,\nafin de pouvoir modifier rapidement l'aspect de l'objet 3D en fonction des couleurs.\n\nEnsuite, nous définissons la fonction rotate2d pour faire pivoter un objet le long d'un plan 2D.\nCette fonction a été abordée dans la partie 10. Nous l'utiliserons pour déplacer la caméra autour de notre modèle 3D\nà l'aide de notre souris.\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nLes fonctions suivantes sont des fonctions utilitaires de base pour la création d'une scène 3D.\nNous avons appris à les connaître dans la partie 6, lorsque nous avons abordé le ray marching.\n\nLa fonction sdSphere est un SDF utilisé pour créer une sphère. \nLa fonction scene est utilisée pour rendre tous les objets de notre scène. \nVous pouvez souvent la voir appelée fonction map lorsque vous lisez le code d'autres personnes sur Shadertoy.\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat scene(vec3 p) {\n  return sdSphere(p, 1., vec3(0));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nEnsuite, nous avons la fonction caméra qui est utilisée pour définir notre modèle de caméra avec un point d'observation.\nCette fonction a été abordée dans la partie 10. \nLe modèle de caméra avec point de visée nous permet de pointer la caméra vers une cible.\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nAnalysons maintenant la fonction mainImage.\nNous configurons les coordonnées UV de manière à ce que les coordonnées des pixels soient comprises entre -0,5 et 0,5. \nNous tenons également compte de l'aspect ratio, ce qui signifie que l'axe des x aura des valeurs comprises entre différentes valeurs, \nmais toujours entre une valeur négative et une valeur positive.\n\nvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\nPuisque nous utilisons la souris pour tourner autour de l'objet 3D, nous devons définir les coordonnées mouseUV.\nNous les configurerons de manière à ce qu'elles se situent entre zéro et un lorsque nous cliquons sur le canvas.\n\nvec2 mouseUV = iMouse.xy/iResolution.xy;\n\nIl y a cependant un problème. Lorsque nous publions notre shader sur Shadertoy, et qu'un utilisateur charge notre shader \npour la première fois, les coordonnées commencent à (0, 0) pour les coordonnées mouseUV. \nNous pouvons \"tromper\" le shader en lui assignant une nouvelle valeur lorsque cela se produit.\n\nif (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\nEnsuite, nous déclarons une variable de couleur, col, avec une valeur de départ arbitraire.\nEnsuite, nous définissons le point d'observation, lp, et l'origine du rayon, ro. \nCe point a également été abordé dans la partie 10. \n\nNotre sphère n'a actuellement aucun décalage dans la fonction scene, elle est donc située à (0, 0, 0). \nNous devrions faire en sorte que le point d'observation ait la même valeur, mais nous pouvons l'ajuster si nécessaire.\n\nvec3 col = vec3(0);\nvec3 lp = vec3(0); // lookat point\nvec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n\nNous pouvons utiliser la souris pour tourner autour de la caméra, mais nous devons être conscients de la distance \nqui sépare la caméra de l'objet 3D. \n\nComme nous l'avons appris à la fin de la partie 10, nous pouvons utiliser la fonction rotate2d pour déplacer la caméra et \nutiliser cameraRadius pour contrôler la distance à laquelle se trouve la caméra.\n\nfloat cameraRadius = 2.;\nro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\nro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\nvec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\nJ'espère que cela a du sens ! Il existe d'autres façons d'implémenter les caméras sur Shadertoy.\nChaque personne les met en place de manière légèrement différente.\nChoisissez l'approche qui vous convient le mieux.\n\n# Opérations combinées 3D SDF\n\nMaintenant que nous comprenons le modèle de marche des rayons que je vous ai fourni, apprenons à connaître les opérations SDF 3D ! \nJ'ai abordé les opérations SDF 2D dans la partie 5 de cette série de tutoriels.\nLes opérations SDF 3D sont un peu similaires.\n\nNous utiliserons des fonctions utilitaires pour combiner des formes entre elles ou les soustraire les unes des autres.\nCes fonctions sont disponibles sur la page SDF 3D d'Inigo Quilez (https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm).\n\nDéfinissez les fonctions utilitaires en haut de votre code et utilisez-les à l'intérieur de la fonction scene.\n\nUnion : combiner deux formes ensemble ou afficher plusieurs formes à l'écran.\nNous devrions maintenant être familiarisés avec l'opération d'union. \nNous avons utilisé la fonction min pour dessiner plusieurs formes.\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  return opUnion(d1, d2);\n}\n\nhttps://inspirnathan.com/_nuxt/img/img-2.5205f5f.png\n*/\n#elif PART == 1\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  return opUnion(d1, d2);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nUnion lisse (smooth): combine deux formes et les mélange sur les bords à l'aide du paramètre k. \nUne valeur de k égale à zéro entraînera une opération d'union normale.\nhttps://inspirnathan.com/_nuxt/img/img-3.08fd406.png\n*/\n\n#elif PART == 2\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  return opSmoothUnion(d1, d2, 0.2);\n}\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n/*\nIntersection : ne prendre que la partie où les deux formes se croisent.\nhttps://inspirnathan.com/_nuxt/img/img-4.5a7b725.png\n*/\n#elif PART == 3\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  return opIntersection(d1, d2);\n}\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n/*\nIntersection lisse : combine deux formes et les mélange sur les bords à l'aide du paramètre k. \nUne valeur de k égale à zéro entraînera une opération d'intersection normale.\nhttps://inspirnathan.com/_nuxt/img/img-5.674bd00.png\n*/\n#elif PART == 4\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  return opSmoothIntersection(d1, d2, 0.2);\n}\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nSoustraction : soustraire d1 de d2.\nhttps://inspirnathan.com/_nuxt/img/img-6.cb07de4.png\n*/\n\n#elif PART == 5\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2 ) {\n  return max(-d1, d2);\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  return opSubtraction(d1, d2);\n}\n\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n/*\nSoustraction lissée : soustraire d1 de d2 de manière lissée sur les bords en utilisant k.\nhttps://inspirnathan.com/_nuxt/img/img-7.4546d20.png\n*/\n#elif PART == 6\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2 ) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  return opSmoothSubtraction(d1, d2, 0.2);\n}\n\n\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nSoustraction 2 : soustraire d2 de d1.\nhttps://inspirnathan.com/_nuxt/img/img-8.7523baf.png\n*/\n#elif PART == 7\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2 ) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction2(float d1, float d2 ) {\n  return max(d1, -d2);\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  return opSubtraction2(d1, d2);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nSoustraction lisse 2 : soustraire d2 de d1 en douceur sur les bords en utilisant k.\nhttps://inspirnathan.com/_nuxt/img/img-9.c120c79.png\n*/\n\n#elif PART == 8\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2 ) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction2(float d1, float d2 ) {\n  return max(d1, -d2);\n}\n\nfloat opSmoothSubtraction2(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  return opSmoothSubtraction2(d1, d2, 0.2);\n}\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\n# Opérations 3D positionnelles SDF\n\nLa page 3D SDFs d'Inigo Quilez (https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm)\ndécrit un ensemble d'opérations 3D SDF positionnelles que nous pouvons utiliser pour nous épargner du travail \nlorsque nous dessinons des objets 3D. \n\nCertaines de ces opérations permettent également de réduire les performances, puisque nous n'avons pas à exécuter \nla boucle de ray marching plusieurs fois.\n\nNous avons appris dans les tutoriels précédents à faire pivoter des formes à l'aide d'une matrice de transformation \net à translater des formes 3D à l'aide d'un décalage. \n\nSi vous devez mettre une forme à l'échelle, il vous suffit de modifier les dimensions du SDF.\n\nSi vous dessinez une scène symétrique, il peut être utile d'utiliser l'opération opSymX. \nCette opération crée un objet 3D dupliqué le long de l'axe x en utilisant le SDF que vous avez fourni.\nSi nous dessinons la sphère avec un décalage de vec3(1, 0, 0), une sphère équivalente sera dessinée à vec3(-1, 0, 0).\n\nhttps://inspirnathan.com/_nuxt/img/img-10.f432e20.png\n\n*/\n\n#elif PART == 9\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2 ) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction2(float d1, float d2 ) {\n  return max(d1, -d2);\n}\n\nfloat opSmoothSubtraction2(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\nfloat opSymX(vec3 p, float r, vec3 o)\n{\n  p.x = abs(p.x);\n  return sdSphere(p, r, o);\n}\n\nfloat scene(vec3 p) {\n  return opSymX(p, 1., vec3(1, 0, 0));\n}\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nSi vous souhaitez utiliser la symétrie le long de l'axe y ou de l'axe z, vous pouvez remplacer p.x par p.y ou p.z, \nrespectivement. N'oubliez pas d'ajuster également le décalage de la sphère.\n\nSi vous souhaitez dessiner des sphères le long de deux axes au lieu d'un seul, vous pouvez utiliser l'opération opSymXZ. \nCette opération crée un double le long du plan XZ, ce qui donne quatre sphères. \n\nSi nous dessinons une sphère avec un décalage de vec3(1, 0, 1), une sphère sera dessinée à vec3(1, 0, 1), vec3(-1, 0, 1),\nvec3(1, 0, -1) et vec3(-1, 0, -1).\nhttps://inspirnathan.com/_nuxt/img/img-11.7a00c8e.png\n*/\n\n#elif PART == 10\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2 ) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction2(float d1, float d2 ) {\n  return max(d1, -d2);\n}\n\nfloat opSmoothSubtraction2(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\nfloat opSymX(vec3 p, float r, vec3 o)\n{\n  p.x = abs(p.x);\n  return sdSphere(p, r, o);\n}\n\nfloat opSymXZ(vec3 p, float r, vec3 o)\n{\n  p.xz = abs(p.xz);\n  return sdSphere(p, r, o);\n}\n\nfloat scene(vec3 p) {\n  return opSymXZ(p, 1., vec3(1, 0, 1));\n}\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nParfois, vous souhaitez créer un nombre infini d'objets 3D sur un ou plusieurs axes. \nVous pouvez utiliser l'opération opRep pour répéter des sphères le long des axes de votre choix.\n\nLe paramètre c est un vecteur utilisé pour contrôler l'espacement entre les objets 3D le long de chaque axe.\nhttps://inspirnathan.com/_nuxt/img/img-12.7efdd69.png\n*/\n\n#elif PART == 11\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2 ) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction2(float d1, float d2 ) {\n  return max(d1, -d2);\n}\n\nfloat opSmoothSubtraction2(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\nfloat opSymX(vec3 p, float r, vec3 o)\n{\n  p.x = abs(p.x);\n  return sdSphere(p, r, o);\n}\n\nfloat opSymXZ(vec3 p, float r, vec3 o)\n{\n  p.xz = abs(p.xz);\n  return sdSphere(p, r, o);\n}\n\nfloat opRep(vec3 p, float r, vec3 o, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSphere(q, r, o);\n}\n\nfloat scene(vec3 p) {\n  return opRep(p, 1., vec3(0), vec3(8));\n}\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nSi vous souhaitez répéter les objets 3D seulement un certain nombre de fois au lieu d'un nombre infini, \nvous pouvez utiliser l'opération opRepLim. \n\nLe paramètre, c, est maintenant une valeur flottante et contrôle toujours l'espacement entre chaque objet 3D répété.\nLe paramètre l est un vecteur qui vous permet de contrôler combien de fois la forme doit être répétée le long d'un axe donné. \nPar exemple, une valeur de vec3(1, 0, 1) dessinerait une sphère supplémentaire le long des axes x et z positifs et négatifs.\n\nhttps://inspirnathan.com/_nuxt/img/img-13.45e16a5.png\n\n*/\n\n#elif PART == 12\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2 ) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction2(float d1, float d2 ) {\n  return max(d1, -d2);\n}\n\nfloat opSmoothSubtraction2(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\nfloat opSymX(vec3 p, float r, vec3 o)\n{\n  p.x = abs(p.x);\n  return sdSphere(p, r, o);\n}\n\nfloat opSymXZ(vec3 p, float r, vec3 o)\n{\n  p.xz = abs(p.xz);\n  return sdSphere(p, r, o);\n}\n\nfloat opRep(vec3 p, float r, vec3 o, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSphere(q, r, o);\n}\n\nfloat opRepLim(vec3 p, float r, vec3 o, float c, vec3 l)\n{\n  vec3 q = p-c*clamp(round(p/c),-l,l);\n  return sdSphere(q, r, o);\n}\n\nfloat scene(vec3 p) {\n  return opRepLim(p, 0.5, vec3(0), 2., vec3(1, 0, 1));\n}\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nVous pouvez également déformer un SDF en manipulant la valeur de p et en l'ajoutant à la valeur renvoyée par le SDF.\nDans l'opération opDisplace, vous pouvez créer n'importe quel type d'opération mathématique pour déplacer la valeur de p, \npuis ajouter ce résultat à la valeur originale renvoyée par un SDF.\n\nhttps://inspirnathan.com/_nuxt/img/gif-1.499f4d6.gif\n*/\n\n#elif PART == 13\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1,d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2 ) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction2(float d1, float d2 ) {\n  return max(d1, -d2);\n}\n\nfloat opSmoothSubtraction2(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\nfloat opSymX(vec3 p, float r, vec3 o)\n{\n  p.x = abs(p.x);\n  return sdSphere(p, r, o);\n}\n\nfloat opSymXZ(vec3 p, float r, vec3 o)\n{\n  p.xz = abs(p.xz);\n  return sdSphere(p, r, o);\n}\n\nfloat opRep(vec3 p, float r, vec3 o, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSphere(q, r, o);\n}\n\nfloat opRepLim(vec3 p, float r, vec3 o, float c, vec3 l)\n{\n  vec3 q = p-c*clamp(round(p/c),-l,l);\n  return sdSphere(q, r, o);\n}\n\nfloat opDisplace(vec3 p, float r, vec3 o)\n{\n  float d1 = sdSphere(p, r, o);\n  float d2 = sin(p.x)*sin(p.y)*sin(p.z) * cos(iTime);\n  return d1 + d2;\n}\n\nfloat scene(vec3 p) {\n  return opDisplace(p, 1., vec3(0));\n}\n\n\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n/*\nVous trouverez ci-dessous le code complet, y compris un exemple de chaque opération SDF 3D.\n*/\n#elif PART == 14\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction2(float d1, float d2) {\n  return max(d1, -d2);\n}\n\nfloat opSmoothSubtraction2(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\nfloat opSymX(vec3 p, float r, vec3 o)\n{\n  p.x = abs(p.x);\n  return sdSphere(p, r, o);\n}\n\nfloat opSymXZ(vec3 p, float r, vec3 o)\n{\n  p.xz = abs(p.xz);\n  return sdSphere(p, r, o);\n}\n\nfloat opRep(vec3 p, float r, vec3 o, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSphere(q, r, o);\n}\n\nfloat opRepLim(vec3 p, float r, vec3 o, float c, vec3 l)\n{\n  vec3 q = p-c*clamp(round(p/c),-l,l);\n  return sdSphere(q, r, o);\n}\n\nfloat opDisplace(vec3 p, float r, vec3 o)\n{\n  float d1 = sdSphere(p, r, o);\n  float d2 = sin(p.x)*sin(p.y)*sin(p.z) * cos(iTime);\n  return d1 + d2;\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  //return d1;\n  //return d2;\n  //return opUnion(d1, d2);\n  //return opSmoothUnion(d1, d2, 0.2);\n  //return opIntersection(d1, d2);\n  //return opSmoothIntersection(d1, d2, 0.2);\n  //return opSubtraction(d1, d2);\n  //return opSmoothSubtraction(d1, d2, 0.2);\n  //return opSubtraction2(d1, d2);\n  //return opSmoothSubtraction2(d1, d2, 0.2);\n  //return opSymX(p, 1., vec3(1, 0, 0));\n  //return opSymXZ(p, 1., vec3(1, 0, 1));\n  //return opRep(p, 1., vec3(0), vec3(8));\n  //return opRepLim(p, 0.5, vec3(0), 2., vec3(1, 0, 1));\n  return opDisplace(p, 1., vec3(0));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n#endif","name":"Image","description":"","type":"image"}]}