{"ver":"0.1","info":{"id":"dslXR7","date":"1669014059","viewed":105,"name":"Grid + Wave","username":"czhowlll","description":"wave + grid","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedrual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Grid\n#define GRID_NUMS               vec2(16.0, 9.0)         // (x, y) numbers of grids\n#define GRID_LINE_WIDTH         0.1                     // 0.0 ~ 1.0, proportional to grid size\n#define GRID_LINE_COLOR         vec3(0.5, 0.5, 0.5)\n#define GRID_BACKGROUND_COLOR   vec3(0.1, 0.3, 0.5)\n\n// Wave (Cosine)         \n#define WAVE_FREQUENCY          10.141                  // scale on x, when it's PI the wave's 1 period length = viewport width\n#define WAVE_AMPLITUDE          0.2                     // scale on y, proportional to viewport height\n#define WAVE_OFFSET             0.1                     // offset on y, proportional to viewport height\n#define WAVE_LINE_WIDTH         0.3                     // 0.0 ~ 0.5, proportional to viewport height\n#define WAVE_PHASE              1.0                     // offset on x\n#define WAVE_COLOR              vec3(1.02, 0.51, 0.63)\n\n// Wave Glowing\n#define WAVE_GLOW               1                       // whether the wave is glowing, 1: enable, 0: disable\n#define WAVE_GLOW_EXPONENT      30.0                    // spread of the glowing effect, larger number is smaller spread\n#define WAVE_GLOW_STRENGTH      2.0                     // strength of the glowing effect \n\n// Animations & Effects      \n#define WAVE_ANIMATED           1                       // whether the wave moving in x direction, 1: enable, 0: disable\n#define WAVE_SPEED              0.2                     // speed of the movement of the wave\n#define GLITCH_ANIMATED         1                       // whether there is a glitch effect, 1: enable, 0: disable\n#define GLITCH_STRENGTH         1.5                     // strength of the glitch effect\n#define SCAN_LINE               1                       // whether there is a scan line effect, 1: enable, 0: disable\n#define SCREEN_DISTORTION       0.1                     // curvature of the screen\n\n// PBR Lighting\n// use mouse drag to see view position change\n#define PBR_LIGHTING            1                       // whether use PBR lighting for final output, 1: enable, 0: disable\n#define SCREEN_ROUGHNESS        0.2\n#define SCREEN_ROUGHNESS_NOISE  0.23                    // this will give some dirty effects on the screen\n#define SCREEN_METALNESS        0.1\n#define FRAME_COLOR             vec3(0.5, 0.5, 0.5) * 0.2\n#define FRAME_ROUGHNESS         0.8\n#define FRAME_METALNESS         0.3\n#define LIGHT_POSITION          vec3(1.0, 1.0, 1.0)\n#define LIGHT_COLOR             vec3(1.0, 1.0, 1.0)\n\n#define PI 3.14159265359\n\n// SDF cosine wave from https://www.shadertoy.com/view/3t23WG\nfloat udCos( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nvec3 grid(vec2 uv, vec2 fragCoord, vec3 gridColor, vec3 backgroundColor)\n{\n    float grid = 0.0;\n    grid = abs(1.0 - mod(uv.y * GRID_NUMS.y * 2.0, 2.0));\n    grid = max(grid, abs(1.0 - mod(uv.x * GRID_NUMS.x * 2.0, 2.0)));\n    grid = smoothstep(1.0 - GRID_LINE_WIDTH - 0.02, 1.0 - GRID_LINE_WIDTH, grid);\n    return grid * gridColor + (1.0 - grid) * backgroundColor;\n}\n\n// cubic lens distortion form https://www.shadertoy.com/view/4lSGRw\nvec2 cubicLensDistortion( vec2 uv, float k, float kcube ){\n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n    return nUv;\n}\n\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat rand(vec2 co)\n{\n   return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// RoughNoise from https://www.shadertoy.com/view/ss23DR\nuint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\nuint seed1 = uint(3214);\n\nfloat r()  // random float\n{\n    return float(Hash(seed1)) / 4294967295.0;\n    seed1 += uint(1);\n}\n\nuint seed2 = uint(2356);\nfloat r2(vec2 p) // random float for vec2\n{\n    if(p == vec2(0.)) return r();\n    else return fract(sin(dot(p, vec2(12.9898, 78.233))) * (43758.5453+float(seed2)));\n}\n\nfloat map(float v, float a1, float a2, float b1, float b2) // mapping function\n{\n    return (v-a1)/(a2-a1)*(b2-b1)+b1;\n}\n\nfloat pixelNoise(vec2 uv) // uper left quadrant\n{\n    return r2(round(uv));\n}\n\nfloat smoothNoise(vec2 uv)\n{\n    float BL = pixelNoise(floor(uv)); // take samples of four surrounding squares\n    float TR = pixelNoise(ceil(uv));\n    float BR = pixelNoise(vec2(ceil(uv.x), floor(uv.y)));\n    float TL = pixelNoise(vec2(floor(uv.x), ceil(uv.y)));\n    \n    uv = fract(uv); // make uv fit in 0-1 to use it in interpolation\n    uv = smoothstep(0., 1., uv); // make interpolation smooth (try commenting it out, it will be uglier)\n    \n    return mix(mix(BL, BR, uv.x), mix(TL, TR, uv.x), uv.y); // interpolate between surrounding colors\n}\n\nfloat roughNoise1(vec2 uv, int depth, float roughness)\n{\n    float col = smoothNoise(uv);\n    float basis = 1./(roughness);\n    \n    for(int i = 1; i < depth; i++) //tweaking initial color by multiplying it by smaller scale noise\n    {\n        uv += vec2(4.3487*r(), 5.754*r()); //move uv to avoid radial repetition effect\n        col *= map(smoothNoise(uv*pow(2., float(i))), 0., 1., 1.-1./pow(basis, float(i)), 1.+1./pow(basis, float(i)));\n    }\n\n    return col;\n}\n\n// PBR Lighting from https://www.shadertoy.com/view/7d23Ry\n///The normal distribution function. Which is how the specular highlight distributes on the surface when viewed.\nfloat NormalDistribution_GGX(float a, float NdH)\n{\n\t//Isotropic ggx\n\tfloat a2 = a * a;\n\tfloat NdH2 = NdH * NdH;\n\n\tfloat denominator = NdH2 * (a2 - 1.0f) + 1.0f;\n\tdenominator *= denominator;\n\tdenominator *= PI;\n\treturn a2 / denominator;\n}\n\n///The geometry function which simulates the tiny cavities' shadowing depending on the light's direction.\n///Imagine a tiny cavity being shadowed because the light does not hit it on the opening.\nfloat Geometric_Smith_Schlick_GGX(float a, float NdV, float NdL)\n{\n\t//smith schlick-GGX\n\tfloat k = a * 0.5f;\n\tfloat GV = NdV / (NdV * (1.0f - k) + k);\n\tfloat GL = NdL / (NdL * (1.0f - k) + k);\n\n\treturn GV * GL;\n}\n\n///Fresnel. Everything is shiny and everything has fresnel. So we need this.\n///http://filmicworlds.com/blog/everything-is-shiny/\n///http://filmicworlds.com/blog/everything-has-fresnel/\nfloat Fresnel_Schlick(float u)\n{\n\tfloat m = clamp(1.0f - u, 0.0f, 1.0f);\n\tfloat m2 = m * m;\n\treturn m2 * m2 * m;\n}\n\n///This one is used for calculating the specular contribution, we'll come back to this one later.\nvec3 Fresnel_Schlick(vec3 specularColor, vec3 h, vec3 v)\n{\n\treturn (specularColor + (1.0f - specularColor) * pow((1.0f - clamp(dot(v, h), 0.0f, 1.0f)), 5.0f));\n}\n\n///Calculate the specular.\n///Send it a million parameters to calculate them all. \n///I know some are unused but i used to have other functions set up here. Don't worry about it.\nvec3 Specular(vec3 specularColor, vec3 h, vec3 v, vec3 l, float a, float NdL, float NdV, float NdH, float VdH, float LdV)\n{\n    ///Get the three results.\n\tvec3 TotalSpecular = NormalDistribution_GGX(a, NdH) *\n\t\tFresnel_Schlick(specularColor, v, h) *\n\t\tGeometric_Smith_Schlick_GGX(a, NdV, NdL);\n\n    ///Divide them by 4 * Normal dot View and Normal dot Light.\n\treturn TotalSpecular / (4.0f * NdV * NdL + 0.001f);\n}\n\n///Compute the result of one light.\nvec3 ComputeLight(vec3 albedoColor, vec3 specularColor, vec3 normal, float roughness, vec3 lightColor, vec3 lightDir, vec3 viewDir, float met)\n{\n    ///Calculate everything.\n\tfloat NdL = clamp(dot(normal, lightDir), 0.0f, 1.0f);\n\tfloat NdV = clamp(dot(normal, viewDir), 0.0f, 1.0f);\n\tvec3 h = normalize(lightDir + viewDir);\n\tfloat NdH = clamp(dot(normal, h), 0.0f, 1.0f);\n\tfloat VdH = clamp(dot(viewDir, h), 0.0f, 1.0f);\n\tfloat LdV = clamp(dot(lightDir, viewDir), 0.0f, 1.0f);\n\tfloat a = max(0.001f, roughness * roughness);\n\n    ///Get the diffuse result and the specular result.\n    ///Lambertian diffuse, explanation here: https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    ///By another of my deities, sebastian lagarde.\n\tvec3 ColorDiffuse = albedoColor / PI;\n\tvec3 ColorSpecular = Specular(specularColor, h, viewDir, lightDir, a, NdL, NdV, NdH, VdH, LdV);\n\n    ///Diffuse and Specular are mutually exclusive, if light goes into diffuse it is because it was not reflected and\n    ///If light goes into specular it's because it was not refracted and was reflected.\n\n    ///Now we get the fresnel of our half and view. This gives us our Specular contribution depending on the angle of viewing.\n\tvec3 F = Fresnel_Schlick(specularColor, h, viewDir);\n\tvec3 kS = F;\n\tvec3 kD = vec3(1.0f, 1.0f, 1.0f) - kS; ///To get our diffuse contribution we substract the specular contribution from a white color.\n\n    kD *= 1.0f - met;\n\n    ///Now we just multiply the NdL by the lightcolor and by the colorDiffuse and ColorSpecular\n\treturn lightColor * NdL * (kD * ColorDiffuse + ColorSpecular);\n}\n\n///This is used for the specular contribution on the environment, we'll also use this later.\nvec3 Specular_F_Roughness(vec3 specularColor, float a, vec3 h, vec3 v)\n{\n    vec3 c = vec3(1.0f - a,1.0f - a,1.0f - a);\n\treturn specularColor + (max(c, specularColor) - specularColor) * pow((1.0f - clamp(dot(v, h), 0.0f, 1.0f)), 5.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // =====================================================================================================\n    // ====================================== UV, mouse & distortion =======================================\n    // =====================================================================================================\n\n    vec2 mouseOffset = (iMouse / iResolution.x - 0.5).xy;\n    float viewportRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy + mouseOffset * 0.01;\n    float kcube = .5 * sin( iTime );\n    float k = 1.0 * sin( iTime * .9 );\n    float offset = .1 * sin( iTime * .5 );\n    uv = cubicLensDistortion(uv, SCREEN_DISTORTION, SCREEN_DISTORTION) - vec2(0.5);\n    \n    // =====================================================================================================\n    // ==================================== Grid, Wave & Effects ===========================================\n    // =====================================================================================================\n    \n    // -------------------------------------------- Grid ---------------------------------------------------\n    vec3 color = vec3(0.0);\n    color = grid(uv, fragCoord, GRID_LINE_COLOR, GRID_BACKGROUND_COLOR);\n    vec3 waveColor = WAVE_COLOR;\n\n    // -------------------------------------------- Time ---------------------------------------------------\n#if WAVE_ANIMATED\n    float t1 = iTime * WAVE_SPEED; // wave time\n#else\n    float t1 = 0.0;\n#endif\n#if GLITCH_ANIMATED\n    float t2 = iTime * GLITCH_STRENGTH; // glitch time\n#else\n    float t2 = 0.0;\n#endif\n\n    // ---------------------------------------- Wave & Noise -----------------------------------------------\n    // interference wave, glitch codes from https://www.shadertoy.com/view/XtK3W3\n    // Create large, incidental noise waves\n    float noise = max(0.0, snoise(vec2(t2, uv.y * 0.3)) - 0.3) * (1.0 / 0.7);\n    // Offset by smaller, constant noise waves\n    noise = noise + (snoise(vec2(t2*10.0, uv.y * 2.4)) - 0.5) * 0.15;\n#if GLITCH_ANIMATED\n    // Apply the noise as x displacement for every line\n    float xpos = uv.x - noise * noise * 0.15 * GLITCH_STRENGTH;\n    float Gnoise = noise * 0.02;\n#else\n    float xpos = uv.x;\n    float Gnoise = 0.0;\n#endif\n\n    // sdf cosine wave, used for glowing effect\n    float dr = udCos(vec2(xpos * viewportRatio, uv.y), WAVE_OFFSET, WAVE_AMPLITUDE, WAVE_FREQUENCY, t1 + WAVE_PHASE);\n\n    // ---------------------------------------- Glow Color -------------------------------------------------\n    // glow & splite tone effects\n#if WAVE_GLOW == 0\n    float waveR = smoothstep(WAVE_LINE_WIDTH, WAVE_LINE_WIDTH - 0.01, dr);\n    float waveG = smoothstep(WAVE_LINE_WIDTH + Gnoise, WAVE_LINE_WIDTH - 0.01, dr);\n    float waveB = smoothstep(WAVE_LINE_WIDTH + Gnoise * 0.1, WAVE_LINE_WIDTH - 0.01 + Gnoise * 0.01, dr);\n    waveColor.r *= waveR;\n    waveColor.g *= waveG;\n    waveColor.b *= waveB;\n#else\n    float waveR = smoothstep(WAVE_LINE_WIDTH, 0.0001, dr);\n    float waveG = smoothstep(WAVE_LINE_WIDTH + Gnoise, 0.0001, dr);\n    float waveB = smoothstep(WAVE_LINE_WIDTH + Gnoise * 0.1, 0.0001 + Gnoise * 0.01, dr);\n    waveColor.r *= pow(waveR, WAVE_GLOW_EXPONENT) * WAVE_GLOW_STRENGTH;\n    waveColor.g *= pow(waveG, WAVE_GLOW_EXPONENT) * WAVE_GLOW_STRENGTH;\n    waveColor.b *= pow(waveB, WAVE_GLOW_EXPONENT) * WAVE_GLOW_STRENGTH;\n#endif\n    \n    // ------------------------------------- Scan Line Glitch ----------------------------------------------\n    // Mix in some random interference for lines\n    waveColor += vec3(rand(vec2(uv.y * t2))) * noise * 0.3;\n#if SCAN_LINE\n    // Apply a 100-lines pattern\n    if (floor(mod(uv.y * 500.0, 2.0)) == 0.0)\n    {\n        waveColor *= 1.0 - (2.0 * noise);\n    }\n#endif\n    \n    // =====================================================================================================\n    // ==================================== Lighting & Output ==============================================\n    // =====================================================================================================\n\n    // ------------------------------------- Parameter Setups ----------------------------------------------\n    // splite the screen part & frame part, get the color(Albedo) and waveColor(Emissive)\n    float sideX = smoothstep(0.495, 0.5, abs(uv.x));\n    float sideY = smoothstep(0.495, 0.5, abs(uv.y));\n    float frame = max(sideX, sideY);\n    color *= 1.0 - frame;\n    color = max(color, vec3(0.0));\n    color += frame * FRAME_COLOR;\n    waveColor = max(waveColor, vec3(0.0)) * (1.0 - frame);\n    \n#if PBR_LIGHTING\n    // from https://www.shadertoy.com/view/7d23Ry\n    // roughness map from noise, splite materials for screen and frame\n    float roughness = (1.0 - frame) * (roughNoise1(uv * 10.0, 8, 0.5) * SCREEN_ROUGHNESS_NOISE + SCREEN_ROUGHNESS) + // screen\n                      frame * FRAME_ROUGHNESS; // frame\n    float metalness = SCREEN_METALNESS * (1.0 - frame) + // screen\n                      FRAME_METALNESS * frame; // frame\n    \n    // lighting\n    vec3 lightDir = normalize(LIGHT_POSITION);\n    vec3 lightColor = LIGHT_COLOR;\n    vec3 specColor = mix(vec3(0.06f, 0.06f, 0.06f), color, metalness);\n\n    // give some fake normal based on cubic distortion\n    vec2 uv2Norm = (fract(uv - 0.5) - 0.5) * 0.8;\n    uv2Norm.x *= viewportRatio;\n    vec3 norm = normalize(vec3(uv2Norm, 0.2)); \n    vec3 viewDir = normalize(vec3(uv - mouseOffset * 0.4, 1.5)); // offset view direction by mouse\n\n    // ----------------------------------- PBR Lighting Calculation ----------------------------------------\n    vec3 pbr = ComputeLight(\n        color, \n        specColor, \n        norm, \n        roughness,\n        lightColor, \n        lightDir, \n        viewDir, \n        metalness\n    );\n\n    // fresnel for the environment.\n    vec3 envFresnel = Specular_F_Roughness(specColor.xyz, roughness * roughness, norm, -viewDir).xyz;\n    \n    // We calculate again the specular and diffuse contributions because there are two parts \n    // There's two parts the environment and the irradiance. \n    // One affects the diffuse and the other one affects the specular.\n\tvec3 Kd = 1.0f - envFresnel;\n\tKd *= 1.0f - metalness;\n    // Get the reflection vector using the view dir on the normal.\n    vec3 reflection = reflect(viewDir, norm);\n    vec4 env = vec4(0.1); // there is no cubemap input\n    vec4 irr = vec4(0.8);\n    \n    // Multiply the surface color by the irradiance and by the diffuse contribution.\n    vec3 ambientLight = color * irr.xyz * Kd; \n    // Multiply the environment by the fresnel.\n    // The environment should be more reflective on grazing angles.\n    vec3 specularIndirectLight = env.xyz * envFresnel; \n\n    // combine all these lighting colors, waveColor counts as emission\n    vec3 pbrLighting = pbr + waveColor + ambientLight + specularIndirectLight;\n    \n    // --------------------------------------- Final Output ------------------------------------------------\n    // Output to screen\n    fragColor = vec4(pbrLighting, 1.0);\n#else\n    fragColor = vec4(color + waveColor, 1.0);\n#endif\n}","name":"Image","description":"","type":"image"}]}