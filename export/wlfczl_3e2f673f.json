{"ver":"0.1","info":{"id":"wlfczl","date":"1592769400","viewed":104,"name":"Marching shader","username":"oseday","description":"yes","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct rayresult{\n    vec3 o; //origin\n    vec3 v; //direction\n    float dist; //distance\n};\n\n#define ambient 1.0\n#define EPSILON 0.001\n\nmat4 cam = mat4(\n    1,0,0,0,\n    0,1,0,0,\n    0,0,1,0,\n    0,0,0,1\n);\n\nmat4 addmv(mat4 mat, vec3 v){\n    mat4 n = mat;\n    n[3]=n[3]+vec4(v,0);\n    return n;\n}\n\nmat4 mat4v(vec3 v){\n    return mat4(\n        1,0,0,v.x,\n        0,1,0,v.y,\n        0,0,1,v.z,\n        0,0,0,1\n    );\n}\n\nvec3 matpos(mat4 mat){\n    return mat[3].xyz;\n}\n\nconst float planedist = 1.0;\n\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nvec3 forwardSF( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nvec3 mapP( vec3 p )\n{\n    vec3 b = 1.000*sin(  1.*p.zxy + vec3(iTime,0.,0.) );\n    b += 0.500*sin(  (sin(iTime*0.789+1.345)+1.5)*4.0*b.zxy );\n    b += 0.225*sin(  (sin(iTime*0.975+5.345)+1.2)*8.2*b.zxy );\n    \n    b = rotateabout(b, normalize(b), iTime);\n    \n    return b*length(p)*length(p);\n}\n\nfloat getMap( vec3 q )\n{\n    vec3 p = mapP( q );\n    float d = length( p ) - 0.00;\n\treturn d * 0.009;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        getMap(vec3(p.x + EPSILON, p.y, p.z)) - getMap(vec3(p.x - EPSILON, p.y, p.z)),\n        getMap(vec3(p.x, p.y + EPSILON, p.z)) - getMap(vec3(p.x, p.y - EPSILON, p.z)),\n        getMap(vec3(p.x, p.y, p.z  + EPSILON)) - getMap(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nconst float kFarClip = 1.02;\nconst int kRaymarchIterations = 1024;\nconst float mapddivisor = 1.0;\n\nfloat rayshadow(vec3 pos, vec3 dir){\n\n\tfloat t = 0.15;\n    float res = 1.0;\n    \n\tfor(int i=0; i<kRaymarchIterations/1; i++){\n        vec3 p = pos + dir * t;\n\t\tfloat d = getMap(p);\n        \n        if (d < -0.00){return 0.;}\n        \n        res = min(res, 256.*d/t);\n        \n        if (d>10.) {return res;}\n        \n        t += d/mapddivisor;\n    }\n    \n    return res*res;\n}\n\nconst vec3 sundir = normalize(vec3(0,1,1));\nconst vec3 suncol = vec3(0.8,0.8,0.8);\nconst vec3 objcol = vec3(0.9,0.9,0.8);\n\nvec3 manager(rayresult io){\n\n    vec3 skycol = texture(iChannel0,io.v).xyz;\n    \n\tfloat t = -1.00;\n    \n    int i=0;\n    \n\tfor(i=0; i<kRaymarchIterations; i++)\n\t{\n        vec3 pos = io.o + io.v * t;\n    \n\t\tfloat d = getMap(pos);\n        \n        if (d > 10.) {return skycol;}\n        \n\t\tif(d < 0.01){\n            \n            vec3 n = estimateNormal(pos);\n            \n            vec3 sdir = reflect(io.v,n);\n            \n            float sundot = dot(n,sundir);\n            \n            vec3 col = suncol * sundot + objcol * 0.6;\n            \n            col *= texture(iChannel0,sdir).xyz;\n            \n            //if (sundot > 0.) {\n                //float shadow = rayshadow(pos+n*0.01, sundir);\n                //col *= vec3(shadow);\n            //}\n            \n\t\t\treturn col;\n\t\t}\n        \n        t += d/mapddivisor;\n\t}\n    \n    return skycol;//vec3(float(i)/1024., col.gb);\n}\n\nvoid updatescene(float tick){\n    \n}\n\nconst int MSAA = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tick = iTime/5.;\n    \n    \n    updatescene(tick);\n    \n    vec2 mouseuv = (iMouse.xy-iResolution.xy/2.0)/iResolution.xx*2.;\n    \n    \n    mat4 ncam = cam\n        *build_transform(vec3(0,0,0),vec3(0,-mouseuv.x*3.1415928 + tick,0))\n        *build_transform(vec3(0,0,0),vec3(-mouseuv.y*3.1415928+sin(tick*2.*0.)/3.,0,0))\n        ;\n    ncam = ncam\n        *build_transform(vec3(0,0,-8.),vec3(0,0,0))\n        ;\n    //ncam[3].xyz = ncam[3].xyz + vec3(0,0,80);\n    \n    \n    vec3 campos = matpos(ncam);\n    vec3 totcol = vec3(0,0,0);\n        \n    float distMSAA = float(MSAA+1);\n    \n    for (int xs=1;xs<=MSAA;xs++){\n        for (int ys=1;ys<=MSAA;ys++){\n            \n            vec2 uv = (fragCoord+vec2(xs,ys)/distMSAA-iResolution.xy/2.0)/iResolution.xx*2.;\n\n            vec3 v = normalize(uv.x*ncam[0].xyz+uv.y*ncam[1].xyz+ncam[2].xyz*planedist);\n\n            vec3 col = vec3(0,0,0);\n\n            //rayresult o = ray(campos,v);\n            rayresult ray;\n            \n            ray.o=campos;\n            ray.v=v;\n            ray.dist=0.10;\n\n            col += manager(ray);\n\n            col = clamp(col,vec3(0,0,0),vec3(1,1,1));\n            totcol += col;\n        }\n    }\n    \n    totcol /= float(MSAA*MSAA);\n\n    fragColor = vec4(totcol,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat4 build_transform(vec3 pos, vec3 ang) \n{\n  float cosX = cos(ang.x);\n  float sinX = sin(ang.x);\n  float cosY = cos(ang.y);\n  float sinY = sin(ang.y);\n  float cosZ = cos(ang.z);\n  float sinZ = sin(ang.z);\n\n  mat4 m;\n\n  float m00 = cosY * cosZ + sinX * sinY * sinZ; \n  float m01 = cosY * sinZ - sinX * sinY * cosZ; \n  float m02 = cosX * sinY;\n  float m03 = 0.0;\n  \n  float m04 = -cosX * sinZ; \n  float m05 = cosX * cosZ; \n  float m06 = sinX;\n  float m07 = 0.0;\n  \n  float m08 = sinX * cosY * sinZ - sinY * cosZ;\n  float m09 = -sinY * sinZ - sinX * cosY * cosZ;\n  float m10 = cosX * cosY;\n  float m11 = 0.0;\n  \n  float m12 = pos.x;\n  float m13 = pos.y;\n  float m14 = pos.z;\n  float m15 = 1.0;\n\n  /*\n  //------ Orientation ---------------------------------\n  m[0] = vec4(m00, m01, m02, m03); // first column.\n  m[1] = vec4(m04, m05, m06, m07); // second column.\n  m[2] = vec4(m08, m09, m10, m11); // third column.\n\n  //------ Position ------------------------------------\n  m[3] = vec4(m12, m13, m14, m15); // fourth column.\n  */\n\n  //------ Orientation ---------------------------------\n  m[0][0] = m00; // first entry of the first column.\n  m[0][1] = m01; // second entry of the first column.\n  m[0][2] = m02;\n  m[0][3] = m03;\n  \n  m[1][0] = m04; // first entry of the second column.\n  m[1][1] = m05; // second entry of the second column.\n  m[1][2] = m06;\n  m[1][3] = m07;\n\n  m[2][0] = m08; // first entry of the third column.\n  m[2][1] = m09; // second entry of the third column.\n  m[2][2] = m10;\n  m[2][3] = m11;\n  \n  //------ Position ------------------------------------\n  m[3][0] = m12; // first entry of the fourth column.\n  m[3][1] = m13; // second entry of the fourth column.\n  m[3][2] = m14;\n  m[3][3] = m15;\n\n  return m;\n}\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotateabout(vec3 vec, vec3 axis, float angle) {\n    return (rotationMatrix(axis, angle) * vec4(vec, 1.0)).xyz;\n}","name":"Common","description":"","type":"common"}]}