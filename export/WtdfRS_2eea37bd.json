{"ver":"0.1","info":{"id":"WtdfRS","date":"1612971651","viewed":50,"name":"fork-002_simplex.frag","username":"jorge2017a1","description":"fork-002_simplex.frag","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fork002simplexfrag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///modificado por jorge.flores.p\n//referencia my avatar\n//https://www.shadertoy.com/view/lslfz4\n\n\n//original code.  by  Will Stallwood\n//https://github.com/willstall/30-days-of-shade/blob/master/assets/shaders/002_simplex.frag\n\n/*\n    daily: 002\n    author: Will Stallwood\n    insta: https://www.instagram.com/willstall/\n    \n*/\n\n\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\n\nvec3 palette(float t,vec3 a,vec3 b,vec3 c,vec3 d )\n{\n    return a + b * cos( TWO_PI * (c*t+d));\n}\n\nfloat random(float x)\n{\n    return fract(sin(x*100.00)*10000.0);\n}\n\nfloat random(vec2 st)\n{\n    return fract(\n        dot(\n            sin(st.x*100.00),\n            sin(st.y*100.00)        \n        )*10000.0);\n}\n\nfloat smoothCellRandom(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    float fPos = fract(x*scale);\n\n    return mix(random(iPos), random(iPos + 1.0), smoothstep(0.,1.,fPos));\n}\n\nfloat peakCellRandom(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    float fPos = fract(x*scale);\n\n    return mix(random(iPos), random(iPos + 1.0), fPos);\n}\n\nfloat cellRandom(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    float fPos = fract(x*scale);\n\n    return random(iPos);\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    vec3 V = normalize(p-ro);\n   \n    return lin*atten;\n}\n\nfloat GetDist2D(vec2 st)\n{\n    float t = iTime * .33;\n    float scale = 20.;\n    float cell = cellRandom(st.x+t,scale);\n    float r = floor(cell*st.y*scale);\n    float f = st.y * abs(sin( cell*1000.0 + iTime));\n    r *= f;\n    r = 1.0 - step(1.0,r);\n    r += 1.0-f;\n\n    float d = smoothCellRandom(st.x+t,scale);\n    // d *= r;\n    d = r;\n\n    \n    return d+fract(t)*2.0;\n }   \n\nfloat maskSharp(vec2 p) {\n    return clamp(GetDist2D(p - vec2(0.0, 0.5))*400.0  , 0.0, 1.0);\n}\n\nfloat maskBlurry(vec2 p) {\n    return clamp((GetDist2D(p - vec2(0.0, 0.5)) + 0.003) * 75.0, 0.0, 1.0);\n}\n\nvec3 normalAt(vec2 p) \n{\n    float ps = 1.0 / iResolution.x;\n    float x = maskBlurry(p - vec2( ps, 0.0)) - maskBlurry(p + vec2( ps, 0.0));\n    float y = maskBlurry(p - vec2(0.0,  ps)) - maskBlurry(p + vec2(0.0,  ps));\n    return normalize(vec3(x, y, 1.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 st = fragCoord.xy / iResolution.xy;\n    //vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.0);\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    vec3 p0=vec3(p, 0.0);\n    vec3 ro=p0;\n    vec3 rd=normalize(vec3(p,1.0));\n    \n    vec3 lightPos = vec3(cos(iTime), sin(iTime), 1.0);\n    \n    vec3 toLight = lightPos - p0;\n    vec3 normal = normalAt(p);\n    float shade = 0.3 + maskSharp(p) * 0.7;\n   \n    \n    \n    float t = iTime * .33;\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(0.0,.1,0.2);\n    \n    float d= GetDist2D(st);\n    color = palette(d+fract(t)*2.0,vec3(0.5),a,b,c);\n    // color += vec3(clamp(dot(normalize(toLight), normal), 0.0, 1.0) / length(toLight)*0.5) * d;\n    vec3 noise = vec3((texture(iChannel0, p * 4.0).x - 0.5) / 32.0);\n    \n    vec3 col2= lightingv3(normal,p0, lightPos, rd, ro) *color;\n     color /= d;\n    color +=noise;\n    \n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}