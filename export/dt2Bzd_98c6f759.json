{"ver":"0.1","info":{"id":"dt2Bzd","date":"1694408473","viewed":46,"name":"Smooth `fract` and `floor`","username":"twixuss","description":"See comments for full description.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["floor","fract","smooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Control smoothness with MouseY\n// Control scale      with MouseX\n\n// Smooth fract and floor.\n// The numerical precision decreases as smoothness parameter drops to zero,\n// so I clamp it to reduce artifacts.\n\n// sfract is implemented in terms of sfloor. Smoothness parameter of commented implementation of sfract\n// is not linear, but sfloor's is.\n\n\n#define PI 3.1415926535897932384626433832795\n#define TAU (PI*2.0)\n\nbool eq(float a, float b) {\n    return a == b;\n    //return abs(floatBitsToInt(a) - floatBitsToInt(b)) <= 1; // Check for exactly one bit difference.\n    //return abs(a-b)<=1e-9; // Alternative\n}\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp((b-a)/k+0.5,0.0,1.0);\n\treturn b+h*(a-b+k*0.5*(h-1.0));\n}\nfloat sfloor(float x, float s) {\n    // Sometimes the formula gives incorrect results if x is within a single bit difference from *.0 or *.5\n    // These are fixed points (they don't depend on s), so we can return exact value.\n    if (eq(x,floor(x)) || eq(x+0.5,floor(x+0.5)))\n        return x-0.5;\n        \n    float x1 = uintBitsToFloat(floatBitsToUint(x + 0.5) - 1u);\n    \n    return smin(floor(x), (fract(x1)-0.5)/(clamp(s,1e-5,1.0)*0.5)+floor(x1)-0.5,-sign(fract(x)-0.5));\n    //return x - sfract(x, s);\n}\nfloat sfract(float x, float s) {\n    //return smin(fract(x), 0.5+(floor(x+0.5)-x)/clamp(s,1e-5,1.0), sign(fract(x)-0.5)); // Independent implementation\n    return x - sfloor(x, s);\n}    \n\n#if 0\n// This version uses sine to produce really smooth floor\nfloat sfloor(float x) {\n    return x-0.5+sin(x*TAU)/TAU;\n}\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5)/iResolution.xy;\n    float mf = floor((iMouse.x+1.0)/iResolution.x * 4.0);\n    float scale = pow(2.0, 2.0 + 2.0*mf);\n    if (mf == 3.0) \n    {\n        scale = iResolution.x;\n    }\n    float x = uv.x * scale + 0.5;\n    \n    float s = clamp(iMouse.y/iResolution.y*2.0-0.5, 0.0,1.0);\n    if (length(iMouse) < 16.0)\n        s = 0.5 + 0.5 * sin(iTime * 2.0);\n    if (uv.y > 0.75)\n        fragColor = vec4(fract(x));\n    else if (uv.y > 0.5)\n        fragColor = vec4(sfract(x,s));\n    else if (uv.y > 0.25)\n        fragColor = vec4(floor(x)/scale);\n    else\n        fragColor = vec4(sfloor(x,s)/scale);\n}","name":"Image","description":"","type":"image"}]}