{"ver":"0.1","info":{"id":"cd3cWM","date":"1695102008","viewed":109,"name":"Galaxy flower","username":"nayk","description":"effects from this shaders","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["light","particles","galaxy","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals  https://www.shadertoy.com/view/MdXSzS https://www.shadertoy.com/view/wdtczM  https://www.shadertoy.com/view/MdfBz7 https://www.shadertoy.com/view/XsjBRt */\n\n\n\n#define M_PI 3.1415926535897932384626433832795\n#define TWO_PI 6.283185307179586\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n// radom number in 2d\nfloat hash(vec2 p) {\n  return fract(sin(dot(p,vec2(12.9898,78.2333)))*43758.5453123);\n}\n\n// noise in 2d\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// fractal noise in 2d\nfloat fbm ( vec2 p ) {\n    const mat2 m = mat2(0.8,0.6,-0.6,0.8);\n    float f = 0.0;\n    f += 0.5000*noise ( p ); p*=m*2.02;\n    f += 0.2500*noise ( p ); p*=m*2.04;\n    f += 0.1250*noise ( p ); p*=m*2.03;\n    f += 0.0650*noise ( p ); p*=m*2.01;\n\n    // normalize f;\n    f /= 0.9375;\n    return f;\n}\n\nvec3 pal(float domain, vec3 frequency, vec3 phase) {\n  return vec3(0.5) + vec3(0.5) * cos(TWO_PI*(frequency*domain+phase));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + 2.07)) * 2.2;\n\tfloat si = sin(t);\n    vec4 o = fragColor;\n    vec2 F = fragCoord;\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\nfloat c6= noise(uv.xy);\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t vec2 p = (-0.5 + (fragCoord.xy / iResolution.xy)) * vec2(4.0);\n  // aspect ratio\n  p.x *= iResolution.x / iResolution.y;\n\n\n\n    vec2 R = iResolution.xy; \n    o-=o;\n    for(float d,t = iTime*.1, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o += c * c.yzww  * (d-d*d)  / vec4(3.1,3.,.5,.5);                     \n    }\n\n\n  // angle and radius to center 0,0\n  float a = atan( p.y, abs(p.x) );\n  float r = length(p);\n\n  // space distortion\n  p += vec2(fbm(vec2(a*2.+iTime*.1,r*.4-iTime*.3)))*5.0;\n  // divide the space into cells and get cell index to seed the palette\n  float cidx = (floor(p.x+2.0) + (floor(p.y+2.0)*4.0)) / 16.0;\n  // color is from palette with cell index\n  vec3 color = pal(fbm(p*.5), vec3(1.0), vec3(0.4+cidx,0.2+cidx,0.0));\n\n  // draw a grid for the cells\n  color *= smoothstep(0.49,0.44, abs(fract(p.x)-0.5));\n  color *= smoothstep(0.49,0.44, abs(fract(p.y)-0.5));\n\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 0.0);\n        float c5 = random(p.xy);\n\t\tfloat c6= noise(p.xy);\n       p.x+=cos(iTime*0.5);\n         p.y+=sin(iTime*0.5);\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1)+c6*color*c5;\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n    vec4 outColor = vec4(0.0);\n\tfloat time = iTime * 0.1;    \n    vec2 uvNorm = fragCoord.xy / iResolution.xy;\n\t\n    uv /= vec2(iResolution.y / iResolution.x, 1.);\n\t   float c5 = random(uv.xy);\n    \n    \n    \n    float grid = smoothstep((sin(length(uv.y-0.5)*(800.*length(uv.y+0.5))) * sin(length(uv.x+0.5)*(800.*length(uv.x-0.5)))), 0.0, 1.0);\n    outColor.rgb += (outColor.rgb * vec3(grid) * 0.6);\n    \n\t\n\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len)+c6;\n\tv2 *= smoothstep(.10, .3, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\n\tfragColor=vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0);\n    fragColor+= outColor;\n    fragColor+=o;\n}","name":"Image","description":"","type":"image"}]}