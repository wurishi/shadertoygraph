{"ver":"0.1","info":{"id":"MdKSDK","date":"1466760889","viewed":1781,"name":"Fresh Water","username":"Draedrus","description":"Summer time !\nFeatures: Rayleigh+Mie sky coloration, Refraction, reflection\nStill under work... Have a lot of things to setup there finally","likes":14,"published":1,"flags":32,"usePreview":1,"tags":["3d","reflection","refraction","texture","water","bump","hdr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n#define UNROLL(x)\n#ifndef GLSL\n#undef UNROLL\n#define UNROLL(x) \n#define textureLod texture\n#endif\n\n\n/*******************\n * SAMPLING\n *******************/\n#define FLOOR_TEXTURE_FREQ 1.6\n#define FLOOR_TEXTURE_AMP 0.04\n#define FLOOR_LEVEL 0.02\n\n\n\n#define WATERSHADING_V4_VISIBILITY 0.4 // 0.2\n#define WATERSHADING_V4_EXTINCTION 100.0\n#define WATERSHADING_V4_DEPTH_FACTOR 1.0\n\n// water clarity\n#define VIEWLENGTH 8.0\n\n//#define CLOUDS\n\n#define REFR_NUM_STEPS 5\n#define SAND_OCTAVES 6\n#define SAND_GRAINS 1\n#define CAMDIST 10.0\n#define CAMROTSPEED 0.1\n#define CLOUDSPEED 0.1\n#define LIGHTSPEED 0.05\n\n#define AIR_REFRACTION_INDEX 0.8\n#define MOLECURAL_DENSITY_SEA_LEVEL 1.0\n#define SCALE_HEIGHT 8000.0\n#define MOONINTENSITY 5.0\n\n#define LIGHTPOS normalize(vec3(1.0, 1.0, 1.0))*149597870700.0\n#define BOATPOS vec3(0.0, 3.0, 0.0)\n\n#define COLORWATERDEEP vec3(0.07, 0.14, 0.09)\n\n\nfloat gSolarPhase = 1.0;\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    vec4 specColor;\n    float shininess;\n\tfloat power;\n};\n\nLight _light = Light(\n    LIGHTPOS,\n    -normalize(TARGETPOS-vec3(0.0, 4.5, 4.5)),\n    vec4(1.0, 1.0, 0.8, 1.0),\n    vec4(1.0, 1.0, 0.8, 1.0),\n    2.0,\n    SUNINTENSITY);\n    //38000.0);\n\nLight _moon = Light(\n    normalize(vec3(0.8, 0.5, 1.0)), \n    normalize(TARGETPOS-vec3(0.0, 1.0, 10.0)),\n    vec4(0.8, 0.8, 1.0, 1.0),\n    vec4(0.8, 0.8, 1.0, 1.0),\n    2.0,\n    MOONINTENSITY);\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\nfloat heightMap(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = FLOOR_TEXTURE_FREQ;\n    for(int i=0;i<5;++i) {\n        vec3 hm = textureLod(iChannel0, p.xz*f, 0.0).rgb;\n        float avg = 1.0-0.33*(hm.r+hm.g+hm.b);\n        h += avg*a;\n        a *= 0.22;\n        //f *= 1.9;\n    }\n    return h-textureLod(iChannel0, p.xz, 0.0).r*0.02+cos(p.x)*0.02+p.z*0.03*log(length(p));\n}\n\n\nfloat mapWater(vec3 p) {\n    return sdPlane(p)+heightMapWater(p, iTime);\n}\n\nfloat mapWaterDetailed(vec3 p) {\n    return sdPlane(p)+heightMapWaterDetailed(p, iTime);\n}\n\nfloat mapTerrain(vec3 p, float s) {\n    float hm = heightMap(p, s);\n    return sdPlane(p-vec3(0.0, -0.25-p.z*0.05, 0.0))+hm;\n}\n\nfloat mapSand(vec3 p) {\n    return sdPlane(p-vec3(0.0, -0.8-p.z*0.05, 0.0))-0.2;\n}\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nvec2 mapUnderWater(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0), FLOOR_TEXTURE_AMP), TYPE_FLOOR);\n    d = opU(d, vec2(mapSand(p-vec3(0.0, FLOOR_LEVEL, 0.0)), TYPE_SAND));\n    return d;\n}\n\nvec2 mapRM(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0), FLOOR_TEXTURE_AMP), TYPE_FLOOR);\n    d = opU(d, vec2(mapSand(p-vec3(0.0, FLOOR_LEVEL, 0.0)), TYPE_SAND));\n    d = opU(d, vec2(mapWater(p-vec3(0.0, WATER_LEVEL, 0.0)), TYPE_WATER));\n    //d = opU(d, vec2(sdBox(p-BOATPOS, vec3(1.0, 1.0, 1.0)), TYPE_BOAT));\n    return d;\n}\n\nvec2 mapRMDetailed(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0), FLOOR_TEXTURE_AMP), TYPE_FLOOR);\n    //d = opU(d, vec2(mapWaterDetailed(p-vec3(0.0, WATER_LEVEL, 0.0)), TYPE_WATER));\n    //d = opU(d, vec2(sdBox(p-BOATPOS, vec3(1.0, 1.0, 1.0)), TYPE_BOAT));\n    return d;\n}\n\nvec3 mapRMNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapRMDetailed(pt).x;    \n    normal.x = mapRMDetailed(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapRMDetailed(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec3 mapRMWaterNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapWaterDetailed(pt);    \n    normal.x = mapWaterDetailed(vec3(pt.x+e,pt.y,pt.z)) - normal.y;\n    normal.z = mapWaterDetailed(vec3(pt.x,pt.y,pt.z+e)) - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec3 mapUnderWaterNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapUnderWater(pt).x;    \n    normal.x = mapUnderWater(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapUnderWater(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = mapRM(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x*log(1.0+float(i));\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\nvec2 raymarchUnderWater(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<REFR_NUM_STEPS; i++ )\n\t{\n        m = mapUnderWater(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += /*0.5**/m.x*log(1.0+float(i));\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\n/************************\n * RENDERING\n ************************/\n\nfloat fresnel(vec3 I, vec3 N, float B, float S, float E)\n{\n    return B+S*pow(max(0.0, 1.0+dot(I,N)),E);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / max(0.0001, 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.01);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.01);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.01);\n  float VdotH = max(dot(viewDirection, H), 0.0001);\n  float LdotH = max(dot(lightDirection, H), 0.0001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(roughness, NdotH);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)*max(0.0, dot(N, L))+Ks*specularColor*spec) * Oi;\n}\n\nvec3 colorFloor(vec3 P, vec3 I, vec3 N, float type, float K, float solarPhase)\n{\n    vec3 L = mix(_moon.d, _light.d, solarPhase);\n    vec3 color = vec3(0.0);\n    if(type == TYPE_FLOOR)\n    {\n        float ao = texture(iChannel0, P.xz*FLOOR_TEXTURE_FREQ).r;\n        vec3 diff = texture(iChannel1, P.xz*FLOOR_TEXTURE_FREQ).rgb;\n        \n        float algae_mask = max(0.0, texture(iChannel1, P.xz).r-0.5);\n        \n        diff = mix(diff, COLORALGAE, algae_mask);\n        float roughness = mix(0.2, 1.0, algae_mask);\n        \n        color = brdf(\n            K, // Ks\n            K, // Kd\n            roughness, // roughness\n            1.0, // opacity\n            diff,//vec3(1.0), // specular color\n            diff, // diffuse color\n            I, // I\n            N, // N\n            -L // L\n            )*ao;\n    }\n    return color;\n}\n\nvec3 getSkyCoord(vec3 ro, vec3 rd)\n{\n    float tmin = -1.0, tmax = -1.0;\n    float d = IntersectSphere(\n        ro+vec3(0.0, 401.0, 0.0), rd, vec3(0.0, 0.0, 0.0),\n        400.0+2.0,\n        tmin, tmax);\n    return ro+rd*tmin;\n}\n\n// Physically Based Rendering, From Theory to Implementation\nfloat PhaseSchlick(float g, float RdotL)\n{\n    float k = 1.55* g - 0.555*g*g*g;\n    RdotL = k*RdotL;\n    return 1.0/(4.0*PI) * (1.0-k*k) / ((1.0-RdotL)*(1.0-RdotL));\n}\n\n// formula from Hzzd\n// Beer-law + Henyey-Greenstein phase function\nfloat getEnergyScattered(float p, float g, float density, float RdotL)\n{\n   return 2.0\n       * exp(-density*p)\n       * (1.0-exp(-2.0*density))\n       * PhaseSchlick(g, RdotL);\n       //* ((1.0-g*g)/pow((1.0+g*g-2.0*g*RdotL), 1.5))/(4.0*3.1415));\n}\n\nvoid getCloudColorOld(\n    vec3 Psky,\n    vec3 ro, vec3 rd, vec3 Lo, vec3 L,\n    out float density,\n    out float Energy, out float cloud_mask, inout vec3 cloudColor,\n\tfloat daynight)\n{\n    vec3 pc = Psky;\n    vec3 Lpc = normalize(Lo-pc);\n    float p = 0.0;\n    density = 0.0;\n    \n    #define CLOUDRMSTEP 0.5\n    #define CLOUDSTEPS 5\n\n    Energy = 1.0;\n        vec3 t = normalize(vec3(-1.0, 0.0, 1.0))*TIME(iTime);\n    vec3 P = pc;\n    for(int i=0;i<CLOUDSTEPS;++i)\n    {\n        //vec3 P = pc+Lpc*(float(i)*CLOUDRMSTEP);\n        P += normalize(Lpc)*CLOUDRMSTEP;\n        P = RotXYZ(P, normalize(vec3(0.4, 0.4, 0.0)));\n            \t\n        //float height = mix(1.0, 0.1, clamp(P.y/5.0, 0.0, 1.0));\n        float mask = clamp(gaussianNoise3D(P*0.006+t), 0.0, 1.0);\n        mask *= mask*mask*mask;\n        float dt = cloudNoise3D((P/*height*/)*0.0002, t);\n        density += dt*mask;\n        if(density>1.0)\n            break;\n    }\n    density = clamp(density, 0.0, 1.0);\n    // formula from Hzzd\n    // Beer-law + Henyey-Greenstein phase function\n    //density *= 2.0;\n    p = 5.0;//max(3.0, sin(TIME)*9.0); // 3, 6, 9 // paper Hzzd\n    float g = mix(0.8, 0.2, daynight); // 0.2 paper Hzzd\n    float RdotL = dot(rd, L);\n    Energy = getEnergyScattered(p, g, density, RdotL);\n\n    cloud_mask = clamp(density*4.0, 0.0, 1.0);\n    cloudColor *= Energy;\n}\n\nbool isRayIntersectSphere(vec3 ro, vec3 rd, vec3 center, float radius)\n{\n    float tmin = -1.0, tmax = -1.0;\n    float d = IntersectSphere(ro, rd, center, radius, tmin, tmax);\n    return tmin>-1.0;\n}\n\nvoid getCloudColor(\n    vec3 Psky,\n    vec3 ro, vec3 rd, vec3 Lo, vec3 L, float Li,\n    out float density,\n    out float Energy, out float cloud_mask, inout vec3 cloudColor,\n\tfloat daynight)\n{\n    vec3 pc = Psky;\n    vec3 Lpc = normalize(Lo-pc);\n    float p = 0.0;\n    density = 1.0;\n\n    Energy = 1.0;\n    vec3 t = normalize(vec3(-1.0, 0.0, 1.0))*TIME(iTime);\n    vec3 P = pc;\n    \n    // formula from Hzzd\n    // Beer-law + Henyey-Greenstein phase function\n    //density *= 2.0;\n    p = 9.0;//max(3.0, sin(TIME)*9.0); // 3, 6, 9 // paper Hzzd\n    float g = mix(0.8, 0.2, daynight); // 0.2 paper Hzzd\n    float RdotL = dot(rd, L);\n   \n    //https://is.muni.cz/th/396277/fi_m/thesis.pdf\n\tcloud_mask = 1.0;\n    \n    float attScat = 1.0;\n    \n    density = 0.0;\n    float energy = 0.0;\n    P = ro+rd*(10.0);\n  \n    for(int i=0;i<4;++i)\n    {\n        //P = ro+rd*(10.0+100.0*density);\n        \n        float dt = cloudNoise3D((P/*height*/)*0.0002, t);\n        \n        if(density>0.5)\n            break;\n        \n        //rd = RotZV3(RotYV3(RotXV3(rd, dt), dt), dt);\n        P += rd*100.0*dt;\n    \tRdotL = dot(rd, normalize(P-Lo));\n        \n        float e = 0.0;\n        e = getEnergyScattered(p, g, density, RdotL)*Li/float(i+1);\n        \n    \tenergy += e;//*mix(-1.0, 1.0, Fresnel_Schlick(1.0, 1.1, RdotL));\n        density+=dt;\n    }\n\n    cloudColor = vec3(energy);\n}\n\nvec3 getSkyColorForPhase(vec3 ro, vec3 rd, float starsQuality, float solarPhase)\n{\n    float daynight = solarPhase;//sin(TIME)>=0.0?1.0:0.0;//max(0.0, dot(vec3(0.0, 1.0, 0.0), -_light.d));\n    vec3 betaR = mix(\n        \t\t\tvec3(0.1e-6, 0.2e-6, 0.5e-6),\n        \t\t\tvec3(5.5e-6, 13.0e-6, 22.4e-6),// DAY\n        \t\t\tdaynight);\n    vec3 betaM = mix(\n        \t\t\tvec3(1e-7),\n        \t\t\tvec3(21e-6),\n        daynight);\n    vec3 color = vec3(0.0);\n    vec3 miecolor = vec3(0.0);\n    \n    \n    vec3 Lo = mix(_moon.o, _light.o, daynight);\n    vec3 L = mix(_moon.d, _light.d, daynight);\n    float Li = mix(_moon.power, _light.power, daynight);\n    \n    color = getSkyLight(ro+vec3(0.0, EARTHRADIUS, 0.0), rd, -L, betaR, betaM, miecolor);//mix(COLORSKYB, COLORSKYT, clamp(rd.y+0.5, 0.0, 1.0));\n    \n    // stars\n    vec3 Psky = getSkyCoord(ro, rd);\n    float sN = gaussianNoise3D(rd*120.0);\n    color += (1.0-daynight)*vec3(max(0.0, min(1.0,sN-0.95))*10.0);\n  \n    float sunGrad = 0.0;\n    float RdotL = dot(rd, -L);\n    if(rd.y>(0.033) && RdotL>0.0/* && tmin>0.0*/)\n    {\n        sunGrad = daynight*pow(max(0.0, pow(RdotL, 2.0)-0.35), mix(MOONINTENSITY, SUNINTENSITY, daynight));\n        sunGrad += pow((pow(RdotL, mix(2056.0, 256.0, daynight))), mix(MOONINTENSITY, SUNINTENSITY, daynight));\n    }\n    \n    float mT = mix(0.001, 1.0, daynight);\n    color += miecolor*sunGrad*mT;\n    \n    vec3 cloudColor = vec3(0.0);\n    float cloud_mask = 0.0;\n    float Energy = 0.0;\n    float density = 0.0;\n    \n    #ifdef CLOUDS\n    \n    getCloudColor(Psky, Psky, rd, Lo, L, Li, density, Energy, cloud_mask, cloudColor, daynight);\n   \tcolor.r = max(0.0, color.r+cloudColor.r);\n    color.g = max(0.0, color.g+cloudColor.g);\n    color.b = max(0.0, color.b+cloudColor.b);\n    #endif\n    \n    #ifdef SHAFTS\n    int i =0;\n    for(i=0;i<5;++i)\n    {\n        vec3 P = ro+rd*float(i)*5.0;\n        vec3 Ld = normalize(Lo-P);\n    \tgetCloudColor(P, L, Lo, -L, density, Energy, cloud_mask, cloudColor);\n        if(cloud_mask<1.0)\n        {\n            color+=(1.0-density)*0.01;\n        }\n    }\n    #endif\n    \n    return color;\n}\n\nvec3 getSkyColor(vec3 ro, vec3 rd, float starsQuality, float solarPhase)\n{\n    #ifdef DAYANDNIGHT\n    return mix(getSkyColorForPhase(ro, rd, starsQuality, 0.0),\n               getSkyColorForPhase(ro, rd, starsQuality, 1.0),\n               solarPhase);\n    #else\n    return getSkyColorForPhase(ro, rd, starsQuality, 1.0);\n    #endif\n}\n\n#define WATERCOLOR1 vec3(0.2, 0.1, 0.0)\n#define WATERCOLOR2 vec3(0.2, 0.4, 0.2)\n#define WATERCOLOR3 vec3(0.2, 0.6, 0.5)\n#define WATERCOLOR4 vec3(0.2, 0.8, 0.5)\n#define WATERCOLOR5 vec3(0.2, 0.4, 0.6)\n\nvec3 getDepthWaterColor(float D)\n{\n    float d = min(1.0, log(1.0+D/WATERSHADING_V4_DEPTH_FACTOR));\n    \n    return mix(WATERCOLOR1,\n        mix(WATERCOLOR2,\n        mix(WATERCOLOR3,\n        mix(WATERCOLOR4, WATERCOLOR5, d)\n            , d)\n        \t, d)\n            , d);\n}\n\n// HDR part function taken from https://www.shadertoy.com/view/lslGzl Zavie's\nvec3 simpleReinhardToneMapping(vec3 color)\n{\n\tfloat exposure = 1.5; // 1.5\n\tcolor *= exposure/(1. + color / exposure);\n    //return vec3(exposure/(1. + color / exposure));\n\tcolor = pow(color, vec3(1. / 1.2)); // gamma = 2.2\n\treturn clamp(color, 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nfloat Remap(float v, float omin, float omax, float nmin, float nmax)\n{\n\treturn nmin+max(0.0, (v-omin))/(omax-omin)*(nmax-nmin);\n}\n\nvec3 rendering(vec3 ro, vec3 rd, vec2 rm, vec2 uv, float solarPhase) {\n    vec3 p = ro+rd*rm.x;\n    vec3 color = vec3(0.0);\n    float horizonvalue = mix(0.0, 2.0, solarPhase);\n    if(rm.x>NEAR && rm.x<FAR) {\n    \tfloat K = mix(0.4, 0.7, solarPhase);\n        float df = (FAR-rm.x)/(FAR-NEAR);\n        if(rm.y == TYPE_FLOOR || rm.y == TYPE_SAND){\n            vec3 n = normalize(mapRMNormal(p, 0.001));\n            color = colorFloor(p, rd, n, rm.y, K, solarPhase);\n        }else if(rm.y == TYPE_WATER)\n        {\n            vec3 n = normalize(mapRMWaterNormal(p, 0.001));\n            vec3 waterColor = vec3(0.0);\n\n            vec2 rmv = raymarchUnderWater(p, vec3(0.0, -1.0, 0.0), NEAR, FAR);\n\n            vec3 rdrf = refract(rd, n, WATER_REFR_INDEX);\n            vec2 rmu = raymarchUnderWater(p, rdrf, NEAR, FAR);\n            vec3 pu = p+rdrf*rmu.x;\n            vec3 nu = mapUnderWaterNormal(pu, 0.001);\n\n            float hyd = 1.0-clamp(rmv.x*0.5, 0.0, 1.0);//min(max(0.0, rmv.x*15.0), 1.0);\n\n            float f = clamp(fresnel(rd, n, REFLREFR_FRESNEL_BIAS, REFLREFR_FRESNEL_SCALE, REFLREFR_FRESNEL_EXPO), 0.0, 1.0);\n\n            vec3 colorU = waterColor;\n            \n            float vdepth = abs(p.y-pu.y);\n            float clampedWaterDepth = clamp(vdepth*1.0, 0.0, 1.0);\n            n.z = -abs(n.z)*mix(1.0, 0.2, clampedWaterDepth);\n            n.x = -abs(n.x)*mix(1.0, 0.2, clampedWaterDepth);\n            n = normalize(n);\n            \n            \n            vdepth = max(0.0, 1.0-Remap(vdepth, 0.0, 1.0, 0.0, 1.0));\n\n            vec3 reflcolor = 0.4*log(1.0+getSkyColor(p, reflect(rd, n), 0.1, solarPhase));\n            // we force TYPE_FLOOR because when the depth is really close to the sea\n            // values get confusing near the shore.\n            vec3 refrcolor = colorFloor(pu, normalize(rdrf), nu, TYPE_FLOOR, K, solarPhase);\n\n            vec3 wColor = mix(refrcolor, reflcolor, clamp(rmu.x/WATERSHADING_V4_VISIBILITY, 0.0, 1.0));\n\n            color = mix(wColor, getDepthWaterColor(rmu.x), clamp((length(p)+rmu.x)/WATERSHADING_V4_EXTINCTION, 0.0, 1.0));\n\n            vec3 H = normalize(rd-_light.d);\n            vec3 LR = -reflect(_light.d, n);\n            float sT = max(0.0, dot(LR, H));\n\n            color += pow(sT, 256.0)*_light.power;\n            #ifdef USE_FOAM\n            float fb = clamp(fbm2Dsimple(p.xz*2.2), 0.0, 1.0);\n            float hshore = max(0.0, vdepth-(1.0-FOAM_MAX_HEIGHT))/FOAM_MAX_HEIGHT;\n            fb = clamp(fb, 0.5, 1.0);\n            float h = hshore*min(1.0, fb);\n\n            float algae_mask = texture(iChannel1, p.xz).r-0.2;\n            algae_mask = (algae_mask+1.0)*(algae_mask+1.0);\n            algae_mask = max(0.0, min(1.0, algae_mask-1.0));\n            \n    \t\tvec3 L = mix(_moon.d, _light.d, solarPhase);\n            \n            float nearShoreMask = max(0.0, hshore-0.8)/0.2;\n            \n            float foamMask = clamp(voronoi2D(p.xz*mix(2., 1.8, max(0.0, hshore))*vec2(1.0, 1.0)), 0.0, 1.0);\n            foamMask = foamMask*foamMask*foamMask*foamMask;\n            \n            vec3 dffFoam = \n                \t\t\tmix(\n                                vec3(1.0),\n                            \tCOLORALGAE,\n                            \tmax(0.0, algae_mask)\n                           \t);\n            \n            vec3 colorFoam = brdf(\n                K, // Ks\n                K, // Kd\n                0.3, // roughness\n                1.0, // opacity\n                vec3(0.0),//vec3(1.0), // specular color\n                dffFoam, // diffuse color\n                rd, // I\n                n, // N\n                -L // L\n                );\n            colorFoam = mix(colorFoam, vec3(1.0), max(foamMask, nearShoreMask));\n            \n            color = mix(color, \n                        colorFoam,\n                        min(1.0, h*fb*2.0));\n            //color = vec3(max(foamMask, nearShoreMask));\n            //color = colorFoam;\n            #endif\n        }\n        float d = rm.x/(FAR-NEAR);\n        float a = clamp(d*d, 0.0, 1.0);//clamp(log(d+1.0)*0.1, 0.0, 1.0);\n        color = mix(color, vec3(horizonvalue), a);\n    }else{\n        color = getSkyColor(ro, rd, 1.0, solarPhase);\n        float ry = 1.0-abs(rd.y);\n        ry = ry*ry*ry*ry;\n        ry = ry*ry*ry*ry;\n        color = mix(color, vec3(horizonvalue), clamp(ry, 0.0, 1.0));\n    }\n    #ifdef HDRS\n    return tonemapping(color);\n    #else\n    return clamp(color, 0.0, 1.0);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    \n    #ifdef DEFERRED\n    \tfloat eps = 0.5/iResolution.x;\n    \tvec3 color = texture(iChannel2, uv+vec2(-eps,-eps)).rgb;\n    \tcolor += texture(iChannel2, uv+vec2(eps,-eps)).rgb;\n    \tcolor += texture(iChannel2, uv+vec2(-eps,eps)).rgb;\n    \tcolor += texture(iChannel2, uv+vec2(eps,eps)).rgb;\n        fragColor = vec4(color*0.25, 1.0);\n    #else\n        vec2 pixel = -1.0 + 2.0*uv;\n        pixel *= iResolution.x/iResolution.y;\n\n    \tvec2 mv = iMouse.xy/iResolution.xy;\n        mv = -1.0 + 2.0*mv;\n        mv *= iResolution.x/iResolution.y;\n\n        vec3 ro = CAMPOS;\n        _light.o = LIGHTPOS;\n\n        vec3 target = ro+vec3(\n            cos(mv.x*2.0),\n            sin(mv.y*1.5),\n            sin(mv.x*2.0));\n\n        mat3 ca = setCamera(ro, target, vec3(0.0, 1.0, 0.0));\n        vec3 rd = ca*normalize(vec3(pixel.xy, 2.5));\n        vec2 rm = vec2(-1.0, -1.0);\n\n        rm = raymarch(ro, rd, NEAR, FAR);\n\n        // updating solar phase\n\n        #ifdef DAYANDNIGHT\n        gSolarPhase = sin(TIME(iTime));//GaussianFunc(fract(TIME)-0.5);//sin(TIME*5.0);//GaussianFunc(fract(TIME)-0.5);\n        _light.o = normalize(vec3(-cos(TIME(iTime)), gSolarPhase, -cos(TIME(iTime))))*SUNDIST;\n        _moon.d = normalize(EARTHPOS-_moon.o*384400000.0);\n        #endif\n        _light.d = normalize(EARTHPOS-_light.o);\n\n        // 0 full night, 1 full day\n        vec3 color = rendering(ro, rd, rm, uv, (gSolarPhase+1.0)/2.0);\n\n        fragColor = vec4(color, 1.0);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n#ifdef DEFERRED\n\n/*******************\n * SAMPLING\n *******************/\n#define FLOOR_TEXTURE_FREQ 0.4\n#define FLOOR_TEXTURE_AMP 0.30\n#define FLOOR_LEVEL -0.80\n\nfloat heightMap(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = FLOOR_TEXTURE_FREQ;\n    for(int i=0;i<5;++i) {\n        vec3 hm = textureLod(iChannel0, p.xz*f, 0.0).rgb;\n        float avg = 1.0-0.33*(hm.r+hm.g+hm.b);\n        h += avg*a;\n        a *= 0.22;\n        //f *= 1.9;\n    }\n    return h-textureLod(iChannel0, p.xz, 0.0).r*0.02+cos(p.x)*0.02+p.z*0.03*log(length(p));\n}\n\nfloat mapTerrain(vec3 p, float s) {\n    float hm = heightMap(p, s);\n    return sdPlane(p-vec3(0.0, -0.25-p.z*0.05, 0.0))+hm;\n}\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nfloat mapSand(vec3 p) {\n    return sdPlane(p-vec3(0.0, -0.8-p.z*0.05, 0.0))-0.2;\n}\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0), FLOOR_TEXTURE_AMP), TYPE_FLOOR);\n    //d = opU(d, vec2(mapSand(p-vec3(0.0, FLOOR_LEVEL, 0.0)), TYPE_SAND));\n    return d;\n}\n\nvec2 mapDetailed(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0), FLOOR_TEXTURE_AMP), TYPE_FLOOR);\n    return d;\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapDetailed(pt).x;    \n    normal.x = mapDetailed(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapDetailed(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    \n    vec2 pixel = -1.0 + 2.0*uv;\n    pixel *= iResolution.x/iResolution.y;\n\n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy;\n    mv *= iResolution.x/iResolution.y;\n\n    vec3 ro = CAMPOS;\n\n    vec3 target = ro+vec3(\n        cos(mv.x*2.0),\n        sin(mv.y*1.5),\n        sin(mv.x*2.0));\n\n    mat3 ca = setCamera(ro, target, vec3(0.0, 1.0, 0.0));\n    vec3 rd = ca*normalize(vec3(pixel.xy, 2.5));\n    vec2 rm = vec2(-1.0, -1.0);\n\n    rm = raymarch(ro, rd, NEAR, FAR);\n\n    vec2 Np = normal_pack(mapNormal(ro+rd*rm.x, 0.001));\n    \n    fragColor = vec4(rm.x, rm.y, Np.x, Np.y);\n}\n\n#else\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n}\n\n#endif","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n/**************************\n * DEFERRED MODE\n * The deferred mode uses two passes\n * First one generates a packed Float4 gbuffer [Depth, Type, Nx, Ny]\n * The second handles the rendering\n * Water is renderer as a screenspace effect.\n ***************************\n * FULL RAYMARCHING\n * When commenting you swap to a full raymarching method.\n * Water, refractions, rocks etc are raymarched\n * => huge processing and extensive use of registers\n ***************************/\n\n//#define DEFERRED\n#define HDRS\n// Improve the scene, but costs a lot\n//#define CLOUDS\n#define DAYANDNIGHT\n#define USE_FOAM\n#define WAVES\n\n/******************\n * RAYMARCHING PARAMETERS\n ******************/\n#define FAR 80.0\n#define NEAR 0.1\n#define NUM_STEPS 80\n\n#define CAMPOS vec3(-9.0, 1.0, -3.0)\n#define TARGETPOS vec3(10.0, 1.0, 10.0)\n#define LIGHTPOS normalize(vec3(1.0, 1.0, 1.0))*149597870700.0\n\n#define TYPE_FLOOR 0.0\n#define TYPE_SAND 1.0\n#define TYPE_WATER 2.0\n#define TYPE_BOAT 3.0\n#define TYPE_CLOUD 4.0\n\n#define TIME(t) (t+1.0)*0.1\n\n/*******************\n * RENDERING\n *******************/\n#define MOONINTENSITY 5.0\n#define SUNRADIUS 695700000.0\n\n#define FOAM_HEIGHT 0.05\n#define FOAM_MAX_HEIGHT 0.3\n\n#define WATER_REFR_INDEX 1.0/1.33\n\n#define COLORALGAE vec3(0.2, 0.6, 0.1)\n\n#define REFLREFR_FRESNEL_BIAS 0.18\n#define REFLREFR_FRESNEL_SCALE 1.0\n#define REFLREFR_FRESNEL_EXPO 0.8\n\n/*******************\n * MATH\n *******************/\n#define PI2 1.57\n#define PI 3.1415\n#define _2PI 6.2830\n\n/********************\n * WATER PARAMETERS\n ********************/\n#ifdef DEFERRED\n    #define WATER_FREQ 1.5\n    #define WATER_AMP 0.2\n    #define WATER_SPEED 1.0\n    #define WATER_LEVEL 0.1\n\t//#define FLOOD\n    // 0.03\n    #define FLOOD_AMP 0.00\n    // WAVES allows the water to \"wave\" giving the illusion of sea water\n    // you can also control the waves using the following parameters\n    #define WAVES_AMP 0.1\n    // 1.0\n    #define WAVES_FREQ 0.01\n#define WAVES_SPEED 2.6\n#else\n    #define WATER_FREQ 3.5\n    #define WATER_AMP 0.05\n    #define WATER_SPEED 1.5\n    #define WATER_LEVEL 0.1\n    //#define FLOOD\n    // 0.03\n    #define FLOOD_AMP 0.00\n    // WAVES allows the water to \"wave\" giving the illusion of sea water\n    // you can also control the waves using the following parameters\n    #define WAVES_AMP 5.1\n    // 1.0\n    #define WAVES_FREQ 0.01\n    #define WAVES_SPEED 2.6\n#endif\n\n/*******************\n * SCATTERING PARAMETERS\n *******************/\n#define EARTHPOS vec3(0.0, 0.0, 0.0)\n#define ATMOSPHERERADIUS 6420e3\n#define EARTHRADIUS 6360e3\n#define SUNINTENSITY 20.0\n#define SUNDIST 149597870700.0\n\n\n/*******************\n * TOOLS\n *******************/\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat GetNormalizedDepth(float x)\n{\n\treturn (FAR-x)/(FAR-NEAR);   \n}\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\nvec3 RotXYZ(in vec3 P, vec3 xyz)\n{\n    P = RotXV3(P, xyz.x);\n    P = RotYV3(P, xyz.y);\n    P = RotZV3(P, xyz.z);\n    return P;\n}\n\nfloat GaussianFunc(float x)\n{\n    float g = exp(-x*x/2.0);\n    g = g*g*g*g;\n    return g*g*g*g;\n}\n\nvec2 normal_pack(vec3 n)\n{\n    return n.xy*0.5+0.5;\n}\n\nvec3 normal_unpack(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\n/********************\n * NOISES\n ********************/\n\nfloat hash1D(float x) {\n\treturn fract(sin(x*13.454)*12.3043);\n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n    x = vec3(hash2D(x.xy), hash2D(x.yz), hash2D(x.xz));\n\treturn fract(dot(x, vec3(12.4955, 49.4294, 42.40594))*13.4959451);    \n}\n\nfloat simpleNoise(vec2 p)\n{\n    float s = sin(p.x), c = cos(p.y);\n    p = mat2(c, -s, s, c)*p;\n    vec2 f = floor(p);\n    vec2 f_ = smoothstep(0.0, 1.0, fract(p));\n    float x = p.x+13.0*p.y;\n    \n    return mix(\n        \tmix(hash1D(x+0.0), hash1D(x+13.0), f.x),\n        \tmix(hash1D(x+13.0), hash1D(x+42.0), f.x),\n        \tf.y);\n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\n\n/** HASH **/\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat cloud_mask_internal(vec2 uv, float t)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv+t); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv-t); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv+t); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv-t); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat cloud_mask(vec2 uv, float t)\n{\n    return cloud_mask_internal(1.0+uv*4.0, t)*cloud_mask_internal(uv*10.0, t);\n}\n\n/**\n * Cloud Noise\n **/\n\nfloat gaussianNoise(vec2 uv)\n{\n\tvec2 p = floor(uv);\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n    f = f*f*(3.0-2.0*f);\n    /*float c = cos(uv.x);\n    float s = sin(uv.y);\n    mat2 R = mat2(c, s, -s, c);*/\n    \n    return mix(\n        \tmix(hash2D(p+vec2(0.0, 0.0)), hash2D(p+vec2(1.0, 0.0)), f.x),\n        \tmix(hash2D(p+vec2(0.0, 1.0)), hash2D(p+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm2Dsimple(vec2 p) {\n    float total = 0.0;\n    total  = 0.5000* gaussianNoise(p); p = p*2.0;\n    total += 0.2500* gaussianNoise(p); p = p*2.0;\n    total += 0.1250* gaussianNoise(p); p = p*2.0;\n    total += 0.0625* gaussianNoise(p); p = p*2.0;\n    return total;\n}\n\nfloat cloudNoise2D(vec2 uv, vec2 _wind)\n{\n    float v = 1.0-voronoi2D(uv*10.0+_wind);\n    float fs = fbm2Dsimple(uv*20.0+_wind);\n    return clamp(v*fs, 0.0, 1.0);\n}\n\nfloat gaussianNoise3D(vec3 uv)\n{\n\tvec3 p = floor(uv);\n    vec3 f = fract(uv);\n    \n    f = f*f*(3.0-2.0*f);\n    /*float c = cos(uv.x);\n    float s = sin(uv.y);\n    mat2 R = mat2(c, s, -s, c);*/\n    \n    return\n        mix(\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, 0.0)), hash3D(p+vec3(1.0, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, 1.0, 0.0)), hash3D(p+vec3(1.0, 1.0, 0.0)), f.x),\n            f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, 1.0)), hash3D(p+vec3(1.0, 0.0, 1.0)), f.x),\n                mix(hash3D(p+vec3(0.0, 1.0, 1.0)), hash3D(p+vec3(1.0, 1.0, 1.0)), f.x),\n            f.y),\n        f.z);\n}\n\nfloat fbm3Dsimple(vec3 p) {\n    float total = 0.0;\n    total  = 0.5000* gaussianNoise3D(p); p = p*2.0;\n    total += 0.2500* gaussianNoise3D(p); p = p*2.0;\n    total += 0.1250* gaussianNoise3D(p); p = p*2.0;\n    total += 0.0625* gaussianNoise3D(p); p = p*2.0;\n    return total;\n}\n\nfloat cloudNoise3D(vec3 uv, vec3 _wind)\n{\n    float v = 1.0-voronoi3D(uv*20.0+_wind);\n    float fs = fbm3Dsimple(uv*40.0+_wind);\n    float mask = fbm3Dsimple(uv*0.1+_wind);\n    return clamp(v*fs*mask, 0.0, 1.0);\n}\n\n/************************\n * RAYMARCHING PRIMITIVES\n ************************/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n/************************\n * HEIGHTMAPS\n ************************/\nfloat GertsnerWave(vec2 _dir, vec2 _pos, float _waveLength, float T)\n{\n    float W = _2PI/_waveLength;\n    float Dp = dot(_dir, _pos);\n    return sin(W*Dp+T);\n}\n\nfloat wave(vec3 p, float amp, float T)\n{\n    //return (p.z>0.0?1.0:0.0)*(-0.3+WAVES_AMP-WAVES_AMP*sin((p.z+TIME*WAVES_SPEED)*WAVES_FREQ))*min(1.0, p.z);\n    //return max(0.0, trochoid(-p.z, 0.8, TIME*WAVES_SPEED));//*log(p.z+4.0));\n    //return (-p.z+sin(iTime*WAVES_SPEED))*FLOOD_AMP;\n    //return p.z*0.10*sin((p.z)*WAVES_FREQ+TIME*WAVES_SPEED)*WAVES_AMP;\n    return GertsnerWave(\n        normalize(vec2(0.0, 1.0)),\n        p.xz,\n        0.8, T)*amp;\n}\n\nfloat heightMapWater(vec3 p, float t)\n{\n    float h = 0.0;\n    vec3 op = p;\n    #ifdef FLOOD\n    float w = (-p.z+sin(TIME*WAVES_SPEED))*FLOOD_AMP;\n    #endif\n    float a = WATER_AMP;\n    float f = WATER_FREQ;\n    float T = TIME(t)*WATER_SPEED;\n    //h = 0.2*(-1.0+fbm_hash(p.xz+TIME)+fbm_hash(p.xz-TIME)); \n    for(int i = 0;i < 3; ++i)\n    {\n//     e((−2πikn)/N   )\n        float ffta = 1.0;//exp((-2.0*3.14*float(i)*(f*length(p)+T))/6.0);\n    \th = a*(-1.0+fbm2Dsimple(f*p.xz+T)+fbm2Dsimple(f*p.xz-T))*ffta; \n        a*= 0.8;\n        f *= 1.2;\n    }\n    //for(int i=0;i<5;++i) {\n    //}\n    #ifdef WAVES\n    h+= wave(op,\n             mix(0.05, 0.9, min(1.0, max(0.0,p.z)/3.2)),\n             T*5.0)*clamp(h, 0.2, 0.6);\n        //*gaussianNoise(op.xz*0.1+T);\n    #endif\n    #ifdef FLOOD\n    return h+w;\n    #else\n    return h;\n    #endif \n}\nfloat heightMapWaterDetailed(vec3 p, float t)\n{\n    float h = 0.0;\n    vec3 op = p;\n    #ifdef FLOOD\n    float w = (-p.z+sin(TIME*WAVES_SPEED))*FLOOD_AMP;\n    #endif\n    float a = WATER_AMP;\n    float f = WATER_FREQ;\n    float T = TIME(t)*WATER_SPEED;\n    float R = hash1D(t);\n    mat2 M = mat2(cos(R), -sin(R), sin(R), cos(R));\n    vec2 W = vec2(T, T);\n    //h = a*(-1.0+fbm2Dsimple(p.xz*f+T)+fbm2Dsimple(p.xz*f-T));\n    for(int i = 0;i < 4; ++i)\n    {\n//     e((−2πikn)/N   )\n        float ffta = 1.0;//exp((-2.0*3.14*float(i))/7.0);\n        h += a*abs(sin(fbm2Dsimple(f*p.xz+W)-0.5)*3.14);\n        a*= 0.8;\n        f *= 1.2;\n        W = mat2(0.2, -0.8, 0.8, 0.2)*W;\n    }\n    //for(int i=0;i<5;++i) {\n    //}\n    #ifdef WAVES\n    h+= wave(op,\n             mix(0.05, 0.9, min(1.0, max(0.0,p.z)/3.2)),\n             T*5.0)\n        *gaussianNoise(op.xz*0.1+T)*(0.8/p.y);\n    #endif\n    #ifdef FLOOD\n    return h+w;\n    #else\n    return h;\n    #endif   \n}\n\n/*******************************\n * Atmosphere scattering\n *******************************/\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = -B/2.0;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\n// From http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 getSkyLight(vec3 ro, vec3 rd, vec3 L, vec3 betaR, vec3 betaM, out vec3 miecolor)\n{\n    vec3 light = vec3(0.0);\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n    vec3 Pa = ro+rd*tmax;\n    /*if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);*/\n    float RdotL = dot(rd, L);\n    float tCurrent = 0.0;\n    float segL = tmax/16.0;\n    /*if(d>0.0)\n        segL = (tmax-tmin)/16.0;*/\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 7994.0; // 7994\n    float hm = 300.0; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation has an error with the first terms in the equation\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    //vec3 betaM = vec3(21e-6);\n    float opticalDepthM = 0.0;\n    float cloudScat = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTHRADIUS;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = L;//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);\n        float segLLight = tlmax/8.0;\n        float tCurrentLight = 0.0;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        float cloudDensity = 0.0;\n        for (int j = 0; j < 8; ++j)\n        {\n            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n            float hLight = length(samplePositionLight) - EARTHRADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(-hLight / hr) * segLLight;\n            opticalDepthLightM += exp(-hLight / hm) * segLLight;\n            //cloudDensity += mix(0.0, cloud_mask(1e-4*samplePositionLight.xz*exp(normalize(samplePositionLight).y), 0.0), rd.y);\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            cloudDensity = clamp(cloudDensity, 0.0, 1.0);\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            //attenuation = mix(attenuation, vec3(tau*cloudDensity), cloudDensity);\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    miecolor = SUNINTENSITY * sumM * phaseM;\n    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n#ifdef DEFERRED\n\n\n/*******************\n * SAMPLING\n *******************/\n#define FLOOR_TEXTURE_FREQ 0.4\n#define FLOOR_TEXTURE_AMP 0.30\n#define FLOOR_LEVEL -0.80\n\n/*******************\n * RENDERING\n *******************/\n\n#define WATERSHADING_V4_VISIBILITY 1.0 // 0.2\n#define WATERSHADING_V4_EXTINCTION 100.0\n#define WATERSHADING_V4_DEPTH_FACTOR 1.0\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    vec4 specColor;\n    float shininess;\n\tfloat power;\n};\n\nLight _light = Light(\n    LIGHTPOS,\n    -normalize(TARGETPOS-vec3(0.0, 4.5, 4.5)),\n    vec4(1.0, 1.0, 0.8, 1.0),\n    vec4(1.0, 1.0, 0.8, 1.0),\n    2.0,\n    SUNINTENSITY);\n    //38000.0);\n\nLight _moon = Light(\n    normalize(vec3(0.8, 0.5, 1.0)), \n    normalize(TARGETPOS-vec3(0.0, 1.0, 10.0)),\n    vec4(0.8, 0.8, 1.0, 1.0),\n    vec4(0.8, 0.8, 1.0, 1.0),\n    2.0,\n    MOONINTENSITY);\nfloat gSolarPhase = 1.0;\n\nfloat tnoise(vec2 p)\n{\n    return textureLod(iChannel3, p, 0.0).x;\n}\n\nfloat waterDetails(vec3 p, float t)\n{\n    float h = 0.0;\n    float a = 0.04;\n    float f = 0.12;//0.05;\n    vec2 T = vec2(TIME(t), TIME(t))*0.1;\n    for(int i = 0;i < 7; ++i)\n    {\n        h -= a*abs(sin(tnoise(f*p.xz+T)-0.5));\n        a*= 0.5;\n        //f *= 1.0;\n        T*=1.3;\n        p.xz = mat2(1.6, -1.2, 1.2, 1.6)*p.xz*0.8;\n    }\n    return h;\n}\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec3 mapRMWaterNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = sdPlane(pt)+waterDetails(pt, iTime);    \n    normal.x = (sdPlane(pt)+waterDetails(vec3(pt.x+e,pt.y,pt.z), iTime)) - normal.y;\n    normal.z = (sdPlane(pt)+waterDetails(vec3(pt.x,pt.y,pt.z+e), iTime)) - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n/************************\n * RENDERING\n ************************/\n\nfloat fresnel(vec3 I, vec3 N, float B, float S, float E)\n{\n    return B+S*pow(max(0.0, 1.0+dot(I,N)),E);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / max(0.0001, 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.01);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.01);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.01);\n  float VdotH = max(dot(viewDirection, H), 0.0001);\n  float LdotH = max(dot(lightDirection, H), 0.0001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(roughness, NdotH);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)*max(0.0, dot(N, L))+Ks*specularColor*spec) * Oi;\n}\n\nvec3 colorFloor(vec3 P, vec3 I, vec3 N, float K, float solarPhase)\n{\n    vec3 L = mix(_moon.d, _light.d, solarPhase);\n    vec3 color = vec3(0.0);\n    float ao = texture(iChannel1, P.xz*FLOOR_TEXTURE_FREQ).r;\n    vec3 diff = texture(iChannel2, P.xz*FLOOR_TEXTURE_FREQ).rgb;\n\n    float algae_mask = max(0.0, texture(iChannel2, P.xz).r-0.5);\n\n    diff = mix(diff, COLORALGAE, algae_mask);\n    float roughness = mix(0.2, 1.0, algae_mask);\n\n    color = brdf(\n        K, // Ks\n        K, // Kd\n        roughness, // roughness\n        1.0, // opacity\n        diff,//vec3(1.0), // specular color\n        diff, // diffuse color\n        I, // I\n        N, // N\n        -L // L\n    )*ao;\n    return color;\n}\n\nvec3 getSkyCoord(vec3 ro, vec3 rd)\n{\n    float tmin = -1.0, tmax = -1.0;\n    float d = IntersectSphere(\n        ro+vec3(0.0, 401.0, 0.0), rd, vec3(0.0, 0.0, 0.0),\n        400.0+2.0,\n        tmin, tmax);\n    return ro+rd*tmin;\n}\n\n// Physically Based Rendering, From Theory to Implementation\nfloat PhaseSchlick(float g, float RdotL)\n{\n    float k = 1.55* g - 0.555*g*g*g;\n    RdotL = k*RdotL;\n    return 1.0/(4.0*PI) * (1.0-k*k) / ((1.0-RdotL)*(1.0-RdotL));\n}\n\n// formula from Hzzd\n// Beer-law + Henyey-Greenstein phase function\nfloat getEnergyScattered(float p, float g, float density, float RdotL)\n{\n   return 2.0\n       * exp(-density*p)\n       * (1.0-exp(-2.0*density))\n       * PhaseSchlick(g, RdotL);\n       //* ((1.0-g*g)/pow((1.0+g*g-2.0*g*RdotL), 1.5))/(4.0*3.1415));\n}\n\nvoid getCloudColorOld(\n    vec3 Psky,\n    vec3 ro, vec3 rd, vec3 Lo, vec3 L,\n    out float density,\n    out float Energy, out float cloud_mask, inout vec3 cloudColor,\n\tfloat daynight)\n{\n    vec3 pc = Psky;\n    vec3 Lpc = normalize(Lo-pc);\n    float p = 0.0;\n    density = 0.0;\n    \n    #define CLOUDRMSTEP 0.5\n    #define CLOUDSTEPS 5\n\n    Energy = 1.0;\n        vec3 t = normalize(vec3(-1.0, 0.0, 1.0))*TIME(iTime);\n    vec3 P = pc;\n    for(int i=0;i<CLOUDSTEPS;++i)\n    {\n        //vec3 P = pc+Lpc*(float(i)*CLOUDRMSTEP);\n        P += normalize(Lpc)*CLOUDRMSTEP;\n        P = RotXYZ(P, normalize(vec3(0.4, 0.4, 0.0)));\n            \t\n        //float height = mix(1.0, 0.1, clamp(P.y/5.0, 0.0, 1.0));\n        float mask = clamp(gaussianNoise3D(P*0.006+t), 0.0, 1.0);\n        mask *= mask*mask*mask;\n        float dt = cloudNoise3D((P/*height*/)*0.0002, t);\n        density += dt*mask;\n        if(density>1.0)\n            break;\n    }\n    density = clamp(density, 0.0, 1.0);\n    // formula from Hzzd\n    // Beer-law + Henyey-Greenstein phase function\n    //density *= 2.0;\n    p = 5.0;//max(3.0, sin(TIME)*9.0); // 3, 6, 9 // paper Hzzd\n    float g = mix(0.8, 0.2, daynight); // 0.2 paper Hzzd\n    float RdotL = dot(rd, L);\n    Energy = getEnergyScattered(p, g, density, RdotL);\n\n    cloud_mask = clamp(density*4.0, 0.0, 1.0);\n    cloudColor *= Energy;\n}\n\nbool isRayIntersectSphere(vec3 ro, vec3 rd, vec3 center, float radius)\n{\n    float tmin = -1.0, tmax = -1.0;\n    float d = IntersectSphere(ro, rd, center, radius, tmin, tmax);\n    return tmin>-1.0;\n}\n\nvoid getCloudColor(\n    vec3 Psky,\n    vec3 ro, vec3 rd, vec3 Lo, vec3 L, float Li,\n    out float density,\n    out float Energy, out float cloud_mask, inout vec3 cloudColor,\n\tfloat daynight)\n{\n    vec3 pc = Psky;\n    vec3 Lpc = normalize(Lo-pc);\n    float p = 0.0;\n    density = 1.0;\n\n    Energy = 1.0;\n    vec3 t = normalize(vec3(-1.0, 0.0, 1.0))*TIME(iTime);\n    vec3 P = pc;\n    \n    // formula from Hzzd\n    // Beer-law + Henyey-Greenstein phase function\n    //density *= 2.0;\n    p = 9.0;//max(3.0, sin(TIME)*9.0); // 3, 6, 9 // paper Hzzd\n    float g = mix(0.8, 0.2, daynight); // 0.2 paper Hzzd\n    float RdotL = dot(rd, L);\n   \n    //https://is.muni.cz/th/396277/fi_m/thesis.pdf\n\tcloud_mask = 1.0;\n    \n    float attScat = 1.0;\n    \n    density = 0.0;\n    float energy = 0.0;\n    P = ro+rd*(10.0);\n  \n    for(int i=0;i<10;++i)\n    {\n        //P = ro+rd*(10.0+100.0*density);\n        \n        float dt = cloudNoise3D((P/*height*/)*0.0002, t);\n        \n        if(density>0.5)\n            break;\n        \n        //rd = RotZV3(RotYV3(RotXV3(rd, dt), dt), dt);\n        P += rd*100.0*dt;\n    \tRdotL = dot(rd, normalize(P-Lo));\n        \n        float e = 0.0;\n        e = getEnergyScattered(p, g, density, RdotL)*Li/float(i+1);\n        \n    \tenergy += e;//*mix(-1.0, 1.0, Fresnel_Schlick(1.0, 1.1, RdotL));\n        density+=dt;\n    }\n\n    cloudColor = vec3(energy);\n}\n\nvec3 getSkyColorForPhase(vec3 ro, vec3 rd, float starsQuality, float solarPhase)\n{\n    float daynight = solarPhase;//sin(TIME)>=0.0?1.0:0.0;//max(0.0, dot(vec3(0.0, 1.0, 0.0), -_light.d));\n    vec3 betaR = mix(\n        \t\t\tvec3(0.1e-6, 0.2e-6, 0.5e-6),\n        \t\t\tvec3(5.5e-6, 13.0e-6, 22.4e-6),// DAY\n        \t\t\tdaynight);\n    vec3 betaM = mix(\n        \t\t\tvec3(1e-7),\n        \t\t\tvec3(21e-6),\n        daynight);\n    vec3 color = vec3(0.0);\n    vec3 miecolor = vec3(0.0);\n    \n    \n    vec3 Lo = mix(_moon.o, _light.o, daynight);\n    vec3 L = mix(_moon.d, _light.d, daynight);\n    float Li = mix(_moon.power, _light.power, daynight);\n    \n    color = getSkyLight(ro+vec3(0.0, EARTHRADIUS, 0.0), rd, -L, betaR, betaM, miecolor);//mix(COLORSKYB, COLORSKYT, clamp(rd.y+0.5, 0.0, 1.0));\n    \n    // stars\n    vec3 Psky = getSkyCoord(ro, rd);\n    float sN = gaussianNoise3D(rd*120.0);\n    color += (1.0-daynight)*vec3(max(0.0, min(1.0,sN-0.95))*10.0);\n  \n    float sunGrad = 0.0;\n    float RdotL = dot(rd, -L);\n    if(rd.y>(0.033) && RdotL>0.0/* && tmin>0.0*/)\n    {\n        sunGrad = daynight*pow(max(0.0, pow(RdotL, 2.0)-0.35), mix(MOONINTENSITY, SUNINTENSITY, daynight));\n        sunGrad += pow((pow(RdotL, mix(2056.0, 256.0, daynight))), mix(MOONINTENSITY, SUNINTENSITY, daynight));\n    }\n    \n    float mT = mix(0.001, 1.0, daynight);\n    color += miecolor*sunGrad*mT;\n    \n    vec3 cloudColor = vec3(0.0);\n    float cloud_mask = 0.0;\n    float Energy = 0.0;\n    float density = 0.0;\n    \n    #ifdef CLOUDS\n    \n    getCloudColor(Psky, Psky, rd, Lo, L, Li, density, Energy, cloud_mask, cloudColor, daynight);\n   \tcolor.r = max(0.0, color.r+cloudColor.r);\n    color.g = max(0.0, color.g+cloudColor.g);\n    color.b = max(0.0, color.b+cloudColor.b);\n    #endif\n    \n    #ifdef SHAFTS\n    int i =0;\n    for(i=0;i<5;++i)\n    {\n        vec3 P = ro+rd*float(i)*5.0;\n        vec3 Ld = normalize(Lo-P);\n    \tgetCloudColor(P, L, Lo, -L, density, Energy, cloud_mask, cloudColor);\n        if(cloud_mask<1.0)\n        {\n            color+=(1.0-density)*0.01;\n        }\n    }\n    #endif\n    \n    return color;\n}\n\nvec3 getSkyColor(vec3 ro, vec3 rd, float starsQuality, float solarPhase)\n{\n    #ifdef DAYANDNIGHT\n    return mix(getSkyColorForPhase(ro, rd, starsQuality, 0.0),\n               getSkyColorForPhase(ro, rd, starsQuality, 1.0),\n               solarPhase);\n    #else\n    return getSkyColorForPhase(ro, rd, starsQuality, 1.0);\n    #endif\n}\n\n#define WATERCOLOR1 vec3(0.010, 0.01, 0.1)\n#define WATERCOLOR2 vec3(0.010, 0.01, 0.1)\n#define WATERCOLOR3 vec3(0.010, 0.02, 0.1)\n#define WATERCOLOR4 vec3(0.009, 0.04, 0.1)\n#define WATERCOLOR5 vec3(0.008, 0.05, 0.1)\n\nvec3 getDepthWaterColor(float D)\n{\n    float d = max(0.0, min(1.0, 2.0*log(1.0+D/0.9)));\n\n    return mix(WATERCOLOR1,\n        mix(WATERCOLOR2,\n        mix(WATERCOLOR3,\n        mix(WATERCOLOR4, WATERCOLOR5, d)\n            , d)\n        \t, d)\n            , d);\n}\n\n// HDR part function taken from https://www.shadertoy.com/view/lslGzl Zavie's\nvec3 simpleReinhardToneMapping(vec3 color)\n{\n\tfloat exposure = 1.5; // 1.5\n\tcolor *= exposure/(1. + color / exposure);\n    //return vec3(exposure/(1. + color / exposure));\n\tcolor = pow(color, vec3(1. / 1.2)); // gamma = 2.2\n\treturn clamp(color, 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nfloat Remap(float v, float omin, float omax, float nmin, float nmax)\n{\n\treturn nmin+max(0.0, (v-omin))/(omax-omin)*(nmax-nmin);\n}\n\nvec3 normal_decode(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\nvec3 rendering(vec3 ro, vec3 rd, vec2 rm, vec3 n, vec2 uv, float solarPhase) {\n    vec3 p = ro+rd*rm.x;\n    vec3 color = vec3(0.0);\n    float horizonvalue = mix(0.0, 2.0, solarPhase);\n    if(rd.y<0.0 || rm.x>NEAR && rm.x<FAR) {\n    \tfloat K = mix(0.4, 0.7, solarPhase);\n        float df = (FAR-rm.x)/(FAR-NEAR);\n\t\tfloat wh = heightMapWaterDetailed(p, iTime)-1.0;\n        if((p.y-wh)<0.0)\n        {\n            float waterDepth = abs(p.y-wh);\n            float clampedWaterDepth = clamp(waterDepth*0.05, 0.0, 1.0);\n            vec3 n = normalize(mapRMWaterNormal(p, 0.001));\n            n.z = -abs(n.z)*mix(0.6, 0.0, clampedWaterDepth);\n            n.x = -abs(n.x)*mix(0.6, 0.0, clampedWaterDepth);\n            n = normalize(n);\n            vec3 waterColor = vec3(0.0);\n            vec3 pw = vec3(p.x, wh, p.z);\n\n            vec3 rdrf = refract(rd, n, WATER_REFR_INDEX);\n            vec3 pu = p+rdrf*waterDepth;\n            vec3 nu = n;\n\n            float f = clamp(fresnel(rd, n, REFLREFR_FRESNEL_BIAS, REFLREFR_FRESNEL_SCALE, REFLREFR_FRESNEL_EXPO), 0.0, 1.0);\n\n            vec3 colorU = waterColor;\n            \n            float vdepth = waterDepth;\n            vdepth = max(0.0, 1.0-Remap(vdepth, 0.0, 1.0, 0.0, 1.0));\n\n            vec3 reflcolor = 0.4*log(1.0+getSkyColor(pw, reflect(rd, n), 0.1, solarPhase));\n            // we force TYPE_FLOOR because when the depth is really close to the sea\n            // values get confusing near the shore.\n            vec3 refrcolor = colorFloor(p+rdrf, normalize(rdrf), nu, K, solarPhase);\n            vec3 wColor = mix(refrcolor, reflcolor, clamp(waterDepth/WATERSHADING_V4_VISIBILITY, 0.0, 1.0));\n         \n            color = mix(wColor,\n                        getDepthWaterColor(vdepth),\n                        clamp(waterDepth/WATERSHADING_V4_EXTINCTION, 0.2, 0.8));\n\n            vec3 H = normalize(rd-_light.d);\n            vec3 LR = -reflect(_light.d, n);\n            float sT = max(0.0, dot(LR, H));\n\n            color += pow(sT, 256.0)*_light.power;\n            \n            #ifdef USE_FOAM\n                float fb = clamp(fbm2Dsimple(p.xz*2.2), 0.0, 1.0);\n                float hshore = max(0.0, vdepth-(1.0-FOAM_MAX_HEIGHT))/FOAM_MAX_HEIGHT;\n                fb = clamp(fb, 0.5, 1.0);\n                float h = hshore*min(1.0, fb);\n\n                float algae_mask = texture(iChannel1, p.xz).r-0.2;\n                algae_mask = (algae_mask+1.0)*(algae_mask+1.0);\n                algae_mask = max(0.0, min(1.0, algae_mask-1.0));\n\n                vec3 L = mix(_moon.d, _light.d, solarPhase);\n\n                float nearShoreMask = max(0.0, hshore-0.8)/0.2;\n\n                float foamMask = clamp(voronoi2D(p.xz*mix(2., 1.8, max(0.0, hshore))*vec2(1.0, 1.0)), 0.0, 1.0);\n                foamMask = foamMask*foamMask*foamMask*foamMask;\n\n                vec3 dffFoam = \n                                mix(\n                                    vec3(1.0),\n                                    COLORALGAE,\n                                    max(0.0, algae_mask)\n                                );\n\n                vec3 colorFoam = brdf(\n                    K, // Ks\n                    K, // Kd\n                    0.3, // roughness\n                    1.0, // opacity\n                    vec3(0.0),//vec3(1.0), // specular color\n                    dffFoam, // diffuse color\n                    rd, // I\n                    n, // N\n                    -L // L\n                    );\n                //colorFoam = mix(colorFoam, vec3(1.0), max(foamMask, nearShoreMask));\n\n            \tcolor += colorFoam*h*fb;\n                /*color = mix(color, \n                            colorFoam,\n                            min(1.0, h*fb*2.0));*/\n                //color = vec3(max(foamMask, nearShoreMask));\n                //color = colorFoam;\n            #endif\n        }\n        else if(rm.y == TYPE_FLOOR || rm.y == TYPE_SAND){\n            vec3 N = normalize(n);\n            color = colorFloor(p, rd, N, K, solarPhase);\n        }\n        float drd = pow(1.0-abs(rd.y), 16.0);\n        float d = min(drd, rm.x/(FAR-NEAR));\n        float a = clamp(d*d, 0.0, 1.0);//clamp(log(d+1.0)*0.1, 0.0, 1.0);\n        color = mix(color, vec3(horizonvalue), a);\n    }else{\n        color = getSkyColor(ro, rd, 1.0, solarPhase);\n        float ry = 1.0-abs(rd.y);\n        ry = ry*ry*ry*ry;\n        ry = ry*ry*ry*ry;\n        color = mix(color, vec3(horizonvalue), clamp(ry, 0.0, 1.0));\n    }\n    #ifdef HDRS\n    return tonemapping(color);\n    #else\n    return clamp(color, 0.0, 1.0);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    \n    vec2 pixel = -1.0 + 2.0*uv;\n    pixel *= iResolution.x/iResolution.y;\n\n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy;\n    mv *= iResolution.x/iResolution.y;\n\n    vec3 ro = CAMPOS;\n\n    vec3 target = ro+vec3(\n        cos(mv.x*2.0),\n        sin(mv.y*1.5),\n        sin(mv.x*2.0))*1.0;\n\n    mat3 ca = setCamera(ro, target, vec3(0.0, 1.0, 0.0));\n    vec3 rd = ca*normalize(vec3(pixel.xy, 2.5));\n    \n    vec4 gbuffer = texture(iChannel0, uv);\n    \n    _light.o = LIGHTPOS;\n    // updating solar phase\n\n    #ifdef DAYANDNIGHT\n    gSolarPhase = sin(TIME(iTime));\n    _light.o = normalize(vec3(-cos(TIME(iTime)), gSolarPhase, -cos(TIME(iTime))))*SUNDIST;\n    _moon.d = normalize(EARTHPOS-_moon.o*384400000.0);\n    #endif\n    _light.d = normalize(EARTHPOS-_light.o);\n\n    \n    // 0 full night, 1 full day\n    vec3 color = rendering(ro, rd, gbuffer.xy, normal_unpack(gbuffer.zw), uv, (gSolarPhase+1.0)/2.0);\n\n    fragColor = vec4(color, 1.0);\n}\n\n#else\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n}\n\n#endif","name":"Buffer B","description":"","type":"buffer"}]}