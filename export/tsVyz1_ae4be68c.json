{"ver":"0.1","info":{"id":"tsVyz1","date":"1602260818","viewed":92,"name":"snakeRotation","username":"Kaeylos","description":"#1 Rotation\nmade during the Ink-MAC-tober 2020\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","rotation","imac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// #define FREE_CAM\n\n// ----- Render options ----- //\n#define AA_SAMPLES 1 // antialisaing\n\n// ----- Ray marching options ----- //\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 25\n#else\n    #define MAX_STEPS 150\n#endif\n#define MAX_DIST 50.\n#define SURF_DIST 0.0001\n#define NORMAL_DELTA 0.0001\n\n// ----- Post process ----- //\n#define VIGNETTAGE_STRENGHT 0.8\n\n// ----- Useful constants ----- //\n#define PI  3.14159265358979323846264338327\n#define TAU 6.28318530717958647692528676655\n\n// ----- useful functions ----- //\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(maxComp(v.xy), v.z); }\nfloat dot2(vec2 v) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat map(float t, float c, float d) {  return c + t * (d - c);} // considering that t is in [0-1]\n\nvec2 matMin(vec2 a, vec2 b) { return (a.x < b.x) ? a : b; }\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// ----- easingFunct -----//\nfloat quadin(float t) { return t*t;}\nfloat quadOut(float t) { return -t*(t-2.0);}\nfloat cubicIn(float t) { return t*t*t;}\nfloat cubicOut(float t) { return -t*t*t+1.0;}\nfloat circleOut(float t) { return pow(1.0-(1.0-t)*(1.0-t), 0.5); }\nfloat circleIn(float t) { return 1.0- pow(1.0-t*t, 0.5); }\n\n// ----- distance functions modifiers ----- //\n// source: https://iquilezles.org/articles/smin\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*0.25;\n}\n\nfloat polysmin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// ----- distance functions for 3D primitives ----- //\n// source: https://iquilezles.org/articles/distfunctions\n\nfloat cylSDF(vec2 p, float radius) { return length(p) - radius; }\n\nfloat boxSDF(vec3 p, vec3 boxDim) {\n    vec3 q = abs(p) - boxDim;\n    return length(max(q, 0.0)) + min(maxComp(q), 0.0);\n}\n\n// ---- Hash functions ---- //\nfloat v31(vec3 a) { return a.x + a.y * 37.0 + a.z * 521.0; }\nfloat v21(vec2 a) { return a.x + a.y * 37.0; }\nfloat Hash21(vec2 uv) {return fract(sin(v21(uv))*104003.9);}\n\nvec2 glow = vec2(0, 0);\n\n\nvec2 sceneSDF(vec3 p) {\n    \n    float freq = 5.0;\n\tfloat theta;\n\tfloat snakeRadius = 0.8;\n\tfloat distoRadius = 0.15;\n\tfloat thickness = 0.02;\n\t\n    float angle = atan(p.z, p.x);\n\n    float amp = cubicIn(sin(angle + iTime/2.0) * 0.5 + 0.5);\n\t\n\tvec2 cylWarp = vec2(cylSDF(p.xz, snakeRadius), p.y + cos((angle+iTime)*3.0)*0.1);\n\t// cylWarp = vec2(cylSDF(p.xz, 1.0), cos(p.y)/15);\n\t\n    theta = angle*freq;\n    float wave1 = boxSDF(vec3(cylWarp + vec2(sin(theta), cos(theta)) * distoRadius * amp, 0.0), vec3(thickness));\n    \n    theta = angle*freq + TAU / 3.0;\n    float wave2 = boxSDF(vec3(cylWarp + vec2(sin(theta), cos(theta)) * distoRadius * amp, 0.0), vec3(thickness));\n\t\n\ttheta = angle*freq - TAU / 3.0;\n    float wave3 = boxSDF(vec3(cylWarp + vec2(sin(theta), cos(theta)) * distoRadius * amp, 0.0), vec3(thickness));\n\t\n\tfloat snake = polysmin(wave1, wave2, 0.1);\n\tsnake = polysmin(snake, wave3, 0.1);\n\t\n\tfloat centerGlow = boxSDF(vec3(cylWarp, 0), vec3(thickness*2.0, vec2(thickness*0.5)));\n    vec2 snakeMat = matMin(vec2(snake, 1.0), vec2(centerGlow, -1.0));\n    \n    float innerRadius = 0.5;\n    float center = cylSDF(vec2(cylSDF(p.xz, innerRadius), p.y), 0.01);\n    float nb = 5.0;\n   \tfor(float i = 0.0; i < nb; ++i) {\n   \t\tcenter = min(center, cylSDF(vec2(cylSDF(p.xz, circleOut((nb-i-0.8f)/nb)*innerRadius), p.y+i/nb*innerRadius), 0.01));\n   \t\tcenter = min(center, cylSDF(vec2(cylSDF(p.xz, circleOut((nb-i-0.8f)/nb)*innerRadius), p.y-i/nb*innerRadius), 0.01));\n   \t}\n    // center = max(center, abs(fract(cylWarp.z*freq-2.0*iTime)-0.5)-0.4);\n    \n    const float fallOffStrenght = 0.5; \n    glow.y += fallOffStrenght / (center * center + fallOffStrenght);\n\n    return matMin(snakeMat, vec2(center, -1.0));\n}\n\n\n// source: https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p) {\n    const float h = NORMAL_DELTA;\n\tconst vec2 k = vec2(1., -1.);\n    return normalize( k.xyy * sceneSDF( p + k.xyy*h ).x + \n                      k.yyx * sceneSDF( p + k.yyx*h ).x + \n                      k.yxy * sceneSDF( p + k.yxy*h ).x + \n                      k.xxx * sceneSDF( p + k.xxx*h ).x );\n}\n\n// return dist, mat, marchingCount\nvec3 rayMarching(vec3 O, vec3 D) { // ray origin and dir\n    vec2 sceneHit;\n    float d = 0.0;\n    float marchingCount = 0.0;\n \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 newPos = O + D * d;\n    \tsceneHit = sceneSDF(newPos);\n        float distToScene = sceneHit.x;\n        \n        d += distToScene * 0.7; // precision handling\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( d > MAX_DIST || abs(distToScene) < SURF_DIST*0.99) break;\n        ++marchingCount;\n        \n        // glow\n        const float fallOffStrenght = 2.0; \n        glow.x += fallOffStrenght / (distToScene * distToScene + fallOffStrenght); // with gaussian fallOff\n    }\n    return vec3(d, sceneHit.y, marchingCount);\n}\n\nvec3 render(vec3 O, vec3 D) { // ray origin and dir\n\t\n\tvec3 finalColor = vec3(2,43,58)/255.0; // background\n\t\n\tglow = vec2(0, 0); // reset glow\n    vec3 marching = rayMarching(O, D);\n    \n    // if we hit an object\n    \n    if( marching.x <= MAX_DIST) {\n\t\t// material handling\n        if (marching.y < 0.0) {\n        \tfinalColor = vec3(255,166,43)/255.0;\n        }else {\n        \tfinalColor = vec3(130,192,204)/255.0;\n        }\n    }\n    \n    // Glow if we're close to the part of the ring with the braid.\n    float cyc = (-sin(marching.y * TAU))*0.5+0.7;\n    \n    // glow\n    \n    finalColor +=  vec3(255,166,43)/255.0 * cyc * glow.x * 0.01;\n    // glow if we are close to the center of our cyl\n    finalColor += vec3(35,100,170)/255.0 * glow.y * 0.01 ;\n\t\n    // finalColor *= vec3(0.2); // mate\n            \n\t// return finalColor;\n\treturn vec3(saturate(finalColor));\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y * 2.0; // get centered & normalized [-1.0, 1.0]\n    uv /= 2.7; // zoom\n    \n    // setup camera\n    vec3 camPos;\n    vec3 camUp = vec3(0, 1, 0);\n#ifdef FREE_CAM\n    const float mx = iMouse.x/iResolution.x*PI*2.0;\n\tconst float my = -iMouse.y/iResolution.y*10.0;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*3.0;\n#else\n    camPos = vec3(0.0);\n    camPos.y = sin(iTime*0.4)*3.0;\n    camPos.z = cos(iTime*0.4)*3.0;\n    camUp.y = camPos.z;\n    camUp.z = -camPos.y;\n    camUp = normalize(camUp);\n#endif\n\tvec3 camDir = computeCamDir(uv, camPos, camUp, vec3(0));\n    vec3 finalColor = vec3(0.0);\n\t\n#if AA_SAMPLES > 1\n    for (float i = 0.0; i < AA_SAMPLES; i++) {\n    \tfor (float j = 0.0; j < AA_SAMPLES; j++) {\n\t        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) *2.0 - 1.0) / iResolution.y;\n\t        uv += deltaUV;\n#endif\n\t    \tfinalColor += render(camPos, camDir);\n#if AA_SAMPLES > 1\n    \t}\n    }\n    finalColor /= float(AA_SAMPLES * AA_SAMPLES); // Average samples\n#endif\n\n    // gamma corection\n    // finalColor = pow( finalColor, vec3( 1 / 2.2));\n    \n    // color grading\n    finalColor *= vec3(1.0 ,1.05, 0.95);\n    \n    // vignetting \n#ifdef VIGNETTAGE_STRENGHT\n    finalColor *= clamp(1.0 - length(uv * VIGNETTAGE_STRENGHT), 0.0, 1.0); //  saturate(1.0 - length(uv * VIGNETTAGE_STRENGHT));\n#endif\n    \n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}","name":"Image","description":"","type":"image"}]}