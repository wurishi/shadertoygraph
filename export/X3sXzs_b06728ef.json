{"ver":"0.1","info":{"id":"X3sXzs","date":"1709852176","viewed":60,"name":"spyrosis","username":"amusement","description":"slowly learning how to make someone puke. FLASHY FLASHY FLASHY","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["flashylights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Sample the spiral shader output from Buffer A (iChannel0)\n    vec3 spiralColor = texture(iChannel0, uv).rgb;\n    \n    // Sample the bloom effect output from Buffer C (iChannel2)\n    vec4 bloomColor = texture(iChannel2, uv);\n    \n    // Blend the spiral color with the bloom color\n    vec3 finalColor = spiralColor + bloomColor.rgb;\n    \n    // Output the final color\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float turns = 1.0;\nconst float thickness = 0.9;\nconst float growth = 1.0;\n\n// Animation parameters\nconst float rotationSpeed = 10.0; // Rotation speed in Hz (e.g., 10 Hz)\nconst float exchangeSpeed = 25.0; // Exchange speed in Hz (e.g., 10 Hz)\n\n// Depth parameters\nconst float depthFactor = 100000.0;\nconst float depthThreshold = 0.5;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 4.0) / iResolution.xy;\n    uv = (uv - 2.0) * 20.0;\n    \n    // Calculate the rotation angle based on time\n    float angle = iTime * rotationSpeed;\n    \n    // Apply rotation to the UV coordinates\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    uv = mat2(cosAngle, -sinAngle, sinAngle, cosAngle) * uv;\n    \n    // Calculate the spiral coordinates\n    float spiralAngle = atan(uv.y, uv.x);\n    float radius = length(uv);\n    \n    float spiral = fract(spiralAngle / (2.0 * 3.14159) * turns + log(radius) * growth);\n    \n    // Sample the input images\n    vec2 imageUV = uv * 0.5 + 0.5;\n    vec4 imageColor0 = texture(iChannel0, imageUV);\n    vec4 imageColor1 = texture(iChannel1, imageUV);\n    \n    // Calculate the spiral mask\n    float spiralMask = smoothstep(thickness, thickness + 0.05, spiral);\n    \n    // Calculate the exchange factor based on time\n    //float exchangeFactor = sign(sin(iTime * exchangeSpeed)) * 0.5 + 0.5;\n    float exchangeFactor = sin(iTime * exchangeSpeed) * 1.0 + 0.1;\n    \n    // Combine the colors based on the spiral mask and exchange factor\n    vec4 combinedColor = mix(\n        mix(imageColor1, imageColor0, spiralMask),\n        mix(imageColor0, imageColor1, spiralMask),\n        exchangeFactor\n    );\n    \n    // Calculate the depth based on the combined color\n    float depth = combinedColor.r; // Assuming the depth information is stored in the red channel\n    depth = smoothstep(depthThreshold, 1.0, depth);\n    \n    // Displace the spiral along the z-axis based on the depth\n    float spiralDepth = depth * depthFactor;\n    vec3 spiralPos = vec3(uv, spiralDepth);\n    \n    // Calculate the normal vector of the spiral surface\n    vec3 dx = dFdx(spiralPos);\n    vec3 dy = dFdy(spiralPos);\n    vec3 normal = normalize(cross(dx, dy));\n    \n    // Sample the light texture\n    vec2 lightUV = uv * 0.5 + 0.5;\n    vec3 lightColor = texture(iChannel1, lightUV).rgb;\n    \n    // Calculate the lighting based on the normal vector and light texture\n    float diffuse = max(dot(normal, normalize(lightColor)), 0.0);\n    \n    // Apply the lighting to the combined color\n    vec3 color = combinedColor.rgb * diffuse;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n   \n    float zoom = 0.4;\n    uv /= zoom;\n    \n    float verticalOffset = -0.1; // Adjust this value to control the vertical offset\n    uv.y += verticalOffset;\n    \n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    \n    float pentagram = 0.0;\n    float lineThickness = 0.015; // Adjust this value to control the thickness of the lines\n    \n    for (int i = 0; i < 5; i++) {\n        float angle = float(i) * (2.0 * 3.14159265 / 5.0);\n        vec2 p1 = 0.4 * vec2(cos(angle), sin(angle));\n        vec2 p2 = 0.4 * vec2(cos(angle + 4.0 * 3.14159265 / 5.0), sin(angle + 4.0 * 3.14159265 / 5.0));\n        \n        vec2 line = normalize(p2 - p1);\n        float d = abs(dot(uv - p1, line));\n        \n        pentagram = max(pentagram, 1.0 - step(lineThickness, d));\n    }\n    \n    // Create an inverted circular mask\n    float circle = 1.0 - step(1.222222, r);\n    \n    // Define the red velvety color\n    vec3 redVelvetColor = vec3(0.6, 0.0, 0.0);\n    \n    vec3 color = redVelvetColor * pentagram * circle;\n    \n    // Output the color and alpha value\n    fragColor = vec4(color, circle * pentagram);\n}","name":"Buffer B","description":"","type":"buffer"}]}