{"ver":"0.1","info":{"id":"7lBGWy","date":"1624643649","viewed":206,"name":"Voxel Gyroid III ","username":"kastorp","description":"another variation, this time with cubemap storing octree data (not compressed)","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["voxel","cubemap","octree"],"hasliked":0,"parentid":"7djGDw","parentname":"Voxel Gyroid (octree)"},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//VoxGyroid  III by Kastorp\n//----------------------------------------------------------------------------\n// cubemap are useful (especially with preview and precalculations)\n// on the other hand they have these issues (IMHO):\n// - performance\n// - half size float\n// - not bit friendly and no texelFetch\n//\n// Credits:using octree ray traversal from Abje: https://www.shadertoy.com/view/XdyfRy\n//---------------------------------------\n// uncomment  one of the following lines, to render isosurface inside voxels:\n//\n#define MC //use marching cubes inside voxels (slow)\n//#define raymarching  //raymarch using trilinear interpolation (with artifacts)\n//------------------------------------------------------------------------------------\n\nfloat minsize= L/N/2.; //voxel size\n#define  detail 3 \nvec3 gNormal;\nvec4 dbg;\nfloat data;\nint gFrame;\n\n#ifdef MC   \n//--------------------\n//porting of \"Marching Cubes\" algorithm by Paul Bourke (1994)\n//http://paulbourke.net/geometry/polygonise/ \n struct TRIANGLE {\n   vec3 p[3];\n} ;\n\n struct GRIDCELL{\n   vec3 p[8];\n   float val[8];\n} ;\n\n const vec3 VertexOffset[8] =vec3[8]\n(\n        vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n        vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\n\n//lookup tables retrieved from BufferA\n#define edgeTable(i) int(texelFetch(confChannel, ivec2(i,0),0).x)\n#define triTableRow(i) ivec4(texelFetch(confChannel, ivec2(i,1),0))\n#define triTableVal(tt,j) int((tt[j>>2]&(15*(1<<((j&3)*4))))>>((j&3)*4))\n\nconst int  vertexTable[24] =int[24](\n   0,1,   1,2,  2,3,   3,0, \n   4,5,   5,6,  6,7,   7,4,   \n   0,4,   1,5,  2,6,   3,7);\n   \n/*\n   Linearly interpolate the position where an isosurface cuts\n   an edge between two vertices, each with their own scalar value\n*/\nfloat  VertexWeight(float isolevel,float valp1, float valp2)\n{  \n   return  (isolevel - valp1) / (valp2 - valp1);\n}\n\n//input: isolevel value at 8 cube vertexs and isolevel threshold\n//output: number of triangles (-1= outside) and list of triangles (up to 5 in worst case)\nuvec4  Polygonise(inout GRIDCELL grid,float isolevel,inout TRIANGLE[5] triangles,sampler2D confChannel)\n{\n \n   /*\n      Determine the index into the edge table which\n      tells us which vertices are inside of the surface\n   */\n   int cubeindex = 0;\n   for(int i=gFrame;i<8;i++) if (grid.val[i] < isolevel) cubeindex |= 1<<i;\n\n   /* Cube is entirely in/out of the surface -1=IN, 0=OUT */\n   int e=edgeTable(cubeindex);\n   if ( e<= 0) return uvec4(e);\n\n   /* Find the vertices where the surface intersects the cube */\n   vec3 vertlist[12];\n   float vertW[12];\n\n\n   for(int i=0;i<12;i++)\n   if ((e & (1<<i))>0)  {\n       vertW[i]= VertexWeight(isolevel,grid.val[vertexTable[i*2]], grid.val[vertexTable[i*2+1]]);\n          \n       vertlist[i]= mix( grid.p[vertexTable[i*2]], grid.p[vertexTable[i*2+1]],vertW[i]);\n   }\n   /* Create the triangle */\n   uvec4 tridata=uvec4(0u); //x=number of triangles, yzw= tritable\n   \n   ivec4 ttr=triTableRow(cubeindex); \n   for (int i=gFrame;triTableVal(ttr,i)!=15 && i<15;i+=3) {\n       \n       for(int j=gFrame;j<3;j++)   {\n           uint k =uint(triTableVal(ttr,(i+j)));\n           int idx =(i+j);\n           if(idx<8) tridata.y +=  k*( 1u<<(idx*4));\n           else tridata.z += k*( 1u<<(idx*4-32));    \n           tridata.w+=  uint( floor(vertW[k]*4. )  )  *( 1u<<(idx*2));\n           triangles[tridata.x].p[j] = vertlist[k];\n       }    \n      tridata.x++;\n   }\n   return uvec4(tridata);\n}\nvec2    g_uv;\n#endif\n\n#ifdef raymarching \nfloat v[8];\nfloat mapVoxel(in vec3 p) {\n    p=fract(p/minsize);\n    return mix( mix(mix(v[0],v[1],p.x),mix(v[2],v[3],p.x),p.y),\n                mix(mix(v[4],v[5],p.x),mix(v[6],v[7],p.x),p.y),  \n            p.z) ;   \n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    vec3 e =vec3(0.001,0,0);\n    for(int i=min(iFrame,0);i<=2;i++){       \n        for(float j=-1.;j<=1.;j+=2.) n+= j*e* mapVoxel(p + j* e) ;\n        e=e.zxy; //TdHopper trick\n    }\n    return normalize(n);\n}\n#endif\n\nvec4 trace(in vec3 ro,in vec3 rd) \n{\n    \n    //bounding box\n    vec2 tb= boxIntersection(  ro,  rd, vec3(L*.25+.001) ) ;   \n    if(tb.y<0.) return vec4(0.);\n    vec3 rob =ro+ max(tb.x,0.)*rd ; //move to bounding box hit position\n    \n    float size =exp2(float(detail))*minsize; //current voxel size\n    vec3 lro = mod(rob,size); // voxel corner position\n    vec3 fro = rob-lro;  //relative position inside voxel\n    vec3 mask; //voxel traversal direction (unsigned)\n    bool exitoct = false;\n    int recursions = 0; //current LOD from 0 to detail\n    float dist = max(tb.x,0.); //ray distance from origin \n  \n    //the octree traverser loop\n    //each iteration i either:\n    // - check if i need to go up a level\n    // - check if i need to go down a level\n    // - check if i hit a cube\n    // - go one step forward if cube is empty\n    for (int i = 0; i < 200; i++)\n    {\n        if (dist >  max(tb.y,0.) ) return vec4(tb.x,tb.y,0.,-1.);\n        \n         dbg[detail-recursions]++;\n         data = getVoxel((fro +lro ) /minsize ,iChannel0,5)[detail -recursions];\n        int voxelstate = (data >=0.)?0:(detail >recursions?1:2); //0=empty,1=subdivide,2=solid\n        \n        //go up a level\n        if (exitoct)\n        {           \n            vec3 newfro = floor(fro/size*0.5+0.25)*size*2.0;\n            \n            lro += fro-newfro;\n            fro = newfro;          \n            recursions--;\n            size *= 2.0;\n            \n            exitoct = (recursions > 0) && (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n            continue; // don't advance ray, just change relative position\n        }\n        //subdivide\n        else if(voxelstate == 1 &&recursions<=detail)\n        {          \n            recursions++;\n            size *= 0.5;\n            \n            //find which of the 8 voxels i will enter\n            vec3 mask2 = step(vec3(size),lro);\n            fro += mask2*size;\n            lro -= mask2*size;\n            continue; // don't advance ray, just change relative position\n        }\n           \n        if (voxelstate ==2 ) \n        {\n            gNormal=-mask*sign(rd);\n            \n            //NOTES on INSIDE VOXEL RENDERING:\n            // hit position= lro+fro\n            // correct lro = floor((lro+fro)/minsize )*minsize\n            // voxel size = minsize\n            \n#ifdef raymarching            \n            vec3 p0=lro+fro;\n             //raycast and find distance to nearest voxel surface in ray direction\n            vec3 hit2 = -(sign(rd)*(lro-size*.5)-size*.5)/max(abs(rd),0.0001); \n            vec3 mask2 = step(hit2.xyz, hit2.yzx) * step(hit2.xyz, hit2.zxy);\n            float len = dot(hit2,mask2)+0.001; //move a bit forward, outside current block\n            float t = 0.0;  \n            for(float id=0.;id<8.;id++){\n                vec3 d = vec3(floor(mod(id,2.)) , floor(mod(id,4.)/2. ),floor(id/4.));  ;\n                vec3 pos= floor((lro+fro)/minsize )*minsize+ d*minsize;\n                v[int(id)]= getVoxel(pos/minsize,iChannel0,0).x;\n             }          \n            for (int iters=min(iFrame,0); iters < 60; iters++) {\n                vec3 p = p0 + rd * t;              \n                if(t>=len) break;\n                float d = mapVoxel(p);\n                if (abs(d) < 0.001) {\n                    gNormal=getNormal(p);\n                    return vec4(p,1.);\n                }\n                t += d*.6; //because this is not an exact sdf...\n                //st_assert(iters<30,0); //below 30 itets in 99,9% cases\n            }            \n#else\n\n#ifdef MC            \n            GRIDCELL g;\n            bool surface=false,solid=true;\n            for(int id=0;id<8;id++)\n            {\n                g.p[id]= floor((lro+fro)/minsize )*minsize+ VertexOffset[id]*minsize;\n                g.val[id]= getVoxel(g.p[id]/minsize,iChannel0,0).x;            \n                surface = surface || ( g.val[id]*g.val[0]<0.);\n            }    \n            if(surface ){\n                TRIANGLE[5] triangles;\n                //calculate vertexes & triangles (requires buffer B)\n                uvec4 tridata = Polygonise(g,0.,triangles,iChannel1);\n                int ntriangles=int(tridata.x);  \n                //if(ntriangles>1) return vec4(lro+fro,3.);\n                float t = 10000.0; \n                for(int i=0;i<ntriangles;i++) {\n                    vec3 tri =triIntersect( ro,rd,triangles[i].p[0],triangles[i].p[1],triangles[i].p[2]);\n                    if(tri.x>0.  && tri.x <t) {\n                        t=tri.x;\n                         gNormal=-normalize(cross(triangles[i].p[1]-triangles[i].p[0],triangles[i].p[2]-triangles[i].p[0]));\n                         g_uv= tri.yz;\n                     }\n                }\n                if(t< 10000.) return  vec4(ro+rd*t,3.);\n            }\n#else            \n            return vec4(lro+fro,3.);\n#endif\n\n#endif\n        }\n        //move forward (also if no hit inside voxel)\n\n        //raycast and find distance to nearest voxel surface in ray direction\n        vec3 hit = -(sign(rd)*(lro-size*.5)-size*.5)/max(abs(rd),0.0001); \n        mask = step(hit.xyz, hit.yzx) * step(hit.xyz, hit.zxy);\n        float len = dot(hit,mask)+0.001; //move a bit forward, outside current block\n          \n        //moving forward in ray direction \n        vec3 oldfro =fro;\n        lro += rd*len-mask*sign(rd)*size;   \n        fro += mask*sign(rd)*size ;\n        dist += len;\n        \n        //checking if i need to go up a level\n        exitoct = (floor(fro/size*0.5+0.25)!=floor(oldfro/size*0.5+0.25))&&(recursions>0);\n\n    }\n    return vec4(tb.x,tb.y,0.,-1.);\n    \n}\n\nvec3 rayDirection(vec3 cameraDir, vec2 uv){\n    \n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\n//--------------------SHANE---------------------\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){ \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   \n    const vec2 e = vec2(0.001, 0);    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.    \n}\n//--------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    gFrame=min(iFrame,0);\n    vec3 bgColor =vec3(0.4,0.4,0.7);\n    fragColor = vec4(bgColor,1.0);\n    dbg=vec4(0.);\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2  m =  iMouse.x<=0. ?  vec2(.2*iTime,sin(iTime) *-.33): (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y*3.14;\n    vec3 ro = vec3(sin(m.y+1.57) * cos(-m.x), sin(m.y+1.57) * sin(-m.x), cos(m.y +1.57))*12.;\n    vec3 cd = -normalize(ro); \n    vec3 rd = rayDirection(cd ,uv);    \n    vec4 res= trace(ro,rd);   \n    if(res.a>0.){\n        vec3 p =res.xyz, \n             n = gNormal;\n\n         n = doBumpMap( iChannel2, (p)*.45/minsize, n, 0.02);\n         //fragColor.rgb= tex3D(iChannel2, (p)*.25/minsize, n).rgb; \n         fragColor.rgb= mix(tex3D(iChannel3, (p)*5.5*minsize, n).grb,vec3(0.110,0.204,0.055),.4); //grass\n         fragColor.rgb = mix( fragColor.rgb , tex3D(iChannel2, (p)*.45/minsize, n).rgb,smoothstep(.7,.5,dot(n, normalize(p)))) ;  //dirt  \n         vec3 l=normalize(vec3(.6,-.4,1));            \n         float shading=1.;                          \n         vec4 s= trace(p+n*.01*minsize,l); \n         shading *= step(0., -s.a)*.6 + .4;\n\n         float ambience = 0.25;\n         float diff = max( dot(n, l), 0.0);\n         float spec =smoothstep(.95,1.,shading)* pow(max( dot( reflect(-l, n), -rd ), 0.0 ), 8.)*.2;\n         float fog = length(ro-p.xyz);\n\n         fragColor.rgb = fragColor.rgb*(diff + ambience) + vec3(.7, .9, 1.)*spec;            \n         fragColor.rgb *= shading; \n         fragColor.rgb =mix(bgColor, fragColor.rgb,exp(-fog *.01) );\n         fragColor = vec4(pow(clamp(fragColor.rgb, 0., 1.),vec3(.8)),1.);     \n    }    \n    //fragColor =mix(fragColor,vec4(0.2), (res.y-res.x)/L*1.4);\n    if(iMouse.z>0.) fragColor.rgb= mix( fragColor.rgb,vec3(dbg.x,dbg.y,dbg.z+dbg.w)/30. ,.5);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float L= 25., //cube dimension\n            N= 100.; //number of voxel x side (must be <=102)\n\n#define cubemapRes vec2(1024)\nconst vec2 packedChunkSize= vec2(10. ); \nconst float heightLimit = packedChunkSize.x * packedChunkSize.y; //must be > N\nvec3 offset = floor(vec3(-N/2.));\n\nvec3 texToVoxCoord(vec2 textelCoord) {\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += floor(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec3 p = floor(voxCoord);\n    return p.xy * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\n//Shane's?\nvec4 tx(samplerCube tx, vec2 p, int id){    \n    p=(floor(p) + 0.5) /  cubemapRes;\n    vec2 uv = fract(p) - .5;\n  \n    vec3 c;\n    if(id==0) c= vec3(-.5, uv.yx);\n    else if(id==1) c= vec3(.5, uv.y, -uv.x);\n    else if(id==2) c=vec3(uv.x, -.5, uv.y);\n    else if(id==3) c=vec3(uv.x, .5, -uv.y);\n    else if(id==4) c=vec3(-uv.x, uv.y, -.5);\n    else  c= vec3(uv, .5);\n    \n    return texture(tx, c);\n}\n\nvec4  getVoxel(vec3 p,samplerCube iChannel, int faceId) {  \n    p-= offset;\n    if(p.z>heightLimit || p.z<0.){return vec4(0.);}  \n    return tx(iChannel,  voxToTexCoord(p) ,faceId);\n}\n//-----------------------------\n\n//Iq's stuff\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    \n    //vec3 normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n// triangle degined by vertices v0, v1 and  v2\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 );\n    \n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    return vec3( t, u, v );\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// MARCHING CUBES LOOKUP TABLES: 256x2 pixels required\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    if(iFrame>3) discard;\n    else if(U.y<1.&& U.x<256.)\n    {\n       int _edgeTable[256]= int[256](\n        -1   , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, \n        0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, \n        0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, \n        0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, \n        0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, \n        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, \n        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, \n        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, \n        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, \n        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, \n        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, \n        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460, \n        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0, \n        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230, \n        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190, \n        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0\n       );\n        Q=vec4(_edgeTable[int(U.x)]);\n   }\n   else if(U.y<2.&& U.x<128.){\n     \n            ivec4  _triTableCompact[128] = ivec4[128](\n                ivec4(65535,65535,65535,65535), ivec4(62336,65535,65535,65535),ivec4( 63760,65535,65535,65535),ivec4( 37761,65304,65535,65535),\n                ivec4(64033,65535,65535,65535), ivec4(4992,65442,65535,65535 ),ivec4( 2601,65426,65535,65535 ),ivec4( 9090,39562,65528,65535 ),\n                ivec4(62131,65535,65535,65535), ivec4(33456,65291,65535,65535),ivec4( 8337,65459,65535,65535 ),ivec4( 4785,35257,65531,65535 ),\n                ivec4(45475,65338,65535,65535), ivec4(416 ,47272,65530,65535 ),ivec4( 12435,43931,65529,65535),ivec4( 43657,65464,65535,65535), \n                ivec4(63604,65535,65535,65535), ivec4(28724,65347,65535,65535),ivec4( 35088,65396,65535,65535),ivec4( 18708,14103,65521,65535),\n                ivec4(35361,65396,65535,65535), ivec4(14147,8512,65530,65535 ),ivec4( 39465,18464,65527,65535),ivec4( 10658,29305,18803,65535), \n                ivec4(14152,65323,65535,65535), ivec4(46923,578 ,65524,65535 ),ivec4( 33033,12916,65531,65535),ivec4( 39796,47540,4754,65535 ),\n                ivec4(12707,34731,65524,65535), ivec4(6833,436 ,19316,65535  ),ivec4( 39028,47536,12474,65535),ivec4( 19316,47515,65530,65535), \n                ivec4(62553,65535,65535,65535), ivec4(1113,65336,65535,65535 ),ivec4( 5200,65285,65535,65535 ),ivec4( 33880,4947,65525,65535 ),\n                ivec4(39457,65349,65535,65535), ivec4(6147,38050,65525,65535 ),ivec4( 23077,1060,65522,65535 ),ivec4( 13730,21330,33844,65535),\n                ivec4(9305,65459,65535, 65535), ivec4(688 ,38072,65525,65535 ),ivec4( 1104,12881,65531,65535 ),ivec4( 9490,33413,22603,65535 ),\n                ivec4(43834,22833,65524,65535), ivec4(1428,43032,43905,65535 ),ivec4( 20549,46512,12474,65535),ivec4( 22597,35496,65531,65535),\n                ivec4(22649,65431,65535,65535), ivec4(36921,30005,65523,65535),ivec4( 2160,20849,65527,65535 ),ivec4( 13137,65397,65535,65535),\n                ivec4(39033,6773,65522,65535 ), ivec4(37402,13573,14160,65535),ivec4( 33288,22610,9639,65535 ),ivec4( 9634,21301,65527,65535 ), \n                ivec4(30103,45976,65522,65535), ivec4(38745,10535,46880,65535),ivec4( 2866,29057,29976,65535 ),ivec4( 45355,6001,65525,65535 ),\n                ivec4(34905,6773,45987,65535 ), ivec4(20597,46992,40976,61611),ivec4( 45227,23088,28800,61557),ivec4( 30123,65371,65535,65535),\n                ivec4(62826,65535,65535,65535), ivec4(21376,65386,65535,65535),ivec4( 20745,65386,65535,65535),ivec4( 4993,42377,65526,65535 ), \n                ivec4(9569,65302,65535,65535 ), ivec4( 5473,866  ,65528,65535),ivec4( 38249,8288,65526,65535 ),ivec4( 22677,9512,33334,65535 ),\n                ivec4(43826,65366,65535,65535), ivec4(47115,27138,65525,65535),ivec4( 10512,42419,65526,65535),ivec4( 5797,47401,47250,65535 ), \n                ivec4(27446,5429,65523,65535 ), ivec4( 2944,20571,27473,65535),ivec4( 1715,24675,38149,65535 ),ivec4( 26966,39865,65528,65535),\n                ivec4(18085,65415,65535,65535), ivec4(16436,22071,65530,65535),ivec4( 20625,18538,65527,65535),ivec4( 5482, 29049,18803,65535),\n                ivec4(25110,29717,65528,65535), ivec4(21793,866 ,29748,65535 ),ivec4( 38728,24656,25093,65535),ivec4( 31031,9033,26969,63842 ),\n                ivec4(29363,27208,65525,65535), ivec4(18085,9255,46880,65535 ),ivec4( 18704,12935,27227,65535),ivec4( 37161,18731,19323,63141), \n                ivec4(14152,21339,27473,65535), ivec4(23317,363 ,19323,64320 ),ivec4( 2384,12374,14006,63304 ),ivec4( 26966,29881,39801,65535),\n                ivec4(26954,65444,65535,65535), ivec4(18084,32937,65523,65535),ivec4( 41226,17926,65520,65535),ivec4( 33080,26721,41316,65535),\n                ivec4(6465,25154,65524,65535 ), ivec4( 6147,17042,17961,65535),ivec4( 17440,65378,65535,65535),ivec4( 33336,9282,65526,65535 ),\n                ivec4(43338,11078,65523,65535), ivec4(8832,38072,27210,65535 ),ivec4( 691 ,24673,41316,65535 ),ivec4( 24902,33953,45345,61880),\n                ivec4(37993,6499,14003,65535 ), ivec4(33208,27393,16785,61766),ivec4( 14003,24582,65524,65535),ivec4( 47174,65414,65535,65535),\n                ivec4(30375,39080,65530,65535), ivec4(880,36986,42858,65535  ),ivec4( 5994,29050,2072,65535  ),ivec4( 42858,28951,65523,65535), \n                ivec4(5665,33158,30345,65535 ), ivec4(10594,30233,14601,63799),ivec4( 28807,1632,65522,65535 ),ivec4( 25143,65319,65535,65535),\n                ivec4(43826,35462,30345,65535), ivec4(9986,37047,42855,63401 ),ivec4( 4225,41351,42855,64306 ),ivec4( 45355,27249,5985,65535 ), \n                ivec4(34456,6518,14006,63025 ), ivec4(45456,65398,65535,65535),ivec4( 28807,45920,1712,65535 ),ivec4( 63159,65535,65535,65535));  \n   \n          Q= vec4(_triTableCompact[int(U.x)]);\n   \n   }      \n   else if(U.y<2.&& U.x<256.){         \n             ivec4  _triTableCompact[128] = ivec4[128](\n                ivec4(64359,65535,65535,65535), ivec4(47107,65383,65535,65535),ivec4( 47376,65383,65535,65535),ivec4( 35096,31507,65526,65535),\n                ivec4(25114,65403,65535,65535), ivec4(14881,46720,65527,65535),ivec4( 8338,46746,65527,65535 ),ivec4( 10166,35386,35235,65535),\n                ivec4(25383,65394,65535,65535), ivec4(30727,9734,65520,65535 ),ivec4( 9842,4211,65529,65535  ),ivec4(  4705,37224,26504,65535),\n                ivec4(42618,12657,65527,65535), ivec4(5754,33191,32791,65535 ),ivec4( 1840,41127,31337,65535 ),ivec4( 31335,43146,65529,65535),\n                ivec4(46214,65384,65535,65535), ivec4(15203,16480,65526,65535),ivec4( 35688,2404,65521,65535 ),ivec4( 38473,14646,25521,65535),\n                ivec4(25734,41611,65521,65535), ivec4(14881,24752,25611,65535),ivec4( 18612,8374,39465,65535 ),ivec4( 41882,18723,25523,62308),\n                ivec4(33576,25636,65522,65535), ivec4(16960,65318,65535,65535),ivec4( 8337,16963,33606,65535 ),ivec4( 5265,16932,65526,65535 ), \n                ivec4(33560,18454,6758, 65535), ivec4(40986,1632,65524,65535 ),ivec4( 17252,42627,37635,62362),ivec4( 25754,65354,65535,65535), \n                ivec4(30100,65462,65535,65535), ivec4(17280,31577,65526,65535),ivec4( 20741,26372,65531,65535),ivec4( 34427,21315,20788,65535),\n                ivec4(42073,26401,65531,65535), ivec4(6070,32930,22851,65535 ),ivec4( 23399,9380,8266,65535  ),ivec4( 14403,9029,9637,63099  ), \n                ivec4(29479,17702,65529,65535), ivec4(1113,24680,30818,65535 ),ivec4( 12899,20839,1104,65535 ),ivec4( 26662,4728,22600,63569 ), \n                ivec4(42073,29025,29462,65535), ivec4(6753,359 ,1927,62553   ),ivec4( 18948,12378,31338,64115),ivec4( 31335,17802,43082,65535),\n                ivec4(26006,35739,65529,65535), ivec4(2915,20534,22790,65535 ),ivec4( 2224,4277,46677,65535  ),ivec4( 25526,13651,65521,65535), \n                ivec4(39457,47541,26040,65535), ivec4(944 ,37046,38486,64033 ),ivec4( 46475,2149,9637,62752  ),ivec4( 25526,41555,13731,65535),\n                ivec4(22917,25986,10290,65535), ivec4(38489,24582,65522,65535),ivec4( 6225,25864,10296,63526 ),ivec4( 9809,65377,65535,65535 ),\n                ivec4(5681,33702, 38486,63128), ivec4(40986,22880,1616,65535 ),ivec4( 22576,65446,65535,65535),ivec4( 63066,65535,65535,65535), \n                ivec4(31323,65461,65535,65535), ivec4(47707,14423,65520,65535),ivec4( 22453,37306,65520,65535),ivec4( 42362,35195,4993,65535 ), \n                ivec4(45595,22295,65521,65535), ivec4(4992,29042,45685,65535 ),ivec4( 38265,2418,31522,65535 ),ivec4( 29271,38322,33330,62089),\n                ivec4(10834,29523,65525,65535), ivec4(32808,30757,21157,65535),ivec4( 20745,13626,10807,65535),ivec4( 37513,30738,21154,62039),\n                ivec4(13617,65367,65535,65535), ivec4(1920,28951,65525,65535 ),ivec4( 37641,13651,65527,65535),ivec4( 22409,65401,65535,65535), \n                ivec4(21637,47754,65528,65535), ivec4(21509,42251,955 ,65535 ),ivec4( 35088,43172,21675,65535),ivec4( 42170,15188,5268,62483 ), \n                ivec4(8530,45656,34120,65535 ), ivec4(2880,21563,6955,64277  ),ivec4( 1312,45717,34117, 62859),ivec4( 9545,65339,65535,65535 ), \n                ivec4(14930,17189,18485,65535), ivec4(21157,9282,65520,65535 ),ivec4( 12963,33701,34117,63760),ivec4( 21157,37186,9362,65535 ), \n                ivec4(34120,21301,65521,65535), ivec4(5440,65360,65535,65535 ),ivec4( 34120,2357,21253,65535 ),ivec4( 62793,65535,65535,65535), \n                ivec4(18356,43449,65531,65535), ivec4(17280,47481,47767,65535),ivec4( 7073,16715,46192,65535 ),ivec4( 13331,41348,46196,62650),\n                ivec4(38836,10571,8603,65535 ), ivec4(38009,6523,6955,62336  ),ivec4( 46203,16932,65520,65535),ivec4( 46203,14372,16948,65535), \n                ivec4(10898,12951,38007,65535), ivec4(38825,10823,1927,63234 ),ivec4( 14963,18218,2586,64004 ),ivec4( 33441,65351,65535,65535),\n                ivec4(16788,6001,65523,65535 ), ivec4(16788,32881,6017,65535 ),ivec4( 29444,65332,65535,65535),ivec4( 63364,65535,65535,65535),\n                ivec4(43177,65419,65535,65535), ivec4(14595,39865,65530,65535),ivec4( 2576,43146,65531,65535 ),ivec4( 47635,65443,65535,65535), \n                ivec4(6945,47515,65528,65535 ), ivec4(14595,8633,39721,65535 ),ivec4( 35616,65456,65535,65535),ivec4( 64291,65535,65535,65535),\n                ivec4(10290,35496,65529,65535), ivec4(681 ,65321,65535,65535 ),ivec4( 10290,4264,35352,65535 ),ivec4( 62113,65535,65535,65535),\n                ivec4(38961,65409,65535,65535), ivec4(61840,65535,65535,65535),ivec4( 63536,65535,65535,65535),ivec4( 65535,65535,65535,65535)\n            );\n\n             Q= vec4(_triTableCompact[int(U.x)-128]);\n\n         }\n         \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//GYROID function\n//https://www.shadertoy.com/view/4tVSzR\nfloat map(vec3 p)\n{\n    float d0=dot(sin(p),cos(p.yzx))  +.3 * dot(sin(p*3.),cos(p.yzx*3.));\n    float d2=length(p)-9.;\n    float d=smax(-d0,d2,3.);   \n    return clamp(d,-.5,+.5);\n}\n\n//VOXEL value x=this voxel, y=  minimum on current voxel vertexes \nvoid mainImage_A( out vec4 O, in vec2 fragCoord )\n{\n    if(iFrame>2) discard;\n    vec2 textelCoord = floor(fragCoord);    \n    vec3 voxelCoord = texToVoxCoord(textelCoord); \n    \n    O.x=map((voxelCoord)*18./N);\n    O.yz=vec2(5.,-5);\n\n    //LOD x=0, y=1, x=2,w=3 (with latency)\n    for(float i=0.;i<8.;i++){\n        vec3 d = vec3(floor(mod(i,2.)) , floor(mod(i,4.)/2. ),floor(i/4.));  \n        float val =map((voxelCoord +d)*18./N);\n        O.y=min(O.y,val);\n        //O.z=max(O.z,val);\n    }\n}\n\n//LOD... could use less pixels but who cares\nvoid mainImage_C( out vec4 O, in vec2 fragCoord )\n{\n\n    if(iFrame>10) discard;\n    vec2 textelCoord = floor(fragCoord);    \n    vec3 voxelCoord = texToVoxCoord(textelCoord); \n\n    vec4 data = getVoxel( voxelCoord,iChannel0,0);\n    O.x =data.y;\n    O.yzw=vec3(5.);\n\n    //LOD x=0, y=1, x=2,w=3 (with latency)\n    for(float i=0.;i<8.;i++){\n        vec3 d = vec3(floor(mod(i,2.)) , floor(mod(i,4.)/2. ),floor(i/4.));         \n        O.y=min(O.y,getVoxel( floor(voxelCoord/2.)*2. + d    ,iChannel0,5).x);      \n        O.z=min(O.z,getVoxel( floor(voxelCoord/4.)*4. + d*2. ,iChannel0,5).y); \n        O.w=min(O.w,getVoxel( floor(voxelCoord/8.)*8. + d*4. ,iChannel0,5).z);\n    } \n}\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n//wrapper function,  readMapTexCube(...) does the opposite\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\t    \n    int faceID = CubeFaceCoords(rayDir);\n    if(faceID!=0 && faceID!=5) discard;\n    \n    vec2 uv = fract(fragCoord/1024.*vec2(1, -1) );  \n    if(faceID==0) mainImage_A(fragColor,uv*cubemapRes); \n    else if(faceID==5)  mainImage_C(fragColor,uv*cubemapRes);\n     \n}","name":"Cube A","description":"","type":"cubemap"}]}