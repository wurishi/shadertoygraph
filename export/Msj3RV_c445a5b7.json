{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define CAST_DISTANCE 200.0\n\n#define SPHERE_RADIUS 1.0\n\n#define SPEED 2.5\n#define SPHERES_COUNT 3\n\n#define REFLECTIONS 5\n\nconst int motionSteps = 3;\n\n#define FPS 60.0\n\n//#define LUM\n#define SEPIA\n#define VIGNETTE\n//#define MOTION_BLUR  \nconst float exposure = 1.5 \n    ;\nconst float brightMax = 2.0;\nconst float camRadius = float(SPHERES_COUNT) * SPHERE_RADIUS * 1.0;\nconst float mult = 2.5 * SPHERE_RADIUS;\n\n// Samples the cube map\nvec3 sampleCube(vec3 v)\n{\n\tvec4 reflcol = texture (iChannel0, v);\n\t\n\tvec3 col = reflcol.rgb * vec3(reflcol.a);\n\t\n\tfloat Y = dot(vec3(0.30, 0.59, 0.11), col);\n\tfloat YD = exposure * (exposure/brightMax + 1.0) / (exposure + 1.0); \n\tcol *= YD;\n\n\treturn col;\n}\n\nvec3 sampleLight(vec3 v)\n{\n    return texture (iChannel1, v).rgb;\n}\n\n// Sphere ray casting function\nfloat rayCastSphere( vec3 center, float radius, vec3 p, vec3 v )\n{\n\tvec3 L = center - p;\n    float tca = dot(L, v);\n\t\n    if (tca < 0.0) \n\t{\n\t\treturn CAST_DISTANCE;\n\t}\n\t\n\tfloat radius2 = radius * radius;\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > radius2)\n\t{\n\t\treturn CAST_DISTANCE;\n\t}\n    float thc = sqrt(radius2 - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n\t\n\treturn min( t0, t1 );\n}\n\n// Return the normal at p\nvec3 getNormal( vec3 center, vec3 p )\n{\n\tvec3 diff = p - center;\n\treturn normalize( diff );\n}\n\n// Scene ray-casting\nvec3 castScene( vec3 p, vec3 v, out vec3 normal, float time )\n{\n\tfloat speedTime = time * SPEED;\n\tint halfSpheresCount = SPHERES_COUNT / 2;\n\tvec3 pos = vec3(CAST_DISTANCE);\n\t\n\tfloat h = CAST_DISTANCE;\n\tfloat newH;\n\tnormal = vec3(0, 0, 0);\n\t\n\tfor( int x = 0; x < SPHERES_COUNT; ++x )\n\t{\n\t\tfor( int y = 0; y < SPHERES_COUNT; ++y )\n\t\t{\t\n\t\t\tfloat cosT = cos(speedTime + float(y));\n\t\t\t\n\t\t\tvec3  baseCenter = vec3(cosT, cosT * mult, cosT );\n\t\t\t\n\t\t\tfor( int z = 0; z < SPHERES_COUNT; ++z )\n\t\t\t{\n\t\t\t\t\n\t\t\t\tvec3 center = baseCenter + vec3( mult * float(z - halfSpheresCount), \n\t\t\t\t\t\t\t\t\t\t\t\t mult * float(y - halfSpheresCount), \n\t\t\t\t\t\t\t\t\t\t\t\t mult * float(x - halfSpheresCount) );\n\t\t\t\t\n\t\t\t\tnewH = rayCastSphere( center, SPHERE_RADIUS, p, v );\n\t\t\t\t\n\t\t\t\tif( newH < h && newH > 0.0 )\n\t\t\t\t{\n\t\t\t\t\th = newH;\n\t\t\t\t\tpos = p + v * h;\n\t\t\t\t\tnormal = getNormal( center, pos );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn pos;\n}\n\n// Computes the final color of the sphere by applying the material\nvec3 ApplyMaterial(vec3 col, vec3 dir, vec3 normal)\n{\n    // material\n    float color_intensity = 0.8;\n\n    vec3 color_mod = (0.5 + 0.5 * col) * color_intensity;\n\n    // IBL\n    vec3 ibl_diffuse = sampleLight(dir);\n\n\n    vec3 foreground = vec3( ibl_diffuse * color_mod);\n    return mix(col, foreground, smoothstep(0.0, 1.0, dot(normal, dir)));\n}\n\n// Computes the final color for the given position\nvec3 shadeSphere( vec3 normal, vec3 vertPos, vec3 v, float time )\n{\t\t\n\tvec3 reflColor;\n\tvec3 newNormal = normal;\n\tvec3 dir = normalize(reflect(v, newNormal));\n\tvec3 pos = vertPos;\n\tint sphere = 0;\n    \n\tfor( int i = 0; i < REFLECTIONS; ++i )\n\t{\n\t\tif( pos.x < CAST_DISTANCE )\n\t\t{\n\t\t\tpos = castScene(pos, dir, newNormal, time);\n\t\t\tdir = normalize(reflect(dir, newNormal));\n            sphere = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    // color\n\tvec3 col = sampleCube(dir);\n    \n    if(sphere == 1)\n    {\n        col = ApplyMaterial(col, dir, newNormal);\n    }\n    \n    return col;\n}\n\n// Camera movement\nvec3 getCameraPos(float time)\n{\n\tvec3 camP;\n\tcamP.z = sin(time * 0.3) * camRadius;\n\tcamP.y = sin(time * 0.8) * camRadius;\n\tcamP.x = cos(time) * sqrt( pow(camRadius, 2.0) - pow(camP.z, 2.0 ) );\n\n\treturn camP;\n}\n\nvec3 Vignette(vec2 scrP, vec3 color)\n{  \n    // vignetting\n\tfloat dist = dot(scrP, scrP);\n\tdist *= dist;\n\tfloat mult = 1.0 / (dist * 0.25 + 1.0);\n\treturn color * mult;\n}\n\nvec3 Lum(vec3 color)\n{\n\treturn vec3(dot(color, vec3(0.21,0.72, 0.07)));\t   \n}\n\nvec3 Sepia(vec3 color)\n{\n    return vec3(\n        dot(color, vec3(0.393, 0.769, 0.189)),\n        dot(color, vec3(0.349, 0.686, 0.168)),\n        dot(color, vec3(0.272, 0.534, 0.131)));\n}\n\nvec3 SamplePixel(vec2 scPix, out vec2 scrP, float time)\n{\n    scrP = 2.0*scPix/iResolution.xy - vec2(1.0);\n\tscrP.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 camP = getCameraPos(time);\n\t\n\t// Look-at\n\tvec3 trgP      = vec3( 0, 0, 0);\n\tvec3 upV       = vec3( 0.0, 1.0, 0.0 );\n\tvec3 camV      = normalize( trgP - camP );\n\tvec3 camRightV = cross( upV, camV );\n\tvec3 camUpV    = cross( camV, camRightV );\n\t\n\tvec3 rayV = normalize( camV + camRightV*scrP.x + camUpV*scrP.y );\n\t\n\tvec3 normal;\n\tvec3 pos = castScene( camP, rayV, normal, time );\n\t\n\treturn shadeSphere( normal, pos, rayV, time ); \n}\n\nvec3 MotionBlur(vec3 color, vec2 fragCoord)\n{\n    vec2 foo;\n    for(int i = 1; i < motionSteps; ++i)  \n\t{  \n  \t\t// Sample the color buffer along the velocity vector.  \n\t\tfloat fi = float(i);\n   \t\tvec3 currentColor = SamplePixel(fragCoord.xy, foo, iTime - fi * (1.0 / FPS));  \n  \t\t// Add the current color to our color sum.  \n  \t\tcolor += currentColor;  \n\t} \n    \n\t// Average all of the samples to get the final blur color.  \n   \treturn color / float(motionSteps + 1);  \n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scrP;\n    vec3 color = SamplePixel( fragCoord.xy, scrP, iTime );\n    \n#ifdef MOTION_BLUR\n    color = MotionBlur( color, fragCoord );\n#endif\n    \n#ifdef LUM\n\tcolor = Lum(color);\n#endif\n    \n#ifdef SEPIA\n    color = Sepia(color);\n#endif\n    \n#ifdef VIGNETTE\n    color = Vignette(scrP, color);\n#endif\n\t\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msj3RV","date":"1391716864","viewed":744,"name":"Balls Reflection","username":"Belocio","description":"A simple reflection shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["reflection","cubemap","balls"],"hasliked":0,"parentid":"","parentname":""}}