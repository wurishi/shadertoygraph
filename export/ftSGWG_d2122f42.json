{"ver":"0.1","info":{"id":"ftSGWG","date":"1624554105","viewed":201,"name":"Outline shader jam 2021","username":"Exca","description":"Outlines late night shader jam (16.5.2021).\n\nPlay music on buffer A.\n\nMovement is not as smooth as on bonzomatic as there's no continous fft or smoothed one.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","cubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n  \n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n\tfragColor = texture(iChannel0, uv);// vec4(c,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float fftS = 0.0;\nfloat fft = 0.0;\nfloat fftI = 0.0;\nfloat beat = 0.0;\nfloat beatStep = 0.0;\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam );\n  vec3 right = normalize( cross( vec3(0,1,0), forward ));\n  vec3 up = normalize(cross( forward, right) );\n  \n  return normalize(vec3( uv.x * right + uv.y * up + fov*forward));\n}\n\nvec3 rotate3d( vec3 p, float x, float y, float z)\n{\n  mat3 rotx = mat3( 1.0, 0., 0, 0, cos(x), -sin(x),0, sin(x), cos(x));\n  mat3 roty = mat3( cos(y), 0, sin(y), 0,1,0, -sin(y), 0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0, sin(z), cos(z), 0,0,0,1);\n  return rotx*roty*rotz*p;\n}\n\nvec2 barrelDistortion(vec2 uv, float k)\n{\n  float rd = length(uv);    \n  float ru = rd * (1.0 + k * rd * rd);\n  uv /= rd;\n  uv *= ru;\n  return uv;\n}\n\nvec3 repeat( vec3 p, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return q;\n}\n\n\nfloat prism( vec3 p, vec2 h)\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y, max(q.x*0.866025+p.y*0.5, -p.y) -h.x*0.5);\n}\n\nfloat roundcube(vec3 p, vec3 b, float r)\n{\n  vec3 d = abs(p) -b;\n  return min(max(d.x, max(d.y,d.z)),0.0)+length(max(d,0.0))-r;\n}\n\nfloat map( vec3 p)\n{\n  vec3 id = floor(p*0.25+0.5);\n  p = repeat(p, vec3(4.,0,4.0));\n  p = rotate3d(p, id.x+fftI*5.0,id.y,id.z-+fftI*2.0);\n  float c = roundcube( p, vec3(0.25)+fftS*40.0,0.1);\n  return c;\n}\n\nvec3 normal(vec3 p)\n{\n  float c = map(p);\n  vec2 e = vec2(0.001, 0.0);\n  return normalize( vec3( \n    map(p+e.xyy),\n    map(p+e.yxy),\n    map(p+e.yyx)\n  )-c);\n}\n\nvec3 textureMap( vec3 surfacepos, vec3 normal, float material )\n{\n   // material = material < 0.5 ? 0. : 1.;\n        mat3 trimap = mat3( texture(iChannel0, surfacepos.yz+0.5).rgb,\n                            texture(iChannel0, surfacepos.xz+0.5).rgb,\n                            texture(iChannel0, surfacepos.xy+0.5).rgb);\n    \n        return trimap * abs(normal);\n    \n}\n\nvec4 march( )\n{\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n\tuv /= vec2(1,iResolution.x / iResolution.y);\n  uv = barrelDistortion(uv,1.5);\n  \n  vec4 col = vec4(0.0);\n  float time = iTime*0.2;\n  vec3 cam = vec3(sin(time+fftI*0.5)*10.0,10,cos(time-fftI*0.7)*10.0);\n  vec3 target = vec3(0);\n  float fov = 2.0;\n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  float t =0.0;\n  for(int i = 0; i < 50; i++)\n  {\n    vec3 p = cam + rd*t;\n    float r = map(p);\n    if(r < 0.01)\n    {\n      vec3 n = normal(p);\n      vec3 rd = reflect( rd, n);\n      \n      vec3 tmp = textureMap( p, n, 0.0)*0.25;\n      col = vec4(tmp,1.0);\n      \n    }\n    t+=r;\n  }\n  \n  return col;\n}\n\n\n\nfloat fftLine( vec2 uv )\n{\n  float fftSP = texture(iChannel1, vec2(abs(uv.x-0.5),0.0)).r*0.1;\n  \n  float d = length((uv.y-0.0) - fftSP*5.0);\n  return 0.04/d;\n}\n\nfloat fftCircle( vec2 uv) \n{\n  float cpl = length( uv )*1.45;\n  float a = abs(atan(uv.y, uv.x))*0.9+0.1;\n  \n  float adjust = smoothstep( 0.001,0.05, fftS);\n  \n  float md = 0.3+adjust;\n  float hd = 0.35+adjust*0.5;\n  float hmMid = 0.325+adjust;\n  \n  float fftSP = texture(iChannel1, vec2(abs(sin(a+fftI*7.+iTime)*0.03),0.5)).r*0.15;\n  cpl += fftSP;\n  float d = smoothstep(md,hmMid,cpl) * smoothstep(hd,hmMid,cpl);\n  return d;\n}\n\nvec2 rotate( vec2 p, float a)\n{\n  return vec2( cos(a)*p.x - sin(a)*p.y, sin(a)*p.y + cos(a)*p.y );\n}\n\nvec2 remap(vec2 uv, float beat)\n{\n  if(beat < 1.0) return uv;\n  else if(beat < 2.0){\n    return vec2( fract( (uv.x+0.5)*2.0)-0.5,uv.y);\n  }\n  else if(beat < 3.0){\n    uv = vec2( fract( (uv+vec2(iResolution.x / iResolution.y,1) ) *2.0)-0.5)*0.5;\n    uv = rotate( uv, iTime);\n    \n    return uv;\n  }\n  else if(beat < 4.0){\n    uv.x*=0.3+sin(fftI)*4.0;\n  }\n  else if(beat < 5.0){\n    uv.y*=0.5+sin(fftI)*4.0;\n  }\n  else if(beat < 6.0){\n    uv = (fract(uv*1.56)-0.5)*0.5;\n  }\n  else if(beat < 7.0){\n    uv*=0.6;\n  }\n  else if(beat < 8.0){\n    uv*=2.2;\n  }\n  \n  return uv;\n}\n\nfloat plasma(vec2 uv)\n{\n  float t = iTime*5.0;\n  float sum =\n    sin(t+uv.x ) \n    +sin(t*1.5+uv.x*3. )*0.5\n    +sin(t*2.75+uv.y*7.+uv.x*0.2 )*0.35\n  \n    +cos(-t+uv.y )\n    +sin(-t*1.5+uv.x*2. )*0.5\n    +sin(-t*2.75+uv.y*1.8+uv.x*0.2 )*0.35\n  ;\n  \n  return smoothstep( 0.0, 10.0, abs(sum));\n}\n\nfloat mcircle(vec2 uv, float size, float off, float edge)\n{\n  float md = off;\n  float hd = off+size;\n  float mmp = off+size*edge;\n  float hmp = off+size-size*edge;\n  float d = length(uv);\n  \n  return step( off, d) * step(d,size+off);\n  return smoothstep( md, mmp, d)* smoothstep(hmp,hd,d);\n}\n\nfloat mcross( vec2 uv, float size, float rot)\n{\n  uv = rotate(uv, rot);\n  float dx = length(uv.x);\n  float dy = length(uv.y);\n  \n  return step( size, dx) * step(size, dy);\n}\n\nfloat mask(vec2 uv )\n{\n  float off = mod(fftI*3.0,1.0);\n  return 1.-mcross( uv, smoothstep(0.005,0.02,fftS)*0.25, fftI)\n  +mcircle( uv, 0.0+smoothstep(0.0,0.02,fftS), off,0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n  \n  beat = floor( iTime*2.0);\n  beatStep = fract( iTime*2.0);\n  \n  fftS = texture(iChannel1, vec2(0.2,0.5)).r*0.01;\n  fftI = texture(iChannel1, vec2(0.2,0.5)).r*0.01+iTime*0.2;\n  fft = texture(iChannel1, vec2(0.2,0.5)).r*0.4;\n  \n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  \n  vec2 ouv = uv;//vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n\tuv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 aspect = vec2(1,iResolution.x/iResolution.y);\n  \n  uv -= 0.5;\n\tuv /= vec2(1,iResolution.x / iResolution.y);\n\n  uv+= sin(iTime+fftI)*smoothstep(0.005,0.05,fftS)*0.25;\n  ouv+= sin(iTime+fftI)*smoothstep(0.005,0.05,fftS)*0.25;\n  \n  uv = rotate(uv, fftI*0.4);\n  \n  uv = remap(uv,mod(beat/8., 8.0));\n  \n  vec3 bc = vec3(1.0, 0.95, 0.9);\n  \n  float cm = mod(beat/2.0, 6.0);\n  if( cm < 1.0) bc = bc.rgb;\n  else if( cm < 2.0) bc = bc.gbr;\n  else if( cm < 3.0) bc = bc.bgr;\n  else if( cm < 4.0) bc = bc.grb;\n  else if( cm < 5.0) bc = bc.brg;\n  else if( cm < 6.0) bc = bc.rbg;\n  \n  vec3 c = vec3(0.0) + plasma(uv)*0.16;\n  \n  \n  float circ = fftCircle( uv);\n  c += circ*bc;\n  \n  float pl = plasma(uv*20.0)*1.0;\n  c = mix( c, vec3(pl), min(1.0,circ*0.9));\n  c += fftLine(ouv)*0.2 * bc;\n  \n  vec4 m = march();\n  c = mix( c, m.rgb,m.a);\n  \n  c*=1.-mask(ouv/aspect-0.5/aspect);\n  \n  vec2 fuv = ouv;\n  fuv -= 0.5;\n  fuv*=0.98;\n  fuv += 0.5;\n  c += texture(iChannel0, fuv).rgb*0.85*smoothstep(0.1, 0.0, fftS)*bc;\n  \n\n\tfragColor = vec4(clamp(c,0.,1.),1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}