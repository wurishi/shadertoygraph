{"ver":"0.1","info":{"id":"M3jXDy","date":"1711038102","viewed":170,"name":"3D Sandstorm","username":"Obama","description":"This is a 3D desert generated with noise, with heat waves and a dust storm going on. The camera is usable!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["waves","heat","dust","hot","desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float distortAmount = 0.004;\nfloat distortZoom = 1.2;\nfloat distortSpeed = 0.1;\nfloat lerpIntensity = 0.6;\n\nvec3 mainColor = vec3(0.5, 0.45, 0.4) * 0.8;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float distortNoise = texture(iChannel1, vec2(fract(uv.x * distortZoom - iTime * distortSpeed), uv.y * distortZoom)).r;\n    \n    distortNoise = smoothstep(0.11, 0.45, distortNoise);\n\n    vec2 distortUV = (vec2(distortNoise * 1., distortNoise * 1.) * distortAmount);\n    \n    vec4 color = texture(iChannel0, uv + distortUV);\n    \n    float sandNoise = texture(iChannel2, vec2(fract(uv.x - iTime * 0.8), fract(uv.y + iTime * 0.055)) + distortUV).r;\n    float sandNoise2 = texture(iChannel2, vec2(fract(uv.x * 1.2 - iTime * 0.4), fract(uv.y * 1.2 + iTime * 0.06)) + distortUV).r;\n    float sandNoise3 = texture(iChannel2, vec2(fract(uv.x * 0.8 - iTime * 0.6), fract(uv.y * 0.8 + iTime * 0.035)) + distortUV).r;\n\n    float finalSandNoise = sandNoise * 0.233 + sandNoise2 * 0.433 + sandNoise3 * 0.333;\n    float sineLerpModifier = (1. + sin(3.1415 * iTime * 0.4)) * 0.1;\n    color = mix(color, vec4(mainColor, 1.), lerpIntensity * sineLerpModifier);\n    color += vec4(mainColor, 1.) * mix(0.2, 1.0, finalSandNoise * mix(0.5, 0.9, sineLerpModifier));\n\n    //Blending the sandstorm with the shader using the alpha channel\n    fragColor = mix(fragColor, color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float PRECISION = 10.;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159;\n\nconst vec3 FLOOR_COLOR = vec3(1.0, 0.6, 0.0);\nconst vec3 BACKGROUND_COLOR = vec3(0.835, 1, 1);\nconst vec3 FOG_COLOR = vec3(0.890,0.784,0.357);\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 permute(vec3 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nfloat hash(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat coefA(vec2 ij)\n{\n    float u = 50. * fract(ij.x / PI);\n    float v = 50. * fract(ij.y / PI);\n    return hash(vec2(u, v));\n    //return 2. * fract(u * v * (u + v)) - 1.;\n}\n\nfloat coefB(vec2 ij) { return coefA(ij + vec2(1., 0.)); }\n\nfloat coefC(vec2 ij) { return coefA(ij + vec2(0., 1.)); }\n\nfloat coefD(vec2 ij) { return coefA(ij + vec2(1., 1.)); }\n\nfloat S(float lambda) { return 3. * pow(lambda, 2.) - 2. * pow(lambda, 3.); }\n\nfloat snoise(vec3 pos)\n{\n    vec2 xz = pos.xz;\n    vec2 ij = vec2(floor(xz.x), floor(xz.y));\n    float i = ij.x;\n    float j = ij.y;\n    float x = xz.x;\n    float z = xz.y;\n    float a = coefA(ij);\n    float b = coefB(ij);\n    float c = coefC(ij);\n    float d = coefD(ij);\n    return a +\n           (b - a) * S(x - i) +\n           (c - a) * S(z - j) +\n           (a - b - c + d) * S(x - i) * S(z - j);\n}\n\n//OBJECTS (there is only one lmao)\nstruct Surface {\n    float sd; // This is the value of the surface\n    vec3 col; //This is its color\n};\n\n//ELEMENT CREATION METHODS--------------------------------//\n\nSurface sdNoisyFloor(vec3 p, vec3 col, float noiseScale, float noiseAmplitude) {\n\n    float noise = noiseAmplitude * snoise(p * noiseScale);\n\n    //This is the part responsible for the sand strips eheh\n    float modulo = mod(0.25*(p.x+0.25*p.z), 2.0);\n    float var = pow(modulo, 2.) - 0.5*pow(modulo, 3.);\n\n    float d = p.y + 1.0 + noise + 0.1*var;\n\n    return Surface(d, col);\n}\n\nSurface sdSandFloor(vec3 p, vec3 col) {\n    Surface floor1 = sdNoisyFloor(p, col, 0.005, 100.);\n\n    //This is the part where I added sand texture\n    float sand = snoise(vec3(p.x, p.y, p.z) * 5.0);\n    float d = floor1.sd + sand * 0.01;\n\n    return Surface(d, mix(floor1.col, vec3(0.9, 0.85, 0.6), sand));\n}\n\n//ELEMENT CALCULS METHODS--------------------------------//\n\nSurface opUnion(Surface obj1, Surface obj2) {\n    if(obj2.sd < obj1.sd)\n        return obj2;\n    return obj1;\n}\n\n//SCENE CREATION METHOD--------------------------------//\n\nSurface scene(vec3 p) {\n\n    Surface co = sdSandFloor(p, FLOOR_COLOR);\n\n    return co;\n}\n\n// SHADOWS METHODS--------------------------------//\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST;\n    Surface co;\n\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = scene(p);\n        depth += co.sd;\n        if(co.sd < PRECISION || depth > MAX_DIST)\n            break;\n    }\n\n    co.sd = depth;\n\n    return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(e.xyy * scene(p + e.xyy).sd +\n        e.yyx * scene(p + e.yyx).sd +\n        e.yxy * scene(p + e.yxy).sd +\n        e.xxx * scene(p + e.xxx).sd);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n    float res = 1.0;\n    float t = mint;\n\n    for(int i = 0; i < 16; i++) {\n        float h = scene(ro + rd * t).sd;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.01, 0.05);\n        if(h < 0.001 || t > tmax)\n            break;\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\n//CAMERA METHODS--------------------------------//\n\n//This method was created by the teacher in the example he created in lecture 2\nvec3 localRay;\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord)\n{\n    vec2 c = vec2(cos(rotation.x),cos(rotation.y));\n    vec4 s;\n    s.xy = vec2(sin(rotation.x),sin(rotation.y));\n    s.zw = -s.xy;\n\n    ray.xy = fragCoord.xy - iResolution.xy*.5;\n    ray.z = iResolution.y*zoom;\n    ray = normalize(ray);\n    localRay = ray;\n    \n    ray.yz = ray.yz*c.xx + ray.zy*s.zx;\n    ray.xz = ray.xz*c.yy + ray.zx*s.yw;\n    \n    pos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n//MAIN--------------------------------//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    //Uv definition\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 0, 0); //The ray origin (ro) is the camera position\n    vec3 rd = normalize(vec3(uv, -1)); //And this is the ray direction\n\n    //Camera\n    vec2 camRot = vec2(.5,.5)+vec2(-.35,4.5)*(iMouse.yx/iResolution.yx);\n    CamPolar( ro, rd, vec3(0), camRot, 500., 1.0, fragCoord );\n\n    Surface co = rayMarch(ro, rd);\n\n    //Distance if\n    if(co.sd > MAX_DIST) {\n    \n        col = BACKGROUND_COLOR;\n        \n        //This is a little gradient for the sky\n        vec3 skyColorTop = vec3(0.835, 1, 1);\n        vec3 skyColorBottom = vec3(0.529, 0.808, 0.922);\n        float t = 0.5 * (rd.y + 1.0);\n        col = mix(skyColorBottom, skyColorTop, t);\n        \n    } else {\n    \n        vec3 p = ro + rd * co.sd;\n        vec3 normal = calcNormal(p);\n\n        vec3 lightPosition = vec3(cos(iTime), 2, sin(iTime));\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        float dif = clamp(dot(normal, lightDirection), 0., 1.) + 0.5; // diffuse reflection\n\n        float softShadow = clamp(softShadow(p, lightDirection, 0.02, 2.5), 0.1, 1.0);\n\n        col = dif * co.col * softShadow;\n        \n    }\n\n    //This is the code responsible for the fog in the background\n    vec3 fogColor = FOG_COLOR;\n    fogColor = mix(fogColor, BACKGROUND_COLOR, pow(uv.y, 1.));\n    col = mix(col, fogColor, 1. - exp(-0.000000000005 * co.sd * co.sd * co.sd));\n    \n    //This is the gama correction\n    col = pow(col, vec3(2.0 / 2.2));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}