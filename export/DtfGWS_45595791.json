{"ver":"0.1","info":{"id":"DtfGWS","date":"1672275321","viewed":91,"name":"Mandelbrot Cycles","username":"petrakat","description":"Bounded parts of the mandelbrot (and julia) set are bounded because the iterated z either stays put or goes in a cycle. This is a visualization of the cycle length.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Set this to 0 to have z input = mouse, c = pixel (julia set mode)\n// 1 means z = pixel, c = mouse\n#define MANDELBROT_MODE 0\n// The longest cycle the code can track. The algorithm is O(n^2) \n// so increasing this gets real slow real fast\n#define MAX_CYCLE_CARE 32\n#define ITERATIONS 256\n\n\n// == Visual controls ==\n\n#define DRAW_AXES 0\n// Zoom in or out!\n#define GRID_SCALE 0.5\n#define X_OFFSET 0.33\n#define Y_OFFSET 0.5\n\n// Antialiasing level.\n// 0 = none; 1 = 4 samples, 2 = 9 samples.\n#define AA_LEVEL 0\n\n\n// Complex multiplication\nvec2 cmul(vec2 lhs, vec2 rhs) {\n    return vec2(lhs.x * rhs.x - lhs.y * rhs.y, lhs.x * rhs.y + lhs.y * rhs.x);\n}\n\n// Get the mouse pos in coordinate space\nvec2 mousePos() {\n    return (2.0 * iMouse.xy - iResolution.xy ) / iResolution.y\n        * vec2(1.0, -1.0) * GRID_SCALE\n        + vec2(X_OFFSET, Y_OFFSET);\n}\n\nvec3 mandelCycle(vec2 pixel) {\n    const float CLOSE_ENOUGH = 0.01;\n\n    vec2 trace[MAX_CYCLE_CARE];\n    \n    \n    #if MANDELBROT_MODE\n    vec2 z = mousePos();\n    vec2 c = pixel;\n    #else\n    vec2 z = pixel;\n    vec2 c = vec2(0.376 + sin(iTime) * 0.001, 0.240 + cos(iTime * 0.7604) * 0.001);\n    #endif\n    \n    for (int i = 0; i < ITERATIONS; i++) {\n        int leftover = i - (ITERATIONS - MAX_CYCLE_CARE);\n        if (0 <= leftover && leftover < MAX_CYCLE_CARE) {\n            trace[leftover] = z;\n        }\n        z = cmul(z, z) + c;\n        if (dot(z, z) > 2.0 * 2.0) {\n            return vec3(0.0);\n        }\n    }\n    \n    // Scan *backwards* and see how long it takes to get to something \"close enough\"\n    for (int i = 0; i < MAX_CYCLE_CARE; i++) {\n        vec2 cmpee = trace[MAX_CYCLE_CARE - 1 - i];\n        vec2 delta = cmpee - z;\n        if (dot(delta, delta) <= CLOSE_ENOUGH) {\n            // we have a cycle of this length!\n            float progress = float(i) / float(MAX_CYCLE_CARE);\n            float hue = mod(float(i) * 3.14159, 1.0);\n            return hsvToRgb(hue, 1.0, mix(progress, 0.6, 1.0));\n        }\n    }\n    \n    // The cycle is too mysterious\n    return vec3(1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0);\n \n    #if AA_LEVEL == 0\n    // no op\n    #elif AA_LEVEL == 1\n    for (float dx = -0.5; dx <= 0.5; dx++) {\n        for (float dy = -0.5; dy <= 0.5; dy++) {\n    #else\n    for (float dx = -0.5; dx <= 0.5; dx += 0.5) {\n        for (float dy = -0.5; dy <= 0.5; dy += 0.5) {\n    #endif\n            vec2 offset = \n                #if AA_LEVEL == 0\n                vec2(0.0)\n                #elif AA_LEVEL == 1  \n                vec2(dx, dy) / 4.0\n                #else\n                vec2(dx, dy) / 3.0\n                #endif\n                ;\n            vec2 c = (2.0 * (fragCoord + offset) - iResolution.xy) \n                / iResolution.y * vec2(1.0,-1.0) \n                * GRID_SCALE\n                + vec2(X_OFFSET, Y_OFFSET);;\n            col += mandelCycle(c);\n    #if AA_LEVEL > 0\n        }\n    }\n    #endif\n    \n    \n    col /= \n        #if AA_LEVEL == 0\n        1.0\n        #elif AA_LEVEL == 1\n        4.0\n        #else\n        9.0\n        #endif\n        ;\n    col = clamp(col, 0.0, 1.0);\n    \n    // Add grid lines\n    #if DRAW_AXES\n    vec2 c = (2.0 * fragCoord - iResolution.xy) \n                / iResolution.y * vec2(1.0,-1.0) \n                * GRID_SCALE;\n    vec2 realDelta = abs(fragCoord - iResolution.xy / 2.0);\n    vec2 deltaStepC = abs(c - round(c));\n    if (\n        (realDelta.x < 1.0 || realDelta.y < 1.0)\n     || (realDelta.x < 8.0 && deltaStepC.y < 0.01)\n     || (realDelta.y < 8.0 && deltaStepC.x < 0.01)) {\n         col += 0.5;\n    }\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Based on https://gist.github.com/eieio/4109795\n/*\n * GLSL HSV to RGB+A conversion. Useful for many effects and shader debugging.\n *\n * Copyright (c) 2012 Corey Tabaka\n *\n * Hue is in the range [0.0, 1.0] instead of degrees or radians.\n * Alpha is simply passed through for convenience.\n */\n\nvec3 hsvToRgb(float h, float s, float v) {\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec3 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec3(c, x, 0.0);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec3(x, c, 0.0);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec3(0.0, c, x);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec3(0.0, x, c);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec3(x, 0.0, c);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec3(c, 0.0, x);\n\t} else {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\n\tcolor += v - c;\n\n\treturn color;\n}","name":"Common","description":"","type":"common"}]}