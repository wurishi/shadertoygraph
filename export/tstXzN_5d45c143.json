{"ver":"0.1","info":{"id":"tstXzN","date":"1571622442","viewed":231,"name":"meta-metal","username":"ankd","description":"reflection metaball","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","metaball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float HALF_PI = 0.5*PI;\nconst float TWO_PI = 2.0*PI;\n\nfloat hash(in float v) { return fract(sin(v)*43237.5324); }\nvec3 hash3(in float v) { return vec3(hash(v), hash(v*99.), hash(v*9999.)); }\n\nfloat sphere(in vec3 p, in float r) { return length(p)-r; }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n#define BALL_NUM 10\nfloat map(in vec3 p) {\n  float res = 1e5;\n  for(int i=0;i<BALL_NUM;i++) {\n    float fi = float(i)+1.;\n    float r = 0.1+hash(fi);\n    vec3 offset = 2.*sin(hash3(fi)*iTime*2.);\n    res = opSmoothUnion(res, sphere(p-offset, r), 0.75);\n  }\n  return res;\n}\n\nvec3 normal(in vec3 p) {\n\tvec2 e = vec2(1., -1.)*1e-3;\n    return normalize(\n    \te.xyy * map(p+e.xyy)+\n    \te.yxy * map(p+e.yxy)+\n    \te.yyx * map(p+e.yyx)+\n    \te.xxx * map(p+e.xxx)\n    );\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r) {\n\tvec3 cz = normalize(tar - eye);\n    vec3 cx = normalize(cross(cz, vec3(sin(r), cos(r), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    return mat3(cx, cy, cz);\n}\n\nvec4 cubeMap(in vec2 tp) {\n    return texture(iChannel0, vec3(cos(tp.y)*cos(tp.x), sin(tp.y), cos(tp.y)*sin(tp.x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0.);\n\n    vec3 ro = 5.*vec3(cos(iTime*0.1), 0., sin(iTime*0.13));\n    vec3 rd = normalize(lookAt(ro, vec3(0.), 0.) * vec3(p,  2.));\n\n    \n    vec2 tmm = vec2(0., 10.);\n    float t = 0.;\n    for(int i=0;i<24;i++) {\n        float tmp = map(ro + rd*t);\n        if(tmp<0.001 || tmm.y<t) break;\n        t += tmp;\n    }\n  \n    if(tmm.y<t) {\n        vec2 tp = vec2(\n        \trd.x * PI,\n            rd.y * HALF_PI\n        );\n        color = cubeMap(tp).rgb;\n    } else {\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        vec2 tp = vec2(\n            ref.x * PI,\n            ref.y * HALF_PI\n        );\n        color = cubeMap(tp).rgb;\n    }\n  \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}