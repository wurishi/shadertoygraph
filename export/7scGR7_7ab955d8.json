{"ver":"0.1","info":{"id":"7scGR7","date":"1629390513","viewed":82,"name":"Pavilion","username":"ZenAn","description":"nothing","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SAMPLES 2\n#define EPSILON 1e-6\n#define opU(a, b) ( (a).x < (b).x ? (a) : (b) )\n#define match(a, b) ( abs(a-b) < EPSILON )\n\n\n#define SKY    0.0\n#define PLANE  1.0\n#define STAGE  2.0\n#define PILLAR 3.0\n#define BALL   4.0\n#define ROOF   5.0\n#define BEAM   6.0\n\nfloat sdBeam(in vec3 p) {\n    vec3 e = vec3(1, 0, -1);\n    float d = 1e10;\n    float h = 1.0;\n    float w = 2.5;\n    float r = .16;\n\n    d = min(d, sdBox(vec3(0.1, 0.24, 2.0), vec3(abs(p.x), p.y, abs(p.z)) - e.xyx*w*0.64 + e.yyx*w*0.64 + e.yxy*0.36));\n    d = min(d, sdBox(vec3(2.0, 0.24, 0.1), vec3(abs(p.x), p.y, abs(p.z)) - e.zyx*w*0.64 + e.zyy*w*0.64 + e.yxy*0.36));\n\n    return d;\n}\n\nfloat sdPillar(vec3 p) {\n    vec3 e = vec3(1, 0, -1);\n\n    float h = 1.0;\n    float w = 2.5;\n    float r = .16;\n\n    return sdCappedCylinder(e.xyx*w*0.64, e.xyx*w*0.64 - e.yxy*(h)*4.0, r*0.8, vec3(abs(p.x), p.y, abs(p.z)));\n}\n\nfloat sdRoof(in vec3 p) {\n    vec3 e = vec3(1, 0, -1);\n    float d = 1e10;\n    float h = 1.0;\n    float w = 2.5;\n    float r = .16;\n\n    d = min(d, sdCappedCylinder(e.xyx*w, e.yxy*h - e.xyx * 0.19, r, vec3(abs(p.x), p.y, abs(p.z))));\n\n    d = min(d, udTriangle(e.xyx*w, e.xyz*w, e.yxy*h, vec3(abs(p.x), p.y, abs(p.z))));\n    d = min(d, udTriangle(e.zyx*w, e.xyx*w, e.yxy*h, vec3(abs(p.x), p.y, abs(p.z))));\n    \n    return d;\n}\n\nfloat sdPier(in vec3 p) {\n    vec3 e = vec3(1, 0, -1);\n    float d = 1e10;\n    float h = 1.0;\n    float w = 2.5;\n    float r = .16;\n    \n    vec3 pt = vec3(abs(p.x), p.y, abs(p.z));\n    pt = pt - e.xyx*w*0.64;\n    \n    d = min(d, sdRoundedCylinder(.16, .2, .1, pt - vec3(0, 0.64, 0)));\n    d = min(d, sdBox(vec3(0.4, 0.1, 0.4), pt - vec3(0, 0.4, 0)));\n    return d;\n}\n\nfloat s(float x) {\n    if (x < 0.0) return x;\n    if (x > 1.0) return x;\n    return 1.0 - (1.0-x)*(1.0-x);\n}\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e10, SKY);\n\n    res = opU(res, vec2(\n        sdPlane(p),\n        PLANE\n    ));\n    \n    res = opU(res, vec2(\n        sdSphere2(0.28, vec3(p.x, (p.y-5.6)*0.8, p.z)),\n        BALL\n    ));\n    \n    res = opU(res, vec2(\n        sdRoof(vec3(p.x, s(p.y - 4.3), p.z)),\n        ROOF\n    ));\n    \n    res = opU(res, vec2(\n        sdPillar(vec3(p.x, p.y - 4.3, p.z)),\n        PILLAR\n    ));\n\n    res = opU(res, vec2(\n        sdBeam(vec3(p.x, p.y - 4.3, p.z)),\n        BEAM\n    ));\n    \n    res = opU(res, vec2(\n        sdPier(p),\n        STAGE\n    ));\n    \n    res = opU(res, vec2(\n        sdBox(vec3(3.6, 0.2, 3.6), p),\n        STAGE\n    ));\n    \n    res = opU(res, vec2(\n        sdBox(vec3(2.4, 0.2, 2.4), p - vec3(0,0.2,0)),\n        STAGE\n    ));\n    \n    res = opU(res, vec2(\n        sdBox(vec3(1.6, 0.2, 12.0), p - vec3(0,0,12)),\n        STAGE\n    ));\n\n    return res;\n}\n\nvec3 normalMap(in vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 rayCast(in vec3 ro, in vec3 rd) {\n    float tmin = 0.1, tmax = 20.0;\n    float t = tmin;\n    vec2 res = vec2(tmax, SKY);\n    \n    float testPlane = (0.0 - ro.y) / rd.y;\n    if (testPlane > 0.0) {\n        tmax = min(tmax, testPlane);\n        res = vec2(testPlane, PLANE);\n    }\n    \n    for (int i = 0; i < 256; ++i) {\n        vec2 r = map(ro + t * rd);\n        float dist = r.x;\n        \n        if (t > tmax) {\n            vec2 res = vec2(tmax, SKY);\n            break;\n        }\n        if (abs(dist) < EPSILON) {\n            res = vec2(min(tmax, t), r.y);\n            break;\n        }\n        t += dist;\n    }\n    return res;\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    // bounding volume\n    float tp = (0.0-ro.y)/rd.y;\n    if(tp > 0.0)\n        tmax = min(tmax, tp);\n\n    float res = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 64; i++) {\n\t\tfloat h = map(ro + rd*t).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min(res, s*s*(3.0-2.0*s));\n        t += clamp(h, 0.02, 0.2);\n        if(res < 0.004 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec2 calcReflection(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    // bounding volume\n    float tp = (0.0-ro.y)/rd.y;\n    if(tp > 0.0)\n        tmax = min(tmax, tp);\n        \n    vec2 refRes = vec2(0,0);\n\n    float res = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 64; i++) {\n        vec2 mapRes = map(ro + rd*t);\n\t\tfloat h = mapRes.x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min(res, s*s*(3.0-2.0*s));\n        t += clamp(h, 0.02, 0.2);\n        \n        // refRes = vec2(t, mapRes.y);\n        \n        if(h < 0.004) {\n            refRes = vec2(t, mapRes.y);\n            break;\n        }\n    }\n    return refRes;\n}\n\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0) * (0.5+0.5*nor.y);\n}\n\nvec3 getMaterialColor(float material, vec3 p, float dist) {\n    vec3 color = vec3(0.3, 0.54, 1.0);\n\n    if (match(material, ROOF)) {\n        color = mix(\n            vec3(0.05, 0.3, 0.12),\n            texture(iChannel2, p.xz).rgb,\n            0.2\n        );\n    } else if (match(material, BALL)) {\n        color = mix(\n            vec3(0.8, 0.5, 0.1),\n            texture(iChannel3, p.xy+p.z).rgb,\n            0.2\n        );\n    } else if (match(material, BEAM)) {\n        color = mix(\n            texture(iChannel0, p.xy + p.z).rgb,\n            vec3(1.0, 0.0, 0.0),\n            0.5\n        );\n    } else if (match(material, PILLAR)) {\n        color = texture(iChannel0, p.xz + p.y).rgb;\n    } else if (match(material, STAGE)) {\n        color = mix(vec3(0.7), texture(iChannel2, p.xz*0.2).rgb, 0.6);\n    } else if (match(material, PLANE)) {\n        float h = 4.0 / (dist+0.01);\n        h = clamp(h, 0.0, 1.0);\n        color = vec3(0.3, 0.54, 1.0) * texture(iChannel1, vec2(p.x + sin(dist*.4), p.z)).r;\n        color = mix(color, vec3(0.3, 0.54, 1.0), h)*h;\n    }\n    \n    return color;\n}\n\nvec3 render(vec3 eye, vec3 dir) {\n    vec2 res = rayCast(eye, dir);\n    vec3 p = eye + res.x*dir;\n    vec3 n = normalMap(p);\n    \n    // vec3 color = vec3(0.4, 0.6, 1.0);\n    vec3 color = getMaterialColor(res.y, p, res.x);\n    \n    // fog\n    float fog = 4.0 / (res.x + 0.01) + 0.6;\n    color *= clamp(fog, 0.0, 1.0);\n    \n    // ambient occlusion\n    float occ = calcAO(p, n);\n    if (match(res.y, SKY))\n        occ = 1.0;\n    color *= (1.0 - (1.0 - occ)*0.8);\n\n    #if 0\n    // reflect shadow\n    {\n        vec3 ref = reflect(dir, n);\n        float shadow = calcSoftshadow(p, ref, 0.2, 8.);\n        color *= (1.0 - (1.0 - shadow)*0.16);\n    }\n    #endif\n    \n    // reflect\n    if (match(res.y, PLANE)) {\n        vec3 ref = reflect(dir, n);\n        vec2 refRes = calcReflection(p, ref, 0.2, 8.);\n        vec3 np = vec3(p + ref * refRes.x);\n        vec3 c = getMaterialColor(refRes.y, np, refRes.x);\n        color = mix(color, c, 0.3);\n    }\n    \n    // sun shadow\n    {\n        vec3 sunDir = normalize(vec3(0.5, 0.4, 0.6));;\n        float shadow = calcSoftshadow(p, sunDir, 0.05, 8.);\n        color *= (1.0 - (1.0 - shadow)*0.5);\n        // color = vec3(shadow);\n    }\n    \n    // color = mix(color, vec3(occ), (sin(iTime * 0.5)+1.0)*0.5);\n    \n    return color;\n}\n\nmat3 setCamera(in vec3 eye, in vec3 lookAt, float rotation) {\n    vec3 cw = normalize(lookAt-eye);\n\tvec3 cp = vec3(sin(rotation), cos(rotation),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // camera\n    vec3 eye = vec3(sin(0.7), .28, cos(0.7)) * 12.0;\n    // vec3 eye = vec3(6.0, 2.0, 6.0);\n    vec3 lookAt = vec3(0.0, 1.0, 0.0);\n    mat3 camera = setCamera(eye, lookAt, 0.0);\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < SAMPLES; ++i)\n    for (int j = 0; j < SAMPLES; ++j) {\n\n        vec2 offset = vec2(float(i), float(j)) / float(SAMPLES) - 0.5;\n        // pixel\n        vec2 p = (2.0 * (fragCoord + offset) - iResolution.xy) / iResolution.y;\n\n        // ray direction\n        vec3 dir = camera * normalize(vec3(p.xy, 2.0));\n\n        // render\n        vec3 c = render(eye, dir);\n        c = pow(c, vec3(0.4545));\n\n        color += c;\n    }\n\n    color /= float(SAMPLES * SAMPLES);\n\n    // Output to screen\n    fragColor = vec4(color, .0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626\n#define SQRT_2 1.414\n\nfloat sdSphere(in vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat sdSphere2(float r, in vec3 p) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 b, vec3 p) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox(vec3 b, float r, vec3 p) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoxFrame(vec3 b, float e, vec3 p) {\n  p = abs(p) - b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdTorus(vec2 t, vec3 p) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedCylinder(vec3 a, vec3 b, float r, vec3 p) {\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle(vec3 a, vec3 b, vec3 c, vec3 p) {\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) ) - 0.1;\n}\n\nfloat sdRoundedCylinder(float ra, float rb, float h, vec3 p) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat smin( float a, float b, float k ) {\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}","name":"Common","description":"","type":"common"}]}