{"ver":"0.1","info":{"id":"3dXBDB","date":"1588943023","viewed":108,"name":"Jumping ","username":"MeHigh_","description":"*boing boing*","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smin(float a, float b, float k) {\n\tfloat h = max(k - abs(a - b), 0.0);\n    \n    return min(a, b) - h * h /(k * 4.); \n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n    \n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 rad) {\n\tfloat k1 = length(p/rad);\n    float k2 = length(p/(rad * rad));\n    \n    return k1 * (k1 - 1.) / k2;\n}\n\nfloat sdMain(vec3 p) {\n\tfloat t = fract(iTime * .75);\n    float y  = 4. * t * (1. - t);\n        \n    vec3 v = vec3(0., y, 0.);\n    \n    float sy = 0.5 + 0.5 * y;\n\tfloat sz = 1./ sy;\n    \n    //box shape\n    vec3 rad = vec3(.1, .2 * sy, .1 * sz);\n    vec3 pos = p - v;\n    float d = sdBox(pos, rad);\n    \n    //sphere shape\n\tvec3 pos1 = pos - vec3(0., -.2, 0.);\n\tvec3 rad1 = vec3(0.2, 0.2 * sy, 0.2 * sz);\n    float d1 = sdEllipsoid(pos1, rad1);\n    \n    d = smin(d, d1, .05);\n    return d;\n}\n\nfloat map (vec3 p) {\n\tfloat d = sdMain(p);\n    \n\tfloat d1 = (p.y) - (-0.25);    \n    \n    return min(d, d1);\n}\n\nvec3 getNormal(in vec3 p) {\n\tvec2 e = vec2(0.001, 0.);   \n    return normalize( vec3( map(p + e.xyy) - map(p - e.xyy),\n                           \tmap(p + e.yxy) - map(p - e.yxy),\n                           \tmap(p + e.yyx) - map(p - e.yyx) ) );\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n    for(int i = 0; i < 100; ++i) {\n        vec3 p = ro + t * rd;\n        float h = map(p);\n        if(h < .001)\n            break;\n        t += h;\n        if(t > 20.)\n            break;\n    }\n    if(t > 20.) \n        t = -1.0;\n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n\tfloat res = 1.;\n    float t = tmin;\n    float ph = 1e20;\n    \n    for(int i = 0; i < 25; ++i) {\n\t\tfloat h = map(ro + t * rd);\n        \n        float y = h * h / (2. * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, 10. * d / max(0., t - y));\n        \n        ph = h;\n        t += h;\n    \tif(res < .0001 || t > tmax) \n            break;\n    }\n    return clamp(res, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n\n    vec2 uv = (2. * (fragCoord) - iResolution.xy)/iResolution.y;\n\n    float a = 10.0 * iMouse.x / iResolution.x;\n\n    float howFar = 1.25;\n    vec3 ro = vec3(howFar * sin(a), 0.45, howFar * cos(a));\n\n    vec3 lookAt = vec3(0., 0.45, 0.);\n    vec3 f = normalize(lookAt - ro);\n    vec3 u = normalize(cross(f, vec3(0., 1., 0.)));\n    vec3 r = normalize(cross(u, f));\n    float zoom = 1.5;\n\n    vec3 rd = normalize(uv.x * u + uv.y * r + zoom * f);\n\n    col = vec3(0.4, 0.75, 1.) - rd.y * .7;\n    col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10. * rd.y));\n\n\n    float t = rayMarch(ro, rd);\n\n    if( t > 0.) {\n        vec3 p = ro + t * rd;\n        vec3 norm = getNormal(p);\n\n        vec3 mat = vec3(0.18);\n        vec3 sunDir = normalize(vec3(0.8, 0.5, 0.2));        \n\n        float sunDif \t= clamp(dot(norm, sunDir), 0., 1.) \n            * softShadow(p, sunDir, .001, 4.);\n        float sunShadow = step(rayMarch(p + norm*0.001, sunDir), 0.0); \n        float skyDif \t= clamp(0.5 + 0.5 * dot(norm, vec3(0., 1., 0.)), 0., 1.);   \n        float bounceDif = clamp(0.5 + 0.5 * dot(norm, vec3(0., -1., 0.)), 0., 1.);   \n\n        col  = mat * vec3(7.0, 5.0, 4.0) * sunDif * sunShadow;\n        col += mat * vec3(0.5, 0.8, 0.9) * skyDif;\n        col += mat * vec3(0.7, 0.3, 0.2) * bounceDif;\n\n    }\n    col = pow(col, vec3(0.4545));\n    //col /= float(AA * AA);\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}