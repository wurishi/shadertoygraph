{"ver":"0.1","info":{"id":"mlB3Wm","date":"1673559107","viewed":246,"name":"2D guy from bla bla bla","username":"tale3d","description":"Procedurally generated and animated character from classic music video \"Bla Bla Bla\" by Gigi D'Agostino","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","line"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * signBezier(A, B, C, p);\n}\n\nvec2 Bezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t)\n{\n    //precompute powers of t and 1-t\n    float t2 = t*t;\n    float t3 = t2*t;\n    float o1 = 1.0-t;\n    float o2 = o1*o1;\n    float o3 = o2*o1;\n    //calculate four terms that make cubic Bezier curve, see lecture for the equation\n    vec2 term1 = p0*o3;\n    vec2 term2 = p1*3.0*o2*t;\n    vec2 term3 = p2*3.0*o1*t2;\n    vec2 term4 = p3*t3;\n    return term1+term2+term3+term4;\n}\n\nfloat ellipse1(vec2 p, vec2 ab)\n{\n    float f = length( p*ab );\n    return f-1.0;\n}\n\nfloat ellipse2(vec2 p, vec2 ab)\n{\n    float f = length( p*ab );\n    float g = length( p*dot(ab,ab) );\n    return (f-1.0)*f/g;\n}\n\nfloat ellipse3(vec2 p, vec2 ab)\n{\n    float e = 2.0/iResolution.y;\n\n    float f = ellipse1(p, ab);\n    float g = length( vec2(dFdx(f),dFdy(f))/e );\n\treturn f/g;\n}\n\nfloat ellipse4(vec2 p, vec2 ab)\n{\n    float e = 2.0/iResolution.y;\n\n    float f = ellipse1(p, ab);\n    float g = length( vec2(ellipse1(p+vec2(e,0.0),ab)-ellipse1(p-vec2(e,0.0),ab),\n                           ellipse1(p+vec2(0.0,e),ab)-ellipse1(p-vec2(0.0,e),ab)) )/(2.0*e);\n    return f/g;\n}\n\n\nfloat Ellipse(vec2 centre, vec2 ab, float angle, vec2 p)\n{\n    float cxi = (p.x-centre.x)*cos(angle)-(p.y-centre.y)*sin(angle);\n    float cyi = (p.x-centre.x)*sin(angle)+(p.y-centre.y)*cos(angle);  \n   \n    //now the implicit equation: we use one of the equations from the lecture\n//    return sqrt(cxi*cxi/(ab.x*ab.x) + cyi*cyi/(ab.y*ab.y))-1.0;\n    return ellipse3(vec2(cxi, cyi), ab);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n    \n    float t = iTime;\n\n    //Background colour (default)\n    vec3 colour = vec3(0.0,0.0,0.0);\n\n    //Direction for the line\n    vec2 dp = vec2(0.0,1.0);\n    \n    //now the implicit equation: we use one of the equations from the lecture\n    float ground = c.y + 0.5;\n    float neck = c.y - 0.2 - 0.05*cos(10.0*iTime);\n    \n    float phs = clamp(sin(10.0*iTime),0.,1.);\n    float phc = clamp(sin(10.0*iTime+10.0),0.,1.);\n    \n    vec2 f1pos = vec2(-0.55+0.2*sin(10.0*iTime),-0.45+0.15*phs);\n    vec2 f2pos = vec2(0.05-0.2*sin(10.0*iTime),-0.45+0.2*phc);\n    float f1rot = -0.2+abs(cos(5.0*iTime));\n    float f2rot = -abs(sin(5.0*iTime));\n    \n    float f1size = 0.8 + 0.2*clamp(-sin(10.0*iTime),0.,1.);\n    float f2size = 0.8 + 0.2*clamp(sin(10.0*iTime),0.,1.);\n   \n    vec2 headpos = vec2(-0.4+0.1*sin(10.0*iTime), 0.2+0.05*cos(10.0*iTime));\n   \n    float foot1 = Ellipse(f1pos, vec2(5.5,9.0)/f1size, f1rot, c);\n    float foot2 = Ellipse(f2pos, vec2(5.5,9.0)/f2size, f2rot, c);\n    \n    float forehead = Ellipse(headpos + vec2(0.2,0.2), vec2(2.7,6.0), 0.1*cos(10.0*iTime), c);\n    \n    float eye = Ellipse(headpos + vec2(0.4,0.2), vec2(200.,70.0), 0.1, c);\n    float hair = sdBezier(headpos + vec2(0.4, 0.34+0.02*sin(10.0*iTime+5.0)), headpos + vec2(0.47, 0.35), headpos + vec2(0.45+0.05*sin(10.0*iTime), 0.45), c);\n    \n    float head = max(forehead, -eye);\n    \n    float curve1 = sdBezier(f1pos, vec2(-0.7, -0.1), headpos+vec2(0.05*phs, 0), c);\n    float curve2 = sdBezier(f2pos, vec2(-0.2, -0.35), f1pos, c);\n    float curve3 = sdBezier(headpos+vec2(0.15+0.05*phs, 0), vec2(-0.35, -0.35), f2pos, c);\n    \n    float curves = max(-curve1, max(-curve2,-curve3));\n    \n    float body = min(min(min(max(curves, neck), foot1), foot2), ground);\n    \n    if (abs(head) < 0.01) colour = vec3(1.0,1.0,1.0);\n    if (abs(hair) < 0.01) colour = vec3(1.0,1.0,1.0);\n    if (abs(body) < 0.01) colour = vec3(1.0,1.0,1.0);    \n\n    //That is it, assign the colour to the pixel.\n    fragColor = vec4(colour,1.0);\n\n\n}","name":"Image","description":"","type":"image"}]}