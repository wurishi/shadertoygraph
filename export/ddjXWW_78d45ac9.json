{"ver":"0.1","info":{"id":"ddjXWW","date":"1670337226","viewed":106,"name":"SED4906 - Raymarching Test 2","username":"sed4906","description":"Now with different colors. It took a while to realize what I was doing wrong with the subtraction function when adding color.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\nconst float clip = 50.0;\n\nivec3 getHilbertIntegerToTranspose(int num, int level)\n{\n    ivec3 coord = ivec3(0);\n    for (int index = 0; index < 3; ++index) {\n        for (int bit_index = 3 * level - index - 1; bit_index >= 0; bit_index -= 3) {\n            coord[index] = (coord[index] << 1) | ((num & (1 << bit_index)) >> bit_index);\n        }\n    }\n    return coord;\n}\n\nivec3 getHilbertCoord(int h, int level) {\n    ivec3 hilbert_coord = getHilbertIntegerToTranspose(h, level);\n    int temp = hilbert_coord[2] >> 1;\n     for (int i = 2; i > 0; --i) {\n        hilbert_coord[i] = hilbert_coord[i] ^ hilbert_coord[i - 1];\n    }\n    hilbert_coord[0] = hilbert_coord[0] ^ temp;\n    \n    int scan = 2;\n    while (scan != (1 << level)) {\n        int scan_check = scan - 1;\n        for (int index = 2; index >= 0; --index) {\n            if ((hilbert_coord[index] & scan) != 0) {\n                hilbert_coord[0] = hilbert_coord[0] ^ scan_check;\n            } else {\n                temp = (hilbert_coord[0] ^ hilbert_coord[index]) & scan_check;\n                hilbert_coord[0] = hilbert_coord[0] ^ temp;\n                hilbert_coord[index] = hilbert_coord[index] ^ temp;\n            }\n        }\n        scan <<= 1;\n    }\n    return hilbert_coord;\n}\n\nvec3 HilbertColor(float c) {\n    return vec3(getHilbertCoord(int(c*4096.0),4))/15.0;\n}\n\nmat4 view(vec3 look, vec3 eye, vec3 up) {\n\tvec3 f = normalize(eye - look);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(vec3(0), 1)\n\t);\n}\n\nvec4 sphere( vec3 pos, float radius, vec3 point, vec3 lighting )\n{\n    return vec4(lighting, distance(pos, point) - radius);\n}\n\nvec4 cube( vec3 pos, vec3 size, vec3 point, vec3 lighting )\n{\n    vec3 d = abs(pos - point) - size;\n    return vec4(lighting, min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)));\n}\n\nvec4 sdfUnion( vec4 a, vec4 b ) {\n    if(a.w < b.w) return a;\n    return b;\n}\n\nvec4 sdfSub( vec4 a, vec4 b ) {\n    if(-a.w > b.w) return vec4(a.xyz,-a.w);\n    return b;\n}\n\nvec4 sdfInt( vec4 a, vec4 b ) {\n    if(a.w > b.w) return a;\n    return b;\n}\n\nvec4 scene( vec3 point )\n{\n    vec4 sdfc1_sphere = sphere(vec3(0),1.0,point, vec3(0.9));\n    vec4 sdfc2_sphere = sphere(vec3(0),1.2,point, vec3(0.8));\n    vec4 sdfc3_cube = cube(vec3(0), vec3(1), point, vec3(0.4));\n    vec4 sdfc4_sphere = sphere(vec3(0),1.3,point, vec3(0.2));\n    vec4 sdfc = sdfUnion(sdfc1_sphere,sdfSub(sdfc2_sphere,sdfInt(sdfc3_cube,sdfc4_sphere)));\n    return sdfc;\n}\n\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)).w - scene(vec3(p.x - EPSILON, p.y, p.z)).w,\n        scene(vec3(p.x, p.y + EPSILON, p.z)).w - scene(vec3(p.x, p.y - EPSILON, p.z)).w,\n        scene(vec3(p.x, p.y, p.z  + EPSILON)).w - scene(vec3(p.x, p.y, p.z - EPSILON)).w\n    ));\n}\n\nvec3 phong(vec3 diff, vec3 spec, float alpha, vec3 position, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = normal(position);\n    vec3 L = normalize(lightPos - position);\n    vec3 V = normalize(eye - position);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (diff * dotLN);\n    }\n    return lightIntensity * (diff * dotLN + spec * pow(dotRV, alpha));\n}\n\nvec3 light( vec3 ambi, vec3 diff, vec3 spec, float alpha, vec3 position, vec3 eye ) {\n    const vec3 ambientLight = vec3(0.5);\n    vec3 color = ambientLight * ambi;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          3.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4);\n    \n    color += phong(diff, spec, alpha, position, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          8.0);\n    vec3 light2Intensity = vec3(0.4);\n    \n    color += phong(diff, spec, alpha, position, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nvec3 raymarch( vec3 eye, vec3 dir ) {\n    float len = 0.0;\n    vec3 end = eye;\n    while(len < clip)\n    {\n        vec4 dist = scene(end);\n        end += dir * dist.w;\n        len += dist.w;\n        if(dist.w <= EPSILON)\n        {\n            vec3 lit = light(HilbertColor(dist.x), HilbertColor(dist.y), HilbertColor(dist.z), 1.0, end, eye);\n            return lit;\n        }\n    }\n    return vec3(0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n\n    vec3 camera = vec3(5.0*sin(iTime),5.0*cos(iTime),5.0*cos(iTime));\n    vec3 raydir = normalize(vec3(uv.x-0.5,(uv.y-0.5)/ar,1.0));\n\n    // Raymarch the scene\n    vec3 col = raymarch(camera, (view(vec3(0,0,1), camera, vec3(0,1,0)) * vec4(raydir,1.0)).xyz);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}