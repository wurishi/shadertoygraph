{"ver":"0.1","info":{"id":"DsX3Rr","date":"1665621064","viewed":64,"name":"Schrödinger Eq.","username":"weasel","description":"Simulation of the Schrödinger equation for a one particle field. The default potential (shown in blue) is a diffractiion grid. Particles can be spawned with left-click. The shown intensity is log(p) where p is the probability density.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["physics","quantum","wavefunction","qm","schrdinger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Look at \"Common\" shader tab for an explanation\n\n// this tab just contains the visual representation.\n// see below for an option to see the phase.\n\nPOTENTIAL\n\nfloat smoothstep2(float x) {\n    float x_ = clamp(x, 0.0, 1.0);\n    return cos((x_-0.5)*2.0*3.1415926)*0.5+0.5;\n}\n\nfloat contour_lines(float V, float stepsize) {\n    float Vd = length(vec2(dFdx(V), dFdy(V)));\n    return smoothstep2((mod(V/stepsize+10.0, 1.0)/(Vd+1e-6))*.03) * min(1.0, Vd*iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 value = psi(fragCoord);\n    vec2 V = potential(fragCoord);\n    vec4 V_rings = vec4(0., 0., contour_lines(V.x, 0.1), 0.);\n    float q = value.r;\n    \n    // change this to 1 to see the phase!\n#if 0\n    fragColor = mix(vec4(1.,0.,0.,1.), vec4(0.,0.,1.,1.), (sign(q)+1.0)*0.5) * abs(q) * 10.0 + V_rings;\n#else\n    float p = value.g;\n    float psi_sqr = q*q + p*p;\n    fragColor = vec4(vec3(max(0.0, 1.0+0.1*log(psi_sqr))), 1.0) + V_rings;\n#endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"LAPLACE\nPOTENTIAL\nTIMESTEP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 value = mix(vec4(psi(fragCoord),0,1), timestep(fragCoord), vec4(0,1,0,1)); // only the Im part\n    if (iMouse.z > 0.0) {\n        float d = length(fragCoord - iMouse.xy);\n        float size = 40.;\n        const float fac = 4.0;\n        //value = d < size ? vec4(1.0,0.0,0.0,1.0) : value;\n        float phase = (fragCoord - iMouse.xy).x*.77;\n        value = d < size ? vec4(cos(phase),sin(phase),0.0,1.0) * (exp(-fac*d*d/(size*size)) - exp(-fac)) : value;\n    }\n    if (iFrame == 0) {\n        value = vec4(0., 0., 0., 1.);\n    }\n    fragColor = value;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Field is structured as (r,g,b,a)=(Re(psi), Im(psi), 0, 1)\n// The Equation is\n// i*h d/dt |psi(t)> = H |psi(t)>\n// where H = p^2/(2m) + V(x) = -h^2/(2m)*laplace(psi(x,t)) + V(x)\n// so we simplify set h = point distance for the laplacian and get\n// H|psi(x,t)> = -1/(2m) * (4*psi(x,t)-psi(x+(1,0),t)-psi(x-(1,0),t)-psi(x+(0,1),t)-psi(x-(0,1),t))\n//\n// the differential equation can be solved using\n//\n// psi(t+dt) = exp(-i H dt/h) |psi(t)>\n//\n// which for small steps is:\n//\n// d_psi(t) = psi(t+dt)-psi(t) = (exp(-i H dt/h) - 1) |psi(t)>\n//          = (-i H dt/h + O(dt^2)) |psi(t)>\n//\n// however this euler method is unstable, instead use a symplectic integrator for\n//\n// d/dt Re(psi(t)) =  Im(H |psi(t)>)/h\n// d/dt Im(psi(t)) = -Re(H |psi(t)>)/h\n//\n// with this better method there are still numerical errors, which cause some diffusion effects\n// but for reasonable values for dt and mass, the simulation is at least stable.\n//\n// the problems remains, that the potential V(x) needs to be small, because otherwise\n// the phase will oscillate quicker than the integrator can handle.\n// Remember, that the motion is independent of constant terms in V(x) (const. with respect to space)\n// so a shift can be done to move the potential up or down,\n// at the cost of changing the phase rotation rate by an offset.\n\n// to get rid of the h, we define dt in units of h\n#define dt 0.24\n#define mass 0.5\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex division\nvec2 cdiv(vec2 a, vec2 b) {\n    return cmul(a, conj(b)) / dot(b, b);\n}\n\n// multiplication with i*hbar (hbar = 1)\nvec2 ih(vec2 c) { return vec2(-c.y, c.x); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n#define psi(pos) (texture(iChannel0, (pos)/iResolution.xy).rg)\n\n#define LAPLACE \\\nvec2 laplace_psi(vec2 pos, vec2 psi_) {\\\n    vec2 smpl1 = psi(pos + vec2(0,1));\\\n    vec2 smpl2 = psi(pos + vec2(0,-1));\\\n    vec2 smpl3 = psi(pos + vec2(1,0));\\\n    vec2 smpl4 = psi(pos + vec2(-1,0));\\\n    return 4.*psi_ - smpl1 - smpl2 - smpl3 - smpl4;\\\n}\n\n#define TIMESTEP \\\nvec4 timestep(vec2 pos) {\\\n    vec2 psi_ = psi(pos);\\\n    vec2 lapl = laplace_psi(pos, psi_) / (2.0*mass);\\\n    psi_ -= ih(-lapl + cmul(psi_, potential(pos))) * dt;\\\n    return vec4(psi_.r, psi_.g, 0., 1.);\\\n}\n\n// this defines the potential V(x), keep it 0 <= V(x) <= 1 to ensure stability of the integrator.\n// the potential here can be imaginary, to include damping.\n#define POTENTIAL \\\nvec2 potential(vec2 pos) {\\\n    return vec2(smoothstep(max(0.0, 10.0-abs(pos.x - iResolution.x/2.0))*(sqr(cos(pos.y*0.2))), 0.0, 1.0), 0.0);\\\n}\n//return vec2(smoothstep(max(0.0, 10.0-abs(pos.x - iResolution.x/2.0))*(sqr(cos(pos.y*0.2))), 0.0, 1.0), 0.0);\\\n//return vec2(smoothstep(pos.x - iResolution.x/2.0, 1.0, 0.0), 0.0);\n//return vec2(0.0, 0.0);\n//return vec2(clamp(1.0 - sqr(length(pos-iResolution.xy/2.0)/iResolution.x)*10.0, 0.0, 1.0), 0.0);\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"LAPLACE\nPOTENTIAL\nTIMESTEP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 value = mix(vec4(psi(fragCoord),0,1), timestep(fragCoord), vec4(1,0,0,1)); // only the Re part\n    if (iFrame == 0) {\n        value = vec4(0., 0., 0., 1.);\n    }\n    fragColor = value;\n}","name":"Buffer B","description":"","type":"buffer"}]}