{"ver":"0.1","info":{"id":"XlSyzw","date":"1507860223","viewed":598,"name":"Pastel Cornell Box","username":"riouxld","description":"Ray marching algorithm with shadow, reflection and noise.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","cornellbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ray marching algorithm with shadow and reflection\n//added a distorted surface to test the reflection part\n//noise is the heaviest thing to compute se the more octave you add\n//the less fps you obtain. Same for reflection.\n\n\nconst int MAX_MARCHING_STEPS = 55; // max marching step\nconst int MAX_MARCHING_STEPS_SHADOW = 8; // max shadow marching step\nconst int MAX_REFLECT_STEPS = 2; // max reflect step\n\n\nconst float MIN_DIST = 0.0; // min marching distance\nconst float MAX_DIST = 20.0; // max marching distance\nconst float MAX_DIST_SHADOW = 8.0; // max shadow marching distance\n\nconst float EPSILON = 0.05; // small number to offset position, normal, etc\n\n// control on noise octave contribution\nconst int OCTAVE = 1;\nconst float PERSISTENCE = 0.4;\nconst vec2 FREQUENCY = vec2(3.52, 3.52);\nconst float AMPLITUDE = 0.1;\nconst vec2 SPEED = vec2(1.5,1.5);\n\n// cornell box dimension\nconst vec3 BOX_CENTER = vec3(0,0,3);\nconst float BOX_HEIGHT = 5.0;\nconst float BOX_WIDHT = 5.0;\nconst float BOX_DEPTH = 10.0;\n\n\n\n//struct, could be optimized\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n\n    vec3 diffuse;\n    vec3 specular;\n\n    float constant;\n    float linear;\n    float quadratic;\n};\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n\n    float reflectivity; \n    float shininess;\n};\n\nstruct Sphere {\n    float radius;\n    vec3 center;\n    Material material;\n};\n\n\nstruct Plane {\n    vec3 center;\n    vec3 normal;\n    Material material;\n};\n\n struct Intersect {\n     float depth;\n     vec3 position;\n     vec3 normal;\n     Material material;\n };\n     \n                        \n// object in scene. defined in init()\nconst int numberOfSpheres = 3;\nconst int numberOfPlanes = 6;\nconst int numberOfLights = 1;\n\nSphere spheres[numberOfSpheres]; \nPlane box[numberOfPlanes];\nLight lights[numberOfLights];\nvec3 eye = vec3(0, 0, -0.75); // camera origin\n\n// Some way to incorporate noise. via texture is the fastest\n// https://www.shadertoy.com/view/4sfGzS\n// do doit procedurally comment #define TEXTURE_NOISE or \n// change #if 1 to #if 0\n#define TEXTURE_NOISE\n\n#ifdef TEXTURE_NOISE\n\nfloat noise( in vec2 x )\n{\n    #ifdef TEXTURE_NOISE\n\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = p.xy + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n    return mix( rg.x, rg.y, 1.0);\n\n    #else\n\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    ivec2 uv = p.xy;\n    vec2 rgA = texelFetch( iChannel0, (uv+ivec2(0,0))&255, 0 ).yx;\n    vec2 rgB = texelFetch( iChannel0, (uv+ivec2(1,0))&255, 0 ).yx;\n    vec2 rgC = texelFetch( iChannel0, (uv+ivec2(0,1))&255, 0 ).yx;\n    vec2 rgD = texelFetch( iChannel0, (uv+ivec2(1,1))&255, 0 ).yx;\n    vec2 rg = mix( mix( rgA, rgB, f.x ),\n                  mix( rgC, rgD, f.x ), f.y );\n    return mix( rg.x, rg.y, 1.0 );\n\n    #endif\n}\n\n#else\n\n#if 1\nfloat random (vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,f);\n\n    return mix(a, b, u.x) + \n        (c - a)* u.y * (1.0 - u.x) + \n        (d - b) * u.x * u.y;\n}\n\n#else\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n    p *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(mix( hash(p+vec2(0,0)), \n                   hash(p+vec2(1,0)),f.x),\n               mix( hash(p+vec2(0,1)), \n                   hash(p+vec2(1,1)),f.x),f.y);\n}\n#endif\n#endif\n\n\n\n\n// add perturbation or varying amplitude and frequency\nfloat octaveNoise (vec2 st) {\n    float total = 0.0;\n    vec2 freq = FREQUENCY;\n    float amp = AMPLITUDE;\n    // loop from large frequency to small to add smaller scale of noise\n    for(int i=0;i<OCTAVE;i++) {\n        total += noise(st*freq-iTime*SPEED) * amp;\n        amp *= PERSISTENCE;\n        freq *= vec2(2.1,2.1);\n    }\n\n    return total;\n}\n\n// sphere signed distance function > 0 if outside sphere = 0 on intersect\nfloat sphereSDF(vec3 samplePoint, Sphere sphere) {\n    return length(samplePoint-sphere.center) - sphere.radius;\n}\n\n// ocean signed distance function > 0 if outside ocean = 0 on intersect\n// sphere with noise to distort its surface\nfloat oceanSDF(vec3 samplePoint, Sphere sphere) {\n    return length(samplePoint-sphere.center) - sphere.radius - octaveNoise (samplePoint.xy);\n}\n\n// plane signed distance function > 0 if same side from normal = 0 on intersect\nfloat planeSDF(vec3 samplePoint, Plane plane) {\n    return dot( plane.normal , samplePoint - plane.center);\n}\n\n// box signed distance function > 0 if outside spheres = 0 on intersect\nfloat spheresSDF(vec3 samplePoint) {\n    float spheresDist = MAX_DIST;\n\n    for(int i=0; i<numberOfSpheres-1; i++)\n    {\n        spheresDist = min(spheresDist, sphereSDF(samplePoint, spheres[i]));\n    }\n    spheresDist = min(spheresDist, oceanSDF(samplePoint, spheres[numberOfSpheres-1]));\n\n    return spheresDist;\n}\n\n// box signed distance function > 0 if inside box = 0 on intersect\nfloat boxSDF(vec3 samplePoint) {\n    float boxDist = MAX_DIST;\n\n    for(int i=0; i<numberOfPlanes; i++)\n    {\n        boxDist = min(boxDist, planeSDF(samplePoint, box[i]));\n    }\n\n    return boxDist;\n}\n\n// scene signed distance function = 0 if hit scene\nfloat sceneSDF(vec3 samplePoint) {\n    return min(spheresSDF(samplePoint),boxSDF(samplePoint));\n}\n\n\n// find shortest distance to spheres, for shadow calculation\nfloat shortestDistanceToSpheres(Ray ray) {\n\n    float depth = MIN_DIST;// distance marched \n    //start raymarching loop\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        //distance from sphere\n        float dist = spheresSDF(ray.origin + depth * ray.direction);\n        //hit a sphere\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        //didnt hit a sphere\n        if (depth >= MAX_DIST_SHADOW) {\n            return MAX_DIST_SHADOW;\n        }\n    }\n    return MAX_DIST_SHADOW;\n}\n\n//check if object is behind a sphere\nbool isInSpheresShadow(Intersect intersection, Light light) {\n    float lightDist = length(light.position - intersection.position); //light dist\n    vec3 shadowDir = normalize(light.position - intersection.position);  //light dir\n\n    Ray shadowRay =  Ray(intersection.position + 10.0*EPSILON*shadowDir, shadowDir);\n    float shadowDist = shortestDistanceToSpheres(shadowRay);\n\n    // if intersected sphere in light direction then shadow before reaching light\n    if(shadowDist != MAX_DIST_SHADOW && shadowDist < lightDist) \n        return true;\n    return false;\n\n}\n\n//compute normal via centered difference\nvec3 calcNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\n//compute light contribution via phong model for each light source\nvec3 phongContribForLight(Ray ray, Intersect intersection, Light light) {\n    vec3 N = intersection.normal; //object normal\n    vec3 L = normalize(light.position - intersection.position); //light direction\n    vec3 V = normalize(ray.origin - intersection.position); // ray direction\n    vec3 R = normalize(reflect(-L, intersection.normal)); // reflect direction\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    //check if we face light\n    if (dotLN < 0.0) {\n        return vec3(0);\n    } \n\n    //attenuate light strength with distance from source\n    float Ldist = length(light.position - intersection.position); //light dist\n    float attenuation = 1.0 / (light.constant + light.linear * Ldist + \n                               light.quadratic * (pow(Ldist,2.0)));\n\n    //compute diffuse contribution\n    vec3 diffuse = light.diffuse*intersection.material.diffuse * dotLN;\n\n    //check if is in shadow of light source\n    if (isInSpheresShadow(intersection, light)){\n        return 0.5*diffuse;\n    }\n\n    //check if light specular reflection point to us\n    if (dotRV < 0.0) {\n        return diffuse*attenuation;\n    }\n\n    //compute specular contribution\n    vec3 specular = light.specular*intersection.material.specular * pow(dotRV, intersection.material.shininess * 128.0);\n\n    return (diffuse+specular)*attenuation;\n\n}\n\n//compute light contribution via phong model\nvec4 phongIllumination(Ray ray, Intersect intersection) {\n\n    //contribution from ambiant light\n    vec3 ambient =  0.3*vec3(1)*intersection.material.ambient;\n\n    vec3 color = ambient;\n\n    //contribution per light\n    for(int i=0; i<numberOfLights; i++)\n    {\n        color += phongContribForLight(ray, intersection, lights[i]);\n    }\n\n    return vec4(color,1);\n}\n\n// RAY MARCHING ALGORITHM\nvec4 rayTracer(Ray ray)\n{\n    vec4 accumulatedColor = vec4(0,0,0,1); // accumulated light over all raymarch\n    vec4 localColor = vec4(0); // local light contribution of each intersected object\n    float frac = 1.0; // lost of light at each reflexion\n    float dist = MAX_DIST; // distance of scene object\n    float depth = MIN_DIST; // distance marched since last intersection\n    float depthAccumulator = MIN_DIST; // total distance marched\n    vec3 p; //position in space\n\n    Ray reflectRay = Ray(ray.origin,  ray.direction);\n    Intersect intersection = Intersect(0.0, vec3(0), vec3(0), \n                                       Material(vec3(0), \n                                                vec3(0), \n                                                vec3(0),\n                                                0.0,0.0));\n\n    int reflectionCounter = 0; //number of reflexive object encountered\n    //start raymarching loop\n    for(int i=0; i<MAX_MARCHING_STEPS; i++)\n    {\n        //compute distance from position to scene \n        p = reflectRay.origin + depth * reflectRay.direction;\n        dist = sceneSDF(p);\n\n        //if hit something\n        if (dist < EPSILON) {\n            intersection = Intersect(dist, p, calcNormal(p), \n                                     Material(vec3(0), \n                                              vec3(0), \n                                              vec3(0),\n                                              0.0,0.0));\n            //retrieve material of object. not optimal I know\n            for(int j=0; j<numberOfSpheres-1; j++)\n            {\n                if (sphereSDF(p, spheres[j]) <= EPSILON) intersection.material = spheres[j].material;\n            }\n\n            if (oceanSDF(p, spheres[numberOfSpheres-1]) <= EPSILON) intersection.material = spheres[numberOfSpheres-1].material;\n\n            for(int j=0; j<numberOfPlanes; j++)\n            {\n                if (planeSDF(p, box[j]) <= EPSILON) intersection.material = box[j].material;\n            }\n\n            //compute lighting contribution of object with phong model\n            localColor = phongIllumination(reflectRay, intersection);\n            //compute accumulated lighting\n            accumulatedColor += localColor * frac;\n\n            depthAccumulator += depth;\n            //if object we hit is reflexive continue\n            if( (intersection.material.reflectivity > 0.0)&&(reflectionCounter < MAX_REFLECT_STEPS))\n            {\n                reflectionCounter += 1;\n                depth = MIN_DIST;\n                reflectRay = Ray(p + 5.0*EPSILON*intersection.normal,  normalize(reflect(reflectRay.direction, intersection.normal)));\n                frac *= intersection.material.reflectivity;\n            }\n            //if object we hit is not reflexive stop\n            else\n            {\n                break;\n            }\n\n        }\n        //if traveled maximum distance\n        if (depthAccumulator >= MAX_DIST) {\n            break;\n        }\n        //advance of distance to scene over the ray\n        depth += dist;\n\n    }\n    return accumulatedColor;\n}\n\n\n// INIT OBJECT IN SCENE\nvoid init()\n{\n\n    spheres[0] = Sphere(1.5, vec3(-2,0,7) + 2.0*vec3(0,cos(iTime),0),\n                        Material( vec3(0.07, 0.45, 0.4),\n                                 vec3(0.07, 0.45, 0.4),\n                                 0.5*vec3(1, 1, 1),\n                                 1.0, 0.5));\n\n    spheres[1] = Sphere(1.25, vec3(0, -2,5) + 2.0*vec3(cos(iTime+ 3.1416),0,0),\n                        Material( vec3(0.55, 0.27, 0.1),\n                                 0.75*vec3(0.55, 0.27, 0.1),\n                                 0.3*vec3(1, 1, 1),\n                                 0.0,0.05));\n\n    spheres[2] = Sphere(1.75, vec3(2, 2,8),\n                        Material( vec3(0.07, 0.45, 0.4),\n                                 vec3(0.07, 0.45, 0.4),\n                                 vec3(1, 1, 1),\n                                 0.5,0.8));\n\n\n    box[0] = Plane(vec3(0, BOX_HEIGHT, 0)+BOX_CENTER, vec3(0, -1, 0),\n                   Material( vec3(0.5, 0.3, 0.1),\n                            0.75*vec3(0.5, 0.3, 0.1),\n                            0.3*vec3(1, 1, 1),\n                            0.2,0.2));\n\n    box[1] = Plane(vec3(0, -BOX_HEIGHT, 0)+BOX_CENTER, vec3(0, 1, 0),\n                   Material( vec3(0.5, 0.1, 0.3),\n                            0.75*vec3(0.5, 0.1, 0.3),\n                            0.3*vec3(1, 1, 1),\n                            0.2,0.2));\n\n\n    box[2] = Plane(vec3(-BOX_WIDHT , 0, 0)+BOX_CENTER, vec3(1, 0, 0),\n                   Material( vec3(0.3, 0.1, 0.5),\n                            0.75*vec3(0.3, 0.1, 0.5),\n                            0.3*vec3(1, 1, 1),\n                            0.2,0.2));\n\n    box[3] = Plane(vec3(BOX_WIDHT , 0, 0)+BOX_CENTER, vec3(-1, 0, 0),\n                   Material(  vec3(0.1, 0.3, 0.5),\n                            0.75*vec3(0.1, 0.3, 0.5),\n                            0.3*vec3(1, 1, 1),\n                            0.2,0.2));\n\n    box[4] = Plane(vec3(0, 0, BOX_DEPTH)+BOX_CENTER, vec3(0, 0, -1),\n                   Material( vec3(0.1, 0.5, 0.3),\n                            0.75*vec3(0.1, 0.5, 0.3),\n                            0.3*vec3(1, 1, 1),\n                            0.2,0.2));\n\n    box[5] = Plane(vec3(0, 0, -BOX_DEPTH)+BOX_CENTER, vec3(0, 0, 1),\n                   Material( vec3(0.3, 0.5, 0.1),\n                            0.75* vec3(0.3, 0.5, 0.1),\n                            0.3*vec3(1, 1, 1),\n                            0.2,0.2));\n\n    lights[0] = Light( \n        vec3(0, 0, 2)+3.0*vec3(cos(iTime),sin(iTime),0),\n        vec3(1, 1, 1),\n        vec3(1, 1, 1),\n        1.0,\n        0.0000007,\n        0.000000002);\n    /*\nlights[1] = Light( \nvec3(0, 0, 8),\nvec3(1, 1, 1),\nvec3(1, 1, 1),\n1.0,\n0.07,\n0.02);\n*/\n\n    //eye = vec3(0, 0, -0.75)+0.15*vec3(cos(iTime*1.25),sin(iTime*1.0),0);\n}   \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n    uv.x *= aspectRatio;\n\n    // init scene\n    init();\n\n    // init ray from pixel\n    Ray ray = Ray(eye,normalize(vec3(uv.x, uv.y, 0)-eye));\n\n    // compute color via ray marching\n    fragColor = vec4(rayTracer(ray));\n}","name":"Image","description":"","type":"image"}]}