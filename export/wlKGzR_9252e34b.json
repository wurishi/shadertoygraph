{"ver":"0.1","info":{"id":"wlKGzR","date":"1578345694","viewed":209,"name":"Fractal orbits","username":"onlinerocker","description":"Wanted to play around with fractal structures...\nAlso tried to map a Voronoi pattern to some spheres, which turned out more difficult than anticipated ;p","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","voronoi","noise","space","spheretracing","planets","raymach"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n//SETTINGS:\n#define VIEW_DIST 40.0\n#define ITERATIONS 8.0\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps;\n    float id;\n    \n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    float minDist;\n    float glowAmt;\n\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n \nvec2 random(vec2 pos, vec2 range, vec2 start)\n{\n    float newX = sin(dot(pos, vec2(32.1232, 7.324)))*23432.4;\n    float newY = cos(dot(pos, vec2(432.23, 21.4)))*32145.4;\n    \n    newX = start.x + mod(newX, range.x);\n    newY = start.y + mod(newY, range.y);\n    \n    return vec2(newX, newY);\n}\n\nfloat floatRandom(vec2 pos, float range, float start)\n{\n    float val = cos(dot(pos, vec2(54.54, 6.766)))*12344.4;\n\tval = start + mod(val, range);\n    return val;\n}\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\n//IQ - https://www.shadertoy.com/view/XsX3RB\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat sdSphere(vec3 pos, float rad)\n{\n \treturn length(pos) - rad;\n}\n\nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    \n    o.dist = 1000.0;\n    o.normEps = 0.001;\n    o.color = vec3(0);\n    \n    //float ang = PI/2.0;\n    float fracAng = iTime/12.0;\n    vec3 objPos = pos - vec3(0.0, -0.0, 0.0); \n    \n     objPos.xz = mat2(cos(fracAng), sin(fracAng), -sin(fracAng), cos(fracAng)) * objPos.xz;\n    float dSphere = sdSphere(objPos, 5.0);\n\n    if(dSphere < o.dist){\n        o.dist = dSphere;\n        o.color = mix(vec3(0, 0.2, 0.9)*fbm(objPos/2.0), vec3(.1, .3, .15)*fbm(objPos*1.5), step(0.5, fbm(objPos*1.5)));\n        o.specVal = 8.0;\n        o.specKs = 0.01;\n    }\n    \n    float size = 1.0;\n    //float angFrac = PI/6.0;\n    vec3 posFracOff = vec3(9, 0.0, 10.);\n    \n    vec3 posFrac = objPos - posFracOff;\n    float dDist;\n    float minDist;\n\n\t\n    dDist = sdSphere(posFrac, size);\n    \n    float scale = 2.7;\n    vec3 p = objPos/scale;\n    float modi;\n    \n    for(float x=0.0; x < ITERATIONS; x++)\n    {        \n        modi =(p.x * p.z) / abs(p.x * p.z);\n        fracAng *= modi;\n        p.x = abs(p.x);\n        p.z = abs(p.z);\n        p = p * scale;\n\n        p -= posFracOff;\n        p.xz = mat2(cos(fracAng), sin(fracAng), -sin(fracAng), cos(fracAng)) * p.xz;\n      \n        float newDDist = sdSphere(p, 1.5) / pow(scale, x);\n        \n        //newDDist /= size;\n        dSphere = min(dSphere, newDDist);\n        if(dSphere < o.dist){\n            o.dist = dSphere;\n            \n            float d;\n            float minDist = 10000.0;\n            vec3 minPt;\n            vec3 len = (p);\n            vec3 len1 = p - posFracOff;\n            vec2 id;\n            \n            float angZ = atan(len.z, len.x);\n            float angY =atan(len.y,len.x);\n            \n            float scale = 20.0;\n            float yScale = 24.0;\n            \n            angZ *= scale;\n            id.x = floor(angZ/PI);\n            id.y = floor(p.y*yScale / PI);\n            \n            id += vec2(x*modi);\n  \n            float dVor, minDVor;\n            vec3 vor;\n            vec2 minId;\n            \n            float ang1 = -id.x*PI / scale;\n            vec3 orig = vec3(0, id.y * PI / yScale, 0);\n            float angRise = asin(orig.y / 1.5);\n            vec3 origBase = vec3(1.5, 0, 0);\n            origBase.xy = mat2(cos(angRise), sin(angRise), -sin(angRise), cos(angRise)) * origBase.xy;\n            origBase.xz = mat2(cos(ang1), -sin(ang1), sin(ang1), cos(ang1)) * origBase.xz;\n            orig.xz = origBase.xz;\n            \n            \n            minDVor = 1000.0;\n            minId = id;\n            for(float x=-1.0; x<=1.0; x++)\n            {\n                for(float y=-1.0; y<=1.0; y++)\n                {\n                    vec2 off = vec2(x,y);\n                    vec2 idOff = id+off;\n                    if(idOff.x == scale)\n                        idOff.x = -scale;\n                    if(idOff.x == -(scale+1.))\n                        idOff.x = scale-1.;\n                    \n                    float ang1Off = -idOff.x*PI / scale;\n                    vec3 origOff = vec3(0, idOff.y * PI / yScale, 0);\n                    float angRiseOff = asin(origOff.y / 1.5);\n                    vec3 origBaseOff = vec3(1.5, 0, 0);\n                    origBaseOff.xy = mat2(cos(angRiseOff), sin(angRiseOff), -sin(angRiseOff), cos(angRiseOff)) * origBaseOff.xy;\n                    origBaseOff.xz = mat2(cos(ang1Off), -sin(ang1Off), sin(ang1Off), cos(ang1Off)) * origBaseOff.xz;\n                    origOff.xz = origBaseOff.xz;\n\n                    vec2 rotsOff = random(idOff, vec2(2.*PI/(scale + (scale)), 0), vec2(0, 0));\n                    vor.xz = mat2(cos(-rotsOff.x), -sin(-rotsOff.x), sin(-rotsOff.x), cos(-rotsOff.x)) * origOff.xz;\n                    vor.y = origOff.y;\n                    \n                    dVor = length(p - vor);\n                    if(dVor < minDVor)\n                    {\n                     \tminDVor = dVor;\n                        minId = idOff;\n                    }\n                }\n        \t}\n            \n            vec3 posId = vec3(minId, 1);\n            o.color = mix(vec3(0.1, 0.1, 0.055)*fbm(posId/5.0), vec3(0.3, 0.15, 0.066)*fbm(posId/2.0), \n                          step(posId.y, (yScale/2.0)-2.0) * step(0.5, fbm(posId/5.0)));\n\n            o.specVal = 8.0;\n            o.specKs = 0.01;\n    \t}\n    }\n    \n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n    res.glowAmt = 1.0;\n    res.minDist = 1000.0;\n\n    for(int x=0; x<150; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        if(abs(o.dist) < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n           \n        \n        if(o.dist < res.minDist) res.minDist = o.dist;\n        res.totalDist += o.dist*speed;\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        \n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    float val = clamp(dot(o.normal, dir), 0.0, 1.0);\n    float oVal = val;\n    //val = round(val/0.33);\n    //val = smoothRound(val, 0.33, 0.05);\n    //val *= 0.33;\n    \n    vec3 col = (o.color) * l.intensity * l.color * val * o.difVal;   \n    //col = colQuant(3.0, col);\n    return col;\n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n\n    vec3 col = o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n    //col = colQuant(2.0, col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(0,5.0,16.0);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float rate = 8.0;\n    float camAng = iMouse.x/20.0;\n    float camAngPos = -PI/2.0;\n    float camAngX = -PI/6.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamPos = mat2( vec2(cos(camAngPos), -sin(camAngPos)), vec2(sin(camAngPos), cos(camAngPos)) );\n    mat2 rotCamX = mat2( vec2(cos(camAngX), sin(camAngX)), vec2(-sin(camAngX), cos(camAngX)) );\n\n    dir.yz = rotCamX * dir.yz;\n    dir.xz = rotCam * dir.xz;\n    \n    #ifdef ZOOM\n    camEye += vec3(0,1.3,0.5)*-3.5*abs(sin(iTime/rate));\n    #endif\n    \n    Light light;\n    light.intensity = 2.4;\n    light.pos = vec3(50, 5, 10);\n    light.color = vec3(1);\n    \n\tMarchRes res = marchRay(camEye, dir, 0.8);\n    vec3 pos = res.curRay;  \n    \n    float x = uv.x + iResolution.x / iResolution.y;\n    vec3 col = (vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0)*0.1*(x) + vec3(0.0, 0.0, 0.1)*(1.0-x));\n\t\n    col += vec3(0.2) * step(9.9, floatRandom(uv, 10.0, 0.0));\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, pos);\n        col += calcSpecLight(res.obj, light,pos, camEye);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}