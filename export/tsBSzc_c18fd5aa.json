{"ver":"0.1","info":{"id":"tsBSzc","date":"1554494489","viewed":1264,"name":"Jelly-Tube Forest","username":"fizzer","description":"Voxel-stepped and raytraced cylinders, with screenspace distortion to make them bendy. No distance field required here.","likes":85,"published":1,"flags":0,"usePreview":0,"tags":["sketch","colourful","jelly","tubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2 // Square root of the number of anti-aliasing samples to make.\n\nvec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)\n{\n    float a = dot(rd, rd);\n    float b = 2. * dot(rd, ro - org);\n    float c = dot(ro - org, ro - org) - rad * rad;\n    float desc = b * b - 4. * a * c;\n    if (desc < 0.)\n        return vec2(1, 0);\n\n    return vec2((-b - sqrt(desc)) / (2. * a), (-b + sqrt(desc)) / (2. * a));\n}\n\nvec2 intersectCylinder(vec2 ro, vec2 rd, vec2 org, float rad)\n{\n    return intersectSphere(vec3(ro, 0), vec3(rd, 0), vec3(org, 0), rad);\n}\n\nvec3 nn = vec3(0);\nfloat u = 0.;\n\nvec3 tr2(vec3 o, vec3 r, vec2 t)\n{\n    o += r * (1e-4 + .5 - o.y) / r.y;\n    for(int i = 0; i < 38; ++i)\n    {\n        vec3 c = vec3(floor(o.x), 0, floor(o.z));\n\n        vec3 ofs = vec3(cos(c.z) * .1, 0, cos(c.x) * .1);      \n\n        float rad = .3+cos(c.x) * .1;\n        ofs.x = cos(t.y * 8. + c.z * 2.5) * rad / 4.;\n\n        float h = -(cos(c.x + 3. + c.z * 65.) * .5 + .5) * 11.8;\n\n        u = h;\n\n        float ht = (h - o.y) / r.y;\n        float ft = (-2.2 - o.y) / r.y;\n\n        vec2 cyl = intersectCylinder(o.xz, r.xz, (c + ofs).xz + .5, rad);\n        vec2 sph = intersectSphere(o, r, (c + ofs) + .5 + vec3(0, -.5 + h, 0), rad);\n\n        cyl.x = max(cyl.x, ht);\n\n        if(sph.x < cyl.x && sph.y > 0. && sph.x < sph.y)\n        {\n            nn = normalize(o + r * sph.x - ((c + ofs) + .5 + vec3(0, -.5 + h, 0)));\n            return o + r * sph.x;\n        }\n\n        if((cyl.x < sph.y || sph.x >= sph.y) && cyl.y > 0. && cyl.x < cyl.y)\n        {\n            nn.xz = o.xz + r.xz * cyl.x - ((c + ofs).xz + .5);\n            nn.y = 0.;\n            nn = normalize(nn);\n            return o + r * cyl.x;\n        }\n\n        c.xz = ((c.xz + max(sign(r.xz), 0.)) - o.xz) / r.xz;\n        float t = (dot(c.xz, step(c.xz, c.zx)) + 1e-4);\n        //      if(ft<t){nn=vec3(0,1,0);return o+r*ft;}\n        o += t * r;\n    }\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec3 acc = vec3(0);\n    float wsum = 0.;\n\n    float time = iTime;\n\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n        {\n            vec2 t = uv.xy + vec2(x, y) / float(AA) * vec2(2.2) / iResolution.x;\n\n            vec3 o = vec3(1.4 + time / 3., 2.5, 0), r = normalize(vec3(t.xy + vec2(0, -1), -3.5));\n\n            {\n                float ang = -3.14159 / 5.;\n                r.xz *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n            }\n\n            vec3 rp;\n            fragColor.rgb = vec3(0);\n\n            rp = tr2(o, r, t);\n            u += o.y * 75.;\n            u += rp.y / 4.;\n\n            {\n                vec3 rd = r;\n                vec3 n = normalize(nn);\n                vec3 r = reflect(rd, n);\n                float fresnel = pow(clamp(1. - dot(n, -rd), 0., 1.), 2.);\n\n                float spec = step(max(abs(3. + r.x * o.y / r.y) - 4., abs(+r.z * o.y / r.y)), 1.4) * step(0., r.y);\n                spec += step(max(abs(-6.6 + r.x * o.y / r.y) - 2., abs(+r.z * o.y / r.y)), 1.4) * step(0., r.y) / 3.;\n\n                spec += step(abs(r.x-1.),.4)/7.;\n\n                fragColor.rgb += (vec3(cos(u), cos(u * 2.), cos(u * 3.)) * .5 + .5) * mix(.9, 1., fresnel);\n\n                vec3 rp2 = rp * 10.;\n                fragColor.rgb = mix(fragColor.rgb, vec3(1), .1 - .1 * smoothstep(.0, .05, length(rp2 - (floor(rp2) + cos(time + floor(rp2.zxy) * 9.) * .4 + .5)) - .1));\n\n                vec3 rp3 = rp * 3.;\n                fragColor.rgb *= mix(.7, 1., smoothstep(.0, .01, length(rp3 - (floor(rp3) + cos(floor(rp3.zxy) * 9.) * .25 + .5)) - .2));\n\n                fragColor.rgb *= rp.y / 10. + 1.5;\n\n                fragColor.rgb += 1.5 * spec * fresnel + fresnel / 15.;\n            }\n\n            acc += clamp(fragColor.rgb, 0., 1.);\n            wsum += 1.;\n        }\n    fragColor.rgb = pow(acc / wsum, vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"}]}