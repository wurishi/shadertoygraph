{"ver":"0.1","info":{"id":"McsyWf","date":"1722342059","viewed":27,"name":"RW_ Colored Game of Life","username":"RoosterWho","description":"The colored version of Game of Life","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["2d","simple","game","automata","life","reference","cellular","buffer","gameoflife","multipass","gol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Introduction to Game of Life\" by chronos. https://shadertoy.com/view/MtdXRn\n// 2024-07-23 06:26:49\n\n/*\n\n\tHi, and thanks for stopping by this humble implementation of Conway's Game of Life!\n\t\n\tThis shader was written to serve as a learning resource for people who are fairly\n\tnew to writing shaders or use as a starting point for more elaborate implementations.\n\tExercises and ideas for experimentation can be found at the bottom of this page,\n\tpost links in the comments to show me what you can come up with!\n\n\tThe shader can serve as an introduction to:\n\t- Buffers\n\t- Cellular automata ( Game of Life in particular )\n\n\tSome prior knowledge is assumed:\n\t- Basic programming knowledge\n\t- Basic familiarity with GLSL syntax\n\n\tReferences:\n\t- en.wikipedia.org/wiki/Conway%27s_Game_of_Life\n\n\tI'd love to hear your feedback and ideas for improvement in the comments!\n\n\t// Created by shadertoy user chronos - 2016\n\t\n*/\n\n/*\n\tIn this shader, the main function simply maps the contents of\n\tthe corresponding pixel in iChannel0 out to the screen.\n\tIt is therefore very short, and the bulk of the program can be\n\tfound in the 'Buf A' tab near the top of the window.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t/*\n\t\tBecause we intend to read from a texture and map to the entire window,\n\t\twe need to scale both our coordinates to map from the range [0 to 1]\n\t*/\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    /*\n\t\tHere we read the data from Buffer A through iChannel0.\n\t\tThe first parameter of texture is the texture,\n\t\tthe second parameter is where in the texture we sample from.\n\t*/\n    vec4 color = texture(iChannel0, uv);\n    \n    /*\n\t\tAnd here the final color is returned!\n\t\tCheck out the 'Buf A' tab for the rest of the code.\n\t*/\n\tfragColor = vec4(color.xyz, 1.0);\n}\n\n\n/*\n\tExercises and experiments!\n\n\t1. Make a restart button!\n\t   You can read input from the keyboard using an input channel and use it to\n\t   set the intial conditions again!\n\n\t2. The cells are currently only black and white and uses the red channel (sample.x or sample.r)\n\t   to check the cell state. Try to change the color of the cell based on the number of neighbors,\n\t   and preseve the game logic!\n\n\tHint: You can check whether any of the red, green or blue channels are non-zero to determine\n\twhether a cell is alive, but then you need to make sure you get the neighbor count right!\n\tAlternatively, you can make the cell a vec4 type and store state in the alpha channel!\n\tThis separates the logic from the color.\n\n\n\t3. If you watch carefully, you can see tiny gliders fly accross the screen amongst the chaos.\n\t   However, when they reach the end of the screen, they just collide.\n\t   Try to make repeating boundary conditions so that they reappear on the other side!\n\n\tHint: You can make coordinates wrap around by subtracting the floor() of the coordinate.\n\t\t  That is: \n\t\t\tX' = X - floor(X)\n\n\t\t  note that:\n\t      floor(-0.1 ) = -1\n\t\t  floor( 1.1 ) = 1\n\t      floor( 0.5 ) = 0\n\t\t  Remember to work in the right coordinate system!\n\n\t4. Experiment with other rules!\n\t   The original Game of Conway has carefully chosen rules so that it\n\t   strikes the right balance between order and chaos, in order to\n\t   produce interresting patterns such as gliders.\n\t   You can modify the rules by changing the conditions for cell life and death\n\t   based on previous cell state and neighbor count.\n\t   See if you can find which rules give worlds which either die out quicly or\n       rapidly overpopulate. Then try to find whether there are any other 'balanced'\n\t   rule sets.\n\n\t   Hint: After trying a bit on your own, you can check wikipedia for some good information on this :)\n\n\n\t5. Map the buffer to other pixels on screen!\n\t   You can sample any pixel from the buffer in the Image shader, try distorting the coordinates! \n\t   You can also use iChannel0 as a regular old texture in another shader.\n\t   For example, you can texture the ground plane in a 3D rendered image with it!\n\n\t6. Design your own procedural intial conditions!\n\t   The initial conditions don't need to come from an input texture,\n\t   you can design your own pattern procedurally!\n\t   Try to start with small (3 by 3 for example), basic patters to see more clearly which\n\t   produce interesting behaviour, then you can store them as functios and copy them around\n\t   the grid. See if you can build a glider-gun!\n\n\t   Hint: Wikipedia has a nice collection of interesting patterns, but try to build your own first!\n\t   \n\n\t7. Make the Game of life interactive with mouse input!\n\t   Draw live cells with the mouse cursor!\n\n\t8. Try different sizes of neighborhoods with different shapes!\n\t   Remember to modify the rules also!\n\n\t9. Make the cell size adjustable!\n\t   The cell size is currently only one pixel large, which is pretty tiny on high resolution screens.\n\t   Try to find a way to sample and draw such that the cell size can be ajusted.\n\n\t   Hint: A staircase function may come in handy here ;)\n\t   \n\t10. Make the timestep adjustable!\n\t\tWith a state update every frame, much of the action becomes to quick to see.\n\t\tMake a variable to control the update speed and control the flow of time! \n\t    \n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tThis is where the results of the rules are computed.\n\tThe reason it is computed here and not in the Image-tab\n\tis because we need to access the previous state of the simulation.\n\tThis is exactly what we can do by taking the output of the buffer\n\tas a texture input. Therefore, when we read from render buffer A \n\tin iChannel0, we can look up the state of any pixel/cell from the previous frame.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n\t\tAgain, we need to access the texture using coordinates in the range [0, 1]\n\t*/\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    /*\n\t\tUsing a tempoary variable for the output value for clarity.\n\t\tit is just passed to fragColor at the end of the function.\n\t*/\n    vec3 color = vec3(0.0);\n\n    /*\n\t\tTime to count the population of the neighborhood!\n\t\tWe count all the live cells in a 3 wide, 3 tall area\n\t\tcentered on this cell.\n\t\t _ _ _\n\t\t|_|_|_|     [-1, -1], [0, -1], [1, -1],\n\t\t|_|_|_|  =  [-1,  0], [0,  0], [1,  0],\n\t\t|_|_|_|     [-1,  1], [0,  1], [1,  1],\n\n\t\tSince each cell only should hold a value of either 0 (dead) or 1 (alive),\n\t\tthe count yields an integer value, but since the\n\t\ttexture sampling returns a float, we will use that instead.\n\t*/ \n    vec3 neighbors = vec3(0.0);\n    \n    for(float i = -1.0; i <= 1.0; i += 1.0)\n    {\n        for( float j = -1.0; j <= 1.0; j += 1.0)\n        {\n        \tvec2 offset = vec2(i, j) / iResolution.xy;\t\t // Scale the offset down\n        \tvec4 lookup = texture(iChannel0, uv + offset); // Apply offset and sample\n        \tneighbors += lookup.rgb;\t\t\t\t\t\t\t // Accumulate the result\n        }\n    }\n\n    \n    /*\n\t\tThis samples the pixel/cell in the previous frame. We use this along with the\n\t\tneighbor count to determined whether the cell is alive or dead in this\n\t\titeration.\n\t\tNote that we have now redundantly sampled this pixel twice (in the double for loop also!).\n\t\tThis is just for simplicity. If you wish, you can try to make the code more efficient :)\n\t*/    \n    vec3 cell = texture(iChannel0, uv).xyz;\n    float cell_ = cell.x + cell.y + cell.z;\n    float sum_count=0.;\n    sum_count = neighbors.x + neighbors.y + neighbors.z;\n    int maxcolor = 0;\n    \n    if (neighbors.x > neighbors.y && neighbors.x > neighbors.z){\n        maxcolor = 0;\n    } else if (neighbors.y > neighbors.x && neighbors.y > neighbors.z){\n        maxcolor = 1;\n\n    } else if (neighbors.z > neighbors.x && neighbors.z > neighbors.y){\n        maxcolor = 2;\n    } else\n    {\n        maxcolor = 3;\n    }\n    \n    \n    /*\n\t\tNow we just need to apply the rules to calulate the state of the cell in this iteraton.\n\t\tIt's really simple: We have already initialized the cell of this iteration to 0,\n\t\tWe therefore just have to check if we need to change that by seeing whether the\n\t\tconditions for being alive hold:\n\t\tCell alive and exactly 2 or 3 _other_ neighbors (3 or 4 in total)\n\t\tOR\n\t\tCell dead and exactly 2 _other_ neighbors (3 in total)\n\t*/\n    if(cell_ > 1.2) {\n        if(sum_count >= 5.1 && sum_count <= 10.8) {\n        switch(maxcolor){\n        case 0:\n            color = vec3(0.5,1.,1.);\n            break;\n        case 1:\n            color = vec3(1.0,0.5,1.);\n\n            break;\n        case 2:\n            color = vec3(1.0,1.,0.5);\n            break;\n        case 3:\n            color = vec3(0.85,0.75,0.15);\n            break;\n        }\n        }\n    } else if(sum_count > 6.3 && sum_count < 18.0 ||(sum_count >21.0)) {\n    \n            switch(maxcolor){\n        case 0:\n            color = vec3(.6,0.4,0.4);\n            break;\n        case 1:\n            color = vec3(0.4,.6,0.4);\n\n            break;\n        case 2:\n            color = vec3(0.4,.4,.6);\n            break;\n        case 3:\n            color = vec3(0.75,0.55,0.35);\n            break;\n        }\n    \t//color = vec3(1.0);\n    }\n\n    /*\n\t\tIn order to get any interesting behaviour, we need a non-uniform\n\t\tstarting-conditions. One simple way to do this is to feed\n\t\ta noise texture into the buffer for the first frame.\n\t\tWhen the condition fails, the previous frame will hold the noise texture ( iChannel1 ),\n\t\tand the Game of Life can begin!\n\t*/\n    if(iFrame < 50) { // can also use iFrame == 0, but seems less reliable.\n        color = vec3(texture(iChannel1, fragCoord.xy / iResolution.xx));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}