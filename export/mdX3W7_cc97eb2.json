{"ver":"0.1","info":{"id":"mdX3W7","date":"1693264823","viewed":20,"name":"Path Tracer artefox","username":"artefox","description":"Path Tracer artefox","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pathtracerartefox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VFOV = 90.0\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct data {\n    float t;\n    vec3 hit;\n    vec3 normal;\n    \n    vec3 albedo;\n    int id;\n    int mat_id;\n};\n\nstruct sphere {\n    vec3 pos;\n    float radius;\n    \n    vec3 albedo;\n    int mat_id;\n};\n\nstruct light {\n    vec3 pos;\n    float intensity;\n    vec3 color;\n};\n\nsphere scene[] = sphere[1](\nsphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0), 0)\n);\n\nlight lights[] = light[2](\nlight(vec3(-2.0, 2.5, 2.0), 50.0, vec3(1.0, 0.6, 0.2)),\nlight(vec3(4.0, 2.5, 1.5), 10.0, vec3(0.6, 0.5, 0.7))\n);\n\nbool sphere_hit(ray r, sphere s, float maxLen, out data d) {\n    vec3 oc = r.o - s.pos;\n    float a = dot(r.d, r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc, oc) - s.radius * s.radius;\n\n    float di = b * b - a * c;\n\n    if (di > 0.0) {\n        float temp = (-b - sqrt(di)) / a;\n\n        if (temp < maxLen && temp > 0.0) {\n            d.t = temp;\n            d.hit = r.o + d.t * r.d;\n            d.normal = (d.hit - s.pos) / s.radius;\n            d.mat_id = s.mat_id;\n            d.albedo = s.albedo;\n\n            return true;\n        }\n    }\n    return false;\n}\n\n// TODO: make function 'data' data type\nbool intersectScene(ray r, out data d) {\n    data temp_d;\n\n    bool hit_anything = false;\n    float closest_so_far = 10000.0;\n\n    for (int i = 0; i < scene.length(); i++) {\n        if (d.id == 0) {\n            sphere s = scene[i];\n            if (sphere_hit(r, s, closest_so_far, temp_d)) {\n                hit_anything = true;\n                closest_so_far = temp_d.t;\n                d = temp_d;\n            }\n        }\n    }\n    return hit_anything;\n}\n\nvec3 lighting(data d) {\n    vec3 shade = vec3(0.0);\n    vec3 col;\n    \n    for (int i = 0; i < lights.length(); i++) {\n        light l = lights[i];\n        data dl;\n        vec3 vtol = l.pos - d.hit;\n        float ld = length(vtol);\n        vtol /= ld;\n\n        if (d.t < 10000.0) {\n            vec3 s = vec3(max(dot(d.normal, vtol), 0.0) / (ld * ld));\n            intersectScene(ray(d.hit, vtol), dl);\n            col = (dl.t > ld ? vec3(0.0) : s) * l.intensity * l.color;\n            col += shade;\n        }\n    }\n    return col;\n}\n\nvec3 calcColor(ray r) {\n    // intersect scene\n    data d;\n    bool intersect = intersectScene(r, d);\n\n    // if nothing found, return background color\n    if (!intersect) return mix(vec3(0.6, 0.7, 1.0), vec3(0.3, 0.4, 0.7), r.d.y);\n\n    return d.albedo * lighting(d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // screen coords\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n\n    // get camera position, and right/up/front axis\n    ray r;\n    \n    float rot = 10.0 * iMouse.x / iResolution.x;\n    r.o = vec3(sin(rot) * 5.0, 0.0, cos(rot) * 5.0);\n    vec3 target = vec3(0.0);\n    \n    vec3 w = normalize(target - r.o);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n\n    // create ray\n    r.d = normalize(p.x * u + p.y * v + 1.0 * w);\n\n    // calc pixel color\n    vec3 col = calcColor(r);\n\n    // apply gamma correction\n    col = pow(col, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}