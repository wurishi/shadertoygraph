{"ver":"0.1","info":{"id":"7tGXRG","date":"1640877976","viewed":328,"name":"Diamond Tunnel","username":"gam0022","description":"IFS + Volume Rendering\n\nhttps://twitter.com/gam0022/status/1453405601971666944","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","volume"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://twitter.com/gam0022/status/1453405601971666944\n#define time iTime\n#define PI acos(-1.)\n#define TAU 2. * PI\n#define L normalize(vec3(1, 1, 1))\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat fbm(float x) { return sin(x) + 0.5 * sin(2. * x) + 0.25 * sin(4. * x); }\n\nfloat dBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvoid rot(inout vec2 p, float a) { p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p; }\n\nfloat map(vec3 p) {\n    float a = 4.5;\n    p = mod(p, a) - a * 0.5;\n    float s = 1.;\n\n    for (int i = 0; i < 3; i++) {\n        p = abs(p) - 0.5 + 0.04 * sin(time * TAU / 4.);\n        rot(p.xy, 0.5);\n        p = abs(p) - 0.4;\n        rot(p.yz, 0.3 + 0.2 * sin(time * TAU / 4.));\n\n        float b = 1.3 + 0.1 * sin(time * TAU / 4.);\n        p *= b;\n        s *= b;\n    }\n\n    return dBox(p, vec3(0.5, 0.05, 0.05)) / s;\n}\n\nfloat map2(vec3 p) {\n    float m1 = map(p) - 0.05;\n    vec3 a = vec3(1.0);\n    p = mod(p, a) - 0.5 * a;\n\n    for (int i = 0; i < 4; i++) {\n        p = abs(p) - 0.5;\n        rot(p.xy, 0.1);\n        p = abs(p) - 0.3;\n        rot(p.yz, 0.1);\n    }\n\n    return max(m1, dBox(p, vec3(1.1, 0.01, 0.01)));\n}\n\nvec3 getN(vec3 p) {\n    vec2 eps = vec2(0.001, 0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy), map(p + eps.yxy) - map(p - eps.yxy), map(p + eps.yyx) - map(p - eps.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0, 0, time);\n    vec3 target = ro + vec3(0., 0., 1.) + 0.01 * fbm(time * TAU * 2.);\n    vec3 up = vec3(0, 1, 0);\n\n    vec3 fwd = normalize(target - ro);\n    vec3 right = normalize(cross(up, fwd));\n    up = normalize(cross(fwd, right));\n    vec3 ray = normalize(right * uv.x + up * uv.y + fwd * 0.5);\n\n    vec3 p = ro;\n    bool hit = false;\n    float t = 0.0;\n    int i;\n\n    vec3 col = vec3(0);\n\n    for (i = 0; i < 100; i++) {\n        p = ro + ray * t;\n        float d = map(p);\n\n        if (d < 0.001) {\n            hit = true;\n            vec3 N = getN(p);\n            float diffuse = dot(N, L);\n            float specular = pow(saturate(dot(reflect(L, N), ray)), 10.0);\n            col = vec3(1) * mix(diffuse, specular, 0.8);\n            break;\n        }\n\n        t += d;\n    }\n\n    p = ro;\n    float t2 = 0.0, ac = 0.0;\n    for (i = 0; i < 100; i++) {\n        p = ro + ray * t2;\n        float d = map2(p);\n        d = max(abs(d), 0.02);\n        ac += exp(-10. * d);\n\n        t2 += d * 0.5;\n        if (t2 > t) break;\n    }\n\n    col += vec3(0.06, 0.3, 0.9) * ac * 0.1;\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}