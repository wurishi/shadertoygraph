{"ver":"0.1","info":{"id":"DttSDr","date":"1685286427","viewed":60,"name":"EmeraldWithColorfulGlow","username":"Eddy","description":"Reference\nhttps://qiita.com/kaneta1992/items/21149c78159bd27e0860\nhttps://www.youtube.com/watch?v=rvDo9LvfoVE&t=2s\nhttps://www.youtube.com/watch?v=NCpaaLkmXI8&t=389s\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","diamond","jewelry","bigwings"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi acos(-1.0)\n#define twoPi pi*2.0\n#define time iTime\n\nvec2 starDirect = vec2(0.0, 2.0);\n\nstruct RayInfo{\n    vec3 p;\n    float df;\n    float d;\n    float accum;\n    bool isHit;\n};\n\n// https://qiita.com/kaneta1992/items/21149c78159bd27e0860\nvec3 hsvToRgb(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nfloat random(vec2 p){\n    return fract(sin(dot(p, vec2(12.9876, 89.124))) * 76222.2466);\n}\n\nfloat random1d2d(vec2 p){\n    return fract(sin(dot(p.xy, vec2(12.532, 95.235))) * 24627.1245);\n}\n\nmat2 rotate(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec2 random2d2d(vec2 p){\n    return fract(sin(vec2(dot(p, vec2(333.12, 63.587)), dot(p, vec2(2122.66, 126.734)))) * 5222.346);\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdPlane(vec3 p, vec4 n) \n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat dJewel(vec3 p){\n    p.xz *= rotate(time*0.6);\n    p.yz *= rotate(acos(-1.0) * 0.5);\n    vec3 lBoxP1 = p;\n    vec3 lBoxP2 = p;\n    p = abs(p);\n\n    float d = 0.0;\n\n    d += sdBox(p, vec3(2.0, 2.0, 2.5));\n    float plane = sdPlane(p, vec4(normalize(vec3(0.0, -1.0, 0.0)), 0.8));\n    d = max(d, -plane);\n    plane = sdPlane(p, vec4(normalize(vec3(-1.0, 0.0, -1.0)), 2.4));\n    d = max(d, -plane);\n\n    plane = sdPlane(p, vec4(normalize(vec3(-1.0, -1.0, 0.0)), 1.2));\n    d = max(d, -plane);\n    plane = sdPlane(p, vec4(normalize(vec3(-0.4, -1.0, 0.0)), 1.0));\n    d = max(d, -plane);\n    plane = sdPlane(p, vec4(normalize(vec3(-0.1, -1.0, 0.0)), 0.86));\n    d = max(d, -plane);\n\n    plane = sdPlane(p, vec4(normalize(vec3(0.0, -1.0, -1.0)), 1.7));\n    d = max(d, -plane);\n    plane = sdPlane(p, vec4(normalize(vec3(0.0, -1.0, -0.3)), 1.16));\n    d = max(d, -plane);\n    plane = sdPlane(p, vec4(normalize(vec3(0.0, -1.0, -0.06)), 0.9));\n    d = max(d, -plane);\n\n    plane = sdPlane(p, vec4(normalize(vec3(-0.7, -1.0, -0.7)), 1.65));\n    d = max(d, -plane);\n    plane = sdPlane(p, vec4(normalize(vec3(-0.3, -1.0, -0.3)), 1.25));\n    d = max(d, -plane);\n    plane = sdPlane(p, vec4(normalize(vec3(-0.1, -1.0, -0.1)), 0.95));\n    d = max(d, -plane);\n    plane = sdPlane(p, vec4(normalize(vec3(-0.15, -1.0, -0.15)), 1.0));\n    d = max(d, -plane);\n\n    return d;\n}\n\n\nfloat distanceFunction(vec3 p){\n    vec3 p1 = p;\n    float d = 0.0;\n\n    d += dJewel(p1);\n\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 err = vec2(0.001, 0.0);\n    return normalize(vec3(\n        distanceFunction(p + err.xyy) - distanceFunction(p - err.xyy),\n        distanceFunction(p + err.yxy) - distanceFunction(p - err.yxy),\n        distanceFunction(p + err.yyx) - distanceFunction(p - err.yyx)\n    ));\n}\n\nRayInfo rayMarching(vec3 camPos, vec3 rayDir, float side){\n    RayInfo info;\n    info.isHit = false;\n    vec3 p = vec3(0.0);\n    float d = 0.0;\n    float df = 0.0;\n    for(int i = 0; i < 200; i++){\n        p = camPos + rayDir * d;\n        df = distanceFunction(p) * side;\n        if(df > 100.0){\n            break;\n        }\n        if(df <= 0.001){\n            info.isHit = true;\n            break;\n        }\n        d += df;\n    }\n\n    info.p = p;\n    info.df = df;\n    info.d = d;\n    return info;\n}\n\n// https://qiita.com/kaneta1992/items/21149c78159bd27e0860\nRayInfo phantomRayMarching(vec3 camPos, vec3 rayDir){\n    RayInfo info;\n    info.isHit = false;\n    vec3 p = vec3(0.0);\n    float d = 0.0;\n    float df = 0.0;\n    float accum = 0.0;\n    for(int i = 0; i < 80; i++){\n        p = camPos + rayDir * d;\n        df = distanceFunction(p);\n        df = max(abs(df), 0.002);\n        accum += exp(-df * 222.2);\n        d += df * 0.7;\n    }\n\n    info.p = p;\n    info.df = df;\n    info.d = d;\n    info.accum = accum;\n    return info;\n}\n\nvec3 gradate(vec2 uv){\n    vec2 p = (uv + 1.0) / 2.0;\n\n    return mix(vec3(0.502, 0.9176, 0.6941), vec3(0.5804, 0.9059, 0.7373), p.y) * mix(vec3(0.0549, 0.5569, 0.4549), vec3(0.5451, 0.8235, 0.7608), abs(uv.x));\n}\n\n// https://www.youtube.com/watch?v=rvDo9LvfoVE&t=2s\nfloat starOrb(vec2 uv, vec2 p, float flare){\n    float c = 0.0;\n    uv -= p;\n    float d = length(uv);\n    c += 0.2/d;\n\n    float ray = max(0.0, 1.0 - abs(uv.x*uv.y*200.0));\n    c += ray*flare;\n    uv *= rotate(pi/4.0);\n    ray = max(0.0, 1.0 - abs(uv.x*uv.y*500.0));\n    c += ray*0.2*flare;\n\n    c *= smoothstep(0.4, 0.2, d);\n\n    return c;\n}\n\nvec3 latticeStarField(vec2 uv, float s, vec2 subPos){\n    vec3 color = vec3(0.0);\n\n    uv *= s;\n    uv += subPos;\n\n    vec2 fPos = fract(uv) - 0.5;\n    vec2 iPos = floor(uv);\n\n    for(float y = -1.0; y <= 1.0; y+=1.0){\n        for(float x = -1.0; x <= 1.0; x+=1.0){\n            vec2 offset = vec2(x, y);\n            float n = random1d2d(iPos+offset);\n            float s = fract(n*4052.22);\n            float star = starOrb(fPos-offset, vec2(n, fract(n*34.24)), smoothstep(0.5, 0.02, s)); \n            vec3 pal = hsvToRgb(fract(s), 1.0, 1.0);\n            float orbColor = pow(star * s, 2.0) * 0.7;\n            color = mix(color, pal, orbColor);\n        }\n    }\n    \n    return color;\n}\n\nvec3 background(vec2 uv){\n    vec3 color = vec3(0.0);\n    for(float i = 0.0; i <= 1.0; i+=1.0/5.0){\n        float depth = fract(time*0.02 + i);\n        float scale = mix(6.0, 0.01, depth);\n        float fade = depth*smoothstep(10.0, 0.9, depth);\n        starDirect = vec2(sin(i*222.87 + time*0.3) * 0.3, 2.0);\n        color += latticeStarField(uv*rotate(i*234.25), scale, vec2(i*222.87) - starDirect) * (fade*(sin(i*200.0+time*4.0) * 0.1 + 0.1));\n    }\n    return color;\n}\n\nvec3 latticeFromRayDir(vec3 camPos, vec3 rayDir, vec3 p){\n    float depth = length(p - camPos);\n    vec2 uv = p.xy / (depth * rayDir.z);\n\n    vec3 color = (gradate(uv) + background(uv + starDirect));\n\n    return color;\n}\n\nvec3 renderingFunc(vec2 uv){\n    vec3 color = vec3(0.0);\n    vec3 camPos = vec3(0.0, 0.0, -7.0);\n    vec3 lookPos = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(lookPos - camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, forward));\n    up = normalize(cross(forward, right));\n    float fov = 1.0;\n    vec3 rayDir = normalize(uv.x * right + uv.y * up + fov * forward);\n\n    RayInfo phantomInfo = phantomRayMarching(camPos, rayDir);\n\n    RayInfo info = rayMarching(camPos, rayDir, 1.0);\n    vec3 refOutside = latticeFromRayDir(camPos, rayDir, info.p);\n    color += refOutside + pow(phantomInfo.accum, 2.5);\n\n    // https://www.youtube.com/watch?v=NCpaaLkmXI8&t=389s\n    float indexOfRefraction = 1.45;\n    if(info.isHit){\n        vec3 normal = getNormal(info.p);\n        vec3 r = reflect(rayDir, normal);\n        vec3 rayDirIn = refract(rayDir, normal, 1.0/indexOfRefraction);\n        vec3 pEnter = info.p - normal * 0.01 * 3.0;\n        RayInfo inInfo = rayMarching(pEnter, rayDirIn, -1.0);\n        vec3 inNormal = -getNormal(inInfo.p);\n\n        vec3 reflectTex = vec3(0);\n        vec3 rdOut = vec3(0);\n        float abb = 0.4;\n\n        rdOut = refract(rayDirIn, inNormal, indexOfRefraction-abb);\n        rdOut = reflect(rayDir, inNormal) * (1.0 - abs(sign(dot(rdOut, rdOut))));\n        reflectTex.r = latticeFromRayDir(pEnter, rayDirIn, inInfo.p).r;\n\n        rdOut = refract(rayDirIn, inNormal, indexOfRefraction);\n        rdOut = reflect(rayDir, inNormal) * (1.0 - abs(sign(dot(rdOut, rdOut))));\n        reflectTex.g = latticeFromRayDir(pEnter, rayDirIn, inInfo.p).g;\n\n        rdOut = refract(rayDirIn, inNormal, indexOfRefraction+abb);\n        rdOut = reflect(rayDir, inNormal) * (1.0 - abs(sign(dot(rdOut, rdOut))));\n        reflectTex.b = latticeFromRayDir(pEnter, rayDirIn, inInfo.p).b;\n\n        float dens = 0.9;\n        float optDist = exp(-inInfo.d * dens);\n        reflectTex = reflectTex * optDist;\n\n        float fresnel = pow(1.0+dot(rayDir, normal), 5.0);\n        \n        color = mix(reflectTex, refOutside, fresnel);\n        color += phantomInfo.accum * 0.14 * vec3(0.098, 0.3294, 0.1569);\n    }\n\n    color = pow(color, vec3(0.4545));\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    vec3 color = vec3(0.0);\n    \n    color += renderingFunc(uv);\n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}