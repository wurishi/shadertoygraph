{"ver":"0.1","info":{"id":"ftyyWR","date":"1661203510","viewed":210,"name":"Spiral Optical Illusion","username":"cnlohr","description":"Just a test optical illusion, from https://twitter.com/Rainmaker1973/status/1561322229559726080","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["spiral","illusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Illusion based on https://twitter.com/Rainmaker1973/status/1561322229559726080\n\nconst bool grey_bars = false;\n\nvec3 CalcColor( vec2 uvz )\n{\n\n    bool showdiamonds = true; //fract(iTime*0.1)>0.5;\n    \n    // THIS LINE is really cool.  The diamonds are what are **the key** to this illusion.\n    bool checkdiamonds = true;// fract(iTime*0.1)>0.5;   //XXX HEY, YOU!!! PLAY WITH TURNING THIS ON AND OFF.\n    \n    float spin_speed = 0.15;\n    float zoom_speed = 0.3;\n    const float segpairs = 18.0;\n    \n    vec2 thetar = vec2(atan( uvz.x, uvz.y ), length( uvz ) );\n\n    const float PI = 3.14159265;\n    const float TAU = PI * 2.0;\n    \n    thetar.x += PI;\n    \n    thetar.x += iTime*spin_speed;\n    \n    float segno;\n    float segplace = (thetar.x * segpairs / TAU);\n    segplace = modf( segplace, segno );\n\n    // For debugging\n    //return vec3( thetar.y );\n    float oneoverr = mix( 40.0, 1.0, pow( 1.0/thetar.y, 0.07) );\n    oneoverr += 0.5;\n    \n    \n    oneoverr += iTime * zoom_speed;\n    \n    float oneoverrf = fract( oneoverr );\n\n    // Neat effect.\n    //return vec3( min( fract(segplace + oneoverrf), fract(segplace - oneoverrf) ) );\n\n    float diamondmr = fract(oneoverrf*2.0);\n    float diamondms = fract(segplace*2.0);\n    float diamondr = abs(0.5-diamondmr);\n    float diamonds = abs(0.5-fract(diamondms+diamondmr));\n    float diamondp = abs(0.5-fract(diamondms));\n    float diamondt = abs(0.5-fract(diamondms-diamondmr));\n    float diamondinten = min( min( diamondr, diamonds ), min( diamondp, diamondt ) );\n\n    // Uncomment for another neat effect.\n    //return vec3(  min( diamondr, diamonds ) );\n\n    float offset = floor(fract(oneoverr/2.0)*2.0)*0.5;\n    // For debugging\n    //return vec3( offset) ;\n\n    vec3 col = vec3( 1.0 );\n    \n    if( diamondinten > 0.17 && showdiamonds )// duva > 0.0 )\n    {\n        col = vec3((diamondr-diamondp)>0.0);\n        // Uncomment for a neat shape.\n        //return vec3( abs(  0.5 - segplace  )>0.25);\n        if( !checkdiamonds ) \n            segplace = 0.0;\n            \n        if( (fract(oneoverr*0.5+0.4)>0.5) ^^ ( fract( abs( 0.5 - segplace ) ) > 0.25 ) )\n            col = 1.0-col;\n    }\n    else\n    {\n        if( oneoverrf < 0.5 )\n        {\n            col = (fract( segplace + offset ) > 0.5)?vec3( 1.0, 1.0, 1.0 ):vec3( 0.0, 0.0, 0.0 );\n        }\n        else\n        {\n           col = (fract( segplace + offset + 0.25 ) > 0.5)?vec3( 0.1, 0.6, 1.0 ):vec3( 0.1, 1.0, 1.0 );\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvz = uv * 2. - 1.;\n    \n    // Grey bars on the sides.\n    if( grey_bars )\n        if( uvz.x < -iResolution.y/iResolution.x || uvz.x > iResolution.y/iResolution.x ) { fragColor = vec4( 0.5); return; }\n    \n    // Make it square.\n    uvz.x *= iResolution.x/iResolution.y;\n \n    vec3 col = vec3( 0.0 );\n    float count = 0.0;\n    \n    // Anti-alias it to mush.\n    vec2 uvofsl = vec2(1.3/iResolution.xy);\n    vec2 ofs = -uvofsl;\n    for( ; ofs.x <= uvofsl.x; ofs.x += uvofsl.x*0.3 )\n    {\n        for( ofs.y = -uvofsl.y; ofs.y <= uvofsl.y; ofs.y += uvofsl.y*0.3 )\n        {\n            col += CalcColor( uvz+ofs );\n            count ++;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col/count,1.0);\n}","name":"Image","description":"","type":"image"}]}