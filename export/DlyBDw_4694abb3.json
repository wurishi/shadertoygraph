{"ver":"0.1","info":{"id":"DlyBDw","date":"1702119123","viewed":32,"name":"Ray Marched Primitives","username":"Chroma_Crash","description":"Simple ray marcher for practice and portfolio. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","primitive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define STEPS 128\n#define MAX_MARCH 100.0\n#define HIT_DISTANCE 0.001\n\n#define LIGHT_DIRECTION normalize(vec3(0.8, 1, 1))\n#define LIGHT_COLOR vec3(1, 1, 1)\n\n#define DISTANCE 24.0\n\n#define PIXEL_SIZE 1.0\n\nvec3[4] PALETTE = vec3[](vec3(0.6, 0.8, 0.7), vec3(0.9, 0.2, 0.2), vec3(0.2, 0.2, 0.9),\n                         vec3(0.2, 0.9, 0.2));\n\n\nfloat sdPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdCylinder(vec3 p, vec2 s)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCube(vec3 p, vec3 s) {\n    vec3 d = abs(p) - s;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone(vec3 p, vec3 s) {\n    return 0.0;\n}\n\nvec2 select(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 world(vec3 p) {\n    vec2 res = vec2(p.y, -1);\n    \n    float plane = sdPlane(p);\n    float sphere = sdSphere(p - vec3(0, 2, 0), 2.0);\n    float cylinder = sdCylinder(p - vec3(6, 3.0 + sin(iTime * 2.0), 0), vec2(2.0, 2.0));\n    float box = sdCube(p - vec3(-6, 3.0 + cos(iTime * 2.0), 0), vec3(2.0, 2.0, 2.0));\n    \n    res = select(res, vec2(plane, 0));\n    res = select(res, vec2(sphere, 1));\n    res = select(res, vec2(cylinder, 2));\n    res = select(res, vec2(box, 3));\n\n    return res;\n}\n\nvec3 get_normal(in vec3 p) {\n    const vec3 s = vec3(0.001, 0.0, 0.0);\n\n    float g_x = world(p + s.xyy).x - world(p - s.xyy).x;\n    float g_y = world(p + s.yxy).x - world(p - s.yxy).x;\n    float g_z = world(p + s.yyx).x - world(p - s.yyx).x;\n\n    vec3 normal = vec3(g_x, g_y, g_z);\n\n    return normalize(normal);\n}\n\nfloat specular(vec3 cam, vec3 pos, vec3 normal) {\n    vec3 viewDir = normalize(cam - pos);\n    vec3 reflectDir = reflect(-LIGHT_DIRECTION, normal);\n    \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    return 0.5 * spec;\n}\n\nfloat diffuse(vec3 normal) {\n    float diffuse = (dot(LIGHT_DIRECTION, normal) + 1.0) / 2.0;\n    return diffuse;\n}\n\nvec4 raymarch(in vec3 ro, in vec3 rd) {\n    float traveled = 0.03;\n    \n    vec3 p = ro;\n\n    for (int i = 0; i < STEPS; i++) {\n        p = ro + traveled * rd;\n        \n        vec2 world = world(p);\n    \n        float max_travel = world.x;\n        \n        if (max_travel < HIT_DISTANCE) {\n            return vec4(p, world.y);\n        }\n        \n        if (traveled > MAX_MARCH) {\n            break;\n        }\n        \n        traveled += max_travel;\n    }\n    return vec4(p, -1);\n}\n\nfloat shadow(vec3 ro, vec3 rd) {\n    float traveled = 1.0;\n    \n    float res = 1.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec2 world = world(ro + traveled * rd);\n        \n        float max_travel = world.x;\n        \n        if (max_travel < HIT_DISTANCE) {\n            return 0.0;\n        }\n        if (traveled > MAX_MARCH) {\n            break;\n        }\n        \n        res = min(res, 2.0 * max_travel / traveled);\n        \n        traveled += max_travel;\n    }\n    \n    return res;\n}\n\nvec4 render(vec2 uv, float time) {\n    uv *= 0.8;\n\n    vec3 ro = vec3(cos(time) * DISTANCE, DISTANCE * 5.0 / 12.0, sin(time) * DISTANCE);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    float d = PI/8.0;\n    \n    mat3 rx = mat3(1,       0,      0,\n                   0,  cos(d), sin(d),\n                   0, -sin(d), cos(d));\n                  \n    d = -time - PI / 2.0;\n    \n    mat3 ry = mat3(cos(d), 0, -sin(d),\n                        0, 1,       0,\n                   sin(d), 0,  cos(d));\n                   \n    rd = ry * rx * rd;\n    \n    vec4 march = raymarch(ro, rd);\n    \n    vec3 pos = march.xyz;\n    vec3 normal = get_normal(pos);\n    \n    float lighting = diffuse(normal) + specular(ro, pos, normal);\n    \n    float shadow_cast = shadow(pos, LIGHT_DIRECTION);\n    \n    if (march.w < 0.1) {\n        float checker = ((int(floor(pos.x)) + int(floor(pos.z))) % 2 == 0) ? 0.0 : 0.1;\n        float damped = checker * (1.0 - (length(pos - ro) / MAX_MARCH));\n        \n        lighting = (0.9 + damped) * lighting;\n    }\n    \n    vec3 col = pow(shadow_cast * lighting, 2.2) * LIGHT_COLOR * PALETTE[int(march.w)];\n    \n    return vec4(col, 1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE;\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    vec4 col = render(uv, iTime / 2.0);\n\n    fragColor = col;\n}\n\n\n","name":"Image","description":"","type":"image"}]}