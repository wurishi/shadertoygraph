{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"precision highp float;\n\n// Parameters\nconst float tile_min_size = 18.;\nconst float tiles_on_screen = 40.;\nconst vec3 color1 = vec3(.45, .33, 0.);\nconst vec3 color2 = vec3(1., .8, 0.);\nconst float linewidth = 2.4;\nconst float omega = 0.01;\nconst int max_depth = 32; // should be enough for all practical purposes\n// ---------------------------------------\nconst float v = 0.618033988749894848204587;\nconst float w = 0.381966011250105151795413;\nconst float grow = 6.85410196624968454461376;\nconst vec2 dp0 = vec2(1.0, 0.0);\nconst vec2 dp1 = vec2(0.809016994374947424102293, 0.587785252292473129168706);\nconst vec2 dp2 = vec2(0.309016994374947424102293, 0.951056516295153572116439);\nconst float linestep0 = 0.5 * (linewidth - 2.4);\nconst float linestep1 = linestep0 + 1.2;\n\nbool is_left(vec2 p0, vec2 p1, bool flipped)\n{\n\treturn flipped ^^ (p0.x * p1.y - p0.y * p1.x > 0.);\n}\n\nvoid deflate(inout vec2 p0, inout vec2 p1, inout vec2 p2, inout bool acute, inout bool flipped)\n{\n\tif (acute) {\n\t\tvec2 q = v * p1 + w * p0;\n\t\tif (is_left(p2, q, flipped)) {\n\t\t\tp0 = p2;\n\t\t\tp2 = p1;\n\t\t\tp1 = q;\n\t\t} else {\n\t\t\tvec2 r = v * p0 + w * p2;\t\n\t\t\tif (is_left(r, q, flipped)) {\n\t\t\t\tp0 = p2;\n\t\t\t\tp2 = r;\n\t\t\t\tp1 = q;\n\t\t\t} else {\n\t\t\t\tp2 = p0;\n\t\t\t\tp1 = q;\n\t\t\t\tp0 = r;\n\t\t\t\tacute = !acute;\n\t\t\t}\n\t\t\tflipped = !flipped;\n\t\t}\n\t} else {\n\t\tvec2 q = v * p1 + w * p2;\n\t\tif (is_left(q, p0, flipped)) {\n\t\t\tp2 = p1;\n\t\t\tp1 = p0;\n\t\t\tp0 = q;\t\t\n\t\t} else {\n\t\t\tp1 = p0;\n\t\t\tp0 = p2;\n\t\t\tp2 = q;\n\t\t\tacute = !acute;\n\t\t}\n\t}\n}\n\nvoid initial_inflate(inout vec2 p1, inout vec2 p2)\n{\n\tp1 *= grow;\n\tp2 *= grow;\t\n}\n\nfloat calc_dist(vec2 p0, vec2 p1)\n{\n\treturn abs(p0.x * p1.y - p0.y * p1.x) / length(p1 - p0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat size = max(tile_min_size, max(iResolution.x, iResolution.y) / tiles_on_screen);\n\tvec2 offset = 6. * iResolution.xy  * vec2(sin(omega * iTime), sin(2. * omega * iTime));\n\tvec2 p0 = offset + (iMouse.xy - 0.5 * iResolution.xy) - fragCoord.xy;\n\tvec2 quad = vec2(sign(-p0));\n\tbool flipped = (quad.y < 0.);\n\tbool acute = true;\n\tvec2 p1, p2;\n\tif (is_left(p0 + quad * dp1, p0, quad.x * quad.y < 0.)) {\n\t\tp1 = quad * size * dp0;\n\t\tp2 = quad * size * dp1;\n\t} else {\n\t\tif (is_left(p0 + quad * dp2, p0, quad.x * quad.y < 0.)) {\n\t\t\tp1 = quad * size * dp2;\n\t\t\tp2 = quad * size * dp1;\n\t\t\tflipped = !flipped;\n\t\t} else {\n\t\t\tp1 = quad * size * dp2;\n\t\t\tp2 = quad * size * dp2 * vec2(-1., 1.);\n\t\t}\n\t}\n\tif (quad.x < 0.) {\n\t\tvec2 tmp = p2;\n\t\tp2 = p1;\n\t\tp1 = tmp;\n\t}\n\tint depth = 0;\n\tfor (int i = 0; i < max_depth / 4; i++) {\n\t\tif (is_left(p0 + p1, p0 + p2, flipped)) break;\n\t\tinitial_inflate(p1, p2);\n\t\tdepth += 4;\n\t}\n\tp1 += p0;\n\tp2 += p0;\n\tfor (int i = 0; i < max_depth; i++) {\n\t\tif (depth == 0) break;\n\t\tdeflate(p0, p1, p2, acute, flipped);\n\t\tdepth--;\n\t}\n\tvec3 color = (acute ? color1 : color2);\n\tif (acute) {\n\t\tcolor *= smoothstep(linestep0, linestep1, calc_dist(p1, p2));\n\t\tcolor *= smoothstep(linestep0, linestep1, calc_dist(p2, p0));\n\t} else {\n\t\tcolor *= smoothstep(linestep0, linestep1, calc_dist(p0, p1));\n\t\tcolor *= smoothstep(linestep0, linestep1, calc_dist(p1, p2));\n\t}\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdXGDX","date":"1380153494","viewed":756,"name":"Penrose","username":"daniel_flassig","description":"Penrose tiling - non-periodic...","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["2d","tiling"],"hasliked":0,"parentid":"","parentname":""}}