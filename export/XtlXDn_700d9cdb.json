{"ver":"0.1","info":{"id":"XtlXDn","date":"1512059890","viewed":366,"name":"GlassBaubleScroller","username":"ChristinaCoffin","description":"inspired by my love for 16bit shmups with lots of parallax and scanline/scroller effects when I owned an amiga.\ndoing some hacks with out of bounds color mixing to create faked translucency/refraction type effect.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","scroller"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// 'GlassBaubleScroller' by @christinacoffin \n//\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n//\n//  remixed bits from :https://www.shadertoy.com/view/4t23RR\n#define sat(x) clamp(x,0.0,1.0) \n#define iTime   (iTime+2000.)\n#define TAU 6.28318530718\nconst vec3 BackColor\t= vec3(0.11, 0.34, 0.777);\nconst vec3 CloudColor\t= vec3(0.618,0.470,0.187);\n\nfloat Func(float pX)\n{\n\treturn 0.6*(0.5*sin(0.1*pX) + 0.5*sin(0.553*pX) + 0.7*sin(1.2*pX));\n}\n\nfloat FuncR(float pX)\n{\n\treturn 0.95 + 0.25*(1.0 + sin(mod(40.0*pX, TAU)));\n}\n\n\nfloat Layer(vec2 pQ, float pT)\n{\n\tvec2 Qt = 3.5*pQ;\n\tpT *= 0.5;\n\tQt.x += pT;\n\n\tfloat Xi = floor(Qt.x);\n\tfloat Xf = Qt.x - Xi -0.5;\n\n\tvec2 C;\n\tfloat Yi;\n\tfloat D = 1.0 - step(Qt.y,  Func(Qt.x));\n\n\t// Disk:\n\tYi = Func(Xi + 0.5);\n\tC = vec2(Xf, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi+ pT/80.0));\n\n\t// Previous disk:\n\tYi = Func(Xi+1.0 + 0.5);\n\tC = vec2(Xf-1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi+1.0+ pT/80.0));\n\n\t// Next Disk:\n\tYi = Func(Xi-1.0 + 0.5);\n\tC = vec2(Xf+1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi-1.0+ pT/80.0));\n\n\treturn min(1.0, D);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Setup: Generate UV coordinate space to determine amount of zoom-in to properly frame the interesting bits.\n\tvec2 UV = 5.0*(fragCoord.xy - iResolution.xy/2.0) / min(iResolution.x, iResolution.y);\t\n\t\n\t// Start with background color\n\tvec3 Color= BackColor;\n\n    vec2 modUV;\n    modUV.x = UV.x;\n   \tmodUV.y = 1.2-abs(UV.y);//flip to outer edges\n    modUV.y *= 0.5+abs(cos(iTime)*0.25);// bring them together and mirror, add some bounce    \n    float vertGrad = min(modUV.y,  modUV.y+1.0);//define gradient func to control distortions\n    \n    //16-bit style sinewave scrollerwarp\n    float waveFreq_Y =39.0 * vertGrad + (15.*sin(iTime));\n    float waveFreq_X = 0.05;\n    float waveFreq_TimeScroll_Y = iTime * 15.0;\n    float waveBlend =12.0 * vertGrad*vertGrad*vertGrad;//global scale blend\n    modUV.x =  modUV.x + ( waveBlend *     (waveFreq_X * sin(vertGrad* waveFreq_Y + (waveFreq_TimeScroll_Y))) );\n    \n\tfor(float J=0.0; J<=1.0; J+=0.02)\n\t{\n        float scrollspeedScale = 2.0;\n\t\tfloat Lt =  scrollspeedScale * iTime*(3.5  + 2.0*J)*(1.0 + 0.1*sin(2.0*J)) + 17.0*J;\n        \n\t\tvec2 Lp = vec2(0.0, fract(J*0.99));        \n\t\tfloat L = Layer( modUV + Lp, Lt);\n\n\t\t// Blur and color:\n\t\tfloat Blur = 0.1*(0.5*abs(2.0 - 1.0*J))/(1.50 - 1.0*J);\n\t\t\n        // ccoffin: smoothstep to negative and outside 0-1 bounds to create extra stylized interactions to fake refract\n\t\tfloat V = mix( -0.05, 1.8950, 1.0 - smoothstep( -0.10, 0.01 +0.2*Blur, L ) );\n\t\tvec3 Lc=  mix( CloudColor, vec3(1.0), J);\n\n\t\tColor =mix(Color, Lc,  V);\n\t}\n\n    Color.rgb = Color.bgr;\n    Color.b = sat( Color.b );\n    Color.b += 0.95*abs(UV.y*UV.y);\n    \n    // Color.gbr = sin(Color.rgb*0.5);// alternate stylized sin palette\n    \n\tfragColor = vec4(Color, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}