{"ver":"0.1","info":{"id":"dtSXWy","date":"1676503245","viewed":399,"name":"Rollerball cam","username":"jonny_townend","description":"A pure accident whilst working on another shader! Move your camera around your surroundings to see the true effect in action","likes":5,"published":1,"flags":2,"usePreview":0,"tags":["ray","raymarch","lighting","webcam","march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERS 50\n#define MIN_DIST 0.003\n#define MAX_DIST 100.\n\n// SDFs\nfloat sSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sPlaneXY(vec3 p) {\n    vec3 col = texture(iChannel0, 0.1 * p.xy).xyz;\n    float val = (col.x + col.y + col.z) / 3.;\n    return p.z - val;\n}\n\nfloat sScene(vec3 p) {\n    p *= vec3(1., -1., 1.);\n    float x = (iMouse.x/iResolution.x);\n    float d = sPlaneXY(vec3(5.) - p);\n    d = smin(d, sSphere(p - vec3(0., 0., 2.), 0.4), 0.5);\n    return d;\n}\n\n// Ray casting\nstruct RayCast {\n    vec3 p;\n    float d;\n};\nRayCast getSurface(vec3 ro, vec3 rd) {\n    float d = 0.;\n    vec3 p = ro;\n    for(int i=0; i<MAX_ITERS; i++) {\n        p += d * rd;\n        d = sScene(p);\n        if (d < MIN_DIST) {\n            return RayCast(p, d);\n        }\n    }\n    return RayCast(p, MAX_DIST);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    vec3 val = vec3(\n        sScene(p + e.xyy) - sScene(p - e.xyy),\n        sScene(p + e.yxy) - sScene(p - e.yxy),\n        sScene(p + e.yyx) - sScene(p - e.yyx)\n    );\n    return normalize(val);\n}\n\n// Lighting\nfloat getHardShadow(vec3 p, vec3 lightPos) {\n    float e = 0.02;\n    float dist = length(p - lightPos);\n    vec3 ro = p + (e * getNormal(p));\n    vec3 rd = normalize(lightPos - p);\n    RayCast rayCast = getSurface(ro, rd);\n    return step(0., rayCast.d - dist);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float e = 0.01;\n    float dist = length(p - lightPos);\n    vec3 ro = p + (e * getNormal(p));\n    vec3 rd = normalize(lightPos - p);\n    RayCast rayCast = getSurface(ro, rd);\n    return smoothstep(rayCast.d - 10., MAX_DIST, rayCast.d - dist);\n}\n\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n};\n\nvec3 getLighting(vec3 p, vec3 n, vec3 i, Light light) {\n    float dist = length(p - light.pos);\n    vec3 normDiff = normalize(light.pos - p);\n    \n    // diffuse\n    float diffuse = dot(n, light.pos);\n    diffuse = map(diffuse, 0., 1., 0.2, 1.);\n    diffuse *= 1. / pow(dist, 2.);\n    diffuse = max(0., diffuse);\n    vec3 diffuseV = diffuse * light.col;\n   \n    // specular\n    float spec = dot(i, normDiff);\n    spec = 0.9 * smoothstep(0.99, 1., spec);\n    vec3 specular = spec * (light.col + vec3(0.8));\n    \n    // shadow\n    float e = 0.02;\n    vec3 ro = p + (e * n);\n    RayCast rayCast = getSurface(ro, normDiff);\n    float shadow = step(0., rayCast.d - e - dist);\n    shadow = map(shadow, 0., 1., 0.1, 1.);\n    \n    return shadow * (diffuseV + specular);\n}\n\nvec3 getSceneLighting(vec3 p, vec3 n) {\n    Light light1 = Light(\n        vec3(1.5*sin(iTime), 2., 0.5*cos(iTime)),\n        5. * vec3 (1., 0., 0.)\n    );\n    \n    Light light2 = Light(\n        vec3(-1.*sin(iTime), 2., -0.5*cos(iTime) - 1.),\n        4. * vec3 (0., 1., 0.)\n    );\n    \n    Light light3 = Light(\n        vec3(-1.5*sin(iTime), 2., 0.5*cos(iTime) + 1.),\n        2. * vec3 (0., 0., 1.)\n    );\n    \n    Light light4 = Light(\n        vec3(-5., 100., 10.),\n        100. * vec3(1., 0., 0.5)\n    );\n    \n    vec3 i = reflect(normalize(p), n);\n    \n    vec3 lighting = getLighting(p, n, i, light1);\n    lighting += getLighting(p, n, i, light2);\n    lighting += getLighting(p, n, i, light3);\n    lighting += getLighting(p, n, i, light4);\n    return lighting;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0., 0., -1);\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n    \n    vec3 p = getSurface(ro, rd).p;\n    vec3 n = getNormal(p);\n    \n    // Ambient lighting\n    vec3 col = 0.3 * vec3(0., 0.8, 1.);\n    \n    // Base lighting\n    col += getSceneLighting(p, n);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Helpers\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\t\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nvec2 normToPolar(vec3 n) {\n    float ro = acos(n.z / sqrt(\n        pow(n.x, 2.) + pow(n.y, 2.) + pow(n.z, 2.)\n    ));\n    float th = atan(n.y / n.z);\n    return vec2(ro, th);\n}","name":"Common","description":"","type":"common"}]}