{"ver":"0.1","info":{"id":"XsjfWy","date":"1502501162","viewed":242,"name":"Glissando","username":"yaz","description":"Shepard-Risset Glissando","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["sound","illusion","shepard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Period 15.\n// txt output https://www.shadertoy.com/view/MtyXRW\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\nfloat message(vec2 U){vec4 T = vec4(0);C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110);return length(T.yz)==0. ? -1. : T.x;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iResolution.y<2000.){float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n\tfragColor = vec4(fract(iTime / Period),0.0,0.0,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Author: Yaz Khabiri\n\n#define PI 3.14159265359\n\n// https://en.wikipedia.org/wiki/Chirp#Linear\nfloat linChirp(float time, float freqStart, float freqEnd, float sweepTime)\n{\n\tfloat k, sound;\n\tfloat phaseStart = 0.0;\n\n\tk = (freqEnd - freqStart) / sweepTime;\n\tsound = sin(phaseStart + 2.0 * PI * (freqStart * time + k / 2.0 * time * time));\n\n\t//sound *= clamp(sign(sweepTime - time), 0.0, 1.0);\n\n\treturn sound;\n}\n\n// https://en.wikipedia.org/wiki/Chirp#Exponential\nfloat expChirp(float time, float freqStart, float freqEnd, float sweepTime)\n{\n\tfloat k, sound;\n\tfloat phaseStart = 0.0;\n\n\tk = pow(freqEnd / freqStart, 1.0 / sweepTime);\n\tsound = sin(phaseStart + 2.0 * PI * freqStart * (pow(k, time) - 1.0) / log(k));\n\n\t//sound *= clamp(sign(sweepTime - time), 0.0, 1.0);\n\n\treturn sound;\n}\n\nfloat wav(float time, float freq)\n{\n\treturn sin(2.0*PI*freq*time);\n}\n\n// linear loop percent\nfloat fade(float intervalPercent)\n{\n\treturn exp(-pow(intervalPercent, 4.0) * 7.);\n    //return exp(-pow(intervalPercent, 4.0) * 11.);\n    //return exp(-pow(intervalPercent, 10.0) * 700.);\n}\n\n//float linShepard(float time, float f = 27.5, float sweepTime = 2.0)\nfloat linShepard(float time, float f, float sweepTime)\n{\n\tfloat sound = 0.0;\n\n\ttime = mod(time, sweepTime);\n\n\tfloat loopPercent = time / sweepTime;\n\n\tsound += (loopPercent)      * linChirp(time, f * 1., f * 2., sweepTime);\n\tsound +=                      linChirp(time, f * 2., f * 4., sweepTime);\n\tsound +=                      linChirp(time, f * 4., f * 8., sweepTime);\n\tsound +=                      linChirp(time, f * 8., f * 16., sweepTime);\n\tsound +=                      linChirp(time, f * 16., f * 32., sweepTime);\n\tsound +=                      linChirp(time, f * 32., f * 64., sweepTime);\n\tsound +=                      linChirp(time, f * 64., f * 128., sweepTime);\n\tsound += (1. - loopPercent) * linChirp(time, f * 128., f * 256., sweepTime);\n\n    float num_octaves = 8.;\n    sound *= 1. / num_octaves;\n    \n\treturn sound;\n}\n\nfloat envelope( float time, float octave )\n{\n    //return 1.;\n    //return -0.5 * cos( 2. * PI * (time+octave) / 8. ) + 0.5;\n    return -0.125 * cos( 2. * PI * (time+octave) / 8. ) + 0.5;\n}\n\nfloat expShepard(float time, float f1, float sweepTime)\n{\n\tfloat sound = 0.0;\n    float f2 = f1 * 2.; // next octave\n\n\ttime = mod(time, sweepTime);\n\n\tfloat intervalPercent = time / sweepTime;\n\n\t// old method, doubling frequency, time = time % sweepTime\n\t// f*1 -> f*2 + f*2 -> f*4, etc\n\n\t// new method, float sweepTime, use same freq range\n\t// better because there is no continuity issue (phase) between intervals\n\t// fade top and bottom frequencies\n\n\tsound += envelope(intervalPercent, 0.) * (1. - fade(intervalPercent)) *\texpChirp(time + sweepTime * 0., f1, f2, sweepTime);\n\tsound += envelope(intervalPercent, 1.) *\t\t\t\t\t\t\t\texpChirp(time + sweepTime * 1., f1, f2, sweepTime);\n\tsound += envelope(intervalPercent, 2.) *\t\t\t\t\t\t\t\texpChirp(time + sweepTime * 2., f1, f2, sweepTime);\n\tsound += envelope(intervalPercent, 3.) *\t\t\t\t\t\t\t\texpChirp(time + sweepTime * 3., f1, f2, sweepTime);\n\tsound += envelope(intervalPercent, 4.) *\t\t\t\t\t\t\t\texpChirp(time + sweepTime * 4., f1, f2, sweepTime);\n\tsound += envelope(intervalPercent, 5.) *\t\t\t\t\t\t\t\texpChirp(time + sweepTime * 5., f1, f2, sweepTime);\n\tsound += envelope(intervalPercent, 6.) *\t\t\t\t\t\t\t\texpChirp(time + sweepTime * 6., f1, f2, sweepTime);\n\tsound += envelope(intervalPercent, 7.) * fade(intervalPercent) *\t\texpChirp(time + sweepTime * 7., f1, f2, sweepTime);\n\n    float num_octaves = 8.;\n\tsound *= 1. / num_octaves;\n\n\treturn sound;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float sound = 0.;\n    \n    //sound += linShepard(time, 27.5, 15.0);\n    sound += expShepard(time, 27.5, 15.0);\n\n\treturn vec2(sound);\n}","name":"Sound","description":"","type":"sound"}]}