{"ver":"0.1","info":{"id":"wdSGRG","date":"1549137291","viewed":2979,"name":"kifs icosahedron","username":"macbooktall","description":"Use the mouse :)\nAnimating the surface by applying a smooth minimum to itself (wrt pos) around a 0.0 k param value. This gives it a scaling animation.","likes":81,"published":1,"flags":32,"usePreview":0,"tags":["icosahedron","smin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uuv = uv * 2.0 - 1.0;\n    vec3 c = texture(iChannel0, uv).rgb;\n    vec4 col = vec4(pow(c, vec3(0.5)), 1.0);\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define GIFLENGTH 3.14159\nfloat clock;\n\n// HG_SDF\n// Brought to you by MERCURY http://mercury.sexy\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fIcosahedron(vec3 p, float r) {\nfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nvoid pR(inout vec2 p, float a) {\np = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// end HG_SDF\n//----------------------------------------------------------------------\n\n\n// smin by iq - https://iquilezles.org/articles/smin\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// --\n\nvec2 mousePos;\n\nfloat map(vec3 pos) {\n    \n    float scale = .55;\n    vec3 spacesize = vec3(3.,4.,2.2);\n    float distFromCam = length(pos)*0.4;\n\tvec3 originalPos = pos;\n\n    // Divide the space into cells\n    pos.xyz = mod(pos.xyz, spacesize) - spacesize*0.5;\n\n    vec3 p = pos;\n\tvec2 mouse = vec2(0.7, 1.05) + mousePos;\n\n    float cube = 1e20;\n    float res = cube;\n    vec3 displacement = vec3(-1., -.5, -2.)*0.75;\n\n    for (int i = 0; i < 8; i++) {\n        p.xyz = abs(p.xyz);\n\n        float phase = clock+float(i)*0.25+distFromCam*2.;\n        vec2 dispAnim = vec2( sin(phase), cos(phase))*0.025; \n\n        displacement.yz += dispAnim;\n        \n        p += displacement * scale;\n\n        phase = clock+float(i)*0.5 + distFromCam;\n        pR(p.xz,-distFromCam+mouse.y+float(i)+sin(phase)*.05);\n        pR(p.zy,distFromCam+mouse.x+float(i)+cos(phase)*.075);  \n   \n\t\tscale *= 0.6;\n        \n        float octa = fIcosahedron(p,scale);\n      \n        res = min(res,octa);    \n    }\n\n    // Animate the pos of the icosahedron\n\toriginalPos.y += cos(length(pos.xz)*4.+clock)*0.015;\n\toriginalPos+=vec3(1.5,1.1,-1.2);\n    pR(originalPos.xy, .2+sin(clock)*0.2);\n    pR(originalPos.xz,-iTime);\n    \n    // Smooth min blend the fractal terrain with itself with a param around zero to give it a scaling effect\n    res = smin(res, res, -0.025+ sin(-0.5+clock-length(vec3(pos.x*0.5,pos.y*0.9,pos.z))*12.)*0.05);\n    res = smin(res, fIcosahedron(originalPos,.2), 0.1);\n\n    return res;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float t = 0.;\n    \n    for( int i=0; i<50; i++ )\n    {\n   \t\tfloat res = map( ro+rd*t );\n   \t\tif (res < 0.001)\n            break;\n    \tt += res;\n        if (t > 5.)\n            break;\n    }\n\n    return t;\n}\n\n// by iq - https://www.shadertoy.com/view/Xds3zN\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(map(pos+eps.xyy) - map(pos-eps.xyy),\n        \t\t\tmap(pos+eps.yxy) - map(pos-eps.yxy),\n        \t\t\tmap(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float hr = 0.01 + 0.02*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// -----------------------------\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.);\n    float res = castRay(ro,rd);\n    vec3 pos = ro + res*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n    float occ = calcAO( pos, nor )*2.5;\n\n    col = vec3(.75+dot(rd,nor));\n    nor.b = .1-nor.b;\n    nor.g = 0.;\n    col *= (nor.rgb*0.5+0.5) ;\n\t\n\tcol = mix(col, vec3(0.), clamp(res/4., 0., 1.));\n    return vec4( clamp(col,0.0,1.0), res );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    clock = iTime*2.;\n    mousePos = 2.*iMouse.xy/iResolution.xy;\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(-0.2, -.75, .5);\n    vec3 ta = ro+vec3(-1.8,-.5,1.);\n    mat3 ca = setCamera( ro, ta, .0 );\n    vec3 rd = ca * normalize(vec3(p.xy,3.6));\n    vec4 col = render( ro, rd );\n\n    fragColor=col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer does some bokeh based on the alpha channel of buffer A which is the distance of the surface from the pixel.\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 base = vec3(0.);\n    \n    // Gaussian blur by mrharicot https://www.shadertoy.com/view/XdfGDH\n    \n    //declare stuff\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\tfloat depth = texture(iChannel0, uv).a;\n    \n    //create the 1-D kernel\n    float sigma = mix(0.05, 4., max(0., -1. + depth*depth*0.1));\n    float Z = .0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            base += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n        }\n    }\n   \tvec4 b = vec4(base/(Z*Z), 1.0);\n\n    fragColor = b;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// subtle feedback loop: blend the last frame with the current one\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n    vec3 s = step(0.5,blend);\n    return s * (sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend)) + (1.-s)*(2.*base*blend+base*base*(1.0-2.0*blend));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 base = texture(iChannel0, uv).rgb;\n    vec3 overlay = texture(iChannel1, uv).rgb;\n    vec4 col = vec4(base +(blendSoftLight(base, overlay)), 1.0);\n    \n    fragColor = col;\n}","name":"Buffer C","description":"","type":"buffer"}]}