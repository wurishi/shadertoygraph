{"ver":"0.1","info":{"id":"NtGfWm","date":"1664578651","viewed":230,"name":"penrose-3","username":"DjinnKahn","description":"penrose \"kites and darts\". Based on https://en.wikipedia.org/wiki/Penrose_tiling#Deflation_for_P2_and_P3_tilings\n\nI found a simple way to find the \"innerness\"/winding of a section.\n\nSetting NUM_ITERATIONS = 15 shows an interesting pentagrid structure.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["penrose"],"hasliked":0,"parentid":"7tyfWW","parentname":"penrose-2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int NUM_ITERATIONS = 9;\n\nconst float PI = 3.1415926;\nconst float PHI = (1. + sqrt( 5. )) / 2.;\nconst vec2 A = vec2( cos( 36./180.*PI ), sin( 36./180.*PI ) );\nconst vec2 B = vec2( A.x*2. - 1., 0. );\nconst vec2 C = A / (PHI * PHI);\nconst vec2 O = vec2( 0. );\nconst vec2 D = vec2( 1., 0. );\nconst vec2 E = A / (PHI);\n\nconst int HALF_KITE = 0;\nconst int HALF_DART = 1;\n\n\n\nbool isClockwise( vec2 a, vec2 b, vec2 c )\n{\n    b -= a;\n    c -= a;\n    return b.x * c.y < c.x * b.y;\n}\n\nmat3x2 map( vec2 a, vec2 b, vec2 c, vec2 newA, vec2 newB, vec2 newC )\n{\n    return mat3x2( newA-newC, newB-newC, newC ) \n         * inverse( mat3x3( vec3( a-c, 0. ), vec3( b-c, 0. ), vec3( c, 1. ) ) );\n}\n\nfloat distToLine( vec2 p, vec2 a0, vec2 a1 )\n{\n    a1 -= a0;\n    p -= a0;\n    vec2 n = normalize( vec2( a1.y, -a1.x ) );\n    return dot( p, n );\n}\n\nvec2 getGeometry( vec2 p, int depth, out int type, out int innerness )\n{\n    type = HALF_KITE;\n\n    innerness = 0;\n              \n    for ( int i = 0; i < depth; i++ )\n    {\n        if ( type == HALF_KITE )\n        {        \n            if ( isClockwise( C, B, p ) ) { type = HALF_DART; p *= PHI; }\n            else if ( isClockwise( B, A, p ) ) { type = HALF_KITE; p = map(B,A,D, D,O,A) * vec3(p,1.); }\n            else { type = HALF_KITE; p = map(B,A,C, D,O,A) * vec3(p,1.); }\n        }\n        else\n        {   \n            innerness += (i & 1) == 1 ? -1 : 1;\n            if ( isClockwise( E, B, p ) ) { type = HALF_KITE; p = map(E,O,B, D,O,A) * vec3(p,1.); }\n            else { type = HALF_DART; p = map(B,E,D, E,D,O) * vec3(p,1.); }\n        }\n    }\n    \n    return p;\n}\n\nfloat distToEdge( vec2 p, int type )\n{\n    if ( type == 0 )\n        return min( distToLine( p, O, A ), distToLine( p, A, D ) );\n    else\n        return min( distToLine( p, D, O ), distToLine( p, E, D ) );\n}\n\nvec3 getColor( vec2 p, int type, int innerness )\n{\n    vec3 color = vec3(0.);\n    \n    //color.r = type == 0 ? .1 : .4;\n    color.rgb += smoothstep( .05, .01, distToEdge( p, type ) ) * .1;\n    \n    //const float LINE_OFFSET = .6;\n    float LINE_OFFSET = sin(iTime*.5) + .5;\n    int extraInnerness = 0;\n    if ( type == HALF_KITE && length( p ) < LINE_OFFSET ) extraInnerness--;\n    if ( type == HALF_DART && length( p ) < 1. - LINE_OFFSET ) extraInnerness++;\n    innerness += ((NUM_ITERATIONS & 1) == 0) ? extraInnerness : -extraInnerness;\n    \n    color.rgb += float( innerness ) * .1 + .5;\n    \n    //if ( type == 0 )\n    //    color.rgb += smoothstep( .05, .01, abs( length( p ) - LINE_OFFSET ) );\n    //if ( type == 1 )\n    //    color.rgb += smoothstep( .05, .01, abs( length( p ) - (1. - LINE_OFFSET) ) );\n    //\n    //\n    //float LINE_OFFSET2 = 1. - LINE_OFFSET;\n    //if ( type == 0 )\n    //    color.rb += smoothstep( .03, .01, abs( distance( p, D ) - LINE_OFFSET2 ) );\n    //if ( type == 1 )\n    //    color.rb += smoothstep( .03, .01, abs( distance( p, E ) - (1./PHI-LINE_OFFSET2) ) );\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    p /= 3.; // zoom into triangle\n    p += vec2( 1.9, .6 );\n    p /= 3.;\n\n    vec3 col = vec3( length(p) );    \n    \n    fragColor = vec4( 0. );\n    if ( isClockwise( vec2( 0, 0 ), A, p ) && isClockwise( A, vec2( 1, 0 ), p ) && p.y > 0. )    \n    {\n        int type;\n        int innerness;\n        vec2 q = getGeometry( p, NUM_ITERATIONS, type, innerness );         \n        fragColor.rgb += getColor( q, type, innerness );\n    }\n}","name":"Image","description":"","type":"image"}]}