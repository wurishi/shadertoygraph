{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define EPS 0.000001\n\nbool point_is_to_the_right_of_line(in vec2 p, in vec2 p0, in vec2 p1) {\n    float cross = (p1.x - p0.x) * (p.y - p0.y) - (p1.y - p0.y) * (p.x - p0.x);\n    return cross <= 0.0;\n}\n\nbvec3 implicit_test(in vec2 p, in vec2 p0, in vec2 p1) {\n    bool is_in_bounds = (p.y > min(p0.y, p1.y)) && (p.y <= max(p0.y, p1.y));\n    bool is_horizontal = abs(p0.y - p1.y) < EPS;\n    bool is_upwards = p1.y > p0.y;\n    vec2 start = (p0.y > p1.y) ? p1 : p0;\n    vec2 end = (p0.y > p1.y) ? p0 : p1;\n    bool is_to_the_right = !is_horizontal && point_is_to_the_right_of_line(p, start, end);\n    \n    return bvec3(is_to_the_right, is_upwards, is_in_bounds);\n}\n\n\nvec3 point_is_inside_triangle(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 v2_v1 = v2 - v1;\n    vec2 v3_v1 = v3 - v1;\n    vec2 p_v1 = p - v1;\n    \n    float d00 = dot(v2_v1, v2_v1);\n    float d01 = dot(v2_v1, v3_v1);\n    float d02 = dot(v2_v1, p_v1);\n    float d11 = dot(v3_v1, v3_v1);\n    float d12 = dot(v3_v1, p_v1);\n    \n    float inv_denom = 1.0 / (d00 * d11 - d01 * d01);\n    float u = (d11 * d02 - d01 * d12) * inv_denom;\n    float v = (d00 * d12 - d01 * d02) * inv_denom;\n    float uv = 1.0 - u - v;\n    \n    return vec3(float(u >= 0.0 && v >= 0.0 && uv >= 0.0), u, v);\n}\n\nfloat get_winding_for_quadratic(in vec2 uv, in vec2 p0, in vec2 p1, in vec2 p2) {\n    float winding = 0.0;\n\n    vec3 bary = point_is_inside_triangle(uv, p0, p1, p2);\n    float u2v = bary.y * 0.5 + bary.z;\n    bool is_inside_triangle = bary.x > 0.0;\n    bool is_inside_quadratic = u2v * u2v < bary.z;\n    bvec3 leak = implicit_test(uv, p0, p2);\n    bvec3 fst = implicit_test(uv, p0, p1);\n    bvec3 snd = implicit_test(uv, p1, p2);\n    bool fttr = fst.z && fst.x;\n    bool sttr = snd.z && snd.x;\n    bool lttr = leak.z && leak.x;\n    float fw = fst.y ? 1.0 : -1.0;\n    float sw = snd.y ? 1.0 : -1.0;\n    float lw = leak.y ? 1.0 : -1.0;\n\n    vec4 cnd = vec4(\n        float(is_inside_triangle && is_inside_quadratic && fttr),\n        float(is_inside_triangle && is_inside_quadratic && sttr),\n        float(is_inside_triangle && !is_inside_quadratic && lttr),\n        float(!is_inside_triangle && lttr)\n    );\n\n    // if (cnd.x) { fw } else if (cnd.y) { sw } else if (cnd.z) { lw } else if (cnd.w) { lw } else { 0 }\n    winding += mix(mix(mix(mix(\n            0.0, lw, cnd.w\n          ), lw, cnd.z\n        ), sw, cnd.y\n      ), fw, cnd.x\n    );\n\n    return winding;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n\tvec2 v0 = vec2(0.9, 0.9) * cos(iTime * 0.5 + vec2(0.0, 5.0));\n    vec2 v1 = vec2(0.9, 0.9) * cos(iTime * 0.6 + vec2(3.0, 4.0));\n    vec2 v2 = vec2(0.9, 0.9) * cos(iTime * 0.7 + vec2(2.0, 0.0));\n\n    vec2 p0 = (v0 + 1.0) * 0.5;\n    vec2 p1 = (v1 + 1.0) * 0.5;\n    vec2 p2 = (v2 + 1.0) * 0.5;\n\n    float winding = get_winding_for_quadratic(uv, p0, p1, p2);\n    float inside = float(winding != 0.0);\n\n    vec4 src_color = vec4(1.0, 0.0, 0.0, 1.0) * inside;\n    vec4 dst_color = vec4(1.0);\n\n    // Output to screen\n    fragColor = mix(dst_color, src_color, inside);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcGfD3","date":"1734545537","viewed":66,"name":"Quadratic Bézier Non-Zero","username":"vg_head","description":"This is an example where we perform the inside/outside test for a quadratic Bézier curve with non-zero winding, with rays being interpreted as passing from left to right horizontally. This builds on top of the core of the Loop-Blinn method.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["2d","bezier","vector","rasterization","fonts"],"hasliked":0,"parentid":"","parentname":""}}