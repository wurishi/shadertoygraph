{"ver":"0.1","info":{"id":"wlXBD8","date":"1596581634","viewed":212,"name":"voxel traversal","username":"HalbFettKaese","description":"voxel traversal","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voxeltraversal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HALFPI 1.5707963267948966192313216916398\n\nfloat GridLines(vec2 uv, float oneP) {\n\tvec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    // Time varying pixel color\n    float col = 1.;\n    \n    if (fr.x <= oneP) {\n        if (mod(fl.x, 5.) == 0.) {\n        \treturn .25;\n        }\n        else {\n        \tcol = .75;\n        }\n    }\n    if (fr.y <= oneP) {\n        if (mod(fl.y, 5.) == 0.) {\n        \treturn .25;\n        }\n        else {\n        \tcol = .75;\n        }\n    }\n    return col;\n}\n\nstruct Ray {\n\tvec2 dir;\n    vec2 start;\n    float len;\n};\n\nfloat Line(vec2 uv, float oneP, Ray ray) {\n    \n    return smoothstep(oneP, 0., \n                     \tdistance(\n                            ray.dir * \n                            \tmax(\n                                    0., min(\n                                    dot(uv - ray.start, ray.dir), \n                                    ray.len)), \n                            uv - ray.start)\n                     );\n}\n\nbool Traverse(vec2 uv, Ray ray) {\n    \n    // The length of one square in transformed space\n    vec2 l = abs(1./ray.dir);\n    \n    // The position at which the ray starts\n    vec2 pos = ray.start;\n    \n    vec2 a = vec2(1.);\n    \n    if (sign(ray.dir.x) != -1.) a.x = -1.; \n    if (sign(ray.dir.y) != -1.) a.y = -1.;\n    \n    vec2 t = (vec2(a*-.5+.5)+a*fract(ray.start)) / abs(ray.dir);\n    \n    for (float i = 0.; i < 2. + ray.len*sqrt(2.) && // for loop for safety\n         distance(pos, ray.start) < ray.len; i++) { // distance is actual condition\n        \n        if (floor(uv) == floor(pos)) return true;\n            \n        if (t.x < t.y) {\n            t.x += l.x;\n        \tpos.x += sign(ray.dir.x);\n        } else {\n            t.y += l.y;\n        \tpos.y += sign(ray.dir.y);\n        }\n    }\n    \n\treturn distance(pos, ray.start) < ray.len;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.xx;\n    \n    // Normalized mouse coordinates (from -.5 to .5)\n    vec4 M = (vec4(iMouse.xy, iMouse.zw * sign(iMouse.zw)) - iResolution.xyxy/2.)/iResolution.xxxx;\n    \n    // The visual zoom\n    float zoom = 40.;\n    \n    uv *= zoom;\n    M *= zoom;\n    \n    vec2 start = M.zw;\n    \n    // The direction of the line. Must be normalized\n    vec2 dir = normalize(M.xy - start);\n    \n    // The size of one pixel\n    float oneP = zoom/iResolution.y;\n    \n    \n    Ray ray = Ray(dir, start, distance(M.xy, M.zw));\n\n    vec3 col = vec3(GridLines(uv, oneP));\n    \n    col = mix(col, vec3(0, 0, 1), Line(uv, 2.*oneP, ray));\n    \n    if (Traverse(uv, ray)) {\n    \tcol = mix(col, vec3(1, 0, 0), .5);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}