{"ver":"0.1","info":{"id":"7dtGR8","date":"1629312821","viewed":348,"name":"Classical black hole raytracer","username":"copperbotte","description":"This simulates a black hole as if it was an entirely classical effect, if light had mass. Also has light fall downwards due to a very weak gravity.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["raytracing","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n//color space transforms\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//events are in the form of (x,y,z,t) for ease of programming.\nconst float c = 1.0; //c is merely a scaling factor for r anyway, so using natural units haha\n\nmat4 trace(vec4 tr)\n{\n    mat4 m = mat4(0.0);\n    for(int n=0; n<4; ++n)\n        m[n][n] = tr[n];\n    return m;\n}\n\nvec4 toPolar(vec4 event)\n{\n    vec3 x = event.xzy;\n    float r = length(x);\n    float xyr = length(x.xy);\n    float theta = acos(x.z/xyr);\n    float psi = atan(x.y, x.x);\n    return vec4(r, theta, psi, event.w);\n}\n\nvec4 toEuclid(vec4 p_event)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    \n    float x = r*sin(theta)*cos(psi);\n    float y = r*sin(theta)*sin(psi);\n    float z = r*cos(theta);\n    \n    return vec4(x, z, y, p_event.w);\n}\n\n//calculates the schwarzchild metric for a given 3-vector r measured from an observing coordinate frame.\n//inputs a minkowski event x, and a schwartzchild radius r. \n//returns a 4x4 minkowski metric.\nmat4 schwarzschildMetric(vec4 x, float r)\n{\n    float k = 1.0 - r / length(x.xyz);  \n    \n    vec2 tr = vec2(-k, 1.0/k);\n    //rotate this into minkowski coordinates to eliminate pole problems\n    \n    //for now, rotate coodinate into spherical polar coodinates\n    vec4 rtp_ct = toPolar(x);\n    \n    return mat4(1.0);    \n}\n\n\nmat4 p_schwarzschildMetric(vec4 rtp_ct, float r)\n{\n    float k = 1.0 - r / rtp_ct.x;\n    float r2 = rtp_ct.x * rtp_ct.x;\n    \n    vec4 tr = vec4(1.0/k, r2, r2*sin(rtp_ct.y), -k);\n    mat4 metric = trace(tr);\n    return metric;\n}\n\nbool hitPlane(vec3 p0, vec3 p1, vec3 normal, float offset, out vec3 hit)\n{\n    float d0 = dot(p0, normal) - offset;\n    float d1 = dot(p1, normal) - offset;\n    if(sign(d0) == sign(d1))\n        return false;\n\n    //intermediate value theorem\n    float s = (offset-d0) / (d1-d0);\n    vec3 dp = p1 - p0;\n    hit = dp*s + p0;\n    return true;\n}\n\nbool hitAccrete(vec3 p0, vec3 p1, out vec3 hit)\n{\n    //find if p0 and p1 lie on opposite sides of the xy plane\n    \n    float theta = 3.141592 / 4.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    \n    vec3 x0 = vec3(0,-0.1,0);\n    \n    vec3 normal = normalize(vec3(0,0,1));\n    normal = rotate * normal;\n    vec3 s_hit;\n    if(!hitPlane(p0-x0, p1-x0, normal, 0.0, s_hit))\n        return false;\n    \n    float lh = length(s_hit);\n    if(lh < 0.5 || 1.0 < lh)\n        return false;\n    \n    hit = s_hit;\n    return true;\n}\n\nbool hitFloor(vec3 p0, vec3 p1, out vec3 hit)\n{\n    //find if p0 and p1 lie on opposite sides of the xy plane\n    vec3 x0 = vec3(0,-0.25,0);\n    //x0.y = sin(iTime * 3.141592 / 5.0);\n    vec3 normal = normalize(vec3(0,1,0));\n    \n    vec3 s_hit;\n    if(!hitPlane(p0, p1, normal, dot(normal, x0), s_hit))\n        return false;\n    \n    float planesize = 40000.0;\n    \n    if(planesize < abs(s_hit.x) || planesize < abs(s_hit.z))\n        return false;\n     \n    hit = s_hit;\n    return true;\n}\n\nvec3 colorAccrete(vec3 hit)\n{\n    float theta = 3.141592 / 4.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    hit = rotate * hit;\n\n    float angle = atan(hit.z, hit.x);\n    angle /= 3.141592;\n    angle *= 4.0;\n    bool color = 0.5 < angle - floor(angle);\n    float radius = length(hit.xz);\n    radius = (radius - 0.5)/(1.0 - 0.5);\n    radius *= 1.0;\n    color = color != (0.5 < radius - floor(radius));\n    \n    if(color)\n        return vec3(0.75,0.75,0.75);\n    else\n        return vec3(0.25,0.25,0.25);\n}\n\nvec3 colorPlane(vec3 hit)\n{\n    //vec2 pos = hit.xz / 2.0;\n    //vec2 pos = hit.xz * 4.0;\n\n    //bool color = 0.5 < mod(pos.x, 1.0);\n    //color = color != 0.5 < mod(pos.y, 1.0);\n    \n    //if(color)\n    //    return vec3(0.75,0.25,0.25);\n    //else\n    //    return vec3(0.25,0.0625,0.0625);\n    \n    vec2 pos = hit.xz / 8.0;\n    vec2 t_uv = mod(pos, 1.0);\n    ivec2 xor = ivec2(t_uv * 256.0);\n    float c = float(xor.x ^ xor.y) / 256.0;\n    \n    vec3 highColor = vec3(0.75,0.25,0.25);\n    vec3 lowColor = highColor * 0.25;\n    \n    return mix(lowColor, highColor, c);\n}\n\nvec3 render( in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    //uv /= 5.0;\n    \n    //view rotation matrix\n    //yaw\n    float theta = 3.141592 * iTime / (2.0 * 5.0);\n    //theta = 0.0;\n    mat3 yaw = mat3(vec3(cos(theta), 0.0, -sin(theta)),\n                       vec3(0.0, 1.0, 0.0),\n                       vec3(sin(theta), 0.0, cos(theta)));\n                       \n    //pitch\n    theta = 3.141592 * (0.25 / 2.0);\n    //theta = 0.0;\n    theta = 0.1;\n    mat3 pitch = mat3(vec3(1.0, 0.0, 0.0),\n                      vec3(0.0, cos(theta), sin(theta)),\n                      vec3(0.0,-sin(theta), cos(theta)));\n    \n    mat3 view = yaw * pitch;\n    \n    vec3 dir = normalize(vec3(uv.xy, 1.0));\n    vec3 src = vec3(0.0, 0.0, -10.0);\n    \n    dir = view * dir;\n    src = view * src;\n    //src += dir;\n    \n    vec4 src_t = vec4(src, length(src));\n    \n    //vec4 p_src = toPolar(vec4(src, 0.0));\n    \n    //return vec3(abs(p_src.yz), 0.0);\n    //GR Step\n    \n    //vec4 e_src = toEuclidean(p_src);\n    float R = length(src_t.xyz);\n    float kp = 1.0 + 1.0/(4.0*R);\n    float kn = 1.0 - 1.0/(4.0*R);\n    \n    float sp = kp*kp*kp*kp;\n    float st = -(kn*kn)/(kp*kp);\n    \n    mat4x4 metric = trace(vec4(sp, sp, sp, st));\n    \n    vec3 col = texture(iChannel0, dir).xyz;\n    \n    float mass = 0.25;\n    //mass = sin(iTime * 3.141592 / 10.0);\n    \n    if(true)\n    {\n    \n    //\"classical\" relativity\n    float m = 1.0;\n    float s0 = 1.0;\n    vec3 vel = dir*s0;\n    \n    vec3 src0 = src;\n    \n    for(int i=0; i<2560; ++i)\n    {\n        float dt = 0.01;\n        dt = dot(src, src); //based on distance to save on resources\n        dt /= 500.0; \n        dt = max(0.01, dt);\n        vec3 force = -mass * normalize(src) / dot(src, src);\n        //force *= 0.25;\n        //force *= -1.0;\n\n        //as if light had mass, effected by earth\n        //force += 0.001*m*9.807*vec3(0,-1,0);\n\n        //force *= 0.0;\n        \n        \n        vel += force * dt;\n        \n        src0 = src;\n        src += vel * dt;\n        \n        col = texture(iChannel0, vel).xyz;\n        \n        if(10000.0 < length(src))\n            return col;\n        \n        if(length(src) < mass * 0.2 / 0.25) // this is an artistically tuned value haha\n            return vec3(0,0,0);\n            \n        if(hitFloor(src0, src, src0))\n            return colorPlane(src0);\n            \n        if(hitAccrete(src0, src, src0))\n            return colorAccrete(src0);\n    }\n    \n    if(length(src) < 1.0)\n        return vec3(0,0,0);\n    \n    dir = normalize(vel);\n    \n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 col = render(fragCoord);\n    vec3 col = vec3(0.0);\n    \n    bool AntiAlias = true;\n    if(AntiAlias)\n    {\n        const int samples = 4;\n        for(int i=0; i<samples; ++i)\n            col += srgb2lsrgb(render(fragCoord + ((vec2(rnd(), rnd())-0.5))));\n        //for(int i=0; i<4; ++i)\n        //    for(int j=0; j<4; ++j)\n        //        col += srgb2lsrgb(render(fragCoord + ((vec2(i, j)-1.0) / 4.0)));\n        col /= float(samples);\n    }else{\n        col = render(fragCoord);\n    }\n    \n    fragColor = vec4(lsrgb2srgb(col),1.0);\n}","name":"Image","description":"","type":"image"}]}