{"ver":"0.1","info":{"id":"3stfzB","date":"1605552166","viewed":814,"name":"Cloud Fairies (sound)","username":"athibaul","description":"Playing with 2D clouds. I'd like to find a nice formula with as few fbm evaluations as possible, that should also be physically motivated. This is not it. Also, some fm synthesis.","likes":42,"published":1,"flags":8,"usePreview":0,"tags":["2d","clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simplified lighting of clouds\n\n// Iterating on the ideas I used for \"Fishermen at sea\" and \"Distress Flare\"\n// https://www.shadertoy.com/view/tdKcWD\n// https://www.shadertoy.com/view/3dGyRc\n\n// They were in turn inspired by \"Clouds\" by iq,\n// who uses a non-physical lighting where light intensity\n// is a function of the density difference between the current\n// point and a point further toward the source.\n// https://www.shadertoy.com/view/XslGRr\n\n#define R(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//#define T(p) smoothstep(0.,1.,textureLod(iChannel0,(p)/256.,0.).r)\n#define T(p) textureLod(iChannel0,(p)/256.,0.).r\n\nfloat fbm(vec2 p)\n{\n    p += T(p.yx*5. + iTime*0.1)*0.1;\n    return T(p)/2. + T(p*2.)/4. + T(p*4.)/8. + T(p*8.)/16. + T(p*16.)/32. + T(p*32.)/64.;\n}\n\n\nfloat density(vec2 p) \n{\n    return smoothstep(0.2,0.8,fbm(p-0.1*iTime))*3.;\n}\n\n\nfloat light(vec2 p, vec3 source)\n{\n    float dist = length(source - vec3(p,0));\n    float dist2D = length(source.xy-p);\n    //float lerpFactor = 1.0/dist;\n    float T = 1.; // Integrate transmittance along the trajectory\n    float d1 = density(p);\n    float STEPS = 3.;\n    float MAXL = 0.25;\n    for(float lerpFactor = 0.; lerpFactor<MAXL; lerpFactor+=MAXL/STEPS)\n    {\n        vec2 q = mix(p, source.xy, lerpFactor);\n        float d2 = density(q);\n        //T *= exp(-d2 * 0.1 * dist2D*exp(-lerpFactor*10.)*10.);\n        // Approximate version. Cheaper?\n        T /= 1.0 + d2/STEPS*dist2D*exp(-lerpFactor*10.)*10.;\n    }\n    return d1*T/(dist*dist);\n}\n\n\nvoid mainImage( out vec4 o, in vec2 u )\n{\n    vec2 p = (u*2.-iResolution.xy)/iResolution.y;\n\n    #if 1\n    // Camera motion inspired from Shane's shaders\n    // \"Precalculated Voronoi Heightmap\" by Shane\n    // https://www.shadertoy.com/view/ldtGWj\n    p *= 2.;\n    p.xy *= R(cos(0.32*iTime)+sin(0.1*iTime));\n    p.x -= iTime*2.;\n    p.y -= cos(iTime);\n    vec3 source = vec3(-iTime*2.+sin(iTime*0.62)*1.62,cos(iTime*2.0)*0.5,2.5 + cos(iTime*0.4));\n    vec3 source2 = vec3(-iTime*2.+cos(iTime),sin(iTime*1.62)*0.62,2.5 + sin(iTime));\n    #else\n    p *= 2.;\n    vec3 source = vec3(cos(iTime),sin(iTime*0.62),2.5);\n    #endif\n    \n    //vec3 col = vec3(fbm(p * 2.));\n    \n    vec3 col = light(p, source) * vec3(8.,3.,1.);\n    col += light(p, source2) * vec3(1.,6.,8.);\n    \n    #if 1\n    col = 1.-exp(-col);\n    #else\n    // ACES tone mapping\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Used in https://www.shadertoy.com/view/ts3Bz7\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n    #endif\n\n    // Output to screen\n    o = vec4(pow(col,vec3(0.45)),1.0);\n    o.rgb += (texture(iChannel0, u / iChannelResolution[0].xy + iTime).r * 2. - 1.) * .01;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n#define msin(x) sin(mod((x),1.)*2.*3.1415926)\n#define cos2(x) cos(x)*cos(x)\n\nfloat fm(float time, float f1, float f2, float idx)\n{\n    return msin(f1*time+idx*msin(f2*time));\n}\n\nfloat stringPad(float time, float f)\n{\n    float t = mod(time, 3.1415926);\n    float vib = 0.3*t*sin(5.*6.3*t);\n    float snd = 0.;\n    snd += fm(t, f+0.2*vib, f, 0.2+0.02*vib) * (0.1+0.01*vib) * (1.-cos2(t));\n    t = mod(time*0.5-0.5*3.1416, 3.1416);\n    vib = 0.3*t*sin(5.*6.3*t);\n    snd += fm(t, f*2.+0.1*vib, f*2., 0.2+0.02*vib) * (0.1+0.01*vib) * (1.-cos2(t));\n    return snd;\n}\n\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 snd = vec2(0);\n    \n    // Marimba\n    #if 1\n    {\n    \tfloat t = mod(time, 0.5);\n    \tsnd += fm(t, 440., 5000., 0.1*exp(-t*50.)) * 0.1 * exp(-t*10.) * cos2(0.3*time);\n    \tt = mod(time-0.1, 0.62);\n    \tsnd += fm(t, 220., 3000., 0.1*exp(-t*50.)) * 0.1 * exp(-t*5.) * (1.-cos2(0.5*time));\n    \tt = mod(time-0.2, 0.89);\n        snd += fm(t, 528., 4000., 0.1*exp(-t*50.)) * 0.05 * exp(-t*10.) * cos2(0.6*time);\n        t = mod(time-0.35, 1.62);\n        snd += fm(t, 586.7, 5500., 0.05*exp(-t*50.)) * 0.05 * exp(-t*10.) * (1.-cos2(time));\n    }\n    #endif\n    \n    // String pad\n    #if 1\n    {\n        snd += stringPad(time, 440.) * 0.3;\n        snd += stringPad(time*0.5, 440.);\n        snd += stringPad(time*0.25, 440.);\n        snd += stringPad(time*2./3., 440.) * (1.-cos2(0.1*time)) * 0.4;\n        snd += stringPad(time*3./4.-3.1, 440.) * 0.6;\n        snd += stringPad(time*8./9.-3.1, 440.) * (1.-cos2(0.05*time))*0.5;\n    }\n    #endif\n    \n    // Low-frequency rumble (wear headphones!)\n    #if 1\n    {\n        float rumble = 0.;\n        float t = mod(time, 5.);\n        float hit = exp(-0.2*t) * (1.-exp(-50.*t));\n        rumble += fm(time, 5., 17., 1.);\n        rumble += fm(time, 27.5, 27.5, 0.5+hit);\n        rumble *= 0.35 * (1.-0.8*cos2(0.3*time)) * (1.0+0.2*cos(time)) * hit;\n        rumble = rumble/(1.+abs(rumble));\n        snd += rumble;\n    }\n    #endif\n    \n    \n    return snd*(1.-exp(-time)); // Fade in\n}","name":"Sound","description":"","type":"sound"}]}