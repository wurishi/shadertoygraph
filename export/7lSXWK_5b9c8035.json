{"ver":"0.1","info":{"id":"7lSXWK","date":"1628607313","viewed":225,"name":"Cone-Traced Supersampling (CTSS)","username":"rtc","description":"Cone Traced Super Sampling (CTSS) for SDF-based geometry.\n\nSeptember 2023:\n-CTSS with Delayed shading\n-Subpixel Edge Reconstruction  (when enabled, ~60 second compile time, disabled by default)\n\nJune 2023:\n-Added simple Sponza + primitives scene\n","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAndrei Chubarau\n\nInteractive demo for Cone-Traced Supersampling (CTSS) with optional Subpixel Edge Reconstruction (SER).\n\nSER is disabled by default. See #USE_SUBPIXEL_EDGE_RESOLVE\n\nThis code is ported from our Unity3D implementation. \n\n----------------------------------------\n\nPaper accepted at Graphics Interface 2023:\nAndrei Chubarau, YANGYANG ZHAO, Ruby Rao, Paul Kry, Derek Nowrouzezahrai,\n\"Cone-Traced Supersampling for Signed Distance Field Rendering\", 2023\nhttps://openreview.net/forum?id=FYhiH9IyBq\n\n----------------------------------------\n\nCTSS performs supersampling along the traced ray near surfaces with partial\nvisibility identified by evaluating cone intersections within a pixel's view frustum.\nCTSS incurs roughly 15-30% added computational cost compared to sphere tracing and\nsignificantly outperforms conventional supersampling approaches while offering\ncomparative antialiasing and visual image quality for most geometric edges.\n\nCombining AA with CTSS (supersample in pixel space and along the traced rays) offers the best visual quality.\n\nHold and move mouse to control view direction (mouse in bottom left corner = initial view).\n\nUse #define NO_CTSS to toggle CTSS\n\nUse #define USE_SUBPIXEL_EDGE_RESOLVE to toggle SER\n\n*/\n\n/* ---------------------------------------- */\n\n// NOTE: The code is based on the primitives showcase by Inigo Quilez: \n// THE ORIGINAL LICENSE:\n//\n// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n\n/* ---------------------------------------- */\n// CTSS parameters\n\n#define MAX_AA_FACTOR 4\n\n// 1 for single sample, 2 for 2x2 supersampling, etc.\n#define _AA_FACTOR 1\n// #define _AA_FACTOR 2\n// #define _AA_FACTOR 3\n\n/* ---------------------------------------- */\n// CTSS parameters\n\n// #define NO_CTSS // disables CTSS\n\n#define CTSS_NUM_SAMPLES 8 // maximum number of CTSS samples per pixel\n\n#define USE_CTSS_WEIGHTED // toggle for using visibility-based weights; uncomment for uniform sample weights\n// #define USE_CTSS_R // use CTSS Relaxed, faster approximation with sphere tracing termination at hard hit (not full hit)\n\n// small value epsilon, precision for cone tracing intersections.\n// Note: cone tracing eps=0.01 is similar to sphere tracing eps=0.0001\n// min ~0.0005, else may have visual artifacts\n#define OCCLUSION_EPS 0.01\n\n#define OCCLUSION_SOFT (0. - OCCLUSION_EPS) // cone occlusion for soft hit detection\n#define OCCLUSION_HARD (0.5 - OCCLUSION_EPS) // cone occlusion for hard hit detection\n\n#ifdef USE_CTSS_R\n#define OCCLUSION_STOP OCCLUSION_HARD // relaxed CTSS (faster, worse AA quality)\n#else\n#define OCCLUSION_STOP (1.0 - OCCLUSION_EPS) // full CTSS (slower, better AA quality)\n#endif\n\n#define MIN_SAMPLE_WEIGHT 0.01 // minimum allowed value for a soft hit group weight\n\n#define SPHERE_TRACE_STEPSIZE_MULT 1.0 // controls step size as a multiple of SDF value, useful for non-ideal SDFs\n#define CONE_RAD_STEP_MULT 0.5 // upper bound for the step size as a multiple of local cone Radius\n\n/* ---------------------------------------- */\n\n//#define USE_SUBPIXEL_EDGE_RESOLVE\n\n// the following only apply when #DEBUG is defined\n#define _USE_SUBPIXEL_EDGE_RESOLVE true\n#define _SUBPIXEL_EDGE_RESOLVE_TWO_PLANE_INTERSECTION true\n#define _SUBPIXEL_EDGE_RESOLVE_CONE_MULT_COS 2.0\n#define _SUBPIXEL_EDGE_RESOLVE_CONE_MULT 1.0\n#define _SUBPIXEL_EDGE_RESOLVE_COSSIM_THRESHOLD_MAX 0.999\n#define _SUBPIXEL_EDGE_RESOLVE_COSSIM_THRESHOLD_MIN 0.9\n#define _SUBPIXEL_EDGE_RESOLVE_CURVATURE_THRESHOLD 0.00001\n\n/* ---------------------------------------- */\n// Sphere tracing parameters\n\n#define TMIN 0.01\n#define TMAX 30.\n\n#define _MAX_RAYMARCH_STEPS 2048  // max SDF marching steps\n\n// cone radius expansion factor in units of pixel size\n#define PIXEL_SIZE_MULT_INSCRIBED (1. / 2.) // cone is inscribed in the pixel (inside the pixel)\n#define PIXEL_SIZE_MULT_CIRCUMSCRIBED (1. / sqrt(2.)) // cone is circumscribed in the pixel (intersects pixel corners)\n#define PIXEL_SIZE_MULT_BALANCED (1. / ((2. + sqrt(2.)) / 2.)) // half way between inscribed and circumscribed\n#define PIXEL_SIZE_MULT PIXEL_SIZE_MULT_BALANCED\n\n/* ---------------------------------------- */\n\n// CONE_BACKTRACE more correctly estimates the entry point of a cone hit as sphere tracing detects a delayed hit.\n// With sphere tracing, the true cone intersection entry point is somewhere between iterations i-1 and i,\n// but cone intersection is only detected at iteration i. This can lead to visual artifacts shading inside a surface.\n// CONE_BACKTRACE gives a safe position between iterations i-1 and i, where no hit is guaranteed.\n#define CONE_BACKTRACE_T(t, tanT) (t * (1. - tanT / (1. + tanT)))\n\n// when defined, will backtrace and then run normal sphere tracing to determine a hard intersection\n// #define CONE_BACKTRACE_SPHERE_TRACE\n\n// maximum number of steps for sphere tracing after applying backtrace correction\n#define CONE_BACKTRACE_SPHERE_TRACE_MAX_STEPS 32\n\n/* ---------------------------------------- */\n\n// boundary box parameters\n// #define BBOX_FLOOR // toggle for using bbox\n\n#define BBOX_FLOOR_Y -0.25 // y level of floor bbox\n\n/* ---------------------------------------- */\n// camera\n\n#define FOCAL_LENGTH 2.5\n\n#define _CAMERA_STATIC false\n#define _CAMERA_SPIN 0.025 // angle of each oscillations\n#define _CAMERA_SPEED 0.05 // how many oscillations per second\n\n/* ---------------------------------------- */\n\n#define DEBUG_OPACITY 0.99\n\n// #define DEBUG // flag to enable/disable all debugging\n\n// #define DEBUG_NUM_SAMPLES\n// #define DEBUG_DEPTH\n// #define DEBUG_NORMAL\n// #define DEBUG_STEPS\n\n#define _DEBUG_SUBPIXEL_EDGE_RESOLVE_WEIGHT false\n#define _DEBUG_SUBPIXEL_EDGE_RESOLVE_COSSIM false\n#define _DEBUG_SUBPIXEL_EDGE_RESOLVE_DIRECTION false\n#define _DEBUG_SUBPIXEL_EDGE_RESOLVE_CURVATURE false\n\n/* ---------------------------------------- */\n// shading\n\n#define USE_SUN\n#define USE_SUN_SDF\n#define USE_AO\n#define USE_SKY_SHADOW\n#define USE_FOG\n\n#define USE_CHECKERBOARD\n\n#define FOG_COLOR vec3(0.9, 0.9, 1.2)\n#define FOG_FALLOFF 0.000015\n#define FOG_START_DISTANCE 2.\n\n#define SKY_COLOR vec3(0.9, 0.9, 1.2)\n\n#define SUN_COLOR vec3(1.00, 0.8, 0.60)\n#define SUN_DIR normalize(vec3(-0.5, 0.4, -0.6))\n\n#define CHECKERBOX_INTENSITY 0.85\n\n#define MAX_SHADOW_STEPS 64  // max SDF marching steps for lights\n#define MIN_SHADOW_STEP_SIZE 0.01\n#define MAX_SHADOW_STEP_SIZE 0.25\n#define MIN_SHADOW_TRACE_T 0.001  // minimum ray depth for tracing shadows\n#define MAX_SHADOW_TRACE_T 5.  // maximum ray depth for tracing shadows\n\n/* ---------------------------------------- */\n// normals\n\n#define NORMAL_IMPL_EPS 0.0001\n\n// 3 different normal calculation implementations\n#define NORMAL_IMPL_UNITY 0  // 6 sdf calls, more precise\n#define NORMAL_IMPL_UNITY_TETRAHYDRON 1 // 4 sdf calls, less precise\n#define NORMAL_IMPL_SHADERTOY 2 // 4 sdf calls, less precise, Shadertoy compile optimization\n\n#define NORMAL_IMPL NORMAL_IMPL_UNITY\n\n/* ---------------------------------------- */\n// sdf function\n\nvec2 sdf_showcase(in vec3 p)\n{\n    vec2 res = vec2(100000, 0);\n\n    p = vec3(p.x, p.y, -p.z);\n    \n    res = opU(res, vec2(sdPlane(p, 0.), 0.));\n\n    // bounding box\n    if (sdBox(p - vec3(0.0, 0.3, -1.0), vec3(0.35, 0.3, 2.5)) < res.x)\n    {\n        // more primitives\n        res = opU(res, vec2(sdBoundingBox(p - vec3(0.0, 0.25, 0.0), vec3(0.3, 0.25, 0.2), 0.025),\n                              16.9));\n        res = opU(res, vec2(sdTorus((p - vec3(0.0, 0.30, 1.0)).xzy, vec2(0.25, 0.05)), 25.0));\n        res = opU(res, vec2(sdCone(p - vec3(0.0, 0.45, -1.0), vec2(0.6, 0.8), 0.45), 55.0));\n        res = opU(res, vec2(sdCappedCone(p - vec3(0.0, 0.25, -2.0), 0.25, 0.25, 0.1), 13.67));\n        res = opU(res, vec2(sdSolidAngle(p - vec3(0.0, 0.00, -3.0), vec2(3, 4) / 5.0, 0.4), 49.13));\n        res = opU(res, vec2(sdSphere(p - vec3(0, 0.25, -0), 0.15), 26.9));\n    }\n\n    // bounding box\n    if (sdBox(p - vec3(1.0, 0.3, -1.0), vec3(0.35, 0.3, 2.5)) < res.x)\n    {\n        // more primitives\n        res = opU(res, vec2(sdCappedTorus((p - vec3(1.0, 0.30, 1.0)) * vec3(1, -1, 1),\n                                            vec2(0.866025, -0.5), 0.25, 0.05), 8.5));\n        res = opU(res, vec2(sdBox(p - vec3(1.0, 0.25, 0.0), vec3(0.3, 0.25, 0.1)), 3.0));\n        res = opU(res, vec2(sdCapsule(p - vec3(1.0, 0.00, -1.0), vec3(-0.1, 0.1, -0.1),\n                                        vec3(0.2, 0.4, 0.2), 0.1), 31.9));\n        res = opU(res, vec2(sdCylinder(p - vec3(1.0, 0.25, -2.0), vec2(0.15, 0.25)), 8.0));\n        res = opU(res, vec2(sdHexPrism(p - vec3(1.0, 0.2, -3.0), vec2(0.2, 0.05)), 18.4));\n    }\n\n    // bounding box\n    if (sdBox(p - vec3(-1.0, 0.35, -1.0), vec3(0.35, 0.35, 2.5)) < res.x)\n    {\n        // more primitives\n        res = opU(res, vec2(sdPyramid(p - vec3(-1.0, -0.6, -3.0), 1.0), 13.56));\n        res = opU(res, vec2(sdOctahedron(p - vec3(-1.0, 0.15, -2.0), 0.35), 23.56));\n        res = opU(res, vec2(sdTriPrism(p - vec3(-1.0, 0.15, -1.0), vec2(0.3, 0.05)), 43.5));\n        res = opU(res, vec2(sdEllipsoid(p - vec3(-1.0, 0.25, 0.0), vec3(0.2, 0.25, 0.05)), 43.17));\n        res = opU(res, vec2(sdRhombus((p - vec3(-1.0, 0.34, 1.0)).xzy, 0.15, 0.25, 0.04, 0.08),\n                              12.5));\n    }\n\n    // bounding box\n    if (sdBox(p - vec3(2.0, 0.3, -1.0), vec3(0.35, 0.3, 2.5)) < res.x)\n    {\n        // more primitives\n        res = opU(res, vec2(sdOctogonPrism(p - vec3(2.0, 0.2, -3.0), 0.2, 0.05), 51.8));\n        res = opU(res, vec2(sdCylinder(p - vec3(2.0, 0.15, -2.0), vec3(0.1, -0.1, 0.0),\n                                         vec3(-0.2, 0.35, 0.1), 0.08), 31.2));\n        res = opU(res, vec2(sdCappedCone(p - vec3(2.0, 0.10, -1.0), vec3(0.1, 0.0, 0.0),\n                                           vec3(-0.2, 0.40, 0.1), 0.15, 0.05), 46.1));\n        res = opU(res, vec2(sdRoundCone(p - vec3(2.0, 0.15, 0.0), vec3(0.1, 0.0, 0.0),\n                                          vec3(-0.1, 0.35, 0.1), 0.15, 0.05), 51.7));\n        res = opU(res, vec2(sdRoundCone(p - vec3(2.0, 0.20, 1.0), 0.2, 0.1, 0.3), 37.0));\n    }\n\n    return res;\n}\n// A shorter, uglier but faster version of https://www.shadertoy.com/view/XddBD2\nvec2 sdf_fast_sponza(in vec3 p)\n{\n    // y bound\n    if (13.75 < p.y)\n        return vec2(1., 0.);\n\n    p.y -= 2.0;\n    vec3 a0 = p;\n    a0.xz = abs(a0.xz) * vec2(-1.0,1.0);\n    vec3 a1 = a0 - vec3(6.24,.0,2.5);\n    a1.xz = pModPolar(a1.xz, 4.0);\n    float d1 = -(a1 - vec3(11.49,.0,.0)).x;\n    vec3 a2 = a1 - vec3(11.02,2.15,7.28);\n    a2.z = domainRepeat1D(a2.z, 2.0);\n    float d3 = fBox(a2 - vec3(-2.64,5.05,.0),vec3(.5,.5,.228));\n    d3 = min(d3,fBox(a2 - vec3(-2.275,5.05,.0),vec3(.383,.383,.175)));\n    d3 = min(d3,fBox(a2 - vec3(-2.64,6.97,.0),vec3(.5,.283,.111)));\n    float d2 = max(-d3,fBox(a2 - vec3(-1.28,6.38,.287),vec3(1.5,1.893,6.673)));\n    vec3 a4 = a1 - vec3(9.18,-4.5,-.032);\n    a4.y = domainRepeat1D(a4.y, 4.5);\n    vec3 a5 = vec3(a4.x, a4.y, domainRepeat1D(a4.z, 2.5));\n    vec3 a6 = vec3(-a5.x, a5.y, a5.z);\n    vec3 a8 = rdZ(a6 - vec3(.05,-.62,.0));\n    float d8 = (fCylinder(a8, 1.398,1.361)*.75);\n    d8 = max(-d8,(fCylinder(a8 - vec3(.0,.152,.0), 1.434,.531)*.75));\n    float d7 = max(d8,fBox(a6 - vec3(.786,.46,.0),vec3(.523,.747,1.415)));\n    float d9 = fBox(a6 - vec3(.47,1.953,.0),vec3(.5,.075,1.5));\n    d9 = min(d9,fBox(a6 - vec3(.58,2.2,.0),vec3(.5,.1,1.5)));\n    d9 = min(d9,fBox(a6 - vec3(-.45,-2.3,.0),vec3(1.5,.1,1.5)));\n    vec3 a10 = a6 - vec3(.463,-.51,1.179);\n    a10.z = domainRepeat1D(a10.z, 2.35);\n    float d10 = fBox(a10,vec3(.24,.033,.24));\n    d10 = min(d10,fBox(a10 - vec3(.0,-.093,.0),vec3(.24,.033,.24)));\n    d10 = min(d10,fBox(a10 - vec3(-2.8,-.03,.0),vec3(.25,.075,.25)));\n    vec3 a11 = vec3(a10.y, pModPolar(a10.xz , 8.0)).yxz;\n    float d11 = fBox(a11 - vec3(.002,-1.07,.0),vec3(.17,1.053,.424));\n    vec3 a12 = a6 - vec3(-1.03,-.518,.0);\n    vec3 a13 = rdZ(a12);\n    float d13 = fCylinder(vec3(a13.x, -a13.z, a13.y), 1.225,3.0);\n    d13 = min(d13,fCylinder(a13, 1.094,2.061));\n    float d12 = max(-d13,fBox(a12 - vec3(.12,1.27,.0),vec3(1.5,1.355,1.551)));\n    vec3 a14 = a6 - vec3(.463,1.57,1.61);\n    float d14 = fCylinder(vec3(a14.y, -a14.x, a14.z) - vec3(-.19, -.13, -1.08), .105,.046);\n    vec3 polePos = vec3(-a14.y, a14.x, a14.z) - vec3(.042, .596, -1.08);\n    polePos.xy += 0.3428 * vec2(polePos.y, -polePos.x);\n    d14 = min(d14,fCylinder(polePos, .025,.582));\n    float dout = min(min(min(d1,d2),min(min(d7,min(min(d9,min(d10,d11)),d12)),d14)),(a0 - vec3(.0,-2.0,.0)).y);\n\n    return vec2(dout, 4.3);\n}\n\nvec2 sdf(in vec3 p)\n{\n    // for better lighting, remove front wall\n    // float zd = p.z - 12;\n    // if (0.1 < zd)\n        // return zd;\n\n    vec2 prim = sdf_showcase((p - vec3(-0.8, 0.001, 7.25)));\n    vec2 sponza = sdf_fast_sponza(p);\n\n    return opU(prim, sponza);\n}\n\n\n/* ---------------------------------------- */\n// normals\n\nvec4 calcNormalH4( vec3 pos, const float h ) // for function f(p)\n{\n    // same as the base implementation below, but also returns the sum of all tested SDF values minus non-zero h0 offset\n    vec2 k = vec2(h, 0);\n    float h0 = sdf(pos).x;\n    float h1 = sdf(pos + k.xyy).x;\n    float h2 = sdf(pos - k.xyy).x;\n    float h3 = sdf(pos + k.yxy).x;\n    float h4 = sdf(pos - k.yxy).x;\n    float h5 = sdf(pos + k.yyx).x;\n    float h6 = sdf(pos - k.yyx).x;\n    return vec4(normalize( vec3(h1 - h2, h3 - h4, h5 - h6)), h1 + h2 + h3 + h4 + h5 + h6 - 6.0 * h0);\n}\n\n// https://iquilezles.org/articles/normalsSDF/\n#if NORMAL_IMPL==NORMAL_IMPL_UNITY\nvec3 calcNormalH( vec3 pos, const float h ) // for function f(p)\n{\n    vec2 k = vec2(h, 0);\n    return normalize( vec3(sdf(pos + k.xyy).x - sdf(pos - k.xyy).x,\n                             sdf(pos + k.yxy).x - sdf(pos - k.yxy).x,\n                             sdf(pos + k.yyx).x - sdf(pos - k.yyx).x ) );\n}\n#elif NORMAL_IMPL==NORMAL_IMPL_UNITY_TETRAHYDRON\n// assumes that we are computing normal at the surface boundary: sdf(pos) = 0, zero iso-surface of the SDF \nvec3 calcNormalH( vec3 pos, const float h ) // for function f(p)\n{\n    const vec2 k = vec2(1., -1.);\n    return normalize( k.xyy * sdf( pos + k.xyy * h ).x +\n                      k.yyx * sdf( pos + k.yyx * h ).x +\n                      k.yxy * sdf( pos + k.yxy * h ).x +\n                      k.xxx * sdf( pos + k.xxx * h ).x );\n}\n#elif NORMAL_IMPL==NORMAL_IMPL_SHADERTOY\nvec3 calcNormalH( vec3 pos, const float h )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0., 0., 0.);\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 e = 0.5773 * (2. * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.);\n        n += e * sdf(pos + h * e).x;\n        //if( n.x+n.y+n.z>100. ) break;\n    }\n    return normalize(n);\n}\n#endif\n\nvec3 calcNormal( vec3 pos )\n{\n    return calcNormalH(pos, NORMAL_IMPL_EPS);\n}\n\nvec3 calcNormal( vec3 pos, const float h )\n{\n    return calcNormalH(pos, max(NORMAL_IMPL_EPS, h)); // limit minimal value for h\n}\n\n/* ---------------------------------------- */\n// shading\n\nvec3 normal2color( vec2 normal )\n{\n    return vec3((normal + 1.) / 2., 0);\n}\n\nvec3 normal2color( vec3 normal )\n{\n    return (normal + 1.) / 2.;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n    float res = 1.;\n    float t = mint;\n    for (int i = ZERO; i < MAX_SHADOW_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        float h = sdf(p).x;\n        float s = clamp(8. * h / t, 0., 1.);\n        res = min(res, s * s * (3. - 2. * s));\n\n        #ifdef GRID\n        float d2cell = abs(sd2dBox(opRep(p, GRID).xz, 0.5*GRID.xz));\n        t += clamp(sign(h.x) * min(max(d2cell, 0.01), abs(h.x)), MIN_SHADOW_STEP_SIZE, MAX_SHADOW_STEP_SIZE); // mod for grid\n        #else\n        t += clamp(h, MIN_SHADOW_STEP_SIZE, MAX_SHADOW_STEP_SIZE);\n        #endif\n\n        if (res < 0.004 || t > tmax) break;\n    }\n    return clamp(res, 0., 1.);\n}\n\n#ifdef USE_AO\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n    float occ = 0.;\n    float sca = 1.;\n    for (int i = ZERO; i < 5; i++)\n    {\n        float h = 0.01 + 0.12 * float(i) / 4.;\n        float d = sdf(pos + h * nor).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n        if (occ > 0.35) break;\n    }\n    return clamp(1. - 3. * occ, 0., 1.) * (0.5 + 0.5 * nor.y);\n}\n#endif\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox(in vec2 p, in vec2 dpdx, in vec2 dpdy)\n{\n    // filter kernel\n    vec2 w = abs(dpdx) + abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2. * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n    // xor pattern\n    return mix(0.5 - 0.5 * i.x * i.y, 1., 1. - CHECKERBOX_INTENSITY);\n    // return 1.;\n}\n\nvec3 code2color( const in float m )\n{\n    return 0.2 + 0.2 * sin(m * 2. + vec3(0., 1., 2.));\n}\n\nvec3 shadedColor(\n    in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float m, in vec3 pos, in vec3 nor)\n{\n    // no hit\n    if (m < -0.5)\n        return vec3(0., 0., 0.);\n\n    vec3 col = code2color(m);\n    float ks = clamp(m / 10.0, 0., 1.);\n\n#ifdef USE_CHECKERBOARD\n    if (m < 1.5)\n    {\n        // floor\n        nor = vec3(0., 1., 0.);\n        // checker grad pattern\n        // project pixel footprint into the plane\n        vec3 dpdx = ro.y * (rd / rd.y - rdx / rdx.y);\n        vec3 dpdy = ro.y * (rd / rd.y - rdy / rdy.y);\n        col.x = checkersGradBox(3. * pos.xz, 3. * dpdx.xz, 3. * dpdy.xz);\n        col = 0.1 + col * 0.05;\n        ks = 1.0;\n    }\n#endif\n\n#ifdef USE_AO\n    // lighting\n    float occ = calcAO(pos, nor);\n#elif defined (SDF_M_IS_OCCLUSION)\n    float occ = m;\n#else\n    float occ = 0.;\n#endif\n\n    vec3 lin = vec3(0., 0., 0.);\n\n#ifdef USE_SUN\n    // sun\n    {\n        vec3 lig = SUN_DIR;\n        vec3 hal = normalize(lig - rd);\n        float dif = clamp(dot(nor, lig), 0., 1.);\n#ifdef USE_SUN_SDF\n        if( dif>0.0001 )\n            dif *= calcSoftshadow(pos, lig, MIN_SHADOW_TRACE_T, MAX_SHADOW_TRACE_T);\n#endif\n        float spe = pow(clamp(dot(nor, hal), 0., 1.), 16.);\n        spe *= dif;\n        spe *= 0.04 + 0.96 * pow(clamp(1. - dot(hal, lig), 0., 1.), 5.);\n        lin += col * 2.20 * dif * SUN_COLOR;\n        lin += 5.00 * spe * SUN_COLOR * ks;\n    }\n#endif\n\n#ifdef USE_SKY_SHADOW\n    // sky\n    {\n        vec3 ref = reflect(rd, nor);\n        float dif = sqrt(clamp(0.5 + 0.5 * nor.y, 0., 1.));\n        dif *= occ;\n        float spe = smoothstep(-0.2, 0.2, ref.y);\n        spe *= dif;\n        spe *= 0.04 + 0.96 * pow(clamp(1. + dot(nor, rd), 0., 1.), 5.);\n        //if( spe>0.001 )\n        spe *= mix(calcSoftshadow(pos, ref, 0.005, MAX_SHADOW_TRACE_T), 1.0, 0.1);\n        lin += col * 0.60 * dif * SKY_COLOR;\n        lin += 1.0 * spe * SKY_COLOR * ks;\n    }\n#endif\n\n    // back\n    {\n        float dif = clamp(dot(nor, normalize(vec3(0.5, 0., 0.6))), 0., 1.) * clamp(\n            1. - pos.y, 0., 1.);\n        dif *= occ;\n        lin += col * 0.6 * dif * vec3(0.25, 0.25, 0.25);\n    }\n    // sss\n    {\n        float dif = pow(clamp(1. + dot(nor, rd), 0., 1.), 2.);\n        dif *= occ;\n        lin += col * 0.55 * dif * 1.;\n    }\n\n    col = lin;\n\n#ifdef USE_FOG\n    // fog\n    float depth = length(ro - pos);\n    float tf = clamp(depth - FOG_START_DISTANCE, 0., depth);\n    col = mix(col, FOG_COLOR, 1. - exp(-FOG_FALLOFF * tf * tf * tf));\n#endif\n\n    return col;\n}\n\n/* ---------------------------------------- */\n// rendering\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = (cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n// returns vec3(ray depth, object id, number of sphere tracing steps)\nvec3 sphereTrace(const vec3 ro, const vec3 rd, const float tan_theta, const int max_steps, const float tmin)\n{\n    float tmax = TMAX;\n    #ifdef BBOX_FLOOR\n    // raytrace \"floor\"\n    float tp1 = (BBOX_FLOOR_Y - stp.ro.y) / stp.rd.y;\n    if (tp1 > 0.)\n    {\n        tmax = min(stp.t_max, tp1);\n    }\n    #endif\n\n    // sphere tracing\n    float t = tmin;\n    for (int i = 0; i < max_steps && t < tmax; i++)\n    {\n        vec3 p = ro + rd * t; // current pos\n        vec2 h = sdf(p); // current sdf\n\n        float coneRad = t * tan_theta;\n        float coneOcclusion = (1. - h.x / coneRad) / 2.;\n\n        // classical sphere tracing with cone intersection termination criterion\n        if (OCCLUSION_HARD < coneOcclusion)\n        {\n            return vec3(t, h.y, i); // ray depth and object code\n        }\n\n        // increment depth along ray\n        float step = h.x * SPHERE_TRACE_STEPSIZE_MULT; // apply step size multiplier\n#ifdef GRID_TRACE\n        float d2cell = abs(sd2dBox(opRep(p, GRID).xz, 0.5 * GRID.xz));\n        t += sign(step) * min(max(d2cell, 0.01), abs(step));\n#else\n        t += step;\n#endif\n    }\n\n    return vec3(t, -1., -1);\n}\n\n#ifdef NO_CTSS\nvec3 render(const vec3 ro, const vec3 rd, const float tan_theta, const vec3 rdx, const vec3 rdy)\n{\n    // compute intersection with SDFs\n    // sample.x = ray depth, sample.y = object id\n    vec3 str = sphereTrace(ro, rd, tan_theta, MAX_RAYMARCH_STEPS, TMIN);\n\n    // shade background if sphere tracing does not find intersection\n    if (str.z < 0)\n    {\n#ifdef WHITE_BG\n        return vec3(1., 1., 1.);\n#else\n        return vec3(clamp(FOG_COLOR - max(rd.y, 0.) * 0.3, 0., 1.));\n#endif\n    }\n\n    // compute shading\n    vec3 pos = ro + rd * str.x;\n    vec3 nor = calcNormal(pos);\n    vec3 color = shadedColor(ro, rd, rdx, rdy, str.y, pos, nor);\n\n#ifdef DEBUG\n#ifdef DEBUG_NORMAL\n    color = mix(color, normal2color(nor), DEBUG_OPACITY);\n#endif\n\n// #define DEBUG_NORMAL_COS\n#ifdef DEBUG_NORMAL_COS\n    float coneRadius = str.x * tan_theta;\n    vec3 norCR = calcNormal(pos, 2.0 * coneRadius);\n    float cosSim = dot(nor, norCR);\n\n    if (cosSim < SUBPIXEL_EDGE_RESOLVE_COSSIM_THRESHOLD)\n    {\n        ;\n    } else\n        color *= 0;\n#endif\n\n#ifdef DEBUG_STEPS\n    float steps = float(str.z) / MAX_RAYMARCH_STEPS;\n    color = mix(color, steps, DEBUG_OPACITY);\n#endif\n\n#ifdef DEBUG_DEPTH\n    float depth = t / TMAX;\n    color = mix(color, depth * depth, DEBUG_OPACITY);\n#endif\n#endif\n\n    return color;\n}\n#else\n\n#define TWO_OVER_FIVE_MINUS_ONE (2. / 5. - 1.)\n#define FOUR_OVER_FIVE_MINUS_ONE (4. / 5. - 1.)\n#define SIX_OVER_FIVE_MINUS_ONE (6. / 5. - 1.)\n#define EIGHT_OVER_FIVE_MINUS_ONE (8. / 5. - 1.)\n#define TEN_OVER_FIVE_MINUS_ONE (10. / 5. - 1.)\n\n#define VISMASK_MIN_NORMAL 0.001f\n\n#define SHIFT(x, n) ((0 <= n) ? (x << n): (x >> -n))\n\nstruct sample_ctss\n{\n    vec3 position;\n    float t_in;\n    float t_out;\n    float t_s;\n    float id;\n    float occlusion;\n};\n\n/**\n    Returns a 32-bit visibility mask given current cone radius, SDF value, and SDF normal.\n    Mask represents ~6x6 subpixel visibility (occupancy).\n    Visibility over 6 horizontal lines is encoded with 4, 6, 6, 6, 6, 4 bits (32 bits total).\n    Note that corner bits are omitted since 6x6=36, but we only have 32 bits.\n    Example bit mask with full visibility (Xs show the space that is omitted in the mask):\n        X1111X\n        111111\n        111111\n        111111\n        111111\n        X1111X\n    This will be packed in a single int as 32 bits: 1111 111111 111111 111111 111111 1111\n*/\nint getVisibilityMask(float coneOcclusion, vec2 nor)\n{\n    // ensure non-zero normal x, y components\n    vec2 n = normalize(vec2(\n        clamp(abs(nor.x), VISMASK_MIN_NORMAL, 1.) * (nor.x < 0. ? -1.: 1.),\n        clamp(abs(nor.y), VISMASK_MIN_NORMAL, 1.) * (nor.y < 0. ? -1.: 1.)\n    ));  // clamp abs then apply sign\n\n    float h = (1. - 2. * coneOcclusion);\n    h = -h;\n\n    // define y = ax + b to describe how the surface intersects the traced cone\n    // solve for a and b using simple geometry and math\n    float a = -n.x / n.y;  // slope;\n    float b = h * (n.y * n.y + n.x * n.x) / n.y;  // y intersect\n\n    // NOTE:\n    // yIncr = 2. / 5. * r;\n    // for i in (0, 1, 2, 3, 4, 5)\n    //     py = yIncr * i - r\n    //     vis = ((py - b) / a / r + 1.) / 2. = (py - b) / a / r / 2. + 0.5\n    float t = 0.5f / a;\n\n    // solve for x (intersection of surface and horizontal line given by y)\n    // saturate visibility to 0-1\n    float vis0 = clamp((-1.0 - b) * t + 0.5, 0., 1.);\n    float vis1 = clamp((TWO_OVER_FIVE_MINUS_ONE - b) * t + 0.5, 0., 1.);\n    float vis2 = clamp((FOUR_OVER_FIVE_MINUS_ONE - b) * t + 0.5, 0., 1.);\n    float vis3 = clamp((SIX_OVER_FIVE_MINUS_ONE - b) * t + 0.5, 0., 1.);\n    float vis4 = clamp((EIGHT_OVER_FIVE_MINUS_ONE - b) * t + 0.5, 0., 1.);\n    float vis5 = clamp((TEN_OVER_FIVE_MINUS_ONE - b) * t + 0.5, 0., 1.);\n\n    // apply vis - 1 if n.x is positive\n    float vis_r = (0. < n.x) ? -1.: 0.; // 0 or -1\n    // convert visibility to bit shift amounts (max 6 bit shift)\n    int shift0 = int(6. * (vis0 + vis_r));\n    int shift1 = int(6. * (vis1 + vis_r));\n    int shift2 = int(6. * (vis2 + vis_r));\n    int shift3 = int(6. * (vis3 + vis_r));\n    int shift4 = int(6. * (vis4 + vis_r));\n    int shift5 = int(6. * (vis5 + vis_r));\n\n    int mask_int = 0;  // 32-bit mask\n    int mask4 = 0x1E; // 0b00011110, the side bits are 0s for line 0 and 5\n    int mask6 = 0x3F; // 0b00111111;  // all 6 bits are used for lines 1, 2, 3, 4\n    mask_int |= (SHIFT(mask6, shift0) & mask4) << 27;  // >> 1 << 28 = << 27; 1 extra right shift (since mask4)\n    mask_int |= (SHIFT(mask6, shift1) & mask6) << 22;\n    mask_int |= (SHIFT(mask6, shift2) & mask6) << 16;\n    mask_int |= (SHIFT(mask6, shift3) & mask6) << 10;\n    mask_int |= (SHIFT(mask6, shift4) & mask6) << 4;\n    mask_int |= (SHIFT(mask6, shift5) & mask4) >> 1;  // >> 1 << 0 = >> 1; 1 extra right shift (since mask4)\n\n    return mask_int;\n}\n\nint bitCountOnes(int num) {\n    int count = 0;\n    for (int i = 0; i < 32; i++)\n    {\n        count += num & 1;\n        num = num >> 1;\n    }\n    return count;\n}\n\n#ifdef USE_SUBPIXEL_EDGE_RESOLVE\nfloat resolve_primary_edge_visibility(const vec3 n1, const vec3 n2, float h1, float h2,\n    const vec3 rd, const vec3 searchDir, float coneRadius)\n{\n    // note: for all local projections, x axis is along searchDir, y axis is along rd\n    // searchDir and rd are orthogonal\n\n    // local projection of the normals of the two planes\n    float np1rd = dot(-rd, n1);\n    float np2rd = dot(-rd, n2);\n    float np1sd = dot(searchDir, n1);\n    float np2sd = dot(searchDir, n2);\n    // 2d projected normals (without normalization)\n    vec2 n1p = vec2(np1sd, np1rd);\n    vec2 n2p = vec2(np2sd, np2rd);\n\n    // local points on the two planes\n    // h is distance along projected 3d normal\n    vec2 p1 = - h1 * n1p; // origin - h1p * n1p\n    vec2 p2 = vec2(coneRadius, 0.0) - h2 * n2p;\n    // normalize direction only after computing p1 and p2\n    n1p = normalize(n1p);\n    n2p = normalize(n2p);\n\n    // describe lines as ax - y = -b\n    // a = -n.x / n.y because normal is orthogonal to line\n    // b = y - a x\n    // line 1\n    float a1 = -n1p.x / n1p.y;\n    float b1 = p1.y - a1 * p1.x;\n    // line 2\n    float a2 = -n2p.x / n2p.y;\n    float b2 = p2.y - a2 * p2.x;\n\n    // determine the intersection point of the two lines\n    // we only need the x coordinate\n    float xi = (b1 - b2) / (a2 - a1); // local x (along searchDir) position\n\n    // the intersection points controls the visibility of the primary edge sample\n    return (clamp(xi, -coneRadius, coneRadius) / coneRadius + 1.0) / 2.0;\n}\n#endif\n\nvec3 render(const vec3 ro, const vec3 rd, const float tan_theta, const vec3 rdx, const vec3 rdy)\n{\n    // setup total color and total weight\n    vec3 colorTotal = vec3(0., 0., 0.);\n    float weightTotal = 0.;\n\n    // record sample information during sphere tracing\n#ifndef USE_SUBPIXEL_EDGE_RESOLVE\n    sample_ctss samples[CTSS_NUM_SAMPLES];\n#else\n    sample_ctss samples[CTSS_NUM_SAMPLES + 1]; // +1 sample to allow for edge resolve\n#endif\n\n    int numSamples = 0;\n    bool hasHardHit = false; // ensure that only the first hard hit is sampled (for each group)\n\n#ifdef USE_CTSS_WEIGHTED\n    int visibilityMask = 0;\n#endif\n\n    // previous values for hasHit, hardHit, and sdf call\n    bool hasHitP = false; // previous\n    bool hardHitP = false; // previous\n    vec2 hP; // previous ray depth and object code\n\n    bool hasFullHit = false;\n\n    // sphere tracing\n    float t = TMIN; // current t\n    float tP = t; // initialize previous t as t\n\n    float t_max = TMAX;\n#ifdef BBOX_FLOOR\n    // raytrace floor plane\n    float tp1 = (BBOX_FLOOR_Y - ro.y) / rd.y;\n    if (tp1 > 0.)\n    {\n        t_max = min(t_max, tp1);\n    }\n#endif\n\n    int numSteps = 0;\n    for (; numSteps < _MAX_RAYMARCH_STEPS && t < t_max && numSamples < CTSS_NUM_SAMPLES; numSteps++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 h = sdf(p);\n\n        float coneRad = t * tan_theta;\n        float coneOcclusion = (1. - h.x / coneRad) / 2.;\n\n        bool hasHit = OCCLUSION_SOFT < coneOcclusion;\n        bool hardHit = OCCLUSION_HARD < coneOcclusion;\n        bool fullHit = OCCLUSION_STOP < coneOcclusion;\n\n        bool hitEntry = hasHit && !hasHitP;\n        bool hitExit = !hasHit && hasHitP;\n        bool hardHitEntry = hardHit && !hardHitP;\n\n        // update previous hit \n        hasHitP = hasHit;\n        hardHitP = hardHit;\n\n        if (hasHit)\n        {\n            if (hitEntry)\n            {\n                hasHardHit = false;\n\n                // init new sample, record hit group entry point\n                // used backtraced intersection: current ray depth minus safe cone radius\n                float t_entry = CONE_BACKTRACE_T(t, tan_theta);\n                // initialize t in, t out, t sample\n                samples[numSamples].t_in = t_entry; \n                samples[numSamples].t_out = t_entry;\n                samples[numSamples].t_s = t_entry;\n                samples[numSamples].position = ro + rd * t_entry; // sdf\n                samples[numSamples].id = h.y; // id\n#ifdef USE_CTSS_WEIGHTED\n                samples[numSamples].occlusion = coneOcclusion;\n#endif\n            }\n\n#ifdef USE_CTSS_WEIGHTED\n            // update maximal cone occlusion for the current group\n            samples[numSamples].occlusion = max(samples[numSamples].occlusion, coneOcclusion);\n#endif\n\n            // if hit group has a hard hit, record the first hard hit\n            if (hardHitEntry && !hasHardHit)\n            {\n                hasHardHit = true; // record that a hard hit was found for the current hit group\n\n                // record hard hit intersection\n#ifdef CONE_BACKTRACE_SPHERE_TRACE\n                // if sphere trace correction is enabled,\n                // sphere_trace from (previous ray depth + previous SDF value)\n                // TODO: fix this for new ctss_sample struct\n                vec3 str_h = sphereTrace(ro, rd, tan_theta, CONE_BACKTRACE_SPHERE_TRACE_MAX_STEPS, tP + hP.x);\n                samples[numSamples].xy = str_h.xy; // sdf, id\n#else\n                // fallback to previous ray depth + previous SDF value (safe position)\n                float t_s = tP + hP.x;\n                samples[numSamples].t_s = t_s; // sample position\n                samples[numSamples].position = ro + rd * t_s; // sdf\n                samples[numSamples].id = hP.y; // id\n#endif\n            }\n        }\n\n        // record the sample only when hit group exit is detected or a full hit occurs\n        if (hitExit || fullHit)\n        {\n            // record group exit position\n            samples[numSamples].t_out = CONE_BACKTRACE_T(t, tan_theta);\n\n            // reset control vars and increment sample counter\n            numSamples++;\n        }\n\n        if (fullHit)\n        {\n            hasFullHit = true;\n            break;\n        }\n\n        // update previous h and t\n        hP = h;\n        tP = t;\n\n        float step = h.x * SPHERE_TRACE_STEPSIZE_MULT;\n\n        // increment depth along ray\n#ifdef GRID_TRACE\n        // if on a grid with randomized objects (for each cell),\n        // need to cap maximum move distance to distance from the point within cell to the boundary of the cell,\n        // otherwise, the trace may miss geometry and have visual artifacts\n        float d2cell = abs(sd2dBox(opRep(p, GRID).xz, 0.5 * GRID.xz));\n        t += max(min(max(d2cell, 0.01), abs(step)), CONE_RAD_STEP_MULT * coneRad);\n#else\n        t += max(step, CONE_RAD_STEP_MULT * coneRad); // speed up sphere tracing near hard hits (sdf ~= 0)\n#endif\n    }\n\n#if defined(USE_CTSS_WEIGHTED) || defined(USE_SUBPIXEL_EDGE_RESOLVE) \n    // for normal projection, assuming camera is level with the horizon\n    // compute right and up vectors given the camera ray rd\n    vec3 right = normalize(cross(rd, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, rd));\n#endif\n    \n#ifdef USE_SUBPIXEL_EDGE_RESOLVE\n    bool hasSecondaryEdge = false;\n    vec3 normalSecondaryEdge = vec3(0.,0.,0.);\n    vec2 normal2dResolvedEdge = vec2(0.,0.);\n\n    // read the last sample and apply subpixel edge resolve for full occlusion samples\n    sample_ctss s = samples[numSamples - 1];\n#ifdef DEBUG\n    if (_USE_SUBPIXEL_EDGE_RESOLVE && OCCLUSION_STOP < s.occlusion)\n#else\n    if (OCCLUSION_STOP < s.occlusion)\n#endif\n    {\n        // calculate small scale normal (the normal of the primary edge)\n        float coneRadius = s.t_s * tan_theta;\n        // compute small scale normal\n        vec3 normalPrimaryEdge = calcNormal(s.position);\n        // compute large scale normal (instead of h=epsilon, use h=Rc, where Rc is the current cone radius)\n        vec4 normalLarge = calcNormalH4(s.position, _SUBPIXEL_EDGE_RESOLVE_CONE_MULT_COS * coneRadius);\n\n        // compute cosine similarity between small and large scale normals\n        float normalSimPrimary = dot(normalPrimaryEdge, normalLarge.xyz);\n        float curvature = normalLarge.w;\n\n        // if normals disagree by more than threshold,\n        // then pixel contains an edge and we will apply subpixel edge resolve \n        hasSecondaryEdge = normalSimPrimary < _SUBPIXEL_EDGE_RESOLVE_COSSIM_THRESHOLD_MAX &&\n            _SUBPIXEL_EDGE_RESOLVE_CURVATURE_THRESHOLD < abs(curvature);\n\n #ifdef DEBUG\n        if (_DEBUG_SUBPIXEL_EDGE_RESOLVE_COSSIM && !_DEBUG_SUBPIXEL_EDGE_RESOLVE_CURVATURE)\n        {\n            float sim = 1.0 - normalSimPrimary;\n            return vec3(sim, sim, sim);\n        }\n\n        if (_DEBUG_SUBPIXEL_EDGE_RESOLVE_CURVATURE)\n        {\n            if (!_DEBUG_SUBPIXEL_EDGE_RESOLVE_COSSIM)\n            {\n                float curv = (abs(curvature) < _SUBPIXEL_EDGE_RESOLVE_CURVATURE_THRESHOLD) ? 0: sign(curvature);\n                curv = (1.0 + curv) / 2.0;\n                return vec3(curv, curv, curv);\n            }\n            else if (!hasSecondaryEdge)\n            {\n                return vec3(0, 0, 0);\n            }\n#endif\n\n        if (hasSecondaryEdge)\n        {\n            // locate the secondary edge side.\n            // the sign of the curvature describes local edge as convex/concave,\n            // which in turn controls the direction towards the secondary edge.\n            // Direction is {from normalPrimaryEdge to normalLarge} for convex,\n            // and {from normalLarge to normalPrimaryEdge} for concave edges;\n            // curvature is positive for convex and negative for concave edges.\n            vec3 searchDir = sign(curvature) * normalize(normalLarge.xyz - normalPrimaryEdge);\n            // project the diff direction from world space to camera space\n            normal2dResolvedEdge = normalize(vec2(dot(right, searchDir), dot(up, searchDir)));\n            // reproject the 2d diff direction back to 3d\n            searchDir = normalize(normal2dResolvedEdge.x * right + normal2dResolvedEdge.y * up);\n\n            // resolve the secondary side position\n            vec3 resolvedPosition = s.position + searchDir * _SUBPIXEL_EDGE_RESOLVE_CONE_MULT * coneRadius;\n            // evaluate normal for secondary side\n            normalSecondaryEdge = calcNormal(resolvedPosition);\n            // evaluate sdf for secondary side (may be different object id)\n            vec2 h2 = sdf(resolvedPosition);\n            // offset position by sdf and normal\n            resolvedPosition = resolvedPosition - normalSecondaryEdge * h2.x * (1.0 - sign(h2.x) * OCCLUSION_EPS);\n\n#ifdef DEBUG\n            if (_DEBUG_SUBPIXEL_EDGE_RESOLVE_CURVATURE)\n            {\n                if (_DEBUG_SUBPIXEL_EDGE_RESOLVE_COSSIM)\n                {\n                    float curv = (1.0 + sign(curvature)) / 2.0;\n                    return vec3(curv, 1 - curv, 0);\n                }\n            }\n\n            if (_DEBUG_SUBPIXEL_EDGE_RESOLVE_DIRECTION)\n            {\n                return normal2color(searchDir);\n            }\n\n            // debug mode allows toggle for plane-plane or small-large normals heuristic\n            float occlusion;\n            if (_SUBPIXEL_EDGE_RESOLVE_TWO_PLANE_INTERSECTION)\n            {\n                vec2 h1 = sdf(s.position);\n                occlusion = resolve_primary_edge_visibility(normalPrimaryEdge, normalSecondaryEdge, h1.x, h2.x, rd,\n                    searchDir, _SUBPIXEL_EDGE_RESOLVE_CONE_MULT * coneRadius);\n            }\n            else\n            {\n                // compute the half angle between the two normals\n                vec3 halfAngle = (normalPrimaryEdge + normalSecondaryEdge) / length(normalPrimaryEdge + normalSecondaryEdge);\n                float halfAngleToLargeSim = dot(normalLarge.xyz, halfAngle);\n                // estimate visibility of the primary edge using the similarity between large scale and half angle normals \n                occlusion = 1.0 - 0.5 * clamp(remapGlsl(\n                    _SUBPIXEL_EDGE_RESOLVE_COSSIM_THRESHOLD_MIN,\n                    _SUBPIXEL_EDGE_RESOLVE_COSSIM_THRESHOLD_MAX,\n                    0.0,\n                    1.0,\n                    halfAngleToLargeSim\n                    ), 0.0, 1.0);\n            }\n\n            if (_DEBUG_SUBPIXEL_EDGE_RESOLVE_WEIGHT)\n            {\n                return vec3(occlusion, occlusion, occlusion);\n            }\n#else\n            vec2 h1 = sdf(s.position);\n            float occlusion = resolve_primary_edge_visibility(normalPrimaryEdge, normalSecondaryEdge, h1.x, h2.x, rd,\n                searchDir, _SUBPIXEL_EDGE_RESOLVE_CONE_MULT * coneRadius);\n#endif\n\n            // update primary sample visibility\n            samples[numSamples - 1].occlusion = occlusion;\n\n            // add secondary sample\n            sample_ctss s_r;\n            s_r.t_in = s.t_in;\n            s_r.t_out = s.t_out;\n            s_r.t_s = length(resolvedPosition - ro);\n            s_r.position = resolvedPosition;\n            s_r.id = h2.y; // this may be different from the primary edge\n            s_r.occlusion = 1.0; // full visibility, since secondary side will be sampled after primary side\n            samples[numSamples] = s_r;\n            numSamples++;\n        }\n    }\n#endif\n\n    // compute shading samples\n    for (int i = ZERO; i < numSamples; i++)\n    {\n        sample_ctss s = samples[i];\n        vec3 nor = calcNormal(s.position);\n#ifdef USE_SUBPIXEL_EDGE_RESOLVE\n        if (hasSecondaryEdge && (i == numSamples - 1)) // only the secondary side (last sample)\n            nor = normalSecondaryEdge;\n#endif\n\n#ifdef USE_CTSS_WEIGHTED\n        // project the normal from world space to camera space\n        vec2 nor2d = normalize(vec2(dot(right, nor), dot(up, nor)));\n#ifdef USE_SUBPIXEL_EDGE_RESOLVE\n        if (hasSecondaryEdge && (i == numSamples - 2)) // only the primary side (second to last sample)\n            nor2d = normal2dResolvedEdge;\n#endif\n\n        // compute current visibility mask given pixel projected normal and group's maximum cone occlusion\n        int visibilityMaskCrt = getVisibilityMask(s.occlusion, nor2d);\n        visibilityMaskCrt &= ~visibilityMask; // correlation with previous hits, removes invisible bits\n        visibilityMask |= visibilityMaskCrt; // update visibility mask given current visibility, adds visible bits\n\n        float visibility = float(bitCountOnes(visibilityMaskCrt)) / 32.; // visible bit ratio\n        float weight = max(MIN_SAMPLE_WEIGHT, visibility);\n#else\n        float weight = 1.0;\n#endif\n\n        vec3 color = shadedColor(ro, rd, rdx, rdy, s.id, s.position, nor);\n\n        colorTotal += weight * color;\n        weightTotal += weight;\n    }\n\n    // background (sky)\n    if (!hasFullHit)\n    {\n#ifdef USE_CTSS_WEIGHTED\n        float bgWeight = 1.0 - float(bitCountOnes(visibilityMask)) / 32.0;\n#else\n        float bgWeight = 1.0;\n#endif\n\n#ifdef WHITE_BG\n        colorTotal += bgWeight * vec3(1., 1., 1.);\n#else\n        colorTotal += bgWeight * vec3(clamp(FOG_COLOR - max(rd.y, 0.) * 0.3, 0., 1.));\n#endif\n        weightTotal += bgWeight;\n    }\n\n    colorTotal /= max(MIN_SAMPLE_WEIGHT, weightTotal);\n\n#ifdef DEBUG\n#ifdef DEBUG_STEPS\n    float steps = float(numSteps) / MAX_RAYMARCH_STEPS;\n    colorTotal = mix(colorTotal, steps, DEBUG_OPACITY);\n#endif\n\n#ifdef DEBUG_DEPTH\n    float depth = t / TMAX;\n    colorTotal = mix(colorTotal, depth * depth, DEBUG_OPACITY);\n#endif\n\n#ifdef DEBUG_NUM_SAMPLES\n    float v = float(numSamples) / float(CTSS_NUM_SAMPLES + 1);\n    colorTotal = mix(colorTotal, v * v, DEBUG_OPACITY);\n#endif\n#endif\n        \n    return colorTotal;\n}\n#endif\n\nvec3 pixelColor(in vec2 pixel, in vec3 ro, in vec3 ta, in float tan_theta, in float focal_length)\n{\n    vec3 color = vec3(0., 0., 0.);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.);\n\n    // ray differentials\n    vec2 px = (2. * (pixel + vec2(1., 0.)) - iResolution.xy) / iResolution.y;\n    vec2 py = (2. * (pixel + vec2(0., 1.)) - iResolution.xy) / iResolution.y;\n    vec3 rdx = ca * normalize(vec3(px, focal_length));\n    vec3 rdy = ca * normalize(vec3(py, focal_length));\n\n    int aa_factor = int(clamp(_AA_FACTOR, 1, MAX_AA_FACTOR));\n\n    for( int m=ZERO; m<aa_factor; m++ )\n    for( int n=ZERO; n<aa_factor; n++ )\n    {\n        vec2 o = vec2(float(m), float(n)) / float(aa_factor) - (0.5 - 1. / float(2 * aa_factor));\n        vec2 p = (2. * (pixel + o) - iResolution.xy) / iResolution.y;\n\n        vec3 fw = normalize(vec3(p, focal_length));\n\n        // ray direction\n        vec3 rd = ca * fw;\n\n        color += render(ro, rd, tan_theta, rdx, rdy);\n\n    }\n    color /= float(aa_factor*aa_factor);\n\n    // gain\n    color = color * 3. / (2.5 + color);\n\n    // gamma\n    color = pow(color, vec3(0.4545, 0.4545, 0.4545));\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 32. + iTime * 0.25;\n    float t = (0.5 + 0.5 * sin(2. * 6.28 * _CAMERA_SPEED * time)) * clamp(_CAMERA_SPIN, 0., 1.);\n    if (_CAMERA_STATIC)\n        t *= 0.0;\n\n    vec2 mo = iMouse.xy / iResolution.xy + vec2(-0.05, 0.15);\n\n    vec3 ta = vec3(-1.8, 0.3, 12.5);\n    vec3 ro = ta + 0.1 * vec3(sin(6.28 * (mo.x + t)), -0.1 - 1. * mo.y, cos(6.28 * (mo.x + t)));\n\n    // NOTE: sqrt(2. * dp * dp) = sqrt(2.) * dp; // dp = half pixel size\n    // NOTE: (sqrt(2.) * PIXEL_SIZE_MULT) modifies multiplier for pixel diagonal\n    float tan_theta = 2. * PIXEL_SIZE_MULT / iResolution.y / FOCAL_LENGTH;\n\n    vec3 color = pixelColor(fragCoord, ro, ta, tan_theta, FOCAL_LENGTH);\n\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Modified for use with Cone-Traced Supersampling (CTSS) by\n// Anonymous Authors, 2021\n\n//------------------------------------------------------------------\n\n// Code modified from:\n// https://www.shadertoy.com/view/Xds3zN\n// THE ORIGINAL LICENSE NOTICE:\n\n// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n// and https://iquilezles.org/articles/distfunctions\n\n//------------------------------------------------------------------\n\n#ifndef PRIMITIVES_H\n#define PRIMITIVES_H\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec3 rdX(vec3 p)\n{\n    return vec3(p.x, p.z, -p.y);\n}\n\nvec3 rdY(vec3 p)\n{\n    return vec3(-p.z, p.y, p.x);\n}\n\nvec3 rdZ(vec3 p)\n{\n    return vec3(-p.y, p.x, p.z);\n}\n\nvec3 opRepInd( in vec3 p, in vec3 c )\n{\n    return floor((p+0.5*c)/c)-0.5*c;\n}\n\nvec3 opRep( in vec3 p, in vec3 s )\n{\n    vec3 ps = p+s*0.5;\n    return sign(ps)*mod(ps,s)-s*0.5;  // sign is needed to work in all quadrants\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n// polynomial smooth min\nfloat opSmoothMin2( float a, float b )\n{\n    float k = 2.;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n//------------------------------------------------------------------\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox(in vec3 ro, in vec3 rd, in vec3 rad)\n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    return vec2(max(max(t1.x, t1.y), t1.z),\n                min(min(t2.x, t2.y), t2.z));\n}\n\nfloat sdPlane( vec3 p, float y)\n{\n    return p.y - y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sd2dBox( in vec2 p, in vec2 b )\n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n    p = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n\n    return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n               length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n            length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n            p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n    const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2\n                        0.3826834323,   // sqrt(2-sqrt(2))/2\n                        0.4142135623 ); // sqrt(2)-1\n                        // reflections\n                        p = abs(p);\n                        p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n                        p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n                        // polygon side\n                        p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n                        vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n                        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n\n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n\n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n    return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n\n    vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n    float m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n\n    // exact distance\n    #if 1\n    vec3 q;\n    if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n    #endif\n\n    // bound, not exact\n    #if 0\n    return m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, 0.0)) + vmax(min(d, 0.0));\n}\n\n// hg\nfloat fCylinder(vec3 p) {\n\tfloat d = length(p.xz) - .5;\n\td = max(d, abs(p.y) - 1.0);\n\treturn d * .5;\n}\n\n// hg\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// iq\nfloat hash(float n)\n{\n\treturn fract(sin(n)*1751.5453);\n}\n\nfloat fmod(float x, float y)\n{\n\treturn x - y * floor(x / y);\n}\n\n// hg\nvec2 pModPolar(vec2 p, float repetitions) {\n\tfloat angle = 2.0 * 3.14 / repetitions;\n\tfloat a = atan(p.y, p.x) + angle * .5;\n\tfloat r = length(p);\n\n\ta = mod(a, angle) - angle * .5;\n\treturn vec2(cos(a), sin(a)) * r;\n}\n\nstruct StackData\n{\n\tint index;\n\tfloat sdf;\n\tvec3 pos;\n};\n\n#define MAX_STACK 32\n\nvec3 modc(vec3 a, vec3 b) { return a - b * floor(a / b); }\n\nvec3 domainRepeat(vec3 p, vec3 size)\n{\n\treturn mod(abs(p) + size * .5, size) - size * .5;\n}\n\nfloat domainRepeat1D(float p, float size)\n{\n\treturn mod(abs(p) + size * .5, size) - size * .5;\n}\n\nfloat sdfOperation(float a, float b, int op)\n{\n\tfloat d = a;\n\n\tif (op == 0)\n\t\td = min(a, b);\n\telse if (op == 1)\n\t\td = max(-a, b);\n\telse if (op == 2)\n\t\td = max(a, b);\n\n\treturn d;\n}\n\n#endif\n","name":"Common","description":"","type":"common"}]}