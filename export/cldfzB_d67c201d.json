{"ver":"0.1","info":{"id":"cldfzB","date":"1702390729","viewed":76,"name":"RayTrace Project","username":"Pryexez","description":"This project is from the Master module \"Computergraphics\" of the Hochschule Darmstadt. It's based on these Tutorials:\n- https://typhomnt.github.io/teaching/ray_tracing/pbr_intro/\n- https://www.youtube.com/watch?v=gfW1Fhd9u9Q&list=PLlrATfBNZ98ed","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This project is from the Master module \"Computergraphics\" of the Hochschule Darmstadt\n// It's based on these Tutorials:\n// - https://typhomnt.github.io/teaching/ray_tracing/pbr_intro/\n// - https://www.youtube.com/watch?v=gfW1Fhd9u9Q&list=PLlrATfBNZ98edc5GshdBtREv5asFW3yXl\n// - https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl\n\n#define FLT_MAX 3.402823466e+38\n#define M_PI 3.1415926535897932384626433832795\n\n#define COLORED    0x00000001u\n#define TEXTURED   0x00000002u\n\nconst int spheresCount = 6;\nconst int materialsCount = 5;\nconst int lightCount = 2;\nconst int bounces = 4;\nconst float fov = 150.0f;\nconst float gamma = 2.2f;\nconst bool sRGB = false;\nconst float ambientvalue = 0.01f;\n\n\n\nstruct Ray {\n\nvec3 origin;\nvec3 direction;\n\n};\n\nstruct HitPayload\n\t{\n\t\tfloat HitDistance;\n\t\tvec3 WorldPosition;\n\t\tvec3 WorldNormal;\n\t\tint ObjectIndex;\n\t};\n    \nstruct Material\n{\n\tvec3 Albedo;\n    float Roughness;\n    float Metallic;\n    //float AO; // if AO is used\n    uint IsTextured;\n    int channel;\n};\n    \nstruct Sphere\n{\n\tvec3 Position;\n\tfloat Radius;\n    float spin;\n    \n    int MaterialIndex;\n}; \n\nstruct Light \n{\n    int type; // 0 dir light, 1 point light\n    vec3 dir; // directionnal light\n    vec3 center; // point light\n    float intensity; // 1 default\n    vec3 color; // light color\n};\n\nstruct Scene\n{\n\tSphere[spheresCount] Spheres;\n    Material[materialsCount] Materials;\n    Light[lightCount] Lights;\n};\n\nHitPayload ClosestHit(const Ray ray, float hitDistance, int objectIndex, const Scene scene){\n\n    HitPayload payload;\n    payload.HitDistance = hitDistance;\n    payload.ObjectIndex = objectIndex;\n\n    Sphere closestSphere = scene.Spheres[objectIndex];\n\n    vec3 origin = ray.origin - closestSphere.Position;  // Kugel zum Ursprung verschieben\n\n    payload.WorldPosition = origin + ray.direction * hitDistance; // Treffpunkt zwischen Prim채rstrahl und Kugel\n    payload.WorldNormal = normalize(payload.WorldPosition); // Normale der Kugel\n\n    payload.WorldPosition += closestSphere.Position; // Verschieben der Kugel auf eigentliche Position\n  \n    return payload;\n    \n}\n\nHitPayload Miss(const Ray ray){\n\n    HitPayload payload;\n    payload.HitDistance = -1.0f;\n\n    return payload;\n\n}\n\n\nHitPayload TraceRay(const Ray ray, const Scene scene) {\n\n\n\n    // (bx^2 + by^2 + bz^2)t^2 + (2(axbx + ayby))t + (ax^2 + ay^2 - r^2) = 0\n\n    // a = ray origin\n    // b = ray direction\n    // r = radius\n    // t = hit distance\n\n\n    int closestSphere = -1;\n    float hitDistance = FLT_MAX;\n\n    for (int i = 0; i < spheresCount; i++) {\n\n        Sphere sphere = scene.Spheres[i];\n\n        vec3 origin = ray.origin - sphere.Position;\n\n        float a = dot(ray.direction, ray.direction);\n        float b = 2.0f * dot(origin, ray.direction);\n        float c = dot(origin, origin) - sphere.Radius * sphere.Radius;\n\n        // Quadratic formula discriminant:\n        // b^2 - 4ac\n\n\n\n\n        float discriminant = b * b - 4.0f * a * c; // Pr체fen, ob es Treffer gibt\n\n        if (discriminant < 0.0f)                 // Wenn es keinen Treffer gibt\n            continue;\n\n        // (-b +- sqrt(discriminant)) / 2a\n\n        //float t0 = -b + sqrt(discriminant) / (2.0f * a);\n        float closestT = (-b - sqrt(discriminant)) / (2.0f * a); // Treffpunkt berechnen\n\n        if (closestT > 0.0f && closestT < hitDistance) {          // Pr체fen, ob Treffpunkt der n채heste ist\n            hitDistance = closestT;\n            closestSphere = i;\n\n        }\n\n    }\n\n    if (closestSphere < 0)                                        // Wenn es keinen Treffer gibt\n        return Miss(ray);\n\n    return ClosestHit(ray, hitDistance, closestSphere, scene);\n\n\n}\n\nRay lightRay(vec3 rayorigin, Light l) //computes ro to light source ray\n{\n    if(l.type == 0)\n        return Ray(rayorigin,normalize(l.dir));\n    else if(l.type == 1)\n        return Ray(rayorigin,normalize(l.center - rayorigin));\n\n    return Ray(rayorigin,vec3(1));\n }\n\nfloat lightDist(vec3 rayorigin, Light l) //computes distance to light\n{ \n    if(l.type == 0)\n         return FLT_MAX;\n    else if(l.type == 1)\n        return length(l.center - rayorigin);\n\n    return FLT_MAX;\n}\n\n\n\nvec3 PBR(HitPayload payload, Ray r, Material material, Light l, vec3 sphereColor)\n{\n    //vec3 ambient = vec3(ambientvalue) * sphereColor * (1.0 - material.AO); // if AO is used\n    vec3 ambient = vec3(ambientvalue) * sphereColor;\n    //Average F0 for dielectric materials\n    vec3 F0 = vec3(0.04);\n    // Get Proper F0 if material is not dielectric\n    F0 = mix(F0, sphereColor, material.Metallic);\n    vec3 N = normalize(payload.WorldNormal);\n    vec3 Ve = normalize(r.origin - payload.WorldPosition);\n\n    float intensity = l.intensity;\n    if(l.type == 1)\n    {\n        float l_dist = lightDist(payload.WorldPosition,l);\n        intensity /= (l_dist*l_dist);\n    }\n    vec3 l_dir = lightRay(payload.WorldPosition,l).direction;\n    vec3 H = normalize(Ve + l_dir);\n    return ambient + computeReflectance(N,Ve,F0,sphereColor,l_dir,H,l.color,intensity,material.Metallic,material.Roughness);\n}\n\n\nvec3 directIllumination(HitPayload payload, Ray r, Material material, const Scene scene, vec3 sphereColor, inout float refl)\n{\n\n    vec3 color = vec3(0);\n\n    for(int i = 0 ; i < lightCount ; i++)\n    {\n        Ray l_ray = lightRay(payload.WorldPosition,scene.Lights[i]);\n        l_ray.origin = payload.WorldPosition + 0.001*payload.WorldNormal;\n        HitPayload io = TraceRay(l_ray, scene);\n        float d_light = lightDist(payload.WorldPosition,scene.Lights[i]);\n\n        if(io.HitDistance < 0.0f)\n        {\n            color += PBR(payload,r, material,scene.Lights[i],sphereColor);\n        }\n        else\n        {\n            color +=  vec3(ambientvalue) * sphereColor;\n            //color +=  vec3(ambientvalue) * sphereColor * material.AO; // if AO is used\n        }\n\n\n        vec3 Ve = normalize(r.origin - payload.WorldPosition);\n        vec3 H = normalize(Ve + l_ray.direction);\n        \n        refl = length(fresnelSchlick(max(dot(H, Ve), 0.0),  mix(vec3(0.04), sphereColor, material.Metallic)));\n        \n        //refl = length(fresnelSchlick(max(dot(H, Ve), 0.0),  mix(vec3(0.04), sphereColor, material.Metallic)))*material.AO; // if AO is used\n    }\n\n    return color;\n}\n\n\nvec4 PerPixel(Ray ray, const Scene scene, vec3 lightpos){\n \n    vec3 color = vec3(0.0f);\n    vec3 mask = vec3(1.0f);\n\n    float multiplier = 1.0f;\n    \n    \n    for (int i = 0; i < bounces; i++) {\n\n        HitPayload payload = TraceRay(ray, scene);\n        if (payload.HitDistance < 0.0f)\n        {\n           \n            vec3 rayuv = ray.direction;\n            vec4 missColorTemp = texture(iChannel3, rayuv);\n            vec3 missColor = vec3(missColorTemp.x,missColorTemp.y,missColorTemp.z);\n            color = color + mask * missColor;\n            \n            //color = color + missColor * multiplier;\n            \n            break;\n        }\n           \n\n        Sphere sphere = scene.Spheres[payload.ObjectIndex];\n        Material material = scene.Materials[sphere.MaterialIndex];\n        vec3 sphereColor;\n        \n        if(material.IsTextured == COLORED){\n        sphereColor = material.Albedo;\n        } \n        \n        else if (material.IsTextured == TEXTURED){\n        \n        vec4 sphereColorTemp;\n        \n        \n        vec3 translateuv = payload.WorldPosition - sphere.Position;\n        \n        if(ray.direction.z < 0.0f)\n            translateuv.x = -translateuv.x;\n            \n        vec2 hituv = vec2(translateuv.x,translateuv.y);\n        hituv += 1.0f;\n        hituv /= 2.0f;\n               \n        switch (material.channel) {\n            case 0:        \n                   hituv *= 3.0f;\n                   hituv.x *= 0.20;\n                   if(sphere.spin != 0.0f){\n                        hituv.x -= iTime * sphere.spin;\n                    }\n                    sphereColorTemp = texture(iChannel0, hituv);\n                    sphereColor = vec3(sphereColorTemp.x,sphereColorTemp.y,sphereColorTemp.z);\n                break;\n            case 1:\n                    if(sphere.spin != 0.0f){\n                        hituv.x -= iTime * sphere.spin;\n                    }\n                    sphereColorTemp = texture(iChannel1, hituv);\n                    sphereColor = vec3(sphereColorTemp.x,sphereColorTemp.y,sphereColorTemp.z);\n                break;\n            case 2:\n                    hituv = vec2(translateuv.x,translateuv.z);\n                    hituv += 1.0f;\n                    hituv /= 2.0f;\n                    if(sphere.spin != 0.0f){\n                        hituv.x -= iTime * sphere.spin;\n                    }\n                    sphereColorTemp = texture(iChannel2, hituv);\n                    sphereColor = vec3(sphereColorTemp.x,sphereColorTemp.y,sphereColorTemp.z);\n                break;    \n            }\n            \n            \n        }\n        \n        \n        vec3 tempColor = directIllumination(payload,ray,material,scene, sphereColor,multiplier);\n      \n        color = color + mask * tempColor;\n        mask = mask * multiplier;\n        \n        // HDR\n        color = color / (color + vec3(1.0f));\n        \n        if(sRGB)\n            //OETF\n            color = linear_2_sRGB(color);\n        else\n            // GAMMA        \n            color = pow(color, vec3(1.0f/gamma));\n        \n        if(material.Roughness >= 1.0)\n        break;\n\n        ray.origin = payload.WorldPosition + payload.WorldNormal * 0.0001f; //reflektionsstrahl Ursprung\n        ray.direction = reflect(ray.direction,payload.WorldNormal); //reflektionsstrahl Richtung\n\n\n    }\n    \n\n\n    return vec4(color, 1.0f);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0f * fragCoord/iResolution.xy - 1.0f;\n    vec2 mousepos = 2.0f * iMouse.xy/iResolution.xy - 1.0f;\n    float aspectRatio = iResolution.x / iResolution.y;\n    float cameraDistance  = 1.0f / tan(fov * 0.5f * M_PI/ 180.0f);\n    \n     \n    \n    // Light and Ray\n    vec3 rayorigin = vec3(0,0, -1);\n    vec3 raytarget= vec3(uv, cameraDistance);\n    raytarget.y /= aspectRatio;\n    vec3 lightpos = vec3(mousepos, -1.0f);    \n    vec3 raydirection = normalize(raytarget - rayorigin);\n    \n\n\n    \n    \n    // Colors\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n      \n    Scene mainScene;\n    \n    // Lights initialization\n    Light light0;\n    light0.type = 0; // 0 dir light, 1 point light\n    light0.dir = lightpos; // directionnal light\n    light0.center = lightpos; // point light\n    light0.intensity = 1.0f; // 1 default\n    light0.color = vec3(1.0f); // light color\n    \n    Light light1;\n    light1.type = 1; // 0 dir light, 1 point light\n    light1.dir = vec3(0.0f, 1.0f, 0.0f); // directionnal light\n    light1.center = vec3(0.0f, 5.0f, 0.0f); // point light\n    light1.intensity = 20.0f; // 1 default\n    light1.color = vec3(1.0f, 0.8f, 0.5f); // light color\n    \n    mainScene.Lights[0] = light0;\n    mainScene.Lights[1] = light1;\n    \n    // Materials initialization\n    \n    Material material0;\n    material0.Albedo = vec3(1.0f,1.0f,1.0f);\n    material0.IsTextured = COLORED;\n    material0.Roughness = 0.1f;\n    material0.Metallic = 1.0f - material0.Roughness;\n    //material0.AO = 1.0f; // if AO is used\n    \n    Material material1;   \n    material1.Albedo = vec3(0.2f,0.3f,1.0f);\n    material1.IsTextured = TEXTURED;\n    material1.channel = 1;\n    material1.Roughness = 0.7f;\n    material1.Metallic = 1.0f - material1.Roughness;\n    //material1.AO = 0.2f; // if AO is used\n    \n    Material material2;\n    material2.Albedo = col;\n    material2.IsTextured = COLORED;\n    material2.Roughness = 0.5f;\n    material2.Metallic = 1.0f - material2.Roughness;\n    //material2.AO = 0.5f; // if AO is used\n    \n    Material material3;\n    material3.Albedo = vec3(1.0f);\n    material3.IsTextured = TEXTURED;\n    material3.channel = 0;\n    material3.Roughness = 1.0f;\n    material3.Metallic = 1.0f - material3.Roughness;\n    //material3.AO = 0.1f; // if AO is used\n    \n    Material material4;\n    material4.Albedo = vec3(0.5f);\n    material4.IsTextured = TEXTURED;\n    material4.channel = 2;\n    material4.Roughness = 0.9f;\n    material4.Metallic = 1.0f - material4.Roughness;\n    //material4.AO = 1.0f; // if AO is used\n   \n    \n    mainScene.Materials[0] = material0;\n    mainScene.Materials[1] = material1;\n    mainScene.Materials[2] = material2;\n    mainScene.Materials[3] = material3;\n    mainScene.Materials[4] = material4;\n    \n    // Sphere initialization\n    \n    Sphere sphere0;\n    sphere0.Position = vec3(0.0f,0.6f,2.0f);\n\tsphere0.Radius = 0.3f;\n    sphere0.MaterialIndex = 0;\n    \n    Sphere sphere1;\n    sphere1.Position = vec3(-0.4f,-0.1f,0.2f);\n\tsphere1.Radius = 0.3f;\n    sphere1.spin = -0.05f;\n    sphere1.MaterialIndex = 1;\n\n    Sphere sphere2;\n    sphere2.Position = vec3(0.0f, 0.0f,1.0f);\n\tsphere2.Radius = 0.3f;\n    sphere2.MaterialIndex = 2;\n    \n    Sphere sphere3;\n    sphere3.Position = vec3(0.7f,sin(iTime) * 0.34f,1.2f);\n\tsphere3.Radius = 0.3f;\n    sphere3.spin = 0.05f;\n    sphere3.MaterialIndex = 3;\n    \n    Sphere sphere4;\n    sphere4.Position = vec3(0.0f,-180.6f,3.0f);\n\tsphere4.Radius = 180.0f;\n    sphere4.MaterialIndex = 4;\n    \n    Sphere sphere5;\n    sphere5.Position = vec3(1.4f,0.0f,0.7f);\n\tsphere5.Radius = 0.5f;\n    sphere5.MaterialIndex = 0;\n    \n\n    \n    mainScene.Spheres[0] = sphere0;\n    mainScene.Spheres[1] = sphere1;\n    mainScene.Spheres[2] = sphere2;\n    mainScene.Spheres[3] = sphere3;\n    mainScene.Spheres[4] = sphere4;\n    mainScene.Spheres[5] = sphere5;\n    \n    Ray ray = Ray(rayorigin, raydirection);\n\n    // Output to screen\n    fragColor = PerPixel(ray, mainScene, lightpos);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.1415926535897932384626433832795\n\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvec3 linear_2_sRGB(vec3 v)\n{\n    bvec3 cutoff = lessThan(v, vec3(0.0031308));\n    vec3 higher = vec3(1.055)*pow(v, vec3(1.0/2.4)) - vec3(0.055);\n    vec3 lower = v * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\n\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0)*pow((1.0 + 0.000001/*avoid negative approximation when cosTheta = 1*/) - cosTheta, 5.0);\n}\n\nvec3 computeReflectance(vec3 N, vec3 Ve, vec3 F0, vec3 albedo, vec3 L, vec3 H, vec3 light_col, float intensity, float metallic, float roughness)\n{\n    vec3 radiance =  light_col * intensity; //Incoming Radiance\n\n    // cook-torrance brdf\n    float NDF = DistributionGGX(N, H, roughness);\n    float G   = GeometrySmith(N, Ve, L,roughness);\n    vec3 F    = fresnelSchlick(max(dot(H, Ve), 0.0), F0);\n\n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - metallic;\n\n    vec3 nominator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, Ve), 0.0) * max(dot(N, L), 0.0) + 0.00001/* avoid divide by zero*/;\n    vec3 specular     = nominator / denominator;\n\n\n    // add to outgoing radiance Lo\n    float NdotL = max(dot(N, L), 0.0);\n    vec3 diffuse_radiance = kD * (albedo)/ M_PI;\n\n    return (diffuse_radiance + specular) * radiance * NdotL;\n}","name":"Common","description":"","type":"common"}]}