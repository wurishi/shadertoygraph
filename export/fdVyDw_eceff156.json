{"ver":"0.1","info":{"id":"fdVyDw","date":"1691247104","viewed":51,"name":"Simple Scene Ray Marching","username":"afmika","description":"Simple, easy to understand ray macrhing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","scene","substract","add"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int steps = 200;\n\nmat4 rotateY(float t) {\n    float c = cos(t);\n    float s = sin(t);\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateZ(float t) {\n    float c = cos(t);\n    float s = sin(t);\n    return mat4(\n        vec4(c, -s, 0, 0),\n        vec4(s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateX(float t) {\n    float c = cos(t);\n    float s = sin(t);\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\n// shapes\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdUnion(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat sdInter(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat sdDiff(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nvec3 applyTransf(mat4 mat, vec3 p) {\n    return (mat * vec4(p, 1.)).xyz;\n}\n\nfloat sdScene(vec3 p) {\n    vec3 transf_p = applyTransf(rotateX (-iTime) * rotateY(-iTime) * rotateZ(-iTime), p); \n    return sdDiff( \n        sdUnion(\n            sdSphere(transf_p, 0.25),\n            sdDiff(sdBox(transf_p, vec3(0.8, 0.8, 0.8)), sdSphere(transf_p, 1.))\n        ),\n        sdTorus(transf_p, vec2(1, 0.5))\n     );\n}\n\n// ---\n\n\n// lightning\n// gradient of the sdf\n// sdf inside the surface < 0\n// sdf outside the surface > 0\nvec3 normalAtContact(vec3 p) {\n  float e = 0.0005; // epsilon\n  float r = 1.; // radius of sphere\n  return normalize(vec3(\n    sdScene (vec3 (p.x + e, p.y, p.z))  - sdScene (vec3 (p.x - e, p.y, p.z)),\n    sdScene (vec3 (p.x, p.y + e, p.z))  - sdScene (vec3 (p.x, p.y - e, p.z)),\n    sdScene (vec3 (p.x, p.y, p.z  + e)) - sdScene (vec3 (p.x, p.y, p.z - e))\n  ));\n}\n\n\n// Generalized Ray marching algorithm\nfloat rayMarch(vec3 camera, vec3 ray_dir, float depth_start, float depth_end) {\n    float d_traveled = depth_start;  \n    for (int i = 0; i < steps; i++) {\n        vec3 p = camera + ray_dir * d_traveled;\n        float d = sdScene (p);\n        d_traveled += d;\n        if (d < 10e-3 || d_traveled > depth_end) break;\n    }\n    return d_traveled;\n}\n\n\n// this function will iterate through each pixel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // center uv coordinate + fix aspect ratio\n    // iResolution is the canvas datas (width, height)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    // camera pos + direction\n    vec3 camera = vec3(0., 0., 3); // camera needs to be behind the screen z > 0\n    vec3 dir = normalize(vec3(uv, -1)); // ray direction\n    \n\n    float max_dist = 100.;\n    \n    // uv == 2d texture coordinates\n    // might as well call it pixel coordinate on the flat screen\n    float d_traveled = rayMarch (camera, dir, 0., max_dist); // 100 == max z\n\n    \n    vec3 col = vec3(0.1);\n    if (d_traveled <= max_dist) {\n        // --- uncomment if we want light\n        vec3 contact_point = camera + dir * d_traveled;\n        vec3 contact_normal = normalAtContact (contact_point);\n        // light pos + direction\n        vec3 light_pos = vec3(1., 1., 2.); // i.e. the sun\n        vec3 light_dir = vec3(light_pos - contact_point); // dir of the ray that hits the sphere\n        float diffuse = dot(contact_normal, light_dir);\n        float rescaled_diffuse = clamp(diffuse, 0., 1.);\n        col = vec3(rescaled_diffuse);\n        // ---\n        \n        // uncomment if no light\n        // col = vec3(0.6);\n     }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}