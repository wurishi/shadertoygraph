{"ver":"0.1","info":{"id":"4XsGWj","date":"1707928135","viewed":85,"name":"Black Hole RayTracer/RayMarcher","username":"ShaderGott420","description":"Epic blakhole (horrible code)\nSchwarzschild Metric Christoffel Symbol based geodesic/light ray Marcher\nFully General Relativity Based\nIf someone could tell me a smarter way to add a background it would be appreciated. (Rn its 6 planes)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","blackhole","singularity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 camTarget = vec3(0,0,0); // The point the camera is looking at (the center of the scene)\nvec3 camUp = vec3(0.0, 0.0, 1.0); // \"Up\" direction in world space (usually Y-up)\nfloat PlaneDist = 100.0;\nfloat camSpeed = 0.1; // Speed of the camera movement\nfloat M = 5.0; // Assuming some mass M is defined, adjust as necessary\nfloat scale = 100.0; // Scale for UV mapping\n// Calculate camera\n// Field of view and aspect ratio\nfloat fov = 90.0; // Field of view in degrees\n\nconst float INFINITY = 1.0e20;\nvec2 getUVForPlane(vec3 hitPoint, vec3 planeNormal) {\n    vec3 absNormal = abs(planeNormal);\n    vec2 uv;\n\n    // Check which plane we're dealing with based on the normal\n    if (absNormal.x > absNormal.y && absNormal.x > absNormal.z) {\n        // Left or Right plane\n        uv = hitPoint.yz;\n    } else if (absNormal.y > absNormal.x && absNormal.y > absNormal.z) {\n        // Top or Bottom plane\n        uv = hitPoint.xz;\n    } else {\n        // Front or Back plane\n        uv = hitPoint.xy;\n    }\n\n    // Now map from [-1, 1] to [0, 1]\n    uv = 0.5 * uv + 0.5;\n    return uv;\n}\nvec3 getPolar(vec3 cartesian) {\n    float r = length(cartesian); // GLSL's length function computes the magnitude of the vector\n    float delta = acos(cartesian.z / r); // GLSL uses .x, .y, .z for vector components\n    float phi = atan(cartesian.y, cartesian.x); // atan(y, x) is used instead of atan2\n\n    return vec3(r, delta, phi);\n}\nvec3 getCartesian(vec3 polar) {\n    float r = polar.x;\n    float delta = polar.y;\n    float phi = polar.z;\n    \n    float x = r * sin(delta) * cos(phi);\n    float y = r * sin(delta) * sin(phi);\n    float z = r * cos(delta);\n    \n    return vec3(x, y, z);\n}\nvoid assignChristoffelSymbols(vec3 polarCoords, out float trt, out float ttr, out float rrr, out float rtt, out float rphiphi, out float rthetatheta, out float thetartheta, out float thetathetar, out float thetaphiphi, out float phirphi, out float phiphir, out float phithetaphi, out float phiphitheta) {\n    float r = polarCoords.x; // Radial distance\n    float theta = polarCoords.y; // Polar angle\n    float phi = polarCoords.z; // Azimuthal angle (unused in the current symbols but included for completeness)\n\n\n    // Now assign each Christoffel symbol based on r, theta, and predefined M\n    trt = M / (r * (r - 2.0 * M));\n    ttr = M / (r * (r - 2.0 * M));\n    rrr = -M / (r * (r - 2.0 * M));\n    rtt = (M * (r - 2.0 * M)) / pow(r, 3.0);\n    rphiphi = -1.0 * (r - 2.0 * M) * pow(sin(theta), 2.0);\n    rthetatheta = -1.0 * (r - 2.0 * M);\n    thetartheta = 1.0 / r;\n    thetathetar = 1.0 / r;\n    thetaphiphi = -sin(theta) * cos(theta);\n    phirphi = 1.0 / r;\n    phiphir = 1.0 / r;\n    phithetaphi = 1.0 / tan(theta);\n    phiphitheta = 1.0 / tan(theta);\n}\nvec3 updateVelocity(vec3 VE, vec3 P) {\n    float r = P.x;\n    float theta = P.y;\n    float phi = P.z;\n\n    // Variables to hold the Christoffel symbols\n    float trt, ttr, rrr, rtt, rphiphi, rthetatheta, thetartheta, thetathetar, thetaphiphi, phirphi, phiphir, phithetaphi, phiphitheta;\n\n    // Assuming assignChristoffelSymbols is defined to calculate and assign Christoffel symbols\n    assignChristoffelSymbols(P, trt, ttr, rrr, rtt, rphiphi, rthetatheta, thetartheta, thetathetar, thetaphiphi, phirphi, phiphir, phithetaphi, phiphitheta);\n\n    float vr = VE.x;\n    float vtheta = VE.y;\n    float vphi = VE.z;\n\n    float dv_r = -1.0 * rrr * (vr * vr) - rphiphi * (vphi * vphi) - rthetatheta * (vtheta * vtheta);\n    float dv_theta = -1.0 * thetartheta * (vr * vtheta) - thetathetar * (vtheta * vr) - thetaphiphi * (vphi * vphi); \n    float dv_phi = -1.0 * phirphi * (vr * vphi) - phiphir * (vphi * vr) - phithetaphi * (vtheta * vphi) - phiphitheta * (vphi * vtheta); \n\n    vec3 dVE = vec3(dv_r, dv_theta, dv_phi);\n    VE += dVE;\n\n    return VE;\n}\nstruct Plane {\n    vec3 point;\n    vec3 normal;\n};\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius)\n{\n    vec3 oc = rayOrigin - sphereCenter;\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(oc, rayDirection);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n    return discriminant > 0.0;\n}\n\n// Function to check ray-plane intersection\nbool intersectPlane(vec3 rayOrigin, vec3 rayDir, vec3 planeNormal, vec3 planePoint, out float dist)\n{\n    float denom = dot(planeNormal, rayDir);\n    if (abs(denom) > 1e-6) // Prevent division by zero\n    {\n        vec3 p0l0 = planePoint - rayOrigin;\n        dist = dot(p0l0, planeNormal) / denom;\n        return (dist >= 0.0);\n    }\n    return false;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat aspectRatio = iResolution.x / iResolution.y;\n\nvec3 camPos = vec3(80.0-iTime, 0, 80.0-iTime); // Position of the camera\nbool notSingularity = true;\nfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    vec2 mouse = iMouse.xy / iResolution.xy; // Normalize mouse coordinates\n    \n    \n    // Calculate camera basis vectors inside mainImage\n    vec3 camDir = normalize(camTarget - camPos);\n   vec3 camRight = normalize(cross(camUp, camDir));\n    vec3 camUpReal = cross(camDir, camRight);\n    // Calculate FOV in radians for both axes\n    float fovYRad = radians(fov); // Vertical field of view in radians\n    float fovXRad = atan(tan(fovYRad * 0.5) * aspectRatio) * 2.0; // Horizontal FOV in radians based on aspect ratio\n    // Calculate field of view in radians\n    float fovRad = tan(radians(fov / 2.0));\n    \n   vec2 ndc = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xy * 2.0;\n    ndc.x *= aspectRatio; // Account for aspect ratio\n\n    // Calculate the ray direction from camera parameters\n   vec3 rayDir = normalize(camDir + (camRight * ndc.x * tan(fovXRad / 2.0)) + (camUpReal * ndc.y * tan(fovYRad / 2.0)));\n\n    // Use this ray direction with the camera's position to cast rays into the scene\n    vec3 rayOrigin = camPos;\n\n    // Use this ray direction with the camera's position to cast rays into the scene\n    vec3 rayMarchedPosition = camPos;\n    float marchDistance = 0.0;\n    rayDir = normalize(rayDir); // Normalize the direction\n    // Sphere definition\n    vec3 sphereCenter = vec3(0.0, 0.0, 0); // Sphere at origin\n    float sphereRadius = 2.0*M;\n    bool uRayMarchingActive = true;\n    // Skybox planes\n    Plane planes[6];\n    planes[0] = Plane(vec3(0, 0, -5), vec3(0, 0, PlaneDist)); // Back\n    planes[1] = Plane(vec3(0, 0, 5), vec3(0, 0, -PlaneDist)); // Front\n    planes[2] = Plane(vec3(-5, 0, 0), vec3(PlaneDist, 0, 0)); // Left\n    planes[3] = Plane(vec3(5, 0, 0), vec3(-PlaneDist, 0, 0)); // Right\n    planes[4] = Plane(vec3(0, 5, 0), vec3(0, -PlaneDist, 0)); // Top\n    planes[5] = Plane(vec3(0, -5, 0), vec3(0, PlaneDist, 0)); // Bottom\n    float a = 001.0;\n    float k = 60000.0; // Semicolon added here\n    vec3 rayMarchedVelocity = getPolar(rayMarchedPosition + rayDir/(30.0)) - getPolar(rayMarchedPosition);\n    if(true){\n        //Prolly gon do some polar Transformations.\n            \n         \n            rayMarchedPosition = getPolar(rayMarchedPosition);\n            rayMarchedPosition.x *=a;\n            for(float i = 0.0; i < k; i++) {\n            \n            \n            rayMarchedVelocity = updateVelocity(rayMarchedVelocity,rayMarchedPosition);\n            rayMarchedPosition += rayMarchedVelocity;\n            if(rayMarchedPosition.x <= 2.1*M*a ){\n                notSingularity = false;\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                break;\n            }\n            if(dot(getCartesian(rayMarchedPosition+rayMarchedVelocity)-getCartesian(rayMarchedPosition),-getCartesian(rayMarchedPosition))<0.0){\n                break;\n            }\n\n\n            /*\n            vec3 camPosPol = getPolar(camPos);\n            if((rayMarchedPosition.x/a > PlaneDist)){\n            if(!(camPosPol.x < PlaneDist)){break;\n            }\n             \n            }*/\n                \n\n\n            // Do something with bonkers\n            }\n            rayMarchedPosition.x /=a;\n    }\n    if (notSingularity) {\n    rayOrigin = getCartesian(rayMarchedPosition);\n    rayDir = normalize(getCartesian(rayMarchedPosition+rayMarchedVelocity)-getCartesian(rayMarchedPosition));\n    \n    // Check for sphere intersection first\n    bool hitSphere = intersectSphere(rayOrigin, rayDir, sphereCenter, sphereRadius);\n\n    // If the ray hits the sphere, render it black\n    if (false) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n    // If the ray does not hit the sphere, check for plane intersections\n    float closestT = INFINITY;\n    vec2 uv;\n    int hitPlaneIndex = -1;\n\n     for (int i = 0; i < 6; i++) {\n        float t;\n        if (intersectPlane(rayOrigin, rayDir, planes[i].point, planes[i].normal, t)) {\n            if (t < closestT) {\n                closestT = t;\n                hitPlaneIndex = i;\n                vec3 hitPoint = rayOrigin + rayDir * t;\n                // Calculate UVs based on which plane is hit\n                // You need to adjust this logic depending on your skybox setup\n                uv = hitPoint.yz; // This is an example, use the correct plane axis\n            }\n        }\n    }\n    uv = fract(uv); // Wrap UV coordinates to avoid tiling artifacts\n    \n    // Sample the texture based on the plane that was hit\n    if (hitPlaneIndex != -1) {\n    // Adjust the hit point to be relative to the center of the box\n    vec3 hitPointRelative = rayOrigin + rayDir * closestT - planes[hitPlaneIndex].point;\n    uv = getUVForPlane(hitPointRelative, planes[hitPlaneIndex].normal);\n    uv /= scale; // Apply any additional scaling to UVs if necessary\n\n    // Now use the uv to sample the texture\n    fragColor = texture(iChannel1, uv); // Use the correct texture channel\n} else {\n    // No intersection with any plane\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n    if(!notSingularity){\n    fragColor = vec4(0, 0, 0, 0);\n        }\n}\n}\n\n/*\nenter that in the web console for cartesian grid bg\ngShaderToy.SetTexture(1, {mSrc:'https://www.dl.dropboxusercontent.com/scl/fi/oxhi3xkvj9njkvkjcvldt/4-Best-5-By-5-Grid-Printable-PDF-for-Free-at-Printablee.jpg?rlkey=ng4qbw3oc8fybkyakr47m6yom&dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n","name":"Image","description":"","type":"image"}]}