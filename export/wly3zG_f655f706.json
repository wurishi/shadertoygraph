{"ver":"0.1","info":{"id":"wly3zG","date":"1579192116","viewed":72,"name":"My first RayMarcher","username":"Lamashnikov","description":"My first raymarcher using GLSL\n\nFramerate is awfull, so don't hesitate if you have any suggestion about how to optimise this shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 100\n#define NORMAL_EPSILON 0.01\n\nstruct Camera {\n \tvec3 lookat;\n    vec3 pos;\n};    \n    \nfloat SphereSDF(vec3 pos, vec3 point, float radius)\n{\n \treturn (length(point- pos) - radius);   \n}\n\nfloat planeSDF(float posY, vec3 point)\n{\n \treturn (point.y - posY);   \n}\n\nmat4 getRotationMatY(float angle)\n{\n    return mat4 (\n        vec4(cos(angle),0,sin(angle),0),\n        vec4(0,1,0,0),\n        vec4(-sin(angle),0,cos(angle),1),\n        vec4(0,0,0,1)\n        );\n}\n\nmat4 getRotationMatX(float angle)\n{\n \treturn mat4 (\n\t\tvec4(1, 0         ,0           ,0),\n        vec4(0, cos(angle), -sin(angle),0),\n        vec4(0, sin(angle), cos(angle),0),\n        vec4(0, 0          ,0          ,1)\n    );\n}\n\nvec3 rotateX(vec3 pos, float angle)\n{\n    \n \treturn vec3(inverse(getRotationMatX(angle)) * vec4(pos,1.)\n               ).xyz;   \n}\n\nvec3 rotateY(vec3 pos, float angle)\n{\n \treturn vec3(\n        inverse(getRotationMatY(angle))* vec4(pos,1.) \n        ).xyz;   \n}\n\nfloat SceneSDF(vec3 pos)\n{\n    float dist =  SphereSDF((vec3(0.,0.,0.)), pos, 1.);\n    dist = min(dist,  SphereSDF(\n\t\t\t\t\t\t\t\trotateY( vec3(-3,.5,0),iTime)\n        \t\t\t\t\t\t\t, pos, 1.));\n    dist = min(dist,  SphereSDF(\n                                 rotateY(vec3(-6,-.5,0), 2. * iTime)\n        \t\t\t\t\t\t\t, pos, 1.));\n\n    dist = min(dist, planeSDF(-2.,pos));\n    return dist;\n}\n\nvec3 getNormal(vec3 point)\n{\n    vec3 normal;\n    \tnormal.x = SceneSDF(vec3(point.x + NORMAL_EPSILON, point.yz)) - SceneSDF(vec3(point.x - NORMAL_EPSILON, point.yz));\n        normal.y = SceneSDF(vec3(point.x, point.y + NORMAL_EPSILON, point.z)) - SceneSDF(vec3(point.x, point.y - NORMAL_EPSILON, point.z));\n\t\tnormal.z = SceneSDF(vec3(point.xy, point.z + NORMAL_EPSILON)) - SceneSDF(vec3(point.xy, point.z -NORMAL_EPSILON));\n    return normalize(normal);\n}\n\nfloat lightIntensitie(vec3 vertice, vec3 lightPos)\n{\n    return (max(0.,dot(normalize(lightPos - vertice), getNormal(vertice) )));\n}\n\nvec2 normalizeScreenCoordinate(vec2 coordinate)\n{\n    vec2 uv = (coordinate - (iResolution.xy /2.))/ iResolution.xy;\n\tuv.y *= (iResolution.y / iResolution.x);\n    return uv;\n}\n\nbool lightMarching(vec3 lightPos, vec3 vertex)\n{\n    float distanceToPoint;\n    vec3 pos = lightPos;\n    vec3 dir = normalize(vertex - lightPos);\n\n \t  for (int i = 0 ; i < MAX_STEP ; ++i) {\n    \t  distanceToPoint = SceneSDF(pos);\n          if(distanceToPoint < 0.01 )\n            return (length(pos-vertex) < 0.3) ? true : false;\n        pos += distanceToPoint * dir;\n     } \n    return true;\n}\n\n\n\nvec3 rayMarching(Camera camera)\n{\n    float distanceToPoint;\n    vec3 pos = camera.pos;\n    \n \t  for (int i = 0 ; i < MAX_STEP; ++i) {\n    \t  distanceToPoint = SceneSDF(pos);\n          if(distanceToPoint < 0.01)\n            return pos;\n        pos += distanceToPoint * camera.lookat;\n     } \n    return camera.pos;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = normalizeScreenCoordinate(fragCoord);\n    vec3 lightPos = vec3(0.,4.,0.); \n    vec3 ambiantLight = vec3(0., .3 ,0.) ;\n    \n    Camera camera;\n    camera.pos = rotateX(vec3(0., 1., -20.), radians(20.));      \n    camera.lookat = rotateX(normalize(vec3(uv, 1.)), radians(20.));\n   \n        \n    vec3 vertex = rayMarching(camera);\n\n    if (vertex == camera.pos){\n       fragColor = vec4(.01,0.,.05,1.);\n    } else if(lightMarching(lightPos, vertex) == false) {\n          fragColor = vec4(ambiantLight ,1.);\n    } else {\n        fragColor = vec4(\n            vec3(0.,1.,0.) * lightIntensitie(vertex, lightPos) + ambiantLight\n            ,1.);\n    }\n    \n    \n    \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2)); // gamma value de l'écran j'ai rien bité\n\n}","name":"Image","description":"","type":"image"}]}