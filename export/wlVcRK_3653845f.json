{"ver":"0.1","info":{"id":"wlVcRK","date":"1611356942","viewed":43,"name":"pattern practice - 2 ","username":"Many","description":"shader pattern practice","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["patternpractice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n#define S(a,b,t) smoothstep(a,b,t)\n#define R1 abs(sin(iTime))\n#define R2 abs(cos(iTime))\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.)-_st);\n    return uv.x*uv.y;\n}\n\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n    float d = length(uv - p);\n    float c = S(r,r-blur,d);\n    \n    return c;\n}\n\nvec2 rotateTilePattern(vec2 _st){\n\n    _st *= 2.;\n    \n    float index = .0;\n    index += step(1.,mod(_st.x,2.0));\n    index += step(1.,mod(_st.y,2.)) *4.0;\n    \n    _st = fract(_st);\n   \n    vec2 origin = _st;\n        \n    if(index == 1.){\n        _st = rotate2D(_st,PI * .5);\n        //_st.y = origin.y + .4;\n    }else if(index == 2.){\n        _st = rotate2D(_st,PI * -.5);\n        //_st.y = origin.y - .4;\n    }else if(index == 3.){\n        _st = rotate2D(_st,PI);\n        //_st.y = origin.y + .6;\n    }\n    \n    return _st;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    uv = tile(uv,4.);\n    uv = rotateTilePattern(uv);\n    \n    float ran = random(vec2(.5,.5));\n    \n    uv = tile(uv, 2.);\n    uv = rotate2D(uv,-PI*iTime*0.25);//rotateTilePattern(uv);\n    \n    uv.y -= sin (iTime) * .5;\n    \n    float rect = box(uv,vec2(1.,1. * ran),.001);\n    //float c = Circle(uv, vec2(0.1,.5),.3,.0001);\n    //rect += box(uv,vec2(.2,1.),.001);\n    //rect += c;\n    col =  mix(vec3(1.,R1,R2),vec3(0.2,R1,R2),vec3(rect));//vec3(step(uv.x,uv.y));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}