{"ver":"0.1","info":{"id":"slBBzK","date":"1652429021","viewed":83,"name":"Catch snorflex","username":"benoitdef","description":"Catch the snorflex by clicking on the screen","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["pokemonsnorflex3dpokeball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////Explanations////////////////////////////////////\n// Click on snorflex to catch it\n// Made by Benoit Defossez & Kevin Gallus\n// Thanks to Christian Sandor for making us discover the infographic\n// Thanks to Inigo Quilez for explaining how to make 3d shapes on his site \n// More information here: https://iquilezles.org/articles/distfunctions\n////////////////////////////////////////////////////////////////////////////\n\nmat3 rotationMatrix_Y(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,0,s),\n        vec3(0,1,0),\n        vec3(-s,0,c)\n    );\n}\n\nmat3 rotationMatrix_X(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,c,-s),\n        vec3(0,s,c)\n    );\n}\n\nmat3 rotationMatrix_Z(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,-s,0),\n        vec3(s,c,0),\n        vec3(0,0,1)\n    );\n}\n\nvec3 rotateY(vec3 p, float theta)\n{\n    return p*rotationMatrix_Y(theta);\n}\n\nvec3 rotateX(vec3 p, float theta)\n{\n    return p*rotationMatrix_X(theta);\n}\n\nvec3 rotateZ(vec3 p, float theta)\n{\n    return p*rotationMatrix_Z(theta);\n}\n\n// ---------------------------------------------\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\n\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTwistedBox( vec3 p, vec3 b )\n{\n    vec3 q = rotateY(p,p.y*5.0);\n    return sdBox(q,b);\n}\n\nfloat sdLiquidBox( vec3 p, vec3 b )\n{\n    float d = sdBox(p,b);\n    float noise = 0.05*sin(200.0*p.x) * sin(20.0*p.y)*sin(20.0*p.z);\n    return d+ noise;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n    float q = length(p.xz);\n    return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdLiquidCone( vec3 p, vec2 c, float h )\n{\n    float q = length(p.xz);\n    float noise = 0.05*sin(5.0*p.x) * sin(15.0*p.y)*sin(15.0*p.z);\n    float d =max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n    return d + noise;\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h)\n{\n    vec2 d = vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for a given shape\n    \n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n\n    return (s<0.0) ? length(q)-r :\n           (q.x<w) ? h - q.y     :\n                     length(q-vec2(w,h));\n}\n\n//---------------------------------\nfloat map(in vec3 pos, out int material)\n{\n    float t = iTime;\n    vec3 q = pos - vec3(0.2,0.0,1.0-1.0*abs(cos(t/2.)));\n    \n    //### SNORFEX ###//\n    \n    // Body\n    vec3 r = q + vec3(0.0,-0.5,-0.7);    \n    float d1 = sdEllipsoid( r, vec3(0.6,0.5,0.5));\n    r = q + vec3(0.0,-0.3,-0.7);    \n    float d2 = sdEllipsoid( r, vec3(0.7,0.5,0.5));\n\n    float corps = opSmoothUnion(d1,d2,0.1);\n\n    // Interior body\n    r = q + vec3(0.0,-0.5,-0.9);    \n    float int_d1 = sdEllipsoid( r, vec3(0.5,0.4,0.4));\n    r = q + vec3(0.0,-0.35,-0.9);    \n    float int_d2 = sdEllipsoid( r, vec3(0.55,0.4,0.4));\n\n    float int_corps = opSmoothUnion(int_d1,int_d2,0.1);\n\n    // Arms (symetric)\n    vec3 r_g = vec3(abs(q.x)-0.55,q.y-0.85,q.z-0.9);  \n    r_g = rotateZ(r_g, 0.5); \n    r_g = rotateY(r_g, 0.7); \n    float bras = sdEllipsoid(r_g, vec3(0.4,0.1,0.2));\n\n    corps = opSmoothUnion(corps,bras,0.1);\n\n    // Head\n    r = q + vec3(0.0,-1.2,-0.7); \n    r = rotateY(r,0.314*sin(iTime));\n    float d3 = sdEllipsoid( r, vec3(0.35,0.3,0.3));\n\n    // Interior head\n    r = q + vec3(0.0,-1.2,-0.8);    \n    r = rotateY(r,0.314*sin(iTime));\n    float int_tete = sdEllipsoid( r, vec3(0.28,0.23,0.3));\n\n    // Mouth\n    r = q + vec3(0.0,-1.18,-0.81);\n    r = rotateY(r,0.314*sin(iTime));\n    float bouche = sdEllipsoid( r, vec3(0.25,0.13,0.3));\n\n    // Eyes (symetric)\n    r = vec3(abs(q.x)-0.1,q.y-1.3,q.z-1.);   \n    r = rotateX(r,0.314*sin(iTime));\n    float yeux = sdEllipsoid( r, vec3(0.09,0.01,0.08));\n    \n    // Ears (symetric)\n    vec3 r1 = vec3(abs(q.x)-0.3,q.y-1.52,q.z-0.7);    \n    r1 = rotateZ(r1, 0.6);\n    float oreilles = sdCone(r1, vec2(0.2,0.15), 0.15);\n\n    float tete = opSmoothUnion(d3,oreilles,0.002);\n    float tete_corps = opSmoothUnion(tete,corps,0.1);\n\n    // Feet\n    r_g = vec3(q.x-0.3,q.y+0.15-0.1*abs(sin(t)),q.z-1.-.1*abs(sin(t/4.))); \n    r_g = rotateX(r_g, abs(sin(t)));\n    float pied_g = sdRoundedCylinder(r_g, 0.1, 0.05, 0.01);\n\n    r_g = vec3(q.x+0.3,q.y+0.15-0.1*abs(cos(t)),q.z-1.-.1*abs(cos(t/4.))); \n    r_g = rotateX(r_g, abs(cos(t)));\n    float pied_d = sdRoundedCylinder(r_g, 0.1, 0.05, 0.01);\n\n    //Pokeball\n    q = pos - vec3(0.2,0.-0.2*sin(t*5.),1.0+0.3*cos(t/2.));   \n    if(iMouse.z > 0.0){ // --> Click\n        if (sin(t/3.)> 0.0) { // Show pokeball in movement\n            r = q + vec3(7.0* sin(t/3.),-0.2,2.0*sin(t/3.));\n            r = rotateZ(r,cos(t)*5.5);\n        \n        } else { // Show capturing pokeball\n            r = q + vec3(0.0,-0.2,-1.0);\n            r = rotateZ(r,sin(t*3.)/1.5);\n        }\n    }\n    else { // Turn on himself\n        r  = q + vec3(1.0,-0.2,-1.0);\n        r = rotateX(r,-iTime*5.);\n    }\n    \n    float toppoke =  sdCutSphere( r, 0.2, 0.0 );\n    float disk = sdRoundedCylinder(r, 0.1, 0.1, 0.003);\n    r = rotateZ(r,3.14);\n    float botpoke =  sdCutSphere( r, 0.2, 0.0 );\n    \n    // Disks in front of pokeball\n    if(iMouse.z > 0.0){// -> Click\n        if (sin(t/3.)> 0.0) { // Follow the movement of the pokeball\n            r = q + vec3(7.0* abs(sin(t/3.)),-0.2,-0.2+2.0*abs(sin(t/3.)));    \n        } else { //Stay in front\n            r = q + vec3(0.0,-0.2,-1.21);\n        }\n    }\n    else{\n        // Turn around the pokeball\n        r = q + vec3(1.0,-0.25-0.2*sin(t*5.),-1.1+0.2*(cos(t*5.))); \n        r = rotateX(r, -iTime*5.);\n    }\n    r = rotateX(r, 3.14/2.);\n    float rondelle = sdRoundedCylinder(r, 0.022, 0.01, 0.002);\n    float in_disk = sdRoundedCylinder(r, 0.02, 0.01, 0.003);\n    \n    // Floor\n    r = pos - vec3(0.,-0.25,0.);\n    float floor = sdBox(r, vec3(3.6,0.02,10.7));\n    \n    // Tree\n    r = vec3(abs(pos.x)-1.-0.8,pos.y-.4,mod(pos.z + mod(t,3.),3.));\n    float tronc = sdRoundedCylinder(r,.1,.2,.6); \n    r = r - vec3(0.,0.8,0.);\n    float feuille_1 = sdLiquidCone(r,vec2(.3,.3),.8);\n    r = r - vec3(0.,0.4,0.);\n    float feuille_2 = sdLiquidCone(r,vec2(.3,.2),.8);\n\n    // Union object\n    float ronflex = opUnion(pied_g,tete_corps);\n    ronflex = opUnion(pied_d,ronflex);\n    ronflex = opUnion(ronflex,int_corps);\n    float visage = opUnion(yeux,bouche);\n    ronflex = opUnion(ronflex,visage);\n    ronflex = opSmoothUnion(ronflex,int_tete,0.001);\n    float pokeball = opUnion(toppoke,botpoke);\n    pokeball = opUnion(pokeball,disk);\n    pokeball = opUnion(pokeball,in_disk);\n    pokeball = opUnion(pokeball,rondelle);\n    float dt = pokeball;\n    if(iMouse.z > 0.0){ // Click -> show capturing snorfex\n        if (sin(t/3.)> 0.0) {\n            dt = opUnion(ronflex,dt);\n        } \n    }\n    else{\n        dt = opUnion(ronflex,dt);\n    }\n    dt = opUnion(floor,dt);\n    dt = opUnion(dt,tronc);\n    dt = opUnion(dt,feuille_1);\n    dt = opUnion(dt,feuille_2);\n\n    // Materials\n    if(tete_corps == dt) {\n        material = 1;\n    } else if(pied_g == dt || pied_d == dt || int_corps == dt || int_tete == dt) {\n        material = 2;\n    } else if(visage == dt || disk == dt || rondelle == dt) {\n        material = 4;\n    } else if (toppoke == dt || (in_disk == dt && sin(iTime*6.0)>0.0 && sin(t/3.)< 0.0 && iMouse.z > 0.0)){\n        material = 5;\n    } else if (floor == dt){\n        material = 6;\n    } else if (tronc == dt){\n        material = 7;\n    } else if (feuille_1 == dt || feuille_2 == dt){\n        material = 8;\n    }else {\n        material =-1;\n    }\n    \n    return dt;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    int mat = 0;\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, mat ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, mat ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, mat ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, mat ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    int mat = 0;\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, mat);\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    // 1 Set up the camera (primar way) \n   vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y; \n   //center of screen: (0,0)\n   //dimensions: +/- 0.5\n \n   vec3 ro = vec3(0.0,3.2,9.8);\n   vec3 rd = normalize(vec3(p-vec2(0.1,1.9),-6.));\n\n    // Colors\n    vec3 uglyGreen = vec3(0,0.4,0.4);\n    vec3 beige = vec3(1,0.90,0.75);\n    vec3 brown = vec3(0.5,0.25,0.0);\n    vec3 dark_brown = vec3(0.2,0.1,0.05);\n    vec3 white = vec3(1.,1.,1.0);\n    vec3 black = vec3(0.0);\n    vec3 red = vec3(1.0,0.0,0.0);\n    vec3 blue = vec3(0.315,0.445,1.);\n    vec3 green = vec3(0.1,0.8,.1);\n\n    // 2 Raymarching\n   float t = 7.0;\n   int mat = 0;\n   for( int i=0; i<128; i++ )\n   {\n\tvec3 p = ro + t*rd;\n\tfloat h = map(p, mat);\n\tif( abs(h)<0.0001 || t>150.0 ) break;\n\tt += h;\n   }\n   \n   vec3 col=vec3(0.8,0.6,0.7);\n\n    // Shading\n   if( t<150.0 )\n   {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n        float dif = clamp(dot(nor,lig),0.0,1.0);\n        float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n        float amb = 0.5 + 0.5*nor.y;\n        col = vec3(0.05,0.1,0.15)*amb + vec3(1.00,0.9,0.80)*dif*sha;\n        \n        if(mat == 1) {\n            col *= uglyGreen;\n        } else if(mat == 2) {\n            col *= beige;\n        } else if(mat == 3) {\n            col *= brown;\n        } else if(mat == 4) {\n            col *= black;\n        } else if (mat == 5){\n            col*=red;\n        } else if (mat == 6){\n            col*=brown;\n        } else if (mat == 7){\n            col*= dark_brown;\n        } else if (mat == 8){\n            col*= green;\n        } else {\n            col *= white;\n        }\n   }\n\n    col = sqrt( col );\n    tot += col;\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}