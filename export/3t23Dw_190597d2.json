{"ver":"0.1","info":{"id":"3t23Dw","date":"1559790233","viewed":140,"name":"evankh_Cubemap","username":"evankh","description":"Testing how to make and use cubemaps","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphere","cubemap","rayintersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool intersects(vec3 center, float radius, vec3 origin, vec3 direction) {\n    vec3 L = center - origin;\n    float tca = dot(L, direction);\n    float d = dot(L,L) - tca * tca;\n    return (d >= 0.) && (d <= radius * radius);\n}\n\nvec3 intersection(vec3 center, float radius, vec3 origin, vec3 direction) {\n    vec3 L = center - origin;\n    float tca = dot(L, direction);\n    float d = dot(L,L) - tca * tca;\n    float t0 = tca - sqrt(radius * radius - d);\n    return origin + t0 * direction;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    // Ray casting - seems way more complicated than necessary\n    vec3 spherePos = vec3(0.0); float sphereRad = 1.0;\n    vec3 cameraPos = vec3(5.0,5.0,0.5), cameraAt = vec3(0.0), cameraDir = normalize(cameraAt - cameraPos), cameraUp = vec3(0.0,0.0,1.0), cameraRight = cross(cameraDir, cameraUp);\n    vec3 ray = normalize(uv.x*cameraRight + uv.y*cameraUp + cameraDir);\n    if (intersects(spherePos, sphereRad, cameraPos, ray)) {\n        vec3 norm = normalize(intersection(spherePos, sphereRad, cameraPos, ray) - spherePos);\n        ray = reflect(ray, norm);\n    }\n    \n    // Time varying pixel color\n    vec3 col = texture(iChannel0, ray).xyz;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"const vec3 walls = vec3(0.2);\nconst float wallShadowSize = 0.9;\nconst float wallShadowStrength = 0.1;\nconst float checkColors = 2.0;\nconst vec3 check1 = vec3(1.0, 0.5, 0.0);\nconst vec3 check2 = vec3(0.0, 0.5, 1.0);\nconst vec3 lightPos = vec3(-5.0, 5.0, 3.0);\n\nfloat Max(vec3 vec) {\n    return max(max(vec.x, vec.y), vec.z);\n}\n\nfloat Clamp(float val, float zeroBound, float oneBound) {\n    return clamp(val / (oneBound - zeroBound) - zeroBound / (oneBound - zeroBound), 0., 1.);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    \n    // Default background\n    vec3 col = walls;\n    \n    // Some background variation\n    if (all(lessThan(abs(rayDir), vec3(wallShadowSize))))\n        col += wallShadowStrength*Max(abs(rayDir) - wallShadowSize);\n    \n    // Checkerboard floor\n    if (rayDir.z < 0.0) {\n        vec2 uv = floor(rayDir.xy / rayDir.z);\n        float i = mod(uv.x + uv.y, checkColors) / (checkColors - 1.);\n        // Blur in distance\n        i = mix(0.5, i, Clamp(-rayDir.z, 0.01, 0.125));\n        col = mix(check1, check2, i);\n    }\n    \n    // Light\n    if (dot(rayDir, normalize(lightPos)) > 0.99)\n        col = vec3(1.0);\n    \n    // Output to cubemap\n    fragColor = vec4(col, 1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}