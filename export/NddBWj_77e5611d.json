{"ver":"0.1","info":{"id":"NddBWj","date":"1657221131","viewed":108,"name":"WEREM: Raymarched Liquid Metal","username":"weremsoft","description":"raymarched reflections","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["reflectionsraymarching"],"hasliked":0,"parentid":"ssdfzj","parentname":"WEREM:Raymarched Reflections"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define MIN_DIST .01\n\n#define TAU 6.283185\n#define PI 3.141592\n#define PI2 1.5707\n\n#define MAT_DEFAULT 0\n#define MAT_CHECKERS 1\n#define MAT_MIRROR 2\n#define MAT_GOLD 3\n\n\n#define R 3. + sin(iTime)\n\nstruct Camera\n{\n    vec3 position;\n    vec3 direction;\n    vec3 lookAt;\n};\n\nfloat smoothMin(float a, float b, float ratio)\n{\n    float h = clamp( .5 + .5 * (b - a)/ratio, 0., 1.);\n    return mix(b, a, h) - ratio * h * (1. - h);\n}\n\nmat2 getRotationMatrix(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat getDist2Box(vec3 p, vec3 size, float rotation)\n{\n    p.xz *= getRotationMatrix(rotation);\n\n    return length(max(abs(p)-size, 0.));\n}\n\nfloat getDist2Sphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n\n\nconst float sphereRadius = 1.5;\n\nfloat getDistance(vec3 p)\n{\n    float r = R;\n\n    float floorD = p.y + 4.;\n   \n    float angle = 0.;\n    float angleIncrement = TAU / 6.;\n\n    // distance to sphere\n    vec3 sphere = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds = getDist2Sphere(p - sphere, sphereRadius);\n    angle += angleIncrement;\n\n    // distance to sphere2\n    vec3 sphere2 = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds2 = getDist2Sphere(p - sphere2, sphereRadius);\n    angle += angleIncrement;\n\n    // distance to sphere3\n    vec3 sphere3 = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds3 = getDist2Sphere(p - sphere3, sphereRadius);\n    angle += angleIncrement;\n\n    \n    // distance to sphere4\n    vec3 sphere4 = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds4 = getDist2Sphere(p - sphere4, sphereRadius);\n    angle += angleIncrement;\n\n    // distance to sphere5\n    vec3 sphere5 = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds5 = getDist2Sphere(p - sphere5, sphereRadius);\n    angle += angleIncrement;\n    \n    // distance to sphere6\n    vec3 sphere6 = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds6 = getDist2Sphere(p - sphere6, sphereRadius);\n    \n    float boxDistance = getDist2Box(p-vec3(0., 1., 0.), vec3(.75), -iTime);\n\n    float fussionRatio = .5;\n\n    return smoothMin(smoothMin(smoothMin(smoothMin(smoothMin(smoothMin(smoothMin(ds, floorD, fussionRatio), boxDistance, fussionRatio), ds2, fussionRatio), ds3, fussionRatio), ds4, fussionRatio), ds5, fussionRatio), ds6, fussionRatio);\n}\n\nint getMaterial(vec3 p)\n{\n    float floorD = p.y + 4.;\n    \n    float r = R;\n    \n    float angle = 0.;\n    float angleIncrement = TAU / 6.;\n   \n    // distance to sphere\n    vec3 sphere = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds = getDist2Sphere(p - sphere, sphereRadius);\n    angle += angleIncrement;\n\n    // distance to sphere2\n    vec3 sphere2 = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds2 = getDist2Sphere(p - sphere2, sphereRadius);\n    angle += angleIncrement;\n\n    // distance to sphere3\n    vec3 sphere3 = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds3 = getDist2Sphere(p - sphere3, sphereRadius);\n    angle += angleIncrement;\n\n    \n    // distance to sphere4\n    vec3 sphere4 = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds4 = getDist2Sphere(p - sphere4, sphereRadius);\n    angle += angleIncrement;\n\n    // distance to sphere5\n    vec3 sphere5 = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds5 = getDist2Sphere(p - sphere5, sphereRadius);\n    angle += angleIncrement;\n    \n    // distance to sphere6\n    vec3 sphere6 = vec3(sin(iTime+angle)*r, 1., cos(iTime+angle)*r);\n    float ds6 = getDist2Sphere(p - sphere6, sphereRadius);\n    \n    float boxDistance = getDist2Box(p-vec3(0., 1., 0.), vec3(.75), -iTime);\n    \n    float d = min(min(min(min(min(min(min(ds, floorD), boxDistance), ds2), ds3), ds4), ds5), ds6);\n    \n    if(d == floorD)\n        return MAT_CHECKERS;\n        \n    if(d == boxDistance)\n        return MAT_DEFAULT;    \n        \n        \n    return MAT_MIRROR;\n}\n\n// Stable softshadow function from https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = getDistance(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.);\n    \n    float d = getDistance(p);\n    \n    vec3 n = d - vec3(\n        getDistance(p - e.xyy), \n        getDistance(p - e.yxy),\n        getDistance(p - e.yyx));    \n    \n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    \n    float dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dl = getDistance(ro + rd * dO);\n        dO += dl;\n        if(dl < MIN_DIST || dO > MAX_DIST) break;\n    }\n\n    return dO;\n}\n\nfloat getLight(vec3 p)\n{\n    vec3 lightPosition = vec3(-1., 5., 6.);\n    \n    float lightMoveRadius = 7.;\n    \n    vec3 lightDirection = normalize(lightPosition - p);\n    \n    vec3 n = getNormal(p);\n    \n    float angleNormLight = dot(lightDirection, n);\n    \n    float distanceToLight = rayMarch(p + n * .1, lightDirection);\n    \n    float shadow = softshadow(p, lightDirection, 0.01, 100., 8.);\n    \n    return angleNormLight * shadow;\n}\n\nfloat checkers ( in vec3 p ) {\n    vec2 w = fwidth( p.xz );\n    vec2 i = 2.0*(abs(fract((p.xz-0.5*w)/2.0)-0.5)-abs(fract((p.xz+0.5*w)/2.0)-0.5))/w;\n    return 0.5-0.5*i.x*i.y;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l - p),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         u = cross(f, r),\n         c = f * z,\n         i = c + uv.x * r + uv.y * u,\n         d = normalize(i);\n    return d;\n}\n\n\nCamera getCamera(vec2 screenPosition, float zoomFactor)\n{\n    vec2 mousePosition = iMouse.xy / iResolution.xy;\n\n    Camera camera;\n    camera.position = vec3(0, 1., -10.);\n    camera.lookAt = vec3(0, 0, 0);\n\n    camera.position.yz *= getRotationMatrix(-mousePosition.y * PI + 1.);\n    camera.position.xz *= getRotationMatrix(-mousePosition.x * TAU);\n    camera.direction = GetRayDir(screenPosition*zoomFactor, camera.position, camera.lookAt, 1.);\n    return camera;\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout float reflectivity)\n{\n    \n    float d = rayMarch(ro, rd);\n\n    vec4 color = texture(iChannel0, rd);\n\n    vec3 p = ro + rd * d;\n    vec3 n = getNormal(p);\n\n    vec3 texCol = vec3(checkers(p));\n    vec3 col = vec3(getLight(p));\n\n    vec3 reflection = reflect(rd, n);\n    ro = p + n * MIN_DIST * 3.;\n    rd = reflection;\n\n    reflectivity = 0.;\n\n    if(d < MAX_DIST)\n    {\n        int material = getMaterial(p);\n\n        if(material == MAT_DEFAULT)\n        {\n            color = vec4(col, 1.0);\n            reflectivity = 0.;\n        } else if(material == MAT_CHECKERS)\n        {\n            color = vec4(mix(col, texCol, .5), 1.0);\n            reflectivity = .3;\n        } else if(material == MAT_MIRROR)\n        {\n           \n            color = vec4(0.);\n            reflectivity = .9;\n        }\n\n        return color;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\n    Camera camera = getCamera(uv, 2.);\n    \n    vec3 ro = camera.position; \n    vec3 rd = camera.direction;\n    float reflectivity = 0.;\n    vec4 difuse = render(ro, rd, reflectivity);\n    vec4 filt = vec4(1.);\n    \n    const int MAX_BOUNCES = 3;\n    \n    vec4 reflection = vec4(0.);\n    \n    for(int i = 0; i < MAX_BOUNCES; i++){\n        filt *= reflectivity;\n        vec4 bounce = filt * render(ro, rd, reflectivity);\n        difuse += bounce; \n    }\n    \n    fragColor = difuse;\n}\n","name":"Image","description":"","type":"image"}]}