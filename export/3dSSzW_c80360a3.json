{"ver":"0.1","info":{"id":"3dSSzW","date":"1553010616","viewed":186,"name":"Simple Planet","username":"jojendersie","description":"Created for a seminar on procedural coding. Uses some basic concepts to introduce computer graphics (dot product lighting, rotation matrix) and procedural content (value noise).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A function to produce a procedural surface appereance\nvec3 planetColor( vec3 n )\n{\n    // Fractal value noise\n    float amplitude = 1.0;\n    float height = 0.0;\n    float frequency = 0.06;\n    for(int i = 0; i < 6; ++i)\n    {\n        height += abs(texture(iChannel2, n * frequency).r - 0.5) * amplitude;\n        amplitude /= 1.9;\n        frequency *= 1.87;\n    }\n    \n    // Threshold between land and water\n    vec3 color;\n    if(height < 0.35)\n    {\n\t    // Water -> Inverted blue\n        color = vec3(0,0,0.7) * height;\n    } else {\n        // Land\n        // Start with a noise red/green floor\n        vec2 noise = texture(iChannel1, vec2(height, n.x * n.y)).rg;\n        vec2 vegetation = -noise * 0.15 + vec2(0.0, 0.3);\n        // Use height as gray vec3(height) for mountains\n        // and mix (also based on height)\n        color = mix(vec3(vegetation, 0.0), vec3(height), height*height*2.0);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Center and scale (larger number decrease the size of the planet)\n    uv = (uv - 0.5) * 2.6;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Circle center distance\n\tfloat len = length(uv);\n\tif( len >= 1.0 )\n\t{\n        // Stars\n\t\tfloat r = texture(iChannel0, uv * 0.4).r;\n\t\tr = r > 0.93 ? r : 0.0;\n\t\tr = r * 100.0 - 93.0;\n        vec3 color = texture(iChannel1, uv + sin(iTime*0.6)*0.04).rgb;\n\t\tfragColor = vec4(color * r, 1);\n        return;\n\t}\n\n\t// Compute normal from trigonometry\n\tvec3 n = vec3(uv.x, uv.y, sqrt(1.0 - len * len));\n\n    // Rotate the planet surface position\n    float cTime = cos(iTime * 0.1);\n    float sTime = sin(iTime * 0.1);\n    mat3x3 rotationY = mat3x3(cTime, 0.0, sTime,\n                             0.0,   1.0, 0.0,\n                            -sTime, 0.0, cTime);\n\tvec3 pos = rotationY * n;\n\n    // Colored planet surface\n    vec3 pcolor = planetColor(pos);\n\n    // Simple light from a constant direction\n    float nDotLight = dot(n, normalize(vec3(0.707, 0.707, 0.3)));\n    float diffuse = pow(max(0.0, nDotLight), 0.5);\n    float light = diffuse * 2.0 + 0.06;\n    \n\tfragColor = vec4(pcolor * light, 1);\n}","name":"Image","description":"","type":"image"}]}