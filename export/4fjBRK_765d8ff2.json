{"ver":"0.1","info":{"id":"4fjBRK","date":"1725204836","viewed":43,"name":"Mesh Ocean with Little Sailboat","username":"Peregrine","description":"2024-06-19, made for the Fabrique Ã  Cookies livecoding jam.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mesh","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t   iTime\n#define PI  3.1415926535897932384626\n#define TAU (2. * PI)\n#define PHI 1.6180339887498948482045\n#define EPSILON 0.001\n\n#define fft(f) texture(texFFT, f).x\n#define noise(uv) texture(texNoise, uv).x\n#define max2(a, b) (a.x > b.x ? a : b)\n#define min2(a, b) (a.x < b.x ? a : b)\n#define pos(x) ((x) * .5 + .5)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define sat(x) clamp(x, 0., 1.)\n\n#define TR_MAX_STEPS   128\n#define TR_MAX_DIST    100.\n#define THICKNESS      .005\n#define WATER_COLOR    vec3(0., .5, 1.)\n#define BOAT_COLOR     vec3(1.)\n#define GLOW_RADIUS    .02\n#define GLOW_INTENSITY .4\n\nvec2 smooth_union(float a, float b, float k) {\n  float h = 1. - min(abs(a - b) / (4. * k), 1.);\n  float w = h * h;\n  float m = w * .5;\n  float s = w * k;\n  return (a < b) ? vec2(a - s, m) : vec2(b - s, 1. - m);\n}\n\nfloat sdf_capped_torus(vec3 p, vec2 sc, float ra, float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n  return sqrt(dot(p, p) + ra * ra - 2. * ra * k) - rb;\n}\n\nfloat sdf_capsule(vec3 p, float t) {\n  p = abs(p);\n  p.x -= clamp(p.x, 0., t/2.);\n  return length(p) - THICKNESS;\n}  \n\nvec2 sdf(vec3 p) {\n  vec2 di = vec2(TR_MAX_DIST, -1.);\n  \n  // water surface\n  vec3 pwater = p;\n  pwater.xz *= rot(PI/6.);\n  \n  // z-length water mesh part\n  vec3 ptube = pwater;\n  float r = 1.,\n        ztubes_id = floor((ptube.x + r * .5)/r);\n  ptube.x = mod(ptube.x + .5 * r, r) - .5 * r;\n  ptube.y -= .2 * sin(.4 * ptube.z + .5 * t + .1 * -ztubes_id);\n  float ztubes = length(ptube.xy) - THICKNESS;\n  \n  // x-length water mesh part\n  ptube = pwater;\n  float xtubes_id = floor((ptube.z + r * .5)/r);\n  ptube.z = mod(ptube.z + .5 * r, r) - .5 * r;\n  ptube.y -= .2 * sin(.5 * ptube.x + .5 * t + .1 * -xtubes_id);\n  float xtubes = length(ptube.yz) - THICKNESS;\n  \n  float water = min(ztubes, xtubes);\n  \n  // white boat\n  p.xz *= rot(-PI/3.);\n  float osc = sin(t * .5) * .2;\n  p.xy *= rot(osc);\n  p.yz *= rot(osc);\n  p.y += .25 * osc - .4;\n  vec3 phull = p;\n  phull.yz *= rot(PI/2.);\n  phull.y = abs(phull.y);\n  phull.y += .5;\n  float top_hull = sdf_capped_torus(phull, vec2(2.*PI/3., PI/3.), 1., THICKNESS);\n  phull = p;\n  phull.y += -.48;\n  float bottom_hull = sdf_capped_torus(phull, vec2(.8*-2.*PI/3., .9*PI/3.), 1., THICKNESS);\n  vec3 psail = p;\n  psail.xz *= rot(.3 * sin(t));\n  psail.xy *= rot(PI/2.);\n  psail.x -= -.75;\n  float sail = sdf_capsule(psail, 2.);\n  psail.xy *= rot(PI/2.);\n  psail -= vec3(.49, .5, 0.);\n  sail = min(sail, sdf_capsule(psail, 1.));\n  psail.xy *= rot(-0.93*PI/3.);\n  psail -= vec3(-.61, -.43, 0.);\n  sail = min(sail, sdf_capsule(psail, sqrt(3.3)));\n\n  float boat = min(sail, min(top_hull, bottom_hull));\n\n  vec2 df = smooth_union(water, boat, .05);\n  di = min2(di, vec2(df.x, df.y + 1.));\n  \n  return di;\n}\n\nfloat glow;\nvec2 trace(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  float td = 0.;\n  \n  glow = 0.;\n  for (int i = 0; i < TR_MAX_STEPS && td < TR_MAX_DIST; i++) {\n    vec2 di = sdf(p);\n    if (di.x < EPSILON)\n      return vec2(td, di.y);\n    glow += (1. - sat(di.x/GLOW_RADIUS)) * GLOW_INTENSITY;\n    p += di.x * rd;\n    td = distance(ro, p);\n  }\n  \n  return vec2(-1.);\n}\n\nvec3 get_normal(vec3 p) {\n  vec2 e = EPSILON * vec2(1., -1.);\n  return normalize(\n    e.xyy * sdf(p + e.xyy).x +\n    e.yxy * sdf(p + e.yxy).x +\n    e.yyx * sdf(p + e.yyx).x +\n    e.xxx * sdf(p + e.xxx).x\n  );\n}\n\nvec3 get_raydir(vec2 uv, vec3 ro, vec3 ta) {\n  vec3 rd = normalize(ta - ro),\n       r = normalize(cross(vec3(0., 1., 0.), rd)),\n       u = normalize(cross(rd, r));\n  return normalize(rd + r * uv.x + u * uv.y);\n}\n\nvec3 get_material(float id, vec3 p, vec3 n) {\n  if (id >= 2.) return BOAT_COLOR * (1. + glow);\n  if (id >= 1.) return WATER_COLOR * (1. + glow);\n  if (id >= -1.) {\n    return WATER_COLOR * glow;\n  }\n}\n\nvec3 render(vec2 uv) {\n  vec3 ro = vec3(3., 2., -10.),\n       ta = vec3(0., 0., TR_MAX_DIST),\n       rd = get_raydir(uv, ro, ta);\n  \n  vec2 tdi = trace(ro, rd);\n  if (tdi.x > 0.) {\n    vec3 p = ro + tdi.x * rd,\n         n = get_normal(p);\n    return get_material(tdi.y, p, n);\n  } else return get_material(-1., vec3(0.), vec3(0.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\tvec3 c = render(uv);\n  \n    c = 1. - exp(-c);\n    c = sqrt(c);\n\tfragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}