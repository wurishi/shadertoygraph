{"ver":"0.1","info":{"id":"3dsGRf","date":"1547226225","viewed":172,"name":"csg","username":"caudya","description":"csg","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// In GLSL, IEEE 754 infinity can conveniently be achieved by dividing by zero\nconst float FLT_MAX = 1.0 / 0.0;    \n\n// We can define a structure that will contain the parameters needed\n// by an object to specify its shading according to Phong shading.\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient, indice de réfraction\n    float Kn;\t// specular power coefficient\n};\n    \n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\nvec3\t   cameraPos    = vec3(6,  4, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 90.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\n// Sphere parameters\nvec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\nvec3     lightPos     = vec3(8, 10, -12);\n\nconst float eps = 0.01;\n\n//CSG objects parameters\nconst vec3     csgSphere1Pos \t= cameraTarget + vec3(-1.125, 2, 0);\nconst float    csgSphere1Radius = 1.4;\nconst vec3\t   csgSphere2Pos \t= cameraTarget + vec3(1.125, 2, 0);\nconst float\t   csgSphere2Radius = 1.4;\nconst vec3\t   csgSphere3Pos \t= cameraTarget + vec3(0, 2.5, 0);\nconst float\t   csgSphere3Radius = 0.5;\nconst vec3\t   csgSphere4Pos \t= cameraTarget + vec3(0, 2.4, -0.5);\nconst float\t   csgSphere4Radius = 0.5;\nconst vec3\t   csgCol1 \t\t\t= vec3(1.0, 0.5, 0.0); //orange\nconst vec3\t   csgCol2 \t\t\t= vec3(0.4, 1.0, 1.0); //light cyan\nconst vec3     csgCol3\t\t\t= vec3(1.0, 0.0, 1.0); //magenta\nconst vec3     csgCol4\t\t\t= vec3(5.0, 5.0, 0.0); //hyper yellow\nconst Material csgMat \t\t\t= Material(0.2, 1.0, 0.1, 90.0);\nconst int \t   csgId\t\t\t= 3;\n\n//value for grid\n\n//boo est vraie alors on prend PIXEL_SAMPLING_GRID_SIZE sinon on choisit PIXEL_SAMPLING_RANDOM \nbool boo = true;\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_RANDOM = 20;\n\nstruct ShadeInfo\n{\n    vec3 shadedcol;\n    float Ks;\n};\n    \nint subObjectIdC;\n\nconst int MAX_NB_BOUNCES = 3;\n//##############################################################################################\n   \nvoid animateScene(in float time) {\n    //animate the sphere position\n\tconst float pi = 3.1415926535;\n\tconst float rs = 2.0;\n\tconst float spr = 5.0;\n\tfloat as = 2.0*pi * time /spr;\n\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0, 1, 0);\n    \n    lightPos += vec3(0.0, 10.5 + 9.5 * cos(time) - 10.0, 0.0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist * vec3(sin(time), max(sin(time*0.5), 0.0), cos(time));\n    \n}\n\n//##############################################################################################\n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n \n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n\n        intersecPt = rayPos + t * rayDir;\n\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n//##############################################################################################\n\n//cette fonction similaire à reySphere est utilisé pour la sphere 4, \n//laquelle nous souhaitons l'intersection la plus éloignée (non visible par la caméra)\nfloat raySphere4(vec3 rayPos ,vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t2  = (-b + sdi) * den;\n \n        float dir = 1.0;\n\n        // As we found the value of t, we can insert it into equation (1) to find\n        // the position of the first intersection point encountered along the ray.\n        intersecPt = rayPos + t2 * rayDir;\n\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        //on prend l'intersection la plus éloignée\n        return t2;\n    }\n    \n    return 0.0;\n}\n//##############################################################################################\n\n//calcul point d'intersection entre deux sphère\nfloat raySphereIntersec(vec3 rayPos, vec3 rayDir, vec3 spos1, vec3 spos2, float srad1, float srad2, out vec3 intersecPt, out vec3 normal, out int subObjectId)\n{ \n    vec3 intersecPt1;\n\tvec3 normal1;\n    vec3 intersecPt2;\n\tvec3 normal2;\n    \n    float dist1 = raySphere(rayPos, rayDir, spos1, srad1, intersecPt1, normal1);\n    \n    float dist2 = raySphere(rayPos, rayDir, spos2, srad2, intersecPt2, normal2);\n    \n     //le rayon passe par les deux sphères (condition nécessaire d'intersection)\n    if ((dist1 > 0.0) && (dist2 > 0.0)) {\n        \n        float disS1 = distance(intersecPt1,csgSphere2Pos);\n        \n        //le point de la sphère 1 est inclu dans la sphère 2\n        if (disS1 <= csgSphere2Radius) {\n            \n            intersecPt = intersecPt1;\n            subObjectId = 1;\n            normal = normal1; \n            return dist1;\n        }\n        \n        float disS2 = distance(intersecPt2,csgSphere1Pos);\n        \n        //le point de la sphère 2 est inclu dans la sphère 1\n        if (disS2 <= csgSphere1Radius) {\n          \tintersecPt = intersecPt2;\n            subObjectId = 2;\n            normal = normal2; \t\n            return dist2;\n         } \n    }\n    \n    return -1.0;\n}\n\n//##############################################################################################\n\n\nfloat rayCSG( vec3 rayPos, vec3 rayDir, out vec3 intersecPt, out vec3 normal, out int subObjectId)\n{\n    vec3 intersecPt1;\n\tvec3 normal1;\n    vec3 intersecPt3;\n\tvec3 normal3;\n    vec3 intersecPt4;\n\tvec3 normal4;\n    int subid;\n    float dist;\n    \n \n    //on cherche si le rayon traverse l'intersection entre la sphère 1 et 2\n    float distintersec = raySphereIntersec(rayPos, rayDir, csgSphere1Pos, csgSphere2Pos, csgSphere1Radius, csgSphere2Radius, intersecPt1, normal1, subid);\n   \n    //on cherche si le rayon traverse la sphère 3\n\tfloat dist3 = raySphere(rayPos, rayDir, csgSphere3Pos, csgSphere3Radius, intersecPt3, normal3);\n    \n\n    //Si il y a une intersection avec la sphère 3 OU entre la sphère 1 et 2\n    if ((dist3 > 0.0)) {\n        //intersection avec la sphère 3\n        intersecPt = intersecPt3;\n        subObjectId = 3;\n        normal = normal3; \n        dist = dist3;\n        \n        //intersection aussi avec la sphère 1  et 2\n        if (distintersec > 0.0) {\n            float discam1 = distance(cameraPos, intersecPt1);\n       \t\tfloat discam3 = distance(cameraPos, intersecPt3);\n        \n            //on prend le point d'intersection le plus proche de la caméra\n            if ((discam3 > discam1)) {\n            \tintersecPt = intersecPt1;\n            \tsubObjectId = subid;\n            \tnormal = normal1; \n            \tdist = distintersec;\n        \t}\n        }\n    } else { \n        // intersection avec la sphère 1 et 2 uniquement\n   \t\tif (distintersec > 0.0) {     \n                intersecPt = intersecPt1;\n            \tsubObjectId = subid;\n            \tnormal = normal1; \n            \tdist = distintersec;\n        } else {\n        \treturn -1.0;\n        }\n     }\n        \n     //distance entre le point d'intersection et l'origine de la sphere4\n     float disS34 = distance(intersecPt,csgSphere4Pos);\n        \n        \n     //le point d'intersection de la sphere n'appartient pas à la sphere 4\n     if (disS34 > csgSphere4Radius) {\n            \n        // on retourne la distance\n        return dist;\n     }  \n    \n    //on calcule le point d'intersection avec la sphere 4 le plus loin\n    float dist4 = raySphere4(rayPos, rayDir, csgSphere4Pos, csgSphere4Radius, intersecPt4, normal4);\n        \n     //on calcule la distance entre le point d'intersection de la sphère 4 et les centres des autres sphères\n     float dis43 = distance(intersecPt4,csgSphere3Pos);\n     float disS41 = distance(intersecPt4,csgSphere1Pos);\n     float disS42 = distance(intersecPt4,csgSphere2Pos);\n        \n     //le point d'intersection de la sphère 4 doit être inclu dans la sphère 3 OU la sphère 1 et 2 \n     if ((dist4 > 0.0) && ((dis43 <= csgSphere3Radius) || ((disS41 <= csgSphere1Radius) && (disS42 <= csgSphere2Radius))) ) {\n          intersecPt = intersecPt4;\n          subObjectId = 4;\n          normal = normal4; \n          return dist4;\n     }\n    \n    return -1.0;\n    \n}\n\n\n//----------------------------------------------------------------------------------------------\n\n// NOTE: planeNormal must be a unit-vector!\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t// To avoid numerical instabilities we consider the ray to be \n        return -1.0;\t\t\t// parallel if the angle between the normal and the ray is\n        \t\t\t\t\t\t// ALMOST zero.\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n    // As we found the value of t, we can insert it into equation (1) to find\n    // the position of the first intersection point encountered along the ray.\n    intersecPt = rayPos + t * rayDir;\n    \n    // NOTE: The normal to be returned has to be pointing 'towards' the rayPos position.\n    //       So, the angle between the ray direction and the normal must > 90°, so the\n    //       dot-product should be negative.\n    //       This can be expressed by taking the 'sign' of den\n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n\n                 \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    // Compute camera three main axis (X,Y,Z) expressed in world space\n    //\n    //  NOTES: - First, we compute the Z camera unit vector that goes from the camera position\n    //           and look toward the camera target.\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n    //         - Finally, we can find the true cy by applying: cy = cross-product(cz, cx)\n\n    vec3 cy = normalize(cross( cz, cx));\n\n\n    // by the same value: iResolution.y\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n\n    //origine du rayon, la caméra\n    rayPos = cameraPos;\n    \n    //direction du rayon\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n//----------------------------------------------------------------------------------------------\n\n// trouve l'intersection la plus proche qu'à le rayon avec les objets\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, in int incId,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test la sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    //float distS = raySphere(rayPos, rayDir, csgSphere1Pos, csgSphere1Radius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n        normalI   =   normalS;\n    }\n    \n    // Test intersection avec l'objet CSG\n    vec3 intersecC, normalC;\n    float distC =  rayCSG(rayPos, rayDir,intersecC, normalC, subObjectIdC);\n    if ((distC > 0.0) && (distC < minDist))\n    {\n        objectId  =   csgId;\n        minDist   =   distC;\n\t    intersecI =   intersecC;\n    \tnormalI   =   normalC;\n    }\n    \n   \t // Test le plan\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n       \tobjectId  =   planeId;\n       \tminDist   =     distP;\n\t   \tintersecI = intersecP;\n    \tnormalI   =   normalP;\n    }\n    \n\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    // As the plane is textured with a checkboard pattern, we need to define\n    // a 'texture coordinate frame'.\n\n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\nvec3 getCSGColorAtPoint(vec3 pt)\n{\n    if (subObjectIdC == 1)\n        return csgCol1;\n    if (subObjectIdC == 2)\n        return csgCol2;\n    if (subObjectIdC == 3)\n        return csgCol3;\n    if (subObjectIdC == 4)\n        return csgCol4;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    } \n    else if (objectId == csgId) \n    {\n        objectMat = csgMat;\n        return getCSGColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat getShadowAtPoint(in vec3 I, in vec3 normalI, in Material objectMat, in vec3 L, in float Ldist)\n{\n    int object;\n    vec3 vec1, vec;\n    float dist = computeNearestIntersection(I, L, -1, object, vec1, vec);\n    if (dist<Ldist && dist>0.0) {\n        return 0.5;\n    } else {\n        return 1.0;\n    }\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, vec3 N, vec3 L, vec3 R, vec3 V, float shadowFactor)\n{    \n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lightCol *     max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *  lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    vec3 phongCol = ambiant + shadowFactor*diffuse + shadowFactor*specular;\n\n    return phongCol;\n}\n\n//##############################################################################################\n\nvec4 RaycastAtPixelCoord(vec2 pixCoord) \n{\n\t// Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir); \n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    \n    int nbBounces = 0;\n    \n    // Test ray-objetcs intersections and find the nearest one\n    // (with its associated intersection point and normal at the object surface)\n    int  objectId;\n    vec3 intersecI, normalI;\n    \n    vec3 col;\n    vec3 spec;\n        \n    do\n    {\t\n        \n    \tfloat distI = computeNearestIntersection(rayPos, rayDir, -1, objectId, intersecI, normalI);\n    \n    \t// Apply the shading to the points that are on the sphere surface and seen by the camera\n    \tif (distI <= 0.0)\n    \t{\n            \n            infos[nbBounces].shadedcol = skyCol;\n        \tinfos[nbBounces].Ks = 0.0;\n        \tbreak;\n            \n        }\n        \n        // unit-vector going from the surface point toward the light\n\t    vec3 L = normalize(lightPos - intersecI);\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n        \n        vec3 RayRefr = 2.0 * normalI * dot(normalI, V) - V;\n        \n        \n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n        vec3 I = intersecI + normalI*eps;\n        \n        float Ldist = length(lightPos-I);\n        \n        float shadowfactor = getShadowAtPoint(I, normalI, objectMat, L, Ldist);\n        \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n       \n        col = computePhongShading(objectCol, objectMat, normalI, L, R, V, shadowfactor);\n        \n        infos[nbBounces].shadedcol = col;\n        infos[nbBounces].Ks = objectMat.Ks;\n        \n        //bounce from the surface towards the reflect direction of the ray\n        \n        rayDir = RayRefr;\n        \n        rayPos = I;\n        \n        nbBounces++;\n    }\n    while (nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n    for (int i=0; i<=nbBounces; i++)\n    {\n        resCol = infos[nbBounces-i].Ks*resCol + infos[nbBounces-i].shadedcol;\n    }\n    \n    //resCol = vec4(computePhongShading(objectCol, objectMat, normalI, L, R, V, shadowfactor), 1);\n    \n    return vec4(resCol, 1);\n \n    //return vec4(computePhongShading(resCol, objectMat, normalI, L, R, V, shadowfactor), 1);; \n}\n\n\n//##############################################################################################\n\nvec2 noise2(vec2 location, vec2 delta) \n{\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m)\n        \n\t);\n}\n\n//##############################################################################################\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float time = iTime;\n    \n    animateScene(time);\n    \n    vec4 moy = vec4(0);\n    \n    if (boo == true) {\n    for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        \n        for (int j=0; j<PIXEL_SAMPLING_GRID_SIZE; j++)\n        {    \n            moy += RaycastAtPixelCoord(fragCoord+vec2(float(i)/float(PIXEL_SAMPLING_GRID_SIZE), float(j)/float(PIXEL_SAMPLING_GRID_SIZE))); \n    \t\t\n        }\n    }\n        \n    } else {\n        for (int i=0; i<PIXEL_SAMPLING_RANDOM ; i++)\n            moy += RaycastAtPixelCoord(fragCoord+noise2(vec2(i),vec2(10000))); \n    }\n    \n    if (boo == true) {\n        fragColor = moy/float(PIXEL_SAMPLING_GRID_SIZE*PIXEL_SAMPLING_GRID_SIZE);\n    } else {\n    \tfragColor = moy/float(PIXEL_SAMPLING_RANDOM);\n    }\n}","name":"Image","description":"","type":"image"}]}