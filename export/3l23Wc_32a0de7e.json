{"ver":"0.1","info":{"id":"3l23Wc","date":"1562083871","viewed":187,"name":"Hello Camera","username":"2YY","description":"I'm studying camera work of ray marching.\n\nAlmost done. But, I'm confused about the \"up vector\".\n\nto rotate by any degrees, I need check camera direction (on world coords) when calculate intended up vector?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////\n// CONSTS\n\n/**\n * Every frames that max ray marching steps of every fragments.\n * TODO: いくつにすべき？ (パフォーマンスと画質のバランス的に)\n */\nconst int MAX_MARCHING_STEPS = 255;\n\n/**\n * Value of \"This distance are collisioned?\".\n * TODO: いくつにすべき？ (画質的に)\n */\nconst float EPSILON = .001;\n\n\n\n\n//////////////////////////////////////////////////\n// STRUCTS\n\n/**\n * Struct of camera.\n * This camera has some properties based on physical and you can set any values that same any any real camera device.\n */\nstruct Camera {\n\tfloat focalLength; // mm\n    vec2 sensorSize; // mm\n    vec2 lensShift; // mm\n    vec3 position;\n    vec3 lookAt;\n    float roll; // degree\n};\n\n/**\n * Struct of light.\n */\nstruct Light {\n    vec3 position; // in global coords\n    vec3 direction; // please set normalized vector\n    float strength;\n    vec3 specular;\n    vec3 diffuse;\n};\n\n/**\n * Struct of material.\n */\nstruct Material {\n\tvec3 albedo; // RGB\n    float specular;\n    float diffuse;\n    float ambient;\n    float shininess;\n};\n\n    \n    \n    \n//////////////////////////////////////////////////\n// DISTANCE FUNCTIONS\n\n\n/**\n * Signed function of sphene.\n * @param {float} p point of ray\n * @param {float} s sphere radius\n * @return {float} distance from p to sphere\n */\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\n/**\n * Signed function of box;\n * @param {vec3} p point of ray\n * @param {vec3} b box size\n */\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n/**\n * Signed function of scene.\n * @param {vec3} p point of ray\n * @return {float} distance from p to scene\n */\nfloat sdScene(vec3 p) {\n    float d = sdBox(p - vec3(0., 0., sin(iTime*2.)*-2.), vec3(1., 1., 1.));\n             d = min(d, sdBox(p - vec3(-3., sin(iTime*2.), 0.), vec3(1., 1., 1.)));\n             d = min(d, sdSphere(p - vec3(3., sin(iTime*4. + 10.), 0.), 1.));\n    return d;\n}\n\n\n\n\n//////////////////////////////////////////////////\n// RAY MARCHING UTILITY FUNCTIONS\n\n/**\n * Get normal vector of surface represented by signed distance function.\n * @param {p} point of marching ray tip\n */\nvec3 getNormal(vec3 p) {\n\treturn normalize(vec3(\n    \tsdScene(p + vec3(EPSILON, 0., 0.)) - sdScene(p + vec3(-EPSILON, 0., 0.)),\n        sdScene(p + vec3(0., EPSILON, 0.)) - sdScene(p + vec3(0., -EPSILON, 0.)),\n        sdScene(p + vec3(0., 0., EPSILON)) - sdScene(p + vec3(0., 0., -EPSILON))\n    ));\n}\n\n/**\n * Get field of view (FOV) with camera settings.\n * @param {vec2} sensorSize vertical and horizontal camera sensor size\n * @param {float} focalLength camera focal length\n * @return {vec2} vertical and horizontal field of view (in degrees)\n */\nvec2 getFieldOfView(vec2 sensorSize, float focalLength) {\n\tfloat verticalFov = degrees(2. * atan(sensorSize.y / 2. / focalLength));\n    float horizontalFov = degrees(2. *atan(sensorSize.y / 2. / focalLength));\n    return vec2(horizontalFov, verticalFov);\n}\n\n/**\n * Get normalized ray direction vec3. (on camera local coordinates)\n * @param {vec2} fov vertical and horizontal field of view\n * @param {float} focalLength camera focal length\n * @param {vec2} uv current UV coords.\n * @return {vec3} normalized ray direction (that correspond to current fragment coords)\n */\nvec3 getRayDirection(vec2 fov, float focalLength, vec2 uv) {\n    float directionX = fov.x / 2. / 90. * uv.x;\n    float directionY = fov.y / 2. / 90. * uv.y;\n    float directionZ = focalLength;\n\treturn normalize(vec3(directionX, directionY, directionZ));\n}\n\n/**\n * Get mat3 that translate to camera coords.\n * @param {vec3} position camera position (on the world coords)\n * @param {vec3} lookAt coords of \"Where to camera looking?\" (on the world coords)\n * @param {vec3} up camera up vector (on the world coords)\n * @return {mat3} viewing transform matrix\n */\nmat3 getViewingTransformMat3(vec3 position, vec3 lookAt, vec3 up) {\n    vec3 z = normalize(lookAt-position);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n\treturn mat3(\n        vec3(x.x, y.x, z.x),\n        vec3(x.y, y.y, z.y),\n        vec3(x.z, y.z, z.z)\n    );\n}\n\n/**\n * Get camera up vector.\n * @param {float} roll degrees that \"How amount roll the screen camera?\"\n */\nvec3 getUpVector(float roll) {\n\treturn vec3(sin(radians(roll)), cos(radians(roll)), 0.);\n}\n\n\n\n\n//////////////////////////////////////////////////\n// SHADING UTILITY FUNCTIONS\n\n/**\n * Shading with normal vector.\n * @param {vec3} normal vector (please set normalized vector)\n * @return {vec3} result color\n */\nvec3 normalShading(vec3 normal) {\n\treturn normal;\n}\n\n/**\n * Shading with lambert reflection model.\n * @param {vec3} normal normal vector (please set normalized vector)\n * @param {Light} light light information\n * @param {Material} material material information\n * @return {vec3} result color\n */\nvec3 lambertShading(vec3 normal, Light light, Material material) {\n\treturn dot(light.direction, normal) * material.albedo * light.strength;\n}\n\n/**\n * Shading with phong reflection model.\n * @param {vec3} ray marching ray vector\n * @param {vec3} cameraPosition position of camera (in world coords)\n * @param {vec3} normal normal vector (please set normalized vector)\n * @param {Light} light light information\n * @param {float} ambientLightStrength strength of ambient light\n * @param {Material} material material information\n * @return {vec3} result color\n */\nvec3 phongShading(vec3 ray, vec3 cameraPosition, vec3 normal, Light light, float ambientLightStrength, Material material) {\n\tvec3 rayDirection = normalize(ray);\n    vec3 L = normalize(ray - light.position); // vector that \"surface to light\"\n    vec3 V = normalize(ray-cameraPosition); // vector that \"surface to camera\"\n    vec3 R = normalize(cross(cross(rayDirection, normal), rayDirection)); // vector that reflection direction from light to the other side of the surface point\n    return material.ambient * ambientLightStrength + (material.diffuse * dot(L, normal) * light.diffuse + material.specular * pow(dot(R, V), material.shininess) * light.specular);\n}\n\n\n\n\n//////////////////////////////////////////////////\n// MAIN PROCESS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // UV (-1〜1 | adjusted to canvas aspect ratio)\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n\n    // Camera\n    Camera camera;\n    camera.focalLength = 59.8333;\n    camera.sensorSize = vec2(35.9, 24.);\n    camera.position = vec3(1000., 3000.*sin(iTime*2.), 5000.*sin(iTime));\n    camera.lookAt = vec3(sin(iTime*3.)*1., 0., 0.);\n    camera.roll = sin(iTime) * 360.;\n    \n    // Light\n    Light light1;\n    light1.position = vec3(0., 0., 0.);\n    light1.direction = normalize(vec3(1., 0., -1.));\n    light1.strength = 1.;\n    light1.specular = vec3(.0, .5,  .5);\n    light1.diffuse = vec3(.5, .0, .5);\n    \n    // Material\n    Material material1;\n    material1.albedo = vec3(1.*abs(sin(iTime)), 0., 1.);\n    material1.specular = .5;\n    material1.diffuse = .5;\n    material1.ambient = .5;\n    material1.shininess = 1.;\n\n    // Ray Marching\n    vec3 color = vec3(false);\n    float depth = 1.;\n    \n    // 回転を角度で指定するバージョン (Camera 構造体にそれ用のプロパティも持たせてみている)\n    // vec3 direction = getRayDirection(getFieldOfView(camera.sensorSize, camera.focalLength), camera.focalLength, uv) * getViewingTransformMat3(camera.position, camera.lookAt, getUpVector(camera.roll));\n    \n    // 見た目重視で適当に回転してみるバージョン\n    vec3 direction = getRayDirection(getFieldOfView(camera.sensorSize, camera.focalLength), camera.focalLength, uv) * getViewingTransformMat3(camera.position, camera.lookAt, vec3(.01, cos(iTime), 0.));\n    \n    bool isCollisioned = false;\n    for(int i=0; i<MAX_MARCHING_STEPS; i++) {\n        float distance = sdScene(camera.position + direction * depth);\n        if(distance < EPSILON) {\n\n            // color = normalShading(getNormal(camera.position + direction * depth));\n            color = lambertShading(getNormal(camera.position + direction * depth), light1, material1);\n            \n            break;\n        }\n        depth += distance;\n    }\n\n    // Render\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}