{"ver":"0.1","info":{"id":"lclcRj","date":"1721766106","viewed":83,"name":"Endless museum of fractals","username":"Imagyx","description":"I used my generator for the 2D fractals and created an endless menger museum filled with them.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","raytrace","generator","parametrize"],"hasliked":0,"parentid":"XXVSWG","parentname":"Fractal Generator 3D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/************************************************************************************************************************\\\n|*  A museum showing many fractals from my 2D fractal generator                                                         *|\n|*   based on formula from distance estimator compendium (https://jbaker.graphics/writings/images/DEC/fractal_de15.png) *|\n|*   and raytracer from iq (https://www.shadertoy.com/view/3ljcRh)                                                      *|\n|*   as well as pseudo random generator from Dave_Hoskins (https://www.shadertoy.com/view/XdGfRR)                       *|\n|*                                                                                                                      *|\n|* Defines                                                                                                              *|\n|* REFINE: Factor < 1.0 to compensate for inaccuracies in the distance estimation                                       *|\n|* SPEED: Horizontal scroll speed for showing \"all\" random fractals generated by parameters and ranges                  *|\n|* EPS: Defines how fine the details of the fractal should be (between a big sphere and fine dust ;-))                  *|\n|* LOOK_AROUND: Set to 0 to see only straight ahead                                                                     *|\n\\************************************************************************************************************************/\n\n#define REFINE 0.9\n#define SPEED 0.4\n#define EPS 0.001\n#define LOOK_AROUND 1\n\nfloat dT; // global distance from tracing\nbool hitCanvas = false, hitFloor = false; // used for inner menger canvas\nvec3 center; // center of each menger \nvec3 id; // id of each menger used for random\nfloat de(vec3 q) {\n    float d = 1e16;\n    float s = 4.0 / 3.0;\n    id = round(q / s);\n    center = q - s * id;\n    id = floor(q / s);\n    d = sdMenger(center, 3.0); // hollow menger cubes\n    float df = -abs(q.y) + .34; // floor and ceiling\n    if(df < d){hitFloor = true;}\n    d = min(d, df);\n    float dc = sdMenger(center * 0.98, 1.0); // trick with less menger levels and smaller size for canvas\n    if(dc < d){hitCanvas = true;}\n    d = min(d, dc);\n    return d;\n}\nvec3 palette(in float t) {\n\treturn palette(t, vec3(0.5, 0.48, 0.4), vec3(0.5), vec3(0.95, 0.99, 0.95), vec3(0.0, 0.14, 0.32));\n}\nvec3 getPainting(in vec3 p, in vec3 n){\n    n.y = abs(n.y);\n    float dif = clamp(dot(n, normalize(vec3(0.5, 0.25, 1.0))), 0.0, 1.0);\n    float amb = 0.25 + 0.5 * dot(n, vec3(0.0, 1.0, 0.0));\n    vec3 c = vec3(0.6, 0.8, 1.0) * 0.5 * dif + amb;\n    if(hitCanvas){\n        float h = 1.0 / 54.0;\n        vec2 uv = n.x > 0.9 ? center.zy : center.xy; // normal decides if painting is aligned with x or z axis\n        c = vec3(0.0);\n        vec2 huv = mod(uv + 18.0 * h, vec2(36.0 * h));\n        uv = mod(uv + 6.0 * h, vec2(12.0 * h));\n        bool centered = all(lessThan(huv, vec2(24.0 * h))) && all(greaterThan(huv, vec2(12.0 * h))); // bigger center painting? or nine smaller ones?\n        uv = centered ? uv / (9.0 * h) - 0.15 : uv / (6.0 * h) - 0.5;\n        //c.rg = uv; //debugging \n        uv = uv * 2.0 - 1.0; // centering for generator to work\n        //c.b = length(uv); // debugging\n        float fg = FractalGenerator2D(uv, id.xz + floor(huv * 3.0 + 0.5) + (n.x > 0.9 ? 0.5 : 1.0)); // offset id by each cube, alignment and canavs position (actually back and front look the same but will not be seen together ;-)) \n        c = palette(mod(fg * 4.0, 6.0));\n    }\n    return c;\n}\n\n/**************************************************************************/\n/* Source of basic raytracing code: https://www.shadertoy.com/view/3ljcRh */\n/**************************************************************************/\nfloat map(in vec3 pos){\n    return de(pos) * REFINE;\n}\nvec3 calcNormal( in vec3 pos){\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = EPS * 0.1;\n    return normalize( e.xyy*map(pos + e.xyy * eps) + \n\t\t\t\t\t  e.yyx*map(pos + e.yyx * eps) + \n\t\t\t\t\t  e.yxy*map(pos + e.yxy * eps) + \n\t\t\t\t\t  e.xxx*map(pos + e.xxx * eps) );\n}\nconst float tmax = 100.0;\nvoid trace(in vec3 ww, in vec3 rd){\n    float t = 0.0;\n    for(float i = 0.0; i < 256.0; i += 1.0){\n        vec3 pos = ww + t * rd;\n        hitCanvas = false; hitFloor = false;\n        float h = map(pos);\n        if(h < EPS || t > tmax){\n            dT = t;\n            break;\n        }\n        t += h;\n    }\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec3 ww = vec3(-1.0, 0.0, 0.0);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 tot = vec3(0.0);\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n    ww.x -= iTime * SPEED;\n    #if LOOK_AROUND\n    rotate(rd.xz, 30.0 * sin(iTime)); // look around to see more of the museum, each canvas is uniquely painted for you ;-)\n    #endif\n    trace(ww, rd);\n    vec3 col = vec3(0.0);\n    if(dT < tmax) {\n        vec3 pos = ww + dT * rd;\n        vec3 nor = calcNormal(pos);\n        col = getPainting(pos, nor);\n        float count = 0.0;\n        while(hitFloor && length(nor.xz) < 0.1 && count++ < 3.0){ // multiple reflections (not much to see yet.â€¦)\n            rd = reflect(rd, nor);\n            ww = pos + rd * 0.01;\n            trace(ww, rd);\n            vec3 pos = ww + dT * rd;\n            vec3 nor = calcNormal(pos);\n            col = mix(col + vec3(0.0, 0.1, 0.3), getPainting(pos, nor), 0.5);\n        }\n    }\n\tfragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Source: https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n// Source: https://www.shadertoy.com/view/XdGfRR\nfloat hash13(vec3 p){\n\tuvec3 q = uvec3(ivec3(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\tuint n = (q.x ^ q.y ^ q.z) * 1597334673U;\n\treturn float(n) * 2.328306437080797e-10;\n}\n// Source: https://www.shadertoy.com/view/XdGfRR\nfloat hash12(vec2 p){\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n    uint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * 2.328306437080797e-10;\n}\n// Source: https://iquilezles.org/articles/distfunctions/\nfloat sdBox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n// Source: https://iquilezles.org/articles/menger/\nfloat sdMenger(in vec3 p, in float iter){\n    float d = sdBox(p,vec3(1.0));\n    float s = 1.0;\n    for(float m = 0.0; m < iter; m += 1.0){\n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / s;\n        if(c > d){\n            d = c;\n        }\n    }\n    return d;\n}\n// Source: https://www.shadertoy.com/view/fsGcW3\nmat3 eulerRotation(vec3 rot){\n\t// Rotation: X - pitch, Y - yaw, Z - roll  -> Rz * Ry * Rx\n\tfloat cx = cos(rot.x);\n\tfloat sx = sin(rot.x);\n\tfloat cy = cos(rot.y);\n\tfloat sy = sin(rot.y);\n\tfloat cz = cos(rot.z);\n\tfloat sz = sin(rot.z);\n\tmat3 RzRyRx = mat3(\n\t\tvec3(  cy * cz,\t\t\t-cy * sz,\t\t\t sy\t ),\n\t\tvec3(  sx * sy * cz + cx * sz,\t-cy * sz + cx * cz,\t\t-sx * cy ),\n\t\tvec3( -cx *sy * cz + sx * sz,\t cx * sy * sz + sx * cz,\t cx * cy )\n\t);\n\treturn RzRyRx;\n}\n// Nothing special\nvoid rotate(inout vec2 q, in float deg){\n    float rad = radians(deg);\n    q = mat2x2(cos(rad),sin(rad),-sin(rad),cos(rad)) * q;\n}\n// Mine (except for basic (but adjusted and extended) fractal code from https://jbaker.graphics/writings/images/DEC/fractal_de15.png)\nvoid applyRange(inout float v, in vec2 r, in vec3 id){\n    v = r.x + hash13(id * 13371.931 + 130223.82) * (r.y - r.x);\n}\nvoid applyRange(inout vec3 v, in mat2x3 r, in vec3 id){\n    v = r[0] + hash13(id * 13371.931 + 130223.82) * (r[1] - r[0]);\n}\nvoid applyRange(inout float v, in vec2 r, in vec2 id) {\n\tv = r.x + hash12(id * 1341.931 + 123.82) * (r.y - r.x);\n}\nfloat FractalGenerator2D(vec2 q, in vec2 id0) {\n\tconst float split = 1.5;\n\tfloat ca, cb, cc, cd, ce, cf, cg, ch, ci, cj, ck;\n\tvec2 da, db;\t\n\tvec2 id = id0 * 382.394 + 3359.07 + floor((q - split) / (2.0 * split));\n\tapplyRange(ca, vec2(0.2, 0.6), id + 117.971);\n\tapplyRange(cb, vec2(0.75, 2.0), id + 251.233);\n\tapplyRange(cc, vec2(0.75, 2.0), id + 928.323);\n\tapplyRange(cd, vec2(0.25, 1.0), id + 339.111);\n\tapplyRange(ce, vec2(1.25, 1.75), id + 1212.12);\n\tapplyRange(cf, vec2(0.5, 2.0), id + 2120.99);\n\tapplyRange(cg, vec2(-10.0, 40.0), id + 1823.82);\n\tapplyRange(ch, vec2(-15.0, 30.0), id + 3293.12);\n\tapplyRange(ci, vec2(5.0, 11.0), id + 4192.17);\n\tapplyRange(cj, vec2(0.0, 1.0), id + 5192.29);\n\tapplyRange(ck, vec2(0.0, 0.75), id + 633.983);\n\tapplyRange(da.x, vec2(0.05, 1.0), id + 1233.12);\n\tapplyRange(da.y, vec2(2.0, 3.5), id + 9372.81);\n\tapplyRange(db.x, vec2(0.1, 1.0), id + 7683.33);\n\tapplyRange(db.y, vec2(1.5, 4.5), id + 6932.55);\n\tq = mod(q - split, 2.0 * split) - split;\n\tq = abs(q) - cb;\n\tif(q.x < q.y) {\n\t\tq.xy = q.yx;\n\t}\n\tfloat s = cc;\n\tq -= da;\n\tfor(float i = 0.0; i < ci; i += 1.0) {\n\t\tfloat r2 = 2.0 / clamp(dot(q, q), cd, ce);\n        q = abs(q) * r2;\n\t\trotate(q, cg);\n\t\tq -= db;\n\t\trotate(q.xy, ch);\n\t\tif(cj > 0.5) {\n\t\t\tq = abs(q.yx);\n\t\t}\n\t\ts *= r2;\n\t}\n\tfloat d = cf * length(q) / (s - ca);\n\treturn (ck < 0.5 ? abs(d) : d);\n}","name":"Common","description":"","type":"common"}]}