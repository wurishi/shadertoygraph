{"ver":"0.1","info":{"id":"XXtSD4","date":"1719045227","viewed":48,"name":"rainbow blobs","username":"toasted","description":"fluid rainbow blobs","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fluid Abstract 3D Demo Shader\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\nmat2 rot2D(float angle) {\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 p) {\n    float time = iTime * 0.5;\n    \n    // Rotate the entire scene\n    p.xz *= rot2D(time * 0.3);\n    p.yz *= rot2D(time * 0.2);\n    \n    // Create multiple spheres\n    float d = MAX_DIST;\n    for (int i = 0; i < 5; i++) {\n        vec3 sp = p;\n        float fi = float(i);\n        sp.x += sin(time + fi * 1.5) * 1.5;\n        sp.y += cos(time * 0.7 + fi * 1.2) * 1.5;\n        sp.z += sin(time * 0.5 + fi * 0.9) * 1.5;\n        float sphereDist = sdSphere(sp, 0.5 + 0.3 * sin(time + fi));\n        d = smin(d, sphereDist, 1.0);\n    }\n    \n    // Add some noise\n    d += sin(p.x * 10.0 + time) * sin(p.y * 8.0 + time * 1.5) * sin(p.z * 6.0 + time * 0.7) * 0.1;\n    \n    return d;\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = map(p);\n        dO += dS;\n        if (dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         u = cross(f, r),\n         c = f * z,\n         i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 0, -4);\n    vec3 rd = getRayDir(uv, ro, vec3(0, 0, 0), 1.0);\n    \n    float d = raymarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 n = getNormal(p);\n    vec3 lightPos = vec3(2, 4, -3);\n    vec3 l = normalize(lightPos - p);\n    \n    vec3 col = vec3(0);\n    \n    if (d < MAX_DIST) {\n        float diff = clamp(dot(n, l), 0.1, 1.0);\n        float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 32.0);\n        float fresnel = pow(1.0 - max(0.0, dot(n, -rd)), 4.0);\n        \n        vec3 objCol = 0.5 + 0.5 * cos(iTime * 0.3 + p.xyx * 2.0 + vec3(0, 2, 4));\n        col = objCol * diff + spec * 0.5 + fresnel * 0.5;\n    }\n    \n    col = pow(col, vec3(0.4545));  // gamma correction\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}