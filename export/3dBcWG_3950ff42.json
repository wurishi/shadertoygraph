{"ver":"0.1","info":{"id":"3dBcWG","date":"1587218639","viewed":110,"name":"automata_6","username":"balkhan","description":"Click somewhere, space if u want to rewind. \nplaying/experimenting with texture interpolation and temporal additions of gol, I have yet to figure how to make behavior resolution independent, fullscreen make full belts. ","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["mouse","automata","gol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 f )\n{\n\to = B(f/R);\n\to.xyz = sin(o.x+ vec3(0.0, 1.04, 2.08) );\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat d(vec2 f, float s) // game of life, s is neighbors sampling scale\n{\n    vec2 i;\n\n    float r = B(f).x;\n    float m = .0;\n    for (int k = 0; i = vec2(k%3, k/3)-1., k < 9; k++)\n        if (k != 4)  m += B((f+i*s/R) ).x;\n    if (\n       r > .0 && m >= 2. && m <= 3.\n       ||\n       r <= 0. && m == 3.\n       )\n        r = 1.;\n    else\n        r = 0.;\n    return r;\n}\n\nfloat aliased_circle(vec2 f) \n    // this used to be \"length(f)-smallradius\" and then I noticed sometimes it gave constructing arms\n    // and so the quest to find the exact shape began\n    // and then it ended\n{\n    float r = .0;\n    f = abs(f); // symmetries are cool\n    if (\n        (f.x >= .0 && f.x < 2.\n         &&\n         f.y <= 8. && f.y > 7.\n        )\n        ||\n        (f.x >= .0 && f.x < 4.\n         &&\n         f.y <= 7. && f.y > 6.\n        )\n        ||\n        (f.x >= .0 && f.x < 6.\n         &&\n         f.y <= 6. && f.y > 4.\n        )\n        ||\n        (f.x >= .0 && f.x < 7.\n         &&\n         f.y <= 4. && f.y > 2.\n        )\n        ||\n        (f.x >= .0 && f.x < 8.\n         &&\n         f.y <= 2. && f.y > 0.\n        )\n        )\n\tr = 1.;\n    \n    return r;\n}\n\nfloat experiment(vec2 f)\n{\n    float r;\n    \n    if (\n        (\n        f.x > -2. && f.x <= 0.\n       &&\n        f.y > -11. && f.y <= 12.\n        )\n        ||\n        (\n        f.x > -11. && f.x <= 12.\n            &&\n        f.y > -0.0 && f.y <= 2.\n        )\n       )\n        r = 1.;\n    \n    return r;\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    vec2 u = f / R;\n    o = texture(iChannel1, u);\n    //if (iFrame % 10 > 1) return;\n\tfloat kb = texture(iChannel2, vec2(32.5/256., 0.25)).x; // keyboard\n    \n    // original transition, this one works independantly of resolution\n    /*\n\to += 3.*d(uv, .5);\n    o -= 1.5*d(uv, 1.5);\n\t*/\n    \n    o += 2.*d(u, .5);\n    o -= 1.5*d(u, 1.5);\n    o += d(u, .25);\n    if (iFrame < 1 || kb > .5 || iMouse.z > .0)\n    //    o.x = step(experiment(f-iMouse.xy), .0)*.5;\n    \to.x = step(aliased_circle(f-iMouse.xy), .0)*.5;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define R iResolution.xy\n#define B(u) texture(iChannel1, u)","name":"Common","description":"","type":"common"}]}