{"ver":"0.1","info":{"id":"ldBBWm","date":"1500650227","viewed":184,"name":"Tentacles 1 ","username":"AlexM","description":"Trying to make a tentacle-like thing. Yucky. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tentacle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Trying to make some weird organic tentacle-like things. Doesn't look too organic though, need to\n// mess around with noise a bit more.\n\n#define PI 3.141592653589793 \n\n#define MATERIAL_EXTERIOR 1 \n#define MATERIAL_INTERIOR 2 \n\nconst float MAXT = 20.0f;\n\nconst float FOGHEIGHT = 0.02; // background fog height. \nconst float FOGFADEHEIGHT = 0.05; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.364, 0.270, 0.254);\nconst float FOGDENSITY = 0.08; \n\nconst vec3  SUNDIRECTION = normalize(vec3(0.0, -0.3, -0.6)); //direction of the sunlight\nconst vec3  SUNCOLOR =vec3(1.0, 0.949, 0.839); // sun color? \nconst vec3  SKYCOLOR = vec3(0.929, 0.792, 0.768);\nconst float REFRETA = 1.0/1.4;\nconst vec3 REPETITIONS = vec3(3.5, 0.0, 0.0);\n\n\n\nconst float EXTERIOR_FRESNEL_POW = 2.0;\nconst float ABSORBANCE_SCALE = 4.5;\nconst vec3  ABSORBANCE = vec3(0.15, 0.7, 0.8);\nconst float TRANSPARENCY = 0.9;\n\n\nstruct TraceResult {\n    bool hit;\n    float rayt;\n    int materialID;\n};\n\n// transformation funcs\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nmat3 rotateZ(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3(a, -b, 0.0, b, a, 0.0, 0.0, 0.0, 1.0);\n}\n\n// NOISE FUNCTIONS\nfloat random(in vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat random(in vec3 st) { \n    return fract(sin(dot(st,vec3(12.9898,78.233,19.124)))*43758.5453);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    float a1 = mix(a, b, u.x);\n    float a2 = mix(c, d, u.x);\n    float a3 = mix(a1, a2, u.y);\n    return clamp(a3, 0.0, 1.0); \n}\n\nfloat noise(in vec3 st) {\n    vec3 i = floor(st);\n    vec3 x = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n    vec3 u = x*x*(3.0-2.0*x);\n    float fa = mix(a, b, u.x);\n    float fb = mix(c, d, u.x);\n    float fc = mix(e, f, u.x);\n    float fd = mix(g, h, u.x);\n    float fe = mix(fa, fb, u.y);\n    float ff = mix(fc, fd, u.y);\n    float fg = mix(fe, ff, u.z);\n    return clamp(fg, 0.0, 1.0);\n}\n\nfloat opSubtract(float a, float b) {\n    return max(-a,b);\n}\n\nfloat opAdd(float a, float b) {\n    return min(a,b);\n}\n\nvec3 opRepeat(vec3 p, vec3 c) {\n    return mod(p,c)-0.5*c;\n}\n\nfloat exterior(vec3 p, out int mattype) {\n    mattype = MATERIAL_EXTERIOR;\n\n    p.x -= noise(p.zz*0.1+iTime*0.2) * 3.0;\n    p = opRepeat(p, REPETITIONS);\n    float f;\n    f = length(p.xy)-0.6; \n    float a = 0.50*(1.0-abs(2.0*noise(p*1.2+vec3(1.0)  +iTime*0.25)-1.0)); a = a*a*a*a;\n    float b = 0.40*(1.0-abs(2.0*noise(p*2.4+vec3(100.0)-iTime*0.27)-1.0)); b = b*b*b*b;\n    float c = 0.13*(1.0-abs(2.0*noise(p*20.+vec3(200.0)+iTime*0.73)-1.0)); c = c*c*c*c;\n    float d = 0.12*(1.0-abs(2.0*noise(p*220.+vec3(500.0)+iTime*0.93)-1.0)); d = d*d*d*d;\n    f = f-a-b-c-d;\n    return f;\n}\n\nfloat interior(vec3 p, out int mattype) {\n    float f;\n    float t =exterior(p, mattype);  \n    f = opSubtract(t, -90000.0);\n    p.x -= noise(p.zz*0.1+iTime*0.2) * 3.0;\n    p = opRepeat(p, REPETITIONS);\n\n    // tubes inside the body\n    p = rotateZ(0.8+iTime*0.5)*p;\n\n    for (int t = 0; t < 2; t++) {\n        float f1 = length(p.xy-vec2(float(t)*0.3-0.2,0.0))-0.10; \n        float a = 0.40*(1.0-abs(2.0*noise(p*1.2+vec3(1.0)  +iTime*0.09)-1.0)); a = a*a*a;\n        float b = 0.30*(1.0-abs(2.0*noise(p*4.4+vec3(100.0)-iTime*0.02)-1.0)); b = b*b*b;\n        f1 = f1-a-b;\n        f= opAdd(f, f1);\n    }\n    mattype = MATERIAL_INTERIOR; \n    if (abs(f-t)<0.2) mattype = MATERIAL_EXTERIOR;\n    return f;\n}\n\n\nfloat interior(vec3 p) { int unused; return interior(p, unused); }\nfloat exterior(vec3 p) { int unused; return exterior(p, unused); }\n\nTraceResult traceInterior(vec3 ro, vec3 rd) {\n    int mattype = 0;\n    int watermat = 0;\n    TraceResult traceResult = TraceResult(false, 0.0, mattype);\n    float t = 0.02;\n    float tmax = MAXT; \n    for (;t < tmax;) {\n        float d = interior(ro+rd*t, mattype);\n        if (d<0.001) { \n            traceResult = TraceResult(true, t, mattype);\n            break;\n        }\n        t += d;\n    }\n    traceResult.rayt = t;\n    return traceResult;\n}\n\nTraceResult traceExterior(vec3 ro, vec3 rd) {\n    int mattype = 0;\n    int watermat = 0;\n    TraceResult traceResult = TraceResult(false, 0.0, mattype);\n    float t = 0.02;\n    float tmax = MAXT; \n    for (;t < tmax;) {\n        float d = exterior(ro+rd*t, mattype);\n        if (d<0.001) { \n            traceResult = TraceResult(true, t, mattype);\n            break;\n        }\n        t += d;\n    }\n    traceResult.rayt = t;\n    return traceResult;\n}\n\nvec3 calcInteriorNormal(vec3 p) {\n    vec2 eps = vec2(0.001,0.0);\n    float x = interior(p+eps.xyy)-interior(p-eps.xyy);\n    float y = interior(p+eps.yxy)-interior(p-eps.yxy);\n    float z = interior(p+eps.yyx)-interior(p-eps.yyx);\n    return normalize(vec3(x,y,z));\n}\n\nvec3 calcExteriorNormal(vec3 p) {\n    vec2 eps = vec2(0.001,0.0);\n    float x = exterior(p+eps.xyy)-exterior(p-eps.xyy);\n    float y = exterior(p+eps.yxy)-exterior(p-eps.yxy);\n    float z = exterior(p+eps.yyx)-exterior(p-eps.yyx);\n    return normalize(vec3(x,y,z));\n}\n\n\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\nfloat phongDiffuseFactor(vec3 l, vec3 n) {\n    return max(0.0, dot(l,n));\n}\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\n//@v - view direction, normalized;\n//@k - shininess constant;\nfloat phongSpecularFactor(vec3 l, vec3 n, vec3 v, float k) {\n    vec3 r = normalize(reflect(l, n));\n    return pow(max(0.0, dot(r, v)), k);\n}\n\nfloat fog(float dist) {\n    return  1.0 - 1.0/exp(pow(dist*FOGDENSITY, 2.0));\n}\n\nvoid getMaterial(in int mattype, out vec3 matcolor) {\n    matcolor = vec3(0.0);\n    vec3 exteriorColor1 = vec3(0.223, 0.050, 0.019);\n    vec3 exteriorColor2 = vec3(0.105, 0.117, 0.172);\n    vec3 interiorColor1 = vec3(0.521, 0.298, 0.098);\n    vec3 interiorColor2 = vec3(0.611, 0.043, 0.815);\n\n    float f = sin(iTime*0.5)*0.5+0.5;\n    if (mattype == MATERIAL_EXTERIOR) { \n        matcolor = mix(exteriorColor1, exteriorColor2, f);\n    }\n    if (mattype == MATERIAL_INTERIOR) {\n        matcolor = mix(interiorColor1, interiorColor2, f);\n    }\n    \n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 color = SKYCOLOR; \n    float d = dot(-SUNDIRECTION, rd); // sun??\n    if (d > 0.0)          \n        color = mix(color, vec3(1.0), pow(d, 150.0));\n    if (rd.y < FOGFADEHEIGHT)     \n        color = mix(FOGCOLOR, color, (rd.y-FOGHEIGHT)/(FOGFADEHEIGHT-FOGHEIGHT));\n    if (rd.y < FOGHEIGHT) \n        color = FOGCOLOR;\n    return clamp(color, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n\n    vec3 color = vec3(0.0);\n\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd = rotateY(-iMouse.x*0.005-0.1) * rotateX(iMouse.y*0.005-0.4)  * rd;\n    rd = normalize(rd);\n\n    vec3 ro = vec3(0.0,1.5,0.0); \n    ro += iTime*0.2*normalize(vec3(0.0, 0.0, 1.0));\n\n\n    TraceResult exteriorTrace = traceExterior(ro, rd);\n    if (exteriorTrace.hit) {\n        vec3 exteriorPosition = ro+exteriorTrace.rayt*rd;\n        vec3 exteriorNormal = calcExteriorNormal(exteriorPosition);\n\n\n        // trace inside the thing \n        vec3 interiorStartPosition = exteriorPosition - exteriorNormal * 0.01; \n        vec3 interiorRayDirection = refract(rd, exteriorNormal, REFRETA); \n        TraceResult interiorTrace = traceInterior(interiorStartPosition, interiorRayDirection);\n\n        vec3 interiorColor;\n        if (interiorTrace.hit) {\n            getMaterial(interiorTrace.materialID, interiorColor);\n\n            vec3 interiorPosition = interiorStartPosition+interiorTrace.rayt*interiorRayDirection;\n            vec3 interiorNormal = calcInteriorNormal(interiorPosition);\n            // compute lighting inside\n            interiorColor = interiorColor*(0.3+phongDiffuseFactor(-SUNDIRECTION, interiorNormal)*1.0\n                                              +phongSpecularFactor(-SUNDIRECTION,interiorNormal, interiorRayDirection, 50.0)*1.0\n            );\n\n            // exit the interior....\n            if (interiorTrace.materialID == MATERIAL_EXTERIOR)\n                interiorColor += sky(interiorPosition, interiorRayDirection) * 0.2;\n        }\n\n        vec3 exteriorColor; \n        getMaterial(exteriorTrace.materialID, exteriorColor);\n        exteriorColor = exteriorColor*(0.3+phongDiffuseFactor(-SUNDIRECTION, exteriorNormal)*1.0 \n                                          +phongSpecularFactor(-SUNDIRECTION,exteriorNormal, rd, 50.0)*1.0\n        );\n\n        vec3 absorbance = exp(-ABSORBANCE*ABSORBANCE_SCALE*interiorTrace.rayt);\n        float fresnel = pow(dot(exteriorNormal, -rd), EXTERIOR_FRESNEL_POW);\n        fresnel *= TRANSPARENCY;\n        vec3 reflection = sky(ro, reflect(rd, exteriorNormal));\n        color = reflection*exteriorColor*(1.0-fresnel) + interiorColor*absorbance*(fresnel);\n\n                \n        color = mix(color, FOGCOLOR, fog(exteriorTrace.rayt));\n        color = clamp(color, 0.0, 1.0);\n    } else {\n        color = sky(ro, rd);\n    }\n\n\n\n    fragColor = vec4(color, 1.0); \n}","name":"Image","description":"","type":"image"}]}