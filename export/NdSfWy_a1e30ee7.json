{"ver":"0.1","info":{"id":"NdSfWy","date":"1677440187","viewed":62,"name":"Exercise 2.10 - Fresnel","username":"marcpages2020","description":"fresnel","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere\n{\n vec3 position;\n float radius;\n};\n\nstruct Hit\n{\n  vec3 point;\n  vec3 normal;\n  int objectId;\n};\n\n//Global Variables ===================================================\nvec3 cameraPosition = vec3(0.0f, 0.0f, 5.0f);\nfloat planeYPosition = -0.5f;\nSphere spheres[3];\nvec3 lightPosition = vec3(0.5f, 1.0f, 0.5f);\nvec3 lightDirection = vec3(1.0); \n//=====================================================================\n\nvec3 rayDirection (in vec2 fragCoord, in vec3 origin)\n{\n  vec3 nearCoord = vec3(2.0 * fragCoord / iResolution.xy - 1.0, 0.0);\n  nearCoord.x *= iResolution.x / iResolution.y;\n  vec3 d = normalize(nearCoord - origin);\n  return d;\n}\n\nbool CastRay(in vec3 origin, in vec3 direction, inout Hit hit, int ignoreObjectId)\n{ \n  float pt = (planeYPosition - origin.y) / direction.y;\n  vec3 planeIntersectionPoint = origin + direction * pt;  \n  float closestDistance = 1000000000000.0f;\n  hit.objectId = -1;\n  \n  bool hitSomething = false;\n  if(pt > 0.0f)\n  {\n    hitSomething = true;\n    hit.point = planeIntersectionPoint;\n    hit.normal = vec3(0.0f, 1.0f, 0.0f);\n  }\n  \n  for(int i = 0; i < 3; ++i)\n  {\n    if(i == ignoreObjectId)\n    {\n       continue;\n    }\n    \n    float proj = dot(spheres[i].position - origin, direction);\n    vec3 k = origin + direction * proj; \n\n    float l1 = length(spheres[i].position - k);\n    float l2 = sqrt(spheres[i].radius * spheres[i].radius - l1 * l1);\n    \n    float t = proj - l2;\n    \n    vec3 P = origin + direction * t;\n    \n    float sphereIntersection = step(l1, spheres[i].radius);\n    vec3 normals = normalize(P - spheres[i].position);\n    \n    float distance = length(spheres[i].position + normals - cameraPosition);\n    if(l1 < spheres[i].radius && distance < closestDistance && t > 0.0f)\n    { \n      closestDistance = distance;\n      hit.objectId = i;\n      hit.point = P;\n      hit.normal = normals;\n      hitSomething = true;\n    }   \n  }\n  \n  return hitSomething;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.x -= 0.5;\n    \n    //Sphere setting\n    float sphereRadius = 0.5f;\n    spheres[0] = Sphere(vec3(-0.8f, 0.0f, 0.2f), sphereRadius);\n    spheres[1] = Sphere(vec3(0.0f, 0.0f, -1.0f), sphereRadius);\n    spheres[2] = Sphere(vec3(0.8f, 0.0f, 0.0f), sphereRadius);\n    \n    //Camera setting\n    vec2 col = uv * 2.0f - 1.0f;\n    vec3 direction = normalize(rayDirection(fragCoord, cameraPosition));\n    \n    //Sky setting\n    vec3 skyColor = vec3(0.65, 0.7, 0.8);\n    skyColor = mix(skyColor, vec3(1.0f), -direction.y);      \n    \n    vec3 color = skyColor;\n    \n    vec3 floorColor = vec3(0.65f);\n    \n    Hit hit;\n    vec3 F0 = vec3(0.05f);\n    if(CastRay(cameraPosition, direction, hit, -2))\n    {      \n      float cosTheta = dot(-direction, hit.normal);\n      color = F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n    }\n    \n    /*\n    if(CastRay(hit.point, normalize(lightDirection), hit, hit.objectId))\n    {\n      color = vec3(0.0f);\n    }\n    */\n    \n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}