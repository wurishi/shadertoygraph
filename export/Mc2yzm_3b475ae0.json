{"ver":"0.1","info":{"id":"Mc2yzm","date":"1722112650","viewed":97,"name":"Ese Pete (Simple Path-Tracer)","username":"RowDaBoat","description":"A simplified path tracer adapted from Reinder's, no bells, no whistles:\nJust two spheres, a floor ,and the sky.\n\nFeatures:\n  - Reflective bounces.\n  - Diffuse bounces.\n  - Easy to read code.\n\nWant to add:\n  - Emissive materials.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ese Pete (Simple Path-Tracer). Created by RowDaBoat 2024\n//\n// https://www.shadertoy.com/view/Mc2yzm\n// adapted from: // https://www.shadertoy.com/view/lsX3DH\n//\n\n#define SAMPLES 80\n#define BOUNCES 4\n\n#define EPSILON 0.001\n#define MAXDISTANCE 180.\n\nfloat time;\n\n///////////////\n// Structures\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up;\n    vec3 left;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n#define SKYBOX 0\n#define GEOMETRY 1\n\nstruct Material {\n    int type;\n    vec3 color;\n    float reflectiveness;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    Material material;\n};\n\nstruct Plane {\n    float height;\n    Material material;\n};\n\nstruct Hit {\n    vec3 point;\n    float distance;\n    vec3 normal;\n    Material material;\n};\n\n\n///////////\n// Random\nvec4 random;\n\nvoid shuffle() {\n    random = fract(1e4 * sin(random) + random.wxyz + 0.5);\n}\n\nvoid initRandom(vec2 normalizedPixel, int iFrame) {\n    random = vec4(normalizedPixel, iFrame, 1);\n\n    for(int i = 0; i < 16; i++)\n        shuffle();\n}\n\n\n////////////////////////\n// Viewport and Camera\nvec2 viewport(vec2 coordinate) {\n    vec2 normalized = coordinate.xy / iResolution.xy;\n\tvec2 centered = -1.0 + 2.0 * normalized;\n    float aspectRatio = iResolution.x / iResolution.y;\n    return vec2(centered.x * aspectRatio, centered.y);\n}\n\nCamera camera(vec3 position, vec3 target, float roll) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = normalize(target - position);\n    vec3 rolling = vec3(sin(roll), cos(roll), .0);\n    camera.up = normalize(cross(camera.direction, rolling));\n    camera.left = normalize(cross(camera.up, camera.direction));\n\n    return camera;\n}\n\nRay cameraRay(Camera camera, vec2 point) {\n    vec2 displacedPoint = point + random.xy / (0.5 * iResolution.xy);\n    vec3 displacement =\n        displacedPoint.x * camera.up +\n        displacedPoint.y * camera.left;\n\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = normalize(displacement + 1.5 * camera.direction);\n\n    return ray;\n}\n\n\n/////////////\n// Material\nMaterial material(int type, vec3 color, float reflectiveness) {\n    Material material;\n    material.type = type;\n    material.color = color;\n    material.reflectiveness = reflectiveness;\n    return material;\n}\n\n\n//////////////////\n// Intersections\nfloat rayFloorIntersection(const Ray ray, const Plane plane) {\t\n\tif (ray.direction.y == 0.0)\n        return MAXDISTANCE;\t\n\n    float distance = -(ray.origin.y - plane.height) / ray.direction.y;\n    return distance > 0.? distance : MAXDISTANCE;\n}\n\nfloat raySphereIntersection(const Ray ray, Sphere sphere) {\n\tvec3  ds = ray.origin - sphere.center;\n\tfloat bs = dot(ray.direction, ds);\n\tfloat cs = dot(ds, ds) - sphere.radius;\n\tfloat ts = bs*bs - cs;\n\n\tif(ts <= 0.0) \n        return MAXDISTANCE;\n\n\tts = -bs - sqrt(ts);\n    return ts > 0. ? ts : MAXDISTANCE;\n}\n\n\n////////////\n// Hits\nHit hitFloor(Plane floor, Ray ray, float distance) {\n    Hit hit;\n    hit.point = ray.origin + ray.direction * distance;\n    hit.distance = distance;\n    hit.material = floor.material;\n    hit.normal = vec3( 0., 1., 0. );\n\n    return hit;\n}\n\nHit hitSphere(Sphere sphere, Ray ray, float distance) {\n    Hit hit;\n    hit.point = ray.origin + ray.direction * distance;\n    hit.distance = distance;\n    hit.material = sphere.material;\n    hit.normal = normalize(ray.origin + ray.direction * distance - sphere.center);\n\n    return hit;\n}\n\nHit hitSkybox(const Ray ray) {\n    Material material;\n    material.type = SKYBOX;\n    material.reflectiveness = 0.;\n    material.color = 1.4 * mix(vec3(.5), vec3(.7, .9, 1), .5 + .5 * ray.direction.y);\n    \n    Hit hit;\n    hit.distance = MAXDISTANCE;\n    hit.material = material;\n\n    return hit;\n}\n\n\n////////////////\n// Scene Trace\nHit trace(const Ray ray) {\n    // Scene\n    Sphere sphere1;\n    sphere1.center = vec3(0.0, 1.0, -2.5);\n    sphere1.radius = 1.0;\n    sphere1.material = material(\n        /*type*/    GEOMETRY,\n        /*color*/   vec3(.8, .8, .8),\n        /*reflect*/ 0.\n    );\n\n    Sphere sphere2;\n    sphere2.center = vec3(1.75 * sin(time), 1., -2.5 + 1.75 * cos(time));\n    sphere2.radius = .2;\n    sphere2.material = material(\n        /*type*/    GEOMETRY,\n        /*color*/   vec3(.95, .7, .45),\n        /*reflect*/ .95\n    );\n\n    Plane floor;\n    floor.height = .0;\n    floor.material = material(\n        /*type*/    GEOMETRY,\n        /*color*/   vec3(.8, .6, .6),\n        /*reflect*/ 0.\n    );\n\n    // Distance Checks\n    Hit hit;\n    float distanceCheck;\n\n    // Skyobx\n\thit = hitSkybox(ray);\n\n    // Floor\n\tif((distanceCheck = rayFloorIntersection(ray, floor)) < hit.distance)\n        hit = hitFloor(floor, ray, distanceCheck);\n\n    // Sphere 1\n    if((distanceCheck = raySphereIntersection(ray, sphere1)) < hit.distance)\n        hit = hitSphere(sphere1, ray, distanceCheck);\n\n    // Sphere 2\n    if((distanceCheck = raySphereIntersection(ray, sphere2)) < hit.distance)\n        hit = hitSphere(sphere2, ray, distanceCheck);\n\n\treturn hit;\n}\n\n////////////////////////////////////////////////////////////////\n// Main raytracing loop with bounces, diffuse, and reflections\nvec3 cosineWeightedRandomHemisphereDirection(const vec3 n) {\n\tvec3  uu = normalize(cross(n, vec3(0.0, 1.0, 1.0)));\n\tvec3  vv = cross(uu, n);\n\n\tfloat ra = sqrt(random.y);\n    float rb = 6.2831 * random.x;\n\tfloat rx = ra * cos(rb); \n\tfloat ry = ra * sin(rb);\n\tfloat rz = sqrt( 1.0 - random.y);\n\tvec3  rr = vec3( rx * uu + ry * vv + rz * n );\n\n    return normalize(rr);\n}\n\nvec3 bounces(Ray ray, inout Hit hit) {\n    vec3 sampled = hit.material.color;\n\n    for(int i = 0; i < BOUNCES - 1 && hit.material.type != SKYBOX; i++) {\n        shuffle();\n        vec3 diffuse = cosineWeightedRandomHemisphereDirection(hit.normal);\n        vec3 reflection = reflect(ray.direction, hit.normal);\n\n        ray.direction = normalize(mix(diffuse, reflection, hit.material.reflectiveness));\n        ray.origin = hit.point + EPSILON * ray.direction;\n\n        hit = trace(ray);\n        sampled *= hit.material.color;\n    }\n\n    return sampled;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\ttime = iTime;\n    initRandom(fragCoord, iFrame);\n\n    vec2 viewportPoint = viewport(fragCoord);\n\n    vec2 cameraWobble = vec2(\n        .1 * cos(time * 1.2),\n        .1 * sin(time * 1.2) + 2.5\n    );\n\n    Camera camera = camera(\n        /*position*/ vec3(cameraWobble, 1.5),\n        /*target*/   vec3(0, 2.15, 0),\n        /*roll*/     0.05 * cos(time * 1.2)\n    );\n\n\tvec3 color = vec3(0.);\n\n    for(int j = 0; j < SAMPLES; j++) {\n        shuffle();\n        Ray ray = cameraRay(camera, viewportPoint);\n        Hit hit = trace(ray);\n        vec3 sampled = bounces(ray, /*out*/ hit);\n\n        // Only add rays that hit the only source of light: the sky\n        if (hit.material.type == SKYBOX)\n\t\t\tcolor += sampled;\n\t}\n\t\n\tfragColor = vec4(color / float(SAMPLES), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}