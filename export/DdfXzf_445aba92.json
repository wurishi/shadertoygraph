{"ver":"0.1","info":{"id":"DdfXzf","date":"1669275455","viewed":286,"name":"Rainy Fountain","username":"Xibanya","description":"it seemed like a good idea at the time","likes":20,"published":1,"flags":32,"usePreview":1,"tags":["sdf","bokeh","rain","night","city","fountain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Luminance(vec3 col)\n{\n    return dot(col, vec3(0.2126729f,  0.7151522f, 0.0721750f));\n}\nvec3 Saturation(vec3 c, float sat)\n{\n    vec3 luma = vec3(Luminance(c));\n    return luma + vec3(sat) * (c - luma);\n}\nvec4 Blend(vec4 top, vec4 bottom) \n{\n\tvec4 result;\n\tresult.a = top.a + bottom.a * (1.0 - top.a);\n\tresult.rgb = (top.rgb * top.aaa + bottom.rgb * bottom.aaa * \n        (vec3(1.0, 1.0, 1.0) - top.aaa)) / result.aaa;\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n\tvec3 duv = texel.xyx * vec3(0.5, 0.5, -0.5);\n\tvec3 blur = texture(iChannel0, uv.xy - duv.xy).rgb;\n\tblur += texture(iChannel0, uv.xy - duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.xy).rgb;\n\tblur /= 4.;\n    vec3 col = Saturation(blur.rgb, 1.25) * 1.1;\n    \n    float n = fract(cos(\n        (sin(uv.x / texel.x) * uv.y / texel.y + iTime * 0.01)\n        * 90.) * 343.4);\n\tcol = mix(col, saturate(min(col, n)), 0.1);\n    \n    float vignette = saturate(\n        pow(length(uv * 2. - 1.), 3.) * 0.5);\n    col = mix(col, col * vec3(0.05, 0.25, 0.5), vignette);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float _XRot = -14.;\nconst float _YRot = 0.;\nconst float _XPos = .5;\nconst float _YPos = 1.3;\nconst float _ZPos = 4.2;\nconst float _FOV = 30.;\n\nconst int MARCH_STEPS = 150;\nconst int SHADOW_MARCH_STEPS = 100;\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst vec3 SHADOW_COLOR = vec3(0.25, 0.2, 0.4) * 0.5;\nconst vec3 WATER_COLOR = vec3(0.7, 0.7, 1.);\nconst vec3 RIPPLE_COLOR = vec3(1.);\nconst vec3 FOUNTAIN_COLOR = vec3(0.7, 0.8, 0.9);\nconst vec3 WINDOW_COLOR = vec3(0.9, 0.8, 0.4);\nconst vec3 _Light1Pos = vec3(-10., 5., -50.);\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat ClearWindows(vec2 uv, vec2 scale)\n{\n    float threshold = 0.6;\n    vec2 s2 = uv * scale;\n    float noise = hash12(floor(s2));\n    float square = step(threshold, noise);\n    return square;\n}\nfloat SDFBox2D(vec2 p, vec2 scale)\n{\n    vec2 dist = abs(p) - scale;\n    return length(max(dist, 0.)) + min(max(dist.x, dist.y), 0.);\n}\nfloat Grid(vec2 uv, vec2 scale)\n{\n    vec2 st = fract(uv) * scale;\n    vec2 fpos = fract(st);\n    vec2 ipos = floor(st);\n    float grid = clamp(sign(SDFBox2D(fpos, vec2(0.9, .8))), 0., 1.);\n    float borderRows = max(\n        step(scale.y - 1., ipos.y), \n        step(ipos.y, 0.));\n    float borderCols = max(\n        step(scale.x - 1., ipos.x),\n        step(ipos.x, 0.)\n    );\n    float borders = max(borderRows, borderCols);\n    grid = max(borders, grid);\n    grid = max(grid, ClearWindows(uv, scale));\n    return grid;\n}\n//https://www.shadertoy.com/view/ws3Bzf\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n)\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    // optional - add local support (prevents discontinuty)\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n// rain adapted from Dave Hoskins //\nfloat hash( float n ) { return fract(sin(n)*687.3123); }\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\nfloat Rain(vec2 uv, float time)\n{\n    vec2 st = 512. * (uv * vec2(0.5 - uv.y * 0.01, .01) + time * 0.1);\n    float rain = abs(noise(st) * noise(st * 0.75) * 1.55);\n    rain = clamp(pow(rain, 25.0), 0.0, uv.y * 0.25);\n    return rain;\n}\n\nfloat Scene(vec3 p, out Objects o) \n{\n    o.water = 1.;\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tvec4 a0 = vec4(p, 1.0);\n\ta0 = vec4(a0) - vec4(.87,.0,.0,.0);\n\twsPos = a0.xyz - vec3(.0,-.024,.0);\n\tfloat d0 = SDFCylinder(wsPos, .354,.091);\n\tvec4 a1 = a0;\n\twsPos = a1.xyz - vec3(.0,.521,.0);\n\tfloat d1 = SDFBox(wsPos,vec3(.348,.265,.402));\n   \n\tvec4 a2 = a1;\n\twsPos = ( a2.xyz * vec3(1.883,1.883,1.883)) - vec3(.0,.257,.0);\n\tfloat d2 = length(wsPos) - .5;\n\td1 = max(-d1,d2);\n\td0 = SDFUnion(d0,d1, 0.5);\n   \n\tvec4 a3 = (a0 * vec4(.778,.778,.778,1.0)) - vec4(.0,-.083,.0,.0);\n\twsPos = a3.xyz - vec3(.0,.31,.0);\n\tfloat topBasin = SDFCapped(wsPos, .47, .001);\n\n    float topWater = topBasin;\n\tvec4 a4 = a3;\n\twsPos = a4.xyz - vec3(.0,.267,.0);\n\tfloat d4 = SDFCylinder(wsPos, .531,.043);\n    \n\ttopBasin = max(-topBasin, d4);\n\n\td0 = min(d0,topBasin);\n    \n\tvec4 a5 = (a0 * vec4(.425, 3.138,.425,1.0)) - vec4(.0,.192,.0,.0);\n\twsPos = a5.xyz - vec3(.0,.496,.0);\n\tfloat d5 = SDFBox(wsPos,vec3(.096,.287,.096));\n\tvec4 a6 = (mat4(.707, .0, .707, .0, .0, 1.0, .0, .0, -.707, .0, .707, .0, .0, .0, .0, 1.0) * a5);\n\twsPos = a6.xyz - vec3(.0,.496,.0);\n\tfloat d6 = SDFBox(wsPos,vec3(.096,.287,.096));\n\td5 = max(d5,d6);\n\td0 = min(d0,d5);\n   \n\tvec4 a7 = a0;\n\twsPos = a7.xyz - vec3(.0, .542,.0);\n\tfloat d7 = SDFCylinder(wsPos, .055,.111);\n\td0 = SDFUnion(d0,d7, 0.25);\n    \n    vec2 bOff = vec2(.708, .696);\n\tvec4 a8 = a0 - vec4(-bOff.x,bOff.y,.0,.0);\n\twsPos = a8.xyz - vec3(0.7,-.497,-.032);\n\tfloat d8 = SDFBox(wsPos, vec3(1.481,.32,1.481));\n\tvec4 lowerBasin = a8 - vec4(bOff.x, -bOff.y, .0, .0);\n\tlowerBasin.xz = pModPolar(lowerBasin.xz, 6.0);\n    // .45 here rather than .7 to lower the apparent water level\n\twsPos = lowerBasin.xyz - vec3(.45,.0,-.032);\n\tfloat d9 = length(wsPos) - .5;\n\td8 = max(-d8,d9);\n\td0 = min(d0,d8);\n    \n\tvec4 a10 = a0 - vec4(-bOff.x,bOff.y,.0,.0);\n\twsPos = a10.xyz - vec3(.699,-.423,-.032);\n\t//float d10 = SDFBox(wsPos,vec3(1.481,.32,1.481));\n    float d10 = SDFBox(wsPos,vec3(1.481,.39,1.481));\n\tvec4 a11 = a10 - vec4(bOff.x,-bOff.y,.0,.0);\n\ta11.xz = pModPolar(a11.xz , 6.0);\n\twsPos = ( a11.xyz * vec3(1.184,1.435,1.184)) - vec3(.641,-.002,-.003);\n\tfloat d11 = length(wsPos) - .5;\n    o.water = min(o.water, d11);\n    o.water = max(o.water, -d10);\n    o.water = min(o.water, topWater);\n\tvec4 a12 = a11;\n\ta12.xz = pModPolar(a12.xz , 6.0);\n\twsPos = a12.xyz - vec3(.699,.0,-.032);\n\tfloat d12 = length(wsPos) - .5;\n\td11 = max(-d11,d12);\n\td10 = max(-d10,d11);\n\td0 = min(d0, d10);\n    o.fountain = max(d0, -o.water);\n\treturn d0;\n\n}\n// meant to be called when distance is needed but color zones are not.\nfloat Distance(vec3 p)\n{\n    Objects o;\n    return Scene(p, o);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 GetNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * EPSILON;\n    return normalize( e.xyy * Distance( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx * Distance( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy * Distance( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx * Distance( pos + e.xxx ) );\n}\nfloat March(vec3 pos, vec3 dir, out Objects o) \n{\n    float depth = MIN_DIST;\n    for (int i = 0; i < MARCH_STEPS; i++) \n    {\n        vec3 p = pos + depth * dir;\n        float dist = Scene(p, o);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= MAX_DIST) break;\n    }\n    return MAX_DIST;\n}\n// https://iquilezles.org/articles/rmshadows\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n    float mint = 0.02;\n    float tmax = 2.5;\n    float tp = (0.4 - ro.y) / rd.y; \n    if( tp > 0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i< SHADOW_MARCH_STEPS; i++ )\n    {\n\t\tfloat h = Distance( ro + rd*t );\n        float s = clamp(10.0 * h/t, 0.0, 1.0);\n        res = min( res, s*s*(3.0 - 2. * s) );\n        t += clamp(h, 0.02, 0.2 );\n        if( res < 0.004 || t > tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0);\n}       \nvec2 GetLight(vec3 normal, vec3 p, vec3 lightPos, vec3 viewDir)\n{\n    vec3 lightDir = normalize(lightPos - p);\n    float nDotL = max(0., dot(lightDir, normal));\n    float shadow = Shadow(p, lightDir);\n    shadow = smoothstep(0., 0.1, pow(shadow, 5.));\n    nDotL *= shadow;\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float specular = max(0., pow(max(0., dot(normal, halfDir)), 16.));\n    return vec2(nDotL, specular);\n}\nvec3 RayDir(float fieldOfView, vec2 size, vec2 fragCoord) \n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nfloat Ripple(vec2 uv)\n{\n    const float rMax = 0.01;\n    const float rMin = 0.0005;\n    float gridFactor = 2.;\n    vec2 grid = fract(uv * gridFactor) - 1. / gridFactor;\n    float off = mod(floor(uv.x * gridFactor), 2.) == 0.? 0.25 : 0.;\n    off += mod(floor(uv.y * gridFactor), 2.) == 0.? 0.25 : 0.;\n    float time = fract(iTime * 0.5 + off);\n    float fade = (1. - InvLerp(0.5 + off * 0.5, 0.95, time)) * InvLerp(0., 0.1, time);\n\n    float circle1 = length(grid) - 0.1 * time;\n    float circle2 = length(grid) - 0.15 * time;\n    float ripple = max(circle2, -circle1);\n    ripple = (1. - smoothstep(rMin, rMax, abs(ripple))) * fade;\n   \n    time = fract(time + 0.25 + off);\n    fade = (1. - InvLerp(0.5 + off * 0.5, 0.95, time)) * InvLerp(0., 0.1, time);\n    float circle3 = length(grid) - 0.2 * time;\n    circle3 *= 1. - InvLerp(0.9, 1., 0.2 * time);\n    float circle4 = length(grid) - 0.25 * time;\n    circle4 *= 1. - InvLerp(0.9, 1., 0.25 * time);\n    float ripple2 = max(circle4, -circle3);\n    ripple2 = (1. - smoothstep(rMin, rMax, abs(ripple2))) * fade;\n    ripple = clamp(ripple + ripple2, 0., 1.);\n\n    time = fract(time + 0.35 + off);\n    fade = (1. - InvLerp(0.5 + off * 0.5, 0.95, time)) * InvLerp(0., 0.1, time);\n    float circle5 = length(grid) - 0.3 * time;\n    circle5 *= 1. - InvLerp(0.9, 1., 0.3 * time);\n    float circle6 = length(grid) - 0.35 * time;\n    circle6 *= 1. - InvLerp(0.9, 1., 0.35 * time);\n    float ripple3 = max(circle6, -circle5);\n    ripple3 = (1. - smoothstep(rMin, rMax, abs(ripple3))) * fade;\n    ripple = clamp(ripple + ripple3, 0., 1.);\n   \n    return ripple;\n}\nstruct TriplanarUV\n{\n    vec2 x, y, z;\n};\nTriplanarUV GetTriplanarUV(vec3 p, vec3 normal)\n{\n    TriplanarUV triUV;\n\ttriUV.x = p.zy;\n\ttriUV.y = p.xz;\n\ttriUV.z = p.xy;\n\tif (normal.x < 0.)\n\t{\n\t\ttriUV.x.x = -triUV.x.x;\n\t}\n\tif (normal.y < 0.)\n\t{\n\t\ttriUV.y.x = -triUV.y.x;\n\t}\n\tif (normal.z >= 0.)\n\t{\n\t\ttriUV.z.x = -triUV.z.x;\n\t}\n\ttriUV.x.y += 0.5;\n\ttriUV.z.x += 0.5;\n\treturn triUV;\n}\nvec3 GetTriplanarWeights(vec3 normal)\n{\n    vec3 triW = abs(normal);\n    return triW / (triW.x + triW.y + triW.z);\n}\n\nvec3 Color(Objects o, vec3 pos, vec3 dir, vec3 normal, float dist)\n{\n    vec3 light1Pos = _Light1Pos;\n    if (iMouse.xy != vec2(0.)) light1Pos.x += ((iMouse.x / iResolution.x) * 2. - 1.) * 2.;\n    vec3 p = pos + dir * dist;\n  \n    // ALBEDO\n    float up = step(0.9, dot(normal, vec3(0., 1., 0.)));\n    // require all surfaces colored as water to be facing up (ie, flat horizontal)\n    float w = step(o.water, o.fountain) * up;\n\n    float fRipple = Ripple(Rotate2D(25., p.xz * 2. + 0.25)) * up;\n    float fountainSurface = 1. - biplanar(iChannel0, p * 0.5 + \n        vec3(1., 0., 1.) * fRipple, normal).r + fRipple * 0.5;\n    vec3 fountainColor = mix(FOUNTAIN_COLOR, vec3(1.), fountainSurface);\n\n    TriplanarUV t = GetTriplanarUV(p * 2., normal);\n    vec3 tW = GetTriplanarWeights(normal);\n    float rainTime = iTime * 0.25;\n    float rainDir = (1. - up);\n    float rain = (Rain(t.x, rainTime) * tW.x + Rain(t.y, rainTime) * tW.y + Rain(t.z, rainTime) * tW.z) * rainDir * 0.5;\n    fountainColor *= 1. + rain;\n\n    float wRipple = max(Ripple(p.xz), Ripple(Rotate2D(25., p.xz * 2.)));\n    vec3 waterColor = mix(WATER_COLOR, WATER_COLOR * 1.2, wRipple);\n\n    vec3 albedo = w == 1.? waterColor : fountainColor;\n\n    normal = \n        w * normalize(normal * vec3(1. + wRipple * 0.05)) +\n        (1. - w) * normalize(normal + rain * 2. + (fountainSurface * 2. - 1.) * 0.05)\n        ;\n\n    vec3 shadowColor = SHADOW_COLOR;\n\n    // DIFFUSE\n    vec2 light1Term = GetLight(normal, p + \n        vec3(wRipple, 1., wRipple) * w * up * 0.05 + \n        vec3(fRipple, 1., fRipple) * (1. - w) * 0.01, \n        light1Pos, dir);\n    vec3 light1 = WINDOW_COLOR * 3.;\n\n    vec2 reflUV = Rotate2D(-15., p.xz) * 0.75;\n    reflUV.x = (reflUV.x + sin(p.z * 200. + iTime * 4.) * 0.005 + \n        cos(p.z * 50. + iTime * 0.5) * 0.01) * w;\n    float bgBox = 1. - Grid(reflUV, vec2(20.));\n    bgBox = (bgBox + wRipple * mix(-2., 0.25, wRipple)) * w;\n    bgBox *= clamp(smoothstep(-0.05, 1.1, reflUV.y * 0.5 + 0.5), 0., 1.);\n    bgBox *= up;\n    vec3 windowColor = pow(WINDOW_COLOR * 5., vec3(2.));\n    light1 = mix(light1, windowColor, max(0., bgBox));\n\n    float diffuseTerm = light1Term.x;\n    float specTerm = light1Term.y;\n    float distAtten = 1. - InvLerp(51.5, 52.5, distance(light1Pos, p));\n    vec3 diffuse = mix(shadowColor, light1, light1Term.x * distAtten);\n\n    // FRESNEL\n    float fresnelTerm = 1. - max(0., dot(normal, -dir));\n    fresnelTerm = smoothstep(0.75, 0.8, fresnelTerm);\n    albedo += mix(albedo * 0.1, WINDOW_COLOR * 3., diffuseTerm) * fresnelTerm;\n\n    vec3 spec = diffuse * smoothstep(0.3, 0.7, specTerm);\n    spec = w * spec * max(0., (1. - wRipple * 0.25)) +\n        spec * fountainColor * max(0., (1. - fRipple));\n\n    vec3 col = albedo * diffuse + spec;\n    return col;\n}\n\n\nfloat Bubble(vec2 uv)\n{\n\tfloat circle = SDFCircle(uv * 2. + vec2(-1.), .0005);\n\tcircle =  1. - saturate(circle);\n    float mask = aastep(0.01, circle);\n    return max(0., (1. - circle) * mask);\n}\nvec4 Bubbles(vec2 uv)\n{\n    uv.y *= iResolution.y / iResolution.x;\n    uv *= 0.5;\n    \n    vec2 perlin = vec2(Perlin(uv, vec2(2., 6.)));\n    uv += perlin * 0.1;\n    \n    if (iMouse.xy != vec2(0.)) uv.x -= iMouse.x * 0.0025;\n    \n    vec2 st = fract(uv + vec2(iTime * 0.012, -0.05)) * vec2(14., 14.);\n    vec2 fpos = fract(st);\n    vec2 ipos = floor(st);\n    float grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 2., 7.), 0.), \n        step(mod(ipos.x - 2., 5.), 0.)\n    );\n    \n    vec4 wcColor = vec4(2.6, 1.2, 1.7, 1.) * 0.35 * grid;\n    \n    st = fract(uv + vec2(iTime * 0.01, -0.02)) * vec2(12., 12.);\n    fpos = fract(st);\n    ipos = floor(st);\n    grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 2., 7.), 0.), \n        step(mod(ipos.x - 8., 5.), 0.)\n    );\n    wcColor = mix(wcColor, vec4(3.9, 2.9, 1.2, 1) * 0.35, grid);  \n    \n    \n    \n    st = fract(uv + vec2(-iTime * 0.01, 0.1)) * vec2(16., 16.);\n    if (iMouse.xy != vec2(0.)) st.y -= iMouse.y * 0.001;\n    fpos = fract(st);\n    ipos = floor(st);\n    grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 4., 14.), 0.), \n        step(mod(ipos.x - 5., 7.), 0.)\n    );\n    wcColor = mix(wcColor, vec4(3.9, 2.9, 1.2, 1)  * 0.35, grid); \n    \n    st = fract(uv +\n        vec2(iTime * 0.0175, 0.3)) * vec2(16., 16.);\n    if (iMouse.xy != vec2(0.)) st.y += iMouse.y * 0.0015;\n    fpos = fract(st);\n    ipos = floor(st);\n    grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 7., 14.), 0.), \n        step(mod(ipos.x - 5., 4.), 0.)\n    );\n    wcColor = mix(wcColor, vec4(1.9, 1.1, 2.6, 1) * 0.35, grid);\n    \n    return wcColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 rot = vec2(_XRot, _YRot);\n\tvec3 dir = RayDir(_FOV, iResolution.xy, fragCoord);\n    dir *= XRotationMatrix(rot.x);\n    dir = dir * YRotationMatrix(rot.y);\n    vec3 pos = vec3(_XPos, _YPos, _ZPos);\n    Objects o;\n    float dist = March(pos, dir, o);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float bgGradient = clamp(length(uv), 0., 1.);\n    vec3 bg = mix(SHADOW_COLOR, WATER_COLOR, bgGradient);\n    bg = mix(SHADOW_COLOR, bg, uv.y);\n    vec3 diffuse = bg;\n    // foreground rain\n    float rain = Rain(uv, fract(iTime));\n    if (dist > MAX_DIST - EPSILON) \n    {\n        float bgRain = Rain(uv * 3., fract(iTime * 0.5)) * 0.25;\n        float blur = 0.003;\n        vec2 gUV = (uv + vec2(0.5, -0.2)) * vec2(1.5, 0.9);\n        float bgBox = 1. - (\n            Grid(gUV, vec2(20.)) +         \n            Grid(gUV + blur, vec2(20.)) +\n            Grid(gUV - blur, vec2(20.)) + \n            Grid(gUV + vec2(-blur, blur), vec2(20.)) + \n            Grid(gUV + vec2(blur, -blur), vec2(20.))) / 5.;\n        vec3 windowColor = mix(diffuse, WINDOW_COLOR * 2., \n            bgGradient * smoothstep(0.3, 1.1, uv.y));\n            \n        diffuse = mix(diffuse, windowColor, max(0., bgBox));\n        vec4 bubbles = max(Bubbles(uv), 0.75 * Bubbles(uv * 2. + vec2(0., -1.)));\n        diffuse += bubbles.rgb * 3. * bubbles.a;\n        // background rain\n        rain += bgRain; \n    }\n    else\n    {\n        vec3 p = pos + dist * dir;\n        vec3 normal = GetNormal(p);\n        diffuse = Color(o, pos, dir, normal, dist);\n    }\n    diffuse *= 1. + rain;\n    fragColor = vec4(diffuse, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define saturate(x) clamp(x, 0., 1.)\n#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n// Antialiased step\n// https://github.com/glslify/glsl-aastep\nfloat aastep(float threshold, float value) \n{\n    float afwidth = length(\n        vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(\n        threshold - afwidth, threshold+afwidth, value); \n}\n/////////// FBM ///////////////\n// see: https://thebookofshaders.com/13/\nfloat FBMRandom(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat FBMNoise(in vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = FBMRandom(i);\n    float b = FBMRandom(i + vec2(1.0, 0.0));\n    float c = FBMRandom(i + vec2(0.0, 1.0));\n    float d = FBMRandom(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\nfloat FBM(vec2 st, float octaves)\n{\n    float value = 0.;\n    float amplitude = 0.5;\n    float frequency = 0.;\n    for (float i = 0.; i < octaves; i++)\n    {\n        value += amplitude * FBMNoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n///////////////////////////////////////////\n// Perlin \n// see: https://thebookofshaders.com/11/\nfloat SmoothCos(float a, float b, float x)\n{\n    float f = (1. - cos(x * 3.1415927)) * 0.5;\n    return a * (1. - f) + b * f;\n}\n// params.x = precision, params.y = octaves\nfloat Perlin(vec2 uv, vec2 params)\n{\n    float p = 0.;\n    float t = params.x;\n    for (float i = 0.; i < params.y; i++)\n    {\n        float a = FBMRandom(vec2(floor(t * uv.x) / t, floor(t * uv.y) / t));\t   \n        float b = FBMRandom(vec2(ceil (t * uv.x) / t, floor(t * uv.y) / t));\t\t\n        float c = FBMRandom(vec2(floor(t * uv.x) / t, ceil (t * uv.y) / t));\t\t\n        float d = FBMRandom(vec2(ceil (t * uv.x) / t, ceil (t * uv.y) / t));\n        if ((ceil(t * uv.x) / t) == 1.)\n        {\n            b = FBMRandom(vec2(0., floor(t * uv.y) / t));\n            d = FBMRandom(vec2(0., ceil(t * uv.y) / t));\n        }\n        float coef1 = fract(t * uv.x);\n        float coef2 = fract(t * uv.y);\n        p += SmoothCos(\n                SmoothCos(a, b, coef1),\n                SmoothCos(c, d, coef1),\n                coef2\n                ) * (1. / pow(2., (i + 0.6)));\n        t *= 2.;\n    }\n    return p;\n}\n\nstruct Objects {\n    float fountain; float water;\n};\n\nmat3 YRotationMatrix(float degrees)\n{\n\tfloat angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat3 rotateYMatrix = mat3(\n        c, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c);\n\treturn rotateYMatrix;\n}\nmat3 ZRotationMatrix(float degrees)\n{\n\tfloat angleZ = radians(degrees);\n\tfloat c = cos(angleZ);\n\tfloat s = sin(angleZ);\n\tmat3 rotateZMatrix = mat3(\n        c, -s, 0,\n\t\ts, c, 0,\n\t\t0, 0, 1\n\t\t);\n\treturn rotateZMatrix;\n}\nmat3 XRotationMatrix(float degrees)\n{\n\tfloat angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat3 rotateXMatrix = mat3(\n        1, 0, 0,\n\t\t0, c, -s, \n\t\t0, s, c);\n\treturn rotateXMatrix;\n}\nvoid Rotate(inout vec3 o, vec3 a)\n{\n    vec3 localScaledTranslatedRotX = o * XRotationMatrix(a.x);\n    vec3 localScaledTranslatedRotXY = localScaledTranslatedRotX * YRotationMatrix(a.y);\n    o = localScaledTranslatedRotXY * ZRotationMatrix(a.z);\n}\nmat2 Rotate2DMatrix(float a)\n{\n    a = radians(a);\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\nvec2 Rotate2D(float angle, vec2 original)\n{\n    return Rotate2DMatrix(angle) * original;\n}\n/////////////////////////////////\n//https://iquilezles.org/articles/distfunctions/\nfloat SDFBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    vec3 v = min(d, 0.);\n    return length(max(d, 0.0)) + max(max(v.x, v.y), v.z);\n}\nfloat SDFCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\nfloat SDFTri( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat SDFCylinder(vec3 p, float r, float height) \n{\n    float d = length(p.xz) - r;\n    return max(d, abs(p.y) - height);\n}\nfloat SDFCapped( vec3 p, float r, float h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat SDFSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\nfloat SDFCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat SDFUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat SDFSub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nvec2 pModPolar(vec2 p, float repetitions) \n{\n    float angle = 2.0 * PI / repetitions;\n    float a = atan(p.y, p.x) + angle * .5;\n    float r = length(p);\n\n    a = mod(a, angle) - angle * .5;\n    return vec2(cos(a), sin(a)) * r;\n}\nfloat InvLerp(float from, float to, float value)\n{\n    return clamp((value - from) / (to - from), 0., 1.);\n}","name":"Common","description":"","type":"common"}]}