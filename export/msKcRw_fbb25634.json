{"ver":"0.1","info":{"id":"msKcRw","date":"1695951149","viewed":76,"name":"Sketch #17: Elastic Cube","username":"MOONtyzoo","description":"Originally I was messing around with using matrices to warp the sdf cube, which led me to make this cool spring-like twist animation.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MIN_DIST 0.2\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\n#define PI 3.14159265359\n\n// From https://easings.net/#easeOutQuad\nfloat easeOutQuad(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\n// From https://easings.net/#easeOutElastic\nfloat easeOutElastic(float x)\n{\n    float c4 = (2.0 * PI) / 3.0;\n\n    return x == 0.0\n      ? 0.0\n      : x == 1.0\n      ? 1.0\n      : pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\n\n// --------------------------------------------\n\nstruct sdfData\n{\n    float dist;\n    vec4 col;\n};\n\nsdfData SdfU(sdfData a, sdfData b)\n{\n    if (a.dist < b.dist) {return a;}\n    else {return b;}\n}\n\nsdfData SdfGrid(vec3 p)\n{\n    float xDist = sqrt(p.y*p.y + p.z*p.z);\n    float yDist = sqrt(p.x*p.x + p.z*p.z);\n    float zDist = sqrt(p.y*p.y + p.x*p.x);\n    vec4 xCol = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 yCol = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 zCol = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    sdfData sdfX = sdfData(xDist, xCol);\n    sdfData sdfY = sdfData(yDist, yCol);\n    sdfData sdfZ = sdfData(zDist, zCol);\n    return SdfU(sdfX, SdfU(sdfY, sdfZ));\n}\n\nsdfData SdfBox(vec3 p, vec4 col, vec3 size)\n{\n    p = abs(p) - size/2.0;\n    float dist = length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n    return sdfData(dist, col);\n}\n\n/*  \n    Defines all of the objects that are visible in the scene\n*/\nsdfData SdfScene(vec3 p)\n{ \n    // Matrix transforms the point's position, altering the definition of it's \"distance\"\n    // which causes the shapes to become warped.\n    float stretch;\n    \n    float anim = mod(iTime, 6.0);\n    if (anim < 4.0)\n    {\n        stretch = 1.0 + 3.0*easeOutQuad(anim/4.0);\n    }\n    else\n    {\n        float elastic = 3.0*easeOutElastic((anim - 4.0)/2.0);\n        elastic /= 1.0 + 0.17*smoothstep(3.0, 4.0, elastic);\n        stretch = 4.0 - elastic;\n    }\n    \n    float angle = (stretch-1.0)*p.y;\n    \n    mat4 rotate = inverse(mat4(\n        cos(angle), 0.0, sin(angle), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin(angle), 0.0, cos(angle), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    ));\n\n    vec3 cubeSize = vec3(1.5/sqrt(stretch), stretch*1.5, 1.5/sqrt(stretch));\n    \n    sdfData box = SdfBox((vec4(p, 1.0)*rotate).xyz, vec4(0.925,0.235,0.373,1.0), cubeSize);\n    box.dist -= 0.1;\n    \n    return box;\n}\n\n// ---------------------------------------------------\n\n/*\n    Returns distance from ro along rd to the hitpoint\n    Also outputs the color of the sdf surface that is hit\n*/\nfloat RayMarch(vec3 ro, vec3 rd, out vec4 col)\n{\n    float dist = MIN_DIST;\n    col = vec4(0.859,0.859,0.859, 1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dist * rd;\n        \n        sdfData sdf = SdfScene(p);\n        float stepDist = sdf.dist;\n        dist += stepDist;\n        \n        if (dist > MAX_DIST) break;\n        if (stepDist < SURF_DIST)\n        {col = sdf.col; break;}\n    }\n    \n    return dist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 d = vec2(0.0, 0.01);\n    \n    vec3 n = (SdfScene(p).dist -\n              vec3(SdfScene(p - d.yxx).dist,\n                   SdfScene(p - d.xyx).dist,\n                   SdfScene(p - d.xxy).dist));\n    \n    return normalize(n);\n}\n\nvec3 ShadePoint(vec3 p, vec4 col)\n{\n    vec3 l = normalize(vec3(-1, -1, -1));\n    vec3 n = GetNormal(p);\n    float val = 0.6 + (-dot(l, n) + 1.0)/5.0;\n    \n    return val*col.rgb;\n}\n\n// ---------------------------------------------------\n\nmat4 cameraLookAt(vec3 from, vec3 to)\n{\n    vec3 forward = normalize(from-to);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    mat4 mat =  mat4(right.x, right.y, right.z, 0.0,\n                up.x, up.y, up.z, 0.0,\n                forward.x, forward.y, forward.z, 0.0,\n                from.x, from.y, from.z, 1.0);\n                \n    return mat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(5.5*sin(0.2*iTime), 2.0, 5.5*cos(0.2*iTime));\n    vec3 rd = normalize( cameraLookAt(ro, vec3(0.0)) * vec4(uv.x, uv.y, -1.0, 0.0) ).xyz;\n    \n    vec4 sdfCol;\n    float dist = RayMarch(ro, rd, sdfCol);\n    \n    vec3 p = ro + dist * rd;\n    vec3 col = (dist < MAX_DIST) ? ShadePoint(p, sdfCol): vec3(0.961,0.980,1.000);\n    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}