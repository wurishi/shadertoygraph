{"ver":"0.1","info":{"id":"lXXXWr","date":"1709921491","viewed":221,"name":"Primitive Rain v2","username":"incre_ment","description":"Iteration on Primitive Rain that uses neighbor checking to get more horizontal movement of rain drops.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is an iteration on the Primitive Rain shader I made about a week ago.\n// I wanted to make the rain move more horizontally, and so this version\n// implements neighbor checking across the x-cells.  Used the ellipse SDF for \n// the drops, as well.  Also, added some dynamics to the puddle splash.\n//\n// Still using the Ellipse SDF (Thanks IQ).  FN suggested a stretched circle, \n// SDF, which I still need to look into!\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   \n    vec3 col = vec3(0.);   \n    \n    float t = fract(iTime);\n\n    // Set number of layers of rain\n    for(float numLayers = 0.; numLayers <10.; numLayers++){ \n\n     float scale = 10. + numLayers;\n     vec2 uv_layer = uv;    \n    \n     // Scale the uv_layers\n     uv_layer *= scale;\n                \n     // Create cellID in X direction\n     float cellIDx = floor(uv_layer.x);\n\n     // Make each x cell go from -.5 to .5\n     uv_layer.x = fract(uv_layer.x) - .5;\n   \n     // Calculate 2 \"random\" numbers: rain fall offset and starting y pos\n     float cellOff = fract(324.6*sin(46.7*cellIDx + numLayers));\n     float n_cellOff = fract(324.6*sin(46.7*(cellIDx+1.) + numLayers));\n     \n       \n     // Calculate the delta x and delta y for the rain drop\n     float xVal = 1.0 - 1.0*fract(t + cellOff);\n     float n_xVal = 1.0 - 1.0*fract(t + n_cellOff);\n     \n     // Calculate some useful quantities for defining the y position\n     float rainfallCutOff = -4.; \n     float fallHeight = (2.5 * scale/2.);\n     float rainDelta = fallHeight - rainfallCutOff;\n     \n     // Calculate the y value \"center\" for current cell and neighbor.\n     float yVal =  fallHeight - rainDelta*fract(t + cellOff);\n     float n_yVal =  fallHeight - rainDelta*fract(t + n_cellOff);\n   \n     // Calculate ellipse SDF for current cell and neighbor, and take the min.\n     float drop1 = sdEllipse(uv_layer - vec2(n_xVal, n_yVal), vec2(.03,.15));\n     float drop2 = sdEllipse((uv_layer - vec2(xVal, yVal) - vec2(-1.0,0.0)), vec2(.03,.15));\n    \n     float drop = min(drop1,drop2);\n\n     // Draw the circle;\n     float w = 10./iResolution.y;\n     col += smoothstep(w,-w,drop);\n\n     // When the drop gets close start to expand the puddle.\n     // I realize the puddle should start AFTER the drop disappears, but let's \n     // call it a creative decision!\n     if (n_yVal < rainfallCutOff + 3.5){\n       float dropDelta = map((rainfallCutOff + 3.5) - n_yVal, 0., 3.5, 0., 1.);     \n       float ell = abs(sdEllipse(uv_layer - vec2(0., rainfallCutOff), vec2(.45*dropDelta,.2*dropDelta))) - .03;\n       w = 20./iResolution.y;\n       col += smoothstep(w,-w,ell);\n     }\n     \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Ellipse SDF by IQ\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n","name":"Common","description":"","type":"common"}]}