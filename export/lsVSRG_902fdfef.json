{"ver":"0.1","info":{"id":"lsVSRG","date":"1465159527","viewed":405,"name":"multiple ngon and perspective","username":"PeterVivo","description":"try to solve #MdKXWW without for and array","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["interaction","ngon","perspectiove"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//adapted from this opengl method:\n//http://stackoverflow.com/questions/16989181/whats-the-correct-way-to-draw-a-distorted-plane-in-opengl\n\n//drags from buffer\n//buffer variables\nconst int maxCount = 21;\nvec2 PP[maxCount];  //store the buffer drags values\nconst float radius = 5.0;\nconst float border = .5;\n\nconst float statePos = float(maxCount);\n#define BufA(x) texture(iChannel0, (vec2(x, 0.0) + 0.5) / iResolution.xy)\n\n// From: Iq\n// https://www.shadertoy.com/view/lsBSDm\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nfloat xross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = xross( g, f );\n    float k1 = xross( e, f ) + xross( h, g );\n    float k0 = xross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n    if( w<0.0 ) return vec2(-1.0);\n\n    w = sqrt( w );\n    \n    float v1 = (-k1 - w)/(2.0*k2);\n    float v2 = (-k1 + w)/(2.0*k2);\n    float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);\n    float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);\n    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;\n    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;\n    \n    vec2 res = vec2(-1.0);\n\n    if(  b1 && !b2 ) res = vec2( u1, v1 );\n    if( !b1 &&  b2 ) res = vec2( u2, v2 );\n    \n    return res;\n}\n\n\n// http://alienryderflex.com/polygon/\n\n    bool innerNgonFill( vec2 uv, vec2 PPi , vec2 PPj , inout bool isInner )\n    {\n        if (( PPi.y < uv.y && PPj.y >= uv.y || PPj.y < uv.y && PPi.y >= uv.y ) && ( PPi.x <= uv.x || PPj.x <= uv.x )) \n            if ( PPi.x + ( uv.y - PPi.y ) / ( PPj.y -PPi.y ) * ( PPj.x - PPi.x ) < uv.x ) \n                isInner=!isInner; \n\n        return isInner;\n    }\n\n#define fill(a,b) innerNgonFill( uv , PP[a] , PP[b] , isInner )\n\nfloat line(vec2 uv, vec2 origin, vec2 destiny, float radius){\n    destiny -= origin;\n    float color = length( clamp( dot(uv-origin,destiny)/dot(destiny,destiny), 0.,1.) *destiny - uv+origin );\n    return smoothstep(color-0.0005,color+0.0005, radius);    \n}\n\n#define li(a,b) color = mix(color, dotCol , line(uv, PP[a], PP[b], .002))\n#define ngonEdit( start,end, r,g,b ) dotCol = vec3( r,g,b ); for( int i = start; i <= end ; i++ ){\tli( i , i == end ? start : i+1 ); }\n#define ngonFill( start, end ) isInner = false; for( int i = start; i <= end ; i++ ){ fill( i, i==start ? end : i-1 ); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // read drag buffer\n    vec4 state = BufA(statePos);\n    float curr = 0.0;\n    float dist = radius + 1.0;\n    for (int i = 0; i < maxCount; ++i) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        float d = distance(fragCoord, center);\n        if (d < dist) {\n            dist = d;\n            curr = f;\n        }\n    }\n    for (int i = 0; i < maxCount; i++) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        \n        //store drag values\n        PP[i] = center/iResolution.xy;\n    }\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // background\n    vec3 color = mix( texture(iChannel2, uv).rgb , vec3(.7) , vec3(1.2) ) ; //background\n   \n    // ngon fill\n    // bool isMask = ngonFill( uv , PP ) ;\n    bool  isInner;    \n    ngonFill( 4 , 10 ); bool isMask = isInner;\n    ngonFill( 11, 14 ); bool isMask2 = isInner;\n\n    // distort\n    vec2 texUv = invBilinear( uv, PP[0], PP[1], PP[2], PP[3] );\n    if( texUv.x>-0.5 && isMask )\n        color = texture( iChannel1, texUv ).xyz + mix( texture(iChannel2, texUv ).rgb , vec3(.1) , vec3(1.2) ) ;\n\n    texUv = invBilinear( uv, PP[15], PP[16], PP[17], PP[18] );\n    if( texUv.x>-0.5 && isMask2 )\n        color = texture( iChannel3, texUv ).xyz;\n    \n    // interaction \n    \n    vec3 dotCol;\n    ngonEdit( 0 , 3 , .7,.7,.7 ); // perspective1\n    ngonEdit( 4, 10 , .2,.8,.2 ); // ngon1\n    ngonEdit( 11 , 14 , .9,.9,.9 ); // perspective2\n    ngonEdit( 15 , 18 , .4,.4,.7 ); // ngon2\n    \n    //drags\n\n    if (dist < radius) {\n        if (dist > radius - border) {\n            color = vec3( .0,.0,.0 ); // border\n        } else {\n            if (curr == state.x)\n                if (state.z > 0.0)                    \n                    color = vec3( .0,.7,.9 ); //mouse pressed\n                else\n                    color = vec3(.5,.5,.5 ); //last pressed\n            else                \n                color = vec3(.5,.5,.5 ); //standby\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Drag and drop framework\n// https://www.shadertoy.com/view/4dtSRn\n// by mhnewman\n//\n// maxCount := the maximum number of objects that can be represented.\n//\n// Buffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n//  * .x := the object's x coordinate.\n//  * .y := the object's y coordinate.\n//\n// Buffer pixel (maxCount, 0) := the current state.\n//  * .x := the index of the currently selected object.\n//  * .y := the number of active objects.\n//  * .z := the mouse state.\n//\n// Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\nconst int maxCount = 21;\n\nconst float radius = 50.0;\n\nconst float statePos = float(maxCount);\nconst float offsetPos = float(maxCount + 1);\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5;\n    vec3 IR = iResolution;\n    \n    if (p.y > 0.0 || p.x > offsetPos) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        float count = 0.0;\n\n        // Initial conditions\n        \n        // perspective start coords\n        addObject(0.2 * IR.x+0.01, 0.1 * IR.y);\n        addObject(0.8 * IR.x, 0.2 * IR.y);\n        addObject(0.7 * IR.x, 0.7 * IR.y);\n        addObject(0.2 * IR.x, 0.87 * IR.y);\n        \n        // mask start coords\n        addObject( 0.25 * IR.x, 0.75 * IR.y);\n        addObject( 0.45 * IR.x, 0.70 * IR.y);\n        addObject( 0.49 * IR.x, 0.40 * IR.y);\n        addObject( 0.70 * IR.x, 0.45 * IR.y);        \n        addObject( 0.79 * IR.x, 0.22 * IR.y);\n        addObject( 0.22 * IR.x, 0.12 * IR.y);\n        addObject( 0.35 * IR.x, 0.30 * IR.y);\n\n        addObject(0.3 * IR.x, 0.2 * IR.y);\n        addObject(0.9 * IR.x, 0.3 * IR.y);\n        addObject(0.8 * IR.x, 0.8 * IR.y);\n        addObject(0.3 * IR.x, 0.9 * IR.y);\n        \n        addObject(0.32 * IR.x, 0.22 * IR.y);\n        addObject(0.92 * IR.x, 0.32 * IR.y);\n        addObject(0.82 * IR.x, 0.82 * IR.y);\n        addObject(0.32 * IR.x, 0.92 * IR.y);\n        \n        \n        \n        if (p.x == statePos)\n            fragColor = vec4(2.0 * statePos, count, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 state = texture(iChannel0, vec2(0.5 + statePos, 0.5) / IR.xy);\n    vec4 offset = texture(iChannel0, vec2(0.5 + offsetPos, 0.5) / IR.xy);\n\n    if (state.z <= 0.0 && iMouse.z > 0.0) {\n        float r = radius + 1.0;\n        for (int i = 0; i < maxCount; ++i) {\n            float f = float(i);\n            if (f >= state.y)\n                break;\n            vec4 center = texture(iChannel0, vec2(0.5 + f, 0.5) / IR.xy);\n            float d = distance(iMouse.xy, center.xy);\n            if (d < r) {\n                r = d;\n                state.x = f;\n                offset = center - iMouse;\n            }\n        }\n        if (r > radius) {\n            if (state.y >= statePos) {\n                state.x = 2.0 * statePos;\n            } else {\n                state.x = state.y;\n                state.y += 1.0;\n            }\n        }\n    }\n    state.z = iMouse.z;\n    \n    if (p.x == statePos) {\n        fragColor = state;\n        return;\n    }\n    \n    if (p.x == offsetPos) {\n        fragColor = offset;\n        return;\n    }\n\n    if (p.x == state.x && state.z > 0.0) {\n        fragColor = iMouse + offset;\n        return;\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / IR.xy);\n}","name":"Buf A","description":"","type":"buffer"}]}