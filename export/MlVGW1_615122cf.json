{"ver":"0.1","info":{"id":"MlVGW1","date":"1474680979","viewed":267,"name":"Core Harvesting","username":"zackpudil","description":"Yet another kali fractal shader. YAKFS. \nUse mouse to move camera.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 res() { return iResolution.xy; }\nvec2 mouse() { return  vec2(iMouse.x, -iMouse.y); }\nfloat time() { return iTime; }\n\nvoid rotate(inout vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    p = mat2(c, s, -s, c)*p;\n}\n\nvec4 orbitTrap;\n\nfloat de(vec3 p) {\n    // \n\tp.xz -= iMouse.z != 0.0 ?(-res() + 2.0*mouse())/res().y : vec2(0.5);\n    p.y += 0.2*time();\n    p.xz = mod(p.xz + 0.5, 1.0) - 0.5;\n    vec4 q = vec4(p, 1);\n    q.y = mod(q.y + 2.0, 4.0) - 2.0;\n    \n    rotate(q.xz, 0.07*time());\n    orbitTrap = vec4(10.0);\n    \n    for(int i = 0; i < 7; i++) {\n        q.xyz = abs(q.xyz) - vec3(0.01, 1.97, 0.1);\n        float r = dot(q.xyz, q.xyz);\n        \n        q /= clamp(r, 0.5, 1.0);\n        q = 2.0*q - vec4(1.3, 1.0, 0.4, 0.0);\n        \n        if(i < 7)\n            orbitTrap.x = min(orbitTrap.x, \n                              2.0*sin(2.0*time() + q.x*q.z*10.0)\n                             + sin(q.y + time()));\n    }\n    \n    float f = length(p.xz) - 0.4;\n    f = max(-(length(p.xz) - 0.2), f);\n    f = max(f, length(q.xz)/q.w - 0.003);\n    \n    return f;\n}\n\nfloat trace(vec3 o, vec3 d, float m) {\n    float t = 0.001;\n    \n    \n    for(int i = 0; i < 100; i++) {\n        float d = de(o + d*t);\n        if(d < 0.001*t || t >= m) break;\n        t += d;\n    }\n    \n    if(t < m) return t;\n    return -1.0;\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        de(p + h.xyy) - de(p - h.xyy),\n        de(p + h.yxy) - de(p - h.yxy),\n        de(p + h.yyx) - de(p - h.yyx)\n\t);\n    return normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float s = 0.005;\n    float o = 0.0, w = 1.0;\n    \n    for(int i = 0; i < 15; i++) {\n        float d = de(p + n*s);\n        o += (s - d)*w;\n        s += s/(float(i) + 1.0);\n    }\n    \n    return 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec4 texcube(sampler2D s, vec3 p, vec3 n) {\n    vec3 m = pow(n, vec3(30.0));\n    \n    vec4 x = texture(s, p.yz);\n    vec4 y = texture(s, p.xz);\n    vec4 z = texture(s, p.xy);\n    \n    return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 material(vec3 p, vec3 n) {\n    return mix(1.0*texcube(iChannel0, p, n).xyz, vec3(1.4, 1.9, 4.0), orbitTrap.x);\n}\n\nvec3 render(vec3 eye, vec3 lat) {\n    vec3 col = vec3(0);\n    \n    float tra = trace(eye, lat, 100.0);\n    if(tra < 0.0) return col;\n    \n    vec3 pos = eye + lat*tra;\n    vec3 nor = normal(pos);\n    \n    vec3 mat = material(pos, nor);\n    float occ = ao(pos, nor);\n\n    col += 1.0*occ + occ*mat;\n    col = mix(col, vec3(1.0), 1.0 - exp(-1.0*tra));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-res() + 2.0*fragCoord)/res().y;\n    \n    vec3 ro = vec3(0.0, 0.0, -0.01);\n    vec3 la = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize(la-ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.97*ww);\n    \n    vec3 col = render(ro, rd);\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}