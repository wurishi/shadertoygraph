{"ver":"0.1","info":{"id":"7l3fWH","date":"1663014138","viewed":57,"name":"Shader Assignment 1 HA","username":"henryanderson","description":"Just a bunch of colors to give people eye problems","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cs4710"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Henry Anderson\n\n//From Dr. Landon\nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc,   0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts,   0.0, c\n\t);\n}\n//http://patriciogonzalezvivo.com\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(mod(iTime-29.0,11.0),mod(iTime,23.0))))*\n        43758.5453123);\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    \n    vec3 col = vec3(0.0);\n    \n    // Background\n    if (mod(iTime,2.0)>1.0){\n        col = vec3((1.0-(abs(uv.x)+abs(uv.y)))*(0.5-abs(mod(iTime,1.0)-0.5)),\n                 mod(iTime,1.0)*abs(uv.x)*2.0,\n                 (1.0-mod(iTime,1.0))*abs(uv.y)*2.0);\n    }else{\n        col = vec3((1.0-(abs(uv.x)+abs(uv.y)))*(0.5-abs((1.0-mod(iTime,1.0))-0.5)),\n                 (1.0-mod(iTime,1.0))*abs(uv.x)*2.0,\n                 mod(iTime,1.0)*abs(uv.y)*2.0);\n    }\n    \n    float t = 0.0;\n    float tdx = 0.0;\n    float tdy = 0.0;\n    \n    vec3 dir = normalize(vec3(uv.x, uv.y, 4));\n    vec3 dirdx = normalize(vec3(uv.x+0.01, uv.y, 4));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.01, 4));\n    vec3 eye = vec3(0, 0.0, -100);\n    for( int i = 0; i < 10; i++){\n        //calc positions from view rays\n        vec3 pos = eye + dir * t;\n        vec3 posdx = eye + dirdx * tdx;\n        vec3 posdy = eye + dirdy * tdy; \n        \n        //get distance from positions to the link\n        float dist1 = sdLink(rotateY(iTime)*pos, 7.0f,2.0f,0.5f);\n        float distdx1 = sdLink(rotateY(iTime)*posdx, 7.0f,2.0f,0.5f);\n        float distdy1 = sdLink(rotateY(iTime)*posdy, 7.0f,2.0f,0.5f);\n        \n        float dist2 = sdTorus(pos-vec3(cos(iTime)*6.0,sin(iTime)*4.0,-1), vec2(cos(iTime*2.0)+1.0,1.0f));\n        float distdx2 = sdTorus(posdx-vec3(cos(iTime)*6.0,sin(iTime)*4.0,-1), vec2(cos(iTime*2.0)+1.0,1.0f));\n        float distdy2 = sdTorus(posdy-vec3(cos(iTime)*6.0,sin(iTime)*4.0,-1), vec2(cos(iTime*2.0)+1.0,1.0f));\n      \n        if(dist1 < 0.01 && distdx1 < 0.01 && distdy1 < 0.01){                        \n            col = vec3(sin(iTime/3.0),sin(iTime/2.0),(sin(iTime)+1.0)/2.0);\n        }\n        if(dist2 < 0.01 && distdx2 < 0.01 && distdy2 < 0.01){   \n            col = vec3(cos(uv.x*100.0*mod(iTime,10.0))*10.0,\n            cos((uv.x+0.1)*100.0*mod(iTime,10.0))*10.0,\n            cos((uv.x+0.2)*100.0*mod(iTime,10.0))*10.0);\n        }\n        t += min(dist1,dist2);\n        tdx += min(distdx1,distdx2);\n        tdy += min(distdy1,distdy2);\n    }\n    \n    // Filter\n    col = vec3(random( uv +0.5))*col*2.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}