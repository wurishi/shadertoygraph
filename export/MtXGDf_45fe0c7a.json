{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// many thanks to IQ for his useful articles !\n\nvec3 sunColor = vec3(1.8, 1.1, 0.6);\nvec3 skyColor = vec3(0.4, 0.6, 0.85);\nvec3 sunLightColor = vec3(1.5, 1.25, 0.9);\nvec3 skyLightColor = vec3(0.15, 0.2, 0.3);\nvec3 indLightColor = vec3(0.4, 0.3, 0.2);\nvec3 cloudsColor = vec3(1.0, 1.0, 1.0);\nvec3 horizonColor = vec3(0.7, 0.75, 0.8);\nvec3 fogColorB = vec3(0.7, 0.8, 0.9);\nvec3 fogColorR = vec3(0.8, 0.7, 0.6);\n\nvec3 sunDirection = normalize(vec3(0.6, 0.8, 0.5));\n\nfloat cloudsHeight = 800.0;\nfloat cloudsDensity = 0.3;\nfloat cloudsCover = 0.2;\n\nfloat noiseT(in vec2 p) {\n    return texture(iChannel0, p / 256.0, -100.0).x * 2.0 - 1.0;\n}\n\nfloat noiseW(in vec2 p) {\n    return texture(iChannel0, (p - 16.0) / 256.0, -100.0).x;\n}\n\nfloat fBm(in vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    for(int i = 0; i < 4; i++) {\n        sum += amp * noiseT(p);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return sum;\n}\n\nfloat fBmC(in vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    for(int i = 0; i < 5; i++) {\n        sum += amp * noiseT(p);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return sum;\n}\n\nfloat fBmW(in vec2 p) {\n    float sum = 0.0;\n    float amp = 0.5;\n    for(int i = 0; i < 5; i++) {\n        sum += amp * noiseT(p);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return sum * 0.2;\n}\n\nfloat raymarchTerrain(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float t = tmin;\n    for (int i = 0; i < 300; i++) {\n        vec3 p = ro + rd * t;\n        float d = p.y - fBm(p.xz);\n        if (d < (0.001 * t) || t > tmax)\n            break;\n        t += 0.2 * d;\n    }\n    return t;\n}\n\nvec3 getTerrainNormal(in vec3 p, float t) {\n    float eps = 0.025;\n    return normalize(vec3(fBm(vec2(p.x - eps, p.z)) - fBm(vec2(p.x + eps, p.z)),\n                          2.0 * eps,\n                          fBm(vec2(p.x, p.z - eps)) - fBm(vec2(p.x, p.z + eps))));\n}\n\nvec3 getWaterNormal(in vec3 p, float t) {\n    float eps = 0.025;\n    return normalize(vec3(fBmW(vec2(p.x - eps, p.z)) - fBmW(vec2(p.x + eps, p.z)),\n                          2.0 * eps,\n                          fBmW(vec2(p.x, p.z - eps)) - fBmW(vec2(p.x, p.z + eps))));\n}\n\nfloat raymarchAO(in vec3 ro, in vec3 rd, float tmin) {\n    float ao = 0.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float t = tmin + pow(i / 5.0, 2.0);\n        vec3 p = ro + rd * t;\n        float d = p.y - fBm(p.xz);\n        ao += max(0.0, t - 0.5 * d - 0.05);\n    }\n    return 1.0 - 0.4 * ao;\n}\n\nfloat raymarchWaterAO(in vec3 ro, in vec3 rd, float tmin) {\n    float ao = 0.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float t = tmin + pow(i / 5.0, 2.0);\n        vec3 p = ro + rd * t;\n        float d = p.y - fBmW(p.xz);\n        ao += max(0.0, t - 0.5 * d - 0.05);\n    }\n    return 1.0 - 0.4 * ao;\n}\n\nfloat raymarchShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    float sh = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 50; i++) {\n        vec3 p = ro + rd * t;\n        float d = p.y - fBm(p.xz);\n        sh = min(sh, 16.0 * d / t);\n        t += 0.5 * d;\n        if (d < (0.001 * t) || t > tmax)\n            break;\n    }\n    return sh;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\n    vec3 eye = vec3(0.0, 2.0, 1.0);\n    vec2 rot = 6.2831 * (vec2(0.0, 0.25) + vec2(1.0, 0.25) * (iMouse.xy - iResolution.xy * 0.5) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye + vec3(cos(iTime * 0.1) * 1.25, sin(iTime * 0.1) * 0.5 + 0.15, iTime * 0.5);\n    ro.y += 2.5;\n    vec3 ta = vec3(0.0, -0.75, 0.0);\n\n    // build camera matrix\n    vec3 cw = normalize(ta - eye);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    // compute ray direction\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));\n\n    // the powerful sun dot\n    float sunDot = clamp(dot(sunDirection, rd), 0.0, 1.0);\n\n    // terrain marching\n    float tmin = 0.1;\n    float tmax = 50.0;\n    float t = raymarchTerrain(ro, rd, tmin, tmax);\n    vec3 color = vec3(0.0);\n    if (t < tmax) {\n        vec3 tpos = ro + rd * t;\n\n        if (tpos.y < 0.15 - sin(iTime) * 0.005) {\n            tpos += -rd * (tpos.y / rd.y);\n            tpos += fBmW(tpos.xz + iTime * 0.15) - fBmW(tpos.xz + 32.0 - iTime * 0.15);\n            vec3 tnorm = getWaterNormal(tpos, t);\n            vec3 ref = reflect(rd, tnorm);\n            vec2 p = tpos.xz + vec2(ref.x + ref.z, ref.y - ref.z);\n            float surface = noiseW(p * 0.5) * noiseW(p) * noiseW(p * 4.0) * noiseW(p * 5.0) * noiseW(p * 6.0) * noiseW(p * 8.0);\n            // light from skydome\n            float sky = clamp(pow(0.5 + 0.5 * tnorm.y, 100.0), 0.0, 1.0);\n            // water AO\n            float occ = clamp(raymarchWaterAO(tpos, tnorm, 0.25), 0.0, 1.0);\n            // terrain shadows on water\n            float sha = 0.25 * clamp(raymarchShadow(tpos, sunDirection, 0.5, 50.0), 0.0, 1.0);\n            // amount of sun reflecting\n            float sun = 10.0 * sha * clamp(pow(dot(sunDirection, ref), 1000.0), 0.0, 1.0);\n\n            // water\n            color = vec3(sky * 0.01 + sun * 0.7 + 0.02 + surface, sky * 0.02 + sun * 0.6 + 0.05 + surface, sky * 0.05 + sun * 0.4 + 0.035 + surface) * occ;\n            color = mix(color, pow(vec3(sha), vec3(1.0, 0.8, 0.8)), 0.05);\n            // foam\n            float foam = fBmC(32.0 * tpos.xz) * 0.4 + 0.2;\n            color = mix(color, 0.75 * vec3(1.0), 0.5 * smoothstep(0.66 + cos(iTime) * 0.01, 1.0, foam));\n            foam = fBmC(16.0 * tpos.xz) * 0.3 + 0.2;\n            color = mix(color, 0.75 * vec3(1.0), 0.5 * smoothstep(0.43 + cos(iTime) * 0.01, 1.0, foam));\n\n        } else {\n            vec3 tnorm = getTerrainNormal(tpos, t);\n\n            // light from sun direction\n            float sun = clamp(dot(sunDirection, tnorm), 0.0, 1.0);\n            // light from skydome\n            float sky = clamp(0.5 + 0.5 * tnorm.y, 0.0, 1.0);\n            // indirect light reflected back in opposite direction of the sun\n            float ind = clamp(dot(vec3(-sunDirection.x, 0.0, -sunDirection.z), tnorm), 0.0, 1.0);\n            // raymarching AO\n            float occ = clamp(raymarchAO(tpos, tnorm, 0.1), 0.0, 1.0);\n            // raymarching penumbra shadows\n            float sha = clamp(raymarchShadow(tpos, sunDirection, 0.5, 50.0), 0.0, 1.0);\n            // light color\n            vec3 lightColor = 1.2 * sun * sunLightColor;\n            lightColor *= pow(vec3(sha), vec3(1.0, 1.2, 1.5));\n            lightColor += 0.7 * sky * skyLightColor * occ;\n            lightColor += 0.3 * ind * indLightColor * occ;\n            \n            // rock\n            color = texture(iChannel0, tpos.xz * 0.7).xyz;\n            color = mix(0.2 * vec3(0.25, 0.2, 0.15), color, 0.2); // gray with dots from noise\n            color = mix(0.15 * vec3(0.25, 0.2, 0.15), color, 2.0 * texture(iChannel0, 0.002 * vec2(tpos.x + noiseT(tpos.xz) * 80.0, tpos.y * 80.0 + noiseT(tpos.xz) * 8.0)).x); // stripes\n            color = mix(0.15 * vec3(0.15, 0.2, 0.05), color, (tpos.y + 0.0));\n            color *= 1.0 * lightColor;\n        }\n\n        // fog\n        vec3 fogColor = mix(fogColorB, fogColorR, pow(sunDot, 4.0));\n        color = mix(color, 0.8 * fogColor, 1.0 - exp(-0.0005 * t * t));\n\n    } else {\n        // sky and sun\n        float sky = clamp(0.6 * (1.0 - 0.8 * rd.y), 0.0, 1.0);\n        float diffuse = clamp(0.4 * sunDot, 0.0, 1.0);\n        color = sky * skyColor + pow(sunDot, 800.0) * sunColor + diffuse * skyLightColor;\n\n        // clouds\n        t = (cloudsHeight - ro.y) / rd.y;\n        if (t > 0.0) {\n            vec3 pos = ro + rd * t;\n            pos.z += iTime * 20.0;\n            float clouds = fBmC(0.0025 * pos.xz) * cloudsDensity + cloudsCover;\n            color = mix(color, mix(cloudsColor * 1.1, sunColor + diffuse * sunLightColor, 0.25), 0.8 * smoothstep(0.1, 0.9, clouds));\n        }\n\n        // horizon\n        color = mix(color, horizonColor, pow(1.0 - rd.y, 4.0));\n    }\n\n    // gamma correction\n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(color, gamma), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtXGDf","date":"1425640102","viewed":2361,"name":"Water Landscape","username":"jimmikaelkael","description":"My first procedural landscape: a water land.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["sea","water","rocks","lanscape"],"hasliked":0,"parentid":"","parentname":""}}