{"ver":"0.1","info":{"id":"4dsBWr","date":"1496226192","viewed":939,"name":"Raytracing (experiments)","username":"sergey_reznik","description":"Just experiments on raytracing","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","pathtracing","cornell","temporal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = pow(texture(iChannel0, uv), vec4(1.0 / 2.2f));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 snoise(vec3 v);\nvec3 uniformDirectionOnSphere(in vec3 n, in vec3 p, in float ns1, float ns2);\n\nvec3 sampleEnvironment(in vec3 d)\n{\n    return pow(texture(iChannel1, d).xyz, vec3(2.2));\n}\n\nRay castPrimaryRay(in vec2 fragCoord)\n{\n    float t = 0.0; // + 0.5 * iTime;\n    float cd = 20.0;\n    vec3 viewPoint = vec3(0.0, 10.0, 0.0);\n\tvec3 cameraPosition = viewPoint + vec3(cd * sin(t), 0.0, cd * cos(t));\n    \n    vec3 d = normalize(viewPoint - cameraPosition);\n    vec3 u = vec3(0.0, 1.0, 0.0);\n    vec3 s = cross(d, u);\n    u = cross(s, d);\n    \n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    return makeRay(cameraPosition, normalize(uv.x * s + uv.y * u + d));\n}\n\nbool transmit(float eta, vec3 i, vec3 n, out vec3 t)\n{\n    bool result = false;\n    \n\tfloat k = 1.0 - eta * eta * (1.0 - dot(n, i) * dot(n, i));\n    if (k >= 0.0)\n    {\n        t = eta * i - (eta * dot(n, i) + sqrt(k)) * n;\n        result = true;\n    }\n\t\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float iorIn = 2.44;\n    float iorOut = 1.00029;\n    \n    vec2 bufferUV = fragCoord / iResolution.xy;\n    vec3 bufferSample = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    \n    setupScene();\n    \n    vec4 ns = snoise(bufferSample.xyz + iTime + (fragCoord.x * fragCoord.y)); \n    vec3 result = vec3(0.0);\n    \n    for (int iteration = 0; iteration < MAX_ITERATIONS; ++iteration) {\n        Ray ray = castPrimaryRay(fragCoord + 0.666666 * (2.0 * ns.x - 1.0));\n\n        ns = snoise(ns.zwy + ray.d * 97973.0 + iTime);\n\n        vec3 throughput = vec3(1.0);\n\n        bool inMedium = false;\n        int depth = 0;\n        for (; depth < MAX_DEPTH; ++depth)\n        {\n            vec3 p;\n            vec3 n;\n            int shapeIndex = trace(ray, p, n);\n\n            if (shapeIndex == -1)\n            {\n                result += throughput * sampleEnvironment(ray.d);\n                break;\n            }\n\n            Shape shape = shapes[shapeIndex];\n            Material mtl = materials[shape.mtl];\n\n            float ior = inMedium ? (iorIn / iorOut) :  (iorOut / iorIn);\n            float eta = pow((ior - 1.0) / (ior + 1.0), 2.0);\n            float fresnel = eta + (1.0 - eta) * pow(1.0 + dot(n, ray.d), 5.0);\n\n            result += throughput * mtl.emissive;\n\n            if (mtl.cls == MATERIAL_METAL)\n            {\n                throughput *= mtl.color;\n                ray.d = reflect(ray.d, n);\n            }\n            else if (mtl.cls == MATERIAL_PLASTIC)\n            {\n                if (ns.z > fresnel) // diffuse\n                {\n                    ray.d = uniformDirectionOnSphere(n, p, ns.x, ns.y);\n                    throughput *= mtl.color;\n                }\n                else \n                {\n                    ray.d = reflect(ray.d, n);\n                }\n            }\n            else if (mtl.cls == MATERIAL_GLASS)\n            {\n                vec3 t;\n                bool transmitted = transmit(ior, ray.d, n, t);\n                if (transmitted && (ns.z > fresnel))\n                {\n                    ray.d = t;\n                    throughput *= mtl.color;\n                    inMedium = !inMedium;\n                }\n                else \n                {\n                    ray.d = reflect(ray.d, n);\n                }\n            }\n            else\n            {\n                throughput *= mtl.color;\n                ray.d = uniformDirectionOnSphere(n, p, ns.x, ns.y);\n            }\n\n            ray.o = p + ray.d * epsilon;\n            ns = snoise((ns.yzw + ray.d) * 97973.0 + ns.zwx * iTime);\n\n            if (dot(throughput, throughput) < epsilon)\n                break;\n        }\n    }   \n    \n    result /= float(MAX_ITERATIONS);\n    float lerp = 1.0 / (float(iFrame + 1));\n    fragColor.xyz = mix(bufferSample, result, lerp);\n}\n\nvec4 snoise(vec3 v)\n{\n\treturn texture(iChannel2, v.xy + v.z);\n}\n\nvec3 uniformDirectionOnSphere(in vec3 n, in vec3 p, in float rnd, in float xi)\n{\n    vec3 u;\n    vec3 v;\n    buildOrthonormalBasis(n, u, v);\n    \n    float phi = rnd * 2.0 * PI;\n    float cosTheta = sqrt(xi);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    return (u * cos(phi) + v * sin(phi)) * cosTheta + n * sinTheta;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float epsilon = 0.00001;\nconst float huge = 1000000.0;\n\nconst int SHAPE_SPHERE = 1;\nconst int SHAPE_BOX = 2;\n\nconst int MATERIAL_DIFFUSE = 1;\nconst int MATERIAL_METAL = 2;\nconst int MATERIAL_PLASTIC = 3;\nconst int MATERIAL_GLASS = 4;\nconst int MATERIAL_LIGHT = 100;\n\n#define MAX_DEPTH \t\t64\n#define MAX_ITERATIONS\t32\n#define NUM_MATERIALS \t7\n#define NUM_SHAPES\t\t11\n#define PI 3.1415926\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\nRay makeRay(in vec3 o, in vec3 d) { Ray r; r.o = o; r.d = d; return r; }\n\nstruct Material\n{\n    vec3 color;\n    vec3 emissive;\n    int cls;\n};\nMaterial materials[NUM_MATERIALS];\n\nMaterial makeLight(vec3 color) { Material m; m.color = vec3(1.0); m.emissive = color; m.cls = MATERIAL_LIGHT; return m; }\nMaterial makeDiffuse(vec3 color) { Material m; m.emissive = vec3(0.0); m.color = color; m.cls = MATERIAL_DIFFUSE; return m; }\nMaterial makeMetal(vec3 color) { Material m; m.emissive = vec3(0.0); m.color = color; m.cls = MATERIAL_METAL; return m; }\nMaterial makePlastic(vec3 color) { Material m; m.emissive = vec3(0.0); m.color = color; m.cls = MATERIAL_PLASTIC; return m; }\nMaterial makeGlass(vec3 color) { Material m; m.emissive = vec3(0.0); m.color = color; m.cls = MATERIAL_GLASS; return m; }\n\nstruct Shape\n{\n    vec3 c;\n    vec3 dim;\n    int cls;\n    int mtl;\n};\nShape shapes[NUM_SHAPES];\n\nShape makeSphere(in vec3 c, in float r, int m) { Shape s; s.c = c; s.dim = vec3(r); s.cls = SHAPE_SPHERE; s.mtl = m; return s; }\nShape makeBox(in vec3 c, in vec3 d, int m) { Shape s; s.c = c; s.dim = d; s.cls = SHAPE_BOX; s.mtl = m; return s; }\n   \nfloat raySphere(in Ray r, in Shape s, out vec3 p, out vec3 n)\n{\n    float t = -1.0;\n\tvec3 dv = r.o - s.c;\n    float distanceToCenterSquared = dot(dv, dv);\n    float radiusSquared = s.dim.x * s.dim.x;\n    \n    bool startedInside = distanceToCenterSquared <= radiusSquared;\n\t\n\tfloat b = dot(r.d, dv);\n    if (b <= 0.0) \n    {\n\t\tfloat d = b * b - distanceToCenterSquared + radiusSquared;\n        if (d >= 0.0) \n        {\n\t\t\td = sqrt(d);\n            float t0 = -b - d;\n            float t1 = -b + d;\n            \n            if (t0 < 0.0) t0 = huge;\n            if (t1 < 0.0) t1 = huge;\n            \n            t = min(t0, t1);\n            p = r.o + t * r.d;\n            n = normalize(startedInside ? (s.c - p) : (p - s.c));\n        }\n    }\n    \n\treturn t;\n}\n\nfloat rayBox(in Ray r, in Shape s, out vec3 p, out vec3 n)\n{\n    float resultMin = -huge;\n    float resultMax = +huge;\n\n    float txmin, txmax, tymin, tymax, tzmin, tzmax;\n    \n    vec3 boxmin = s.c - 0.5 * s.dim;\n    vec3 boxmax = s.c + 0.5 * s.dim;\n\n    float divx = 1.0 / r.d.x;\n    if (divx >= 0.0)\n    {\n        txmin = (boxmin.x - r.o.x) * divx;\n        txmax = (boxmax.x - r.o.x) * divx;\n    }\n    else\n    {\n        txmin = (boxmax.x - r.o.x) * divx;\n        txmax = (boxmin.x - r.o.x) * divx;\n    }\n\n    if (txmin > resultMin)\n        resultMin = txmin;\n    \n    if (txmax < resultMax)\n        resultMax = txmax;\n\n    float divy = 1.0 / r.d.y;\n    if (divy >= 0.0)\n    {\n        tymin = (boxmin.y - r.o.y) * divy;\n        tymax = (boxmax.y - r.o.y) * divy;\n    }\n    else\n    {\n        tymin = (boxmax.y - r.o.y) * divy;\n        tymax = (boxmin.y - r.o.y) * divy;\n    }\n    \n    if ((resultMin > tymax) || (tymin > resultMax))\n        return -1.0;\n\n    if (tymin > resultMin)\n        resultMin = tymin;\n    \n    if (tymax < resultMax)\n        resultMax = tymax;\n\n    float divz = 1.0 / r.d.z;\n    if (divz >= 0.0)\n    {\n        tzmin = (boxmin.z - r.o.z) * divz;\n        tzmax = (boxmax.z - r.o.z) * divz;\n    }\n    else\n    {\n        tzmin = (boxmax.z - r.o.z) * divz;\n        tzmax = (boxmin.z - r.o.z) * divz;\n    }\n\n    if ((resultMin > tzmax) || (tzmin > resultMax))\n        return -1.0;\n    \n    if (tzmin > resultMin)\n        resultMin = tzmin;\n    \n    if (tzmax < resultMax)\n        resultMax = tzmax;\n    \n    float t = min(resultMin, resultMax);\n    p = r.o + r.d * t;\n\t\n    n = vec3(0.0);\n    if (abs(p.x - boxmin.x) < epsilon) n = vec3(-1.0, 0.0, 0.0);\n    if (abs(p.y - boxmin.y) < epsilon) n = vec3(0.0, -1.0, 0.0);\n    if (abs(p.z - boxmin.z) < epsilon) n = vec3(0.0, 0.0, -1.0);\n    if (abs(p.x - boxmax.x) < epsilon) n = vec3(+1.0, 0.0, 0.0);\n    if (abs(p.y - boxmax.y) < epsilon) n = vec3(0.0, +1.0, 0.0);\n    if (abs(p.z - boxmax.z) < epsilon) n = vec3(0.0, 0.0, +1.0);\n    return t;\n}\n\nfloat rayShape(in Ray r, in Shape s, out vec3 p, out vec3 n)\n{\n    if (s.cls == SHAPE_SPHERE)\n    {\n        return raySphere(r, s, p, n);\n    }\n    else if (s.cls == SHAPE_BOX)\n    {\n        return rayBox(r, s, p, n);\n    }\n}\n\nvoid buildOrthonormalBasis(in vec3 n, out vec3 u, out vec3 v)\n{\n\tfloat sgn = (n.z < 0.0) ? -1.0 : 1.0;\n    float a = -1.0 / (sgn + n.z);\n   \tfloat b = n.x * n.y * a;\n    u = vec3(1.0 + sgn * n.x * n.x * a, sgn * b, -sgn * n.x);\n    v = vec3(b, sgn + n.y * n.y * a, -n.y);\n}\n\nvoid setupScene()\n{\n    materials[0] = makeLight(vec3(10.0, 11.0, 12.0));\n    \n    materials[1] = makeDiffuse(vec3(1.0, 1.0, 1.0));\n    materials[2] = makeDiffuse(vec3(1.0, 0.5, 0.0));\n    materials[3] = makeDiffuse(vec3(0.0, 0.5, 1.0));\n    \n    materials[4] = makeMetal(vec3(0.8, 0.3, 0.16));\n    materials[5] = makePlastic(vec3(0.1, 0.7, 0.25));\n    materials[6] = makeGlass(vec3(1.0, 1.0, 1.0));\n    \n    // shapes[0] = makeSphere(vec3(0.0, 10.0, 0.0), 10.0, 6);\n    \n    //*\n    shapes[0] = makeSphere(vec3(-6.0, 3.0, 6.0), 3.0, 4);\n    shapes[1] = makeSphere(vec3(+5.0, 5.0, 2.0), 5.0, 5);\n    shapes[2] = makeSphere(vec3(-10.0, 15.0, 0.0), 5.0, 6);\n    \n    shapes[3] = makeBox(vec3(0.0, 0.0, 0.0), vec3(30.05, 0.2, 20.05), 1);\n    shapes[4] = makeBox(vec3(0.0, 20.05, 0.0), vec3(30.05, 0.2, 20.05), 1);\n    shapes[5] = makeBox(vec3(-15.0, 10.0, 0.0), vec3(0.1, 20.55, 20.55), 2);\n    shapes[6] = makeBox(vec3(+15.0, 10.0, 0.0), vec3(0.1, 20.55, 20.55), 3);\n    shapes[7] = makeBox(vec3(0.0, 10.0, -10.0), vec3(30.05, 20.05, 0.1), 1);\n    \n    shapes[8] = makeBox(vec3(0.0, 15.0, -9.0), vec3(19.99, 5.0, 1.0), 4);\n    \n    shapes[9] = makeBox(vec3(0.0, 20.0, 0.0), vec3(0.1, 0.2, 10.0), 0);\n    shapes[10] = makeBox(vec3(0.0, 20.0, 0.0), vec3(10.0, 0.2, 0.1), 0);\n\t// */\n}\n\nint trace(in Ray ray, out vec3 p, out vec3 n)\n{\n    float minT = huge;\n    int shapeIndex = -1;\n    for (int i = 0; i < NUM_SHAPES; ++i)\n    {\n       \tvec3 localP;\n        vec3 localN;\n        float t = rayShape(ray, shapes[i], localP, localN);\n        if ((t > 0.0) && (t < minT))\n        {\n            p = localP;\n            n = localN;\n            minT = t;\n            shapeIndex = i;\n        }\n    }\n    return shapeIndex;\n}\n","name":"Common","description":"","type":"common"}]}