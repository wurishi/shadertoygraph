{"ver":"0.1","info":{"id":"3sjBDt","date":"1591188514","viewed":120,"name":"Vortex music clip","username":"hellgunman","description":"Sound visualizer\nMusic by Nexc0re (me)\n\n(Sometimes the music does not load. If nothing moves, realod the page)","likes":3,"published":1,"flags":96,"usePreview":0,"tags":["sound","music","visualizer","soundcloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nvec3 radius_color(float radius, vec3 background, float glow_intensity)\n{\n    if (radius > 1.0)\n    {\n        float glow = clamp(pow(radius - 1.0, glow_intensity), 0.0, 1.0);\n        return mix(vec3(1.0), background, glow);\n    }\n    \n    if (radius > 0.9)\n        return vec3(1.0);\n    \n    \n    vec3 inside = vec3(0.0);\n    vec3 outside1 = vec3(119, 210, 217) / 255.0;\n    vec3 outside2 = vec3(137, 245, 255) / 255.0;\n    \n    vec3 outside = mix(outside1, outside2, sign(sin(pow(radius, 0.5) * 30.0 + iTime * 10.0)) * 0.5 + 0.5);\n    \n    vec3 color = mix(inside, outside, pow(radius / 0.8, 3.0));\n    \n    \n    return color;\n}\n\nvec3 background_spike(float freq, float average, vec3 color, float contrast, float thresold)\n{\n    float backgroundIntensity = texture(iChannel1, vec2(freq, average)).x;\n    backgroundIntensity = pow(backgroundIntensity, contrast) * contrast - thresold;\n    backgroundIntensity = clamp(backgroundIntensity, 0.0, 1.0);\n    \n    return color * backgroundIntensity;\n}\n\nvec3 ring(vec2 uv, float y, float size)\n{\n    vec2 center = uv - vec2(0.5, y);\n    float l = sqrt(center.x * center.x + center.y * center.y * mix(2.0, 15.0, uv.y));\n    return vec3(1.0) * pow(clamp(1.0 - abs(l- size) * 5.0, 0.0, 1.0), 40.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float intensity = 2.0 * texture(iChannel1, vec2(0.0, 1.0)).x;\n    \n\tfloat curve = texture(iChannel1, vec2(uv.x * 0.1, 1.0)).x;\n\n    vec3 background = (1.0 - intensity) * vec3(1.0, 0.0, 0.5) * pow(floor((uv.y + sin(uv.x * 30.0 + iTime * 0.3 * floor(((1.0-uv.y) + sin(iTime + uv.y) * 0.1) * 20.0)) * 0.05) * 10.0) / 10.0, 5.0);\n    \n    float coef = sign(uv.y - curve) * 0.5 + 0.5;\n    \n    vec2 proj;\n    if (iResolution.x > iResolution.y)\n    {\n        proj = normalize(vec2(iResolution.x, iResolution.y));\n    }\n    else\n    {\n        proj = normalize(vec2(iResolution.y, iResolution.x));\n    }\n    \n    vec2 fromCenter = (uv.xy - vec2(0.5, 0.5)) * proj;\n    float distFromCenter = length(fromCenter);\n    \n    float angle = atan(fromCenter.x, fromCenter.y);\n    float offset = abs(angle / M_PI);\n    offset += pow(length(fromCenter), intensity*2.0);\n    //offset = mod(offset * (intensity), 1.0);\n    \n    float fft = texture(iChannel1, vec2(offset, 0.01)).x;\n    \n    float radius = min(proj.x, proj.y) * (0.1 + fft * 0.3) + intensity * 0.1;\n    coef = sign(distFromCenter - radius) * 0.5 + 0.5;\n    \n    float curveFreq = 0.2 + (0.25*uv.x - 0.2) * mix(1.0, cos(uv.y + 0.5), 0.8);\n    float curveFreqFlipX = 0.2 + (0.25*(1.0-uv.x) - 0.2) * mix(1.0, cos(uv.y + 0.5), 0.8);\n    \n    background += background_spike(curveFreq, 0.0, vec3(1.0, 0.0, 0.8), 10.0, 0.2);\n    background += background_spike(curveFreqFlipX, 0.0, vec3(1.0, 0.0, 0.8), 10.0, 0.2);\n    background += background_spike(curveFreq, 0.02, vec3(1.0, 0.0, 0.5) * 0.8, 7.0, 0.2);\n    background += background_spike(curveFreqFlipX, 0.02, vec3(1.0, 0.0, 0.5) * 0.8, 7.0, 0.2);\n    \n    \n    float trebleCoef = texture(iChannel1, vec2(0.05 + 0.1 * abs(uv.y - 0.5) / sin(abs(fromCenter.x * 2.0) * M_PI), 0.0)).x;\n    \n    vec3 lineColor = mix(vec3(1.0), vec3(1.0, 0.4, 0.8), pow(abs(fromCenter.x) * 2.0, 1.0));\n    trebleCoef = clamp(pow(trebleCoef, 3.0) * 5.0 - 1.5, 0.0, 1.0);\n    trebleCoef *= clamp(distFromCenter * 10.0, 0.0, 1.0);\n    trebleCoef *= clamp(sin(offset * M_PI), 0.0, 1.0);\n    \n    float glowIntensity = pow(intensity, 4.0);\n    vec3 color = radius_color(distFromCenter / radius, background, glowIntensity);\n    color += lineColor * trebleCoef;\n    \n    \n    \n    if (distFromCenter > radius * 1.0 && distFromCenter < radius * 2.0)\n    {\n        float outline = ((distFromCenter / radius) - 1.0);\n        \n        float radialScale = mix(10.0, 1.0, intensity);\n        vec4 random = texture(iChannel0, vec2(outline * 0.05 + iTime * 0.1, offset * radialScale));\n        float opacity = pow(random.x, 10.0 * (1.0-pow(1.0-outline, 3.0)));\n        \n        vec3 dotColor = mix(vec3(1.0, 0.0, 0.7), vec3(1.0), pow(outline, 0.25));\n        color += dotColor * max(0.0, opacity) * (1.0 - outline) * intensity;\n    }\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4lS3Dc","filepath":"https://soundcloud.com/nexc0re/stasis","previewfilepath":"https://soundcloud.com/nexc0re/stasis","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FFT_WIDTH 512\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;    \n    \n    float size = uv.y / float(FFT_WIDTH);\n    \n    float fft = 0.0;\n    \n    for(int i = 0; i < FFT_WIDTH; ++i)\n    {        \n        float freq = uv.x + size * float(i);\n        if (freq > 1.0)\n            freq -= 1.0;\n        \n        fft += texture(iChannel0, vec2(freq, 0)).x;\n    }\n    \n    fft /= float(FFT_WIDTH);\n    \n    float previous = texture(iChannel1, vec2(uv.x, uv.y)).x;\n    \n    \n    \n    \n    float average = mix(fft, previous, 1.0 - pow(abs(previous - fft), 2.0));\n    \n    fragColor = vec4(fft, 0.0, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}