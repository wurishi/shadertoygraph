{"ver":"0.1","info":{"id":"sdfyzX","date":"1642454088","viewed":116,"name":"Hexercise","username":"DukeOfStraylight","description":"Just a rough reproduction of an effect seen elsewhere.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["hex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\nstruct HexCoord {\n  // just Cartesian coordinates centered at the center of the hex;\n  // they also work as barycentric, third barycentric coord is just 0.-(gv.x+gv.y)\n  vec2 gv;\n  // axial coordinates a la the timeless https://www.redblobgames.com/grids/hexagons/\n  // (my first intuition was to try on my own and I of course came up with offset\n  // coordinates, and I actually got pretty far with them, but OH GOD THE PAIN)\n  // id.x grows right, id.y grows up and to the left\n  vec2 id;\n};\n\n// https://www.redblobgames.com/grids/hexagons/ again\nvec2 hexCenter(vec2 id) {\n    return vec2(3./2. * id.x,\n                sqrt(3.)/2. * id.x + sqrt(3.) * id.y);\n}\n\n// https://observablehq.com/@jrus/hexround\nvec2 axialRound(vec2 uv) {\n    float xgrid = round(uv.x);\n    float ygrid = round(uv.y);\n    uv.x -= xgrid;\n    uv.y -= ygrid; // remainder\n    if (abs(uv.x) >= abs(uv.y)) {\n        return vec2(xgrid + round(uv.x + 0.5*uv.y), ygrid);\n    } else {\n        return vec2(xgrid, ygrid + round(uv.y + 0.5*uv.x));\n    }\n}\n\n// https://www.redblobgames.com/grids/hexagons/ again\nHexCoord hexCoords(vec2 uv) {\n  float q = 2./3. * uv.x;\n  float r = -1./3. * uv.x + sqrt(3.)/3. * uv.y;\n  vec2 gv = vec2(q, r);\n  vec2 id = axialRound(gv);\n  return HexCoord(gv-id, id);\n}\n\n// https://en.wikipedia.org/wiki/Centered_hexagonal_number\n// or https://oeis.org/A003215 for nerds\nfloat hexagonalNumber(float n) {\n    return 3.*n*n - 3.*n + 1.;\n}\n\n// just your ordinary Manhattan distance in cube coords\nfloat hexRadius(vec2 id) {\n    float s = 0. - id.x - id.y;\n    return max(abs(id.x), max(abs(id.y), abs(s)));\n}\n\n\nconst float pi = 3.14159;\nconst float tau = 2. * pi;\n\n// good morning, you look like you want an extreme, uncontrollable pile of\n// case analysis\nfloat hexAngle(vec2 id) {\n    float radius = hexRadius(id);\n    // for clarity, introducing coords that properly match\n    // https://www.redblobgames.com/grids/hexagons/\n    float q = id.x;\n    float s = id.y;\n    float r = 0. - id.x - id.y;\n    if (s == 0.) {\n        return q < 0. ? 0. : 3.*radius;\n    } else if (s < 0.) {\n        return 3.*radius + \n          (r <= 0. ? - s : q > 0. ? radius + r : 3. * radius + s);\n    } else {\n        return q <= 0. ? radius - r : 2.*radius + q;\n    }\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat hexTime(vec2 id) {\n    if (id.x == 0. && id.y == 0.) {\n        return 0.;\n    }\n    return hexagonalNumber(hexRadius(id)) + hexAngle(id);\n}\n\nvec3 tri(vec2 p, float t, vec2 id, vec2 n1, vec2 n2) {\n    vec2 c = hexCenter(id);\n    vec2 n1id = id + n1;\n    vec2 n2id = id + n2;\n    vec2 n1c = hexCenter(n1id);\n    vec2 n2c = hexCenter(n2id);\n    vec2 triCenter = (c + n1c + n2c) / 3.;\n    // muggly hack: The original really runs in order of creating triangles,\n    // and I only realised after implementing the rest of this to run in order\n    // of creating points, so let's just kinda reach ahead here by using the\n    // median instead of the maximum of the hexTimes as the showTime\n    float ht = hexTime(id);\n    float ht1 = hexTime(n1id);\n    float ht2 = hexTime(n2id);\n    float showTime =\n      ht > ht1 && ht > ht2 ? max(ht1, ht2) :\n      ht1 > ht && ht1 > ht2 ? max(ht, ht2) :\n      max(ht1, ht);\n    if (t < showTime) {\n        return vec3(0);\n    }\n    c =   mix(c, triCenter,   0.1);\n    n1c = mix(n1c, triCenter, 0.1);\n    n2c = mix(n2c, triCenter, 0.1);\n    float d = min(sdSegment(p, c, n1c),\n               min(sdSegment(p, c, n2c), sdSegment(p, n1c, n2c)));\n    float w = dFdy(p.y);\n    return smoothstep(w, 0.0, d) * hueShift(vec3(1, 1, 0), length(triCenter));\n}\n\nvec3 triAllNeighbors(vec2 p, float t, vec2 id) {\n    return\n     tri(p, t, id, vec2( 1, 0), vec2( 1,-1)) +\n     tri(p, t, id, vec2( 1,-1), vec2( 0,-1)) +\n     tri(p, t, id, vec2( 0,-1), vec2(-1, 0)) +\n     tri(p, t, id, vec2(-1, 0), vec2(-1, 1)) +\n     tri(p, t, id, vec2(-1, 1), vec2( 0, 1)) +\n     tri(p, t, id, vec2( 0, 1), vec2( 1, 0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    uv *= iTime + 12.;\n\n    HexCoord hexCoord = hexCoords(uv);\n    vec2 id = hexCoord.id;\n    vec2 hc = hexCenter(hexCoord.id);\n    vec3 col = vec3(0);\n    \n    col = triAllNeighbors(uv, iTime + iTime*iTime*0.25, id);\n    float w = dFdy(uv.y)*3.;\n    col += vec3(smoothstep(w, 0.8*w, distance(uv, hexCenter(id))));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}