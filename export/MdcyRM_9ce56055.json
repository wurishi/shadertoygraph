{"ver":"0.1","info":{"id":"MdcyRM","date":"1518147166","viewed":96,"name":"Cool Paw Metaballs","username":"kingish","description":"Paw looking metaballs.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float EPSILON = 0.01;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 24.0;\nint MAX_MARCHING_STEPS = 24;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translationMatrix(vec3 translation)\n{\n  return mat4(1,0,0,0,\n              0,1,0,0,\n              0,0,1,0,\n              translation.x, translation.y, translation.z, 1);\n}\n\nstruct SDFData {\n    float SDV;\n    float id;\n};\n    \nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nfloat SDFSphere(vec3 p) {\n    return length(p)-1.0;\n}\n\nSDFData SDFScene(vec3 p) {\n    float rotations[5] = float[](0.0,72.0,144.0,216.0,288.0);\n    \n    vec3 center = vec3(0,1.5,0);\n    \n    center = vec3(rotationMatrix(vec3(1,0,0), -iTime * 90.0) * vec4(center,1));\n    \n    SDFData best = SDFData(1000000000.0, 0.0);\n    \n    for(int i = 0; i < 5; ++i) {\n    \tmat4 trans = translationMatrix(vec3(0,-2,0)) * translationMatrix(center) * translationMatrix(vec3(0,2.0,0)) * \n            rotationMatrix(vec3(1,0,0), iTime * 40.0 + rotations[i]) * \n            translationMatrix(vec3(0,2,0));\n            ;\n        vec3 q = vec3(inverse(trans)*vec4(p,1));\n        float scale = 0.54;\n    \tfloat v = scale * SDFSphere(q/scale);\n        \n        if(v < best.SDV) {\n        \tbest = SDFData(v, 1.0);\n        }\n    }\n    \n    float scale = 1.6;\n    float v = scale * (SDFSphere(p/scale));\n    \n    best.SDV = smin(v, best.SDV, 1.1);\n        \n\n\treturn best;\n}\n\nSDFData raymarch(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        SDFData data = SDFScene(eye + depth * marchingDirection);\n        float dist = data.SDV;\n        if (dist < EPSILON) {\n            return SDFData(depth, data.id);\n        }\n        depth += dist;\n        if (depth >= end) {\n            return SDFData(end, 0.0f);\n        }\n    }\n    return SDFData(end, 0.0f);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n  vec3 f = normalize(center - eye);\n  vec3 s = normalize(cross(f, up));\n  vec3 u = cross(s, f);\n  return mat4(vec4(s, 0.0), vec4(u, 0.0), vec4(-f, 0.0), vec4(0.0, 0.0, 0.0, 1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 dir = rayDirection(70.0, vec2(iResolution.x,iResolution.y), vec2(gl_FragCoord.x, gl_FragCoord.y));\n    vec3 eye = vec3(15.0, 0.0, 0.0);\n\n    mat4 viewToWorld = viewMatrix(eye, vec3(0, 0, 0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    SDFData data = raymarch(eye, worldDir, MIN_DIST, MAX_DIST);\n    float dist = data.SDV;\n    \n    if (dist > MAX_DIST - EPSILON) {\n    \tfragColor = vec4(255,255,255,255) / 255.0;\n        return;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    fragColor = vec4(0,0,0,255.0)/255.0;\n}","name":"Image","description":"","type":"image"}]}