{"ver":"0.1","info":{"id":"wsjGDw","date":"1559826565","viewed":146,"name":"Sketch 002","username":"Rackdoll","description":"Carving knowledge & testing learnings.\nThis study is about structs, materials, lighting and shadows.\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","shadows","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 256;\nconst int MAX_SOFT_SHADOW_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.0001;\n\n#define ZERO (min(iFrame,0))\n\n//STRUCTS.\nstruct Material\n{\n\tint id;\n};\n\n//CAMERA.\nstruct Camera\n{\n \tvec3 pos;\n    vec3 look;\n    vec3 dir;\n    vec3 up;\n    vec3 right;\n};\n    \n//OBJECTS.\nstruct Object\n{\n    vec3 pos;\n    Material material;\n};\n    \nstruct RMResult\n{\n\tvec3 pos;\n    vec3 normal;\n    vec3 color;\n    vec3 RO;\n    vec3 RD;\n    float depth;\n};\n\n\n\n//From: https://www.shadertoy.com/view/lllSR7\nvoid materialCheck( float newDist, inout float minDist, int newMaterial, inout int material )\n{\n    if( newDist < minDist )\n    {\n    \tminDist = newDist;\n        material = newMaterial;\n    }\n    \n}\n\n\nfloat map( vec3 p, out int hitMaterial )\n{\n  \tfloat MAX_D = MAX_DIST;\n    hitMaterial = 0;\n    \n    //objects definitions.\n    Object o_1;\n    o_1.pos      = vec3( 0, 0., 0.5);\n    o_1.material.id = 1;\n    \n    Object o_2;\n    o_2.pos      = vec3(0, 0., 0.5);\n    o_2.material.id = 0;\n    \n    Object o_3;\n    o_3.pos      = vec3(0, 0., 0.5);\n    o_3.material.id = 2;\n    \n    Object o_4;\n    o_4.pos      = vec3(0, 0., 0.5);\n    o_4.material.id = 3;\n    \n    \n    Object o_5;\n    o_5.pos = vec3(0., 0., 2.);\n    o_5.material.id = 4;\n    \n     //rendering.\n    vec3 p_1 = rotateXYZ((vec3(p) + o_1.pos), iTime, iTime * .75, 0.);\n    float scene =  SDFTorus( p_1, vec2(0.475, 0.075));\n    materialCheck( scene, MAX_D, o_1.material.id, hitMaterial);\n    \n    vec3 p_2 = rotateXYZ((vec3(p_1) ), -iTime*.75, -iTime * .25, 0.);\n    scene = min(scene, SDFTorus(p_2, vec2(0.625, 0.075)));\n    materialCheck( scene, MAX_D, o_2.material.id, hitMaterial);\n    \n    vec3 p_3 = rotateXYZ((vec3(p_2)), iTime*.95, -iTime * .55, 0.);\n    scene = min(scene, SDFTorus(p_3, vec2(0.32, 0.075)));\n    materialCheck( scene, MAX_D, o_3.material.id, hitMaterial);\n    \n    vec3 p_4 = rotateXYZ((vec3(p_3)), iTime*.95, -iTime * .55, 0.);\n    scene = min(scene, SDFTorus(p_4, vec2(0.18, 0.075)));\n    materialCheck( scene, MAX_D, o_4.material.id, hitMaterial);\n\n\n     \n    vec3 p_0 = vec3(p) + o_5.pos;\n    scene = min(scene,SDFPlane( p_0, normalize( vec3(0, 0, -1.)),2.1));\n    materialCheck( scene, MAX_D, o_5.material.id, hitMaterial );\n                           \n    \n\treturn scene;    \n}\n\nfloat map( vec3 p)\n{\n\tint tempHitMaterial;\n    return map( p, tempHitMaterial );\n}\n\n\n\n//normals.\nvec3 normal( vec3 p )\n{\n     vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( p + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( p + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( p + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( p + e.xxx ) );\n}\n\nvec3 ShadeMaterial( vec3 pos, vec3 normal, int material_id, vec3 RO, vec3 RD )\n{\n    vec3 c = vec3(0.0);\n \tif( material_id == 0 ) c = vec3(1., 0., 0.);\n    else if( material_id == 1 ) c = vec3(0., 1., 0.);\n    else if( material_id == 2 ) c = vec3(0., 0., 1.);\n    else if( material_id == 3 ) c = vec3(1., 1., 0.);\n    else if( material_id == 4 ) c = vec3(1., 1., 1.);\n    return c;  \n}\n\n\n//-----------------------------------------------------------------------\n//\t\t\t\tBACKGROUND SHADING\n//----------------------------------------------------------------------\nvec4 ShadeBackground( vec3 pos, vec3 normal, vec3 RO, vec3 RD, vec2 uv )\n{\n    \n    vec2 uuvv = vec2(uv) * .5 + .5;\n    vec2 cell = vec2( mod(uuvv.x,.1), \n                      mod(uuvv.y,.1));\n    \n    vec2 cellMiddle = vec2( cell.x - .05,\n                            cell.y - .05);\n    \n    float len  =  length( cellMiddle - pos.xy );\n    vec2 delta = vec2(  cellMiddle  -pos.xy );\n    float angle = atan( delta.y, delta.x );\n    \n    vec4 finalColor = vec4(1., 0.4,0.,1.);\n    if( mod(uuvv.x, .2) < .1 && \n        mod(uuvv.y, .2) < .1) \n        finalColor = vec4(cell.x * 10., cell.y * 10.,0.4,1.);\n    \n \treturn finalColor * vec4( vec3(1.-sqrt(len)*2.), 1.);   \n}\n\n\n//---------------------------------------------------------------------------\n// \t\t\t\tRAY MARCH RESULT\n//---------------------------------------------------------------------------\nRMResult RM( vec3 RO, vec3 RD )\n{\n    float result = MAX_DIST;\n    float depth = 0.0;\n    vec3 ray = RO;\n    int hitMaterial = 0;\n \tfor( int i= ZERO; i < MAX_MARCHING_STEPS; ++i )\n    {\n        float small = 0.0005 * depth;\n    \tray = RO + ( depth * RD);\n        float scene = map( ray, hitMaterial ); \n        \n        \n        if(scene < small || scene < (EPSILON*result) )\n        {\n            \n         \tresult = depth;   \n            break;\n        }\n            \n        \n        depth += scene;\n        if( depth >= MAX_DIST )\n        {\n        \tresult = MAX_DIST;    \n            break;\n        } \n    }\n    \n    \n    //create a result obj.\n    RMResult r;\n    r.pos    = ray;\n    r.normal = normal(ray);\n    r.color  = ShadeMaterial( ray, r.normal, hitMaterial, RO, RD );\n    r.RO     = RO;\n    r.RD     = RD;\n    r.depth  = result;\n    return r;\n}\n\n//--------------------------------------------------------------------------\n// \t\t\t\t\t\tSOFT SHADOWS\n// \t\t\t\thttps://www.shadertoy.com/view/lsKcDD\n//--------------------------------------------------------------------------\nfloat calcSoftShadow( vec3 ro, vec3 rd, float tmin, float tmax)\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    float ph = 1e10; \n    \n    for( int i=ZERO; i<MAX_SOFT_SHADOW_STEPS; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 32.0*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        if(res < 0.0001 || t>tmax ) break; \n    }\n  \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 CalcLight(vec3 pos, vec3 normal, vec3 material_color, vec3 RO, vec3 RD, int hasSpec )\n{\n   // -> lighting\n\tvec3 light = normalize( vec3(1.5, 0.0, -1.) );\n    vec3 light_color  = vec3( .8,.5,0.3);\n    float intensity   = .95;\n    float lightRadius = 1.5;\n    float lightCutOff = .001;\n    vec3 N     = normalize(normal);\n    vec3 L     = normalize( vec3( light - pos ) );\n    \n    //shadow\n    float shadow  = calcSoftShadow( pos, light, 0.1, 5.0); \n\n    //diffuse\n    float diffuseWeight = clamp( dot( N, light), 0.0, 1.0);\n    \n    //specular\n    vec3 halfVec = normalize(light-RD );\n    float specularWeight = pow( max ( dot( reflect( -L, N), halfVec ), 0.0 ), 10.0 );\n    \n    \n    //attenuation\n    float len = length( light - pos );\n\n    float d = max( len - lightRadius, 0.0 );\n    float denom  = d/lightRadius + 1.0;\n    float attenuationWeight = 1.0 / (denom*denom);\n    attenuationWeight       = ( attenuationWeight -lightCutOff) / (1.0-lightCutOff);\n    attenuationWeight       = max( attenuationWeight, 0.);\n    \n    \n    \n    vec3 ambient  = vec3( 0.0 );\n\tvec3 diffuse  = (light_color * material_color) * diffuseWeight  * intensity;\n    vec3 specular = light_color * specularWeight; \n\n    if(hasSpec==0)\n        return (ambient + diffuse)  * attenuationWeight * shadow; \n    \n    return  (ambient + diffuse + specular)  * attenuationWeight * shadow;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv      = fragCoord.xy/iResolution.xy - 0.5;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x = aspect * uv.x;\n    \n \n    //camera setup.\n    vec3 UP     = vec3(0, 1.0, 0);\n    vec3 RIGHT  = vec3(1.0, 0, 0); \n    \n    Camera cam;\n    cam.pos  = vec3(-0.3, -.5, -3.);\n    cam.look = vec3(0., 0., 0.1);\n    cam.dir  = normalize(cam.look-cam.pos);\n    cam.right= normalize(cross(UP, cam.dir));\n    cam.up   = normalize(cross(cam.dir, cam.right));\n    \n\t\n    //ray direction / origin  \n    vec3 RO = cam.pos;\n    vec3 RD = normalize( cam.dir + uv.x * cam.right + uv.y * cam.up);\n\n    //march.\n    RMResult result = RM( RO, RD );\n    vec3 material   = result.color;\n    if(material == vec3(1.)) material = ShadeBackground(vec3(0), vec3(0), RO, RD, uv ).rgb;\n    \n    material = CalcLight( result.pos, result.normal, material, RO, RD, (result.color == vec3(1.)) ? 0 : 1 );\n    \n    //final color.\n\tfragColor = vec4(material, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Primitives\nfloat SDFSphere( vec3 p, float s )\n{\n\treturn length(p) - s;    \n}\nfloat SDFTorus( vec3 p, vec2 s)\n{\n    vec2 q = vec2(length(p.xy)-s.x,p.z);\n    return (length(q)-s.y);\n}\nfloat SDFBox( vec3 p, float s )\n{\n    return length( max( abs(p) - s, 0.0 ) ); \n}\n\nfloat SDFPlane(vec3 p, vec3 n, float distanceFromOrigin) \n{\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n\n\n\n//ROTATIONS\nvec3 rotateX( vec3 p, float a )\n{\n \treturn mat3( 1.0, 0.0, 0.0,\n                     0.0, cos(a), -sin(a),\n                     0.0, sin(a), cos(a) ) * p;\n}\nvec3 rotateY( vec3 p, float a )\n{\n \treturn mat3( cos(a), 0.0, sin(a),\n                    0.0, 1.0,    0.0,\n                -sin(a), 0.0,  cos(a) ) * p;\n}\nvec3 rotateZ( vec3 p, float a )\n{\n \treturn mat3( cos(a), -sin(a), 0.0,\n                 sin(a), cos(a),  0.0,\n                        0.0, 0.0, 1.0 ) * p;\n}\nvec3 rotateXYZ( vec3 p, float aX, float aY, float aZ )\n{\n   \tmat3 rotX = mat3( 1.0, 0.0, 0.0,\n                      0.0, cos(aX), -sin(aX),\n                      0.0, sin(aX),  cos(aX));\n    \n    mat3 rotY = mat3( cos(aY), 0.0, sin(aY),\n                         0.0, 1.0,    0.0,\n                     -sin(aY), 0.0,  cos(aY));\n    \n    mat3 rotZ = mat3( cos(aZ), -sin(aZ), 0.0,\n                 \t  sin(aZ), cos(aZ),  0.0,\n                         0.0,    0.0, 1.0 );\n    \n    return ((rotX * rotY * rotZ) * p);\n\n}\n\n\n\n\n","name":"Common","description":"","type":"common"}]}