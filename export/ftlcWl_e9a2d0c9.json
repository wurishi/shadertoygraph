{"ver":"0.1","info":{"id":"ftlcWl","date":"1648914108","viewed":68,"name":" 2D Boze","username":"kaiware007","description":"2D Boze","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","boze"],"hasliked":0,"parentid":"3dKfRw","parentname":"Simple Boze"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 200\n#define MAX_DIST 100.\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n#define M_PI 3.1415926\n#define RAD90 (M_PI * 0.5)\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    int count;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \t0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \t0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \t0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \t0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \t0, true))\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Basic Distance function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nfloat opU( float d1, float d2 ) {  return min(d1,d2); }\n\nsurface opS( surface d1, surface d2 )\n{\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    return surface(d, albedo, d1.count, true);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opU(opU(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Distance Function 2D\nfloat sdRoundBox(vec2 p, vec2 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nfloat sdCapsule(vec2 p, vec2 a, vec2 b, float r)\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec2 p, vec2 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nsurface opColorOvreWrite(surface a, surface b)\n{\n    if(b.dist > 0.0){\n        return a;\n    }else{\n        a.albedo = b.albedo;\n        return a;\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function 2D\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdEar(vec2 p)\n{\n    p = rot(RAD90+0.25) * p;\n    return sdArc(p + vec2(0.05, 0.175), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n    //return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE_2D 0.045\n\nvec2 opBendXY(vec2 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec2(m*p.xy);\n}\n\nfloat sdMouse(vec2 p, float ms)\n{\n    vec2 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    return sdEllipsoid(q, vec2(0.035, 0.01 * ms));\n}\n\nfloat sdCheep(vec2 p)\n{    \n    const float x = 0.085;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n        \n    float d = sdCapsule(opBendXY(p + vec2(x, -0.02), rb1), vec2(-0.005,0.0), vec2(0.005, 0.), r);\n    float d1 = sdCapsule(opBendXY(p + vec2(x+0.01, -0.02), 200.0), vec2(-0.0026,0.0), vec2(0.0026, 0.), r);\n    float d2 = sdCapsule(opBendXY(p + vec2(x+0.019, -0.025), -rb1), vec2(-0.01,0.0), vec2(0.0045, 0.), r);\n    \n    return opU(opU(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec2 p)\n{\n    const float x = 0.05;\n    return sdRoundBox(p + vec2(EYE_SPACE_2D, -0.14), vec2(0.015,0.004), 0.0);\n}\n\nsurface sdBoze(vec2 p, vec2 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, sc.y);\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec2(0,0.08), vec2(0, 0.11), 0.125);\n    \n    float d1 = sdCapsule(p, vec2(-0.1, 0.0075), vec2(0.1, 0.0075), 0.06); \n    \n    d = smin(d, d1, 0.025);\n    \n    vec2 mxp = vec2(-abs(p.x), p.y);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);    \n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec2(-EYE_SPACE_2D, 0.07), vec2(-EYE_SPACE_2D, 0.09), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    result = opColorOvreWrite(head, mouse);\n    \n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    result = opColorOvreWrite(result, cheep);\n    \n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    result = opColorOvreWrite(result, eye);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze 2D\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    float ms = sin(iTime*2.) * 0.5 + 0.5;\n    surface mat = sdBoze(p, vec2(3), ms);\n    \n    // outline\n    mat.albedo.xyz *= abs(mat.dist) <= 0.002 ? 0. : 1.;\n    \n    vec3 col = (mat.dist <= 0.0) ? mat.albedo.xyz : vec3(0.3);\n    \n    // Output to screen\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}