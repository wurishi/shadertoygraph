{"ver":"0.1","info":{"id":"43Bfzz","date":"1729118889","viewed":25,"name":"My First Value Noise Test","username":"8InfinityTaco8","description":"This is just a test.  I'm learning how to generate noise and manipulate it","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","valuenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash function to generate pseudo-random values\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Interpolates between four points using bilinear interpolation\nfloat interpolateNoise(vec2 st) {\n    vec2 i_st = floor(st);   // Integer grid coordinates\n    vec2 f_st = fract(st);   // Fractional part of the coordinates (for interpolation)\n\n    //these four lines call the random() function to get the pseudo random values for the four courners of te gric cell surrounding st\n    float v00 = random(i_st); // bottom left\n    float v10 = random(i_st + vec2(1.0, 0.0)); //bottom right corner\n    float v01 = random(i_st + vec2(0.0, 1.0)); // top left corner\n    float v11 = random(i_st + vec2(1.0, 1.0)); // top right corner\n\n    vec2 u = f_st;  // Keep u without smoothing to create sharp transitions\n\n    return mix(mix(v00, v10, u.x), mix(v01, v11, u.x), u.y); // Regular linear interpolation\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Get normalized coordinates [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Adjust aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n        // Center the UV coordinates at (0.5, 0.5) before scaling\n    uv -= 0.5;\n\n    // Scroll the noise by adding a time offset\n    float speed = 0.5;\n    uv += vec2(sin(iTime * speed) * 0.5, 0.0); // Scroll only along the x-axis\n    uv += vec2(0.0, cos(iTime * speed) * 0.5); // Scroll only along the y-axis\n\n\n\n    // Pixelate the UV coordinates to get blocky pixels (adjust scale to control pixel size)\n    float pixelSize = 0.005*sin(iTime * 0.5) + 0.01;   // Adjust this to control pixel sharpness (larger value = bigger pixels)\n    uv = floor(uv / pixelSize) * pixelSize;\n\n    // Scale UV coordinates to control frequency of noise\n    float noiseScale = 100.0*atan(iTime * 0.5) + 0.01;;   // Larger value = more detailed noise\n    uv *= noiseScale;\n\n    // Translate back to original range after scaling\n    uv += 0.5;\n\n    // Get the noise value at this pixel\n    float noiseValue = interpolateNoise(uv);\n\n    // Output the noise as a grayscale color\n    fragColor = vec4(vec3(noiseValue), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}