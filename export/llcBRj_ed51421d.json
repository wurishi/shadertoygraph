{"ver":"0.1","info":{"id":"llcBRj","date":"1540313508","viewed":218,"name":"Wave Equation","username":"kenhu","description":"wave equation","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["waveequation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Wave equation\n// Based on \n// - Mathematics for 3D Game Programming and Computer Graphics, Third Edition\n// - https://www.shadertoy.com/view/ldVyWW\n\n// from https://www.laurivan.com/rgb-to-hsv-to-rgb-for-shaders/\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Simulation code in Common\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = fragColor * 0.5 + 0.5;\n    \n    // Visualize as hue\n    fragColor.rgb = hsv2rgb(vec3(fragColor.r, 1.0, 1.0));\n    \n    // Fill with magenta if stable condition is not satisfied\n    if (is_delta_time_valid() < 0.0)\n        fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float c = 2.0;   // propagation velocity / c^2 = T/p = Tension/Density\nfloat d = 0.095; // grid unit\nfloat u = 0.0;   // viscocity\nfloat t = 0.033; // delta time\nfloat constant_damping = 0.9999;\n\nfloat is_delta_time_valid()\n{\n    return t < (u + sqrt(u * u + 32.0 * c * c / d / d)) / (8.0 * c * c / d / d) ? 1.0 : -1.0;\n}\n\nfloat constant_0()\n{\n    return (4.0 - 8.0 * c * c * t * t / d / d) / (u * t + 2.0);\n}\n\nfloat constant_1()\n{\n    return (u * t - 2.0) / (u * t + 2.0);\n}\n\nfloat constant_2()\n{\n    return (2.0 * c * c * t * t / d /d) / (u * t + 2.0);\n}\n\nvoid evaluate(\n    in sampler2D iChannel0, \n    in sampler2D iChannel1, \n    in sampler2D noiseTexture,\n    in vec3 iResolution, \n    in vec4 iMouse,\n    in float iTime,\n    out vec4 fragColor, \n    in vec2 fragCoord )\n{\n    // prev neighbours\n    vec4 a = textureLodOffset(iChannel0, fragCoord / iResolution.xy, 0.0, ivec2(-1,+0));\n    vec4 b = textureLodOffset(iChannel0, fragCoord / iResolution.xy, 0.0, ivec2(+1,+0));\n    vec4 c = textureLodOffset(iChannel0, fragCoord / iResolution.xy, 0.0, ivec2(+0,-1));\n    vec4 d = textureLodOffset(iChannel0, fragCoord / iResolution.xy, 0.0, ivec2(+0,+1));\n    \n    // prev  displacement\n    vec4 frame_current = textureLodOffset(iChannel0, fragCoord / iResolution.xy, 0.0, ivec2(+0,+0));\n    \n    // prev-prev displacement\n    vec4 frame_prev = textureLodOffset(iChannel1, fragCoord / iResolution.xy, 0.0, ivec2(+0,+0));\n    \n    // apply wave equation\n    fragColor = vec4(0)\n        + constant_0() * frame_current\n        + constant_1() * frame_prev\n        + constant_2() * (a+b+c+d);\n    \n    // clamp displacement\n    // fragColor = clamp(fragColor,vec4(-1.),vec4(1.));\n    \n    // noise damping\n    vec2 aspect = vec2(1.0, iResolution.y / iResolution.x);\n    vec2 tiling = vec2(4.0) * aspect;\n    vec2 scroll = vec2(iTime, 0.0) * vec2(0.5);\n    vec4 noise = texture(noiseTexture, fragCoord / iResolution.xy * tiling + scroll);\n    // fragColor *= (1.0 - noise.x * 0.01);\n    \n    // constant energy damping\n    fragColor *= constant_damping;\n    \n    // visualize noise\n    // fragColor = noise;\n    \n   \t// mouse input\n    if(iMouse.z > 0. && distance(fragCoord,iMouse.xy) < 10.) \n        fragColor = vec4(1.);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    evaluate(iChannel0, iChannel1, iChannel2, iResolution, iMouse, iTime, fragColor, fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    evaluate(iChannel0, iChannel1, iChannel2, iResolution, iMouse, iTime, fragColor, fragCoord);\n}","name":"Buffer C","description":"","type":"buffer"}]}