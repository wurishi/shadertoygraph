{"ver":"0.1","info":{"id":"WdcBWB","date":"1605942844","viewed":123,"name":"Chaos Turtles","username":"Gabe3704","description":"Just trying GLSL for the first time after making a node-based path tracer in Blender.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","pathtracing","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n#define EXPOSURE .5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n    \n    col *= EXPOSURE;\n    col = ACESFilm(col);\n    col = LinearToSRGB(col);\n    \n    fragColor = vec4(col.rgb,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 300\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define PI 3.14159265\n#define FRACTAL_I 15\n#define POWER 6.\n\nfloat dfMandelBulb(vec3 p)\n{\n    vec3 z = p;\n    float dr = 1.;\n    float r;\n    \n    for(int i=0; i<FRACTAL_I; i++)\n    {\n    \tr = length(z);\n        if (r > 2.){break;}\n        \n        float theta = acos(z.z / r) * POWER;\n        float phi = atan(z.y, z.x) * POWER;\n        float zr = pow(r, POWER);\n        dr = pow(r, POWER - 1.) * POWER * dr + 1.;\n        \n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return .5 * log(r) * r/dr;\n}\n\nfloat GetDist(vec3 p)\n{\n    return dfMandelBulb(p);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dO < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.000001,0);\n    \n    vec3 n = d - vec3\n    (\n        GetDist(p-e.xyy),    \n        GetDist(p-e.yxy),    \n        GetDist(p-e.yyx)    \n    );\n    \n    return normalize(n);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(vec2 p) \n{\n  int x = FK(p.x); int y = FK(p.y);\n  return (float((x-y*y)*(x*x+y)-x)/2.14e9) * .5 + .5;\n}\n\nvec2 hash2(vec2 n) \n{\n   return vec2(hash(n),hash(n+vec2(1))); \n    \n}\n\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    return (b);\n}\n               \nvec2 rv2;          \n\nvec3 getSampleBiased(vec3 dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rv2;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getCosineWeightedSample(vec3 dir)\n{\n    return getSampleBiased(dir,1.);\n}\n\nvec3 GetBG(vec3 dir) \n{\t\n\treturn vec3(texture(iChannel1,dir));\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  rv2;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rv2 = hash2(fragCoord+vec2(iTime*.42));\n    vec2 uv = ((fragCoord+hash2(vec2(iTime))-5.)-.5*iResolution.xy)/iResolution.y;\n    vec4 tex = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    vec4 mouse = iMouse / iResolution.xyxy;\n    bool mousePressed = (mouse.z>0.);\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(.25, .5, -1.5); //cam pos\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n\n    float d = RayMarch(ro,rd);\n    vec3 p = ro + rd*d;\n    vec3 n = GetNormal(p);\n    bool m = GetDist(p)>.01;\n    \n    vec3 rd2 = getCosineWeightedSample(n);\n    vec3 ro2 = p + n*.01;\n    float d2 = RayMarch(ro2,rd2);\n    vec3 p2 = ro2 + rd2*d2;\n    vec3 n2 = GetNormal(p2);\n    bool m2 = GetDist(p2)>.01;\n    m2 = m?true:m2;\n    \n    rv2 = hash2(fragCoord+vec2(iTime*1.153));\n    vec3 sunDir = vec3(.5,1,-.125); //sun direction\n    sunDir = getConeSample(sunDir, .01);\n    float d3 = RayMarch(ro2,sunDir);\n    vec3 p3 = ro2 + sunDir*d3;\n    bool m3 = GetDist(p3)>.01;\n    \n      \n    vec3 dir = vec3(m?rd:rd2);\n    \n    col = vec3(GetBG(dir));\n    col *= .5; //world strength\n    col += vec3(m3)*max(dot(sunDir,n),0.)* 16.; //sun strength\n    col *= float(m2);\n    col = m?vec3(.05):col;\n    \n    //col = min(n,vec3(0)); //fun bug with how color management deals with negative vectors :)\n    \n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n\tfloat blend = (lastFrameColor.a == 0.0f || mousePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n\tcol = mix(lastFrameColor.rgb, col, blend);\n \n\tfragColor = vec4(col, blend);\n}","name":"Buffer A","description":"","type":"buffer"}]}