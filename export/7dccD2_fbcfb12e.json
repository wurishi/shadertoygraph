{"ver":"0.1","info":{"id":"7dccD2","date":"1657454572","viewed":148,"name":"Fizzy bubbles","username":"fuzzmoon","description":"bubbles","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bubbles","fizzy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n// -----------------------------------------------\n//Hash and Position tracking from \n// The Universe Within - by Martijn Steinrucken aka BigWings 2018\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nfloat N21(vec2 p){\n    p = fract(p*vec2(3.14,1.73));\n    p += dot(p, p+17.73);\n    return (p.x * p.y);\n}\n\nvec2 GetPos(vec2 id, float t){\n    float n = N21(id);\n    float n1 = fract(n*100.);\n    float n2 = fract(n*10.);\n    float a = t+n;\n    return vec2(sin(a*n1), cos(a*n2))*.35;\n}\n\n// -----------------------------------------------\n\nfloat Disk(vec2 pos, vec2 center, float radius ){\n    vec2 d = pos - center;\n    float l = length(d);\n    return smoothstep(l,l-0.04,radius);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy-.5)/iResolution.y;\n    \n    float t = iTime;\n\n    vec3 col = 0.5 + 0.5*cos(uv.xyx*.34+vec3(2.,2.,0.));\n    uv.y -= t*.3;\n\n    vec2 gv = fract(uv*2.)-.5;\n    vec2 id = floor(uv*2.);\n    gv *= .7 + 0.5*length(gv);\n    gv *= 1.5 + 0.1*sin(gv.x+t*.15) + 0.1*sin(gv.y*.03);\n\n    vec2 pos = GetPos(id, t);\n    float n = fract(N21(id));\n\n    float d = Disk(pos, gv, .3-(n*.125))*.5;\n    d += Disk(pos, gv-.1+n*.01, .03*n*.1);\n    d *= Disk(pos, gv-.13+n*.01, .03*n*.1);\n\n    fragColor = vec4(col/d,1.0);\n}","name":"Image","description":"","type":"image"}]}