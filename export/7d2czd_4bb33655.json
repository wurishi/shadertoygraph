{"ver":"0.1","info":{"id":"7d2czd","date":"1643972272","viewed":133,"name":"Fibonacci spiral (tech demo)","username":"stegu","description":"The planar Fibonacci spiral pattern, but without using the animated fractional-N growth part of the function, asking for integer set sizes only and adding points around the periphery rather than at the center. Some \"kaleidoscope\" animation added for fun.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["spiral","animated","fibonacci","sunflower","growth","botany"],"hasliked":0,"parentid":"7sjyzy","parentname":"Phyllotactic spiral (tech demo)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Compute Fibonacci number F_i without a loop\n// (Doubtful if it saves any work for small i, pow() is expensive,\n// but formally this is \"constant time\", and it works for i <= 29.)\nfloat fibonacci(float i) {\n\treturn floor(pow(PHI, i)/sqrt(5.0) + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float N = 500.0+iTime*100.0;\n    // Zoom out to fit most of the set in the viewport as it grows\n    float scale = 2.0*max(4.0, sqrt(N));\n    float uvscale = 1.0/max(iResolution.x, iResolution.y);\n    vec2 uvcenter = 0.5*iResolution.xy;\n    // Adjust scale by mouse drags (down-drag zooms out, up-drag zooms in)\n    float zoom = pow(0.99,iMouse.y-abs(iMouse.w));\n    vec2 uv = zoom*scale*(uvscale*(fragCoord-uvcenter));\n\n    vec3 nn = inversePF(uv, 1.0, 0.0);\n    float d = length(uv-nn.xy);\n    if(nn.z>=floor(N)) d = 1.0; // Hide points with index > intN\n    \n    float i = floor(mod(iTime,6.0));\n    float Fi = fibonacci(i+4.0);\n    float disksize = 0.7+0.2*sin(sqrt(nn.z)*Fi-5.0*iTime);\n    vec3 mixcolor = mix(vec3(0.0,0.6,0.0), vec3(d/disksize), 1.0-aastep(disksize,d));\n\n    fragColor = vec4(mixcolor,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n#define Phi 0.618033988749895\n\nfloat fracmodphi(float k) {\n\t// (Pray that this maps to an FMA instruction)\n\treturn k * Phi - floor(k * Phi);\n}\n\n//\n// Find nearest neighbor in an N-point Fibonacci spiral,\n// not scaled to fit in the unit circle but growing\n// with N to a radius sqrt(N) around the origin.\n// Modified version of the algorithm from the article\n// \"Spherical Fibonacci Mapping\" by Keinert et al,\n// ACM Trans. on Graphics 34 (2015), 6, 193.\n// Ported from HLSL to GLSL by Stefan Gustavson 2021,\n// edited for planar mapping and modified for animation\n// by Stefan Gustavson 2022.\n// Copyright 2022 Stefan Gustavson, released under the\n// terms of the MIT license (\"use freely with credit\"):\n// https://opensource.org/licenses/MIT\n// \n// The vec3 return value has the position of the nearest\n// neighbor in .xy, and its integer index (k) in .z.\n// A gradual blend between configurations with N and N+1\n// points can be achieved by calling the function with\n// intN = floor(t), fracN = fract(t), N <= t < N+1.\n// Indices are numbered from 0 up outwards from the origin.\n// If you want the index to \"follow\" a point as it \"moves\n// outwards\" with an animated N, the index needs to be\n// recomputed as (intN - k). The point set is not limited\n// to N points -- the point returned is the nearest neighbor\n// on the infinite plane, with k as large as it takes.\n//\nvec3 inversePF(vec2 p, float intN, float fracN) {\n\tvec3 nn;\n\tfloat theta = min(atan(p.y, p.x), PI); // min() to dodge NaN\n\tfloat r2 = dot(p,p);\n    float i = max(0.0, r2-0.5+fracN);\n    float k = max(2.0, 1.0+floor(log(sqrt(5.0)*PI*(i+0.5))/2.0/log(PHI)));\n\t// F0, F1 are actually faster to compute with pow()\n\t// than by using an array of precomputed values.\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 =  floor(Fk * PHI + 0.5);\n    float B0 = fracmodphi(F0);\n    B0 = (B0 > 0.62) ? B0-1.0 : B0;\n    float B1 = fracmodphi(F1);\n    B1 = (B1 > 0.62) ? B1-1.0 : B1;\n\tmat2 B = mat2(2.0*PI*B0, F0,\n                  2.0*PI*B1, F1);\n\tmat2 invB = inverse(B);\n    float ctheta = theta + 2.0*PI*fracmodphi(intN);\n    float ci = i + 0.5 + fracN;\n    vec2 c = floor(invB * vec2(ctheta, ci));\n\tfloat dsqmin = 1e10; // Effectively \"Inf\"\n    float r, dsq;\n    vec2 q;\n\tfor (float s = 0.0; s < 4.0; s++) {\n\t\ti = dot(vec2(F0, F1),\n\t\t\tvec2(mod(s, 2.0), floor(s*0.5)) + c);\n        i = floor(abs(i)+0.5);\n        theta = 2.0*PI*fracmodphi(i-intN);\n\t\tr = sqrt(i+0.5+fracN);\n\t\tq = vec2(cos(theta)*r, sin(theta)*r);\n\t\tdsq = dot(p-q, p-q); // Most numerically sound measure\n\t\tif (dsq < dsqmin) {\n\t\t\tdsqmin = dsq;\n\t\t\tnn.xy = q;\n\t\t\tnn.z = i;\n\t\t}\n\t}\n    // The return value is the closest point in the set,\n    // but with a few glitches close to some Voronoi cell edges\n    // for some values of fracN.\n    // The most blatant error is that we sometimes miss cell 0\n    // near the origin. Let's fix that, because it encroaches on\n    // the useful circular portion of cell 0, but leave the rest.\n    if(r2 < 3.0) {\n        theta = 2.0*PI*fracmodphi(0.0-intN);\n\t\tr = sqrt(0.0+0.5+fracN);\n\t\tq = vec2(cos(theta)*r, sin(theta)*r);\n\t\tdsq = dot(p-q, p-q); // Most numerically sound measure\n\t\tif (dsq < dsqmin) {\n\t\t\tdsqmin = dsq;\n\t\t\tnn.xy = q;\n\t\t\tnn.z = 0.0;\n\t\t}\n    }\n    return nn;\n}\n","name":"Common","description":"","type":"common"}]}