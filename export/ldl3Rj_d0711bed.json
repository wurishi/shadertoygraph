{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// elephant\n// @simesgreen\n\nconst int maxSteps = 64;\nconst float hitThreshold = 0.005;\nconst int shadowSteps = 64;\nconst float PI = 3.14159;\n\n// smooth min function, thanks iq!\nfloat smin( float a, float b )\n{\n     const float k = 0.08;\n     //float k = 0.21 + sin(iTime*0.3)*0.2;\n     float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n     return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p ); \t\n    return f;\n}\n\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x - sa*p.y, sa*p.x + ca*p.y, p.z);\n}\n\n// primitive functions\n// these all return the distance to the surface from a given point\n\n  // n must be normalized\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat obj(vec3 p, float d, mat4 invMat, float scale)\n{\n     p = vec3(vec4(p, 1.0) * invMat);     // transform into unit sphere space\n     float nd = sphere(p, 0.5) * scale;\n     //return min(d, nd);  // sharp\n     return smin(d, nd);     // smooth\n}\n\n// distance to scene\nfloat scene(vec3 p)\n{          \n    float d = 1e10;\n     \n     p.z = -p.z;;\n     d = plane(p, vec4(0.0, 1.0, 0.0, 0.0));\n          \n     d = obj(p, d, mat4(1.2803, .0257, -.1086, -.1481, -.0648, 2.3275, -.2133, -3.2924, .1019, .1154, 1.2281, -.0267, .0000, .0000, .0000, 1.0000), 0.3421481);\n     d = obj(p, d, mat4(1.2662, .0344, -.1104, -.1702, -.0370, 2.3495, .3066, -4.6523, .1192, -.1698, 1.3155, .3811, .0000, .0000, .0000, 1.0000), 0.3375993);\n     d = obj(p, d, mat4(.8106, .0238, -.0705, -.1052, -.0341, 1.4574, .1003, -2.4684, .0714, -.0536, .8026, .0343, .0000, .0000, .0000, 1.0000), 0.5474745);\n     d = obj(p, d, mat4(.5588, -.5116, .2569, .3841, .3507, .5897, .4115, -1.5407, -6.3634, -2.4589, 8.9475, 7.0953, .0000, .0000, .0000, 1.0000), 0.07110132);\n     d = obj(p, d, mat4(.5540, .4782, -.3232, -.3529, -.3384, .6320, .3551, -1.4915, 6.5760, -1.5359, 8.9997, 3.8446, .0000, .0000, .0000, 1.0000), 0.07110132);\n     d = obj(p, d, mat4(2.7186, .5212, -.2130, -.7512, -.2716, 1.3373, -.1946, -.9392, .1396, .4468, 2.8748, .4618, .0000, .0000, .0000, 1.0000), 0.2746665);\n     d = obj(p, d, mat4(4.3558, 1.7680, -.6095, -1.6599, -.6871, 1.4367, -.7429, -.3387, -.2280, 1.9038, 3.8927, .1645, .0000, .0000, .0000, 1.0000), 0.1687667);\n     d = obj(p, d, mat4(2.1226, .0218, -.1781, -.2373, .0000, 1.5515, .1902, -1.5960, .1795, -.2583, 2.1068, .8252, .0000, .0000, .0000, 1.0000), 0.3755594);\n     d = obj(p, d, mat4(2.5502, 4.0364, -6.2848, -6.8785, 1.1011, 1.9351, 1.6896, -1.1261, 5.3419, -3.1602, .1379, 5.1073, .0000, .0000, .0000, 1.0000), 0.1013599);\n     d = obj(p, d, mat4(9.8963, 10.9896, -2.6877, -7.3528, 1.3209, -.5031, 2.8065, 3.6789, 7.5378, -8.0065, -4.9828, 7.6609, .0000, .0000, .0000, 1.0000), 0.05322327);\n     d = obj(p, d, mat4(3.8968, 6.2161, -5.7150, -8.3724, 1.5393, .6879, 1.7978, 1.1367, 4.8210, -5.0434, -2.1983, 5.5735, .0000, .0000, .0000, 1.0000), 0.08602334);\n     d = obj(p, d, mat4(6.6851, 4.1233, -.7759, -7.6863, -1.1433, 2.1203, 1.4174, -1.2823, 2.1077, -2.4170, 5.3158, 4.4889, .0000, .0000, .0000, 1.0000), 0.1013599);\n     d = obj(p, d, mat4(6.3641, 12.4248, 6.8200, -9.3938, -2.2613, -.1936, 2.4629, 3.8232, 7.2178, -7.0311, 6.0743, 6.8159, .0000, .0000, .0000, 1.0000), 0.0514908);\n     d = obj(p, d, mat4(6.7540, 6.3613, .6346, -9.2097, -1.1026, .9734, 1.9777, .9464, 3.8180, -4.4863, 4.3366, 5.2496, .0000, .0000, .0000, 1.0000), 0.08602334);\n\n     d = obj(p, d, mat4(.6275, .0000, .0000, -.0658, .0000, .8511, .0000, -1.2585, .0000, .0000, .8511, -.8373, .0000, .0000, .0000, 1.0000), 0.94);\n     d = obj(p, d, mat4(.6625, -.0421, -.0288, .0436, .0452, .6584, .0778, -1.1031, .0236, -.0795, .6593, -1.1483, .0000, .0000, .0000, 1.0000), 1.203912);\n\n\t // save some instructions, legs are symmetrical\n\t p.x = abs(p.x);\n\t\n\t/*\n     d = obj(p, d, mat4(2.4187, .0000, .0000, .9254, .0000, 3.4403, .0000, -.4139, .0000, .0000, 2.2953, -5.2986, .0000, .0000, .0000, 1.0000), 0.232537);\n     d = obj(p, d, mat4(3.2647, .0000, .0000, 1.2491, .0000, 1.4969, .0000, -.7095, .0000, .0000, 2.9657, -6.8464, .0000, .0000, .0000, 1.0000), 0.2295453);\n     d = obj(p, d, mat4(2.2941, .0000, .0000, .8777, .0000, 1.4969, .0000, -1.3468, .0000, .0000, 2.3149, -5.3439, .0000, .0000, .0000, 1.0000), 0.317626);\n\t*/\n\n\t d = obj(p, d, mat4(2.4290, .0000, .0000, -1.3538, .0000, 3.4403, .0000, -.4139, .0000, .0000, 2.2102, -5.0321, .0000, .0000, .0000, 1.0000), 0.232537);\n     d = obj(p, d, mat4(3.2786, .0000, .0000, -1.8273, .0000, 1.4969, .0000, -.7095, .0000, .0000, 2.8559, -6.5020, .0000, .0000, .0000, 1.0000), 0.2295453);\n     d = obj(p, d, mat4(2.3039, .0000, .0000, -1.2841, .0000, 1.4969, .0000, -1.3468, .0000, .0000, 2.2291, -5.0751, .0000, .0000, .0000, 1.0000), 0.317626);\n\n     d = obj(p, d, mat4(2.2877, .0000, .0000, -1.4038, .0000, 3.4403, .0000, -.4139, .0000, .0000, 1.9638, -1.1446, .0000, .0000, .0000, 1.0000), 0.232537);\n     d = obj(p, d, mat4(3.0878, .0000, .0000, -1.8949, .0000, 1.4969, .0000, -.7095, .0000, .0000, 2.5374, -1.4916, .0000, .0000, .0000, 1.0000), 0.2295453);\n     d = obj(p, d, mat4(2.1698, .0000, .0000, -1.3315, .0000, .8897, .0923, -1.0531, .0000, -.3293, 1.9636, -.9458, .0000, .0000, .0000, 1.0000), 0.317626);     \n\t\n\t/*\n     d = obj(p, d, mat4(2.3018, .0000, .0000, 1.0433, .0000, 3.4403, .0000, -.3507, .0000, .0000, 1.8847, -1.0916, .0000, .0000, .0000, 1.0000), 0.232537);\n     d = obj(p, d, mat4(3.1070, .0000, .0000, 1.4082, .0000, 1.4969, .0000, -.6819, .0000, .0000, 2.4352, -1.3938, .0000, .0000, .0000, 1.0000), 0.2295453);\n     d = obj(p, d, mat4(2.1833, .0000, .0000, .9895, .0000, .9280, .0872, -1.1071, .0000, -.3113, 1.8862, -.8113, .0000, .0000, .0000, 1.0000), 0.317626);\n\t*/\n\t\n\t// add skin texture\n\td += fbm(p*vec3(5.0, 20.0, 20.0))*0.002;\n\t\n\treturn d;\n}\n\n// calculate scene normal\nvec3 sceneNormal(in vec3 pos )\n{\n    float eps = 0.0001;\n    vec3 n;\n    float d = scene(pos);\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - d;\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - d;\n    return normalize(n);\n}\n\n// ambient occlusion approximation\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - scene(p + n*d));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float dt = (maxt - mint) / float(shadowSteps);\n    float t = mint;\n     //t += hash(ro.z*574854.0 + ro.y*517.0 + ro.x)*0.1;\n    float res = 1.0;\n    for( int i=0; i<shadowSteps; i++ )\n    {\n        float h = scene(ro + rd*t);\n          if (h < hitThreshold) return 0.0;     // hit\n        res = min(res, k*h/t);\n        //t += h;\n          t += dt;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\n// trace ray using sphere tracing\nvec3 trace(vec3 ro, vec3 rd, out bool hit)\n{\n    hit = false;\n    vec3 pos = ro;\n    for(int i=0; i<maxSteps; i++)\n    {\n          if (!hit) {\n               float d = scene(pos);\n               if (abs(d) < hitThreshold) {\n                    hit = true;\n               }\n               pos += d*rd;\n          }\n    }\n    return pos;\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos)\n{\n    float ao = ambientOcclusion(pos, n);\n     \n     // skylight\n     vec3 sky = mix(vec3(0.3, 0.2, 0.0), vec3(0.6, 0.8, 1.0), n.y*0.5+0.5);\n     vec3 c = sky*ao*0.5;\n\n#if 1\n     // point light\n     const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n     const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n     \n     vec3 l = lightPos - pos;\n     float dist = length(l);\n     l /= dist;\n     float diff = max(0.0, dot(n, l));\n     //diff *= 50.0 / (dist*dist);     // attenutation\n     \n#if 0\n     float maxt = dist;\n     float shadow = softShadow( pos, l, 0.1, maxt, 5.0 );\n     diff *= shadow;\n#endif\n     \n     c += diff*lightColor;\n#endif\n     \n//     return vec3(ao);\n//     return n*0.5+0.5;\n     return c;\n}\n\nvec3 background(vec3 rd)\n{\n     return mix(vec3(0.3, 0.2, 0.0), vec3(0.6, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -1.5));\n    vec3 ro = vec3(0.0, 1.2, 2.0);\n\n     vec2 mouse = iMouse.xy / iResolution.xy;\n     float roty = 0.0; // sin(iTime*0.2);\n     float rotx = 0.0;\n     if (iMouse.z > 0.0) {\n          rotx = -(mouse.y-0.5)*3.0;\n          roty = -(mouse.x-0.5)*6.0;\n     } else {\n          roty = sin(iTime*0.5)*PI*0.5;\n     }\n     \n    rd = rotateX(rd, rotx);\n    ro = rotateX(ro, rotx);\n          \n    rd = rotateY(rd, roty);\n    ro = rotateY(ro, roty);\n          \n    // trace ray\n    bool hit;\n    vec3 pos = trace(ro, rd, hit);\n\n    vec3 rgb;\n    if(hit) {\n        // calc normal\n        vec3 n = sceneNormal(pos);\n        // shade\n        rgb = shade(pos, n, ro);\n\n     } else {\n        rgb = background(rd);\n     }\n     \n    fragColor=vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldl3Rj","date":"1374768751","viewed":1083,"name":"ellipsoid elephant","username":"simesgreen","description":"experiment in modelling with blended ellipsoids.\nmodelled in unity, is that cheating? :)","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","ellipsoid","blobby"],"hasliked":0,"parentid":"","parentname":""}}