{"ver":"0.1","info":{"id":"tdjBzw","date":"1589754532","viewed":203,"name":"ShATI - Flamme","username":"Flopine","description":"My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 14th subject: flame :)\nInspired by Super Mario Odyssey","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fire","modeling","glow","mario"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n\n#define time iTime\n#define PI acos(-1.)\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(32.6,13.4)))*1254.4);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) \n{\n    float k = dot(p-a, b-a)/dot(b-a,b-a);\n    return distance(p, mix(a, b, clamp(k, 0., 1.)));\n}\n\nfloat face, body; \nfloat g1=0.;\nfloat SDF (vec3 p)\n{\n    float r = 0.5;\n    float sy = 1.+sin(time*15.)*0.1+0.1;\n    float sxz = 1./sy;\n    vec3 resize = vec3(sxz,sy,sxz);\n    p.y +=r ;\n    p *= resize;\n    p.y -= r;\n    vec3 pp = p;\n\n    // corps\n\n    p.x -= texNoise(p.yz*0.1+time*0.5).r*0.1;\n    p.y += texNoise(p.xz*0.08+time*0.5).r*0.25;\n    float bd = length(p)-r; \n    // nez\n    p.x *= 0.8; \n    bd = min(bd,(length(p+vec3(0.,0.08,r*1.2))-0.12)/length(vec3(0.8,0.,0.)));\n\n\n    // yeux\n    p = pp;\n    p.x = abs(p.x)-0.15;\n    p.x *= 1.3;\n    float fd = length(p+vec3(0.,-0.07,r*.92))-0.1;\n\n    // sourcils\n    p = pp;\n    p.x = abs(p.x)-0.18;\n    p += vec3(0.,-0.28,r*0.9);\n    p.xz *= rot(PI/6.);\n    p.y += p.x*p.x*2.;\n    fd = min(fd,max(length(p.yz)-(0.01-sqrt(p.x*p.x+0.001)*0.15),abs(p.x)-0.2));\n\n    // moustache\n    p = pp;\n    p *= 1.1;\n    p.y += cos(p.x*3.)*0.2;\n    float line = linedist(p,vec3(-r,0.,-r),vec3(r,0.,-r))-(0.06-sqrt(p.x*p.x+0.001)*0.2) / 1.1;\n    p = pp;  \n    p *= 1.1;\n    p.x = abs(p.x);\n    float spheres = length(p+vec3(-0.35, 0.15, r))-0.05;\n    spheres = min(spheres,length(p+vec3(-0.22, 0.25, r))-0.05);\n    spheres = min(spheres,length(p+vec3(-0.08, 0.3, r))-0.05) / 1.1;\n    float mustache = smin(line, spheres, 0.15);\n    fd = min(fd, mustache);\n\n    body = bd/length(resize);\n    g1 += 0.001/(0.001+body*body);\n    face = fd/length(resize);\n\n    return min(body,face);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n} \n\nfloat spec (vec3 rd, vec3 n, vec3 l)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(h,n),0.),15.);\n}\n\nfloat bubble (vec2 uv, float r, vec2 offset)\n{\n    return smoothstep(r,r*0.9,length(uv+offset))*length(uv+offset);\n}\n\nvec3 background(vec2 uv)\n{\n    vec3 color = vec3(1.,0.5,0.8);\n    color += bubble(uv, 0.25+sin(time*1.2)*0.01, vec2(-0.2, -0.1));\n    uv.x = abs(uv.x)-.8;\n    color += bubble(uv, 0.2+sin(time)*0.01, vec2(0.5));\n    color += bubble(uv, 0.3+sin(time*1.5)*0.01, vec2(0.1, 0.3));\n    color += bubble(uv, 0.25+sin(time*1.2)*0.01, vec2(0.4, -0.4));\n    return color;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.,0.,-2.2),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        l = vec3(1.,2.,-2.),\n        col = background(uv)*0.8;\n\n    float shad, d = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<64.; i++)\n    {\n        d  = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }   \n        d *= 0.9+dither*0.1;\n        p += d*rd;\n    }\n\n\n    if (hit)\n    {\n        float bo = body;\n        float fa = face;\n        vec3 n = getnorm(p);\n        float fre = pow(max(1.-dot(-rd,n),0.),1.);\n        if (d == bo) \n        {\n            col = mix(vec3(0.8,0.8, 0.1),vec3(0.8,0.2,0.), smoothstep(0.2,0.9,fre));\n            col += spec(rd, n, l)*(fre*2.);\n        }\n        if (d == fa) col = mix(vec3(0.05,0., 0.),vec3(0.8,0.1,0.),fre);\n    }\n    \n    col += g1*0.1*vec3(1.,0.1,0.01);\n    fragColor = vec4(sqrt(col),1.);\n}","name":"Image","description":"","type":"image"}]}