{"ver":"0.1","info":{"id":"tsK3DK","date":"1571015062","viewed":519,"name":"Navier-Stokes equation","username":"vdecaria","description":"Navier-Stokes equation. Based on Gijs basic heat equation. https://www.shadertoy.com/view/MlscDs.\n\nSee image for readme. Click screen to place inflow.\nModify parameters in common. Use mouse to change things.\nThanks for suggestions by Cotterzz and wyatt.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["fluid","navierstokes","incompressible"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\"Incompressible\" Navier-Stokes equations\n\nImproved by helpful suggestions from Cotterzz and wyatt.\n\nu_t + (u.grad)u - nu div(grad(u)) + grad(p) = 0\ndiv(u) = 0.\n\nThis equation has an infinite wave speed due to incompressibility\nwhich makes explicit methods difficult.\n\nWe hack it with the penalty method. Perturb the continuity equation by\nepsilon*p + div(u) = 0.\nTake the gradient, and solve for p.\n\ngrad(p) = -1/epsilon grad(div(u))\n\nSubstitute this into the momentum equation.\n\nu_t + (u.grad)u - nu div(grad(u)) - 1/epsilon grad(div(u)) = 0.\n\nThis reduces the unknowns (in 2D) from 3 to 2.\n\nThe smaller epsilon, the faster information can propogate.\nThe other terms are difficult too.\n\nRed is the x-component.\nGreen is the y-component.\n\nPlay with the parameters in Common.\n\nLowering the viscosity also makes epsilon smaller,\nenforcing incompressibility more strongly.\nIt also makes the timestep smaller.\n\nviscosity is set to .1 by default. \n\n.1 gives interesting results and has a tolerable speed.\n\n\nI used explicit Euler, and whatever difference stensils \nseemed intuitive, but they may not be the best. (especially\nthe grad-div and convective ones.)\n\nYou can change mouse radius and speed too.\n\n*/\nvec4 getT(sampler2D g, vec2 p){\n    return texture(g,p/iResolution.xy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Colors get clipped between 0 and 1 for rendering.\n    //Need to take absolute value here so negative velocities\n    //are seen.\n    \n    if(view_option == 0)\n    \tfragColor = abs(texture(iChannel0,fragCoord.xy / iResolution.xy));\n    \n    else if(view_option == 1){\n       float dy = dx;\n       vec2 middle    = getT(iChannel0,fragCoord).xy;   \t\n       vec2 up        = getT(iChannel0,fragCoord+vec2( 0, int(grid_level))).xy;\n       vec2 down      = getT(iChannel0,fragCoord+vec2( 0,-int(grid_level))).xy;\n       vec2 right     = getT(iChannel0,fragCoord+vec2( int(grid_level), 0)).xy;\n       vec2 left      = getT(iChannel0,fragCoord+vec2(-int(grid_level), 0)).xy;\n       float vort     = (left.y - right.y)/dx - (up.x - down.x)/dy;\n       vec2  vort_vec = 5.*vec2(max(0.,vort), abs(min(0.,vort)));\n       float div = (left.x - right.x)/dx + (up.y - down.y)/dx;\n       fragColor = vec4(vort_vec, 50.* div, 0.);\n    }\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 getT(sampler2D g, vec2 p){\n    return texture(g,p/iResolution.xy);\n\n}\n\nvec2 euler(sampler2D g, vec2 p){\n    vec2 middle    = getT(g,p).xy;   \t\n    vec2 up        = getT(g,p+vec2( 0, int(grid_level))).xy;\n    vec2 down      = getT(g,p+vec2( 0,-int(grid_level))).xy;\n    vec2 right     = getT(g,p+vec2( int(grid_level), 0)).xy;\n    vec2 left      = getT(g,p+vec2(-int(grid_level), 0)).xy;\n    vec2 upright   = getT(g,p+vec2( int(grid_level), int(grid_level))).xy;\t\n    vec2 upleft    = getT(g,p+vec2(-int(grid_level), int(grid_level))).xy;\n    vec2 downright = getT(g,p+vec2( int(grid_level),-int(grid_level))).xy;\n    vec2 downleft  = getT(g,p+vec2(-int(grid_level),-int(grid_level))).xy;\n\t\n    vec2 gradDiv\\\n   \t= vec2((0.25*(upleft.y + up.y)  - 0.25*(downleft.y + down.y)   + left.x   -middle.x\\\n                -(0.25*(upright.y + up.y) - 0.25*(downright.y+ down.y)  + middle.x     -right.x))/(pow(grid_level,2.)*dx*dx),\\\n                (up.y    - middle.y     + 0.25*(upleft.x + left.x)     -0.25*(upright.x + right.x)\\\n                -(middle.y  - down.y   + 0.25*(downleft.x + left.x)   -0.25*(downright.x+right.x)))/(pow(grid_level,2.)*dx*dx));\n    \n    //laplacian(u) = div(grad(u))\n    //Gijs ninepoint stensil.\n    vec2 laplacian\\\n    = (-8.*middle + up + left + right + down + upright + upleft + downright + downleft)/(3.*pow(grid_level,2.)*dx*dx);  \n    \n    //(uxdx + uydy)ux, (uxdx + uydy)uy\n    vec2 convect\\\n   \t= vec2((middle.x*(left.x - right.x) + middle.y*(up.x - down.x))/(2.*grid_level*dx),\\\n               (middle.x*(left.y - right.y) + middle.y*(up.y - down.y))/(2.*grid_level*dx));\n    \n    //\"Navier-Stokes\"\n    return  middle.xy + dt*(viscosity*laplacian + nonlin_strength*convect + 1.0/epsilon*gradDiv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){  \n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    if(distance(iMouse.xy,fragCoord)<circle_radius){\n        fragColor.xy = mouse_speed;\n        fragColor.z = 1.0;\n        \n\n    }\n    else if(uv.x < .005){\n        if(uv.y > .62 && uv.y < .7){\n            fragColor.xy = vec2(1.0,0.);\n        }\n        else{\n            fragColor.xy = vec2(0.0,0.);\n        }\n    }\n    else if(uv.y > .99){\n        if(uv.x > .3 && uv.x < .36){\n            fragColor.xy = vec2(0.0,1.);\n        }\n        else{\n            fragColor.xy = vec2(0.0,0.);\n        }\n    }\n    else{\n        fragColor.xy = euler(iChannel0,fragCoord);\n        //fragColor.xy = euler(iChannel1,fragCoord);\n\n    }\n    \n    //Apply a directional do nothing condition at bottom and right outflows.\n    if(uv.y <.01)\n        fragColor.y = max(0.,fragColor.y);\n    else if(uv.x >.995)\n        fragColor.x = max(0.,fragColor.x);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst float viscosity = 1.;                //Tested down to .01. Gets slow...0.1 is kind of interesting\n                                           //Seems unstable for bigger viscosity.\nconst float dx = 5.;\nconst float grid_level = 1.;\nconst float dt = viscosity*dx*dx*.095;    //Smaller value enforces incompressibility more.\nconst float epsilon = viscosity*.25;\nconst float nonlin_strength = 1.;         //Proportional to Reynolds number.\n\n\nconst vec2 mouse_speed = vec2(-.5,-0.5);   //Set equal to zero to turn mouse\n                                          //into an obstacle.\n\nconst float circle_radius = 10.;\n\nint view_option = 0;      // 0 - Green x component of velocity, Red y component\n                            // 1 - Red green vorticity, blue divergence.\n\n\n//Experimental\n/*\nconst float viscosity =.5 ;                //Tested down to .01. Gets slow...0.1 is kind of interesting\n                                           //Seems unstable for bigger viscosity.\nconst float dx = 4.;\nconst float grid_level = 6.;\nconst float dt = viscosity*dx*dx*.5;    //Smaller value enforces incompressibility more.\nconst float epsilon = viscosity*.03;\nconst float nonlin_strength = 1.;         //Proportional to Reynolds number.\n\n\nconst vec2 mouse_speed = vec2(0.,0.);   //Set equal to zero to turn mouse\n                                          //into an obstacle.\n\nconst float circle_radius = 10.;\n*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 getT(sampler2D g, vec2 p){\n    return texture(g,p/iResolution.xy);\n\n}\n\nvec2 euler(sampler2D g, vec2 p){\n    vec2 middle    = getT(g,p).xy;   \t\n    vec2 up        = getT(g,p+vec2( 0, int(grid_level))).xy;\n    vec2 down      = getT(g,p+vec2( 0,-int(grid_level))).xy;\n    vec2 right     = getT(g,p+vec2( int(grid_level), 0)).xy;\n    vec2 left      = getT(g,p+vec2(-int(grid_level), 0)).xy;\n    vec2 upright   = getT(g,p+vec2( int(grid_level), int(grid_level))).xy;\t\n    vec2 upleft    = getT(g,p+vec2(-int(grid_level), int(grid_level))).xy;\n    vec2 downright = getT(g,p+vec2( int(grid_level),-int(grid_level))).xy;\n    vec2 downleft  = getT(g,p+vec2(-int(grid_level),-int(grid_level))).xy;\n\t\n    vec2 gradDiv\\\n   \t= vec2((0.25*(upleft.y + up.y)  - 0.25*(downleft.y + down.y)   + left.x   -middle.x\\\n                -(0.25*(upright.y + up.y) - 0.25*(downright.y+ down.y)  + middle.x     -right.x))/(pow(grid_level,2.)*dx*dx),\\\n                (up.y    - middle.y     + 0.25*(upleft.x + left.x)     -0.25*(upright.x + right.x)\\\n                -(middle.y  - down.y   + 0.25*(downleft.x + left.x)   -0.25*(downright.x+right.x)))/(pow(grid_level,2.)*dx*dx));\n    \n    //laplacian(u) = div(grad(u))\n    //Gijs ninepoint stensil.\n    vec2 laplacian\\\n    = (-8.*middle + up + left + right + down + upright + upleft + downright + downleft)/(3.*pow(grid_level,2.)*dx*dx);  \n    \n    //(uxdx + uydy)ux, (uxdx + uydy)uy\n    vec2 convect\\\n   \t= vec2((middle.x*(left.x - right.x) + middle.y*(up.x - down.x))/(2.*grid_level*dx),\\\n               (middle.x*(left.y - right.y) + middle.y*(up.y - down.y))/(2.*grid_level*dx));\n    \n    //\"Navier-Stokes\"\n    return  middle.xy + dt*(viscosity*laplacian + nonlin_strength*convect + 1.0/epsilon*gradDiv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){  \n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    if(distance(iMouse.xy,fragCoord)<circle_radius){\n        fragColor.xy = mouse_speed;\n        fragColor.z = 1.0;\n        \n\n    }\n    else if(uv.x < .005){\n        if(uv.y > .62 && uv.y < .7){\n            fragColor.xy = vec2(1.0,0.);\n        }\n        else{\n            fragColor.xy = vec2(0.0,0.);\n        }\n    }\n    else if(uv.y > .99){\n        if(uv.x > .3 && uv.x < .36){\n            fragColor.xy = vec2(0.0,1.);\n        }\n        else{\n            fragColor.xy = vec2(0.0,0.);\n        }\n    }\n    else{\n        fragColor.xy = euler(iChannel0,fragCoord);\n        //fragColor.xy = euler(iChannel1,fragCoord);\n\n    }\n    \n    //Apply a directional do nothing condition at bottom and right outflows.\n    if(uv.y <.01)\n        fragColor.y = max(0.,fragColor.y);\n    else if(uv.x >.995)\n        fragColor.x = max(0.,fragColor.x);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 getT(sampler2D g, vec2 p){\n    return texture(g,p/iResolution.xy);\n\n}\n\nvec2 euler(sampler2D g, vec2 p){\n    vec2 middle    = getT(g,p).xy;   \t\n    vec2 up        = getT(g,p+vec2( 0, int(grid_level))).xy;\n    vec2 down      = getT(g,p+vec2( 0,-int(grid_level))).xy;\n    vec2 right     = getT(g,p+vec2( int(grid_level), 0)).xy;\n    vec2 left      = getT(g,p+vec2(-int(grid_level), 0)).xy;\n    vec2 upright   = getT(g,p+vec2( int(grid_level), int(grid_level))).xy;\t\n    vec2 upleft    = getT(g,p+vec2(-int(grid_level), int(grid_level))).xy;\n    vec2 downright = getT(g,p+vec2( int(grid_level),-int(grid_level))).xy;\n    vec2 downleft  = getT(g,p+vec2(-int(grid_level),-int(grid_level))).xy;\n\t\n    vec2 gradDiv\\\n   \t= vec2((0.25*(upleft.y + up.y)  - 0.25*(downleft.y + down.y)   + left.x   -middle.x\\\n                -(0.25*(upright.y + up.y) - 0.25*(downright.y+ down.y)  + middle.x     -right.x))/(pow(grid_level,2.)*dx*dx),\\\n                (up.y    - middle.y     + 0.25*(upleft.x + left.x)     -0.25*(upright.x + right.x)\\\n                -(middle.y  - down.y   + 0.25*(downleft.x + left.x)   -0.25*(downright.x+right.x)))/(pow(grid_level,2.)*dx*dx));\n    \n    //laplacian(u) = div(grad(u))\n    //Gijs ninepoint stensil.\n    vec2 laplacian\\\n    = (-8.*middle + up + left + right + down + upright + upleft + downright + downleft)/(3.*pow(grid_level,2.)*dx*dx);  \n    \n    //(uxdx + uydy)ux, (uxdx + uydy)uy\n    vec2 convect\\\n   \t= vec2((middle.x*(left.x - right.x) + middle.y*(up.x - down.x))/(2.*grid_level*dx),\\\n               (middle.x*(left.y - right.y) + middle.y*(up.y - down.y))/(2.*grid_level*dx));\n    \n    //\"Navier-Stokes\"\n    return  middle.xy + dt*(viscosity*laplacian + nonlin_strength*convect + 1.0/epsilon*gradDiv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){  \n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    if(distance(iMouse.xy,fragCoord)<circle_radius){\n        fragColor.xy = mouse_speed;\n        fragColor.z = 1.0;\n        \n\n    }\n    else if(uv.x < .005){\n        if(uv.y > .62 && uv.y < .7){\n            fragColor.xy = vec2(1.0,0.);\n        }\n        else{\n            fragColor.xy = vec2(0.0,0.);\n        }\n    }\n    else if(uv.y > .99){\n        if(uv.x > .3 && uv.x < .36){\n            fragColor.xy = vec2(0.0,1.);\n        }\n        else{\n            fragColor.xy = vec2(0.0,0.);\n        }\n    }\n    else{\n        fragColor.xy = euler(iChannel0,fragCoord);\n        //fragColor.xy = euler(iChannel1,fragCoord);\n\n    }\n    \n    //Apply a directional do nothing condition at bottom and right outflows.\n    if(uv.y <.01)\n        fragColor.y = max(0.,fragColor.y);\n    else if(uv.x >.995)\n        fragColor.x = max(0.,fragColor.x);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec4 getT(sampler2D g, vec2 p){\n    return texture(g,p/iResolution.xy);\n\n}\n\nvec2 euler(sampler2D g, vec2 p){\n    vec2 middle    = getT(g,p).xy;   \t\n    vec2 up        = getT(g,p+vec2( 0, int(grid_level))).xy;\n    vec2 down      = getT(g,p+vec2( 0,-int(grid_level))).xy;\n    vec2 right     = getT(g,p+vec2( int(grid_level), 0)).xy;\n    vec2 left      = getT(g,p+vec2(-int(grid_level), 0)).xy;\n    vec2 upright   = getT(g,p+vec2( int(grid_level), int(grid_level))).xy;\t\n    vec2 upleft    = getT(g,p+vec2(-int(grid_level), int(grid_level))).xy;\n    vec2 downright = getT(g,p+vec2( int(grid_level),-int(grid_level))).xy;\n    vec2 downleft  = getT(g,p+vec2(-int(grid_level),-int(grid_level))).xy;\n\t\n    vec2 gradDiv\\\n   \t= vec2((0.25*(upleft.y + up.y)  - 0.25*(downleft.y + down.y)   + left.x   -middle.x\\\n                -(0.25*(upright.y + up.y) - 0.25*(downright.y+ down.y)  + middle.x     -right.x))/(pow(grid_level,2.)*dx*dx),\\\n                (up.y    - middle.y     + 0.25*(upleft.x + left.x)     -0.25*(upright.x + right.x)\\\n                -(middle.y  - down.y   + 0.25*(downleft.x + left.x)   -0.25*(downright.x+right.x)))/(pow(grid_level,2.)*dx*dx));\n    \n    //laplacian(u) = div(grad(u))\n    //Gijs ninepoint stensil.\n    vec2 laplacian\\\n    = (-8.*middle + up + left + right + down + upright + upleft + downright + downleft)/(3.*pow(grid_level,2.)*dx*dx);  \n    \n    //(uxdx + uydy)ux, (uxdx + uydy)uy\n    vec2 convect\\\n   \t= vec2((middle.x*(left.x - right.x) + middle.y*(up.x - down.x))/(2.*grid_level*dx),\\\n               (middle.x*(left.y - right.y) + middle.y*(up.y - down.y))/(2.*grid_level*dx));\n    \n    //\"Navier-Stokes\"\n    return  middle.xy + dt*(viscosity*laplacian + nonlin_strength*convect + 1.0/epsilon*gradDiv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){  \n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    if(distance(iMouse.xy,fragCoord)<circle_radius){\n        fragColor.xy = mouse_speed;\n        fragColor.z = 1.0;\n        \n\n    }\n    else if(uv.x < .005){\n        if(uv.y > .62 && uv.y < .7){\n            fragColor.xy = vec2(1.0,0.);\n        }\n        else{\n            fragColor.xy = vec2(0.0,0.);\n        }\n    }\n    else if(uv.y > .99){\n        if(uv.x > .3 && uv.x < .36){\n            fragColor.xy = vec2(0.0,1.);\n        }\n        else{\n            fragColor.xy = vec2(0.0,0.);\n        }\n    }\n    else{\n        fragColor.xy = euler(iChannel0,fragCoord);\n        //fragColor.xy = euler(iChannel1,fragCoord);\n\n    }\n    \n    //Apply a directional do nothing condition at bottom and right outflows.\n    if(uv.y <.01)\n        fragColor.y = max(0.,fragColor.y);\n    else if(uv.x >.995)\n        fragColor.x = max(0.,fragColor.x);\n}","name":"Buffer D","description":"","type":"buffer"}]}