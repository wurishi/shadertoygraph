{"ver":"0.1","info":{"id":"csXXRj","date":"1669167646","viewed":366,"name":"Multiple scattering: GGX","username":"LVutner","description":"Top - 64 scattering orders.\nBottom - 1 scattering order.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["importancesampling","ibl","pbr","ggx","multiplescattering","ms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    GGX VNDF - Multiple scattering using random walk algorithm\n\n    Author:\n        @LVutner\n\n    Credits: \n        @Stubman - Raycast logic\n        @selfshadow - GGX heightfield function\n\n    Info:\n        Very simple example of multiple scattered GGX material.\n        Based on \"Multiple-Scattering Microfacet BSDFs with the Smith Model\"\n\n    References:\n        [R. Cook & K. Torrance, 1982] \"A Reflectance Model for Computer Graphics\"\n        [B. Walter et al, 2007] \"Microfacet Models for Refraction through Rough Surfaces\"\n        [E. Heitz, 2014] \"Understanding the Masking-Shadowing Function in Microfacet-based BRDFs\"  \n        [E. Heitz, 2018] \"Sampling the GGX Distribution of Visible Normals\"\n        [E. Heitz & J. Dupuy, 2015] \"Implementing a Simple Anisotropic Rough Diffuse Material with Stochastic Evaluation\"\n        [E. Heitz, 2016] \"Multiple-Scattering Microfacet BSDFs with the Smith Model\"\n        [J. Dupuy & A. Benyoub, 2023] \"Sampling Visible GGX Normals with Spherical Caps\"\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Sample scene color\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n\n    //Apply exposure\n    color *= 2.0;\n\n    //Tonemapping\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n\n    //Transform from linear to sRGB\n    color = fromLinear(color);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    GGX VNDF - Multiple scattering using random walk algorithm\n\n    Author:\n        @LVutner\n\n    Credits: \n        @Stubman - Raycast logic\n        @selfshadow - GGX heightfield function\n\n    Info:\n        Very simple example of multiple scattered GGX material.\n        Based on \"Multiple-Scattering Microfacet BSDFs with the Smith Model\"\n\n    References:\n        [R. Cook & K. Torrance, 1982] \"A Reflectance Model for Computer Graphics\"\n        [B. Walter et al, 2007] \"Microfacet Models for Refraction through Rough Surfaces\"\n        [E. Heitz, 2014] \"Understanding the Masking-Shadowing Function in Microfacet-based BRDFs\"  \n        [E. Heitz, 2018] \"Sampling the GGX Distribution of Visible Normals\"\n        [E. Heitz & J. Dupuy, 2015] \"Implementing a Simple Anisotropic Rough Diffuse Material with Stochastic Evaluation\"\n        [E. Heitz, 2016] \"Multiple-Scattering Microfacet BSDFs with the Smith Model\"\n        [J. Dupuy & A. Benyoub, 2023] \"Sampling Visible GGX Normals with Spherical Caps\"\n*/\n\n//Traces the scene [thx Stubman]\nHitInfo TraceRay(RayDesc ray)\n{\n    HitInfo sphere_hit; \n    {\n        //Set up materials\n        vec3 albedo = vec3(1.0, 0.7, 0.3);\n        float roughness = gl_FragCoord.x < 0.5 * iResolution.x ? 0.25 : 1.0;\n\n        //Create materials\n        Material sphere_material = remap_materials(albedo, roughness);\n            \n        //Ray cast\n        ray_sphere_intersection(ray, vec4(0.0, 2.0, 2.0, 1.0), sphere_material, sphere_hit);\n    }\n    return sphere_hit;\n}   \n\n\n//Phase function\n//Simple diffuse+specular material\nvec3 vndf_phase_function(vec3 V_tangent, HitInfo ray, inout vec3 throughput) \n{\n    //Sample VNDF\n    vec3 H_tangent = sample_ggx_vndf(V_tangent, RandNext2F(), ray.material.alpha);\n\n    //VdotH\n    float VdotH = clamp(dot(V_tangent, H_tangent), 0.0, 1.0);\n\n    //Sample fresnel (F0 = 0.04)\n    float fresnel = F_SphericalGaussian(VdotH, 0.04);\n\n    //Calculate specular bounce probability\n    float fresnel_luma = dot(fresnel, 0.33);\n    float albedo_luma = dot(ray.material.albedo, vec3(0.33));\n    float total_luma = albedo_luma * (1.0 - fresnel_luma) + fresnel_luma;\n    float specular_probablility = fresnel_luma / total_luma;\n\n    if(specular_probablility > RandNextF()) \n    {\n        //Calculate new ray direction\n        vec3 L = reflect(-V_tangent, H_tangent);\n\n        //Update throughput\n        throughput /= specular_probablility; //Probablity\n        throughput *= fresnel; //Fresnel\n\n        //Output new direction\n        return L;\n    } \n    else \n    {\n        //Calculate new ray direction (microfacet oriented cosine hemisphere)\n        vec3 L = sample_cosine_hemisphere(H_tangent, RandNext2F());\n\n        //Update throughput\n        throughput /= 1.0 - specular_probablility; //Probablity\n        throughput *= ray.material.albedo; //Albedo      \n        throughput *= 1.0 - fresnel; //Fresnel (I know it's not \"that\" simple, feel free to improve it in your project.)\n\n        //Output new direction\n        return L;\n    }\n}\n\n//Importance sample phase function using random walk algorithm\nvec3 ggx_random_walk(vec3 wi, HitInfo ray, inout vec3 throughput) \n{\n    //Scattering orders\n    int MS_ORDER = gl_FragCoord.y > 0.5 * iResolution.y ? 32 : 1;\n    \n    //Initialize\n    vec3 wr = -wi; //Direction\n    float hr = 0.0; //Heightfield\n    int i = 0; //Iteration count\n    \n    while(i <= MS_ORDER)\n    {\n        //Sample GGX microsurface\n        hr = sample_ggx_height(RandNextF(), wr, hr, ray.material.alpha);\n\n        //Did we left the microsurface?\n        if(hr > 0.0)\n            break;\n        else\n            i++;\n            \n        //Sample phase function with new direction and update throughput\n        wr = vndf_phase_function(-wr, ray, throughput);\n\n        //NaN fixer no.1\n        if(hr != hr || wr.z != wr.z)\n            return vec3(0.0, 0.0, 1.0);  \n    }\n\n    //NaN fixer no.2. \n    //Just to be 200% sure we don't get any NaNs\n    throughput = i > MS_ORDER ? vec3(0.0) : max(throughput, 0.0);\n\n    //Output new direction\n    return wr;\n}\n\n\n//Returns shiny ball :P\nvec3 ggx_vndf_smith_ms(vec3 N, vec3 V, HitInfo ray)\n{\n    //Othronormal basis\n    mat3 TBN;  \n    TBN[0] = normalize(V - N * dot(N, V));\n    TBN[1] = cross(N, TBN[0]); \n    TBN[2] = N;\n    \n    //Rotate (world) view direction to tangent space\n    vec3 V_tangent = V * TBN;\n\n    //Accumulator\n    vec3 lighting = vec3(0.0);\n\n    for(int i = 0; i < IS_SAMPLE_COUNT; i++)\n    {\n        //Get sample direction and throughput\n        vec3 throughput = vec3(1.0);\n        vec3 L_tangent = ggx_random_walk(V_tangent, ray, throughput);\n\n        //Rotate L_tangent to world space\n        vec3 L = TBN[0].xyz * L_tangent.x + (TBN[1].xyz * L_tangent.y + (TBN[2].xyz * L_tangent.z));\n\n        //Sample cubemap with new direction\n        vec3 sampled_cube = toLinear(textureLod(iChannel1, L, 0.0).xyz);\n\n        //Accumulate the samples\n        lighting += sampled_cube * throughput;\n          \n    }\n    lighting /= float(IS_SAMPLE_COUNT);\n\n    //Output\n    return lighting;\n}\n\n\n//Scene rendering\nvec3 get_scene_color(vec2 frag)\n{\n    //Clip space position\n    vec2 p = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.x;\n    \n    //Jitter the position for anti-alias effect\n    p += RandNext2F() * (2.0 / iResolution.xy);\n\n    //Camera origin\n    vec3 camera_origin = vec3(0.0, 2.0, -1.0);\n    \n    //Camera direction\n    vec3 camera_direction = normalize(vec3(p, 1.0));\n\n    //Primary ray data\n    RayDesc primaryRay;\n    primaryRay.Origin = camera_origin;\n    primaryRay.Direction = camera_direction;\n    primaryRay.TMin = 0.0;\n    primaryRay.TMax = MAX_DISTANCE;\n\n    //Shoot primary ray\n    HitInfo rayHit = TraceRay(primaryRay);\n    bool hit = rayHit.dist > 0.0;\n\n    //Background\n    vec3 color = toLinear(textureLod(iChannel1, primaryRay.Direction, 0.0).xyz);\n\n    //If we hit something, let's calculate all stuff\n    if(hit) \n    {\n        //Vectors\n        vec3 N = rayHit.normal;\n        vec3 V = -normalize(primaryRay.Direction);\n\n        //Final lighting\n        color = ggx_vndf_smith_ms(N, V, rayHit);\n    }\n    return color;\n}\n\n//Render everything\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    //Initialize RNG\n    InitRand(uint(fragCoord.x) + uint(iResolution.x) * (uint(fragCoord.y) + uint(iResolution.y) * uint(iFrame)));\n\n    //Sample the scene\n    vec3 color = get_scene_color(fragCoord);\n\n    //Previous frame\n    vec3 color_prev = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n\n    //Blend\n    color = mix(color_prev, color, 1.0 / float(iFrame + 1));\n\n    //Output to framebuffer\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    GGX VNDF - Multiple scattering using random walk algorithm\n\n    Author:\n        @LVutner\n\n    Credits: \n        @Stubman - Raycast logic\n        @selfshadow - GGX heightfield function\n\n    Info:\n        Very simple example of multiple scattered GGX material.\n        Based on \"Multiple-Scattering Microfacet BSDFs with the Smith Model\"\n\n    References:\n        [R. Cook & K. Torrance, 1982] \"A Reflectance Model for Computer Graphics\"\n        [B. Walter et al, 2007] \"Microfacet Models for Refraction through Rough Surfaces\"\n        [E. Heitz, 2014] \"Understanding the Masking-Shadowing Function in Microfacet-based BRDFs\"  \n        [E. Heitz, 2018] \"Sampling the GGX Distribution of Visible Normals\"\n        [E. Heitz & J. Dupuy, 2015] \"Implementing a Simple Anisotropic Rough Diffuse Material with Stochastic Evaluation\"\n        [E. Heitz, 2016] \"Multiple-Scattering Microfacet BSDFs with the Smith Model\"\n        [J. Dupuy & A. Benyoub, 2023] \"Sampling Visible GGX Normals with Spherical Caps\"\n*/\n\n//////////////////////////////////////////////////////////////////////////////\n//Settings\n//////////////////////////////////////////////////////////////////////////////\n\n//Quality settings\n#define IS_SAMPLE_COUNT 8 //Sample count\n\n//Raycast settings\n#define MAX_DISTANCE 200.0 //Max distance of primary ray\n\n//Hardcoded values\n#define PI float(3.141592)\n\n//////////////////////////////////////////////////////////////////////////////\n//BRDF UTILS\n//////////////////////////////////////////////////////////////////////////////\n\n//Fresnel approximation using spherical gaussians\nfloat F_SphericalGaussian(float dotproduct, float F0)\n{\n    return F0 + (1.0 - F0) * exp2((-5.55473 * dotproduct - 6.98316) * dotproduct);\n}\n\n//GGX heightfield\nfloat sample_ggx_height(float Xi, vec3 direction, float height, float alpha)\n{\n    float direction_length = length(vec3(direction.xy * alpha, 1.0));\n    float delta = -log(1.0f - Xi) * direction.z / max(0.5 * (direction_length - direction.z), 1e-6);\n\n    return height + delta;\n}\n\n//Returns microfacet visible normal with GGX distribution\nvec3 sample_ggx_vndf(vec3 V_tangent, vec2 Xi, float alpha)\n{\n\t//stretch the view direction\n    vec3 V_tangent_stretched = normalize(vec3(V_tangent.xy * alpha, V_tangent.z));\n\n\t//sample a spherical cap in (-wi.z, 1]\n    float phi = PI * 2.0 * Xi.x;\n    \n\tvec3 hemisphere = vec3(cos(phi), sin(phi), 0.0);\n\n\t//normalize (z)\n\themisphere.z = (1.0 - Xi.y) * (1.0 + V_tangent_stretched.z) + -V_tangent_stretched.z;\t\n\n\t//normalize (hemi * sin theta)\n\themisphere.xy *= sqrt(clamp(1.0 - hemisphere.z * hemisphere.z, 0.0, 1.0));\n\n\t//halfway direction\n\themisphere += V_tangent_stretched;\n\n\t//unstretch and normalize\n\treturn normalize(vec3(hemisphere.xy * alpha, hemisphere.z));\n}\n\n//Returns cosine weighted hemisphere oriented on N\nvec3 sample_cosine_hemisphere(vec3 N, vec2 Xi)\n{\n    float phi = 2.0 * PI * Xi.x;\n    Xi.y = Xi.y * 2.0 - 1.0;\n\n    vec3 sphere = vec3(0.0);\n\tsphere.x = cos(phi) * sqrt(1.0 - Xi.y * Xi.y);\n\tsphere.y = sin(phi) * sqrt(1.0 - Xi.y * Xi.y);\n\tsphere.z = Xi.y;\n \n    return normalize(N + sphere);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//IMAGE\n//////////////////////////////////////////////////////////////////////////////\n\n//sRGB to linear\nvec3 toLinear(vec3 sRGB)\n{\n    bvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n    vec3 higher = pow((sRGB + vec3(0.055)) / vec3(1.055), vec3(2.4));\n    vec3 lower = sRGB / vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\n//Linear to sRGB\nvec3 fromLinear(vec3 linearRGB)\n{\n    bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n    vec3 higher = vec3(1.055) * pow(linearRGB, vec3(1.0 / 2.4)) - vec3(0.055);\n    vec3 lower = linearRGB * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) \n{\n    vec3 a = v * (v + 0.0245786);\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//RAYCAST\n//////////////////////////////////////////////////////////////////////////////\n\n\nstruct RayDesc\n{\n    vec3 Origin; //Ray origin\n    vec3 Direction; //Ray direction\n    float TMin; //Minimal distance\n    float TMax; //Max distance\n};\n\nstruct Material\n{\n    vec3 albedo; //Albedo\n    float alpha; //GGX alpha\n};\n\nstruct HitInfo\n{\n    vec3 position; //Position\n    vec3 normal; //Normal\n    float dist; //Traveled distance    \n    Material material; //Materials\n};\n\n\nvoid ray_sphere_intersection(RayDesc ray, vec4 sphere, Material mat, inout HitInfo hit)\n{\n    //from iq...\n\tvec3 position = ray.Origin - sphere.xyz;\n\tfloat b = dot(position, ray.Direction);\n\tfloat c = dot(position, position) - sphere.w * sphere.w;\n\tfloat h = b * b - c;\n\n    float dist = h < 0.0 ? -1.0 : -b - sqrt(h);\n\n    if(dist > 0.0)\n    {\n        hit.dist = dist;\n        hit.position = ray.Origin + ray.Direction * hit.dist;\n        hit.normal = (hit.position - sphere.xyz) / sphere.w;\n        hit.material = mat;\n    }\n    else\n        hit.dist = -1.0;\n}\n\n\n//Creates materials for metallic-roughness workflow\nMaterial remap_materials(vec3 albedo, float roughness)\n{\n    Material o;\n\n    o.albedo = albedo;\n\n    //GGX alpha  \n    o.alpha = clamp(roughness * roughness, 1.0 / 255.0, 1.0);\n\n    //Output\n    return o;\n}\n\nHitInfo overrideHit(HitInfo a, HitInfo b) \n{ \n    if (a.dist < b.dist) \n        return a; \n    else \n        return b; \n}\n\n////////////////////////////////////////////////\n//RNG\n////////////////////////////////////////////////\n\nuint triple32(uint x) \n{\n\t// https://nullprogram.com/blog/2018/07/31/\n\tx ^= x >> 17;\n\tx *= 0xed5ad4bbu;\n\tx ^= x >> 11;\n\tx *= 0xac4c1b51u;\n\tx ^= x >> 15;\n\tx *= 0x31848babu;\n\tx ^= x >> 14;\n\treturn x;\n}\n\nuint randState;\n\nvoid InitRand(uint seed) \n{ \n    randState = triple32(seed); \n}\n\nuint RandNext() \n{ \n    return randState = triple32(randState); \n}\n\n#define RandNextF() (float(RandNext()) / float(0xffffffffu))\n#define RandNext2() uvec2(RandNext(), RandNext())\n#define RandNext2F() (vec2(RandNext2()) / float(0xffffffffu))","name":"Common","description":"","type":"common"}]}