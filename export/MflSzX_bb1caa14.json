{"ver":"0.1","info":{"id":"MflSzX","date":"1705617635","viewed":38,"name":"Sphere texturizing | fixed 1.0","username":"ASMcoder","description":"In general, this is simply texturing the sphere relative to the point that is considered the pole of the texture (from where it is superimposed, you can imagine superimposing the texture of the earth).\nhttps://www.desmos.com/3d/664746b06a","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["math","learning"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nvec4 SphereTexture(vec2 coord){\n    return vec4((sin(coord.x*150.0) > 0.5 ? 1.0 : 0.0) + (sin(coord.y*150.0) > 0.5 ? 1.0 : 0.0), 0.0, 0.0, 1.0);\n}\n\n\nvec3 vectorToSphere(vec2 uv, float distanceToCenter ){\n    vec2 toPixelProject = vec2(uv.x-0.5, uv.y-0.5);\n    float zDistance = sqrt(pow(distanceToCenter,2.0) - (pow(toPixelProject.x,2.0)+pow(toPixelProject.y, 2.0)));\n    return vec3(toPixelProject.x, toPixelProject.y, zDistance+0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float distanceToCenter = .5;\n    if( sqrt(pow(uv.x - 0.5, 2.0) + pow(uv.y-0.5, 2.0)) > distanceToCenter ){\n        fragColor = vec4(0.0, 0.0, 0.0, 1);\n        return;\n    }\n    \n    \n    \n    vec3 upAxis = vec3(0.0, -distanceToCenter, 0.0);\n    vec3 pixelPoint = vectorToSphere(uv, distanceToCenter);\n    vec3 polarPoint = vec3(sin(iTime/7.0)*0.5, 0.0, cos(iTime/7.0)*0.5);\n    \n    // I have made mistake, so its fix witout looking on epressions\n    vec3 swap = pixelPoint;\n    pixelPoint = polarPoint;\n    polarPoint  = swap;\n    \n    vec3 toPolar = polarPoint - pixelPoint;\n    vec3 toPixel = normalize(pixelPoint); // defined just for\n    float angleA = acos(dot(toPolar, -toPixel)/(length(toPolar)*length(toPixel)));\n    float angleB = radians(90.0) - angleA;\n    float projectDistance = sin(angleB)*length(toPolar);\n    vec3 projectedPolarPoint = polarPoint + normalize(toPixel)*projectDistance;\n    vec3 projectedToPolar = (projectedPolarPoint - pixelPoint);\n    vec3 product1 = cross(upAxis, toPixel);\n    vec3 product2 = cross(toPixel, product1);\n    float angleG = acos(dot(product1, projectedToPolar)/(length(product1)*length(projectedToPolar)));\n    float angleSign = dot(product2, projectedToPolar) > 0.0 ? 1.0 : -1.0; \n    float turnSign = length(toPolar) > sqrt(length(toPixel)*length(toPixel) + length(toPixel)*length(toPixel)) ? 1.0 : -1.0; \n    \n    float polarAngle = ((angleG * angleSign) + M_PI) / (2.0*M_PI) + (iTime/30.0*turnSign);\n    float polarDistance = acos(dot(pixelPoint, polarPoint)/(length(pixelPoint)*length(polarPoint)))*distanceToCenter;\n    //fragColor = SphereTexture(vec2(polarAngle, polarDistance));\n    fragColor = texture(iChannel0, vec2(polarAngle, polarDistance));\n}\n\n\n","name":"Image","description":"","type":"image"}]}