{"ver":"0.1","info":{"id":"msdGRj","date":"1677553980","viewed":137,"name":"Elliptic Mobius Transform","username":"Borthralla","description":"Elliptic Mobius Transform with focus points at -1 and 1\nOn the reimann sphere, think of slicing the sphere into circles from the west to the east.\nThe vertical line goes through north/south pole\nThe focus points are the western/eastern poles of the globe.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["checkerboard","mobius","transform"],"hasliked":0,"parentid":"Ddd3z2","parentname":"Parabolic Mobius Transform"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\nvec2 cMul(in vec2 z1, in vec2 z2) {\n    return  mat2(z1,-z1.y,z1.x) * z2;\n}\n\nvec2 cDiv(in vec2 z1, in vec2 z2) {\n    return z1 * mat2(z2,-z2.y,z2.x) / dot(z2,z2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = 12. * (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y);\n    vec2 unit = vec2(1., 0.);\n    p = cDiv(p + unit, p - unit); // 2 fixed points, loxodromic\n    //p = cDiv(unit, p); // 1 fixed point, parabolic\n    \n    // Use these for elliptic/hyperbolic/loxodromic transforms depending on where itime is\n    // itime on both means loxodromic\n    // just on theta is elliptic\n    // just on length is hyerbolic\n    float theta = atan(p.y, p.x);\n    float len = length(p);\n    float x_index = sin( PI* ( theta * 12. / PI - iTime ));\n    float y_index = sin( PI* ( log(len) * 4.  ));\n   \n    // Use these for parabolic mobious transformations\n    //float x_index = sin( PI* ( p.x * 10. + iTime ));\n    //float y_index = sin( PI* ( p.y * 10.  ));\n    \n    float v = x_index*y_index;\n    \n    \n    //Thank you to Fabrice for the anti anliasing tip\n    fragColor = vec4( .5 + v/fwidth(v) );\n}","name":"Image","description":"","type":"image"}]}