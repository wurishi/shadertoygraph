{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":" #define MAX_ITERATIONS 140\n \n\n\t// rotations from euler angles\n    mat4 fromEuler(vec3 ang) {\n        vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n        vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n        vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n        mat4 m;\n        m[0] = vec4(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x,0.0);\n        m[1] = vec4(-a2.y*a1.x,a1.y*a2.y,a2.x,0.0);\n        m[2] = vec4(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y,0.0);\n        m[3] = vec4(0.0,0.0,0.0,1.0);\n        return m;\n    }           \n\n    // rotate (operate) vec3 from mat4\n    vec3 rotate(vec3 v, mat4 m) {\n       return vec3(dot(v,m[0].xyz),dot(v,m[1].xyz),dot(v,m[2].xyz));\n    } \n\n    // p: point\n    // Distance function (some objects)\n    vec3 map( in vec3 p ) {\n        float sr = 1.0;  // sphere radius\n        vec3 box = vec3(3.5,1.7,0.3);\n        float rbox = 0.1;\n        float id = 1.0;  // 3 = floor, 2 wall, 1 sphere\n\n        // Sphere\n        float distS = length(p + vec3( sin(iTime * 0.21) * 3.0,0.3,cos(iTime * 0.21) * 3.0))-sr;\n        \n        // First wall\n        float distQ = length(max(abs(p)-box,0.0))-rbox;\n        // Cuboid moved 2.0 to the right (2on wall)\n        float distQ2 = length(max(abs(p + vec3(-2.0,.0,2.0)) - vec3(0.3,1.7,3.5), 0.0))-rbox;\n\n        // Window in the wall\n        vec3 d = abs(p) - vec3(0.5,0.8,1.0);\n        float distQ3 = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\n        // External wall (parcel limit) without ceiling\n        vec3 d2 = vec3(10.0,2.0,10.0) - abs(p);\n        float distQ4 = max( min( d2.x,  d2.z ), -d2.y );\n\n        // Column\n        float distCol = length(max(abs(p + vec3(2.5,.0,4.5)) - vec3(0.3,1.7,0.3), 0.0))-rbox;\n\n\n        float distTot = min( min( distS, distQ), distQ2 );\n        distTot = max( -distQ3,distTot );\n        distTot = min( distCol,distTot );\n        distTot = min( distTot, distQ4 );\n\n        if (distS > distTot) {\n            id = 2.0;\n        }\n\n        float distP = p.y + 1.6;\n\n        if (distP < distTot) {\n            id = 3.0;\n        }\n\n        distTot = min(distP, distTot);\n\n        return vec3(distTot, id, 0.0 );\n    }\n\n\n\t// texture\n    float fbm( vec3 p, vec3 n )\n    {\n        return texture( iChannel0, (p.xy + p.zy) / 4.0).x;\n    }\n\n\t// bump mapping\n    vec3 doBumpMap( in vec3 pos, in vec3 nor )\n    {\n        float e = 0.0015;\n        float b = 0.1;\n        \n        float ref = fbm( pos, nor );\n        vec3 gra = b*vec3( fbm( vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                            fbm( vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                            fbm( vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;\n        \n        vec3 tgrad = gra - nor * dot ( nor , gra );\n        return normalize ( nor - tgrad );\n    }\n\n\n    // p: point to calculate gradient\n\t// id: object id\n    // Calculate normal by gradient\n    vec3 calcNormal( in vec3 p, in float id ) {\n        vec3 eps = vec3(0.002,0.0,0.0);\n\n        vec3 nor = normalize( vec3(\n            map( p + eps.xyy).x - map(p - eps.xyy).x,\n            map( p + eps.yxy).x - map(p - eps.yxy).x,\n            map( p + eps.yyx).x - map(p - eps.yyx).x));\n\n        if (id == 2.0) {\n            return doBumpMap(p,nor);\n        }\n\n        return nor;\n    }\n\n\n    // shadow\n    // ro: ray origin\n    // rd: ray destination\n    float softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n    {\n        float res = 1.0;\n        float h = mint;\n        for( int i=0; i < 100; i++ )\n        {\n            ro += rd * h;\n            h = map(ro).x;\n            if( h<0.01 )\n                return 0.0;\n            res = min( res, k*h );\n            if (h > maxt)\n                break;\n        }\n\n        return res;\n    }\n\n\t// ambientOclussion\n    float ambientOclussion( in vec3 p, in vec3 n) {\n        float step = 0.1;\n        float res = 1.0;\n        vec4 vstep = vec4( n*step, step );\n        vec4 np = vec4(p,0.0) + vstep;\n        for (int i=0; i < 5; i++) {\n            res -= (np.w - map( np.xyz ).x) * 0.25;\n            np += vstep;\n        }\n\n        return max(res,0.0);\n    }\n\n    // p: point to colorize\n\t// id: object id of point\n    vec3 colorize( in vec3 p, in float id ) {\n        vec3 n = calcNormal( p, id);\n\n        // light pos2 (rotate)\n        vec3 lighto2 = vec3(800.0 * sin(iTime*0.04),1000.0,800.0 * cos(iTime * 0.04));\n        vec3 tolight2 = normalize(lighto2 - p);\n        vec3 colorLight2 = vec3(0.8,0.9,0.9);\n\n\n        // text col\n        float ambientOc = ambientOclussion( p, n );\n        vec3 direct2 = colorLight2 * 1.0 * max(dot(n,tolight2),0.0) / (ambientOc);// * ambientOc);\n\n        float shadow2 = softShadow(p, tolight2, 0.2, 50.0, 5.0) * ambientOc;\n\n        vec3 textureOut;\n        if (id == 2.0) {\n            highp vec3 v3 = vec3(.4,.4,.4);\n            textureOut =  max( texture(iChannel0, (p.xy + p.zy) / 4.0 ).xyz, v3);\n        }\n        else if (id == 1.0)\n            textureOut = vec3(.2,.5,.6);\n        else\n            textureOut = vec3(.2,.5,.2);\n\n        vec3 ambient = vec3(.5,.5,.5);\n\n\n        return  (textureOut * ambient * ambientOc) + (textureOut * direct2 * shadow2);  // One light\n\n    }\n\n\n    // ro: ray origin\n    // rd: ray direction (normalizada)\n    vec3 rayMarch( in vec3 ro, in vec3 rd, out float idObj, out vec3 ptCol ) {\n\n        float dist = 0.0;\n        vec3 vdist;\n        vec3 np = ro;\n        for( int i = 0; i < MAX_ITERATIONS; i++ ) {\n            \n            vdist = map(np);\n            dist = vdist.x;\n            if (dist < 0.001)\n                break;\n            np += rd * dist;\n\n        }\n\n        idObj = vdist.y;\n        ptCol = np;\n\n        if (dist < 0.01) {\n            return colorize(np, vdist.y);\n        }\n\n        return vec3( 0.6, .6, 0.8);    \n\n    }\n\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        // Obtenemos xy de fragment y normalizamos (haciendo cuadrados los pÃ­xeles si hace falta)\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        vec2 p = -1.0 + 2.0 * uv;\n        p.x *= iResolution.x/iResolution.y;\n\n\n        // cam calculation (camo = origin, camd = destination/target)\n        vec3 camo = vec3( 9.0*sin( iTime * -0.2), 1.0, 9.0*cos(iTime*-0.2 ));//vec3(iCamX, iCamY, iCamZ);\n        vec3 camd = camo;\n        camd = normalize(camd);\n        vec3 up = vec3(0.0,1.0,0.0);\n        vec3 left = normalize(cross(camd, up));\n        camd = normalize( left*p.x + up*p.y - 2.0*camd );\n        \n        float idObj;\n        vec3 ptCol;\n        \n        vec4 color = vec4( rayMarch( camo, camd, idObj, ptCol ), 1 );\n\n        if (idObj == 3.0)  // agua\n                {\n            float lambda = 10.0;\n            float ptColx = ptCol.x - cos(ptCol.y );\n            float ptColz = ptCol.z - sin(ptCol.z );\n\n            vec3 normalFloor = normalize(vec3(  .02 * sin( ptColx * lambda * 0.5 + iTime * 7.1) + \n                                                .01 * sin( (ptColx + ptColz * 0.3) * lambda + iTime * 8.0) + \n                                                .005 * sin( (ptColx - ptColz * 0.9) * lambda*2.1 + iTime * 5.2),\n                1.0, \n                .02 * cos( ptColz * lambda * 0.5 + iTime * 7.6) + \n                .01 * cos( ptColz * lambda + iTime * 8.0) + \n                .005 * cos( ptColz * lambda *1.9 + iTime * 5.6)));\n            vec3 newcamd = normalize( reflect( camd, normalFloor ));\n            float dot = dot( newcamd, normalFloor );\n            float dot2 = sqrt(dot);\n            vec3 color3 = (1.0 - dot2) * rayMarch( vec3(ptCol.x, -1.51, ptCol.z), newcamd, idObj, ptCol) + dot2 * vec3(0.1,0.3,0.1);\n\n            color = vec4(color3,1.0);\n\n        }\n\n\t\t// Calculate and assign color\n        fragColor = color;\n\n    }\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsjXzV","date":"1414071296","viewed":420,"name":"SphereAndWalls","username":"capitanminero","description":"A little demo with ambient occlusion, soft shadows, bump mapping and texturing","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","softshadows","ambientocclusion"],"hasliked":0,"parentid":"","parentname":""}}