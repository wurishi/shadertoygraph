{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const float EPS = 0.001; // this defines \"close enough\", because raymarching doesn't actually hit\nconst int MAXI = 400;\t // how much work we are willing to do (speed vs. accuracy)\nconst float MAXD = 30.; // if we are this far away from everything, we are lost in the skies of eternity\n\n// OK NOW YOU SHOULD GO SCROLL DOWN TO MAIN AND FOLLOW THE FUNCTION CALLS FROM THERE OK\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec3 hsv(float h,float s,float v) { // this is just a hue/saturation/luminance to RGB conversion\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat scenedist(vec3 p){ // this defines what is actually in the scene\n\tfloat s1 = length(p)-1.; \t\t\t\t// this is just a sphere\n\tfloat s2 = length(p-vec3(.8, 0., 0.))-.5;\n\treturn min(s1,s2); // add them together (like boolean OR)\n    // min combines them because it will return the distance to the closest, the other is irrelevant right?\n\t// other fun mixes are max(s1,s2) (boolean AND) and max(s1,-s2) (volume subtraction)\n}\n\nvec3 getNormal(vec3 pos){ // this gets the normal\n\t/* So we're gonna check the distance field at little steps in each direction\n\t\tthe subtractions will give us the gradient in each direction\n\t\tso if distance goes up in a direction we get positive that way\n*/\n\tvec2 eps = vec2(0.0, EPS);\n\treturn normalize(vec3( // always normalise directions godammit\n\t\t\tscenedist(pos + eps.yxx) - scenedist(pos - eps.yxx),\n\t\t\tscenedist(pos + eps.xyx) - scenedist(pos - eps.xyx),\n\t\t\tscenedist(pos + eps.xxy) - scenedist(pos - eps.xxy)));\n}\n\nvec3 renderworld(vec2 uv){ // this is where we do everything\n\t\n\t// put the camera somewhere\n\t// sin and cos are useful for making circles, so we spin around\n\tvec3 camPos = normalize(vec3(2.*sin(iTime),2.*cos(iTime),1. + sin(iTime*.33)))*3.;\n\t// what to look at (the center for now)\n\tvec3 camTarg = vec3(0.);\n\t// which way is up? I like Z. This is world-relative for now.\n\tvec3 camUp = normalize(vec3(0.,0.,1.));\n\t\n\t// camera points to target from camera\n\t// remember that all directions must be normalised, or shit goes craycray\n\tvec3 camDir = normalize(camTarg - camPos);\n\t// right is perpendicular to up and forwards\n\tvec3 camRight = normalize(cross(camUp,camDir));\n\t// change UP to be relative to camera\n\tcamUp = normalize(cross(camDir,camRight));\n\t\n\t// This pixel will cast ray in the camera direction, but a bit up/down and sidewise\n\tvec3 rayDir = normalize(camDir+uv.x*camRight+uv.y*camUp);\n\t\n\t// the first distance we will jump - randomised slightly to reduce some banding effects\n\tfloat dist = scenedist(camPos) * rand(rayDir.xy);\n\t// must maintain the total or we will not know where we hit when we do\n\tfloat total = dist;\n\t\n\t// now we march along the ray a lot\n    int i;\n\tfor(i = 0;i<MAXI;i++){\n\t\tdist = scenedist(camPos+rayDir*total); // distance to closest thing (safe jump distance)\n\t\ttotal += dist;\t\t\t\t\t\t   // add it to our progress\n\t\tif(dist<EPS || dist>MAXD){break;}   // quit if we hit something or are lost\n\t}\n\tvec3 dest = camPos+rayDir*total; // this is where we ended up\n\tvec3 c;\t\t\t\t\t\t\t // this will be our pixel colour\n\tif(dist<EPS){\t\t\t\t\t // if we score a hit\n        // \"free\" ambient occlusion based on iteration count\n        float ao = 1.-float(i)/(float(MAXI)*.3);\n\t\tc = .5+.5*getNormal(dest);\n        c *= ao;\n\t}else{\t\t\t\t\t\t\t // no hit, we are lost in the sky\n\t\tc = hsv(.55,smoothstep(-1.5,1.,uv.y),1.); // make teh pretty blue skies\n\t}\n\t\t\n\treturn c; // give the colour back\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) // IS LIKE C(++), you start with the main\n{\n\t// uv is our screen position\n\t// remember this all runs per-pixel, so so this is how we know which we are!\n\tvec2 uv = (fragCoord.xy / iResolution.xy - 0.5) // -.5 to centre it (is now in range [-.5,.5])\n\t\t* vec2(2.0,2.0/(iResolution.x/iResolution.y)); //*2 to normalise x to [-1,1]\n\t\t\t\t\t\t\t\t\t\t\t//y adjusts aspect (typical widescreen is >1 in both directions\n\t\n\t// step 1: figure out where you are\n\t// step 2: do everything else\n\tvec3 c = renderworld(uv);\n\t\n\tfragColor = vec4(c,1.0);// make this pixel pretty colours\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MssXWM","date":"1402632982","viewed":453,"name":"Raymarch Tut Thingy","username":"squeakyneb","description":"simple newbie stuff that hopefully explains some shit in terms of actually implementing sphere-tracing/ray-marching\n\nupdated 2019 - after five years of mediocre raymarching code üòÅ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","example","simple","raymarched","tutorial","sample"],"hasliked":0,"parentid":"","parentname":""}}