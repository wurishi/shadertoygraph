{"ver":"0.1","info":{"id":"flf3W7","date":"1622169416","viewed":272,"name":"BlackHole By Sam K","username":"samk9632","description":"black hole test shader","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rotate(vec3 pos, vec2 rotation) {\n    vec2 m4 = vec2(length(pos.xz), length(pos.xyz));\n\n    vec2 angle = vec2(acos(pos.x/m4.x), asin(pos.z/m4.y));\n    float xx = pos.x*cos(rotation.y)+pos.z*sin(rotation.y);\n    float yy = pos.y;\n    float zz = -pos.x*sin(rotation.y)+pos.z*cos(rotation.y);\n    return vec3(xx, yy, zz);\n}\nfloat intersectionTest(vec3 o, vec3 n, float rIn, float rOut) {\n    float m1 = length(o);\n    float m2 = length(n);\n    float m3 = o.z/(o.z-n.z)*m2+(1.0-o.z/(o.z-n.z))*m1;\n    float m5 = 1.0;\n    if (o.z <= 0.0 && n.z > 0.0) {\n        if (m3 <= rOut && m3 >= rIn) {\n            m5 = 1.0;\n        } else {\n            m5 = 0.0;\n        }\n    } else if (o.z >= 0.0 && n.z < 0.0) {\n        if (m3 <= rOut && m3 >= rIn) {\n            m5 = 1.0;\n        } else {\n            m5 = 0.0;\n        }\n    } else {\n        m5 = 0.0;\n    }\n    return m5;\n}\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fractalNoise(vec2 UV, float iterations, float dimension, float scale, float scaleRel) {\nfloat val = 0.0;\n    for (float j = 1.0; j < pow(scaleRel, iterations); j*=scaleRel) {\n        val+=-0.0+noise(scale*j*UV.xy)/(1.0 + dimension);\n    }\n    return val;\n}\nfloat lt(float a1, float a2) {\n    float output1 = (-abs(a1-a2)/(a1-a2)+1.0)/2.0;\n    return output1;\n}\nfloat gt(float a1, float a2) {\n    float output1 = (abs(a1-a2)/(a1-a2)+1.0)/2.0;\n    return output1;\n}\nvec4 rayMarch(float stepSize, vec3 pos, vec3 dir, float maxSteps, float warp, float horizon, float xx, float SRV, vec4 color) {\n    vec3 p = pos;\n    vec3 d = dir;\n    float ll = length(d);\n    vec3 pStorage = p;\n    float absorb = 0.0;\n    vec4 outs = vec4(0.0, 0.0, 0.0, 1.0);\n    float alpha = 0.0;\n    float di = 1.0;\n    for (float i = 0.0; i < maxSteps; i+=di) {\n        if (abs(p.z) > 0.2+stepSize*length(p) || length(p.xy) > 7.0) {\n        d -= warp*p/(length(p)-horizon)*stepSize*2.0;\n        d /= length(d)*ll/stepSize/length(p);\n            p += d*stepSize;\n            di = 1.0;\n        } else {\n        d -= warp*p/(length(p)-horizon)*stepSize*pow(SRV, 1.0)*2.0;\n        d /= length(d)*ll/stepSize/length(p);\n            p += d*stepSize*SRV;\n            di = SRV;\n        }\n        float rI = 1.0;\n        float rO = 3.0;\n        if (abs(p.z) < 0.5) {\n        vec2 UV = vec2(p.xy);\n        UV = vec2(UV.x*sin(xx)+UV.y*cos(xx), -UV.y*sin(xx)+UV.x*cos(xx));\n        UV = vec2(1.0*length(UV), abs(UV.y)/UV.y*acos(UV.x/length(UV)));\n        float localAbsorb = pow(0.5, 2.0/(rO-rI)*(length(p.xy)-rI))*10.0*length(p-pStorage)*gt(length(p.xy), rI)*lt(abs(p.z), 0.05*max(1.0+0.2*fractalNoise(UV, 16.0, 1.0, 1.0, 2.0), 0.0));\n        localAbsorb *= pow(2.0, min(length(p.xy-rI-0.5), 0.0));\n        absorb += localAbsorb*100.0;\n        vec4 emit = color*100.0*pow(0.5, 2.0/(rO-rI)*(length(p.xy)-rI))*length(p-pStorage)*gt(length(p.xy), rI)*lt(abs(p.z), 0.05*max(1.0+0.2*fractalNoise(UV, 16.0, 1.0, 1.0, 2.0), 0.0));\n        emit *= min(1.0-length(p.xy)+rI, 1.0)+fractalNoise(UV, 8.0, 0.0, 1.0, 2.0);\n        float fog = 10.0*pow(0.5, 2.0/(rO-rI)*(length(p.xy)-rI))*length(p-pStorage)*gt(length(p.xy), rI)*pow(max(0.0, 1.0-5.0*abs(p.z)), 3.0);\n        emit.x += pow(color.x, 0.7)*0.5*(fog)*max(0.5+1.0*fractalNoise(UV, 8.0, 1.0, 1.0, 2.0), 0.0)+0.2*fog;\n        emit.y += pow(color.y, 0.7)*0.5*(fog)*max(0.5+1.0*fractalNoise(UV, 8.0, 1.0, 1.0, 2.0), 0.0)+0.2*fog;\n        emit.z += pow(color.z, 0.7)*0.5*(fog)*max(0.5+1.0*fractalNoise(UV, 8.0, 1.0, 1.0, 2.0), 0.0)+0.2*fog;\n        absorb += 1.0*fog;\n        emit *= lt(length(p.xy), 7.0);\n        emit = max(emit, 0.0);\n        outs += pow(0.8, absorb)*emit;\n        pStorage = p;\n        }\n    }\n    return outs;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy / iResolution.xy;\n    //camera distance\n    float r = 25.0;\n    //camera rotation sensitivity\n    float s = 10.0;\n    //depth of field\n    float dof = 1.0;\n    float mouseX = iMouse.x/iResolution.x-0.5;\n    float mouseY = (iMouse.y-0.5*iResolution.y)/iResolution.x;\n    float x = fragCoord.x/iResolution.x-0.5;\n    float y = (fragCoord.y-0.5*iResolution.y)/iResolution.x;\n    vec3 camPos = rotate(vec3(r, 0.0, 0.0), -vec2(0.0*mouseX, -s*mouseY));\n    \n    vec3 camDir = rotate(vec3(-1.0, dof*x, dof*y), vec2(0.0, s*mouseY));\n    fragColor = 2.0*rayMarch(0.25, camPos, camDir, 150.0, 0.01, 0.0, iTime*1.0-s*mouseX, 0.1, vec4(255.0, 0.75*207.0, 0.6*159.0, 255.0)/255.0);\n}","name":"Image","description":"","type":"image"}]}