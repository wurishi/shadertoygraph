{"ver":"0.1","info":{"id":"Xldyzj","date":"1533234259","viewed":95,"name":"Shiny Red Blobby","username":"TinyTexel","description":"shader","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \n// by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\n\ncamera controls via mouse + shift key\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi05= 2.0 / (1.0 * Pi);\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat lerp(float a, float b, float l) {return a + (b - a) * l;}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 CmplxMul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 CmplxMul(vec2 c0, float ang)\n{\n\tvec2 c1 = vec2(cos(ang), sin(ang));\n\n\treturn vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n    \nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n    \nfloat map(vec3 x);\n\nvec3 GradientCD(vec3 x, float o)\n{\n\tfloat xn = map(vec3(x.x - o, x.y, x.z));\n\tfloat xp = map(vec3(x.x + o, x.y, x.z));\n\t\n\tfloat yn = map(vec3(x.x, x.y - o, x.z));\n\tfloat yp = map(vec3(x.x, x.y + o, x.z));\n\t\n\tfloat zn = map(vec3(x.x, x.y, x.z - o));\n\tfloat zp = map(vec3(x.x, x.y, x.z + o));\n\t\n\tvec3 g = vec3(xp - xn, yp - yn, zp - zn) / o * 0.5;\n\t\n\treturn g;\n}\n\nvec3 GradientCD(vec3 x)\n{\n    return GradientCD(x, 0.0001);\n}\n\nvec3 GradientFD(vec3 x, float o)\n{\n\tx -= o * 0.5;\n\tfloat c = map(x);\n\t// c = 0.0;\n    \n\tfloat xp = map(vec3(x.x + o, x.y, x.z));\n\tfloat yp = map(vec3(x.x, x.y + o, x.z));\n\tfloat zp = map(vec3(x.x, x.y, x.z + o));\n\t\n\tvec3 g = vec3(xp - c, yp - c, zp - c) / o;\n\t\n\treturn g;\n}\n\nvec3 GradientFD(vec3 x)\n{\n    return GradientFD(x, 0.0001);\n}\n\n\nbool ImplicitRC(\nfloat funcScale,\nvec3 x, \nvec3 dir, \nfloat linCount,\nfloat binCount,\nfloat stepSizeAdd,\nout float t0, out float tm, out float t1)\n{\n\tbool hit = false;\n\n    t0 = tm = t1 = 0.0;\n    \n    float stepSize = abs(map(x)) + stepSizeAdd;\n    \n\tfor(float i = 0.0; i < linCount; ++i)// linear search\n\t{\t\n\t\tt1 += stepSize;\n\n        vec3 p = x + dir * t1;\n        \n        float f = map(p) * funcScale;\n        \n        stepSize = abs(f) + stepSizeAdd;\n        \n        hit = f < 0.0;\n\t\t\n        if(hit) {i=linCount;}\n        //if(hit) {break;}        \n        else {t0 = t1;}\n\t}\n\n    \n\tif(hit)\n    {\n        #if 1\n        for(float i = 0.0; i < binCount; ++i)// binary search\n\t\t{\n\t\t\ttm = (t0 + t1) * 0.5;\n\t\t\t\n            vec3 p = x + dir * tm;\n            \n\t\t\tif(map(p) * funcScale < 0.0)\n\t\t\tt1 = tm;\n\t\t\telse\n\t\t\tt0 = tm;\n\t\t}\n        \n        vec3 p0 = x + dir * t0;\n        vec3 p1 = x + dir * t1;\n        \n        float f0 = map(p0) * funcScale;\n        float f1 = map(p1) * funcScale;\n        \n        float div = f0 - f1;\n        \n        tm = mix(t0, t1, abs(div) > 1e-16 ? f0 / div : 0.5);// linear interpolation\n        #else\n        tm = (t0 + t1) * 0.5;\n        #endif\n        \n        return true;\n    }\n    else\n    return false;\n}\n\n// primitive normals\n// see: https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n#define a 0.5773502691896258\nconst vec3 PrimN3 = vec3( a, a, a);\nconst vec3 PrimN4 = vec3(-a, a, a);\nconst vec3 PrimN5 = vec3( a,-a, a);\nconst vec3 PrimN6 = vec3( a, a,-a);\n#undef a\n\nfloat map(vec3 x)\n{\n    float r = length(x) - 1.0;\n    //return r;\n    \n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    \n    #if 1\n    float t = iTime * 0.6;\n    t0 = t * 1.23;\n    t1 = t * 1.37;\n    t2 = t * 2.11;\n    x.xz = CmplxMul(x.xz, t * 0.21);\n    #endif\n    \n    float o = 1.0;\n    float s = 11.0;\n    o *= cos(x.x * s + t0);\n    o *= sin(x.z * s + t1);\n    o *= cos(x.y * s + t2);\n   \t// TODO: maybe tetrahedron axis instead?\n    // analytical derivatives?\n    o = o*0.5+0.5;\n    \n    o = 1.0 - rsqrt(rsqrt(1.0 - o * 0.95));\n    \n    r -= o * 0.2;\n    \n    return r;\n}\n\nvec3 HapkeBRDF(float mu, float mu0, vec3 a_ss)\n{\n    vec3 s = sqrt(1.0 - a_ss);        \n\n    return ((1.0 + 2.0 * mu    ) * (1.0 + 2.0 * mu0    )) / \n           ((1.0 + 2.0 * mu * s) * (1.0 + 2.0 * mu0 * s) * (mu + mu0)) * a_ss * RcpPi4;      \n}\n\nvec3 HapkeBRDF2(float mu, float mu0, vec3 s)\n{\n    vec3 a_ss = 1.0 - s*s;\n    \n    return ((1.0 + 2.0 * mu    ) * (1.0 + 2.0 * mu0    )) / \n           ((1.0 + 2.0 * mu * s) * (1.0 + 2.0 * mu0 * s) * (mu + mu0)) * a_ss * RcpPi4;      \n}\n\nfloat HapkeNonAbsBRDF(float mu, float mu0)\n{\n    float R = (mu * mu0 + 0.25) / (mu + mu0) * RcpPi + RcpPi2;\n\n    return R;// * 0.888;\n}\n\nfloat Cubic(float x) {return x*x*(3.0-2.0*x);}\n\nvec3 EvalSceneCol(\n    vec3 rp, Cam cam, vec2 uv0, bool right)\n{\n    vec3 col = vec3(1.0);\n    vec2 PixelCount = iResolution.xy;// * vec2(0.5, 1.0);\n    \n    vec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n        \n     \n    vec3 rd = NewRay(cam, tex21);\n\n    // TODO: ray-sphere intersection\n    \n    vec2 t; vec3 n; vec3 a;\n    float t0, tm, t1;\n    bool hit = ImplicitRC(1.0, rp, rd, 50.0, 5.0, 0.005, /*out*/ t0, tm, t1);\n\n    \n    vec3 ambient = mix(vec3(0.05, 0.4, 1.0), vec3(1.0), 0.1) * 0.025;\n    \n    col = ambient * Pi;\n    \n    if(!hit) return col;\n\n    \n    vec3 p = rp + rd * tm; \n\n    n = normalize(GradientCD(p));\n\n    vec3 L = vec3(0.0, 1.0, 0.0);\n    vec3 V = -rd;\n\n    float NdL = clamp01(dot(n, L));\n    float NdV = clamp01(dot(n, V));\n    float VdL =         dot(V, L) ;\n\n    float b0 = 0.2;\n    float a0 = 0.9;\n\n    /*\n\t\tassumed micro structure of the surface is that of a square wave:\n          _   _   _             /__white\n     \t_| |_| |_| |_ /__ red   \\        <- also white\n                      \\\n\t\t- the very bottom has a red albedo (bottomCol) while the rest is white (topCol) \n\t\t- shadow hiding is not considered, i.e. it is assumed that the shadows cast by the top structure on\n          the bottom is always fully visible to the observer\n          -> this makes the BRDF non-reciprocal and the resulting color for the bottom layer too dark\n             (but also heavily simplifies the calculations (probably; havnt actually derived it))\n        - no ao. backside- or self-shadowing for the top structure is computed (making it too bright)\n\t*/\n    \n    #if 1\n    float v = clamp01(a0 - sqrt(1.0 / (NdV*NdV) - 1.0) * b0);\n    float o = clamp01(a0 - sqrt(1.0 / (NdL*NdL) - 1.0) * b0);\n    float ao = 1.0 - b0/a0 * atan(a0/b0);//TODO: sitll misses fully shadowed amount\n    #elif 1\n    float v = clamp01(a0 - sqrt(1.0 / (NdV) - 1.0) * b0);\n    float o = clamp01(a0 - sqrt(1.0 / (NdL) - 1.0) * b0);\n    float ao = 0.7;\n    #else  \n    float v = clamp01(a0 - sqrt(-log2(NdV)) * b0);\n    float o = clamp01(a0 - sqrt(-log2(NdL)) * b0);\n    float ao = 0.7;\n    #endif\n\n    float shadow = o / a0;\n    \n    vec3 topCol = vec3(1.0);\n    vec3 bottomCol = vec3(0.99, 0.05, 0.01);\n\n    //bottomCol = vec3(1.0);\n    \n    //v = a;\n    //col = vec3(v * NdL + 0.0);\n    //col = (vec3(1.0) * ((1.0 - o) * (1.0 - v)) + vec3(1.0, 0.1, 0.01) * (o * v)) * NdL;\n    //col /= vec3(((1.0 - o) * (1.0 - v)) + (o * v));\n    col = mix(topCol * (1.0/Pi * NdL + ambient), bottomCol * (1.0/Pi * NdL * shadow + ao*ambient), v);// lacks shadow hiding -> not reciprocal + too dark   \n    //col = (topCol * (1.0 - v) * (1.0 - o) + bottomCol * v * o) * NdL / Pi + ambient; col *= 1.5;\n    //col /= vec3(mix(1.0, o, v));// normalization attempt -> poopy\n   \t#if 0\n    {\n    float u = NdL / Pi;\n    float o = NdL / (NdL + NdV) / Pi2;\n    float uo = mix(u, o, 0.5);\n    float up = u / uo;\n    float op = o / uo;\n        \n    col = vec3( u / o * 0.05);\n        float a = 0.4;\n        \n    col = vec3(mix(NdL, 1.0, NdL / (NdL + NdV) * a)) / (Pi * (1.0 + a));\n        vec3 fooCol = vec3(0.99, 0.1, 0.02);\n        //fooCol *= fooCol;\n    col = mix(NdL * fooCol, fooCol*fooCol, NdL / (NdL + NdV) * a) / (Pi * (1.0 + a)); \n        \n        float A = 0.0;\n        float B = 0.0;\n        float C = 1.0;\n        col = vec3(NdL * (A + B * NdL*NdV + C*(NdL+NdV)) / (NdL + NdV));\n        a = 0.4;\n        col = NdL * (mix(fooCol*(NdL+NdV), mix(fooCol, fooCol*fooCol, a), a) / (NdL + NdV)) / (Pi * (1.0 + a));\n        col = fooCol * NdL * (mix(NdL + NdV, 1.0, a) / (NdL + NdV)) / (Pi * (1.0 + a)); \n        //col *= mix(vec3(1.0), fooCol, a);\n        col = NdL * HapkeBRDF2(NdL, NdV, 1.0 - vec3(0.99, 0.4, 0.1));\n        //col = NdL * vec3(0.99, 0.2, 0.1) / Pi;\n        float n;\n        {\n            float A = Pi*a*(3.0-a);\n            \n            float c0 = 1.21358;\n            float c1 = -1.227411;\n            float B = c0 - Pi * a * (a + c1);\n            \n            n = max(A, B);\n        }\n        //col = vec3(1.0) * NdL * (a + (1.0-a)*NdL*NdV + a*(1.0-a)*(NdL + NdV)) / (NdL + NdV) / n;\n    \t//col = vec3(1.0) * NdL / Pi;\n        //col = vec3(1.0) * (1.0 - exp2(-1.0/Pow4(NdL + NdV)));\n        col = mix(vec3(1.0) * HapkeNonAbsBRDF(NdL, NdV) * NdL, col, exp2(-0.05/Cubic(Pow3((NdL + NdV)*0.5))));\n        col += ambient;// * vec3(0.99, 0.2, 0.05);\n    }\n    #endif\n    \n    #if 0\n    col = (col + mix(topCol * (1.0/Pi * NdL + ambient), bottomCol * (1.0/Pi * NdL * (v/a0) + ao*ambient), o)) * 0.5;// reciprocal but non-sense (probably)\n    #endif\n    \n    #if 0\n    col = vec3(1.0) * NdL / (NdL + NdV) * 0.389002;\n    col = vec3(1.0) * NdL / (sqrt(NdL) + sqrt(NdV)) * 0.496699;\n    col = vec3(1.0) * NdL * mix(1.0 / (NdL + NdV) * 0.389002, 1.0 / Pi, 0.4);\n    //col = vec3(1.0) * NdL / Pi;\n    #endif\n    \n    col *= Pi;\n\n    //col = (vec3(1.0) * ((1.0 - o) * (1.0 - v)) + vec3(1.0) * (o * v));// * NdL;\n    //col = mix(vec3(1.0), vec3(1.0, 0.1, 0.01), (o * v)) * NdL;\n    //col = mix(vec3(1.0, 0.1, 0.01), vec3(1.0), (1.0 - o) * (1.0 - v)) * NdL;\n    #if 0\n    col = (mix(bottomCol, topCol, (1.0 - o) * (1.0 - v)) + \n           mix(topCol, bottomCol, (o * v))) * 0.5 * NdL;// reciprocal but non-sense (probably)\n    #endif\n    \n    //float wu = (1.0 + NdV * log(NdV) - NdV * log(1.0 + NdV));\n    //float yu = (1.0 + NdL * log(NdL) - NdL * log(1.0 + NdL));\n    \n    //col = vec3(1.0) * NdL / (NdL + NdV) / wu * RcpPi2;\n    //col = vec3(1.0) *  mix(1.0 / (NdL + NdV) / wu, 1.0 / (NdL + NdV) / yu, 0.5) * NdL * RcpPi2;\n    //col = vec3(1.0) * (NdL / (NdL + NdV)) * (1.0 / wu + 1.0 / yu) / 1.6 * RcpPi4;\n    //col = vec3(1.0) * HapkeNonAbsBRDF(NdL, NdV) * NdL;\n    //col *= Pi;\n    \n    //col = vec3(NdL);\n    \n    //col = vec3(1.0) * NdL / (NdL + NdV) * mix((dot(L, V) * 0.5 + 0.5), 1.0, 0.5);\n    //col = vec3(1.0) * 1.0 * mix(1.0, NdL * NdV, 0.4) / (NdL + NdV) * NdL;\n    //col = vec3(1.0) * mix(NdL / (NdL + NdV) * 0.5, NdL, 0.4);\n    //col = vec3(1.0) * mix(NdL / (NdL + NdV), NdL, exp2(-0.3 * (1.0/NdL + 1.0/NdV)));\n    //col = mix(vec3(1.0, 0.1, 0.01), vec3(1.0), 1.0-a0) * NdL;\n    ////col = mix(vec3(1.0, 0.1, 0.01), vec3(1.0), (o * (1.0 - v) + ((1.0 - o) * v)) * 0.5) * NdL;        \n    //l = vec3(NdL);\n\n\n    return col;\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(1.0 - abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\nvec3 Sample_Triangle(vec3 s) \n{ \n    vec3 v = 1.0 - sqrt(1.0 - abs(s));\n    \n    return vec3(s.r < 0.0 ? -v.r : v.r,\n                s.g < 0.0 ? -v.g : v.g,\n                s.b < 0.0 ? -v.b : v.b);\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n    \n    vec2 PixelCount = iResolution.xy;// * vec2(0.5, 1.0);\n    \n    bool right = uv.x > PixelCount.x * 0.5;\n    //if(right) uv.x -= PixelCount.x;\n    \n    vec4 bnoise = texelFetch(iChannel1, ivec2(uv) & 1023, 0); \n    \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n    vec4 wasdAccu  = texelFetch(iChannel0, ivec2(2, 0), 0); \n\n    vec2 lightAng = vec2(Pi * 0.0, Pi * 0.5);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    \n    vec2 ang = vec2(-0.25 * Pi, -Pi * 0.2);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    vec3 cpos = -cam.Front * 2.0;\n    cpos = -cam.Front * (exp2(1.2 + mouseAccu.w * 0.02));\n    \n\n\t#if 1\n    col = vec3(EvalSceneCol(cpos, cam, uv0, right));  \n    #else        \n    col  = EvalSceneCol(cpos, cam, uv + vec2(0.3, 0.1), right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(0.9, 0.3), right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(0.5, 0.5), right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(0.1, 0.7), right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(0.7, 0.9), right);   \n    col *= 0.2; \n    #endif\n    \n//col = vec3(1.0);\n    #if 1\n    vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    //col = vec3(uv0.x / iResolution.x);\n    //col *= col*col*col;\n    //col *= 0.01;\n    \n    //col += Sample_Triangle(bnoise.rgb * 2.0 - 1.0) / 255.0;\n    col += (bnoise.rgb - 0.5) / 255.0;\n\t\n         //col = 0.5 + 0.5*cos(iTime+uv.xyx/iResolution.xyx+vec3(0,2,4));\n\t//col = floor(col * 256.0) / 256.0;\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// \n// by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\n\ncamera controls via mouse + shift key\n*/\n\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast   = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}","name":"Buffer A","description":"","type":"buffer"}]}