{"ver":"0.1","info":{"id":"Ws2fDV","date":"1591028338","viewed":232,"name":"Eisenstein Gasket","username":"sl2c","description":"Based on a conversation [url=https://www.shadertoy.com/view/wdsfWX]here[/url], I created a circle packing based on regular hyperbolic ideal tetrahedra; the centers of all circles should thus be Eisenstein rationals!","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["fractal","circles","gasket"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n#define swap(u,v) {int t=sigma[u]; sigma[u]=sigma[v]; sigma[v]=t;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float res = 1.0 / iResolution.y;\n    vec3 zh = vec3(z, res);\n    \n    vec2[3] lines = vec2[](\n        vec2(1.0,0.0),\n        vec2(-0.5,sqrt(0.75)),\n        vec2(-0.5,-sqrt(0.75)));\n    zh *= 3.0;\n    float t = 0.2 * iTime;\n    t = mod(t, sqrt(3.0) * 2.0);\n    zh += t * vec3(sqrt(0.75), 0.5, 0.0);\n    \n    vec3[3] colors = vec3[](\n        vec3(1.0,0.2,0.2),\n        vec3(0.2,1.0,0.2),\n        vec3(0.0,0.0,0.0));\n    \n    int[5] sigma = int[](0,1,2,3,4);\n    \n    int i;\n    int br = 2;\n    float err = 2.0;\n    for(i=0; i<50; i++) {\n        if (dot(zh,zh) < 1.0) {\n            zh /= dot(zh,zh);\n            swap(0,4);\n            if (sigma[0]+sigma[4]==4) {\n                br = sigma[0];\n                err = (dot(zh,zh)-1.0)/(2.0 * zh.z);\n                break;\n            }\n        }\n        for(int j=0; j<3; j++) {\n            if (dot(zh.xy, lines[j])>0.5) {\n                zh.xy = zh.xy - 2.0 * lines[j] * (dot(zh.xy, lines[j]) - 0.5);\n                swap(0,j+1);\n                if (sigma[0]+sigma[j+1]==4) {\n                    br = sigma[0];\n                    err = (0.5 - dot(zh.xy, lines[j]))/zh.z;\n                    break;\n                }\n            }\n        }\n        if (br != 2) {\n            break;\n        }\n    }\n\n    if (br > 2) {br = 4 - br;}\n    vec3 col = colors[br] * min(err, 2.0) * 0.5;\n    \n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}","name":"Image","description":"","type":"image"}]}