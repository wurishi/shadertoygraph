{"ver":"0.1","info":{"id":"lljfD1","date":"1515679398","viewed":178,"name":"The green hikers duo","username":"zproxy","description":"fork of https://www.shadertoy.com/view/Xl2BRR\n4fps","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["walkman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------\n// Created by sebastien durand - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n\n// Change this to improve quality (3 is good)\n#define ANTIALIASING 1\n\n//#define WITH_SHADOW\n//#define WITH_AO\n\n// Isosurface Renderer\n// less makes edges glitch\n#define g_traceLimit 80\n#define g_traceSize .004\n\n#define STAR_VOXEL_STEPS 20\n#define STAR_VOXEL_STEP_SIZE 3.\n#define STAR_RADIUS .02\n\n\nfloat gTime;\n\n//---------------------------------------------------------------------\n//    Animation\n//---------------------------------------------------------------------\n\n//                       Contact           Down               Pass               Up      \nconst float ep = 16.;\nvec3[9] HEAD = vec3[9](  vec3(50,24,0),    vec3(73,30,0),     vec3(94,20,0),     vec3(117,15,0), //vec3(138,29,0), \n                         vec3(85+50,24,0), vec3(85+73,30,0),  vec3(85+94,20,0),  vec3(85+117,15,0), /*vec3(85+138,29,0),*/ vec3(168+50,24,0));\n\nvec3[9] SHOULDER = vec3[9](vec3(44,47,ep),   vec3(66,53,ep),    vec3(91,43,ep),    vec3(115,38,ep), /*vec3(140,50,15),*/ \n                         vec3(85+51,50,ep),vec3(85+73,55,ep), vec3(85+91,43,ep), vec3(85+111,37,ep), vec3(168+44,47,ep));\n\nvec3[9] ELBOW = vec3[9]( vec3(25,68,25),   vec3(46,71,25),    vec3(88,74,25),    vec3(120,69,25), //vec3(148,75,15),\n                         vec3(85+54,66,25),vec3(85+87,71,25), vec3(85+91,75,25), vec3(85+92,65,25), vec3(168+25,68,25));\n\nvec3[9] WRIST = vec3[9](vec3(20,90,15),   vec3(35,81,20),    vec3(88,106,25),   vec3(128,94,25), \n                         vec3(164,85,15),  vec3(85+102,86,20),vec3(85+88,104,25),vec3(85+82,86,20), vec3(168+20,90,15));\n\nvec3[9] HIP = vec3[9](vec3(42,90,10.),  vec3(62,95,10.),   vec3(83,88,10.),   vec3(107,83,10.),  \n                         vec3(127,92,10.), vec3(147,94,10.),  vec3(168,91,10.),  vec3(192,85,10.), vec3(42+168,90,10));\n\nvec3[9] KNEE = vec3[9]( vec3(29,118,7.),  vec3(48,120,8.),   vec3(97,117,10.),  vec3(130,107,10.), \n                         vec3(144,120,7.), vec3(167,118,7.),  vec3(167,118,7.),  vec3(181,111,7.), vec3(168+29,118,7));\n\nvec3[9] ANKLE=vec3[9](vec3(5,134,5.),   vec3(22,132,6.),   vec3(71,122,10.),  vec3(113,127,10.), \n                         vec3(162,146,5.), vec3(164,146,5.),  vec3(164,146,5.),  vec3(168,137,5.), vec3(168+5,134,5));\n\nvec3[9] FOOT = vec3[9](  vec3(14,150,10.), vec3(16,150,10.),  vec3(63,139,10.),  vec3(119,143,10.), \n                         vec3(178,139,10.),vec3(182,150,10.), vec3(182,150,10.), vec3(182,150,10.), vec3(168+14,150,10));\n\n\nvec3 shoulder1, elbow1, wrist1, head,\n     shoulder2, elbow2, wrist2;\nvec3 foot1, ankle1, knee1, hip1,\n     foot2, ankle2, knee2, hip2;\n\nmat2 rot, rot2;\n\n// Interpolate pos of articulations\nvec3 getPos(vec3 arr[9], int it, float kt, float z) {\n    it = it%8;\n    vec3 p = mix(arr[it], arr[it+1], kt);\n\treturn .02*vec3(p.x+floor(gTime/8.)*168., 150.-p.y, p.z*z);\n}\n\n\n//---------------------------------------------------------------------\n//    HASH functions (iq)\n//---------------------------------------------------------------------\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nvec3 hash33( const in vec3 p) {\n    return fract(vec3(\n        sin( dot(p,    vec3(127.1,311.7,758.5453123))),\n        sin( dot(p.zyx,vec3(127.1,311.7,758.5453123))),\n        sin( dot(p.yxz,vec3(127.1,311.7,758.5453123))))*43758.5453123);\n}\n\n\n//---------------------------------------------------------------------\n//    Palette\n// https://www.shadertoy.com/view/4dsSzr\n//---------------------------------------------------------------------\nvec3 heatmapGradient(float t) {\n\treturn clamp((pow(t, 1.5) * .8 + .2) * vec3(smoothstep(0., .35, t) + t * .5, smoothstep(.5, 1., t), max(1. - t * 1.7, t * 7. - 6.)), 0., 1.);\n}\n\n\n//---------------------------------------------------------------------\n//    Geometry\n//---------------------------------------------------------------------\n\n// Distance from ray to point\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n    //return length(cross(p-ro,rd));\n}\n\n// Distance line / line (must exist simplest way to do this)\nfloat distanceLineLine(vec3 ro, vec3 u, vec3 ro2, vec3 v) {\n    vec3 w = ro - ro2;\n    float a = dot(u,u); \n    float b = dot(u,v);\n    float c = dot(v,v);\n    float d = dot(u,w);\n    float e = dot(v,w);\n    float D = a*c - b*b;\n    float sc = (b*e - c*d) / D;\n    float tc = (a*e - b*d) / D;\n    // get the difference of the two closest points\n    vec3 dP = w + (sc * u) - (tc * v);\n    return sc>0. ? length(dP):1e3;   // return the closest distance\n}\n\n\n//---------------------------------------------------------------------\n//      Start field (iterate in a 3d grid)\n//---------------------------------------------------------------------\n\nvec4 renderStarField(in vec3 ro, in vec3 rd, in float tmax) { \n    vec3 ros = ro;\n    ros /= STAR_VOXEL_STEP_SIZE;\n\tvec3 pos = floor(ros),\n\t     mm, ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ros + .5 + rs*.5) * ri;\n    float dint, d = 0.;\n\tvec3 offset, id;\n    vec4 col = vec4(0);\n    vec4 sum = vec4(0);\n    \n\tfor( int i=0; i<STAR_VOXEL_STEPS; i++ ) {\n        id = hash33(pos);\n        offset = clamp(id+.1*cos(id+(id.x)*iTime),STAR_RADIUS, 1.-STAR_RADIUS);\n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if (dint>0.&& dint*STAR_VOXEL_STEP_SIZE<tmax) {\n            col.rgb = heatmapGradient(.4+id.x*.6);\n            col = (vec4(.6+.4*col.rgb, 1.)*(1.-smoothstep(STAR_RADIUS*.5,STAR_RADIUS,d)));\n            col.a *= smoothstep(float(STAR_VOXEL_STEPS),0.,dint);\n            col.rgb *= col.a/dint;\t\t\t\t                                \n            sum += (1.0-sum.a)*col;\n            if (sum.a>.99) break;\n        }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\treturn sum;\n}\n\n\n//---------------------------------------------------------------------\n//   Modeling Primitives\n//   [Inigo Quilez] https://iquilezles.org/articles/distfunctions\n//---------------------------------------------------------------------\n\nbool cube(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf) { //, out vec3 n) {\n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n//\tn = -sign(rd)*step(a.yzx,a)*step(b.zxy,b);\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z);\n\treturn tn>0. && tn<tf;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule2( vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat sdPlane( vec3 p, vec3 n) {\n  // n must be normalized\n  return dot(p,n);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\n\n//---------------------------------------------------------------------\n//    Man + Ground distance field \n//---------------------------------------------------------------------\n\nfloat map0(vec3 pos);\n\nfloat map(vec3 pos0)\n   {\n       // 3fps\n   return min( map0(  vec3(pos0.x + 1., pos0.y, pos0.z - 0.5)),\n               map0(vec3(pos0.x - 1., pos0.y, pos0.z + 0.5))\n              );\n       \n   }\n    \nfloat map0(vec3 pos){\n    // this cuts the man in half\n//    vec3 pos = vec3(mod(pos0.x -1., 200.), pos0.y, pos0.z);\n   // vec3 pos = vec3(mod(pos0.x +1., 2.), pos0.y, pos0.z);\n    \n    //vec3 pos = vec3(pos0.x + 1., pos0.y, pos0.z) * 0.999;\n    \n    \n    const float r1= .15, r2 = .1, r3= .1;\n    float d = 200.;\n    \n    // Leg 1\n    d = min(d, sdCapsule2(pos, foot1, ankle1, r2,r1));\n    d = min(d, sdCapsule(pos, ankle1, knee1, r1));\n    d = min(d, sdCapsule2(pos, knee1, hip1, r1,r2));\n \n    // Foot1 flat part - vector base linked to leg 1\n    vec3 v2 = normalize(knee1 - ankle1);\n    vec3 v1 = normalize(ankle1 - foot1-v2*.1);\n    vec3 v3 = cross(v1,v2);\n    d = max(d, -sdPlane(pos-ankle1+v2*.1, -cross(v1,v3))); \n    \n    // Leg 2\n    float d2 = sdCapsule2(pos, foot2, ankle2, r2,r1);\n    d2 = min(d2, sdCapsule(pos, ankle2, knee2, r1));\n    d2 = min(d2, sdCapsule2(pos, knee2, hip2, r1,r2));\n\n    // Foot2 flat part - vector base linked to leg 2\n    v2 = normalize(knee2 - ankle2);\n    v1 = normalize(ankle2 - foot2-v2*.1);\n    v3 = cross(v1,v2);\n    d2 = max(d2, -sdPlane(pos-ankle2+v2*.1, -cross(v1,v3))); \n\n    d = min(d, d2);\n    \n    vec3 ep0 = mix(shoulder1,shoulder2,.5);\n    vec3 ha0 = mix(hip1,hip2,.5);\n\n    // Head\n    d = min(d, sdCapsule2(pos, head - vec3(0,.17,0), head + vec3(-.02,.11,0),.13,.16));\n    \n    // Arm 1\n    v1 = normalize(wrist1-elbow1);\n    d = min(d, sdCapsule(pos, shoulder1, elbow1, r2));\n    d = min(d, sdCapsule2(pos, elbow1, wrist1-.05*v1, r2,r3));\n\n    // Hand1 - fix vector base to harm 1\n    v3 = -normalize(cross(v1,normalize(wrist1-shoulder1)));\n    v2 = -cross(v1,v3);\n    vec3 c = wrist1-v3*.06-v1*.12;\n    \n\t// Finders 1\n    d2 = sdCapsule2(pos, c, wrist1+.1*(v2+v1+v3), .013,.033);\n    d2 = min(d2, sdCapsule2(pos, c, wrist1+.18*(v1+v2*.2), .01,.03));\n    d2 = min(d2, sdCapsule2(pos, c, wrist1+.2*(v1-v2*.2), .01,.03));\n    d2 = min(d2, sdCapsule2(pos, c, wrist1+.15*(v1-v2*.6), .01,.026));\n    \n    // Arm 2\n    v1 = normalize(wrist2-elbow2);\n    d = min(d, sdCapsule(pos, shoulder2, elbow2, r2));\n    d = min(d, sdCapsule2(pos, elbow2, wrist2-.05*v1, r2,r3));\n    \n    // Hand2 - fix vector base to harm 2\n    v3 = normalize(cross(v1,normalize(wrist2-shoulder2)));\n    v2 = cross(v1,v3);\n    c = wrist2-v3*.06-v1*.12;\n    \n\t// Finders 2     \n    d2 = min(d2, sdCapsule2(pos, c, wrist2+.1*(v2+v1+v3), .013,.033));\n    d2 = min(d2, sdCapsule2(pos, c, wrist2+.18*(v1+v2*.2), .01,.03));\n    d2 = min(d2, sdCapsule2(pos, c, wrist2+.2*(v1-v2*.2), .01,.03));\n    d2 = min(d2, sdCapsule2(pos, c, wrist2+.15*(v1-v2*.6), .01,.026));\n\n    d = min(d, sdCapsule(pos, shoulder1, shoulder2, r2));\n   \td = smin(d2, d, .08);\n    \n    // Torso\n    vec3 a = mix(ha0,ep0,.15), b = mix(ha0,ep0,.78);\n    \n    // Neck\n    d = smin(d, sdCapsule(pos, mix(shoulder1,shoulder2,.5)-vec3(.1,0,0), head-vec3(.11,.1,0), r2*.5),.06);\n    d = smin(d, sdCapsule2(pos, a, b, .2,.26),.18);\n\n    // Ground\n    vec3 te = textureLod(iChannel0, pos.xz*.1,1.).rgb;\n    d = min(d, pos.y+.3*length(te));\n    \n    // Belt\n    vec3 pos2 = pos-ha0+vec3(0,-.13,.02);\n    pos2.yz *= rot2;\n    d = min(d,mix(d,sdCappedCylinder(pos2, vec2(.28,.08)),.4)); \n \n    // Backpack\n    pos -= ep0;\n    \n    // can we modulate the backback atleast?\n    d2 = udRoundBox(\n        \n        vec3(\n            // whats one hop size? // there seems to be a cutoff space?\n            //pos.x+.43 - 1.5,\n            pos.x+.43 - mod(iTime * 100., 600.0) *0.01 + 2.0,\n            \n            pos.y-.2,\n            pos.z+0.), \n        \n        vec3(.1,.2,.2), \n        \n        .25); \n    \n    float d2x =    udRoundBox(\n        \n        vec3(\n            // whats one hop size? // there seems to be a cutoff space?\n            //pos.x+.43 - 1.5,\n            pos.x+.43 - mod(-iTime * 100., 600.0) *0.01 + 2.0,\n            \n            pos.y+.5,\n            pos.z+0.), \n        \n        vec3(.1,.2,.2), \n        \n        .25); \n    \n    \n   // d2 += .005*(smoothstep(.1,.6,cos(51.*(.2*pos.z+.4*pos.x*pos.x+pos.y)))+smoothstep(.4,.9,sin(51.*(.8*cos(1.+pos.z)+.4*pos.x+.2*pos.y))));\n    pos.yz *= rot;\n    //d2 = smin(d2,mix(d,sdCappedCylinder(pos.yzx+vec3(.13,.04,.1), vec2(.37,.05)),.75),.05); \n    \n//    return -1.;\n    //return d2;\n    \n    \n    // demo animatio space?\n    //return min(min(d2, d2x),d);\n    if (float(iTime) == 0.)\n        return -1.;\n    \n    return d;\n}\n\n\n//---------------------------------------------------------------------\n//   Ray marching scene if ray intersect bbox\n//---------------------------------------------------------------------\nconst float aspacex = 4.0;\nconst float aspacez = 4.0;\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd ) {\n    // Trace if in bbox (TODO: return intersection with ground otherwise)\n    float dx = gTime*168.*.02/8.+.85;\n    float tn, tf;\n    if (\n        cube(\n            \n            pos-vec3(dx,1.35,0), \n            ray, \n            \n            // this makes animation space bigger\n            vec3(aspacex, 1.7 * 2.,aspacez),  \n            \n            tn, tf)) \n    {\n        \n        traceEnd = min(tf, traceEnd);\n        float t = max(tn, traceStart);\n        float h;\n        for( int i=0; i < g_traceLimit; i++) {\n            h = map( pos+t*ray );\n            if (h < g_traceSize || t > traceEnd)\n                return t>traceEnd?100.:t;\n            t = t+h+.002;\n        }\n    }\n\treturn 100.0;\n}\n\n\n//---------------------------------------------------------------------\n//   Soft shadows\n//---------------------------------------------------------------------\n\n#ifdef WITH_SHADOW\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.05, 0.20 );\n        if( h<0.01 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\n\n//---------------------------------------------------------------------\n//   Ambiant occlusion\n//---------------------------------------------------------------------\n\n#ifdef WITH_AO\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, totao = 0.0;\n    float sca = 1.0;\n    vec3 aopos; \n    for( int aoi=0; aoi<5; aoi++ ) {\n        hr = 0.01 + 0.05*float(aoi);\n        aopos =  nor * hr + pos;\n        totao += -(map( aopos )-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n#endif\n\n\n//---------------------------------------------------------------------\n//   Shading\n//   Adapted from Shane / Iq\n//---------------------------------------------------------------------\n\nvec3 doColor( in vec3 pos, in vec3 rd, in vec3 nor, in vec3 lp, in vec3 col){\n    vec3 ref = reflect( rd, nor );\n\n    // lighitng   \n#ifdef WITH_AO\n    float occ = calcAO( pos, nor );\n#else\n    float occ = 1.;\n#endif\n    vec3  lig = normalize( vec3(0.4, 0.7, 0.6) );\n    vec3  hal = normalize( lig-rd );\n    float amb = .4;//clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n#ifdef WITH_SHADOW\n    dif *= calcSoftshadow( pos, lig, 0.2, 2.5 );\n#endif\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),106.0)*\n        dif *\n        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 50.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += .80*dif*vec3(1.00,0.80,0.55)*(.3+.7*occ);\n    lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n    lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n    lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n    col += 10.00*spe*vec3(1.00,0.90,0.70);\n    return col;\n}\n\n\n//---------------------------------------------------------------------\n//   Calculate normal\n//   From TekF \n//---------------------------------------------------------------------\nvec3 Normal( vec3 pos, vec3 ray, float t) {\n\tfloat pitch = .2 * t / iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx, // tetrahedral offsets\n\t     p1 = pos+d.xyy,\n\t     p2 = pos+d.yxy,\n\t     p3 = pos+d.yyx;\n\n\tfloat f0 = map(p0), f1 = map(p1), f2 = map(p2),\tf3 = map(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n//---------------------------------------------------------------------\n//   Camera\n//---------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n//---------------------------------------------------------------------\n//   Entry point\n//---------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = iTime*6.;\n   \n    // Animation\n    int it = int(floor(gTime));\n    float kt = fract(gTime);\n    \n    float dz = 1.;\n   \n    head = getPos(HEAD, it, kt, dz);\n\n    shoulder1 = getPos(SHOULDER, it, kt, -dz);\n    elbow1 = getPos(ELBOW, it, kt, -dz);\n    wrist1 = getPos(WRIST, it, kt, -dz);\n    \n    foot1 = getPos(FOOT, it, kt, dz);\n    ankle1 = getPos(ANKLE, it, kt, dz);\n    knee1 = getPos(KNEE, it, kt, dz);\n    hip1 = getPos(HIP, it, kt, dz);\n    \n    shoulder2 = getPos(SHOULDER, it+4, kt, dz);\n    elbow2 = getPos(ELBOW, it+4, kt, dz);\n    wrist2 = getPos(WRIST, it+4, kt, dz);\n\n    foot2 = getPos(FOOT, it+4, kt, -dz);\n    ankle2 = getPos(ANKLE, it+4, kt, -dz);\n    knee2 = getPos(KNEE, it+4, kt, -dz);\n    hip2 = getPos(HIP, it+4, kt, -dz);\n\n    \n    float a = -1.5708*.4;\n    rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    a = -1.5708*.1;\n    rot2 = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    float dx = it%8 < 4 ? -85.*.02 : +85.*.02; \n    foot2.x += dx;\n    ankle2.x += dx;\n    knee2.x += dx;\n    hip2.x += dx;\n\n    shoulder2.x += dx;\n    elbow2.x += dx;\n    wrist2.x += dx;\n    \n// ------------------------------------\n \n    vec2 m = iMouse.xy/iResolution.y - .5;\n   \n\n// Positon du point lumineux\n    float distLightRot =  100.;      \n    float lt = 5.;\n    vec3 g_lightPos1 = distLightRot*vec3(cos(lt*.5), 1., sin(lt*.5));\n\n     \n\tfloat traceStart = .2;\n    float t, s1, s2;\n    \n    vec3 col = vec3(0), colorSum = vec3(0.);\n\tvec3 pos;\n    vec3 ro, rd;\n\t\n  \tvec2 q;\n    \n#if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n        float randPix = hash(iTime);\n        vec2 subPix = .4*vec2(cos(randPix+6.28*float(i)/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)/float(ANTIALIASING)));        \n    \t// camera\t\n        q = (fragCoord.xy+subPix)/iResolution.xy;\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n\n        ro = vec3(hip1.x+12.*cos(3.14*(.01*iTime+m.x+.3)),3.+3.*abs(sin(.01314*iTime))+10.*(m.y+.3),hip1.z+12.*sin(3.14*(.01*iTime+m.x+.3)));// .9*cos(0.1*time), .45, .9*sin(0.1*time) );\n        vec3 ta = hip1;\n\n        ta.x +=1.2;\n        ta.y = 1.2;\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera(ro, ta, 0.0);\n\n        // ray direction\n        rd = ca * normalize( vec3(p.xy,4.5) );\n\n        float tGround = -(ro.y-0.) / rd.y;\n        float traceEnd = 120.;//min(tGround,100.);\n        traceStart = 0.;\n        col = vec3(0);\n        vec3 n;\n        t = Trace(ro, rd, traceStart, traceEnd);\n        \n        if (tGround < 0.) \n            tGround = 100.;\n        t = min(t, tGround);\n        \n        if (t<100.) {\n        \tvec3 objCol = vec3(0,0,0);\n\n            pos = ro + rd*t;\n            n = Normal(pos, rd, t);\n           \tif (pos.y<.01) {\n               objCol = .02*vec3(.8,.8,.9);//textureLod(iChannel0, pos.xz*.1,1.).rgb;\n           \t} else {\n                objCol = vec3(.5,.0,.0) ;\n           \t}\n\n            col = doColor(pos, rd, n, g_lightPos1, objCol).grb;\n            \n        } else {\n            \n            float time = iTime*.5;\n            float kt = fract(time);\n            vec3 k = -.5+hash33(floor(time)+vec3(0, 2, 112));\n            if (k.y>.25) {\n                float t0 = distanceLineLine(ro,rd, k*200.+vec3(-100,0,0), normalize(k));\n\n            // mysterious line in sky\n                col = vec3(1,.8,.7) * (1.-smoothstep(0.,0.8,t0)) * smoothstep(.53,.01,rd.y+.2*kt);\n                col *= (.5+.5*hash(time))*smoothstep(0.,1., kt);\n            }\n        }\n        \n#if (ANTIALIASING > 1)\t\n        colorSum += col;\n\t}\n    \n    col = colorSum/float(ANTIALIASING);\n#endif\n    \n    // 6fps to 7fps\n    // Render star dusts ------------------------\n   // vec4 star = renderStarField(ro, rd, t);\n   // \t star.rgb += col.rgb * (1.0 - star.a);\n   // \t col = star.rgb;\n         \n    // Post processing stuff --------------------\n    // Fog\n    float f = 50.0;\n    col = mix( vec3(.18), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t// Gamma\n    col = pow( col, vec3(0.4545) );\n    // Vigneting\n    //col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .1); \n    \n\tfragColor =  vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}