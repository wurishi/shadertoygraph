{"ver":"0.1","info":{"id":"DlccDr","date":"1699298094","viewed":46,"name":"A fork of fading spheres","username":"viktorcsimma","description":"My description: draw balls, then modulate their radius and brightness by time\nOriginal description: Learn from https://thebookofshaders.com/09/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pattern"],"hasliked":0,"parentid":"DltyzM","parentname":"fading spheres"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// original: https://www.shadertoy.com/view/DltyzM\n\n\n// This was from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl.\n// All components are in the range [0â€¦1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// 0..1 -> 0..1 cos\nfloat unitCos(float f) {\n  // cos(2pi*f) + 1/2\n  return ((cos(2.0*3.14159*f)+1.0)/2.0);\n}\n\n//essentially returns a color\nfloat circle(in vec2 _st, in int x, in int y, in float _radius) {\n    float time = iTime * 0.25;  // this slows down movements to a healthy speed\n    // time-dependent variables\n    float cosTimeBw = unitCos(fract((time + ((float(x) + float(y)) / 3.)) * 0.5)) / 2.;\n    float cosTimeFw = unitCos(fract((time + ((float(x) - float(y)) / 3.)) * 0.5)) / 2.;\n\n    vec2 l = _st-vec2(0.5); // huh... it is fract(uv) - (0.5, 0.5); but I don't understand the mathematical meaning\n    float p = 0.3 + cosTimeBw; // this is the range of smoothing; and the cosTimeBw here gives the movement\n    // 2*||l||^2 + cosTimeBw\n    float r = dot(l, l) * 5.0 + cosTimeBw;  // this makes some circles in the same diagonal greater than others\n    // for smoothing the borders\n    // _radius is the \"middle\" radius\n    // and here is where p comes in and determines the width of the smoothed line\n    float smoothed = smoothstep(_radius-(_radius*p), _radius+(_radius*p), r);\n    float color = smoothed;\n    // this cosTimeFw'ed part determines the saturation as well as the width of the diagonals\n    return 1. - ((1. - color) * pow(cosTimeFw, 0.8)); // (1. - pow(cosTimeFw, 2.) / 2.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // scale\n    int s = 15;\n\n    // Normalized pixel coordinates (from 0 to s - 1)\n    vec2 uv = fragCoord / iResolution.y * float(s);\n    // from 0 to 1 (used for calculating the colors)\n    vec2 uvCol = uv / float(s-1);\n    // calculating the angle to the bottom left corner (for the spinning rainbow)\n    float angle = atan(uv.y / uv.x);\n\n    // Now we have 3 spaces that goes from 0-1\n    float bright = circle(fract(uv), int(uv.x), int(uv.y), 0.5);\n    float dark = 1. - bright;\n\n    // Output to screen\n    // the iTime here makes the colors spin\n    vec3 color = hsv2rgb(vec3(angle + iTime/15., 1, 1));\n    fragColor = vec4(1. - (1.-color)*dark,1.0);\n}\n","name":"Image","description":"","type":"image"}]}