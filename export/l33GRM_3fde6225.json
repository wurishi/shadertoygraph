{"ver":"0.1","info":{"id":"l33GRM","date":"1716324447","viewed":74,"name":"raytracing_trying","username":"bk2002","description":"idk dawg ","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 get2DTexture( sampler2D sam, vec2 uv ) {\n  return texture(sam, uv).rgb;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n     \n    \n    vec3 texColor  = get2DTexture(iChannel1, uv);\n    vec3 frameNo = get2DTexture(iChannel2, vec2(0.0,0.0));\n     vec4 m = iMouse / iResolution.x;\n     vec3 offset = texelFetch( iChannel3, ivec2(0,0), 0 ).xyz;\n        if( (m.z>0.0) ) // button is down\n        {\n            fragColor = vec4(texColor, 1.0);\n            \n        }\n       \n    else\n        fragColor = vec4(texColor/frameNo.x, 1.0);\n   \n    \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uint seed = 0u;\nconst float PI = 3.141592;\nmat3 CameraRotation(vec2 m)\n{\n    m.y = -m.y;\n\n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n\n    return rotY * rotX;\n}\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\n\n#define load(P) texelFetch(iChannel3, ivec2(P), 0)\n\n#define M_PI 3.14159265358979323846\nvoid hash()\n{\n    seed *= uint(iTime);\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\n\nvoid initRandomGenerator(vec2 fragCoord)\n{\n    seed = uint(fragCoord.y * iResolution.x + fragCoord.x) + uint(iFrame) * uint(iResolution.x) * uint(iResolution.y);\n}\n\nfloat random()\n{\n    hash();\n    return float(seed) / 4294967295.0;\n}\n\nvec3 random_vec3()\n{\n    vec3 res;\n    seed += 1u; // Change the seed for each component\n    res.x = random();\n    seed += 1u; // Change the seed for each component\n    res.y = random();\n    seed += 1u; // Change the seed for each component\n    res.z = random();\n    return normalize(res);\n}\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd)\n{\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy / iResolution.x;\n\n    float a = 1.0 / max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy * 0.5) * a, 0.5));\n\n    rd = CameraRotation(m) * rd;\n}\n\nvec3 cosine_weighted_hemisphere(vec3 normal)\n{\n    float rand1 = random();\n    float rand2 = random();\n    float r = sqrt(rand1);\n    float theta = 2.0 * 3.141592653589793 * rand2;\n\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    float z = sqrt(1.0 - rand1);\n\n    vec3 s = vec3(x, y, z);\n    vec3 w = normal;\n    vec3 u = normalize(cross(abs(w.x) > 0.1 ? vec3(0, 1, 0) : vec3(1, 0, 0), w));\n    vec3 v = cross(w, u);\n    return normalize(s.x * u + s.y * v + s.z * w);\n}\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c));\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c));\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1));\n}\n\n// Identity matrix.\nmat3 identity()\n{\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1));\n}\nfloat key_pressed(int keyCode)\n{\n    return texture(iChannel0, vec2((float(keyCode) + 0.5) / 256., .5 / 3.)).r;\n}\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float metallic;\n    vec3 emission_color;\n    float emission_power;\n    float eta;\n};\nvec3 get_emission(Material m)\n{\n    return m.emission_color * m.emission_power;\n}\nstruct Sphere\n{\n    vec3 center;\n    float r;\n    Material mat;\n};\n\n#define N_SPHERE 3\n#define W 87\n#define A 65\n#define S 83\n#define D 68\n// Function to calculate the intersection of a ray with a sphere\nfloat get_t(vec3 ray_origin, vec3 ray_dir, vec3 center, float r)\n{\n    vec3 oc = ray_origin - center;\n    float a = dot(ray_dir, ray_dir);\n    float b = 2.0 * dot(oc, ray_dir);\n    float c = dot(oc, oc) - r * r;\n    float d = b * b - 4.0 * a * c;\n\n    if (d < 0.01f)\n        return -1.0;\n\n    float sqrt_d = sqrt(d);\n    float t1 = (-b - sqrt_d) / (2.0 * a);\n    float t2 = (-b + sqrt_d) / (2.0 * a);\n\n    // Return the smallest positive t value\n    if (t1 > 0.0)\n        return t1;\n    if (t2 > 0.0)\n        return t2;\n    return -1.0;\n}\n\n// Struct to store intersection information\nstruct HitInfo\n{\n    float t;\n    int index;\n};\n\n// Function to find the closest sphere intersection\nHitInfo find_closest(Sphere sphere[N_SPHERE], vec3 ray_origin, vec3 ray_dir)\n{\n    float min_t = 1e20; // Initialize to a large value\n    int min_index = -1; // Initialize to an invalid index\n\n    for (int i = 0; i < N_SPHERE; i++)\n    {\n        float t = get_t(ray_origin, ray_dir, sphere[i].center, sphere[i].r);\n        if (t > 0.0 && t < min_t)\n        {\n            min_t = t;\n            min_index = i;\n        }\n    }\n\n    return HitInfo(min_t, min_index);\n}\n\nvec3 get2DTexture(sampler2D sam, vec2 uv)\n{\n    return texture(sam, uv).rgb;\n}\nfloat fresnel(float cos_theta, float f0)\n{\n    return f0 + (1.0 - f0) * pow(1.0 - cos_theta, 5.0);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initRandomGenerator(fragCoord * iTime);\n    vec3 center1 = vec3(0.0, -0.0, 0.0);\n    float r1 = 1.0;\n    vec3 center2 = vec3(0.0, -201.0, 0.0);\n    float r2 = 200.0;\n    vec3 center3 = vec3(2.4, 0.0, 0.0);\n    float r3 = 1.0;\n\n    vec3 color1 = vec3(0.9, 0.9, 0.9);    // Original color for the first sphere\n    vec3 color2 = vec3(0.9, 0.9, 0.9);    // Original color for the second sphere\n    vec3 color3 = vec3(0.99, 0.99, 0.99); // Original color for the second sphere\n\n    // Define materials\n    // Define materials\n    Material mate1 = Material(color1, 0.1, 0.6, vec3(0.0f), 0.0, 1.2); // Albedo is color1, roughness 0.5, metallic 0.0\n    Material mate2 = Material(color2, 0.9, 0.2, vec3(0.0f), 0.0, 0.0); // Albedo is color2, roughness 0.2, metallic 0.0\n    Material mate3 = Material(color3, 0.9, 0.0, color3, 0.0, 0.0);     // Albedo is color2, roughness 0.2, metallic 0.0\n\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ouv = uv;\n    vec2 mouse = vec2(iMouse) / vec2(iResolution);\n\n    uv = 2.0 * (uv - 0.5);\n    uv.x *= aspect_ratio;\n\n    mouse = 2.0 * (mouse - 0.5);\n    mouse *= aspect_ratio;\n\n    // vec3 offset = texelFetch(iChannel3, ivec2(0, 0), 0).xyz;\n    // vec3 roffset = texelFetch(iChannel3, ivec2(0.5, 0.5), 0).xyz;\n    vec3 light_dir = normalize(vec3(mouse.x, mouse.y, -1.0));\n    int bounces = 32;\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    int bs = -1;\n    Camera(fragCoord, ro, rd);\n    Sphere s[N_SPHERE] = Sphere[N_SPHERE](Sphere(center1, r1, mate1), Sphere(center2, r2, mate2), Sphere(center3, r3, mate3));\n    int samples = 4;\n\n    vec3 sky_color = vec3(0.7, 0.9, 1.2);\n\n    vec3 fcolor = vec3(0.0f);\n    bool flag_re = false;\n    bool flag_rf = false;\n    for (int sm = 0; sm < samples; sm++)\n    {\n\n        vec3 jittering = random_vec3() * 0.005;\n        vec3 ray_origin = vec3(0.0 + ro.x, 0.0 + ro.y, ro.z - 1.0f);\n        vec3 ray_dir = vec3(rd.x, rd.y, rd.z);\n        ray_dir += jittering;\n\n        ray_dir = normalize(ray_dir);\n\n        vec3 light = vec3(0.0);\n\n        vec3 contribution = vec3(1.0);\n        float etap = 1.0;\n\n        for (int i = 0; i < bounces; i++)\n        {\n            HitInfo hi = find_closest(s, ray_origin, ray_dir);\n            float t1 = hi.t;\n\n            if (hi.index == -1)\n            {\n                light += sky_color * contribution;\n                bs = i;\n                break;\n            }\n\n            Sphere sh = s[hi.index];\n            Material mat = sh.mat;\n            vec3 hit_point = ray_origin + ray_dir * t1;\n            vec3 normal = normalize(hit_point - s[hi.index].center);\n            bool front_face = true;\n\n            contribution *= mat.albedo;\n\n            light += get_emission(sh.mat);\n\n            // Generate the next ray\n            vec3 offset = normal * 0.01;\n            ray_origin = hit_point + offset;\n            vec3 copy = ray_dir;\n            ray_dir = mix(cosine_weighted_hemisphere(normal),\n                          (reflect(ray_dir, normal) + cosine_weighted_hemisphere(normal) * mat.metallic), 1.0 - mat.roughness);\n            if (dot(-normal, ray_dir) > 0.0)\n            {\n                front_face = false;\n                normal = -normal;\n            }\n            else\n                front_face = true;\n            \n            if (abs(mat.eta) > 0.01)\n            {\n                ray_dir = copy;\n                float eta = mat.eta;\n                float eta_fraction = 1.0 / eta;\n\n                float f0 = (1.0 - eta_fraction) / (1.0 + eta_fraction);\n                f0 = f0 * f0;\n\n                if (!front_face)\n                    eta_fraction = eta; // Correctly adjust eta_fraction based on ray direction\n                vec3 nwo = ray_dir;\n                float cos_theta = -dot(normal, nwo);\n                float sin_theta_2 = 1.0 - (eta_fraction * eta_fraction) * (1.0 - cos_theta * cos_theta);\n                bool cannot_refract = sin_theta_2 <= 0.0;\n                // Variables for the new ray direction and origin\n                vec3 dir;\n                vec3 origin;\n\n                if (!cannot_refract)\n                {\n                    // Refract\n                    origin = hit_point - normal * 0.01;\n                    vec3 perp = nwo * cos_theta;\n                    vec3 para = (eta_fraction * cos_theta - sqrt(sin_theta_2)) * normal;\n\n                    dir = perp + para;\n                    flag_re = true;\n\n                    // contribution /= mat.albedo;\n                }\n                else\n                {\n                    // Reflect\n                    origin = hit_point + normal * 0.01;\n                    dir = reflect(nwo, normal);\n                }\n\n                // Normalize the direction\n                ray_dir = normalize(dir);\n                ray_origin = origin;\n            }\n        }\n        // Debug colors for visualization\n        vec3 color = vec3(0.0);\n#define aDEBUG\n#ifdef DEBUG\n\n        if (bs == -1)\n            color = vec3(0, 0, 1);\n        else\n        {\n            if (bs == 0)\n                color = vec3(0.5);\n            if (bs == 1)\n                color = vec3(0.9, 0.9, 0.0);\n            if (bs > 2)\n                color = vec3(0.0, 0.9, 0.9);\n            if (bs > 6)\n                color = vec3(0.9, 0.0, 0.9);\n            if (bs >= 20)\n                color = vec3(0.0, 0.9, 0.0);\n        }\n        if (flag_re)\n        {\n            // color = vec3(0.5, 0.5, 0.0);\n            flag_re = false;\n        }\n#else\n        color = light;\n#endif\n        fcolor += color;\n    }\n    fcolor = fcolor / float(samples);\n    vec3 texColor = get2DTexture(iChannel1, ouv);\n    vec4 m = iMouse / iResolution.x;\n    if (iTime > 1.0f)\n    {\n        if ((m.z > 0.0)) // button is down\n        {\n            fragColor = vec4(fcolor, 1.0);\n            return;\n        }\n        fragColor = vec4(fcolor + texColor, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvec3 get2DTexture( sampler2D sam, vec2 uv ) {\n  return texture(sam, uv).rgb;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 prevFrame  = get2DTexture(iChannel2, vec2(0.0,0.0));\n    vec4 m = iMouse / iResolution.x;\n   \n    \n     if( (m.z>0.0) ) // button is down\n        {\n            fragColor = vec4(0.0,0.0,0.0,0.0);\n            \n        }\n       else\n    fragColor = vec4(1.0f+prevFrame.x,0.0,0.0,0.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\nmat3 CameraRotation( vec2 m )\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY * rotX;\n}\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 17;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec3 KeyboardInput() {\n    INPUT_METHOD\n    \n\t    vec3 i = vec3(0.0);\n    i.x = key(KEY_BIND_RIGHT) - key(KEY_BIND_LEFT);\n    i.z = key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD);\n    i.y = float(key(KEY_SP)) - float(key(KEY_BSP));\n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    \n    return CameraRotation(m) * vec3(KeyboardInput()).xyz;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, min(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    //Collision(ptarget, target);\n    \n    position += (target - position) ;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n\t}\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}","name":"Buffer C","description":"","type":"buffer"}]}