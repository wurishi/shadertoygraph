{"ver":"0.1","info":{"id":"MtBcDd","date":"1510591727","viewed":373,"name":"Simple renderer sphere tracing","username":"lsdlive","description":"Nothing new, nothing innovative, it's my simple renderer template I use for my projects.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Renderer v1 (simple renderer)\n\nmat2 r2d(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 amod(vec2 p, float m) {\n\tfloat a = mod(atan(p.x, p.y), m) - m * .5;\n\treturn vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat sc(vec3 p, float s) {\n\tp = abs(p);\n    p = max(p, p.yzx);\n\treturn min(min(p.x, p.y), p.z) - s;\n}\n\nfloat box(vec3 p, vec3 b) {\n\treturn length(max(abs(p) - b, 0.));\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// from: https://github.com/mudlord/shaderlathe/blob/master/redist/raymarch.glsl\nfloat mudlord_cube(vec3 p) {\n\tfloat cube = box(p, vec3(.5)) + max(sin((p.x + p.y + p.z)*20.) * .003, 0.);\n\treturn max(cube, -sphere(p, .5));\n}\n\n\nfloat map(vec3 p) {\n\tmat2 r = r2d(iTime);\n\n\tp.xz *= r;\n\tp.yz *= r;\n\n\t// shape 1\n\t//return box(p, vec3(.7));\n\n\t// shape 2\n\t//p.xz = amod(p.xz, .785);// pi / 4, 45Â°\n\t//return sc(p, .5);\n\n\t// shape 3\n\treturn mudlord_cube(p);\n}\n\nvec3 fog(vec3 col, float dist) {\n\tvec3 BACKGROUND_COLOR = vec3(.3, .1, .2);\n\tfloat FOG_DENSITY = .01;\n\treturn mix(col, BACKGROUND_COLOR, 1.0 - exp(-FOG_DENSITY*dist*dist));\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec2 e = vec2(1.,-1.)*.5773*.0005;\n    return normalize(e.xyy*map( pos + e.xyy) + \n\t\t\t\t\t e.yyx*map( pos + e.yyx) + \n\t\t\t\t\t e.yxy*map( pos + e.yxy) + \n\t\t\t\t\t e.xxx*map( pos + e.xxx));\n    /*\n\tvec3 eps = vec3(.0005, 0, 0);\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n\t*/\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\n\t//vec3 ro = vec3(1, 1, 5), p;\n\tvec3 ro = vec3(0, 0, 3), p;\n\tvec3 rd = normalize(vec3(uv, -1.));\n\tp = ro;\n\n\tfloat ri;\n\tfloat d;\n\tfor (float i = 0.; i < 1.; i+=.01) {\n\t\tri = i;\n\t\td = map(p);\n\t\tif (d < .001) break;\n\t\tp += d * rd;\n\t}\n\n\n\t// ** render stage (can be combined) ** //\n\n\tvec3 c = vec3(.2, .1, .2);\n\n\t// lambert light front\n\t//c = vec3(.9, .3, .3) * max(0., dot(-rd, normal(p)));\n\n\t// lambert point light\n\tvec3 lpos = vec3(0, 4, 2);\n\tvec3 ldir = normalize(lpos - p);\n\t//c = vec3(.9, .3, .3) * max(0., dot(ldir, normal(p)));\n\n\t// fake ambient\n\t//if(d<0.01) c = c * .5 + .5;\n\n\t// normals\n\t//c = normal(p);\n\n\t// distance\n\t//c = mix(vec3(0.9, 0.3, 0.3), c, length(ro - p) * .1);\n\n\t// iteration\n\tc = mix(vec3(.9, .3, .3), c, ri);\n\n\n\t// ** \"post processing\" ** //\n\n\tc = fog(c, length(ro - p));\n\n\t// centered light\n\tc = c * sqrt(1. - length(uv));\n\n\t// scanline\n\tc = c + cos(1e3*uv.y) * .02;\n\n\t// flickering\n\t//c = c + cos(iTime*1e3) * .01;\n\n\tfragColor = vec4(c, 1);\n}","name":"Image","description":"","type":"image"}]}