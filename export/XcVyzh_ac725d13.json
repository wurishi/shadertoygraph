{"ver":"0.1","info":{"id":"XcVyzh","date":"1731481724","viewed":29,"name":"22r23","username":"congodin","description":"2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FIXED_POINT_PRECISION = 4096.0;\nconst float TEXTURE_SIZE = 256.0;\nconst int MAX_STEPS = 64;\nconst float MAX_DIST = 100.0;\nconst float MIN_DIST = 0.01;\nconst int NUM_ORBS = 5;\n\n// More aggressive vertex snapping for that characteristic PS1 jitter\nvec3 ps1Snap(vec3 p) {\n    // Aggressive vertex snapping\n    float snap = 20.0; // Lower = more jitter\n    p.x = floor(p.x * snap) / snap;\n    p.y = floor(p.y * snap) / snap;\n    p.z = floor(p.z * snap) / snap;\n    return p;\n}\n\nvec2 ps1UV(vec2 uv, float z) {\n    // Aggressive affine texture warping\n    z = max(z, 0.01);\n    uv.x += sin(uv.y * 10.0 + iTime) * 0.02 * z; // Add characteristic PS1 texture swim\n    return floor(uv * TEXTURE_SIZE) / TEXTURE_SIZE;\n}\n\nfloat fogExp(float d, float density) {\n    return 1.0 - exp(-density * d);\n}\n\nmat2 rot2(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// More unstable SDF for that horror game feel\nfloat sceneSDF(vec3 p) {\n    // Snap vertex positions for PS1 style\n    p = ps1Snap(p);\n    \n    // Ground plane with unstable warping\n    float ground = p.y + 1.0;\n    ground += sin(p.x * 2.0 + iTime) * cos(p.z * 2.0) * 0.1;\n    \n    // Add some disturbing geometric patterns\n    for(int i = 0; i < 3; i++) {\n        p.xz *= rot2(iTime * 0.1);\n        float pattern = length(max(abs(p) - 1.0, 0.0));\n        ground = min(ground, pattern);\n    }\n    \n    // Add floating unstable orbs\n    float orbs = 100.0;\n    for(int i = 0; i < NUM_ORBS; i++) {\n        float t = iTime * 0.5 + float(i) * 1.618;\n        vec3 center = vec3(\n            sin(t) * 2.0,\n            cos(t * 0.7) * 0.5 + 1.5,\n            cos(t) * 2.0\n        );\n        \n        // Add instability to orbs\n        center += sin(center.yzx * 4.0 + iTime) * 0.1;\n        \n        float d = length(ps1Snap(p - center)) - 0.5;\n        orbs = min(orbs, d);\n    }\n    \n    return min(ground, orbs);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera with characteristic PS1 shakiness\n    float wobble = sin(iTime * 5.0) * 0.02;\n    vec3 ro = vec3(3.5 * sin(iTime * 0.5 + wobble), 2.0, 3.5 * cos(iTime * 0.5 + wobble));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    // Snap camera position for more instability\n    ro = ps1Snap(ro);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = cross(uu, ww);\n    \n    // Add view instability\n    vec3 rd = normalize(vec3(uv, 2.0));\n    rd = normalize(rd.x * uu + rd.y * vv + rd.z * ww);\n    \n    // Raymarch with unstable steps\n    float t = 0.0;\n    float fog = 0.0;\n    vec3 p;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        p = ro + rd * t;\n        float d = sceneSDF(p);\n        \n        // Add distance fog\n        fog += 0.1 / (1.0 + d * d * 40.0);\n        \n        if(d < MIN_DIST) break;\n        if(t > MAX_DIST) break;\n        \n        // Unstable step size for more PS1 feel\n        t += d * (0.9 + sin(t + iTime) * 0.1);\n    }\n    \n    // Base color with PS1 color quantization\n    vec3 col = vec3(0.5);\n    \n    // Add characteristic PS1 fog\n    float fogAmount = fogExp(t, 0.15);\n    vec3 fogColor = vec3(0.1, 0.1, 0.15); // Dark atmospheric fog\n    col = mix(col, fogColor, fogAmount);\n    \n    // Add fog glow from orbs\n    col += vec3(0.2, 0.3, 0.5) * fog * 0.3;\n    \n    // PS1 color depth simulation (5-5-5 RGB)\n    col = floor(col * 32.0) / 32.0;\n    \n    // Add characteristic PS1 affine texture wobble\n    float distortion = sin(fragCoord.y * 0.25 + iTime) * 0.001;\n    col *= (1.0 + distortion);\n    \n    // Add scanlines\n    float scanline = sin(fragCoord.y * 2.0) * 0.015;\n    col = max(col - scanline, 0.0);\n    \n    // Add noise\n    float noise = fract(sin(dot(fragCoord, vec2(12.9898, 78.233))) * 43758.5453);\n    col += noise * 0.02;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}