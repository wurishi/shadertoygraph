{"ver":"0.1","info":{"id":"lsKBzW","date":"1527850553","viewed":208,"name":"Vision persistence: Hidden image","username":"Quinchilion","description":"Idea based on https://www.testufo.com/eyetracking#pattern=checkerboard\n\nYou should see a hidden pattern only when you focus on the moving dot.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","illusion","hiddenimage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Idea based on https://www.testufo.com/eyetracking#pattern=checkerboard\n// Assumes 60 frames per second, does not do any explicit synchronization\n\nconst float line_width = 2.0;\nconst float cell_size = 16.0;\nconst vec3 line_color = vec3(1.0);\nconst float dot_size = 8.0;\nconst float dot_spacing = 750.0;\nconst vec3 dot_color = vec3(1.0, 1.0, 0.0);\n\nfloat motionCheckers(vec2 pos) {\n\t// Repeats this pattern in time and space:\n    // |   ->   | -> |   ->   | -> ...\n    //   | -> |   ->   | -> |   -> ...\n    // (arrows denote frame progression)\n    \n    vec2 cellf = fract(pos / cell_size);\n    bool oddFrame = fract(float(iFrame) / 2.0) >= 0.5;\n    \n    bool activeLine = cellf.x > 0.5 ^^ cellf.y > 0.5 ^^ oddFrame;\n    \n    bool line = fract(cellf.x * 2.0) <= (2.0 * line_width / cell_size);\n    \n\treturn float(line && activeLine);\n}\n\nfloat leadingDot(vec2 pos) {\n    // Draws a dot that follows the checkerboard pattern\n    pos.x -= iTime * cell_size * (60.0 / 2.0);\n    pos.y += dot_spacing * 0.5;\n    \n\tvec2 dotp = (fract(pos / dot_spacing) - 0.5) * dot_spacing;\n    bool isDot = dot(dotp, dotp) <= (dot_size * dot_size);\n    \n    return float(isDot);\n}\n\nfloat message(vec2 pos) {\n\tfloat a = abs(pos.x*0.7) - 1.5 + pos.y * 0.4;\n    float b = pos.y * 0.25;\n    float w1 = a*a*a*a+b*b*b*b;\n    \n    float c = -abs(pos.x*0.7) + 5.0 + pos.y * 0.4;\n    float w2 = b*b*b*b+c*c*c*c;\n    \n    float w = min(w1, w2);\n    \n    vec2 op1 = vec2(pos.x * 0.6 + 11.0, pos.y * 0.7 - 2.5);\n    float od1 = op1.x * op1.x + op1.y * op1.y - 12.0;\n    float o1 = od1 * od1 / 25.0;\n    \n    vec2 op2 = vec2(pos.x * 0.6 - 11.0, pos.y * 0.7 - 2.5);\n    float od2 = op2.x * op2.x + op2.y * op2.y - 12.0;\n    float o2 = od2 * od2 / 25.0;\n    \n    float o = min(o1, o2);\n    return min(w, o) - 1.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = fragCoord - iResolution.xy / vec2(2.0);\n    \n\t// Add a hidden pattern to the y component of the input position,\n    // making it visible only through display persistence motion blur.\n    vec2 posf = pos / iResolution.xy;\n    float sdf = message(posf * vec2(55.0, 18.0) + vec2(0.0, 2.5));\n    \n    vec2 patPos = vec2(pos.x, pos.y + pos.x * 0.5 * sign(sdf));\n\n\tvec3 c = motionCheckers(patPos) * line_color;\n    \n    c = mix(c, dot_color, leadingDot(patPos) * float(sdf > 0.0));\n    \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}