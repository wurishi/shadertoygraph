{"ver":"0.1","info":{"id":"7lsGRf","date":"1622834094","viewed":5242,"name":"Pistons with Motion Blur","username":"bad_dreams_","description":"Click and drag to rotate the scene.\n\nIt's fun to pause the animation and rotate around the motion blur in 3d.","likes":104,"published":1,"flags":8,"usePreview":0,"tags":["sound","motionblur","piston"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 1/9/2021:\n// - Moved & expanded the MSAA pattern into the temporal\n//   sampling code so the image is always AA'd when using\n//   more than one sample. This is basically free since\n//   we're taking the samples anyway. Thanks for the\n//   suggestion, rory618!\n// - Added bluenoise for temporal jitter. It looks quite\n//   a bit better than the whitenoise for this purpose\n//   and tends to fill in the shapes at very low samples,\n//   even 1spp looks alright in motion. Not a fan of how\n//   the noise breaks up the otherwise smooth look but\n//   maybe this could still be improved.\n\nconst float temporalSamples = 16.0;\nconst bool useTemporalJitter = false; // Adds noise, but eliminates banding.\nconst float maximumBounces = 2.0;\n\n\n// \"Part\" being one piston/cam assembly.\nfloat partDistance(vec3 point, float initialAngle, float worldTime) {\n    point = vec3(point.x, abs(point.z) - 0.1, point.y);\n    vec3 flattenedPoint = vec3(point.x, 0.0, point.z);\n    \n    float smoothing = 0.02;\n    \n    float radiusA = 0.3;\n    float radiusB = 0.15;\n    float size = 0.38;\n    float camAngle = getCamAngle(initialAngle, worldTime);\n    vec3 rotatedPoint = erot(flattenedPoint, vec3(0.0, 1.0, 0.0), camAngle);\n    float dist = roundConeDistance(rotatedPoint, radiusA, radiusB, size);\n    \n    const float height = 0.1;\n    float halfHeight = height / 2.0;\n    float container = boxDistance(point, vec3(0.0, halfHeight, 0.0), vec3(2.0, halfHeight, 2.0));\n    dist = opSmoothIntersection(dist, container, smoothing);\n    \n    vec3 postPoint = point - vec3(0.0, 0.15, 0.0);\n    float post = smoothCylinderDistance(postPoint, 0.1, 0.093, smoothing);\n    dist = opSmoothUnion(dist, post, 0.01);\n    \n    vec3 camAttachment = erot(vec3(0.0, 0.0, 0.38), vec3(0.0, -1.0, 0.0), camAngle);\n\n    vec3 jointPoint = point - camAttachment;\n    float joint = smoothCylinderDistance(jointPoint, 0.075, 0.093, smoothing);\n    dist = opSmoothUnion(dist, joint, 0.005);\n    \n    float rodX = 0.5;\n    float rodLength = 1.0;\n    \n    vec3 rodEnd = vec3(0.0, 0.0, rodLength + camAttachment.z - 0.1);\n    vec3 rodPoint = vec3(point.x, 0.0, point.z);\n    float rod = segmentDistance(rodPoint, camAttachment, rodEnd) - 0.1;\n    float rodContainer = boxDistance(point, vec3(0.0, -height, 0.0), vec3(2.0, halfHeight, 2.0));\n    vec3 rodBasePoint = point - camAttachment - vec3(0.0, -height, 0.0);\n    float rodBase = smoothCylinderDistance(rodBasePoint, halfHeight, 0.2, smoothing);\n    float rodComposite = opSmoothUnion(\n        opSmoothIntersection(rod, rodContainer, smoothing),\n        rodBase,\n        0.075\n    );\n    dist = min(dist, rodComposite);\n    \n    vec3 headPoint = vec3(point.x, point.z - camAttachment.z - rodLength, point.y + 0.1);\n    float head = smoothCylinderDistance(headPoint, 0.25, 0.25, smoothing);\n    \n    vec3 skirtPoint = point - vec3(0.0, 0.0, camAttachment.z + 0.65);\n    float skirtCut = cylinderDistance(skirtPoint, 0.25, 0.2);\n\n    vec3 wristPoint = point - vec3(0.0, 0.15, camAttachment.z + 0.95);\n    float wristCut = cylinderDistance(wristPoint, 0.1, 0.05);\n    \n    float headCuts = min(skirtCut, wristCut);\n    float headComposite = opSmoothSubtraction(headCuts, head, 0.01);\n    dist = min(dist, headComposite);\n    \n    return dist;\n}\n\n// Thanks to Blackle Mori for their video on domain repetition.\nfloat sceneDistance(vec3 point, float worldTime) {\n    float center = (floor(point.z * 1.8) + 0.5) / 1.8;\n    float neighborCenter = center + ((point.z < center) ? -1.0 : 1.0);\n\n    float me = partDistance(point - vec3(0.0, 0.0, center), 3.14159 * floor(center), worldTime);\n    float neighbor = boxDistance(point, vec3(0.0, 0.6, neighborCenter), vec3(0.6, 1.2, 0.70));\n    float partComposite = min(me, neighbor);\n    \n    float container = boxDistance(point, vec3(0.0, 0.6, 0.56), vec3(1.0, 1.4, 1.1));\n    return opSmoothIntersection(partComposite, container, 0.02);\n}\n\n#define ZERO (min(iFrame,0))\n\nvec3 sceneNormal(vec3 point, float worldTime) {\n  #if 0\n    float epsilon = 0.0001;\n    vec3 xOffset = vec3(epsilon, 0.0, 0.0);\n    vec3 yOffset = vec3(0.0, epsilon, 0.0);\n    vec3 zOffset = vec3(0.0, 0.0, epsilon);\n    \n    vec3 direction = vec3(\n        sceneDistance(point + xOffset, worldTime) - sceneDistance(point - xOffset, worldTime),\n        sceneDistance(point + yOffset, worldTime) - sceneDistance(point - yOffset, worldTime),\n        sceneDistance(point + zOffset, worldTime) - sceneDistance(point - zOffset, worldTime)\n    );\n    \n    return normalize(direction);\n  #else\n    // Snagged from iq's \"Raymarching - Primitives\" shader,\n    // which in turn says this is inspired by tdhooper and klems.\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i += 1) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * sceneDistance(point + 0.0005 * e, worldTime);\n    }\n\n    return normalize(n);\n  #endif\n}\n\nvec3 cameraRay(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n    vec3 forward = normalize(lookAt - position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 lensPlane = forward * zoom;\n    vec3 lensPoint = lensPlane + uv.x * right + uv.y * up;\n    vec3 direction = normalize(lensPoint);\n    return direction;\n}\n\nvec3 skyColor(vec3 direction) {\n    return texture(iChannel0, direction).xyz;\n}\n\nstruct TraceResult {\n    bool hit;\n    vec3 point;\n    vec3 incoming;\n};\n\nTraceResult sceneTrace(vec3 origin, vec3 direction, float worldTime) {\n  bool hit = false;\n  vec3 testPoint;\n\n  float time = 0.0;\n  float tfar = 6.0;\n  vec2 bounds = boxIntersect(origin - vec3(0.0, 0.45, 0.55), direction, vec3(0.6, 1.2, 1.15));\n  if (bounds.x < bounds.y && bounds.y > 0.0) {\n      time = max(time, bounds.x);\n      tfar = min(tfar, bounds.y);\n\n      for (int i = 0; i < 128; i += 1) {\n          testPoint = origin + direction * time;\n          float dist = sceneDistance(testPoint, worldTime);\n          if (dist < 0.0001) {\n              hit = true;\n              break;\n          }\n\n          time += dist;\n          if(time > tfar) { break; }\n      }\n  }\n\n  return TraceResult(hit, testPoint, direction);\n}\n\nfloat sceneOcclusion(vec3 point, vec3 normal, float worldTime) {\n    float dist = 0.04;\n    float occlusion = 1.0;\n    for (int index = 0; index < 3; index += 1) {\n        occlusion = min(occlusion, sceneDistance(point + dist * normal, worldTime) / dist);\n        dist *= 0.8;\n    }\n\n    return max(occlusion, 0.05);\n}\n\nmat2 rotate(float a) {\n    float y = sin(a);\n    float x = cos(a);\n    return mat2(x, -y, y, x);\n}\n\nvec3 sceneColor(vec2 uv, float worldTime) {\n    // Thanks to BigWIngs for their mouse input stuff.\n    vec2 mouse = iMouse.x > 20.0 && iMouse.y > 20.0\n        ? iMouse.xy / iResolution.xy\n        : vec2(0.40, 0.50);\n\n    vec3 initialOrigin = vec3(0.0, 3.0, -3.0);\n    initialOrigin.yz *= rotate(-mouse.y * 3.14 + 1.0);\n    initialOrigin.xz *= rotate(-mouse.x * 6.2831);\n\n    vec3 initialDirection = cameraRay(uv, initialOrigin, vec3(0.0, 0.55, 0.6), 1.45);\n    \n    vec3 origin = initialOrigin;\n    vec3 direction = initialDirection;\n    \n    float bounce;\n    vec3 color = vec3(1.0);\n    TraceResult result;\n    for (bounce = 0.0; bounce < maximumBounces; bounce += 1.0) {\n        TraceResult result = sceneTrace(origin, direction, worldTime);\n        \n        if (!result.hit) {\n            color = color * skyColor(result.incoming) * 2.0;\n            break;\n        }\n        \n        vec3 normal = sceneNormal(result.point, worldTime);\n        \n        // Apply AO to our first hit.\n        if (bounce == 0.0) {\n            color = color * sceneOcclusion(result.point, normal, worldTime);\n        }\n\n        color = color * 0.5;\n        \n        direction = reflect(direction, normal);\n        origin = result.point + direction * 0.001;\n    }\n    \n    if (bounce == maximumBounces) {\n        return color * skyColor(direction);\n    }\n\n    return color;\n}\n\nvec2 coordToUv(vec2 coord) {\n  return (coord - (iResolution.xy * 0.5)) / iResolution.y;\n}\n\nfloat hash31(vec3 seed) {\n    vec3 temp = fract(seed * vec3(235.219, 392.452, 149.976));\n    temp += dot(temp, temp + 23.12);\n    return fract(temp.x * temp.y * temp.z);\n}\n\nconst float goldenRatioConjugate = 0.61803398875f;\n\n// From demofox's Blue Noise Fog shader.\n// Not 100% sure I'm applying this correctly,\n// but does look a bit better than whitenoise\n// I think :)\nvec3 bluenoise(vec2 coord) {\n    return texture(iChannel1, coord / 1024.0f).xyz;\n}\n\nconst float a = (3.0 / 8.0);\nconst float b = (1.0 / 8.0);\n\nconst vec2 msaaOffsets[] = vec2[](\n    vec2(0.5625, 0.5625),\n    vec2(0.4375, 0.3125),\n    vec2(0.3125, 0.6250),\n    vec2(0.7500, 0.4375),\n    vec2(0.1875, 0.3750),\n    vec2(0.6250, 0.8125),\n    vec2(0.8125, 0.6875),\n    vec2(0.6875, 0.1875),\n    vec2(0.3750, 0.8750),\n    vec2(0.5000, 0.0625),\n    vec2(0.2500, 0.1250),\n    vec2(0.1250, 0.2500),\n    vec2(0.0000, 0.5000),\n    vec2(0.9375, 0.2500),\n    vec2(0.8750, 0.9375),\n    vec2(0.0625, 0.0000)\n);\n\n// Doing a brute force trace of the scene at different times\n// within the frame and mixing them together.\nvec3 temporalSample(vec2 coord, float worldTime) {\n    // Using iTimeDelta here for a natural looking motion blur.\n    // Looks particularly nice at 144hz w/ 16 samples (:\n    float shutterTime = iTimeDelta;\n    float sampleCount = temporalSamples;\n    float slice = shutterTime / sampleCount;\n    vec3 jitter = bluenoise(coord);\n    \n    vec3 color = vec3(0.0);\n    for (float sampleIndex = 0.0; sampleIndex < sampleCount; sampleIndex += 1.0) {\n        float jitterTime = (sampleIndex + 1.0) + float(iFrame + 1);\n        vec3 adjustedJitter = fract(jitter + jitterTime * goldenRatioConjugate);\n\n        float t = sampleIndex / sampleCount;\n        float sampleTime = useTemporalJitter\n            ? (worldTime - shutterTime) + adjustedJitter.z * shutterTime\n            : (worldTime - shutterTime * t);\n\n        vec2 offset = msaaOffsets[int(mod(sampleIndex, 16.0))];\n\n        vec2 uv = coordToUv(coord + offset);\n        color += sceneColor(uv, sampleTime);\n    }\n\n    return color / sampleCount;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = temporalSample(fragCoord, iTime);\n\n    vec3 toneMapped = hejl(color, 1.0);\n    vec3 gammaCorrected = pow(toneMapped, vec3(1.0 / 2.2));\n    fragColor = vec4(gammaCorrected, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash11(float x) { return fract(sin(x * 3759.371 + 1546.3316) * 5752.1534); }\n\n// Very noob attempt at sound effects.\nvec2 mainSound(int samp, float time) {\n    float camAngle = getCamAngle(0.0, time);\n    float time2 = time * time;\n    \n    float initial = sin(camAngle);\n    float shotRamp = clamp(time2 * 0.05 - 0.001, 0.0, 0.1);\n    float extraRamp = clamp(time2 * 0.001 - 0.0001, 0.0, 0.05);\n    float noise = hash11(time) * min(time2 * 0.1, 0.1);\n    float shot = (1.0 - fract(initial)) * 2.0 - 1.0;\n    float noiseRamp = time > 2.0 ? min(max(time * 0.25 - 2.0, 0.0), 1.0) : 0.0;\n    \n    float primary = shot * shotRamp * 1.0;\n    float secondary = shot * hash11(time + 1.0) * extraRamp * 1.0;\n    float tertiary = noise * shot * noiseRamp * 0.6;\n    return vec2(primary + secondary + tertiary);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"float getCamAngle(float initialAngle, float worldTime) {\n    return initialAngle + worldTime * min(worldTime, 32.0) * 1.0;\n}\n\nvec3 erot(vec3 point, vec3 axis, float angle) {\n    return mix(dot(axis, point) * axis, point, cos(angle))\n        + sin(angle) * cross(axis, point);\n}\n\n// Thanks iq!\nfloat opSmoothSubtraction(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b + a) / k, 0.0, 1.0);\n    return mix(b, -a, h) + k * h * (1.0 - h);\n}\n\nfloat opSmoothUnion(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothIntersection(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\nfloat boxDistance(vec3 point, vec3 position, vec3 extents) {\n    vec3 adjustedPoint = point - position;\n    vec3 p = abs(adjustedPoint) - extents;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\n// From iq's bounding box suggestion.\nvec2 boxIntersect(in vec3 ro, in vec3 rd, in vec3 rad) {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    return vec2( max(max(t1.x, t1.y), t1.z), \n                 min(min(t2.x, t2.y), t2.z) );\n}\n\nfloat segmentDistance(vec3 point, vec3 a, vec3 b) {\n    vec3 aToPoint = point - a;\n    vec3 aToB = b - a;\n\n    float time = clamp(dot(aToPoint, aToB) / dot(aToB, aToB), 0.0, 1.0);\n    return distance(point, a + time * aToB);\n}\n\nfloat cylinderDistance(vec3 point, float height, float radius) {\n    vec2 d = abs(vec2(length(point.xz), point.y)) - vec2(radius, height);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat smoothCylinderDistance(vec3 point, float height, float radius, float smoothing) {\n    return cylinderDistance(point, height - smoothing, radius - smoothing) - smoothing;\n}\n\nfloat roundConeDistance(vec3 point, float radiusA, float radiusB, float height) {\n    vec2 q = vec2(length(point.xy), point.z);\n\n    float b = (radiusA - radiusB) / height;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n\n    if (k < 0.0) return length(q) - radiusA;\n    if (k > a * height) return length(q - vec2(0.0, height)) - radiusB;\n\n    return dot(q, vec2(a, b)) - radiusA;\n}\n\n// https://twitter.com/jimhejl/status/633777619998130176\nvec3 hejl(vec3 color, float whitePoint) {\n    vec4 vh = vec4(color, whitePoint);\n    vec4 va = 1.425 * vh + 0.05;\n    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;\n    return vf.rgb / vf.www;\n}","name":"Common","description":"","type":"common"}]}