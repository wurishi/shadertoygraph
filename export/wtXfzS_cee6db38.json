{"ver":"0.1","info":{"id":"wtXfzS","date":"1597285871","viewed":112,"name":"fastinvsmoothstep","username":"iradicator","description":"Shows a faster approach for calculating inverse smoothstep.\n\nblue = invsmoothstep\nyellow = invsmoothstep approximation\nred = error (shifted to center)\n\nFor full information:\nhttps://iradicator.com/fast-inverse-smoothstep/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["math","fast","function","smoothstep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \n// For more details, check out my blog post: \n// https://iradicator.com/fast-inverse-smoothstep/\n//\n// fastinvsmoothstep implementation: https://www.shadertoy.com/view/wtXfzS\n// fastinvsmoothstep-based animations: https://www.shadertoy.com/view/wtlfz2\n//\n\n// Pick one option\n//#define fastinvsmoothstep fastinvsmoothstep_naive\n//#define fastinvsmoothstep fastinvsmoothstep_linearguess_animated\n//#define fastinvsmoothstep fastinvsmoothstep_linearguess\n//#define fastinvsmoothstep fastinvsmoothstep_edgeoption1_animated\n//#define fastinvsmoothstep fastinvsmoothstep_edgeoption1\n//#define fastinvsmoothstep fastinvsmoothstep_edgeoption2_animated\n//#define fastinvsmoothstep fastinvsmoothstep_edgeoption2\n//#define fastinvsmoothstep fastinvsmoothstep_combined_animated\n#define fastinvsmoothstep fastinvsmoothstep_combined\n\n#define PI 3.141592653589793\n#define EPSILON 0.00001\n\n#define IS_SECOND_UPDATE_STEP 0\n\n// REF: https://www.shadertoy.com/view/MsSBRh\nfloat invsmoothstep(in float x)\n{\n    return 0.5 - sin(asin(1.0-2.0*x)/3.0);\n}\n\nfloat fastinvsmoothstep_naive(in float y)\n{\n  float yn = 2.0*y-1.0;\n  float t = 0.0;\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n  return t + 0.5;  \n}\n\nfloat fastinvsmoothstep_linearguess_animated(in float y)\n{\n  float freq = 0.2;\n  float alpha = (0.5*sin(2.0*PI*freq*iTime)+0.5);\n  float yn = 2.0*y-1.0;\n  float t = (2.0+alpha)*yn/6.0;\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n  return t + 0.5;  \n}\n\nfloat fastinvsmoothstep_linearguess(in float y)\n{\n  float yn = 2.0*y-1.0;\n  float t = 0.45*yn;\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n#if IS_SECOND_UPDATE_STEP // Uncomment for increased precision\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n#endif    \n  return t + 0.5;  \n}\n\nfloat fastinvsmoothstep_edgeoption1_animated(in float y)\n{\n  float freq = 0.2;\n  float alpha = (0.5*sin(2.0*PI*freq*iTime)+0.5);\n  float yn = 2.0*y-1.0;\n  float p = 20.0*alpha;\n  float k = 0.5;\n  float t = k*sign(yn)*pow(abs(yn), p);\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n#if IS_SECOND_UPDATE_STEP // Uncomment for increased precision\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n#endif    \n  return t + 0.5;  \n}\n\nfloat fastinvsmoothstep_edgeoption1(in float y)\n{\n  float yn = 2.0*y-1.0;\n  float t = 0.5*abs(yn)*yn*yn*yn;\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0-EPSILON);\n#if IS_SECOND_UPDATE_STEP // Uncomment for increased precision\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0-EPSILON);\n#endif    \n  return t + 0.5;     \n}\n\nfloat fastinvsmoothstep_edgeoption2_animated(in float y)\n{\n  float freq = 0.2;\n  float alpha = (0.5*sin(2.0*PI*freq*iTime)+0.5);\n  float yn = 2.0*y-1.0;\n  float p = 20.0*alpha;\n  float k = -0.25;\n  float t = k*sign(yn)*pow(abs(yn), p);\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n#if IS_SECOND_UPDATE_STEP // Uncomment for increased precision\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n#endif    \n  return t + 0.5;  \n}\n\nfloat fastinvsmoothstep_edgeoption2(in float y)\n{\n  float yn = 2.0*y-1.0;\n  float t = -0.25*yn*yn*yn;\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n#if IS_SECOND_UPDATE_STEP // Uncomment for increased precision\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0-EPSILON);\n#endif    \n  return t + 0.5; \n}\n\nfloat fastinvsmoothstep_combined_animated(in float y)\n{\n  float freq = 0.2;\n  float alpha = (0.5*sin(2.0*PI*freq*iTime)+0.5);\n  float r = 20.0*alpha;\n  float yn = 2.0*y-1.0;\n  float beta = pow(abs(yn), r);\n  float t = mix(0.45*yn, 0.5*abs(yn)*yn*yn*yn, beta);\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n#if IS_SECOND_UPDATE_STEP // Uncomment for increased precision\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0);\n#endif    \n  return t + 0.5; \n}\n\nfloat fastinvsmoothstep_combined(in float y)\n{\n  float yn = 2.0*y-1.0;\n  float absyn3 = abs(yn)*yn*yn;\n  float t = 0.45*yn+0.5*yn*(absyn3*absyn3-0.9*absyn3);\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0-EPSILON);\n#if IS_SECOND_UPDATE_STEP // Uncomment for increased precision\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0-EPSILON);\n#endif    \n  return t + 0.5; \n}\n    \nfloat sinasind3(in float y)\n{\n  float yn = -y;\n  float t = 0.45*yn;\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0-EPSILON);\n#if IS_SECOND_UPDATE_STEP // Uncomment for increased precision\n  t -= ( t*(4.0*t*t-3.0) + yn) / (12.0*t*t-3.0-EPSILON);\n#endif    \n  return -t;\n}\n\n// NOTE: Based on https://www.shadertoy.com/view/MsSBRh\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float dx = 1.0/iResolution.y;\n    vec2  p = ( vec2((iResolution.y-iResolution.x)/2.0,0.0)+fragCoord)/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    if( p.x>0.0 && p.x<1.0 )\n    {\n        // background\n        col = vec3( 0.2 + 0.02*mod(floor(p.x*10.0)+floor(p.y*10.0),2.0) );\n        \n        // blue: analytic invsmoothstep\n        {\n        float y = invsmoothstep( p.x );\n        float dy = invsmoothstep(p.x-sign(p.x-0.5)*dx) - y; // distance estimation\n        float di = abs(p.y-y)/sqrt(dx*dx+dy*dy);                 // https://iquilezles.org/articles/distance\n        col = mix( col, vec3(0.0,0.4,0.8), 1.0-smoothstep( 0.0, 2.0, di ) );\n        }\n        \n        // yellow: fast invsmoothstep\n        {\n        float y = fastinvsmoothstep( p.x );\n        float dy = fastinvsmoothstep(p.x-sign(p.x-0.5)*dx) - y; // distance estimation\n        float di = abs(p.y-y)/sqrt(dx*dx+dy*dy);                 // https://iquilezles.org/articles/distance\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0, di ) );\n        }\n        \n\t\t// red: error\n        {\n        float y = 0.5 /* center */ + 1.0 /* scale */ * ( fastinvsmoothstep( p.x ) - invsmoothstep( p.x ) );\n        float di = abs(p.y-y)/sqrt(2.0)/dx;\n        col = mix( col, vec3(0.7,0.2,0.0), 1.0-smoothstep(0.0, 1.5, di ) );\n        }\n\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}