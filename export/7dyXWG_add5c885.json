{"ver":"0.1","info":{"id":"7dyXWG","date":"1635188851","viewed":284,"name":"Analog Overshoot Simulation","username":"Astherix","description":"Tweak bias and tension parameters with mouse X and Y.\n\nThe overshoot effect is achieved with Hermite interpolation (https://en.wikipedia.org/wiki/Hermite_interpolation)\n\nA simple low-pass filter is also applied to simulate downsampling or Y/C separation.","likes":3,"published":1,"flags":32,"usePreview":1,"tags":["analog","ntsc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Input on Buffer A's iChannel0\n\n#define FIR_SIZE 4\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 s;\n\n    for (int i = -FIR_SIZE; i <= FIR_SIZE; i++) {\n        vec2 uv = vec2(fragCoord.x + float(i), fragCoord.y)/iResolution.xy;\n\n        s = s + texture(iChannel0, uv).xyz;\n    }\n    \n    s /= (float(FIR_SIZE) * 2.0) + 1.0;\n\n    fragColor = vec4(s, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hermite(float y0, float y1, float y2, float y3, float m, float tension, float bias) {\n    float m2 = m*m,\n          m3 = m2*m,\n          m0 =      (y1-y0)*(1.0+bias)*(1.0-tension)/2.0;\n          m0 = m0 + (y2-y1)*(1.0-bias)*(1.0-tension)/2.0;\n    float m1 =      (y2-y1)*(1.0+bias)*(1.0-tension)/2.0;\n          m1 = m1 + (y3-y2)*(1.0-bias)*(1.0-tension)/2.0;\n    float a0 =  2.0*m3 - 3.0*m2 + 1.0,\n          a1 =      m3 - 2.0*m2 + m,\n          a2 =      m3 -     m2,\n          a3 = -2.0*m3 + 3.0*m2;\n     \n     return (a0*y1+a1*m0+a2*m1+a3*y2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 fcm1 = vec2(fragCoord.x-4.0, fragCoord.y)/iResolution.xy,\n         fcm0 = vec2(fragCoord.x-0.0, fragCoord.y)/iResolution.xy,\n         fcp1 = vec2(fragCoord.x+4.0, fragCoord.y)/iResolution.xy,\n         fcp2 = vec2(fragCoord.x+8.0, fragCoord.y)/iResolution.xy;\n    \n    vec3 y0 = texture(iChannel0, fcm1).xyz,\n         y1 = texture(iChannel0, fcm0).xyz,\n         y2 = texture(iChannel0, fcp1).xyz,\n         y3 = texture(iChannel0, fcp2).xyz;\n    \n    vec3 o = y1;\n         \n    float l = iMouse.x/iResolution.x, y = iMouse.y/iResolution.y;\n         \n    vec3 f = vec3(\n        hermite(y0.x, y1.x, y2.x, y3.x, l, y, y * 50.0),\n        hermite(y0.y, y1.y, y2.y, y3.y, l, y, y * 50.0),\n        hermite(y0.z, y1.z, y2.z, y3.z, l, y, y * 50.0)\n    );\n\n    fragColor = vec4(f, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}