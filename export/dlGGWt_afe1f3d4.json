{"ver":"0.1","info":{"id":"dlGGWt","date":"1684851371","viewed":77,"name":"Wow! This is crazy!","username":"Noedell","description":"This is not a dam! This is a party!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["crazylight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 resolution = iResolution.xy;\n    vec2 uv = fragCoord.xy / resolution.xy;\n    \n    // Number of colors to choose from\n    const int numColors = 16;\n    \n    // Randomly select a color index\n    int colorIndex = int(mod(floor(iTime), float(numColors)));\n    \n    // Array of colors\n    vec3 colors[numColors];\n    colors[0] = vec3(1.0, 0.0, 0.0);   // Red\n    colors[1] = vec3(0.0, 1.0, 0.0);   // Green\n    colors[2] = vec3(0.0, 0.0, 1.0);   // Blue\n    colors[3] = vec3(1.0, 1.0, 0.0);   // Yellow\n    colors[4] = vec3(1.0, 0.0, 1.0);   // Magenta\n    colors[5] = vec3(0.0, 1.0, 1.0);   // Cyan\n    colors[6] = vec3(1.0, 0.5, 0.0);   // Orange\n    colors[7] = vec3(0.0, 0.5, 1.0);   // Light Blue\n    colors[8] = vec3(1.0, 0.0, 0.5);   // Pink\n    colors[9] = vec3(0.5, 1.0, 0.0);   // Lime Green\n    colors[10] = vec3(0.5, 0.0, 1.0);  // Purple\n    colors[11] = vec3(0.0, 1.0, 0.5);  // Sea Green\n    colors[12] = vec3(1.0, 0.5, 0.5);  // Light Pink\n    colors[13] = vec3(0.5, 1.0, 0.5);  // Light Green\n    colors[14] = vec3(0.5, 0.5, 1.0);  // Light Purple\n    colors[15] = vec3(0.0, 0.5, 0.5);  // Dark Cyan\n    \n    // Get the current color based on the index\n    vec3 color = colors[colorIndex];\n    \n    // Strobe light effect\n    float flicker = sin(iTime * 20.0) * 0.5 + 0.5;\n    color *= flicker;\n    \n    \n    // Cube rotation\n    vec2 center = resolution * 0.5;\n    vec2 normalizedPos = (fragCoord - center) / min(resolution.x, resolution.y);\n    float rotationAngle = iTime * 0.5;\n    float cubeSize = 0.3;\n    \n    vec2 rotatedPos;\n    rotatedPos.x = normalizedPos.x * cos(rotationAngle) - normalizedPos.y * sin(rotationAngle);\n    rotatedPos.y = normalizedPos.x * sin(rotationAngle) + normalizedPos.y * cos(rotationAngle);\n    \n    // Draw cube\n    float cube = max(abs(rotatedPos.x), abs(rotatedPos.y)) - cubeSize;\n    float cubeEdges = max(abs(rotatedPos.x), abs(rotatedPos.y)) - cubeSize * 0.95;\n    float cubeLines = min(abs(rotatedPos.x), abs(rotatedPos.y)) - cubeSize * 0.95;\n    float cubeEffect = smoothstep(0.01, 0.0, abs(cubeEdges)) * (1.0 - smoothstep(0.01, 0.0, abs(cubeLines)));\n    color += cubeEffect;\n    \n    // Output the final color\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}