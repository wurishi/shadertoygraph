{"ver":"0.1","info":{"id":"4sdXRB","date":"1460035308","viewed":197,"name":"collab x cabbibo 2 ","username":"macbooktall","description":"cabbibo and i are ping ponging some code and rendering gifs and this march is from the second we made here: https://assets.ello.co/uploads/asset/attachment/3779581/ello-optimized-6da2d75e.gif\n\nuse mouse to adjust camera","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["prism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// https://iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n// Includes code from hg_sdf library by Mercury http://mercury.sexy/hg_sdf/\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.00001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS =500;\n\nvec3 lightPos = vec3( .9 , .8 , .6 );\nvec3 camDir;\nfloat difVal;\nfloat prismSize = 0.6 + cos(iTime*4.)*0.05;\n\n#define MOUSE_CAM\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\np = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\nfloat fOctahedron(vec3 p, float r) {\nfGDFBegin\nfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\nfGDFEnd\n}\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat pNoise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n  \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\nfloat rz = 0.;\n    vec3 bp = p;\nfor (float i=0.; i<=3.; i++ )\n{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\nz *= 1.5;\np *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n}\nreturn rz;\n}\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2, .1 );\n    return f;\n    \n}\n\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 m )\n{\n    float an = 0.3 + 10.0*m.x;\n    \n    //float an  = -iTime * .1 * 3.14159;\n    #ifdef MOUSE_CAM    \n\tcamPos = vec3(5.5*sin(an),(m.y - .5) * 4.,5.5*cos(an));\n    #else\n    camPos = vec3(5.5*sin(3.14159*1.95),1.,5.5*cos(3.14159*1.95));\n    #endif\n    camTar = vec3(-0.05,0.0,0.0);\n}\n\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n   return (-d1.x>d2.x) ? vec2( -d1.x , d1.y ) : d2;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 smoothU( vec2 d1, vec2 d2, float k)\n{\n    float a = d1.x;\n    float b = d2.x;\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return vec2( mix(b, a, h) - k*h*(1.0-h), mix(d2.y, d1.y, pow(h, 2.0)));\n}\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \nreturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n \n\nvec2 prism( vec3 pos, float size ){\n    \n    pos -= vec3( 0., -.6 , 0. );\n    \n    float octDist = fOctahedron( pos  , size );\n    float planeDist = sdPlane( pos , vec4( 0., 1. , 0. , 0. ) );\n    \n    float dist = opS(  planeDist , octDist );\n    \n    return vec2( dist , 1. );\n    \n}\n\n\nvec4 grow = vec4( 1. );\n\nvec3 mapP( vec3 p )\n{\n    p.xyz += .050*sin(  8.*p.zxy)*grow.x;\n    p.xyz += 0.0850*sin(  12.0*p.yzx+ sin(iTime*4.)*1.8)*grow.y;\n    p.xyz += 0.05*sin(  5.0*p.yzx+ cos(iTime*4.)*1.8 )*grow.z;\n    p.xyz += 0.060*sin( 4.0*p.yzx)*grow.w;\n    return p;\n}\n\n\nvec2 rotate(vec2 v, float a){\n\tfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\n\nvec2 goo( vec3 pos ){\n\n    pos.xz = rotate(pos.xz, sin(iTime*4.)*0.1);\n    \n    vec3 nPos = mapP( pos - vec3( -.4 , -.2 , 0.0) );\n    \n    difVal = length(nPos -( pos - vec3( -.5 , -.2 , 0.0) ));\n\n    float dist = length( nPos ) - .6 + cos(iTime * 4.)*0.08;\n    \n    pos -= vec3( 0., -.7 , 0. );\n    \n    // second larger prism\n    float octDist = prism( pos , prismSize ).x;\n    float planeDist = sdPlane( pos , vec4( 0., 1. , 0. , 0. ) );\n    \n    float prisDist = octDist;\n    \n    \n    //vec2 res = opS( vec2( prisDist , 2.) , vec2( dist , 3. ));\n   // dist = opS( prisDist , dist );\n    \n   //vec2 res = vec2( dist , 3.);\n    \n    \n    return vec2( dist * .03 , 2. );\n    \n    \n}\n\nvec2 lightMap( vec3 pos ){\n\n    \n   float dist =length( pos - lightPos ) - .3;\n    \n    return vec2( dist , 4. );\n    \n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos , float io ){  \n   \n    vec2 idx =vec2(1.);\n    \n    float clock = iTime*4.;\n    float phase = (idx.y+idx.x)*3.14159;\n    \n    float anim = sin(phase + clock);\n    \n    vec2 crystal = prism( pos, prismSize );\n    vec2 flow = goo( pos + vec3(0.,anim*0.025,0.)  );\n    \n    vec2 res2 = smoothU( crystal , flow , .2 );// vec2(smin(crystal.x, flow.x, 0.15), 3.);\n    \n    vec2 l = lightMap( pos );\n    //res = opU( res , l );\n    \n    res2.x *= io;\n\n   \treturn res2;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd  , in float io){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\nfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n  vec2 m = map( ro+rd*t , io );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax , float io )\n{\nfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {\nfloat h = map( ro + rd*t , io).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor , float io )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos , io).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n#define STEPS 10\nvec3 fogCube( vec3 ro , vec3 rd , vec3 n ){\n \n    float lum = 1.;\n    \n    vec3 col = vec3( 0. );\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * .1  * float( i );\n\n        lum += triNoise3D( p * .5 , 1.2);// + sin( p.y * 3. ) + sin( p.z * 5.);\n    \n       //\tcol += hsv( lum / 10. + .8 , 1. , 1. ) * ( float(STEPS) - float(i)) / float(STEPS) * lum;\n        \n        col += vec3( .2 , 0. , 0.2) * lum * lum * lum * 1. / (float( i)+1.);\n    }\n    \n    return col/float(STEPS);\n    \n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos , in float io ){\n    \nvec3 eps = vec3( 0.001, 0.0, 0.0 );\nvec3 nor = vec3(\n   map( pos+eps.xyy , io ).x - map( pos-eps.xyy , io ).x,\n   map( pos+eps.yxy , io ).x - map( pos-eps.yxy , io ).x,\n   map( pos+eps.yyx , io ).x - map( pos-eps.yyx , io ).x );\nreturn normalize(nor);\n}\n\n\nvec3 noiseNormal( vec3 pos ){\n return normalize( vec3(hash(pos.x) , hash( pos.y ), hash( pos.z) ) );  \n}\n\n\n\n\nvec3 doGooCol( vec3 p , vec3 n , float id ){\n  \n    vec3 lightDir = normalize(lightPos - p);\n    \n    float match = dot( lightDir , n );\n    float ao = calcAO( p , n , 1. );\n    \n    vec3 fNorm = normalize(noiseNormal( p * 100. ) + n);\n   \tvec3 refl = reflect( lightDir ,fNorm );\n    \n    float rMatch = dot( refl , camDir );\n    \n    \n    if( id - 1.96 < .01 ){\n      \tvec3 sparkle = rMatch *  vec3( 1.3 , .7 , 0. );\n    \treturn sparkle + match * vec3( 1. , .6 , 0. );\n    \n       \n    }\n    \n    \n    float v = length( p - vec3( 0. ) );\n    \n  \tvec3 rb = hsv( difVal * .4 + .9 , .9 , .8 );\n    \n   // return vec3( 1. ) * ao * ao * ao * 60. * (rMatch * rMatch * rMatch + match);// rb * rMatch * ao + vec3(1.,.5 , 0.)*rMatch;\n     \n   return vec3( 1. ) * ao * ao * ao * 60.; \n}\n\nvec3 doBGCol( vec3 p  ){\n return vec3( triNoise3D( p * .1 , .0 ) );   \n}\nvec3 doSecondColor( vec3 rd , vec3 p , vec3 n  ){\n    \n    float ior = .9;\n    float dRay = .02;\n    //First break it into rays\n    \n    vec3 rR = refract( rd , n , ior + dRay );\n    vec3 rG = refract( rd , n , ior );\n    vec3 rB = refract( rd , n , ior - dRay );\n    \n    \n    vec2 resR = calcIntersection( p + rR * .01 , rR , -1. );\n    vec2 resG = calcIntersection( p + rG * .01 , rG , -1. );\n    vec2 resB = calcIntersection( p + rB * .01 , rB , -1. );\n    \n    vec3 col = vec3( 1.6 , .2 , 0. );\n    \n    //return col;\n    \n    float fc = length( fogCube( p * .1 , rd , n  ) );\n    \n    //return doCol( 1. , p , n );//col * vec3( pow( fc , 2.) - .5 );\n    \n    \n    \n    // BUGS\n    if( resR.y < -.5 || resG.y < -.5 || resB.y < -.5){\n        col = vec3( 0. , .5 , 0.); \n    }else{\n\n    \n        vec3 pR = p + rR * (resR.x +.01);\n        vec3 pG = p + rG * (resG.x +.01);\n        vec3 pB = p + rB * (resB.x +.01);\n\n        vec3 nR = calcNormal( pR , -1. );\n        vec3 nG = calcNormal( pG , -1. );\n        vec3 nB = calcNormal( pB , -1. );\n\n        vec3 r2R = refract( rR , nR , ior + dRay );\n        vec3 r2G = refract( rG , nG , ior );\n        vec3 r2B = refract( rB , nB , ior - dRay );\n\n        vec2 res2R = calcIntersection( pR + r2R * .01 , r2R , 1. );\n        vec2 res2G = calcIntersection( pG + r2G * .01 , r2G , 1. );\n        vec2 res2B = calcIntersection( pB + r2B * .01 , r2B , 1. );\n\n\n         // BUGS\n        if( res2R.y < -.5 || res2G.y < -.5  || res2B.y < -.5 ){\n            \n            vec3 c = vec3( 1. , 0., 0.);\n            \n            vec3 p2R = pG + r2R * (2. +.01);\n            vec3 p2G = pR + r2G * (2. +.01);\n            vec3 p2B = pG + r2B * (2. +.01);\n\n            \n             col = c.xyy * doBGCol( p2R ) \n                + c.yxy * doBGCol( p2G )  \n                + c.yyx * doBGCol( p2B );\n            \n            col *= vec3( .4 , .6 , 1.3 );; \n            //col *= vec3( 1.);\n        }else{\n            \n            \n            vec3 p2R = pG + r2R * (res2R.x +.01);\n            vec3 p2G = pR + r2G * (res2G.x +.01);\n            vec3 p2B = pG + r2B * (res2B.x +.01);\n\n            \n            vec3 n2R = calcNormal( p2R , 1. );\n            vec3 n2G = calcNormal( p2G , 1. );\n            vec3 n2B = calcNormal( p2B , 1. );\n            \n            \n            \n            vec3 c = vec3( 1. , 0., 0.);\n            \n            col = c.xyy * doGooCol( p2R , n2R, res2R.y ) \n                + c.yxy * doGooCol( p2G , n2G, res2G.y )  \n                + c.yyx * doGooCol( p2B , n2B, res2B.y );\n            \n            //col *= .8;\n           \n            col *= vec3( .4 , .6 , 1.3 );\n            //col *= vec3( 1. );//\n           \n\n           \n            //col = c;\n        }\n        \n\n    }\n    \n    \n    \n    \n    \n    \n    return col ;\n    \n    \n}\n\n\nvec3 doCol( float id , vec3 p , vec3 n ){\n    \n    vec3 lightDir = lightPos - p;\n    \n    float match = dot( normalize( lightDir ) , n );\n    float ao = calcAO( p , n , 1. );\n    \n    if( id < 1.95 ){\n    \tvec3 c =  doSecondColor( camDir , p , n );\n        return c; //vec3( 1. , 0.,  0.);\n        \n    }else{\n     return doGooCol( p , n , id );// - (n * .5 + .5); \n        \n    }\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    grow.x = 1.9 + sin(iTime*4.)*.1;//(sin( iTime * 4. ) + 10. ) / 10.;\n    \n    grow.y = 1.8 + cos(iTime*4.)*.1;//(sin( iTime * 8. ) + 10. ) / 10.;\n    grow.z = 2.2 + sin(iTime*4.)*.1;//(sin( iTime * 16. ) + 10. ) / 10.;\n     grow.w = 2.3 + cos(iTime*4.)*.1;//(sin( iTime * 32. ) + 10. ) / 10.;\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.01+sin(iTime*4.)*0.01 );  // 0.0 is the camera roll\n    \n// create view ray\nvec3 rd = normalize( camMat * vec3(p.xy,3.5) ); // 2.0 is the lens length\n    \n    camDir = rd;\n    \n    vec2 res = calcIntersection( ro , rd , 1.  );\n\n\n    vec3 col = vec3( 0.);\n    \n\n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos , 1. );\n        \n        vec3 depthColor = fogCube( pos , rd , norm  );\n \t\t\n        col = doCol( res.y , pos , norm );\n        \n        \n    }else{\n        \n       vec3 c = doBGCol( ro + rd * 2. );\n     col = vec3(.2, 0.5, 1.) *c * c*c * 5.; \n        \n    }\n\tcol = pow( col, vec3(.792545) );\n\n    fragColor = vec4( col , 1. );\n\n\n\n}","name":"Image","description":"","type":"image"}]}