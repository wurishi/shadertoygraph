{"ver":"0.1","info":{"id":"tlSXzD","date":"1565398666","viewed":177,"name":"Ciel sacr√©","username":"hamtarodeluxe","description":"A simple 2D shader based on domain repetition in polar coordinates :-)\nOriginal art from a friend of mine : https://www.instagram.com/p/B03t1VhCrNY/\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","eye","sky","stars","night","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define SOFT 0.0035\n\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    float v = mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n              \t             dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n              \t        mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n              \t             dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n              \t   mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n              \t             dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n              \t        mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n              \t             dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n\treturn v;\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float v = mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                        dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                   mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                        dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n\treturn v;\n}\n\nfloat fbm (vec2 p)\n{\n\treturn noise(p)+0.5*noise(p*2.);\n}\n\nfloat fbm (vec3 p)\n{\n    float n =0.;\n    float s = 1.;\n    for (int i = 0; i<6; i++)\n    {\n\t \tn+= noise (p*s)/s;\n    \ts*=2.;\n\t}\n    return n;\n}\nfloat band(float x,float mid, float thickness)\n{\n\treturn smoothstep (mid-thickness,mid,x)-smoothstep(mid, mid+thickness,x);\n}\n\nfloat ring(float rMin, float rMax, float l, float soft)\n{\n    return  smoothstep (rMin-soft,rMin,l)-smoothstep(rMax, rMax+soft,l);    \n}\n\nfloat sat(float x){return clamp(x,0.,1.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    vec2 uvNorm = uv*2.;\n\n    uv *= 0.0035;\n    uv *= iResolution.xy;\n    vec2 oldUv = uv;\n    \n    uv += vec2(cos(0.5*iTime),sin(0.33*iTime))*0.045;\n\n    float pol = atan(uv.y,uv.x)+PI;\n    float rad = length(uv); \n    \n    float deform = 0.02 * noise(vec3(7.*oldUv, iTime));\n    \n    float rMin = 0.06 + deform +sin(iTime*0.5)*0.015;;\n    float rMax = 0.35 + deform;\n    float limit = 0.18 + deform ;\n    float bands = step(limit,rad);\n    float thickness = 0.0018*3.;   \n\tfloat sp = 0.25;\n    float nSlice = mix(7.,9.,bands);\n   \tfloat slice = 2.*PI / nSlice;\n    \n    pol+=iTime*mix(0.05,-0.05,bands);\n    \n    uv.x = cos(pol)*rad;\n    uv.y = sin(pol)*rad;\n    \n\t// Main shape   \n    float t1 =  1.-(smoothstep(rMin, rMin +0.5*(limit-rMin),rad)-smoothstep(rMin +0.5*(limit-rMin),limit,rad));\n    float t2 =  1.-(smoothstep(limit, limit +0.5*(rMax-limit),rad)-smoothstep(limit +0.5*(rMax-limit),rMax,rad));\n    float nMap = mix(t1,t2,step(limit,rad));\n    float reshape = 1.0;\n    float nStr = 0.03 / pow(rad,0.85);  \n    float nFq = 7.;\n    float offsetStr = 0.2;\n    \n    //(pass1)\n    float pol1 = pol;       \n    float rot = slice*3.5*bands;\n    float s = step(rad,limit);\n    pol1 += rot;    \n    float cellPol =-rot+(floor((pol+rot+0.5*slice)/(slice))+0.5)*(slice);\n    float cellId = floor((mod(pol1+0.5*slice,2.*PI)/slice));\n    float offset = hash(vec2(cellId,0.)).x*rad;\n    vec2 cp = normalize(vec2(cos(cellPol),sin(cellPol)));\n    pol1 = mod(pol1+0.5*slice,slice)-0.5*slice;   \n    float n = nStr*4.*(fbm(uv*nFq-cp*iTime*sp+rad*2.));\n    float li1 = band(pol1+n+offsetStr*offset,0.,thickness/(rad));\n    n = mix(n, nStr*4.*(fbm(uv*nFq-cp*iTime*sp+rad*2.+5000.)),nMap);\n    li1 = max(li1,band(pol1+n+offsetStr*offset,0.,thickness/(rad)));   \n    \n    //(pass2)\n    pol1 = pol;       \n    rot = slice*0.5+slice*3.5*bands;\n    s = step(rad,limit);\n    pol1 += rot;    \n    cellPol =-rot+(floor((pol+rot+0.5*slice)/(slice))+0.5)*(slice);\n    cellId = floor((mod(pol1+0.5*slice,2.*PI)/slice));\n    offset = hash(vec2(cellId,1.)).x*rad;\n    cp = normalize(vec2(cos(cellPol),sin(cellPol)));\n    pol1 = mod(pol1+0.5*slice,slice)-0.5*slice;   \n    n = nStr*4.*(fbm(uv*nFq-cp*iTime*sp+rad*2.+2000.));\n    float li2 = band(pol1+n+offsetStr*offset,0.,thickness/(rad));\n    n = mix(n,nStr*4.*(fbm(uv*nFq-cp*iTime*sp+rad*2.+5000.)),nMap);\n    li2 = max(li2,band(pol1+n+offsetStr*offset,0.,thickness/(rad)));\n   \n    float li = max (li1,li2);\n    \n    float zoneMid = ring(0.,rMin,rad,SOFT);\n    float mid =  (fbm(vec3(oldUv*150.,iTime*0.5)))-0.2;\n\tfloat ring0 = ring(rMin,rMin+0.002,rad,SOFT);\n    float ringlim = ring(limit,limit+0.002,rad,SOFT);\n    float zone = ring(rMin,rMax,rad,SOFT);\n\t\n    li = max(max(li,ring0),ringlim);\n\tli = min (li,zone);\n    li = max(li,mid*zoneMid);\n    \n    zone = ring(0.,rMax,rad,SOFT+0.01);\n            \n    vec3 liCol = mix(vec3(0.4), 1.5*vec3(0.16,0.14,0.025) , ring(0.,limit-SOFT,rad,SOFT));\n    vec3 bgCol = mix(vec3(0.001,0.0045,0.1429),vec3(0.0087),zoneMid);\n    vec3 mainShape = mix(bgCol*zone,liCol,li);\n    \n    //Stars\n    pol = atan(oldUv.y,oldUv.x)+PI;\n    rad = length(oldUv);    \n    slice = 2.*PI/50.;\n    float radSlice = 40.*pow(rad,0.24);\n \t\n    //(pass1)\n    cellPol = floor(pol/slice);\n    float cellRad = floor(-0.25*iTime+radSlice);\n    vec2 cellSpace = vec2(fract(pol/slice), fract(-0.25*iTime+radSlice));\n    vec3 cellH = hash(vec3(cellRad,cellPol,50.))*0.5+0.5;\n       \n    float starRad = (cellH.y*0.032+0.02)/rad;\n    float starProb = cellH.x;\n    float starOs = cellH.z-0.5;\n    float starLum = cellH.z;\n    float stars = starProb>0.4 ? 0. : starLum*smoothstep(starRad+0.01,0.01,length(-starOs+cellSpace-0.5));\n    \n    //(pass2)\n    pol +=0.5*slice;\n    cellPol = floor(pol/slice);\n    cellRad = floor(-0.5*iTime+150.+radSlice);\n    cellSpace = vec2(fract(pol/slice), fract(-0.5*iTime+radSlice));\n    cellH = hash(vec3(cellRad,cellPol,50.))*0.5+0.5;\n       \n    starRad = (cellH.y*0.032+0.02)/rad;\n    starProb = cellH.x;\n    starOs = cellH.z-0.5;\n    starLum = cellH.z;\n    stars = max(stars, starProb>0.4 ? 0. : starLum*smoothstep(starRad+0.01,0.01,length(-starOs+cellSpace-0.5)));\n    stars = sat(stars);\n    \n    //Background\n    float bgNoise = fbm(vec3(2.*oldUv/pow(rad,0.35),iTime*0.175))*0.5+0.5;\n    bgNoise = sat (bgNoise);\n\tvec3 col = vec3(0);// \n    vec3 cbg1 = 0.25*vec3(0.00450,.0049,0.0138); vec3 cbg2 = vec3(0.0052,0.0055,0.03);\n    col = mix(cbg1,cbg2,bgNoise);\n    col = mix(col, 1.*vec3(0.003,0.003,0.035), smoothstep(0.5,0.71,bgNoise));\n    col = mix(col*0.75,col,  smoothstep(0.3,0.35,bgNoise));\n\tcol *=0.75;\n    stars += (0.2*sat(mid) *(smoothstep(0.5,0.7,bgNoise)-smoothstep(0.9,1.,bgNoise)));\n    col += mix (col, vec3(0.3),stars);\n    \n    col = mix (col, mainShape, zone);\n    \n    //shadow\n    pol = atan(uv.y,uv.x) + PI;\n    rad = length(uv); \n    \n    pol += noise(vec2(rad*50.,0.5*iTime));\n    pol = mod(pol, 2.*PI);   \n    float v = sat((1.-zone)*(1.-(rad-rMax )/ (0.05+sin(pol*2.)*0.025)));\n    col = mix(col, col*0.2, v);\n    \n    //vignette and noise\n    col = mix(col,col*0.5,hash(oldUv).x);\n    col *= 1./pow((pow(sqrt(dot(uvNorm,uvNorm)*.4),2.)+1.),2.5);\n    \n    //texture\n    float pap = 1.-length((fract(oldUv*70.+vec2(0.,noise(0.5*oldUv*100.+5000.)))-0.5)/0.7);\n\tpap = sat(pap+0.5);\n\tcol *= pap;\n    \n    //the end\n    col = pow(col,vec3(0.45));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}