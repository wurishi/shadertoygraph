{"ver":"0.1","info":{"id":"sss3WN","date":"1639580906","viewed":155,"name":"Ray Marching walk around","username":"Pro_Coder","description":"This is a small ray march test\n\nControls: \n- WASD to walk\n- SPACE to go up\n- SHIFT to go down\n- CTRL to go fast\n- left-click on the left side, to rotate camera left\n- left-click on the right side, to rotate camera right","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n//#define SHOW_NORMALS\n#define RENDER_DISTANCE 40.\n#define MAX_STEPS 1000\n#define MIN_DISTANCE 0.00001\n#define MAX_REFLECTIONS 50\n#define REFLECION_COLOR_FACT 0.93\n\n//Objects\n#define NO_HIT_MATERIAL Material(vec3(0.0, 0.0, 1.0), 0.0, 0.0, false, 0.0, false)\n#define NO_HIT_ID 0\n#define UNKNOWN_ID -1\n\n#define SPHERE_1     Sphere(vec3(1.0, 1.0, 0.0) M, 0.5 M)\n#define SPHERE_LIGHT Sphere(vec3(0.0, 3.5, 1.0) + vec3(sin(iTime)) , 0.2 M)\n#define Y_PLANE_1    YPlane(-1. M)\n#define BOX_1        Box(vec3(0.0, 1.0, 1.7) M, vec3(1.5, 1.5, 1.5) M)\n//#define PLAYER\n//#define OPEN_BOX_1   OpenBox(vec3(-3., 0.0, 1.) M, vec3(5.5) M, vec3(5.49) M)\n#define BOX_2        Box(vec3(0.0, 1., -1.7) M, vec3(1.5, 1.5, 1.5) M)\n#define MS           Box(world.msPos.xyz, vec3(5.5, 2.5, 0.5))\n\n\n#define SPHERE_1_MATERIAL     Material(vec3(1.0, 0.0, 0.0), 1.0, 0.0, false, 0.0, true)\n#define SPHERE_LIGHT_MATERIAL Material(vec3(1.0),           0.0, 0.0, true, 1.0, true)\n#define Y_PLANE_1_MATERIAL    Material(vec3(1.0, 0.0, 0.0), 0.0, 0.0, false, 0.0, true)\n#define BOX_1_MATERIAL        Material(vec3(0.0, 1.0, 0.0), 0.1, 0.0, false, 0.0, true)\n#define PLAYER_MATERIAL       Material(vec3(0.2, 0.6, 1.0), 0.0, 0.0, false, 0.0, true)\n#define OPEN_BOX_1_MATERIAL   Material(vec3(0.5, 0.5, 0.5), 0.0, 0.0, false, 0.0, true)\n#define BOX_2_MATERIAL        Material(vec3(0.0, 1.0, 0.0), 1.0, 0.0, false, 0.0, true)\n#define MS_MATERIAL           Material(vec3(0.2, 0.6, 1.0), 0.0, 1.5, false, 0.0, true)\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n};\n\nstruct YPlane\n{\n    float y;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n};\n\nstruct Material\n{\n    vec3 color;\n    float reflectiveness;\n    float roughness;\n    bool lightSource;\n    float light;\n    bool visible;\n};\n\n//world information and current frame information\nstruct World\n{\n    vec4 camPosition; // cam pos (xyz) and distanceToScreen (w)\n    vec3 viewDirection;\n    vec3 msPos;\n    vec3 rayDirection;\n} world;\n\nstruct OpenBox\n{\n    vec3 center; //center of outer box\n    vec3 sizeOuter;\n    vec3 sizeInner;\n    \n};\n\nconst Material materials[] = Material[9](\n                              NO_HIT_MATERIAL,        //0\n                              SPHERE_1_MATERIAL,      //1\n                              SPHERE_LIGHT_MATERIAL,  //2\n                              Y_PLANE_1_MATERIAL,     //3\n                              BOX_1_MATERIAL ,        //4\n                              PLAYER_MATERIAL,        //5\n                              OPEN_BOX_1_MATERIAL,    //6\n                              BOX_2_MATERIAL,         //7\n                              MS_MATERIAL             //8\n                            );\n                            \n                         \n\n//functions\nfloat vmax(vec3 a){\n    return max(a.z, max(a.x, a.y));\n}\n\nvec3 noise(vec3 p){\n   return fract(cos(p) * vec3(897432.2342366, 783582.4365865, 245579.543546764));\n}\n\nfloat rand(vec3 p){\n    return fract(sin(dot(p, vec3(243.12325, 6753.4365865, 9665.43252))) * 245579.543546764);\n}  \n\nvec3 noise2(vec3 p){\n    \n    return vec3(rand(p), rand(noise(p)), rand(p+vec3(123.432, 1234.768, 6574.453)));\n}\n\n\n//SDF functions\nfloat sdfYPlane(vec3 pos, YPlane plane){\n    return pos.y - plane.y;\n}\n\nfloat sdfSphere(vec3 pos, Sphere s){\n    return length(pos - s.position) - s.radius;\n}\n\nfloat sdfBox(vec3 p, Box box){\n    p -= box.center;\n    vec3 d = abs(p) - box.size*.5;\n    float m = (vmax(d));\n    return max(length(min(sign(d) + vec3(1.), 1.) * d), abs(m)) * sign(m);\n}\n\nfloat sdfPlayer(vec3 p){\n    vec3 camPosition = GET(iChannel1, CAM_POS_TEXEL).xyz;\n    vec3 viewDirection = GET(iChannel1, VIEW_DIR_TEXEL).xyz;\n    \n    return length(p - (camPosition - viewDirection*.4 M)) - 0.4 M;\n}\n\nfloat sdfOpenBox(vec3 p, OpenBox box){\n    p -= box.center;\n    float dis = 100.0;\n\n    float sizeX = 1.;\n    float sizeZ = 1.;\n\n    Box ground = Box(vec3(0.0), vec3(sizeX, 0.5, sizeZ));\n    dis = sdfBox(p, ground);\n    \n    vec3 c1 = texture(iChannel3, p.xz*0.09).xyz;\n    vec3 c2 = texture(iChannel3, p.xy*0.0943255).xyz;\n    vec3 c3 = texture(iChannel3, p.xz*0.0733).xyz;\n\n    c1 = mix(c1, c2, 0.5);\n    c1 = mix(c1, c3, .5);\n     \n    return dis - c1.r;\n}\n\n\nint getDistance(vec3 pos, out float dis){\n    dis = RENDER_DISTANCE * 2.;\n    float sphere1 = 100.;\n    float sphereLight = 100.;\n    float yPlane1 = 100.;\n    float box1 = 100.;\n    float player = 100.;\n    float openBox1 = 100.;\n    float box2 = 100.;\n    float ms = 100.; \n    \n    #ifdef SPHERE_1\n        sphere1 = sdfSphere(pos, SPHERE_1);\n        dis = min(dis, sphere1);\n    #endif\n    \n    #ifdef SPHERE_LIGHT\n        sphereLight = sdfSphere(pos, SPHERE_LIGHT);\n        dis = min(dis, sphereLight);\n    #endif\n    \n    #ifdef Y_PLANE_1\n        //make plane go up and down\n       \n        vec3 c1 = texture(iChannel3, pos.xz*0.005).xyz;\n        vec3 c2 = texture(iChannel3, pos.xz*0.005).xyz;\n        vec3 c3 = texture(iChannel3, pos.xz*0.0233).xyz;\n        c1 = mix(c1, c2, 0.5);\n        c1 = mix(c1, c3, .5);\n        \n        c1 -= 0.3;\n        \n        yPlane1 = sdfYPlane(pos, Y_PLANE_1)-(c1.r*7.*pow(min(1.0, length(pos.xz*0.05)), 3.));\n        \n        dis = min(dis, yPlane1);\n    #endif\n    \n    #ifdef BOX_2\n        box2 = sdfBox(pos, BOX_2);\n        dis = min(dis, box2);\n    #endif\n    \n    #ifdef BOX_1\n        box1 = sdfBox(pos, BOX_1);\n        dis = min(dis, box1);\n    #endif \n    \n    #ifdef PLAYER\n        player = sdfPlayer(pos);\n        dis = min(dis, player);\n    #endif\n    \n    #ifdef OPEN_BOX_1\n        openBox1 = sdfOpenBox(pos, OPEN_BOX_1);\n        dis = min(dis, openBox1);\n    #endif\n    \n    #ifdef MS\n        ms = sdfBox(pos, MS);\n        dis = min(dis, ms);\n    #endif\n         \n    if(dis <= MIN_DISTANCE){\n        if(dis == sphere1){\n            return 1;\n        }else if(dis == sphereLight){\n            return 2;\n        }else if(dis == yPlane1){\n            return 3;\n        }else if(dis == box1){\n            return 4;\n        }else if(dis == player){\n            return 5;\n        }else if(dis == openBox1){\n            return 6;\n        }else if(dis == box2){\n            return 7;\n        }else if(dis == ms){\n            return 8;\n        }\n    }else if(dis > MIN_DISTANCE){\n        return NO_HIT_ID;\n    }\n\n    return UNKNOWN_ID;\n}\n\nfloat getDistance(vec3 pos){\n    float d;\n    getDistance(pos, d);\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n \tfloat d = getDistance(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(getDistance(p - e.xyy), getDistance(p - e.yxy), getDistance(p - e.yyx));\n    return normalize(n);\n}\n\nint rayMarch(inout vec3 pos, vec3 rd, float fact){\n    \n    int outId;\n    float dis = MIN_DISTANCE*90.;\n    float cDis = RENDER_DISTANCE*2.;\n    \n    pos = pos + rd * dis;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n       outId = getDistance(pos, cDis);\n       cDis *= fact;\n       \n       \n       if(cDis <= MIN_DISTANCE){\n           //hit  \n          \n           return outId;\n           \n       }else if(dis > RENDER_DISTANCE){\n           return NO_HIT_ID;\n           //No hit\n       }\n       \n       dis += cDis;\n       pos = pos + rd * cDis;\n       \n    }\n    \n    //No hit\n    return UNKNOWN_ID;\n\n}\n\n\n\nstruct State\n{\n    bool isSky;\n    vec3 newPos;\n    vec3 normal;\n    Material mat;\n    vec3 lightPos;\n    vec3 light;\n};\n\nState stateMarch(vec3 pos, inout vec3 rd){\n    vec3 p = pos;\n    \n    //hit\n    int hitId = max(0, rayMarch(p, rd, 1.)); \n    Material mat = materials[hitId];\n    vec3 normal = getNormal(p);\n    \n    if(mat.roughness != 0.0){\n        //raymarch inside object\n        rd = refract(rd, normal, 1./mat.roughness);\n        hitId = max(0, rayMarch(p, rd, -1.));\n        \n        //we are out again\n        normal = -getNormal(p);\n        vec3 rdOut = refract(rd, normal, mat.roughness);\n        for(uint i = 0u; i < 7u && rdOut.x*rdOut.y*rdOut.z == 0.0; i++){\n            \n            rd = reflect(rd, normal);\n            hitId = max(0, rayMarch(p, rd, -1.));\n            //we are out again\n            normal = -getNormal(p);\n            rdOut = refract(rd, normal, mat.roughness);\n           \n        }\n        \n        hitId = max(0, rayMarch(p, rdOut, 1.));\n \n        mat = materials[hitId];\n        normal = getNormal(p);\n        \n    }\n    \n    if(hitId == 0){\n        return State(true, p, vec3(0.), mat, vec3(0.), vec3(mat.light));\n    }else if(hitId == 3){\n        //make plane darker and lighter in some places\n        vec3 c = texture(iChannel2, p.xz*0.1).xyz;\n        vec3 c1 = texture(iChannel3, p.xz*0.0005).xyz;\n        vec3 c2 = texture(iChannel3, p.xz*0.005).xyz;\n        vec3 c3 = texture(iChannel3, p.xz*0.000233).xyz;\n        \n        c1 = mix(c1, c2, 0.5);\n        c1 = mix(c1, c3, .5);\n        \n        mat.color = c*c1.r;\n    }\n    \n    \n    \n    //light\n    vec3 lightDirection = normalize(SPHERE_LIGHT.position - p);\n    vec3 posL = p;\n    int hitIdL = (rayMarch(posL, lightDirection, 1.));\n    Material matL = materials[hitIdL];\n    vec3 light = vec3(matL.light);\n    \n    return State(false, p, normal, mat, posL, light); \n}\n\nvec3 calcSky(State state, vec3 rd){\n    vec3 v = rd + world.camPosition.xyz/RENDER_DISTANCE;\n    \n    //sun\n    //when xz is 0.0, the sun is in x direction\n    //when xz is PI/2, the sun is in z direction\n    float t = (fract(iTime*.001)-.5)*2.; //\n    float xzAngle = -0.6 + (t*.5)*PI*2.; //0.0 - PI*2.\n    float yAngle = sin(t*PI)*PI*0.5;  //0.0 - PI/2.\n    \n    \n    vec3 sunPos = normalize(vec3(cos(xzAngle), sin(yAngle), sin(xzAngle)))+ world.camPosition.xyz/RENDER_DISTANCE;\n    float disToSun = length(sunPos - v);\n    \n    \n    \n    \n    float fog = (0.1 - clamp(0.0, 0.1,v.y*0.5))*8.; //1.0 for fog\n    float sunrise = pow(min(1.0, abs(yAngle*1.2)), 3.);// 0.0 for sunrise\n    float y = v.y *0.2;\n    vec3 cout = vec3(0.2-y , 0.5-y*.5 , 0.8 +y*y);\n    vec3 fogColor = mix(vec3(1.,0.5, 0.5), vec3(0.55, 0.67, 0.67), sunrise);\n    cout = mix(cout, fogColor , clamp(0.0, 1.0, fog*fog)); \n    \n    if(disToSun < 0.1) cout = vec3(1.0);\n    \n    return cout;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Screen coordinates from -1 to 1.\n    vec2 uv = (fragCoord - iResolution.xy*.5)*2. / iResolution.y;\n    \n    //output color\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    //move sphere\n    world.msPos = GET(iChannel1, MS_POS_TEXEL).xyz;\n\n    //Camera\n    #ifdef USE_LOOK_AT\n        vec3 lookAt = world.msPos;\n        world.camPosition.xyz = LOOK_AT_CAM_POS;\n        world.camPosition.w = GET(iChannel1, CAM_POS_TEXEL).w; // load zoom\n        world.viewDirection = normalize(lookAt - world.camPosition.xyz);\n    #else\n        world.camPosition = GET(iChannel1, CAM_POS_TEXEL);\n        world.viewDirection = GET(iChannel1, VIEW_DIR_TEXEL).xyz;\n    #endif\n    float distanceToScreen = world.camPosition.w;\n    \n    //Virtual Screen\n    float screenSizeFactor = 1.0 M; //The actual screen size depends on the uv\n    vec3 screenNormal = world.viewDirection; //The screen is always perpendicular to the viewDirection\n    vec3 screenTangent = normalize(WORLD_NORMAL + (dot(WORLD_NORMAL, screenNormal) * -screenNormal)); //vector in the direction of the height of the screen\n    vec3 screenBiTangent = normalize(cross(screenNormal, screenTangent)); //vector in direction of the width of the screen\n    \n    //World-position of the pixel\n    vec3 pixelPos = world.camPosition.xyz\n    + (world.viewDirection * distanceToScreen)\n    + (uv.y * screenTangent * screenSizeFactor)\n    + (uv.x * screenBiTangent * screenSizeFactor);\n    \n    vec3 rayDirection = normalize(pixelPos - world.camPosition.xyz);\n    world.rayDirection = rayDirection;\n    \n    \n    \n    \n    \n    //Ray Marching\n    State state = stateMarch(world.camPosition.xyz, rayDirection);\n    if(state.isSky){\n        col = calcSky(state, rayDirection);\n            //SKY\n    }else{\n        if(state.mat.reflectiveness > 0.0){\n            vec3 reflectDirection = rayDirection;\n            for(int c = 0; c < MAX_REFLECTIONS; c++){\n\n                reflectDirection = reflect(reflectDirection, state.normal);\n                state = stateMarch(state.newPos, reflectDirection);\n                if(state.isSky){\n                    col = calcSky(state, reflectDirection)*pow(REFLECION_COLOR_FACT, float(c*c)+1.);\n                        //SKY\n                    break;\n                }else{\n                    if(state.mat.reflectiveness > 0.0){\n                         \n                         col = state.mat.color*pow(REFLECION_COLOR_FACT, float(c)+1.);\n                       \n                    }else{\n                        col = state.mat.color*pow(REFLECION_COLOR_FACT, float(c)+1.);\n                        col = col * max(0.5, state.light.r);\n                        break;\n                    }\n                }\n                \n            }    \n        }else{\n            col = state.mat.color;\n            col = col * max(0.5, state.light.r);\n        }\n    }\n    \n    if(!state.isSky){\n        \n    }\n    \n    #ifdef SHOW_NORMALS\n        col = abs(getNormal(state.newPos));\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n//example isKey(KEY_A, IS_PRESSED)\nbool isKey(float checkKey, float type){\n    return texture( iChannel0, vec2(checkKey, type)).r > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n     \n    if(iFrame > 0) {\n        if(DO_SAVE(CAM_POS_TEXEL)){\n            vec4 pos = GET(iChannel1, CAM_POS_TEXEL);\n            vec4 vdir = GET(iChannel1, VIEW_DIR_TEXEL);\n            vec3 tdir = cross(WORLD_NORMAL, vdir.xyz);\n            float speed = MOVE_SPEAD;\n            \n            //move fast\n            if(isKey(KEY_CTRL, IS_PRESSED)){\n                speed *= 10.;\n            }\n            \n            //move cam\n            if(isKey(KEY_W, IS_PRESSED)){//forward\n                pos.xyz += vdir.xyz * speed;\n            }\n            if(isKey(KEY_S, IS_PRESSED)){//backward\n                pos.xyz -= vdir.xyz * speed;\n            }\n            if(isKey(KEY_A, IS_PRESSED)){//left\n                pos.xyz += tdir * speed;\n            }\n            if(isKey(KEY_D, IS_PRESSED)){//right\n                pos.xyz -= tdir * speed;\n            }\n            if(isKey(KEY_SHIFT, IS_PRESSED)){\n                pos.y -= 1.0 * speed;\n            }\n            if(isKey(KEY_SPACE, IS_PRESSED)){\n                pos.y += 1.0 * speed;\n            }\n            \n            //Zoom\n            if(isKey(KEY_C, IS_PRESSED)){\n                pos.w *= 1.052631578947368;\n            }\n            if(isKey(KEY_X, IS_PRESSED)){\n                pos.w *= 0.95;\n            }\n            \n            fragColor = pos;\n            return;\n            \n        }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec4 viewDirection = GET(iChannel1, VIEW_DIR_TEXEL);\n            \n            if(iMouse.z > 0.0){\n                vec4 oldMouse = GET(iChannel1, OLD_MOUSE_TEXEL);\n                vec2 mouseOffset = iMouse.xy - oldMouse.xy;\n\n                float angleXZ = atan(viewDirection.x, viewDirection.z);\n                angleXZ -= ((iMouse.x-iResolution.x*.5)/iResolution.x)*PI*0.05;\n \n\n             \n                viewDirection.xyz = normalize(vec3(sin(angleXZ), viewDirection.y, cos(angleXZ)));\n            }\n            fragColor = viewDirection;\n            return;\n            \n        }else if(DO_SAVE(OLD_MOUSE_TEXEL)){\n            fragColor = iMouse;\n            return;\n            \n        }else if(DO_SAVE(MS_POS_TEXEL)){\n            vec4 pos = GET(iChannel1, MS_POS_TEXEL);\n            \n            vec3 z = vec3(0.0, 0.0, MOVE_SPEAD);\n            vec3 x = vec3(MOVE_SPEAD, 0.0, 0.0);\n            float y = MOVE_SPEAD;\n        \n            if(isKey(KEY_ARROW_UP, IS_PRESSED)){//forward\n                pos.xyz += z;\n            }\n            if(isKey(KEY_ARROW_DOWN, IS_PRESSED)){//backward\n                pos.xyz -= z;\n            }\n            if(isKey(KEY_ARROW_LEFT, IS_PRESSED)){//left\n                pos.xyz += x;\n            }\n            if(isKey(KEY_ARROW_RIGHT, IS_PRESSED)){//right\n                pos.xyz -= x;\n            }\n            if(isKey(KEY_NUMPAD_0, IS_PRESSED)){\n                pos.y -= y;\n            }\n            if(isKey(KEY_NUMPAD_1, IS_PRESSED)){\n                pos.y += y;\n            }\n        \n            fragColor = pos;\n             \n         }\n         \n    }else{\n         //initial values\n         if(DO_SAVE(CAM_POS_TEXEL)){\n            fragColor = vec4(CAM_START_POS, CAM_DIS_TO_SCREEN);\n\n         }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec3 viewDirection = normalize(LOOK_AT_POSITION - CAM_START_POS);\n            fragColor = vec4(viewDirection, 1.0);\n\n         }else if(DO_SAVE(OLD_MOUSE_TEXEL)){\n             fragColor = iMouse;\n             \n         }else if(DO_SAVE(MS_POS_TEXEL)){\n             fragColor = vec4(LOOK_AT_POSITION, 1.0);\n             \n         }\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.1415926\n\n//World stuff\n//#define USE_LOOK_AT\n#define LOOK_AT_POSITION vec3(0.0, 1.0, 3.0)\n#define LOOK_AT_CAM_POS vec3(0.0, 7., -7.)\n\n#define CAM_START_POS vec3(0., 1., 0.)\n#define CAM_DIS_TO_SCREEN 1.0\n#define WORLD_NORMAL vec3(0.0, 1.0, 0.0)\n#define M\n#define MOVE_SPEAD 0.1\n\n//Saving variables\n#define DO_SAVE(texel) (ivec2(fragCoord) == texel)\n#define GET(buffer, texel) (texelFetch(buffer, texel, 0))\n\n#define CAM_POS_TEXEL   ivec2(0, 0)\n#define VIEW_DIR_TEXEL  ivec2(0, 1)\n#define OLD_MOUSE_TEXEL ivec2(1, 0)\n#define MS_POS_TEXEL    ivec2(1, 1)\n\n\n\n\n\n\n//Keyboard\n#define NUMBER_OF_KEYS 256.\n#define IS_PRESSED 0.0\n#define ON_PRESS 0.5\n#define BUFFFER_PRESS 1.0\n\n#define KEY_TAB 10./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ENTER 14./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SHIFT 17./NUMBER_OF_KEYS - 1./512.\n#define KEY_CTRL 18./NUMBER_OF_KEYS - 1./512.\n#define KEY_ALT 19./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SPACE 33./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ARROW_LEFT 38./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_UP 39./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_RIGHT 40./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_DOWN 41./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_0 49./NUMBER_OF_KEYS - 1./512.\n#define KEY_1 50./NUMBER_OF_KEYS - 1./512.\n#define KEY_2 51./NUMBER_OF_KEYS - 1./512.\n#define KEY_3 52./NUMBER_OF_KEYS - 1./512.\n#define KEY_4 53./NUMBER_OF_KEYS - 1./512.\n#define KEY_5 54./NUMBER_OF_KEYS - 1./512.\n#define KEY_6 55./NUMBER_OF_KEYS - 1./512.\n#define KEY_7 56./NUMBER_OF_KEYS - 1./512.\n#define KEY_8 57./NUMBER_OF_KEYS - 1./512.\n#define KEY_9 58./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_NUMPAD_0 97./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_1 98./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_2 99./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_3 100./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_4 101./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_5 102./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_6 103./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_7 104./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_8 105./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_9 106./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_GREATER 61./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SS 64./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_A 66./NUMBER_OF_KEYS - 1./512.\n#define KEY_B 67./NUMBER_OF_KEYS - 1./512.\n#define KEY_C 68./NUMBER_OF_KEYS - 1./512.\n#define KEY_D 69./NUMBER_OF_KEYS - 1./512.\n#define KEY_E 70./NUMBER_OF_KEYS - 1./512.\n#define KEY_F 71./NUMBER_OF_KEYS - 1./512.\n#define KEY_G 72./NUMBER_OF_KEYS - 1./512.\n#define KEY_H 73./NUMBER_OF_KEYS - 1./512.\n#define KEY_I 74./NUMBER_OF_KEYS - 1./512.\n#define KEY_J 75./NUMBER_OF_KEYS - 1./512.\n#define KEY_K 76./NUMBER_OF_KEYS - 1./512.\n#define KEY_L 77./NUMBER_OF_KEYS - 1./512.\n#define KEY_M 78./NUMBER_OF_KEYS - 1./512.\n#define KEY_N 79./NUMBER_OF_KEYS - 1./512.\n#define KEY_O 80./NUMBER_OF_KEYS - 1./512.\n#define KEY_P 81./NUMBER_OF_KEYS - 1./512.\n#define KEY_Q 82./NUMBER_OF_KEYS - 1./512.\n#define KEY_R 83./NUMBER_OF_KEYS - 1./512.\n#define KEY_S 84./NUMBER_OF_KEYS - 1./512.\n#define KEY_T 85./NUMBER_OF_KEYS - 1./512.\n#define KEY_U 86./NUMBER_OF_KEYS - 1./512.\n#define KEY_V 87./NUMBER_OF_KEYS - 1./512.\n#define KEY_W 88./NUMBER_OF_KEYS - 1./512.\n#define KEY_X 89./NUMBER_OF_KEYS - 1./512.\n#define KEY_Y 90./NUMBER_OF_KEYS - 1./512.\n#define KEY_Z 91./NUMBER_OF_KEYS - 1./512.\n","name":"Common","description":"","type":"common"}]}