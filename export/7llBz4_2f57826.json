{"ver":"0.1","info":{"id":"7llBz4","date":"1650687332","viewed":88,"name":"SDF Surface Side Atmosphere v1","username":"Rugged","description":"Atmosphere from surface sdf try 1. I'm not sure what's going wrong with being able to see the sun before it passes above the ground. Any ideas? Also the sun seems to be pulsing. I need to get rid of the camera blow out effect too.\n\nMouse to turn camera.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","surface","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define r1 1.\n#define gr1 .7\n#define c1 vec3(0.)\n#define r2 1.\n#define c2 vec3(0., 4., 0.)\n#define ep 1.\n\nfloat sdfSphere(vec3 p, vec3 c, float radius){\n\n    \n    return length(p - c) - radius;\n}\n\nfloat sdfSphere2(vec3 p, vec3 c, float radius){\n    return length(p - c) - 0.;\n}\n\nfloat sdfMainPlane(vec3 p, vec3 n, float h){\n    return dot(p, n) + h;\n}\n\nfloat sdfMainBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx, vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\nfloat color2(float x, float a, float x0){\n    return 1. / (exp(abs(a * (x - x0))));\n}\n\n\nvec3 quaternionVectorRotation(vec3 v, vec4 q){\n    vec3 rowOne = vec3(1. - (2. * ((q.z * q.z) + (q.w * q.w))), 2.* ((q.y * q.z) - (q.x * q.y)), 2. * ((q.x * q.z) + (q.y * q.w)));\n    vec3 rowTwo = vec3(2. * ((q.y * q.z) + (q.x * q.w)), 1. - (2. * ((q.y * q.y) + (q.w * q.w))), 2. * ((q.y * q.z) + (q.x * q.w)));\n    vec3 rowThree = vec3(2. * ((q.y * q.w) - (q.x * q.z)), 2. * ((q.x * q.y) + (q.z * q.w)), 1. - (2. * ((q.y * q.y) + (q.z * q.z))));\n    \n    mat3 r = mat3(rowOne, rowTwo, rowThree);\n    return r * v;\n}\n\n\n\n\nvec4 quaternionMult(vec4 a, vec4 b){\n    return vec4(a.x * b.x - dot(a.yzw, b.yzw), a.x*b.yzw + b.x*a.yzw + cross(a.yzw, b.yzw));\n}\n\n\nvec3 generateReflectionVector(vec3 normal, vec3 inV){\n    return inV - (2. * normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n        \n    vec4 col = vec4(0.);\n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    //float phi = radians(180.);\n    //float theta = radians(105.);\n    float phi = radians(360. * (1.- muv.x));\n    float theta = radians(180. * (1. - muv.y));\n\n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(0., cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    \n    \n    float rad90 = radians(90.);\n    \n    float fov = 110.;\n    \n    float xAng = radians(fov * (.5 - uv.x));\n    //replace \"fov\" with \"(fov + (110. * pow(.5 - uv.x, 2.)))\" below to add a counteractment to the fisheye lens effect\n    //it basically counteracts the artifact with quaternions that happens when you rotate by a large angle on one axis then try to rotate on another axis perpendicular, it just rotates around it thus making the new direction lesser\n    float yAng = radians(fov * screenRatio * (.5 - uv.y));\n    \n    //get the axes that the quarternions should be based around (perpendicular to the camera plane or dv)\n    vec3 xRotAxis = vec3(cos(phi) * sin(theta - rad90), sin(phi) * sin(theta - rad90), cos(theta - rad90));\n    vec3 yRotAxis = cross(xRotAxis, camD.yzw);//vec3(cos(phi - rad90) * sin(theta), sin(phi - rad90) * sin(theta), cos(theta));\n    \n    //get the quarternions of the ray direction rotations\n    vec4 xQuat = vec4(cos(xAng / 2.), xRotAxis * sin(xAng / 2.));\n    vec4 yQuat = vec4(cos(yAng / 2.), yRotAxis * sin(yAng / 2.));\n    \n    \n    \n    //combine the rotations\n    vec4 compQuat = quaternionMult(yQuat, xQuat);\n    \n    \n    \n    //get the conjugate of the compQuart\n    vec4 conjComp = vec4(compQuat.x, -compQuat.yzw);\n\n    \n    //ray direction\n    vec3 rayD = quaternionMult(quaternionMult(compQuat, camD), conjComp).yzw;\n    \n    \n    //############################################\n    \n    float t = 0.;\n    \n    float d = 100.;\n    \n    \n    vec3 p = vec3(0.);\n    \n    float m = 0.;\n    \n    \n    int steps = 300;\n    \n    \n    vec3 rayO = vec3(0., 0.1, 1.);\n    \n    vec3 pN = vec3(100., 100., .7);\n    \n    \n    \n    float slowT = iTime * .5;\n    \n    vec3 sunD = normalize(vec3(sin(slowT + 1.7), 0., cos(slowT + 1.7)));\n    \n    float cValue, cv2, surface, dp, ds, nx, ny, nz;\n    \n    vec3 q;\n    \n    vec3 camN = normalize(rayO - c1);\n    \n    mat3 epIden = mat3(ep);\n    \n    //sunD = vec3(0., 0., -1.);\n    \n    \n    float rs = dot(rayD, -sunD);\n    float rp = dot(rayD, vec3(0., 0., 1.));\n    float ps = dot(vec3(0., 0., 1.), -sunD);\n   \n    float r = ((1. - ((rp + 1.) / 2.)) * (1. - ((ps + 1.) / 2.))) * 2.2;\n    float g = 0.;\n    float b =(rs + .1) * rp;\n    \n    \n    \n    b = max(pow(1. - r, 10.), 0.);\n    g = ((r + b * 3.) / 2.);\n    \n    \n    //col = vec4(r, g, b, 1.);\n    \n    \n    //trace 1\n    for (int i = 0; i <= steps; i++){\n        //float nose = cos(iTime) + sin(iTime * 2.) + (.01 * sin(20. * iTime)) + cos(.1 * iTime) + sin(iTime + 1.);\n        p = rayO + (rayD * t);\n        \n        \n        \n        \n        \n        \n        dp = sdfMainBox(p, pN);\n        \n        \n        d = dp;\n        //add the scalar of 1 / d, scaled by .005, scaled by planet-sun dp, scaled by ray-sun dp, time the color of the sky vec4\n        col += ((ps * .005 * ((rs + 1. )/ 2.)) / (d * d)) * vec4(r, g * .4, b, 1.);\n        \n        //this should make it stop if it hits the ground but it seems like it gets\n        //through sometimes because we can see the sun\n        if(d < .001){\n            \n            col = vec4(.3, .6, .3, 1.) * max(ps, .1);\n            \n            break;\n        }\n        \n        if(distance(-sunD * 2., p) < .08 && p.z >= rayO.z){\n            col = vec4(1.);\n            break;\n        }\n        \n        \n                \n        t += min(d - .00001, 0.1);\n    }\n        \n    \n    \n    \n    \n    \n    \n    \n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}