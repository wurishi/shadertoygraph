{"ver":"0.1","info":{"id":"NssXD8","date":"1618581134","viewed":140,"name":"Task 2 Computer Graphics. ","username":"candelabrum","description":"Ray tracing. Minecraft into dodecahedron. Minecraft was used from here https://www.shadertoy.com/view/tslGRX","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","dodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1) ;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FAR_INF 1e9\n\n#define RAY_DEPTH 7 \n#define STACK_SIZE 130\n\n\n\n// NB! UNCOMMENT IS_OCCLUDED TO MAKE NORMAL MINECRAFT\n//const float INF = 1e10; \nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\n///const float pi = acos(-1.);\n\nvec3 CAMERA_POS = vec3(-0, 2.2, -6);\n\n// choose const vec3 LIGHT1_POS = vec3(0, 1.0, 1.5);\n/*const vec3 LIGHT1_POS = vec3(2, 0.0,0);\nconst float LIGHT1_SCALE = 0.25;\nconst float LIGHT1_RADIUS = 0.25;\nconst vec3 LIGHT1_COLOR = vec3(0.5, 0.5, 0.3);\n*/\n//const vec3 LIGHT2_POS = vec3(0,1,-5);\n/*const vec3 LIGHT2_POS = vec3(0,2,-0);\nconst float LIGHT2_SCALE = 0.25;\nconst float LIGHT2_RADIUS = 0.25;\nconst vec3 LIGHT2_COLOR = vec3(1, 0.2, 0.5);\n\nconst vec3 LIGHT3_POS = vec3(0,0,0);\nconst float LIGHT3_SCALE = 0.25;\nconst vec3 LIGHT3_COLOR = vec3(0.1,1,0.2);\n*/\nfloat cur_n;\n                     \nconst float GLASS_N=1.55;\nconst float AIR_N = 1.0;\nfloat n1 = AIR_N;\nfloat n2 = GLASS_N;\n/*float pow2(float x)\n{\n     return x*x;\n}*/\n\n\nfloat GLASS_R;\n\n\n/*float rand(float frame)\n{\n     return fract(sin(dot(vec3(frame), vec3(12.9898, 78.233, 45.5432)))*43758.5453);\n}*/\n\nvec3 randVals;\n\nbool isOccluded(vec3 pos, vec3 target);\n\n\n/* ------------------------------MINECRAFT_MAGIC------------------*/\nfloat noise(vec3 p)\n{\n    return textureLod(iChannel3, p, 0.0).x  ;\n}\n\nfloat cnoise(vec3 p)\n{\n    vec3 size = 1.0 / vec3(textureSize(iChannel3, 0));\n    return (\n        noise(p * size * 1.0 + vec3(0.52, 0.78, 0.43)) * 0.5 + \n        noise(p * size * 2.0 + vec3(0.33, 0.30, 0.76)) * 0.25 + \n        noise(p * size * 4.0 + vec3(0.70, 0.25, 0.92)) * 0.125) * 1.14;\n}\n\nbool voxel(vec3 vp)\n{\n    vp -= vec3(40, -10, -20);\n    //if (vp.y < cloud_height - 2.0)\n        return cnoise(vp * 0.05 - vec3(40.0, -10.0, -20.0)) + vp.y * -0.02 > threshold; \n    //return false;\n}\n\nTraceResult traceVoxel(vec3 p, vec3 d, float dist)\n{\n    TraceResult r;\n    r.hit = false;\n    r.n = -d;\n    r.r = dist;\n    \n    \n    vec3 id = 1.0 / d;\n    vec3 sd = sign(d);\n    vec3 nd = max(-sd, 0.0);\n    vec3 vp = floor(p) - nd * vec3(equal(floor(p), p));\n\n    for (int i = 0; i < MARCH_STEPS; ++i)\n    {\n        if (dist <= 0.0 || p.y > cloud_height * m_scale && d.y > 0.0 /*|| dot(r.p, r.p) > RADIUS_MINECRAFT*/)\n        \tbreak;\n\n        if (voxel(vp))\n        {\n\n\t\t\tr.vp = vp * m_scale;\n\t\t\tr.p = p * m_scale;\n\t\t\tr.r = dist;\n\t\t\tr.hit = true;\n            if (dot(r.p, r.p) > RADIUS_MINECRAFT)\n                r.hit = false;\n            \n            \n\t\t\treturn r;\n        }\n\n        vec3 n =  mix(floor(p + 1.0), ceil(p - 1.0), nd);\n\t\tvec3 ls = (n - p) * id;\n\t\tfloat l = min(min(ls.x, ls.y), ls.z);\n\t\tvec3 a = vec3(equal(vec3(l), ls));\n\n        p = mix(p + d * l, n, a);\n        vp += sd * a;\n        r.n = -sd * a;\n        dist -= l * m_scale;\n    }\n\n    return r;\n}\n\nfloat sample_ao(vec3 vp, vec3 p, vec3 n)\n{\n    const float s = 0.5;\n    const float i = 1.0 - s;\n    vec3 b = vp + n;\n    vec3 e0 = n.zxy;\n    vec3 e1 = n.yzx;\n    float a = 1.0;\n    if (voxel(b + e0))\n        a *= i + s * sqi(fract(dot(-e0, p)));\n    if (voxel(b - e0))\n        a *= i + s * sqi(fract(dot(e0, p)));\n    if (voxel(b + e1))\n        a *= i + s * sqi(fract(dot(-e1, p)));\n    if (voxel(b - e1))\n        a *= i + s * sqi(fract(dot(e1, p)));\n    if (voxel(b + e0 + e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((-e0 - e1) * p)))));\n    if (voxel(b + e0 - e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((-e0 + e1) * p)))));\n    if (voxel(b - e0 + e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((e0 - e1) * p)))));\n    if (voxel(b - e0 - e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((e0 + e1) * p)))));\n    return a;\n}\n\nTraceResult TraceMineCraft(vec3 pos, vec3 dir)\n{\n    vec3 l1Norm;\n    vec3 curPos;\n    float view_distance = max(0.0, (404.0 - dot(pos, pos)));\n    float t;\n    TraceResult tr_res;   \n    \n    // INSIDE MINECRAFT\n    if (dot(pos, pos) > RADIUS_MINECRAFT)\n    {    \n        t = traceSphere(pos - SPHERE_POS, dir, SPHERE_RADIUS, l1Norm);\n    \n        curPos = pos + t * dir;\n    \n        tr_res = traceVoxel(curPos * im_scale, dir, view_distance);\n        //tr_res.p = curPos + t * dir\n        t += sqrt(dot(curPos - tr_res.p, curPos - tr_res.p));\n        \n        tr_res.sphereIntersect = curPos;\n    \n        return tr_res;\n    }\n    // IN MINECRAFT\n    tr_res = traceVoxel(pos * im_scale, dir, view_distance);\n    if (tr_res.hit == true)\n    {\n        tr_res.t = view_distance - tr_res.r;\n    }\n    else\n    {\n        tr_res.t = INF;\n    }   \n    \n    return tr_res;\n}\n\nfloat compute_light1_factor(vec3 pos, vec3 normal)\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    vec3 randDir = normalize(randVals - 0.5);\n    vec3 toLight1 = LIGHT1_POS-pos;\n    float distSq1 = dot(toLight1,toLight1);\n    float att1 = 40.0f/distSq1;\n    \n    for (int i = 0; i < 1; i++)\n    {\n        randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n        randDir = normalize(randVals - 0.5);\n        if (isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS))\n        {    \n            att1 = 0.0;\n            break;\n        }\n    }\n    \n    return (max(0.0,dot(normal,normalize(toLight1)))*att1\n );\n}\n\nfloat compute_light2_factor(vec3 pos, vec3 normal)\n{\n     vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n     vec3 randDir = normalize(randVals - 0.5);\n     vec3 toLight2 = LIGHT2_POS-pos;\n     float distSq2 = dot(toLight2,toLight2);\n     float att2 = 20.0f/distSq2; \n    \n     if (isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS))\n        att2 = 0.0;\n     return (\n         max(0.0, max(0.0,dot(normal,normalize(toLight2)))*att2\n ));\n}\n\nvec3 compute_minecraft_light(TraceResult r, vec3 p , vec3 d)\n{\n    const vec3 grass_color = vec3(0.63, 1.0, 0.31);\n    const vec3 dirt_color = vec3(0.78, 0.56, 0.4);\n    const vec3 ambient_color = vec3(0.5, 0.5, 0.5);\n    const vec3 sun_color = vec3(0.5, 0.5, 0.5);\n    \n    vec3 to_light1 = LIGHT1_POS - r.p;\n    const float view_distance = 75.0;\n    \n    vec3 to_light2 = LIGHT2_POS - r.p;\n    \n    float sun_factor = max(0.0, dot(r.n, sun_dir));\n    \n    float light1_factor = compute_light1_factor(r.p, r.n);\n    float light2_factor = compute_light2_factor(r.p, r.n);\n\n    float fog_factor = min(1.0, sq(length(r.p - p) / view_distance));\n    vec3 fog_color = background(d);\n\n    if (sun_factor > 0.0)\n    {\n         float sd = m_scale * (cloud_height - r.p.y) / sun_dir.y;\n         if (traceVoxel(r.p, sun_dir, sd).hit)\n             sun_factor = 0.0;\n    }\n   \n    float ambient_factor = sample_ao(im_scale * r.vp, im_scale * r.p, r.n);\n\n    float texel_noise = textureLod(iChannel3, im_scale * r.p * 0.5, 0.0).r;\n\n    float grass_mix = 0.0;\n    if (!voxel(r.vp + vec3(0, m_scale, 0)))\n    {\n         if (texel_noise * 4.0 + floor(fract(im_scale * r.p.y) * 16.0) > 15.0)\n             grass_mix = 1.0;\n         else\n             grass_mix = max(0.0, r.n.y);\n    }\n\n    vec3 texel = vec3(texel_noise) * 0.3 + 0.7;\n    vec3 diffuse = texel * mix(dirt_color, grass_color, grass_mix);\n    vec3 c = diffuse * (ambient_factor * ambient_color +\n                        sun_factor * sun_color  +\n                        light1_factor * LIGHT1_COLOR + \n                        light2_factor * LIGHT2_COLOR);\n\n    return mix(c, fog_color, fog_factor);\n}\n\n/* -------------------------------END_MINECRAFT_MAGIC-----------------*/\n\n\n\n\nvec3 computeLight(vec3 pos,vec3 color,vec3 normal)\n{\n     vec3 toLight1 = LIGHT1_POS-pos;\n     float distSq1 = dot(toLight1,toLight1);\n     float att1 = 20.0f/distSq1;\n     if (isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS))\n        att1 = 0.0;\n     vec3 toLight2 = LIGHT2_POS-pos;\n     float distSq2 = dot(toLight2,toLight2);\n     float att2 = 10.0f/distSq2;\n     if (isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS))\n        att2 = 0.0;\n     return color*(\n         max(0.0,dot(normal,normalize(toLight1)))*att1*LIGHT1_COLOR+\n         max(0.0,dot(normal,normalize(toLight2)))*att2*LIGHT2_COLOR+\n         texture(iChannel1,normal).rgb*0.6\n );\n}\n\nRay get_ray(vec2 uv)\n{\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(front,up));\n    up = normalize(cross(right,front));\n    vec3 viewVec = normalize(front+right*uv.x+up*uv.y);\n    \n    return Ray(CAMERA_POS, viewVec);\n}\n\nvoid drawPlane(Ray ray, inout TraceResult cur_ctxt)\n{\n    vec3 planeNorm;\n    float planeT = tracePlane(ray.pos, ray.dir, planeNorm);    \n    \n    if(planeT < cur_ctxt.t)\n    {\n        cur_ctxt.t = planeT;\n\n        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos; \n        cur_ctxt.color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n        cur_ctxt.n = planeNorm;\n\n        cur_ctxt.materialType = DIFFUSE;\n        /*if(randVals.y < 0.5)\n        {\n            cur_ctxt.materialType = REFLECTION;\n        }*/\n    }\n}\n\nvoid drawLight1(Ray ray, inout TraceResult cur_ctxt)\n{\n    vec3 l1Norm;\n    float light1T = traceSphere(ray.pos - LIGHT1_POS, ray.dir, \n                                        LIGHT1_RADIUS, l1Norm);\n    \n    if(light1T < cur_ctxt.t)\n    {\n        cur_ctxt.t=light1T;\n\n        cur_ctxt.materialType = EMISSION;\n        cur_ctxt.color=LIGHT1_COLOR;\n        cur_ctxt.n = l1Norm;\n        cur_ctxt.alpha = 0.0;\n    }\n\n}\n\nvoid drawLight2(Ray ray, inout TraceResult cur_ctxt)\n{\n    vec3 l2Norm;\n    float light2T = traceSphere(ray.pos - LIGHT2_POS, ray.dir, \n                                        LIGHT2_RADIUS, l2Norm);\n    \n    if(light2T < cur_ctxt.t)\n    {\n        cur_ctxt.t=light2T;\n\n        cur_ctxt.materialType = EMISSION;\n        cur_ctxt.color=LIGHT2_COLOR;\n        cur_ctxt.n = l2Norm;\n        cur_ctxt.alpha = 0.0;\n    }\n}\n\nvoid drawMineCraftNotBlur(Ray ray, inout TraceResult cur_ctxt)\n{\n    TraceResult tr_res;\n    float mineT;\n    tr_res = TraceMineCraft(ray.pos, ray.dir);\n\n    mineT = sqrt(dot(tr_res.p - ray.pos, tr_res.p - ray.pos)); \n    if (mineT < cur_ctxt.t && tr_res.hit == true)\n    {\n        cur_ctxt.color = vec3(compute_minecraft_light(tr_res, \n                                    tr_res.sphereIntersect, ray.dir));\n        cur_ctxt.n = tr_res.n;\n        \n        cur_ctxt.t = mineT;\n        //cur_ctxt.alpha = max(0.75, \n        //                    sqrt(sqrt(dot(tr_res.p, tr_res.p))));\n        cur_ctxt.alpha = GLOBAL_ALPHA;\n        cur_ctxt.materialType = EMISSION;\n    }\n}\n\nvoid drawCylinder(Ray ray, inout TraceResult cur_ctxt)\n{\n    vec3 cylNorm;\n    float cylT = traceCylinder(ray.pos, ray.dir, cylNorm);\n    \n    if(cylT < cur_ctxt.t)\n    {\n        cur_ctxt.t = cylT;\n        \n        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos;\n    \n        cur_ctxt.materialType = DIFFUSE; \n        cur_ctxt.color = 0.3*texture(iChannel2, worldPos.xz * worldPos.y).rgb \n                                        + 0.7*texture(iChannel3, ray.dir).rgb;\n        //cur_ctxt.color = vec3(1, 0, 0);\n        cur_ctxt.n = cylNorm;\n    }\n}\n/*HERE */\nvoid drawTriangle(Ray ray, inout TraceResult cur_ctxt, Triangle Triangle1)\n{\n    //float t = INF;\n    vec3 t_normal;\n    float t_trgl0 = intersectTriangle(ray.pos, ray.dir,\n                                  Triangle1.V0, Triangle1.V1, Triangle1.V2,\n                                  t_normal);\n    if (t_trgl0 < cur_ctxt.t) \n    {\n        cur_ctxt.t = t_trgl0;\n        //cur_ctxt.color = Triangle1.color;\n        ///cur_ctxt.color = 0.5 * t_normal + 0.5;\n        cur_ctxt.n = t_normal;\n        \n        if (randVals.x <  GLASS_R * 8.0) \n        {\n            cur_ctxt.materialType = REFLECTION;\n        } \n        else \n        { \n            cur_ctxt.materialType = REFRACTION;\n            if (cur_ctxt.cur_n == AIR_N) \n            {\n                cur_ctxt.prev_n = GLASS_N;\n            } \n            else \n            {\n                cur_ctxt.prev_n = AIR_N;\n            }\n        }   \n        \n        cur_ctxt.materialType = REFRACTION;\n    }\n}\n\nvoid drawPentagon(Ray ray, inout TraceResult cur_ctxt, Pentagon Pent1)\n{\n    drawTriangle(ray, cur_ctxt, Pent1.Triangle1);\n    drawTriangle(ray, cur_ctxt, Pent1.Triangle2);\n    drawTriangle(ray, cur_ctxt, Pent1.Triangle3);\n}\n\nvoid drawDodecahedron(Ray ray, inout TraceResult cur_ctxt)\n{\n    drawPentagon(ray, cur_ctxt, Pent1);\n    drawPentagon(ray, cur_ctxt, Pent2);\n    drawPentagon(ray, cur_ctxt, Pent3);\n    drawPentagon(ray, cur_ctxt, Pent4);\n    drawPentagon(ray, cur_ctxt, Pent5);\n    drawPentagon(ray, cur_ctxt, Pent6);\n    drawPentagon(ray, cur_ctxt, Pent7);\n    drawPentagon(ray, cur_ctxt, Pent8);\n    drawPentagon(ray, cur_ctxt, Pent9);\n    drawPentagon(ray, cur_ctxt, Pent10);\n    drawPentagon(ray, cur_ctxt, Pent11);\n    drawPentagon(ray, cur_ctxt, Pent12);\n}\n\nbool isOccluded(vec3 pos, vec3 target)\n{\n    TraceResult cur_ctxt;\n    Ray ray;\n    \n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n\n    vec3 dodNorm = vec3(0, 0, 0);\n    ray.dir = dir;\n    ray.pos = pos;\n    float dodT;\n    drawDodecahedron(ray, cur_ctxt);\n    dodT = cur_ctxt.t;\n    dodNorm = cur_ctxt.n;\n    if (dodT < dist && cur_ctxt.t > 0.0)\n        return true;\n    vec3 cylNorm = dodNorm;\n    float t = traceCylinder(pos, dir, cylNorm);\n    \n    if (t > 0.0 && t <= dodT)\n        return (true);\n        \n    TraceResult tr_res = TraceMineCraft(pos, dir);\n    if (tr_res.t < dist && tr_res.t > 0.0)\n        return true;\n}\n\nvec3 set_camera_pos(vec3 CAMERA_POS)\n{\n    //CAMERA_POS = vec3(0, 1.2, -6);\n    //CAMERA_POS.xy =  rotate(CAMERA_POS.xy, iTime/ 5.0);\n    //CAMERA_POS.yz =  rotate(CAMERA_POS.yz, iTime/ 5.0);\n    CAMERA_POS.xz =  rotate(CAMERA_POS.xz, iTime/ 5.0);\n    \n    return CAMERA_POS;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //CAMERA_POS = set_camera_pos(CAMERA_POS);\n    CAMERA_POS.xz =  rotate(CAMERA_POS.xz, 0.0);\n    GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    //GLASS_R = pow2(AIR_N - GLASS_N)/pow2(AIR_N + GLASS_N);\n    randVals = vec3(rand(float(iFrame + 3)), rand(float(iFrame+5)), rand(float(iFrame+15)));\n    randDir = normalize(randVals - 0.5);\n    \n    vec2 uv = (fragCoord-iResolution.xy*0.5 + 1.0*(randVals.xy-0.5))/iResolution.x;\n \n    Ray ray = get_ray(uv);\n    \n    TraceResult cur_ctxt;\n    \n    vec3 curPos = ray.pos;\n    vec3 curDir = ray.dir;\n    \n    float prev_n;\n    float cur_n = AIR_N;\n    cur_ctxt.prev_n = prev_n;\n    cur_ctxt.cur_n = cur_n;\n    for(int i=0; i<20; i++)\n    { \n         float t = INF;\n         int materialType;\n         vec3 color;\n         vec3 normal;\n         vec3 back;\n         \n\n         cur_ctxt.color = color;\n         cur_ctxt.n = normal;\n         cur_ctxt.materialType = materialType;\n         cur_ctxt.t = t;\n       \n         drawPlane(ray, cur_ctxt);\n         drawLight1(ray, cur_ctxt);\n         drawLight2(ray, cur_ctxt); \n         drawDodecahedron(ray, cur_ctxt);\n         drawCylinder(ray, cur_ctxt);\n         back = cur_ctxt.color;\n         drawMineCraftNotBlur(ray, cur_ctxt);\n         \n         if(cur_ctxt.t != INF)\n         {\n             vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos; \n\n             fragColor = texture(iChannel0, worldPos.xz);\n             if(cur_ctxt.materialType == EMISSION)\n             {\n                 //fragColor.rgb = mix(cur_ctxt.color, back, GLOBAL_ALPHA);\n                 fragColor.rgb = cur_ctxt.color;\n                 break;\n             } \n\n             else if(cur_ctxt.materialType == DIFFUSE)\n             {\n                 fragColor.rgb = computeLight(worldPos, cur_ctxt.color,\n                                                 cur_ctxt.n);\n                 break;\n             } \n             else if (cur_ctxt.materialType == REFLECTION)\n             {\n                 ray.dir = normalize(reflect(ray.dir, cur_ctxt.n));\n                 ray.pos = worldPos + ray.dir*1e-5;\n             } \n             else if(cur_ctxt.materialType == REFRACTION)\n             {\n                 ray.dir = refraction(ray.dir, cur_ctxt.n, cur_ctxt.cur_n, \n                                                              cur_ctxt.prev_n);\n                 ray.pos = worldPos + ray.dir*1e-5;\n                 \n                 //fragColor.rgb = vec3(1, 1, 1);\n              }\n         } \n         else \n         {\n             if (cur_ctxt.cur_n == AIR_N) \n             {\n                 //fragColor.rgb = color;\n                 //fragColor.rgb = cur_dir + vec3(0.3, 0.2, 0.3);\n                 fragColor.rgb = texture(iChannel1, ray.dir).rgb;\n             } \n             else \n             {\n                 //fragColor.rgb = texture(iChannel1, cur_dir).rgb;// * colorMult;\n                 fragColor.rgb = vec3(1.0, 0.0, 0.0);\n             }\n             break;\n         }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) \n                    + texture(iChannel1, uv) ;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// question? need i calculate compute_light for minecraft if i use ambient occlusion in weak realization ?\n// try to zoom minecraft to minimum 256 * 256 * 256 //\n#define EPS 1e-4\nconst float pi = 3.1415926536;\nconst float fov = 2.2;\nconst float cloud_height = 18.0;\nconst float threshold = 0.5;\nconst float clouds_threshold = 0.525;\nconst float sun_movement = 0.1;\n//const float zoom = 1.0;\nconst float size_window = 0.25;\nconst vec3 eye_movement = vec3(-4.0, 0.0, -1.0);\nconst vec3 cloud_movement = vec3(-1.0, 0.0, -1.5);\nconst vec3 eye_start = vec3(-40.0, 10.0, 20.0);\n\nvec3 clouds_offset;\nconst float t1 = 1.0;\nvec3 sun_dir = normalize(vec3(+0.5, 1.1, -0.0));\nvec3 SPHERE_POS = vec3(0, 0, 0);\n//const vec3 MINECRAFT_CAMERA_POS = vec3(0, 0.8, -0.8);\nconst vec3 MINECRAFT_SPHERE_POS = vec3(0, 0, 0);\nconst float SPHERE_RADIUS = 0.5;\nfloat MAX_STEP = 10.0;\nfloat MARCH_SIZE = 0.01;\nfloat INF = 1e10;\nconst float m_scale = 0.01; // IS MARCH_SIZE\nconst float im_scale = 1.0 / m_scale; // INVERSE STEP MARCH_SIZE\nconst float phi = (1.+sqrt(5.))*.5;\n\nconst float GLOBAL_ALPHA = 0.5;\n// NB! CONTROL PARAMETERS RADIUS_MINECRAFT, MARCH_STEPS..\nconst float RADIUS_MINECRAFT = float(SPHERE_RADIUS) + 0.05 * m_scale;\nconst int MARCH_STEPS = int(4.0*floor(RADIUS_MINECRAFT * im_scale));\n\nconst vec3 LIGHT1_POS = vec3(2, 1.4,-0);\nconst float LIGHT1_SCALE = 0.25;\nconst float LIGHT1_RADIUS = 0.25;\nconst vec3 LIGHT1_COLOR = vec3(0.5, 0.5, 0.3);\n\nconst vec3 LIGHT2_POS = vec3(0,1,-5);\nconst float LIGHT2_SCALE = 0.25;\nconst float LIGHT2_RADIUS = 0.25;\nconst vec3 LIGHT2_COLOR = vec3(1, 0.2, 0.5);\n\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nfloat sq(float x) { return x * x; }\nfloat sq(vec2 x) { return dot(x, x); }\nfloat sqi(float x) { return 1.0 - sq(1.0 - x); }\nfloat sqi(vec2 x) { return 1.0 - sq(1.0 - x); }\n\nvec3 background(vec3 d)\n{\n\tconst float sun_intensity = 1.0;\n    vec3 sun = (pow(max(0.0, dot(d, sun_dir)), 48.0) + pow(max(0.0, dot(d, sun_dir)), 4.0) * 0.25) * sun_intensity * vec3(1.0, 0.85, 0.5);\n    vec3 sky = mix(vec3(0.6, 0.65, 0.8), vec3(0.15, 0.25, 0.65), d.y) * 1.15;\n    return sun + sky;\n}\n\n \nvec3 randDir;\n\nstruct Ray\n{\n    vec3 pos, dir;\n//    float transparent;\n//    int depth;\n};\n\nstruct Triangle \n{\n    vec3 V0, V1, V2;\n    vec3 color;\n};\n\n\nconst float scale = 0.755;\n\n\nmat3 rotate3DX(float a) { return mat3(1.,0.,0.,0.,cos(a),-sin(a),0,sin(a),cos(a));}\nmat3 rotate3DY(float a) { return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 rotate3DZ(float a) { return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\nmat3 rotate3D(float x, float y, float z) { return rotate3DX(x)*rotate3DY(y)*rotate3DZ(z); }\n\n//const float angleX = 0.93\nconst float angleX = 0.888;\nconst float angleY = 0.0;\nconst float angleZ = 0.0;\nconst mat3 rotateX = mat3(  1., 0., 0.,\n                            0., cos(angleX), -sin(angleX),\n                            0, sin(angleX), cos(angleX) );   \nconst mat3 rotateY = mat3(cos(angleY), 0., sin(angleY), \n                          0., 1., 0.,\n                          -sin(angleY), 0., cos(angleY));\n                          \nconst mat3 rotateZ = mat3(cos(angleZ), -sin(angleZ), 0., \n                          sin(angleZ), cos(angleZ),  0.,\n                           0.   ,   0.  ,  1.);      \n\nconst mat3 rotateXYZ = rotateX * rotateY * rotateZ;                          \n                          \n                   \n\n//orange\nconst vec3 p1 = scale * vec3(1, 1, 1) * rotateXYZ;\nconst vec3 p2 = scale * vec3(-1, 1, 1) * rotateXYZ;\nconst vec3 p3 = scale * vec3(-1, -1, 1) * rotateXYZ;\nconst vec3 p4 = scale * vec3(1, -1, 1) * rotateXYZ;\n        \n\t//bottom\nconst vec3 p5 = scale * vec3(1, 1, -1) * rotateXYZ;\nconst vec3 p6 = scale * vec3(-1, 1, -1) * rotateXYZ;\nconst vec3 p7 = scale * vec3(-1, -1, -1) * rotateXYZ;\nconst vec3 p8 = scale * vec3(1, -1, -1) * rotateXYZ;\n\n        //green\n        \nconst vec3 p9 = scale * vec3(0, phi, 1.0/phi) * rotateXYZ;\nconst vec3 p10 = scale * vec3(0, -phi, 1.0/phi) * rotateXYZ;\nconst vec3 p11 = scale * vec3(0, -phi, -1.0/phi) * rotateXYZ;\nconst vec3 p12 = scale * vec3(0, phi, -1.0/phi) * rotateXYZ;\n\n        //blue\n\nconst vec3 p13 = scale * vec3(1.0/phi, 0, phi) * rotateXYZ;\nconst vec3 p14 = scale * vec3(-1.0/phi, 0, phi) * rotateXYZ;\nconst vec3 p15 = scale * vec3(-1.0/phi, 0, -phi) * rotateXYZ;\nconst vec3 p16 = scale * vec3(1.0/phi, 0, -phi) * rotateXYZ;\n\n        //pink\n\nconst vec3 p17 = scale * vec3(phi, 1.0/phi, 0) * rotateXYZ;\nconst vec3 p18 = scale * vec3(-phi, 1.0/phi, 0) * rotateXYZ;\nconst vec3 p19 = scale * vec3(-phi, -1.0/phi, 0) * rotateXYZ;\nconst vec3 p20 = scale * vec3(phi, -1.0/phi, 0) * rotateXYZ;\n\n\n/*p1.yz = rotate(p1.yz, angle);\np2.yz = rotate(p2.yz, angle);\np3.yz = rotate(p3.yz, angle);\np4.yz = rotate(p4.yz, angle);\n\np5.yz = rotate(p5.yz, angle);\np6.yz = rotate(p6.yz, angle);\np7.yz = rotate(p7.yz, angle);\np8.yz = rotate(p8.yz, angle);\n\np9.yz = rotate(p9.yz, angle);\np10.yz = rotate(p10.yz, angle);\np11.yz = rotate(p11.yz, angle);\np12.yz = rotate(p12.yz, angle);\n\np13.yz = rotate(p13.yz, angle);\np14.yz = rotate(p14.yz, angle);\np15.yz = rotate(p15.yz, angle);\np16.yz = rotate(p16.yz, angle);\n\np17.yz = rotate(p17.yz, angle);\np18.yz = rotate(p18.yz, angle);\np19.yz = rotate(p19.yz, angle);\np20.yz = rotate(p20.yz, angle);\n*/\nconst vec3 color1 = vec3(1, 0, 0);\nconst vec3 color2 = vec3(0, 1, 0);\nconst vec3 color3 = vec3(0, 0, 1);\n\n//Pent1\nconst Triangle Triangle1 = Triangle(p4, p10, p11, color1);\nconst Triangle Triangle2 = Triangle(p4, p11, p8, color2);    \nconst Triangle Triangle3 = Triangle(p4, p8, p20, color3);                                    \n\n//Pent2\nconst Triangle Triangle4 = Triangle(p3, p19, p7, color1);\nconst Triangle Triangle5 = Triangle(p3, p7, p11, color2);    \nconst Triangle Triangle6 = Triangle(p3, p11, p10, color3);\n\n//Pent3\nconst Triangle Triangle7 = Triangle(p14, p3, p19, color1);\nconst Triangle Triangle8 = Triangle(p14, p19, p18, color2);    \nconst Triangle Triangle9 = Triangle(p14, p18, p2, color3);\n\n//Pent4 //9, 2, 14, 13, 1\nconst Triangle Triangle10 = Triangle(p9, p2, p14, color1);\nconst Triangle Triangle11 = Triangle(p9, p14, p13, color2);    \nconst Triangle Triangle12 = Triangle(p9, p13, p1, color3);\n\n//Pent5 //13, 4, 20, 17, 1\nconst Triangle Triangle13 = Triangle(p13, p4, p20, color1);\nconst Triangle Triangle14 = Triangle(p13, p20, p17, color2);    \nconst Triangle Triangle15 = Triangle(p13, p17, p1, color3);\n\n//Pent6 //top: 10, 3, 14, 13, 4\nconst Triangle Triangle16 = Triangle(p10, p3, p14, color1);\nconst Triangle Triangle17 = Triangle(p10, p14, p13, color2);    \nconst Triangle Triangle18 = Triangle(p10, p13, p4, color3);\n\n//bottom part\n        \n//Pent7  //11, 7, 15, 16, 8\nconst Triangle Triangle19 = Triangle(p11, p7, p15, color1);\nconst Triangle Triangle20 = Triangle(p11, p15, p16, color2);    \nconst Triangle Triangle21 = Triangle(p11, p16, p8, color3);\n\n//Pent8  //15, 7, 19, 18, 6\nconst Triangle Triangle22 = Triangle(p15, p7, p19, color1);\nconst Triangle Triangle23 = Triangle(p15, p19, p18, color2);    \nconst Triangle Triangle24 = Triangle(p15, p18, p6, color3);\n\n//Pent9  //2, 18, 6, 12, 9\nconst Triangle Triangle25 = Triangle(p2, p18, p6, color1);\nconst Triangle Triangle26 = Triangle(p2, p6, p12, color2);    \nconst Triangle Triangle27 = Triangle(p2, p12, p9, color3);\n\n//Pent10  //1, 9, 12, 5, 17\nconst Triangle Triangle28 = Triangle(p1, p9, p12, color1);\nconst Triangle Triangle29 = Triangle(p1, p12, p5, color2);    \nconst Triangle Triangle30 = Triangle(p1, p5, p17, color3);\n\n//Pent11  //16, 8, 20, 17, 5\nconst Triangle Triangle31 = Triangle(p16, p8, p20, color1);\nconst Triangle Triangle32 = Triangle(p16, p20, p17, color2);    \nconst Triangle Triangle33 = Triangle(p16, p17, p5, color3);\n\n//bottom:end \n\n//12, 6, 15, 16, 5\nconst Triangle Triangle34 = Triangle(p12, p6, p15, color1);\nconst Triangle Triangle35 = Triangle(p12, p15, p16, color2);    \nconst Triangle Triangle36 = Triangle(p12, p16, p5, color3);\n\n\n\n//Triangle(p4, p10, p1);\n        //Triangle(p4, p11, p8);\n//Triangle(p4, p8, p20);\n\nstruct Pentagon \n{\n    Triangle Triangle1;\n    Triangle Triangle2;\n    Triangle Triangle3;\n};\n\nconst Pentagon Pent1 = Pentagon(Triangle1, Triangle2, Triangle3);\nconst Pentagon Pent2 = Pentagon(Triangle4, Triangle5, Triangle6);\nconst Pentagon Pent3 = Pentagon(Triangle7, Triangle8, Triangle9);\nconst Pentagon Pent4 = Pentagon(Triangle10, Triangle11, Triangle12);\nconst Pentagon Pent5 = Pentagon(Triangle13, Triangle14, Triangle15);\nconst Pentagon Pent6 = Pentagon(Triangle16, Triangle17, Triangle18);\nconst Pentagon Pent7 = Pentagon(Triangle19, Triangle20, Triangle21);\nconst Pentagon Pent8 = Pentagon(Triangle22, Triangle23, Triangle24);\nconst Pentagon Pent9 = Pentagon(Triangle25, Triangle26, Triangle27);\nconst Pentagon Pent10 = Pentagon(Triangle28, Triangle29, Triangle30);\nconst Pentagon Pent11 = Pentagon(Triangle31, Triangle32, Triangle33);\nconst Pentagon Pent12 = Pentagon(Triangle34, Triangle35, Triangle36);\n\nstruct Dodecahedron\n{\n    vec3 pos;\n    float scale;\n    int materialType;\n};\n\n\nfloat intersectTriangle(in vec3 ro, in vec3 rd, \n                    in vec3 v0, in vec3 v1, in vec3 v2,\n                    out vec3 normal)\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross(v1v0, v2v0);\n    vec3  q = cross(rov0, rd);\n    \n    float d = 1.0 / dot(rd, n);\n    \n    if (d < EPS && d > -EPS) {\n        return INF;\n    }\n    \n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n\n    if (u < 0.0 || v < 0.0 || (u + v) > 1.0) {\n        return INF;\n    }\n    \n    normal = normalize(cross(v1v0, v2v0));\n    if (dot(normal, rd) > 0.0) {\n        normal = normalize(cross(v2v0, v1v0));\n    }\n    \n    if (t < 0.0) {\n        return INF;\n    }\n    \n    return t;\n}\n\nvec3 refraction(in vec3 v, in vec3 normal, inout float n1, inout float n2)\n{\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    \n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    if (sinA > n2 / n1) {\n        return normalize(reflect(v, normal));\n    }\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA * (n1 / n2);\n    float cosB = sqrt(1.0 - sinB * sinB);\n    float tmp = n1;\n    n1 = n2;\n    n2 = tmp;\n    return normalize(sinB * tang + cosB * normal);\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal)\n{\n    const float R = 1.0f;\n    const float H = 0.1f;\n    float floorT = (-1.0 - pos.y) / dir.y;\n    if (floorT < 0.0)\n        return INF;\n    vec3 finalPos = pos + dir * floorT;\n    if (dot(finalPos.xz, finalPos.xz) < R * R) {\n        normal = vec3(0, 1, 0);\n        return floorT;\n    }\n    \n    float b = dot(pos.xz, dir.xz);\n    float a = dot(dir.xz, dir.xz);\n    float D = b * b - (dot(pos.xz, pos.xz) - R * R) * a;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D)) / a;\n    if (pos.y + t * dir.y < -1.0) {\n        vec3 wPos = pos + t * dir;\n        normal = normalize(vec3(wPos.x, 0, wPos.z));\n        return t;\n    }\n    \n    return INF;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal)\n{\n //dot(pos+t*dir,pos+t*dir) == r*r //скалярное произведение\n //dot(pos,pos)+2*t*dot(pos,dir)+t*t*dot(dir,dir) == r*r\n //t*t+2.0*t*dot(pos,dir)+dot(pos,pos)-r*r == 0\n     float b = dot(pos,dir);\n         float D = b*b - dot(pos,pos) + r*r;\n     if(D<0.0){\n         return INF;\n     }\n     float t=-b-sqrt(D);\n     if(t>0.0){\n         normal = normalize(pos + t*dir);\n         return t;\n     }\n     t=-b+sqrt(D);\n     if(t<0.0){\n         return INF;\n     }\n     normal = normalize(pos + t*dir);\n     return t;\n}\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n/* HERE */\n//(CAMERA_POS + t*viewVec).y == -1\n//t = (-1 - CAMERA_POS.y)/viewVec.y;\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal)\n{\n     float t = (-1.2 - pos.y)/dir.y;\n     if(t<=0.0){\n         return INF;\n     }\n     vec3 worldPos = t*dir + pos; \n     if(dot(worldPos.xz, worldPos.xz)>=100.0){\n         return INF;\n     }\n     normal = vec3(0,1,0);\n     return t;\n}\n\nfloat pow2(float x)\n{\n    return x*x;\n}\n\nstruct TraceResult\n{\n    float r;\n    bool hit;\n    vec3 sphereIntersect;\n    vec3 vp;\n    vec3 p;\n    vec3 color;\n    vec3 n;\n    vec2 fragCoord;\n    float t;\n    float alpha;\n    float cur_n;\n    float prev_n;\n    int materialType;\n};\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define FAR_INF 1e9\n\n#define RAY_DEPTH 7 \n#define STACK_SIZE 130\n\n\n\n// NB! UNCOMMENT IS_OCCLUDED TO MAKE NORMAL MINECRAFT\n//const float INF = 1e10; \nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\n///const float pi = acos(-1.);\n\nvec3 CAMERA_POS = vec3(-0, 2.2, -6);\n\n\n\nconst vec3 LIGHT3_POS = vec3(0,0,0);\nconst float LIGHT3_SCALE = 0.25;\nconst vec3 LIGHT3_COLOR = vec3(0.1,1,0.2);\nfloat cur_n;\n \nconst float GLASS_N=1.55;\nconst float AIR_N = 1.0;\nfloat n1 = AIR_N;\nfloat n2 = GLASS_N;\n/*float pow2(float x)\n{\n     return x*x;\n}*/\n\n\nfloat GLASS_R;\n\n\n/*float rand(float frame)\n{\n     return fract(sin(dot(vec3(frame), vec3(12.9898, 78.233, 45.5432)))*43758.5453);\n}*/\n\nvec3 randVals;\n\nbool isOccluded(vec3 pos, vec3 target);\n\n\n/* ------------------------------MINECRAFT_MAGIC------------------*/\nfloat noise(vec3 p)\n{\n    return textureLod(iChannel2, p, 0.0).x  ;\n}\n\nfloat cnoise(vec3 p)\n{\n    vec3 size = 1.0 / vec3(textureSize(iChannel2, 0));\n    return (\n        noise(p * size * 1.0 + vec3(0.52, 0.78, 0.43)) * 0.5 + \n        noise(p * size * 2.0 + vec3(0.33, 0.30, 0.76)) * 0.25 + \n        noise(p * size * 4.0 + vec3(0.70, 0.25, 0.92)) * 0.125) * 1.14;\n}\n\nbool voxel(vec3 vp)\n{\n    vp -= vec3(40, -10, -20);\n    //if (vp.y < cloud_height - 2.0)\n        return cnoise(vp * 0.05 - vec3(40.0, -10.0, -20.0)) + vp.y * -0.02 > threshold; \n    //return false;\n}\n\nTraceResult traceVoxel(vec3 p, vec3 d, float dist)\n{\n    TraceResult r;\n    r.hit = false;\n    r.n = -d;\n    r.r = dist;\n    \n    \n    vec3 id = 1.0 / d;\n    vec3 sd = sign(d);\n    vec3 nd = max(-sd, 0.0);\n    vec3 vp = floor(p) - nd * vec3(equal(floor(p), p));\n\n    for (int i = 0; i < MARCH_STEPS; ++i)\n    {\n        if (dist <= 0.0 || p.y > cloud_height * m_scale && d.y > 0.0 /*|| dot(r.p, r.p) > RADIUS_MINECRAFT*/)\n        \tbreak;\n\n        if (voxel(vp))\n        {\n\n\t\t\tr.vp = vp * m_scale;\n\t\t\tr.p = p * m_scale;\n\t\t\tr.r = dist;\n\t\t\tr.hit = true;\n            if (dot(r.p, r.p) > RADIUS_MINECRAFT)\n                r.hit = false;\n            \n            \n\t\t\treturn r;\n        }\n\n        vec3 n =  mix(floor(p + 1.0), ceil(p - 1.0), nd);\n\t\tvec3 ls = (n - p) * id;\n\t\tfloat l = min(min(ls.x, ls.y), ls.z);\n\t\tvec3 a = vec3(equal(vec3(l), ls));\n\n        p = mix(p + d * l, n, a);\n        vp += sd * a;\n        r.n = -sd * a;\n        dist -= l * m_scale;\n    }\n\n    return r;\n}\n\nfloat sample_ao(vec3 vp, vec3 p, vec3 n)\n{\n    const float s = 0.5;\n    const float i = 1.0 - s;\n    vec3 b = vp + n;\n    vec3 e0 = n.zxy;\n    vec3 e1 = n.yzx;\n    float a = 1.0;\n    if (voxel(b + e0))\n        a *= i + s * sqi(fract(dot(-e0, p)));\n    if (voxel(b - e0))\n        a *= i + s * sqi(fract(dot(e0, p)));\n    if (voxel(b + e1))\n        a *= i + s * sqi(fract(dot(-e1, p)));\n    if (voxel(b - e1))\n        a *= i + s * sqi(fract(dot(e1, p)));\n    if (voxel(b + e0 + e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((-e0 - e1) * p)))));\n    if (voxel(b + e0 - e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((-e0 + e1) * p)))));\n    if (voxel(b - e0 + e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((e0 - e1) * p)))));\n    if (voxel(b - e0 - e1))\n        a = min(a, i + s * sqi(min(1.0, length(fract((e0 + e1) * p)))));\n    return a;\n}\n\nTraceResult TraceMineCraft(vec3 pos, vec3 dir)\n{\n    vec3 l1Norm;\n    vec3 curPos;\n    float view_distance = max(0.0, (404.0 - dot(pos, pos)));\n    float t;\n    TraceResult tr_res;   \n    \n    // INSIDE MINECRAFT\n    if (dot(pos, pos) > RADIUS_MINECRAFT)\n    {    \n        t = traceSphere(pos - SPHERE_POS, dir, SPHERE_RADIUS, l1Norm);\n    \n        curPos = pos + t * dir;\n    \n        tr_res = traceVoxel(curPos * im_scale, dir, view_distance);\n        //tr_res.p = curPos + t * dir\n        t += sqrt(dot(curPos - tr_res.p, curPos - tr_res.p));\n        \n        tr_res.sphereIntersect = curPos;\n    \n        return tr_res;\n    }\n    // IN MINECRAFT\n    tr_res = traceVoxel(pos * im_scale, dir, view_distance);\n    if (tr_res.hit == true)\n    {\n        tr_res.t = view_distance - tr_res.r;\n    }\n    else\n    {\n        tr_res.t = INF;\n    }   \n    \n    return tr_res;\n}\n\nfloat compute_light1_factor(vec3 pos, vec3 normal)\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    vec3 randDir = normalize(randVals - 0.5);\n    vec3 toLight1 = LIGHT1_POS-pos;\n    float distSq1 = dot(toLight1,toLight1);\n    float att1 = 40.0f/distSq1;\n    \n    for (int i = 0; i < 1; i++)\n    {\n        randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n        randDir = normalize(randVals - 0.5);\n        if (isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS))\n        {    \n            att1 = 0.0;\n            break;\n        }\n    }\n    \n    return (max(0.0,dot(normal,normalize(toLight1)))*att1\n );\n}\n\nfloat compute_light2_factor(vec3 pos, vec3 normal)\n{\n     vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n     vec3 randDir = normalize(randVals - 0.5);\n     vec3 toLight2 = LIGHT2_POS-pos;\n     float distSq2 = dot(toLight2,toLight2);\n     float att2 = 20.0f/distSq2; \n    \n     if (isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS))\n        att2 = 0.0;\n     return (\n         max(0.0, max(0.0,dot(normal,normalize(toLight2)))*att2\n ));\n}\n\nvec3 compute_minecraft_light(TraceResult r, vec3 p , vec3 d)\n{\n    const vec3 grass_color = vec3(0.63, 1.0, 0.31);\n    const vec3 dirt_color = vec3(0.78, 0.56, 0.4);\n    const vec3 ambient_color = vec3(0.5, 0.5, 0.5);\n    const vec3 sun_color = vec3(0.5, 0.5, 0.5);\n    \n    vec3 to_light1 = LIGHT1_POS - r.p;\n    const float view_distance = 75.0;\n    \n    vec3 to_light2 = LIGHT2_POS - r.p;\n    \n    float sun_factor = max(0.0, dot(r.n, sun_dir));\n    \n    float light1_factor = compute_light1_factor(r.p, r.n);\n    float light2_factor = compute_light2_factor(r.p, r.n);\n\n    float fog_factor = min(1.0, sq(length(r.p - p) / view_distance));\n    vec3 fog_color = background(d);\n\n    if (sun_factor > 0.0)\n    {\n         float sd = m_scale * (cloud_height - r.p.y) / sun_dir.y;\n         if (traceVoxel(r.p, sun_dir, sd).hit)\n             sun_factor = 0.0;\n    }\n   \n    float ambient_factor = sample_ao(im_scale * r.vp, im_scale * r.p, r.n);\n\n    float texel_noise = textureLod(iChannel2, im_scale * r.p * 0.5, 0.0).r;\n\n    float grass_mix = 0.0;\n    if (!voxel(r.vp + vec3(0, m_scale, 0)))\n    {\n         if (texel_noise * 4.0 + floor(fract(im_scale * r.p.y) * 16.0) > 15.0)\n             grass_mix = 1.0;\n         else\n             grass_mix = max(0.0, r.n.y);\n    }\n\n    vec3 texel = vec3(texel_noise) * 0.3 + 0.7;\n    vec3 diffuse = texel * mix(dirt_color, grass_color, grass_mix);\n    vec3 c = diffuse * (ambient_factor * ambient_color +\n                        sun_factor * sun_color  +\n                        light1_factor * LIGHT1_COLOR + \n                        light2_factor * LIGHT2_COLOR);\n\n    return mix(c, fog_color, fog_factor);\n}\n\n/* -------------------------------END_MINECRAFT_MAGIC-----------------*/\n\n\n\n\nvec3 computeLight(vec3 pos,vec3 color,vec3 normal)\n{\n     vec3 toLight1 = LIGHT1_POS-pos;\n     float distSq1 = dot(toLight1,toLight1);\n     float att1 = 20.0f/distSq1;\n     if (isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS))\n        att1 = 0.0;\n     vec3 toLight2 = LIGHT2_POS-pos;\n     float distSq2 = dot(toLight2,toLight2);\n     float att2 = 10.0f/distSq2;\n     if (isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS))\n        att2 = 0.0;\n     return color*(\n         max(0.0,dot(normal,normalize(toLight1)))*att1*LIGHT1_COLOR+\n         max(0.0,dot(normal,normalize(toLight2)))*att2*LIGHT2_COLOR+\n         texture(iChannel1,normal).rgb*0.6\n );\n}\n\nRay get_ray(vec2 uv)\n{\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(front,up));\n    up = normalize(cross(right,front));\n    vec3 viewVec = normalize(front+right*uv.x+up*uv.y);\n    \n    return Ray(CAMERA_POS, viewVec);\n}\n\nvoid drawPlane(Ray ray, inout TraceResult cur_ctxt)\n{\n    vec3 planeNorm;\n    float planeT = tracePlane(ray.pos, ray.dir, planeNorm);    \n    \n    if(planeT < cur_ctxt.t)\n    {\n        cur_ctxt.t = planeT;\n\n        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos; \n        cur_ctxt.color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n        cur_ctxt.n = planeNorm;\n        \n        cur_ctxt.alpha = 0.0;\n        cur_ctxt.materialType = DIFFUSE;\n        /*if(randVals.y < 0.5)\n        {\n            cur_ctxt.materialType = REFLECTION;\n        }*/\n    }\n}\n\nvoid drawLight1(Ray ray, inout TraceResult cur_ctxt)\n{\n    vec3 l1Norm;\n    float light1T = traceSphere(ray.pos - LIGHT1_POS, ray.dir, \n                                        LIGHT1_RADIUS, l1Norm);\n    \n    if(light1T < cur_ctxt.t)\n    {\n        cur_ctxt.t=light1T;\n\n        cur_ctxt.materialType = EMISSION;\n        cur_ctxt.color=LIGHT1_COLOR;\n        cur_ctxt.n = l1Norm;\n        cur_ctxt.alpha = 0.0;\n    }\n\n}\n\nvoid drawLight2(Ray ray, inout TraceResult cur_ctxt)\n{\n    vec3 l2Norm;\n    float light2T = traceSphere(ray.pos - LIGHT2_POS, ray.dir, \n                                        LIGHT2_RADIUS, l2Norm);\n    \n    if(light2T < cur_ctxt.t)\n    {\n        cur_ctxt.t=light2T;\n\n        cur_ctxt.materialType = EMISSION;\n        cur_ctxt.color=LIGHT2_COLOR;\n        cur_ctxt.n = l2Norm;\n        cur_ctxt.alpha = 0.0;\n    }\n}\n\n/*\nvoid drawMineCraftNotBlur(Ray ray, inout TraceResult cur_ctxt)\n{\n    TraceResult tr_res;\n    float mineT;\n    tr_res = TraceMineCraft(ray.pos, ray.dir);\n\n    mineT = sqrt(dot(tr_res.p - ray.pos, tr_res.p - ray.pos)); \n    if (mineT < cur_ctxt.t && tr_res.hit == true)\n    {\n        cur_ctxt.color = vec3(compute_minecraft_light(tr_res, \n                                    tr_res.sphereIntersect, ray.dir));\n        cur_ctxt.n = tr_res.n;\n        \n        cur_ctxt.t = mineT;\n        //cur_ctxt.alpha = max(0.75, \n        //                    sqrt(sqrt(dot(tr_res.p, tr_res.p))));\n        cur_ctxt.alpha = GLOBAL_ALPHA;\n        cur_ctxt.materialType = EMISSION;\n    }\n}*/\n\nvoid drawCylinder(Ray ray, inout TraceResult cur_ctxt)\n{\n    vec3 cylNorm;\n    float cylT = traceCylinder(ray.pos, ray.dir, cylNorm);\n    \n    if(cylT < cur_ctxt.t)\n    {\n        cur_ctxt.t = cylT;\n        \n        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos;\n    \n        cur_ctxt.materialType = DIFFUSE; \n        cur_ctxt.color = 0.3*texture(iChannel0, worldPos.xz * worldPos.y).rgb \n                                        + 0.7*texture(iChannel2, ray.dir).rgb;\n        //cur_ctxt.color = vec3(1, 0, 0);\n        cur_ctxt.n = cylNorm;\n        \n        cur_ctxt.alpha = 0.0;\n    }\n}\n/*HERE */\nvoid drawTriangle(Ray ray, inout TraceResult cur_ctxt, Triangle Triangle1)\n{\n    //float t = INF;\n    vec3 t_normal;\n    float t_trgl0 = intersectTriangle(ray.pos, ray.dir,\n                                  Triangle1.V0, Triangle1.V1, Triangle1.V2,\n                                  t_normal);\n    if (t_trgl0 < cur_ctxt.t) \n    {\n        cur_ctxt.t = t_trgl0;\n        //cur_ctxt.color = Triangle1.color;\n        ///cur_ctxt.color = 0.5 * t_normal + 0.5;\n        cur_ctxt.n = t_normal;\n        \n        if (randVals.x <  GLASS_R * 8.0) \n        {\n            cur_ctxt.materialType = REFLECTION;\n        } \n        else \n        { \n            cur_ctxt.materialType = REFRACTION;\n            if (cur_ctxt.cur_n == AIR_N) \n            {\n                cur_ctxt.prev_n = GLASS_N;\n            } \n            else \n            {\n                cur_ctxt.prev_n = AIR_N;\n            }\n        }   \n        cur_ctxt.alpha = 0.0;\n        cur_ctxt.materialType = REFRACTION;\n    }\n}\n\nvoid drawPentagon(Ray ray, inout TraceResult cur_ctxt, Pentagon Pent1)\n{\n    drawTriangle(ray, cur_ctxt, Pent1.Triangle1);\n    drawTriangle(ray, cur_ctxt, Pent1.Triangle2);\n    drawTriangle(ray, cur_ctxt, Pent1.Triangle3);\n}\n\nvoid drawDodecahedron(Ray ray, inout TraceResult cur_ctxt)\n{\n    drawPentagon(ray, cur_ctxt, Pent1);\n    drawPentagon(ray, cur_ctxt, Pent2);\n    drawPentagon(ray, cur_ctxt, Pent3);\n    drawPentagon(ray, cur_ctxt, Pent4);\n    drawPentagon(ray, cur_ctxt, Pent5);\n    drawPentagon(ray, cur_ctxt, Pent6);\n    drawPentagon(ray, cur_ctxt, Pent7);\n    drawPentagon(ray, cur_ctxt, Pent8);\n    drawPentagon(ray, cur_ctxt, Pent9);\n    drawPentagon(ray, cur_ctxt, Pent10);\n    drawPentagon(ray, cur_ctxt, Pent11);\n    drawPentagon(ray, cur_ctxt, Pent12);\n}\n\nbool isOccluded(vec3 pos, vec3 target)\n{\n    TraceResult cur_ctxt;\n    Ray ray;\n    \n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n\n    vec3 dodNorm = vec3(0, 0, 0);\n    ray.dir = dir;\n    ray.pos = pos;\n    float dodT;\n    drawDodecahedron(ray, cur_ctxt);\n    dodT = cur_ctxt.t;\n    dodNorm = cur_ctxt.n;\n    if (dodT < dist && cur_ctxt.t > 0.0)\n        return true;\n    vec3 cylNorm = dodNorm;\n    float t = traceCylinder(pos, dir, cylNorm);\n    \n    if (t > 0.0 && t <= dodT)\n        return (true);\n        \n    TraceResult tr_res = TraceMineCraft(pos, dir);\n    if (tr_res.t < dist && tr_res.t > 0.0)\n        return true;\n}\n\nvec4 make_another_blur( in vec2 fragCoord, float size)\n{\n    vec4 fragColor;\n    \n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 8.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = size; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Pixel colour\n    vec4 Color = texture(iChannel3, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture(iChannel3, uv + \n                                vec2(cos(d), sin(d))*Radius * i);\t\t\n        }\n }\n    \n    // Output to screen\n    Color /= Quality * Directions;\n   \n    //Color = vec4(0, 1, 0, 1);\n    fragColor =  Color;\n    \n    return fragColor;\n}\n\nvoid drawMineCraftBlur(Ray ray, inout TraceResult cur_ctxt)\n{\n    TraceResult tr_res;\n    float mineT;\n    tr_res = TraceMineCraft(ray.pos, ray.dir);\n\n    mineT = sqrt(dot(tr_res.p - ray.pos, tr_res.p - ray.pos)); \n    if (mineT < cur_ctxt.t && tr_res.hit == true)\n    {\n        cur_ctxt.color = vec3(compute_minecraft_light(tr_res, \n                                    tr_res.sphereIntersect, ray.dir));\n        cur_ctxt.n = tr_res.n;\n        \n        cur_ctxt.t = mineT;\n        //cur_ctxt.alpha = max(0.75, \n        //                   sqrt(sqrt(dot(tr_res.p, tr_res.p))));\n        cur_ctxt.alpha = GLOBAL_ALPHA;\n        /* blur_effect */\n        float ro = abs(dot(tr_res.p, tr_res.p) - RADIUS_MINECRAFT);\n        vec3 blur_color = cur_ctxt.color;\n        \n        blur_color = make_another_blur(cur_ctxt.fragCoord,\n                                    abs(8.0*(RADIUS_MINECRAFT - ro))).rgb;\n        cur_ctxt.color = blur_color;\n        \n        cur_ctxt.materialType = EMISSION;\n        /* end blur_effect */\n    }\n}\n\nvec3 set_camera_pos(vec3 CAMERA_POS)\n{\n    //CAMERA_POS = vec3(0, 1.2, -6);\n    //CAMERA_POS.xy =  rotate(CAMERA_POS.xy, iTime/ 5.0);\n    //CAMERA_POS.yz =  rotate(CAMERA_POS.yz, iTime/ 5.0);\n    CAMERA_POS.xz =  rotate(CAMERA_POS.xz, iTime/ 5.0);\n    \n    return CAMERA_POS;\n}\n\nbool is_boundary_MineCraft(vec3 pos, vec3 dir, float scale)\n{\n    TraceResult tr_res = TraceMineCraft(pos, dir);\n    \n    vec3 ray_pos_x_p = pos + scale * vec3(1, 0, 0);\n    vec3 ray_pos_x_m = pos - scale * vec3(1, 0, 0);\n    \n    vec3 ray_pos_y_p = pos + scale * vec3(0, 1, 0);\n    vec3 ray_pos_y_m = pos - scale * vec3(0, 1, 0);\n    \n    bool x_p = TraceMineCraft(ray_pos_x_p, dir).hit;\n    bool x_m = TraceMineCraft(ray_pos_x_m, dir).hit;\n    \n    bool y_p = TraceMineCraft(ray_pos_y_p, dir).hit;\n    bool y_m = TraceMineCraft(ray_pos_y_m, dir).hit;\n    \n    return (!tr_res.hit && (x_p || x_m || y_p || y_m) ||\n           (tr_res.hit && !(x_p && x_m && y_p && y_m)));\n}\n\n\nfloat to_float(bool b)\n{\n    if (b == true)\n        return 1.0;\n    \n    return 0.0;\n}\n\nfloat get_dist_ray_point(Ray ray, vec3 point)\n{\n    float t = (dot(ray.dir, point - ray.pos)/dot(ray.dir, ray.dir));\n    \n    if (t > 0.0)\n    {\n        return length(point - (ray.pos + t * ray.dir));\n    }\n    \n    return length(point - ray.pos);\n}\n\nvoid draw_blur(in Ray ray, float radius, inout TraceResult cur_ctxt)\n{\n    float accum = 10.0;\n    /*vec4 color;\n    vec3 normal1;\n    float t1 = traceSphere(ray.pos, ray.dir, radius/1.0, normal1);\n    vec3 normal2;\n    float t2 = traceSphere(ray.pos, ray.dir, radius/2.0, normal2);\n    vec3 normal3;\n    float t3 = traceSphere(ray.pos, ray.dir, radius/3.0, normal3);\n    vec3 normal4;\n    float t4 = traceSphere(ray.pos, ray.dir, radius/4.0, normal4);\n    vec3 normal5;\n    float t5 = traceSphere(ray.pos, ray.dir, radius + 0.04, normal5);\n    \n    bool b5 = (t5 != INF);\n    bool b4 = (t4 != INF);\n    bool b3 = (t3 != INF);\n    bool b2 = (t2 != INF);\n    bool b1 = (t1 != INF);\n    \n    accum = to_float(b5);*/\n    float d = get_dist_ray_point(ray, vec3(0, 0, 0));\n    \n    vec3 normal5;\n    float t5 = traceSphere(ray.pos, ray.dir, radius, normal5);\n    \n    if (t5 != INF)\n    {           \n        \n        cur_ctxt.color = make_another_blur(cur_ctxt.fragCoord,\n                                    max(26.0*d,0.0)).rgb;\n        //cur_ctxt.color = vec3(1, 1, 1);\n        cur_ctxt.materialType = EMISSION;\n        cur_ctxt.alpha = min(1.0 - d/(radius) + 0.1, 0.7);\n    }\n    vec3 normal6;\n    float t6 = traceSphere(ray.pos, ray.dir, radius + 0.04, normal6);\n    if (t5 == INF && t6 != INF)\n    {\n        float dif = d - radius - 0.04;\n        \n        cur_ctxt.color = make_another_blur(cur_ctxt.fragCoord,\n                                    max(16.0 * (1.0 - 25.0*dif),0.0)).rgb;\n        \n        cur_ctxt.materialType = EMISSION;\n        //cur_ctxt.alpha = min(-(0.6/0.04) * dif , 0.7);\n    }\n    \n    //cur_ctxt.alpha = GLOBAL_ALPHA;\n    //cur_ctxt.materialType = EMISSION;\n     /*//vec3 curPos = ray.pos + t * ray.dir;\n*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    //randDir = normalize(randVals - 0.5);\n    //CAMERA_POS = set_camera_pos(CAMERA_POS);\n    //vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    CAMERA_POS.xz =  rotate(CAMERA_POS.xz, 0.0);\n    GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    //GLASS_R = pow2(AIR_N - GLASS_N)/pow2(AIR_N + GLASS_N);\n    randVals = vec3(rand(float(iFrame + 3)), rand(float(iFrame+5)), rand(float(iFrame+15)));\n    randDir = normalize(randVals - 0.5);\n    \n    vec2 uv = (fragCoord-iResolution.xy*0.5 + 2.0*(randVals.xy-0.5))/iResolution.x;\n \n    Ray ray = get_ray(uv);\n    \n    TraceResult cur_ctxt;\n    \n    vec3 curPos = ray.pos;\n    vec3 curDir = ray.dir;\n    \n    float prev_n;\n    float cur_n = AIR_N;\n    cur_ctxt.prev_n = prev_n;\n    cur_ctxt.cur_n = cur_n;\n    for(int i=0; i<20; i++)\n    { \n         float t = INF;\n         int materialType;\n         vec3 color;\n         vec3 normal;\n         vec3 back;\n         \n\n         cur_ctxt.color = color;\n         cur_ctxt.n = normal;\n         cur_ctxt.materialType = materialType;\n         cur_ctxt.t = t;\n         cur_ctxt.fragCoord = fragCoord;\n       \n         drawPlane(ray, cur_ctxt);\n         drawLight1(ray, cur_ctxt);\n         drawLight2(ray, cur_ctxt); \n         drawDodecahedron(ray, cur_ctxt);\n         drawCylinder(ray, cur_ctxt);\n         drawMineCraftBlur(ray, cur_ctxt);\n         draw_blur(ray, RADIUS_MINECRAFT, cur_ctxt); \n         /*vec3 worldPos = ray.pos + cur_ctxt.t * (ray.dir);\n         \n         if (is_boundary_MineCraft(ray.pos, ray.dir, 0.1))\n         //if (dot(worldPos, worldPos) <  pow2(RADIUS_MINECRAFT) + 0.6)\n         {\n            vec3 curPos = ray.pos + cur_ctxt.t * ray.dir;\n            float dist = dot(curPos, curPos);\n        \n            cur_ctxt.color = make_another_blur(cur_ctxt.fragCoord, 16.0).rgb;\n            // cur_ctxt.color = make_blur(cur_ctxt.fragCoord,\n            //                                   max(2.0, 2.0));\n            //cur_ctxt.color = vec3(1, 1, 1);\n         }*/\n         \n         \n         if(cur_ctxt.t != INF)\n         {\n             vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos; \n\n             fragColor = texture(iChannel0, worldPos.xz);\n             if(cur_ctxt.materialType == EMISSION)\n             {\n                 fragColor.rgb = mix(cur_ctxt.color, back, cur_ctxt.alpha);\n                 //fragColor.rgb = cur_ctxt.color;\n                 break;\n             } \n\n             else if(cur_ctxt.materialType == DIFFUSE)\n             {\n                 fragColor.rgb = computeLight(worldPos, cur_ctxt.color,\n                                                 cur_ctxt.n);\n                 break;\n             } \n             else if (cur_ctxt.materialType == REFLECTION)\n             {\n                 ray.dir = normalize(reflect(ray.dir, cur_ctxt.n));\n                 ray.pos = worldPos + ray.dir*1e-5;\n             } \n             else if(cur_ctxt.materialType == REFRACTION)\n             {\n                 ray.dir = refraction(ray.dir, cur_ctxt.n, cur_ctxt.cur_n, \n                                                              cur_ctxt.prev_n);\n                 ray.pos = worldPos + ray.dir*1e-5;\n                 \n                 //fragColor.rgb = vec3(1, 1, 1);\n              }\n         } \n         else \n         {\n             if (cur_ctxt.cur_n == AIR_N) \n             {\n                 //fragColor.rgb = color;\n                 //fragColor.rgb = cur_dir + vec3(0.3, 0.2, 0.3);\n                 fragColor.rgb = texture(iChannel1, ray.dir).rgb;\n             } \n             else \n             {\n                 //fragColor.rgb = texture(iChannel1, cur_dir).rgb;// * colorMult;\n                 fragColor.rgb = vec3(1.0, 0.0, 0.0);\n             }\n             break;\n         }\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer D","description":"","type":"buffer"}]}