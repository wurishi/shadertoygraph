{"ver":"0.1","info":{"id":"MXjfzW","date":"1729264826","viewed":21,"name":"Fork Just A Hig dan_bmp 704","username":"dan_bmp","description":"High-quality smoothstep gradient in linear color space. Also has some noise to reduce color banding.\n\n Changed to fork: cycling through array of colors every 30s.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"lscGDr","parentname":"Just A High-Quality Gradient"},"renderpass":[{"inputs":[],"outputs":[],"code":"//\n// Demonstrates high-quality and proper gamma-corrected color gradient.\n//\n// Does interpolation in linear color space, mixing colors using smoothstep function.\n// Also adds some gradient noise to reduce banding.\n//\n// References:\n// http://blog.johnnovak.net/2016/09/21/what-every-coder-should-know-about-gamma/\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch24.html\n// http://loopit.dk/banding_in_games.pdf\n//\n// This shader is dedicated to public domain.\n//\n\n#define SRGB_TO_LINEAR(c) pow((c), vec3(2.2))\n#define LINEAR_TO_SRGB(c) pow((c), vec3(1.0 / 2.2))\n#define SRGB(r, g, b) SRGB_TO_LINEAR(vec3(float(r), float(g), float(b)) / 255.0)\n\n\nconst vec3 COLOR0 = SRGB(0, 0, 255);\nconst vec3 COLOR1 = SRGB(255, 171, 255);\nconst vec3 COLOR2 = SRGB(255, 255, 0);\nconst vec3 COLOR3 = SRGB(255, 0, 0);\nconst int numColors = 4;\nconst vec3 COLOR_MASKS[numColors] = vec3[]( COLOR0,COLOR1,COLOR2,COLOR3);\n\n// Gradient noise from Jorge Jimenez's presentation:\n// http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat gradientNoise(in vec2 uv)\n{\n    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(uv, magic.xy)));\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat circle(vec2 uv, vec2 pos, float rad) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn  1.0 - t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //TIMINGS, COLOR SELECT\n    float dur = 30.0;\n    float transitionDur = 0.1; //In relation to total dur\n    float spread = 0.8;\n    float progression = mod(iTime, dur)/dur;\n    float progressionCol = iTime/dur;\n    \n    float offset = (1.0/transitionDur)/2.0;\n    vec2 a = map(progression, 0.0, 1.0, -spread - offset, 1.0 + offset) * iResolution.xy;\n    vec2 b = map(progression, 0.0, 1.0, 0.0 - offset, 1.0 + spread + offset) * iResolution.xy;\n    \n    float colorI = mod(progressionCol, float(numColors));\n    vec3 cB = COLOR_MASKS[int(colorI)];\n    vec3 cA = COLOR_MASKS[int(mod(colorI + 1.0, float(numColors)))];\n    \n    \n    //GRADIENT\n    // Calculate interpolation factor with vector projection.\n    vec2 ba = b - a;\n    float t = dot(fragCoord - a, ba) / dot(ba, ba);\n    // Saturate and apply smoothstep to the factor.\n    t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));\n    // Interpolate.\n    vec3 color = mix(cA, cB, t);\n    // Convert color from linear to sRGB color space (=gamma encode).\n    color = LINEAR_TO_SRGB(color);\n    // Add gradient noise to reduce banding.\n    color += (1.0/255.0) * gradientNoise(fragCoord) - (0.5/255.0);\n    \n    //CIRCLE\n    vec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.5 * iResolution.y;\n\tfloat circ = circle(uv, center, radius);\n\t\n\t// Blend the two\n    //color = mix(vec3(0.0), color, circ);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}