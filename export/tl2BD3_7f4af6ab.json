{"ver":"0.1","info":{"id":"tl2BD3","date":"1600272936","viewed":232,"name":"Rhombic Dodecahedral Honeycomb","username":"Polygon","description":"It took a while, but I finally got this rhombic dodecahedral voxel tracer working!\n\nI just cleaned it up a bit so it checks for 6 planes using 2 vec3s instead of 6 floats. I'm not sure how that affects performance, but it makes the code look a lot neater.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","voxels","rhombicdodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV = 80.0;\nconst float MUL = tan(FOV * 3.14159265 / 180.0 / 2.0);\nconst int STEPS = 128;\n\nvec4 trace(vec3 pos, vec3 dir);\nbool check(vec3 pos);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy * 2.0 - 1.0);\n    mouse.x *= 4.0;\n    mouse.y *= 1.5;\n\n\tvec3 cameraPos = vec3(4. * iTime, 0, 4. * iTime);\n    vec3 cameraDir = normalize(vec3(sin(mouse.x) * cos(mouse.y), sin(mouse.y), cos(mouse.x) * cos(mouse.y)));\n    vec3 right = normalize(cross(vec3(0, 1, 0), cameraDir));\n    vec3 up = cross(cameraDir, right);\n    \n    vec3 dir = normalize(cameraDir + up * MUL * uv.y + right * MUL * uv.x);\n    \n    \n    vec4 traceData = trace(cameraPos, dir);\n    float dist = traceData.w;\n    vec3 collision = cameraPos + dist * dir;\n    vec3 normal = traceData.xyz;\n    normal += texture(iChannel0, vec2(collision.x + collision.y, collision.x - collision.y) + (cameraPos + dist * dir).yz).xyz * 0.2;\n    normal = normalize(normal);\n    \n    const vec3 skyColor = vec3(111, 168, 237) / 255.0;\n    vec3 lightDir = normalize(vec3(-5.0 * cos(iTime / 5.0), -5, 5.0 * sin(iTime / 5.0)));\n    \n    fragColor.xyz = mix(skyColor, vec3(1), pow(max(0.0, dot(dir, -lightDir)), 20.));\n    \n    if (dist != -1.0) {\n        vec3 color = vec3(0.8, 0.2, 0.6);\n        fragColor.xyz = color * max(0.0, -dot(lightDir, normal));\n        fragColor.xyz = fragColor.xyz * 0.8 + color * 0.2;\n        \n        vec3 reflectDir = normalize(reflect(dir, normal));\n        float reflection = pow(max(0.0, dot(reflectDir, -lightDir)), 20.);\n        fragColor.xyz = mix(fragColor.xyz, vec3(1), reflection);\n        \n        float fog = 1. - pow(0.98, dist);\n        fragColor.xyz = mix(fragColor.xyz, skyColor, fog);\n        \n        \n        \n        //fragColor.xyz = (normal + 2.) / 4.;\n    }\n}\n\nvec4 trace(vec3 pos, vec3 dir) {\n    vec3 step_p = vec3(1) / (dir.yzx + dir.zxy);\n    vec3 step_n = vec3(1) / (dir.yzx - dir.zxy);\n    \n    vec3 samplePoint = floor(pos);\n    if (mod(samplePoint.x + samplePoint.y + samplePoint.z, 2.0) != 0.0) {\n        vec3 fraction = fract(pos);\n        vec3 _sign = vec3(lessThan(fraction, 1. - fraction)) * 2. - 1.;\n        fraction = min(fraction, 1. - fraction);\n        if (fraction.x < fraction.y && fraction.x < fraction.z) {\n            samplePoint.x -= _sign.x;\n        }\n        else if (fraction.y < fraction.z) {\n            samplePoint.y -= _sign.y;\n        }\n        else\n            samplePoint.z -= _sign.z;\n    }\n    \n    vec3 next_p = samplePoint.yzx + samplePoint.zxy + 1. + 1. * sign(step_p);\n    vec3 next_n = samplePoint.yzx - samplePoint.zxy + sign(step_n);\n    \n    vec3 dist_p = abs((next_p - pos.yzx - pos.zxy) / (dir.yzx + dir.zxy));\n    vec3 dist_n = abs((next_n - pos.yzx + pos.zxy) / (dir.yzx - dir.zxy));\n    \n    float minDist;\n    vec3 normal;\n    float _sign;\n    float totalDist = 0.0;\n    \n    for(int i = 0; i < STEPS; ++i) {\n        minDist = min(dist_p.z, min(dist_p.x, min(dist_p.y, min(dist_n.z, min(dist_n.x, dist_n.y)))));\n        \n        if (dist_p.z == minDist) {\n            _sign = sign(step_p.z);\n            \n            dist_p += step_p * _sign - minDist;\n            dist_n += step_n * _sign * vec3(1, -1, 0) - minDist;\n            dist_p.z = 2.0 * abs(step_p.z);\n            totalDist += minDist;\n            \n            normal = -_sign * vec3(1, 1, 0);\n        }\n        else if (dist_n.z == minDist) {\n            _sign = sign(step_n.z);\n            \n            dist_p += step_p * _sign * vec3(-1, 1, 0) - minDist;\n            dist_n += -step_n * sign(step_n.z) - minDist;\n            dist_n.z = 2.0 * abs(step_n.z);\n            totalDist += minDist;\n            \n            normal = -_sign * vec3(1, -1, 0);\n        }\n        else if (dist_p.x == minDist) {\n            _sign = sign(step_p.x);\n            \n            dist_p += step_p * _sign - minDist;\n            dist_n += step_n * _sign * vec3(0, 1, -1) - minDist;\n            dist_p.x = 2.0 * abs(step_p.x);\n            totalDist += minDist;\n            \n            normal = -_sign * vec3(0, 1, 1);\n        }\n        else if (dist_n.x == minDist) {\n            _sign = sign(step_n.x);\n            \n            dist_p += step_p * _sign * vec3(0, -1, 1) - minDist;\n            dist_n += -step_n * sign(step_n.x) - minDist;\n            dist_n.x = 2.0 * abs(step_n.x);\n            totalDist += minDist;\n            \n            normal = -_sign * vec3(0, 1, -1);\n        }\n        else if (dist_p.y == minDist) {\n            _sign = sign(step_p.y);\n            \n            dist_p += step_p * _sign - minDist;\n            dist_n += step_n * _sign * vec3(-1, 0, 1) - minDist;\n            dist_p.y = 2.0 * abs(step_p.y);\n            totalDist += minDist;\n            \n            normal = -_sign * vec3(1, 0, 1);\n        }\n        else {\n            _sign = sign(step_n.y);\n            \n            dist_p += step_p * _sign * vec3(1, 0, -1) - minDist;\n            dist_n += -step_n * sign(step_n.y) - minDist;\n            dist_n.y = 2.0 * abs(step_n.y);\n            totalDist += minDist;\n            \n            normal = -_sign * vec3(-1, 0, 1);\n        }\n        samplePoint -= normal;\n        \n        if (check(samplePoint)) return vec4(normal * 0.70710678118, totalDist);\n    }\n\n\t\n    \n    \n    return vec4(-1);\n    \n}\n\nbool check(vec3 pos) {\n        return (pos.y + sin(pos.x) / 2. + sin(pos.z / 2.) / 2. + 10. * sin(pos.x / 20.) * sin(pos.z / 20.) < -3.);\n}","name":"Image","description":"","type":"image"}]}