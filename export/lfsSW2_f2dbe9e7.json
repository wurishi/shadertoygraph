{"ver":"0.1","info":{"id":"lfsSW2","date":"1705766715","viewed":95,"name":"Sinewave Marbles","username":"spalmer","description":"deconstructing and simplifying dr2's cool rolling marbles demo [url]wtfcRr[/url], this time focusing just on the marbles.\nuses my own quaternion library instead of dr2 matrix-quaternion-hybrid math.\nmight redo the camera next!","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["collision","raymarch","quaternion","physics"],"hasliked":0,"parentid":"Wlsyzr","parentname":"Voronoi Marbles"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// simplified version refactored to common tab by spalmer at  http://shadertoy.com/view/Wlsyzr\n\n// \"Channeling Marbles\" by dr2 at http://shadertoy.com/view/wtfcRr\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nint idBall;\nfloat tCur, dstFar;\nvec3 vnObj, ltDir;\n\n#define IZERO min(0, iFrame)\n\nvec4 Load(int id) { return Load(CH, RZ, id); }\n\nvec3 HsvToRgb(vec3 c)\n{\n    return c.z * mix(vec3(1), clamp(abs(fract(c.xxx - vec3(0, 1, 2) / 3.) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n// sph checker pattern texture\nfloat BallChqr(int idBall, vec3 vnBall)\n{\n    vec3 u;\n    vec2 a;\n    quat q = Load(4 * idBall + 2);\n    //u = vnBall * QtToRMat(q); // rotate to ball local - dr2 way\n    u = qrot(qrev(q), vnBall); // rotate to ball local - spalmer way\n    a = mod(floor(8. * vec2(atan(u.x, u.y), asin(u.z)) / pi), 2.) - .5;\n    return .5 + .5 * step(0., sign(a.x) * sign(a.y));\n}\n// TODO simpler sinewaves perhaps\n\n#if 1\n// TODO more simpler rendering please\n\nfloat SurfRay(vec3 ro, vec3 rd)\n{\n    vec3 p;\n    float dHit, h, s, sLo, sHi;\n    dHit = dstFar;\n    if (rd.y < 0.) {\n        s = -(ro.y/* - vorHt*/) / rd.y;\n        sLo = s;\n        for (int j = 0 + IZERO; j < 96; ++j) {\n            p = ro + s * rd;\n            h = p.y - SurfHt(p.xz);\n            if (h < 0.) break;\n            sLo = s;\n            s += max(.2, .4 * h);\n            if (s > dstFar) break;\n        }\n        if (h < 0.) {\n            sHi = s;\n            for (int j = 0 + IZERO; j < 5; ++j) {\n                s = .5 * (sLo + sHi);\n                p = ro + s * rd;\n                if (p.y > SurfHt(p.xz)) sLo = s;\n                else sHi = s;\n            }\n            dHit = .5 * (sLo + sHi);\n        }\n    }\n    return dHit;\n}\n\n// tracks idBall in globals\nfloat BallHit(vec3 ro, vec3 rd)\n{\n    vec4 p;\n    vec3 u;\n    float b, d, w, dMin, rad;\n    dMin = dstFar;\n    for (int n = 0 + IZERO; n < nBall; ++n) {\n        p = Load(4 * n);\n        u = ro - p.xyz;\n        rad = ballRadius;\n        b = dot(rd, u);\n        w = b * b - dot(u, u) + rad * rad;\n        if (w >= 0.) {\n            d = -b - sqrt(w);\n            if (d > 0. && d < dMin) {\n                dMin = d;\n                vnObj = (u + d * rd) / rad;\n                idBall = n;\n            }\n        }\n    }\n    return dMin;\n}\n// simpler, for shadow traces\nfloat BallHitSh(vec3 ro, vec3 rd, float rng)\n{\n    vec4 p;\n    vec3 rs, u;\n    float b, d, w, dMin, rad;\n    dMin = dstFar;\n    for (int n = 0 + IZERO; n < nBall; ++n) {\n        p = Load(4 * n);\n        u = ro - p.xyz;\n        rad = ballRadius;\n        b = dot(rd, u);\n        w = b * b - dot(u, u) + rad * rad;\n        if (w >= 0.) {\n            d = -b - sqrt(w);\n            if (d > 0. && d < dMin) dMin = d;\n        }\n    }\n    return smoothstep(0., rng, dMin);\n}\n\nvec2 Rot2D(vec2 q, float a)\n{\n    vec2 cs = cossin(a);\n    return vec2(dot(q, vec2(cs.x, -cs.y)), dot(q.yx, cs));\n}\n\nvec3 ShowScene(vec3 ro, vec3 rd)\n{\n    vec4 c4;\n    vec3 c, vn, bg;\n    float dstObj, dstSurf, sh;\n    \n    bg = vec3(.5, .7, 1);\n    dstObj = BallHit(ro, rd);\n    dstSurf = SurfRay(ro, rd);\n    if (min(dstObj, dstSurf) < dstFar) {\n        if (dstObj < dstSurf) {\n            ro += dstObj * rd;\n            vn = vnObj;\n            c4 = vec4(HsvToRgb(vec3(float(idBall) / float(nBall), .8, BallChqr(idBall, vn))), .3);\n        } else if (dstSurf < dstFar) {\n            ro += dstSurf * rd;\n            vn = SurfNf(ro);\n            c4 = vec4(.7 * mix(vec3(.4, .3, .3), vec3(.8, .85, .8), smoothstep(0., .02, ro.y)), 0.);\n        }\n        sh = BallHitSh(ro + .01 * ltDir, ltDir, 10.);\n        c = c4.rgb * (.2 + .1 * max(-dot(vn.xz, normalize(ltDir.xz)), 0.) +\n            .1 * max(vn.y, 0.) + .8 * sh * max(dot(vn, ltDir), 0.)) +\n            c4.a * pow(max(dot(normalize(ltDir - rd), vn), 0.), 32.);\n        c = mix(c, bg, 1. - min(1., exp2(8. * (1. - 1.2 * min(dstObj, dstSurf) / dstFar))));\n\n    }\n    else c = bg;\n    return clamp(c, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    mat3 vuMat;\n    vec4 state, mPtr;\n    vec3 c, rd, ro, vd, bMid;\n    vec2 canvas, uv, ut;\n    float az, el, asp, zmFac, s, mb;\n    int fBall;\n    canvas = iResolution.xy;\n    uv = 2. * fragCoord.xy / canvas - 1.;\n    uv.x *= canvas.x / canvas.y;\n    tCur = iTime;\n    asp = canvas.x / canvas.y;\n    state = Load(4 * nBall + 0);\n    state = Load(4 * nBall + 2);\n    mPtr.xyz = state.xyz;\n    fBall = -1; //int(state.w); // which ball we following?\n    az = 0.;\n    el = 0.;\n    ut = vec2(mPtr.x, abs(mPtr.y)) + .05 * vec2(1. / asp, 1.) - .5;\n    mb = min(ut.x, ut.y);\n    if (mPtr.z > 0. && mb < 0.) {\n        az = 2. * pi * mPtr.x;\n        el = .5 * pi * (mPtr.y + .25);\n    } else if (fBall < 0) {\n        az += .03 * pi * tCur;\n        el += pi * (.17 + .1 * sin(.041 * pi * tCur));\n    }\n    if (fBall >= 0) { // following a particular ball?\n        ro = Load(4 * fBall + 0).xyz;\n        ro.y += .7;\n        vd = Load(4 * fBall + 1).xyz;\n        vd = normalize(vec3(vd.x, 0, vd.z));\n        vd.xz = Rot2D(vd.xz, -az);\n        ro.xz -= .7 * vd.xz;\n        vuMat = mat3(vec3(vd.z, 0, -vd.x), vec3(0, 1, 0), vd);\n        zmFac = 2.;\n    } else {\n        el = clamp(el, .02 * pi, .4 * pi);\n        bMid.xz = vec2(0);\n        for (int n = 0; n < nBall; ++n) bMid.xz += Load(4 * n).xz;\n        bMid.xz /= float(nBall);\n        bMid.y = 0.;\n        float H = iMouse.z > 0. ? 60. : 30.;\n        ro = bMid + H * vec3(cos(el) * sin(az + vec2(.5 * pi, 0)), 2. * sin(el)).xzy;\n        vd = normalize(bMid - ro);\n        s = sqrt(max(1. - vd.y * vd.y, 1e-6));\n        vuMat = mat3(vec3(vd.z, 0., -vd.x) / s,\n            vec3(-vd.y * vd.x, 1. - vd.y * vd.y, -vd.y * vd.z) / s, \n            vd);\n        zmFac = 6.;\n    }\n    rd = vuMat * normalize(vec3(uv, zmFac));\n    dstFar = 200.;\n    ltDir = normalize(vec3(1, 2, -1));\n    c = ShowScene(ro, rd);\n    c = pow(c, vec3(1. / 2.2)); // gamma->sRGB OETF\n    fragColor = vec4(c, 1);\n}\n\n#else\n// TODO from my Quaternion Kinematics http://shadertoy.com/view/ssGSDm\n\nvec2 balls(vec3 q)\n{\n    vec4 p;\n    vec3 u;\n    float d, dMin;\n    int idB;\n    dMin = dstFar;\n    \n    for (int n = 0 + IZERO; n < nBall; ++n) {\n        p = Load(4 * n);\n        d = dot(q - p.xyz, q - p.xyz);\n        if (d > 0. && d < dMin) {\n            dMin = d;\n            //vnObj = (u + d * rd) / rad; // HACK\n            idB = n;\n        }\n    }\n    dMin = sqrt(dMin);\n    dMin -= ballRadius;\n    return vec2(dMin, idB/*+2*/);\n}\n\nvec2 scene(vec3 e)\n{\n    vec2 b = balls(e);\n    float dp = .7 * (e.y - SurfHt(e.xz));\n    return dp < b.x ? vec2(dp, 1) : b;\n}\n\nvec3 QrbitCamera(vec2 a, vec3 d)\n{\n    a.y = clamp(a.y, -.5, .5);\n    a *= pi;\n    quat q = qidentity;\n    // FIXME replace mouse control with auto follow cam like original toy\n    q = qmul(q, qaxisangle(vec3(0,1,0), 2.*a.x));\n    q = qmul(q, qaxisangle(vec3(-1,0,0), a.y));\n    q = qrenormalize(q);\n    return qrot(q, d);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    o = iMouse; // bonus: initializes o\n    vec3 e = iResolution,\n      d = normalize(vec3(p - .5 * e.xy, e.y)); // 1. / tan(hfovy)\n\to.xy /= e.xy; // last use of resolution, now e -> eye pos\n    if (abs(o.z) > 1.) // quality detail in lists and prior to click\n        o -= .5;\n    else\n        o.x += .1 * sin(.2 * iTime);   \n    d = QrbitCamera(o.xy, d); // quaternion look\n    d = normalize(d);\n    e -= e; e.y += -4.; // ray init    \n    float r = 24., t = 0.; // sphere caster\n    vec2 h;\n    for (int i = 40; \n      h = scene(e),\n      h.x *= .8,\n      t += h.x, e += h.x * d, // march\n      i-- > 0 && abs(h.x) >= .001 * t && t < r && e.y < 9.; );\n    o -= o - exp(-.06 * min(r, t)); // black fog\n    float g = (scene(e + vec3(.1)).x - scene(e).x) / length(vec3(.1)); // directed gradient\n    o.rgb *= clamp(g * .25 + .5, 0., 1.); // simple lighting\n    o.rgb *= cos(vec3(0,2,4)-1.+11.7*h.y) * .5 + .5; // albedo\n    if (e.y >= 9. || t > r) o *= 0.;\n    o = sqrt(o); // gamma\n}\n\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// http://shadertoy.com/view/lfsSW2\n// simplified version refactored to common tab by spalmer at  http://shadertoy.com/view/Wlsyzr\n\n// \"Channeling Marbles\" by dr2 at http://shadertoy.com/view/wtfcRr\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// refactored to pure quaternions by spalmer 1/20/24\n\n#define CH iChannel0\n#define RZ iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nconst int nBall = 6;\nconst float ballRadius = .45;\n\nconst float\n    pi = radians(180.),\n    sqrt3 = sqrt(3.);\n\nvec2 cossin(float rads)\n{\n\treturn sin(rads + vec2(.5 * pi, 0));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff(float p)\n{\n\treturn fract(sin(p) * cHashM);\n}\n\nvec3 Hashv3f(float p)\n{\n\treturn fract(sin(p + vec3(37, 39, 41)) * cHashM);\n}\n\n#if 1\n// from my http://shadertoy.com/view/ssGSDm\n#define quat vec4\n\nconst quat qidentity = quat(0,0,0,1);\n\n/*\n// quaternion from 2 unit vectors\nquat qfromto(vec3 vsrc, vec3 vdst) // construct rotation that maps vsrc to vdst\n{\n    vec3 vhalf = vsrc + vdst;\n    vhalf *= length(vdst) / length(vhalf);\n    return quat(cross(vsrc, vhalf), dot(vsrc, vhalf));\n}\n*/\n// QrbitCamera uses it\nquat qaxisangle(vec3 axis, float rad)\t// axis should be unit length!!\n{\n    rad *= .5;\n    return quat(sin(rad) * axis, cos(rad));\n}\n\n// conjugate\nquat qrev(quat q)\n{\n    q.w = -q.w;\n    return q;\n}\n\n// quaternion composition Rodrigues style\nquat qmul(quat a, quat b)\n{\n\tvec3 va = a.xyz, vb = b.xyz;\n\treturn quat(b * a.w) - quat(cross(vb, va) - va * b.w, dot(va, vb));\n}\n\nquat qrenormalize(quat q)\n{\n    float l2 = dot(q, q);\n\treturn l2 == 1. ? q : .5 * (3. - l2) * q;\n}\n\nvec3 qrot(quat q, vec3 r)\n{\n\tvec3 axis = q.xyz;\n\tfloat w = q.w;\n\treturn 2.*((cross(axis,r) + r * w) * w + axis * dot(axis,r)) - r;\n}\n/*\nquat qlog(quat q)\n{\n\tvec3 v = q.xyz;\n\tfloat l = length(v), s = 2. * atan(l / q.w) / l;\n\treturn quat(v * s, l);\n}\n*/\nquat qexp(quat v)\n{\n\tvec3 v3 = v.xyz;\n\tfloat a = dot(v3, v3);\n\tif (a < 1e-7) return qidentity;\n\ta = .5 * sqrt(a);\n\treturn quat(v3 * (sin(a) * .5 / a), cos(a));\n}\n\n#endif\n\n#if 0\n// dr2 quaternions involving matrices  replaced w my quats\nvec4 QtMul(vec4 q1, vec4 q2)\n{\n\treturn vec4(\n\t\t q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n\t\t q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n\t\t-q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n\t\t-q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt(mat3 m)\n{\n\tvec4 q;\n\tconst float tol = 1e-6;\n\tq.w = .5 * sqrt(max(1. + m[0][0] + m[1][1] + m[2][2], 0.));\n\tif (abs(q.w) > tol)\n        q.xyz = vec3(\n            m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]\n            ) / (4. * q.w);\n\telse {\n\t\tq.x = sqrt(max(.5 * (1. + m[0][0]), 0.));\n\t\tif (abs(q.x) > tol)\n            q.yz = vec2(m[0][1], m[0][2]) / q.x;\n\t\telse {\n\t\t\tq.y = sqrt(max(.5 * (1. + m[1][1]), 0.));\n\t\t\tif (abs(q.y) > tol) q.z = m[1][2] / q.y;\n\t\t\telse q.z = 1.;\n\t\t}\n\t}\n\treturn normalize(q);\n}\n\nmat3 QtToRMat(vec4 q)\n{\n\tmat3 m;\n\tfloat a1, a2, s;\n\tq = normalize(q);\n\ts = q.w * q.w - .5;\n\tm[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n\ta1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n\ta1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n\ta1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n\treturn 2. * m;\n}\n\n// just applies angular velocity spin.\n// I do it directly as a quaternion instead.\nmat3 LpStepMat(vec3 a)\n{\n\tmat3 m1, m2;\n\tvec3 t, c, s;\n\tfloat b1, b2;\n\tt = .25 * a * a;\n    // seems like obtaining cos and sin from tangent, if I had to guess.  and I must.\n\tc = (1. - t) / (1. + t);\n\ts = a / (1. + t);\n    /*\n    // NOTE:\n    m1 winds up being: mat3(\n        c.y * c.z,  s.x * s.y * c.z + c.x * s.z, -c.x * s.y * c.z + s.x * s.z,\n        c.y * s.z, -s.x * s.y * s.z + c.x * c.z,  c.x * s.y * s.z + s.x * c.z,\n        s.y,  -s.x * c.y,  c.x * c.y\n        )\n    ok now wth kind of matrix is that?  I can barely tell, and that's without\n    all the variables being exchanged and intermingled and constantly renamed\n    due to dr2 clever (but possibly premature) optimization\n    anyway on to m1: transpose(mat3(\n         c.y * c.z, s.x * s.y * c.z - c.x * s.z, c.x * s.y * c.z + s.x * s.z,\n         c.y * s.z, s.x * s.y * s.z + c.x * c.z, c.x * s.y * s.z - s.x * c.z,\n        -s.y,  s.x * c.y,  c.x * c.y\n        ))\n    then of course those get matrix multiplied together, \n    and I'm sure that turns into a proliferation of terms\n    but what does it all DO?\n    look how it gets used below, in the physics integration step:\n\tqm = normalize(qmul(RMatToQt(LpStepMat(.5 * dt * wm)), qm)); // integrate orientation\n    obviously it produces some sort of rotation matrix\n    expected to be the rotation corresponding to the\n       wm += dt * wam / .1; // integrate angular velocity\n    where wam is the angular momentum\n    so it's rotating a quaternion by the angular velocity vector\n    why, that's easy!  or damn sight easier than all this termwise gobbledygook.\n    \n    dr2, one comment could have saved me so much effort!  :octopusballoon:\n\t*/\n\tm1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n\tb1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n\tm1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n\tb1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n\tm1[0][2] = -b1 + b2;  m2[2][0] = b1 + b2;\n\tb1 = c.y * s.z;\n\tm1[1][0] = -b1;  m2[0][1] = b1;\n\tb1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n\tm1[1][1] = -b1 + b2;  m2[1][1] = b1 + b2;\n\tb1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n\tm1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n\tm1[2][0] = s.y;  m2[0][2] = -s.y;\n\tb1 = s.x * c.y;\n\tm1[2][1] = -b1;  m2[1][2] = b1;\n\tb1 = c.x * c.y;\n\tm1[2][2] = b1;  m2[2][2] = b1;\n\treturn m1 * m2;\n}\n#endif\n\nfloat SurfHt(vec2 p)\n{\n\treturn .5*(sin( .5*p.x) + sin( .5*p.y))\n        + .06*(sin(2.3*p.x) + sin(2.1*p.y))\n        ; //sin(vorHt * smoothstep(vorSmth.x, vorSmth.y, HexVor(p));\n}\n\nvec3 SurfNf(vec3 p)\n{\n\tconst vec2 e = vec2(.01, 0);\n\treturn normalize(vec3(SurfHt(p.xz) - vec2(SurfHt(p.xz + e.xy), SurfHt(p.xz + e.yx)), e.x).xzy);\n}\n\n\nvec4 Load(sampler2D ch, vec2 rz, int idVar)\n{\n\tfloat fi;\n\tfi = float(idVar);\n\treturn texture(ch, (vec2(mod(fi, txRow), floor(fi / txRow)) + .5) / rz);\n}\n\nvoid Save(int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n\tvec2 d;\n\tfloat fi = float(idVar);\n\td = abs(fCoord - vec2(mod(fi, txRow), floor(fi / txRow)) - .5);\n\tif (max(d.x, d.y) < .5) fCol = val;\n}\n\nvoid Step(sampler2D ch, vec2 rz, int mId, int zero, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out int fBall)\n{\n\tvec4 p;\n\tvec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n\tfloat fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, grav, rSep,\n\t\tfc, ft, drv, dt;\n\tfOvlap = 500.;\n\tfricN = 10.;\n\tfricS = .1;\n\tfricSW = 1.;\n\tfricT = .5;\n\tfPull = 2.;\n\tfDamp = .5;\n\tgrav = 5.;\n\tp = Load(ch, rz, 4 * mId);\n\trm = p.xyz;\n\tvm = Load(ch, rz, 4 * mId + 1).xyz;\n\tqm = Load(ch, rz, 4 * mId + 2);\n\twm = Load(ch, rz, 4 * mId + 3).xyz;\n\tam = vec3(0);\n\twam = vec3(0);\n\tfor (int n = 0 + zero; n < nBall; ++n) {\n        // check collision w other balls\n\t\tp = Load(ch, rz, 4 * n);\n\t\trmN = p.xyz;\n\t\tdr = rm - rmN;\n\t\trSep = length(dr);\n\t\tif (n != mId && rSep < 1.) {\n\t\t\tfc = fOvlap * (1. / rSep - 1.);\n\t\t\tvmN = Load(ch, rz, 4 * n + 1).xyz;\n\t\t\twmN = Load(ch, rz, 4 * n + 3).xyz;\n\t\t\tdv = vm - vmN;\n\t\t\tdrv = dot(dr, dv) / (rSep * rSep);\n\t\t\tfc = max(fc - fricN * drv, 0.);\n\t\t\tam += fc * dr;\n\t\t\tdv -= drv * dr + cross(.5 * (wm + wmN), dr);\n\t\t\tft = min(fricT, fricS * abs(fc) * rSep / max(.001, length(dv)));\n\t\t\tam -= ft * dv;\n\t\t\twam += (ft / rSep) * cross(dr, dv);\n\t\t}\n\t}\n\tdr.xz = .5 * SurfNf(rm).xz;\n\tdr.y = rm.y + .5 - SurfHt(rm.xz - dr.xz);\n\trSep = length(dr);\n\tif (rSep < 1.) {\n        // friction cone stuff\n\t\tfc = fOvlap * (1. / rSep - 1.);\n\t\tdv = vm;\n\t\tdrv = dot(dr, dv) / (rSep * rSep);\n\t\tfc = max(fc - fricN * drv, 0.);\n\t\tam += fc * dr;\n\t\tdv -= drv * dr + cross(wm, dr);\n\t\tft = min(fricT, fricSW * abs(fc) * rSep / max(.001, length(dv)));\n\t\tam -= ft * dv;\n\t\twam += ft / rSep * cross(dr, dv);\n\t}\n\t// accelerations\n\tam += vec3(fPull * vec2(.7, .5), - grav).xzy -\n\t   fDamp * vec3(1, 5, 1) * vm;\n\tdt = fBall < 0 ? .02 : .02;\n\tvm += dt * am; // integrate velocity\n\trm += dt * vm; // integrate position\n\twm += dt * wam / .1; // integrate angular velocity\n\t//qm = normalize(qmul/*QtMul*/(RMatToQt(LpStepMat(.5 * dt * wm)), qm)); // integrate orientation - the dr2 way\n    qm = qrenormalize(qmul(qexp(quat(.5 * dt * wm, 0)), qm)); // integrate orientation - the spalmer way\n}\n\nvoid Init(int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n\tfloat mIdf;\n\tmIdf = float(mId);\n\trm.xz = vec2(0, 1.5 * mIdf) + 35.; // * mod(todCur, 10.);\n\trm.y = .5;\n\tvm = vec3(.5); // * (2. * Hashv3f(mIdf + todCur) - 1.);\n\tqm = vec4(0, 0, 0, 1);\n\twm = vec3(0);\n}\n\nvoid mainBuffer(out vec4 fragColor, vec2 fragCoord,\n\tsampler2D ch, vec2 rz,\n\tint frame, vec3 res, vec4 mouse, vec4 date)\n{\n    float nStep; // was global\n\tvec4 mPtr, mPtrP, state, qm;\n\tvec3 rm, vm, wm;\n\tvec2 iFrag, canvas;\n\tfloat asp;\n\tint mId, pxId, kp, zero = min(0, frame);\n\tbool doInit;\n\tiFrag = floor(fragCoord);\n\tpxId = int(iFrag.x + txRow * iFrag.y);\n\tif (iFrag.x >= txRow || pxId >= 4 * nBall + 3) \n        discard;\n\tcanvas = res.xy;\n\tmPtr = mouse;\n\tmPtr.xy = mPtr.xy / canvas - .5;\n\tasp = canvas.x / canvas.y;\n\n\tmId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n\tint fBall = -1;\n\tif (frame < 3) {\n\t\tdoInit = true;\n\t} else {\n\t\tdoInit = false;\n\t\tstate = Load(ch, rz, 4 * nBall);\n\t\tnStep = state.w;\n\t\t++nStep;\n\t\tstate = Load(ch, rz, 4 * nBall + 2);\n\t\tmPtrP.z = state.z;\n\t\t//fBall = int(state.w);\n        /*\n\t\tif (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > .5 - .05 / asp && abs(mPtr.y) > .5 - .05) {\n\t\t\tif (mPtr.y > 0.) {\n\t\t\t\tif (nStep > 100.) doInit = true;\n\t\t\t} else {\n\t\t\t\tif (fBall >= 0) fBall = -1;\n\t\t\t\telse fBall = pxId / 4;\n\t\t\t}\n\t\t}\n        */\n\t}\n\tif (doInit) {\n\t\tnStep = 0.;\n\t\tfBall = -1;\n\t}\n\tif (mId >= 0) {\n\t\tif (doInit)  Init(mId,       rm, vm, qm, wm);\n\t\telse Step(ch, rz, mId, zero, rm, vm, qm, wm, fBall);\n\t}\n\tif (pxId < 4 * nBall) {\n\t\tkp = 4 * mId;\n\t\t     if (pxId == kp    ) state = vec4(rm, 0);\n\t\telse if (pxId == kp + 1) state = vec4(vm, 0);\n\t\telse if (pxId == kp + 2) state = qm;\n\t\telse if (pxId == kp + 3) state = vec4(wm, 0);\n\t}\n\tSave(pxId, state, fragColor, fragCoord);\n}\n\n\n#define BUFFER\t\t\t\t\t\t\t\t\t\\\nvoid mainImage(out vec4 o, vec2 p)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tmainBuffer(o, p, CH, RZ,\t\t\t    \t\\\n\t\tiFrame, iResolution, iMouse, iDate);\t\\\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"BUFFER\n\n// To increase speed\n// simply make more Buffer tabs\n// and copy this code to them\n// setting the prior buffer\n// in circular ring as iChannel0\n\n","name":"Buffer A","description":"","type":"buffer"}]}