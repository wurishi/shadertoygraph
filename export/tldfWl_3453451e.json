{"ver":"0.1","info":{"id":"tldfWl","date":"1613860297","viewed":93,"name":"Carpet pattern #1","username":"TWal","description":"Another carpet pattern","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["wallpapergroup","cmm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHOW_CMM 0\n\n//Reduce the cmm wallpaper group to the triangle (0,0) -- (1,0) -- (0,1)\nvec2 cmm(vec2 p) {\n    p = mod(p+1., 2.)-1.;\n    p = abs(p);\n    return 1.-p.x > p.y ? p : 1.-p;\n}\n\nconst float PI = acos(-1.);\nvec2 rotMod(vec2 p, int N, float off) {\n    float r = length(p);\n    float t = atan(p.y, p.x);\n    float m = 2.*PI/float(N);\n    t = mod(t+m*off+m/2., m)-m/2.;\n    return r*vec2(cos(t), sin(t));\n}\n\nfloat sdLine(vec2 p, float x0, float x1, float thickness) {\n    return sdBox(p-vec2((x0+x1)/2., 0.), vec2((x1-x0)/2., thickness/2.));\n}\n\nvec3 carpet1(vec2 p) {\n    const float bwidth = 0.1;\n    const float swidth = 0.05;\n    const float cradius = 0.74;\n    const float hradius = 0.4;\n    p = cmm(p);\n#if SHOW_CMM==1\n    st_assert(p.x > 0.02 && p.y > 0.02 && p.x+p.y < 1.-0.04);\n#endif\n    float sd = -1000.;\n    sd = max(sd, -sdCircle(p, cradius));\n    sd = min(sd, sdCircle(p, cradius-bwidth));\n    sd = max(sd, -sdHexagon(p, hradius));\n    sd = min(sd, sdHexagon(p, hradius-bwidth));\n    sd = max(sd, -sdLine(p.x > p.y ? p.xy : p.yx, cradius-bwidth/2., 1., bwidth));\n    sd = max(sd, -sdLine(rotMod(p, 6, 0.), 0., cradius, swidth));\n    sd = max(sd, -sdLine(rotMod(p, 6, 0.5), hradius*2./sqrt(3.)-swidth/2., cradius, swidth));\n    return vec3(sd, float(sdHexagon(p, hradius-bwidth/2.) < 0.), float(sdCircle(p, cradius-bwidth/2.) < 0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 5.;\n    float pixelSize = 5./iResolution.y;\n    float blur = 0.75*pixelSize;\n    \n    const float tmod = 5.;\n    float t = mod(iTime, tmod);\n    float idt = floor(iTime/tmod);\n    vec2 dir = sign(sin(1.+idt*1234.))*(mod(idt, 2.) < 1. ? vec2(1., 0.) : vec2(0., 1.));\n    uv += 2.*dir*t/tmod;\n\n    vec3 c = carpet1(uv);\n    vec3 extCol = vec3(0.5, 0.3, 0.7);\n    vec3 cirCol = vec3(1.0, 0.4, 0.5);\n    vec3 hexCol = vec3(1.0, 0.8, 0.4);\n    vec3 col = smoothstep(blur, -blur, c.x)*((1.-c.z)*extCol + c.z*(1.-c.y)*cirCol + c.y*hexCol);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Thanks iq for the 2d sdf!\nfloat sdHexagon( in vec2 p, in float r ) {\n    p = p.yx;\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}","name":"Common","description":"","type":"common"}]}