{"ver":"0.1","info":{"id":"WtKGWR","date":"1578750649","viewed":189,"name":"DotConnectVisualizer","username":"olealgo","description":"artOfCode helps me get a better understanding of shaders.","likes":8,"published":1,"flags":64,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MtSGR1","filepath":"https://soundcloud.com/de-best-beats/freestyle-hip-hop-rap","previewfilepath":"https://soundcloud.com/de-best-beats/freestyle-hip-hop-rap","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 1. Create grid cell 3x3\n// 2. Create a random pixel inside each grid\n// 3. Connect the pixels with lines\n// 4. Add effects\n\n// Procedural programming\n\n\n#define S(a, b, t) smoothstep (a, b, t)\n\n\nfloat DistLine(vec2 p, vec2 startPoint, vec2 endPoint) {\n\n    vec2 pointA = p - startPoint;\n    vec2 pointB = endPoint - startPoint;\n    \n    float t = clamp(dot(pointA, pointB) / dot (pointB, pointB), 0., 1.);\n    return length(pointA - pointB*t);\n}\n\n\nfloat N21(vec2 p) {\n    // Random float between 0 and 1\n    p = fract(p*vec2(233.42, 472.21));\n    \n    // make more random \n    p += dot(p, p+59.31);\n    return fract(p.x*p.y);\n\t\n}\n\n\nvec2 N22(vec2 p) {\n\n    // Random vec2\n    // for Random X and random Y\n    \n   float n = N21(p);\n   return vec2(n, N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 offset) {\n   \t\n    vec2 noise = N22(id + offset)*iTime;\n    \n    return offset + sin(noise) *.4;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b) {\n\n    float d = DistLine(p, a, b);\n\tfloat m = S(.03, .01, d);\n    float dist = length(a-b);\n       \n    m *= S(1.2, .08, dist)*3. + S(.05, .01, abs(dist-.5));\n    return m;\n}\n\nfloat GridDotConnectLayer(vec2 uv) {\n \n    vec2 gridUv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    \n    float m;\n    \n    int i = 0;\n    for (float y=-1.; y <= 1.; y++) {\n    \tfor (float x=-1.; x <= 1.; x++) {\n    \t\t p[i++] = GetPos(id, vec2(x, y));\n    \t}\n    }\n    \n    // Draw lines\n    float t = iTime*10.;\n    \n    for(int i=0; i < 9; i++) {\n        m += Line(gridUv, p[4], p[i]);\n        \n        // Current point\n        vec2 j = (p[i]-gridUv)*25.;\n        float sparkle =  1. / dot(j, j);\n        m += sparkle; //* (sin(t+p[i].*x10.)*.5+.5);\n    }\n    // add additional lines to hidden lines\n    m += Line(gridUv, p[1], p[3]);\n    m += Line(gridUv, p[1], p[5]);\n    m += Line(gridUv, p[5], p[7]);\n    m += Line(gridUv, p[7], p[3]);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    // normalized uv coords\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    \n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) - .5;\n    \n    //vec2 p = GetPos(id);\n    //float dot = length(gridUv-p);\n    //m =  S(.1, .05, dot); \n    \n    float gradient = uv.y;\n    \n    float m = 0.;\n    float t = iTime*.25;\n \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    \n    uv *= rot;\n    mouse *= rot;\n    \n    for(float i=0.; i <= 1.; i+= 1./4.) {\n        float z = fract(i+t*1.3);\n        float size = mix(8.5, 2., z);\n        float fade = S(0., .5, z) * S(1., .8, z);\n        m+= GridDotConnectLayer(uv*size+i*20.-mouse) * fade;\n    }\n    \n    vec3 base = sin( t * vec3( .345, .456, .43 ))*.2 + .5;\n   \n    vec3 col = vec3( m * base);\n    col += gradient + S(.35, .55, base) * .35;\n    \n    // coords for the s-tex\n\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n\n    // s-tex 512x2\n    int tx = int(uv2.x*512.0);\n    \n\t// (48Khz/4 in 512 texels == 23 Hz/texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    float wave = texelFetch( iChannel0, ivec2(tx, 0.5), 0 ).x;\n\tcol += 1.0-S( 0., 0.5, abs(wave - 0.99));\n\n    \n    //m = N22(uv).x;\n    //col.rg += gridUv;\n    //col.rg = id*.2;\n    //if(gridUv.x >0.48 || gridUv.y>0.48) col = vec3(1,0,0);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}