{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define PI\t3.14159265359\n#define PI2\tPI * 2.0\n\n\nmat2 rotate(in float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nfloat hash(in vec3 p){\n\tp  = fract(p * vec3(.16532,.17369,.15787));\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat smin(in float a, in float b, in float k)\n{   \n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;   \n}\n\nvec2 TE1(in vec2 p)\n{\n\tp.y -= 1.5 * pow(p.x, 2.0) + 0.2;\n    return p;\n}\n\nvec2 TE2(in vec2 p)\n{\n    vec2 q = p;\n    p.x = abs(p.x) - 0.3; \t\n \tp.x += 0.4 * p.y;\n    p.x = abs(p.x - 0.5) - 0.25; \t\n\tp.x += 0.4 * p.y;\n\tp.x = abs(p.x); \t\n    p.y += clamp(3.0 * pow(p.x - 0.2, 2.0), 0.0, 0.5) + 0.1;\n    p.y -= abs(0.2 * q.x);\n    return p;\n}\n\nvec2 TE3(in vec2 p)\n{\n    p.x =abs(p.x);\n    p.x += 0.8 * pow(p.y + 0.2, 2.0);\n    p.x += 0.7 * p.y;\n    p.x -= 1.6;\n    return p;\n}\n\nvec2 TE4(in vec2 p, in float t)\n{\n    t = t * PI2 + iTime * 2.5;\n    p.x -= 0.2 * sin(t) * p.y * p.y;\n    float a = PI / 2.0 + 0.4 * sin(t);\n    p *= rotate(-a + PI / 2.0);\n    vec2 v = vec2(cos(a), sin(a));\n    p -= 2.0 * min(0.0, dot(p, v)) * v;\n    return p;    \n}\n\nfloat DEBat(in vec3 p, in float t)\n{\n    vec2 te1 = TE1(p.xy);\n    vec2 te2 = TE2(p.xy);\n    vec2 te3 = TE3(p.xy);\n    p.zx = TE4(p.zx, t);\n\tfloat de1 = max(abs(p.z) - 0.005, max(te1.y, max(-te2.y, min(1.0, te3.x))));\n    float de2 = min(min(\n       max(te3.x, length(vec2(te1.y, p.z)) - 0.01),\n       max(-te2.y, length(vec2(te2.x, p.z)) - 0.01)),\n       max(te1.y, max(-te2.y, length(vec2(te3.x, p.z)) - 0.01)));   \n    p.y *= 0.7 * pow(p.y, 0.7);\n    p.y -= 0.1;\n    p.y -=  0.15 * smoothstep(0.1, 0.0, length(abs(p.zx) - vec2(0.0, 0.15))) * step(0.0, p.y);       \n    float de3 = length(p) - 0.12;\n    return smin(smin(de1, de2, 30.0), de3, 30.0);\n}\n\nfloat DE(in vec3 p)\n{   \n    p *= 0.8;\n    p.yz *= rotate(iTime * 0.3123);\n    p.zx *= rotate(iTime * 0.5123);\n    p.x += 0.5 * sin(iTime);\n    // Sparse grid (https://www.shadertoy.com/view/XlfGDs)\n    const float c = 4.5;\n\tvec3 ip = floor(p / c);\n    p = mod(p, c) - c / 2.0;\n    float rnd = hash(ip);\n   \tfloat de = 1.0;\n    if (length(ip) - 3.0 < 0.0)\n    if (rnd > 0.6)\n    {\n        p.yz *= rotate(PI * 0.4);\n        de = min(de, DEBat(p, rnd));\n    }\n    return de;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tDE(p + e.xyy) - DE(p - e.xyy),\n\t\tDE(p + e.yxy) - DE(p - e.yxy),\n\t\tDE(p + e.yyx) - DE(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 32.0;\n\tconst float precis = 0.005;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = DE(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p2 = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    //vec3 col = 0.6 * length(p2) * texture(iChannel0, vec2(length(p2), atan(p2.y, p2.x) / PI2) * 2.0).rgb;\n    float d = inversesqrt(length(p2));\n    //vec3 col = 0.5 * d * texture(iChannel0, vec2(d * 2.0, atan(p2.y, p2.x) / PI2) * 2.0).rgb;\n    vec3 col = 0.75 * (2.0 - d) * texture(iChannel0, vec2(d * 2.0, atan(p2.y, p2.x) / PI2) * 2.0).rgb;\n    col = clamp(col, 0.0, 0.6);\n  \tvec3 rd = normalize(vec3(p2, -1.5));\n\tvec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 p3 = ro + t * rd;\n        vec3 n = calcNormal(p3);\n\t\tfloat dif = clamp((dot(n, li) + 0.5) * 0.7, 0.3, 1.0);\n        //col = vec3(0.15) * dif;\n        col = vec3(0.3,0.1,0.1) * dif;\n        col += pow(max(dot(reflect(rd,n),li),0.), 60.);\n \t}\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtS3Rz","date":"1426682802","viewed":1245,"name":"Bats","username":"gaz","description":"3d","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","de"],"hasliked":0,"parentid":"","parentname":""}}