{"ver":"0.1","info":{"id":"WsB3Dz","date":"1548565619","viewed":210,"name":"Trefoil Knot","username":"oalpha","description":"Trefoil knor.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","knot","trefoil"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AMBIENT_LIGHT   0\n#define POINT_LIGHT     1\n#define CONE_LIGHT      2\n#define DIRECTION_LIGHT 3\nstruct light {\n    int type;\n    vec3 position;\n    vec3 color;\n    float intensity;\n    vec3 direction;\n    float falloff;\n    float spread;\n    float taper;\n};\nlight ambientLight(vec3 color, float intensity) {\n    return  light(\n        AMBIENT_LIGHT, // type\n        vec3(0.0), // position (N/A)\n        color, // color\n        intensity, // intensity\n        vec3(0.0), //direction (N/A)\n        0.0, // falloff (N/A)\n        0.0, // spread (N/A)\n        0.0 // taper (N/A)\n    );\n}\nlight ambientLight(float color, float intensity) {\n    return ambientLight(vec3(color), intensity);\n}\nlight pointLight(vec3 position, vec3 color, float intensity, float falloff) {\n    return light(\n        POINT_LIGHT, // type\n        position, // position\n        color, // color\n        intensity, // intensity\n        vec3(0.0), //direction (N/A)\n        falloff, // falloff\n        0.0, // spread (N/A)\n        0.0 // taper (N/A)\n    );\n}\nlight pointLight(vec3 position, float color, float intensity, float falloff) {\n    return pointLight(position, vec3(color), intensity, falloff);\n}\nlight directionLight(vec3 direction, vec3 color, float intensity) {\n    return light(\n        DIRECTION_LIGHT, // type\n        vec3(0.0), // position (N/A)\n        color, // color\n        intensity, // intensity\n        direction, //direction\n        0.0, // falloff (N/A)\n        0.0, // spread (N/A)\n        0.0 // taper (N/A)\n    );\n}\n#define LAMBERT_DIFFUSE   0\n#define ORENNAYAR_DIFFUSE 1\n#define PHONG_SPECULAR 0\nstruct material {\n    float roughness;\n    vec3 ambientalbedo;\n    int diffusetype;\n    vec3 diffusealbedo;\n    int speculartype;\n    vec3 specularalbedo;\n};\nstruct point {\n    vec3 source;\n    vec3 direction;\n    vec3 position;\n    vec3 normal;\n    float marchlength;\n    int iterations;\n    float closestlength;\n    float closestdistance;\n    float penumbra;\n};\nstruct lightpath {\n    point p;\n    light l;\n    vec3 normal;\n    float ilength;\n    vec3 iray;\n    vec3 vray;\n    vec3 rray;\n    vec2 incident;\n    vec2 view;\n    vec2 reflected;\n    float energy;\n};\nlightpath Lightpath(point p, light l, vec3 n) {\n    vec3 i;\n    float il;\n    if(l.type == DIRECTION_LIGHT) {\n        i = -l.direction;\n        il = 0.0;\n    }\n    else {\n        i = l.position - p.position;\n        il = length(i);\n        i = normalize(i);\n    }\n    vec3 v = -p.direction;\n    vec3 r = 2.0 * dot(i, n) * n - i;\n    vec3 t = normalize(cross(cross(n, i), n));\n    vec3 tv = normalize(cross(cross(n, v), n));\n    vec3 tr = normalize(cross(cross(n, r), n));\n    float energy;\n    if(l.type != DIRECTION_LIGHT) {\n        energy = l.intensity / pow(il, l.falloff);\n        if(l.type == CONE_LIGHT)\n            energy *= pow((l.spread - acos(dot(-i, l.direction))) / l.spread, l.taper);\n    }\n    else\n        energy = l.intensity;\n    return lightpath(\n        p,\n        l,\n        n,\n        il,\n        i,\n        v,\n        r,\n        vec2(dot(n, i), 0.0), // incident\n        vec2(dot(n, v), dot(t, tv)), // view\n        vec2(dot(n, r), dot(t, tr)), // reflected\n        energy\n    );\n}\nstruct distanceestimation {\n    vec3 p;\n    vec3 s;\n    vec3 d;\n    float l;\n    vec3 n;\n};\nconst float a = 0.2;\nconst float b = .2;\nconst float a2 = a * a,\n    c = a2 - b * b;\nconst float a24 = 4. * a2;\nconst float a28 = 8. * a2;\nfloat DistanceEstimator(inout distanceestimation d) {\n    vec3 p = d.p;\n    vec2 q = p.xy;\n    float x = q.x;\n    float x2 = x * x;\n    float x3 = x2 * x;\n    float y = q.y;\n    float y2 = y * y;\n    float y3 = y2 * y;\n    float z = p.z;\n    float z2 = z * z;\n    float r2 = x2 + y2;\n    float r4 = r2 * r2;\n    float r48 = 8. * r4;\n    float r = sqrt(r2);\n    float r21 = r2 + 1.;\n    float xp = x3 - 3. * x * y2;\n    float yp = 3. * x2 * y - y3;\n    float D = r21 + z2 + c;\n    float A = a28 * yp * z;\n    float az = a2 * z2;\n    float xy23 = 3. * x * y2;\n    \n    d.l = sqrt(pow(r - a, 2.) + z2) - b;\n    d.l = min(\n        d.l,\n        sqrt(pow(r - 2., 2.) + z2) - b\n    );\n    \n    float t1 = -r48 * D +\n        a24 * (\n            2. * r4 -\n            xp * r21\n        ) +\n        A +\n        4. * az * xp;\n    float t2 = 2. * r2 * D +\n        r48 + a24 * (\n            2. * xp -\n            r2 * r21\n        ) -\n        A -\n        4. * r2 * az;\n    vec2 qu = q / r;\n    float phi = atan(qu.y,qu.x);\n    float psi = 3. * phi / 2.;\n    d.l = distance(\n        vec2(r, z),\n        vec2(1. + a * cos(psi), a * sin(psi))\n    ) - b;\n    d.l = min(d.l, distance(\n        vec2(r, z),\n        vec2(1. - a * cos(psi), -a * sin(psi))\n    ) - b);\n    //d.l = t1 * t1 - r2 * t2 * t2;\n    //d.s = normalize(d.p);\n    return d.l;\n}\nvec3 normal(vec3 p) {\n    float diff = 0.00001;\n    distanceestimation d = distanceestimation(\n        vec3(0.0), //p\n        vec3(0.0), //s\n        vec3(0.0), //d\n        0.0, //l\n        vec3(0.0) //n\n    );\n    d.p = p - diff * i3;\n    float nx = DistanceEstimator(d);\n    d.p = p + diff * i3;\n    float px = DistanceEstimator(d);\n    d.p = p - diff * j3;\n    float ny = DistanceEstimator(d);\n    d.p = p + diff * j3;\n    float py = DistanceEstimator(d);\n    d.p = p - diff * k3;\n    float nz = DistanceEstimator(d);\n    d.p = p + diff * k3;\n    float pz = DistanceEstimator(d);\n    return normalize(vec3(\n        px - nx,\n        py - ny,\n        pz - nz\n    ));\n}\nvoid trace(inout point tracePoint, float k) {\n    float pdis = 1e20, dis;\n    tracePoint.direction = normalize(tracePoint.direction);\n    tracePoint.iterations = 0;\n    distanceestimation d = distanceestimation(\n        vec3(0.0),\n        vec3(0.0),\n        tracePoint.direction,\n        0.0,\n        vec3(0.0)\n    );\n\tfor (int steps = 0; steps < MaximumRaySteps; steps++) {\n        if(\n            tracePoint.iterations == 0\n            || abs(dis) > MinimumDistance\n            && tracePoint.marchlength < MaximumDistance\n            && length(Center - tracePoint.position) < MaximumRadius\n        ) {\n            tracePoint.position = tracePoint.source + tracePoint.marchlength * tracePoint.direction;\n            d.p = tracePoint.position;\n            dis = DistanceEstimator(d);\n            tracePoint.normal = d.n;\n            tracePoint.marchlength += dis;\n            float y = dis*dis/(2.0*pdis);\n\t\t\tfloat d = sqrt(dis*dis-y*y);\n            pdis = dis;\n            if(steps == 0) {\n                tracePoint.closestdistance = d;\n                tracePoint.closestlength = max(0.0,tracePoint.marchlength-y);\n                tracePoint.penumbra = k * d/max(0.0,tracePoint.marchlength-y);\n            }\n            else {\n                if(d < tracePoint.closestdistance) {\n                    tracePoint.closestdistance = d;\n                    tracePoint.closestlength = max(0.0,tracePoint.marchlength-y);\n                }\n                tracePoint.penumbra = min(tracePoint.penumbra, k * d/max(0.0,tracePoint.marchlength-y));\n            }\n            tracePoint.iterations++;\n        }\n\t}\n    if(length(Center - tracePoint.position) > MaximumRadius || tracePoint.marchlength > MaximumDistance) {\n        tracePoint.position = vec3(0.0);\n        tracePoint.iterations = MaximumRaySteps;\n    }\n}\nmat3 lookAt(vec3 camera, vec3 target, vec3 up, float film, vec2 fov) {\n    vec3 z = normalize(camera - target);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    return film * mat3(\n        fov.x,0.0,0.0,\n        0.0,fov.y,0.0,\n        0.0,0.0,1.0\n    ) * mat3(x, y, -z);\n}\nvec3 lambert(material m, lightpath lp) {\n    return m.diffusealbedo / PI * lp.l.color * max(0.0, lp.energy * lp.incident.x);\n}\nvec3 orennayar(material m, lightpath lp) {\n    float roughness = tan(0.999 * m.roughness * PI / 2.0);\n    float A = 1.0 - 0.5 * m.roughness / (m.roughness + 0.33);\n    float B = 0.45 * m.roughness / (m.roughness + 0.09);\n    float ca = max(lp.incident.x, lp.view.x);\n    float cb = min(lp.incident.x, lp.view.x);\n    float sa = sqrt(1.0 - ca * ca);\n    float tb = sqrt(1.0 / (cb * cb) - 1.0);\n    return m.diffusealbedo / PI * lp.l.color * max(0.0, lp.energy * lp.incident.x * (A + (B * max(0.0, lp.view.y) * sa * tb)));\n}\nvec3 phong(material m, lightpath lp) {\n    float shininess = tan(0.999 * (1.0 - m.roughness) * PI / 2.0);\n    return m.specularalbedo / PI * lp.l.color * max(0.0, lp.energy * lp.incident.x * pow(dot(lp.rray, lp.vray), shininess));\n}\nvoid lighting(inout vec3 r, inout vec3 a, material m, light l, point p, vec3 n) {\n    if(l.type == AMBIENT_LIGHT) {\n        a += m.ambientalbedo / PI * l.color * l.intensity;\n        a = clamp(a, 0.0, 1.0);\n    }\n    else {\n        lightpath lp =  Lightpath(p, l, n);\n        vec3 L;\n        if(m.diffusetype == LAMBERT_DIFFUSE)\n            L = lambert(m, lp);\n        else if(m.diffusetype == ORENNAYAR_DIFFUSE)\n            L = orennayar(m, lp);\n        vec3 S;\n        if(m.speculartype == PHONG_SPECULAR)\n            L += phong(m, lp);\n        if(false && length(L) > 0.0001) {\n            point sp = point(\n                p.position + lp.iray * 0.01, // source\n                lp.iray, // direction\n                vec3(0.0), // position\n                vec3(0.0), // normal\n                0.0, // marchlength\n                0, // iterations\n                0.0, // closestlength\n                0.0, // closestdistance\n                0.0 // penumbra\n            );\n            trace(sp, 1.0);\n            float sf = exm1_ex(sp.penumbra);\n            sf = 1.0;\n            if(sp.iterations < MaximumRaySteps && sp.marchlength < lp.ilength)\n                sf = 0.0;\n            L *= sf;\n        }\n        r = clamp(r + L, 0.0, 1.0);\n    }\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //#define BUFFCHECK\n    #ifndef BUFFCHECK\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    float h = 2.0 / iResolution.x;\n    //uv.x *= iResolution.x / uResolution.y;\n    float t = 1.0 * iTime * 0.25;\n    \n    vec3 camera = mat3(\n        cos(t), -sin(t), 0.0,\n        sin(t),  cos(t), 0.0,\n           0.0,     0.0, 0.75\n    ) * vec3(1., 1., 3.);\n    mat3 raycaster = lookAt(\n        camera,\n        vec3(0.), // target\n        vec3(0.0, 0.0, 1.0), // up\n        0.5, // film\n        vec2(1.0) // fov\n    );\n    \n    light la = ambientLight(1.0, 0.0);\n    float intensity = 2048.0;\n    light lp1 = pointLight(\n        vec3(8.0, 8.0, 8.0), // position\n        normalize(vec3(0.8, 0.3, 1.0)), // color\n        intensity, // intensity\n        2.0 // falloff\n    );\n    light lp2 = pointLight(\n        vec3(-8.0, -8.0, 8.0), // position\n        normalize(vec3(0.32, 0.9, 1.2)), // color\n        intensity, // intensity\n        2.0 // falloff\n    );\n    light lp3 = pointLight(\n        vec3(-8.0, 8.0, -8.0), // position\n        normalize(vec3(1.0, 0.97, 0.46)), // color\n        intensity, // intensity\n        2.0 // falloff\n    );\n    light lp4 = pointLight(\n        vec3(8.0, -8.0, -8.0), // position\n        normalize(vec3(0.53, 1.0, 0.16)), // color\n        intensity, // intensity\n        2.0 // falloff\n    );\n    material m = material(\n        0.0, // roughness\n        vec3(1.0), // ambientalbedo\n        //LAMBERT_DIFFUSE, // diffusetype\n        ORENNAYAR_DIFFUSE, // diffusetype\n        //vec3(0.3), // diffusealbedo\n        vec3(0.125), // diffusealbedo\n        //vec3(1.0), // diffusealbedo\n        //vec3(0.0), // diffusealbedo\n        PHONG_SPECULAR, // speculartype\n        vec3(0.5) // specularalbedo\n        //vec3(0.0) // specularalbedo\n    );\n    vec3 bg = vec3(0.53, 0.81, 0.98);\n    \n    #define SAMPLES 2\n    vec3 pixel = vec3(0.0);\n    \n    float fsn = float(SAMPLES);\n    float factor = 1.0 / (fsn * fsn);\n    for(int i = 0; i < SAMPLES; i++)\n        for(int j = 0; j < SAMPLES; j++) {\n            vec2 cuv = uv + h * (factor * vec2(float(i), float(j)) - 0.5 + 0.5 / fsn);\n            point p = point(\n                camera, // source\n                raycaster * vec3(cuv, 1.0), // direction\n                vec3(0.0), // position\n                vec3(0.0), // normal\n                0.0, // marchlength\n                0, // iterations\n                0.0, // closestlength\n                0.0, // closestdistance\n                0.0 // penumbra\n            );\n            trace(p, 1.0);\n\n            vec3 v;\n            if(p.iterations < MaximumRaySteps) {\n                vec3 n = p.normal;\n                if(length(n) < 0.001)\n                    n = normal(p.position);\n                vec3 reflection = vec3(0.0), ambient = vec3(0.0);\n                lighting(reflection, ambient, m, lp1, p, n);\n                lighting(reflection, ambient, m, lp2, p, n);\n                lighting(reflection, ambient, m, lp3, p, n);\n                lighting(reflection, ambient, m, lp4, p, n);\n                lighting(reflection, ambient, m, la, p, n);\n                float occlusion = 1.0 - float(p.iterations) / float(MaximumRaySteps);\n                \n                // Output to screen\n                v = clamp((reflection + ambient), 0.0, 1.0);\n                //v = clamp(occlusion * ambient, 0.0, 1.0);\n                //v = vec3(occlusion);\n                //v = n * 0.5 + 0.5;\n                //v = normalize(p) * 0.5 + 0.5;\n                //v = normalize(p) / length(p) * 0.5 + 0.5;\n                //v = mix(v, bg, log(clamp(p.marchlength - 100.0, 0.0, 1.0) + 1.0));\n            }\n            else {\n                v = vec3(0.0);\n                v = bg;\n            }\n            pixel += v * factor;\n        }\n    fragColor = vec4(pixel, 1.0);\n    #else\n    fragColor = texture(iChannel0, Mod(fragCoord/iResolution.xy, 1.0));\n\t#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.141592653589793238462643383279\n#define PI2 6.283185307179586476925286766559\n\n#define i2 vec2(1.0, 0.0)\n#define j2 vec2(0.0, 1.0)\n#define i3 vec3(1.0, 0.0, 0.0)\n#define j3 vec3(0.0, 1.0, 0.0)\n#define k3 vec3(0.0, 0.0, 1.0)\n#define i4 vec4(1.0, 0.0, 0.0, 0.0)\n#define j4 vec4(0.0, 1.0, 0.0, 0.0)\n#define k4 vec4(0.0, 0.0, 1.0, 0.0)\n#define l4 vec4(0.0, 0.0, 0.0, 1.0)\n\n#define duo(a, b) a##b\n#define Iterations 1\n#define fIterations float(Iterations)\n#define Power 8.0\n#define Bailout 2.0\n\n#define MaximumRaySteps 200\n#define MaximumDistance 100.0\n#define MinimumDistance 0.001\n#define MaximumRadius 100.0\n\n#define Center vec3(0.0)\n\n#define CURVE(h) curve5(h)\n#undef CURVE\n#define CURVE(h) curve3(h)\n//#undef CURVE\n//#define CURVE(h) h\n\nfloat Dot(vec2 v) {\n    return dot(v, v);\n}\nfloat Dot2(vec2 a, vec2 b) {\n    float d = dot(a, b);\n    return d * d;\n}\nfloat triple(vec3 a, vec3 b, vec3 c) {\n    return dot(a, cross(b, c));\n}\n\nfloat red_e(vec2 v, float f) {return dot(v, vec2(f));}\nfloat red_e(vec3 v, float f) {return dot(v, vec3(f));}\nfloat red_e(vec4 v, float f) {return dot(v, vec4(f));}\nfloat sum_e(vec2 v) {return red_e(v, 1.0);}\nfloat sum_e(vec3 v) {return red_e(v, 1.0);}\nfloat sum_e(vec4 v) {return red_e(v, 1.0);}\nfloat prod_e(vec2 v) {return v.x * v.y;}\nfloat prod_e(vec3 v) {return v.x * v.y * v.z;}\nfloat prod_e(vec4 v) {return v.x * v.y * v.z * v.w;}\nfloat exm1_ex(float x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec2 exm1_ex(vec2 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec3 exm1_ex(vec3 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nvec4 exm1_ex(vec4 x) {\n    return (exp(x) - 1.0) / exp(x);\n}\nfloat Mod(float a, float b) {return a - floor(a / b) * b;}\nvec2  Mod(vec2  a, float b) {return a - floor(a / b) * b;}\nvec2  Mod(vec2  a, vec2  b) {return a - floor(a / b) * b;}\nvec3  Mod(vec3  a, float b) {return a - floor(a / b) * b;}\nvec3  Mod(vec3  a, vec3  b) {return a - floor(a / b) * b;}\nvec4  Mod(vec4  a, float b) {return a - floor(a / b) * b;}\nvec4  Mod(vec4  a, vec4  b) {return a - floor(a / b) * b;}\n\nfloat curve3(float a) {return a * a * (3.0 - 2.0 * a);}\nvec2  curve3(vec2  a) {return a * a * (3.0 - 2.0 * a);}\nvec3  curve3(vec3  a) {return a * a * (3.0 - 2.0 * a);}\nvec4  curve3(vec4  a) {return a * a * (3.0 - 2.0 * a);}\nfloat curve5(float a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\nvec2  curve5(vec2  a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\nvec3  curve5(vec3  a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\nvec4  curve5(vec4  a) {return a * a * a * (10.0 + a * (6.0 * a - 15.0));}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(\n         c, -s,\n         s,  c\n    );\n}\nmat3 rotX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(\n         1.0,  0.0,  0.0,\n         0.0,    c,   -s,\n         0.0,    s,    c\n    );\n}\nmat3 rotY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(\n           c,  0.0,    s,\n         0.0,  1.0,  0.0,\n          -s,  0.0,    c\n    );\n}\nmat3 rotZ(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(\n           c,  -s, 0.0,\n           s,   c, 0.0,\n         0.0, 0.0, 1.0\n    );\n}\nmat4 rotXY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n         1.0, 0.0, 0.0, 0.0,\n         0.0, 1.0, 0.0, 0.0,\n         0.0, 0.0,   c,  -s,\n         0.0, 0.0,   s,   c\n    );\n}\nmat4 rotYZ(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n           c, 0.0, 0.0,  -s,\n         0.0, 1.0, 0.0, 0.0,\n         0.0, 0.0, 1.0, 0.0,\n           s, 0.0, 0.0,   c\n    );\n}\nmat4 rotZW(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n           c,  -s, 0.0, 0.0,\n           s,   c, 0.0, 0.0,\n         0.0, 0.0, 1.0, 0.0,\n         0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotWX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n         1.0, 0.0, 0.0, 0.0,\n         0.0,   c,  -s, 0.0,\n         0.0,   s,   c, 0.0,\n         0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotYW(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n           c, 0.0,   s, 0.0,\n         0.0, 1.0, 0.0, 0.0,\n          -s, 0.0,   c, 0.0,\n         0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotZX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat4(\n         1.0, 0.0, 0.0, 0.0,\n         0.0,   c, 0.0,   s,\n         0.0, 0.0, 1.0, 0.0,\n         0.0,  -s, 0.0,   c\n    );\n}\nmat3 euler_zyx(vec3 a) {return rotX(a.x) * rotY(a.y) * rotZ(a.z);}\nmat4 rot(vec4 a) {return rotXY(a.x) * rotYZ(a.y) * rotZW(a.z) * rotWX(a.w);}\n\nfloat randSin(float x, float o, float r, vec4 ss) {return o + r * fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec2  randSin(vec2  x, float o, float r, vec4 ss) {return o + r * fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec3  randSin(vec3  x, float o, float r, vec4 ss) {return o + r * fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec4  randSin(vec4  x, float o, float r, vec4 ss) {return o + r * fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\n#define RAND randSin\n\nfloat rand1(vec2  v, float o, float r, vec2 d, vec4 s) {return RAND( dot(d, RAND(v, 0.0, 1.0, s)), o, r, s);}\nvec2  rand2(vec2  v, float o, float r, mat2 d, vec4 s) {return RAND( d * RAND(v, 0.0, 1.0, s), o, r, s);}\nfloat rand1(vec3  v, float o, float r, vec3 d, vec4 s) {return RAND( dot(d, RAND(v, 0.0, 1.0, s)), o, r, s);}\nvec3  rand3(vec3  v, float o, float r, mat3 d, vec4 s) {return RAND( d * RAND(v, 0.0, 1.0, s), o, r, s);}\nfloat rand1(vec4  v, float o, float r, vec4 d, vec4 s) {return RAND( dot(d, RAND(v, 0.0, 1.0, s)), o, r, s);}\nvec4  rand4(vec4  v, float o, float r, mat4 d, vec4 s) {return RAND( d * RAND(v, 0.0, 1.0, s), o, r, s);}\nvec2  randRot2(vec2  v, mat2 d, vec4 s) {return rot(rand1(v, 0.0, PI2, d[0], s)) * vec2(1.0, 0.0);}\nvec3  randRot3(vec3  v, mat3 d, vec4 s) {return euler_zyx(rand3(v, 0.0, PI2, d, s)) * vec3(1.0, 0.0, 0.0);}\nvec4  randRot4(vec4  v, mat4 d, vec4 s) {return rot(rand4(v, 0.0, PI2, d, s)) * vec4(1.0, 0.0, 0.0, 0.0);}\n\nfloat perlinGradient(vec2 p, mat2 d, vec4 s) {\n    vec2 r = floor(p);\n    vec2 f = CURVE(fract(p)), F = 1.0 - f;\n    float o = 0.0;\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++) {\n        vec2 b = vec2(i, j);\n        vec2 B = 1.0 - b;\n        vec2 R = r + b;\n        o += dot(randRot2(R, d, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o;\n}\nfloat perlinGradient(vec3 p, mat3 d, vec4 s) {\n    vec3 r = floor(p);\n    vec3 f = CURVE(fract(p)), F = 1.0 - f;\n    float o = 0.0;\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++)\n    for(float k = 0.0; k < 2.0; k++) {\n        vec3 b = vec3(i, j, k);\n        vec3 B = 1.0 - b;\n        vec3 R = r + b;\n        o += dot(randRot3(R, d, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o;\n}\nfloat perlinGradient(vec4 p, mat4 d, vec4 s) {\n    vec4 r = floor(p);\n    vec4 f = CURVE(fract(p)), F = 1.0 - f;\n    float o = 0.0;\n    for(float i = 0.0; i < 2.0; i++)\n    for(float j = 0.0; j < 2.0; j++)\n    for(float k = 0.0; k < 2.0; k++)\n    for(float l = 0.0; l < 2.0; l++) {\n        vec4 b = vec4(i, j, k, l);\n        vec4 B = 1.0 - b;\n        vec4 R = r + b;\n        o += dot(randRot4(R, d, s), p - R) * CURVE(prod_e(b * f + B * F));\n    }\n    return o;\n}\n\nfloat triangle(vec2 a, vec2 b, vec2 c) {\n    vec2 B = b - a, C = c - a;\n    return sqrt(Dot(B) * Dot(C) - Dot2(B, C)) / 2.0;\n}\nfloat tetrahedron(vec3 a, vec3 b, vec3 c, vec3 d) {\n    vec3 B = b - a, C = c - a, D = d - a;\n    return abs(triple(B, C, D)) / 6.0;\n}\nfloat pentachoron(vec4 a, vec4 b, vec4 c, vec4 d, vec4 e) {\n    vec4 B = b - a, C = c - a, D = d - a, E = e - a;\n    return (\n        B.x * triple(C.yzw, D.yzw, E.yzw) -\n        C.x * triple(B.yzw, D.yzw, E.yzw) +\n        D.x * triple(B.yzw, C.yzw, E.yzw) -\n        E.x * triple(B.yzw, C.yzw, D.yzw)\n    ) / 24.0;\n}\n\nivec3 sortD(vec3 v) {\n    if(v.x >= v.y && v.x >= v.z && v.y >= v.z)\n        return ivec3(1, 2, 3);\n    if(v.x >= v.y && v.x >= v.z && v.z >= v.y)\n        return ivec3(1, 3, 2);\n    if(v.y >= v.z && v.y >= v.x && v.z >= v.x)\n        return ivec3(2, 3, 1);\n    if(v.y >= v.z && v.y >= v.x && v.x >= v.z)\n        return ivec3(2, 1, 3);\n    if(v.z >= v.x && v.z >= v.y && v.x >= v.y)\n        return ivec3(3, 1, 2);\n    if(v.z >= v.x && v.z >= v.y && v.y >= v.x)\n        return ivec3(3, 2, 1);\n}\nivec4 sortD(vec4 v) {\n    float x = v.x, y = v.y, z = v.z, w = v.w;\n    if(\n        x >= y && x >= z && x >= w &&\n        y >= z && y >= w &&\n        z >= w\n    )\n        return ivec4(1, 2, 3, 4);\n    if(\n        x >= y && x >= z && x >= w &&\n        y >= z && y >= w &&\n        w >= z\n    )\n        return ivec4(1, 2, 4, 3);\n    if(\n        x >= y && x >= z && x >= w &&\n        z >= y && z >= w &&\n        y >= w\n    )\n        return ivec4(1, 3, 2, 4);\n    if(\n        x >= y && x >= z && x >= w &&\n        z >= y && z >= w &&\n        w >= y\n    )\n        return ivec4(1, 3, 4, 2);\n    if(\n        x >= y && x >= z && x >= w &&\n        w >= y && w >= z &&\n        y >= z\n    )\n        return ivec4(1, 4, 2, 3);\n    if(\n        x >= y && x >= z && x >= w &&\n        w >= y && w >= z &&\n        z >= y\n    )\n        return ivec4(1, 4, 3, 2);\n    if(\n        y >= x && y >= z && y >= w &&\n        x >= z && x >= w &&\n        z >= w\n    )\n        return ivec4(2, 1, 3, 4);\n    if(\n        y >= x && y >= z && y >= w &&\n        x >= z && x >= w &&\n        w >= z\n    )\n        return ivec4(2, 1, 4, 3);\n    if(\n        y >= x && y >= z && y >= w &&\n        z >= x && z >= w &&\n        x >= w\n    )\n        return ivec4(2, 3, 1, 4);\n    if(\n        y >= x && y >= z && y >= w &&\n        z >= x && z >= w &&\n        w >= x\n    )\n        return ivec4(2, 3, 4, 1);\n    if(\n        y >= x && y >= z && y >= w &&\n        w >= x && w >= z &&\n        x >= z\n    )\n        return ivec4(2, 4, 1, 3);\n    if(\n        y >= x && y >= z && y >= w &&\n        w >= x && w >= z &&\n        z >= x\n    )\n        return ivec4(2, 4, 3, 1);\n    if(\n        z >= x && z >= y && z >= w &&\n        x >= y && x >= w &&\n        y >= w\n    )\n        return ivec4(3, 1, 2, 4);\n    if(\n        z >= x && z >= y && z >= w &&\n        x >= y && x >= w &&\n        w >= y\n    )\n        return ivec4(3, 1, 4, 2);\n    if(\n        z >= x && z >= y && z >= w &&\n        y >= x && y >= w &&\n        x >= w\n    )\n        return ivec4(3, 2, 1, 4);\n    if(\n        z >= x && z >= y && z >= w &&\n        y >= x && y >= w &&\n        w >= x\n    )\n        return ivec4(3, 2, 4, 1);\n    if(\n        z >= x && z >= y && z >= w &&\n        w >= x && w >= y &&\n        x >= y\n    )\n        return ivec4(3, 4, 1, 2);\n    if(\n        z >= x && z >= y && z >= w &&\n        w >= x && w >= y &&\n        y >= x\n    )\n        return ivec4(3, 4, 2, 1);\n    if(\n        w >= x && w >= y && w >= z &&\n        x >= y && x >= z &&\n        y >= z\n    )\n        return ivec4(4, 1, 2, 3);\n    if(\n        w >= x && w >= y && w >= z &&\n        x >= y && x >= z &&\n        z >= y\n    )\n        return ivec4(4, 1, 3, 2);\n    if(\n        w >= x && w >= y && w >= z &&\n        y >= x && y >= z &&\n        x >= z\n    )\n        return ivec4(4, 2, 1, 3);\n    if(\n        w >= x && w >= y && w >= z &&\n        y >= x && y >= z &&\n        z >= x\n    )\n        return ivec4(4, 2, 3, 1);\n    if(\n        w >= x && w >= y && w >= z &&\n        z >= x && z >= y &&\n        x >= y\n    )\n        return ivec4(4, 3, 1, 2);\n    if(\n        w >= x && w >= y && w >= z &&\n        z >= x && z >= y &&\n        y >= x\n    )\n        return ivec4(4, 3, 2, 1);\n}\n\nfloat simplexGradient(vec2 p, mat2 d, vec4 s) {\n    float skew = (sqrt(3.0) - 1.0) / 2.0, unskew = (1.0 - 1.0 / sqrt(3.0)) / 2.0;\n    vec2 P = p + sum_e(p) * skew;\n    vec2 L = floor(P);\n    vec2 f = fract(P);\n    vec2 c1 = L;\n    vec2 c2 = c1 + (f.x >= f.y ? i2 : j2);\n    vec2 c3 = L + 1.0;\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    float A = triangle(c1, c2, c3);\n    float w1 = CURVE(triangle(p, c2, c3) / A);\n    float w2 = CURVE(triangle(c1, p, c3) / A);\n    float w3 = CURVE(triangle(c1, c2, p) / A);\n    //#define WEIGHT2\n    #ifdef WEIGHT2\n    return vec3(w1 + w2 + w3) * 0.5;\n    #else\n    #define GRADIENT2\n    #ifdef GRADIENT2\n    float v1 = dot(randRot2(c1, d, s), p - c1);\n    float v2 = dot(randRot2(c2, d, s), p - c2);\n    float v3 = dot(randRot2(c3, d, s), p - c3);\n    return (v1 * w1 + v2 * w2 + v3 * w3) / (w1 + w2 + w3);\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return vec3(w1 > w2 && w1 > w3 ? v1 : w2 > w1 && w2 > w3 ? v2 : v3);\n    #endif\n    #endif\n}\nfloat simplexGradient(vec3 p, mat3 d, vec4 s) {\n    //p.z = 0.0;\n    float skew = 1.0 / 3.0, unskew = 1.0 / 6.0;\n    #define SKEW\n    #ifdef SKEW\n    vec3 P = p + sum_e(p) * skew;\n    #else\n    vec3 P = p;\n    #endif\n    vec3 L = floor(P);\n    vec3 f = fract(P);\n    ivec3 o = sortD(f);\n    vec3 c1 = L;\n    vec3 c2 = c1 + (o.x == 1 ? i3 : o.x == 2 ? j3 : k3);\n    vec3 c3 = c2 + (o.y == 1 ? i3 : o.y == 2 ? j3 : k3);\n    vec3 c4 = L + 1.0;\n    #ifdef SKEW\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    #endif\n    float V = tetrahedron(c1, c2, c3, c4);\n    float w1 = CURVE(tetrahedron(p, c2, c3, c4) / V);\n    float w2 = CURVE(tetrahedron(c1, p, c3, c4) / V);\n    float w3 = CURVE(tetrahedron(c1, c2, p, c4) / V);\n    float w4 = CURVE(tetrahedron(c1, c2, c3, p) / V);\n    //#define WEIGHT3\n    #ifdef WEIGHT3\n    //if(o.x == 1)\n    //    return o.y == 2 ? i3 : 1.0 - i3;\n    //else if(o.x == 2)\n    //    return o.y == 3 ? j3 : 1.0 - j3;\n    //else if(o.x == 3)\n    //    return o.y == 1 ? k3 : 1.0 - k3;\n    return (w1 + w2 + w3 + w4) * 0.5;\n    #else\n    #define GRADIENT3\n    #ifdef GRADIENT3\n    vec3 g1 = randRot3(c1, d, s);\n    vec3 g2 = randRot3(c2, d, s);\n    vec3 g3 = randRot3(c3, d, s);\n    vec3 g4 = randRot3(c4, d, s);\n    vec3 d1 = p - c1;\n    vec3 d2 = p - c2;\n    vec3 d3 = p - c3;\n    vec3 d4 = p - c4;\n    float v1 = dot(g1, d1);\n    float v2 = dot(g2, d2);\n    float v3 = dot(g3, d3);\n    float v4 = dot(g4, d4);\n    //return (w1 > w2 && w1 > w3 && w1 > w4 ? d1 : w2 > w1 && w2 > w3 && w2 > w4 ? d2 : w3 > w1 && w3 > w2 && w3 > w4 ? d3 : d4) * 0.5 + 0.5;\n    //return w1 > w2 && w1 > w3 && w1 > w4 ? g1 : w2 > w1 && w2 > w3 && w2 > w4 ? g2 : w3 > w1 && w3 > w2 && w3 > w4 ? g3 : g4;\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 * w1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 * w2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 * w3 : v4 * w4);\n    return (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4) / (w1 + w2 + w3 + w4);\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    float v4 = rand(c4, 0.0, 1.0, d[0], s);\n    //return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return (w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    #endif\n    #endif\n    //return vec3(w2, w3, w4);\n}\nfloat simplexGradient(vec4 p, mat4 d, vec4 s) {\n    //p.z = 0.0;\n    float skew = (sqrt(5.0) - 1.0) / 4.0, unskew = (1.0 - 1.0 / sqrt(5.0)) / 4.0;\n    #define SKEW\n    #ifdef SKEW\n    vec4 P = p + sum_e(p) * skew;\n    #else\n    vec3 P = p;\n    #endif\n    vec4 L = floor(P);\n    vec4 f = fract(P);\n    ivec4 o = sortD(f);\n    vec4 c1 = L;\n    vec4 c2 = c1 + (o.x == 1 ? i4 : o.x == 2 ? j4 : o.x == 3 ? k4 : l4);\n    vec4 c3 = c2 + (o.y == 1 ? i4 : o.y == 2 ? j4 : o.y == 3 ? k4 : l4);\n    vec4 c4 = c3 + (o.z == 1 ? i4 : o.z == 2 ? j4 : o.z == 3 ? k4 : l4);\n    vec4 c5 = L + 1.0;\n    #ifdef SKEW\n    c1 -= sum_e(c1) * unskew;\n    c2 -= sum_e(c2) * unskew;\n    c3 -= sum_e(c3) * unskew;\n    c4 -= sum_e(c4) * unskew;\n    c5 -= sum_e(c5) * unskew;\n    #endif\n    float V = pentachoron(c1, c2, c3, c4, c5);\n    float w1 = CURVE(pentachoron(p, c2, c3, c4, c5) / V);\n    float w2 = CURVE(pentachoron(c1, p, c3, c4, c5) / V);\n    float w3 = CURVE(pentachoron(c1, c2, p, c4, c5) / V);\n    float w4 = CURVE(pentachoron(c1, c2, c3, p, c5) / V);\n    float w5 = CURVE(pentachoron(c1, c2, c3, c4, p) / V);\n    //#define WEIGHT3\n    #ifdef WEIGHT3\n    if(o.x == 1)\n        return o.y == 2 ? i3 : 1.0 - i3;\n    else if(o.x == 2)\n        return o.y == 3 ? j3 : 1.0 - j3;\n    else if(o.x == 3)\n        return o.y == 1 ? k3 : 1.0 - k3;\n    return (w1 + w2 + w3 + w4 + w5) * 0.5;\n    #else\n    #define GRADIENT3\n    #ifdef GRADIENT3\n    vec4 g1 = randRot4(c1, d, s);\n    vec4 g2 = randRot4(c2, d, s);\n    vec4 g3 = randRot4(c3, d, s);\n    vec4 g4 = randRot4(c4, d, s);\n    vec4 g5 = randRot4(c5, d, s);\n    vec4 d1 = p - c1;\n    vec4 d2 = p - c2;\n    vec4 d3 = p - c3;\n    vec4 d4 = p - c4;\n    vec4 d5 = p - c5;\n    float v1 = dot(g1, d1);\n    float v2 = dot(g2, d2);\n    float v3 = dot(g3, d3);\n    float v4 = dot(g4, d4);\n    float v5 = dot(g4, d5);\n    //return (w1 > w2 && w1 > w3 && w1 > w4 ? d1 : w2 > w1 && w2 > w3 && w2 > w4 ? d2 : w3 > w1 && w3 > w2 && w3 > w4 ? d3 : d4) * 0.5 + 0.5;\n    //return w1 > w2 && w1 > w3 && w1 > w4 ? g1 : w2 > w1 && w2 > w3 && w2 > w4 ? g2 : w3 > w1 && w3 > w2 && w3 > w4 ? g3 : g4;\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    //return vec3(w1 > w2 && w1 > w3 && w1 > w4 ? v1 * w1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 * w2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 * w3 : v4 * w4);\n    return (v1 * w1 + v2 * w2 + v3 * w3 + v4 * w4 + v5 * w5) / (w1 + w2 + w3 + w4 + w5);\n    #else\n    float v1 = rand(c1, 0.0, 1.0, d[0], s);\n    float v2 = rand(c2, 0.0, 1.0, d[0], s);\n    float v3 = rand(c3, 0.0, 1.0, d[0], s);\n    float v4 = rand(c4, 0.0, 1.0, d[0], s);\n    float v5 = rand(c5, 0.0, 1.0, d[0], s);\n    //return vec3(v1 * w1, v2 * w2, v3 * w3);\n    return (w1 > w2 && w1 > w3 && w1 > w4 ? v1 : w2 > w1 && w2 > w3 && w2 > w4 ? v2 : w3 > w1 && w3 > w2 && w3 > w4 ? v3 : v4);\n    #endif\n    #endif\n    //return vec3(w2, w3, w4);\n}\n\n#define NOISE perlinGradient\n//#undef  NOISE\n//#define NOISE simplexGradient\n#define NOISEITERATIONS 1\nfloat fbm(vec2 p, mat2 ss, float as, mat2 d, vec4 s) {\n    float o = 0.0, a = 1.0;\n    vec4 cs = s;\n    for(int i = 0; i < NOISEITERATIONS; i++) {\n        o += NOISE(p, d, s) * a;\n        p *= ss;\n        a *= as;\n        cs = (cs, 1234.5678, 5678.9012, s);\n    }\n    return o;\n}\nfloat fbm(vec3 p, mat3 ss, float as, mat3 d, vec4 s) {\n    float o = 0.0, a = 1.0;\n    vec4 cs = s;\n    for(int i = 0; i < NOISEITERATIONS; i++) {\n        o += NOISE(p, d, s) * a;\n        p *= ss;\n        a *= as;\n        cs = (cs, 1234.5678, 5678.9012, s);\n    }\n    return o;\n}\nfloat fbm(vec4 p, mat4 ss, float as, mat4 d, vec4 s) {\n    float o = 0.0, a = 1.0;\n    vec4 cs = s;\n    for(int i = 0; i < NOISEITERATIONS; i++) {\n        o += NOISE(p, d, s) * a;\n        p *= ss;\n        a *= as;\n        cs = (cs, 1234.5678, 5678.9012, s);\n    }\n    return o;\n}\nfloat fbm1(vec3 p, mat3 d, vec4 ss) {\n    float o = 0.0, s = 1.0, a = 1.0;\n    vec4 cs = ss;\n    o += NOISE(p * s, d, ss) * a;\n    s *= 2.0;\n    a *= 0.25;\n    cs = (cs, 1234.5678, 5678.9012, ss);\n    o += pow(1.0 - abs(NOISE(p * s, d, ss)), 2.0) * a;\n    s *= 2.0;\n    a *= 0.25;\n    cs = (cs, 1234.5678, 5678.9012, ss);\n    o += pow(1.0 - abs(NOISE(p * s, d, ss)), 2.0) * a;\n    s *= 2.0;\n    a *= 0.5;\n    cs = (cs, 1234.5678, 5678.9012, ss);\n    o += NOISE(p * s, d, ss) * a;\n    return o;\n}\nfloat fbm1(vec4 p, mat4 d, vec4 ss) {\n    float o = 0.0, s = 1.0, a = 1.0;\n    vec4 cs = ss;\n    o += NOISE(p * s, d, ss) * a;\n    s *= 2.0;\n    a *= 0.25;\n    cs = (cs, 1234.5678, 5678.9012, ss);\n    o += pow(1.0 - abs(NOISE(p * s, d, ss)), 2.0) * a;\n    s *= 2.0;\n    a *= 0.25;\n    cs = (cs, 1234.5678, 5678.9012, ss);\n    o += pow(1.0 - abs(NOISE(p * s, d, ss)), 2.0) * a;\n    s *= 2.0;\n    a *= 0.5;\n    cs = (cs, 1234.5678, 5678.9012, ss);\n    o += NOISE(p * s, d, ss) * a;\n    return o;\n}\n\nfloat Min(inout vec4 M, float m) {\n    float t;\n    for(int i = 0; i < 4; i++)\n        if(m < M[i]) {\n            t = m;\n            m = M[i];\n            M[i] = t;\n        }\n    return m;\n}\nfloat evoronoi( in vec2 x, vec4 c, mat2 d, vec4 s ) {\n    float fallout = 64.0;\n    vec2 p = floor( x.xy );\n    vec2 f = fract( x.xy );\n\n    vec4 res = vec4(1.0e20);\n    const float range = 1.0;\n    for( float j=-range; j<=range; j++ )\n    for( float i=-range; i<=range; i++ )\n    {\n        vec2 b = vec2( i, j );\n        vec2 r = b - f + rand2( p + b, 0.0, 1.0, d, s );\n        float dis = length( r );\n\n        Min(res, dis);\n    }\n    return dot(res, c);\n}\n#define JUSTMIN\nfloat evoronoi( in vec3 x, vec4 c, mat3 d, vec4 s ) {\n    float fallout = 64.0;\n    ivec3 p = ivec3(floor( x ));\n    vec3 f = fract( x );\n\n    #ifdef JUSTMIN\n    float res = 1.0e20;\n    #else\n    vec4 res = vec4(1.0e20);\n    #endif\n    const int range = 2;\n    for( int k=-range; k<=range; k++ )\n    for( int j=-range; j<=range; j++ )\n    for( int i=-range; i<=range; i++ )\n    {\n        ivec3 b = ivec3( i, j, k );\n        vec3 r = vec3(b) - f + rand3( vec3(p + b), 0.0, 1.0, d, s );\n        float dis = length( r );\n\n        #ifdef JUSTMIN\n        res = min(res, dis);\n        #else\n        Min(res, dis);\n        #endif\n    }\n    #ifdef JUSTMIN\n    return res;\n    #else\n    return dot(res, c);\n    #endif\n}\n#define VORORANGE 2\nvec2 rectvoronoi(in vec2 x, mat2 d, vec4 s) {\n    ivec2 p = ivec2(floor( x ));\n    vec2 f = fract( x );\n\n    ivec2 mb;\n    vec2 mr;\n    float id = 1.0e20;\n    const int range = 3;\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec2 b = ivec2( i, j );\n        vec2 B = vec2(p + b);\n        vec2 rv = rand2(B, 0.0, 1.0, d, s );\n        //vec2 rv = RAND(B, 0.0, 1.0, s);\n        vec2 r = vec2(b) - f + rv;\n        float dis = length( r );\n\n        if(dis < id) {\n            mb = b;\n            mr = r;\n            id = dis;\n        }\n    }\n    float bd = 1.0e20;\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec2 b = mb + ivec2( i, j );\n        vec2 B = vec2(p + b);\n        vec2 rv = rand2(B, 0.0, 1.0, d, s );\n        //vec2 rv = RAND(B, 0.0, 1.0, s);\n        vec2 r = vec2(b) - f + rv;\n        float dis = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        bd = min(bd, dis);\n    }\n    return vec2(id, bd);\n}\nvec2 rectvoronoi(in vec3 x, mat3 d, vec4 s) {\n    ivec3 p = ivec3(floor( x ));\n    vec3 f = fract( x );\n\n    ivec3 mb;\n    vec3 mr;\n    float id = 1.0e20;\n    const int range = 3;\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec3 b = ivec3( i, j, k );\n        vec3 B = vec3(p + b);\n        vec3 rv = rand3(B, 0.0, 1.0, d, s );\n        //vec3 rv = RAND(B, 0.0, 1.0, s);\n        vec3 r = vec3(b) - f + rv;\n        float dis = length( r );\n\n        if(dis < id) {\n            mb = b;\n            mr = r;\n            id = dis;\n        }\n    }\n    float bd = 1.0e20;\n    for( int k=-VORORANGE; k<=VORORANGE; k++ )\n    for( int j=-VORORANGE; j<=VORORANGE; j++ )\n    for( int i=-VORORANGE; i<=VORORANGE; i++ )\n    {\n        ivec3 b = mb + ivec3( i, j, k );\n        vec3 B = vec3(p + b);\n        vec3 rv = rand3(B, 0.0, 1.0, d, s );\n        //vec3 rv = RAND(B, 0.0, 1.0, s);\n        vec3 r = vec3(b) - f + rv;\n        float dis = dot( 0.5*(mr+r), normalize(r-mr) );\n\n        bd = min(bd, dis);\n    }\n    return vec2(id, bd);\n}","name":"Common","description":"","type":"common"}]}