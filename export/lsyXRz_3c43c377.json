{"ver":"0.1","info":{"id":"lsyXRz","date":"1462460270","viewed":363,"name":"Desert of the 3rd kind","username":"Cha","description":"Playing with notes and sound, I've reused Iq scene bridge for this sample. \nI've recreated the five tones from Close encounters of the thid kind.","likes":13,"published":1,"flags":8,"usePreview":0,"tags":["terrain","music","sand","desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on the Bridge sample by inigo quilez \n// https://www.shadertoy.com/view/Mds3z2\n\n//#define STEREO\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\n\treturn -1.0 + 2.0*texture( iChannel2, (uv+0.5)/256.0, -100.0 ).x;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//----------------------------------------------------------------\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n//----------------------------------------------------------------\n\n\nfloat terrain( vec2 x )\n{\n\tvec2 z = x*0.05;\n\t\n\tx *= 0.06*1.0;\n    x += 227.3;\n\t\n\tvec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float a = texture(iChannel1,(p+vec2(0.5,0.5))/1024.0,-32.0).x;\n\tfloat b = texture(iChannel1,(p+vec2(1.5,0.5))/1024.0,-32.0).x;\n\tfloat c = texture(iChannel1,(p+vec2(0.5,1.5))/1024.0,-32.0).x;\n\tfloat d = texture(iChannel1,(p+vec2(1.5,1.5))/1024.0,-32.0).x;\n\tfloat r = mix(mix( a, b,f.x), mix( c, d,f.x), f.y);\n\n    r -= 0.04*(noise( 4.0*x ));\n\t\t\n\tr = r*35.0;\n\t//r = r*15.0 + 5.0;\n\tfloat ss =smoothstep( 0.5, 4.0, abs(z.y) );\n\tr = mix( r, -1.0, 1.0-ss );\n\t\n\tfloat cc = 1.0-smoothstep( 0.1, 2.0, abs(z.x) );\n\tcc *= smoothstep( 0.5, 1.0, abs(z.y) );\n\tr = mix( r, 0.5, cc );\n\n\treturn r;\n}\n\nvec2 map( in vec3 p )\n{\n    vec2 res = vec2(1000.0,-1.0);\n\tvec3  po =vec3(0.0,0.0, 8.0);\n\t\n    // terrain\n\tfloat h = terrain( p.xz );\n\tfloat dd = (p.y - h);\n\t\n    res = vec2(dd, 0.0 );\n    \n    //monoliths  \n    float dis = sdBox(p-po*2.0, vec3(1.0,12.0,2.0));\n    if(dis< res.x)\n        res = vec2(dis, 3.0);\n\n    dis = sdBox(p-po, vec3(1.0,12.0,2.0));\n    if(dis< res.x)\n        res = vec2(dis, 3.5);\n    \n    dis = sdBox(p, vec3(1.0,12.0,2.0));\n    if(dis< res.x)\n        res = vec2(dis, 4.0);\n    \n    dis = sdBox(p+po, vec3(1.0,12.0,2.0));\n    if(dis< res.x)\n        res = vec2(dis, 4.5);\n    \n    dis = sdBox(p+po*2.0, vec3(1.0,12.0,2.0));\n    if(dis< res.x)\n        res = vec2(dis, 5.0);\n\t\n\n    return res;\n}\n\nconst float precis = 0.025;\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 250.0;\n    float h = precis*1.5;\n    float t = 0.0;\n\tfloat d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<140; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t\td = res.y;\n\t\tm = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(precis,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<60; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 1.0 );\n\t\tif( h<0.001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.1 + 1.5*pow(float(aoi)/8.0,2.0);\n        vec3 aopos = pos + nor * hr;\n        float dd = map( aopos ).x;\n        //totao += clamp( (hr-dd)*0.1-0.01,0.0,1.0);\n\t\ttotao += max( 0.0, hr-3.0*dd-0.01);\n    }\n    return clamp( 1.0 - 0.15*totao, 0.0, 1.0 );\n}\n\n\nfloat NoteAtt(float time, float delay)\n{\n    time = mod( time, 10.0 );\n    \n    if (time < delay ) \n        return 0.0;\n    \n    float t = time -delay;\n\treturn clamp(2.0-t, 0.0, 1.0);\n}\n\nvec3 lig = normalize(vec3(-0.5,0.25,-0.3));\n\nvoid ShadeMonolith(in vec3 nor, in vec3 rd, float delay, vec3 tint, out vec4 mate )\n{\n\tfloat c = NoteAtt(iTime, delay);\n    mate.xyz = c*vec3(tint);\n    vec3 scol = vec3(0.9);\n    float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0),32.0 ) );\n\n    mate.xyz += spe*scol;\n}\n\nvoid shade( in vec3 pos, in vec3 nor, in vec3 rd, in float matID, out vec4 mate, out vec2 mate2 )\n{\n\tmate = vec4(0.0);\n\tmate2 = vec2(0.0);\n\t\n    if( matID<3.5 )\t\t\tShadeMonolith(nor, rd, 4.0, vec3(1.0,1.0,1.0), mate);\n    else if( matID<4.0 )\tShadeMonolith(nor, rd, 3.0, vec3(1.0,1.0,0.0), mate);\n    else if( matID<4.5 )    ShadeMonolith(nor, rd, 2.0, vec3(0.9,0.5,0.1), mate);\n    else if( matID<5.0 )\tShadeMonolith(nor, rd, 1.0, vec3(1.0,0.0,0.0), mate);\n    else if( matID<5.5)\t\tShadeMonolith(nor, rd, 0.0, vec3(1.0,0.0,1.0), mate);\n\n\tif( matID<2.5 )\n\t{\n        float iss = smoothstep( 0.5, 0.9, nor.y );\n        iss = mix( iss, 0.9, 0.75*smoothstep( 0.1, 1.0, texturize( iChannel1, 0.1*pos, nor ).x ) );\n\n        vec3 scol = vec3( 0.8, 0.5, 0.2 );\n\n        vec3 cnor = normalize( -1.0 + 2.0*texture( iChannel2, 0.15*pos.xz ).xyz );\n        cnor.y = abs( cnor.y );\n        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,cnor)), 0.0, 1.0), 64.0 ) );\n        mate2.y = spe*iss;\n\n        mate.xyz = mix( mate.xyz, scol, iss );\n\t}    \n\n}\n\nfloat cloudShadow( in vec3 pos )\n{\n\tvec2 cuv = pos.xz + lig.xz*(100.0-pos.y)/lig.y;\n\tfloat cc = 0.1 + 0.9*smoothstep( 0.1, 0.35, texture( iChannel1, 0.0003*cuv + 0.1+0.005*iTime ).x );\n\t\n\treturn cc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\n    //-----------------------------------------------------\n    // animate\n    //-----------------------------------------------------\n\n\tfloat ctime = iTime;\n\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n\tfloat an = sin(0.1*ctime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(30.0*sin(an),15.0,40.0*cos(an));\n    vec3 ta = vec3(2.0,1.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n\t#ifdef STEREO\n\tvec3 fo = ro + rd*100.0; // put focus plane behind Mike\n\tro -= 0.5*uu*eyeID;    // eye separation\n\trd = normalize(fo-ro);\n    #endif\n\n    \n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = 2.5*vec3(0.18,0.33,0.45) - rd.y*1.5;\n\tcol *= 0.9;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(2.0,1.5,0.0)*0.8*pow( sun, 32.0 );\n\n    vec3 bgcol = col;\n\t\n\n\tvec2 cuv = ro.xz + rd.xz*(100.0-ro.y)/rd.y;\n\tfloat cc = texture( iChannel1, 0.0003*cuv +0.1+ 0.013*iTime ).x;\n\tcc = 0.65*cc + 0.35*texture( iChannel1, 0.0003*2.0*cuv + 0.013*.5*iTime ).x;\n\tcc = smoothstep( 0.3, 1.0, cc );\n\tcol = mix( col, vec3(1.0,1.0,1.0)*(0.95+0.20*(1.0-cc)*sun), 0.7*cc );\n\t\n\t\n\t\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(0.0);\n\t\tvec3 bnor = vec3(0.0);\n\t\tshade( pos, nor, rd, tmat.z, mate, mate2 );\n        nor = normalize( nor);\n\t\t\n\t\tvec3 ref = reflect( rd, nor );\n\n\t\t// lighting\n\t\tfloat occ = calcOcc(pos,nor) * clamp(0.7 + 0.3*nor.y,0.0,1.0);\n        float sky = 0.6 + 0.4*nor.y;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.2 + 0.8*dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 64.0 );\n\t\tsha *= cloudShadow( pos );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\n\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.0*dif*vec3(1.70,1.15,0.70)*pow(vec3(sha),vec3(1.0,1.2,2.0));\n\t\tlin += 1.0*sky*vec3(0.05,0.20,0.45)*occ;\n\t\tlin += 1.0*bac*vec3(0.20,0.25,0.25)*occ;\n\t\tlin += 1.2*bou*vec3(0.15,0.20,0.20)*(0.5+0.5*occ);\n        lin += 1.0*fre*vec3(1.00,1.25,1.30)*occ*0.5*(0.5+0.5*dif*sha);\n\t\tlin += 1.0*mate2.y*vec3(1.00,0.60,0.50)*4.0*occ*dif*(0.1+0.9*sha);\n\n\t\t// surface-light interacion\n\t\tcol = mate.xyz*lin;\n\n\t\t// fog\n\t\tcol = mix( bgcol, col, exp(-0.0015*pow(tmat.x,1.0)) );\n\t}\n\n\t// sun glow\n    col += vec3(1.0,0.6,0.2)*0.4*pow( sun, 4.0 );\n\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n    // contrast, desat, tint and vignetting\t\n\tcol = col*0.8 + 0.2*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.333, 0.2 );\n\tcol *= vec3(1.0,1.02,0.96);\n\tcol *= 0.6 + 0.4*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    #ifdef STEREO\n    col *= vec3( eyeID, 1.0-eyeID, 1.0-eyeID );\n\t#endif\n\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"#define Re  294.0\n#define Mi  330.0\n#define Do  262.0\n#define DoM  131.0\n#define Sol  196.0\n\n#define Repeat 0.1 //once every ten seconds\n    \nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvec2 Hash(vec2 p)\n{\n\tp  = fract(p * vec2(1.3983, 1.4427));\n    p += dot(p.yx, p.xy +  vec2(3.5351, 4.3137));\n\treturn fract(vec2(p.x * p.y * 5.4337, p.x * p.y * 7.597));\n}\n\nfloat Noise(float n)\n{\n    float f = fract(n);\n    n = floor(n);\n    f = f*f*(3.0-2.0*f);\n    return mix(Hash(n), Hash(n+1.0), f)-.5;\n}\n\nvec2 Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\nvec2 FBM( vec2 p )\n{\n    p = mod(p, 200.0);\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 3.;\n\tf += 0.2500  * Noise(p); p = p * 3.;\n\tf += 0.1250  * Noise(p); p = p * 3.;\n    f += 0.062125 * Noise(p); p = p * 3.;\n    return f;\n}\n\n\nvec2 Note(float time, float freq, float delay, float amp, float att)\n{\n    if (time < delay ) \n        return vec2(0.0);\n    \n    float t = time -delay;\n    \n\treturn amp*vec2( sin(6.2831*freq*t)*exp(-att*fract(Repeat*t)));  \n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 pos = vec2(time * (1250.5), time * (1200.2));\n    vec2 noise = FBM(pos)* .15 + FBM(pos*8.0)* (.1*Noise(time*.4)+.1);\n\n    \n    time = mod( time, 1.0/Repeat);\n    \n    vec2 melody = Note(time, Re,  0.0, 0.8, 64.0);\n    melody+= \t  Note(time, Mi,  1.0, 1.0, 48.0);\n    melody+= \t  Note(time, Do,  2.0, 1.2, 32.0);\n    melody+= \t  Note(time, DoM, 3.0, 1.0, 48.0);\n    melody+= \t  Note(time, Sol, 4.0, 1.5, 16.0);\n           \n    return melody + 0.5*noise; \n} ","name":"Sound","description":"","type":"sound"}]}