{"ver":"0.1","info":{"id":"NtdyWH","date":"1659895319","viewed":229,"name":"Torus inside the Cube","username":"valena","description":"This work was inspired by this work: https://www.shadertoy.com/view/NslGRN\n\nStandart ray marching with refractions. If ray hits the cube, it refracts and gets into another dimentson where torus is stored.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["torus","refraction","cube","portal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nmat2 rmatrix(float a)    //Rotation matrix;\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\n\treturn mat2(c, -s, s, c);\n}\n\nvec3 getRayDir(vec3 cameraDir, float cameraAngle)\n{\n\tvec2 coord = ((gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0);\n\tcoord.y /= iResolution.x / iResolution.y;\n\tvec3 xAxis = normalize(vec3(-cameraDir.z, 0, cameraDir.x)) * tan(cameraAngle / 2.0);\n\tvec3 yAxis = normalize(cross(cameraDir, xAxis)) * tan(cameraAngle / 2.0) * -1.0;\n\tvec3 result = normalize(cameraDir + xAxis * coord.x + yAxis * coord.y);\n\n\treturn (result);\n}\n\nvec4 map(vec3 p)    //plane and cube map\n{\n    vec2 uv = vec2(0.0);\n    float mat = 0.0;\n    float t = 1000000.0;\n    \n    float cube = length(max(abs(p) - vec3(0.5), vec3(0))) - 0.1;\n    \n    float plane = p.y + 1.5;\n    \n    t = min(cube, plane);\n   \n    if (t == plane)\n    {\n        uv = p.xz;\n        mat = 0.0;\n    }\n    else if (t == cube)\n        mat = 2.0;\n    \n\treturn vec4(t, uv, mat);\n}\n\nvec4 map2(vec3 p)   //torus map\n{\n    vec2 uv = vec2(0.0);\n    float mat = 0.0;\n    float t = 1000000.0;\n    \n    float tr1 = 0.35;\n    float tr2 = 0.15;\n    \n\tfloat torus = length(normalize(vec3(p.x, 0, p.z)) * tr1 - p) - tr2;\n    \n    t = torus;\n    \n    uv.x = atan(p.x, p.z) / PI * 0.5 + 0.5;\n\n    vec3 d = p - normalize(vec3(p.x, 0, p.z)) * tr1;\n    float s = dot(normalize(vec2(p.x, p.z)), normalize(d.xz));\n    vec2 coord2d = vec2(length(d.xz) * s, d.y);\n\n    uv.y = atan(coord2d.x, coord2d.y) / PI * 0.5 + 0.5;\n    \n    \n    mat = 1.0;\n    \n\treturn vec4(t, uv, mat);\n}\n\nvec4 marchRay(vec3 rayOrigin, vec3 rayDir, bool space2)  //almost classic raymarching\n{\n\tfloat t;\n\tfloat d = 0.0;\n\tfloat e = 0.00001;\n\tfloat maxRange = 50.0;\n\tvec3 pos;\n    vec4 info;\n\n\tfor (t = 0.0; t <= maxRange; t += d)\n\t{\n\t\tpos = rayOrigin + rayDir * t;\n        \n        if (!space2)   //space2 tells witch map to use\n            info = map(pos);\n        else\n            info = map2(pos);\n\t\t\n        d = info.x;\n\n\t\tif (d < e)\n\t\t\tbreak;\n\t}\n\tif (t > maxRange)\n\t\treturn vec4(-1.0);\n    \n    info.x = t;\n\treturn info;\n}\n\nvec3 getNorm(vec3 pos)\n{\n\tvec2 e = vec2(0.0001, 0);\n\tfloat tp = map(pos).x;\n\n\tvec3 norm = -normalize(vec3(map(pos - e.xyy).x - tp,\n\t\t\t\t\t\t\t   map(pos - e.yxy).x - tp,\n\t\t\t\t\t\t\t   map(pos - e.yyx).x - tp));\n\treturn (norm);\n}\n\nvec3 getColor(vec4 info)\n{\n   float mat = info.w;\n   vec2 uv = info.yz;\n   \n   if (mat == 1.0)\n   {\n       vec3 c1 = vec3(0, 98, 255) / 255.0;\n       vec3 c2 = vec3(255, 21, 0) / 255.0;\n       \n       float k = sin(fract(uv.y + uv.x * 1.0) * PI);\n       \n       vec3 color = mix(c1, c2, k);\n       \n       color *= pow(abs(sin((uv.y + uv.x * 1.0) * PI / 2.0 * 32.0)), 10.0);\n       \n       return (color);\n   }\n   if (mat == 0.0)\n   {\n       vec2 id = floor(uv);\n       if (mod((id.x + id.y), 2.0) == 0.0)\n           return (vec3(0.5));\n       return vec3(1.0);\n   }\n   return (vec3(0));\n}\n\nfloat getShadow(vec3 rayOrigin, vec3 rayDir)\n{\n\tfloat t;\n\tfloat d = 0.0;\n\tfloat e = 0.00001;\n\tfloat maxRange = 10.0;\n    vec4 info;\n\tvec3 pos;\n    \n    float res = 1.0;\n\n\tfor (t = 0.0; t <= maxRange; t += d)\n\t{\n\t\tpos = rayOrigin + rayDir * t;\n        info = map(pos);\n\t\td = info.x;\n        res = min(res, d / t * 8.0);\n\t\tif (d < e)\n\t\t\tbreak;\n\t}\n        \n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float camPitch = 0.0;\n    float camYaw = iTime / 5.0;\n    float cameraDist = 2.0;\n    \n    camPitch += (iMouse.xy / iResolution.xy + 0.5).y * PI;\n    camYaw += (iMouse.xy / iResolution.xy + 0.5).x * PI * 2.0;\n    \n    camPitch = min(max(PI - 1.2, camPitch), PI + 1.2);\n    \n    vec3 cameraPos = cameraDist * vec3(cos(camYaw) * cos(camPitch), sin(camPitch), sin(camYaw) * cos(camPitch));\n    vec3 cameraDir = -normalize(cameraPos);\n    \n    cameraPos.y = max(-1.49, cameraPos.y);\n    \n\tvec3 rayDir = getRayDir(cameraDir, PI / 2.0);\n\tvec3 rayOrigin = cameraPos;\n    \n    vec4 info = marchRay(rayOrigin, rayDir, false);\n\tfloat t = info.x;\n\n\tvec3 color = vec3(0);\n\n\tif (t != -1.0)\n\t{\n\t\tvec3 pos = rayOrigin + rayDir * t;\n\t\tvec3 lightDir = normalize(vec3(-4, 4, 4));\n\t\tvec3 norm = getNorm(pos);\n\t\tfloat l = 0.1;\n        \n        color = getColor(info);\n        \n        lightDir = normalize(vec3(5) - pos);\n        \n        float mat = info.w;\n        \n        if (mat == 2.0)\n        {\n            float k = 1.33;\n            vec3 pos = rayOrigin + rayDir * info.x;\n            \n            float ra = acos(dot(rayDir, norm) / (length(rayDir) * length(norm)));\n            float ca = asin(k);\n            \n            vec3 refrColor;\n            vec3 reflColor = vec3(0);\n            \n            vec3 rd2 = refract(rayDir, getNorm(pos), 1.0 / k - 0.01);\n            vec4 i = marchRay(pos, rd2, true);\n            refrColor.r = getColor(i).r;\n            \n            rd2 = refract(rayDir, getNorm(pos), 1.0 / k);\n            i = marchRay(pos, rd2, true);\n            refrColor.g = getColor(i).g;\n            \n            rd2 = refract(rayDir, getNorm(pos), 1.0 / k + 0.01);\n            i = marchRay(pos, rd2, true);\n            refrColor.b = getColor(i).b;\n            \n            rd2 = reflect(rayDir, getNorm(pos));\n            i = marchRay(pos + norm * 0.01, rd2, false);\n            if (i.x != -1.0)\n            {\n                reflColor = getColor(i);\n            \n                vec3 pos2 = pos + rd2 * i.x;\n                vec3 norm2 = getNorm(pos2);\n                float st = getShadow(pos2 + norm2 * 0.01, lightDir);\n\n                l = 0.1;\n\n                //st = 0.5;\n\n                l += max(0.0, dot(lightDir, norm2)) * 0.9 * st;\n\n                reflColor *= l;\n            }\n            \n            color = mix(refrColor, reflColor, pow(1.0 + dot(rayDir, norm), 5.0));\n            //color = reflColor;\n        }\n        else\n        {\n            float st = getShadow(pos + norm * 0.001, lightDir);\n\n            l += max(0.0, dot(lightDir, norm)) * 0.9 * st;\n\n            color *= l;\n        }\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}