{"ver":"0.1","info":{"id":"ltSfzd","date":"1518447332","viewed":133,"name":"Project Point to Cube Section","username":"TinyTexel","description":"Projecting a point inside a cube to a planar cross-section of it. \nImplemented in ProjPointToCubeSect using two ray-plane and two ray-cube intersections.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Project Point to Cube Section\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by TinyTexel\n\n/*\nProjecting a point inside a cube to a planar cross-section of it. \nImplemented in ProjPointToCubeSect using two ray-plane and two ray-cube intersections.\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\nconst float Pi2  = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define If(cond, tru, fls) mix(fls, tru, cond)\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n        t = max(vec2(-1.0), t);\n\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\nfloat Length4(vec3 vec)//TODO: fix nans\n{\n\tfloat len4 = Pow4(vec.x) + Pow4(vec.y) + Pow4(vec.z);\n    \n    if(len4 == 0.0) return 0.0;\n    \n\tfloat len = rsqrt(rsqrt(len4));\n\t\n\treturn len;\n}\n\n\nfloat Cube(vec3 x, vec3 b)\n{    \n    vec3 d = abs(x) - b;\n    \n    float inner = max(d.x, max(d.y, d.z)); \n    \n    float box = (inner < 0.0 ? inner : length(max(vec3(0.0), d)));\n    \n    return box;\n}\n\n\n// helper function for ProjPointToCubeSect\nvoid Intersect_Ray_CubeBackside_V0(vec3 rp, vec3 rd, out float t, out vec3 N)\n{\t\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(-1.0), vec3(1.0));\n\n\tvec3 ub = (rp - os) * m;\n\n    ub = abs(ub);//-inf -> inf\n\tt = min(ub.x, min(ub.y, ub.z));\t\n\n    N = If(equal(ub, vec3(t)), vec3(0.0), vec3(1.0));\n}\n\nvec4 ProjPointToCubeSect(vec3 point0, vec3 pn, float pc)// point0 coords in range [-1,1], plane must intersect that cube\n{    \n    //point0 = clamp(point0, -1.0, 1.0);\n    vec3 point = point0 - pn * (dot(pn, point0) - pc);\n\n    if(abs(point.x) < 1.0 && abs(point.y) < 1.0 && abs(point.z) < 1.0) return vec4(point, 0.0);\n    \n    \n    if(pc < 0.0) { pn = -pn; } pc = abs(pc);\n    \n    float t; vec3 n;\n    Intersect_Ray_CubeBackside_V0(point0, pn, /*out:*/ t, n);\n\n    \n    vec3 p = point0 + pn * t;\n\t     p = clamp(p, -1.0, 1.0);\n    \n    vec3 dir = pn * n;\n    \n    {\n        float t; vec3 n;\n\t\tIntersect_Ray_CubeBackside_V0(p, dir, /*out:*/ t, n);\n\n        float a = dot(pn, p) - pc;\n        float b = dot(dir, pn);\n        float pt = b == 0.0 ? 0.0 : a / -b;\n        \n        if(t < pt) \n        {\n            p += dir * t;\n\n            dir *= n;\n\n            float a = dot(pn, p) - pc;\n            float b = dot(dir, pn);\n        \tfloat pt = b == 0.0 ? 0.0 : a / -b;\n            \n            vec3 p2 = p + dir * pt;\n\n            return vec4(p2, SqrLen(p2 - point));\n        }\n        \n    \tvec3 p2 = p + dir * pt;\n\n        return vec4(p2, SqrLen(p2 - point));\n    }\n}\n    \nvec4 ProjPointToCubeSect_Debug(vec3 point, vec3 pn, float pc)// point already on plane; used to eval debug color for plane\n{    \n    if(abs(point.x) < 1.0 && abs(point.y) < 1.0 && abs(point.z) < 1.0) return vec4(point, 0.0);\n       \n    if(pc < 0.0) { pn = -pn; } pc = abs(pc);\n    \n    vec2 t; vec3 n, n1;\n\tfloat hit = Intersect_Ray_Cube(point, -pn, vec3(0.0), vec3(1.0), /*out:*/ t, n, n1);\n    //Intersect_Ray_CubeBackside_V0(point0, pn, /*out:*/ t, n);\n\n    if(hit <= 0.0) return vec4(point, 0.0);    \n    \n    vec3 p = point - pn * t.x;\n\t     p = clamp(p, -1.0, 1.0);\n    \n    vec3 dir = pn * (vec3(1.0) - abs(n));\n    \n    {\n        float t; vec3 n;\n\t\tIntersect_Ray_CubeBackside_V0(p, dir, /*out:*/ t, n);\n\n        float a = dot(pn, p) - pc;\n        float b = dot(dir, pn);\n        float pt = b == 0.0 ? 0.0 : a / -b;\n\n        //if(false)\n        if(t < pt) \n        {\n            p += dir * t;\n\n            dir *= n;\n\n            float a = dot(pn, p) - pc;\n            float b = dot(dir, pn);\n        \tfloat pt = b == 0.0 ? 0.0 : a / -b;\n            \n            //pt = clamp(pt, 0.0, 8.0);//sqrt(12.0)\n            \n            vec3 p2 = p + dir * pt;\n\t     \t     //p2 = clamp(p2, -1.0, 1.0);\n            //if(dot(dir, pn) == 0.0) return vec4(p, SqrLen(p - point));\n            //if(isnan(pt)) return vec4(p, SqrLen(p - point));\n\n            //return vec4(p2, SqrLen(p2 - point));\n        \treturn pt >= 0.0 ? vec4(p2, SqrLen(p2 - point)) : vec4(0.0);\n        }\n        \n    \tvec3 p2 = p + dir * pt;\n\n        //return vec4(p2, SqrLen(p2 - point));\n        return pt >= 0.0 ? vec4(p2, SqrLen(p2 - point)) : vec4(0.0);\n    }\n}\n    \nvec4 ClampPointToCubeSect(vec3 point, vec3 pn, float pc)// point already on plane; valid for all points on plane; not used here\n{\n    #define MIN(a, b) (a.w <  b.w ? a : b)\n    #define MAX(a, b) (a.w >= b.w ? a : b)\n    \n    const float l  = 2.0;\n    const float lh = 1.;\n    \n    vec3 d = abs(point) - lh;\n\n    vec4 rX = vec4(-1.0);\n    vec4 rY = vec4(-1.0);\n    vec4 rZ = vec4(-1.0);\n        \n    if(max(d.y, d.z) > 0.0)// X\n    {\n        float s = 1.0 / pn.x;\n\n        float  o = pc    * s;\n        vec2 off = pn.yz * s;\n\n        vec3 vert0 = vec3(o - lh * (off.x + off.y),  lh,  lh);\n        vec3 vert1 = vec3(o + lh * (off.x + off.y), -lh, -lh);\n\n        vec3 edge0 = vec3(off.y * l, 0.0,  -l);\n        vec3 edge1 = vec3(off.x * l,  -l, 0.0);\n\n        float scale0 = 1.0 / dot(edge0, edge0);        \n        float scale1 = 1.0 / dot(edge1, edge1);        \n\n        {\n            vec3 p0 = vert0 + edge0 * clamp01(dot(point - vert0, edge0) * scale0);\n            vec3 p1 = vert0 + edge1 * clamp01(dot(point - vert0, edge1) * scale1);\n\n            vec4 r0 = vec4(p0, dot(point - p0, point - p0));    \n            vec4 r1 = vec4(p1, dot(point - p1, point - p1)); \n\n            rX = MIN(r0, r1);\n        }\n\n        {\n            vec3 p0 = vert1 + edge0 * -clamp01(dot(point - vert1, edge0) * -scale0);\n            vec3 p1 = vert1 + edge1 * -clamp01(dot(point - vert1, edge1) * -scale1);\n\n            vec4 r0 = vec4(p0, dot(point - p0, point - p0));    \n            vec4 r1 = vec4(p1, dot(point - p1, point - p1)); \n\n            rX = MIN(rX, MIN(r0, r1));\n        }\n    }\n\n    if(max(d.x, d.z) > 0.0)// Y\n    {\n        float s = 1.0 / pn.y;\n\n        float  o = pc    * s;\n        vec2 off = pn.xz * s;\n\n        vec3 vert0 = vec3( lh, o - lh * (off.x + off.y),  lh);\n        vec3 vert1 = vec3(-lh, o + lh * (off.x + off.y), -lh);\n\n        vec3 edge0 = vec3( 0.0, off.y * l,  -l);\n        vec3 edge1 = vec3(  -l, off.x * l, 0.0);\n\n        float scale0 = 1.0 / dot(edge0, edge0);        \n        float scale1 = 1.0 / dot(edge1, edge1);        \n\n        {\n            vec3 p0 = vert0 + edge0 * clamp01(dot(point - vert0, edge0) * scale0);\n            vec3 p1 = vert0 + edge1 * clamp01(dot(point - vert0, edge1) * scale1);\n\n            vec4 r0 = vec4(p0, dot(point - p0, point - p0));    \n            vec4 r1 = vec4(p1, dot(point - p1, point - p1)); \n\n            rY = MIN(r0, r1);\n        }\n\n        {\n            vec3 p0 = vert1 + edge0 * -clamp01(dot(point - vert1, edge0) * -scale0);\n            vec3 p1 = vert1 + edge1 * -clamp01(dot(point - vert1, edge1) * -scale1);\n\n            vec4 r0 = vec4(p0, dot(point - p0, point - p0));    \n            vec4 r1 = vec4(p1, dot(point - p1, point - p1)); \n\n            rY = MIN(rY, MIN(r0, r1));\n        }\n    }\n    \n    if(max(d.x, d.y) > 0.0)// Z\n    {\n        float s = 1.0 / pn.z;\n\n        float  o = pc    * s;\n        vec2 off = pn.xy * s;\n\n        vec3 vert0 = vec3( lh,  lh, o - lh * (off.x + off.y));\n        vec3 vert1 = vec3(-lh, -lh, o + lh * (off.x + off.y));\n\n        vec3 edge0 = vec3(0.0,  -l, off.y * l);\n        vec3 edge1 = vec3( -l, 0.0, off.x * l);\n\n        float scale0 = 1.0 / dot(edge0, edge0);        \n        float scale1 = 1.0 / dot(edge1, edge1);        \n\n        {\n            vec3 p0 = vert0 + edge0 * clamp01(dot(point - vert0, edge0) * scale0);\n            vec3 p1 = vert0 + edge1 * clamp01(dot(point - vert0, edge1) * scale1);\n\n            vec4 r0 = vec4(p0, dot(point - p0, point - p0));    \n            vec4 r1 = vec4(p1, dot(point - p1, point - p1)); \n\n            rZ = MIN(r0, r1);\n        }\n\n        {\n            vec3 p0 = vert1 + edge0 * -clamp01(dot(point - vert1, edge0) * -scale0);\n            vec3 p1 = vert1 + edge1 * -clamp01(dot(point - vert1, edge1) * -scale1);\n\n            vec4 r0 = vec4(p0, dot(point - p0, point - p0));    \n            vec4 r1 = vec4(p1, dot(point - p1, point - p1)); \n\n            rZ = MIN(rZ, MIN(r0, r1));\n        }\n    }\n    \n    return MAX(rZ, MAX(rX, rY));\n\n    #undef MIN    \n    #undef MAX\n}\n\n#if 0\n#define func(x) ClampPointToCubeSect(x, pn, pc).w\n//#define func CubeSect\n\nvec3 GradientCD(vec3 x, vec3 pn, float pc, float o)\n{\n\tfloat xn = func(vec3(x.x - o, x.y, x.z));\n\tfloat xp = func(vec3(x.x + o, x.y, x.z));\n\t\n\tfloat yn = func(vec3(x.x, x.y - o, x.z));\n\tfloat yp = func(vec3(x.x, x.y + o, x.z));\n\t\n\tfloat zn = func(vec3(x.x, x.y, x.z - o));\n\tfloat zp = func(vec3(x.x, x.y, x.z + o));\n\t\n\tvec3 g = vec3(xp - xn, yp - yn, zp - zn) / o * 0.5;\n\t\n\treturn g;\n}\n\nvec2 GradientCD(vec3 x, vec3 ox, vec3 oz, vec3 pn, float pc, float o)\n{\n\tfloat xn = func(x - ox * o);\n\tfloat xp = func(x + ox * o);\n\t\n\tfloat yn = func(x - oz * o);\n\tfloat yp = func(x + oz * o);\n\n\tvec2 g = vec2(xp - xn, yp - yn) / o * 0.5;\n\t\n\treturn g;\n}\n#endif\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n\n    vec2 ang = vec2(Pi * 0.0, -Pi * 0.25);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang - vec2(1.7, 0.2), Pi * 0.5, PixelCount.x / PixelCount.y);\n    vec3 cpos = -cam.Front * 2.0;\n    cpos = -cam.Front * (exp2(2.0 + mouseAccu.w * 0.03));\n    //cpos = -cam.Front * (exp2(1.0 + (mouseAccu.z + mouseAccu.w)*0.02));\n\n    vec3 rdir = NewRay(cam, tex21);\n    \n    //vec2 t;\n\t//float hit = Intersect_Ray_Cube(cpos, rdir, vec3(0.0), vec3(0.5), OUT t);\n\n    vec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(cpos, rdir, vec3(0.0), vec3(1.0), OUT t, n0, n1);\n    \n    if(mod(uv.x + uv.y, 2.0) == 0.0) hit = 0.0;\n    \n    if(hit > 0.0)\n    {\n        col = n0 * 0.5 + 0.5;\n        col *= col;\n    }\n    \n    vec3 sp = vec3(-0.5);\n    {\n        float st = iTime * 1.;\n        sp.x = sin(st * 0.873); sp.y = sin(st + Pi * 0.123); sp.z = sin(st * 1.317 + Pi * 0.373);\n        \n       // sp = vec3(-1.0, -1.0, 1.0);\n\n        #if 1\n    \tvec2 t0;\n\t\tfloat hit0 = Intersect_Ray_Sphere(cpos, rdir, sp, Pow2(0.05), /*out:*/ t0);\n        \n        if(hit0 > 0.0 && (t0.x < t.x || hit <= 0.0))\n        {\n            hit = 1.0;\n            t.x = t0.x;\n            \n            col = vec3(1.0, 0.0, 1.0);\n            n0 = vec3(1.0);\n        }\n        #endif\n    }\n    \n    {\n        vec3 pn0 = vec3(1.0, 0.4, 0.5);\n        vec3 pn = normalize(pn0);\n        //pn = normalize(vec3(0.5, 0.5, 0.5));\n        float pc = -length(pn0)-0.04;//*1.02;\n        \n        vec3 ox, oz;\n\t\tOrthonormalBasisRH(pn, /*out:*/ ox, oz);\n        \n        #if 0\n        vec3 point0 = ox * 0.7 + oz * 1.0 + pn * pc;\n        point0 = (ox * cos(iTime * 0.5) + oz * sin(iTime * 0.5)) * 1.1 + pn * pc;\n        #else\n        vec3 point0 = sp - pn * dot(pn, sp - pn*pc);\n        #endif\n        \n        float d = (dot(pn, cpos) - (pc+0.));//cpos - pn *       \n        float pt = d / dot(-rdir, pn);\n        \n        vec3 ppos = cpos + rdir * pt;\n        \n        if(SqrLen(ppos - pn*pc) < 4.0 && pt > 0.0 && (pt < t.x || hit <= 0.0))\n        {\n            hit = 1.0;\n            t.x = pt;\n\n            col = vec3(1.0);\n\n            vec4 projRes = ProjPointToCubeSect_Debug(ppos, pn, pc);\n\n            //float c = 0.1;\n            //c = 1.0 - clamp01(cos(c * 32.0) * 0.5 + 0.5);\n\n            col = vec3(0.1);                \n\n\t\t\tif(projRes.w > 0.0)\n            {\n                col = vec3(fract(sqrt(projRes.w) * 4.0));\n                \n                vec3 grad = ppos - projRes.xyz;\n                grad -= pn * dot(grad, pn);\n                grad = normalize(grad);\n\n                vec3 gcol = vec3(dot(grad, ox), dot(grad, oz), 0.0) * 0.5 + 0.5; \n                gcol *= gcol;\n\n                col *= gcol;\n            }\n\n\t\t\t#if 1\n            {\n                if(SqrLen(ppos - point0) < 0.001) col = vec3(1.0);\n\n                vec3 ppoint0 = ProjPointToCubeSect(sp, pn, pc).xyz;\n\n                if(SqrLen(ppos - ppoint0) < 0.001) col = vec3(1.0, 0.0, 1.0);\n            }\n            #endif\n\n            n0 = pn;\n        }\n    }\n    \n   //if(hit > 0.0)\n   //{\n   //    col *= vec3(abs(dot(-rdir, n0)));\n   //    //col = mix(vec3(0.0), cb, o) + cf;\n   //    //col = vec3(1.0 - o);\n   //    //col = vec3(cf);\n   //}\n   //else \n   //    col = vec3(0.0);\n\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n    //outCol = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, 0), 0);\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n}","name":"Buffer D","description":"","type":"buffer"}]}