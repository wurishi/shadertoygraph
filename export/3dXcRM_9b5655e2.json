{"ver":"0.1","info":{"id":"3dXcRM","date":"1584327207","viewed":132,"name":"Covid-20","username":"maxbittker","description":"\nMouse-sensitive! \nRemix of charstiles' https://www.shadertoy.com/view/tsfyz4","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["covid19"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat PI = 3.1415;\nfloat PHI = 1.61803398874989;\nconst int steps = 16;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// this function from https://www.shadertoy.com/view/wtSSWh\nfloat n(vec2 u){\n    vec4 d=vec4(.106,5.574,7.728,3.994),q=u.xyxy,p=floor(q);\n    ++p.zw;\n    q-=p;\n    p=fract(p*d.xyxy);\n    d=p+d.wzwz;\n\td=p.xxzz*d.ywyw+p.ywyw*d.xxzz;\n    p=fract((p.xxzz+d)*(p.ywyw+d));\n    p=cos(p*=iTime+d)*q.xxzz+sin(p)*q.ywyw;\n    q*=q*(3.-2.*q);\n    p=mix(p,p.zwzw,q.x);\n    return mix(p.x,p.y,q.y);\n}\n\n// these three functions are from http://mercury.sexy/\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n    return fOpIntersectionRound(a, -b, r);\n}\n\n\nfloat virusHead (float p){\n    \n    return cos(p);//+ noise(abs(p));\n}\n\nfloat modBlob(inout vec3  p){\n        float sz = 0.;\n    if (p.x < max(p.y, p.z)){ \n        p = p.yzx;\n        //sz+=.007;\n    }\n    if (p.x < max(p.y, p.z)){ \n       // sz-=0.05;\n        p = p.yzx;}\n\n    return sz;\n    \n}\n\nfloat bFunct(vec3 p, vec3 savedP){ // this function places nubs around sphere\n   return  max(max(max(\n        dot(p, normalize(vec3(1., 1, 1))),\n        dot(p.xz, normalize(vec2(PHI+1., 1.)))),\n        dot(p.yx, normalize(vec2(1., PHI )))),\n        dot(p.xz, normalize(vec2(1., PHI ))));\n    \n}\n\nfloat bloby(vec3 p) {\n    p = abs(p);\n    vec3 savedP = p;\n    float sz = 1.3;\n    sz += modBlob(p);\n    float b = bFunct(p,savedP);\n    float l = length(p);\n    \n    float nub =(1.01 - b / l)*(PI / .04) - n(savedP.xy*20.);\n        \n    float sploops = l - sz - 0.06 * cos(min(nub, (PI)));\n    \n    return fOpDifferenceRound (sploops,l-1.38, 0.15); // just ge tthe nubs\n}\n\n\nfloat virus(vec3 p) {\n    vec3 savedP = p;\n    p = abs(p);\nfloat sz = 1.2;\n sz += modBlob(p);\n    float b = bFunct(p,savedP);\n        \n    float l = length(p);\n    return l - sz - 0.3 * (3. / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.15), PI )) +( n(savedP.xy*20.) *0.01)+  n(savedP.zy*17.) *0.03;\n}\n//from http://mercury.sexy/\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat scene(vec3 ray){\n //   ray.x -= (iMouse.x-0.5)/100.;\n    float time = iTime;\n\n    float radius = 0.5;\n    \n    \n   // ray = mod(ray, modSpace) - 0.5*modSpace;\n    \n    ray = ray - vec3(0.,0.,2.0);\n    vec3 ray2 = ray;\n    vec3 ray3 = ray;\n        \n    pR(ray2.yz,time/3. + n((vec2(time*3. ) / 2.)) * 0.2);\n    pR(ray3.yz,time/3.);\n    \n    vec3 ray4 = mix(ray2,ray3,(sin(time)*5.) + 1.);\n    \n    pR(ray4.xz, n(vec2(time/40.) ) );\n    \n    pR(ray4.xy, 0.2*n(vec2(time/20.) ) ); \n    float blob = bloby(ray4);\n    float virus = virus(ray4);\n\n    return smin(blob,virus,.8  + (0.08* sin(time)));//smin(smin(blob, sphere,0.6), sphere2,0.6) ;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    float smallNumber = 0.002;\n    vec3 n = vec3(\n    scene(vec3(p.x + smallNumber, p.yz)) -\n    scene(vec3(p.x - smallNumber, p.yz)),\n    scene(vec3(p.x, p.y + smallNumber, p.z)) -\n    scene(vec3(p.x, p.y - smallNumber, p.z)),\n    scene(vec3(p.xy, p.z + smallNumber)) -\n    scene(vec3(p.xy, p.z - smallNumber))\n);\n\n\treturn normalize(n);\n}\n\nvec3 lighting(vec3 origin, vec3 dir, vec3 normal) {\n    vec3 lightPos1 = vec3(12.,12,1);//vec3(cos(time) +12., sin(time), 12.);\n    vec3 color1 = vec3(1.0,0.5,0.6);\n    vec3 light1 = normalize(lightPos1 - origin);\n    float diffuse1 = max(0., dot(light1, normal));\n    vec3 reflectedRay1 = 2.2 * dot(light1, normal) * normal - light1;\n    float specular1 = max(0., (pow(dot(reflectedRay1, light1),5.))) *0.1;\n\n    vec3 lightPos2 = vec3(-12,-12.*sin(iTime*3.),1);//vec3(cos(time) +12., sin(time), 12.);\n    vec3 color2 = vec3(0.2,0.2,0.7);\n    vec3 light2 = normalize(lightPos2 - origin);\n    float diffuse2 = max(0., dot(light2, normal));\n    vec3 reflectedRay2 = 2.2 * dot(light2, normal) * normal - light2;\n    float specular2 = max(0., (pow(dot(reflectedRay2, light2),5.))) *0.1;\n\n    \n    \n   \n    \n    float ambient = 0.1+  0.05* sin(iTime*20.);\n\tvec3 ambientColor = vec3(0.5,0.6,0.7);\n    vec3 result1 = (diffuse1 + specular1) * color1;\n    vec3 result2 = (diffuse2 + specular2) * color2;\n    \n    vec3 ambientResult = ambient * ambientColor;\n    \n    \n    return (result1+ambientResult + result2);\n\n}\n\n\nvec4 trace(vec3 rayOrigin, vec3 dir){\n    vec3 ray = rayOrigin;\n    float dist = 0.; \n    float totalDist = 0.;\n    float maxDist = 3.;\n    \n    for (int i = 0; i < steps ; i++){\n        dist = scene(ray);\n        \n        if(dist < 00.04){\n            vec4 distCol = vec4(1. - vec4(totalDist/maxDist));\n            vec4 lightingCol = vec4(\n                vec3(lighting(rayOrigin,dir,estimateNormal(ray))\n                     ),1.0);\n            vec4 col = lightingCol;//mix(lightingCol , vec4(distCol),distCol.x);\n           \n            return col;\n        } \n        totalDist += dist;\n        ray += dist * dir;\n        if (totalDist > maxDist){\n            break;\n            \n        }\n    } \n \n\n    return vec4(0.0);\n}\nvec3 lookAt(vec2 uv, vec3 camOrigin, vec3 camTarget){\n\tvec3 zAxis = normalize(camTarget - camOrigin);\n\tvec3 up = vec3(0,1,0);\n\tvec3 xAxis = normalize(cross(up, zAxis));\n\tvec3 yAxis = normalize(cross(zAxis, xAxis));\n\n\tfloat fov = 2.;\n\n\tvec3 dir = (normalize(uv.x * xAxis + uv.y * yAxis + zAxis * fov));\n\n\treturn dir;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = (uv *2.)-1.;\n\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 rayOrigin = vec3(uv.x + n(vec2(time))*0.05,uv.y + n(vec2(time/3.))*0.03, 0.); // TODO make it so that the bg moves more than the foreground so it looks like the fbm is far away\n    vec3 camOrigin = vec3(0, 0., -1.);\n\n    vec3 camTarget = camOrigin+ vec3(sin(time/10.),cos(time*10.)*0.1, 2);\n\n    vec3 direction = lookAt(uv, camOrigin, camTarget);\n\t\n\n    vec3 color = (trace(rayOrigin, direction)).rgb;\n    float n = 4.0;\n    fragColor = vec4(color,1.0);\n    \n     uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.0) -1.0;\n    uv+= ((iMouse.xy/iResolution.xy)-vec2(0.5))/10.;\n    \n    \tuv*=0.995;\n    uv= (uv+1.0)/2.0;\n    uv+= vec2(3./iResolution.x, 0.0);\n     vec3 oldColor = texture(iChannel0, uv).rgb;\n\n    if(length(color)<0.01){\n        fragColor.rgb = oldColor;\n     }\n//fragColor = vec4(color, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}