{"ver":"0.1","info":{"id":"tdlyz4","date":"1584805325","viewed":134,"name":"Interactive Noise","username":"raabix","description":"X-Mouse: Number of octaves\nY-Mouse: Decay of each octave\nWork in progress - I try to build an interactive noise explorer and learn shadertoy","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*  This is a work in progress shader. I want to make exploring noise accessible\n    for everyone and learn at the same time coding in shadertoy.\n    So for the beginning you can experience summed gradient noise and adjust its\n    parameters with the mouse \n    X-Mouse: Number of Octaves\n    Y-Mouse: Roughness (the amount of how much each octave is scaled smaller)\n\n*/\n\n\n#define NORMALIZED_OUTPUT true\n#define UNNORMALIZED_OUTPUT false\n\n\n\n// Code for font rendering\n\n#define AUTO_FONT_SPACING\n#define FONT_SAMPLER iChannel0\n\n// ------------------------------------------------------------------\n// SDF Font Printing by P_Malin - https://www.shadertoy.com/view/ldfcDr#\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au,\n\n\t_LCUB = 0x7Bu,\t\t// '{'\n    _VERBAR = 0x7Cu,\t// '|'\n    _RCUB = 0x7Du,\t\t// '}'\n    _TILDE = 0x7Eu,\t\t// '~'\n    \n        \n    _EOL = 0x1000u, \t// End of Line - Carriage Return & Line Feed    \n    _BOLDON = 0x1001u,\t// Special\n    _BOLDOFF = 0x1002u,\t// Special\n    _ITALON = 0x1003u,\t// Special\n    _ITALOFF = 0x1004u\t// Special\n;\n\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( FONT_SAMPLER, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n#if 0\n    // Simple but not efficient - samples texture for each character\n    // Extends distance field beyond character boundary\n    vSample = textureLod( FONT_SAMPLER, vUV, 0.0 );\n    vSample.gb = vSample.gb * 2.0f - 1.0f;\n    vSample.a -= 0.5f+1.0/256.0;    \n    vSample.w += l * 0.75;\n#else    \n    // Skip texture sample when not in character boundary\n    // Ok unless we have big shadows / outline / font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( FONT_SAMPLER, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n#endif    \n        \n    return vSample;\n}\n\n#ifndef AUTO_FONT_SPACING\nfloat CharExtentsLeft( uint iChar )\n{\n    if ( iChar < 32u )\n        return 0.1f;\n    \n    switch( iChar )\n    {\n        case _EXCL:  case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.4f;\n        case _l: return 0.325f;        \n        case _A: case _Y: case _Q: case _w:case _W: case _m: case _M: return 0.25f;\n    }\n\treturn 0.3f;\n}\n\nfloat CharWidth( uint iChar )\n{\n    if ( iChar < 32u )  \n        return 0.8f;\n   \n    switch( iChar )\n    {\n        case _EXCL: case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.2f;       \n        case _1: case _j: return 0.3f;        \n        case _l: return 0.35f;\n        case _A: case _Y: case _Q: case _w: case _W: case _m: case _M: return 0.5f;\n    }\n\n    return 0.4f;\n}\n#endif \n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n#ifdef AUTO_FONT_SPACING\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n#else\n    result.left = CharExtentsLeft( iChar );\n    result.width = CharWidth( iChar );\n#endif\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vCanvasOrigin;\n \n    // print position\n    vec2 vStart;\n    vec2 vPos;\n    vec2 vPixelSize;\n    bool EOL;\n\n    // result\n    float fDistance;\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vStart = state.vCanvasOrigin - vPos;\n    state.vPos = state.vStart;    \n    state.EOL = false;\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;\n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vCanvasOrigin = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n    bool bItalic;\n    bool bBold; \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(16.0f, 16.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n    style.bItalic = false;\n    style.bBold = false;    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;\n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f; \n    return style;\n}\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vPos.x = state.vStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n    float fFontDescent = 0.15f;\n\tstate.vPos.y -= style.vSize.y * fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n    float fFontAscent = 0.65f;\n\tstate.vPos.y -= style.vSize.y * (fFontAscent + style.fLineGap);\n}\n\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n    \n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n    \n    vec2 vUV = (state.vPos / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;    \n    }\n    \n    state.vPos.x -= style.vSize.x * (extents.width + style.fAdvancement);\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( in PrintState state, in LayoutStyle style, in RenderStyle renderStyle, inout vec3 color )\n{\n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n    vec3 vCol = renderStyle.vFontColor;\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n#define ARRAY_PRINT(STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i<CHAR_ARRAY.length(); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > 0u )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= -decimalPlaces )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place; \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n\n\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UIF (1.0 / float(0xffffffffU))\n\n// Hash by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n \n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return 2.*fract((p3.xx+p3.yz)*p3.zy) - vec2(1.);\n\n}\n\n\n// This is the long written noise function so I finally understand what is happening\n// inside there\nfloat gradnoise(vec2 uv)\n{\n    vec2 p = floor(uv),\n        f = (fract(uv));\n    \n    vec2 u = f*f*f*(6.0*f*f - 15.0*f +10.0);\n    //vec2 u = f*f*(3.-2.*f);\n    float dot1, dot2, dot3, dot4;\n    \n    dot1 = dot((hash22(p)), f);\n    dot2 = dot((hash22(p + vec2(1., 0.))) , f - vec2(1.,0.));\n    dot3 = dot((hash22(p + vec2(0., 1.))) , f - vec2(0.,1.));\n    dot4 = dot((hash22(p + vec2(1., 1.))) , f - vec2(1.,1.));\n    \n    float m1, m2;\n    \n    m1 = mix(dot1, dot2, u.x);\n    m2 = mix(dot3, dot4, u.x);\n    \n    return mix(m1, m2, u.y);\n   // return hash22(p).y;\n}\n\n\n// expects a gradnoise lookup value (-1 ... 1)\n// and remaps it according to the function given\nfloat gradnoise_remap(float gradnoise_lookup)\n{\n    return 0.5;\n}\n\n\nfloat gainf(float x, float k) \n{\n    //remap k, so k is driven by 0...1 range\n    k = k < 0.5 ? 2.*k : 1./(1.-(k-0.5)*2.);\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nfloat oct_gradnoise(vec2 uv, float octaves, float roughness, float octscale, bool equalize)\n{\n    float a = 0.;\n    float oct_intensity = 1.0; // first intensity is 1.0, successive octaves get scaled by roughness value\n    float total_scale = 0.0;\n    float remap;\n    float contrast = 0.0;\n    //mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for(float i = 0.; i < octaves; i++)\n    {\n        float gradnoise_lookup = gradnoise(uv)*1.;\n        \n        // So per octave mapping here\n        // some_func(gradnoise_lookup);\n        total_scale += oct_intensity;\t\t    \n        a += (gradnoise_lookup) * oct_intensity;\n        oct_intensity = oct_intensity * roughness; // get intensity for next(!) octave\n        uv = (uv + vec2(11.37, 11.49)) * octscale;\n    } \n    if(equalize == true)\n        a/=(total_scale);  \n\n    return (a); // if we were dividing just by octaves we'd get an intensity shift\n}\n\nfloat oct_gained_gradnoise(vec2 uv, float octaves, float roughness, float octscale)\n{\n    float a = 0.;\n    float intensity = 1.;\n    float oct_intensity = 1.0; // first intensity is 1.0, successive octaves get scaled by roughness value\n    float total_scale = 0.0;\n    float remap;\n    float contrast = 0.999;\n    float gain = .001;\n    //mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for(float i = 0.; i < octaves; i++)\n    {\n        float gradnoise_lookup = gradnoise(uv)*1.6;\n        \n        remap = gradnoise_lookup;\n        //remap = clamp(remap < 0. ? (- pow(abs(remap), gain)) : pow(remap, gain), -12.0, 12.0);\n        remap = gainf(clamp((gradnoise_lookup*.5 + .5), 0.0, 1.0), gain);\n        remap = ((remap - 0.5) * 2.); \n        \n\t\ttotal_scale += oct_intensity;\n        a += remap* oct_intensity;\n        oct_intensity*= roughness; // get intensity for current octave\n        \n        uv = (uv + vec2(11.37, 11.49)) * octscale;\n        \n    }\n    // applying contrast and clamping it\n\t\n    a = (a/(1.0 -contrast)) ;\n    a= clamp(a/total_scale, -1., 1.0);\n    return a; // if we were dividing just by octaves we'd get an intensity shift\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x += iTime*.1;\n\tvec2 uvMouse = (iMouse.xy/iResolution.xy);\n    \n    int octaves = int(ceil(uvMouse.x * 10.));\n    float roughness = uvMouse.y*1.5;\n    // Dynamic gradnoise\n    \n    // Static gradnoise\n    \n    float octscale = 2.0; //factor by which each octave gets smaller than the previous one\n    bool equalized_out_yes = true;\n    bool equalized_out = true;\n    float final_value;\n    \n    \n    \n    if(fragCoord.x < iResolution.x/2.)\n    {\n        if(uv.y > 0.5)\n        {\n            final_value = oct_gradnoise( uv*2., float(octaves), roughness, octscale, NORMALIZED_OUTPUT);  \n\t\t\t//final_value = final_value/.3;\n            final_value = final_value*0.5 + 0.5;\n        }\n        else\n        {\n            final_value = (oct_gradnoise( uv*2., float(octaves), roughness, octscale, UNNORMALIZED_OUTPUT));\n            //final_value = 1.0 - exp(-final_value);\n            final_value = final_value*0.5 + 0.5;\n        }\n    }\n    else\n    {\n        //oct_gained_gradnoise(vec2 uv, float octaves, float roughness, float octscale)\n        \n        final_value = gradnoise(uv*2.*pow(octscale, float(octaves-1)));  \n        final_value = final_value*0.5 + 0.5;\n    }\n    \n\n    \n    \n    if(mod(fragCoord.x, iResolution.x /2.) < 1.)\n       final_value = 0.;\n\n\n    // Output to screen\n    fragColor = vec4(final_value);\n    \n    // ----------- Font Rendering ----------\n    vec2 vCanvasCoord = vec2( fragCoord.x, iResolution.y - 1.0f - fragCoord.y );    \n    vec2 vCanvasPixelSize = vec2(1.0);\n\n\tbool bScaleWithResolution = false;    \n    \n    if ( bScaleWithResolution )\n    {\n    \tvCanvasCoord = vec2( fragCoord.x, iResolution.y - 1.0f - fragCoord.y ) * vec2(640.0, 360) / iResolution.xy;\n    \tvCanvasPixelSize = vec2(640.0, 360) / iResolution.xy;   \n      //  vec2 dVdx = dFdx(vCanvasCoord);\n      //  vec2 dVdy = dFdy(vCanvasCoord);\n      //  vCanvasPixelSize = vec2( length(vec2(dVdx.x, dVdy.x) ), length(vec2(dVdx.y, dVdy.y) ) );\n    }\n    \n    PrintState state = PrintState_InitCanvas( vCanvasCoord, vCanvasPixelSize );\n    MoveTo(state, vec2(6,10));\n\n    LayoutStyle style = LayoutStyle_Default();\n    style.vSize = vec2(16.0f, 16.0f);\n    style.fLineGap = 0.1;\n    style.fAdvancement = 0.1;\n    //style.bBold = true;\n    \n    \n    // Without this line the print position specifies the baseline\n    // with this line we advance by the ascent and line gap\n    PrintBeginNextLine(state, style);\n    \n    uint str[] = uint[] ( _O, _c, _t, _a, _v, _e, _s, _COLON, _SP);\n    ARRAY_PRINT( state, style, str );\n   \n\tPrint( state, style, octaves);\n    PrintCh( state, style,  _EOL  );\n    \n    uint str2[] = uint[] ( _R, _o, _u, _g, _h, _n, _e, _s, _s, _COLON, _SP);\n    ARRAY_PRINT( state, style, str2 );\n    \n    Print (state, style, roughness, 3);\n    PrintCh( state, style,  _EOL  );\n    \n    MoveTo(state, vec2(iResolution.x/2. + 10.,19));\n    uint str3[] = uint[] ( _C, _u, _r, _r, _e, _n, _t, _SP, _M, _a, _x, _SP, _O, _c, _t, _a, _v, _e,_SP);\n    ARRAY_PRINT( state, style, str3 );\n    \n    uint str4[] = uint[] ( _W, _i, _t, _h, _SP, _N, _o, _r, _m, _a, _l, _i, _z, _a, _t, _i, _o, _n, _SP);\n    uint str5[] = uint[] ( _N, _o, _SP, _N, _o, _r, _m, _a, _l, _i, _z, _a, _t, _i, _o, _n, _SP);\n    \n    MoveTo(state, vec2(6., iResolution.y/2. - 6.));\n    ARRAY_PRINT( state, style, str4 );\n    \n    MoveTo(state, vec2(6., iResolution.y/2. + 14.));\n    ARRAY_PRINT( state, style, str5 );\n //   Print( state, style, int(iDate.x) );\n //   PrintCh( state, style, _MINUS );\n //   Print( state, style, int(iDate.y) + 1 );\n //   PrintCh( state, style, _MINUS );\n //   Print( state, style, int(iDate.z) );\n //   PrintCh( state, style, _COMMA );\n //   PrintCh( state, style, _SP );\n //   Print( state, style, int(mod(iDate.w / (60.0 * 60.0), 24.0)) );\n //   PrintCh( state, style, _COLON );\n //   Print( state, style, int(mod(iDate.w / 60.0, 60.0)) );\n //   PrintCh( state, style, _COMMA );\n //   PrintCh( state, style, _SP );\n //   Print( state, style, iTime, 3 );\n //   PrintEOL( state, style );\n   \n\n    RenderStyle renderStyle = RenderStyle_Default( vec3(0.0) );\n    RenderFont( state, style, renderStyle, fragColor.rgb );\n}","name":"Image","description":"","type":"image"}]}