{"ver":"0.1","info":{"id":"XXtSW2","date":"1719597804","viewed":47,"name":"Reject #1;","username":"gllama","description":"I was trying to SDF the lines of 3d-cartesian space that lie on integer XYZ positions. Totally a failure but there's some interesting madness in here","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["grid","equirectangular","reject"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\n// This function let's us jump from 2D-UV to spherical 3D-XYZ position\nvec3 uvTo3D(vec2 uv) {\n    // The 2-Sphere point via UV => Lat/Long angles\n    float theta = uv.x * 2.0 * 3.14159265359; // Longitude\n    float phi = uv.y * 3.14159265359; // Latitude\n    // Trigonometry from 2-Sphere angles to an XYZ normalized [-1,1].\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    // { Dev Note }\n    // If you're porting this shader to a material, I strongly recommend you skip this function and just use the XYZ of your `varying vNormal` in place of the result you would get here. Should be suitable for all spheres and most round geometries\n    return vec3(x, y, z);\n}\n\nfloat sdfLine(vec3 p) {\n    float radius = .01;\n    float closestXLine = length(vec3(round(p.x),p.yz)-p)-radius;\n    float closestYLine =length(vec3(p.x,round(p.y),p.z)-p)-radius;\n    float closestZLine =length(vec3(p.xy,round(p.z))-p)-radius;\n    return min(closestXLine,min(closestYLine,closestZLine));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor= vec4(0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 pos = uvTo3D(uv); // UV => 3D for equirectangular/spherical mapping\n    pos.x+=iTime;\n    pos.y+=iTime;\n    const float MINIMUM_HIT_DISTANCE = 0.000000001;\n    const int NUMBER_OF_STEPS = 20;\n    float total_distance_traveled = 1.;\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i){\n        vec3 current_position = vec3(0.) + total_distance_traveled * pos;\n        float distance_to_closest = sdfLine(current_position);\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) // hit\n        {\n            fragColor=vec4(vec3(1.),1.);\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n        if(total_distance_traveled>2.){break;}\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}