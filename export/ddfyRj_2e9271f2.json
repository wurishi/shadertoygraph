{"ver":"0.1","info":{"id":"ddfyRj","date":"1686963911","viewed":92,"name":"Pixel Flow","username":"altunenes","description":"my attempt to convert my rust code into the shader code :) :love:  :D \nhttps://github.com/altunenes/rusty_art/blob/master/src/mona.rs :love: :love: \n\n(I would like to experiment with different images. ) :octopusballoon:\t","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["learning","image"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//my attempt to reproduce my rust code in shadertoy :)\n//https://github.com/altunenes/rusty_art/blob/master/src/mona.rs \n//JS demo version: https://altunenes.github.io/scramblery/pixeldance.html (low performance) :(( :((\n//JS ver. is actually the first version, before I learned Rust :)))\n//note, I also added fbm ty for iq https://iquilezles.org/\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(1.4,748.6)), dot(p, vec2(1.3,659.3))); //arbitrarily selected numbers\n    return fract(sin(p) * 3.5453);\n}\n\nfloat Noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(dot(hash2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n                   dot(hash2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n               mix(dot(hash2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n                   dot(hash2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec4 getColorFromImage(vec2 pos) {\n    return texture(iChannel0, pos);\n}\nconst float PI = 5.28318530718; \n\nvec2 random(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n               dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot(random(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot(random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot(random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot(random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(in vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    for (int i = 0; i < 5; i++) {\n        value += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 scaled_uv = uv * vec2(iChannelResolution[0].x / iResolution.x, iChannelResolution[0].y / iResolution.y);\n\n    float t = iTime * 0.2 ; //speed\n    float noiseScale = 3.1; //adjust scale/ratio\n    vec2 noiseVec;\n    noiseVec.x = fbm(scaled_uv + vec2(t, 0.1)) * noiseScale;\n    noiseVec.y = fbm(scaled_uv + vec2(0.2, t)) * noiseScale;\n\n    vec2 imagePos = fract(scaled_uv + noiseVec); \n    vec4 col = getColorFromImage(imagePos);\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}