{"ver":"0.1","info":{"id":"XlKfWy","date":"1543943534","viewed":92,"name":"Myro's first raymarching shader","username":"Myro","description":"My first raymarching shader\nhelped by this tutorial\nhttps://www.youtube.com/watch?v=yxNnRSefK94\n\nand these raymarching primitives distance functions \nhttps://www.shadertoy.com/view/Xds3zN","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// first raymarching thing\n// https://www.youtube.com/watch?v=yxNnRSefK94\n\n// raymarching primitives distance functions\n// https://www.shadertoy.com/view/Xds3zN\n    \n\n// distance function for a box\n// input p : - the current path being traced\n// input b : - box vector (width/2, heigth/2, depth/2)\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// distance function for a sphere\n// input p : - the current path being traced\n// input s : - sphere radius\nfloat sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n// MAPPING FUNCTION ... raymarching stuff having to do with path tracing\nfloat map (vec3 path) {\n    \n    // makes an infinite repeating pattern\n    path = fract(path) *2.0 -1.0; \n    path.xy *= mat2(cos(0.5*path.z), -sin(.5*path.z), sin(.5*path.z), cos(.5*path.z));\n\t\t\n    // boolean operation : taking a box and extruding a sphere \n\treturn max(box(path,vec3(0.6)),-sphere(path,0.8));\n}\n\n\n// TRACING A PATH : measuring the distance to the nearest object\nfloat trace  (vec3 origin, vec3 ray) {\n\t\n    //t is the point at which we are in the measuring of the distance\n    float t =0.0;\n    \n    for (int i=0; i<32; i++) {\n    \tvec3 path = origin + ray * t;\t\n    \tfloat dist = map(path);\n    \t// we want t to be as large as possible at each step but not too big to induce artifacts\n        t += 0.5 * dist;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t// Pixel coordinates from -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Adjusting aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //ray direction (the view plane is at z=1)\n    vec3 ray = normalize(vec3 (uv,1.0));\n\n    //ROTATING THE CAMERA (rotating the ray)\n    float rotTime = iTime/3.0;\n    //rotation matrix around the y axis\n    ray.xz *= mat2(cos(rotTime), -sin(rotTime), sin(rotTime), cos(rotTime));\n    \n    //camera position (rays origin)\n    vec3 origin = vec3 (0.0,0.0,-3); \n    origin = vec3 (0.0,iTime,iTime);           \n    \n    //tracing the ray (getting the distance of the closest object in the ray direction)\n\tfloat depth = trace(origin,ray);\n\t\n    //rendering with a fog calculation (further is darker)\n\tfloat fog = 1.0 / (1.0 + depth * depth * 0.1);\n\t\n    //frag color\n    vec3 fc = vec3(fog);\n    \n    // rainbow colors fun\n\tfc.x *= 1.0+sin(1.5*iTime);\n    fc.y *= 1.0-sin(1.5*iTime+5.0);\n    \n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}