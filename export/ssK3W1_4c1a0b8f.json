{"ver":"0.1","info":{"id":"ssK3W1","date":"1631516058","viewed":64,"name":"RotatingArrow","username":"samikganguly","description":"2D rotating arrow","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415926535897932384626433832795f;\n\nfloat make_arrow(\n    in vec2 uv, \n    in float tailW, in float tailL, \n    in float headW, in float headL, \n    in float bottom, in float left\n) {\n    if(uv.y > bottom && uv.y < bottom + tailL) {\n        float hTOff = (headW - tailW) / 2.f;\n        return float(uv.x > left + hTOff && uv.x < left + tailW + hTOff);\n    } else if(uv.y >= bottom + tailL && uv.y < bottom + tailL + headL) {\n        float slope = headL / headW * 2.f;\n        if(uv.x > left && uv.x < left + headW / 2.f) {\n            return float(slope * (uv.x - left) > uv.y - bottom - tailL);\n        } else if(uv.x >= left + headW / 2.f && uv.x < left + headW) {\n            return float(slope * (uv.x - left - headW / 2.f) < bottom + tailL + headL - uv.y);\n        }\n    }\n    return 0.f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    float angle = pi / 6.f * iTime; //varying angle with time, 1 degree = pi/180 radian\n    uv -= 0.5f; // move arrow to centre\n    uv = vec2(uv.x * aspect * cos(angle) - uv.y * sin(angle), uv.x * aspect * sin(angle) + uv.y * cos(angle)); //rotate\n    float mask = make_arrow(uv, 0.01f, 0.4f, 0.05f, 0.1f, 0.f, 0.f); // generate arrow at origin\n    vec3 bgcol = vec3(0);\n    vec3 fgcol = vec3(0.75);\n\n    // Output to screen\n    fragColor = vec4(mask * fgcol + bgcol,1.0);\n}","name":"Image","description":"","type":"image"}]}