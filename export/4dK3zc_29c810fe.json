{"ver":"0.1","info":{"id":"4dK3zc","date":"1456340046","viewed":13823,"name":"Wall and chimney","username":"TambakoJaguar","description":"Tried to simulate smoke, under windy weather. I took iq's formulas as base. I also created some refraction from the high temperature air coming out of the chimney. It was also nice to create a blurry reflection for the chimney and rather realistic bricks.","likes":55,"published":1,"flags":0,"usePreview":1,"tags":["noise","clouds","grass","bump","smoke","diffuse","tube","bricks","steam","metallic","pipe","chimney","wallturbulence","smooothreflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Wall and chimney\" by Emmanuel Keller aka Tambako - February 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\n// Switches, you can play with them!\n#define brick_bump\n#define specular\n#define shadow\n#define ambocc\n#define reflections\n#define procedural_clouds\n#define show_chimney\n#define show_smoke\n#define heat_refraction\n#define smoke_turbulence\n    \nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \nfloat aaindex;\n\n// Every object of the scene has its ID\n#define SKY_OBJ        0\n#define WALL_OBJ       1\n#define BRICKS_OBJ     2\n#define CHIMNEY_OBJ    3\n\nfloat currTime;\nconst float timeFactor = 1.;\n\n// Scene objects sizes and description\nconst vec3 wallPos = vec3(30, -20, -11.3);\nconst vec3 wallSize = vec3(20, 46, 50);\nconst vec3 brickSize = vec3(0.2, 0.34, 2.04);\nconst vec3 brickStep = vec3(0., 0.44, 2.29);\nconst float brickBR = 0.05;\n\nconst float tubeDiam = 1.8;\nconst float tubeLen1 = 2.1;\nconst float tubeclen = 1.6;\nconst float tubeLen2 = 1.5;\nconst float tubeDiam2 = 2.6;\nconst float tubeLen3 = 0.9;\nconst vec3 chimneyOrig = vec3(-1.3, wallPos.x - wallSize.x - tubeLen1 + 0.2, -17.5);\n\n// Camera options\nvec3 campos;\nvec3 camtarget = vec3(7., 3., -18);\nvec3 camdir;\nfloat fov = 4.5;\n\n// Lighing options\nconst vec3 ambientColor = vec3(0.1, 0.5, 1.);\nconst float ambientint = 0.21;\nDirLamp sunLamp = DirLamp(vec3(-3., 1.2, 1.7), vec3(1., 0.98, 0.94), 1.5);\n\n// Shading options\nfloat specint[4];\nfloat specshin[4];\nconst float aoint = 0.9;\nconst float aoMaxdist = 50.;\nconst float aoFalloff = 0.2;\nconst float shi = 0.55;\nconst float shf = 0.05;\n    \n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 400.;\nconst float nbrref = 12.;      // This controls the number of diffuse reflections. You can set it higher if you want the chimney appear softer, but the FPS will drop\nconst float rrefblur = 0.8;\n\n// Smoke options\nconst float smokeBrightness = 4.0;\nconst vec3 smokeCol = vec3(0.7, 0.75, 0.8)*smokeBrightness;\nconst float smokeColPresence = 0.4;\nconst float smokeColBias = 0.7;\nconst float smokeScale = 2.;\nconst float smokeSpeed = 5.7;\nconst float smokeDens = 5.5;\nconst float smokeBias = -0.01;\nconst float smokePow = 1.9;\nconst float smokeRefInt = 0.0003;\nconst float smokeTurbulence = 0.05;\nconst float smokeTurbulenceScale = 2.5;\n\n// Wind options\nconst float maxWindIntensity = 1.8;\nconst float maxWindAngle = 0.27;\nfloat windIntensity;\nfloat dWindIntensity;\nfloat windAngle;\n\n// Cloud options\nconst vec3 cloudSize = vec3(0.07, 0.2, 0.07);\nconst vec3 cloudSpeed = 0.001*vec3(1., 0.3, 1.2);\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.65;\nconst int aasamples = 1;\n\n// 1D hash function\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\n// 3D hash function\nvec3 hash3( vec3 n ){\n\treturn fract(vec3(sin(n.x)*3538.5453, sin(n.y)*2753.8256, sin(n.z)*5296.3728));\n}\n\n// 2D Vector rotation\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\n#ifdef procedural_clouds\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0 - 2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0),f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0),f.x),f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0),f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise2(vec3 pos)\n{\n    vec3 q = 8.0*pos;\n    float f  = 0.5000*noise(q) ; q = m*q*2.01;\n    f+= 0.2500*noise(q); q = m*q*2.02;\n    f+= 0.1250*noise(q); q = m*q*2.03;\n    f+= 0.0625*noise(q); q = m*q*2.01;\n    return f;\n}\n#endif\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Difference operation from iq\nfloat opS(float d1, float d2)\n{\n    return max(-d2,d1);\n}\n\n// From https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0 );\n    return mix(b, a, h) - k*h*(1.0 - h);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)),0.0) + length(max(d, 0.0));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p) - b,0.0)) - r;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y), 0.0) + length(max(d, 0.0));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdTorus(vec3 p, vec2 t)\n{\n    return length(vec2(length(p.xz) - t.x,p.y)) - t.y;\n}\nfloat sdTorusQ(vec3 p, vec2 t)\n{\n    return max(max(length(vec2(length(p.xz) - t.x,p.y)) - t.y, p.x), p.z);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdConeSection(in vec3 p, in float h, in float r1, in float r2)\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1 - r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0 - si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2), 0.0)) + min(max(d1,d2), 0.);\n}\n\n// Distance mapping of the bricks\nvec2 map_bricks(vec3 pos)\n{\n    vec3 pos2 = pos;\n    pos2.yz+= 0.07*texture(iChannel1, pos.yz*0.005).g;\n    pos2.z+= 0.5*(brickStep.z + 0.02)*mod(floor(0.5*pos2.y/brickStep.y), 2.);\n\n    vec2 nb = floor(pos2.yz/brickStep.yz*vec2(0.5, 1.));\n    float nbBrick = nb.x*2. + nb.y*80.;\n    float btd = 1. + 0.3*(hash(nbBrick) - 0.5);\n    \n    pos2.yz = mod(pos2.yz, brickStep.yz*vec2(2., 1.));\n    float bricks = udRoundBox(pos2 - vec3(wallPos.x - wallSize.x + brickSize.x*0.5*btd, brickStep.y, 0.), brickSize, brickBR);\n    \n    #ifdef brick_bump\n    bricks+= 0.01*smoothstep(0.1, 0.95, texture(iChannel3, pos.yz*0.18).r + 0.6*texture(iChannel0, 0.2*pos.yz).r)*smoothstep(-0.2, -0.23, pos.x - wallPos.x + wallSize.x - brickSize.x*0.5*btd);\n    #endif\n    \n    #ifdef show_chimney\n    bricks = max(bricks, -sdCylinder(pos.yxz-chimneyOrig, vec2(tubeDiam/2. + 0.1, 2.)));\n    #endif\n    \n    return vec2(bricks, BRICKS_OBJ);\n}\n\n#ifdef show_chimney\n// Distance mapping of the inside (hole of the chimney)\nfloat getTubeInt(vec3 pos)\n{ \n    return sdCylinder(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2 - 3., 0), vec2(tubeDiam/2.3, tubeLen2*2.));\n}\n\n// Distance mapping of the metallic chimney\nvec2 map_chimney(vec3 pos)\n{\n    const float cw = 0.16;\n    const float ch = 0.02;\n    \n    pos = pos.yxz;\n    pos-= chimneyOrig;\n    \n    // Horizontal tube\n    float chimney = sdCylinder(pos, vec2(tubeDiam/2., tubeLen1));\n    // Bands around the tube\n    float angle1 = atan(pos.x, pos.z) + 3.*pos.y - 0.07;\n    float angle2 = atan(pos.y + tubeLen1 + tubeclen, pos.z) - 3.*pos.x + 1.07;\n    chimney-= ch*smoothstep(cw, 0., abs(0.2 - mod(angle1, pi)));\n    \n    // Curved tube\n    float rtube = sdTorusQ(pos.yzx + vec3(tubeLen1, 0., -tubeclen), vec2(tubeclen, tubeDiam/2.));\n    vec3 pos2 = pos.yzx + vec3(tubeLen1, 0., -tubeclen);\n    // Bands around the tube\n    float angle3 = atan(pos2.x - 0.025, pos2.z);\n    float angle4 = atan(pos.x*cos(angle3*0.65 - 1.15) + (pos.y + 2.7)*sin(angle3*0.65 - 1.), pos.z) + 4.3*angle3 - 1.72;\n    rtube-= ch*smoothstep(cw, 0., abs(0.2 - mod(angle4, pi)));\n    \n    chimney = min(chimney, rtube);\n    \n    // Vertical tube\n    float tube2 = sdCylinder(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2, 0), vec2(tubeDiam/2., tubeLen2));\n    // Bands around the tube\n    tube2-= ch*smoothstep(cw, 0., abs(0.2 - mod(angle2, pi)));\n    chimney = min(chimney, tube2);\n \n    // Broad conic top of the chimney\n    float cone1 = sdConeSection(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2 - tubeLen3, 0), tubeLen3/2., tubeDiam/2.6, tubeDiam2/2.23);\n    float cone2 = sdConeSection(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2 - tubeLen3*2. - 0.08, 0), tubeLen3/2., tubeDiam2/2.23, tubeDiam/2.56);\n    float cone = smin(cone1, cone2, 0.2);\n    chimney = smin(chimney, cone, 0.1);\n    \n    // Small \"collar\" at the base of the broad part \n    float collar1 = sdCylinder(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2 - 0.6, 0), vec2(tubeDiam/1.85, 0.065));\n    chimney = smin(chimney, collar1, 0.15);\n    \n    // Small rounding at the middle of the broad part  \n    float rborder = sdTorus(pos.yxz + vec3(tubeLen1 + tubeclen, -tubeclen - tubeLen2 - tubeLen3 - 0.5, 0.), vec2(tubeDiam2/1.8, 0.01));\n    chimney = smin(chimney, rborder, 0.2);\n    \n    // Inside of the chimney (hole of the chimney)\n    float tubeInt = getTubeInt(pos);\n    chimney = max(chimney, -tubeInt);\n    \n    return vec2(chimney, CHIMNEY_OBJ);\n}\n#endif\n\n// Main distance mapping function\nvec2 map(vec3 pos)\n{\n    vec2 wall = vec2(sdBox(pos - wallPos, wallSize), WALL_OBJ);\n    float wallBound = sdBox(pos - wallPos, wallSize*1.04);\n    vec2 bricks = max(map_bricks(pos), wallBound);\n    #ifdef show_chimney\n    vec2 chimney = map_chimney(pos);\n    return opU(opU(wall, bricks), chimney);\n    #else\n    return opU(wall, bricks);\n    #endif\n}\n\n// Simple mapping function of the wall\n#ifdef show_chimney\nvec2 map_s(vec3 pos)\n{\n    vec2 wall = vec2(sdBox(pos-wallPos, wallSize), BRICKS_OBJ);\n    \n    return wall;\n}\n\n// Mapping of the inside of the hole (for smoke mapping)                            \nfloat map_int(vec3 pos)\n{\n    pos = pos.yxz;\n    pos-= chimneyOrig;\n    \n    return getTubeInt(pos);\n}\n#endif\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 90; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = map(pos).x;\n        if (dist>maxdist || abs(dist)<0.0004)\n            break;\n        t+= dist*1.;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// Gets the position of the wall\n#ifdef show_chimney\nvec2 trace_s(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = max((-cam.x - wallPos.x + wallSize.x)/ray.x, maxdist);\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n  \n    pos = ray*t + cam;\n    vec2 res = map_s(pos);\n    dist = res.x;\n    t+= dist;\n    objnr = abs(res.y);\n\n  \treturn vec2(t, objnr);\n}\n#endif\n\n// From https://www.shadertoy.com/view/MstGDM\n// Normal mapping function\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                          map(pos + q.xyx).x - map(pos - q.xyx).x,\n                          map(pos + q.xxy).x - map(pos - q.xxy).x));\n}\n\n// Normal mapping function, simplified version\n#ifdef show_chimney\nvec3 getNormal_s(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map_s(pos + q.yxx).x - map_s(pos - q.yxx).x,\n                          map_s(pos + q.xyx).x - map_s(pos - q.xyx).x,\n                          map_s(pos + q.xxy).x - map_s(pos - q.xxy).x));\n}\n#endif\n\n// Gets the flares of the lamps (kind of non-reflective specular)\nvec3 getFlares(vec3 ray)\n{\n\tvec3 rc = vec3(0.);\n    rc+= 0.4*clamp(normalize(sunLamp.color)*sunLamp.intensity*pow(max(0.0, dot(ray, normalize(sunLamp.direction))), 300.), 0., 1.);\n\n    return rc;\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{\n    float elev = atan(ray.y);\n    float azimuth = atan(ray.x, ray.z);\n \n    vec3 sky = ambientColor + vec3(0.4, 0.22, 0.05)*2.5*(0.65 - elev);\n    \n    // Clouds\n    #ifdef procedural_clouds\n    float cloudst = smoothstep(-0.2, 0.5, elev)*smoothstep(0.1, 0.97, noise2(11.*cloudSize*ray + vec3(cloudSpeed*currTime)));\n    #else\n    float cloudst = smoothstep(-0.2, 0.5, elev)*texture(iChannel1, cloudsize*ray.xy).r;\n    #endif\n    sky = mix(sky, 0.45 + 0.6*vec3(cloudst), smoothstep(0.12, 0.5, cloudst)) + 0.3*vec3(smoothstep(0.2, 0.8, cloudst));\n    \n    // Ground\n    vec3 grass = vec3(0.05, 0.45, 0.3) + vec3(0.19, 0.13, -0.03)*2.7*(0.65 - elev);\n    grass = grass*(0.6 + 2.*abs(elev)*texture(iChannel0, 12.*ray.xy).r);\n    \n    return mix(mix(grass, vec3(0.65)*(0.7 + 0.3*texture(iChannel0, 12.*ray.xy).r), smoothstep(-0.17 - 0.035*abs(azimuth), -0.172 - 0.035*abs(azimuth), elev)), sky, smoothstep(-0.0003, 0.0003, elev)) + getFlares(ray); \n}\n\n// Gets the simplified version of the color of the sky\nvec3 sky_color_s(vec3 ray)\n{\n    float elev = atan(ray.y);\n \n    const float cloudsize = 0.25;\n    vec3 sky = ambientColor + vec3(0.4, 0.22, 0.05)*2.5*(1. - elev);\n    \n    vec3 grass = vec3(0.0, 0.35, 0.25) + vec3(0.22, 0.16, -0.03)*2.8*(0.65 - elev);\n    \n    return mix(mix(grass, vec3(0.65), smoothstep(-0.31, -0.312, elev)), sky, smoothstep(-0.0003, 0.0003, elev)); \n}\n\n// Get the color of the cement parts between the bricks\nvec3 getWallColor(vec3 pos)\n{\n    return vec3(0.3 + 0.7*texture(iChannel0, 0.9*pos.yz).r)*(0.5 + 0.5*smoothstep(0., 0.12, texture(iChannel3, 0.3*pos.yz).r));\n}\n\n// Get the color of the metallic chimney\nvec3 getChimneyColor(vec3 pos, vec3 norm)\n{\n    vec3 chcol = vec3(1.25) - 0.7*texture(iChannel2, 0.0007*(5.*pos.xy + cross(norm, pos).yz + cross(pos, norm).zx)).x;\n    \n    return chcol;\n}\n\n// Get the color of the bricks\nvec3 getBrickColor(vec3 pos)\n{\n    vec3 brickCol1 = vec3(0.60, 0.27, 0.15);\n    vec3 brickCol2 = vec3(0.45, 0.24, 0.13);\n    vec3 brickCol3 = vec3(0.29, 0.10, 0.04);\n    \n    vec3 pos2 = pos;\n    pos2.yz+= 0.07*texture(iChannel1, pos.yz*0.005).g;\n    pos2.z+= 0.5*brickStep.z*floor(0.5*pos2.y/brickStep.y);\n    vec2 nb = floor(pos2.yz/brickStep.yz*vec2(0.5, 1.));\n    float nbBrick = nb.x + nb.y*90.;\n    float nbBrickf = pow(hash(nbBrick), 6.);\n    vec3 brickCol = mix(brickCol1, brickCol2, nbBrickf);\n    brickCol = mix(brickCol, brickCol3, pow(smoothstep(0.1, 1.05, 1.2*texture(iChannel2, pos.yz*0.18).x*texture(iChannel2, pos.yz*0.23).x), 1.5));\n    brickCol*= 0.4 + 0.6*smoothstep(0.80, 0.60, texture(iChannel1, pos.yz*0.07).b);\n    return brickCol;\n}\n\nvec3 getBrickColor_s(vec3 pos)\n{\n    return vec3(0.9, 0.3, 0.05);\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr)\n{\n   vec3 col = objnr==WALL_OBJ?getWallColor(pos):(\n              objnr==BRICKS_OBJ?getBrickColor(pos):(\n              objnr==CHIMNEY_OBJ?getChimneyColor(pos, norm):sky_color(pos)));\n\n   return col;\n}\n\n// Get the simplified color of the wall (basic brick color)\nvec3 getColor_s(vec3 norm, vec3 pos, int objnr)\n{\n   vec3 col = getBrickColor_s(pos);\n   return col;\n}\n\n////////////////////////////////////////////////////////\n// Smoke functions from www.shadertoy.com/view/XsX3RB //\n////////////////////////////////////////////////////////\n\n#ifdef show_smoke\nvec3 rayRef;\n// Mapping of the smoke\nvec4 mapSmoke(in vec3 pos)\n{\n    vec3 pos2 = pos;\n    pos2-= chimneyOrig + vec3(5.65, -0.8, 0.);\n    \n    // Calculating the smoke domain (3D space giving the probability to have smoke inside\n    float sw = max(tubeDiam*0.84 + 0.25*pos2.y*(1. + max(0.15*pos2.y, 0.)) + 0.2*windIntensity*(pos.y + chimneyOrig.x - tubeclen - tubeLen2 + 0.3), 0.);\n    float smokeDomain = smoothstep(1.2 + sw/4.3, 0.7 - sw*0.5, length(pos2.xz)/sw);\n    \n    float d;\n    vec4 res;\n    if (smokeDomain>0.1)\n    {           \n    \t// Space modification in function of the time and wind\n        vec3 q = pos2*vec3(1., 1. + 0.5*windIntensity, 1.) + vec3(0.0,-currTime*smokeSpeed + 10.,0.0);\n    \tq/= smokeScale;\n        q.y+= 8.*dWindIntensity + 1.5/(0.7 + dWindIntensity);\n        \n        // Turbulence of the smoke\n        #ifdef smoke_turbulence\n        if (smokeTurbulence>0.)\n        {\n        \tfloat n = smoothstep(4., 0., pos2.y + 3.2)*smokeTurbulence*noise(q*smokeTurbulenceScale)/(currTime + 3.);\n        \tq.xy = rotateVec(-q.xy, pos.z*n);\n        \tq.yz = rotateVec(-q.yz, pos.x*n);\n        \tq.zx = rotateVec(-q.zx, pos.y*n);\n        }\n        #endif\n        \n        // Calculation of the noise\n        d = clamp(0.6000*noise(q), 0.4, 1.); q = q*2.02;  \n        d+= 0.2500*noise(q); q = q*2.03;\n        d+= 0.1200*noise(q); q = q*2.08;\n        d+= 0.0500*noise(q);\n        \n        #ifdef heat_refraction\n        // Calculation of the refraction due to the temperature difference in the air\n        float rrf = smokeDomain*(1. - clamp((pos2.y + 2.8)*0.55, 0., 1.))*smoothstep(0., .3, pos2.y + 3.2);\n        rayRef.x+= (smokeRefInt*noise(q*3.27 + q*4.12) - 0.5*smokeRefInt)*rrf;\n        rayRef.y+= (smokeRefInt*noise(q*3.37 - q*3.96) - 0.5*smokeRefInt)*rrf;\n        rayRef.z+= (smokeRefInt*noise(q*3.11 + q*3.82) - 0.5*smokeRefInt)*rrf;\n        #endif\n\n        d = d - 0.3 - smokeBias - 0.04*pos.y + 0.05*(1. + windIntensity);\n        d = clamp(d, 0.0, 1.0);\n        \n \t\tres = vec4(pow(d*smokeDomain, smokePow));\n\n    \t// Some modifications of color and alpha\n\t\tres.xyz = mix(smokeCol, 0.2*vec3(0.4, 0.4, 0.4), res.x);\n\t\tres.xyz*= 0.2 + 0.2*smoothstep(-2.0, 1.0, pos.y);\n    \tres.w*= max(smokeDens - 1.8*sqrt(pos.y - 4.), 0.);\n    }\n    else\n    {\n        d = 0.;\n        res = vec4(0.);\n    }\n\t\n\treturn res;\n}\n\n// Raymarching of the smoke\nvec4 raymarchSmoke(in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, bool isShadow)\n{\n\tvec4 sum = vec4(0.0);\n    vec2 windDir = rotateVec(vec2(1., 0.), windAngle);\n\n\tfloat t = isShadow?5.4:abs(0.95*(campos.z - chimneyOrig.z)/rd.z);\n\tfor(int i=0; i<32; i++)\n\t{\n\t\tif(t>tmax || sum.w>1.) break;\n\t\tvec3 pos = ro + t*rd;\n        \n        // Influence of the wind\n        pos.xz+= windDir*windIntensity*(pos.y + chimneyOrig.x - tubeclen - tubeLen2 + 0.3);\n\n\t\tvec4 col = mapSmoke(pos);\n\t\t\n        if (col != vec4(0.))\n        {\n        \t// Color modifications of the smoke\n        \tcol.rgb+= (1. - smokeColPresence)*(1.0 - col.w);\n\t\t\tcol.rgb = mix(col.rgb, bcol, smoothstep(smokeColBias, 0.0, col.w));\n\t\t\tcol.rgb*= col.a;\n\n\t\t\tsum = sum + col*(1.0 - sum.a);\n        }\n\t\tt+= 0.07*(1. + windIntensity)*max(0.1,0.05*t);\n\t}\n\tsum.rgb/= (0.001 + sum.a);\n\treturn clamp(sum, 0.0, 1.0);\n}\n#endif\n\n////////////////////////////////////////////////////////////////\n\nvec4 smokeRes;\n// From https://www.shadertoy.com/view/Xds3zN, but I changed the code\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<12; i++)\n    {\n    \tfloat h = map(ro + rd*t).x;\n        res = min(res, 10.0*h/t + 0.02*float(i));\n        t+= 1.5*clamp(h, 0.01, 0.5);\n        if(h<0.001 || t>tmax) break;\n    }\n    #ifdef show_smoke\n    vec4 rsr = raymarchSmoke(ro, rd, vec3(1.), 6., true);\n    return clamp(min(res, 1. - rsr.a*0.9), 0.0, 1.0);\n    #else\n    return clamp(res, 0.0, 1.0);\n    #endif\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<5; i++)\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos).x;\n        occ+= -(dd - hr)*sca;\n        sca*= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1 - n2)/(n1 + n2), (n1 - n2)/(n1 + n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return r;\n}\n\n// Shading of the objects\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, bool simple)\n{\n\tvec3 pl = normalize(lamp.direction);\n      \n    // Diffuse shading\n    vec3 col;\n    if (objnr==CHIMNEY_OBJ)\n        col = ocol*lamp.color*lamp.intensity*(0.1 + 0.75*pow(clamp(dot(norm, pl), 0., 0.93), 1.8));\n    else\n        col = ocol*lamp.color*lamp.intensity*clamp(dot(norm, pl), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    float specint2 = objnr==CHIMNEY_OBJ?specint[CHIMNEY_OBJ]:specint[BRICKS_OBJ];\n    float specshin2 = objnr==CHIMNEY_OBJ?specshin[CHIMNEY_OBJ]:specshin[BRICKS_OBJ];\n    if (dot(norm, lamp.direction) > 0.)\n        col+= lamp.color*lamp.intensity*specint2*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin2);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    if (!simple)\n        col*= shi*softshadow(pos, pl, shf, 7.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.52, 0.65);\n   else\n      iMouse2 = iMouse.xy;\n   \n   campos = vec3(19.*(1. - iMouse2.x/iResolution.x - 0.5),\n                 18.*(iMouse2.y/iResolution.y - 0.35),\n                 10.);\n   /*campos = camtarget + vec3(-20.*cos(3. + 6.*iMouse2.x/iResolution.x),\n                 20.*cos(3.*iMouse2.y/iResolution.y),\n                 20.*sin(3. + 6.*iMouse2.x/iResolution.x)*sin(3.*iMouse2.y/iResolution.y)); */\n    \n   camdir = camtarget-campos;   \n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0., 1., 0.), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x*vRight + vWindow.y*vUp + vForward*fov);\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool simple)\n{\n    #ifdef show_chimney\n    vec2 tr = simple?trace_s(tpos, ray, maxdist):trace(tpos, ray, maxdist);\n    #else\n    vec2 tr = trace(tpos, ray, maxdist);\n    #endif\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist)\n    {\n        #ifdef show_chimney\n        norm = simple?getNormal_s(pos, normdelta):getNormal(pos, normdelta);\n        col = simple?getColor_s(norm, pos, objnr):getColor(norm, pos, objnr);\n        #else\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr);        \n        #endif\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        float aofact;\n        if (!simple)\n           aofact = 1. - aoint + aoint*calcAO(pos, norm);\n        else\n           aofact = 1.;\n        #else\n        float aofact = 1.;\n        #endif\n        \n        // Shading\n        col = ambientColor*ambientint*aofact + lampShading(sunLamp, norm, pos, col, objnr, simple)*(0.6 + 0.4*aofact);\n    }\n    else\n    {\n        // Shows the color of the sky\n        objnr = SKY_OBJ;\n        col = simple?sky_color_s(ray):sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Function to get the intensity of the wind as a function \nfloat getWindIntensity(float t)\n{\n    return maxWindIntensity*smoothstep(-0.3, 2.2, sin(t*0.153 + 18.) + 0.63*sin(t*0.716 - 7.3) + 0.26*sin(t*1.184 + 87.));\n}\n// Function to get the angle of the wind as a function \nfloat getWindAngle(float t)\n{\n    return maxWindAngle*pi*(sin(t*0.0117) + 0.67*sin(t*0.0672 + 5.6) + 0.26*sin(t*0.1943 - 18.7));\n}\n\n// Main render function with diffuse reflections on the chimney\nvec3 ray;\nint robjnr;\nbool isIns;\nvec3 render(vec2 fragCoord, bool calcSmoke)\n{   \n    // The specular is different between the bricks and chimney\n    specint[BRICKS_OBJ] = 0.15;\n    specshin[BRICKS_OBJ] = 0.8;\n    specint[CHIMNEY_OBJ] = 0.95;\n    specshin[CHIMNEY_OBJ] = 15.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; \n    uv = uv*2.0 - 1.0;\n    uv.x*= iResolution.x / iResolution.y;\n\n    ray = GetCameraRayDir(uv, camdir, fov);\n\n    // Modification of the ray because of the air refraction due to the heat\n    #ifdef show_smoke\n    rayRef = vec3(0.);\n    smokeRes = raymarchSmoke(campos, ray, vec3(1.), 40., false);\n    #ifdef heat_refraction\n    ray+= rayRef;\n    #endif\n    #endif\n    \n    RenderData traceinf = trace0(campos, ray, maxdist, false);\n    vec3 pos = traceinf.pos;\n    vec3 col = traceinf.col;\n    robjnr = traceinf.objnr;\n    \n    #ifdef reflections\n    vec3 refray = reflect(ray, traceinf.norm);\n    if (robjnr==CHIMNEY_OBJ)\n    {   \n        vec3 cols = vec3(0.);\n        for (float r=0.; r<nbrref ;r++)\n        {\n           vec3 randpart = hash3(vec3(1.)*(1.74 + r*21.12 + aaindex) + 80.*traceinf.pos);\n           vec3 refray2 = refray + rrefblur*(randpart - vec3(0.5));\n           RenderData traceinf_ref = trace0(traceinf.pos, refray2, 20., true);\n           cols+= traceinf_ref.col;   \n        }\n        float r = clamp(fresnel(ray, traceinf.norm, 2.9), 0., 0.45);\n        col = mix(col, cols/nbrref, r);\n    }\n    #endif\n    \n    // Sets a variable if the smoke is inside the chimney\n    #ifdef show_smoke\n    isIns = map_int(pos)<0.04;\n    #endif\n    \n    return col;\n}\n\n// Main tracing function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    currTime = iTime*timeFactor;\n    setCamera();\n    windIntensity = getWindIntensity(currTime*0.8);\n    dWindIntensity = windIntensity - getWindIntensity(currTime*0.8 - 0.2);\n    windAngle = getWindAngle(currTime);\n    \n    // Antialiasing loop\n    vec3 vs = vec3(0.);\n    for (int j=0; j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0; i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy), i + j==0);\n          aaindex = 1.23*float(i) + 18.79*float(j);\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vs/vec3(aasamples*aasamples);\n    \n    // Adds the smoke to the image\n    #ifdef show_smoke\n    if (robjnr!=CHIMNEY_OBJ || isIns)\n        col = mix(col, smokeRes.xyz, smokeRes.w)*(1. + 0.06*smokeRes.w);\n    #endif\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}