{"ver":"0.1","info":{"id":"wsSSDz","date":"1553418830","viewed":150,"name":"CSG: blue lattice - point light","username":"takumifukasawa","description":"csg: blue lattice - pointlight","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EPS 0.0001\n#define PI 3.14159265359\n\nprecision mediump float;\n\nconst int maxIterations = 64;\nconst float stepScale = 1.;\nconst float stopThreshold = .005;\n\nfloat sphere(vec3 p, float size) {\n  return length(p) - size;\n}\n\nfloat tube2(vec2 p, float size) {\n  return length(p) - size;\n}\n\nfloat box2(vec2 p, float size) {\n  return length(max(abs(p) - size, 0.));\n}\n\nfloat cylindar(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat displacement(vec3 p, vec3 power) {\n  return sin(power.x * p.x) * sin(power.y * p.y) * sin(power.z * p.z);\n}\n\nvec3 repeat(vec3 p, float c) {\n  return mod(p, c) - c * .5;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat scene(vec3 p) {\n  vec3 _pb = repeat(p, 4.);\n  float b1 = box2(_pb.xy, .3);\n  float b2 = box2(_pb.yz, .3);\n  float b3 = box2(_pb.xz, .3);\n\n  vec3 _pt = repeat(p, .2);\n  float t1 = tube2(_pt.xy, .02);\n  float t2 = tube2(_pt.yz, .02);\n  float t3 = tube2(_pt.xz, .02);\n\n  float c = 0.;\n  c = smin(b1, b2, 3.);\n  c = smin(c, b3, 3.);\n\n  return c;\n}\n\nvec3 getNormal(vec3 p) {\n  const float e = EPS;\n  return normalize(vec3(\n    scene(p + vec3(e,   0.0, 0.0)) - scene(p + vec3(-e,  0.0, 0.0)),\n    scene(p + vec3(0.0,   e, 0.0)) - scene(p + vec3(0.0,  -e, 0.0)),\n    scene(p + vec3(0.0, 0.0,   e)) - scene(p + vec3(0.0, 0.0,  -e))\n  ));\n}\n\nfloat rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  float sceneDist = 0.;\n  float rayDepth = start;\n  for(int i = 0; i < maxIterations; i++) {\n    sceneDist = scene(origin + dir * rayDepth);\n    if((sceneDist < stopThreshold) || (rayDepth >= end)) {\n      break;\n    }\n    rayDepth += sceneDist * stepScale;\n  }\n  if (sceneDist >= stopThreshold) {\n    rayDepth = end;\n  } else {\n    rayDepth += sceneDist;\n  }\n  return rayDepth;\n}\n\nvec3 lighting(vec3 position, vec3 cameraPos) {\n  vec3 sceneColor = vec3(0.);\n  vec3 normal = getNormal(position);\n\n  vec3 objColor = vec3(.2, .2, .8);\n\n  vec3 lightPos = vec3(0., 0., 0.);\n\n  vec3 ambient = vec3(0., 0., .1);\n\n  vec3 lightDir = lightPos - position;\n\n  // directional light\n  // float diffuse = max(0., dot(normal, normalize(lightPos)));\n\n  // point light\n  float diffuse = max(0., dot(normal, normalize(lightDir)));\n  float d = distance(lightPos, position);\n  vec3 k = vec3(.06, .08, .09);\n  float attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n\n  vec3 ref = reflect(-normalize(lightDir), normal);\n  float specular = max(0., dot(ref, normalize(cameraPos - normal)));\n  float specularPower = 16.;\n  specular = pow(specular, specularPower);\n\n  diffuse *= attenuation;\n  specular *= attenuation;\n\n  return objColor * vec3(diffuse) + specular + ambient;\n}\n\nvec3 fog(vec3 color, float distance, vec3 fogColor, float b) {\n  float fogAmount = 1. - exp(-distance * b);\n  return mix(color, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  vec2 screenCoord = (2. * fragCoord.xy / iResolution.xy - 1.) * aspect;\n\n  // camera settings\n  vec3 lookAt = vec3(0., 0., 0.);\n  vec3 cameraPos = vec3(cos(iTime / 3.) * 4., sin(iTime / 3.) * 4., 4.);\n  float fov = .9;\n  float nearClip = 0.;\n  float farClip = 80.;\n\n  // camera vectors\n  vec3 forward = normalize(lookAt - cameraPos);\n  vec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, forward));\n\n  // raymarch\n  vec3 rayOrigin = cameraPos;\n  vec3 rayDirection = normalize(forward + fov * screenCoord.x * right + fov * screenCoord.y * up);\n  float dist = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n\n  if(dist >= farClip) {\n    vec3 bgColor = vec3(0.);\n    fragColor = vec4(bgColor, 1.);\n    return;\n  }\n\n  vec3 position = rayOrigin + rayDirection * dist;\n  vec3 normal = getNormal(position);\n\n  vec3 sceneColor = lighting(position, cameraPos);\n  sceneColor = fog(sceneColor, dist, vec3(0.), .04);\n\n  fragColor = vec4(sceneColor, 1.);\n}\n","name":"Image","description":"","type":"image"}]}