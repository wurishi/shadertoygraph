{"ver":"0.1","info":{"id":"wtBfWD","date":"1598941960","viewed":141,"name":"Triangle and Circles","username":"jasonzil","description":"A sketch to play with shifting shapes\n\nSmoothstep made the whole thing quite slow","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM 3.\n#define AA .01\n#define S(v)  smoothstep(AA,-AA,v)\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Gold Noise ©2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat sdf_circle( in vec2 p , float r){\n\treturn distance ( p , vec2(.5))-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // define scale correctly at all resolutions, thanks @FabriceNeyret2!!!\n    float scale = (NUM + 5.*smoothstep(-.5,.5, sin(iTime))) / iResolution.y;\n    vec2 uv = (fragCoord - iResolution.xy*.5) * scale; // that makes it easy to change the center!\n    \n    vec2 cellVal = floor (uv)+1.;//this +1 is to offset the 0 that is used \n    vec2 cellValOff = floor( uv + vec2(.5)*NUM);\n    uv = fract (uv);\n    vec2 anotherUV = floor(uv * NUM + .5 ) / NUM;\n    vec3 col = vec3(0.0);\n    float sdTri = sdEquilateralTriangle((uv-vec2(.5))*3.);\n    float sdCirc = (sdf_circle(uv, .23));\n    float sd = max(mix(sdCirc,sdTri,cos(iTime*gold_noise(cellVal.xy+1.,1.))),\n                   mix(sdTri,sdCirc,sin(iTime*gold_noise(cellVal.xy+6.,1.))));\n    \n    vec3 niceYellow = vec3(.937,.788,.345);\n    vec3 niceOrange = vec3(.882,.478,.278);\n    vec3 niceTeal = vec3(.29, .694,.616);\n    vec3 niceRed = vec3(.937,.239,.349);\n    \n    vec3 colTri = S(sd) * mix(niceYellow, niceOrange, abs(sin(iTime* .8 + gold_noise(cellVal.xy,1.))));\n    vec3 colCirc = S(sd) * mix(niceRed,niceTeal, abs(cos(iTime*.4+gold_noise(cellVal,1.))));\n\t\t\n        \n    col = mix ( colTri, colCirc, fract(.7*iTime * gold_noise(cellVal,cellVal.x + cellVal.y)));\n        \n\tcol += S(length(col)) * vec3(.2,.3,.32);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}