{"ver":"0.1","info":{"id":"7dyBRG","date":"1658383593","viewed":240,"name":"Disk Blur","username":"libcg","description":"Inspired from: https://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The second pass filters out the noise\n\n#define GOLDEN_ANGLE 2.39996322972865332f\n\n#define NUM_TAPS 8\n#define BLUR_STRENGTH 10.f\n\nvec3 linearToSrgb(vec3 color) {\n    bvec3 isLo = lessThanEqual(color, vec3(0.0031308f));\n\n    vec3 loPart = color * 12.92f;\n    vec3 hiPart = pow(color, vec3(5.0f / 12.0f)) * 1.055f - 0.055f;\n    return mix(hiPart, loPart, isLo);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = vec2(textureSize(iChannel0, 0).xy);\n    vec3 sum = vec3(0.f, 0.f, 0.f);\n    float coc = BLUR_STRENGTH * sin(float(iTime));\n    \n    // Texture taps in a sunflower pattern (uniformly spread)\n    // https://thatsmaths.com/2014/06/05/sunflowers-and-fibonacci-models-of-efficiency/\n    for (int i = 0; i < NUM_TAPS; i++) {\n        float radius = coc * sqrt(float(i) / float(NUM_TAPS));\n        float angle = float(i) * GOLDEN_ANGLE;\n        vec2 offset = radius * vec2(sin(angle), cos(angle));\n        \n        sum += texture(iChannel0, (fragCoord + offset) / size).xyz;\n    }\n    \n    fragColor = vec4(linearToSrgb(sum / float(NUM_TAPS)), 1.f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The first pass creates a noisy blur unless the number of samples is really high\n\n#define GOLDEN_ANGLE 2.39996322972865332f\n\n#define NUM_TAPS 32\n#define BLUR_STRENGTH 40.f\n\nvec3 srgbToLinear(vec3 color) {\n    bvec3 isLo = lessThanEqual(color, vec3(0.04045f));\n\n    vec3 loPart = color / 12.92f;\n    vec3 hiPart = pow((color + 0.055f) / 1.055f, vec3(12.0f / 5.0f));\n    return mix(hiPart, loPart, isLo);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = vec2(textureSize(iChannel0, 0).xy);\n    vec3 sum = vec3(0.f, 0.f, 0.f);\n    float coc = BLUR_STRENGTH * sin(float(iTime));\n    \n    // Texture taps in a sunflower pattern (uniformly spread)\n    // https://thatsmaths.com/2014/06/05/sunflowers-and-fibonacci-models-of-efficiency/\n    for (int i = 0; i < NUM_TAPS; i++) {\n        float radius = coc * sqrt(float(i) / float(NUM_TAPS));\n        float angle = float(i) * GOLDEN_ANGLE;\n        vec2 offset = radius * vec2(sin(angle), cos(angle));\n        \n        sum += srgbToLinear(texture(iChannel0, (fragCoord + offset) / size).xyz);\n    }\n    \n    fragColor = vec4(sum / float(NUM_TAPS), 1.f);\n}","name":"Buffer A","description":"","type":"buffer"}]}