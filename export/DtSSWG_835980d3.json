{"ver":"0.1","info":{"id":"DtSSWG","date":"1676640249","viewed":235,"name":"DaluxCompass","username":"Mesterli","description":"Dalux toy","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["dalux"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.0005\n\nvec2 rotate(vec2 p, float angle) {\n    return vec2(cos(angle)*p.x-sin(angle)*p.y, sin(angle)*p.x+cos(angle)*p.y);\n}\n\nvec3 sampleNormal(vec2 p) {\n    return 2.0*texture(iChannel1, p).xyz-0.5;\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5-0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) + k*h*(1.0-h);\n}\n\nfloat roundedCylinder(vec3 p, float radius, float halfHeight, float cornerRadius) {\n    vec2 dists = vec2(length(p.xy)-radius+cornerRadius, abs(p.z)-halfHeight+cornerRadius);\n    return length(max(dists, 0.0))-cornerRadius;\n}\n\nfloat cylinder(vec3 p, float radius) {\n    return length(p.xy)-radius;\n}\n\nfloat rect2d(vec2 p, vec2 size) {\n    return length(max(abs(p)-size, 0.0));\n}\n\nstruct Surface {\n    vec3 color;\n    bool metallic;\n    vec3 roughnessVec;\n};\n\nfloat parallelogram2d(vec2 p, float len, float width) {\n    vec2 p2 = abs(p);\n    vec2 a = vec2(width, 0.0);\n    vec2 b = vec2(0.0, len);\n    vec2 normal = normalize(vec2(len, width));\n    return min(dot(abs(p2)-a, normal), min(distance(p2, a), distance(p2, b)));\n}\n\nfloat needle(vec3 p, float len, float width, float height, out Surface surface) {\n    float planarDist = parallelogram2d(p.xy, len, width);\n    vec2 dists = vec2(planarDist, abs(p.z)-height);\n    float dist = length(max(dists, 0.0));\n    if (dist < EPS) {\n        surface.color = p.y > 0.0 ? vec3(0.88, 0.3, 0.3) : vec3(0.92, 0.92, 0.92);\n        surface.metallic = false;\n        surface.roughnessVec = 0.1*sampleNormal(p.xy);\n    }\n    return dist;\n}\n\nvec3 compassTexture(float x, float y) {\n    const vec3 background = vec3(0.95, 0.9, 0.8);\n    const vec3 mainColor = vec3(0.26, 0.36, 0.42);\n    const vec3 softColor = vec3(0.55, 0.6, 0.6);\n    // North\n    if (abs(x) < 0.07 && abs(y-0.32) < 0.05) {\n        return vec3(0.55, 0.78, 0.25);\n    }\n    if (y > 0.37 && abs(abs(x)+y-0.45) < 0.01) {\n        return mainColor;\n    }\n    // West\n    if (y < 0.06 && abs(4.0*abs(x+0.39)-2.0*y-0.12) < 0.028) {\n        return mainColor;\n    }\n    // East\n    float d = length(vec2(x*1.5-0.55, y));\n    if (d < 0.07 && d > 0.055) {\n        return mainColor;\n    }\n    if (abs(1.5*x-0.55-y) < 0.01 && y > -0.08 && y < 0.08) {\n        return mainColor;\n    }\n    // South\n    float offsetY = y+0.37;\n    float dy = (x < offsetY ? offsetY-0.0333 : offsetY+0.0333);\n    d = length(vec2(x, dy));\n    if (d < 0.04 && d > 0.027) {\n        return mainColor;\n    }\n    \n    if (parallelogram2d(vec2(x, y), 0.25, 0.05) < 0.0 || parallelogram2d(vec2(x, y), 0.05, 0.25) < 0.0) {\n        return mainColor;\n    }\n    vec2 rot = rotate(vec2(x, y), 3.1415/4.0);\n    if (parallelogram2d(rot, 0.2, 0.05) < 0.0 || parallelogram2d(rot, 0.05, 0.2) < 0.0) {\n        return softColor;\n    }\n   \n    return background;\n}\n\nfloat compass(vec3 p, out Surface surface) {\n    const vec3 brass = vec3(0.74, 0.651, 0.259);\n    \n    float radius = 0.6;\n    float dist = smax(-cylinder(p, radius-0.1), roundedCylinder(p, radius, 0.1, 0.08), 0.05);\n    if (dist < EPS) {\n        surface.color = brass;\n        surface.metallic = true;\n        surface.roughnessVec = 0.08*sampleNormal(p.xy);\n        return dist;\n    }\n    dist = min(dist, max(cylinder(p, radius-0.1), p.z));\n    if (dist < EPS) {\n        surface.color = compassTexture(p.x, p.y);\n        surface.metallic = false;\n        surface.roughnessVec = 0.11*sampleNormal(p.xy);\n        return dist;\n    }\n    \n    float angle = sin(iTime)/2.0-3.14/3.0;\n    vec3 needlePos = vec3(rotate(p.xy, angle), p.z-0.05);\n    dist = min(dist, needle(needlePos, radius-0.2, 0.05, 0.005, surface));\n    if (dist < EPS) { return dist; }\n    \n    dist = min(dist, max(cylinder(p, 0.02), p.z-0.08));\n    if (dist < EPS) {\n        surface.color = brass;\n        surface.metallic = true;\n        surface.roughnessVec = 0.1*sampleNormal(p.xy);\n    }\n    return dist;\n}\n\nfloat desk(vec3 p, out Surface surface) {\n    vec3 p2 = vec3(rotate(p.xy+vec2(0.4, 0.6), 0.4), p.z+0.05);\n    float dist = p2.z;\n    if (dist < EPS) {\n        if (abs(mod(p2.x, 1.0)-0.5) < 0.005 || abs(mod(p2.y, 1.0)-0.5) < 0.005) {\n            surface.color = vec3(0.72, 0.6, 0.32);\n        } else {\n            surface.color = vec3(0.96, 0.84, 0.56);\n        }\n        surface.color = 0.15*texture(iChannel0, p2.xy).xyz+0.85*surface.color;\n        surface.metallic = false;\n        surface.roughnessVec = 0.08*sampleNormal(p.xy);\n    }\n    return dist;\n}\n\n  \nfloat scene(vec3 p, out Surface surface) {\n   float dist = desk(p, surface);\n   dist = min(dist, compass(p, surface));\n   return dist;\n}\n\nfloat sceneDist(vec3 p) {\n    Surface surface;\n    return scene(p, surface);\n}\n\nfloat raymarch(vec3 position, vec3 direction, int iterations, out Surface surface) {\n    float cameraDist = 0.1;\n    for(int i = 0 ; i < iterations; i++) {\n        float dist = scene(position + cameraDist*direction, surface);\n        if(dist < EPS) {\n            return cameraDist;\n        }\n        cameraDist += dist;     \n    }\n    return -1.0;\n}\n\nvec3 computeNormal(vec3 p) {\t\n    vec2 d = vec2(1.0*EPS, 0.0);\n    return normalize(vec3(\n        sceneDist(p+d.xyy) - sceneDist(p-d.xyy),\n        sceneDist(p+d.yxy) - sceneDist(p-d.yxy),\n        sceneDist(p+d.yyx) - sceneDist(p-d.yyx)\n    ));\n}\n\nfloat computeShadow(vec3 pos, vec3 dir, float k) {\n    Surface surface;\n    float cameraDist = 0.01;\n    float shadow = 0.0;\n    for (int i = 0; i < 20; i++) {\n        float dist = sceneDist(pos + cameraDist*dir);\n        if (dist < EPS) {\n            return 1.0;\n        }\n        shadow = max(shadow, 1.0-10.0*dist/cameraDist);\n        cameraDist += dist;\n    }  \n    return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(fragCoord.xy / iResolution.xy)-1.0;\n    uv.x *= iResolution.x / iResolution.y;\n  \n    float screenDist = 3.0;\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    \n    vec3 camPos = vec3(0.5-0.5*sin(iTime/3.0), -2.0-0.1*cos(iTime/3.0), 4);\n    //vec3 camPos = vec3(0.0, 0.0, 2.0);\n    vec3 camTarget = vec3(0.0, 0.0, -0.1);\n    vec3 camDir = normalize(camTarget-camPos);\n    vec3 camRight = cross(camDir, vec3(0.0, 0.0, 1.0));\n    vec3 camUp = cross(camRight, camDir);\n    vec3 rayTarget = camPos + screenDist*camDir + uv.x*camRight + uv.y*camUp;\n    vec3 rayDir = normalize(rayTarget-camPos);\n    \n    Surface surface;\n    float cameraDist = raymarch(camPos, rayDir, 200, surface);\n    \n    if (cameraDist > 0.0) {\n        vec3 hitPos = camPos+cameraDist*rayDir;\n        vec3 specularDir = normalize(lightDir-camDir);\n        \n        vec3 normal = computeNormal(hitPos);\n        float occlusion = (0.05-sceneDist(hitPos+0.05*normal))*3.0;\n        normal = normalize(normal+surface.roughnessVec);\n\n        float shadow = computeShadow(hitPos, lightDir, 2.0);\n        \n        float specularDot = max(0.0, dot(specularDir, normal));\n        float specular = surface.metallic ? 0.8*pow(specularDot, 20.0) : 0.0;\n        \n        vec3 lightColor = 0.55*vec3(0.95, 0.9, 0.8);\n        vec3 ambientColor = 0.5*vec3(0.95, 0.9, 0.85);\n        vec3 color = (\n            (1.0-occlusion)*ambientColor+(1.0-shadow)*max(dot(lightDir, normal), 0.0)*lightColor)*surface.color\n            +specular*lightColor;\n\n        fragColor = vec4(color, 1.0);\n        //fragColor = vec4(occlusion, 0.0, 0.0, 1.0);\n        //fragColor = vec4(specular, 0.0, 0.0, 1.0);\n        //fragColor = vec4(shadow, 0.0, 0.0, 1.0);\n        //fragColor = vec4(normal, 1.0);\n    } else {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}