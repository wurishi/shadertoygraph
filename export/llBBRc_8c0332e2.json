{"ver":"0.1","info":{"id":"llBBRc","date":"1516822132","viewed":75,"name":"AUCS playground","username":"ilmikko","description":"This is the playground shader for the Wednesday AUCS meet!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["playground"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 circle(vec2 uv, vec2 position, float radius)\n{\n    // We can calculate a circle quite easily.\n    \n    // First we get the difference between the origin and the circle position, or center.\n    vec2 delta = uv-position;\n    \n    // Then we calculate the length of that vector (pythagorean theorem)\n    float circ = length(delta);\n    \n    // Scale the circle according to our radius\n    circ/=radius;\n    \n    // and invert it (because, at the center of the circle, we want 1, and at the edge we want 0)\n    circ=1.-circ;\n    \n    // Finally, ceil all the floats to the nearest integer.\n    // Comment this line out and see what it does!\n    circ = ceil(circ);\n    \n\treturn vec3(circ);\n}\nvec3 circle(vec2 uv, vec2 position, float radius, vec3 color)\n{\n\t// Overload for colored circles.\n    return circle(uv,position,radius)*color;\n}\n\nvec3 rectangle(vec2 uv, vec2 position, float width, float height)\n{\n    // A rectangle is almost as easy as a circle.\n    // Calculate the differences between the x and y\n    float deltaX = uv.x-position.x;\n    float deltaY = uv.y-position.y;\n    \n    // Calculate the length of these 1-dimensional vectors (same as abs in this case)\n    deltaX = length(deltaX);\n    deltaY = length(deltaY);\n    \n    // Scale the deltas according to our width and height\n    deltaX/=width;\n    deltaY/=height;\n    \n    // The step function does several things for us.\n    // First of all, it clamps the values between 0 and 1.\n    // This is important because when you multiply -1 and -1, you get a positive again.\n    // Second, it generates only a value that is either 0 or 1. If it's less than 0, it's 0. Otherwise it's 1.\n    // This saves us some time and makes our code faster.\n    deltaX = step(0.,1.-deltaX);\n    deltaY = step(0.,1.-deltaY);\n    \n    // Important bit: combining these floats into one\n    // Try doing just `rec = deltaX` or `rec = deltaY`.\n    float rec = deltaX * deltaY;\n    \n\treturn vec3(rec);\n}\nvec3 rectangle(vec2 uv, vec2 position, float width, float height, vec3 color)\n{\n\t// Overload for colored rectangles.\n    return rectangle(uv,position,width,height)*color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // First we divide the (x,y) coordinate by the (w,h) size to get values from 0 to 1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Then we subtract 0.5, 0.5 from x, y to move our origin to the center.\n    uv -= 0.5;\n    \n    // Then we divide the x coordinate by the ratio of our resolution in order to get square pixels again.\n    uv.x /= iResolution.y / iResolution.x;\n    \n    // Color: a three dimensional vector (r,g,b) where r,g,b are between 0 and 1\n    vec3 color = vec3(0,0,0);\n    \n    color += circle(uv, vec2(0,0), 0.5, vec3(0,1,0));\n    \n    // Drawing over\n    color -= rectangle(uv, vec2(0,0), 0.25, 0.25, vec3(0,1,0));\n    color += rectangle(uv, vec2(0,0), 0.25, 0.25, vec3(1,0,0));\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}