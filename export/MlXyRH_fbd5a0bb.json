{"ver":"0.1","info":{"id":"MlXyRH","date":"1503523063","viewed":493,"name":"Hypersponge","username":"Polygon","description":"This is what a 4d Menger Sponge looks like, with 3d space representing a \"cross section\" of 4d space.\n\nIt probably won't work with browsers that don't support WebGL 2.0 yet, so I'll fix that soon.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["menger","4d","crosssection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ORDER 4\n#define FOV 100.\n\n//Don't mess with these.\n#define pi 3.14159265\n#define d2r 0.0174533\n#define WIDTH int(pow(3., float(ORDER)))\n\n//bool check(vec4  pos);\nvec4 render(vec2 coord);\nmat2 rotate(float spin) {return mat2(cos(spin), sin(spin), -sin(spin), cos(spin));}\nvec4 transform(vec3 start);\nvec3 iTransform(vec4 start);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = render(fragCoord.xy);\n}\n\n\n\nvec4 render(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv -= .5;\n    \n    float maxRes = max(iResolution.x, iResolution.y);\n    vec2 s = coord.xy / maxRes - vec2(0.5 * iResolution.x / maxRes, 0.5 * iResolution.y / maxRes);\n    \n    vec2 uvM = iMouse.xy / iResolution.xy - .5;\n    \n    \n    vec2 rot = 5.*vec2(-uvM.x,-uvM.y);\n    vec4 pos = -1.75 * float(WIDTH) * vec4(sin(rot.x) * cos(rot.y), sin(rot.y), cos(rot.x) * cos(rot.y), 0.);\n    \n    pos = transform(pos.xyz);\n    \n    vec4 d = vec4(2.0 * s.x * tan(d2r * FOV / 2.0), 2.0 * s.y * tan(d2r * FOV / 2.0), 1.0, 0.);\n    \n    vec4 sky = vec4(0.5 - 0.5 * sin(d.y), 0.7 - 0.3 * sin(d.y),1.0,0.0);\n    vec4 o = sky;\n    \n    //Rotations\n    d.yz *= rotate(rot.y);\n    d.xz *= rotate(rot.x);;\n    \n    d = transform(d.xyz) - transform(vec3(0));\n    \n    d = normalize(d);\n    \n    vec4 d0 = vec4(equal(d, vec4(0)));\n    \n    \n    vec4 bounderies = vec4(WIDTH) * (0.5 - 0.5 * sign(d));\n    vec4 t = (bounderies - pos) / d;\n    t *= 1. - d0;\n    \n    vec4 mask = vec4(greaterThanEqual(t.xyzw, max(t.yzwx, max(t.zwxy, t.wxyz))));\n    \n    vec4 endPos = (1. - mask) * (pos + d * dot(t, mask))   +   mask * bounderies;\n    \n    if (dot(t, mask) <= 0.)\n        endPos = pos;\n    \n    float ao;\n    \n    //MAIN LOOP\n    for (int j = 0; j < 10; j++) {\n        ao = float(j); // ambient occlusion\n        \n        if (max(endPos.x, max(endPos.y, max(endPos.z, endPos.w))) > float(WIDTH) || min(endPos.x, min(endPos.y, min(endPos.z, endPos.w))) < 0.)\n            break;\n        \n        vec4 lastEntered = vec4(equal(endPos, floor(endPos)));\n        ivec4 enter = ivec4(floor(endPos) - (.5 + .5 * -sign(d)) * lastEntered);\n        \n        bvec4 inf;\n        int num = WIDTH / 3;\n        for (int i = 0; i < ORDER; i++) {\n            \n            \n            bvec4 sliceCheck = bvec4(!any(bvec3((enter.yzw / num - 1) % 3)),!any(bvec3((enter.xzw / num - 1) % 3)),!any(bvec3((enter.xyw / num - 1) % 3)),!any(bvec3((enter.xyz / num - 1) % 3)));\n            \n            if (any(sliceCheck)) {\n                \n                if (all(sliceCheck))\n                    inf = bvec4(0);\n                else\n                    inf = sliceCheck;\n                \n                break;\n            }\n            \n            num /= 3;\n        }\n        \n        if (num == 0) {\n            o = vec4(1);\n            float dist = distance(iTransform(endPos), iTransform(pos));\n            \n            vec4 normal = sign(d) * (lastEntered);\n            vec3 Normal = iTransform(normal) - iTransform(vec4(0));\n            Normal = normalize(Normal);\n            \n            vec3 lightPos = iTransform(pos);\n            \n            o = vec4(0);\n            o.xy = vec2(dot(normalize(-lightPos + iTransform(endPos)), Normal));\n            o.xy = o.xy / 2. + .5;\n            \n            // specular highlight\n            o.xyz += max(0., pow(dot(normalize(-lightPos + iTransform(endPos)), Normal), 20.)) * 0.6;\n            \n            o /= (dist * dist / float(WIDTH * WIDTH) / 9. + 1.);\n            o *= 1.0 - ao / 10.0;\n            \n            break;\n        }\n        \n        ivec4 nextPlane = num * (enter / num) + num * ivec4(.5 + .5 * sign(d));\n        \n        nextPlane += 10000 * ivec4(inf) * ivec4(floor(sign(d)));\n        \n        \n        vec4 distToNext = (vec4(nextPlane) - endPos) / d;\n        \n        distToNext = distToNext * (1. - d0) + d0 * 2. * float(WIDTH); \n        \n        bvec4 mask = lessThanEqual(distToNext.xyzw, min(distToNext.yzwx, min(distToNext.zwxy, distToNext.wxyz)));\n        float time = dot(distToNext, vec4(mask));\n        \n        endPos = vec4(mask) * vec4(nextPlane) + (endPos + d * time) * (1. - vec4(mask));\n        \n    }\n    \n    \n    return o;\n}\n\n\n/*\nbool check(vec4 pos) {\n    ivec4 uv = ivec4(pos);\n    \n    int num = WIDTH;\n    for (int i = 0; i < ORDER; i++) {\n        num /= 3;\n        if (!(bool((uv.x / num - 1) % 3) || bool((uv.y / num - 1) % 3) || bool((uv.z / num - 1) % 3))\n           || !(bool((uv.x / num - 1) % 3) || bool((uv.y / num - 1) % 3) || bool((uv.w / num - 1) % 3))\n           || !(bool((uv.x / num - 1) % 3) || bool((uv.z / num - 1) % 3) || bool((uv.w / num - 1) % 3))\n           || !(bool((uv.y / num - 1) % 3) || bool((uv.z / num - 1) % 3) || bool((uv.w / num - 1) % 3)))\n            return false;\n    }\n    \n    return true;\n}\n*/\n\n\n\nvec4 transform(vec3 start) {\n    float d = float(WIDTH) / 2. * (sin(iTime * pi / 12.));\n    float thetaXY = iTime;\n    float thetaYZ = iTime * pi / 4.;\n    float thetaXZ = iTime * pi * pi / 16.;\n    \n    vec4 coords = vec4(start, d);\n    coords.zw *= rotate(thetaXY);\n    coords.xw *= rotate(thetaYZ);\n    coords.yw *= rotate(thetaXZ);\n    coords += float(WIDTH) / 2.;\n    \n    return coords;\n}\n\nvec3 iTransform(vec4 coords) {\n    float thetaXY = iTime;\n    float thetaYZ = iTime * pi / 4.;\n    float thetaXZ = iTime * pi * pi / 16.;\n    \n    coords -= float(WIDTH) / 2.;\n    coords.yw *= rotate(-thetaXZ);\n    coords.xw *= rotate(-thetaYZ);\n    coords.zw *= rotate(-thetaXY);\n    \n    return vec3(coords);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}