{"ver":"0.1","info":{"id":"llGBRy","date":"1542915861","viewed":150,"name":"Ray Trace Test","username":"foodini","description":"A simple raytracer, with diffuse, specular, reflection, shadows. Still needs visible light sources.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","raytracer","raytrace","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray {\n\tvec3 o;\n\tvec3 d;\n};\n\nstruct light {\n\tvec3 pos;\n\tvec3 col;\n\tfloat exp;\n};\n\nstruct shape {\n\tint type; //0:sphere, 1:plane\n\t\n\tvec3 pos;\n\tvec3 offset;  //radius or normal\n\t\n\tfloat diffuse_fract;\n\tfloat specular_fract;\n\tint diffuse_texture;\n\t\n\tfloat reflective_fract;\n};\n\n    \nconst int obj_count = 10;\nconst int light_count = 3;\nshape shapes[obj_count];\nlight lights[light_count];\n    \n\n//ray must be normalized!\nfloat ray_sphere_isect(ray r, const int id) {\n\tshape s = shapes[id];\n\t\n\tfloat a = dot(r.d, r.d);\n\tvec3 s0_r0 = r.o - s.pos;\n\tfloat b = 2.0*dot(r.d, s0_r0);\n\tfloat c = dot(s0_r0, s0_r0) - s.offset.x*s.offset.x;\n\tfloat b2 = b*b;\n\tif (b2 - 4.0*a*c < 0.0) {\n\t\treturn -1.0;\n\t}\n\treturn (-b - sqrt(b2 - 4.0*a*c)) / (2.0*a); \n}\n\nvec3 diffuse_texture(vec3 p, int t) {\n\tif(t==0)\n\t\treturn vec3(1.0,0.,0.0);\n\tif(t==1)\n\t\treturn vec3(1.0 - (\n\t\t\tsmoothstep(0.3, 0.5, fract(p.z)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.z)) +\n\t\t\tsmoothstep(0.3, 0.5, fract(p.y)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.y))\n\t\t\t));\n\tif(t==2)\n\t\treturn vec3(1.0 - (\n\t\t\tsmoothstep(0.3, 0.5, fract(p.x)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.x)) +\n\t\t\tsmoothstep(0.3, 0.5, fract(p.z)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.z))\n\t\t\t));\n\tif(t==3)\n\t\treturn vec3(1.0 - (\n\t\t\tsmoothstep(0.3, 0.5, fract(p.x)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.x)) +\n\t\t\tsmoothstep(0.3, 0.5, fract(p.y)) -\n\t\t\tsmoothstep(0.5, 0.7, fract(p.y))\n\t\t\t));\n\tif(t==4)\n\t\treturn vec3(0.0,1.0,0.0);\n\tif(t==5)\n\t\treturn vec3(0.0,0.0,1.0);\n\treturn vec3(0.2,0.2,0.2);\n\n}\n\nfloat ray_plane_isect(ray r, const int id) {\n\tshape s = shapes[id];\n\n\tfloat denom = dot(s.offset, r.d);\n\tif(denom > 1.0e-6) {\n\t\tfloat t = dot((s.pos - r.o), s.offset) / denom;\n\t\tif(t > 1.0e-6) {\n\t\t\treturn t;\n\t\t}\n\t}\n\treturn -1.0;\n}\n\n//Should isect_dist return dist*dist?\nfloat isect_dist(ray r, int id) {\n\tif (shapes[id].type == 0) {\n\t\treturn ray_sphere_isect(r, id);\n\t} else {\n\t\treturn ray_plane_isect(r, id);\n\t}\n\treturn -1.;\n}\n\nvec3 isect_normal(vec3 position, int id) {\n\tif (shapes[id].type == 0) {\n\t\treturn(normalize(position - shapes[id].pos));\n\t} else {\n\t\treturn(-shapes[id].offset);\n\t}\n}\n\n//TODO: \n// * Light attenuation is broken. Gets brighter with distance.\n// * visible light sources.\nvec3 get_color_for_ray(ray r) {\n\tint ignore = -1;\n\tvec3 retval = vec3(0.0);\n\t/* visible light sources...\n\tfor(lid=0; lid<light_count; lid++) {\n\t\tvec3\n\t}\n\t*/\n\tfloat attenuation = 1.0;\n\tint depth = 0;\n\tvec3 position, normal, reflection, to_v;\n\twhile(depth < 4 && attenuation > 0.05) {\n\t\tdepth += 1;\n\t\tfloat min_dist = 100000.;\n\t\tint nearest_obj = -1;\n\t\tfor (int obj_id=0; obj_id<obj_count; obj_id++) {\n\t\t\tif (obj_id == ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfloat t = isect_dist(r, obj_id);\n\t\t\tif (t > 0.0 && t < min_dist) {\n\t\t\t\tnearest_obj = obj_id;\n\t\t\t\tmin_dist = t;\n\t\t\t}\n\t\t}\n\t\tif (nearest_obj < 0) {\n\t\t\treturn retval;\n\t\t}\n\t\tposition = r.o + r.d*min_dist;\n\t\tnormal = isect_normal(position, nearest_obj);\n\t\tif (shapes[nearest_obj].diffuse_fract > 0.0 || shapes[nearest_obj].reflective_fract > 0.0) {\n\t\t\tto_v = normalize(r.o - position);\n\t\t\treflection = reflect(to_v, normal);\n\t\t}\n\t\tif (shapes[nearest_obj].diffuse_fract > 0.0) {\n\t\t\tfor (int lid=0; lid<light_count; lid++) {\n\t\t\t\tvec3 to_l = lights[lid].pos - position;\n\t\t\t\tray shadow_test = ray(position, to_l);  //NOT NORMALIZED\n\t\t\t\tbool shadowed = false;\n\t\t\t\tif (dot(normal, to_l) < 0.0) {\n\t\t\t\t\tshadowed = true;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int obj_id=0; obj_id<obj_count; obj_id++) {\n\t\t\t\t\t\tfloat dist = isect_dist(shadow_test, obj_id);\n\t\t\t\t\t\tif (dist > 0.0 && dist < 1.0) { //1.0 because shadow_test isn't normalized\n\t\t\t\t\t\t\tshadowed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!shadowed) {\n\t\t\t\t\tto_l = normalize(to_l);\n\t\t\t\t\tretval += \n\t\t\t\t\t\tattenuation * (\n\t\t\t\t\t\t\tdiffuse_texture(position, shapes[nearest_obj].diffuse_texture)\n\t\t\t\t\t\t\t* dot(to_l, normal) \n\t\t\t\t\t\t\t* shapes[nearest_obj].diffuse_fract\n\t\t\t\t\t\t\t/ sqrt(dot(to_l, to_l))\n\t\t\t\t\t\t\t//SPECULAR:\n\t\t\t\t\t\t\t+ lights[lid].col\n\t\t\t\t\t\t\t\t* pow(dot(to_l, reflection), 50.0)\n\t\t\t\t\t\t\t\t* shapes[nearest_obj].specular_fract\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shapes[nearest_obj].reflective_fract <= 0.0) {\n\t\t\treturn retval;\n\t\t}\n\t\tretval *= (1.0 - shapes[nearest_obj].reflective_fract);\n\t\tattenuation *= shapes[nearest_obj].reflective_fract;\n\t\tr.o = position;\n\t\tr.d = -reflection;\n\n\t\tignore = nearest_obj;\n\t}\n\treturn retval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float st = sin(iTime);\n    float ct = cos(iTime);\n    float nst = -sin(iTime);\n    float nct = -cos(iTime);\n    shapes[0] = shape(0, vec3(st,ct,nst),    vec3(0.9),        0.7, 0.9, 0, 0.1);\n    shapes[1] = shape(0, vec3(ct,nst,nct),    vec3(1.2),        0.7, 0.9, 4, 0.1);\n    shapes[2] = shape(0, vec3(nst,nct,st),  vec3(1.1),        0.7, 0.9, 5, 0.1);\n    shapes[3] = shape(0, vec3(nct,st,ct),    vec3(1.0),       0.4, 0.9, 6, 0.2);\n    shapes[4] = shape(1, vec3( 6.,0.,0.),    vec3(1.,0.,0.),  1.0, 1.0, 1, 0.0);\n    shapes[5] = shape(1, vec3(-6.,0.,0.),   vec3(-1.,0.,0.),  1.0, 1.0, 1, 0.0);\n    shapes[6] = shape(1, vec3( 0.,6.,0.),    vec3(0.,1.,0.),  1.0, 1.0, 2, 0.0);\n    shapes[7] = shape(1, vec3( 0.,-6.,0.),   vec3(0.,-1.,0.), 1.0, 1.0, 2, 0.0);\n    shapes[8] = shape(1, vec3( 0.,0.,6.),    vec3(0.,0.,1.),  1.0, 1.0, 3, 0.0);\n    shapes[9] = shape(1, vec3( 0.,0.,-6.),   vec3(0.,0.,-1.), 1.0, 1.0, 3, 0.0);\n    lights[0] = light(vec3(sin(iTime)*2.0,   cos(iTime)*2.0, 2.0), vec3(1.0, 0.0, 0.0), 5.0);\n    lights[1] = light(vec3(cos(iTime)*2.0,   sin(iTime)*2.0, 2.0), vec3(0.0, 1.0, 0.0), 5.0);\n    lights[2] = light(vec3(-sin(iTime)*2.0,  cos(iTime)*2.0, 2.0), vec3(0.0, 0.0, 1.0), 5.0);\n    vec3 viewpoint = vec3(6.0*sin(iTime/3.0), 6.0*cos(iTime/3.0), 2.0*sin(iTime/2.0));\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 lookdir = viewpoint - lookat;\n    vec3 right = vec3(-lookdir.y, lookdir.x, 0.0);\n\t\t\n\tvec2 screen_coords = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tright *= 3.0/length(right);\n\tvec3 up = cross(lookdir, right);\n\tup *= 3.0/(length(up))*iResolution.y/iResolution.x;\n\n\tvec3 screen_vect = normalize((lookat + up * screen_coords.y + right * screen_coords.x) - viewpoint);\n\tray r = ray(viewpoint, screen_vect);\n\n\tfragColor = vec4(get_color_for_ray(r), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}