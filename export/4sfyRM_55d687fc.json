{"ver":"0.1","info":{"id":"4sfyRM","date":"1487337252","viewed":270,"name":"Sphere & 50 lights - Phong","username":"mantiuk","description":"A sphere is illuminated by 50 lights. The lights are importance-sampled from the HDR illumination map. Phong reflection model used for shading.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["phong","hdr","brdf","ibl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader was based on: https://www.shadertoy.com/view/XsjSRG\n\n#define TONE_MAP_GAMMA 2.3\n\n#define PI 3.1415926535897932384626433832795\n#define PI_MODIFIER 4.0\n\nvec3 obj_pos = vec3(0.0,0.0,-10.0);\nfloat obj_size = 5.0;\n\nfloat sphere(vec3 dir, vec3 center, float radius) {\n    vec3 rp = -center;\n\tfloat b = dot(rp,dir);\n\tfloat dist = b * b - (dot(rp,rp) - radius * radius);\n\tif(dist <= 0.0) return -1.0;\n\treturn -b - sqrt(dist);\n}\n\n\nvec3 toneMap( vec3 color, float exposure )\n{\n    return pow( exposure * color, vec3( 1., 1., 1. ) / TONE_MAP_GAMMA );\n}\n\n#define NO_LIGHTS 50\n\nconst vec3 light_pos[NO_LIGHTS] = vec3[NO_LIGHTS](\n\tvec3( 0.9795, -0.199, 0.03061 ), \n\tvec3( -0.6191, 0.4162, -0.6659 ), \n\tvec3( -0.621, 0.6624, -0.4191 ), \n\tvec3( 0.7035, 0.3737, -0.6045 ), \n\tvec3( -0.9323, 0.3205, 0.1675 ), \n\tvec3( -0.2139, -0.9441, -0.2508 ), \n\tvec3( 0, 0.4741, -0.8805 ), \n\tvec3( 0.5121, 0.6364, -0.5768 ), \n\tvec3( 0, -0.7614, -0.6483 ), \n\tvec3( -0.5421, 0.6547, -0.5268 ), \n\tvec3( -0.6173, 0.6992, 0.3605 ), \n\tvec3( 0, 0.8646, -0.5024 ), \n\tvec3( -0.2879, -0.4645, -0.8375 ), \n\tvec3( 0.2781, 0.3615, -0.8899 ), \n\tvec3( -0.5941, -0.5523, 0.5848 ), \n\tvec3( 0, 0.4614, -0.8872 ), \n\tvec3( 0, -0.2444, 0.9697 ), \n\tvec3( 0.904, 0.1624, -0.3955 ), \n\tvec3( 0.2982, 0.8484, -0.4374 ), \n\tvec3( -0.754, -0.3711, 0.542 ), \n\tvec3( 0.4546, -0.8557, 0.2473 ), \n\tvec3( 0, -0.6964, 0.7177 ), \n\tvec3( -0.8943, -0.4332, 0.1118 ), \n\tvec3( 0.9625, -0.01504, 0.2707 ), \n\tvec3( 0.3822, -0.6263, -0.6794 ), \n\tvec3( 0.6443, 0.6598, 0.3866 ), \n\tvec3( 0.963, -0.2332, 0.1354 ), \n\tvec3( -0.4193, -0.7454, -0.5183 ), \n\tvec3( -0.4596, -0.684, -0.5665 ), \n\tvec3( -0.4009, 0.5876, -0.7029 ), \n\tvec3( -0.4768, 0.803, 0.3576 ), \n\tvec3( -0.1962, 0.761, -0.6183 ), \n\tvec3( 0.7421, 0.5102, 0.4348 ), \n\tvec3( 0, -0.7198, -0.6941 ), \n\tvec3( 0.8941, -0.02794, 0.447 ), \n\tvec3( -0.3756, -0.6867, 0.6224 ), \n\tvec3( 0, -0.6686, -0.7436 ), \n\tvec3( 0.582, 0.07591, -0.8097 ), \n\tvec3( 0.7022, -0.395, -0.5924 ), \n\tvec3( 0.3243, 0.209, -0.9226 ), \n\tvec3( 0.7855, 0.2393, -0.5707 ), \n\tvec3( -0.2695, 0.9325, 0.2404 ), \n\tvec3( 0, -0.9845, 0.1752 ), \n\tvec3( 0, -0.7546, 0.6562 ), \n\tvec3( 0.3261, -0.6522, -0.6843 ), \n\tvec3( 0.9826, -0.1459, 0.1151 ), \n\tvec3( -0.4522, 0.8513, -0.266 ), \n\tvec3( 0.4597, -0.7265, 0.5108 ), \n\tvec3( 0, -0.7012, -0.713 ), \n\tvec3( -0.7623, 0.2918, 0.5777 ) ); \n\nconst vec3 light_rgb[NO_LIGHTS] = vec3[](\n\tvec3(  0.605,  0.363,  0.312 ),\n\tvec3(  0.330,  0.164,  0.123 ),\n\tvec3(  0.406,  0.250,  0.205 ),\n\tvec3(  0.215,  0.130,  0.111 ),\n\tvec3(  1.500,  3.500,  5.500 ),\n\tvec3(  0.711,  0.434,  0.344 ),\n\tvec3(  0.727,  0.492,  0.418 ),\n\tvec3(  0.691,  0.418,  0.312 ),\n\tvec3(  0.809,  0.492,  0.387 ),\n\tvec3(  0.275,  0.168,  0.152 ),\n\tvec3(  0.211,  0.104,  0.095 ),\n\tvec3(  0.543,  0.383,  0.328 ),\n\tvec3(  0.424,  0.195,  0.164 ),\n\tvec3(  0.346,  0.229,  0.203 ),\n\tvec3(  0.832,  0.520,  0.414 ),\n\tvec3(  0.486,  0.334,  0.277 ),\n\tvec3(  0.633,  0.371,  0.285 ),\n\tvec3(  0.246,  0.157,  0.141 ),\n\tvec3(  0.445,  0.227,  0.180 ),\n\tvec3(  0.844,  0.535,  0.437 ),\n\tvec3(  0.871,  0.512,  0.402 ),\n\tvec3(  0.715,  0.426,  0.328 ),\n\tvec3(  0.475,  0.316,  0.266 ),\n\tvec3(  0.941,  0.703,  0.633 ),\n\tvec3(  0.455,  0.230,  0.189 ),\n\tvec3(  0.338,  0.186,  0.146 ),\n\tvec3(  0.613,  0.434,  0.418 ),\n\tvec3(  0.926,  0.563,  0.445 ),\n\tvec3(  0.898,  0.543,  0.426 ),\n\tvec3(  0.275,  0.158,  0.137 ),\n\tvec3(  0.285,  0.156,  0.115 ),\n\tvec3(  0.396,  0.213,  0.168 ),\n\tvec3(  0.980,  0.703,  0.527 ),\n\tvec3(  0.723,  0.453,  0.359 ),\n\tvec3(  0.805,  0.602,  0.551 ),\n\tvec3(  0.801,  0.492,  0.379 ),\n\tvec3(  0.824,  0.508,  0.402 ),\n\tvec3(  0.324,  0.184,  0.164 ),\n\tvec3(  0.738,  0.406,  0.309 ),\n\tvec3(  0.303,  0.184,  0.158 ),\n\tvec3(  0.535,  0.320,  0.250 ),\n\tvec3(  1.008,  0.656,  0.531 ),\n\tvec3(  0.832,  0.516,  0.402 ),\n\tvec3(  0.777,  0.477,  0.387 ),\n\tvec3(  0.475,  0.238,  0.199 ),\n\tvec3(  0.703,  0.457,  0.402 ),\n\tvec3(  0.432,  0.258,  0.209 ),\n\tvec3(  0.336,  0.213,  0.172 ),\n\tvec3(  0.832,  0.520,  0.410 ),\n\tvec3(  0.484,  0.313,  0.232 ) ); \n\n\n// Given the ray direction dir, return color.\nvec3 getColor(vec3 dir) {\n    \n    float dist = sphere( dir, obj_pos, obj_size );    \n    \n    if(dist > 0.0) {\n                        \n    \tvec3 point = dir * dist;\n        \n        // Normal\n    \tvec3 N = normalize(point - obj_pos);  // Normal\n        vec3 V = normalize( -dir );           // View vector        \n\n        vec3 specular_color = vec3( 0., 0., 0. );\n        vec3 diffuse_refl = vec3( 1., 1., 0.5);\n        \n        float k_spec = 0.4;\n        float k_diff = 0.2;\n        float spec_alpha = 30.;\n        \n        vec3 diffuse_color  = vec3( 0., 0., 0. );\n        for( int l = 0; l < NO_LIGHTS; l++ ) {\n\t        vec3 L = normalize(light_pos[l]);\n\t        vec3 Lr = reflect(L, N);\n\t        float NdotL = clamp(dot(L,  N), 0.0, 1.0);\n            \n\t        specular_color += k_spec * light_rgb[l] * vec3( 1., 1., 1. ) * pow( max( dot(Lr, V), 0.), spec_alpha );\n\t        diffuse_color  += k_diff * light_rgb[l] * diffuse_refl * NdotL;\n        }        \n        \n        float exposure = 0.2;\n        vec3 final_color = toneMap( diffuse_color + specular_color, exposure );\n        \n\t\treturn final_color;\n\n    } else {      \n        \n        return texture(iChannel0, dir).xyz;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 dir = normalize(vec3(uv.xy,-1.0));\n   \n    // rotation\n    float c = cos(iTime / 10.0);\n    float s = sin(iTime / 10.0);\n    \n    dir.xz = vec2(dir.x * c - dir.z * s, dir.x * s + dir.z * c);\n    obj_pos.xz = vec2(obj_pos.x * c - obj_pos.z * s, obj_pos.x * s + obj_pos.z * c);\n    \n    // color\n\tfragColor = vec4(getColor(dir),1.0);\n}\n","name":"Image","description":"","type":"image"}]}