{"ver":"0.1","info":{"id":"7tV3z1","date":"1637199007","viewed":150,"name":"Transition playground","username":"Golui","description":"Playground for a transition animation.\n\nPlease let me know what this pattern is called.\n\nIt's called halftone. Apparently I can't even read.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["transition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n//#define SINGLE_SHOT\n\nconst vec4 color1 = vec4(136.0, 199.0, 220.0, 255.0) / 255.;\nconst vec4 color2 = vec4(199.0, 220.0, 136.0, 255.0) / 255.;\nconst vec4 color3 = vec4(220.0, 136.0, 199.0, 255.0) / 255.;\nconst vec4 color4 = vec4(199.0, 136.0, 220.0, 255.0) / 255.;\nconst vec4 color5 = vec4(220.0, 199.0, 136.0, 255.0) / 255.;\nconst vec4 color6 = vec4(136.0, 220.0, 199.0, 255.0) / 255.;\nconst vec4 color7 = vec4(236.0, 120.0, 109.0, 255.0) / 255.;\nconst vec4 color8 = vec4(120.0, 109.0, 236.0, 255.0) / 255.;\n\n\nconst float delta = 0.8;\nconst float e = exp(1.0);\n\nstruct ColorFun\n{\n    vec4 color;\n    vec2 fun;\n};\n\n// Some trial functions to generate the checkerboard.\n\nvec2 squareWave(vec2 x)\n{\n    return (1.0/atan(1.0/delta))*atan(sin(x)/delta);\n}\n\n// This one seems the most pleasing\nvec2 doubleSine(vec2 x)\n{\n    return sin(sin(x)) / sin(1.0);\n}\n\nvec2 polynomialWave(vec2 x, float powerOverTwo)\n{\n    vec2 z = fract(abs(x / PI));\n    vec2 periodize = sign(fract(abs(x) / (2.0 * PI)) - 0.5) * sign(x);\n    vec2 zPow = pow((z - 0.5) * (z - 0.5), vec2(powerOverTwo));\n    vec2 singleWave = pow(2.0, powerOverTwo * 2.0) * zPow - 1.0;\n    return singleWave * periodize;\n}\n\nvec2 expWave(vec2 x)\n{\n    return 1.0 - 2.0*(exp(sin(x) - 1.0 / e)) / (e - 1.0 / e);\n}\n\nvec2 expWave2(vec2 x)\n{\n    return 1.0 - 2.0*(exp(sin(sin(x)) / sin(1.0) - 1.0 / e)) / (e - 1.0 / e);\n}\n\nColorFun resolveSection(vec2 uv)\n{\n    vec2 arg = uv * 128.0;\n    int num = int(fract(uv.x) * 8.0);\n    vec2 adjArg = vec2(2.0 * arg.x - 0.5 * arg.y, -0.5 * arg.x - 2.0 * arg.y);\n    vec2 val = vec2(0.0);\n    vec4 color;\n    vec2 fun;\n    switch(num)\n    {\n        case 0: return ColorFun(color1, sin(adjArg));\n        case 1: return ColorFun(color2, doubleSine(adjArg));\n        case 2: return ColorFun(color3, squareWave(adjArg));\n        case 3: return ColorFun(color4, polynomialWave(adjArg, 1.0));\n        case 4: return ColorFun(color5, polynomialWave(adjArg, 2.0));\n        case 5: return ColorFun(color6, polynomialWave(adjArg, 3.0));\n        case 6: return ColorFun(color7, expWave(adjArg));\n        case 7: return ColorFun(color8, expWave2(adjArg));\n    }\n}\n\n\nfloat createBandMask(float x, float blurRadius, float width, float base)\n{\n    width -= 2. * blurRadius;\n    return smoothstep(0.0, blurRadius, abs(x - base - width / 2. - blurRadius) - width / 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float adjTime = iTime + 0.3;\n#ifdef SINGLE_SHOT\n    adjTime = min(5.0, adjTime);\n#endif\n\n    vec2 uv = fragCoord / iResolution.x;\n\n    float streakAngle = (-1.0 / 3.0 * uv.x - 3.0 * uv.y) / 6.0; // As with the checkerboard, we want the wave at an angle, but a different one.\n    float animProgress = streakAngle + 0.10 * adjTime; // Let's animate it\n    animProgress = fract(animProgress);\n    ColorFun cf = resolveSection(uv);\n    // Get the checkerboard.\n    float mask = (cf.fun.x + cf.fun.y) / 4.0 - 0.5;\n    // Now, we will offset the checkerboard with a smoothed line.\n    // This will create the effect of the checkerboard dots appearing\n    // On the wavefront.\n    // Scaling was used so that when there is no wave, the whole checkerboard is < 0, and behind the front it's > 1\n    float shiftVal = 2.0 * (1.0 - createBandMask(animProgress, 0.21, 0.75, 0.0));\n    float alpha = mask + shiftVal;\n    // https://github.com/glslify/glsl-aastep\n    float aawidth = length(vec2(dFdx(alpha), dFdy(alpha))) / sqrt(2.0);\n    alpha = smoothstep(0.5 - aawidth, 0.5 + aawidth, alpha);\n    float result = clamp(alpha, 0.0, 1.0);\n    fragColor = cf.color * result + cf.color * (1.0 - result) * 0.5;\n}","name":"Image","description":"","type":"image"}]}