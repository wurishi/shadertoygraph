{"ver":"0.1","info":{"id":"mtdGWB","date":"1683197824","viewed":56,"name":"Dithering third part","username":"PandaManda","description":"Dithering with light step","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//THIS PROGRAM IS FROM A POST MADE BY ALEX CHARLTON IMPLEMENTED IN SHADERTOY http://alex-charlton.com/posts/Dithering_on_the_GPU/\n\n// IGNORE THIS (THIS FUNCTIONS COME INTEGRATED WITH OPENGL BUT NOT HERE THAT IS WHY I WROTE THEM HERE; YOU CAN IGNORE THEM)\n// ____________________________________________________________________________________________________________________________\n\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n//      clamp(v,0.,1.)\n#endif\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\nvec3 rgbToHsl(vec3 c){\n\tfloat cMin=min(min(c.r,c.g),c.b),\n\t      cMax=max(max(c.r,c.g),c.b),\n\t      delta=cMax-cMin;\n\tvec3 hsl=vec3(0.,0.,(cMax+cMin)/2.);\n\tif(delta!=0.0){ //If it has chroma and isn't gray.\n\t\tif(hsl.z<.5){\n\t\t\thsl.y=delta/(cMax+cMin); //Saturation.\n\t\t}else{\n\t\t\thsl.y=delta/(2.-cMax-cMin); //Saturation.\n\t\t}\n\t\tfloat deltaR=(((cMax-c.r)/6.)+(delta/2.))/delta,\n\t\t      deltaG=(((cMax-c.g)/6.)+(delta/2.))/delta,\n\t\t      deltaB=(((cMax-c.b)/6.)+(delta/2.))/delta;\n\t\t//Hue.\n\t\tif(c.r==cMax){\n\t\t\thsl.x=deltaB-deltaG;\n\t\t}else if(c.g==cMax){\n\t\t\thsl.x=(1./3.)+deltaR-deltaB;\n\t\t}else{ //if(c.b==cMax){\n\t\t\thsl.x=(2./3.)+deltaG-deltaR;\n\t\t}\n\t\thsl.x=fract(hsl.x);\n\t}\n\treturn hsl;\n}\n\n\nvec3 hslToRgb(vec3 hsl){\n\tif(hsl.y==0.){\n\t\treturn vec3(hsl.z); //Luminance.\n\t}else{\n\t\tfloat b;\n\t\tif(hsl.z<.5){\n\t\t\tb=hsl.z*(1.+hsl.y);\n\t\t}else{\n\t\t\tb=hsl.z+hsl.y-hsl.y*hsl.z;\n\t\t}\n\t\tfloat a=2.*hsl.z-b;\n\t\treturn a+hue2rgb(hsl.x)*(b-a);\n\t\t/*vec3(\n\t\t\thueRamp(a,b,hsl.x+(1./3.)),\n\t\t\thueRamp(a,b,hsl.x),\n\t\t\thueRamp(a,b,hsl.x-(1./3.))\n\t\t);*/\n\t}\n}\n\n//___________________________________________________________________________________________________________________\n\n//Code starts here\nvec2 frag_Coord;\n\n//in HSL\nvec3 palette[8];\n\nint paletteSize = 8;\n\n\n\n//The indexMatrix8x8 is an 8x8 matrix (a 2-dimensional array) containing integers that are used to index into the matrix to retrieve a value\n\nconst int indexMatrix8x8[64] = int[](0,  32, 8,  40, 2,  34, 10, 42,\n                                     48, 16, 56, 24, 50, 18, 58, 26,\n                                     12, 44, 4,  36, 14, 46, 6,  38,\n                                     60, 28, 52, 20, 62, 30, 54, 22,\n                                     3,  35, 11, 43, 1,  33, 9,  41,\n                                     51, 19, 59, 27, 49, 17, 57, 25,\n                                     15, 47, 7,  39, 13, 45, 5,  37,\n                                     63, 31, 55, 23, 61, 29, 53, 21);\n\n\n//The indexValue function is defined to return a floating-point value obtained by calculating the index into the indexMatrix8x8 array based on the frag_Coord input variable, which is a 2D coordinate representing the position of the current fragment being rendered\n//This function uses values from the matrix to quantization error across neighboring pixels in order to reduce visible banding in the rendered image\n//The mod function is used to calculate the remainder of the division of the x and y components of frag_Coord by 8. This effectively maps the coordinates to the corresponding 8x8 tile in the matrix. The function then uses the calculated index to look up the corresponding value in the indexMatrix8x8 array and divides it by 64.0 to scale the value to the range [0, \nfloat indexValue() {\n    int x = int(mod(frag_Coord.x, 8.0));\n    int y = int(mod(frag_Coord.y, 8.0));\n    return float(indexMatrix8x8[(x + y * 8)]) / 64.0;\n}\n                                   \n\n\n//This function calculates the difference between two hues in the HSL color space\n//The input parameters h1 and h2 represent the hue values of two colors\n\n//First, it calculates the absolute difference between h1 and h2. It then checks if the difference is greater than 0.5, which indicates that the two colors are on opposite sides of the hue circle. If this is the case, it subtracts the difference from 1.0 to get the shortest distance between the two hues. Otherwise, it returns the absolute difference as is\n//The returned value is a float representing the hue distance between the two colors\nfloat hueDistance(float h1, float h2) {\n    float diff = abs((h1 - h2));\n    float minm = min((abs((1.0 - diff))), diff);\n    return minm;\n\n}\n\n\n//This function takes a hue value as input and returns an array of the two colors in the palette that are closest to the input hue. \n//It iterates over all the colors in the palette, calculates the hue distance between each color and the input hue using the hueDistance() function, and keeps track of the two closest colors\n//The function then returns an array containing these two colors.\nvec3[2] closestColors(float hue) {\n    vec3 ret[2];\n    vec3 closest = vec3(-2, 0, 0);\n    vec3 secondClosest = vec3(-2, 0, 0);\n    vec3 temp;\n    for (int i = 0; i < paletteSize; ++i) {\n        temp = palette[i];\n        float tempDistance = hueDistance(temp.x, hue);\n        if (tempDistance < hueDistance(closest.x, hue)) {\n            secondClosest = closest;\n            closest = temp;\n        } else {\n            if (tempDistance < hueDistance(secondClosest.x, hue)) {\n                secondClosest = temp;\n            }\n        }\n    }\n    ret[0] = closest;\n    ret[1] = secondClosest;\n    return ret;\n}\n\nconst float lightnessSteps = 4.0; // you can play around with this value\n\nfloat lightnessStep(float l) {\n    /* Quantize the lightness to one of `lightnessSteps` values */\n    return floor((0.5 + l * lightnessSteps)) / lightnessSteps;\n}\n\nvec3 dither(vec3 color) {\n    vec3 hsl = rgbToHsl(color); // converting color to hsl color space where is easy to work with\n\n    // function is called to determine the two nearest colors to the input hue value\n    vec3 cs[2] = closestColors(hsl.x); // we are going to make a list of 2 nearest colors which correspond to the color we want\n    vec3 c1 = cs[0];\n    vec3 c2 = cs[1];\n    \n    float d = indexValue(); // calling index value function\n    float hueDiff = hueDistance(hsl.x, c1.x) / hueDistance(c2.x, c1.x); // The difference in hue between the two closest colors is calculated, and is divided by the distance between the two colors to normalize the value between 0 and 1\n    \n    //The difference in lightness is also calculated, and is normalized to a value between 0 and 1\n    float l1 = lightnessStep(max((hsl.z - 0.125), 0.0));\n    float l2 = lightnessStep(min((hsl.z + 0.124), 1.0));\n    float lightnessDiff = (hsl.z - l1) / (l2 - l1);\n\n    //The result color is determined by comparing the normalized hue difference to the dithering value. If the hue difference is less than the dithering value, the first closest color is chosen; otherwise, the second closest color is chosen. \n    //Similarly, the lightness difference is compared to the dithering value to determine whether to use the first or second lightness step value\n    vec3 resultColor = (hueDiff < d) ? c1 : c2;\n    resultColor.z = (lightnessDiff < d) ? l1 : l2;\n    \n    return hslToRgb(resultColor); //When we return the color we need to convert it back to the rgb values\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n     //THIS IS THE MAIN FUNCTION WHICH IS CALLED AT THE START OF THE PROGRAM\n \n \n     //This whole program is called shader\n     //Shader is nothing more than a program that runs on gpu\n     //2 most known and used shaders you need to know are vertex shader and fragment shader(This program is fragment shader)\n     //Vertex shader is shader that handles the processing of individual vertices\n     //Fragment shader(the simplest way to think about it is this) a program that runs for every pixel,\n     //and it's purpose is to assign color to a pixel it's currently running for\n     \n     //this is glsl language for opengl shaders\n     //This shader is supposed to run in an OpenGL application, but that is a topic for itself (Opengl is a graphics programming specifcation which let you program on the graphics card (what a shocker))\n     \n     \n     \n    //Out fragColor is a color variable which we return at the end of the shader to assing pixel color\n\n    //Our pallete needs to be in hsl color space\n    palette[0] = rgbToHsl(vec3(0.0, 0.0, 0.0));\n    palette[1] = rgbToHsl(vec3(1.0, 1.0, 1.0)); // white\n    palette[2] = rgbToHsl(vec3(1.0, 0.0, 0.0)); // red\n    palette[3] = rgbToHsl(vec3(0.0, 1.0, 0.0)); // green\n    palette[4] = rgbToHsl(vec3(0.0, 0.0, 1.0)); // blue\n    palette[5] = rgbToHsl(vec3(1.0, 1.0, 0.0)); // yellow\n    palette[6] = rgbToHsl(vec3(1.0, 0.0, 1.0)); // magenta\n    palette[7] = rgbToHsl(vec3(0.0, 1.0, 1.0)); // cyan\n\n\n        //just assigning fragCoord to a global variable\n       \n    frag_Coord = fragCoord; // fragCoord return the coordinates of the pixel (fragment) on the screen\n    vec2 uv = fragCoord/iResolution.xy; //this normalizes screen position to -1 to 1\n    \n    vec4 fg = texture(iChannel0,uv); //We are getting pixel from the texture and saving it in vector of 4 (r g b and alpha)\n\n    \n\n    fragColor = vec4(vec3(dither(fg.rgb)),1.0); // This is where we assign our pixel color, here the results of these function inside a vec4 will correspon to a new rgb value\n\n}","name":"Image","description":"","type":"image"}]}