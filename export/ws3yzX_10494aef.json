{"ver":"0.1","info":{"id":"ws3yzX","date":"1601387313","viewed":232,"name":"Dem renderer with CA","username":"kastorp","description":"adapted from [url]https://www.shadertoy.com/view/3lyGRt[/url] \"DEM Renderer\"  by iapafoto\n\nhere a variation [url]https://www.shadertoy.com/view/WsdyDS[/url]\n","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["sphere","planet","ca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Fork of \"dem renderer\" by iapafoto https://www.shadertoy.com/view/3lyGRt\n\n// if defined, altitude is interpolated\n#define SMOOTH \n\n\n// Relief (low = big!) values : [2..20]\n#define H_COEFF 10.\n\n// With / Without water \n#define WITH_WATER\n\n#define WATER_OPACITY_COEFF 2.5\n#define WATER_OPACITY_INIT 1.5\n\n#define WITH_MOUSE_CONTROL \n\n#define WITH_SHADOWS\n#define WITH_AO  // Good with a lot of rays but need multi pass\n#define NB_AO  4 // Reduce if slow\n\n\n// -------------------------------\n// DO NOT CHANGE\n// -------------------------------\n\n\n#define PI 3.14159265359\n\n#define NO_ID 0\n#define GROUND_ID 1\n#define DEEP_ID 2\n\n#define NO_INTERSECTION 9999.\n\n#define COLOR_BACK vec3(.16,.18,.19)\n#define COLOR_WATER vec3(.3, .12, .08) \n \nconst float dd = .02;     // ray step \n\n// ------------------------------------------------------------------------------\n\nint intersectSphere(vec3 ro, vec3 rd, float r, out float t1, out float t2) {\n    float b = dot(ro,rd), d = b*b - dot(ro,ro) + r*r;\n    if (d <= 0.) return -1;\n    t1 = -b-sqrt(d);\n    t2 = -2.*b-t1;\n    return t1 > 0. ? 1 : t2 > 0. ? 2 : 0;\n}\n\n// -------------------------------------------------------------------\n\nfloat hash1( float seed) {\n    return fract(sin(seed)*43758.545312);\n}\n\nvec2 hash2( float seed) {\n    return fract(sin(vec2(seed*43758.545312,(seed+.1)*22578.145912)));\n}\n\nfloat hash( const in vec3 p ) {\n    return fract(sin(dot(p,vec3(127.1,311.7,758.5453123)))*43758.5453123);\n}\n\n    \n    \nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (iChannel2, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n\n// ------------------------------------------------------------------\n int  N = 120; \n\nvec2 coord(vec3 p){     \n\treturn mod((vec2(atan( -p.x ,p.z),atan(-p.y,p.z))*4./3.14159265 * float(N)/2. -float(N)/2.  ),float(N));\n}\n\nvec3 cube(in vec3 p)\n{\n    vec2 x = coord( sign(p.x)* p.yzx*vec3(1.,sign(p.x),1.));\n    vec2 y = coord( sign(p.y)* p.xzy*vec3(-1.,sign(p.y),1.));\n    vec2 z = coord( sign(p.z)* p.xyz*vec3(sign(p.z),1.,1.));\n    \n    vec3 pa = abs(p);\n    if (pa.x > pa.y && pa.x > pa.z) return vec3(x, p.x>0. ? 1.:3.);\n    if (pa.y > pa.x && pa.y > pa.z) return vec3(y, p.y>0. ? 6.:2.);\n    else return vec3(z, p.z>0. ? 4.:5.);\n}\n// ------------------------------------------------------------------\n\n\n\n\nfloat altitudeMeter(vec3 p) {\n\n    vec3 coords= cube(p);\n    vec2 f = fract(coords.xy-.5);\n    ivec3 C= ivec3(coords.xy-.5,coords.z);\n#ifdef SMOOTH    \n    ivec3 NU= NU_(C,N);\n    vec4 tex = A(encode(C,N)) ;\n    \n    //if(!isBorder(C,N)) \n    tex=  tex  *(1.- f.x) *(1.- f.y )\n    + A(encode(NR_(C,N),N)) *(f.x) *(1.- f.y )\n    + A(encode(NU,N))*(1.- f.x) *( f.y )\n    + A(encode(NR_(NU,N),N))*(f.x) *( f.y );\n#else   \n\tvec4 tex = A(encode(C,N)) ;\n#endif\n    return 30.*tex.x +  17.*tex.y -15.;\n   \n}\n\nfloat altitude(vec3 p) {\n    return H_COEFF*(length(p)-1.)-altitudeMeter(p)/100.;\n}\n\nvec3 normalAt( vec3 p) {\n    vec3 e = vec3 (.001, -.001, 0); \n    return normalize(e.xyy * altitude(p + e.xyy)\n                   + e.yyx * altitude(p + e.yyx)\n                   + e.yxy * altitude(p + e.yxy)\n                   + e.xxx * altitude(p + e.xxx));\n}\n\n// bisect\nfloat preciseSurfaceGround( vec3 ro,  vec3 rd, float dmin, float dmax) {\n    float dm = dmin;\n    vec3 p; \n    for (int j=0; j<6;j++) {\n        dm = (dmin + dmax)*.5;  \n        p = ro+rd*dm;\n        if (altitude(p) < 0.) dmax = dm;  \n        else dmin = dm;\n    }\n    return dm;  \n}\n\nvec2 rayGround(vec3 ro,  vec3 rd,  float dmin,  float dmax, out vec3 out_n, out float out_val) {\n    \n    float t1, t2;\n    // Test bounding sphere\n    int type = intersectSphere(ro, rd, .5/H_COEFF+1., t1, t2);\n    if (type > 0) {\n        dmin = max(dmin,t1);\n        dmax = min(dmax,t2);\n\n        // Go step by step until the ray traverse the ground\n        float d, h, rand = dd*hash1(dot(ro+rd*dmin,vec3(127.1,311.7,758.5453123)));\n        for(d = dmin+rand; d<dmax+dd; d += dd) {\n            h = altitude(ro+rd*d);\n            if (h <= 0.) break;\n        }\n\n        // Precise the true intersection point\n        if (d <= dmax) {\n            d = preciseSurfaceGround(ro, rd, max(dmin, d-dd), min(d,dmax));\n            out_n = normalAt(ro+rd*d);\t\t\t\t\n            out_val = altitude(ro+rd*d);\n            return vec2(d, GROUND_ID);\n        }\n    }\n\treturn vec2(NO_INTERSECTION, NO_ID);\n}\n\n\n#ifdef WITH_SHADOWS\nfloat doShadow( vec3 ro,  vec3 rd,  float dMax) {\n    vec3 n;\n    float val, dMin = dd*.1;\n    vec2 res = rayGround(ro, rd, dMin, dMax, n, val);\n    return res.x>dMin && res.x <= dMax ? 1. - clamp((dMax-res.x)/dMax,0.,1.) : 1.;\n}\n#endif\n\n\n#ifdef WITH_AO\nvec3 randomHemisphereDirection(vec3 n,  float seed) {\n    vec2 r = 2.*PI*hash2(seed);\n    vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n    float k = dot(dr,n);\n    return k == 0. ? n : normalize(k*dr);\n}\n\nfloat doAmbiantOcclusion( vec3 ro,  vec3 n, float dMax) {\n    float val, ao = 0., seed = ro.x+ro.y+.12345*ro.z;\n    vec3 n2, rd;\n    vec2 res;\n    for (int i=0;i<NB_AO; i++){\n        rd = randomHemisphereDirection(n, seed);    \n        seed += .1;\n        res = rayGround(ro, rd, .03*dd, 1., n2, val);\n        if (int(res.y) != NO_ID && res.x > 0. && res.x < dMax) {\n            ao += clamp((dMax-res.x)/dMax,0.,1.);\n        }\n    }\n    return (1.-ao/float(NB_AO));\n}\n#endif\n\n\n// -----------------------------------------------------------------\n\n// Shading\nvec3 doShading(int id, vec3 rd, vec3 p, vec3 n, vec3 light,  vec3 col) { \n    float diffuse = max(0., dot(n, light)),\n          rimMatch =  1. - max( 0. , dot( n , -rd ) );\n    vec3 rimCol  = vec3 (.4,.6,1.)*rimMatch;\n\n    float occ = 1.;\n#ifdef WITH_AO\n    occ = doAmbiantOcclusion(p+n*.001/*.01*rd*dd*/, n, .08);\n#endif\n     \n    vec3 hal = normalize( light-rd );\n\tfloat \n        amb = clamp( .5, 0., 1. ),\n     \tdif = clamp( dot( n, light ), 0., 1. ),\n     \tbac = clamp( dot( n,-light), 0., 1. ),\n     \tfre = pow( clamp(1.0+dot(n,rd),0.,1.), 2. );\n        \n#ifdef WITH_SHADOWS\n    if (dif >0.) {\n        dif *= (doShadow(p-.2*rd*dd, light, .6));  \n    }\n#endif\n\n\tvec3 lin = vec3 (0.);\n    lin += .7*dif*vec3 (1.,.8,.55);\n    lin += .4*amb*vec3 (.4,.6,1.)*occ;\n    lin += .5*bac*vec3 (.25)*occ;\n    lin += .25*fre*vec3 (1)*occ;\n\n    float spe = max(0., dot(light, reflect(rd, n)));\n    spe = dif*pow(spe,29.);;              \n\n\tvec3 c = col*lin;\n\tc += (id==GROUND_ID?.1f:.5f)*spe;\n    c+= .2f * rimCol * occ;\n\n    return pow(c,vec3(.55f)); \t   \n}\n\n\n// Camera\nvec3 RD( vec3 ro, vec3 ta, vec3 up, vec2 uv, vec2 res, float h) {\n    vec2 p = (2.*uv-res)/res.y;\n    vec3 \n        w = normalize(ta - ro),\n        u = normalize(cross(w, up)),\n        v = normalize(cross(u,w));\n    return normalize( p.x*u + p.y*v + h*w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n    \n     setN;  \n    \n    // Background\n\n    // Camera\n#ifdef WITH_MOUSE_CONTROL\n    vec4 qtVu = Loadv4(1);\n    mat3 vuMat = QToRMat(qtVu);\n    vec3 rd = normalize (vec3((2.*uv-iResolution.xy)/iResolution.y, 3.5)) * vuMat,\n    \t ro = vec3 (0., 0., -4.5) * vuMat;\n#else\n\tvec3 ro = 4.5*normalize(vec3(1., 0., 0.)),//.1*cos(.15*iTime))),\t\n         rd = RD(ro, vec3(0,0,.8), vec3(1,0,0), uv, iResolution.xy, 10.5);\n#endif\n    // Light\n    vec3 n,p, lightDir = normalize(ro+vec3(0,10,10));\n\n        \n        // background sky  \n\tfloat sun = max( dot(lightDir,rd), 0. );\n    vec2 q = uv/iResolution.xy;\n   // vec3 col = \n\n\tvec3 col = vec3( .7 * pow( sun, 10. ) )  \n         +    COLOR_BACK * pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.5f) + .05*hash(vec3(q,1.));\n\n    \n    // Find intersection\n\tfloat val, tmax = 5.f;\n    vec2 res = rayGround(ro, rd, 0., tmax, n, val);\n\n    // Shading\n    if (res.x > 0. && res.x < NO_INTERSECTION) {\n       \n        if (int(res.y) == GROUND_ID) {\n            p = ro + res.x*rd;\n\t\t\tfloat h = altitudeMeter(p);\n \n            col = mix(.2*vec3(.6,.5,.4), texture(iChannel1, vec2(h/50.,.5)).xyz, .7);\n            col *= .8 +.3*hash(p); // a little bit dirty\n            col = pow(col, vec3(.7));\n\t\t\t\n#ifdef WITH_WATER\n            vec3 colw = texture(iChannel1, vec2(0)).xyz; \n            colw = colw*.25 + .75*exp(-COLOR_WATER*(-h*.002)); \n            col = mix(colw,col, smoothstep(-0.1,0.1,h));\n#endif\n            col = doShading(int(res.y), rd, p, n, lightDir, col);\n        }\n    }\n    \n#ifdef WITH_WATER\n\t// Add water effect\n\tfloat dminSea, dmaxSea;\n    if (intersectSphere(ro, rd, 1., dminSea, dmaxSea)>0) {\n        if (dminSea <= res.x) {\n            p = ro+rd*dminSea;\n            float dist = min(res.x,dmaxSea) - dminSea;\n            col = col * exp(-COLOR_WATER*(WATER_OPACITY_INIT + 20.*WATER_OPACITY_COEFF*dist));\n            n = normalize(p);\n            float specular = max(0., dot(lightDir, reflect(rd, n)));\n            specular = pow(specular,29.);\n            col += .4*specular;\n        }\n    }\n#endif\n\n    fragColor = vec4(col, 1.);\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//original shader: //Cyclic cellular automaton by Zolozulman  https://www.shadertoy.com/view/4tV3Wd\n int  N = 120; \n\n//  angle cell are excluded from computation \n\nvec4 getNeibor(ivec2 n, vec2 U){\n    \n    //return A(U+vec2(n));\n    ivec3 C =decode(U,N);\n    if(n.x==1 && n.y==0) C=  NR_(decode(U,N),N);\n    if(n.x==-1  && n.y==0) C=  NL_(decode(U,N),N);\n    if(n.y==1 && n.x==0) C=  ND_(decode(U,N),N);\n    if(n.y==-1 && n.x==0) C=  NU_(decode(U,N),N);\n    if(n.x==1 && n.y==1) C=  NR_(ND_(decode(U,N),N),N);\n    if(n.x==-1 && n.y==1) C= NL_(ND_(decode(U,N),N),N);\n    if(n.x==1 && n.y==-1) C=  NR_(NU_(decode(U,N),N),N);\n    if(n.x==-1 && n.y==-1) C= NL_(NU_(decode(U,N),N),N);\n       \n    float f = isAngle(C,N)?0.:1.;\n    return  A(encode(C,N))*f;\n}\n\nvec4 getDominant(vec4 n){\n     vec4 o = vec4(0,0,0,1);\n     if(n.x > n.y && n.x > n.z){\n         o=vec4(1,0,0,1);\n     }else if(n.y > n.x && n.y > n.z){\n         o=vec4(0,1,0,1);\n     }else if(n.z > n.x && n.z > n.y){\n         o=vec4(0,0,1,1);\n     }else{\n         if(n.x == n.y){\n            if(n.x > n.z){\n                o=vec4(1,0,0,1);\n            }else{\n                o=vec4(0,0,1,1);\n            }\n        }else if(n.y == n.z){\n            if(n.y > n.x){\n                o=vec4(0,1,0,1);\n            }else{\n                o=vec4(1,0,0,1);\n            }\n        }else if(n.z == n.x){\n            if(n.z > n.y){\n                o=vec4(0,0,1,1);\n            }else{\n                o=vec4(0,1,0,1);\n            }\n        }else{\n            o = vec4(0,0,0,1);\n        }\n     }\n     return o;\n}\n\nvec4 neiborhood(vec2 fragCoord){\n   \n    vec4 o = vec4(0,0,0,1);\n    \n    for(int i = -1;i<2;i++){\n        for(int j = -1;j<2;j++){\n            if(i == 0 && j==0){\n                continue;\n            }\n            //o+=getDominant(getNeibor(ivec2(i,j),fragCoord));\n             o+=getDominant(getNeibor(ivec2(i,j),fragCoord)) *(i==0 || j==0?1.:2.);\n        }\n    }\n    \n   return o;\n}\n\nvec4 rule(vec2 fragCoord){\n    vec4 n = neiborhood(fragCoord);\n    vec4 md = getDominant(getNeibor(ivec2(0,0),fragCoord));\n\n    vec4 nd = md;\n    \n    if(md.x == 1.){\n        if(n.y>3.){\n            nd = vec4(0,1,0,1);\n        }\n    }\n    if(md.y == 1.){\n        if(n.z>3.){\n            nd = vec4(0,0,1,1);\n        }\n    }\n    if(md.z==1.){\n        if(n.x>3.){\n            nd = vec4(1,0,0,1);\n        }\n    }\n    \n    return nd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setN;\n    if(max(float(3*N+1)- fragCoord.x,float(2*N+1)-fragCoord.y)<1.) {fragColor.zw= TS.xy;return;}\n    if(fragCoord.x>float(N*3) || fragCoord.y >float(N*2)) discard;\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    if(iFrame < 15  || TS.x != A(vec2(3*N+1,2*N+1)).z){\n        fragColor = texture( iChannel1, uv);\n    }else{\n        fragColor = rule(fragCoord);// texture( iChannel1, uv)*.2 ;//random factor to avoid spiral formation\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define time iTime\n#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define TS vec2(textureSize(iChannel0,0))\n \n#define setN  N=min(int(iChannelResolution[0].x/6.),150) \n\n\nivec3 decode(vec2 Uf,int N){\n    ivec2 U =ivec2(Uf-.5 );\n   return (ivec3(\n       U.x % N, \n       U.y % N, \n       1+ (U.x/N)+3* (U.y/N)\n     ));\n   \n}\nivec2 encode(ivec3 C,int N){\n\n   return ivec2( \n       ((C.z-1) % 3) *N + (C.x%N), \n       ((C.z-1) / 3) *N + (C.y%N)\n   );\n  \n}\n//CROSS FACE NEIGHTBOURS (too much code...)\nivec3  NU_(ivec3 C,int N) { \n         if(C.y ==N-1 && C.z==1) return ivec3(0 ,N-1 -C.x,5);//90 rotation left \n    else if(C.y ==N-1 && C.z==2) return ivec3(C.x ,0,5); \n    else if(C.y ==N-1 && C.z==3 ) return ivec3(N-1 ,C.x,5); //90 rotation right \n    else if(C.y ==N-1 && C.z==4 ) return ivec3(C.x ,0.,2); \n    else if(C.y ==N-1 && C.z==5 ) return ivec3(N-1-C.x ,N-1,6); //180 rotation\n\telse if(C.y ==N-1 && C.z==6 ) return ivec3(N-1-C.x ,N-1,5); //180 rotation   \n    else return ivec3(C.x,C.y+1,C.z);    \n}\n                                                   \nivec3  ND_(ivec3 C,int N) {  \n         if(C.y ==0 && C.z==1 ) return ivec3(0 ,C.x,4); //90 rotation right \n    else if(C.y ==0 && C.z==2 ) return ivec3(C.x ,N-1,4); \n    else if(C.y ==0 && C.z==3 ) return ivec3(N-1 ,N-1 -C.x,4);//90 rotation left \n    else if(C.y ==0 && C.z==4 ) return ivec3(N-1-C.x ,0,6); //180 rotation \n    else if(C.y ==0 && C.z==5) return ivec3(C.x ,N-1,2); \n    else if(C.y ==0 && C.z==6 ) return ivec3(N-1-C.x ,0,4); //180 rotation \n    else/* if( C.y >0)*/ return ivec3(C.x,C.y-1,C.z);\n}\nivec3  NL_(ivec3 C,int N) {\n         if(C.x ==0 && C.z==1 ) return ivec3(N-1 ,C.y, 6); \n    else if(C.x ==0 && C.z==2) return ivec3(N-1, C.y ,1);\n    else if(C.x ==0 && C.z==3) return  ivec3(N-1, C.y ,2);\n    else if(C.x ==0 && C.z==4 ) return ivec3( C.y,0 ,1);//90 rotation left        \n    else if(C.x ==0 && C.z==5 ) return ivec3(N-1-C.y ,N-1,1); //90 rotation right       \n    else if(C.x ==0 &&  C.z==6 ) return ivec3(N-1 , C.y,3);     \n    else /*if( C.x >0)*/ return ivec3(C.x-1,C.y,C.z);\n}\nivec3  NR_(ivec3 C,int N) {       \n         if(C.x ==N-1  && C.z==1 ) return ivec3( 0, C.y ,2); \n    else if(C.x ==N-1  &&C.z==2) return ivec3( 0 ,C.y,3); \n    else if(C.x ==N-1  &&C.z==3 ) return ivec3( 0, C.y,6);  \n    else if(C.x ==N-1  &&C.z==4 ) return ivec3( N-1 - C.y, 0 ,3); //90 rotation right \n    else if(C.x ==N-1  &&C.z==5 ) return ivec3( C.y, N-1 ,3);//90 rotation left \n    else if(C.x ==N-1  && C.z==6 ) return ivec3(0, C.y,1); \n    else /*if( C.x <N-1 ) */ return ivec3(C.x+1,C.y,C.z); \n\n}\nbool isBorder(ivec3 C, int N){\n\treturn (C.y ==N-1)|| (C.x ==N-1) || (C.x ==0) || (C.y ==0);\n}\nbool isAngle(ivec3 C,int N){\n\treturn (C.y ==N-1 && C.x ==N-1) \n        || (C.y ==N-1 && C.x ==0 )\n        || (C.y ==0 && C.x ==N-1)\n        || (C.y ==0 && C.x ==0);\n}\n\nconst float txRow = 64.;\n\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Mouse control\n//----------------------------------------------\n\nconst float pi = 3.14159;\n\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (iChannel0, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     iChannelResolution[0].xy);\n}\n/*\nvec4 QtMul(vec4 q1, vec4 q2) {\n    return vec4(cross(q1.xyz,q2.xyz) + q1.w*q2.xyz + q2.w*q1.xyz, q1.w*q2.w - dot(q1.xyz,q2.xyz));\n}\n*/\n\nvec4 QMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n     q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n     q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n   - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n   - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\n\nvec4 EulToQ (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n\nvec4 qtVu;\n\n\nvec3 VInit (int n)\n{\n  float fn;\n  fn = float (n);\n  return 2. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3),\n     Hashff(fn + 0.6)) - 0.5);\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool init)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n    \n  if (! init) {\n    qtVu = vec4 (0., 0., 0., 1.);\n    mPtrP = vec4 (99.,0., -1., 0.);\n      \n  } else {\n      \n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize(QMul(vec4(cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else {\n        mPtrP = vec4 (99., 0., -1., 0.);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  float tCur;\n  int pxId = int(fragCoord.x);\n \n  if (pxId > 2) discard;\n    \n  tCur = 5.*(1.+.5*sin(.5*iTime))+2.*iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n    \n  qtVu = Loadv4 (1);\n  mPtrP = Loadv4 (2);\n  \n  if (iFrame < 10) {\n    OrientVu(qtVu, mPtr, mPtrP, false);\n   \n  } else {\n      \n    OrientVu (qtVu, mPtr, mPtrP, true);\n    stDat = Loadv4(0);\n    ++stDat.x;\n      \n    if (mPtrP.z < 0.) \n        qtVu = normalize(QMul (EulToQ (0.2 * (tCur - stDat.z) * pi * vec3 (-0.27, -0.34, -0.11)), qtVu));\n      \n    stDat.z = tCur;\n  }\n\n  if (pxId == 1) stDat = qtVu;\n  else if (pxId == 2) stDat = mPtrP;\n        \n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}