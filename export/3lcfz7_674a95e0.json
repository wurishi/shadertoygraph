{"ver":"0.1","info":{"id":"3lcfz7","date":"1612400398","viewed":74,"name":"2D Perlin and inverse Worley","username":"itsjonebone","description":"A 2D demonstration of perlin noise and inverse worley noise and their combination\nInspired by Andrew Schneider's chapter in GPU Pro 7\na much more refined version by piyushslayer is available here:\nhttps://www.shadertoy.com/view/3dVXDc","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cloud","perlin","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// image will be comprised of t x t tiles\nfloat t = 2.0; \n// noises start generation with freq x freq cells\nfloat freq = 4.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // create tiles\n    //uv *= t;\n    // add time animation\n    uv -= 0.05 * iTime;\n    uv = fract(uv);\n    \n    vec3 col = vec3(0.0);\n  /// => comment/uncomment the below lines to see the contribution of each\n    //col += worley(uv * freq, freq);\n    //col += worleyFBM(uv, freq);\n    //col = vec3(perlin(uv, freq));\n    //col = vec3(perlinFBM(uv, freq, 7));\n    //col = abs(col * 2. - 1.); // \"folding\" values down the middle\n    //col = vec3(perlin_worley(uv, freq));\n    \n    \n    if (fragCoord.x > iResolution.x / 2.) {\n        // remap here acts as a rudimentary \"cloud cover\" texture described by Schneider in GPU Pro 7\n        col = vec3(remap(cloud(uv, freq), 0.75, 1., 0., 1.));\n    } else {\n        col = vec3(cloud(uv, freq));\n    }\n    \n    \n    // Output color\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//// *** noisemaking in here *** ////\n\n/// point of interest generator\n// point of interest is a point we calculate distance to for worley noise\nvec2 poi_gen (vec2 gridIndex) {\n    // random val calculated based on gridindex and time\n    // ensures for the same grid index and time any calculated points are identical\n    // adding 1 to gridIndex prevents multiplying by 0 issues\n    return fract(sin(vec2(dot(gridIndex + 1.0, vec2(127.4, 723.8)), \n                dot(gridIndex + 1.0, vec2(837.7, 208.7)))) * 25787.33);\n}\n\n/// Inverse Worley Noise \nfloat worley(vec2 p, float freq) {\n    // assume p is normalized\n    // split p into id and position\n    vec2 id = floor(p);\n    vec2 pos = fract(p);\n    \n    float minDist = 100.0; // needs to be too big initially\n    for(int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 offset = vec2(x, y);\n            vec2 poi = poi_gen(mod(id + offset, vec2(freq))); // use mod for tiling\n            poi += offset;\n            vec2 diff = poi - pos;\n            minDist = min(minDist, length(diff));\n        }\n    }\n    return 1.0 - minDist; // inverting noise\n}\n\n/// Compound Worley Noise\n// uses the Worley FBM described by Schneider's chapter in GPU Pro 7\nfloat worleyFBM(vec2 p, float freq) {\n    return worley(p * freq, freq) * 0.625 +\n           worley(p * freq * 2., freq * 2.) * 0.25 +\n           worley(p * freq * 4., freq * 4.) * 0.125;\n}\n\n/// PERLIN\n// modified to tile from thebookofshaders.com\nfloat perlin(vec2 uv, float freq) {\n    vec2 p = uv * freq;\n    // split into ID and position\n    vec2 id = floor(p);\n    vec2 pos = fract(p);\n    \n    // tile corners\n    float a = poi_gen(id).x;\n    float b = poi_gen(mod(id + vec2(1., 0.), freq)).x;\n    float c = poi_gen(mod(id + vec2(0., 1.), freq)).x;\n    float d = poi_gen(mod(id + vec2(1., 1.), freq)).x;\n    \n    //smooth interpolation\n    vec2 u = smoothstep(0., 1., pos);\n    //u = pos * pos * (3. - 2. * pos);\n    \n    // mix 4 corners using position as percentage\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1. - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n\n/// Multi-octave perlin noise compounder\nfloat perlinFBM(vec2 p, float freq, int octaves) {\n    float noise = 0.;\n    float w = 0.5;\n    float c = 1.;\n    for (int i = 0; i < octaves; ++i) {\n        noise += w * perlin(p , freq * c);\n        c = c * 2.;\n        w *= 0.5;\n    }\n\n    return noise;\n}\n\n\n/// PerlinWorley\n// remapping as described by Schneider's chapter in GPU Pro 7\nfloat remap(float val, float old_min, float old_max, float new_min, float new_max) {\n    return new_min + (((val - old_min) / (old_max - old_min)) * (new_max - new_min));\n}\n\nfloat perlin_worley(vec2 uv, float freq) {\n    float w = worleyFBM(uv, freq);\n    float p = perlinFBM(uv, freq, 5);\n    p = abs(p * 2. - 1.);\n    return remap(p, 0., 1., w, 1.);\n}\n\n///cloud\nfloat cloud(vec2 uv, float freq) {\n    float pw = perlin_worley(uv, freq);\n    float wg = worleyFBM(uv, freq);\n    float wb = worleyFBM(uv, freq * 2.);\n    float wa = worleyFBM(uv, freq * 4.);\n    \n    float wfbm = wg * .625 + wb * .25 + wa * 0.125;\n    \n    return remap(pw, wfbm - 1., 1., 0., 1.);\n}\n\n\n\n","name":"Common","description":"","type":"common"}]}