{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\nvec3 l = normalize( vec3(1.0,1.0 ,-2.0) );\n\nfloat sdFloat(vec3 p, float s) {\n\treturn length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n        return length(max (abs(p) -b ,0.0) );\n}\n\nfloat lambert(vec3 n , vec3 l) {\n\treturn max(dot(n, l) , 0.0);\n}\nvec2 rot(vec2 r,float ang) {\n    return vec2(r.x* cos(ang) - r.y * sin(ang),  r.x*sin(ang) + r.y* cos(ang) ) ;\n}\nfloat obj(vec3 rp) {\nvec2 rotx =   rot(vec2(rp.x,rp.z) ,0.04*sin(iTime));\n\nvec3 trn = vec3(1.0,1.0,1.0);\n\nvec3 nrp1 = vec3(rotx.x ,rp.y , rotx.y + 5.0*iTime);\n\nvec3 nrp1_2 = nrp1+ vec3(0.5,0.5,0.0);\n\nvec3 nrp2= mod( nrp1_2,trn)-0.5*trn;\n\n\nfloat nrp3 = max(-sdFloat(nrp2,0.55), sdBox(nrp2, vec3(0.5,0.5 ,0.5 )  ) );\n\n\nreturn  nrp3;\n}\n\nvec3 est_normal(vec3 rp ) {\n\nconst float diff = 0.0001;\n\nvec3 x_p = vec3(diff ,0.0,0.0);\nvec3 x_m = vec3(-diff ,0.0,0.0);\n\nvec3 y_p = vec3(0.0,diff ,0.0);\nvec3 y_m = vec3(0.0,-diff ,0.0);\n\nvec3 z_p = vec3(0.0,0.0 ,diff);\nvec3 z_m = vec3(0.0,0.0,-diff);\n\n\nfloat x_diff = obj(rp+x_p) - obj(rp+x_m);\nfloat y_diff = obj(rp+y_p) - obj(rp+y_m);\nfloat z_diff = obj(rp+z_p) - obj(rp+z_m);\n\nreturn normalize(vec3(x_diff,y_diff,z_diff));\n\n}\n\n\nvec3 raymatch_iter2(vec3 ro , vec3 rd ) {\n\n        vec3 rp = ro;\n        float s = 0.0;\n        const int mstep = 20;\n        const float eps = 0.0001;\n        for (int i = 0; i < mstep ; i++) {\n\n                s = obj(rp);\n\n                rp = rp + rd*s;\n        }\n\n        vec3 n = est_normal(rp);\n        vec3 ret = vec3(0.0);\n\n        if (abs(s) < eps) {\n            ret = vec3(1.0)*lambert(n, l);\n         }\n\n        return ret;\n\n}\n\nvec3 raymatch(vec3 ro , vec3 rd ) {\n\n        vec3 rp = ro;\n        float s = 0.0;\n        const int mstep = 80;\n        const float eps = 0.0001;\n\tfor (int i = 0; i < mstep ; i++) {\n\n\t\n                s = obj(rp);\n\n                rp = rp + rd*s;\n                if (abs(s) < eps ) break;\n\t\n\t}\n\n        //vec3 n = normalize(vec3 (rp));\n\n        vec3 n = est_normal(rp);\n        vec3 ret = vec3(0.0);\n\n        if (abs(s) < eps) {\n            //ret = vec3(1.0)*lambert(n, l) ;//+0.6*raymatch_iter2(rp+vec3(0.1), normalize(-reflect((rp-ro),n)));\n        ret = 0.5+0.5*n;\n        }\n\n        return ret;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        vec2 uv = 2.0*(fragCoord.xy / iResolution.xy)-1.0;\n        /* projective*/\n        vec3 ro = vec3(0.0 , 0.0 , -5.0 );\n        /*ortogonal*/\n        //vec3 ro = vec3(uv.x , uv.y , -2.0 );\n\n        vec3 proj_plane = vec3 (uv.x , uv.y , -1.0 );\n\n\tvec3 rd = normalize( proj_plane - ro);\n\n\n\tvec3 res = raymatch(ro,rd);\n\n\tfragColor = vec4(res,1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsBSRz","date":"1408116249","viewed":179,"name":"N Tunel","username":"Wingrime","description":"Well, thats my first raymach shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymach"],"hasliked":0,"parentid":"","parentname":""}}