{"ver":"0.1","info":{"id":"cdSyD3","date":"1688228186","viewed":95,"name":"frame memory test","username":"boytoy","description":"hello, thank you for passing by","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvo = fragCoord/iResolution.xy;\n    vec2 uv  = uvo;\n    uv*=2.;uv-=1.;\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0,uvo));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvo = fragCoord/iResolution.xy;\n    const vec2 pixels = vec2(320.,240.);\n    \n    uvo = floor(pixels*uvo+0.5)/pixels; // normalized [0,1] x [0,1] uv coordinates\n    \n    vec2 uv  = uvo;  // [-1,1] x [-1,1] coordinates\n    uv*=2.;uv-=1.;   //\n    \n    uv*= (3.+uv)/length(uv+3.); // space distortion (i don't even know what is the shape lmao)\n    \n    \n    \n    float disp = fbm(0.5*uv-0.5*iTime); \n    float light_pattern = fbm(uv*10.+iTime+0.1*disp); // \"foreground stars\"\n    light_pattern = max(light_pattern,0.9*fbm(uv*20.+iTime)); // \"background stars\"\n    light_pattern = (light_pattern > 0.65)? 1. : 0.;\n    \n    vec4 pattern = vec4(vec3(light_pattern),1.);\n    \n    \n    // mix last frame with this one\n    vec4 color = texture(iChannel0,uvo);\n    \n    color *= pow(0.1, 1./iFrameRate); // decays value from last frame, generates trailing\n    color = max(color,pattern); // value ~~ whatever is the most bright (on each channel)\n\n    fragColor = color;\n    fragColor.gb = pattern.gb; // red trailing effect ;\n                             // note it is \"substractive\" coloring instead of additive.\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 random(vec2 uv){\n    uv = vec2( dot(uv, vec2(127.1,311.7) ),\n               dot(uv, vec2(269.5,183.3) ) );\n    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);\n}\n\nfloat noise(vec2 uv) {\n    vec2 uv_index = floor(uv);\n    vec2 uv_fract = fract(uv);\n\n    vec2 blur = smoothstep(0.0, 1.0, uv_fract);\n\n    return mix( mix( dot( random(uv_index + vec2(0.0,0.0) ), uv_fract - vec2(0.0,0.0) ),\n                     dot( random(uv_index + vec2(1.0,0.0) ), uv_fract - vec2(1.0,0.0) ), blur.x),\n                mix( dot( random(uv_index + vec2(0.0,1.0) ), uv_fract - vec2(0.0,1.0) ),\n                     dot( random(uv_index + vec2(1.0,1.0) ), uv_fract - vec2(1.0,1.0) ), blur.x), blur.y) + 0.5;\n}\n\nfloat fbm(vec2 uv) {\n    int octaves = 7;\n    float amplitude = 0.5;\n    float frequency = 4.0;\n\tfloat value = 0.0;\n\t\n    for(int i = 0; i < octaves; i++) {\n        value += amplitude * noise(frequency * uv);\n        amplitude *= 0.4;\n        frequency *= 2.0;\n    }\n    return value;\n}","name":"Common","description":"","type":"common"}]}