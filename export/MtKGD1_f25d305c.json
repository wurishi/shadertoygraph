{"ver":"0.1","info":{"id":"MtKGD1","date":"1474526408","viewed":163,"name":"multiple reflections","username":"andrewww1","description":"A room with a sphere inside showing multiple reflections.\n\nSet REFLECT_NUM to change the number of reflections.\n\nMouse X position yaws, and mouse Y position sets zoom.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["reflections","multiple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define REFLECT_NUM 8\n\nbool intersectPlane(vec3 P,vec3 V,vec4 plane, out float t) {\n  //ax+by+cz+d=0\n\n  float d=plane.w;\n  vec3 N=plane.xyz;\n\n  float NPd=dot(N,P)+d;\n\n  //origin below or on plane\n  if(NPd <= 0.0) {\n    t=0.0;\n    return false;\n  }\n\n  //\n  float NV=dot(N,V);\n\n  //vector parallel or pointing away from plane\n  if(NV >= 0.0) {\n    t=0.0;\n    return false;\n  }\n\n  //\n  t=-NPd/NV;\n\n  //\n  return true;\n}\n\n\nbool intersectSphere(vec3 P,vec3 V,vec3 C,float r,out float t) {\n  vec3 M;\n  float b,d,c;\n\n  M=P-C;\n  c=dot(M,M)-r*r;\n\n  if(c<0.0) {\n    return false;\n  }\n\n  b=dot(V,M);\n\n  if(b > 0.0) {\n    return false;\n  }\n\n  d=b*b-c;\n\n  if(d < 0.0) {\n    return false;\n  }\n\n  t=-b-sqrt(d);\n  return true;\n}\n\nbool intersectWall(vec3 ro, vec3 rd, out vec3 ptOut, out vec3 norOut, out vec3 colOut) {\n  vec3 nor;\n  float scale=10.0;\n  float t;\n  \n  //wall x\n  if(intersectPlane(ro,rd,vec4(nor=vec3(1.0,0.0,0.0),scale),t) ||\n     intersectPlane(ro,rd,vec4(nor=vec3(-1.0,0.0,0.0),scale),t)) {\n    vec3 pt=ro+rd*t;\n\n    if(pt.z>=-scale&&pt.z<=scale&&pt.y>=-scale&&pt.y<=scale){\n      ptOut=pt;\n      norOut=nor;\n      colOut=nor*0.5+0.5;\n      return true;\n    }\n  }\n\n  //wall y\n  if(intersectPlane(ro,rd,vec4(nor=vec3(0.0,1.0,0.0),scale),t) ||\n     intersectPlane(ro,rd,vec4(nor=vec3(0.0,-1.0,0.0),scale),t)) {\n    vec3 pt=ro+rd*t;\n\n    if(pt.z>=-scale&&pt.z<=scale&&pt.x>=-scale&&pt.x<=scale){\n      ptOut=pt;\n      norOut=nor;\n      colOut=nor*0.5+0.5;\n      return true;\n    }\n  }\n\n  //wall z\n  if(intersectPlane(ro,rd,vec4(nor=vec3(0.0,0.0,1.0),scale),t) ||\n     intersectPlane(ro,rd,vec4(nor=vec3(0.0,0.0,-1.0),scale),t)) {\n    vec3 pt=ro+rd*t;\n\n    if(pt.x>=-scale&&pt.x<=scale&&pt.y>=-scale&&pt.y<=scale){\n      ptOut=pt;\n      norOut=nor;\n      colOut=nor*0.5+0.5;\n      return true;\n    }\n  }\n  \n  return false;\n}\n\nbool intersectScene(vec3 ro, vec3 rd, out vec3 ptOut, out vec3 norOut, out vec3 colOut) {\n  //spheres\n  if(true) {\n    float t,tt;\n    bool found=false;\n    vec3 c;\n  \n    //sphere 1\n    c=vec3(0.0,0.0,0.0);\n  \n    if(intersectSphere(ro,rd,c,2.0,tt) && (!found || tt<t)) {\n      found=true;\n      t=tt;\n    \n      vec3 pt=ro+rd*t;\n      ptOut=pt;\n      norOut=normalize(pt-c);\n      colOut=vec3(1.0);\n    }\n\n    //sphere 2\n    if(false) {\n\t  c=vec3(6.0,0.0,0.0);\n  \n      if(intersectSphere(ro,rd,c,2.0,tt) && (!found || tt<t)) {\n        found=true;\n        t=tt;\n    \n        vec3 pt=ro+rd*t;\n        ptOut=pt;\n        norOut=normalize(pt-c);\n        colOut=vec3(1.0);\n      }\n\t}\n  \n    if(found) {\n      return true;\n    }\n  }\n  \n  if(intersectWall(ro,rd,ptOut,norOut,colOut)) {\n    return true;\n  }\n\n  colOut=vec3(0.0);\n  return false;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 pt,nor;\n  vec3 col=vec3(0.0,0.0,0.0);\n\n  if(intersectScene(ro,rd,pt,nor,col)) {\n    vec3 col2;\n    vec3 rd2=rd;\n    float d=1.0;\n    for(int i=0;i<REFLECT_NUM;i++) {\n      rd2=normalize(reflect(rd2,nor));\n          \n      if(!intersectScene(pt,rd2,pt,nor,col2)) {\n        break;\n      }\n          \n      col=mix(col,col2,0.5*d);\n      //d*=0.9;      \n    }\n  }\n  \n  return vec3(clamp(col,0.0,1.0));\n}\n\nvec3 calcPrimaryRay(vec2 screen,float fovy,float aspect) {\n  float d=1.0/tan(fovy/2.0);\n  vec3 v=vec3(screen.x*aspect,screen.y,-d);\n  v=normalize(v);\n  return v;\n}\n\nmat3 orbitViewRot(float yaw,float pitch) {\n    vec2 s=vec2(sin(pitch),sin(yaw));\n    vec2 c=vec2(cos(pitch),cos(yaw));\n    return mat3(c.y,0.0,-s.y,s.y*s.x,c.x,c.y*s.x,s.y*c.x,-s.x,c.y*c.x); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 scr = uv*2.0-1.0;\n    vec2 ms = iMouse.xy / iResolution.xy;\n    vec2 ms2=(ms.x==0.0 && ms.y==0.0)?vec2(0.5,0.5):ms;\n    float aspect=iResolution.x/iResolution.y;\n    float fovy=0.7854;\n\n    float pitch=0.0;//(ms2.y-0.5);\n    float yaw=(iMouse.z<=0.0)?iTime*0.25:(ms2.x-0.5)*10.0;\n    \n    mat3 viewRot=orbitViewRot(yaw,pitch);\n    \n    float d=(iMouse.z<=0.0)?-0.5:(ms2.y-0.5);\n    \n    vec3 ro=viewRot*vec3(0.0,0.0,d*30.0+18.0);\n    vec3 rd=normalize(viewRot*calcPrimaryRay(scr,fovy,aspect));\n    vec3 col=render(ro,rd);\n\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}