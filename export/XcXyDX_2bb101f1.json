{"ver":"0.1","info":{"id":"XcXyDX","date":"1721664816","viewed":144,"name":"BRDF without H vector","username":"spalmer","description":"A simple BRDF lighting sample showing how one may eliminate the need for the H vector","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["brdf","pbr","torrance","noh","trowbridge","reitz"],"hasliked":0,"parentid":"Ns2yDD","parentname":"approximate_dof"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A very simple sample of BRDF forked from\n// http://shadertoy.com/view/Ns2yDD by shinraigo\n// DoF and focus completely redone\n\n    // the entire point of this toy is to demonstrate this tidbit:\n#define NO_HALF_VECTOR\n    // you should not notice any visual difference either way.\n    // I discovered this a few days ago, with Maxima's assistance.\n    // All it really eliminates is a sqrt  (or does it actually?)\n    // deep in the BSDF calculations,\n    // and maybe a dot depending whether you needed vl anyway;\n    // some precalculate that stuff, negating most benefits.\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 dir; // of this pixel\n    mat3 view;\n};\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n    float len;\n    int hitId;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nstruct Material\n{\n    vec2 uv;\n    vec3 normal;\n    vec3 baseColor;\n    float roughness;\n    float metallic;\n    bool isFar;\n};\n\nstruct Lit\n{\n    vec3 direct;\n    vec3 indirect;\n};\n\nstruct ShadingDots\n{\n    float nh; // NdotH \n    float vh; // VdotH \n    float nv; // NdotV \n    float nl; // NdotL \n};\n    //float lh; // LdotH  // just use VdotH, same\n\n\nconst float GroundHeight = -1.;\nSphere spheres[4] = Sphere[] (\n    Sphere(vec3(0, 0, 0), 1.),\n    Sphere(vec3(0, 0, 3), 1.),\n    Sphere(vec3(0, 0, 6), 1.),\n    Sphere(vec3(0, 0, 9), 1.)\n    );\n\n\n\n// Reinhard tonemap (poor toe, sorry)\nfloat tonemap(float x)\n{\n    return x / (x + .6);\n}\nfloat untonemap(float x)\n{\n    x *= 5.;\n    x /= (x + 3.);\n    return x;\n}\nvec3 tonemap(vec3 c)\n{\n    return vec3(tonemap(c.r), tonemap(c.g), tonemap(c.b));\n}\nvec3 untonemap(vec3 c)\n{\n    return vec3(untonemap(c.r), untonemap(c.g), untonemap(c.b));\n}\n\nbool IsRayHitSphere(Sphere sphere, Ray ray)\n{\n    vec3 toCenterDir = sphere.center - ray.org;\n    float dToCenterSq = dot(toCenterDir, toCenterDir);\n    float c = dot(toCenterDir, ray.dir);\n    if (c < 0.)\n        return false;\n    float perpendicularSq = dToCenterSq - c * c;\n    return perpendicularSq <= sphere.radius * sphere.radius;\n}\n\nfloat GetRayDistanceToSphere(Sphere sphere, Ray ray)\n{\n    vec3 toCenterDir = sphere.center - ray.org;\n    float dToCenterSq = dot(toCenterDir, toCenterDir);\n    float c = dot(toCenterDir, ray.dir);\n    float perpendicularSq = dToCenterSq - c * c;\n    return sqrt(dToCenterSq - perpendicularSq) - sqrt(sphere.radius * sphere.radius - perpendicularSq);\n}\n\nfloat GetPerpendicularSqToSphere(Sphere sphere, Ray ray)\n{\n    vec3 toCenterDir = sphere.center - ray.org;\n    float dToCenterSq = dot(toCenterDir, toCenterDir);\n    float c = dot(toCenterDir, ray.dir);\n    return dToCenterSq - c * c;\n}\n\nbool IsRayHitPlane(float height, Ray ray)\n{\n    float c = -ray.dir.y;\n    return c > .04; // nonzero makes more of a round table\n}\n\nfloat GetRayDistanceToPlane(float height, Ray ray)\n{\n    float c = -ray.dir.y;\n    return (ray.org.y - height) / max(c, 1e-8);\n}\n\nvec3 FresnelSchlick(vec3 f0Color, float vh)\n{\n    return f0Color + (1. - f0Color) * pow(1. - vh, 5.);\n}\n\n// http://seblagarde.wordpress.com/2011/08/17/hello-world/\nvec3 FresnelSchlickRoughness(float c, vec3 f0Color, float roughness)\n{\n    // attention!!\n    return f0Color + (max(vec3(1. - roughness), f0Color) - f0Color) * pow(1. - c, 5.);\n}  \n\nvec3 FresnelLerp(vec3 f0Color, vec3 albedo, float nv)\n{\n    return mix(f0Color, albedo, pow(1. - nv, 5.));\n}\n\n\nfloat sqr(float x) \n{\n    return x * x;\n}\n\n\nconst float pi = radians(180.);\n\nfloat G1_schlick(float c, float k)\n{\n\treturn c / (c * (1. - k) + k);\n}\n\n// filmicworlds idea\nfloat GeometryHable(float alpha, float vh)\n{\n\treturn pow(G1_schlick(vh, .5 * alpha), 2.);\n}\n\nfloat GeometrySmithGGXCorrelated(float alpha, float nl, float nv)\n{\n    float alphaSq = alpha * alpha;\n    float NdotLSq = nl * nl;\n    float NdotVSq = nv * nv;\n    float GGXV = nl * sqrt(nv * (1. - alphaSq) * nv + alphaSq); // at least refactor this!\n    float GGXL = nv * sqrt(nl * (1. - alphaSq) * nl + alphaSq);    \n    return .5 / (GGXV + GGXL);    \n}\n\nfloat DistributionTrowbridgeReitz(float alpha, float nh)\n{\n    float a2 = alpha * alpha;\n    float t = (nh * a2 - nh) * nh + 1.;\n    return a2 / (pi * t * t);\n}\n\nvec3 SpecularBRDF(vec3 f0Color, float roughness, ShadingDots dots)\n{\n    float alpha = max(roughness * roughness, 1e-3), D, G;\n    D = DistributionTrowbridgeReitz(alpha, dots.nh);\n    // real hard to see G term variability in this toy, hardly any geo or normals\n    //G = GeometrySmithGGXCorrelated(alpha, dots.nl, dots.nv);\n    G = GeometryHable(alpha, dots.vh);\n    //G /= max(4. * dots.nl * dots.nv, 1e-5); // forked vis term breaks\n    // oh apparently vis term is supposed to be this anyway:\n    G /= sqr(2. * dots.vh);\n    //G = .25; // HACK good 'nuff - really dims my highlights though, must not be scaled correctly\n    vec3 F = FresnelSchlick(f0Color, dots.vh);  // TODO need conductor variant\n    return D * G * F;\n}\n\n\nvec3 LambertDiffuse(vec3 baseColor, float nl)\n{\n    return nl / pi * baseColor;\n}\n\n\nvoid DetectRayHitResult(inout Ray ray)\n{\n    for (int i = spheres.length(); i-- > 0; ) {\n        Sphere obj = spheres[i];\n        if (IsRayHitSphere(obj, ray)) {\n            float d = GetRayDistanceToSphere(obj, ray);\n            if (d < ray.len) {\n                ray.len = d;\n                ray.hitId = 1+i;\n            }\n        }\n    }\n    if (IsRayHitPlane(GroundHeight, ray)) {\n        float d = GetRayDistanceToPlane(GroundHeight, ray);\n        if (d < ray.len) {\n            ray.len = d;\n            ray.hitId = 0;\n        }\n    }\n}\n\n\nMaterial CalcMaterialForSphere(vec3 pos, Sphere obj)\n{\n    vec3 d = normalize(obj.center - pos);\n    Material m;\n    m.uv.y = 1. - fract(.5 + (atan(d.x, d.z) / pi));\n    m.uv.x = 1. - fract(.5 - (asin(d.y) / pi));\n    m.normal = -d;\n    vec4 baseColor = texture(iChannel1, m.uv);\n    baseColor.rgb *= baseColor.rgb; // sRGB->linear\n    m.roughness = baseColor.r; //fract(2. * m.baseColor.r * m.baseColor.g + .5);\n    m.baseColor = baseColor.rgb;\n    m.metallic = 0.;\n    m.normal.y += m.roughness * (fract(2. * baseColor.r) - .5);\n    m.normal = normalize(m.normal);\n    return m;\n}\n\nMaterial CalcMaterialForPlane(vec3 pos)\n{\n    Material m;\n    m.normal = vec3(0, 1, 0);\n    m.uv = vec2(fract(pos.x * .2), fract(pos.z * .2));\n    vec4 baseColor = texture(iChannel0, 2. * m.uv);\n    baseColor.rgb *= baseColor.rgb; // sRGB->linear\n    m.baseColor = baseColor.rgb;\n    m.roughness = .2; //m.baseColor.r;\n    m.metallic = 0.;\n    m.normal.xz += m.roughness * fract(2. * (baseColor.rg + baseColor.gb));\n    m.normal = normalize(m.normal);\n    return m;\n}\n\nMaterial GetMaterialResult(Ray ray)\n{\n    vec3 currPos = ray.len * ray.dir + ray.org;\n    Material m;\n    switch(ray.hitId) {\n        case 0:\n            m = CalcMaterialForPlane(currPos);\n            break;\n        case 1:\n            m = CalcMaterialForSphere(currPos, spheres[0]);\n            m.roughness = min(1., m.roughness * 1.2);\n            break;\n        case 2:\n            m = CalcMaterialForSphere(currPos, spheres[1]);\n            m.baseColor = vec3(.9, .6, .3) * mix(m.baseColor, vec3(1), .3);\n            m.metallic = 1.;\n            break;\n        case 3:\n            m = CalcMaterialForSphere(currPos, spheres[2]);\n            m.baseColor = vec3(.7, .5, .3) * mix(m.baseColor, vec3(1), .3);\n            m.roughness = mix(m.roughness, .9, .3);\n            break;\n        case 4:\n            m = CalcMaterialForSphere(currPos, spheres[3]);\n            m.baseColor = vec3(.7, .6, .5) * mix(m.baseColor, vec3(1), .3);\n            m.metallic = 1.;\n            m.roughness = mix(m.roughness, .9, .5);\n            break;\n        default:\n            m.isFar = true;\n            break;\n    }\n    return m;\n}\n\nfloat SoftShadow(Sphere sphere, Ray ray)\n{\n    // check perpendicular distance from ray to center of sphere hit\n    // to fake a soft edge for shadow\n    float perpendSq = GetPerpendicularSqToSphere(sphere, ray);\n    float edgeAspect = smoothstep(.2, 1., perpendSq / (sphere.radius * sphere.radius));\n    return edgeAspect;\n}\n\nvec3 GetDirectionalLightDirection(float t)\n{\n    t *= .1;\n    return normalize(vec3(cos(t) * .1, 1., sin(t) * .1));\n}\n\nvec3 GetDirectionalLightIntensity()\n{\n    // for natural result, use IBL color\n    vec3 ibl = textureLod(iChannel3, vec3(0, 1, 0), 2.).rgb;\n    ibl *= ibl; // sRGB->linear\n    ibl = untonemap(ibl);\n    return ibl;\n}\n\n\nfloat CalcShadow(vec3 pos, vec3 ldir)\n{\n    vec3 dirToLight = ldir;\n    Ray ray = Ray(pos, normalize(dirToLight), 8e4, -1); \n    float shadow = 1.;\n    // check if ray from pos to light will hit something\n    if (IsRayHitSphere(spheres[0], ray))\n        shadow *= SoftShadow(spheres[0], ray);        \n    if (IsRayHitSphere(spheres[1], ray))\n        shadow *= SoftShadow(spheres[1], ray);\n    if (IsRayHitSphere(spheres[2], ray))\n        shadow *= SoftShadow(spheres[2], ray);\n    if (IsRayHitSphere(spheres[3], ray))\n        shadow *= SoftShadow(spheres[3], ray);\n    return shadow;\n}\n\n\nfloat remap(float v, float oldMin, float oldMax, float newMin, float newMax)\n{\n    return (v - oldMin) / (oldMax - oldMin) * (newMax - newMin) + newMin;\n}\n\n\nfloat CalcAmbientOcclusion(Ray ray, Material mat) //, Camera cam)\n{\n    // one bounce along normal as a fake AO\n    vec3 pos = ray.len * ray.dir + ray.org;    \n    Ray rayNext = Ray(pos + .1 * mat.normal, mat.normal, 8e4, -1);\n    DetectRayHitResult(rayNext);\n    return clamp(remap(rayNext.len, 0., .9, .0, 1.), 0., 1.);\n}\n\n\nconst vec3 NonMetallicF0 = vec3(.04); // average dielectric IoR 1.5 Fresnel reflectance at 0 angle\n\n// Direct Lighting\nvec3 CalcDirectLight(Ray ray, Material mat, ShadingDots dots)\n{\n    vec3 f0 = mix(NonMetallicF0, mat.baseColor, mat.metallic);\n    vec3 diffuseColor = (1. - mat.metallic) * mat.baseColor;\n    vec3 dir = vec3(0);\n    dir += LambertDiffuse(diffuseColor, dots.nl);\n    dir += SpecularBRDF(f0, mat.roughness, dots);\n    dir *= GetDirectionalLightIntensity();\n    return dir;\n}\n\n\n// Indirect Lighting\nvec3 EnvSpecular(Material mat, Ray ray, ShadingDots dots)\n{\n    // http://unrealengine.com/en-US/blog/physically-based-shading-on-mobile\n    vec3 sampleDir = reflect(ray.dir, mat.normal);\n    float perceptualRoughness = mat.roughness * (1.7 - .7 * mat.roughness);\n    float Mip = perceptualRoughness * 6.; // 6Layer MIPMAP CUBEMAP\n\n    vec3 iblSpecular = textureLod(iChannel3, sampleDir, Mip).rgb;\n    iblSpecular = iblSpecular * iblSpecular; // sRGB -> linear\n    iblSpecular = untonemap(iblSpecular);\n    \n    vec3 f0Color = mix(NonMetallicF0, mat.baseColor, mat.metallic);\n    // what's going on here?  looks like HACKS to me\n\tvec4 c0 = vec4(-1, -.0275, -.572, .022);\n\tvec4 c1 = vec4(1, .0425, 1.04, -.04);\n\tvec4 r = mat.roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * dots.nv)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\treturn (f0Color * vec3(AB.x) + vec3(AB.y)) * iblSpecular;\n}\n\nvec3 EnvDiffuse(Material mat, Ray ray, ShadingDots dots)\n{\n    vec3 sampleDir = mat.normal; //reflect(ray.dir, mat.normal);\n    //float perceptualRoughness = mat.roughness * (1.7 - .7 * mat.roughness);\n    float Mip = 7.; //perceptualRoughness * 6.; //\n    vec3 iblDiffuse = textureLod(iChannel3, sampleDir, Mip).rgb;\n    iblDiffuse = iblDiffuse * iblDiffuse; // sRGB->linear\n    iblDiffuse = untonemap(iblDiffuse);\n    \n    vec3 f0Color = mix(NonMetallicF0, mat.baseColor, mat.metallic);\n    vec3 fresnelRoughness = FresnelSchlickRoughness(dots.nv, f0Color, mat.roughness);\n    vec3 OneMinusReflectivityFromMetallic = (1. - fresnelRoughness) * (1. - mat.metallic);\n\n    return iblDiffuse * OneMinusReflectivityFromMetallic * mat.baseColor;\n}\n\nvec3 CalcIndirectLight(Material mat, Ray ray, ShadingDots dots)\n{\n    vec3 ind = vec3(0);\n    ind += EnvSpecular(mat, ray, dots);\n    ind += EnvDiffuse(mat, ray, dots);\n    return ind;\n}\n\n\nvoid ShadingDotProducts(float vl, float nv, float nl,\n\t\tout float nh, out float vh) \n{\n\tfloat vl1 = vl + 1.;\n    // Hammon-Earl GDC'17 slides http://gdcvault.com/play/1024478/PBR-Diffuse-Lighting-for-GGX  that Dain refers to\n  #if 1\n    // @Dain idea from comments, saves a division; rsqrt is slightly faster anyway\n    // slide 116 stuff\n    float q = inversesqrt(vl1 + vl1); // = 1/length(L + V) = vh / vl1 \n    vh = q * vl1;\n    nh = q * (nv + nl);\n  #elif 0\n    // slide 114\n    float m = sqrt(vl1 + vl1); //sqrt(2. + 2. * vl); //length(L + V); //\n    vh = .5 * m;\n    nh = (nv + nl) / m;\n    // they claim on slide 115 this does save some cycles\n  #else\n    // Thanks, Maxima!\n\tvh = sqrt(.5 * vl1);\n\tnh = vh / vl1 * (nv + nl);\n  #endif\n}\n// avoids computing H, and associated costly normalize(),\n// but trades for something with a sqrt and a divide anyway.\n// maybe it saves something?\n\n// all must be unit vectors!\n// be damn sure the input vectors are normalized!!\nShadingDots CalcDots(vec3 normal, vec3 viewDir, vec3 lightDir)\n{\n    ShadingDots dots;\n    dots.nv = dot(normal,  viewDir);\n    dots.nl = dot(normal, lightDir);\n#if defined(NO_HALF_VECTOR)\n    float vl = dot(viewDir, lightDir); // no dots.vl;\n    ShadingDotProducts(vl, dots.nv, dots.nl, dots.nh, dots.vh); // look, ma, no H vector!  =D\n#else\n    vec3 halfDir = normalize(lightDir + viewDir);\n    dots.nh = dot(normal,  halfDir);\n    dots.vh = dot(viewDir, halfDir);\n#endif\n    // DO NOT clamp until after my NO_HALF_VECTOR trick!\n    const float ep = 1e-5;\n    dots.nl = max(dots.nl, ep);\n    dots.nv = max(dots.nv, ep);\n    dots.vh = max(dots.vh, ep);\n    dots.nh = max(dots.nh, ep);\n    return dots;\n}\n\n\nLit Lighting(Ray ray, Material mat)\n{\n    vec3 ldir = GetDirectionalLightDirection(iTime);\n    float shadow = CalcShadow(ray.len * ray.dir + ray.org, ldir);  // directional light shadow\n    float ao = CalcAmbientOcclusion(ray, mat);\n    ShadingDots dots = CalcDots(normalize(mat.normal), -normalize(ray.dir), ldir);\n    Lit l;\n    l.direct = CalcDirectLight(ray, mat, dots) * shadow;\n    l.indirect = CalcIndirectLight(mat, ray, dots) * ao;\n    return l;\n}\n\nvec3 LookAtPosition = vec3(0, 0, 4.5);\n\nCamera CreateCamera(const vec2 fragCoord, const vec2 res, float t)\n{\n    const float CloseClip = 1.;\n    \n    if (iMouse.z > 0.) { // TODO vec2\n        LookAtPosition.y += 2. * (iMouse.y/res.y - .5);\n        LookAtPosition.z += 4. * (iMouse.x/res.x - .5);\n    }\n\n    vec2 uv = fragCoord / res,\n        screenPosition = uv - .5;\n    screenPosition.x *= res.x / res.y;\n    \n    vec3 cameraOffset = vec3(cos(t * .2), sin(t * .05), sin(t * .5)),\n       cameraPos = vec3(5, 0, 5.5) + vec3(2, .5, 2) * cameraOffset,\n       lookAt = LookAtPosition,\n    \n       forwardV = normalize(lookAt - cameraPos),\n       rightV = cross(vec3(0, 1, 0), forwardV),\n       cameraUpV = cross(forwardV, rightV),\n   \n       centerOfScreen = cameraPos + forwardV * CloseClip,\n       intersectionPoint = centerOfScreen + screenPosition.x * rightV + screenPosition.y * cameraUpV,\n       cameraDir = intersectionPoint - cameraPos;\n\n    Camera cam;\n    cam.pos = cameraPos;\n    cam.dir = normalize(cameraDir);\n    cam.view = mat3(rightV, cameraUpV, forwardV);\n    return cam;\n}\n\nvec2 cossin(float rad)\n{\n    return vec2(cos(rad), sin(rad));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    Camera camera = CreateCamera(fragCoord, iResolution.xy, iTime);\n\tvec3 cbg = texture(iChannel3, camera.dir).rgb;\n    cbg *= cbg; // sRGB->linear\n    cbg = untonemap(cbg);\n    float foclen = length(camera.pos - LookAtPosition);\n    vec3 pfoc = camera.pos + camera.dir * foclen;\n    // hacked SSAA + DoF to replace original toy DoF scheme\n    float zero = min(0., iTime);\n    float aa = iResolution.y;\n    const float phi = .5 * (sqrt(5.) - 1.);\n    const float blur = 8.;\n    const float SSAA = 12.;\n    vec3 color = vec3(0);\n    for (float i = zero + SSAA; i-- > 0.; ) {\n        Ray ray = Ray(camera.pos, camera.dir, 8e4, -1); \n        vec2 jit = blur * cossin(2. * pi * phi * i / SSAA) * sqrt(i / SSAA) / aa; // vogel disc jitter;\n        ray.org += camera.view * vec3(jit, 0) * foclen;\n        ray.dir = mix(pfoc - ray.org, ray.dir, .5); // redo for DoF\n        ray.dir = normalize(ray.dir);\n        vec3 c = cbg;\n        DetectRayHitResult(ray);\n        Material material = GetMaterialResult(ray);\n        if (!material.isFar) {\n            Lit lit = Lighting(ray, material);\n            c = lit.direct + lit.indirect;\n        }        \n        color += c;\n    }\n    color /= SSAA;\n    color *= 2.; // brighten\n    color = tonemap(color);\n    fragColor = vec4(sqrt(color), 1); // linear->sRGB OETF approx\n}\n","name":"Image","description":"","type":"image"}]}