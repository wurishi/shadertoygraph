{"ver":"0.1","info":{"id":"7t23Rt","date":"1624790883","viewed":278,"name":"a path tracing demo","username":"yunhai","description":"my simple path tracing demo\n","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nespecially thanks to the author of this blog let me learned a lot :D\nhttps://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n*/\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv = C/iResolution.xy;\n    vec3 col=texture(iChannel0,uv).rgb;\n    col=ACESFilm(col*0.6);//Tone Mapping\n    O.rgb=linearToSRGB(col);//linear space to sRGB\n    //O.rgb=col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T iTime\nconst int RepaintPerFrame=1000000;\nconst uint RayJumpTimes=8u;\nconst uint RepeteTimesPerFrame=5u;\n//scene\nvec3 camPos=vec3(-1,3,-3);\nvec3 lookat=vec3(0,3,2);\nvec4 sphere0=vec4(vec3(-.5,.8,.8),.8);\nvec4 sphere1=vec4(vec3(-3,2,2),.8);\nvec4 sphere2=vec4(vec3(3,1.5,1),.8);\nvoid setCam(vec3 pos,vec3 lookat)\n{\n    cam.fov=80.;\n    cam.pos=pos;\n    cam.lookat=lookat;\n    cam.f=normalize(lookat-pos);\n    cam.r=cross(vec3(0,1,0),cam.f);\n    cam.u=cross(cam.f,cam.r);\n}\nRay getRay(vec2 uv)\n{\n    float dis=1./tan(.5*cam.fov*PI/180.);\n    return Ray(cam.pos,normalize(uv.x*cam.r+uv.y*cam.u+cam.f*dis));\n}\nvec3 randomUnitVec3(uint id)\n{\n    vec3 v=vec3(0,0,hashf(id));\n    float r=sqrt(1.-v.z*v.z);\n    float a=hashf(~id)*2.*PI;\n    v.x=r*cos(a);v.y=r*sin(a);\n    return v;\n}\nconst int nid=-1;\nconst int lid=0;//cube light\nconst int cid=1;\nconst int s1id=2;\nconst int s2id=3;\nconst int s3id=4;\nconst int ObjCount=5;\n//search for a intersection\nfloat isphere(Ray r,vec4 s)\n{\n    vec3 co=r.o-s.xyz;\n    float b=2.*dot(co,r.d);\n    float c=dot2(co)-s.w*s.w;\n    float delta=b*b-4.*c;\n    if(delta<0.)\n        return MaxDist;\n    float selRoot;\n    if(c<0.) selRoot=1.; \n    else if(b>0.) return MaxDist;\n    else selRoot=-1.;\n    return (-b+selRoot*sqrt(delta))/2.;\n}\nfloat icube(Ray r,vec3 pos,vec3 size,out bool isIn)\n{\n    size*=.5;\n    vec3 pmin=pos-size,pmax=pos+size,//AABB\n    t1=(pmin-r.o)/r.d,t2=(pmax-r.o)/r.d,\n    tn3=min(t1,t2),tf3=max(t1,t2);//3xtnear and 3x tfar\n    float tmin=max3(tn3),\n          tmax=min3(tf3);\n    if(tmin>tmax||tmax<0.)\n        return MaxDist;\n    isIn=false;\n    if(tmin<0.)\n        isIn=true;\n    return mix(tmax,tmin,step(0.,tmin));\n}\nHit getAHit()\n{\n    return Hit(nid,MaxDist,vec3(0),vec3(0),false,\n           Mat(vec3(0),vec3(0),0.,0.,vec3(0)));\n}\nHit rayCast(Ray r)\n{\n    vec4 s[3];\n    s[0]=sphere0;\n    s[1]=sphere1;\n    s[2]=sphere2;\n    vec3 cpos=vec3(0,4,-2);\n    vec3 csiz=vec3(9,8,12);\n    vec3 lpos=vec3(0,8.07,3);\n    vec3 lsiz=vec3(4.,.2,1.);\n    float d[ObjCount];\n    bool isIn[ObjCount];\n    d[s1id]=isphere(r,s[0]);\n    d[s2id]=isphere(r,s[1]);\n    d[s3id]=isphere(r,s[2]);\n    d[cid]=icube(r,cpos,csiz,isIn[cid]);\n    d[lid]=icube(r,lpos,lsiz,isIn[lid]);\n    Hit h=getAHit();\n    for(int i=0;i<ObjCount;i++)\n        if(d[i]<h.dis)\n        {\n            h.id=i;\n            h.dis=d[i];\n        }\n    h.pos=r.o+r.d*h.dis;\n    h.isIn=isIn[h.id];\n    //set info\n    if(h.id>=0)\n    {\n        if(h.id>=s1id)\n        {\n            h.nml=(h.pos-s[h.id-2].xyz)/s[h.id-2].w;\n            if(h.id==s1id)\n            {\n                h.mat.albedo=vec3(.7,.3,.3);\n                h.mat.emission=vec3(0);\n                h.mat.specularPercent=.5;\n                h.mat.roughness=.4;\n                h.mat.specularCol=vec3(.3,.3,.7);\n            }\n            else if(h.id==s2id)\n            {\n                h.mat.albedo=vec3(.2,.5,.4)*1.6;\n                h.mat.emission=vec3(0);\n                h.mat.specularPercent=.9;\n                h.mat.roughness=.1;\n                h.mat.specularCol=vec3(.3,.5,.4);\n            }\n            else if(h.id==s3id)\n            {\n                h.mat.albedo=vec3(.5,.5,.1);\n                h.mat.emission=vec3(0.);\n                h.mat.specularPercent=.1;\n                h.mat.roughness=.8;\n                h.mat.specularCol=vec3(.4,.9,.1);\n            }\n            \n        }   \n        else if(h.id==cid||h.id==lid)\n        {\n            vec3 cp=h.pos-cpos;\n            h.nml=normalize(pit(csiz/2.-1e-6,cp)*sign(cp));\n            if(h.isIn)\n                h.nml=-h.nml;\n            vec3 lrWallPass=vec3(step(.5,h.nml.x),step(.5,-h.nml.x),0);\n            lrWallPass=mix(vec3(1.),lrWallPass,step(.5,abs(h.nml.x)));\n            h.mat.albedo=vec3(.6)*lrWallPass;\n            h.mat.emission=vec3(0.);\n            h.mat.specularPercent=.1;\n            h.mat.roughness=.4;\n            h.mat.specularCol=vec3(.6)*lrWallPass;\n            if(h.id==lid)\n            {\n                h.mat.albedo=vec3(0.6);\n                h.mat.emission=vec3(1,.9,.8)*10.;\n            }\n        }  \n    }\n    \n    return h;\n}\nvec3 sceneTrace(Ray r,uint tracePathSeed)\n{  \n    vec3 throughput=vec3(1);\n    vec3 col=vec3(0);\n    for(uint i=0u;i<RayJumpTimes;++i)\n    {\n        Hit h=rayCast(r);\n        if(h.id<0) break;\n        col+=h.mat.emission*throughput;\n        r.o=h.pos+h.nml*MinDist;\n        vec3 randomRayDir=normalize(h.nml+randomUnitVec3(tracePathSeed+i));\n        vec3 specularRayDir=reflect(r.d,h.nml);\n        specularRayDir=normalize(mix(specularRayDir,randomRayDir,h.mat.roughness));\n        float isSpecular=step(hashf(tracePathSeed+i*2u),h.mat.specularPercent);\n        r.d=mix(randomRayDir,specularRayDir,isSpecular);\n        throughput*=mix(h.mat.albedo,h.mat.specularCol,isSpecular);\n        //Russian Roulette\n        float aliveP=max3(throughput);\n        if(hashf(tracePathSeed+i-100u)>aliveP)\n            break;\n        throughput/=aliveP;\n    }   \n    return col;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    uint seed=hash21(C*3.+vec2(100.*T));\n    int frame=iFrame%RepaintPerFrame;\n    vec2 m=iMouse.xy/iResolution.xy-.5;\n    \n    setCam(camPos,lookat);\n    \n    vec2 offset=vec2(hashf(uint(T)),hashf(uint(T+100.)))-.5;//AA\n    vec2 uv = (2.*(C+offset)-iResolution.xy)/iResolution.y;\n    Ray r=getRay(uv);\n    \n    vec3 col=vec3(0);\n    for(uint i=0u;i<RepeteTimesPerFrame;++i)\n        col+=(sceneTrace(r,seed-50000u*i));\n    col/=float(RepeteTimesPerFrame);\n    vec3 lastCol=texture(iChannel0,C/iResolution.xy).rgb;\n    if(frame==0) lastCol=vec3(0);\n    O.rgb=mix(lastCol,col,1./float(frame+1));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst float PI=3.14159265;\nconst float MaxDist=100.;\nconst float MinDist=1e-5;\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n}; \nstruct Mat\n{\n    vec3 albedo;\n    vec3 emission;\n    float specularPercent;\n    float roughness;\n    vec3 specularCol;\n};\nstruct Hit\n{\n    int id;\n    float dis;\n    vec3 pos;\n    vec3 nml;\n    bool isIn;\n    Mat mat;\n    \n};\nstruct Cam\n{\n    vec3 pos;\n    vec3 lookat;\n    vec3 f;\n    vec3 r;\n    vec3 u;\n    float fov;\n}cam;\nfloat dot2(vec3 v){return dot(v,v);}\nfloat pit(float o,float t){return step(o,t)+1.-step(-o,t);}\nvec3 pit(vec3 o,vec3 v){return vec3(pit(o.x,v.x),pit(o.y,v.y),pit(o.z,v.z));}\nfloat max3(vec3 v){return max(v.x,max(v.y,v.z));}\nfloat min3(vec3 v){return min(v.x,min(v.y,v.z));}\nuint hash(uint a)\n{\n    a*=89734129u;\n    a=(a<<10)^(a>>10)^a;\n    a*=91613912u;\n    a=(a<<3)^(a>>3)^a;\n    return a;\n}\nfloat hashf(uint a){return float(hash(a))/4294967296.0;}\nuint hash21(vec2 v)\n{\n    return hash(uint(v.x*1733.)+uint(v.y+7699.));\n}\n//--------------ColorSpace change\nvec3 linearToSRGB(vec3 rgb)\n{\n    return pow(rgb, vec3(.45));\n}\n//--------------Tone Mapping\n//more info on this :\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)//1->0.8,10->1()\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n","name":"Common","description":"","type":"common"}]}