{"ver":"0.1","info":{"id":"4tdSDS","date":"1481559441","viewed":2545,"name":"Transformation Using Smin","username":"Ark","description":"Demo: a transformation by using smooth minimum and distance function\n\nâ†“ A Japanese article about this work\nhttps://trapti.tech/blog/4273/","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["transformation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define INF 1e10\n#define EPS 1e-10\n#define ITER_MAX 10000\n\nfloat crs(vec2 v1, vec2 v2) {\n    return v1.x*v2.y - v1.y*v2.x;\n}\n\n// smooth min\n// reference: https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\nfloat ellipse(vec2 p, vec2 r) {\n    return (length(p/r) - 1.0) * min(r.x, r.y);\n}\n\nfloat line(vec2 p, vec2 v1, vec2 v2) {\n    p  -= v1;\n    vec2 v = v2-v1;\n    float t = dot(p, normalize(v));\n    if (t<0.0) {\n        return length(p);\n    } else if (t>length(v)) {\n        return length(p-v);\n    } else {\n        return abs(crs(p, normalize(v)));\n    }\n}\n\nbool innerTriangle(vec2 p, vec2 v1, vec2 v2, vec2 v3) {\n    float c1 = crs(v2-v1, p-v1);\n    float c2 = crs(v3-v2, p-v2);\n    float c3 = crs(v1-v3, p-v3);\n    return (c1>0.0&&c2>0.0&&c3>0.0) || (c1<0.0&&c2<0.0&&c3<0.0);\n}\n\nfloat StarPolygon(vec2 p, int n, int m, float r) {\n    float d = INF;\n    for (int i=0; i<ITER_MAX; i++) {\n        if (i >= n) break;\n        \n        float rad1 = 2.0*PI*float(i)/float(n);\n        float rad2 = 2.0*PI*float(i+m)/float(n);\n        vec2 v1 = vec2(cos(rad1), sin(rad1)) * r;\n        vec2 v2 = vec2(cos(rad2), sin(rad2)) * r;\n        bool flg = innerTriangle(p, vec2(0.0), v1, v2);\n        d = min(d, line(p, v1, v2) * (flg?-1.0:1.0));\n    }\n    return d;\n}\n\nvec3 calc(vec2 p) {\n    float t = iTime;\n    float r = (sin(t*PI)+1.0) * 0.3 + EPS;\n    float d1 = StarPolygon(p, 5, 2, r);\n    float d2 = ellipse(p, vec2(0.01));\n    float d = smin(d1, d2, 3.5);\n    return vec3(pow(clamp(1.0-d, 0.0, 1.0), 5.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfragColor = vec4(calc(uv),1.0);\n}","name":"Image","description":"","type":"image"}]}