{"ver":"0.1","info":{"id":"lXS3Ry","date":"1709661184","viewed":100,"name":"Moon_JellyBoonz","username":"JellyBoonz","description":"First \"official\" shader! I learned a lot about noise and fractional brownian motion. I'm currently working on factoring in FBM or some other noise for the star glimmer. Also open to input on how to blend the bright reflection on the moon.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["moon","night"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Authors: Jaiden Ortiz aka JellyBoonz and Saif Fayed (c) 2024\n// Moon\n//\n\nconst int MAX_MARCHING_STEPS=255;\nconst float MIN_DIST=0.;\nconst float MAX_DIST=100.;\nconst float PRECISION=.001;\nconst float RADIUS=.7;\n#define OCTAVES 6\n\nfloat random(in vec3 st){\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nmat3 rotateY(float theta){\n    float c=cos(theta);\n    float s=sin(theta);\n    return mat3(\n        vec3(c,0,s),\n        vec3(0,1,0),\n        vec3(-s,0,c)\n    );\n}\n\n// Author @patriciogv - 2015 - patriciogonzalezvivo.com\nfloat noise(vec3 p){\n    vec3 i=floor(p);\n    vec3 fractionalPart=fract(p);\n    \n    // Eight corners in 3D of a tile\n    float a=random(i);\n    float b=random(i+vec3(1.,0.,0.));\n    float c=random(i+vec3(0.,1.,0.));\n    float d=random(i+vec3(1.,1.,0.));\n    float e=random(i+vec3(0.,0.,1.));\n    float f=random(i+vec3(1.,0.,1.));\n    float g=random(i+vec3(0.,1.,1.));\n    float h=random(i+vec3(1.,1.,1.));\n    \n    vec3 u=fractionalPart*fractionalPart*(3.-2.*fractionalPart);\n    \n    //Blend the x-axis values together using u.x, then\n    //blend the resulting values on the y-axis, then\n    //finally the z-axis\n    //note: interpolation is based on how far into each\n    //axis the input point is\n    return mix(mix(mix(a,b,u.x),\n    mix(c,d,u.x),u.y),\n    mix(mix(e,f,u.x),\n    mix(g,h,u.x),u.y),u.z);\n}\n\n/**\n*  signed distance from edge of sphere\n*/\nfloat sdfSphere(vec3 p, float radius) {\n    vec3 offset = vec3(0, 0, -2);\n    return length(p - offset) - radius;\n}\n\nvec3 sdfSphere(vec3 p, float radius, mat3 transform) {\n    vec3 offset = vec3(0, 0, -2);\n    return vec3(length(transform * (p - offset)) - radius);\n}\n\n/**\n* Draws the background and stars\n*/\nvec3 drawStars(vec2 uv){\n    float starDensity=.003;// Adjust the density of stars\n    float offset=fract(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453);\n    float seed=fract(offset);\n    float brightness=seed*.8+.5;\n    \n    // Making stars\n    if(offset<starDensity){\n        // Use a unique seed based on position for each star\n        float positionSeed=fract(dot(uv,vec2(123.45,678.9)));\n        float flicker=sin(iTime*mix(positionSeed,offset,smoothstep(0.,1.,positionSeed))*10.);\n        brightness+=flicker*.6;// Adjust the amplitude of flickering\n        \n        // Random color variation\n        float colorSeed = fract(positionSeed * 12345.6789); // Generate a new seed for color variation\n        vec3 starColor = vec3(brightness); // Default white color\n\n        // Randomly adjust the color based on the colorSeed\n        if (colorSeed < 0.33) {\n            starColor.r *= 1.9; // Slightly red\n        } else if (colorSeed < 0.66) {\n            starColor.b *= 1.01; // Slightly blue\n        }\n\n        return starColor;\n    }\n    \n    return vec3(.05,.05,.05);// Space background\n}\n\n/**\n* Used to add extra layers of noise on top of each other.\n*/\nfloat fbm(in vec3 p){\n    // Initial values\n    float value=0.;\n    float amplitude=.6;\n    float lacunarity=3.;\n    float gain=.3;\n    \n    // Loop of octaves\n    for(int i=0;i<OCTAVES;i++){\n        value+=amplitude*noise(p);\n        p*=lacunarity;\n        amplitude*=gain;\n    }\n    return value;\n}\n\nfloat rayMarch(vec3 ro,vec3 rd,float start,float end){\n    float depth=start;\n    \n    for(int i=0;i<MAX_MARCHING_STEPS;i++){\n        vec3 p=ro+depth*rd;\n        float d=sdfSphere(p,RADIUS);// Using sdfSphere function for moon with rotation\n        depth+=d;\n        if(d<PRECISION||depth>end)break;\n    }\n    \n    return depth;\n}\n\n/*\n* Calculates normal vectors to a given position. rotationMatrix\n* is used to rotate the normals and thus move the light around the moon.\n*/\nvec3 calcNormal(vec3 p,mat3 rotationMatrix){\n    vec2 e=vec2(1.,-1.)*.0005;// epsilon\n    float r=1.;// radius of sphere\n    return normalize(\n        e.xyy*sdfSphere(p+e.xyy*rotationMatrix,r,rotationMatrix)+\n        e.yyx*sdfSphere(p+e.yyx*rotationMatrix,r,rotationMatrix)+\n        e.yxy*sdfSphere(p+e.yxy*rotationMatrix,r,rotationMatrix)+\n        e.xxx*sdfSphere(p+e.xxx*rotationMatrix,r,rotationMatrix)\n    );\n}\n\nvec3 drawScene(vec2 uv){\n    vec3 col=drawStars(uv);\n    // Ray marching for rendering moon\n    vec3 ro=vec3(0.,0.,2.);// Camera position\n    vec3 rd=normalize(vec3(uv,-1.));// Ray direction\n    \n    mat3 rotationMatrix=rotateY(iTime);// Rotation matrix for the moon\n    \n    float moonDepth=rayMarch(ro,rd,MIN_DIST,MAX_DIST);// Adjust end value as necessary\n    \n    // Check if ray hits the moon\n    if(moonDepth<10.){\n        // Calculate point on the moon surface\n        vec3 p=ro+moonDepth*rd;\n        \n        // Calculate surface normal\n        vec3 normal=calcNormal(p,rotationMatrix);\n        \n        vec3 lightPosition=vec3(0.,0.,0.)*rotateY(iTime*.05);// Light position rotates around the moon at a slower rate\n        vec3 lightDirection=normalize(lightPosition-p);\n        \n        // Modify color based on Perlin noise\n        float craterNoise=fbm(p*10.);// Adjust the scale of noise by multiplying with an appropriate factor\n        craterNoise=smoothstep(.2,.8,craterNoise);// Smooth the noise\n        \n        float dif=clamp(dot(normal,lightDirection),0.,1.);\n        \n        col=vec3(dif);\n        col*=mix(1.,1.5,craterNoise);// Adjust the values for crater appearance\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;// <0,1>\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;// fix aspect ratio\n    \n    vec3 col=drawScene(uv);\n    \n    // Output to screen\n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}