{"ver":"0.1","info":{"id":"ltKfWG","date":"1544118079","viewed":320,"name":"Depth of field - blur buffer","username":"qzhang93","description":"for CS1230 Final Project","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["final"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAttempt was to get a hexagonal bokeh.\nRef: https://www.shadertoy.com/view/MsG3Dz\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n    \n    fragColor = texture(iChannel0, uv);\n\tfragColor = vec4(fragColor.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SPHERE 0\n#define PLANE 1\n#define NO_INTERSECT 2\n#define DISPLACEMENT_FACTOR 0.1\n\n#define FOCUS_DISTANCE 7.5\n#define DEFOCUS_PER_UNIT 0.0925\n#define BLUR_LIMIT 1.0\n\n// Data structure for raymarching results\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n\n// Helper function for tri3.\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\n// Triangle noise. Use it as a sample displacement map for task 7.\nvec3 tri3(in vec3 p) {\n    return vec3(tri(p.z+tri(p.y*1.)), \n                tri(p.z+tri(p.x*1.)), \n                tri(p.y+tri(p.x*1.)));\n}\n\n// TODO [Task 8] Make a displacement map\n// You can check out tri3 above and the functions in the handout as inspiration\nfloat calcDisplacement(in vec3 p) {\n    return pow(sin(p.x) + cos(p.y), 2.0);\n}\n\n// TODO [Task 6] Implement triplanar texture mapping\n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec4 xtex = texture(sam, p.yz);\n    vec4 ytex = texture(sam, p.xz);\n    vec4 ztex = texture(sam, p.xy);\n    return xtex.rgb * abs(n.x) +  ytex.rgb * abs(n.y) + ztex.rgb * abs(n.z);\n}\n\n// Signed distance to the twisted sphere.\nfloat sdTwistedSphere(vec3 p) {\n    vec3 spherePosition = vec3(0.0, 0.25, 0.0);\n    float radius = 1.5;\n    float primitive = length(p - spherePosition) - radius;\n    return primitive + calcDisplacement(p);\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\nPrimitiveDist map(vec3 p) {\n    // TODO [Task 3] Implement distance map\n    float closest = min(sdFloor(p), sdTwistedSphere(p));\n    float planeDist = sdFloor(p);\n    float sphereDist = sdTwistedSphere(p);\n    if (planeDist < sphereDist) {\n    \treturn PrimitiveDist(planeDist, PLANE);\n    } else {\n        return PrimitiveDist(sphereDist, SPHERE); \n    }\n}\n\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    vec3 normal = vec3(map(p + e.xyy).dist - map(p - e.xyy).dist, \n                       map(p + e.yxy).dist - map(p - e.yxy).dist, \n                       map(p + e.yyx).dist - map(p - e.yyx).dist);\n    return normalize(normal);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n    \n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        // TODO [Task 7] Modify the loop to implement soft shadows\n        //if (h < threshold) {\n            darkness = min(darkness, k*h/marchDist);\n        //    break;\n        //}\n        marchDist += h * 0.7;\n    }\n    \n    return darkness;\n}\n\n\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n    \n    // TODO [Task 2] Implement ray marching algorithm\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 50.0;\n    float threshold = 0.001;\n    \n    // Fill in the iteration count\n    for (int i = 0; i < 1000; i++) {\n        // Fill in loop body\n        PrimitiveDist currentDist = map(ro + marchDist * rd);\n        marchDist += 0.1 * currentDist.dist;\n        \n        if (currentDist.dist < threshold) {\n            return PrimitiveDist(marchDist, currentDist.primitive);\n        }\n        if (marchDist > boundingDist) {\n        \tbreak;\n        }\n    }    \n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n    \n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n    \n    // Normal vector\n    vec3 nor = calcNormal(pos);\n    \n    // Ambient\n    float ambient = 0.1;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0; \n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    \n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n    \n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = texCube(iChannel0, pos, nor);\n    } else if (which == SPHERE) {\n        material = texCube(iChannel1, pos, nor);\n    } else {\n        material = vec3(0.5);\n    }\n    \n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n    \n    return col;\n}\n\nconst float M_PI = 3.1415926535897932384626433832795;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    vec3 rayOrigin = vec3(6.0 * sin(iTime * .3), 4.8, 6.0 * cos(iTime * .3));\n    //vec3 rayOrigin = vec3(6.0, 6.0, 0.0);\n    \n    float focalLength = 2.0;\n    \n    // The target we are looking at\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward)); \n    \n    // TODO [Task 1] Construct the ray direction vector\n    vec2 uv = vec2(fragCoord.x/iResolution.x*2.0 - 1.0, -1.0 + fragCoord.y/iResolution.y*2.0);\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    vec3 rayDirection = vec3(uv.x, uv.y, focalLength);\n    rayDirection = cameraRight * rayDirection.x + cameraUp * rayDirection.y + cameraForward * rayDirection.z;\n    rayDirection = normalize(rayDirection);\n\n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n        col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    }\n    \n    //compute how much this pixel is focused (this math could be improved)\n    float focus = abs(rayMarchResult.dist-FOCUS_DISTANCE)*DEFOCUS_PER_UNIT;\n    focus = min(BLUR_LIMIT,focus);\n    \n    fragColor = vec4(col, focus);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//first blur pass\n\nconst vec2 dir = vec2(0.02,0.02);//blur direction\nconst float thresh = .5;//depth threshold\n\nfloat weight(float x){\n\treturn 1.0-x*x*x*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy*2.0;\n    \n    float dist = texture(iChannel0,uv).a;\n    float totalw = .0;\n    \n    vec3 color = vec3(0,0,0);\n    for (int i=0; i<=20; i++){\n        vec2 p = uv;\n        float fi = float(i-10)/10.0;\n        p.xy+=dir*fi*dist;\n        \n        float w = weight(fi);\n        \n    \tvec4 c = texture(iChannel0,p);\n        if (dist>=c.a){\n            w*=max(.0,1.0-(dist-c.a)/thresh);\n        }\n        color += c.xyz*w;\n        totalw+=w;\n    }\n    color/=totalw;\n\tfragColor = vec4(color,dist);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//second blur pass\n\nconst vec2 dir = vec2(0.02,-0.02);//blur direction\nconst float thresh = .5;//depth threshold\n\nfloat weight(float x){\n\treturn 1.0-x*x*x*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n\n    float dist = texture(iChannel0,uv).a;\n    float totalw = .0;\n    \n    vec3 color = vec3(0,0,0);\n    for (int i=0; i<=20; i++){\n        vec2 p = uv;\n        float fi = float(i-10)/10.0;\n        p.xy+=dir*fi*dist;\n        \n        float w = weight(fi);\n        \n    \tvec4 c = texture(iChannel0,p);\n        if (dist>=c.a){\n            w*=max(.0,1.0-(dist-c.a)/thresh);\n        }\n        color += c.xyz*w;\n        totalw+=w;\n    }\n    color/=totalw;\n\tfragColor = vec4(color,dist);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//third blur pass\n\nconst vec2 dir = vec2(0.00,0.04);//blur direction\nconst float thresh = .5;//depth threshold\n\nfloat weight(float x){\n\treturn 1.0-x*x*x*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n    \n    float dist = texture(iChannel0,uv).a;\n    float totalw = .0;\n    \n    vec3 color = vec3(0,0,0);\n    for (int i=0; i<=20; i++){\n        vec2 p = uv;\n        float fi = float(i-10)/10.0;\n        p.xy+=dir*fi*dist;\n        \n        float w = weight(fi);\n        \n    \tvec4 c = texture(iChannel0,p);\n        if (dist>=c.a){\n            w*=max(.0,1.0-(dist-c.a)/thresh);\n        }\n        color += c.xyz*w;\n        totalw+=w;\n    }\n    color/=totalw;\n\tfragColor = vec4(color,dist);\n}","name":"Buffer D","description":"","type":"buffer"}]}