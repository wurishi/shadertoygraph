{"ver":"0.1","info":{"id":"WsccDH","date":"1600850097","viewed":950,"name":"Flammes 3 - Vortex","username":"athibaul","description":"2D fake flame simulation using a simple vortex street, a fake combustion equation, and a chart for blackbody color.","likes":61,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","flame","vortexstreet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 colorFromTemperature( float t )\n{\n    // Convert a temperature in Kelvin to a color\n    \n    // Blackbody color data from Mitchell Charity's website\n    // http://www.vendian.org/mncharity/dir3/blackbody/\n    vec3 col = vec3(0);\n    col = mix(col, rgb(0xff3800), clamp(t/1000.,0.,1.));\n    col = mix(col, rgb(0xff8912), clamp((t-1000.)/1000.,0.,1.));\n    // I'm unlikely to use higher temperatures for realistic flames,\n    // but I included them anyway.\n    col = mix(col, rgb(0xffb46b), clamp((t-2000.)/1000.,0.,1.));\n    col = mix(col, rgb(0xffd1a3), clamp((t-3000.)/1000.,0.,1.));\n    col = mix(col, rgb(0xffe4ce), clamp((t-4000.)/1000.,0.,1.));\n    col = mix(col, rgb(0xfff3ef), clamp((t-5000.)/1000.,0.,1.));\n    col = mix(col, rgb(0xf5f3ff), clamp((t-6000.)/1000.,0.,1.));\n    return col*t/3000.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    // The simulation is done horizontally, but let's make it vertical\n    float heat = T0(uv.yx).b;\n    // Constants are completely arbitrary\n    float temperature = 1.1e5*heat;\n    vec3 col = 1.5*colorFromTemperature(temperature);\n    \n    // Tone mapping and gamma correction\n    col = mix(col, 1.-(4./27.)/(col*col), step(2./3., col));\n    //col = smoothstep(0.,1.,col);\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Comment this out for old version\n#define TEMPERATURE_CATALYSIS\n\nfloat tScale = 10.0; // Speed of simulation\n\nvec3 initCond( vec2 uv )\n{\n    // Initial conditions : cold oxygen everywhere, and gas inside a circle.\n    // x = amount of combustible gas\n    // y = amount of oxygen\n    // 1-x-y = amount of inert gas\n    // z = amount of heat\n    return mix(vec3(0,1,0), vec3(0.2,0.05,0),\n               smoothstep(0.5,0.35,length(uv-vec2(-1.5,0))));\n}\n\nvec2 velocityField( vec2 uv )\n{\n    // Velocity is the sum of the velocities of several vortex fields,\n    // each with a Kaufmann profile.\n    // https://www.shadertoy.com/view/3stcDr\n    \n    // The positions of vortices is chosen to look like a vortex street\n    // with random variation.\n    // https://en.wikipedia.org/wiki/K%C3%A1rm%C3%A1n_vortex_street\n    vec2 v = vec2(0);\n    float cx0 = 0.5*iTime*tScale;\n    float xScale = 0.5; // Smaller for more vortices\n    for(float cx = fract(cx0)-3.; cx < fract(cx0)+3.; cx += xScale)\n    {\n        for(float cy = -0.5; cy < 0.51; cy += 1.0)\n        {\n            float id = cx-cx0 + 0.25*sign(cy);\n            vec2 c = vec2(cx + 0.25*xScale*sign(cy), cy*0.8);\n            c += 0.3*(2.*hash21(id)-1.); // Randomize vortex position\n    \t\tfloat r0 = 0.15 + 0.2*hash11(id); // Radius of the smooth vortex core\n            vec2 uv2 = uv-c;\n            float denom = r0*r0 + dot(uv2,uv2);\n            v += sign(cy) * vec2(-uv2.y,uv2.x)/denom * xScale;\n        }\n    }\n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    if(iFrame == 0 || T0(uv).a != iResolution.x)\n    {\n        fragColor = vec4(initCond(uv), iResolution.x);\n    }\n    else\n    {\n        // Transport the fluid according to current velocity\n        fragColor = T0(uv - 0.002*tScale*velocityField(uv));\n        // Fake combustion equation : consume gas and oxygen to produce heat\n        #ifndef TEMPERATURE_CATALYSIS\n        \tfloat heat = fragColor.r * fragColor.g * 0.01*tScale;\n        #else\n        \t// Make combustion more efficient at higher temperatures,\n        \t// resulting in a more contrasted flame\n        \tfloat heat = fragColor.r * fragColor.g * (5e1*fragColor.b+0.5) * 0.01*tScale;\n        #endif\n        fragColor.b += heat;\n        fragColor.r -= heat;\n        fragColor.g -= heat;\n        fragColor = max(fragColor, vec4(0));\n        // A bit of dissipation/mixing\n        fragColor.rgb = mix(fragColor.rgb, initCond(uv), 0.015*tScale);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define T0(uv) texture(iChannel0, (0.5+0.5*(uv)*iResolution.y/iResolution.xy))\n\n// Hash functions by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//-------------------------------------\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}\n//----------------------------------------------\n\n\n\n// Convert sRGB-int8 to linear RGB-float\nvec3 rgb(int r, int g, int b)\n{\n    return pow(vec3(r,g,b)/255., vec3(2.2));\n}\nvec3 rgb(int a)\n{\n    int r = (a>>16) & 0xff;\n    int g = (a>>8) & 0xff;\n    int b = a & 0xff;\n    return rgb(r,g,b);\n}","name":"Common","description":"","type":"common"}]}