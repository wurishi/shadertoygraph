{"ver":"0.1","info":{"id":"MscGW2","date":"1452164892","viewed":295,"name":"Blur Rotate Lines 2","username":"TambakoJaguar","description":"One more 2D test using the buffers, this time with more funny stuff!","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["2d","blur","lines","colorful","random","rotation","drawing","buffer","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\n\"Blur Rotate Lines\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int nb_lines = 25;\nconst float line_width = 0.0007;\nconst int blur_size = 2;\nconst float blur_width = 0.9;\nconst float darken_fact0 = 0.965;\nconst float blur_fact = 0.00001;\nfloat iangle;\nfloat sin_freq;\nfloat sin_amp;\n\nvec3 drawLine(vec2 p1, vec2 p2, vec2 pos, vec3 color, float w)\n{\n    float v = dot(p1-pos, (p1.yx-p2.yx)*vec2(1., -1.));\n    v = dot(p1 - pos, p2 - p1)<0.?v:2.*w;\n    v = dot(p2 - pos, p2 - p1)>0.?v:2.*w;\n    float w2 = w*distance(p1, p2);\n    return mix(color, vec3(0), smoothstep(w2, w2+0.0005, abs(v)));\n}\n\n// Simple \"random\" function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vect.y*= iResolution.y/iResolution.x;\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    rv.y*= iResolution.x/iResolution.y;\n    return rv;\n}\n\nfloat gauss(float x, float e)\n{\n    return exp(-pow(x, 2.)/e); \n}\n\n\nvec4 quickblur(vec2 pos)\n{\n   vec4 pixval = vec4(0.);\n   float csum = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int y=0; y<nb; y++)\n   {\n       for (int x=0; x<nb; x++)\n       { \n           vec2 ipos = pos + vec2(blur_width*float(x-blur_size)/iResolution.x, blur_width*float(y-blur_size)/iResolution.y);\n           float g = 1.; //gauss(distance(ipos, pos), float(blur_size)*blur_fact);\n           pixval+= g*texture(iChannel0, ipos);\n           csum+= g;\n       }\n   }\n   return pixval/csum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat darken_fact;\n\n    iangle = 1.6*cos(iTime/2.2);\n    sin_freq = 70. + 25.*cos(iTime/1.7 + 0.5);\n    sin_amp = 0.0017 * (1. + 0.8*sin(iTime*1.3));    \n    \n    vec2 uv = fragCoord.xy / iResolution.xx;\n    vec2 uv2 = fragCoord.xy / iResolution.xy + sin_amp*sin((fragCoord.xy / iResolution.x)*sin_freq);\n    float sx = 1.;\n    float sy = iResolution.y/iResolution.x;\n    \n    vec3 col = vec3(0.);\n    if (mod(iTime/3.5 + 0.8, 2.)>0.65)\n    {\n        float trf = 55.*floor(iTime*10.);\n        vec2 dv = vec2(0.03*sx*random(trf + 10.), 0.03*sy*random(trf + 20.));\n        for (float l=0.; l<float(nb_lines); l++)\n        {\n            vec2 p1 = vec2(sx*0.15 + sx*0.7*random(trf + 100.), sy*0.15 + sy*0.7*random(trf + 200.)) - l*dv;\n            vec2 p2 = vec2(sx*0.15 + sx*0.7*random(trf + 300.), sy*0.15 + sy*0.7*random(trf + 400.)) + l*dv;\n            vec3 color = 0.25*vec3(random(trf + 500.), random(trf + 600.), random(trf + 700.));\n            col+= drawLine(p1, p2, uv, color, line_width);\n        }\n        darken_fact = darken_fact0;\n    }\n    else\n        darken_fact = 1.;\n    fragColor = darken_fact*quickblur(vec2(0.5, 0.5)+rotateVec(uv2-vec2(0.5, 0.5), radians(iangle))) + vec4(col, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}