{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// https://iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 40;\n\t\nvec4 spherePos[20];\n  \n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 noiseVec( vec3 p ){\n    \n    float x = rand( p.xy );\n    float y = rand( p.yz);\n    float z = rand( p.zx );\n \n    return normalize(normalize(vec3( x , y , z )) - vec3( .5 ));\n    \n}\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n    \n    float f = sin( p.z * 5. ) * sin( p.x * 5. );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y - (abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdNoiseSphere( vec3 p, float s )\n{\n  return length(p)-( s * (1.3 + .3 * triNoise3D( p * .2, 1. ) ));\n}\n\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    //pos = mod( pos + .5 , 1. ) - .5 ;\n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    \n    for( int i = 0; i < 20; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , .2 ) ,  .1);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n    vec2 res2 = vec2( sdNoiseSphere( (pos) , .6 ) , 3.);\n    \n    res = opU( res , res2 );\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 20; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n        \n        vec3  p = vec3( x , y , z );\n        p = normalize( p ) * 1.3;\n        \n    \tspherePos[i] = vec4( p.x ,  p.y ,  p.z , .2  );\n        \n        \n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 lightPos = vec3( 2. , 1. , 0. );\n    \n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n        vec3 pos = ro + rd * res.x;\n        vec3 nor = calcNormal( pos );\n\n        vec3 lightDir = lightPos - pos;\n        lightDir = normalize( lightDir );\n        \n        vec3 lightRefl = reflect( lightDir , nor );\n        float reflMatch = pow( max( 0. , dot( rd , lightRefl )) , 10. );\n        \n\n\n        float AO = calcAO( pos , nor );\n\n        float match = max( 0. , dot( nor , lightDir ));\n        \n        float rim = pow( 1. - max( 0. , dot( -nor , rd ) ) , 5.);\n\n        if( res.y < 2. ){\n    \n           // float c = pow(( 1.-AO) , 5.)*  10.;\n            float c = 0.;\n            //c += pow((1.- match),4.) * 1.;\n            c += pow(( 1.-AO) , 5.)*  2.;\n           // col = vec3( c );// * .4 * ( nor * .5 + .5 );\n\n           // col = hsv( c ,1.,1.) * c;\n            col += vec3( 1. , .2 , 0.6 ) * pow(( 1.-AO) , 2.); \n            col += vec3( 1. , .8, .2 ) * rim;\n            col += vec3( .3 , .5 , 1. ) * reflMatch;\n            \n            //* pow( match , 3.) * hsv(abs(sin(match*1.)) , 1. , 1. );\n            //col += pow( shinyMatch , 5. ) * hsv(abs(sin(shinyMatch*10.)) , 1. , 1. );\n        }else{\n          \n        \tvec3 refl = normalize( reflect( rd , nor ));\n            \n            vec3 ro2 = pos + refl * .01;\n            vec3 rd2 = refl;\n            \n            vec2 res2 = calcIntersection( ro2 , rd2  );\n            \n            col += vec3( 1. , .8 , .2 ) * rim;\n            \n            if( res2.y > -.5 ){\n                \n                \n                \n\n                vec3 pos2 = ro2 + rd2 * res2.x;\n        \t\tvec3 nor2 = calcNormal( pos2 );\n\n                vec3 lightDir = lightPos - pos2;\n                lightDir = normalize( lightDir );\n\n                vec3 lightRefl = reflect( lightDir , nor2 );\n                float reflMatch = pow( max( 0. , dot( rd2 , lightRefl )) , 10. );\n                \n                float AO = calcAO( pos2 , nor2 );\n                col += vec3( 1. , .2 , .6 ) * pow(( 1.-AO) , 2.); \n                \n                float r2 = pow( 1. - max( 0. , dot( -nor2 , rd2 ) ) , 5.);\n                col += vec3( 1. , .8 , .2 ) * r2;\n                \n                col += vec3( .3 , .5 , 1. ) * reflMatch;\n            \n            }\n            \n          \n            \n        }\n        //col = vec3( shinyMatch );\n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n    }\n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llSGzz","date":"1426621364","viewed":181,"name":"shadeaday ( 3 / 17 / 2015 )","username":"cabbibo","description":"Un modding  yesterdays.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""}}