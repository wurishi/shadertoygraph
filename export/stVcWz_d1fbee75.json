{"ver":"0.1","info":{"id":"stVcWz","date":"1661320004","viewed":211,"name":"Fast Fourier Transform _","username":"Envy24","description":"Green                      - function to be sampled,\nPurple                     - samples,\nRed (cross)              - restored values,\nBlue (horizontal)       - real part of DFT,\nLight blue (diagonal) - imagine part of DFT.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spectrum","fast","inverse","fourier","discrete","transform","dft","idft"],"hasliked":0,"parentid":"st3yDl","parentname":"Discrete Fourier Transform"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define TAU                         6.2831853071795862\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SMAA(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n/* */\n#define M        ( 3. )\n#define func(x)  ( (x)*sin(M*(x)) )\n#define deriv(x) ( sin(M*(x))+M*(x)*cos(M*(x)) )\n/* *\n#define M        ( 2.0 )\n#define func(x)  ( sin(M*(x)) )\n#define deriv(x) ( M*cos(M*(x)) )\n/* *\n#define func(x)  ( (x) )\n#define deriv(x) ( 1. )\n/* *\n#define func(x)  ( (x)*(x) )\n#define deriv(x) ( 2.*(x) )\n/* *\n#define func(x)  ( (x)*(x)*(x) ) \n#define deriv(x) ( 3.*(x)*(x) )\n/* *\n#define func(x)  ( abs(x) ) \n#define deriv(x) ( (x)/abs(x) )\n/* *\nfloat pulseOsc(\n    float amplitude,   // in range [0.0; 1.0]\n    float frequency,   // > 0.0\n    float time,        \n    float phase_shift,\n    float pulse_width)\n{\n    float phase = phase_shift + time * TAU * frequency;\n    \n    float sign_ = fract(phase / TAU) >= pulse_width ? 1.0 : -1.0;\n\n    return sign_ * amplitude;\n}\n#define func(x) ( pulseOsc(1., 1., x, 0., 0.5) )\n#define deriv(x) ( 0. )\n/* *\nfloat rectangle(float T, float x)\n{\n    float T2 = T*0.5, T4 = T*0.4;\n    \n    return \n        (x>=-T2)&&(x<-T4) ?\n            -1. :\n            (x>=-T4)&&(x<T4) ?\n                1. :\n                -1.;\n}\n#define func(x) ( rectangle(PI, x) )\n#define deriv(x) ( 0. )\n/* *\nfloat impulse(float x, float x0)\n{\n    return \n        abs(x-x0) < 1e-14 ?\n            1. :\n            0.;\n}\n#define func(x) ( impulse(x, 0.) )\n#define deriv(x) ( 0. )\n/* */\n\n#define NTH_POWER_OF_TWO(n) ( 1 << clamp((n), 0, 8) )\n\nconst int N = NTH_POWER_OF_TWO(4);\nvec2 samples[N]; // Time domain signal -> Frequency domain signal -> Restored time domain signal\n\nvoid sample_func(\n    inout vec2 samples[N],\n    in float a,\n    in float b)\n{\n    float dx = (b-a)/float(N);\n\n    for(int i = 0; i < N; ++i)\n    {\n        samples[i] = vec2(func(a+float(i)*dx), 0.);\n    }\n}\n\nbool is_power_of_two(int x)\n{\n    return ((x != 0) && ((x & (~x + 1)) == x));\n}\n\n/*\n    Works only for powers of two.\n*/\nint log2_(int value)\n{\n    int exponent = 0;    \n    while ((1 << exponent) < value) { ++exponent; }\n    return exponent;\n}\n\nint bit_reverse(\n    in int value,\n    in int numOfBits)\n{\n    int bits = value, mask = 1, reversed = 0;\n\n    for (int bitIdx = 0, limit = numOfBits - 1; bitIdx <= limit; ++bitIdx)\n    {\n        reversed |= (((bits >> bitIdx) & mask) << (limit - bitIdx));\n    }\n\n    return reversed;\n}\n\nvoid sort_bit_reverse_order(\n    inout vec2 array[N],\n    in int N)\n{\n    if (is_power_of_two(N) == false) { return; }\n\n    int numOfBits = log2_(N);\n\n    for (int idx = 1, limit = N - 2; idx < limit; ++idx)\n    {\n        int reversedIdx = bit_reverse(idx, numOfBits);\n\n        if (reversedIdx <= idx) { continue; }\n\n        vec2 tmp = array[idx];\n        array[idx] = array[reversedIdx];\n        array[reversedIdx] = tmp;\n    }\n}\n\nvec2 cmul(vec2 l, vec2 r) { return vec2(l.x*r.x - l.y*r.y, l.x*r.y + l.y*r.x); }\n\nvoid FFT(\n    inout vec2 samples[N],\n    in int N)\n{\n    sort_bit_reverse_order(samples,  N);\n\n    for (int level = 2; level <= N; level <<= 1)\n    {\n        float base_freq = TAU / float(level);\n        vec2 phasor = vec2(cos(base_freq), sin(base_freq));\n\n        for (int blockIdx = 0; blockIdx < N; blockIdx += level)\n        {\n            vec2 w = vec2(1.0, 0.0);\n\n            for (int butterflyIdx = 0, limit = level >> 1; butterflyIdx < limit; ++butterflyIdx)\n            {\n                vec2 u = samples[blockIdx + butterflyIdx];\n                vec2 v = cmul(samples[blockIdx + butterflyIdx + limit], w);\n\n                samples[blockIdx + butterflyIdx] = u + v;\n                samples[blockIdx + butterflyIdx + limit] = u - v;\n\n                w = cmul(w, phasor);\n            }\n        }\n    }\n    \n    /* Normalization. Should be uncommented only in FFT or IFFT. */\n    vec2 invN = vec2(1.0 / float(N), 0.);\n\n    for (int sampleIdx = 0; sampleIdx < N; ++sampleIdx)\n    {\n        samples[sampleIdx] = cmul(samples[sampleIdx], invN);\n    }\n    /**/\n}\n\nvoid IFFT(\n    inout vec2 samples[N],\n    in int N)\n{\n    sort_bit_reverse_order(samples, N);\n\n    for (int level = 2; level <= N; level <<= 1)\n    {\n        float base_freq = -TAU / float(level);\n        vec2 phasor = vec2(cos(base_freq), sin(base_freq));\n\n        for (int blockIdx = 0; blockIdx < N; blockIdx += level)\n        {\n            vec2 w = vec2(1.0, 0.0);\n\n            for (int butterflyIdx = 0, limit = level >> 1; butterflyIdx < limit; ++butterflyIdx)\n            {\n                vec2 u = samples[blockIdx + butterflyIdx];\n                vec2 v = cmul(samples[blockIdx + butterflyIdx + limit], w);\n\n                samples[blockIdx + butterflyIdx] = u + v;\n                samples[blockIdx + butterflyIdx + limit] = u - v;\n                \n                w = cmul(w, phasor);\n            }\n        }\n    }\n\n    /* Normalization. Should be uncommented only in FFT or IFFT. *\n    vec2 invN = vec2(1.0 / float(N), 0.);\n\n    for (int sampleIdx = 0; sampleIdx < N; ++sampleIdx)\n    {\n        samples[sampleIdx] = cmul(samples[sampleIdx], invN);\n    }\n    /**/\n}\n\nfloat magnitude(vec2 z) { return sqrt(z.x*z.x+z.y*z.y); }\nfloat argument(vec2 z) { return atan(z.y, z.x); }\n\nvoid amplitudes_spectrum(\n    inout float amps[N],\n    in vec2 fourier[N])\n{\n    for (int i = 0; i < N; ++i)\n    {\n        amps[i] = magnitude(fourier[i]);\n    }\n}\n\nvoid phases_spectrum(\n    inout float phases[N],\n    in vec2 fourier[N])\n{\n    for (int i = 0; i < N; ++i)\n    {\n        phases[i] = argument(fourier[i]);\n    }\n}\n\nvoid spectrums(\n    inout vec2 spectr[N],\n    in vec2 fourier[N])\n{\n    for (int i = 0; i < N; ++i)\n    {\n        spectr[i].x = magnitude(fourier[i]);\n        spectr[i].y = argument(fourier[i]);\n    }\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 3.5\n#define YSCALE 1.0\n#define OFFSET vec2(0., 0.)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         color.rb -= draw_func(NDC, YSCALE*func(NDC.x), YSCALE*deriv(NDC.x));\n\n    float a = -PI, b = PI, dx = (b-a)/float(N);\n         //color.gb -= vertical_line(NDC, a); color.gb -= vertical_line(NDC, b);\n         color -= horizontal_line(NDC, -PI)*0.2; color -= horizontal_line(NDC, PI)*0.2;\n    \n    /* */\n    sample_func(samples, a, b);\n    FFT(samples, N);\n    /* */\n    \n    for (int i = 0; i < N; ++i)\n    {\n        float x = a+float(i)*dx;\n        vec2 B = vec2(x, 0.), E = vec2(x, func(x));\n        \n        /* Sampled values */\n        color = mix(color, vec3(1, 0, 1), SMAA(diskSDF_L2(NDC, B, UNIT*2.2)));\n        color = mix(color, vec3(1, 0, 1), SMAA(diskSDF_L2(NDC, E, UNIT*2.2)));\n        color = mix(color, vec3(1, 0, 1), SMAA(segmentSDF_L2(NDC, B, E)));\n        /* Sampled values */\n        \n        float s = 0.;     \n        B = vec2(x, s), E = vec2(x, samples[i].x - s);     \n        vec2 offs = vec2(0.1, 0.);\n        \n        /* Real part */\n        color = mix(color, vec3(0., 0, 1.), SMAA(segmentSDF_L2(NDC, E-offs, E+offs)));\n        color = mix(color, vec3(0., 0, 1), SMAA(segmentSDF_L2(NDC, B, E)));\n        /* Real part */\n        \n        offs = vec2(0.1, 0.1);\n        E = vec2(x, samples[i].y - s);\n        \n        /* Imaginary part */\n        color = mix(color, vec3(0.1, 0.5, 1), SMAA(segmentSDF_L2(NDC, E-offs, E+offs)));\n        color = mix(color, vec3(0.1, 0.5, 1), SMAA(segmentSDF_L2(NDC, B, E)));\n        /* Imaginary part */\n\n    }\n    \n    /**\n    spectrums(samples, samples);\n    \n    for (int i = 0; i < N; ++i)\n    {\n        float x = a+float(i)*dx;\n        vec2 B = vec2(x, 0.), E = vec2(x, samples[i].x);\n\n        /* Amplitudes *\n        vec2 offs = vec2(0.1, 0.);    \n        color = mix(color, vec3(0.5, 0, 0.5), SMAA(segmentSDF_L2(NDC, E-offs, E+offs)));\n        /* Amplitudes */\n                     \n        /* Phases *\n        B = vec2(x, 0.), E = vec2(x, samples[i].y);\n        offs = vec2(0., 0.1);    \n        color = mix(color, vec3(0., 0.5, 0.5), SMAA(segmentSDF_L2(NDC, E+offs, E-offs)));\n        /* Phases *\n    }\n    /**/ \n    \n    /**/\n    IFFT(samples, N);\n    \n    for (int i = 0; i < N; ++i)\n    {\n        float x = a+float(i)*dx;\n        vec2 B = vec2(x, 0.), E = vec2(x, samples[i]);\n\n        // Restored values\n        vec2 offs = vec2(0.1, 0.);    \n        color = mix(color, vec3(1., 0, 0), SMAA(segmentSDF_L2(NDC, E-offs, E+offs)));\n             offs = vec2(0., 0.1);    \n        color = mix(color, vec3(1., 0, 0), SMAA(segmentSDF_L2(NDC, E+offs, E-offs)));\n    }\n    /**/\n    \n \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\nvoid DFT(\n    inout vec2 FDS[N+1],\n    in float TDS[N])\n{\n    float N_ = float(N),\n          dA = (2.*PI)/(N_-1.),\n          inv = 1./N_;\n    \n    for (float k = 0.; k < N_; k += 1.)\n    {\n        FDS[int(k)] = vec2(0);\n        \n        for (float n = 0.; n < N_; n += 1.)\n        {\n            FDS[int(k)].x += TDS[int(n)]*cos(k*dA*n);\n            FDS[int(k)].y -= TDS[int(n)]*sin(k*dA*n);\n        }\n        \n        FDS[int(k)].x *= inv; FDS[int(k)].y *= inv;\n    }\n}\n\nvoid IDFT(\n    inout float RTDS[N],\n    in vec2 FDS[N+1])\n{\n    float N_ = float(N),\n          dA = (2.*PI)/(N_-1.),\n          inv = 1./N_;\n    \n    for (float n = 0.; n < N_; n += 1.)\n    {\n        RTDS[int(n)] = 0.;\n        \n        for (float k = 0.; k < N_; k += 1.)\n        {\n            RTDS[int(n)] += FDS[int(k)].x*cos(k*dA*n) + FDS[int(k)].y*sin(k*dA*n);\n        }\n        \n        //RTDS[int(n)] /= inv;\n    }\n}\n/**/","name":"Common","description":"","type":"common"}]}