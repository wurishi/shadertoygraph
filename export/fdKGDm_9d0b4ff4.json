{"ver":"0.1","info":{"id":"fdKGDm","date":"1642786120","viewed":84,"name":"Simple 3D rendering","username":"Catarina","description":"Messing around with raytracing","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADOW_BIAS 1.e-4\n\n#define INF 3.402823466e+38\n#define PI  3.1415926535898\n\n#define NULL_MATERIAL Material(vec3(0.),0.,0.,false)\n#define RAYHIT_INFINITY Hit(vec3(INF),vec3(0.),INF,NULL_MATERIAL,false)\n#define LIGHT_SPHERE Sphere(light.pos,0.1,Material(light.color,0.,0.,false))\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material{\n    vec3 albedo;\n    float specularPower;\n    float specularIntensity;\n    bool isLit;\n};\n\nstruct Hit{\n    vec3 point;\n    vec3 normal;\n    float dist;\n    Material material;\n    bool isHit;\n};\n\n\nstruct Sphere{\n    vec3 pos;\n    float radius;\n    Material material;\n};\n\nstruct Light{\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\n\nstruct Scene{\n    Sphere[2] spheres;\n    Light light;\n};\n\nScene createScene(){\n    Material groundMaterial = Material(\n        vec3(1.), // albedo\n        150., // specular power\n        0., // specular intensity\n        true // is lit\n    );\n\n\n    Material sphereMaterial = Material(\n        vec3(1.0, 0.0, 0.0), // albedo\n        150., // specular power\n        0.5, // specular intensity\n        true // is lit\n    );\n\n    Sphere s1 = Sphere(\n        vec3(0., 0., -5.),\n        1.,\n        sphereMaterial\n    );\n    \n    Sphere ground = Sphere(\n        vec3(2., -1001., -5.),\n        1000.,\n        groundMaterial\n    );\n    \n    Sphere[2] spheres = Sphere[](s1, ground);\n    \n    Light light = Light(\n        vec3(0. + cos(iTime)*2., 1.5, -4. + sin(iTime)*2.), // position\n        vec3(1.), // color\n        15. // intensity\n    );\n     \n    \n    Scene scene = Scene(spheres, light);\n    return scene;\n}\n\nHit raySphereIntersection(Sphere sphere, Ray ray){\n    Hit hit = RAYHIT_INFINITY;\n\n    vec3 ro = ray.origin;\n    vec3 rd = ray.direction;\n    vec3 s = sphere.pos;\n    float R = sphere.radius;\n\n    float t = dot(s - ro, rd);\n    if(t < 0.) return hit;\n    vec3 p = ro + rd * t;\n    \n    float y = length(s - p);\n    if(y > R) return hit;\n    float x = sqrt(R*R - y*y);\n    \n    float temp1 = t - x;\n    float temp2 = t + x;\n    float t1 = min(temp1, temp2);\n    if (t1 < 0.) return hit;\n    float dist = t1;\n    \n    hit.point = ro + rd * dist;\n    hit.normal = normalize(hit.point - sphere.pos);\n    hit.dist = dist;\n    hit.material = sphere.material;\n    hit.isHit = true;\n    \n    return hit;\n}\n\nHit castRay(Ray ray, Scene scene){\n    Hit closestHit = RAYHIT_INFINITY;\n    \n    for(int i = 0; i < 2; i++){\n        Hit hit = raySphereIntersection(scene.spheres[i], ray);\n        \n        if(hit.dist < closestHit.dist) closestHit = hit;\n    }\n    // render sphere in point light's location\n    Light light = scene.light;\n    Hit lightHit = raySphereIntersection(LIGHT_SPHERE, ray);\n    if(lightHit.dist < closestHit.dist) closestHit = lightHit;\n    \n    return closestHit;\n}\n\nvec3 getLight(Hit hit, Ray ray, Scene scene)\n{\n    // Unlit material\n    if (!hit.material.isLit)\n        return hit.material.albedo;\n    \n    Light light = scene.light;\n    vec3 ldir = normalize(light.pos - hit.point);\n    float r2 = length(ldir);\n    ldir = ldir / r2;\n    \n    // cast hard shadow\n    float shadowValue = 1.;\n    vec3 shadowRayOrigin = hit.point + hit.normal * SHADOW_BIAS;\n    vec3 shadowRayDirection = ldir;\n    Ray shadowRay = Ray(shadowRayOrigin, shadowRayDirection);\n    for(int i = 0; i < 2; i++){\n        Hit hit = raySphereIntersection(scene.spheres[i], shadowRay);\n        if(hit.isHit){\n            shadowValue = 0.;\n            break;\n        }\n    }\n    \n    // inv square law\n    vec3 li = light.color * (light.intensity / (4. * PI * r2));\n    // lambert\n    float lv = max(dot(ldir, hit.normal), 0.);\n    \n    // specular (Phong)\n    vec3 R = reflect(ldir, hit.normal);\n    vec3 specular = li * pow(max(0.f, dot(R, ray.direction)), hit.material.specularPower);\n    \n    vec3 albedo = hit.material.albedo;\n    vec3 diffuse = albedo * li * lv;\n    \n    return (diffuse + specular * hit.material.specularIntensity) * shadowValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Scene scene = createScene();\n\n    // uvs from (-1.0 to 1.0)\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.);\n    \n    // Creating Ray\n    vec3 rayOrigin = vec3(0., 0., 1.);\n    vec3 rayDirection = normalize(vec3(uv.xy, 0.) - rayOrigin);\n    Ray ray = Ray(rayOrigin, rayDirection);\n    \n    // Casting Ray\n    Hit hit = castRay(ray, scene);\n    \n    if (hit.isHit) color = getLight(hit, ray, scene);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}