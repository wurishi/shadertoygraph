{"ver":"0.1","info":{"id":"XsXfD8","date":"1495805351","viewed":249,"name":"Grid AA using sin()","username":"etale_cohomology","description":"Fork of https://www.shadertoy.com/view/MlVSDW","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["grid","antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/MlVSDW\n\n// Sadly, this grid doesn't admit nonlinear transformations without shearing like crazey!\n// Anyone know how to fix that?\n\n#define ZOOM_FACTOR 4.\n#define ZOOM_SPEED  (iTime * .5)  // Set this to 0. or 1. or -1., for instance\n#define PI          3.14159\n\nfloat draw_grid(vec2 uv){\n  float zoom = ZOOM_FACTOR * (1. + sin(ZOOM_SPEED));\n\n  float antialias = 12. * zoom / iResolution.y;\n  vec2 grid_2D = smoothstep(antialias, .0, abs(sin(PI * zoom * uv)));\n\n  return max(grid_2D.x, grid_2D.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// Center & normalize pixel coordinates!\n  uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * uv;  // Left-multiplication by a unit-complex number!\n\n  float grid = draw_grid(uv);\n  fragColor.rgb = vec3(grid);\n}\n","name":"Image","description":"","type":"image"}]}