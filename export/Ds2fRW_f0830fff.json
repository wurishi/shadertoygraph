{"ver":"0.1","info":{"id":"Ds2fRW","date":"1689496616","viewed":252,"name":"CookTorrance Importance Sampling","username":"totimannino","description":"Better importance sampling than https://www.shadertoy.com/view/DtyXW3\nSo, should converge much faster and is more stable to added geometry. (the extra spheres)","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","brdf","cooktorrance"],"hasliked":0,"parentid":"DtyXW3","parentname":"Cook Torrance Specular BRDF"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 computeFlare(ivec2 filterLen, vec2 pixCoord, vec2 pixDelta, float lumThreshold)\n{\n    float lum = 0.;\n    vec2 pixOffset;\n    vec3 colorOffset;\n    vec3 accumColor = vec3(0.);\n    for(int ii = -filterLen.x; ii <= filterLen.x; ++ii)\n    {\n        for(int jj = -filterLen.y; jj <= filterLen.y; ++jj)\n        {\n            pixOffset = vec2(ii,jj)*pixDelta;\n            colorOffset = texture(iChannel0, pixCoord + pixOffset).rgb;\n            lum = dot(colorOffset, vec3(0.2126, 0.7152, 0.0722));\n            if(lum >= lumThreshold)\n            {\n                vec2 fParams = vec2(ii,jj)/float(filterLen);\n                accumColor = accumColor + vec3(colorOffset)*exp(-dot(fParams,fParams));\n            }\n        }\n    }\n    \n    return accumColor/(float(50*filterLen.x*filterLen.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pixCoord = fragCoord/iResolution.xy;\n    vec2 pixDelta = vec2(1.,1.)/iResolution.xy;\n    fragColor = texture(iChannel0, pixCoord);\n    vec3 flareColor = computeFlare(ivec2(8,4), pixCoord, pixDelta, 3.0);\n    fragColor.rgb = TonemapACES(fragColor.rgb + flareColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626433833\n#define INV_PI 0.318309886183790671537767526745\n#define MAX_DIST 99999999999.\n#define RAY_EPS 0.0001\n\nstruct Primitive\n{\n    int objGeoTypeId;\n    int geoIndexId;\n    int materialModelId;\n    int materialIndexId;\n};\n\n// Geometry\nstruct PlaneDef\n{\n    mat3 onb;\n    vec3 pos;\n};\n\nstruct DiskDef\n{\n    mat3 onb;\n    vec3 pos;\n    float radius;\n};\n\nstruct SphereDef\n{\n    vec3 center;\n    float radius;\n};\n\nstruct BoxSDFDef\n{\n    vec3 halfwidth;\n    vec3 pos;\n    vec4 rotation; // quaternion\n};\n\n// Camera\nstruct CameraDef\n{\n    vec3 pos;\n    vec3 lookAt;\n    float yaw;\n};\n\n// Ray tracing\nstruct Ray\n{\n    vec3 dir;\n    vec3 orig;\n};\n\nstruct TraceInfo\n{\n    Ray sampleRay;\n    vec3 pos;\n    vec3 norm;\n    vec3 color;\n    float dist;\n    int prim;\n};\n\nstruct RaySample\n{\n    Ray ray;\n    vec3 weight;\n};\n\n// Materials\nstruct EmissionMat\n{\n    vec3 emissionColor;\n    float radiance;\n};\n\nstruct LambertMat\n{\n    vec3 diffuseColor;\n};\n\nstruct CookTorranceMat\n{\n    vec3 diffuseColor;\n    vec3 specularColor;\n    vec3 Ni;\n    vec3 No;\n    float roughness;\n    bool metallic;\n};\n\nmat3 constructCameraMat(CameraDef cam) \n{\n\tvec3 cw = normalize(cam.lookAt-cam.pos);\n    vec3 cp;\n    if(abs(cw.x) > 0. || abs(cw.z) > 0.)\n    {\n        cp = vec3(sin(cam.yaw), cos(cam.yaw), 0.);\n    }\n    else\n    {\n        cp = vec3(sin(cam.yaw), 0., cos(cam.yaw));\n    }\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvec4 quaternionMult(vec4 q1, vec4 q2)\n{\n    return vec4(q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y, \n                q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x, \n                q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w, \n                q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n}\n\nvec4 rotationQuaternion(vec3 axis, float angleRadians)\n{\n    float halfAngle = 0.5*angleRadians;\n    return vec4(axis * sin(halfAngle), cos(halfAngle));\n}\n\nvec3 rotate(vec3 orig, vec4 q)\n{\n    return quaternionMult(quaternionMult(q, vec4(orig, 0)), vec4(-q.xyz, q.w)).xyz;\n}\n\nvec3 rayHitPos(Ray ray, float t)\n{\n    return ray.orig + t*ray.dir;\n}\n\nfloat planeIntersect(Ray ray, PlaneDef plane)\n{   \n    float t = dot(plane.onb[2], plane.pos-ray.orig)/dot(plane.onb[2], ray.dir);\n    if(t > RAY_EPS) return t;\n    else return MAX_DIST;\n}\n\nfloat diskIntersect(Ray ray, DiskDef plane)\n{\n    float rdotn = dot(plane.onb[2], ray.dir);\n    if(rdotn > 0.) return MAX_DIST;\n    float t = dot(plane.onb[2], plane.pos-ray.orig)/rdotn;\n    if(t <= RAY_EPS) return MAX_DIST;\n    vec3 dist = rayHitPos(ray, t) - plane.pos;\n    if(length(dist) > plane.radius) return MAX_DIST;\n    else return t;\n}\n\nfloat sphereIntersect(Ray ray, SphereDef s)\n{\n    vec3 tcenter = s.center - ray.orig;\n \tfloat c = dot(tcenter,tcenter)-s.radius*s.radius;\n    float b = 2.0*dot(-tcenter, ray.dir);\n    //assumption is ray.dir is normalized\n    //float a = 1.0;//dot(ray.dir, ray.dir);\n    float det = b*b-4.0*c;\n    vec2 hits = vec2(-1.0,-1.0);\n    if(det > 0.0) {\n    \tfloat t1 = 0.5*(-b+sqrt(det));\n    \tfloat t2 = 0.5*(-b-sqrt(det));\n        if(t1 < t2 && t1 > 0.) return t1;\n        else if(t2 < t1 && t2 > 0.) return t2;\n    }\n    return MAX_DIST;\n}\n\n\nvec3 sphereNorm(SphereDef sd, vec3 pos)\n{\n    return normalize(pos-sd.center);\n}\n\nfloat BoxSDF(vec3 pos, BoxSDFDef aabox)\n{\n    vec3 q = abs(pos) - aabox.halfwidth;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat BoxSDFIntersect(Ray ray, BoxSDFDef aabox)\n{\n\tfloat t = RAY_EPS;\n\tfloat h = 0.0;\n    vec3 rotOrig = rotate(ray.orig-aabox.pos, aabox.rotation);\n    vec3 rotDir = rotate(ray.dir, aabox.rotation);\n\tfor(int i = 0; i < 40; i++)\n\t{\n\t\th = BoxSDF(rotOrig + t*rotDir, aabox);\n\t\tt = t+h;\n\t\tif (h < RAY_EPS) return t;\n\t}\n    \n    return MAX_DIST;\n}\n\nvec3 BoxSDFNorm(BoxSDFDef aabox, vec3 pos)\n{\n\tconst vec2 delta = vec2(0,.1);\n\tvec3 grad;\n    vec3 rotPos = rotate(pos-aabox.pos, aabox.rotation);\n    float psdf = BoxSDF(rotPos, aabox);\n\tgrad.x = psdf - BoxSDF(rotPos - delta.yxx, aabox);\n\tgrad.y = psdf - BoxSDF(rotPos - delta.xyx, aabox);\n\tgrad.z = psdf - BoxSDF(rotPos - delta.xxy, aabox);\n\treturn normalize(grad);\n}\n\n// Frisvad method, from \n// https://backend.orbit.dtu.dk/ws/portalfiles/portal/126824972/onb_frisvad_jgt2012_v2.pdf\n// implementation from https://www.shadertoy.com/view/4lfcDr\nmat3 computeONB(vec3 normal)\n{\n\tmat3 ret;\n\tret[2] = normal;\n\tif(normal.z < -0.999805696) \n    {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[1] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse \n    {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[1] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nvec2 sampleDisk(vec2 uvRand, float radius)\n{\n    float theta = 2.0*PI*uvRand.x;\n\treturn vec2(cos(theta), sin(theta)) * sqrt(uvRand.y*radius);\n}\n\nvec3 sampleCosine(vec2 uvRand)\n{\n\tvec2 disk = sampleDisk(uvRand, 1.);\n\treturn vec3(disk.x, disk.y, sqrt(max(0.0, 1.0 - dot(disk, disk))));\n}\n\nvec3 sampleMicrofacetGGX(vec2 uvRand, float roughness)\n{\n    float theta = 2.0*PI*uvRand.x;\n    vec2 zdev = normalize(vec2(sqrt(1. - uvRand.y), roughness*sqrt(uvRand.y)));\n    return vec3(cos(theta)*zdev.y, sin(theta)*zdev.y, zdev.x);\n}\n\nvec3 fresnelSchlick(float vDotN, vec3 F0)\n{\n    float a = 1. - vDotN;\n\treturn mix(F0, vec3(1.0), a*a*a*a*a);//F0 + (1.0-F0)*a*a*a*a*a;\n}\n\nfloat GGXDistribution(vec3 n, vec3 m, float alpha)\n{\n    float NoM = dot(n,m);\n    if(NoM > 0.)\n    {\n        float alpha2 = alpha*alpha;\n        float NoM2 = NoM*NoM;\n        float den = NoM2*alpha2 + (1. - NoM2);\n        return alpha2/(PI*den*den);\n    }\n    else\n    {\n        return 0.;\n    }\n}\n\nfloat GGXPartialGeometryTerm(vec3 v, vec3 n, vec3 m, float alpha)\n{\n    float VoM2 = abs(dot(v,m));\n    float chi = (VoM2/abs(dot(v,n))) > 0. ? 1. : 0.;\n    VoM2 = VoM2*VoM2;\n    float tan2 = (1. - VoM2)/VoM2;\n    return (2.*chi)/(1. + sqrt(1. + alpha*alpha*tan2));\n}\n\nvec3 weightCookTorrance(float G, vec3 inRayDir, vec3 outRayDir, vec3 surfNorm, vec3 mfNorm)\n{\n    float iDotN = max(0.0, dot(inRayDir, surfNorm));\n    float oDotN = max(0.0, dot(outRayDir, surfNorm));\n    float nDotM = max(0.0, dot(surfNorm, mfNorm));\n    float iDotM = max(0.0, dot(inRayDir, mfNorm));\n    return vec3(iDotM*G/max(0.1, iDotN*nDotM)); // max 0.1 this is to attentuate the ray-edge spike, using a wider distribution might be a better way to solve this\n}\n\nvec3 brdfLambert(LambertMat matParams)\n{\n    return matParams.diffuseColor*INV_PI;\n}\n\n// Cook-Torrance ref: http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\nvec3 brdfCookTorrance(CookTorranceMat matParams, vec3 inRayDir, vec3 outRayDir, vec3 surfNorm)\n{\n    vec3 halfVec = normalize(inRayDir + outRayDir);\n    float G1 = GGXPartialGeometryTerm(inRayDir, surfNorm, halfVec, matParams.roughness);\n    float G2 = GGXPartialGeometryTerm(outRayDir, surfNorm, halfVec, matParams.roughness);\n    float D = GGXDistribution(surfNorm, halfVec, matParams.roughness);\n    \n    vec3 F = matParams.specularColor;\n    if(!matParams.metallic)\n    {\n        vec3 F0 = abs((matParams.Ni - matParams.No)/(matParams.Ni + matParams.No));\n        F = fresnelSchlick(clamp(dot(inRayDir, halfVec), 0., 1.), F0*F0);\n    }\n    return (F*G1*G2*D)/(4.*abs(dot(inRayDir, surfNorm)*dot(outRayDir, surfNorm)));\n}\n\n// Tone mapping and transfer functions\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 TonemapACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Primitives\n#define NPRIMITIVES 26\n\n#define PLANEID 0\n#define DISKID 1\n#define SPHEREID 2\n#define BOXSDFID 3\n\n#define NPLANES 6\n#define NDISKS 6\n#define NSPHERES 11\n#define NBOXSDF 3\n\nPrimitive primitives[NPRIMITIVES];\n\nPlaneDef plane[NPLANES];\nDiskDef disk[NDISKS];\nSphereDef sphere[NSPHERES];\nBoxSDFDef boxsdf[NBOXSDF];\n\n// Materials\n#define EMISSIONID 0\n#define LAMBERTID 1\n#define COOKTORRANCEID 2\n\n#define NMATERIALS 2\n#define NEMISSION 3\n#define NLAMBERT 5\n#define NCOOKTORRANCE 7\n\n#define PATHLENGTH 4\n\nEmissionMat emission[NEMISSION];\nLambertMat lambert[NLAMBERT];\nCookTorranceMat cooktorrance[NCOOKTORRANCE];\n\n// Emission surfaces (for sampling)\n#define NEMISSIONPRIMS 3\nPrimitive emissionPrims[NEMISSIONPRIMS];\n\nint seed = 0;\nint coordIdx = 0;\n\n// tiny encryption algorithm for random sampling\n// https://redirect.cs.umbc.edu/~olano/papers/GPUTEA.pdf\n// implementation from https://www.shadertoy.com/view/4lfcDr\nvoid tinyEncrypt(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg.x;\n    uint v1 = arg.y;\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key.x) ^ (v1 + sum) ^ ((v1 >> 5) + key.y);\n\t\tv1 += ((v0 << 4) + key.z) ^ (v0 + sum) ^ ((v0 >> 5) + key.w);\n\t}\n\targ.x = v0;\n\targ.y = v1;\n}\n\nvec2 random2d()\n{\n  \tuvec2 arg = uvec2(coordIdx, seed++);\n  \ttinyEncrypt(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\nvec3 computeNorm(vec3 hitPos, int primId)\n{\n    if(primitives[primId].objGeoTypeId == PLANEID)\n    {\n        return plane[primitives[primId].geoIndexId].onb[2];\n    }\n    else if(primitives[primId].objGeoTypeId == DISKID)\n    {\n        return disk[primitives[primId].geoIndexId].onb[2];\n    }\n    else if(primitives[primId].objGeoTypeId == SPHEREID)\n    {\n        return sphereNorm(sphere[primitives[primId].geoIndexId], hitPos);\n    }\n    else if(primitives[primId].objGeoTypeId == BOXSDFID)\n    {\n        return BoxSDFNorm(boxsdf[primitives[primId].geoIndexId], hitPos);\n    }\n    else \n    {\n        return vec3(0.);\n    }\n}\n\nTraceInfo traceScene(Ray ray)\n{\n    float minHitT = MAX_DIST;\n    float currHitT = MAX_DIST;\n    int minPrimHit = -1;\n    for(int i = 0; i < NPRIMITIVES; i++)\n    {\n        if(primitives[i].objGeoTypeId == PLANEID)\n        {\n            currHitT = planeIntersect(ray, plane[primitives[i].geoIndexId]);\n        }\n        else if(primitives[i].objGeoTypeId == DISKID)\n        {\n            currHitT = diskIntersect(ray, disk[primitives[i].geoIndexId]);\n        }\n        else if(primitives[i].objGeoTypeId == SPHEREID)\n        {\n            currHitT = sphereIntersect(ray, sphere[primitives[i].geoIndexId]);\n        }\n        else if(primitives[i].objGeoTypeId == BOXSDFID)\n        {\n            currHitT = BoxSDFIntersect(ray, boxsdf[primitives[i].geoIndexId]);\n        }\n        \n        if(currHitT < minHitT)\n        {\n            minHitT = currHitT;\n            minPrimHit = i;\n        }\n    }\n    \n    TraceInfo traceInfo;\n    traceInfo.prim = -1;\n    if(minHitT < MAX_DIST)\n    {\n        traceInfo.dist = minHitT;\n        traceInfo.pos = rayHitPos(ray, minHitT);\n        traceInfo.norm = computeNorm(traceInfo.pos, minPrimHit);\n        traceInfo.prim = minPrimHit;\n        if(primitives[minPrimHit].materialModelId == LAMBERTID)\n        {\n            traceInfo.color = lambert[primitives[minPrimHit].materialIndexId].diffuseColor;\n        }\n        else if(primitives[minPrimHit].materialModelId == COOKTORRANCEID)\n        {\n            traceInfo.color = cooktorrance[primitives[minPrimHit].materialIndexId].specularColor;\n        }\n        else if(primitives[minPrimHit].materialModelId == EMISSIONID)\n        { \n            traceInfo.color = vec3(1.);\n        }\n    }\n    \n    return traceInfo;\n}\n\nRaySample sampleRay(TraceInfo trace, Ray currRay)\n{\n    RaySample rsamp;\n    if(primitives[trace.prim].materialModelId == LAMBERTID)\n    {\n        vec3 sampleRayDir = sampleCosine(random2d());\n        mat3 onb = computeONB(trace.norm);\n        rsamp.ray = Ray(onb*sampleRayDir, trace.pos);\n        // brdf/pdf == albedo - i.e. cos(t)/PI cancels out top and bottom\n        rsamp.weight = lambert[primitives[trace.prim].materialIndexId].diffuseColor;\n    }\n    else if(primitives[trace.prim].materialModelId == COOKTORRANCEID)\n    {\n        CookTorranceMat matParams = cooktorrance[primitives[trace.prim].materialIndexId];\n        vec3 inRayDir = -currRay.dir;\n        vec3 relNorm = trace.norm;\n        vec3 relNi = matParams.Ni;\n        vec3 relNo = matParams.No;\n        if(dot(inRayDir, trace.norm) < 0.)\n        {\n            relNorm = -relNorm;\n            relNi = matParams.No;\n            relNo = matParams.Ni;\n        }\n        \n        mat3 onb = computeONB(relNorm);\n        vec3 mfNorm = onb*sampleMicrofacetGGX(random2d(),  matParams.roughness);\n        \n        // Fresnel term, F\n        vec3 F = matParams.specularColor;\n        vec3 invF = vec3(0.);\n        float Fs = 1.0;\n        if(!matParams.metallic)\n        {\n            vec3 F0 = abs((relNi - relNo)/(relNi + relNo));\n            F = fresnelSchlick(clamp(dot(inRayDir, mfNorm), 0., 1.), F0*F0);\n            Fs = (F.x + F.y + F.z)/3.;\n        }\n        \n        // Partial Geometry Term, G1\n        float G1 = GGXPartialGeometryTerm(inRayDir, relNorm, mfNorm, matParams.roughness);\n        \n        // Distribution, D term\n        float D = GGXDistribution(relNorm, mfNorm, matParams.roughness);\n        \n        vec2 rr = random2d();\n        if(matParams.metallic || (Fs > 0.5*(rr.x + rr.y)))\n        {\n            float rayDotMf = abs(dot(inRayDir, mfNorm));\n            vec3 sampleRayDir = 2.*rayDotMf*mfNorm - inRayDir;\n            float G = G1*GGXPartialGeometryTerm(sampleRayDir, relNorm, mfNorm, matParams.roughness);\n            rsamp.ray = Ray(sampleRayDir, trace.pos);\n            rsamp.weight = (F/Fs)*weightCookTorrance(G, inRayDir, sampleRayDir, trace.norm, mfNorm);\n        }\n        else\n        {\n            vec3 refractRayDir = -normalize((mfNorm + relNi*inRayDir)/relNo);\n            float G = G1*GGXPartialGeometryTerm(refractRayDir, relNorm, mfNorm, matParams.roughness);\n            rsamp.ray = Ray(refractRayDir, trace.pos + RAY_EPS*refractRayDir);\n            rsamp.weight = ((1.-F)/(1.-Fs))*weightCookTorrance(G, inRayDir, refractRayDir, trace.norm, mfNorm);\n        }\n    }\n    else if(primitives[trace.prim].materialModelId == EMISSIONID)\n    {\n        // just pass through\n        rsamp.weight = vec3(1.);\n    }\n    return rsamp;\n}\n\nvec3 brdfMaterial(int matModelId, int matIndexId, vec3 inRayDir, vec3 outRayDir, vec3 surfNorm)\n{\n    if(matModelId == LAMBERTID)\n    {\n        return brdfLambert(lambert[matIndexId]);\n    }\n    else if(matModelId == COOKTORRANCEID)\n    {\n        return brdfCookTorrance(cooktorrance[matIndexId], inRayDir, outRayDir, surfNorm);\n    }\n    else\n    {\n        return vec3(0.); // not implemented\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixOffset = (fragCoord.xy + random2d() - 0.5*iResolution.xy)/iResolution.y;\n    float focalLength = 1.0;\n    \n    // for random2d\n    int coordIdx = int(dot(fragCoord.xy, vec2(1, iResolution.y)));\n    seed = iFrame*coordIdx;\n    \n    // camera\n    CameraDef sceneCam = CameraDef(vec3(0.,-5.,0.), vec3(0.,0.,0.), 0.);\n    mat3 camMat = constructCameraMat(sceneCam);\n    vec3 rayDir = camMat*normalize(vec3(pixOffset, focalLength));\n    \n    // walls\n    plane[0] = PlaneDef(computeONB(vec3(0.,0.,1.)), vec3(0.,0.,-10.));\n    plane[1] = PlaneDef(computeONB(vec3(0.,0.,-1.)), vec3(0.,0.,10.));\n    plane[2] = PlaneDef(computeONB(normalize(vec3(1.,0.,-.75))), vec3(-20.,0.,0.));\n    plane[3] = PlaneDef(computeONB(normalize(vec3(-1.,0.,-.75))), vec3(20.,0.,0.));\n    plane[4] = PlaneDef(computeONB(normalize(vec3(0.,-1.,-.75))), vec3(0.,36.,0.));\n    plane[5] = PlaneDef(computeONB(normalize(vec3(0.,1.,-.75))), vec3(0.,-14.,0.));\n    \n    \n    // light geometry\n    float lightHt = 9.2f;\n    disk[0] = DiskDef(computeONB(vec3(0.,0.,-1.)), vec3(-7., 21., lightHt), 1.5f);\n    disk[1] = DiskDef(computeONB(vec3(0.,0.,-1.)), vec3(0., 21., lightHt), 1.5f);\n    disk[2] = DiskDef(computeONB(vec3(0.,0.,-1.)), vec3(7., 21., lightHt), 1.5f);\n    // light backside\n    disk[3] = DiskDef(computeONB(vec3(0.,0.,1.)), vec3(-7., 21., lightHt), 1.5f);\n    disk[4] = DiskDef(computeONB(vec3(0.,0.,1.)), vec3(0., 21., lightHt), 1.5f);\n    disk[5] = DiskDef(computeONB(vec3(0.,0.,1.)), vec3(7., 21., lightHt), 1.5f);\n    \n    // spheres\n    sphere[0] = SphereDef(vec3(-15.,28.,-4.), 5.0);\n    sphere[1] = SphereDef(vec3(-5.,28.,-4.), 5.0);\n    sphere[2] = SphereDef(vec3(5.,28.,-4.), 5.0);\n    sphere[3] = SphereDef(vec3(15.,28.,-4.), 5.0);\n    sphere[4] = SphereDef(vec3(-15.,23.,-8.), 2.5);\n    sphere[5] = SphereDef(vec3(-10.,23.,-8.), 2.5);\n    sphere[6] = SphereDef(vec3(-5.,23.,-8.), 2.5);\n    sphere[7] = SphereDef(vec3(0.,23.,-8.), 2.5);\n    sphere[8] = SphereDef(vec3(5.,23.,-8.), 2.5);\n    sphere[9] = SphereDef(vec3(10.,23.,-8.), 2.5);\n    sphere[10] = SphereDef(vec3(15.,23.,-8.), 2.5);\n    \n    // arch\n    boxsdf[0] = BoxSDFDef(vec3(1.0,1.0,15.0), vec3(16.,18.,-8.2), rotationQuaternion(normalize(vec3(0.,1.,0.)), 0.2));\n    boxsdf[1] = BoxSDFDef(vec3(1.0,1.0,15.0), vec3(-16.,18.,-8.2), rotationQuaternion(normalize(vec3(0.,-1.,0.)), 0.2));\n    boxsdf[2] = BoxSDFDef(vec3(15.0,1.0,1.0), vec3(0.,18.,6.7), rotationQuaternion(normalize(vec3(0.,-1.,0.)), 0.0));\n    \n    // wall/arch material\n    lambert[0] = LambertMat(vec3(1.,1.,1.));\n    lambert[1] = LambertMat(vec3(.9,0.,.7));\n    lambert[2] = LambertMat(vec3(0.,.9,0.7));\n    lambert[3] = LambertMat(vec3(.9,.5,1.));\n    lambert[4] = LambertMat(vec3(0.1,.1,.9));\n    \n    // sphere materials\n    cooktorrance[0] = CookTorranceMat(vec3(0.9, 0.9, 0.9), vec3(1.,1.,1.), vec3(1.,1.,1.), vec3(1.,1.,1.), 0.03, true);\n    cooktorrance[1] = CookTorranceMat(vec3(0.9, 0.9, 0.9), vec3(1.,1.,1.), vec3(1.,1.,1.), vec3(1.,1.,1.), 0.04, true);\n    cooktorrance[2] = CookTorranceMat(vec3(0.9, 0.9, 0.9), vec3(1.,1.,1.), vec3(1.,1.,1.), vec3(1.,1.,1.), 0.07, true);\n    cooktorrance[3] = CookTorranceMat(vec3(0.9, 0.9, 0.9), vec3(1.,1.,1.), vec3(1.,1.,1.), vec3(1.,1.,1.), 0.1, true);\n    cooktorrance[4] = CookTorranceMat(vec3(0.9, 0.9, 0.9), vec3(1.,1.,1.), vec3(1.,1.,1.), vec3(1.,1.,1.), 0.15, true);\n    cooktorrance[5] = CookTorranceMat(vec3(0.9, 0.9, 0.9), vec3(1.,1.,1.), vec3(1.,1.,1.), vec3(1.,1.,1.), 0.2, true);\n    cooktorrance[6] = CookTorranceMat(vec3(0.9, 0.9, 0.9), vec3(1.,1.,1.), vec3(1.,1.,1.), vec3(1.,1.,1.), 0.3, true);\n    \n    // scene\n    primitives[0] = Primitive(PLANEID, 0, LAMBERTID, 0);\n    primitives[1] = Primitive(PLANEID, 1, LAMBERTID, 0);\n    primitives[2] = Primitive(PLANEID, 2, LAMBERTID, 1);\n    primitives[3] = Primitive(PLANEID, 3, LAMBERTID, 3);\n    primitives[4] = Primitive(PLANEID, 4, LAMBERTID, 2);\n    primitives[5] = Primitive(PLANEID, 5, LAMBERTID, 4);\n    primitives[6] = Primitive(DISKID, 0, EMISSIONID, 0);\n    primitives[7] = Primitive(DISKID, 1, EMISSIONID, 1);\n    primitives[8] = Primitive(DISKID, 2, EMISSIONID, 2);\n    primitives[9] = Primitive(DISKID, 3, LAMBERTID, 0);\n    primitives[10] = Primitive(DISKID, 4, LAMBERTID, 0);\n    primitives[11] = Primitive(DISKID, 5, LAMBERTID, 0);\n    primitives[12] = Primitive(SPHEREID, 0, COOKTORRANCEID, 0);\n    primitives[13] = Primitive(SPHEREID, 1, COOKTORRANCEID, 2);\n    primitives[14] = Primitive(SPHEREID, 2, COOKTORRANCEID, 4);\n    primitives[15] = Primitive(SPHEREID, 3, COOKTORRANCEID, 6);\n    primitives[16] = Primitive(BOXSDFID, 0, LAMBERTID, 0);\n    primitives[17] = Primitive(BOXSDFID, 1, LAMBERTID, 0);\n    primitives[18] = Primitive(BOXSDFID, 2, LAMBERTID, 0);\n    primitives[19] = Primitive(SPHEREID, 4, COOKTORRANCEID, 0);\n    primitives[20] = Primitive(SPHEREID, 5, COOKTORRANCEID, 1);\n    primitives[21] = Primitive(SPHEREID, 6, COOKTORRANCEID, 2);\n    primitives[22] = Primitive(SPHEREID, 7, COOKTORRANCEID, 3);\n    primitives[23] = Primitive(SPHEREID, 8, COOKTORRANCEID, 4);\n    primitives[24] = Primitive(SPHEREID, 9, COOKTORRANCEID, 5);\n    primitives[25] = Primitive(SPHEREID, 10, COOKTORRANCEID, 6);\n    \n    // lights\n    emissionPrims[0] = primitives[6];\n    emissionPrims[1] = primitives[7];\n    emissionPrims[2] = primitives[8];\n    \n    // emission power spectrum\n    emission[0] = EmissionMat(vec3(0.1,0.1,0.9), 300.);\n    emission[1] = EmissionMat(vec3(0.1,0.9,0.1), 300.);\n    emission[2] = EmissionMat(vec3(0.9,0.1,0.1), 300.);\n    \n    vec3 totalColor = vec3(0.);\n    vec3 throughput = vec3(1.);\n    RaySample rsamp = RaySample(Ray(rayDir, sceneCam.pos), vec3(1.));\n    for(int i = 0; i < PATHLENGTH; i++)\n    {\n        TraceInfo trace = traceScene(rsamp.ray);\n        vec3 misRadiance = vec3(0.);\n        float misWeight = 0.0;\n        if(primitives[trace.prim].materialModelId == EMISSIONID)\n        {\n            if(i == 0) // camera ray\n            {\n                totalColor += throughput*emission[primitives[trace.prim].materialIndexId].emissionColor*emission[primitives[trace.prim].materialIndexId].radiance;\n            }\n            break;\n        }\n        else\n        {\n            for(int j = 0; j < NEMISSIONPRIMS; j++)\n            {\n                if(emissionPrims[j].objGeoTypeId == DISKID)\n                {\n                    float lightRadius = disk[emissionPrims[j].geoIndexId].radius;\n                    vec3 sampDisk2D = vec3(sampleDisk(random2d(), lightRadius), 0.);\n                    mat3 diskONB = disk[emissionPrims[j].geoIndexId].onb;\n                    vec3 sampPosToDiskRay = disk[emissionPrims[j].geoIndexId].pos + diskONB*sampDisk2D - trace.pos;\n                    float distToLightSampSqr = dot(sampPosToDiskRay, sampPosToDiskRay);\n                    sampPosToDiskRay = sampPosToDiskRay/sqrt(distToLightSampSqr);\n\n                    TraceInfo traceEmissive = traceScene(Ray(sampPosToDiskRay, trace.pos));\n                    \n                    float lightArea = PI*lightRadius*lightRadius;\n                    float lnDotL = max(0.0001, abs(dot(diskONB[2], sampPosToDiskRay)));\n                    float pdf = distToLightSampSqr/(lightArea*lnDotL);\n                    if((primitives[traceEmissive.prim].objGeoTypeId == emissionPrims[j].objGeoTypeId) && (primitives[traceEmissive.prim].geoIndexId == emissionPrims[j].geoIndexId))\n                    {\n                        vec3 lightRadiance = emission[emissionPrims[j].materialIndexId].emissionColor*emission[emissionPrims[j].materialIndexId].radiance;\n                        float nDotL = max(0.0001, dot(trace.norm, sampPosToDiskRay));\n                        // combining squared pdf weighting...\n                        // this is technically pdf^2 * 1/pdf * radiance * foreshortening * brdf\n                        // but one set of pdfs cancel\n                        misRadiance += pdf*lightRadiance*nDotL*brdfMaterial(primitives[trace.prim].materialModelId, primitives[trace.prim].materialIndexId, -rsamp.ray.dir, sampPosToDiskRay, trace.norm);\n                    }\n                    misWeight += pdf*pdf;\n                }\n            }\n        }\n        \n        if(misWeight > 0.0f)\n        {\n            totalColor += throughput*misRadiance/misWeight;\n        }\n        \n        // sample new ray for next iteration\n        rsamp = sampleRay(trace, rsamp.ray); \n        throughput *= rsamp.weight;\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float accR = 1./float(iFrame+1);\n    vec3 sumColor = texture(iChannel0, uv).rgb*(1. - accR) + totalColor*accR;\n    fragColor = vec4(sumColor, 1.);\n    //fragColor = vec4(totalColor, 1.);\n    //fragColor = random2d().y > 0.2 ? vec4(0.,0.,0.2,1.) : vec4(4.,0.,0.,1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}