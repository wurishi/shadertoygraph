{"ver":"0.1","info":{"id":"ftj3zz","date":"1623249796","viewed":53,"name":"simple cloud shader","username":"okdalto","description":"simple cloud shader","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["cloud","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 tonemapACES( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).xyz;\n    float exposure = 0.06 * (1.0+0.2*sin(0.5*iTime)*sin(1.8*iTime));\n    col = tonemapACES(col * exposure);\n    col = pow(col, vec3(0.2+1.0/2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define LIGHTSTEP 20\n#define CLOUDS_FORWARD_SCATTERING_G (.8)\n#define CLOUDS_BACKWARD_SCATTERING_G (-.2)\n\n\n\n#define coord1(p) (uint(p)*M1)\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\n\n#define EARTH_RADIUS       6300e3\n#define CLOUD_START        800.0\n#define CLOUD_HEIGHT       600.0\n#define SUN_POWER          vec3(1.0,0.9,0.6) * 750.\n#define TransmittanceCoeff vec3(0.8, 0.9, 1.0) * 0.03\n#define LOW_SCATTER        vec3(1.0, 0.7, 0.5)\n#define BAYER_LIMIT 16\n#define BAYER_LIMIT_H 4\n\n// 4 x 4 Bayer matrix\nconst int bayerFilter[BAYER_LIMIT] = int[]\n(\n    0,  8,  2, 10,\n   12,  4, 14,  6,\n    3, 11,  1,  9,\n   15,  7, 13,  5\n);\n\nbool writeToPixel(vec2 fragCoord, int iFrame)\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int index = iFrame % BAYER_LIMIT;\n    return (((iFragCoord.x + BAYER_LIMIT_H * iFragCoord.y) % BAYER_LIMIT)\n            == bayerFilter[index]);\n      \n}\n\n\n\nfloat remap(float value, float origin_min, float origin_max, float new_min, float new_max){\n    return new_min + (((value - origin_min) / (origin_max - origin_min)) * (new_max - new_min));\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    return textureLod(iChannel2, x/32.0, 0.0).x;\n}\n\nfloat fbm( vec3 p )\n{\n    mat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );    \n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\n\n\nfloat getDensity(vec3 p, inout float cloudHeight){\n    float atmoHeight = length(p - vec3(0.0, -EARTH_RADIUS, 0.0)) - EARTH_RADIUS;\n    cloudHeight = clamp((atmoHeight-CLOUD_START)/(CLOUD_HEIGHT), 0.0, 1.0);\n    p.z += iTime*250.3;\n    float largeWeather = clamp((textureLod(iChannel0, -0.00005*p.zx, 0.0).x-0.18)*5.0, 0.0, 2.0);\n    p.x += iTime*222.3;\n    float weather = largeWeather*max(0.0, textureLod(iChannel0, 0.0002*p.zx, 0.0).x-0.28)/0.72;\n    weather *= smoothstep(0.0, 0.5, cloudHeight) * smoothstep(1.0, 0.5, cloudHeight);\n    float cloudShape = pow(weather, 0.3+1.5*smoothstep(0.2, 0.5, cloudHeight));\n    if(cloudShape <= 0.0)\n        return 0.0;    \n    p.x += iTime*248.3;\n    float den= max(0.0, cloudShape-0.7*fbm(p*.01));\n    if(den <= 0.0)\n        return 0.0;\n\n    p.y += iTime*298.2;\n    den = max(0.0, den-0.2*fbm(p*0.05));\n    return largeWeather*0.2*min(1.0, 5.0*den) * 0.5;\n}\nfloat lightStep(vec3 rayPos, vec3 lightDir, float stepSize, float dC, float mu, float cloudHeight){\n    int nbSampleLight = 20;\n\tfloat zMaxl         = 600.;\n    float stepL         = stepSize;\n\n    float density = 0.0;\n    vec3 lightRayPos = rayPos + lightDir * stepSize *hash(dot(rayPos, vec3(12.256, 2.646, 6.356)) + iTime);\n    for(int i = 0; i < LIGHTSTEP; i++){\n        float cloudHeight;\n        density += getDensity(lightRayPos, cloudHeight);\n        lightRayPos += lightDir * stepL;\n    }\n    float scatterAmount = mix(0.008, 1.0, smoothstep(0.96, 0.0, mu));\n    float beersLaw = exp(-stepL*density)+0.5*scatterAmount*exp(-0.1*stepL*density)+scatterAmount*0.4*exp(-0.02*stepL*density);\n    return beersLaw * mix(0.05 + 1.5*pow(min(1.0, dC*8.5), 0.3+5.5*cloudHeight), 1.0, clamp(density*0.4, 0.0, 1.0));\n    \n    \n    //return (0.5*exp(-0.4*stepL*density)*exp(-0.02*stepL*density));\n\n    //return exp(-stepSize*density * TransmittanceCoeff)+0.5*exp(-0.1*stepSize*density * TransmittanceCoeff)+0.4*exp(-0.02*stepSize*density * TransmittanceCoeff);\n    //return exp(-density * stepSize) + exp(-density * 0.25 * stepSize) * 0.7;\n}\n\n/*\nfloat lightRay(vec3 p, float phaseFunction, float dC, float mu, vec3 sun_direction, float cloudHeight)\n{\n    int nbSampleLight = 20;\n\tfloat zMaxl         = 600.;\n    float stepL         = zMaxl/float(nbSampleLight);\n    \n    float lighRayDen = 0.0;    \n    p += sun_direction*stepL*hash(dot(p, vec3(12.256, 2.646, 6.356)) + iTime);\n    for(int j=0; j<nbSampleLight; j++)\n    {\n        float cloudHeight;\n        lighRayDen += getDensity( p + sun_direction*float(j)*stepL, cloudHeight);\n    }    \n    float scatterAmount = mix(0.008, 1.0, smoothstep(0.96, 0.0, mu));\n    float beersLaw = exp(-stepL*lighRayDen)+0.5*scatterAmount*exp(-0.1*stepL*lighRayDen)+scatterAmount*0.4*exp(-0.02*stepL*lighRayDen);\n    return beersLaw * phaseFunction * mix(0.05 + 1.5*pow(min(1.0, dC*8.5), 0.3+5.5*cloudHeight), 1.0, clamp(lighRayDen*0.4, 0.0, 1.0));\n}\n*/\n\nfloat HenyeyGreenstein( float sundotrd, float g) {\n   float gg = g * g;\n   return (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);\n}\n\n\n\nfloat intersectSphere(vec3 origin, vec3 dir, vec3 spherePos, float sphereRad)\n{\n   vec3 oc = origin - spherePos;\n   float b = 2.0 * dot(dir, oc);\n   float c = dot(oc, oc) - sphereRad*sphereRad;\n   float disc = b * b - 4.0 * c;\n   if (disc < 0.0)\n      return -1.0;    \n    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\n   float t0 = q;\n   float t1 = c / q;\n   if (t0 > t1) {\n      float temp = t0;\n      t0 = t1;\n      t1 = temp;\n   }\n   if (t1 < 0.0)\n      return -1.0;\n    \n    return (t0 < 0.0) ? t1 : t0;\n}\n\nfloat numericalMieFit(float costh)\n{\n    // This function was optimized to minimize (delta*delta)/reference in order to capture\n    // the low intensity behavior.\n    float bestParams[10];\n    bestParams[0]=9.805233e-06;\n    bestParams[1]=-6.500000e+01;\n    bestParams[2]=-5.500000e+01;\n    bestParams[3]=8.194068e-01;\n    bestParams[4]=1.388198e-01;\n    bestParams[5]=-8.370334e+01;\n    bestParams[6]=7.810083e+00;\n    bestParams[7]=2.054747e-03;\n    bestParams[8]=2.600563e-02;\n    bestParams[9]=-4.552125e-12;\n    \n    float p1 = costh + bestParams[3];\n    vec4 expValues = exp(vec4(bestParams[1] *costh+bestParams[2], bestParams[5] *p1*p1, bestParams[6] *costh, bestParams[9] *costh));\n    vec4 expValWeight= vec4(bestParams[0], bestParams[4], bestParams[7], bestParams[8]);\n    return dot(expValues, expValWeight);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    float mpx = iMouse.x/iResolution.x * 3.141592 * 2.0;\n    vec3 cameraPos = vec3(0.0, 1.0, 0.0);\n    vec3 target = vec3(0.0, 0.8, 0.0);\n    vec3 front = normalize(vec3(cos(mpx), 0.4, sin(mpx)));\n    vec3 up = vec3(0.0, -1.0, 0.0);\n    vec3 right = cross(front, up);\n    up = cross(front, right);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/ iResolution.y;\n\n    vec3 history = texture(iChannel3, fragCoord/iResolution.xy).xyz;\n\n    if(writeToPixel(fragCoord, iFrame)){\n        fragColor = vec4(history, 1.0);\n        return;\n    }\n    \n    vec3 rayDir = normalize(front * 0.8 + up * uv.y + right * uv.x);\n    \n    \n    \n    \n    \n\n    //vec3 rayDir = normalize(vec3(uv + vec2(0.0, 1.4), 0.0) * 3.0 - cameraPos);\n    vec3 lightDir = normalize( vec3(cos(iTime * 0.8), 0.1, sin(iTime * 0.8)) );\n    vec3 lightDirNrm = normalize(lightDir);\n\n    float sundotrd = dot( rayDir, lightDirNrm);\n    //float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),\n    //    HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), 0.5 );\n    \n    float scattering = numericalMieFit(sundotrd);\n    \n    const float ATM_START = EARTH_RADIUS+CLOUD_START;\n    const float ATM_END = ATM_START+CLOUD_HEIGHT;\n\n    float start = intersectSphere(cameraPos, rayDir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_START); \n    float end  = intersectSphere(cameraPos, rayDir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_END);\n\n\n    float fogDistance = intersectSphere(cameraPos, rayDir, vec3(0.0, -EARTH_RADIUS, 0.0), EARTH_RADIUS);\n\n    float stepSize = (end-start) / float(40);\n    \n    vec3 col = vec3(0.0);\n    vec3 rayPos = cameraPos + rayDir * start;\n    rayPos += rayDir * hash(dot(rayDir, vec3(12.256, 2.646, 6.356)) + iTime) * stepSize; \n    float Transmittance = 1.0;\n    \n    \n    if(fogDistance == -1.0){\n        for(int i = 0; i < 40; i++){\n            float cloudHeight;\n            float density = getDensity(rayPos, cloudHeight);\n\n            if(density > 0.0){\n\n                float shadow = lightStep(rayPos, lightDirNrm, CLOUD_HEIGHT/float(LIGHTSTEP), density, sundotrd, cloudHeight);\n                //float shadow = lightRay(rayPos, scattering, density, sundotrd, lightDirNrm, cloudHeight);        \n                vec3 ambient = (0.5 + 0.6*cloudHeight)*vec3(0.2, 0.5, 1.0)*6.5 + vec3(0.8) * max(0.0, 1.0-2.0*cloudHeight);\n                //vec3 S = (ambient * 0.1 + SUN_POWER * shadow * scattering) * density;\n                vec3 S = (ambient + SUN_POWER * shadow * scattering);\n                S *= density;\n                vec3 Sint = (S - S * exp(-density * stepSize * vec3(1.0)))/ density;\n                col += Sint * Transmittance;\n                Transmittance *= exp(-density * stepSize);\n            }\n            rayPos += rayDir * stepSize;\n        }\n    }\n    //vec3 background = vec3(0.11, 0.3, 0.9) * 2.0;\n\tvec3 background = 6.0*mix(vec3(0.2, 0.52, 1.0), vec3(0.8, 0.95, 1.0), pow(0.5+0.5*sundotrd, 15.0))+mix(vec3(3.5), vec3(0.0), min(1.0, 2.3*rayDir.y));\n    background += Transmittance*vec3(1e4*smoothstep(0.9998, 1.0, sundotrd));\n    col += background * Transmittance;\n    \n\n    fogDistance = intersectSphere(cameraPos, rayDir, vec3(0.0, -EARTH_RADIUS, 0.0), EARTH_RADIUS+160.0);\n    float fogPhase = 0.5*HenyeyGreenstein(sundotrd, 0.7)+0.5*HenyeyGreenstein(sundotrd, -0.6);  \n    col = mix(fogPhase*0.1*vec3(1.0, 0.7, 0.5)*SUN_POWER+10.0*vec3(0.55, 0.8, 1.0), col, exp(-0.0001*fogDistance));\n    \n    \n    col = mix(col, history, 0.6);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}