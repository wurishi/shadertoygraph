{"ver":"0.1","info":{"id":"dlSSzW","date":"1675757550","viewed":91,"name":"Phasing Palette Circles","username":"tarnith","description":"Haven't shadertoyed in a bit. Been working on some C++ projects and came up with a different variant of this for visualizing the phase of oscillators in a VCV Rack module. Figured I'd play with it a bit and turn it into a Shadertoy.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["sdf","instancing"],"hasliked":0,"parentid":"dlSXRW","parentname":"Circle Instances"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tuv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,tuv)*vec4(pow(3.5,2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized -1..+1 coordinates\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // Normalized 0..1 tex coord\n    vec2 tuv = fragCoord/iResolution.xy;\n    \n    // Hold output colour values\n    vec3 col = vec3(0.);\n    \n    \n    \n    for(int i = 0; i < ITERS;i++){\n    \n        // Float circle ID cast\n        float id = float(i);\n        \n        // Center an ID offset around 0 for multiplying with palette\n        float offset = (id+(.5*FITERS))/FITERS;\n        \n        // 2D Rotation matrix \n        uv *= mat2(cos(T),-sin(T),sin(T),cos(T));\n        \n        // Placement determined by ITER points around circle\n        // SCALE to fit viewport and determine circle size\n        float circle = sdCircle(uv+vec2(cos(id/FITERS*TAU),sin(id/FITERS*TAU))*SCALE,SCALE*1.2);\n        \n        // Smoothstep based on screen res to create sharp edge, sdOnion to take an abs slice of SDF\n        circle = smoothstep(1.,0.,sdOnion(circle*iResolution.y*1.2,1.));\n             \n        // Accumulate, palletize circles based on pal function and offset \n        col += circle * pal(iTime*offset, vec3(0.5,0.5,0.5),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25))*offset;\n    \n    }\n    col /= FITERS;\n    // Center\n    tuv -= .5; \n    // Transform scale\n    tuv *= 1.+(sin(T)*.1);\n    // Renormalize\n    tuv += .5;\n    \n    // Output\n    fragColor = vec4(col+texture(iChannel0,tuv).rgb*.33,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tuv = fragCoord/iResolution.xy;\n    vec2 uuv = tuv;\n    tuv -= .5;\n    tuv *= 1.+(cos(-T*1.5)*.1);\n    tuv += .5;\n    fragColor = texture(iChannel0,uuv)+texture(iChannel1,tuv)*.33;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define T iTime*.02*PI\n#define PI 3.14159\n#define TAU 2.*PI\n#define SCALE .16\n#define ITERS 16\n#define FITERS float(ITERS)\n// IQ is the GOAT \nfloat sdCircle(vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdOnion(in float Object, float r){\n    return abs(Object)-r;\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n","name":"Common","description":"","type":"common"}]}