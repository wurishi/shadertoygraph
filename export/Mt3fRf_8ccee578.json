{"ver":"0.1","info":{"id":"Mt3fRf","date":"1540495319","viewed":252,"name":"Pathtraced 2D Shadows","username":"Assossa","description":"Based on https://www.shadertoy.com/view/lltfRB","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","shadows","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 tex   = texture(iChannel1, uv);\n    vec4 light = texture(iChannel0, uv);\n    \n    if(light.w < 0.) {\n        light.w = 1.;\n        fragColor = max(light, vec4(.1, .1, .1, 1.));\n        return;\n    }\n    \n    light /= light.w;\n    \n    fragColor = tex * light;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 64\n#define EPSILON 0.01\n#define TWO_PI 6.28318530718\n#define RAYS_PER_FRAME 10\n\nfloat phi = (sqrt(5.) + 1.) * .5;\n\n// ret.x - Distance\n// ret.y - Object ID\nvec2 scene(vec2 pos) {\n    float dist_o = length(pos - vec2(.5,   0)) - .10; // ID 0\n    float dist_w = length(pos - vec2(.3, -.2)) - .05; // ID 1\n    float dist_g = length(pos                ) - .02; // ID 2\n    float dist = min(min(dist_o, dist_w), dist_g);\n    \n    int id_w = int(dist_w < dist_o && dist_w < dist_g);\n    int id_g = int(dist_g < dist_o && dist_g < dist_w);\n    int id = id_w | (id_g << 1);\n    \n    return vec2(dist, id);\n}\n\nvec3 id_color(float id) {\n    vec3 col = vec3(1);\n    col.xz = vec2((-.8 * id) + 1.8); // (1.0) if id=1, (0.2, 1.0, 0.2) if id=2\n    col *= clamp(id, 0., 1.); // (0.0) if id=0\n    col *= (id * 2.) - 1.; // Brightness\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) * float(iFrame > 1);\n    \n    vec2 ray = uv - .5;\n    ray.x *= iResolution.x / iResolution.y;\n    \n    vec2 init_check = scene(ray);\n    if(init_check.x < EPSILON) {\n        fragColor = vec4(id_color(init_check.y), -1);\n        return;\n    }\n    \n    int ray_frame = iFrame * RAYS_PER_FRAME;\n    \n    for(int ray_index = 0; ray_index < RAYS_PER_FRAME; ++ray_index) {\n        // I couldn't find a hash function that didn't produce patterns\n        // This works perfectly fine even though it converges oddly\n        float ang = float(ray_frame + ray_index) * phi;\n        vec2 dir = vec2(cos(ang), sin(ang));\n        \n        for(int step_index = 0; step_index < MAX_STEPS; ++step_index) {\n            vec2 march = scene(ray);\n            ray += dir * march.x;\n            \n            if(march.x < EPSILON) {\n                vec3 col = id_color(march.y);\n                fragColor += vec4(col, 1.);\n                break;\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}