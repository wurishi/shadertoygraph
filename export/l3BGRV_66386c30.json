{"ver":"0.1","info":{"id":"l3BGRV","date":"1708622386","viewed":59,"name":"Raymarching \"Mountains\"","username":"CODEXi","description":"Simple mountain raymarch shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","beginner","landscape","mountains"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define mapfn scene\nconst vec3 lightPos = vec3(2, 1, 0);\nconst int maxRayLength = 50;\nconst float maxDist = 20.0;\nconst float minDist = 0.001;\nconst float fov = 0.4;\n\nfloat smin(float a, float b) {\n    const float k = 1.0;\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nmat2 rot2d(float angle) {\n    return mat2(\n        cos(angle),-sin(angle),\n        sin(angle),cos(angle) );\n}\n\nfloat sdSphere(vec3 pos, float d) { return length(pos) - d; }\nfloat sdBox(vec3 pos, vec3 size) { vec3 q = abs(pos) - size; return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);}\n\nfloat scene(vec3 pos) {\n    float groundPos = 0.75 + texture(iChannel0, (pos.xz + vec2(iTime * -0.4,sin(iTime * 0.1)) * 14.4) * 0.01).r;\n    float ground = pos.y + groundPos;\n    float sphere = sdSphere(pos - vec3(2, groundPos * 0.05 - 1.0, 0), 0.5);\n    \n    return smin(ground, sphere);\n}\n\n// by inigo quilez\nvec3 getNormal(vec3 p) {\n    const float eps = 0.001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(mapfn(p+h.xyy) - mapfn(p-h.xyy),\n                           mapfn(p+h.yxy) - mapfn(p-h.yxy),\n                           mapfn(p+h.yyx) - mapfn(p-h.yyx) ) );\n}\n\nvec3 march(vec2 uv) {\n    vec3 rayOffset = vec3(5, 0, 0);\n    vec3 rayOrigin = vec3(0, 0, 0) + rayOffset;\n    vec3 rayDir = normalize(vec3(uv * fov, 1));\n    \n    rayDir.xz = rayDir.xz * -rot2d(4.71);\n    rayDir.y -= 0.2;\n    \n    float dist = 0.;\n    vec3 normal = vec3(0.);\n    \n    int i = 0;\n    \n    for (i = 0; i < maxRayLength; i++) {\n        vec3 rayPos = rayOrigin + rayDir * dist;\n        \n        float sceneDist = mapfn(rayPos);\n        \n        normal = normalize(getNormal(rayPos));\n        \n        vec3 diffuse = (vec3(\n            max(0.0, dot(normal, normalize(lightPos - rayPos)))\n        ) * (1.0/dist));\n        if (dist > maxDist) break;\n        if (sceneDist < minDist) return diffuse + -dist * 0.00125;\n        \n        dist += sceneDist;\n    }\n\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    fragColor.xyz = march(uv);\n}","name":"Image","description":"","type":"image"}]}