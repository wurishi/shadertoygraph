{"ver":"0.1","info":{"id":"3t33Wr","date":"1575995514","viewed":1935,"name":"Biquadratic family (hopefully)","username":"inou","description":"Biquadratic family (z^2+a)^2+b\nBased on (or, small modification of):\n \tJulia - Quaternion by inigo quilez\n \thttps://www.shadertoy.com/view/MsfGRr\n\nBy changing TYPE macro, one can choose which parameter set to draw.\n(See the source code for details).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Biquadratic family (z^2+a)^2+b by Hiroyuki Inou\n// Based on (or, small modification of):\n// \tJulia - Quaternion by inigo quilez\n// \thttps://www.shadertoy.com/view/MsfGRr\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// antialais level (1, 2, 3...)\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n// 0: slower escaping algorithm (non-shift locus/bifurcation locus)\n// 1: faster escaping algorithm (connectedness locus)\n// 2: non-escaping locus of the critical value b\n// 3: non-escaping locus of the critical point 0\n#define TYPE 1\n\n// 0: numerical normals (central differences)\n// 1: analytic normals\n// 2: analytic normals optimized\n#define METHOD 1\n\nconst int numIterations = 11;\n\nfloat map( in vec3 p, out vec4 oTrap, in float w0 )\n{\n    vec4 z = vec4(p, w0);\n    \n    vec4 trap = vec4(abs(z.xyz),dot(z,z));\n\n    float n = 2.0;  \n#if TYPE < 3\n    vec2 x = vec2(z.z,z.w); // x = b\n#else\n    vec2 x = vec2(0,0); // x = 0\n#endif    \n    vec2 mda = vec2(0,0); // a derivative of x\n    vec2 mdb = vec2(1,0); // b derivative of x\n\tfloat mz2 = dot(x,x);\n    for( int i=0; i<numIterations; i++ )\n    {\n        // x -> (x^2 + a)^2 + b\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y)+1.0, \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y),\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.x, 2.0*x.x*x.y + z.y);\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y), \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y)+1.0,\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.z, 2.0*x.x*x.y + z.w);\n        \n        mz2 = dot(x,x);\n        \n        if(mz2>10.0) break;\n        n += 2.0;\n    }\n#if TYPE<2    \n    vec2 y = x;\n    vec2 mda1=mda;\n    vec2 mdb1=mdb;\n    float mz21=mz2;\n\n    float m = n;\n    n = 2.0;\n    x = vec2(z.x,z.y); // z = a\n    mda = vec2(1,0);\n    mdb = vec2(0,0);\n\tmz2 = dot(x,x);\n    for( int i=0; i<numIterations; i++ )\n    {\n        // x -> (x^2 + b)^2 + a\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y), \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y)+1.0,\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.z, 2.0*x.x*x.y + z.w);\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y)+1.0, \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y),\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.x, 2.0*x.x*x.y + z.y);\n        \n        mz2 = dot(x,x);\n        if(mz2>10.0) break;\n        n += 2.0;\n    }\n    \n    // choose faster/slower escaping \n#if TYPE==1\n    if (exp2(-m)*log(mz21) > exp2(-n)*log(mz2)) {\n#else\n    if (exp2(-m)*log(mz21) < exp2(-n)*log(mz2)) {\n#endif\n        n=m; x=y; mda=mda1; mdb=mdb1; mz2=mz21;\n    }\n#endif\n    oTrap = trap;\n\n    return 0.25*sqrt(mz2/(dot(mda,mda)+dot(mdb,mdb)))*log(mz2);  \n}\n\n#if METHOD==0\nvec3 calcNormal( in vec3 pos, in float w0 )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, kk, w0 ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk, w0 ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk, w0 ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk, w0 ) );\n}\n#endif\n\n#if METHOD==1\nvec3 calcNormal( in vec3 p, in float w0 )\n{\n    vec4 z = vec4(p,w0);\n    \n    float n = 2.0;    \n#if TYPE < 3\n    vec2 x = vec2(z.z,z.w); // x = b\n#else\n    vec2 x = vec2(0,0); // x = 0\n#endif    \n    vec2 mda = vec2(0,0); // a derivative of x\n    vec2 mdb = vec2(1,0); // b derivative of x\n\tfloat mz2 = dot(x,x);\n    for( int i=0; i<numIterations; i++ )\n    {\n        // x -> (x^2 + a)^2 + b\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y)+1.0, \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y),\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.x, 2.0*x.x*x.y + z.y);\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y), \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y)+1.0,\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.z, 2.0*x.x*x.y + z.w);\n        \n        mz2 = dot(x,x);\n        \n        if(mz2>10.0) break;\n        n += 2.0;\n    }\n#if TYPE<2    \n    vec2 y = x;\n    vec2 mda1=mda;\n    vec2 mdb1=mdb;\n    float mz21=mz2;\n\n    float m = n;\n    n = 2.0;\n    x = vec2(z.x,z.y); // z = a\n    mda = vec2(1,0);\n    mdb = vec2(0,0);\n\tmz2 = dot(x,x);\n    for( int i=0; i<numIterations; i++ )\n    {\n        // x -> (x^2 + b)^2 + a\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y), \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y)+1.0,\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.z, 2.0*x.x*x.y + z.w);\n        mda = vec2(2.0*(mda.x*x.x-mda.y*x.y)+1.0, \n                   2.0*(mda.x*x.y+mda.y*x.x));\n        mdb = vec2(2.0*(mdb.x*x.x-mdb.y*x.y),\n                   2.0*(mdb.x*x.y+mdb.y*x.x));\n        x = vec2(x.x*x.x - x.y*x.y + z.x, 2.0*x.x*x.y + z.y);\n        \n        mz2 = dot(x,x);\n        if(mz2>10.0) break;\n        n += 2.0;\n    }\n    \n    // choose faster/slower escaping \n#if TYPE==1\n    if (exp2(-m)*log(mz21) > exp2(-n)*log(mz2)) {\n#else\n    if (exp2(-m)*log(mz21) < exp2(-n)*log(mz2)) {\n#endif\n        x=y; mda=mda1;mdb=mdb1;\n    }\n#endif\n    return normalize(vec4(x.x*mda.x+x.y*mda.y,\n                          -x.x*mda.y+x.y*mda.x,\n                          x.x*mdb.x+x.y*mdb.y,\n                          -x.x*mdb.y+x.y*mdb.x).xyz);\n}\n#endif\n/*\n#if METHOD==2\nvec3 calcNormal( in vec3 p, in vec4 c )\n{\n    vec4 z = vec4(p,0.0);\n\n    // identity derivative\n    vec4 J0 = vec4(1,0,0,0);\n    vec4 J1 = vec4(0,1,0,0);\n    vec4 J2 = vec4(0,0,1,0);\n    \n  \tfor(int i=0; i<numIterations; i++)\n    {\n        vec4 cz = qconj(z);\n        \n        // chain rule of jacobians (removed the 2 factor)\n        J0 = vec4( dot(J0,cz), dot(J0.xy,z.yx), dot(J0.xz,z.zx), dot(J0.xw,z.wx) );\n        J1 = vec4( dot(J1,cz), dot(J1.xy,z.yx), dot(J1.xz,z.zx), dot(J1.xw,z.wx) );\n        J2 = vec4( dot(J2,cz), dot(J2.xy,z.yx), dot(J2.xz,z.zx), dot(J2.xw,z.wx) );\n\n        // z -> z2 + c\n        z = qsqr(z) + c; \n        \n        if(dot(z,z)>4.0) break;\n    }\n    \n\tvec3 v = vec3( dot(J0,z), \n                   dot(J1,z), \n                   dot(J2,z) );\n\n    return normalize( v );\n}\n#endif\n\n// this method does not work, but in my mind, it should\n#if METHOD==3\nvec3 calcNormal( in vec3 p, in vec4 c )\n{\n    vec4 z = vec4(p,0.0);\n\n    vec4 dz = vec4(1,0,0,0);\n    \n  \tfor(int i=0; i<numIterations; i++)\n    {\n        // z' = 2z'z\n\t\tdz = 2.0*qmul( z, dz );\n        \n        // z -> z2 + c\n        z = qsqr(z) + c; \n        \n        if(dot(z,z)>4.0) break;\n    }\n    \n\tvec4 v = qconj(qmul( dz, qconj(z) ));\n    \n    return normalize( v.xyz );\n}\n#endif\n*/\n\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 res, in float w0 )\n{\n    vec4 tmp;\n    float resT = -1.0;\n\tfloat maxd = 10.0;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<300; i++ )\n    {\n        if( h<0.0001||t>maxd ) break;\n\t    h = map( ro+rd*t, tmp, w0);\n        t += h;\n    }\n    if( t<maxd ) { resT=t; res = tmp; }\n\n\treturn resT;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k, in float w0 )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk, w0);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float w0 )\n{\n\tconst vec3 sun = vec3(  0.577, 0.577,  0.577 );\n    \n\tvec4 tra;\n\tvec3 col;\n    float t = intersect( ro, rd, tra, w0 );\n    if( t < 0.0 )\n    {\n     \tcol = vec3(0.7,0.9,1.0)*(0.7+0.3*rd.y);\n\t\tcol += vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,sun),0.0,1.0), 48.0 );\n\t}\n\telse\n\t{\n        vec3 mate = vec3(1.0,0.8,0.7)*0.3;\n\t\t//mate.x = 1.0-10.0*tra.x;\n        \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, w0 );\n        \n\t\tfloat occ = clamp(2.5*tra.w-0.15,0.0,1.0);\n\t\t\n\n        col = vec3(0.0);\n\n        // sky\n        {\n        float co = clamp( dot(-rd,nor), 0.0, 1.0 );\n        vec3 ref = reflect( rd, nor );\n        //float sha = softshadow( pos+0.0005*nor, ref, 0.001, 4.0);\n        float sha = occ;\n        sha *= smoothstep( -0.1, 0.1, ref.y );\n        float fre = 0.1 + 0.9*pow(1.0-co,5.0);\n            \n\t\tcol  = mate*0.3*vec3(0.8,0.9,1.0)*(0.6+0.4*nor.y)*occ;\n\t\tcol +=  2.0*0.3*vec3(0.8,0.9,1.0)*(0.6+0.4*nor.y)*sha*fre;\n        }\n\n        // sun\n        {\n        const vec3 lig = sun;\n        float dif = clamp( dot( lig, nor ), 0.0, 1.0 );\n        float sha = softshadow( pos, lig, 0.001, 64.0, w0 );\n        vec3 hal = normalize( -rd+lig );\n        float co = clamp( dot(hal,lig), 0.0, 1.0 );\n        float fre = 0.04 + 0.96*pow(1.0-co,5.0);\n        float spe = pow(clamp(dot(hal,nor), 0.0, 1.0 ), 32.0 );\n        col += mate*3.5*vec3(1.00,0.90,0.70)*dif*sha;\n        col +=  7.0*3.5*vec3(1.00,0.90,0.70)*spe*dif*sha*fre;\n        }\n\n        // extra fill\n        {\n        const vec3 lig = vec3( -0.707, 0.000, -0.707 );\n\t\tfloat dif = clamp(0.5+0.5*dot(lig,nor), 0.0, 1.0 );\n        col += mate* 1.5*vec3(0.14,0.14,0.14)*dif*occ;\n        }\n        \n        // fake SSS\n        {\n        float fre = clamp( 1.+dot(rd,nor), 0.0, 1.0 );\n        col += mate* mate*0.6*fre*fre*(0.2+0.8*occ);\n        }\n    }\n\n\treturn pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // anim\n    float time = iTime*.15;\n    //vec4 c = vec4(1.5,1.5,0.7,0.7)*cos( vec4(0.5,3.9,1.4,1.1) + time*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.0,0.0,1.0,0.0);\n\tfloat w0 = sin(time*0.3);\n    \n    // camera\n\tfloat r = 1.5+0.15*cos(0.0+0.29*time);\n    vec3 ro = vec3(           r*cos(0.3+0.37*time), \n\t\t\t\t\t2.3 + 0.8*r*cos(1.0+0.33*time), \n\t\t\t\t\t          r*cos(2.2+0.31*time) );\n    //ro = ro.yxz;\n \tvec3 ta = vec3(0.0,0.0,0.0);\n    float cr = 0.1*cos(0.1*time);\n    \n    \n    // render\n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(float(i),float(j))/float(AA))) / iResolution.y;\n\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(cr), cos(cr),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        col += render( ro, rd, w0 );\n    }\n    col /= float(AA*AA);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tcol *= 0.7 + 0.3*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.25);\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}