{"ver":"0.1","info":{"id":"XlS3Dd","date":"1433521279","viewed":191,"name":"Try iq's ray-plan intersection","username":"tyleeer","description":"Use brute-force way to inverse matrix. \n\niq has a cute formula for inverse 3x3 matrix","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Reference:\n// https://iquilezles.org/blog/?p=2315\n// https://www.shadertoy.com/view/ldfGDB\n\nstruct Intersection {\n   float u; // intersection point's intrinsic u coordinate wrt the planar surface\n   float v; // intersection point's intrinsic v coordinate wrt the planar surfce\n   float t; // intersection point's intrinsic coordinate wrt the ray\n};\n\nmat3 transpose(mat3 A) {\n\n    mat3 B;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n\t\t\tB[i][j] = A[j][i];\n        }\n    }\n    return B;\n}\n    \nmat3 inverse(mat3 A){\n    \n    mat3 C;\n    float d;\n    \n    // Determinant\n    d = A[0][0]*A[1][1]*A[2][2]+A[1][0]*A[2][1]*A[0][2]+A[2][0]*A[0][1]*A[1][2]\n        -A[0][2]*A[1][1]*A[2][0]-A[1][2]*A[2][1]*A[0][0]-A[2][2]*A[0][1]*A[1][0];\n    \n    // Adjoint\n    C[0][0] = A[1][1]*A[2][2]-A[2][1]*A[1][2];\n    C[0][1] = A[2][0]*A[1][2]-A[1][0]*A[2][2];\n    C[0][2] = A[1][0]*A[2][1]-A[2][0]*A[1][1];\n    C[1][0] = A[2][1]*A[0][2]-A[0][1]*A[2][2];\n    C[1][1] = A[0][0]*A[2][2]-A[2][0]*A[0][2];\n    C[1][2] = A[2][0]*A[0][1]-A[0][0]*A[2][1];\n    C[2][0] = A[0][1]*A[1][2]-A[1][1]*A[0][2];\n    C[2][1] = A[1][0]*A[0][2]-A[0][0]*A[1][2];\n    C[2][2] = A[0][0]*A[1][1]-A[1][0]*A[0][1];\n    \n    return transpose(C)/d;\n}\n    \nIntersection castRayWithPlan(vec3 p, vec3 a, vec3 b, vec3 o, vec3 d, float flag) {\n\tIntersection result;\n    vec3 n = cross(a,b);\n\n    if (flag > 0.0) {\n    \t//---------------------------\n        // High school Method\n    \t//---------------------------\n        result.t = dot(p-o,n)/dot(d,n);\n    \tresult.u = dot(o+result.t*d-p,a);\n    \tresult.v = dot(o+result.t*d-p,b);\n    }\n    else {\n        //---------------------------\n        // Linear Algebra\n        //---------------------------\n        mat3 A;\n        A[0] = -d;\n        A[1] = a;\n        A[2] = b;\n        vec3 x = inverse(A)*(o-p);\n        result.t = x[0];\n        result.u = x[1];\n        result.v = x[2];\n    }\n    \n    // boundary check for the planar surface\n    if ( pow(mod(result.u,2.0)-1.0,2.0)+pow(mod(result.v,2.0)-1.0,2.0) > 1.0) {\n        result.t = -1.0;   \n    }\n    \n    return result;\n}\n\nvec2 pixelSpaceToUVSpace(vec2 p, vec2 resolution) {\n  vec2 uv = 2.0*p/resolution-1.0;\n  if (resolution.x > resolution.y)\n      uv[0] *= resolution.x/resolution.y;\n  else\n      uv[1] *= resolution.y/resolution.x;\n  return uv;\n}\n\nfloat signedDistanceToLine(vec2 p, vec2 n,vec2 c) {\n \t// the line passes point c and has n as its normal\n    return dot(p-c,n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = pixelSpaceToUVSpace(fragCoord.xy,iResolution.xy);\n    vec4 color = vec4(1.0,1.0,1.0,1.0);\n    float flag = 0.0;\n    \n    //---------------------------------\n    //         Split screen\n    //---------------------------------\n    vec2 n = vec2(1.0,0.0);\n    vec2 p;\n    if (iMouse.z < 0.01) { // mouse released\n        p = vec2(0.0,0.0);\n    }\n    else { // mouse clicked\n        p = pixelSpaceToUVSpace(iMouse.xy,iResolution.xy);\n    }\n    float d = signedDistanceToLine(uv,n,p);\n    flag = d;\n    \n    \n    //---------------------------------\n    //         Ray Tracing\n    //---------------------------------\n    // Camera extrinsic parameter \n    vec3 C_o = vec3(0.0,0.0,0.0); // camera center\n    vec3 C_x = vec3(1.0,0.0,0.0); // right\n    vec3 C_y = vec3(0.0,1.0,0.0); // up\n    vec3 C_z = vec3(0.0,0.0,1.0); // opposite of lookAt vector\n    float f = 2.0;                // focal length\n    \n    // camera Transformation\n    vec3 T = vec3(0,0,4);\n    mat3 R = mat3(1.0,0.0,0.0, // first column\n                  0.0,1.0,0.0, // second column\n                  0.0,0.0,1.0); // third column\n    \n    // Shoot a ray\n    vec3 ray_o = (uv[0]*C_x+uv[1]*C_y-f*C_z); // ray origin without transformation\n    vec3 ray_dir = (normalize(ray_o));        // ray dir without transformation\n    vec3 ray_o_g = R*ray_o+T;                 // apply transformation\n    vec3 ray_dir_g = R*ray_dir;               // apply transformation\n    \n    \n \tIntersection I = castRayWithPlan(vec3(0.0,-1.0,0.0), vec3(0.0,0.0,1.0),vec3(1.0,0.0,0.0), ray_o_g, ray_dir_g, flag);\n    color = mix(color,vec4(I.u,0.0,0.0,1.0),step(0.0,I.t));\n    \n    // draw splitting line\n    color = mix(color,vec4(0.0,0.0,0.0,1.0),1.0-smoothstep(0.0,0.01,abs(d)));\n    \n\tfragColor = color;\n}","name":"","description":"","type":"image"}]}