{"ver":"0.1","info":{"id":"7tjSzw","date":"1627616854","viewed":113,"name":"Intersection Line Segments","username":"Yusef28","description":"Just a quick exploration with lot's of comments:\n[url]http://blog.jliszka.org/2013/10/24/exact-numeric-nth-derivatives[/url]\nand here:\n[url]http://blog.sigfpe.com/2005/07/automatic-differentiation.html[/url]","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["ad","autodiff","autodiff","automaticdifferentiation","dualnumbers","autodifferentiation","dn"],"hasliked":0,"parentid":"Nl2XRw","parentname":"Intersection Line - Line"},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 26-07-2021                                  //\n// Status: On Going                                        //\n// Topic: Line Segment Intersection                        //\n// Sources: http://paulbourke.net/geometry                 //\n// Listening to: Andromida - Hellscape (FULL ALBUM STREAM) //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n#define line1Col vec3(1.,.2,.5)\n#define line2Col vec3(1.,.3,.3)\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  BACKGROUND GRID DESIGN             //\n      //                                   //\n      /////////////////////////////////////\n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    //graph background\n    vec3 col = vec3(0.1);\n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  LINE INTERSECTION CALCULATIONS     //\n      //                                   //\n      /////////////////////////////////////\n      \n    //Line Points\n    vec2 A1 = vec2(-3.4+sin(iTime),-2.4+sin(iTime+0.5));\n    vec2 B1 = vec2(3.4+sin(iTime+4.),3.4+sin(iTime+2.));\n    \n    vec2 A2 = vec2(-3.3+sin(iTime+1.4),-3.6+sin(iTime+3.));\n    vec2 B2 = vec2(2.3+sin(iTime+0.2),3.1+sin(iTime+0.3));\n    \n    //For line segments we want to create a linear interpolation\n    // x1 + s(x2-x1) is how far we are on the x of a line\n    // same for y, and that's one line. We do that for 2 line and\n    //we get this expression\n    \n    // point1 = (A1.x + s*(B1.x-A1.x)), (A1.y + s*(B1.y-A1.y))\n    // point2 = (A2.x + t*(B2.x-A2.x)), (A2.y + t*(B2.y-A2.y))\n    //the way this is structured differs from the line-line intersection\n    //in that we know the x and y values. The only unknowns are s and t\n    //so to find them we need to set up two equations.\n    //one that means x1 = x2 with s and t as unknowns\n    //and one where y1  = y2 with s and t as unknowns.\n    \n    //we turn that into a linear equation \n    //the point where these two lines is the samw is the point where\n    //the left sides are equal:\n    //(A1x + s(B1x-A1x)) = (A2x + t(B2x-A2x))\n    //as well as the right\n    //(A1y + s(B1y-A1y)) = (A2y + t(B2y-A2y))\n    \n    //so now we are basically in the same position as\n    //with the basic line-line intersection, but we'll want to\n    //have all the additions solved at this point and any\n    //hanging constants are basically the b's in y = mx + b\n    \n    //instead of y,x we have s,t but otherwise it's the same\n    //so we solve and substitute\n    //for x's \n    //first I'll take all those coefficients from above and \n    //put them in smaller containers\n    \n    float B = B2.x-A2.x;\n    float A = B1.x-A1.x;\n    \n    float E = B2.y-A2.y;\n    float D = B1.y-A1.y;\n    \n    float C = A1.x-A2.x;\n    float F = A1.y-A2.y;\n    \n    //there nice and neat\n    // s(A) - t(B) = C;// <- (A1x + s(B1x-A1x)) = (A2x + t(B2x-A2x))\n    // s(D) - t(E) = F;// <- (A1y + s(B1y-A1y)) = (A2y + t(B2y-A2y))\n    \n    //using paper...\n    //getting frustrated...\n    //going to sleep...\n    //waking up and trying again...\n    //http://paulbourke.net/geometry/\n    //trying the obviouse way I ignored for the last few hours...\n    float s = (B*F-C*E)/(A*E-D*B);\n    float t = (A*F-D*C)/(A*E-D*B);\n    //I was trying to sub the answer for s into \n    //one of the neater formulas above but something wasn't working\n    //so I finally went with the basic t solution.\n    \n    //subbing back into the line equations\n    //these are both the same point but on two different lines\n    vec2 pointOnLine1 = vec2(A1.x + s*(B1.x-A1.x), A1.y + s*(B1.y-A1.y));\n    vec2 pointOnLine2 = vec2(A2.x + t*(B2.x-A2.x), A2.y + t*(B2.y-A2.y));\n   \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n        \n    //line 1\n    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n    col = mix(col, vec3(1.,.2,.5), f);//0.5\n    \n    //line 2\n    f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A2, B2, uv)));\n    col = mix(col, vec3(1.,.3,.3), f);\n    \n    \n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);\n    col = mix(col, line1Col, f);\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);\n    col = mix(col, line1Col, f);\n    \n    //segment end points line 2\n    f = 1.-smoothstep(0.03,0.08,length(uv-A2)-0.02);\n    col = mix(col, line2Col, f);\n    //segment end points line 2\n    f = 1.-smoothstep(0.03,0.08,length(uv-B2)-0.02);\n    col = mix(col, line2Col, f);\n    \n    \n    // if s and t are both between 0. and 1. they are\n    // valid for both the linear interpolations we need.\n    // so show the intersection point.\n    if((s >= 0. && s <= 1.) && (t >= 0. && t <= 1.)){\n    \n    //intersection\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-pointOnLine2)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-pointOnLine2)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    \n    }\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n     \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}\n","name":"Image","description":"","type":"image"}]}