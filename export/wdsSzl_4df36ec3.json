{"ver":"0.1","info":{"id":"wdsSzl","date":"1593964477","viewed":248,"name":"boxes in space","username":"kvick","description":"I had other variants of this but they all broke","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n#define PI2 6.28318530718\n\n//Draw line start\n#define DLS(adef) b = adef;\n//Draw line next\n#define DLN(bdef) a = b; b = bdef; color += vec3(1.0, 0., 0.) * getLine(st, a, b);\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n#define HASHSCALE 3.10432424231\nfloat Hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 15.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------------\nfloat Linear(float x, float v0, float v1) \n{\n\treturn (v1-v0)*x + v0;\n}\n\n//--------------------------------------------------------------------------------\nfloat Smoothstep(float x, float v0, float v1) \n{\n\tx = x*x*(3.0-2.0*x);\n\treturn (v1-v0)*x + v0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat Line(vec2 st, vec2 a, vec2 b, float w)\n{\n \tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(aToST, ab) / dot(ab, ab), 0., 1.);\n    float d = length(aToST - ab * t) - w * 0.5;\n    return d;\n}\n\nfloat distToLine(vec2 st, vec2 a, vec2 b)\n{\n\tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(ab, aToST) / dot(ab, ab), 0., 1.);\n    float d = length(a + ab * t - st);\n    \n    //doing some fudging to achieve the falloff line look for vectrex\n    //d /= t * 1.;\n    \n    return d;\n}\n\nfloat getLine(vec2 st, vec2 start, vec2 end)\n{\n    const float jitterIntensity = 0.001;\n    float jitter = Hash(sin(iTime)) * jitterIntensity;\n    \n    float f = 0.;\n    float dist2Line = distToLine(st, start, end) + jitter;\n    \n    f = (0.001 / (dist2Line));\n    \n    return clamp(f, 0., 1.);\n}\n\nvec3 rotZ(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d),\t-sin(d), \t0.,\n        sin(d), cos(d), \t0.,\n        0., \t0., \t\t1.\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotY(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d), \t\t0., \tsin(d), \n        0., \t\t\t1., \t0., \n        -sin(d), \t\t0., \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotX(vec3 b, float d)\n{\n    mat3 A = mat3(\n        1., \t0., \t\t0.,\n        0.,\t\tcos(d),\t\t-sin(d),\n        0.,\t\tsin(d), \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec2 pToS(vec3 p)\n{\n    p = rotY(p, iTime * 0.);\n    p = rotX(p, -0.85 + sin(iTime * 0.2) * 0.1 + 0.1);\n    p = rotZ(p, 0.0);\n    \n    //vec3 pCenter = vec3(-0., 0., pow(max(mod(-iTime * 25.0, 102.0), 4.), 0.25) * 0.75);\n    vec3 pCenter = vec3(0.15, 0.35, -1.45);\n    p += pCenter;\n    \n    p.x += sin(p.z * 1.0);\n    //p.y += cos(p.z * 1.0);\n    //p.y = cos(p.z * 1.0);\n    \n    return vec2(p.x / p.z, p.y / p.z);\n}\n\nvec3 hill(vec2 st)\n{\n    vec3 color = vec3(0.);\n    float flipOver = 5.;\n    float viewAngle = iMouse.x * 0.001;mod(iTime * 0.1, flipOver) - (flipOver * 0.5);\n    vec3 hillColor = vec3(0.5, 0., 0.);\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-1.0, 0.1), vec2(viewAngle, 0.) + vec2(-0.5, 0.2));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.5, 0.2), vec2(viewAngle, 0.) + vec2(-0.1, 0.4));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.1, 0.4), vec2(viewAngle, 0.) + vec2(0.4, 0.2));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.4, 0.2), vec2(viewAngle, 0.) + vec2(0.8, 0.1));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.6, 0.0), vec2(viewAngle, 0.) + vec2(1.0, 0.2));\n    \n    //HillPeak\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.3, 0.3), vec2(viewAngle, 0.) + vec2(-0.18, 0.32));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.18, 0.32), vec2(viewAngle, 0.) + vec2(-0.09, 0.29));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.09, 0.29), vec2(viewAngle, 0.) + vec2(0.01, 0.31));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.01, 0.31), vec2(viewAngle, 0.) + vec2(0.09, 0.29));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.09, 0.29), vec2(viewAngle, 0.) + vec2(0.15, 0.3));\n    \n    //Horizon\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(-1., 0.0), vec2(1., 0.0));\n    return color;\n}\n\nvec3 cube(vec2 st, vec3 pos, float scale, vec3 color)\n{\n \tfloat f = 0.;\n    float yScale = 1.0;\n    \n    vec3[] p = vec3[](\n        (vec3(-scale, -scale * yScale, -scale)),\n    \t(vec3(-scale,  scale * yScale, -scale)),\n        (vec3( scale,  scale * yScale, -scale)),\n    \t(vec3( scale, -scale * yScale, -scale)),\n        \n        (vec3(-scale, -scale * yScale, scale)),\n    \t(vec3(-scale,  scale * yScale, scale)),\n     \t(vec3( scale,  scale * yScale, scale)),\n        (vec3( scale, -scale * yScale, scale))\n    );\n    \n    vec2[8] p_;\n    for (int i = 0 ; i < 8; ++i)\n    {\n        p_[i] = pToS(p[i] + pos);\n    }\n    \n    const int k_edgeMax = 8 * 3;\n    int[] edges = int[](\n        \n        0, 1,\n        1, 2,\n        2, 3,\n        3, 0,\n\t\t       \n\n        //Top\n        4, 5,\n        5, 6,\n        6, 7,\n        7, 4,\n       \n        //Draw connecting lines\n        \n        0, 4,\n        1, 5,\n        2, 6,\n        3, 7\n\t\t\n\n    );\n    \n    for (int i = 0; i < k_edgeMax; i += 2)\n    {\n        const float jitterIntensity = 0.001;//pow(sin(iTime), 3.);\n        const float halfJitter = jitterIntensity * 0.5;\n        vec2 randPointA = vec2(Hash(iTime + float(i + 34)), Hash(iTime + float(i + 3424))) * jitterIntensity - halfJitter;\n        vec2 randPointB = vec2(Hash(iTime + float(i * 2 + 34)), Hash(iTime + float(i * 24))) * jitterIntensity - halfJitter;\n        \n        vec2 pointA = p_[edges[i]] + randPointA;\n        vec2 pointB = p_[edges[i + 1]] + randPointB;\n        \n        f += getLine(st, pointA, pointB);\n        \n    }\n    \n    //Color\n    return color * f * 0.18;   \n}\n\n//================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\tuv.x *= aspect;\n\tvec2 st = uv;\n    st -= vec2(0.5 * aspect, 0.5);\n    \n    //Cool warpy look\n    //st = vec2(pow(pow(st.x, st.x), 2.), pow(st.y, 2.));\n    \n\tfloat f = 0.;\n    vec3 color = vec3(0.);\n    \n    for (float i = 0.; i < 11.0; i += 2.0)\n    {\n        float jMod = (floor(Hash(i) * 8.0));\n        for (float j = -15.0 + jMod; j < 1.0 + jMod; j += 1.0)\n    \t{\n        \tconst float scale = 0.045;\n            const float scaleFactor = (scale + scale * 1.5);\n            const float loopFactor = (0.9 * scaleFactor);\n            \n            vec3 colorCube = vec3(1., 0.3, 0.8);\n            \n            const vec3 colorA = vec3(1.0, 1.0, 0.0);\n            const vec3 colorB = vec3(0.0, 1., 1.0);\n            const vec3 colorC = vec3(1.0, 0.0, 1.0);\n            const vec3 colorNeutral = vec3(1.0, 1.0, 1.0);\n            const vec3 color_Destroyed = vec3(0.0);\n            \n            //vec3 color_threat = vec3(0., 0, 0.);\n            vec3 color_threat = vec3(0.5 + 2.0 * (sin(iTime * 52.0) * 0.5 + 0.5), 0.0, 0.0);\n            \n            float randomFract = Hash(i * j - floor(iTime * 0.03 / loopFactor));\n            colorCube = randomFract < 0.15 ? colorA : \n            \t\t\trandomFract < 0.35 ? colorB : \n            \t\t\trandomFract < 0.5 ? colorC : \n            \t\t\trandomFract < 0.7 ? colorNeutral : \n            \t\t\t//randomFract < 0.9 ? color_Destroyed :\n            \t\t\tcolor_Destroyed;\n            \n            //drawing a line?\n            colorCube = j == (-5.0 + floor(iTime * 0.03 / loopFactor)) ? vec3(3.2, 3., 3.): colorCube;\n            \n            //green cube\n            colorCube = i == 3.0 && j == (-15.0 + floor(iTime * 0.03 / loopFactor)) ? vec3(1.2, 8., 5.): colorCube;\n            \n            //colorCube = vec3(1.);\n            \n            float tickTock = floor(mod(iTime, 2.0));\n            tickTock = sin(iTime) * 0.5 + 0.5;\n            colorCube = mix(colorCube, vec3(1.0, 0.3, 0.3), tickTock);\n            \n        \tcolor += cube(st, vec3(i * scaleFactor * 1.1, j * loopFactor + mod(iTime * 0.03, loopFactor), i * 0.025), scale, colorCube);\n    \t}\n    }\n    \n    float gamma = Smoothstep(st.y, 2.19, 4.0);\n    color = vec3(pow(color.x, gamma), pow(color.y, gamma), pow(color.z, gamma));\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}