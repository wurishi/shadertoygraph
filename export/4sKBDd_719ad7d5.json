{"ver":"0.1","info":{"id":"4sKBDd","date":"1531089781","viewed":846,"name":"FMSR ending scene (dirty)","username":"xinux","description":"https://www.youtube.com/watch?v=Qrvg2w9hVSM\nhttps://www.pouet.net/prod.php?which=76756\n\nends at ~40s","likes":8,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdBXzd","filepath":"https://soundcloud.com/edvind/lbsdsd","previewfilepath":"https://soundcloud.com/edvind/lbsdsd","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DUR (5.323173125 / 4.0) // duration\n#define REPEATS 4.0\n#define TOTALDUR (DUR * REPEATS)\n#define SPD 1.0 // timescale\n#define OFF 0.1 // time offset for audio timings\n\n// thanks to http://mercury.sexy/hg_sdf/\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat rand1d(float n)\n{\n\treturn fract(sin(n) * 43758.5453);\n}\n\nfloat time()\n{\n    return mod((iTime + OFF) * SPD, DUR * REPEATS) / DUR;\n}\n\nfloat time(float offset)\n{\n    return (mod((iTime + OFF) * SPD, DUR * REPEATS) + offset) / DUR;\n}\n\nfloat quart()\n{\n    return mod(time(), 0.25);\n}\n\nfloat quart(float offset)\n{\n    return mod(time(offset), 0.25);\n}\n\nfloat halft()\n{\n    return mod(time(), 0.5);\n}\n\nfloat halft(float offset)\n{\n    return mod(time(offset), 0.5);\n}\n\nfloat wholet()\n{\n    return mod(time(), 1.);\n}\n\nfloat wholet(float offset)\n{\n    return mod(time(offset), 1.);\n}\n\nfloat doublet()\n{\n    return mod(time(), 2.);\n}\n\nfloat doublet(float offset)\n{\n    return mod(time(offset), 2.);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat displacement(vec3 p, float k)\n{\n\treturn sin(k*p.x)*sin(k*p.y)*sin(k*p.z);\n}\n\nfloat texture1(vec2 p)\n{\n    p *= 0.03;\n\n    float a = sin(p.x) * cos(p.y * 0.9 + 0.4) * 2.;\n    float b = cos(p.x * 1.22 + 2.) * sin(p.y * 1.4) * 3.;\n    pR45(p.xy);\n    float c = cos(p.x * 3.22 + 1.) * sin(p.y * 3.4 + 0.5) * 2.;\n    pR45(p.xy);\n    float d = tan(p.x * 3.22 + 2.) * cos(p.y * 3.4 + 0.5) * 2.;\n\n    float x = a + b * c + d;\n\n    float val = cos(x * 1.) * 1.0;\n    val += sin(c) * 0.2;\n    val *= cos(b * 8.) * 0.2 + 1.0;\n    return val;\n}\n\n// returns a sawtooth (0-1) between start and end\nfloat superclamp(float val, float start, float end)\n{\n    float dur = end - start;\n    float halfdur = dur / 2.;\n    float prog = clamp(val, start, end) - start;\n    return (halfdur - abs(prog - halfdur)) / halfdur;\n}\n\nvec4 scene(vec3 p)\n{\n    // float nod = getNoddingFactor();\n    // p *= nod +1.;\n    \n    float orangeTime = 20.6;\n    float orangeness = max(orangeTime, iTime) - orangeTime;\n    \n    // pR(p.zy, -p.z * 0.01);\n    // pR(p.yz, sin(p.z * 0.1) * 0.11);\n    \n    float spinFactor = 0.5 + tan((iTime) * 0.1) * 0.5;\n    \n    pR(p.zy, (p.z * 0.1 + iTime) * 0.1 * sin(-orangeness * 0.15));\n    spinFactor *= 1. - min(0.6, orangeness) * 1.8;\n    \n    spinFactor -= orangeness * 0.01;\n    \n    pR(p.xy, (-p.z * 0.1 + iTime) * spinFactor);\n    \n    \n    pR(p.xy, -orangeness * 0.2);\n    \n    float speed = tan(iTime * 0.1) * 0.1 + 0.7;\n    \n    float orangeness_dist = 0.;\n    orangeness_dist = min(25., orangeness * 5.);\n    vec3 tPos = p + vec3(0., -2. - orangeness_dist, -iTime * 35. * speed);\n    \n    vec3 c = vec3(0.);\n\n    float noise = displacement(tPos * 0.4, 0.5) * 0.4 + 1.;\n    // noise = 1.;\n    float terrain = -tPos.y + noise * sin(1.57 + tPos.x * 0.4) * 2.0;\n    \n    //pos *= rotX(-0.1);\n    // pR(p.xy, 1.);\n    // pR(p.yz, -iTime * 3.14);\n    pR(p.zy, 1.8);\n    \n    float pillar = fBox(p + vec3(0., -1., 2.) + (p.y + 10.) / ((iTime) * 2. + 8.), vec3(0.2, 100., 0.2));\n    pillar = 10000.;\n    \n    //float pillar_noise = texture(iChannel0, tPos.xy * 0.01).r;\n    // float pillar_noise = texture1(tPos.xy * sin(iTime)) * 0.3 + 0.9;\n    // float pillar_noise = displacement(tPos, 0.4) + 0.8;\n    pillar -= 0.2;\n    \n    float ground = smin(pillar, terrain, 3.);\n    \n    // float tc = max(0., sin(tPos.z) * 5.) * 2. + 0.4;\n    // float tc = max(0., sin(tPos.x * 1.) * 5.) * 2. + 0.4;\n\n    float tca = max(0., sin(tPos.x) * 3.) * 1.5 + 0.3;\n    float tcb = max(0., sin(tPos.z) * 3.) * 1.5;\n    \n    \n    float tc = tca - tcb;\n    \n    // tc = clamp(tc, 0., 1.);\n    \n    // tc *= length(p);\n    \n    tc -= tan((iTime - 0.3) * 0.1) * 0.6;\n\n    //c = texture(iChannel3, tPos.xz * 0.1).rgb;\n    \n    float orange_c_ratio = min(0.25, orangeness) * 4.;\n    \n    vec3 tint = vec3(0.25, 0.56, 0.96) * (1. - orange_c_ratio) + \n        vec3(0.92, 0.15, 0.05) * (orange_c_ratio);\n    c = tint * tc * 1.5;\n    \n    \n    \n    // c.r = sin(p.x * 3.0) * 5.;\n    // c.b = 0.;\n    \n    //vec3 pillar_c = texture(iChannel1, tPos.xy * 0.1 + vec2(iGlobalTime, -iGlobalTime * 2.5)).rgb;\n    vec3 pillar_c = vec3(1.0, 0.3, 0.05) * 2.;\n    \n    float pillar_c_w = min(1., ground + pillar);\n    \n    c = pillar_c * (1. - pillar_c_w) + c * pillar_c_w;\n    \n    // c += max(0., p.z - 50);\n    \n    return vec4(c, ground);\n}\n\nfloat getDistortFactor()\n{\n    float dur = 10. - clamp(iTime, 9., 10.);\n    \n    return superclamp(doublet(0.), 1.1, 1.2) * dur\n        ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float distorto = getDistortFactor();\n    // fragCoord.x += rand1d(distorto + fragCoord.y) * distorto * 100.;    \n\n    vec3 cameraOrigin = vec3(.0, -0.4, 18.0);\n    cameraOrigin += vec3(sin(iTime) * 3., sin(iTime * 0.4) * 0.5, sin(iTime) * 1.); // gungis\n    ////cameraOrigin += vec3(0., 0., -iGlobalTime * 25.); \n    vec3 cameraTarget = cameraOrigin + vec3(.0, -1., -10);\n    pR(cameraTarget.yx, -iTime * 2.);\n    pR(cameraTarget.xz, -iTime * 1.5);\n\n    vec3 upDirection = vec3(.0, 1.0, .0);\n\n    // pR(upDirection.xz, sin(iGlobalTime * 2.) * 100.0);\n    //upDirection *= rotZ(sin(iGlobalTime * 2.) * 0.1); // gungis\n    //upDirection *= rotX(-abs(sin(iGlobalTime * 0.3)) * 0.7);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    screenPos += (vec2(rand1d(iTime), rand1d(iTime + 1.0)) - 0.5)* 0.02;\n\n\n    float orangeTime = 20.6;\n    float orangeness = max(orangeTime, iTime) - orangeTime;\n    float orange_shake = superclamp(orangeness, 0., 0.8) * 0.23;\n\n    // fx\n    float scaleN = max(.0, 0.1 - halft(-0.1));\n    screenPos *= 1. - 3. * orange_shake; // scale\n    \n    float shakeN = max(.0, 0.2 - doublet(1.22));\n    shakeN += max(.0, 0.1 - halft(1.22)) * 0.2;\n    float shakeDur = 10. - clamp(iTime, 9., 10.);\n    screenPos += (vec2(rand1d(iTime), rand1d(iTime + 1.0)) - 0.5) * shakeN * shakeDur; //shake\n\n    // orange shake\n    screenPos += (vec2(rand1d(iTime), rand1d(iTime + 1.0)) - 0.5) * orange_shake; //shake\n\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    // // nodding\n    // vec3 nodding = getNoddingFactor();\n    // rayDir += nodding * 0.5;\n    \n    \n    const float MAX_DIST = 200000.0;\n    const float EPSILON = 0.1;\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    vec3 color = vec3(0.);\n    vec4 dist_color = vec4(EPSILON, vec3(0.));\n\n    for(int i = 0; i < 200; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n        \n\t\tdist_color = scene(pos);\n        color = dist_color.rgb;\n        dist = dist_color.a;\n        \n        //dist = scene(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n    \n    vec3 bgColor = vec3(0.2, 0.3, 0.45) * 1.0;\n    vec3 fadeColor = vec3(0.3, 0.31, 0.3);\n    \n    if(dist < EPSILON)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n            scene(pos + eps.yxx).a - scene(pos - eps.yxx).a,\n            scene(pos + eps.xyx).a - scene(pos - eps.xyx).a,\n            scene(pos + eps.xxy).a - scene(pos - eps.xxy).a));\n        \n        float diffuse = max(.0, dot(-rayDir, normal));\n        //float diffuse = max(.0, dot(normalize(vec3(0., -100., 5.)), normal));\n        float specular = pow(diffuse, 60.0);\n        \n        vec3 result = vec3(diffuse + specular);\n        \n        //color = color * 0.6 + fadeColor * 0.4;\n        result = result * normalize(fadeColor) * 0.8 + bgColor * 0.4 + 0.05;\n        \n        result *= color * 1.3;\n        \n        fragColor = vec4(result, 1.0);\n    }\n    else\n    {\n        //fragColor = vec4(texture(iChannel1, screenPos * 0.25 - 0.5 + vec2(0., iTime * 0.03)).rgb, 1.0) * 0.6;\n        \n        vec3 bgc = vec3(0.25, 0.56, 0.96);\n\n        pR(screenPos.yx, iTime * 0.1);\n        float x = abs(sin(floor((screenPos.x) * 10.))) * 1.2;\n        fragColor = vec4(bgc * x, 1.);\n    }\n    \n    \n\n    fragColor += scaleN * 10.;\n    \n    float colorFactor = max(0.01, 1.0 - (halft(-0.03)) * 5.0);\n    fragColor = round(fragColor / colorFactor) * colorFactor;\n    \n    fragColor = clamp(fragColor, 0., 1.);\n    float fadetime = 31.;\n    float fadeFactor = clamp(iTime, fadetime, fadetime + 1.) - fadetime;\n    fragColor -= fadeFactor * 0.5;\n    \n    \n    float startFlash = 0.2 - min(0.2, iTime);\n    fragColor += startFlash * 20.;\n}","name":"Image","description":"","type":"image"}]}