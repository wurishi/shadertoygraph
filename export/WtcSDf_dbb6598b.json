{"ver":"0.1","info":{"id":"WtcSDf","date":"1582928935","viewed":169,"name":"Environment Set-Piece","username":"iciar","description":"Lighthouse at night","likes":8,"published":1,"flags":32,"usePreview":1,"tags":["night","lighthouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WATER_DEPTH 2.1\n#define DRAG_MULT 0.048\n#define ITERATIONS_RAYMARCH 13\n#define EPSILON 0.01\n#define OCTAVES 12\n\n\nvec2 random(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Worley noise\nfloat worley(vec2 pos) {\n  // The dimensions of the cell division, based on the dimensions of the screen.\n  float m = 2.1;\n  float n = 2.1;\n\n  // The cell where the current point is\n  vec2 p = vec2(floor((pos.x) * m), floor((pos.y) * n));\n    \n  // The random point within that cell\n  vec2 randVec = p + random(p);\n\n  // Variables to keep track of the closest random point to the current point and their distance\n  vec2 final_point = randVec;\n  vec2 curr_rand = randVec;\n  float dist = 999999.00;\n  float dist2 = 999999.00;\n  float dist3 = 999999.00;\n\n  float result = 0.0;\n\n  // Worley Noise\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      float i_float = float(i);\n      float j_float = float(j);\n      // Random point at the current cell.\n      curr_rand = vec2(p[0] + i_float - 1.0, p[1] + j_float - 1.0) + random(vec2 (p[0] + i_float - 1.0, p[1] + j_float - 1.0));\n      // Distance from random point to current point.\n      float curr_dist = sqrt(pow((pos.x) * m - curr_rand[0], 2.0) + pow((pos.y) * n - curr_rand[1], 2.0));\n      // If the distance is smaller than previous distance, store that distance and the current random point.\n      if (curr_dist < dist) {\n        dist2 = dist;\n        dist = curr_dist;\n        final_point = curr_rand;\n      }\n      else if (curr_dist < dist2) {\n        dist3 = dist2;\n        dist2 = curr_dist;\n      }\n      else if (curr_dist < dist3) {\n        dist3 = curr_dist;\n      }\n    }\n  }\n\n  result = -dist + dist2;\n  result = pow(clamp(result, 0.1, 0.9) - 0.1, 0.5);\n    \n  return result;\n}\n\n\nfloat fbm5(vec2 p) {\n    // Initialize the variables to be used\n    float total = 0.0;\n    float amplitude = 0.5;\n\n    // For loop that interates through octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        total += amplitude * worley(p);\n        p *= 1.5;\n        amplitude *= .7;\n    }\n\n    return total;\n}\n\n\n\n// From: https://www.shadertoy.com/view/4s23zz\nfloat pattern( in vec2 p, out vec2 q, out vec2 r )\n{\n    q.x = fbm5( p + vec2(0.0,0.0) );\n    q.y = fbm5( p + vec2(5.2,1.3) );\n\n    r.x = fbm5( p + 4.0*q + vec2(1.7,9.2) );\n    r.y = fbm5( p + 4.0*q + vec2(8.3,2.8) );\n\n    return fbm5( p  );\n}\n\n\n\n// Transform functions\nvec3 rotX(vec3 p, float x) {\n  x = radians(x);\n  float c = cos(x);\n  float s = sin(x);\n  return vec3(p.x, c*p.y-s*p.z, s*p.y+c*p.z);\n}\n\nvec3 rotY(vec3 p, float y) {\n  y = radians(y);\n  float c = cos(y);\n  float s = sin(y);\n  return vec3(c*p.x+s*p.z, p.y, -s*p.x+c*p.z);\n}\n\nvec3 rotZ(vec3 p, float z) {\n  z = radians(z);\n  float c = cos(z);\n  float s = sin(z);\n  return vec3(c*p.x-s*p.y, s*p.x+c*p.y, p.z);\n}\n\n\n\n// SDFs from https://iquilezles.org/articles/distfunctions\nfloat dot2(in vec2 v ) {return dot(v,v);}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s; \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// Ray marching\n// Based on: https://www.shadertoy.com/view/Xds3zN\nvec2 map(vec3 pos) {\n    vec2 result = vec2( 1e10, 0.0 );\n    \n    vec3 newPos = rotZ(pos + vec3(-2.6, 0.0, -0.2), -5.5) / 0.9;\n    float cone = sdCappedCone((newPos + vec3(0.0, -2.43, 0.0)), 0.08, 0.22, 0.01);\n    float sphere = sdSphere(newPos + vec3(0.0, -2.55, 0.0), 0.025);\n    \n    float top = opSmoothUnion(cone, sphere, 0.02);\n    if (top < result.x) {\n        result.x = top;\n        result.y = 0.0;\n    }\n    \n    top = top * 0.9;\n    \n    float pat = fbm5(pos.xy);\n    top = mix(top, top * pat, 0.4);\n    \n    // Warped fbm\n    vec2 q2 = vec2( fbm5( pos.xy + vec2(0.0,0.0) ), fbm5( pos.xy + vec2(5.2,1.3) ) );\n    float f = fbm5( pos.xy + 3.0*q2 );\n    cone = mix(top, top * f, 0.1);\n    \n    if (cone < result.x) {\n        result.x = cone - 0.01;\n        result.y = 1.0;\n    }\n    \n    \n    return result;\n}\n\n\nvec2 rayCast(vec3 orig, vec3 dir) {\n    vec2 result = vec2(-1.0, -1.0);\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for (int i = 0; i < 70; i++) {\n        if (t >= tmax) {\n            break;\n        }\n        vec3 pos = orig + dir * t;\n        vec2 isect = map(pos);\n        if (isect.x < 0.0001) {\n            result = vec2(t, isect.y);\n            break;\n        }\n        t += isect.x;\n    }\n    \n    return result;\n}\n\n\n\n// From: https://www.shadertoy.com/view/Xds3zNs\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    vec3 colAll = texture( iChannel0, uv ).xyz;\n    \n    // Calculate camera psition/direction.\n    vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 4.5, 1.0 + 2.0, 4.5 );\n    mat3 ca = setCamera( ro, ta, 0.0);\n    vec3 rd = ca * normalize( vec3(p,2.5) );\n    \n    // Make sure top of the lighthouse overlaps light beam\n    vec2 isect = rayCast(ro, rd);\n    if (isect.x > 0.0001) {\n        fragColor = vec4(colAll, 1.0);\n    }\n    \n    else {\n    \n        // Gaussian blur:\n        // Calculate the dimensions of a pixel.\n        float width = 1.0 / iResolution.x;\n        float height = 1.0 / iResolution.y;\n\n\n        // Calculate the values of all the colors that will produce a 5x5 kernel\n        // having the current pixel at the center\n\n        vec3 colBeam = texture( iChannel1, uv ).xyz;\n        vec3 col = colAll + colBeam;\n\n        // The 8 color values of the pixels surrounding the current pixel\n        vec3 col1 = texture(iChannel1, vec2(uv.x + width, uv.y + height)).rgb;\n        vec3 col2 = texture(iChannel1, vec2(uv.x + width, uv.y - height)).rgb;\n        vec3 col3 = texture(iChannel1, vec2(uv.x - width, uv.y + height)).rgb;\n        vec3 col4 = texture(iChannel1, vec2(uv.x - width, uv.y - height)).rgb;\n        vec3 col5 = texture(iChannel1, vec2(uv.x + width, uv.y)).rgb;\n        vec3 col6 = texture(iChannel1, vec2(uv.x - width, uv.y)).rgb;\n        vec3 col7 = texture(iChannel1, vec2(uv.x, uv.y + height)).rgb;\n        vec3 col8 = texture(iChannel1, vec2(uv.x, uv.y - height)).rgb;\n\n        // The next 16 pixel colors surrounding the previous 8 pixels, for a total of 25 colors (5 x 5)\n        vec3 col9 = texture(iChannel1, vec2(uv.x + 2.0 * width, uv.y + 2.0 * height)).rgb;\n        vec3 col10 = texture(iChannel1, vec2(uv.x + 2.0 * width, uv.y - 2.0 * height)).rgb;\n        vec3 col11 = texture(iChannel1, vec2(uv.x - 2.0 * width, uv.y + 2.0 * height)).rgb;\n        vec3 col12 = texture(iChannel1, vec2(uv.x - 2.0 * width, uv.y - 2.0 * height)).rgb;\n\n        vec3 col13 = texture(iChannel1, vec2(uv.x + 2.0 * width, uv.y + height)).rgb;\n        vec3 col14 = texture(iChannel1, vec2(uv.x - 2.0 * width, uv.y + height)).rgb;\n        vec3 col15 = texture(iChannel1, vec2(uv.x + width, uv.y + 2.0 * height)).rgb;\n        vec3 col16 = texture(iChannel1, vec2(uv.x + width, uv.y - 2.0 * height)).rgb;\n        vec3 col17 = texture(iChannel1, vec2(uv.x + 2.0 * width, uv.y - height)).rgb;\n        vec3 col18 = texture(iChannel1, vec2(uv.x - 2.0 * width, uv.y - height)).rgb;\n        vec3 col19 = texture(iChannel1, vec2(uv.x - width, uv.y + 2.0 * height)).rgb;\n        vec3 col20 = texture(iChannel1, vec2(uv.x - width, uv.y - 2.0 * height)).rgb;\n\n        vec3 col21 = texture(iChannel1, vec2(uv.x + 2.0 * width, uv.y)).rgb;\n        vec3 col22 = texture(iChannel1, vec2(uv.x - 2.0 * width, uv.y)).rgb;\n        vec3 col23 = texture(iChannel1, vec2(uv.x, uv.y + 2.0 * height)).rgb;\n        vec3 col24 = texture(iChannel1, vec2(uv.x, uv.y - 2.0 * height)).rgb;\n\n\n        // Calculate the final color by using the kernel values calulated at:\n        // http://dev.theomader.com/gaussian-kernel-calculator/\n        // having sigma = 20 and kernel size = 5\n        vec3 color = (colBeam * 0.0402 +\n                 col1 * \t0.0401 + col2 * \t0.0401 + col3 * \t0.0401 + col4 * \t0.0401\n                 + col5 * 0.04015 + col6 * 0.04015 + col7 * 0.04015 + col8 * 0.04015\n                 + col9 * 0.0398 + col10 * 0.0398 + col11 * 0.0398 + col12 * 0.0398\n                 + col13 * 0.03995 + col14 * 0.03995 + col15 * 0.03995 + col16 * 0.03995\n                 + col17 * 0.03995 + col18 * 0.03995 + col19 * 0.03995 + col20 * 0.03995\n                 + col21 * 0.04 + col22 * 0.04 + col23 * 0.04 + col24 * 0.04);\n\n\n\n        fragColor = vec4(colAll + color, 1.0);\n    }\n} ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define WATER_DEPTH 2.1\n#define DRAG_MULT 0.048\n#define ITERATIONS_RAYMARCH 13\n#define EPSILON 0.01\n#define ZERO (min(iFrame,0))\n\nfloat rand(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n\n// From: https://www.shadertoy.com/view/4ttSWf\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0); \n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    \n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\n\n\nfloat fbm3 (vec2 p) {\n    // Initialize the variables to be used\n    p.x = p.x - 0.5; // Move mountain\n    p.y = p.y - 0.5; // Move mountain\n    float total = 0.0;\n    float amplitude = 0.5;\n    int octaves = 12;\n    \n    //p *= 1.6;\n\n    // For loop that interates through octaves\n    for (int i = 0; i < octaves; i++) {\n        total += amplitude * noise(p);\n        p *= 1.5;\n        amplitude *= .5;\n        //p = 1.1 * m2 * p; // Achieve more irregularities and rockiness\n    }\n\n    return total;\n}\n\n\n\n\nvec2 random(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n// Worley noise\nfloat worley(vec2 pos) {\n  // The dimensions of the cell division, based on the dimensions of the screen.\n  float m = 2.1;\n  float n = 2.1;\n\n  // The cell where the current point is\n  vec2 p = vec2(floor((pos.x) * m), floor((pos.y) * n));\n  //vec2 p = pos;\n  // The random point within that cell\n  vec2 randVec = p + random(p);\n\n  // Variables to keep track of the closest random point to the current point and their distance\n  vec2 final_point = randVec;\n  vec2 curr_rand = randVec;\n  float dist = 999999.00;\n  float dist2 = 999999.00;\n  float dist3 = 999999.00;\n\n  float result = 0.0;\n\n  // Worley Noise\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      float i_float = float(i);\n      float j_float = float(j);\n      // Random point at the current cell.\n      curr_rand = vec2(p[0] + i_float - 1.0, p[1] + j_float - 1.0) + random(vec2 (p[0] + i_float - 1.0, p[1] + j_float - 1.0));\n      // Distance from random point to current point.\n      float curr_dist = sqrt(pow((pos.x) * m - curr_rand[0], 2.0) + pow((pos.y) * n - curr_rand[1], 2.0));\n      // If the distance is smaller than previous distance, store that distance and the current random point.\n      if (curr_dist < dist) {\n        dist2 = dist;\n        dist = curr_dist;\n        final_point = curr_rand;\n      }\n      else if (curr_dist < dist2) {\n        dist3 = dist2;\n        dist2 = curr_dist;\n      }\n      else if (curr_dist < dist3) {\n        dist3 = curr_dist;\n      }\n    }\n  }\n\n  result = -dist + dist2;\n  result = pow(clamp(result, 0.1, 0.9) - 0.1, 0.5);\n\n    \n  return result;\n}\n\n\n\n\n\n\n// value noise, and its analytical derivatives\nvec3 noised2( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    vec2 p = vec2(floor(x));\n    float a = rand((p+vec2(0,0)));\n\tfloat b = rand((p+vec2(1,0)));\n\tfloat c = rand((p+vec2(0,1)));\n\tfloat d = rand((p+vec2(1,1)));\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n\n\nconst mat2 m = mat2(0.8,-0.6,0.6,0.8);\n\nfloat baseFbm( in vec2 p )\n{\n    float a = 0.0;\n    float b = 1.0;\n    vec2  d = vec2(0.0);\n    for( int i=0; i<15; i++ )\n    {\n        vec3 n=noised2(p);\n        d +=n.yz;\n        a +=b*n.x/(1.0+dot(d,d));\n        b *=0.5;\n        p=m*p*2.0;\n    }\n    return a;\n}\n\n\nfloat fbm5(vec2 p) {\n    // Initialize the variables to be used\n    float total = 0.0;\n    float amplitude = 0.5;\n    int octaves = 12;\n\n\n    // For loop that interates through octaves\n    for (int i = 0; i < octaves; i++) {\n        total += amplitude * worley(p);\n        p *= 1.5;\n        amplitude *= .7;\n        //p = 1.1 * m2 * p; // Achieve more irregularities and rockiness\n    }\n\n    return total;\n}\n\n\n\n\n\n\n// Transformation functions\nvec3 rotX(vec3 p, float x) {\n  x = radians(x);\n  float c = cos(x);\n  float s = sin(x);\n  return vec3(p.x, c*p.y-s*p.z, s*p.y+c*p.z);\n}\n\nvec3 rotY(vec3 p, float y) {\n  y = radians(y);\n  float c = cos(y);\n  float s = sin(y);\n  return vec3(c*p.x+s*p.z, p.y, -s*p.x+c*p.z);\n}\n\nvec3 rotZ(vec3 p, float z) {\n  z = radians(z);\n  float c = cos(z);\n  float s = sin(z);\n  return vec3(c*p.x-s*p.y, s*p.x+c*p.y, p.z);\n}\n\n\n\n// SDFs from https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s; \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat dot2(in vec2 v ) {return dot(v,v);}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n// SDF for the lighthouse\nvec2 sdfLighthouse(vec3 p) {\n    vec2 result = vec2( 1e11, 0.0 );\n    \n\tfloat cone = sdCappedCone((p + vec3(0.0, -0.40, 0.0)), 0.05, 0.3, 0.29);\n    if (cone < result.x) {\n        result.x = cone;\n        result.y = 0.0;\n    }\n    \n    cone = sdCappedCone((p + vec3(0.0, -0.78, 0.0)), 0.33, 0.29, 0.24);\n    if (cone < result.x) {\n        result.x = cone;\n        result.y = 1.0;\n    }\n    \n    cone = sdCappedCone((p + vec3(0.0, -1.33, 0.0)), 0.25, 0.24, 0.20);\n    if (cone < result.x) {\n        result.x = cone;\n        result.y = 0.0;\n    }\n    \n    cone = sdCappedCone((p + vec3(0.0, -1.78, 0.0)), 0.25, 0.20, 0.16);\n    if (cone < result.x) {\n        result.x = cone;\n        result.y = 1.0;\n    }\n    \n    cone = sdCappedCone((p + vec3(0.0, -2.05, 0.0)), 0.01, 0.26, 0.26);\n    if (cone < result.x) {\n        result.x = cone;\n        result.y = 0.0;\n    }\n    \n    float post = sdCappedCone((p + vec3(-0.25, -2.11, 0.0)), 0.03, 0.0001, 0.0001);\n    \n    if (post < result.x) {\n     \tresult.x = post;\n        result.y = 0.0;\n    }\n    \n    post = sdCappedCone((p + vec3(-0.18, -2.11, -0.15)), 0.03, 0.0001, 0.0001);\n    \n    if (post < result.x) {\n     \tresult.x = post;\n        result.y = 0.0;\n    }\n    \n    post = sdCappedCone((p + vec3(-0.05, -2.11, -0.24)), 0.03, 0.0001, 0.0001);\n    \n    if (post < result.x) {\n     \tresult.x = post;\n        result.y = 0.0;\n    }\n    \n    post = sdCappedCone((p + vec3(0.13, -2.11, -0.21)), 0.03, 0.0001, 0.0001);\n    \n    if (post < result.x) {\n     \tresult.x = post;\n        result.y = 0.0;\n    }\n    \n    post = sdCappedCone((p + vec3(0.245, -2.10, 0.01)), 0.03, 0.0001, 0.0001);\n    \n    if (post < result.x) {\n     \tresult.x = post;\n        result.y = 0.0;\n    }\n    \n    float torus = sdTorus((p + vec3(0.0, -2.14, 0.0)), vec2(0.25, 0.001));\n    if (torus < result.x) {\n    \tresult.x = torus;\n        result.y = 0.0;\n    }\n    \n    cone = sdCappedCone((p + vec3(0.0, -2.08, 0.0)), 0.1, 0.15, 0.14);\n    if (cone < result.x) {\n        result.x = cone;\n        result.y = 0.0;\n    }\n    \n    cone = sdCappedCone((p + vec3(0.0, -2.28, 0.0)), 0.1, 0.15, 0.16);\n    if (cone < result.x) {\n        result.x = cone;\n        result.y = 2.0;\n    }\n   \n    cone = sdCappedCone((p + vec3(0.0, -2.43, 0.0)), 0.08, 0.22, 0.01);\n    \n    float sphere = sdSphere(p + vec3(0.0, -2.55, 0.0), 0.025);\n    \n    float top = opSmoothUnion(cone, sphere, 0.02);\n    if (top < result.x) {\n        result.x = top;\n        result.y = 0.0;\n    }\n    \n    \n    \n    return result;\n}\n\n\n\nvec2 sdfLighthouseLight(vec3 p) {\n    \n    vec2 result = vec2( 1e11, 0.0 );\n    \n    float sphere = sdSphere(p + vec3(6.8, -1.3, 1.5), 1.5);\n    \n    if (sphere < result.x) {\n     \tresult.x = sphere;\n        result.y = 1.0;\n    }  \n    \n    \n    return result;\n}\n\n\n\n\n// Ocean based on: https://www.shadertoy.com/view/MdXyzX\nvec2 waveDx(vec2 pos, vec2 dir, float speed, float freq) {\n    float x = dot(dir, pos) * freq + iTime * speed;\n    float wave = exp(sin(x) - 2.0); // Subtract by higher number for less steep waves\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat fbmWater(vec2 pos) {\n    pos = pos * 1.3; //This will make the waves more/less spread out \n    float iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for (int i = 0; i < 13; i++) {\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = waveDx(pos, p, speed, phase);\n        pos += normalize(p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2); //The mix value creates the separation of the waves\n        phase *= 1.18; // How chopy the water is (lower value = smoother, higher value = choppier)\n        speed *= 1.07; // Speed of the waves\n    }\n    \n    return w / ws;\n}\n\n\n\n\n// Ray marching\n// Based on: https://www.shadertoy.com/view/Xds3zN\nvec2 map(vec3 pos) {\n    vec2 result = vec2( 1e10, 0.0 );\n    \n    float box = sdBox(rotY(pos + vec3(-2.4, -1.4, -0.2), -30.5), vec3(0.4, 1.1, 0.7));\n   \n    if (box >= result.x) {\n    \treturn result;\n    }\n    \n    vec2 lighthouse = sdfLighthouse(rotZ(pos + vec3(-2.6, 0.0, -0.2), -5.5) / 0.9);\n    lighthouse.x = lighthouse.x * 0.9;\n    \n    // Make surface of the lighthouse less smooth\n    float pat = fbm5(pos.xy);\n\n    lighthouse.x = mix(lighthouse.x, lighthouse.x * pat, 0.4);\n\n    // Warped fbm\n    vec2 q2 = vec2( fbm5( pos.xy + vec2(0.0,0.0) ), fbm5( pos.xy + vec2(5.2,1.3) ) );\n\n    float f = fbm5( pos.xy + 3.0*q2 );\n    lighthouse.x = mix(lighthouse.x, lighthouse.x * f, 0.1);\n    \n    if (lighthouse.x < result.x) {\n        result.x = lighthouse.x - 0.01;\n        result.y = lighthouse.y;\n    }\n\n    return result;\n}\n\n\nvec2 mapLight(vec3 pos) {\n    vec2 result = vec2( 1e10, 0.0 );\n    \n    vec2 lighthouse = sdfLighthouseLight(rotZ(pos + vec3(-2.6, 0.0, -0.2), -5.5) / 0.9);\n    lighthouse.x = lighthouse.x * 0.9;\n    if (lighthouse.x < result.x) {\n        result.x = lighthouse.x - 0.01;\n        result.y = lighthouse.y;\n    }\n    \n    return result;\n}\n\n\nvec2 mapWater(vec3 pos) {\n    float h = pos.y - clamp(-0.2, 0.1, fbmWater(pos.xz) - 0.2);\n    return vec2(h, 2.0);\n}\n\nvec2 mapTerrain(vec3 pos) {\n    float h = pos.y - fbm3(vec2(pos.x, pos.z - 1.0) * 0.6) * 1.5; \n    return vec2(h, 3.0);\n}\n\n\n// Lighthouse ray cast\nvec2 rayCast(vec3 orig, vec3 dir) {\n    vec2 result = vec2(-1.0, -1.0);\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for (int i = 0; i < 70 && t < tmax; i++) {\n        vec3 pos = orig + dir * t;\n        vec2 isect = map(pos);\n        if (isect.x < 0.0001) {\n            result = vec2(t, isect.y);\n            break;\n        }\n        t += isect.x;\n    }\n    \n    return result;\n}\n\n// From: https://iquilezles.org/articles/rmshadows\n// Soft shadows by using how close shadow ray was to hitting the lighthouse\nfloat rayCastShadow(vec3 orig, vec3 dir, float w) {\n  \tfloat tmin = 1.0;\n    float tmax = 20.0;\n\tfloat s = 1.0;\n    \n    float t = tmin;\n    for (int i = 0; i < 70 && t < tmax; i++) {\n        vec3 pos = orig + dir * t;\n        vec2 h = map(pos);\n        \n        s = min(s, 0.1 + 0.9 * h.x / (w * t));\n\n        if (s < 0.0) {\n            break;\n        }\n        \n      \tt += h.x;\n    }\n\t\n    s = max(s, 0.0);\n    return s * s * (3.0 - 2.0 * s); // smoothstep\n}\n\n\n// Used to get moon position for water reflection\nvec2 rayCastLight(vec3 orig, vec3 dir) {\n    vec2 result = vec2(-1.0, -1.0);\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for (int i = 0; i < 70 && t < tmax; i++) {\n        vec3 pos = orig + dir * t;\n        vec2 isect = mapLight(pos);\n        if (isect.x < 0.0001) {\n            result = vec2(t, isect.y);\n            break;\n        }\n        t += isect.x;\n    }\n    \n    return result;\n}\n\n\n\n\n// Based on: https://www.shadertoy.com/view/MdX3Rr\n// Same as other ray casts but this time mapping the water\nvec2 waterRayCast(vec3 orig, vec3 dir) {\n\n    float tmin = 1.0;\n    float tmax = 50.0;\n    \n    float t = tmin;\n\tfor( int i=0; i<50; i++ )\n\t{\n        vec3 pos = orig + t * dir;\n        float h = mapWater(pos).x;\n\t\tif( abs(h)<(0.0015*t) || t>tmax ) break;\n\t\tt += 0.4*h;\n\t}\n\n\treturn vec2(t, 2.0);\n}\n\n\n\nvec2 terrainRayCast(vec3 orig, vec3 dir) {\n    float tmin = 1.0;\n    float tmax = 50.0;\n    \n    float t = tmin;\n    for(int i = 0; i < 50; i++) {\n        vec3 pos = orig + t * dir;\n        float h = pos.y - fbm3(vec2(pos.x, pos.z - 1.0) * 0.6) * 1.5;\n        if( abs(h)<(0.015*t) || t>tmax ) break;\n\t\tt += 0.4*h;\n    }\n    \n    return vec2(t, 3.0);\n}\n\n\n// From: https://www.shadertoy.com/view/Xds3zN\nvec3 calculateNormals(vec3 pos)\n{  \n    vec3 n = vec3(0.0);\n    for( int i = ZERO; i < 4; i++ )\n    {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1),((i >> 1) & 1),(i & 1)) - 1.0);\n        n += e * map(pos + 0.0025 * e).x;\n    }\n    return normalize(n);\n}\n\n\nvec3 waterNormal(vec3 pos) {\n    vec3 n = vec3(0.0);\n    for( int i = ZERO; i < 4; i++ )\n    {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1),((i >> 1) & 1),(i & 1)) - 1.0);\n        n += e * mapWater(pos + 0.0025 * e).x;\n    }\n    return normalize(n);\n}\n\nvec3 terrainNormal(vec3 pos) { \n    \n    vec3 n = vec3(0.0);\n    for( int i = ZERO; i < 4; i++ )\n    {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1),((i >> 1) & 1),(i & 1)) - 1.0);\n        n += e * mapTerrain(pos + 0.0025 * e).x;\n    }\n    return normalize(n);\n}\n\n\n// Based on: https://www.shadertoy.com/view/MlfXWH\nvec3 skyCol = 2.5 * pow(vec3(30.0, 46.0, 64.0)/255.0, vec3(2.2));\nvec3 moonCol = pow(vec3(180.0, 190.0, 210.0)/255.0, vec3(2.2));\nvec3 skyColor(vec3 dir) {\n    vec3 sundir = normalize(vec3(-0.5, 0.5, -1.0));\n    vec3 col = skyCol;\n    \n    // Sky and moon glow and position\n    col += max(0.0, -dir.z) * moonCol * pow(max(dot(sundir, dir), 0.0), 16.0);\n    vec2 moonPos = dir.xy/dir.z - sundir.xy/sundir.z;\n    \n    // Add stars\n    col = mix(col, vec3(1.0, 1.0, 1.0) * 30.0, clamp(rand(dir.xy) - 0.98, 0.0, 1.0) * smoothstep(0.0, 0.9, length(moonPos)));\n    \n\n    float randFbm = baseFbm(moonPos) * 1.5;\n    \n    //col = mix(col, vec3(1.65), max(0.0, -dir.z)*rand*smoothstep(0.37, 0.35, length(moonPos)));\n    \n    // Add moon\n    // Smoothstep makes sure only the circle of the moon gets affected by the color below.\n    // Rand value creates the texture of the moon\n    col = mix(col, vec3(1.8), randFbm * smoothstep(0.37, 0.35, length(moonPos)));\n    \n    \n    \n    return col;\n}\n\n\n// Calculate lighthouse colors\nvec3 computeMaterial(float obj, vec3 p, vec3 n, vec3 light, vec3 view) {\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    if (obj == 0.0) {\n        color = vec3(0.6,0.2,0.1);\n        \n        vec2 q = vec2(0.0);\n        vec2 r = vec2(0.0);\n\n        color = mix( vec3(0.6,0.2,0.1), vec3(0.3,0.05,0.05), fbm5(p.xy));\n        \n        // Warped fbm\n        vec2 q2 = vec2( fbm5( p.xy + vec2(0.0,0.0) ), fbm5( p.xy + vec2(5.2,1.3) ) );\n\n        float f = fbm5( p.xy + 3.0*q2 );\n        color = mix(color, color * vec3(0.8, 0.6, 0.4), f);\n    }\n    else if (obj == 1.0) {\n        color = vec3(1.0, 1.0, 1.0); // * max(0.0, dot(n, light)); // * shadow(light, p, 0.1);\n        float pat = fbm5(p.xy);\n        color = mix( vec3(1.0, 1.0, 1.0), vec3(190.0,170.0,140.0) / 255.0, pat);\n        \n        // Warped fbm\n        vec2 q2 = vec2( fbm5( p.xy + vec2(0.0,0.0) ), fbm5( p.xy + vec2(5.2,1.3) ) );\n\n        float f = fbm5( p.xy + 3.0*q2 );\n        color = mix(color, color * vec3(1.0, 0.95, 0.85), f);\n    }\n    \n    \n  \treturn color;\n}\n\n\n\n\n// From: https://www.shadertoy.com/view/XdsGDB\n// Calculate the reflections of the water by getting the intersection from the \n// water normal to the element being reflected\nvec3 shadeOcean(vec3 pos, vec3 ray, vec2 fragCoord, vec3 dir) {\n    vec3 norm = waterNormal(pos);\n    float ndotr = dot(ray, norm);\n    float fresnel = pow(1.0 - abs(ndotr), 5.0);\n    \n    vec3 reflectedRay = ray - 2.0 * norm * ndotr;\n    vec3 refractedRay = ray + (-cos(1.33 * acos(-ndotr)) - ndotr) * norm;\t\n    refractedRay = normalize(refractedRay);\n    \n    const float crackFudge = 0.0;\n    \n    // reflection\n    vec3 reflection = skyColor(dir);\n    \n    \n    // Calculate base reflection\n    float t = terrainRayCast(pos - crackFudge * reflectedRay, reflectedRay).x;\n\n    \n    if (t > 0.0) {\n        vec3 post = pos + (t - crackFudge) * reflectedRay;\n        reflection = mix(vec3(1.0, 1.0, 1.0), vec3(0.5, 0.2, 0.2), fbm3(vec2(post.x, post.z - 1.0) * 0.6) * 1.5 + 0.2); // terrain color, will change later    \t  \n    }\n    \n    vec3 col = vec3(0.0,.04,.04); // under-sea color\n    col = 2.5 * pow(vec3(40.0, 60.0, 78.0)/255.0, vec3(2.2));\n    if ( t > 0.0 )\n\t{\n        vec3 post = pos + (t - crackFudge) * reflectedRay;\n\t}\n   \n    col = mix( col, reflection, fresnel * 0.8 );\n    \n    \n    // Calculate reflection caused by moon\n    reflection = skyColor(dir);\n    float t2 = rayCastLight(pos - crackFudge * reflectedRay, reflectedRay).x;\n    \n    if (t2 > 0.0) {\n        vec3 post = pos + (t2 - crackFudge) * reflectedRay;\n        reflection = mix(vec3(1.0, 1.0, 1.0), vec3(0.5, 0.2, 0.2), 0.0); // terrain color, will change later    \t  \n    }\n    \n    if ( t2 > 0.0 )\n\t{\n        vec3 post = pos + (t2 - crackFudge) * reflectedRay;\n\t}\n    \n    col = mix( col, reflection, clamp(0.0, 0.8, fresnel * 3.0));\n    \n    \n    return col;\n}\n\n\n\n\n// From: https://www.shadertoy.com/view/Xds3zNs\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Position of the light source:\n    vec3 lightPos = vec3(0.0, 2.5, -0.5);\n    vec3 lightPos2 = vec3(6.0, 4.0, 2.0);\n    \n    \n    vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // Calculate camera position/direction.\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 4.5, 1.0 + 2.0, 4.5 );\n    mat3 ca = setCamera( ro, ta, 0.0);\n    vec3 rd = ca * normalize( vec3(p,2.5) );\n    \n    vec3 dir = normalize(vec3(p, -1.0));\n    \n    \n    // Initial color is the sky color\n    vec3 col = skyColor(dir);\n    \n    // Check intersections\n    vec2 terrainIsect = terrainRayCast(ro, rd);\n    vec2 waterIsect = waterRayCast(ro, rd);\n    \n    // Terrain\n    if (terrainIsect.x < waterIsect.x && p.x > 0.1 && ((p.y > -0.8 && p.y < 0.0) || (p.y > 0.0 && p.x > 0.5))) {\n        if (terrainIsect.x < 10.0) {\n            vec3 post = ro + terrainIsect.x * rd;\n\n            // Terrain color\n            vec3 li = normalize(vec3(-2.0, 2.0, -4.0));\n            vec3 nor = terrainNormal(post);\n            float r = max(dot(nor, li), 0.05) / 2.0;\n            float k = mapTerrain(post).x;\n\n            vec3 col1 =vec3(r * k * 1.4, r * k * 1.1, r * k);\n            col = 0.1 + col1 * 9.0;\n\n            col = mix(col, col * vec3(1.5, 1.6, 1.7), fbm5(post.xy));\n\n\n            // Shadow from the lighthouse\n            vec3 lightPos4 = vec3(-0.8, 9.0, -0.5);\n\n            vec3 rayDirection = normalize(lightPos4 - post);\n            float l = length(lightPos4 - post);\n\n\n            float lightSize = 0.05 + 0.04*sin(0.7);\n            float shadow = rayCastShadow(post, rayDirection, lightSize);\n\n\n            // Make shadow lighter\n            col = mix(col, col * vec3(shadow), 0.75);\n\n            float dif = clamp( dot( nor, rayDirection ), 0.0, 1.0 ) * shadow;\n\n            if (shadow < 1.0) {\n            }\n\n        } \n    }\n    \n    \n    // Water\n    else if (waterIsect.x < 10.0) {\n        vec3 pos = ro + waterIsect.x * rd;\n        col = shadeOcean(pos, rd, fragCoord, dir);\n        \n    }\n    \n    \n    \n    // Distance fog\n    vec3 p2 = ro + 5.0 * rd;\n    vec3 fogCol = skyCol * vec3(1.4, 1.5, 1.6);\n    vec2 moonFogPos = vec2(-0.5, 0.50);\n    if (p2.y >= 1.30 && p2.y < 1.50) {\n        float h = (p2.y - 1.30) * 5.0;\n        vec3 col1 = mix( col, fogCol, h );\n        col1 = mix( col1, fogCol, h*h*h );\n        \n        vec3 col2 = mix( col, vec3(1.0, 1.0, 1.0), h );\n        col2 = mix( col2, vec3(1.0, 1.0, 1.0), h*h*h );\n        float lightIntensity = 1.0 / (10.0 * distance(p, moonFogPos));\n        \n        col = mix(col1, col2, lightIntensity);\n    }\n    if (p2.y >= 1.50 && p2.y < 1.70) {\n        float h = 1.0 - (p2.y - 1.50) * 5.0;\n        vec3 col1 = mix( col, fogCol, h );\n        col1 = mix( col1, fogCol, h*h*h );\n        \n        vec3 col2 = mix( col, vec3(1.0, 1.0, 1.0), h );\n        col2 = mix( col2, vec3(1.0, 1.0, 1.0), h*h*h );\n        float lightIntensity = 1.0 / (10.0 * distance(p, moonFogPos));\n        \n        col = mix(col1, col2, lightIntensity);\n    } \n    \n    \n    \n    // Lighthouse\n    vec2 isect = rayCast(ro, rd);\n    if (isect.x > 0.0001 && isect.x < terrainIsect.x) {\n        vec3 pos = ro + isect.x * rd;\n        \n       \n        vec3 nor = calculateNormals(pos);\n        vec3 lightDir = normalize(lightPos - pos);\n        \n        if (isect.y != 2.0) {\n        \tcol = computeMaterial(isect.y, pos, nor, lightDir, normalize(ro - pos)); \n        }\n       \n        \n        // From: https://iquilezles.org/articles/outdoorslighting\n        // Use: normalize(lightPos2 - pos) instead of lightDir to see lightHouse better\n        float sun = clamp( dot( nor, lightDir), 0.0, 1.0 );\n\n        // compute lighting\n        vec3 lin  = sun * vec3(1.64,1.27,0.99);\n        lin += skyCol * vec3(0.16,0.20,0.28);\n\n        // multiply lighting and materials\n        vec3 color = col * lin;\n        \n\n        // gamma correction\n        color = pow( color, vec3(1.0/2.2) );\n        \n        // Glow inside glass\n        if (isect.y == 2.0) {\n            sun = clamp( dot( nor, normalize(lightPos2 - pos)), 0.0, 1.0 );\n            lin  = sun * vec3(1.64,1.27,0.99);\n            vec3 color2 = col * lin;\n            color2 = pow( color2, vec3(1.0/1.5) );\n            color = color + color2;\n        }\n\n        // display\n        col = color;\n        \n        \n        // Specular in the side of the lighthouse\n        float diffuse = max(0.0, dot(lightDir, nor)) / 1.2;\n      \tfloat specular = pow(diffuse, 2.);\n        \n      \tcol += vec3(diffuse * col + specular*2.9);\n    }\n     \n    \n    \n    // From: https://www.shadertoy.com/view/MdyGzR\n    // Set point in the screen where light is and set intensity based on distance to p\n    vec3 lightPos3 = vec3(0.86, 0.57, 0.0);\n    vec3 lightColor = mix (vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), sin(iTime));\n    float lighIntensity = 1.0 / (50.0 * distance(p, lightPos3.xy));\n        \n    col += lighIntensity*lightColor;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Transform functions\nvec3 rotX(vec3 p, float x) {\n  x = radians(x);\n  float c = cos(x);\n  float s = sin(x);\n  return vec3(p.x, c*p.y-s*p.z, s*p.y+c*p.z);\n}\n\nvec3 rotY(vec3 p, float y) {\n  y = radians(y);\n  float c = cos(y);\n  float s = sin(y);\n  return vec3(c*p.x+s*p.z, p.y, -s*p.x+c*p.z);\n}\n\nvec3 rotZ(vec3 p, float z) {\n  z = radians(z);\n  float c = cos(z);\n  float s = sin(z);\n  return vec3(c*p.x-s*p.y, s*p.x+c*p.y, p.z);\n}\n\n\n// SDFs from https://iquilezles.org/articles/distfunctions\nfloat dot2(in vec2 v ) {return dot(v,v);}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nvec2 mapBeam(vec3 pos) {\n    vec2 result = vec2( 1e10, 0.0 );\n    \n    float light = sdCappedCone(rotX(rotZ(pos, -95.0) + vec3(0.0, 2.5, 0.0), iTime * (180.0 / 3.1415)) - vec3(1.78, 3.0, 0.0), 3.0, 0.0, 0.5);\n\n    if (light < result.x) {\n        result.x = light;\n        result.y = 2.0;\n    }\n    \n    return result; \n}\n\n\nvec2 rayCastBeam(vec3 orig, vec3 dir) {\n    vec2 result = vec2(-1.0, -1.0);\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    for (int i = 0; i < 70; i++) {\n        if (t >= tmax) {\n        \tbreak;\n        }\n        vec3 pos = orig + dir * t;\n        vec2 isect = mapBeam(pos);\n        if (isect.x < 0.0001) {\n            result = vec2(t, isect.y);\n            break;\n        }\n        t += isect.x;\n    }\n    \n    return result;\n}\n\n\nvec3 fog(vec3 p, vec3 dir, vec3 dirSky) {\n\n    float light = sdCappedCone((rotZ(p, -95.0)) - vec3(1.78, 0.0, 0.0), 2.5, 0.0, 0.5);\n    \n    vec2 isect = rayCastBeam(p, normalize(vec3(0.0, 0.0, 0.0)));\n    vec3 p2 = p + isect.x * dir;\n    float dist = length(p2);\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    if (isect.y == 2.0) {\n    \tcol = mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), smoothstep(0.0, 0.5, dist / 10.0));\n    \n    }\n    \n    return col;\n}\n\n\n// From: https://www.shadertoy.com/view/Xds3zNs\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // Calculate camera psition/direction.\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 4.5, 1.0 + 2.0, 4.5 );\n    mat3 ca = setCamera( ro, ta, 0.0);\n    vec3 rd = ca * normalize( vec3(p,2.5) );\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec3 dir = normalize(vec3(p, -1.0));\n    \n    \n    // Light Beam\n    vec2 isect2 = rayCastBeam(ro, rd);\n\n    vec3 pos = ro + isect2.x * rd;\n        \n    if (isect2.y == 2.0) {\n        col += (fog(pos, rd, dir));\n    }\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}