{"ver":"0.1","info":{"id":"lsjczc","date":"1494515440","viewed":233,"name":"White Layer over Lambert","username":"TinyTexel","description":"non-absorptive layer over red lambertian surface\n\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// White Layer over Lambert\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nnon-absorptive layer over red lambertian surface\n\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n*/\n\nconst float Pi = 3.14159265359;\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n    //vec2 uv = floor(fragCoord.xy);\n\tvec2 tex = uv0.xy / PixelCount;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    vec3 colpt = textureLod(iChannel0, tex - vec2(0.5, 0.0), 0.0).rgb;\n    \n    if(false)\n    if(uv.x > PixelCount.x * 0.5)\n    col = (col - colpt);\n    \n    //if(false)\n    {\n    \tcol = 1.0 - exp2(-col * 3.0);\n        col = mix(col, col*col, 0.9);\n    }\n    \n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n    \n    if(false)\n    if(uv.x > PixelCount.x * 0.5)\n    fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// White Layer over Lambert\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nnon-absorptive layer over red lambertian surface\n\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n*/\n\n\n//0.01, 0.3, 0.5\n#define LAYER_THICKNESS 0.3\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define OUT\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define lerp mix\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggestes by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggestes by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggestes by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc, vec2 llp, float S1, out vec3 glp)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front + (cam.Right * tc.x + cam.Up * tc.y) / cam.AxisLen;\n    \n    glp = cam.Right * llp.x + cam.Up * llp.y;\n    \n    vec3 dir = normalize(imgPos * S1 - glp);\n\n    return dir;\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n\tt = min(ub.x, min(ub.y, ub.z));\t\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nvoid Intersect_Ray_SphereBackside(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout float t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = min(dot(rp, rp) - sr2, 0.0);\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\t//if(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(max(0.0, D));\n\n\tt = (-b + sqrtD) / a * 0.5;\n}\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(clamp01(1.0 - s1*s1));\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n// s [0..1]\nfloat Sample_HenyeyGreenstein(float s, float g)\n{\t\n    if(abs(g) < 0.0001) return s * 2.0 - 1.0;\n\n    float g2 = g * g;\n\n    float t0 = (1.0 - g2) / (1.0 - g + 2.0 * g * s);\n\n    float cosAng = (1.0 + g2 - t0*t0) / (2.0 * g);\n\n    return cosAng;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_HenyeyGreenstein(float s0, float s1, float g, vec3 forward)\n{\t\n    float cosTheta = Sample_HenyeyGreenstein(s1, g);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\n// s [0..1]\nfloat Sample_SchlickPhase(float s, float k)\n{\t\n    float t0 = 1.0 + k - 2.0 * s;\n    float t1 = 1.0 + k - 2.0 * s * k;\n\n    float cosAng = t0 / t1;\n\n    return cosAng;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_SchlickPDF(float s0, float s1, float k, vec3 forward)\n{\t\n    float cosTheta = Sample_SchlickPhase(s1, k);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv0.x - 0.5 == float(cx) && uv0.y - 0.5 == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nfloat HenyeyGreensteinPhase(float cosTheta, float g)\n{\n\tfloat g2 = g * g;\n\t\n\tfloat t0 = 1.0 - g2;\n\tfloat t1 = 1.0 + g2 - 2.0 * g * cosTheta;\n\t\n\t return t0 * rsqrt(max(0.0, t1*t1*t1));\n\t//return t0 * rsqrt(max(1.0e-32, t1*t1*t1));\n}\n\nfloat HenyeyGreensteinPDF(float cosTheta, float g)\n{\n    return HenyeyGreensteinPhase(cosTheta, g) * RcpPi4;\n}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n#define PixelCount iResolution.xy\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;\n        \n\tvec2 tex = (uv.xy + vec2(0.5)) / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n    vec2 ang = vec2(Pi * 0.32, -Pi * 0.17);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    \n    float cdist = exp2(1.65 + mouseAccu.w * 0.02);\n    vec3 cpos = -cam.Front * cdist;\n\n    float fId = frameAccu * 1.64683 + 0.84377;\n    \n    vec3 pxId  = vec3(frameAccu, uv); \n         pxId *= vec3( 0.76032, 1.47035, 0.92526); \n         pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    uint hh = HashUInt(pxId, uvec3(0xB8D3E97Cu, 0x736D370Fu, 0xA7D00135u));\n    \n    {\n        vec2 off;\n        {\n        \tfloat h0 = Hash(fId, 0xAF609A13u);\n        \tfloat h1 = Hash(fId, 0xE0ABC868u);\n        \n        \t//off = vec2(h0, h1) * 0.5;\n        \toff = vec2(Sample_Triangle(h0), Sample_Triangle(h1));\n        }\n                      \n        tex21 = ((uv.xy + 0.5) + off) / PixelCount * 2.0 - vec2(1.0);\n    }\n    \n    vec2 llp = vec2(0.0);// local sample pos on lens\n    if(false)\n    {\n        float h0 = HashFlt(hh, 0x27BB116Bu);\n        float h1 = HashFlt(hh, 0x11A95B42u);\n\t\th1 = clamp01(h1 * 0.5 + 0.5);\n\n        llp = Sample_Disk(h0, h1);\n        llp *= 0.02;\n    }\n    \n    vec3 glp;// global sample pos on lens\n    float S1 = cdist - 0.0;// set cube ~sharp\n    vec3 rdir = NewRay(cam, tex21, llp, S1, OUT glp);\n \n    \n    vec2 lightAng = vec2(Pi * 0.3, 0.05 * Pi);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    vec3 lightp = light;\n    {\n        float h0 = HashFlt(hh, 0x9E2355B4u);\n        float h1 = HashFlt(hh, 0xDC305E12u);\n        h1 = clamp01(h1 * 0.5 + 0.5);\n        \n        h1 = mix(0.999, 1.0, h1);\n        \n        lightp = Sample_Sphere(h0, h1, light);\n    }\n    \n    //light = vec3(0.0, 1.0, 0.0);\n    vec3 pot = vec3(1.0);\n    vec3 col = vec3(0.0);\n    vec3 col0 = vec3(0.0);\n    \n    const float E = 1.0 * Pi;\n    \n    bool exit = false;\n    bool scattered = false;\n    \n    float t = -1.0; vec2 tt;\n    vec3 n0, n1;\n    vec3 pos = cpos + glp;\n    vec3 dir = rdir;\n\tfloat ffp = 0.0;\n    float lth = LAYER_THICKNESS;\n    \n    float g = 0.5;// asymmetry parameter; first moment of phase function\n    float sigma_e = 2048.0;// extinction coefficient; reciprocal of photon mean-free-path \n\tsigma_e = 0.8 / lth;\n    \n    if(Intersect_Ray_Sphere(pos, dir, vec3(0.0), Pow2(1.0 + lth), OUT tt) > 0.0)\n\t//if(Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(1.0 + lth), OUT tt, n0, n1) > 0.0)\n    {\n        pos += dir * tt.x;\n        \n        for(float i = 0.0; i < 256.0; ++i)\n        {\n\t\t\t// sample free flight path\n            {\n                float h0 = HashFlt(hh, 0x4EF175A5u);\n                h0 = clamp01(h0 * 0.5 + 0.5);\n                h0 = max(0.0001, h0);\n\n                ffp = -log(h0) / sigma_e;\n            }\n\n            \n            //if(false)\n            {\n              float hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT tt);\n            //float hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(1.0), OUT tt, n0, n1);\n            \n            float mt = min(t, tt.x);\n            \n            if(hit > 0.0)\n            {\n                if(tt.x < ffp)\n                {\n                    ffp -= tt.x;\n                    \n                    pos += dir * tt.x;\n                    \n                    n0 = normalize(pos);\n                    \n                    pos += n0 * 0.0001;\n                    \n                    float h0 = HashFlt(hh, 0x874C40D4u);\n                    float h1 = HashFlt(hh, 0xF27BD7E1u);\n                    h1 = clamp01(h1 * 0.5 + 0.5);\n\n                    dir = Sample_ClampedCosineLobe(h0, h1, n0);\n                    \n                    pot *= vec3(1.0, 0.0, 0.0);\n                    \n                    {\n                        float l;\n                        //Intersect_Ray_CubeBackside(pos, light, vec3(0.0), vec3(1.0 + lth), OUT l);\n\t\t\t\t\t\tIntersect_Ray_SphereBackside(pos, light, vec3(0.0), Pow2(1.0 + lth), OUT l);\n                        \n                        float transm = exp(-l * sigma_e);\n                        float brdf = RcpPi;\n\n\t\t\t\t\t\tif(transm > 0.0)// prevents nans for reasons; also had this in HLSL code...\n                        col += pot * brdf * transm * E * clamp01(dot(n0, light));\n                    }\n                    //break;\n                }\n            }\n        }\n            \n            //Intersect_Ray_CubeBackside(pos, dir, vec3(0.0), vec3(1.0 + lth), OUT t);\n            Intersect_Ray_SphereBackside(pos, dir, vec3(0.0), Pow2(1.0 + lth), OUT t);\n            \n            if(t < ffp)// photon hits cube surface earlier than particle\n            {\n                exit = true;\n                break;\n            }\n\n            pos += dir * ffp;\n\n            // single-scattering albedo; a_ss = sigma_s / sigma_e = sigma_s / (sigma_s + sigma_a)\n            //vec3 a_ss = vec3(0.2, 0.6, 0.9);\n           //vec3 a_ss = If(greaterThan(pos, vec3(0.0)), vec3(0.9), vec3(0.2));\n           //a_ss = vec3(0.9);\n           //pot *= a_ss;\n            \n            scattered = true;\n            \n            // direct light sampling\n            //if(false)\n            if(Intersect_Ray_Sphere(pos, light, vec3(0.0), 1.0, OUT tt) < 1.0)\n            {\n                float l;\n                //Intersect_Ray_CubeBackside(pos, light, vec3(0.0), vec3(1.0 + lth), OUT l);\n\t\t\t\tIntersect_Ray_SphereBackside(pos, light, vec3(0.0), Pow2(1.0 + lth), OUT l);\n                \n                float transm = exp(-l * sigma_e);\n                float phase = HenyeyGreensteinPDF(dot(dir, lightp), g);\n\n                //if(Intersect_Ray_Cube(pos, light, vec3(0.0), vec3(1.0), OUT tt, n0, n1) < 1.0)\n                if(transm > 0.0)// prevents nans for reasons; also had this in HLSL code...\n                    col += pot * phase * transm * E;\n            }\n\n            // sample scattering direction\n            {\n                float h0 = HashFlt(hh, 0x874C40D4u);\n                float h1 = HashFlt(hh, 0xF27BD7E1u);\n                h1 = clamp01(h1 * 0.5 + 0.5);\n\n                //dir = Sample_SchlickPhase(h0, h1, 0.6, dir);\n                dir = Sample_HenyeyGreenstein(h0, h1, g, dir);\n            }    \n\n\n            hh = Hash(hh);\n        }\n    }\n    \n    if(t == -1.0 || exit == true || scattered == false)// either initial ray missed cube (t=-1 ffp=0) or we exited the loop early\n    {\n       if(scattered == false)// already sampled this part directly\n       {\n           if(dot(dir, light) > 0.999)\n           {col += E; col0 += E;}\n       }\n        \n       {\n           float h0 = HashFlt(hh, 0x9E2355B4u);\n           float h1 = HashFlt(hh, 0xDC305E12u);\n           h1 = clamp01(h1 * 0.5 + 0.5);\n\n           h1 = mix(0.999, 1.0, h1);\n\n           dir = Sample_Sphere(h0, h1, dir);\n       }\n        \n        //col += pot * vec3(0.2, 0.4, 1.0);// \n        col += pot * textureLod(iChannel2, dir, 0.0).rgb;// blurred bg\n        \n        //col += pot * 1.0;\n        //col0 = pot;\n    }\n    \n    \n    vec3 colLast = textureLod(iChannel0, uv0 / iResolution.xy, 0.0).rgb;\n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n    //col.x = tex21.x;\n    outCol = vec4(col, 0.0);\n    \n    \n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}