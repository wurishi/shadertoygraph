{"ver":"0.1","info":{"id":"DllXWn","date":"1674688615","viewed":122,"name":"Slimy","username":"kabbitron","description":"Experiments with the bleeding effect from metaballs","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1 in the longest axis, square units)\n    vec2 pt = (2.0 * fragCoord - iResolution.xy) / max(iResolution.x, iResolution.y);\n    // Normalized pixel coordinates (from -1 to 1 in x and y)\n    vec2 ptS = (2.0 * fragCoord - iResolution.xy) / iResolution.xy;\n\n    // Bleed SDFs together\n    const float bleedDist = 0.04;\n    const float fadeDist = 0.003;\n    const float LineWidth = 0.01;\n\n    vec4 bleed = vec4(0.0, 0.0, 0.0, 0.0);\n\n    vec2 grid1 = sdGridSep(pt, vec2(0.5 * cos(iTime * 0.023), sin(iTime * 0.017)), iTime * 0.03, 0.3, LineWidth);\n    vec3 grid1col = vec3(1.0, 0.0, 1.0);\n    bleed += BleedVal(grid1col, grid1.x, bleedDist);\n    bleed += BleedVal(grid1col, grid1.y, bleedDist);\n\n    vec2 grid2 = sdGridSep(pt, vec2(0.5 * cos(iTime * 0.013), sin(iTime * 0.027)), -iTime * 0.02, 0.4, LineWidth);\n    vec3 grid2col = vec3(0.0, 1.0, 1.0);\n    bleed += BleedVal(grid2col, grid2.x, bleedDist);\n    bleed += BleedVal(grid2col, grid2.y, bleedDist);\n\n    //float grid3 = sdDiscGrid(pt, vec2(0.5 * cos(iTime * 0.033), sin(iTime * 0.025)), iTime * 0.01, 0.5, 0.125);\n    //float grid3 = sdAnnulusGrid(pt, vec2(0.5 * cos(iTime * 0.033), sin(iTime * 0.025)), iTime * 0.01, 0.5, 0.15, 0.04);\n    float grid3 = sdAnnulusHexGrid(pt, vec2(0.5 * cos(iTime * 0.033), sin(iTime * 0.025)), iTime * 0.01, 0.5, 0.15, LineWidth);\n    vec3 grid3col = vec3(1.0, 1.0, 0.0);\n    bleed += BleedVal(grid3col, grid3, bleedDist);\n\n    float grid4 = sdDiscGrid(pt, vec2(0.5 * cos(iTime * 0.013), sin(iTime * 0.027)), -iTime * 0.04, 0.2, 0.005);\n    vec3 grid4col = vec3(1.0, 1.0, 1.0);\n    bleed += BleedVal(grid4col, grid4, bleedDist);\n\n\n    vec3 col = BleedToCol(bleed, bleedDist, fadeDist);\n\n    // Fade out at the edges\n    col *= smoothstep(1.5, 0.8, length(ptS)); // round fade\n    col *= smoothstep(1.2, 0.7, max(abs(ptS.x), abs(ptS.y))); // rect fade\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat sqr(float x)\n{\n    return x * x;\n}\n\n// SDF for grid with separate values for the horizontal and vertical bars\nvec2 sdGridSep(vec2 pt, vec2 ptGridCenter, float gridAngle, float gridCellWidth, float barWidth)\n{\n    // Transform from world to grid\n    pt -= ptGridCenter;\n    pt *= rotate2d(-gridAngle);\n    \n    return abs(mod(pt, gridCellWidth) - 0.5 * gridCellWidth) - 0.5 * barWidth;\n}\n\n// SDF for grid of discs\nfloat sdDiscGrid(vec2 pt, vec2 ptGridCenter, float gridAngle, float gridCellWidth, float circleRadius)\n{\n    // Transform from world to grid\n    pt -= ptGridCenter;\n    pt *= rotate2d(-gridAngle);\n    \n    return length(mod(pt, gridCellWidth) - 0.5 * gridCellWidth) - circleRadius;\n}\n\n// SDF for grid of discs\nfloat sdAnnulusGrid(vec2 pt, vec2 ptGridCenter, float gridAngle, float gridCellWidth, float circleRadius, float circleWidth)\n{\n    // Transform from world to grid\n    pt -= ptGridCenter;\n    pt *= rotate2d(-gridAngle);\n    \n    return abs(length(mod(pt, gridCellWidth) - 0.5 * gridCellWidth) - circleRadius) - 0.5 * circleWidth;\n}\n\nvec2 HexAxialRound(vec2 pt)\n{\n    // https://observablehq.com/@jrus/hexround\n    vec2 ptGrid = round(pt);\n    pt -= ptGrid;\n    if (abs(pt.x) > abs(pt.y))\n        ptGrid.x += round(pt.x + 0.5*pt.y);\n    else\n        ptGrid.y += round(pt.y + 0.5*pt.x);\n    return ptGrid;\n}\n\n#define SQRT3 (1.7320508)\n#define INVSQRT3 (0.57735027)\n\n// (grid cell x, grid cell y, dist to cell center)\nvec3 HexGrid(vec2 pt, float cellWidth)\n{\n    pt *= 1.0 / cellWidth;\n    // To axial              From axial \n    // | 1  -1/sqrt(3) |     | 1  1/2       |\n    // | 0   2/sqrt(3) |     | 0  sqrt(3)/2 |\n    vec2 ptAxial = vec2(pt.x - INVSQRT3 * pt.y, 2.0 * INVSQRT3 * pt.y);\n    ptAxial = HexAxialRound(ptAxial);\n    vec2 ptCellCenter = vec2(ptAxial.x + 0.5 * ptAxial.y, 0.5 * SQRT3 * ptAxial.y);\n    return vec3(ptAxial.x, ptAxial.y, cellWidth * distance(pt, ptCellCenter));\n}\n\n// SDF for grid of discs\nfloat sdAnnulusHexGrid(vec2 pt, vec2 ptGridCenter, float gridAngle, float gridCellWidth, float circleRadius, float circleWidth)\n{\n    // Transform from world to grid\n    pt -= ptGridCenter;\n    pt *= rotate2d(-gridAngle);\n    \n    vec3 hex = HexGrid(pt, gridCellWidth);\n    \n    return abs(hex.z - circleRadius) - 0.5 * circleWidth;\n}\n\n// Converts color and signed distance to a \"bleed value\",\n// Bleed value takes the signed dist interval [0, bleedDist], reverses it, scales it to [0, 1] with clamping, and squares it.\n// The color is weighted by the bleed value.\n// Bleed values can be added and in the end converted back to color\nvec4 BleedVal(vec3 col, float sd, float bleedDist)\n{\n    float b = sqr(clamp((bleedDist - sd) / bleedDist, 0.0, 1.0));\n    return vec4(b * col, b);\n}\n\nvec3 BleedToCol(vec4 bleedVal, float bleedDist, float fadeDist)\n{\n    vec3 col = bleedVal.xyz / bleedVal.w;\n    \n    float sd = bleedDist - sqrt(bleedVal.w) * bleedDist;\n    \n    col *= smoothstep(fadeDist, 0.0, sd);\n    \n    return col;\n}\n\n","name":"Common","description":"","type":"common"}]}