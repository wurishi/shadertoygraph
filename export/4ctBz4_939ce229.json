{"ver":"0.1","info":{"id":"4ctBz4","date":"1732785968","viewed":216,"name":"Ring Nebula (M57)","username":"toninoni","description":"Fork of the Crab nebula, forked from my Helix nebula, forked from the Supernova Remnant by Duke. Trying to model the Ring nebula as close as possible.","likes":19,"published":1,"flags":16,"usePreview":1,"tags":["cloud","star","space","nebula","supernova","dust","remnant","filament"],"hasliked":0,"parentid":"MfcBzH","parentname":"Crab Nebula (M1)"},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ring nebula (M57)\n// Fork of \"Supernova remnant\" by Duke\n// https://www.shadertoy.com/view/MdKXzc\n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 4\" (https://www.shadertoy.com/view/MsVXWW) \n// and \"Protoplanetary disk\" (https://www.shadertoy.com/view/MdtGRl) \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n#define ITERATIONS 70\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nmat4 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// iq's noise\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\nfloat fbm(vec3 p) {\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\nfloat fpm(vec3 p) {\n   return noise(p*0.06125)*0.5 + noise(p*0.125)*0.25 + noise(p*0.25)*0.125;\n}\nconst float nudge = 0.9;\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\nfloat SpiralNoiseC(vec3 p) {\n    float n = 0.0;\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++) {\n        \n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\n        \n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        \n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.733733;\n    }\n    return n;\n}\n\n\n\nfloat length2( vec2 p ) {\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p ) {\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat Ring(vec3 p){\n  p.x *= 1.3;\n  p.y *= 0.9;\n  vec2 q = vec2(length(p.xy)-2.2,p.z);\n  return length(q);\n}\nfloat Disk( vec3 p, vec3 t ) {\n    vec2 q = vec2(length2(p.xy) -t.x, p.z);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\nfloat Sphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\n\nfloat NebulaNoise(vec3 p) {\n    float final = Sphere(p.xzy, 3.5);\n    final += fbm(p * 10.0);\n    final += SpiralNoiseC(p.zxy*0.415);\n\n    return final * 2.5;\n}\n\nfloat smin( float a, float b, float k ){\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat Xor(float d1, float d2 ){\n    return max(min(d1,d2),-max(d1,d2));\n}\n\n\nfloat map(vec3 p) {\n\tR(p.xz, iMouse.x*0.003*pi+iTime*0.1);\n    p = (vec4(p,1.0) * rotate(vec3(1.0, 0.0, 1.), pi / 8.0)).rgb;\n\n\tfloat d1 = Disk(p,vec3(2.2,1.0,0.3)) + fpm(vec3(p.xy * 30.0, p.z * 90.0) * 3.0) * 0.8;\n    float d2 = Ring(p);\n    float d3 = abs(NebulaNoise(p)*0.8) + 0.07;\n    return Xor(d3, smin(d1,d2,1.0));\n}\n//--------------------------------------------------------------\n\nvec3 computeColor( float density, float radius ) {\n\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\tvec3 colCenter = 7.0*vec3(0.5,0.99,1.0);\n\tvec3 colEdge = 2.0*vec3(0.7,0.67,0.5);\n    vec3 colOuter = vec3(1.0, 0.4, 0.42);\n\tresult *= mix(mix( colCenter, colEdge, min( (radius) * 0.9, 1.15 ) ), colOuter, radius * 0.19);\n    \n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far) {\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 20.0;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n    float zoom = (iMouse.y / iResolution.y) * 2.5 - 1.0;\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.0 + (5.0 * zoom));\n\n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist)) {\n       \n\tt = min_dist*step(t,min_dist) - hash13(1000.0 * rd);\n   \n\t// raymarch loop\n\tfor (int i=0; i<ITERATIONS; i++) {\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n\t    if(td>0.9 || t>20.0 || sum.a > 0.99 || t>max_dist) break;\n        \n        // evaluate distance function\n        float d = map(pos);\n\t\t       \n\t\t// change this string to control density \n\t\td = max(d,0.0);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light \n        float _T = lDist*2.2+2.0;\n        vec3 lightColor=0.4+0.45*cos(_T + pi * 0.5*vec3(-0.6,0.25,1.4));\n        \n        // Bloom\n        sum.rgb+=(lightColor / exp(lDist*lDist*lDist*.03)/35.0);\n        \n\t\tif (d<h) {\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1.0 - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1.0/40.0;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2;\t\n            \n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1.0/70.0;\n\n\t\t\n        // trying to optimize step size near the camera and near the light source\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.01);\n        \n\t}\n    \n    // simple scattering\n\tsum *= 1.0 / exp( ld * 0.1 ) * 0.6;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz * sum.xyz * (3.0 - 2.0 * sum.xyz);\n    \n\t}\n\n    fragColor = vec4(sum.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}