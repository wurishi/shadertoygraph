{"ver":"0.1","info":{"id":"DdsXR7","date":"1668651810","viewed":79,"name":"Mario Mushroom Wallpaper","username":"Mario8664","description":"Mario Mushroom Wallpaper","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BX 120.0\n#define BY 48.0\n#define FACTOR 4.0\n\nfloat getBrick(vec2 uv, vec2 offset)\n{\n    float bh = fract(uv.y / offset.y / BY / 6.0);\n    bh = ceil(bh - 1.0 / 6.0);\n    float bv = fract(uv.x / offset.x / BX / 3.0);\n    bv = ceil(bv - 1.0 / 3.0);\n    return max(bh, bv);\n}\n\nvec3 getBG(vec2 uv, vec2 offset, float n)\n{\n    vec3 darkcolor = vec3(0.1, 0.2, 0.3);\n    float gradient = 1.0 - uv.y;\n    //gradient process\n    gradient += 0.5;\n    gradient *= 0.3;\n    gradient += 0.7;\n\n    gradient = clamp(gradient, 0.0, 1.0);\n\n    n += 0.65;\n    n = clamp(n, 0.0, 1.0);\n\n    uv.x += 13.0 * offset.x;\n    uv += vec2(n - 0.5) * 0.001;\n\n    //background\n    float hl = fract(uv.y / offset.y / BY);\n    hl = ceil(hl - FACTOR / BY);\n\n    float vlmask = fract(uv.y / offset.y / BY / 2.0);\n    vlmask = ceil(vlmask - 0.5);\n    float uvmask = uv.x + vlmask * BX * 0.5 * offset.x;\n    float vl = fract(uvmask / offset.x / BX);\n    vl = ceil(vl - FACTOR / BX);\n    float b1 = getBrick(uv, offset);\n    float b2 = getBrick(uv + vec2(BX * 2.0, BY * 2.0) * offset, offset);\n    float bf = min(b1, b2);\n    bf = bf * 0.8 + 0.2;\n\n    float brick = min(hl, min(vl, bf));\n\n    brick = min(brick, n);\n\n    vec3 bg = mix(vec3(0.89, 0.91, 0.93), vec3(1.0), brick);\n    return mix(darkcolor, bg.rgb, gradient);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 offset = 1.0 / iResolution.xy;\n    vec3 bg = getBG(uv, offset, texture(iChannel1, fragCoord / iResolution.y).r);\n    vec4 col = texture(iChannel0, uv / SCALE);\n\n    // Output to screen\n    fragColor = vec4(mix(bg, col.rgb, col.a),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define DISTANCE 8.0\n#define PI 3.1415926535897932384626\n#define FRESNEL 0.3\n#define AOSTEP 0.1\n#define LIGHT vec3(1.0, 2.0, -1.0)\n#define SUNSIZE 0.01\n\nvec3 capDown;\nvec3 capRight;\nvec3 capForward;\n\nvec4 opUnion(vec4 d1, vec4 d2)\n{\n    float d = min(d1.w, d2.w);\n    //difference is (1, 0) or (0, 1)\n    vec2 difference = normalize(vec2(abs(d - d1.w), abs(d - d2.w)));\n    vec3 colorMix = difference.x * d2.rgb + difference.y * d1.rgb;\n    return vec4(colorMix, d);\n}\n\nvec4 opSubtraction(vec4 d1, vec4 d2 )\n{\n    d1.w = -d1.w;\n    float d = max(d1.w, d2.w);\n    //difference is (1, 0) or (0, 1)\n    vec2 difference = normalize(vec2(abs(d - d1.w), abs(d - d2.w)));\n    vec3 colorMix = difference.x * d2.rgb + difference.y * d1.rgb;\n    return vec4(colorMix, d);\n}\n\nvec4 opSmoothSubtraction(vec4 d1, vec4 d2, float k)\n{\n    d1.w = -d1.w;\n    float difference = max(k - abs(d1.w - d2.w), 0.0);\n    float d = max(d1.w, d2.w) + difference * difference * 0.25 / k;\n    //colorDifference is between (1, 0) and (0, 1)\n    vec2 colorDifference = vec2(abs(d - d1.w), abs(d - d2.w));\n    colorDifference.x = colorDifference.x / (colorDifference.x + colorDifference.y);\n    colorDifference.y = 1.0 - colorDifference.x;\n    vec3 colorMix = colorDifference.x * d2.rgb + colorDifference.y * d1.rgb;\n    return vec4(colorMix, d);\n}\n\nvec4 sdSphere(vec3 pos, float radius, vec3 color)\n{\n\treturn vec4(color, length(pos) - radius);\n}\n\nvec4 sdCapsule(vec3 pos, vec3 a, vec3 b, float radius,vec3 color)\n{\n  vec3 pa = pos - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  /*     \n          p\n          ↓                 ph = √pa * pa - ah * ah = length(pa - ah)\n      a---h----------b\n  */\n  return vec4(color, length( pa - ba*h ) - radius);\n}\n\nvec4 sdRoundedCylinder(vec3 p, float radius, float roundRadius, float height,vec3 color)\n{\n  vec2 d = vec2( length(p.xz) - 2.0 * radius + roundRadius, abs(p.y) - height);\n  return vec4(color, min(max(d.x,d.y),0.0) + length(max(d,0.0)) - roundRadius);\n}\n\nvec4 getScene(vec3 pos)\n{\n    const vec3 capColor = vec3(0.8, 0.0, 0.0);\n    const vec3 pointColor = vec3(1.0);\n    const vec3 faceColor = vec3(1.0, 0.85, 0.7);\n    const vec3 eyeColor = vec3(0.0, 0.0, 0.0);\n    \n    //Symmetry\n    vec3 pe = pos;\n    pe.x = abs(pe.x);\n    \n    //cap\n    vec4 s1 = sdSphere(pos - vec3(0.0, 0.3, 0.0), 1.2, capColor);\n    vec4 s2 = sdSphere(pos - capDown * 3.18, 2.8, capColor);\n    vec4 cap = opSmoothSubtraction(s2, s1, 0.75);\n    vec4 s3 = sdSphere(pos - capDown * 0.7, 0.8, capColor);\n    cap = opSmoothSubtraction(s3, cap, 0.25);\n    //face\n    vec4 face = sdRoundedCylinder(pos - vec3(0.0, 0.0, -0.12), 0.37, 0.55, 0.32, faceColor);\n    //point\n    vec4 ps = sdSphere(pos - capDown * 3.18, 3.2, pointColor);\n    vec4 p1 = sdSphere(pos - (capForward * 0.65 - capDown * 0.47), 0.81, pointColor);\n    vec4 p2 = sdSphere(pos - (-capForward * 0.39 - capDown * 0.52), 0.81, pointColor);\n    //dean_the_coder suggests that using symmetry trick\n    vec4 p3 = sdSphere(pe - (capForward * 0.15 -capRight * 0.5 - capDown * 0.5), 0.81, pointColor);\n    //vec4 p3 = sdSphere(pos - (capForward * 0.15 -capRight * 0.5 - capDown * 0.5), 0.81, pointColor);\n    //vec4 p4 = sdSphere(pos - (capForward * 0.15 +capRight * 0.5 - capDown * 0.5), 0.81, pointColor);\n    vec4 p5 = sdSphere(pos - (capForward * 0.15 - capDown * 0.82), 0.81, pointColor);\n    vec4 p = opUnion(p1, p2);\n    p = opUnion(p, p3);\n    //p = opUnion(p, p4);\n    p = opUnion(p, p5);\n    ps = opSubtraction(ps, p);\n    vec4 pSmoothS = sdSphere(pos - vec3(0.0, 0.3, 0.0), 1.21, pointColor);\n    pSmoothS.w = -pSmoothS.w;\n    ps = opSmoothSubtraction(pSmoothS, ps, 0.08);\n    //eye\n    vec4 e1 = sdCapsule(pe, vec3(0.21, -0.4, -0.74),  vec3(0.22, -0.2, -0.76), 0.095, eyeColor);\n    \n    return opUnion(cap, opUnion(face, opUnion(ps, e1)));\n}\n\nvec3 skyBox(vec3 rd)\n{\n    //return texture(iChannel0, rd).xyz;\n    vec3 sky = mix(vec3(1.2), vec3(0.7, 0.8, 1.0), smoothstep(-0.3, 0.7, rd.y));\n    vec3 land = mix(vec3(0.0), vec3(0.2, 0.2, 0.3), smoothstep(-0.9, 0.3, rd.y));\n    vec3 skybox = mix(land, sky, smoothstep(-0.05, 0.1, rd.y));\n    \n    float sun = dot(rd, normalize(LIGHT));\n    sun = (sun - 1.0 + SUNSIZE) / SUNSIZE;\n    sun = clamp(sun, 0.0, 1.0);\n    sun = pow(sun, 5.0);\n    \n    return skybox + sun;\n    //return ceil(rd * 10.0) / 10.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * SCALE * fragCoord - iResolution.xy) / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    if(uv.x > aspect || uv.y > 1.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    //Camera\n    vec2 m = vec2(iTime * 0.05, 0.5);//Camera input\n    vec3 target = vec3(0.0, 0.03, 0.0);//Camera view target\n    float theta = m.x * 2.0 * PI;//Input to y-axis angle(0 ~ 2PI)\n    float fai = -(m.y - 0.5) * 0.8 * PI;//Input to local x-axis angle(-0.4Pi ~ 0.4PI)\n\n    //rotation vector(unit vector)\n    vec3 rotation = vec3(cos(theta), sin(fai) ,sin(theta));\n    rotation.xz *= cos(fai);\n    \n    vec3 cameraPos = rotation * DISTANCE;\n    vec3 cameraForward = normalize(target - rotation);\n    vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n    \n    vec3 ro = cameraPos;\n    vec3 rd = cameraForward * 5.0 + uv.x * cameraRight + uv.y * cameraUp;\n    rd = normalize(rd);\n    \n    float t = 0.0;\n    vec3 pos = ro;\n    vec4 col = vec4(0.0);//skyBox(rd);\n    \n    vec3 light = LIGHT.x * cameraRight + LIGHT.y * cameraUp + LIGHT.z * cameraForward;\n    \n    //uniform\n    capDown = normalize(vec3(0.0, -2.8, -1.3));\n    capRight = normalize(cross(vec3(0.0, 1.0, 0.0), capDown));\n    capForward = cross(capDown, capRight);\n    \n    for(int i = 0; i < 64; i++)\n    {\n    \tvec4 d = getScene(pos);\n        if(abs(d.w)<(0.001*t))\n        {\n            vec2 offset = vec2(0.001, 0.0);\n            vec3 normal = vec3(getScene(pos + offset.xyy).w - getScene(pos - offset.xyy).w,\n                               getScene(pos + offset.yxy).w - getScene(pos - offset.yxy).w,\n                               getScene(pos + offset.yyx).w - getScene(pos - offset.yyx).w);\n            normal = normalize(normal);\n            //reflection\n            //vec3 ref = skyBox(reflect(rd,normal)) * 0.5;\n            //fresnel\n            float fresnel = (1.0 - dot(normal, -rd));\n            fresnel = ceil(fresnel - 0.6) * 0.3;\n            //diffuse\n            float diffuse = dot(normal, normalize(light));\n            diffuse = diffuse * 0.5 + 0.5;\n            diffuse = mix(0.8, 1.0, ceil(diffuse - 0.5));\n            //specular\n            float specular = clamp(dot(normal,normalize(light-rd)), 0.0, 1.0);\n            specular = ceil(specular - 0.95) * 0.5;\n            light = -LIGHT.x * cameraRight -LIGHT.y * cameraUp + LIGHT.z * cameraForward;\n            //float specular2 = clamp(dot(normal,normalize(light-rd)), 0.0, 1.0);\n            //specular2 = ceil(specular2 - 0.95) * 0.3;\n            \n        \tcol.rgb = diffuse * d.rgb + fresnel + vec3(0.05) + specular;\n            col.a = 1.0;\n            break;\n        }\n        t += d.w;\n        pos = ro + rd * t;        \n    }\n    \n\n    // Output to screen\n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SCALE 4.0","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//outline\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 os = vec3(-1.0, 0.0, 1.0);\n    vec2 o = vec2(1.0) / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    \n    float c0 = abs(texture(iChannel0, uv + o * os.xy).a - col.a);\n    float c1 = abs(texture(iChannel0, uv + o * os.yx).a - col.a);\n    float c2 = abs(texture(iChannel0, uv + o * os.zy).a - col.a);\n    float c3 = abs(texture(iChannel0, uv + o * os.yz).a - col.a);\n    //float c4 = abs(texture(iChannel0, uv + o * os.xx).a - col.a);\n    //float c5 = abs(texture(iChannel0, uv + o * os.xz).a - col.a);\n    //float c6 = abs(texture(iChannel0, uv + o * os.zx).a - col.a);\n    //float c7 = abs(texture(iChannel0, uv + o * os.zz).a - col.a);\n    \n    //float l = max(c0, max(c1, max(c2, max(c3, max(c4, max(c5, max(c6, c7)))))));\n    float l = max(c0, max(c1, max(c2, c3)));\n    l = mix(l, 0.0, col.a);\n    col.a = max(col.a, l);\n    col.rgb *= 1.0 - l;\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}