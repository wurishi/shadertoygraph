{"ver":"0.1","info":{"id":"lfVyWc","date":"1732497439","viewed":10,"name":"Fun with Raytracing","username":"IMDragonFart","description":"Raytracing test. I will be improving this in the future","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_RAY_STEPS = 100;\nconst int MAX_RAY_BOUNCES = 16;\nconst float RAYMARCH_DETAIL = 0.0001; // dont remember name of correct term for this\nconst int PASSES = 16;\n\nconst vec4 SKY_COLOR = vec4(0.2,0.2,1.0, 1.0);\nconst float FOCAL_DISTANCE = 1.0;\nconst float FOCAL_PLANE_SIZE = 1.0;\nconst float VIEW_DISTANCE = 1000.0;\n\nconst int SUN_SOURCES_COUNT = 1;\nconst vec3[] SUN_SOURCES = vec3[]( vec3(0.5,10,0.5), vec3(10.5,10,0.5) );\n\nstruct Material\n{\nvec3 Normal;\nfloat SDF;\nfloat Roughness;\nvec4 Diffuse;\n\n};\n\nvec3 RotateX(vec3 point, vec3 origin, float angle)\n{\n    point -= origin;\n\n    return vec3(\n    point.x,\n    cos(angle) * point.y - sin(angle) * point.z,\n    sin(angle) * point.y + cos(angle) * point.z) + origin;\n}\nvec3 RotateY(vec3 point, vec3 origin, float angle)\n{\n    point -= origin;\n\n    return vec3(\n    cos(angle) * point.x + sin(angle) * point.z,\n    point.y,\n    -sin(angle) * point.x + cos(angle) * point.z) + origin;\n}\nvec3 RotateZ(vec3 point, vec3 origin, float angle)\n{\n    point -= origin;\n\n    return vec3(\n    cos(angle) * point.x - sin(angle) * point.y,\n    sin(angle) * point.x + cos(angle) * point.y,\n    point.z) + origin;\n}\n\nMaterial CubeSDF(vec3 point, vec3 center, vec3 size, float roughness, vec4 color)\n{\n// how is it this simple?\n    vec3 q = abs(point-center) - size; // distance to edge\n    float a = min(max(q.x,max(q.y,q.z)),0.0); // maximum distance to edge >= 0\n    float dist = length(max(q,0.0)) + a;\n    \n    return Material(vec3(0), dist, roughness, color);\n\n\n\n\n/*\n    size/=2.0;\n    vec3 dist = vec3(max(-(center.x + size.x - point.x), center.x - size.x - point.x),\n                    max(-(center.y + size.y - point.y), center.y - size.y - point.y),\n                    max(-(center.z + size.z - point.z), center.z - size.z - point.z));\n    \n    if(dist.x < dist.y && dist.x < dist.z)\n    {\n        if(dist.y > 0.0)\n        {\n            // missed the (x)edge so the closest point is on the corner\n            float distFromCenter = (center - point).y;\n            vec3 corner =  distFromCenter/abs(distFromCenter)\n            dist.x = length(corner - point);\n        }\n    \n        return Material(vec3(-dist.x / abs(dist.x), 0, 0), dist.x, roughness, color);\n    }\n    if(dist.y < dist.x && dist.y < dist.z)\n    {\n        return Material(vec3(-dist.y / abs(dist.y), 0, 0), dist.y, roughness, color);\n    }\n    return Material(vec3(-dist.z / abs(dist.z), 0, 0), dist.z, roughness, color);*/\n}\n\nMaterial SphereSDF(vec3 point, vec3 center, float radius, float roughness, vec4 color)\n{\n    vec3 difference = center - point;\n    float magnitude = length(difference);\n    \n    return Material(-difference/magnitude + sin(2.0*(difference.x/difference.y+difference.z))/2.0, magnitude - radius, roughness, color);\n}\n\nMaterial SceneSDF(vec3 point)\n{\n    Material sphere1 = SphereSDF(point, vec3(sin(iTime)*5.0,-2,0), 1.0, 0.9, vec4(0,1,0,1));\n    Material sphere2 = SphereSDF(point, vec3(sin(iTime)*-5.0,4,3), 2.0, 0.9, vec4(0,1,1,1));\n    Material sphere3 = SphereSDF(point, vec3(0,0,0), 2.0, 1.0, vec4(1,0,0,1));\n    Material cube1 = CubeSDF(point, vec3(0, 0, 10), vec3(1,1,1), 1.0, vec4(1));\n    \n    if(sphere2.SDF < sphere1.SDF && sphere2.SDF < sphere3.SDF && sphere2.SDF < cube1.SDF)\n        return sphere2;\n\n    if(sphere3.SDF < sphere1.SDF && sphere3.SDF < sphere2.SDF && sphere3.SDF < cube1.SDF)\n        return sphere3;\n        \n    if(cube1.SDF < sphere1.SDF && cube1.SDF < sphere2.SDF && cube1.SDF < sphere3.SDF)\n        return cube1;\n\n    return sphere1;\n}\n\nMaterial RayMarch(vec3 origin, vec3 direction, float start, float end)\n{\n    float dist = start;\n    Material mat = Material(vec3(0), 0.0, 0.0, vec4(0));\n    for(int iteration = 0; iteration < MAX_RAY_STEPS; iteration++)\n    {\n        mat = SceneSDF(origin + direction*dist);\n        dist += mat.SDF;\n        if(mat.SDF < RAYMARCH_DETAIL)\n            return Material(mat.Normal, dist-RAYMARCH_DETAIL, mat.Roughness, mat.Diffuse);\n        \n        if(dist > end)\n        {\n            return Material(vec3(0), end, 0.0, vec4(0));;\n        }\n    }\n    return Material(mat.Normal, dist, mat.Roughness, mat.Diffuse);\n}\n\nvec2 SampleNoise(vec2 uv)\n{\n    vec4 col = texture(iChannel0, uv);\n    return vec2(col.x, col.y);\n}\nvec3 RayNoise(vec3 v1, vec3 v2)\n{\n    vec2 noise = SampleNoise(vec2(fract(abs(v1.x + 3.1415926) + abs(v2.y + 4.9751063)),\n                            fract(abs(v1.y + 90.51893) + abs(v2.x) + 1.80315)));\n                            \n    return vec3(noise.xy, fract(pow((noise.x + 12969135.78135), (noise.y*.3517)) / 999.0));\n}\n\nvec3 EstimateNormal(vec3 point)\n{\n    \n    float sampleDistance = RAYMARCH_DETAIL;\n    return -normalize(vec3(SceneSDF(point + vec3(sampleDistance, 0, 0)).SDF - SceneSDF(point - vec3(sampleDistance, 0, 0)).SDF,\n                SceneSDF(point + vec3(0, sampleDistance, 0)).SDF - SceneSDF(point - vec3(0, sampleDistance, 0)).SDF,\n                SceneSDF(point + vec3(0, 0, sampleDistance)).SDF - SceneSDF(point - vec3(0, 0, sampleDistance)).SDF));\n}\n\nvec4 CalculateShading(vec3 normal)\n{\n    vec4 color = vec4(0,0,0,0);\n    for(int i = 0; i < SUN_SOURCES_COUNT; i++)\n    {\n        color += clamp(dot(normal, normalize(SUN_SOURCES[i])), 0.0, 1.0); // TODO: Incorporate intensity\n    }\n    return color;\n}\n\nvec4 CalculateLight(vec3 origin, vec3 direction, float maxDistance, vec2 randomNoise)\n{\n    vec3 rayOrigin = origin;\n    vec3 rayDirection = direction;\n        \n    vec4 color =vec4(0,0,0,1);\n    for(int bounce = 0; bounce < MAX_RAY_BOUNCES; bounce++)\n    {\n        Material mat = RayMarch(rayOrigin, rayDirection, RAYMARCH_DETAIL, maxDistance);\n        if(mat.SDF >= maxDistance)\n        {\n            color += SKY_COLOR / float(bounce+1);\n            return color;\n        }\n        vec3 hitPoint = rayDirection*mat.SDF;\n        \n        // Update ray\n        rayOrigin += hitPoint;\n        vec3 normal = mat.Normal;\n        if(length(normal) <= 0.0)\n             normal = EstimateNormal(hitPoint);\n        \n        rayDirection = reflect(rayDirection, normal)\n                        + RayNoise(rayOrigin * randomNoise.x, rayDirection * randomNoise.y) * mat.Roughness;\n        \n        vec4 shading = CalculateShading(normal);\n        //vec4 specular = clamp(shading, 0.0, 1.0);//-vec4(3.0), 3.0, 4.0);\n        color += (mat.Diffuse*shading) / float(bounce+1);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord- vec2(0.5 * iResolution.xy))/iResolution.y ;\n    \n    vec3 center = vec3(0,0,0);\n    vec3 cameraOrientation = vec3((iMouse.y / iResolution.y-.5) * -3.1415926, (iMouse.x / iResolution.x-.5) * 3.1415926, 0)*2.0;\n    vec3 cameraOrigin = RotateX(RotateY(vec3(0,0,-18), center, cameraOrientation.y), center, cameraOrientation.x);\n    vec3 cameraDirection = RotateX(RotateY(normalize(vec3(uv*FOCAL_PLANE_SIZE, FOCAL_DISTANCE)), center, cameraOrientation.y), center, cameraOrientation.x);\n    \n    fragColor = vec4(0,0,0,1.0);\n    for(int i = 0; i < PASSES; i ++)\n    {\n        fragColor += CalculateLight(cameraOrigin, cameraDirection, VIEW_DISTANCE, SampleNoise(uv*vec2(i+1, float(i)/float(PASSES)+0.1)));\n    }\n    fragColor/=float(PASSES);\n}","name":"Image","description":"","type":"image"}]}