{"ver":"0.1","info":{"id":"4cKGzV","date":"1713613608","viewed":73,"name":"Geometry Library","username":"Mitko","description":"Geometry Library","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CANNEL_BUFFER_A iChannel0\n#define CANNEL_STATE CANNEL_BUFFER_A\n\nfloat ReadCameraRotataion() {\n    return texelFetch(CANNEL_STATE, ROTATION_ADDRESS, 0).x;\n}\nvec3 ReadCameraLookAt() {\n    return texelFetch(CANNEL_STATE, LOOKAT_ADDRESS, 0).yzw;\n}\n\nfloat ReadCameraZoom() {\n    return texelFetch(CANNEL_STATE, ZOOM_ADDRESS, 0).x;\n}\nfloat ReadCameraHeight() {\n    return texelFetch(CANNEL_STATE, HEIGHT_ADDRESS, 0).y;\n}\nfloat ReadDemoType() {\n    return texelFetch(CANNEL_STATE, DEMO_TYPE_ADDRESS, 0).z;\n}\n\n#define NEAR_Z 1.0f\n\nstruct TRay\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n\nstruct TSphere\n{\n    vec3 Center;\n    float Radius;\n};\n\nfloat RaySphereIntersect(TRay ray, TSphere sphere)\n{\n    vec3 oc = ray.Origin - sphere.Center;\n    float b = dot(oc, ray.Direction);\n    float c = dot(oc, oc) - (sphere.Radius * sphere.Radius);\n    float h = (b * b) - c;\n    if (h < 0.0)\n        return INF;\n    else\n        return - b - sqrt(h);\n}\n\nstruct TPlane\n{\n    vec3 Normal;\n    float D;\n};\n\nfloat RayPlaneIntersect(TRay ray, TPlane plane)\n{\n    float denom = dot(plane.Normal, ray.Direction);\n\n    // Prevent divide by zero:\n    if (abs(denom) <= 1e-4f)\n        return INF;\n\n    // If you want to ensure the ray reflects off only\n    // the \"top\" half of the plane, use this instead:\n    //\n    // if (-denom <= 1e-4f)\n    //     return std::nullopt;\n\n    float t = -(dot(plane.Normal, ray.Origin) + plane.D) / denom;\n\n    // Use pointy end of the ray.\n    // It is technically correct to compare t < 0,\n    // but that may be undesirable in a raytracer.\n    if (t <= 1e-4)\n        return INF;\n\n    return t;\n}\n\nvec3 PerspectiveCamera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 fragCoord)\n{\n    vec2 uv = 2.0f * (fragCoord - (iResolution.xy * 0.5f)) / max(iResolution.y, iResolution.y);\n    vec3 vup = normalize(vec3(sin(tilt), 0.0f, cos(tilt)));\n    vec3 lookdir = normalize((lookat - lookfrom));\n    vec3 u = cross(lookdir, vup);\n    vec3 v = cross(u, lookdir);\n    float wf = (1.0f / tan(((vfov * PI) / 360.0f)));\n    return normalize((((uv.x * u) + (uv.y * v)) + (wf * lookdir)));\n}\n\nfloat AAStripe(float x, float thickness, float scale)\n{\n    float area = fwidth(x) / scale;\n    float x0 = x / scale - 0.5f * (area - thickness);\n    float x1 = x0 + area;\n    \n    float i0 = thickness * floor(x0);\n    i0 += min(fract(x0), thickness);\n    \n    float i1 = thickness * floor(x1);\n    i1 += min(fract(x1), thickness);\n    \n    return saturate((i1 - i0) / area);\n}\n\nfloat AAStripe(vec2 pos, float thickness, float scale)\n{\n    return max(\n        AAStripe(pos.x, thickness, scale),\n        AAStripe(pos.y, thickness, scale)\n    );\n}\n\nfloat AAStripe(vec3 pos, float thickness, float scale)\n{\n    return max(\n        AAStripe(pos.xy, thickness, scale),\n        AAStripe(pos.z, thickness, scale)\n    );\n}\n\nfloat Stripe(float x, float thickness, float scale)\n{\n    return float(fract(x / scale + thickness * 0.5f) < thickness);\n}\n\nfloat Stripe(vec2 pos, float thickness, float scale)\n{\n    return max(\n        Stripe(pos.x, thickness, scale),\n        Stripe(pos.y, thickness, scale)\n    );\n}\n\nfloat Stripe(vec3 pos, float thickness, float scale)\n{\n    return max(\n        Stripe(pos.xy, thickness, scale),\n        Stripe(pos.z, thickness, scale)\n    );\n}\n\nfloat HexPattern(vec2 pos, float thickness, float scale)\n{\n\tpos = (pos + vec2(0.5f, 0.435f)) / scale;\n\tpos.y *= tan(PI / 6.0f) * 2.0f;\n\tpos.x += mod(floor(pos.y), 2.0f) * 0.5f;\n\tpos = abs(fract(pos) - 0.5f);\n\treturn step(abs(max(pos.x + pos.y * 1.5f, pos.x * 2.0f) - 1.0f), thickness);\n}\n\nconst int MaxSamples = 8;\nivec2 ComputeSamples(vec3 uvw, vec3 ddx_uvw, vec3 ddy_uvw)\n{\n    return ivec2(1) + ivec2(\n        int(clamp(length(ddx_uvw) * 1000.0f, 0.0f, float(MaxSamples - 1))),\n        int(clamp(length(ddy_uvw) * 1000.0f, 0.0f, float(MaxSamples - 1)))\n    );\n}\n\nfloat HexPatternAA(vec3 uvw, vec3 ddx_uvw, vec3 ddy_uvw)\n{\n    ivec2 samples = ComputeSamples(uvw, ddx_uvw, ddy_uvw);\n    float accumulator = 0.0f;\n\n    for (int j = 0; j < samples.x; ++j)\n    {\n        for (int i = 0; i < samples.y; ++i)\n        {\n            vec2 offset = vec2(float(i), float(j)) / vec2(float(samples.x), float(samples.y));\n            vec3 position = uvw + offset.x * ddx_uvw + offset.y * ddy_uvw;\n            accumulator += HexPattern(position.xy, 0.1f, 0.1f);\n        }\n    }\n\n    return accumulator / float(samples.x * samples.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 screen = fragCoord / iResolution.xy;\n    \n    vec2 mouse = vec2(iMouse) / vec2(iResolution);\n    float cameraRotation = ReadCameraRotataion() * PI / 180.0f;\n    \n    TSphere sphere;\n    sphere.Center = vec3(0.0f, 0.0f, 1.0f);\n    sphere.Radius = 1.0f;\n    \n    TPlane plane;\n    plane.Normal = vec3(0.0f, 0.0f, 1.0f);\n    plane.D = 0.0f;\n    \n    vec3 cameraLookAt = ReadCameraLookAt();\n    vec3 cameraPosition = cameraLookAt + ReadCameraZoom() * vec3(sin(cameraRotation) * 2.0f, cos(cameraRotation) * 2.0f, ReadCameraHeight());\n    \n    TRay cameraRay;\n    cameraRay.Origin = cameraPosition;\n    cameraRay.Direction = PerspectiveCamera(cameraPosition, cameraLookAt, 0.0f, 50.0f, fragCoord);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime+screen.xyx + vec3(0,2,4));\n\n    const vec3 sunDirection = -normalize(vec3(1.0f, -1.0f, -1.0f));\n    \n    float intersectionDistance = RayPlaneIntersect(cameraRay, plane);\n    intersectionDistance = min(intersectionDistance, RaySphereIntersect(cameraRay, sphere));\n    \n    if (intersectionDistance > 1e7f)\n    {\n        col = vec3(0.0f, 0.0f, 0.0f);\n    }\n    else\n    {\n        vec3 intersectionPosition = cameraRay.Origin + cameraRay.Direction * intersectionDistance;\n        float demoType = ReadDemoType();\n        if (demoType == DemoSquareGrid)\n        {\n            if (fragCoord.x > iMouse.x)\n                col.xyz = vec3(Stripe(intersectionPosition.xy, 0.1f, 0.1f));\n            else\n                col.xyz = vec3(AAStripe(intersectionPosition.xy, 0.1f, 0.1f));\n        }\n        else if (demoType == DemoHexGrid)\n        {\n            if (fragCoord.x > iMouse.x)\n                col.xyz = vec3(HexPattern(intersectionPosition.xy, 0.1f, 0.1f));\n            else\n                col.xyz = vec3(HexPatternAA(intersectionPosition, dFdx(intersectionPosition), dFdy(intersectionPosition)));\n        }\n        else if (demoType == DemoVisualizeSS)\n        {\n            ivec2 samples = ComputeSamples(intersectionPosition, dFdx(intersectionPosition), dFdy(intersectionPosition));\n            col.xyz = vec3(vec2(samples) / float(MaxSamples), 1.0f);\n        }\n    }\n//    else\n//    {\n//        vec3 intersectionPosition = cameraRay.Origin + cameraRay.Direction * intersectionDistance;\n//        vec3 normal = normalize(intersectionPosition - sphere.Center);\n//        float NoL = dot(normal, sunDirection);\n//        col.xyz *= NoL;\n//    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int SPACE_KEY = 32;\n\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\n\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_C = 67;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_W = 87;\n\n#define CANNEL_KEYBOARD iChannel0\n#define CANNEL_BUFFER_A iChannel1\n\nbool IsKeyPressed(int key) {\n    return texelFetch(CANNEL_KEYBOARD, ivec2(key, 0), 0).x > 0.0f;\n}\nbool CheckKeyPress(int key) {\n    return texelFetch(CANNEL_KEYBOARD, ivec2(key, 1), 0).x > 0.0f;\n}\nbool IsKeyToggled(int key) {\n    return texelFetch(CANNEL_KEYBOARD, ivec2(key, 2), 0).x > 0.0f;\n}\n\n#define CANNEL_STATE CANNEL_BUFFER_A\nconst float CameraRotationSensitivity = 1.0f;\nconst float CameraMoveSensitivity = 0.03f;\nconst float CameraZoomSensitivity = 0.03f;\nconst float CameraHeightSensitivity = 0.03f;\n\nfloat ReadCameraRotataion() {\n    return texelFetch(CANNEL_STATE, ROTATION_ADDRESS, 0).x;\n}\nvec3 ReadCameraLookAt() {\n    return texelFetch(CANNEL_STATE, LOOKAT_ADDRESS, 0).yzw;\n}\n\nfloat ReadCameraZoom() {\n    return texelFetch(CANNEL_STATE, ZOOM_ADDRESS, 0).x;\n}\nfloat ReadCameraHeight() {\n    return texelFetch(CANNEL_STATE, HEIGHT_ADDRESS, 0).y;\n}\nfloat ReadDemoType() {\n    return texelFetch(CANNEL_STATE, DEMO_TYPE_ADDRESS, 0).z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float frameTimeDelta = 60.0f / float(iFrameRate);\n    fragColor = vec4(0.0f);\n    if (ivec2(fragCoord) == LOOKAT_ADDRESS)\n    {        \n        float cameraRotation = ReadCameraRotataion();\n        if (IsKeyPressed(KEY_E)) {\n            cameraRotation += CameraRotationSensitivity * frameTimeDelta;\n        }\n        if (IsKeyPressed(KEY_Q)) {\n            cameraRotation -= CameraRotationSensitivity * frameTimeDelta;\n        }\n        \n        vec2 rotation = sincos(cameraRotation * PI / 180.0f);\n        vec2 cameraOffset = vec2(0.0f, 0.0f);\n        if (IsKeyPressed(KEY_W)) {\n            cameraOffset -= vec2(rotation.x, rotation.y);\n        }\n        if (IsKeyPressed(KEY_S)) {\n            cameraOffset += vec2(rotation.x, rotation.y);\n        }\n        if (IsKeyPressed(KEY_D)) {\n            cameraOffset -= vec2(rotation.y, -rotation.x);\n        }\n        if (IsKeyPressed(KEY_A)) {\n            cameraOffset += vec2(rotation.y, -rotation.x);\n        }\n        \n        if (any(notEqual(cameraOffset, vec2(0.0f))))\n            cameraOffset = normalize(cameraOffset);\n        vec3 cameraLookAt = ReadCameraLookAt() + vec3(cameraOffset, 0.0f) * CameraMoveSensitivity * frameTimeDelta;\n        fragColor = vec4(cameraRotation, cameraLookAt);\n    }\n    \n    if (ivec2(fragCoord) == ZOOM_ADDRESS)\n    {\n        float cameraZoom = ReadCameraZoom();\n        if (IsKeyPressed(KEY_F)) {\n            cameraZoom += CameraZoomSensitivity * frameTimeDelta;\n        }\n        if (IsKeyPressed(KEY_G)) {\n            cameraZoom -= CameraZoomSensitivity * frameTimeDelta;\n        }\n\n        fragColor.x = clamp(cameraZoom, 1.0f, 4.0f);\n    }\n    if (ivec2(fragCoord) == HEIGHT_ADDRESS)\n    {\n        float cameraHeight = ReadCameraHeight();\n        if (IsKeyPressed(KEY_R)) {\n            cameraHeight -= CameraHeightSensitivity * frameTimeDelta;\n        }\n        if (IsKeyPressed(KEY_T)) {\n            cameraHeight += CameraHeightSensitivity * frameTimeDelta;\n        }\n\n        fragColor.y = clamp(cameraHeight, 0.3f, 1.2f);\n    }\n    \n    if (ivec2(fragCoord) == DEMO_TYPE_ADDRESS)\n    {\n        float demoType = ReadDemoType();\n        for (int i = 0; i < DemosCount; ++i) {\n            if (IsKeyPressed(KEY_1 + i)) {\n                demoType = float(i);\n            }\n        }\n\n        fragColor.z = demoType;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define INF (1e10)\n\nfloat saturate(float value) {\n    return clamp(value, 0.0f, 1.0f);\n}\nvec2 saturate(vec2 value) {\n    return clamp(value, 0.0f, 1.0f);\n}\nvec3 saturate(vec3 value) {\n    return clamp(value, 0.0f, 1.0f);\n}\nvec4 saturate(vec4 value) {\n    return clamp(value, 0.0f, 1.0f);\n}\nvec2 sincos(float x) {\n    return vec2(sin(x), cos(x));\n}\n\nconst ivec2 ROTATION_ADDRESS = ivec2(0, 0);\nconst ivec2 LOOKAT_ADDRESS = ivec2(0, 0);\nconst ivec2 ZOOM_ADDRESS = ivec2(1, 0);\nconst ivec2 HEIGHT_ADDRESS = ivec2(1, 0);\n\nconst ivec2 DEMO_TYPE_ADDRESS = ivec2(1, 0);\nconst float DemoSquareGrid = 0.0f;\nconst float DemoHexGrid = 1.0f;\nconst float DemoVisualizeSS = 2.0f;\nconst int DemosCount = 3;","name":"Common","description":"","type":"common"}]}