{"ver":"0.1","info":{"id":"dlKGRW","date":"1684236851","viewed":41,"name":"Flower-Thing V1","username":"mnasell","description":"Just tried to use a 2D function and get somewhere with raymarching at all :).\nMost components are borrowed from others (ie. @iq excellent webpage-resources and @BigWIngs videos).\nSorry! Can't figure out light source. ¯\\_(ツ)_/¯\nStill so much to learn...","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["useless","flowerthing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int   MAX_STEPS = 256;\nconst float MIN_DIST  = 0.0;\nconst float MAX_DIST  = 200.0;\nconst float PRECISION = 0.001;\nconst float EPSILON   = 0.0005;\nconst float PI        = 3.141593;\nconst float THICKNESS = 0.3;\n\nconst float radius    = 1.0;\nconst float frequency = 7.0;\nfloat amplitude       = 0.25;\nfloat phaseshift      = 0.0;\n\nconst vec3  lightPosition1  = vec3(1, 1, 1);\nconst float lightIntensity1 = 0.4;\nconst vec3  lightPosition2  = vec3(-6, -4, -3);\nconst float lightIntensity2 = 0.3;\n\nconst vec3 palette[] = vec3[](\n    vec3(.75, .75, 0.),\n    vec3(.0, .0, .75),\n    vec3(.75, 0.0, 0.75),\n    vec3(1.0, .5, 0.)\n);\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec3 mapColor(float value) {\n    int index1 = int(value * float(palette.length()));\n    int index2 = (index1 + 1) % palette.length();\n    float factor = fract(value * float(palette.length()));\n    return mix(palette[index1], palette[index2], factor);\n}\n\nmat3 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat3(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n  );\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}   \n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec2 sdShape(vec3 p, float thickness) {\n    float angle   = atan(p.y, p.x);\n    float outline = (radius + amplitude * cos(frequency * angle + phaseshift));\n    float base    = .5*length(p.yx);\n    float surf1   = base - outline;\n    float surf2   = base - (outline*.33);    \n    float extr    = abs(p.z) - thickness;        \n    float outter  = opSmoothIntersection(surf1,extr,.25);\n    if (iMouse.z > 0.) {\n        float sphere  = length(p)-(3.*sin(iTime*5.)*0.5+0.5);\n        return vec2( opSmoothUnion(max(surf2,sphere),outter,0.5), outline);\n    } else {\n        return vec2( opSmoothSubtraction(surf2,outter,.25), outline);\n    }\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float c     = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    vec2 vd = sdShape(p,THICKNESS);\n    depth += vd.x;\n    c=vd.y;\n    if (vd.x < PRECISION || depth > MAX_DIST) {\n        break;\n    }\n  }\n  return vec2(depth,c);\n}\n\nvec3 calcNormal(vec3 p)\n{\n  const float h = 0.01;\n  const vec2  k = vec2(1.,-1.);\n  return normalize( k.xyy*sdShape( p + k.xyy*h,THICKNESS ).x + \n                    k.yyx*sdShape( p + k.yyx*h,THICKNESS ).x + \n                    k.yxy*sdShape( p + k.yxy*h,THICKNESS ).x + \n                    k.xxx*sdShape( p + k.xxx*h,THICKNESS ).x );\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 K_a, vec3 lightDir, float lightIntensity, vec3 rd, vec3 normal) {\n  vec3  K_d = vec3(1);\n  vec3  K_s = vec3(1);\n  float alpha = 50.;\n  float diffuse = clamp(dot(lightDir, normal), 0., 1.);\n  float specular = pow(clamp(dot(reflect(lightDir, normal), -rd), 0., 1.), alpha);\n  return lightIntensity * (K_a + K_d * diffuse + K_s * specular);\n}\n\nfloat fresnel(vec3 n, vec3 rd) {\n  return pow(clamp(1. - dot(n, -rd), 0., 1.), 5.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    phaseshift = iTime*2.;\n    amplitude  = cos(iTime*.25)*0.3;\n    vec2  uv = (2.*fragCoord.xy - iResolution.xy)/ iResolution.y;    \n    vec3  ro = vec3(0, 0, 4.0) * rotation3d(vec3(0.,1.,0.),mix(-PI, PI, fract(iTime*0.05)));\n    vec3  rd = camera(ro, vec3(0)) * normalize(vec3(uv, -1.0));    \n    vec2  vd = rayMarch(ro, rd);\n\n    vec3  p  = ro + rd * vd.x;\n    vec3  n  = calcNormal(p);    \n    \n    float ci = map(vd.y,radius-amplitude,radius+amplitude,0.0,0.5);\n    vec3  oc = mapColor(fract(ci-iTime*0.05));\n    vec3  bc =  vec3(length(uv)-0.75) * mapColor(fract(sqrt(uv.x*uv.x*uv.x*uv.x+uv.y*uv.y*uv.y*uv.y)-iTime*0.2));\n    vec3 lightDirection1 = normalize(lightPosition1 - p);\n    vec3 lightDirection2 = normalize(lightPosition2 - p);\n\n    vec3  color = vec3(0.);\n    color += phong(oc,lightDirection1, lightIntensity1, rd, n);\n    color += phong(oc,lightDirection2, lightIntensity2, rd, n);\n    color += fresnel(n, rd) * 0.4;  \n        \n    fragColor = vec4(mix(bc, color, step(vd.x - MAX_DIST, 0.)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}