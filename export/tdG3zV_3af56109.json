{"ver":"0.1","info":{"id":"tdG3zV","date":"1571076568","viewed":191,"name":"Wavy Blocks","username":"ParaBellum","description":"Playing around with random and ray marching\nYou can move the camera with the mouse left click and moving it","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","random","blocks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 700\n#define MIN_DIS .01\n#define STEP_SIZE .075\n\n#define PI 3.141592\n\n#define DISP 1.\n\n#define MIN_SHADOW .1\n#define MAX_SHADOW .2\n\n#define AO_SAMPLES 1.\n#define AO_INTENSITY 1.\n\n#define T iTime*.5\n#define L_P vec3(0., 10., 100.)\n#define SHININNESS 16.\n\n#define B vec3(.1)\n#define W vec3(1.)\n#define C1 vec3(.0, .1, .0)\n#define C2 vec3(.0, .6, .0)\n\nfloat hash21(in vec2 p)\n{\n    return fract(sin(dot(p, vec2(23.1, 98.3))) * 65192.8);\n}\n\nfloat plane(in vec3 p)\n{\n    float h21 = hash21(floor(p.xz))*DISP;\n    h21 += (sin((p.x*.1)+T)*cos((p.z*.1)+T))*2.5;\n    return p.y-h21;\n}\n\nfloat scene(in vec3 p)\n{\n    return plane(p);\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, 0.);\n    float d = scene(p);\n    vec3 n = d - vec3(scene(p-e.xyy), scene(p-e.yxy), scene(p-e.yyx));\n    return normalize(n);\n}\n\nfloat phong(in vec3 p, in vec3 n, in vec3 o)\n{\n    vec3 ld = normalize(L_P - p);\n    vec3 vd = normalize(o - p);\n    vec3 hv = normalize(ld + vd);\n    \n    float Kd = max(dot(n, ld), 0.);\n    float Ks = pow(max(dot(n, hv), 0.), SHININNESS);\n    \n    return Kd+Ks;\n}\n\nfloat hShadow(in vec3 o)\n{\n    vec3 d = normalize(L_P - o);\n    float t = MIN_SHADOW;\n    for (int i = 0; i < 1; i+=0)\n    {\n        float s = scene(o + d * t);\n        if (s < .01)\n            return 0.5;\n        if (t > MAX_SHADOW)\n            break;\n        t += s;\n    }\n   \treturn 1.;\n}\n\nfloat ambientOcclusion(in vec3 p, in vec3 n)\n{\n    float s = 1. / AO_SAMPLES;\n    float ao = clamp((s-scene(p + n * s))*AO_INTENSITY, 0., 1.);\n    return 1. - ao / AO_SAMPLES;\n}\n\nfloat shade(in vec3 p, in vec3 o)\n{\n    vec3 n = normal(p);\n    float ph = phong(p, n, o);\n    float a = .25;\n    float s = hShadow(p);\n    s = pow(s, 2.);\n    float ao = ambientOcclusion(p, n);\n    return clamp(ph*s + a*ao, 0., 1.);\n}\n\nfloat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float s = scene(o + d * t);\n        if (s < MIN_DIS)\n            return t;\n        t += s*STEP_SIZE;\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 ms = iMouse.xy/iResolution.xy*2.-1.;\n    ms.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n    float h = 12.;\n    vec3 o = vec3(ms.x*5., h, 0.);\n    vec3 t = vec3(0., h-2.+ms.y*5., h/2.);\n    vec3 f = normalize(o-t);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n\tvec3 d = uv.x*r + uv.y*u - f;\n\n    float m = marcher(o, d);\n    if ( m > -1.)\n    {\n        vec3 p = o + d * m;\n\n        float h21 = hash21(floor(p.xz));\n        col += shade(p, o);\n        vec3 C = abs(vec3(sin(T), 0., cos(T)));\n        if (h21 < .94)\n          \tcol *= B;\n        else if (h21 >= .94 && h21 < .96)\n            col *= C1+C;\n        else if (h21 >= .96 && h21 < .98)\n            col *= C2+C;\n        else if (h21 >= .98)\n            col *= W;\n    }\n    \n    fragColor = vec4(sqrt(col), 1.);\n}","name":"Image","description":"","type":"image"}]}