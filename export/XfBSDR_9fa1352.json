{"ver":"0.1","info":{"id":"XfBSDR","date":"1707294713","viewed":101,"name":"my first pathtracer w. controls","username":"thomThalas","description":"FOV: UP and DOWN arrow.\ncamera dist Z and X\nMovement: WASDQE\nShift: 2X speed. (This speeds up everything)\nC: 1/15 speed. (Same here)\nDOF Aperture: 1 and 2\nDOF Focus dist: 3 and 4\nDebug mode: LEFT and RIGHT arrow (LIST of debugs in BUFFER A)\n","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["3d","raytracing","raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define img(x) texelFetch(iChannel0, ivec2(x), 0);\n\nvoid mainImage(out vec4 fragColor, in vec2 coord)\n{\n    vec4 color = img(coord);\n    \n    color.xyz = clamp(color.xyz, 0., 1.);\n    \n    \n    \n    \n    //Some random easing functions. From easings.net\n    color.xyz = easeInOutSine(color.xyz);\n    color.xyz = easeOutCirc(color.xyz);\n    \n    \n    \n    fragColor = pow(color, vec4(vec3(0.75), 1.));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n/*//////////////////////////////////////\nDEBUG MODES:\n    1: Depth of field focus distance.\n    2: Normals\n    3: Fresnel\n    4: Base color\n    5: Emmision\n//////////////////////////////////////*/\n\n\n#define inf 9e20 \n\n#define time 0.49\n\n\n\n\n\n\n\n//https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//This function is from someone else. I don't remember where from tho. Tust me i serached through all of my search history. Couldn't find it.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n\n//A struct for material data.\nstruct Material\n{\n    vec3 color;\n    vec3 emmision;\n    float smoothness;\n    float specular;\n    float ior;\n    float metallic;\n    float height;\n    bool useHeight;\n    \n};\n\n\n//This returns the whole map/scene distance. I can make it more effeicent but i don't wanna. Because it's very complex and don't want to do anymore headbaning.\n//Why am i even writing this. It's not like anybodys gonna read it. Unless you are reading it at the moment then well you are reading it. \n//God i have not made a single comma in a long time.\nfloat map(vec3 p, out Material material, bool calculateMaterial)\n{\n    \n    vec3 _floor = p;\n    vec3 _mainbox = p;\n    vec3 cylinder0 = p;\n    vec3 someCapsule = p;\n    vec3 movingSphere = p;\n    vec3 wallLoc = p;\n    vec3 player = p;\n\n    // Calculate distances to objects\n    _floor -= vec3(0,-2,0);\n    float objFloor = sdBox(_floor, vec3(10.,0.5,10.));\n\n    _mainbox -= vec3(0, -1, 0);\n    float mainbox = sdBox(_mainbox, vec3(1.));\n\n    _mainbox -= vec3(0,2,0);\n    float frameBoxes = sdBoxFrame(_mainbox, vec3(0.8), 0.05);\n    _mainbox.yz *= rot2D(time*2.);\n    _mainbox.xz *= rot2D(time*4.);\n    frameBoxes = opSmoothUnion(frameBoxes, sdBox(_mainbox, vec3(0.35)), 1.1);\n\n    cylinder0 -= vec3(10,0,0);\n    cylinder0.yz *= rot2D(0.9);\n    cylinder0.xy *= rot2D(-0.9);\n    float cylinderDist = sdCylinder(cylinder0, vec3(1.));\n\n    someCapsule -= vec3(2., -1.5, -2.);\n    float capsuleDist = sdVerticalCapsule(someCapsule, 1., 0.5);\n\n    movingSphere.xz *= rot2D(-time*1.5);\n    movingSphere -= vec3(3.,2.,0.);\n    float sphereDist = sdSphere(movingSphere, 0.5);\n    \n    wallLoc -= vec3(-5., 0., 0.);\n    \n    float wallDist = sdBox(wallLoc, vec3(0.5, 3., 10.));\n    \n    \n    player -= vec3(1.56, 0., 0.);\n\n    float playerDist = sdBox(player, vec3(0.5));\n    \n    \n    \n    \n    \n\n    //blending all the shapes together.\n    float value = opSmoothUnion(objFloor, mainbox, 1.);\n    value = min(value, frameBoxes);\n    value = opSmoothUnion(value, cylinderDist, 1.);\n    value = opSmoothUnion(value, capsuleDist, 1.);\n    value = min(value, sphereDist);\n    value = min(value, wallDist);\n    value = opSmoothUnion(value, playerDist, 0.2);\n    \n    \n    if(calculateMaterial)\n    {\n        // Calculating materials based on how close a ray is to the object.\n        material.specular = 0.9;\n        material.metallic = 0.;\n        material.ior = 0.;\n        material.smoothness = 0.85;\n\n\n        if(sphereDist < 0.002)\n        {\n            material.color = vec3(0.);\n            material.emmision = vec3(15., 0., 0.);\n            material.specular = 0.;\n        } \n        else if(wallDist < 0.002)\n        {\n            material.color = vec3(0.);\n            material.emmision = vec3(0, 0, 2.);\n            material.specular = 0.;\n        }\n        else if(frameBoxes < 0.002)\n        {\n            material.color = vec3(0., 0., 0.);\n            material.emmision = vec3(3.);\n        }\n        else if(playerDist < 0.002)\n        {\n            material.color = tex3D(iChannel2, player, vec3(4,4,4));\n            material.ior = 0.8;\n            material.smoothness = 0.95;\n            material.metallic = 1.;\n            material.useHeight = true;\n            material.height = material.color.z / 200.;\n            material.color = pow(material.color, vec3(1.5));\n        }\n        else\n        {\n            material.color = tex3D(iChannel1, p / 2., vec3(4,4,4));\n            material.specular = 0.5;\n            material.useHeight = true;\n            material.height = material.color.x / 100.;\n        }\n    }\n    \n\n    return value;\n}\n\n\n\n\n\n//I get the normal by sampling distances around the source point.\nvec3 GetNormal(vec3 p)\n{   \n    Material material;\n    float d = map(p, material, true);\n    \n    bool useHeight = material.useHeight;\n    \n    float detail = 0.001;\n    \n    float xp = 0.;\n    float xn = 0.;\n    \n    float yp = 0.;\n    float yn = 0.;\n    \n    float zp = 0.;\n    float zn = 0.;\n    \n    \n    if(useHeight)\n    {\n        xp = map(p + vec3(detail,0.,0.), material, true) - d;\n        xp += material.height;\n        \n        xn = map(p - vec3(detail,0.,0.), material, true) - d;\n        xn += material.height;\n        \n        yp = map(p + vec3(0.,detail,0.), material, true) - d;\n        yp += material.height;\n        \n        yn = map(p - vec3(0.,detail,0.), material, true) - d;\n        yn += material.height;\n        \n        zp = map(p + vec3(0.,0.,detail), material, true) - d;\n        zp += material.height;\n        \n        zn = map(p - vec3(0.,0.,detail), material, true) - d;\n        zn += material.height;\n    }\n    else\n    {\n        xp = map(p + vec3(detail,0.,0.), material, false) - d;\n        xn = map(p - vec3(detail,0.,0.), material, false) - d;\n\n        yp = map(p + vec3(0.,detail,0.), material, false) - d;\n        yn = map(p - vec3(0.,detail,0.), material, false) - d;\n\n        zp = map(p + vec3(0.,0.,detail), material, false) - d;\n        zn = map(p - vec3(0.,0.,detail), material, false) - d;\n    }\n    \n    \n    \n    vec3 n = vec3(0.);\n    n.x += xp;\n    n.x -= xn;\n    n.y += yp;\n    n.y -= yn;\n    n.z += zp;\n    n.z -= zn;\n    \n    return normalize(n);\n}\n\n\n\n// This is self explanatory. Also i have absolutely no idea if i did this one right.\nfloat calcFresnel(vec3 normal, vec3 view, float ior) {\n    \n    float angle = dot(normal, view);\n    return ior + (1. - ior) * pow(1. - clamp(angle, 0., 1.), 5.); //This is Schlick's approximation maybe.\n    \n    //return pow((-dot(view, normal) + 1.), ior + 1.); //This was my simple implementation\n    \n}\n\n//This is a struct that holds all the data for a ray that that has hit something used by SendRay.\nstruct RayData\n{\n    bool hit;\n    vec3 pos;\n    vec3 normal;\n    vec3 reflection;\n    float rayLength;\n    Material material;\n};\n\n//This sends a ray though a scene.\nRayData SendRay(in vec3 ro, in vec3 rd, in int iterations, in float hitSensitivity, in float missSensitivity, in float maxDist)\n{\n    float t = 0.;\n\n    bool hit = false;\n    \n    vec3 pos = vec3(0.);\n    \n    vec3 normal = vec3(0.);\n    \n    vec3 reflection = vec3(0.);\n    \n    Material material = Material(vec3(0), vec3(0.), 1., 1., 0., 0., 0., false);\n    \n    \n    for(int i = 0; i < iterations && t < maxDist; i++)\n    {\n        vec3 p = ro + rd * t;\n    \n        float d = map(p, material, false);\n\n        t += d; \n\n        \n        \n        if(d < hitSensitivity)\n        {\n            hit = true;\n            break;\n        }\n        else if(d > missSensitivity)\n        { \n            \n            break;\n        }\n        \n    }\n    \n    pos = ro + rd * t;\n    \n    if(hit)\n    {\n\n        normal = GetNormal(pos);\n        reflection = normalize(reflect(rd, normal));\n        map(pos, material, true);\n        \n    }\n    else\n    {\n        t = maxDist;\n    }\n\n    return RayData(hit, pos, normal, reflection, t, material);\n}\n\n//Defining diffrent function overloads i really only use the bottom one\nRayData SendRay(in vec3 ro, in vec3 rd, in int iterations)\n{\n    return SendRay(ro, rd, iterations, 0.001, 100., inf);\n}\n\nRayData SendRay(in vec3 ro, in vec3 rd, in float maxDist)\n{\n    return SendRay(ro, rd, 1000, 0.001, 1000., maxDist);\n}\n\nRayData SendRay(in vec3 ro, in vec3 rd)\n{\n    return SendRay(ro, rd, 500, 0.001, 20., 30.);\n}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int debugModeVal = int(debugMode(iChannel3).x);\n    \n    vec2 mouse = (iMouse.xy - iResolution.xy / 2.) / iResolution.xy - 0.1;\n    \n    //vec2 mouseControlMouse = iMouse.xy / iResolution.xy;\n    \n    if(iMouse.y < 1.)\n    {\n        mouse = vec2(-0.1, -0.03);\n    }\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    vec2 backgroundUV = fragCoord / iResolution.y;\n    \n    float someT = time * 5.;\n    \n    vec3 ro = vec3(0, 0., -cameraDistance(iChannel3).x);\n    \n    vec2 dofOffset = normalize(randvec(mod(iTime, 60.))).xy * cameraAperture(iChannel3).x;\n    \n    ro.xy += dofOffset;\n    //The commented out lines here are for orthographic perspective.\n    //ro += vec3(uv * 3., 0.);\n    vec3 rd = normalize(vec3(uv, zoom(iChannel3).x));\n    \n    rd.xy -= dofOffset / cameraFocusDistance(iChannel3).x;\n    rd = normalize(rd);\n    //vec3 rd = vec3(0., 0., 1.);\n    \n    \n    \n    \n    ro.yz *= rot2D(-mouse.y * 3.);\n    rd.yz *= rot2D(-mouse.y * 3.);\n    \n    ro.xz *= rot2D(-mouse.x * 8.);\n    rd.xz *= rot2D(-mouse.x * 8.);\n    \n    ro += cameraPosition(iChannel3).xyz;\n    \n    \n    vec3 color = vec3(0.);\n\n    vec4 background = vec4(vec3(0.),0);\n    \n    RayData mainRay = SendRay(ro, rd);\n    \n    vec3 fresnel = vec3(calcFresnel(mainRay.normal, -rd, mainRay.material.ior));\n    \n    vec3 diffuse = vec3(0.);\n    vec3 reflection = vec3(0.);\n\n\n\n\n\n\n    float seed = Vec3ToIndex(mainRay.pos + mod(iTime, 60.)*0.5, vec2(10.,10.));\n\n    if(mainRay.hit)\n    {\n\n\n        vec3 secondRayDirection = normalize(RandomVecCone(seed, mainRay.normal));\n        RayData secondRay = SendRay(mainRay.pos + mainRay.normal * 0.01, secondRayDirection);\n\n        vec3 reflectionRayDirection = mix(secondRayDirection, mainRay.reflection, mainRay.material.smoothness);\n\n        RayData reflectionRay = SendRay(mainRay.pos + mainRay.reflection * 0.01, reflectionRayDirection);\n\n        if(secondRay.hit)\n        {\n            diffuse = secondRay.material.emmision * mainRay.material.color;\n        }\n\n\n        if(reflectionRay.hit)\n        {\n            reflection = reflectionRay.material.emmision * fresnel * mainRay.material.specular \n            * mix(vec3(1.), mainRay.material.color, mainRay.material.metallic);\n        }\n\n    }\n\n    color += diffuse + reflection;\n\n    color += mainRay.material.emmision;\n\n    if(!mainRay.hit)\n    {\n        background.w = 1.;\n\n    }\n    \n\n    color = mix(color, background.xyz, background.w);\n    \n\n\n\n\n\n\n\n    \n    float frame = float(iFrame) - texelFetch(iChannel3, frameBuffLoc, 0).x;\n    \n    \n    vec3 last = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    switch(debugModeVal)\n    {\n        case 0:\n            break;\n        case debugFocusDistance:\n            float dist = cameraFocusDistance(iChannel3).x;\n            vec3 debug = vec3(0., 0., mainRay.rayLength / 40.);\n            debug.x = 0.1 - abs(dist - mainRay.rayLength) / pow(dist, 0.5);\n            debug.x = clamp(debug.x, 0., 1.);\n            debug.x = pow(debug.x, 1.5);\n            debug.x *= 20.;\n            color = debug;\n            break;\n        case debugNormal:\n            color = mainRay.normal;\n            break;\n        case debugFresnel:\n            color = fresnel;\n            break;\n        case debugColor:\n            color = mainRay.material.color;\n            break;\n        case debugEmmision:\n            color = mainRay.material.emmision;\n    }\n    \n    \n    color = mix(last, color, 1./max(frame, 1.)); //it's not a mistake that i don't have a plus one on the frame. The buffer is one frame behind for some reason.\n    \n    \n    \n    //color = mix(last, color, 0.5);\n    \n\n    \n    \n    fragColor = vec4(color * vec3(1.,1.,1.), 1);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n#define frameBuffLoc ivec2(0,0)\n\n#define zoomBuffer ivec2(2, 0)\n#define zoom(x) texelFetch(x, zoomBuffer, 0)\n\n#define cameraPositionBuffer ivec2(3, 0)\n#define cameraPosition(x) texelFetch(x, cameraPositionBuffer, 0)\n\n#define cameraDistanceBuffer ivec2(4, 0)\n#define cameraDistance(x) texelFetch(x, cameraDistanceBuffer, 0)\n\n#define cameraApertureBuffer ivec2(5, 0)\n#define cameraAperture(x) texelFetch(x, cameraApertureBuffer, 0)\n\n#define cameraFocusDistanceBuffer ivec2(6, 0)\n#define cameraFocusDistance(x) texelFetch(x, cameraFocusDistanceBuffer, 0)\n\n#define debugModeBuffer ivec2(7, 0)\n#define debugMode(x) texelFetch(x, debugModeBuffer, 0)\n#define debugFocusDistance 1\n#define debugNormal 2\n#define debugFresnel 3\n#define debugColor 4\n#define debugEmmision 5\n\n\n\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n//Got this from https://www.shadertoy.com/view/3djyWW\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x+y)*(y*y-x)+x)/2.14e9;\n}\n\n//Got this from https://www.shadertoy.com/view/3djyWW\nvec3 randvec(float seed) {\n    float h1 = hash(seed, seed);\n    float h2 = hash(h1, seed);\n    float h3 = hash(h2, seed);\n    return vec3(h1,h2,h3);\n}\n\n\n//Random vector that is within a 180 degree cone A.K.A a half circle\nvec3 RandomVecCone(float seed, vec3 dir)\n{\n    vec3 v = randvec(seed);\n    float dotProd = dot(v,dir) < 0. ? -1. : 1.;\n    return v * dotProd;\n}\n\n\n\n//Creates a seed from a vector3\nfloat Vec3ToIndex(vec3 val, vec2 size) {\n    return (val.z * size.x * size.y) + (val.y * size.x) + val.x;\n}\n\n\n\n\n\n\n//https://easings.net/\nfloat easeOutCirc(float x) {\n    return sqrt(1. - pow(x - 1., 2.));\n}\n\n\nvec3 easeOutCirc(vec3 val)\n{\n    return vec3(easeOutCirc(val.x), easeOutCirc(val.y), easeOutCirc(val.z));\n}\n\n//https://easings.net/\nfloat easeInOutSine(float x) {\n    return -(cos(PI * x) - 1.0) / 2.0;\n}\n\nvec3 easeInOutSine(vec3 val)\n{\n    return vec3(easeInOutSine(val.x), easeInOutSine(val.y), easeInOutSine(val.z));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// per second\n#define CAMERA_MOVMENT_SPEED 1.5\n\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n\n#define KEY_Q 81\n#define KEY_E 69\n\n#define KEY_Z 90\n#define KEY_X 88\n\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n\n#define KEY_SHIFT 16\n#define KEY_C 67\n\n#define DOWN 0\n#define PRESSED 1\n#define TOGGLE 2\n\n#define KEY(chanl, key, type) (texelFetch(chanl, ivec2(key, type), 0).x > 0.5)\n#define KEY1(key, type) KEY(iChannel1, key, type)\n\n\nvoid mainImage( out vec4 o, in vec2 coord )\n{\n    ivec2 iCoord = ivec2(coord);\n    float dt = iTimeDelta;\n    \n    float multiplier = 1.;\n        \n    if(KEY1(KEY_SHIFT, DOWN))\n    {\n        multiplier = 2.;\n    }\n    else if(KEY1(KEY_C, DOWN))\n    {\n        multiplier = 0.06666666666;\n    }\n    \n    \n    if(iCoord == frameBuffLoc)\n    {\n        if(iMouse.z > 0.5 || KEY1(KEY_LEFT, DOWN) || KEY1(KEY_RIGHT, DOWN) || KEY1(KEY_UP, DOWN) || KEY1(KEY_DOWN, DOWN) \n        || KEY1(KEY_W, DOWN) || KEY1(KEY_S, DOWN) || KEY1(KEY_D, DOWN) || KEY1(KEY_A, DOWN) || KEY1(KEY_Q, DOWN) || KEY1(KEY_E, DOWN)\n        || KEY1(KEY_Z, DOWN) || KEY1(KEY_X, DOWN)\n        || KEY1(KEY_1, DOWN) || KEY1(KEY_2, DOWN) || KEY1(KEY_3, DOWN) || KEY1(KEY_4, DOWN)\n        || iFrame <= 3)\n        {\n            o = vec4(iFrame);\n        }\n        else\n        {\n            o = texelFetch(iChannel0, ivec2(coord), 0);\n        }\n    }\n    else if(iCoord == zoomBuffer)\n    {\n        o = zoom(iChannel0);\n        if(iFrame == 0)\n        {\n            o.x = 1.3;\n        }\n        if(KEY1(KEY_UP, DOWN))\n        {\n            o.x += dt * multiplier;\n        }\n        if(KEY1(KEY_DOWN, DOWN))\n        {\n            o.x -= dt * multiplier;\n        }\n        o = max(o, 0.05);\n    }\n    else if(iCoord == cameraPositionBuffer)\n    {\n        o = cameraPosition(iChannel0);\n        if(iFrame == 0)\n        {\n            o = vec4(vec3(0., 0.5, 0.), 0.);\n        }\n        \n        vec2 mouse = (iMouse.xy - iResolution.xy / 2.) / iResolution.xy - 0.1;\n    \n        //vec2 mouseControlMouse = iMouse.xy / iResolution.xy;\n\n        if(iMouse.y < 10.)\n        {\n            mouse = vec2(-0.1, -0.03);\n        }\n        \n        \n        mouse *= vec2(-8., -3.);\n        \n        vec3 right = vec3(1., 0., 0.);\n        vec3 forward = vec3(0., 0., 1.);\n        \n        right.xz *= rot2D(mouse.x);\n        forward.xz *= rot2D(mouse.x);\n        \n        \n        \n        if(KEY1(KEY_W, DOWN))\n        {\n            o.xyz += forward * dt * CAMERA_MOVMENT_SPEED * multiplier;\n        }\n        if(KEY1(KEY_S, DOWN) )\n        {\n            o.xyz -= forward * dt * CAMERA_MOVMENT_SPEED * multiplier;\n        }\n        if(KEY1(KEY_D, DOWN))\n        {\n            o.xyz += right * dt * CAMERA_MOVMENT_SPEED * multiplier;\n        }\n        if(KEY1(KEY_A, DOWN))\n        {\n            o.xyz -= right * dt * CAMERA_MOVMENT_SPEED * multiplier;\n        }\n        if(KEY1(KEY_Q, DOWN))\n        {\n            o.y -= dt * CAMERA_MOVMENT_SPEED * multiplier;\n        }\n        if(KEY1(KEY_E, DOWN))\n        {\n            o.y += dt * CAMERA_MOVMENT_SPEED * multiplier;\n        }\n        \n    }\n    else if(iCoord == cameraDistanceBuffer)\n    {\n        o = cameraDistance(iChannel0);\n        \n        if(iFrame == 0)\n        {\n            o.x = 4.5;\n        }\n        if(KEY1(KEY_Z, DOWN))\n        {\n            o.x += dt * 2. * multiplier;\n        }\n        if(KEY1(KEY_X, DOWN))\n        {\n            o.x -= dt * 2. * multiplier;\n        }\n        o = max(o, 0.0);\n        \n    }\n    else if(iCoord == cameraApertureBuffer)\n    {\n        o = cameraAperture(iChannel0);\n        if(iFrame == 0)\n        {\n            o.x = 0.1;\n        }\n        \n        if(KEY1(KEY_1, DOWN))\n        {\n            o.x -= dt * 0.05 * multiplier;\n        }\n        if(KEY1(KEY_2, DOWN))\n        {\n            o.x += dt * 0.05 * multiplier;\n        }\n        \n        o.x = max(min(o.x, 2.), 0.);\n    }\n    else if(iCoord == cameraFocusDistanceBuffer)\n    {\n        o = cameraFocusDistance(iChannel0);\n        if(iFrame == 0)\n        {\n            o.x = 4.5;\n        }\n        \n        if(KEY1(KEY_3, DOWN))\n        {\n            o.x -= dt * 1. * multiplier;\n        }\n        if(KEY1(KEY_4, DOWN))\n        {\n            o.x += dt * 1. * multiplier;\n        }\n        \n        o.x = max(o.x, 0.06);\n    }\n    else if(iCoord == debugModeBuffer)\n    {\n        if(iFrame == 0)\n        {\n            o.x = 0.;\n        }\n        \n        o = debugMode(iChannel0);\n        \n        if(KEY1(KEY_RIGHT, PRESSED))\n        {\n            o.x += 1.;\n        }\n        if(KEY1(KEY_LEFT, PRESSED))\n        {\n            o.x -= 1.;\n        }\n        o.x = mod(o.x, 6.);\n        \n        o.x = round(o.x);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer D","description":"","type":"buffer"}]}