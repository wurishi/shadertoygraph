{"ver":"0.1","info":{"id":"llGcDz","date":"1535737183","viewed":470,"name":"Dancing H ðŸ•º","username":"luruke","description":"An H that dance ðŸ•º","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","ao","h","letter","breakdance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nstruct Camera {\n  vec3 position;\n  vec3 target;\n  float fov;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct Light {\n  vec3 position;\n};\n\nvec3 calculateRayDirection(Camera c, vec2 uv) {\n  vec3 forward = normalize(c.target - c.position);\n  vec3 right = normalize(vec3(forward.z, 0.0, -forward.x));\n  vec3 up = normalize(cross(forward, right));\n\n  return normalize(forward + c.fov * uv.x * right + c.fov * uv.y * up);\n}\n\n////\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n    vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c)\n    );\n}\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n    vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c)\n    );\n}\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n    vec3(c, -s, 0), vec3(s, c, 0), vec3(0, 0, 1)\n    );\n}\n\nfloat voxel(vec3 p, mat4 m) {\n  vec3 tp = vec3(m * vec4(p, 1.0)).xyz;\n  vec3 size = vec3(1.0);\n\n  vec3 d = abs(tp) - size;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat scene(vec3 op){\n  vec3 p = op;\n\n  p.x = -p.x;\n\n  p = rotateY(p.y * 0.1 + iTime + sin(iTime)) * p;\n  p = rotateY(p.y * 0.1 + iTime) * p;\n  p = rotateZ(p.y * 0.03 + sin(iTime) * 0.3 * .05 + iTime) * p;\n  p = rotateZ(p.y * 0.01 + sin(iTime)) * p;\n\n  // H\n  float h = voxel(p, mat4(0.0,-0.0,-0.2996,-0.0,-1.0,0.0,-0.0,0.0,0.0,1.0,0.0,-0.0,-0.0,0.0,-0.0,1.0));\n  h = min(h, voxel(p, mat4(-1.0,-0.0,0.0,-0.0,-0.0,0.0,0.1597,0.0,0.0,1.0,0.0,-0.0,-2.5,0.0,-0.0,1.0)));\n  h = min(h, voxel(p, mat4(-1.0,-0.0,0.0,-0.0,-0.0,0.0,0.1597,0.0,0.0,1.0,0.0,-0.0,2.5,-0.0,-0.0,1.0)));\n\n  float plane = dot(op, normalize(vec3(0.0, 0.0, -1.0))) + 12.1;\n\n  return min(h, plane);\n}\n\n#define FAR 200.\n#define INFINITY 1e32\nfloat t_min = 2.01;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 125;\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n// https://www.shadertoy.com/view/4tVXRV\nfloat march(Ray r) {\n    vec3 o = r.origin;\n    vec3 d = r.direction;\n\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.2;\n    float stepLength = 0.;\n    float pixelRadius = 0.0001;\n    float functionSign = scene(o) < 0. ? -1. : 1.;\n    float mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        mp = scene(d * t + o);\n        float signedRadius = functionSign * mp;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) return 0.0;\n    \n    return candidate_t;\n}\n\n// 4 taps\n// https://iquilezles.org/articles/normalsSDF\nvec3 calculateNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.1; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ) + \n                      k.yyx*scene( p + k.yyx*h ) + \n                      k.yxy*scene( p + k.yxy*h ) + \n                      k.xxx*scene( p + k.xxx*h ) );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - scene( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// https://www.shadertoy.com/view/4scSW4\nfloat fresnel(float bias, float scale, float power, vec3 I, vec3 N) {\n    return bias + scale * pow(1.0 + dot(I, N), power);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<125; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = scene( pos );\n        res = min( res, k*max(h,0.0)/t );\n        if( res<0.0001 ) break;\n        t += clamp(h,0.01,0.5);\n    }\n\n    return res;\n}\n\nfloat blinnPhongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  //Calculate Blinn-Phong power\n  vec3 H = normalize(viewDirection + lightDirection);\n  return pow(max(0.0, dot(surfaceNormal, H)), shininess);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aspect = iResolution.x / iResolution.y;\n  vec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * vec2(aspect, 1.0);\n\n  Camera c = Camera(\n    // vec3(sin(iTime) * 10.0, cos(iTime) * 10.0, -30.0),\n    vec3(0.0, 0.0, -30.0),\n    vec3(0.0, 0.0, 0.0),\n    0.4\n  );\n\n  Ray r = Ray(\n    c.position,\n    calculateRayDirection(c, uv)\n  );\n\n  Light l = Light(\n    vec3(0.0, 20.0, 20.0)\n  );\n\n  float traveled = march(r);\n  vec3 color = vec3(0.0);\n\n  if (traveled <= 0.0) {\n    // Hit nothing\n    fragColor = vec4(color, 1.0);\n    return;\n  }\n\n  vec3 positionHit = c.position + r.direction * traveled;\n  vec3 normal = calculateNormal(positionHit);\n\n  if (positionHit.z > 5.0) {\n    fragColor = vec4(color, 1.0);\n    return;\n  }\n\n  // Phong\n  vec3 eyeDirection = normalize(c.position - positionHit);\n  vec3 lightDirection = normalize(l.position - positionHit);\n  float power = blinnPhongSpecular(lightDirection, eyeDirection, normal, 1.0);\n\n  color += vec3(0.3) + power;\n\n  // AO\n  float ao = calcAO(positionHit, normal,10.,1.6);\n  color *= ao;\n\n  // Fresnel\n  vec3 I = normalize(positionHit - c.position);\n  float R = fresnel(.0, 2.4, 5.2, I, normal);\n  color *= 1.0 - R;\n\n  // Fog\n  float dd = distance(c.position, positionHit);\n  float start = 20.0;\n  float end = 50.0;\n  float fog = 1.0 - clamp((end - dd) / (end - start), 0.0, 1.0);\n  color = mix(color, vec3(0.0), fog);\n  \n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}