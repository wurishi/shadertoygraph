{"ver":"0.1","info":{"id":"sd3SDj","date":"1633951008","viewed":192,"name":"quadmap simplified","username":"jt","description":"Simplified version of [url]https://www.shadertoy.com/view/7scSzf[/url] replacing adjugate by inverse.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["map","projection","quad","mat3","projective","quadrilateral","quadmap","quad2quad","quadtoquad","mat3x3","3x3matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/sd3SDj\n// Simplified version of https://www.shadertoy.com/view/7scSzf replacing adjugate by inverse.\n// ported from: https://jsfiddle.net/dFrHS/1/\n// https://math.stackexchange.com/questions/296794/finding-the-transform-matrix-from-4-projected-points-with-javascript/\n// original author: MvG\n// shadertoy-port by jt\n\n// keywords: quad, map, quadmap, quad2quad, quadtoquad, quadrilateral, projective, projection, mat3, mat3x3, 3x3matrix\n\n// (added wxMaxima instructions in comments)\nmat3 basisToPoints(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n  // M: matrix([x_0,x_1,x_2], [y_0,y_1,y_2], [1,1,1]);\n  mat3 M =\n    mat3\n    (\n      vec3(p0, 1.0),\n      vec3(p1, 1.0),\n      vec3(p2, 1.0)\n    );\n\n  // m: matrix([x_3], [y_3], [1]);\n  vec3 m = vec3(p3, 1.0);\n  // v : invert(M).m;\n  vec3 v = inverse(M) * m;\n\n  // D: matrix([v[1],0,0], [0,v[2],0], [0,0,v[3]]);\n  mat3 D =\n    mat3\n    (\n      vec3(v.x, 0.0, 0.0),\n      vec3(0.0, v.y, 0.0),\n      vec3(0.0, 0.0, v.z)\n    );\n\n  // M.D;\n  return M * D;\n  // ratsimp(M.D);\n  // factor(M.D);\n}\n\nmat3 general2DProjection(\n  vec2 s0, vec2 d0,\n  vec2 s1, vec2 d1,\n  vec2 s2, vec2 d2,\n  vec2 s3, vec2 d3\n)\n{\n  mat3 S = basisToPoints(s0, s1, s2, s3);\n  // NOTE: 0..1 quad results in\n  // subst([x_0=0, y_0=0, x_1=1, y_1=0, x_2=1, y_2=1, x_3=0, y_3=1],M.D);\n  //mat3 D = mat3(0.0, 0.0, 1.0,-1.0, 0.0,-1.0, 1.0, 1.0, 1.0);\n  mat3 D = basisToPoints(d0, d1, d2, d3);\n  return D * inverse(S);\n}\n\nvec2 project(mat3 m, float x, float y)\n{\n  vec3 v = m * vec3(x,y, 1.0);\n  return v.xy / v.z; // dehomogenize\n}\n\n// Just some code to visualize the quad\n\n#define PI 3.1415926\n#define TAU (2.0 * PI)\n\nfloat checker(vec2 p)\n{\n  return smoothstep(-0.05,+0.05, sin(p.x*TAU)*sin(p.y*TAU));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = iTime / 5.0;\n    vec2 p0 = vec2(0.2, 0.2) + 0.1 * vec2(+cos(t),+sin(t));\n    vec2 p1 = vec2(0.8, 0.2) + 0.15 * vec2(-sin(t),+cos(t));\n    vec2 p2 = vec2(0.2, 0.8) + 0.2 * vec2(-cos(t),-sin(t));\n    vec2 p3 = vec2(0.8, 0.8) + 0.25 * vec2(+sin(t),-cos(t));\n\n    // NOTE: quads must be convex\n    mat3 m = general2DProjection\n    (\n      p0, vec2(0.0, 0.0),\n      p1, vec2(1.0, 0.0),\n      p3, vec2(1.0, 1.0),\n      p2, vec2(0.0, 1.0)\n    );\n\n    vec2 q = project(m, uv.x, uv.y);\n    fragColor = texture(iChannel0, q);\n    //fragColor = vec4(checker(5.0 * q));\n\n    //if(any(lessThan(q, vec2(0.0))) || any(greaterThan(q, vec2(1.0))))\n    //    fragColor = vec4(0.0);\n\n    fragColor *= smoothstep(0.0, 0.01, q.x) * smoothstep(0.0, 0.01, q.y) * smoothstep(1.0, 0.99, q.x) * smoothstep(1.0, 0.99, q.y);\n}\n","name":"Image","description":"","type":"image"}]}