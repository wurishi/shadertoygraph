{"ver":"0.1","info":{"id":"XctSDf","date":"1714546499","viewed":81,"name":"Raycast Procedural Earth","username":"ArchaicVirus","description":"A raycast planet using procedural noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raycast","space","planet","procgen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n\n    return mix(\n        mix(hash(ip.x + ip.y * 57.0), hash(ip.x + 1.0 + ip.y * 57.0), u.x),\n        mix(hash(ip.x + (ip.y + 1.0) * 57.0), hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0), u.x),\n        u.y\n    );\n}\n\nvec3 rotate(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);\n}\n\nfloat layeredNoise(vec3 p) {\n    float n = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float persistence = 0.5;\n    int octaves = 8;\n    for (int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotate(p, 45.0);\n    }\n    return n;\n}\n\nfloat sphere(vec3 ro, vec3 rd, float radius) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvec3 colorBanding(float n) {\n    if (n > 0.95) return vec3(0.0, 0.1, 0.5);\n    else if (n > 0.85) return vec3(0.0, 0.3, 0.7);\n    else if (n > 0.75) return vec3(0.0, 0.5, 0.8);\n    else if (n > 0.65) return vec3(0.0, 0.7, 0.7);\n    else if (n > 0.55) return vec3(0.8, 0.6, 0.4);\n    else if (n > 0.45) return vec3(0.0, 0.6, 0.0);\n    else if (n > 0.35) return vec3(0.5, 0.5, 0.0);\n    else if (n > 0.25) return vec3(0.6, 0.4, 0.2);\n    else if (n > 0.15) return vec3(0.4, 0.3, 0.1);\n    else return vec3(0.8, 0.8, 0.8);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float t = sphere(ro, rd, 1.25);\n    if (t < 0.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        vec3 pos = ro + t * rd;\n        pos = rotate(pos, iTime);\n        vec3 norm = normalize(pos);\n        float noiseValue = layeredNoise(norm * 3.0);\n        vec3 color = colorBanding(noiseValue);\n        fragColor = vec4(color, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}