{"ver":"0.1","info":{"id":"sstSW8","date":"1633077429","viewed":182,"name":"The Penrose packing","username":"DrHow","description":"Obtained as a 2D slice of a 5D hypercubic packing.\nThe Coxeter diagram of the 5D packing is linear 3-4-3-3-3-4.\nThe code took advantage of its hypercubic symmetry hence was much shorter.\nUpdate 1: add animation.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","circlepacking"],"hasliked":0,"parentid":"NddSWn","parentname":"Extended Bi23, generalized"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Disclaimer:\nI know nothing about lighting and coloring (I'm colorblind).\nI copied the visual effect from Zhao Liang (twitter @neozhaoliang).\nAnd I count on the community to make these things nicer.\n*/\n\n//*****************************************************************************\n\nfloat map(vec2 p) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float k = 1.0;\n    if (iMouse.z > 0.0) {\n        p -= mouse;\n        k = dot(p,p);\n        p /= k;\n        p += mouse;\n    }\n    vec3 q = vec3(p.x, p.y, iTime*0.2);\n    const float strong_factor = .5;\n    return DE(q) * strong_factor;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 post_process(vec3 col, vec2 uv) {\n  col = pow(clamp(col, 0., 1.), vec3(1.0/2.2)); \n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *= 0.5 + 0.5*pow(19.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.7);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    init();\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = 2. * uv - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    p *= ZOOM;\n    float aa  = 2.0 / iResolution.y;\n        \n    float d = map(p);    \n    \n    float b = -0.4;\n    float t = 10.0;\n    const float lh = 2.;\n    const vec3 lp = vec3(2.5, 2.5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld = normalize(lp - pp);\n    \n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd = normalize(lp - bp);\n    float bl = L2(lp - bp);\n\n    float st = (0.0-b)/srd.z;\n    vec3  sp = bp + srd*st;\n\n    float bd = map(bp.xy);\n    float sd = map(sp.xy);\n\n    vec3 col = vec3(0);\n    const float ss = 15.0;\n    col       += vec3(1.)  * (1.0 - exp(-ss*(max(sd, 0.0)))) / bl;\n    float l   = length(p);\n    float hue = fract(0.25*l) + .45;\n    float sat = .9*tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    \n    col       *= (1.0-clamp(tanh(0.75*l), 0., .1)) * 1.3;\n\n    col       = mix(col, vec3(1), smoothstep(-aa, aa, -d));\n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    col = post_process(col, uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define inf              -1.\n#define MAX_ITER         50\n#define PI               3.14159265359\n#define L2(x)            dot(x, x)\n#define L2XY(x, y)       dot(x - y, x - y)\n#define ZOOM             5.\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    float[5] n;\n    float r;\n    bool invert;\n};\n\nBall cocluster;\nBall cluster;\n\n// Distance from a point to a ball\nfloat sdistanceToBall(float[5] p, Ball B) {\n    float d2=0.;\n    for (int k = 0; k < 5; k++)\n        d2 += (p[k]-B.n[k]) * (p[k]-B.n[k]);\n    return sqrt(d2) - B.r;\n}\n\nvoid translate(inout float[5] p) {\n    for (int k = 0; k < 5; k++) {\n        p[k] = 2.*fract(p[k]/2.+0.5) - 1.;\n        if (p[k] < 0.)\n            p[k] *= -1.;\n    }\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout float[5] p, Ball B, inout float scale) { \n    float[5] q;\n    for (int i = 0; i < 5; i++)\n        q[i] = p[i]-B.n[i];\n    float d2=0.;\n    for (int i = 0; i < 5; i++)\n        d2 += q[i] * q[i];\n    float k = (B.r * B.r) / d2;\n    if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n        return true;\n    for (int i = 0; i < 5; i++)\n        p[i] = k * q[i] + B.n[i];\n    scale *= k;\n    return false;\n}\n\n \n// return distance to the scene, and get the index of the real ball hitted\nfloat DE(vec3 pp) {\n    float[5] p;\n    for (int k=0; k<5; k++) \n        p[k] = pp.z + pp.x * cos(float(k)*PI/2.5)/sqrt(2.5) + pp.y * sin(float(k)*PI/2.5)/sqrt(2.5);\n    \n    float scale = .1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        translate(p);\n        cond = cond && try_reflect(p, cocluster, scale);       \n        if (cond)\n            break;\n    }\n    \n    translate(p);\n    float d = sdistanceToBall(p, cluster);\n    d=abs(d);\n    return d / scale;\n}\n\nvoid init() {\n    cocluster = Ball(float[5](1.,1.,1.,1.,1.), 2., true);\n    cluster = Ball(float[5](0.,0.,0.,0.,0.), 1., false);\n}\n","name":"Common","description":"","type":"common"}]}