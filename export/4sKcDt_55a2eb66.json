{"ver":"0.1","info":{"id":"4sKcDt","date":"1586717483","viewed":155,"name":"glowing lollipop","username":"nexor","description":"a lollipop","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\n\n\n// linear white point\nconst float W = 1.2;\nconst float T2 = 9.5;\n\nfloat filmic_reinhard_curve (float x) {\n    float q = (T2*T2 + 1.0)*x*x;    \n\treturn q / (q + x + T2*T2);\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) / w;\n}\n\nconst int N = 8;\nvec3 ca(sampler2D t, vec2 UV, vec4 sampl){\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3(0);\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0/float(N);\n\tfor(int i = 0; i < N; ++i){\n\t\tc.r += f*texture(t, 0.5-0.5*(uv*rf) ).r;\n\t\tc.g += f*texture(t, 0.5-0.5*(uv*gf) ).g;\n\t\tc.b += f*texture(t, 0.5-0.5*(uv*bf) ).b;\n\t\trf *= 0.9972;\n\t\tgf *= 0.998;\n        bf /= 0.9988;\n\t\tc = clamp(c,0.0, 1.0);\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.+2.*uv;\n    p.y *= iResolution.y/iResolution.x;\n    vec4 sampl = texture(iChannel0, uv);\n    vec3 col = ca(iChannel0, uv, sampl).rgb;\n    col = texture(iChannel0,uv).rgb;\n    float noise = .012*vec3(hash(length(p)*iTime)).x;\n    float vignette = 1.25 / (1.1 + 1.1*dot(p, p));\n    vignette *= vignette;\n    vignette = mix(1.0, smoothstep(0.1, 1.1, vignette), 0.25);\n    col = col*vignette+noise;\n    col = filmic_reinhard(col);\n    col = smoothstep(-0.025, 1.0,col);\n    col = pow(col, vec3(0.9));\n\tfragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.141569\n#define pi_2 (pi*.5)\n#define pi_4 (pi*.25)\n#define pi2 (pi*2.)\n\n#define X vec3(1.,.0,.0)\n#define Y vec3(.0,1.,.0)\n#define Z vec3(.0,.0,1.)\n#define up Y\n\n\n#define saw(x) (4.*abs(fract((x))-.5)-1.)\n#define saw1(x) (2.*abs(fract((x))-.5))\n#define sin1(x) (sin((x))*.5+.5)\n#define cos1(x) (cos((x))*.5+.5)\n\nvec2 opU(vec2 a, vec2 b)\n{\n  return vec2(min(a.x,b.x),\n    mix(a.y,b.y,1.-step(a.x,b.x)));\n}\n\nvec2 opS(vec2 a, vec2 b)\n{\n  return vec2(max(a.x,1.-b.x),\n    mix(a.y,b.y,step(a.x,b.x)));\n}\n\nvec2 opI(vec2 a, vec2 b)\n{\n  return vec2(max(a.x,b.x),\n    mix(a.y,b.y,step(a.x,b.x)));\n}\n\nfloat pow50(float x)\n{\n\tfloat x5 = x*x*x*x*x;\n    float x25=x5*x5*x5*x5*x5;\n    return x25*x25;\n}\n\nvec2 rep(vec2 p,float n)\n{\n  float a=atan(p.y,p.x);\n  a=mod(a,pi2/n)-pi/n;\n  return length(p)*vec2(cos(a),sin(a));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n  vec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, k.wz), vec4(c.gb, k.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n  return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n}\n\nmat2 rot2(float a)\n{\n  float c=cos(a),s=sin(a);\n  return mat2(c,-s,s,c);\n}\n\nmat3 rot(float a,float x,float y,float z)\n{\n  float s=sin(a),c=cos(a);\n  return mat3(\n    x+c*y+c*z,s*z,s*y,\n    -s*z,y+c*x+c*z,s*x,\n    -s*y,-s*x,z+c*x+c*y);\n}\n\nmat3 rotX(float a)\n{\n  float s=sin(a),c=cos(a);\n  return mat3(\n    1.,0.,0.,\n    0.,c,s,\n    0.,-s,c);\n}\n\nmat3 rotY(float a)\n{\n  float s=sin(a),c=cos(a);\n  return mat3(\n    c,0.,s,\n    0.,1.,0.,\n    -s,0.,c);\n}\n\nmat3 rotZ(float a)\n{\n  float s=sin(a),c=cos(a);\n  return mat3(\n    c,s,0.,\n    -s,c,0.,\n    0.,0.,1.);\n}\n\nfloat lengthN(vec3 p,float n)\n{\n  p=pow(p,vec3(n));\n  return pow(p.x+p.y+p.z,1./n);\n}\n\nfloat lengthN(vec2 p,float n)\n{\n  p=pow(p,vec2(n));\n  return pow(p.x+p.y,1./n);\n}\n\nfloat plane(vec3 p,vec3 n,float d)\n{\n  return dot(p,n)+d;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,.0));\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat torus88(vec3 p,vec2 t)\n{\n  vec2 q=vec2(lengthN(p.xz,8.)-t.x,p.y);\n  return lengthN(q,8.)-t.y;\n}\n\nfloat torus28(vec3 p,vec2 t)\n{\n  vec2 q=vec2(lengthN(p.xz,2.)-t.x,p.y);\n  return lengthN(q,8.)-t.y;\n}\n\nfloat sphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\nfloat cone( vec3 p, vec2 c )\n{\n    return dot(normalize(c),vec2(length(p.xy),p.z));\n}\n\nfloat cappedcyl( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr)\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr),cos(cr),.0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  return mat3(cu,cv,cw);\n}\n\nvec2 pol(float a, float r)\n{\n\treturn vec2(cos(a),sin(a))*r;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n\n#define resolution iResolution\n#define time iTime\n#define backbuffer iChannel0\n\n\n\nvec2 map(vec3 p)\n{\n  vec3 q=p,r=p;\n  vec2 res=vec2(-1.);\n  float k=length(q.xz);\n  float a=atan(q.x,q.z);\n  //q.y-=(sin((a*1.+k*3.)))*.2;\n  res=vec2(plane(q,up,2.5),2./8.);\n  //r*=rot(pi*.25,.5,1.,.5)*.35;\n  float d=1e30;\n  r.y-=5.;\n  r*=rotZ(pi/7.)\n  *rotY(-pi/3.);\n  d=sphere(r,1.);\n  d=min(d,torus28(r,vec2(1.,.125)));\n  p.y-=3.;\n  d=min(d,sphere(p,.25));\n  p.y-=pow(1.-length(p.xz),12.);\n  d=min(d,sphere(p,.25));\n  q.y-=-2.5;\n  res=opU(res,vec2(d,35./80.));\n\n  d=capsule(r,vec3(.0),vec3(.0,-5.,.0),.1);\n  res=opU(res,vec2(d,4./8.));\n  return res;\n}\n\nvec3 norm(vec3 p)\n{\n  vec2 e=vec2(1.,-1.)*.5773*.000125;\n  return normalize(\n    e.xyy*map(p+e.xyy).x+\n    e.yxy*map(p+e.yxy).x+\n    e.yyx*map(p+e.yyx).x+\n    e.xxx*map(p+e.xxx).x);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n  rd=normalize(rd);\n  float res = 1.0;\n  for( float t=mint; t < maxt; )\n  {\n    float h = map(ro + rd*t).x;\n    if( h<0.0005 ) return 0.0;\n    res = min( res, k*h/t );\n    t += h*.005;\n  }\n  return res;\n}\n\nvec3 material(vec3 ro, float t, float tmin, float tmax, vec3 rd,vec3 lig,float m)\n{\n    vec3 p=ro+t*rd;\n    vec3 nor=norm(p);\n    \n    vec3 R = 2.0 * dot(lig, nor) * nor - lig;\n    vec3 V = -rd;\n\n    float amb=clamp(.7,.0,1.);\n    float dif=clamp(dot(nor,lig),.0,1.);\n    float spe=pow(max(dot(R, V), 0.0),50.);\n    \n    float sha = 1.;\n      sha=softshadow(p,1.-lig,tmin,tmax,2.);\n    \n\tvec3 lin=\n          +1.*spe*vec3(1.)\n          +.9*dif*vec3(1.,.8,.55)\n          +.2*hsv2rgb(vec3(m*pi2,1.,1.));\n    lin *= sha;\n\tlin+=        \n          +.1*amb*vec3(.4,.6,1.);\n   return clamp(lin,vec3(.0),vec3(1.));\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n  vec3 col=vec3(.0);\n\n  float tmin=.0;\n  float tmax=80.;\n\n  float t=tmin;\n  float m=-1.;\n  float i=.0;\n  for(;i<1800.;i++)\n  {\n    float precis=.000125*t;\n    vec2 res=map(ro+t*rd);\n    if(res.x<precis||t>tmax)break;\n    t+=res.x*.025;\n    m=res.y;\n  }\n  if(t<tmax)\n  {\n    vec3 p=ro+t*rd;\n    vec3 nor=norm(p);\n    vec3 lig=vec3(5.,12.,3.);\n    lig+=p;\n    lig=normalize(lig);\n      \n    col+=material(ro,t,tmin,tmax,rd,vec3(1.,0.,0.),m);\n    if(m>1./8.)\n    \tcol+=vec3(i/1e3)*.8;\n   }\n    col=mix(vec3(.0),col,\n      exp(-t*t*.0015));\n\n  return col;\n}\n\nvec3 render( vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy/resolution.xy;\n  vec3 col = vec3(.0);\n  vec2 p=(-resolution.xy+2.*fragCoord.xy)/resolution.y;\n\n  vec3 ro =vec3(.0,10.,10.);\n  //ro.xz*=rot2(pi*2.*(-.25));\n  vec3 to = vec3(.0,3.,.0);\n  mat3 ca = camera(ro,to,.0);\n  vec3 rd = ca*normalize(vec3(p,2.5));\n  col=render(ro,rd);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fc, in vec2 fragCoord )\n{\n\n  if(iFrame<20)\n    fc=vec4(render(fragCoord),1.);\n  else\n  \tdiscard;//fc=texture(backbuffer,fragCoord.xy/resolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// FXAA implementation by mudlord (I think?)\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1.0 / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          0.03125, 0.0078125);\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"}]}