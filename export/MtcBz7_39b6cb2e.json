{"ver":"0.1","info":{"id":"MtcBz7","date":"1539040774","viewed":218,"name":"Stranger mandelbrot","username":"avataren","description":"Multiple scene mandelbrot shader, using minimum iteration count with early exit for antialiasing.","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["fractal","mandelbrot","reactive","zoom","antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XtXGRr","filepath":"https://soundcloud.com/user-365177788/stranger-things-main-theme","previewfilepath":"https://soundcloud.com/user-365177788/stranger-things-main-theme","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Smooth\n#define MaxIter 1024.\n#define aa 2. //antialiasing steps\n#define aa_delta 1./aa\n#define AspectRatio iResolution.x/iResolution.y\n//#define StillImage\n\n//optimization to skip major parts of the set if zoomed out\nbool opt1(vec2 c)\n{\n    float a=(c.x-0.25);\n    float y2 = c.y*c.y;\n    float p=sqrt(a*a+y2);\n    float b = c.x+1.;\n    return (c.x < (p-2.*p*p+0.25)) || b*b+y2 < (1./16.);\n}\n//pretty standard mandelbrot iteration, with early exit for antialiasing\nfloat Mandelbrot(vec2 c, float minIter)\n{\n    if (opt1(c)) return MaxIter; //try for early exit\n    vec2 z = c;\n    float i;\n    for (i=0.;i<MaxIter;i++){\n        if( dot(z,z)>(4.) ) break; //escapes to infinity\n        if (minIter < i) {\n            i=MaxIter; //early antialiasing exit\n            break;\n        }\n        z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y) + c; //iterate mandelbrot formula\n    }\n\n    #ifdef Smooth\n   \tfloat sl = i - log2(log2(dot(z,z))) + 4.0; //IQs smoothing formula\n    return sl; //this gives some banding with current aa method, but looks kinda cool too\n    #else\n    return i;\n    #endif\n}\n//2d rotation\nvec2 rotate (vec2 v,float r)\n{\n    float s = sin(r);\n    float c = cos(r);\n    mat2 rot = mat2(c,-s,s,c);\n    return v*rot;\n}\n//list of interesting locations to zoom in to\nvec2 getLocation(int idx)\n{\n    vec2 locations[7]= vec2[](\n    vec2 ( -1.25066,0.02012),\n    vec2 ( -0.0452407411, 0.9868162204352258),\n    vec2 ( 0.452721018749286, 0.39649427698014),\n    vec2 ( -1.7590170270659, 0.01916067191295),\n    vec2 ( -0.235125, 0.827215),\n    vec2 ( 0.2549870375144766, -0.0005679790528465),\n    vec2 ( 0.2929859127507, 0.6117848324958));\n    return locations[idx];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat fft = texelFetch(iChannel0,ivec2(1,0),0).x;\n    \n    vec3 col = vec3(0);\n    float t = iTime*0.1;\n    \n    #ifdef StillImage\n    t=200.;\n    #endif\n    //iterate between various locations over time\n    int lidx=int(mod(floor(t*.3),7.));\n    vec2 location=getLocation(lidx);\n    vec2 colUV;\n    //minIter is used to find the lowest iteration sample when antialiasing\n    float minIter = MaxIter;\n    float mandelColor = 0.;\n     //fudge some zoom factor together\n    float zoom = pow(((sin(t)*0.5+0.5)*.25+.001),1.8);\n    //antialiasing loop\n    for (float y=0.;y<aa;y++)\n        for (float x=0.;x<aa;x++)\n        {\n\t\t    // Normalized pixel coordinates (from -2 to 2)\n            vec2 uv = fragCoord/(iResolution.xy+vec2(x,y)*aa_delta)*4.-2.;\n            uv.x*=AspectRatio;\n            uv=rotate(uv,t)*zoom+location;    \n            float sampleIter = Mandelbrot(uv, minIter);//fetch mandelbrot sample\n            \n            if (sampleIter < minIter)\n            {\n                //store the minimum value found in antialiasing steps\n                //this gives cleaner image then supersampling and averaging\n                minIter = sampleIter; //update the new minimum iteration count found\n                colUV = uv; //store the captured \"uv\" coordinate used in calculation for color calculation later\n            }\n        }\n    \n    if (minIter < MaxIter) //prevent flickering inside set\n\t\tmandelColor = minIter/MaxIter;\n    //simple music reaction\n    //mandelColor*=(0.5+fft);\n    //pick some nice colors\t\n \tcol = (0.5 + 0.5*cos(mandelColor*64.+colUV.xyy+vec3(.1,.2,.3)))*pow(mandelColor,0.05);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}