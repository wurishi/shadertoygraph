{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n * This study includes\n *\n * 1) findUV: a function that finds two orthogonal vectors, given a \n * normal vector. The normal vector has to be given in spherical\n * coordinates, (theta, phi). findUV calculates an orthonormal\n * local coordinate system (n, u, v). This can be used in texture\n * mapping a plane, or orienting the camera.\n *\n * 2) iPlane2: Ray-plane intersection method. Its parameters are (besides\n * the ray parameters) the normal and the distance from the origin\n * of the plane.\n *\n * 3) checkerBoard3: An anti-aliased checker board pattern generator,\n * it does not need that (u,v) to be in [0,1]. they can go to infinity,\n * the pattern will repeat inifinitely.\n * It does work for closeby checker cells, but distant ones still\n * produce Moire patterns.\n *\n * 4) iBox: A box-ray intersection function. It is different than\n * the \"axis-aligned box\" method. It first defines 3 arbitrary normals.\n * (if these planes are orthogonal to each other, than we'll get a\n * rectangular box) For each normal, it defines two parallel planes on which\n * the sides of the box will lie.\n * The Kay-Kasia algorithm is applied to 3 slabs and the intersection\n * position and normal at the intersection are returned.\n *\n * 5) intersect: deals with whether we hit nothing, the ground plane or\n * the cube.\n *\n * 6) A camera implementation. the camera direction is given in spherical\n * coordinates. and u and v vectors on the camera plane are found\n * via findUV. Then, rays are sent with the formula:\n * normalize(sX * cU + sY * cV + FOV*cDir);\n * sX, sY: screen coordinates, cU,cV: camera UV. cDir: given direction.\n * The FOV parameter came for free. :-)\n * \n */\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 light = normalize( vec3(0.57703) );\nvec4 plane;\nvec4 sph1;\n\n\n// given spherical coordinates (theta, phi) of a normal vector (OR longitude and latitude)\n// find the normal vector, and two vectors that are perpendicular to it (and each other)\n// that lie on the plane defined by the normal vector\nvoid findUV(in float th, in float ph, out vec3 dir, out vec3 u, out vec3 v) {\n\tdir = vec3(sin(th)*cos(ph), cos(th), sin(th)*sin(ph));\n\t// Second direction, V of the plane, is PI/2 upwards towards the north pole\n\tfloat thV, phV;\n\tif(th < 0.5*PI) {\n\t\tthV = 0.5*PI - th;\n\t\tphV = mod(ph + PI, TWO_PI);\n\t} else {\n\t\tthV = th - 0.5*PI;\n\t\tphV = ph;\n\t}\n\tv = vec3(sin(thV)*cos(phV), cos(thV), sin(thV)*sin(phV));\n\t// Third direction, U of plane, is perpendicular to both\n\tu = cross(dir, v);\n}\n\n// the bad example from IQ's article, Haha!\n// https://iquilezles.org/articles/noacos\nmat3 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat3( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c );\n}\n\n// assumes (u,v) in [0,1]. Divides the ares into nTile x nTile squares.\nvec3 checkerBoard(vec2 uv, float nTile) {\n\tvec3 color1 = vec3(1.0, 1.0, 1.0);\n\tvec3 color2 = vec3(0.0, 0.0, 0.0);\n\tfloat side = 1.0/nTile;\n\tfloat c1 = mod(uv.x, 2.0 * side);\n\tc1 = step(side, c1);\n\tfloat c2 = mod(uv.y, 2.0 * side);\n\tc2 = step(side, c2);\t\n\tvec3 color = mix(color1, color2, mod(c1+c2,2.0));\n\treturn color;\n}\n\n\n// infinite area, tiles of size \"side\"\nfloat stripe(float x, float side, float smth) {\n\tx = mod(x, 2.0*side);\n\treturn smoothstep(0.0 - smth, 0.0 + smth, -x)\n         + smoothstep(1.0*side - smth, 1.0*side + smth, x)\n         - smoothstep(2.0*side - smth, 2.0*side + smth, x);\n}\nfloat checkerBoard3(vec2 uv, float side, float smth) {\n\t//smooth *= length(1.0*uv);\n\tfloat xStripes = stripe(uv.x, side, smth);\n\tfloat yStripes = stripe(uv.y, side, smth);\n\tfloat checker = abs(xStripes+yStripes-1.0);\n\treturn checker;\n}\n\n\nfloat iPlane2(vec3 o, vec3 d, vec4 plane) { // ray Origin, ray Direction\n\tvec3 n = plane.xyz;\n\tfloat dist = -plane.w;\n\tfloat denom = dot(n, d);\n\n\treturn - (dot(n, o)+dist)/denom;\n}\nvec3 nPlane2(vec3 pos) {\n\treturn plane.xyz;\n}\n\nvoid swap(inout float x, inout float y) {\n\tif(x>y) {\n\t\tfloat temp = x;\n\t\tx = y;\n\t\ty = temp;\n\t}\t\t\n}\n\nfloat iBox(vec3 o, vec3 d, vec3 center, vec3 sides, out vec3 normal) {\n\tvec3 axis = normalize(vec3(1.0, 1.0, 0.0));\n\tmat3 rot = rotationAxisAngle(axis, PI/2.);\n\tvec3 xn = rot*vec3(1.0, 0.0, 0.0);\n\tvec3 yn = rot*vec3(0.0, 1.0, 0.0);\n\tvec3 zn = rot*vec3(0.0, 0.0, 1.0);\n\taxis = normalize(vec3(0.0, 1.0, 0.0));\n\trot = rotationAxisAngle(axis, iTime);\n\txn = rot*xn;\n\tyn = rot*yn;\n\tzn = rot*zn;\t\n\tfloat t1, t2;\n\tfloat tNear = -10000.0;\n\tfloat tFar = 10000.0;\n\t\n\to = o - center; // translation\n\t\n\t// x -> yz-plane\n\tt1 = iPlane2(o, d, vec4(xn, -0.5*sides.x));\n\tt2 = iPlane2(o, d, vec4(xn, 0.5*sides.x));\n\tif(t1>t2) swap(t1, t2);\n\tif(t1 > tNear) { normal = xn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar || tFar < 0.0) return -1.0;\n\t\n\t// y -> xz-plane\n\tt1 = iPlane2(o, d, vec4(yn, -0.5*sides.y));\n\tt2 = iPlane2(o, d, vec4(yn, 0.5*sides.y));\t\n\tif(t1>t2) swap(t1, t2);\n\tif(t1 > tNear) { normal = yn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar || tFar < 0.0) return -1.0;\n\t\n\t// z -> xy-plane\n\tt1 = iPlane2(o, d, vec4(zn, -0.5*sides.z));\n\tt2 = iPlane2(o, d, vec4(zn, 0.5*sides.z));\t\n\tif(t1>t2) swap(t1, t2);\n\tif(t1 > tNear) { normal = zn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar || tFar < 0.0) return -1.0;\n\t\n\treturn tNear;\n}\n\nint intersect( in vec3 ro, in vec3 rd, out float resT, out vec3 normal ){\n\tresT = 1000.0;\n\tint id = -1;\n\tsph1 = vec4(0.0, -1.5, 00.0, 2.0);\n\tfloat tpla2 = iPlane2(ro, rd, plane);\n\t\n\tvec3 boxCenter = vec3(0.0, 4.0, 0.0);\n\tvec3 boxSides = vec3(2.0, 2.0+0.2*sin(iTime*20.), 2.0)*2.0;\n\tfloat tCube = iBox(ro, rd, boxCenter, boxSides, normal);\n\tif( tpla2 > 0.0 && tpla2 < resT ) {\n\t\tid = 3;\n\t\tresT = tpla2;\n\t}\n\tif( tCube > 0.0 && tCube < resT ) {\n\t\tid = 4;\n\t\tresT = tCube;\n\t}\n\t\n\t//float t = min(tsph, tpla);\n\treturn id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.yx;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Camera (My own attempt of preparing a camera. Use at your own risk!)\n\tvec3 ro = vec3( 0.0, 4.0, 10.0); // origin\n\tfloat cTheta = 0.55*PI; // polar theta of direction\n\tfloat cPhi = 0.2*PI*sin(iTime)-0.5*PI; // polar phi of direaction\n\tfloat cAlpha = 0.1*PI*cos(iTime); // tilt\n\tfloat FOV = 1.5; // smaller number wider view and vice versa.\n\t// direct the camera at given latitude and longitude\n\tvec3 cDir, cU, cV;\n\tfindUV(cTheta, cPhi, cDir, cU, cV);\t\n\t// Tilt the camera\n\tmat3 tilt = rotationAxisAngle(cDir, cAlpha);\n\tcU = tilt*cU; // just rotate camera U and V. Yay, tt works!\n\tcV = tilt*cV;\t\n\tvec2 scan = (-1.0+2.0*uv)*vec2(1.78, 1.0); // magical numbers\n\tvec3 rd = normalize(scan.x * cU + scan.y * cV + FOV*cDir);\n\t//vec3 rd = normalize(vec3( (-1.0+2.0*uv)*vec2(1.78, 1.0), -1.0));\t\n\t\n\t// ground\n\tfloat pTheta = 0.0*PI;\n\tfloat pPhi = 0.3*PI;\n\tvec3 pNorm, pU, pV;\n\tfindUV(pTheta, pPhi, pNorm, pU, pV);\n\tplane = vec4(pNorm, 0.0);\n\t\n\t// send rays to detect intersections with objects\n\tfloat t;\n\tvec3 normal;\n\t// intersect will return the object type \"id\"\n\t// and set the ray parameter \"t\" and normal at the intersection point\n\tint id = intersect(ro, rd, t, normal);\n\n\tvec3 bgCol = vec3(244., 198., 61.)/255.;\n\tvec3 col = bgCol;\n\t// hit id\n\tvec3 pos = ro + t*rd;\n\tif(id == 3) { // hit the floor\n\t\tvec3 nor = nPlane2( pos );\t\t\n\t\tfloat dif = clamp( dot(nor, light), 0.0, 1.0);\n\t\tfloat amb = 0.2;\n\t\t// find uv on the plane at the intersection\n\t\tvec3 projection = pos - dot(pos,nor)*nor;\n\t\tfloat u = dot(projection, pU);\n\t\tfloat v = dot(projection, pV);\n\t\tfloat side = 2.0;\n\t\t//vec3 texture = checkerBoard2( vec2(u, v), side );\n\t\tvec3 color1 = vec3(4., 105., 103.)/255.;\n\t\tvec3 color2 = vec3(234., 229., 206.)/255.;\n\t\tvec3 aveColor = mix(color1, color2, 0.5);\n\t\tfloat mixVal = checkerBoard3( vec2(u, v), side, 0.02*side );\n\t\tvec3 texture = mix(color1, color2, mixVal);\n\t\tfloat distVal = clamp(exp(-0.0005*t*t),0.0,0.99);\n\t\tvec3 fadedToAverage = mix(aveColor, texture, distVal*distVal);\n\t\t//vec3 texture = vec3( checkerBoard3( vec2(u, v), side, 0.5*side ) );\n\t\t//col = mix(texture*dif,bgCol, 0.001*t); // fade to background color\n\t\t//col = texture*dif;\n\t\tcol = fadedToAverage*dif;\n\t} else if(id == 4) { // hit the box\n\t\tfloat dif = clamp( abs(dot(normal, light)), 0.0, 1.0);\n\t\tvec3 boxColor = vec3(215., 2., 6.)/255.;\n\t\tcol = boxColor*dif;\n\t}\n\tcol = sqrt(col*1.5);\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sj3WK","date":"1393633372","viewed":3434,"name":"Study 9: Box-Ray Intersection","username":"vug","description":"A visually unpleasant study of box-ray intersection using analytical geometric methods, instead of ray marching (which I didn't learn yet). ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracer"],"hasliked":0,"parentid":"","parentname":""}}