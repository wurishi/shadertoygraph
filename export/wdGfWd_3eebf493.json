{"ver":"0.1","info":{"id":"wdGfWd","date":"1608305839","viewed":165,"name":"Path Tracing Testing 54","username":"Pjbomb2","description":"Mouse and WASD for controls\nUncomment the #define scene1 to get alternative scene\nOrigional watch SDF by Reinder\nWhat I should do next/how to make this better/more optimized\nComment out def.sun and switch Buffer B iChannel0 to Basilica cubemap for IBL(?)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["lighting","pathtrace","pathtracing","spheretrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Reference watch SDF made by Reinder https://www.shadertoy.com/view/lscBW4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = texture( iChannel0, uv ).xyz;\n    col *= 2.; // exposure\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    //col = pow( col, vec3(0.8,0.85,0.9) );\n    col = ACESFilm(col); // convert unbounded HDR color range to SDR color range\n    col = LinearToSRGB(col); // convert from linear to sRGB for display\n    col = smoothstep(0., 1., col); // increase contrast\n    \n    \n    fragColor = vec4( col, 1 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Change BOUNCECOUNT to change the number of light bounces\n\n\n//#define debug 1\n//debug 1 = normals, debug 2 = materials(no lighting)\n\n\n#define BOUNCECOUNT 7\n//comment out ceilinglights for outside sun\n\n\n#define textures\n\n#define sun\n#define scene1\n//4.8ms\n\n\n#define MATTILE 0.0\n#define MATGROUT 1.0\n#define MATWALL 2.0\n#define MATLIGHT 3.0\n#define MATWOOD 4.0\n#define MATGREY 5.0\n#define MATWHITE 6.0\n#define MATMETAL 7.0\n#define MATDEBUG 8.0\n#define MATGLASS 9.0\n#define MATCEILLIGHT 10.0\n#define MATBLOOD 11.0\n#define MATBRONZE 12.0\n#define MATWOODLIGHT 13.0\n#define MATSILVER 14.0\n#define MATWHITE2 15.0\n\n//Color correction from Demofox\nvec3 LessThan(vec3 f, float value)\n{\n    //Reccomended change by Dave_Hoskins\n    return vec3(lessThan(f, vec3(value)));\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return 2. * fract( p.x*p.y*p.z*(p.x+p.y+p.z) ) - 1.;\n}\n\nfloat noise(const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat fbm(const in vec3 p, const in int octaves) {\n    float accum = 0.;\n    vec3 temp_p = p;\n    float weight = 1.;\n     \n    for (int i=0; i<octaves; i++) {\n        accum += weight * noise(temp_p);\n        weight *= .5;\n        temp_p *= 2.;\n    }\n    return abs(accum);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = n*n;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x+m.y+m.z);\n}\n\n\n//SDF functions\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\n\n\n\nfloat SDFSphere(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat SDFBox(vec3 point, vec3 size)\n{\n    vec3 d = abs(point) - size;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec2 Union(in vec2 a, in vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t//return min(a,b);\n\t\n\t\n    //float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfloat fresnel(in vec3 I, in vec3 N, float eps) \n{ \n    float cosi = clamp( dot(I, N), -1.0, 1.0); \n    \n    float etai = 1.0;\n    float etat = eps; \n    float tmp;\n    if (cosi > 0.0) { tmp = etai; etai = etat; etat = etai; /*swap(etai, etat);*/ } \n    \n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi)); \n    // Total internal reflection\n    if (sint >= 1.0) { \n        return 1.0;\n    } \n    else { \n        float cost = sqrt(max(0.0, 1.0 - sint * sint)); \n        cosi = abs(cosi); \n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n        return  (Rs * Rs + Rp * Rp) / 2.0; \n    } \n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n} \n\n\n//materials\nvec3 GetMatProps(in float matID, out float refl, out float refr, out float emmis, out float IOR) {//return material properties when what material is being hit is requested\n    \n    if(matID == MATTILE) {\n     \trefl = 0.1;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.933,0.749,0.627);\n    }\n        if(matID == MATGROUT) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.8, 0.7, 0.5);\n    }\n\t    if(matID == MATWALL) {\n     \trefl = 0.1;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.8, 0.75, 0.6);\n    }\n    \t    if(matID == MATLIGHT) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 4.0;\n        IOR = 1.0;\n        return vec3(0.8, 0.8, 0.8);\n    }\n        \t    if(matID == MATWOOD) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.8, 0.6, 0.3);\n    }\n            \t    if(matID == MATGREY) {\n     \trefl = 0.4;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.2, 0.2, 0.2);\n    }\n                \t    if(matID == MATWHITE) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.9, 0.9, 0.9);\n    }\n                    \t    if(matID == MATMETAL) {\n     \trefl = 0.8;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.7, 0.7, 0.7);\n    }\n                        \t    if(matID == MATDEBUG) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.9, 0.0, 0.9);\n    }\n                            \t    if(matID == MATGLASS) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        IOR = 1.5;\n        return vec3(1.0, 1.0, 1.0);\n    }\n        \t    if(matID == MATCEILLIGHT) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 1.0;\n        IOR = 1.0;\n        return vec3(0.8, 0.8, 0.8);\n    }\n            \t    if(matID == MATBLOOD) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        IOR = 1.3;\n        return vec3(0.14, 0.92, 0.76);\n    }\n                        \t    if(matID == MATBRONZE) {\n     \trefl = 0.6;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(1.000, 0.766, 0.336);//return vec3(0.690,0.690,0.690);\n    }\n                            \t    if(matID == MATWOODLIGHT) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.671,0.459,0.090);\n    }\n                            \t    if(matID == MATSILVER) {\n     \trefl = 0.6;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.690,0.690,0.690);\n    }\n                    \t    if(matID == MATWHITE2) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.9, 0.9, 0.9);\n    }\n    \n    \n    \n    \nreturn vec3(1.0, 0.0, 1.0);\n}\n\n\n\n\nfloat sdTorusYX( const vec3 p, const vec2 t ) {\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderZY( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.zy),p.x)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( const vec3 p, const vec3 r ) {\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdSegment2D( const vec2 p, const vec2 a, const vec2 b, const float w ) {\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - w;\n}\n\nvec3 rotateX( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\nvec3 rotateY( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\nvec3 rotateZ( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nvec2 rotate( in vec2 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p = mat2(co,-si,si,co) * p;\n    return p;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy * 10.0;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 0.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 0.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n\n    \n    position += (0.1 * target - position);\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Camera and Keyboard input by glk7, from https://www.shadertoy.com/view/4lVXRm\n\n//2.5ms\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nconst ivec2 VMOUSE = ivec2(1, 1);\n\nconst float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\n\n//vec3 SunPos = vec3(100, 100, 50);\n//vec3 SunPos = vec3(0, 100, 0);\n#ifdef scene1\nvec3 SunPos = vec3(0, 100, -100);\n#else\nvec3 SunPos = vec3(100, 100, 0);\n#endif\nvec3 sunCol = 2.0*vec3(0.8, 0.7, 0.6);\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state, in vec3 nor)\n{\n    float u = RandomFloat01(state);\n    float v = RandomFloat01(state) * c_twopi;\n   \n    \t// method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    \tfloat ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n        float ka = 1.0 / (1.0 + abs(nor.z));\n        float kb = -ks * nor.x * nor.y * ka;\n        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    \n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n\nvec2 MapBoxes(vec3 rayPoint)\n{\n    \n   \n        float b = SDFBox(rayPoint - vec3(0,0.2,0), vec3(15, 1.1, 32));\n        \n        \n        \n    //floor\n    vec2 scene = vec2(b,MATTILE);//Union(vec2(a,MATTILE), vec2(SmoothMin(b, c, 0.75),MATGROUT));\n return scene;\n}\n\n\n\n\n\n\nvec2 MapMetal(vec3 rayPoint) {\n\nfloat t1 = sdTorus(rayPoint - vec3(0,2.2,0), vec2(3.0,0.22));\nfloat t2 = sdTorus(rayPoint - vec3(0,2.2,0), vec2(3.25,0.04));\n\nfloat t3 = sdCylinder(rayPoint-vec3(0,1.9,0), vec2(3.05, 0.4));\n\nfloat t4 = sdTorus(rayPoint - vec3(0,1.6,0), vec2(3.0,0.22));\nfloat t5 = sdTorus(rayPoint - vec3(0,1.6,0), vec2(3.25,0.04));\n\nfloat t6 = sdTorus(rayPoint - vec3(0,2.4,0), vec2(3.0,0.07));\n\nfloat t7 = sdCylinder(rayPoint-vec3(0,1.9,0), vec2(3.219, 0.27));\n\nfloat t8 = sdCylinder(rayPoint-vec3(0,2,0), vec2(3, 0.4));\n\nfloat t9 = sdCappedCone(rayPoint - vec3(0,1.9,3), vec3(0, 0, 0), vec3(0, 0, 1.0), 0.5, 0.3);\n\nfloat t10 = sdCylinderXY(rayPoint - vec3(0,1.9,4.3), vec2(0.5,0.3));\nfloat t12 = sdCylinderZY(rayPoint - vec3(0,1.9,3.7), vec2(0.18,0.5));\nrayPoint = rotateX(rayPoint, -1.4);\nrayPoint = rotateZ(rayPoint, -1.5);\nfloat t11 = sdLink(rayPoint - vec3(4.05,-0.3,2.5), 0.5, 0.7, 0.15);\n\nvec2 ret = vec2(min(SmoothMin(SmoothMin(max(SmoothMin(min(min(min(max(t1,-t2),max(t4,-t5)),t3),t6),t7, 0.01),-t8),t9, 0.1),t12,0.1),t10), MATBRONZE);//vec2(SmoothMin(a,b, 0.1), MATDEBUG);\nret = Union(ret, vec2(t11, MATSILVER));\n\nreturn ret;\n}\n\nfloat MapGlass( in vec3 pos ) {\n    return max(sdEllipsoid( pos - vec3(0,2.38,0), vec3(2.95,.3,2.95) ),-sdEllipsoid( pos - vec3(0,2.36,0), vec3(2.95,.3,2.95) ));\n}\n\nfloat MapHand(in vec3 pos, float w, float l, float r) {\n    float d = sdSegment2D(pos.xz, vec2(0,-w*10.), vec2(0,l), w);\n    d = min(d, length(pos.xz) - (.03+r));\n    return max(d, abs(pos.y)-.005);\n\n}\n#ifdef scene1\nvec2 MapTree(vec3 rayPoint) {\nvec3 pos = rayPoint;\nfloat ofst = texcube(iChannel0, pos * 0.5, vec3(1.0)).g * 0.1 + texcube(iChannel0, pos * 0.1, vec3(1.0, 0.0, 1.0)).r * 0.3 + texcube(iChannel0, pos * 0.01, vec3(1.0)).b * 0.6;// + sin(fbm(pos*0.1, 5));\nfloat t = sdCylinder(rayPoint, vec2(13.0+ofst, 200.0));\nfloat t2 = sdCylinderXY(rayPoint - vec3(0,2,-12), vec2(3.4, 5));\nfloat t3 = sdTorusYX(rayPoint - vec3(0,2,-12.5), vec2(3.0 + ofst, 0.7));\nvec2 ret = vec2(SmoothMin(max(t, -t2), t3, 0.1), MATWOODLIGHT);\nreturn ret;\n}\n#endif\n\n\nvec2 map(vec3 rayPoint, in float inside)\n{\n    #ifdef scene1\n    rayPoint += vec3(0.0, 3.0, -15.0);\n    vec2 tree = MapTree(rayPoint - vec3(0,0,1));\n    \n        rayPoint = rotateX(rayPoint, -0.7);\n    \n\n \n     rayPoint += vec3(0.0, -5.0, 6.0);\n    vec2 metal = MapMetal(rayPoint);\n    vec2 ret = metal;\n    #else\n    rayPoint += vec3(0.0, 3.0, -2.0);\n        vec2 boxes = MapBoxes(rayPoint);\n\n    vec2 ret = boxes;\n    \n        vec2 metal = MapMetal(rayPoint);\n    ret = Union(ret, metal);\n#endif\n    \n    ret = Union(ret, vec2(MapGlass(rayPoint),MATGLASS));\n    \n    ret = Union(ret, vec2(sdCylinder(rayPoint-vec3(0,2,0), vec2(3, 0.3)),MATWHITE));\n     \n     float secs = mod( floor(-1000.0),        60.0 );\n\tfloat mins = mod( floor(-1000.0/60.0),   60.0 );\n\tfloat hors = mod( floor(-1000.0/3600.0), 24.0 ) + mins/60.;\n     vec3 ps = rotateY( rayPoint+vec3(0,0,2), 6.2831*secs/60.0 );\n    vec3 pm = rotateY( rayPoint, 6.2831*mins/60.0 );\n    vec3 ph = rotateY( rayPoint, 6.2831*hors/12.0 );\n   \n   float mh = MapHand(pm-vec3(0,2.37,0), 0.06, 2.1, 0.09);\n    float hh = MapHand(ph-vec3(0,2.33,0), 0.06, 1.2, 0.09);\n    float sh = MapHand(ps-vec3(0,2.35,0), 0.03, 0.51, 0.036);\n    ret = Union(ret, vec2(min(min(mh, hh),sh), MATGREY));\n    \n\n    float hp1 = sdCylinder(rayPoint - vec3(0,2,0), vec2(0.05, 0.4));//hand pin 1\n    float hp2 = sdCylinder(rayPoint - vec3(0,2,-2), vec2(0.025, 0.4));//hand pin 2\n    \n    ret = Union(ret, vec2(min(hp1,hp2), MATWHITE2));\n    \n    #ifdef scene1\n    ret = Union(ret, tree);\n    #endif\n    \n    if(ret.x < 0.0001) return (inside == 1.0) ? vec2(-ret.x, ret.y): ret;\n    \n    //ret = Union(ret, vec2(min(sdEllipsoid( rayPoint - vec3(0,1,0), vec3(6.95,.7,6.95) ),-boxes.x),MATBLOOD));\n    \n       return (inside == 1.0) ? vec2(-ret.x, ret.y): ret;\n}\n\n\n\n\n\n\nvec3 calcNormal( in vec3 pos )//normals calculation\n{\n    vec2 eps = vec2(0.0001,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy, 0.0).x - map( pos-eps.xyy, 0.0).x,\n      map( pos+eps.yxy, 0.0).x - map( pos-eps.yxy, 0.0).x,\n      map( pos+eps.yyx, 0.0).x - map( pos-eps.yyx, 0.0).x ) );\n}\n/*\nfloat intersect(in vec3 ro, in vec3 rd, in float inside) {//normal sphere tracing function\n    float res = -1.0;\n    int ignore;\n    float t = 2.0 * max(0.03, map(ro, inside).x);\n    float t_max = 50.0;\n float relax = 1.5;\n    float last_d = 0.0;\n    float last_dt = 0.0;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int curr_id;\n        float d = map(ro + t*rd, inside).x;\n        \n        //test for overrelaxation\n        if (relax != 1.0 && last_dt > abs(last_d) + abs(d))\n        {\n            //if overrelaxed, turn off relaxation and step back\n            t += (1.0 - relax) * last_dt;\n            relax = 1.0;\n            continue;\n        }\n        \n        if (d < 0.005)\n        {\n            break;\n        }        \n        t += relax * d;\n        last_dt = relax * d;\n        last_d = d;\n    } \n    if(t<t_max) res = t;\n    \n    return res;\n    \n}*/\n\n\n//alt intersection(above) drops it from 4.7 to 3.3ms\nfloat intersect(in vec3 ro, in vec3 rd, in float inside) {//normal sphere tracing function\n\tfloat res = -1.0;\n    float tmax = 100.0;\n    float t = 0.001;\n    for(int i = 0; i < 228; i++) {\n    \tfloat h = map(ro+rd*t, inside).x;\n        if((h<0.0001) || (t>tmax)) break;\n        t += h;\n    }\n    if(t<tmax) res = t;\n    \n    return res;\n    \n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    float res = 0.0;\n    \n    float tmax = 12.0;\n    \n    float t = 0.001;\n    for(int i=0; i<80; i++ )\n    {\n        float h = map(ro+rd*t, 0.0).x;\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    if( t>tmax ) res = 1.0;\n    \n    return res;\n}\n\n\nvec3 calcFinalColor(vec3 ro, vec3 rd, inout uint rngState) {//main function\n    vec3 accumulatedColor = vec3(0.0);\n        vec3 colorMask = vec3(1.0);\n            float fdis = 0.0;\n\n        float emmis, refl, refr = 0.0;\n        float IOR = 1.0003;\n        \n    vec3 norm = vec3(0.0);\n    vec3 oro = ro;\n    vec3 ord = rd;\n    float rand = RandomFloat01(rngState);\n   #ifdef sun\n   vec3 SunDir = normalize(SunPos - ro);\n    #endif\n    #ifdef debug\n   \t\t#if debug == 1\n    float t = intersect(ro, rd, 0.0);\n    \n    norm = calcNormal(ro + rd*t);\n    \n    return norm;\n    \t#elif debug == 2\n    float t = intersect(ro, rd, 0.0);\n    return t < 0.0 ? vec3(0.0) : GetMatProps(map(ro + rd*t, 0.0).y, refl, refr, emmis, IOR);\n    \t#endif\n    #else\n    for(int bounce = 0; bounce < BOUNCECOUNT; bounce++) {\n\t\t#ifdef sun\n        SunDir = normalize(SunPos - ro);\n        #endif\n        rand = RandomFloat01(rngState);\n        float preIOR = IOR;\n        float t = intersect(ro, rd, 0.0);\n        vec3 iColor = vec3(0.0);\n\n\n    \tif(bounce == 0) fdis = t;\n        vec3 pos = ro + rd*t;\n        vec3 surfaceColor = GetMatProps(map(pos, 0.0).y, refl, refr, emmis, IOR);\n   #ifdef textures\n   \n   float fbm10 = sin(fbm(pos,15));\n      if(map(pos, 0.0).y == MATBRONZE) {\n    surfaceColor = mix(surfaceColor, vec3(0.000,0.000,0.000), sin(fbm(pos, 15)));\n    refl = min(0.9 - max(0.0,fbm10)/2.0,1.0);\n    }\n    \n    if(map(pos,0.0).y == MATWHITE) {\n    #ifdef scene1\nfloat dial = texture(iChannel3, vec2(.15 * pos.x + 0.5, +.192 * pos.z - .6)).r;\nsurfaceColor = mix(vec3(dial), vec3(0.780,0.667,0.580), fbm10);\n#else\nfloat dial = texture(iChannel3, vec2(.15 * pos.x + 0.5, +.15 * pos.z + .2)).r;\nsurfaceColor = mix(vec3(dial), vec3(0.780,0.667,0.580), fbm10);\n#endif\n}\n            if(map(pos, 0.0).y == MATTILE) {\n      //refl = max(0.0,min(0.0 +  sin(fbm(pos, 1))/10.0,1.0));\n   surfaceColor = mix(surfaceColor, vec3(0.475,0.255,0.106), sin(fbm(pos, 1))/3.0);\n    }\n        #ifdef scene1\n    if(map(pos,0.0).y == MATWOODLIGHT) {\nsurfaceColor = mix(surfaceColor, texcube(iChannel0, pos, vec3(1.0)).xyz, min(1.0, max(0.0, sin(fbm(vec3(pos.x, pos.y, pos.z), 15)))));\n\n}\n#endif\n\n    #endif\n\n\n        if( t < 0.0 )\n        {\n            \n\n        #ifdef sun\n            colorMask *= sunCol;\n            iColor += max(pow(dot(rd, SunDir), 10.0),0.000001) * (1.0 * sunCol) + 2.0 * accumulatedColor;\n            accumulatedColor += colorMask * iColor;//pow is to enhance the directionality of it, I wanted sharper shadows, so I did that\n               #else\n               colorMask *= texture(iChannel0, rd).xyz;\n               iColor += texture(iChannel0, rd).xyz+2.0*accumulatedColor;\n               accumulatedColor += iColor * colorMask;\n               #endif\n               break;\n        }\n\n         norm = calcNormal(pos);\n\n\n        if(refr == 1.0) {//if material is refractive\n            float eps = IOR;\n            if(t < 0.001) {//theory: if ray is already inside an object, use first calculation, else use second calculation\n                norm = -norm;         \n            }else {\n               eps = preIOR/eps;\n            }\n            \n\t\trd = (fresnel(rd, norm, preIOR/eps) > rand) ? reflect(rd, norm) : refract(rd, norm, eps);//Fresnel function located in common\n\n            \n            \n        t = intersect(pos, rd, 1.0);\n        float t2 = (0.3 + sin(fbm(pos+rd*t * rand, 1)))*3.0;\n        pos += rd*t;\n        \n            \n            colorMask *= exp(-(surfaceColor*2.81) * t2 * t ); //coloring based on distance ray travels through transparent object\n        \n        }else { //else if material not refractive\n                  colorMask *= surfaceColor;\n\n            //mix between reflective and diffuse ray directions\n            rd = mix( reflect(rd, norm), RandomUnitVector(rngState, norm), 1.0-refl);\n\n            \n            \n\n              }\n\t\tro = pos;\n        iColor +=  (emmis * surfaceColor) + 2.0 * accumulatedColor * dot(norm, rd);//apply colors and emmisivity\n        accumulatedColor += colorMask * iColor;\n        \n        //if(emmis > 0.0) break;\n\n\n    }\n\n\n    \n    float ff = exp(-0.001*fdis*fdis);\n    accumulatedColor *= ff; \n    accumulatedColor += (1.0-ff)*0.05*vec3(0.9,1.0,1.0);\n   \n   #ifdef sun\n   //removing volumetrics goes from 4.7 to 4.1-4.3ms\n   ff = exp(-0.1*fdis);\n\n   // volumetrics\n   float dt = 0.0;\n   float acc = 0.0;\n\n       float t = fdis*rand;\n       vec3 pos = oro + ord*t;\n       acc += 5.0 * dt*shadow( pos, SunDir );//*exp(-0.25*t);\n\n    accumulatedColor += vec3(0.1)*pow(acc,2.0)*sunCol*0.4;\n    #endif\n#endif\n    return accumulatedColor;\n}\n\n\n\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) //Camera function to make flying camera\n{\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    m.y = -m.y;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3(((fragCoord) - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    \n        vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    vec3 col = vec3(0.0);\n         Camera(fragCoord + jitter, ro, rd);\n         col = calcFinalColor( ro, rd, rngState);\n\n    \n\t\n    \n        \n            vec4 lastFrameColor = texture( iChannel2, fragCoord/iResolution.xy );\n            float blend = (lastFrameColor.a == 0.0f || iMouse.z > 1.0) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    col = mix(lastFrameColor.rgb, col, blend);\n\n    \n    fragColor = vec4(col,blend);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Temporal sampling\n\nfloat grayscale(vec3 image) {\n    return dot(image, vec3(0.3, 0.59, 0.11));\n}\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  lowp vec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n  lowp vec3 imageacc = max( texture(iChannel1,uv).rgb , vec3(0.0));\n  lowp vec3 image = max( texture(iChannel0,uv).rgb , vec3(0.0));  \n\n    //declare stuff\n    const int mSize = 9;\n    const int kSize = (mSize-1)/2 ;\n    float kernel[mSize];\n    vec3 imageblurred = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 1.5;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            imageblurred += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }   \n    \n    imageblurred = imageblurred / (Z*Z);  \n    \n    image = min(image, imageblurred); // reduce fireflies    \n\n    if (iMouse.z < 0.5) \n    {\n        // attempt to reduce ghosting\n        lowp float weight = grayscale( pow( clamp( abs(imageacc - image) * 0.3 , 0., 1.), vec3(0.5)));\n        imageacc = mix(imageacc, image, clamp(weight + 0.1, 0., 1.));\n    } else { \n\n        imageacc = image;\n    }\n    \n    fragColor = vec4(imageacc,1.0);\n\n\t\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/lscBW4\n//\n// In this buffer the albedo of the dial (red channel) and the roughness\n// of the glass (green channel) is pre-calculated.\n//\n\nbool resolutionChanged() {\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\n}\n\nfloat printChar(vec2 uv, uint char) {\n    float d = textureLod(iChannel1, (uv + vec2( char & 0xFU, 0xFU - (char >> 4))) / 16.,0.).a;\n\treturn smoothstep(1.,0., smoothstep(.5,.51,d));\n}\n\nfloat dialSub( in vec2 uv, float wr ) {\n    float r = length( uv );\n    float a = atan( uv.y, uv.x )+3.1415926;\n\n    float f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\n    float g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\n    float w = fwidth(f);\n    f = 1.0 - smoothstep( 0.2*g+0.05-w, 0.2*g+0.05+w, f );\n    float s = abs(fwidth(r));\n    f *= smoothstep( 0.9 - wr -s, 0.9 - wr, r ) - smoothstep( 0.9, 0.9+s, r );\n    float hwr = wr * .5;\n    f -= 1.-smoothstep(hwr+s,hwr,abs(r-0.9+hwr)) - smoothstep(hwr-s,hwr,abs(r-0.9+hwr));\n\n    return .1 + .8 * clamp(1.-f,0.,1.);\n}\n\nfloat dial(vec2 uv) {\n    float d = dialSub(uv, 0.05);\n\n    vec2 uvs = uv;\n    \n    uvs.y += 0.6;\n    uvs *= 1./(0.85-0.6);\n\n    d = min(d, dialSub(uvs, 0.1));\n    \n    vec2 center = vec2(0.5);\n    vec2 radius = vec2(3.65, 0.);\n    \n    for (int i=0; i<9; i++) {\n        if(i!=5) {\n\t        float a = 6.28318530718 * float(i+4)/12.;\n    \t    vec2 uvt = clamp(uv * 5. + center + rotate(radius, a), vec2(0), vec2(1));\n        \td = mix(d, 0.3, printChar(uvt, uint(49+i)));\n        }\n    }\n    for (int i=0; i<3; i++) {\n\t    float a = 6.28318530718 * float(i+13)/12.;\n    \tvec2 uvt1 = clamp(uv * 5. + center + rotate(radius, a) + vec2(.25,0.), vec2(0), vec2(1));\n        d = mix(d, 0.3, printChar(uvt1, uint(49)));\n    \tvec2 uvt = clamp(uv * 5. + center + rotate(radius, a)+ vec2(-.15,0.), vec2(0), vec2(1));\n        d = mix(d, 0.3, printChar(uvt, uint(48+i)));\n    }\n    \n    d *= .9 + .25*texture(iChannel2, uv*.5+.5).r;\n    \n    return pow(clamp(d, 0., 1.), 2.2);\n}\n\nfloat roughnessGlass(vec2 uv) {\n    uv = uv * .5 + .5;\n    return smoothstep(0.2, 0.8, texture(iChannel2, uv * .3).r) * .4 + .2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    if(resolutionChanged() && iChannelResolution[1].x > 0.  && iChannelResolution[2].x > 0.) {\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\n            fragColor = floor(iResolution.xyxy);\n        } else {\n            vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.xy;\n\n            fragColor = vec4( dial(uv), roughnessGlass(uv), 0., 1.0 );      \n        }\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}