{"ver":"0.1","info":{"id":"Mfdyz2","date":"1733240479","viewed":62,"name":"BigGol","username":"JoostAB","description":"A simple big Game Of Life. Just click somewhere in the gris to add 1 cell and see what happens.\nYou can also draw some pixels by keeping the mousebutton pressed\nOptionally shows neighbourcount in color and/or number","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["conway","gameoflife","gol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment to give each cell a greytone depending on the number of neighbours\n//#define GREYTONES\n\n// Uncomment to show number of neighbours (best with higher FPS)\n#define SHOWNEIGBOURS\n\nconst vec3 gridColor = vec3(0.5);\nconst vec3 lifeColor = vec3(1.0);\n\nvec3 circle(vec2 fCoord, vec2 center, vec3 fColor, vec3 color) {\n    return mix(fColor, color, 1.0-smoothstep(fHalfGridSize*.8,fHalfGridSize,distance(fCoord,center)));\n}\n\nvec3 lifeCell(vec2 fCoord, ivec2 coord, vec3 fColor) {\n#ifdef GREYTONES\n    vec3 col = vec3((loadValue(coord).w/8.) + 0.2);\n    return circle(fCoord, posToCellCenter(coord), fColor, col);\n#else\n    return circle(fCoord, posToCellCenter(coord), fColor, lifeColor);\n#endif\n}\n\nvec3 grid(vec2 fCoord, vec3 fColor) {\n    return ((mod(fCoord.x,fGridSize)<1.) || (mod(fCoord.y,fGridSize)<1.))?gridColor:fColor;\n}\n\nvec4 getCell(vec2 fc) {\n    ivec2 pos = ivec2(fc/fGridSize);\n    return loadValue(pos);\n}\n\nvec4 getCell(ivec2 pos) {\n    return loadValue(pos);\n}\n\nfloat isLifeCell(ivec2 pos) {\n    return loadValue(pos).r;\n}\n\nvec2 cellToCharPos(ivec2 cell, float size) {\n    return posToCellCenter(cell)-vec2(7.*size,3.5*size);\n}\n\nfloat digitAt(vec2 fc, ivec2 cell, int digit, float size) {\n    digit += 48; // Start at 0\n    vec2 pos = cellToCharPos(cell, size);\n    pos = pos/iResolution.y;\n    vec2 p = (((fc/iResolution.y)-pos)*(iResolution.y/7.0))/size;\n    p.x -= .5;\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return 0.0;\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(digit, 15-digit/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = grid(fragCoord, vec3(0.0));\n    ivec2 pos = pixelToCell(fragCoord);\n    \n    vec4 cell = getCell(pos);\n    \n    if (cell.r == 1.0) {\n        // Cell is alive\n        col = lifeCell(fragCoord, pos,col);\n        \n#ifdef SHOWNEIGBOURS\n        if (digitAt(fragCoord, pos , int(cell.w), fGridSize*.1) > 0.5) {\n            col = col.x>.5?vec3(0.0):vec3(1.0);\n        }\n#endif\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Controls\n#define GRIDSIZE 40\n// Frames per step :)\n#define FPS 20\n\n// Utilities\n#define loadValue(a) (texelFetch(iChannel0,a,0))\n#define storeVec4Full(a,v,c,p) c=(ivec2(p-0.5)==a)?v:c;\n#define storeVec4(a,v) storeVec4Full(a,v,fragColor, fragCoord)\n#define storeVec2Full(a,v,c,p) storeVec4Full(a,vec4(v,0.0,0.0),c,p)\n#define storeVec2(a,v) storeVec2Full(a,v,fragColor, fragCoord)\n\n// Calculates which cell the passed real pixel coordinates belong to\n#define pixelToCell(p) ivec2(p/fGridSize)\n\n// Converts an ivec2 containing cell coordinates to a vec2 \n// containing the real pixel coordinates of the cell center\n#define posToCellCenter(p) vec2(p)*fGridSize+fHalfGridSize\n#define intmod(a,b) int(mod(float(a),float(b)))\nconst float fGridSize = float(GRIDSIZE);\nconst float fHalfGridSize = fGridSize/2.0;\nconst int iGridSize = GRIDSIZE;\n\nivec2 fieldSize;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nivec2 wrap(ivec2 pos) {\n    /*\n    while (pos.x > fieldSize.x) pos.x = pos.x - fieldSize.x;\n    while (pos.y > fieldSize.y) pos.y = pos.y - fieldSize.y;\n    */\n    return pos;\n}\n\nivec2 wrapa(ivec2 vec) {\n    //vec.x = int(mod(float(vec.x),fGridSize));\n    vec.x = vec.x%fieldSize.x;\n    vec.y = vec.y%fieldSize.y;\n    return vec;\n}\n\nvec2 wrap(vec2 vec) {\n    //vec.x = int(mod(float(vec.x),fGridSize));\n    //vec.x = mod(vec.x,float(fieldSize.x));\n    //vec.y = mod(vec.y,float(fieldSize.y));\n    vec = mod(vec,vec2(fieldSize));\n    return vec;\n}\n\n\nfloat isCellAlive(ivec2 pos) {\n    if (pos.x < 0 || pos.y < 0) return 0.0;\n    pos.x = pos.x%fieldSize.x;\n    pos.y = pos.y%fieldSize.y;\n    return loadValue(pos).r;\n}\n\nfloat startWalker(ivec2 pos) {\n    float f = 0.0;\n    if ((pos.x == 2 && pos.y == 1) ||\n        (pos.x == 3 && pos.y == 2) ||\n        (pos.x == 3 && pos.y == 2) ||\n        (pos.x == 3 && pos.y == 3) ||\n        (pos.x == 2 && pos.y == 3) ||\n        (pos.x == 1 && pos.y == 3) ) {\n        f = 1.0;\n    }\n    return f;\n}\n\nfloat neighbours(ivec2 pos) {\n    float n = 0.0;\n    \n    for(int x = -1; x < 2; x++) {\n        for(int y = -1; y < 2; y++) {\n            ivec2 offset = ivec2(x,y);\n            if (offset != ivec2(0,0)) {\n                n += isCellAlive(pos + offset);\n            }\n        }\n    }\n    \n    \n    return n;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fieldSize = ivec2(iResolution)/iGridSize;\n    \n    ivec2 pos = wrap(ivec2(fragCoord));\n    float state = isCellAlive(pos);\n    \n    if (iFrame == 0) {\n        state = startWalker(pos);\n        fragColor = vec4(vec3(state),1.0);\n        return;\n    }\n    \n    float nCount = neighbours(pos);\n    if (iMouse.z > 0.0) {\n        vec2 mp = iMouse.xy;\n        if (pixelToCell(mp) == pos) {\n            state = 1.0;\n        }\n    } else {\n        if (iFrame%FPS==0) {\n            //float nCount = neighbours(pos);\n            state = nCount == 3.0\n                ? 1.0\n                : nCount == 2.0\n                  ? state\n                  : 0.0;\n        }\n    }\n    fragColor = vec4(vec3(state),nCount);\n}","name":"Buffer A","description":"","type":"buffer"}]}