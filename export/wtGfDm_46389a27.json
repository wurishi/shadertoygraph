{"ver":"0.1","info":{"id":"wtGfDm","date":"1615673921","viewed":294,"name":"cone sampled Beer's law cloud","username":"itsjonebone","description":"I drew inspiration from Schneider's chapter in GPU pro 7\norange dot represents sun direction (disappears when scene rotation makes it inaccurate)","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud","beerslaw","conesamples"],"hasliked":0,"parentid":"WltBRX","parentname":"noise cloud density raymarch"},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ray_it 80 \n#define light_it 8\n\n#define sphere_mult 0.05\n// inv_sphere_mult = 1/sphere_mult\n#define inv_sphere_mult 20.\n\nfloat dist = 40.;\n\n\nfloat opacity = 55.;\nvec3 cloudCol = vec3(0.3, 0.3, 0.8);\n            \nfloat light_opacity = 30.;\nvec3 lightCol = vec3(0.9, 0.1, 0.1);\n\nvec3 bg = vec3(0.2, 0.2, 0.2);\n\nvec3 sun_dir = normalize(vec3(1., 0., 0.));\n\n// in other uses, the RGBA texture used should have different octaves as different colors\n// which would allow the FBM to be the combination of the different channels\n\n// this noise lookup inspired by iq's 3D noise lookup in his clouds shader\nfloat noise(vec3 p) {\n    vec3 id = floor(p);\n    vec3 pos = fract(p);\n    //quintic interpolation\n    pos = pos * pos * pos * (pos *(pos * 6.0 - 15.0) + 10.0);\n    p = id + pos + 0.5;\n    return textureLod(iChannel0, p / 32. , 0.0).x * 2. - 1.;\n}\n\nfloat fbm(vec3 p) {\n    return abs(\n           noise(p * 1.) * .6 ) +\n           noise(p * 2.) * .3 +\n           noise(p * 4.) * .25 +\n           noise(p * 8.) * .125;\n}\n// makes a sphere\n// x - length(p) is inverse distance function \n// points with length less than x get positive values, outside of x radius values become negative\n// high enough values from the FBM can outweigh the negative distance values\nfloat scene(vec3 p) {\n    return .5 - length(p) * sphere_mult + fbm(p * .0321);\n}\n\n// creates a noise vector between (-1,-1,-1) and (1,1,1) \n// to be used for cone sampling\nvec3 noiseVec(vec3 p) {\n    vec3 v = textureLod(iChannel0, normalize(p), 0.).xyz;\n    return v * 2. - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(bg, 1.0);\n    // Normalized pixel coordinates so that 0,0 is the center\n    vec2 uv = (2. * fragCoord - iResolution.xy)/(iResolution.y * 0.9) ;\n    uv.y -= 0.1;\n    // add sun animation\n    sun_dir = normalize(vec3(-1.0 * cos(iTime), .5 * sin(iTime), 0.));\n    \n    // mouse controlled origin\n    float xmouse = 2. * (iMouse.x / iResolution.x) - 1.;\n    if (iMouse.x == 0.) xmouse = 0.;\n    vec3 origin = normalize(vec3(-3. * xmouse + 1., 3. * xmouse + 1., 0.1));\n    \n    // reference animation (only accurate when centered)\n    if (uv.y < -0.95 && abs(xmouse) < 0.1) {\n        vec2 sun_pos = vec2(sun_dir.x, sun_dir.y * -0.1 - 1.1);\n        if (length(uv - sun_pos) < 0.05) fragColor = vec4(1., .6, 0., 0.);\n        return;\n    }\n    \n    /// raycasting \n    // rays start at origin\n    // most of this can be moved to CPU computation to be passed to the shader in a practical application\n    origin *= dist;\n    vec3 target = vec3(0., 0., -1.);\n    // normalized directional vector from origin to target\n    vec3 ot = normalize(target - origin);\n    // normalized left directional vector\n    vec3 left = normalize(cross(vec3(0., 0., 1.), ot));\n    // normalized up directional vector\n    vec3 up = normalize(cross(ot, left));\n    // normalized directional vector from origin to pixel\n    vec3 dir = normalize(uv.x * left + uv.y * up + 1.5 * ot);\n    \n    // density ray loop things\n    float area_mult = (2. * dist) * 0.01;\n    float length_bound = area_mult * inv_sphere_mult;\n    // (area_mult * inv_square_mult)^2 can be done by hand in advance when dist is constant\n    float length_bound_squared = length_bound * length_bound;\n    float zMax = sqrt(length_bound_squared - (uv.x * uv.x + uv.y * uv.y));\n    float zTravel = 2. * zMax;\n    float zStep = zTravel / float(ray_it);\n    vec3 rayPoint = origin;\n    vec3 color = vec3(0.);\n    float density = 0.;\n    //Transmittence\n    float T = 1.;\n    \n    // skip to a place where we start to get actual cloud values\n    rayPoint += dir * (2. * zMax - origin.z);\n    \n    // light loop things\n    float lzTravel = zTravel * 0.25;\n    //float lStep = lzTravel / float(light_it);\n    float lStep = lzTravel * 0.125;\n    vec3 light_step = sun_dir * lStep;\n    float cone_spread_multiplier = length(light_step);\n    float light_density = 0.;\n    float lightSample = 0.;\n    \n    // ray loop\n    for(int i = 0; i < ray_it; i ++) {\n        density = scene(rayPoint);\n        \n        if (density > 0.) {\n            density = density / float(ray_it);\n            T *= 1. - (density * 100.);\n            // if ray_it == 100 we can simplify the above commented lines to:\n            //T *= 1. - density;\n            \n            \n            // allows transmittence to be \"used up\" as it goes through the cloud\n            if (T <= .01) break;\n            \n            /// light sampling\n            // copy point for use in sampling loop\n            vec3 samplePoint = rayPoint;\n            // sampling loop\n            for (int j = 1; j < light_it; j ++) {\n                samplePoint += light_step; \n                   + (cone_spread_multiplier * float(i) * noiseVec(samplePoint));\n                   \n                lightSample = scene(samplePoint);\n                if (lightSample > 0.) {\n                    light_density += lightSample * 0.5;\n                }\n                \n            }\n            \n            // Beer's law states that\n            // E = e^-t\n            // where \n            // E is light engergy\n            // t is thickness\n            color += (cloudCol * opacity + lightCol * exp(-1. * light_density) * light_opacity) * density * T;\n            \n        }\n        rayPoint += dir * zStep;\n    }\n    \n    //add background if you want to!\n    color += bg;\n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}