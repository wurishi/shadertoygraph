{"ver":"0.1","info":{"id":"lXsSWn","date":"1709478396","viewed":61,"name":"sdf_2d_polygon","username":"qt1","description":"Visualization of 2d SDF, Useful for debugging signed distance functions. And an implementation of SDF of a general polygon.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// demonstrate 2d Signed Distance Field\n\n\n#define M_PI 3.14159265358979323846264338327950288\n#define M_2PI 6.28318530717958647692528676655900576\n#define FLT_MAX 3.402823466e+38\n\n\nvec4 colormap_hot(float x) {\n    float r = clamp(8.0 / 3.0 * x, 0.0, 1.0);\n    float g = clamp(8.0 / 3.0 * x - 1.0, 0.0, 1.0);\n    float b = clamp(4.0 * x - 3.0, 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\nvec4 colormap_cool(float x) {\n    float r = (1.0 + 1.0 / 63.0) * x - 1.0 / 63.0;\n    float g = -(1.0 + 1.0 / 63.0) * x + (1.0 + 1.0 / 63.0);\n    float b = 1.0;\n    return vec4(r, g, b, 1.0);\n}\n\n\nstruct Circle {\n    vec2 c;\n    float r;\n};\n\nfloat dist(vec2 p, Circle c) {\n    return length(p-c.c) - c.r;\n}\n\nfloat sdf_disk(vec2 p, float r) {\n    return length(p)-r;\n}\n\nfloat sdf_capped_bar(vec2 p, float r, float len) {\n    float x = max(0.0, abs(p.x) - 0.5*len);\n    return sdf_disk(vec2(x,p.y),r);\n}\n\n\nfloat sdf_rect(vec2 p, float w, float h) {\n    vec2 q = abs(p); // symetry\n    vec2 c = vec2(0.5 * w, 0.5 * h); // corner \n    vec2 cq = q-c;\n    return cq.x>0.0 && cq.y>0.0 ? length(cq) : max(cq.x, cq.y);\n}\n\n\n\n\n#define MAX_VERTICES 10\n\n// nv must be > 2, assumed closed\nfloat sd_convex_poly(vec2 p, vec2 pts[MAX_VERTICES], int nv) {\n    \n    // find the closest point on the polygon\n    int imin=0;\n    float dmin = FLT_MAX;\n    // starting from last segment..\n    for(int i=nv-1, j=0; j<nv; i=j, j++) {\n        vec2 a=pts[i], b=pts[j], ab=b-a, ap=p-a;\n        float t = dot(ap,ab) / dot(ab,ab);\n        float ct = clamp(t, 0.0, 1.0);\n        vec2 q = a + ab*ct;\n        //float s = dot(ap, -vec2(-ab.y, ab.x))>0.0 && ct!=t ? 1.0 : -1.0;\n        float d = length(p-q);\n        if(d<dmin) {\n            dmin=d;\n            imin=i;\n        }\n    }\n    \n   \n    float s;\n    // determine the sign\n    {\n        vec2 a=pts[imin], b=pts[(imin+1)%nv], ab=b-a, ap=p-a;\n        float t = dot(ap,ab) / dot(ab,ab);\n        float ct = clamp(t, 0.0, 1.0);\n        //vec2 q = a + ab*ct;\n        // assuming convex, else need to determine angle\n        s = (dot(ap, -vec2(-ab.y, ab.x))>0.0 || ct!=t) ? 1.0 : -1.0;\n    }\n    \n    return s*dmin;\n}\n\n// nv must be > 2, closed\nfloat sd_poly(vec2 p, vec2 pts[MAX_VERTICES], int nv) {\n    \n    // find the closest point on the polygon\n    int imin=0;\n    float dmin = FLT_MAX;\n    // starting from last segment..\n    for(int i=nv-1, j=0; j<nv; i=j, j++) {\n        vec2 a=pts[i], b=pts[j], ab=b-a, ap=p-a;\n        float t = dot(ap,ab) / dot(ab,ab);\n        float ct = clamp(t, 0.0, 1.0);\n        vec2 q = a + ab*ct;\n        //float s = dot(ap, -vec2(-ab.y, ab.x))>0.0 && ct!=t ? 1.0 : -1.0;\n        float d = length(p-q);\n        if(d<dmin) {\n            dmin=d;\n            imin=i;\n        }\n    }\n    \n   \n    bool pos;\n    // determine the sign\n    {\n        vec2 a=pts[imin], b=pts[(imin+1)%nv], ab=b-a, ap=p-a, right=-vec2(-ab.y, ab.x);\n        float t = dot(ap,ab) / dot(ab,ab);\n        if(t<0.0) {\n            pos = dot(pts[(imin-1+nv)%nv]-a, right)<0.0;\n        } else if(t>1.0) {\n            pos = dot(b-pts[(imin+2)%nv], right)>0.0;\n        } else {\n            pos = dot(ap, right)>0.0 ;\n        }\n     }\n    \n    return pos ? dmin : -dmin;\n}\n\n\n\nvec2 frag_to_clip(vec2 f) {\n    float resolution = min(iResolution.x,iResolution.y);\n    return (f-vec2(iResolution.x*0.5,iResolution.y*0.5))/resolution*2.0;\n}\n\nvec4 d_to_color(float d) {\n    float resolution = 20.0;\n    float I = cos(d*M_2PI*resolution);\n    return d<0.0  \n        ? clamp(I*colormap_cool(-d/2.0),0.0,1.0)\n        //vec4(0.5, 0.5, 0.5 ,1.0) : \n        : clamp(I*colormap_hot(d/2.0),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float resolution = min(iResolution.x,iResolution.y);\n    vec2 p = frag_to_clip(fragCoord);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    Circle c1;\n    c1.c = vec2(0.1, 0.0);\n    c1.r = 0.1;\n\n    Circle c2;\n    c2 = c1;\n    c2.c = frag_to_clip(iMouse.xy);\n    c2.r = 0.1;\n\n    \n    float d = 1000.0;\n    d = min(d, dist(p,c1));\n    \n    //d = min(d, sdf_capped_bar(p, 0.4, 0.5));\n   \n    //d = min(d, sdf_rect(p, 0.45,0.9) + 0.2*sin(iTime));\n    //d = min(d, -0.1+sdf_rect(p, 0.4,0.9));\n    //d = sdf_disk(vec2(p.x, mod(p.y+0.3,0.6)-0.3) , 0.25); // chain\n    \n    vec2 poly1[MAX_VERTICES];// = {vec2(0.0,0.0),vec2(0.5,0.0),vec2(0.6,0.5)};\n    poly1[0] = iMouse.x > 10.0 ? frag_to_clip(iMouse.xy) : vec2(-1.2, 0.0);\n    poly1[1] = vec2(-0.3, -0.0);\n    poly1[2] = vec2(0.7,-0.5);\n    poly1[3] = vec2(0.0,0.2);\n    poly1[4] = vec2(1.1,0.8);\n\n    d = sd_poly(p, poly1, 5) + 0.2*sin(iTime);\n    \n    if(iMouse.x > 10.0) \n        d = min(d, dist(p,c2) );\n    \n    fragColor = d_to_color(d);\n}","name":"Image","description":"","type":"image"}]}