{"ver":"0.1","info":{"id":"mtSGRh","date":"1672820537","viewed":236,"name":"firefly swarm","username":"tieutieu","description":"\nInclude:\n[url]https://www.shadertoy.com/view/3ty3Dy[/url] (fork)\n[url]https://www.shadertoy.com/view/MdGSzt[/url] (perlin noise)\nInspiration:\n[url]https://www.youtube.com/watch?v=Qf4dIN99e2w[/url] (boids)\n","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["2d","perlinnoise","particles","splat","swarm","boids","voronoitracking","write2xy","writetoxy","voronoiparticlestracking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//DRAW PARTICLE\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = T2(I);\n    \n\n\n    //\n    float sinTime       = iTime/COLOR_PERIOD*3.14;\n    float sinTimeOffset = 0.5*3.14;\n    \n    // PARTICLE POST PROCESS\n    vec4 a = T1(I);         // 4 particule id (supposed to be particles closest to I)\n    \n    for(int i = 0; i < 4; i++){ // draw Gaussian blobs\n        \n        float iP = a[i];\n        vec4 P = A(iP);\n        \n        vec2 v = I - P.xy;\n        \n        if( length(v) < PARTICLE_SIZE+2. ){\n            vec4 color = vec4( abs(sin(sinTime))*0.8+0.5, abs(sin(sinTime+sinTimeOffset))*0.4, abs(sin(sinTime+sinTimeOffset*2.))*0.4, 1.);\n            O += vec4(color.xyz,0.0)*0.1;//smoothstep(color, vec4(color.xyz,0.), length(v)-10.);\n        }\n        if( length(v) < PARTICLE_SIZE ){\n            O += vec4(1.,1.,1.,0.0)*0.3;\n        }\n  \n     }\n    \n    \n    //O = vec4(fract(I.xy/10.),0.,0.);\n    \n    //O = T0(I);//DEBUG BUFFER A\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//PARTICLE BEHAVIOR / POSITION & MOMENTUM STORAGE\n\n\nfloat perlin_noise_animated(vec2 p, float scale, float speed)\n{\n    float value = perlin_noise(vec3(p.x*scale,p.y*scale, iTime*speed));\n    return value;\n}\n\nvec2 perlin_noise_animated_rotate_vector(vec2 p, float scale, float speed)\n{\n    float angle = perlin_noise_animated( p.xy, scale, speed)*3.14 *2. ;\n    return vec2(cos(angle),sin(angle));    \n}\n\n#define DEBUG_PERLIN_NOISE 0\n#define DEBUG_PERLIN_NOISE_VECTOR 0\n#define DEBUG 0\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = T0(I);               \n    O.xy = mod(O.xy,R);\n\n    if(iFrame<T_START){\n        vec4 r = rand4( int(I.x) + int(I.y)*2141 + (int(iTime*2141.)+iFrame)*2141);\n        O.xy = r.xy*R;\n        O.zw = .25*cos(TAU*(vec2(0,.25)+r.z));    \n    }\n    else{\n        vec2 p     = O.xy;\n        vec2 v_mom = O.zw;\n\n\n\n    \n\n        // STEER\n        float perlin_scale = PARTICLE_STEERING_PERLIN_SCALE;\n        float perlin_speed = PARTICLE_STEERING_PERLIN_SPEED;\n\n\n        float steer_power = perlin_noise(I.xyx)*PARTICLE_STEERING_POWER;\n        vec2 v_steer = perlin_noise_animated_rotate_vector(O.xy, perlin_scale, perlin_speed)*steer_power;\n\n        vec2 v_mom_next = v_mom + v_steer;\n        v_mom_next *= 1. - ENV_FRICTION;//FRICTION\n        \n        //MAX SPEED\n        //if( 100000. < dot(v_mom_next,v_mom_next) )\n        //    v_mom_next = normalize(v_mom_next);\n\n        p += v_mom_next;\n\n        //next step\n        O.zw = p - O.xy;\n        O.xy = p;\n    }\n    \n    \n     \n \n \n#if DEBUG_PERLIN_NOISE_VECTOR \n    vec2 perlin_vector = perlin_noise_animated_rotate_vector(I.xy, perlin_scale, perlin_speed);\n    \n    float d_r =  max( 0.,perlin_vector.x);\n    float d_g =  max( 0.,perlin_vector.y);\n    float d_b =  max( 0.,perlin_vector.x*-1.);\n    \n    O = vec4( d_r,d_g,d_b,1.); // DEBUG\n#endif\n\n#if DEBUG_PERLIN_NOISE\n    float perlin_value = perlin_noise_animated(I.xy, perlin_scale, perlin_speed);\n    O =vec4( perlin_value,0,0,0 );\n    if( perlin_value < 0. )\n        O =vec4( 0.,perlin_value*-1.,0,0 );\n#endif\n    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//OPTIM - FOR EACH PIXEL STORE 4 CLOSEST PARTICLES ( voronoitracking )\n\n\n\n// --- insert (i,d) and maintain the 4 closest (i_,d_) \nvoid list_insert(inout vec4 i, inout vec4 d, float i_, float d_){\t\n    if(i_ == 0.) return;           // not a particle : exit\n    if(any(equal(vec4(i_),i))) return; // already in top4 : exit\n    if     (d_ < d[0])             // closer to closest: insert here\n        i = vec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             // closer to 2nd closest: insert here\n        i = vec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])             // closer to 3rd closest: insert here\n        i = vec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])             // closer to 4th closest: insert here\n        i = vec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n\nvec2 D;\n#define dist(i) ( D = mod( A(i).xy-I + R/2., R) - R/2., dot(D,D) )\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    vec4  i = vec4(0);\n    vec4  d = vec4(1e9); \n    \n    // STORE FROM HERE\n    vec4 i0 = T1( I ); \n    for(int k = 0; k < 4; k++)    \n        list_insert( i, d, i0[k], dist(i0[k]) );\n         \n    // 4 closests particles from n around\n    for( int n = 1; n < 1+TRACKING_SUROUND_PIXEL_CIRCLE_TO_CHECK; n++){\n        vec4 ia = T1( mod(I + vec2( 1*n, 0*n),R) );  \n        vec4 ib = T1( mod(I + vec2( 0*n, 1*n),R) );\n        vec4 ic = T1( mod(I + vec2(-1*n, 0*n),R) );\n        vec4 id = T1( mod(I + vec2( 0*n,-1*n),R) );\n\n        for(int k = 0; k < 4; k++){    \n            list_insert( i, d, ia[k], dist(ia[k]) );\n            list_insert( i, d, ib[k], dist(ib[k]) );\n            list_insert( i, d, ic[k], dist(ic[k]) );\n            list_insert( i, d, id[k], dist(id[k]) );\n        }\n\n#if 1 \n        // also checking diagonal (to test possibly axis bias)\n        ia = T1( mod(I + vec2( 1*n, 1*n),R) ),\n        ib = T1( mod(I + vec2(-1*n, 1*n),R) ),\n        ic = T1( mod(I + vec2( 1*n,-1*n),R) ),\n        id = T1( mod(I + vec2(-1*n,-1*n),R) );\n        for(int k = 0; k < 4; k++){    // sorts all these\n            list_insert( i, d, ia[k], dist(ia[k]) );\n            list_insert( i, d, ib[k], dist(ib[k]) );\n            list_insert( i, d, ic[k], dist(ic[k]) );\n            list_insert( i, d, id[k], dist(id[k]) );\n        }\n#endif        \n    }\n\n    // INSERT AT THE BEGINING OF THE FRAME\n    if(iFrame < T_START*2){\n        for(int k = 0; k < 1; k++){    \n    \n            int r = IHash( int(I.x) + int(I.y)*2141 + iFrame*2141*2141 +k*11131);\n            int i_ =  1 + r % ( int(R.x*R.y)/int(PARTICLES_NBR) );\n            list_insert(i, d, float(i_), dist(i_) );\n        }\n    }\n    \n    // stores 4 closest\n    O = vec4(i); \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//DRAW PARTICLE TRAIL\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    // TRAIL\n    float sinTime       = iTime/COLOR_PERIOD*3.14;\n    float sinTimeOffset = 0.5*3.14;\n    \n    O = T2(I);\n    O.x*=0.7+abs(sin(sinTime*0.5))*0.2;\n    O.y*=0.7+abs(sin(sinTime*0.4))*0.3;\n    O.z*=0.7+abs(sin(sinTime*0.3))*0.3;\n    \n    // PARTICL\n    vec4 a = T1(I);         // 4 particule id (supposed to be particles closest to I)\n    \n    for(int i = 0; i < 4; i++){ // draw Gaussian blobs\n        \n        float iP = a[i];\n        vec4 P = A(iP);\n        \n        vec2 v = I - P.xy;\n        \n        if( length(v) < PARTICLE_SIZE+1.1 ){\n            //O = rand4(int(iP));\n            O = vec4( abs(sin(sinTime))*0.8+0.5, abs(sin(sinTime+sinTimeOffset))*0.4, abs(sin(sinTime+sinTimeOffset*2.))*0.4, 1.);\n        }\n  \n     }\n\n   \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//PARAMETERS\n#define PARTICLES_NBR 20. // 1 is the nbr max of particles (screen resolution) \n#define PARTICLE_SIZE 1.\n\n#define PARTICLE_STEERING_PERLIN_SCALE 0.01\n#define PARTICLE_STEERING_PERLIN_SPEED 0.4\n#define PARTICLE_STEERING_POWER 0.5\n\n#define ENV_FRICTION 0.05\n\n#define COLOR_PERIOD 5.\n\n//TECHNICAL PARAMETERS\n#define T_START 60*1\n#define TRACKING_SUROUND_PIXEL_CIRCLE_TO_CHECK 2\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////UTILS\n\n// --- translate particle id (in [1,Rx*Ry] ) to buffer pixel \n#define A(n) T0( vec2( (int(n)-1) % iR.x,      \\\n                       (int(n)-1) / iR.x ) +.5 )  // +.5 useless\n\n// --- utils\n                           \n#define R     iResolution.xy\n#define iR    ivec2(iResolution)\n#define T0(U) texelFetch( iChannel0, ivec2(U)   , 0 )\n#define T1(U) texelFetch( iChannel1, ivec2(U)%iR, 0 )\n#define T2(U) texelFetch( iChannel2, ivec2(U)   , 0 )\n#define T3(U) texelFetch( iChannel2, ivec2(U)   , 0 )\n\n#define l2(x) dot(x,x)\n\n#define TAU 6.2831853\n                           \n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n                           \n\n// --- random numbers\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\n#define Hash(a) ( float(IHash(a)) / float(0x7FFFFFFF) ) // Uniform in [0,1]\n\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\n\n// --- normal law random generator\nvec2 randn(vec2 r){ // r: randuniform\n    r.x = sqrt( -2.* log(1e-9+abs(r.x)));\n    r.y *= TAU;\n    return r.x * vec2(cos(r.y),sin(r.y));\n}\n\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n\n","name":"Common","description":"","type":"common"}]}