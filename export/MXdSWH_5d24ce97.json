{"ver":"0.1","info":{"id":"MXdSWH","date":"1719007384","viewed":75,"name":"Dithered Pixel Art Planet","username":"ArchaicVirus","description":"Palette based bayer dithering","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raycast","sphere","planet","art","pix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DITHER_STRENGTH 0.075\n#define PIXEL_SIZE 4.0\n\nfloat hash(float n) {\n    return fract(sin(n) * 53738.14534123);\n}\n\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n    float scale = 105.0;\n    return mix(\n        mix(hash(ip.x + ip.y * scale), hash(ip.x + 1.0 + ip.y * scale), u.x),\n        mix(hash(ip.x + (ip.y + 1.0) * scale), hash(ip.x + 1.0 + (ip.y + 1.0) * scale), u.x),\n        u.y\n    );\n}\n\nvec3 rotate(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);\n}\n\nfloat layeredNoise(vec3 p, float amplitude, float frequency, float persistence, int octaves) {\n    float n = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotate(p, 45.0);\n    }\n    return n;\n}\n\nfloat sphere(vec3 ro, vec3 rd, float radius) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvec3 colorBanding(float n) {\n    vec3 color = vec3(0);\n    if (n > 0.95) return vec3(0.0, 0.1, 0.5);\n    else if (n > 0.85) color = vec3(0.0, 0.3, 0.7);\n    else if (n > 0.75) color = vec3(0.0, 0.5, 0.8);\n    else if (n > 0.65) color = vec3(0.0, 0.7, 0.7);\n    else if (n > 0.55) color = vec3(0.8, 0.6, 0.4);\n    else if (n > 0.45) color = vec3(0.0, 0.6, 0.0);\n    else color = vec3(0.4, 0.6, 0.1);\n    return color;\n}\n\nconst mat4 bayerMatrix = mat4(\n    0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,\n    12.0/16.0, 4.0/16.0, 14.0/16.0,  6.0/16.0,\n    3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,\n    15.0/16.0, 7.0/16.0, 13.0/16.0,  5.0/16.0\n);\n\nvec3 applyDithering(vec3 color, vec2 uv, float noiseValue) {\n    int x = int(mod(uv.x, 4.0));\n    int y = int(mod(uv.y, 4.0));\n    float threshold = bayerMatrix[x][y];\n    noiseValue += threshold*DITHER_STRENGTH;\n    return colorBanding(noiseValue);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float pixelSize = PIXEL_SIZE;\n    vec2 uv = (floor(fragCoord / pixelSize) * pixelSize - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 ro_planet = vec3(0.0, 0.0, 2.4);\n    vec3 ro_clouds = vec3(0.0, 0.0, 2.3);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float t_planet = sphere(ro_planet, rd, 1.0);\n    float t_clouds = sphere(ro_clouds, rd, 1.0);\n    if (t_clouds < 0.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        vec3 pos = ro_planet + t_planet * rd;\n        pos = rotate(pos, iTime * 0.25);\n        vec3 norm = normalize(pos);\n        float noiseValue = layeredNoise(norm * 3.1415 + 50.0, 0.75, 1.0, 0.5, 8);\n        \n        vec3 color;\n        if (t_planet < 0.0) {\n            color = vec3(0.0);\n        } else {\n            color = applyDithering(colorBanding(noiseValue), fragCoord.xy / pixelSize, noiseValue);\n        }\n        \n        vec3 pos2 = ro_clouds + t_clouds * rd;\n        pos2 = rotate(pos2, iTime);\n        vec3 norm2 = normalize(pos2);\n        float noiseValue2 = layeredNoise(norm2 * 2.55275, 1.0, 1.0, 0.5, 8);\n        float noiseValueFinal = pow(noiseValue2, 1.05) - 1.0;\n        vec4 color2 = vec4(vec3(noiseValueFinal), min(noiseValue2 - 0.5, 0.1));\n        fragColor = vec4(color, 1.0);\n        //uncomment below to enable clouds\n        //fragColor = vec4(mix(color, color2.rgb + vec3(0.0, 0.22, 0.75), noiseValue2) + color, 1.0);\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}