{"ver":"0.1","info":{"id":"msVcRw","date":"1695938170","viewed":70,"name":"Low-Precision 3x5 Printf","username":"cnlohr","description":"Another one of my tiny printf fonts.  This one is geared for embedded GPUs where integers are meidump.  See this for a much nicer (but heavier) font. https://www.shadertoy.com/view/stK3Rm","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["font","printf"],"hasliked":0,"parentid":"csGyzw","parentname":"4x6 Shader Font"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tiny Print Font, Public Domain 2023 Charles Lohr\n\n// This one is smalle nough it should work with mediump ints for embedded GPUs.\n\n// xxx  x  xxx xxx x x xxx x   xxx xxx xxx\n// x x 1x    x   x x x x   x     x x x x x\n// x x  x   x   xx xxx xxx xxx  x  xxx xxx\n// x x  x  x     x   x   x x x  x  x x   x\n// xxx  x  xxx xxx   x xxx xxx  x  xxx xxx\n\nconst int tppfont[] = int[13]( \n    31599,  // 0 111101101101111\n    9370,   // 1 010010010011010\n    29671,  // 2 111001111100111\n    31143,  // 3 111100110100111\n    18925,  // 4 100100111101101\n    31183,  // 5 111100111001111\n    31689,  // 6 111101111001001\n    9383,   // 7 010010010100111\n    31727,  // 8 111101111101111\n    31215,  // 9 111100111101111\n    8192,   // . 010000000000000\n    448,    // - 000000111000000\n    0       //   000000000000000\n);\n\n\nconst int ipow10[12] = int[12]( 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 2147483647, 2147483647 );\n#define calc_ipow10(x) ipow10[x]\n\nfloat char3x5( int ch, vec2 uv )\n{\n    vec2 fuv = fract(uv);\n    ivec2 pos = ivec2( fuv * vec2( 4, 6  ) );\n    int offset = pos.x + pos.y * 3;\n    // In 16-bit mode, overshifting produces weird results.  Make surt to clip off.\n    return (pos.x < 3 && pos.y < 5) ? float( ( tppfont[ch] >>  offset ) & 1 ) : 0.0;\n}\n\n\n\nfloat print3x5int( int num, vec2 uv, int places )\n{\n    vec2 cuv = uv*vec2( places, 1. );\n    vec2 luv = cuv*vec2( 1, 1. );\n    ivec2 iuv = ivec2( luv );\n    int posi = int(iuv.x);\n    int marknegat = -1;\n    if( num < 0 )\n    {\n        marknegat = places-int(log(-float(num))/log(10.0))-2;\n    }\n    num = abs(num);\n    int nn = (num/calc_ipow10(places-posi-1));\n    if( posi == marknegat )\n        nn = 11;\n    else if( nn <= 0 && posi != places-1)\n        nn = 12;\n    else\n        nn %= 10;\n    int ch = nn;\n    return char3x5( ch, fract(cuv)*vec2(1.,1.) );\n}\n\n\n// Zero Leading Integer Print\nfloat print3x5intzl( int num, vec2 uv, int places )\n{\n    vec2 cuv = uv*vec2( places, 1. );\n    vec2 luv = cuv*vec2( 1, 1. );\n    ivec2 iuv = ivec2( luv );\n    int posi = int(iuv.x);\n    int nn = (num/calc_ipow10(places-posi-1));\n    nn %= 10;\n    int ch = nn;\n    return char3x5( ch, fract(cuv)*vec2(1.,1.) );\n}\n\nfloat print3x5float( float num, vec2 uv, int wholecount, int decimalcount )\n{\n    vec2 cuv = uv*vec2( wholecount+decimalcount+1, 1. );\n    vec2 luv = cuv*vec2( 1, 1 );\n    ivec2 iuv = ivec2( luv );\n    int posi = int(iuv.x);\n    int nn = 10;\n    \n    int marknegat = -1;\n    if( num < 0.0 )\n    {\n        marknegat = wholecount-2-int(log(-num)/log(10.0));\n    }\n    \n    num = abs(num);\n    num +=  pow(.1f,float(decimalcount))*.499;\n    int nv = int( num );\n    \n    if( posi < wholecount )\n    {\n        int wholediff = posi - wholecount+1;\n        float v = (pow( 10.0 , float(wholediff)));\n        int ni = int( float(nv) * v);\n        if( posi == marknegat ) nn = 11;\n        else if( ni <= 0 && wholediff != 0 ) nn = 12; //Blank out.\n        else         nn = ni%10;\n    }\n    else if( posi > wholecount )\n    {\n        num -= float(nv);\n        nn = int( num * pow( 10.0 , float(posi-wholecount)));\n        nn %= 10;\n    }\n    int ch = nn;\n\n    return char3x5( ch, fract(cuv)*vec2( 1, 1. ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    \n    uv.y*=12.0;\n\n    vec3 col = vec3( print3x5float( sin(iTime + max(0.9,uv.y)), fract( uv*vec2( 3.0, 1.0) ), 4, 5 ) );\n    if( uv.y > 8.0 )\n        col = vec3( print3x5int( -267890, fract( uv*vec2( 3.0, 1.0 ) ), 10 ) );\n    else if( uv.y > 4.0 )\n        col = vec3( print3x5float( -3.14159, fract( uv*vec2( 3.0, 1.0) ), 4, 5 ) );\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}