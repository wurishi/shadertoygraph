{"ver":"0.1","info":{"id":"Xt2GWt","date":"1433619483","viewed":601,"name":"Procedural Houndstooth","username":"ChristinaCoffin","description":"example of how to create a procedural texture by breaking it down to its basic components and layering them to create vector pattern shapes.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Procedural Houndstooth shader\n// \ttutorial of one way to combine multiple procedural shapes without using if() branches\n// \tto create a complex pattern.\n//\n// by @christinacoffin\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// for application as a procedural texture on 3d obj+environment,\n//\tyou'd need to supersample+filter the results of Houndstooth() function.\n// a good article on that can be found here:\n//\thttps://iquilezles.org/articles/filtering\n \nfloat Houndstooth( vec2 uv_A )\n{\n    // generate working vars for 2x2 checker shape\n    float sub_A = step(uv_A.x, 0.5);\n    float sub_B = step(1.0-uv_A.y, 0.5);\n    float sub_C = max(sub_A,sub_B);// L shape black\n    float sub_D = min(sub_A,sub_B);// L shape black (inverted)\n    float sub_E = 1.0-sub_C;// corner\n    \n    float stripe_A =  step( (uv_A.x) + (uv_A.y),  0.25 ); \n    float stripe_B =  step( (uv_A.x) + (uv_A.y),  0.5 ); \n    float stripe_C =  step( (uv_A.x) + (uv_A.y),  0.75 ); \n\n    float stripe_F =  step( (uv_A.x-0.5) + (uv_A.y-0.5),  0.25 );\n    float stripe_G =  step( (uv_A.x-0.5) + (uv_A.y-0.5),  0.5 );\n    float stripe_H =  step( (uv_A.x-0.5) + (uv_A.y-0.5),  0.75 );    \n    \n\t// build diagonal parts as 3 bands and generate that before mixing in the square quadrants.\n    \n    // subtracting the results of a stepfunction with a lower threshold value from a higher one\n    //\tcreates a square wave function that we use to create the diagonal bands    \n    \n    // a good reference to visualize step+pulse functions and mixing them can be found here:\n    //\thttp://realtimecollisiondetection.net/blog/?p=95    \n    \n    // 1st band\n    float lum = (stripe_B  - stripe_A);\n    // larger inner diagonal\n    lum +=\t(stripe_F  - stripe_C);\n    // 3rd band\n    lum +=\t(stripe_H  - stripe_G);\n    \n    // put the black+white squares in the diagonal quadrants 'on top' to finish the pattern\n    lum += sub_E;// top diag corner white  \n    lum -= sub_D;// upper left corner black    \n    \n    return clamp(lum , 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = iTime;// animated rotation over time.\n  \n\tvec2 uv;\n    vec2 vignetteUV;\n    uv = fragCoord.xy / iResolution.xy;\n    vignetteUV = uv;// copy UV for vignette code\n    \n    vec4 animFragColor;\n    animFragColor = vec4(fract(uv),0.5+0.5*sin(iTime),1.0);\n    \n    uv.xy += vec2( -.5, -.5);// offset uv so it rotates in the center of screen\n    uv.x /= iResolution.y/iResolution.x;// aspect correct\n    uv *= 6.0;// tiling factor of pattern\n\n\t// rotate UV space\n    vec2 rotCoord;\n    rotCoord.x = uv.x * cos(angle) + uv.y * sin(angle);\n    rotCoord.y = uv.x * - sin(angle) + uv.y * cos(angle);    \n      \n    vec2 uv_A = rotCoord;// copy rotated UV\n    uv_A = uv_A - floor(uv_A);// turn the tiled UV coords into 0-1 space for the procedural texture func\n    \n    fragColor.rgb = vec3( Houndstooth( uv_A ) );// 'sample' the procedural texture\n    \n    fragColor.rgb*= animFragColor.rgb;// mul with screen gradient wash color to colorize it \n    \n\t//-----------------------------------------------------\n\t// Vignette\n\tfragColor.rgb *= 0.15 + 0.85*pow( abs(32.0*vignetteUV.x*vignetteUV.y*(1.0-vignetteUV.x)*(1.0-vignetteUV.y)), 0.85 );    \n\n}","name":"","description":"","type":"image"}]}