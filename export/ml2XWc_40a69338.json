{"ver":"0.1","info":{"id":"ml2XWc","date":"1678621540","viewed":482,"name":"bathroom","username":"belfry","description":"Mouseable.","likes":18,"published":1,"flags":32,"usePreview":1,"tags":["shaft","replication","anime","bakemonogatari"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.1415926;\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat extrude(float d, float y, float h) {\n    vec2 a = vec2(d, abs(y) - h);\n    float i = max(a.x, a.y);\n    float o = length(max(vec2(0.), a));\n    return i < 0. ? i : o;\n}\n\nfloat smin(float a, float b, float t) {\n    float s = smoothstep(-t, t, a - b);\n    return mix(a, b, s) - s * (1. - s) * t;\n}\n\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 e) {\n    p = abs(p);\n    vec2 a = p - e;\n    float i = max(a.x, a.y);\n    float o = length(max(vec2(0.), a));\n    return i < 0. ? i : o;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 e) {\n    p = abs(p);\n    vec3 a = p - e;\n    float i = max(a.x, max(a.y, a.z));\n    float o = length(max(vec3(0.), a));\n    return i < 0. ? i : o;\n}\n\nfloat cylinder(vec3 p, float h, float r) {\n    return extrude(circle(p.xz, r), p.y, h);\n}\n\nfloat capsule(vec3 p, float h, float r) {\n    p.y -= clamp(p.y, -h, h);\n    return length(p) - r;\n}\n\nfloat triangle(vec3 p, float h, vec2 q) {\n    return extrude(sdTriangleIsosceles(p.xz, q), p.y, h);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nconst float WALL_FRAME = 0.;\nconst float WALL_INSIDE = 1.;\nconst float WALL_GLASS = 2.;\nconst float WALL_TRIANGLE = 3.;\nconst float WALL_QUAD = 4.;\nconst float FLOOR = 5.;\nconst float FLOWER_INNER = 6.;\nconst float FLOWER_OUTLINE = 7.;\nconst float RING = 8.;\nconst float SPIRAL = 9.;\nconst float POLES = 10.;\nconst float TRIANGLES_UNDER_FLOWER = 11.;\nconst float DOOR_FRAME = 12.;\nconst float DOOR_HANDLE = 13.;\nconst float DOOR_OUTER = 14.;\nconst float DOOR_INNER = 15.;\nconst float SHELF_SOLID = 16.;\nconst float BATHTUB_BODY = 17.;\nconst float BATHTUB_LEG = 18.;\nconst float TAP_PIPE = 19.;\nconst float TAP_BOX = 20.;\nconst float TAP_VALVE = 21.;\nconst float TAP_VALVE_HOT = 22.;\nconst float TAP_VALVE_COLD = 23.;\nconst float SHELF_TRANSPARENT = 24.;\nconst float WATER = 25.;\nconst float MIRROR = 26.;\nconst float SINK = 27.;\nconst float SINK_LEGS = 28.;\nconst float CHAIR = 29.;\nconst float CHAIR_LEGS = 30.;\n\nvec2 wallPart0(vec3 p) {\n    float frame0 = box(p, vec3(.8, 2., .1));\n    float frame1 = box(p, vec3(.7, 1.8, .2));\n    float frame2 = box(p - vec3(0., 1.7, -0.05), vec3(.7, .1, .05));\n    float frame = min(max(frame0, -frame1), frame2);\n    float inside0 = box(p - vec3(0., -.1, -.09), vec3(.7, 1.7, .01));\n    float inside1 = box(p - vec3(0., -.4, -.09), vec3(.25, 1.5, .1));\n    float inside = max(inside0, -inside1);\n    float glass = box(p - vec3(0., -.4, -.09), vec3(.25, 1.5, .01));\n    return min2(vec2(glass, WALL_GLASS), \n                min2(vec2(inside, WALL_INSIDE), vec2(frame, WALL_FRAME))\n    );\n}\n\nvec2 wallPartSide(vec3 p) {\n    vec2 part0 = wallPart0(p);\n    p = p.xzy;\n    p -= vec3(0., 0.63, 2.56);\n    p.yz *= rot(radians(-45.));\n    float tri = triangle(p, .03, vec2(.8, -.8));\n    return min2(part0, vec2(tri, WALL_TRIANGLE));\n}\n\nvec2 wallPartFront(vec3 p) {\n    vec2 part0 = wallPart0(p);\n    float k = .8 / sqrt(2.);\n    float tri = triangle(p.xzy - vec3(0., 0., 2. + k), .1, vec2(.8, -k));\n    return min2(part0, vec2(tri, WALL_TRIANGLE));\n}\n\nvec2 wallsSide(vec3 p) {\n    p.z = -abs(p.z) + 6.5;\n    p = opRepLim(p, 1.6, vec3(5., 0., 0.));\n    return wallPartSide(p);\n}\n\nvec2 wallsSideUp(vec3 p) {\n    p.y += -2.56;\n    p.z = -abs(p.z) + 5.87;\n    p.x = abs(p.x) - 4.;\n    p.yz *= rot(radians(45.));\n    p = opRepLim(p, 1.6, vec3(2., 0., 0.));\n    p.xy *= rot(radians(45.));\n    return vec2(box(p, vec3(.56, .56, .03)), WALL_QUAD);\n}\n\nvec2 wallsFront(vec3 p) {\n    p.xz = p.zx;\n    p.z = -abs(p.z) + 8.9;\n    p.x = abs(abs(p.x) - 4.8) - 0.8;\n    return wallPartFront(p);\n}\n\nvec2 _floor(vec3 p) {\n    return vec2(box(p - vec3(0., -1.9, 0.), vec3(8.8, .1, 6.4)), FLOOR);\n}\n\nfloat pedal00(vec2 p) {\n    p -= vec2(.3, -.29);\n    float s1 = circle(p - vec2(.0, 0), .25);\n    float s2 = circle(p - vec2(1.519, .53), 1.925);\n    float s3 = circle(p - vec2(-.3, -.013), .85);\n    float s4 = circle(p - vec2(1.35, -.58), 1.124);\n    float s5 = mix(s1, s2, .6);\n    float s6 = mix(s3, s4, .45);\n    return max(s5, s6);\n}\n\nfloat pedal01(vec2 p) {\n    p -= vec2(.0, -.08628);\n    float s1 = circle(p - vec2(.1, .1), .3);\n    float s2 = circle(p - vec2(1.719, -1.6), 2.150425);\n    float s3 = circle(p - vec2(1.419, -1.6), 2.150685);\n    float s4 = circle(p - vec2(-.1, -.1), .2);\n    float s5 = mix(s1, s2, .5);\n    float s6 = mix(s3, s4, .5);\n    return max(s5, s6);\n}\n\nfloat flower00(vec2 p, float scale) {\n    float d = 10000000.;\n    p /= scale;\n    for (int i = 0; i < 3; i++) {\n        p *= rot(PI * 2. / 3.);\n        d = min(d, pedal00(p));\n    }\n    return d * scale;\n}\n\nfloat flower01(vec2 p, float scale) {\n    return flower00(p * rot(PI * 1. / 3.), scale);\n}\n\nfloat flower10(vec2 p, float scale) {\n    p = vec2(-p.x, p.y);\n    float d = 10000000.;\n    p /= scale;\n    for (int i = 0; i < 6; i++) {\n        p *= rot(PI * 2. / 6.);\n        d = min(d, pedal01(p));\n    }\n    return d * scale;\n}\n\nfloat flowerOutline(vec2 flowerDists, float scale) {\n    vec2 d = abs(flowerDists) - .01 * scale;\n    return min(d.x, d.y);\n}\n\nfloat flowerOutline(float flowerDists, float scale) {\n    return abs(flowerDists) - .01 * scale;\n}\n\nvec2 flower(vec3 p) {\n    vec2 largeFlowerDists = vec2(flower00(p.yz, 1.), flower01(p.yz, 1.));\n    vec2 q = p.yz * rot(-.1);\n    vec2 smallFlowerDists = vec2(flower00(q, .6), flower01(q, .6));\n    float largeFlower1Dist = flower10(p.yz * rot(.15), .7);\n    float largeOutline = flowerOutline(largeFlowerDists, 1.);\n    float smallOutline = flowerOutline(smallFlowerDists, .6);\n    float large1Outline = flowerOutline(largeFlower1Dist, 1.);\n    float outline = min(large1Outline, min(largeOutline, smallOutline));\n    float largeFlowerDist = min(largeFlowerDists.x, largeFlowerDists.y);\n    largeFlowerDist = min(largeFlowerDist, largeFlower1Dist);\n    largeFlowerDist = max(largeFlowerDist, -outline);\n    vec2 flowerInner = vec2(extrude(largeFlowerDist, p.x, .05), FLOWER_INNER);\n    vec2 flowerOutline = vec2(extrude(outline, p.x, .05), FLOWER_OUTLINE);\n    return min2(flowerInner, flowerOutline);\n}\n\nvec2 flowers(vec3 p) {\n    p = vec3(abs(p.x) - 9.1, p.y - 3.3, p.z);\n    p.yz *= rot(.5);\n    p /= 2.0;\n    vec2 f = flower(p);\n    return vec2(f.x * 2.0, f.y);\n}\n\nfloat lineDist(vec2 p, vec2 s, vec2 d, float w) {\n    return length(clamp(dot(d, p - s) / dot(d, d), 0., 1.) * d + s - p) - w;\n}\n\nfloat ringDist(vec2 uv) {\n    vec2 polar = vec2(atan(uv.y, uv.x), length(uv));\n    float tiling = 11.;\n    vec2 a = vec2(0., .75);\n    vec2 b = vec2(PI / tiling, .75);\n    vec2 m = vec2(PI / tiling * .5, .7);\n    polar.x = mod(polar.x, PI / tiling);\n    a = vec2(cos(a.x), sin(a.x)) * a.y;\n    b = vec2(cos(b.x), sin(b.x)) * b.y;\n    m = vec2(cos(m.x), sin(m.x)) * m.y;\n    uv = vec2(cos(polar.x), sin(polar.x)) * polar.y;\n    float l1 = lineDist(uv, a, m - a, .0025);\n    float l2 = lineDist(uv, b, m - b, .0025);\n    vec2 d = normalize(a - b) * .05;\n    float h = lineDist(uv, m, vec2(-d.y, d.x), .005);\n    float c1 = abs(circle(uv, .755)) - .005;\n    float c2 = abs(circle(uv, .695)) - .0025;\n    return min(c2, min(c1, min(h, min(l1, l2))));\n}\n\nvec2 ring(vec3 p) {\n    vec3 q = opRepLim(p, 1.9, vec3(4., 0., 0.));\n    float s = .095;\n    float d1 = extrude(ringDist(q.yz * s) / s, q.x, .05);\n    q = p;\n    q.x = abs(q.x) - 4.8;\n    q.yz *= rot(.14);\n    q = opRepLim(q, 1.9, vec3(2., 0., 0.));\n    float d2 = extrude(ringDist(q.yz * s) / s, q.x, .05);\n    return vec2(min(d1, d2), RING);\n}\n\nfloat spiralDist(vec2 polar) {\n    float tiling = 12.;\n    polar.x += PI / tiling * .5 + polar.y * .5;\n    polar.x = mod(polar.x, PI / tiling) - PI / tiling * .5;\n    vec2 p = vec2(cos(polar.x), sin(polar.x)) * polar.y;\n    return length(p.y) - .025;\n}\n\nfloat doubleSpiralDist(vec2 p) {\n    vec2 polar = vec2(atan(p.y, p.x), length(p));\n    return min(spiralDist(polar), spiralDist(vec2(-polar.x, polar.y)));\n}\n\nvec2 spiral(vec3 p) {\n    p = vec3(abs(p.x) - 9.2, p.y - 1.8, p.z);\n    p /= 2.25;\n    float d = doubleSpiralDist(p.yz);\n    d = max(d, box(p.yz - vec2(-.85, 0.), vec2(1., 1.8)));\n    return vec2(extrude(d, p.x, .01) * 1., SPIRAL); // not scaling the distance with 2.25 to counter overstepping\n}\n\nfloat polesDist(vec2 p) {\n    vec2 q = vec2(abs(p.x) - 3., p.y - 4.5);\n    q = opRepLim(q, 2., vec2(1., 0.));\n    float h = box(q, vec2(0.5, .05));\n    float c = circle(p, 7.9);\n    p.x = mod(p.x, 1.) - .5;\n    float d = abs(p.x) - .05;\n    d = max(d, -box(p - vec2(-.85, 0.), vec2(1., 1.8)));\n    float c1 = abs(c) - .05;\n    return min(h, min(c1, max(d, c)));\n}\n\nvec2 poles(vec3 p) {\n    p.x = abs(p.x) - 9.5;\n    float d = polesDist(p.zy);\n    return vec2(extrude(d, p.x, .1), POLES);\n}\n\nvec2 trianglesUnderFlower(vec3 p) {\n    vec3 q1 = p;\n    float s = 1.09;\n    p.y += 1.5;\n    p.x = abs(p.x) - 8.9;\n    vec2 q = p.zy;\n    q *= s;\n    float b = box(q, vec2(3.5, sqrt(2.) * .25));\n    q = opRepLim(vec2(q.x, -q.y + sqrt(2.) * .75), 1., vec2(3., 0.));\n    float t = sdTriangleIsosceles(q, vec2(1., sqrt(2.)) * .5);\n    float dist = min(b, t);\n    dist = extrude(dist / s, p.x, .1);\n    q1 -= vec3(8.9, -.42, 0.);\n    float doorFrame = box(q1, vec3(.2, 1.5, 1.38));\n    return vec2(max(dist, -doorFrame), TRIANGLES_UNDER_FLOWER);\n}\n\nvec2 doors(vec3 p) {\n    p -= vec3(8.9, -.4, 0.);\n    float doorFrame = box(p, vec3(.1, 1.5, 1.38));\n    doorFrame = max(doorFrame, -box(p, vec3(.2, 1.4, 1.28)));\n    float doorOuter = box(p, vec3(.05, 1.4, 1.28));\n    vec3 q = p;\n    q.z = abs(q.z) - .625;\n    doorOuter = max(doorOuter, -box(q, vec3(.2, 1.35, .575)));\n    float doorInner = box(q, vec3(.025, 1.35, .575));\n    q = vec3(p.x - .0, p.y, abs(p.z) - 1.235);\n    float doorHandle = box(q, vec3(.075, .15, .02));\n    vec2 result = vec2(doorFrame, DOOR_FRAME);\n    result = min2(result, vec2(doorOuter, DOOR_OUTER));\n    result = min2(result, vec2(doorInner, DOOR_INNER));\n    result = min2(result, vec2(doorHandle, DOOR_HANDLE));\n    return result;\n}\n\nfloat shelfPart1(vec3 p) {\n    vec3 q = p;\n    q.y += .2;\n    q.xz = abs(q.xz) - .4;\n    float legs = cylinder(q, 1.8, .04);\n    q = p;\n    q.y = abs(q.y - .5) - .65;\n    q = q.yxz;\n    q.z = abs(q.z) - .4;\n    float mid = cylinder(q, .4, .04);\n    q = p;\n    q.y -= 1.525;\n    q = q.yzx;\n    q.z = abs(q.z) - .4;\n    float top = cylinder(q, .4, .04);\n    q = p;\n    q.y = abs(q.y - .475) - .75;\n    q = q.yzx;\n    q.yz *= rot(radians(-45.));\n    float diagonal = cylinder(q, .575, .01);\n    return min(diagonal, min(top, min(legs, mid)));\n}\n\nfloat shelfCubes(vec3 p, float time) {\n    time *= .5;\n    vec3 q = p;\n    q.y += .25;\n    q.xz *= rot(radians(-45.) + sin(time * 1.1) * .5);\n    q.yz *= rot(-time);\n    float b1 = box(q, vec3(.25));\n    q = p;\n    q.y -= 1.25;\n    q.xz *= rot(radians(-45.) + sin(time * .9) * .5);\n    q.yz *= rot(time);\n    float b2 = box(q, vec3(.25));\n    return min(b1, b2);\n}\n\nfloat shelfSolid(vec3 p, float time) {    \n    return min(shelfPart1(p), shelfCubes(p, time));\n}\n\nvec2 shelfsSolid(vec3 p, float time) {\n    vec3 id = sin(round(p/4.) * 123.123 + 12.321) * PI * 2.;\n    float i = id.x + id.z;\n    vec3 q = p;\n    q.z = abs(q.z) - 5.;\n    q.x += 3.;\n    q = opRepLim(q, 4., vec3(1., 0., 0.));\n    float d = shelfSolid(q, time * sign(i) + i);\n    \n    id = sin(round(p/3.) * 123.123 + 12.321) * PI * 2.;\n    i = id.x + id.z;\n    q = p;\n    q.x += 3.;\n    q.xz = abs(q.xz) - 3.;\n    d = min(d, shelfSolid(q, time * sign(i) + i));\n\n    d = min(d, shelfSolid(p - vec3(-4.5, 0., 2.5), time + 125.3434));\n    d = min(d, shelfSolid(p - vec3(2., 0., -1.5), -time + 225.3434));\n\n    return vec2(d, SHELF_SOLID);\n}\n\nfloat bathtubBody(vec3 p, out float m) {\n    float s = 1.6;\n    p *= s;\n    float part1 = extrude(sdTrapezoid(p.xy, .75, 1., .4), p.z, .1);\n    float part2 = extrude(sdTrapezoid(p.xy - vec2(.6, .55), .95, 6.5, .65), p.z, 2.);\n    float part3 = extrude(sdTrapezoid(p.zy - vec2(0., .0), .001, .1, .4), p.x, 1.);\n    float d0 = max(part1, part3) - .425;\n    float d = max(part1, part3) - .4;\n    d = max(abs(d) - .025, -part2);\n    float r = max(max(d, part2), -d0) - .05;\n    m = d0;\n    return min(r, d) / s;\n}\n\nfloat bathtubLegs(vec3 p) {\n    p.y -= -.425;\n    p.xz = abs(p.xz) - vec2(.59, .165);\n    float a = sdRoundCone(p, vec3(0.), vec3(-.025, -.12, -.025), .05, .025);\n    p.z -= .05;\n    float b = sdRoundCone(p, vec3(-.025, -.15, -.075), vec3(.014, -.2, -.04), .025, .025);\n    return smin(a, b, .015);\n}\n\nvec2 bathtub(vec3 p) {\n    p -= vec3(-3., -1.155, 0.);\n    p.xz = vec2(-p.z, p.x);\n    float m;\n    vec2 body = vec2(bathtubBody(p, m), BATHTUB_BODY);\n    vec2 legs = vec2(max(bathtubLegs(p), -m), BATHTUB_LEG);\n    return min2(body, legs);\n}\n\nvec2 tapPipeIn(vec3 p) {\n    float c4 = capsule(p.xzy - vec3(0., .0, .18), .065, .01);\n    p.z = abs(p.z) - .07;\n    float c1 = capsule(p, .45, .01);\n    vec3 q = p;\n    q -= vec3(-0.04, .49, 0.);\n    q.xy *= rot(radians(45.));\n    float c2 = capsule(q, .05, .01);\n    q = p;\n    q -= vec3(-.0775, .605, 0.);\n    float c3 = capsule(q, .075, .01);\n    float pipe = smin(c3, smin(c1, c2, .0025), .0025);\n    pipe = smin(pipe, c4, .0025);\n    return vec2(pipe, TAP_PIPE);\n}\n\nvec2 tapBox(vec3 p) {\n    return vec2(box(p - vec3(-.0775, 0.6, 0.), vec3(.05, .025, .13)), TAP_BOX);\n}\n\nvec2 tapPipeOut(vec3 p) {\n    vec3 q = p;\n    q -= vec3(-0.105, .55, 0.);\n    q.xy *= rot(radians(5.*45.));\n    float ct = sdCappedTorus(q, vec2(sin(PI * .25),cos(PI * .25)), 0.025, 0.01 );\n    float c = capsule(p - vec3(-0.08, .575, 0.), .00975, .01);\n    float pipe = smin(c, ct, .01);\n    q = p;\n    q -= vec3(-0.1525, .525, 0.);\n    q = q.yxz;\n    c = capsule(q, .0325, .01);\n    pipe = smin(pipe, c, .01);\n    q = p;\n    q -= vec3(-0.2, .5005, 0.);\n    q.xy *= rot(radians(45.));\n    ct = sdCappedTorus(q, vec2(sin(PI * .25),cos(PI * .25)), 0.025, 0.01 );\n    pipe = smin(pipe, ct, .01);\n    q = p;\n    q -= vec3(-0.225, .487, 0.);\n    c = cylinder(q, .005, .01);\n    pipe = smin(pipe, c, .009);\n    \n    return vec2(pipe, TAP_PIPE);\n}\n\nvec2 tapValve(vec3 p) {\n    p -= vec3(-0.075, .675, .0);\n    float id = p.z > 0. ? TAP_VALVE_HOT : TAP_VALVE_COLD;\n    p.z = abs(p.z) - .07;\n    float d = circle(p.xz, .035) + sin(atan(p.z, p.x) * 10.) * .0025;\n    float v = extrude(d, p.y, .0375);\n    p.y -= .0135;\n    float c = cylinder(p, .025, .01);\n    return vec2(min2(vec2(v, TAP_VALVE), vec2(c, id)));\n}\n\nvec2 tap(vec3 p) {\n    //p -= vec3(-0., -1.35, 0.);\n    p -= vec3(-2.575, -1.55, -0.3);\n    return min2(min2(min2(tapPipeIn(p), tapBox(p)), tapPipeOut(p)), tapValve(p));\n}\n\nvec2 mirror(vec3 p) {\n    return vec2(cylinder(p.xzy - vec3(-4.5, -3.8, -.5), .02, .6), MIRROR);\n}\n\nvec2 sinkLegs(vec3 p) {\n    p -= vec3(-4.5, -1.6, -3.5);\n    vec3 q = p;\n    q.xz = abs(q.xz) - vec2(.45, .25);\n    float b = box(q, vec3(.015, .2, .015));\n    q = p;\n    q.x = abs(q.x) - .45;\n    float b1 = box(q, vec3(.015, .015, .25));\n    return vec2(min(b, b1), SINK_LEGS);\n}\n\nvec2 chairLegs(vec3 p) {\n    p -= vec3(-4.5, -1.65, -2.75);\n    p.xz = abs(p.xz) - vec2(.15, .15);\n    return vec2(box(p, vec3(.015, .2, .015)), CHAIR_LEGS);\n}\n\nvec2 sdf(vec3 p, float time) {\n    vec2 result = _floor(p);\n    result = min2(result, wallsSide(p));\n    result = min2(result, wallsFront(p));\n    result = min2(result, wallsSideUp(p));\n    result = min2(result, flowers(p));\n    result = min2(result, ring(p));\n    result = min2(result, spiral(p));\n    result = min2(result, poles(p));\n    result = min2(result, trianglesUnderFlower(p));\n    result = min2(result, doors(p));\n    result = min2(result, shelfsSolid(p, time));\n    result = min2(result, bathtub(p));\n    result = min2(result, tap(p));\n    result = min2(result, mirror(p));\n    result = min2(result, sinkLegs(p));\n    result = min2(result, chairLegs(p));\n    return result;\n}\n\nfloat shelfTransparent(vec3 p, float time) {\n    return box(p - vec3(0., -1.3, 0.), vec3(.5));\n}\n\nvec2 shelfsTransparent(vec3 p, float time) {\n    vec3 id = sin(round(p/4.) * 123.123 + 12.321) * PI * 2.;\n    float i = id.x + id.z;\n    vec3 q = p;\n    q.z = abs(q.z) - 5.;\n    q.x += 3.;\n    q = opRepLim(q, 4., vec3(1., 0., 0.));\n    float d = shelfTransparent(q, time * sign(i) + i);\n    \n    id = sin(round(p/3.) * 123.123 + 12.321) * PI * 2.;\n    i = id.x + id.z;\n    q = p;\n    q.x += 3.;\n    q.xz = abs(q.xz) - 3.;\n    d = min(d, shelfTransparent(q, time * sign(i) + i));\n\n    d = min(d, shelfTransparent(p - vec3(-4.5, 0., 2.5), time + 125.3434));\n    d = min(d, shelfTransparent(p - vec3(2., 0., -1.5), -time + 225.3434));\n\n    return vec2(d, SHELF_TRANSPARENT);\n}\n\nvec2 water(vec3 p, float time) {\n    p -= vec3(-3., -1.155, 0.);\n    p.xz = vec2(-p.z, p.x);\n    \n    float s = 1.6;\n    p *= s;\n    float part1 = extrude(sdTrapezoid(p.xy, .75, 1., .4), p.z, .1);\n    float part2 = extrude(sdTrapezoid(p.xy - vec2(.6, .55), .95, 6.5, .65), p.z, 2.);\n    float part3 = extrude(sdTrapezoid(p.zy - vec2(0., .0), .001, .1, .4), p.x, 1.);\n    float d0 = max(part1, part3) - .425;\n    float d = max(part1, part3) - .4;\n    d = max(d, -part2);\n    float r = max(max(d, part2), -d0) - .05;\n    r = min(r, d);\n    p -= vec3(-0., -1.2, 0.);\n    float b = box(p, vec3(1.5, 1., .7)) + sin(cos(p.x + p.y + time) * 3.) * .03;\n    r = max(r, b);\n    return vec2(r / s, WATER);\n}\n\nvec2 sink(vec3 p) {\n    p -= vec3(-4.5, -1.275, -3.5);\n    float b = box(p, vec3(.5, .125, .3));\n    float s = sphere(p - vec3(0., .12, .065), .18);\n    return vec2(max(b, -s), SINK);\n}\n\nvec2 chair(vec3 p) {\n    p -= vec3(-4.5, -1.4, -2.75);\n    float b = box(p, vec3(.2, .0525, .2));\n    return vec2(b, CHAIR);\n}\n\nvec2 sdfTransparent(vec3 p, float time) {\n    vec2 result = shelfsTransparent(p, time);\n    result = min2(result, water(p, time));\n    result = min2(result, sink(p));\n    result = min2(result, chair(p));\n    return result;\n}\n\nvec2 sdfAmbientOcclusion(vec3 p, float time) {\n    vec2 result = _floor(p);\n    result = min2(result, wallsSide(p));\n    result = min2(result, wallsFront(p));\n    result = min2(result, wallsSideUp(p));\n    result = min2(result, doors(p));\n    result = min2(result, tap(p));\n    return result;\n}\n\nvec2 sdfShadow(vec3 p, float time) {\n    vec2 result = ring(p);\n    result = min2(result, poles(p));\n    result = min2(result, bathtub(p));\n    return result;\n}\n\nvec3 gradient(vec3 p, float time) {\n    vec2 e = vec2(0., .001);\n    vec3 n = vec3(0.);\n    for (int i = min(iFrame, 0); i < 6; i++) { // ugly, but reduces compile time...\n        int k = i > 2 ? i - 3 : i;\n        vec3 o = vec3(k == 2 ? e.y : e.x, k == 1 ? e.y : e.x, k == 0 ? e.y : e.x);\n        float s = i < 3 ? 1. : -1.;\n        float x = s * sdf(p + o * s, time).x;\n        n += vec3(k == 2 ? x : 0., k == 1 ? x : 0., k == 0 ? x : 0.);\n    }\n    return normalize(n);\n    /*\n    float dx = sdf(p + e.yxx, time).x - sdf(p - e.yxx, time).x;\n    float dy = sdf(p + e.xyx, time).x - sdf(p - e.xyx, time).x;\n    float dz = sdf(p + e.xxy, time).x - sdf(p - e.xxy, time).x;\n    return normalize(vec3(dx, dy, dz));\n    */\n}\n\nvec3 gradientTransparent(vec3 p, float time) {\n    vec2 e = vec2(0., .001);\n    vec3 n = vec3(0.);\n    for (int i = min(iFrame, 0); i < 6; i++) { // ugly, but reduces compile time...\n        int k = i > 2 ? i - 3 : i;\n        vec3 o = vec3(k == 2 ? e.y : e.x, k == 1 ? e.y : e.x, k == 0 ? e.y : e.x);\n        float s = i < 3 ? 1. : -1.;\n        float x = s * sdfTransparent(p + o * s, time).x;\n        n += vec3(k == 2 ? x : 0., k == 1 ? x : 0., k == 0 ? x : 0.);\n    }\n    return normalize(n);\n    /*\n    float dx = sdf(p + e.yxx, time).x - sdf(p - e.yxx, time).x;\n    float dy = sdf(p + e.xyx, time).x - sdf(p - e.xyx, time).x;\n    float dz = sdf(p + e.xxy, time).x - sdf(p - e.xxy, time).x;\n    return normalize(vec3(dx, dy, dz));\n    */\n}\n\nstruct Material {\n    vec3 diffuse;\n    vec3 specular;\n    vec3 emission;\n    float reflectance;\n    float ambientOcclusion;\n    float receiveShadow;\n    float transparency;\n};\n\nconst Material[] materials = Material[](\n// WALL_FRAME\nMaterial(vec3(.005), vec3(.01), vec3(0.), 0., 1., 0., 1.), \n// WALL_INSIDE\nMaterial(vec3(.005), vec3(.01), vec3(0.), 0., 1., 0., 1.), \n// WALL_GLASS\nMaterial(vec3(.05), vec3(.03), vec3(0.), 0., 0., 0., 1.), \n// WALL_TRIANGLE\nMaterial(vec3(.005), vec3(.01), vec3(0.), 0., 1., 0., 1.), \n// WALL_QUAD\nMaterial(vec3(.005), vec3(.01), vec3(0.), 0., 1., 0., 1.), \n// FLOOR\nMaterial(vec3(.2), vec3(.1), vec3(0.), .2, 1., .1, 1.), \n// FLOWER_INNER\nMaterial(vec3(.05), vec3(.025), vec3(.3, .45, .35), 0., 0., 0., 1.), \n// FLOWER_OUTLINE\nMaterial(vec3(.0), vec3(.0), vec3(0.), 0., 0., 0., 1.), \n// RING\nMaterial(vec3(0.2), vec3(0.2), vec3(0.), 0., 0., 0., 1.), \n// SPIRAL\nMaterial(vec3(0.0), vec3(0.0), vec3(0.), 0., 0., 0., 1.), \n// POLES\nMaterial(vec3(0.2), vec3(0.2), vec3(0.), 0., 0., 0., 1.), \n// TRIANGLES_UNDER_FLOWER\nMaterial(vec3(0.05), vec3(0.1), vec3(0.), 0., 0., 0., 1.), \n// DOOR_FRAME\nMaterial(vec3(.1, .1, .0), vec3(0.1), vec3(0.), 0., 1., 0., 1.), \n// DOOR_HANDLE\nMaterial(vec3(0.3), vec3(0.1), vec3(0.), 0., 1., 0., 1.), \n// DOOR_OUTER\nMaterial(vec3(0.1), vec3(0.), vec3(0.), 0., 1., 0., 1.), \n// DOOR_INNER\nMaterial(vec3(0.5), vec3(0.5), vec3(0.), 0., 1., 0., 1.), \n// SHELF_SOLID\nMaterial(vec3(0.1), vec3(0.2), vec3(0.), 0., 0., 0., 1.), \n// BATHTUB_BODY\nMaterial(vec3(0.03), vec3(0.002), vec3(0.15), 0., 0., 0., 1.), \n// BATHTUB_LEG\nMaterial(vec3(.2, 0.05, 0.05), vec3(.05, .01, .01), vec3(.125, .0, .0), 0., 0., 0., 1.), \n// TAP_PIPE\nMaterial(vec3(0.2), vec3(0.2), vec3(0.), 0., 0., 0., 1.), \n// TAP_BOX\nMaterial(vec3(0.1), vec3(0.1), vec3(0.), 0., 0., 0., 1.), \n// TAP_VALVE\nMaterial(vec3(0.1), vec3(0.1), vec3(0.05), 0., 1., 0., 1.), \n// TAP_VALVE_HOT\nMaterial(vec3(0.3, 0., 0.), vec3(0.2), vec3(0.), 0., 0., 0., 1.), \n// TAP_VALVE_COLD\nMaterial(vec3(0., 0., 0.3), vec3(0.2), vec3(0.), 0., 0., 0., 1.),\n// SHELF_TRANSPARENT\nMaterial(vec3(0.3), vec3(0.5), vec3(0.), 0., 0., 0., .3),\n// WATER\nMaterial(vec3(0.05, .3, .2), vec3(0.5), vec3(0.), 0., 0., 0., .3),\n// MIRROR\nMaterial(vec3(.5), vec3(1.), vec3(0.), .9, 0., 0., .0),\n// SINK\nMaterial(vec3(0.1, .2, .2), vec3(0.2), vec3(0.), 0., 0., 0., .6),\n// SINK_LEGS\nMaterial(vec3(0.05), vec3(0.05), vec3(0.), 0., 0., 0., 1.),\n// CHAIR\nMaterial(vec3(0.1, .2, .2), vec3(0.2), vec3(0.), 0., 0., 0., .6),\n// CHAIR_LEGS\nMaterial(vec3(0.05), vec3(0.05), vec3(0.), 0., 0., 0., 1.)\n);\n\nfloat ambientOcclusion(vec3 pos, vec3 n, float time) {\n    float ao = 0.;\n    for (float i = 1.; i < 6.; i++) {\n        float t = i * .1;\n        vec3 p = t * n + pos;\n        float dist = sdfAmbientOcclusion(p, time).x;\n        ao += abs(dist - t) / pow(2., i);\n    }\n    return clamp(1. - 2. * ao, 0., 1.);\n}\n\nfloat shadow(vec3 pos, vec3 l, float time) {\n    float s = 1.;\n    float t = .1;\n    for (float i = 0.; i < 100.; i++) {\n        vec3 p = pos + l * t;\n        float dist = sdfShadow(p, time).x;\n        s = min(s, dist / t);\n        t += dist;\n    }\n    return clamp(abs(s), 0., 1.);\n}\n\nbool is(float id, float ID) {\n    return abs(id - ID) < .5;\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 d, float id, float time, float t,\n    out float reflectance, out float transparency)\n{\n    const vec3 l = normalize(vec3(-1., 1., -1.));\n    const vec3 l2 = normalize(vec3(1., 1., 1.));\n    Material mat = materials[int(id + .5)];\n    if (is(id, FLOOR)) {\n        mat.diffuse += textureLod(iChannel0, p.xz * .5, t * .5).rgb * .1;\n    }\n    if (is(id, WALL_GLASS)) {\n        vec2 uv = p.xy;// + floor(p.x * 123.4324) * .2;\n        if (abs(n.x) > .5)\n            uv = p.yz;// + floor(p.z * 321.2452) * .2;\n        mat.emission += textureLod(iChannel1, uv * .25, t * .125).rgb;\n    }\n    if (is(id, WATER)) {\n        mat.diffuse = mix(mat.diffuse, vec3(0., .0, .6), abs(dot(n, d)));\n    }\n    vec3 diffuse = mat.diffuse * max(0., dot(n, l));\n    diffuse += .5 * mat.diffuse * max(0., dot(n, l2));\n    vec3 specular = mat.specular * pow(max(0., dot(n, normalize(l + d))), 32.);\n    specular += .5 * mat.specular * pow(max(0., dot(n, normalize(l2 + d))), 32.);\n    vec3 ambient = vec3(.05) * vec3(.3, .45, .35);\n    ambient += smoothstep(4., 8., p.y) * 1.;\n    if (mat.ambientOcclusion != 0.)\n        ambient *= mix(1., ambientOcclusion(p, n, time), mat.ambientOcclusion);\n    float s = 1.;\n    if (mat.receiveShadow != 0.)\n        s = mix(1., shadow(p, l, time), mat.receiveShadow);\n    reflectance = mat.reflectance;\n    transparency = mat.transparency;\n    return s * (diffuse + specular) + mat.emission + ambient;\n}\n\nbool trace(float time, vec3 pos, vec3 dir, \n    inout float t, out float i, out vec3 p, out float id) \n{\n    for (i = 0.; i < 200.; i++) {\n        p = t * dir + pos;\n        vec2 obj = sdf(p, time);\n        id = obj.y;\n        if (abs(obj.x) < t * .001)\n            return true;\n        t += obj.x;\n        if (t > 100.)\n            return false;\n    }\n    return false;\n}\n\nvec4 traceTransparent(float time, vec3 pos, vec3 dir, \n    float maxDist, inout float t, out float i) \n{\n    vec2 obj = sdfTransparent(pos, time);\n    bool inside = obj.x < 0.;\n    vec3 col = vec3(0.);\n    float alpha = 1.;\n    for (i = 0.; i < 200.; i++) {\n        vec3 p = t * dir + pos;\n        obj = sdfTransparent(p, time);\n        float id = obj.y;\n        if (obj.x < 0. != inside) {\n            float reflectance; // unused due to performance\n            float transparency;\n            vec3 n = gradientTransparent(p, time);\n            vec3 color = shade(p, n, -dir, id, time, t, reflectance, transparency);\n            col += color * transparency * alpha;\n            alpha *= (1. - transparency);\n            inside = !inside;\n            //t += .1;\n        }\n        t += max(.01, abs(obj.x));//max((inside && obj.x < 0.) ? , obj.x);\n        //if (obj.x < 0.)\n        //    col += vec3(.05);\n        if (t > maxDist)\n            return vec4(col, alpha);\n    }\n    return vec4(col, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 dir = normalize(vec3(uv, 1. / tan(radians(30.))));\n    vec3 camPos = vec3(0., -.535, -4.525);\n    float time = iTime;\n    \n    float r = time * .1 + .28;\n    if (iMouse.x != 0. && iMouse.y != 0.) {\n        r = iMouse.x / iResolution.x - .5 + .28;\n    }\n    dir.xz *= rot(r * PI * 2.);\n    camPos.xz *= rot(r * PI * 2.);\n\n    //camPos += vec3(-4.5, 0., -3.5);\n    float t = 0.;\n    vec3 pos = camPos;\n    float blend = 1.;\n    fragColor.rgb = vec3(0.);\n    for (int k = min(0, iFrame); k < 2; k++) {\n        float i;\n        vec3 p;\n        float id;\n        bool hit = trace(time, pos, dir, t, i, p, id);\n        vec3 n = gradient(p, time);\n\n        float t2 = 0.;\n        float i2;\n        vec4 transColor = traceTransparent(time, pos, dir, t, t2, i2);\n\n        if (hit) {\n            float reflectance;\n            float dummy;\n            vec3 solidShaded = shade(p, n, -dir, id, time, t, reflectance, dummy);\n            vec3 col = mix(transColor.rgb, solidShaded, transColor.a);\n            fragColor.rgb = mix(fragColor.rgb, col, blend);\n            if (reflectance != 0.) {\n                pos = p;\n                dir = reflect(dir, n);\n                t = .01;\n                blend = reflectance;\n            } else\n                break;\n        } else {\n            vec3 bg = mix(vec3(0.), vec3(.3, .45, .35), abs(uv.y));\n            vec3 col = mix(transColor.rgb, bg, transColor.a);\n            fragColor.rgb = mix(fragColor.rgb, col, blend);\n            break;\n        }\n    \n    }\n    fragColor.rgb *= vec3(.8, 1.15, 1.);\n    fragColor.rgb = sqrt(fragColor.rgb);\n    fragColor.rgb *= 1.5 - length(uv) * .6;\n    //fragColor = vec4(t / 1000.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// --- taken from: https://iquilezles.org/articles/distfunctions2d/ ---\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot(k2, k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\n// --------------------------------------------------------------------\n\n// ---- taken from: https://iquilezles.org/articles/distfunctions/ ----\nvec3 opRepLim( in vec3 p, in float c, in vec3 l )\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nvec2 opRepLim( in vec2 p, in float c, in vec2 l )\n{\n    vec2 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot( pa*l2 - ba*y, pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n// --------------------------------------------------------------------","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float s = 3.;\n    float t = 2.;\n    vec3 e = vec3(s * uv.x + uv.y, s - s * uv.x + uv.y, uv.y * 2.) * t;\n   \tvec3 id = floor(e);\n    e = fract(vec3(e.xy, e.z + 1.));\n    e = smoothstep(0., .05, e) * smoothstep(1., .95, e);\n    float l = 1. - e.x * e.y * e.z;\n    fragColor = vec4(l*(vec3(1.)), 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 fbm(vec2 uv) {\n    vec4 n = vec4(0.);\n    float t = 0.;\n    for (float i = 1.; i < 40.; i *= 2.) {\n        n += texture(iChannel0, uv * i / 32.) / i;\n        t += 1. / i;\n    }\n    return n / t;\n}\n\nvec4 voronoi(vec2 uv, float tiling) {\n    float d1 = 10000.001;\n    float d2 = 10000.001;\n    vec2 id = vec2(0., 0.);\n    for (float i = -1.; i < 1.5; i++) {\n        for (float j = -1.; j < 1.5; j++) {\n            vec2 tileUV = fract(tiling * uv) + vec2(i, j);\n            vec2 tileID = floor(tiling * uv) - vec2(i, j);\n            //tileID = mod(tileID, vec2(14.));\n            vec4 noise = texelFetch(\n                iChannel0,\n                ivec2(mod(tileID, iChannelResolution[0].xy)),\n                0\n            );\n            vec2 pd = noise.xy - tileUV;\n            float d = dot(pd, pd);\n            if (d < d1) {\n                d2 = d1;\n                d1 = d;\n                id = tileID;\n            }\n            if (d < d2 && d > d1) {\n                d2 = d;\n            }\n        }\n    }\n    return vec4(d1, abs(d1 - d2), id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float tiling = 14.;\n    vec4 v = voronoi(uv, tiling);\n    vec4 noise = texelFetch(\n        iChannel0,\n        ivec2(mod(v.zw, iChannelResolution[0].xy)),\n        0\n    );\n    vec4 noise2 = texelFetch(\n        iChannel0,\n        ivec2(mod(v.zw + vec2(623., 122.), iChannelResolution[0].xy)),\n        0\n    );\n    vec4 f = fbm(uv * 3.);\n    vec4 f1 = fbm(uv * 5. + f.xy * .5);\n    vec3 c = clamp(v.y * (.75 + .2) * mix(noise.xxy, noise2.xyy, f1.x * f1.x * 10.), 0., 1.);\n    fragColor.rgb = c;\n}","name":"Buffer B","description":"","type":"buffer"}]}