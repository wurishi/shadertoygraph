{"ver":"0.1","info":{"id":"3lXGzM","date":"1556462876","viewed":802,"name":"The Walk","username":"OliverSchaff","description":"The materials contain a density in their a-coordinate. This defines the transparency.\nUse mouse to rotate.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","volumetric","glass","transforms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Renderingcode from a shader by Shane\n// https://www.shadertoy.com/view/ll2SRy\n\n#define PI 3.14159265359\n#define grad_step 0.01\n\n#define wormTimeXF pow(clamp(sin(2.0*PI*time-0.3*2.0*PI),0.0,1.0),0.8)\n#define wormTimeXB pow(clamp(sin(2.0*PI*time-0.3*2.0*PI-1.0*PI),0.0,1.0),0.8)\n\n#define time 0.5*iTime\n\n#define ZERO (min(iFrame,0))\n\nvec2 opUC( vec2 d1, vec4 mate1, vec2 d2, vec4 mate2, out vec4 mate){\n    if (d1.x<d2.x) {\n        mate = mate1;\n        return d1;\n    }\n    mate = mate2;\n    return d2;\n}\n\n\nvec2 opUC_s( vec2 a, vec4 matea,vec2 b, vec4 mateb, float k , out vec4 mate){\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    float d = mix( b.x, a.x, h ) - k*h*(1.0-h);\n    \n    mate = mix( mateb, matea, h ) - k*h*(1.0-h);\n    \n    if (a.x<b.x) {\n        return vec2(d,a.y);\n    }\n    return vec2(d,b.y);\n}\n\n\n// iq's distance functions\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 carToCyl(vec3 p) {\n    mat2 rot = mat2(-1.0,0.0,0.,-1.0);\n    p.xy = rot*p.xy;\n    float r = length(p.xy);\n    float the = atan(p.y,p.x);\n    return vec3(r,the,p.z);\n}\n\n// 2D rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) { \n\tfloat angle = 2.*PI/repetitions; \n\tfloat a = atan(p.y, p.x) + angle/2.; \n\tfloat r = length(p); \n\tfloat c = floor(a/angle); \n\ta = mod(a,angle) - angle/2.; \n\tp = vec2(cos(a), sin(a))*r; \n    // For an odd number of repetitions, fix cell index of the cell in -x direction // (cell index would be e.g. -5 and 5 in the two halves of the cell): \n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.z -= clamp( p.z, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat blob(vec2 p,float r){\n    float f = smoothstep(0.2*r,r,length(p));\n    return f;\n}\n\nfloat line( vec3 p, vec3 a, vec3 b, float radius, inout vec4 mate)\n{\n\tvec3 ba = b - a;\n\tvec3 pa = p - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - radius;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xy-c.xy)-c.z;\n}\n\n// https://www.shadertoy.com/view/4djSRW\n// thanks to Dave_Hoskins\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\nvec2 map(in vec3 p, out vec4 mate){\n    \n    float tubeTime = floor(time)+smoothstep(0.3,0.7,fract(time));\n    p.x += 0.2*sin(2.0*p.z+4.0*time);\n    p.z += tubeTime;\n    \n\n    // tube\n    vec3 pt = p;\n    pt.z -= tubeTime;\n\tconst float xOffset = 0.4;\n    \n    // tube material\n    vec3 ptm = pt;\n    vec3 pcyl = carToCyl(ptm-vec3(xOffset,0,0));\n    vec4 mate0 = vec4(1,1,1,0.2);\n    vec4 mate1 = vec4(texture(iChannel0,1.0*vec2(pcyl.y/PI,pcyl.z)).rrr,0.6);\n    const float radius = 0.3;\n    float modRadius = 0.06*mate1.r+radius+0.1*pow(abs(sin(-3.*time+0.25*pt.z)),25.0);\n    mate0 = mix(mate0,mate1,0.7);\n\n    vec2 d0 = vec2(sdCylinder(pt, vec3(xOffset,0.0,modRadius)),1.0);\n    \n    // leaves\n    vec3 pl = pt;\n\tpl.xy -= vec2(xOffset,0.0);\n    pl.z = fract(0.5*pl.z)/0.5;\n    float leafIndex = pModPolar(pl.xy,3.);\n    pl = rotationXY(vec2(0.0,-2.7))*pl;\n    vec2 d1 = vec2(sdVerticalCapsule(pl-vec3(-1.2,0.0,0.4),-1.8,0.03-0.03*pl.z),3.0);\n    \n    // leaf material\n    mate1 = vec4(0.6,0.8,1,0.2);\n    d0 = opUC_s(d0, mate0,d1,mate1,0.3,mate0);\n    \n    // worm body\n    mate1 = vec4(1,1,1,0.2);\n    vec3 pb = p;\n\n    float wormTimeZ = floor(time)+smoothstep(0.3,0.7,fract(time))-floor(time-0.5)-smoothstep(0.3,0.7,fract(time-0.5));\n    vec3 back = vec3(-0.4*wormTimeXB+0.7*wormTimeXF,0.,1.5+wormTimeZ);\n    float l = length(back);\n    pb.x += 0.7*wormTimeXF+radius-0.19+0.4*(0.5+0.5*sin(1.6*PI*p.z/l-0.8));\n    pb = rotationXY(vec2(0.0,-atan(back.x/back.z)))*pb;\n    pb.z *= 1.0/length(back);\n    \n    // worm's freckles\n    pcyl = carToCyl(pb-vec3(0.,0.,0.));\n    vec2 ps = vec2(10.0*0.5*pcyl.y/PI,20.0*pcyl.z);\n   \tvec2 fps = fract(ps);\n    vec2 ips = floor(ps);\n    vec2 ran = hash22(ips);\n//    vec2 ran = texelFetch( iChannel0, (ivec2(ips)+10), 0 ).rg;\n    float r = 0.2+0.3*ran.x;\n    float blob = blob(fps-0.2-0.4*ran.xy, r);\n    float freckles = (1.0-blob)*smoothstep(0.0,0.1,pb.z)*smoothstep(1.0,0.9,pb.z);\n    mate1 = mix(mate1, vec4(1,0.2,0,0.8), freckles);\n\n    d1 = vec2(sdVerticalCapsule(pb, 1.0, 0.15-0.07*wormTimeZ+0.01*freckles),1.0);\n\n    pb.z *= length(back);\n    // head\n    vec4 mate2 = vec4(1,0.2,0,0.4);\n    vec4 mate3;\n    vec2 d2 = vec2(sdSphere(pb-vec3(0,0,-0.2),0.15),2.0);\n    d1 = opUC_s(d1, mate1 ,d2, mate2 ,0.1, mate3);\n    \n    // back end\n    d2 = vec2(sdSphere(pb-vec3(0,0,length(back)+0.15),0.15),3.0);\n    d1 = opUC_s(d1, mate3 ,d2, mate2 ,0.1, mate3);\n    \n    vec2 dFinal = opUC_s(d0, mate0, d1, mate3, 0.05, mate);\n    return dFinal;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float ep )\n{\n    vec4 kk;\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk).x );\n#else\n    // prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep, kk).x;\n    }\n    return normalize(n);\n#endif    \n    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 phongColor(in vec3 p, in vec3 rd){\n    \n    vec3 Ks = vec3(1.0); // specular reflected intensity\n    float shininess = 80.0;\n    \n    vec3 n = calcNormal(p, 0.01);\n    vec3 ref = reflect( rd, n );\n    vec3 final = vec3(0);\n    \n\n    // light 0\n\t{\n\t\tvec3 light_pos   = p+vec3( -1.0, 1.0, 0.0 );\n\t\tvec3 light_color = vec3( 1.0, 1.0, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - p );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n        specular = pow( specular, vec3( shininess ) );\n\t\tfinal += light_color * specular; \n\t}\n    return final;\n}\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\nconst float MAX_TRACE_DISTANCE = 11.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.009;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 50;\nconst float EPS_NORMAL = 0.01;\nconst float SCALE_DIST = 0.9;\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    vec4 kk;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t , kk);\n        h = m.x;\n        t += h*SCALE_DIST;\n        id = m.y;\n    }\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    return vec2( res , id );\n}\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n  vec3 c = vec3(0);\n  if( res.y > -.5 ){\n      vec3 pos = ro + rd * res.x;\n      c = phongColor(pos, rd);\n  }\n  return c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\tvec3 ro = vec3(-2,-3,-3.0-time);\n    vec3 ta = vec3( 0.3*sin(time), 0.3*cos(2.0*time) , -time);\n    \n    float aa = 1.0/min(iResolution.y,iResolution.x);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, -1.1);  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy, 4.5+1.5*sin(time)) );\n    \n    // rotate camera with mouse\n\tmat3 rot = rotationXY(iMouse.xy * vec2( 0.01, -0.01 ) );\n    vec3 shift = ro-vec3(-2,-3,-3.0);\n    ro -= shift;\n\trd = rot * rd;\n\tro = rot * ro;\n    ro += shift;\n    \n    vec3 col = vec3(0.05,0.05,0.15);\n    vec3 sp;\n    vec4 mate;\n    \n    // volume rymarching\n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    // Surface distance threshold. Smaller numbers give a sharper object. Antialiased with aa\n    float thD = 0.25*sqrt(aa); \n    \n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n    for(int i=0; i<90; i++)\t{\n        if(layers>100. || col.g>1.0 || t>11.) break;\n        sp = ro + rd*t;\n        d = map(sp, mate).x; // Distance to nearest point in the cube field.\n        // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d))/thD;\n        // If we're within the surface threshold, accumulate some color.\n        if(aD>0.) { \n            vec3 tc = mate.rgb*pow(mate.a,2.0);\n            col += 5.0*tc*(aD*aD*(3. - 2.*aD)/(1. + t*t*.2));\n            layers += 30.0*pow(mate.a+0.2,2.0);\n        }\n        t += max(abs(d)*0.7, thD*0.7); \n\t}\n\n    // standard raymarching code to color the surface\n    vec2 res = calcIntersection( ro , rd  );\n    vec3 surfaceColor = render(res, ro, rd);\n    col += surfaceColor;\n    \n    \n    col = clamp(col, 0.0,1.0);\n    // post processing\n    col = pow(col,vec3(0.7,0.85,1.0));\n    // iq's vignetting\n \tvec2 q = fragCoord/iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.3 );\n\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n }\n","name":"Image","description":"","type":"image"}]}