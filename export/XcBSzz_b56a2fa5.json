{"ver":"0.1","info":{"id":"XcBSzz","date":"1705949973","viewed":123,"name":"Mandelbrot Set Renderer","username":"Brainn","description":"Renders the Mandelbrot fractal.\n\nIf the aspect ratio of the display region does not match that of the screen it will result in the image getting stretched.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","render","staticimage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//display region\nconst float X_MIN = -0.743649; //-2.\nconst float X_MAX = -0.743637; //1.\nconst float Y_MIN = 0.131822125; //-0.84375\nconst float Y_MAX = 0.131828875; //0.84375\n\nconst int MAX_ITERATIONS = 1000; //250\nconst int samples = 8;\n\n//Convert [0, 1] range to a custom range\nfloat convertRange(float value, float min, float max) {\n    return min + (max - min) * value;\n}\n\n//Get pseudorandom number between 0 and 1\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//Complex number opearations\nfloat complexAbs(vec2 c) {\n    return sqrt((c.x * c.x) + (c.y * c.y));\n}\n\nvec2 complexMultiply(vec2 z1, vec2 z2) {\n    return vec2(z1.x * z2.x - z1.y * z2.y, z1.x * z2.y + z1.y * z2.x);\n}\n\n//Interpolate between two vec3s\nvec3 smoothstepVec3(vec3 a, vec3 b, float t) {\n    vec3 result;\n    result.x = (smoothstep(0.0f, 1.0f, t) * (b.x - a.x) + a.x);\n    result.y = (smoothstep(0.0f, 1.0f, t) * (b.y - a.y) + a.y);\n    result.z = (smoothstep(0.0f, 1.0f, t) * (b.z - a.z) + a.z);\n    return result;\n}\n\n//Gradient for pretty colors! :o\nvec3 gradient(float value) {\n    if (value < 0.16f) {\n        return smoothstepVec3(vec3(0, 7, 100), vec3(32, 107, 203), value / 0.16f);\n    } else if (value < 0.42f) {\n        return smoothstepVec3(vec3(32, 107, 203), vec3(237, 255, 255), (value - 0.16f) / 0.26f);\n    } else if (value < 0.6425f) {\n        return smoothstepVec3(vec3(237, 255, 255), vec3(255, 170, 0), (value - 0.42f) / 0.2225f);\n    } else if (value < 0.8575f) {\n        return smoothstepVec3(vec3(255, 170, 0), vec3(0, 2, 0), (value - 0.6425f) / 0.215f);\n    } else {\n        return vec3(0, 2, 0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Get the size that each pixel represents\n    vec2 p = 1.0 / iResolution.xy;\n    \n    //Define float to calculate the average samples for the current pixel (when multi-sampling)\n    float avr_iterations = 0.0;\n    \n    //Loop over all samples for the current pixel\n    for (int s = 0; s < samples; s++) {\n        //Add random sample offset (when multi-sampling)\n        vec2 o = vec2(0., 0.);\n        if (samples != 1) {\n            o = (rand(uv.xy) - 0.5) * p;\n        }\n\n        //UV coordinates converted to display region\n        vec2 c = vec2(convertRange(uv.x + o.x, X_MIN, X_MAX), convertRange(uv.y + o.y, Y_MIN, Y_MAX));\n        \n        //Mandelbrot algorithm\n        vec2 z = vec2(0, 0);\n        int iterations = 0;\n        while(complexAbs(z) < 2.0 && iterations < MAX_ITERATIONS){\n            z = complexMultiply(z, z) + c;\n            iterations++;\n        }\n        \n        //Add sample's iterations\n        avr_iterations += float(iterations);\n    }\n    //Divide iterations by amount of samples to get the average\n    avr_iterations /= float(samples);\n    \n    //Map iterations to gradient color\n    vec3 col = gradient(avr_iterations / float(MAX_ITERATIONS)) / 255.0;\n\n    //Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}