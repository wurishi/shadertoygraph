{"ver":"0.1","info":{"id":"wl2XWD","date":"1565955769","viewed":116,"name":"#Evoke 2019 - Mandelbrot Escape2","username":"VJSpackOMat","description":"example evoke mandelbrot colors taken from iq\n\ndemonstrates normal/interpolating/alternating hybrid variant for 2d escape time","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["evoke2019hybrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Evoke 2019 Example Escape Time Fractals, coloring is taken from iq\n \nconst float BAILOUT = 4.0f;\nconst int MAXITER = 200;\n\n// forward declaration of utility functions\nvec2 c_from_polar(float r, float theta);\nvec2 c_to_polar(vec2 c);\nvec2 c_pow(vec2 c, float e);\n\n\n// Functions\nvec2 frac_func_mandelbrot2(vec2 z,vec2 c)\n{\n    // z = z*z + c\t\t\n    return z = c_pow(z,2.0f) + c;\n}\nvec2 frac_func_mandelbrot3(vec2 z,vec2 c)\n{\n    // z = z*z*z + c\t\t\n    return z = c_pow(z,3.0f) + c;\n}\n// end Functions \n\n// evaluatePoint returns the color for mapped input coordinate\nvec3 evaluatePoint(vec2 p){\n\n    \tvec3 col = vec3(0.0);\n        float Iteration = 0.0;\n\t    vec2 z  = vec2(0.0);\n        vec2 c = p;\n        for( int i=0; i<MAXITER; i++ )\n        {\n    \t\t// normal\n            z = frac_func_mandelbrot2(z,c);\t\n            ///\n            \n    \t\t// interpolate (linear interpolation, other interpolations yield different results\n            // time intensive due to 2 times evaluating of function\n            vec2 z1 = frac_func_mandelbrot2(z,c);\t\t\n    \t\tvec2 z2 = frac_func_mandelbrot3(z,c);\t\t\n    \t\t//z=mix(z1,z2,iMouse.x/iResolution.x);\n            ///\n            \n            // alternate\n            if(i<10){\n             //z = frac_func_mandelbrot2(z,c);\n            }else{\n             //z = frac_func_mandelbrot3(z,c);\n            }\n            ///\n            \n            if( length(z)>(BAILOUT ) ) break;\n    \t\tIteration += 1.0;\n        }    \t \n\n    \t// coloring - map iteqration count to color\n        col += 0.5 + 0.5*cos( 3.0 + Iteration*0.15 + vec3(0.0,0.6,1.0));\n    return col;\n}\n\n// shadertoy entry point\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // map coordinaste\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n     \n    fragColor =   vec4( evaluatePoint(p*2.0f), 1.0 );\n}\n\n\n// Helper Mat\n// forward defined functions implemented here\nvec2 c_from_polar(float r, float theta) {\n  return vec2(r * cos(theta), r * sin(theta));\n}\n\nvec2 c_to_polar(vec2 c) {\n  return vec2(length(c), atan(c.y, c.x));\n}\n/// Raises `c` to a floating point power `e`.\nvec2 c_pow(vec2 c, float e) {\n  vec2 p = c_to_polar(c);\n  return c_from_polar(pow(p.x, e), p.y*e);\n}\n// End Helper Math\n","name":"Image","description":"","type":"image"}]}