{"ver":"0.1","info":{"id":"4ttGzB","date":"1470052247","viewed":642,"name":"015 2d shadow","username":"kakaxizhhgjh","description":"2d shadow, inspired by https://www.shadertoy.com/view/4dfXDn\ncannot understand source code,  so use my shadow function instead. effect not good as original, thare are some artificial, so any improve please let me know.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2dshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float opU(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\nfloat opI(float d1, float d2) {\n\treturn max(d1, d2);\n}\n\nfloat opS(float d1, float d2) {\n\treturn max(d1, -d2);\n}\n\nfloat circle(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat ring(vec2 p, float r, float thick) {\n\treturn abs(circle(p, r)) - thick;\n}\n\nfloat pie(vec2 p, float angle) {\n    return dot(vec2(abs(p.x), p.y), vec2(cos(angle), sin(angle)));\n}\n\nfloat arc(vec2 p, float r, float thick, float angle) {\n\treturn opS(ring(p, r, thick), pie(p, angle));\n}\n\nfloat round_box(vec2 p, vec2 d, float r) {\n\tp = abs(p) - d;\n    return min(max(p.x,p.y),0.0) + length(max(p,0.0)) - r;\n}\n\nfloat line_segment(vec2 p, vec2 a, vec2 b, float r) {\n\tvec2 ab = b - a;\n    vec2 ap = p - a;\n    return length(ap - ab * clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0)) - r;\n}\n\n// triangle's sdf comes form iq's https://www.shadertoy.com/view/XsXSz4\n// it use perp dot product to decide whether p inside or outside of triangle\n// more info: http://mathworld.wolfram.com/PerpDotProduct.html\n// vector's perpendicular has two directions below or above\n// choose direction according to triangle's ccw or cw\n// so in this implementation, a, b, c must be given ccw\n\nfloat perp_dot(vec2 a, vec2 b) {\n\treturn dot(vec2(-a.y, a.x), b);\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n\tvec2 ab = b - a, bc = c - b, ca = a - c;\n    vec2 ap = p - a, bp = p - b, cp = p - c;\n    vec2 pab = ap - ab * clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0);\n    vec2 pbc = bp - bc * clamp(dot(bc, bp) / dot(bc, bc), 0.0, 1.0);\n    vec2 pca = cp - ca * clamp(dot(ca, cp) / dot(ca, ca), 0.0, 1.0);\n    \n    vec2 d = min(min(\n        vec2(dot(pab, pab), perp_dot(ab, ap)),\n    \tvec2(dot(pbc, pbc), perp_dot(bc, bp))),\n        vec2(dot(pca, pca), perp_dot(ca, cp)));\n    \n    return -sqrt(d.x) * sign(d.y);\n}\n\nmat2 ccw(float a) {\n    float ca = cos(a);\n    float sa = sin(a);\n\treturn mat2(ca, sa, -sa, ca);\n}\n\nfloat map(vec2 p) {\n    float d = circle(p - vec2(-1.3, 0.45), 0.25);\n    d = opU(d, ring(p - vec2(-0.6, 0.45), 0.22, 0.04));\n    d = opU(d, round_box(p - vec2(0.1, 0.45), vec2(0.2), 0.05));\n    d = opU(d, line_segment(p - vec2(0.8, 0.45), vec2(-0.2), vec2(0.2), 0.05));\n    d = opU(d, triangle(p - vec2(1.3, 0.45), vec2(-0.25), vec2(0.25, -0.25), vec2(0.0, 0.25)));\n    \n    d = opU(d, opS(\n        circle(p - vec2(-1.3, -0.45), 0.25),\n        round_box(p - vec2(-1.3, -0.45 + 0.25 * sin(iTime * 3.0)), vec2(0.3, 0.1), 0.0)));\n    \n    d = opU(d, opI(\n        circle(p - vec2(-0.6, -0.45), 0.25),\n    \tround_box(p - vec2(-0.6, -0.45 + 0.25 * sin(iTime * 3.0)), vec2(0.3, 0.1), 0.0)));\n    \n    d = opU(d, opU(\n        circle(p - vec2(0.1, -0.45), 0.25),\n    \tround_box(p - vec2(0.1, -0.45 + 0.25 * sin(iTime * 3.0)), vec2(0.3, 0.1), 0.0)));\n    \n    d = opU(d, triangle((p - vec2(0.8, -0.45)) * ccw(iTime),\n        vec2(-0.2165, -0.125), vec2(0.2165, -0.125), vec2(0.0, 0.25)));\n    \n    d = opU(d, arc(p - vec2(1.3, -0.45), 0.2, 0.03, 0.6));\n    \n    return d;\n}\n\nfloat plot_edge(float d) {\n\treturn smoothstep(3.0 / iResolution.y, 0.0, abs(d));\n}\n\nfloat plot_solid(float d) {\n\treturn smoothstep(3.0 / iResolution.y, 0.0, max(0.0, d));\n}\n\nvec3 shadow(vec2 ro, vec2 mo) {\n    vec2 rd = normalize(mo - ro);\n    for(int i = 0; i < 48; ++i) {\n        float d = map(ro);\n        float tmax = length(mo - ro);\n        if(d > tmax) return vec3(0.2);\n        if(d < 0.01) return vec3(0.0);\n        ro += d * rd;\n    }\n    return vec3(0.2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mo = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 bg = vec3(0.5) * (1.0 - length(uv) * 0.3);\n    bg *= clamp(min(mod(fragCoord.x, 20.0), mod(fragCoord.y, 20.0)), 0.9, 1.0);\n    bg = mix(bg, vec3(1.0), plot_solid(circle(uv - vec2(mo), 0.06)));\n    bg += shadow(uv, mo);\n    \n    float d = map(uv);\n    bg = mix(bg, vec3(1.0, 0.4, 0.0), plot_solid(d));\n    bg = mix(bg, vec3(0.0), plot_edge(d));\n    \n\tfragColor = vec4(bg, 1.0);\n}","name":"Image","description":"","type":"image"}]}