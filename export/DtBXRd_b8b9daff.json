{"ver":"0.1","info":{"id":"DtBXRd","date":"1676432979","viewed":134,"name":"Lonely rocket","username":"ianertson","description":"A lonely rocket traveling through space.\nUse the mouse to look around :)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raymarch","space","rocket","rocket"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SMOKE_STEPS 32\n#define SMOKE_STEPSIZE 0.3\n\n#define NEAR 0.003\n#define FAR 70.0\n#define STEPS 96\n\n#define DEBUG 0\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_SHIP 2\n#define ID_SHIP_HEAD 3\n#define ID_SHIP_THRUST 4\n#define ID_SHIP_PANEL 5\n\n#define R iResolution.xy\n#define T (iTime*0.5)\n\n#define ZERO (min(0, int(iTime)))\n#define adot(a, b) (abs(dot(a, b)))\n#define rgb(a, b, c) (vec3(a, b, c) / 255.0)\n\n#define SUN_COLOR0 rgb(238, 118, 0)\n#define SUN_COLOR1 rgb(247, 181, 69)\n#define SUN_COLOR2 rgb(179, 41, 0)\n\nfloat artifact(vec2 uv, vec2 pp, vec2 res, float r, float pwr, float mx) {\n  float d = distance(uv, pp);\n  float a = pwr / (0.1 + (d * res.y));\n\n  r = max(0.001, r - d);\n  float f = r * 0.09;\n\n  float b = max(0.0, 1.0 - smoothstep(r - f, r + f, d));\n\n  return mix(a, b, mx);\n}\n\nvec3 lensFlare(vec2 uv, vec3 L, vec3 ro, vec3 rd, vec2 res) {\n  float VdotL = max(0.0, dot(rd, L));\n\n  if (VdotL <= 0.0)\n    return vec3(0.0);\n\n  vec3 p = L;\n\n  vec2 pp = p.xy / (p.z * FAR);\n\n  pp = (pp.xy - 0.5 / res.xy) * res.y;\n\n  vec3 col = vec3(0.0);\n\n  float flare1 = artifact(uv + (pp * 0.5), pp, res, 0.3, VdotL,\n                          0.01); // VdotL / (0.1+(distance(uv, pp)*res.y));\n  float flare2 = artifact(uv + (pp * 0.7), pp, res, 0.2, VdotL, 0.01);\n  float flare3 = artifact(uv + (pp * 0.89), pp, res, 0.02, VdotL, 0.01);\n\n  float flare = flare1 + flare2 + flare3;\n\n  col += flare; // * pow(VdotL, 16.0);\n\n  return col;\n}\n\nvec3 mulm4(vec3 v, mat4 m) { return (vec4(v, 1.0) * m).xyz; }\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n  vec3 lookAt = point;\n  float zoom = 1.;\n  vec3 camForward = normalize(lookAt - ro);\n  vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n  vec3 camUp = -cross(camRight, camForward);\n  vec3 screenCenter = ro + camForward * zoom;\n  vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n  return normalize(screenIntersection - ro);\n}\n\nfloat noise21(vec2 p, float freq) {\n  float div = 0.0;\n  float amp = 1.0;\n  float n = 0.0;\n  n += amp * textureLod(iChannel2, (p * freq) / 256., 0.).r;\n  div += amp;\n  amp /= 2.0;\n  freq *= 2.0;\n  n += amp * textureLod(iChannel2, (p * freq) / 256., 0.).r;\n  div += amp;\n  amp /= 2.0;\n  freq *= 2.0;\n  n += amp * textureLod(iChannel2, (p * freq) / 256., 0.).r;\n  div += amp;\n  amp /= 2.0;\n  freq *= 2.0;\n  n += amp * textureLod(iChannel2, (p * freq) / 256., 0.).r;\n  div += amp;\n  amp /= 2.0;\n  freq *= 2.0;\n  return n / div;\n}\n\nvec3 noise23(vec2 p, float freq) {\n  float div = 0.0;\n  float amp = 1.0;\n  vec3 n = vec3(0.0);\n  n += amp * textureLod(iChannel3, (p * freq) / 256., 0.).rgb;\n  div += amp;\n  amp /= 2.0;\n  freq *= 2.0;\n  n += amp * textureLod(iChannel3, (p * freq) / 256., 0.).rgb;\n  div += amp;\n  amp /= 2.0;\n  freq *= 2.0;\n  n += amp * textureLod(iChannel3, (p * freq) / 256., 0.).rgb;\n  div += amp;\n  amp /= 2.0;\n  freq *= 2.0;\n  n += amp * textureLod(iChannel3, (p * freq) / 256., 0.).rgb;\n  div += amp;\n  amp /= 2.0;\n  freq *= 2.0;\n  return n / div;\n}\n\nvec3 noise33Signed(vec3 p, float freq, float seed) {\n  vec3 a = texNoise(iChannel3, p, freq, seed, vec2(0.0)) * 2.0 - 1.0;\n  vec3 b = texNoise(iChannel3, p, freq, seed + 4.9185, vec2(0.0));\n  return cross(a, b);\n}\n\nmat2 rot(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, s, -s, c);\n}\n\nfloat circle(vec2 uv, vec2 p, float r, float f) {\n  return max(0.0, 1.0 - smoothstep(r - f, r + f, distance(uv, p)));\n}\n\nstruct Transform {\n  vec3 p;\n  vec4 r;\n};\n\n#define NEW_TRANSFORM Transform(vec3(0.0), vec4(0.0))\n\nstruct Data {\n  vec3 p;\n  vec3 n;\n  vec2 uv;\n  vec2 uvSp;\n  float d;\n  int id;\n  int skip;\n  float rough;\n  vec3 spec;\n  Transform t;\n};\n\n#define NEW_DATA                                                               \\\n  Data(vec3(0.0), vec3(0.0), vec2(0.0), vec2(0.0), FAR, 0, 0, 1.0, vec3(0.1),  \\\n       NEW_TRANSFORM)\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n\nstruct Light {\n  vec3 p;\n  vec3 c;\n  float s;\n  int type;\n};\n\nvec3 getLightDir(in Light light, vec3 p) {\n  switch (light.type) {\n  case LIGHT_AMBIENT:\n    return normalize(light.p);\n    break;\n  case LIGHT_POINT:\n    return normalize(light.p - p);\n    break;\n  }\n  return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, vec3 p, vec3 n) {\n  vec3 L = getLightDir(light, p);\n  float NdotL = max(0.002, dot(n, L));\n\n  switch (light.type) {\n  case LIGHT_AMBIENT: {\n    return light.c * light.s * NdotL;\n  } break;\n  case LIGHT_POINT: {\n    float d = distance(light.p, p);\n    float a = pow(light.s, 2.0) / max(0.0001, pow(d, 2.0));\n    return light.c * NdotL * a;\n  }; break;\n  }\n\n  return vec3(0.0);\n}\n\n#define SAMPLE(var, tra, id_)                                                  \\\n  if (id_ != data.skip && var < dist) {                                        \\\n    data.id = id_;                                                             \\\n    data.t = tra;                                                              \\\n    dist = var;                                                                \\\n  }\n\nfloat coneSDF(vec3 p, vec2 c, float h, float taper) {\n\n  p.y += h;\n  vec3 a = vec3(0, 0., 0);\n  vec3 b = vec3(0, 1, 0);\n\n  float r = 1.;\n\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  float y = (abs(t - 0.5) - 0.5) * length(ab);\n\n  vec3 c2 = a + t * ab;\n  float x = length(p - c2) - r;\n\n  float e = length(max(vec2(x, y), 0.0));\n  float i = min(max(x, y), 0.0);\n\n  float q = length(p.xz);\n\n  float d = dot(c, vec2(q, -p.y));\n\n  d += y;\n  d /= 2.;\n\n  float slice = -(p.y - h);\n  d = max(d, slice);\n\n  float sp = length(vec3(p.x, p.y - h, p.z)) - h;\n\n  d = mix(d, sp, abs(p.y - h) * taper);\n\n  return d;\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  vec3 c = a + t * ab;\n  float x = length(p - c) - r;\n  float y = (abs(t - 0.5) - 0.5) * length(ab);\n  float e = length(max(vec2(x, y), 0.0));\n  float i = min(max(x, y), 0.0);\n  return e + i;\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n  p = abs(p) - s;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat groundSDF(vec3 p) { return p.y; }\n\n#define SHIP_POS                                                               \\\n  vec3(0. + sin(T) * 0.5, 2. + cos(T) * 2., sin(T + 3.01915) * 0.25)\n#define SHIP_ROT vec4(T, (0.05 * cos(T + (2.0 * sin(T * 2.)))), -1.9, 0.0)\n\nfloat shipSDF(vec3 p, in int skip, inout int part, inout Transform trans) {\n  trans = Transform(SHIP_POS, SHIP_ROT);\n\n  // m *= vec4(SHIP_POS, 1.0);\n  //  trans.p.yx *= rot(trans.r.z);\n  // trans.p.yz *= rot(trans.r.y);\n\n#if DEBUG != 1\n  p -= trans.p * 0.5; //*0.5;\n  p.yx *= rot(trans.r.z);\n  p.yz *= rot(trans.r.y);\n  p.xz *= rot(trans.r.x);\n  p += trans.p * 0.5;\n#endif\n\n  part = ID_SHIP;\n  float dist = FAR;\n\n  float body = cylinderSDF(p, vec3(0, -0.5, 0), vec3(0, 1.5, 0), 0.5);\n  float head = coneSDF(p - vec3(0, 1.4, 0.), vec2(0.5, 0.5), 1.4, 0.17);\n\n  float thrust1 = cylinderSDF(p - vec3(0.3, -0.2, 0), vec3(0, 0, 0),\n                              vec3(0, -0.5, 0), 0.16);\n  float thrust2 = cylinderSDF(p - vec3(-0.3, -0.2, 0), vec3(0, 0, 0),\n                              vec3(0, -0.5, 0), 0.16);\n  float thrust3 = cylinderSDF(p - vec3(0.0, -0.2, 0.3), vec3(0, 0, 0),\n                              vec3(0, -0.5, 0), 0.16);\n  float thrust4 = cylinderSDF(p - vec3(0.0, -0.2, -0.3), vec3(0, 0, 0),\n                              vec3(0, -0.5, 0), 0.16);\n\n  float panelW = 0.3;\n  float panelH = 0.5;\n  float panel = boxSDF(p - vec3(0, 0.6, -0.38), vec3(panelW, panelH, 0.16));\n\n  if (body < dist && skip != ID_SHIP) {\n    dist = body;\n  }\n  if (head < dist && skip != ID_SHIP_HEAD) {\n    dist = head;\n    part = ID_SHIP_HEAD;\n  }\n  if (thrust1 < dist && skip != ID_SHIP_THRUST) {\n    dist = thrust1;\n    part = ID_SHIP_THRUST;\n  }\n  if (thrust2 < dist && skip != ID_SHIP_THRUST) {\n    dist = thrust2;\n    part = ID_SHIP_THRUST;\n  }\n  if (thrust3 < dist && skip != ID_SHIP_THRUST) {\n    dist = thrust3;\n    part = ID_SHIP_THRUST;\n  }\n  if (thrust4 < dist && skip != ID_SHIP_THRUST) {\n    dist = thrust4;\n    part = ID_SHIP_THRUST;\n  }\n  if (panel < dist && skip != ID_SHIP_PANEL) {\n    dist = panel;\n    part = ID_SHIP_PANEL;\n  }\n\n  return dist;\n}\n\nfloat getDist(inout Data data, vec3 p) {\n  float dist = FAR;\n\n  // float ground = groundSDF(p);\n  int shipPart = 0;\n  Transform shipTrans;\n  float ship = shipSDF(p, data.skip, shipPart, shipTrans);\n\n  // SAMPLE(ground, ID_GROUND);\n  SAMPLE(ship, shipTrans, shipPart);\n\n  return dist;\n}\n\nvec3 getNormal(inout Data data, vec3 p) {\n  vec2 e = vec2(0.001, 0.0);\n\n  return normalize(getDist(data, p) - vec3(getDist(data, p - e.xyy),\n                                           getDist(data, p - e.yxy),\n                                           getDist(data, p - e.yyx)));\n}\n\nvec2 getUv(inout Data data, vec3 p) {\n  vec3 n = data.n;\n  vec2 uv = vec2(0.0);\n\n  Transform t = data.t;\n\n#if DEBUG != 1\n  if (data.id == ID_SHIP || data.id == ID_SHIP_THRUST ||\n      data.id == ID_SHIP_HEAD || data.id == ID_SHIP_PANEL) {\n    vec3 pos = SHIP_POS;\n    vec4 rota = SHIP_ROT;\n    p -= pos * 0.5; //*0.5;\n    p.yx *= rot(rota.z);\n    p.yz *= rot(rota.y);\n    p.xz *= rot(rota.x);\n    p += pos * 0.5;\n\n    n.yx *= rot(rota.z);\n    n.yz *= rot(rota.y);\n    n.xz *= rot(rota.x);\n  }\n#endif\n\n  data.uvSp = sphereUv(p);\n  // p = mulm4(p, t.m);\n  // n = mulm4(n, t.m);\n\n  uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n  uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n  uv = mix(uv, p.yz, adot(n, vec3(1, 0, 0)));\n  return uv;\n}\n\nbool march(inout Data data, vec3 ro, vec3 rd) {\n  float dist = 0.0;\n\n  for (int i = ZERO; i < STEPS; i++) {\n    vec3 p = ro + rd * dist;\n    float next = getDist(data, p);\n    dist += next;\n    if (abs(next) <= NEAR)\n      break;\n    if (abs(dist) >= FAR)\n      return false;\n  }\n\n  dist = abs(dist);\n  vec3 p = ro + rd * dist;\n  data.p = p;\n  data.d = dist;\n  data.n = getNormal(data, p);\n  data.uv = getUv(data, p);\n\n  return true;\n}\n\nfloat smokeSDF(vec3 p, in Light light, inout vec3 col) {\n  vec3 norm = normalize(p);\n  \n  \n \n  light.c = dullen(light.c, 0.3*clamp(pow(distance(p, light.p), 4.0), 0.0, 1.6));\n  vec3 att = getLightAtt(light, p, -norm);\n  att = max(vec3(0.16), att);\n\n  \n  vec3 region = noise33Signed(p + (2.*vec3(sin(T*0.5), cos(T*0.5), cos(T*0.5))), 0.01, 34.2915);\n // p += region*0.1;\n  float reg = region.r;\n  \n  float t = ((reg + T+(region.y*8.)) * (0.5 + (reg*0.0001)))*2.;\n\n  vec3 shift = (vec3(-t, cos(t), sin(t + 7.8191)) + region)*2.;\n  vec3 n = noise33Signed(p + shift, M_PI, 1.2915);\n\n  float radius = 1.0;\n  vec3 spherePos = -SHIP_POS * 0.5;\n\n vec4 shipRot = SHIP_ROT;\n\n  spherePos += vec3(0, -1.7, 0);\n\n   spherePos.xz *= inverse(rot(shipRot.x));\n  spherePos.yz *= inverse(rot(shipRot.y));\n  spherePos.yx *= inverse(rot(shipRot.z));\n \n  \n\n  spherePos += SHIP_POS * 0.5;\n  float d = (dot(normalize(p), n));\n  \n  d -= ((n.y*0.5)+(reg*0.5))*6.;\n  d += region.x*1.3;\n\n  radius += d;\n  //radius *= 0.68;\n  radius = max(0.0001, radius);\n  \n  //radius = max(0.01, radius*(0.5+(p.x*2.)));\n  p.y *= 1.1;\n  p.x *= 0.8;\n  \n\n  radius = max(0.001, radius);\n  float sp = length(p - spherePos) - radius;\n  sp -= (region.y*2.0-1.0)/2.2;\n  sp += n.x*3.;\n  sp = max(sp, -(p.x-0.5));\n  sp += length(p.xz)*0.01;\n  \n  \n // d = max(d, sp);\n  col += abs(d * att) / (1.0+abs(p.x)*2.);\n // col += luma(col)/M_PI;\n col = pow(col, vec3(2.0));\n\n  return sp;\n}\n\nvec3 renderSmoke(vec3 ro, vec3 rd, float far, in Light light) {\n  float dist = 0.0;\n  vec3 col = vec3(0.0);\n  int c = 0;\n\n  for (int i = ZERO; i < SMOKE_STEPS; i++) {\n    vec3 p = ro + (rd * dist * SMOKE_STEPSIZE);\n\n    vec3 nextCol = vec3(0.0);\n    float next = smokeSDF(p, light, nextCol);\n    col += nextCol;\n    dist += next;\n    c += 1;\n\n    if (abs(dist) >= min(far, FAR))\n      break;\n  }\n\n  if (abs(dist) >= min(far, FAR))\n    return vec3(0.0);\n\n  col *= dist / float(c);\n  return col / float(c);\n}\n\nvec3 getSunTexture(vec2 uv) {\n  float region = noise21(uv, 0.09);\n\n  float t = (T + (region * 6.)) * (0.5 + (region * 0.003));\n  uv += vec2(cos(t), sin(t)) * 4.;\n\n  vec3 col = vec3(0.0);\n\n  vec3 c0 = SUN_COLOR0;\n  vec3 c1 = SUN_COLOR1;\n  vec3 c2 = SUN_COLOR2;\n\n  vec3 n = noise23(uv, 0.5);\n\n  col = mix(col, c0, n.x);\n  col = mix(col, c1, n.y);\n  col = mix(col, c2, n.z);\n\n  col /= vec3(0.5) + col;\n  col += 0.2;\n\n  return col;\n}\n\nvec3 getSky(vec3 ro, vec3 rd, in Light light) {\n //   return texture(iChannel0, rd).xyz;\n  vec3 col = vec3(0.005);\n  vec3 L = normalize(light.p);\n  vec2 skyUv = sphereUv(rd);\n  \n  vec3 gs = vec3(cos(T*0.1), sin(T*0.1), sin((T*0.1)+9.21583));\n  vec3 galaxy = texNoise(iChannel3, rd + gs, 2.6, 7.29195, vec2(0.0));\n  float jr = textureLod(iChannel2, (skyUv*8.) + sphereUv(gs), 0.0).r;\n  jr = pow(jr, 8.0)*2.;\n  galaxy *= max(0.0, 1.0 - jr);\n  galaxy = pow(galaxy, vec3(16.0))*9.;\n  galaxy += jr*galaxy;\n  galaxy = mix(galaxy, vec3(1.0), luma(galaxy)*2.);\n  col += galaxy;\n\n  float stars0 = textureLod(iChannel2, skyUv * 4., 0.0).r;\n\n  float stars1 =\n      textureLod(iChannel2,\n                 0.6 * ((skyUv + vec2(cos(T * 0.005), sin(T * 0.005))) +\n                        vec2(0.291, -0.001123)),\n                 0.0)\n          .r;\n  stars0 *= (0.1 + stars1);\n\n  stars0 = pow(stars0, 24.0);\n\n  col += stars0;\n\n  vec2 lightUv = sphereUv(L);\n\n  float n =\n      noise21((skyUv + (lightUv * 60.)) + vec2(cos(T * .2), sin(T * 0.2)), 2.3);\n  n = n;\n\n  float r = 0.1;\n  r *= mix(1.3, 0.7, n);\n\n  float sun = circle(skyUv, lightUv, r, 0.01);\n  float shade = circle(skyUv, lightUv, r, 0.1);\n  shade = smoothstep(1.4, 0.33, shade);\n\n  vec3 sunTex = getSunTexture(skyUv * 128.);\n  sunTex = mix(sunTex, vec3(0.0), shade);\n\n  col += sunTex * sun * light.c;\n\n  return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n  vec2 uv = data.uv;\n\n  return texture(iChannel3, uv).rgb;\n}\n\nvec3 metalTexture(vec2 uv, inout float rough, inout vec3 spec) {\n  vec3 col = vec3(0.0);\n  float base = texture(iChannel2, uv).r;\n  float vary = texture(iChannel2, (uv * 0.2) + 3.87271).r;\n  float region = noise21((uv * 2.) + 9., 4.1);\n  float invRegion = noise21((uv * 2.) + 3.921, 4.1);\n  region = pow(region, 4.0);\n  invRegion = max(0.0, invRegion - region * 2.);\n  float overlap = abs(region - invRegion);\n  float scratches = max(0.0, 1.0 - smoothstep(0.09, overlap, 1.));\n\n  scratches += scratches * pow(vary, 2.0) * 9.;\n\n  vec3 c1 = rgb(198, 202, 205);\n  vec3 c2 = rgb(81, 81, 81);\n  vec3 c3 = rgb(52, 50, 53);\n  vec3 c4 = rgb(163, 165, 166);\n\n  col += base / TAU;\n  col += region * c1 / M_PI;\n  col += c2 * invRegion / M_PI;\n  col += c4 * scratches / (TAU * 3.);\n  col += vary * region;\n  col = dullen(col, 0.3);\n  col += col / 2.;\n\n  rough = max(0.0001, base - scratches);\n  spec = c1 * region;\n\n  // col += region;\n  return clamp(col, 0.0, 1.0);\n}\n\nvec3 getAlbedoShip(inout Data data) {\n  vec3 col = metalTexture(data.uv, data.rough, data.spec);\n  \n  float e = 0.03;\n  vec3 n = normalize(luma(col) - vec3(\n      luma(metalTexture(data.uv + vec2(e, 0), data.rough, data.spec)),\n      luma(metalTexture(data.uv + vec2(e, e), data.rough, data.spec)),\n      0.5\n  ));\n  \n  n = n * -1.;\n  data.n = normalize(mix(data.n, n, clamp(max(0.0, dot(n, data.n)), 0.0, 1.0)));\n\n  return col;\n}\n\nvec3 getAlbedoThruster(inout Data data) {\n  vec2 uv = data.uv;\n  vec3 col = texture(iChannel1, uv).rgb;\n\n  col = pow(col, vec3(2.0));\n  col /= 2.0;\n  \n  data.spec = vec3(1.0);\n  data.rough = 0.0;\n\n  return col;\n}\n\nvec3 getAlbedoHead(inout Data data) {\n  vec2 uv = data.uvSp;\n\n  uv *= 16.0;\n  vec2 id = floor(uv);\n  vec2 lv = fract(uv);\n\n  float g = 1.0 - ceil(min(lv.x, lv.y) - 0.1);\n\n  vec3 col = texture(iChannel1, uv).rgb;\n\n  col = pow(col, vec3(2.0));\n  col /= 2.0;\n  col = dullen(col, 0.3);\n\n  float n = texture(iChannel2, uv * 0.01).r;\n\n  n = pow(n, 3.0);\n  col += (g * 0.5) * n;\n  \n  data.rough = 1.0;\n  data.spec = vec3(1.0);\n\n  return col;\n}\n\nvec3 getAlbedoPanel(inout Data data) {\n  vec3 col = vec3(0.0);\n  vec2 uv = data.uv * 8.;\n  vec2 id = floor(uv);\n  vec2 lv = fract(uv);\n\n  vec3 baseColor = rgb(0, 19, 82);\n\n  float g = 1.0 - ceil(min(lv.x, lv.y) - 0.1);\n\n  col += baseColor;\n  col += g;\n\n  data.spec = vec3(1.0);\n  data.rough = 0.0;\n\n  return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n  switch (data.id) {\n  case ID_GROUND:\n    return getAlbedoGround(data);\n    break;\n  case ID_SHIP:\n    return getAlbedoShip(data);\n    break;\n  case ID_SHIP_THRUST:\n    return getAlbedoThruster(data);\n    break;\n  case ID_SHIP_HEAD:\n    return getAlbedoHead(data);\n    break;\n  case ID_SHIP_PANEL:\n    return getAlbedoPanel(data);\n    break;\n  }\n\n  return vec3(0.48);\n}\n\n#define NUM_LIGHTS 2\n\nvec3 forEachLight(inout Data data, in Light light, vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  vec3 p = data.p;\n  vec3 L = getLightDir(light, p);\n  vec3 albedo = getAlbedo(data);\n  vec3 diffuse = albedo / M_PI;\n  vec3 n = data.n;\n  vec3 att = getLightAtt(light, p, n);\n  vec3 ref = reflect(L, n);\n  float VdotR = max(0.0, dot(rd, ref));\n  vec3 spec = max(0.0, 1.0 - data.rough) * data.spec * (mix(vec3(light.c), SUN_COLOR1, pow(VdotR, 8.)) *\n                           pow(VdotR, 32.));\n\n  col += (diffuse + spec) * att;\n  \n\n  return col;\n}\n\nvec3 render(inout Data data, vec2 uv, vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  Light lights[NUM_LIGHTS];\n\n  vec3 shipLightPos = -SHIP_POS * 0.5;\n  vec4 shipRot = SHIP_ROT;\n  vec3 lightTrans = vec3(0.0, -1., 0.);\n  // lightTrans.yx *= inverse(rot(shipRot.z));\n  shipLightPos += lightTrans;\n  shipLightPos.yz *= inverse(rot(shipRot.y));\n  shipLightPos.yx *= inverse(rot(shipRot.z));\n\n  // shipLightPos -= lightTrans;\n\n  shipLightPos += SHIP_POS * 0.5;\n  // shipLightPos += -lightTrans;\n\n  lights[0] = Light(vec3(1, 1, 3), vec3(0.97, 0.90, 0.79), 2.0, LIGHT_AMBIENT);\n  lights[1] = Light(shipLightPos, vec3(1, 0, 0), 4.0, LIGHT_POINT);\n\n  bool hit = false;\n\n  float hitDist = FAR;\n  \n  float rough = 0.0;\n  \n  float primDist = FAR;\n  \n  for (int j = ZERO; j < 2; j++) {\n    bool nextHit = march(data, ro, rd);\n    if (j <= 0) { primDist = data.d; }\n    \n    hit = hit || nextHit;\n    hitDist = min(hitDist, data.d);\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n      Light light = lights[i];\n\n      if (nextHit) {\n          col += (forEachLight(data, light, ro, rd) / (1.0 + float(j))) * max(0.0, 1.0 - rough);\n          \n         \n          rough = data.rough;\n          \n        //  if (data.rough <= 0.0 && j > 0) {\n          //    col = nextCol;\n           //   break;\n         // }\n      }\n      if (light.type == LIGHT_POINT) {\n        vec3 L = normalize(light.p - ro);\n        float VdotL = max(0.0, dot(rd, L));\n        float k = max(0.0, 1.0 - smoothstep(5., 7.2, hitDist));\n        col += ((pow(VdotL, 256.) * light.c * light.s) * max(0.0, 1.0 - k)) / M_PI;\n      }\n    }\n    \n    if (!nextHit) {\n        col += getSky(ro, rd, lights[0]) * max(0.0, 1.0 - rough);\n        break;\n    }\n    \n    ro = data.p;\n    rd = reflect(rd, data.n);\n    data.skip = data.id;\n    rough = data.rough;\n    \n\n  }\n\n  Light light = lights[0];\n\n\n  vec3 L = normalize(light.p);\n  float VdotL = max(0.0, dot(rd, L));\n\n  float k = max(0.0, 1.0 - smoothstep(5., 7.2, hitDist));\n\n  float pwr = pow(VdotL, 2.0);\n  col += (pow(pwr, 8.0) * mix(SUN_COLOR1, SUN_COLOR2, pwr * 1.2)) *\n         max(0.0, 1.0 - k);\n\n\n  vec3 smoke = renderSmoke(ro, rd, hitDist, lights[1]);\n // if (smokeDist < primDist) {\n      //col = mix(col, smoke, clamp(length(smoke), 0.0, 1.6));\n      col += smoke;\n // }\n\n  L = -normalize(ro - (light.p));\n  vec3 flare = lensFlare(uv, L, ro, rd, R);\n\n  col += (flare * VdotL * SUN_COLOR2)*4.;\n\n  return col;\n}\n\nvoid getRay(vec2 uv, vec2 m, inout vec3 ro, inout vec3 rd) {\n  ro = vec3(0, 1., -5.0);\n  rd = normalize(vec3(uv.xy, 1.0));\n\n#if DEBUG == 1\n  if (iMouse.x > 0.01) {\n#else\n  if (iMouse.z > 0.01) {\n#endif\n    \n\n    ro.yz *= rot(m.y * TAU);\n    ro.xz *= rot(m.x * TAU);\n\n    rd.yz *= rot(m.y * TAU);\n    rd.xz *= rot(m.x * TAU);\n\n    // ro += pos*0.25;\n    //  rd = look(uv, SHIP_POS + vec3(0, -1., 0), ro);\n  } else {\n    vec3 pos = SHIP_POS + vec3(0, 6, 0);\n    ro.xz *= rot(T * 0.5);\n    \n    //ro = mix(ro, pos, 0.4*(0.5+(0.5*cos(T*0.5))));\n    rd = look(uv, SHIP_POS + vec3(0, -1., 0), ro);\n  }\n\n  ro.y = max(0.2, ro.y);\n}\n\nvoid mainImage(out vec4 O, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc - 0.5 * R.xy) / R.y;\n  vec2 m = (iMouse.xy - 0.5 * R.xy) / R.y;\n\n  Data data = NEW_DATA;\n  vec3 ro = vec3(0.0);\n  vec3 rd = vec3(0.0);\n  getRay(uv, m, ro, rd);\n  col += render(data, uv, ro, rd);\n\n  col += luma(col) / M_PI;\n  col += (col * luma(col)) / M_PI;\n\n  col /= vec3(1.0) + col;\n  col = pow(col, vec3(1.0 / 2.2));\n\n  O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n\nvec3 texHash33(sampler2D ch, vec3 p, float div, float seed, vec2 lod) {\n    return textureLod(ch, (vec2(p.x, p.y) +\n        div*(textureLod(ch, (vec2((p.y*p.z), p.z)+seed)/div, lod.x).xy*2.0-1.0))/div, lod.y).xyz;\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float seed, vec2 lod) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n\n    float div = 256.0;//vec2(textureSize(tex, 0).xy).y;\n\n    return mix(\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 0), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 0), div, seed, lod), lv.x),\n          lv.y),\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 1), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 1), div, seed, lod), lv.x),\n          lv.y),\n        lv.z\n    );\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float freq, float seed, vec2 lod) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    return n / div;\n}\n\n\nvec3 dullen(vec3 c, float amnt) {\n    vec3 dull = c / M_PI;\n    dull += 1.0 / M_PI;\n    return mix(c, dull, amnt);\n}\n\n\nvec2 sphereUv(vec3 p) {\n    vec2 uv = vec2(0.0);\n    uv.y = acos(p.x);\n    uv.x = atan(p.y, p.z);\n    uv = uv * 2.0 - 1.0;\n    uv.x = 0.5 + uv.x / (M_PI);\n    uv.y = 0.5 - uv.y / M_PI;\n    return uv;\n}\n\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\n\n\n\n","name":"Common","description":"","type":"common"}]}