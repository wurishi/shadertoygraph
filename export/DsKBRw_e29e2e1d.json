{"ver":"0.1","info":{"id":"DsKBRw","date":"1698670947","viewed":55,"name":"Documented Wave Equation Sim","username":"MarshmallowFellow","description":"A simulation of the Wave Equation;\n often used to model the movement of waves like sound, light and the surface of liquids. \nIt is able to demonstrate features of waves such as constructive and destructive interference.\nnow with normals!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["wave","simulation","interactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nall the fun things to fiddle with are in Buffer C\nBuffer A and B are used as memory, simply copying the buffer to the right of them\nThis pass is just used to convert the wave height to something on the screen\n\nRed is positive pressure and blue is negative though within the shader blue is just 0 and red is 1\n*/\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    float height = float(texture(iChannel0, uv));\n    \n    float normalStrength = .3;\n    \n    vec3 normals = HeightToNormals(iChannel0, 5, uv, iResolution);    \n    //fetch the texture with the normals applied as an offset to the UV    \n    vec3 col = vec3(texture(iChannel1, uv - vec2(normals.x, normals.y) * normalStrength)); \n    \n    // Swap these to get either pressure (red/blue) or distorted texture  ^ v\n    \n    /*\n     vec3 col = mix(vec3(0,0,1), vec3(1.,0,0), height) * abs(height - 0.5);\n     col = mix(col, vec3(1.,1.,1.), max(0., abs(height -.5) -.5 ) );\n    */\n    \n    \n    \n    //fragColor = vec4(vec3(texture(iChannel0, uv)),1.0);  \n    \n    // swap these to see the height values instead of the red/blue values\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//just copies buffer B\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(vec3(texture(iChannel0, uv) ), 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//just copies buffer C\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(vec3(texture(iChannel0, uv) ), 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//set these to change the effect\n\nfloat waveInitHeight = 1.; //height of wave created when clicked.  can be greater than 1 and negative\nfloat waveInitSize = 6.; // radius of click in pixels\n\nfloat springiness = .994; \n// this needs to be slightly under 1.  1 is perfect springiness, it'll go up to 1 and back\n// at lower values it'll spring past 0 and bounce back and forth until it settles\n// the lower the value the more it'll bounce back and forth\n// at 1 it also won't lose energy and settle to 0 across the board\n\nfloat waveSpeed = .6; // higher numbers can cause instability\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // handy data about screen\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pixelSize = 1./iResolution.xy;\n    \n    //generate mouse interaction\n    float waveInit = (1. - min(1., float(length(abs(fragCoord - iMouse.zw)) / waveInitSize))) * waveInitHeight;\n    \n    //actual math\n    float velocity = ( float(texture(iChannel1, uv)) - float(texture(iChannel0, uv)) ) * iTimeDelta;\n    \n    \n    \n    //The Wave Equation\n    fragColor = vec4( vec3\n    (\n        ((2. * float(texture(iChannel1, uv)) - float(texture(iChannel0, uv)) + \n        pow(waveSpeed, 2.) * \n        (\n            float(texture(iChannel1, uv + vec2(0., pixelSize.y))) + // 1 pixel up\n            float(texture(iChannel1, uv - vec2(0., pixelSize.y))) + // 1 pixel down\n            float(texture(iChannel1, uv + vec2(pixelSize.x, 0.))) + // 1 pixel right\n            float(texture(iChannel1, uv - vec2(pixelSize.x, 0.))) - // 1 pixel left\n            4. * float(texture(iChannel1, uv))\n        ) + waveInit - .5) * springiness) + .5\n    ), 1.);\n    \n    if(iFrame < 5) fragColor = vec4(vec3(0.5), 1.);\n    \n    fragColor =  abs(fragCoord.x - 200.0) < 10.0 && abs(fragCoord.y  - iResolution.y/2.0) > 10.0 ? vec4(vec3(0.5), 1.0) : fragColor;\n    \n    \n    float dist = 20.0 - distance(fragCoord, vec2( 100, iResolution.y/2.0) );\n    fragColor = vec4(vec3(max(dist * float(sin(iTime) > 0.95) * 0.65, float(fragColor)) ), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//best used with only a few iterations\nvec3 HeightToNormals(in sampler2D tex, int iterations, vec2 UV, vec3 resolution)\n{\n    vec3 _tempTexture = vec3(texture(tex, UV));\n    vec3 sum = vec3(0);\n    \n    vec2 pixelSize = vec2(1) / vec2(resolution);\n    \n    for (int i = 0; i < iterations; i++)\n    {\n        float weight =  pow(1. - (1./float(iterations) * float(i)), 3.);\n        sum.x -=(vec3( texture( tex, UV + vec2(pixelSize.x * float(i + 1), 0))) - _tempTexture).x * weight;\n        sum.x +=(vec3( texture( tex, UV + vec2(pixelSize.x * float(0 - i - 1), 0))) - _tempTexture).x * weight;\n\n        sum.y -=(vec3( texture( tex, UV + vec2(0, pixelSize.y * float(i + 1)))) - _tempTexture).x * weight;\n        sum.y +=(vec3( texture( tex, UV + vec2(0, pixelSize.y * float(0 - i - 1)))) - _tempTexture).x * weight;\n\n    }\n    sum *= 0.5;\n    sum += 0.5;\n\n    return sum + vec3(0,0, distance(vec3(0), sum));\n}","name":"Common","description":"","type":"common"}]}