{"ver":"0.1","info":{"id":"wdlBRS","date":"1588575056","viewed":376,"name":"Pacific Ocean","username":"pajunen","description":"Extension of my previous shader.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["ocean","sky","model","analytic","hosek","hosekwilkie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implementation of 2012 Hosek-Wilkie skylight model\n\n#define M_PI 3.1415926535897932384626433832795\n#define M_PI_2 1.57079632679\n#define CIE_X 0\n#define CIE_Y 1\n#define CIE_Z 2\n\nfloat sample_coeff(int channel, int quintic_coeff, int coeff) {    \n    int index =  6 * coeff + quintic_coeff;\n    if (channel == CIE_X) {HOSEK_COEFF_X}\n    if (channel == CIE_Y) {HOSEK_COEFF_Y}\n    if (channel == CIE_Z) {HOSEK_COEFF_Z}\n}\n\nfloat sample_radiance(int channel, int quintic_coeff) {\n    int index = quintic_coeff;\n    if (channel == CIE_X) {HOSEK_RAD_X}\n    if (channel == CIE_Y) {HOSEK_RAD_Y}\n    if (channel == CIE_Z) {HOSEK_RAD_Z}\n}\n\nfloat eval_quintic_bezier(in float[6] control_points, float t) {\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\tfloat t4 = t3 * t;\n\tfloat t5 = t4 * t;\n\t\n\tfloat t_inv = 1.0 - t;\n\tfloat t_inv2 = t_inv * t_inv;\n\tfloat t_inv3 = t_inv2 * t_inv;\n\tfloat t_inv4 = t_inv3 * t_inv;\n\tfloat t_inv5 = t_inv4 * t_inv;\n\t\t\n\treturn (\n\t\tcontrol_points[0] *             t_inv5 +\n\t\tcontrol_points[1] *  5.0 * t  * t_inv4 +\n\t\tcontrol_points[2] * 10.0 * t2 * t_inv3 +\n\t\tcontrol_points[3] * 10.0 * t3 * t_inv2 +\n\t\tcontrol_points[4] *  5.0 * t4 * t_inv  +\n\t\tcontrol_points[5] *        t5\n\t);\n}\n\nfloat transform_sun_zenith(float sun_zenith) {\n\tfloat elevation = M_PI / 2.0 - sun_zenith;\n\t\treturn pow(elevation / (M_PI / 2.0), 0.333333);\n}\n\nvoid get_control_points(int channel, int coeff, out float[6] control_points) {\n\tfor (int i = 0; i < 6; ++i) control_points[i] = sample_coeff(channel, i, coeff);\n}\n\nvoid get_control_points_radiance(int channel, out float[6] control_points) {\n\tfor (int i = 0; i < 6; ++i) control_points[i] = sample_radiance(channel, i);\n}\n\nvoid get_coeffs(int channel, float sun_zenith, out float[9] coeffs) {\n\tfloat t = transform_sun_zenith(sun_zenith);\n\tfor (int i = 0; i < 9; ++i) {\n\t\tfloat control_points[6]; \n\t\tget_control_points(channel, i, control_points);\n\t\tcoeffs[i] = eval_quintic_bezier(control_points, t);\n\t}\n}\n\nvec3 mean_spectral_radiance(float sun_zenith) {\n\tvec3 spectral_radiance;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfloat control_points[6];\n        get_control_points_radiance(i, control_points);\n\t\tfloat t = transform_sun_zenith(sun_zenith);\n\t\tspectral_radiance[i] = eval_quintic_bezier(control_points, t);\n\t}\n\treturn spectral_radiance;\n}\n\nfloat F(float theta, float gamma, in float[9] coeffs) {\n\tfloat A = coeffs[0];\n\tfloat B = coeffs[1];\n\tfloat C = coeffs[2];\n\tfloat D = coeffs[3];\n\tfloat E = coeffs[4];\n\tfloat F = coeffs[5];\n\tfloat G = coeffs[6];\n\tfloat H = coeffs[8];\n\tfloat I = coeffs[7];\n\tfloat chi = (1.0 + pow(cos(gamma), 2.0)) / pow(1.0 + H*H - 2.0 * H * cos(gamma), 1.5);\n\t\n\treturn (\n\t\t(1.0 + A * exp(B / (cos(theta) + 0.01))) *\n\t\t(C + D * exp(E * gamma) + F * pow(cos(gamma), 2.0) + G * chi + I * sqrt(cos(theta)))\n\t);\n}\n\nvec3 spectral_radiance(float theta, float gamma, float sun_zenith) {\n\tvec3 XYZ;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfloat coeffs[9];\n\t\tget_coeffs(i, sun_zenith, coeffs);\n\t\tXYZ[i] = F(theta, gamma, coeffs);\n\t}\n\treturn XYZ;\n}\n\n// Returns angle between two directions defined by zentih and azimuth angles\nfloat angle(float z1, float a1, float z2, float a2) {\n\treturn acos(\n\t\tsin(z1) * cos(a1) * sin(z2) * cos(a2) +\n\t\tsin(z1) * sin(a1) * sin(z2) * sin(a2) +\n\t\tcos(z1) * cos(z2));\n}\n\n// Sky is rendered using Hosek-Wilkie skylight model\nvec3 sample_sky(float view_zenith, float view_azimuth, float sun_zenith, float sun_azimuth) {    \n\tfloat gamma = angle(view_zenith, view_azimuth, sun_zenith, sun_azimuth);\n\tfloat theta = view_zenith;   \n   \tvec3 mean_sr = mean_spectral_radiance(sun_zenith);\n    float sun_angular_radius = M_PI / 360.0; // About 0.5 deg\n    \n    if (gamma > sun_angular_radius) {\n\t\treturn spectral_radiance(theta, gamma, sun_zenith) * mean_sr;\n    } else {\n     \treturn vec3(100.0,100.0,100.0);\n    }\n}\n\n// CIE-XYZ to linear RGB\nvec3 XYZ_to_RGB(vec3 XYZ) {\n\tmat3 XYZ_to_linear = mat3(\n\t\t 3.24096994, -0.96924364, 0.55630080,\n\t\t-1.53738318,  1.8759675, -0.20397696,\n\t\t-0.49861076,  0.04155506, 1.05697151\n\t);\n\treturn XYZ_to_linear * XYZ;\n}\n\n// Clamps color between 0 and 1 smoothly\nvec3 expose(vec3 color, float exposure) {\n\treturn vec3(2.0) / (vec3(1.0) + exp(-exposure * color)) - vec3(1.0);\n}\n\nvec2 to_zenith_azimuth(vec3 v) {\n \tfloat zenith = acos(v.y);\n    float azimuth = atan(v.x, v.z);\n    return vec2(zenith, azimuth);\n}\n\nmat3 rotationX( in float angle ) {\n\treturn mat3(\t1.0,\t\t     0,\t\t\t  0,\n\t\t\t \t\t  0, \tcos(angle),\t-sin(angle),\n\t\t\t\t\t  0, \tsin(angle),\t cos(angle));\n}\n\nmat3 rotationY( in float angle ) {\n\treturn mat3(\tcos(angle),\t\t0,\t\tsin(angle),\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle));\n}\n\nmat3 rotationZ( in float angle ) {\n\treturn mat3(\tcos(angle),\t\t-sin(angle),\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1);\n}\n\nvec3 fresnel_schlick(float cosTheta, vec3 F0)\n{\n    return F0 + (max(vec3(1.0), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tvec2 uv    = (fragCoord -0.5 * iResolution.xy) / iResolution.y;\n\tvec2 mouse = (iMouse.xy) / iResolution.y;\n\n\tfloat mouse_angle = atan(mouse.x, mouse.y);\n\n\tfloat pixel_angle = atan(uv.x,uv.y);\n\tfloat pixel_distance =  length(uv) * M_PI;\n    \n    float sun_speed = 0.3;\n    \n    vec3 sun_dir = vec3(0.,0.,1.) * rotationX(-mod((iTime*sun_speed + 12.5) / 5.0, M_PI)) * rotationZ(0.) * rotationY(M_PI);\n\n    vec2 sun_pos = to_zenith_azimuth(sun_dir);\n    \n    vec3 sample_point = normalize(vec3(uv.xy, 0.5));\n    mat3 rot = rotationY(-mouse.x * M_PI) * rotationX(mouse.y * M_PI / 2.0 + M_PI / 9.0);\n\tvec3 sample_dir = rot * sample_point;\n    \n    vec3 fresnel = vec3(1.0);\n    if (sample_dir.y < 0.0) {\n        // Intersection point with water\n        float x0 = tan(acos(sample_dir.y)) / 0.5;\n        \n        // Generate water surface normal\n\t\tfloat N_theta = ((sin(x0) + 1.) / 2.0) * 0.1 * (1.0 / ((x0*.15)*(x0*.15) + 1.0));\n\t\tfloat N_gamma = iTime + x0;\n        float sin_N_theta = sin(N_theta);\n        float sin_N_gamma = sin(N_gamma);\n        float cos_N_theta = cos(N_theta);\n        float cos_N_gamma = cos(N_gamma);\n\t\tvec3 N = vec3(sin_N_theta * cos_N_gamma, cos_N_theta, sin_N_theta * sin_N_gamma);\n        \n        // New sample direction\n\t\tsample_dir = reflect(sample_dir, N);\n        if (sample_dir.y < 0.0) sample_dir.y *= -1.;\n\n        // Eval fresnel\n        float cos_theta = max(dot(N, sample_dir), 0.0);\n        fresnel = fresnel_schlick(cos_theta, vec3(0.04));\n    }\n    \n    vec2 view_zenith_azimuth = to_zenith_azimuth(sample_dir);\n    \n    vec3 XYZ = fresnel * sample_sky(view_zenith_azimuth.x, view_zenith_azimuth.y, sun_pos.x, sun_pos.y);  \n\tvec3 RGB = XYZ_to_RGB(XYZ);\n\n\tvec3 col = expose(RGB, 0.1);\n\t\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define HOSEK_RAD_X if (index < 3) { if (index < 1) { return 1.471043; } else { if (index < 2) { return 1.746088; } else { return -0.929970; } } } else { if (index < 4) { return 17.203620; } else { if (index < 5) { return 5.473384; } else { return 8.336416; } } }\n#define HOSEK_RAD_Y if (index < 3) { if (index < 1) { return 1.522034; } else { if (index < 2) { return 1.844545; } else { return -1.322862; } } } else { if (index < 4) { return 19.183820; } else { if (index < 5) { return 5.440769; } else { return 8.837119; } } }\n#define HOSEK_RAD_Z if (index < 3) { if (index < 1) { return 1.107408; } else { if (index < 2) { return 2.382765; } else { return -5.112357; } } } else { if (index < 4) { return 21.478230; } else { if (index < 5) { return 14.931280; } else { return 14.608820; } } }\n#define HOSEK_COEFF_X if (index < 27) { if (index < 13) { if (index < 6) { if (index < 3) { if (index < 1) { return -1.129483; } else { if (index < 2) { return -1.146420; } else { return -1.128348; } } } else { if (index < 4) { return -1.025820; } else { if (index < 5) { return -1.083957; } else { return -1.062465; } } } } else { if (index < 9) { if (index < 7) { return -0.189062; } else { if (index < 8) { return -0.188358; } else { return -0.264130; } } } else { if (index < 11) { if (index < 10) { return 0.014047; } else { return -0.260668; } } else { if (index < 12) { return -0.151219; } else { return -9.065101; } } } } } else { if (index < 20) { if (index < 16) { if (index < 14) { return 3.309173; } else { if (index < 15) { return 1.223176; } else { return -1.187406; } } } else { if (index < 18) { if (index < 17) { return 2.207108; } else { return 1.042881; } } else { if (index < 19) { return 9.659923; } else { return -3.127882; } } } } else { if (index < 23) { if (index < 21) { return 0.055150; } else { if (index < 22) { return 2.729900; } else { return -7.202803; } } } else { if (index < 25) { if (index < 24) { return 14.278390; } else { return -0.036078; } } else { if (index < 26) { return -0.069382; } else { return -0.349065; } } } } } } else { if (index < 40) { if (index < 33) { if (index < 30) { if (index < 28) { return 0.587759; } else { if (index < 29) { return -5.968103; } else { return -4.242214; } } } else { if (index < 31) { return 0.831436; } else { if (index < 32) { return 0.398711; } else { return 1.997784; } } } } else { if (index < 36) { if (index < 34) { return -0.276114; } else { if (index < 35) { return 2.129455; } else { return 0.403810; } } } else { if (index < 38) { if (index < 37) { return 0.081817; } else { return 0.140058; } } else { if (index < 39) { return -0.041237; } else { return 0.460263; } } } } } else { if (index < 47) { if (index < 43) { if (index < 41) { return -0.077895; } else { if (index < 42) { return 0.199778; } else { return 4.768868; } } } else { if (index < 45) { if (index < 44) { return 6.283042; } else { return -2.251251; } } else { if (index < 46) { return 8.305125; } else { return -1.137688; } } } } else { if (index < 50) { if (index < 48) { return 2.814449; } else { if (index < 49) { return 0.633978; } else { return 0.526708; } } } else { if (index < 52) { if (index < 51) { return 0.948347; } else { return 0.394500; } } else { if (index < 53) { return 0.887177; } else { return 0.580320; } } } } } }\n#define HOSEK_COEFF_Y if (index < 27) { if (index < 13) { if (index < 6) { if (index < 3) { if (index < 1) { return -1.144464; } else { if (index < 2) { return -1.170104; } else { return -1.129171; } } } else { if (index < 4) { return -1.042294; } else { if (index < 5) { return -1.082293; } else { return -1.071715; } } } } else { if (index < 9) { if (index < 7) { return -0.204380; } else { if (index < 8) { return -0.211863; } else { return -0.255288; } } } else { if (index < 11) { if (index < 10) { return 0.004450; } else { return -0.272306; } } else { if (index < 12) { return -0.142657; } else { return -10.201880; } } } } } else { if (index < 20) { if (index < 16) { if (index < 14) { return 4.391405; } else { if (index < 15) { return 0.223830; } else { return -0.511603; } } } else { if (index < 18) { if (index < 17) { return 2.065076; } else { return 1.095351; } } else { if (index < 19) { return 10.712470; } else { return -4.198900; } } } } else { if (index < 23) { if (index < 21) { return 0.731429; } else { if (index < 22) { return 2.627589; } else { return -8.143133; } } } else { if (index < 25) { if (index < 24) { return 17.297830; } else { return -0.032567; } } else { if (index < 26) { return -0.071116; } else { return -0.356273; } } } } } } else { if (index < 40) { if (index < 33) { if (index < 30) { if (index < 28) { return 0.609900; } else { if (index < 29) { return -7.892212; } else { return -3.851931; } } } else { if (index < 31) { return 0.786021; } else { if (index < 32) { return 0.389044; } else { return 1.881931; } } } } else { if (index < 36) { if (index < 34) { return -0.126464; } else { if (index < 35) { return 2.142231; } else { return 0.436051; } } } else { if (index < 38) { if (index < 37) { return 0.068727; } else { return 0.102483; } } else { if (index < 39) { return -0.030787; } else { return 0.432528; } } } } } else { if (index < 47) { if (index < 43) { if (index < 41) { return -0.071062; } else { if (index < 42) { return 0.211444; } else { return 4.824771; } } } else { if (index < 45) { if (index < 44) { return 6.282535; } else { return -1.039120; } } else { if (index < 46) { return 7.080503; } else { return -1.122398; } } } } else { if (index < 50) { if (index < 48) { return 2.970832; } else { if (index < 49) { return 0.625984; } else { return 0.536569; } } } else { if (index < 52) { if (index < 51) { return 0.909630; } else { return 0.458365; } } else { if (index < 53) { return 0.833851; } else { return 0.594439; } } } } } }\n#define HOSEK_COEFF_Z if (index < 27) { if (index < 13) { if (index < 6) { if (index < 3) { if (index < 1) { return -1.353023; } else { if (index < 2) { return -1.624704; } else { return -0.798361; } } } else { if (index < 4) { return -1.266679; } else { if (index < 5) { return -1.009707; } else { return -1.075646; } } } } else { if (index < 9) { if (index < 7) { return -0.481352; } else { if (index < 8) { return -0.799020; } else { return 0.141748; } } } else { if (index < 11) { if (index < 10) { return -0.428898; } else { return -0.153775; } } else { if (index < 12) { return -0.176875; } else { return -31.049200; } } } } } else { if (index < 20) { if (index < 16) { if (index < 14) { return -21.671250; } else { if (index < 15) { return 9.914841; } else { return -5.818701; } } } else { if (index < 18) { if (index < 17) { return 3.496378; } else { return -1.347762; } } else { if (index < 19) { return 31.401560; } else { return 22.463410; } } } } else { if (index < 23) { if (index < 21) { return -10.815030; } else { if (index < 22) { return 6.986437; } else { return -3.013726; } } } else { if (index < 25) { if (index < 24) { return 1.989004; } else { return -0.009511; } } else { if (index < 26) { return -0.011635; } else { return -0.012188; } } } } } } else { if (index < 40) { if (index < 33) { if (index < 30) { if (index < 28) { return -0.081807; } else { if (index < 29) { return 0.242115; } else { return 0.013758; } } } else { if (index < 31) { return 0.554203; } else { if (index < 32) { return 0.541575; } else { return 0.341139; } } } } else { if (index < 36) { if (index < 34) { return 1.397403; } else { if (index < 35) { return -0.283193; } else { return 1.764810; } } } else { if (index < 38) { if (index < 37) { return 0.008135; } else { return 0.026184; } } else { if (index < 39) { return -0.061377; } else { return 0.201692; } } } } } else { if (index < 47) { if (index < 43) { if (index < 41) { return 0.030034; } else { if (index < 42) { return 0.133002; } else { return 3.136646; } } } else { if (index < 45) { if (index < 44) { return 1.139214; } else { return 7.445848; } } else { if (index < 46) { return -1.275731; } else { return 3.702862; } } } } else { if (index < 50) { if (index < 48) { return 3.230864; } else { if (index < 49) { return 0.521599; } else { return 0.344436; } } } else { if (index < 52) { if (index < 51) { return 1.180080; } else { return 0.259277; } } else { if (index < 53) { return 0.774632; } else { return 0.662621; } } } } } }\n","name":"Common","description":"","type":"common"}]}