{"ver":"0.1","info":{"id":"tdjBzW","date":"1589726050","viewed":439,"name":"Biker 2D","username":"spalmer","description":"an extreme simplification of the classic game Excitebike's style of gameplay, or maybe Trials?  spacebar to accelerate, L&R arrows lean, space resets when \"wrecked\"","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["game","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Biker 2D by spalmer\n\n// fork of Glitter Confetti 2D, (private) https://shadertoy.com/view/wttSWN\n// one of these days I'll get that to actually work like I wanted, hopefully!\n\n// jorge2017a1 gave me an idea,\n// I mean I have been wanting to\n// port Excitebike for a long time,\n// just never got around to it.\n// I will try!\n// This is first playable prototype, enjoy lol\n// Currently more like a simplified Trials than Excitebike  :(\n// TODO maybe an isometric-rendered version\n// TODO with opponents! competitor bikes :) auto-piloted by AI! lol\n// The AI (blue bike) currently only runs when mouse is at origin for \"attract\" mode in thumbnails\n// TODO time limit (just shows current iDate.w currently)\n// TODO choose tracks\n// TODO parallax fore/background objects?\n// original had hay bales and cameramen,\n// final flag-waver at finish line,\n// and a crowd stand in the background.\n// TODO boost button, overheating\n// TODO boost pads\n// TODO mud puddles\n\n#define BufA iChannel0\n#define Font iChannel3\n\nconst float cscale = .5;\n\n\n#if 1 // numeric display based on https://shadertoy.com/view/llySRh\n// using font in iChannel1; otherwise I'd put it in Common\nfloat char(vec2 p, int c)\n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.)\n        return 0.;\n    vec2 q = p/16. + fract(vec2(c, 15-c/16) / 16.);\n    vec4 t = textureLod(Font, q, 0.);\n    // probably not perfect but seems ok\n    float scale = 64./(1.+dot(fwidth(q), vec2(1))); //(abs(dFdx(q.x))+abs(dFdy(q.y))); //length(fwidth(p)); //\n    scale = clamp(scale, 1./1024., 1024.);\n    float g = t.a; // a unorm-encoded signed distance\n    g = .5 - (g - .5) * scale; // antialiasing\n    g = clamp(g, 0., 1.);\n    return g;\n}\n    //float w = scale/16.;// /iResolution.y; //.05; //\n    //g = clamp(.5 - 1./w * (t.w-.5), 0., 1.); //\n    //g = smoothstep(.5+w,.5-w, t.w); // aa sdf - could probably do pixel perfect with a bit more effort\n    //g = clamp(.5 - (t.w - .5) * 8./scale; // yeah but we need scale info, maybe do the scaling here?\n\n// display unsigned int up to 4 digits base 10\nfloat pUint(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n); i > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    if (abs(n) < 1e-7)\n        v += char(p, 48);\n    return v;\n}\n\n// display unsigned int 4 digits base 10\nfloat pUint4(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n), d = 4; d-- > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    return v;\n}\n#endif\n\nmat3x3 bikeFrame() \n{\n    vec4  p0 = getParticle(BufA, 0)\n        , p1 = getParticle(BufA, 1)\n        , p2 = getParticle(BufA, 2)\n        ;\n    vec2  d = (p2 - p1).xy;\n    d = normalize(d);\n    // HACK for now I'm just gonna ignore\n    // the swapping of the power wheels\n    // and just fix the bike frame visuals\n    // if bike wheels get inverted somehow\n    // actually now it just resets the game,\n    // so no longer matters, won't be drawn.\n    vec2 a = d;\n    if (pdot(d, (p0 - p1).xy) < 0.) // determinant()\n        d = -d;\n    mat3x3 frame;\n    frame = mat3x3(\n          vec3(d, 0)\n        , vec3(-d.y,d.x, 0) // perp d\n        , vec3(p0.xy + a * .02, 1)\n        );\n    return frame;\n}\n\nfloat dframe(vec2 q)\n{\n    float d0 = length(q - vec2(.007,-.04)) - .034\n       ,  d1 = dseg(q - vec2(-.09,-.1), vec2(.08,.08)) - .01\n       ,  d2 = dseg(q - vec2(-.09,-.1 ), vec2(.1,.04)) - .01\n       ,  d3 = dseg(q - vec2(.04,-.04), vec2(.06,-.06)) - .01\n       ,  d = min(min(d0, d1), min(d2, d3));\n    return d;\n}\nconst float cplx = .98;\n// \"clouds\" parallax scrolling background\n// this is just the mask for the cloud texture in iChannel2\nfloat dcloud(vec2 q, vec2 parallax)\n{\n    q -= cplx*parallax; // parallax adjust\n    q.x /= 2.;  // stretch\n    q *= cscale;\n    if (q.y < .0) return 99.;\n    return (length(.5-fract(q)) - .0) / cscale;\n}\n\n// terrain \"surface\" rendering - sky/ground color\nvec3 drawRamps(float d)\n{\n    vec2 R = iResolution.xy;\n    float g = .5-.5*cos(d * R.y * .5);\n    g = 1.; // no lines\n\tvec3 c = d < 0. ? vec3(.25,.25,.1) : vec3(.2,.5,.8);\n    c *= g;\n    //c *= 1.-exp2(-.5*iResolution.y * abs(d));\n    c = mix(c, vec3(.6,.4,.2), exp2(-.5*iResolution.y * abs(d)));\n    return c;\n}\n    //g = mix(1., g, exp2(-128.*abs(d))); // isolines\n\n// draws particles\nvec4 drawParticle(vec2 p, int i, vec2 q, vec2 v)\n{\n    float r = wheelradius\n    , d = distance(p, q) - r\n    ;\n    if (i != 0) d = abs(d + .5*tirethick) - .5*tirethick;\n    vec4 c = i == 0 ? vec4(1,1,0,1) : vec4(.1,.1,.1,1.);\n    c *= clamp(.5 - .125*iResolution.y * d, 0., 1.);\n    return c;\n}\n    //(cos(vec3(0,2,4) + float(i>>1) * 66.) * .5 + .5);\n\nvec4 drawBike(vec2 q)\n{\n    vec4 c = vec4(0);\n    for (int i = 0; i < nparticles; ++i) {\n    \tvec4 d = getParticle(BufA, i);\n        c = max(c, drawParticle(q, i, d.xy, d.zw));\n    }\n    mat3x3 mframe = bikeFrame()\n    , iframe = inverse(mframe); // probably cheaper ways to accomplish this btw\n    float dfr = dframe((iframe * vec3(q,1)).xy);\n    float framecov = clamp(.5-iResolution.y/2.*dfr, 0., 1.);\n    vec4 cbike = isAttract(iMouse) ? vec4(.1,.1,.5,1) : vec4(.5,.1,.1,1);\n    vec4 cframe = cbike * framecov;\n    c = c * (1. - cframe.a) + cframe; // proper premultiplied alpha blend\n    return c;\n}\n\nfloat dflag(vec2 q, float parallax)\n{\n    const float pm = 2.; // parallax mul\n\tq.x += pm*parallax; // seems closer though\n    q.x += -.5*pm;\n    q.y -= .55;\n    q.x = mod(q.x, 10.*pm); // same distance as used for score increments TODO merge constants\n    q.x -= 5.*pm;\n//    q *= parallax; \n    return dseg(q - vec2(0, -.7), vec2(0, .4)) - 1./iResolution.y; // just a pole for now\n}\n\nvec4 drawTrack(vec2 q, vec2 parallax)\n{\n    float dtr = dtrack(q);\n    float BGS = .6;\n    vec2 qbg = q - .96 * parallax;\n    float dmt = .25 + qbg.y * 3. - fbm1(qbg.x / BGS) / BGS; //lnoise1(q.x * BGS, (q.y * -BGS + .2)) / -BGS; //dtrack(q * .1); // + parallax?\n    vec3 ctrack = drawRamps(dtr);\n    //vec3 ctrackbg = drawRamps(dmt + 5.5);\n    if (dtr < 0.) \n        ctrack *= mix(vec3(1),\n            texture(iChannel1, q * 2.).rgb\n            , exp2(4.*dtr));\n    else if (dmt < -0.1)\n        ctrack = mix(ctrack, vec3(.3,.5,.2), .2); // ugly mountains :)\n    float dfl = dflag(q, mix(parallax.x, 1., .5));\n    float flagcov = clamp(.5 - dfl * 2., 0., 1.);\n    vec3 cflag = isAttract(iMouse) ? vec3(.4,.4,1.) : vec3(.4,1.,.4);\n    ctrack = mix(ctrack, cflag, flagcov); // green flagpoles\n    // TODO parallax flags, crowd?, 2.5D view\n    float dcl = dcloud(q, parallax) -.3;\n    float cloudcov = clamp(.5 - dcl * 2., 0., 1.);\n    // meh, better than nothing I guess\n    cloudcov *= texture(iChannel2, (q - cplx*parallax)/3.).x;\n    ctrack = mix(ctrack, vec3(1), cloudcov);\n\treturn vec4(ctrack, 1);\n}\n//    ctrack = vec3(ntrack(q) * .5 + .5, 0); // * vec3(1,0,0); // debug track normals\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy, q = StoQ(p, R);\n    vec4 body = getParticle(BufA, 0);  // particle 0 is the main body\n\tvec2 parallax = body.xy; // attach camera to bike\n    parallax.y *= .5; // only partially vertical\n    parallax.y += .5;\n    parallax.x += .5;\n    q += parallax;\n    vec4 cbike = drawBike(q)\n      , ctrack = drawTrack(q, parallax);\n    c = ctrack;\n    // FIXME yeah but all the other bike frame blends are wrong too\n    c = c * (1.-cbike.a) + cbike; //c.rgb = mix(c.rgb, cbike.rgb, cbike.a); // FIXME blend wrong for premultiplied alpha DOH just extinct&add\n    vec4 ui = vec4(0);\n    //float timer = mod(iDate.w, 1000.); // HACK\n    float score = round(max(0., body.x / 10.));\n    ui += vec4(.2,1,.2,1) * pUint((p - R/vec2(6,8)) * 6./R.y, float(score)); //timer));\n    c = max(c, ui); //c = mix(c, vec4(ui.rgb, 1), ui.a); //\n    c = vec4(pow(c.rgb, vec3(1./2.2)),1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// TODO need some leaning controls; gas alone isn't enough - sort of in now, needs work.\n// TODO some artificial forces to help balance, especially when jumping.\n// TODO stb suggests just \"staying wrecked\" and pressing a button to right the bike;\n// should just store a \"wrecked\" flag in the state and wait for keypress, then just fix the bike and keep going.\n// could even make a button-pressing mini-game out of it!\n// TODO if in \"attract mode\", maybe should automatically gas it periodically?\n// FIXME if the reset kick or hard landing manages to invert the particle triangle,\n// the front wheel becomes the drive wheel! must detect inverted coordinate frame\n// currently just resets the game if it happens!\n// TODO run physics in a loop to handle lower frame rates more gracefully.\n// TODO switch to Verlet integration, or at least leapfrog or implicit Euler\n// FIXME often losing context results in botched state; unsure why resolution pixel test isn't catching it\n    \n#define BufA iChannel0\n#define Kbd  iChannel1\n\n// links table\n// GLSL ES does not like arrays of arrays\nivec2[3] links = ivec2[3] (\n    ivec2(0, 1)\n  , ivec2(0, 2)\n  , ivec2(1, 2)\n);\n\nconst float\n  tension = exp2(8.5)\n, sdamp = .04\n, friction = 6.\n, gravity = 1.5\n, motorpower = 3.\n, leanpower = 1.6\n;\n// FIXME if all spring tension coeffs are the same, why put them in a table?\nvec2[3] linklen = vec2[3] ( // actually length, kspring\n   vec2(.13, tension)\n , vec2(.17, tension)\n , vec2(.2 , tension) \n);\n // TODO mass, color, radius\n\nbool key(int k)\n{\n    return texelFetch(Kbd, ivec2(k,0), 0).x > .5;\n}\n\n// the original had a joystick/dpad for leaning\n// and changing lanes, and a button for acceleration\n// TODO not all features implemented yet\nconst int\n  KEY_SPACE = 32 // accel      - space bar\n, KEY_W     = 87 // lane up    - WASD for qwerty\n, KEY_A     = 65 // lean left\n, KEY_S     = 83 // lane down\n, KEY_D     = 68 // lean right\n, KEY_LEFT  = 37 // lean left  - arrow keys\n, KEY_RIGHT = 39 // lean right\n, KEY_UP    = 38 // lane up\n, KEY_DOWN  = 40 // lane down\n, KEY_ESC   = 27 // reset      - HACK reset bike? TODO\n;\n\n\nvoid FixupFrame(inout vec4 c, int id, vec2 pos)\n{\n  //  float t = float(i);\n    switch (id) {\n        default:\n        case pidBody: c.xy = vec2(  0,.232); break;\n        case pidWheelBack:  c.xy = vec2(-.1,.1); break;\n        case pidWheelFront: c.xy = vec2( .1,.1); break;\n  //      default: c.xy = (vec2(rand(t+iDate.w), rand(t*1.6+iDate.z))*.15+.5) * 2. - 1.; break;\n    }\n    c.xy += pos + vec2(0.,.3); // initial world pos offset to all particles\n    c.zw = vec2(.5,.1); // begin travelling rightward\n}\n\nvoid Init(inout vec4 c, int i, vec2 p)\n{\n    vec2 R = iResolution.xy;\n    c = vec4(0);\n    if (i >= nparticles || int(p.y) > 0) {\n        if (ivec2(p) == ivec2(0,1)) //ivec2(R)-1) //\n            c.xy = R+vec2(.5); // resolution pixel\n        return;\n    }\n\tFixupFrame(c, i, getParticle(BufA, 0).xy);\n}\n\n// the undamped spring was originally iq's from https://shadertoy.com/view/tlyGRR\n// but it's been heavily modified since, added damping!\nvoid Constraint(vec4 pa, vec4 pb, out vec2 f,out vec2 v, float lr, float k)\n{\n    vec2 d = pb.xy-pa.xy; // rel pos\n    vec2 w = pb.zw-pa.zw; // rel vel\n    float ld = length(d);\n    vec2 e = d/max(ld,1e-3); // unit vector aimed at b from a\n    vec2 h = tension * e; //k * e; //\n    f = (ld-lr) * h; // simple undamped spring force\n    f += sdamp * dot(w,e) * h; // damping force (euler integration's unstable without it)\n    v = vec2(0); // no impulse\n}\n    // actual air resistance forces are too detailed for this game\n    //vec2 n = vec2(e.y,-e.x); // perp\n    //float s = dot(pa.zw, n);\n    //f -= n * s * r;\n\n// check for flipped determinant\nbool isInverted(vec2 p0, vec2 p1, vec2 p2)\n{\n    vec2  d = (p2 - p1).xy;\n    d = normalize(d);\n    return pdot(d, (p0 - p1).xy) < 0.; // determinant()\n}\n\n// Tick just updates all the bike particles \n// individually depending on which pixel this is\nvoid Tick(inout vec4 c, int id, vec2 p)\n{\n    vec2 R = iResolution.xy;\n    c = texelFetch(BufA, ivec2(p), 0);\n    if (id >= nparticles || int(p.y) > 0) return;\n    float dt = iTimeDelta;\n    // HACK detect thumbnail and just fix the framerate at a 60fps that seems fine\n    bool attract = isAttract(iMouse);\n    if (attract) dt = .0167; // HACK otherwise seems too fast\n    if (!(dt > 0.) || isnan(dt)) return; // abort!\n    dt = clamp(dt, .005, .033); // prevent severe temporal discontinuities from blowing things up\n    //dt = .033; // HACK very high or low framerate to stress test physics - high seems fine\n    vec4[3] part = vec4[3] (\n        getParticle(BufA, 0)\n      , getParticle(BufA, 1)\n      , getParticle(BufA, 2)\n      );\n    vec2 p0 = part[pidBody].xy\n      , p1 = part[pidWheelBack].xy\n      , p2 = part[pidWheelFront].xy\n      ;\n    // iTimeDelta seems always locked at low-ish framerate (60fps)\n    // was originally causing the thumbnail to freak out.\n    bool accel  = key(KEY_SPACE)                   \n    , leanback  = key(KEY_A) || key(KEY_LEFT )\n    , leanfront = key(KEY_D) || key(KEY_RIGHT)\n    , laneup    = key(KEY_W) || key(KEY_UP   )\n    , lanedown  = key(KEY_S) || key(KEY_DOWN )\n    , reset     = key(KEY_ESC)\n    , inverted = pdot((p2 - p1).xy, (p0 - p1).xy) < 0. // determinant()\n    ;\n    // check other particles to see if linked and apply connecting forces\n    vec2 op = c.xy;\n    vec2 forces = vec2(0), impulses = vec2(0);\n    for (int i = links.length(); i-- > 0; ) {\n        for (int x = 2; x-- > 0; ) \n            if (id == links[i][x]) {\n                int j = links[i][x^1];\n\t        \tvec4 pj = part[j]; //getParticle(BufA, j);\n    \t    \tvec2 f, v;\n        \t    Constraint(c, pj, f, v, linklen[i].x, linklen[i].y);\n\t            forces += f;\n                impulses += v;\n                break;\n    \t    }\n    }\n    forces.y -= gravity;\n    c.zw += forces * dt + impulses;\n    vec2 oldvel = c.zw; // after forces but prior collision\n    // FIXME Euler integration isn't stable enough for low framerates, need loop or better implicit integrator\n    c.xy += c.zw * dt; // integrate\n    float htrack = dtrack(vec2(c.x,0));\n    // collide with track\n    float dtr = dtrack(vec2(c.x,0));\n    bool onground = c.y <= wheelradius - dtr;\n    if (attract && onground && !inverted \n        && dot(part[0].zw,part[0].zw) < 4.) // speed limit\n         accel = sin(.8*iTime) + sin(6.1*iTime) > .2;\n    // AI balancing, spin prevention\n    vec2 fw = normalize(p2 - p1);\n    if (id == pidBody && attract && abs(fw.y) > .51 && \n        ((p0.y > .5 && !onground) || dot(c.zw,c.zw) > 5. || inverted)) {\n        float sf = 0.; // something about the relative velocities vs. positions of p0..2\n        sf += fw.y;\n        float d = dot(part[0].zw - part[1].zw, fw.yx * vec2(-1,1));\n        sf += d;\n        // if inverted, we should keep spinning the same direction, otherwise opposite\n        if (inverted)\n     \t    sf = -sf;\n        if (sf < -3e-2)\n\t        leanback = true;\n\t    else if (sf > 3e-2)\n\t        leanfront = true;\n    }\n                \n    vec2 g = vec2(0,1);\n    if (onground) {\n    \tg = ntrack(c.xy);\n\t    c.y = max(c.y, wheelradius - dtr);\n    }    \n    c.zw = (c.xy - op) / max(dt, 1e-6);\n    float vd = dot(g, oldvel);\n    bool stopped = dot(oldvel,oldvel) < 3e-3;\n    if (onground) {\n\t    if (vd <= 0.)\n\t        c.zw -= vd * g;\n\t    if (id == pidWheelBack) // back tire acceleration\n\t        if (accel) \n\t            c.z += motorpower * dt;\n\t    if (id == pidBody) // && inverted) // ?\n\t        if (stopped) // main body touching ground == upside down, going slow?\n\t        \tc.zw += vec2(.1,1.35); // BOING rescue\n\t        else\n\t            c.z *= exp2(-friction*dt); // drag/friction\n    }\n    // only body gets air control forces but it\n    // often doesn't know if we're truly airborne\n    // so I'll just let player control body leaning at all times\n    // also serves as slow forward/reverse\n    // probably other ways to manage the forces but this should work ok\n    // meh, wind up needing to add counter-torque forces to the other particles.\n    // I may need to handle the bike as a whole as a rigid body, in the end.\n    if (id == pidBody) {\n        float s = 0.;\n        if (leanback) ++s;\n        if (leanfront) --s;\n        if (inverted) s = -s;\n        vec2 d = normalize(p1 - p2);        \n        c.zw += leanpower*dt*s*d;\n    }\n    bool broken = isInverted(p0, p1, p2)\n    , flipbike = texelFetch(Kbd, ivec2(KEY_SPACE, 1), 0).x > .5; // strobe, must release and press again\n\tif ((broken || (stopped && inverted)) && (attract || flipbike)) // bike's messed up, just fix it if accelerate is pressed\n        FixupFrame(c, id, p0);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy;\n    int i = int(p.x); // + R.x*floor(p.y));\n    // check bufferA resolution pixel matches\n    vec2 oldr = texelFetch(BufA, ivec2(0,1)/*ivec2(R)-1*/, 0).xy;\n    // TODO I should just load the entire state of the bike\n    // because I'll surely wind up needing it, and\n    // no sense loading the stuff more than once.  Make a struct!\n\t// FIXME must detect exploded physics \n    // (nan's in particle positions, huge particle\n    // heights, gigantic velocities, etc.)\n\t// and just reset the toy when it happens\n    vec4 body = getParticle(BufA, 0);\n    //vec4 p1 = getParticle(BufA, 1);\n    //vec4 p2 = getParticle(BufA, 2);\n    if (iFrame == 0 \n     || ivec2(oldr) != ivec2(R+.5)\n     || body.y > 4.\n     || dot(body.zw,body.zw) > 1e4\n     || key(KEY_ESC) // TODO rather just fix the bike, leave the game running\n     //|| isInverted(body.xy, p1.xy, p2.xy) // bike's messed up, just reset the game!\n        // || (isAttract(iMouse) && score > 5.)\n       )\n        Init(c, i, p);\n    else\n        Tick(c, i, p);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int LEVELS = 4;\nconst float SCALE = .5 //4. // // of track noise\n, difficultyh = .2 // similar to SCALE, affect height of bumps\n, difficultye = 1e-2 // exponential scaling over track length\n;\nconst int nparticles = 3;\nconst float pi = acos(-1.);\n\nconst float wheelradius = .05\n    , tirethick = .02;\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n    return (s+s-r)/r.y;\n}\n\nbool isAttract(vec4 mouse)\n{\n    return mouse.z <= 0. && dot(mouse.xy, mouse.xy) <= 4.;\n}\n\nconst int // particle id's\n    pidBody = 0\n  , pidWheelBack = 1\n  , pidWheelFront = 2\n  ;\n    \n// particles are each a vec4\n// where the pseudo-struct is\n// xy=position, zw=velocity\n// but I should change it to zw=oldposition\n// because I swear, verlet is much easier \n// to deal with than euler integration!\n// I just know this euler crap will blow up.\n\n// relative offset from segment given two vectors relative to one endpoint of seg\n// v is from a to query pt, e is from a to b points of segment\nvec2 rseg(vec2 v, vec2 e)\n{ // this is taken from iq's sdLine I think\n    return v - e * clamp(dot(v,e)/dot(e,e), 0., 1.);\n}\n// just take length afterward\n\nfloat dseg(vec2 v, vec2 e)\n{\n    return length(rseg(v, e));\n}\n\n// perp dot product for finding which side of an edge\nfloat pdot(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// spinor of radians = rotator\nvec2 cossin(float r)\n{\n    const float halfpi = .5*pi; //1.5707963;\n    return cos(vec2(r, r - halfpi));\n}\n\n// see https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat rand(float x)\n{\n    return fract(sin(x) * 25314.67285);\n}\n\n\n// see Eikonal Voronoise 1D https://shadertoy.com/view/wsXcW7\n\nfloat tent1(float x)\n{\n    return max(0., (1.-abs(x)));\n}\n\nfloat noise1(float x)\n{\n    float o = x;\n    x = mod(x - 1., 2.) - 1.;\n    float y = sin(3.1415927*(sqrt(5.)+1.)*floor((o-1.)/2.)); // some pseudorandom hash\n\tfloat v = tent1(x);\n    v *= sqrt(.5); // fix sheared 'distance' measurements - but this is 1D so unsure it's even a good thing to try\n    if (y < 0.) v = -v;\n    return v;\n}\n\nfloat fbm1(float x)\n{\n    float d = -1.\n    , s = 1.;\n    for (int i = LEVELS; --i >= 0; s *= .5, x *= 2.) {\n        float n = s * noise1(x);\n        d = max(d, n);\n    }\n    return d;\n}\n\nfloat lodshape(float dshape, float dlod, float fade)\n{\n    float b = abs(dlod);\n    if (b >= fade) return dlod;\n    if (b <= 0.) return dshape;\n    float a = abs(dshape);\n    return mix(dshape, dlod, b / fade);\n}\n\nfloat lnoise1(float x, float y)\n{\n    float n = fbm1(x);\n    // FIXME I get the feeling n is 0..1 here ?!  honestly don't understand what's going on w the range\n    n = clamp(n, -.01, .19);\n    n *= difficultyh * exp2(clamp(difficultye*x, 0., 3.)); // hills grow in steepness/size as track progresses\n    n = min(n, .5); // let's not get too ridiculous\n\tconst float slab = 1.; // for clipping max extent of hill\n    float d0 = y - n, d1 = sign(y) * max(0., abs(y) - slab);\n    return d0;\n}\n\n// track signed height pseudo-distance\nfloat dtrack(vec2 q)\n{\n    float pd = q.y\n    , nd = lnoise1(q.x * SCALE, (q.y * -SCALE + .2)) / -SCALE\n    , d = min(nd, pd);\n    return d;\n}\n\n// gradient for normal of track\nvec2 ntrack(vec2 q)\n{\n    vec2 e = vec2(0,.002);\n    return normalize(vec2(\n    \t    dtrack(q + e.yx)\n    \t  , dtrack(q + e.xy)\n        ) - dtrack(q));\n}\n\nvec4 getParticle(sampler2D ch, int i)\n{\n    return texelFetch(ch, ivec2(i,0), 0);\n}\n\n","name":"Common","description":"","type":"common"}]}