{"ver":"0.1","info":{"id":"3ddGzH","date":"1567790895","viewed":455,"name":"2D Mobius Transform","username":"skye_adaire","description":"This is a geometric Mobius transformation of the complex plane. The image of the plane has also been transformed by sin(z). Uses lifted domain coloring. http://www-users.math.umn.edu/~arnold//papers/moebius.pdf","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sphere","mobius","plane","complex","stereographic","transform","real","lifted"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//created by Skye Adaire\n\n#define tau32 6.2831853072\n#define eps32 1e-10\n\nfloat alpha(float x, float a, float b)\n{\n   return (x - a) / (b - a);\n}\n\n#define uclamp(x) clamp(x, 0.0, 1.0)\n#define ualpha(x, a, b) uclamp(alpha(x, a, b))\n\n#define Real float\n#define Complex vec2\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n\treturn Complex(\n        lhs.x * rhs.x - lhs.y * rhs.y, \n        lhs.x * rhs.y + lhs.y * rhs.x);\n}\n\nComplex H_sin(Complex h)\n{\n\treturn Complex(sin(h.x) * cosh(h.y), cos(h.x) * sinh(h.y));\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h.y, h.x);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\n//the hyperplane centered at the origin with normal 0,0,1\nbool intersectHyperplane(vec3 rayPosition, vec3 rayDirection, out float t)\n{\n    t = -rayPosition[2] / rayDirection[2];\n\n    return t > 0.0 && !isinf(t);\n}\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\n//the hypersphere centered at the origin with radius 1\nbool intersectHypersphere(vec3 rayPosition, vec3 rayDirection, out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayDirection, rayPosition);\n    float c = dot(rayPosition, rayPosition) - 1.0;\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//http://blog.hvidtfeldts.net/index.php/2012/03/lifted-domain-coloring/\nvec3 liftedDomainColor(vec2 z)\n{\n    PolarComplex polar = H_toPolar(z);\n\n    float magnitude = (1.0-1.0/pow(2.0,polar.norm)) * 0.9 + 0.1;\n    float logradius = log(polar.norm);\n\n    //black rings\n    float fractlog = fract(logradius);\n    float ringdist = min(abs(fractlog-0.5), fractlog > 0.5 ? 1.0-fractlog : fractlog);\n    float ring = (1.0 - smoothstep(0.00, 0.02, ringdist)) * 0.8;\n\n    //white rays\n    float k = 12.0;\n    float sectorsize = (tau32) / k;\n    float anglemod = mod(polar.argument, sectorsize);\n    float sectordist = anglemod > sectorsize/2.0 ? sectorsize-anglemod : anglemod;\n    float raywidth = 0.02;\n    float ray = (1.0 - smoothstep(0.0, raywidth, sectordist)) * 0.8;\n\n    //infinity will be white\n    float infinityFade = pow(magnitude,100000000.0);\n\n    //growth ring shade\n    float growth = (fractlog)*0.7 + 0.3;\n    float darkening = uclamp(1.5*magnitude * (fractlog*0.5 + 0.5) + ray + infinityFade);\n\n    float hue = polar.argument/tau32;\n    float saturation = 1.0 - infinityFade;\n    float value = darkening;\n    \n    vec3 color = hsv2rgb(vec3(hue, saturation, value));\n    color = mix(color, vec3(1.0), darkening * ray);\n    color = mix(color, vec3(0.0), darkening * (ring-infinityFade));\n\n    return color;\n}\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n\n    mat3 viewTransform = rotationXY(-tau32 / 8.0) * rotationYZ(tau32/6.0);\n    \n    //view basis\n    vec3 viewPosition = viewTransform * vec3(0, 0, 6);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 screenRayPosition =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 screenRayDirection = normalize(screenRayPosition - frustumPoint);\n       \n    //transform sphere local to global\n    float angle = iTime * 0.4;\n    mat3 rotation = rotationXZ(angle);\n    vec3 translation = vec3(0, 0, 1.0 + cos(iTime*0.4 + tau32/2.0));\n    vec3 pole = translation + vec3(0, 0, 1);\n    \n    //transform sphere global to local\n    mat3 rotationInv = rotationXZ(-angle);\n    vec3 translationInv = -translation;\n    vec3 poleInv = vec3(0, 0, 1);\n    \n    //transform the ray to local sphere space\n    vec3 rpt = rotationInv * (translationInv + screenRayPosition);\n    vec3 rdt = rotationInv * screenRayDirection;\n    \n    float t, tmin;\n    int object = -1;\n    vec3 position;\n    \n    //sphere in local space\n    if(intersectHypersphere(rpt, rdt, t))\n    {\n        tmin = t;\n        object = 1;\n    }\n    \n    //plane in global space\n    if(intersectHyperplane(screenRayPosition, screenRayDirection, t))\n    {\n        if(object == -1 || t < tmin)\n        {\n            tmin = t;\n         \tobject = 2;\n        }\n    }\n    \n    vec3 color = vec3(0);\n    \n    if(object == 2)//we are on the global plane, project to the local sphere\n    {\n        vec3 rp = screenRayPosition + tmin * screenRayDirection;\n        vec3 rd = normalize(rp - pole) * (length(rpt) < 1.0 ? 1.0 : -1.0);;\n        \n    \trpt = rotationInv * (translationInv + rp);\n    \trdt = rotationInv * rd;\n        \n        intersectHypersphere(rpt, rdt, tmin);//must hit\n        object = 1;\n    }\n    \n    if(object == 1)//we are on the local sphere, project to the local plane\n    {\n        vec3 rp =  rpt + tmin * rdt;\n        vec3 rd = normalize(rp - poleInv);\n\n        float t;\n        intersectHyperplane(rp, rd, t);//must hit\n        \n        vec2 localPlanePosition = (rp + t * rd).xy;\n        \n        //apply a complex transform to the plane\n        vec2 z = localPlanePosition;\n        vec2 zt = H_sin(z);\n\n        color = liftedDomainColor(zt);\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}