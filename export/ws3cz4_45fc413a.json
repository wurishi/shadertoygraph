{"ver":"0.1","info":{"id":"ws3cz4","date":"1600484160","viewed":161,"name":"LBM_axisymmetric","username":"Jiaqi","description":"LBM fluid solver.\nUse mouse button to draw walls or draw wave.\n\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["flow","draw","channel","lattice","lbm","boltzmann","cfd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //relaxation time\n    float w = 1./tau;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    //int LatSizeX = 400;\n    //int LatSizeY = 200;\n    //4 texels per voxel\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    //moments\n    float rho = rho(ix,iy);\n    float vx  = vx(ix,iy);\n    float vy  = vy(ix,iy); \n    \n    float solid =solid(ix,iy);\n    f0 = f0(ix,iy);\n    \n    if( (iFrame==0) || (f0==0.0) ) //initialisation comparing with last fram f0\n    {\n        rho = 1.0;\n        vx  = VEL_x;\n        vy  = VEL_y;\n        \n        f0 = calc_equilibrium(rho, vec2(vx,vy), ivec2(center_offset));\n        f1 = calc_equilibrium(rho, vec2(vx,vy), ivec2(east_offset));\n        f2 = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_offset));\n        f3 = calc_equilibrium(rho, vec2(vx,vy), ivec2(west_offset));\n        f4 = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_offset));\n        f5 = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_east_offset));\n        f6 = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_west_offset));        \n        f7 = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_west_offset));\n        f8 = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_east_offset));\n        \n       \n        //add a small disk near the entrance\n        float R = 1.0;\n        float R_x=50.0;\n        if( distance(vec2(R_x,LatSizeY/2),vec2(ix,iy)) < R || iy<2 || iy>LatSizeY-2)\n            solid = 1.0;\n        else\n            solid = 0.0;\n    }\n    \n    else //normal time-step\n    {\n    \n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( ix    ,yminus);\n        f3 = f3( xplus ,iy    );\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yminus);        \n        f7 = f7( xplus ,yplus );\n        f8 = f8( xminus,yplus );\n        //6--2--5\n        //|  |  |\n        //3--0--1\n        //|  |  |\n        //7--4--8        \n        \n        #if PRESET_disk_Boundary==1\n        //boundary condition-bounce back\n        float temp;\n        if( solid>0.5 )//boundary condition \n        {\n            temp = f1;\n            f1   = f3;\n            f3   = temp;\n            temp = f2;\n            f2   = f4;\n            f4   = temp;\n            temp = f6;\n            f6   = f5;\n            f5   = temp;\n            temp = f7;\n            f7   = f8;\n            f8   = temp;\n\n\n        }\n        \n        #endif\n\n        \n        \n        \n        \n\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1+f5+f8-f3-f6-f7);\n        vy = 1./rho*(f2+f5+f6-f4-f7-f8);\n      \n               \n        \n        #if PRESET==0\n      \n        if( iMouse.w>0.01 && distance(iMouse.xy/2.0,vec2(ix,iy)) < 2.0)\n            solid = 1.0;\n        \n        #elif PRESET==1\n        vec2 mouse = vec2(iMouse.zw);\n    \tif(mouse.x > 0.0 && mouse.y > 0.0){\n        vec2 current_mouse = vec2(iMouse.xy);\n        if(distance(fragCoord, current_mouse) < 3.0){\n            rho += 0.1;\n        \t}\n    \t}\n        #endif\n\n        \n        #if PRESET_Non_orthogonal==0 //classical feq with soft wall\n        \t\n        float f0eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(center_offset));\n        float f1eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(east_offset));\n        float f2eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_offset));\n        float f3eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(west_offset));        \n        float f4eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_offset));        \n        float f5eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_east_offset));\n        float f6eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_west_offset));        \n        float f7eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_west_offset));        \n        float f8eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_east_offset));\n        \n        \n        \t#if PRESET_LES==0\n        \t\t  float OMEGAS = 1.0/tau;\n            #elif PRESET_LES==1        \n        \tfloat f0neq = f0 - f0eq;\n        \tfloat f1neq = f1 - f1eq;\n        \tfloat f2neq = f2 - f2eq;\n        \tfloat f3neq = f3 - f3eq;\n        \tfloat f4neq = f4 - f4eq;\n        \tfloat f5neq = f5 - f5eq;\n        \tfloat f6neq = f6 - f6eq;\n        \tfloat f7neq = f7 - f7eq;\n        \tfloat f8neq = f8 - f8eq;\n        \t//Pxx = sum of e[k].x * e[k].x * f_neq[k] where e[k] is the direction of the node k.\n        \tfloat Pxx = f1neq + f3neq + f5neq + f6neq + f7neq +f8neq;\n        \tfloat Pxy = f5neq + f7neq - f6neq - f8neq;\n        \tfloat Pyy = f2neq + f4neq + f5neq + f6neq + f7neq +f8neq;\n        \tfloat Q = sqrt(Pxx*Pxx + 2. * Pxy*Pxy + Pyy*Pyy);//magnitude of this non equilibrium stress tensor\n        \tfloat S = 1. / 6. * (sqrt(nu*nu + 18. * C*C * Q) - nu);//magnitude of the stress tensor itself\n        \tfloat TauS = (6.0*( nu + S ) + 1.0)/2.0; //relaxation\n        \tfloat OMEGAS = 1.0/TauS;\n            #endif\n\n        \n        \n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        //anechoic band for soft wall\n        float sigma1 = smoothstep(0.95,1.0 ,fragCoord.x/iResolution.x);//inlet\n        float sigma2 = 1.-smoothstep(0.0 ,0.05,fragCoord.x/iResolution.x);//outlet\n        float sigma3 = smoothstep(0.95,1.0 ,fragCoord.y/iResolution.y);//down\n        float sigma4 = 1.-smoothstep(0.0 ,0.05,fragCoord.y/iResolution.y);//up\n        float scale = 0.4;\n        float sigma = scale*(sigma1+sigma2+sigma3+sigma4);\n        \n        //add force term in collision step\n        float g0 = 0.0;\n        float g1 = 1./9.  * rho * ( 3.* Gx);\n        float g2 = 1./9.  * rho * ( 3.* Gy);\n        float g3 = 1./9.  * rho * (-3.* Gx);\n        float g4 = 1./9.  * rho * ( 3.* Gy);\n        float g5 = 1./36. * rho * ( 3.* (Gx+Gy));\n        float g6 = 1./36. * rho * ( 3.* (-Gx+Gy));       \n        float g7 = 1./36. * rho * (-3.* (Gx+Gy));\n        float g8 = 1./36. * rho * (-3.* (-Gx+Gy));\n                \n        \n        f0 = (1.-OMEGAS) * f0 + OMEGAS * f0eq - sigma*(f0eq-Ft0) + g0;\n        f1 = (1.-OMEGAS) * f1 + OMEGAS * f1eq - sigma*(f1eq-Ft1) + g1;\n        f2 = (1.-OMEGAS) * f2 + OMEGAS * f2eq - sigma*(f2eq-Ft2) + g2;\n        f3 = (1.-OMEGAS) * f3 + OMEGAS * f3eq - sigma*(f3eq-Ft3) + g3;\n        f4 = (1.-OMEGAS) * f4 + OMEGAS * f4eq - sigma*(f4eq-Ft4) + g4;\n        f5 = (1.-OMEGAS) * f5 + OMEGAS * f5eq - sigma*(f5eq-Ft5) + g5;\n        f6 = (1.-OMEGAS) * f6 + OMEGAS * f6eq - sigma*(f6eq-Ft6) + g6;\n        f7 = (1.-OMEGAS) * f7 + OMEGAS * f7eq - sigma*(f7eq-Ft7) + g7;\n        f8 = (1.-OMEGAS) * f8 + OMEGAS * f8eq - sigma*(f8eq-Ft8) + g8;\n        \n\n        #elif PRESET_Non_orthogonal==1 //central moments        \n        //Cascaded Lattice Boltzmann solver\n        //trace of the pressure tensor\n  \t\t//float T = 1./rho*((((-vx)*(-vx)))*f0+(((1.-vx)*(1.-vx)))*f1+(((-vx)*(-vx)))*f3+(((-1.-vx)*(-1.-vx)))*f2+(((-vx)*(-vx)))*f4+(((1.-vx)*(1.-vx)))*f5+(((-1.-vx)*(-1.-vx)))*f6+(((-1.-vx)*(-1.-vx)))*f7+(((1.-vx)*(1.-vx)))*f8)+1./rho*((((-vy)*(-vy)))*f0+(((-vy)*(-vy)))*f1+(((1.-vy)*(1.-vy)))*f2+(((-vy)*(-vy)))*f3+(((-1.-vy)*(-1.-vy)))*f4+(((1.-vy)*(1.-vy)))*f5+(((1.-vy)*(1.-vy)))*f6+(((-1.-vy)*(-1.-vy)))*f7+(((-1.-vy)*(-1.-vy)))*f8);\n  \t\t//normal stress difference\n  \t\tfloat N = 1./rho*((((-vx)*(-vx)))*f0+(((1.-vx)*(1.-vx)))*f1+(((-vx)*(-vx)))*f2+(((-1.-vx)*(-1.-vx)))*f3+(((-vx)*(-vx)))*f4+(((1.-vx)*(1.-vx)))*f5+(((-1.-vx)*(-1.-vx)))*f6+(((-1.-vx)*(-1.-vx)))*f7+(((1.-vx)*(1.-vx)))*f8)-(1./rho*((((-vy)*(-vy)))*f0+(((-vy)*(-vy)))*f1+(((1.-vy)*(1.-vy)))*f2+(((-vy)*(-vy)))*f3+(((-1.-vy)*(-1.-vy)))*f4+(((1.-vy)*(1.-vy)))*f5+(((1.-vy)*(1.-vy)))*f6+(((-1.-vy)*(-1.-vy)))*f7+(((-1.-vy)*(-1.-vy)))*f8));\n  \t\t//off diagonal element of the stress tensor\n  \t\tfloat Pxy = 1./rho*(((-vx)*(-vy))*f0+((1.-vx)*(-vy))*f1+((-vx)*(1.-vy))*f2+((-1.-vx)*(-vy))*f3+((-vx)*(-1.-vy))*f4+((1.-vx)*(1.-vy))*f5+((-1.-vx)*(1.-vy))*f6+((-1.-vx)*(-1.-vy))*f7+((1.-vx)*(-1.-vy))*f8);\n  \t\t//fisrt third order moment\n  \t\t//float Qyxx = 1./rho*((((-vx)*(-vx))*(-vy))*f0+(((1.-vx)*(1.-vx))*(-vy))*f1+(((-vx)*(-vx))*(1.-vy))*f3+(((-1.-vx)*(-1.-vx))*(-vy))*f2+(((-vx)*(-vx))*(-1.-vy))*f4+(((1.-vx)*(1.-vx))*(1.-vy))*f5+(((-1.-vx)*(-1.-vx))*(1.-vy))*f6+(((-1.-vx)*(-1.-vx))*(-1.-vy))*f7+(((1.-vx)*(1.-vx))*(-1.-vy))*f8);\n  \t\t//second third order moment\n  \t\t//float Qxyy = 1./rho*(((-vx)*((-vy)*(-vy)))*f0+((1.-vx)*((-vy)*(-vy)))*f1+((-vx)*((1.-vy)*(1.-vy)))*f3+((-1.-vx)*((-vy)*(-vy)))*f2+((-vx)*((-1.-vy)*(-1.-vy)))*f4+((1.-vx)*((1.-vy)*(1.-vy)))*f5+((-1.-vx)*((1.-vy)*(1.-vy)))*f6+((-1.-vx)*((-1.-vy)*(-1.-vy)))*f7+((1.-vx)*((-1.-vy)*(-1.-vy)))*f8);\n  \t\t//fourth order moment\n  \t\t//float A = 1./rho*((((-vx)*(-vx))*((-vy)*(-vy)))*f0+(((1.-vx)*(1.-vx))*((-vy)*(-vy)))*f1+(((-vx)*(-vx))*((1.-vy)*(1.-vy)))*f3+(((-1.-vx)*(-1.-vx))*((-vy)*(-vy)))*f2+(((-vx)*(-vx))*((-1.-vy)*(-1.-vy)))*f4+(((1.-vx)*(1.-vx))*((1.-vy)*(1.-vy)))*f5+(((-1.-vx)*(-1.-vx))*((1.-vy)*(1.-vy)))*f6+(((-1.-vx)*(-1.-vx))*((-1.-vy)*(-1.-vy)))*f7+(((1.-vx)*(1.-vx))*((-1.-vy)*(-1.-vy)))*f8);\n        \n        //=== RELAX TOWARD EQUILIBRIUM ========================\n \t    Pxy = (1.-w)*Pxy;\n  \t    N = (1.-w)*N;\n  \t\tfloat T = 0.66666666666667;\n  \t  \tfloat Qxyy = 0.0;\n        float Qyxx = 0.0;\n        float A = 0.11111111111111;\n        \n\n        f0 = rho*(1.-(vx*vx+vy*vy)+4.*vx*vy*Pxy-(((vx*vx-vy*vy)/2.)*N)+((-2.+vx*vx+vy*vy)/2.)*T+2.*vx*Qxyy+2.*vy*Qyxx+A);\n  \t\tf1 = rho/2.*(vx*vx+vx*(1.-vy*vy)-((2.*vy+4.*vx*vy)*Pxy)+((1.+vx+vx*vx-vy*vy)/2.)*N+((1.-vx-(vx*vx+vy*vy))/2.)*T-((1.+2.*vx)*Qxyy)-2.*vy*Qyxx-A);\n  \t\tf2 = rho/2.*(vy*vy+vy*(1.-vx*vx)-((2.*vx+4.*vx*vy)*Pxy)+((-1.-vy+vx*vx-vy*vy)/2.)*N+((1.-vy-(vx*vx+vy*vy))/2.)*T-((1.+2.*vy)*Qyxx)-2.*vx*Qxyy-A);\n  \t\tf3 = rho/2.*(vx*vx+(-vx)*(1.-vy*vy)-((-2.*vy+4.*vx*vy)*Pxy)+((1.-vx+vx*vx-vy*vy)/2.)*N+((1.-(-vx)-(vx*vx+vy*vy))/2.)*T-((-1.+2.*vx)*Qxyy)-2.*vy*Qyxx-A);\n  \t\tf4 = rho/2.*(vy*vy+(-vy)*(1.-vx*vx)-((-2.*vx+4.*vx*vy)*Pxy)+((-1.-(-vy)+vx*vx-vy*vy)/2.)*N+((1.-(-vy)-(vx*vx+vy*vy))/2.)*T-((-1.+2.*vy)*Qyxx)-2.*vx*Qxyy-A);\n  \t\tf5 = rho/4.*(vx*vy+vx*vy*vy+vy*vx*vx+(1.+4.*vx*vy+2.*vy+2.*vx)*Pxy+((-vx*vx+vy*vy-vx+vy)/2.)*N+((vx*vx+vy*vy+vx+vy)/2.)*T+(1.+2.*vx)*Qxyy+(1.+2.*vy)*Qyxx+A);\n  \t\tf6 = rho/4.*((-vx)*vy+(-vx)*vy*vy+vy*vx*vx+(-1.+4.*vx*vy-2.*vy+2.*vx)*Pxy+((-vx*vx+vy*vy-(-vx)+vy)/2.)*N+((vx*vx+vy*vy-vx+vy)/2.)*T+(-1.+2.*vx)*Qxyy+(1.+2.*vy)*Qyxx+A);\n  \t\tf7 = rho/4.*(vx*vy+(-vx)*vy*vy+(-vy)*vx*vx+(1.+4.*vx*vy-2.*vy-2.*vx)*Pxy+((-vx*vx+vy*vy-(-vx)-vy)/2.)*N+((vx*vx+vy*vy-vx-vy)/2.)*T+(-1.+2.*vx)*Qxyy+(-1.+2.*vy)*Qyxx+A);\n  \t\tf8 = rho/4.*((-vx)*vy+vx*vy*vy+(-vy)*vx*vx+(-1.+4.*vx*vy+2.*vy-2.*vx)*Pxy+((-vx*vx+vy*vy-vx-vy)/2.)*N+((vx*vx+vy*vy+vx-vy)/2.)*T+(1.+2.*vx)*Qxyy+(-1.+2.*vy)*Qyxx+A);\n        \n        #elif PRESET_Non_orthogonal==2 //Non-orthogonal central moments\n        float U=vx;\n        float V=vy;\n        float U2 = U*U;\n\t    float V2 = V*V;\n\t    float UV = U*V;\n\t\tfloat U2V2 = U2*V2;\n        float k4 = ((((-vx)*(-vx)))*f0+(((1.-vx)*(1.-vx)))*f1+(((-vx)*(-vx)))*f2+(((-1.-vx)*(-1.-vx)))*f3+(((-vx)*(-vx)))*f4+(((1.-vx)*(1.-vx)))*f5+(((-1.-vx)*(-1.-vx)))*f6+(((-1.-vx)*(-1.-vx)))*f7+(((1.-vx)*(1.-vx)))*f8)-(((((-vy)*(-vy)))*f0+(((-vy)*(-vy)))*f1+(((1.-vy)*(1.-vy)))*f2+(((-vy)*(-vy)))*f3+(((-1.-vy)*(-1.-vy)))*f4+(((1.-vy)*(1.-vy)))*f5+(((1.-vy)*(1.-vy)))*f6+(((-1.-vy)*(-1.-vy)))*f7+(((-1.-vy)*(-1.-vy)))*f8));\n        float k5 = (((-vx)*(-vy))*f0+((1.-vx)*(-vy))*f1+((-vx)*(1.-vy))*f2+((-1.-vx)*(-vy))*f3+((-vx)*(-1.-vy))*f4+((1.-vx)*(1.-vy))*f5+((-1.-vx)*(1.-vy))*f6+((-1.-vx)*(-1.-vy))*f7+((1.-vx)*(-1.-vy))*f8);\n        k4 *= 1.-w;\n        k5 *= 1.-w;\n        float k3 = rho*2./3.;\n        float k6 = -rho*U2*V;\n        float k7 = -rho*U*V2;\n        float k8 = rho*(1.+27.*U2V2)/9.0;\n        \n        f0 = k3*(-1.+0.5*U2+0.5*V2)+k4*(-U2+V2)+4.*UV*k5+2.*V*k6+2.*U*k7+k8+rho*(1.-U2-V2+U2V2);\n    \tf1 = 0.25*k3*(1.-U-U2-V2)+0.25*k4*(1.+U+U2-V2)+k5*(-V-2.*UV)-V*k6+k7*(-0.5-U)-0.5*k8+0.5*rho*(U+U2-U*V2-U2V2);\n    \tf2 = 0.25*k3*(1.-V-U2-V2)+0.25*k4*(-1.-V+U2-V2)+k5*(-U-2.*UV)+k6*(-0.5-V)-U*k7-0.5*k8+0.5*rho*(V+V2-U2*V-U2V2);\n\t    f3 = 0.25*k3*(1.+U-U2-V2)+0.25*k4*(1.-U+U2-V2)+k5*(V-2.*UV)-V*k6+k7*(0.5-U)-0.5*k8+0.5*rho*(-U+U2+U*V2-U2V2);\n\t    f4 = 0.25*k3*(1.+V-U2-V2)+0.25*k4*(-1.+V+U2-V2)+k5*(U-2.*UV)+k6*(0.5-V)-U*k7-0.5*k8+0.5*rho*(-V+V2+U2*V-U2V2);\n\t    f5 = 0.125*k3*(U+V+U2+V2)+0.125*k4*(-U+V-U2+V2)+k5*(0.25+0.5*U+0.5*V+UV)+k6*(0.25+0.5*V)+k7*(0.25+0.5*U)+0.25*k8+0.25*rho*(UV+U2*V+U*V2+U2V2);\n\t    f6 = 0.125*k3*(-U+V+U2+V2)+0.125*k4*(U+V-U2+V2)+k5*(-0.25+0.5*U-0.5*V+UV)+k6*(0.25+0.5*V)+k7*(-0.25+0.5*U)+0.25*k8+0.25*rho*(-UV+U2*V-U*V2+U2V2);\n\t    f7 = 0.125*k3*(-U-V+U2+V2)+0.125*k4*(U-V-U2+V2)+k5*(0.25-0.5*U-0.5*V+UV)+k6*(-0.25+0.5*V)+k7*(-0.25+0.5*U)+0.25*k8+0.25*rho*(UV-U2*V-U*V2+U2V2);\n\t    f8 = 0.125*k3*(U-V+U2+V2)+0.125*k4*(-U-V-U2+V2)+k5*(-0.25-0.5*U+0.5*V+UV)+k6*(-0.25+0.5*V)+k7*(0.25+0.5*U)+0.25*k8+0.25*rho*(-UV-U2*V+U*V2+U2V2);\n\t\n        #elif PRESET_Non_orthogonal==3 //Cas_Geier\n        \n\t\t//pre-collision mass/momentum source step , update \n              \n        float r = float(iy)+r0;\n        float temp1=vy(xplus,iy);\n        float temp2=vy(xminus,iy);\n        float temp3=vx(ix,yplus);\n        float temp4=vx(ix,yminus);\n        float temp5=vy(ix,yplus);\n        float temp6=vy(ix,yminus);\n                \n               \n        float dxvy =(temp1-temp2)/2.0;\n        float dyvx =(temp3-temp4)/2.0;\n        float dyvy =(temp5-temp6)/2.0;\n        \n        float MA = -rho*vy/r;\n        float FA_x = -rho*vx*vy/r + nu*rho*dxvy/r; \n        float FA_y = -rho*vy*vy/r + 2.0*nu*rho*dyvy/r - 2.0*nu*rho*vy/r/r;\n        \n        rho += MA/2.0 ; //dt=1;\n        vx  += FA_x/2.0 /rho;\n        vy  += FA_y/2.0 /rho;\n    \n      \n        \n        \n        \n        \n        float kxx = f1 + f3 + f5 + f6 + f7 + f8;\n\t\tfloat kyy = f2 + f4 + f5 + f6 + f7 + f8;\n\t\tfloat kxy = f5 + f7 - f6 - f8;\n\t\tfloat kxxy = f5 + f6 - f7 - f8;\n\t\tfloat kxyy = f5 + f8 - f6 - f7;\n\t\tfloat kxxyy = f5 + f6 + f7 + f8;\n\n        //Cas_Geier\n        //float omega3 = 1.0;\n        //float omega4 = 1.0/tau;\n        //float omega5 = 1.0/tau;\n        //float omega6 = 1.0;\n        //float omega7 = 1.0;\n        //float omega8 = 1.0;\n        //Cas_Lalle \n        //float omega3 = 1.64;\n        //float omega4 = 1.0/tau;\n        //float omega5 = 1.0/tau;\n        //float omega6 = 1.9;\n        //float omega7 = 1.9;\n        //float omega8 = 1.54;\n        //Cas_Chavez\n        float omega3 = 1.64;\n        float omega4 = 1.0/tau;\n        float omega5 = 1.0/tau;\n        float omega6 = 0.9;\n        float omega7 = 0.9;\n        float omega8 = 1.54;        \n        \n\n        \n        \n        float p0 = MA/9.0;\n        float p1 = FA_x/6.0;\n        float p2 = FA_y/6.0;\n        \n\t\tfloat p3 = (omega3/12.)*((2.*rho/3.) + rho*((vx*vx) + (vy*vy)) - (kxx + kyy));\n\t\tfloat p4 = (omega4/4.)*(rho*((vx*vx) - (vy*vy)) - (kxx - kyy));\n\t\tfloat p5 = (omega5/4.)*(rho*vx*vy - kxy);\n\t\tfloat p6 = (omega6/4.)*(2.*rho*(vx*vx)*vy + kxxy - 2.*vx*kxy - vy*kxx) - 0.5*vy*(3.*p3 + p4) - 2.*vx*p5;\n\t\tfloat p7 = (omega7/4.)*(2.*rho*vx*(vy*vy) + kxyy - 2.*vy*kxy - vx*kyy) - 0.5*vx*(3.*p3 - p4) - 2.*vy*p5;\n\t\tfloat p8 = (omega8/4.)*(rho/9. + 3.*rho*(vx*vx)*(vy*vy) - (kxxyy - 2.*vx*kxyy - 2.*vy*kxxy + (vx*vx)*kyy + (vy*vy)*kxx + 4.*vx*vy*kxy)) -2.*p3 -0.5*(vy*vy)*(3.*p3 + p4) - 0.5*(vx*vx)*(3.*p3 - p4) - 4.*vx*vy*p5 - 2.*vy*p6 - 2.*vx*p7;\n\n        f0  = f0 + p0 - 4.*(p3 - p8);\n        f1  = f1 + p0 + p1 - p3 + p4 + 2.*(p7 - p8);\n        f2  = f2 + p0 + p2 - p3 - p4 + 2.*(p6 - p8);\n        f3  = f3 + p0 - p1 - p3 + p4 - 2.*(p7 + p8);\n        f4  = f4 + p0 - p2 - p3 - p4 - 2.*(p6 + p8);\n        f5  = f5 + p0 + p1 + p2 + 2.*p3 + p5 - p6 - p7 + p8;\n        f6  = f6 + p0 - p1 + p2 + 2.*p3 - p5 - p6 + p7 + p8;\n        f7  = f7 + p0 - p1 - p2 + 2.*p3 + p5 + p6 + p7 + p8;\n        f8  = f8 + p0 + p1 - p2 + 2.*p3 - p5 + p6 - p7 + p8;\n        \n\n        \n        \n        \n        \n\t\t#endif\n        \n        \n        \n\n        \n       \n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor = vec4(f0,f1,f2,f3);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor = vec4(f4,f5,f6,f7);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rg = vec2(f8);\n    else //stores rho,vx,vy\n        fragColor= vec4(rho,vx,vy,solid);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //relaxation time\n    float w = 1./tau;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    //int LatSizeX = 400;\n    //int LatSizeY = 200;\n    //4 texels per voxel\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    //moments\n    float rho = rho(ix,iy);\n    float vx  = vx(ix,iy);\n    float vy  = vy(ix,iy); \n    \n    float solid =solid(ix,iy);\n    f0 = f0(ix,iy);\n    \n    if( (iFrame==0) || (f0==0.0) ) //initialisation comparing with last fram f0\n    {\n        rho = 1.0;\n        vx  = VEL_x;\n        vy  = VEL_y;\n        \n        f0 = calc_equilibrium(rho, vec2(vx,vy), ivec2(center_offset));\n        f1 = calc_equilibrium(rho, vec2(vx,vy), ivec2(east_offset));\n        f2 = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_offset));\n        f3 = calc_equilibrium(rho, vec2(vx,vy), ivec2(west_offset));\n        f4 = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_offset));\n        f5 = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_east_offset));\n        f6 = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_west_offset));        \n        f7 = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_west_offset));\n        f8 = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_east_offset));\n        \n       \n        //add a small disk near the entrance\n        float R = 1.0;\n        float R_x=50.0;\n        if( distance(vec2(R_x,LatSizeY/2),vec2(ix,iy)) < R || iy<2 || iy>LatSizeY-2)\n            solid = 1.0;\n        else\n            solid = 0.0;\n    }\n    \n    else //normal time-step\n    {\n    \n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( ix    ,yminus);\n        f3 = f3( xplus ,iy    );\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yminus);        \n        f7 = f7( xplus ,yplus );\n        f8 = f8( xminus,yplus );\n        //6--2--5\n        //|  |  |\n        //3--0--1\n        //|  |  |\n        //7--4--8        \n        \n        #if PRESET_disk_Boundary==1\n        //boundary condition-bounce back\n        float temp;\n        if( solid>0.5 )//boundary condition \n        {\n            temp = f1;\n            f1   = f3;\n            f3   = temp;\n            temp = f2;\n            f2   = f4;\n            f4   = temp;\n            temp = f6;\n            f6   = f5;\n            f5   = temp;\n            temp = f7;\n            f7   = f8;\n            f8   = temp;\n\n\n        }\n        \n        #endif\n\n        \n        \n        \n        \n\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1+f5+f8-f3-f6-f7);\n        vy = 1./rho*(f2+f5+f6-f4-f7-f8);\n      \n               \n        \n        #if PRESET==0\n      \n        if( iMouse.w>0.01 && distance(iMouse.xy/2.0,vec2(ix,iy)) < 2.0)\n            solid = 1.0;\n        \n        #elif PRESET==1\n        vec2 mouse = vec2(iMouse.zw);\n    \tif(mouse.x > 0.0 && mouse.y > 0.0){\n        vec2 current_mouse = vec2(iMouse.xy);\n        if(distance(fragCoord, current_mouse) < 3.0){\n            rho += 0.1;\n        \t}\n    \t}\n        #endif\n\n        \n        #if PRESET_Non_orthogonal==0 //classical feq with soft wall\n        \t\n        float f0eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(center_offset));\n        float f1eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(east_offset));\n        float f2eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_offset));\n        float f3eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(west_offset));        \n        float f4eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_offset));        \n        float f5eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_east_offset));\n        float f6eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(north_west_offset));        \n        float f7eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_west_offset));        \n        float f8eq = calc_equilibrium(rho, vec2(vx,vy), ivec2(south_east_offset));\n        \n        \n        \t#if PRESET_LES==0\n        \t\t  float OMEGAS = 1.0/tau;\n            #elif PRESET_LES==1        \n        \tfloat f0neq = f0 - f0eq;\n        \tfloat f1neq = f1 - f1eq;\n        \tfloat f2neq = f2 - f2eq;\n        \tfloat f3neq = f3 - f3eq;\n        \tfloat f4neq = f4 - f4eq;\n        \tfloat f5neq = f5 - f5eq;\n        \tfloat f6neq = f6 - f6eq;\n        \tfloat f7neq = f7 - f7eq;\n        \tfloat f8neq = f8 - f8eq;\n        \t//Pxx = sum of e[k].x * e[k].x * f_neq[k] where e[k] is the direction of the node k.\n        \tfloat Pxx = f1neq + f3neq + f5neq + f6neq + f7neq +f8neq;\n        \tfloat Pxy = f5neq + f7neq - f6neq - f8neq;\n        \tfloat Pyy = f2neq + f4neq + f5neq + f6neq + f7neq +f8neq;\n        \tfloat Q = sqrt(Pxx*Pxx + 2. * Pxy*Pxy + Pyy*Pyy);//magnitude of this non equilibrium stress tensor\n        \tfloat S = 1. / 6. * (sqrt(nu*nu + 18. * C*C * Q) - nu);//magnitude of the stress tensor itself\n        \tfloat TauS = (6.0*( nu + S ) + 1.0)/2.0; //relaxation\n        \tfloat OMEGAS = 1.0/TauS;\n            #endif\n\n        \n        \n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        //anechoic band for soft wall\n        float sigma1 = smoothstep(0.95,1.0 ,fragCoord.x/iResolution.x);//inlet\n        float sigma2 = 1.-smoothstep(0.0 ,0.05,fragCoord.x/iResolution.x);//outlet\n        float sigma3 = smoothstep(0.95,1.0 ,fragCoord.y/iResolution.y);//down\n        float sigma4 = 1.-smoothstep(0.0 ,0.05,fragCoord.y/iResolution.y);//up\n        float scale = 0.4;\n        float sigma = scale*(sigma1+sigma2+sigma3+sigma4);\n        \n        //add force term in collision step\n        float g0 = 0.0;\n        float g1 = 1./9.  * rho * ( 3.* Gx);\n        float g2 = 1./9.  * rho * ( 3.* Gy);\n        float g3 = 1./9.  * rho * (-3.* Gx);\n        float g4 = 1./9.  * rho * ( 3.* Gy);\n        float g5 = 1./36. * rho * ( 3.* (Gx+Gy));\n        float g6 = 1./36. * rho * ( 3.* (-Gx+Gy));       \n        float g7 = 1./36. * rho * (-3.* (Gx+Gy));\n        float g8 = 1./36. * rho * (-3.* (-Gx+Gy));\n                \n        \n        f0 = (1.-OMEGAS) * f0 + OMEGAS * f0eq - sigma*(f0eq-Ft0) + g0;\n        f1 = (1.-OMEGAS) * f1 + OMEGAS * f1eq - sigma*(f1eq-Ft1) + g1;\n        f2 = (1.-OMEGAS) * f2 + OMEGAS * f2eq - sigma*(f2eq-Ft2) + g2;\n        f3 = (1.-OMEGAS) * f3 + OMEGAS * f3eq - sigma*(f3eq-Ft3) + g3;\n        f4 = (1.-OMEGAS) * f4 + OMEGAS * f4eq - sigma*(f4eq-Ft4) + g4;\n        f5 = (1.-OMEGAS) * f5 + OMEGAS * f5eq - sigma*(f5eq-Ft5) + g5;\n        f6 = (1.-OMEGAS) * f6 + OMEGAS * f6eq - sigma*(f6eq-Ft6) + g6;\n        f7 = (1.-OMEGAS) * f7 + OMEGAS * f7eq - sigma*(f7eq-Ft7) + g7;\n        f8 = (1.-OMEGAS) * f8 + OMEGAS * f8eq - sigma*(f8eq-Ft8) + g8;\n        \n\n        #elif PRESET_Non_orthogonal==1 //central moments        \n        //Cascaded Lattice Boltzmann solver\n        //trace of the pressure tensor\n  \t\t//float T = 1./rho*((((-vx)*(-vx)))*f0+(((1.-vx)*(1.-vx)))*f1+(((-vx)*(-vx)))*f3+(((-1.-vx)*(-1.-vx)))*f2+(((-vx)*(-vx)))*f4+(((1.-vx)*(1.-vx)))*f5+(((-1.-vx)*(-1.-vx)))*f6+(((-1.-vx)*(-1.-vx)))*f7+(((1.-vx)*(1.-vx)))*f8)+1./rho*((((-vy)*(-vy)))*f0+(((-vy)*(-vy)))*f1+(((1.-vy)*(1.-vy)))*f2+(((-vy)*(-vy)))*f3+(((-1.-vy)*(-1.-vy)))*f4+(((1.-vy)*(1.-vy)))*f5+(((1.-vy)*(1.-vy)))*f6+(((-1.-vy)*(-1.-vy)))*f7+(((-1.-vy)*(-1.-vy)))*f8);\n  \t\t//normal stress difference\n  \t\tfloat N = 1./rho*((((-vx)*(-vx)))*f0+(((1.-vx)*(1.-vx)))*f1+(((-vx)*(-vx)))*f2+(((-1.-vx)*(-1.-vx)))*f3+(((-vx)*(-vx)))*f4+(((1.-vx)*(1.-vx)))*f5+(((-1.-vx)*(-1.-vx)))*f6+(((-1.-vx)*(-1.-vx)))*f7+(((1.-vx)*(1.-vx)))*f8)-(1./rho*((((-vy)*(-vy)))*f0+(((-vy)*(-vy)))*f1+(((1.-vy)*(1.-vy)))*f2+(((-vy)*(-vy)))*f3+(((-1.-vy)*(-1.-vy)))*f4+(((1.-vy)*(1.-vy)))*f5+(((1.-vy)*(1.-vy)))*f6+(((-1.-vy)*(-1.-vy)))*f7+(((-1.-vy)*(-1.-vy)))*f8));\n  \t\t//off diagonal element of the stress tensor\n  \t\tfloat Pxy = 1./rho*(((-vx)*(-vy))*f0+((1.-vx)*(-vy))*f1+((-vx)*(1.-vy))*f2+((-1.-vx)*(-vy))*f3+((-vx)*(-1.-vy))*f4+((1.-vx)*(1.-vy))*f5+((-1.-vx)*(1.-vy))*f6+((-1.-vx)*(-1.-vy))*f7+((1.-vx)*(-1.-vy))*f8);\n  \t\t//fisrt third order moment\n  \t\t//float Qyxx = 1./rho*((((-vx)*(-vx))*(-vy))*f0+(((1.-vx)*(1.-vx))*(-vy))*f1+(((-vx)*(-vx))*(1.-vy))*f3+(((-1.-vx)*(-1.-vx))*(-vy))*f2+(((-vx)*(-vx))*(-1.-vy))*f4+(((1.-vx)*(1.-vx))*(1.-vy))*f5+(((-1.-vx)*(-1.-vx))*(1.-vy))*f6+(((-1.-vx)*(-1.-vx))*(-1.-vy))*f7+(((1.-vx)*(1.-vx))*(-1.-vy))*f8);\n  \t\t//second third order moment\n  \t\t//float Qxyy = 1./rho*(((-vx)*((-vy)*(-vy)))*f0+((1.-vx)*((-vy)*(-vy)))*f1+((-vx)*((1.-vy)*(1.-vy)))*f3+((-1.-vx)*((-vy)*(-vy)))*f2+((-vx)*((-1.-vy)*(-1.-vy)))*f4+((1.-vx)*((1.-vy)*(1.-vy)))*f5+((-1.-vx)*((1.-vy)*(1.-vy)))*f6+((-1.-vx)*((-1.-vy)*(-1.-vy)))*f7+((1.-vx)*((-1.-vy)*(-1.-vy)))*f8);\n  \t\t//fourth order moment\n  \t\t//float A = 1./rho*((((-vx)*(-vx))*((-vy)*(-vy)))*f0+(((1.-vx)*(1.-vx))*((-vy)*(-vy)))*f1+(((-vx)*(-vx))*((1.-vy)*(1.-vy)))*f3+(((-1.-vx)*(-1.-vx))*((-vy)*(-vy)))*f2+(((-vx)*(-vx))*((-1.-vy)*(-1.-vy)))*f4+(((1.-vx)*(1.-vx))*((1.-vy)*(1.-vy)))*f5+(((-1.-vx)*(-1.-vx))*((1.-vy)*(1.-vy)))*f6+(((-1.-vx)*(-1.-vx))*((-1.-vy)*(-1.-vy)))*f7+(((1.-vx)*(1.-vx))*((-1.-vy)*(-1.-vy)))*f8);\n        \n        //=== RELAX TOWARD EQUILIBRIUM ========================\n \t    Pxy = (1.-w)*Pxy;\n  \t    N = (1.-w)*N;\n  \t\tfloat T = 0.66666666666667;\n  \t  \tfloat Qxyy = 0.0;\n        float Qyxx = 0.0;\n        float A = 0.11111111111111;\n        \n\n        f0 = rho*(1.-(vx*vx+vy*vy)+4.*vx*vy*Pxy-(((vx*vx-vy*vy)/2.)*N)+((-2.+vx*vx+vy*vy)/2.)*T+2.*vx*Qxyy+2.*vy*Qyxx+A);\n  \t\tf1 = rho/2.*(vx*vx+vx*(1.-vy*vy)-((2.*vy+4.*vx*vy)*Pxy)+((1.+vx+vx*vx-vy*vy)/2.)*N+((1.-vx-(vx*vx+vy*vy))/2.)*T-((1.+2.*vx)*Qxyy)-2.*vy*Qyxx-A);\n  \t\tf2 = rho/2.*(vy*vy+vy*(1.-vx*vx)-((2.*vx+4.*vx*vy)*Pxy)+((-1.-vy+vx*vx-vy*vy)/2.)*N+((1.-vy-(vx*vx+vy*vy))/2.)*T-((1.+2.*vy)*Qyxx)-2.*vx*Qxyy-A);\n  \t\tf3 = rho/2.*(vx*vx+(-vx)*(1.-vy*vy)-((-2.*vy+4.*vx*vy)*Pxy)+((1.-vx+vx*vx-vy*vy)/2.)*N+((1.-(-vx)-(vx*vx+vy*vy))/2.)*T-((-1.+2.*vx)*Qxyy)-2.*vy*Qyxx-A);\n  \t\tf4 = rho/2.*(vy*vy+(-vy)*(1.-vx*vx)-((-2.*vx+4.*vx*vy)*Pxy)+((-1.-(-vy)+vx*vx-vy*vy)/2.)*N+((1.-(-vy)-(vx*vx+vy*vy))/2.)*T-((-1.+2.*vy)*Qyxx)-2.*vx*Qxyy-A);\n  \t\tf5 = rho/4.*(vx*vy+vx*vy*vy+vy*vx*vx+(1.+4.*vx*vy+2.*vy+2.*vx)*Pxy+((-vx*vx+vy*vy-vx+vy)/2.)*N+((vx*vx+vy*vy+vx+vy)/2.)*T+(1.+2.*vx)*Qxyy+(1.+2.*vy)*Qyxx+A);\n  \t\tf6 = rho/4.*((-vx)*vy+(-vx)*vy*vy+vy*vx*vx+(-1.+4.*vx*vy-2.*vy+2.*vx)*Pxy+((-vx*vx+vy*vy-(-vx)+vy)/2.)*N+((vx*vx+vy*vy-vx+vy)/2.)*T+(-1.+2.*vx)*Qxyy+(1.+2.*vy)*Qyxx+A);\n  \t\tf7 = rho/4.*(vx*vy+(-vx)*vy*vy+(-vy)*vx*vx+(1.+4.*vx*vy-2.*vy-2.*vx)*Pxy+((-vx*vx+vy*vy-(-vx)-vy)/2.)*N+((vx*vx+vy*vy-vx-vy)/2.)*T+(-1.+2.*vx)*Qxyy+(-1.+2.*vy)*Qyxx+A);\n  \t\tf8 = rho/4.*((-vx)*vy+vx*vy*vy+(-vy)*vx*vx+(-1.+4.*vx*vy+2.*vy-2.*vx)*Pxy+((-vx*vx+vy*vy-vx-vy)/2.)*N+((vx*vx+vy*vy+vx-vy)/2.)*T+(1.+2.*vx)*Qxyy+(-1.+2.*vy)*Qyxx+A);\n        \n        #elif PRESET_Non_orthogonal==2 //Non-orthogonal central moments\n        float U=vx;\n        float V=vy;\n        float U2 = U*U;\n\t    float V2 = V*V;\n\t    float UV = U*V;\n\t\tfloat U2V2 = U2*V2;\n        float k4 = ((((-vx)*(-vx)))*f0+(((1.-vx)*(1.-vx)))*f1+(((-vx)*(-vx)))*f2+(((-1.-vx)*(-1.-vx)))*f3+(((-vx)*(-vx)))*f4+(((1.-vx)*(1.-vx)))*f5+(((-1.-vx)*(-1.-vx)))*f6+(((-1.-vx)*(-1.-vx)))*f7+(((1.-vx)*(1.-vx)))*f8)-(((((-vy)*(-vy)))*f0+(((-vy)*(-vy)))*f1+(((1.-vy)*(1.-vy)))*f2+(((-vy)*(-vy)))*f3+(((-1.-vy)*(-1.-vy)))*f4+(((1.-vy)*(1.-vy)))*f5+(((1.-vy)*(1.-vy)))*f6+(((-1.-vy)*(-1.-vy)))*f7+(((-1.-vy)*(-1.-vy)))*f8));\n        float k5 = (((-vx)*(-vy))*f0+((1.-vx)*(-vy))*f1+((-vx)*(1.-vy))*f2+((-1.-vx)*(-vy))*f3+((-vx)*(-1.-vy))*f4+((1.-vx)*(1.-vy))*f5+((-1.-vx)*(1.-vy))*f6+((-1.-vx)*(-1.-vy))*f7+((1.-vx)*(-1.-vy))*f8);\n        k4 *= 1.-w;\n        k5 *= 1.-w;\n        float k3 = rho*2./3.;\n        float k6 = -rho*U2*V;\n        float k7 = -rho*U*V2;\n        float k8 = rho*(1.+27.*U2V2)/9.0;\n        \n        f0 = k3*(-1.+0.5*U2+0.5*V2)+k4*(-U2+V2)+4.*UV*k5+2.*V*k6+2.*U*k7+k8+rho*(1.-U2-V2+U2V2);\n    \tf1 = 0.25*k3*(1.-U-U2-V2)+0.25*k4*(1.+U+U2-V2)+k5*(-V-2.*UV)-V*k6+k7*(-0.5-U)-0.5*k8+0.5*rho*(U+U2-U*V2-U2V2);\n    \tf2 = 0.25*k3*(1.-V-U2-V2)+0.25*k4*(-1.-V+U2-V2)+k5*(-U-2.*UV)+k6*(-0.5-V)-U*k7-0.5*k8+0.5*rho*(V+V2-U2*V-U2V2);\n\t    f3 = 0.25*k3*(1.+U-U2-V2)+0.25*k4*(1.-U+U2-V2)+k5*(V-2.*UV)-V*k6+k7*(0.5-U)-0.5*k8+0.5*rho*(-U+U2+U*V2-U2V2);\n\t    f4 = 0.25*k3*(1.+V-U2-V2)+0.25*k4*(-1.+V+U2-V2)+k5*(U-2.*UV)+k6*(0.5-V)-U*k7-0.5*k8+0.5*rho*(-V+V2+U2*V-U2V2);\n\t    f5 = 0.125*k3*(U+V+U2+V2)+0.125*k4*(-U+V-U2+V2)+k5*(0.25+0.5*U+0.5*V+UV)+k6*(0.25+0.5*V)+k7*(0.25+0.5*U)+0.25*k8+0.25*rho*(UV+U2*V+U*V2+U2V2);\n\t    f6 = 0.125*k3*(-U+V+U2+V2)+0.125*k4*(U+V-U2+V2)+k5*(-0.25+0.5*U-0.5*V+UV)+k6*(0.25+0.5*V)+k7*(-0.25+0.5*U)+0.25*k8+0.25*rho*(-UV+U2*V-U*V2+U2V2);\n\t    f7 = 0.125*k3*(-U-V+U2+V2)+0.125*k4*(U-V-U2+V2)+k5*(0.25-0.5*U-0.5*V+UV)+k6*(-0.25+0.5*V)+k7*(-0.25+0.5*U)+0.25*k8+0.25*rho*(UV-U2*V-U*V2+U2V2);\n\t    f8 = 0.125*k3*(U-V+U2+V2)+0.125*k4*(-U-V-U2+V2)+k5*(-0.25-0.5*U+0.5*V+UV)+k6*(-0.25+0.5*V)+k7*(0.25+0.5*U)+0.25*k8+0.25*rho*(-UV-U2*V+U*V2+U2V2);\n\t\n        #elif PRESET_Non_orthogonal==3 //Cas_Geier\n        \n\t\t//pre-collision mass/momentum source step , update \n              \n        float r = float(iy)+r0;\n        float temp1=vy(xplus,iy);\n        float temp2=vy(xminus,iy);\n        float temp3=vx(ix,yplus);\n        float temp4=vx(ix,yminus);\n        float temp5=vy(ix,yplus);\n        float temp6=vy(ix,yminus);\n                \n               \n        float dxvy =(temp1-temp2)/2.0;\n        float dyvx =(temp3-temp4)/2.0;\n        float dyvy =(temp5-temp6)/2.0;\n        \n        float MA = -rho*vy/r;\n        float FA_x = -rho*vx*vy/r + nu*rho*dxvy/r; \n        float FA_y = -rho*vy*vy/r + 2.0*nu*rho*dyvy/r - 2.0*nu*rho*vy/r/r;\n        \n        rho += MA/2.0 ; //dt=1;\n        vx  += FA_x/2.0 /rho;\n        vy  += FA_y/2.0 /rho;\n    \n      \n        \n        \n        \n        \n        float kxx = f1 + f3 + f5 + f6 + f7 + f8;\n\t\tfloat kyy = f2 + f4 + f5 + f6 + f7 + f8;\n\t\tfloat kxy = f5 + f7 - f6 - f8;\n\t\tfloat kxxy = f5 + f6 - f7 - f8;\n\t\tfloat kxyy = f5 + f8 - f6 - f7;\n\t\tfloat kxxyy = f5 + f6 + f7 + f8;\n\n        //Cas_Geier\n        //float omega3 = 1.0;\n        //float omega4 = 1.0/tau;\n        //float omega5 = 1.0/tau;\n        //float omega6 = 1.0;\n        //float omega7 = 1.0;\n        //float omega8 = 1.0;\n        //Cas_Lalle \n        //float omega3 = 1.64;\n        //float omega4 = 1.0/tau;\n        //float omega5 = 1.0/tau;\n        //float omega6 = 1.9;\n        //float omega7 = 1.9;\n        //float omega8 = 1.54;\n        //Cas_Chavez\n        float omega3 = 1.64;\n        float omega4 = 1.0/tau;\n        float omega5 = 1.0/tau;\n        float omega6 = 0.9;\n        float omega7 = 0.9;\n        float omega8 = 1.54;        \n        \n\n        \n        \n        float g0 = MA/9.0;\n        float g1 = FA_x/6.0;\n        float g2 = FA_y/6.0;\n        \n\t\tfloat g3 = (omega3/12.)*((2.*rho/3.) + rho*((vx*vx) + (vy*vy)) - (kxx + kyy));\n\t\tfloat g4 = (omega4/4.)*(rho*((vx*vx) - (vy*vy)) - (kxx - kyy));\n\t\tfloat g5 = (omega5/4.)*(rho*vx*vy - kxy);\n\t\tfloat g6 = (omega6/4.)*(2.*rho*(vx*vx)*vy + kxxy - 2.*vx*kxy - vy*kxx) - 0.5*vy*(3.*g3 + g4) - 2.*vx*g5;\n\t\tfloat g7 = (omega7/4.)*(2.*rho*vx*(vy*vy) + kxyy - 2.*vy*kxy - vx*kyy) - 0.5*vx*(3.*g3 - g4) - 2.*vy*g5;\n\t\tfloat g8 = (omega8/4.)*(rho/9. + 3.*rho*(vx*vx)*(vy*vy) - (kxxyy - 2.*vx*kxyy - 2.*vy*kxxy + (vx*vx)*kyy + (vy*vy)*kxx + 4.*vx*vy*kxy)) -2.*g3 -0.5*(vy*vy)*(3.*g3 + g4) - 0.5*(vx*vx)*(3.*g3 - g4) - 4.*vx*vy*g5 - 2.*vy*g6 - 2.*vx*g7;\n\n        f0  = f0 + g0 - 4.*(g3 - g8);\n        f1  = f1 + g0 + g1 - g3 + g4 + 2.*(g7 - g8);\n        f2  = f2 + g0 + g2 - g3 - g4 + 2.*(g6 - g8);\n        f3  = f3 + g0 - g1 - g3 + g4 - 2.*(g7 + g8);\n        f4  = f4 + g0 - g2 - g3 - g4 - 2.*(g6 + g8);\n        f5  = f5 + g0 + g1 + g2 + 2.*g3 + g5 - g6 - g7 + g8;\n        f6  = f6 + g0 - g1 + g2 + 2.*g3 - g5 - g6 + g7 + g8;\n        f7  = f7 + g0 - g1 - g2 + 2.*g3 + g5 + g6 + g7 + g8;\n        f8  = f8 + g0 + g1 - g2 + 2.*g3 - g5 + g6 - g7 + g8;\n        \n\n        \n        \n        \n        \n\t\t#endif\n        \n        \n        \n\n        \n       \n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor = vec4(f0,f1,f2,f3);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor = vec4(f4,f5,f6,f7);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rg = vec2(f8);\n    else //stores rho,vx,vy\n        fragColor= vec4(rho,vx,vy,solid);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//for polt velocity or density\n#define PRESET 0 \n//now only bounce-back for solid boundary condition\n#define PRESET_disk_Boundary 1 \n//0: classical; 1: cascaded central moment; 2: Non-orthogonal central moments\n#define PRESET_Non_orthogonal 3\n//0: classical; 1: LES \n#define PRESET_LES 0\n\n\n\n\n\n//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).a;\n\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f6(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f7(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).a;\n\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n\n#define rho(x,y)   texture(iChannel0, (vec2(2*x+1,2*y+1)+0.5)/iResolution.xy).r;\n#define vx(x,y)    texture(iChannel0, (vec2(2*x+1,2*y+1)+0.5)/iResolution.xy).g;\n#define vy(x,y)    texture(iChannel0, (vec2(2*x+1,2*y+1)+0.5)/iResolution.xy).b;\n#define solid(x,y) texture(iChannel0, (vec2(2*x+1,2*y+1)+0.5)/iResolution.xy).a;\n\n//#define T(x,y) texture(iChannel0, (vec2(2*x+1,2*y+1)+0.5)/iResolution.xy).a;\n\n//for pseudo-2D with source including ux,uy\n\n\nconst float cs2 = 1.0 / 3.0;\nconst float  tau= 0.501;\nconst float  nu= ((tau-1.0/2.0)/3.0);\nconst float  C= 0.06;\n\n//channel velocity\n#define VEL_x 0.1\n#define VEL_y 0.0   \n//g = w .* 1 .* (Gx .* ex + Gy .* ey ) ./ cs^2;\n#define Gx 0.0 //bug\n#define Gy 0.0\n\n#define r0 3.0\n\n\n\n// Ft0_8 is equal to  f_i at initial condition\n#define Ft0 0.437777777777778 \n#define Ft1 0.147777777777778\n#define Ft2 0.109444444444444\n#define Ft3 0.081111111111111\n#define Ft4 0.109444444444444\n#define Ft5 0.036944444444444\n#define Ft6 0.020277777777778\n#define Ft7 0.020277777777778\n#define Ft8 0.036944444444444\n        //6--2--5\n        //|  |  |\n        //3--0--1\n        //|  |  |\n        //7--4--8\n\nconst vec2 center_offset     = vec2( 0.0, 0.0);\nconst vec2 east_offset       = vec2( 1.0, 0.0);\nconst vec2 north_offset      = vec2( 0.0, 1.0);\nconst vec2 west_offset       = vec2(-1.0, 0.0);\nconst vec2 south_offset      = vec2( 0.0,-1.0);\nconst vec2 north_east_offset = vec2( 1.0, 1.0);\nconst vec2 north_west_offset = vec2(-1.0, 1.0);\nconst vec2 south_west_offset = vec2(-1.0,-1.0);\nconst vec2 south_east_offset = vec2( 1.0,-1.0);\n\n\n\n\n\n\n\nfloat calc_equilibrium(const in float density, \n                 const in vec2 velocity, \n                 const in ivec2 ij) {\n\n\tint i = ij.x;\n    int j = ij.y;\n    // u . u\n    float velmag = dot(velocity, velocity);\n    // Compute the weight.\n    float weight;\n    if(i == 0 && j == 0) {\n        weight = 4.0 / 9.0;\n    } else if(i == 0 || j == 0) {\n        weight = 1.0 / 9.0;\n    } else {\n        weight = 1.0 / 36.0;\n    }\n\n    // e_i . u\n    float dotprod = float(i) * velocity.x + float(j) * velocity.y;\n\n    float sum = 1.0;\n    sum += (1.0 / cs2) * dotprod;\n    sum += (1.0 / (2.0*cs2 * cs2)) * dotprod * dotprod;\n    sum -= (1.0 / (2.0*cs2) ) * velmag;\n    //if(density == 0.0){\n    //\treturn 0.0;\n    //}\n    return  weight * density * sum;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//fancy function to compute a color from the velocity\nvec4 computeColor(float normal_value)\n{\n    vec3 color;\n    if(normal_value<0.0) normal_value = 0.0;\n    if(normal_value>1.0) normal_value = 1.0;\n    float v1 = 1.0/7.0;\n    float v2 = 2.0/7.0;\n    float v3 = 3.0/7.0;\n    float v4 = 4.0/7.0;\n    float v5 = 5.0/7.0;\n    float v6 = 6.0/7.0;\n    //compute color\n    if(normal_value<v1)\n    {\n      float c = normal_value/v1;\n      color.x = 70.*(1.-c);\n      color.y = 70.*(1.-c);\n      color.z = 219.*(1.-c) + 91.*c;\n    }\n    else if(normal_value<v2)\n    {\n      float c = (normal_value-v1)/(v2-v1);\n      color.x = 0.;\n      color.y = 255.*c;\n      color.z = 91.*(1.-c) + 255.*c;\n    }\n    else if(normal_value<v3)\n    {\n      float c = (normal_value-v2)/(v3-v2);\n      color.x =  0.*c;\n      color.y = 255.*(1.-c) + 128.*c;\n      color.z = 255.*(1.-c) + 0.*c;\n    }\n    else if(normal_value<v4)\n    {\n      float c = (normal_value-v3)/(v4-v3);\n      color.x = 255.*c;\n      color.y = 128.*(1.-c) + 255.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v5)\n    {\n      float c = (normal_value-v4)/(v5-v4);\n      color.x = 255.*(1.-c) + 255.*c;\n      color.y = 255.*(1.-c) + 96.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v6)\n    {\n      float c = (normal_value-v5)/(v6-v5);\n      color.x = 255.*(1.-c) + 107.*c;\n      color.y = 96.*(1.-c);\n      color.z = 0.;\n    }\n    else\n    {\n      float c = (normal_value-v6)/(1.-v6);\n      color.x = 107.*(1.-c) + 223.*c;\n      color.y = 77.*c;\n      color.z = 77.*c;\n    }\n    return vec4(color.r/255.0,color.g/255.0,color.b/255.0,1.0);\n}","name":"Common","description":"","type":"common"}]}