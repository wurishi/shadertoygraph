{"ver":"0.1","info":{"id":"3sBfDG","date":"1590983457","viewed":93,"name":"SmileFaceAnimation","username":"fangyuan267","description":"SmileFace","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["smileface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)     //limit value between 0.0 to 1.0\n\nfloat remap01(float a, float b, float t)  //control graph area\n{\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t)\n{\n\treturn sat((t-a)/(b-a)) * (d-c) +c;\n}\n\nvec2 within(vec2 uv, vec4 rect)     //creat a new small uv box for a part of graph\n{\n    return (uv- rect.xy)/(rect.zw - rect.xy);\n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float smile)\n{   \n    uv -= 0.5;\n    uv.x *= side; //set reverse mirror effect\n    float d = length(uv);\n    \n    vec4 irisCol = vec4(.3, .5, 1.,1.);\n    vec4 col = mix(vec4(1.), irisCol, S(.1,.7, d)*.5);    //circle radius range from 0.1 to 0.7 mix two color\n    col.a = S(.5, .48, d); //length > 0.5 return 0, length < 0.48, return 1, else return smooth value\n    \n    col.rgb *= 1. - S(.45, .5, d)*.5 * sat(-uv.y-uv.x*side);  //eye shadow\n    \n    d = length(uv -m * .4); //pupil move with mouse position\n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d)); //black circle\n    \n    irisCol.rgb *= 1. +S(.3, .05, d);  //linear iris blue color\n    float irisMask = S(.28, .25, d); \n    col.rgb = mix(col.rgb, irisCol.rgb, irisMask);\n    \n    d = length(uv -m * .5);//iris move with mouse position\n    \n    float pupilSize = mix(.4, .16, smile);        //pupil\n    float pupilMask = S(pupilSize, pupilSize * 0.75, d);\n    pupilMask *= irisMask;\n    col.rgb = mix(col.rgb, vec3(0.), pupilMask); \n    \n    float t = iTime;   //highlight animation\n    vec2 offs = vec2(sin(t + uv.y *25.), sin(t + uv.x * 25.));\n    offs *= .01 * (1. -smile);\n    uv += offs;\n    \n    float highlight = S(.09, .08, length(uv-vec2(-.15, .15)));  //highlight\n    highlight += S(.06, .04, length(uv+vec2(-.08, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv, float smile)\n{\n    uv -= 0.5;\n    vec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;              //draw smile mouth curve\n    uv.y -= uv.x*uv.x*3. *smile;\n    uv.x *= mix(2.5, 1., smile);\n    \n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    uv.y *= 1.4;  //teeth\n    uv.x -= .14;\n    uv.y -= uv.x*uv.x*10.;\n    uv.y += (abs(uv.x) *.5 +.1) ;\n    float td = length(uv - vec2(0.1, .6));   \n    \n    vec3 toothCol = vec3(1.)*S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));  \n    \n    \n    uv.y /= 1.6;  //tongue\n    uv.x += .18;\n    uv.y += uv.x*uv.x*0.9;    \n    td = length(uv + vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.55, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv)\n{\n    vec4 col = vec4(0.9, 0.65, 0.1, 1.0);\n    \n    float d = length(uv);\n    col.a = S(.5, .49, d);  //head range\n    \n    float edgeShade = remap01(.35, .5, d);  //edge shadow\n    edgeShade *= edgeShade;\n    col.rgb *= 1. - edgeShade* .5;\n    \n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(.47, .48, d));  //outline\n    \n    float highlight = S(.42, .39, d)*0.75;  //highlight\n    highlight *= remap(.42, -.1, .75, 0., uv.y);  //half linear circle\n    highlight *= S(.18, .19, length(uv-vec2(.21, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    d = length(uv-vec2(.25,-.2));  //cheek blush\n    float cheek = S(.2, .01, d)*0.4;\n    cheek *= S(.17, .16, d);\n    col.rgb = mix(col.rgb, vec3(1.,.1,.1), cheek);\n        \n    return col;\n}\n\nvec4 Soucil(vec2 uv, float smile)\n{\n    float offs = mix(.8, 0., smile);\n    uv.y += offs;  //up down\n    \n    uv.y += uv.x*.9 -mix(.2,.4, smile);  //change curve form\n    uv.x -= mix(.0, .1, smile); //left right\n    uv -= 0.5;\n    vec4 col = vec4(.5, .28, .2, 1.);\n    \n    uv.y += uv.x*uv.x*4.5 *(1.- offs); //change curve radian\n    \n    float d = length(uv);\n    col.a = S(.5, .45, d);\n    \n    float highlight = S(.3, .05, d)*0.5 * smile;  //move with smile time\n    col.rgb = mix(col.rgb, vec3(0.9), highlight);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv, vec2 m, float smile)\n{\n    vec4 col = vec4(0.);\n    \n    float side = sign(uv.x);  //return 1 if uv.x > 0, return 0 if = 0, return -1 if < 0\n    uv.x = abs(uv.x); //mirror effect\n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, m, smile);\n    vec4 mouth = Mouth(within(uv, vec4(-.3, -.44, .3, -.14)), smile);\n    vec4 soucil = Soucil(within(uv, vec4(.08, .33, .35, .39)), smile);\n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    col = mix(col, soucil, soucil.a);  //float mix(floatx,float y,float a )  return x(1-a)+ya\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; //move vec(0.0,0.0) to the center of screen\n    uv.x = uv.x/iResolution.y *iResolution.x;  \n\n    vec2 m = iMouse.xy/iResolution.xy;  //get mouse position\n    m -= .5;\n    \n    float smile = cos(iTime) * 0.5 + .5;  //value 0.0 to 1.0\n    \n    //uv -= m;\n    uv -= m *(.25 - dot(uv, uv));  //change face direction with mouse position\n    //uv += mix(.25, -.25, smile) *(.25 - dot(uv, uv));  //change face direction by time\n\n    // Output to screen\n    fragColor = Smiley(uv, m, smile);\n}","name":"Image","description":"","type":"image"}]}