{"ver":"0.1","info":{"id":"3scBD7","date":"1605215344","viewed":934,"name":"[JFIG] Oeuf de Faberg√©","username":"SimonL","description":"Submission to the Shadertoy JFIG 2020 contest.\n","likes":28,"published":1,"flags":32,"usePreview":1,"tags":["egg","contest","faberge","jfig2020"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Submission to the Shadertoy JFIG 2020 contest\n// Simon LUCAS\n// Student Master at the University of Strasbourg (UNISTRA)\n// Apprentice at the ICUBE lab (UNISTRA)\n//\n// Inspiration : https://tinyurl.com/y5lcr9we\n// 12/11/2020\n\n/////////////////////////////////////////////////\n// Post processing\n//\n\n////////////////////////////////////////////////////\n// bloom function \n// from https://www.shadertoy.com/view/ldVGRh\nvec3 bloom(vec2 coord, vec2 res){\n    const int r = 8;\n\tfloat stddev = float(r) / 3.;\n\n\tvec3 bloom_ = vec3(.0);\n\tfloat w = 0.0;\n\n    vec2 offsetCoord = coord + .5;\n    \n\tconst float threshold = 0.40;\n    ivec2 d = ivec2(1, -1); \n\tfor (int di = -1; di <= 4; ++di) {\n\t\tfor (int o = -r; o <= r; ++o) {\n\t\t\tvec2 of = vec2(o) / stddev;\n\t\t\tfloat weight = exp(-.5 );\n\t\t\tvec3 s = texture(iChannel0, (offsetCoord + vec2(o * d)) / res).xyz;\n\t\t\tbloom_ += weight * max(vec3(.0), s - threshold);\n\t\t\tw += weight;\n\t\t}\n        d.y += 1;\n\t}\n\n    bloom_ /= w * 0.75;\n    \n\tvec3 radiance = texture(iChannel0, coord / res).xyz;\n\tradiance +=  bloom_;\n\treturn radiance;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec3 tex;\n\n    tex = bloom(fragCoord,iResolution.xy);\n    \n    tex *= 2.;\n    \n    fragColor = vec4(tex,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////////////////////\n// Constant\n// \n\n#define PI_1_2 1.57079632679\n#define PI\t   3.14159265359\n#define PI_2   6.28318530718\n\n#define SINT ((sin(iTime) + 1.) / 2.)\n#define T iTime\n\n/////////////////////////////////////////////////\n// Structure\n//\n\nstruct ray\n{\n\tvec3 o;\n\tvec3 d;\n};\n\nstruct inter\n{\n\tfloat t;\n\tvec2 uv;\n\tvec3 p;\n\tvec3 n;\n\tint m;\n};\n    \n/////////////////////////////////////////////////\n// Operation on sdf\n// \n\n#define I(a,b) max(a,b)\n#define U(a,b) min(a,b)\n#define D(a,b) max(a,-b)\n\nfloat Us( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat Ds( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat Is( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\ninter C ( inter a, inter b) {\n    if(a.t < b.t){\n    \treturn a;\n    }\n    \n    return b;\n}\n\n/////////////////////////////////////////////////\n// Rotation\n//\n\nvec3 rotateX(vec3 p, float angle)\n{\n\tmat3 r = mat3(1, 0, 0,\n\t\t\t\t\t0, cos(angle), -sin(angle),\n\t\t\t\t\t0, sin(angle), cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), 0, sin(angle),\n\t\t\t\t0, 1, 0,\n\t\t\t\t-sin(angle),0 , cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), -sin(angle), 0,\n\t\t\t\tsin(angle), cos(angle), 0,\n\t\t\t\t0, 0, 1);\n\treturn r * p;\n}\n\n\n/////////////////////////////////////////////////\n// Coordonate modification \n//\nvec3 cart_to_cylinder(vec3 p){\n\treturn vec3(\n        length(p.xz),\n        atan(p.z/p.x),\n        p.y);\n}\n\nvec3 cylinder_to_cart(vec3 c){\n\treturn vec3(\n    c.x * cos(c.y),\n    c.z,\n    c.x * sin(c.y));\n}\n\n#define DEFORM 1\nvec2 deform( in vec2 p )\n{\n\n    // deform 2\n    #if DEFORM >= 2\n    p += 0.02*cos( 1.5*p.yx + 0.003*1.0*iTime + vec2(0.1,1.1) );\n    p += 0.02*cos( 2.4*p.yx + 0.003*1.6*iTime + vec2(4.5,2.6) );\n    p += 0.02*cos( 3.3*p.yx + 0.003*1.2*iTime + vec2(3.2,3.4) );\n    p += 0.02*cos( 4.2*p.yx + 0.003*1.7*iTime + vec2(1.8,5.2) );\n    p += 0.02*cos( 9.1*p.yx + 0.003*1.1*iTime + vec2(6.3,3.9) );\n    #endif\n    \n    // deform 1\n    #if DEFORM >= 1\n   \n    p = vec2(atan(p.x,p.y),length(p));\n    p*= 11.5;\n\n    #endif\n    return p;\n}\n\n/////////////////////////////////////////////////\n// Signed distance field\n// https://iquilezles.org/articles/distfunctions\n//\nfloat sdfSphere(vec3 p, vec3 c, float r)\n{\n\treturn length(c-p) - r;\n}\n\nfloat sdfBox( vec3 p, vec3 c, vec3 b )\n{\n  vec3 q = abs(c-p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdfTorus( vec3 p, float r1, float r2 )\n{\n  vec2 q = vec2(length(p.xz)-r1,p.y);\n  return length(q)-r2;\n}\n\n//https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\nfloat sdfSpiral(vec2 p, float a, float b){\n  // calculate the target radius and theta\n  float r = length(p);\n  float t = atan(p.y, p.x);\n \n  // early exit if the point requested is the origin itself\n  // to avoid taking the logarithm of zero in the next step\n  if (r == 0.)\n    return 0.;\n \n  // calculate the floating point approximation for n\n  float n = (log(r/a)/b - t)/(PI_2);\n \n  // find the two possible radii for the closest point\n  float upper_r = a * exp(b * (t + PI_2*ceil(n)));\n  float lower_r = a * exp(b * (t + PI_2*floor(n)));\n \n  // return the minimum distance to the target point\n  return min(abs(upper_r - r), abs(r - lower_r));\n}\n\n                    \n\n/////////////////////////////////////////////////\n// Normal mapping utilities\n//\n\n// https://www.shadertoy.com/view/WdXfRn\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n\n\nmat3 tbn(vec3 n)\n{   \n    return orthonormal_basis(n);\n    /*\n    vec3 tangent = \t   dPdX * dUVdy.y - dPdY * dUVdx.y;\n    vec3 bitangent = - dPdX * dUVdy.x + dPdY * dUVdx.x;\n \tfloat f = 1.0 / (dUVdx.x * dUVdy.y - dUVdy.x * dUVdx.y);\n    \n    return mat3(normalize(tangent  *f),\n                normalize(bitangent*f),\n                n );\n\t*/\n}\n\nvec3 mapping_normal(vec2 uv, vec2 dUVdx, vec2 dUVdy,mat3 tbn, sampler2D channel )\n{\n    float t  = texture(channel, uv ).x;\n    float tx = texture(channel, uv + dUVdx).x;\n    float ty = texture(channel, uv + dUVdy).x;\n    float dx = tx - t;\n    float dy = ty - t;\n    vec3 map = normalize(vec3(dx, dy , 1.)) * .5 + .5;\n    \n   \tmap = map * 2. - 1.;\n    return normalize(tbn * map);\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////\n// Constant\n//\n\n#define MAX_DISTANCE 40.\n#define TRACE_EPSILON 0.01\n\n#define NORMAL_EPSILON 0.001\n\n#define FILTERING_COEF 1.\n\n\n/////////////////////////////////////////////////\n// Procedural texture\n// More info :\n//\t - https://www.shadertoy.com/view/Wd3fDn\n//\t - https://www.shadertoy.com/view/ts3BWn\n// \n\nfloat fcos( float u )\n{\n    float w = fwidth(u);\n    return cos(u) * sin(FILTERING_COEF*w)/(FILTERING_COEF*w);\n}\n\nfloat dfcos( float u, float f)\n{\n    float w = fwidth(u);\n    float dw = fwidth(w);\n    \n    return ( (-f * sin(u) * sin(FILTERING_COEF*w) + cos(u) * FILTERING_COEF * dw * cos(FILTERING_COEF * w) ) * (FILTERING_COEF*w) - cos(u) * sin(FILTERING_COEF * w) * (FILTERING_COEF*dw) )/ pow(FILTERING_COEF*w,2.);\n}\n\nfloat getIntensityFilteredGrad( in float t )\n{\n    float grad = 0.;\n    grad += 0.40*dfcos(t*  1.0+ 0.6, 1.0);\n    grad += 0.20*dfcos(t*  3.1+ 1.0, 3.1);\n    grad += 0.20*dfcos(t*  5.1+ 1.1, 5.1);\n    grad += 0.10*dfcos(t*  9.1+ 1.2, 9.1);\n    grad += 0.10*dfcos(t*  13.1+ 1.9, 13.1);\n    return grad * 0.5;\n}\n\n\nfloat getIntensityFiltered( in float t )\n{\n    float i = 0.0;\n    i += 0.4*fcos(t*  1.0+0.6);\n    i += 0.2*fcos(t*  3.1+1.0);\n    i += 0.2*fcos(t*  5.1+1.1);\n    i += 0.1*fcos(t*  9.1+1.2);\n    i += 0.1*fcos(t*  13.1+1.9);\n    return i;\n}\n\n/////////////////////////////////////////////////\n// JFIG bitfield\n//\n\n#define JFIGW 32u\n#define JFIGH 12u\nuint[] jfig_bitfield = uint[](0x0u,\n                              0x0u,\n                              0x0u,\n                              0xf97800u,\n                              0x90900u,\n                              0xc91800u,\n                              0x890900u,\n                              0xf90900u,\n                              0x180u,\n                              0x0u,\n                              0x0u,\n                              0x0u );\n\n\nuint[] _2020_bitfield = uint[](0x0u,\n                              0x0u,\n                              0x0u,\n                              0x30e30e0u,\n                              0x4904900u,\n                              0x49e49e0u,\n                              0x4824820u,\n                              0x31e31e0u,\n                              0x0u,\n                              0x0u,\n                              0x0u );\n\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\nbool _2020(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (_2020_bitfield[id/32u] & (1u << (id&31u)));\n}\n\n\n/////////////////////////////////////////////////\n// Sdf functions of the scene elements\n// \n\n// Floor\ninter sdfFloor(vec3 p)\n{    \n\tinter i;\n\ti.m = 1;\n    i.uv = p.xz;\n    i.t = p.y + 0.47;\n\treturn i;\n}\n\n// Sign\ninter sdfSign(vec3 p)\n{\n\n    inter i;\n    p *= 1.2;\n    p = rotateX(p,-0.32);\n    p -= vec3(0.,-0.46,1.35);\n    float t = sdfBox(p,vec3(0.),vec3(0.75 ,0.45,0.05));\n    \n    i.uv =  p.xy;\n\ti.uv.x = -i.uv.x;\n    \n\n    vec2 id = floor(i.uv * 16.)+ vec2(16.,3.);\n\n    i.m = 2;\n    \n    if(jfig(uint(id.x), uint(id.y)) ||\n       _2020(uint(id.x), uint(id.y+ 7.)))\n    {\n    \ti.m = 3; // jfig letters\n        t -= 0.05;\n    }\n\n    float tt = sdfBox(p,vec3(0.),vec3(0.83 ,0.53,0.1));\n    tt = D(tt,sdfBox(p,vec3(0.),vec3(0.75 ,0.45,0.2)));\n    \n    t = U(t,tt);\n    if(t == tt)\n    \ti.m = 4; // sign's border\n    i.t = t;\n    \n    return i;\n    \n}\n\n// Table\ninter sdfTable(vec3 p)\n{\n\tinter i;\n   \n    p.y += 0.16;  \n    \n    float t = sdfCappedCylinder(p - vec3(0.,-0.25,0.),0.75,0.03);\n    t = Us(t,sdfCappedCylinder(p - vec3(0.,0.2,0.),0.1,0.5),0.5);\n    i.m = 5; // foot\n    \n    \n    float tt = sdfCappedCylinder(p - vec3(0.,0.65,0.),1.0,0.05);\n    t = U(t,tt);\n    if(t == tt){\n    \ti.m = 6; // table;\n    }\n    \n    tt = sdfTorus(p- vec3(0.,0.65,0.), 1.,0.065 );\n    t = U(tt,t);\n    if(t == tt){\n    \ti.m = 7; // table edge;\n    }\n    \n    i.uv = p.xz;\n    i.t = t;\n    \n    return i;\n}\n\n//Egg\ninter sdfEgg(vec3 p)\n{\n    inter i;\n    i.m = 8; // egg\n    \n    ///////////////\n    // set position\n    \n    p.y -= 0.6;\n    \n    //////////////////////\n    // mirror X and Z axis\n    \n    p.z = -abs(p.z);\n    p.x = abs(p.x);\n   \tp = rotateY(p,PI * 0.25);\n    p = rotateZ(p,-(sin(iTime * 0.5) * 0.5 + 0.5) * 0.5);\n    p = rotateY(p,PI * 0.25);\n\n    ////////////\n    // egg shape\n    \n    float t = sdfSphere(p,vec3(0.,1.,0.),1.);\n    \t  t = Us(t, sdfSphere(p,vec3(0.,2.0,0.),0.5),1.0);\n  \t\n    \n    ///////////////\n    // border shape\n    \n    float tt = t;\n    tt = Is(tt,sdfBox(p,vec3(0.03,1.,0.),vec3(0.02,4.,10.)),0.1);\n    tt = Us(tt,Is(t,sdfBox(p,vec3(0.,1.,0.03),vec3(10.,4.,0.02)),0.1),0.02);\n    \n    \n    /////////\n    // Spiral\n    \n    vec3 pp = rotateY(p,-0.1);\n    pp = cart_to_cylinder(pp - vec3(0.,0.5,0.));\n    \n    pp.xyz -= vec3(0.7,0.7,0.7);\n    \n    float ttt = sdfSpiral(pp.yz,1.,0.13) - 0.06;\n    \n    pp = cylinder_to_cart(pp);\n    \n    ttt = Is(ttt,Us(sdfSphere(p,vec3(0.,1.,0.),1.07),sdfSphere(p,vec3(0.,2.0,0.),0.54),1.),0.2);\n    t = U(t,ttt);\n    if(t == ttt)\n    \ti.m = 9; // egg's border\n    \n    ////////////////////////////////\n    // distorsion on the egg surface\n    float radius = 0.;\n    float waves = 15.;\n    float waveSize = 0.01;\n\n    radius -= abs(cos(atan(p.x,p.z) * 15.) * 0.01) + abs(cos(p.y * PI * 15. / 2.) * 0.01);\n\n    t += radius * 0.5;\n\n    t = U(t,tt);\n    /////////////////////\n    // mix border and egg\n    \n    tt -= 0.04;\n    t = U(t,tt);\n    if(t == tt)\n        i.m = 9; // egg's border\n    \n\n    \n    ///////////////\n    // Remove 3 / 4\n    \n    t = D(t,sdfBox(p,vec3(0.,4.,-4.),vec3(4.)));\n    t = D(t,sdfBox(p,vec3(-4.,4.,0.),vec3(4.)));\n    \n\t////////////\n    // Add pearl\n    \n    tt = sdfSphere(p,vec3(0.7,1.22,0.7),0.1);\n    tt = U(tt,sdfSphere(p,vec3(0.95,1.17,0.315),0.05));\n    tt = U(tt,sdfSphere(p,vec3(0.905,0.812,0.435),0.05));\n    tt = U(tt,sdfSphere(p,vec3(0.629,0.635,0.7117),0.05));\n    tt = U(tt,sdfSphere(p,vec3(0.246,0.82,0.955),0.05));\n    tt = U(tt,sdfSphere(p,vec3(0.31,1.9,0.74),0.05));\n    tt = U(tt,sdfSphere(p,vec3(0.51,2.07,0.51),0.05));\n\ttt = U(tt,sdfSphere(p,vec3(0.69,2.03,0.26),0.05));\n    \n    ttt = sdfSphere(p,vec3(0.63,1.21,0.63),0.17);\n    ttt = U(ttt,sdfSphere(p,vec3(0.89,1.165,0.295),0.1));\n    ttt = U(ttt,sdfSphere(p,vec3(0.84,0.82,0.402),0.1));\n\tttt = U(ttt,sdfSphere(p,vec3(0.59,0.652,0.663),0.1));\n    ttt = U(ttt,sdfSphere(p,vec3(0.229,0.83,0.895),0.1));\n    ttt = U(ttt,sdfSphere(p,vec3(0.288,1.875,0.686),0.1));\n    ttt = U(ttt,sdfSphere(p,vec3(0.47,2.038,0.47),0.1));\n\tttt = U(ttt,sdfSphere(p,vec3(0.64,2.0,0.24),0.1));\n    \n    float tttt = Ds(tt,ttt,0.05);\n    tt = U(tt,tttt);\n    \n    t = U(tt,t);\n    if(t == tt)\n    \ti.m = 10; // pearl\n\tif(t == tttt)\n        i.m = 9; // contour\n\t\n    \n    \n    ///////////////////////////////////\n    // hollow out the inside of the egg\n    \n    tt = Us(sdfSphere(p,vec3(0.,1.,0.),0.9),sdfSphere(p,vec3(0.,2.0,0.),0.45),1.);\n    t = D(t,tt);\n    if(t > tt)\n    \ti.m = 10; // inside egg\n    \n\n    i.uv = vec2(atan(p.x/p.z),atan(p.y - 1.5));\n    \n    i.t = t;\n    return i;\n}\n\n/////////////////////////////////////////////////\n// Scene composition\n// \ninter scene(vec3 p){\n    inter floor_ = sdfFloor(p);\n    inter table_ = sdfTable(p);\n    inter egg_ = sdfEgg(p);\n    inter sign_ = sdfSign(p);\n    \n    inter i;\n    i.m = 0;\n    i.t = 900.;\n    \n   \ti = C(floor_,i);\n    i = C(table_,i);\n   \ti = C(egg_,i);\n    i = C(sign_,i);\n\n    return i;\n}\n\n/////////////////////////////////////////////////\n// Normal computation\n// \nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + NORMAL_EPSILON, p.y, p.z)).t - scene(vec3(p.x - NORMAL_EPSILON, p.y, p.z)).t,\n        scene(vec3(p.x, p.y + NORMAL_EPSILON, p.z)).t - scene(vec3(p.x, p.y - NORMAL_EPSILON, p.z)).t,\n        scene(vec3(p.x, p.y, p.z + NORMAL_EPSILON)).t - scene(vec3(p.x, p.y, p.z - NORMAL_EPSILON)).t\n    ));\n}\n\n/////////////////////////////////////////////////\n// Ambient occlusion\n// \nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    \n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = scene(p + n*hr).t;\n        occ += (hr - d)*sca;\n        sca *= .7;\n\t\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n/////////////////////////////////////////////////\n// Raymarching function\n// \ninter trace(ray r)\n{\t\t\n\tinter i;\n\tfloat t = 0.0;\n\tvec3 p;\n\twhile(t <= MAX_DISTANCE)\n\t{\n\t\tp = r.o + r.d * t;\n\t\ti = scene(p);\t\t\n        t += i.t*0.5;\n        if(i.t <= TRACE_EPSILON){\n        \ti.p = p;\n            i.n = normal(p);\n            return i;\n        }\n\t}\n\ti.t = t;\n\ti.p = p;\n\ti.n = normal(p);\n\treturn i;\n}\n\n\n/////////////////////////////////////////////////\n// Shading functions\n// \nfloat ndf(vec3 n, vec3 h, float r){\n    float cos_theta = dot(n,h);\n    float cos2_theta = cos_theta * cos_theta;\n    return max(0.000001,(1.0 / (PI*r*cos2_theta*cos2_theta)) * exp((cos2_theta-1.)/(r*cos2_theta)));\n}\n\nvec3 specular(vec3 v, vec3 l, vec3 n, vec3 h, float r){\n    r = r*r;\n    return vec3(ndf(n,h, r)) / vec3(4. * max(abs(dot(v,n)),0.2) * abs(dot(l,n))) * max(dot(l, n),-0.0);\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 iridescence(float t){\n    return vec3(0.5) + vec3(0.5)*cos( 6.28318*(vec3(1.)*t+vec3(0.00, 0.33, 0.67)) );\n\n}\n\n\nvec3 shade(ray r, ray rdx, ray rdy){\n    vec3 final = vec3(0.);\n    inter i = trace(r);\n    if(i.t < MAX_DISTANCE){\n        vec3 Pdx = rdx.o - rdx.d*dot(rdx.o-i.p,i.n)/dot(rdx.d,i.n);\n\t\tvec3 Pdy = rdy.o - rdy.d*dot(rdy.o-i.p,i.n)/dot(rdy.d,i.n);\n        \n        inter idx = scene(Pdx);\t\n    \tinter idy = scene(Pdy);\n\n        vec2 dUVdx = idx.uv - i.uv;\n        vec2 dUVdy = idy.uv - i.uv;\n        \n        mat3 tbn_ = tbn(i.n);\n        \n        vec3 lp = vec3(4.*sin(iTime),6.,4.*cos(iTime));\n        vec3 l = normalize(lp - i.p);\n\t\tvec3 h = normalize(l-r.d);\n        \n        float li = 27.5 / (distance(i.p,lp) * distance(i.p,lp));\n        \n        vec3 a,c,rr,n,nn = vec3(1.);\n\t\t\n        switch(i.m) {\n         case 1: // ground\n            \n            vec2 q = deform(i.p.xz);\n            float v1 = getIntensityFiltered(q.x);\n            float v2 = getIntensityFiltered(q.y);\n            float v = min(v1,v2);\n            \n            if(v == v1){\n            \tn.x = -getIntensityFilteredGrad(q.x);\n                n.y = sqrt(1. - pow(n.x,2.));\n                n.z = 0.;\n            } else {\n            \tn.x = 0.;\n                n.z = -getIntensityFilteredGrad(q.y);\n                n.y = sqrt(1. - pow(n.z,2.));\n            }\n            v = pow(v,2.);\n            a = v * vec3(1.,0.,0.) + (1. - v) * 0.2 * vec3(1. - q.y / 50.,0.,0.);        \n            c = a * 0.6 + specular(-r.d, l, n, h,0.3) * 0.4;\n         \tbreak;   \n            \n        case 2: // sign\n        \t    \n        \ta = vec3(0.9,0.9,0.8) / PI;\n            nn = mapping_normal(i.uv,dUVdx,dUVdy,tbn_,iChannel2);\n            n = nn;\n            float t_iri = max(dot(n,-r.d),0.);\n            vec3 iri = iridescence(t_iri - 0.25 + textureLod(iChannel2,i.uv * 0.5, 0.).x );\n            a = mix(vec3(1.,1.,1.) / PI ,iri / PI,pow(abs(1. - t_iri),4.));\n            a += textureLod(iChannel1,n,8.).xyz / PI;\n            rr = normalize(reflect(r.d,n));\n            c = a * 0.8 + a * specular(-r.d, l, n, h, 0.5) * 0.18 + a * specular(-r.d, l, n, h, 0.05)* 0.02;\n        \tbreak;\n            \n        case 3: // jfig\n        \n            a = vec3(0.9,0.0,0.) / PI;\n            nn = mapping_normal(i.uv * 0.25,dUVdx * 0.25,dUVdy * 0.25,tbn_,iChannel3);\n            n = nn;\n            rr = normalize(reflect(r.d,n));\n            c = a * 0.8 + specular(-r.d, l, n, h, 0.2) * 0.2;\n        \tbreak;\n            \n        case 4: // sign's border\n            \n            a = vec3(0.9,0.0,0.) / PI;\n            nn = mapping_normal(i.uv * 0.25,dUVdx * 0.25,dUVdy * 0.25,tbn_,iChannel3);\n            n = nn;\n            a = mix(a,vec3(0.9,0.8,0.1) /PI , 1. - dot(n,-r.d) );\n            rr = normalize(reflect(r.d,n));\n            c = a * 0.8 + specular(-r.d, l, n, h, 0.2) * 0.2;\n        \tbreak;\n            \n        case 5: // foot\n        \n            a = texture(iChannel0,i.uv * 0.5).xyz / PI;\n            nn = mapping_normal(i.uv * 0.5 + 0.5,dUVdx * 0.5,dUVdy * 0.5,tbn_,iChannel0);\n            n = nn;\n            rr = normalize(reflect(r.d,n));\n            c = a * 0.95 + specular(-r.d, l, n, h, 0.01 + a.x * 0.6) * 0.05;\n        \tbreak;\n            \n        case 6: // table\n        \n            a = texture(iChannel0,i.uv * 0.5).xyz / PI;\n            nn = mapping_normal(i.uv * 0.5 + 0.5,dUVdx * 0.5,dUVdy * 0.5,tbn_,iChannel0);\n            n = nn;\n            rr = normalize(reflect(r.d,n));\n            c = a * 0.95 + specular(-r.d, l, n, h, 0.01 + a.x * 0.6) * 0.05;\n        \tbreak;\n            \n        case 7: // table's border\n        \n            a = vec3(0.4,0.3,0.) / PI;\n            nn = mapping_normal(i.uv,dUVdx,dUVdy,tbn_,iChannel2);\n            n = nn;\n            rr = normalize(reflect(r.d,n));\n            a += pow(textureLod(iChannel1,rr,4.).xyz,vec3(1.)) / PI;\n            c = a * 0.95 + 0.05 * specular(-r.d, l, n, h, 0.1);\n        \tbreak;\n            \n        case 8: // egg\n        \n            a = vec3(0.9,0.9,0.8) / PI;\n            nn = mapping_normal(i.uv,dUVdx,dUVdy,tbn_,iChannel2);\n            n = nn;\n            t_iri = max(dot(n,-r.d),0.);\n            iri = iridescence(t_iri - 0.25 + textureLod(iChannel2,i.uv * 0.5, 0.).x );\n            a = mix(vec3(1.,1.,1.) / PI ,iri / PI,pow(abs(1. - t_iri),4.));\n            a += textureLod(iChannel1,n,8.).xyz / PI;\n            rr = normalize(reflect(r.d,n));\n            c = a * 0.8 + a * specular(-r.d, l, n, h, 0.5) * 0.18 + a * specular(-r.d, l, n, h, 0.05)* 0.02;\n        \tbreak;\n            \n        case 9: // egg's border\n        \t\n            a = vec3(0.4,0.3,0.) / PI;\n            nn = mapping_normal(i.uv.yy * 0.5,dUVdx * 0.5,dUVdy * 0.5,tbn_,iChannel3);\n            n = nn;\n            rr = normalize(reflect(r.d,n));\n            a += pow(textureLod(iChannel1,rr,4.).xyz,vec3(1.)) / PI;\n            c = a * 0.8 + 0.2 * specular(-r.d, l, n, h, 0.1);\n        \tbreak;\n            \n        case 10: // egg's inside\n        \n            a = vec3(0.9,0.0,0.) / PI;\n            nn = mapping_normal(i.uv,dUVdx,dUVdy ,tbn_,iChannel3);\n            n = nn;\n            a = mix(a,vec3(0.9,0.8,0.1) /PI , 1. - dot(n,-r.d) ); // pseudo iridescence\n            rr = normalize(reflect(r.d,n));\n            c = a * 0.8 + specular(-r.d, l, n, h, 0.2) * 0.2;\n        \tbreak;\n            \t\t\n        }\n        \n        final = c * li;\n        final *= calcAO(i.p, n);\n\n    }\n    return final;\n}\n\n/////////////////////////////////////////////////\n// Camera function, ray generation\n// \nray camera(vec3 o, vec3 p, vec2 uv, float rx, float ry){\n\tray r;\n    \n    r.o = o;\n    r.o = rotateX(r.o, rx);\n    r.o = rotateY(r.o, ry);\n\n    vec3 f = normalize(p-r.o);\n    vec3 t = cross(vec3(0., 1. + 0.3, 0.), f);\n    vec3 u = cross(f, t);\n\n    vec3 c = r.o + f;\n    vec3 i = c + uv.x*t + uv.y*u;\n    r.d = i-r.o;\n    \n    return r;\n}\n\n/////////////////////////////////////////////////\n// Main\n// \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= ratio;\n    \n    vec2 mouse = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n\n    float camRotX = mouse.y * 0.5;\n\tfloat camRotY = mouse.x;\n    \n    \n\tray r   = camera(vec3(1.,2.,4.),vec3(0.,1.2,0.),uv,camRotX,camRotY);\n\tray rdx = camera(vec3(1.,2.,4.),vec3(0.,1.2,0.),uv+vec2(1.,0.) / iResolution.xy * ratio ,camRotX,camRotY);\n\tray rdy = camera(vec3(1.,2.,4.),vec3(0.,1.2,0.),uv+vec2(0.,1.) / iResolution.xy         ,camRotX,camRotY);\n    \n    \t\n\tvec3 color = shade(r,rdx,rdy);\n    \n    fragColor = vec4(color,1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}