{"ver":"0.1","info":{"id":"cll3RM","date":"1671570244","viewed":124,"name":"Ray X Arc2D intersection","username":"MrShoor","description":"Example of ray vs arc intersection","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","raytracing","arc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//use mouse to choose ray direction\n\n\n#define INF 100000.0\n\nfloat cross2d(vec2 a, vec2 b)\n{\n   return a.x * b.y - a.y * b.x;\n}\n\nbool inArcSide(vec2 p, float radius, vec2 chord_pt1, vec2 chord_dir) {\n  return cross2d(radius * p - chord_pt1 * length(p), chord_dir) > 0.0;\n}\n\nfloat arcDist(vec2 p, float radius, vec2 chord_pt1, vec2 chord_dir) {\n  vec2 pt1_dir = chord_pt1 - p;\n  vec2 pt2_dir = pt1_dir + chord_dir;\n  float dEnd = sqrt(min(dot(pt1_dir, pt1_dir), dot(pt2_dir, pt2_dir)));\n  float dRad = length(p);\n  if (inArcSide(p, radius, chord_pt1, chord_dir))\n    return min(abs(radius - dRad), dEnd);\n  return dEnd;\n}\n\nfloat cirRaytrace(vec2 ro, vec2 rd, float radius) {\n  float A = dot(rd, rd);\n  float B = 2.0*dot(ro, rd);\n  float C = dot(ro, ro) - radius*radius;\n  float D = B*B - 4.0*A*C;\n  if (D < 0.0) return INF;\n  D = sqrt(D);\n  float t = (-B-D) / (2.0*A);\n  if (t > 0.0) return t;\n  t = (-B+D) / (2.0*A);\n  if (t > 0.0) return t;\n  return INF;\n}\n\nfloat arcThinRaytrace(vec2 ro, vec2 rd, float radius, vec2 chord_pt1, vec2 chord_dir) {\n  float A = dot(rd, rd);\n  float B = 2.0*dot(ro, rd);\n  float C = dot(ro, ro) - radius*radius;\n  float D = B*B - 4.0*A*C;\n  if (D < 0.0) return INF;\n  D = sqrt(D);\n  float t = (-B-D) / (2.0*A);\n  if (t > 0.0 && inArcSide(ro+rd*t, radius, chord_pt1, chord_dir)) return t;\n  t = (-B+D) / (2.0*A);\n  if (t > 0.0 && inArcSide(ro+rd*t, radius, chord_pt1, chord_dir)) return t;\n  return INF;\n}\n\nfloat arcThickRaytrace(vec2 ro, vec2 rd, vec2 angles, float radius, float width, out vec2 n) {\n  vec2 cs1 = vec2(cos(angles.x), sin(angles.x));\n  vec2 cs2 = vec2(cos(angles.y), sin(angles.y));\n  vec2 cs_dir = cs2 - cs1;\n  vec2 pt1 = cs1 * radius;\n  vec2 pt2 = cs2 * radius;\n  \n  if (arcDist(ro, radius, pt1, cs_dir*radius) <= width) return 0.0;\n    \n  float r_in = radius - width;\n  float r_out = radius + width;\n  float t_min = INF;\n  float t = arcThinRaytrace(ro, rd, r_in, cs1*r_in, (cs_dir)*r_in);\n  if (t < t_min) {\n    t_min = t;\n    n = -ro - rd*t;\n  }\n  t = arcThinRaytrace(ro, rd, r_out, cs1*r_out, (cs_dir)*r_out);\n  if (t < t_min) {\n    t_min = t;\n    n = ro + rd*t;\n  }\n  t = cirRaytrace(ro - pt1, rd, width);\n  if (t < t_min) {\n    t_min = t;\n    n = ro + rd*t - pt1;\n  }\n  t = cirRaytrace(ro - pt2, rd, width);\n  if (t < t_min) {\n    t_min = t;\n    n = ro + rd*t - pt2;\n  }\n  return t_min;\n}\n\nvec2 pix2space(vec2 p) {\n  return p - iResolution.xy*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord - iResolution.xy*0.5;\n    \n    float ang_start = 3.14 * sin(iTime*0.5) + 3.14;\n    float ang_end = ang_start + 3.13 * cos(iTime*0.3) + 3.15;\n    \n    vec2 ro = pix2space(fragCoord);\n    vec2 rd = -pix2space(iMouse.xy);\n    vec2 light_dir = normalize(vec2(0.75, 0.3));\n    vec2 n = light_dir;    \n    float t = arcThickRaytrace(ro, rd, vec2(ang_start, ang_end), 250.0, 50.0, n);\n    vec3 dist_color = vec3(0.0);\n    if (t != INF) {\n        float d = t*0.5*length(rd);\n        dist_color = t==INF ? vec3(0.0) : mix(vec3(0.0,0.0,0.3), d<3.14?vec3(1.0) : vec3(0.2,0.5,0.8), (cos(d)+1.0)*0.5);\n    }\n    n = normalize(n);\n    dist_color *= abs(dot(n, -light_dir));\n    fragColor = vec4(dist_color.x, dist_color.y, dist_color.z ,1.0);\n}","name":"Image","description":"","type":"image"}]}