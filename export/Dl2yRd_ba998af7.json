{"ver":"0.1","info":{"id":"Dl2yRd","date":"1692189968","viewed":46,"name":"Ising model","username":"chaddon","description":"Monte Carlo simulation of the Ising model. Probably not completely rigorous.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["simulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float s = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    \n    if(s == 1.0) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// temperature\nfloat t = 1.0;\n\n// right xorshift\nuint xorshr(uint b, uint x) {\n    return x ^ (x >> b);\n}\n\n// take the b highest bits of x\nuint hi(uint b, uint x) {\n    return x >> (32u - b);\n}\n\n// take the b lowest bits of x\nuint lo(uint b, uint x) {\n    return (x << (32u - b)) >> (32u - b);\n}\n\n// controlled right xorshift\n// xorshift by a value depending on the b highest bits of x\nuint cxorshr(uint b, uint x) {\n    uint c = hi(b, x) + 1u;\n    uint r = lo(32u - b, x);\n    return c | xorshr(c, r);\n}\n\nuint hash(uint x) {\n    // single lcg step\n    x = x * 0x5897f487u + 0x55e2f1d0u;\n    \n    // output function\n    x = cxorshr(2u, x);\n    x *= 0x5897f487u;\n    x = xorshr(16u, x);\n    return x;\n}\n\nfloat s(ivec2 x) {\n    return texelFetch(iChannel0, ivec2(x.x % int(iResolution.x), x.y % int(iResolution.y)), 0).x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 x = ivec2(fragCoord);\n    \n    float r = float(hash(\n        uint(x.x) + \n        uint(x.y) * uint(iResolution.x) + \n        uint(iFrame) * uint(iResolution.x) * uint(iResolution.y)\n    )) / float(0xffffffffu);\n    \n    if(iFrame == 0) {\n        if(r > 0.5) {\n            fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n        } else {\n            fragColor = vec4(-1.0, 0.0, 0.0, 0.0);\n        }\n    } else if((x.x + x.y + iFrame) % 2 == 0) {\n        float s_start = s(x);\n        float s_flipped = -s_start;\n        \n        float e_start =\n            (s_start == s(x + ivec2(1, 0)) ? -1.0 : 0.0) +\n            (s_start == s(x - ivec2(1, 0)) ? -1.0 : 0.0) +\n            (s_start == s(x + ivec2(0, 1)) ? -1.0 : 0.0) +\n            (s_start == s(x - ivec2(0, 1)) ? -1.0 : 0.0);\n            \n        float e_flipped =\n            (s_flipped == s(x + ivec2(1, 0)) ? -1.0 : 0.0) +\n            (s_flipped == s(x - ivec2(1, 0)) ? -1.0 : 0.0) +\n            (s_flipped == s(x + ivec2(0, 1)) ? -1.0 : 0.0) +\n            (s_flipped == s(x - ivec2(0, 1)) ? -1.0 : 0.0);\n            \n        if(e_flipped < e_start) {\n            fragColor = vec4(s_flipped, 0.0, 0.0, 0.0);\n        } else {\n            if(r < exp(-(e_flipped - e_start) / t)) {\n                fragColor = vec4(s_flipped, 0.0, 0.0, 0.0);\n            } else {\n                fragColor = vec4(s_start, 0.0, 0.0, 0.0);\n            }\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, x, 0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}