{"ver":"0.1","info":{"id":"Ml2GDd","date":"1433841696","viewed":222,"name":"music visualizer circles","username":"KitVanDeBunt","description":"combined two of my previous shaders to make this one","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["music","visualizer","normalmaps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// used\n// https://www.shadertoy.com/view/XdX3z2 music visualizer\n// https://www.shadertoy.com/view/Xlj3Dt music map\n// https://www.shadertoy.com/view/Ml2GWd normalmap\n\n// atan2 en lerp:\n// http://http.developer.nvidia.com/Cg/index_stdlib.html\n\n// colors\n// https://color.adobe.com/nl/Mijn-Kuler-thema-color-theme-4149936/?showPublished=true\n\n#define PI 3.14159265359\n\n#define twoThirdPI 3.14159265359/3.0*2.0\n#define twelfthPI 3.14159265359/12.0\nvec3 lightPos = vec3(0.5,0.5,0.2);\n\n#define bars 10.0\t\t\t\t// How many buckets to divide spectrum into\n#define barSize 0.2 / bars\t\t// Constant to avoid division in main loop\n#define barGap 0.1 * barSize\t// 0.1 represents gap on both sides, so a bar is\n#define sampleSize 0.1\t\t\t// How accurately to sample spectrum, must be a factor of 1.0\n\n#define circleRadius 0.1;\n\n#define c1 vec4(0.24)\t\t\t\t// grey\n#define c2 vec4(.71,.32,.36,1.0)\t// red\n#define c3 vec4(.91,.64, .0,1.0)\t// yello\n#define c4 vec4(.27,.48,.44,1.0)\t// green\n#define c5 vec4(.21,.40,.51,1.0)\t// blue\n\n\n#define colorOnCenter c1*1.5\n#define colorOff (c5*4.0)\n#define colorOn (c1*10.0)\n\n\nfloat lerp(float a, float b, float t)\n{\n  return a + t*(b-a);\n}\n\nvec4 lerp(vec4 a, vec4 b, float t)\n{\n  return a + t*(b-a);\n}\n\nfloat atan2(float y, float x)\n{\n  float t0, t1, t2, t3, t4;\n\n  t3 = abs(x);\n  t1 = abs(y);\n  t0 = max(t3, t1);\n  t1 = min(t3, t1);\n  t3 = float(1) / t0;\n  t3 = t1 * t3;\n\n  t4 = t3 * t3;\n  t0 =         - float(0.013480470);\n  t0 = t0 * t4 + float(0.057477314);\n  t0 = t0 * t4 - float(0.121239071);\n  t0 = t0 * t4 + float(0.195635925);\n  t0 = t0 * t4 - float(0.332994597);\n  t0 = t0 * t4 + float(0.999995630);\n  t3 = t0 * t3;\n\n  t3 = (abs(y) > abs(x)) ? float(1.570796327) - t3 : t3;\n  t3 = (x < 0.0) ?  float(3.141592654) - t3 : t3;\n  t3 = (y < 0.0) ? -t3 : t3;\n\n  return t3;\n}\n\nbool drawCircle(vec2 circlePos, vec2 pixelPos, float radius)\n{\n    float deltaX = circlePos.x-pixelPos.x;\n    float deltaY = circlePos.y-pixelPos.y;\n    return(sqrt((deltaX*deltaX)+(deltaY*deltaY))<radius);\n}\n\nvec3 circleNormal(vec2 circlePos, vec2 pixelPos, float radius)\n{\n    float deltaX = circlePos.x-pixelPos.x;\n    float deltaY = circlePos.y-pixelPos.y;\n    float dist = sqrt((deltaX*deltaX)+(deltaY*deltaY));\n    float dist2 = (((1.0*(radius*2.0))-dist)*(1.0/(radius*2.0)));\n    vec2 dir = vec2(deltaX,deltaY);\n    \n    float normalY = (-deltaY*4.0);\n    float normalX = (-deltaX*4.0);\n    return vec3(normalX,normalY,dist2); \n}\n\nvec2 circleMusicMap(vec2 circlePos, vec2 pixelPos, float radius){\n\tvec2 musicMap;\n    // create music map red (angle center)\n    float deltaX = pixelPos.x-circlePos.x;\n    float deltaY = pixelPos.y-circlePos.y;\n    float angleFromCenter = atan2(deltaX,deltaY);  \n    musicMap.r = 1.0-(angleFromCenter+PI)/(PI*2.0);\n    \n    // create music map blue (dist center)\n    float distFromCenter = sqrt((deltaY*deltaY)+(deltaX*deltaX));\n    float circleFromCenter = (distFromCenter*3.0);\n    circleFromCenter = circleFromCenter-radius;\n    musicMap.g = circleFromCenter;   \n    return musicMap;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 aspactRatio = vec2((iResolution.x/iResolution.y),1.0);\n\tvec2 uv = fragCoord.xy / (iResolution.xy/aspactRatio);\n    vec2 center = aspactRatio*0.5;\n\tvec4 color = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    // light position\n    lightPos.xy = (vec2(sin(iTime*2.0),-cos(iTime*2.0))/1.5)+center;\n\tif( iMouse.z > 0.0 )\n\t{\n\t\tlightPos = vec3((iMouse.xy / (iResolution.xy/aspactRatio)), lightPos.z);\n\t}\n    \n    bool filled = false;\n    \n    vec3 musicMap;\n    for (float i = 0.0;i < 2.6;i+=0.5){\n        for (float j = 1.0;j < 5.0;j+=1.0){\n            float size = (0.01+(j*0.04));\n            float fromCenter = 0.05+(0.01*j)+(size*j);\n            vec2 circlePos = vec2(sin((-iTime/3.0)+(i*twoThirdPI)+(j*twelfthPI)),cos((-iTime/3.0)+(i*twoThirdPI)+(j*twelfthPI)));\n            circlePos = (circlePos*fromCenter)+center;\n            if(drawCircle(circlePos,uv,size)){\n\n                // normal\n                vec3 circelNormal = circleNormal(circlePos,uv,size);\n\n                vec3 lightDir = normalize(lightPos-vec3(uv.x,uv.y,0.0));\n                float lightDot = dot(lightDir,circelNormal);\n                float lightPower = clamp( lightDot,0.0,1.0);\n                // draw circle\n                vec4 diffuse = vec4(lightPower);\n                \n                \n\t\t\t\tfloat fViewHeight = 2.0;\n\t\t\t\tvec3 vSurfacePos = vec3(uv, 0.0);\n\t\n\t\t\t\tvec3 vViewPos = vec3(0.5, 0.5, fViewHeight);\n\t\t\t\tvec3 vDirToView = normalize( vViewPos - vSurfacePos );\n                vec3 vHalf = normalize( vDirToView + lightDir );\n                float fNDotH = clamp( dot(circelNormal, vHalf), 0.0, 1.0);\n                float specular = pow(fNDotH, 10.0) * lightDot * 0.5;\n\t\t\t\t\n                // draw normalmaps\n                //fragColor = vec4(circelNormal.xyz,0) * 0.5 + 0.5; \n                // draw music maps\n                musicMap.xz = circleMusicMap(circlePos,uv,size);\n                //fragColor = vec4(musicMap.x,0.0,musicMap.z,1.0);\n                filled = true;\n                \n                // music visualizer\n    \t\t\t\n                ////old\n                if(musicMap.b < 0.0){\n                    fragColor = colorOnCenter*diffuse+specular;\n                }else{\n\n                    // use music map red\n                    float musicChannelnput = texture( iChannel0, vec2( musicMap.r,0.0)).r;\n\n                    // Get the starting x for this bar by rounding down\n                    float barStart = floor(musicMap.r * bars) / bars;\n\n                    // Sample spectrum in bar area, keep cumulative total\n                    float intensity = 0.0;\n                    for(float s = 0.0; s < barSize; s += barSize * sampleSize) {\n                        intensity += texture(iChannel0, vec2(barStart + s, 0.0)).r;\n                    }\n                    fragColor = vec4(intensity/10.0);\n                    intensity *= sampleSize*size;\n                    //if(musicMap.r - barStart < barGap || musicMap.r > barStart + barSize - barGap) {\n                        //intensity = 0.0;\n                    //}\n                    //fragColor = vec4(intensity);\n                    // use music map blue\n                    float onOff = musicMap.b-(intensity*3.0);\n                    onOff = clamp(onOff,-0.5,0.5); \n                    onOff = floor(onOff+1.0);\n                    fragColor = lerp(colorOn, (colorOff*color),onOff)*diffuse+(specular*50.0);\n                    //fragColor = vec4(musicChannelnput/1.0);\n                }\n            }\n        }\n    }\n    \n    \n    \n    \n    if(!filled){\n       fragColor = vec4(0.20);  \n    }else{\n        //fragColor = vec4(musicMap.xyz,0.0);\n    }\n    //fragColor = vec4(musicMap.xyz,0.0);\n}\n\n\n\n","name":"","description":"","type":"image"}]}