{"ver":"0.1","info":{"id":"wlSXzz","date":"1564778647","viewed":257,"name":"Remix: Triple spring (mouse)","username":"aaaidan","description":"Remix of qwertysol's toy. https://www.shadertoy.com/view/4dtfD4\nI just added mouse input. Comment out line 3 Buf A to use alternative input method. \n\nInspired by https://www.reddit.com/r/Simulated/comments/8cpcrp/oc_triple_spring_simulation/","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["simulation","physics","springs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void drawScene( vec2 fragCoord )\n{\n    float scale = iResolution.y / 20.0;\n    vec2 middle = iResolution.xy / 2.0 + vec2(0, 5.0) * scale;\n    \n    vec2 last = middle;\n    for (int i=0; i<n; i++)\n    {\n        vec2 body = getBody(i, iChannel0).xy * scale + middle;\n        drawSpring(fragCoord, last, body, 1.0 * scale, 5); \n        last = body;\n    }\n    \n    drawCircle(fragCoord, middle, scale / 3.0);\n    for (int i=0; i<n; i++)\n    {\n        vec2 body = getBody(i, iChannel0).xy * scale + middle;\n#ifdef COLOR\n        color = colors[i];\n#endif\n        drawCircle(fragCoord, body, scale * .6);\n        last = body;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = texture(iChannel1, uv);\n    drawScene(fragCoord);\n    fragColor += outputColor;\n\n    \n    fragColor = vec4(tosRGB(fragColor.rgb), 1.0);\n    \n    if (fragCoord.x < 6.0) \n    {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simulation\n\n#define TUG // comment out to snap to cursor\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y < float(n) && fragCoord.x < 2.0) \n    {\n    \tif (iFrame < 1 || resolutionChanged(iChannel0, iResolution))\n    \t{\n    \t    // Initial conditions.\n    \t    fragColor = bodies[int(fragCoord.y)];\n    \t}\n        else if (fragCoord.x < 1.0)\n        {\n            int i = int(fragCoord.y);\n            float t = min(iTimeDelta, 0.2);\n            \n            vec4 body = getBody(i, iChannel0);\n            vec4 anchor = getBody(i-1, iChannel0);\n            \n            if (i > 0)\n            {\n                anchor.zw += g*t;\n            }\n            body.zw += g*t;\n            \n            // Spring equation\n            vec2 dx = anchor.xy - body.xy;\n            float l = ls[i];\n            float x = l - length(dx);\n            \n            vec2 d = normalize(dx);\n            vec2 dv = anchor.zw - body.zw;\n            float v = dot(dv, d);\n            \n            float k = ks[i];\n            float b = bs[i];\n            float m = ms[i];\n            \n            bool isMouseDown = iMouse.z > 0.;\n            vec2 f = (-k*x + b*v) * d;\n            body.zw += f / m;\n            \n            const float drag = 0.98;\n            body.zw *= drag;\n\n            \n            if (i < n-1)\n            {\n                k = ks[i+1];\n                b = bs[i+1];\n                l = ls[i+1];\n                \n                vec4 anchor = getBody(i+1, iChannel0);\n                anchor.zw += g*t;\n             \n                // Spring equation\n            \tvec2 dx = body.xy - anchor.xy;\n            \tfloat x = l - length(dx);\n            \n            \tvec2 d = normalize(dx);\n            \tvec2 dv = body.zw - anchor.zw;\n            \t//float v = dot(dv, d);\n            \n            \tvec2 f = (k*x - b*v) * d;\n            \tbody.zw += f / m;\n            }\n            \n            // Integration\n            body.xy += body.zw * t;\n            \n            if (isMouseDown && fragCoord.y > 2.0) {\n                float scale = iResolution.y / 20.0;\n    \t\t\tvec2 middle = iResolution.xy / 2.0 + vec2(0, 5.0) * scale;\n                \n                vec2 mousePos = iMouse.xy;\n                vec2 bodyPos = (body.xy * scale + middle);\n                vec2 delta = mousePos - bodyPos;\n            \t\n#ifdef TUG\n                // tug\n                body.zw += delta * 0.05;\n#else\n                // snap\n                body.xy = (mousePos - middle) / scale;\n                body.zw = vec2(0.,0.);\n#endif\n            }\n            \n            fragColor = body;\n        }\n        else\n        {\n            int i = int(fragCoord.y);\n            fragColor = getBody(i, iChannel0);\n        }\n    }\n    else\n    {\n        fragColor = vec4(iResolution, 0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = iResolution.y / 20.0;\n    vec2 middle = iResolution.xy / 2.0 + vec2(0, 5.0) * scale;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    outputColor = (resolutionChanged(iChannel1, iResolution) ? 0.0 : .998) * texture(iChannel1, uv);\n    for (int i=0; i<n; i++)\n    {\n#ifdef COLOR\n        color = colors[i];\n#endif        \n        drawLine(fragCoord, \n                 getBodyPrevious(i, iChannel0).xy * scale + middle, \n                 getBody(i, iChannel0).xy * scale + middle,\n                 0.5);\n    }\n    \n    fragColor = outputColor;\n    \n    if (fragCoord.x < 6.0) \n    {\n        fragColor = vec4(iResolution, 0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define COLOR\n\nconst float k = 0.5;\nconst float b = 0.0;\nconst float l = 0.5;\nconst float m = 1.0;\n\nconst vec2 g = vec2(0, -9.8) * 2.0;\n\nconst float[] bs = float[](b, b, b);\nconst float[] ks = float[](k, k, k);\nconst float[] ls = float[](l, l, l);\nconst float[] ms = float[](m, m, m);\n\nconst vec4[] bodies = vec4[](vec4(1,0.5,-7,15), vec4(0.3,1.5,-3,0), vec4(-0.5,2,15,4));\nconst vec4[] colors = vec4[](vec4(1,0,0,1), vec4(0,1,0,1), vec4(0,0,1,1));\nconst int n = 3;\n\nfloat segmentDistance( vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nvec3 toLinear(vec3 v) {\n  \treturn pow(v, vec3(2.2));\n}\n\nvec3 tosRGB( vec3 color )\n{\n    return pow(color, vec3(1.0/2.2));\n}\n\nvec4 outputColor = vec4(vec3(0), 1);\nvec4 color = vec4(1.0);\n\nvoid drawLine( vec2 coords, vec2 p0, vec2 p1, float thickness )\n{\n    float sD = segmentDistance(coords, p0, p1);\n\tfloat a = 1.0 - clamp(sD - thickness / 2.0 + .5, 0.0, 1.0);\n    \n    outputColor = mix(outputColor, color, a * color.a);\n}\n\nvoid drawSpring( vec2 coords, vec2 p0, vec2 p1, float thickness, int loops )\n{\n    vec2 d = p1 - p0;\n    if (length(d) < 0.001)\n        return;\n    \n    vec2 dir = normalize(d);\n    vec2 per = vec2(dir.y, -dir.x);\n    \n    vec2 st = d / float(loops * 2);\n    vec2 last = p0 + per * thickness / 2.0 + st / 2.0;\n    vec2 sw = -thickness * per;\n    float th = 1.0;\n    \n    drawLine(coords, p0, last, th);\n    \n    for (int i=0; i<loops*2-1; i++)\n    {\n        vec2 next = last + st + sw;\n        sw = -sw;\n        drawLine(coords, last, next, th);\n        last = next;\n    }\n    \n    drawLine(coords, last, p1, th);\n}\n\nvoid drawCircle( vec2 coords, vec2 center, float radius )\n{\n    float sD = distance(coords, center);\n\tfloat a = 1.0 - clamp(sD - radius / 2.0 + .5, 0.0, 1.0);\n    \n        outputColor = mix(outputColor, color, a * color.a);\n}\n\nvec4 getBody( int i, sampler2D sampler )\n{\n    if (i < 0)\n    {\n        return vec4(0.0); \n    }\n        \n    return texelFetch(sampler, ivec2(0, i), 0);\n}\n\nvec4 getBodyPrevious( int i, sampler2D sampler )\n{\n    if (i < 0)\n    {\n        return vec4(0.0); \n    }\n        \n    return texelFetch(sampler, ivec2(1, i), 0);\n}\n\nbool resolutionChanged( sampler2D sampler, vec3 iResolution )\n{\n    return iResolution.xy != texelFetch(sampler, ivec2(5, 5), 0).rg;\n}","name":"Common","description":"","type":"common"}]}