{"ver":"0.1","info":{"id":"XcSXDR","date":"1706354136","viewed":278,"name":"Drawing practice #2","username":"hasenpfote","description":"I am practicing drawing lines with my right hand.\n\nLeft side: Original image, Right side: Filtered image\nThe additional details can be found within the Image tab.","likes":15,"published":1,"flags":48,"usePreview":0,"tags":["crosshatch","sketch","drawing","npr","bilateral","oklab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Drawing practice #2\n *\n * Enabling DEBUG_CROSSHATCH_STROKE in the Common tab allows you to visualize\n * strokes.\n *\n * ===\n * User inputs\n *   [Mouse drag] Adjusts the filter's application range.\n *\n * ===\n * In this pass, edge detection, and crosshatching to determine the final\n * colors.\n */\n\n#define CROSSHATCH_MODEL 2\n\nconst float PI = 3.1415926;\nconst float TAU = 6.2831853;\n\n//==============================================================================\n\nvec4 load_state(in int id){\n    return load_state(iChannel3, id);\n}\n\nvec3 fetch(in vec2 pos){\n    return texture(iChannel0, pos / iResolution.xy).rgb;\n}\n\n//==============================================================================\n\nvec2 grad(in vec2 pos, in float delta){\n    // 2nd order central difference\n    vec2 d = vec2(delta, 0.);\n    return vec2(\n        fetch(pos + d.xy).r - fetch(pos - d.xy).r,\n        fetch(pos + d.yx).r - fetch(pos - d.yx).r\n    ) / (2. * delta);\n}\n\n#if (CROSSHATCH_MODEL == 0)\n/**\n * This function is built upon classical techniques with the following\n * enhancements:\n *   - Drawing lines with the right hand.\n *   - Adjusting the slope and density of lines based on lightness.\n *     Note: Unable to cross 90 degrees.\n *\n * See previous: https://www.shadertoy.com/view/MfsSRr\n */\nfloat crosshatch(in vec2 pos, in float lightness){\n#define CYCLE 256.\n\n    const int num_strokes = 5;\n    const float width = 0.5;\n    const vec2 lower = vec2(0.4, 2.); // slope, density\n    const vec2 upper = vec2(6., 1.);\n\n    float complementary = 1. - lightness;\n    vec2 uv = (pos / iResolution.xy) * CYCLE;\n    vec2 sum = vec2(0.);\n\n    for(int i = 0; i < num_strokes; i++){\n        // Adjusts the slope of the mainline based on lightness.\n        float x = float(i) - float(num_strokes - 1) * complementary;\n        float w = exp2(- x * x);\n        vec2 interpolated = mix(lower, upper, float(i) / float(num_strokes - 1));\n        float p = interpolated.x * uv.x - uv.y;\n        sum.x += w * hash11(mod(floor(p), CYCLE)) * step(mod(p, interpolated.y), width);\n        sum.y += w;\n    }\n\n    return 1. - tanh((sum.x / sum.y) * complementary * complementary);\n\n#undef CYCLE\n}\n#elif (CROSSHATCH_MODEL == 1)\n/**\n * This function is a refined version of the previous one, making it easier to\n * control the slope of lines.\n */\nfloat crosshatch(in vec2 pos, in float lightness){\n#define CYCLE 256.\n\n    const int num_strokes = 5;\n    const float width = 0.5;\n    const vec2 lower = vec2(0.34906585, 2.); // angle, density\n    const vec2 upper = vec2(1.7453292, 1.);\n\n    float complementary = 1. - lightness;\n    vec2 uv = (pos / iResolution.xy) * CYCLE;\n    vec2 sum = vec2(0.);\n\n    for(int i = 0; i < num_strokes; i++){\n        // Adjusts the slope of the mainline based on lightness.\n        float x = float(i) - float(num_strokes - 1) * complementary;\n        float w = exp2(- x * x);\n        vec2 interpolated = mix(lower, upper, float(i) / float(num_strokes - 1));\n        float p = -sin(interpolated.x) * uv.x + cos(interpolated.x) * uv.y;\n        sum.x += w * hash11(mod(floor(p), CYCLE)) * step(mod(p, interpolated.y), width);\n        sum.y += w;\n    }\n\n    return 1. - tanh((sum.x / sum.y) * complementary * complementary);\n\n#undef CYCLE\n}\n#else\n/**\n * This function is a simplified version.\n */\nfloat crosshatch(in vec2 pos, in float lightness){\n#define CYCLE 256.\n\n    const int num_strokes = 5;\n    const float density = 4.;\n\n    float complementary = 1. - lightness;\n    vec2 uv = (pos / iResolution.xy) * CYCLE;\n    vec2 sum = vec2(0.);\n\n    for(int i = 0; i < num_strokes; i++){\n        // Adjusts the slope of the mainline based on lightness.\n        float x = float(i) - float(num_strokes - 1) * complementary;\n        float w = exp2(- x * x);\n        float angle = mix(0.34906585, 1.7453292, float(i) / float(num_strokes - 1));\n        float p = floor(density * (-sin(angle) * uv.x + cos(angle) * uv.y));\n        sum.x += w * hash11(mod(p, CYCLE));\n        sum.y += w;\n    }\n\n    return 1. - tanh((sum.x / sum.y) * complementary * complementary);\n\n#undef CYCLE\n}\n#endif // CROSSHATCH_MODEL\n\n//==============================================================================\n\n/**\n * Returns the weight of a separator at the specified position.\n */\nfloat vert_separator(in float pos, in float sep){\n    pos -= sep;\n    return pos * pos < 4. ? 0. : 1.;\n}\n\n#ifdef DEBUG_DISPLAY\nint text(in vec2 pos){\n    const float font_scale = 5.;\n\n    float short_side = iResolution.y;\n    vec2 c_size = text_size(short_side, font_scale);\n    vec2 c_spacing = text_spacing(short_side, font_scale);\n    vec2 uv = pos / short_side;\n    vec2 o = text_pos(vec2(0., 1.), c_size.y);\n    vec2 p = o;\n    int res = 0;\n\n#define CRLF text_newline(p, o.x, c_spacing.y)\n#define C(c) do{ res |= font_draw_char(c, p, c_size, uv); text_advance_to(p, c_spacing.x); }while(false)\n#define I(_x) res |= font_draw_decimal(_x, p, c_size, uv, 1)\n#define F(_x) res |= font_draw_decimal(_x, p, c_size, uv, 2)\n\n    // fps:F\n    C(102); C(112); C(115); C(58); F(iFrameRate); CRLF;\n\n    return res;\n\n#undef F\n#undef I\n#undef C\n#undef CRLF\n}\n#endif\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float vsep_pos = load_state(SID_SEPARATOR).x * iResolution.x;\n    vec3 lab;\n\n    if(fragCoord.x < vsep_pos){\n        lab = fetch(fragCoord);\n    }else{\n        lab = fetch(fragCoord);\n        float w = crosshatch(fragCoord, lab.r);\n#ifdef DEBUG_CROSSHATCH_STROKE\n        lab.r = w;\n#else\n        // Adds edge-like features to the image.\n        vec2 g = grad(fragCoord, 0.5);\n        lab.r = mix(w, lab.r, smoothstep(0.004 * sqrt(2.), 0.04 * sqrt(2.), length(g)));\n#endif\n    }\n\n    vec3 color = oklab_to_linear_srgb(lab);\n\n    color *= vert_separator(fragCoord.x, vsep_pos);\n#ifdef DEBUG_DISPLAY\n    vec4 state_debug = load_state(SID_DEBUG);\n    if(state_debug.x > 0.){\n        int txt = text(fragCoord);\n        color = mix(color, vec3(0., 1., 0.), float(txt));\n    }\n#endif\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//#define DEBUG_DISPLAY\n\n/** Enables debug mode for crosshatch strokes. */\n//#define DEBUG_CROSSHATCH_STROKE\n\n#define SID_DEBUG     0\n#define SID_SEPARATOR 1\n\n//==============================================================================\n\n// Hash without Sine - David Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(in float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//==============================================================================\n\nfloat srgb_to_linear(in float x){\n    return x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\n\nvec3 srgb_to_linear(in vec3 color){\n    return vec3(srgb_to_linear(color.r), srgb_to_linear(color.g), srgb_to_linear(color.b));\n}\n\nfloat linear_to_srgb(in float x){\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(x, 1./2.4) - 0.055;\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    return vec3(linear_to_srgb(color.r), linear_to_srgb(color.g), linear_to_srgb(color.b));\n}\n\n//==============================================================================\n// Oklab\n// https://bottosson.github.io/posts/oklab/\n//==============================================================================\n\nvec3 linear_srgb_to_lms_prime(in vec3 rgb){\n    const mat3 m = mat3(\n        0.4122214708, 0.2119034982, 0.0883024619,\n        0.5363325363, 0.6806995451, 0.2817188376,\n        0.0514459929, 0.1073969566, 0.6299787005\n    );\n\n    vec3 lms = m * rgb;\n\n    return sign(lms) * pow(abs(lms), vec3(1./3.));\n}\n\nvec3 linear_srgb_to_oklab(in vec3 rgb){\n    const mat3 m = mat3(\n         0.2104542553,  1.9779984951,  0.0259040371,\n         0.7936177850, -2.4285922050,  0.7827717662,\n        -0.0040720468,  0.4505937099, -0.8086757660\n    );\n\n    vec3 lms_prime = linear_srgb_to_lms_prime(rgb);\n\n    return m * lms_prime;\n}\n\nvec3 lms_prime_to_linear_srgb(in vec3 lms_prime){\n    const mat3 m = mat3(\n         4.0767416621, -1.2684380046, -0.0041960863,\n        -3.3077115913,  2.6097574011, -0.7034186147,\n         0.2309699292, -0.3413193965,  1.7076147010\n    );\n\n    vec3 lms = lms_prime * lms_prime * lms_prime;\n\n    return m * lms;\n}\n\nvec3 oklab_to_linear_srgb(in vec3 lab){\n    const mat3 m = mat3(\n        1.,            1.,            1.,\n        0.3963377774, -0.1055613458, -0.0894841775,\n        0.2158037573, -0.0638541728, -1.2914855480\n    );\n\n    vec3 lms_prime = m * lab;\n\n    return lms_prime_to_linear_srgb(lms_prime);\n}\n\n//==============================================================================\n// State buffer\n//==============================================================================\n\nconst ivec2 STATE_BUFFER_SIZE = ivec2(128);\n\nvec4 load_state(in sampler2D sampler, in int id){\n    ivec2 pos = ivec2(id % STATE_BUFFER_SIZE.x, id / STATE_BUFFER_SIZE.y);\n    return texelFetch(sampler, pos, 0);\n}\n\nint pos_to_sid(in ivec2 pos){\n    int factor = 1 - 2 * int(any(greaterThanEqual(pos, STATE_BUFFER_SIZE)));\n    return (pos.y * STATE_BUFFER_SIZE.x + pos.x) * factor;\n}\n\nbool can_store_state(in int id, in ivec2 pos){\n    return id == pos_to_sid(pos);\n}\n\n//==============================================================================\n\n#ifdef DEBUG_DISPLAY\n//\n// This font is based on the following work:\n// [Simple Bitmap Text - integers - iq] https://www.shadertoy.com/view/4s3fzl\n//\n\n/**\n * The data is based on the following 4x6 font.\n * http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n */\nconst int[95] FONT_DATA = int[](\n    0x000000, // \n    0x222020, // !\n    0x550000, // \"\n    0x575750, // #\n    0x236362, // $\n    0x412410, // %\n    0x253570, // &\n    0x640000, // '\n    0x244420, // (\n    0x422240, // )\n    0x527250, // *\n    0x027200, // +\n    0x000064, // ,\n    0x007000, // -\n    0x000020, // .\n    0x112440, // /\n    0x355560, // 0\n    0x262270, // 1\n    0x612470, // 2\n    0x612160, // 3\n    0x157110, // 4\n    0x746160, // 5\n    0x246520, // 6\n    0x713220, // 7\n    0x252520, // 8\n    0x253120, // 9\n    0x002020, // :\n    0x002064, // ;\n    0x124210, // <\n    0x007070, // =\n    0x421240, // >\n    0x612020, // ?\n    0x755470, // @\n    0x257550, // A\n    0x656560, // B\n    0x344430, // C\n    0x655560, // D\n    0x746470, // E\n    0x746440, // F\n    0x345530, // G\n    0x557550, // H\n    0x722270, // I\n    0x111520, // J\n    0x556550, // K\n    0x444470, // L\n    0x577550, // M\n    0x575550, // N\n    0x255520, // O\n    0x656440, // P\n    0x255730, // Q\n    0x656550, // R\n    0x347160, // S\n    0x722220, // T\n    0x555570, // U\n    0x555520, // V\n    0x557750, // W\n    0x552550, // X\n    0x552220, // Y\n    0x712470, // Z\n    0x644460, // [\n    0x442110, // back slash\n    0x622260, // ]\n    0x250000, // ^\n    0x00000F, // _\n    0x620000, // `\n    0x003570, // a\n    0x446560, // b\n    0x003430, // c\n    0x113530, // d\n    0x007630, // e\n    0x127220, // f\n    0x007517, // g\n    0x446550, // h\n    0x202220, // i\n    0x202226, // j\n    0x445650, // k\n    0x222220, // l\n    0x007750, // m\n    0x006550, // n\n    0x002520, // o\n    0x006564, // p\n    0x003531, // q\n    0x006440, // r\n    0x003260, // s\n    0x027230, // t\n    0x005570, // u\n    0x005520, // v\n    0x005770, // w\n    0x005250, // x\n    0x005524, // y\n    0x006230, // z\n    0x326230, // {\n    0x222220, // |\n    0x623260, // }\n    0x5A0000  // ~\n);\n\nconst ivec2 FONT_CELL_SIZE = ivec2(4, 6);\n\nconst int FONT_MAX_INT_DIGITS = 4; // Configure the integer maximum digit count from 1 to 10.\nconst int FONT_MAX_INT_PLACE = 1000; // 10^{MAX_INT_DIGITS-1}\n\nint font_draw_char(in int ascii, in vec2 pos, in vec2 size, in vec2 uv){\n    ascii -= 32;\n    if(ascii < 0 || ascii > 94)\n        return 0;\n\n    // Subtract our position from the current uv so that we can\n    // know if we're inside the bounding box or not.\n    uv -= pos;\n\n    // Divide the screen space by the size, so our bounding box is 1x1.\n    uv /= size;\n\n    // Multiply the UV by the bitmap size so we can work in\n    // bitmap space coordinates.\n    uv *= vec2(FONT_CELL_SIZE);\n\n    // Compute bitmap texel coordinates\n    ivec2 iuv = ivec2(round(uv));\n\n\t// Bounding box check. With branches, so we avoid the maths and lookups    \n    if(iuv.x < 0 || iuv.x >= FONT_CELL_SIZE.x || iuv.y < 0 || iuv.y >= FONT_CELL_SIZE.y)\n        return 0;\n\n    // Compute bit index\n    iuv.x = FONT_CELL_SIZE.x - 1 - iuv.x;\n    int index = FONT_CELL_SIZE.x * iuv.y + iuv.x;\n\n    // Get the appropriate bit and return it.\n    return (FONT_DATA[ascii] >> index) & 0x1;\n}\n\nint font_draw_decimal(in uint x, inout vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n    uint place = uint(FONT_MAX_INT_PLACE);\n    float spacing = 1.25 * size.x; // 1.25 = (MAP_SIZE.x+1) / MAP_SIZE.x\n\n    for(int i = FONT_MAX_INT_DIGITS - 1; i >= 0; i--){\n        uint quotient = x / place;\n        if(quotient > 0u || i < min_digits){\n            uint digit = quotient % 10u;\n            res |= font_draw_char(int(48u + digit), pos, size, uv);\n            pos.x += spacing;\n        }\n        place /= 10u;\n    }\n\n    return res;\n}\n\nint font_draw_decimal(in int x, inout vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n\n    if(x < 0){\n        res |= font_draw_char(45, pos, size, uv);\n        x = -x;\n        pos.x += 1.25 * size.x;\n    }\n\n    res |= font_draw_decimal(uint(x), pos, size, uv, min_digits);\n\n    return res;\n}\n\nint font_draw_decimal(in float x, inout vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n    float spacing = 1.25 * size.x;\n\n    if(x < 0.){\n        res |= font_draw_char(45, pos, size, uv);\n        x = -x;\n        pos.x += spacing;\n    }\n\n    float fx, ix;\n    fx = modf(x, ix);\n\n    res |= font_draw_decimal(uint(ix), pos, size, uv, 1);\n\n    res |= font_draw_char(46, pos, size, uv);\n    pos.x += spacing;\n\n    res |= font_draw_decimal(uint(pow(10., float(min_digits)) * fx), pos, size, uv, min_digits);\n\n    return res;\n}\n\nvec2 text_size(in float base_dim, in float fs){\n    return fs * vec2(FONT_CELL_SIZE) / base_dim;\n}\n\nvec2 text_spacing(in float base_dim, in float fs){\n    return fs * vec2(FONT_CELL_SIZE + 1) / base_dim;\n}\n\nvec2 text_pos(in vec2 p, in float s){\n    p.y -= s;\n    return p;\n}\n\nvoid text_advance_to(inout vec2 p, in float spacing){\n    p.x += spacing;\n}\n\nvoid text_newline(inout vec2 p, in float left, in float spacing){\n    p.x = left;\n    p.y -= spacing;\n}\n#endif // DEBUG_DISPLAY\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define KEY_LEFT    37\n#define KEY_UP      38\n#define KEY_RIGHT   39\n#define KEY_DOWN    40\n#define KEY_F1     112\n#define KEY_COMMA  188\n#define KEY_PERIOD 190\n\nvec4 load_state(in int id){\n    return load_state(iChannel0, id);\n}\n\nbool is_mouse_down(){\n    return iMouse.z > 0.;\n}\n\nbool is_key_pressed(int code){\n    return texelFetch(iChannel1, ivec2(code, 1), 0).x > 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 pos = ivec2(fragCoord);\n    vec4 state;\n\n    if(can_store_state(SID_DEBUG, pos)){\n        state = load_state(SID_DEBUG);\n        if(iFrame > 0){\n            if(is_key_pressed(KEY_F1)){\n                state.x = float(!bool(state.x));\n            }\n        }else{\n            state = vec4(1.);\n        }\n    }else if(can_store_state(SID_SEPARATOR, pos)){\n        state = load_state(SID_SEPARATOR);\n        if(iFrame > 0){\n            if(is_mouse_down()){\n                state.x = iMouse.x / iResolution.x;\n            }\n        }else{\n            state = vec4(0.5, 0., 0., 0.);\n        }\n    }else{\n        discard;\n    }\n\n    fragColor = state;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n * In this pass, noise reduction is applied. The output is in the Oklab color\n * space.\n */\n\n#define USE_LUT\n\n/** Radius of the gaussian kernel. */\nconst int KERNEL_RADIUS = 2;\n\n/** Standard deviation for the domain kernel. */\nconst float SIGMA_D = 10.;\n\n/** Standard deviation for the range kernel. */\nconst float SIGMA_R = 0.1;\n\n//==============================================================================\n\nvec3 fetch(in vec2 pos){\n    return srgb_to_linear(texture(iChannel0, pos / iResolution.xy).rgb);\n}\n\n//==============================================================================\n\nfloat weight(in vec2 x, in vec3 intensity){\n#ifdef USE_LUT\n    return exp(- 0.5 * (x.x + x.y + dot(intensity, intensity)/(SIGMA_R*SIGMA_R)));\n#else\n    return exp(- 0.5 * (dot(x,x)/(SIGMA_D*SIGMA_D) + dot(intensity, intensity)/(SIGMA_R*SIGMA_R)));\n#endif\n}\n\n// https://en.wikipedia.org/wiki/Bilateral_filter\nvec3 bilateral_filter(in vec2 pos){\n#ifdef USE_LUT\n    const float vd = SIGMA_D * SIGMA_D;\n    float lut[KERNEL_RADIUS + 1];\n\n    for(int i = 0; i <= KERNEL_RADIUS; i++){\n        lut[i] = float(i*i) / vd;\n    }\n#endif\n\n    vec4 sum = vec4(0.);\n    vec3 c0 = fetch(pos);\n\n    for(int i = -KERNEL_RADIUS; i <= KERNEL_RADIUS; i++){\n#ifdef USE_LUT\n        float y_d = lut[abs(i)];\n#endif\n        for(int j = -KERNEL_RADIUS; j <= KERNEL_RADIUS; j++){\n            vec2 offset = vec2(i, j);\n            vec3 c = fetch(pos + offset);\n            vec3 intensity = c - c0;\n#ifdef USE_LUT\n            float w = weight(vec2(lut[abs(j)], y_d), intensity);\n#else\n            float w = weight(offset, intensity);\n#endif\n            sum.rgb += w * c;\n            sum.a += w;\n        }\n    }\n\n#undef USE_LUT\n\n    return sum.rgb / sum.a;\n}\n\n//==============================================================================\n\n// https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-8-simulating-diffraction\nvec3 bump(vec3 x){\n    // |x| > 1 ? 0 : 1 - x^2 \n\tvec3 y = vec3(1.) - x * x;\n\ty = max(y, vec3(0.));\n\treturn y;\n}\n\nvec3 spectrum(float t){\n    // t := 0 <= (wl - 400) / 300 <= 1\n    return bump(4. * vec3(t - 0.75, t - 0.5, t - 0.25));\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n#ifdef DEBUG_CROSSHATCH_STROKE\n    float levels = 15.;\n    vec2 t = floor((fragCoord / (iResolution.xy * vec2(0.5, 1.))) * levels) / levels;\n    vec3 cl = mix(spectrum(t.x), mix(vec3(0), vec3(1), t.x), step(0.50 * iResolution.y, fragCoord.y));\n    vec3 cr = mix(mix(vec3(0), vec3(1), t.y), spectrum(t.y), step(0.75 * iResolution.x, fragCoord.x));\n    vec3 color = mix(cl, cr, step(0.5 * iResolution.x, fragCoord.x));\n#else\n    vec3 color = bilateral_filter(fragCoord);\n#endif\n    fragColor = vec4(linear_srgb_to_oklab(color), 1.);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}