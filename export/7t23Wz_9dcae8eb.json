{"ver":"0.1","info":{"id":"7t23Wz","date":"1624006505","viewed":161,"name":"IDW Interpolation 1","username":"JoeShader","description":"Inverse Distance Weighting - IDW\nUsed to create an interpolated 'surface' from data points. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["interpolation","idw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_POINTS 9\n\nfloat distancePower = 3.;\nfloat neighbourDistanceThreshold = 0.99;\nfloat exactThreshold = 0.01; // if we are very close to a point then avoid a divide by zero and set to exact weight of the point\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 points[NUM_POINTS];\n    points[0] = vec3(0.25, 0.25, 0.9);\n    points[1] = vec3(0.5, 0.25, 0.5);\n    points[2] = vec3(0.75, 0.25, 0.9); \n    \n    points[3] = vec3(0.25, 0.5, 0.1);\n    points[4] = vec3(0.5, 0.5, .7);\n    points[5] = vec3(0.75, 0.5, 0.9);\n    \n    points[6] = vec3(0.25, 0.75, 0.9);\n    points[7] = vec3(0.5, 0.75, 0.5);\n    points[8] = vec3(0.75, 0.75, 0.2);\n          \n    float sumOfAllInverseDistances = 0.;\n    float inverseDistances[NUM_POINTS];\n    float interpolatedValue = 0.;  \n    \n    for (int i = 0; i < NUM_POINTS; ++i) \n    {\n        float dist = max(exactThreshold, length(uv - points[i].xy));  \n        if (dist < neighbourDistanceThreshold) \n        {                            \n            inverseDistances[i] = 1. / pow(dist, distancePower);\n            sumOfAllInverseDistances += inverseDistances[i];\n        }\n        interpolatedValue += points[i].z * inverseDistances[i];\n    }\n    interpolatedValue /= sumOfAllInverseDistances; \n    \n    interpolatedValue = clamp(interpolatedValue, 0.0, 1.0);\n    fragColor = vec4(interpolatedValue, interpolatedValue, interpolatedValue, 1.0);\n}","name":"Image","description":"","type":"image"}]}