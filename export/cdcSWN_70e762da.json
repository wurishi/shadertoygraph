{"ver":"0.1","info":{"id":"cdcSWN","date":"1679769557","viewed":69,"name":"gpt4 cat7: from scratch","username":"memo","description":"code created by chatgpt using gpt4\nsee code comments","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["chatgpt","gpt4"],"hasliked":0,"parentid":"Ds3SWN","parentname":"gpt4 cat6: mountains and sky"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ncode created by chatgpt using gpt4\ntrying from scratch\nprompt:\ncreate glsl code for shadertoy to draw a cat sitting on a table surrounded by green hills and a blue sky with white clouds and yellow sun, using 3D primitives and signed distance fields\n\ngpt4 outputted full new code\n\nI had to make one minor fix:\n- swap the order of the function definitions sceneSDF and getNormal, as the latter calls the former\n*/\n\n\n/*\nHere's a complete GLSL shader code for ShaderToy that draws a cat sitting on a table,\nsurrounded by green hills, a blue sky with white clouds, and a yellow sun, using\n3D primitives and signed distance fields:\n\n*/\n\n// ShaderToy shader code\n#pragma glslify: smin = require(./smin.glsl)\n\nvec2 opU(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat boxSDF(vec3 p, vec3 center, vec3 size) {\n    vec3 d = abs(p - center) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat unionSDF(float d1, float d2) {\n    return min(d1, d2);\n}\n\n\nfloat sceneSDF(vec3 p) {\n    // Cat body\n    float body = sphereSDF(p, vec3(0.0, 1.0, 0.0), 1.0);\n    // Cat head\n    float head = sphereSDF(p, vec3(0.0, 2.5, 0.0), 0.7);\n    // Cat ears\n    float leftEar = boxSDF(p, vec3(-0.4, 3.2, 0.0), vec3(0.2, 0.3, 0.1));\n    float rightEar = boxSDF(p, vec3(0.4, 3.2, 0.0), vec3(0.2, 0.3, 0.1));\n    // Table\n    float table = boxSDF(p, vec3(0.0, 0.5, 0.0), vec3(2.0, 0.5, 2.0));\n    // Mountains\n    float mountains = p.y - (0.7 * (sin(0.5 * p.x) + sin(0.5 * p.z)));\n    return min(min(min(min(body, head), leftEar), rightEar), min(table, mountains));\n}\n\n\nvec3 getNormal(vec3 p, float eps) {\n    vec2 e = vec2(eps, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),\n        sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\n        sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)\n    ));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.1;\n    vec3 cameraPos = vec3(5.0 * cos(t), 2.0, 5.0 * sin(t));\n    vec3 target = vec3(0.0, 1.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    vec3 cameraForward = normalize(target - cameraPos);\n    vec3 cameraRight = normalize(cross(up, cameraForward));\n    vec3 cameraUp = cross(cameraForward, cameraRight);\n    \n  \n    /*\n    MEMO:\n    first chunk of code output stopped here. I had to prompt 'continue'.\n    Second chunk of code was generated and ended with:\n    \n    Copy and paste this code, along with the previous part, into ShaderToy\n    (https://www.shadertoy.com/) to see the cat sitting on a table, surrounded by green hills,\n    a blue sky with white clouds, and a yellow sun. The scene uses 3D primitives and signed distance fields.\n    */\n    \n    mat3 cameraToWorld = mat3(cameraRight, cameraUp, cameraForward);\n\n    vec3 rayDir = cameraToWorld * normalize(vec3(uv, 1.0));\n\n    vec3 p = cameraPos;\n    bool hit = false;\n    float d;\n    for (int i = 0; i < 64; ++i) {\n        d = sceneSDF(p);\n        if (d < 0.001) {\n            hit = true;\n            break;\n        }\n        p += rayDir * d;\n    }\n\n    vec3 color;\n    if (hit) {\n        vec3 normal = getNormal(p, 0.001);\n        vec3 lightDir = normalize(vec3(-0.5, 1.0, -1.0));\n        float diffuse = max(dot(normal, lightDir), 0.0);\n\n        if (abs(p.y - (0.7 * (sin(0.5 * p.x) + sin(0.5 * p.z)))) < 0.001) {\n            // Green hills\n            vec3 hillColor = vec3(0.2, 0.7, 0.2);\n            color = hillColor * diffuse;\n        } else {\n            // Cat and table color\n            vec3 objectColor = vec3(0.8, 0.4, 0.6);\n            color = objectColor * diffuse;\n        }\n    } else {\n        // Sky and sun color\n        float gradient = 0.5 * (rayDir.y + 1.0);\n        vec3 sky = mix(vec3(0.1, 0.3, 0.5), vec3(0.8, 0.9, 1.0), gradient);\n        float sun = smoothstep(0.999, 1.0, dot(rayDir, normalize(vec3(-0.5, 1.0, -1.0))));\n        sky += vec3(1.0, 0.8, 0.5) * sun;\n        color = sky;\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}