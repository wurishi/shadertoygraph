{"ver":"0.1","info":{"id":"43GXDd","date":"1720612765","viewed":56,"name":"Brownian motion","username":"ODtian","description":"background: https://www.shadertoy.com/view/dsSfzz\ncolor map: https://www.shadertoy.com/view/4dXXDX\nsdf: iq","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot2(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define PI 3.1415926\n#define PI2 (PI * 2.0)\n\n// #iChannel0 \"file://l7ch0.glsl\"\n\nvec3 autumn(float t) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), t);\n}\n\nfloat random(in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.246334, 78.34534))) *\n        4346.23643);\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdTriangleIsosceles(in vec2 p, in vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sdRoundedBox(in vec2 p, in vec2 b, in vec4 r) {\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x = (p.y > 0.0) ? r.x : r.y;\n    vec2 q = abs(p) - b + r.x;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n}\n\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\nvec4 opUcolor(vec4 a, vec4 b) {\n    return a.a > b.a ? b : a;\n}\n\nvec4 map(vec2 pos, float t, vec2 uv) {\n    float angle = texelFetch(iChannel0, ivec2(0), 0).a;\n    pos -= texelFetch(iChannel0, ivec2(0), 0).yz;\n\n    vec3 c = autumn(sin(iTime / 3.0) * 0.5 + 0.5);\n    vec4 scene = vec4(c, sdRoundedBox((pos * 3.0 * rot2(angle) - vec2(0.0, 0.08)), vec2(0.01, 0.10), vec4(0.01)));\n    scene = opUcolor(scene, vec4(c, sdTriangleIsosceles(pos * 3.0 * rot2(angle) - vec2(0.0, 0.23), vec2(0.04, -0.06))));\n    scene = opUcolor(scene, vec4(vec3(1.0), sdCircle(pos, 0.03)));\n\n    scene = opUcolor(scene, texture(iChannel0, uv));\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float asp = iResolution.x / iResolution.y;\n    vec2 pos = uv - 0.5;\n    pos.y /= asp;\n\n    float t = floor(iTime * 20.0) / 20.0, t2 = floor(iTime * 30.0) / 30.0;\n\n    vec4 scene = map(pos, t, uv);\n\n    float a = smoothstep(0.002, 0.0, scene.a);\n    vec2 x = pos * .2 + vec2(random(vec2(t2)), random(vec2(t2 + 3.0)));\n    fragColor.rgb = mix(texture(iChannel1, uv).rgb * smoothstep(0.0, 1.1, texture(iChannel2, x).r + 0.5), scene.rgb, a * 0.8);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define rot2(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define PI 3.1415926\n#define PI2 (PI * 2.0)\n\n// #iChannel0 \"self\"\n\nconst float speed = 0.5;\n\nfloat random(in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.246334, 78.34534))) *\n        4346.23643);\n}\n\nvec3 autumn(float t) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), t);\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\nvec4 opUcolor(vec4 a, vec4 b) {\n    return a.a > b.a ? b : a;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // first texel for last t\n    ivec2 coord = ivec2(fragCoord);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    float asp = iResolution.x / iResolution.y;\n    vec2 pos = uv - 0.5;\n    pos.y /= asp;\n\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    float t = floor(iTime * 20.0) / 20.0;\n\n    float random_angle = random(vec2(t)) * PI2;\n\n    float last_t = data.x;\n    vec2 last_pos = data.yz;\n    float last_angle = data.a;\n\n    vec2 vel = normalize(vec2(0.0, 1.0) * rot2(-last_angle)) * speed + random(vec2(t)) * speed / 10.0;\n    vec2 cur_pos = (t - last_t) * vel + last_pos;\n\n    if (abs(cur_pos.x) > 0.5 || abs(cur_pos.y) > (0.5 / asp)) {\n        cur_pos = (t - last_t) * -1.0 * vel + last_pos;\n        random_angle += PI;\n    }\n\n    if (coord.x < 1 && coord.y < 1) {\n        fragColor.x = t;\n        fragColor.yz = cur_pos;\n        fragColor.a = random_angle;\n    } else {\n        if (iFrame < 1) {\n            fragColor.a = 1.0;\n            return;\n        }\n        fragColor = opUcolor(texture(iChannel0, uv), vec4(autumn(sin(iTime / 3.0) * 0.5 + 0.5), sdSegment(pos, last_pos, cur_pos) - 0.0005));\n        // fragColor.x = opU(texture(iChannel0, uv).x, sdBox(pos - data.yz, vec2(0.02)));\n        //fragColor.x = opSub(fragColor.x, sdBox(pos - cur_pos, vec2(0.01)));\n    }\n    // fragColor.x = sdSegment(pos, last_pos, cur_pos);\n    // vec2 uv = fragCoord / iResolution.xy;\n    // float asp = iResolution.x / iResolution.y;\n    // vec2 pos = uv - 0.5;\n    // pos.y /= asp;\n\n    // float t = round(iTime * 10.0) / 10.0;\n\n    // float col = step(0.0, map(pos, t));\n    // fragColor.rgb = vec3(col);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 hash( uvec3 x )\n{  \n    //https://www.shadertoy.com/view/4lXyWN\n    \n    //multiply large prime value first.\n    uint k = 1103515245U;\n    x*= k;\n    //mix x, y, z values.\n    //Without shift operator, x, y and z value become same value.\n    x = ((x>>2u)^(x.yzx>>1u)^x.zxy)*k;\n \n    return (vec3(x)*(1.0/float(0xffffffffU)));\n}\n\nvec3 noise(vec3 p)\n{\n    uvec3 fl = uvec3(floor(p));\n    vec3 fr = fract(p);\n    fr = smoothstep(0.0,1.0,fr);\n    vec3 tr = hash(fl + uvec3(0,0,0));\n    vec3 tl = hash(fl + uvec3(1,0,0));\n    vec3 br = hash(fl + uvec3(0,1,0));\n    vec3 bl = hash(fl + uvec3(1,1,0));\n    vec3 tr2 = hash(fl + uvec3(0,0,1));\n    vec3 tl2 = hash(fl + uvec3(1,0,1));\n    vec3 br2 = hash(fl + uvec3(0,1,1));\n    vec3 bl2 = hash(fl + uvec3(1,1,1));\n        \n    \n    vec3 res = mix(mix(mix(tr, tl, fr.x), mix(br, bl, fr.x), fr.y)\n            ,mix(mix(tr2,tl2,fr.x), mix(br2,bl2, fr.x), fr.y),fr.z);\n    \n    vec3 result = (1.0 + res)*0.5; //map to [0,1]\n\n    return res;\n}\n\n\nvec3 fbm_levels(vec3 p, int levels)\n{\n    vec3 r = vec3(0);\n    \n    float m = 1.0f;\n    for (int i = 0; i < levels; i++)\n    {\n       m *= 0.5f;\n       r += m * noise(p); \n       p *= 2.03;\n    }\n    return r;\n}\n\nvec3 fbm(vec3 p)\n{\n    return fbm_levels(p,4);\n}\n\n\nvec3 pattern(vec3 p)\n{\n    vec3 q = fbm(p);\n    vec3 r = fbm(p + 4.*q);\n    \n    vec3 result;\n    result.x = fbm(p + fbm(p + 2.*fbm(p + q))).x;\n    result.y = q.x;\n    result.z = r.x;\n    return result;\n}\n\nvec3 sampleFloor(vec2 coord)\n{    \n    coord = coord * 1.8f + 0.25;\n    float g1 = 0.10f;\n    float g2 = 0.025f;\n    bool b1 = ((1.0 - fract(coord.x - g1/2.0f)) < g1 || (1.0 - fract(coord.y - g1/2.0f) < g1));\n    bool b2 = ((1.0 - fract(coord.x - g2/2.0f)) < g2 || (1.0 - fract(coord.y - g2/2.0f) < g2));\n    \n    vec3 baseCol;\n    \n    vec3 nRes = noise(vec3(coord * 100.0f,1.0f));\n    if (!b1 && !b2)\n    {\n        vec3 fRes = fbm_levels(vec3(coord * 5.0f,1.0f),3);\n        baseCol = vec3(0.3 + fRes.r * 0.3f+ nRes.r * 0.2f);\n    }\n    else if (b1 && !b2)\n    {\n        baseCol = vec3(0.1 + 0.2 * nRes.y);\n    }\n    else\n    {\n        baseCol = vec3(0.7 + 0.2 * nRes.z);\n    }\n    \n    //\n    vec3 timed_p = vec3(coord * 0.3f,iTime*0.4f + fbm(vec3(coord + 5.0,10.0))); \n    vec3 fRes = fbm_levels(timed_p,2);\n    \n    float cPow = 50.0f;\n    vec3 cCol = vec3(1);\n    \n    vec3 caustics = vec3(0);\n    caustics += pow(clamp(1.0-abs((fRes.y - 0.5f)),0.0f , 1.0f),cPow) * cCol;\n    caustics += pow(clamp(1.0-abs((fRes.x - 0.5f)),0.0f , 1.0f),cPow) * cCol;\n    caustics += pow(clamp(1.0-abs((fRes.z - 0.5f)),0.0f , 1.0f),cPow) * cCol;\n\n    return clamp(baseCol + caustics * 0.2f,0.0,1.0);\n}\n\nvec2 CalcUV(vec2 coord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = coord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    float zoom = 5.0f;\n    uv *= zoom;\n    uv += vec2(50.0,25.0);\n    return uv;\n}\n\nfloat sampleWater(vec2 coord)\n{\n    vec2 uv = CalcUV(coord);\n\n    // Time varying pixel color\n    vec3 p = vec3(uv,iTime/3.0f + fbm(vec3(uv + 5.0,10.0)));\n    vec3 res = pattern(p);\n    vec3 color;\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((res.x*res.x)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                1.0-res.y);\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                1.0-res.z);\n\n    return (color.r + color.g + color.b)/3.0f;\n}\n\n// normals using dfdx dfdy, same for the entire quad\n#define CHEAP_NORMALS 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = CalcUV(fragCoord);\n    vec3 finalCol = sampleFloor(uv);\n#if 1\n    float greyscale = sampleWater(fragCoord);\n\n    // normal \n    float height = 0.05f * iResolution.x; // scales with resolution, because noise also scales with the resolution.\n#if CHEAP_NORMALS\n    float offset = 1.0f;\n    float greyscale_dx = dFdx(greyscale);\n    float greyscale_dy = dFdy(greyscale);\n#else\n    float offset = 0.1f;\n    float greyscale_dx = (sampleWater(fragCoord + vec2(offset,0)) - greyscale);\n    float greyscale_dy = (sampleWater(fragCoord + vec2(0,offset)) - greyscale);\n#endif\n    vec2 dxdy = vec2(greyscale_dx, greyscale_dy);\n    vec3 normal = normalize(vec3(dxdy,offset/height));\n    \n    // light\n    vec3 viewDir = vec3(0,0,-1);\n    vec3 lDir = normalize(vec3(-0.477,-0.477,-0.277));\n    \n    vec3 reflectDir = reflect(lDir, normal);\n    float spec = pow(max(dot(reflectDir,viewDir),0.0f),2.0f);\n        \n    // Output to screen\n    vec3 waterCol = vec3(145, 239, 255) / 255.0f;\n    \n    vec2 samplePos = uv + greyscale;\n    finalCol = sampleFloor(samplePos) * waterCol + spec * 0.5f;\n#endif\n    fragColor = vec4(finalCol,0);\n}","name":"Buffer B","description":"","type":"buffer"}]}