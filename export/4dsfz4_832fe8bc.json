{"ver":"0.1","info":{"id":"4dsfz4","date":"1495097385","viewed":89,"name":"Raymarching test FC","username":"FractalCurious","description":"My first attempt at implementing ray marching (following a tutorial). Attempting to implement shadows on my own.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Based on this tutorial: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415;\n\nstruct object {\n\tfloat sdf;\n    vec3 diffColor;\n    vec3 specColor;\n};\n\nvec3 lightPos;     \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    \n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    \n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat checker(float x, float y) {\n    return mod(mod(x, 1.) + mod(y, 1.), 2.);\n}\n\nfloat regularPoints(float x)\n{\n    return mod(x, 1.);\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat squareSDF(vec3 p, vec3 center, vec3 dimensions) {\n    \n    vec3 d = abs(p - center) - dimensions / 2.;\n    \n  \treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nobject cylinderX(vec3 samplePoint, float radius) {\n    \n    vec3 p = samplePoint;\n    p.x = 0.;\n    \n\treturn object(length(p) - radius, vec3(1., 1., 1.) * regularPoints(samplePoint.x), vec3(1.));\n}\n\nobject cylinderY(vec3 samplePoint, float radius) {\n    \n    vec3 p = samplePoint;\n    p.y = 0.;\n    \n\treturn object(length(p) - radius, vec3(1., 1., 1.) * regularPoints(samplePoint.y), vec3(1.));\n}\n\nobject cylinderZ(vec3 samplePoint, float radius) {\n    \n    vec3 p = samplePoint;\n    p.z = 0.;\n    \n\treturn object(length(p) - radius, vec3(1., 1., 1.) * regularPoints(samplePoint.z), vec3(1.));\n}\n\nobject behindPlane(vec3 p) {\n    \n    vec3 color = vec3(0., 1.1, .99) * (0.3 + 0.7 * mod((p.x - 2.) + (p.y - 2.) * (p.x - 2.) + iTime / 9., 1.));\n    \n\treturn object(p.z + 3., color, vec3(1.));\n}\n\nfloat polarCheckers(vec2 xy) {\n    float r = length(xy) - mod(iTime, 2.);\n    float a = atan(xy.y / xy.x) + iTime;\n    \n    return mod(mod(r, 1.) + mod(a, 2. * 3.1415 / 32.), 2.);\n}\n\nobject leftPlane(vec3 p) {\n    \n    vec3 diffColor = vec3(0., 1., 0.) * polarCheckers(p.yz * 2.);\n    \n\treturn object(p.x + 3., diffColor, vec3(1.));\n}\n\nobject rightPlane(vec3 p) {\n    vec3 diffColor = vec3(0., 1., 0.) * polarCheckers(p.yz * 2.);\n    \n\treturn object(3. - p.x, diffColor, vec3(1.));\n}\n\nobject belowPlane(vec3 p) {\n    \n    vec3 diffColor = vec3(.9, .5, .9) * checker(-p.x, p.z);\n    \n\treturn object(2. + p.y, diffColor, vec3(1.));\n}\n\nobject abovePlane(vec3 p) {\n    float sdf = 2. + .3 * sin(iTime) - p.y;\n    \n    vec3 diffColor = vec3(.9, .5, .9) * checker(p.x, p.z);\n    \n\treturn object(sdf, diffColor, vec3(1.));\n}\n\nobject oUnion(object o1, object o2) {\n    \n    float sdf1 = o1.sdf;\n    float sdf2 = o2.sdf;\n    \n    vec3 diffColor = mix(o1.diffColor, o2.diffColor, step(EPSILON, sdf1));\n    \n\treturn object(min(sdf1, sdf2), diffColor, vec3(1.));\n}\n\nfloat triangleWave(float x) {\n\treturn abs(mod(x, 2.) - 1.);\n}\n\nobject axes(vec3 p) {\n    \n    float radius = 0.03;\n    \n    object xAxis = cylinderX(p, radius);\n    object yAxis = cylinderY(p, radius);\n    object zAxis = cylinderZ(p, radius);\n    \n\treturn oUnion(oUnion(xAxis, yAxis), zAxis);\n}\n\nfloat sphericChecker(vec3 p) {\n\tfloat a = atan(p.z / p.x) + iTime;\n    float b = atan(p.z / p.y) + iTime;\n    \n    return mod(mod(a, 2. * PI / 32.) + mod(b, 2. * PI / 32.), 2.);\n}\n\nobject sphere2(vec3 p) {\n    \n    float cx = -2.5 + 5. * triangleWave(iTime * 15. / 32. + 2.4387);\n    float cz = -0.5 + 13. * triangleWave(iTime * 13. / 32.);\n    \n    vec3 center = vec3(cx, -1.5, cz);\n    \n    float sdf = sphereSDF(p, center, .5);\n    \n    vec3 diffColor = vec3(.9, .8, .3) * sphericChecker(p - center);\n    \n    return object(sdf, diffColor, vec3(1.));\n}\n\n\nvec3 rotateX(vec3 p, float angle) {\n\tvec3 result = p;\n    \n    result.y = p.y * cos(angle) - p.z * sin(angle);\n    result.z = p.y * sin(angle) + p.z * cos(angle);\n    \n    return result;\n}\n\nobject scene(vec3 p) {\n    \n    object light = object(length(lightPos - p) - .03, vec3(1.), vec3(1.));\n    \n    object rightAndLeftWalls = oUnion(leftPlane(p), rightPlane(p));\n    object floorAndCeiling = oUnion(belowPlane(p), abovePlane(p));\n    \n    object walls = oUnion(behindPlane(p), oUnion(rightAndLeftWalls, floorAndCeiling));\n    \n    float sphere1SDF = sphereSDF(p, vec3(0., 0., 0.), 1.);\n    object sphere1 = object(sphere1SDF, vec3(1., 1., 0.), vec3(1.));\n    \n    object sphere2Obj = sphere2(p);\n    \n    object axesObj = axes(p);\n    \n    vec3 square1Coord = rotateX(p - vec3(2., 0., 0.), iTime * 5.);\n    \n    object square1 = object(squareSDF(square1Coord, vec3(0.), vec3(.5)), vec3(.8), vec3(1.));\n    \n    object spheres = oUnion(sphere1, sphere2Obj);\n    \n    object scene = oUnion(oUnion(spheres, walls), oUnion(square1, axesObj));\n    \n    return object(scene.sdf, scene.diffColor, vec3(1.));\n}\n\nfloat sceneSDF(vec3 p) {\n\tobject sceneObj = scene(p);\n    \n    return sceneObj.sdf;\n}\n\nvec3 estimateNormal(vec3 p) {\n\treturn normalize(vec3(\n    \tsceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n    \nvec3 phongShading(vec3 diffColor, vec3 specColor, vec3 surfPoint, vec3 surfNorm, vec3 lightPos, vec3 eyePos)\n{\n    vec3 visionDir = normalize(eyePos - surfPoint);\n    vec3 lightVec = lightPos - surfPoint;\n    vec3 lightDir = normalize(lightVec);\n    float lightDist = length(lightVec);\n    \n    // =================== Figure out if light is occluded by obstacles ====================//\n    \n    float distToObstacle = shortestDistanceToSurface(\n        surfPoint,\n        normalize(lightVec),\n        EPSILON * 20.,\n        lightDist\n    );\n    \n    if (distToObstacle < lightDist) {\n    \treturn vec3(0.); // No dice. We're in the shadow.\n    }\n   \n    // ================= Good, we're not in the shadow! compute light intensity =============//\n    \n    float diffDot = dot(lightDir, surfNorm);\n    float specDot = dot(normalize(visionDir), normalize(reflect(-lightDir, surfNorm)));\n    \n    if (diffDot < 0.) {\n    \treturn vec3(0.);\n    }\n    \n    vec3 diffIntensity = diffColor * diffDot;\n    \n    if (specDot < 0.) {\n    \treturn diffIntensity;\n    }\n    \n    return diffIntensity + 0.5 * specColor * pow(specDot, 10.);\n}\n\nvec3 handleLights(vec3 diffColor, vec3 specColor, vec3 surfPoint, vec3 surfaceNormal, vec3 eyePos) {\n    float light1PosRadius = 2.8;\n    float light1PosAngle = iTime * 2. / 10.;\n    \n    vec3 light1Pos = vec3(\n        light1PosRadius * cos(light1PosAngle),\n        1.5 * sin(iTime / 1.74327623 / 10.),\n        light1PosRadius * sin(light1PosAngle)\n    );\n    \n    vec3 color = phongShading(\n        diffColor,\n        specColor,\n        surfPoint,\n        surfaceNormal,\n        light1Pos,\n        eyePos\n    );\n    \n    vec3 light2Pos = vec3(-1., 1., 1.);\n    \n    color += phongShading(\n        diffColor,\n        specColor,\n        surfPoint,\n        surfaceNormal,\n        light2Pos,\n        eyePos\n    );\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.2, 12.0);\n    \n    float eyeTargetX = sin(1. * iMouse.x / iResolution.x - .5);\n    float eyeTargetY = sin(1. * iMouse.y / iResolution.y - .5);\n    \n    vec3 eyeTargetPos = eye + vec3(eyeTargetX, eyeTargetY, -1.);\n    \n    mat4 viewToWorld = viewMatrix(eye, eyeTargetPos, vec3(0., 1., 0.));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float lightPosRadius = 2.8;\n    float lightPosAngle = iTime * 2. / 2.;\n    \n    lightPos = vec3(\n        lightPosRadius * cos(lightPosAngle),\n        1.5 * sin(iTime / 1.74327623 / 2.),\n        lightPosRadius * sin(lightPosAngle)\n    );\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 surfPoint = eye + dist * worldDir;\n    \n    object sceneObj = scene(surfPoint);\n    \n    vec3 surfaceNormal = estimateNormal(surfPoint);\n    \n    vec3 color = handleLights(\n        sceneObj.diffColor,\n        sceneObj.specColor,\n        surfPoint,\n        surfaceNormal,\n        eye\n    );\n    \n    fragColor = vec4(.5 * color + 0.1, 1.);\n}","name":"Image","description":"","type":"image"}]}