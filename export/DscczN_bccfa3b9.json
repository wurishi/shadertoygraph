{"ver":"0.1","info":{"id":"DscczN","date":"1695214206","viewed":91,"name":"Hexagonal Grids","username":"cesor","description":"hexagonal grids construction.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","hexagonalgrids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Hexagonal Grids - https://www.redblobgames.com/grids/hexagons\n    2D distance functions - https://iquilezles.org/articles/distfunctions2d/\n    \n    here we select inverse width & height/\n    \n    HEX_TYPE:\n        1 => flat-top(q)\n            width = 2 * size / COS30\n            height = 2 * size\n        2 => pointy-top(r)\n            width = 2 * size\n            height = 2 * size / COS30\n            \n    ODEVITY:\n        1 => (odd)\n            HEX_TYPE==1 => odd-q\n            HEX_TYPE==2 => odd-r\n        2 => (even)\n            HEX_TYPE==1 => even-q\n            HEX_TYPE==2 => even-r\n\n    COORD:\n        1 => OFFSET_COORD\n        2 => AXIAL_COORD\n*/\n#define PI     3.14159265\n#define COS30 .866025404 // sqrt(3)/2\n#define SIN30 .5\n#define TAN30 .577350269 // sqrt(3)/3\n#define HEX_TYPE 2\n#define ODEVITY 1\n#define COORD 2\n\n// COORD == 1\n#define ROW_CNT 7\n#define COL_CNT 13\n\n// COORD == 2\n#define RADIUS 3\n\n//const vec3 k = vec3(-sqrt(3.)/2., 1./2., sqrt(3.)/3.);\nconst vec3 k = vec3(-COS30, SIN30, TAN30); // cos, sin, tan of PI/6\nfloat sdHexagon(vec2 p, float r)\n{\n    p = abs(p);\n#if HEX_TYPE==1\n    p -= 2. * min(dot(k.xy,p), 0.) * k.xy;\n    p -= vec2( clamp(p.x, -k.z*r, k.z*r), r );\n    return length(p) * sign(p.y);\n#else\n    p -= 2. * min(dot(k.yx,p), 0.) * k.yx;\n    p -= vec2( r, clamp(p.y, -k.z*r, k.z*r) );\n    return length(p) * sign(p.x);\n#endif\n}\n\nvec2 hex2pixel(vec2 hex, float rd)\n{\n    float q = float(hex.x);\n    float r = float(hex.y);\n    float a = 3. / (2. * COS30);\n    float b = 1.;\n    float c = 2.;\n#if HEX_TYPE==1\n    float x = (a * q) * rd;\n    float y = (b * q + c * r) * rd;\n#else\n    float x = (c * q + b * r) * rd;\n    float y = (a * r) * rd;\n#endif\n    return vec2(x, y);\n}\n\nvec3 axial2cube(vec2 axial)\n{\n    float q = axial.x;\n    float r = axial.y;\n    float s = -q-r;\n    return vec3(q,r,s);\n}\n\nvec2 cube2axial(vec3 cube)\n{\n    float q = cube.x;\n    float r = cube.y;\n    return vec2(q,r);\n}\n\nvec2 axialRound(vec2 axial)\n{\n    vec3 cube = axial2cube(axial);\n\n    float q = round(cube.x);\n    float r = round(cube.y);\n    float s = round(cube.z);\n    \n    float q_diff = abs(q-cube.x);\n    float r_diff = abs(r-cube.y);\n    float s_diff = abs(s-cube.z);\n    \n    if(q_diff>r_diff && q_diff>s_diff)\n        q = -r-s;\n    else if(r_diff > s_diff)\n        r = -q-s;\n    else\n        s = -q-r;\n        \n    return cube2axial(vec3(q,r,s));\n}\n\nvec2 pixel2hex(vec2 p, float rd)\n{\n    float a = 3. / (2. * COS30);\n    float b = 1.;\n    float c = 2.;\n#if HEX_TYPE==1\n    float q = (p.x / a) / rd;\n    float r = (p.y - (b * p.x) / a) / (c * rd);\n#else\n    float q = (p.x - (b * p.y) / a) / (c * rd);\n    float r = (p.y / a) / rd;\n#endif\n    return axialRound(vec2(q,r));\n}\n\nfloat offsetMap(vec2 p, float r, float sc, int i, int j)\n{  \n    vec2 sp = vec2( (r/COS30) * (3./2.), r );\n#if HEX_TYPE==1\n    float odd = float(j&1); // use &1 instead of %2, because it works with negative numbers too.\n    vec2 off = vec2(\n        sp.x * float(j),\n#if ODEVITY==1\n        sp.y * ( 2.*float(i) + odd ) * -1.\n#else\n        sp.y * ( 2.*float(i) - odd ) * -1.\n#endif\n    );\n#else\n    float odd = float(i&1); // use &1 instead of %2, because it works with negative numbers too.\n    vec2 off = vec2(\n#if ODEVITY==1\n        sp.y * ( 2.*float(j) + odd ),\n#else\n        sp.y * ( 2.*float(j) - odd ),\n#endif\n        sp.x * float(i) * -1.\n    );\n#endif\n\n    p *= sc;\n    float d = sdHexagon(p-off, r);\n    return smoothstep(.0, sc*.01, abs(d));\n}\n\nvec3 offsetCoord(vec2 p, float r, float sc, int rowCnt, int colCnt)\n{\n    vec2 sp = vec2( (r/COS30) * (3./2.), r );\n    \n    vec3 col = vec3(1.);\n    for(int i=0; i<rowCnt; i++)\n        for(int j=0; j<colCnt; j++)\n            col *= offsetMap(p, r, sc, i, j);\n    return col;\n}\n\nivec2 axial2off(ivec2 axial)\n{\n    int q = axial.x;\n    int r = axial.y;\n#if HEX_TYPE==1 && ODEVITY==1\n    return ivec2(\n        r + (q-(q&1)) / 2,\n        q\n    );\n#elif HEX_TYPE==2 && ODEVITY==1\n    return ivec2(\n        r,\n        q + (r-(r&1)) / 2\n    );\n#elif HEX_TYPE==1 && ODEVITY==2\n    return ivec2(\n        r + (q+(q&1)) / 2,\n        q\n    );\n#else\n    return ivec2(\n        r,\n        q + (r+(r&1)) / 2\n    );\n#endif\n}\n\nint dirs_q[6] = int[](0, 1, 1, 0, -1, -1);\nint dirs_r[6] = int[](-1, -1, 0, 1, 1, 0);\nivec2 axialNeighbor(ivec2 axial, int dir)\n{\n    return ivec2(\n        axial.x + dirs_q[dir],\n        axial.y + dirs_r[dir]\n    );\n}\n\nint neb_dirs[6] = int[](2, 3, 4, 5, 0, 1);\nfloat axialRing(vec2 p, float r, float sc, int rd)\n{\n    if(rd == 0)\n        return offsetMap(p, r, sc, 0, 0);\n\n    float ret = 1.;\n    for(int i=0; i<6; i++)\n    {\n        ivec2 s = ivec2(\n            dirs_q[i] * rd,\n            dirs_r[i] * rd\n        );\n        int neb_dir = neb_dirs[i];\n        for(int j=0; j<rd; j++)\n        {\n            if (j!=0)\n                s = axialNeighbor(s, neb_dir);\n            ivec2 off = axial2off(s);\n            ret *= offsetMap(p, r, sc, off.x, off.y);\n        }\n    }\n    return ret;\n}\n\nvec3 axialCoord(vec2 p, float r, float sc, int rd)\n{\n    vec3 col = vec3(1.);\n    for(int i=0; i<rd+1; i++)\n        col *= axialRing(p, r, sc, i);\n        \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n#if COORD==1\n    p -= vec2(-1.5,.7);\n#endif\n    float sc = 2.5;\n    \n    float r = .3;\n#if COORD==1\n    vec3 col = offsetCoord(p, r, sc, ROW_CNT, COL_CNT);\n#elif COORD==2\n    vec3 col = axialCoord(p, r, sc, RADIUS);\n#else\n    vec3 col = vec3(1.);\n#endif\n\n    vec2 mo = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    mo *= sc;\n    \n    vec2 hex = pixel2hex(mo, r);\n    vec2 pp = hex2pixel(hex, r);\n    \n    float d = smoothstep(.05, .0, sdHexagon(p*sc-pp, r));\n    col = (1.-d)*col + d*vec3(0.);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}