{"ver":"0.1","info":{"id":"XtsfWX","date":"1513809785","viewed":671,"name":"Angle Grinder","username":"shau","description":"Another Beeple inspired Tunnel ","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime * 2.0\n#define PI 3.14159265359\n#define FAR 140.0 \n#define EPS 0.003\n#define PLATFORM 1.0\n#define WALL 2.0\n#define BOLLARD_LIGHT 3.0\n#define RAIL_LIGHT 4.0\n#define PANEL 5.0\n\nvec3 lp = vec3(4.0, 5.0, -2.0);\nvec3 glowc = vec3(0.0, 0.0, 0.0);\nvec3 ball = vec3(0.0, 0.0, 0.0);\n\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n//IQ SDF \n//IQ - Sphere functions\n//https://iquilezles.org/articles/spherefunctions\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\t\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b*b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//mercury\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat boxSection(vec3 rp, float width) {\n    rp.z = mod(rp.z, 4.0) - 2.0;\n    float ns = sdBox(rp - vec3(0.0, 0.4, 0.0), vec3(width, 0.1, 2.0));\n    ns = min(ns, sdBox(rp - vec3(0.0, -0.4, 0.0), vec3(width, 0.1, 2.0)));\n    ns = min(ns, sdBox(rp - vec3(0.0, 0.0, 1.9), vec3(width, 0.4, 0.1)));\n    rp.yz *= rot(0.2);\n    return min(ns, sdBox(rp - vec3(0.0, 0.0, 0.0), vec3(width, 0.1, 2.0)));\n}\n\n//neat trick from Shane\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\nvec4 map(vec3 rp) {    \n    vec3 q = rp;\n    float wall = 14.0 - abs(q.x);\n    wall = min(wall, 12.0 - abs(q.y));\n    wall = max(wall, min(2.0 - q.y, -(1.5 - q.y)));\n    wall = max(wall, min(-1.5 - q.y, -(-2.0 - q.y)));    \n    float raillight = length(abs(q.xy) - vec2(15.0, 1.75)) - 0.2;\n    float panel = 10.0 - abs(q.x);\n    panel = max(panel, abs(q.y) - 0.8);\n    \n    float bd = mod(q.z, 160.0) - 80.0 > 0.0 ? 1.0 : -1.0;\n    q.z = mod(q.z, 80.0) - 40.0;\n    q.xz *= rot(0.2 * bd);\n    float platform = boxSection(q.zyx - vec3(0.0, 3.0, 0.0), 1.0);\n    platform = min(platform, boxSection(q.zyx - vec3(30.0, -3.0, 0.0), 1.0));\n    q = rp;\n    bd = mod(q.z, 200.0) - 100.0 > 0.0 ? 1.0 : -1.0;\n    q.z = mod(q.z, 100.0) - 50.0;\n    q.xz *= rot(0.2 * bd);\n    platform = min(platform, boxSection(q.zyx - vec3(0.0, 8.0, 0.0), 1.0));\n    platform = min(platform, boxSection(q.zyx - vec3(20.0, -8.0, 0.0), 1.0));\n    q = rp;\n    q.xy = abs(q.xy);\n    platform = min(platform, boxSection(q - vec3(6.0, 3.0, 0.0), 2.0));\n    platform = min(platform, boxSection(q - vec3(10.5, 3.0, 0.0), 2.0));\n    q = rp;\n    q.z = mod(q.z, 20.0) - 10.0;\n    q.x = abs(q.x);\n    float bollard = fCylinder(q - vec3(6.0, -2.0, 0.0), 0.5, 0.4); \n    //bollard = min(bollard, fCylinder(q - vec3(6.0, -1.4, 0.0), 0.5, 0.05)); \n    float bollardlight = fCylinder(q - vec3(6.0, -1.5, 0.0), 0.55, 0.05); \n    \n    vec2 near = nearest(vec2(platform, PLATFORM), vec2(wall, WALL));\n    near = nearest(near, vec2(raillight, RAIL_LIGHT));\n    near = nearest(near, vec2(bollard, PLATFORM));\n    near = nearest(near, vec2(bollardlight, BOLLARD_LIGHT));\n    near = nearest(near, vec2(panel, PANEL));\n\n    return vec4(near, raillight, bollardlight);\n}\n\nstruct Scene {\n    float t;\n    float id;\n    float rli; //rail light\n    float bollli; //bollard light\n    float glli; //glow light     \n};\n\nScene march(vec3 ro, vec3 rd) {\n \n    float t = 0.0;\n    float id = 0.0;\n    float rli = 0.0;\n    float bollli = 0.0;\n    float glli = 0.0;\n    \n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;\n        vec4 scene = map(rp);\n        if (scene.x < EPS || t > FAR) {\n            id = scene.y;\n            break;\n        }\n        \n        rli += 0.05 / (1.0 + scene.z * scene.z * 50.);\n        bollli += 0.1 / (1.0 + scene.w * scene.w * scene.w * 400.);\n        vec3 q = rp;\n        q.xy = abs(q.xy);\n        float blt1 = length(ball - q);\n        glli += 0.2 / (1.0 + blt1 * blt1 * 10.) * 16.0; \n        \n        t += scene.x;            \n    }\n    \n    return Scene(t, id, rli, bollli, glli);\n}\n\nvec3 normal(vec3 rp) {\n    vec2 e = vec2(EPS, 0);\n    float d1 = map(rp + e.xyy).x, d2 = map(rp - e.xyy).x;\n    float d3 = map(rp + e.yxy).x, d4 = map(rp - e.yxy).x;\n    float d5 = map(rp + e.yyx).x, d6 = map(rp - e.yyx).x;\n    float d = map(rp).x * 2.0;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\nvec2 glyphpanel(vec2 uv) {\n    uv.y -= 0.5;\n    vec2 cuv = uv * 4.0 - 2.0;\n    vec2 cmx = mod(cuv, 1.0) - 0.5;\n    float lc = length(cmx);\n    float glyph = smoothstep(0.4, 0.3, lc); \n    float glyphc = smoothstep(0.3, 0.03, lc); \n    glyph *= step(-6.0, cuv.y);\n    glyphc *= step(-6.0, cuv.y);\n    glyph *= step(cuv.y, -2.0);\n    glyphc *= step(cuv.y, -2.0);\n    float r1 = rand(floor(vec2(cuv.x + floor(T * 1.0), cuv.y))) > 0.5 ? 1.0 : 0.0;\n    glyph *= step(cuv.y, -1.0) * step(-8.0, cuv.y) * r1;\n    glyphc *= step(cuv.y, -1.0) * step(-8.0, cuv.y) * r1;\n    float gy = mod(cuv.x + floor(T * 1.0), 15.0);\n    glyph *= step(1.0, gy) * step(gy, 7.0) + step(9.0, gy) * step(gy, 14.0);\n    glyphc *= step(1.0, gy) * step(gy, 7.0) + step(9.0, gy) * step(gy, 14.0);\n    return vec2(glyph, glyphc);\n}\n\n//IQ\n//https://iquilezles.org/articles/fog\nvec3 applyFog(vec3  rgb,      // original color of the pixel\n              float d, // camera to point distance\n              vec3  rayDir,   // camera to point vector\n              vec3  sunDir,\n              float b)  // sun light direction\n{\n    float fogAmount = 1.0 - exp(-d * b);\n    float sunAmount = max(dot(rayDir, sunDir), 0.0);\n    vec3  fogColor  = mix(vec3(0.5, 0.3, 0.8), // purple\n                          vec3(0.7, 0.7, 1.0), // blue\n                          pow(sunAmount, 16.0));\n    return mix(rgb, fogColor, fogAmount);\n}\n\nfloat shadow(vec3 ro, vec3 lp) {\n\n    vec3 rd = normalize(lp - ro);\n    float shade = 1.0;\n    float t = 0.05;    \n    float end = length(lp - ro);\n    \n    for (int i = 0; i < 20; i++) {\n        float h = map(ro + rd * t).x;\n        shade = min(shade, smoothstep(0.1, 0.5, 2.0 * h / t));\n        t += clamp(h, 0.01, 1.);\n        if (h < EPS || t > end) break; \n    }\n\n    return min(max(shade, 0.) + 0.08, 1.0);\n}\n\nvoid setupCamera(vec2 uv, inout vec3 ro, inout vec3 rd) {\n\n    vec3 lookAt = vec3(0.0, 0.0, T * 12.0);\n    ro = lookAt + vec3(0.0, 0.0, -4.0);\n    lp = lookAt + vec3(0.2, 0.3, 0.1);\n    glowc = lookAt + vec3(0.0, 0.0, 130.0);\n    \n    ball = lookAt + vec3(15.0, 1.75, 20.0 + mod(T * 4.0, 200.0) - 100.0);\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n    float sh = 1.0;\n        \n    vec3 ro, rd;\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    setupCamera(uv, ro, rd);\n    \n    Scene scene = march(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        \n        mint = scene.t;\n        vec3 rp = ro + rd * scene.t;\n        vec3 n = normal(rp);\n        vec3 cld = normalize(lp - rp); //camera light direction\n        float clt = length(lp - rp); //camera light distance\n        vec3 gld = normalize(glowc - rp); //glow light direction\n        float glt = length(glowc - rp);\n        \n        if (scene.id == WALL) {\n            \n        } else if (scene.id == PLATFORM) {\n            \n            float diff = max(dot(cld, n), 0.05);\n            float catten = 1.0 / (1.0 + clt * clt * 0.00005);\n            float gspec = pow(max(dot(reflect(-gld, n), -rd), 0.0), 32.0);\n            float gatten = 1.0 / (1.0 + glt * glt * 0.00005);\n            sh = shadow(ro + rd * (scene.t - EPS), glowc);\n            pc = vec3(0.2) * diff * catten;\n            pc += vec3(0., 0.7, 1.0) * gspec * abs(n.x) * gatten * 2.0;\n            pc *= sh;\n            \n        } else if (scene.id == RAIL_LIGHT) {\n            \n            float diff = max(dot(cld, n), 0.2);            \n            float spec = pow(max(dot(reflect(-gld, n), -rd), 0.0), 32.0);\n            float catten = 1.0 / (1.0 + clt * clt * 0.0005);\n            float la = abs(ball.z - rp.z) * 0.3;\n            la = 1.0 / (1.0 * la * la * 0.1);\n            pc = vec3(0.8, 0.5, 1.0) * clamp(diff * la, 0.0, 2.0);\n            pc += vec3(1.0) * spec * catten;\n\n        } else if (scene.id == BOLLARD_LIGHT) {\n            \n            pc = vec3(0.6, 0.6, 1.1);\n    \n        } else if (scene.id == PANEL) {\n            \n            float diff = max(dot(cld, n), 0.05);\n            float atten = 1.0 / (1.0 + clt * clt * 0.03);\n            vec2 glyph = glyphpanel(rp.zy);\n            pc += vec3(0.8, 0.2, 1.0) * glyph.x * 1.0 * atten;            \n            pc += vec3(0.2, 0.5, 1.0) * glyph.y * 8.0 * atten;            \n        }   \n    } else {\n        float nd = noise(vec3(20.0 * rd.x + 0.8 * T, 100.0 * rd.y + 0.8 * T, 10.0 * rd.z + 0.8 * T));\n        pc = vec3(0.8, 0.5, 1.0) * (1.0 - nd) * .8; //background\n        pc += vec3(0.7, 0.7, 1.0) * smoothstep(0.065, 0.06, length(uv)) * 0.8;\n    }\n    //*/\n    \n    pc += vec3(0.8, 0.5, 1.0) * scene.rli * 0.6;\n    pc += vec3(0.2, 0.7, 1.0) * scene.glli * 0.5;\n    pc += vec3(0.0, 0.7, 1.0) * scene.bollli * sh;\n    \n    float st2 = sphIntersect(ro, rd, vec4(glowc, 130.0));\n    if (st2 > 0.0) {\n        vec3 rp = ro + rd * st2;\n        \n        float h = sphDensity(ro, rd, vec4(glowc, 130.0), mint); \n        if (h > 0.0) {\n            pc += vec3(0.0, 1.0, 1.0) * h * h * 2.0;    \n            pc += vec3(0.4, 1.0, 1.0) * h * h * h * h * 10.0;\n        }\n    }\n    \n    pc = applyFog(pc, mint, rd, normalize(vec3(4.0, 5.0, 2.0)), 0.0008);\n    \n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}