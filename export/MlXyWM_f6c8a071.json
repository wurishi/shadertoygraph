{"ver":"0.1","info":{"id":"MlXyWM","date":"1505018717","viewed":359,"name":"Collapsing Waves","username":"KilledByAPixel","description":"Using my pixel fractal code, greatly simplified to be a 1x1 matrix so it's pretty much a 1D fractal for the colors. The shape is formed with some warping effects to give it a wavy effect.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["fractal","zoom","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////\n// Canyon Trip Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= -3.0;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 1.0;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 8;\t// how deep to recurse\nconst float curvature\t\t\t= 0.3;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec4 HsvToRgb(vec4 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec4(s_n) + vec4(s) * cos(2.0 * pi * (c.x + vec4(1.0, 0.6666, .3333, 0.0)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec4 InitPixelColor() { return vec4(0); }\nvec4 CombinePixelColor(vec4 color, float timePercent, int i, int r)\n{\n    vec4 myColor = vec4\n    (\n    \tmix(-0.1, 0.1, RandFloat(i + r)),\n    \tmix(0.0, 0.8, RandFloat(i + r + 100)),\n        mix(0.0, 0.8, RandFloat(i + r + 200)),\n        0.0\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    myColor.y = pow(myColor.y, 4.0);\n    myColor.z = pow(myColor.z, 4.0);\n    color += myColor*f;\n    return color;\n}\n\nvec4 FinishPixel(vec4 color, vec2 uv)\n{\n    // color wander\n    color.x += 0.02*iTime;\n    \n    // convert to rgb\n    return HsvToRgb(color);\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.05*sin(10.0*uv.y + 0.17*iTime);\n\tuv.y += 0.05*sin(10.0*uv.x + 0.13*iTime);\n\tuv.x += 0.8*sin(2.0*uv.y + 0.31*iTime);\n\tuv.y += 0.8*sin(2.0*uv.x + 0.27*iTime);\n    \n    // spin\n    float theta = 0.05*iTime;\n    float c = cos(theta);\n    float s = sin(theta);\n    uv *= mat2(-s, c, c, s);\n    \n    return uv * 20.0;\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n    \n\t// get time \n    float time = iTime + curvature*pow(abs(uv.x), 1.0);\n\tfloat timePercent = time*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -timePercent);\n\tzoom *= zoomScale;\n\t\n\t// generate recursive colors\n\tfragColor = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n        fragColor = CombinePixelColor(fragColor, timePercent, iterations, r);\n    fragColor = FinishPixel(fragColor, uv);\n}","name":"Image","description":"","type":"image"}]}