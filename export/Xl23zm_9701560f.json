{"ver":"0.1","info":{"id":"Xl23zm","date":"1427919180","viewed":307,"name":"AO Morph","username":"purton","description":"Testing distance functions with simple ambient occlusion.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distance","occlusion","ambient","functions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define MAXT 10.0\n\nfloat map(in vec3 pos)\n{\n    float circle = length(pos) - 2.0 + cos((pos.x + pos.y) * 15.0) * 0.05;\n    float negCircle = length(pos) - 1.4;\n    float cube = length(max(abs(pos) - 1.0, 0.0)) - 0.05;\n    float ground = dot(pos, vec3(0.0, 1.0, 0.0)) + 1.0 + cos(pos.x * 20.0) * 0.05;\n    float ceiling = dot(pos, vec3(0.0, -1.0, 0.0)) + 3.0 + 1.0 + cos(pos.z * 20.0) * 0.05;\n    \n    float shape = mix(circle, cube, 0.5 + 0.5 * cos(iTime));\n    shape = max(-negCircle, shape);\n    return min(shape, min(ground, ceiling));\n}\n\nvec3 castRay(in vec3 ro, in vec3 rd)\n{\n    vec3 p = vec3(0.0);\n    float t = 0.0;\n    \n    for(int i = 0; i < 64; i++)\n    {\n        p = ro + rd*t;\n        float dist = map(p);\n        \n        if (dist < 0.0 || t > MAXT)\n            break;\n        \n        t += max(dist * 0.8, 0.001);\n    }\n    \n    return p;\n}\n\nvec3 getNormal(in vec3 pos)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 normal = vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx));\n    return normalize(normal);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal)\n{\n    float dist = 0.1;\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos);\n    return clamp(sdist / dist, 0.5, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(p.x, p.y, 0.5));\n    \n    vec3 hitp = castRay(ro, rd);\n    vec3 normal = getNormal(hitp);\n    float ao = getAO(hitp, normal);\n    float ndist = distance(ro, hitp) / MAXT;\n    \n    fragColor = vec4(1.0) * ao - ndist;\n}\n","name":"","description":"","type":"image"}]}