{"ver":"0.1","info":{"id":"lcdfzX","date":"1733348837","viewed":116,"name":"closeup view","username":"pb","description":"close up view of a nice spot on a 3d fractal, not suitable for animation due to slow fps,  click mouse to animate light if you have a nice GPU","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["3d","fractal","raymarch"],"hasliked":0,"parentid":"lfcfDn","parentname":"oumuamua"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n        uv = u/R;\n\n    O *= 0.;\n\n    float totdist = texture(iChannel0,uv).a;\n    \n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    //golfed by fabriceneyret2\n    for (int k; k < 25; k++)      \n        O += gk1s[k] * texture(iChannel0, uv + ( vec2(k%5,k/5) - 2. ) / R );\n\n    //O +=  fwidth(O*4.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//philip.bertani@gmail.com\n\nvec3  ro, ifs_color, light_direction;\nfloat max_iter, normal_mult, norm_dist_expand, sc, glow=0.;\n\nmat3 rot_xz_yz(float a1, float a2) {\n    float c1=cos(a1),c2=cos(a2),s1=sin(a1),s2=sin(a2);\n    return mat3(    c1, 0.,    -s1,\n                -s2*s1, c2, -s2*c1,\n                 c2*s1, s2,  c2*c1 );\n}\n\n# define rot(a) mat2(cos(a+vec4(0,11,33,0)))\nfloat mbox (vec3 p)\n{\n    ifs_color = vec3(0.);\n    vec4 offset=vec4(p,1.), v=offset;\n  \n    float n=0.;\n    for (; n<44.;n++) {\n\n        v.xyz = clamp (v.xyz,-1.-.5,1.+.3) * 1.855\n                - v.xyz;\n\n        v = v * 1.9\n        / clamp (dot (v.xyz, v.xyz),\n            .01, 2.8) + offset;\n\n    }\n    \n    sc = v.w;  //for coloring\n  \n    return length (v.xyz) / v.w ;\n}\n\nfloat all_objects(vec3 p) {\n    return max( mbox(p), -(length(p-ro)-.002 ) );\n}\n\nvec3 gradient(vec3 p) {\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = (1e-5 + norm_dist_expand/2.) * dpn; \n    vec3 df = dpn.xxx * all_objects(p+dp.xxx) +\n              dpn.yyx * all_objects(p+dp.yyx) +\n              dpn.xyy * all_objects(p+dp.xyy) +\n              dpn.yxy * all_objects(p+dp.yxy);\n    return normalize(df); \n}\n\n\nvec3 bg(vec3 p, vec3 rd, float dist, float totdist) {\n\n    vec3 color = cos(log(1.+sc)+4.*vec3(1,2,3)) * .9;\n    return color*color;\n}\n\nvec3 color(vec3 p, vec3 rd, float dist, float totdist) {\n\n    float t2 = totdist;\n    \n    norm_dist_expand = totdist/200.;\n\n    vec3 nv = gradient(p);\n\n    vec3 color = cos(log(sc) + vec3(1,2,3));\n    \n    color = 1. - exp(-color*color);\n\n    color = exp(-t2)*color \n              * max (0., dot (nv, -light_direction))  \n              \n         +  exp(-t2*2.)\n            *pow ( max (0., dot (-light_direction,\n                reflect (rd, nv))), 32. );\n\n    return color;\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n\n    float tt = mod(100.34/2.-39.,40.);\n    \n    xy = (2.*xy - iResolution.xy)/iResolution.y;\n    \n    ro = vec3(.118+.038,.152+.03,3.7-.23);\n    \n\n    vec3 rd = normalize(vec3(xy,-1.7));\n     \n    rd.yz *= rot(.4);\n    rd.xz *= rot(.9);\n    \n    ro.x +=  tt/600.;\n    ro.z -=  tt/10.; \n      \n    float lt = 169.5;\n    \n    if (iMouse.z > 0.) lt=iTime;\n    \n    light_direction = \n        normalize(vec3(-.5*cos(lt),-.1,-.8+.6*sin(lt) ) ); \n    \n    vec3  p=ro;\n    float dist,totdist;\n    float eps = 3e-6, hit_threshold=eps;\n\n    float distfac = 15.;\n    vec3  rgb = vec3(0.);\n    \n    float maxd = 2.5;\n    for (float f=0.; f<1000.; f++) {\n    \n        dist = .05*all_objects(p);\n        \n        if ( \n             dist < hit_threshold || totdist > maxd) \n            \n           \n            { rgb = totdist > maxd\n              ? vec3(0)\n              : color(p, rd, dist, totdist)\n             ;\n             \n            \n            break; }\n        \n        float stepsize = dist;\n        p += rd*stepsize;\n\n        totdist += stepsize;\n        \n        hit_threshold = eps*(1.+totdist*distfac);\n    \n    }\n    \n    rgba = vec4( rgb, totdist);\n}","name":"Buffer A","description":"","type":"buffer"}]}