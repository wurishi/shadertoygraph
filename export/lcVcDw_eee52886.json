{"ver":"0.1","info":{"id":"lcVcDw","date":"1731968244","viewed":135,"name":"circles on parabola SDF ","username":"morimea","description":"Copy of iq Parabola - distance 2D\nAnd alternative/idea to - [url]https://www.shadertoy.com/view/4cKcW1[/url] - circles on parabola by jt\n\nLook my screenshot in comments.\n\nBufA - just minimal code\nBufB - original by jt\n\nClick to compare. (Mouse.y top/bot)","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["2d","sdf","intersection","circle","distance","geometry","quartic","parabola","parabola"],"hasliked":0,"parentid":"4cKcW1","parentname":"circles on parabola touch circle"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// just alternative to\n// circles on parabola touch circle by jt\n// https://www.shadertoy.com/view/4cKcW1\n\n// self https://www.shadertoy.com/view/lcVcDw\n\n\n// Only reason to make it - I think SDF version of solution is simpler(by code/logic) that all.\n// Look BufA to see minimal implementation of this\n\n\n\n\n// MOUSE CLICK - to compare BufA to BufB (move Mouse.y top/down half)\n// BufB is original by jt\n\n\n\n// using \n// https://iquilezles.org/articles/distfunctions2d/\n\n\n// watch https://www.youtube.com/live/fjOdtSu4Lm4?t=9243\n// Math for Game Devs [2022, part 1] • Numbers, Vectors & Dot Product by Freya Holmér\n// 2:34:00 - next few min - simple related math explained there\n\n\n// look get_parabola_intersect_circle_points\n// maybe there simpler/better weays - do better if you can\n// I made this - interpolation to parabola (bad on low steps)\n// just drawing line from parabola normal and getting line intersectiong with circle\n\n\n\n// edit this - set less to see steps, like 8\n// 16 give not too bad result for this case\nconst int SDF_LOOP = 16;\n\n// define to do second test after first\n// debug-draw display only first\n#define SECOND_TEST\n\n\n\n\n\n// can be used to debug with mouse\n#define iTime mix(iTime,5.+12.*iMouse.x/iResolution.x,float(iMouse.z>0.))\n//#define iTime 0.\n\n\n// https://iquilezles.org/articles/distfunctions2d/\n// https://www.shadertoy.com/view/ws3GD7\nfloat sdParabola( in vec2 pos, in float k )\n{\n    pos.x = abs(pos.x);\n    \n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    \n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        // 1 root\n        pow(q+r,1.0/3.0) + pow(abs(q-r),1.0/3.0)*sign(p) :\n        // 3 roots\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    \n    float d = length(pos-vec2(x,k*x*x));\n    \n    return (pos.x<x)? -d : d;\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n// SDF alternative to https://www.shadertoy.com/view/4cKcW1\n// get_parabola_intersect_circle_points return 4 points where parabola intersect circle\n\n// just loop-around-circle and check where sdf in/out that simple\n\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\nvec2 circle_line_intersect(vec2 p0, vec2 dir, float cr){\n    float a = p0.x, b = p0.y;\n    float u = dir.x, v = dir.y;\n    float t = (sqrt(-a*a*v*v + 2.0*a*b*u*v - b*b*u*u + cr*cr*(u*u+v*v)) - a*u - b*v) / (u*u + v*v);\n    return p0 + dir * t;\n}\nvec2 calcNormal( in vec2 pos, vec3 pabc)\n{\n    vec2 e = vec2(1.0,0.0)*0.0025;\n    return normalize( e.xy*sdParabola( pos + e.xy-pabc.xy, pabc.b) + \n\t\t\t\t\t  e.yx*sdParabola( pos + e.yx-pabc.xy, pabc.b) + \n\t\t\t\t\t -e.xy*sdParabola( pos - e.xy-pabc.xy, pabc.b) + \n\t\t\t\t\t -e.yx*sdParabola( pos - e.yx-pabc.xy, pabc.b) );\n}\n\n//point1-2 is just debug can be deleted\nmat4x2 get_parabola_intersect_circle_points(float cr, vec3 pabc, out mat4 point1, out mat4 point2){\n    mat4x2 ret = mat4x2(vec2(0.),vec2(0.),vec2(0.),vec2(0.));\n    point1 = mat4(vec4(0.),vec4(0.),vec4(0.),vec4(0.));\n    point2 = mat4(vec4(0.),vec4(0.),vec4(0.),vec4(0.));\n    \n    int idx = 0;\n    for(int a = 0; a<SDF_LOOP; a++){\n        \n        vec2 tp1 = vec2(0.,cr)*MD(float(a)/float(SDF_LOOP)*3.14159265*2.);\n        vec2 tp2 = vec2(0.,cr)*MD(float(a+1)/float(SDF_LOOP)*3.14159265*2.);\n        \n        float td1 = sdParabola( -tp1-pabc.xy, pabc.b);\n        float td2 = sdParabola( -tp2-pabc.xy, pabc.b);\n\n        if(sign(td1)!=sign(td2)){\n            float flip = 1.;\n            if(!(td1>=0.)){td1=td2;tp1=tp2;flip=-1.;}\n            \n            {\n                vec2 pn = -calcNormal(-tp1, pabc);\n                \n                // this is just \"some interpolation of normal to parabola\"\n                // to predict position of parabola-circle intersect - more steps better position\n                // look screenshot:\n                // https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/lcVcDw.png\n                float dm = atan(pn.y,pn.x)/(3.14159265*2.);\n                ret[idx].xy = vec2(0.,cr)*MD((float(a+int(flip<0.))/float(SDF_LOOP))*3.14159265*2.);\n                ret[idx].xy = ret[idx].xy-td1*pn;\n                vec2 pnt = circle_line_intersect(ret[idx].xy, vec2(-1.*flip,0.)*MD((dm-0.25)*3.1415926*2.), cr);\n                ret[idx].xy = pnt;\n                \n                // second iteration to get closer result\n#ifdef SECOND_TEST\n                {\n                    float ttd1 = sdParabola( -ret[idx].xy-pabc.xy, pabc.b);\n                    vec2 pn2 = -calcNormal(-ret[idx].xy, pabc);\n                    float dm2 = atan(pn.y,pn.x)/(3.14159265*2.);\n                    ret[idx].xy = ret[idx].xy-ttd1*pn2;\n                    vec2 pnt = circle_line_intersect(ret[idx].xy, vec2(-1.*flip,0.)*MD((dm2-0.25)*3.1415926*2.), cr);\n                    ret[idx].xy = pnt;\n                }\n#endif\n\n                // debug data\n                // debug shows only first iteration, not include second loop like above\n                {\n                    // static pos of circle-step - arrow to parabola normal\n                    point1[idx].xy = vec2(0.,cr)*MD((float(a+int(flip<0.))/float(SDF_LOOP))*3.14159265*2.);\n                    point1[idx].b = dm; // angle of vector\n                    point1[idx].a = td1; // length of vector\n\n                    // 90-deg rotated normal from parabola point - length to circle-line intersect\n                    point2[idx].xy = point1[idx].xy-td1*pn; //same as below\n                    //point2[idx].xy = point1[idx].xy-vec2(td1,0.)*MD((dm)*3.1415926*2.);\n\n                    vec2 pnt = circle_line_intersect(point2[idx].xy, vec2(-1.*flip,0.)*MD((dm-0.25)*3.1415926*2.), cr);\n                    point2[idx].b = dm+flip*0.25*(1.-2.*float(length(point2[idx].xy)<cr)); // angle of vector\n                    point2[idx].a = distance(pnt,point2[idx].xy); // length of vector\n                }\n            \n            }\n\n            idx+=1;\n            if(idx>3)break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat get_arrow(vec2 arrow_uv, float arrow_aa, float arrow_angle, float arrow_norm);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\nif(iMouse.z>0.&&iMouse.y>iResolution.y*0.5){\n    fragColor = vec4(0.,1.,0.,1.)*texture(iChannel0,fragCoord/iResolution.xy);\n    \n    fragColor+= vec4(1.,0.,0.,1.)*(1.-clamp((texture(iChannel1,fragCoord/iResolution.xy)-0.75)*10.,0.,1.));\n    return;\n}\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n// copy from\n// https://www.shadertoy.com/view/4cKcW1\n//-------------\n    float r0 = 0.1;\n    float d = mix(0.9, 0.75, cos(iTime/2.0) * 0.5 + 0.5);\n    \n    float d2 = sdCircle(p, d);\n    d += r0;\n    float d3 = sdCircle(p, d);\n\n    float x0 = cos(iTime * 0.2) * d * mix(0.5, 1.0, cos(iTime/3.0) * 0.5 + 0.5);\n    float y0 = sin(iTime * 0.2) * d * mix(-1.5, 0.5, cos(iTime) * 0.5 + 0.5);\n\n    float s = mix(0.2, 2.0, cos(iTime) * 0.5 + 0.5);\n    s = 1./(s*s);\n//-------------\n\n    float d1 = sdParabola( p-vec2(x0,y0), s );\n\n    float td = min(d1, d2);\n    td = min(td, d3);\n    td = d1;\n    \n    vec3 col = (td>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(td));\n\tcol *= 0.7 + 0.2*cos(110.0*td);\n\t\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d1)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d2)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d3)) );\n    \n    \n// draw/get parabola-circle intersect points\n//-------------\n    mat4 dp1, dp2; //debug points\n    mat4x2 points = get_parabola_intersect_circle_points(d, vec3(x0,y0,s), dp1, dp2);\n    \n    for(int a = 0; a<4; a++){\n        float tcd = 0.;\n        if(length(points[a].xy)>0.001){\n            tcd = sdCircle(p+points[a].xy, r0);\n            col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(tcd)) );\n            col= mix( col, vec3(0.2,0.2,1.0), get_arrow(p+dp1[a].xy, 1./iResolution.y, dp1[a].b*3.1415926*2., dp1[a].w));\n            col= mix( col, vec3(0.2,1.0,0.2), get_arrow(p+dp2[a].xy, 1./iResolution.y, dp2[a].b*3.1415926*2., dp2[a].w));\n        }\n    }\n    \n//-------------\n\n\tfragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n// arrow from ollj\n// https://www.shadertoy.com/view/XsBBRd\n\n// ------------------------------------------------------------------------------------------------\nfloat m_stretch(float point, float stretch){\n    return .5 * (sign(point) * stretch - point) * (sign(abs(point) - stretch) + 1.);\n}\n\nfloat ollj_rotate(vec2 uv){\n    const float ROTATE_PARAM0 = sqrt(1.);\n    const float ROTATE_PARAM1 = sqrt(.0);\n    return dot(uv, vec2(ROTATE_PARAM0 + ROTATE_PARAM1, ROTATE_PARAM0 - ROTATE_PARAM1));\n}\n\n\nfloat sdf_arrow(vec2 uv, float norm, float angle, float head_height, float stem_width){\n    uv = vec2(cos(angle) * uv.x + sin(angle) * uv.y, -sin(angle) * uv.x + cos(angle) * uv.y);\n\n    norm -= head_height;\n    uv.x -= norm;\n\n    uv.y = abs(uv.y);\t\t\n    float head = max(ollj_rotate(uv) - head_height, -uv.x);\n\n    uv.x = (.5 * m_stretch(2. * uv.x + norm, norm));\n    uv.y = (.5 * m_stretch(2. * uv.y, stem_width));\n    float stem = length(uv);\n\n    return min(head, stem);\n}\n\nfloat get_arrow(vec2 arrow_uv, float arrow_aa, float arrow_angle, float arrow_norm){\n    float arrow_head_height = .051;  \n    float arrow_stem_width = .024; \n    float arrow;\n    arrow = sdf_arrow(arrow_uv, arrow_norm, arrow_angle, arrow_head_height, arrow_stem_width);\n    arrow = 1.-smoothstep(0., arrow_aa, arrow);\n\n    return arrow;\n}\n\n// --------------------------\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// just alternative to\n// circles on parabola touch circle by jt\n// https://www.shadertoy.com/view/4cKcW1\n\n\n// this exist just as for-fun-experiment\n// no idea if it usable\n\n// self https://www.shadertoy.com/view/lcVcDw\n\n\n\nconst int SDF_LOOP = 16;\n\n// can be used to debug with mouse\n#define iTime (5.+12.*iMouse.x/iResolution.x)\n//#define iTime 0.\n\n//----------------------\n\nfloat sdParabola( in vec2 pos, in float k );\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\nvec2 circle_line_intersect(vec2 p0, vec2 dir, float cr){\n    float a = p0.x, b = p0.y;\n    float u = dir.x, v = dir.y;\n    float t = (sqrt(-a*a*v*v + 2.0*a*b*u*v - b*b*u*u + cr*cr*(u*u+v*v)) - a*u - b*v) / (u*u + v*v);\n    return p0 + dir * t;\n}\nvec2 calcNormal( in vec2 pos, vec3 pabc)\n{\n    vec2 e = vec2(1.0,0.0)*0.0025;\n    return normalize( e.xy*sdParabola( pos + e.xy-pabc.xy, pabc.b) + \n\t\t\t\t\t  e.yx*sdParabola( pos + e.yx-pabc.xy, pabc.b) + \n\t\t\t\t\t -e.xy*sdParabola( pos - e.xy-pabc.xy, pabc.b) + \n\t\t\t\t\t -e.yx*sdParabola( pos - e.yx-pabc.xy, pabc.b) );\n}\n\nmat4x2 get_parabola_intersect_circle_points(float cr, vec3 pabc){\n    mat4x2 ret = mat4x2(vec2(0.),vec2(0.),vec2(0.),vec2(0.));\n    \n    int idx = 0;\n    for(int a = 0; a<SDF_LOOP; a++){\n        \n        vec2 tp1 = vec2(0.,cr)*MD(float(a)/float(SDF_LOOP)*3.14159265*2.);\n        vec2 tp2 = vec2(0.,cr)*MD(float(a+1)/float(SDF_LOOP)*3.14159265*2.);\n        \n        float td1 = sdParabola( -tp1-pabc.xy, pabc.b);\n        float td2 = sdParabola( -tp2-pabc.xy, pabc.b);\n\n        if(sign(td1)!=sign(td2)){\n            float flip = 1.;\n            if(!(td1>=0.)){td1=td2;tp1=tp2;flip=-1.;}\n            \n            {\n                vec2 pn = -calcNormal(-tp1, pabc);\n                float dm = atan(pn.y,pn.x)/(3.14159265*2.);\n                ret[idx].xy = vec2(0.,cr)*MD((float(a+int(flip<0.))/float(SDF_LOOP))*3.14159265*2.);\n                ret[idx].xy = ret[idx].xy-td1*pn;\n                vec2 pnt = circle_line_intersect(ret[idx].xy, vec2(-1.*flip,0.)*MD((dm-0.25)*3.1415926*2.), cr);\n                ret[idx].xy = pnt;\n\n                {\n                    float ttd1 = sdParabola( -ret[idx].xy-pabc.xy, pabc.b);\n                    vec2 pn2 = -calcNormal(-ret[idx].xy, pabc);\n                    float dm2 = atan(pn.y,pn.x)/(3.14159265*2.);\n                    ret[idx].xy = ret[idx].xy-ttd1*pn2;\n                    vec2 pnt = circle_line_intersect(ret[idx].xy, vec2(-1.*flip,0.)*MD((dm2-0.25)*3.1415926*2.), cr);\n                    ret[idx].xy = pnt;\n                }\n            }\n\n            idx+=1;\n            if(idx>3)break;\n        }\n    }\n    \n    return ret;\n}\n\n//----------------------\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdParabola( in vec2 pos, in float k )\n{\n    pos.x = abs(pos.x);\n    \n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    \n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        // 1 root\n        pow(q+r,1.0/3.0) + pow(abs(q-r),1.0/3.0)*sign(p) :\n        // 3 roots\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    \n    float d = length(pos-vec2(x,k*x*x));\n    \n    return (pos.x<x)? -d : d;\n}\n\n//----------------------\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat get_arrow(vec2 arrow_uv, float arrow_aa, float arrow_angle, float arrow_norm);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\nif(iMouse.z<=0.||iMouse.y<iResolution.y*0.5)discard;\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n// copy from\n// https://www.shadertoy.com/view/4cKcW1\n//-------------\n    float r0 = 0.1;\n    float d = mix(0.9, 0.75, cos(iTime/2.0) * 0.5 + 0.5);\n    \n    float d2 = sdCircle(p, d);\n    d += r0;\n    float d3 = sdCircle(p, d);\n\n    float x0 = cos(iTime * 0.2) * d * mix(0.5, 1.0, cos(iTime/3.0) * 0.5 + 0.5);\n    float y0 = sin(iTime * 0.2) * d * mix(-1.5, 0.5, cos(iTime) * 0.5 + 0.5);\n\n    float s = mix(0.2, 2.0, cos(iTime) * 0.5 + 0.5);\n    s = 1./(s*s);\n//-------------\n\n    float d1 = sdParabola( p-vec2(x0,y0), s );\n\n    float td = min(d1, d2);\n    td = min(td, d3);\n    td = d1;\n    \n    vec3 col = vec3(0.);\n\t\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d1)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d2)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d3)) );\n    \n    \n// draw/get parabola-circle intersect points\n//-------------\n    mat4x2 points = get_parabola_intersect_circle_points(d, vec3(x0,y0,s));\n    for(int a = 0; a<4; a++){\n        float tcd = 0.;\n        if(length(points[a].xy)>0.001){\n            tcd = sdCircle(p+points[a].xy, r0);\n            col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(tcd)) );\n        }\n    }\n    \n//-------------\n\n\tfragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n#define iTime (5.+12.*iMouse.x/iResolution.x)\n\n// circles on parabola touch circle by jt\n// https://www.shadertoy.com/view/4cKcW1\n\n\n// https://www.shadertoy.com/view/4cKcW1 circles on parabola touch circle, 2024 by jt\n// https://www.shadertoy.com/view/7lVfD1 Parabola Circle Intersection 2 by jt\n// Apply depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n// to https://www.shadertoy.com/view/NtyfD1 Parabola Circle Intersection by jt\n\n// If the static circle is offset by the radius of the animated bouncing circle,\n// then parabola-circle intersection returns positions where circles touch.\n// This could be used to animate exact collision of a bouncing circle.\n\n// Thanks @mla for depressed quartic solver from https://www.shadertoy.com/view/7dSBWz Cyclides\n\n// tags: intersection, circle, geometry, quartic, parabola, depressed\n\n// Potentially relevant links:\n// https://en.wikipedia.org/wiki/Quartic_function\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf (thanks, mla!)\n// https://www.nickalls.org/dick/papers/maths/quartic2009.pdf\n// https://www.maa.org/press/periodicals/convergence/descartes-method-for-constructing-roots-of-polynomials-with-simple-curves-depressed-quartics-and\n\n// NOTE: For a possible OTHER shader, parabola-parabola intersection, from https://www.geogebra.org/m/X2E9Dzvs \"Intersection of a vertical and horizontal parabola\"\n//       \"The intersection points of a vertical and horizontal parabola lie on a circle whose centre's distance from the directrices is the sum of distances of the foci from the directrices (in both the x and y directions.\"\n\n//#define POINTSIZE 0.01\n#define POINTSIZE (5.0/R.y) // resolution-independent\n#define draw_point(q) o *= smoothstep(0.0, POINTSIZE, abs(q))\n#define draw_circle(r, I) draw_point(length(I) - r)\n#define draw_quadratic(A, B, C, I) draw_point(draw_quadratic_helper(A, B, C, I))\n\n#define draw_point_grey(q) o *= (0.5+0.5*smoothstep(0.0, POINTSIZE, abs(q)))\n#define draw_circle_grey(r, I) draw_point_grey(length(I) - r)\n#define draw_quadratic_grey(A, B, C, I) draw_point_grey(draw_quadratic_helper(A, B, C, I))\n\n\nfloat parabola(float A, float B, float C, float x)\n{\n    return A*x*x+B*x+C;\n}\n\nfloat parabola_derivative(float A, float B, float x) // NOTE: C disappears due by derivative\n{\n    return 2.0*A*x+B;\n}\n\nfloat draw_quadratic_helper(float A, float B, float C, vec2 I)\n{\n    return (parabola(A, B, C, I.x)-I.y)/length(vec2(parabola_derivative(A, B, I.x),-1.0)); // divide by length of the gradient to get a constant width line - thanks, mla!\n}\n\n// START depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\nfloat sgn(float x)\n{\n    return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) // based on depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n{\n    float x1,x2;\n    float b = -0.5*B;\n    float q = b*b - A*C;\n    if (q < 0.0) return 0;\n    float r = b + sgn(b)*sqrt(q);\n    x1 = C/r;\n    x2 = r/A;\n    res = vec2(x1,x2);\n    return 2;\n}\n\n\n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\nvec4 eval(float X, float B, float C, float D) // based on depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n{\n    float B1 = X+B;\n    float C2 = B1*X+C;\n    float DQ = (X+B1)*X + C2;\n    float Q = C2*X + D;\n\n    return vec4(Q, DQ, B1, C2);\n}\n\nfloat qcubic(float B, float C, float D) // based on depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n{\n    float X = -B/3.0;\n\n    vec4 e = eval(X,B,C,D);\n\n    float r = pow(abs(e.x),1.0/3.0);\n    if (-e.y > 0.0) r = 1.324718*max(r,sqrt(-e.y)); // NOTE: Is 1.324718 here the https://en.wikipedia.org/wiki/Perrin_number ?\n    float x0 = X - (e.x < 0.0 ? -r : +r);\n    if (x0 != X)\n    {\n        X = x0;\n        for (int i = 0; i < 4; i++)\n        {\n            e = eval(X,B,C,D);\n            if (e.y == 0.0) break;\n            X -= e.x/e.y;\n        }\n\n        if (X*X > abs(D/X))\n        {\n            e.w = -D/X;\n            e.z = (e.w - C)/X;\n        }\n    }\n\n    vec2 res;\n    if (quadratic(1.0,e.z,e.w,res) == 0) return X;\n\n    X = max(X,res[0]);\n    X = max(X,res[1]);\n\n    return X;\n}\n\nint biquadratic(float p, float r, out vec4 res) // based on depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n{\n    // Solve x^4 + px^2 + r = 0 (ie. a quadratic equation in x^2)\n    vec2 t;\n    if (quadratic(1.0,p,r,t) == 0) return 0;\n    int n = 0;\n    for (int i = 0; i < 2; i++)\n    {\n        if (t[i] >= 0.0)\n        {\n            float x = sqrt(t[i]);\n            res[n++] = -x;\n            res[n++] = x;\n        }\n    }\n    return n;\n}\n\n// Descartes solver for depressed quartics\n// ie. x^4 + px^2 + qx + r = 0\nint dquartic(float p, float q, float r, out vec4 res) // based on depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n{\n    if (abs(q) < 0.001) return biquadratic(p,r,res);\n    float A = 2.0*p;\n    float B = p*p-4.0*r;\n    float C = -q*q;\n    float U = qcubic(A,B,C);\n    //assert(U >= 0.0);\n    float u = sqrt(U);\n    float s = -u;\n    float t = 0.5*(p+U+q/u);\n    float v = 0.5*(p+U-q/u);\n    int n1 = quadratic(1.0,s,t,res.xy);\n    int n2 = quadratic(1.0,u,v,res.zw);\n    if (n1 == 0) res.xy = res.zw;\n    return n1+n2;\n}\n\n// END depressed quartics solver from https://www.shadertoy.com/view/7dSBWz Cyclides by mla\n\nvoid mainImage(out vec4 o, vec2 I)\n{\nif(iMouse.z<=0.||iMouse.y<iResolution.y*0.5)discard;\n    vec2 R = iResolution.xy;\n    I = (I+I-R)/R.y;\n\n    o = vec4(1);\n\n    float r0 = 0.1; // radius of moving circle\n\n    float d = mix(0.9, 0.75, cos(iTime/2.0) * 0.5 + 0.5);\n    draw_point(length(I) - d); // circle\n    d += r0;\n    draw_point_grey(length(I) - d); // circle\n\n    float x0 = cos(iTime * 0.2) * d * mix(0.5, 1.0, cos(iTime/3.0) * 0.5 + 0.5);\n    float y0 = sin(iTime * 0.2) * d * mix(-1.5, 0.5, cos(iTime) * 0.5 + 0.5);\n\n    float s = mix(0.2, 2.0, cos(iTime) * 0.5 + 0.5); // scale parabola\n\n    // y = ((x - x0)/s)^2 + y0 by solving x = s*t + x0 for t then plugging into y = t*t + y0\n    // y = x^2/s^2 - 2*x*x0/s^2 + x0^2/s^2 + y0\n    // y = A * x^2 + B * x + C\n    float A = 1.0/(s*s), B = -2.0*x0/(s*s), C = x0*x0/(s*s)+y0;\n    draw_quadratic_grey(A, B, C, I);\n\n    // x = s*t + x0\n    // y = t*t + y0\n    // d^2 = x*x+y*y\n    // d^2 = (s*t+x0)^2 + (t^2+y0)^2\n    // d^2 = s^2*t^2 + 2*s*t*x0 + x0^2 + t^4 + 2*t^2*y0 + y0^2\n    // 0 = t^4 + t^2*(s^2+2*y0) + 2*s*t*x0 + (x0^2+y0^2-d^2)\n    // 0 = t^4 + p * t^2 + q * t + r\n    float p = s*s+2.0*y0;\n    float q = 2.0*s*x0;\n    float r = x0*x0+y0*y0-d*d;\n\n    vec4 roots;\n    int n = dquartic(p, q, r, roots);\n\n    for(int i = 0; i < n; i++)\n    {\n        draw_circle_grey(0.025, I - vec2(s*roots[i]+x0, roots[i]*roots[i]+y0));\n        draw_circle(r0, I - vec2(s*roots[i]+x0, roots[i]*roots[i]+y0));\n    }\n\n    //float t = (fract(iTime/5.0)*2.0-1.0)*2.0;\n    //draw_circle(r0, I - vec2(t,A*t*t+B*t+C));\n}\n","name":"Buffer B","description":"","type":"buffer"}]}