{"ver":"0.1","info":{"id":"NlV3D1","date":"1637631570","viewed":205,"name":"UI library (In progress)","username":"Balint","description":"Immediate mode UI library for demos","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["uicontrolshsvsliderbutton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n * Controls library created by BÃ¡lint Csala\n * Use it as you like, but please keep the credit around\n */\n\n// NOTE: Everything (apart from chars) has the \"picker\" prefix to avoid name conflicts\n\n// HELPERS\n\nvec3 store24F(float value) {\n    return vec3(\n        floor(value / 256.0 / 256.0),\n        mod(floor(value), 256.0),\n        mod(value, 256.0)\n    ) / 255.0;\n}\n\n// If you already have PI, you can remove this\nconst float PI = 3.141592654;\n\n// rgb2hsv and hsv2rgb by Sam Hocevar https://stackoverflow.com/a/17897228/4934560\n// If you already have these, you can remove them\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n// ---- IMPORTANT PART ----\n\n// CHARACTER SET\n\nconst int _NULL = 255;                // \"NULL terminator\"\nconst int _FAST_BACKWARD = 0;\nconst int _BACKWARD = 1;\nconst int _LEFT_PLAY_ARROW = 2;\nconst int _RECORD = 3;\nconst int _STOP = 4;\nconst int _PLAY = 5;\nconst int _PAUSE = 6;\nconst int _FORWARD = 7;\nconst int _FAST_FORWARD = 8;\nconst int _WHOLE_NOTE = 9;\nconst int _EIGHTH_NOTE = 10;\nconst int _BEAM_NOTE = 11;\nconst int _BIG_BEAM_NOTE = 12;\nconst int _FLAT = 13;\nconst int _LONG = 14;\nconst int _SHARP = 15;\nconst int _LEFT_ARROW = 16;\nconst int _UP_ARROW = 17;\nconst int _RIGHT_ARROW = 18;\nconst int _DOWN_ARROW = 19;\nconst int _LEFT_RIGHT_ARROW = 20;\nconst int _UP_DOWN_ARROW = 21;\nconst int _UP_LEFT_ARROW = 22;\nconst int _UP_RIGHT_ARROW = 23;\nconst int _DOWN_RIGHT_ARROW = 24;\nconst int _DOWN_LEFT_ARROW = 25;\nconst int _CCW_ARROW = 26;\nconst int _CW_ARROW = 27;\nconst int _STAR = 28;\nconst int _SMILEY = 29;\nconst int _NO_SOUND = 30;\nconst int _SOUND = 31;\nconst int _SPACE  = 32;               // space\nconst int _EXCLAMATION = 33;          // !\nconst int _QUOTATION = 34;            // \"\nconst int _HASH = 35;                 // #\nconst int _DOLLAR = 36;               // $\nconst int _PERCENTAGE = 37;           // %\nconst int _AND = 38;                  // &\nconst int _APOSTROPHE = 39;           // '\nconst int _LEFT_PAREN = 40;           // (\nconst int _RIGHT_PAREN = 41;          // )\nconst int _ASTERISK = 42;             // *\nconst int _PLUS = 43;                 // +\nconst int _COMMA = 44;                // ,\nconst int _DASH = 45;                 // -\nconst int _DOT = 46;                  // .\nconst int _SLASH = 47;                // /\nconst int _0 = 48;                    // 0\nconst int _1 = 49;                    // 1\nconst int _2 = 50;                    // 2\nconst int _3 = 51;                    // 3\nconst int _4 = 52;                    // 4\nconst int _5 = 53;                    // 5\nconst int _6 = 54;                    // 6\nconst int _7 = 55;                    // 7\nconst int _8 = 56;                    // 8\nconst int _9 = 57;                    // 9\nconst int _COLON = 58;                // :\nconst int _SEMICOLON = 59;            // ;\nconst int _LEFT_ANGLE = 60;           // <\nconst int _EQUALS = 61;               // =\nconst int _RIGHT_ANGLE = 62;          // >\nconst int _QUESTION = 63;             // ?\nconst int _AT = 64;                   // @\nconst int _A = 65;                    // A\nconst int _B = 66;                    // B\nconst int _C = 67;                    // C\nconst int _D = 68;                    // D\nconst int _E = 69;                    // E\nconst int _F = 70;                    // F\nconst int _G = 71;                    // G\nconst int _H = 72;                    // H\nconst int _I = 73;                    // I\nconst int _J = 74;                    // J\nconst int _K = 75;                    // K\nconst int _L = 76;                    // L\nconst int _M = 77;                    // M\nconst int _N = 78;                    // N\nconst int _O = 79;                    // O\nconst int _P = 80;                    // P\nconst int _Q = 81;                    // Q\nconst int _R = 82;                    // R\nconst int _S = 83;                    // S\nconst int _T = 84;                    // T\nconst int _U = 85;                    // U\nconst int _V = 86;                    // V\nconst int _W = 87;                    // W\nconst int _X = 88;                    // X\nconst int _Y = 89;                    // Y\nconst int _Z = 90;                    // Z\nconst int _LEFT_SQUARE_BRACKER = 91;  // [\nconst int _BACKWARD_SLASH = 92;       // \\\nconst int _RIGHT_SQUARE_BRACKET = 93; // ]\nconst int _CARET = 94;                // ^\nconst int _UNDERSCORE = 95;           // _\nconst int _BACKTICK = 96;             // `\nconst int _a = 97;                    // a\nconst int _b = 98;                    // b\nconst int _c = 99;                    // c\nconst int _d = 100;                   // d\nconst int _e = 101;                   // e\nconst int _f = 102;                   // f\nconst int _g = 103;                   // g\nconst int _h = 104;                   // h\nconst int _i = 105;                   // i\nconst int _j = 106;                   // j\nconst int _k = 107;                   // k\nconst int _l = 108;                   // l\nconst int _m = 109;                   // m\nconst int _n = 110;                   // n\nconst int _o = 111;                   // o\nconst int _p = 112;                   // p\nconst int _q = 113;                   // q\nconst int _r = 114;                   // r\nconst int _s = 115;                   // s\nconst int _t = 116;                   // t\nconst int _u = 117;                   // u\nconst int _v = 118;                   // v\nconst int _w = 119;                   // w\nconst int _x = 120;                   // x\nconst int _y = 121;                   // y\nconst int _z = 122;                   // z\nconst int _LEFT_BRACKET = 123;        // {\nconst int _PIPE = 124;                // |\nconst int _RIGHT_BRACKET = 125;       // }\nconst int _TILDE = 126;               // ~\n// Needs extending to the rest of the extended ascii list\n\n// UI\n\n/** Area: Defines the position and size of a view element\n  * \n  * position - The top-left position of the area in pixels\n  * size - The width and height of the area in pixels\n  */\nstruct PickerArea {\n    vec2 position;\n    vec2 size;\n};\n\n/** Result: The result of a picker\n  * \n  * isInside - Whether the current pixel is part of an input or not. If it is, the current pixel should halt\n  * result - A generic result vector. Refer to the functions to know how to read it\n  */\nstruct PickerResult {\n    bool isInside;\n    vec4 result;\n};\n\n/** Helper function to draw a rectangle in the specified area\n  * \n  * fragCoord - The coordinates of the current pixel\n  * bufferSampler - The sampler for the buffer the slider is on\n  * backgroundColor - The color of the rectangle\n  * color - If the position is inside the rectangle, it will set color to the background color\n  * \n  * Returned vec4 is unused\n  */\nPickerResult pickerCheckRectangle(PickerArea area, vec2 fragCoord, vec3 backgroundColor, inout vec3 color) {\n    PickerResult result;\n    if (fragCoord.x >= area.position.x && fragCoord.y >= area.position.y && \n        fragCoord.x < area.position.x + area.size.x && fragCoord.y < area.position.y + area.size.y) {\n        result.isInside = true;\n        color = backgroundColor;\n    } else {\n        result.isInside = false;\n    }\n    return result;\n}\n\n// SLIDER\n\n/** Slider: Creates an input where the user can pick a value between a minimum and maximum range at the specified\n  *         step size (resolution = (max - min) / step)\n  *\n  * area - The space the slider will occupy\n  * min - The minimum value of the slider\n  * max - The maximum value of the slider\n  * step - The distance between two values on the scale\n  *\n  * Optimal height for the slider is 10 pixels\n  */\nstruct PickerSlider {\n    PickerArea area;\n    float min;\n    float max;\n    float step;\n    float defaultValue;\n};\n\n/** Queries the value for the specified slider\n  * \n  * slider - The parameters of the slider\n  * fragCoord - The coordinates of the pixel\n  * mouse - The value of iMouse\n  * frame - The value of iFrame\n  * color - If the position is part of the slider, color will be set to the color of it at the current pixel\n  *\n  * Returned vec4 contains the value of the slider in all 4 components\n  */\nPickerResult pickerCheckSlider(PickerSlider slider, sampler2D bufferSampler, vec2 fragCoord, vec4 mouse, int frame, inout vec3 color) {\n    vec2 relativePosition = fragCoord - slider.area.position;\n    vec3 valueRaw = texelFetch(bufferSampler, ivec2(slider.area.position), 0).rgb * 255.0;\n    float value = valueRaw.r * 256.0 * 256.0 + valueRaw.g * 256.0 + valueRaw.b + slider.min;\n    \n    \n    if (frame == 0) {\n        value = slider.defaultValue;\n        valueRaw = store24F(value);\n    }\n    \n    if (mouse.z > 0.5 && mouse.x >= slider.area.position.x && mouse.y >= slider.area.position.y &&\n            mouse.x < slider.area.position.x + slider.area.size.x && mouse.y < slider.area.position.y + slider.area.size.y) {\n        float diffX = (mouse.x - slider.area.position.x) / slider.area.size.x;\n        value = round(diffX * (slider.max - slider.min) / slider.step) * slider.step + slider.min;\n        valueRaw = store24F(value);\n    }\n    \n    if (floor(relativePosition.x) == 0.0 && floor(relativePosition.y) == 0.0) {\n        color = valueRaw / 255.0;\n        return PickerResult(true, vec4(value));\n    }\n    \n    // Parts\n    PickerArea leftSideArea = PickerArea(vec2(0, 0), vec2(3, slider.area.size.y));\n    PickerArea rightSideArea = PickerArea(vec2(slider.area.size.x - 3.0, 0), vec2(3, slider.area.size.y));\n    PickerArea railArea = PickerArea(vec2(0, slider.area.size.y / 2.0 - 1.0), vec2(slider.area.size.x, 2.0));\n    float knobPercentage = (value - slider.min) / (slider.max - slider.min);\n    PickerArea knobArea = PickerArea(vec2(knobPercentage * (slider.area.size.x - 4.0), 0), vec2(4, slider.area.size.y));\n    \n    PickerResult leftSide = pickerCheckRectangle(leftSideArea, relativePosition, vec3(0.4), color);\n    PickerResult rightSide = pickerCheckRectangle(rightSideArea, relativePosition, vec3(0.4), color);\n    PickerResult rail = pickerCheckRectangle(railArea, relativePosition, vec3(0.4), color);\n    PickerResult knob = pickerCheckRectangle(knobArea, relativePosition, vec3(0.7), color);\n    bool isInside = leftSide.isInside || rightSide.isInside || rail.isInside || knob.isInside;\n    return PickerResult(isInside, vec4(value));\n}\n\n// HSV\n\n/** HSV: Creates an input element where the user can pick a color using an HSV color wheel \n  * \n  * area - The space the color picker will occupy\n  *\n  * Optimal size for the color picker is (height + 20, height), where height is the height you want it to occupy\n  */\nstruct PickerHSV {\n    PickerArea area;\n    vec3 defaultValue;\n};\n\n/** Queries the value for the specified hsv color picker\n  * \n  * hsv - The parameters of the color wheel\n  * bufferSampler - The sampler for the buffer the color wheel is on\n  * fragCoord - The coordinates of the pixel\n  * mouse - The value of iMouse\n  * frame - The value of iFrame\n  * color - If the position is part of the color wheel, color will be set to the color of it at the current pixel\n  *\n  * Returned vec4 contains the selected color in RGB in the r, g and b components, a/w is unused\n  */\nPickerResult pickerCheckHSV(PickerHSV hsv, sampler2D bufferSampler, vec2 fragCoord, vec4 mouse, int frame, inout vec3 color) {\n    vec2 relativePosition = fragCoord - hsv.area.position;\n    vec3 valueRaw = texelFetch(bufferSampler, ivec2(hsv.area.position + hsv.area.size.y / 2.0), 0).rgb;\n    vec3 value = rgb2hsv(valueRaw);\n    \n    if (frame == 0) {\n        valueRaw = hsv.defaultValue;\n        value = rgb2hsv(valueRaw);\n    }\n    \n    vec3 rgbMaxValue = hsv2rgb(vec3(value.xy, 1.0));\n    float size = hsv.area.size.y;\n\n    vec2 mouseRelative = mouse.xy - hsv.area.position;\n    float mouseR = length(mouseRelative - size / 2.0) / size * 2.0;\n    if (mouse.z > 0.5 && mouse.x >= hsv.area.position.x && mouse.y >= hsv.area.position.y &&\n            mouse.x < hsv.area.position.x + hsv.area.size.x && mouse.y < hsv.area.position.y + hsv.area.size.y) {\n        if (mouseR < 1.0) {\n            float angle = atan(mouseRelative.y - size / 2.0, mouseRelative.x - size / 2.0) / 2.0 / PI;\n            value = vec3(angle, max((mouseR - 0.2) / 0.8, 0.0), value.z);\n            valueRaw = hsv2rgb(value);\n        } else if (mouse.x > size + 15.0) {\n            value = vec3(value.xy, (mouse.y - hsv.area.position.y) / size);\n            valueRaw = hsv2rgb(value);\n        }\n    }\n\n    bool isInside = false;\n    \n    if (relativePosition.y < 0.0 || relativePosition.y >= size) {\n        return PickerResult(false, vec4(valueRaw, 0));\n    }\n    \n    float r = length(relativePosition - size / 2.0) / size * 2.0;\n    if (relativePosition.x >= size + 5.0 && relativePosition.x < size + 20.0) {\n        float diffY = relativePosition.y / hsv.area.size.y;\n        float distY = abs(diffY - value.z) * hsv.area.size.y; \n        if (distY < 2.0) {\n            color = vec3(1.0 - step(1.0, distY));\n            return PickerResult(true, vec4(valueRaw, 0));\n        }\n        \n        color = hsv2rgb(vec3(value.xy, diffY));\n        isInside = true;\n    } else if (r < 0.2) {\n        color = valueRaw;\n        isInside = true;\n    } else if (r < 1.0) {\n        vec2 currValuePosition = vec2(\n            cos(value.r * 2.0 * PI),\n            sin(value.r * 2.0 * PI)\n        ) * (value.y * 0.8 + 0.2) * size / 2.0 + size / 2.0;\n        float distToKnob = distance(currValuePosition, relativePosition);\n        if (distToKnob < 4.0) {\n            color = vec3(1.0 - step(2.6, distToKnob));\n            return PickerResult(true, vec4(valueRaw, 0));\n        }\n        \n        r = (r - 0.2) / 0.8;\n        float angle = atan(relativePosition.y - size / 2.0, relativePosition.x - size / 2.0) / 2.0 / PI;\n        color = hsv2rgb(vec3(angle, r, value.z));\n        isInside = true;\n    } else {\n    }\n\n    return PickerResult(isInside, vec4(valueRaw, 0));\n}\n\n// BUTTON\n\n/** Button: Creates a button at the specified location\n  * \n  * area - The space the button will occupy\n  *\n  * The usable space inside the button will have a 4 pixel margin in all directions\n  */\nstruct PickerButton {\n    PickerArea area;\n};\n\n/** Queries the state of the specified button\n  * \n  * button - The parameters of the button\n  * fragCoord - The coordinates of the pixel\n  * mouse - The value of iMouse\n  * color - If the position is part of the button, color will be set to the color of it at the current pixel\n  *\n  * The z and w components are the same as iMouse\n  */\nPickerResult pickerCheckButton(PickerButton button, vec2 fragCoord, vec4 mouse, inout vec3 color) {\n    vec2 pressed = vec2(0);\n    if (mouse.x >= button.area.position.x && mouse.y >= button.area.position.y &&\n            mouse.x < button.area.position.x + button.area.size.x && mouse.y < button.area.position.y + button.area.size.y) {\n        pressed = mouse.zw;\n    }\n    \n    vec2 relativePosition = fragCoord - button.area.position;\n    if (relativePosition.x > 0.0 && relativePosition.y > 0.0 &&\n            relativePosition.x < button.area.size.x && relativePosition.y < button.area.size.y) {\n        vec2 size = button.area.size;\n        vec2 centralPos = abs(relativePosition - size / 2.0);\n        vec2 factors = step(size / 2.0 - 2.0, centralPos);\n        vec3 backgroundColor = mix(vec3(0.4), vec3(0.3), step(0.5, max(pressed.x, pressed.y)));\n        color = mix(backgroundColor, vec3(0.2), max(factors.x, factors.y));\n    } else {\n        return PickerResult(false, vec4(0, 0, pressed));\n    }\n    return PickerResult(true, vec4(0, 0, pressed));\n}\n\n// TEXT\n\n/** Text10: Creates a piece of text with the length of at most 10. If you need text shorter, fill the remaining chars with \"__\"-s\n  * \n  * startPos - The position the text starts at\n  * height - The height of the text in pixels\n  * charWidth - The width of a character (for spacing purposes, they won't be squished)\n  * color - The color of the text\n  * text - The text represented using an array of ASCII codes. Use the underscored helper constants\n  */\nstruct PickerText10 {\n    vec2 startPos;\n    float height;\n    float charWidth;\n    vec3 color;\n    int[10] text;\n};\n\n/** Text20: Creates a piece of text with the length of at most 20. If you need text shorter, fill the remaining chars with \"__\"-s\n  * \n  * startPos - The position the text starts at\n  * height - The height of the text in pixels\n  * charWidth - The width of a character (for spacing purposes, they won't be squished)\n  * color - The color of the text\n  * text - The text represented using an array of ASCII codes. Use the underscored helper constants\n  */\nstruct PickerText20 {\n    vec2 startPos;\n    float height;\n    float charWidth;\n    vec3 color;\n    int[20] text;\n};\n\n/** Text40: Creates a piece of text with the length of at most 40. If you need text shorter, fill the remaining chars with \"__\"-s\n  * \n  * startPos - The position the text starts at\n  * height - The height of the text in pixels\n  * charWidth - The width of a character (for spacing purposes, they won't be squished)\n  * color - The color of the text\n  * text - The text represented using an array of ASCII codes. Use the underscored helper constants\n  */\nstruct PickerText40 {\n    vec2 startPos;\n    float height;\n    float charWidth;\n    vec3 color;\n    int[40] text;\n};\n\n/** Text80: Creates a piece of text with the length of at most 80. If you need text shorter, fill the remaining chars with \"_NULL\"-s\n  * \n  * startPos - The position the text starts at\n  * height - The height of the text in pixels\n  * charWidth - The width of a character (for spacing purposes, they won't be squished)\n  * color - The color of the text\n  * text - The text represented using an array of ASCII codes. Use the underscored helper constants\n  */\nstruct PickerText80 {\n    vec2 startPos;\n    float height;\n    float charWidth;\n    vec3 color;\n    int[80] text;\n};\n\nPickerResult pickerCheckText(PickerText10 text, sampler2D fontSampler, vec2 fragCoord, inout vec3 color) {\n    vec2 relativePosition = fragCoord - text.startPos;\n    if (relativePosition.x < 0.0 || relativePosition.y < 0.0 ||\n            relativePosition.x > 10.0 * text.charWidth || relativePosition.y > text.height)\n        return PickerResult(false, vec4(0));\n        \n    int currentChar = int(relativePosition.x / text.charWidth);\n    int charCode = text.text[currentChar];\n    if (charCode == _NULL)\n        return PickerResult(false, vec4(0));\n        \n    vec2 charStartUV = vec2(\n        charCode % 16,\n        15 - charCode / 16\n    ) / 16.0;\n    vec2 charUV = fract(relativePosition / vec2(text.charWidth, text.height));\n    charUV.x = (charUV.x - 0.5) * text.charWidth / text.height + 0.5;\n    color = mix(color, text.color, texture(fontSampler, charStartUV + charUV / 16.0).r);\n    return PickerResult(true, vec4(0));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"PickerSlider slider = PickerSlider(PickerArea(vec2(10.0, 10.0), vec2(170.0, 20.0)), 1.0, 300.0, 1.0, 50.0);\nPickerHSV hsv = PickerHSV(PickerArea(vec2(10, 40), vec2(170, 150)), vec3(1, 0, 0));\nPickerButton button = PickerButton(PickerArea(vec2(10, 200), vec2(152, 40)));\nPickerText10 text = PickerText10(vec2(14, 204), 32.0, 16.0, vec3(1), int[](_C, _l, _i, _c, _k, _SPACE, _M, _e, _EXCLAMATION, _NULL));\n\n// TESTING STUFF\nfloat intersectSphere(vec3 ro, vec3 rd, vec3 ce, float r, out vec3 normal) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r * r;\n    float disc = b * b - c;\n    if (disc < 0.0)\n        return -1.0;\n    \n    float t = -b - sqrt(disc);\n    normal = (ro + rd * t - ce) / r;\n    return t;\n}\n\nfloat schlickFresnel(float F0, float cosTheta) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {  \n    PickerResult sliderRes = pickerCheckSlider(slider, iChannel0, fragCoord, iMouse, iFrame, fragColor.rgb);\n    PickerResult hsvRes = pickerCheckHSV(hsv, iChannel0, fragCoord, iMouse, iFrame, fragColor.rgb);\n    PickerResult buttonRes = pickerCheckButton(button, fragCoord, iMouse, fragColor.rgb);\n    PickerResult textRes = pickerCheckText(text, iChannel1, fragCoord, fragColor.rgb);\n    if (sliderRes.isInside || hsvRes.isInside || buttonRes.isInside)\n        return;\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 ro = vec3(0, 0, 5);\n    vec3 rd = normalize(vec3((fragCoord - iResolution.xy / 2.0) / iResolution.yy, -1));\n    vec3 ce = vec3(0, buttonRes.result.z > 0.0 ? 1.0 : 0.0, 0);\n    float r = 1.0;\n    \n    vec3 normal;\n    float t = intersectSphere(ro, rd, ce, r, normal);\n    \n    if (t < 0.0) {\n        fragColor.rgb = (1.4 + rd.z) * vec3(0.1, 0.2, 0.4);\n    } else {\n        vec3 light = normalize(vec3(1, 3, 2));\n        float cosTheta = max(dot(normal, light), 0.0);\n        vec3 diffuse = hsvRes.result.rgb / PI;\n        vec3 ambient = vec3(0.1, 0.2, 0.2) * hsvRes.result.rgb;\n        vec3 view = -rd;\n        vec3 halfway = normalize(light + view);\n        float shininess = sliderRes.result.r;\n        float blinnPhong = pow(max(dot(halfway, normal), 0.0), shininess) * (8.0 + shininess) / (8.0 * PI);\n        vec3 specular = blinnPhong * vec3(1);\n        float ks = 0.1;//schlickFresnel(0.04, max(dot(view, normal), 0.0));\n        fragColor.rgb = (diffuse * (1.0 - ks) + specular * ks) * cosTheta * vec3(3) + ambient;\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}