{"ver":"0.1","info":{"id":"lfsfzN","date":"1723482750","viewed":20,"name":"Chladni Patterns","username":"Plip","description":"Chladni Figures in ShaderToy, done as a project for the MIT SGI Program (2024).\n\nLook up instructions here: https://github.com/CDInstitute/3DChladni\n\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["voxel","chladni","marchingcubes"],"hasliked":0,"parentid":"ftXGDj","parentname":"Marching Cubes II"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Marching Cubes II by Kastorp\n//----------------------------------------------------------------\n// \n// with CACHE undefined: caching only surface intersection; only 1 bit needed per cube\n// with CACHE defined: caching all data in one pixel, with quantized weights; better performance, less accuracy\n//\n// update:  after some optimizations on tritable lookup, also uncached version if fast and usable in realtime\n//----------------------------------------------------------------\n\n#define CACHE\n\nvec3    g_n;\nvec2    g_uv;\n\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5*csz - csz*0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\nvec3 rayDirection(vec3 cameraDir, vec2 uv){\n    \n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\n\nvec4 trace(vec3 ro,vec3 rd)\n{\n    //RAYTRACING BOUNDING BOX\n    vec2 tb= boxIntersection(  ro,  rd, vec3(csz*N*.50+.00001) ) ;\n    if(tb.y<0.) return vec4(0.);\n    \n    \n    //VOXEL TRAVERSAL\n    vec3 rs= sign(rd);\n    vec3 ri = 1./rd;\n\tvec3 rp=ro +  max(tb.x,0.)*rd;  \n    vec3 mp=floor(rp/csz)*csz;\n    vec3 sd = (mp-rp + 0.5*csz + sign(rd)*0.5*csz) *ri;\n    vec3 mask=vec3(0.);     \n    for (int i = 0; i < 200; i++) {\n         \n        mask = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n\t\tsd += mask *  rs *ri*csz;\n        mp += mask *  rs*csz;\n        \n        rp = VoxelHitPos(mp,rp,rd).xyz+rd*.0001; \n        if(length(rp-ro)>tb.y) break; //outside bounding box\n        \n\n       uvec4 tridata = floatBitsToUint(getVoxel( mp/csz,iChannel2,iChannelResolution[2])); \n    \n       int ntriangles=int(tridata.x);\n        if(ntriangles>0 ){\n                     \n            TRIANGLE[5] triangles;\n            \n#ifndef CACHE\n                //calculate vertexes & triangles (requires buffer A and B)\n                GRIDCELL g;\n                for(int id=0;id<8;id++)\n                {\n                    g.p[id]=mp+  VertexOffset[id]*csz;\n                    g.val[id]=getVoxel(g.p[id]/csz,iChannel1,iChannelResolution[1]).x;                \n                }\n\n                Polygonise(g,0.,triangles,iChannel0);\n#else\n                //rebuild from cache (requires only buffer C)\n                Polygonise(tridata,triangles,mp);\n#endif\n                      \n            float t = 1000.0; \n            for(int i=0;i<ntriangles;i++) {\n                vec3 tri =triIntersect( ro,rd,triangles[i].p[0],triangles[i].p[1],triangles[i].p[2]);\n                if(tri.x>0.  && tri.x <t) {\n                    t=tri.x;\n                     g_n=-normalize(cross(triangles[i].p[1]-triangles[i].p[0],triangles[i].p[2]-triangles[i].p[0]));\n                     g_uv= tri.yz;\n                 }\n            }\n            if(t< 1000.) return  vec4(ro+rd*t,t);\n        }\n\t} \n    return vec4(tb.x,tb.y,0.,0.);\n}\n\n//--------------------SHANE---------------------\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n//--------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    gFrame = min(iFrame, 0);\n\n    // Mouse or other input control for camera movement\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.x <= 0. ? vec2(-0.3) : (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 3.14;\n\n    // Control camera distance\n    \n    float startingDistance = 200.0;\n    float cameraDistance = startingDistance + (iMouse.y / iResolution.y - 0.5) * 25.0; // Adjust this line as needed\n    \n       \n    \n    //COLORING\n    vec3 insideColor=vec3(1.0,1.0,0.0);\n    vec3 outsideColor=vec3(0.0,0.0,1.0);\n    \n    vec3 insideChecker=vec3(0.0,0.0,0.0);\n    vec3 outsideChecker=vec3(1.0,1.0,1.0);\n    \n    vec3 backgroundColor=vec3(0.0,0.0,0.0);\n    // Compute the camera position based on the distance\n    vec3 ro = vec3(\n        sin(m.y + .76) * cos(-m.x), \n        sin(m.y + .76) * sin(-m.x), \n        cos(m.y + .76)\n    ) * cameraDistance;\n    vec3 cd = -normalize(ro);\n    \n    vec3 offset = vec3(0.,0.,0.);\n    ro += offset;\n    vec3 rd = rayDirection(cd, uv) + offset;\n    \n    vec4 r = trace(ro, rd);\n\n    if (r.a > 0.0) {\n        vec3 p = r.xyz;\n        vec3 n = g_n;\n        vec3 l = normalize(vec3(.6, -.4, 1.0));  // Light\n\n\n\n        // Compute if we are inside or outside\n        float insideFactor = dot(n, rd) > 0.0 ? 1.0 : 0.0; // 1.0 if inside, 0.0 if outside\n\n        // Define checkerboard parameters\n        float checkerSize = 7.8; // Size of the checkerboard squares\n        vec2 checkerUV = mod(p.xy / checkerSize, 2.0); // Compute checkerboard pattern\n\n        // Compute checkerboard color based on UV\n        float checkerboard = step(0.5, mod(floor(checkerUV.x) + floor(checkerUV.y), 2.0));\n\n\n\n        fragColor.rgb = mix(outsideColor, outsideChecker, checkerboard);// * (1.0 - insideFactor); // Base color for outside\n        //fragColor.rgb += mix(insideColor, insideChecker, checkerboard) * insideFactor; // Inside color\n        \n        fragColor.rgb +=vec3(0.7,0.7,0.7)*(1.0-insideFactor);\n        \n        // Compute color and shading\n        //fragColor.rgb = insideColor * (1.0 - insideFactor);  // Base color for outside\n        //fragColor.rgb +=outsideColor*(insideFactor);\n        //fragColor.rgb = mix(fragColor.rgb, vec3(0.5, 0.75, 1.0) * insideFactor, smoothstep(.7, .5, dot(n, normalize(p))));  // Inside color\n\n        //fragColor*=vec4(checkerboard*outsideChecker,1.0);\n\n\n        // Adjust based on edges\n        fragColor.rgb *= .9 + .1 * smoothstep(0.01, .15, min(min(g_uv.x, g_uv.y), 1.0 - g_uv.x - g_uv.y)); // Edges\n\n        // Shading\n        float ambience = 0.5;\n        float diff = max(dot(n, l), 0.0);\n        float spec = 0.0; // Specular lighting (can be adjusted or added)\n        vec4 s = trace(p + n * .005 * csz, l);\n        float shading = step(0.0, -s.a) * 1.0 + .2;\n\n        fragColor.rgb = fragColor.rgb * (diff + ambience) + vec3(.7, .9, 1.0) * spec;\n        //fragColor.rgb *= shading;\n\n        fragColor = vec4(sqrt(clamp(fragColor.rgb, 0.0, 1.0)), 1.0);\n    } else {\n        fragColor = vec4(backgroundColor,1);//mix(vec4(0.4, 0.4, 0.7, 1.0), vec4(0.2), (r.y - r.x) / L * 1.2); // Background\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// LOOKUP TABLES: 256x2 pixels required\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    if(iFrame>3) discard;\n    else if(U.y<1.&& U.x<256.)\n    {\n       int _edgeTable[256]= int[256](\n        -1   , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, \n        0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, \n        0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, \n        0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, \n        0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, \n        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, \n        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, \n        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, \n        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, \n        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, \n        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, \n        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460, \n        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0, \n        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230, \n        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190, \n        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0\n       );\n        Q=vec4(_edgeTable[int(U.x)]);\n   }\n   else if(U.y<2.&& U.x<128.){\n   \n    int  _triTableCompact1[512] = int[512](\n        65535,65535,65535,65535, 62336,65535,65535,65535, 63760,65535,65535,65535, 37761,65304,65535,65535, 64033,65535,65535,65535, \n        4992,65442,65535,65535, 2601,65426,65535,65535, 9090,39562,65528,65535, 62131,65535,65535,65535, 33456,65291,65535,65535, \n        8337,65459,65535,65535, 4785,35257,65531,65535, 45475,65338,65535,65535, 416 ,47272,65530,65535, 12435,43931,65529,65535, \n        43657,65464,65535,65535, 63604,65535,65535,65535, 28724,65347,65535,65535, 35088,65396,65535,65535, 18708,14103,65521,65535,\n        35361,65396,65535,65535, 14147,8512,65530,65535, 39465,18464,65527,65535, 10658,29305,18803,65535, 14152,65323,65535,65535,\n        46923,578 ,65524,65535, 33033,12916,65531,65535, 39796,47540,4754,65535, 12707,34731,65524,65535, 6833,436 ,19316,65535, 39028,\n        47536,12474,65535, 19316,47515,65530,65535, 62553,65535,65535,65535, 1113,65336,65535,65535, 5200,65285,65535,65535, 33880,4947,\n        65525,65535, 39457,65349,65535,65535, 6147,38050,65525,65535, 23077,1060,65522,65535, 13730,21330,33844,65535, 9305,65459,65535,\n        65535, 688 ,38072,65525,65535, 1104,12881,65531,65535, 9490,33413,22603,65535, 43834,22833,65524,65535, 1428,43032,43905,65535,\n        20549,46512,12474,65535, 22597,35496,65531,65535, 22649,65431,65535,65535, 36921,30005,65523,65535, 2160,20849,65527,65535, 13137,\n        65397,65535,65535, 39033,6773,65522,65535, 37402,13573,14160,65535, 33288,22610,9639,65535, 9634,21301,65527,65535, 30103,45976,\n        65522,65535, 38745,10535,46880,65535, 2866,29057,29976,65535, 45355,6001,65525,65535, 34905,6773,45987,65535, 20597,46992,40976,\n        61611, 45227,23088,28800,61557, 30123,65371,65535,65535, 62826,65535,65535,65535, 21376,65386,65535,65535, 20745,65386,65535,65535,\n        4993,42377,65526,65535, 9569,65302,65535,65535, 5473,866  ,65528,65535, 38249,8288,65526,65535, 22677,9512,33334,65535, 43826,65366,\n        65535,65535, 47115,27138,65525,65535, 10512,42419,65526,65535, 5797,47401,47250,65535, 27446,5429,65523,65535, 2944,20571,27473,65535,\n        1715,24675,38149,65535, 26966,39865,65528,65535, 18085,65415,65535,65535, 16436,22071,65530,65535, 20625,18538,65527,65535, 5482,\n        29049,18803,65535, 25110,29717,65528,65535, 21793,866 ,29748,65535, 38728,24656,25093,65535, 31031,9033,26969,63842, 29363,27208,\n        65525,65535, 18085,9255,46880,65535, 18704,12935,27227,65535, 37161,18731,19323,63141, 14152,21339,27473,65535, 23317,363 ,19323,\n        64320, 2384,12374,14006,63304, 26966,29881,39801,65535, 26954,65444,65535,65535, 18084,32937,65523,65535, 41226,17926,65520,65535,\n        33080,26721,41316,65535, 6465,25154,65524,65535, 6147,17042,17961,65535, 17440,65378,65535,65535, 33336,9282,65526,65535, 43338,\n        11078,65523,65535, 8832,38072,27210,65535, 691 ,24673,41316,65535, 24902,33953,45345,61880, 37993,6499,14003,65535, 33208,27393,\n        16785,61766, 14003,24582,65524,65535, 47174,65414,65535,65535, 30375,39080,65530,65535, 880,36986,42858,65535, 5994,29050,2072,\n        65535, 42858,28951,65523,65535, 5665,33158,30345,65535, 10594,30233,14601,63799, 28807,1632,65522,65535, 25143,65319,65535,65535,\n        43826,35462,30345,65535, 9986,37047,42855,63401, 4225,41351,42855,64306, 45355,27249,5985,65535, 34456,6518,14006,63025, 45456,\n        65398,65535,65535, 28807,45920,1712,65535,63159,65535,65535,65535); \n            int id= int(U.x)*4;\n     Q= vec4(_triTableCompact1[id],_triTableCompact1[id+1],_triTableCompact1[id+2],_triTableCompact1[id+3] );\n\n    }\n  else  if(U.y<2.&& U.x<256.){\n  int  _triTableCompact2[512] = int[512](       \n       64359,65535, 65535,65535, 47107,65383,65535,65535, 47376,65383,\n        65535,65535, 35096,31507,65526,65535, 25114,65403,65535,65535, 14881,46720,65527,65535, 8338,46746,65527,65535, 10166,35386,35235,\n        65535, 25383,65394,65535,65535, 30727,9734,65520,65535, 9842,4211,65529,65535, 4705,37224,26504,65535, 42618,12657,65527,65535, \n        5754,33191,32791,65535, 1840,41127,31337,65535, 31335,43146,65529,65535, 46214,65384,65535,65535, 15203,16480,65526,65535, 35688,\n        2404,65521,65535, 38473,14646,25521,65535, 25734,41611,65521,65535, 14881,24752,25611,65535, 18612,8374,39465,65535, 41882,18723,\n        25523,62308, 33576,25636,65522,65535, 16960,65318,65535,65535, 8337,16963,33606,65535, 5265,16932,65526,65535, 33560,18454,6758,\n        65535, 40986,1632,65524,65535, 17252,42627,37635,62362, 25754,65354,65535,65535, 30100,65462,65535,65535, 17280,31577,65526,65535,\n        20741,26372,65531,65535, 34427,21315,20788,65535, 42073,26401,65531,65535, 6070,32930,22851,65535, 23399,9380,8266,65535, 14403,\n        9029,9637,63099, 29479,17702,65529,65535, 1113,24680,30818,65535, 12899,20839,1104,65535, 26662,4728,22600,63569, 42073,29025,29462,\n        65535, 6753,359 ,1927,62553, 18948,12378,31338,64115, 31335,17802,43082,65535, 26006,35739,65529,65535, 2915,20534,22790,65535, \n        2224,4277,46677,65535, 25526,13651,65521,65535, 39457,47541,26040,65535, 944 ,37046,38486,64033, 46475,2149,9637,62752, 25526,\n        41555,13731,65535, 22917,25986,10290,65535, 38489,24582,65522,65535, 6225,25864,10296,63526, 9809,65377,65535,65535, 5681,33702,\n        38486,63128, 40986,22880,1616,65535, 22576,65446,65535,65535, 63066,65535,65535,65535, 31323,65461,65535,65535, 47707,14423,65520,\n        65535, 22453,37306,65520,65535, 42362,35195,4993,65535, 45595,22295,65521,65535, 4992,29042,45685,65535, 38265,2418,31522,65535, \n        29271,38322,33330,62089, 10834,29523,65525,65535, 32808,30757,21157,65535, 20745,13626,10807,65535, 37513,30738,21154,62039,\n        13617,65367,65535,65535, 1920,28951,65525,65535, 37641,13651,65527,65535, 22409,65401,65535,65535, 21637,47754,65528,65535, 21509,\n        42251,955 ,65535, 35088,43172,21675,65535, 42170,15188,5268,62483, 8530,45656,34120,65535, 2880,21563,6955,64277, 1312,45717,34117,\n        62859, 9545,65339,65535,65535, 14930,17189,18485,65535, 21157,9282,65520,65535, 12963,33701,34117,63760, 21157,37186,9362,65535, \n        34120,21301,65521,65535, 5440,65360,65535,65535, 34120,2357,21253,65535, 62793,65535,65535,65535, 18356,43449,65531,65535, 17280,\n        47481,47767,65535, 7073,16715,46192,65535, 13331,41348,46196,62650, 38836,10571,8603,65535, 38009,6523,6955,62336, 46203,16932,\n        65520,65535, 46203,14372,16948,65535, 10898,12951,38007,65535, 38825,10823,1927,63234, 14963,18218,2586,64004, 33441,65351,65535,\n        65535, 16788,6001,65523,65535, 16788,32881,6017,65535, 29444,65332,65535,65535, 63364,65535,65535,65535, 43177,65419,65535,65535,\n        14595,39865,65530,65535, 2576,43146,65531,65535, 47635,65443,65535,65535, 6945,47515,65528,65535, 14595,8633,39721,65535, 35616,\n        65456,65535,65535, 64291,65535,65535,65535, 10290,35496,65529,65535, 681 ,65321,65535,65535, 10290,4264,35352,65535, 62113,65535,\n        65535,65535, 38961,65409,65535,65535, 61840,65535,65535,65535, 63536,65535,65535,65535, 65535,65535,65535,65535\n    );\n       \n     int id= int(U.x)*4;\n     Q= vec4(_triTableCompact2[id-512],_triTableCompact2[id-511],_triTableCompact2[id-510],_triTableCompact2[id-509] );\n\n }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*const float L = 200.0; // Size of the cube\nconst float N = 100.0; // Number of voxels per side\nconst float csz = .5*L / N; // Voxel size\n\nvec3 offset = floor(vec3(-1.,-1.,-1.));\n//vec3 offset = vec3(0.0); // Centered at origin\nconst vec2 packedChunkSize= ceil(sqrt(N) * vec2(1.25 ,0.8)); // iResolution.xy/iResolution.yx \nconst float heightLimit =  packedChunkSize.x * packedChunkSize.y; //must be > N*/\n\nconst float L = 100.0; // Size of the cube\nconst float N = 100.0; // Number of voxels per side\nconst float csz = L / N; // Voxel size\n\nvec3 offset = floor(vec3(0.,0.,0.));\n//vec3 offset = vec3(0.0); // Centered at origin\n\n//PUT YOUR SCREEN RESOLUTION HERE\n//PUT EITHER VIEWER(ON THE LEFT) OR FULLSCREEN RESOLUTION\nconst float xRes=768.0;\nconst float yRes=432.0;\n\nconst vec2 packedChunkSize= ceil(sqrt(N) * vec2(2.0*xRes/1000.0 , 2.0*yRes/1000.0)); // iResolution.xy/iResolution.yx \nconst float heightLimit = packedChunkSize.x * packedChunkSize.y; //must be > N\n\n\n\n\n//-----------------------------------------\n// VOXEL CACHE FUNCTIONS from fb39ca4\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float o = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - o);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float o = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + o;\n}\n\nfloat calcLoadDist(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset) {\n\n    vec2 packedChunkSize= packedChunkSize;\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec2 packedChunkSize= packedChunkSize;\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nvec4  getVoxel(vec3 p,sampler2D iChannel,vec3 resolution) {\n\n\n    p.z-= offset.z;\n    if(p.z>heightLimit || p.z<0.){return vec4(0.);}  \n    return texelFetch(iChannel, ivec2(voxToTexCoord(p))  , 0);\n    \n    \n    //return texture(iChannel, (floor(voxToTexCoord(p)) + 0.5) /  (floor (resolution.xy)), 0.0);\n}\n\n\n\n//--------------------\n\n//porting of \"Marching Cubes\" algorithm by Paul Bourke (1994)\n//http://paulbourke.net/geometry/polygonise/\n \n//Note on porting: I made code more compact. Also used the usual trick to prevent unrolling in Angle\nint gFrame=0; \n \n struct TRIANGLE {\n   vec3 p[3];\n} ;\n\n\n struct GRIDCELL{\n   vec3 p[8];\n   float val[8];\n} ;\n\n\n//   4-------5\n//  /|      /|\n// 7-------6 |\n// | |     | |\n// | 0-----|-1\n// |/      |/\n// 3-------2\n//\n const vec3 VertexOffset[8] =vec3[8]\n(\n        vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n        vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\n\n//lookup tables retrieved from BufferA\n#define edgeTable(i) int(texelFetch(confChannel, ivec2(i,0),0).x)\n#define triTableRow(i) ivec4(texelFetch(confChannel, ivec2(i,1),0))\n#define triTableVal(tt,j) int((tt[j>>2]&(15*(1<<((j&3)*4))))>>((j&3)*4))\n\nconst int  vertexTable[24] =int[24](\n   0,1,   1,2,  2,3,   3,0, \n   4,5,   5,6,  6,7,   7,4,   \n   0,4,   1,5,  2,6,   3,7);\n   \n/*\n   Linearly interpolate the position where an isosurface cuts\n   an edge between two vertices, each with their own scalar value\n*/\n#define SNAP .0\nfloat  VertexWeight(float isolevel,float valp1, float valp2)\n{\n   \n   float mu = (isolevel - valp1) / (valp2 - valp1);\n   if(mu<SNAP) mu=0.;\n   if(mu>1.-SNAP) mu=1.;\n\n   return mu;\n\n}\n\n//input: isolevel value at 8 cube vertexs and isolevel threshold\n//output: number of triangles (-1= outside) and list of triangles (up to 5 in worst case)\nuvec4  Polygonise(inout GRIDCELL grid,float isolevel,inout TRIANGLE[5] triangles,sampler2D confChannel)\n{\n \n   /*\n      Determine the index into the edge table which\n      tells us which vertices are inside of the surface\n   */\n   int cubeindex = 0;\n   for(int i=gFrame;i<8;i++) if (grid.val[i] < isolevel) cubeindex |= 1<<i;\n\n   /* Cube is entirely in/out of the surface -1=IN, 0=OUT */\n   int e=edgeTable(cubeindex);\n   if ( e<= 0) return uvec4(e);\n\n   /* Find the vertices where the surface intersects the cube */\n   vec3 vertlist[12];\n   float vertW[12];\n\n\n   for(int i=0;i<12;i++)\n   if ((e & (1<<i))>0)  {\n       vertW[i]= VertexWeight(isolevel,grid.val[vertexTable[i*2]], grid.val[vertexTable[i*2+1]]);\n          \n       vertlist[i]= mix( grid.p[vertexTable[i*2]], grid.p[vertexTable[i*2+1]],vertW[i]);\n   }\n   /* Create the triangle */\n   uvec4 tridata=uvec4(0u); //x=number of triangles, yzw= tritable\n   \n   ivec4 ttr=triTableRow(cubeindex); \n   for (int i=gFrame;triTableVal(ttr,i)!=15 && i<15;i+=3) {\n       \n       for(int j=gFrame;j<3;j++)   {\n           uint k =uint(triTableVal(ttr,(i+j)));\n           int idx =(i+j);\n           if(idx<8) tridata.y +=  k*( 1u<<(idx*4));\n           else tridata.z += k*( 1u<<(idx*4-32));\n        \n           tridata.w+=  uint( floor(vertW[k]*4. )  ) \n                        *( 1u<<(idx*2));\n           triangles[tridata.x].p[j] = vertlist[k];\n       }\n      \n      tridata.x++;\n   }\n\n   return uvec4(tridata);\n}\n\n// the following functions are used if CACHE is defined\nuint getTri(uvec4 tridata,int n){\n\n        if(n<8) return (tridata.y & (15u * (1u<<(4*n))))  >>(4*n);\n        else return  ( tridata.z & (15u* (1u<<(4*n-32)))) >>(4*n-32);\n}\n\n// 3 quantized values: .25, .5, .75, \nfloat getMu(uvec4 tridata,int n){\n       uint m= (tridata.w & (3u * (1u<<(2*n))))  >>(2*n);\n       return  float(m)*.25+.125;\n}\n\nvoid  Polygonise(uvec4 tridata,inout TRIANGLE[5] triangles, vec3 mp)\n{\n     for (int i=0;i<5;i++)     {\n         if(getTri(tridata,i*3) ==15u) break;\n         for(int j=0;j<3;j++)   {\n           int idx=i*3+j;\n           uint k =  getTri(tridata,idx) ;\n           vec3 v1= mp+  VertexOffset[vertexTable[k*2u]]*csz;\n           vec3 v2= mp+  VertexOffset[vertexTable[k*2u+1u]]*csz;\n           float mu=  getMu(tridata,idx);\n\n           triangles[i].p[j] = mix( v1 , v2,mu);\n\n       }\n    }\n}\n\n//-----------------------------\n\n//Iq\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    \n    //vec3 normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\n// triangle degined by vertices v0, v1 and  v2\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 );\n    \n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    return vec3( t, u, v );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//ISOSURFACE FUNCTION \nconst float PI = 3.14159265358979323846264338327950288;\n\nfloat map(vec3 p)\n{\n    vec3 p_normalized = (p + vec3(L/4.)) / (L/4.) - vec3(1.0);\n    //return length(p_normalized-vec3(0,0,0.5)) - 0.5; // Sphere with radius 0.5\n    \n    p_normalized=p_normalized-vec3(0,0,1.);\n    \n    float \n    x=p_normalized.x,\n    y=p_normalized.y,\n    z=p_normalized.z;\n\n    float fn;      \n    float \n    u=1.0,\n    v=1.0,\n    w=2.0;\n    \n    float \n    A=1.0,\n    B=2.0,\n    C=2.0,\n    D=1.5,\n    E=1.5,\n    F=0.5;\n    \n    //1.0 for Neumann\n    //0.0 for Dirichlet\n    float type=1.0;\n    \n    if(type==0.0) //Dirichlet\n    fn =\n    A * sin(u * PI * x)* sin(v * PI * y)* sin(w * PI * z) +\n               B * sin(u * PI * x)* sin(v * PI * z)* sin(w * PI * y) +\n               C * sin(u * PI * y)* sin(v * PI * x)* sin(w * PI * z) +\n               D * sin(u * PI * y)* sin(v * PI * z)* sin(w * PI * x) +\n               E * sin(u * PI * z)* sin(v * PI * x)* sin(w * PI * y) +\n               F * sin(u * PI * z)* sin(v * PI * y)* sin(w * PI * x);\n    \n    else //Nuemann\n    fn = A * cos(u * PI * x)* cos(v * PI * y)* cos(w * PI * z) +\n     B * cos(u * PI * x)* cos(v * PI * z)* cos(w * PI * y) +\n     C * cos(u * PI * y)* cos(v * PI * x)* cos(w * PI * z) +\n     D * cos(u * PI * y)* cos(v * PI * z)* cos(w * PI * x) +\n     E * cos(u * PI * z)* cos(v * PI * x)* cos(w * PI * y) +\n     F * cos(u * PI * z)* cos(v * PI * y)* cos(w * PI * x);\n\n    \n    return fn ;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    vec2 resolution=iResolution.xy;\n    vec3 voxelCoord = texToVoxCoord(floor(fragCoord), offset);    \n    float data =map(voxelCoord);\n    fragColor = vec4(data);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// MARCHING CUBES BUFFER (used if CACHE enabled)\n\nGRIDCELL g;\nTRIANGLE[5] triangles;\nuvec4 tridata=uvec4(0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec3 v = texToVoxCoord(floor(fragCoord), offset); \n       \n    int nv=0;\n    for(int id=0;id<8;id++)\n    {\n\n        g.p[id]=v+  VertexOffset[id];\n        g.val[id]=getVoxel(v+  VertexOffset[id],iChannel1,iChannelResolution[1]).x;\n        if(g.val[id]>0.) nv++;\n    }\n    \n     if(nv==0  || nv==8) tridata= uvec4(0u);\n     else {\n         tridata =Polygonise(g,0.,triangles,iChannel0);\n        \n     }\n             \n    fragColor = uintBitsToFloat(tridata);\n\n}","name":"Buffer C","description":"","type":"buffer"}]}