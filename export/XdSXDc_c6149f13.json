{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Pustules by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XdSXDc\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTrying to achive high percieved detail with while keeping\n\tcomputational cost to a minimum.\n\n\tThe render is done in 3 steps. The base raymarched geometry,\n\twhich is then followed by a refined domain raymarching loop\ton more \n\tcomplex geometry (2 layers of 8-tap 3d voronoi displacement).\n\tAnd finally fine detail is added with gradient bump mapping on a 3d field.\n*/\n\n//#define USE_DISNEYS_DIFFUSE\n\n#define FAR 7.\n#define time iTime*0.5\n#define PI 3.14159265\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat smin( in float a, in float b, in float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 rand22(in vec2 p){\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\nfloat hash( float n ) { return fract(sin(n)*43758.5453); }\n\n//Trying to get away with 8-tap 3d voronoi\nvec3 vor(in vec3 p)\n{\n    p *= 4.;\n    float pri = -1.;\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float rid = -1.;\n    vec2 rz = vec2(2.);\n    float dc = 0.;\n    for (int i=-1; i<=0; i++) \n\tfor (int j=-1; j<=0; j++) \n\tfor (int k=-1; k<=0; k++) \n\t{\n\t\tvec3 ir = ip + vec3(i, j, k);\n\t\tvec3 fr = fp - vec3(i, j, k);\n\t\tvec2 uid = ir.xy * vec2(0.037, 0.119) + ir.z * 0.00301;\n        vec2 rand = rand22(uid)*.66+.67;\n        vec3 pp = fr -(vec3(rand.x));\n        float d = dot(pp, pp);\n        if (d < rz.x)\n\t\t{\n            rz.y = rz.x;\n            rz.x = d;\n            dc = d;\n            rid = hash(dot(uid,vec2(1.01,17.01)));\n\t\t}\n        else if(d < rz.y)\n\t{\n    \trz.y = d;\n\t}\n\t}\n\n    rz.y = rz.y-rz.x;\n    return vec3(rz,rid);\n}\n\nfloat map(vec3 p)\n{\n    float mv =sin(time*1.5+sin(time*2.7))*0.51;\n    float d = length(p-mv)-.51;\n    d = smin(d,length(p+mv)-.45,1.9);\n    \n    return d;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<70; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*1.1;\n        h = res;\n    }\n\treturn d;\n}\nvec2 mapHD(vec3 p)\n{\n    float d = map(p);\n    float id = 0.;\n    vec3 rz = vor(p*1.1)*0.1;\n    d += rz.x;\n    id = rz.y+rz.z*0.7;\n    rz =  vor(p*2.1)*0.05;\n    d += rz.x;\n    id += rz.y+rz.z;\n    \n    return vec2(d*0.9,id);\n}\n\nvec2 marchHD(in vec3 ro, in vec3 rd, in float d)\n{\n\tfloat maxd = FAR;\n    float precis = 0.008;\n    float h=precis*2.0;\n    float id = 0.;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(h)<precis || d>maxd ) break;\n        d += h;\n\t    vec2 res = mapHD(ro+rd*d);\n        h = res.x;\n        id = res.y;\n    }\n    if (d>maxd)d = 1000.;\n\treturn vec2(d,id);\n}\n\nvec3 normal(in vec3 p, in vec3 rd)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\tvec3 n = normalize(e.yxx*mapHD(p + e.yxx).x + e.xxy*mapHD(p + e.xxy).x + \n\t\t\t\t\t e.xyx*mapHD(p + e.xyx).x + e.yyy*mapHD(p + e.yyy).x ); \n    \n    float k = dot(-rd,n);\n    return n + rd*k*(0.5-0.5*sign(k));\n}\n\n\n//from iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat ssin(float x) \n{\n    float rz = sin(x)*0.5+0.5;\n\treturn rz*rz;\n}\n\nfloat fbm(vec3 p) \n{\n    float t = 0.;\n    float z = 4.;\n    for (int i=0;i<3;i++)\n    {\n        t += (noise(p) / z);\n        z *= 3.;\n        p *= 2.8;\n    }\n    return t;\n}\n\nfloat bnoise(in vec3 p)\n{\n    float n = ssin(fbm(p*21.)*40.)*0.003;\n    return n;\n}\n\nvec3 bump(in vec3 p, in vec3 n)\n{\n    vec2 e = vec2(.01,0);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*2.);\n    return n;\n}\n\n//shadows and AO from iq\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {\n\t\tfloat h = mapHD(ro + rd*t).x;\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.02, .20 );\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = mapHD( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat hornerD(in float f, in float x){return 1. + (f - 1.) * exp2((-5.55473 * x - 6.98316) * x);}\n\n//mostly from: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec3 shade(in vec3 pos, in vec3 n, in vec3 rd, in vec3 l, in vec3 lcol, in vec3 alb)\n{\n    //material data (could be passed in)\n    const float rough = 0.4;\n    const vec3 F0 = vec3(.02);\n    const float kr = .3; //diff/spec ratio\n    \n    float nl = dot(n, l);\n    float nv = dot(n, -rd);\n    vec3 col = vec3(0.);\n    float ao = calcAO(pos, n);\n    if (nl > 0. && nv > 0.)\n    {\n        vec3 haf = normalize(l - rd);\n        float nh = dot(n, haf); \n        float vh = dot(-rd, haf);\n        \n        #ifdef USE_DISNEYS_DIFFUSE\n        float fd90 = 0.5+ 2.*vh*vh*rough;\n        vec3 dif = nl*alb*hornerD(fd90, nl)*hornerD(fd90, nv);\n        #else\n        vec3 dif = alb*nl;\n        #endif\n        \n        float a = rough*rough;\n        float a2 = a*a;\n        float dn = nh*nh*(a2 - 1.) + 1.;\n        float D = a2/(PI*dn*dn);\n        \n        float k = pow( rough*0.5 + 0.5, 2.0 )*0.5;\n        float nvc = max(nv,0.);\n        float gv = nvc/(nvc*(1.-k) + k);\n        float gl = nl/(nl*(1.-k) + k);\n        float G = gv*gl;\n\n        vec3 F = F0 + (1. - F0) * exp2((-5.55473 * vh - 6.98316) * vh);\n        \n        vec3 spe = D*F*G/(nl*nv);\n    \t\n        #if 1\n        col = lcol*mix(spe*nl, dif, kr);\n        #else\n        col = lcol*nl*mix(spe, dif, kr);\n        #endif\n        col *= shadow( pos, l, 0.05, 10.);\n    }\n    col += 0.07*alb*ao;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 bp = fragCoord.xy/iResolution.xy;\n    vec2 p = bp*2.-1.;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.5,0.3):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    \n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-3.6));\n    mat2 mx = mm2(time*.04+mo.x*6.);\n    mat2 my = mm2(time*0.06+mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    float edl = dot(rd,ligt)*0.5+.5;\n    vec3 bgvor = vor(rd*4.2)*0.35;\n    bgvor += vor(rd*9.)*0.25;\n    bgvor += vor(rd*25.)*0.1;\n    vec3 bgcol = ((bgvor.z*.5 + 0.1)*(.5 - bgvor.x*1.5*(1.5 - bgvor.y*10.)))\n        *(sin(vec3(1,1.5,1.7) + noise(rd*24.))*.5+.5);\n    vec3 lcol = vec3(.9,.85,.75)*1.2;\n    bgcol *= bgcol;\n    vec3 col = bgcol*0.8 + edl*bgcol + (pow(edl,150.)*2.5 + smoothstep(0.998,1.,edl))*lcol*0.35;\n    \n    float rz = march(ro,rd);\n    if ( rz < FAR )\n    {\n        vec2 rzH = marchHD(ro,rd,rz);\n        float rzHD = rzH.x;\n        rz = rzH.x;\n        if (rzHD < FAR)\n        {\n            vec3 pos = ro+rzHD*rd;\n            vec3 nor= normal(pos, rd);\n            nor = bump(pos,nor);\n            col = sin(vec3(1.95,1.63,1.4)+rzH.y*13.+8.6)*.57+.7;\n            col *= col;\n            col = shade(pos, nor, rd, ligt, lcol,col);\n        }\n    }\n\t\n   \tcol *= pow(16.0*bp.x*bp.y*(1.0-bp.x)*(1.0-bp.y),0.1);\n   \n   \tcol = clamp(col,0.,1.);\n   \tcol = clamp(pow(col, vec3(0.416667))*1.055 - 0.055,0.,1.); //cheap sRGB approx\n   \tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdSXDc","date":"1416366785","viewed":3074,"name":"Pustules","username":"nimitz","description":"Alternate name: \"Wet turd\"\n\nMouse enabled.","likes":71,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","voronoi","pbr","tasty"],"hasliked":0,"parentid":"","parentname":""}}