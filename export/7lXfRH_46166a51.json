{"ver":"0.1","info":{"id":"7lXfRH","date":"1650523712","viewed":74,"name":"halftone 0421.2","username":"actonmic","description":"halftone","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["halftone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.1415926535\n\n#define C_ANGLE 165.0\n#define M_ANGLE 45.0\n#define Y_ANGLE 90.0\n#define K_ANGLE 105.0\n\nfloat angle = 15.0;\nfloat size = 1.2;\nfloat offset = 15.0;\nfloat black = 1.0;\nfloat blackSize = 0.8;\nfloat intensity = 3.3;\nfloat alpha = 0.8;\nfloat opacity = 1.0;\n\nfloat radian(float angle){\n    return angle/180.0 * PI;\n}\n\nvec2 rotate(vec2 pos, float angle, vec2 center){\n    float r = radian(angle);\n    float c = cos(r), s = sin(r);\n    vec2 res = pos - center;\n    res = vec2(res.x * c + res.y * s, res.y * c - res.x * s);\n    res = res + center;\n    return res;\n}\n\nvec2 move(vec2 pos, vec2 offset){\n    return pos - offset;\n}\n\nvec2 scale(vec2 pos, vec2 center, float sc){\n    vec2 cp = pos - center;\n    cp /= sc;\n    return center + cp;\n}\n\nvec2 mosaic(vec2 pos, float size){\n    vec2 s = pos - mod(pos, size);\n    return s;\n}\n\nvec4 texture2D(vec2 pos){\n    return texture(iChannel0,pos/iResolution.xy);\n}\n\n\nvec2 getMosaicPos(vec2 p, float angle, vec2 center){\n    vec2 pos = rotate(p,angle, center);\n    pos = mosaic(pos, size);\n    pos += size / 2.0; \n    pos = rotate(pos, -angle, center);\n    return pos;\n}\n\nvec4 getMosaicColor(vec2 p, float angle, vec2 center){\n    return texture2D(getMosaicPos(p, angle, center));\n}\n\nvec4 rgb2cmyk(vec3 rgb){\n    vec4 res = vec4(0.0);\n    vec3 mid = vec3(rgb.r,rgb.g,rgb.b);\n\n    float k = 1.- max(mid.x,max(mid.y,mid.z));\n    \n    k*= black;\n    \n    res.x = (1. - mid.x-k)/(1.0-k);\n    res.y = (1. - mid.y-k)/(1.0-k);\n    res.z = (1. - mid.z-k)/(1.0-k);\n    res.w = k;\n    return res;\n}\n\nvec4 getCMYK(vec2 p, float angle, vec2 center){\n    return rgb2cmyk(getMosaicColor(p, angle, center).rgb);\n}\n\nfloat halfTone(vec2 pos, vec2 center, float value, float baseRadius){\n    float dist = distance(pos, center);\n    float r = value * baseRadius;\n    //return step(r, dist);\n    return  1.0 -  smoothstep(0., r, dist);\n}\n\nfloat cmyk2rgb(float col,float k){\n    return (1. - col) * (1. - k);\n}\n\nvec3 cmyk2rgb(vec4 cmyk){\n    return vec3(cmyk2rgb(cmyk.x,cmyk.w),\n        cmyk2rgb(cmyk.y,cmyk.w),\n        cmyk2rgb(cmyk.z,cmyk.w));\n}\n\nvec4 blend_normal(vec4 base, vec4 overlay) {\n    return base + overlay - base * overlay.a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = iMouse.xy / iResolution.xy;\n    \n    //intensity = 0.5 + 3.0 * p.y;\n    //size = 0.01 +99.0 * p.x;\n    \n    //fset = p .x * offset;\n    \n    alpha = fragCoord.x/iResolution.x;\n    \n    if(alpha< 0.3333){\n        alpha = 0.3333;\n    }else if(alpha < 0.6666){\n        alpha = 0.6666;\n    }else{\n        alpha = 1.0;\n    }\n    \n    alpha = 1.0;\n    \n    vec2 pos = fragCoord;\n    vec2 center = iResolution.xy / 2.0 + offset;\n    \n    vec2 cPos = getMosaicPos(pos, C_ANGLE, center);\n    vec2 mPos = getMosaicPos(pos, M_ANGLE, center);\n    vec2 yPos = getMosaicPos(pos, Y_ANGLE, center);\n    vec2 kPos = getMosaicPos(pos, K_ANGLE, center); \n    \n    float c = rgb2cmyk(texture2D(cPos).rgb).r;\n    float m = rgb2cmyk(texture2D(mPos).rgb).g;\n    float y = rgb2cmyk(texture2D(yPos).rgb).b;\n    float k = rgb2cmyk(texture2D(kPos).rgb).a;\n    \n    float baseRadius = size / 2.0;\n    float br = baseRadius * intensity;\n    \n    vec4 cmyk = vec4(halfTone(pos,cPos,c,br),halfTone(pos,mPos,m,br),halfTone(pos,yPos,y,br),halfTone(pos,kPos,k,br * blackSize));\n    \n    // Time varying pixel color\n    vec3 col = cmyk2rgb(cmyk);\n    if(uv.x<0.5){\n   //     col = 1.0-cmyk.rgb;\n   //     col -= cmyk.w;\n    }\n\n    vec4 base = texture(iChannel0, uv);\n    vec4 overlay = vec4(col, 1.0) * alpha;\n    \n    \n    // Output to screen\n    \n    \n    fragColor = vec4(blend_normal(base, overlay).rgb,1.0);\n    //fragColor = vec4(col.rgb, 1.0);\n    //fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 coord = fragCoord;\n    vec4 color = vec4(0.0);\n    int size = 0;\n    for (int i = -size; i <= size; i++) {\n        for (int j = -size; j <= size; j++) {\n            color += texture(iChannel0, (coord + vec2(float(i), float(j))) / iResolution.xy) / pow(float(size * 2 + 1), 2.0);\n        }\n    }\n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"}]}