{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/**\n * This shader visualizes two set expressions.\n * In each expression, there are three sets.\n * The first set is A, which is an interval on the Y-axis.\n * The other two sets are B and C, which are intervals on the X-axis.\n *\n * The first expression is: A × (B ∆ C)\n *\n * The second expression is: (A × B) ∆ (A × C)\n *\n * Each axis in the image as a domain of [0.0, 1.0].\n *\n * Let A = { y ∈ R | 0.1 < y < 0.9 }\n *\n * Let B = { x ∈ R | 0.2 < x < 0.6 }\n *\n * Let C = { x ∈ R | 0.3 < x < 0.4 }\n *\n * Both expressions yield a set of planes.\n * This is due to the cartesian product appearing in both expressions.\n * While the second expression has three cartesian products, the effect is not additive since they are separated by the ∆ operator.\n * A series of three or more cartesian products would be more difficult to visualize since it extends to (and beyond) 3D space.\n *\n * We will be writing each expression as a function in this programming language.\n *\n *   p_{x, y} = f(x, y)\n *\n * Where p_{x, y} is the pixel intensity for the given spot on the image.\n * The function will return a value of one when the x and y values belong to the set it describes.\n * It will return 0 when the coordinates of x and y do not belong to the set.\n * The affect this has is that it describes the entire expression as a drawing on the image.\n *\n * The function will have to look a tad bit different than the expressions written above.\n * The biggest difference is that the ∆ will be written as ^^, since it equivalent to the XOR operator in this visualization.\n * The cartesian product will be written as the && operator (AND operator) since the functions should only return 1 when\n * both x and y appear in the set.\n *\n * Let f(x) be a function that indicates if the value x belongs in the set A.\n * Let g(x) be a function that indicates if the value x belongs in the set B.\n * Let h(x) be a function that indicates if the value x belongs in the set C.\n *\n * A × (B ∆ C) is written as f(y) & (g(x) ^ h(x))\n *\n * (A × B) ∆ (A × C) is written as (f(y) & g(x)) ^ (f(y) & h(x))\n *\n * L(x, y) = f(y) & (g(x) ^ h(x))\n * R(x, y) = (f(y) & g(x)) ^ (f(y) & h(x))\n *\n * To differentiate these two expressions in the image, L(x, y) will be shown as red and R(x, y) will be shown as blue.\n * If they are equivalent, the will show up overlapping as the color purple.\n *\n * Notes:\n *\n *  - For this programming language, we have to write a < x < b as (a < x) && (x < b)\n */\n\n\nbool f(float x)\n{\n  return (0.1 < x) && (x < 0.9);\n}\n\nbool g(float x)\n{\n  return (0.2 < x) && (x < 0.6);\n}\n\nbool h(float x)\n{\n  return (0.3 < x) && (x < 0.4);\n}\n\nbool L(float x, float y)\n{\n  return f(y) && (g(x) ^^ h(x));\n}\n\nbool R(float x, float y)\n{\n  return (f(y) && g(x)) ^^ (f(y) && h(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float l = L(uv.x, uv.y) ? 1.0 : 0.0;\n    float r = R(uv.x, uv.y) ? 1.0 : 0.0;\n\n    // Output to screen (red, green, blue, opacity)\n    fragColor = vec4(l, 0.0, r, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lXdyRr","date":"1734677785","viewed":24,"name":"A × (B ∆ C) = (A × B) ∆ (A × C)","username":"tay10r","description":"Using GLSL to visualize an expression from a MAT 299 class.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""}}