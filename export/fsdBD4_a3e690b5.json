{"ver":"0.1","info":{"id":"fsdBD4","date":"1656846692","viewed":343,"name":"Easy Ray AABB Intersection","username":"Patan77","description":"Easy to use Ray AABB Intersection with support for ray origin inside/outside of AABB, distance and normal output.\n// Patrik Fröhler www.patan77.com","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","intersection","box","aabb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Patrik Fröhler\n    www.patan77.com\n*/\n\n#define Epsilon 0.000001\n#define Epsilon2 0.00001\n#define FalseFloat 0.0\n#define TrueFloat  1.0\n\n/*\n\n/*********[  Functions  ]*********/\n \nfloat HorizontalToVerticalFieldOfView(in float horizontalFieldOfViewRadians,in float aspectRatio)\n{\n    return  tan(horizontalFieldOfViewRadians * 0.5) / aspectRatio;\n}\n\nfloat NegPosOneToZeroPosOne(in float value)\n{\n    return value * 0.5 + 0.5;\n}\n\n\n/*********[  Ray  ]*********/\n\nstruct Ray \n{\n   vec3 Origin;\n   vec3 Direction;\n};\n\nRay RayToLocalSpace(in Ray ray, in vec3 localSpace )\n{\n    return Ray(ray.Origin - localSpace, ray.Direction);\n}\n\n\n/******[  Axis Aligned Bounding Box  ]******/\n\nstruct Bounds \n{\n   vec3 Min;\n   vec3 Max;\n   \n   vec3 Center;\n   vec3 Extent;\n};\n\n\nBounds CreateBounds(in vec3 Min, in vec3 Max)\n{\n    vec3 extent = (Max - Min) * 0.5;\n    vec3 center = Min + extent;\n    return Bounds(Min, Max ,center, extent);\n}\n\nBounds UpdateBounds(Bounds bounds)\n{\n    return CreateBounds(bounds.Min, bounds.Max);\n}\n\n/*********[  Camera  ]*********/\n\nstruct Camera\n{\n    vec3 Position;\n    vec3 LookAtPosition;\n    float FovVerticalRadians;\n    float FovHorizontalDegrees;\n    \n    float AspectRatio;\n    vec3 RightDirection;\n    vec3 UpDirection;\n    vec3 ForwardDirection;   \n};\n\nCamera CreateCamera(in vec3 position, in vec3 lookAtPosition, in float fovHorizontalDegrees)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    float fovVerticalRadians = HorizontalToVerticalFieldOfView(radians(fovHorizontalDegrees), aspectRatio);\n    \n    const vec3 worldUpVector = vec3(0,1,0);\n    vec3 forwardDirection = normalize( lookAtPosition - position );\n    vec3 rightDirection = normalize(cross(worldUpVector, forwardDirection));\n    vec3 upDirection = normalize(cross(forwardDirection, rightDirection));\n    \n    return Camera(position, lookAtPosition, fovVerticalRadians, fovHorizontalDegrees, aspectRatio, rightDirection, upDirection, forwardDirection);\n}\n\nCamera UpdateCamera(Camera camera)\n{\n    return CreateCamera(camera.Position, camera.LookAtPosition, camera.FovHorizontalDegrees);\n}\n\n\nRay GenerateCameraRay(in Camera camera, in vec2 fragCoord)\n{\n    vec2 pixelNDCSpace, pixelScreenSpace, pixelCameraSpace;\n\n    pixelNDCSpace =  fragCoord / iResolution.xy;\n    pixelScreenSpace = (2.0 * pixelNDCSpace) - 1.0;\n    pixelCameraSpace = pixelScreenSpace* camera.FovVerticalRadians;\n    pixelCameraSpace.x *= camera.AspectRatio;\n\n\tvec3  rayDirection = normalize((pixelCameraSpace.x*camera.RightDirection) + (pixelCameraSpace.y*camera.UpDirection) + camera.ForwardDirection  );    \n    \n    return Ray(camera.Position, rayDirection);\n}\n\n/*********[  Intersection  ]*********/ //(Based on Inigo Quilez: Box - intersection) https://iquilezles.org/articles/intersectors/\n \nfloat IntersectRayAABB(in Ray ray, in Bounds bounds, out float hitDistance, out float insideAABB, out vec3 normal)\n{\n    vec3 n = ray.Origin / (ray.Direction + Epsilon);\n    vec3 k = (bounds.Extent + Epsilon2) / abs(ray.Direction + Epsilon);\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float hitDistanceNear = max(max(t1.x, t1.y), t1.z);\n    float hitDistanceFar = min(min(t2.x, t2.y), t2.z);\n\n    hitDistance = hitDistanceNear;\n    insideAABB = FalseFloat;\n    if (hitDistanceNear < 0.0)\n    {\n        hitDistance = hitDistanceFar;\n        insideAABB = TrueFloat;\n    } \n\n    if (hitDistanceNear >= hitDistanceFar - Epsilon || hitDistanceFar < 0.0)\n    {\n        return FalseFloat;\n    }\n    \n    normal = -sign(ray.Direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); // Can be removed if normal not needed.\n    return TrueFloat;\n}\n\n\n/********[  Animation  ]********/\n\nvec2 UnitCircleVector(in float value)\n{\n    return vec2(sin(value), cos(value));\n}\n\nCamera AnimateCamera(in Camera camera)\n{\n    vec2 unitCircle = UnitCircleVector(iTime);\n    float cameraDistanceLookAt = distance(camera.Position.xz, camera.LookAtPosition.xz);\n    \n    float frequencyBackForward = 0.25;\n    float offsetFromLookAt = 0.1;\n    float backForwardMovment = NegPosOneToZeroPosOne(sin(iTime * frequencyBackForward)) + offsetFromLookAt;    \n    \n    float frequencyUpDown = 0.75;\n    float amplitudeUpDown = 1.5;\n    float cameraOffset = camera.Position.y*camera.LookAtPosition.y;\n    float upDownMovment = sin(iTime*frequencyUpDown)*amplitudeUpDown + cameraOffset ;\n    \n    camera.Position.xz = unitCircle*cameraDistanceLookAt*backForwardMovment + camera.LookAtPosition.xz;\n    camera.Position.y = upDownMovment;\n    \n    camera = UpdateCamera(camera);\n    return camera;\n}\n\n\n/*********[  Shader  ]*********/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Bounds AABB = CreateBounds(vec3(0,0,0) , vec3(1,1,1));\n    Camera camera = CreateCamera(vec3(1.5,1.5,-1.5), vec3(0.5,0.5,0.5), 120.0);\n    \n    camera = AnimateCamera(camera);\n    \n    Ray cameraRay = GenerateCameraRay(camera, fragCoord);\n    Ray cameraRayLocal = RayToLocalSpace(cameraRay, AABB.Center);\n    \n    vec3 normal; \n    float hitDistance, insideAABB;\n\tfloat hit = IntersectRayAABB( cameraRayLocal, AABB, hitDistance, insideAABB, normal);\n\n    vec3 hitLocation = camera.Position + (hitDistance * cameraRay.Direction); \n    \n    float alpha = hit;\n    vec3 color = hitLocation * alpha;\n    \n    if(hit + insideAABB > 1.0) \n    { \n       color*= 0.5;\n    } \n    \n\tfragColor = vec4(color, alpha);\n}","name":"Image","description":"","type":"image"}]}