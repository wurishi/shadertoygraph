{"ver":"0.1","info":{"id":"stjSzm","date":"1627376876","viewed":78,"name":"Ellipse Distance from Torus","username":"weasel","description":"In this shader I explored the possibility to use a projection of a torus which has an analytic sdf to create an ellipse sdf. It is not yet fully featured, but it would not be hard to support ellipses from any (non orthogonal) 2d matrix.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","distance","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, vec2(cos(-angle), sin(-angle))));\n}\n\n#define RADIUS 0.7\n\nfloat globalSdf(vec3 pos) {\n    // just a torus in the xy plane (was a real sdf before optimizing the sqrt)\n    vec3 d = vec3(normalize(pos.xy) * RADIUS, 0.0) - pos;\n    return dot(d, d); // avoid the sqrt here and only do it once\n}\n\n#define NUMBER_OF_STEPS 10\nvec4 search_minimum(in vec3 rpos, in vec3 rdir) {\n    // direct minimum search without derivatives\n    // NOTE: one could use the newton method to find the\n    // minimum quickly using the 1. and 2. derivative\n    float t_max = -dot(rpos, rdir);\n    float t_min = t_max - RADIUS;\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        // divide interval into 3 parts\n        float new_t_min = (t_min * 2.0 + t_max) / 3.0;\n        float new_t_max = (t_min + 2.0 * t_max) / 3.0;\n\t\tfloat new_sd_min = globalSdf(rpos + new_t_min * rdir);\n\t\tfloat new_sd_max = globalSdf(rpos + new_t_max * rdir);\n        if (new_sd_min < new_sd_max)\n            t_max = new_t_max;\n        else\n            t_min = new_t_min;\n    }\n    float sd_max = globalSdf(rpos + t_max * rdir);\n    float sd_min = globalSdf(rpos + t_min * rdir);\n    return vec4(vec3(abs(sin((sqrt(min(sd_min, sd_max)) - 0.01) * 50.0))), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m = m * 2.0 - 1.0;\n    m.y = -abs(m.y);\n\n     // camera movement\n\tvec3 cam_pos = rotateX(vec3(0,1,0), m.y * 1.6); // normalized\n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = -cam_pos; // look at origin\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create orthographic view ray\n    vec3 rpos = uv.x*uu - abs(uv.y)*vv;\n\tvec3 rdir = ww;\n    \n    vec4 shaded_color = search_minimum(rpos, rdir);\n    //shaded_color.rgb *= shaded_color.a;\n    //shaded_color.rgb = pow(shaded_color.rgb, vec3(0.7));\n\n    fragColor = vec4(shaded_color);\n}","name":"Image","description":"","type":"image"}]}