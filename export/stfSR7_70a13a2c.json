{"ver":"0.1","info":{"id":"stfSR7","date":"1625350996","viewed":562,"name":"Cubic Bezier Analytic OBB (2D)","username":"fizzer","description":"Finding an oriented bounding box for a cubic Bezier curve using Principle Component Analysis - the eigenvectors of the covariance of the Bezier curve point coordinates are used as axes for the bounding box (without actually sampling the Bezier curve).","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["2d","bezier","cubic","boundingbox","obb","oriented"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// An attempt to use Principle Component Analysis to analytically calculate an oriented bounding box for\n// a cubic Bezier curve.\n\n// It's not the minimal-area OBB but it seems to generally have lower area than an AABB.\n// The circle indicator in the lower-left of the frame shows green when the OBB has less area\n// than the AABB and otherwise shows red.\n\n// The main reason this is suboptimal is probably that the moments are computed directly from the curve\n// parameterised by t, rather than by length.\n\n\nfloat binomialCoefficient(int n, int k)\n{\n    // Using the multiplicative formula\n    // https://en.wikipedia.org/wiki/Binomial_coefficient#Multiplicative_formula\n    float c = 1.;\n    for(int i = 1; i <= k; ++i)\n        c *= float(n + 1 - i) / float(i);\n    return c;\n}\n\n// https://en.wikipedia.org/wiki/B%C3%A9zier_curve\nvec2 explicitBezier(in vec2 control_points[4], float t)\n{\n    vec2 sum = vec2(0);\n    for(int i = 0; i <= 3; ++i)\n    {\n        sum += float(binomialCoefficient(3, i)) *\n            \tpow(1. - t, float(3 - i)) * pow(t, float(i)) * control_points[i];\n    }\n\n    return sum;\n}\n\n// Exact BBox to a cubic bezier\n// From IQ: https://www.shadertoy.com/view/XdVBWd\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    // extremes\n    vec2 mi = min(p0,p3);\n    vec2 ma = max(p0,p3);\n\n    vec2 k0 = -1.0*p0 + 1.0*p1;\n    vec2 k1 =  1.0*p0 - 2.0*p1 + 1.0*p2;\n    vec2 k2 = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;\n\n    vec2 h = k1*k1 - k0*k2;\n\n    if( h.x>0.0 )\n    {\n        h.x = sqrt(h.x);\n        //float t = (-k1.x - h.x)/k2.x;\n        float t = k0.x/(-k1.x-h.x);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;\n            mi.x = min(mi.x,q);\n            ma.x = max(ma.x,q);\n        }\n        //t = (-k1.x + h.x)/k2.x;\n        t = k0.x/(-k1.x+h.x);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;\n            mi.x = min(mi.x,q);\n            ma.x = max(ma.x,q);\n        }\n    }\n\n    if( h.y>0.0)\n    {\n        h.y = sqrt(h.y);\n        //float t = (-k1.y - h.y)/k2.y;\n        float t = k0.y/(-k1.y-h.y);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;\n            mi.y = min(mi.y,q);\n            ma.y = max(ma.y,q);\n        }\n        //t = (-k1.y + h.y)/k2.y;\n        t = k0.y/(-k1.y+h.y);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;\n            mi.y = min(mi.y,q);\n            ma.y = max(ma.y,q);\n        }\n    }\n   \n    return vec4( mi, ma );\n}\n\nbool computeTransformation(in vec2 control_points[4], out vec2 translation, out mat2 rotation)\n{\n    // Set p0 to zero, to simplify computation\n    vec2 p1 = control_points[1] - control_points[0];\n    vec2 p2 = control_points[2] - control_points[0];\n    vec2 p3 = control_points[3] - control_points[0];\n    \n    // Polynomial coefficients of Bezier curve B(t)\n    vec2 a = 3. * (p1 - p2) + p3;\n    vec2 c = 3. * p1;\n    vec2 b = 3. * p2 - 2. * c;\n   \n    // Expected value, E[B] = mean of points along Bezier curve\n    vec2 mu = a / 4. + b / 3. + c / 2.;\n\n    // Polynomial coefficients of Bx(t)By(t)\n    float axy = a.x * a.y;\n    float bxy = a.x * b.y + b.x * a.y;\n    float cxy = a.x * c.y + b.x * b.y + c.x * a.y;\n    float dxy = b.x * c.y + c.x * b.y;\n    float exy = c.x * c.y;\n    \n    // Polynomial coefficients of Bx(t)Bx(t) and By(t)By(t)\n    vec2 aB = a * a;\n    vec2 bB = a * b * 2.;\n    vec2 cB = a * c * 2. + b * b;\n    vec2 dB = b * c * 2.;\n    vec2 eB = c * c;\n    \n    // Definite integrals of polynomials p(1) - p(0)\n    float xy =  axy / 7. +  bxy / 6. +  cxy / 5. +  dxy / 4. +  exy / 3.; // E[BxBy]\n    \n    float xx = aB.x / 7. + bB.x / 6. + cB.x / 5. + dB.x / 4. + eB.x / 3.; // E[BxBx]\n    float yy = aB.y / 7. + bB.y / 6. + cB.y / 5. + dB.y / 4. + eB.y / 3.; // E[ByBy]\n\n    // Covariance matrix\n    mat2 covariance;\n    covariance[1][0] = covariance[0][1] = xy - mu.x * mu.y;\n    covariance[0][0] = xx - mu.x * mu.x;\n    covariance[1][1] = yy - mu.y * mu.y;\n    \n    // Characteristic polynomial of covariance matrix\n    float eigen_a = 1.;\n    float eigen_b = -(covariance[0][0] + covariance[1][1]);\n    float eigen_c = covariance[0][0] * covariance[1][1] - covariance[1][0] * covariance[0][1];\n \n    float discr = eigen_b * eigen_b - 4. * eigen_a * eigen_c;\n    \n    if(discr > 0.)\n    {\n        float sqrt_discr = sqrt(discr);\n        \n        // Eigenvalues of covariance matrix\n        float lambda0 = (-eigen_b - sqrt_discr) / (2. * eigen_a);\n        float lambda1 = (-eigen_b + sqrt_discr) / (2. * eigen_a);\n\n        // Eigenvectors of covariance matrix\n        vec2 eigenvector0 = vec2(covariance[1][0], lambda0 - covariance[0][0]);\n        vec2 eigenvector1 = vec2(covariance[1][0], lambda1 - covariance[0][0]);\n\n        rotation[0] = normalize(eigenvector0);\n        rotation[1] = normalize(eigenvector1);        \n\n        translation = mu + control_points[0];\n        return true;\n    }\n    \n    return false;\n}\n\nbool getCubicBezierOBB(in vec2 control_points[4], out vec2 box_points[4])\n{\n    vec2 translation;\n    mat2 rotation;\n    \n    bool res = computeTransformation(control_points, translation, rotation);\n    \n    if(!res)\n        return false;\n        \n    // Transform the Bezier control points into the local space of the OBB\n    vec2 control_points_xfrm[4];\n    for(int i = 0; i <= 3; ++i)\n    {\n        control_points_xfrm[i] = control_points[i] - translation;\n        control_points_xfrm[i] = transpose(rotation) * control_points_xfrm[i];\n    }\n    \n    // Get axis-aligned bounding box in local space\n    vec4 b2_xfrm = bboxBezier(control_points_xfrm[0], control_points_xfrm[1],\n                              control_points_xfrm[2], control_points_xfrm[3]);\n    \n    // Transform AABB back to worldspace\n    box_points[0] = b2_xfrm.xy;\n    box_points[1] = vec2(b2_xfrm.x, b2_xfrm.w);\n    box_points[2] = b2_xfrm.zw;\n    box_points[3] = vec2(b2_xfrm.z, b2_xfrm.y);\n    \n    for(int i = 0; i < 4; ++i)\n        box_points[i] = rotation * box_points[i] + translation;\n    \n    return true;\n}\n\n\n// Distance to line segment\nfloat segment(vec2 p, vec2 a, vec2 b)\n{\n    return distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a, b - a), 0., 1.)));\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    return (m.x > 0.0) ? length(q) : m.y; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 2.;\n\n    // Control points\n    vec2 control_points[4];\n    \n    // Generate control points\n    // Control points animation from: https://www.shadertoy.com/view/XdVBWd\n    {\n        float time = iTime*0.5 - 0.7;\n        vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n        vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n        vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n        vec2 p3 = 0.8*sin( time*1.5 + vec2(1.0,5.0) );\n\n        control_points[0] = p0;\n        control_points[1] = p1;\n        control_points[2] = p2;\n        control_points[3] = p3;\n    }\n    \n    // Get the Bezier AABB\n    vec4 aabb = bboxBezier( control_points[0], control_points[1],\n                            control_points[2], control_points[3]);\n\n    float aabb_area = (aabb.z - aabb.x) * (aabb.w - aabb.y);\n\n    vec2 obb_points[4];\n    \n    // Get the Bezier OBB\n    getCubicBezierOBB(control_points, obb_points);\n\n    float obb_area = distance(obb_points[1], obb_points[0]) *\n                     distance(obb_points[1], obb_points[2]);\n\n\n    vec4 col = vec4(0);\n\n    col = vec4(.07, .07, .07, 1.);\n    \n    const int m = 32;\n    \n    float dist = 1e4;\n    \n    // Basic and slow method of evaluating distance to Bezier.\n    {\n        vec2 prevp;\n        for(int i = 0; i <= m; ++i)\n        {\n            float t = float(i) / float(m);\n            vec2 p;\n\n            p = explicitBezier(control_points, t);\n\n            if(i > 0)\n                dist = min(dist, segment(uv, prevp, p));\n\n            prevp = p;\n        }\n    }\n        \n    // Draw control edges\n    for(int i = 0; i < 3; ++i)\n    {\n        col = mix(vec4(.25, .25, .25, 1), col, smoothstep(.002, .004,\n                segment(uv, control_points[i], control_points[i + 1])));\n    }\n    \n    // Draw Bezier curve\n\tcol = mix(vec4(1, .2, .2, .2), col, smoothstep(.004, .006, dist));\n    \n    // Draw AABB\n    float d = sdBox( uv-(aabb.xy+aabb.zw)*0.5, (aabb.zw-aabb.xy)*0.5 );\n    col = mix( col, vec4(0.1,0.3,1.0,1), 1.0-smoothstep(0.003,0.005,abs(d)) );\n    \n    // Draw control points\n    for(int i = 0; i <= 3; ++i)\n       col = mix(vec4(1), col, smoothstep(.02, .023, distance(uv, control_points[i])));\n    \n    // Draw area indicator\n    col = mix((obb_area < aabb_area) ? vec4(0,1,0,1) : vec4(1,0,0,1), col,\n                    smoothstep(.1, .11, distance(uv, vec2(-1.5,-.7))));\n\n#if 0\n    // Enable this code to see a brute-force calculated minimal OBB.\n    {\n        vec2 translation;\n        mat2 rotation;\n\n        bool res = computeTransformation(control_points, translation, rotation);\n\n        vec2 box_points_bf[4];\n        float min_area = 1e9;\n        int n = 512;\n        for(int i = 0; i < n; ++i)\n        {\n            vec2 box_points[4];\n            \n            float th = float(i) / float(n) * 3.14159265359 * 2.;\n            rotation[0] = vec2(cos(th), sin(th));\n            rotation[1] = rotation[0].yx * vec2(-1, 1);\n            \n            // Transform the Bezier control points into the local space of the OBB\n            vec2 control_points_xfrm[4];\n            for(int i = 0; i <= 3; ++i)\n            {\n                control_points_xfrm[i] = control_points[i] - translation;\n                control_points_xfrm[i] = rotation * control_points_xfrm[i];\n            }\n\n            // Get axis-aligned bounding box in local space\n            vec4 b2_xfrm = bboxBezier(control_points_xfrm[0], control_points_xfrm[1],\n                                      control_points_xfrm[2], control_points_xfrm[3]);\n\n            // Transform AABB back to worldspace\n            box_points[0] = b2_xfrm.xy;\n            box_points[1] = vec2(b2_xfrm.x, b2_xfrm.w);\n            box_points[2] = b2_xfrm.zw;\n            box_points[3] = vec2(b2_xfrm.z, b2_xfrm.y);\n\n            for(int i = 0; i < 4; ++i)\n                box_points[i] = transpose(rotation) * box_points[i] + translation;\n                \n            float box_area = distance(box_points[1], box_points[0]) *\n                             distance(box_points[1], box_points[2]);\n                             \n            if(box_area < min_area)\n            {\n                min_area = box_area;\n                box_points_bf = box_points;\n            }\n        }\n        \n        // Draw brute-force OBB\n        col = mix(vec4(1,1,0,1), col, smoothstep(.004, .006, segment(uv, box_points_bf[0], box_points_bf[1])));\n        col = mix(vec4(1,1,0,1), col, smoothstep(.004, .006, segment(uv, box_points_bf[1], box_points_bf[2])));\n        col = mix(vec4(1,1,0,1), col, smoothstep(.004, .006, segment(uv, box_points_bf[2], box_points_bf[3])));\n        col = mix(vec4(1,1,0,1), col, smoothstep(.004, .006, segment(uv, box_points_bf[3], box_points_bf[0])));\n\n    }\n#endif\n\n    // Draw OBB\n    col = mix(vec4(1,0,1,1), col, smoothstep(.004, .006, segment(uv, obb_points[0], obb_points[1])));\n    col = mix(vec4(1,0,1,1), col, smoothstep(.004, .006, segment(uv, obb_points[1], obb_points[2])));\n    col = mix(vec4(1,0,1,1), col, smoothstep(.004, .006, segment(uv, obb_points[2], obb_points[3])));\n    col = mix(vec4(1,0,1,1), col, smoothstep(.004, .006, segment(uv, obb_points[3], obb_points[0])));\n\n    fragColor = vec4(sqrt(col.rgb), 1.0);\n}","name":"Image","description":"","type":"image"}]}