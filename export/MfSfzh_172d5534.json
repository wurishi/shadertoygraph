{"ver":"0.1","info":{"id":"MfSfzh","date":"1724627267","viewed":64,"name":"Keyboard-Controlled Camera","username":"Quazerix","description":"This scene allows for using the keyboard to modify the position/orientation of either a freecam or arcball camera. All data is stored in a buffer, so in the main loop, you can just call a texelFetch to get the current ray direction/orientation.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* USE ARROW KEYS TO CONTROL THE DIRECTION OF THE CAMERA (MODE 1) OR ORIENTATION OF THE SCENE (MODE 2)\n *\n * USE \"W\" AND \"S\" TO MOVE THE CAMERA FORWARD AND BACKWARD\n * (\"WALKS\" THE CAMERA IN MODE 1, CONTROLS \"ZOOM\" IN MODE 2)\n *\n * USE \"R\" TO RESET THE CAMERA POSITION\n * USE \"T\" TO TOGGLE BETWEEN CAMERA MODES (POSITIONS ARE PRESERVED BETWEEN MODES)\n *\n * SEE BUFFER A FOR MORE DETAILED NOTES\n */\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( float p, float b )\n{\n  return abs(p) - b;\n}\n\nfloat usdBox( in vec3 p, in vec3 b )\n{\n    return length( max(abs(p)-b,0.0 ) );\n}\n\nfloat sdRhombus( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\treturn d - r;\n}\n\nvec2 opRepLim(vec2 p, float s, vec2 limmin, vec2 limmax) {\n    return p-s*clamp(round(p/s),-limmin,limmax);\n}\n\n// Scene distance\n// Using part of iq's Greek Temple: https://www.shadertoy.com/view/ldScDh\nfloat map(vec3 p) {\n    p*=3.;\n    \n    vec3 q = p;\n    \n    // Columns\n    q.xz = opRepLim(q.xz,4., vec2(4.,2.), vec2(4.,2.));\n    float rad = .9 - .05*p.y + (.1*(.5+.5*sin(16.*atan(q.x, q.z))));\n    rad += .15*pow(.5 + .5*sin(q.y*3.),.1)-.15;\n    float d = length(q.xz) - rad;\n    d = max(d+.5, abs(q.y)-5.);\n    d *= .7;\n\n    // Column caps\n    d = min(d, sdBox(vec3(q.x, abs(q.y-.18)-5.0, q.z), vec3(1.4,.2,1.4)));\n    \n    // Carve out extra columns\n    d = max(d, -sdBox(p, vec3(14,6,6)));\n    \n    // Floor/steps\n    for (float i=0.; i<3.; i++) {\n        q=p;\n        q.z-=2.*mod(i,2.);\n        q.x+=2.*mod(i,2.);\n        q.y+=5.5+i;\n        q.xz = opRepLim(q.xz,4., vec2(4.+floor(i/2.),ceil(2.+i/2.)), vec2(ceil(4.+i/2.),2.+floor(i/2.)));\n        d = min(d, sdBox(q, vec3(2,.5,2)-.2)-.2);\n    }\n    \n    // Roof\n    q = vec3(mod(p.x+2.,4.)-2., p.y, mod(p.z+0.,4.)-2.);\n    float b = sdBox(q-vec3(0,7,0), vec3(1.95,1.,1.95)-.15)-.15;\n    b = max(b, sdBox(p-vec3(0,7,0),vec3(18,1,10)));\n    if (b<d) {d=b;}\n    q = vec3(mod(p.x+.5,1.)-.5, p.y, mod(p.z+.5,1.)-.5);\n    b = sdBox(q-vec3(0,8,0), vec3(.45,.5,.45)-.02)-.02;\n    b = max(b, sdBox(p-vec3(0,8,0),vec3(19,.2,11)));\n    if (b<d) d=b;\n    b = sdRhombus(p.yz-vec2(8.2,0), vec2(3,11),.05) ;\n    q = vec3(mod(p.x+1.,2.)-1., p.y, mod(p.z+1.,2.)-1.);\n    b = max(b, -sdBox(vec3(abs(p.x)-20.,p.y,q.z)-vec3(0,8,0), vec3(2,5,.1))-.02);\n    b = max(b,-p.y+8.2 );\n    b = max(b, usdBox(p-vec3(0,8,0),vec3(19,12,11)));\n    float c = sdRhombus( p.yz-vec2(8.3,0), vec2(2.25,8.5), 0.05);\n    c = max(c, sdBox(abs(p.x)-19.,2.));\n    d = min(d, max(b, -c));\n    d = max(d,-sdBox(p-vec3(0,9.5,0),vec3(15,4,9)));\n    \n    return d*.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialization\n    float T = texelFetch(iChannel0, ivec2(6, 0), 0).r;         // Camera mode\n    vec3 rd = texelFetch(iChannel0, ivec2(fragCoord), 0).gba;  // ray direction\n    vec3 ro = texelFetch(iChannel0, ivec2(1.-T, 0), 0).gba;    // ray origin\n\n    const float MAX_DIST = 30.;\n    float t = 0.; // total distance travelled\n    float i; // Number of steps\n    float d = MAX_DIST; // Distance to our scene\n    vec3 p; // Current point in space\n    \n    // Raymarching\n    for (i = 0.; i < 100. && d > 0.001 && t < MAX_DIST; i++) {\n        p = ro + rd * t;\n        d = map(p);\n        t += d;\n    }\n\n    // Coloring\n    vec3 col = vec3(i * .02); // color based on number of steps\n    \n    fragColor = vec4(col,1.0);\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Concept of storing keyboard-modified data in a buffer came from Assossa\n// https://www.shadertoy.com/view/ltsyRS\n\n/* This buffer stores the ray direction and ray origin for the camera in 2 different modes\n * 1. Free-cam (or 1st-person) has the camera rotate in place\n * 2. Arcball (or 3rd-person) has the camera rotate around (and always look at) a central point\n * Most of the pixels will store the ray direction, since that's different per-pixel\n * but we need to reserve 2 pixels to store data for the camera position for each mode.\n * I put these at the bottom right for minimum visual disturbance in the final scene.\n \n * CONTROLS:\n * \"W\" - Move the camera forward along its direction vector.\n * \"S\" - Move the camera backward along its direction vector.\n * UP ARROW - Increase the azimuthal angle of the camera. Capped at 89.9 degrees.\n * DOWN ARROW - Decrease the azimuthal angle of the camera. Capped at -89.9 degrees.\n * RIGHT ARROW - Increase the polar angle of the camera.\n * LEFT ARROW - Decrease the polar angle of the camera.\n * \"T\" - Toggle between the camera modes.\n * \"R\" - Reset the camera angle/position for the current camera mode.\n \n * NOTE: There is a 1-frame delay with some of the position calculations, since they rely on reading the previous\n *       frame's theta/phi calculations.\n *       There's probably a way to keep the code efficient (i.e. not do the angle calculations for every pixel)\n *       while still keeping it without the delay, but I think there would still be some duplicated calculations\n *       (since the pixels I need to store and use the data differ), and the effect usually isn't noticable unless\n *       the scene is paused. (The most obvious delay is when resetting the position/angle of the camera. The position\n *       of the camera is reset the frame before the angle is reset.)\n *       I could also fix this by reading the angle/radius data in the main loop after everything is written and calculate\n *       position/direction from there, but then I'd need to define the rotateVector method there, and that would be more\n *       places to copy/paste stuff if I want this in other projects. As it is, I can just copy this file and wire up the\n *       buffers, then the only change I need from the \"standard\" ray marching setup is to read position/direction from\n *       the buffer, instead of calculating uv and defining them there.\n *\n * FUTURE WORK: I'd like to exchange the arrow key control for mouse control, where camera orientation changes\n *              as the mouse moves across the canvas. It shouldn't be too difficult, but I didn't want to lump\n *              it in with this project.\n *              I'd also like to iron out some of the lag issues (especially with pressing \"R\").\n */\n \n \n \n /* Feel free to use this buffer in your own projects with appropriate credits. */\n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_W     = 87;\nconst int KEY_S     = 83;\nconst int KEY_R     = 82;\nconst int KEY_T     = 84;\n\nconst float rotateSpeed = 100.0;\nconst float zoomSpeed = 20.0;\n\n// Offset along the negative z-axis for initial camera position.\n// Also dictates minumum radius for the arcball camera.\nconst float STARTING_CAMERA_DIST = 3.;\n\nvec3 rotateVector(vec3 v, float theta, float phi) {\n    float thetaRad = -radians(theta); // Convert to radians (really just a scaling factor to limit the rotation speed)\n    float phiRad = radians(phi);     // Convert to radians (really just a scaling factor to limit the rotation speed)\n\n    // Rotation matrix around the Y-axis\n    mat3 R_y = mat3(\n        cos(thetaRad), 0, sin(thetaRad),\n        0, 1, 0,\n        -sin(thetaRad), 0, cos(thetaRad)\n    );\n\n    // Rotation matrix around the X-axis\n    mat3 R_x = mat3(\n        1, 0, 0,\n        0, cos(phiRad), -sin(phiRad),\n        0, sin(phiRad), cos(phiRad)\n    );\n\n    // Combined rotation matrix\n    mat3 R = R_y * R_x;\n\n    // Apply rotation to vector\n    return R * v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Read data from the previous frame\n    float tf = texelFetch(iChannel0, ivec2(2, 0), 0).r; // Theta (free-cam)\n    float pf = texelFetch(iChannel0, ivec2(3, 0), 0).r; // Phi (free-cam)\n    float ta = texelFetch(iChannel0, ivec2(4, 0), 0).r; // Theta (arcball)\n    float pa = texelFetch(iChannel0, ivec2(5, 0), 0).r; // Phi (free-cam)\n\n    float t = texelFetch(iChannel1, ivec2(KEY_T, 2), 0).r; // Camera mode\n    // t = 1.-t; // Uncomment this line to switch the starting camera mode on first load. Default is free-cam mode.\n\n    float theta = (tf*(1.-t))+(ta*t); // Theta for current camera mode\n    float phi   = (pf*(1.-t))+(pa*t); // Phi for current camera mode\n    \n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 currentPosition = rotateVector(rd, (1.-2.*t)*theta, (1.-2.*t)*phi); // Ray direction (sometimes ray origin)\n    float outData = 0.0; // Theta, phi, or radius\n    \n    // Store position data at coordinates (0 through 6, 0) of the buffer.\n    if (int(fragCoord.y) == 0){\n        // Read data from the previous frame\n        float rad = texelFetch(iChannel0, ivec2(0, 0), 0).r; // Arcball radius/position\n        vec3 fp = texelFetch(iChannel0, ivec2(1, 0), 0).gba; // Free-cam position\n        \n        float r = texelFetch(iChannel1, ivec2(KEY_R, 1), 0).r; // If we need to reset the position/rotation\n        \n        // Calculate camera angle and position based on keyboard presses\n        switch(int(fragCoord.x)) {\n            case 0:\n                // Radius (arcball)\n                outData = (1.-r*t)*(rad +\n                    t*((iTimeDelta * zoomSpeed) * texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r -\n                    (iTimeDelta * zoomSpeed) * texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r));\n                outData = max(outData, 0.); // Take max to prevent camera from passing through origin\n\n                // Position (arcball)\n                currentPosition = rotateVector(vec3(0, 0, -1), -theta, -phi)*(outData+STARTING_CAMERA_DIST);\n\n                break;\n            case 1:\n                // Position (free-cam)\n                currentPosition = fp + (1.-t)*(rotateVector(vec3(0.,0.,1.), theta, phi)*zoomSpeed/2.*\n                                     ((iTimeDelta) * texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r -\n                                      (iTimeDelta) * texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r));                      \n                                \n                if (r==1. && t==0.) { // Reset position if 'R' is pressed\n                    currentPosition = vec3(0,0,-STARTING_CAMERA_DIST);\n                }\n                \n                break;\n            case 2:\n                // Theta (freecam)\n                outData = (1.-r*(1.-t))*(tf +\n                    ((iTimeDelta * rotateSpeed) * texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r -\n                    (iTimeDelta * rotateSpeed) * texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r) * (1.-t));\n                break;\n\n            case 3:\n                // Phi (freecam)\n                outData = (1.-r*(1.-t))*(pf +\n                    ((iTimeDelta * rotateSpeed) * texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r -\n                    (iTimeDelta * rotateSpeed) * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r) * (1.-t));\n                outData = clamp(outData, -89.9, 89.9); // Used for camera angle, clamp to prevent camera from going upside-down\n                break;\n            case 4:\n                // Theta (arcball)\n                outData = (1.-r*t)*(ta +\n                    ((iTimeDelta * rotateSpeed) * texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r -\n                    (iTimeDelta * rotateSpeed) * texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r) * t);\n                break;\n            case 5:\n                // Phi (arcball)\n                outData = (1.-r*t)*(pa +\n                    ((iTimeDelta * rotateSpeed) * texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r -\n                    (iTimeDelta * rotateSpeed) * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r) * t);\n                outData = clamp(outData, -89.9, 89.9); // Used for camera angle, clamp to prevent camera from going upside-down\n                break;\n            case 6:\n                // State of the \"T\" key for keeping track of camera mode\n                outData = t;\n                break;\n        }\n    }\n    \n    // outData is theta, phi, or radius.\n    // currentPosition is ray direction or ray origin.\n    fragColor = vec4(outData, currentPosition);\n}","name":"Buffer A","description":"","type":"buffer"}]}