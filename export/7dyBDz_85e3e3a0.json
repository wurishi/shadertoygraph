{"ver":"0.1","info":{"id":"7dyBDz","date":"1657980224","viewed":97,"name":"Quintic solvers","username":"Envy24","description":"Based on this shader: https://www.shadertoy.com/view/fsB3Wt\nFormulas for factoring terms: https://www.desmos.com/calculator/uh9mtw2wiw\n\nOther implementation:\nhttps://www.shadertoy.com/view/Nd23Dt","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","newton","quintic","raphson","halley","numeric","secant","regulafalsi"],"hasliked":0,"parentid":"ssKfRD","parentname":"Quartic solvers"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  6.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat quintic(vec2 NDC, float a, float b, float c, float d, float e, float f)\n{\n    float df   = NDC.y - (((((a * NDC.x + b) * NDC.x + c) * NDC.x + d) * NDC.x + e) * NDC.x + f),\n          dfdx = (((5.0 * a * NDC.x + 4.0 * b) * NDC.x + 3.0 * c) * NDC.x + 2.0 * d) * NDC.x + e;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            2.*TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5)) :\n            2.*TO_CENTERED_NDC(SC);\n\n    //float a = -0.8, b = -1.4, c = 0.8, d = 0.0, e = -1.0, f = -1.0;\n    /* Quintic */\n    float a = sinOSC(-1.25, 1.25, iTime * 0.15), b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17), f = sinOSC( -1.0,  1.0, iTime * 0.07);\n    /* Quartic *\n    float a =                               0.0, b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17), f = sinOSC( -1.0,  1.0, iTime * 0.07);\n    /* Cubic *\n    float a =                               0.0, b =                               0.0, \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17), f = sinOSC( -1.0,  1.0, iTime * 0.07);\n    /* Quadratic *\n    float a =                               0.0, b =                               0.0, \n          c =                               0.0, d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17), f = sinOSC( -1.0,  1.0, iTime * 0.07);\n    /* Linear *\n    float a =                               0.0, b =                               0.0,\n          c =                               0.0, d =                               0.0,\n          e = sinOSC( -1.0,  1.0, iTime * 0.17), f = sinOSC( -1.0,  1.0, iTime * 0.07);\n    /* Identity 0 == 0 *\n    float a =                               0.0, b =                              0.0,\n          c =                               0.0, d =                              0.0,\n          e =                               0.0, f =                              0.0;\n    /**/\n\n    // Cauchy's roots bounds (only for quintic).\n    float upper_bound = max(0.0, 1.0 + max(-a/a, max(-b/a, max(-c/a, max(-d/a, max(-e/a, -f/a)))))),\n          lower_bound = max(0.0, 1.0 + max( a/a, max( b/a, max( c/a, max( d/a, max( e/a,  f/a))))));\n\n    vec3 color = (NDC.x <= upper_bound && NDC.x >= -lower_bound) ? vec3(.9,.9,.9) : vec3(1.);\n         color -= quintic(NDC, a, b, c, d, e, f);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    vec2 roots[5]; float coef[6] = float[6]( a, b, c, d, e, f );\n      \n    // One numeric, four analytic roots solver.\n    int num = solve5_14(roots, coef);\n    \n    // Two numeric, three analytic roots solver.\n    //int num = solve5_23(roots, coef);\n\n    for (int r=0; r < num; ++r) \n    {\n        float x = roots[r].x;\n        color = mix(color, vec3(1, 0, 0), SM(diskSDF_L2(NDC, vec2(x, 0.0), 0.03)));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n/*\n    Return value:\n        0 - no roots when A==0, B==0, C==0;\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicForReal(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float inv = 1.0 / coef[0];\n    float a = coef[1] * inv;\n    float b = coef[2] * inv;\n    float c = coef[3] * inv;\n\n    float Q = (a * a - 3.0 * b) / 9.0;\n    float R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n\n        roots[0].x = -2.0 * sign(R) * sqrt(Q) * cosh(phi) - a * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n\n        roots[0].x = -2.0 * sign(R) * sqrt(abs(Q)) * sinh(phi) - a * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        roots[0].x = -pow(c - a * a * a / 27.0, oneThird) - a * oneThird; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    float Re = sign(R) * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n\n/*\n     Returns number of real roots.       \n*/\nint solveQuartic(\n    inout vec2 roots[4],\n    in float coef[5])\n{\n    float invA = 1.0 / coef[0];\n    float B = coef[1] * invA;\n    float C = coef[2] * invA;\n    float D = coef[3] * invA;\n    float E = coef[4] * invA;\n\n    float coef_[4] = float[4](\n        1.,\n        -C,\n        D * B - 4. * E,\n        -(D * D + E * B * B - 4. * E * C)\n    );\n    vec2 roots_[3];\n\n    int num = solveCubicForReal(roots_, coef_);\n\n    float u = 0.0;\n    float D0 = -1.0;\n    float D1 = -1.0;\n\n    if (num == 3)\n    {\n        u = roots_[2].x;\n\n        D0 = B * B * 0.25 + u - C;\n        D1 = u * u * 0.25 - E;\n    }\n    else\n    {\n        u = roots_[0].x;\n        D0 = B * B * 0.25 + u - C;\n        D1 = u * u * 0.25 - E;\n    }   \n\n    D0 = sqrt(D0); D1 = sqrt(D1);\n\n    float p0 = B * 0.5 + D0, p1 = B * 0.5 - D0,\n          q0 = u * 0.5 + D1, q1 = u * 0.5 - D1;\n    \n    // This line may cause problems (try other tresholds).\n    if (abs(p0 * q1 + p1 * q0 - D) > 1e-3)\n    {\n        float t = q0; q0 = q1; q1 = t;\n    } \n\n    vec2 r_[2];\n    float c_[3] = float[3]( 1.0, p0, q0 );\n\n    num = solveQuadraticForReal(r_, c_);\n\n    int wIdx = \n        num == 0 ? \n            2 : 0;\n\n    roots[wIdx] = r_[0]; roots[wIdx + 1] = r_[1];\n\n    wIdx = \n        num == 0 ? \n        0 : 2;\n\n    c_[1] = p1; c_[2] = q1;\n\n    int n = solveQuadraticForReal(r_, c_);\n\n    roots[wIdx] = r_[0]; roots[wIdx + 1] = r_[1];\n\n    num = num == 1 ? 2 : num;\n\n    return\n        n == 1 ? \n            num + 2 :\n            num + n;\n}\n\n/* Numeric solvers. */\nfloat findQuinticRootNewtonRaphson(\n    float x, float a, float b, float c, float d, float e, float f)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float dfdx = (((5. * a * x + 4. * b) * x + 3. * c) * x + 2. * d) * x + e;\n    bool quit = abs(dfdx) <= EPSILON;\n    \n    for (int i = 0; (i < 12) && (quit == false); ++i)\n    {\n        float y = ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n        x -= y / dfdx;          \n        dfdx = (((5. * a * x + 4. * b) * x + 3. * c) * x + 2. * d) * x + e;\n        quit = (abs(y) <= tolerance) || (abs(dfdx) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuarticRootNewtonRaphson(\n    float x, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float dfdx = ((4.0 * a * x + 3.0 * b) * x + 2.0 * c) * x + d;\n    bool quit = abs(dfdx) <= EPSILON;\n    \n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        float f = (((a * x + b) * x + c) * x + d) * x + e;\n        x -= f / dfdx;          \n        dfdx = ((4.0 * a * x + 3.0 * b) * x + 2.0 * c) * x + d;\n        quit = (abs(f) <= tolerance) || (abs(dfdx) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuinticRootSecant(\n    float x, float a, float b, float c, float d, float e, float f)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n\n    float x_p = x;\n    float f_p = ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n          x = x_p - (f_p / ((((5. * a * x + 4. * b) * x + 3. * c) * x + 2. * d) * x + e));\n\n    bool quit = false;\n\n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {\n        float y = ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n        float df = y - f_p; f_p = y;\n        float dx = x - x_p; x_p = x;\n\n        x -= y / (df / dx);\n\n        quit = (abs(y) <= tolerance) || (abs(dx) <= EPSILON || (abs(df) <= EPSILON));         \n    }\n\n    return x;\n}\nfloat findQuarticRootSecant(\n    float x, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n\n    float x_p = x;\n    float f_p = (((a * x + b) * x + c) * x + d) * x + e;\n          x = x_p - (f_p / (((4.0 * a * x + 3.0 * b) * x + 2.0 * c) * x + d));\n\n    bool quit = false;\n\n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {\n        float f = (((a * x + b) * x + c) * x + d) * x + e;\n        float df = f - f_p; f_p = f;\n        float dx = x - x_p; x_p = x;\n\n        x -= f / (df / dx);\n\n        quit = (abs(f) <= tolerance) || (abs(dx) <= EPSILON || (abs(df) <= EPSILON));         \n    }\n\n    return x;\n}\nfloat findQuinticRootHalley(\n    float x, float a, float b, float c, float d, float e, float f)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float y = ((((a * x + b) * x + c) * x + d) * x + e) * x + f,\n          dfdx = (((5. * a * x + 4. * b) * x + 3. * c) * x + 2. * d) * x + e,\n          ddfddx = ((20. * a * x + 12. * b) * x + 6. * c) * x + 2. * d,\n          denom = 2.*dfdx*dfdx - y * ddfddx;\n          \n    bool quit = abs(denom) <= EPSILON;\n    \n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {       \n        x -= (2.*y*dfdx) / denom;\n        \n        y = ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n        dfdx = (((5. * a * x + 4. * b) * x + 3. * c) * x + 2. * d) * x + e,\n        ddfddx = ((20. * a * x + 12. * b) * x + 6. * c) * x + 2. * d,\n        denom = 2.*dfdx*dfdx - y * ddfddx;\n        \n        quit = (abs(y) <= tolerance) || (abs(denom) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuarticRootHalley(\n    float x, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float f = (((a * x + b) * x + c) * x + d) * x + e,\n          dfdx = ((4. * a * x + 3. * b) * x + 2. * c) * x + d,\n          ddfddx = (12. * a * x + 6. * b) * x + 2. * c,\n          denom = 2.*dfdx*dfdx - f * ddfddx;\n          \n    bool quit = abs(denom) <= EPSILON;\n    \n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {       \n        x -= (2.*f*dfdx) / denom;\n        \n        f = (((a * x + b) * x + c) * x + d) * x + e;\n        dfdx = ((4. * a * x + 3. * b) * x + 2. * c) * x + d;\n        ddfddx = (12. * a * x + 6. * b) * x + 2. * c;\n        denom = 2.*dfdx*dfdx - f * ddfddx;\n        \n        quit = (abs(f) <= tolerance) || (abs(denom) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuinticRootBisection(\n    float xl, float xr, float a, float b, float c, float d, float e, float f)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        ((((a * xl + b) * xl + c) * xl + d) * xl + e) * xl + f,  // f(xl)\n        ((((a * xr + b) * xr + c) * xr + d) * xr + e) * xr + f); // f(xr)\n        \n    float y = 0.5;\n        \n    for (int i = 0; (i < 12) && (abs(y) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float x = (X[0] + X[1]) * 0.5;\n              y = ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n\n        int w_idx = int(sign(F[0]) != sign(y));\n        \n        F[w_idx] = y; X[w_idx] = x;\n    }\n\n    return (X[0] + X[1]) * 0.5;\n}\nfloat findQuarticRootBisection(\n    float xl, float xr, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (((a * xl + b) * xl + c) * xl + d) * xl + e,  // f(xl)\n        (((a * xr + b) * xr + c) * xr + d) * xr + e); // f(xr)\n        \n    float f = 0.5;\n        \n    for (int i = 0; (i < 24) && (abs(f) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float x = X[0] + (X[1] - X[0]) * 0.5;\n              f = (((a * x + b) * x + c) * x + d) * x + e;\n\n        int w_idx = int(sign(F[0]) != sign(f));\n        \n        F[w_idx] = f; X[w_idx] = x;\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\nfloat findQuinticRootHybrid(\n    float xl, float xr, float a, float b, float c, float d, float e, float f)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        ((((a * xl + b) * xl + c) * xl + d) * xl + e) * xl + f,  // f(xl)\n        ((((a * xr + b) * xr + c) * xr + d) * xr + e) * xr + f); // f(xr)\n        \n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        float x = (X[0] * F[1] - X[1] * F[0]) / (F[1] - F[0]);\n        float y = ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n    \n        int w_idx = int(abs(f - F[0]) < abs(y - F[1]));\n\n        F[w_idx] = y; X[w_idx] = x;\n\n        quit = (abs(y) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\nfloat findQuarticRootHybrid(\n    float xl, float xr, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (((a * xl + b) * xl + c) * xl + d) * xl + e,  // f(xl)\n        (((a * xr + b) * xr + c) * xr + d) * xr + e); // f(xr)\n        \n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        float x = (X[0] * F[1] - X[1] * F[0]) / (F[1] - F[0]);\n        float f = (((a * x + b) * x + c) * x + d) * x + e;\n    \n        int w_idx = int(abs(f - F[0]) < abs(f - F[1]));\n\n        F[w_idx] = f; X[w_idx] = x;\n\n        quit = (abs(f) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\nfloat findQunticRootRegulaFalsi(\n    float xl, float xr, float a, float b, float c, float d, float e, float f)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        ((((a * xl + b) * xl + c) * xl + d) * xl + e) * xl + f,   // f(xl)\n        ((((a * xr + b) * xr + c) * xr + d) * xr + e) * xr + f ); // f(xr)\n\n    float x = 0.0, y = 0.0;\n\n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        x = X[0] -  F[0] * ((X[1] - X[0]) / (F[1] - F[0]));\n        y = ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n\n        int w_idx = int(y * F[1] > 0.);\n\n        F[w_idx] = y; X[w_idx] = x;\n\n        quit = (abs(y) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuarticRootRegulaFalsi(\n    float xl, float xr, float a, float b, float c, float d, float e)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        (((a * xl + b) * xl + c) * xl + d) * xl + e,   // f(xl)\n        (((a * xr + b) * xr + c) * xr + d) * xr + e ); // f(xr)\n\n    float x = 0.0, f = 0.0;\n\n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        x = X[0] -  F[0] * ((X[1] - X[0]) / (F[1] - F[0]));\n        f = (((a * x + b) * x + c) * x + d) * x + e;\n\n        int w_idx = int(f * F[1] > 0.);\n\n        F[w_idx] = f; X[w_idx] = x;\n\n        quit = (abs(f) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return x;\n}\n\n/* \n    Returns number of real roots.       \n*/\nint solve5_14(\n    inout vec2[5] roots,\n    in float[6] coef)\n{\n    // Quintic equation?\n    if (coef[0] != 0.0)\n    {\n        float x = findQuinticRootBisection(-8.1, 8.0, coef[0], coef[1], coef[2], coef[3], coef[4], coef[5]);\n              x = findQuinticRootNewtonRaphson(x, coef[0], coef[1], coef[2], coef[3], coef[4], coef[5]);\n    \n        roots[0].x = x;\n\n        // Convert equation to form: (x-r0)(axxxx+bxxx+cxx+dx+e)=0\n        vec2 roots_[4];\n        float coef_[5] = float[5](\n            coef[0],\n            coef[1] + x * coef[0],\n            coef[2] + x * (coef[1] + x * coef[0]),\n            coef[3] + x * (coef[2] + x * (coef[1] + x * coef[0])),\n            coef[4] + x * (coef[3] + x * (coef[2] + x * (coef[1] + x * coef[0])))\n        );\n\n        int num = solveQuartic(roots_, coef_);\n\n        roots[1] = roots_[0]; roots[2] = roots_[1]; roots[3] = roots_[2]; roots[4] = roots_[3];\n\n        return num + 1;\n    }\n    \n    // Quartic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[4];\n        float coef_[5] = float[5](\n            coef[1], coef[2], coef[3], coef[4], coef[5]\n        );\n\n        int num = solveQuartic(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2]; roots[3] = roots_[3];\n        \n        return num;\n    }\n    \n    // Cubic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[2], coef[3], coef[4], coef[5]\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[3] != 0.0)\n    {\n        vec2 roots_[2];\n        float coef_[3] = float[3](\n            coef[3], coef[4], coef[5]\n        );\n\n        int num = solveQuadraticForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[4] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[5]/coef[4]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (coef[5] == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    /**/\n    \n    return 0;\n}\n\n/*  Unstable.\n    Returns number of real roots.       \n*/\nint solve5_23(\n    inout vec2[5] roots,\n    in float[6] coef)\n{\n    // Quintic equation?\n    if (coef[0] != 0.0)\n    {         \n        float x = findQuinticRootBisection(-8.1, 8.0, coef[0], coef[1], coef[2], coef[3], coef[4], coef[5]);\n              x = findQuinticRootNewtonRaphson(x, coef[0], coef[1], coef[2], coef[3], coef[4], coef[5]);\n    \n        roots[0].x = x;\n            \n        coef[4] = coef[4] + coef[3] * x + coef[2] * x * x + coef[1] * x * x * x + coef[0] * x * x * x * x;\n        coef[3] = coef[3] + coef[2] * x + coef[1] * x * x + coef[0] * x * x * x;\n        coef[2] = coef[2] + coef[1] * x + coef[0] * x * x;\n        coef[1] = coef[1] + coef[0] * x;\n        //coef[0] = coef[0];\n        \n        //x = findQuarticRootHalley(0.01, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        x = findQuarticRootBisection(-8.0, 1.0, coef[0], coef[1], coef[2], coef[3], coef[4]);\n        //x = findQuarticRootHybrid(-10.0, 1., coef[0], coef[1], coef[2], coef[3], coef[4]);\n        x = findQuarticRootNewtonRaphson(x, coef[0], coef[1], coef[2], coef[3], coef[4]);\n\n        // No real roots?\n        float eps = 1e-4;\n        if ( abs((((coef[0] * x + coef[1]) * x + coef[2]) * x + coef[3]) * x + coef[4]) > eps ) \n        { \n            x = findQuarticRootBisection(-1.0, 8.0, coef[0], coef[1], coef[2], coef[3], coef[4]);\n            //x = findQuarticRootRegulaFalsi(-1., 10., coef[0], coef[1], coef[2], coef[3], coef[4]);\n            x = findQuarticRootNewtonRaphson(-x, coef[0], coef[1], coef[2], coef[3], coef[4]);\n                  \n            // Still no real roots?\n            if ( abs((((coef[0] * x + coef[1]) * x + coef[2]) * x + coef[3]) * x + coef[4]) > eps ) { return 1; }\n        }\n\n        roots[1].x = x;\n\n        // Convert equation to form: (x-r0)(axxx+bxx+cx+d)=0\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[0],\n            coef[1] + coef[0] * x,\n            coef[2] + coef[1] * x + coef[0] * x * x,\n            coef[3] + coef[2] * x + coef[1] * x * x + coef[0] * x * x * x\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[2] = roots_[0]; roots[3] = roots_[1]; roots[4] = roots_[2];\n\n        return num + 2;\n    }\n    \n    // Quartic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[4];\n        float coef_[5] = float[5](\n            coef[1], coef[2], coef[3], coef[4], coef[5]\n        );\n\n        int num = solveQuartic(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2]; roots[3] = roots_[3];\n        \n        return num;\n    }\n    \n    // Cubic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[2], coef[3], coef[4], coef[5]\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[3] != 0.0)\n    {\n        vec2 roots_[2];\n        float coef_[3] = float[3](\n            coef[3], coef[4], coef[5]\n        );\n\n        int num = solveQuadraticForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[4] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[5]/coef[4]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (coef[5] == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    /**/\n    \n    return 0;\n}","name":"Common","description":"","type":"common"}]}