{"ver":"0.1","info":{"id":"4dGBDG","date":"1530122567","viewed":126,"name":"Voronoi Reflection","username":"nr4","description":"Some geometry tricks with voronoi distances","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Voronoi Reflection\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float pi = acos(-1.);\nconst vec2 c = vec2(1., 0.);\n\n#define rand(a0) fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453)\n\nmat3 rot(vec3 p)\n{\n    return mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\nfloat norm(vec2 x)\n{\n    return length(x);\n}\n\n/* compute voronoi distance and closest point.\n * x: coordinate\n * return value: vec3(distance, coordinate of control point)\n */\nvec3 vor(vec2 x)\n{\n    vec2 y = floor(x);\n   \tfloat ret = 1.;\n    \n    //find closest control point. (\"In which cell am I?\")\n    vec2 pf=c.yy, p;\n    float df=10., d;\n    \n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = y + vec2(float(i), float(j));\n            p += rand(p);\n            \n            d = norm(x-p);\n            \n            if(d < df)\n            {\n                df = d;\n                pf = p;\n            }\n        }\n    \n    //compute voronoi distance: minimum distance to any edge\n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = y + vec2(float(i), float(j));\n            p += rand(p);\n            \n            vec2 o = p - pf;\n            d = norm(.5*o-dot(x-pf, o)/dot(o,o)*o);\n            ret = min(ret, d);\n        }\n    \n    return vec3(ret, pf);\n}\n\nvec2 scene(vec3 x)\n{\n    x = rot(5.e-1*iTime*c.yyx)*x-c.yxy;\n    \n    vec3 w = vor(6.*x.xy),\n    \tv = vor(6.*x.xy)+.3*vor(12.*x.xy)+.1*vor(24.*x.xy);\n    \n    return vec2(min(abs(length(2.+1.*2.1+(rot(3.e-1*vec3(1.4,1.5,2.)*iTime)*x.xyy).xy-.2)-5.), \n                    1./length(x)*abs(x.x))-2.4-.05*v.x-.1+abs(x.z), rand(w.yz));\n}\n\nconst float dx = 1.e-5;\nvec3 normal(vec3 x)\n{\n    float s = scene(x).x;\n    return normalize(vec3(\n        scene(x+dx*c.xyy).x-s, \n        scene(x+dx*c.yxy).x-s, \n        scene(x+dx*c.yyx).x-s\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5, s = c.yy;\n    \n    //raymarching\n    vec3 o = 3.*c.yyx, t = 2.*c.yxy, d = normalize(t-o), r = c.xyy, u = cross(d, r), x = c.yyy, \n        ro = o + uv.x * r + uv.y * u;\n    \n    float depth = 0.;\n    \n    for(int i=0; i<100; ++i)\n    {\n        x = ro + depth * d;\n        s = scene(x);\n        if(s.x < 1.e-4) break;\n        if(depth > 1000.) \n        {\n\t\t\tfragColor = c.yyyx;\n            return;\n        }\n        depth += s.x;\n    }\n    \n    //colorize\n    vec3 n = normal(x), l = c.xxx, re = normalize(reflect(-l, n)), v = normalize(x-ro),\n        col;\n    if(s.y == 1.)\n        col = .3*c.xyy+.3*c.xyy*dot(l,n)+.7*c.xxy*pow(abs(dot(re,v)), 4.);\n\telse\n    \tcol = .1*c.yyx+.1*c.yyx*dot(l,n)+c.yxx*pow(abs(dot(re,v)), 4.);\n\n    col = abs(.7*rot(vec3(1.1,1.2,1.3)*iTime+s.y)*col);\n        \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}