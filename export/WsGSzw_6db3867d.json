{"ver":"0.1","info":{"id":"WsGSzw","date":"1573582487","viewed":101,"name":"Oban Racers","username":"sametaylak","description":"Oban Racers","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["oban","racers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat cylinder(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n\tvec3 ap = abs(p) - s;\n    return length(max(vec3(0.0), ap)) + min(0.0, max(ap.x, max(ap.y, ap.z)));\n}\n\nfloat roundBox(vec3 p, vec3 s, float r)\n{\n  vec3 rb = abs(p) - s;\n  return length(max(rb, 0.0)) + min(max(rb.x, max(rb.y, rb.z)), 0.0) - r;\n}\n\nmat2 rot(float a)\n{\n\tfloat ca = cos(a);\n    float sa = sin(a);\n\treturn mat2(ca, sa, -sa, ca);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\n\nfloat ship(vec3 p) {\n    float s = sphere(p, 0.4);\n    float b = max(cylinder(p.yz + vec2(0.1, 0.0), 0.2), abs(p.x) - 0.8);\n    float d = min(s, b);\n    \n    float s2 = sphere(p + vec3(1.0, 0.1, 0.0), 0.3);\n    float s3 = sphere(p + vec3(-1.0, 0.1, 0.0), 0.3);\n    \n    float sideSpheres = min(s2, s3);\n    d = min(d, sideSpheres);\n\n    float c1 = roundBox(p + vec3(1.0, 0.1, -0.8), vec3(0.11, 0.1, 0.8), 0.075);\n    float c2 = roundBox(p + vec3(1.0, -0.10, -1.2), vec3(0.1, 0.3, 0.4), 0.075);\n    d = min(d, smin(c1, c2, 0.01));\n    \n    float c3 = roundBox(p + vec3(-1.0, 0.1, -0.8), vec3(0.11, 0.1, 0.8), 0.075);\n    float c4 = roundBox(p + vec3(-1.0, -0.10, -1.2), vec3(0.1, 0.3, 0.4), 0.075);\n    d = min(d, smin(c3, c4, 0.01));\n    \n    return d;\n}\n\nvec3 tunnel(vec3 p) {\n\tvec3 off = vec3(0.0);\n    off.x += sin(p.z * 0.3);\n    off.y += cos(p.z * 0.5) * 0.1;\n    return off;\n}\n\nfloat map(in vec3 p)\n{\n    p += tunnel(p);\n\n    vec3 p1 = p;\n    float m = iTime * 4.0;\n    p1.z -= m;\n    \n    p1.zy *= rot(0.1);\n    float t = clamp(sin(-p.z * 0.3), -1.0, 1.0) * 0.35;\n   \tp1.yx *= mat2(1.0, t, -t, 1.0);\n    float s = ship(p1);\n\n    \n    vec3 bp = p;\n    bp.z = fract(bp.z / 2.0 - 0.5) - 0.5;\n    float bPlane = box(bp + vec3(0.0, -0.75, 0.0), vec3(2.0, 0.2, 1.0));\n    \n    vec3 sp = p;\n    sp.xy *= rot(1.0);\n    sp.z = fract(sp.z / 0.0 - 0.5);\n    float rPlane = box(sp + vec3(1.4, -2.0, 1.0), vec3(1.0, 0.2, 1.0));\n    \n    vec3 sp2 = p;\n    sp2.yx *= rot(1.0);\n    sp2.z = fract(sp2.z / 0.0 - 0.5);\n    float lPlane = box(sp2 + vec3(-1.4, -2.0, 1.0), vec3(1.0, 0.2, 1.0));\n    \n    return min(s, min(bPlane, min(rPlane, lPlane)));\n}\n\nvec3 norm(vec3 p)\n{\n\tvec2 off = vec2(0.01, 0.0);\n    return normalize(map(p) - vec3(map(p - off.xyy), map(p - off.yxy), map(p - off.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.0);\n    \n    vec3 s = vec3(0.0, -2.0, -4.0);\n    vec3 t = vec3(0.0, 0.0, 3.0);\n    \n    float m = iTime * 4.0;\n    s.z += m;\n    t.z += m;\n    \n    s -= tunnel(s);\n    vec3 offT = tunnel(t);\n    t -= offT;\n    \n    vec3 cz = normalize(t - s);\n    vec3 cx = normalize(cross(cz, vec3(0.0, 1.0, 0.0) - offT * 0.2));\n    vec3 cy = normalize(cross(cz, cx));\n    \n    vec3 r = normalize(cx * uv.x + cy * uv.y + cz);\n    \n    vec3 col = vec3(0.0);\n    vec3 l = normalize(vec3(0.0, -1.0, 0.0));\n    \n    vec3 p = s;\n    for(int i = 0; i < 100; ++i)\n    {\n    \tfloat d = map(p);\n        if(d < 0.001) {\n            vec3 n = norm(p);\n            float f = pow(1.0 - dot(n, -r), 1.0);\n            col += max(0.0, dot(n, l));\n        \n            break;\n        }\n        if(d > 100.0) break;\n        p += d * r;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}