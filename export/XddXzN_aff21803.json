{"ver":"0.1","info":{"id":"XddXzN","date":"1458300912","viewed":439,"name":"progressive soft reflections","username":"public_int_i","description":"progressive soft reflections.","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["reflection","ray","soft","march","progressive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = pow(texture(iChannel0,fragCoord/iResolution.xy)/10., vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ethan Shulman/public_int_i 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//thanks to iq for the great tutorials, code and information\n\n\n\n\n#define FOV_SCALE 1.3\n#define ITERATIONS 128\n#define SHADOW_ITERATIONS 24\n#define REFLECTION_ITERATIONS 84\n#define EPSILON .0008\n#define NORMAL_EPSILON .0004\n#define VIEW_DISTANCE 2.\n#define pi 3.141592\n\n\n\nvec3 cameraLocation;\nvec2 cameraRotation;\n\n\nstruct material {\n    vec3 diffuse,specular,emissive;\n    float metallic,roughness;\n};\nstruct light {\n    vec3 position, color;\n    float size;\n};\n    \nconst vec3 ambient = vec3(0.35);\n\n\n#define nLights 1\n\n#if nLights != 0\nlight lights[nLights];\n#endif    \n\nvoid initLights() {\n    #if nLights != 0\n    lights[0] = light(vec3(30.,100.,-10.),\n                      vec3(1.,.7,.85),\n                      1000.);\n\t#endif\n}\n\n\n//distance functions from iq's site\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//random ray in a hemisphere relative to d, uses p as a seed\nvec3 randomHemiRay(in vec3 d, in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\nvec2 df(in vec3 rp) {\n    #define dc(d,i) {float db = d;if(db<dr.x) {dr=vec2(db,i);}}\n    \n    vec2 dr = vec2(rp.y,0.);//ground\n   \tdc(udBox(rp-vec3(0.,0.,.2),vec3(2.,.3,.01)),1.);//wall\n    \n    vec3 slp = vec3(mod(abs(rp.x),.3)-.15,rp.y-.1,rp.z);\n    dc(max(abs(rp.x)-.6, length(slp)-.1),2.);//spheres\n    \n    return dr;\n}\nvec2 df_hq(in vec3 rp) {\n\treturn df(rp);\n}\n\n\n\nconst vec3 ne = vec3(NORMAL_EPSILON,0.,0.);\nvec3 normal2(in vec3 rp) {\n    return normalize(vec3(df(rp+ne).x-df(rp-ne).x,\n                          df(rp+ne.yxz).x-df(rp-ne.yxz).x,\n                          df(rp+ne.yzx).x-df(rp-ne.yzx).x));\n}\n\n\nvec3 normal(in vec3 rp) {\n    return normalize(vec3(df_hq(rp+ne).x-df_hq(rp-ne).x,\n                          df_hq(rp+ne.yxz).x-df_hq(rp-ne.yxz).x,\n                          df_hq(rp+ne.yzx).x-df_hq(rp-ne.yzx).x));\n}\n\n\nmaterial mat(vec3 rp) {\n    vec2 dr = df(rp);\n    \n    if (dr.y < 1.) {\n        //ground material\n\t\treturn material(vec3(.74,.79,.85), //diffuse\n                     vec3(.79,.82,.96), //specular\n                  \t vec3(0.), //emissive\n                     0.,//metallic\n                     .64);//roughness\n    }\n    if (dr.y < 2.) {\n        //wall material\n\t\treturn material(vec3(.74,.79,.85), //diffuse\n                     vec3(.92), //specular\n                  \t vec3(0.), //emissive\n                     .84,//metallic\n                     .08);//roughness\n    }\n\t\n    float met = pow((rp.x+.6)/1.2,2.);\n    vec3 ts = vec3(.99,.32,.22);\n    //sphere material\n\treturn material(ts, //diffuse\n                    mix(ts,vec3(.92),met), //specular\n                  \t vec3(0.), //emissive\n                     met,//metallic\n                     .5-met*.5);//roughness\n    \n}\n\n\n\n//rp = ray pos\n//rd = ray dir\n//maxDist = max trace distance\n//returns -1 if nothing is hit\nfloat trace(in vec3 rp, inout vec3 rd, float maxDist) {\n    \n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s).x;\n        if (d < EPSILON || s > maxDist) break;\n        s += d;\n    }\n    \n    if (d < EPSILON) return s;\n    \n    return -1.0;\n}\nfloat rTrace(in vec3 rp, inout vec3 rd, float maxDist) {\n    \n    float d,s = 0.;\n    for (int i = 0; i < REFLECTION_ITERATIONS; i++) {\n        d = df(rp+rd*s).x;\n        if (d < EPSILON || s > maxDist) break;\n        s += d;        \n    }\n    \n    if (d < EPSILON) return s;\n    \n    return -1.0;\n}\n\n#define AO_ITERATIONS 16\n#define AO_PRECISION .005\n#define AO_INTENSITY 2.\n#define AO_ATTEN 0.9\n\nfloat ambientOcclusion(in vec3 p, in vec3 norm) {\n\tfloat sum = 0.0;\n\tfloat atten = 1.0;\n\tfloat s = AO_PRECISION;\n    \n    float d;\n    \n\tfor (int i = 1; i < AO_ITERATIONS; i++) {\n        d = max(0., df(p+norm*s).x);\n        \n\t\tsum += (s-d)*atten;\t\t\n\t\ts += AO_PRECISION*(1.+float(i)*.25);\t\n\t\tatten *= AO_ATTEN;\n\t}\n\t\n\treturn 1.0-sum*AO_INTENSITY;\n}\n\nfloat softShadowTrace(in vec3 rp, in vec3 rd, in float maxDist, in float penumbraSize, in float penumbraIntensity) {\n    vec3 p = rp;\n    float sh = 0.;\n    float d,s = 0.;\n    for (int i = 0; i < SHADOW_ITERATIONS; i++) {\n        d = df(rp+rd*s).x;\n        sh += max(0., penumbraSize-d)*float(s>penumbraSize*2.);\n        s += d;\n        if (d < EPSILON || s > maxDist) break;\n    }\n    \n    if (d < EPSILON) return 0.;\n    \n    return max(0.,1.-sh/penumbraIntensity);\n}\n\nvec3 background(in vec3 rd) {\n\tvec3 c = vec3(0.);\n    return c;\n}\nvec3 background_gi(in vec3 rd) {\n    return background(rd);\n}\n\nvoid lighting(in vec3 td, in vec3 sd, in vec3 norm, in vec3 reflDir, in material m, inout vec3 dif, inout vec3 spec) {\n    float ao = ambientOcclusion(td,norm);\n    dif = ambient*ao;\n    spec = vec3(0.);\n        \n    #if nLights != 0\n    for (int i = 0; i < nLights; i++) {\n        vec3 lightVec = lights[i].position-td;\n        float lightAtten = length(lightVec);\n        lightVec = normalize(lightVec);\n        float shadow = softShadowTrace(sd, lightVec, lightAtten, .01, .01);\n        lightAtten = max(0., 1.-lightAtten/lights[i].size)*shadow;\n        \n    \tdif += max(0., dot(lightVec,norm))*lights[i].color*lightAtten;\n        spec += pow(max(0., dot(reflDir, lightVec)), 4.+(1.-m.roughness)*78.)*shadow*lights[i].color;\n    }\n\t#endif\n}\n\n//copy of shade without reflection trace\nvec3 shadeNoReflection(in vec3 rp, in vec3 rd, in vec3 norm, in material m) {\n    vec3 sd = rp-rd*EPSILON*2.;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 reflDir = reflect(rd,norm);\n\n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);\n\n    return lightDif*m.diffuse +\n        \t(.5+m.metallic*.5)*lightSpec*m.specular +\n        \tm.emissive ;\n}\n\nvec3 shade(in vec3 rp, in vec3 rd, in vec3 norm, material m) {\n    vec3 sd = rp-rd*EPSILON;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 dlc = vec3(0.);\n    \n    vec3 slc = vec3(0.);\n    \n    vec3 tReflDir = reflect(normalize(mix(rd, \n                                  randomHemiRay(norm,rp*cos(float(iFrame)/1024.+float(iFrame)*1.1923)+rp.yzx+128.1924*cos(float(iFrame)*.1972)),\n                                  m.roughness)),\n                            norm);\n    float rtd = rTrace(sd,tReflDir,VIEW_DISTANCE);\n    if (rtd < 0.) {\n        slc += background(tReflDir);\n    } else {\n        vec3 rhp = sd+tReflDir*rtd;\n        slc += shadeNoReflection(rhp,tReflDir,normal(rhp),mat(rhp));\n    }\n    \n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflect(rd,norm),m,lightDif,lightSpec);\n    dlc += lightDif;\n    slc += lightSpec;\n    \n    float fres = 1.-max(0., dot(-rd,norm));\n    \n    return (1.-m.metallic)*dlc*m.diffuse +\n        \tslc*m.specular*((.5-m.metallic*.5)*fres+m.metallic*(.5+m.metallic*.5)) +\n        \tm.emissive ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/iResolution.x;\n\n    \n    initLights();\n\n    cameraRotation = vec2(cos(iTime*.1)+pi/2., 2.);\n\tcameraLocation = vec3(0., 0., -1.);\n    \n    vec3 rp = cameraLocation;\n    vec3 rd = normalize(vec3(uv*FOV_SCALE,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n    rp.yz = rot(rp.yz,cameraRotation.y);\n    rp.xz = rot(rp.xz,cameraRotation.x);    \n    \n\tfloat itd = trace(rp,rd,VIEW_DISTANCE);\n\n    vec3 hp = rp+itd*rd;\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy)*.9+\n              vec4(mix(shade(hp,\n                      rd,\n                      normal(hp),\n                      mat(hp)), background(rd), max(clamp(-itd,0.,1.),itd/VIEW_DISTANCE)),\n        \t\t\t1.);\n}","name":"Buf A","description":"","type":"buffer"}]}