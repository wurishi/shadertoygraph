{"ver":"0.1","info":{"id":"Dtd3zX","date":"1682943961","viewed":306,"name":"[SESSIONS2023] POOL","username":"FoRenard","description":"Winning entry in the GLSL Graphics Compo for SESSIONS 2023.\n\nWarning: Compilation takes a very long time!","likes":9,"published":1,"flags":32,"usePreview":1,"tags":["pool","liminal","sessions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Parameters---------------------------------------------------------------\n#define PI 3.14159265359\n#define TAU 6.28318530718\n#define LoopMax 128\n#define DistMin 0.001\n#define LenMax 1000.0\n#define NormalEPS 0.001\n#define ResolutionEPS (2.0/max(iResolution.x, iResolution.y))\n\n#define sabs(x) sqrt(x*x+1e-2)\n#define smin(a,b) (a+b-sabs(a-b))*.5\n#define smax(a,b) (a+b+sabs(a-b))*.5\n#define opRep(p,c) (mod(p,c)-(c)*.5)\n#define opRepLim(p,c,l,r) (p-(c)*clamp(round((p)/(c)),l,r))\n#define remap(x,a,b,c,d) (((x-a)/(b-a))*(d-c)+c)\n#define remapc(x,a,b,c,d) clamp(remap(x,a,b,c,d),min(c,d),max(c,d))\n#define RGBColor(r,b,g) (vec3(r,g,b)/255.0)\n#define BackBuffer(uv) texture(iChannel0,mod(uv,vec2(1)))\n\nfloat LocalTime;\nfloat ABSLocalTime;\nfloat T = 0.0;\n\n#define MAX_SCID 24\nfloat SCID[MAX_SCID];\n\n#define SC(l,r) if((T=LocalTime-l),(l<=LocalTime&&LocalTime<r))\n#define SCI(id) if((T=LocalTime-SCID[id-1]),(SCID[id-1]<=LocalTime&&LocalTime<SCID[id]))\n#define SCIR(il,ir) if((T=LocalTime-SCID[il]),(SCID[il]<=LocalTime&&LocalTime<SCID[ir]))\n#define SCIR01(il,ir) if((T=(LocalTime-SCID[il])/(SCID[ir]-SCID[il])),(SCID[il]<=LocalTime&&LocalTime<SCID[ir]))\n#define SCI01(id) if((T=(LocalTime-SCID[id-1])/(SCID[id]-SCID[id-1])),(SCID[id-1]<=LocalTime&&LocalTime<SCID[id]))\n#define OPENINGSC SCIR01(0,6)\n#define POORSC SCIR01(6,19)\n\nstruct MatInfo\n{\n    float roughness;\n    float metalic;\n    float emission;\n    float lightRange;\n    vec3 color;\n};\n#define MatInfo() MatInfo(0.0,0.0,0.0,1.0,vec3(0.0))\n\n//UI--------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/Mt2GWD\n#define MAX_INT_DIGITS 5\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\nconst vec4 ch_spc = vec4(0x000000, 0x000000, 0x000000, 0x000000);\nconst vec4 ch_per = vec4(0x000000, 0x000000, 0x000038, 0x380000);\nconst vec4 ch_0 = vec4(0x007CC6, 0xD6D6D6, 0xD6D6C6, 0x7C0000);\nconst vec4 ch_1 = vec4(0x001030, 0xF03030, 0x303030, 0xFC0000);\nconst vec4 ch_2 = vec4(0x0078CC, 0xCC0C18, 0x3060CC, 0xFC0000);\nconst vec4 ch_3 = vec4(0x0078CC, 0x0C0C38, 0x0C0CCC, 0x780000);\nconst vec4 ch_4 = vec4(0x000C1C, 0x3C6CCC, 0xFE0C0C, 0x1E0000);\nconst vec4 ch_5 = vec4(0x00FCC0, 0xC0C0F8, 0x0C0CCC, 0x780000);\nconst vec4 ch_6 = vec4(0x003860, 0xC0C0F8, 0xCCCCCC, 0x780000);\nconst vec4 ch_7 = vec4(0x00FEC6, 0xC6060C, 0x183030, 0x300000);\nconst vec4 ch_8 = vec4(0x0078CC, 0xCCEC78, 0xDCCCCC, 0x780000);\nconst vec4 ch_9 = vec4(0x0078CC, 0xCCCC7C, 0x181830, 0x700000);\nconst vec4 ch_col = vec4(0x000000, 0x383800, 0x003838, 0x000000);\nconst vec4 ch_A = vec4(0x003078, 0xCCCCCC, 0xFCCCCC, 0xCC0000);\nconst vec4 ch_C = vec4(0x003C66, 0xC6C0C0, 0xC0C666, 0x3C0000);\nconst vec4 ch_E = vec4(0x00FE62, 0x60647C, 0x646062, 0xFE0000);\nconst vec4 ch_L = vec4(0x00F060, 0x606060, 0x626666, 0xFE0000);\nconst vec4 ch_O = vec4(0x00386C, 0xC6C6C6, 0xC6C66C, 0x380000);\nconst vec4 ch_P = vec4(0x00FC66, 0x66667C, 0x606060, 0xF00000);\nconst vec4 ch_R = vec4(0x00FC66, 0x66667C, 0x6C6666, 0xE60000);\nconst vec4 ch_Y = vec4(0x00CCCC, 0xCCCC78, 0x303030, 0x780000);\n\nvec2 res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b, -1.0, 24.0);\n    return floor(mod(floor(n / pow(2.0, floor(b))), 2.0));\n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x - uv.x - 1.0) + uv.y * size.x;\n\n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv, vec2(0))) && all(lessThan(uv, size));\n\n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 0.0);\n\n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\nconst vec4 ch_digits[10] = vec4[](ch_0, ch_1, ch_2, ch_3, ch_4, ch_5, ch_6, ch_7, ch_8, ch_9);\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    return ch_digits[int(d) % 10];\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n\n    for(int i = MAX_INT_DIGITS; i >= 0; i--)\n    {\n        float digit = mod(number / pow(10.0, float(i)), 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i || i == 0) //Clip off leading zeros.\n        {\n            result += char(get_digit(digit), uv);\n        }\n    }\n    return result;\n}\n\n//Easing-------------------------------------------------------------------\n#define MAX_CATMULL_LENGTH 16\nvec3 CATMULL_ROM_POINTS[MAX_CATMULL_LENGTH];\nfloat CATMULL_ROM_LENGTH[MAX_CATMULL_LENGTH];\n\nvoid setCatmull(int id, vec3 point)\n{\n    CATMULL_ROM_POINTS[id] = point;\n    CATMULL_ROM_LENGTH[id] = (id > 0 ? (length(CATMULL_ROM_POINTS[id] - CATMULL_ROM_POINTS[id - 1]) + CATMULL_ROM_LENGTH[id - 1]) : 0.0);\n}\n\nvec3 getCatmull(int count, float t)\n{\n    t = clamp(t, 0.0, 1.0);\n    float sl = CATMULL_ROM_LENGTH[count - 1];\n    for(int i = 1; i < count; i++)\n    {\n        if(t * sl <= CATMULL_ROM_LENGTH[i])\n        {\n            t = clamp((t * sl - CATMULL_ROM_LENGTH[i - 1]) / (CATMULL_ROM_LENGTH[i] - CATMULL_ROM_LENGTH[i - 1]), 0.0, 1.0);\n            if(i == 1)\n            {\n                vec3 p0 = CATMULL_ROM_POINTS[0];\n                vec3 p1 = CATMULL_ROM_POINTS[1];\n                vec3 p2 = CATMULL_ROM_POINTS[2];\n                return 0.5 * ((p0 - 2.0 * p1 + p2) * t * t + (-3.0 * p0 + 4.0 * p1 - p2) * t + 2.0 * p0);\n            }\n            else if(i == count - 1)\n            {\n                vec3 p0 = CATMULL_ROM_POINTS[i - 2];\n                vec3 p1 = CATMULL_ROM_POINTS[i - 1];\n                vec3 p2 = CATMULL_ROM_POINTS[i];\n                return 0.5 * ((p0 - 2.0 * p1 + p2) * t * t + (-p0 + p2) * t + 2.0 * p1);\n            }\n            else\n            {\n                vec3 p0 = CATMULL_ROM_POINTS[i - 2];\n                vec3 p1 = CATMULL_ROM_POINTS[i - 1];\n                vec3 p2 = CATMULL_ROM_POINTS[i];\n                vec3 p3 = CATMULL_ROM_POINTS[i + 1];\n                return 0.5 * ((-p0 + 3.0 * p1 - 3.0 * p2 + p3) * t * t * t + (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t * t + (-p0 + p2) * t + 2.0 * p1);\n            }\n        }\n    }\n}\n\n//General Functions--------------------------------------------------------\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);\n    return hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);\n}\n\nvec3 rgb2hsv(vec3 rgb)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n#define HexColor(c) vec3(float(c >> 16) / 255.0, float((c >> 8) & 0xFF) / 255.0, float(c & 0xFF) / 255.0)\n\nfloat roughnessFix(float roughness)\n{\n    return clamp(remap(roughness, 0.0, 1.0, 10000.0, 0.0), 0.0, 10000.0);\n}\nfloat lightAttenuation(MatInfo lightInfo, float dist)\n{\n    dist = max(dist, 0.0);\n    float range = max(lightInfo.lightRange, 0.1);\n    return pow(clamp(1.0 - (1.0 / range) * dist, 0.0, 1.0), 2.0) * lightInfo.emission;\n}\n\n// Hash without Sine by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash23(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat noise11(float x)\n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash11(i), hash11(i + 1.0), u);\n}\n\nvec2 rot2d(vec2 p, float a)\n{\n    a *= PI / 180.0;\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\nvec4 permute(vec4 x)\n{\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\nfloat taylorInvSqrt(float r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return vec4(taylorInvSqrt(r.x), taylorInvSqrt(r.y), taylorInvSqrt(r.z), taylorInvSqrt(r.w));\n}\n        //\tSimplex 3D Noise \n        //\tby Ian McEwan, Ashima Arts\n        //\nfloat snoise(vec3 v)\n{\n    const vec2 C = vec2(0.5, 1.0) / 3.0;\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n            // First corner\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n            // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n            //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n            // Permutations\n    i = mod(i, 289.0);\n    vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n            // Gradients\n            // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0 / 7.0; // N=7\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0, 0, 0, 0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n            //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n            // lerp final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    float res = clamp(42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))), -1.0, 1.0);\n    return clamp((res + 1.0) * 0.5, 0.0, 1.0);\n}\n\n#define NumOctaves 4\nfloat fbm(vec3 x, in float H)\n{\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < NumOctaves; i++)\n    {\n        t += a * snoise(f * x);\n        f *= 2.0;\n        a *= G;\n\n    }\n    return clamp(t, 0.0, 1.0);\n}\n\nvec3 pattern(vec3 p)\n{\n    vec3 q;\n    q.x = fbm(p, 2.0);\n    q.y = fbm(p + vec3(4.2, 1.3, 0.42), 2.0);\n    q.z = fbm(p + vec3(5.3, .1, 3.12), 2.0);\n    vec3 r;\n    r.x = fbm(p + 4.0 * q + vec3(0.2, 6.7, 3.2), 2.0);\n    r.y = fbm(p + 4.0 * q + vec3(4.2, 2.2, 1.1), 2.0);\n    r.z = fbm(p + 4.0 * q + vec3(1.2, 4.1, 7.1), 2.0);\n    vec3 res, ss = p + 4.0 * r;\n    res.x = fbm(vec3(ss.x, 0, 0), 2.0);\n    res.y = fbm(vec3(0, ss.y, 0), 2.0);\n    res.z = fbm(vec3(0, 0, ss.z), 2.0);\n    return res;\n}\n\nfloat smoothMin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\nfloat foldPlus(float x, float f)\n{\n    return f - abs(x - f);\n}\nfloat foldMinus(float x, float f)\n{\n    return f + abs(x - f);\n}\n\nvoid tangentSpaceBasis(vec3 normal, out vec3 tangent, out vec3 binormal)\n{\n    vec3 n = normalize(normal);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 0.0);\n\n    if(n.x < 0.9999)\n    {\n        t = normalize(cross(n, vec3(1.0, 0.0, 0.0)));\n    }\n    else\n    {\n        t = normalize(cross(n, vec3(0.0, 1.0, 0.0)));\n    }\n\n    b = cross(n, t);\n\n    tangent = t;\n    binormal = b;\n}\n\nvec3 localToWorld(vec3 local, vec3 tangent, vec3 normal, vec3 binormal)\n{\n    return tangent * local.x + normal * local.y + binormal * local.z;\n}\n\nvec3 reflSample(vec2 rnd, float n)\n{\n    float theta = acos(pow(1.0 - rnd.x, 1.0 / (1.0 + n)));\n    float phi = 2.0 * PI * rnd.y;\n\n    return vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x * PI * 2.;\n    float t = rnd.y * 2. - 1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\n//SDF----------------------------------------------------------------------\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\nfloat sdVerticalCapsule(vec3 p, float h, float r)\n{\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\nfloat sdHolizontalCapsule(vec3 p, float h, float r)\n{\n    p.x -= clamp(p.x, 0.0, h);\n    return length(p) - r;\n}\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\nfloat sdTorusYZ(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.yz) - t.x, p.x);\n    return length(q) - t.y;\n}\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat sdSphere(vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\n//Map----------------------------------------------------------------------\nfloat sofa(vec3 p)\n{\n    float n = 0.0;\n    p.x = foldPlus(p.x, 1.05);\n    float d = sdBox(p, vec3(1, 0.3, 0.6));\n    n = 0.05 * clamp(snoise(p * 50.0) * 15.0, 0.95, 1.0);\n    return d - n;\n}\nMatInfo _sofa(vec3 p)\n{\n    MatInfo info = MatInfo();\n    float ha = 1.0;\n    vec3 c = HexColor(0xDEDAC5);\n    info.roughness = 1.0;\n    info.metalic = 0.0;\n    ha = remapc(hash12(hash23(p * 42.0)), 0.0, 1.0, 0.8, 1.0);\n    info.color = c * ha;\n    return info;\n}\n\nfloat room(vec3 p)\n{\n    const float h = 4.0;\n    const float f = 6.0 * PI;\n    const float a = 7.0;\n    const float m = 0.02;\n\n    vec3 uv = p;\n    float n = 0.0;\n    float d = -sdBox(p - vec3(0, 2, 0), vec3(8, 2, 6));\n    d = max(d, -sdBox(p - vec3(1.5, 0, 0), vec3(1.5, 2.0, 4)));\n    d = min(d, sdBox(p - vec3(4.5, h * 0.5, 0), vec3(1.5, h, 4)));\n    d = min(d, sdBox(p - vec3(-6.0, h * 0.5, 4.0), vec3(3, h, 2)));\n    n = clamp(abs(cos(uv.x * f) + 1.0) * a, 0.0, 1.0) *\n        clamp(abs(cos(uv.y * f) + 1.0) * a, 0.0, 1.0) *\n        clamp(abs(cos(uv.z * f) + 1.0) * a, 0.0, 1.0) *\n        (1.0 + (snoise(p * 20.0) - 0.5) * 0.1) * m;\n    return d - n;\n}\n\nconst vec3 _roomCols[4] = vec3[4](HexColor(0x425C78), HexColor(0xC3CED6), HexColor(0x4D7085), HexColor(0xA8BDCB));\nMatInfo _room(vec3 p)\n{\n    MatInfo info = MatInfo();\n    const float f = 6.0 * PI;\n    const float a = 7.0;\n    const float m = 0.02;\n\n    vec3 uv = p;\n    float n = clamp(abs(cos(uv.x * f) + 1.0) * a, 0.0, 1.0) *\n        clamp(abs(cos(uv.y * f) + 1.0) * a, 0.0, 1.0) *\n        clamp(abs(cos(uv.z * f) + 1.0) * a, 0.0, 1.0) *\n        (1.0 + (snoise(p * 20.0) - 0.5) * 0.1) * m;\n    int id = int(hash12(hash23(floor(p * 3.0 + 1.5) * 42.0)) * 4.0);\n    vec3 maincol = _roomCols[id];\n    const vec3 mizocol = HexColor(0x040D18);\n    float mizu = pow(remapc(snoise(p * 0.5), 0.5, 1.0, 0.0, 1.0), 0.5) * remapc(p.y, 0.2, 0.5, 1.0, 0.0);\n    info.roughness = 0.05;\n    info.metalic = mizu * 0.5;\n    info.color = (n > m * 0.2 ? maincol : mizocol);\n    return info;\n}\n\nfloat handrail(vec3 p)\n{\n    const float h = 5.0;\n    const float b = 0.02;\n    const float a = 15.0 * PI / 180.0;\n    float d = LenMax;\n    float r = 0.0;\n    r = 0.25;\n    float tp = r / tan(a);\n    vec3 p0 = p;\n    p0.x -= h * 0.5;\n    p0.y -= h - h * 0.5 * sqrt(3.0);\n    p0.xy = rot2d(p0.xy, -30.0);\n    float d0 = sdVerticalCapsule(p, h - tp, b);\n    float d1 = sdVerticalCapsule(p0, h - tp, b);\n    vec3 p1 = p - vec3(r, h - tp, 0);\n    float rt = atan(p1.y, p1.x);\n    float d2 = sdTorus(p1, vec2(r, b));\n    d = min(d, d0);\n    d = min(d, d1);\n    d = (PI / 6.0 <= rt && rt <= PI) ? d2 : d;\n    return d;\n}\nMatInfo _handrail(vec3 p)\n{\n    MatInfo info = MatInfo();\n    info.roughness = 0.0;\n    info.metalic = 1.0;\n    info.color = vec3(1.0);\n    return info;\n}\n\nfloat desk(vec3 p)\n{\n    float d = LenMax;\n    d = min(d, sdBox(p - vec3(0.0, 1.5, 0.0), vec3(1.0, 0.05, 2.0)));\n    vec3 p0 = p;\n    p0.x = foldPlus(p0.x, 0.0);\n    p0.z = foldPlus(p0.z, 0.0);\n    d = min(d, sdBox(p0 - vec3(-0.8, 0.5, -1.8), vec3(0.04, 1.0, 0.04)));\n    return d;\n}\nconst vec3 _deskCols[4] = vec3[4](HexColor(0xAD8974), HexColor(0x9E765D), HexColor(0x755240), HexColor(0x4C392C));\nMatInfo _desk(vec3 p)\n{\n    MatInfo info = MatInfo();\n    const vec3 cz = HexColor(0x1E0E04);\n    float n = fract(fbm(p * vec3(2.0, 2.0, 0.5), 2.0) * 7.0) * 3.0;\n    int id = int(n);\n    float ca = fract(n);\n    vec3 c = mix(_deskCols[id], _deskCols[id + 1], ca);\n    info.roughness = 0.15;\n    info.color = p.y < 1.44 ? cz : c;\n    info.metalic = float(p.y < 1.44);\n    return info;\n}\n\nfloat computerFrame(vec3 p)\n{\n    const float fu = 14.0 * PI;\n    const float fv = 6.0 * PI;\n    const float a = 5.0;\n    float d = LenMax;\n    p.y -= 1.5;\n    vec2 uv = remap(p.xz, vec2(-0.25, -0.45), vec2(0.05, 0.45), vec2(0, 0), vec2(1, 1)).yx;\n    float n = 0.0;\n    n = clamp(abs(sin(uv.x * fu)) * a, 0.0, 1.0) * clamp(abs(sin(uv.y * fv)) * a, 0.0, 1.0) * 0.005;\n    n *= float(0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0);\n    d = min(d, sdBox(p - vec3(0.0, 0.1, 0.0), vec3(0.3, 0.0, 0.5)) - 0.01);\n    d = max(d, -sdBox(p - vec3(0.175, 0.1 + 0.01, 0.0), vec3(0.11, 0.006, 0.2)));\n    return d - n;\n}\nMatInfo _computerFrame(vec3 p)\n{\n    const float fu = 14.0 * PI;\n    const float fv = 6.0 * PI;\n    const float a = 5.0;\n    vec2 uv = remap(p.xz, vec2(-0.25, -0.45), vec2(0.05, 0.45), vec2(0, 0), vec2(1, 1)).yx;\n    float n = 0.0;\n    n = clamp(abs(sin(uv.x * fu)) * a, 0.0, 1.0) * clamp(abs(sin(uv.y * fv)) * a, 0.0, 1.0) * 0.005;\n    n *= float(0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0);\n    MatInfo info = MatInfo();\n    info.roughness = n > 0.001 ? 1.0 : 0.9;\n    info.color = n > 0.001 ? vec3(0.1) : HexColor(0xCACBCD);\n    return info;\n}\nfloat computerScreen(vec3 p)\n{\n    p -= vec3(-0.4, 1.9, 0);\n    p.xy = rot2d(p.xy, -15.0);\n    return sdBox(p, vec3(0.0, 0.3, 0.5)) - 0.01;\n}\nvec2 _rotate(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * p;\n}\nfloat d2_sdf_arc(vec2 p, vec2 sc, float ra, float rb)\n{\n    p.x = abs(p.x);\n    return ((sc.y * p.x > sc.x * p.y) ? length(p - sc * ra) : abs(length(p) - ra)) - rb;\n}\nfloat sessions_s(vec2 uv)\n{\n    const float angle = 4.4;\n    const float thin = 0.1;\n    const vec2 offset_S = vec2(-0.35, 0.0);\n\n    uv *= 0.57;\n    uv += vec2(0.4, 0.14);\n    uv += offset_S;\n    uv = _rotate(uv, -0.2);\n    uv -= offset_S;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= 1.25;\n    vec2 uv1 = uv + offset_S;\n    uv1.y -= 0.2 + thin;\n    uv1 = _rotate(uv1, angle);\n    float d1 = d2_sdf_arc(uv1, vec2(sin(angle), cos(angle)), 0.3, thin);\n    vec2 uv2 = uv + offset_S;\n    uv2.y += 0.2 + thin;\n    uv2 = _rotate(uv2, angle + PI);\n    float d2 = d2_sdf_arc(uv2, vec2(sin(angle), cos(angle)), 0.3, thin);\n    return float(min(d1, d2) < 0.0);\n}\n\nfloat sessions(vec2 uv)\n{\n    float pl = 1.0;\n    pl *= float(uv.x < 0.25);\n    pl *= float(mod(0.5 + uv.x + uv.y, 0.3) < 0.15);\n    float pr = 1.0;\n    pr *= float(uv.x >= 0.25);\n    pr -= sessions_s(uv);\n    float p = pl + pr;\n    return clamp(1.0 - p, 0.0, 1.0);\n}\n\nfloat easing(float t)\n{\n    return pow(t, 0.1);\n}\n\nconst vec3 _scolpalette0[4] = vec3[](HexColor(0x2B3467), HexColor(0xBAD7F9), vec3(1), HexColor(0xEB455F));\nvec3 sessionsCol(vec2 uv)\n{\n    float lt = ABSLocalTime * 0.5;\n    lt = floor(lt) + easing(fract(lt));\n    float amp = 1.0;\n\n    SCI01(5)\n    {\n        amp = mix(1.0, 0.0, clamp(T * 2.0, 0.0, 1.0));\n    }\n    float n0 = floor(hash11(floor(lt)) * 10.0 * amp + 1.0);\n    vec3 scol = vec3(0);\n    vec2 div = vec2(16. / 9., 1.) * n0;\n\n    vec2 id = floor(uv * div);\n    lt += 0.25 * id.y / div.y;\n    uv.x += 0.1 * (cos(2.0 * PI * lt) + 2.0 * PI * lt);\n    id = floor(uv * div);\n    uv = mod(uv, 1. / div) * div;\n    float pix = sessions(uv);\n    vec3 col = _scolpalette0[int(hash12(id) * 4.0)];\n    scol = mix(scol, col, pix);\n    float thresh = 0.05;\n    SCI01(5)\n    {\n        thresh = mix(0.05, 1.0, clamp(T / 0.8, 0.0, 1.0));\n    }\n    scol = hash12(id + 42.42) < thresh ? vec3(length(scol) < .1, 0, 0) : scol;\n    return scol;\n}\n\nvec3 screenCol(vec2 uv)\n{\n    float lt = ABSLocalTime * 0.5;\n    lt = floor(lt) + easing(fract(lt));\n    float mt = mod(lt, 1.0);\n    float s = mt < 0.8 ? 0.0 : pow(mix(0.0, 1.0, (mt - 0.8) * 5.0), 5.0);\n    vec2 sh = vec2(s, 0) * 0.025;\n    return vec3(sessionsCol(uv + sh).r, sessionsCol(uv).g, sessionsCol(uv - sh).b);\n}\n//LIGHT\nMatInfo _computerScreen(vec3 p)\n{\n    MatInfo info = MatInfo();\n    p -= vec3(-0.4, 1.9, 0);\n    p.xy = rot2d(p.xy, -15.0);\n    vec2 uv = remap(p.zy, vec2(-0.5, -9. / 32.), vec2(0.5, 9. / 32.), vec2(0), vec2(1));\n    bool inSide = 0.0 < uv.x && uv.x < 1.0 && 0.0 < uv.y && uv.y < 1.0 && p.x > 0.0;\n    info.color = inSide ? screenCol(uv) : HexColor(0xCACBCD);\n    info.emission = float(inSide && length(info.color) > .1) * 4.0;\n    info.roughness = 1.0;\n    info.lightRange = 14.0;\n    POORSC\n    {\n        info.color = inSide ? BackBuffer(uv).rgb : HexColor(0xCACBCD);\n        info.emission = float(inSide && length(info.color) > .1);\n        info.lightRange = 4.0;\n    }\n    return info;\n}\n\nfloat coffee(vec3 p)\n{\n    float d = LenMax;\n    d = min(d, sdCappedCylinder(p - vec3(0.0, 1.67, 0.0), 0.1, 0.1));\n    d = max(d, -sdCappedCylinder(p - vec3(0.0, 1.67 + 0.1, 0.0), 0.04, 0.09));\n    d -= 0.001;\n    d = smoothMin(d, sdTorusYZ(p - vec3(0.0, 1.65, 0.1), vec2(0.06, 0.01)), 0.01);\n    return d;\n}\nMatInfo _coffee(vec3 p)\n{\n    MatInfo info = MatInfo();\n    bool isCoffee = length(p.xz) < 0.09;\n    info.roughness = isCoffee ? 0.0 : 0.5;\n    info.color = isCoffee ? vec3(0.1) : vec3(0.932813, 0.867187, 0.7125);\n    return info;\n}\n\nfloat ceilLattice(vec3 p)\n{\n    float d = LenMax;\n    float mz = 0.25, mx = 1.0;\n    p.z = opRep(p.z, mz);\n    d = min(d, length(p.yz) - 0.01);\n    p.x = opRep(p.x, mx);\n    d = smoothMin(d, length(p.xy) - 0.025, 0.01);\n    return d;\n}\nMatInfo _ceilLattice(vec3 p)\n{\n    MatInfo info = MatInfo();\n    info.roughness = 0.05;\n    info.color = vec3(0.9);\n    return info;\n}\n\nfloat ceilLightFrame(vec3 p)\n{\n    float d = LenMax;\n    const float m = 3.25;\n    const float y = -0.25;\n    p.xz = opRepLim(p.xz, m, vec2(-2.0, -2.0), vec2(0.0, 1.0));\n    d = min(d, sdBox(p - vec3(0.0, -0.125 + y, 0.0), vec3(m * 0.25 + 0.05, 0.025, 0.175)));\n    p.z = foldPlus(p.z, 0.0);\n    p.x = opRepLim(p.x - m * 0.25, m * 0.5, -1.0, 0.0);\n    d = min(d, sdBox(p - vec3(0.0, -0.2 + y, -0.1), vec3(0.025, 0.05, 0.05)));\n    d = min(d, sdVerticalCapsule(p - vec3(0.0, -0.2 + y, -0.1), m * 0.5, 0.005));\n    return d;\n}\nMatInfo _ceilLightFrame(vec3 p)\n{\n    MatInfo info = MatInfo();\n    info.roughness = 0.05;\n    info.color = vec3(0.9);\n    return info;\n}\n\nfloat ceilLightLight(vec3 p)\n{\n    const float m = 3.25;\n    const float y = -0.25;\n    p.xz = opRepLim(p.xz, m, vec2(-2.0, -2.0), vec2(0.0, 1.0));\n    p.z = foldPlus(p.z, 0.0);\n    return sdHolizontalCapsule(p - vec3(-m * 0.25, -0.2 + y, -0.1), m * 0.5, 0.02);\n}\n//LIGHT\nMatInfo _ceilLightLight(vec3 p)\n{\n    MatInfo info = MatInfo();\n    POORSC\n    {\n        info.emission = mix(hash11(floor(LocalTime * 3.0)) < 0.5 ? 0.4 : 0.7, 1.0, pow(clamp(noise11(LocalTime * 6.5) * 4.0, 0.0, 1.0), 16.0));\n        info.emission *= 0.75;\n    }\n    info.lightRange = 5.0;\n    info.color = HexColor(0xDDE6FF);\n    return info;\n}\n\n#define SnakeLights 6\nfloat sdSnake3D(vec2 plane, float t, float tmin, float tmax, float start, float end, float seed)\n{\n    const float a = 0.2;\n    const float f = 2.0;\n    vec3 p0 = vec3((t + seed) * f, 0.0, 0.0);\n    float x = remapc(t, tmin, tmax, 0.0, 1.0);\n    float v = a * (noise11(p0.x) - 0.5) + mix(start, end, x * x);\n    float sdplanex = abs(plane.x - v);\n    float sdplaney = abs(plane.y);\n    float sdplanez = max(max(t - tmax, tmin - t), 0.0);\n    return sqrt(sdplanex * sdplanex + sdplaney * sdplaney + sdplanez * sdplanez);\n}\nfloat snakeLightLine(vec3 p, int index)\n{\n    const float radius = 0.02;\n    p.y -= 0.1;\n    float seed = float(index + 1);\n    float d = LenMax;\n    // Yuka\n    const vec2 trange0 = vec2(-8.0, 0.0 + radius * 2.0), startrange0 = vec2(-3.0, -1.0), endrange0 = vec2(-3.5, 2.0);\n    float start = mix(startrange0.x, startrange0.y, hash12(vec2(seed)));\n    float end = mix(endrange0.x, endrange0.y, hash12(vec2(seed + float(SnakeLights) * 42.0)));\n    d = min(d, sdSnake3D(p.zy - vec2(0, 2.0 * radius), p.x, trange0.x, trange0.y, start, end, seed) - radius);\n    // Kabe\n    const vec2 trange1 = vec2(0.0, 1.5);\n    const float end1 = -2.0;\n    d = min(d, sdSnake3D(p.zx - vec2(0, 2.0 * radius + trange0.x), p.y, trange1.x, trange1.y, start, end1, seed + trange0.x) - radius);\n    // Pool\n    const vec2 trange2 = vec2(-2.0, 0.0 + radius * 2.0);\n    d = min(d, sdSnake3D(p.zx - vec2(0, 2.0 * radius), p.y, trange2.x, trange2.y, end, end, seed) - radius);\n    return d;\n}\nconst vec3 _cols[4] = vec3[](HexColor(0x7D6D94), HexColor(0xB57BBE), HexColor(0x5976CB), HexColor(0x6EB8D7));\n//LIGHT\nMatInfo _snakeLightLine(vec3 p, int index)\n{\n    const float emitr = 0.1, nonemitr = 0.2;\n    const float emitsumr = emitr + nonemitr;\n    p.y -= 0.1;\n    float seed = float(index + 1);\n    float emits = -mix(0.1, 1.0, hash12(vec2(seed, 0)));\n    float emitn = hash12(vec2(seed, 42));\n    float emitx = mod(p.x - p.y + emits * LocalTime + emitn * emitsumr, emitsumr);\n    bool isemit = emitx < emitr;\n\n    MatInfo info = MatInfo();\n    info.color = vec3(0.9);\n    POORSC\n    {\n        info.color = _cols[index % 4] * (isemit ? 1.0 : 0.15);\n        info.emission = 1.0;\n    }\n    info.roughness = 1.0;\n    info.lightRange = 2.0;\n    return info;\n}\nfloat snakeLights(vec3 p)\n{\n    float d = LenMax;\n    for(int i = 0; i < SnakeLights; i++)\n    {\n        d = min(d, snakeLightLine(p, i));\n    }\n    return d;\n}\n\n#define NazoLights 3\nconst vec3 _nazoPoses[NazoLights] = vec3[](vec3(-6.25, 1.26 - 0.3, -5.3), vec3(-6.25 + 4.5, 1.26 - 0.3, -5.3 + 10.5), vec3(2.4, 1.26 - 3.0, 3.4));\nconst vec3 _nazoCols[NazoLights] = vec3[](HexColor(0xB5CDFF), HexColor(0xFFC99D), vec3(0.9));\nfloat nazoLight(vec3 p, int index)\n{\n    float d = LenMax;\n    d = sdSphere(p - _nazoPoses[index % NazoLights] - vec3(0, 0.3, 0), 0.5);\n    return d;\n}\n// LIGHT\nMatInfo _nazoLight(vec3 p, int index)\n{\n    MatInfo info = MatInfo();\n    info.emission = 1.0;\n    OPENINGSC\n    {\n        info.emission = 0.0;\n    }\n    info.roughness = 1.0;\n    info.color = _nazoCols[index % NazoLights];\n    info.lightRange = 4.0;\n    return info;\n}\n\nfloat nazoLights(vec3 p)\n{\n    float d = LenMax;\n    for(int i = 0; i < NazoLights; i++)\n    {\n        d = min(d, nazoLight(p, i));\n    }\n    return d;\n}\n\nfloat sdf(vec3 p)\n{\n    float d = LenMax;\n    d = min(d, room(p));\n    d = min(d, sofa(p - vec3(-1.7, 0.35, 5.3)));\n    vec3 p0 = p;\n    p0.z = foldMinus(p0.z, -2.0);\n    d = min(d, sofa(p0 - vec3(-6.3, 0.35, 1.3)));\n    vec3 p1 = p;\n    p1.z = foldMinus(p1.z, -2.5);\n    d = min(d, handrail(p1 - vec3(-0.2, -3.0, -2.0)));\n    d = min(d, desk(p - vec3(-7.0, 0.0, -2.0)));\n    d = min(d, computerFrame(p - vec3(-7.0, 0.0, -2.0)));\n    d = min(d, computerScreen(p - vec3(-7.0, 0.0, -2.0)));\n    d = min(d, nazoLights(p));\n    d = min(d, ceilLightFrame(p - vec3(1.5, 3.5, 1.5)));\n    d = min(d, ceilLightLight(p - vec3(1.5, 3.5, 1.5)));\n    d = min(d, ceilLattice(p - vec3(0.0, 3.5, 0.0)));\n    d = min(d, coffee(p - vec3(-7.0, 0.0, -1.0)));\n    d = min(d, snakeLights(p));\n    return d;\n}\n// dist,id\nvec2 map(vec3 p)\n{\n    #define opMatUnion(sdf) (id = ((dt = sdf) < d ? (d = dt, mid): id)), mid++\n    int id = -1, mid = 0;\n    float d = LenMax, dt = 0.0;\n    vec3 p0 = p, p1 = p;\n    p0.z = foldMinus(p0.z, -2.0);\n    p1.z = foldMinus(p1.z, -2.5);\n    opMatUnion(room(p));\n    opMatUnion(sofa(p - vec3(-1.7, 0.35, 5.3)));\n    opMatUnion(sofa(p0 - vec3(-6.3, 0.35, 1.3)));\n    opMatUnion(handrail(p1 - vec3(-0.2, -3.0, -2.0)));\n    opMatUnion(desk(p - vec3(-7.0, 0.0, -2.0)));\n    opMatUnion(computerFrame(p - vec3(-7.0, 0.0, -2.0)));\n    opMatUnion(computerScreen(p - vec3(-7.0, 0.0, -2.0)));\n    for(int i = 0; i < NazoLights; i++)\n    {\n        opMatUnion(nazoLight(p, i));\n    }\n    opMatUnion(ceilLightFrame(p - vec3(1.5, 3.5, 1.5)));\n    opMatUnion(ceilLightLight(p - vec3(1.5, 3.5, 1.5)));\n    opMatUnion(ceilLattice(p - vec3(0.0, 3.5, 0.0)));\n    opMatUnion(coffee(p - vec3(-7.0, 0.0, -1.0)));\n    for(int i = 0; i < SnakeLights; i++)\n    {\n        opMatUnion(snakeLightLine(p, i));\n    }\n    return vec2(d, id);\n}\n\nMatInfo getMatInfo(vec3 p, float fid)\n{\n    #define ifMat(mat) if(id == mid++)return mat\n    #define elifMat(mat) else if(id == mid++)return mat\n    int id = int(fid + 0.5), mid = 0;\n    vec3 p0 = p, p1 = p;\n    p0.z = foldMinus(p0.z, -2.0);\n    p1.z = foldMinus(p1.z, -2.5);\n    ifMat(_room(p));\n    elifMat(_sofa(p - vec3(-1.7, 0.35, 5.3)));\n    elifMat(_sofa(p0 - vec3(-6.3, 0.35, 1.3)));\n    elifMat(_handrail(p1 - vec3(-0.2, -3.0, -2.0)));\n    elifMat(_desk(p - vec3(-7.0, 0.0, -2.0)));\n    elifMat(_computerFrame(p - vec3(-7.0, 0.0, -2.0)));\n    elifMat(_computerScreen(p - vec3(-7.0, 0.0, -2.0)));\n    for(int i = 0; i < NazoLights; i++)\n    {\n        ifMat(_nazoLight(p, i));\n    }\n    ifMat(_ceilLightFrame(p - vec3(1.5, 3.5, 1.5)));\n    elifMat(_ceilLightLight(p - vec3(1.5, 3.5, 1.5)));\n    elifMat(_ceilLattice(p - vec3(0.0, 3.5, 0.0)));\n    elifMat(_coffee(p - vec3(-7.0, 0.0, -1.0)));\n    for(int i = 0; i < SnakeLights; i++)\n    {\n        ifMat(_snakeLightLine(p, i));\n    }\n    return MatInfo();\n}\n\nMatInfo getMatInfo(vec3 p)\n{\n    return getMatInfo(p, map(p).y);\n}\n\nvec3 normal(vec3 p)\n{\n    const float h = NormalEPS;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * sdf(p + k.xyy * h) + k.yyx * sdf(p + k.yyx * h) + k.yxy * sdf(p + k.yxy * h) + k.xxx * sdf(p + k.xxx * h));\n}\n\n// Intersect\nvoid calcIntersect(out vec3 rp0, out float len0, vec3 rd0, vec3 ro0)\n{\n    int i;\n    float dist = 0.0;\n    len0 = 0.0;\n    for(i = 0; i < LoopMax; i++)\n    {\n        rp0 = ro0 + rd0 * len0;\n        dist = sdf(rp0);\n        len0 += dist;\n        if(dist < DistMin || len0 > LenMax)\n        {\n            break;\n        }\n    }\n}\n\n// Light\n#define OtherLights 2\n#define LightCount (OtherLights+NazoLights+SnakeLights)\n\nfloat lightsdf(vec3 p, int id)\n{\n    int mid = 0;\n    #define ifLSDF(sdf) if(id == mid++)return sdf\n    #define elifLSDF(sdf) else if(id == mid++)return sdf\n    ifLSDF(computerScreen(p - vec3(-7.0, 0.0, -2.0)));\n    elifLSDF(ceilLightLight(p - vec3(1.5, 3.5, 1.5)));\n    for(int i = 0; i < NazoLights; i++)\n    {\n        ifLSDF(nazoLight(p, i));\n    }\n    for(int i = 0; i < SnakeLights; i++)\n    {\n        ifLSDF(snakeLightLine(p, i));\n    }\n    return LenMax;\n}\n\nMatInfo getLightInfo(vec3 p, int id)\n{\n    #define ifMat(mat) if(id == mid++)return mat\n    #define elifMat(mat) else if(id == mid++)return mat\n    int mid = 0;\n    ifMat(_computerScreen(p - vec3(-7.0, 0.0, -2.0)));\n    elifMat(_ceilLightLight(p - vec3(1.5, 3.5, 1.5)));\n    for(int i = 0; i < NazoLights; i++)\n    {\n        ifMat(_nazoLight(p, i));\n    }\n    for(int i = 0; i < SnakeLights; i++)\n    {\n        ifMat(_snakeLightLine(p, i));\n    }\n    return MatInfo();\n}\n\nvec3 lightDirection(vec3 p, in int lightIndex)\n{\n    const float h = NormalEPS;\n    const vec2 k = vec2(1, -1);\n    return -normalize(k.xyy * lightsdf(p + k.xyy * h, lightIndex) + k.yyx * lightsdf(p + k.yyx * h, lightIndex) + k.yxy * lightsdf(p + k.yxy * h, lightIndex) + k.xxx * lightsdf(p + k.xxx * h, lightIndex));\n}\n\n#define ApporximateLightSamples 5\nvoid apporximateLight(out vec3 lightCol, out vec3 lightDir, out float lightLen, out float laRes, vec3 ro, int lightIndex)\n{\n    const float maxdiff = 0.2;\n    const float distFactor = 1.0;\n    MatInfo lightInfo = MatInfo();\n    float la = 0.0;\n    float emission = 0.0, dist = 0.0;\n    vec3 col = vec3(0);\n    vec3 rp, rd;\n    rp = ro;\n    dist = lightsdf(rp, lightIndex);\n    lightInfo = getLightInfo(rp, lightIndex);\n    la = lightAttenuation(lightInfo, dist);\n\n    col += lightInfo.color * la;\n    emission += la;\n    for(int j = 0; j < ApporximateLightSamples; j++)\n    {\n        rd = lightDirection(rp, lightIndex);\n        float diff = clamp(1.0 - float(j) / float(ApporximateLightSamples - 1), 0.0, 1.0) * maxdiff;\n        rd = normalize(rd + diff * randomSphereDir(hash23(vec3(float(j) + LocalTime, hash23(rd * 42.0) * 42.0 - vec2(float(lightIndex) * 0.42)))));\n        dist = lightsdf(rp, lightIndex);\n        lightInfo = getLightInfo(rp, lightIndex);\n        la = lightAttenuation(lightInfo, dist);\n\n        col += lightInfo.color;\n        emission += la;\n        rp += rd * dist * distFactor;\n    }\n    col /= float(ApporximateLightSamples + 1);\n    emission /= float(ApporximateLightSamples + 1);\n    lightLen = length(rp - ro);\n    lightDir = (rp - ro) / lightLen;\n    lightInfo.emission = emission;\n    laRes = lightAttenuation(lightInfo, lightLen);\n    lightCol = laRes * col;\n}\n\nvoid calcMixColAndShadow(out vec3 mixCol, out float mixLa, vec3 roOrigin, vec3 rdOrigin, vec3 normal, in MatInfo infoOrigin)\n{\n    const float laFactor = 1.0, laMax = 1.0;\n    const float shadowThresh = 0.1;\n    mixCol = vec3(0.0);\n    mixLa = 0.0;\n    vec3 ro = roOrigin + normal * NormalEPS * 50.0;\n    int loopCount = LightCount;\n    OPENINGSC\n    {\n        loopCount = 1;\n    }\n    for(int i = 0; i < loopCount; i++)\n    {\n        vec3 lightCol, lightDir;\n        float lightLen, la;\n        apporximateLight(lightCol, lightDir, lightLen, la, ro, i);\n\n        if(la == 0.0)\n        {\n            continue;\n        }\n\n        vec3 diffShadow = vec3(1.0);\n        OPENINGSC\n        {\n            vec3 rd = lightDir, rp;\n            float len = 0.0, dist = 0.0;\n            int k;\n            for(k = 0; k < LoopMax / 2; k++)\n            {\n                rp = ro + rd * len;\n                dist = sdf(rp);\n                len += dist;\n                if(dist < DistMin || len > LenMax || len > lightLen)\n                {\n                    break;\n                }\n            }\n            float shelter = lightLen - len;\n            diffShadow = shelter < shadowThresh ? vec3(1.0) : vec3(0.1);\n        }\n        lightCol *= diffShadow;\n        la *= (diffShadow.x + diffShadow.y + diffShadow.z) / 3.0;\n        float ndotl = clamp(dot(normal, lightDir), 0.1, 1.0);\n        vec3 diffCol = infoOrigin.color * ndotl * (1.0 - clamp(infoOrigin.metalic, 0.0, 1.0)) * lightCol;\n        vec3 specCol = pow(clamp(dot(reflect(lightDir, normal), rdOrigin), 0., 1.), 64.0) * (1.0 - infoOrigin.roughness) * lightCol;\n        diffCol = clamp(diffCol, 0.0, 1.0);\n        specCol = clamp(specCol, 0.0, 1.0);\n        mixCol += diffCol + specCol;\n        mixLa += la * laFactor;\n    }\n    mixCol = clamp(mixCol, 0.0, 1.0);\n    mixLa = clamp(mixLa, 0.0, laMax);\n}\n\n// Reflection\nvoid calcReflectionCol(out vec3 reflCol, float roughness, vec3 rd0, vec3 rp0, vec3 normal, float fakeEmission, float seed)\n{\n    vec3 t, b;\n    tangentSpaceBasis(normal, t, b);\n    vec3 rp1, lrd1, hd1, rd1, ro1;\n    float len1 = 0.0, dist, roughnessfx = roughnessFix(roughness);\n    MatInfo info1 = MatInfo();\n    ro1 = rp0 + normal * NormalEPS * 50.0;\n\n    lrd1 = reflSample(hash23(vec3(seed, 0, LocalTime)), roughnessfx);\n    hd1 = localToWorld(lrd1, t, normal, b);\n    rd1 = reflect(rd0, hd1);\n    for(int j = 0; j < LoopMax / 2; j++)\n    {\n        rp1 = ro1 + rd1 * len1;\n        dist = sdf(rp1);\n        len1 += dist;\n        if(dist < DistMin || len1 > LenMax)\n        {\n            break;\n        }\n    }\n    info1 = getMatInfo(rp1);\n    float nfactor = 8.0 * PI / (roughnessfx + 8.0);\n    reflCol = (1.0 - info1.metalic) * (info1.emission + 1.0) * fakeEmission * info1.color * nfactor * 4.0 * dot(hd1, rd1);\n    reflCol = clamp(reflCol, 0.0, 1.0);\n}\n\n//Render-------------------------------------------------------------------\n\nvec3 mainTracer(vec3 rd0, vec3 rp0, in float seed)\n{\n    MatInfo info0 = getMatInfo(rp0);\n    vec3 normal = normal(rp0);\n    // reflection\n    const float fakeEmission = 20.0;\n    vec3 reflCol = vec3(0.0);\n    if(info0.roughness < 0.99)\n    {\n        calcReflectionCol(reflCol, info0.roughness, rd0, rp0, normal, fakeEmission, seed);\n    }\n    // diffuse&shadow\n    vec3 mixCol = vec3(0.0);\n    float mixLa = 1.0;\n    calcMixColAndShadow(mixCol, mixLa, rp0, rd0, normal, info0);\n\n    // result\n    vec3 sumCol = (info0.emission >= 1.0 ? 1.0 : info0.emission) * info0.color + reflCol * mixLa + mixCol;\n    return sumCol;\n}\n\n// vec3 subTracer(vec3 ro0, vec3 rd0, vec3 rp0, in float len0, in MatInfo info0, in float seed, bool isShadow)\n// {\n//     vec3 normal = normal(rp0);\n\n//     // diffuse&shadow\n//     vec3 mixCol = vec3(0.0);\n//     float mixLa = 0.0;\n//     calcMixColAndShadow(mixCol, mixLa, rp0, rd0, normal, info0, isShadow);\n\n//     // result\n//     vec3 sumCol = (info0.emission >= 1.0 ? 1.0 : info0.emission) * info0.color + mixCol;\n//     return clamp(sumCol, 0.0, 1.0);\n// }\n\n// dist,iswater\nfloat _stWater(vec3 p)\n{\n    float d = LenMax;\n    float a = 0.01;\n    float y = remap(sin(LocalTime * 0.25), -1.0, 1.0, -1.5, 1.5);\n    y = -6.0;\n    POORSC\n    {\n        y = mix(-0.6, 0.6, T);\n    }\n    float n = (2.0 * snoise(vec3(p.xz * 2.0, LocalTime)) - 1.0) * a;\n    y += n;\n    d = min(d, p.y - y);\n    return d;\n}\nvec3 _waterNormal(vec3 p)\n{\n    const float h = NormalEPS;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * _stWater(p + k.xyy * h) + k.yyx * _stWater(p + k.yyx * h) + k.yxy * _stWater(p + k.yxy * h) + k.xxx * _stWater(p + k.xxx * h));\n}\n\n// Intersect\nvoid calcIntersectPool(out vec3 rp0, out float len0, vec3 rd0, vec3 ro0)\n{\n    int i;\n    float dist = 0.0;\n    len0 = 0.0;\n    for(i = 0; i < LoopMax / 2; i++)\n    {\n        rp0 = ro0 + rd0 * len0;\n        dist = _stWater(rp0);\n        len0 += dist;\n        if(dist < DistMin || len0 > LenMax)\n        {\n            break;\n        }\n    }\n}\n\nfloat fresnel(float f0, float u)\n{\n    return clamp(f0 + (1.0 - f0) * pow(1.0 - u, 5.0), 0.0, 1.0);\n}\n\nvec3 superTracer(vec3 ro, vec3 rd, in float seed)\n{\n    vec3 resCol = vec3(0);\n    vec3 rporigin;\n    float lenorigin;\n    calcIntersect(rporigin, lenorigin, rd, ro);\n    resCol = mainTracer(rd, rporigin, seed);\n    if(_stWater(rporigin) > 0.0)\n    {\n        // intersect other\n        return resCol;\n    }\n\n    vec3 rp;\n    float len;\n    calcIntersectPool(rp, len, rd, ro);\n\n    vec3 normal = _waterNormal(rp);\n    vec3 reflCol = vec3(0.4), refrCol = vec3(0);\n    float vdotn = max(0.0, dot(-rd, normal));\n    float fresnel = fresnel(0.02, vdotn);\n\n    float len1 = lenorigin - len;\n    refrCol = resCol;\n\n    vec3 waterBaseCol = vec3(0.35, 0.1, 0.15);\n    const float density = 1.0, falloff = 0.5;\n    float fog = clamp(exp(-(len1 - falloff) * density), 0.0, 1.0);\n    refrCol = refrCol * mix(waterBaseCol, vec3(1.0), fog);\n\n    return mix(refrCol, reflCol, fresnel);\n}\n\nvoid setParameters(vec2 coord)\n{\n    #define LOOP_TIME 160.0\n    #define TIME_OFFSET 0.0\n    SCID[0] = 0.0;\n    SCID[1] = 20.0;\n    SCID[2] = 20.5;\n    SCID[3] = 35.0;\n    SCID[4] = 35.5;\n    SCID[5] = 50.0;\n    SCID[6] = 51.0;\n    SCID[7] = 53.0;\n    SCID[8] = 54.0;\n    SCID[9] = 70.0;\n    SCID[10] = 70.5;\n    SCID[11] = 85.0;\n    SCID[12] = 85.5;\n    SCID[13] = 105.0;\n    SCID[14] = 105.5;\n    SCID[15] = 125.0;\n    SCID[16] = 125.5;\n    SCID[17] = 150.0;\n    SCID[18] = 155.0;\n    SCID[19] = 160.0;\n    LocalTime = iTime + TIME_OFFSET;\n    ABSLocalTime = iTime + TIME_OFFSET;\n    LocalTime += (hash12(hash23(vec3(LocalTime, coord)))) * 0.005;\n    LocalTime = mod(LocalTime, LOOP_TIME);\n    ABSLocalTime = mod(ABSLocalTime, LOOP_TIME);\n    // LocalTime = ABSLocalTime = 70.0;\n}\n\nvoid getUVandSeed(out vec2 uv, out vec2 suv, out float seed, inout vec2 fragCoord)\n{\n    // CRT\n    uv = fragCoord / iResolution.xy;\n    POORSC\n    {\n        uv.x += uv.y < 0.01 ? (0.01 - uv.y) * 2.0 + noise11(ABSLocalTime * 50.0) * 0.05 : (hash11(floor(uv.y * 128.0 + hash11(mod(ABSLocalTime, hash11(floor(ABSLocalTime + 42.0)) * 4.0)) * 42.0)) - 0.5) * 0.0025;\n    }\n    fragCoord = uv * iResolution.xy;\n    vec2 taa = hash23(vec3(LocalTime, fragCoord)) - 0.5;\n    seed = hash12(taa * 42.0 - 0.42) * 42.0;\n    suv = (2.0 * (fragCoord + taa) - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvoid getRORD(out vec3 ro, out vec3 rd, vec2 suv)\n{\n    // Parameter\n    // #define CONTROLL_CAMERA\n    float fov = 90.0;\n    float fisheye = 0.0;\n    vec3 dir = vec3(0);\n    vec3 tebrue = (pattern(vec3(ABSLocalTime * 0.03, ABSLocalTime * 0.03 + 42.42, ABSLocalTime * 0.03 - 42.42)) - 0.5) * 0.07;\n\n    // CAMERA Sequence\n    SCI01(1)\n    {\n        float LT = pow(T, 0.5);\n        // dir\n        setCatmull(0, vec3(-.98387, -.17546, -.03472));\n        setCatmull(1, vec3(-.88153, -.11387, .45818));\n        setCatmull(2, vec3(-.8165, -.06842, .57326));\n        setCatmull(3, vec3(-.76864, -.32789, .54924));\n        setCatmull(4, vec3(-.43677, -.53729, .72147));\n        dir = normalize(getCatmull(5, LT));\n        // ro\n        setCatmull(0, vec3(6.9117, .6681, -2.5893));\n        setCatmull(1, vec3(6.9117, .6681, -5.0495));\n        setCatmull(2, vec3(.7727, .9317, -4.8827));\n        setCatmull(3, vec3(-3.6579, 3.2047, -3.5855));\n        setCatmull(4, vec3(-5.5876, 3.1361, -2.239));\n        ro = getCatmull(5, LT);\n    }\n    else SCI01(2)\n    {\n        dir = vec3(-.43677, -.53729, .72147);\n        ro = vec3(-5.5876, 3.1361, -2.239);\n    }\n    else SCI01(3)\n    {\n        float LT = T;\n        fov = 110.0;\n        // dir\n        setCatmull(0, vec3(.38601, .00619, -.92247));\n        setCatmull(1, vec3(-.93411, -.08463, -.3468));\n        setCatmull(2, vec3(-.8165, -.06842, .57326));\n        setCatmull(3, vec3(-.88438, .12164, .45061));\n        dir = normalize(getCatmull(4, LT));\n        // ro\n        setCatmull(0, vec3(-7.7526, 1.7481, -.656));\n        setCatmull(1, vec3(-6.2829, 1.7481, -1.1716));\n        setCatmull(2, vec3(-6.2829, 1.7481, -1.9093));\n        setCatmull(3, vec3(-5.3722, 1.5269, -4.4661));\n        ro = getCatmull(4, LT);\n    }\n    else SCI01(4)\n    {\n        fov = 110.0;\n        dir = vec3(-.88438, .12164, .45061);\n        ro = vec3(-5.3722, 1.5269, -4.4661);\n    }\n    else SCI01(5)\n    {\n        float LT = T;\n        fov = mix(110.0, 80.0, LT);\n        dir = mix(vec3(-.99341, -.11422, .00932), vec3(-.97075, -.23973, -.01275), LT);\n        ro = mix(vec3(-5.7884, 1.9151, -1.9602), vec3(-7.1226, 1.9617, -1.9573), LT);\n    }\n    else SCI01(9)\n    {\n        float LT = T;\n        fov = 100.0;\n        fisheye = 0.5;\n        // dir\n        setCatmull(0, vec3(.46515, -.61874, .63307));\n        setCatmull(1, vec3(-.19055, -.50834, .8398));\n        setCatmull(2, vec3(-.68175, -.72116, .123));\n        dir = normalize(getCatmull(3, LT));\n        // ro\n        setCatmull(0, vec3(1.6878, 3.6381, -5.4813));\n        setCatmull(1, vec3(1.6878, 3.6381, -5.4813));\n        setCatmull(2, vec3(1.6878, 3.6381, -5.4813));\n        ro = getCatmull(3, LT);\n        tebrue *= 0.0;\n    }\n    else SCI01(11)\n    {\n        float LT = T;\n        fov = 100.0;\n        fisheye = 0.5;\n        // dir\n        setCatmull(0, vec3(-.07618, -.31368, .94646));\n        setCatmull(1, vec3(-.99302, .10023, .06211));\n        setCatmull(2, vec3(-.26109, -.52743, -.80847));\n        dir = normalize(getCatmull(3, LT));\n        // ro\n        setCatmull(0, vec3(1.0689, .1884, 2.0751));\n        setCatmull(1, vec3(1.0689, .1884, 2.0751));\n        setCatmull(2, vec3(1.0689, .1884, 2.0751));\n        ro = getCatmull(3, LT);\n        tebrue *= 0.0;\n    }\n    else SCI01(13)\n    {\n        float LT = T;\n        // dir\n        setCatmull(0, vec3(-.96212, -.13568, .23644));\n        setCatmull(1, vec3(.07011, -.184113, -.98039));\n        setCatmull(2, vec3(.75603, -.50064, -.42162));\n        setCatmull(3, vec3(-.05268, -.75428, -.65442));\n        dir = normalize(getCatmull(4, LT));\n        // ro\n        setCatmull(0, vec3(-6.76, .9662, -2.9276));\n        setCatmull(1, vec3(-5.578, .9662, -2.9276));\n        setCatmull(2, vec3(-.841, 1.2763, -1.5016));\n        setCatmull(3, vec3(1.6679, 2.2187, -1.1792));\n        ro = getCatmull(4, LT);\n    }\n    else SCI01(15)\n    {\n        float LT = T;\n        fov = 130.0;\n        fisheye = 0.5;\n        // dir\n        setCatmull(0, vec3(.0103, -.92302, .3846));\n        setCatmull(1, vec3(-.6002, -.7992, .03217));\n        setCatmull(2, vec3(-.02958, -.74839, -.66259));\n        setCatmull(3, vec3(.5756, -.81758, -.01541));\n        dir = normalize(getCatmull(4, LT));\n        // ro\n        setCatmull(0, vec3(-3.1782, 3.1775, -1.7176));\n        setCatmull(1, vec3(-3.1782, 3.1775, -1.7176));\n        setCatmull(2, vec3(-3.1782, 3.1775, -1.7176));\n        setCatmull(3, vec3(-3.1782, 3.1775, -1.7176));\n        ro = getCatmull(4, LT);\n        tebrue *= 0.0;\n    }\n    else SCI01(17)\n    {\n        float LT = pow(T, 0.6);\n        // dir\n        setCatmull(0, vec3(-.98387, -.17535, .03513));\n        setCatmull(1, vec3(-.96224, -.09579, -.25476));\n        setCatmull(2, vec3(-.92195, -.13568, -.36274));\n        setCatmull(3, vec3(-.9816, -.11798, -.15008));\n        setCatmull(4, vec3(-.98534, -.16216, .05281));\n        setCatmull(5, vec3(-.96596, -.2581, .01724));\n        setCatmull(6, vec3(-.97057, -.24081, .0));\n        dir = normalize(getCatmull(7, LT));\n        // ro\n        setCatmull(0, vec3(6.1963, 1.0471, 4.8724));\n        setCatmull(1, vec3(2.9209, 1.0471, 4.8724));\n        setCatmull(2, vec3(-.13, 1.0471, 3.5894));\n        setCatmull(3, vec3(-2.5181, 1.6534, -0.3591));\n        setCatmull(4, vec3(-4.7409, 1.6534, -1.9903));\n        setCatmull(5, vec3(-6.4135, 1.9834, -1.9903));\n        setCatmull(6, vec3(-7.2869, 1.9834, -1.9903));\n        ro = getCatmull(7, LT);\n        tebrue *= mix(1.0, 0.0, LT);\n    }\n\n    #ifdef CONTROLL_CAMERA\n    ro = vec3(-7.7526, 1.7481, -.656) + GetCameraPosition();\n    vec2 mouse = 180.0 * (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    dir = vec3(0.0, 0.0, 1.0);\n    dir.yz = rot2d(dir.yz, -mouse.y * 0.5);\n    dir.xz = rot2d(dir.xz, -mouse.x);\n    dir = normalize(dir);\n    fov = 90.0 + GetAlpha();\n    #else\n    ro += tebrue;\n    #endif\n\n    float cr = 0.0;\n    vec3 cw = normalize(dir);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    float zf = 1.0 / tan(fov * PI / 360.0);\n    zf -= zf * length(suv) * fisheye;\n    rd = normalize(-cu * suv.x + cv * suv.y + cw * zf);\n}\n\nvoid postprocess1(inout vec3 sCol, vec2 uv)\n{\n    // RGB Motion Blur\n    float backstr = 0.5, srcstr = 0.5;\n    vec3 bs;\n    POORSC\n    {\n        float no = remapc(snoise(vec3(uv.y * 42.0, LocalTime, 0.0)), 0.0, 1.0, 0.5, 1.0);\n        float off = 0.005 * no;\n        bs = vec3(BackBuffer(uv + vec2(off, 0)).r, BackBuffer(uv).g, BackBuffer(uv - vec2(off, 0)).b);\n    }\n    else OPENINGSC\n    {\n        backstr = 0.8;\n        srcstr = 0.4;\n        const float gc = 5.0;\n        float gs = 0.0;\n        bs = vec3(0);\n        int blur = 2;\n        for(int x = -blur; x <= blur; x++)\n        {\n            for(int y = -blur; y <= blur; y++)\n            {\n                vec2 cd = vec2(x, y);\n                float l = length(cd);\n                float g = exp(-l * l / (2.0 * gc * gc));\n                bs += g * BackBuffer(uv + cd / iResolution.xy).rgb;\n                gs += g;\n            }\n        }\n        bs /= gs;\n    }\n    else\n    {\n        bs = BackBuffer(uv).rgb;\n    }\n\n    sCol = clamp(bs * backstr + sCol * srcstr, 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/7tK3zW\nvec3 liftGammaGain(vec3 rgb, vec4 LIFT, vec4 GAMMA, vec4 GAIN, vec3 LUMA)\n{\n    vec4 liftt = 1.0 - pow(1.0 - LIFT, log2(GAIN + 1.0));\n\n    vec4 gammat = GAMMA.rgba - vec4(0.0, 0.0, 0.0, dot(LUMA, GAMMA.rgb));\n    vec4 gammatTemp = 1.0 + 4.0 * abs(gammat);\n    gammat = mix(gammatTemp, 1.0 / gammatTemp, step(0.0, gammat));\n\n    vec3 col = rgb;\n    float luma = dot(LUMA, col);\n\n    col = pow(col, gammat.rgb);\n    col *= pow(GAIN.rgb, gammat.rgb);\n    col = max(mix(2.0 * liftt.rgb, vec3(1.0), col), 0.0);\n\n    luma = pow(luma, gammat.a);\n    luma *= pow(GAIN.a, gammat.a);\n    luma = max(mix(2.0 * liftt.a, 1.0, luma), 0.0);\n\n    col += luma - dot(LUMA, col);\n\n    return col;\n}\n\nvoid postprocess0(inout vec3 sCol, vec2 uv, float seed)\n{\n    OPENINGSC\n    {\n        sCol = clamp(pow(sCol + vec3(0.0, 0.0, 0.0), vec3(0.7)), 0.0, 1.0);\n    }\n    // ColorGrading\n    vec4 lift = vec4(-0.03, -0.01, 0.03, 0.0);\n    vec4 gamma = vec4(0.03, -0.01, -0.03, 0.0);\n    vec4 gain = vec4(1.02, 1.01, 1.02, 1.0);\n    vec3 luma = vec3(0.2126, 0.7152, 0.0722);\n    sCol = clamp(liftGammaGain(sCol, lift, gamma, gain, luma), 0.0, 1.0);\n    SCI01(18)\n    {\n        sCol = vec3(hash11(seed), hash11(seed + 42.), hash11(seed + 420.42)) * 0.5;\n    }\n    POORSC\n    {\n        // CRT\n        sCol *= mix(1.0, mix(0.7, 1.0, hash11(seed)), pow(noise11(uv.y * 10.0 + LocalTime * 3.0), 5.0));\n        // Vinette\n        sCol *= 1.0 - 0.3 * pow(remapc(length(uv - 0.5), 0.0, 0.5, 0.0, 1.0), 3.0);\n    }\n    sCol = clamp(sCol, 0.0, 1.0);\n}\n\nfloat uitext(vec2 uv)\n{\n    float col = 0.0;\n    vec2 leftup = vec2(0, res.y);\n    vec2 leftdown = vec2(0);\n    vec2 rightup = res;\n\n    // Play\n    print_pos = floor(leftup + vec2(STRWIDTH(4.0), -STRHEIGHT(3.0)));\n    col += char(ch_P, uv);\n    col += char(ch_L, uv);\n    col += char(ch_A, uv);\n    col += char(ch_Y, uv);\n\n    // REC\n    print_pos = floor(leftup + vec2(STRWIDTH(4.0), -STRHEIGHT(4.5)));\n    col += char(ch_R, uv);\n    col += char(ch_E, uv);\n    col += char(ch_C, uv);\n\n    // DATE\n    print_pos = floor(leftdown + vec2(STRWIDTH(4.0), STRHEIGHT(2.0)));\n    col += char(ch_A, uv);\n    col += char(ch_P, uv);\n    col += char(ch_R, uv);\n    col += char(ch_per, uv);\n    col += char(ch_spc, uv);\n    col += print_integer(29., 2, uv);\n    col += char(ch_spc, uv);\n    col += print_integer(4., 2, uv);\n    col += char(ch_spc, uv);\n    col += print_integer(2023., 4, uv);\n\n    // TIME\n    float t = ABSLocalTime;\n    float hour = floor(t / 60.0 / 60.0);\n    float minute = floor(mod(t / 60.0, 60.0));\n    float sec = floor(mod(t, 60.0));\n    print_pos = floor(rightup - vec2(STRWIDTH(12.0), STRHEIGHT(4.5)));\n    col += print_integer(hour, 2, uv);\n    col += char(ch_col, uv);\n    col += print_integer(minute, 2, uv);\n    col += char(ch_col, uv);\n    col += print_integer(sec, 2, uv);\n\n    return clamp(col, 0.0, 1.0);\n}\n\nfloat uishape0(vec2 uv)\n{\n    vec2 leftup = vec2(0, res.y);\n    vec2 anc = floor(leftup + vec2(STRWIDTH(9.0), -STRHEIGHT(3.0)));\n    vec2 luv = remap(uv - anc, vec2(0), vec2(STRWIDTH(1.0), STRHEIGHT(1.0)), vec2(0), vec2(1));\n    float col = 1.0;\n    col *= float(luv.x > 0.0);\n    col *= float(luv.y < -0.5 * luv.x + 1.0);\n    col *= float(luv.y > 0.5 * luv.x);\n    return col;\n}\n\nfloat uishape1(vec2 uv)\n{\n    vec2 leftup = vec2(0, res.y);\n    vec2 anc = floor(leftup + vec2(STRWIDTH(8.0), -STRHEIGHT(4.5)));\n    vec2 luv = remap(uv - anc, vec2(0), vec2(STRWIDTH(1.0), STRHEIGHT(1.0)), vec2(0), vec2(1));\n    luv -= 0.5;\n    luv.y /= STRWIDTH(1.0) / STRHEIGHT(1.0);\n    return float(length(luv) < 0.5) * float(mod(ABSLocalTime + .24, 2.0) < 1.0);\n}\n\n#define BATTERY_TIME 100.0\nfloat uishape2(vec2 uv)\n{\n    vec2 rightup = res;\n    vec2 anc = floor(rightup - vec2(STRWIDTH(8.0), STRHEIGHT(3.0)));\n    vec2 luv = remap(uv - anc, vec2(0), vec2(STRWIDTH(4.0), STRHEIGHT(1.0)), vec2(0), vec2(1));\n    float col = 1.0;\n    luv.y = (luv.y - 0.5) * (1.0 + float(luv.x < 0.1)) + 0.5;\n    float fx = 12. / 32., lx = 0.9 - 0.2 * fx, eps = 0.03;\n    float ti = float(mod(ABSLocalTime + .42, 2.0) < 1.0);\n    int lt = 0;\n    POORSC\n    {\n        lt = int(floor(4.0 - T * 4.0));\n    }\n    col *= float(luv.x > 0.0 && luv.x < 1.0 && luv.y > 0.0 && luv.y < 1.0);\n    col *= float(!(luv.x > 0.1 + 0.1 * fx && luv.x < 1.0 - 0.1 * fx && luv.y > 0.1 && luv.y < 0.9));\n    luv = (luv - 0.5) * 1.05 + 0.5;\n    col += float(luv.x > 0.1 + 0.1 * fx + lx * 3. / 4. + eps && luv.x < 1.0 - 0.1 * fx && luv.y > 0.1 && luv.y < 0.9) * (lt < 0 ? 0.0 : lt == 0 ? ti : 1.0);\n    col += float(luv.x > 0.1 + 0.1 * fx + lx * 2. / 4. + eps && luv.x < 0.1 + 0.1 * fx + lx * 3. / 4. && luv.y > 0.1 && luv.y < 0.9) * (lt < 1 ? 0.0 : lt == 1 ? ti : 1.0);\n    col += float(luv.x > 0.1 + 0.1 * fx + lx * 1. / 4. + eps && luv.x < 0.1 + 0.1 * fx + lx * 2. / 4. && luv.y > 0.1 && luv.y < 0.9) * (lt < 2 ? 0.0 : lt == 2 ? ti : 1.0);\n    col += float(luv.x > 0.1 + 0.1 * fx && luv.x < 0.1 + 0.1 * fx + lx * 1. / 4. && luv.y > 0.1 && luv.y < 0.9) * (lt < 3 ? 0.0 : lt == 3 ? ti : 1.0);\n    return col;\n}\n\n#define GLITCH float n = floor(noise11(uv.x * 20.0) * 5.0+1.0) / 6.0;vec2 off = vec2(0, n) * 0.2;sCol = BackBuffer(uv + off).rgb\n\nvoid overlay(inout vec3 sCol, vec2 uv, vec2 coord)\n{\n    // Overlay\n    POORSC\n    {\n        float alpha = 1.0;\n        SCI01(8)\n        {\n            alpha = mix(0.0, 1.0, T);\n        }\n        // for shadertoy\n        float ism = max(iResolution.x,iResolution.y);\n        float ds = remapc(ism,420.,1920.,1.,3.);\n        res = iResolution.xy / ds;\n        float pix = uitext(coord / ds) + uishape0(coord / ds);\n        sCol = mix(sCol, vec3(1), clamp(pix, 0.0, 1.0) * alpha);\n        pix = uishape1(coord / ds);\n        sCol = mix(sCol, vec3(1, 0, 0), clamp(pix, 0.0, 1.0) * alpha);\n        pix = uishape2(coord / ds);\n        sCol = mix(sCol, vec3(1), clamp(pix, 0.0, 1.0) * alpha);\n    }\n    // Glitch\n    SCI01(2)\n    {\n        GLITCH;\n    }\n    else SCI01(4)\n    {\n        GLITCH;\n    }\n    else SCI01(6)\n    {\n        GLITCH;\n    }\n    else SCI01(7)\n    {\n        sCol = vec3(0);\n    }\n    else SCI01(10)\n    {\n        GLITCH;\n    }\n    else SCI01(12)\n    {\n        GLITCH;\n    }\n    else SCI01(14)\n    {\n        GLITCH;\n    }\n    else SCI01(16)\n    {\n        GLITCH;\n    }\n    else SCI01(18)\n    {\n        print_pos = floor(iResolution.xy * 0.5 * 0.1 + vec2(-STRWIDTH(2.0), -STRHEIGHT(0.5)));\n        sCol = mix(sCol, vec3(1), char(ch_P, coord * 0.1));\n        sCol = mix(sCol, vec3(1), char(ch_O, coord * 0.1));\n        sCol = mix(sCol, vec3(1), char(ch_O, coord * 0.1));\n        sCol = mix(sCol, vec3(1), char(ch_L, coord * 0.1));\n    }\n    else SCI01(19)\n    {\n        sCol = vec3(0);\n    }\n\n    sCol = clamp(sCol, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // vec2 fragCoord = gl_FragCoord.xy;\n\n    setParameters(fragCoord);\n\n    // Get UV and Seed\n    float seed;\n    vec2 uv, suv;\n    getUVandSeed(uv, suv, seed, fragCoord);\n\n    // Camera\n    vec3 ro, rd;\n    getRORD(ro, rd, suv);\n\n    // Render\n    vec3 sCol = superTracer(ro, rd, seed);\n\n    // PostProcess\n    postprocess0(sCol, uv, seed);\n    postprocess1(sCol, uv);\n\n    // OverLay\n    overlay(sCol, uv, fragCoord);\n\n    // Output\n    fragColor = vec4(sCol, 1.0);\n    // outColor = vec4(sCol, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}