{"ver":"0.1","info":{"id":"McB3zh","date":"1703801106","viewed":163,"name":"raymarching the grid neighbors","username":"Elsio","description":"O estudo dos códigos beira o plágio, eu sei. Principalmente se eu não apresentar nada novo. \nmas meu objetivo é simplificar ao máximo do máximo para me concentrar só no entendimento da técnica. E quem sabe aprender mais alguma coisa nos comentários.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","grid","rectangle","prism","city","block","traversal","sparse","spiderman"],"hasliked":0,"parentid":"DdBfzt","parentname":"Cell-By-Cell Raymarching"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define hash21(p) fract(sin(mod(dot(p, vec2(27.609, 57.583)), 6.2831853)) * 43758.5453)\n#define box(p, b) length(max(abs(p) - (b), .0))    // problem??\n#define BLUE vec3(.2, .4, 1)\n#define RED BLUE.zxy\n#define GREEN BLUE.xzy\n#define FAR 20.\n\nvec3 cor;\nfloat gCD;\nvec2 gRd, q, id, B;\n\nvoid getGrid(vec2 p) {\n    \n    vec2 ip;\n\n    B = vec2(.5);\n    \n    ip = floor(p / B) + .5;\n\n    if(hash21(ip) < .25) {\n        B.x /= 2.;\n        ip.x = floor(p.x / B.x) + .5;\n    }\n\n    if(hash21(ip + .2) < .25) {\n        B.y /= 2.;\n        ip.y = floor(p.y / B.y) + .5;\n    }\n    \n    id = ip * B;\n    q  = p - id; \n}\n\n\nfloat map(vec3 p) {\n    // define q, id and B\n    getGrid(p.xy);\n    \n    // the magic!\n    vec2 r = (sign(gRd) * B * .5 - q) / gRd;\n    gCD = min(r.x, r.y) + .01;\n    //\n    \n    B -= hash21(id) * .2;\n    \n    float d1, d2, h;\n    h = dot(cos(id * .5), vec2(1, 2) / 4.);\n    \n    d1 = box(\n            vec3(q, p.z + h * (.25 + cos(iTime * hash21(id + .3) * 3.) * .4)), \n            vec3(B * .5, h));\n    \n    d2 = box(\n            vec3(q, p.z + h + .8), \n            vec3(B * .6 - .1, h/3.));\n    \n    hash21(id) < .15? cor = RED : cor = BLUE;\n    min(B.x, B.y) > .3 && hash21(id + .1) < .5\n        ? d1 = min(d1, d2)\n        : d1;\n    \n    return min(-p.z, d1);\n}\n\n\n\n\nfloat trace(vec3 ro, vec3 D) {\n    float d, t, i;\n    \n    gRd = D.xy;\n    \n    while(i++ < 128. && t < FAR) {\n        d = map(ro + t * D);\n        if(abs(d) < .001) \n            break;\n        t += min(d, gCD);\n    }\n\n    return min(t, FAR);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k) {\n    vec3 D = lp - ro;\n    float d = 1., t, shade = 1.,\n          end = max(length(D), .0001);\n    D /= end;\n    \n    gRd  = D.xy;\n    \n    int i;\n    while(i++ < 48 && t < end && d > 0.) \n        d = map(ro + D * t),\n        shade = min(shade, k * d / t),\n        t += clamp(min(d, gCD), .02, .25);\n\n    return max(shade, 0.);\n}\n\n// a mágica foi até aqui\n// todo o resto é código conhecido para exibir \n// este belíssimo (e ainda obscuro) map.\n\nfloat calcAO(vec3 p, vec3 n) {\n    float sca = 2., occ = 0., \n          i, hr, d;\n    \n    while(i++ < 5.) \n        hr = (i + 1.) * .125 / 5.,\n        d = map(p + n * hr),\n        occ += (hr - d) * sca,\n        sca *= .7;\n\n    return clamp(1. - occ, 0., 1.);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    u = (u - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 e = vec3(0, .001, 0),\n         p = vec3(iTime / 2., 0, -3),\n         lp = p + vec3(-1, 1, 1.),\n         lookAt = cos(iTime + vec3(11, 22, 0)) + vec3(0, 0, 8),\n    \n         fwd = normalize(lookAt),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x)),\n         up  = cross(fwd, rgt),\n         D   = normalize(u.x * rgt + u.y * up + fwd / 1.3);\n    \n    float sh, ao, atten, diff, spec,\n          d = trace(p, D);\n    \n    if(d < FAR) {\n        p += D * d;\n        \n        vec3 ld = lp - p,\n             N = normalize(\n                     vec3( map(p + e.yxx), \n                           map(p + e), \n                           map(p + e.xxy)) - map(p));\n        \n        float lDist = max(length(ld), .01);\n        ld /= lDist;\n        \n        sh = softShadow(p, lp, N, 16.);\n        ao = calcAO(p, N);\n        \n        atten = 2. / (1. + lDist * .125);\n        \n        diff = pow(max(dot(N, ld), 0.), 2.) * 2.;\n        spec = pow(max(dot(reflect(ld, N), D), 0.), 16.);\n        \n        o.rgb = ( cor\n                  + diff * sh \n                  + spec * .25\n                )  * ao * atten * .18;\n    }\n}\n\n\n/*\n    versão 3D by @Tater\n    https://www.shadertoy.com/view/7dVGDd\n    \n    versão @IQ (preciso estudar)\n    https://www.shadertoy.com/view/Msl3Rr  \n    \n    \n    versão @nimitz (preciso estudar)\n    https://www.shadertoy.com/view/XlfGDs\n\n*/ \n\n","name":"Image","description":"","type":"image"}]}