{"ver":"0.1","info":{"id":"tdKfWW","date":"1607182613","viewed":92,"name":"Shader Royale #2 - branch ","username":"Branch","description":"Shader coded live on stream for Shader Royale #2 (about 1h) - 4 december 2020","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["tripfest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ltlXRr","filepath":"https://soundcloud.com/lug00ber/flipside-lug00ber-lovin-u","previewfilepath":"https://soundcloud.com/lug00ber/flipside-lug00ber-lovin-u","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdSphere(vec3 p, float s){ \n  return length(p) - s;\n}\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p) {\n  float d = 1e10;\n  float t= mod(iTime,20.);\n  for(float i=1.0; i < 32.; i++) {\n    p.z *= 0.1;\n    if(t<5.0) {\n      p.x += sin(p.z * 12. + iTime + i) * i;  // state 0\n      p.y += cos(p.z * 12. + iTime + i) * i;  // state 1\n      d = min(d, sdSphere(p, 0.5 + sin(i * 12. + iTime + p.z) + texture(iChannel0,vec2(0.3)).x*12.));\n    }\n    else if(t<10.0) {\n      float angle = i/32. + (p.z * 12.) * 0.2;\n      float s= sin(angle);\n      float c =cos(angle);\n      mat2 rotMat = mat2(c,s,-s,c);\n      p.xy *= rotMat;\n      p.x += sin(p.z * 12. + iTime + i) * i;  // state 0\n      p.y += cos(p.z * 12. + iTime + i) * i;  // state 1\n      \n      d = min(d, sdBox(p, vec3(    0.2 + sin(i * 3. + iTime + p.z)  )  + texture(iChannel0,vec2(0.1)).x*0.3  ));\n    } \n    else if(t<15.0) {\n      float angle = i/32. + (p.z * 12.) * 0.2;\n      float s= sin(angle);\n      float c =cos(angle);\n      mat2 rotMat = mat2(c,s,-s,c);\n      p.xy *= rotMat;\n      p.x += sin(p.z * 12.) * min(p.z*0.2,6.);  // state 0\n      p.y += cos(p.z * 12.) * min(p.z*0.2,6.);  // state 1\n      \n      d = min(d, sdBox(p, vec3(    0.2 + sin(i * 3. + iTime + p.z) + texture(iChannel0,vec2(0.3)).x*1.2 )   ));\n    } else {\n      p.x += sin(p.z * 12. + iTime + i);  // state 0\n      p.y += cos(p.z * 12. + iTime + i) * i * 0.2;  // state 1\n      d = min(d, sdSphere(p, 0.5 ));\n    }\n    \n  }\n  return d;\n}\n\nfloat rand(vec2 c) {\n  return fract(sin(dot(c.xy,vec2(12.9898,78.233))) * 41231.51222); \n  //i don't remember exactly... hopefully this is good enough\n  \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  vec2 uv2=uv;\n  float vessa = mod(iTime*2.,13.121);\n  if(vessa<3.0) { \n    uv += 0.333;\n  }\n  if(vessa>10.0) { \n    uv -= 0.333;\n  }\n  float kickoff = floor(mod(iTime,12.0)); \n  if(kickoff < 2.) { \n    kickoff = 12.;\n  }\n  if(kickoff < 4.) { \n    kickoff = -1.;\n  }\n  if(mod(iTime*0.6,12.0)<3.0) { \n    float angle = rand(floor(uv*1.5 + 0.5)) * 3. + iTime * 4.;\n    float s= sin(angle);\n    float c =cos(angle);\n    mat2 rotMat = mat2(c,s,-s,c);\n    uv *=rotMat;\n  }\n  \n  \n  float vignette = 1.0 / max( 0.25 + 0.9 * dot(uv,uv), 1.0);\n  vec3 rayOrigin = vec3(0.);\n  vec3 rayDirection = normalize(vec3(uv*(1.333 - 0.1*sin(iTime+length(uv) * 0.2) +  kickoff),1.0));\n  vec3 col = vec3(0.0);\n  float dist = 0.0;\n  float t = 0.01;\n  float d;\n  vec3 p = vec3(0.0);\n  \n  \n  \n  for(int i=0; i <32; i++) {\n    p = rayOrigin + t * rayDirection;\n    d = map(p);\n    t +=d;\n      if(t>32.0){\n          continue;\n      }\n    \n  }\n  if(d < 0.01) {\n    col = vec3(1.0) * floor(mod(p.z*2. + iTime * 12., 2.0));\n    col = mix(col, vec3(0.0), max(0.0, p.z - 5. ) * 0.2);\n  }\n  float homer = mod(iTime*0.333 + floor(mod(uv2.x + 0.5,2.0)),4.);\n  if(homer<1.0) {\n    col = vec3(1.0,0.5,0.7) - col;\n  }\n  if(homer<2.0) {\n    col = vec3(0.5,0.2,0.7) - col;\n  }\n  if(homer<3.0) {\n    col = vec3(0.5,0.7,0.7) * col;\n  }\n  if(length(uv2.x)<0.80 ) {\n    if(length(uv2.x)>0.795) {\n      col = vec3(0.15);\n    }\n  }\n  if(length(uv2.y)<0.47 ) {\n    if(length(uv2.y)>0.465) {\n      col = vec3(0.15);\n    }\n  }\n  if(mod(iTime*12.32,4.)<1.0 && mod(iTime*1.2,12.) < 2.0) {\n    col.r = floor(col.r*3.) / 2.;\n    col.g = floor(col.g*3.) / 2.;\n    col.b  = floor(col.b*3.) / 2.;\n  }\n    fragColor = vec4(col,1.0) * vignette + rand(uv2 + mod(iTime*12.,3.0))*0.13 ;\n}","name":"Image","description":"","type":"image"}]}