{"ver":"0.1","info":{"id":"lXBfDd","date":"1730128276","viewed":58,"name":"alogz+bz^2+c","username":"pb","description":"1.09*log(z)-.09*z^2+(.9,0)","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["fractal","log"],"hasliked":0,"parentid":"X3BBDd","parentname":"embossed"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nfloat[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n);\n\n//taking input and output of iterated functions from Buffer A\n//and mixing them up here\nvoid mainImage(out vec4 O, vec2 u) {\n\n    vec2 R = iResolution.xy,\n        uv = u/R;\n    float Rxy=length(R);\n\n    O *= 0.;\n\n    //fake lighting by pretending z,f(z) is a 3d point and taking\n    //cross product using nearby points\n    vec2 tex = 1./R.xy;\n    float one_pixel = 1.3/Rxy,\n          pix = one_pixel/sqrt(2.),\n          wgt = 0.;\n          \n    for (int i=0; i<5; i++) {\n        for (int j=0; j<5; j++) {                             \n            vec4 x2 =  texture(iChannel0,uv+vec2( 0.0,  one_pixel) + vec2( i-2,j-2 ) * tex),\n                 x3 =  texture(iChannel0,uv+vec2( pix, pix) + vec2( i-2,j-2 ) * tex),\n                 x4 =  texture(iChannel0,uv+vec2( 0.0, -one_pixel) + vec2( i-2,j-2 ) * tex);\n\n            float a = x3.x*x2.y - x3.y*x2.x,\n                  c = x3.x*x2.z - x3.z*x2.x,\n                  e = x3.y*x2.z - x3.z*x2.y;\n\n            wgt += gk1s[i*5 + j] * ( (a*x4.z - c*x4.y + e*x4.x) ) ;\n        }\n    }\n\n    float  yyy = .3 - wgt*Rxy*Rxy/1200.;\n    vec4 actual_pixel = texture(iChannel0, uv);\n    \n    float zzz = .8*sin( 1.5*actual_pixel.z);\n\n    vec3 cc = vec3(1,.8,0)*yyy + zzz*zzz*vec3(.7,.6,0);\n    \n    O = vec4( cc, 0.);\n    \n    O = 1. - exp(-sqrt(O));\n  \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// philip.bertani@gmail.com\n#define t mod(iTime,60.)\n#define too_small 1e-7\n\n//Fabrice: I could not get a golfed version working :(\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y, \n         \n         center = vec2(50.*t,0 ), \n         width = vec2(1000.-150.*sqrt(t)),\n         z = uv * width + center ; \n    \n    float max_iter=200., infinity=1e3,\n          escape_value=0., distance=0.,\n          r=.9,an=0.;  //the Julia set params, play with it\n          \n    vec2 jc = vec2(r*cos(an),r*sin(an));\n\n    float invert = 1./max(z.x*z.x+z.y*z.y,too_small);    \n    z *= invert;\n    \n    for ( float i=0.; i<max_iter; i++ ) {\n    \n        float r = max(length(z),too_small);\n        float theta = atan(z.y/z.x); //the \"wrong\" atan works better\n         \n        z = mix(vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y),\n                vec2(log(r),theta),\n                1.09) + jc;\n                \n        distance = z.x*z.x + z.y*z.y;\n\n        if ( distance > infinity ) {\n            escape_value = i;\n            break;\n        }        \n    }\n     \n    fragColor = escape_value==0.\n        ?vec4(uv,log(distance)/2.,0)\n        :vec4(0);\n}\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}