{"ver":"0.1","info":{"id":"MtBfzV","date":"1516490831","viewed":1562,"name":"Recursive Voronoi Geometry","username":"fizzer","description":"Uses recursion to create irregular voronoi cells, and to create a close approximation of soft shadowing from disc-like lightsources. Ray intersections are computed with ray-versus-plane, not raymarching!","likes":92,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","voronoi","softshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float pi=acos(-1.);\nconst int n=3;\nconst float ssd=1.7;\nconst int maxdepth=7;\n\nfloat depth=0.;\nfloat index=0.;\nfloat h0=0.,h1=-.1;\n\nvec2 ps[n];\nint j=0;\n\nvec2 point(vec2 q, int k)\n{\n    return vec2(cos((float(k)+.5)/float(n)*pi*2.+float(index)*2.),sin((float(k)+.5)/float(n)*pi*2.))+vec2(0.,.5);\n}\n\nvoid populatePoints(vec2 p,float ss)\n{\n    float md=1e4;\n    for(int k=0;k<n;++k)\n    {\n        ps[k]=point(p, k);\n        ps[k]*=ss;\n        float d = distance(ps[k], p);\n        if(d<md)\n        {\n            md=d;\n            j=k;\n        }\n    }\n}\n\nfloat shadow(vec3 hitp,vec3 ld,float softness)\n{\n    float shadt=(h0-hitp.z)/ld.z;\n    vec3 shadp=hitp+ld*shadt;\n    float r=softness*shadt;\n    float dd=0.;\n    float ss=1.;\n    depth=0.;\n    index=0.;\n\n    for(int i=0;i<maxdepth;++i)\n    {\n        if(cos(float(index)*239.)<-.8)break;\n\n        populatePoints(hitp.xy, ss);\n\n        for(int k=0;k<n;++k)\n            if(k!=j)\n                dd+=pow(min(0.,-r/2.+dot(shadp.xy-(ps[j]+ps[k])/2.,normalize(ps[j]-ps[k]))),2.);   \n\n            shadp.xy-=ps[j];\n        hitp.xy-=ps[j];\n        ss/=ssd;\n\n        index=index*float(n)+float(j);\n        depth+=1.;\n    }\n    return 1.-clamp(sqrt(dd)/r,0.,1.);\n}\n\nfloat light(vec3 hitp,vec3 ld,vec3 hitnorm,float softness)\n{\n    return max(0.,.5+.5*dot(ld,hitnorm))*pow(shadow(hitp,ld,softness),2.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 t=uv*2.-1.;\n   \tt.y/=iResolution.x/iResolution.y;\n    vec3 ro=vec3(cos(iTime/10.)+.1,0.3,1.1),oro=ro;\n    vec3 rd=normalize(vec3(t.xy,-1.));\n\n    float t0=(h0-ro.z)/rd.z;\n    float t1=(h1-ro.z)/rd.z;\n\n    ro+=rd*t0;\n\n    float ppt=t1-t0;\n\n    vec3 floornorm=vec3(0,0,1);\n    vec3 hitnorm=floornorm;\n\n    float ss=1.;\n    depth=0.;\n    index=0.;\n    float dd=1e3;\n    for(int i=0;i<maxdepth;++i)\n    {\n        if(cos(float(index)*239.)<-.8)break;\n\n        populatePoints(ro.xy, ss);\n\n        for(int k=0;k<n;++k)\n        {\n            if(k!=j)\n            {\n                vec4 plane;\n                plane.xy=-normalize(ps[k]-ps[j]);\n                plane.z=0.;\n                float thickness=.0015;\n                plane.w=dot((ps[j]+ps[k])/2., plane.xy)+thickness;\n                dd=min(dd,-thickness+dot(ro.xy-(ps[j]+ps[k])/2.,plane.xy));\n                float pt=(plane.w-dot(ro,plane.xyz))/dot(rd,plane.xyz);\n                if(dot(rd,plane.xyz)<0.&&pt<ppt)\n                {\n                    ppt=pt;\n                    hitnorm=plane.xyz;\n                }\n            }\n        }      \n\n        ro.xy-=ps[j];\n        ss/=ssd;\n\n        index=index*float(n)+float(j);\n        depth+=1.;\n        if(dd<0.){ppt=0.;hitnorm=floornorm;break;}\n\n    }\n    ppt+=t0;\n    vec3 hitp=oro+rd*ppt;\n\n    vec3 diff=mix(vec3(.5,.75,1),vec3(1,1.,.5),.5+.5*cos(index));\n\n    diff=mix(diff,vec3(1./1.5),1.-clamp(dd/.001,0.,1.));\n    \n  \tvec3 diffm=vec3(1);\n    \n    if(hitnorm.z>.0)\n\t\tdiffm=texture(iChannel0,hitp.xy).rgb;\n    else\n\t\tdiffm=texture(iChannel0,2.*vec2(dot(hitp.xy,normalize(vec2(hitnorm.y,-hitnorm.x))),hitp.z/2.)).rgb;\n    \n    diff*=mix(diffm,vec3(1),.4);\n    diff=mix(diff,vec3(dot(diff,vec3(1./3.))),.13);\n    //diff=diffm;\n    \n    fragColor.rgb=vec3(0);\n    fragColor.rgb+=diff*light(hitp,normalize(vec3(1.,.5,.7)),hitnorm,.2)*vec3(1.,1.,.8)*\n        (.3+smoothstep(.05,.3,abs(fract((hitp.y*6.+hitp.x)*.7)-.5)));\n    fragColor.rgb+=diff*pow(light(hitp,normalize(vec3(-.1,0.,7)),hitnorm,2.5)/1.,.5)/3.*vec3(.8,.9,1.);\n\n    fragColor.rgb*=exp(-length(hitp.xy-oro.xy)/4.);\n    fragColor.rgb*=1.5;\n    fragColor.rgb+=.01*vec3(1,1,.7);\n    fragColor.rgb=pow(fragColor.rgb*1.,vec3(1./2.4));\n}","name":"Image","description":"","type":"image"}]}