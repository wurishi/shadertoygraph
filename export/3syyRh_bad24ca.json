{"ver":"0.1","info":{"id":"3syyRh","date":"1604267701","viewed":103,"name":"LifeBlob - YannSitu","username":"YannSitu","description":"Blob pour le cours de modélisation géométrique.\nM2 ID3D.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["modelisationgeometrique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.0;\nfloat lipshitz_constant = 1.;\nfloat phase1 = 10.; // 8 seconds\nfloat phase2 = 1.5;\nfloat phase3 = 8.;\nfloat phase4 = 5.;\n\nconst vec3 white = vec3(1.,1.,1.);\nconst vec3 black = vec3(0.,0.,0.);\nconst vec3 red = vec3(1.,0.,0.);\nconst vec3 blue = vec3(0.,0.,1.);\nconst vec3 green = vec3(0.,1.,0.);\nconst vec3 magenta = vec3(1.,0.,1.);\nconst vec3 cyan = vec3(0.,1.,1.);\nconst vec3 yellow = vec3(1.,1.,0.);\nconst vec3 superwhite = vec3(1.8,1.7,1.5);\nconst vec3 brown = vec3(0.792,0.41,0.3);\nconst vec3 lightbrown = vec3(0.992,0.997,0.65);\nconst vec3 darkbrown = vec3(0.52,0.37,0.25);\nconst vec3 darkred = vec3(0.8,0.1,0.3);\nconst vec3 lightred = vec3(1.0,0.4,0.6);\n\nvec3 bg_col1 = brown;\nvec3 bg_col2 = lightbrown;\n////////////////\n// Primitives //\n////////////////\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// R : radius\nfloat Point(vec3 p, vec3 c, float R)\n{\n    vec3 pc = p-c;\n    return falloff2(dot(pc,pc),R*R);\n}\n\n// NoisyPoint skeleton\n// p : point\n// c : center of skeleton\n// noise_amplitude\n// R : radius\n// -> noisy point primitive that could be not connexe\nfloat NoisyPoint(vec3 p, vec3 c, float noise_amplitude, float noise_scale, float R)\n{\n    vec3 pc = p-c;\n    return (falloff2(dot(pc,pc),R*R))+noise_amplitude*noise3D(noise_scale*p);\n\n}\n\n// NoisyScalePoint skeleton\n// p : point\n// c : center of skeleton\n// noise_amplitude\n// noise_scale\n// nb_harmonics\n// R : radius\n// -> noisy point primitive that is connexe and with direction\nfloat NoisyScalePoint(vec3 p, vec3 c, float noise_amplitude, float noise_scale, int nb_harmonics, float R)\n{\n    vec3 pc = p-c;\n    return scale_noise_falloff(pc, noise_amplitude, noise_scale, nb_harmonics, R);\n}\n\n// pave skeleton\n// p : point\n// c : center of skeleton\n// n : norm indices (n=2 gives euclidean distance so ellipsoide)\n// s : (sx,sy,sz) scale of each side\n// o : orientation\n// R : radius\n// -> generalisation of the point primitive, with L_x norm, scaling and orientation\nfloat Pave(vec3 p, vec3 c, float n, vec3 s, vec3 o, float R)\n{\n    vec3 pc = p-c;\n    pc = rotateX(pc, o.x);\n    pc = rotateY(pc, o.y);\n    pc = rotateZ(pc, o.z);\n    float dist = pow(pow(pc.x*s.x,n)+pow(pc.y*s.y,n)+pow(pc.z*s.z,n), 1./n);\n    return falloff(dist,R);\n}\n\n// Segment skeleton\n// p  : point\n// p0 : point of Segment\n// p1 : point of Segment\n// R : radius\nfloat Segment(vec3 p, vec3 p0, vec3 p1, float R)\n{\n    vec3 p10 = (p1-p0);\n    vec3 pp0 = p-p0;\n    float lp10 = length(p10);\n    float lp0h = dot(pp0, 1.0/lp10 * p10);\n    if (lp0h < 0.0)\n        return falloff2(dot(pp0,pp0),R*R);\n    if (lp0h > lp10)\n    \treturn falloff(length(p-p1),R);\n    return falloff2(dot(pp0,pp0)-lp0h*lp0h,R*R);\n}\n\n// NoisyScaleSegment skeleton\n// p  : point\n// p0 : point of Segment\n// p1 : point of Segment\n// noise_amplitude\n// noise_scale\n// nb_harmonics\n// R : radius\nfloat NoisyScaleSegment(vec3 p, vec3 p0, vec3 p1, float noise_amplitude, float noise_scale, int nb_harmonics, float R)\n{\n    vec3 p10 = (p1-p0);\n    vec3 pp0 = p-p0;\n    float lp10 = length(p10);\n    vec3 normalize_p10 = 1.0/lp10 * p10;\n    float lp0h = dot(pp0, normalize_p10);\n    if (lp0h < 0.0)\n        return scale_noise_falloff_seed(pp0, noise_amplitude, noise_scale, nb_harmonics, R, p0);\n    if (lp0h > lp10)\n        return scale_noise_falloff_seed(p-p1, noise_amplitude, noise_scale, nb_harmonics, R, p1);\n    vec3 h = p0+lp0h*normalize_p10;\n    return scale_noise_falloff_seed(p-h, noise_amplitude, noise_scale, nb_harmonics, R, h);\n}\n\n// circle skeleton\n// p  : point\n// p0 : point center\n// n : normal\n// rad : radius of the disk\n// R : radius\nfloat circle(vec3 p, vec3 p0, vec3 n, float rad, float R)\n{\n    vec3 pp0 = (p-p0);\n    float h = dot(pp0, normalize(n));\n    float r = rad-sqrt(dot(pp0,pp0) - h*h);\n    return falloff2(h*h+r*r,R*R);\n}\n\n// disk skeleton\n// p  : point\n// p0 : point center\n// n : normal\n// rad : radius of the disk\n// R : radius\nfloat disk(vec3 p, vec3 p0, vec3 n, float rad, float R)\n{\n    vec3 pp0 = (p-p0);\n    float h = dot(pp0, n);\n    float r = sqrt(dot(pp0,pp0) - h*h) - rad;\n    if (r < 0.)\n    {\n        return falloff(abs(h),R);\n    }\n\n    return falloff2(h*h+r*r,R*R);\n}\n\n// circlearc skeleton\n// p  : point\n// c : point center\n// n : normal\n// p0 : point for the beginning of the arc\n// angle : max angle of the arc\n// R : radius\nfloat circlearc(vec3 p, vec3 c, vec3 n, vec3 p0, float angle, float R)\n{\n    vec3 p0c = p0-c;\n    float hp0 = dot(p0c, n);\n    vec3 c0 = c + hp0*n ; /* projection du centre c dans le plan de normal n,\n    * passant par p0*/\n    vec3 pc0 = (p-c0);\n    vec3 p0c0 = (p0-c0);\n    vec3 e1 = normalize(p0c0);\n    vec3 e2 = cross(n, e1);\n    float l = dot(pc0,e1); // can be negatif or positif\n    float L = dot(pc0,e2); // triangle rect entre l L et r\n    float theta = atan(L,l); // to get the angle\n    if (theta < 0.)\n    {   theta = theta + 2.* 3.14159265;}\n\n    if (theta > 3.14159265 + angle/2.)\n    {\n        return falloff(length(p-p0),R);\n    }\n    else if (theta > angle)\n    {\n        vec3 maxangle_pt = c0 + length(p0c0)*(cos(angle)*e1 + sin(angle)*e2);\n        /* pour le point extremum de l'arc : on se place en c0 et dans le\n        * plan défini par m (vecteur unitaire de (p0-c0)) et cross(e1,e2)\n        * (vecteur unitaire perpendiculaire à e1 et e2)*/\n        return falloff(length(p-maxangle_pt),R);\n    }\n    else // case between 0 an angle\n    {\n        float h = dot(pc0, n);\n        float h2=h*h;\n        float rrad = sqrt(dot(pc0,pc0) - h2) - length(p0c0);\n        /* on fait comme le cercle */\n        return falloff2(h2+rrad*rrad,R*R);\n    }\n}\n\n// SegmentRotation skeleton\n// p  : point\n// c : origin of the symetry axe\n// n : direction of the symetry axe\n// p0 : 2D point of the beginning of the segment\n// p1 : 2D point of the end of the segment\n// R : radius\nfloat SegmentRotation(vec3 p, vec3 c, vec3 n, vec2 p0, vec2 p1, float R)\n{\n    vec3 pc = p-c;\n    n = normalize(n);\n    vec3 m = normalize(cross(cross(n,pc),n)); // p is in the plane of origin c and directios (n,m)\n\n    vec2 pc2D = vec2(dot(pc,m),dot(pc,n));\n\n    vec2 p10 = (p1-p0);\n    vec2 pc2Dp0 = pc2D-p0;\n    float lp10 = length(p10);\n    float lp0h = dot(pc2Dp0, 1.0/lp10 * p10);\n    if (lp0h < 0.0)\n        return falloff2(dot(pc2Dp0,pc2Dp0),R*R);\n    if (lp0h > lp10)\n    \treturn falloff(length(pc2D-p1),R);\n    return falloff2(dot(pc2Dp0,pc2Dp0)-lp0h*lp0h,R*R);\n}\n\n///////////////\n// Operators //\n///////////////\n\n// Blending\n// a,b : field function of the sub-trees\nvec4 Blend(vec4 a,vec4 b)\n{\n    float s = a.a+b.a;\n    return vec4(mix(a.rgb,b.rgb,(b.a)/(s+0.0001)),s);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 Union(vec4 a,vec4 b)\n{\n    if (a.a > b.a)\n    {\n        return a;\n    }\n    return b;\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 Intersection(vec4 a,vec4 b)\n{\n    if (a.a < b.a)\n    {\n        return vec4(0.5*(a.rgb+b.rgb),a.a);\n    }\n    return vec4(0.5*(a.rgb+b.rgb),b.a);\n}\n\n// ColorInfluence_Blend\n// a : field function that remains\n// b : field function that influence a with a blend\nvec4 ColorInfluence_Blend(vec4 a,vec4 b)\n{\n    return vec4(mix(a.rgb,b.rgb,(b.a)/(a.a+b.a)),a.a);\n}\n\n// ColorInfluence_Inter\n// a : field function that remains\n// b : field function that influence a with an intersection\nvec4 ColorInfluence_Inter(vec4 a,vec4 b)\n{\n    if (a.a > b.a)\n    {\n        return a;\n    }\n    return vec4(b.rgb,a.a);\n}\n\n// BiColorNoise skeleton : return a color\n// p : point\n// col1 : first color\n// col2 : second color\n// noise_scale\nvec3 BiColorNoise(vec3 p, vec3 col1, vec3 col2, float noise_scale)\n{\n    return mix(col1, col2, noise3D(noise_scale*p));\n}\n\n//============================================================================//\nvec4 Scene1(vec3 p, float t)\n{\n    int nb_balls = 8;\n\n    float time_step = 0.85;\n    float t_iter = 0.5;\n    float t_convergence = 4.;\n    float R = 1.2;\n\n    vec4 environment = Union(\n        vec4(superwhite, Point(p, vec3(0.,0.,0.), 5.)),\n        vec4(black,\n            falloff(p.z-\n                (1.4*noise3D(0.2*vec3(0.,p.x+1.802*iTime,p.y))\n                +0.4*noise3D(0.4*vec3(0.,p.x+0.978*iTime,p.y+2.417*iTime))\n                )+8.,1.))\n            );// a noisy plane\n    vec4 v = vec4(0.,0.,0.,0.);\n    for (int i = 0; i<nb_balls ; i++)\n    {\n        if (t > t_iter) {\n            // create ball\n            if (t <= t_iter+t_convergence)\n            {\n                float t_dep = t-t_iter;\n                float t_i = (t_dep/t_convergence);\n                float coeff = 2.*t_i*t_i;\n                float randspeed = 2.*Hash(t_iter);\n                float angle = 3.14155*Hash(t_iter+1324.7);\n                if (randspeed < 0.)\n                  randspeed -= 3.5;\n                else\n                  randspeed += 3.5;\n\n                float c1 = cos(coeff*randspeed*(t_dep)); float s1 = sin(coeff*randspeed*(t_dep));\n                float c0 = cos(angle); float s0 = sin(angle);\n                vec3 pos = vec3(0.,0.,-1);\n                pos.yz = vec2(c1*pos.y - s1*pos.z, s1*pos.y + c1*pos.z);\n                //pos.xz = vec2(c1*pos.x + s1*pos.z, -s1*pos.x + c1*pos.z);\n                pos.xy = vec2(c0*pos.x + s0*pos.y, -s0*pos.x + c0*pos.y);\n                t_i -= 1.;\n                t_i *= t_i; // between 0 and 1 (0 is at the end)\n                v = Union(v,\n                    vec4(black, Point(p, (14.*t_i)*pos, R+0.1*angle))\n                    //vec4(mix(black, superwhite, 1.-t_i), Point(p, (16.*t_i)*pos, R))\n                    );\n            }\n            t_iter += time_step;\n        }\n        else {\n            break;\n        }\n    }\n    v = Blend(v,environment);\n    return vec4(v.rgb, v.a-T);\n}\n\nvec4 Scene2(vec3 p, float t)\n{\n    float time_step = 0.85;\n    float t_abs = t/phase2;\n    float R = 1.2;\n    bg_col1 = mix(brown, darkbrown, t_abs);\n    bg_col2 = mix(lightbrown, black, t_abs);\n    vec4 environment = Union(\n        vec4(mix(superwhite, darkred, t_abs), Point(p, vec3(0.,0.,0.), 5.)),\n        vec4(mix(black, mix(black,brown, 0.2*floor(5.*(1.8-(8.+p.z))/1.8)), t_abs),\n            falloff(p.z-\n                (1.4*noise3D(0.2*vec3(0.,p.x+1.802*iTime,p.y))\n                +0.4*noise3D(0.4*vec3(0.,p.x+0.978*iTime,p.y+2.417*iTime))\n                )+8.,1.))\n            );// a noisy plane\n    vec4 v = environment;\n    return vec4(v.rgb, v.a-T);\n}\n\nvec4 Scene3(vec3 p, float t)\n{\n    float time_step = 0.85;\n    float t_abs = t/phase3;\n    float R = 1.2;\n    bg_col1 = darkbrown;\n    bg_col2 = black;\n\n    // heart beat function test\n    float i = mod(floor(5.*8.*t_abs-0.5)+0.5,5.); float f = 1.-fract(5.*8.*t_abs-0.5);\n    float u = 0.0;\n    if (i>3.)\n    {\n        u = f*f;\n        u = 4.*(1.-u)*u;\n    }\n\n    vec4 environment = Union(\n        vec4(mix(darkred, lightred, u), NoisyScalePoint(p, vec3(0.,0.,0.), 0.06*u*t_abs, 7.*t_abs, 2, 5.+5.*(1.9*t_abs*t_abs+0.1)*(t_abs)+1.*u)),\n        vec4(mix(black,brown, 0.2*floor(5.*(1.8-(8.+p.z))/1.8)),\n            falloff(p.z-\n                (1.4*noise3D(0.2*vec3(0.,p.x+1.802*iTime,p.y))\n                +0.4*noise3D(0.4*vec3(0.,p.x+0.978*iTime,p.y+2.417*iTime))\n                )+8.,1.))\n            );// a noisy plane\n    vec4 v = environment;\n    return vec4(v.rgb, v.a-T);\n}\n\nvec4 Scene4(vec3 p, float t)\n{\n    float time_step = 0.85;\n    float t_abs = t/phase4;\n    float t_abs2 = t_abs*t_abs;\n    float t_abs4 = t_abs2*t_abs2;\n    float t_absm = (1.-2.*t_abs);\n    t_absm = t_absm*t_absm;\n    t_absm = t_absm*t_absm;\n    if(t_abs < 0.1)\n    {\n        t_absm = t_absm*t_absm;\n        t_absm = t_absm*t_absm;\n    }\n    float R = 0.8;\n    bg_col1 = mix(darkbrown, brown, t_abs4);\n    bg_col2 = mix(black, lightbrown, t_abs4);\n\n    vec4 environment = Union(\n        vec4(mix(lightred, superwhite,t_abs2), Point(p, vec3(0.,0.,0.), 15.-10.*(t_absm+t_abs4))),\n        vec4(mix(mix(black,brown, 0.2*floor(5.*(1.8-(8.+p.z))/1.8)), black, t_abs4),\n            falloff(p.z-\n                (1.4*noise3D(0.2*vec3(0.,p.x+1.802*iTime,p.y))\n                +0.4*noise3D(0.4*vec3(0.,p.x+0.978*iTime,p.y+2.417*iTime))\n                )+8.,1.))\n            );// a noisy plane\n    vec4 v = environment;\n    if (t_abs < 0.8)\n    {\n    vec4 anneau = Union(\n        vec4(mix(lightred, superwhite,t_abs2) ,circle(p, vec3(0.), vec3(0.08,-0.05,1.), 23.*t_abs, 0.7*R*(t_abs2-0.8*0.8))),\n        vec4(mix(lightred, superwhite,t_abs2) ,circle(p, vec3(0.), vec3(0.01,-0.03,1.), 31.*t_abs, R*(0.8-t_abs)))\n        );\n    anneau = Union(\n        anneau,\n        vec4(mix(lightred, superwhite,t_abs2) ,circle(p, vec3(0.), vec3(-0.09,0.06,1.), 41.*t_abs, R*(0.8-t_abs)))\n        );\n        v = Blend(v, anneau);\n    }\n    return vec4(v.rgb, v.a-T);\n}\n// Potential field of the object\n// p : point\nvec4 Object(vec3 p)\n{\n\n    float R = 0.6;\n    float t = mod(iTime, phase1+phase2+phase3+phase4);\n    vec3 p2 = 3.*p;\n    if (t < phase1)\n    {//phase1\n        return Scene1(p, t) ;\n    }\n    else if(t < phase1+phase2)\n    {\n        return Scene2(p, t-phase1);\n    }\n    else if(t < phase1+phase2+phase3)\n    {\n        return Scene3(p, t-phase1-phase2);\n    }\n    else\n    {\n        return Scene4(p, t-phase1-phase2-phase3);\n    }\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n    float eps = 0.0001;\n    vec3 n;\n    float v = Object(p).a;\n    n.x = Object( vec3(p.x+eps, p.y, p.z) ).a - v;\n    n.y = Object( vec3(p.x, p.y+eps, p.z) ).a - v;\n    n.z = Object( vec3(p.x, p.y, p.z+eps) ).a - v;\n    return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nvec4 Trace(vec3 o, vec3 u, float rB,out bool h,out int s)\n{\n    h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n    vec4 v;\n    for(int i=0; i<Steps; i++)\n    {\n        s=i;\n        vec3 p = o+t*u;\n        v = Object(p);\n        // Hit object\n        if (v.a > 0.0)\n        {\n            s=i;\n            h = true;\n            break;\n        }\n        // Move along ray\n        t += Epsilon;\n        // Escape marched far away\n        if (t>rB)\n        {\n            break;\n        }\n    }\n    return vec4(v.rgb,t);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// return t a vec4 where t.rgb is the color and t.a is the distance value\nvec4 SphereTrace(vec3 o, vec3 u, float rB, out bool h,out int s)\n{\n    h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n    vec4 v;\n    for(int i=0; i<Steps; i++)\n    {\n        s=i;\n        vec3 p = o+t*u;\n        v = Object(p);\n        // Hit object\n        if (v.a > 0.0)\n        {\n            s=i;\n            h = true;\n            break;\n        }\n        // Move along ray\n        t += max(Epsilon,abs(v.a)/lipshitz_constant);\n        // Escape marched far away\n        if (t>rB)\n        {\n            break;\n        }\n    }\n    return vec4(v.rgb,t);\n}\n\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n, int a)\n{\n    if (a==0) { return 1.0; }\n\n    float ao=0.0;\n\n    for (int i=0;i<a;i++)\n    {\n        vec3 d = Cosine(581.123*float(i) , n);\n\n        int s;\n        bool h;\n        float t=SphereTrace(p,d,10.0,h,s).a;\n        if (!h) {ao+=1.0;}\n        else if (t>5.0)\n        {\n            ao+=1.0;\n        }\n    }\n\n    ao/=float(a);\n    return ao;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n    return mix(bg_col1,bg_col2, rd.z*0.5+0.5);\n}\n\nfloat Light(vec3 p,vec3 n)\n{\n    // point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n\n    vec3 l = normalize(lp - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l)); diff = diff*diff;\n\n    bool h;\n    int s;\n    float t=SphereTrace(p+0.1*n,l,10.0,h,s).a;\n    if (!h)\n    {\n        return diff;\n    }\n    return 0.0;\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n, vec3 col)\n{\n    vec3 c = 0.4*col+0.15*background(n);\n    c+=0.1*AmbientOcclusion(p+0.1*n,n,15)*vec3(0.7,0.3,0.7);\n    c+=0.16*Light(p,-n)*vec3(1.0,1.0,0.7);\n    return c;\n}\n\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n    float t=float(n)/(float(Steps-1));\n    return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n    if (pip==true)\n    {\n        const float fraction=1.0/4.0;\n        // Recompute pixel coordinates in sub-picture\n        if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n        {\n            p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n            pip=true;\n        }\n        else\n        {\n            pip=false;\n        }\n    }\n    return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=false;\n\n    // Pixel\n    vec2 pixel=(-iResolution.xy + 2.0*pxy)/iResolution.y;//Pip(pxy, pip);\n\n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n    //Ray(vec2(0.17,0.5),pixel,ro,rd);\n\n    // Trace ray\n\n    // Hit and number of steps\n    bool hit;\n    int s;\n\n    vec4 t = SphereTrace(ro, rd, 100.0,hit, s);\n\n    // Position\n    vec3 pt = ro + t.a * rd;\n\n    // Shade background\n    vec3 rgb = background(rd);\n\n    if (hit)\n    {\n        // Compute normal\n        vec3 n = ObjectNormal(pt);\n\n        // Shade object with light\n        rgb = Shade(pt, n, t.rgb);\n        /*float ss = float(s/16);\n        vec3 c = vec3(cos(ss*0.0625*iTime),cos(ss*0.125*iTime),cos(ss*0.25*iTime));\n        rgb = 0.95*rgb + 0.05*c;*/\n\n    }\n\n    // Uncomment this line to shade image with false colors representing the number of steps\n    // if (pip==true)\n    // {\n    //     rgb = ShadeSteps(s);\n    // }\n\n\n    color=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Cosine direction \nvec3 Cosine( in float seed, in vec3 nor)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    \t// method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n        float a = 6.2831853 * v;\n        u = 2.0 * u - 1.0;\n        return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n////////////////\n//// Noises ////\n////////////////\n\nfloat random3D(in vec3 p) {\n    return fract(sin(dot(p, vec3(5395.3242, 38249.2348, 123.456))) * 248.24);\n}\n\nfloat noise3D (in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    float a000 = random3D(i);\n    float a001 = random3D(i + vec3(0.0, 0.0, 1.0));\n    float a010 = random3D(i + vec3(0.0, 1.0, 0.0));\n    float a011 = random3D(i + vec3(0.0, 1.0, 1.0));\n    float a100 = random3D(i + vec3(1.0, 0.0, 0.0));\n    float a101 = random3D(i + vec3(1.0, 0.0, 1.0));\n    float a110 = random3D(i + vec3(1.0, 1.0, 0.0));\n    float a111 = random3D(i + vec3(1.0, 1.0, 1.0));\n    vec3 u = f*f*(3.0-2.0*f);\n    float val_left = mix(a000, a001, u.z) +\n       (a010 - a000)* u.y * (1.0 - u.z) +\n       (a011 - a001)* u.y * u.z;\n   float val_right = mix(a100, a101, u.z) +\n       (a110 - a100)* u.y * (1.0 - u.z) +\n       (a111 - a101)* u.y * u.z;\n    return  mix(val_left, val_right, u.x);\n}\n\n// noise3D_hamonics function\n// return a value_noise with nb_harmonics frequencies (equals to 2^i with amplitude 2^-i)\nfloat noise3D_hamonics (in vec3 p, int nb_harmonics) {\n    float res = noise3D(p);\n    float two_powers = 1.;\n    float half_powers = 1.;\n    for (int i=0;i<nb_harmonics;i++)\n    {\n        two_powers = 2. * two_powers;\n        half_powers = 0.5 * half_powers;\n        res += half_powers*noise3D(two_powers*p);\n    }\n    return res;\n}\n\n////////////////\n//// fallof ////\n////////////////\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x, float R)\n{\n    float u = clamp(x/R,0.0,1.0);\n    float v = (1.0-u*u);\n    return v*v*v;\n}\n\n// Smooth cubic falloff2 function\n// x2 : sqyare distance\n// R2 : square radius\nfloat falloff2(float x2, float R2)\n{\n    float u = clamp(x2/R2,0.0,1.0);\n    float v = (1.0-u);\n    return v*v*v;\n}\n\n// Scale noise cubic falloff function\n// dist_vec : vector of distance between object and p\n// noise_amplitude\n// noise_scale\n// R : radius\nfloat scale_noise_falloff(vec3 dist_vec, float noise_amplitude, float noise_scale, int nb_harmonics, float R)\n{\n    return (falloff2(dot(dist_vec,dist_vec),R*R))*\n      (1.+noise_amplitude * noise3D_hamonics(noise_scale*normalize(dist_vec), nb_harmonics));\n}\n\n// Scale noise cubic falloff function with seed\n// dist_vec : vector of distance between object and p\n// noise_amplitude\n// noise_scale\n// R : radius\n// seed :\nfloat scale_noise_falloff_seed(vec3 dist_vec, float noise_amplitude, float noise_scale, int nb_harmonics, float R, vec3 seed)\n{\n    return (falloff2(dot(dist_vec,dist_vec),R*R))*\n      (1.+noise_amplitude * noise3D_hamonics(noise_scale*(seed+normalize(dist_vec)), nb_harmonics));\n}\n\n\n// Rays\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    ro=vec3(20.0,0.0,3.0);\n    ro*=rotate_z(3.0*3.14*m.x); \n\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n","name":"Common","description":"","type":"common"}]}