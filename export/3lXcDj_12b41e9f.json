{"ver":"0.1","info":{"id":"3lXcDj","date":"1593031072","viewed":106,"name":"Double Pendulum Dynamics","username":"cheasify","description":"Behavior of a double pendulum. There are oases of order but if you stray too far, chaos will quickly envelope the screen. I derived the differential equation using Euler-Legrange equation and evaluate using Runge-Kutta. ","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["chaos","physics","diffequ"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//double pendula exhibit a behavior called chaos where small changes in initial conditions can have a huge effect on long term behavior\n//this program was made to explore the order and chaos in this simple system\n#define PI 3.14159265358979\nvec3 color(float x){\n\tx=sin(x)+.3;\n    float r=(1.0-x)*(1.0-x);\n    float g=x*x;\n    float b=2.0*(1.0-x)*x;\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec4 F=vec4( texelFetch( iChannel0, ivec2(fragCoord), 0 ));\n    float scale=1.;\n    //these are different colorings\n    \n    //individual parameters but has looping color scheme\n    //fragColor=vec4(color(F.x*scale),0);//top angle\n    //fragColor=vec4(color(F.y*scale),0);//bottom angle\n    //fragColor=vec4(color(F.z*scale),0);//top angular velocity\n    //fragColor=vec4(color(F.w*scale),0);//bottom angular velocity\n    \n   \t\n    //different colors represent the different parameters\n    fragColor=vec4(F.z*scale*2.+.2,F.x*scale*2.+.2,(F.z+F.w)*scale+.2,0);\n    //fragColor=vec4(F.x*scale*2.+.2,F.y*scale*2.+.2,F.z*scale*2.+.2,0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//change these for different behavior\n//you can change these while the program is running\n//some values will not work and will go straight to chaos so just restart and try something different\nconst float r1=1.;//top rod length\nconst float r2=3.1;//bottom rod length\nconst float m1=3.;//top mass\nconst float m2=3.;//bottom mass\nconst float g=3.5;//gravity, this can look like a speed up in time but will have other effects?\nconst float dt=0.03;//time step,changes speed,values larger than .1 can cause lots of error and will be obnoxious\n\n\n\n//there are 4 values transferred at each step\n//two angles θ1, θ2\n//two angular velocities ω1, ω2 \n//fragColor=vec4(θ1,θ2,ω1,ω2); \n\n//this is a coupled homogenous ordinary differential equation fully discribing the motion of a double pendulum\n//this was derived using the euler-lagrange equation\nvec4 dFdt(vec4 f){\n\tfloat a1=r2/r1*m1/(m1+m2)*cos(f.x-f.y);\n    float a2=r1/r2*cos(f.x-f.y);\n    float b1=r2/r1*m1/(m1+m2)*f.w*f.w*sin(f.x-f.y)-g/r1*sin(f.x);\n    float b2=r1/r2*f.z*f.z*sin(f.x-f.y)-g/r2*sin(f.y);\n\treturn vec4(f.z,\n                f.w,\n                (b1-a1*b2)/(1.-a1*a2),\n                (b2-a2*b2)/(1.-a1*a2));\n\n}\n\n//midpoint method aka Runge-Kutta2(RK2)\n//this can help if you are dropping frames\n//swap the RK4 for RK2 on line 55 and this should run several times faster\nvec4 RK2(vec4 prev){\n\tvec4 mid=prev+dt/2.*dFdt(prev);\n    return prev+dt*dFdt(mid);\n}\n\n\n//Runge-Kutta4(RK4)\n//less prone to error but slower\nvec4 RK4(vec4 prev){\n    vec4 k1=dFdt(prev);\n    vec4 k2=dFdt(prev+dt/2.*k1);\n    vec4 k3=dFdt(prev+dt/2.*k2);\n    vec4 k4=dFdt(prev+dt*k3);\n\treturn prev+dt/6.*(k1+2.*k2+2.*k3+k4);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec4 prev=texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor=RK4(prev);//set next value\n    \n    \n    if( iFrame==0 ){//initial conditions\n       \n        float zoom=1.;//initial zoom, need to reset for this to have an affect\n        //fragColor=vec4(float(uv.x)/zoom,float(uv.y)/zoom,0.0,0.0);//initial based on angle\n        fragColor=vec4(0.0,0.0,float(uv.x)/zoom,float(uv.y)/zoom);//initial based on angular velocity aka spinniness \n    }\n    \n   \t\n}","name":"Buffer A","description":"","type":"buffer"}]}