{"ver":"0.1","info":{"id":"4ltfWf","date":"1541363661","viewed":192,"name":"Paintballs Blob","username":"Crazybytes","description":"Paintballs Blob\nCombined spilled normal with pong light normal after ray march.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["blob","paint","pong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uniform vec2 pos_abs;\n#define BLOBS 30\n#define PI 3.141592653589793\n\nconst float camera_pos=-5.0;\nvec2 uv2;\nvec2 uv;\n\nfloat T = 0.0;\nint horizon;\n\n//https://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/\nfloat SoftMaximum(float x, float y)\n{\n\tfloat maximum = max(x, y);\n\tfloat minimum = min(x, y);\n\treturn maximum + log( 1.0 + exp(minimum - maximum) );\n}\n\n//https://www.johndcook.com/blog/2010/01/13/soft-maximum/\nfloat smax( float a, float b, float k )\n{\n    return log( exp(a*k) + exp(b*k) ) / k;\n}\n\n//https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h/(6.0*k*k);\n}\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n// power smooth min (k = 8);\nfloat smin3( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// exponential smooth min (k = 32);\nfloat smin1( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n\nfloat getVal(vec2 uv, vec2 delta)\n{\n//    return length(texture(texture_buffer,uv).xyz);\n    vec3 col=vec3(0.0);\n    col+=texture(iChannel0,uv).xyz*4.0;\n    col+=texture(iChannel0,uv+vec2(delta.x,0.0)        ).xyz*2.0;\n    col+=texture(iChannel0,uv+vec2(-delta.x,0.0)       ).xyz*2.0;\n    col+=texture(iChannel0,uv+vec2(0.0,delta.y)        ).xyz*2.0;\n    col+=texture(iChannel0,uv+vec2(0.0,-delta.y)       ).xyz*2.0;\n    col+=texture(iChannel0,uv+vec2(delta.x,delta.y)    ).xyz;\n    col+=texture(iChannel0,uv+vec2(-delta.x,delta.y)   ).xyz;\n    col+=texture(iChannel0,uv+vec2(delta.x,-delta.y)   ).xyz;\n    col+=texture(iChannel0,uv+vec2(-delta.x,-delta.y)  ).xyz;\n    col=col/16.0;\n    return length(col);\n}\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n//http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#signed-distance-functions\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nmat4 rotateXYZ(float theta_x, float theta_y, float theta_z) {\n    float c_x = cos(theta_x);\n    float s_x = sin(theta_y);\n    float c_y = cos(theta_x);\n    float s_y = sin(theta_y);\n    float c_z = cos(theta_x);\n    float s_z = sin(theta_y);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c_x, -s_x, 0),\n        vec4(0, s_x, c_x, 0),\n        vec4(0, 0, 0, 1)\n    ) *\n    mat4(\n        vec4(c_y, 0, s_y, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s_y, 0, c_y, 0),\n        vec4(0, 0, 0, 1)\n    ) *\n    mat4(\n        vec4(c_z, -s_z, 0, 0),\n        vec4(s_z, c_z, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateZYX(float theta_x, float theta_y, float theta_z) {\n    float c_x = cos(theta_x);\n    float s_x = sin(theta_y);\n    float c_y = cos(theta_x);\n    float s_y = sin(theta_y);\n    float c_z = cos(theta_x);\n    float s_z = sin(theta_y);\n\n    return mat4(\n        vec4(c_z, -s_z, 0, 0),\n        vec4(s_z, c_z, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    ) *\n    mat4(\n        vec4(c_y, 0, s_y, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s_y, 0, c_y, 0),\n        vec4(0, 0, 0, 1)\n    ) *\n    mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c_x, -s_x, 0),\n        vec4(0, s_x, c_x, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 projection(float theta) {\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 1.0/theta, 1)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, -s, 0, 0),\n        vec4(s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nfloat disp(vec3 p,float n) {\n\tfloat t = iTime*0.23+n;\n\tfloat f = 4.0;\n\treturn (.18) * cos( p.x * f + t ) * cos(p.z * f + t ) * cos( p.y * f + t ) ;\n}\n\nmat4 rotje() {\n    return rotateX(-T*0.1*2.0*PI)*rotateY(-T*0.1*2.0*PI)*rotateZ(-T*0.1*2.0*PI);\n}\nmat4 rotje2() {\n    return rotateZ(T*0.1*2.0*PI)*rotateY(T*0.1*2.0*PI)*rotateX(T*0.1*2.0*PI);\n}\n\nfloat map(vec3 p) {\n\tfloat d = 1.0E10;\n\thorizon=0;\n\tp.z=p.z+camera_pos;\n\n\td =  disp(p,1.0)+sdSphere(p+   vec3(0.0,0.0,sin(T*5.234)),2.0) ;\n    for (int x=0; x<BLOBS; x++) {\n        float ff=float(x);\n        float where=mod(T*1.22+ff*ff,2.0*PI);\n        if ((where<PI*0.5 || (where>PI && where<1.5*PI)) ) {\n                float d2 = ( 1.0-(0.5+sin(2.0*where+.5*PI)/2.0) )*disp(p,1.0) +sdSphere(p + vec3(0.0,0.0,sin(T*5.234)) +  ( rotateX(ff+T*0.33) * rotateY(ff+T*0.45) * rotateZ(ff+T*0.56) * vec4( 0.0+sin(where)*2.0, 0.0+sin(where)*2.0,  sin(where)*10.0  ,  1.0  )).xyz    ,   1.33*( 1.0-(0.5+sin(2.0*where+1.5*PI)/2.0) ));    d = smin(d,d2,0.3);\n        }\n    }\n\n\n    d = min(1.0E10 , d );\n    if (d>= 1.0E10) horizon=1;\n\treturn d;\n\n}\n\nvec3 normal(vec3 p) {\n\tvec3 n, E = vec3(.005, 0., 0.);\n\n/*\n\tfloat n1,n2,n3;\n\n\tn1=map(p);\n\tn2=map(p - 1.0 * E.xyy);\n\tn3=map(p + 1.0 * E.xyy);\n\tif (abs(n1-n2)>abs(n3-n1)) {n.x=(n3 - n1)*2.0;  }\n\telse n.x=(n1 - n2)*2.0;\n\n\tn2=map(p - 1.0 * E.yxy);\n\tn3=map(p + 1.0 * E.yxy);\n\tif (abs(n1-n2)>abs(n3-n1)) {n.y=(n3 - n1)*2.0;  }\n\telse n.y=(n1 - n2)*2.0;\n\n\tn2=map(p - 1.0 * E.yyx);\n\tn3=map(p + 1.0 * E.yyx);\n\tif (abs(n1-n2)>abs(n3-n1)) {n.z=(n3 - n1)*2.0;  }\n\telse n.z=(n1 - n2)*2.0;\n*/\n\n\n\tn.x = map(p + E.xyy) - map(p - E.xyy);\n\tn.y = map(p + E.yxy) - map(p - E.yxy);\n\tn.z = map(p + E.yyx) - map(p - E.yyx);\n\treturn normalize(n);\n}\n\nfloat getVal2(vec2 uv)\n{\n    return length( texture(iChannel0,uv).xyz);\n}\n\nvec2 getGrad(vec2 uv,vec2 delta) {\n\n     return vec2(  getVal(uv+vec2(delta.x,0),delta) - getVal(uv-vec2(delta.x,0),delta) , getVal(uv+vec2(0,delta.y),delta) - getVal(uv-vec2(0,delta.y),delta) )/delta;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float t=0.0;\n\tT=iTime/(iResolution.x/100.0);\n    float zoom=1.0;\n    vec4 Color=vec4(0.0);\n    vec2 Coord=fragCoord.xy;\n    zoom=1.0;\n\tvec3 kS = vec3(.7, .5, .9);\n\tvec3 kA = vec3(0.0, .0, .0);\n\n\tfloat ppy = .0;\n\tfloat ppx = .0;\n\tfloat TT = T * 0.71 + sin(T*0.1334)*3.14;\n\tvec3 light=vec3(sin(T*0.55)*3.0, 1.0 , -1.5+sin(T*0.66)+camera_pos); \n\n    vec3 ro = vec3(0.0,0.0, -1.0);\n\n\tuv = zoom*(Coord.xy - .5 * iResolution.xy) / iResolution.y;\n\tvec3 rd = vec3(uv+vec2(ppx,ppy)*2.0, 1.0);\n\n\tt = 0.0;\n    vec3 p;\n    p = ro + rd * t;\n    float m=map(p);\n\tfor (int i = 0; i < 512; i++) {\n        m=map(p);\n        if (horizon==1) break;\n        t += 0.9 * m;\n        p = ro + rd * t;\n \t\tif (m<0.0001) break;\n\t}\n\n    uv2= vec2(1.0,1.0)*  (( (   ( p.xy*1.2*vec2(1.0,-1.0) +  vec2(ppx,ppy) - t/1.5  ) ) -0.5) + 0.25);\n\tif (horizon==0 || m<0.0001) {\n\n        vec4 kD=vec4(0.0);\n\n        vec2 offset=vec2(-T*0.12*1.0,-T*0.1*1.0);  //xyz\n        vec3 n = normal( p );\n        vec2 calc=(p.xy*vec2(0.6,0.6)*(1.1+p.z/1.50) +  vec2(ppx,ppy)  - (t)/2.5);\n        vec2 uv2= vec2(1.1,1.1) * ( calc /(1.0+ p.xy/10.0) )  +  vec2(0.0,-(calc.y)*0.20)+ offset;\n        vec2 uv_adj=(uv2/(1.0+sqrt(-camera_pos/2.0 + 1.0)/iResolution.y)*vec2(0.05,0.05)  );\n\n\n        vec3 n2 = vec3(getGrad(uv_adj,-1.0/iResolution.xy),-150.0);\n        n2=normalize(n2);\n        kD = texture(iChannel0,uv_adj);\n\n        n=normalize(n+n2*3.0);\n        vec3 lp = normalize(light - p);\n        float diff = 1.0 * clamp(dot( n,lp), 0.0, 1.);\n        float spec = (9.5) * pow(max(dot(reflect(-lp, n), ro), 0.), 120.);\n\n\t\tColor = clamp(vec4(kA + kD.xyz * (diff ) + kS * ( spec ), 1.0), 0.0,1.0);\n\t} else {\n\t\tColor = vec4( (sin(T*0.633)+1.0)/2.0, (sin(T*0.543)+1.0)/2.0, (sin(T*0.439)+1.0)/2.0,1.0);\n\t}\n    fragColor=Color;\n//    fragColor=texture(iChannel0,fragCoord.xy/iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    fragColor.z += (0.01*scr.yx / (dot(scr,scr)/0.1+0.3)).x;\n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n     if( iMouse.z>0.01 || iMouse.w>0.01 )\n        {\n            // move with mouse\n            vec2 paddlePos = (-0.5 + 1.0*iMouse.xy/iResolution.xy)*iResolution.x/iResolution.y;\n            float x=abs(scr.x-paddlePos.x);\n            float y=abs(scr.y-paddlePos.y);\n            if ( sqrt(x*x+y*y)<0.35) { \n\t\t\t\tfloat T=iTime/(iResolution.x/100.0);\n\t\t\t\tvec4 Color = vec4( (sin(T*0.633)+1.0)/2.0, (sin(T*0.543)+1.0)/2.0, (sin(T*0.439)+1.0)/2.0,1.0);\n  \t\t\t\tif (paddlePos.y<0.0) fragColor.xyz+=Color.xyz*0.4;              \n                else fragColor.xyz-=Color.xyz*0.4;              \n//                fragColor.xy*=1.0+sin(iTime*0.1)/5.0;\n//                fragColor.yz*=1.0+sin(iTime*0.123)/5.0;\n//                fragColor.zx*=1.0+sin(iTime*0.1423)/5.0;\n            }\n        }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}