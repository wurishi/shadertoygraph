{"ver":"0.1","info":{"id":"McXfDH","date":"1730043392","viewed":83,"name":"4D axis visualization ","username":"Torbernight","description":"4D axis visualization with rotations and translation in the W axis\nX is red\nY is green\nZ is blue\nW is magenta","likes":0,"published":3,"flags":48,"usePreview":0,"tags":["4d","axis","transform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int text_len = 277;\nuint text[70] = uint[70](\n0x496e7374U, 0x72756374U, 0x696f6e73U, 0x3a202020U, 0x20202020U, 0x20202020U, 0x20202020U, 0x20202020U, \n0x20202020U, 0x20202020U, 0x20202020U, 0x20202020U, 0x2020526fU, 0x74617465U, 0x20696e20U, 0x33442077U, \n0x69746820U, 0x582c592cU, 0x20616e64U, 0x205a206bU, 0x6579732eU, 0x20202020U, 0x20202020U, 0x20202020U, \n0x20202020U, 0x526f7461U, 0x74652069U, 0x6e203444U, 0x20776974U, 0x6820512cU, 0x572c2061U, 0x6e642045U, \n0x206b6579U, 0x732e2020U, 0x20202020U, 0x20202020U, 0x20202020U, 0x2020486fU, 0x6c642053U, 0x50414345U, \n0x206b6579U, 0x20746f20U, 0x6d6f7665U, 0x20626163U, 0x6b776172U, 0x64732e20U, 0x20202020U, 0x20202020U, \n0x20202020U, 0x20202020U, 0x50726573U, 0x73205550U, 0x20616e64U, 0x20444f57U, 0x4e206b65U, 0x79732074U, \n0x6f206d6fU, 0x76652069U, 0x6e207468U, 0x65205720U, 0x64697265U, 0x6374696fU, 0x6e2e5072U, 0x65737320U, \n0x5220746fU, 0x20726573U, 0x65742074U, 0x72616e73U, 0x666f726dU, 0x2e00636fU\n);\n\nuint getGlyph(int index)\n{\n    uint byte = uint(index%4);\n    index = index>>2;\n    return (text[index] & (0xFF000000U >> (byte<<3U))) >> ((3U-byte)<<3U);\n}\n\nconst float textSize = 50.0;\n\nvec4 renderText(in vec2 uv, in vec4 color)\n{\n    const float gSize = 16.0; //font texture glyph size\n    //preserve aspect ratio and X coordinate\n    uv.y = 1.0 - (1.0 - uv.y)*iResolution.y/iResolution.x;\n    \n    ivec2 glyphCoord = ivec2(vec2(uv.x, 1.0-uv.y)*textSize);\n    \n    int glyphIndex = glyphCoord.x + glyphCoord.y*int(textSize);\n    \n    if (glyphIndex >= text_len)\n        return color;\n    \n    uint glyph = getGlyph(glyphIndex);\n    uvec2 glyphOffset = uvec2(glyph%uint(gSize), 255u - glyph/uint(gSize));\n\n    uv = (fract(uv*textSize) + vec2(glyphOffset))/gSize;\n    \n    vec4 res = texture(iChannel3, uv);\n    \n    return mix(color, vec4(1.0), res.r);    \n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    fragColor = aces_approx(texture(iChannel1, uv) + texture(iChannel1, uv/4.0) + texture(iChannel2, uv/4.0));\n\n    if (iTime < 4.0)\n        fragColor = mix(renderText(uv, fragColor), fragColor, pow(iTime/4.0, 4.0));\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define Q_KEY 81\n#define W_KEY 87\n#define E_KEY 69\n#define X_KEY 88\n#define Y_KEY 89\n#define Z_KEY 90\n#define R_KEY 82\n#define UP_KEY 38\n#define DOWN_KEY 40\n\nconst mat4 inv_perspective =\nmat4(\n\tvec4(1.24481,0,0,0),\n\tvec4(0,0.700208,0,0),\n\tvec4(0,0,0,4.995),\n\tvec4(0,0,-1,-5.005)\n);\n\nconst float radius = .1;\nconst vec3 origin = vec3(0.0, 0.0, 2.0);\n\nvec4 aces_approx(vec4 v)\n{\n    v *= 0.6;\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\nvec2 smin( float a, float b)\n{\n    float k = 0.02;\n    float h = 1.0 - min( abs(a-b)/(6.0*k), 1.0 );\n    float w = h*h*h;\n    float m = w*0.5;\n    float s = w*k; \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n//modified from https://iquilezles.org/articles/distfunctions/\nfloat sdVector( vec4 p, vec4 x, float r )\n{\n    vec4 a = -x;\n    vec4 pa = p - a, ba = x - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCoords(vec4 p, float r, out vec3 color)\n{\n    vec2 a = smin(sdVector(p, vec4(1,0,0,0), r), sdVector(p, vec4(0,1,0,0), r));\n    vec2 b = smin(sdVector(p, vec4(0,0,1,0), r), sdVector(p, vec4(0,0,0,1), r));\n    vec2 c = smin(a.x, b.x);\n    vec3 colorA = mix(vec3(2,0.001,0.001), vec3(0.001,2,0.001), a.y);\n    vec3 colorB = mix(vec3(0.001,0.001,2), vec3(2,0.001,2), b.y);\n    color = mix(colorA, colorB, c.y);\n    return c.x;\n}\n\n#define SDF sdCoords\n\nmat4 fetch_transform(sampler2D buffer)\n{\n    return mat4(\n        texelFetch(buffer, ivec2(0,0), 0),\n        texelFetch(buffer, ivec2(1,0), 0),\n        texelFetch(buffer, ivec2(2,0), 0),\n        texelFetch(buffer, ivec2(3,0), 0)\n    );\n}\nmat4 rotate(vec3 theta3D, vec3 theta4D) \n{\n    vec3 \n    c = cos(theta3D),\n    s = sin(theta3D),\n    cw = cos(theta4D), \n    sw = sin(theta4D);\n    return mat4(\n      vec4(c.y * c.z * cw.x, -(s.y * sw.z * sw.y) + c.y * (cw.y * s.z - c.z * cw.z * sw.x * sw.y), cw.z * s.y - c.y * c.z * sw.x * sw.z, cw.y * s.y * sw.z + c.y * (c.z * cw.z * cw.y * sw.x + s.z *  sw.y)), \n      vec4(-(c.z * cw.x * s.x * s.y) - c.x * cw.x * s.z, c.x * (c.z * cw.y + cw.z * s.z * sw.x * sw.y) + s.x * (-(c.y * sw.z * sw.y) - s.y * (cw.y * s.z - c.z * cw.z * sw.x * sw.y)), c.x * s.z * sw.x * sw.z + s.x * (c.y * cw.z + c.z * s.y * sw.x * sw.z), c.x * (-(cw.z * cw.y * s.z * sw.x) + c.z * sw.y) + s.x * (c.y * cw.y * sw.z - s.y * (c.z * cw.z * cw.y * sw.x + s.z * sw.y))), \n      vec4(-(c.x * c.z * cw.x * s.y) + cw.x * s.x * s.z, -(s.x * (c.z * cw.y + cw.z * s.z * sw.x * sw.y)) + c.x * (-(c.y * sw.z * sw.y) - s.y * (cw.y * s.z - c.z * cw.z * sw.x * sw.y)), -(s.x * s.z * sw.x * sw.z) + c.x * (c.y * cw.z + c.z * s.y * sw.x * sw.z), -(s.x * (-(cw.z * cw.y * s.z * sw.x) + c.z * sw.y)) + c.x * (c.y * cw.y * sw.z - s.y * (c.z * cw.z * cw.y * sw.x + s.z * sw.y))), \n      vec4(-sw.x, -(cw.x * cw.z * sw.y), -(cw.x * sw.z), cw.x * cw.z * cw.y)\n    );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float keyFetch(int key)\n{\n    return texelFetch(iChannel0, ivec2(key, 0), 0).r;\n}\nfloat keyToggle(int key)\n{\n\treturn texelFetch(iChannel0, ivec2(key, 2), 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 icoords = ivec2(fragCoord);\n    \n    if (icoords.y > 0 || icoords.x > 4)\n        return;\n    \n    vec3 theta3D, theta4D;\n    \n    float k = (1.0 - keyFetch(32))*2.0-1.0;\n    \n    theta3D = k*iTimeDelta*vec3(\n        keyFetch(X_KEY),\n        keyFetch(Y_KEY),\n        keyFetch(Z_KEY)\n    );\n    theta4D = k*iTimeDelta*vec3(\n        keyFetch(Q_KEY),\n        keyFetch(W_KEY),\n        keyFetch(E_KEY)\n    \n    );\n   \n    mat4 T = rotate(theta3D, theta4D) * fetch_transform(iChannel1);\n    \n    float W = (keyFetch(UP_KEY) - keyFetch(DOWN_KEY))*iTimeDelta + texelFetch(iChannel1, ivec2(4, 0), 0).w;\n    \n    if (iFrame == 0 || keyFetch(R_KEY) == 1.0){\n        T = mat4(1.0);\n        W = 0.0;\n    }\n    \n    switch(icoords.x)\n    {\n        case 0:\n            fragColor = T[0];\n            break;\n        case 1:\n            fragColor = T[1];\n            break;\n        case 2:\n            fragColor = T[2];\n            break;\n        case 3:\n            fragColor = T[3];\n            break;\n        case 4:\n            fragColor = vec4(0.0,0.0,0.0, W);\n            break;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    vec4 uvwz = inv_perspective * vec4(uv, 1.0, 1.0);\n    uvwz /= uvwz.w;\n    \n    mat4 T = fetch_transform(iChannel0);\n    \n    vec4 offset = texelFetch(iChannel0, ivec2(4,0), 0);\n    \n    vec4 P = T * (vec4(origin,0.0) + offset);\n    vec4 D = mat3x4(T) * normalize(origin - uvwz.xyz);\n\n    vec3 color;\n    for (int i = 0; i < 64; i++) {\n        float dist = SDF(P, radius, color);\n        \n        if (0.0 < dist && dist < 0.01){\n            fragColor.rgb = color*1.1;\n            return;\n        }\n        \n        P += D*dist;\n    }\n    fragColor = vec4(0.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 sledgehammer_blur(sampler2D tex, vec2 uv, vec2 resolution)\n{\n    vec2 texelSize = 1.0/resolution;\n    vec2 Off[2] = vec2[2](0.5*texelSize, 1.5*texelSize);\n\n    vec4 a = texture(tex, vec2(uv.x + Off[0].x, uv.y + Off[0].y));\n    vec4 b = texture(tex, vec2(uv.x - Off[0].x, uv.y + Off[0].y));\n    vec4 c = texture(tex, vec2(uv.x + Off[0].x, uv.y - Off[0].y));\n    vec4 d = texture(tex, vec2(uv.x - Off[0].x, uv.y - Off[0].y));\n\n    vec4 e = texture(tex, vec2(uv.x + Off[1].x, uv.y + Off[1].y));\n    vec4 f = texture(tex, vec2(uv.x + Off[1].x, uv.y));\n    vec4 g = texture(tex, vec2(uv.x + Off[1].x, uv.y - Off[1].y));\n\n    vec4 h = texture(tex, vec2(uv.x, uv.y + Off[1].y));\n    vec4 i = texture(tex, vec2(uv.x, uv.y));\n    vec4 j = texture(tex, vec2(uv.x, uv.y - Off[1].y));\n\n    vec4 k = texture(tex, vec2(uv.x - Off[1].x, uv.y + Off[1].y));\n    vec4 l = texture(tex, vec2(uv.x - Off[1].x, uv.y));\n    vec4 m = texture(tex, vec2(uv.x - Off[1].x, uv.y - Off[1].y));\n\n    return i*0.125 + (e+g+k+m)*0.03125 + (f+h+j+l)*0.0625 + (a+b+c+d)*0.125;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 4.0;\n    fragColor = sledgehammer_blur(iChannel0, uv, vec2(textureSize(iChannel0, 0).xy)/4.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec4 sledgehammer_blur(sampler2D tex, vec2 uv, vec2 resolution)\n{\n    vec2 texelSize = 1.0/resolution;\n    vec2 Off[2] = vec2[2](0.5*texelSize, 1.5*texelSize);\n\n    vec4 a = texture(tex, vec2(uv.x + Off[0].x, uv.y + Off[0].y));\n    vec4 b = texture(tex, vec2(uv.x - Off[0].x, uv.y + Off[0].y));\n    vec4 c = texture(tex, vec2(uv.x + Off[0].x, uv.y - Off[0].y));\n    vec4 d = texture(tex, vec2(uv.x - Off[0].x, uv.y - Off[0].y));\n\n    vec4 e = texture(tex, vec2(uv.x + Off[1].x, uv.y + Off[1].y));\n    vec4 f = texture(tex, vec2(uv.x + Off[1].x, uv.y));\n    vec4 g = texture(tex, vec2(uv.x + Off[1].x, uv.y - Off[1].y));\n\n    vec4 h = texture(tex, vec2(uv.x, uv.y + Off[1].y));\n    vec4 i = texture(tex, vec2(uv.x, uv.y));\n    vec4 j = texture(tex, vec2(uv.x, uv.y - Off[1].y));\n\n    vec4 k = texture(tex, vec2(uv.x - Off[1].x, uv.y + Off[1].y));\n    vec4 l = texture(tex, vec2(uv.x - Off[1].x, uv.y));\n    vec4 m = texture(tex, vec2(uv.x - Off[1].x, uv.y - Off[1].y));\n\n    return i*0.125 + (e+g+k+m)*0.03125 + (f+h+j+l)*0.0625 + (a+b+c+d)*0.125;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = sledgehammer_blur(iChannel0, uv, vec2(textureSize(iChannel0, 0).xy));\n}","name":"Buffer D","description":"","type":"buffer"}]}