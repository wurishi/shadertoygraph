{"ver":"0.1","info":{"id":"tdtXRf","date":"1572542610","viewed":113,"name":"clouds_v0","username":"JabberSnatch","description":"Simplex noise implementation","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","volume"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hash3(vec3 p)\n{\n    mat3 seed = mat3(742.342, 823.457, 242.086,\n                     247.999, 530.343, 634.112,\n                     437.652, 139.485, 484.348);\n\n    return fract(seed * sin(p)) * 2.0 - vec3(1.0);\n}\n\n\nfloat noise3(vec3 p)\n{\n    float f = (sqrt(4.0) - 1.0) / 3.0;\n    mat3 skew = mat3(1.0 + f, f, f,\n                     f, 1.0 + f, f,\n\t\t\t\t\t f, f, 1.0 + f);\n    float g = (1.0 - 1.0/sqrt(4.0)) / 3.0;\n    mat3 invskew = mat3(1.0-g, -g, -g,\n                        -g, 1.0-g, -g,\n\t\t\t\t\t\t-g, -g, 1.0-g);\n\n    vec3 sp = skew * p;\n    vec3 cell = floor(sp);\n    vec3 d0 = fract(sp);\n\n    float x0 = step(d0.x, d0.y);\n\tfloat x1 = step(d0.y, d0.z);\n\tfloat x2 = step(d0.z, d0.x);\n\t// x = x2*(1-x0)\n    // y = x0*(1-x1)\n    // z = x1*(1-x2)\n    vec3 s0 = vec3(x2*(1.-x0), x0*(1.-x1), x1*(1.-x2));\n    // x = min(1.0, x2+1.0-x0)\n    // y = min(1.0, x0+1.0-x1)\n    // z = min(1.0, x1+1.0-x2)\n    vec3 s1 = min(vec3(1.0), vec3(1.0) + vec3(x2-x0, x0-x1, x1-x2));\n\n    vec3 sv[4] = vec3[4](cell,\n                         cell + s0,\n                         cell + s1,\n                         cell + vec3(1.0));\n    vec3 wv[4] = vec3[4](invskew * sv[0],\n                         invskew * sv[1],\n                         invskew * sv[2],\n                         invskew * sv[3]);\n    vec3 d[4] = vec3[4](p - wv[0],\n                        p - wv[1],\n                        p - wv[2],\n                        p - wv[3]);\n\n    vec4 weights = max(vec4(0.0), vec4(0.6) - vec4(dot(d[0], d[0]),\n                                                   dot(d[1], d[1]),\n                                                   dot(d[2], d[2]),\n                                                   dot(d[3], d[3])));\n    weights = weights * weights * weights * weights;\n\n    return (dot(hash3(sv[0]), d[0]) * weights[0] +\n            dot(hash3(sv[1]), d[1]) * weights[1] +\n            dot(hash3(sv[2]), d[2]) * weights[2] +\n            dot(hash3(sv[3]), d[3]) * weights[3]) * 16.0;\n}\n\nvec3 target_half_diagonal_hfov(float n, float alpha, float aspect)\n{\n\tfloat half_width = tan(alpha * 0.5) * n;\n\tfloat half_height = half_width * aspect;\n\treturn vec3(half_width, half_height, n);\n}\n\nvec3 compute_ray_plane(vec3 half_diagonal, vec2 clip_coord)\n{\n\tvec3 target = half_diagonal * vec3(clip_coord, 1.0);\n\treturn normalize(target);\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    vec2 uv = frag_coord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 d2 = hash3(vec3(1.0, -13.0, 0.0)) * iTime * .5;\n\n\tfloat aspect_ratio = iResolution.y / iResolution.x;\n\tfloat fov = 60.0 * 3.1415926536 / 180.0;\n\tfloat near = 0.1;\n\tvec3 half_diagonal = target_half_diagonal_hfov(near, fov, aspect_ratio);\n\tvec2 clip_coord = ((frag_coord / iResolution.xy) - 0.5) * 2.0;\n\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n\tvec3 rd = compute_ray_plane(half_diagonal, clip_coord);\n\n    vec3 pc = ro + dot(rd, -ro) * rd;\n    float x0 = length(pc);\n    float x1 = 1.0 - x0*x0;\n    float x2 = length(pc - ro) - x1;\n\n    vec3 i0 = ro + rd*x2;\n    vec3 i1 = i0 + 2.0*(pc - i0);\n\n    float t0 = x2;\n    float t1 = length(ro - i1);\n    float stepcount = 3.0;\n    float step = (t1-t0)/stepcount;\n    if (x0 < 1.0)\n        for (float i = 0.0; i <= stepcount; i += 1.0)\n    {\n       \tfloat t = t0 + step*i;\n        vec3 p = ro + t*rd;\n\n        vec3 color = vec3(0.0);\n        for (float i = 1.0; i < pow(2.0, 5.0); i *= 2.0)\n            color.x += noise3((p*5.0 + d2/(i*1.2))*i) / i;\n\n        color = color*4.0 + vec3(0.1);\n\n        frag_color.xyz += color.xxx / stepcount;\n    }\n\n    frag_color = vec4(frag_color.x * 1.2, frag_color.x * 0.92, sqrt(2.0) * 0.3, 1.0);\n    frag_color *= exp(-pow(length((frag_coord / iResolution.xy) - vec2(0.5)), 2.0) / 0.25);\n}\n","name":"Image","description":"","type":"image"}]}