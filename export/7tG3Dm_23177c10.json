{"ver":"0.1","info":{"id":"7tG3Dm","date":"1638840874","viewed":269,"name":"cyclic Nyancat","username":"cyperus","description":"cyclic Nyancat","likes":11,"published":3,"flags":0,"usePreview":0,"tags":["nyancat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"cyclic Nyancat\" created by Colling Patrik (cyperus) in 2021\n//\n// DESCRIPTION: \n// - comment in out #define COMPLEX\n//\n// BASED ON\n// - mu6k \n//     \"Nyancat\" https://www.shadertoy.com/view/4dXGWH\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#define COMPLEX\n\nconst float\n    period = 10., // animation loop time in seconds\n    scale  = 7.;  // inside one unit\n\nvec4 stars(vec2 p, float time)\n{\n\tvec4 color = vec4(0);\n\tvec2 ps;\n\tfloat stars; float ss = 0.04, s1 = 16.;\n    \n\tfor (float i = 1.; i < 7.; i++)\n\t{\n        time /= i; ps = i*p;\n\t\tps = ps + time*vec2(1, 0) - mod(ps + vec2(time,i*s1) ,vec2(ss));\n        \n\t\tstars = noise(s1 * ps);        \n\t\tif (stars > 0.98) color = vec4(1);\n\t}   \n\treturn color;\n}\n\nvec4 nyancat(vec2 z, vec2 z0, float scale, float time)\n{\n    z = scale * vec2(fract(z.x - time) , z.y); z -= z0;\n    return ((0. < z.x && z.x < 0.9) && (0. < z.y && z.y < 0.6))\n    ? texture(iChannel0, \n        vec2(40./256. * (z.x + floor(6. * fract(3. * scale * time))), z.y + 0.2 ))\n    : vec4(0.);\n}    \n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float time = iTime/period,\n          PI2time = PI2*time;\n    \n    float pix = 3./R.x;\n    #ifdef COMPLEX\n    vec2 uv = (2.*U.xy-R.xy)/R.x; // uv.x ∈ [-1, 1.], uv.y ∈ [-R.y/R.x, R.y/R.x];\n    #else\n    vec2 uv = U.xy/R.x; // uv.x ∈ [0., 1.], uv.y ∈ [0., R.y/R.x];\n    #endif\n    \n    // complex stuff! \n    #ifdef COMPLEX\n    uv = crpt(2.* uv, .0*PI2time * .25, 2, .7 +.1*cos(PI2time*.15));\n    uv = crpt(2.* uv, .3*PI2time * -.5, 3,    1.4*sin(PI2time*.25));\n    \n    uv.xy = uv.yx;\n    uv = cinv(uv);\n    #endif\n    \n    uv.y = abs(uv.y); // mirror along x-axis\n    \n    // background\n    vec4 bg = vec4(mix(vec3(0.0,0.1,0.7),vec3(0.8,0.8,0.0), sqrt(uv.y)), 1.);\n    vec4 st = stars(10. * uv, 5. * time);\n    \n    // floor\n    float fl_height = scale * 0.03;\n    vec2 fl_uv = scale * uv; // uv-transformation\n    float fl_sdf = fl_height - fl_uv.y ; // signed distance function\n    vec4 fl = vec4(0.9 * h2rgb(uv.x), S(fl_sdf, 0.01)); // color, alpha   \n    \n    // ball\n    float ba_r = 0.1;     \n    vec2 ba_uv  = scale * vec2(fract(uv.x - time), uv.y ); // uv-transformation\n         ba_uv -= vec2(1.2, fl_height + ba_r + 0.2 * abs(cos(PI2time * scale)));\n    float ba_sdf = ba_r - length(ba_uv); // signed distance function\n    vec4 ba = vec4(1.2 * vec3(.8,.2,0.), S(ba_sdf, 0.01 )); // color, alpha\n    \n    // nyancat\n    vec2 uv0 = vec2(0., fl_height);\n    vec4 na = nyancat(uv, uv0, scale, time); // color, alpha\n    na.rgb = pow(na.rgb, vec3(2.2)); // gamma\n    \n    // compose    \n    O = vec4(bg.rgb * bg.a, bg.a);\n    O = mix(O, st, st.a);\n    O = mix(O, fl, fl.a); \n    O = mix(O, ba, ba.a);\n    O = mix(O, na, na.a);\n    O = vec4(O.rgb / O.a, O.a);\n    \n    // gamma\n    O = vec4(pow(O.rgb, vec3(1./2.2)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"# define R iResolution\n\nconst float PI_2 = acos(0.), PI = 2.*PI_2, PI2 = 2.*PI;\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) // za*zb\n{\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) // 1/z\n{\n    return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) // z/w\n{\n    return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, int n) // z^n\n{\n    vec2 w = z;\n    for (int i = 1; i < n; i++){\n    w = cmul(w,z);\n    }\n    return w;\n}\n\nvec2 crot(vec2 z,float a) // z*e^(i*a)\n{\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) // (z*e^ia)^n-x0\n{\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// noise \n// https://www.shadertoy.com/view/4dXGWH \"Nyancat\" by mu6k\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321);\n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\treturn hashmix(pd,(pd+vec2(1.0,1.0)), pm);\n}\n\n// smooth\nfloat S(float sdf, float pix) {return smoothstep(-pix, +pix, sdf);}\n\n// color\nvec3 h2rgb(float h) {return .5*(1.+cos(PI2*(h+vec3(0,1,2)/3.)));}\n","name":"Common","description":"","type":"common"}]}