{"ver":"0.1","info":{"id":"wttGD8","date":"1576227490","viewed":134,"name":"Polyp","username":"indigofracture","description":"A weird wriggly thing.\nMy first shader on shadertoy! :D","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["simplex","spider","octopus","creepy","tentacle","squid","swim","polyp","wriggle","crawl","crawling","crawly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265\n\n#define LIMBS 4\n#define JOINTS 14\n#define LIMB_LENGTH 0.025*0.5\n#define FATNESS 0.8\n\n// Reverse colors and thickness for cool effect.\n#define REVERSED\n\n\n// Optimized Simplex noise functions from Makio64: https://www.shadertoy.com/view/4sdGD8\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\n// Draw line and circle functions from Loeizd: https://www.shadertoy.com/view/4ljfRD\n\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\nfloat drawCircle(vec2 p, float d, vec2 uv)\n{\n    return (distance(p, uv) <= d) ? 1. : 0.;\n}\n\n// Basic map function from: https://stackoverflow.com/questions/17134839/how-does-the-map-function-in-processing-work\n\nfloat map(float value, \n                              float istart, \n                              float istop, \n                              float ostart, \n                              float ostop) {\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\n\n\nvec3 bodycolor1 = vec3(1.0,0.8,0.8);\nvec3 bodycolor2 = vec3(0.2,0.0,0.3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime*45.; //Pro Tipâ„¢: multipluy time to go faster!\n\n    vec2 noise_vec = vec2(-t * 0.01, t * 0.01);\n    \n    float lines = 0.;\n    \n    vec2 init = vec2(0.5+sin(t*0.01) * 0.3, 0.5+cos(t*0.01) * 0.3);//vec2(0.5-t*0.001,0.5 + snoise(noise_vec)*0.5);\n    \n    #ifndef REVERSED\n    // Main fadeoff mapping\n    float fadeoff = map(distance(init,uv),0.,LIMB_LENGTH*float(JOINTS),FATNESS,0.0);//((LIMB_LENGTH*float(JOINTS))-distance(init, uv));\n\t#else\n    // Reversed fadeoff mapping (gives a cool widening effect)\n    float fadeoff = map(distance(init,uv),0.,LIMB_LENGTH*float(JOINTS),0.0,FATNESS);\n    #endif\n    \n    for(int i = 0; i < LIMBS; ++i) {\n            vec2 prevpos = init;\n        for(int j = 0; j < JOINTS; ++j) {\n            float theta = map(snoise(noise_vec+float(j)+(float(i)*float(JOINTS))), -1., 1., -pi, pi) + (t*0.01);\n            noise_vec += float(j);\n            vec2 nextpos = prevpos - (vec2(sin(theta), cos(theta)) * LIMB_LENGTH);\n            if(lines == 0.)\n            \tlines += drawLine(prevpos, nextpos, uv, fadeoff*16.) * fadeoff;//* map(float(j), 0., float(JOINTS), 1.0, 0.0);\n            prevpos = nextpos;\n        }\n    }\n    \n    if(lines == 0.)\n        lines += drawCircle(init, .02+(sin(t*0.1) + 1.)*0.02 * snoise(noise_vec), uv) * fadeoff;\n    \n    vec3 col = vec3(0.,0.,0.);\n    col.r = map(lines, 1.0, 0.0, bodycolor1.r, bodycolor2.r);\n    col.g = map(lines, 1.0, 0.0, bodycolor1.g, bodycolor2.g);\n    col.b = map(lines, 1.0, 0.0, bodycolor1.b, bodycolor2.b);\n    \n\tfragColor = vec4(col.r, col.g, col.b, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define HARMONICS 9.\n#define STEP 1.05946\n#define BPM 310.\n#define NOTES_PER_BEAT 1.0\n#define FALLOFF 14.\n\n\nconst int notes[] = int[](1, 5, 8, 10, 11, 10, 8, 5,\n                          1+3, 5+3, 8+3, 10+3, 11+3, 10+3, 8+3, 5+3,\n                         1+5, 5+5, 8+5, 10+5, 11+5, 10+5, 8+5, 5+5,\n                         1, 5, 8, 10, 13, 15, 17, 25);\n\nvec2 mainSound( in int samp, float time )\n{\n    float o = 0.;\n    int index = int(time/(60./BPM/NOTES_PER_BEAT)) % notes.length();\n    float basefreq = 55. * pow(STEP, float(notes[index]));\n    \n    float t = mod(time,60./BPM);\n    \n    //for(float i = 0.; i < HARMONICS; i += 1.) {\n    for(float i = 0.; i <= (sin(time)+1.)*8.; i += 1.) {\n        o += sin(6.2831*(basefreq+(basefreq*i))*t)*exp(-FALLOFF*t*i);\n    }\n    \n    //o /= HARMONICS;\n    o /= (sin(time)+1.)*8.+0.001;\n    // A 440 Hz wave that attenuates quickly over time\n    return (vec2( o ));\n}","name":"Sound","description":"","type":"sound"}]}