{"ver":"0.1","info":{"id":"DsKyW3","date":"1696887608","viewed":88,"name":"Lava buckets","username":"Krafpy","description":"Infinite lava buckets.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud","light","volumetric","link"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define TAU (2.*PI)\n\n// from: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdTorus(vec3 p, float r, float w){\n    vec2 q = vec2(length(p.xy)-r,p.z);\n    return length(q)-w;\n}\n\n// based on iq's elongate function\nvec3 opElongate(vec3 p, vec3 s){\n    return p - clamp(p, -s, s);\n}\n\nfloat sdLink(vec3 p, float r, float w, float e){\n    return sdTorus(opElongate(p, vec3(0.,0.5*e,0.)), r, w);\n}\n\n// based on iq's revolution function\nvec2 opRevolution(vec3 p, float o){\n    return vec2(length(p.xz)-o,p.y);\n}\n\nfloat sdBox(vec2 p, vec2 b){\n    vec2 q = abs(p) - b;\n    return length(max(q,0.)) + min(0., max(q.x,q.y));\n}\n\nfloat sdLine(vec3 p, vec3 u){\n    return length(p - dot(p,u)*u);\n}\n\nfloat pulse(float x, float a, float b){\n    return smoothstep(0.,a,x)*smoothstep(a+b,a,x);\n}\n\nfloat sdLink(vec3 p){\n    // length 1 link\n    float e = 0.35;\n    float w = 0.107;\n    float r = 0.5 - w - 0.5*e;\n    float h = 1.15;\n    float hh = h*0.5;\n    \n    vec2 y = vec2(p.y+hh,p.y);\n    // repeat only in y+ direction\n    float rep = step(0.,floor(p.y/h));\n    y = mix(y, mod(y,h), rep) - hh;\n    vec3 a = vec3(p.x,y.x,p.z);\n    vec3 b = vec3(p.z,y.y,-p.x);\n    float d1 = sdLink(a, r, w, e);\n    float d2 = sdLink(b, r, w, e);\n    return min(d1, d2);\n}\n\n#define testmin(td,i) if(td<d){d=td;id=i;}\n\nfloat tri(float x){\n    // return 2.*mix(step(mod(x, 2.),1.), step(mod(x+1., 2.),1.), fract(x))-1.;\n    x = mod(x, 2.);\n    return (smoothstep(0.,1.,x)*2.-1.)*(smoothstep(2.,1.,x+0.1)*2.-1.);\n}\n\n#define BUCKET_SPEED 0.1\n#define BUCKET_OFFSET (iTime*BUCKET_SPEED+h*13.)\n\n\nfloat hasLava(vec2 i){\n    float h = hash12(i);\n    return step(mod(BUCKET_OFFSET,2.)-1.,0.);\n}\n\nfloat sdBucket(vec3 p, inout float id){\n    float h = 0.8;\n    vec2 q = opRevolution(p, 0.);\n    \n    float depth = 1.;\n    float thick = 0.;\n    float rad = 1.;\n    float bot = sdBox(q - vec2(0.,-depth+0.5*thick), vec2(rad, 0.5*thick));\n    \n    q = vec2(abs(q.x - rad), q.y);\n    float sid = sdBox(q, vec2(0.5*thick, depth));\n    float d = min(bot, sid) - 0.05;\n    \n    float handle = length(p - vec3(p.x,h,0.)) - 0.15;\n    d = max(d, -handle);\n    \n    vec3 m = vec3(abs(p.x), p.yz) - vec3(rad,1.11,0.);\n    float s = 0.6;\n    // d = min(d, sdLink(m/s)*s);\n    testmin(sdLink(m/s)*s, 1.);\n    \n    return d;\n}\n\n\n#define GRID_SIZE 10.\n\n\nvec2 cell(vec3 p){\n    return floor(p.xz/GRID_SIZE);\n}\n\nvec2 center(vec3 p){\n    return cell(p)*GRID_SIZE + GRID_SIZE*0.5;\n}\n\nfloat height(vec2 i){\n    float h = hash12(i);\n    float dy = tri(BUCKET_OFFSET);\n    return dy*20.;\n}\n\nfloat map(vec3 p, inout float id){\n    id = 0.;\n    \n    vec2 i = cell(p);\n    p.xz = p.xz - center(p);\n    float h = hash12(i);\n    \n    float a = pulse(mod(BUCKET_OFFSET, 1.), 0.01, 0.1);\n    p.xz *= rot(0.07*sin(iTime*20. + p.y*0.5)*a);\n    \n    float dy = tri(BUCKET_OFFSET);\n    p.y -= height(i);\n    p.xz *= rot(sin(iTime*0.9+h*13.)*0.3);\n    \n    float d = sdBucket(p, id);\n    \n    float dl = sdBox(opRevolution(p, 0.), vec2(1.,0.6));\n    float hl = hasLava(i);\n    testmin(hl*dl + (1.-hl)*1e9, 2.);\n    \n    return d;\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd, float maxT, inout float id){\n    float t = 0.;\n    for(float i = 0.; i < 128. && t < maxT; ++i){\n        float d = map(ro + rd*t, id);\n        if(d < 0.01){\n            return t;\n        }\n        t += d;\n    }\n    return -1.;\n}\n\nfloat nextCell(vec2 ro, vec2 rd, float s){\n    const float eps = 0.002;\n    vec2 i = floor(ro/s)*s;\n    vec2 d = i + max(sign(rd)*s,0.) - ro;\n    vec2 t = d/rd;\n    return min(t.x,t.y) + eps;\n}\n\nfloat trace(vec3 ro, vec3 rd, inout float id){\n    float t = 0.;\n    for(float i = 0.; i < 10.; ++i){\n        float maxT = nextCell(ro.xz, rd.xz, GRID_SIZE);\n        float d = raymarch(ro, rd, maxT, id);\n        if(d > 0.){\n            t += d;\n            return t;\n        }\n        t += maxT;\n        ro += maxT*rd;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 p){\n    vec2 h = vec2(0.001, 0.);\n    float i = 0.;\n    return normalize(vec3(\n        map(p+h.xyy, i)-map(p-h.xyy, i),\n        map(p+h.yxy, i)-map(p-h.yxy, i),\n        map(p+h.yyx, i)-map(p-h.yyx, i)\n    ));\n}\n\n\nfloat noise(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    //f = f * f * (3. - 2. * f);\n    f = smoothstep(0., 1., f);\n    // f = f * f * f * (6. * f * f - 15. * f + 10.);\n    p = i + f;\n    return textureLod(iChannel0, (p+0.5)/32., 0.).r;\n}\n\nfloat fbm(vec3 p){\n    float f;\n    f = 0.5 * noise(p * 1.);\n    f += 0.25 * noise(p * 2.);\n    f += 0.125 * noise(p * 4.);\n    //f += 0.0625 * noise(p * 8.);\n    return f;\n}\n\n\nvec3 triplanar(sampler2D tex, vec3 p, vec3 n){\n    vec2 uvx = p.zy;\n    vec2 uvy = p.xz;\n    vec2 uvz = p.xy;\n    n = abs(n);\n    return n.x * texture(iChannel1, uvx).rgb +\n           n.y * texture(iChannel1, uvy).rgb +\n           n.z * texture(iChannel1, uvz).rgb;\n}\n\n\nvec3 bucketTex(vec3 p, vec3 n, float id){\n    if(id == 0.){\n        return triplanar(iChannel1, p*0.1, n);\n    } else {\n        vec3 c = triplanar(iChannel1, p*1., n)*0.7;\n        c += triplanar(iChannel1, p*2., n)*0.5;\n        return c*pow(dot(c, vec3(1.))/3., 2.);\n    }\n}\n\nvec3 getColor(vec3 p, float id, vec3 rd){\n    vec2 i = cell(p);\n    vec2 cen = center(p);\n    \n    vec3 lc = vec3(2.,1.,0.5);\n    if(id == 2.){\n        return lc;\n    }\n    vec3 col = vec3(0.);\n    vec3 ldir = vec3(0.,-2.,-0.5); ldir = normalize(ldir);\n    vec3 lcol = vec3(0.7, 0.3, 0.1);\n    \n    vec3 n = normal(p);\n    float dif = max(dot(n, ldir), 0.);\n    float spec = pow(max(0., dot(reflect(-vec3(0.,-1.,0.), n), -rd)), 20.);\n    float specd = spec;\n    vec3 q = p; q.xz -= cen; q.y -= height(i);\n    vec3 tex = pow(bucketTex(q, n, id), vec3(4.));\n    if(id == 0.){\n        tex = pow(bucketTex(q, n, id)*1.3, vec3(9.));\n        float s = smoothstep(-0.1, 1., q.y);\n        q.y *= 0.02;\n        vec3 tex2 = pow(bucketTex(q, n, id)*1.3, vec3(9.));\n        spec = pow(max(0., dot(reflect(-vec3(0.,1.,0.), n), -rd)), 20.);\n        tex = mix(tex, tex2, s);\n    }\n    //col = tex*lcol*dif;\n    col = tex*lcol*dif + lcol*spec*tex;\n    col += tex*max(0.,n.y)*0.1*vec3(0.7,0.7,1.);\n    \n    float inwards = max(0., -dot(normalize(p.xz-cen), n.xz));\n    float h = p.y - height(i);\n    \n    vec3 ref = hasLava(i)*lc*inwards*exp(-1.*(h-0.8));\n    if(id == 1.){\n        ref *= (specd*6. + dif*2.5);\n    }\n    col += ref;\n    col += hasLava(i)*vec3(0.025,0.0,0.)*exp(-1.*(h))*smoothstep(1.,0.,h);\n    \n    return col;\n}\n\n\n#define LAVA_LEVEL -11.\n#define FOG_HEIGHT -7.\n\nfloat getDensity(vec3 p){\n    float id = 0.;\n    float d = map(p,id);\n    p.y -= iTime*1.;\n    return fbm(p*0.7)*(1.+3.*exp(-2.*d));\n}\n\nfloat marchDensity(vec3 ro, vec3 rd, float ta, float tb){\n    tb = min(tb, 60.);\n    ta = min(ta, tb);\n    float dt = 0.1;\n    float od = 0.;\n    float jit = 0.02;\n    for(float t = ta+dt; t <= tb; t += dt){\n        vec3 p = ro + rd*t;\n        float dens = getDensity(p);\n        od += dens * dt;\n        t += hash12(p.xz*32.)*jit;\n        dt *= 1.05;\n        jit *= 1.1;\n    }\n    return exp(-od);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(2.,3.,-5.+iTime*2.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    rd.yz *= rot(0.4);\n    rd.xz *= rot(0.5);\n    \n    vec3 col = vec3(0.);\n    \n    float id;\n    float t = trace(ro, rd, id);\n    if(t > 0.){\n        vec3 p = ro + rd*t;\n        col = getColor(p, id, rd);\n    } else if(rd.y >= 0.) {\n        col = vec3(0.,0.,0.);\n    } else {\n        col = vec3(2.,1.,0.);\n    }\n    \n    // bottom lava fog\n    float tf0 = (FOG_HEIGHT-ro.y)/rd.y;\n    if(rd.y < 0. && (tf0 < t || t < 0.)){\n        float tf1 = (LAVA_LEVEL-ro.y)/rd.y;\n        float trans1 = marchDensity(ro, rd, tf0, tf1);\n        vec3 c = mix(vec3(0.), vec3(1.,0.45,0.), trans1);\n        c = pow(c*10., vec3(2.));\n        c = clamp(c, 0., 1.);\n        if(t > 0.){\n            float trans2 = marchDensity(ro, rd, tf0, t);\n            vec3 p = ro + rd*t;\n            float h = smoothstep(0.,1.,exp((p.y-FOG_HEIGHT)*3.));\n            c = mix(col, c, 1.-trans2);\n        }\n        col = c;\n        t = tf0;\n    }\n    \n    if(t > 0.){\n        col *= smoothstep(50., 0., t);\n    }\n    \n    col = pow(col, vec3(1./2.2));\n    \n    // vignetting\n    vec2 uv01 = fragCoord/iResolution.xy;\n    float k = 32.*uv01.x*(1.-uv01.x)*uv01.y*(1.-uv01.y);\n    k = pow(k, 1./15.);\n    col *= k;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}