{"ver":"0.1","info":{"id":"dstXWr","date":"1681984260","viewed":97,"name":"First Assignment 2023","username":"GergoPapp","description":"ARI","likes":44,"published":1,"flags":48,"usePreview":1,"tags":["raycast","camera","postprocess","buffer","lesson"],"hasliked":0,"parentid":"msdXDn","parentname":"CG2023 04"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    ivec2 pix = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, pix, 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int spheresNo = 4;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int triangleNo = 8;\nTriangle triangles[triangleNo];\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-4.5,3,1.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    \n    // no intersection\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0), ray.tmax, s.mat_id, s.textured);\n    \n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    \n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    \n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    \n    return TraceResult(normal, t, s.mat_id, s.textured);\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle triangle)\n{\n    // Calc 2 edges of triangle\n    vec3 ab = triangle.b - triangle.a;\n    vec3 ac = triangle.c - triangle.a;\n    \n    vec3 pv = cross(ray.v, ac);\n    float det = dot(ab, pv);\n    \n    // Check if the ray and triangle are parallel or not\n    if (abs(det) < 1e-6)\n        return TraceResult(vec3(0), ray.tmax, -1, triangle.textured);\n    \n    float invdet = 1. / det;\n    \n    vec3 tv = ray.p0 - triangle.a;\n    float u = dot(tv, pv) * invdet;\n    \n    if (u < 0. || u > 1.)\n        return TraceResult(vec3(0), ray.tmax, -1, triangle.textured);\n        \n    vec3 qv = cross(tv, ab);\n    float v = dot(ray.v, qv) * invdet;\n    \n    if (v < 0. || u + v > 1.)\n        return TraceResult(vec3(0), ray.tmax, -1, triangle.textured);\n        \n    float t = dot(ac, qv) * invdet;\n    vec3 tn = normalize(cross(ab, ac));\n\n    return TraceResult(tn, t, triangle.mat_id, triangle.textured);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    \n    return TraceResult(plane.n, t, plane.mat_id, plane.textured);\n}\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax, 0, false);\n    \n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    for(int i = 0; i < triangleNo; ++i)\n    {\n        TraceResult res3 = intersectTriangle(ray, triangles[i]);\n        if(res3.t < ray.tmax && res3.t > ray.tmin && res3.t < res.t){\n            res = res3;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\n// Calculates the amount of shadow is casted by an object onto the scene\nfloat shadow(vec3 ray_origin, vec3 ray_direction, float mint, float tmax, float softness)\n{\n    float t = mint;\n    float res = 1.0;\n    \n    // Cast ray towards the light source\n    Ray ray = Ray(ray_origin + ray_direction * t, mint, ray_direction, tmax);\n    TraceResult tr = raycast(ray);\n    float h = tr.t;\n    \n    // Iteratively checks for occluders at increasing distances.\n    for(int i = 0; i < 64; i++) {\n\t\tres = min(res, smoothstep(0.0, 1.0, softness * h / t));\n        t += clamp(h, 0.01, 0.2);\n        \n        if(res < 0.0005 || t > 8.) {\n            break;\n        }\n    }\n    \n    return clamp(res,0.0,1.0);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\n// Calculates color\nvec4 hitColor(Ray ray, TraceResult tr, vec3 lightPos)\n{\n    Material mat = materials[tr.mat_id];\n    \n    vec3 p = ray.p0 + ray.v * tr.t; // Point of hit\n    vec3 n = tr.n; // Surface normal\n    \n    vec3 l = lightPos - p;\n    float lightDist = length(l);\n    l /= lightDist; // normalized direction to the light\n    \n    // Create ray from hit point to the light source with offset to avoid self-intersection.\n    Ray shadowray = Ray(p+0.0001 * n, 0.001, l, lightDist);\n    TraceResult res = raycast(shadowray);\n    \n    vec3 v = -ray.v;\n    l = normalize(lightPos - p);\n\n    // Fresnel effect\n    float fresnel_pow = mix(2., 3., mat.metalness);\n    vec3 color_mod = mat.color + 0.3;\n    vec3 light_color = pow(texture(iChannel2, vec3(1.0, 1.0, 1.0)).xyz * 1.2, vec3(2.));\n\n    float fresnel = max(1.0 - dot(n, -ray.v), 0.0);\n    fresnel = pow(fresnel, fresnel_pow);\n\n    // Image-Based Lighting\n    vec3 dif_ibl = pow(textureBlurred(iChannel2, n), vec3(2.));\n    vec3 ref_ibl = pow(textureBlurred(iChannel2, reflect(ray.v, n)), vec3(2.));\n    \n    // Reflection\n    vec3 reflection = pow(texture(iChannel2, reflect(ray.v, n)).xyz, vec3(2.));\n    reflection = mix(reflection, ref_ibl, (1.0 - fresnel) * mat.roughness);\n    reflection = mix(reflection, ref_ibl, mat.roughness);\n    \n    // Specular\n    float power = 1.0 / max(mat.roughness * 0.4, 0.01);\n    vec3 spec = mat.color * GGX(n, -ray.v, lightPos, mat.roughness * 0.7, 0.2);\n    reflection -= spec;\n    \n    // Shadow\n    float sh = 1.;\n    if(!(res.t == shadowray.tmax || mat.emission != vec3(0.) || materials[res.mat_id].emission != vec3(0.))) {\n        sh = shadow(p, l, 0.001, 100., 1.);\n    }\n    \n    // Diffusion\n    vec3 diffuse = dif_ibl * dot(n,l) * sh;\n    diffuse = mix(diffuse * color_mod, reflection, fresnel); \n    \n    vec3 final_color = mix(diffuse, reflection * color_mod, mat.metalness) + spec;\n    \n    vec3 specular;\n    // Check if angle is valid for reflection. If less than zero, then the light is hitting from behind\n    if(dot(n,l) >= 0.) {\n        float spec_dot = dot(reflect(l, n), v);\n        specular = l * vec3(10, 10, 10) * pow(max(0.0, spec_dot), 100.);\n    }\n    else { specular = vec3(0); }\n    \n    // Texture\n    if(tr.textured) {\n        vec3 tex = texture(iChannel3, p.xy).rgb;\n        final_color += tex;\n    }\n    \n    vec3 col = diffuse + (final_color + specular * mat.metalness) * max(dot(n,l), 0.);\n    \n    // Is it a light source?\n    if(mat.emission != vec3(0.)) {\n        return vec4(col + clamp(mat.emission, 0., 1.), 1.);\n    }\n    \n    return vec4(col, 1.);\n}\n\n// Calculate fragment color lit by a light source\nvec4 getFragmentColor(Ray ray, TraceResult ret)\n{\n    vec4 result;\n    \n    if(ray.tmax > ret.t) {\n        result = hitColor(ray, ret, vec3(10., 10., 10.));\n        \n        vec4 color_tmp;\n        \n        // Check if any sphere is a light source\n        for(int i = 0; i < spheresNo; ++i) {\n            if(materials[spheres[i].mat_id].emission != vec3(0.)) {\n                color_tmp += hitColor(ray, ret, spheres[i].c);\n            }\n        }\n\n        // Check if any triangle is a light source\n        for(int i = 0; i < triangleNo; ++i) {\n            if(materials[triangles[i].mat_id].emission != vec3(0.)) {\n                color_tmp += hitColor(ray, ret, triangles[i].a); \n                color_tmp += hitColor(ray, ret, triangles[i].b);\n                color_tmp += hitColor(ray, ret, triangles[i].c);\n            }\n        }\n        \n        // Add additional emission of objects\n        result += color_tmp;\n    }\n    \n    // Missed ray in scene\n    else {\n        result = missColor(ray);\n    }\n    \n    return result * 0.8;\n}\n\nvec4 getRayColor(Ray ray, inout uint rngState)\n{\n    vec3 rayPos = ray.p0; // Starting position\n    vec3 rayDir = ray.v;  // Direction\n    \n    vec4 throughput = vec4(.8); // Color multiplier, modulates the color of objects that the ray bounces off\n\n    vec4 ret = vec4(0.);\n    \n    // Ray bouncing\n    for(int bounce = 0; bounce <= num_bounces; ++bounce)\n    {\n        TraceResult tr = raycast(ray);\n        \n        if(ray.tmax <= ret.t) {\n            ret += vec4(texture(iChannel2, ray.v).xyz, 1.) * throughput;\n        }\n        \n        // Calc new poisition of ray after bounce.\n        // Nudge is used to avoid self intersection.\n        rayPos = (rayPos + rayDir * tr.t) + tr.n * normal_nudge;\n        \n        // Check refractiveness of material\n        // Index of refraction greater than 0?\n        if(0. < materials[tr.mat_id].ior) {\n            \n            // Calc refracted ray\n            Ray refracted_ray = Ray(rayPos, ray.tmin, refract(rayDir, tr.n, ray.tmin), ray.tmax);\n            \n            // Calc intersection point and refrected ray color\n            TraceResult refracted = raycast(refracted_ray);   \n            ret += getFragmentColor(refracted_ray, refracted) * materials[tr.mat_id].ior * throughput;\n        }\n        \n        // New direction for ray by adding a random unit vector to the normal\n        rayDir = normalize(tr.n + randomUnitVector(rngState));\n        \n        // Calc color of current intersection point\n        ret += getFragmentColor(ray, tr) * (1. - materials[tr.mat_id].ior) * throughput;\n        ret += vec4(materials[tr.mat_id].emission, 1.0) * throughput;\n        \n        throughput *= vec4(materials[tr.mat_id].color, 1.);\n        \n        // New ray with updated position for further bouncing\n        Ray newRay = Ray(rayPos, ray.tmin, rayDir, ray.tmax);\n        ray = newRay;\n    }\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize Planes\n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)), 3, false);\n    \n    // Initialize Triangles\n    triangles[0] = Triangle(vec3(0., 1.7, 0.), vec3(-1, 3., 1.), vec3(-1, 3., -1.), 0, false);\n    triangles[1] = Triangle(vec3(0., 1.7, 0.), vec3(-1, 3., -1.), vec3(1, 3., -1.), 0, false);\n    triangles[2] = Triangle(vec3(0., 1.7, 0.), vec3(1, 3., -1.), vec3(1, 3., 1.), 0, false);\n    triangles[3] = Triangle(vec3(0., 1.7, 0.), vec3(1, 3., 1.), vec3(-1, 3., 1.), 0, false);\n    \n    triangles[4] = Triangle(vec3(0., 4.3, 0.), vec3(-1, 3., -1.), vec3(-1, 3., 1.), 0, false);\n    triangles[5] = Triangle(vec3(0., 4.3, 0.), vec3(1, 3., -1.), vec3(-1, 3., -1.), 0, false);\n    triangles[6] = Triangle(vec3(0., 4.3, 0.), vec3(1, 3., 1.), vec3(1, 3., -1.), 0, false);\n    triangles[7] = Triangle(vec3(0., 4.3, 0.), vec3(-1, 3., 1.), vec3(1, 3., 1.), 0, false);\n    \n    // Initialize Transformation\n    float time = iTime * 0.5;\n    mat3 rotation = mat3(\n        vec3(cos(time), 0, sin(time)),\n        vec3(0, 1, 0),\n        vec3(-sin(time), 0, cos(time))\n    );\n    \n    // Transform Triangles\n    for (int i = 0; i < triangleNo; i++) {\n        triangles[i].a = rotation * triangles[i].a;\n        triangles[i].b = rotation * triangles[i].b;\n        triangles[i].c = rotation * triangles[i].c;\n    }\n\n    // Initialize Spheres\n    spheres[0] = Sphere(vec3(-3., 3., 0), 0.7f, 2, false);\n    spheres[1] = Sphere(vec3(3., 3., 0), 0.7f, 0, true);\n    spheres[2] = Sphere(vec3(0., 3., -3), 0.7f, 4, false);\n    spheres[3] = Sphere(vec3(0., 3., 3), 0.7f, 5, false);\n\n    // Transform Spheres\n    for (int i = 0; i < spheresNo; i++) {\n        spheres[i].c = rotation * spheres[i].c;\n    }\n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from camera\n    \n    // Seed for random number generator. Helps with reproducibility\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    // Get color of pixel based on ray and scene objects.\n    // Traces the generated ray through the scene to find any intersections with objects.\n    fragColor = getRayColor(ray, rngState);\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\nconst float c_twopi = 2. * pi;\nconst int num_bounces = 0;\nconst float normal_nudge = 0.01; // correction variable for frame rendering\n\nstruct Material {\n    vec3  color;        // [0,1/pi]\n    float roughness;    // [0,~7]\n    vec3  emission;\t    // [0, inf] ambient color\n    float metalness;    // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n    float ior;          // Index of refraction\n};\n\n#define LIGHTSRC(r,g,b)    Material(vec3(0,0,0)   ,  1.      ,    vec3(r,g,b), 0.  , 0.)\n#define METALLIC(r,g,b,m)  Material(vec3(r,g,b)/pi,  float(m),    vec3(0,0,0), 0.9 , 0.)\n#define NONMETAL(r,g,b,m)  Material(vec3(r,g,b)/pi,  float(m),    vec3(0,0,0), 0.02, 0.)\n#define NOMATERIAL(r,g,b)  Material(vec3(0,0,0),     0.      ,    vec3(0,0,0), 0.,   0.)\n#define REFRACTS(r,g,b,m)  Material(vec3(r,g,b)/pi,  float(m),    vec3(0,0,0), 0.02, 0.8)\n\nconst Material materials[] = Material[](\n    METALLIC(  .3,  .4, .1, 0.03),\n    NONMETAL( .5, .01,  1,   .1),\n    NONMETAL(  1,   0.5, .1,    1),\n    NONMETAL(   1,   1,  1,  0.3),\n    LIGHTSRC( 0.6, 0.6, 0.6),\n    REFRACTS( .01, .01,  0.1,   .01)\n);\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    int mat_id;\n    bool textured;\n};\n\nstruct Triangle {\n    vec3 a, b, c;\n    int mat_id;\n    bool textured;\n};\n\nstruct Plane {\n    vec3 q0;   // any point on the plane\n    vec3 n;    // normal\n    int mat_id;\n    bool textured;\n};\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    int mat_id;\n    bool textured;\n};\n\n// https://www.shadertoy.com/view/XsfXWX\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\nvec3 textureAVG(samplerCube tex, vec3 tc) { \n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlurred(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\n\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 randomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}","name":"Common","description":"","type":"common"}]}