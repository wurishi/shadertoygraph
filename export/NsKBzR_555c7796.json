{"ver":"0.1","info":{"id":"NsKBzR","date":"1657566658","viewed":149,"name":"grid colors disco stu","username":"Mojomajor","description":"disco grid \nnight fever, night feveaaah","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["discogrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ltSSzD","filepath":"https://soundcloud.com/mojomajor-zen/steady-line","previewfilepath":"https://soundcloud.com/mojomajor-zen/steady-line","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define time iTime*0.05\n#define PAPERGRAIN 0.0\n#define VIGNETTE 0.35\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(h)*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\nfloat sawtooh(float x) {\n    return sin(x + sin(x))*0.5+0.5;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    float _sin = cos(time)*.5+0.5;\n    \n    //grid\n    float gridSize = 20.;\n    // grid uv\n    vec2 uv2 = fract(uv*gridSize);\n    // color uv\n    vec2 uv3 = floor(uv*gridSize)/gridSize; \n    \n    // mad fbm\n    vec2 offs = vec2(fbm(uv3/5. + time/4.), fbm(uv/9. + time/4. + .35));\n    const float oFct = .04;\n    // magic window\n    //if (mod(uv.x*100.,2.)<1.5)\n    //    if (mod(uv.y*100.,2.)<1.5)\n    //        uv3 -= (offs - .5)*oFct;\n    uv3 -= (offs - .5)*oFct;\n    \n    //random color for every grid part\n    vec3 randColor = vec3(0.);\n    \n    randColor = vec3(rand(uv3), rand(uv3+vec2(10.0)), rand(uv3+vec2(60.0)));\n    \n    // To move the cross we move the space\n    vec2 translate = vec2(cos(time),sin(time));\n    vec2 origUv3 = uv3;\n    uv3 += translate*0.35;\n    uv3 = rotate2d( sin(time)*PI ) * uv3;\n    randColor += texture( iChannel0, uv3 ).xyz;\n    vec3 randColor2 = mix(texture( iChannel0, uv3 ).xyz, randColor, sawtooh(time));\n    \n    float ampl = texture(iChannel1,origUv3).x;\n\n\n    randColor = mix(randColor2,randColor,_sin*_sin);\n    randColor = mix(randColor,vec3(.9),ampl);\n    \n    float aBox=box(uv2, vec2(gridSize));\n    \n    float borderWidth= 0.1;\n    vec3 color = vec3(randColor * aBox );\n    // bottom-left grid borders\n    vec2 bl = step(vec2(borderWidth),uv2);\n    float pct = bl.x * bl.y;\n    color *= pct;\n    \n    \n    \n    \n\n    // Scaling factor.\n    float gSc = 1.;\n    vec2 p = uv;\n    // Cheap paper grain... Also barely worth the effort. :)\n    vec2 oP = floor(p/gSc*iResolution.x/2.);\n    vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    vec3 pg = .9 + .1*rn3.xyz  + .1*rn3.xxx;\n    color *= mix(color, pg , PAPERGRAIN);\n    \n    // vignette\n    color *= 0.9*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), VIGNETTE *ampl); //is an exaggerated variant\n    \n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}