{"ver":"0.1","info":{"id":"WdS3Dw","date":"1548966932","viewed":58,"name":"SecondTestingShader","username":"quicksilver","description":"practicing ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Learning from the book of shaders: https://thebookofshaders.com/\n\n//plot a line on y axis using a value between .0-1.\n\nfloat plot(vec2 uv, float point){\n    //smoothstep â€” perform Hermite interpolation between two values\n    return smoothstep(point-.08, point, uv.x) - smoothstep( point, point +0.01, uv.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n \n    //normalized pixel coordinates (from 0 to 1)\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n   \n    //put the coordinates more to the middle\n    uv-=.5;\n    uv.y +=.4;\n    //we get the normalized value of the x coordinate\n    float y = uv.y;\n\n    //plug it in to the plot fuction and store it to point \n    //trig functions will have the line act along the trig function\n    float point = plot(uv * (2.*sin(iTime) *cos(iTime)), y);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //1. is BRIGHTNESS\n    //point is the plotted line\n    //+point will make the plotted line white and and availabe to be coloured\n    //*col adds the colour\n    vec3 outVar = (1.-point ) + (point) * col;\n    fragColor = vec4(outVar  , 1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}