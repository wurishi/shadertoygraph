{"ver":"0.1","info":{"id":"DdfBDl","date":"1689267566","viewed":140,"name":"Perspective Distortion Example","username":"fizzer","description":"A small example of the distortion effects caused by relatively wide or narrow fields of view. Click and drag horizontally to manually change the camera distance.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["distortion","camera","perspective","fov"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// In this scene there is a camera moving between two fixed distances from a sphere.\n// The camera's view frustum is set up so that the boundary of the sphere is fixed to a circle\n// in screenspace. The idea is to show the effect that the changing field of view has\n// on the textured surface of the sphere.\n\n// This is more-or-less the same as the effect known as \"dolly zoom\" in cinematography.\n\nconst float pi = 3.14159265358979323;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Parameters\n    vec2 range = vec2(1.01, 4.);\n\n    float cameraSphereDistance = mix(range.x, range.y, .5 + .5 * cos(iTime));\n    \n    if(iMouse.z > .5)\n        cameraSphereDistance = mix(range.x, range.y, iMouse.x / iResolution.x);\n    \n    // Problem geometry\n    float innerConeHalfAngle = acos(1. / cameraSphereDistance);\n    float outerConeHalfAngle = pi / 2. - innerConeHalfAngle;\n    float b = sqrt(cameraSphereDistance * cameraSphereDistance - 1.);\n    float c = cos(outerConeHalfAngle) * b;\n    float e = sin(innerConeHalfAngle);\n\n    // Camera / ray setup\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 2.;\n    vec3 ro = vec3(0, 0, cameraSphereDistance), rd = normalize(vec3(uv * e * 1.2, -c));\n    \n    vec3 col = vec3(0);\n\n    // Ray-sphere intersection\n    vec2 is = vec2(1, 0);\n    \n    {\n       float b = 2. * dot(rd, ro);\n       float c = cameraSphereDistance * cameraSphereDistance - 1.;\n       float desc = b * b - 4. * c;\n       if (desc >= 0.)\n           is = (sqrt(desc) * vec2(-1, 1) - b) / 2.;\n    }\n\n    // Environment texture\n    col = pow(texture(iChannel0, rd.zyx).rgb, vec3(2));\n\n    if(is.x > 0. && is.x <= is.y)\n    {\n        // Surface texture\n        vec3 rp = ro + rd * is.x;\n        vec2 uv = vec2(atan(rp.z, rp.x), asin(rp.y)) / pi * 4.;\n        col = .5 + .5 * vec3(step(.5, fract(uv.x * 3. +\n                        .5 * step(.5, fract(uv.y * 3.)))));\n        col *= pow(texture(iChannel3, uv).rgb, vec3(2)) * .5 + .5;\n    }\n\n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}