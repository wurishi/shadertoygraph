{"ver":"0.1","info":{"id":"WlGczK","date":"1611896487","viewed":335,"name":"bounds of volume","username":"Carandiru","description":"testing out Ric3cir121 3d volume template from https://www.shadertoy.com/view/wtdcD2\n\na 3d texturing approach...","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["volume","volumetric","3dtexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WlGczK\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n#define SCANLINE_INTERLEAVE 5.0f\n\n// using the excellent 3d volume template by  Ric3cir121\n// https://www.shadertoy.com/view/wtdcD2\n\n// camera setup - https://www.shadertoy.com/view/4djXRh\nvoid camera(in vec2 uv, in vec3 eye, in vec3 at, in vec3 up, out vec3 ro, out vec3 rd)\n{\t\n\tvec3 cw = normalize(at - eye);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu,cw));\n\n    vec3 virtscreen = eye + cw * 2.0 + (cu * uv.x + cv * uv.y);\n    ro = eye + (cu * uv.x + cv * uv.y);\n\trd = normalize(virtscreen - ro);\n}\n\nvec2 intersect_box(in vec3 orig, in vec3 dir) {\n\n\tvec3 inv_dir = 1.0f / dir;\n\tvec3 tmin_tmp = (vec3(-1.0f) - orig) * inv_dir;\n\tvec3 tmax_tmp = (vec3(1.0f) - orig) * inv_dir;\n\tvec3 tmin = min(tmin_tmp, tmax_tmp);\n\tvec3 tmax = max(tmin_tmp, tmax_tmp);\n\n\treturn vec2(max(tmin.x, max(tmin.y, tmin.z)), min(tmax.x, min(tmax.y, tmax.z)));\n}\n\nfloat aaStep(in float compValue, in float gradient){\n  float halfChange = fwidth(gradient) * 0.5f;\n\n  //base the range of the inverse lerp on the change over one pixel\n  float lowerEdge = compValue - halfChange;\n  float upperEdge = compValue + halfChange;\n  //do the inverse interpolation\n  return( clamp((gradient - lowerEdge) / (upperEdge - lowerEdge), 0.0f, 1.0f) );\n}\n\nconst vec3 ld = normalize(vec3(0.35f, 0.0f, 0.1f));\nconst vec3 gui_green = vec3(266.666e-3f, 913.725e-3f, 537.254e-3f);\nconst vec3 gui_bleed = vec3(619.607e-3f, 1.0f, 792.156e-3f);\n\nvoid mainImage(out vec4 O,vec2 u){\n   \n    vec2 uv = 2.0f * u/iResolution.xy - 1.0f;\n\n\t//uv.x *= iResolution.x / iResolution.y;\n        \n    vec3 ro, rd;\n    {\n        float dist = 5.0000f;\n        \n        const vec3 at  = vec3(0, 0, 0);\n        vec3 eye = v3_rotate_azimuth(vec3(dist, dist, dist), iTime * CAMERA_SPEED);\n        const vec3 up  = vec3(0,0,1);\n        camera(uv, eye, at, up, ro, rd);\n    }\n    \n    vec2 t_hit = intersect_box(ro, rd);\n\tif (t_hit.x > t_hit.y) {\n        O = vec4(0);\n        return;\n\t}\n\n\tt_hit.x = max(t_hit.x, 0.0f);\n    \n\tfloat interval_length = (t_hit.y - t_hit.x);\n    \n    float inv_num_steps = 1.0f / length(k_VolumeDimensions * abs(rd)); // number of steps for full volume\n\tfloat dt = (interval_length) * inv_num_steps;\t// dt calculated @ what would be the full volume interval\n    dt = max(MIN_STEP, dt);\n    \n    \n    vec3 p = ro + t_hit.x * rd + textureLod(iChannel1, uv, 0.0f).r * rd * dt * 0.5f; // start with bluenoise jitter offset (up to 1/2 dt)\n    \n    // begin volumetric raymarch\n    vec4 voxel = vec4(vec3(0.0f), 1.0f);\n\t\n    for( float interval_remaining = interval_length; \n         interval_remaining >= 0.0f ; interval_remaining -= dt ) \n    {  // fast sign test    \n    \n        vec4 sampling = volume(iChannel0, p);\n        \n        vec3 n = normalize(sampling.rgb * 2.0f - 1.0f);\n        float NdotL = max(0.0f, dot(n, ld));\n        float NdotV = dot(n, -rd);\n        \n        float fresnel = pow(1.0f - NdotV, 5.0f);\n        \n        vec3 light_color = gui_bleed * NdotL * (1.0f - fresnel) + gui_green * fresnel;\n        \n        // integration\n        float sigmaS = sampling.a;\n\t\tfloat sigmaE = max(EPSILON, sigmaS); // to avoid division by zero extinction\n                \n        vec3 Li = light_color * sigmaS;// incoming light\n        float sigma_dt = exp2(sigmaE * k_sqrtMaxSteps * dt * -2.0f);\n        vec3 Sint = (Li - Li * sigma_dt) / sigmaE; // integrate along the current step segment\n\n        voxel.light += voxel.tran * Sint; // accumulate and also take into account the transmittance from previous steps\n\n        // Evaluate transmittance to view independentely (change in transmittance)\n        voxel.tran *= sigma_dt;\n\n        p += dt * rd;\n    }\n    \n    \n    vec3 color = voxel.light * (1.0f - voxel.tran);\n    \n    // special effect\n    color = mix(vec3(0) + color * pow(1.0f - voxel.tran, 5.0f), color, aaStep( SCANLINE_INTERLEAVE * 0.5f, mod(u.y, SCANLINE_INTERLEAVE - (1.0f / iResolution.y) * 0.5f) ) );\n    \n    \n    O = vec4(color,1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI (3.14159265358979323846)\n\n#define EPSILON 0.000000001f\n#define light rgb\n#define tran a\n#define MIN_STEP 0.00005f\t// absolute minimum before performance degradation or infinite loop, no artifacts or banding\n#define MAX_STEPS 128.0f\n#define CAMERA_SPEED 1.111f\n\n#define sq(a) (a*a)\n#define fma(a,b,c) ((a) * (b) + (c))\n\nconst float k_sqrtMaxSteps = sqrt(MAX_STEPS);\nconst float k_VolumeDimensions = (128.0f);\nconst float k_InvVolumeDimensions = 1.0f / k_VolumeDimensions;\n\nvec3 v3_rotate_azimuth(in vec3 p, in float angle)\n{\n    vec2 inOrient = vec2(cos(angle), sin(angle));\n    \n\treturn vec3(fma(p.x, inOrient.x, -p.y * inOrient.y),\n\t\t\t\tfma(p.x, inOrient.y, p.y * inOrient.x),\n\t\t\t\tp.z);\n}\n\n// using the excellent 3d volume template by  Ric3cir121\n// https://www.shadertoy.com/view/wtdcD2\n\n#define _ac ---------- Common ------------------------|\\\n/| Note: This is the 3D buffer engine!                |\\\n/|----------------------------------------------------|\\\n\n\n\n#define makevolume() void mainImage(out vec4 o,vec2 u){\\\n    ivec2 me = ivec2(u);\\\n    int ar = int(pow(iResolution.x*iResolution.y,1./3.));\\\n    int slide = me.x+me.y*int(iResolution.x)-1;\\\n    vec3 c = vec3(slide%ar,slide/ar%ar,slide/ar/ar);\\\n    o = vec4(0);\\\n    if(c.z<=volumeResolution.z)mainImage(o,c);\\\n    if(slide==-1)o=vec4(1.2,3.4,4.3,2.1);\\\n}\\\nfloat _r_voldserr\n\n#define volumeResolution vec3(int(pow(iResolution.x*iResolution.y,1./3.)))\n\n#define _r_res() int(pow(iResolution.x*iResolution.y,1./3.))\n#define _r_rd(c) ivec3(mod(vec3((c)*volumeResolution),vec3(_r_res())))\n#define _r_slide(c) (_r_rd(c).x+_r_rd(c).y*_r_res()+_r_rd(c).z*_r_res()*_r_res()+1)\n#define volume(ch,c) texelFetch(ch,ivec2(_r_slide(c)%int(iResolution.x),_r_slide(c)/int(iResolution.x)),0)","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// using the excellent 3d volume template by  Ric3cir121\n// https://www.shadertoy.com/view/wtdcD2\n\n#define _ab ------------------------- Buffer A --------------------------------------------|\\\n/| vec3 volumeResolution             /* volume resolution                               */ |\\\n/| void makevolume                   /* put at the end to declare the buffer as a volume*/ |\\\n/| void mainImage(out vec4 o,vec3 u) /* this is the mainImage                           */ |\\\n/| vec4 volume(sampler2D ch,vec3 c)  /* ch: iChannel, c: coordinates (from 0 to 1)      */ |\\\n/|                                                                                         |\\\n/| Note: while putting a texture remember to click on gear near the texture and change     |\\\n/|       the filter to linear                                                              |\\\n/|-----------------------------------------------------------------------------------------|\\\n\n\nfloat sdSphere(in vec3 p, in float r)\n{\n    return( length(p) - r );\n}\n\nfloat opacity(in vec3 uvw) \n{\n    float o;\n    \n    o = sdSphere(uvw, 0.05f);\n    \n    float ho = 0.5f * o;\n    \n    o = smoothstep(1.0f, ho*ho, o);\n    \n    return(o);\n}\n\nvec3 computeNormal(in vec3 uvw)\n{\n\tvec2 half_texel_offset = vec2(1.0f, 0.0f) * volumeResolution.z;   \n\n\tvec3 gradient;\t\n\n\tgradient.x = opacity(uvw - half_texel_offset.xyy) - opacity(uvw + half_texel_offset.xyy);\n\tgradient.y = opacity(uvw - half_texel_offset.yxy) - opacity(uvw + half_texel_offset.yxy);\n\tgradient.z = opacity(uvw - half_texel_offset.yyx) - opacity(uvw + half_texel_offset.yyx);\n\n\treturn( normalize(gradient) ); // normal from central differences (gradient) \n}\n\nvoid mainImage(out vec4 O,vec3 u){\n\n    vec3 uvw = 2.0f * u / volumeResolution - 1.0f;\n    \n    float o = opacity(uvw);\n    vec3 n = computeNormal(uvw);\n    \n    O = vec4(n * 0.5f + 0.5f, o);\n}\n\nmakevolume();","name":"Buffer A","description":"","type":"buffer"}]}