{"ver":"0.1","info":{"id":"clsXRH","date":"1674294147","viewed":471,"name":"midnight jam","username":"hayabuzo","description":"I made this shader after reading the Book of Shaders, so it's like a graduation project covering all main topics of the book. The visual part is inspired by GTA2 videogame and Gaspar Noe's movie Enter the Void.","likes":51,"published":1,"flags":64,"usePreview":0,"tags":["night","lights","cars","roads"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xt2SWc","filepath":"https://soundcloud.com/lancemontgomery/enter-the-void?si=89f31e59f9be4bc99507e576305f3f39&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/lancemontgomery/enter-the-void?si=89f31e59f9be4bc99507e576305f3f39&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846  \n#define TWO_PI 6.28318530718\n#define NUM_OCTAVES 10\n#define FRC iTime*0.7\n#define MLS iTime*0.7\n\n\n/* Image to Grayscale */\nfloat img2avg ( vec4 img ) { \n  return dot(img.rgb, vec3(0.33333)); }\nfloat img2avg ( vec3 img ) { \n  return dot(img.rgb, vec3(0.33333)); }\n\t\nvec2  zr(vec2 uv, vec2 move, float zoom, float ang) {\n\t\t  uv -= 0.5;\n\t\t  uv *= mat2( \n  \t  \t\t\tcos(ang) , -sin(ang) ,\n  \t  \t\t\tsin(ang) ,  cos(ang) );\n\t\t  uv *= zoom;\n\t\t  uv -= move*zoom;\n\t\t  uv -= move*(5.0-zoom);\n\t\t  return(uv); }\n\nfloat random (float x) {\n  \t\treturn fract(sin(0.005387+x)*129878.4375453); }\n\nfloat random (vec2 uv) {\n  \t\treturn fract(sin(0.387+dot( uv.xy, vec2(12.9,78.2))) * 4.54 ); }\n\nfloat noise(float x) {\n\t\t\tfloat i = floor(x);\n\t\t\tfloat f = fract(x);\n\t\t\tfloat y = mix(random(i), random(i + 1.0), smoothstep(0.,1.,f));\n\t\t\treturn y; }\n\nvec2  random2(vec2 st){\n\t\t  st = vec2( dot(st,vec2(127.1,311.7)), dot(st,vec2(269.5,183.3)));\n  \t  return -1.0 + 2.0*fract(sin(st)*43758.5453123); }\nfloat noise(vec2 st) {\n  \t\tvec2  i = floor(st);   // Gradient Noise by Inigo Quilez - iq/2013\n  \t\tvec2  f = fract(st);   // https://www.shadertoy.com/view/XdXGW8\n  \t\tvec2  u;\n\t\t\tu = f*f*f*(f*(f*6.-15.)+10.);\n  \t\treturn mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n  \t\t                 dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n  \t\t            mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n  \t\t                 dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y); }\n\nvec3  hsb2rgb (vec3 c) {\n  \t\tvec4   K = vec4(1.0,2.0/3.0,1.0/3.0,3.0);     \t\t\t\t// Color conversion function from Sam Hocevar: \n  \t\tvec3   p = abs(fract(c.xxx+K.xyz)*6.0-K.www); \t\t\t\t// lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n  \t\treturn c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y); }\n\t\t\t\t\t\t\t\t\t \nfloat rect(vec2 uv, float x, float y, float w, float h) { \n\t\t\treturn step(x-w*0.5,uv.x) * step(uv.x,x+w*0.5)\n\t\t\t\t \t * step(y-h*0.5,uv.y) * step(uv.y,y+h*0.5);   }\n\t\t\t\t \nfloat circle(vec2 uv, float x, float y, float d) {\n\t\t\treturn step(distance(uv,vec2(x,y)),d*0.5); }\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t \nfloat sphere2(vec2 uv, float x, float y, float d) {\n    \tvec2 dist = uv-vec2(x,y);\n\t\t\treturn clamp( (1.- dot(dist,dist)/(d/8.0)) ,0.0, 1.0); }\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat fbm_noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * fbm_noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\t\t\t\nvec2 random3( vec2 p ) {\n  return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  \t\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);    }\n\t\nmat2 rotate2d(float a)   {\n     return mat2( \n     cos(a) , -sin(a) ,\n     sin(a) ,  cos(a) ); }\n\t\nmat2 scale(vec2 s) {\n     return mat2(\n     s.x, 0.0 ,\n     0.0 , s.y );  }\n\nvec2 uv2wtr( vec2 uv, float kx, float ky) {\n  kx = kx*2.0+0.01;\n  vec2 t1 = vec2(kx,ky);\n  vec2 t2 = uv;\n  for(int i=1; i<10; i++) {\n    t2.x+=0.3/float(i)*sin(float(i)*3.0*t2.y+MLS*kx)+t1.x;\n    t2.y+=0.3/float(i)*cos(float(i)*3.0*t2.x+MLS*kx)+t1.y; }\n\tvec3 tc1;\n  tc1.r=cos (t2.x+t2.y+1.0)*0.5+0.5;\n  tc1.g=sin (t2.x+t2.y+1.0)*0.5+0.5;\n  tc1.b=(sin(t2.x+t2.y)+cos(t2.x+t2.y))*0.5+0.5;\n  uv = uv +(tc1.rb*vec2(2.0)-vec2(1.0))*ky;\n\treturn uv; }\n\t\nfloat nexto(float ch, float n) {\n  float a;\n  a = sin(n*ch);  a = floor(a*10000.0)*0.001;\n  a = cos(a);     a = floor(a*8000.0)*0.001;\n  return fract(a); }\t\n\t\nvec2 uv2wav( vec2 uv1, float kx, float ky, float sd) {\n    float tx = kx;\n    float ty = ky;\n\t\tvec2 t1;\n\t\tfloat time = FRC*0.0;\n    //                       frq                                     spd                    amp\n    t1.y = cos( uv1.x * nexto(1.0,tx)*10.0 + time * ceil(nexto(2.0,tx)*10.0-5.0) ) * nexto(3.0,tx)*1.15;\n    t1.x = sin( uv1.y * nexto(1.0,ty)*10.0 + time * ceil(nexto(2.0,ty)*10.0-5.0) ) * nexto(3.0,ty)*1.15;\n    uv1 = uv1 + vec2(t1.x,t1.y)*sd;\n    t1.y = cos( uv1.x * nexto(4.0,tx)*10.0 + time * ceil(nexto(5.0,tx)*10.0-5.0) ) * nexto(6.0,tx)*0.55;\n    t1.x = sin( uv1.y * nexto(4.0,ty)*10.0 + time * ceil(nexto(5.0,ty)*10.0-5.0) ) * nexto(6.0,ty)*0.55;\n    uv1 = uv1 + vec2(t1.x,t1.y)*sd;\n    t1.y = cos( uv1.x * nexto(7.0,tx)*10.0 + time * ceil(nexto(8.0,tx)*10.0-5.0) ) * nexto(9.0,tx)*0.15;\n    t1.x = sin( uv1.y * nexto(7.0,ty)*10.0 + time * ceil(nexto(8.0,ty)*10.0-5.0) ) * nexto(9.0,ty)*0.15;\n    uv1 = uv1 + vec2(t1.x,t1.y)*sd;\n\treturn uv1; }\n\t\n/* RGB to HSB Conversion */\nvec3 rgb2hsb( vec3 c ) {\n  // Color conversion function from Sam Hocevar: \n  // lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n  vec4   K = vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);\n  vec4   p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4   q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n  float  d = q.x - min(q.w, q.y);\n  float  e = 1.0e-10;\n  return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)), d/(q.x+e), q.x); }\n\n/* Hue Tune & Replace  */\nvec3 rgb2ht( vec3 img, float t) {\n\timg.rgb = rgb2hsb(img.rgb);\n\timg.r = img.r+t;\n\treturn hsb2rgb(img.rgb); }\nvec3 rgb2hr( vec3 img, float t) {\n\timg.rgb = rgb2hsb(img.rgb);\n\timg.r = t;\n\treturn hsb2rgb(img.rgb); }\n\t\t\n/* Saturation Tune & Replace */\nvec3 rgb2st( vec3 img, float t) {\n\timg.rgb = rgb2hsb(img.rgb);\n\timg.g = img.g+t;\n\treturn hsb2rgb(img.rgb); }\nvec3 rgb2sr( vec3 img, float t) {\n\timg.rgb = rgb2hsb(img.rgb);\n\timg.g = t;\n\treturn hsb2rgb(img.rgb); }\n\t\t\n/* Lightness Tune & Replace  */\nvec3 rgb2lt( vec3 img, float t) {\n\timg.rgb = rgb2hsb(img.rgb);\n\timg.b = img.b+t;\n\treturn hsb2rgb(img.rgb); }\nvec3 rgb2lr( vec3 img, float t) {\n\timg.rgb = rgb2hsb(img.rgb);\n\timg.b = t;\n\treturn hsb2rgb(img.rgb); }\n\nvec2 zoom(vec2 uv, vec2 m, float zmin, float zmax) {\n\tfloat zoom = map(sin(FRC),-1.,1.,zmin,zmax);\n\tuv -= 0.5;\n\tuv *= zoom;\n\tuv -= m*zoom;\n\tuv -= m*(zmax-zoom);\n\treturn(uv);\n}\n\nvec2 roto(vec2 uv, vec2 m, float ang) {\n  uv -= 0.5;\t\n  uv *= mat2( \n  cos(ang) , -sin(ang) ,\n  sin(ang) ,  cos(ang) );\n  uv += 0.5;\n\treturn(uv);\n}\n\t\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n\t\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\t\n\t\n/////////////// Float \n\n/* Float to Zero Centered */\nfloat f2z ( float f ) {\n\treturn f*2.0-1.0; }\n\t\n/* Zero Centered to Float */\nfloat z2f ( float z ) {\n\treturn z*0.5+0.5; }\n\t\n/* Float Constrain */\nfloat f2f ( float f ) {\n\treturn clamp(f,0.0,1.0); }\n\t\n/* Zero Centered Constrain */\nfloat z2z ( float z ) {\n\treturn clamp(z,-1.0,1.0); }\n\n/* Float to Random */\t\nfloat f2rand (float x) {\n  return fract(sin(0.005387+x)*129878.4375453); }\n\t\n/* Float to Noise */\t\nfloat f2noise(float x) {\n\treturn mix(f2rand(floor(x)), f2rand(floor(x) + 1.0), smoothstep(0.,1.,fract(x))); }\n\t\n/* Float to Slit */\nfloat f2slit ( float f, float lvl, float len, float smt ) { \n\treturn smoothstep(lvl-len*0.5-smt,lvl-len*0.5    ,f) - \n\t       smoothstep(lvl+len*0.5    ,lvl+len*0.5+smt,f); }\n\n/* Float to Map */\nfloat f2m(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);        }\n\t\nfloat sphere(vec2 uv, float x, float y, float d, vec2 l) {\n\treturn \n\t\t(1.0-distance(uv,vec2(x,y)+l*d)*(1.0/d))  \n\t\t* \n\t\tsmoothstep(d*0.51,d*0.49,distance(uv,vec2(x,y)))\n\t; }\n\t\nfloat cube(vec2 uv, float x, float y, float s) { \n\n\treturn step(x-s*0.5,uv.x) * step(uv.x,x+s*0.5)\n\t\t\t\t * step(y-s*0.5,uv.y) * step(uv.y,y+s*0.5);     }\n\t\t\nfloat sphere3(vec2 uv, float x, float y, float d, vec2 l) {\n\treturn \n\t\tclamp((1.0-distance(uv,vec2(x,y)+l*d)),0.0,1.0)\n\t; }\n\n/* Cartesian to Polar */\nvec2 xy2md(vec2 xy) {\n\treturn vec2( \n\t\tsqrt( pow(xy.x,2.0) + pow(xy.y,2.0) ) ,\n\t\tatan(xy.y,xy.x) ); }\n\n/* Polar to Cartesian */\nvec2 md2xy(vec2 md) {\n\treturn vec2( \n\t\tmd.x * cos(md.y) ,\n\t\tmd.x * sin(md.y) ); }\n\t\n/* Barrel Distortion */\nvec2 uv2brl( vec2 uv, float pwr ) {\n\t//uv.y = uv.y * (HEIGHT/WIDTH);  \n\tuv = md2xy(xy2md(uv - 0.5) + vec2(pwr-0.5,0.0)) + 0.5;\n\t//uv.y = uv.y * (WIDTH/HEIGHT);  \n\treturn uv; }\n\n// ----------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n// Normalized pixel coordinates (from 0 to 1)\nvec2  uv = fragCoord/iResolution.xy;\nvec2  RES = iResolution.xy;\nvec2  M = iMouse.xy/iResolution.xy;\n      M.y = 1.0-M.y;\n\n\n\nconst int n = 10;\t\t// number of layers\nfloat thr = 0.85;\t\t// threshold of roads in layer\nfloat amt = 0.50;\t\t// amount of cars in layer\n\n\t  // setup main coordinate system according to the screen dimensions\nvec2  uv0 = fragCoord.xy/RES.xy; uv0.y = 1.0-uv0.y;\n\t  uv0.x *= RES.x/RES.y;\nvec2  uvc = uv0;\n\t\t\tuv0.x -= ((RES.x-RES.y)/RES.y)*0.5;\n\n\t  // set main coordinate system movement parameters\nfloat angle = sin(MLS*0.2); // MLS\nfloat zoom  = 20.0+10.0*sin(FRC*0.5);\nvec2  move  = vec2(FRC*0.2,FRC*0.7);\t\t\n\n\n      // move main coordinate system\n      uv0 = zr(uv0+vec2(abs(sin(M.x*PI*0.5)),abs(sin(M.y*PI*0.5))), move, zoom, angle);\n\nvec3  layer;  // RGB of every layer\nvec3  stack;  // RGB of composed image\n\nfor (int i=n; i>0; i--) {\t// for every layer\n\n    vec2  uv = uv0; // copy main coordinate system to create local fixed UV\n                // take  ↓ it  ↓ do not move  ↓ zoom according to layer number              ↓ rotate \n                uv = zr( uv,   vec2(0.0),     1.0 + (float(n-i))*0.3 + sin(FRC*0.01)*0.005,  PI*2.0*random(float(i)*0.258) );\n\n                // bend the road\n    float kx = 0.5*sin(0.2*PI*random(float(i)*1087.4432)+0.00001*length(uv));     // bending coefficient\n                uv.y += \t\t\t\t\t\t\t\t\t\tsin(uv.x*kx);\t\t\t\t\t\t // bend Y axis with Sin\n                uv.x += (fract(uv.y)-0.5) * sin(uv.x*kx-PI*0.5)*kx;\t // bend X axis with modified Sin\n                //                    ↑ we need to bend road X according to the road center\n\n    float dir = step(mod(uv.y,2.0),1.0);\t// neighboring roads will have opposite directions (0 and 1)\n\n                // calculate speed on every road according to direction\n                //\t\t\t\t\t\t\t\t\t↓ boost  boost ↓      ↓ break                   ↓ according to layer \n    float\tspeed = (dir-0.5) * 10.0 * ( FRC + 2.0 * (noise(FRC*0.2+floor(uv.y)+float(i)*10.0)) * 2.0 - 1.0 );\n                //       ↑ direction         ↑ counter  counter ↑       ↑ according to road           ↑ normalize to (-1;1)\n\n    vec2  uvi = floor(uv);\t\t// integer part of fixed UV\n    vec2  uvf = fract(uv);\t\t// fract part of fixed UV\n\n    vec2  uvm = uv;       \t\t// local moveable UV\n                uvm.x += speed;\t\t\t// move every road along X axis\n    vec2  mi  = floor(uvm);   // integer part of moveable UV\n    vec2  mf  = fract(uvm); \t// fract part of moveable UV\n\n    float car_vis = step(amt, random(mi.x+float(i)*200.0));\t\t\t\t\t\t\t\t\t\t \t// is current block has a car\n    float CPR = car_vis * (1.0-step(amt, random(mi.x-1.0+float(i)*200.0)));\t\t \t// is current block has a car and is previous block empty\n    float CNX = car_vis * (1.0-step(amt, random(mi.x+1.0+float(i)*200.0)));\t\t \t// is current block has a car and is next block empty\n    float CPR2 = (1.0-car_vis) * (step(amt, random(mi.x-1.0+float(i)*200.0))); \t// is current block empty and is previous block has a car\n    float CNX2 = (1.0-car_vis) * (step(amt, random(mi.x+1.0+float(i)*200.0))); \t// is current block empty and is next block has a car\n\n    vec3  c_lamp = vec3(1.0);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// RGB of road lightning\n    vec3  c_red  = vec3(1.0,0.0,0.0);\t\t\t\t\t\t\t\t\t\t\t\t\t// RGB of red lights\n    vec3  c_yel  = vec3(1.0,1.0,random(mi.x+float(i)*300.0));\t// RGB of yellow lights\n\n                // paint the car:\t\t\t\t                ↓ hue                             ↓ saturation            ↓ brightness\n    vec3  car_color = hsb2rgb(vec3( (random(mi.y) + random(mi.x*10.1+5.5)*0.3),  0.4+0.6*random(mi.x+10.0), 1.0 ) );\n\n    float\troad_vis = step(thr,(random(uvi.y+float(i)*100.0)))-0.01;     // is current road visible\n    float kl = 0.25;\t// brightness of car lights\n    float ka = 0.50;  // brightness of road lights\n\n                // lightning of roads and cars\n    vec3\tlamp = mix(vec3(0.0), c_lamp,    pow((abs(snoise( uv/6.5))) ,5.0) +0.07 )        // fixed road lights: white\n                         + mix(vec3(0.0), c_red*ka , pow((abs(snoise((uvm+137.0)/5.5))),5.0)) \t\t\t // moving road lights: red\n                         + mix(vec3(0.0), c_yel*ka , pow((abs(snoise((uvm+872.0)/5.5))),5.0)) \t\t\t // moving road lights: yellow\n\n                           // drawing 4 circles for car lights, coloring it according to the road direction\n                         + mix(vec3(0.0), mix(c_yel,c_red,dir)*(0.6+0.4*random(mi.x+float(i)*13.4)), \n                                                                                                    CNX * sphere2(mf,0.8,0.7,0.1) \t\t \n                                                                                                + CNX * sphere2(mf,0.8,0.3,0.1))\t\t \n                         + mix(vec3(0.0), mix(c_red,c_yel,dir)*(0.6+0.4*random(mi.x+float(i)*73.7)), \n                                                                                                    CPR * sphere2(mf,0.2,0.7,0.1)\n                                                                                                + CPR * sphere2(mf,0.2,0.3,0.1)) ;\t\t\n\n                             // drawing 4 circles for extra car lights, coloring it according to the road direction: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n                         + mix(vec3(0.0), mix(c_red*kl,car_color*kl,dir)*(0.6+0.4*random(mi.x+float(i)*73.7)), \t\t\n                                                                                                +\tCNX2 * sphere2(mf-vec2(0.5,0.0), 0.5, 0.5, 3.0 ) )\n                         + mix(vec3(0.0), mix(car_color*kl,c_red*kl,dir)*(0.6+0.4*random(mi.x+float(i)*13.4)), \n                                                                                                +\tCPR2 * sphere2(mf+vec2(0.5,0.0), 0.5, 0.5, 3.0 ) )\n                         + mix(vec3(0.0), mix(car_color*kl,c_red*kl,dir)*(0.6+0.4*random(mi.x+float(i)*73.7)), \n                                                                                                +\tCNX  * sphere2(mf-vec2(0.5,0.0), 0.5, 0.5, 3.0 ) )\n                         + mix(vec3(0.0), mix(c_red*kl,car_color*kl,dir)*(0.6+0.4*random(mi.x+float(i)*13.4)), \n                                                                                                +\tCPR  * sphere2(mf+vec2(0.5,0.0), 0.5, 0.5, 3.0 ) ) ;\n\n                lamp = clamp(lamp,vec3(0.0),vec3(1.0)); // clamp lights to avoid overexposure\n\n                // paint layer with:\n                //            ↓ road visibility     ↓ road brighntess      ↓ road lightning\n                layer = vec3( road_vis            * float(i)/float(n)    * lamp \n                                            //        ↓ road tiles                                ↓ road lines      \n                                            * ( 0.3 * rect( uvf,  0.5,  0.5,  1.0,  0.9 ) + 1.0 * rect( uvf, 0.5,  0.5,  0.4,  0.1  ) ) ) \n                                            // ↓ minimal constant lightning\t\t\t\t    \n                                            + lamp * 0.25;\t\n\n                // add road cracks\n                layer *= (0.75+0.6*pow( abs( snoise(uv*8.0+131.0)  )  ,  3.0  ));\n\n    float fig;\t// draw a car\n                fig += random(mi.x+0.01) * circle(  mf,  random(mi.x+0.11),   0.5  ,0.3+0.4*random(mi+0.21)  );\n                fig += random(mi.x+0.02) *   rect(  mf,  random(mi.x+0.12),   0.5  ,0.1+0.9*random(mi+0.22)  ,  0.1+0.9*random(mi+0.32));\n                fig += random(mi.x+0.05) * circle(  mf,  random(mi.x+0.15),   0.5  ,0.3+0.3*random(mi+0.25)  );\n                fig += random(mi.x+0.06) *   rect(  mf,  random(mi.x+0.16),   0.5  ,0.1+0.9*random(mi+0.26)  ,  0.1+0.9*random(mi+0.36));\n                fig += random(mi.x+0.07) *   rect(  mf,  random(mi.x+0.17),   0.5  ,0.1+0.9*random(mi+0.27)  ,  0.1+0.9*random(mi+0.37));\n                // add extra shadows to a car\t\n                fig *= (0.75+pow( abs( snoise(uvm+725.0)  )  ,  2.5  ));\n\n                // apply lighting to a car and add a car to the layer\n                layer = mix(layer, car_color * fig * lamp, car_vis * step(0.05,fig));\n\n                // add layer to the stack\n                stack = mix(stack,layer,road_vis+0.01);\n\n                // if current layer is not empty break the cycle to avoid extra calculations\n                if (length(stack)>0.0) break;\n\n}\n\t\t\t\nvec3  color = hsb2rgb(vec3( noise(uv0*0.0020)*PI,  0.3, 1.0 ) );\nfloat cloud = pow( fbm( vec2(fbm(uv0*0.1),fbm(uv0*0.1+vec2(10.0)+vec2(FRC*0.4,0.0)))   ),7.0)*10.0 * map(zoom,10.0,30.0,0.3,1.0);\n\t  cloud = clamp(cloud,0.0,0.8);\n\t  stack = mix(stack, color , cloud );\n\nvec4  img = vec4(stack,1.0);\n\n    // Output to screen\n    fragColor = img;\n}","name":"Image","description":"","type":"image"}]}