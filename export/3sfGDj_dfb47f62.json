{"ver":"0.1","info":{"id":"3sfGDj","date":"1547474412","viewed":373,"name":"Golden ratio visualized","username":"toocanzs","description":"attempting to implement the program shown in this video in shader\nhttps://www.youtube.com/watch?v=sj8Sg8qnjOg\n\nComment out line 2 to see the golden ratio\nChange phi at line 12 to any ratio to see how irrational it looks","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["golden","ratio","irrationality"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DYNAMIC\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define CS(a)  vec2(cos(a),sin(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = ( 2.*u - R )/ R.y;\n    O = vec4(0);\n\nfloat PI = 3.14159,\n#ifdef DYNAMIC\n        phi = iTime*0.001 + 0.1,\n#else\n        phi = (1. + sqrt(5.))/2.,\n#endif\n          a = phi * 2.*PI,\n         i0 = ( length(U) - .01 ) /.0015,\n         i1 = ( mod( PI-atan(U.y,U.x) ,2.*PI) )/ a, // + k.2PI/a\n          k = floor( (i0-i1) / (2.*PI/a) ), \n          i, d = 1e9;\n    \n    for (float n = 0.; n < 2.; n++) {\n        i = round(i1 + k++ * 2.*PI/a );\n        vec2 p = -( .01+ 0.0015*i) *CS(-i*a);\n    \td = min( d, length(U - p) - .001);\n       //O[int(n)%3] += max(0.,1.-length(uv - p)/.1);    \n    }\n  \n    O += vec4(smoothstep(3./iResolution.y, 0., d - .01));\n}  \n\n/*\nIn making this shader I was told by FabriceNeyret2 about how this loop can \nbe removed and still produce the same image. \nGreat learning experience. \nAbove is his suggested code, and for reference my old code is below.\n\nfloat phi = (1. + sqrt(5.))/2.;\n#define DYNAMIC\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy )/ iResolution.y;\n    \n\tfloat d = 99999.;\n    vec2 p = vec2(0.01,0);\n    #ifdef DYNAMIC\n    phi = iTime*0.001 + 0.1;\n    #endif\n    //phi = (1./3.);\n    float a = phi * 2.*3.14159265358979323846;\n    mat2 rot = mat2(cos(a),sin(a),-sin(a),cos(a));\n    for(int i = 0; i < 1400; i++)\n    {\n        p *= rot;\n    \td = min(d,length(uv + p)-0.001);\n        p = normalize(p) * (length(p)+0.0015);\n    }\n    fragColor = vec4(smoothstep(3./iResolution.y, 0., d - 0.01));\n}\n\n*/","name":"Image","description":"","type":"image"}]}