{"ver":"0.1","info":{"id":"Wts3WH","date":"1556414265","viewed":92,"name":"Fork godrays","username":"Godlander","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DECAY\t\t.974\n#define EXPOSURE\t.24\n\n#define SAMPLES\t\t32\n#define DENSITY\t\t.95\n#define WEIGHT\t\t.30\n\n\n//planar zoom.\n#define ViewZoom 3.\n//sub-pixel blur\n#define fsaa 14./min(iResolution.x,iResolution.y)\n//View Frame\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n//maxiterations for bayer matrix, maximum value is number of bits of your data type?\n//for crepuscular ray dithering [1..3] iterations are enough\n//because it is basically \"noisy scattering\" so  any patterns in it are \"just fine\"\n#define iterBayerMat 1\n#define bayer2x2(a) (4-(a).x-((a).y<<1))%4\n//return bayer matris (bitwise operands for speed over compatibility)\nfloat GetBayerFromCoordLevel(vec2 pixelpos)\n{ivec2 p=ivec2(pixelpos);int a=0\n;for(int i=0; i<iterBayerMat; i++\n){a+=bayer2x2(p>>(iterBayerMat-1-i)&1)<<(2*i);\n}return float(a)/float(2<<(iterBayerMat*2-1));}\n//https://www.shadertoy.com/view/XtV3RG\n\n//analytic bayer over 2 domains, is unrolled loop of GetBayerFromCoordLevel().\n//but in terms of reusing subroutines, which is faster,while it does not extend as nicely.\nfloat bayer2  (vec2 a){a=floor(a);return fract(dot(a,vec2(.5, a.y*.75)));}\nfloat bayer4  (vec2 a){return bayer2 (  .5*a)*.25    +bayer2(a);}\nfloat bayer8  (vec2 a){return bayer4 (  .5*a)*.25    +bayer2(a);}\nfloat bayer16 (vec2 a){return bayer4 ( .25*a)*.0625  +bayer4(a);}\nfloat bayer32 (vec2 a){return bayer8 ( .25*a)*.0625  +bayer4(a);}\nfloat bayer64 (vec2 a){return bayer8 (.125*a)*.015625+bayer8(a);}\nfloat bayer128(vec2 a){return bayer16(.125*a)*.015625+bayer8(a);}\n#define dither2(p)   (bayer2(  p)-.375      )\n#define dither4(p)   (bayer4(  p)-.46875    )\n#define dither8(p)   (bayer8(  p)-.4921875  )\n#define dither16(p)  (bayer16( p)-.498046875)\n#define dither32(p)  (bayer32( p)-.499511719)\n#define dither64(p)  (bayer64( p)-.49987793 )\n#define dither128(p) (bayer128(p)-.499969482)\n//https://www.shadertoy.com/view/4ssfWM\n\n//3 ways to approach a bayer matrix for dithering (or for loops within permutations)\nfloat iib(vec2 u){\n return dither128(u);//analytic bayer, base2\n}\n\n\n//x is result, yz are position in normalized coords.\n //This is just a quick hack for this shader only.\nvec3 sun( vec2 uv ) {\t\n//o put op inside this function, making p not a parameter of it, because\n    vec2 p=fra(iMouse.xy)*.666;\n    //vec2 p=vec2(-0.6,-.3); switch to this one for a stationary sun\n    vec3 res;\n    float di = distance(uv, p);\n    res.x =  di <= .33333? sqrt(1. - di*3.) : 0.;\n    res.yz = p;\n    res.y /= (iResolution.x / iResolution.y);\n    res.yz = (res.yz+1.)*.5;\n    return res;}\n\n#define SS 1./min(iResolution.x,iResolution.y)\n\nfloat circle( vec2 p, float r){\n return smoothstep(SS,-SS,length(p)-r);\n return step(length(p)-r,.0);\n    return length(p) < r ? 1. : 0.;//why would you do that?\n}\n\n\n//[buffA of https://www.shadertoy.com/view/4dyXWy ], merged into [Image]\nvec4 BA(in vec2 uv, vec2 coord ){  \n    //This buffer calculates occluders and a gaussian glowing blob.\n    //Just see what it returns for any uv input.\n    //It makes sense to buffer this as a matrix (low res 2d frame buffer)\n    // ,because it is being looked up multiple times\n    // With different offsets.\n    //  This is NOT doing that, for no good reason at all \n    //   other than brute force benchmaking a bufferless approach\n    uv=uv*2.-1.;\n    float aspect = iResolution.x / iResolution.y;\n   uv.x *= aspect;\n    //above framing is not pretty. but thats not what is demoed here.\n    \n    vec4 occlusionTex = texture(iChannel0, coord);\n    float occluders = 0.;\n    occluders += occlusionTex.r;\n    vec3 light=min(sun(uv),1.);\n    float col = max(light.x - occluders, 0.);\n    return vec4(col,occluders,light.yz); //Gross hack to pass light pos as B and A values\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 coord = uv;\n    vec4 buffer=BA(uv, coord);\n    vec2 lightpos = buffer.zw;       \n    float occ = buffer.x; //light\n    float obj = buffer.y; //objects\n    float dither = iib(fragCoord);\n    vec2 dtc = (coord - lightpos)*(1./float(SAMPLES)*DENSITY);\n    float illumdecay = 1.;\n    \n    for(int i=0; i<SAMPLES; i++)    {\n        coord -= dtc;\n            float s = BA(coord+(dtc*dither), coord).x;\n        s *= illumdecay * WEIGHT;\n        occ += s;\n        illumdecay *= DECAY;\n    }\n        \n    fragColor = vec4(vec3(.5,.7,.1)*obj/3.+occ*EXPOSURE,1.0);\n}","name":"Image","description":"","type":"image"}]}