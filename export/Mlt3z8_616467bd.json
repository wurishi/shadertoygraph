{"ver":"0.1","info":{"id":"Mlt3z8","date":"1468005469","viewed":1176,"name":"Procedural Bayer Matrix","username":"Patapom","description":"Generates a Bayer matrix procedurally by applying a simple recursive pattern.\nShould be much more efficient with integer arithmetics though...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","matrix","bayer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple recursive Bayer matrix generation\n// We start from the root permutation matrix:\n//\tI2 = |1 2|\n//       |3 0|\n//\n// Next, we can recursively obtain successive matrices by applying:\n//  I2n = | 4*In+1 4*In+2 |\n//        | 4*In+3 4*In+0 |\n//\n// Behaves much better and looks much simpler when using integer arithmetics...\n//\n#define USE_PROCEDURAL\t// Comment this to use the texture version instead\n\n// Generates the basic 2x2 Bayer permutation matrix:\n//  [1 2]\n//  [3 0]\n// Expects _P in [0,1]\nfloat B2( vec2 _P ) {\n//    return ((_P.y << 1) + _P.x + 1) & 3;\t<= This would fare much better than modulos and floors :(\n    return mod( 2.0*_P.y + _P.x + 1.0, 4.0 );\n}\n\n// Generates the 4x4 matrix\n// Expects _P any pixel coordinate\nfloat B4( vec2 _P ) {\n    vec2\tP1 = mod( _P, 2.0 );\t\t\t\t\t// (P >> 0) & 1\n    vec2\tP2 = floor( 0.5 * mod( _P, 4.0 ) );\t\t// (P >> 1) & 1\n    return 4.0*B2(P1) + B2(P2);\n}\n// Generates the 8x8 matrix\nfloat B8( vec2 _P ) {\n    vec2\tP1 = mod( _P, 2.0 );\t\t\t\t\t// (P >> 0) & 1\n    vec2\tP2 = floor( 0.5 * mod( _P, 4.0 ) );\t\t// (P >> 1) & 1\n    vec2\tP4 = floor( 0.25 * mod( _P, 8.0 ) );\t// (P >> 2) & 1\n    return 4.0*(4.0*B2(P1) + B2(P2)) + B2(P4);\n}\n// Generates the 16x16 matrix\nfloat B16( vec2 _P ) {\n    vec2\tP1 = mod( _P, 2.0 );\t\t\t\t\t// (P >> 0) & 1\n    vec2\tP2 = floor( 0.5 * mod( _P, 4.0 ) );\t\t// (P >> 1) & 1\n    vec2\tP4 = floor( 0.25 * mod( _P, 8.0 ) );\t// (P >> 2) & 1\n    vec2\tP8 = floor( 0.125 * mod( _P, 16.0 ) );\t// (P >> 3) & 1\n    return 4.0*(4.0*(4.0*B2(P1) + B2(P2)) + B2(P4)) + B2(P8);\n}\n// I think you can guess the pattern now... :D\n\n\nfloat rnd(vec2 co){\n//\treturn fract(sin(iTime*.1+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\treturn fract(sin(dot(19.319849*co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tfragCoord.y = iResolution.y-fragCoord.y; // Because I like DirectX better\n    \n\tfragCoord = floor( fragCoord / 48.0 );\t // Because large pixels\n//\tfragCoord = floor( fragCoord / 4.0 );\t // Because large pixels\n\n  #ifdef USE_PROCEDURAL\n    // Use procedural matrix\n//\tfloat\tf = B4( fragCoord ) / 15.0;\n\tfloat\tf = B8( fragCoord ) / 63.0;\n//\tfloat\tf = B16( fragCoord ) / 255.0;\n  #else\n    // Or use the texture (with a little tweaking of UVs to match the procedural version)\n\tvec2 \tUV = fragCoord.yx / 8.0;\n     \t \tUV.x = 0.875 - UV.x;\n\tfloat\tf = texture( iChannel0, UV ).x;\n  #endif\n    \n    // Use V to check which value is where to make sure the matrix is correctly generated...\n\tfloat\tV = mod( 2.0*iTime, 63.0 );\n\tfragColor = abs( 63.0*f - V ) < 0.5 ? vec4( 1.0, 0.0, 0.0, 1.0 ) : vec4( f, f, f, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}