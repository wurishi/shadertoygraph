{"ver":"0.1","info":{"id":"XflXDB","date":"1705683693","viewed":179,"name":"Rotating wireframe sphere","username":"chronos","description":"Rotating wireframe sphere\nStudy for use in another shader: [url=https://www.shadertoy.com/view/MflXDj]TRIOPTIMUM[/url]","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["wireframe","sphere","rotating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\n// @iq's suggestion for 'pixel snapping' effect:\n#define PIXEL_SNAPPING 0\n\n#define PIXELATION 0\n            \nconst float pixels_per_uv = 100.;\n\nfloat linesegdist(vec2 p, vec2 a, vec2 b)\n{\n    return distance(p, clamp(dot(p-a, b-a)/dot(b-a,b-a), 0., 1.) * (b-a) + a);\n}\n\nvec3 rot(vec3 p, vec3 ax, float angle)\n{\n    ax = normalize(ax);\n    vec3 proj = dot(ax, p) * ax;\n    vec3 rejection = p-proj;\n    float c = cos(angle), s = sin(angle);\n    vec3 normal = cross(ax, p);\n    \n    return proj + normal * s + rejection * c;\n}\n\nvec2 perspective(vec3 p) \n{ \n    #if 1\n    float focal = 2.;\n    return focal * p.xy / (focal + p.z);\n    #else\n    return p.xy;\n    #endif\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n\n    #if PIXELATION\n    uv = round(uv*pixels_per_uv)/pixels_per_uv;\n    #endif\n\n    vec3 color = vec3(0);\n\n    float mindist = 9e9;\n    \n    vec3 rot_axis = vec3(-1.,0.,1.);\n    float rot_angle = radians(45.);\n    \n    vec3 translation = vec3(0,0, sin(iTime/2.)-1.);\n    \n    int subdivs = 12;\n    \n    for(int i = 0; i < subdivs; i++)\n    {\n        float angle = 2. * PI * float(i)/float(subdivs);\n        float c = cos(angle), s = sin(angle);\n        vec3 a  = vec3(c,s, 0.);\n\n        angle = 2. *  PI * float(i+1)/float(subdivs);\n        c = cos(angle); s = sin(angle);\n        vec3 b  = vec3(c,s, 0.);\n            \n        for(int j = 0; j < subdivs/2; j++)\n        {\n            float angle2 = 2. *  PI * float(j)/float(subdivs) - iTime;\n            float c2 = cos(angle2), s2 = sin(angle2);\n            mat2 R = mat2(c2, s2, -s2, c2);\n            \n            vec3 a2 = a; a2.xz = R * a.xz;\n            vec3 b2 = b; b2.xz = R * b.xz;\n            \n            vec2 p0 = perspective(rot(a2, rot_axis, rot_angle) - translation);\n            vec2 p1 = perspective(rot(b2, rot_axis, rot_angle) - translation);\n            \n            #if PIXEL_SNAPPING\n            p0 = round(p0*pixels_per_uv)/pixels_per_uv;\n            p1 = round(p1*pixels_per_uv)/pixels_per_uv;\n            #endif\n            \n            float d = linesegdist(uv, p0, p1);\n            mindist = min(mindist, d);\n            \n            angle2 = 2.* PI * float(j+1)/float(subdivs) - iTime;\n            c2 = cos(angle2); s2 = sin(angle2);\n            R = mat2(c2, s2, -s2, c2);\n            \n            vec3 a3 = a; a3.xz = R * a.xz;\n            vec3 b3 = b; b3.xz = R * b.xz;\n            \n            vec2 p2 = perspective(rot(a3, rot_axis, rot_angle)-translation);\n            \n            #if PIXEL_SNAPPING\n            p2 = round(p2*pixels_per_uv)/pixels_per_uv;\n            #endif\n            \n            d = linesegdist(uv, p0, p2);\n            mindist = min(mindist, d);\n        }\n    }\n\n    const float percent = 0.01;\n    float pix_size = 2. / iResolution.y;\n    \n    #if PIXELATION\n    // This kind of anti-aliasing is perhaps a bit anachronistic if we're going retro, but...\n    pix_size = 1. / pixels_per_uv;\n    #endif\n    \n    float linethickness = 1. * percent;\n    float alpha = smoothstep(pix_size + linethickness/2., linethickness/2., mindist);\n    \n    vec3 linecolor = vec3(1./255.,1.,0.075);\n    \n    color = mix(color, linecolor, .25 * alpha);\n\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}