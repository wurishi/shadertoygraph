{"ver":"0.1","info":{"id":"3djyRR","date":"1586207360","viewed":247,"name":"Eriksonns Wormhole","username":"Eriksonn","description":"raytraced wormhole using general relativity","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","generalrelativity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float Tau = 6.28318530718;\nconst float Pi = 3.14159265359;\n\nconst float Radius = 1.5;\nconst float Length = 3.0;\nconst float Lensing=1.5;\nconst float Contraction=0.03;\n\nfloat a=Length*Radius;\nfloat p=Radius;\nfloat W=Lensing*Radius;\nfloat Q=Contraction/Length;\nfloat CloudDistance = Radius*6.0;\n\n\nfloat R(float l)\n{\n    if(abs(l)<a)\n        return p;\n    \n    float x = 2.0*(abs(l)-a)/(Pi*W);\n\treturn p+W*(x*atan(x)-0.5*log(1.0+x*x));\n}\nfloat DerivativeR(float l)\n{\n    float q = Q;\n    if(abs(l)>a*2.0)\n    {\n    \tq=0.0;\n    }\n    if(l>0.0)\n    {\n    \treturn max(2.0*atan(2.0*(l-a)/(Pi*W))/Pi,q*l);\n    }else\n    {\n    \treturn min(2.0*atan(2.0*(l+a)/(Pi*W))/Pi,q*l);\n    }\n}\n\nfloat cross2(vec2 a,vec2 b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\nfloat lerp(float a,float b,float t)\n{\n\treturn a*(1.0-t)+t*b;\n}\nvec3 lerpC(vec3 A,vec3 B,float t)\n{\n\treturn vec3(lerp(A.x,B.x,t),lerp(A.y,B.y,t),lerp(A.z,B.z,t));\n}\nvec3 Cloud(vec3 Pos)\n{\n    vec3 C = texture(iChannel2,Pos/15.0).rgb;\n    float h = 0.3;\n\treturn 1.0-clamp(C,0.0,h)/h;\n}\nfloat Sq(float x)\n{\n\treturn x*x;\n}\nvec3 Ray(vec2 Pixel, float CameraDistance,mat3 CameraPosition,mat3 CameraRotation)\n{\n    vec3 Vel = CameraRotation*vec3(Pixel.x,Pixel.y,1);\n    Vel/=length(Vel);\n    \n    vec3 I = (vec3(0,0,1));\n    vec3 J = Vel;\n    vec3 K = cross(I,J);\n    //PlaneAngle = ;\n    I=normalize(I);\n    K=normalize(K);\n    J=normalize(cross(I,K));\n    mat3 WormholeMatrix = mat3(I,J,K);\n    //due to the fact that a rotation matrix is orthonormal, \n    //transposing and inverting is the same thing\n    mat3 InverseMatrix = transpose(WormholeMatrix);\n    \n    float Rad=CameraDistance;\n    float r = R(Rad);\n    \n    float Angle=0.0;\n    float RadVel=-Vel.z;\n    float AngleVel=(InverseMatrix*Vel).y/r;\n    float angularMomentum = AngleVel*r*r;\n    float adaptivedt=2.0;\n    //rotation matrix for getting in/out of the plane of the lightbeam\n   \t \n    \n    \n    /*vec2 Pos2=(InverseMatrix*(Pos)).xy;\n    vec2 Vel2=normalize((InverseMatrix*Vel).xy);\n    Angle=atan(Pos2.y,Pos2.x);\n    Rad = length(Pos2);*/\n    \n    \n    vec3 CloudDensity =vec3(0,0,0);\n\t\n    vec3 BackColor=vec3(1,0,1);\n\tfor(int Step =0;Step<400;Step++)\n\t{\n\t\t\n\t\tfloat r = R(Rad);\n\t\tfloat r1 = DerivativeR(Rad);\n        adaptivedt = lerp(0.2,0.6,clamp(r1*0.3,0.0,1.0))*1.0;\n\t\tif(abs(Rad)<CloudDistance)\n\t\t{\n\t\t\tfloat Wrapper=(1.0-Sq(Rad/CloudDistance))/(CloudDistance);\n\t\t\tvec2 Pos2=vec2(cos(Angle),sin(Angle))*r;\n\t\t\tvec3 Pos=CameraPosition*(WormholeMatrix)*(vec3(Pos2,0));\n            Pos/=length(Pos);\n\t\t\tCloudDensity+=Cloud(sign(Rad)*(Pos)*(1.0+abs(Rad/CloudDistance)*4.0)-16.0)*Wrapper*10.0*adaptivedt;\n\t\t}\n\t\t\n\t\t\n\t\tfloat b = angularMomentum;\n\t\tRadVel+=(b*b*r1/(r*r*r))*adaptivedt;\n\t\tRad+=RadVel*adaptivedt;\n\t\tAngle+=b*adaptivedt/(r*r);\n\t\t\n\t\t\n\t\tif(Rad>100.0*p)\n\t\t\tbreak;\n        \n        \n        /*float H = -2.0*a*cos(iTime*0.0);\n\t\tif((Rad-H)*(Rad-H-RadVel*adaptivedt)<0.0)\n        {\n            float R2 = Rad;\n            //r = R(R2);\n            float Q = -(R2-H)/RadVel;\n            //RadVel+=(b*b*r1/(r*r*r))*Q;\n\t\t\t//R2+=RadVel*Q;\n\t\t\t//Angle+=b*Q/(r*r);\n            float A = -b*Q/(r*r);\n            R2 = H;\n            vec2 Pos2=vec2(cos(Angle-A),sin(Angle-A))*R(R2);\n\t\t\tvec3 Pos=CameraPosition*(WormholeMatrix)*(vec3(Pos2,0));\n            float s = 0.05;\n        \tif(abs(Pos.x)<s||abs(Pos.y)<s||abs(Pos.z)<s)//||mod(6.0*Pos.y/R(R2)+0.05,1.0)<0.1)\n            {\n                if(RadVel<0.0)\n                {\n            \t\tBackColor=vec3(0.5,0,0);\n                }\n                else\n                {\n                \tBackColor=vec3(0,0,0.5);\n                }\n                //break;\n        \t}\n        }*/\n\t}\n\tCloudDensity=(1.0-exp(-CloudDensity));\n\t\n\tvec2 Pos2=vec2(cos(Angle),sin(Angle))*(Rad);\n\tvec3 Pos=CameraPosition*(WormholeMatrix)*(vec3(Pos2,0));\n    //if(length(BackColor)==0.0)\n    {\n        if(Rad>0.0)\n        {\n            BackColor=vec3(texture(iChannel0,vec2(atan(Pos.z,Pos.x)/Tau,Pos.y/Rad)));\n        }else\n        {\n            BackColor=vec3(texture(iChannel1,vec2(atan(Pos.z,Pos.x)/Tau,-Pos.y/Rad)));\n        }\n    }\n\tif(abs(Rad)<a*3.0)\n\t\tBackColor=vec3(0.9,0,1)*0.7;\n\tvec3 CloudColor = CloudDensity.x*vec3(1,0,1)+CloudDensity.y*vec3(0,0,1);\n\t//return BackColor;\n\treturn BackColor*(1.0-CloudDensity)+CloudColor;\n}\nmat3 RotateX(float Angle)\n{\n\tfloat Cos=cos(Angle);\n    float Sin=sin(Angle);\n    return mat3(\n        1,0,0,\n        0,Cos,Sin,\n        0,-Sin,Cos\n    );\n}\nmat3 RotateY(float Angle)\n{\n\tfloat Cos=cos(Angle);\n    float Sin=sin(Angle);\n    return mat3(\n        Cos,0,Sin,\n        0,1,0,\n        -Sin,0,Cos\n    );\n}\nmat3 RotateZ(float Angle)\n{\n\tfloat Cos=cos(Angle);\n    float Sin=sin(Angle);\n    return mat3(\n        Cos,Sin,0,\n        -Sin,Cos,0,\n        0,0,1\n    );\n}\nvoid RotateCamera(float Angle1,float Angle2,out vec3 V)\n{\n\tvec3 Out=vec3(0,0,0);\n    \n    float Cos1=cos(Angle1);\n    float Sin1=sin(Angle1);\n    float Cos2=cos(Angle2);\n    float Sin2=sin(Angle2);\n    //camera rotations\n    V.yz = mat2(Cos2, Sin2, -Sin2, Cos2)*V.yz;\n    V.xz = mat2(Cos1, Sin1, -Sin1, Cos1)*V.xz;\n    \n}\nmat3 GetRotationMatrix(float Angle1,float Angle2)\n{\n    float Cos1=cos(Angle1);\n    float Sin1=sin(Angle1);\n    float Cos2=cos(Angle2);\n    float Sin2=sin(Angle2);\n    \n\tmat3 Out = mat3(\n        1,0,0,\n        0,Cos2,Sin2,\n        0,-Sin2,Cos2\n    );\n    Out*=mat3(\n    \tCos1,0,Sin1,\n        0,1,0,\n        -Sin1,0,Cos1\n    );\n    return Out;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    //fov scale\n    uv*=1.0;\n    //vec3 RayHeading=vec3(uv.x,uv.y,1);\n    \n    \n    float Angle1=iTime/3.0;\n    //float Angle1=0.0;\n    float Angle2=lerp(-0.1,0.60,(cos(iTime/2.414)+1.0)/2.0);\n    //float Angle2=0.0;\n    float Angle3=Pi/2.0;\n    float Distance = -20.0*cos(Angle1);\n    float Angle4 = Pi*0.25*sin(Angle1)+0.25*Pi;\n    //Distance=lerp(12.0,2.0,sin(Angle1*1.5)*0.5+0.5);\n    //RotateCamera(Angle1,Angle2,RayHeading);\n    mat3 CameraPos = RotateY(-Angle1*1.5);\n    //float Angle3 = -(cos(-1.0*Angle1)/2.0)*Pi/2.0+Pi/4.0;\n    \n    mat3 CameraRotation = RotateY(Angle4);\n    //vec3 CameraPos=vec3(0,0,-20.0);\n    //RotateCamera(Angle1,Angle2,CameraPos);\n    //vec3 RayPos=CameraPos+vec3(0,0,0);\n    \n    //RayHeading/=length(RayHeading);\n    \n\tvec3 col = Ray(uv,Distance,CameraPos,CameraRotation);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}