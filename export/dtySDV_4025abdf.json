{"ver":"0.1","info":{"id":"dtySDV","date":"1686354271","viewed":37,"name":"Lights Experiments","username":"henrmota","description":"Experiment some concepts to light an object","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lightfresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SURF_DIST 0.01\n#define MAX_DIST 100.\n#define SKY_COLOR vec3(0.3, 0.1, 1.)\n#define GROUND_COLOR vec3(1., 0.1, 0.2)\n#define LIGHT_COLOR vec3(1., 1., 1.)\n\nmat2 rot(float angle) {\n    float c = cos(angle), s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}\nfloat iLerp(float minV, float maxV, float value) {\n    return (value - minV) / (maxV - minV);\n}\n\nfloat remap(float value, float oMin, float oMax, float tMin, float tMax) {\n    return mix(tMin, tMax, iLerp(oMin, oMax, value));\n}\n\nfloat map(vec3 p) {\n    vec3 ev = p - vec3(0., 0., 0.);\n    float radius = mix(.6, .5, smoothstep(-0.5, 0.8, ev.y));\n    radius -= 0.005 * pow(max(0., sin(atan(ev.x, ev.z) * 20.)), 2.);\n    \n    float d = length(ev) - radius;\n   \n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.);\n    \n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i =0; i < 100; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p);\n        if (abs(d) < SURF_DIST) break;\n        t +=d;\n        if (t > MAX_DIST) break;\n    }\n    \n    return t;\n}\n\nvec4 getLight(vec3 p, vec3 rd) {\n  vec3 light = vec3(0.);\n  vec3 lightDir = normalize(vec3(remap(sin(iTime) * 0.5 + 0.5, 0., 1., -2., 2. ), 3., -3.) - p);\n  \n  vec3 n = getNormal(p);\n  \n  light += LIGHT_COLOR * 0.1;\n  //hemilight\n  float hemiMix = remap(n.y, -1., 1., 0., 1.);\n  vec3 hemiLight = mix(GROUND_COLOR, SKY_COLOR, hemiMix);\n  light += hemiLight * .1;\n  \n  //diffuse\n  float diffusePower = max(0., dot(n, lightDir));\n  vec3 diffuse = LIGHT_COLOR * diffusePower;\n  light += diffuse * .4;\n  \n  //specular\n  vec3 r = normalize(reflect(-lightDir, n));\n  float specularPower = pow(max(0., dot(r, -rd)), 32.);\n  vec3 specular = LIGHT_COLOR * specularPower;\n  float fresnel = pow(1. - max(0., dot(n, -rd)), 6.);\n  fresnel *= max(0., dot(normalize(vec2(p.x + p.z, p.y)), vec2(cos(iTime * 2.), sin(iTime * 2.))));\n  float fresnelPower = 1.;\n  //specular += fresnel;\n  light += specular * 0.4;\n  \n  return vec4(light, (fresnel * fresnelPower));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.);\n\n    vec3 ro = vec3(0., 0., -2.);\n    vec3 rd = normalize(vec3(uv, 1.25));\n    \n    float t = rayMarch(ro, rd);\n    \n    col += rd * rd * 0.2;\n    if (t < MAX_DIST) {\n        col = vec3(1.);\n        vec3 p = ro + rd * t;\n        vec3 n = pow(getNormal(p), vec3(4.));\n        vec4 l = getLight(p, rd);\n        float red = 2.;\n        float green = 1.;\n        float blue = .3;\n        col *= mix((l.rgb * 0.7 ) * vec3(red, green, blue), vec3(.5, .5, 2.), l.a);\n    }\n    \n    //gamma correction\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}