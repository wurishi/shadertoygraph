{"ver":"0.1","info":{"id":"lt2BWm","date":"1516124379","viewed":161,"name":"2d kifs fractal","username":"unnick","description":"i extended my cantor morpher to support more than just abs folding.\ncantor morpher: https://www.shadertoy.com/view/XlBfDm","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tau 6.283\n\n//folds\nconst vec3[] folds = vec3[](\n    vec3(vec2(0, 1), 0.5),\n    vec3(vec2(sin(tau    /6.0), cos(tau    /6.0)), 0.0),\n    vec3(vec2(-sin(tau*2.0/6.0), -cos(tau*2.0/6.0)), 0.0),\n    vec3(vec2(1, 0), 0.0)\n);\nconst bool absfold = false;\n\n//palette\nconst vec3[] palette = vec3[](\n    vec3(1.0, 1.0, 1.0),\n    vec3(0.0, 0.5, 1.0),\n    vec3(0.0, 0.5, 1.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 0.0)\n);\nconst float palettescale = 10.0;\n\n//rotation matrix generator\nmat2 createrotmat(float a){\n    float s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\n//color function\nvec3 getcolor(float dist){\n    dist = pow(dist, 0.05);\n    dist *= palettescale;\n    int idx1 = int(mod(dist      , float(palette.length())));\n    int idx2 = int(mod(dist + 1.0, float(palette.length())));\n    return mix(palette[idx1], palette[idx2], mod(dist, 1.0));\n}\n\n//distance estimator function\nfloat de(vec2 pos){\n    int iters = 10;\n    float mul = iMouse.z>0.5?iMouse.x/iResolution.x*3.0+1.0:2.0;\n    mat2 rot = createrotmat(iMouse.z>0.5?iMouse.y/iResolution.y*tau/(absfold?4.0:1.0):iTime);\n    for(int i = 0; i < iters; i++){\n        //pre-fold rotate\n        pos *= rot;\n        //folds\n        if(absfold) pos = abs(pos);\n        for(int j = 0; j < folds.length(); j++){\n            vec2 fold = normalize(folds[j].xy);\n            vec2 offset = fold * folds[j].z;\n            pos -= offset;\n            if(dot(pos, fold)<0.0) pos = reflect(pos, fold);\n            pos += offset;\n        }\n        //scale\n        pos = pos*mul-1.0;\n    }\n    return length(pos) / pow(mul, float(iters));\n}\n\n//main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    pos *= 1.5;\n\tfragColor = vec4(getcolor(de(pos)), 1.0);\n}","name":"Image","description":"","type":"image"}]}