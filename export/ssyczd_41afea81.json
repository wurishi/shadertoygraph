{"ver":"0.1","info":{"id":"ssyczd","date":"1655385035","viewed":164,"name":"GPT3 generated","username":"Jan300100","description":"Made by GPT3 with some help from me, steering it in the right direction with a series of prompts.\nI had to run the initial prompt a few times until I got something that actually made sense. from there on I asked it to edit the code it already generated.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","gpt3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 c)\n{\n    return length(p - c) - r;\n}\n\nfloat sdScene(vec3 p)\n{\n    float d = sdSphere(p, 0.5, vec3(sin(iTime * 0.5) * 2.0, cos(iTime * 0.5) * 2.0, 0.0));\n    d = smin(d, sdSphere(p, 0.75, vec3(sin(iTime * 0.75) * 2.0, 0.0, cos(iTime * 0.75) * 2.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.5, vec3(1.0, sin(iTime * 1.0) * 2.0, cos(iTime * 1.0) * 2.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.25, vec3(sin(iTime * 1.25) * 3.0, 1.0, cos(iTime * 1.25) * 3.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.25, vec3(0.0, sin(iTime * 1.5), cos(iTime * 1.5))), 0.0);\n    d = smin(d, sdSphere(p, 0.25, vec3(sin(iTime * 1.75) * 3.0, 0.0, cos(iTime * 1.75) * 3.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.25, vec3(0.0, sin(iTime * 2.0), cos(iTime * 2.0))), 0.4);\n    d = smin(d, sdSphere(p, 0.25, vec3(sin(iTime * 2.25) * 3.0, -1.0, cos(iTime * 2.25) * 3.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.5, vec3(1.0, sin(iTime * 2.5) * 2.0, cos(iTime * 2.5) * 2.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.75, vec3(sin(iTime * 2.75) * 2.0, 0.0, cos(iTime * 2.75) * 2.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.5, vec3(sin(iTime * 3.0) * 2.0, cos(iTime * 3.0) * 2.0, 0.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.25, vec3(sin(iTime * 3.25) * 3.0, cos(iTime * 3.25) * 3.0, 0.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.25, vec3(sin(iTime * 3.5) * 3.0, cos(iTime * 3.5) * 3.0, 0.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.25, vec3(sin(iTime * 3.75) * 3.0, cos(iTime * 3.75) * 3.0, 0.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.25, vec3(sin(iTime * 4.0) * 3.0, cos(iTime * 4.0) * 3.0, 0.0)), 0.4);\n    d = smin(d, sdSphere(p, 0.25, vec3(sin(iTime * 4.25) * 3.0, cos(iTime * 4.25) * 3.0, 0.0)), 0.4);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv is the coordinate of the pixel in the range [-0.5, 0.5]\n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    // make the image square\n    uv.x *= iResolution.x / iResolution.y;\n    // ray is the direction of the ray\n    vec3 ray = vec3(uv, 1.0);\n    // ro is the origin of the ray\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    // rd is the normalized direction of the ray\n    vec3 rd = normalize(ray);\n    // t is the distance from the origin of the ray to the intersection point\n    float t = 0.0;\n    // iterate 100 times\n    for(int i = 0; i < 100; i++)\n    {\n        // p is the position of the intersection point\n        vec3 p = ro + t * rd;\n        // d is the distance from the intersection point to the scene\n        float d = sdScene(p);\n        // if the distance is less than 0.001, we have found the intersection point\n        if(d < 0.001)\n        {\n            // n is the normal of the sphere at the intersection point\n            vec3 n = normalize(p);\n            // l is the dot product of the normal and the light direction\n            float l = max(0.0f,dot(n, vec3(-sin(iTime), -cos(iTime), -0.0))) * 0.75;\n            // set the color of the pixel to the color of the sphere\n            fragColor = vec4(l + 0.1, l + 0.1, l + 0.1, 1.0);\n            return;\n        }\n        // increase the distance\n        t += d;\n    }\n    // if we did not find an intersection point, set the color of the pixel to black\n    fragColor = vec4(1.0);\n}","name":"Image","description":"","type":"image"}]}