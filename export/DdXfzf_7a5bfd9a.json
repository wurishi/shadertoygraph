{"ver":"0.1","info":{"id":"DdXfzf","date":"1689003660","viewed":87,"name":"Spectral CMY mixing","username":"stduhpf","description":"Mixing reflectivity in spectrum space to simulate pigment mixing.\nUnlike with the simple case of substractive color mixing using transparent filters, mixinig pigments together cannot be accurately depicted by simply multiplying the RGB values together.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pigment","colorscience","spectralrendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// related paper: https://arxiv.org/ftp/arxiv/papers/1710/1710.06364.pdf\n\n// see code in BufferA / Common\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 tex = texture(iChannel0,uv);\n\n    fragColor = pow(tex/tex.a,vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//// Spectrum locus (cie1931 numerical approximation)\n\nfloat gaussian(float x,float al, float mu, float s1, float s2){\n    float y = x-mu;\n    y/=y<0.?s1:s2;\n    return al*exp(-y*y*.5);\n}\n\nvec3 lambdatoXYZ(float wl){\n    return .27*vec3( gaussian(wl, 1.056, 599.8, 37.9, 31.0)+gaussian(wl, 0.362, 442.0, 16.0, 26.7)+ gaussian(wl, -0.065, 501.1, 20.4, 26.2)\n                ,gaussian(wl, 0.821, 568.8, 46.9, 40.5)+gaussian(wl,0.286, 530.9, 16.3, 31.1)\n                ,gaussian(wl, 1.217, 437.0, 11.8, 36.0)+gaussian(wl, 0.681, 459.0, 26.0, 13.8));\n}\nconst mat3 xyz = mat3(\n    3.240479, -1.537150, -0.498535,\n    -0.969256, 1.875992, 0.041556,\n    0.055648, -0.204043, 1.057311);\n\nvec3 spectrum_to_rgb(in float wl){\n    return lambdatoXYZ(wl)*xyz;\n}\n\n//// example pigments taken from real-world data using spectrophotometry on the Munsell Book of colors\n// cyan is 5BG6/10\n// yellow is 2.5Y8.5/12\n// magenta is 7.5P4/12 \n\nconst float[]    cyanSPD = float[36](0.226852, 0.22656, 0.226232, 0.225863, 0.225471, 0.24652, 0.27384, 0.304816, 0.348342, 0.420506, 0.513509, 0.593055, 0.633926, 0.625359, 0.576119, 0.502782, 0.421055, 0.334432, 0.251199, 0.190363, 0.151893, 0.128086, 0.10907, 0.094938, 0.087553, 0.084424, 0.083465, 0.085332, 0.089549, 0.091792, 0.091259, 0.089525, 0.086066, 0.083882, 0.090457, 0.109825);\nconst float[]  yellowSPD = float[36](0.06442, 0.063444, 0.062343, 0.061107, 0.059728, 0.065141, 0.069075, 0.074415, 0.081778, 0.091205, 0.101782, 0.114437, 0.140106, 0.221695, 0.380001, 0.55625, 0.690459, 0.771125, 0.823822, 0.868837, 0.89395, 0.907102, 0.912147, 0.915422, 0.918944, 0.923359, 0.929584, 0.933489, 0.93563, 0.932886, 0.931054, 0.932887, 0.939308, 0.941529, 0.9404, 0.939377);\nconst float[] magentaSPD = float[36](0.303825, 0.304208, 0.30464, 0.305125, 0.305673, 0.314655, 0.304984, 0.286227, 0.261911, 0.231608, 0.196079, 0.156579, 0.125382, 0.102557, 0.079352, 0.062228, 0.057283, 0.059966, 0.060463, 0.0654, 0.090836, 0.143106, 0.20325, 0.234474, 0.229592, 0.232372, 0.277786, 0.368676, 0.487086, 0.596852, 0.681536, 0.745001, 0.794206, 0.827648, 0.851242, 0.864175);\n\nfloat sampleSPDdata(float[36] data, float wl){\n    float i = 35.*(wl-380.)/(730.-380.);\n    int index = int(i);\n    if(index<0) return data[0];\n    if(index>=35) return data[35];\n    float spd = mix(data[index],data[index+1],fract(i));\n    return max(spd,0.);\n}\n\n//// RGB color to reflectance Spectrum (assumes true D65 lighting) \n\n//http://scottburns.us/wp-content/uploads/2018/09/RGB-components-comma-separated.txt\n//0:380->35:730\nconst float[] rho_R = float[36](0.021592459, 0.020293111, 0.021807906, 0.023803297, 0.025208132, 0.025414957, 0.024621282, 0.020973705, 0.015752802, 0.01116804, 0.008578277, 0.006581877, 0.005171723, 0.004545205, 0.00414512, 0.004343112, 0.005238155, 0.007251939, 0.012543656, 0.028067132, 0.091342277, 0.484081092, 0.870378324, 0.939513128, 0.960926994, 0.968623763, 0.971263883, 0.972285819, 0.971898742, 0.972691859, 0.971734812, 0.97234454, 0.97150339, 0.970857997, 0.970553866, 0.969671404);\nconst float[] rho_G = float[36](0.010542406, 0.010878976, 0.011063512, 0.010736566, 0.011681813, 0.012434719, 0.014986907, 0.020100392, 0.030356263, 0.063388962, 0.173423837, 0.568321142, 0.827791998, 0.916560468, 0.952002841, 0.964096452, 0.970590861, 0.972502542, 0.969148203, 0.955344651, 0.892637233, 0.5003641, 0.116236717, 0.047951391, 0.027873526, 0.020057963, 0.017382174, 0.015429109, 0.01543808, 0.014546826, 0.015197773, 0.014285896, 0.015069123, 0.015506263, 0.015545797, 0.016302839);\nconst float[] rho_B = float[36](0.967865135, 0.968827912, 0.967128582, 0.965460137, 0.963110055, 0.962150324, 0.960391811, 0.958925903, 0.953890935, 0.925442998, 0.817997886, 0.42509696, 0.167036273, 0.078894327, 0.043852038, 0.031560435, 0.024170984, 0.020245519, 0.01830814, 0.016588218, 0.01602049, 0.015554808, 0.013384959, 0.012535491, 0.011199484, 0.011318274, 0.011353953, 0.012285073, 0.012663188, 0.012761325, 0.013067426, 0.013369566, 0.013427487, 0.01363574, 0.013893597, 0.014025757);\n\nfloat RGBtoSPD(vec3 col, float wl){ //linear color input, obiously\n    float i = 35.*(wl-380.)/(730.-380.);\n    int index = int(i);\n    if(index<0) return col.b;\n    if(index>=35) return col.r;\n    float m = min(col.r,min(col.g,col.b));\n    float spd = m+dot(col-m,mix(vec3(rho_R[index],rho_G[index],rho_B[index]),vec3(rho_R[index+1],rho_G[index+1],rho_B[index+1]),fract(i)));\n    return max(spd,0.);\n}\n\n//// D65 spectrum\n\n//https://www.mtheiss.com/help/final/html/code/bk_d65_spectrum.htm\n//0:380->80:780\nconst float[] D65 = float[81](50.,  52.,  54.,  68.,  82.,  87.,  91.,  92.,  93.,  90.,  86.,  95., 104., 110., 117., 117., 117., 116., 114., 115., 115., 112., 108., 109., 109., 108., 107., 106., 104., 106., 107., 106., 104., 104., 104., 102., 100.,  98.,  96.,  96.,  95.,  92.,  88.,  89.,  90.,  89.,  89.,  88.,  87.,  85.,  83.,  83.,  83.,  81.,  80.,  80.,  80.,  81.,  82.,  80.,  78.,  74.,  69.,  70.,  71.,  73.,  74.,  68.,  61.,  65.,  69.,  72.,  75.,  69.,  63.,  55.,  46.,  56.,  66.,  65.,  63.) ;\n\nfloat blackbody(float wl, float T){\n    const float h = 6.62607015e-34; // Planck constant\n    const float k = 1.380649e-23; // Boltzmann constant\n    const float c = 2.99792458e8; // Speed of light\n    wl*=1e-9; // convert nm to m\n\n    const float normalization_constant = 3.12245e-13; //such as 6500K lightsource is almost pure sRGB white, with luminance == 1.\n\n    return  2.*h*(c*c)/(wl*wl*wl*wl*wl*(exp(h*c/(T*wl*k))-1.))*normalization_constant;\n}\n\nfloat get_D65(float wl){\n    float i = 80.*(wl-380.)/(780.-380.);\n    int index = int(i);\n    if(index<0) return blackbody(wl,6500.);\n    if(index>=80) return blackbody(wl,6500.);\n    const float normalization_constant = .142358; // such as integration over the wole spectum gives vec3(1)\n\n    return mix(D65[index],D65[index+1],fract(i))*normalization_constant;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// sample visible spectrum uniformly over time\nfloat getWavelength(float frame){\n    const float spectrum_start = 380.;\n    const float spectrum_end = 780.;\n\n    const float spectrum_range = spectrum_end-spectrum_start;\n    const float PHI = .5+.5*sqrt(5.);\n\n    return fract(frame*PHI)*spectrum_range+spectrum_start;\n}\n\n//multiplicative mix \n#define mix_m(a,b,bp) (pow((a),1.-(bp))*pow((b),(bp)))\n\n#define  mix_m3(a,b,c,bp,cp) (pow((a),1.-(bp)-(cp))*pow((b),(bp))*pow((c),(cp)))\n// <=> \n// #define  mix_m3(a,b,c,bp,cp) mix_m( mix_m((a), (b), (bp)/(1.-(cp)) ) , (c), (cp))\n\n\n// additive mix\n // #define  mix_m3(a,b,c,bp,cp) ((a)*(1.-(bp)-(cp))+(b)*(bp)+(c)*(cp))\n\n\n// https://www.shadertoy.com/view/ttcyRS\nvec3 oklab_mix_uv( vec3 colA, vec3 colB,vec3 colC, vec2 uv )\n{\n\n    // x = a * (1-u-v) + b*u + c*v\n    // xu = a * (1-u) + b*u = x + ( a-c * v)\n    // xu = x + (a-c) * v\n    // x = xu + (c-a) * v\n    \n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(                \n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n    \n    // rgb to cone (arg of pow can't be negative)\n    vec3 lmsA = pow( kCONEtoLMS*colA, vec3(1.0/3.0) );\n    vec3 lmsB = pow( kCONEtoLMS*colB, vec3(1.0/3.0) );\n    vec3 lmsC = pow( kCONEtoLMS*colC, vec3(1.0/3.0) );\n\n    vec3 lms = mix_m3(lmsA,lmsB,lmsC,uv.xxx,uv.yyy);\n\n    return kLMStoCONE*(lms*lms*lms);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float ze = .25/65535.; //avoid zero reflectance\n\n    const vec3 color_00 = max(vec3(0,1,1),ze);\n    const vec3 color_10 = max(vec3(1,0,1),ze);\n    const vec3 color_01 = max(vec3(1,1,0),ze);\n\n    // const vec3 color_00 = vec3(ma,ze,ze);\n    // const vec3 color_01 = vec3(ze,ma,ze);\n    // const vec3 color_11 = vec3(ze,ze,ma);\n    // const vec3 color_10 = vec3(ze);\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n\n    vec2 barycentric_uv = (fragCoord/iResolution.y)*mat2(sqrt(3.)*.5,-.5,0,1);\n\n\n    vec4 noise = texture(iChannel1,fragCoord/iChannelResolution[1].xy);\n    vec2 dithering = (noise.rg*255.+noise.ba)/256.;\n\n    float wl = getWavelength(float(iFrame)+dithering.x-dithering.y);\n\n    // mix in spectral power distribution space (one spectral sample per pixel per frame)\n\n    // find plausible reflectance SPD for each pigment color (assuming D65 illuminant)\n    float ref_00 = RGBtoSPD(color_00,wl);   //sampleSPDdata(cyanSPD,wl);\n    float ref_01 = RGBtoSPD(color_01,wl);   //sampleSPDdata(yellowSPD,wl);\n    float ref_10 = RGBtoSPD(color_10,wl);   //sampleSPDdata(magentaSPD,wl);\n\n    float ref = mix_m3(ref_00,ref_01,ref_10,barycentric_uv.x, barycentric_uv.y);\n\n    vec3 color = spectrum_to_rgb(wl)*get_D65(wl)*ref;\n\n    // mix directly in sRGB space (wrong)\n    // vec3 colormix = mix_m3(color_00,color_01,color_10,barycentric_uv.xxx,barycentric_uv.yyy);color = colormix;\n\n    // okLAB mixing (perceptually uniform, and somehow closer to the correct outcome compared to RGB) \n    // color = oklab_mix_uv(color_00,color_01,color_10,barycentric_uv);\n\n    if(barycentric_uv.x+barycentric_uv.y>1. || barycentric_uv!=fract(barycentric_uv))color*=0.;\n\n\n    fragColor += vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}