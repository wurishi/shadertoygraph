{"ver":"0.1","info":{"id":"7tK3WG","date":"1638519173","viewed":160,"name":"Water sim 01","username":"JCash","description":"Testing simple 2D animation ideas for water","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795*2.0\n#define M_TWO_PI (M_PI*2.0)\n\nint CHECKER_SIZE=64;\nfloat WAVE_FREQUENCY=10.0;\nfloat WAVE_AMPLITUDE=0.003;\nvec2 WAVE_DIR=vec2(1,1);\nfloat STRENGTH=0.8;\n\n// Placeholder until using an actual texture\nvec3 uvToColor(vec2 uv)\n{\n    int ux = int(uv.x) / CHECKER_SIZE;\n    int uy = int(uv.y) / CHECKER_SIZE;\n    bool fill = (ux & 1) != (uy & 1);\n    return fill ? vec3(0.4,0.8,0.9)*0.8 : vec3(0.1,0.4,0.5);\n}\n\n\n// You should replace this hash by one that you like and meets\n// your needs. This one is here just as example and should not\n// be used in production.\nvec2 g( vec2 n ) { return sin(n.x*n.y*vec2(12,17)+vec2(1,2)); }\n//vec2 g( vec2 n ) { return sin(n.x*n.y+vec2(0,1.571)); } // if you want the gradients to lay on a circle\n\nfloat noise(vec2 p)\n{\n    const float kF = 2.0;  // make 6 to see worms\n    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(sin(kF*dot(p,g(i+vec2(0,0)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,0)))),f.x),\n               mix(sin(kF*dot(p,g(i+vec2(0,1)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,1)))),f.x),f.y);\n}\n\nfloat fbm(vec2 uv)\n{\n    uv *= 2.0;\n    const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float noise = fbm(uv);\n    float c = cos((noise + iTime/WAVE_FREQUENCY) * M_TWO_PI);\n    vec2 offset = normalize(WAVE_DIR) * c * WAVE_AMPLITUDE;\n    vec3 col = uvToColor((uv+offset) * iResolution.xy);\n\n    float s = clamp((c*0.5 + 0.5) * STRENGTH, 0.0, 1.0);\n    s = s*s*s;\n    //fragColor = vec4(mix(col, col+vec3(1,1,1), s),1.0);\n    fragColor = vec4(col*(0.8) + vec3(1,1,1) * s, 1.0);\n}","name":"Image","description":"","type":"image"}]}