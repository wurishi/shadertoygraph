{"ver":"0.1","info":{"id":"mlscRl","date":"1691064258","viewed":69,"name":"Collatz Iterations On Floats","username":"chronos","description":"Using a simple generalization of the odd number indicator function from integers to floats, and generalizing the Collatz iteration rule.\nDisclaimer: Far from an expert in any of this :)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["visualization","iterations","float","collatz","conjecture","chaotic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Hue in degrees\n// Just quickly hacked this together from wikipedia:\n// https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative\nvec3 hueToRGB(float hue)\n{\n    float S = 1.;\n    float V = 1.;\n    \n    float k = mod(5. + hue / 60., 6.);\n    float R = V - V * S * max(0., min(k, min(4.-k, 1.)));\n    \n    k = mod(3. + hue / 60., 6.);\n    float G = V - V * S * max(0., min(k, min(4.-k, 1.)));\n    \n    k = mod(1. + hue / 60., 6.);\n    float B = V - V * S * max(0., min(k, min(4.-k, 1.)));\n    \n    return vec3(R,G,B);\n}\n\n// Triangle wave aligned such that it returns \n// 1 for odd numbers\n// 0 for even numbers\n// piecewise linear interpolation inbetween\n// Generalizes and 'is_odd(n)' function, aka mod 2 for integers.\n// It only really occured to me that a triangle wave is what I wanted after the fact,\n// which is why this was implemented with the branched method first.\n#define BRANCHLESS 1\nfloat f(float n)\n{\n    float m = mod(n, 2.);\n    #if BRANCHLESS\n        m = min(m, 2.-m);\n    #else\n        if(m > 1.) { m = 2. - m; }\n    #endif\n    \n    return m;\n}\n\n// Should be the same as the usual rule for integers\n// Gives e.g 1.5 n + 0.5 for half integers\nfloat collatz_rule(float n)\n{\n    float odd = f(n);\n    return mix(0.5, 3., odd) * n + odd; // becomes (3. * n + 1.) for odd n, becomes (0.5 * n) for even n\n}\n\n// Most numbers are unlikely to hit exactly 1 anytime soon,\n// so we stop for all numbers less than or equal to 1 instead\n// This is somewhat arbitrary but seems to work well enough...\nbool stopping_rule(float n)\n{\n    return n <= 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 10.;\n\n    vec2 uv = floor(fragCoord)/iResolution.xy;\n\n    // Number n to start the 'Collatz' iteration from\n    float n_0 = scale * uv.x; \n    float n = n_0;\n\n    const int max_iter = 500;\n    \n    int i = 0;\n    for(; i < max_iter && !stopping_rule(n); i++)\n    {        \n        n = collatz_rule(n);\n    }\n    \n    float hue = float(i % 360); // in degrees\n\n    vec3 RGB = hueToRGB(hue);\n\n    vec3 col = vec3(RGB);\n    \n    // Turn into bars / spikes.\n    if(int(fragCoord.y) > i) col *= 0.;\n    \n    // visualize max iterations cutoff:\n    if(int(fragCoord.y) == max_iter) col = vec3(1);\n    \n    // Quick and dirty integer indicators;\n    if(int(fragCoord.y) > max_iter && abs(round(n_0) - n_0) < 1e-6) col += .5;\n    \n    // Test correct number of iterations for small integers:\n    // n\n    // 1 : i == 0\n    // 2 : i == 1\n    // 3 : i == 7\n    // 4 : i == 2\n    // 5 : i == 5\n    // 6 : i == 8\n    // 7 : i == 16\n    // 8 : i == 3\n    // 9 : i == 19\n    // if(i == 19) col = vec3(1);\n    \n    const float GAMMA = 2.2;\n    fragColor = vec4(pow(col, vec3(1./GAMMA)),1.0);\n}","name":"Image","description":"","type":"image"}]}