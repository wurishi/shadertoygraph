{"ver":"0.1","info":{"id":"MdjyRK","date":"1492896022","viewed":263,"name":"2D rotating maxnorm ellipse","username":"assumptionsoup","description":"Visualization of a maxnorm signed distance field for a rotating ellipse.  Mouse input enabled.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","ellipse","maxnorm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nPrior work/references:\n\nNon-rotated 3D ellipse:\nhttps://www.shadertoy.com/view/Mt2XWG\n\nGeneral maxnorm distance paper:\nhttp://gamma.cs.unc.edu/RECONS/maxnorm.pdf\n\nSweet SDF visualization technique from:\nhttps://www.shadertoy.com/view/4ddSR7\n\nUpdates: \n4-27-2017 - Solve ellipse_1 + 2 using common sub-expressions.\n            They are very similar solutions.  Usually just b vs -b\n            But unfortunately, the domain mirroring prevents\n\t\t\tsolving them together for large efficiency gains.\n*/\n\nfloat SIGNED_DIST_MAX = 1000.0;\nfloat PI = 3.14159265359;\nfloat scene_dist(vec2 p);\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nfloat shape_circle(vec2 p, vec2 center) {\n  float d = length(p - center) - 0.5;\n  return d;\n}\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_distance(float d) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nvec2 solve_quadratic(in float a, in float b, in float c) {\n    // ax^2.0 + bx + c = 0, a non-zero\n    float q = b*b - 4.0*a*c;\n    if (q < 0.0) {\n        return vec2(SIGNED_DIST_MAX);\n    }\n    float r0 = -b/(2.0*a);\n    float r1 = sqrt(q)/(2.0*a);\n    return vec2(r0 - r1, r0 + r1);\n}\n\nfloat sum_elem(in vec2 v) { return v.x + v.y; }\n\nfloat min_elem(vec2 v) { return min(v.x, v.y); }\n\nfloat max_elem(vec2 v) { return max(v.x, v.y); }\n\n// Solve ellipse equation for y == x\nfloat ellipse_1(in vec2 p, in vec2 r, in float an) {\n    // mirror input coordinates along y = x\n    if (-p.x > p.y) {\n        float tmp = p.y;\n        p.y = -p.x;\n        p.x = -tmp;\n        an=-an-PI/2.0;\n    }\n\n    // Mathematic code used to create this solution:\n    //\n    // p = {px, py}\n    // r = {rx, ry}\n    // v = {x, y}\n    // rot = RotationMatrix[an]\n    //\n    // (* ellipse equation *)\n    // ellipsem[v_] := Total[(v.rot - p.rot)^2 / r^2] - 1\n    //\n    // (* ellipse gradient and solutions for it *)\n    // derivs = D[ellipsem[{x, y}], {v}]\n    //\n    // (* I don't know mathematica well enough to write this more elegantly *)\n    // derivx = Simplify[Solve[derivs[[1]] == 0, x]][[1]][[1]][[2]]\n    // derivy = Simplify[Solve[derivs[[2]] == 0, y]][[1]][[1]][[2]]\n    // edgex = Simplify[CoefficientList[ellipsem[{x, y}] /. x -> derivx, y]]\n    // edgey = Simplify[CoefficientList[ellipsem[{x, y}] /. y -> derivy, x]]\n    // corners = Simplify[CoefficientList[ellipsem[{x, x}], x]]\n    //\n    // (* Find common sub-expressions.  Then parse the hell out of the answer. *)\n    // optexpr = Experimental`OptimizeExpression[Flatten[{corners, derivy, derivx, edgey, edgex}], OptimizationLevel -> 2]\n\n    float cosa = cos(an);\n    float sina = sin(an);\n    float sin2a = sin(2.0*an);\n    float cos2a = cos(2.0*an);\n\n    vec2 p2 = pow(p, vec2(2.0));\n    vec2 r2 = pow(r, vec2(2.0));\n    vec2 ir2 = vec2(1.0) / r2;\n\n    float c_1 = pow(cosa, 2.0);\n    float c_2 = pow(sina, 2.0);\n    float c_3 = r2.x - r2.y;\n\n    // y = x   - corner\n    float a, b, c;\n    c = -1.0 + dot(p2, ir2) * c_1 - 2.0 * p.x * p.y * ir2.y * cosa * sina + dot(p2, ir2.yx) * c_2 + p.x * p.y * ir2.x * sin2a;\n    b =  -2.0 * ir2.x * ir2.y * ((p.y * r2.x + p.x * r2.y) * c_1 - (p.x + p.y) * c_3 * cosa * sina + ( p.x * r2.x + p.y * r2.y) * c_2);\n    a = sum_elem(ir2) + (ir2.x - ir2.y) * sin2a;\n\n    if (c <= 0.0) {\n        // solving for the absolute value here solves\n        // some discontinuities that would appear due to\n        // mirroring our coordinate system when p.x < p.y\n        return -min_elem(abs(solve_quadratic(a, b, c)));\n    }\n    float corner = min_elem(solve_quadratic(a, b, c));\n\n    float c_4 = dot(r2, vec2(c_1, c_2));\n    float c_5 = dot(r2, vec2(c_2, c_1));\n    float c_6 = sum_elem(r2) + (r2.x - r2.y) * cos2a;\n    float c_7 = sum_elem(r2) + (r2.y - r2.x) * cos2a;\n\n    // df/dy = 0, f(x) = 0  - edge parallel to y\n    c = -(-2.0 * p2.x + c_6) / c_6;\n    b = -2.0 * p.x / c_4;\n    a = 1.0 / c_4;\n    float edge_y = min_elem(solve_quadratic(a, b, c));\n\n    // df/dy = 0\n    float deriv_y =  (p.y * r2.x * c_1 - c_3 * (p.x - edge_y) * cosa * sina + p.y * r2.y * c_2) / c_4;\n\n    // df/dx = 0, f(x) = 0  - edge parallel to x\n    c = -(-2.0 * p2.y + c_7) / c_7;\n    b = -2.0 * p.y / c_5;\n    a = 1.0 / c_5;\n    float edge_x = min_elem(solve_quadratic(a, b, c));\n\n    // df/dx = 0\n    float deriv_x = (p.x * r2.y * c_1 - c_3 * (p.y + -edge_x) * cosa * sina + p.x * r2.x * c_2) / c_5;\n\n    float dist = SIGNED_DIST_MAX;\n    dist = min(SIGNED_DIST_MAX, corner);\n    dist = min(dist, max(deriv_y, edge_y));\n    dist = min(dist, max(deriv_x, edge_x));\n\n    return dist;\n}\n\n// same as ellipse_1, but all equations solved for y == -x\nfloat ellipse_2(in vec2 p, in vec2 r, in float an) {\n\n    // mirror input coordinates along y = -x\n    if (p.x < p.y) {\n        float tmp = p.y;\n        p.y = p.x;\n        p.x = tmp;\n        an=-an+PI/2.0;\n    }\n\n    // Mathematic code used to create this solution:\n    //\n    // p = {px, py}\n    // r = {rx, ry}\n    // v = {x, y}\n    // rot = RotationMatrix[an]\n    //\n    // (* ellipse equation *)\n    // ellipsem[v_] := Total[(v.rot - p.rot)^2 / r^2] - 1\n    //\n    // (* ellipse gradient and solutions for it *)\n    // derivs = D[ellipsem[{x, -y}], {v}]\n    //\n    // (* I don't know mathematica well enough to write this more elegantly *)\n    // derivx = Simplify[Solve[derivs[[1]] == 0, x]][[1]][[1]][[2]]\n    // derivy = Simplify[Solve[derivs[[2]] == 0, y]][[1]][[1]][[2]]\n    // edgex = Simplify[CoefficientList[ellipsem[{x, -y}] /. x -> derivx, y]]\n    // edgey = Simplify[CoefficientList[ellipsem[{x, -y}] /. y -> derivy, x]]\n    // corners = Simplify[CoefficientList[ellipsem[{x, -x}], x]]\n    //\n    // (* Find common sub-expressions.  Then parse the hell out of the answer. *)\n    // optexpr = Experimental`OptimizeExpression[Flatten[{corners, derivy, derivx, edgey, edgex}], OptimizationLevel -> 2]\n\n    float cosa = cos(an);\n    float sina = sin(an);\n    float sin2a = sin(2.0*an);\n    float cos2a = cos(2.0*an);\n\n    vec2 p2 = pow(p, vec2(2.0));\n    vec2 r2 = pow(r, vec2(2.0));\n    vec2 ir2 = vec2(1.0) / r2;\n\n    float c_1 = pow(cosa, 2.0);\n    float c_2 = pow(sina, 2.0);\n    float c_3 = r2.x - r2.y;\n\n    // y = -x   - corner\n    float a, b, c;\n    c = -1.0 + dot(p2, ir2) * c_1 - 2.0 * p.x * p.y * ir2.y * cosa * sina + dot(p2, ir2.yx) * c_2 + p.x * p.y * ir2.x * sin2a;\n    b = 2.0 * ir2.x * ir2.y * ((p.y * r2.x - p.x * r2.y) * c_1 - (p.x - p.y) * c_3 * cosa * sina + (-p.x * r2.x + p.y * r2.y) * c_2);\n    a = sum_elem(ir2) + (ir2.y - ir2.x) * sin2a;\n\n    if (c <= 0.0) {\n        // solving for the absolute value here solves\n        // some discontinuities that would appear due to\n        // mirroring our coordinate system when p.x < p.y\n        return -min_elem(abs(solve_quadratic(a, b, c)));\n    }\n    float corner = min_elem(solve_quadratic(a, b, c));\n\n    float c_4 = dot(r2, vec2(c_1, c_2));\n    float c_5 = dot(r2, vec2(c_2, c_1));\n    float c_6 = sum_elem(r2) + (r2.x - r2.y) * cos2a;\n    float c_7 = sum_elem(r2) + (r2.y - r2.x) * cos2a;\n\n    // df/dy = 0, f(x) = 0  - edge parallel to y\n    c = -(-2.0 * p2.x + c_6) / c_6;\n    b = -2.0 * p.x / c_4;\n    a = 1.0 / c_4;\n    float edge_y = min_elem(solve_quadratic(a, b, c));\n\n    // df/dy = 0\n    float deriv_y = (-p.y * r2.x * c_1 + c_3 * (p.x - edge_y) * cosa * sina - p.y * r2.y * c_2) / c_4;\n\n    // df/dx = 0, f(x) = 0  - edge parallel to x\n    c = -(-2.0 * p2.y + c_7) / c_7;\n    b = 2.0 * p.y / c_5;\n    a = 1.0 / c_5;\n    float edge_x = min_elem(solve_quadratic(a, b, c));\n\n    // df/dx = 0\n    float deriv_x = (p.x * r2.y * c_1 - c_3 * (p.y + edge_x) * cosa * sina + p.x * r2.x * c_2) / c_5;\n\n    float dist = SIGNED_DIST_MAX;\n    dist = min(dist, corner);\n    dist = min(dist, max(deriv_y, edge_y));\n    dist = min(dist, max(deriv_x, edge_x));\n    return dist;\n}\n\nfloat ellipse(in vec2 point, in vec2 radius,in float angle) {\n    float e1 = ellipse_1(point, radius, angle);\n    float e2 = ellipse_2(point, radius, angle);\n    return max(e1, e2);\n}\n\nfloat scene_dist(vec2 test_point, vec2 center_point) {\n    float rotation = mod(2.0*iTime, PI);\n    // offset graph so that the ellipse is centered at (0,0)\n    vec2 point = test_point - center_point;\n    vec2 radius = vec2(0.5, 0.25);\n    return ellipse(point, radius, rotation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = squareFrame(iResolution.xy, fragCoord);\n    vec2 center_point = vec2(0, 0);\n    \n    // Hacky test to make sure the mouse has been clicked.\n    // Otherwise, the ellipse shows up in the corner, making\n    // the shader look janky.\n    if (iMouse.xy != vec2(0, 0))\n    \tcenter_point = squareFrame(iResolution.xy, iMouse.xy);\n    \n    fragColor.rgb = draw_distance(scene_dist(uv, center_point));\n    fragColor.a   = 1.0;\n\n}\n\n","name":"Image","description":"","type":"image"}]}