{"ver":"0.1","info":{"id":"fltcWf","date":"1660678421","viewed":149,"name":"Texture Sampler Precision Limit","username":"Bers","description":"Shader testing the precision of hardware vs software texel value interpolation.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["interpolation","texel","sampler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author : Sebastien Berube\n// Created : Aug 2022\n//\n// This shader was written to compare the precision of hardware vs software texel interpolation.\n//\n// What we see is an extreme zoom on a texture pixel red channel (center), and the linear interpolation with its 8 neighbors.\n// \n// One the left side, we see the result of hardware texel interpolation (lower precision).\n// One the right side, we see the result of software texel interpolation (higher precision).\n//\n// To better show the difference between both techniques, the pixel value is multiplied by 32.\n// The fractional part of the multiplied value is shown, so we have isolines and strong gradients to better illustrate artifacts.\n//\n// We can see the limits of the hardware version, where the fractional precision is limited to (2^8 subdivisions).\n// \n// From Direct3D 11.3 Functional Specification: (probably similar to OpenGL)\n//  | \n//  | \"7.18.16.1 Texture Sampling Precision - Addressing and LOD Precision\n//  | \n//  |  During Texture Sampling(7.18), the amount of range required for selecting texels\n//  |  (after scaling normalized texture coordinates by texture size) is at least 2^16. This range is centered around 0.\n//  |  \n//  |  The amount of subtexel precision required (after scaling texture coordinates by texture size) is at least 8-bits\n//  |  of fractional precision (2^8 subdivisions).\"\n//  |\n//  |  Source: https://microsoft.github.io/DirectX-Specs/d3d/archive/D3D11_3_FunctionalSpec.htm#7.18.16.1%20Texture%20Addressing%20and%20LOD%20Precision\n//  |\n//\n// License : Creative Commons Non-commercial (NC) license\n\nconst ivec2 INPUT_TEXTURE_RES = ivec2(256,256);\nconst vec2 fINPUT_TEXTURE_RES = vec2(INPUT_TEXTURE_RES);\n\n#define INCREASE_CONTRAST 1 //0=Plain texel value, 1=Exaggerated contrast\n#define EXTREMER_ZOOM 0 //0=Extreme Zoom, 1=More Extreme Zoom\n\n//Classic bilinear interpolation\nvec4 bilinearInterpolation(vec2 u, vec4 a, vec4 b, vec4 c, vec4 d)\n{\n  return vec4(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y);\n}\n\n//Wrap around first and last pixel.\nivec2 wrap(ivec2 p, ivec2 res)\n{\n  //Note : When resolution is a power of two, the bitwise operator (&)\n  //       can be used to wrap around the usable range (simpler).\n  //\n  //       e.g.\n  //       return p & 255;\n  \n  //Supported input range is limited to [(-1,-1):res].\n  //Wrapped output range is [(0,0):res-1].\n  return ivec2(p.x<0 ? res.x-1 :\n                       p.x<res.x ? p.x:0,\n               p.y<0 ? res.y-1 :\n                       p.y<res.y ? p.y:0);\n}\n\n//Hardware sampler interpolation\nvec4 hardwareSampler(vec2 uv)\n{\n  return textureLod(iChannel0, uv, 0.);\n}\n  \nvec4 softwareSampler_Repeat(vec2 uv)\n{\n  const float eps = 0.01;\n  \n  uv = fract(uv); //Repeat\n  uv *= fINPUT_TEXTURE_RES;\n  uv -= 0.5;\n  vec2 u = fract(uv);\n  \n  //Note 1 : beware of negative values (e.g. -0.5) being truncated to zero instead of -1.\n  //OPTME : is there a better way to prevent truncation inconsistencies around zero,\n  //        other than adding the conditions below?\n  //        This also works, but I'm worried of imprecisions: ivec2 px = ivec2(floor(uv));\n  ivec2 px = ivec2(uv.x<0.? -1 : int(uv.x),\n                   uv.y<0.? -1 : int(uv.y));\n  \n  vec4 a = texelFetch(iChannel0, wrap(px + ivec2(0, 0), INPUT_TEXTURE_RES), 0);\n  vec4 b = texelFetch(iChannel0, wrap(px + ivec2(1, 0), INPUT_TEXTURE_RES), 0);\n  vec4 c = texelFetch(iChannel0, wrap(px + ivec2(0, 1), INPUT_TEXTURE_RES), 0);\n  vec4 d = texelFetch(iChannel0, wrap(px + ivec2(1, 1), INPUT_TEXTURE_RES), 0);\n  \n  vec4 v = bilinearInterpolation(u.xy, a, b, c, d);\n  \n  return v;\n}\n\nfloat exaggeratedIsolinesAndGradient(float val)\n{\n#if INCREASE_CONTRAST\n  return fract(val*32.);\n#else\n  return val;\n#endif\n}\n\nvec3 drawRedSeparator(float xPos, vec3 backgroundColor)\n{\n  float distanceToLine = abs(xPos); //Distance in screen space pixels\n  float alpha = smoothstep(2.,1.,distanceToLine);\n  return mix(backgroundColor, vec3(1,0,0), alpha);\n}\n\nvec3 drawTexelCenters(vec2 uv, vec3 backgroundColor)\n{\n  float distanceToTexelCenter = length(iResolution.xy*(fract(uv*fINPUT_TEXTURE_RES)-0.5));\n  float alpha = smoothstep(12.,10.,distanceToTexelCenter); //[10,12] pixel radius (2 pix smoothness)\n  return mix(backgroundColor, vec3(0,1,0.5), alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if EXTREMER_ZOOM\n  float XCELLS = 0.2;\n#else\n  float XCELLS = 2.;\n#endif\n  \n  vec2 uv = (fragCoord/iResolution.xy)*XCELLS/fINPUT_TEXTURE_RES;\n\n  //Align input texels with edges\n  uv += 0.5/fINPUT_TEXTURE_RES;\n  \n  //Animated split position\n  float xSplitFrag = fragCoord.x-(0.5+0.4*sin(iTime))*iResolution.x;\n  \n  //Left Side Sample: Hardware interpolation\n  vec4 leftSampleValue = hardwareSampler(uv);\n  \n  //Right Side Sample : Software interpolation\n  vec4 rightSampleValue = softwareSampler_Repeat(uv);\n  \n  //Draw texel interpolation value\n  fragColor.rgb = vec3(exaggeratedIsolinesAndGradient(xSplitFrag<0.?leftSampleValue.x:rightSampleValue.x));\n\n  //Red Split line\n  fragColor.rgb = drawRedSeparator(xSplitFrag, fragColor.rgb);\n  \n  //Green Texel center dots\n  fragColor.rgb = drawTexelCenters(uv, fragColor.rgb);\n}","name":"Image","description":"","type":"image"}]}