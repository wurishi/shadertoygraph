{"ver":"0.1","info":{"id":"XcfSWS","date":"1732098270","viewed":23,"name":"Raymarching 1st Steps","username":"NatShadLab","description":"An introduction to Raymarching by kishimisu","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SoftLight Blend\nvec3 softligth( vec3 x, vec3 y){\n    vec3 result = 2.*x*y + x*x*(1.-2.*y);\n    return result;\n}\n\n// Color Palette\nvec3 palette( float t){\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a +b*cos(6.28318 * (c * t + d));\n}\n\n// Boolean Operations\nfloat opUnion(float d1, float d2){\n    return min(d1, d2);\n}\n\nfloat opSubtraction( float d1, float d2){\n    return max(-d1, d2);\n}\n\nfloat opIntersection( float d1, float d2){\n    return max (d1, d2);\n}\n\n// Smooth Boolean Operations\nfloat opSmoothUnion( float d1, float d2, float k){\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ){\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix( d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix ( d2, d1, h) + k *h *(1.0 - h);\n}\n\n// Smooth Min\nfloat smin( float a, float b, float k){\n    float h = max( k - abs(a - b), 0.0 ) / k;\n    return min( a, b) - h *h *h *k *(1.0 / 6.0);\n}\n\n// Sign Distance Shapes\n\n// SD Sphere\nfloat sdSphere( vec3 p, float s ){\n    return length(p) - s;\n}\n\n// SD Box\nfloat sdBox( vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x, max(q.y, q.z)),0.0);\n}\n\n// SD Octahedron\nfloat sdOctahedron( vec3 p, float s){\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\n\nmat2 rot2D( float angle){\n    float s = sin( angle);\n    float c = cos( angle);\n    return mat2( c, -s, s, c);\n}\n\n// Distance to the scene\nfloat map(vec3 p) {\n    vec3 spherePos = vec3(sin(iTime)*3., cos((iTime-.5)*2.)*1., 0); // Sphere position\n    float sphere = sdSphere(p - spherePos, .75);  // Sphere SDF\n    \n    vec3 q = p; // Input copy\n    \n    p.z += iTime * .4; // Upward Movement\n    \n    // Space repetition\n    p.xy = (fract(p.xy) - .5);\n    p.z += (sin(iTime*3.)+1.) * mod(p.z,.25);\n    p.z = mod(p.z, .25) - .125;\n    \n    p.xy *= rot2D(iTime); // Rotate around the Z axis\n    p.xz *= rot2D(iTime); // Rotate around the Y axis\n    p.yz *= rot2D(iTime); // Rotate around the X axis\n    \n    vec3 boxPos = vec3(0., 0., 0.); // Cube position\n    vec3 boxSca = vec3( 1., 1., 1.); // Cube scale\n    float box = sdOctahedron(p, .15); // Cube SDF\n    \n    float ground = p.y + 1.5; // Ground SDF    \n    float ceiling = -p.y + 1.5; // Ceiling SDF\n    \n    float BG = min(ground, ceiling);\n    \n    // Closest distance to the scene\n    return smin( BG, smin(sphere, box, 1.618), .618);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/ iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialization\n    vec3 ro = vec3(0, 0, -3); // ray origin\n    vec3 rd = normalize(vec3(uv, 1)); // ray direction\n    vec3 col = vec3(0);\n    \n    float t = 0.; // total distance travelled\n    \n    // Vertical camera rotation\n    \n    //ro.yz *= rot2D(-m.y);\n    //rd.yz *= rot2D(-m.y);\n    \n    // Horizontal camera rotation\n    \n    //ro.xz *= rot2D(-m.x);\n    //rd.xz *= rot2D(-m.x);\n    \n    // Default circular motion if mouse not clicked\n    if (iMouse.z < 0.) m = vec2(cos(iTime * .2)*.5, sin(iTime * .2)*.5);\n    \n    int i;// Raymarching\n    \n    int maxiter = 120;\n    for (i =0; i < maxiter; i++){\n        vec3 p = ro + rd * t; // position along the ray\n        \n        p.xy *= rot2D(t*.2 * m.x); // Rotate ray around Z-axis\n        \n        p.y += sin(t * (m.y + 1.) * .5) * .35; // Wiggle Wiggle Wiggle ray\n    \n        float d = map(p); // current distance to the scene\n\n        t += d; // \"march\" the ray\n        \n        //col = vec3(i) / 80.;\n        \n        if( d < .001 || t > 100.) break; // early stop if close enough or too far\n    }\n\n    // Coloring\n    col = palette(t * .04 - float(i) * .005); // color based on distance\n    col = softligth(col,vec3((t / 10.)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}