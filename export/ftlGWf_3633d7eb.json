{"ver":"0.1","info":{"id":"ftlGWf","date":"1627809815","viewed":127,"name":"Move Black Hole","username":"oseday","description":"Click on the screen to move the black hole","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarchphysicsblackhole"],"hasliked":0,"parentid":"tdt3Rs","parentname":"Black Hole Singularity"},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EventHorizon\n\n#define ExpandingGravity\n\n//#define ApproachSingularity\n\n\nconst float Gravity = 0.1; \nconst float Zoom = 1.1;\n\nconst int kRaymarchIterations = 650;\n\nstruct rayresult{\n    vec3 o; //origin\n    vec3 v; //direction\n    float dist; //distance\n};\n\nmat4 cam = mat4(\n    1,0,0,0,\n    0,1,0,0,\n    0,0,1,0,\n    0,0,0,1\n);\n\nmat4 addmv(mat4 mat, vec3 v){\n    mat4 n = mat;\n    n[3]=n[3]+vec4(v,0);\n    return n;\n}\n\nmat4 mat4v(vec3 v){\n    return mat4(\n        1,0,0,v.x,\n        0,1,0,v.y,\n        0,0,1,v.z,\n        0,0,0,1\n    );\n}\n\nvec3 matpos(mat4 mat){\n    return mat[3].xyz;\n}\n\n\nfloat kFarClip = 10.;\nfloat tick;\n\n\n\nvec3 manager(rayresult io){\n    vec3 col = vec3(0,0,0);\n    \n    float colorshift = 1.;\n    \n    float fClosest = kFarClip;\n\tfloat d = 0.0;\n\tfloat dl = kFarClip/float(kRaymarchIterations);\n    float g = dl*Gravity;\n    \n    \n    float epsi = 1.;\n    \n\tfor(int i=0; i<kRaymarchIterations; i++)\n\t{\n        io.o = io.o + io.v * dl;\n        \n\t\td = length(io.o)/1.;\n        \n        \n        float gt = g;\n        #ifdef ExpandingGravity\n        gt *= (sin(tick)+1.);\n        #endif\n        \n        float d2 = gt/(d*d);\n        \n        \n        io.v = normalize(io.v - normalize(io.o)*d2);\n        \n        colorshift *= (1. + 200.*dl*d2*dot(normalize(io.o),io.v) );\n\t}\n    \n    #ifdef EventHorizon\n    if (d<1.0) {\n    \treturn vec3(0,0,0);\n\t}\n    #endif\n    \n    \n    col += texture(iChannel1,io.v).xyz;\n    \n    \n    \n    col = RGBtoHSV(col);\n    \n    col.x *= colorshift;\n    \n    col.x = clamp(col.x,0.,1.)*0.8333;\n    \n\n    col = HSVtoRGB(col);\n    \n    \n    return col;\n}\n\nvoid updatescene(float tick){\n    \n}\n\nconst int MSAA = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tick = iTime/5.;\n    \n    \n    updatescene(tick);\n    \n    vec2 mouseuv = (iMouse.xy-iResolution.xy/2.0)/iResolution.xx*2.;\n    \n    mat4 ncam = cam;\n    \n    ncam = ncam\n        *build_transform(vec3(0,0,-4),vec3(0,0,0))\n        ;\n    \n    #ifdef ApproachSingularity\n    ncam *= build_transform(vec3(0,0,(pow(abs(sin(tick*3.)),0.2)*3.9777)),vec3(0,0,0));\n    #endif\n    \n    ncam[3].xyz = ncam[3].xyz - vec3(mouseuv.x*3.5,mouseuv.y*3.5,0);\n    vec3 campos = matpos(ncam);\n    vec3 totcol = vec3(0,0,0);\n        \n    float distMSAA = float(MSAA+1);\n    \n    for (int xs=1;xs<=MSAA;xs++){\n        for (int ys=1;ys<=MSAA;ys++){\n            \n            vec2 uv = (fragCoord+vec2(xs,ys)/distMSAA-iResolution.xy/2.0)/iResolution.xx*2.;\n\n            vec3 v = normalize(uv.x*ncam[0].xyz+uv.y*ncam[1].xyz+ncam[2].xyz*Zoom);\n\n            vec3 col = vec3(0,0,0);\n\n            rayresult ray;\n            \n            ray.o=campos;\n            ray.v=v;\n            ray.dist=2.10;\n\n            col += manager(ray);\n\n            col = clamp(col,vec3(0,0,0),vec3(1,1,1));\n            totcol += col;\n        }\n    }\n    \n    totcol /= float(MSAA*MSAA);\n\n    fragColor = vec4(totcol,1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat4 build_transform(vec3 pos, vec3 ang) \n{\n  float cosX = cos(ang.x);\n  float sinX = sin(ang.x);\n  float cosY = cos(ang.y);\n  float sinY = sin(ang.y);\n  float cosZ = cos(ang.z);\n  float sinZ = sin(ang.z);\n\n  mat4 m;\n\n  float m00 = cosY * cosZ + sinX * sinY * sinZ; \n  float m01 = cosY * sinZ - sinX * sinY * cosZ; \n  float m02 = cosX * sinY;\n  float m03 = 0.0;\n  \n  float m04 = -cosX * sinZ; \n  float m05 = cosX * cosZ; \n  float m06 = sinX;\n  float m07 = 0.0;\n  \n  float m08 = sinX * cosY * sinZ - sinY * cosZ;\n  float m09 = -sinY * sinZ - sinX * cosY * cosZ;\n  float m10 = cosX * cosY;\n  float m11 = 0.0;\n  \n  float m12 = pos.x;\n  float m13 = pos.y;\n  float m14 = pos.z;\n  float m15 = 1.0;\n\n  /*\n  //------ Orientation ---------------------------------\n  m[0] = vec4(m00, m01, m02, m03); // first column.\n  m[1] = vec4(m04, m05, m06, m07); // second column.\n  m[2] = vec4(m08, m09, m10, m11); // third column.\n\n  //------ Position ------------------------------------\n  m[3] = vec4(m12, m13, m14, m15); // fourth column.\n  */\n\n  //------ Orientation ---------------------------------\n  m[0][0] = m00; // first entry of the first column.\n  m[0][1] = m01; // second entry of the first column.\n  m[0][2] = m02;\n  m[0][3] = m03;\n  \n  m[1][0] = m04; // first entry of the second column.\n  m[1][1] = m05; // second entry of the second column.\n  m[1][2] = m06;\n  m[1][3] = m07;\n\n  m[2][0] = m08; // first entry of the third column.\n  m[2][1] = m09; // second entry of the third column.\n  m[2][2] = m10;\n  m[2][3] = m11;\n  \n  //------ Position ------------------------------------\n  m[3][0] = m12; // first entry of the fourth column.\n  m[3][1] = m13; // second entry of the fourth column.\n  m[3][2] = m14;\n  m[3][3] = m15;\n\n  return m;\n}\n\nconst float EPSILON = 1e-10;\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 HSLtoRGB(in vec3 hsl)\n{\n    // Hue-Saturation-Lightness [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsl.x);\n    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n\nvec3 RGBtoHSV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 RGBtoHSL(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Lightness [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float z = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);\n    return vec3(hcv.x, s, z);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColor = texture(iChannel0,1.6*vec2(atan(rayDir.x/rayDir.z + 0.0) + iTime/5. , (rayDir.y)));\n    fragColor *= fragColor*1.7;\n}","name":"Cube A","description":"","type":"cubemap"}]}