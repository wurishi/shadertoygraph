{"ver":"0.1","info":{"id":"mlSSz1","date":"1675671443","viewed":97,"name":"Fork Desire Cry","username":"2505598272","description":"from https://www.shadertoy.com/view/flfyRS\n\n效果不变，改了下代码格式","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","glass","crystal"],"hasliked":0,"parentid":"flfyRS","parentname":"Desire Crystal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DTR 0.01745329\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 uv;\n// ray 相关参数\nvec3 cp, cn, cr, ro, rd;\nfloat cd, sd, io, td;\n// oc - 物体表面颜色，cc - 颜色处理后结果\nvec3 oc, cc;\n// 透明度\nfloat oa;\n// 结果颜色\nvec4 fc;\n// 时间\nfloat tt;\nint es = 0;\n\nfloat bx(vec3 p, vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return min(max(q.x, max(q.y, q.z)), 0.) + length(max(q, 0.));\n}\nfloat cy(vec3 p, vec2 s)\n{\n    p.y += s.x / 2.;\n    p.y -= clamp(p.y, 0., s.x);\n    return length(p) - s.y;\n}\n\nfloat shatter(vec3 p, float d, float n, float a, float s)\n{\n    for(float i = 0.; i < n; i++)\n    {\n        p.xy *= rot(a);\n        p.xz *= rot(a * 0.5);\n        p.yz *= rot(a + a);\n        float c = mod(i, 3.) == 0. ? p.x : mod(i, 3.) == 1. ? p.y : p.z;\n        c = abs(c) - s;\n        d = max(d, -c);\n    }\n    return d;\n}\n\nvec3 lattice(vec3 p, int iter)\n{\n    for(int i = 0; i < iter; i++)\n    {\n        if (i % 2 == 0) {\n            p.xy *= rot(45.*DTR);\n        } else {\n            p.xz *= rot(45.*DTR);\n        }\n        p = abs(p) - 1.;\n        if (i % 2 == 1) {\n            p.xy *= rot(-45.*DTR);\n            p.zy *= rot(-45.*DTR);\n        } else {\n            p.xz *= rot(-45.*DTR);\n            p.yz *= rot(-45.*DTR);\n        }\n    }\n    return p;\n}\n\nfloat mp(vec3 p)\n{\n    //now with mouse control\n    if(iMouse.z > 0.)\n    {\n        p.yz *= rot(2.0 * (iMouse.y / iResolution.y - 0.5));\n        p.zx *= rot(-7.0 * (iMouse.x / iResolution.x - 0.5));\n    } else {\n        p.xz *= rot(tt * 0.2);\n        p.xy *= rot(tt * 0.2);\n    }\n    vec3 pp = p;\n    \n    p = lattice(p, 2);\n\n    sd = cy(p, vec2(0.2)) - 0.05;\n\n    sd = shatter(p, sd, 1., sin(tt * 0.1), 0.2);\n\n    sd = min(sd, bx(p, vec3(0.1, 1.1, 4.)) - 0.3);\n\n    sd = mix(sd, cy(p, vec2(4, 1)), cos(tt * 0.5) * 0.5 + 0.5);\n\n\n    sd = abs(sd) - 0.001;\n    if(sd < 0.001)\n    {\n        oc = mix(vec3(0.2, 0.9, 0.6), vec3(1., 0.6, 0.), pow(length(pp) * 0.18, 1.5));\n        io = 1.1;\n        oa = 0.05 + 1. - length(pp) * 0.2;\n    }\n    return sd;\n}\n\nvoid tr()\n{\n    cd = 0.;\n    for(float i = 0.; i < 512.; i++)\n    {\n        mp(ro + rd * cd);\n        cd += sd;\n        td += sd;\n        if(sd < 0.0001 || cd > 128.)break;\n    }\n}\nvoid nm()\n{\n    mat3 k = mat3(cp, cp, cp) - mat3(.001);\n    cn = normalize(mp(cp) - vec3(mp(k[0]), mp(k[1]), mp(k[2])));\n}\n\nvoid px()\n{\n    cc = vec3(0.1, 0.5, 0.4) + length(pow(abs(rd + vec3(0, 0.5, 0)), vec3(3))) * 0.3;\n    if(cd > 128.)\n    {\n        oa = 1.;\n        return;\n    }\n    vec3 l = vec3(0.4, 0.7, 0.8);\n    float df = clamp(length(cn * l), 0., 1.);\n    vec3 fr = pow(1. - df, 3.) * mix(cc, vec3(0.4), 0.5);\n    float sp = (1. - length(cross(cr, cn * l))) * 0.2;\n    float ao = min(mp(cp + cn * 0.3) - 0.3, 0.3) * 0.5;\n    cc = oc * (df + fr) + fr + sp + ao;\n}\n\nvoid render(vec2 frag, vec2 res, float time, out vec4 col)\n{\n    tt = mod(time, 260.);\n    uv = vec2(frag.x / res.x, frag.y / res.y);\n    uv -= 0.5;\n    uv /= vec2(res.y / res.x, 1);\n    ro = vec3(0, 0, -15);\n    rd = normalize(vec3(uv, 1));\n\n    for(int i = 0; i < 20; i++)\n    {\n        tr();\n        cp = ro + rd * cd;\n        nm();\n        ro = cp - cn * 0.01;\n        cr = refract(rd, cn, i % 2 == 0 ? 1. / io : io);\n        if(length(cr) == 0. && es <= 0)\n        {\n            cr = reflect(rd, cn);\n            es = 2;\n        }\n        if(max(es, 0) % 3 == 0 && cd < 128.)rd = cr;\n        es--;\n        px();\n        fc = fc + vec4(cc * oa, oa) * (1. - fc.a);\n        if((fc.a >= 1. || cd > 128.))break;\n    }\n    col = fc / fc.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    render(fragCoord.xy, iResolution.xy, iTime, fragColor);\n}","name":"Image","description":"","type":"image"}]}