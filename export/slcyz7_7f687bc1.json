{"ver":"0.1","info":{"id":"slcyz7","date":"1659545871","viewed":239,"name":"truchet tiling on sphere","username":"valena","description":"This sketch inspired by work of BigWIngs.\n\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sphere","truchet","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Texture is made by using Truchet tiling. Each tile has 8 \"connection points\", \n//and 4 lines going from one point to another. Pattern of each tile is totaly random. \n//Texture is mapped to sphere by cubemapping. It uses two layers of Truchet tiling,\n//If you want to increase your fps, just switch USE_TWO_LAYERS to false\n\n//All of code made fully by myself, especially tiling and cube mapping.\n//A just could not found how cube mapping works on the internet, so made\n//formula by myself =)\n\n//The way of generating this pattern and the idea of cubemapping was inspired by BigWIngs\n\n#define PI 3.14159265359\n\n#define USE_TWO_LAYERS true\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat rand(float p)\n{\n\treturn fract(sin(p * 1.231 + 4.123) * 5.212 + 5.214);\n}\n\nmat2 rmatrix(float a)  //--Function to rotate 2d vector\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\n\treturn mat2(c, -s, s, c);\n}\n\nfloat lineDist(vec2 p, vec2 p1, vec2 p2)   //Distance to line starting and ending at p1 and p2 accordingly\n{\n\tfloat h = dot(p - p1, p2 - p1) / pow(length(p2 - p1), 2.0);\n\n\th = max(0.0, min(1.0, h));\n\n\tvec2 p3 = p1 * (1.0 - h) + p2 * h;\n\treturn (length(p - p3));\n}\n\nfloat bezier(vec2 p, vec4 p1, vec4 p2)  //Distance to Bezier Curve. p1 and p2 \n                                        //have subpoints coordinates at zw components\n{\n\tfloat minDist = -1.0;\n\tfloat steps = 15.0;\n\tvec2 lp1 = p1.xy;\n\tvec2 lp2;\n\n\n\tfor (float t = 1.0 / steps; t <= 1.01; t += 1.0 / steps)\n\t{\n\t\tvec2 A = p1.xy * (1.0 - t) + p1.zw * t;\n\t\tvec2 B = p1.zw * (1.0 - t) + p2.zw * t;\n\t\tvec2 C = p2.zw * (1.0 - t) + p2.xy * t;\n\n\t\tvec2 D = A * (1.0 - t) + B * t;\n\t\tvec2 E = B * (1.0 - t) + C * t;\n\n\t\tvec2 F = D * (1.0 - t) + E * t;\n\n\t\tlp2 = F;\n\n\t\tfloat dist = lineDist(p, lp1, lp2);\n\n\t\tif (minDist == -1.0 || dist < minDist)\n\t\t\tminDist = dist;\n\n\t\tlp1 = lp2;\n\t}\n\n\treturn (minDist);\n}\n\nvec2 getPointByID(float i, float a1, float a2)  //Getting coordinate of connection point dy id\n{\n\tvec2 p1;\n\n\tfloat iEdge = floor(i / 2.0);\n\n\tif (iEdge < 1.)\n\t\tp1.xy = vec2(a1 + a2 * step(0.5, fract(i / 2.0)), 0);\n\telse if (iEdge < 2.)\n\t\tp1.xy = vec2(1.0, a1 + a2 * step(0.5, fract(i / 2.0)));\n\telse if (iEdge < 3.)\n\t\tp1.xy = vec2(1.0 - a1 - a2 * step(0.5, fract(i / 2.0)), 1.0);\n\telse if (iEdge < 4.)\n\t\tp1.xy = vec2(0.0, 1.0 - a1 - a2 * step(0.5, fract(i / 2.0)));\n\telse\n\t\tp1.xy = vec2(0.5, 0.5);\n\n\treturn (p1);\n}\n\nfloat bezierID(vec2 p, float i, float j)   //Distance to bezier curve by id of points\n{\n\tvec4 p1, p2;\n\n\tfloat k1 = 0.33;\n\tfloat k2 = 0.2;\n\n\tfloat a1 = k1;\n\tfloat a2 = 1.0 - 2.0 * k1;\n\n\tfloat iEdge = floor(i / 2.0);\n\tfloat jEdge = floor(j / 2.0);\n\n\tp1.xy = getPointByID(i, a1, a2);\n\tp2.xy = getPointByID(j, a1, a2);\n\n\tif (iEdge == 0.0)\n\t\tp1.zw = vec2(p1.x, k2);\n\telse if (iEdge == 2.0)\n\t \tp1.zw = vec2(p1.x, 1.0 - k2);\n\telse if (iEdge == 1.0)\n\t \tp1.zw = vec2(1.0 - k2, p1.y);\n\telse if (iEdge == 3.0)\n\t\tp1.zw = vec2(k2, p1.y);\n\n\tif (jEdge == 0.0)\n\t\tp2.zw = vec2(p2.x, k2);\n\telse if (jEdge == 2.0)\n\t \tp2.zw = vec2(p2.x, 1.0 - k2);\n\telse if (jEdge == 1.0)\n\t \tp2.zw = vec2(1.0 - k2, p2.y);\n\telse if (jEdge == 3.0)\n\t\tp2.zw = vec2(k2, p2.y);\n\n\treturn (bezier(p, p1, p2));\n}\n\nvoid getPath(vec2 id, out float path[8])  //Get the random path of each of four lines\n{\n\tbool used[8] = bool[8](false, false, false, false, false, false, false, false);\n\n\tint an = 8;\n\t\n\tfloat rnum = rand(id);\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\trnum = rand(rnum) * float(an);\n\t\tint x = -1;\n\n\t\tfor (float j = 0.0; j < rnum; j++)\n\t\t{\n\t\t\tx++;\n\t\t\twhile (used[x])\n\t\t\t\tx++;\n\t\t}\n\t\tpath[i] = float(x);\n\t\tused[x] = true;\n\t\tan--;\n\t}\n}\n\nvoid getTile(vec2 p, vec2 id, inout vec3 color) //Get the tile and ad it to color\n{\n\tfloat lineW = 0.1;\n\tfloat shadow = 0.1;\n\tfloat path[8];\n\n\tgetPath(id, path);\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tfloat res = bezierID(p, path[i * 2], path[i * 2 + 1]);\n\n\t\tif (res < lineW)\n\t\t\tcolor = vec3(1);\n\t\telse if (res < lineW + shadow)\n\t\t\tcolor *= 1.0 - (1.0 - (res - lineW) / shadow) * 0.8;\n\t}\n}\n\nvoid getTex(vec2 uv, inout vec3 color)   //This function just makes two layers of Truchet pattern\n{\n\tvec2 uv1 = uv * 5.0;\n\tvec2 uv2 = uv;\n    \n    if (USE_TWO_LAYERS)\n        getTile(fract(uv1), floor(uv1), color);\n\tgetTile(fract(uv2), floor(uv2), color);\n}\n\nvec3 getRayDir(vec3 cameraDir, float cameraAngle, vec2 coord)\n{\n\tvec3 xAxis = normalize(vec3(-cameraDir.z, 0, cameraDir.x)) * tan(cameraAngle / 2.0);\n\tvec3 yAxis = normalize(cross(cameraDir, xAxis)) * tan(cameraAngle / 2.0) * -1.0;\n\tvec3 result = normalize(cameraDir + xAxis * coord.x + yAxis * coord.y);\n\n\treturn (result);\n}\n\nfloat map(in vec3 p)\n{\n\treturn length(p) - 0.4;\n}\n\nfloat marchRay(vec3 rayOrigin, vec3 rayDir)\n{\n\tfloat t;\n\tfloat d = 0.0;\n\tfloat e = 0.001;\n\tfloat maxRange = 100.0;\n\tvec3 pos;\n\n\tfor (t = 0.0; t <= maxRange; t += d)\n\t{\n\t\tpos = rayOrigin + rayDir * t;\n\t\td = map(pos);\n\n\t\tif (d < e)\n\t\t\tbreak;\n\t}\n\tif (t > maxRange)\n\t\treturn (-1.0);\n\treturn (t);\n}\n\nvec3 getNorm(vec3 pos)\n{\n\tvec2 e = vec2(0.0001, 0);\n\tfloat tp = map(pos);\n\n\tvec3 norm = -normalize(vec3(map(pos - e.xyy) - tp,\n\t\t\t\t\t\t\t   map(pos - e.yxy) - tp,\n\t\t\t\t\t\t\t   map(pos - e.yyx) - tp));\n\treturn (norm);\n}\n\nvec3 cubeMap(vec3 p)   //Function for mapping 2d texture to 3d sphere\n{\n\tvec3 ap = abs(p);\n\tfloat m = max(ap.x, max(ap.y, ap.z));\n\tvec2 uv;\n\tfloat side;\n\n\tif (ap.x == m)\n\t{\n\t\tuv.x = atan(p.z, p.x) / (PI / 4.0);\n\t\tuv.y = atan(p.y, p.x) / (PI / 4.0);\n\t\tside = 1.0 * sign(p.x);\n\t}\n\tif (ap.z == m)\n\t{\n\t\tuv.x = atan(p.x, p.z) / (PI / 4.0);\n\t\tuv.y = atan(p.y, p.z) / (PI / 4.0);\n\t\tside = 2.0 * sign(p.z);\n\t}\n\tif (ap.y == m)\n\t{\n\t\tuv.x = atan(p.x, p.y) / (PI / 4.0);\n\t\tuv.y = atan(p.z, p.y) / (PI / 4.0);\n\t\tside = 3.0 * sign(p.y);\n\t}\n\treturn vec3(uv, side);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv;\n    vec2 screenUV = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n\tvec3 color = vec3(0);\n    \n    float camPitch = cos(iTime / 35.0);\n    float camYaw = iTime / 25.0;\n    float cameraDist = 2.0;\n    \n    vec3 cameraPos = cameraDist * vec3(cos(camYaw) * cos(camPitch), sin(camPitch), sin(camYaw) * cos(camPitch));\n    vec3 cameraDir = -normalize(cameraPos);\n    \n\tvec3 rayDir = getRayDir(cameraDir, PI / 3.0, screenUV);\n\n\tvec3 p = rayDir;\n\n\tfloat t = marchRay(cameraPos, rayDir);\n\n\tif (t != -1.0) //---if ray hit the sphere----\n\t{\n\t\tvec3 sp = cameraPos + rayDir * t;\n\t\tvec3 cm = cubeMap(sp);\n\t\tuv = cm.xy;\n\t\tuv *= 4.0;\n\t\tuv += 100.0 * cm.z;\n\t\tcolor = vec3(0.05);\n\t\tgetTex(uv, color);\n\t}\n\telse\n\t{\n\t\tvec3 cm = cubeMap(p);\n\t\tuv = cm.xy;\n\t\tuv *= 10.0;\n\t\tuv += 100.0 * cm.z;\n\t\tgetTex(uv, color);\n\t\tcolor *= 0.5;\n\t}\n\n\tfloat r = length(screenUV);\n\n\tcolor *= (1.0 - r);\n\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}