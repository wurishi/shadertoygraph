{"ver":"0.1","info":{"id":"Mcl3z4","date":"1702834848","viewed":142,"name":"2D terrain with shadows","username":"Yarodash","description":"2D terrain with shadows","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["2d","terrain","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.14159265358979323846\n\nfloat getH(vec2 pos) { \n    pos.x /= iResolution.x / iResolution.y;\n    return max(texture(iChannel0, pos + 0.5).x, 0.06);\n}\n\nfloat getWater(vec2 pos) { \n    pos.x /= iResolution.x / iResolution.y;\n    return texture(iChannel0, pos + 0.5).x;\n}\n\nfloat checkShadow(vec3 pos, vec3 sun) {\n    float maxDist = distance(pos, sun);\n    vec3 sunDir = normalize(sun - pos);\n    \n    float s = 0.01;\n    float d = 0.0;\n    \n    while (d < maxDist && pos.z < 1.0) {\n        if (pos.z < getH(pos.xy)) {\n            return 0.0;\n        }\n        d += s;\n        pos += sunDir * s;\n    }\n    \n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color = texture(iChannel1, uv).rgb;\n    \n    vec2 pos = (uv - 0.5);\n    pos.x *= iResolution.x / iResolution.y;\n\n    vec2 sunPos = iMouse.xy / iResolution.xy;\n    sunPos = (sunPos - 0.5);\n    sunPos.x *= iResolution.x / iResolution.y;\n    \n    float shadow = 0.0;\n    \n    float radius = 0.01;\n    /*for (float i = 0.0; i < 4.0; i += 1.0) {\n        float dx = radius * cos(i / 4.0 * 2.0 * M_PI);\n        float dy = radius * sin(i / 4.0 * 2.0 * M_PI);\n        \n        shadow += checkShadow(vec3(pos, getH(pos)), vec3(sunPos + vec2(dx, dy), 2.0));\n    }*/\n\n    vec3 POS = vec3(pos, getH(pos));\n    vec3 SUN = vec3(sunPos, 3.0);\n    float sunDist = distance(POS, SUN);\n    shadow = checkShadow(POS, SUN);\n    shadow += checkShadow(POS, SUN + vec3(0.0, 0.0, 0.1));\n    shadow *= 0.5;\n    \n    // 0.5 + min(1.5 * pow(maxDist, -1.0), 0.5);\n    \n    float ambientOcclusion = texture(iChannel2, uv).r;\n    float totalShadow = 0.5 + min(SUN.z * shadow * pow(sunDist, -2.0), 0.5);\n\n    vec3 CAMERA_POS = vec3(0.0, 0.0, 8.0);\n    \n    float water_reflect = 0.0;\n    \n    if (getWater(pos) < 0.06) {\n        water_reflect = 1.0;\n    }\n    \n    vec3 N = vec3(0.0, 0.0, 1.0);\n    vec3 L = normalize(SUN - POS);\n    vec3 V = normalize(CAMERA_POS - POS);\n    \n    float specular = pow(max(dot(N, normalize(L + V)), 0.0), 256.0); \n    \n    fragColor = vec4(0.3 * totalShadow * specular * water_reflect + color * totalShadow - 0.1 * ambientOcclusion, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define M_PI 3.14159265358979323846\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 1.0/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(M_PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    //float W = iMouse.x / iResolution.x * 100.0;\n    //uv = floor(uv * W) / W;\n    \n    float HEIGHT = 1.5;\n    \n    float d = distance(uv, vec2(0.0));\n    float h = HEIGHT * pNoise(uv * 3.0 + iTime * 0.1, 8) - pow(d, 2.0) * 1.7 * HEIGHT + 0.15;\n    h = max(0.0, h);\n\n    fragColor = vec4(h, h, h, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 heightToColor(float height) {\n    vec3 sea = vec3(0.2039, 0.5137, 0.9216);\n    vec3 sand = vec3(0.9569, 0.8392, 0.6549);\n    vec3 grass = vec3(0.4078, 0.6392, 0.3176);\n    vec3 snow = vec3(0.95, 0.95, 0.95);\n    \n    if (height < 0.06) {\n        return sea;\n    }\n    \n    if (height < 0.12) {\n        return sand;\n    }\n    \n    if (height < 0.43) {\n        return grass;\n    }\n    \n    return snow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            color += heightToColor(texture(iChannel0, uv + vec2(0.0, 0.0) / 1.5 / iResolution.x).x);\n        }\n    }\n\n    fragColor = vec4(color / 9.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float getH(vec2 pos) { \n    pos.x /= iResolution.x / iResolution.y;\n    return max(texture(iChannel0, pos + 0.5).x, 0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = (uv - 0.5);\n    pos.x *= iResolution.x / iResolution.y;\n    \n    float h = getH(pos);\n    \n    float c = 0.0;\n    \n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            float deltaH = abs(getH(pos + vec2(x, y) / iResolution.xy) - h);\n            c += deltaH * 0.6;\n        }\n    }\n    \n    c = min(1.0, max(c, 0.0));\n    c = smoothstep(0.001, 0.05, c);\n    \n    fragColor = vec4(c, c, c, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}