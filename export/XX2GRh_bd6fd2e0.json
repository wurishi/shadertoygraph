{"ver":"0.1","info":{"id":"XX2GRh","date":"1708199715","viewed":68,"name":"voronoi_opalite","username":"danielroeven","description":"arst","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"ftl3Wl","parentname":"Practice Simple Voronoi "},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Returns a hash value based on a single float input\nfloat hashFromSingleFloat( float inputFloat ) { \n    return fract(sin(inputFloat)*43758.5453); \n}\n\n// Returns a 2D hash value from a 2D vector\nvec2 hashFromVec2( vec2 position ) { \n    position = vec2( dot(position, vec2(127.1, 311.7)), dot(position, vec2(269.5, 183.3)) ); \n    return fract(sin(position) * 43758.5453); \n}\n\n// The parameter smoothnessFactor controls the smoothness of the Voronoi edges\nvec4 calculateVoronoi( in vec2 position, float smoothnessFactor )\n{\n    vec2 baseCell = floor( position ); // Base cell position\n    vec2 positionWithinCell = fract( position ); // Position within the base cell\n\n    vec4 minDistAndColor = vec4( 8.0, 0.0, 0.0, 0.0 ); // Initialize min distances and color\n    for( int offsetY = -2; offsetY <= 2; offsetY++ )\n    for( int offsetX = -2; offsetX <= 2; offsetX++ )\n    {\n        vec2 offset = vec2( float(offsetX), float(offsetY) );\n        vec2 hashOffset = hashFromVec2( baseCell + offset );\n        \n        hashOffset = 0.5 + 0.5 * sin( 6.2831 * hashOffset ); // Adjust hash offset\n\n        // Calculate distance to the cell\n        float distanceToCell = length(offset - positionWithinCell + hashOffset);\n        \n        // Calculate cell color based on hash\n        vec3 cellColor = 0.5 + 0.5 * sin( hashFromSingleFloat(dot(baseCell + offset, vec2(7.0, 113.0))) * 2.5 + 3.5 + vec3(2.0, 3.0, 0.0));\n        cellColor = cellColor * cellColor; // Adjust color to linear space\n        \n        // Perform smooth minimum calculation for colors and distances\n        float smoothStepResult = smoothstep( -1.0, 1.0, (minDistAndColor.x - distanceToCell) / smoothnessFactor );\n        minDistAndColor.x = mix( minDistAndColor.x, distanceToCell, smoothStepResult ) - smoothStepResult * (1.0 - smoothStepResult) * smoothnessFactor / (1.0 + 3.0 * smoothnessFactor); // distance\n        minDistAndColor.yzw = mix( minDistAndColor.yzw, cellColor, smoothStepResult ) - smoothStepResult * (1.0 - smoothStepResult) * smoothnessFactor / (1.0 + 3.0 * smoothnessFactor); // color\n    }\n    \n    return minDistAndColor;\n}\n\n\nfloat noise2d(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(1.0,73))) * 43758.5453);\n}\n\n\n// https://www.shadertoy.com/view/ttcyRS\n// The MIT License\n// Copyright Â© 2020 Inigo Quilez\nvec3 to_linear(vec3 color){\n    return pow(color,vec3(2.2));\n}\n\nvec3 from_linear(vec3 color){\n    return pow(color,vec3(1.0/2.2) );\n}\n\nvec3 oklab_mix( vec3 colA, vec3 colB, float h )\n{\n\n    //colA = to_linear(colA);\n    //colB = to_linear(colB);\n\n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(                \n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n                    \n    // rgb to cone (arg of pow can't be negative)\n    vec3 lmsA = pow( kCONEtoLMS*colA, vec3(1.0/3.0) );\n    vec3 lmsB = pow( kCONEtoLMS*colB, vec3(1.0/3.0) );\n    // lerp\n    vec3 lms = mix( lmsA, lmsB, h );\n    // gain in the middle (no oaklab anymore, but looks better?)\n // lms *= 1.0+0.2*h*(1.0-h);\n    // cone to rgb\n    return kLMStoCONE*(lms*lms*lms);\n}\n\n// end oklab\n\nvec2 getP1(float t) {\n    float x1 = (sin(t)+1.0)/2.0 * 0.5;\n    float x2 = (cos(t*3.0)+1.0)/2.0 * 0.3;\n    float x3 = (sin(t*5.0)+1.0)/2.0 * 0.2;\n    float x = x1 + x2 + x3;\n      \n    float y1 = (cos(t)+1.0)/2.0 * 0.5;\n    float y2 = (sin(t*3.0)+1.0)/2.0 * 0.3;\n    float y3 = (sin(t*5.0)+1.0)/2.0 * 0.2;\n    float y = y1 + y2 + y3;\n    vec2 pos = vec2(x,y);\n    return pos;\n}\n\nvec2 getP2(float t) {\n    t = t * 1.2 + 3389.0;\n    float x1 = (cos(t)+1.0)/2.0 * 0.5;\n    float x2 = (sin(t*3.0)+1.0)/2.0 * 0.3;\n    float x3 = (sin(t*5.0)+1.0)/2.0 * 0.2;\n    float x = x1 + x2 + x3;\n      \n    float y1 = (sin(t)+1.0)/2.0 * 0.5;\n    float y2 = (cos(t*3.0)+1.0)/2.0 * 0.3;\n    float y3 = (sin(t*5.0)+1.0)/2.0 * 0.2;\n    float y = y1 + y2 + y3;\n    vec2 pos = vec2(x,y);\n    return pos;\n}\n\nvec2 getP3(float t) {\n    t = t * 1.1 + 9389.0;\n    float x1 = (sin(t)+1.0)/2.0 * 0.5;\n    float x2 = (sin(t*3.0)+1.0)/2.0 * 0.3;\n    float x3 = (cos(t*5.0)+1.0)/2.0 * 0.2;\n    float x = x1 + x2 + x3;\n      \n    float y1 = (cos(t)+1.0)/2.0 * 0.5;\n    float y2 = (sin(t*3.0)+1.0)/2.0 * 0.3;\n    float y3 = (cos(t*5.0)+1.0)/2.0 * 0.2;\n    float y = y1 + y2 + y3;\n    vec2 pos = vec2(x,y);\n    return pos;\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nfloat remap(float v, float size, float fade_percentage ){\n      float clamped = clamp(v, 0.0, size);\n      float normalized = map(clamped, 0.0, size, 0.0, 1.0);\n      \n      if(fade_percentage == 0.0)\n          return v < size ? 0.0 : 1.0;\n          \n      return smoothstep(1.0 - fade_percentage, 1.0, normalized);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 normalizedPosition = fragCoord / iResolution.y;\n    float aspectRatioCorrection = 0.5 * iResolution.x / iResolution.y;\n    \n    vec4 voronoiResult = calculateVoronoi( 40.0 * normalizedPosition, 0.00 );\n\n    vec3 correctedColor = sqrt(voronoiResult.yzw); // Correct color gamma\n\n    vec2 p = normalizedPosition + (vec2(correctedColor.x, correctedColor.y) / 8.0);\n    \n    float size = 0.6;\n    float fade = 0.9;    \n\n    //vec2 p = fragCoord/iResolution.xy;\n    float t = iTime / 5.0;\n    \n    vec2 pos1 = getP1(t);\n    vec2 pos2 = getP2(t);\n    vec2 pos3 = getP3(t);\n\n    float d1 = distance(pos1, p);\n    float d2 = distance(pos2, p);\n    float d3 = distance(pos3, p);\n    \n    d1 = remap(d1, size, fade);\n    d2 = remap(d2, size, fade);\n    d3 = remap(d3, size, fade);\n    \n    vec3 bg_color = to_linear(vec3(0.965,0.949,0.937));  \n    vec3 color1 = to_linear(vec3(0.922,0.816,0.949));\n    vec3 color2 = to_linear(vec3(0.816,0.839,0.949));\n    vec3 color3 = to_linear(vec3(0.816,0.925,0.949));\n      \n    vec3 color = bg_color;\n    color = oklab_mix(color1, color, d1);\n    color = oklab_mix(color2, color, d2);\n    color = oklab_mix(color3, color, d3);\n       \n    color = color +  (noise2d(p) * 2.0 - 1.0) * 0.08;\n    \n    fragColor = vec4(from_linear(color),1.0);\n    \n        \n    //fragColor = vec4( correctedColor, 1.0 );\n}","name":"Image","description":"","type":"image"}]}