{"ver":"0.1","info":{"id":"stB3zd","date":"1624500133","viewed":332,"name":"MSAA Sampler","username":"Kecho","description":"Potential 4x4 msaa resolver, treating msaa samples as stratified points in a grid.\nCode includes area selection algorithm and point selection, with this we can perform distance weights operations and so on","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["msaasampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MSAA Resolver visualizer\n// by\n// Kleber Garcia (c) 2021\n//\n//Potential 4x4 msaa resolver, treating msaa samples as stratified points in a grid.\n//Code includes area selection algorithm and point selection, with this we can perform distance weights operations and so on\n\nconst vec2 samplePoints[] = vec2[](\n    vec2(-1.0/8.0,-3.0/8.0),\n    vec2( 3.0/8.0,-1.0/8.0),\n    vec2(-3.0/8.0, 1.0/8.0),\n    vec2( 1.0/8.0, 3.0/8.0)\n);\n\n/// Transformation functions. Thse functions determine which area a particular point in a grid is.\n/// There are 4 possible areas in the grid. Selected area is determined by the mouse coordinate.\n\nvec2 transformToArea0(vec2 ccIn)\n{ \n    const float distSquare = 2.0*distance(samplePoints[0],  samplePoints[1]);\n    const float sinTheta = 2.0/sqrt(20.0);\n    const float cosTheta = 4.0/sqrt(20.0);\n    const vec2 xAxis = vec2(cosTheta, sinTheta);\n    const vec2 yAxis = vec2(sinTheta, -cosTheta);\n    return vec2(dot(ccIn, xAxis), dot(ccIn,yAxis)) * 2.0 / distSquare;\n}\n\nvec2 transformToArea1(vec2 ccIn)\n{ \n    const float distSquare = 2.0*distance(samplePoints[0],  samplePoints[1]);\n    const float sinTheta = 4.0/sqrt(20.0);\n    const float cosTheta = 2.0/sqrt(20.0);\n    const vec2 xAxis = vec2(cosTheta, sinTheta);\n    const vec2 yAxis = vec2(sinTheta, -cosTheta);\n    return vec2(dot(ccIn, xAxis), dot(ccIn,yAxis)) * 2.0 / distSquare;\n}\n\nvec2 transformToArea2(vec2 ccIn)\n{\n    const float distSquare = 2.0*distance(samplePoints[0],  samplePoints[1]);\n    ccIn *= 2.99/distSquare;\n    return vec2(ccIn.x + ccIn.y *2.0/4.0,ccIn.x*2.0/4.0 + ccIn.y);    \n}\n\nvoid getAreaPointsAndWeights(\n    vec2 pixelCoord, int areaId,\n    out ivec3 p0, out ivec3 p1, out ivec3 p2, out ivec3 p3)\n{\n    if (areaId == 0)\n    {\n        p0 = ivec3(0,0,0);\n        p1 = ivec3(0,0,1);\n        p2 = ivec3(0,0,2);\n        p3 = ivec3(0,0,3);\n        \n    }\n    else if (areaId == 1)\n    {\n        p0 = ivec3(0, 0,2);\n        p1 = ivec3(0,-0.5,0);\n        p2 = ivec3(-0.5,0,3);\n        p3 = ivec3(-0.5,-0.5,1);        \n    }\n    else if (areaId == 2)\n    {\n        p0 = ivec3(0, 0, 0);\n        p1 = ivec3(0, 0, 2);\n        p2 = ivec3(-0.5, 0, 1);\n        p3 = ivec3(-0.5, 0, 3);\n    }\n    else    \n    {\n        p0 = ivec3(0,0,0);\n        p1 = ivec3(0,0,1);\n        p2 = ivec3(0,0.5,2);\n        p3 = ivec3(0,0.5,3);\n    }\n}\n\n\nvec2 offsetForArea(vec2 fragCoord, int areaId)\n{\n    if (areaId == 1)\n    {\n        fragCoord += 0.5;\n    }\n    else if (areaId == 2)\n    {\n        fragCoord.x += 0.5;\n    }\n    else if (areaId == 3)\n    {\n        fragCoord.y += 0.5;\n    }\n    return fragCoord;\n}\n\n// Drawing functionality, which visualizes stuff\n\nvec2 canvasCoord(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvec3 canvasMask(vec2 cc)\n{\n    if (cc.x > 1.0 || cc.x < -1.0 || cc.y > 1.0 || cc.y < -1.0)\n        return vec3(0,0,0);\n        \n    return vec3(1,1,1);\n}\n\nvoid drawGrid(vec2 uv, inout vec3 col)\n{\n    vec2 subUv = fract(uv * 3.0);\n    vec2 subCc = subUv * 2.0 - 1.0;\n    vec2 border = clamp((1.0 - abs(subCc))/0.03, 0.0, 1.0);\n    col = mix(vec3(0,0,0), col, border.x * border.y);\n    \n    vec2 subsubUv = fract(subUv * 8.0);\n    vec2 subsubCc = subsubUv * 2.0 - 1.0;\n    vec2 subsubBorder = clamp((1.0 - abs(subsubCc))/0.1, 0.0, 1.0);\n    col = mix(vec3(0.7,0.6,0.5), col, subsubBorder.x * subsubBorder.y);\n    \n}\n\nvoid drawPoint(vec2 uv, vec2 center, vec3 color, float rad, inout vec3 outCol)\n{\n    float edge = 0.04;\n    float d = clamp(distance(uv, center) / rad - 1.0, 0.0, 1.0 + edge);\n    outCol = mix(color, outCol, clamp(d/edge, 0.0, 1.0));\n}\n\nvoid msaaPoint(vec2 uv, vec2 center, int sampleId, inout vec3 outCol)\n{\n    drawPoint(uv, center + 2.0*samplePoints[sampleId] , vec3(0.1, 0.8, 0.7), 0.06, outCol);\n}\n\nvoid drawMsaaPoints(vec2 uv, out vec3 outCol)\n{\n    for (float px = 0.0; px < 3.0; ++px)\n    {\n        for (float py = 0.0; py < 3.0; ++py)\n        {\n            vec2 subUv = fract(uv * 3.0);\n            vec2 dc = subUv * 2.0 - 1.0;\n            msaaPoint(dc, vec2(0.0), 0, outCol);\n            msaaPoint(dc, vec2(0.0), 1, outCol);\n            msaaPoint(dc, vec2(0.0), 2, outCol);\n            msaaPoint(dc, vec2(0.0), 3, outCol);\n        }\n    }    \n}\n\nvoid drawMouseGrid(vec2 uv, vec2 mouseUv, inout vec3 outCol)\n{\n    drawPoint(uv, mouseUv, vec3(0.9, 0.0, 0.1), 0.02, outCol);\n\n}\n\nvoid drawSamplePoints(vec2 uv, vec2 mouseUv, inout vec3 outCol)\n{\n    for (int sampleId = 0; sampleId < 4; ++sampleId)\n    {\n        drawPoint(uv, mouseUv + samplePoints[sampleId], vec3(0.4, 0.8, 0.9), 0.02, outCol);\n    }\n}\n\n\nvec2 transformToArea(vec2 fragCoord, int areaId)\n{\n    vec2 ccIn = fract(fragCoord) * 2.0 - 1.0;\n    \n    if (areaId == 0)\n        return transformToArea0(ccIn);\n    else if (areaId == 1)\n        return transformToArea1(ccIn);\n    else if (areaId == 2)\n        return transformToArea2(ccIn);\n    else //(areaId == 3)\n    {\n        ccIn.x = -ccIn.x;\n        return transformToArea2(ccIn);\n    }\n}\n\nvec3 areaColor(int areaId)\n{\n    if (areaId == 0)\n        return vec3(0.0,0.0,0.0);\n    else if (areaId == 1)\n        return vec3(0.0,0.0,0.0);\n    else if (areaId == 2)\n        return vec3(0.5,0.5,0.5);\n    else\n        return vec3(0.6,0.2,0.8);\n}\n\nvoid drawInArea(vec2 fragCoord, vec2 mouseFrag, int areaId, inout int selectedArea, inout vec3 outCol)\n{\n    fragCoord = offsetForArea(fragCoord, areaId);\n    mouseFrag = offsetForArea(mouseFrag, areaId);\n    vec2 rotCoord  = transformToArea(fragCoord, areaId);\n    vec2 limits = clamp((abs(rotCoord) - 1.0)/0.001, vec2(0.0,0.0), vec2(1.0,1.0));\n    \n    vec2 texelId = floor(fragCoord);\n    vec2 texelEnd = texelId + 1.0;\n    vec3 squareCol = areaColor(areaId);\n    float opacity = 0.14;\n    if (mouseFrag.x > texelId.x && mouseFrag.y > texelId.y && mouseFrag.x < texelEnd.x && mouseFrag.y < texelEnd.y)\n    {\n        vec2 mousePos = transformToArea(mouseFrag, areaId);\n        if (mousePos.x > -1.0 && mousePos.y > -1.0 && mousePos.x < 1.0 && mousePos.y < 1.0)\n        {\n            selectedArea = areaId;\n            opacity = 0.32;\n            squareCol = vec3(0.2,0.4,0.2);\n        }\n    }\n    \n    outCol = mix(outCol, squareCol, (1.0-max(limits.y,limits.x))*opacity);\n}\n\nvoid drawSamplePoints(vec2 fragCoord, vec2 mouseFrag, int selectedArea, inout vec3 outColor)\n{\n    if (selectedArea == -1)\n        return;\n        \n\n    vec2 texelCenter = floor(fragCoord) + 0.5;\n\n    vec2 pixelCoord = fract(fragCoord);\n    ivec3 sp0 = ivec3(0,0,0);\n    ivec3 sp1 = ivec3(0,0,0);\n    ivec3 sp2 = ivec3(0,0,0);\n    ivec3 sp3 = ivec3(0,0,0);\n    getAreaPointsAndWeights(pixelCoord, selectedArea, sp0, sp1, sp2, sp3);\n    \n    vec3 pColor = vec3(0,0.3,0.5) ;  \n    drawPoint(pixelCoord, 0.5 + vec2(sp0.xy) + samplePoints[sp0.z], pColor, 0.03, outColor);\n    drawPoint(pixelCoord, 0.5 + vec2(sp1.xy) + samplePoints[sp1.z], pColor, 0.03, outColor);\n    drawPoint(pixelCoord, 0.5 + vec2(sp2.xy) + samplePoints[sp2.z], pColor, 0.03, outColor);\n    drawPoint(pixelCoord, 0.5 + vec2(sp3.xy) + samplePoints[sp3.z], pColor, 0.03, outColor);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cc = canvasCoord(fragCoord);\n    vec2 mouseUv = canvasCoord(iMouse.xy)* vec2(0.5,-0.5) + vec2(0.5, 0.5);;\n    vec2 uv = cc * vec2(0.5,-0.5) + vec2(0.5, 0.5);\n    vec3 mask = canvasMask(cc);\n    vec3 outCol = vec3(0.9,0.9,0.9);\n    \n    drawGrid(uv, outCol);\n    drawMsaaPoints(uv, outCol);\n    drawMouseGrid(3.0*uv, 3.0*mouseUv, outCol);\n    drawSamplePoints(3.0 * uv, 3.0 * mouseUv, outCol);\n    int selectedArea = -1;\n    for (int areaId = 0; areaId < 4; ++areaId)\n        drawInArea(3.0 * uv, 3.0 * mouseUv, areaId, selectedArea, outCol);\n    \n    drawSamplePoints(3.0 * uv, 3.0 * mouseUv, selectedArea, outCol);\n    fragColor = vec4((outCol * mask),1.0);\n}\n","name":"Image","description":"","type":"image"}]}