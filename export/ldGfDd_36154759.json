{"ver":"0.1","info":{"id":"ldGfDd","date":"1531042585","viewed":132,"name":"Singing Pumpkin","username":"Firzen_","description":"I made a rapping pumpkin, because why not","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["visualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sSXzd","filepath":"https://soundcloud.com/flavoursmusic/illvis-freshly-pass-that-flavours-remix","previewfilepath":"https://soundcloud.com/flavoursmusic/illvis-freshly-pass-that-flavours-remix","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi (acos(-1.))\nconst float steps = 30.;\nconst float stepSize = 0.001;\n\nconst float voiceBand = 0.23;\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst vec3 camPos = vec3(0,0,10.);\n\nvec3 backGroundColor(vec2 uv, float t)\n{\n    float band = floor(uv.y*20.+sin(uv.x*3.+t));\n    float bandFract = fract(uv.y*20.+sin(uv.x*3.+t));\n    return vec3( sin(band), cos(band), cos(3.*band))*4.*(bandFract*bandFract-bandFract);\n}\n\nvec4 SDFEye( vec3 p, vec2 h )\n{\n    float f = texture(iChannel0, vec2(0.015,0)).r;\n    float eyeScale = max(EPSILON, -0.1+f*2.);\n    p.y /= eyeScale;\n    vec3 q = abs(p);\n    \n    //vec3 color = vec3(f,f,0);\n    vec3 color = backGroundColor(vec2(p.xy), iTime*f);\n    float dist = max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n    return vec4(color.rgb, dist);\n}\n\nvec4 SDFNose( vec3 p, vec2 h )\n{\n    float f = texture(iChannel0, vec2(0.53,0)).r;\n    p.y /= -f;\n    vec3 q = abs(p);\n    \n    //vec3 color = vec3(f,f,0);\n    vec3 color = backGroundColor(vec2(p.xy), iTime*f);\n    float dist = max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n    return vec4(color.rgb, dist);\n}\n\nvec4 SDFEllipsoid( in vec3 p, in vec3 r )\n{\n    float f = texture(iChannel0, vec2(voiceBand,0)).r;\n    float mouthScale = clamp(-2.+f*4., 0., 1.);\n    r.y *= mouthScale;\n    r.x *= 0.5+(mouthScale/2.);\n    \n    //vec3 color = vec3(f,0.,0.);\n    vec3 color = backGroundColor(vec2(p.xy), iTime*f);\n    \n    float dist = (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n    return vec4(color.rgb, dist);\n}\n\nvec4 SDFSphere(vec3 pos)\n{\n    float angle = atan(pos.z,pos.x);\n    //vec3 color = backGroundColor(vec2(pos.xy), iTime);\n    pos.y *= 1.3;\n    vec3 color = vec3(1.,117./255.,24./255.);\n    float dist = length(pos)-(1.+cos(10.*angle)*0.02);\n    return vec4(color.rgb, dist);\n}\n\nvec4 SDFDiff(vec4 distA, vec4 distB) {\n    if(distA.w > -distB.w)\n        return distA;\n    return distB;\n}\n\nvec4 SDFScene(vec3 pos)\n{\n    float f = clamp(1.0f-texture(iChannel0, vec2(0.005,0)).r,0.5f,1.f);\n    float d = texture(iChannel0, vec2(0.995,0)).r;\n    pos.y += d/3.f;\n    float dx = sin(texture(iChannel0, vec2(0.7,0)).r);\n    pos.x += dx/3.f;\n    pos *= f;\n    return SDFDiff(\n           SDFDiff(\n           SDFDiff(\n           SDFDiff(\n            SDFSphere(pos), SDFEye(pos-vec3(-0.4,0.1,1), vec2(0.2,1))\n            ),SDFEye(pos-vec3(0.4,0.1,1), vec2(0.2,1)))\n           ,SDFEllipsoid(pos-vec3(0,-0.35,1), vec3(0.5,0.1,0.8))),\n        \tSDFNose(pos-vec3(0,-0.1,1), vec2(0.1,1))\n           );\n}\n\nvec4 shortestDistanceToSurface(vec3 camPos, vec3 dir)\n{\n    float depth = MIN_DIST;\n    \n    for(int i = 0; i<MAX_MARCHING_STEPS; i++)\n    {\n        vec4 val = SDFScene(camPos+dir*depth);\n        float dist = val.w;\n        if(dist < EPSILON)\n            return vec4(val.rgb, depth);\n        depth += dist;\n        if(depth > MAX_DIST)\n            return vec4(0.,0.,0.,MAX_DIST);\n    }\n    return vec4(0.,0.,0.,MAX_DIST);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float dx = (SDFScene(vec3(p.x + EPSILON, p.y, p.z)).w - SDFScene(vec3(p.x - EPSILON, p.y, p.z)).w);\n    float dy = (SDFScene(vec3(p.x, p.y + EPSILON, p.z)).w - SDFScene(vec3(p.x, p.y - EPSILON, p.z)).w);\n    float dz = (SDFScene(vec3(p.x, p.y, p.z + EPSILON)).w - SDFScene(vec3(p.x, p.y, p.z - EPSILON)).w);\n    return normalize(vec3(\n        dx,\n        dy,\n        dz\n    ));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = camPos;\n    \n    float t = iTime + texture(iChannel0, vec2(0.005,0)).r*0.5;\n    \n    vec3 lightDir1 = -vec3(cos(t),-sin(t),-2.);\n    lightDir1 = normalize(lightDir1);\n    vec3 lightColor1 = vec3(1.);\n    \n    vec3 lightDir2 = vec3(0,-1,-1);\n    vec3 lightColor2 = vec3(1.,0.9,0.9);\n        \n    vec4 val = shortestDistanceToSurface(eye, dir);\n    vec3 bgColor = backGroundColor(uv, t);\n    \n    if(val.w > MAX_DIST - EPSILON)\n        fragColor = vec4(bgColor,0.);\n    else\n    {\n        vec3 normal = estimateNormal(eye+dir*val.w);\n        vec3 geomColor = mix(val.rgb, bgColor, 0.05);\n        fragColor = vec4(geomColor*lightColor1,1.) * (max(0.,dot(normal, lightDir1)) + vec4(geomColor*lightColor2,1.) * max(0.,dot(normal, lightDir2)));\n    }\n}","name":"Image","description":"","type":"image"}]}