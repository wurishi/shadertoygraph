{"ver":"0.1","info":{"id":"sdGcWh","date":"1654750035","viewed":84,"name":"RayTracer02","username":"alanza","description":"a second attempt at raytracing","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 center;\n    vec3 color;\n    float radius;\n    float eta;\n};\n\nSphere spheres [8];\n\nstruct Light {\n    vec3 position;\n    float intensity;\n};\n\nLight lights [3];\n\nvec3 toLight(vec3 position, Light light) {\n    return light.intensity*(light.position - position)/dot(light.position - position, light.position - position);\n}\n\nstruct Ray {\n    vec3 point;\n    vec3 direction;\n};\n\nfloat solveQuadratic(in float a, in float b, in float c) {\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0 || a == 0.0) {\n    // no real roots, return garbage\n        return 696969.0;\n    }\n    else {\n        float root = sqrt(discriminant);\n        return 0.5*(-b + root)/a;\n        }\n        // both roots negative, return garbage\n        // else return 696969.0;\n}\n\n// assumes ray.direction is a unit vector\nfloat intersectSphere(in Ray ray, in Sphere sphere) {\n    float b = 2.0*dot(ray.point - sphere.center, ray.direction);\n    float c = dot(ray.point - sphere.center, ray.point - sphere.center) - sphere.radius*sphere.radius;\n    return solveQuadratic(1.0, b, c);\n}\n\nfloat intersectFloor(in Ray ray) {\n    if (ray.direction.y == 0.0) {\n        return 696969.0;\n    } else {\n    return (-1.0 - ray.point.y)/ray.direction.y;\n    }\n}\n\nstruct rayTraceData {\n    Ray ray;\n    vec3 color;\n};\n\nrayTraceData rayTrace(in Ray ray) {\n    int min = 0;\n    float dist = 696969.0;\n    for (int i = 0; i < spheres.length(); i++) {\n        float try = intersectSphere(ray, spheres[i]);\n        if (try < dist) {\n            dist = try;\n            min = i;\n        }\n    }\n    if (dist == 696969.0) {\n            return rayTraceData(ray, vec3(0,0,0));\n    }\n    // the first hit is at distance dist along ray.direction\n    vec3 hit = ray.point + dist*ray.direction;\n    // the normal to the sphere is (parallel to) the vector that points from the center to the hit point\n    vec3 normal = normalize(hit - spheres[min].center);\n    // bounce off the sphere\n    Ray new = Ray(hit, normalize(refract(ray.direction, normal, spheres[min].eta)));\n    vec3 col = vec3(0,0,0);\n    for (int i = 0; i < lights.length(); i++) {\n        float shade = dot(toLight(new.point, lights[i]), new.direction);\n        if (shade > 0.0) {\n            col = col + shade*shade*spheres[min].color;\n        }\n    }\n    return rayTraceData(new, col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec3 camera = vec3(0,0,8);\n    Ray ray = Ray(camera,normalize(vec3(uv,0.8)));\n    \n    for (int i = 0; i < spheres.length(); i++) {\n        float xcor = 4.0*(float(i) + 0.5 - 0.5*float(spheres.length()))/float(spheres.length());\n        spheres[i] = Sphere(\n            vec3(xcor, cos(xcor + iTime), 4.0 + sin(xcor + iTime)),\n            vec3(0.5+0.5*cos(xcor*iTime),0.5+0.5*sin(xcor*iTime),0.5+0.5*abs(cos(iTime)*sin(iTime))),\n            0.3,-0.5);\n    }\n    \n    lights[0] = Light(vec3(0,4,-4),8.0);\n    lights[1] = Light(vec3(-3,0,2),2.0);\n    lights[2] = Light(vec3(2,2,1),3.0);\n    \n    vec3 col;\n    for (int i = 0; i < 50; i++) {\n        rayTraceData data = rayTrace(ray);\n        if (i < 1) {\n            col = col + data.color;\n        } else {\n            col = col - pow(0.5,float(i))*length(data.color);\n        }\n        ray = data.ray;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}