{"ver":"0.1","info":{"id":"Ml33zs","date":"1470874308","viewed":458,"name":"Framebuffer noodles","username":"LukeRissacher","description":"Fun with persistent framebuffers.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["procedural","2d","perlin","framebuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Gradient noise with texture lookups (a little faster than calculated pseudorandom gradients). \n// Adapted from code by Inigo Q.\nvec3 GetGradient(vec3 pos) { \n    vec2 uv = pos.xy + pos.z * vec2(2.159, 0.955);\n    vec3 gradient = 2.0 * texture(iChannel0, uv / 64.0).xyz - 1.0;\n    return normalize(gradient); \n}\n\nfloat TexNoise( in vec3 p ) {\n    vec3 i = floor( p );\n    vec3 f = fract( p ); \n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( GetGradient( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( GetGradient( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( GetGradient( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( GetGradient( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( GetGradient( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( GetGradient( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( GetGradient( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( GetGradient( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat SineMix(float minVal, float maxVal, float t) {\n    return mix(minVal, maxVal, 0.5 + 0.5 * sin(t * 6.283));\n}\n\nvec2 Rotate(vec2 pos, float angle) {\n\treturn vec2(\n\t\tpos.x * cos(angle) - pos.y * sin(angle),\n\t\tpos.x * sin(angle) + pos.y * cos(angle)\n\t);\n}\n\n\nvec3 HueToRgb(float h) {\n    vec3 rgb = 2.0 - abs(6.0 * h - vec3(3, 2, 4));\n    rgb.r = 1.0 - rgb.r;\n    return clamp(rgb, 0.0, 1.0);\n}\n\nvec3 HsvToRgb(vec3 hsv) {\n    vec3 rgb = HueToRgb(hsv.x);\n    return ((rgb - 1.0) * hsv.y + 1.0) * hsv.z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Use framerate-independent time for smoother image\n    float t = float(iFrame) / 30.0 + 116.0;\n    \n    // Get last buffer value, darken and move left\n    vec2 uv = fragCoord / iResolution.xy + vec2(0.002, 0.0);\n    vec3 lastColor = 0.98 * texture(iChannel1, uv).rgb;\n    \n    // Vary noise scale & rotation\n    vec2 noiseScale = vec2(SineMix(1.0, 10.0, 0.06 * t));\n\tvec2 noiseUv = (2.0 * fragCoord.xy - iResolution.xy) / \n        min(iResolution.x, iResolution.y) * noiseScale;\n    noiseUv = Rotate(noiseUv, SineMix(-1.5, 1.5, 0.02 * t));\n     \n    // Sample noise, get 'normal'\n    float noiseZ = 30.0 + 0.1 * t;\n    float noiseVal = TexNoise(vec3(noiseUv, noiseZ));\n    float noiseValDx = TexNoise(vec3(noiseUv + vec2(0.001, 0.0), noiseZ));\n    float noiseValDy = TexNoise(vec3(noiseUv + vec2(0.0, 0.001), noiseZ));\n    vec2 normal = normalize(vec2(noiseValDx - noiseVal, noiseValDy - noiseVal));\n    \n    // Map top percentage of noise to 0..1\n    noiseVal = 0.5 + 0.5 * noiseVal;\n    float emptyPercentage = SineMix(0.55, 0.68, 0.05 * t + 0.65);\n    float edgeTransition = 0.003 * noiseScale.x;\n    float normalizedNoiseVal = clamp((noiseVal - emptyPercentage) / (0.7 - emptyPercentage), 0.0, 1.0);\n     \n    // Apply \"lighting\" around edges\n    vec2 lightDir = normalize(vec2(-1.0, 1.0));\n    float diffuse = mix(0.3, 1.0, clamp(dot(lightDir, normal), 0.0, 1.0));\n    \n    // Map to a color\n    float baseHue = fract(0.05 * t);\n    float hueOffset = 0.5 + 0.25 * sin(0.0133 * t);\n    vec3 color1 = HsvToRgb(vec3(baseHue, 1.0, diffuse));\n    vec3 color2 = HsvToRgb(vec3(fract(baseHue + hueOffset), 1.0, diffuse));\n    vec3 noiseColor = mix(color1, color2, 0.5 + 0.5 * TexNoise(vec3(noiseUv, noiseZ + 100.0)));\n    \n    // Mix current noise shapes with last framebuffer\n    fragColor.rgb = mix(lastColor, noiseColor, \n        smoothstep(emptyPercentage, emptyPercentage + edgeTransition, noiseVal));\n    fragColor.a = 1.0;\n}","name":"Buf A","description":"","type":"buffer"}]}