{"ver":"0.1","info":{"id":"tlfSDH","date":"1652560978","viewed":177,"name":"Octree Optimized","username":"Panoptics","description":"Tried to remove as many branches as possible.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raycast","spheres","octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define F(x) floor(x*S.z+S.w)\n#define steps 100\n#define timediff iTime\n\n#define SPHERES\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define GSIZE 2.0\n#define H_GSIZE int(GSIZE) >> 1\n//0 is empty, 1 is subdivide and 2 is full\nconst vec4 K=vec4(2.0,0.001,0.0,17.34),HH=vec4(13.46,41.74,-73.36,14.24),S=vec4(2.0,1.0,0.5,0.25);\nconst vec3 dimensions = vec3(-.50f,-.50f,-30000.0f);\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    //const vec2 uv = (gl_FragCoord.xy * S.x - resolution.xy) /resolution.y;\n    float s = GSIZE;\n    vec3 uv = vec3((fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y,1.0);\n    vec3 ro = vec3(S.yy+K.zy,timediff);\n    vec3 rd = normalize(uv.xyz);\n        //rd.xz *= u_rot_matrix;\n    \n    if (length(iMouse.xy) > 40.0) {\n        rd.xz *= rot(timediff/16.0*3.14-3.14*0.5);\n        rd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n\n    vec3 rayInvert = vec3(lessThan(rd,K.zzz));\n    vec3 rayDirNorm = mix( rd, -rd, (rayInvert));\n    //const vec3 origNorm = K.zzz;//mix( vec3(0.0),  vec3(0.0)    , (rayInvert));\n    \n    vec3 ird = S.y/rayDirNorm;\n    vec3 tmin = ird*dimensions;\n    vec3 hmax = max( max( tmin, tmin.yzx), tmin.zxy);\n    float dist=length(hmax);\n    ro+=rd*dist;\n\n    vec3 srd = sign(rd);\n    vec3 lro = mod(ro,s);\n    vec3 fro = ro-lro;\n    vec3 mask = K.zzz;\n    int i=steps;\n    float edge = S.y;\n    vec3 lastmask; \n    //the octree traverser loop\n    //each iteration i either:\n    // - check if i need to go up a level\n    // - check if i need to go down a level\n    // - check if i hit a cube\n    // - go one step forward if octree cell is empty\n    // - repeat if i did not hit a cube\n    float vs=K.z;\n    float rs = S.y/s;\n    vec3 dnormal;\n    while ( int(vs<S.x)*--i>0)\n    {\n        float sH = s*S.z;\n        float is = -vs+S.y;\n        s -= vs*sH;\n        vec3 m = step(vec3(s),lro)*s*vs; \n        fro += m;\n        lro -= m;\n        rs *= vs+S.y;\n        vec3 h = ird * -(srd*(lro-sH)-sH);//\n        lastmask = mask = vec3(lessThan(h,min(h.yzx,h.zxy)))*is + (mask*vs);\n        float l = is*dot(h,mask);\n        vec3 msd = mask*srd;\n        dist = l*is+dist;\n\n        vec3 dr = is*msd*s;\n        lro = rd*l-dr+lro;\n        vec3 nf = dr+fro;\n        vec3 fs = nf*rs;\n        bool exitoct = all(bvec2(s<K.x,F(fs)!=F(fro*rs)));\n        fro = nf;\n        \n        while (exitoct)\n        {\n            vec3 msdsaved = msd*S.z;\n            s += s;\n            rs *= S.z;\n            nf = s*F(fs);\n            lro += fro-nf;\n            fro = nf;\n            fs = nf*rs;\n            exitoct = all(lessThan(vec2(s,abs(dot(mod(fs+S.z,S.x)-S.y+msdsaved,mask))),K.xy));\n            --i;\n        }\n        float v=fract(4e4*sin(dot(vec4(fro,s),HH)+K.w));\n        vs = floor(float(!any(bvec2(s<=S.w,all(lessThan(abs(fro.xy),S.yy)))))*(v*v*3.0));\n\n#ifdef SPHERES\n        if (vs==2.0 && s<=S.z*2.0){\n            vec4 sph =vec4( (fro)+s*0.5+v/20.0,s*0.125);\n            float dd= sphIntersect( ro, rd, sph  );\n            dnormal = normalize(sph.xyz-ro+rd*dd);\n            if (dd<0.0 ){\n                vs=1.0;\n            }else{\n                dist=dd;\n            }\n        }else{\n            dnormal = -lastmask*srd;\n        }\n#endif\n    }\n\n    ro += rd*dist;\n#ifndef SPHERES\n    dnormal = normalize(-lastmask*srd);\n#endif  \n    vec3 color = vec3(S.y/dist);\n    vec4 ocolor = vec4(color*(dnormal*S.z+S.y),S.y);\n    fragColor = ocolor;\n\n}\n/*\n#define C const\n#define v3 vec3\n#define v4 vec4 \nC v4 S=v4(2.0,1.0,0.5,0.25),H=v4(13.46,41.74,-73.36,14.24),K=v4(2.0,0.001,0.0,17.34);\n#define F(n)floor(n*S.z+S.w) \n#define LT lessThan\nvoid main(void){\n    int st=150;\n    float vs=K.z,l=K.z,edge=S.y,d=K.z,i,sH;\n    v4 s=v4(K.x,S.y/K.x, (gl_FragCoord.xy*S.x-iResolution.xy)/iResolution.y);\n    v3 rd=normalize(v3(s.zw,S.y)),sr=sign(rd),ir=S.y/max(abs(rd),0.1);\n    v3 ro=v3(K.xx*S.zz+K.yz,iGlobalTime*1.00007),o=mod(ro,s.x),p=ro-o,M=K.zzz,g,h,sd,n,f,m,dr;\n\n    while (int(vs!=2.0)*--st>0){\n        sH=s.x*S.z,s.x-=vs*sH,s.y*=vs+S.y,i=-vs+S.y,m=vs*step(s.xxx,o)*s.x,\n        p+=m,o-=m,h=-(sr*(o-sH)-sH)*ir,g=M=i*v3(LT(h,min(h.yzx,h.zxy)))+M*vs,sd=M*sr,dr=sd*s.x*i,\n        l=i*dot(h,M),d+=i*l,o=l*rd-dr+o,n=dr+p,f=n*s.y;\n        bool up=all(bvec3(s.x<K.x,F(f)!=F(p*s.y),true)); p=n;\n        while (up) {\n            s.xy*=S.xz,n=F(f)*s.x,o+=p-n,f=n*s.y,--st,p=n;\n            up=all(LT(vec2(s.x,abs(dot(mod(f+S.z,S.x)-S.y+sd*S.z,M))),K.xy));\n        }\n        float v=fract(4e4*sin(dot(v4(p,s.x),H)+K.w));\n        vs=int(!any(bvec3(false,s.x<S.z,all(LT(abs(p.xy),S.yy)))))*int(v*v*3.0);\n    }\n    gl_FragColor=pow(v4(v3(S.y/d)*K.x*(-g*sr*S.w+S.y),S.y),S.zzzz);//ro+=rd*d;\n}\n\n#version 430\n#define C const\n#define v3 vec3\n#define v4 vec4 \nuniform float iGlobalTime;\nuniform vec2 iResolution;\nout v4 ocolor;\nC v4 S=v4(2.0,1.0,0.5,0.25),H=v4(13.46,41.74,-73.36,14.24),K=v4(2.0,0.001,0.0,17.34);\n#define F(n)floor(n*S.z+S.w) \n#define rot(a)mat2(cos(a),sin(a),-sin(a),cos(a))\n#define LT lessThan\n//0 is empty,1 is subdivide and 2 is full\nvoid main(){\n    int vs=0,st=150;\n    float l=K.z,edge=S.y,d=K.z,i,sH;\n    v4 s=v4(K.x,S.y/K.x, (gl_FragCoord.xy*S.x-iResolution.xy)/iResolution.y);\n    C v3 rd=normalize(v3(s.zw,S.y)),sr=sign(rd),ir=S.y/max(abs(rd),0.1);\n    v3 ro=v3(K.xx*S.zz+K.yz,0.1),o=mod(ro,s.x),p=ro-o,M=K.zzz,g,h,sd,n,f,m,dr;\n\n    while (int(vs!=2)*--st>0){\n        sH=s.x*S.z,s.x-=vs*sH,s.y*=vs+S.y,i=-vs+S.y,m=vs*step(s.xxx,o)*s.x,\n        p+=m,o-=m,h=-(sr*(o-sH)-sH)*ir,g=M=i*v3(LT(h,min(h.yzx,h.zxy)))+M*vs,sd=M*sr,dr=sd*s.x*i,\n        l=i*dot(h,M),d+=i*l,o=l*rd-dr+o,n=dr+p,f=n*s.y;\n        bool up=all(bvec2(s.x<K.x,F(f)!=F(p*s.y))); p=n;\n        while (up) {\n            s.xy*=S.xz,n=F(f)*s.x,o+=p-n,f=n*s.y,--st,p=n;\n            up=all(LT(vec2(s.x,abs(dot(mod(f+S.z,S.x)-S.y+sd*S.z,M))),K.xy));\n        }\n        float v=fract(4e4*sin(dot(v4(p,s.x),H)+K.w));\n        vs=int(!any(bvec2(s.x<S.z,all(LT(abs(p.xy),S.yy)))))*int(v*v*3.0);\n    }\n    //ro+=rd*d;\n    ocolor=pow(v4(v3(S.y/d)*K.x*(-g*sr*S.w+S.y),S.y),S.zzzz);\n}\n*/\n\n","name":"Image","description":"","type":"image"}]}