{"ver":"0.1","info":{"id":"4f3Szf","date":"1714927451","viewed":91,"name":"function_3D","username":"loki123123","description":"visualise 3d function :)\nhaving problem with pow","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define r iResolution\n#define PI 3.14\n#define lightDir vec3(0.1,0.2,-1.3)\n#define light2Dir vec3(0.1,0.2,1.3)\n#define rot(d) mat2(cos(d),sin(d),-sin(d),cos(d))\n#define it 0.05\n#define maxIters 200\n\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n\nfloat text(vec2 p){  \n    return (texture(iChannel0,.3+p.xy/30.)/1.4).x;\n}\n\nfloat func(vec2 p){\n    return text(p/1.5)*4.;\n    return noise3(p.xyy)*2.;\n    return 1.;\n}\n\n\nvec3 normal(vec2 p) {\n    float delta = 0.01;\n    float fx = (func(p + vec2(delta, 0.0)) - func(p - vec2(delta, 0.0))) / (2.0 * delta);\n    float fy = (func(p + vec2(0.0, delta)) - func(p - vec2(0.0, delta))) / (2.0 * delta);\n    \n    vec3 gradient = vec3(-fx, -fy, 1.0); \n  \n    return normalize(gradient); \n}\n\nfloat absCircular(float t)\n{\n    float a = floor(t + 0.5);\n    return mod((a - t), 1.0);\n}\n\n\nvec3 color(in vec3 pos,in vec3 viewDir){\n    \n    vec3 res = vec3(0.);\n    \n    vec3 ambientColor = vec3(0.7,0.6,0.65);\n    float ambient = .0;\n   \n    \n    vec3 diffuseColor = vec3(.6,.7,.8);\n    float diffuse = 1.3;\n    \n    float above = sign(pos.z-func(pos.xy));\n    \n    //check intersect with z=0\n    vec3 rayPos;\n\n    rayPos = pos-viewDir*(pos.x/viewDir.x);\n    \n\n    if(pos.x/viewDir.x>1. &&  mod(rayPos.y, 1.0) < .04/length(rayPos.y))\n        res= mix(res,vec3(1.)-.7*sign(func(rayPos.xy)-rayPos.z), 1.-pow(smoothstep(0., 0.05, absCircular(rayPos.y)), 1.) );\n    \n    rayPos = pos-viewDir*(pos.y/viewDir.y);\n    \n    if(pos.y/viewDir.y>1.&& mod(rayPos.x, 1.0) < .04/length(rayPos.x))\n        res= mix(res,vec3(1.)-.7*sign(func(rayPos.xy)-rayPos.z), 1.-pow(smoothstep(0., 0.05, absCircular(rayPos.x)), 1.));\n    \n    rayPos = pos-viewDir*(pos.z/viewDir.z);\n    \n    if(pos.z/viewDir.z>1. && (mod(rayPos.x, 1.0) < .04/length(rayPos.x)|| mod(rayPos.y, 1.0) < .02/length(rayPos.y)))\n        res= mix(res,vec3(1.)-.7*sign(func(rayPos.xy)-rayPos.z), 1.-pow(smoothstep(0., 0.05, absCircular(rayPos.y)*pow(smoothstep(0., 0.05, absCircular(rayPos.x)), 2.)), 1.));\n    \n    vec3 lpos = pos;\n    \n    for(int i=0;i++<maxIters;){\n         \n        vec3 normalV = normal(lpos.xy);\n        float Vh = func(lpos.xy)-lpos.z;\n        if(abs(Vh)<it/length(normalV)){\n        \n           float fact = 1.-smoothstep(0.,20.,length(lpos.xy));\n           diffuse = abs(dot(normalize(viewDir+lightDir),normal(lpos.xy)*above));\n           \n           res+=(diffuseColor*diffuse)/1.3*fact;\n           \n           diffuse = abs(dot(normalize(viewDir+light2Dir),normal(lpos.xy)*above));\n           \n           res+=(diffuseColor*diffuse)/1.3*fact;\n          \n           break;\n        }\n        lpos += it*abs(Vh)*viewDir*(-5.+dot(normalV,viewDir));\n        \n        \n    }\n    \n    \n   \n    \n    res/=pow(length(lpos),.1);\n    return res;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 0, 1), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n\nvoid mainImage( out vec4 o, in vec2 c )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = c/r.y;\n    \n    uv-=vec2(.5*r.x/r.y,.5);\n    \n    float camDis = 10.;\n   \n    vec2 mouseInput = iMouse.xy/r.xy-vec2(.5);\n    mouseInput.y = min(max(mouseInput.y,-0.4),-0.2);\n    \n    vec3 camPos = vec3(0.6, 1.,0.1);\n    camPos.xy *= rot( mouseInput.x*2.*PI)*cos(-mouseInput.y*PI);\n    camPos.z = sin(-mouseInput.y*PI);\n    camPos *= camDis;\n    \n    mat3 mat = camera(camPos, vec3(0.));\n    \n    \n   \n    vec3 viewDir = normalize(mat * vec3(-uv.xy, 1.0));\n    o.xyz = color(camPos,normalize(viewDir));\n\n    \n   \n}","name":"Image","description":"","type":"image"}]}