{"ver":"0.1","info":{"id":"4dG3Wh","date":"1454122303","viewed":416,"name":"kingdom","username":"stb","description":"Interactive GLSL version of something I made a long time ago. What do you see?\nControls:\n  mouse: drag & hold to move in a direction\n  1: zoom out;  2: zoom in; 3: decrement iterations; 4: increment iterations","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["procedural","2d","rorschach","pareidolia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\n\tkingdom\n\t2016 stb\n\n    Inspired by the Rorschach test.\n    \n\tFor smoother performance:\n\t\t* close all other programs\n\t\t* enter/exit fullscreen mode (helps on my system)\n\t\t* set UseBNoise to true\n\n\tFYI: IE produces a strange, intended bump effect when using simplex noise.\n*/\n\nconst bool UseBNoise = false; // use basic noise? (bnoise is faster than simplex noise, but not necesarily better)\nconst bool Colorize  = true;  // apply coloring & vignette?\nconst float ZOffset  = 0.07;  // z translation of noise, offset by x (lower values = more repetition)\nconst float YScale   = 0.35;  // global y-scaling\nconst float NScale   = 1.0;   // noise scale (not for zooming)\n\nfloat s, c;\n#define rotateTo(p, v) mat2(c=v.y, s=v.x, -s, c) * p\n\nfloat line(in vec2 p, vec2 p0, vec2 p1, float thk) {\n    p -= p0;\n    p = rotateTo(p, normalize(p1-p0));\n    return float(p.y<0. || p.y>length(p1-p0) ? 0. : max(0., 1.-length(p.x)/thk));\n}\n\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\nvec3 mod289(vec3 x) {\n  return x - floor(x/289.) * 289.;\n}\nvec4 mod289(vec4 x) {\n  return x - floor(x/289.) * 289.;\n}\nvec4 permute(vec4 x) {\n     return mod289((x*34.+1.)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - .85373472095314 * r;\n}\n// 3D simplex noise\nfloat snoise(vec3 v) { \n    const vec2  C = vec2(1./6., 1./3.) ;\n    const vec4  D = vec4(0., .5, 1., 2.);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1. - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0., i1.z, i2.z, 1. ))\n\t\t\t+ i.y + vec4(0., i1.y, i2.y, 1. )) \n\t\t\t+ i.x + vec4(0., i1.x, i2.x, 1. ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = .142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49. * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7. * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1. - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2. + 1.;\n    vec4 s1 = floor(b1)*2. + 1.;\n    vec4 sh = -step(h, vec4(0.));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n    m = m * m;\n    return 42. * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat bnoise(vec3 p) {\n    p *= 2.;\n    #define h(x, y, z) 2. * (.5-hash13(floor(p)+vec3(x, y, z)))\n    float n[8];\n    n[0] = h(0., 0., 0.);\n    n[1] = h(1., 0., 0.);\n    n[2] = h(0., 1., 0.);\n    n[3] = h(1., 1., 0.);\n    n[4] = h(0., 0., 1.);\n    n[5] = h(1., 0., 1.);\n    n[6] = h(0., 1., 1.);\n    n[7] = h(1., 1., 1.);\n    vec3 fp = smoothstep(0., 1., fract(p));\n    return\n        mix(\n            mix(\n                mix(n[0], n[1], fp.x),\n                mix(n[2], n[3], fp.x),\n                fp.y\n            ),\n            mix(\n                mix(n[4], n[5], fp.x),\n                mix(n[6], n[7], fp.x),\n                fp.y\n            ),\n            fp.z\n\t\t);\n}\n\n#define dataAt(x, y) texture(iChannel0, vec2(x, y)/res)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec2 p = fragCoord / res.y;\n    \n    vec2 scrollPos = dataAt(.5, .5).rg / res;\n    float zoom = dataAt(.5, .5).b;\n    vec2 mPos0 = dataAt(1.5, .5).rg;\n    vec2 mPos1 = iMouse.xy;\n    float iters = dataAt(1.5, .5).b;\n    \n    // draw line\n    float l = 0.;\n    if(dataAt(.5, .5).a>0. && !(mPos0.x==mPos1.x && mPos0.y==mPos1.y))\n        l = line(p, mPos0/res.y, mPos1/res.y, 2./res.x);\n    \n    // new p transformed with data from Buf A\n    p = (uv-scrollPos*res.y-.5) / zoom * vec2(res.x/res.y, 1.);\n    \n    vec3 xyz;\n    \n    float f = 0.;\n    vec3 col = vec3(0.);\n    for(float i=0.; i<16.; i++) {\n        float sPow = pow(2., i);\n        xyz = 5. * vec3(abs(fract(3.*p.x*sPow)-.5), p.y*sPow/YScale, ZOffset*p.x*sPow-i) / NScale;\n        if(UseBNoise)\n            f += bnoise(xyz) / pow(1.3, i);\n        else\n        \tf += snoise(xyz) / pow(1.3, i);\n        \n        if(i>=iters)\n            break;\n    }\n    \n    // control contrast here\n    f = mix(1. ,f, .25);\n\t\n    if(Colorize) {\n        uv = uv - .5;\n        float vig = 1.2 * dot(uv, uv);\n        vec3 nCol1  = vec3(.2, .05, 0.);\n        vec3 nCol2  = vec3(1.2, 1.1, .85);\n        vec3 vigCol = vec3(1., .5, 0.);\n        fragColor = vec4(mix(nCol1, nCol2, f)/(1.1+vig)+vec3(l)-vig*vigCol, 1.0);\n    }\n    else\n        fragColor = vec4(vec3(f+l), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\t2D navigation using mouse & keys.\n*/\n\nconst int   ItersDefault = 4;\nconst float ZoomDefault  = 2.0;\nconst float ZoomSpeed    = 0.025;\nconst float ScrollSpeed  = 0.025;\nconst float ScrollDrift  = 32.0;\n\nconst float KEY_1 = 49.5 / 256.;\nconst float KEY_2 = 50.5 / 256.;\nconst float KEY_3 = 51.5 / 256.;\nconst float KEY_4 = 52.5 / 256.;\n\n#define dataAt(x, y) texture(iChannel0, vec2(x, y)/res)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 res = iResolution.xy;\n    vec2 uv  = fragCoord / res;\n    \n    vec2 scrollPos, mPos0;\n    float zoom, mIsHeld, iters;\n    \n    // initial state\n    if(iFrame==0) {\n        scrollPos = vec2(0.);\n        zoom      = ZoomDefault;\n        mIsHeld   = 0.;\n        mPos0     = iMouse.xy;\n        iters     = float(ItersDefault);\n    }\n    // running state\n    else {\n        // get stored variables\n        scrollPos = dataAt(.5, .5).rg;\n        zoom      = dataAt(.5, .5).b;\n        mIsHeld   = dataAt(.5, .5).a;\n        mPos0     = dataAt(1.5, .5).rg;\n        iters     = dataAt(1.5, .5).b;\n        \n        // new time-based variables (to make them frame-based, set td to 1.0)\n        float td = 60. * iTimeDelta;\n        float zoomSpeed   = ZoomSpeed * td;\n        float scrollSpeed = ScrollSpeed * td;\n        float scrollDrift = ScrollDrift * td;\n        \n        // mouse handling\n        if(iMouse.z>0.) {\n            if(mIsHeld==0.)\n                mPos0 = iMouse.xy;\n            \n            mIsHeld = 1.;\n        }\n        else {\n            // scroll drifting\n            //mPos0 = mix(mPos0, iMouse.xy, min(1., 1./scrollDrift));\n            mPos0 = mix(mPos0, iMouse.xy, min(1., 1./scrollDrift));\n            \n            mIsHeld = 0.;\n        }\n        \n        // modified zoom speed\n        float zs = 1. + zoomSpeed;\n        \n        // zoom out\n        if(texture(iChannel3, vec2(KEY_1, 0.)).r>0.) {\n            zoom /= zs;\n            scrollPos /= zs;\n        }\n        \n        // zoom in\n        if(texture(iChannel3, vec2(KEY_2, 0.)).r>0.) {\n            zoom *= zs;\n            scrollPos *= zs;\n        }\n        \n        // decrement iterations\n        if(texture(iChannel3, vec2(KEY_3, 1./3.)).r>0.)\n            iters = max(1., iters-1.);\n        \n        // increment iterations\n        if(texture(iChannel3, vec2(KEY_4, 1./3.)).r>0.)\n            iters = min(15., iters+1.);\n        \n        // update scroll position\n    \tscrollPos -= scrollSpeed / res.y * (iMouse.xy-mPos0) * pow(.025*length(iMouse.xy-mPos0), 1.5);\n    }\n    \n    // save data\n    if(vec2(0., 0.)==floor(fragCoord))\n    \tfragColor = vec4(scrollPos, zoom, mIsHeld);\n    if(vec2(1., 0.)==floor(fragCoord))\n    \tfragColor = vec4(mPos0, iters, 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}