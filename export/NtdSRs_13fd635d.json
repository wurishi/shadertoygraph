{"ver":"0.1","info":{"id":"NtdSRs","date":"1639603442","viewed":70,"name":"Raymarching #CCD Shadows","username":"mghermida18","description":"Ejemplo de ray marching para la asignatura CCD","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","basic"],"hasliked":0,"parentid":"slcXzs","parentname":"Raymarching #Color"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Funciones de distancia de Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\nvec2 opSmoothUnion( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h),min(d1.y,d2.y)); }\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 opUnion(vec2 a, vec2 b) {\n    return (a.x<b.x) ? a : b;\n}\n\nmat3 rotateZ() {\n    vec2 one = vec2(1.0,0.0);\n    return mat3(-one.yxy,one.xyy,-one.yyx);\n}\n\nvec2 map(in vec3 p) {\n    float an = 1.6;\n    vec2 c = vec2(sin(an),cos(an));\n    vec2 res = vec2(sdCappedTorus(rotateZ()*p-rotateZ()*vec3(0.1,0.5,0.0), c, 0.4,0.1),1.0);\n    res = opUnion(res,vec2(sdCappedTorus(rotateZ()*p-rotateZ()*vec3(-0.6,0.5,0.0), c, 0.4,0.1),1.0));\n    res = opUnion(res,vec2(sdCappedTorus((-rotateZ())*p-(-rotateZ())*vec3(0.6,0.5,0.0), c, 0.4,0.1),1.0));\n    res = opSmoothUnion(res,vec2(sdVerticalCapsule(p-vec3(0.6,0.1,0.0),0.8,0.11)),0.01);\n    res = opUnion(res,vec2(sdPlane(p),4.0));\n    return res;\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd ) {\n    float tmin = 1.0;\n    float tmax = 30.0;\n    \n    #if 1\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n    #endif\n    \n    float t = tmin;\n    int maxIters = 170;\n    \n    vec2 res = vec2(-1.0);\n    \n    for( int i = 0; i < maxIters && t < tmax ; i++ ) {\n        vec2 h = map( ro + rd*t );\n        if( abs(h.x) < (0.0001*t) ){\n            res = vec2(t,h.y);\n            break;\n        }\n        t = t + h.x;\n    }\n    \n    return res;\n}\n#define ZERO (min(iFrame,0))\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3  pos ) // for function f(p)\n{\n    const float h = 0.0001;      // replace by an appropriate value\n     // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h).x;\n    }\n    return normalize(n);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    \n    vec2 res = raycast(ro,rd);\n    vec3 pos = ro+res.x*rd;\n    float t = res.x;\n    vec3 col = vec3(0.1, 0.1, 0.1);\n    vec3 normal = calcNormal(pos);\n    \n    // Luz\n    if(res.y > -0.5)\n    {\n       vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );;\n       vec3 p = vec3(0.2,0.4,0.6);\n       vec3 hal = normalize(lig-rd);\n       float dif = clamp( dot(normal,p), 0.15, 1.0);\n       dif *= calcSoftshadow( pos, lig, 0.01, 3.0,18.);\n       float spe = pow( clamp( dot( normal, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n       vec3 mate = res.y > 2.0 ? vec3(0.63, 0.63, 0.63) : vec3(0.55, 0.97, 0.46);\n       col += mate * 1.2*dif*vec3(0.89, 0.83, 0.85);\n       col +=      12.0*spe*vec3(1.00,0.70,0.5);\n    \n    }\n    col *= exp( -0.0005*t*t*t );\n    return vec3( clamp(col,0.0,1.0) );\n}\n\n// Transformacion de un vector en espacio de la camara, al espacio del mundo.\nmat3 camera2World(in vec3 co, in vec3 ta, float rotation) {\n    vec3 h = vec3(sin(rotation),cos(rotation),0.0);\n    vec3 i = normalize(ta-co);\n    vec3 j = normalize(cross(i,h));\n    vec3 k = cross(j,i);\n    return mat3(j,k,i);                                                                                                                            \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camara target o objetivo\n    vec3 ta = vec3(-0.1,0.4,0.0);\n    float angle = -0.5;\n    float dist = 2.0;\n    // Camara origen (camera-origin)\n    vec3 co = vec3(dist*sin(angle),1.0,dist*cos(angle));\n    \n    mat3 ca = camera2World(co,ta,0.0f);\n    \n    vec2 p = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    // Longitud de la lente de la camara.\n    const float fl = 2.4f;\n    \n    vec3 rd = ca * normalize(vec3(p,fl));\n    vec3 col = render(co,rd);\n    //vec3 col = rd.xyz;\n    //vec3 col = vec3(rd.xy,1.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}