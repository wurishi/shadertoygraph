{"ver":"0.1","info":{"id":"ftK3Wt","date":"1639649231","viewed":64,"name":"Wrap Lighting ","username":"CesarMolto","description":"Simple subsurface scattering implementation based on wrap lighting.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["subsurfacescattering","wraplighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\n/*** BASIC OPERATORS ***/\nmat2 Rotate(float angle)\n{\n    float sinus = sin(angle);\n    float cosin = cos(angle);\n    \n    return mat2(cosin, -sinus, sinus, cosin);\n}\n\n/*** BASIC GEOMETRIC SHAPES SDFs ***/\nfloat sdfSphere(vec3 marchingPos, vec3 spherePos, float radius)\n{\n    return length(marchingPos - spherePos) - radius;\n}\n\n\n/*** RAYMARCHING ALGORITHM CORE METHODS ***/\n// Returns the distance between a specific space position and its closest scene element\nfloat GetDist(vec3 marchingPos)\n{    \n    float sphereSdf = sdfSphere(marchingPos, vec3(0, 2, 7), 1.);\n    float planeSdf = marchingPos.y; // Plane is at position y = 0\n    \n    float distToScene = min(sphereSdf, planeSdf);\n    \n    return distToScene;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float distFromOrigin = 0.0;\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 marchingPos = rayOrigin + rayDirection * distFromOrigin;\n        float distToScene = GetDist(marchingPos);\n        \n        distFromOrigin += distToScene;\n        \n        if (distFromOrigin > MAX_DIST || distToScene < SURF_DIST)\n            break;\n    }\n    \n    return distFromOrigin;\n}\n\n\n/** METHODS FOR LIGHTNING AND SHADOWING ***/\n// Returns the normal vector for a specific space point position in the scene\nvec3 GetNormal(vec3 point)\n{\n    float distance = GetDist(point);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 normalVector = distance - vec3(GetDist(point-e.xyy), \n                                        GetDist(point-e.yxy), \n                                        GetDist(point-e.yyx));\n                                        \n    return normalize(normalVector);\n}\n\n// Returns the light value for a specific space point position in the scene\nfloat GetLight(vec3 point)\n{ \n    // Diffuse lighting\n    vec3 lightPos = vec3(-3, 2, 7);\n    // lightPos.xz *= Rotate(iTime);\n    \n    vec3 lightVector = normalize(lightPos - point);\n    vec3 normalVector = GetNormal(point);\n    \n    // Wrap lighting\n    float wrap = iMouse.x / iResolution.x;\n    \n    float diffLight = max(0., ((dot(normalVector, lightVector) + wrap) / (1. + wrap)));\n    \n    // Shadows\n    float distance = RayMarch(point + normalVector * SURF_DIST * 2.0, lightVector);\n    if (distance < length(lightPos - point))\n        diffLight *= 0.1;\n    \n    return diffLight;\n}\n\n\n/*** MAIN METHOD ***/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    vec3 rayOrigin = vec3(0.0, 2.0, 0.0); // AKA Camera position\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    float distance = RayMarch(rayOrigin, rayDirection);\n    \n    vec3 intersectPoint = rayOrigin + rayDirection * distance;\n    \n    float diffLight = GetLight(intersectPoint);\n\n    col = vec3(diffLight);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}