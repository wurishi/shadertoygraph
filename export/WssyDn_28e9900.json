{"ver":"0.1","info":{"id":"WssyDn","date":"1584885648","viewed":175,"name":"Torus Knot Plane Intersection 2","username":"arifr123","description":"Click to magnify.\nDrag the mouse to override the animation and to return to the table.\nBased on my shaders [url]https://www.shadertoy.com/view/wtcSW2[/url] and [url]https://www.shadertoy.com/view/tslcz7[/url].","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["gradientdescent","torusknot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433\n\n#define sq(x) dot(x, x)\n\nvec2 sic(float t)\n{\n    return vec2(cos(t), sin(t));\n}\nvec2 perp(vec2 v)\n{\n    return (v * vec2(1, -1)).yx;\n}\n\nstruct TorusKnotParameters\n{\n    float kp;\n    float kq;\n    float r1;\n    float r2;\n    float r3;\n};\n\nvec3 torusKnot(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    return vec3((sicRZ.x + tkp.r1)*sicXY, sicRZ.y);\n}\nvec3 torusKnotDerivative(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    vec2 dSicXY = tkp.kp * vec2(-1, 1) * sicXY.yx;\n    vec2 dSicRZ = tkp.kq * vec2(-1, 1) * sicRZ.yx;\n    \n    return vec3(dSicRZ.x*sicXY + dSicXY*(sicRZ.x + tkp.r1), dSicRZ.y);\n}\n\nfloat torusKnotSqDistance(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return sq(torusKnot(t, tkp) - p);\n}\nfloat torusKnotSqDistanceDerivative(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return 2.*dot(torusKnot(t, tkp) - p, torusKnotDerivative(t, tkp));\n}\n\nstruct Ray\n{\n  vec3 ro;\n  vec3 rd;\n};\n\nvec3 torusKnotSqDistanceMinimumInside(vec3 p, TorusKnotParameters tkp)\n{\n    //all hard coded numbers depend on the 'r's\n    \n    int sections = int(2.*max(tkp.kq,tkp.kp));\n    float sectionLength = 2.*PI/float(sections);\n    \n    float lerningRate = 1.5/(max(tkp.kq,tkp.kp));\n    const int maxIterations = 50;//50\n    \n    float minDist;\n    float bestT;\n    \n    for(int j = 0; j < sections; j++)\n    {\n        float t = sectionLength * float(j);\n        \n        for(int i = 0; i < maxIterations; i++)\n        {\n            float dt = torusKnotSqDistanceDerivative(t, p, tkp);\n            dt *= lerningRate;\n            \n            if(abs(dt) < 0.001)\n            {\n                float sqDist = torusKnotSqDistance(t, p, tkp);\n        \n                if(sqDist <= sq(tkp.r3))\n                {\n                    return vec3(t, sqDist, 1.);\n                }\n                \n                break;\n            }\n            \n            t -= dt;\n            \n            \n            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))\n            {\n                break;\n            }\n        }\n    }\n    \n    return vec3(0.);\n}\n\nint gcd(ivec2 v)\n{\n    while(v.x != v.y)\n    {\n        if(v.x > v.y)\n            v.x -= v.y;\n        else\n            v.y -= v.x;\n    }\n    \n    return v.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 table = vec2(5, 3);\n    \n    vec2 uv = table*fragCoord/iResolution.xy;\n    ivec2 kpkq = ivec2(uv) + 1;\n    kpkq = kpkq.yx;\n    uv = mod(uv, 1.);\n    uv -= 0.5;\n    \n    //uv.x = table.x*fragCoord.x/iResolution.x\n    uv.x *= iResolution.x*table.y/(table.x*iResolution.y);\n\t\n    const float clickSize = 0.;\n    if(iMouse.z < 0. && length(iMouse.xy + iMouse.zw) <= clickSize)//ivec2(iMouse.xy*table/iResolution.xy) == ivec2(-iMouse.zw*table/iResolution.xy)\n    {\n\t\tuv = (fragCoord - iResolution.xy/2.)/iResolution.y;\n        kpkq = ivec2(table*iMouse.xy/iResolution.xy) + 1;\n        kpkq = kpkq.yx;\n    }\n\n    vec2 angles = /*false &&*/ iMouse.z > 0. ? PI*(2.*iMouse.xy/iResolution.xy - 1.) : 1.5*iTime*vec2(0.7, 1);//PI*vec2(0.25, 0.25)*(sic(iTime) + vec2(0, 1))\n    vec2 sic0 = sic(angles[0]);\n    vec2 sic1 = sic(angles[1]);\n    \n    vec3 f = vec3(sic1.x * sic0, sic1.y);\n    vec3 r = vec3(perp(sic0), 0);\n    vec3 u = cross(f, r);\n    \n    ////////////////////////////////////The torus knot parameters//////////////////////////////////////////\n    float kp = 3., kq = 4., r1 = 0.25, r2 = 0.125, r3 = 0.065;// + 0.3*(sin(iTime)+1.)/2.;//Change kp and kq!\n    // p and q are flipped. The parameters: 'lerningRate', 'maxIterations' and 'sections' also may need to be changed.\n    \n    //ivec2 kpkq = ivec2(10.*iMouse.xy/iResolution.xy) + 1;\n    \n    kpkq /= gcd(kpkq);\n    \n    kp = float(kpkq.x);\n    kq = float(kpkq.y);\n    \n    \n    TorusKnotParameters tkp = TorusKnotParameters(kp, kq, r1, r2, r3);\n    \n    vec3 p = uv.x*r + uv.y*f;\n    \n    vec3 res = torusKnotSqDistanceMinimumInside(p, tkp);\n    \n    vec3 col = vec3(0);\n    \n    \n    if(res[2] > 0.5)\n    {\n        uv.x *= table.x*iResolution.y/(iResolution.x*table.y);\n        \n        p = (uv.x*r + uv.y*f);//square of size 1x1x1\n        \n        col = 2.*p + 0.5;\n        \n        float len = length(col);\n        col = normalize(col);\n        \n        //col = vec3(vec2(kpkq)/(table+1.), 0);\n        \n        col *= smoothstep(tkp.r3, tkp.r3 - 1./iResolution.y, sqrt(res[1]));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}